<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITPropertyAccess32_64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #if ENABLE(JIT)
  29 #if USE(JSVALUE32_64)
  30 #include &quot;JIT.h&quot;
  31 
  32 #include &quot;CodeBlock.h&quot;
  33 #include &quot;DirectArguments.h&quot;
  34 #include &quot;GCAwareJITStubRoutine.h&quot;
  35 #include &quot;InterpreterInlines.h&quot;
  36 #include &quot;JITInlines.h&quot;
  37 #include &quot;JSArray.h&quot;
  38 #include &quot;JSFunction.h&quot;
  39 #include &quot;JSLexicalEnvironment.h&quot;
  40 #include &quot;LinkBuffer.h&quot;
  41 #include &quot;OpcodeInlines.h&quot;
  42 #include &quot;ResultType.h&quot;
  43 #include &quot;SlowPathCall.h&quot;
  44 #include &quot;StructureStubInfo.h&quot;
  45 #include &lt;wtf/StringPrintStream.h&gt;
  46 
  47 
  48 namespace JSC {
  49 
  50 void JIT::emit_op_put_getter_by_id(const Instruction* currentInstruction)
  51 {
  52     auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterById&gt;();
  53     VirtualRegister base = bytecode.m_base;
  54     int property = bytecode.m_property;
  55     int options = bytecode.m_attributes;
  56     VirtualRegister getter = bytecode.m_accessor;
  57 
  58     emitLoadPayload(base, regT1);
  59     emitLoadPayload(getter, regT3);
  60     callOperation(operationPutGetterById, m_codeBlock-&gt;globalObject(), regT1, m_codeBlock-&gt;identifier(property).impl(), options, regT3);
  61 }
  62 
  63 void JIT::emit_op_put_setter_by_id(const Instruction* currentInstruction)
  64 {
  65     auto bytecode = currentInstruction-&gt;as&lt;OpPutSetterById&gt;();
  66     VirtualRegister base = bytecode.m_base;
  67     int property = bytecode.m_property;
  68     int options = bytecode.m_attributes;
  69     VirtualRegister setter = bytecode.m_accessor;
  70 
  71     emitLoadPayload(base, regT1);
  72     emitLoadPayload(setter, regT3);
  73     callOperation(operationPutSetterById, m_codeBlock-&gt;globalObject(), regT1, m_codeBlock-&gt;identifier(property).impl(), options, regT3);
  74 }
  75 
  76 void JIT::emit_op_put_getter_setter_by_id(const Instruction* currentInstruction)
  77 {
  78     auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterSetterById&gt;();
  79     VirtualRegister base = bytecode.m_base;
  80     int property = bytecode.m_property;
  81     int attributes = bytecode.m_attributes;
  82     VirtualRegister getter = bytecode.m_getter;
  83     VirtualRegister setter = bytecode.m_setter;
  84 
  85     emitLoadPayload(base, regT1);
  86     emitLoadPayload(getter, regT3);
  87     emitLoadPayload(setter, regT4);
  88     callOperation(operationPutGetterSetter, m_codeBlock-&gt;globalObject(), regT1, m_codeBlock-&gt;identifier(property).impl(), attributes, regT3, regT4);
  89 }
  90 
  91 void JIT::emit_op_put_getter_by_val(const Instruction* currentInstruction)
  92 {
  93     auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterByVal&gt;();
  94     VirtualRegister base = bytecode.m_base;
  95     VirtualRegister property = bytecode.m_property;
  96     int32_t attributes = bytecode.m_attributes;
  97     VirtualRegister getter = bytecode.m_accessor;
  98 
  99     emitLoadPayload(base, regT2);
 100     emitLoad(property, regT1, regT0);
 101     emitLoadPayload(getter, regT3);
 102     callOperation(operationPutGetterByVal, m_codeBlock-&gt;globalObject(), regT2, JSValueRegs(regT1, regT0), attributes, regT3);
 103 }
 104 
 105 void JIT::emit_op_put_setter_by_val(const Instruction* currentInstruction)
 106 {
 107     auto bytecode = currentInstruction-&gt;as&lt;OpPutSetterByVal&gt;();
 108     VirtualRegister base = bytecode.m_base;
 109     VirtualRegister property = bytecode.m_property;
 110     int32_t attributes = bytecode.m_attributes;
 111     VirtualRegister setter = bytecode.m_accessor;
 112 
 113     emitLoadPayload(base, regT2);
 114     emitLoad(property, regT1, regT0);
 115     emitLoadPayload(setter, regT3);
 116     callOperation(operationPutSetterByVal, m_codeBlock-&gt;globalObject(), regT2, JSValueRegs(regT1, regT0), attributes, regT3);
 117 }
 118 
 119 void JIT::emit_op_del_by_id(const Instruction* currentInstruction)
 120 {
 121     auto bytecode = currentInstruction-&gt;as&lt;OpDelById&gt;();
 122     VirtualRegister dst = bytecode.m_dst;
 123     VirtualRegister base = bytecode.m_base;
 124     int property = bytecode.m_property;
 125     emitLoad(base, regT1, regT0);
 126     callOperation(operationDeleteByIdJSResult, dst, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), m_codeBlock-&gt;identifier(property).impl());
 127 }
 128 
 129 void JIT::emit_op_del_by_val(const Instruction* currentInstruction)
 130 {
 131     auto bytecode = currentInstruction-&gt;as&lt;OpDelByVal&gt;();
 132     VirtualRegister dst = bytecode.m_dst;
 133     VirtualRegister base = bytecode.m_base;
 134     VirtualRegister property = bytecode.m_property;
 135     emitLoad2(base, regT1, regT0, property, regT3, regT2);
 136     callOperation(operationDeleteByValJSResult, dst, m_codeBlock-&gt;globalObject(), JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));
 137 }
 138 
 139 void JIT::emit_op_get_by_val(const Instruction* currentInstruction)
 140 {
 141     auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();
 142     auto&amp; metadata = bytecode.metadata(m_codeBlock);
 143     VirtualRegister dst = bytecode.m_dst;
 144     VirtualRegister base = bytecode.m_base;
 145     VirtualRegister property = bytecode.m_property;
 146     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
 147 
 148     emitLoad2(base, regT1, regT0, property, regT3, regT2);
 149 
 150     if (metadata.m_seenIdentifiers.count() &gt; Options::getByValICMaxNumberOfIdentifiers()) {
 151         auto notCell = branchIfNotCell(regT1);
 152         emitArrayProfilingSiteWithCell(regT0, regT4, profile);
 153         notCell.link(this);
 154         callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByVal, dst, TrustedImmPtr(m_codeBlock-&gt;globalObject()), JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));
 155     } else {
 156         emitJumpSlowCaseIfNotJSCell(base, regT1);
 157         emitArrayProfilingSiteWithCell(regT0, regT4, profile);
 158 
 159         JITGetByValGenerator gen(
 160             m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),
 161             JSValueRegs::payloadOnly(regT0), JSValueRegs(regT3, regT2), JSValueRegs(regT1, regT0));
 162         if (isOperandConstantInt(property))
 163             gen.stubInfo()-&gt;propertyIsInt32 = true;
 164         gen.generateFastPath(*this);
 165         addSlowCase(gen.slowPathJump());
 166         m_getByVals.append(gen);
 167 
 168         emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 169         emitStore(dst, regT1, regT0);
 170     }
 171 }
 172 
 173 void JIT::emitSlow_op_get_by_val(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 174 {
 175     if (hasAnySlowCases(iter)) {
 176         auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();
 177         VirtualRegister dst = bytecode.m_dst;
 178         auto&amp; metadata = bytecode.metadata(m_codeBlock);
 179         ArrayProfile* profile = &amp;metadata.m_arrayProfile;
 180 
 181         JITGetByValGenerator&amp; gen = m_getByVals[m_getByValIndex];
 182         ++m_getByValIndex;
 183 
 184         linkAllSlowCases(iter);
 185 
 186         Label coldPathBegin = label();
 187         Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByValOptimize, dst, TrustedImmPtr(m_codeBlock-&gt;globalObject()), gen.stubInfo(), profile, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));
 188         gen.reportSlowPathCall(coldPathBegin, call);
 189     }
 190 }
 191 
 192 void JIT::emit_op_put_by_val_direct(const Instruction* currentInstruction)
 193 {
 194     emit_op_put_by_val&lt;OpPutByValDirect&gt;(currentInstruction);
 195 }
 196 
 197 template&lt;typename Op&gt;
 198 void JIT::emit_op_put_by_val(const Instruction* currentInstruction)
 199 {
 200     auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
 201     auto&amp; metadata = bytecode.metadata(m_codeBlock);
 202     VirtualRegister base = bytecode.m_base;
 203     VirtualRegister property = bytecode.m_property;
 204     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
 205     ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
 206 
 207     emitLoad2(base, regT1, regT0, property, regT3, regT2);
 208 
 209     emitJumpSlowCaseIfNotJSCell(base, regT1);
 210     PatchableJump notIndex = patchableBranch32(NotEqual, regT3, TrustedImm32(JSValue::Int32Tag));
 211     addSlowCase(notIndex);
 212     emitArrayProfilingSiteWithCell(regT0, regT1, profile);
 213 
 214     PatchableJump badType;
 215     JumpList slowCases;
 216 
 217     // FIXME: Maybe we should do this inline?
 218     addSlowCase(branchTest32(NonZero, regT1, TrustedImm32(CopyOnWrite)));
 219     and32(TrustedImm32(IndexingShapeMask), regT1);
 220 
 221     JITArrayMode mode = chooseArrayMode(profile);
 222     switch (mode) {
 223     case JITInt32:
 224         slowCases = emitInt32PutByVal(bytecode, badType);
 225         break;
 226     case JITDouble:
 227         slowCases = emitDoublePutByVal(bytecode, badType);
 228         break;
 229     case JITContiguous:
 230         slowCases = emitContiguousPutByVal(bytecode, badType);
 231         break;
 232     case JITArrayStorage:
 233         slowCases = emitArrayStoragePutByVal(bytecode, badType);
 234         break;
 235     default:
 236         CRASH();
 237         break;
 238     }
 239 
 240     addSlowCase(badType);
 241     addSlowCase(slowCases);
 242 
 243     Label done = label();
 244 
 245     m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeIndex, notIndex, badType, mode, profile, done, done));
 246 }
 247 
 248 template &lt;typename Op&gt;
 249 JIT::JumpList JIT::emitGenericContiguousPutByVal(Op bytecode, PatchableJump&amp; badType, IndexingType indexingShape)
 250 {
 251     auto&amp; metadata = bytecode.metadata(m_codeBlock);
 252     VirtualRegister base = bytecode.m_base;
 253     VirtualRegister value = bytecode.m_value;
 254     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
 255 
 256     JumpList slowCases;
 257 
 258     badType = patchableBranch32(NotEqual, regT1, TrustedImm32(ContiguousShape));
 259 
 260     loadPtr(Address(regT0, JSObject::butterflyOffset()), regT3);
 261     Jump outOfBounds = branch32(AboveOrEqual, regT2, Address(regT3, Butterfly::offsetOfPublicLength()));
 262 
 263     Label storeResult = label();
 264     emitLoad(value, regT1, regT0);
 265     switch (indexingShape) {
 266     case Int32Shape:
 267         slowCases.append(branchIfNotInt32(regT1));
 268         store32(regT0, BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
 269         store32(regT1, BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
 270         break;
 271     case ContiguousShape:
 272         store32(regT0, BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
 273         store32(regT1, BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
 274         emitLoad(base, regT2, regT3);
 275         emitWriteBarrier(base, value, ShouldFilterValue);
 276         break;
 277     case DoubleShape: {
 278         Jump notInt = branchIfNotInt32(regT1);
 279         convertInt32ToDouble(regT0, fpRegT0);
 280         Jump ready = jump();
 281         notInt.link(this);
 282         moveIntsToDouble(regT0, regT1, fpRegT0, fpRegT1);
 283         slowCases.append(branchIfNaN(fpRegT0));
 284         ready.link(this);
 285         storeDouble(fpRegT0, BaseIndex(regT3, regT2, TimesEight));
 286         break;
 287     }
 288     default:
 289         CRASH();
 290         break;
 291     }
 292 
 293     Jump done = jump();
 294 
 295     outOfBounds.link(this);
 296     slowCases.append(branch32(AboveOrEqual, regT2, Address(regT3, Butterfly::offsetOfVectorLength())));
 297 
 298     emitArrayProfileStoreToHoleSpecialCase(profile);
 299 
 300     add32(TrustedImm32(1), regT2, regT1);
 301     store32(regT1, Address(regT3, Butterfly::offsetOfPublicLength()));
 302     jump().linkTo(storeResult, this);
 303 
 304     done.link(this);
 305 
 306     return slowCases;
 307 }
 308 
 309 template &lt;typename Op&gt;
 310 JIT::JumpList JIT::emitArrayStoragePutByVal(Op bytecode, PatchableJump&amp; badType)
 311 {
 312     auto&amp; metadata = bytecode.metadata(m_codeBlock);
 313     VirtualRegister base = bytecode.m_base;
 314     VirtualRegister value = bytecode.m_value;
 315     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
 316 
 317     JumpList slowCases;
 318 
 319     badType = patchableBranch32(NotEqual, regT1, TrustedImm32(ArrayStorageShape));
 320 
 321     loadPtr(Address(regT0, JSObject::butterflyOffset()), regT3);
 322     slowCases.append(branch32(AboveOrEqual, regT2, Address(regT3, ArrayStorage::vectorLengthOffset())));
 323 
 324     Jump empty = branch32(Equal, BaseIndex(regT3, regT2, TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), TrustedImm32(JSValue::EmptyValueTag));
 325 
 326     Label storeResult(this);
 327     emitLoad(value, regT1, regT0);
 328     store32(regT0, BaseIndex(regT3, regT2, TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload))); // payload
 329     store32(regT1, BaseIndex(regT3, regT2, TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag))); // tag
 330     Jump end = jump();
 331 
 332     empty.link(this);
 333     emitArrayProfileStoreToHoleSpecialCase(profile);
 334     add32(TrustedImm32(1), Address(regT3, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
 335     branch32(Below, regT2, Address(regT3, ArrayStorage::lengthOffset())).linkTo(storeResult, this);
 336 
 337     add32(TrustedImm32(1), regT2, regT0);
 338     store32(regT0, Address(regT3, ArrayStorage::lengthOffset()));
 339     jump().linkTo(storeResult, this);
 340 
 341     end.link(this);
 342 
 343     emitWriteBarrier(base, value, ShouldFilterValue);
 344 
 345     return slowCases;
 346 }
 347 
 348 template &lt;typename Op&gt;
 349 JITPutByIdGenerator JIT::emitPutByValWithCachedId(ByValInfo* byValInfo, Op bytecode, PutKind putKind, const Identifier&amp; propertyName, JumpList&amp; doneCases, JumpList&amp; slowCases)
 350 {
 351     // base: tag(regT1), payload(regT0)
 352     // property: tag(regT3), payload(regT2)
 353 
 354     VirtualRegister base = bytecode.m_base;
 355     VirtualRegister value = bytecode.m_value;
 356 
 357     slowCases.append(branchIfNotCell(regT3));
 358     emitByValIdentifierCheck(byValInfo, regT2, regT2, propertyName, slowCases);
 359 
 360     // Write barrier breaks the registers. So after issuing the write barrier,
 361     // reload the registers.
 362     emitWriteBarrier(base, value, ShouldFilterBase);
 363     emitLoadPayload(base, regT0);
 364     emitLoad(value, regT3, regT2);
 365 
 366     JITPutByIdGenerator gen(
 367         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),
 368         JSValueRegs::payloadOnly(regT0), JSValueRegs(regT3, regT2), regT1, m_codeBlock-&gt;ecmaMode(), putKind);
 369     gen.generateFastPath(*this);
 370     doneCases.append(jump());
 371 
 372     Label coldPathBegin = label();
 373     gen.slowPathJump().link(this);
 374 
 375     // JITPutByIdGenerator only preserve the value and the base&#39;s payload, we have to reload the tag.
 376     emitLoadTag(base, regT1);
 377 
 378     Call call = callOperation(gen.slowPathFunction(), m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT3, regT2), JSValueRegs(regT1, regT0), propertyName.impl());
 379     gen.reportSlowPathCall(coldPathBegin, call);
 380     doneCases.append(jump());
 381 
 382     return gen;
 383 }
 384 
 385 void JIT::emitSlow_op_put_by_val(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 386 {
 387     bool isDirect = currentInstruction-&gt;opcodeID() == op_put_by_val_direct;
 388     VirtualRegister base;
 389     VirtualRegister property;
 390     VirtualRegister value;
 391 
 392     auto load = [&amp;](auto bytecode) {
 393         base = bytecode.m_base;
 394         property = bytecode.m_property;
 395         value = bytecode.m_value;
 396     };
 397 
 398     if (isDirect)
 399         load(currentInstruction-&gt;as&lt;OpPutByValDirect&gt;());
 400     else
 401         load(currentInstruction-&gt;as&lt;OpPutByVal&gt;());
 402 
 403     ByValInfo* byValInfo = m_byValCompilationInfo[m_byValInstructionIndex].byValInfo;
 404 
 405     linkAllSlowCases(iter);
 406     Label slowPath = label();
 407 
 408     // The register selection below is chosen to reduce register swapping on ARM.
 409     // Swapping shouldn&#39;t happen on other platforms.
 410     emitLoad(base, regT2, regT1);
 411     emitLoad(property, regT3, regT0);
 412     emitLoad(value, regT5, regT4);
 413     Call call = callOperation(isDirect ? operationDirectPutByValOptimize : operationPutByValOptimize, m_codeBlock-&gt;globalObject(), JSValueRegs(regT2, regT1), JSValueRegs(regT3, regT0), JSValueRegs(regT5, regT4), byValInfo);
 414 
 415     m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;
 416     m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;
 417     m_byValInstructionIndex++;
 418 }
 419 
 420 void JIT::emit_op_try_get_by_id(const Instruction* currentInstruction)
 421 {
 422     auto bytecode = currentInstruction-&gt;as&lt;OpTryGetById&gt;();
 423     VirtualRegister dst = bytecode.m_dst;
 424     VirtualRegister base = bytecode.m_base;
 425     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 426 
 427     emitLoad(base, regT1, regT0);
 428     emitJumpSlowCaseIfNotJSCell(base, regT1);
 429 
 430     JITGetByIdGenerator gen(
 431         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),
 432         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::TryGetById);
 433     gen.generateFastPath(*this);
 434     addSlowCase(gen.slowPathJump());
 435     m_getByIds.append(gen);
 436 
 437     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 438     emitStore(dst, regT1, regT0);
 439 }
 440 
 441 void JIT::emitSlow_op_try_get_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 442 {
 443     linkAllSlowCases(iter);
 444 
 445     auto bytecode = currentInstruction-&gt;as&lt;OpTryGetById&gt;();
 446     VirtualRegister resultVReg = bytecode.m_dst;
 447     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 448 
 449     JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
 450 
 451     Label coldPathBegin = label();
 452 
 453     Call call = callOperation(operationTryGetByIdOptimize, resultVReg, m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());
 454 
 455     gen.reportSlowPathCall(coldPathBegin, call);
 456 }
 457 
 458 
 459 void JIT::emit_op_get_by_id_direct(const Instruction* currentInstruction)
 460 {
 461     auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdDirect&gt;();
 462     VirtualRegister dst = bytecode.m_dst;
 463     VirtualRegister base = bytecode.m_base;
 464     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 465 
 466     emitLoad(base, regT1, regT0);
 467     emitJumpSlowCaseIfNotJSCell(base, regT1);
 468 
 469     JITGetByIdGenerator gen(
 470         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),
 471         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::GetByIdDirect);
 472     gen.generateFastPath(*this);
 473     addSlowCase(gen.slowPathJump());
 474     m_getByIds.append(gen);
 475 
 476     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 477     emitStore(dst, regT1, regT0);
 478 }
 479 
 480 void JIT::emitSlow_op_get_by_id_direct(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 481 {
 482     linkAllSlowCases(iter);
 483 
 484     auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdDirect&gt;();
 485     VirtualRegister resultVReg = bytecode.m_dst;
 486     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 487 
 488     JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
 489 
 490     Label coldPathBegin = label();
 491 
 492     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdDirectOptimize, resultVReg, m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());
 493 
 494     gen.reportSlowPathCall(coldPathBegin, call);
 495 }
 496 
 497 
 498 void JIT::emit_op_get_by_id(const Instruction* currentInstruction)
 499 {
 500     auto bytecode = currentInstruction-&gt;as&lt;OpGetById&gt;();
 501     auto&amp; metadata = bytecode.metadata(m_codeBlock);
 502     VirtualRegister dst = bytecode.m_dst;
 503     VirtualRegister base = bytecode.m_base;
 504     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 505 
 506     emitLoad(base, regT1, regT0);
 507     emitJumpSlowCaseIfNotJSCell(base, regT1);
 508 
 509     if (*ident == m_vm-&gt;propertyNames-&gt;length &amp;&amp; shouldEmitProfiling()) {
 510         Jump notArrayLengthMode = branch8(NotEqual, AbsoluteAddress(&amp;metadata.m_modeMetadata.mode), TrustedImm32(static_cast&lt;uint8_t&gt;(GetByIdMode::ArrayLength)));
 511         emitArrayProfilingSiteWithCell(regT0, regT2, &amp;metadata.m_modeMetadata.arrayLengthMode.arrayProfile);
 512         notArrayLengthMode.link(this);
 513     }
 514 
 515     JITGetByIdGenerator gen(
 516         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),
 517         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::GetById);
 518     gen.generateFastPath(*this);
 519     addSlowCase(gen.slowPathJump());
 520     m_getByIds.append(gen);
 521 
 522     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 523     emitStore(dst, regT1, regT0);
 524 }
 525 
 526 void JIT::emitSlow_op_get_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 527 {
 528     linkAllSlowCases(iter);
 529 
 530     auto bytecode = currentInstruction-&gt;as&lt;OpGetById&gt;();
 531     VirtualRegister resultVReg = bytecode.m_dst;
 532     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 533 
 534     JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
 535 
 536     Label coldPathBegin = label();
 537 
 538     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdOptimize, resultVReg, m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());
 539 
 540     gen.reportSlowPathCall(coldPathBegin, call);
 541 }
 542 
 543 void JIT::emit_op_get_by_id_with_this(const Instruction* currentInstruction)
 544 {
 545     auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdWithThis&gt;();
 546     VirtualRegister dst = bytecode.m_dst;
 547     VirtualRegister base = bytecode.m_base;
 548     VirtualRegister thisVReg = bytecode.m_thisValue;
 549     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 550 
 551     emitLoad(base, regT1, regT0);
 552     emitLoad(thisVReg, regT4, regT3);
 553     emitJumpSlowCaseIfNotJSCell(base, regT1);
 554     emitJumpSlowCaseIfNotJSCell(thisVReg, regT4);
 555 
 556     JITGetByIdWithThisGenerator gen(
 557         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),
 558         ident-&gt;impl(), JSValueRegs(regT1, regT0), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT4, regT3));
 559     gen.generateFastPath(*this);
 560     addSlowCase(gen.slowPathJump());
 561     m_getByIdsWithThis.append(gen);
 562 
 563     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 564     emitStore(dst, regT1, regT0);
 565 }
 566 
 567 void JIT::emitSlow_op_get_by_id_with_this(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 568 {
 569     linkAllSlowCases(iter);
 570 
 571     auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdWithThis&gt;();
 572     VirtualRegister resultVReg = bytecode.m_dst;
 573     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 574 
 575     JITGetByIdWithThisGenerator&amp; gen = m_getByIdsWithThis[m_getByIdWithThisIndex++];
 576 
 577     Label coldPathBegin = label();
 578 
 579     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdWithThisOptimize, resultVReg, m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT1, regT0), JSValueRegs(regT4, regT3), ident-&gt;impl());
 580 
 581     gen.reportSlowPathCall(coldPathBegin, call);
 582 }
 583 
 584 void JIT::emit_op_put_by_id(const Instruction* currentInstruction)
 585 {
 586     // In order to be able to patch both the Structure, and the object offset, we store one pointer,
 587     // to just after the arguments have been loaded into registers &#39;hotPathBegin&#39;, and we generate code
 588     // such that the Structure &amp; offset are always at the same distance from this.
 589 
 590     auto bytecode = currentInstruction-&gt;as&lt;OpPutById&gt;();
 591     VirtualRegister base = bytecode.m_base;
 592     VirtualRegister value = bytecode.m_value;
 593     bool direct = !!(bytecode.m_flags &amp; PutByIdIsDirect);
 594 
 595     emitLoad2(base, regT1, regT0, value, regT3, regT2);
 596 
 597     emitJumpSlowCaseIfNotJSCell(base, regT1);
 598 
 599     JITPutByIdGenerator gen(
 600         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),
 601         JSValueRegs::payloadOnly(regT0), JSValueRegs(regT3, regT2),
 602         regT1, m_codeBlock-&gt;ecmaMode(), direct ? Direct : NotDirect);
 603 
 604     gen.generateFastPath(*this);
 605     addSlowCase(gen.slowPathJump());
 606 
 607     emitWriteBarrier(base, value, ShouldFilterBase);
 608 
 609     m_putByIds.append(gen);
 610 }
 611 
 612 void JIT::emitSlow_op_put_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 613 {
 614     linkAllSlowCases(iter);
 615 
 616     auto bytecode = currentInstruction-&gt;as&lt;OpPutById&gt;();
 617     VirtualRegister base = bytecode.m_base;
 618     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 619 
 620     Label coldPathBegin(this);
 621 
 622     // JITPutByIdGenerator only preserve the value and the base&#39;s payload, we have to reload the tag.
 623     emitLoadTag(base, regT1);
 624 
 625     JITPutByIdGenerator&amp; gen = m_putByIds[m_putByIdIndex++];
 626 
 627     Call call = callOperation(
 628         gen.slowPathFunction(), m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT3, regT2), JSValueRegs(regT1, regT0), ident-&gt;impl());
 629 
 630     gen.reportSlowPathCall(coldPathBegin, call);
 631 }
 632 
 633 void JIT::emit_op_in_by_id(const Instruction* currentInstruction)
 634 {
 635     auto bytecode = currentInstruction-&gt;as&lt;OpInById&gt;();
 636     VirtualRegister dst = bytecode.m_dst;
 637     VirtualRegister base = bytecode.m_base;
 638     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 639 
 640     emitLoad(base, regT1, regT0);
 641     emitJumpSlowCaseIfNotJSCell(base, regT1);
 642 
 643     JITInByIdGenerator gen(
 644         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),
 645         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0));
 646     gen.generateFastPath(*this);
 647     addSlowCase(gen.slowPathJump());
 648     m_inByIds.append(gen);
 649 
 650     emitStore(dst, regT1, regT0);
 651 }
 652 
 653 void JIT::emitSlow_op_in_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 654 {
 655     linkAllSlowCases(iter);
 656 
 657     auto bytecode = currentInstruction-&gt;as&lt;OpInById&gt;();
 658     VirtualRegister resultVReg = bytecode.m_dst;
 659     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 660 
 661     JITInByIdGenerator&amp; gen = m_inByIds[m_inByIdIndex++];
 662 
 663     Label coldPathBegin = label();
 664 
 665     Call call = callOperation(operationInByIdOptimize, resultVReg, m_codeBlock-&gt;globalObject(), gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());
 666 
 667     gen.reportSlowPathCall(coldPathBegin, call);
 668 }
 669 
 670 void JIT::emitVarInjectionCheck(bool needsVarInjectionChecks)
 671 {
 672     if (!needsVarInjectionChecks)
 673         return;
 674     addSlowCase(branch8(Equal, AbsoluteAddress(m_codeBlock-&gt;globalObject()-&gt;varInjectionWatchpoint()-&gt;addressOfState()), TrustedImm32(IsInvalidated)));
 675 }
 676 
 677 void JIT::emitResolveClosure(VirtualRegister dst, VirtualRegister scope, bool needsVarInjectionChecks, unsigned depth)
 678 {
 679     emitVarInjectionCheck(needsVarInjectionChecks);
 680     move(TrustedImm32(JSValue::CellTag), regT1);
 681     emitLoadPayload(scope, regT0);
 682     for (unsigned i = 0; i &lt; depth; ++i)
 683         loadPtr(Address(regT0, JSScope::offsetOfNext()), regT0);
 684     emitStore(dst, regT1, regT0);
 685 }
 686 
 687 void JIT::emit_op_resolve_scope(const Instruction* currentInstruction)
 688 {
 689     auto bytecode = currentInstruction-&gt;as&lt;OpResolveScope&gt;();
 690     auto&amp; metadata = bytecode.metadata(m_codeBlock);
 691     VirtualRegister dst = bytecode.m_dst;
 692     VirtualRegister scope = bytecode.m_scope;
 693     ResolveType resolveType = metadata.m_resolveType;
 694     unsigned depth = metadata.m_localScopeDepth;
 695 
 696     auto emitCode = [&amp;] (ResolveType resolveType) {
 697         switch (resolveType) {
 698         case GlobalProperty:
 699         case GlobalPropertyWithVarInjectionChecks: {
 700             JSScope* constantScope = JSScope::constantScopeForCodeBlock(resolveType, m_codeBlock);
 701             RELEASE_ASSERT(constantScope);
 702             emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
 703             load32(&amp;metadata.m_globalLexicalBindingEpoch, regT1);
 704             addSlowCase(branch32(NotEqual, AbsoluteAddress(m_codeBlock-&gt;globalObject()-&gt;addressOfGlobalLexicalBindingEpoch()), regT1));
 705             move(TrustedImm32(JSValue::CellTag), regT1);
 706             move(TrustedImmPtr(constantScope), regT0);
 707             emitStore(dst, regT1, regT0);
 708             break;
 709         }
 710 
 711         case GlobalVar:
 712         case GlobalVarWithVarInjectionChecks:
 713         case GlobalLexicalVar:
 714         case GlobalLexicalVarWithVarInjectionChecks: {
 715             JSScope* constantScope = JSScope::constantScopeForCodeBlock(resolveType, m_codeBlock);
 716             RELEASE_ASSERT(constantScope);
 717             emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
 718             move(TrustedImm32(JSValue::CellTag), regT1);
 719             move(TrustedImmPtr(constantScope), regT0);
 720             emitStore(dst, regT1, regT0);
 721             break;
 722         }
 723         case ClosureVar:
 724         case ClosureVarWithVarInjectionChecks:
 725             emitResolveClosure(dst, scope, needsVarInjectionChecks(resolveType), depth);
 726             break;
 727         case ModuleVar:
 728             move(TrustedImm32(JSValue::CellTag), regT1);
 729             move(TrustedImmPtr(metadata.m_lexicalEnvironment.get()), regT0);
 730             emitStore(dst, regT1, regT0);
 731             break;
 732         case Dynamic:
 733             addSlowCase(jump());
 734             break;
 735         case LocalClosureVar:
 736         case UnresolvedProperty:
 737         case UnresolvedPropertyWithVarInjectionChecks:
 738             RELEASE_ASSERT_NOT_REACHED();
 739         }
 740     };
 741     switch (resolveType) {
 742     case GlobalProperty:
 743     case GlobalPropertyWithVarInjectionChecks: {
 744         JumpList skipToEnd;
 745         load32(&amp;metadata.m_resolveType, regT0);
 746 
 747         Jump notGlobalProperty = branch32(NotEqual, regT0, TrustedImm32(resolveType));
 748         emitCode(resolveType);
 749         skipToEnd.append(jump());
 750 
 751         notGlobalProperty.link(this);
 752         emitCode(needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar);
 753 
 754         skipToEnd.link(this);
 755         break;
 756     }
 757     case UnresolvedProperty:
 758     case UnresolvedPropertyWithVarInjectionChecks: {
 759         JumpList skipToEnd;
 760         load32(&amp;metadata.m_resolveType, regT0);
 761 
 762         Jump notGlobalProperty = branch32(NotEqual, regT0, TrustedImm32(GlobalProperty));
 763         emitCode(GlobalProperty);
 764         skipToEnd.append(jump());
 765         notGlobalProperty.link(this);
 766 
 767         Jump notGlobalPropertyWithVarInjections = branch32(NotEqual, regT0, TrustedImm32(GlobalPropertyWithVarInjectionChecks));
 768         emitCode(GlobalPropertyWithVarInjectionChecks);
 769         skipToEnd.append(jump());
 770         notGlobalPropertyWithVarInjections.link(this);
 771 
 772         Jump notGlobalLexicalVar = branch32(NotEqual, regT0, TrustedImm32(GlobalLexicalVar));
 773         emitCode(GlobalLexicalVar);
 774         skipToEnd.append(jump());
 775         notGlobalLexicalVar.link(this);
 776 
 777         Jump notGlobalLexicalVarWithVarInjections = branch32(NotEqual, regT0, TrustedImm32(GlobalLexicalVarWithVarInjectionChecks));
 778         emitCode(GlobalLexicalVarWithVarInjectionChecks);
 779         skipToEnd.append(jump());
 780         notGlobalLexicalVarWithVarInjections.link(this);
 781 
 782         addSlowCase(jump());
 783         skipToEnd.link(this);
 784         break;
 785     }
 786 
 787     default:
 788         emitCode(resolveType);
 789         break;
 790     }
 791 }
 792 
 793 void JIT::emitLoadWithStructureCheck(VirtualRegister scope, Structure** structureSlot)
 794 {
 795     emitLoad(scope, regT1, regT0);
 796     loadPtr(structureSlot, regT2);
 797     addSlowCase(branchPtr(NotEqual, Address(regT0, JSCell::structureIDOffset()), regT2));
 798 }
 799 
 800 void JIT::emitGetVarFromPointer(JSValue* operand, GPRReg tag, GPRReg payload)
 801 {
 802     uintptr_t rawAddress = bitwise_cast&lt;uintptr_t&gt;(operand);
 803     load32(bitwise_cast&lt;void*&gt;(rawAddress + TagOffset), tag);
 804     load32(bitwise_cast&lt;void*&gt;(rawAddress + PayloadOffset), payload);
 805 }
 806 void JIT::emitGetVarFromIndirectPointer(JSValue** operand, GPRReg tag, GPRReg payload)
 807 {
 808     loadPtr(operand, payload);
 809     load32(Address(payload, TagOffset), tag);
 810     load32(Address(payload, PayloadOffset), payload);
 811 }
 812 
 813 void JIT::emitGetClosureVar(VirtualRegister scope, uintptr_t operand)
 814 {
 815     emitLoad(scope, regT1, regT0);
 816     load32(Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + TagOffset), regT1);
 817     load32(Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + PayloadOffset), regT0);
 818 }
 819 
 820 void JIT::emit_op_get_from_scope(const Instruction* currentInstruction)
 821 {
 822     auto bytecode = currentInstruction-&gt;as&lt;OpGetFromScope&gt;();
 823     auto&amp; metadata = bytecode.metadata(m_codeBlock);
 824     VirtualRegister dst = bytecode.m_dst;
 825     VirtualRegister scope = bytecode.m_scope;
 826     ResolveType resolveType = metadata.m_getPutInfo.resolveType();
 827     Structure** structureSlot = metadata.m_structure.slot();
 828     uintptr_t* operandSlot = reinterpret_cast&lt;uintptr_t*&gt;(&amp;metadata.m_operand);
 829 
 830     auto emitCode = [&amp;] (ResolveType resolveType, bool indirectLoadForOperand) {
 831         switch (resolveType) {
 832         case GlobalProperty:
 833         case GlobalPropertyWithVarInjectionChecks: {
 834             emitLoadWithStructureCheck(scope, structureSlot); // Structure check covers var injection.
 835             GPRReg base = regT2;
 836             GPRReg resultTag = regT1;
 837             GPRReg resultPayload = regT0;
 838             GPRReg offset = regT3;
 839 
 840             move(regT0, base);
 841             load32(operandSlot, offset);
 842             if (ASSERT_ENABLED) {
 843                 Jump isOutOfLine = branch32(GreaterThanOrEqual, offset, TrustedImm32(firstOutOfLineOffset));
 844                 abortWithReason(JITOffsetIsNotOutOfLine);
 845                 isOutOfLine.link(this);
 846             }
 847             loadPtr(Address(base, JSObject::butterflyOffset()), base);
 848             neg32(offset);
 849             load32(BaseIndex(base, offset, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload) + (firstOutOfLineOffset - 2) * sizeof(EncodedJSValue)), resultPayload);
 850             load32(BaseIndex(base, offset, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag) + (firstOutOfLineOffset - 2) * sizeof(EncodedJSValue)), resultTag);
 851             break;
 852         }
 853         case GlobalVar:
 854         case GlobalVarWithVarInjectionChecks:
 855         case GlobalLexicalVar:
 856         case GlobalLexicalVarWithVarInjectionChecks:
 857             emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
 858             if (indirectLoadForOperand)
 859                 emitGetVarFromIndirectPointer(bitwise_cast&lt;JSValue**&gt;(operandSlot), regT1, regT0);
 860             else
 861                 emitGetVarFromPointer(bitwise_cast&lt;JSValue*&gt;(*operandSlot), regT1, regT0);
 862             if (resolveType == GlobalLexicalVar || resolveType == GlobalLexicalVarWithVarInjectionChecks) // TDZ check.
 863                 addSlowCase(branchIfEmpty(regT1));
 864             break;
 865         case ClosureVar:
 866         case ClosureVarWithVarInjectionChecks:
 867             emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
 868             emitGetClosureVar(scope, *operandSlot);
 869             break;
 870         case Dynamic:
 871             addSlowCase(jump());
 872             break;
 873         case ModuleVar:
 874         case LocalClosureVar:
 875         case UnresolvedProperty:
 876         case UnresolvedPropertyWithVarInjectionChecks:
 877             RELEASE_ASSERT_NOT_REACHED();
 878         }
 879     };
 880 
 881     switch (resolveType) {
 882     case GlobalProperty:
 883     case GlobalPropertyWithVarInjectionChecks: {
 884         JumpList skipToEnd;
 885         load32(&amp;metadata.m_getPutInfo, regT0);
 886         and32(TrustedImm32(GetPutInfo::typeBits), regT0); // Load ResolveType into T0
 887 
 888         Jump isNotGlobalProperty = branch32(NotEqual, regT0, TrustedImm32(resolveType));
 889         emitCode(resolveType, false);
 890         skipToEnd.append(jump());
 891 
 892         isNotGlobalProperty.link(this);
 893         emitCode(needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar, true);
 894         skipToEnd.link(this);
 895         break;
 896     }
 897     case UnresolvedProperty:
 898     case UnresolvedPropertyWithVarInjectionChecks: {
 899         JumpList skipToEnd;
 900         load32(&amp;metadata.m_getPutInfo, regT0);
 901         and32(TrustedImm32(GetPutInfo::typeBits), regT0); // Load ResolveType into T0
 902 
 903         Jump isGlobalProperty = branch32(Equal, regT0, TrustedImm32(GlobalProperty));
 904         Jump notGlobalPropertyWithVarInjections = branch32(NotEqual, regT0, TrustedImm32(GlobalPropertyWithVarInjectionChecks));
 905         isGlobalProperty.link(this);
 906         emitCode(GlobalProperty, false);
 907         skipToEnd.append(jump());
 908         notGlobalPropertyWithVarInjections.link(this);
 909 
 910         Jump notGlobalLexicalVar = branch32(NotEqual, regT0, TrustedImm32(GlobalLexicalVar));
 911         emitCode(GlobalLexicalVar, true);
 912         skipToEnd.append(jump());
 913         notGlobalLexicalVar.link(this);
 914 
 915         Jump notGlobalLexicalVarWithVarInjections = branch32(NotEqual, regT0, TrustedImm32(GlobalLexicalVarWithVarInjectionChecks));
 916         emitCode(GlobalLexicalVarWithVarInjectionChecks, true);
 917         skipToEnd.append(jump());
 918         notGlobalLexicalVarWithVarInjections.link(this);
 919 
 920         addSlowCase(jump());
 921 
 922         skipToEnd.link(this);
 923         break;
 924     }
 925 
 926     default:
 927         emitCode(resolveType, false);
 928         break;
 929     }
 930     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 931     emitStore(dst, regT1, regT0);
 932 }
 933 
 934 void JIT::emitSlow_op_get_from_scope(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 935 {
 936     linkAllSlowCases(iter);
 937 
 938     auto bytecode = currentInstruction-&gt;as&lt;OpGetFromScope&gt;();
 939     VirtualRegister dst = bytecode.m_dst;
 940     callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetFromScope, dst, m_codeBlock-&gt;globalObject(), currentInstruction);
 941 }
 942 
 943 void JIT::emitPutGlobalVariable(JSValue* operand, VirtualRegister value, WatchpointSet* set)
 944 {
 945     emitLoad(value, regT1, regT0);
 946     emitNotifyWrite(set);
 947     uintptr_t rawAddress = bitwise_cast&lt;uintptr_t&gt;(operand);
 948     store32(regT1, bitwise_cast&lt;void*&gt;(rawAddress + TagOffset));
 949     store32(regT0, bitwise_cast&lt;void*&gt;(rawAddress + PayloadOffset));
 950 }
 951 
 952 void JIT::emitPutGlobalVariableIndirect(JSValue** addressOfOperand, VirtualRegister value, WatchpointSet** indirectWatchpointSet)
 953 {
 954     emitLoad(value, regT1, regT0);
 955     loadPtr(indirectWatchpointSet, regT2);
 956     emitNotifyWrite(regT2);
 957     loadPtr(addressOfOperand, regT2);
 958     store32(regT1, Address(regT2, TagOffset));
 959     store32(regT0, Address(regT2, PayloadOffset));
 960 }
 961 
 962 void JIT::emitPutClosureVar(VirtualRegister scope, uintptr_t operand, VirtualRegister value, WatchpointSet* set)
 963 {
 964     emitLoad(value, regT3, regT2);
 965     emitLoad(scope, regT1, regT0);
 966     emitNotifyWrite(set);
 967     store32(regT3, Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + TagOffset));
 968     store32(regT2, Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + PayloadOffset));
 969 }
 970 
 971 void JIT::emit_op_put_to_scope(const Instruction* currentInstruction)
 972 {
 973     auto bytecode = currentInstruction-&gt;as&lt;OpPutToScope&gt;();
 974     auto&amp; metadata = bytecode.metadata(m_codeBlock);
 975     VirtualRegister scope = bytecode.m_scope;
 976     VirtualRegister value = bytecode.m_value;
 977     GetPutInfo getPutInfo = copiedGetPutInfo(bytecode);
 978     ResolveType resolveType = getPutInfo.resolveType();
 979     Structure** structureSlot = metadata.m_structure.slot();
 980     uintptr_t* operandSlot = reinterpret_cast&lt;uintptr_t*&gt;(&amp;metadata.m_operand);
 981 
 982     auto emitCode = [&amp;] (ResolveType resolveType, bool indirectLoadForOperand) {
 983         switch (resolveType) {
 984         case GlobalProperty:
 985         case GlobalPropertyWithVarInjectionChecks: {
 986             emitWriteBarrier(m_codeBlock-&gt;globalObject(), value, ShouldFilterValue);
 987             emitLoadWithStructureCheck(scope, structureSlot); // Structure check covers var injection.
 988             emitLoad(value, regT3, regT2);
 989 
 990             loadPtr(Address(regT0, JSObject::butterflyOffset()), regT0);
 991             loadPtr(operandSlot, regT1);
 992             negPtr(regT1);
 993             store32(regT3, BaseIndex(regT0, regT1, TimesEight, (firstOutOfLineOffset - 2) * sizeof(EncodedJSValue) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.tag)));
 994             store32(regT2, BaseIndex(regT0, regT1, TimesEight, (firstOutOfLineOffset - 2) * sizeof(EncodedJSValue) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.payload)));
 995             break;
 996         }
 997         case GlobalVar:
 998         case GlobalVarWithVarInjectionChecks:
 999         case GlobalLexicalVar:
1000         case GlobalLexicalVarWithVarInjectionChecks: {
1001             JSScope* constantScope = JSScope::constantScopeForCodeBlock(resolveType, m_codeBlock);
1002             RELEASE_ASSERT(constantScope);
1003             emitWriteBarrier(constantScope, value, ShouldFilterValue);
1004             emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
1005             if (!isInitialization(getPutInfo.initializationMode()) &amp;&amp; (resolveType == GlobalLexicalVar || resolveType == GlobalLexicalVarWithVarInjectionChecks)) {
1006                 // We need to do a TDZ check here because we can&#39;t always prove we need to emit TDZ checks statically.
1007                 if (indirectLoadForOperand)
1008                     emitGetVarFromIndirectPointer(bitwise_cast&lt;JSValue**&gt;(operandSlot), regT1, regT0);
1009                 else
1010                     emitGetVarFromPointer(bitwise_cast&lt;JSValue*&gt;(*operandSlot), regT1, regT0);
1011                 addSlowCase(branchIfEmpty(regT1));
1012             }
1013             if (indirectLoadForOperand)
1014                 emitPutGlobalVariableIndirect(bitwise_cast&lt;JSValue**&gt;(operandSlot), value, &amp;metadata.m_watchpointSet);
1015             else
1016                 emitPutGlobalVariable(bitwise_cast&lt;JSValue*&gt;(*operandSlot), value, metadata.m_watchpointSet);
1017             break;
1018         }
1019         case LocalClosureVar:
1020         case ClosureVar:
1021         case ClosureVarWithVarInjectionChecks:
1022             emitWriteBarrier(scope, value, ShouldFilterValue);
1023             emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
1024             emitPutClosureVar(scope, *operandSlot, value, metadata.m_watchpointSet);
1025             break;
1026         case ModuleVar:
1027         case Dynamic:
1028             addSlowCase(jump());
1029             break;
1030         case UnresolvedProperty:
1031         case UnresolvedPropertyWithVarInjectionChecks:
1032             RELEASE_ASSERT_NOT_REACHED();
1033         }
1034     };
1035 
1036     switch (resolveType) {
1037     case GlobalProperty:
1038     case GlobalPropertyWithVarInjectionChecks: {
1039         JumpList skipToEnd;
1040         load32(&amp;metadata.m_getPutInfo, regT0);
1041         and32(TrustedImm32(GetPutInfo::typeBits), regT0); // Load ResolveType into T0
1042 
1043         Jump isGlobalProperty = branch32(Equal, regT0, TrustedImm32(resolveType));
1044         Jump isGlobalLexicalVar = branch32(Equal, regT0, TrustedImm32(needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar));
1045         addSlowCase(jump()); // Dynamic, it can happen if we attempt to put a value to already-initialized const binding.
1046 
1047         isGlobalLexicalVar.link(this);
1048         emitCode(needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar, true);
1049         skipToEnd.append(jump());
1050 
1051         isGlobalProperty.link(this);
1052         emitCode(resolveType, false);
1053         skipToEnd.link(this);
1054         break;
1055     }
1056     case UnresolvedProperty:
1057     case UnresolvedPropertyWithVarInjectionChecks: {
1058         JumpList skipToEnd;
1059         load32(&amp;metadata.m_getPutInfo, regT0);
1060         and32(TrustedImm32(GetPutInfo::typeBits), regT0); // Load ResolveType into T0
1061 
1062         Jump isGlobalProperty = branch32(Equal, regT0, TrustedImm32(GlobalProperty));
1063         Jump notGlobalPropertyWithVarInjections = branch32(NotEqual, regT0, TrustedImm32(GlobalPropertyWithVarInjectionChecks));
1064         isGlobalProperty.link(this);
1065         emitCode(GlobalProperty, false);
1066         skipToEnd.append(jump());
1067         notGlobalPropertyWithVarInjections.link(this);
1068 
1069         Jump notGlobalLexicalVar = branch32(NotEqual, regT0, TrustedImm32(GlobalLexicalVar));
1070         emitCode(GlobalLexicalVar, true);
1071         skipToEnd.append(jump());
1072         notGlobalLexicalVar.link(this);
1073 
1074         Jump notGlobalLexicalVarWithVarInjections = branch32(NotEqual, regT0, TrustedImm32(GlobalLexicalVarWithVarInjectionChecks));
1075         emitCode(GlobalLexicalVarWithVarInjectionChecks, true);
1076         skipToEnd.append(jump());
1077         notGlobalLexicalVarWithVarInjections.link(this);
1078 
1079         addSlowCase(jump());
1080 
1081         skipToEnd.link(this);
1082         break;
1083     }
1084 
1085     default:
1086         emitCode(resolveType, false);
1087         break;
1088     }
1089 }
1090 
1091 void JIT::emitSlow_op_put_to_scope(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
1092 {
1093     linkAllSlowCases(iter);
1094 
1095     auto bytecode = currentInstruction-&gt;as&lt;OpPutToScope&gt;();
1096     ResolveType resolveType = copiedGetPutInfo(bytecode).resolveType();
1097     if (resolveType == ModuleVar) {
1098         JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_throw_strict_mode_readonly_property_write_error);
1099         slowPathCall.call();
1100     } else
1101         callOperation(operationPutToScope, m_codeBlock-&gt;globalObject(), currentInstruction);
1102 }
1103 
1104 void JIT::emit_op_get_from_arguments(const Instruction* currentInstruction)
1105 {
1106     auto bytecode = currentInstruction-&gt;as&lt;OpGetFromArguments&gt;();
1107     VirtualRegister dst = bytecode.m_dst;
1108     VirtualRegister arguments = bytecode.m_arguments;
1109     int index = bytecode.m_index;
1110 
1111     emitLoadPayload(arguments, regT0);
1112     load32(Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + TagOffset), regT1);
1113     load32(Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + PayloadOffset), regT0);
1114     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
1115     emitStore(dst, regT1, regT0);
1116 }
1117 
1118 void JIT::emit_op_put_to_arguments(const Instruction* currentInstruction)
1119 {
1120     auto bytecode = currentInstruction-&gt;as&lt;OpPutToArguments&gt;();
1121     VirtualRegister arguments = bytecode.m_arguments;
1122     int index = bytecode.m_index;
1123     VirtualRegister value = bytecode.m_value;
1124 
1125     emitWriteBarrier(arguments, value, ShouldFilterValue);
1126 
1127     emitLoadPayload(arguments, regT0);
1128     emitLoad(value, regT1, regT2);
1129     store32(regT1, Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + TagOffset));
1130     store32(regT2, Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + PayloadOffset));
1131 }
1132 
1133 void JIT::emit_op_get_internal_field(const Instruction* currentInstruction)
1134 {
1135     auto bytecode = currentInstruction-&gt;as&lt;OpGetInternalField&gt;();
1136     auto&amp; metadata = bytecode.metadata(m_codeBlock);
1137     VirtualRegister dst = bytecode.m_dst;
1138     VirtualRegister base = bytecode.m_base;
1139     unsigned index = bytecode.m_index;
1140 
1141     emitLoadPayload(base, regT2);
1142     load32(Address(regT2, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index) + TagOffset), regT1);
1143     load32(Address(regT2, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index) + PayloadOffset), regT0);
1144     emitValueProfilingSite(metadata);
1145     emitStore(dst, regT1, regT0);
1146 }
1147 
1148 void JIT::emit_op_put_internal_field(const Instruction* currentInstruction)
1149 {
1150     auto bytecode = currentInstruction-&gt;as&lt;OpPutInternalField&gt;();
1151     VirtualRegister base = bytecode.m_base;
1152     VirtualRegister value = bytecode.m_value;
1153     unsigned index = bytecode.m_index;
1154 
1155     emitLoadPayload(base, regT0);
1156     emitLoad(value, regT1, regT2);
1157     store32(regT1, Address(regT0, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index) + TagOffset));
1158     store32(regT2, Address(regT0, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index) + PayloadOffset));
1159     emitWriteBarrier(base, value, ShouldFilterValue);
1160 }
1161 
1162 } // namespace JSC
1163 
1164 #endif // USE(JSVALUE32_64)
1165 #endif // ENABLE(JIT)
    </pre>
  </body>
</html>
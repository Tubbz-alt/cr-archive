<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/BitmapImage.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BitmapImage.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Color.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/BitmapImage.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 69 #if PLATFORM(JAVA)
 70     static Ref&lt;Image&gt; createFromName(const char* name);
 71 #endif
 72     virtual ~BitmapImage();
 73 
 74     void updateFromSettings(const Settings&amp;);
 75 
 76     bool hasSingleSecurityOrigin() const override { return true; }
 77 
 78     EncodedDataStatus dataChanged(bool allDataReceived) override;
 79     unsigned decodedSize() const { return m_source-&gt;decodedSize(); }
 80 
 81     EncodedDataStatus encodedDataStatus() const { return m_source-&gt;encodedDataStatus(); }
 82     size_t frameCount() const { return m_source-&gt;frameCount(); }
 83     RepetitionCount repetitionCount() const { return m_source-&gt;repetitionCount(); }
 84     String uti() const override { return m_source-&gt;uti(); }
 85     String filenameExtension() const override { return m_source-&gt;filenameExtension(); }
 86     Optional&lt;IntPoint&gt; hotSpot() const override { return m_source-&gt;hotSpot(); }
 87 
 88     // FloatSize due to override.
<span class="line-modified"> 89     FloatSize size() const override { return m_source-&gt;size(); }</span>
<span class="line-modified"> 90     IntSize sizeRespectingOrientation() const { return m_source-&gt;sizeRespectingOrientation(); }</span>
 91     Color singlePixelSolidColor() const override { return m_source-&gt;singlePixelSolidColor(); }
 92     bool frameIsBeingDecodedAndIsCompatibleWithOptionsAtIndex(size_t index, const DecodingOptions&amp; decodingOptions) const { return m_source-&gt;frameIsBeingDecodedAndIsCompatibleWithOptionsAtIndex(index, decodingOptions); }
 93     DecodingStatus frameDecodingStatusAtIndex(size_t index) const { return m_source-&gt;frameDecodingStatusAtIndex(index); }
 94     bool frameIsCompleteAtIndex(size_t index) const { return frameDecodingStatusAtIndex(index) == DecodingStatus::Complete; }
 95     bool frameHasAlphaAtIndex(size_t index) const { return m_source-&gt;frameHasAlphaAtIndex(index); }
 96 
 97     bool frameHasFullSizeNativeImageAtIndex(size_t index, SubsamplingLevel subsamplingLevel) { return m_source-&gt;frameHasFullSizeNativeImageAtIndex(index, subsamplingLevel); }
 98     bool frameHasDecodedNativeImageCompatibleWithOptionsAtIndex(size_t index, const Optional&lt;SubsamplingLevel&gt;&amp; subsamplingLevel, const DecodingOptions&amp; decodingOptions) { return m_source-&gt;frameHasDecodedNativeImageCompatibleWithOptionsAtIndex(index, subsamplingLevel, decodingOptions); }
 99 
100     SubsamplingLevel frameSubsamplingLevelAtIndex(size_t index) const { return m_source-&gt;frameSubsamplingLevelAtIndex(index); }
101 
102     Seconds frameDurationAtIndex(size_t index) const { return m_source-&gt;frameDurationAtIndex(index); }
103     ImageOrientation frameOrientationAtIndex(size_t index) const { return m_source-&gt;frameOrientationAtIndex(index); }
104 
105     size_t currentFrame() const { return m_currentFrame; }
106     bool currentFrameKnownToBeOpaque() const override { return !frameHasAlphaAtIndex(currentFrame()); }
107     ImageOrientation orientationForCurrentFrame() const { return frameOrientationAtIndex(currentFrame()); }
108     bool canAnimate() const;
109 
110     bool shouldUseAsyncDecodingForTesting() const { return m_source-&gt;frameDecodingDurationForTesting() &gt; 0_s; }
</pre>
<hr />
<pre>
122 #if USE(APPKIT)
123     NSImage *nsImage() override;
124     RetainPtr&lt;NSImage&gt; snapshotNSImage() override;
125 #endif
126 
127 #if PLATFORM(COCOA)
128     CFDataRef tiffRepresentation() override;
129 #endif
130 
131 #if PLATFORM(WIN)
132     bool getHBITMAP(HBITMAP) override;
133     bool getHBITMAPOfSize(HBITMAP, const IntSize*) override;
134 #endif
135 
136 #if PLATFORM(GTK)
137     GdkPixbuf* getGdkPixbuf() override;
138 #endif
139 
140     WEBCORE_EXPORT NativeImagePtr nativeImage(const GraphicsContext* = nullptr) override;
141     NativeImagePtr nativeImageForCurrentFrame(const GraphicsContext* = nullptr) override;

142 #if USE(CG)
143     NativeImagePtr nativeImageOfSize(const IntSize&amp;, const GraphicsContext* = nullptr) override;
144     Vector&lt;NativeImagePtr&gt; framesNativeImages();
145 #endif
146 
147     void imageFrameAvailableAtIndex(size_t);
148     void decode(Function&lt;void()&gt;&amp;&amp;);
149 
150 protected:
151     WEBCORE_EXPORT BitmapImage(NativeImagePtr&amp;&amp;, ImageObserver* = nullptr);
152     WEBCORE_EXPORT BitmapImage(ImageObserver* = nullptr);
153 
154     NativeImagePtr frameImageAtIndex(size_t index) { return m_source-&gt;frameImageAtIndex(index); }
155     NativeImagePtr frameImageAtIndexCacheIfNeeded(size_t, SubsamplingLevel = SubsamplingLevel::Default, const GraphicsContext* = nullptr);
156 
157     // Called to invalidate cached data. When |destroyAll| is true, we wipe out
158     // the entire frame buffer cache and tell the image source to destroy
159     // everything; this is used when e.g. we want to free some room in the image
160     // cache. If |destroyAll| is false, we only delete frames up to the current
161     // one; this is used while animating large images to keep memory footprint
</pre>
<hr />
<pre>
174 
175     // Animation.
176     enum class StartAnimationStatus { CannotStart, IncompleteData, TimerActive, DecodingActive, Started };
177     bool isAnimated() const override { return m_source-&gt;frameCount() &gt; 1; }
178     bool shouldAnimate() const;
179     void startAnimation() override { internalStartAnimation(); }
180     StartAnimationStatus internalStartAnimation();
181     void advanceAnimation();
182     void internalAdvanceAnimation();
183     bool isAnimating() const final;
184 
185     // It may look unusual that there is no start animation call as public API. This is because
186     // we start and stop animating lazily. Animation begins whenever someone draws the image. It will
187     // automatically pause once all observers no longer want to render the image anywhere.
188     void stopAnimation() override;
189     void resetAnimation() override;
190 
191     // Handle platform-specific data
192     void invalidatePlatformData();
193 
<span class="line-modified">194 #if !ASSERT_DISABLED</span>
195     bool notSolidColor() override;
196 #endif
197 
198 #if PLATFORM(COCOA)
199     RetainPtr&lt;CFDataRef&gt; tiffRepresentation(const Vector&lt;NativeImagePtr&gt;&amp;);
200 #endif
201 
202 private:
203     void clearTimer();
204     void startTimer(Seconds delay);
205     SubsamplingLevel subsamplingLevelForScaleFactor(GraphicsContext&amp;, const FloatSize&amp; scaleFactor);
206     bool canDestroyDecodedData();
207     void setCurrentFrameDecodingStatusIfNecessary(DecodingStatus);
208     bool isBitmapImage() const override { return true; }
209     void callDecodingCallbacks();
210     void dump(WTF::TextStream&amp;) const override;
211 
212     // Animated images over a certain size are considered large enough that we&#39;ll only hang on to one frame at a time.
213     static const unsigned LargeAnimationCutoff = 30 * 1024 * 1024;
214 
</pre>
<hr />
<pre>
220     std::unique_ptr&lt;Timer&gt; m_frameTimer;
221     RepetitionCount m_repetitionsComplete { RepetitionCountNone }; // How many repetitions we&#39;ve finished.
222     MonotonicTime m_desiredFrameStartTime; // The system time at which we hope to see the next call to startAnimation().
223 
224     std::unique_ptr&lt;Vector&lt;Function&lt;void()&gt;, 1&gt;&gt; m_decodingCallbacks;
225 
226     bool m_animationFinished { false };
227 
228     // The default value of m_allowSubsampling should be the same as defaultImageSubsamplingEnabled in Settings.cpp
229 #if PLATFORM(IOS_FAMILY)
230     bool m_allowSubsampling { true };
231 #else
232     bool m_allowSubsampling { false };
233 #endif
234     bool m_allowAnimatedImageAsyncDecoding { false };
235     bool m_showDebugBackground { false };
236 
237     bool m_clearDecoderAfterAsyncFrameRequestForTesting { false };
238     bool m_largeImageAsyncDecodingEnabledForTesting { false };
239 
<span class="line-modified">240 #if !LOG_DISABLED</span>
241     size_t m_lateFrameCount { 0 };
242     size_t m_earlyFrameCount { 0 };
243     size_t m_cachedFrameCount { 0 };
244 #endif
245 
246     unsigned m_decodeCountForTesting { 0 };
247 
248 #if USE(APPKIT)
249     mutable RetainPtr&lt;NSImage&gt; m_nsImage; // A cached NSImage of all the frames. Only built lazily if someone actually queries for one.
250 #endif
251 #if USE(CG)
252     mutable RetainPtr&lt;CFDataRef&gt; m_tiffRep; // Cached TIFF rep for all the frames. Only built lazily if someone queries for one.
253 #endif
254     RefPtr&lt;Image&gt; m_cachedImage;
255 };
256 
257 } // namespace WebCore
258 
259 SPECIALIZE_TYPE_TRAITS_IMAGE(BitmapImage)
</pre>
</td>
<td>
<hr />
<pre>
 69 #if PLATFORM(JAVA)
 70     static Ref&lt;Image&gt; createFromName(const char* name);
 71 #endif
 72     virtual ~BitmapImage();
 73 
 74     void updateFromSettings(const Settings&amp;);
 75 
 76     bool hasSingleSecurityOrigin() const override { return true; }
 77 
 78     EncodedDataStatus dataChanged(bool allDataReceived) override;
 79     unsigned decodedSize() const { return m_source-&gt;decodedSize(); }
 80 
 81     EncodedDataStatus encodedDataStatus() const { return m_source-&gt;encodedDataStatus(); }
 82     size_t frameCount() const { return m_source-&gt;frameCount(); }
 83     RepetitionCount repetitionCount() const { return m_source-&gt;repetitionCount(); }
 84     String uti() const override { return m_source-&gt;uti(); }
 85     String filenameExtension() const override { return m_source-&gt;filenameExtension(); }
 86     Optional&lt;IntPoint&gt; hotSpot() const override { return m_source-&gt;hotSpot(); }
 87 
 88     // FloatSize due to override.
<span class="line-modified"> 89     FloatSize size(ImageOrientation orientation = ImageOrientation::FromImage) const override { return m_source-&gt;size(orientation); }</span>
<span class="line-modified"> 90     ImageOrientation orientation() const override { return m_source-&gt;orientation(); }</span>
 91     Color singlePixelSolidColor() const override { return m_source-&gt;singlePixelSolidColor(); }
 92     bool frameIsBeingDecodedAndIsCompatibleWithOptionsAtIndex(size_t index, const DecodingOptions&amp; decodingOptions) const { return m_source-&gt;frameIsBeingDecodedAndIsCompatibleWithOptionsAtIndex(index, decodingOptions); }
 93     DecodingStatus frameDecodingStatusAtIndex(size_t index) const { return m_source-&gt;frameDecodingStatusAtIndex(index); }
 94     bool frameIsCompleteAtIndex(size_t index) const { return frameDecodingStatusAtIndex(index) == DecodingStatus::Complete; }
 95     bool frameHasAlphaAtIndex(size_t index) const { return m_source-&gt;frameHasAlphaAtIndex(index); }
 96 
 97     bool frameHasFullSizeNativeImageAtIndex(size_t index, SubsamplingLevel subsamplingLevel) { return m_source-&gt;frameHasFullSizeNativeImageAtIndex(index, subsamplingLevel); }
 98     bool frameHasDecodedNativeImageCompatibleWithOptionsAtIndex(size_t index, const Optional&lt;SubsamplingLevel&gt;&amp; subsamplingLevel, const DecodingOptions&amp; decodingOptions) { return m_source-&gt;frameHasDecodedNativeImageCompatibleWithOptionsAtIndex(index, subsamplingLevel, decodingOptions); }
 99 
100     SubsamplingLevel frameSubsamplingLevelAtIndex(size_t index) const { return m_source-&gt;frameSubsamplingLevelAtIndex(index); }
101 
102     Seconds frameDurationAtIndex(size_t index) const { return m_source-&gt;frameDurationAtIndex(index); }
103     ImageOrientation frameOrientationAtIndex(size_t index) const { return m_source-&gt;frameOrientationAtIndex(index); }
104 
105     size_t currentFrame() const { return m_currentFrame; }
106     bool currentFrameKnownToBeOpaque() const override { return !frameHasAlphaAtIndex(currentFrame()); }
107     ImageOrientation orientationForCurrentFrame() const { return frameOrientationAtIndex(currentFrame()); }
108     bool canAnimate() const;
109 
110     bool shouldUseAsyncDecodingForTesting() const { return m_source-&gt;frameDecodingDurationForTesting() &gt; 0_s; }
</pre>
<hr />
<pre>
122 #if USE(APPKIT)
123     NSImage *nsImage() override;
124     RetainPtr&lt;NSImage&gt; snapshotNSImage() override;
125 #endif
126 
127 #if PLATFORM(COCOA)
128     CFDataRef tiffRepresentation() override;
129 #endif
130 
131 #if PLATFORM(WIN)
132     bool getHBITMAP(HBITMAP) override;
133     bool getHBITMAPOfSize(HBITMAP, const IntSize*) override;
134 #endif
135 
136 #if PLATFORM(GTK)
137     GdkPixbuf* getGdkPixbuf() override;
138 #endif
139 
140     WEBCORE_EXPORT NativeImagePtr nativeImage(const GraphicsContext* = nullptr) override;
141     NativeImagePtr nativeImageForCurrentFrame(const GraphicsContext* = nullptr) override;
<span class="line-added">142     NativeImagePtr nativeImageForCurrentFrameRespectingOrientation(const GraphicsContext* = nullptr) override;</span>
143 #if USE(CG)
144     NativeImagePtr nativeImageOfSize(const IntSize&amp;, const GraphicsContext* = nullptr) override;
145     Vector&lt;NativeImagePtr&gt; framesNativeImages();
146 #endif
147 
148     void imageFrameAvailableAtIndex(size_t);
149     void decode(Function&lt;void()&gt;&amp;&amp;);
150 
151 protected:
152     WEBCORE_EXPORT BitmapImage(NativeImagePtr&amp;&amp;, ImageObserver* = nullptr);
153     WEBCORE_EXPORT BitmapImage(ImageObserver* = nullptr);
154 
155     NativeImagePtr frameImageAtIndex(size_t index) { return m_source-&gt;frameImageAtIndex(index); }
156     NativeImagePtr frameImageAtIndexCacheIfNeeded(size_t, SubsamplingLevel = SubsamplingLevel::Default, const GraphicsContext* = nullptr);
157 
158     // Called to invalidate cached data. When |destroyAll| is true, we wipe out
159     // the entire frame buffer cache and tell the image source to destroy
160     // everything; this is used when e.g. we want to free some room in the image
161     // cache. If |destroyAll| is false, we only delete frames up to the current
162     // one; this is used while animating large images to keep memory footprint
</pre>
<hr />
<pre>
175 
176     // Animation.
177     enum class StartAnimationStatus { CannotStart, IncompleteData, TimerActive, DecodingActive, Started };
178     bool isAnimated() const override { return m_source-&gt;frameCount() &gt; 1; }
179     bool shouldAnimate() const;
180     void startAnimation() override { internalStartAnimation(); }
181     StartAnimationStatus internalStartAnimation();
182     void advanceAnimation();
183     void internalAdvanceAnimation();
184     bool isAnimating() const final;
185 
186     // It may look unusual that there is no start animation call as public API. This is because
187     // we start and stop animating lazily. Animation begins whenever someone draws the image. It will
188     // automatically pause once all observers no longer want to render the image anywhere.
189     void stopAnimation() override;
190     void resetAnimation() override;
191 
192     // Handle platform-specific data
193     void invalidatePlatformData();
194 
<span class="line-modified">195 #if ASSERT_ENABLED</span>
196     bool notSolidColor() override;
197 #endif
198 
199 #if PLATFORM(COCOA)
200     RetainPtr&lt;CFDataRef&gt; tiffRepresentation(const Vector&lt;NativeImagePtr&gt;&amp;);
201 #endif
202 
203 private:
204     void clearTimer();
205     void startTimer(Seconds delay);
206     SubsamplingLevel subsamplingLevelForScaleFactor(GraphicsContext&amp;, const FloatSize&amp; scaleFactor);
207     bool canDestroyDecodedData();
208     void setCurrentFrameDecodingStatusIfNecessary(DecodingStatus);
209     bool isBitmapImage() const override { return true; }
210     void callDecodingCallbacks();
211     void dump(WTF::TextStream&amp;) const override;
212 
213     // Animated images over a certain size are considered large enough that we&#39;ll only hang on to one frame at a time.
214     static const unsigned LargeAnimationCutoff = 30 * 1024 * 1024;
215 
</pre>
<hr />
<pre>
221     std::unique_ptr&lt;Timer&gt; m_frameTimer;
222     RepetitionCount m_repetitionsComplete { RepetitionCountNone }; // How many repetitions we&#39;ve finished.
223     MonotonicTime m_desiredFrameStartTime; // The system time at which we hope to see the next call to startAnimation().
224 
225     std::unique_ptr&lt;Vector&lt;Function&lt;void()&gt;, 1&gt;&gt; m_decodingCallbacks;
226 
227     bool m_animationFinished { false };
228 
229     // The default value of m_allowSubsampling should be the same as defaultImageSubsamplingEnabled in Settings.cpp
230 #if PLATFORM(IOS_FAMILY)
231     bool m_allowSubsampling { true };
232 #else
233     bool m_allowSubsampling { false };
234 #endif
235     bool m_allowAnimatedImageAsyncDecoding { false };
236     bool m_showDebugBackground { false };
237 
238     bool m_clearDecoderAfterAsyncFrameRequestForTesting { false };
239     bool m_largeImageAsyncDecodingEnabledForTesting { false };
240 
<span class="line-modified">241 #if ASSERT_ENABLED || !LOG_DISABLED</span>
242     size_t m_lateFrameCount { 0 };
243     size_t m_earlyFrameCount { 0 };
244     size_t m_cachedFrameCount { 0 };
245 #endif
246 
247     unsigned m_decodeCountForTesting { 0 };
248 
249 #if USE(APPKIT)
250     mutable RetainPtr&lt;NSImage&gt; m_nsImage; // A cached NSImage of all the frames. Only built lazily if someone actually queries for one.
251 #endif
252 #if USE(CG)
253     mutable RetainPtr&lt;CFDataRef&gt; m_tiffRep; // Cached TIFF rep for all the frames. Only built lazily if someone queries for one.
254 #endif
255     RefPtr&lt;Image&gt; m_cachedImage;
256 };
257 
258 } // namespace WebCore
259 
260 SPECIALIZE_TYPE_TRAITS_IMAGE(BitmapImage)
</pre>
</td>
</tr>
</table>
<center><a href="BitmapImage.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Color.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
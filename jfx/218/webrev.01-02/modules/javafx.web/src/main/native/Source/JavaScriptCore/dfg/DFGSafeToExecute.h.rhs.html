<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSafeToExecute.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 #include &quot;DFGGraph.h&quot;
 31 
 32 namespace JSC { namespace DFG {
 33 
<a name="1" id="anc1"></a><span class="line-added"> 34 // This phase is used to determine if a node can safely run at a new location.</span>
<span class="line-added"> 35 // It is important to note that returning false does not mean it&#39;s definitely</span>
<span class="line-added"> 36 // wrong to run the node at the new location. In other words, returning false</span>
<span class="line-added"> 37 // does not imply moving the node would be invalid only that this phase could</span>
<span class="line-added"> 38 // not prove it is valid. Thus, it is always ok to return false.</span>
<span class="line-added"> 39 </span>
 40 template&lt;typename AbstractStateType&gt;
 41 class SafeToExecuteEdge {
 42 public:
 43     SafeToExecuteEdge(AbstractStateType&amp; state)
 44         : m_state(state)
 45     {
 46     }
 47 
 48     void operator()(Node*, Edge edge)
 49     {
 50         m_maySeeEmptyChild |= !!(m_state.forNode(edge).m_type &amp; SpecEmpty);
 51 
 52         switch (edge.useKind()) {
 53         case UntypedUse:
 54         case Int32Use:
 55         case DoubleRepUse:
 56         case DoubleRepRealUse:
 57         case Int52RepUse:
 58         case NumberUse:
 59         case RealNumberUse:
 60         case BooleanUse:
 61         case CellUse:
 62         case CellOrOtherUse:
 63         case ObjectUse:
 64         case ArrayUse:
 65         case FunctionUse:
 66         case FinalObjectUse:
 67         case RegExpObjectUse:
<a name="2" id="anc2"></a><span class="line-added"> 68         case PromiseObjectUse:</span>
 69         case ProxyObjectUse:
 70         case DerivedArrayUse:
<a name="3" id="anc3"></a><span class="line-added"> 71         case DateObjectUse:</span>
 72         case MapObjectUse:
 73         case SetObjectUse:
 74         case WeakMapObjectUse:
 75         case WeakSetObjectUse:
 76         case DataViewObjectUse:
 77         case ObjectOrOtherUse:
 78         case StringIdentUse:
 79         case StringUse:
 80         case StringOrOtherUse:
 81         case SymbolUse:
 82         case BigIntUse:
 83         case StringObjectUse:
 84         case StringOrStringObjectUse:
 85         case NotStringVarUse:
 86         case NotSymbolUse:
 87         case NotCellUse:
 88         case OtherUse:
 89         case MiscUse:
 90         case AnyIntUse:
 91         case DoubleRepAnyIntUse:
 92             return;
 93 
 94         case KnownInt32Use:
 95             if (m_state.forNode(edge).m_type &amp; ~SpecInt32Only)
 96                 m_result = false;
 97             return;
 98 
 99         case KnownBooleanUse:
100             if (m_state.forNode(edge).m_type &amp; ~SpecBoolean)
101                 m_result = false;
102             return;
103 
104         case KnownCellUse:
105             if (m_state.forNode(edge).m_type &amp; ~SpecCell)
106                 m_result = false;
107             return;
108 
109         case KnownStringUse:
110             if (m_state.forNode(edge).m_type &amp; ~SpecString)
111                 m_result = false;
112             return;
113 
114         case KnownPrimitiveUse:
115             if (m_state.forNode(edge).m_type &amp; ~(SpecHeapTop &amp; ~SpecObject))
116                 m_result = false;
117             return;
118 
119         case KnownOtherUse:
120             if (m_state.forNode(edge).m_type &amp; ~SpecOther)
121                 m_result = false;
122             return;
123 
124         case LastUseKind:
125             RELEASE_ASSERT_NOT_REACHED();
126             break;
127         }
128         RELEASE_ASSERT_NOT_REACHED();
129     }
130 
131     bool result() const { return m_result; }
132     bool maySeeEmptyChild() const { return m_maySeeEmptyChild; }
133 private:
134     AbstractStateType&amp; m_state;
135     bool m_result { true };
136     bool m_maySeeEmptyChild { false };
137 };
138 
139 // Determines if it&#39;s safe to execute a node within the given abstract state. This may
140 // return false conservatively. If it returns true, then you can hoist the given node
141 // up to the given point and expect that it will not crash. It also guarantees that the
142 // node will not produce a malformed JSValue or object pointer when executed in the
143 // given state. But this doesn&#39;t guarantee that the node will produce the result you
144 // wanted. For example, you may have a GetByOffset from a prototype that only makes
145 // semantic sense if you&#39;ve also checked that some nearer prototype doesn&#39;t also have
146 // a property of the same name. This could still return true even if that check hadn&#39;t
147 // been performed in the given abstract state. That&#39;s fine though: the load can still
148 // safely execute before that check, so long as that check continues to guard any
149 // user-observable things done to the loaded value.
150 template&lt;typename AbstractStateType&gt;
151 bool safeToExecute(AbstractStateType&amp; state, Graph&amp; graph, Node* node, bool ignoreEmptyChildren = false)
152 {
153     SafeToExecuteEdge&lt;AbstractStateType&gt; safeToExecuteEdge(state);
154     DFG_NODE_DO_TO_CHILDREN(graph, node, safeToExecuteEdge);
155     if (!safeToExecuteEdge.result())
156         return false;
157 
158     if (!ignoreEmptyChildren &amp;&amp; safeToExecuteEdge.maySeeEmptyChild()) {
159         // We conservatively assume if the empty value flows into a node,
160         // it might not be able to handle it (e.g, crash). In general, the bytecode generator
161         // emits code in such a way that most node types don&#39;t need to worry about the empty value
162         // because they will never see it. However, code motion has to consider the empty
163         // value so it does not insert/move nodes to a place where they will crash. E.g, the
164         // type check hoisting phase needs to insert CheckStructureOrEmpty instead of CheckStructure
165         // for hoisted structure checks because it can not guarantee that a particular local is not
166         // the empty value.
167         switch (node-&gt;op()) {
168         case CheckNotEmpty:
169         case CheckStructureOrEmpty:
<a name="4" id="anc4"></a><span class="line-added">170         case CheckArrayOrEmpty:</span>
171             break;
172         default:
173             return false;
174         }
175     }
176 
<a name="5" id="anc5"></a><span class="line-modified">177     // NOTE: This can lie when it comes to effectful nodes, because it knows that they aren&#39;t going to</span>
<span class="line-modified">178     // get hoisted anyway. Sometimes this is convenient so we can avoid branching on some internal</span>
<span class="line-added">179     // state of the node (like what some child&#39;s UseKind might be). However, nodes that are obviously</span>
<span class="line-added">180     // always effectful, we return false for, to make auditing the &quot;return true&quot; cases easier.</span>
181 
182     switch (node-&gt;op()) {
<a name="6" id="anc6"></a><span class="line-added">183     // FIXME: Audit these:</span>
<span class="line-added">184     // https://bugs.webkit.org/show_bug.cgi?id=207075</span>
185     case JSConstant:
186     case DoubleConstant:
187     case Int52Constant:
188     case LazyJSConstant:
189     case Identity:
190     case IdentityWithProfile:
<a name="7" id="anc7"></a>



191     case GetCallee:
<a name="8" id="anc8"></a>
192     case GetArgumentCountIncludingThis:
<a name="9" id="anc9"></a>
193     case GetRestLength:
194     case GetLocal:
<a name="10" id="anc10"></a>


195     case GetStack:
<a name="11" id="anc11"></a>

196     case ExitOK:
197     case Phantom:
<a name="12" id="anc12"></a>





198     case ArithBitNot:
199     case ArithBitAnd:
200     case ArithBitOr:
201     case ArithBitXor:
202     case ArithBitLShift:
<a name="13" id="anc13"></a><span class="line-modified">203     case ArithBitRShift:</span>
204     case BitURShift:
205     case ValueToInt32:
206     case UInt32ToNumber:
207     case DoubleAsInt32:
208     case ArithAdd:
209     case ArithClz32:
210     case ArithSub:
211     case ArithNegate:
212     case ArithMul:
213     case ArithIMul:
214     case ArithDiv:
215     case ArithMod:
216     case ArithAbs:
217     case ArithMin:
218     case ArithMax:
219     case ArithPow:
220     case ArithRandom:
221     case ArithSqrt:
222     case ArithFRound:
223     case ArithRound:
224     case ArithFloor:
225     case ArithCeil:
226     case ArithTrunc:
227     case ArithUnary:
<a name="14" id="anc14"></a><span class="line-modified">228     case TryGetById: // FIXME: Audit this: https://bugs.webkit.org/show_bug.cgi?id=163834</span>
































229     case CheckStructure:
230     case CheckStructureOrEmpty:
231     case GetExecutable:
<a name="15" id="anc15"></a>
232     case CallDOMGetter:
233     case CallDOM:
234     case CheckSubClass:
235     case CheckArray:
<a name="16" id="anc16"></a><span class="line-modified">236     case CheckArrayOrEmpty:</span>

237     case GetScope:
238     case SkipScope:
239     case GetGlobalObject:
240     case GetGlobalThis:
241     case GetClosureVar:
<a name="17" id="anc17"></a>
242     case GetGlobalVar:
243     case GetGlobalLexicalVariable:
<a name="18" id="anc18"></a>
244     case CheckCell:
<a name="19" id="anc19"></a>
245     case CheckNotEmpty:
246     case AssertNotEmpty:
<a name="20" id="anc20"></a><span class="line-modified">247     case CheckIdent:</span>





248     case CompareLess:
249     case CompareLessEq:
250     case CompareGreater:
251     case CompareGreaterEq:
252     case CompareBelow:
253     case CompareBelowEq:
254     case CompareEq:
255     case CompareStrictEq:
256     case CompareEqPtr:
257     case SameValue:
<a name="21" id="anc21"></a>























258     case CheckTypeInfoFlags:
259     case ParseInt:
260     case OverridesHasInstance:
<a name="22" id="anc22"></a>

261     case IsEmpty:
262     case IsUndefined:
263     case IsUndefinedOrNull:
264     case IsBoolean:
265     case IsNumber:
266     case NumberIsInteger:
267     case IsObject:
268     case IsObjectOrNull:
269     case IsFunction:
270     case IsCellWithType:
271     case IsTypedArrayView:
272     case TypeOf:
273     case LogicalNot:
<a name="23" id="anc23"></a>

274     case ToString:
<a name="24" id="anc24"></a>


275     case NumberToStringWithValidRadixConstant:
<a name="25" id="anc25"></a>
276     case StrCat:
277     case CallStringConstructor:
<a name="26" id="anc26"></a>
278     case MakeRope:
<a name="27" id="anc27"></a>







279     case GetFromArguments:
280     case GetArgument:
<a name="28" id="anc28"></a>























281     case StringFromCharCode:
<a name="29" id="anc29"></a>

282     case ExtractOSREntryLocal:
283     case ExtractCatchLocal:
<a name="30" id="anc30"></a>






284     case CheckInBounds:
285     case ConstantStoragePointer:
286     case Check:
287     case CheckVarargs:
<a name="31" id="anc31"></a>
288     case ValueRep:
289     case DoubleRep:
290     case Int52Rep:
291     case BooleanToNumber:
292     case FiatInt52:
<a name="32" id="anc32"></a>




293     case HasIndexedProperty:
<a name="33" id="anc33"></a>

294     case GetEnumeratorStructurePname:
295     case GetEnumeratorGenericPname:
296     case ToIndexString:
<a name="34" id="anc34"></a>







297     case CheckStructureImmediate:
<a name="35" id="anc35"></a>







298     case GetMyArgumentByVal:
299     case GetMyArgumentByValOutOfBounds:
<a name="36" id="anc36"></a>

300     case GetPrototypeOf:
301     case StringReplace:
302     case StringReplaceRegExp:
303     case GetRegExpObjectLastIndex:
<a name="37" id="anc37"></a>





304     case MapHash:
305     case NormalizeMapKey:
<a name="38" id="anc38"></a>
306     case StringSlice:
307     case ToLowerCase:
308     case GetMapBucket:
309     case GetMapBucketHead:
310     case GetMapBucketNext:
311     case LoadKeyFromMapBucket:
312     case LoadValueFromMapBucket:
313     case ExtractValueFromWeakMapGet:
314     case WeakMapGet:
<a name="39" id="anc39"></a>










315     case AtomicsIsLockFree:
<a name="40" id="anc40"></a>
316     case MatchStructure:
<a name="41" id="anc41"></a><span class="line-added">317     case DateGetInt32OrNaN:</span>
<span class="line-added">318     case DateGetTime:</span>
319     case DataViewGetInt:
320     case DataViewGetFloat:
321         return true;
322 
<a name="42" id="anc42"></a><span class="line-added">323     case GetButterfly:</span>
<span class="line-added">324         return state.forNode(node-&gt;child1()).isType(SpecObject);</span>
<span class="line-added">325 </span>
326     case ArraySlice:
327     case ArrayIndexOf: {
328         // You could plausibly move this code around as long as you proved the
329         // incoming array base structure is an original array at the hoisted location.
330         // Instead of doing that extra work, we just conservatively return false.
331         return false;
332     }
333 
<a name="43" id="anc43"></a><span class="line-added">334     case GetGetter:</span>
<span class="line-added">335     case GetSetter: {</span>
<span class="line-added">336         if (!state.forNode(node-&gt;child1()).isType(SpecCell))</span>
<span class="line-added">337             return false;</span>
<span class="line-added">338         StructureAbstractValue&amp; value = state.forNode(node-&gt;child1()).m_structure;</span>
<span class="line-added">339         if (value.isInfinite() || value.size() != 1)</span>
<span class="line-added">340             return false;</span>
<span class="line-added">341 </span>
<span class="line-added">342         return value[0].get() == graph.m_vm.getterSetterStructure;</span>
<span class="line-added">343     }</span>
<span class="line-added">344 </span>
345     case BottomValue:
346         // If in doubt, assume that this isn&#39;t safe to execute, just because we have no way of
347         // compiling this node.
348         return false;
349 
350     case StoreBarrier:
351     case FencedStoreBarrier:
352     case PutStructure:
353     case NukeStructureAndSetButterfly:
354         // We conservatively assume that these cannot be put anywhere, which forces the compiler to
355         // keep them exactly where they were. This is sort of overkill since the clobberize effects
356         // already force these things to be ordered precisely. I&#39;m just not confident enough in my
357         // effect based memory model to rely solely on that right now.
358         return false;
359 
360     case FilterCallLinkStatus:
<a name="44" id="anc44"></a><span class="line-modified">361     case FilterGetByStatus:</span>
362     case FilterPutByIdStatus:
363     case FilterInByIdStatus:
364         // We don&#39;t want these to be moved anywhere other than where we put them, since we want them
365         // to capture &quot;profiling&quot; at the point in control flow here the user put them.
366         return false;
367 
368     case GetByVal:
369     case GetIndexedPropertyStorage:
370     case GetArrayLength:
371     case GetVectorLength:
372     case ArrayPop:
373     case StringCharAt:
374     case StringCharCodeAt:
<a name="45" id="anc45"></a><span class="line-added">375     case StringCodePointAt:</span>
376         return node-&gt;arrayMode().alreadyChecked(graph, node, state.forNode(graph.child(node, 0)));
377 
378     case ArrayPush:
379         return node-&gt;arrayMode().alreadyChecked(graph, node, state.forNode(graph.varArgChild(node, 1)));
380 
<a name="46" id="anc46"></a><span class="line-added">381     case CheckNeutered:</span>
382     case GetTypedArrayByteOffset:
383         return !(state.forNode(node-&gt;child1()).m_type &amp; ~(SpecTypedArrayView));
384 
385     case PutByValDirect:
386     case PutByVal:
387     case PutByValAlias:
388         return node-&gt;arrayMode().modeForPut().alreadyChecked(
389             graph, node, state.forNode(graph.varArgChild(node, 0)));
390 
391     case AllocatePropertyStorage:
392     case ReallocatePropertyStorage:
393         return state.forNode(node-&gt;child1()).m_structure.isSubsetOf(
394             RegisteredStructureSet(node-&gt;transition()-&gt;previous));
395 
<a name="47" id="anc47"></a><span class="line-added">396     case GetGetterSetterByOffset: {</span>
<span class="line-added">397         // If it&#39;s an inline property, we need to make sure it&#39;s a cell before trusting what the structure set tells us.</span>
<span class="line-added">398         if (node-&gt;child1().node() == node-&gt;child2().node() &amp;&amp; !state.forNode(node-&gt;child2()).isType(SpecCell))</span>
<span class="line-added">399             return false;</span>
<span class="line-added">400 </span>
<span class="line-added">401         StorageAccessData&amp; data = node-&gt;storageAccessData();</span>
<span class="line-added">402         auto* uid = graph.identifiers()[data.identifierNumber];</span>
<span class="line-added">403         PropertyOffset desiredOffset = data.offset;</span>
<span class="line-added">404         StructureAbstractValue&amp; value = state.forNode(node-&gt;child2()).m_structure;</span>
<span class="line-added">405         if (value.isInfinite())</span>
<span class="line-added">406             return false;</span>
<span class="line-added">407         for (unsigned i = value.size(); i--;) {</span>
<span class="line-added">408             Structure* thisStructure = value[i].get();</span>
<span class="line-added">409             if (thisStructure-&gt;isUncacheableDictionary())</span>
<span class="line-added">410                 return false;</span>
<span class="line-added">411             unsigned attributes = 0;</span>
<span class="line-added">412             PropertyOffset checkOffset = thisStructure-&gt;getConcurrently(uid, attributes);</span>
<span class="line-added">413             if (checkOffset != desiredOffset || !(attributes &amp; PropertyAttribute::Accessor))</span>
<span class="line-added">414                 return false;</span>
<span class="line-added">415         }</span>
<span class="line-added">416         return true;</span>
<span class="line-added">417     }</span>
<span class="line-added">418 </span>
419     case GetByOffset:
<a name="48" id="anc48"></a>
420     case PutByOffset: {
<a name="49" id="anc49"></a><span class="line-added">421         // If it&#39;s an inline property, we need to make sure it&#39;s a cell before trusting what the structure set tells us.</span>
<span class="line-added">422         if (node-&gt;child1().node() == node-&gt;child2().node() &amp;&amp; !state.forNode(node-&gt;child2()).isType(SpecCell))</span>
<span class="line-added">423             return false;</span>
<span class="line-added">424 </span>
425         StorageAccessData&amp; data = node-&gt;storageAccessData();
426         PropertyOffset offset = data.offset;
427         // Graph::isSafeToLoad() is all about proofs derived from PropertyConditions. Those don&#39;t
428         // know anything about inferred types. But if we have a proof derived from watching a
429         // structure that has a type proof, then the next case below will deal with it.
430         if (state.structureClobberState() == StructuresAreWatched) {
431             if (JSObject* knownBase = node-&gt;child2()-&gt;dynamicCastConstant&lt;JSObject*&gt;(graph.m_vm)) {
432                 if (graph.isSafeToLoad(knownBase, offset))
433                     return true;
434             }
435         }
436 
437         StructureAbstractValue&amp; value = state.forNode(node-&gt;child2()).m_structure;
438         if (value.isInfinite())
439             return false;
440         for (unsigned i = value.size(); i--;) {
441             Structure* thisStructure = value[i].get();
<a name="50" id="anc50"></a><span class="line-added">442             if (thisStructure-&gt;isUncacheableDictionary())</span>
<span class="line-added">443                 return false;</span>
444             if (!thisStructure-&gt;isValidOffset(offset))
445                 return false;
446         }
447         return true;
448     }
449 
450     case MultiGetByOffset: {
451         // We can&#39;t always guarantee that the MultiGetByOffset is safe to execute if it
452         // contains loads from prototypes. If the load requires a check in IR, which is rare, then
453         // we currently claim that we don&#39;t know if it&#39;s safe to execute because finding that
454         // check in the abstract state would be hard. If the load requires watchpoints, we just
455         // check if we&#39;re not in a clobbered state (i.e. in between a side effect and an
456         // invalidation point).
457         for (const MultiGetByOffsetCase&amp; getCase : node-&gt;multiGetByOffsetData().cases) {
458             GetByOffsetMethod method = getCase.method();
459             switch (method.kind()) {
460             case GetByOffsetMethod::Invalid:
461                 RELEASE_ASSERT_NOT_REACHED();
462                 break;
463             case GetByOffsetMethod::Constant: // OK because constants are always safe to execute.
464             case GetByOffsetMethod::Load: // OK because the MultiGetByOffset has its own checks for loading from self.
465                 break;
466             case GetByOffsetMethod::LoadFromPrototype:
467                 // Only OK if the state isn&#39;t clobbered. That&#39;s almost always the case.
468                 if (state.structureClobberState() != StructuresAreWatched)
469                     return false;
470                 if (!graph.isSafeToLoad(method.prototype()-&gt;cast&lt;JSObject*&gt;(), method.offset()))
471                     return false;
472                 break;
473             }
474         }
475         return true;
476     }
477 
<a name="51" id="anc51"></a><span class="line-added">478     case ToThis:</span>
<span class="line-added">479     case CreateThis:</span>
<span class="line-added">480     case CreatePromise:</span>
<span class="line-added">481     case CreateGenerator:</span>
<span class="line-added">482     case CreateAsyncGenerator:</span>
<span class="line-added">483     case ObjectCreate:</span>
<span class="line-added">484     case ObjectKeys:</span>
<span class="line-added">485     case SetLocal:</span>
<span class="line-added">486     case SetCallee:</span>
<span class="line-added">487     case PutStack:</span>
<span class="line-added">488     case KillStack:</span>
<span class="line-added">489     case MovHint:</span>
<span class="line-added">490     case ZombieHint:</span>
<span class="line-added">491     case Upsilon:</span>
<span class="line-added">492     case Phi:</span>
<span class="line-added">493     case Flush:</span>
<span class="line-added">494     case SetArgumentDefinitely:</span>
<span class="line-added">495     case SetArgumentMaybe:</span>
<span class="line-added">496     case SetArgumentCountIncludingThis:</span>
<span class="line-added">497     case PhantomLocal:</span>
<span class="line-added">498     case DeleteById:</span>
<span class="line-added">499     case DeleteByVal:</span>
<span class="line-added">500     case GetById:</span>
<span class="line-added">501     case GetByIdWithThis:</span>
<span class="line-added">502     case GetByValWithThis:</span>
<span class="line-added">503     case GetByIdFlush:</span>
<span class="line-added">504     case GetByIdDirect:</span>
<span class="line-added">505     case GetByIdDirectFlush:</span>
<span class="line-added">506     case PutById:</span>
<span class="line-added">507     case PutByIdFlush:</span>
<span class="line-added">508     case PutByIdWithThis:</span>
<span class="line-added">509     case PutByValWithThis:</span>
<span class="line-added">510     case PutByIdDirect:</span>
<span class="line-added">511     case PutGetterById:</span>
<span class="line-added">512     case PutSetterById:</span>
<span class="line-added">513     case PutGetterSetterById:</span>
<span class="line-added">514     case PutGetterByVal:</span>
<span class="line-added">515     case PutSetterByVal:</span>
<span class="line-added">516     case DefineDataProperty:</span>
<span class="line-added">517     case DefineAccessorProperty:</span>
<span class="line-added">518     case Arrayify:</span>
<span class="line-added">519     case ArrayifyToStructure:</span>
<span class="line-added">520     case PutClosureVar:</span>
<span class="line-added">521     case PutGlobalVariable:</span>
<span class="line-added">522     case CheckBadCell:</span>
<span class="line-added">523     case RegExpExec:</span>
<span class="line-added">524     case RegExpExecNonGlobalOrSticky:</span>
<span class="line-added">525     case RegExpTest:</span>
<span class="line-added">526     case RegExpMatchFast:</span>
<span class="line-added">527     case RegExpMatchFastGlobal:</span>
<span class="line-added">528     case Call:</span>
<span class="line-added">529     case DirectCall:</span>
<span class="line-added">530     case TailCallInlinedCaller:</span>
<span class="line-added">531     case DirectTailCallInlinedCaller:</span>
<span class="line-added">532     case Construct:</span>
<span class="line-added">533     case DirectConstruct:</span>
<span class="line-added">534     case CallVarargs:</span>
<span class="line-added">535     case CallEval:</span>
<span class="line-added">536     case TailCallVarargsInlinedCaller:</span>
<span class="line-added">537     case TailCallForwardVarargsInlinedCaller:</span>
<span class="line-added">538     case ConstructVarargs:</span>
<span class="line-added">539     case VarargsLength:</span>
<span class="line-added">540     case LoadVarargs:</span>
<span class="line-added">541     case CallForwardVarargs:</span>
<span class="line-added">542     case ConstructForwardVarargs:</span>
<span class="line-added">543     case NewObject:</span>
<span class="line-added">544     case NewPromise:</span>
<span class="line-added">545     case NewGenerator:</span>
<span class="line-added">546     case NewAsyncGenerator:</span>
<span class="line-added">547     case NewArray:</span>
<span class="line-added">548     case NewArrayWithSize:</span>
<span class="line-added">549     case NewArrayBuffer:</span>
<span class="line-added">550     case NewArrayWithSpread:</span>
<span class="line-added">551     case NewArrayIterator:</span>
<span class="line-added">552     case Spread:</span>
<span class="line-added">553     case NewRegexp:</span>
<span class="line-added">554     case NewSymbol:</span>
<span class="line-added">555     case ProfileType:</span>
<span class="line-added">556     case ProfileControlFlow:</span>
<span class="line-added">557     case InstanceOf:</span>
<span class="line-added">558     case InstanceOfCustom:</span>
<span class="line-added">559     case CallObjectConstructor:</span>
<span class="line-added">560     case ToPrimitive:</span>
<span class="line-added">561     case ToPropertyKey:</span>
<span class="line-added">562     case ToNumber:</span>
<span class="line-added">563     case ToNumeric:</span>
<span class="line-added">564     case ToObject:</span>
<span class="line-added">565     case NumberToStringWithRadix:</span>
<span class="line-added">566     case SetFunctionName:</span>
<span class="line-added">567     case NewStringObject:</span>
<span class="line-added">568     case InByVal:</span>
<span class="line-added">569     case InById:</span>
<span class="line-added">570     case HasOwnProperty:</span>
<span class="line-added">571     case PushWithScope:</span>
<span class="line-added">572     case CreateActivation:</span>
<span class="line-added">573     case CreateDirectArguments:</span>
<span class="line-added">574     case CreateScopedArguments:</span>
<span class="line-added">575     case CreateClonedArguments:</span>
<span class="line-added">576     case CreateArgumentsButterfly:</span>
<span class="line-added">577     case PutToArguments:</span>
<span class="line-added">578     case NewFunction:</span>
<span class="line-added">579     case NewGeneratorFunction:</span>
<span class="line-added">580     case NewAsyncGeneratorFunction:</span>
<span class="line-added">581     case NewAsyncFunction:</span>
<span class="line-added">582     case Jump:</span>
<span class="line-added">583     case Branch:</span>
<span class="line-added">584     case Switch:</span>
<span class="line-added">585     case EntrySwitch:</span>
<span class="line-added">586     case Return:</span>
<span class="line-added">587     case TailCall:</span>
<span class="line-added">588     case DirectTailCall:</span>
<span class="line-added">589     case TailCallVarargs:</span>
<span class="line-added">590     case TailCallForwardVarargs:</span>
<span class="line-added">591     case Throw:</span>
<span class="line-added">592     case ThrowStaticError:</span>
<span class="line-added">593     case CountExecution:</span>
<span class="line-added">594     case SuperSamplerBegin:</span>
<span class="line-added">595     case SuperSamplerEnd:</span>
<span class="line-added">596     case ForceOSRExit:</span>
<span class="line-added">597     case CPUIntrinsic:</span>
<span class="line-added">598     case CheckTraps:</span>
<span class="line-added">599     case LogShadowChickenPrologue:</span>
<span class="line-added">600     case LogShadowChickenTail:</span>
<span class="line-added">601     case NewTypedArray:</span>
<span class="line-added">602     case Unreachable:</span>
<span class="line-added">603     case ClearCatchLocals:</span>
<span class="line-added">604     case CheckTierUpInLoop:</span>
<span class="line-added">605     case CheckTierUpAtReturn:</span>
<span class="line-added">606     case CheckTierUpAndOSREnter:</span>
<span class="line-added">607     case LoopHint:</span>
<span class="line-added">608     case InvalidationPoint:</span>
<span class="line-added">609     case NotifyWrite:</span>
<span class="line-added">610     case MultiPutByOffset:</span>
<span class="line-added">611     case GetEnumerableLength:</span>
<span class="line-added">612     case HasGenericProperty:</span>
<span class="line-added">613     case HasStructureProperty:</span>
<span class="line-added">614     case GetDirectPname:</span>
<span class="line-added">615     case GetPropertyEnumerator:</span>
<span class="line-added">616     case PhantomNewObject:</span>
<span class="line-added">617     case PhantomNewFunction:</span>
<span class="line-added">618     case PhantomNewGeneratorFunction:</span>
<span class="line-added">619     case PhantomNewAsyncGeneratorFunction:</span>
<span class="line-added">620     case PhantomNewAsyncFunction:</span>
<span class="line-added">621     case PhantomNewArrayIterator:</span>
<span class="line-added">622     case PhantomCreateActivation:</span>
<span class="line-added">623     case PhantomNewRegexp:</span>
<span class="line-added">624     case PutHint:</span>
<span class="line-added">625     case MaterializeNewObject:</span>
<span class="line-added">626     case MaterializeCreateActivation:</span>
<span class="line-added">627     case MaterializeNewInternalFieldObject:</span>
<span class="line-added">628     case PhantomDirectArguments:</span>
<span class="line-added">629     case PhantomCreateRest:</span>
<span class="line-added">630     case PhantomSpread:</span>
<span class="line-added">631     case PhantomNewArrayWithSpread:</span>
<span class="line-added">632     case PhantomNewArrayBuffer:</span>
<span class="line-added">633     case PhantomClonedArguments:</span>
<span class="line-added">634     case ForwardVarargs:</span>
<span class="line-added">635     case CreateRest:</span>
<span class="line-added">636     case SetRegExpObjectLastIndex:</span>
<span class="line-added">637     case RecordRegExpCachedResult:</span>
<span class="line-added">638     case GetDynamicVar:</span>
<span class="line-added">639     case PutDynamicVar:</span>
<span class="line-added">640     case ResolveScopeForHoistingFuncDeclInEval:</span>
<span class="line-added">641     case ResolveScope:</span>
<span class="line-added">642     case StringValueOf:</span>
<span class="line-added">643     case WeakSetAdd:</span>
<span class="line-added">644     case WeakMapSet:</span>
<span class="line-added">645     case AtomicsAdd:</span>
<span class="line-added">646     case AtomicsAnd:</span>
<span class="line-added">647     case AtomicsCompareExchange:</span>
<span class="line-added">648     case AtomicsExchange:</span>
<span class="line-added">649     case AtomicsLoad:</span>
<span class="line-added">650     case AtomicsOr:</span>
<span class="line-added">651     case AtomicsStore:</span>
<span class="line-added">652     case AtomicsSub:</span>
<span class="line-added">653     case AtomicsXor:</span>
<span class="line-added">654     case InitializeEntrypointArguments:</span>
<span class="line-added">655     case ValueNegate:</span>
<span class="line-added">656     case GetInternalField:</span>
<span class="line-added">657     case PutInternalField:</span>
658     case DataViewSet:
<a name="52" id="anc52"></a>

659     case SetAdd:
660     case MapSet:
661         return false;
662 
<a name="53" id="anc53"></a><span class="line-added">663     case Inc:</span>
<span class="line-added">664     case Dec:</span>
<span class="line-added">665         return node-&gt;child1().useKind() != UntypedUse;</span>
<span class="line-added">666 </span>
<span class="line-added">667     case ValueBitAnd:</span>
<span class="line-added">668     case ValueBitXor:</span>
<span class="line-added">669     case ValueBitOr:</span>
<span class="line-added">670     case ValueBitLShift:</span>
<span class="line-added">671     case ValueBitRShift:</span>
<span class="line-added">672     case ValueAdd:</span>
<span class="line-added">673     case ValueSub:</span>
<span class="line-added">674     case ValueMul:</span>
<span class="line-added">675     case ValueDiv:</span>
<span class="line-added">676     case ValueMod:</span>
<span class="line-added">677     case ValuePow:</span>
<span class="line-added">678         return node-&gt;isBinaryUseKind(BigIntUse);</span>
<span class="line-added">679 </span>
<span class="line-added">680     case ValueBitNot:</span>
<span class="line-added">681         return node-&gt;child1().useKind() == BigIntUse;</span>
<span class="line-added">682 </span>
683     case LastNodeType:
684         RELEASE_ASSERT_NOT_REACHED();
685         return false;
686     }
687 
688     RELEASE_ASSERT_NOT_REACHED();
689     return false;
690 }
691 
692 } } // namespace JSC::DFG
693 
694 #endif // ENABLE(DFG_JIT)
<a name="54" id="anc54"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="54" type="hidden" />
</body>
</html>
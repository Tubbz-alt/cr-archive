<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGRenderTreeAsText.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGRenderSupport.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGRenderingContext.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGRenderTreeAsText.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
185             writeSVGPaintingResource(ts, strokePaintingResource);
186 
187             SVGLengthContext lengthContext(&amp;shape.graphicsElement());
188             double dashOffset = lengthContext.valueForLength(svgStyle.strokeDashOffset());
189             double strokeWidth = lengthContext.valueForLength(style.strokeWidth());
190             const auto&amp; dashes = svgStyle.strokeDashArray();
191 
192             DashArray dashArray;
193             for (auto&amp; length : dashes)
194                 dashArray.append(length.value(lengthContext));
195 
196             writeIfNotDefault(ts, &quot;opacity&quot;, svgStyle.strokeOpacity(), 1.0f);
197             writeIfNotDefault(ts, &quot;stroke width&quot;, strokeWidth, 1.0);
198             writeIfNotDefault(ts, &quot;miter limit&quot;, style.strokeMiterLimit(), 4.0f);
199             writeIfNotDefault(ts, &quot;line cap&quot;, style.capStyle(), ButtCap);
200             writeIfNotDefault(ts, &quot;line join&quot;, style.joinStyle(), MiterJoin);
201             writeIfNotDefault(ts, &quot;dash offset&quot;, dashOffset, 0.0);
202             if (!dashArray.isEmpty())
203                 writeNameValuePair(ts, &quot;dash array&quot;, dashArray);
204 





205             ts &lt;&lt; &quot;}]&quot;;
206         }
207 
208         if (RenderSVGResource* fillPaintingResource = RenderSVGResource::fillPaintingResource(const_cast&lt;RenderSVGShape&amp;&gt;(shape), shape.style(), fallbackColor)) {
209             TextStreamSeparator s(&quot; &quot;);
210             ts &lt;&lt; &quot; [fill={&quot; &lt;&lt; s;
211             writeSVGPaintingResource(ts, fillPaintingResource);
212 
213             writeIfNotDefault(ts, &quot;opacity&quot;, svgStyle.fillOpacity(), 1.0f);
214             writeIfNotDefault(ts, &quot;fill rule&quot;, svgStyle.fillRule(), WindRule::NonZero);
215             ts &lt;&lt; &quot;}]&quot;;
216         }
217         writeIfNotDefault(ts, &quot;clip rule&quot;, svgStyle.clipRule(), WindRule::NonZero);
218     }
219 
220     writeIfNotEmpty(ts, &quot;start marker&quot;, svgStyle.markerStartResource());
221     writeIfNotEmpty(ts, &quot;middle marker&quot;, svgStyle.markerMidResource());
222     writeIfNotEmpty(ts, &quot;end marker&quot;, svgStyle.markerEndResource());
223 }
224 
</pre>
<hr />
<pre>
546 
547     ts &lt;&lt; &quot; [offset=&quot; &lt;&lt; stop.element().offset() &lt;&lt; &quot;] [color=&quot; &lt;&lt; stop.element().stopColorIncludingOpacity() &lt;&lt; &quot;]\n&quot;;
548 }
549 
550 void writeResources(TextStream&amp; ts, const RenderObject&amp; renderer, OptionSet&lt;RenderAsTextFlag&gt; behavior)
551 {
552     const RenderStyle&amp; style = renderer.style();
553     const SVGRenderStyle&amp; svgStyle = style.svgStyle();
554 
555     // FIXME: We want to use SVGResourcesCache to determine which resources are present, instead of quering the resource &lt;-&gt; id cache.
556     // For now leave the DRT output as is, but later on we should change this so cycles are properly ignored in the DRT output.
557     if (!svgStyle.maskerResource().isEmpty()) {
558         if (RenderSVGResourceMasker* masker = getRenderSVGResourceById&lt;RenderSVGResourceMasker&gt;(renderer.document(), svgStyle.maskerResource())) {
559             ts &lt;&lt; indent &lt;&lt; &quot; &quot;;
560             writeNameAndQuotedValue(ts, &quot;masker&quot;, svgStyle.maskerResource());
561             ts &lt;&lt; &quot; &quot;;
562             writeStandardPrefix(ts, *masker, behavior, WriteIndentOrNot::No);
563             ts &lt;&lt; &quot; &quot; &lt;&lt; masker-&gt;resourceBoundingBox(renderer) &lt;&lt; &quot;\n&quot;;
564         }
565     }
<span class="line-modified">566     if (!svgStyle.clipperResource().isEmpty()) {</span>
<span class="line-modified">567         if (RenderSVGResourceClipper* clipper = getRenderSVGResourceById&lt;RenderSVGResourceClipper&gt;(renderer.document(), svgStyle.clipperResource())) {</span>


568             ts &lt;&lt; indent &lt;&lt; &quot; &quot;;
<span class="line-modified">569             writeNameAndQuotedValue(ts, &quot;clipPath&quot;, svgStyle.clipperResource());</span>
570             ts &lt;&lt; &quot; &quot;;
571             writeStandardPrefix(ts, *clipper, behavior, WriteIndentOrNot::No);
572             ts &lt;&lt; &quot; &quot; &lt;&lt; clipper-&gt;resourceBoundingBox(renderer) &lt;&lt; &quot;\n&quot;;
573         }
574     }
575     if (style.hasFilter()) {
576         const FilterOperations&amp; filterOperations = style.filter();
577         if (filterOperations.size() == 1) {
578             const FilterOperation&amp; filterOperation = *filterOperations.at(0);
579             if (filterOperation.type() == FilterOperation::REFERENCE) {
580                 const auto&amp; referenceFilterOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
581                 AtomString id = SVGURIReference::fragmentIdentifierFromIRIString(referenceFilterOperation.url(), renderer.document());
582                 if (RenderSVGResourceFilter* filter = getRenderSVGResourceById&lt;RenderSVGResourceFilter&gt;(renderer.document(), id)) {
583                     ts &lt;&lt; indent &lt;&lt; &quot; &quot;;
584                     writeNameAndQuotedValue(ts, &quot;filter&quot;, id);
585                     ts &lt;&lt; &quot; &quot;;
586                     writeStandardPrefix(ts, *filter, behavior, WriteIndentOrNot::No);
587                     ts &lt;&lt; &quot; &quot; &lt;&lt; filter-&gt;resourceBoundingBox(renderer) &lt;&lt; &quot;\n&quot;;
588                 }
589             }
</pre>
</td>
<td>
<hr />
<pre>
185             writeSVGPaintingResource(ts, strokePaintingResource);
186 
187             SVGLengthContext lengthContext(&amp;shape.graphicsElement());
188             double dashOffset = lengthContext.valueForLength(svgStyle.strokeDashOffset());
189             double strokeWidth = lengthContext.valueForLength(style.strokeWidth());
190             const auto&amp; dashes = svgStyle.strokeDashArray();
191 
192             DashArray dashArray;
193             for (auto&amp; length : dashes)
194                 dashArray.append(length.value(lengthContext));
195 
196             writeIfNotDefault(ts, &quot;opacity&quot;, svgStyle.strokeOpacity(), 1.0f);
197             writeIfNotDefault(ts, &quot;stroke width&quot;, strokeWidth, 1.0);
198             writeIfNotDefault(ts, &quot;miter limit&quot;, style.strokeMiterLimit(), 4.0f);
199             writeIfNotDefault(ts, &quot;line cap&quot;, style.capStyle(), ButtCap);
200             writeIfNotDefault(ts, &quot;line join&quot;, style.joinStyle(), MiterJoin);
201             writeIfNotDefault(ts, &quot;dash offset&quot;, dashOffset, 0.0);
202             if (!dashArray.isEmpty())
203                 writeNameValuePair(ts, &quot;dash array&quot;, dashArray);
204 
<span class="line-added">205             if (is&lt;SVGGeometryElement&gt;(shape.graphicsElement())) {</span>
<span class="line-added">206                 double pathLength = downcast&lt;SVGGeometryElement&gt;(shape.graphicsElement()).pathLength();</span>
<span class="line-added">207                 writeIfNotDefault(ts, &quot;path length&quot;, pathLength, 0.0);</span>
<span class="line-added">208             }</span>
<span class="line-added">209 </span>
210             ts &lt;&lt; &quot;}]&quot;;
211         }
212 
213         if (RenderSVGResource* fillPaintingResource = RenderSVGResource::fillPaintingResource(const_cast&lt;RenderSVGShape&amp;&gt;(shape), shape.style(), fallbackColor)) {
214             TextStreamSeparator s(&quot; &quot;);
215             ts &lt;&lt; &quot; [fill={&quot; &lt;&lt; s;
216             writeSVGPaintingResource(ts, fillPaintingResource);
217 
218             writeIfNotDefault(ts, &quot;opacity&quot;, svgStyle.fillOpacity(), 1.0f);
219             writeIfNotDefault(ts, &quot;fill rule&quot;, svgStyle.fillRule(), WindRule::NonZero);
220             ts &lt;&lt; &quot;}]&quot;;
221         }
222         writeIfNotDefault(ts, &quot;clip rule&quot;, svgStyle.clipRule(), WindRule::NonZero);
223     }
224 
225     writeIfNotEmpty(ts, &quot;start marker&quot;, svgStyle.markerStartResource());
226     writeIfNotEmpty(ts, &quot;middle marker&quot;, svgStyle.markerMidResource());
227     writeIfNotEmpty(ts, &quot;end marker&quot;, svgStyle.markerEndResource());
228 }
229 
</pre>
<hr />
<pre>
551 
552     ts &lt;&lt; &quot; [offset=&quot; &lt;&lt; stop.element().offset() &lt;&lt; &quot;] [color=&quot; &lt;&lt; stop.element().stopColorIncludingOpacity() &lt;&lt; &quot;]\n&quot;;
553 }
554 
555 void writeResources(TextStream&amp; ts, const RenderObject&amp; renderer, OptionSet&lt;RenderAsTextFlag&gt; behavior)
556 {
557     const RenderStyle&amp; style = renderer.style();
558     const SVGRenderStyle&amp; svgStyle = style.svgStyle();
559 
560     // FIXME: We want to use SVGResourcesCache to determine which resources are present, instead of quering the resource &lt;-&gt; id cache.
561     // For now leave the DRT output as is, but later on we should change this so cycles are properly ignored in the DRT output.
562     if (!svgStyle.maskerResource().isEmpty()) {
563         if (RenderSVGResourceMasker* masker = getRenderSVGResourceById&lt;RenderSVGResourceMasker&gt;(renderer.document(), svgStyle.maskerResource())) {
564             ts &lt;&lt; indent &lt;&lt; &quot; &quot;;
565             writeNameAndQuotedValue(ts, &quot;masker&quot;, svgStyle.maskerResource());
566             ts &lt;&lt; &quot; &quot;;
567             writeStandardPrefix(ts, *masker, behavior, WriteIndentOrNot::No);
568             ts &lt;&lt; &quot; &quot; &lt;&lt; masker-&gt;resourceBoundingBox(renderer) &lt;&lt; &quot;\n&quot;;
569         }
570     }
<span class="line-modified">571     if (style.clipPath() &amp;&amp; is&lt;ReferenceClipPathOperation&gt;(style.clipPath())) {</span>
<span class="line-modified">572         auto resourceClipPath = downcast&lt;ReferenceClipPathOperation&gt;(style.clipPath());</span>
<span class="line-added">573         AtomString id = resourceClipPath-&gt;fragment();</span>
<span class="line-added">574         if (RenderSVGResourceClipper* clipper = getRenderSVGResourceById&lt;RenderSVGResourceClipper&gt;(renderer.document(), id)) {</span>
575             ts &lt;&lt; indent &lt;&lt; &quot; &quot;;
<span class="line-modified">576             writeNameAndQuotedValue(ts, &quot;clipPath&quot;, resourceClipPath-&gt;fragment());</span>
577             ts &lt;&lt; &quot; &quot;;
578             writeStandardPrefix(ts, *clipper, behavior, WriteIndentOrNot::No);
579             ts &lt;&lt; &quot; &quot; &lt;&lt; clipper-&gt;resourceBoundingBox(renderer) &lt;&lt; &quot;\n&quot;;
580         }
581     }
582     if (style.hasFilter()) {
583         const FilterOperations&amp; filterOperations = style.filter();
584         if (filterOperations.size() == 1) {
585             const FilterOperation&amp; filterOperation = *filterOperations.at(0);
586             if (filterOperation.type() == FilterOperation::REFERENCE) {
587                 const auto&amp; referenceFilterOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
588                 AtomString id = SVGURIReference::fragmentIdentifierFromIRIString(referenceFilterOperation.url(), renderer.document());
589                 if (RenderSVGResourceFilter* filter = getRenderSVGResourceById&lt;RenderSVGResourceFilter&gt;(renderer.document(), id)) {
590                     ts &lt;&lt; indent &lt;&lt; &quot; &quot;;
591                     writeNameAndQuotedValue(ts, &quot;filter&quot;, id);
592                     ts &lt;&lt; &quot; &quot;;
593                     writeStandardPrefix(ts, *filter, behavior, WriteIndentOrNot::No);
594                     ts &lt;&lt; &quot; &quot; &lt;&lt; filter-&gt;resourceBoundingBox(renderer) &lt;&lt; &quot;\n&quot;;
595                 }
596             }
</pre>
</td>
</tr>
</table>
<center><a href="SVGRenderSupport.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SVGRenderingContext.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorDebuggerAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorConsoleAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorDebuggerAgent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorDebuggerAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;InspectorDebuggerAgent.h&quot;
  32 
  33 #include &quot;AsyncStackTrace.h&quot;
  34 #include &quot;ContentSearchUtilities.h&quot;
  35 #include &quot;InjectedScript.h&quot;
  36 #include &quot;InjectedScriptManager.h&quot;
  37 #include &quot;InspectorFrontendRouter.h&quot;
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;RegularExpression.h&quot;
  40 #include &quot;ScriptCallStack.h&quot;
  41 #include &quot;ScriptCallStackFactory.h&quot;
  42 #include &quot;ScriptDebugServer.h&quot;
  43 #include &quot;ScriptObject.h&quot;

  44 #include &lt;wtf/JSONValues.h&gt;
  45 #include &lt;wtf/NeverDestroyed.h&gt;
  46 #include &lt;wtf/Stopwatch.h&gt;
  47 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  48 #include &lt;wtf/text/WTFString.h&gt;
  49 
  50 namespace Inspector {
  51 
  52 const char* InspectorDebuggerAgent::backtraceObjectGroup = &quot;backtrace&quot;;
  53 
  54 // Objects created and retained by evaluating breakpoint actions are put into object groups
  55 // according to the breakpoint action identifier assigned by the frontend. A breakpoint may
  56 // have several object groups, and objects from several backend breakpoint action instances may
  57 // create objects in the same group.
  58 static String objectGroupForBreakpointAction(const ScriptBreakpointAction&amp; action)
  59 {
  60     return makeString(&quot;breakpoint-action-&quot;, action.identifier);
  61 }
  62 





  63 InspectorDebuggerAgent::InspectorDebuggerAgent(AgentContext&amp; context)
  64     : InspectorAgentBase(&quot;Debugger&quot;_s)
  65     , m_frontendDispatcher(makeUnique&lt;DebuggerFrontendDispatcher&gt;(context.frontendRouter))
  66     , m_backendDispatcher(DebuggerBackendDispatcher::create(context.backendDispatcher, this))
  67     , m_scriptDebugServer(context.environment.scriptDebugServer())
  68     , m_injectedScriptManager(context.injectedScriptManager)
  69 {
<span class="line-modified">  70     // FIXME: make breakReason optional so that there was no need to init it with &quot;other&quot;.</span>
<span class="line-modified">  71     clearBreakDetails();</span>
  72 }
  73 
  74 InspectorDebuggerAgent::~InspectorDebuggerAgent() = default;
  75 
  76 void InspectorDebuggerAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
  77 {
  78 }
  79 
  80 void InspectorDebuggerAgent::willDestroyFrontendAndBackend(DisconnectReason reason)
  81 {
<span class="line-modified">  82     disable(reason == DisconnectReason::InspectedTargetDestroyed);</span>

  83 }
  84 
  85 void InspectorDebuggerAgent::enable()
  86 {
<span class="line-removed">  87     if (m_enabled)</span>
<span class="line-removed">  88         return;</span>
<span class="line-removed">  89 </span>
  90     m_enabled = true;
  91 
  92     m_scriptDebugServer.addListener(this);
  93 
  94     for (auto* listener : copyToVector(m_listeners))
  95         listener-&gt;debuggerWasEnabled();










  96 }
  97 
  98 void InspectorDebuggerAgent::disable(bool isBeingDestroyed)
  99 {
<span class="line-removed"> 100     if (!m_enabled)</span>
<span class="line-removed"> 101         return;</span>
<span class="line-removed"> 102 </span>
 103     for (auto* listener : copyToVector(m_listeners))
 104         listener-&gt;debuggerWasDisabled();
 105 
 106     m_scriptDebugServer.removeListener(this, isBeingDestroyed);
 107 
 108     clearInspectorBreakpointState();
 109 
 110     if (!isBeingDestroyed)
 111         m_scriptDebugServer.deactivateBreakpoints();
 112 
 113     ASSERT(m_javaScriptBreakpoints.isEmpty());
 114 
 115     clearAsyncStackTraceData();
 116 
 117     m_pauseOnAssertionFailures = false;
 118     m_pauseOnMicrotasks = false;
 119 
 120     m_enabled = false;
 121 }
 122 
<span class="line-modified"> 123 void InspectorDebuggerAgent::enable(ErrorString&amp;)</span>
 124 {





 125     enable();
 126 }
 127 
 128 void InspectorDebuggerAgent::disable(ErrorString&amp;)
 129 {
 130     disable(false);
 131 }
 132 
 133 bool InspectorDebuggerAgent::breakpointsActive() const
 134 {
 135     return m_scriptDebugServer.breakpointsActive();
 136 }
 137 
 138 void InspectorDebuggerAgent::setAsyncStackTraceDepth(ErrorString&amp; errorString, int depth)
 139 {
 140     if (m_asyncStackTraceDepth == depth)
 141         return;
 142 
 143     if (depth &lt; 0) {
 144         errorString = &quot;Unexpected negative depth&quot;_s;
</pre>
<hr />
<pre>
 152 }
 153 
 154 void InspectorDebuggerAgent::setBreakpointsActive(ErrorString&amp;, bool active)
 155 {
 156     if (active)
 157         m_scriptDebugServer.activateBreakpoints();
 158     else
 159         m_scriptDebugServer.deactivateBreakpoints();
 160 }
 161 
 162 bool InspectorDebuggerAgent::isPaused() const
 163 {
 164     return m_scriptDebugServer.isPaused();
 165 }
 166 
 167 void InspectorDebuggerAgent::setSuppressAllPauses(bool suppress)
 168 {
 169     m_scriptDebugServer.setSuppressAllPauses(suppress);
 170 }
 171 











 172 static RefPtr&lt;JSON::Object&gt; buildAssertPauseReason(const String&amp; message)
 173 {
 174     auto reason = Protocol::Debugger::AssertPauseReason::create().release();
 175     if (!message.isNull())
 176         reason-&gt;setMessage(message);
 177     return reason-&gt;openAccessors();
 178 }
 179 
 180 static RefPtr&lt;JSON::Object&gt; buildCSPViolationPauseReason(const String&amp; directiveText)
 181 {
 182     auto reason = Protocol::Debugger::CSPViolationPauseReason::create()
 183         .setDirective(directiveText)
 184         .release();
 185     return reason-&gt;openAccessors();
 186 }
 187 
 188 RefPtr&lt;JSON::Object&gt; InspectorDebuggerAgent::buildBreakpointPauseReason(JSC::BreakpointID debuggerBreakpointIdentifier)
 189 {
 190     ASSERT(debuggerBreakpointIdentifier != JSC::noBreakpointID);
 191     auto it = m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.find(debuggerBreakpointIdentifier);
</pre>
<hr />
<pre>
 208     if (injectedScript.hasNoValue())
 209         return nullptr;
 210 
 211     return injectedScript.wrapObject(exception, InspectorDebuggerAgent::backtraceObjectGroup)-&gt;openAccessors();
 212 }
 213 
 214 void InspectorDebuggerAgent::handleConsoleAssert(const String&amp; message)
 215 {
 216     if (!m_scriptDebugServer.breakpointsActive())
 217         return;
 218 
 219     if (m_pauseOnAssertionFailures)
 220         breakProgram(DebuggerFrontendDispatcher::Reason::Assert, buildAssertPauseReason(message));
 221 }
 222 
 223 InspectorDebuggerAgent::AsyncCallIdentifier InspectorDebuggerAgent::asyncCallIdentifier(AsyncCallType asyncCallType, int callbackId)
 224 {
 225     return std::make_pair(static_cast&lt;unsigned&gt;(asyncCallType), callbackId);
 226 }
 227 
<span class="line-modified"> 228 void InspectorDebuggerAgent::didScheduleAsyncCall(JSC::ExecState* exec, AsyncCallType asyncCallType, int callbackId, bool singleShot)</span>
 229 {
 230     if (!m_asyncStackTraceDepth)
 231         return;
 232 
 233     if (!m_scriptDebugServer.breakpointsActive())
 234         return;
 235 
<span class="line-modified"> 236     Ref&lt;ScriptCallStack&gt; callStack = createScriptCallStack(exec, m_asyncStackTraceDepth);</span>
 237     ASSERT(callStack-&gt;size());
 238     if (!callStack-&gt;size())
 239         return;
 240 
 241     RefPtr&lt;AsyncStackTrace&gt; parentStackTrace;
 242     if (m_currentAsyncCallIdentifier) {
 243         auto it = m_pendingAsyncCalls.find(m_currentAsyncCallIdentifier.value());
 244         ASSERT(it != m_pendingAsyncCalls.end());
 245         parentStackTrace = it-&gt;value;
 246     }
 247 
 248     auto identifier = asyncCallIdentifier(asyncCallType, callbackId);
 249     auto asyncStackTrace = AsyncStackTrace::create(WTFMove(callStack), singleShot, WTFMove(parentStackTrace));
 250 
 251     m_pendingAsyncCalls.set(identifier, WTFMove(asyncStackTrace));
 252 }
 253 
 254 void InspectorDebuggerAgent::didCancelAsyncCall(AsyncCallType asyncCallType, int callbackId)
 255 {
 256     if (!m_asyncStackTraceDepth)
</pre>
<hr />
<pre>
 681 {
 682     JSC::SourceID sourceID = scriptIDStr.toIntPtr();
 683     auto it = m_scripts.find(sourceID);
 684     if (it != m_scripts.end())
 685         *scriptSource = it-&gt;value.source;
 686     else
 687         errorString = &quot;Missing script for given scriptId&quot;;
 688 }
 689 
 690 void InspectorDebuggerAgent::getFunctionDetails(ErrorString&amp; errorString, const String&amp; functionId, RefPtr&lt;Protocol::Debugger::FunctionDetails&gt;&amp; details)
 691 {
 692     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(functionId);
 693     if (injectedScript.hasNoValue()) {
 694         errorString = &quot;Missing injected script for given functionId&quot;_s;
 695         return;
 696     }
 697 
 698     injectedScript.getFunctionDetails(errorString, functionId, details);
 699 }
 700 
<span class="line-modified"> 701 void InspectorDebuggerAgent::schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason breakReason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data)</span>
 702 {
 703     if (m_javaScriptPauseScheduled)
 704         return;
 705 
 706     m_javaScriptPauseScheduled = true;
 707 
<span class="line-modified"> 708     m_breakReason = breakReason;</span>
<span class="line-removed"> 709     m_breakData = WTFMove(data);</span>
 710 
 711     JSC::JSLockHolder locker(m_scriptDebugServer.vm());
 712     m_scriptDebugServer.setPauseOnNextStatement(true);
 713 }
 714 
 715 void InspectorDebuggerAgent::cancelPauseOnNextStatement()
 716 {
 717     if (!m_javaScriptPauseScheduled)
 718         return;
 719 
 720     m_javaScriptPauseScheduled = false;
 721 
<span class="line-modified"> 722     clearBreakDetails();</span>
 723     m_scriptDebugServer.setPauseOnNextStatement(false);
 724     m_enablePauseWhenIdle = false;
 725 }
 726 
 727 void InspectorDebuggerAgent::pause(ErrorString&amp;)
 728 {
 729     schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason::PauseOnNextStatement, nullptr);
 730 }
 731 
 732 void InspectorDebuggerAgent::resume(ErrorString&amp; errorString)
 733 {
<span class="line-modified"> 734     if (!m_pausedScriptState &amp;&amp; !m_javaScriptPauseScheduled) {</span>
 735         errorString = &quot;Must be paused or waiting to pause&quot;_s;
 736         return;
 737     }
 738 
 739     cancelPauseOnNextStatement();
 740     m_scriptDebugServer.continueProgram();
 741     m_conditionToDispatchResumed = ShouldDispatchResumed::WhenContinued;
 742 }
 743 
 744 void InspectorDebuggerAgent::stepOver(ErrorString&amp; errorString)
 745 {
 746     if (!assertPaused(errorString))
 747         return;
 748 
 749     willStepAndMayBecomeIdle();
 750     m_scriptDebugServer.stepOverStatement();
 751 }
 752 
 753 void InspectorDebuggerAgent::stepInto(ErrorString&amp; errorString)
 754 {
</pre>
<hr />
<pre>
 789 }
 790 
 791 void InspectorDebuggerAgent::didBecomeIdle()
 792 {
 793     m_registeredIdleCallback = false;
 794 
 795     if (m_conditionToDispatchResumed == ShouldDispatchResumed::WhenIdle) {
 796         cancelPauseOnNextStatement();
 797         m_scriptDebugServer.continueProgram();
 798         m_frontendDispatcher-&gt;resumed();
 799     }
 800 
 801     m_conditionToDispatchResumed = ShouldDispatchResumed::No;
 802 
 803     if (m_enablePauseWhenIdle) {
 804         ErrorString ignored;
 805         pause(ignored);
 806     }
 807 }
 808 





 809 void InspectorDebuggerAgent::setPauseOnExceptions(ErrorString&amp; errorString, const String&amp; stringPauseState)
 810 {
 811     JSC::Debugger::PauseOnExceptionsState pauseState;
 812     if (stringPauseState == &quot;none&quot;)
 813         pauseState = JSC::Debugger::DontPauseOnExceptions;
 814     else if (stringPauseState == &quot;all&quot;)
 815         pauseState = JSC::Debugger::PauseOnAllExceptions;
 816     else if (stringPauseState == &quot;uncaught&quot;)
 817         pauseState = JSC::Debugger::PauseOnUncaughtExceptions;
 818     else {
 819         errorString = makeString(&quot;Unknown state: &quot;_s, stringPauseState);
 820         return;
 821     }
 822 
 823     m_scriptDebugServer.setPauseOnExceptionsState(static_cast&lt;JSC::Debugger::PauseOnExceptionsState&gt;(pauseState));
 824     if (m_scriptDebugServer.pauseOnExceptionsState() != pauseState)
 825         errorString = &quot;Internal error. Could not change pause on exceptions state&quot;_s;
 826 }
 827 
 828 void InspectorDebuggerAgent::setPauseOnAssertions(ErrorString&amp;, bool enabled)
</pre>
<hr />
<pre>
 847     }
 848 
 849     auto pauseState = m_scriptDebugServer.pauseOnExceptionsState();
 850     bool pauseAndMute = doNotPauseOnExceptionsAndMuteConsole &amp;&amp; *doNotPauseOnExceptionsAndMuteConsole;
 851     if (pauseAndMute) {
 852         if (pauseState != JSC::Debugger::DontPauseOnExceptions)
 853             m_scriptDebugServer.setPauseOnExceptionsState(JSC::Debugger::DontPauseOnExceptions);
 854         muteConsole();
 855     }
 856 
 857     injectedScript.evaluateOnCallFrame(errorString, m_currentCallStack.get(), callFrameId, expression,
 858         objectGroup ? *objectGroup : emptyString(), includeCommandLineAPI &amp;&amp; *includeCommandLineAPI, returnByValue &amp;&amp; *returnByValue, generatePreview &amp;&amp; *generatePreview, saveResult &amp;&amp; *saveResult,
 859         result, wasThrown, savedResultIndex);
 860 
 861     if (pauseAndMute) {
 862         unmuteConsole();
 863         m_scriptDebugServer.setPauseOnExceptionsState(pauseState);
 864     }
 865 }
 866 













































 867 void InspectorDebuggerAgent::scriptExecutionBlockedByCSP(const String&amp; directiveText)
 868 {
 869     if (m_scriptDebugServer.pauseOnExceptionsState() != JSC::Debugger::DontPauseOnExceptions)
 870         breakProgram(DebuggerFrontendDispatcher::Reason::CSPViolation, buildCSPViolationPauseReason(directiveText));
 871 }
 872 
 873 Ref&lt;JSON::ArrayOf&lt;Protocol::Debugger::CallFrame&gt;&gt; InspectorDebuggerAgent::currentCallFrames(const InjectedScript&amp; injectedScript)
 874 {
 875     ASSERT(!injectedScript.hasNoValue());
 876     if (injectedScript.hasNoValue())
 877         return JSON::ArrayOf&lt;Protocol::Debugger::CallFrame&gt;::create();
 878 
 879     return injectedScript.wrapCallFrames(m_currentCallStack.get());
 880 }
 881 
 882 String InspectorDebuggerAgent::sourceMapURLForScript(const Script&amp; script)
 883 {
 884     return script.sourceMappingURL;
 885 }
 886 
 887 void InspectorDebuggerAgent::setPauseForInternalScripts(ErrorString&amp;, bool shouldPause)
 888 {
 889     if (shouldPause == m_pauseForInternalScripts)
 890         return;
 891 
 892     m_pauseForInternalScripts = shouldPause;
 893 
<span class="line-modified"> 894     if (m_pauseForInternalScripts)</span>
<span class="line-modified"> 895         m_scriptDebugServer.clearBlacklist();</span>
<span class="line-modified"> 896 }</span>
<span class="line-modified"> 897 </span>
<span class="line-modified"> 898 static bool isWebKitInjectedScript(const String&amp; sourceURL)</span>
<span class="line-modified"> 899 {</span>
<span class="line-removed"> 900     return sourceURL.startsWith(&quot;__InjectedScript_&quot;) &amp;&amp; sourceURL.endsWith(&quot;.js&quot;);</span>
 901 }
 902 
 903 void InspectorDebuggerAgent::didParseSource(JSC::SourceID sourceID, const Script&amp; script)
 904 {
 905     String scriptIDStr = String::number(sourceID);
 906     bool hasSourceURL = !script.sourceURL.isEmpty();
 907     String sourceURL = script.sourceURL;
 908     String sourceMappingURL = sourceMapURLForScript(script);
 909 
 910     const bool isModule = script.sourceProvider-&gt;sourceType() == JSC::SourceProviderSourceType::Module;
 911     const bool* isContentScript = script.isContentScript ? &amp;script.isContentScript : nullptr;
 912     String* sourceURLParam = hasSourceURL ? &amp;sourceURL : nullptr;
 913     String* sourceMapURLParam = sourceMappingURL.isEmpty() ? nullptr : &amp;sourceMappingURL;
 914 
 915     m_frontendDispatcher-&gt;scriptParsed(scriptIDStr, script.url, script.startLine, script.startColumn, script.endLine, script.endColumn, isContentScript, sourceURLParam, sourceMapURLParam, isModule ? &amp;isModule : nullptr);
 916 
 917     m_scripts.set(sourceID, script);
 918 
<span class="line-modified"> 919     if (hasSourceURL &amp;&amp; isWebKitInjectedScript(sourceURL) &amp;&amp; !m_pauseForInternalScripts)</span>
<span class="line-modified"> 920         m_scriptDebugServer.addToBlacklist(sourceID);</span>



 921 
 922     String scriptURLForBreakpoints = hasSourceURL ? script.sourceURL : script.url;
 923     if (scriptURLForBreakpoints.isEmpty())
 924         return;
 925 
 926     for (auto&amp; entry : m_javaScriptBreakpoints) {
 927         RefPtr&lt;JSON::Object&gt; breakpointObject = entry.value;
 928 
 929         bool isRegex;
 930         String url;
 931         breakpointObject-&gt;getBoolean(&quot;isRegex&quot;_s, isRegex);
 932         breakpointObject-&gt;getString(&quot;url&quot;_s, url);
 933         if (!matches(scriptURLForBreakpoints, url, isRegex))
 934             continue;
 935 
 936         ScriptBreakpoint scriptBreakpoint;
 937         breakpointObject-&gt;getInteger(&quot;lineNumber&quot;_s, scriptBreakpoint.lineNumber);
 938         breakpointObject-&gt;getInteger(&quot;columnNumber&quot;_s, scriptBreakpoint.columnNumber);
 939         breakpointObject-&gt;getString(&quot;condition&quot;_s, scriptBreakpoint.condition);
 940         breakpointObject-&gt;getBoolean(&quot;autoContinue&quot;_s, scriptBreakpoint.autoContinue);
</pre>
<hr />
<pre>
 970 }
 971 
 972 void InspectorDebuggerAgent::willRunMicrotask()
 973 {
 974     if (!m_scriptDebugServer.breakpointsActive())
 975         return;
 976 
 977     if (m_pauseOnMicrotasks)
 978         schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason::Microtask, nullptr);
 979 }
 980 
 981 void InspectorDebuggerAgent::didRunMicrotask()
 982 {
 983     if (!m_scriptDebugServer.breakpointsActive())
 984         return;
 985 
 986     if (m_pauseOnMicrotasks)
 987         cancelPauseOnNextStatement();
 988 }
 989 
<span class="line-modified"> 990 void InspectorDebuggerAgent::didPause(JSC::ExecState&amp; scriptState, JSC::JSValue callFrames, JSC::JSValue exceptionOrCaughtValue)</span>
 991 {
<span class="line-modified"> 992     ASSERT(!m_pausedScriptState);</span>
<span class="line-modified"> 993     m_pausedScriptState = &amp;scriptState;</span>
<span class="line-modified"> 994     m_currentCallStack = { scriptState.vm(), callFrames };</span>
 995 
<span class="line-modified"> 996     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;scriptState);</span>
 997 
 998     // If a high level pause pause reason is not already set, try to infer a reason from the debugger.
<span class="line-modified"> 999     if (m_breakReason == DebuggerFrontendDispatcher::Reason::Other) {</span>
1000         switch (m_scriptDebugServer.reasonForPause()) {
1001         case JSC::Debugger::PausedForBreakpoint: {
<span class="line-modified">1002             JSC::BreakpointID debuggerBreakpointId = m_scriptDebugServer.pausingBreakpointID();</span>
<span class="line-modified">1003             if (debuggerBreakpointId != m_continueToLocationBreakpointID) {</span>
<span class="line-modified">1004                 m_breakReason = DebuggerFrontendDispatcher::Reason::Breakpoint;</span>
<span class="line-removed">1005                 m_breakData = buildBreakpointPauseReason(debuggerBreakpointId);</span>
<span class="line-removed">1006             }</span>
1007             break;
1008         }
1009         case JSC::Debugger::PausedForDebuggerStatement:
<span class="line-modified">1010             m_breakReason = DebuggerFrontendDispatcher::Reason::DebuggerStatement;</span>
<span class="line-removed">1011             m_breakData = nullptr;</span>
1012             break;
1013         case JSC::Debugger::PausedForException:
<span class="line-modified">1014             m_breakReason = DebuggerFrontendDispatcher::Reason::Exception;</span>
<span class="line-modified">1015             m_breakData = buildExceptionPauseReason(exceptionOrCaughtValue, injectedScript);</span>








1016             break;

1017         case JSC::Debugger::PausedAtStatement:
1018         case JSC::Debugger::PausedAtExpression:
1019         case JSC::Debugger::PausedBeforeReturn:
1020         case JSC::Debugger::PausedAtEndOfProgram:
1021             // Pause was just stepping. Nothing to report.
1022             break;
1023         case JSC::Debugger::NotPaused:
1024             ASSERT_NOT_REACHED();
1025             break;
1026         }
1027     }
1028 


















1029     // Set $exception to the exception or caught value.
1030     if (exceptionOrCaughtValue &amp;&amp; !injectedScript.hasNoValue()) {
1031         injectedScript.setExceptionValue(exceptionOrCaughtValue);
1032         m_hasExceptionValue = true;
1033     }
1034 
1035     m_conditionToDispatchResumed = ShouldDispatchResumed::No;
1036     m_enablePauseWhenIdle = false;
1037 
1038     RefPtr&lt;Protocol::Console::StackTrace&gt; asyncStackTrace;
1039     if (m_currentAsyncCallIdentifier) {
1040         auto it = m_pendingAsyncCalls.find(m_currentAsyncCallIdentifier.value());
1041         if (it != m_pendingAsyncCalls.end())
1042             asyncStackTrace = it-&gt;value-&gt;buildInspectorObject();
1043     }
1044 
<span class="line-modified">1045     m_frontendDispatcher-&gt;paused(currentCallFrames(injectedScript), m_breakReason, m_breakData, asyncStackTrace);</span>
1046 
1047     m_javaScriptPauseScheduled = false;
1048 
1049     if (m_continueToLocationBreakpointID != JSC::noBreakpointID) {
1050         m_scriptDebugServer.removeBreakpoint(m_continueToLocationBreakpointID);
1051         m_continueToLocationBreakpointID = JSC::noBreakpointID;
1052     }
1053 
1054     RefPtr&lt;Stopwatch&gt; stopwatch = m_injectedScriptManager.inspectorEnvironment().executionStopwatch();
1055     if (stopwatch &amp;&amp; stopwatch-&gt;isActive()) {
1056         stopwatch-&gt;stop();
1057         m_didPauseStopwatch = true;
1058     }
1059 }
1060 
1061 void InspectorDebuggerAgent::breakpointActionSound(int breakpointActionIdentifier)
1062 {
1063     m_frontendDispatcher-&gt;playBreakpointActionSound(breakpointActionIdentifier);
1064 }
1065 
<span class="line-modified">1066 void InspectorDebuggerAgent::breakpointActionProbe(JSC::ExecState&amp; scriptState, const ScriptBreakpointAction&amp; action, unsigned batchId, unsigned sampleId, JSC::JSValue sample)</span>
1067 {
<span class="line-modified">1068     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;scriptState);</span>
1069     auto payload = injectedScript.wrapObject(sample, objectGroupForBreakpointAction(action), true);
1070     auto result = Protocol::Debugger::ProbeSample::create()
1071         .setProbeId(action.identifier)
1072         .setBatchId(batchId)
1073         .setSampleId(sampleId)
1074         .setTimestamp(m_injectedScriptManager.inspectorEnvironment().executionStopwatch()-&gt;elapsedTime().seconds())
1075         .setPayload(WTFMove(payload))
1076         .release();
1077     m_frontendDispatcher-&gt;didSampleProbe(WTFMove(result));
1078 }
1079 
1080 void InspectorDebuggerAgent::didContinue()
1081 {
1082     if (m_didPauseStopwatch) {
1083         m_didPauseStopwatch = false;
1084         m_injectedScriptManager.inspectorEnvironment().executionStopwatch()-&gt;start();
1085     }
1086 
<span class="line-modified">1087     m_pausedScriptState = nullptr;</span>
1088     m_currentCallStack = { };
1089     m_injectedScriptManager.releaseObjectGroup(InspectorDebuggerAgent::backtraceObjectGroup);
<span class="line-modified">1090     clearBreakDetails();</span>
1091     clearExceptionValue();
1092 
1093     if (m_conditionToDispatchResumed == ShouldDispatchResumed::WhenContinued)
1094         m_frontendDispatcher-&gt;resumed();
1095 }
1096 
<span class="line-modified">1097 void InspectorDebuggerAgent::breakProgram(DebuggerFrontendDispatcher::Reason breakReason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data)</span>
1098 {
<span class="line-modified">1099     m_breakReason = breakReason;</span>
<span class="line-modified">1100     m_breakData = WTFMove(data);</span>
1101     m_scriptDebugServer.breakProgram();
1102 }
1103 
1104 void InspectorDebuggerAgent::clearInspectorBreakpointState()
1105 {
1106     ErrorString ignored;
1107     for (const String&amp; identifier : copyToVector(m_breakpointIdentifierToDebugServerBreakpointIDs.keys()))
1108         removeBreakpoint(ignored, identifier);
1109 
1110     m_javaScriptBreakpoints.clear();
1111 
1112     clearDebuggerBreakpointState();
1113 }
1114 
1115 void InspectorDebuggerAgent::clearDebuggerBreakpointState()
1116 {
1117     {
1118         JSC::JSLockHolder holder(m_scriptDebugServer.vm());
1119         m_scriptDebugServer.clearBreakpointActions();
1120         m_scriptDebugServer.clearBreakpoints();
<span class="line-modified">1121         m_scriptDebugServer.clearBlacklist();</span>
1122     }
1123 
<span class="line-modified">1124     m_pausedScriptState = nullptr;</span>
1125     m_currentCallStack = { };
1126     m_scripts.clear();
1127     m_breakpointIdentifierToDebugServerBreakpointIDs.clear();
1128     m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.clear();
1129     m_continueToLocationBreakpointID = JSC::noBreakpointID;
<span class="line-modified">1130     clearBreakDetails();</span>
1131     m_javaScriptPauseScheduled = false;
1132     m_hasExceptionValue = false;
1133 
1134     if (isPaused()) {
1135         m_scriptDebugServer.continueProgram();
1136         m_frontendDispatcher-&gt;resumed();
1137     }
1138 }
1139 
1140 void InspectorDebuggerAgent::didClearGlobalObject()
1141 {
1142     // Clear breakpoints from the debugger, but keep the inspector&#39;s model of which
1143     // pages have what breakpoints, as the mapping is only sent to DebuggerAgent once.
1144     clearDebuggerBreakpointState();
1145 
1146     clearAsyncStackTraceData();
1147 
1148     m_frontendDispatcher-&gt;globalObjectCleared();
1149 }
1150 
1151 bool InspectorDebuggerAgent::assertPaused(ErrorString&amp; errorString)
1152 {
<span class="line-modified">1153     if (!m_pausedScriptState) {</span>
1154         errorString = &quot;Must be paused&quot;_s;
1155         return false;
1156     }
1157 
1158     return true;
1159 }
1160 
<span class="line-modified">1161 void InspectorDebuggerAgent::clearBreakDetails()</span>
1162 {
<span class="line-modified">1163     m_breakReason = DebuggerFrontendDispatcher::Reason::Other;</span>
<span class="line-removed">1164     m_breakData = nullptr;</span>
1165 }
1166 
1167 void InspectorDebuggerAgent::clearExceptionValue()
1168 {
1169     if (m_hasExceptionValue) {
1170         m_injectedScriptManager.clearExceptionValue();
1171         m_hasExceptionValue = false;
1172     }
1173 }
1174 
1175 void InspectorDebuggerAgent::clearAsyncStackTraceData()
1176 {
1177     m_pendingAsyncCalls.clear();
1178     m_currentAsyncCallIdentifier = WTF::nullopt;
1179 
1180     didClearAsyncStackTraceData();
1181 }
1182 
1183 } // namespace Inspector
</pre>
</td>
<td>
<hr />
<pre>
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;InspectorDebuggerAgent.h&quot;
  32 
  33 #include &quot;AsyncStackTrace.h&quot;
  34 #include &quot;ContentSearchUtilities.h&quot;
  35 #include &quot;InjectedScript.h&quot;
  36 #include &quot;InjectedScriptManager.h&quot;
  37 #include &quot;InspectorFrontendRouter.h&quot;
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;RegularExpression.h&quot;
  40 #include &quot;ScriptCallStack.h&quot;
  41 #include &quot;ScriptCallStackFactory.h&quot;
  42 #include &quot;ScriptDebugServer.h&quot;
  43 #include &quot;ScriptObject.h&quot;
<span class="line-added">  44 #include &lt;wtf/Function.h&gt;</span>
  45 #include &lt;wtf/JSONValues.h&gt;
  46 #include &lt;wtf/NeverDestroyed.h&gt;
  47 #include &lt;wtf/Stopwatch.h&gt;
  48 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  49 #include &lt;wtf/text/WTFString.h&gt;
  50 
  51 namespace Inspector {
  52 
  53 const char* InspectorDebuggerAgent::backtraceObjectGroup = &quot;backtrace&quot;;
  54 
  55 // Objects created and retained by evaluating breakpoint actions are put into object groups
  56 // according to the breakpoint action identifier assigned by the frontend. A breakpoint may
  57 // have several object groups, and objects from several backend breakpoint action instances may
  58 // create objects in the same group.
  59 static String objectGroupForBreakpointAction(const ScriptBreakpointAction&amp; action)
  60 {
  61     return makeString(&quot;breakpoint-action-&quot;, action.identifier);
  62 }
  63 
<span class="line-added">  64 static bool isWebKitInjectedScript(const String&amp; sourceURL)</span>
<span class="line-added">  65 {</span>
<span class="line-added">  66     return sourceURL.startsWith(&quot;__InjectedScript_&quot;) &amp;&amp; sourceURL.endsWith(&quot;.js&quot;);</span>
<span class="line-added">  67 }</span>
<span class="line-added">  68 </span>
  69 InspectorDebuggerAgent::InspectorDebuggerAgent(AgentContext&amp; context)
  70     : InspectorAgentBase(&quot;Debugger&quot;_s)
  71     , m_frontendDispatcher(makeUnique&lt;DebuggerFrontendDispatcher&gt;(context.frontendRouter))
  72     , m_backendDispatcher(DebuggerBackendDispatcher::create(context.backendDispatcher, this))
  73     , m_scriptDebugServer(context.environment.scriptDebugServer())
  74     , m_injectedScriptManager(context.injectedScriptManager)
  75 {
<span class="line-modified">  76     // FIXME: make pauseReason optional so that there was no need to init it with &quot;other&quot;.</span>
<span class="line-modified">  77     clearPauseDetails();</span>
  78 }
  79 
  80 InspectorDebuggerAgent::~InspectorDebuggerAgent() = default;
  81 
  82 void InspectorDebuggerAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
  83 {
  84 }
  85 
  86 void InspectorDebuggerAgent::willDestroyFrontendAndBackend(DisconnectReason reason)
  87 {
<span class="line-modified">  88     if (enabled())</span>
<span class="line-added">  89         disable(reason == DisconnectReason::InspectedTargetDestroyed);</span>
  90 }
  91 
  92 void InspectorDebuggerAgent::enable()
  93 {



  94     m_enabled = true;
  95 
  96     m_scriptDebugServer.addListener(this);
  97 
  98     for (auto* listener : copyToVector(m_listeners))
  99         listener-&gt;debuggerWasEnabled();
<span class="line-added"> 100 </span>
<span class="line-added"> 101     for (auto&amp; [sourceID, script] : m_scripts) {</span>
<span class="line-added"> 102         Optional&lt;JSC::Debugger::BlackboxType&gt; blackboxType;</span>
<span class="line-added"> 103         if (isWebKitInjectedScript(script.sourceURL)) {</span>
<span class="line-added"> 104             if (!m_pauseForInternalScripts)</span>
<span class="line-added"> 105                 blackboxType = JSC::Debugger::BlackboxType::Ignored;</span>
<span class="line-added"> 106         } else if (shouldBlackboxURL(script.sourceURL) || shouldBlackboxURL(script.url))</span>
<span class="line-added"> 107             blackboxType = JSC::Debugger::BlackboxType::Deferred;</span>
<span class="line-added"> 108         m_scriptDebugServer.setBlackboxType(sourceID, blackboxType);</span>
<span class="line-added"> 109     }</span>
 110 }
 111 
 112 void InspectorDebuggerAgent::disable(bool isBeingDestroyed)
 113 {



 114     for (auto* listener : copyToVector(m_listeners))
 115         listener-&gt;debuggerWasDisabled();
 116 
 117     m_scriptDebugServer.removeListener(this, isBeingDestroyed);
 118 
 119     clearInspectorBreakpointState();
 120 
 121     if (!isBeingDestroyed)
 122         m_scriptDebugServer.deactivateBreakpoints();
 123 
 124     ASSERT(m_javaScriptBreakpoints.isEmpty());
 125 
 126     clearAsyncStackTraceData();
 127 
 128     m_pauseOnAssertionFailures = false;
 129     m_pauseOnMicrotasks = false;
 130 
 131     m_enabled = false;
 132 }
 133 
<span class="line-modified"> 134 void InspectorDebuggerAgent::enable(ErrorString&amp; errorString)</span>
 135 {
<span class="line-added"> 136     if (enabled()) {</span>
<span class="line-added"> 137         errorString = &quot;Debugger domain already enabled&quot;_s;</span>
<span class="line-added"> 138         return;</span>
<span class="line-added"> 139     }</span>
<span class="line-added"> 140 </span>
 141     enable();
 142 }
 143 
 144 void InspectorDebuggerAgent::disable(ErrorString&amp;)
 145 {
 146     disable(false);
 147 }
 148 
 149 bool InspectorDebuggerAgent::breakpointsActive() const
 150 {
 151     return m_scriptDebugServer.breakpointsActive();
 152 }
 153 
 154 void InspectorDebuggerAgent::setAsyncStackTraceDepth(ErrorString&amp; errorString, int depth)
 155 {
 156     if (m_asyncStackTraceDepth == depth)
 157         return;
 158 
 159     if (depth &lt; 0) {
 160         errorString = &quot;Unexpected negative depth&quot;_s;
</pre>
<hr />
<pre>
 168 }
 169 
 170 void InspectorDebuggerAgent::setBreakpointsActive(ErrorString&amp;, bool active)
 171 {
 172     if (active)
 173         m_scriptDebugServer.activateBreakpoints();
 174     else
 175         m_scriptDebugServer.deactivateBreakpoints();
 176 }
 177 
 178 bool InspectorDebuggerAgent::isPaused() const
 179 {
 180     return m_scriptDebugServer.isPaused();
 181 }
 182 
 183 void InspectorDebuggerAgent::setSuppressAllPauses(bool suppress)
 184 {
 185     m_scriptDebugServer.setSuppressAllPauses(suppress);
 186 }
 187 
<span class="line-added"> 188 void InspectorDebuggerAgent::updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason reason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data)</span>
<span class="line-added"> 189 {</span>
<span class="line-added"> 190     if (m_pauseReason != DebuggerFrontendDispatcher::Reason::BlackboxedScript) {</span>
<span class="line-added"> 191         m_preBlackboxPauseReason = m_pauseReason;</span>
<span class="line-added"> 192         m_preBlackboxPauseData = WTFMove(m_pauseData);</span>
<span class="line-added"> 193     }</span>
<span class="line-added"> 194 </span>
<span class="line-added"> 195     m_pauseReason = reason;</span>
<span class="line-added"> 196     m_pauseData = WTFMove(data);</span>
<span class="line-added"> 197 }</span>
<span class="line-added"> 198 </span>
 199 static RefPtr&lt;JSON::Object&gt; buildAssertPauseReason(const String&amp; message)
 200 {
 201     auto reason = Protocol::Debugger::AssertPauseReason::create().release();
 202     if (!message.isNull())
 203         reason-&gt;setMessage(message);
 204     return reason-&gt;openAccessors();
 205 }
 206 
 207 static RefPtr&lt;JSON::Object&gt; buildCSPViolationPauseReason(const String&amp; directiveText)
 208 {
 209     auto reason = Protocol::Debugger::CSPViolationPauseReason::create()
 210         .setDirective(directiveText)
 211         .release();
 212     return reason-&gt;openAccessors();
 213 }
 214 
 215 RefPtr&lt;JSON::Object&gt; InspectorDebuggerAgent::buildBreakpointPauseReason(JSC::BreakpointID debuggerBreakpointIdentifier)
 216 {
 217     ASSERT(debuggerBreakpointIdentifier != JSC::noBreakpointID);
 218     auto it = m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.find(debuggerBreakpointIdentifier);
</pre>
<hr />
<pre>
 235     if (injectedScript.hasNoValue())
 236         return nullptr;
 237 
 238     return injectedScript.wrapObject(exception, InspectorDebuggerAgent::backtraceObjectGroup)-&gt;openAccessors();
 239 }
 240 
 241 void InspectorDebuggerAgent::handleConsoleAssert(const String&amp; message)
 242 {
 243     if (!m_scriptDebugServer.breakpointsActive())
 244         return;
 245 
 246     if (m_pauseOnAssertionFailures)
 247         breakProgram(DebuggerFrontendDispatcher::Reason::Assert, buildAssertPauseReason(message));
 248 }
 249 
 250 InspectorDebuggerAgent::AsyncCallIdentifier InspectorDebuggerAgent::asyncCallIdentifier(AsyncCallType asyncCallType, int callbackId)
 251 {
 252     return std::make_pair(static_cast&lt;unsigned&gt;(asyncCallType), callbackId);
 253 }
 254 
<span class="line-modified"> 255 void InspectorDebuggerAgent::didScheduleAsyncCall(JSC::JSGlobalObject* globalObject, AsyncCallType asyncCallType, int callbackId, bool singleShot)</span>
 256 {
 257     if (!m_asyncStackTraceDepth)
 258         return;
 259 
 260     if (!m_scriptDebugServer.breakpointsActive())
 261         return;
 262 
<span class="line-modified"> 263     Ref&lt;ScriptCallStack&gt; callStack = createScriptCallStack(globalObject, m_asyncStackTraceDepth);</span>
 264     ASSERT(callStack-&gt;size());
 265     if (!callStack-&gt;size())
 266         return;
 267 
 268     RefPtr&lt;AsyncStackTrace&gt; parentStackTrace;
 269     if (m_currentAsyncCallIdentifier) {
 270         auto it = m_pendingAsyncCalls.find(m_currentAsyncCallIdentifier.value());
 271         ASSERT(it != m_pendingAsyncCalls.end());
 272         parentStackTrace = it-&gt;value;
 273     }
 274 
 275     auto identifier = asyncCallIdentifier(asyncCallType, callbackId);
 276     auto asyncStackTrace = AsyncStackTrace::create(WTFMove(callStack), singleShot, WTFMove(parentStackTrace));
 277 
 278     m_pendingAsyncCalls.set(identifier, WTFMove(asyncStackTrace));
 279 }
 280 
 281 void InspectorDebuggerAgent::didCancelAsyncCall(AsyncCallType asyncCallType, int callbackId)
 282 {
 283     if (!m_asyncStackTraceDepth)
</pre>
<hr />
<pre>
 708 {
 709     JSC::SourceID sourceID = scriptIDStr.toIntPtr();
 710     auto it = m_scripts.find(sourceID);
 711     if (it != m_scripts.end())
 712         *scriptSource = it-&gt;value.source;
 713     else
 714         errorString = &quot;Missing script for given scriptId&quot;;
 715 }
 716 
 717 void InspectorDebuggerAgent::getFunctionDetails(ErrorString&amp; errorString, const String&amp; functionId, RefPtr&lt;Protocol::Debugger::FunctionDetails&gt;&amp; details)
 718 {
 719     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(functionId);
 720     if (injectedScript.hasNoValue()) {
 721         errorString = &quot;Missing injected script for given functionId&quot;_s;
 722         return;
 723     }
 724 
 725     injectedScript.getFunctionDetails(errorString, functionId, details);
 726 }
 727 
<span class="line-modified"> 728 void InspectorDebuggerAgent::schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason reason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data)</span>
 729 {
 730     if (m_javaScriptPauseScheduled)
 731         return;
 732 
 733     m_javaScriptPauseScheduled = true;
 734 
<span class="line-modified"> 735     updatePauseReasonAndData(reason, WTFMove(data));</span>

 736 
 737     JSC::JSLockHolder locker(m_scriptDebugServer.vm());
 738     m_scriptDebugServer.setPauseOnNextStatement(true);
 739 }
 740 
 741 void InspectorDebuggerAgent::cancelPauseOnNextStatement()
 742 {
 743     if (!m_javaScriptPauseScheduled)
 744         return;
 745 
 746     m_javaScriptPauseScheduled = false;
 747 
<span class="line-modified"> 748     clearPauseDetails();</span>
 749     m_scriptDebugServer.setPauseOnNextStatement(false);
 750     m_enablePauseWhenIdle = false;
 751 }
 752 
 753 void InspectorDebuggerAgent::pause(ErrorString&amp;)
 754 {
 755     schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason::PauseOnNextStatement, nullptr);
 756 }
 757 
 758 void InspectorDebuggerAgent::resume(ErrorString&amp; errorString)
 759 {
<span class="line-modified"> 760     if (!m_pausedGlobalObject &amp;&amp; !m_javaScriptPauseScheduled) {</span>
 761         errorString = &quot;Must be paused or waiting to pause&quot;_s;
 762         return;
 763     }
 764 
 765     cancelPauseOnNextStatement();
 766     m_scriptDebugServer.continueProgram();
 767     m_conditionToDispatchResumed = ShouldDispatchResumed::WhenContinued;
 768 }
 769 
 770 void InspectorDebuggerAgent::stepOver(ErrorString&amp; errorString)
 771 {
 772     if (!assertPaused(errorString))
 773         return;
 774 
 775     willStepAndMayBecomeIdle();
 776     m_scriptDebugServer.stepOverStatement();
 777 }
 778 
 779 void InspectorDebuggerAgent::stepInto(ErrorString&amp; errorString)
 780 {
</pre>
<hr />
<pre>
 815 }
 816 
 817 void InspectorDebuggerAgent::didBecomeIdle()
 818 {
 819     m_registeredIdleCallback = false;
 820 
 821     if (m_conditionToDispatchResumed == ShouldDispatchResumed::WhenIdle) {
 822         cancelPauseOnNextStatement();
 823         m_scriptDebugServer.continueProgram();
 824         m_frontendDispatcher-&gt;resumed();
 825     }
 826 
 827     m_conditionToDispatchResumed = ShouldDispatchResumed::No;
 828 
 829     if (m_enablePauseWhenIdle) {
 830         ErrorString ignored;
 831         pause(ignored);
 832     }
 833 }
 834 
<span class="line-added"> 835 void InspectorDebuggerAgent::setPauseOnDebuggerStatements(ErrorString&amp;, bool enabled)</span>
<span class="line-added"> 836 {</span>
<span class="line-added"> 837     m_scriptDebugServer.setPauseOnDebuggerStatements(enabled);</span>
<span class="line-added"> 838 }</span>
<span class="line-added"> 839 </span>
 840 void InspectorDebuggerAgent::setPauseOnExceptions(ErrorString&amp; errorString, const String&amp; stringPauseState)
 841 {
 842     JSC::Debugger::PauseOnExceptionsState pauseState;
 843     if (stringPauseState == &quot;none&quot;)
 844         pauseState = JSC::Debugger::DontPauseOnExceptions;
 845     else if (stringPauseState == &quot;all&quot;)
 846         pauseState = JSC::Debugger::PauseOnAllExceptions;
 847     else if (stringPauseState == &quot;uncaught&quot;)
 848         pauseState = JSC::Debugger::PauseOnUncaughtExceptions;
 849     else {
 850         errorString = makeString(&quot;Unknown state: &quot;_s, stringPauseState);
 851         return;
 852     }
 853 
 854     m_scriptDebugServer.setPauseOnExceptionsState(static_cast&lt;JSC::Debugger::PauseOnExceptionsState&gt;(pauseState));
 855     if (m_scriptDebugServer.pauseOnExceptionsState() != pauseState)
 856         errorString = &quot;Internal error. Could not change pause on exceptions state&quot;_s;
 857 }
 858 
 859 void InspectorDebuggerAgent::setPauseOnAssertions(ErrorString&amp;, bool enabled)
</pre>
<hr />
<pre>
 878     }
 879 
 880     auto pauseState = m_scriptDebugServer.pauseOnExceptionsState();
 881     bool pauseAndMute = doNotPauseOnExceptionsAndMuteConsole &amp;&amp; *doNotPauseOnExceptionsAndMuteConsole;
 882     if (pauseAndMute) {
 883         if (pauseState != JSC::Debugger::DontPauseOnExceptions)
 884             m_scriptDebugServer.setPauseOnExceptionsState(JSC::Debugger::DontPauseOnExceptions);
 885         muteConsole();
 886     }
 887 
 888     injectedScript.evaluateOnCallFrame(errorString, m_currentCallStack.get(), callFrameId, expression,
 889         objectGroup ? *objectGroup : emptyString(), includeCommandLineAPI &amp;&amp; *includeCommandLineAPI, returnByValue &amp;&amp; *returnByValue, generatePreview &amp;&amp; *generatePreview, saveResult &amp;&amp; *saveResult,
 890         result, wasThrown, savedResultIndex);
 891 
 892     if (pauseAndMute) {
 893         unmuteConsole();
 894         m_scriptDebugServer.setPauseOnExceptionsState(pauseState);
 895     }
 896 }
 897 
<span class="line-added"> 898 void InspectorDebuggerAgent::setShouldBlackboxURL(ErrorString&amp; errorString, const String&amp; url, bool shouldBlackbox, const bool* optionalCaseSensitive, const bool* optionalIsRegex)</span>
<span class="line-added"> 899 {</span>
<span class="line-added"> 900     if (url.isEmpty()) {</span>
<span class="line-added"> 901         errorString = &quot;URL must not be empty&quot;_s;</span>
<span class="line-added"> 902         return;</span>
<span class="line-added"> 903     }</span>
<span class="line-added"> 904 </span>
<span class="line-added"> 905     bool caseSensitive = optionalCaseSensitive &amp;&amp; *optionalCaseSensitive;</span>
<span class="line-added"> 906     bool isRegex = optionalIsRegex &amp;&amp; *optionalIsRegex;</span>
<span class="line-added"> 907 </span>
<span class="line-added"> 908     if (!caseSensitive &amp;&amp; !isRegex &amp;&amp; isWebKitInjectedScript(url)) {</span>
<span class="line-added"> 909         errorString = &quot;Blackboxing of internal scripts is controlled by &#39;Debugger.setPauseForInternalScripts&#39;&quot;_s;</span>
<span class="line-added"> 910         return;</span>
<span class="line-added"> 911     }</span>
<span class="line-added"> 912 </span>
<span class="line-added"> 913     BlackboxConfig config { url, caseSensitive, isRegex };</span>
<span class="line-added"> 914     if (shouldBlackbox)</span>
<span class="line-added"> 915         m_blackboxedURLs.appendIfNotContains(config);</span>
<span class="line-added"> 916     else</span>
<span class="line-added"> 917         m_blackboxedURLs.removeAll(config);</span>
<span class="line-added"> 918 </span>
<span class="line-added"> 919     for (auto&amp; [sourceID, script] : m_scripts) {</span>
<span class="line-added"> 920         if (isWebKitInjectedScript(script.sourceURL))</span>
<span class="line-added"> 921             continue;</span>
<span class="line-added"> 922 </span>
<span class="line-added"> 923         Optional&lt;JSC::Debugger::BlackboxType&gt; blackboxType;</span>
<span class="line-added"> 924         if (shouldBlackboxURL(script.sourceURL) || shouldBlackboxURL(script.url))</span>
<span class="line-added"> 925             blackboxType = JSC::Debugger::BlackboxType::Deferred;</span>
<span class="line-added"> 926         m_scriptDebugServer.setBlackboxType(sourceID, blackboxType);</span>
<span class="line-added"> 927     }</span>
<span class="line-added"> 928 }</span>
<span class="line-added"> 929 </span>
<span class="line-added"> 930 bool InspectorDebuggerAgent::shouldBlackboxURL(const String&amp; url) const</span>
<span class="line-added"> 931 {</span>
<span class="line-added"> 932     if (!url.isEmpty()) {</span>
<span class="line-added"> 933         for (const auto&amp; blackboxConfig : m_blackboxedURLs) {</span>
<span class="line-added"> 934             auto searchStringType = blackboxConfig.isRegex ? ContentSearchUtilities::SearchStringType::Regex : ContentSearchUtilities::SearchStringType::ExactString;</span>
<span class="line-added"> 935             auto regex = ContentSearchUtilities::createRegularExpressionForSearchString(blackboxConfig.url, blackboxConfig.caseSensitive, searchStringType);</span>
<span class="line-added"> 936             if (regex.match(url) != -1)</span>
<span class="line-added"> 937                 return true;</span>
<span class="line-added"> 938         }</span>
<span class="line-added"> 939     }</span>
<span class="line-added"> 940     return false;</span>
<span class="line-added"> 941 }</span>
<span class="line-added"> 942 </span>
 943 void InspectorDebuggerAgent::scriptExecutionBlockedByCSP(const String&amp; directiveText)
 944 {
 945     if (m_scriptDebugServer.pauseOnExceptionsState() != JSC::Debugger::DontPauseOnExceptions)
 946         breakProgram(DebuggerFrontendDispatcher::Reason::CSPViolation, buildCSPViolationPauseReason(directiveText));
 947 }
 948 
 949 Ref&lt;JSON::ArrayOf&lt;Protocol::Debugger::CallFrame&gt;&gt; InspectorDebuggerAgent::currentCallFrames(const InjectedScript&amp; injectedScript)
 950 {
 951     ASSERT(!injectedScript.hasNoValue());
 952     if (injectedScript.hasNoValue())
 953         return JSON::ArrayOf&lt;Protocol::Debugger::CallFrame&gt;::create();
 954 
 955     return injectedScript.wrapCallFrames(m_currentCallStack.get());
 956 }
 957 
 958 String InspectorDebuggerAgent::sourceMapURLForScript(const Script&amp; script)
 959 {
 960     return script.sourceMappingURL;
 961 }
 962 
 963 void InspectorDebuggerAgent::setPauseForInternalScripts(ErrorString&amp;, bool shouldPause)
 964 {
 965     if (shouldPause == m_pauseForInternalScripts)
 966         return;
 967 
 968     m_pauseForInternalScripts = shouldPause;
 969 
<span class="line-modified"> 970     auto blackboxType = !m_pauseForInternalScripts ? Optional&lt;JSC::Debugger::BlackboxType&gt;(JSC::Debugger::BlackboxType::Ignored) : WTF::nullopt;</span>
<span class="line-modified"> 971     for (auto&amp; [sourceID, script] : m_scripts) {</span>
<span class="line-modified"> 972         if (!isWebKitInjectedScript(script.sourceURL))</span>
<span class="line-modified"> 973             continue;</span>
<span class="line-modified"> 974         m_scriptDebugServer.setBlackboxType(sourceID, blackboxType);</span>
<span class="line-modified"> 975     }</span>

 976 }
 977 
 978 void InspectorDebuggerAgent::didParseSource(JSC::SourceID sourceID, const Script&amp; script)
 979 {
 980     String scriptIDStr = String::number(sourceID);
 981     bool hasSourceURL = !script.sourceURL.isEmpty();
 982     String sourceURL = script.sourceURL;
 983     String sourceMappingURL = sourceMapURLForScript(script);
 984 
 985     const bool isModule = script.sourceProvider-&gt;sourceType() == JSC::SourceProviderSourceType::Module;
 986     const bool* isContentScript = script.isContentScript ? &amp;script.isContentScript : nullptr;
 987     String* sourceURLParam = hasSourceURL ? &amp;sourceURL : nullptr;
 988     String* sourceMapURLParam = sourceMappingURL.isEmpty() ? nullptr : &amp;sourceMappingURL;
 989 
 990     m_frontendDispatcher-&gt;scriptParsed(scriptIDStr, script.url, script.startLine, script.startColumn, script.endLine, script.endColumn, isContentScript, sourceURLParam, sourceMapURLParam, isModule ? &amp;isModule : nullptr);
 991 
 992     m_scripts.set(sourceID, script);
 993 
<span class="line-modified"> 994     if (isWebKitInjectedScript(sourceURL)) {</span>
<span class="line-modified"> 995         if (!m_pauseForInternalScripts)</span>
<span class="line-added"> 996             m_scriptDebugServer.setBlackboxType(sourceID, JSC::Debugger::BlackboxType::Ignored);</span>
<span class="line-added"> 997     } else if (shouldBlackboxURL(sourceURL) || shouldBlackboxURL(script.url))</span>
<span class="line-added"> 998         m_scriptDebugServer.setBlackboxType(sourceID, JSC::Debugger::BlackboxType::Deferred);</span>
 999 
1000     String scriptURLForBreakpoints = hasSourceURL ? script.sourceURL : script.url;
1001     if (scriptURLForBreakpoints.isEmpty())
1002         return;
1003 
1004     for (auto&amp; entry : m_javaScriptBreakpoints) {
1005         RefPtr&lt;JSON::Object&gt; breakpointObject = entry.value;
1006 
1007         bool isRegex;
1008         String url;
1009         breakpointObject-&gt;getBoolean(&quot;isRegex&quot;_s, isRegex);
1010         breakpointObject-&gt;getString(&quot;url&quot;_s, url);
1011         if (!matches(scriptURLForBreakpoints, url, isRegex))
1012             continue;
1013 
1014         ScriptBreakpoint scriptBreakpoint;
1015         breakpointObject-&gt;getInteger(&quot;lineNumber&quot;_s, scriptBreakpoint.lineNumber);
1016         breakpointObject-&gt;getInteger(&quot;columnNumber&quot;_s, scriptBreakpoint.columnNumber);
1017         breakpointObject-&gt;getString(&quot;condition&quot;_s, scriptBreakpoint.condition);
1018         breakpointObject-&gt;getBoolean(&quot;autoContinue&quot;_s, scriptBreakpoint.autoContinue);
</pre>
<hr />
<pre>
1048 }
1049 
1050 void InspectorDebuggerAgent::willRunMicrotask()
1051 {
1052     if (!m_scriptDebugServer.breakpointsActive())
1053         return;
1054 
1055     if (m_pauseOnMicrotasks)
1056         schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason::Microtask, nullptr);
1057 }
1058 
1059 void InspectorDebuggerAgent::didRunMicrotask()
1060 {
1061     if (!m_scriptDebugServer.breakpointsActive())
1062         return;
1063 
1064     if (m_pauseOnMicrotasks)
1065         cancelPauseOnNextStatement();
1066 }
1067 
<span class="line-modified">1068 void InspectorDebuggerAgent::didPause(JSC::JSGlobalObject* globalObject, JSC::JSValue callFrames, JSC::JSValue exceptionOrCaughtValue)</span>
1069 {
<span class="line-modified">1070     ASSERT(!m_pausedGlobalObject);</span>
<span class="line-modified">1071     m_pausedGlobalObject = globalObject;</span>
<span class="line-modified">1072     m_currentCallStack = { globalObject-&gt;vm(), callFrames };</span>
1073 
<span class="line-modified">1074     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(globalObject);</span>
1075 
1076     // If a high level pause pause reason is not already set, try to infer a reason from the debugger.
<span class="line-modified">1077     if (m_pauseReason == DebuggerFrontendDispatcher::Reason::Other) {</span>
1078         switch (m_scriptDebugServer.reasonForPause()) {
1079         case JSC::Debugger::PausedForBreakpoint: {
<span class="line-modified">1080             auto debuggerBreakpointId = m_scriptDebugServer.pausingBreakpointID();</span>
<span class="line-modified">1081             if (debuggerBreakpointId != m_continueToLocationBreakpointID)</span>
<span class="line-modified">1082                 updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason::Breakpoint, buildBreakpointPauseReason(debuggerBreakpointId));</span>


1083             break;
1084         }
1085         case JSC::Debugger::PausedForDebuggerStatement:
<span class="line-modified">1086             updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason::DebuggerStatement, nullptr);</span>

1087             break;
1088         case JSC::Debugger::PausedForException:
<span class="line-modified">1089             updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason::Exception, buildExceptionPauseReason(exceptionOrCaughtValue, injectedScript));</span>
<span class="line-modified">1090             break;</span>
<span class="line-added">1091         case JSC::Debugger::PausedAfterBlackboxedScript: {</span>
<span class="line-added">1092             // There should be no break data, as we would&#39;ve already continued past the breakpoint.</span>
<span class="line-added">1093             ASSERT(!m_pauseData);</span>
<span class="line-added">1094 </span>
<span class="line-added">1095             // Don&#39;t call `updatePauseReasonAndData` so as to not override `m_preBlackboxPauseData`.</span>
<span class="line-added">1096             if (m_pauseReason != DebuggerFrontendDispatcher::Reason::BlackboxedScript)</span>
<span class="line-added">1097                 m_preBlackboxPauseReason = m_pauseReason;</span>
<span class="line-added">1098             m_pauseReason = DebuggerFrontendDispatcher::Reason::BlackboxedScript;</span>
1099             break;
<span class="line-added">1100         }</span>
1101         case JSC::Debugger::PausedAtStatement:
1102         case JSC::Debugger::PausedAtExpression:
1103         case JSC::Debugger::PausedBeforeReturn:
1104         case JSC::Debugger::PausedAtEndOfProgram:
1105             // Pause was just stepping. Nothing to report.
1106             break;
1107         case JSC::Debugger::NotPaused:
1108             ASSERT_NOT_REACHED();
1109             break;
1110         }
1111     }
1112 
<span class="line-added">1113     if (m_scriptDebugServer.reasonForPause() == JSC::Debugger::PausedAfterBlackboxedScript) {</span>
<span class="line-added">1114         // Ensure that `m_preBlackboxPauseReason` is populated with the most recent data.</span>
<span class="line-added">1115         updatePauseReasonAndData(m_pauseReason, nullptr);</span>
<span class="line-added">1116 </span>
<span class="line-added">1117         RefPtr&lt;JSON::Object&gt; data;</span>
<span class="line-added">1118         if (auto debuggerBreakpointId = m_scriptDebugServer.pausingBreakpointID()) {</span>
<span class="line-added">1119             ASSERT(debuggerBreakpointId != m_continueToLocationBreakpointID);</span>
<span class="line-added">1120             data = JSON::Object::create();</span>
<span class="line-added">1121             data-&gt;setString(&quot;originalReason&quot;_s, Protocol::InspectorHelpers::getEnumConstantValue(DebuggerFrontendDispatcher::Reason::Breakpoint));</span>
<span class="line-added">1122             data-&gt;setValue(&quot;originalData&quot;_s, buildBreakpointPauseReason(debuggerBreakpointId));</span>
<span class="line-added">1123         } else if (m_preBlackboxPauseData) {</span>
<span class="line-added">1124             data = JSON::Object::create();</span>
<span class="line-added">1125             data-&gt;setString(&quot;originalReason&quot;_s, Protocol::InspectorHelpers::getEnumConstantValue(m_preBlackboxPauseReason));</span>
<span class="line-added">1126             data-&gt;setValue(&quot;originalData&quot;_s, m_preBlackboxPauseData);</span>
<span class="line-added">1127         }</span>
<span class="line-added">1128         updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason::BlackboxedScript, WTFMove(data));</span>
<span class="line-added">1129     }</span>
<span class="line-added">1130 </span>
1131     // Set $exception to the exception or caught value.
1132     if (exceptionOrCaughtValue &amp;&amp; !injectedScript.hasNoValue()) {
1133         injectedScript.setExceptionValue(exceptionOrCaughtValue);
1134         m_hasExceptionValue = true;
1135     }
1136 
1137     m_conditionToDispatchResumed = ShouldDispatchResumed::No;
1138     m_enablePauseWhenIdle = false;
1139 
1140     RefPtr&lt;Protocol::Console::StackTrace&gt; asyncStackTrace;
1141     if (m_currentAsyncCallIdentifier) {
1142         auto it = m_pendingAsyncCalls.find(m_currentAsyncCallIdentifier.value());
1143         if (it != m_pendingAsyncCalls.end())
1144             asyncStackTrace = it-&gt;value-&gt;buildInspectorObject();
1145     }
1146 
<span class="line-modified">1147     m_frontendDispatcher-&gt;paused(currentCallFrames(injectedScript), m_pauseReason, m_pauseData, asyncStackTrace);</span>
1148 
1149     m_javaScriptPauseScheduled = false;
1150 
1151     if (m_continueToLocationBreakpointID != JSC::noBreakpointID) {
1152         m_scriptDebugServer.removeBreakpoint(m_continueToLocationBreakpointID);
1153         m_continueToLocationBreakpointID = JSC::noBreakpointID;
1154     }
1155 
1156     RefPtr&lt;Stopwatch&gt; stopwatch = m_injectedScriptManager.inspectorEnvironment().executionStopwatch();
1157     if (stopwatch &amp;&amp; stopwatch-&gt;isActive()) {
1158         stopwatch-&gt;stop();
1159         m_didPauseStopwatch = true;
1160     }
1161 }
1162 
1163 void InspectorDebuggerAgent::breakpointActionSound(int breakpointActionIdentifier)
1164 {
1165     m_frontendDispatcher-&gt;playBreakpointActionSound(breakpointActionIdentifier);
1166 }
1167 
<span class="line-modified">1168 void InspectorDebuggerAgent::breakpointActionProbe(JSC::JSGlobalObject* globalObject, const ScriptBreakpointAction&amp; action, unsigned batchId, unsigned sampleId, JSC::JSValue sample)</span>
1169 {
<span class="line-modified">1170     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(globalObject);</span>
1171     auto payload = injectedScript.wrapObject(sample, objectGroupForBreakpointAction(action), true);
1172     auto result = Protocol::Debugger::ProbeSample::create()
1173         .setProbeId(action.identifier)
1174         .setBatchId(batchId)
1175         .setSampleId(sampleId)
1176         .setTimestamp(m_injectedScriptManager.inspectorEnvironment().executionStopwatch()-&gt;elapsedTime().seconds())
1177         .setPayload(WTFMove(payload))
1178         .release();
1179     m_frontendDispatcher-&gt;didSampleProbe(WTFMove(result));
1180 }
1181 
1182 void InspectorDebuggerAgent::didContinue()
1183 {
1184     if (m_didPauseStopwatch) {
1185         m_didPauseStopwatch = false;
1186         m_injectedScriptManager.inspectorEnvironment().executionStopwatch()-&gt;start();
1187     }
1188 
<span class="line-modified">1189     m_pausedGlobalObject = nullptr;</span>
1190     m_currentCallStack = { };
1191     m_injectedScriptManager.releaseObjectGroup(InspectorDebuggerAgent::backtraceObjectGroup);
<span class="line-modified">1192     clearPauseDetails();</span>
1193     clearExceptionValue();
1194 
1195     if (m_conditionToDispatchResumed == ShouldDispatchResumed::WhenContinued)
1196         m_frontendDispatcher-&gt;resumed();
1197 }
1198 
<span class="line-modified">1199 void InspectorDebuggerAgent::breakProgram(DebuggerFrontendDispatcher::Reason reason, RefPtr&lt;JSON::Object&gt;&amp;&amp; data)</span>
1200 {
<span class="line-modified">1201     updatePauseReasonAndData(reason, WTFMove(data));</span>
<span class="line-modified">1202 </span>
1203     m_scriptDebugServer.breakProgram();
1204 }
1205 
1206 void InspectorDebuggerAgent::clearInspectorBreakpointState()
1207 {
1208     ErrorString ignored;
1209     for (const String&amp; identifier : copyToVector(m_breakpointIdentifierToDebugServerBreakpointIDs.keys()))
1210         removeBreakpoint(ignored, identifier);
1211 
1212     m_javaScriptBreakpoints.clear();
1213 
1214     clearDebuggerBreakpointState();
1215 }
1216 
1217 void InspectorDebuggerAgent::clearDebuggerBreakpointState()
1218 {
1219     {
1220         JSC::JSLockHolder holder(m_scriptDebugServer.vm());
1221         m_scriptDebugServer.clearBreakpointActions();
1222         m_scriptDebugServer.clearBreakpoints();
<span class="line-modified">1223         m_scriptDebugServer.clearBlackbox();</span>
1224     }
1225 
<span class="line-modified">1226     m_pausedGlobalObject = nullptr;</span>
1227     m_currentCallStack = { };
1228     m_scripts.clear();
1229     m_breakpointIdentifierToDebugServerBreakpointIDs.clear();
1230     m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.clear();
1231     m_continueToLocationBreakpointID = JSC::noBreakpointID;
<span class="line-modified">1232     clearPauseDetails();</span>
1233     m_javaScriptPauseScheduled = false;
1234     m_hasExceptionValue = false;
1235 
1236     if (isPaused()) {
1237         m_scriptDebugServer.continueProgram();
1238         m_frontendDispatcher-&gt;resumed();
1239     }
1240 }
1241 
1242 void InspectorDebuggerAgent::didClearGlobalObject()
1243 {
1244     // Clear breakpoints from the debugger, but keep the inspector&#39;s model of which
1245     // pages have what breakpoints, as the mapping is only sent to DebuggerAgent once.
1246     clearDebuggerBreakpointState();
1247 
1248     clearAsyncStackTraceData();
1249 
1250     m_frontendDispatcher-&gt;globalObjectCleared();
1251 }
1252 
1253 bool InspectorDebuggerAgent::assertPaused(ErrorString&amp; errorString)
1254 {
<span class="line-modified">1255     if (!m_pausedGlobalObject) {</span>
1256         errorString = &quot;Must be paused&quot;_s;
1257         return false;
1258     }
1259 
1260     return true;
1261 }
1262 
<span class="line-modified">1263 void InspectorDebuggerAgent::clearPauseDetails()</span>
1264 {
<span class="line-modified">1265     updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason::Other, nullptr);</span>

1266 }
1267 
1268 void InspectorDebuggerAgent::clearExceptionValue()
1269 {
1270     if (m_hasExceptionValue) {
1271         m_injectedScriptManager.clearExceptionValue();
1272         m_hasExceptionValue = false;
1273     }
1274 }
1275 
1276 void InspectorDebuggerAgent::clearAsyncStackTraceData()
1277 {
1278     m_pendingAsyncCalls.clear();
1279     m_currentAsyncCallIdentifier = WTF::nullopt;
1280 
1281     didClearAsyncStackTraceData();
1282 }
1283 
1284 } // namespace Inspector
</pre>
</td>
</tr>
</table>
<center><a href="InspectorConsoleAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorDebuggerAgent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTreeAsText.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderThemeWin.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderVTTCue.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTreeAsText.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeAsText.h&quot;
 28 
 29 #include &quot;ClipRect.h&quot;
 30 #include &quot;Document.h&quot;
 31 #include &quot;Frame.h&quot;
 32 #include &quot;FrameSelection.h&quot;
 33 #include &quot;FrameView.h&quot;
 34 #include &quot;HTMLElement.h&quot;
 35 #include &quot;HTMLNames.h&quot;
 36 #include &quot;HTMLSpanElement.h&quot;
 37 #include &quot;InlineTextBox.h&quot;
<span class="line-modified"> 38 #include &quot;LineLayoutInterfaceTextBoxes.h&quot;</span>
 39 #include &quot;Logging.h&quot;
 40 #include &quot;PrintContext.h&quot;
 41 #include &quot;PseudoElement.h&quot;
 42 #include &quot;RenderBlockFlow.h&quot;
 43 #include &quot;RenderCounter.h&quot;
 44 #include &quot;RenderDetailsMarker.h&quot;
 45 #include &quot;RenderFileUploadControl.h&quot;
 46 #include &quot;RenderFragmentContainer.h&quot;
 47 #include &quot;RenderInline.h&quot;
 48 #include &quot;RenderIterator.h&quot;
 49 #include &quot;RenderLayer.h&quot;
 50 #include &quot;RenderLayerBacking.h&quot;
 51 #include &quot;RenderLineBreak.h&quot;
 52 #include &quot;RenderListItem.h&quot;
 53 #include &quot;RenderListMarker.h&quot;
 54 #include &quot;RenderSVGContainer.h&quot;
 55 #include &quot;RenderSVGGradientStop.h&quot;
 56 #include &quot;RenderSVGImage.h&quot;
 57 #include &quot;RenderSVGInlineText.h&quot;
 58 #include &quot;RenderSVGPath.h&quot;
</pre>
<hr />
<pre>
143     return (!inlineStyleDecl || inlineStyleDecl-&gt;isEmpty());
144 }
145 
146 String quoteAndEscapeNonPrintables(StringView s)
147 {
148     StringBuilder result;
149     result.append(&#39;&quot;&#39;);
150     for (unsigned i = 0; i != s.length(); ++i) {
151         UChar c = s[i];
152         if (c == &#39;\\&#39;) {
153             result.appendLiteral(&quot;\\\\&quot;);
154         } else if (c == &#39;&quot;&#39;) {
155             result.appendLiteral(&quot;\\\&quot;&quot;);
156         } else if (c == &#39;\n&#39; || c == noBreakSpace)
157             result.append(&#39; &#39;);
158         else {
159             if (c &gt;= 0x20 &amp;&amp; c &lt; 0x7F)
160                 result.append(c);
161             else {
162                 result.appendLiteral(&quot;\\x{&quot;);
<span class="line-modified">163                 appendUnsignedAsHex(c, result);</span>
164                 result.append(&#39;}&#39;);
165             }
166         }
167     }
168     result.append(&#39;&quot;&#39;);
169     return result.toString();
170 }
171 
172 void RenderTreeAsText::writeRenderObject(TextStream&amp; ts, const RenderObject&amp; o, OptionSet&lt;RenderAsTextFlag&gt; behavior)
173 {
174     ts &lt;&lt; o.renderName();
175 
176     if (behavior.contains(RenderAsTextFlag::ShowAddresses))
177         ts &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;const void*&gt;(&amp;o);
178 
<span class="line-modified">179     if (o.style().zIndex())</span>
<span class="line-modified">180         ts &lt;&lt; &quot; zI: &quot; &lt;&lt; o.style().zIndex();</span>
181 
182     if (o.node()) {
183         String tagName = getTagName(o.node());
184         // FIXME: Temporary hack to make tests pass by simulating the old generated content output.
185         if (o.isPseudoElement() || (o.parent() &amp;&amp; o.parent()-&gt;isPseudoElement()))
186             tagName = emptyAtom();
187         if (!tagName.isEmpty()) {
188             ts &lt;&lt; &quot; {&quot; &lt;&lt; tagName &lt;&lt; &quot;}&quot;;
189             // flag empty or unstyled AppleStyleSpan because we never
190             // want to leave them in the DOM
191             if (isEmptyOrUnstyledAppleStyleSpan(o.node()))
192                 ts &lt;&lt; &quot; *empty or unstyled AppleStyleSpan*&quot;;
193         }
194     }
195 
196     RenderBlock* cb = o.containingBlock();
197     bool adjustForTableCells = cb ? cb-&gt;isTableCell() : false;
198 
199     LayoutRect r;
200     if (is&lt;RenderText&gt;(o)) {
201         // FIXME: Would be better to dump the bounding box x and y rather than the first run&#39;s x and y, but that would involve updating
202         // many test results.
203         const RenderText&amp; text = downcast&lt;RenderText&gt;(o);
204         r = IntRect(text.firstRunLocation(), text.linesBoundingBox().size());
<span class="line-modified">205         auto textBoxes = LineLayoutInterface::textBoxes(text);</span>
<span class="line-removed">206         if (textBoxes.begin() == textBoxes.end())</span>
207             adjustForTableCells = false;
208     } else if (o.isBR()) {
209         const RenderLineBreak&amp; br = downcast&lt;RenderLineBreak&gt;(o);
<span class="line-modified">210         IntRect linesBox = br.linesBoundingBox();</span>
211         r = IntRect(linesBox.x(), linesBox.y(), linesBox.width(), linesBox.height());
212         if (!br.inlineBoxWrapper())
213             adjustForTableCells = false;
214     } else if (is&lt;RenderInline&gt;(o)) {
215         const RenderInline&amp; inlineFlow = downcast&lt;RenderInline&gt;(o);
216         // FIXME: Would be better not to just dump 0, 0 as the x and y here.
217         r = IntRect(0, 0, inlineFlow.linesBoundingBox().width(), inlineFlow.linesBoundingBox().height());
218         adjustForTableCells = false;
219     } else if (is&lt;RenderTableCell&gt;(o)) {
220         // FIXME: Deliberately dump the &quot;inner&quot; box of table cells, since that is what current results reflect.  We&#39;d like
221         // to clean up the results to dump both the outer box and the intrinsic padding so that both bits of information are
222         // captured by the results.
223         const RenderTableCell&amp; cell = downcast&lt;RenderTableCell&gt;(o);
224         r = LayoutRect(cell.x(), cell.y() + cell.intrinsicPaddingBefore(), cell.width(), cell.height() - cell.intrinsicPaddingBefore() - cell.intrinsicPaddingAfter());
225     } else if (is&lt;RenderBox&gt;(o))
226         r = downcast&lt;RenderBox&gt;(o).frameRect();
227 
228     // FIXME: Temporary in order to ensure compatibility with existing layout test results.
229     if (adjustForTableCells)
230         r.move(0_lu, -downcast&lt;RenderTableCell&gt;(*o.containingBlock()).intrinsicPaddingBefore());
231 
232     // FIXME: Convert layout test results to report sub-pixel values, in the meantime using enclosingIntRect
233     // for consistency with old results.
234     ts &lt;&lt; &quot; &quot; &lt;&lt; enclosingIntRect(r);
235 
236     if (!is&lt;RenderText&gt;(o)) {
237         if (is&lt;RenderFileUploadControl&gt;(o))
238             ts &lt;&lt; &quot; &quot; &lt;&lt; quoteAndEscapeNonPrintables(downcast&lt;RenderFileUploadControl&gt;(o).fileTextValue());
239 
240         if (o.parent()) {
241             Color color = o.style().visitedDependentColor(CSSPropertyColor);
242             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyColor).rgb() != color.rgb())
243                 ts &lt;&lt; &quot; [color=&quot; &lt;&lt; color.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
244 
245             // Do not dump invalid or transparent backgrounds, since that is the default.
246             Color backgroundColor = o.style().visitedDependentColor(CSSPropertyBackgroundColor);
247             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyBackgroundColor).rgb() != backgroundColor.rgb()
<span class="line-modified">248                 &amp;&amp; backgroundColor.isValid() &amp;&amp; backgroundColor.rgb())</span>
249                 ts &lt;&lt; &quot; [bgcolor=&quot; &lt;&lt; backgroundColor.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
250 
251             Color textFillColor = o.style().visitedDependentColor(CSSPropertyWebkitTextFillColor);
252             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyWebkitTextFillColor).rgb() != textFillColor.rgb()
<span class="line-modified">253                 &amp;&amp; textFillColor.isValid() &amp;&amp; textFillColor.rgb() != color.rgb() &amp;&amp; textFillColor.rgb())</span>
254                 ts &lt;&lt; &quot; [textFillColor=&quot; &lt;&lt; textFillColor.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
255 
256             Color textStrokeColor = o.style().visitedDependentColor(CSSPropertyWebkitTextStrokeColor);
257             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyWebkitTextStrokeColor).rgb() != textStrokeColor.rgb()
<span class="line-modified">258                 &amp;&amp; textStrokeColor.isValid() &amp;&amp; textStrokeColor.rgb() != color.rgb() &amp;&amp; textStrokeColor.rgb())</span>
259                 ts &lt;&lt; &quot; [textStrokeColor=&quot; &lt;&lt; textStrokeColor.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
260 
261             if (o.parent()-&gt;style().textStrokeWidth() != o.style().textStrokeWidth() &amp;&amp; o.style().textStrokeWidth() &gt; 0)
262                 ts &lt;&lt; &quot; [textStrokeWidth=&quot; &lt;&lt; o.style().textStrokeWidth() &lt;&lt; &quot;]&quot;;
263         }
264 
265         if (!is&lt;RenderBoxModelObject&gt;(o) || is&lt;RenderLineBreak&gt;(o))
266             return;
267 
268         const RenderBoxModelObject&amp; box = downcast&lt;RenderBoxModelObject&gt;(o);
269         LayoutUnit borderTop = box.borderTop();
270         LayoutUnit borderRight = box.borderRight();
271         LayoutUnit borderBottom = box.borderBottom();
272         LayoutUnit borderLeft = box.borderLeft();
273         if (box.isFieldset()) {
274             const auto&amp; block = downcast&lt;RenderBlock&gt;(box);
275             if (o.style().writingMode() == TopToBottomWritingMode)
276                 borderTop -= block.intrinsicBorderForFieldset();
277             else if (o.style().writingMode() == BottomToTopWritingMode)
278                 borderBottom -= block.intrinsicBorderForFieldset();
</pre>
<hr />
<pre>
461         }
462 
463         if (needsLayout)
464             ts &lt;&lt; &quot;)&quot;;
465     }
466 
467     if (behavior.contains(RenderAsTextFlag::ShowOverflow) &amp;&amp; is&lt;RenderBox&gt;(object)) {
468         const auto&amp; box = downcast&lt;RenderBox&gt;(object);
469         if (box.hasRenderOverflow()) {
470             LayoutRect layoutOverflow = box.layoutOverflowRect();
471             ts &lt;&lt; &quot; (layout overflow &quot; &lt;&lt; layoutOverflow.x().toInt() &lt;&lt; &quot;,&quot; &lt;&lt; layoutOverflow.y().toInt() &lt;&lt; &quot; &quot; &lt;&lt; layoutOverflow.width().toInt() &lt;&lt; &quot;x&quot; &lt;&lt; layoutOverflow.height().toInt() &lt;&lt; &quot;)&quot;;
472 
473             if (box.hasVisualOverflow()) {
474                 LayoutRect visualOverflow = box.visualOverflowRect();
475                 ts &lt;&lt; &quot; (visual overflow &quot; &lt;&lt; visualOverflow.x().toInt() &lt;&lt; &quot;,&quot; &lt;&lt; visualOverflow.y().toInt() &lt;&lt; &quot; &quot; &lt;&lt; visualOverflow.width().toInt() &lt;&lt; &quot;x&quot; &lt;&lt; visualOverflow.height().toInt() &lt;&lt; &quot;)&quot;;
476             }
477         }
478     }
479 }
480 
<span class="line-modified">481 static void writeTextBox(TextStream&amp; ts, const RenderText&amp; o, const LineLayoutInterface::TextBox&amp; textBox)</span>
482 {
483     auto rect = textBox.rect();
<span class="line-removed">484     auto logicalRect = textBox.logicalRect();</span>
<span class="line-removed">485 </span>
486     int x = rect.x();
487     int y = rect.y();
<span class="line-modified">488 </span>
<span class="line-modified">489     // FIXME: Mixing logical and physical here doesn&#39;t make sense.</span>
<span class="line-removed">490     int logicalWidth = ceilf(rect.x() + logicalRect.width()) - x;</span>
<span class="line-removed">491 </span>
492     // FIXME: Table cell adjustment is temporary until results can be updated.
493     if (is&lt;RenderTableCell&gt;(*o.containingBlock()))
494         y -= floorToInt(downcast&lt;RenderTableCell&gt;(*o.containingBlock()).intrinsicPaddingBefore());
495 
496     ts &lt;&lt; &quot;text run at (&quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;) width &quot; &lt;&lt; logicalWidth;
497     if (!textBox.isLeftToRightDirection() || textBox.dirOverride()) {
498         ts &lt;&lt; (!textBox.isLeftToRightDirection() ? &quot; RTL&quot; : &quot; LTR&quot;);
499         if (textBox.dirOverride())
500             ts &lt;&lt; &quot; override&quot;;
501     }
502     ts &lt;&lt; &quot;: &quot;
503         &lt;&lt; quoteAndEscapeNonPrintables(textBox.text());
504     if (textBox.hasHyphen())
505         ts &lt;&lt; &quot; + hyphen string &quot; &lt;&lt; quoteAndEscapeNonPrintables(o.style().hyphenString().string());
506     ts &lt;&lt; &quot;\n&quot;;
507 }
508 
509 void write(TextStream&amp; ts, const RenderObject&amp; o, OptionSet&lt;RenderAsTextFlag&gt; behavior)
510 {
511     if (is&lt;RenderSVGShape&gt;(o)) {
</pre>
<hr />
<pre>
533         return;
534     }
535     if (is&lt;RenderSVGInlineText&gt;(o)) {
536         writeSVGInlineText(ts, downcast&lt;RenderSVGInlineText&gt;(o), behavior);
537         return;
538     }
539     if (is&lt;RenderSVGImage&gt;(o)) {
540         writeSVGImage(ts, downcast&lt;RenderSVGImage&gt;(o), behavior);
541         return;
542     }
543 
544     ts &lt;&lt; indent;
545 
546     RenderTreeAsText::writeRenderObject(ts, o, behavior);
547     ts &lt;&lt; &quot;\n&quot;;
548 
549     TextStream::IndentScope indentScope(ts);
550 
551     if (is&lt;RenderText&gt;(o)) {
552         auto&amp; text = downcast&lt;RenderText&gt;(o);
<span class="line-modified">553         for (auto textBox : LineLayoutInterface::textBoxes(text)) {</span>
554             ts &lt;&lt; indent;
555             writeTextBox(ts, text, textBox);
556         }
557     } else {
558         for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(downcast&lt;RenderElement&gt;(o))) {
559             if (child.hasLayer())
560                 continue;
561             write(ts, child, behavior);
562         }
563     }
564 
565     if (is&lt;RenderWidget&gt;(o)) {
566         Widget* widget = downcast&lt;RenderWidget&gt;(o).widget();
567         if (is&lt;FrameView&gt;(widget)) {
568             FrameView&amp; view = downcast&lt;FrameView&gt;(*widget);
569             if (RenderView* root = view.frame().contentRenderer()) {
570                 if (!(behavior.contains(RenderAsTextFlag::DontUpdateLayout)))
571                     view.layoutContext().layout();
572                 if (RenderLayer* layer = root-&gt;layer())
573                     writeLayers(ts, *layer, *layer, layer-&gt;rect(), behavior);
</pre>
<hr />
<pre>
622 #endif
623     }
624 
625     if (paintPhase == LayerPaintPhaseBackground)
626         ts &lt;&lt; &quot; layerType: background only&quot;;
627     else if (paintPhase == LayerPaintPhaseForeground)
628         ts &lt;&lt; &quot; layerType: foreground only&quot;;
629 
630     if (behavior.contains(RenderAsTextFlag::ShowCompositedLayers)) {
631         if (layer.isComposited()) {
632             ts &lt;&lt; &quot; (composited, bounds=&quot; &lt;&lt; layer.backing()-&gt;compositedBounds() &lt;&lt; &quot;, drawsContent=&quot; &lt;&lt; layer.backing()-&gt;graphicsLayer()-&gt;drawsContent()
633                 &lt;&lt; &quot;, paints into ancestor=&quot; &lt;&lt; layer.backing()-&gt;paintsIntoCompositedAncestor() &lt;&lt; &quot;)&quot;;
634         } else if (layer.paintsIntoProvidedBacking())
635             ts &lt;&lt; &quot; (shared backing of &quot; &lt;&lt; layer.backingProviderLayer() &lt;&lt; &quot;)&quot;;
636     }
637 
638 #if ENABLE(CSS_COMPOSITING)
639     if (layer.isolatesBlending())
640         ts &lt;&lt; &quot; isolatesBlending&quot;;
641     if (layer.hasBlendMode())
<span class="line-modified">642         ts &lt;&lt; &quot; blendMode: &quot; &lt;&lt; compositeOperatorName(CompositeSourceOver, layer.blendMode());</span>
643 #endif
644 
645     ts &lt;&lt; &quot;\n&quot;;
646 }
647 
648 static void writeLayerRenderers(TextStream&amp; ts, const RenderLayer&amp; layer, LayerPaintPhase paintPhase, OptionSet&lt;RenderAsTextFlag&gt; behavior)
649 {
650     if (paintPhase != LayerPaintPhaseBackground) {
651         TextStream::IndentScope indentScope(ts);
652         write(ts, layer.renderer(), behavior);
653     }
654 }
655 
656 static LayoutSize maxLayoutOverflow(const RenderBox* box)
657 {
658     LayoutRect overflowRect = box-&gt;layoutOverflowRect();
659     return LayoutSize(overflowRect.maxX(), overflowRect.maxY());
660 }
661 
662 static void writeLayers(TextStream&amp; ts, const RenderLayer&amp; rootLayer, RenderLayer&amp; layer, const LayoutRect&amp; paintRect, OptionSet&lt;RenderAsTextFlag&gt; behavior)
</pre>
</td>
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeAsText.h&quot;
 28 
 29 #include &quot;ClipRect.h&quot;
 30 #include &quot;Document.h&quot;
 31 #include &quot;Frame.h&quot;
 32 #include &quot;FrameSelection.h&quot;
 33 #include &quot;FrameView.h&quot;
 34 #include &quot;HTMLElement.h&quot;
 35 #include &quot;HTMLNames.h&quot;
 36 #include &quot;HTMLSpanElement.h&quot;
 37 #include &quot;InlineTextBox.h&quot;
<span class="line-modified"> 38 #include &quot;LineLayoutTraversal.h&quot;</span>
 39 #include &quot;Logging.h&quot;
 40 #include &quot;PrintContext.h&quot;
 41 #include &quot;PseudoElement.h&quot;
 42 #include &quot;RenderBlockFlow.h&quot;
 43 #include &quot;RenderCounter.h&quot;
 44 #include &quot;RenderDetailsMarker.h&quot;
 45 #include &quot;RenderFileUploadControl.h&quot;
 46 #include &quot;RenderFragmentContainer.h&quot;
 47 #include &quot;RenderInline.h&quot;
 48 #include &quot;RenderIterator.h&quot;
 49 #include &quot;RenderLayer.h&quot;
 50 #include &quot;RenderLayerBacking.h&quot;
 51 #include &quot;RenderLineBreak.h&quot;
 52 #include &quot;RenderListItem.h&quot;
 53 #include &quot;RenderListMarker.h&quot;
 54 #include &quot;RenderSVGContainer.h&quot;
 55 #include &quot;RenderSVGGradientStop.h&quot;
 56 #include &quot;RenderSVGImage.h&quot;
 57 #include &quot;RenderSVGInlineText.h&quot;
 58 #include &quot;RenderSVGPath.h&quot;
</pre>
<hr />
<pre>
143     return (!inlineStyleDecl || inlineStyleDecl-&gt;isEmpty());
144 }
145 
146 String quoteAndEscapeNonPrintables(StringView s)
147 {
148     StringBuilder result;
149     result.append(&#39;&quot;&#39;);
150     for (unsigned i = 0; i != s.length(); ++i) {
151         UChar c = s[i];
152         if (c == &#39;\\&#39;) {
153             result.appendLiteral(&quot;\\\\&quot;);
154         } else if (c == &#39;&quot;&#39;) {
155             result.appendLiteral(&quot;\\\&quot;&quot;);
156         } else if (c == &#39;\n&#39; || c == noBreakSpace)
157             result.append(&#39; &#39;);
158         else {
159             if (c &gt;= 0x20 &amp;&amp; c &lt; 0x7F)
160                 result.append(c);
161             else {
162                 result.appendLiteral(&quot;\\x{&quot;);
<span class="line-modified">163                 result.append(hex(c));</span>
164                 result.append(&#39;}&#39;);
165             }
166         }
167     }
168     result.append(&#39;&quot;&#39;);
169     return result.toString();
170 }
171 
172 void RenderTreeAsText::writeRenderObject(TextStream&amp; ts, const RenderObject&amp; o, OptionSet&lt;RenderAsTextFlag&gt; behavior)
173 {
174     ts &lt;&lt; o.renderName();
175 
176     if (behavior.contains(RenderAsTextFlag::ShowAddresses))
177         ts &lt;&lt; &quot; &quot; &lt;&lt; static_cast&lt;const void*&gt;(&amp;o);
178 
<span class="line-modified">179     if (o.style().usedZIndex()) // FIXME: This should use !hasAutoUsedZIndex().</span>
<span class="line-modified">180         ts &lt;&lt; &quot; zI: &quot; &lt;&lt; o.style().usedZIndex();</span>
181 
182     if (o.node()) {
183         String tagName = getTagName(o.node());
184         // FIXME: Temporary hack to make tests pass by simulating the old generated content output.
185         if (o.isPseudoElement() || (o.parent() &amp;&amp; o.parent()-&gt;isPseudoElement()))
186             tagName = emptyAtom();
187         if (!tagName.isEmpty()) {
188             ts &lt;&lt; &quot; {&quot; &lt;&lt; tagName &lt;&lt; &quot;}&quot;;
189             // flag empty or unstyled AppleStyleSpan because we never
190             // want to leave them in the DOM
191             if (isEmptyOrUnstyledAppleStyleSpan(o.node()))
192                 ts &lt;&lt; &quot; *empty or unstyled AppleStyleSpan*&quot;;
193         }
194     }
195 
196     RenderBlock* cb = o.containingBlock();
197     bool adjustForTableCells = cb ? cb-&gt;isTableCell() : false;
198 
199     LayoutRect r;
200     if (is&lt;RenderText&gt;(o)) {
201         // FIXME: Would be better to dump the bounding box x and y rather than the first run&#39;s x and y, but that would involve updating
202         // many test results.
203         const RenderText&amp; text = downcast&lt;RenderText&gt;(o);
204         r = IntRect(text.firstRunLocation(), text.linesBoundingBox().size());
<span class="line-modified">205         if (!LineLayoutTraversal::firstTextBoxFor(text))</span>

206             adjustForTableCells = false;
207     } else if (o.isBR()) {
208         const RenderLineBreak&amp; br = downcast&lt;RenderLineBreak&gt;(o);
<span class="line-modified">209         IntRect linesBox = br.boundingBoxForRenderTreeDump();</span>
210         r = IntRect(linesBox.x(), linesBox.y(), linesBox.width(), linesBox.height());
211         if (!br.inlineBoxWrapper())
212             adjustForTableCells = false;
213     } else if (is&lt;RenderInline&gt;(o)) {
214         const RenderInline&amp; inlineFlow = downcast&lt;RenderInline&gt;(o);
215         // FIXME: Would be better not to just dump 0, 0 as the x and y here.
216         r = IntRect(0, 0, inlineFlow.linesBoundingBox().width(), inlineFlow.linesBoundingBox().height());
217         adjustForTableCells = false;
218     } else if (is&lt;RenderTableCell&gt;(o)) {
219         // FIXME: Deliberately dump the &quot;inner&quot; box of table cells, since that is what current results reflect.  We&#39;d like
220         // to clean up the results to dump both the outer box and the intrinsic padding so that both bits of information are
221         // captured by the results.
222         const RenderTableCell&amp; cell = downcast&lt;RenderTableCell&gt;(o);
223         r = LayoutRect(cell.x(), cell.y() + cell.intrinsicPaddingBefore(), cell.width(), cell.height() - cell.intrinsicPaddingBefore() - cell.intrinsicPaddingAfter());
224     } else if (is&lt;RenderBox&gt;(o))
225         r = downcast&lt;RenderBox&gt;(o).frameRect();
226 
227     // FIXME: Temporary in order to ensure compatibility with existing layout test results.
228     if (adjustForTableCells)
229         r.move(0_lu, -downcast&lt;RenderTableCell&gt;(*o.containingBlock()).intrinsicPaddingBefore());
230 
231     // FIXME: Convert layout test results to report sub-pixel values, in the meantime using enclosingIntRect
232     // for consistency with old results.
233     ts &lt;&lt; &quot; &quot; &lt;&lt; enclosingIntRect(r);
234 
235     if (!is&lt;RenderText&gt;(o)) {
236         if (is&lt;RenderFileUploadControl&gt;(o))
237             ts &lt;&lt; &quot; &quot; &lt;&lt; quoteAndEscapeNonPrintables(downcast&lt;RenderFileUploadControl&gt;(o).fileTextValue());
238 
239         if (o.parent()) {
240             Color color = o.style().visitedDependentColor(CSSPropertyColor);
241             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyColor).rgb() != color.rgb())
242                 ts &lt;&lt; &quot; [color=&quot; &lt;&lt; color.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
243 
244             // Do not dump invalid or transparent backgrounds, since that is the default.
245             Color backgroundColor = o.style().visitedDependentColor(CSSPropertyBackgroundColor);
246             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyBackgroundColor).rgb() != backgroundColor.rgb()
<span class="line-modified">247                 &amp;&amp; backgroundColor.rgb() != Color::transparent)</span>
248                 ts &lt;&lt; &quot; [bgcolor=&quot; &lt;&lt; backgroundColor.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
249 
250             Color textFillColor = o.style().visitedDependentColor(CSSPropertyWebkitTextFillColor);
251             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyWebkitTextFillColor).rgb() != textFillColor.rgb()
<span class="line-modified">252                 &amp;&amp; textFillColor.rgb() != color.rgb() &amp;&amp; textFillColor.rgb() != Color::transparent)</span>
253                 ts &lt;&lt; &quot; [textFillColor=&quot; &lt;&lt; textFillColor.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
254 
255             Color textStrokeColor = o.style().visitedDependentColor(CSSPropertyWebkitTextStrokeColor);
256             if (o.parent()-&gt;style().visitedDependentColor(CSSPropertyWebkitTextStrokeColor).rgb() != textStrokeColor.rgb()
<span class="line-modified">257                 &amp;&amp; textStrokeColor.rgb() != color.rgb() &amp;&amp; textStrokeColor.rgb() != Color::transparent)</span>
258                 ts &lt;&lt; &quot; [textStrokeColor=&quot; &lt;&lt; textStrokeColor.nameForRenderTreeAsText() &lt;&lt; &quot;]&quot;;
259 
260             if (o.parent()-&gt;style().textStrokeWidth() != o.style().textStrokeWidth() &amp;&amp; o.style().textStrokeWidth() &gt; 0)
261                 ts &lt;&lt; &quot; [textStrokeWidth=&quot; &lt;&lt; o.style().textStrokeWidth() &lt;&lt; &quot;]&quot;;
262         }
263 
264         if (!is&lt;RenderBoxModelObject&gt;(o) || is&lt;RenderLineBreak&gt;(o))
265             return;
266 
267         const RenderBoxModelObject&amp; box = downcast&lt;RenderBoxModelObject&gt;(o);
268         LayoutUnit borderTop = box.borderTop();
269         LayoutUnit borderRight = box.borderRight();
270         LayoutUnit borderBottom = box.borderBottom();
271         LayoutUnit borderLeft = box.borderLeft();
272         if (box.isFieldset()) {
273             const auto&amp; block = downcast&lt;RenderBlock&gt;(box);
274             if (o.style().writingMode() == TopToBottomWritingMode)
275                 borderTop -= block.intrinsicBorderForFieldset();
276             else if (o.style().writingMode() == BottomToTopWritingMode)
277                 borderBottom -= block.intrinsicBorderForFieldset();
</pre>
<hr />
<pre>
460         }
461 
462         if (needsLayout)
463             ts &lt;&lt; &quot;)&quot;;
464     }
465 
466     if (behavior.contains(RenderAsTextFlag::ShowOverflow) &amp;&amp; is&lt;RenderBox&gt;(object)) {
467         const auto&amp; box = downcast&lt;RenderBox&gt;(object);
468         if (box.hasRenderOverflow()) {
469             LayoutRect layoutOverflow = box.layoutOverflowRect();
470             ts &lt;&lt; &quot; (layout overflow &quot; &lt;&lt; layoutOverflow.x().toInt() &lt;&lt; &quot;,&quot; &lt;&lt; layoutOverflow.y().toInt() &lt;&lt; &quot; &quot; &lt;&lt; layoutOverflow.width().toInt() &lt;&lt; &quot;x&quot; &lt;&lt; layoutOverflow.height().toInt() &lt;&lt; &quot;)&quot;;
471 
472             if (box.hasVisualOverflow()) {
473                 LayoutRect visualOverflow = box.visualOverflowRect();
474                 ts &lt;&lt; &quot; (visual overflow &quot; &lt;&lt; visualOverflow.x().toInt() &lt;&lt; &quot;,&quot; &lt;&lt; visualOverflow.y().toInt() &lt;&lt; &quot; &quot; &lt;&lt; visualOverflow.width().toInt() &lt;&lt; &quot;x&quot; &lt;&lt; visualOverflow.height().toInt() &lt;&lt; &quot;)&quot;;
475             }
476         }
477     }
478 }
479 
<span class="line-modified">480 static void writeTextBox(TextStream&amp; ts, const RenderText&amp; o, const LineLayoutTraversal::TextBox&amp; textBox)</span>
481 {
482     auto rect = textBox.rect();


483     int x = rect.x();
484     int y = rect.y();
<span class="line-modified">485     // FIXME: Use non-logical width. webkit.org/b/206809.</span>
<span class="line-modified">486     int logicalWidth = ceilf(rect.x() + (textBox.isHorizontal() ? rect.width() : rect.height())) - x;</span>


487     // FIXME: Table cell adjustment is temporary until results can be updated.
488     if (is&lt;RenderTableCell&gt;(*o.containingBlock()))
489         y -= floorToInt(downcast&lt;RenderTableCell&gt;(*o.containingBlock()).intrinsicPaddingBefore());
490 
491     ts &lt;&lt; &quot;text run at (&quot; &lt;&lt; x &lt;&lt; &quot;,&quot; &lt;&lt; y &lt;&lt; &quot;) width &quot; &lt;&lt; logicalWidth;
492     if (!textBox.isLeftToRightDirection() || textBox.dirOverride()) {
493         ts &lt;&lt; (!textBox.isLeftToRightDirection() ? &quot; RTL&quot; : &quot; LTR&quot;);
494         if (textBox.dirOverride())
495             ts &lt;&lt; &quot; override&quot;;
496     }
497     ts &lt;&lt; &quot;: &quot;
498         &lt;&lt; quoteAndEscapeNonPrintables(textBox.text());
499     if (textBox.hasHyphen())
500         ts &lt;&lt; &quot; + hyphen string &quot; &lt;&lt; quoteAndEscapeNonPrintables(o.style().hyphenString().string());
501     ts &lt;&lt; &quot;\n&quot;;
502 }
503 
504 void write(TextStream&amp; ts, const RenderObject&amp; o, OptionSet&lt;RenderAsTextFlag&gt; behavior)
505 {
506     if (is&lt;RenderSVGShape&gt;(o)) {
</pre>
<hr />
<pre>
528         return;
529     }
530     if (is&lt;RenderSVGInlineText&gt;(o)) {
531         writeSVGInlineText(ts, downcast&lt;RenderSVGInlineText&gt;(o), behavior);
532         return;
533     }
534     if (is&lt;RenderSVGImage&gt;(o)) {
535         writeSVGImage(ts, downcast&lt;RenderSVGImage&gt;(o), behavior);
536         return;
537     }
538 
539     ts &lt;&lt; indent;
540 
541     RenderTreeAsText::writeRenderObject(ts, o, behavior);
542     ts &lt;&lt; &quot;\n&quot;;
543 
544     TextStream::IndentScope indentScope(ts);
545 
546     if (is&lt;RenderText&gt;(o)) {
547         auto&amp; text = downcast&lt;RenderText&gt;(o);
<span class="line-modified">548         for (auto&amp; textBox : LineLayoutTraversal::textBoxesFor(text)) {</span>
549             ts &lt;&lt; indent;
550             writeTextBox(ts, text, textBox);
551         }
552     } else {
553         for (auto&amp; child : childrenOfType&lt;RenderObject&gt;(downcast&lt;RenderElement&gt;(o))) {
554             if (child.hasLayer())
555                 continue;
556             write(ts, child, behavior);
557         }
558     }
559 
560     if (is&lt;RenderWidget&gt;(o)) {
561         Widget* widget = downcast&lt;RenderWidget&gt;(o).widget();
562         if (is&lt;FrameView&gt;(widget)) {
563             FrameView&amp; view = downcast&lt;FrameView&gt;(*widget);
564             if (RenderView* root = view.frame().contentRenderer()) {
565                 if (!(behavior.contains(RenderAsTextFlag::DontUpdateLayout)))
566                     view.layoutContext().layout();
567                 if (RenderLayer* layer = root-&gt;layer())
568                     writeLayers(ts, *layer, *layer, layer-&gt;rect(), behavior);
</pre>
<hr />
<pre>
617 #endif
618     }
619 
620     if (paintPhase == LayerPaintPhaseBackground)
621         ts &lt;&lt; &quot; layerType: background only&quot;;
622     else if (paintPhase == LayerPaintPhaseForeground)
623         ts &lt;&lt; &quot; layerType: foreground only&quot;;
624 
625     if (behavior.contains(RenderAsTextFlag::ShowCompositedLayers)) {
626         if (layer.isComposited()) {
627             ts &lt;&lt; &quot; (composited, bounds=&quot; &lt;&lt; layer.backing()-&gt;compositedBounds() &lt;&lt; &quot;, drawsContent=&quot; &lt;&lt; layer.backing()-&gt;graphicsLayer()-&gt;drawsContent()
628                 &lt;&lt; &quot;, paints into ancestor=&quot; &lt;&lt; layer.backing()-&gt;paintsIntoCompositedAncestor() &lt;&lt; &quot;)&quot;;
629         } else if (layer.paintsIntoProvidedBacking())
630             ts &lt;&lt; &quot; (shared backing of &quot; &lt;&lt; layer.backingProviderLayer() &lt;&lt; &quot;)&quot;;
631     }
632 
633 #if ENABLE(CSS_COMPOSITING)
634     if (layer.isolatesBlending())
635         ts &lt;&lt; &quot; isolatesBlending&quot;;
636     if (layer.hasBlendMode())
<span class="line-modified">637         ts &lt;&lt; &quot; blendMode: &quot; &lt;&lt; compositeOperatorName(CompositeOperator::SourceOver, layer.blendMode());</span>
638 #endif
639 
640     ts &lt;&lt; &quot;\n&quot;;
641 }
642 
643 static void writeLayerRenderers(TextStream&amp; ts, const RenderLayer&amp; layer, LayerPaintPhase paintPhase, OptionSet&lt;RenderAsTextFlag&gt; behavior)
644 {
645     if (paintPhase != LayerPaintPhaseBackground) {
646         TextStream::IndentScope indentScope(ts);
647         write(ts, layer.renderer(), behavior);
648     }
649 }
650 
651 static LayoutSize maxLayoutOverflow(const RenderBox* box)
652 {
653     LayoutRect overflowRect = box-&gt;layoutOverflowRect();
654     return LayoutSize(overflowRect.maxX(), overflowRect.maxY());
655 }
656 
657 static void writeLayers(TextStream&amp; ts, const RenderLayer&amp; rootLayer, RenderLayer&amp; layer, const LayoutRect&amp; paintRect, OptionSet&lt;RenderAsTextFlag&gt; behavior)
</pre>
</td>
</tr>
</table>
<center><a href="RenderThemeWin.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderVTTCue.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
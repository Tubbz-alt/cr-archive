<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBRequest.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;IDBRequest.h&quot;
 28 
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;DOMException.h&quot;
 32 #include &quot;Event.h&quot;
 33 #include &quot;EventDispatcher.h&quot;
 34 #include &quot;EventNames.h&quot;
 35 #include &quot;EventQueue.h&quot;
 36 #include &quot;IDBBindingUtilities.h&quot;
 37 #include &quot;IDBConnectionProxy.h&quot;
 38 #include &quot;IDBCursor.h&quot;
 39 #include &quot;IDBDatabase.h&quot;
 40 #include &quot;IDBIndex.h&quot;
 41 #include &quot;IDBKeyData.h&quot;
 42 #include &quot;IDBObjectStore.h&quot;
 43 #include &quot;IDBResultData.h&quot;
 44 #include &quot;JSDOMConvertIndexedDB.h&quot;
 45 #include &quot;JSDOMConvertNumbers.h&quot;
 46 #include &quot;JSDOMConvertSequences.h&quot;
 47 #include &quot;Logging.h&quot;
 48 #include &quot;ScriptExecutionContext.h&quot;
 49 #include &quot;ThreadSafeDataBuffer.h&quot;
 50 #include &lt;JavaScriptCore/StrongInlines.h&gt;
 51 #include &lt;wtf/IsoMallocInlines.h&gt;
 52 #include &lt;wtf/Scope.h&gt;
 53 #include &lt;wtf/Variant.h&gt;
 54 
 55 
 56 namespace WebCore {
 57 using namespace JSC;
 58 
 59 WTF_MAKE_ISO_ALLOCATED_IMPL(IDBRequest);
 60 
 61 Ref&lt;IDBRequest&gt; IDBRequest::create(ScriptExecutionContext&amp; context, IDBObjectStore&amp; objectStore, IDBTransaction&amp; transaction)
 62 {
 63     return adoptRef(*new IDBRequest(context, objectStore, transaction));
 64 }
 65 
 66 Ref&lt;IDBRequest&gt; IDBRequest::create(ScriptExecutionContext&amp; context, IDBCursor&amp; cursor, IDBTransaction&amp; transaction)
 67 {
 68     return adoptRef(*new IDBRequest(context, cursor, transaction));
 69 }
 70 
 71 Ref&lt;IDBRequest&gt; IDBRequest::create(ScriptExecutionContext&amp; context, IDBIndex&amp; index, IDBTransaction&amp; transaction)
 72 {
 73     return adoptRef(*new IDBRequest(context, index, transaction));
 74 }
 75 
 76 Ref&lt;IDBRequest&gt; IDBRequest::createObjectStoreGet(ScriptExecutionContext&amp; context, IDBObjectStore&amp; objectStore, IndexedDB::ObjectStoreRecordType type, IDBTransaction&amp; transaction)
 77 {
 78     return adoptRef(*new IDBRequest(context, objectStore, type, transaction));
 79 }
 80 
 81 Ref&lt;IDBRequest&gt; IDBRequest::createIndexGet(ScriptExecutionContext&amp; context, IDBIndex&amp; index, IndexedDB::IndexRecordType requestedRecordType, IDBTransaction&amp; transaction)
 82 {
 83     return adoptRef(*new IDBRequest(context, index, requestedRecordType, transaction));
 84 }
 85 
 86 IDBRequest::IDBRequest(ScriptExecutionContext&amp; context, IDBClient::IDBConnectionProxy&amp; connectionProxy)
 87     : IDBActiveDOMObject(&amp;context)
 88     , m_resourceIdentifier(connectionProxy)
 89     , m_connectionProxy(connectionProxy)
 90 {
 91     m_result = NullResultType::Undefined;
 92     suspendIfNeeded();
 93 }
 94 
 95 IDBRequest::IDBRequest(ScriptExecutionContext&amp; context, IDBObjectStore&amp; objectStore, IDBTransaction&amp; transaction)
 96     : IDBActiveDOMObject(&amp;context)
 97     , m_transaction(&amp;transaction)
 98     , m_resourceIdentifier(transaction.connectionProxy())
 99     , m_source(&amp;objectStore)
100     , m_connectionProxy(transaction.database().connectionProxy())
101 {
102     m_result = NullResultType::Undefined;
103     suspendIfNeeded();
104 }
105 
106 IDBRequest::IDBRequest(ScriptExecutionContext&amp; context, IDBCursor&amp; cursor, IDBTransaction&amp; transaction)
107     : IDBActiveDOMObject(&amp;context)
108     , m_transaction(&amp;transaction)
109     , m_resourceIdentifier(transaction.connectionProxy())
110     , m_pendingCursor(&amp;cursor)
111     , m_connectionProxy(transaction.database().connectionProxy())
112 {
113     suspendIfNeeded();
114 
115     WTF::switchOn(cursor.source(),
116         [this] (const auto&amp; value) { this-&gt;m_source = IDBRequest::Source { value }; }
117     );
118 
119     m_result = NullResultType::Undefined;
120     cursor.setRequest(*this);
121 }
122 
123 IDBRequest::IDBRequest(ScriptExecutionContext&amp; context, IDBIndex&amp; index, IDBTransaction&amp; transaction)
124     : IDBActiveDOMObject(&amp;context)
125     , m_transaction(&amp;transaction)
126     , m_resourceIdentifier(transaction.connectionProxy())
127     , m_source(&amp;index)
128     , m_connectionProxy(transaction.database().connectionProxy())
129 {
130     m_result = NullResultType::Undefined;
131     suspendIfNeeded();
132 }
133 
134 IDBRequest::IDBRequest(ScriptExecutionContext&amp; context, IDBObjectStore&amp; objectStore, IndexedDB::ObjectStoreRecordType type, IDBTransaction&amp; transaction)
135     : IDBActiveDOMObject(&amp;context)
136     , m_transaction(&amp;transaction)
137     , m_resourceIdentifier(transaction.connectionProxy())
138     , m_source(&amp;objectStore)
139     , m_requestedObjectStoreRecordType(type)
140     , m_connectionProxy(transaction.database().connectionProxy())
141 {
142     m_result = NullResultType::Undefined;
143     suspendIfNeeded();
144 }
145 
146 IDBRequest::IDBRequest(ScriptExecutionContext&amp; context, IDBIndex&amp; index, IndexedDB::IndexRecordType requestedRecordType, IDBTransaction&amp; transaction)
147     : IDBRequest(context, index, transaction)
148 {
149     m_result = NullResultType::Undefined;
150     m_requestedIndexRecordType = requestedRecordType;
151 }
152 
153 IDBRequest::~IDBRequest()
154 {
155     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
156 
157     WTF::switchOn(m_result,
158         [] (RefPtr&lt;IDBCursor&gt;&amp; cursor) { cursor-&gt;clearRequest(); },
159         [] (const auto&amp;) { }
160     );
161 }
162 
163 ExceptionOr&lt;IDBRequest::Result&gt; IDBRequest::result() const
164 {
165     if (!isDone())
166         return Exception { InvalidStateError, &quot;Failed to read the &#39;result&#39; property from &#39;IDBRequest&#39;: The request has not finished.&quot;_s };
167 
168     return IDBRequest::Result { m_result };
169 }
170 
171 ExceptionOr&lt;DOMException*&gt; IDBRequest::error() const
172 {
173     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
174 
175     if (!isDone())
176         return Exception { InvalidStateError, &quot;Failed to read the &#39;error&#39; property from &#39;IDBRequest&#39;: The request has not finished.&quot;_s };
177 
178     return m_domError.get();
179 }
180 
181 void IDBRequest::setSource(IDBCursor&amp; cursor)
182 {
183     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
184 
185     m_source = Source { &amp;cursor };
186 }
187 
188 void IDBRequest::setVersionChangeTransaction(IDBTransaction&amp; transaction)
189 {
190     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
191     ASSERT(!m_transaction);
192     ASSERT(transaction.isVersionChange());
193     ASSERT(!transaction.isFinishedOrFinishing());
194 
195     m_transaction = &amp;transaction;
196 }
197 
198 RefPtr&lt;WebCore::IDBTransaction&gt; IDBRequest::transaction() const
199 {
200     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
201     return m_shouldExposeTransactionToDOM ? m_transaction : nullptr;
202 }
203 
204 uint64_t IDBRequest::sourceObjectStoreIdentifier() const
205 {
206     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
207 
208     if (!m_source)
209         return 0;
210 
211     return WTF::switchOn(m_source.value(),
212         [] (const RefPtr&lt;IDBObjectStore&gt;&amp; objectStore) { return objectStore-&gt;info().identifier(); },
213         [] (const RefPtr&lt;IDBIndex&gt;&amp; index) { return index-&gt;info().objectStoreIdentifier(); },
214         [] (const RefPtr&lt;IDBCursor&gt;&amp;) { return 0; }
215     );
216 }
217 
218 uint64_t IDBRequest::sourceIndexIdentifier() const
219 {
220     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
221 
222     if (!m_source)
223         return 0;
224 
225     return WTF::switchOn(m_source.value(),
226         [] (const RefPtr&lt;IDBObjectStore&gt;&amp;) -&gt; uint64_t { return 0; },
227         [] (const RefPtr&lt;IDBIndex&gt;&amp; index) -&gt; uint64_t { return index-&gt;info().identifier(); },
228         [] (const RefPtr&lt;IDBCursor&gt;&amp;) -&gt; uint64_t { return 0; }
229     );
230 }
231 
232 IndexedDB::ObjectStoreRecordType IDBRequest::requestedObjectStoreRecordType() const
233 {
234     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
235 
236     return m_requestedObjectStoreRecordType;
237 }
238 
239 IndexedDB::IndexRecordType IDBRequest::requestedIndexRecordType() const
240 {
241     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
242     ASSERT(m_source);
243     ASSERT(WTF::holds_alternative&lt;RefPtr&lt;IDBIndex&gt;&gt;(m_source.value()));
244 
245     return m_requestedIndexRecordType;
246 }
247 
248 EventTargetInterface IDBRequest::eventTargetInterface() const
249 {
250     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
251 
252     return IDBRequestEventTargetInterfaceType;
253 }
254 
255 const char* IDBRequest::activeDOMObjectName() const
256 {
257     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
258 
259     return &quot;IDBRequest&quot;;
260 }
261 
262 bool IDBRequest::hasPendingActivity() const
263 {
264     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()) || Thread::mayBeGCThread());
265     return !m_contextStopped &amp;&amp; m_hasPendingActivity;
266 }
267 
268 void IDBRequest::stop()
269 {
270     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
271     ASSERT(!m_contextStopped);
272 
273     cancelForStop();
274 
275     removeAllEventListeners();
276 
277     clearWrappers();
278 
279     m_contextStopped = true;
280 }
281 
282 void IDBRequest::cancelForStop()
283 {
284     // The base IDBRequest class has nothing additional to do here.
285 }
286 
287 void IDBRequest::enqueueEvent(Ref&lt;Event&gt;&amp;&amp; event)
288 {
289     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
290     if (m_contextStopped)
291         return;
292 
293     queueTaskToDispatchEvent(*this, TaskSource::DatabaseAccess, WTFMove(event));
294 }
295 
296 void IDBRequest::dispatchEvent(Event&amp; event)
297 {
298     LOG(IndexedDB, &quot;IDBRequest::dispatchEvent - %s (%p)&quot;, event.type().string().utf8().data(), this);
299 
300     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
301     ASSERT(m_hasPendingActivity);
302     ASSERT(!m_contextStopped);
303 
304     auto protectedThis = makeRef(*this);
305     m_dispatchingEvent = true;
306 
307     if (event.type() != eventNames().blockedEvent)
308         m_readyState = ReadyState::Done;
309 
310     Vector&lt;EventTarget*&gt; targets { this };
311 
312     if (&amp;event == m_openDatabaseSuccessEvent)
313         m_openDatabaseSuccessEvent = nullptr;
314     else if (m_transaction &amp;&amp; !m_transaction-&gt;didDispatchAbortOrCommit())
315         targets = { this, m_transaction.get(), &amp;m_transaction-&gt;database() };
316 
317     m_hasPendingActivity = false;
318 
319     {
320         TransactionActivator activator(m_transaction.get());
321         EventDispatcher::dispatchEvent(targets, event);
322     }
323 
324     // Dispatching the event might have set the pending activity flag back to true, suggesting the request will be reused.
325     // We might also re-use the request if this event was the upgradeneeded event for an IDBOpenDBRequest.
326     if (!m_hasPendingActivity)
327         m_hasPendingActivity = isOpenDBRequest() &amp;&amp; (event.type() == eventNames().upgradeneededEvent || event.type() == eventNames().blockedEvent);
328 
329     m_dispatchingEvent = false;
330     if (!m_transaction)
331         return;
332 
333     if (m_hasUncaughtException)
334         m_transaction-&gt;abortDueToFailedRequest(DOMException::create(AbortError, &quot;IDBTransaction will abort due to uncaught exception in an event handler&quot;_s));
335     else if (!event.defaultPrevented() &amp;&amp; event.type() == eventNames().errorEvent &amp;&amp; !m_transaction-&gt;isFinishedOrFinishing()) {
336         ASSERT(m_domError);
337         m_transaction-&gt;abortDueToFailedRequest(*m_domError);
338     }
339 
340     m_transaction-&gt;finishedDispatchEventForRequest(*this);
341 
342     // The request should only remain in the transaction&#39;s request list if it represents a pending cursor operation, or this is an open request that was blocked.
343     if (!m_pendingCursor &amp;&amp; event.type() != eventNames().blockedEvent)
344         m_transaction-&gt;removeRequest(*this);
345 }
346 
347 void IDBRequest::uncaughtExceptionInEventHandler()
348 {
349     LOG(IndexedDB, &quot;IDBRequest::uncaughtExceptionInEventHandler&quot;);
350 
351     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
352 
353     if (m_dispatchingEvent) {
354         ASSERT(!m_hasUncaughtException);
355         m_hasUncaughtException = true;
356         return;
357     }
358     if (m_transaction &amp;&amp; m_idbError.code() != AbortError)
359         m_transaction-&gt;abortDueToFailedRequest(DOMException::create(AbortError, &quot;IDBTransaction will abort due to uncaught exception in an event handler&quot;_s));
360 }
361 
362 void IDBRequest::setResult(const IDBKeyData&amp; keyData)
363 {
364     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
365 
366     auto* context = scriptExecutionContext();
367     if (!context)
368         return;
369 
370     VM&amp; vm = context-&gt;vm();
371     JSLockHolder lock(vm);
372     m_result = keyData;
373     m_resultWrapper = { };
374 }
375 
376 void IDBRequest::setResult(const Vector&lt;IDBKeyData&gt;&amp; keyDatas)
377 {
378     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
379 
380     auto* context = scriptExecutionContext();
381     if (!context)
382         return;
383 
384     VM&amp; vm = context-&gt;vm();
385     JSLockHolder lock(vm);
386     m_result = keyDatas;
387     m_resultWrapper = { };
388 }
389 
390 void IDBRequest::setResult(const IDBGetAllResult&amp; result)
391 {
392     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
393 
394     auto* context = scriptExecutionContext();
395     if (!context)
396         return;
397 
398     VM&amp; vm = context-&gt;vm();
399     JSLockHolder lock(vm);
400     m_result = result;
401     m_resultWrapper = { };
402 }
403 
404 void IDBRequest::setResult(uint64_t number)
405 {
406     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
407 
408     auto* context = scriptExecutionContext();
409     if (!context)
410         return;
411 
412     VM&amp; vm = context-&gt;vm();
413     JSLockHolder lock(vm);
414     m_result = number;
415     m_resultWrapper = { };
416 }
417 
418 void IDBRequest::setResultToStructuredClone(const IDBGetResult&amp; result)
419 {
420     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
421 
422     LOG(IndexedDB, &quot;IDBRequest::setResultToStructuredClone&quot;);
423 
424     auto* context = scriptExecutionContext();
425     if (!context)
426         return;
427 
428     VM&amp; vm = context-&gt;vm();
429     JSLockHolder lock(vm);
430     m_result = result;
431     m_resultWrapper = { };
432 }
433 
434 void IDBRequest::setResultToUndefined()
435 {
436     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
437 
438     auto* context = scriptExecutionContext();
439     if (!context)
440         return;
441 
442     VM&amp; vm = context-&gt;vm();
443     JSLockHolder lock(vm);
444     m_result = NullResultType::Undefined;
445     m_resultWrapper = { };
446 }
447 
448 IDBCursor* IDBRequest::resultCursor()
449 {
450     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
451 
452     return WTF::switchOn(m_result,
453         [] (const RefPtr&lt;IDBCursor&gt;&amp; cursor) -&gt; IDBCursor* { return cursor.get(); },
454         [] (const auto&amp;) -&gt; IDBCursor* { return nullptr; }
455     );
456 }
457 
458 void IDBRequest::willIterateCursor(IDBCursor&amp; cursor)
459 {
460     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
461     ASSERT(isDone());
462     ASSERT(scriptExecutionContext());
463     ASSERT(m_transaction);
464     ASSERT(!m_pendingCursor);
465     ASSERT(&amp;cursor == resultCursor());
466 
467     m_pendingCursor = &amp;cursor;
468     m_hasPendingActivity = true;
469     m_result = NullResultType::Empty;
470 
471     auto* context = scriptExecutionContext();
472     if (!context)
473         return;
474 
475     VM&amp; vm = context-&gt;vm();
476     JSLockHolder lock(vm);
477 
478     if (m_resultWrapper)
479         m_cursorWrapper = m_resultWrapper;
480     m_resultWrapper = { };
481     m_readyState = ReadyState::Pending;
482     m_domError = nullptr;
483     m_idbError = IDBError { };
484 }
485 
486 void IDBRequest::didOpenOrIterateCursor(const IDBResultData&amp; resultData)
487 {
488     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
489     ASSERT(m_pendingCursor);
490 
491     auto* context = scriptExecutionContext();
492     if (!context)
493         return;
494 
495     VM&amp; vm = context-&gt;vm();
496     JSLockHolder lock(vm);
497 
498     m_result = NullResultType::Empty;
499     m_resultWrapper = { };
500 
501     if (resultData.type() == IDBResultType::IterateCursorSuccess || resultData.type() == IDBResultType::OpenCursorSuccess) {
502         if (m_pendingCursor-&gt;setGetResult(*this, resultData.getResult(), m_currentTransactionOperationID) &amp;&amp; m_cursorWrapper)
503             m_resultWrapper = m_cursorWrapper;
504         if (resultData.getResult().isDefined())
505             m_result = m_pendingCursor;
506     }
507 
508     m_pendingCursor = nullptr;
509 
510     completeRequestAndDispatchEvent(resultData);
511 }
512 
513 void IDBRequest::completeRequestAndDispatchEvent(const IDBResultData&amp; resultData)
514 {
515     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
516 
517     m_readyState = ReadyState::Done;
518 
519     m_idbError = resultData.error();
520     if (!m_idbError.isNull())
521         onError();
522     else
523         onSuccess();
524 }
525 
526 void IDBRequest::onError()
527 {
528     LOG(IndexedDB, &quot;IDBRequest::onError&quot;);
529 
530     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
531     ASSERT(!m_idbError.isNull());
532 
533     m_domError = m_idbError.toDOMException();
534     enqueueEvent(Event::create(eventNames().errorEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes));
535 }
536 
537 void IDBRequest::onSuccess()
538 {
539     LOG(IndexedDB, &quot;IDBRequest::onSuccess&quot;);
540     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
541     enqueueEvent(Event::create(eventNames().successEvent, Event::CanBubble::No, Event::IsCancelable::No));
542 }
543 
544 void IDBRequest::setResult(Ref&lt;IDBDatabase&gt;&amp;&amp; database)
545 {
546     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
547 
548     auto* context = scriptExecutionContext();
549     if (!context)
550         return;
551 
552     VM&amp; vm = context-&gt;vm();
553     JSLockHolder lock(vm);
554 
555     m_result = RefPtr&lt;IDBDatabase&gt; { WTFMove(database) };
556     m_resultWrapper = { };
557 }
558 
559 void IDBRequest::clearWrappers()
560 {
561     auto* context = scriptExecutionContext();
562     if (!context)
563         return;
564     VM&amp; vm = context-&gt;vm();
565     JSLockHolder lock(vm);
566 
567     m_resultWrapper.clear();
568     m_cursorWrapper.clear();
569 
570     WTF::switchOn(m_result,
571         [] (RefPtr&lt;IDBCursor&gt;&amp; cursor) { cursor-&gt;clearWrappers(); },
572         [] (const auto&amp;) { }
573     );
574 }
575 
576 
577 } // namespace WebCore
578 
579 #endif // ENABLE(INDEXED_DATABASE)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/webdatabase/DatabaseManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DatabaseManager.h&quot;
 28 
 29 #include &quot;Database.h&quot;
 30 #include &quot;DatabaseCallback.h&quot;
 31 #include &quot;DatabaseContext.h&quot;
 32 #include &quot;DatabaseTask.h&quot;
 33 #include &quot;DatabaseTracker.h&quot;
 34 #include &quot;Document.h&quot;
 35 #include &quot;InspectorInstrumentation.h&quot;
 36 #include &quot;Logging.h&quot;
 37 #include &quot;PlatformStrategies.h&quot;
 38 #include &quot;ScriptController.h&quot;
 39 #include &quot;SecurityOrigin.h&quot;
 40 #include &quot;SecurityOriginData.h&quot;
 41 #include &quot;WindowEventLoop.h&quot;
 42 #include &lt;wtf/NeverDestroyed.h&gt;
 43 
 44 namespace WebCore {
 45 
 46 class DatabaseManager::ProposedDatabase {
 47 public:
 48     ProposedDatabase(DatabaseManager&amp;, SecurityOrigin&amp;, const String&amp; name, const String&amp; displayName, unsigned long estimatedSize);
 49     ~ProposedDatabase();
 50 
 51     SecurityOrigin&amp; origin() { return m_origin; }
 52     DatabaseDetails&amp; details() { return m_details; }
 53 
 54 private:
 55     DatabaseManager&amp; m_manager;
 56     Ref&lt;SecurityOrigin&gt; m_origin;
 57     DatabaseDetails m_details;
 58 };
 59 
 60 DatabaseManager::ProposedDatabase::ProposedDatabase(DatabaseManager&amp; manager, SecurityOrigin&amp; origin, const String&amp; name, const String&amp; displayName, unsigned long estimatedSize)
 61     : m_manager(manager)
 62     , m_origin(origin.isolatedCopy())
 63     , m_details(name.isolatedCopy(), displayName.isolatedCopy(), estimatedSize, 0, WTF::nullopt, WTF::nullopt)
 64 {
 65     m_manager.addProposedDatabase(*this);
 66 }
 67 
 68 inline DatabaseManager::ProposedDatabase::~ProposedDatabase()
 69 {
 70     m_manager.removeProposedDatabase(*this);
 71 }
 72 
 73 DatabaseManager&amp; DatabaseManager::singleton()
 74 {
 75     static NeverDestroyed&lt;DatabaseManager&gt; instance;
 76     return instance;
 77 }
 78 
 79 void DatabaseManager::initialize(const String&amp; databasePath)
 80 {
 81     platformInitialize(databasePath);
 82     DatabaseTracker::initializeTracker(databasePath);
 83 }
 84 
 85 void DatabaseManager::setClient(DatabaseManagerClient* client)
 86 {
 87     m_client = client;
 88     DatabaseTracker::singleton().setClient(client);
 89 }
 90 
 91 bool DatabaseManager::isAvailable()
 92 {
 93     return m_databaseIsAvailable;
 94 }
 95 
 96 void DatabaseManager::setIsAvailable(bool available)
 97 {
 98     m_databaseIsAvailable = available;
 99 }
100 
101 Ref&lt;DatabaseContext&gt; DatabaseManager::databaseContext(Document&amp; document)
102 {
103     if (auto databaseContext = document.databaseContext())
104         return *databaseContext;
105     return adoptRef(*new DatabaseContext(document));
106 }
107 
108 #if LOG_DISABLED
109 
110 static inline void logOpenDatabaseError(Document&amp;, const String&amp;)
111 {
112 }
113 
114 #else
115 
116 static void logOpenDatabaseError(Document&amp; document, const String&amp; name)
117 {
118     LOG(StorageAPI, &quot;Database %s for origin %s not allowed to be established&quot;, name.utf8().data(), document.securityOrigin().toString().utf8().data());
119 }
120 
121 #endif
122 
123 ExceptionOr&lt;Ref&lt;Database&gt;&gt; DatabaseManager::openDatabaseBackend(Document&amp; document, const String&amp; name, const String&amp; expectedVersion, const String&amp; displayName, unsigned estimatedSize, bool setVersionInNewDatabase)
124 {
125     auto backend = tryToOpenDatabaseBackend(document, name, expectedVersion, displayName, estimatedSize, setVersionInNewDatabase, FirstTryToOpenDatabase);
126 
127     if (backend.hasException()) {
128         if (backend.exception().code() == QuotaExceededError) {
129             // Notify the client that we&#39;ve exceeded the database quota.
130             // The client may want to increase the quota, and we&#39;ll give it
131             // one more try after if that is the case.
132             {
133                 ProposedDatabase proposedDatabase { *this, document.securityOrigin(), name, displayName, estimatedSize };
134                 this-&gt;databaseContext(document)-&gt;databaseExceededQuota(name, proposedDatabase.details());
135             }
136             backend = tryToOpenDatabaseBackend(document, name, expectedVersion, displayName, estimatedSize, setVersionInNewDatabase, RetryOpenDatabase);
137         }
138     }
139 
140     if (backend.hasException()) {
141         if (backend.exception().code() == InvalidStateError)
142             logErrorMessage(document, backend.exception().message());
143         else
144             logOpenDatabaseError(document, name);
145     }
146 
147     return backend;
148 }
149 
150 ExceptionOr&lt;Ref&lt;Database&gt;&gt; DatabaseManager::tryToOpenDatabaseBackend(Document&amp; document, const String&amp; name, const String&amp; expectedVersion, const String&amp; displayName, unsigned estimatedSize, bool setVersionInNewDatabase,
151     OpenAttempt attempt)
152 {
153     auto* page = document.page();
154     if (!page || page-&gt;usesEphemeralSession())
155         return Exception { SecurityError };
156 
157     auto backendContext = this-&gt;databaseContext(document);
158 
159     ExceptionOr&lt;void&gt; preflightResult;
160     switch (attempt) {
161     case FirstTryToOpenDatabase:
162         preflightResult = DatabaseTracker::singleton().canEstablishDatabase(backendContext, name, estimatedSize);
163         break;
164     case RetryOpenDatabase:
165         preflightResult = DatabaseTracker::singleton().retryCanEstablishDatabase(backendContext, name, estimatedSize);
166         break;
167     }
168     if (preflightResult.hasException())
169         return preflightResult.releaseException();
170 
171     auto database = adoptRef(*new Database(backendContext, name, expectedVersion, displayName, estimatedSize));
172 
173     auto openResult = database-&gt;openAndVerifyVersion(setVersionInNewDatabase);
174     if (openResult.hasException())
175         return openResult.releaseException();
176 
177     // FIXME: What guarantees backendContext.securityOrigin() is non-null?
178     DatabaseTracker::singleton().setDatabaseDetails(backendContext-&gt;securityOrigin(), name, displayName, estimatedSize);
179     return database;
180 }
181 
182 void DatabaseManager::addProposedDatabase(ProposedDatabase&amp; database)
183 {
184     std::lock_guard&lt;Lock&gt; lock { m_proposedDatabasesMutex };
185     m_proposedDatabases.add(&amp;database);
186 }
187 
188 void DatabaseManager::removeProposedDatabase(ProposedDatabase&amp; database)
189 {
190     std::lock_guard&lt;Lock&gt; lock { m_proposedDatabasesMutex };
191     m_proposedDatabases.remove(&amp;database);
192 }
193 
194 ExceptionOr&lt;Ref&lt;Database&gt;&gt; DatabaseManager::openDatabase(Document&amp; document, const String&amp; name, const String&amp; expectedVersion, const String&amp; displayName, unsigned estimatedSize, RefPtr&lt;DatabaseCallback&gt;&amp;&amp; creationCallback)
195 {
196     ASSERT(isMainThread());
197     ScriptController::initializeThreading();
198 
199     bool setVersionInNewDatabase = !creationCallback;
200     auto openResult = openDatabaseBackend(document, name, expectedVersion, displayName, estimatedSize, setVersionInNewDatabase);
201     if (openResult.hasException())
202         return openResult.releaseException();
203 
204     RefPtr&lt;Database&gt; database = openResult.releaseReturnValue();
205 
206     auto databaseContext = this-&gt;databaseContext(document);
207     databaseContext-&gt;setHasOpenDatabases();
208     InspectorInstrumentation::didOpenDatabase(*database);
209 
210     if (database-&gt;isNew() &amp;&amp; creationCallback.get()) {
211         LOG(StorageAPI, &quot;Scheduling DatabaseCreationCallbackTask for database %p\n&quot;, database.get());
212         database-&gt;setHasPendingCreationEvent(true);
213         database-&gt;m_document-&gt;eventLoop().queueTask(TaskSource::Networking, [creationCallback, database]() {
214             creationCallback-&gt;handleEvent(*database);
215             database-&gt;setHasPendingCreationEvent(false);
216         });
217     }
218 
219     return database.releaseNonNull();
220 }
221 
222 bool DatabaseManager::hasOpenDatabases(Document&amp; document)
223 {
224     auto databaseContext = document.databaseContext();
225     return databaseContext &amp;&amp; databaseContext-&gt;hasOpenDatabases();
226 }
227 
228 void DatabaseManager::stopDatabases(Document&amp; document, DatabaseTaskSynchronizer* synchronizer)
229 {
230     auto databaseContext = document.databaseContext();
231     if (!databaseContext || !databaseContext-&gt;stopDatabases(synchronizer)) {
232         if (synchronizer)
233             synchronizer-&gt;taskCompleted();
234     }
235 }
236 
237 String DatabaseManager::fullPathForDatabase(SecurityOrigin&amp; origin, const String&amp; name, bool createIfDoesNotExist)
238 {
239     {
240         std::lock_guard&lt;Lock&gt; lock { m_proposedDatabasesMutex };
241         for (auto* proposedDatabase : m_proposedDatabases) {
242             if (proposedDatabase-&gt;details().name() == name &amp;&amp; proposedDatabase-&gt;origin().equal(&amp;origin))
243                 return String();
244         }
245     }
246     return DatabaseTracker::singleton().fullPathForDatabase(origin.data(), name, createIfDoesNotExist);
247 }
248 
249 DatabaseDetails DatabaseManager::detailsForNameAndOrigin(const String&amp; name, SecurityOrigin&amp; origin)
250 {
251     {
252         std::lock_guard&lt;Lock&gt; lock { m_proposedDatabasesMutex };
253         for (auto* proposedDatabase : m_proposedDatabases) {
254             if (proposedDatabase-&gt;details().name() == name &amp;&amp; proposedDatabase-&gt;origin().equal(&amp;origin)) {
255                 ASSERT(&amp;proposedDatabase-&gt;details().thread() == &amp;Thread::current() || isMainThread());
256                 return proposedDatabase-&gt;details();
257             }
258         }
259     }
260 
261     return DatabaseTracker::singleton().detailsForNameAndOrigin(name, origin.data());
262 }
263 
264 void DatabaseManager::logErrorMessage(Document&amp; document, const String&amp; message)
265 {
266     document.addConsoleMessage(MessageSource::Storage, MessageLevel::Error, message);
267 }
268 
269 #if !PLATFORM(COCOA)
270 void DatabaseManager::platformInitialize(const String&amp; databasePath)
271 {
272     UNUSED_PARAM(databasePath);
273 }
274 #endif
275 
276 } // namespace WebCore
    </pre>
  </body>
</html>
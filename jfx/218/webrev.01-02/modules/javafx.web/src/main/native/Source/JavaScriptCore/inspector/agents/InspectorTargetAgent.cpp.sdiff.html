<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorTargetAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorScriptProfilerAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorTargetAgent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorTargetAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorTargetAgent.h&quot;
 28 
 29 #include &quot;InspectorTarget.h&quot;
 30 
 31 namespace Inspector {
 32 
 33 InspectorTargetAgent::InspectorTargetAgent(FrontendRouter&amp; frontendRouter, BackendDispatcher&amp; backendDispatcher)
 34     : InspectorAgentBase(&quot;Target&quot;_s)

 35     , m_frontendDispatcher(makeUnique&lt;TargetFrontendDispatcher&gt;(frontendRouter))
 36     , m_backendDispatcher(TargetBackendDispatcher::create(backendDispatcher, this))
 37 {
 38 }
 39 
 40 InspectorTargetAgent::~InspectorTargetAgent() = default;
 41 
 42 void InspectorTargetAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
 43 {
 44     m_isConnected = true;
 45 
 46     connectToTargets();
 47 }
 48 
 49 void InspectorTargetAgent::willDestroyFrontendAndBackend(DisconnectReason)
 50 {
 51     disconnectFromTargets();
 52 
 53     m_isConnected = false;

 54 }
 55 
<span class="line-modified"> 56 void InspectorTargetAgent::exists(ErrorString&amp;)</span>
 57 {
<span class="line-modified"> 58     // Intentionally do nothing to return success.</span>
<span class="line-modified"> 59     // FIXME: Remove this when the local inspector has switched over to the modern path.</span>















 60 }
 61 
 62 void InspectorTargetAgent::sendMessageToTarget(ErrorString&amp; errorString, const String&amp; targetId, const String&amp; message)
 63 {
 64     InspectorTarget* target = m_targets.get(targetId);
 65     if (!target) {
 66         errorString = &quot;Missing target for given targetId&quot;_s;
 67         return;
 68     }
 69 
 70     target-&gt;sendMessageToTargetBackend(message);
 71 }
 72 
 73 void InspectorTargetAgent::sendMessageFromTargetToFrontend(const String&amp; targetId, const String&amp; message)
 74 {
 75     ASSERT_WITH_MESSAGE(m_targets.get(targetId), &quot;Sending a message from an untracked target to the frontend.&quot;);
 76 
 77     m_frontendDispatcher-&gt;dispatchMessageFromTarget(targetId, message);
 78 }
 79 
 80 static Protocol::Target::TargetInfo::Type targetTypeToProtocolType(InspectorTargetType type)
 81 {
 82     switch (type) {
<span class="line-removed"> 83     case InspectorTargetType::JavaScriptContext:</span>
<span class="line-removed"> 84         return Protocol::Target::TargetInfo::Type::JavaScript;</span>
 85     case InspectorTargetType::Page:
 86         return Protocol::Target::TargetInfo::Type::Page;
 87     case InspectorTargetType::DedicatedWorker:
 88         return Protocol::Target::TargetInfo::Type::Worker;
 89     case InspectorTargetType::ServiceWorker:
 90         return Protocol::Target::TargetInfo::Type::ServiceWorker;
 91     }
 92 
 93     ASSERT_NOT_REACHED();
<span class="line-modified"> 94     return Protocol::Target::TargetInfo::Type::JavaScript;</span>
 95 }
 96 
 97 static Ref&lt;Protocol::Target::TargetInfo&gt; buildTargetInfoObject(const InspectorTarget&amp; target)
 98 {
<span class="line-modified"> 99     return Protocol::Target::TargetInfo::create()</span>
100         .setTargetId(target.identifier())
101         .setType(targetTypeToProtocolType(target.type()))
102         .release();





103 }
104 
105 void InspectorTargetAgent::targetCreated(InspectorTarget&amp; target)
106 {
107     auto addResult = m_targets.set(target.identifier(), &amp;target);
108     ASSERT_UNUSED(addResult, addResult.isNewEntry);
109 
110     if (!m_isConnected)
111         return;
112 
<span class="line-modified">113     target.connect(frontendChannel());</span>


114 
115     m_frontendDispatcher-&gt;targetCreated(buildTargetInfoObject(target));
116 }
117 
118 void InspectorTargetAgent::targetDestroyed(InspectorTarget&amp; target)
119 {
120     m_targets.remove(target.identifier());
121 
122     if (!m_isConnected)
123         return;
124 
<span class="line-removed">125     target.disconnect(frontendChannel());</span>
<span class="line-removed">126 </span>
127     m_frontendDispatcher-&gt;targetDestroyed(target.identifier());
128 }
129 
<span class="line-modified">130 void InspectorTargetAgent::connectToTargets()</span>
131 {
<span class="line-modified">132     auto&amp; channel = frontendChannel();</span>








133 







134     for (InspectorTarget* target : m_targets.values()) {
<span class="line-modified">135         target-&gt;connect(channel);</span>
136         m_frontendDispatcher-&gt;targetCreated(buildTargetInfoObject(*target));
137     }
138 }
139 
140 void InspectorTargetAgent::disconnectFromTargets()
141 {
<span class="line-removed">142     auto&amp; channel = frontendChannel();</span>
<span class="line-removed">143 </span>
144     for (InspectorTarget* target : m_targets.values())
<span class="line-modified">145         target-&gt;disconnect(channel);</span>
146 }
147 
148 } // namespace Inspector
</pre>
</td>
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorTargetAgent.h&quot;
 28 
 29 #include &quot;InspectorTarget.h&quot;
 30 
 31 namespace Inspector {
 32 
 33 InspectorTargetAgent::InspectorTargetAgent(FrontendRouter&amp; frontendRouter, BackendDispatcher&amp; backendDispatcher)
 34     : InspectorAgentBase(&quot;Target&quot;_s)
<span class="line-added"> 35     , m_router(frontendRouter)</span>
 36     , m_frontendDispatcher(makeUnique&lt;TargetFrontendDispatcher&gt;(frontendRouter))
 37     , m_backendDispatcher(TargetBackendDispatcher::create(backendDispatcher, this))
 38 {
 39 }
 40 
 41 InspectorTargetAgent::~InspectorTargetAgent() = default;
 42 
 43 void InspectorTargetAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
 44 {
 45     m_isConnected = true;
 46 
 47     connectToTargets();
 48 }
 49 
 50 void InspectorTargetAgent::willDestroyFrontendAndBackend(DisconnectReason)
 51 {
 52     disconnectFromTargets();
 53 
 54     m_isConnected = false;
<span class="line-added"> 55     m_shouldPauseOnStart = false;</span>
 56 }
 57 
<span class="line-modified"> 58 void InspectorTargetAgent::setPauseOnStart(ErrorString&amp;, bool pauseOnStart)</span>
 59 {
<span class="line-modified"> 60     m_shouldPauseOnStart = pauseOnStart;</span>
<span class="line-modified"> 61 }</span>
<span class="line-added"> 62 </span>
<span class="line-added"> 63 void InspectorTargetAgent::resume(ErrorString&amp; errorString, const String&amp; targetId)</span>
<span class="line-added"> 64 {</span>
<span class="line-added"> 65     auto* target = m_targets.get(targetId);</span>
<span class="line-added"> 66     if (!target) {</span>
<span class="line-added"> 67         errorString = &quot;Missing target for given targetId&quot;_s;</span>
<span class="line-added"> 68         return;</span>
<span class="line-added"> 69     }</span>
<span class="line-added"> 70 </span>
<span class="line-added"> 71     if (!target-&gt;isPaused()) {</span>
<span class="line-added"> 72         errorString = &quot;Target for given targetId is not paused&quot;_s;</span>
<span class="line-added"> 73         return;</span>
<span class="line-added"> 74     }</span>
<span class="line-added"> 75 </span>
<span class="line-added"> 76     target-&gt;resume();</span>
 77 }
 78 
 79 void InspectorTargetAgent::sendMessageToTarget(ErrorString&amp; errorString, const String&amp; targetId, const String&amp; message)
 80 {
 81     InspectorTarget* target = m_targets.get(targetId);
 82     if (!target) {
 83         errorString = &quot;Missing target for given targetId&quot;_s;
 84         return;
 85     }
 86 
 87     target-&gt;sendMessageToTargetBackend(message);
 88 }
 89 
 90 void InspectorTargetAgent::sendMessageFromTargetToFrontend(const String&amp; targetId, const String&amp; message)
 91 {
 92     ASSERT_WITH_MESSAGE(m_targets.get(targetId), &quot;Sending a message from an untracked target to the frontend.&quot;);
 93 
 94     m_frontendDispatcher-&gt;dispatchMessageFromTarget(targetId, message);
 95 }
 96 
 97 static Protocol::Target::TargetInfo::Type targetTypeToProtocolType(InspectorTargetType type)
 98 {
 99     switch (type) {


100     case InspectorTargetType::Page:
101         return Protocol::Target::TargetInfo::Type::Page;
102     case InspectorTargetType::DedicatedWorker:
103         return Protocol::Target::TargetInfo::Type::Worker;
104     case InspectorTargetType::ServiceWorker:
105         return Protocol::Target::TargetInfo::Type::ServiceWorker;
106     }
107 
108     ASSERT_NOT_REACHED();
<span class="line-modified">109     return Protocol::Target::TargetInfo::Type::Page;</span>
110 }
111 
112 static Ref&lt;Protocol::Target::TargetInfo&gt; buildTargetInfoObject(const InspectorTarget&amp; target)
113 {
<span class="line-modified">114     auto result = Protocol::Target::TargetInfo::create()</span>
115         .setTargetId(target.identifier())
116         .setType(targetTypeToProtocolType(target.type()))
117         .release();
<span class="line-added">118     if (target.isProvisional())</span>
<span class="line-added">119         result-&gt;setIsProvisional(true);</span>
<span class="line-added">120     if (target.isPaused())</span>
<span class="line-added">121         result-&gt;setIsPaused(true);</span>
<span class="line-added">122     return result;</span>
123 }
124 
125 void InspectorTargetAgent::targetCreated(InspectorTarget&amp; target)
126 {
127     auto addResult = m_targets.set(target.identifier(), &amp;target);
128     ASSERT_UNUSED(addResult, addResult.isNewEntry);
129 
130     if (!m_isConnected)
131         return;
132 
<span class="line-modified">133     if (m_shouldPauseOnStart)</span>
<span class="line-added">134         target.pause();</span>
<span class="line-added">135     target.connect(connectionType());</span>
136 
137     m_frontendDispatcher-&gt;targetCreated(buildTargetInfoObject(target));
138 }
139 
140 void InspectorTargetAgent::targetDestroyed(InspectorTarget&amp; target)
141 {
142     m_targets.remove(target.identifier());
143 
144     if (!m_isConnected)
145         return;
146 


147     m_frontendDispatcher-&gt;targetDestroyed(target.identifier());
148 }
149 
<span class="line-modified">150 void InspectorTargetAgent::didCommitProvisionalTarget(const String&amp; oldTargetID, const String&amp; committedTargetID)</span>
151 {
<span class="line-modified">152     if (!m_isConnected)</span>
<span class="line-added">153         return;</span>
<span class="line-added">154 </span>
<span class="line-added">155     auto* target = m_targets.get(committedTargetID);</span>
<span class="line-added">156     if (!target)</span>
<span class="line-added">157         return;</span>
<span class="line-added">158 </span>
<span class="line-added">159     m_frontendDispatcher-&gt;didCommitProvisionalTarget(oldTargetID, committedTargetID);</span>
<span class="line-added">160 }</span>
161 
<span class="line-added">162 FrontendChannel::ConnectionType InspectorTargetAgent::connectionType() const</span>
<span class="line-added">163 {</span>
<span class="line-added">164     return m_router.hasLocalFrontend() ? Inspector::FrontendChannel::ConnectionType::Local : Inspector::FrontendChannel::ConnectionType::Remote;</span>
<span class="line-added">165 }</span>
<span class="line-added">166 </span>
<span class="line-added">167 void InspectorTargetAgent::connectToTargets()</span>
<span class="line-added">168 {</span>
169     for (InspectorTarget* target : m_targets.values()) {
<span class="line-modified">170         target-&gt;connect(connectionType());</span>
171         m_frontendDispatcher-&gt;targetCreated(buildTargetInfoObject(*target));
172     }
173 }
174 
175 void InspectorTargetAgent::disconnectFromTargets()
176 {


177     for (InspectorTarget* target : m_targets.values())
<span class="line-modified">178         target-&gt;disconnect();</span>
179 }
180 
181 } // namespace Inspector
</pre>
</td>
</tr>
</table>
<center><a href="InspectorScriptProfilerAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorTargetAgent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/LayoutUnit.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2012, Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions are
  6  * met:
  7  *
  8  *     * Redistributions of source code must retain the above copyright
  9  * notice, this list of conditions and the following disclaimer.
 10  *     * Redistributions in binary form must reproduce the above
 11  * copyright notice, this list of conditions and the following disclaimer
 12  * in the documentation and/or other materials provided with the
 13  * distribution.
 14  *     * Neither the name of Google Inc. nor the names of its
 15  * contributors may be used to endorse or promote products derived from
 16  * this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 19  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 20  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 21  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 22  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 23  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 24  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 25  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 26  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 28  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 29  */
 30 
 31 #pragma once
 32 
 33 #include &lt;limits.h&gt;
 34 #include &lt;limits&gt;
 35 #include &lt;math.h&gt;
 36 #include &lt;stdlib.h&gt;
 37 #include &lt;wtf/MathExtras.h&gt;
 38 #include &lt;wtf/SaturatedArithmetic.h&gt;
<a name="1" id="anc1"></a>
 39 
 40 namespace WTF {
 41 class TextStream;
 42 }
 43 
 44 namespace WebCore {
 45 
 46 #ifdef NDEBUG
 47 
 48 #define REPORT_OVERFLOW(doesOverflow) ((void)0)
 49 
 50 #else
 51 
 52 #define REPORT_OVERFLOW(doesOverflow) do \
 53     if (!(doesOverflow)) { \
 54         WTFReportError(__FILE__, __LINE__, WTF_PRETTY_FUNCTION, &quot;!(%s)&quot;, #doesOverflow); \
 55     } \
 56 while (0)
 57 
 58 #endif
 59 
 60 static const int kFixedPointDenominator = 64;
 61 const int intMaxForLayoutUnit = INT_MAX / kFixedPointDenominator;
 62 const int intMinForLayoutUnit = INT_MIN / kFixedPointDenominator;
 63 
 64 class LayoutUnit {
 65 public:
 66     LayoutUnit() : m_value(0) { }
 67     LayoutUnit(int value) { setValue(value); }
 68     LayoutUnit(unsigned short value) { setValue(value); }
 69     LayoutUnit(unsigned value) { setValue(value); }
 70     explicit LayoutUnit(unsigned long value)
 71     {
 72         m_value = clampTo&lt;int&gt;(value * kFixedPointDenominator);
 73     }
 74     explicit LayoutUnit(unsigned long long value)
 75     {
 76         m_value = clampTo&lt;int&gt;(value * kFixedPointDenominator);
 77     }
 78     explicit LayoutUnit(float value)
 79     {
 80         m_value = clampToInteger(value * kFixedPointDenominator);
 81     }
 82     explicit LayoutUnit(double value)
 83     {
 84         m_value = clampToInteger(value * kFixedPointDenominator);
 85     }
 86 
 87     LayoutUnit&amp; operator=(const LayoutUnit&amp; other) = default;
 88     LayoutUnit&amp; operator=(const float&amp; other) { return *this = LayoutUnit(other); }
 89 
 90     static LayoutUnit fromFloatCeil(float value)
 91     {
 92         LayoutUnit v;
 93         v.m_value = clampToInteger(ceilf(value * kFixedPointDenominator));
 94         return v;
 95     }
 96 
 97     static LayoutUnit fromFloatFloor(float value)
 98     {
 99         LayoutUnit v;
100         v.m_value = clampToInteger(floorf(value * kFixedPointDenominator));
101         return v;
102     }
103 
104     static LayoutUnit fromFloatRound(float value)
105     {
106         if (value &gt;= 0)
107             return clamp(value + epsilon() / 2.0f);
108         return clamp(value - epsilon() / 2.0f);
109     }
110 
111     int toInt() const { return m_value / kFixedPointDenominator; }
112     float toFloat() const { return static_cast&lt;float&gt;(m_value) / kFixedPointDenominator; }
113     double toDouble() const { return static_cast&lt;double&gt;(m_value) / kFixedPointDenominator; }
114     unsigned toUnsigned() const { REPORT_OVERFLOW(m_value &gt;= 0); return toInt(); }
115 
116     operator int() const { return toInt(); }
117     operator float() const { return toFloat(); }
118     operator double() const { return toDouble(); }
119     explicit operator bool() const { return m_value; }
120 
121     LayoutUnit&amp; operator++()
122     {
123         m_value += kFixedPointDenominator;
124         return *this;
125     }
126 
127     inline int rawValue() const { return m_value; }
128     inline void setRawValue(int value) { m_value = value; }
129     void setRawValue(long long value)
130     {
131         REPORT_OVERFLOW(value &gt; std::numeric_limits&lt;int&gt;::min() &amp;&amp; value &lt; std::numeric_limits&lt;int&gt;::max());
132         m_value = static_cast&lt;int&gt;(value);
133     }
134 
135     LayoutUnit abs() const
136     {
137         LayoutUnit returnValue;
138         returnValue.setRawValue(::abs(m_value));
139         return returnValue;
140     }
141     int ceil() const
142     {
143         if (UNLIKELY(m_value &gt;= INT_MAX - kFixedPointDenominator + 1))
144             return intMaxForLayoutUnit;
145         if (m_value &gt;= 0)
146             return (m_value + kFixedPointDenominator - 1) / kFixedPointDenominator;
147         return toInt();
148     }
149 
150     int round() const
151     {
152         if (m_value &gt; 0)
153             return saturatedAddition(rawValue(), kFixedPointDenominator / 2) / kFixedPointDenominator;
154         return saturatedSubtraction(rawValue(), (kFixedPointDenominator / 2) - 1) / kFixedPointDenominator;
155     }
156 
157     int floor() const
158     {
159         if (UNLIKELY(m_value &lt;= INT_MIN + kFixedPointDenominator - 1))
160             return intMinForLayoutUnit;
161         if (m_value &gt;= 0)
162             return toInt();
163         return (m_value - kFixedPointDenominator + 1) / kFixedPointDenominator;
164     }
165 
166     float ceilToFloat() const
167     {
168         float floatValue = toFloat();
169         if (static_cast&lt;int&gt;(floatValue * kFixedPointDenominator) == m_value)
170             return floatValue;
171         if (floatValue &gt; 0)
172             return nextafterf(floatValue, std::numeric_limits&lt;float&gt;::max());
173         return nextafterf(floatValue, std::numeric_limits&lt;float&gt;::min());
174     }
175 
176     LayoutUnit fraction() const
177     {
178         // Add the fraction to the size (as opposed to the full location) to avoid overflows.
179         // Compute fraction using the mod operator to preserve the sign of the value as it may affect rounding.
180         LayoutUnit fraction;
181         fraction.setRawValue(rawValue() % kFixedPointDenominator);
182         return fraction;
183     }
184 
185     bool mightBeSaturated() const
186     {
187         return rawValue() == std::numeric_limits&lt;int&gt;::max()
188             || rawValue() == std::numeric_limits&lt;int&gt;::min();
189     }
190 
191     static float epsilon() { return 1.0f / kFixedPointDenominator; }
192 
193     static const LayoutUnit max()
194     {
195         LayoutUnit m;
196         m.m_value = std::numeric_limits&lt;int&gt;::max();
197         return m;
198     }
199     static const LayoutUnit min()
200     {
201         LayoutUnit m;
202         m.m_value = std::numeric_limits&lt;int&gt;::min();
203         return m;
204     }
205 
206     // Versions of max/min that are slightly smaller/larger than max/min() to allow for roinding without overflowing.
207     static const LayoutUnit nearlyMax()
208     {
209         LayoutUnit m;
210         m.m_value = std::numeric_limits&lt;int&gt;::max() - kFixedPointDenominator / 2;
211         return m;
212     }
213     static const LayoutUnit nearlyMin()
214     {
215         LayoutUnit m;
216         m.m_value = std::numeric_limits&lt;int&gt;::min() + kFixedPointDenominator / 2;
217         return m;
218     }
219 
220     static LayoutUnit clamp(double value)
221     {
222         return clampTo&lt;LayoutUnit&gt;(value, LayoutUnit::min(), LayoutUnit::max());
223     }
224 
225 private:
226     static bool isInBounds(int value)
227     {
228         return ::abs(value) &lt;= std::numeric_limits&lt;int&gt;::max() / kFixedPointDenominator;
229     }
230     static bool isInBounds(unsigned value)
231     {
232         return value &lt;= static_cast&lt;unsigned&gt;(std::numeric_limits&lt;int&gt;::max()) / kFixedPointDenominator;
233     }
234     static bool isInBounds(double value)
235     {
236         return ::fabs(value) &lt;= std::numeric_limits&lt;int&gt;::max() / kFixedPointDenominator;
237     }
238 
239     inline void setValue(int value)
240     {
241         if (value &gt; intMaxForLayoutUnit)
242             m_value = std::numeric_limits&lt;int&gt;::max();
243         else if (value &lt; intMinForLayoutUnit)
244             m_value = std::numeric_limits&lt;int&gt;::min();
245         else
246             m_value = value * kFixedPointDenominator;
247     }
248     inline void setValue(unsigned value)
249     {
250         if (value &gt;= static_cast&lt;unsigned&gt;(intMaxForLayoutUnit))
251             m_value = std::numeric_limits&lt;int&gt;::max();
252         else
253             m_value = value * kFixedPointDenominator;
254     }
255 
256     int m_value;
257 };
258 
259 inline bool operator&lt;=(const LayoutUnit&amp; a, const LayoutUnit&amp; b)
260 {
261     return a.rawValue() &lt;= b.rawValue();
262 }
263 
264 inline bool operator&lt;=(const LayoutUnit&amp; a, float b)
265 {
266     return a.toFloat() &lt;= b;
267 }
268 
269 inline bool operator&lt;=(const LayoutUnit&amp; a, int b)
270 {
271     return a &lt;= LayoutUnit(b);
272 }
273 
274 inline bool operator&lt;=(const float a, const LayoutUnit&amp; b)
275 {
276     return a &lt;= b.toFloat();
277 }
278 
279 inline bool operator&lt;=(const int a, const LayoutUnit&amp; b)
280 {
281     return LayoutUnit(a) &lt;= b;
282 }
283 
284 inline bool operator&gt;=(const LayoutUnit&amp; a, const LayoutUnit&amp; b)
285 {
286     return a.rawValue() &gt;= b.rawValue();
287 }
288 
289 inline bool operator&gt;=(const LayoutUnit&amp; a, int b)
290 {
291     return a &gt;= LayoutUnit(b);
292 }
293 
294 inline bool operator&gt;=(const float a, const LayoutUnit&amp; b)
295 {
296     return a &gt;= b.toFloat();
297 }
298 
299 inline bool operator&gt;=(const LayoutUnit&amp; a, float b)
300 {
301     return a.toFloat() &gt;= b;
302 }
303 
304 inline bool operator&gt;=(const int a, const LayoutUnit&amp; b)
305 {
306     return LayoutUnit(a) &gt;= b;
307 }
308 
309 inline bool operator&lt;(const LayoutUnit&amp; a, const LayoutUnit&amp; b)
310 {
311     return a.rawValue() &lt; b.rawValue();
312 }
313 
314 inline bool operator&lt;(const LayoutUnit&amp; a, int b)
315 {
316     return a &lt; LayoutUnit(b);
317 }
318 
319 inline bool operator&lt;(const LayoutUnit&amp; a, float b)
320 {
321     return a.toFloat() &lt; b;
322 }
323 
324 inline bool operator&lt;(const LayoutUnit&amp; a, double b)
325 {
326     return a.toDouble() &lt; b;
327 }
328 
329 inline bool operator&lt;(const int a, const LayoutUnit&amp; b)
330 {
331     return LayoutUnit(a) &lt; b;
332 }
333 
334 inline bool operator&lt;(const float a, const LayoutUnit&amp; b)
335 {
336     return a &lt; b.toFloat();
337 }
338 
339 inline bool operator&gt;(const LayoutUnit&amp; a, const LayoutUnit&amp; b)
340 {
341     return a.rawValue() &gt; b.rawValue();
342 }
343 
344 inline bool operator&gt;(const LayoutUnit&amp; a, double b)
345 {
346     return a.toDouble() &gt; b;
347 }
348 
349 inline bool operator&gt;(const LayoutUnit&amp; a, float b)
350 {
351     return a.toFloat() &gt; b;
352 }
353 
354 inline bool operator&gt;(const LayoutUnit&amp; a, int b)
355 {
356     return a &gt; LayoutUnit(b);
357 }
358 
359 inline bool operator&gt;(const int a, const LayoutUnit&amp; b)
360 {
361     return LayoutUnit(a) &gt; b;
362 }
363 
364 inline bool operator&gt;(const float a, const LayoutUnit&amp; b)
365 {
366     return a &gt; b.toFloat();
367 }
368 
369 inline bool operator&gt;(const double a, const LayoutUnit&amp; b)
370 {
371     return a &gt; b.toDouble();
372 }
373 
374 inline bool operator!=(const LayoutUnit&amp; a, const LayoutUnit&amp; b)
375 {
376     return a.rawValue() != b.rawValue();
377 }
378 
379 inline bool operator!=(const LayoutUnit&amp; a, float b)
380 {
381     return a != LayoutUnit(b);
382 }
383 
384 inline bool operator!=(const int a, const LayoutUnit&amp; b)
385 {
386     return LayoutUnit(a) != b;
387 }
388 
389 inline bool operator!=(const LayoutUnit&amp; a, int b)
390 {
391     return a != LayoutUnit(b);
392 }
393 
394 inline bool operator==(const LayoutUnit&amp; a, const LayoutUnit&amp; b)
395 {
396     return a.rawValue() == b.rawValue();
397 }
398 
399 inline bool operator==(const LayoutUnit&amp; a, int b)
400 {
401     return a == LayoutUnit(b);
402 }
403 
404 inline bool operator==(const int a, const LayoutUnit&amp; b)
405 {
406     return LayoutUnit(a) == b;
407 }
408 
409 inline bool operator==(const LayoutUnit&amp; a, float b)
410 {
411     return a.toFloat() == b;
412 }
413 
414 inline bool operator==(const float a, const LayoutUnit&amp; b)
415 {
416     return a == b.toFloat();
417 }
418 
419 // For multiplication that&#39;s prone to overflow, this bounds it to LayoutUnit::max() and ::min()
420 inline LayoutUnit boundedMultiply(const LayoutUnit&amp; a, const LayoutUnit&amp; b)
421 {
422     int64_t result = static_cast&lt;int64_t&gt;(a.rawValue()) * static_cast&lt;int64_t&gt;(b.rawValue()) / kFixedPointDenominator;
423     int32_t high = static_cast&lt;int32_t&gt;(result &gt;&gt; 32);
424     int32_t low = static_cast&lt;int32_t&gt;(result);
425     uint32_t saturated = (static_cast&lt;uint32_t&gt;(a.rawValue() ^ b.rawValue()) &gt;&gt; 31) + std::numeric_limits&lt;int&gt;::max();
426     // If the higher 32 bits does not match the lower 32 with sign extension the operation overflowed.
427     if (high != low &gt;&gt; 31)
428         result = saturated;
429 
430     LayoutUnit returnVal;
431     returnVal.setRawValue(static_cast&lt;int&gt;(result));
432     return returnVal;
433 }
434 
435 inline LayoutUnit operator*(const LayoutUnit&amp; a, const LayoutUnit&amp; b)
436 {
437     return boundedMultiply(a, b);
438 }
439 
440 inline double operator*(const LayoutUnit&amp; a, double b)
441 {
442     return a.toDouble() * b;
443 }
444 
445 inline float operator*(const LayoutUnit&amp; a, float b)
446 {
447     return a.toFloat() * b;
448 }
449 
450 inline LayoutUnit operator*(const LayoutUnit&amp; a, int b)
451 {
452     return a * LayoutUnit(b);
453 }
454 
455 inline LayoutUnit operator*(const LayoutUnit&amp; a, unsigned short b)
456 {
457     return a * LayoutUnit(b);
458 }
459 
460 inline LayoutUnit operator*(const LayoutUnit&amp; a, unsigned b)
461 {
462     return a * LayoutUnit(b);
463 }
464 
465 inline LayoutUnit operator*(const LayoutUnit&amp; a, unsigned long b)
466 {
467     return a * LayoutUnit(b);
468 }
469 
470 inline LayoutUnit operator*(const LayoutUnit&amp; a, unsigned long long b)
471 {
472     return a * LayoutUnit(b);
473 }
474 
475 inline LayoutUnit operator*(unsigned short a, const LayoutUnit&amp; b)
476 {
477     return LayoutUnit(a) * b;
478 }
479 
480 inline LayoutUnit operator*(unsigned a, const LayoutUnit&amp; b)
481 {
482     return LayoutUnit(a) * b;
483 }
484 
485 inline LayoutUnit operator*(unsigned long a, const LayoutUnit&amp; b)
486 {
487     return LayoutUnit(a) * b;
488 }
489 
490 inline LayoutUnit operator*(unsigned long long a, const LayoutUnit&amp; b)
491 {
492     return LayoutUnit(a) * b;
493 }
494 
495 inline LayoutUnit operator*(const int a, const LayoutUnit&amp; b)
496 {
497     return LayoutUnit(a) * b;
498 }
499 
500 inline float operator*(const float a, const LayoutUnit&amp; b)
501 {
502     return a * b.toFloat();
503 }
504 
505 inline double operator*(const double a, const LayoutUnit&amp; b)
506 {
507     return a * b.toDouble();
508 }
509 
510 inline LayoutUnit operator/(const LayoutUnit&amp; a, const LayoutUnit&amp; b)
511 {
512     LayoutUnit returnVal;
513     long long rawVal = static_cast&lt;long long&gt;(kFixedPointDenominator) * a.rawValue() / b.rawValue();
514     returnVal.setRawValue(clampTo&lt;int&gt;(rawVal));
515     return returnVal;
516 }
517 
518 inline float operator/(const LayoutUnit&amp; a, float b)
519 {
520     return a.toFloat() / b;
521 }
522 
523 inline double operator/(const LayoutUnit&amp; a, double b)
524 {
525     return a.toDouble() / b;
526 }
527 
528 inline LayoutUnit operator/(const LayoutUnit&amp; a, int b)
529 {
530     return a / LayoutUnit(b);
531 }
532 
533 inline LayoutUnit operator/(const LayoutUnit&amp; a, unsigned short b)
534 {
535     return a / LayoutUnit(b);
536 }
537 
538 inline LayoutUnit operator/(const LayoutUnit&amp; a, unsigned b)
539 {
540     return a / LayoutUnit(b);
541 }
542 
543 inline LayoutUnit operator/(const LayoutUnit&amp; a, unsigned long b)
544 {
545     return a / LayoutUnit(b);
546 }
547 
548 inline LayoutUnit operator/(const LayoutUnit&amp; a, unsigned long long b)
549 {
550     return a / LayoutUnit(b);
551 }
552 
553 inline float operator/(const float a, const LayoutUnit&amp; b)
554 {
555     return a / b.toFloat();
556 }
557 
558 inline double operator/(const double a, const LayoutUnit&amp; b)
559 {
560     return a / b.toDouble();
561 }
562 
563 inline LayoutUnit operator/(const int a, const LayoutUnit&amp; b)
564 {
565     return LayoutUnit(a) / b;
566 }
567 
568 inline LayoutUnit operator/(unsigned short a, const LayoutUnit&amp; b)
569 {
570     return LayoutUnit(a) / b;
571 }
572 
573 inline LayoutUnit operator/(unsigned a, const LayoutUnit&amp; b)
574 {
575     return LayoutUnit(a) / b;
576 }
577 
578 inline LayoutUnit operator/(unsigned long a, const LayoutUnit&amp; b)
579 {
580     return LayoutUnit(a) / b;
581 }
582 
583 inline LayoutUnit operator/(unsigned long long a, const LayoutUnit&amp; b)
584 {
585     return LayoutUnit(a) / b;
586 }
587 
588 inline LayoutUnit operator+(const LayoutUnit&amp; a, const LayoutUnit&amp; b)
589 {
590     LayoutUnit returnVal;
591     returnVal.setRawValue(saturatedAddition(a.rawValue(), b.rawValue()));
592     return returnVal;
593 }
594 
595 inline LayoutUnit operator+(const LayoutUnit&amp; a, int b)
596 {
597     return a + LayoutUnit(b);
598 }
599 
600 inline float operator+(const LayoutUnit&amp; a, float b)
601 {
602     return a.toFloat() + b;
603 }
604 
605 inline double operator+(const LayoutUnit&amp; a, double b)
606 {
607     return a.toDouble() + b;
608 }
609 
610 inline LayoutUnit operator+(const int a, const LayoutUnit&amp; b)
611 {
612     return LayoutUnit(a) + b;
613 }
614 
615 inline float operator+(const float a, const LayoutUnit&amp; b)
616 {
617     return a + b.toFloat();
618 }
619 
620 inline double operator+(const double a, const LayoutUnit&amp; b)
621 {
622     return a + b.toDouble();
623 }
624 
625 inline LayoutUnit operator-(const LayoutUnit&amp; a, const LayoutUnit&amp; b)
626 {
627     LayoutUnit returnVal;
628     returnVal.setRawValue(saturatedSubtraction(a.rawValue(), b.rawValue()));
629     return returnVal;
630 }
631 
632 inline LayoutUnit operator-(const LayoutUnit&amp; a, int b)
633 {
634     return a - LayoutUnit(b);
635 }
636 
637 inline LayoutUnit operator-(const LayoutUnit&amp; a, unsigned b)
638 {
639     return a - LayoutUnit(b);
640 }
641 
642 inline float operator-(const LayoutUnit&amp; a, float b)
643 {
644     return a.toFloat() - b;
645 }
646 
647 inline LayoutUnit operator-(const int a, const LayoutUnit&amp; b)
648 {
649     return LayoutUnit(a) - b;
650 }
651 
652 inline float operator-(const float a, const LayoutUnit&amp; b)
653 {
654     return a - b.toFloat();
655 }
656 
657 inline LayoutUnit operator-(const LayoutUnit&amp; a)
658 {
659     LayoutUnit returnVal;
660     returnVal.setRawValue(-a.rawValue());
661     return returnVal;
662 }
663 
664 // For returning the remainder after a division with integer results.
665 inline LayoutUnit intMod(const LayoutUnit&amp; a, const LayoutUnit&amp; b)
666 {
667     // This calculates the modulo so that: a = static_cast&lt;int&gt;(a / b) * b + intMod(a, b).
668     LayoutUnit returnVal;
669     returnVal.setRawValue(a.rawValue() % b.rawValue());
670     return returnVal;
671 }
672 
673 inline LayoutUnit operator%(const LayoutUnit&amp; a, const LayoutUnit&amp; b)
674 {
675     // This calculates the modulo so that: a = (a / b) * b + a % b.
676     LayoutUnit returnVal;
677     long long rawVal = (static_cast&lt;long long&gt;(kFixedPointDenominator) * a.rawValue()) % b.rawValue();
678     returnVal.setRawValue(rawVal / kFixedPointDenominator);
679     return returnVal;
680 }
681 
682 inline LayoutUnit operator%(const LayoutUnit&amp; a, int b)
683 {
684     return a % LayoutUnit(b);
685 }
686 
687 inline LayoutUnit operator%(int a, const LayoutUnit&amp; b)
688 {
689     return LayoutUnit(a) % b;
690 }
691 
692 inline LayoutUnit&amp; operator+=(LayoutUnit&amp; a, const LayoutUnit&amp; b)
693 {
694     a.setRawValue(saturatedAddition(a.rawValue(), b.rawValue()));
695     return a;
696 }
697 
698 inline LayoutUnit&amp; operator+=(LayoutUnit&amp; a, int b)
699 {
700     a = a + b;
701     return a;
702 }
703 
704 inline LayoutUnit&amp; operator+=(LayoutUnit&amp; a, float b)
705 {
706     a = a + b;
707     return a;
708 }
709 
710 inline float&amp; operator+=(float&amp; a, const LayoutUnit&amp; b)
711 {
712     a = a + b;
713     return a;
714 }
715 
716 inline LayoutUnit&amp; operator-=(LayoutUnit&amp; a, int b)
717 {
718     a = a - b;
719     return a;
720 }
721 
722 inline LayoutUnit&amp; operator-=(LayoutUnit&amp; a, const LayoutUnit&amp; b)
723 {
724     a.setRawValue(saturatedSubtraction(a.rawValue(), b.rawValue()));
725     return a;
726 }
727 
728 inline LayoutUnit&amp; operator-=(LayoutUnit&amp; a, float b)
729 {
730     a = a - b;
731     return a;
732 }
733 
734 inline float&amp; operator-=(float&amp; a, const LayoutUnit&amp; b)
735 {
736     a = a - b;
737     return a;
738 }
739 
740 inline LayoutUnit&amp; operator*=(LayoutUnit&amp; a, const LayoutUnit&amp; b)
741 {
742     a = a * b;
743     return a;
744 }
745 // operator*=(LayoutUnit&amp; a, int b) is supported by the operator above plus LayoutUnit(int).
746 
747 inline LayoutUnit&amp; operator*=(LayoutUnit&amp; a, float b)
748 {
749     a = a * b;
750     return a;
751 }
752 
753 inline float&amp; operator*=(float&amp; a, const LayoutUnit&amp; b)
754 {
755     a = a * b;
756     return a;
757 }
758 
759 inline LayoutUnit&amp; operator/=(LayoutUnit&amp; a, const LayoutUnit&amp; b)
760 {
761     a = a / b;
762     return a;
763 }
764 // operator/=(LayoutUnit&amp; a, int b) is supported by the operator above plus LayoutUnit(int).
765 
766 inline LayoutUnit&amp; operator/=(LayoutUnit&amp; a, float b)
767 {
768     a = a / b;
769     return a;
770 }
771 
772 inline float&amp; operator/=(float&amp; a, const LayoutUnit&amp; b)
773 {
774     a = a / b;
775     return a;
776 }
777 
778 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const LayoutUnit&amp;);
779 
780 inline int roundToInt(LayoutUnit value)
781 {
782     return value.round();
783 }
784 
785 inline int floorToInt(LayoutUnit value)
786 {
787     return value.floor();
788 }
789 
790 inline float roundToDevicePixel(LayoutUnit value, float pixelSnappingFactor, bool needsDirectionalRounding = false)
791 {
792     double valueToRound = value.toDouble();
793     if (needsDirectionalRounding)
794         valueToRound -= LayoutUnit::epsilon() / (2 * kFixedPointDenominator);
795 
796     if (valueToRound &gt;= 0)
797         return round(valueToRound * pixelSnappingFactor) / pixelSnappingFactor;
798 
799     // This adjusts directional rounding on negative halfway values. It produces the same direction for both negative and positive values.
800     // Instead of rounding negative halfway cases away from zero, we translate them to positive values before rounding.
801     // It helps snapping relative negative coordinates to the same position as if they were positive absolute coordinates.
802     unsigned translateOrigin = -value.rawValue();
803     return (round((valueToRound + translateOrigin) * pixelSnappingFactor) / pixelSnappingFactor) - translateOrigin;
804 }
805 
806 inline float floorToDevicePixel(LayoutUnit value, float pixelSnappingFactor)
807 {
808     return floorf((value.rawValue() * pixelSnappingFactor) / kFixedPointDenominator) / pixelSnappingFactor;
809 }
810 
811 inline float ceilToDevicePixel(LayoutUnit value, float pixelSnappingFactor)
812 {
813     return ceilf((value.rawValue() * pixelSnappingFactor) / kFixedPointDenominator) / pixelSnappingFactor;
814 }
815 
816 inline int roundToInt(float value) { return roundToInt(LayoutUnit(value)); }
817 inline float roundToDevicePixel(float value, float pixelSnappingFactor, bool needsDirectionalRounding = false) { return roundToDevicePixel(LayoutUnit(value), pixelSnappingFactor, needsDirectionalRounding); }
818 inline float floorToDevicePixel(float value, float pixelSnappingFactor) { return floorToDevicePixel(LayoutUnit(value), pixelSnappingFactor); }
819 inline float ceilToDevicePixel(float value, float pixelSnappingFactor) { return ceilToDevicePixel(LayoutUnit(value), pixelSnappingFactor); }
820 
821 inline LayoutUnit absoluteValue(const LayoutUnit&amp; value)
822 {
823     return value.abs();
824 }
825 
826 inline bool isIntegerValue(const LayoutUnit value)
827 {
828     return value.toInt() == value;
829 }
830 
831 inline namespace StringLiterals {
832 
833 inline LayoutUnit operator&quot;&quot; _lu(unsigned long long value)
834 {
835     return LayoutUnit(value);
836 }
837 
838 }
839 
840 } // namespace WebCore
<a name="2" id="anc2"></a>












<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
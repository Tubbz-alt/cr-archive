<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/shared/IDBObjectStoreInfo.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;IDBObjectStoreInfo.h&quot;
 28 #include &lt;wtf/text/StringBuilder.h&gt;
 29 
 30 #if ENABLE(INDEXED_DATABASE)
 31 
 32 namespace WebCore {
 33 
 34 IDBObjectStoreInfo::IDBObjectStoreInfo()
 35 {
 36 }
 37 
 38 IDBObjectStoreInfo::IDBObjectStoreInfo(uint64_t identifier, const String&amp; name, Optional&lt;IDBKeyPath&gt;&amp;&amp; keyPath, bool autoIncrement)
 39     : m_identifier(identifier)
 40     , m_name(name)
 41     , m_keyPath(WTFMove(keyPath))
 42     , m_autoIncrement(autoIncrement)
 43 {
 44 }
 45 
<a name="1" id="anc1"></a><span class="line-modified"> 46 IDBIndexInfo IDBObjectStoreInfo::createNewIndex(uint64_t indexID, const String&amp; name, IDBKeyPath&amp;&amp; keyPath, bool unique, bool multiEntry)</span>
 47 {
<a name="2" id="anc2"></a><span class="line-modified"> 48     IDBIndexInfo info(indexID, m_identifier, name, WTFMove(keyPath), unique, multiEntry);</span>
 49     m_indexMap.set(info.identifier(), info);
 50     return info;
 51 }
 52 
 53 void IDBObjectStoreInfo::addExistingIndex(const IDBIndexInfo&amp; info)
 54 {
 55     ASSERT(!m_indexMap.contains(info.identifier()));
 56 
<a name="3" id="anc3"></a>


 57     m_indexMap.set(info.identifier(), info);
 58 }
 59 
 60 bool IDBObjectStoreInfo::hasIndex(const String&amp; name) const
 61 {
 62     for (auto&amp; index : m_indexMap.values()) {
 63         if (index.name() == name)
 64             return true;
 65     }
 66 
 67     return false;
 68 }
 69 
 70 bool IDBObjectStoreInfo::hasIndex(uint64_t indexIdentifier) const
 71 {
 72     return m_indexMap.contains(indexIdentifier);
 73 }
 74 
 75 IDBIndexInfo* IDBObjectStoreInfo::infoForExistingIndex(const String&amp; name)
 76 {
 77     for (auto&amp; index : m_indexMap.values()) {
 78         if (index.name() == name)
 79             return &amp;index;
 80     }
 81 
 82     return nullptr;
 83 }
 84 
 85 IDBIndexInfo* IDBObjectStoreInfo::infoForExistingIndex(uint64_t identifier)
 86 {
 87     auto iterator = m_indexMap.find(identifier);
 88     if (iterator == m_indexMap.end())
 89         return nullptr;
 90 
 91     return &amp;iterator-&gt;value;
 92 }
 93 
 94 IDBObjectStoreInfo IDBObjectStoreInfo::isolatedCopy() const
 95 {
 96     IDBObjectStoreInfo result = { m_identifier, m_name.isolatedCopy(), WebCore::isolatedCopy(m_keyPath), m_autoIncrement };
 97 
<a name="4" id="anc4"></a><span class="line-modified"> 98     for (auto&amp; iterator : m_indexMap)</span>
 99         result.m_indexMap.set(iterator.key, iterator.value.isolatedCopy());
<a name="5" id="anc5"></a>




100 
101     return result;
102 }
103 
104 Vector&lt;String&gt; IDBObjectStoreInfo::indexNames() const
105 {
106     Vector&lt;String&gt; names;
107     names.reserveCapacity(m_indexMap.size());
108     for (auto&amp; index : m_indexMap.values())
109         names.uncheckedAppend(index.name());
110 
111     return names;
112 }
113 
114 void IDBObjectStoreInfo::deleteIndex(const String&amp; indexName)
115 {
116     auto* info = infoForExistingIndex(indexName);
117     if (!info)
118         return;
119 
120     m_indexMap.remove(info-&gt;identifier());
121 }
122 
123 void IDBObjectStoreInfo::deleteIndex(uint64_t indexIdentifier)
124 {
125     m_indexMap.remove(indexIdentifier);
126 }
127 
128 #if !LOG_DISABLED
129 
130 String IDBObjectStoreInfo::loggingString(int indent) const
131 {
132     StringBuilder builder;
133     for (int i = 0; i &lt; indent; ++i)
134         builder.append(&#39; &#39;);
135     builder.append(&quot;Object store: &quot;, m_name, m_identifier);
136     for (auto index : m_indexMap.values())
137         builder.append(index.loggingString(indent + 1), &#39;\n&#39;);
138     return builder.toString();
139 }
140 
141 String IDBObjectStoreInfo::condensedLoggingString() const
142 {
143     return makeString(&quot;&lt;OS: &quot;, m_name, &quot; (&quot;, m_identifier, &quot;)&gt;&quot;);
144 }
145 
146 #endif
147 
148 } // namespace WebCore
149 
150 #endif // ENABLE(INDEXED_DATABASE)
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RegistrationDatabase.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWServer.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 41,20 ***</span>
  #include &quot;ServiceWorkerClientType.h&quot;
  #include &quot;ServiceWorkerContextData.h&quot;
  #include &quot;ServiceWorkerFetchResult.h&quot;
  #include &quot;ServiceWorkerJobData.h&quot;
  #include &lt;wtf/CompletionHandler.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/text/WTFString.h&gt;
  
  namespace WebCore {
  
  static Seconds terminationDelay { 10_s };
  
<span class="line-modified">! SWServer::Connection::Connection(SWServer&amp; server)</span>
      : m_server(server)
<span class="line-modified">!     , m_identifier(SWServerConnectionIdentifier::generate())</span>
  {
  }
  
  HashSet&lt;SWServer*&gt;&amp; SWServer::allServers()
  {
<span class="line-new-header">--- 41,21 ---</span>
  #include &quot;ServiceWorkerClientType.h&quot;
  #include &quot;ServiceWorkerContextData.h&quot;
  #include &quot;ServiceWorkerFetchResult.h&quot;
  #include &quot;ServiceWorkerJobData.h&quot;
  #include &lt;wtf/CompletionHandler.h&gt;
<span class="line-added">+ #include &lt;wtf/MemoryPressureHandler.h&gt;</span>
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/text/WTFString.h&gt;
  
  namespace WebCore {
  
  static Seconds terminationDelay { 10_s };
  
<span class="line-modified">! SWServer::Connection::Connection(SWServer&amp; server, Identifier identifier)</span>
      : m_server(server)
<span class="line-modified">!     , m_identifier(identifier)</span>
  {
  }
  
  HashSet&lt;SWServer*&gt;&amp; SWServer::allServers()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 67,10 ***</span>
<span class="line-new-header">--- 68,13 ---</span>
      // Destroy the remaining connections before the SWServer gets destroyed since they have a raw pointer
      // to the server and since they try to unregister clients from the server in their destructor.
      auto connections = WTFMove(m_connections);
      connections.clear();
  
<span class="line-added">+     for (auto&amp; callback : std::exchange(m_importCompletedCallbacks, { }))</span>
<span class="line-added">+         callback();</span>
<span class="line-added">+ </span>
      Vector&lt;SWServerWorker*&gt; runningWorkers;
      for (auto&amp; worker : m_runningOrTerminatingWorkers.values()) {
          if (worker-&gt;isRunning())
              runningWorkers.append(worker.ptr());
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 109,17 ***</span>
      return iterator-&gt;value.userAgent;
  }
  
  SWServerWorker* SWServer::activeWorkerFromRegistrationID(ServiceWorkerRegistrationIdentifier identifier)
  {
<span class="line-modified">!     auto* registration = m_registrationsByID.get(identifier);</span>
      return registration ? registration-&gt;activeWorker() : nullptr;
  }
  
  SWServerRegistration* SWServer::getRegistration(const ServiceWorkerRegistrationKey&amp; registrationKey)
  {
<span class="line-modified">!     return m_registrations.get(registrationKey);</span>
  }
  
  void SWServer::registrationStoreImportComplete()
  {
      ASSERT(!m_importCompleted);
<span class="line-new-header">--- 113,17 ---</span>
      return iterator-&gt;value.userAgent;
  }
  
  SWServerWorker* SWServer::activeWorkerFromRegistrationID(ServiceWorkerRegistrationIdentifier identifier)
  {
<span class="line-modified">!     auto* registration = m_registrations.get(identifier);</span>
      return registration ? registration-&gt;activeWorker() : nullptr;
  }
  
  SWServerRegistration* SWServer::getRegistration(const ServiceWorkerRegistrationKey&amp; registrationKey)
  {
<span class="line-modified">!     return m_scopeToRegistrationMap.get(registrationKey).get();</span>
  }
  
  void SWServer::registrationStoreImportComplete()
  {
      ASSERT(!m_importCompleted);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 129,22 ***</span>
      auto clearCallbacks = WTFMove(m_clearCompletionCallbacks);
      for (auto&amp; callback : clearCallbacks)
          callback();
  
      performGetOriginsWithRegistrationsCallbacks();
  }
  
  void SWServer::registrationStoreDatabaseFailedToOpen()
  {
      if (!m_importCompleted)
          registrationStoreImportComplete();
  }
  
  void SWServer::addRegistrationFromStore(ServiceWorkerContextData&amp;&amp; data)
  {
      // Pages should not have been able to make a new registration to this key while the import was still taking place.
<span class="line-modified">!     ASSERT(!m_registrations.contains(data.registration.key));</span>
  
      auto registration = makeUnique&lt;SWServerRegistration&gt;(*this, data.registration.key, data.registration.updateViaCache, data.registration.scopeURL, data.scriptURL);
      registration-&gt;setLastUpdateTime(data.registration.lastUpdateTime);
      auto registrationPtr = registration.get();
      addRegistration(WTFMove(registration));
<span class="line-new-header">--- 133,32 ---</span>
      auto clearCallbacks = WTFMove(m_clearCompletionCallbacks);
      for (auto&amp; callback : clearCallbacks)
          callback();
  
      performGetOriginsWithRegistrationsCallbacks();
<span class="line-added">+ </span>
<span class="line-added">+     for (auto&amp; callback : std::exchange(m_importCompletedCallbacks, { }))</span>
<span class="line-added">+         callback();</span>
  }
  
<span class="line-added">+ void SWServer::whenImportIsCompleted(CompletionHandler&lt;void()&gt;&amp;&amp; callback)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(!m_importCompleted);</span>
<span class="line-added">+     m_importCompletedCallbacks.append(WTFMove(callback));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ </span>
  void SWServer::registrationStoreDatabaseFailedToOpen()
  {
      if (!m_importCompleted)
          registrationStoreImportComplete();
  }
  
  void SWServer::addRegistrationFromStore(ServiceWorkerContextData&amp;&amp; data)
  {
      // Pages should not have been able to make a new registration to this key while the import was still taking place.
<span class="line-modified">!     ASSERT(!m_scopeToRegistrationMap.contains(data.registration.key));</span>
  
      auto registration = makeUnique&lt;SWServerRegistration&gt;(*this, data.registration.key, data.registration.updateViaCache, data.registration.scopeURL, data.scriptURL);
      registration-&gt;setLastUpdateTime(data.registration.lastUpdateTime);
      auto registrationPtr = registration.get();
      addRegistration(WTFMove(registration));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 154,40 ***</span>
      worker-&gt;setState(ServiceWorkerState::Activated);
  }
  
  void SWServer::addRegistration(std::unique_ptr&lt;SWServerRegistration&gt;&amp;&amp; registration)
  {
<span class="line-modified">!     auto key = registration-&gt;key();</span>
<span class="line-modified">!     auto* registrationPtr = registration.get();</span>
<span class="line-modified">!     auto addResult1 = m_registrations.add(key, WTFMove(registration));</span>
      ASSERT_UNUSED(addResult1, addResult1.isNewEntry);
<span class="line-removed">- </span>
<span class="line-removed">-     auto addResult2 = m_registrationsByID.add(registrationPtr-&gt;identifier(), registrationPtr);</span>
<span class="line-removed">-     ASSERT_UNUSED(addResult2, addResult2.isNewEntry);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_originStore-&gt;add(key.topOrigin());</span>
  }
  
<span class="line-modified">! void SWServer::removeRegistration(const ServiceWorkerRegistrationKey&amp; key)</span>
  {
<span class="line-modified">!     auto topOrigin = key.topOrigin();</span>
<span class="line-removed">-     auto registration = m_registrations.take(key);</span>
      ASSERT(registration);
<span class="line-removed">-     bool wasRemoved = m_registrationsByID.remove(registration-&gt;identifier());</span>
<span class="line-removed">-     ASSERT_UNUSED(wasRemoved, wasRemoved);</span>
  
<span class="line-modified">!     m_originStore-&gt;remove(topOrigin);</span>
      if (m_registrationStore)
<span class="line-modified">!         m_registrationStore-&gt;removeRegistration(key);</span>
  }
  
  Vector&lt;ServiceWorkerRegistrationData&gt; SWServer::getRegistrations(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
  {
      Vector&lt;SWServerRegistration*&gt; matchingRegistrations;
<span class="line-modified">!     for (auto&amp; item : m_registrations) {</span>
<span class="line-modified">!         if (!item.value-&gt;isUninstalling() &amp;&amp; item.key.originIsMatching(topOrigin, clientURL))</span>
<span class="line-modified">!             matchingRegistrations.append(item.value.get());</span>
      }
      // The specification mandates that registrations are returned in the insertion order.
      std::sort(matchingRegistrations.begin(), matchingRegistrations.end(), [](auto&amp; a, auto&amp; b) {
          return a-&gt;creationTime() &lt; b-&gt;creationTime();
      });
<span class="line-new-header">--- 168,42 ---</span>
      worker-&gt;setState(ServiceWorkerState::Activated);
  }
  
  void SWServer::addRegistration(std::unique_ptr&lt;SWServerRegistration&gt;&amp;&amp; registration)
  {
<span class="line-modified">!     m_originStore-&gt;add(registration-&gt;key().topOrigin());</span>
<span class="line-modified">!     auto registrationID = registration-&gt;identifier();</span>
<span class="line-modified">!     ASSERT(!m_scopeToRegistrationMap.contains(registration-&gt;key()));</span>
<span class="line-added">+     m_scopeToRegistrationMap.set(registration-&gt;key(), makeWeakPtr(*registration));</span>
<span class="line-added">+     auto addResult1 = m_registrations.add(registrationID, WTFMove(registration));</span>
      ASSERT_UNUSED(addResult1, addResult1.isNewEntry);
  }
  
<span class="line-modified">! void SWServer::removeRegistration(ServiceWorkerRegistrationIdentifier registrationID)</span>
  {
<span class="line-modified">!     auto registration = m_registrations.take(registrationID);</span>
      ASSERT(registration);
  
<span class="line-modified">!     auto it = m_scopeToRegistrationMap.find(registration-&gt;key());</span>
<span class="line-added">+     if (it != m_scopeToRegistrationMap.end() &amp;&amp; it-&gt;value == registration.get())</span>
<span class="line-added">+         m_scopeToRegistrationMap.remove(it);</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_originStore-&gt;remove(registration-&gt;key().topOrigin());</span>
      if (m_registrationStore)
<span class="line-modified">!         m_registrationStore-&gt;removeRegistration(registration-&gt;key());</span>
  }
  
  Vector&lt;ServiceWorkerRegistrationData&gt; SWServer::getRegistrations(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
  {
      Vector&lt;SWServerRegistration*&gt; matchingRegistrations;
<span class="line-modified">!     for (auto&amp; item : m_scopeToRegistrationMap) {</span>
<span class="line-modified">!         if (item.key.originIsMatching(topOrigin, clientURL)) {</span>
<span class="line-modified">!             auto* registration = item.value.get();</span>
<span class="line-added">+             ASSERT(registration);</span>
<span class="line-added">+             if (registration)</span>
<span class="line-added">+                 matchingRegistrations.append(registration);</span>
<span class="line-added">+         }</span>
      }
      // The specification mandates that registrations are returned in the insertion order.
      std::sort(matchingRegistrations.begin(), matchingRegistrations.end(), [](auto&amp; a, auto&amp; b) {
          return a-&gt;creationTime() &lt; b-&gt;creationTime();
      });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 209,11 ***</span>
      }
  
      m_jobQueues.clear();
      while (!m_registrations.isEmpty())
          m_registrations.begin()-&gt;value-&gt;clear();
<span class="line-removed">-     ASSERT(m_registrationsByID.isEmpty());</span>
      m_pendingContextDatas.clear();
      m_originStore-&gt;clearAll();
      if (m_registrationStore)
          m_registrationStore-&gt;clearAll(WTFMove(completionHandler));
  }
<span class="line-new-header">--- 225,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 246,13 ***</span>
      m_jobQueues.removeIf([&amp;](auto&amp; keyAndValue) {
          return keyAndValue.key.relatesToOrigin(securityOrigin);
      });
  
      Vector&lt;SWServerRegistration*&gt; registrationsToRemove;
<span class="line-modified">!     for (auto&amp; keyAndValue : m_registrations) {</span>
<span class="line-modified">!         if (keyAndValue.key.relatesToOrigin(securityOrigin))</span>
<span class="line-modified">!             registrationsToRemove.append(keyAndValue.value.get());</span>
      }
  
      for (auto&amp; contextDatas : m_pendingContextDatas.values()) {
          contextDatas.removeAllMatching([&amp;](auto&amp; contextData) {
              return contextData.registration.key.relatesToOrigin(securityOrigin);
<span class="line-new-header">--- 261,13 ---</span>
      m_jobQueues.removeIf([&amp;](auto&amp; keyAndValue) {
          return keyAndValue.key.relatesToOrigin(securityOrigin);
      });
  
      Vector&lt;SWServerRegistration*&gt; registrationsToRemove;
<span class="line-modified">!     for (auto&amp; registration : m_registrations.values()) {</span>
<span class="line-modified">!         if (registration-&gt;key().relatesToOrigin(securityOrigin))</span>
<span class="line-modified">!             registrationsToRemove.append(registration.get());</span>
      }
  
      for (auto&amp; contextDatas : m_pendingContextDatas.values()) {
          contextDatas.removeAllMatching([&amp;](auto&amp; contextData) {
              return contextData.registration.key.relatesToOrigin(securityOrigin);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 272,16 ***</span>
          m_registrationStore-&gt;flushChanges(WTFMove(completionHandler));
  }
  
  void SWServer::Connection::finishFetchingScriptInServer(const ServiceWorkerFetchResult&amp; result)
  {
<span class="line-modified">!     m_server.scriptFetchFinished(*this, result);</span>
  }
  
  void SWServer::Connection::didResolveRegistrationPromise(const ServiceWorkerRegistrationKey&amp; key)
  {
<span class="line-modified">!     m_server.didResolveRegistrationPromise(*this, key);</span>
  }
  
  void SWServer::Connection::addServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
  {
      m_server.addClientServiceWorkerRegistration(*this, identifier);
<span class="line-new-header">--- 287,16 ---</span>
          m_registrationStore-&gt;flushChanges(WTFMove(completionHandler));
  }
  
  void SWServer::Connection::finishFetchingScriptInServer(const ServiceWorkerFetchResult&amp; result)
  {
<span class="line-modified">!     m_server.scriptFetchFinished(result);</span>
  }
  
  void SWServer::Connection::didResolveRegistrationPromise(const ServiceWorkerRegistrationKey&amp; key)
  {
<span class="line-modified">!     m_server.didResolveRegistrationPromise(this, key);</span>
  }
  
  void SWServer::Connection::addServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
  {
      m_server.addClientServiceWorkerRegistration(*this, identifier);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 296,15 ***</span>
  {
      if (auto* worker = m_server.workerByID(identifier))
          m_server.syncTerminateWorker(*worker);
  }
  
<span class="line-modified">! SWServer::SWServer(UniqueRef&lt;SWOriginStore&gt;&amp;&amp; originStore, String&amp;&amp; registrationDatabaseDirectory, PAL::SessionID sessionID)</span>
      : m_originStore(WTFMove(originStore))
      , m_sessionID(sessionID)
  {
<span class="line-modified">!     ASSERT(!registrationDatabaseDirectory.isEmpty() || m_sessionID.isEphemeral());</span>
      if (!m_sessionID.isEphemeral())
          m_registrationStore = makeUnique&lt;RegistrationStore&gt;(*this, WTFMove(registrationDatabaseDirectory));
      else
          registrationStoreImportComplete();
  
<span class="line-new-header">--- 311,18 ---</span>
  {
      if (auto* worker = m_server.workerByID(identifier))
          m_server.syncTerminateWorker(*worker);
  }
  
<span class="line-modified">! SWServer::SWServer(UniqueRef&lt;SWOriginStore&gt;&amp;&amp; originStore, bool processTerminationDelayEnabled, String&amp;&amp; registrationDatabaseDirectory, PAL::SessionID sessionID, SoftUpdateCallback&amp;&amp; softUpdateCallback, CreateContextConnectionCallback&amp;&amp; callback)</span>
      : m_originStore(WTFMove(originStore))
      , m_sessionID(sessionID)
<span class="line-added">+     , m_isProcessTerminationDelayEnabled(processTerminationDelayEnabled)</span>
<span class="line-added">+     , m_createContextConnectionCallback(WTFMove(callback))</span>
<span class="line-added">+     , m_softUpdateCallback(WTFMove(softUpdateCallback))</span>
  {
<span class="line-modified">!     RELEASE_LOG_IF(registrationDatabaseDirectory.isEmpty() &amp;&amp; !m_sessionID.isEphemeral(), ServiceWorker, &quot;No path to store the service worker registrations&quot;);</span>
      if (!m_sessionID.isEphemeral())
          m_registrationStore = makeUnique&lt;RegistrationStore&gt;(*this, WTFMove(registrationDatabaseDirectory));
      else
          registrationStoreImportComplete();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 313,20 ***</span>
  }
  
  // https://w3c.github.io/ServiceWorker/#schedule-job-algorithm
  void SWServer::scheduleJob(ServiceWorkerJobData&amp;&amp; jobData)
  {
<span class="line-modified">!     ASSERT(m_connections.contains(jobData.connectionIdentifier()));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // FIXME: Per the spec, check if this job is equivalent to the last job on the queue.</span>
<span class="line-removed">-     // If it is, stack it along with that job.</span>
  
      auto&amp; jobQueue = *m_jobQueues.ensure(jobData.registrationKey(), [this, &amp;jobData] {
          return makeUnique&lt;SWServerJobQueue&gt;(*this, jobData.registrationKey());
      }).iterator-&gt;value;
  
<span class="line-modified">!     jobQueue.enqueueJob(jobData);</span>
      if (jobQueue.size() == 1)
          jobQueue.runNextJob();
  }
  
  void SWServer::rejectJob(const ServiceWorkerJobData&amp; jobData, const ExceptionData&amp; exceptionData)
<span class="line-new-header">--- 331,30 ---</span>
  }
  
  // https://w3c.github.io/ServiceWorker/#schedule-job-algorithm
  void SWServer::scheduleJob(ServiceWorkerJobData&amp;&amp; jobData)
  {
<span class="line-modified">!     ASSERT(m_connections.contains(jobData.connectionIdentifier()) || jobData.connectionIdentifier() == Process::identifier());</span>
  
      auto&amp; jobQueue = *m_jobQueues.ensure(jobData.registrationKey(), [this, &amp;jobData] {
          return makeUnique&lt;SWServerJobQueue&gt;(*this, jobData.registrationKey());
      }).iterator-&gt;value;
  
<span class="line-modified">!     if (!jobQueue.size()) {</span>
<span class="line-added">+         jobQueue.enqueueJob(WTFMove(jobData));</span>
<span class="line-added">+         jobQueue.runNextJob();</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     auto&amp; lastJob = jobQueue.lastJob();</span>
<span class="line-added">+     if (jobData.isEquivalent(lastJob)) {</span>
<span class="line-added">+         // FIXME: Per the spec, check if this job is equivalent to the last job on the queue.</span>
<span class="line-added">+         // If it is, stack it along with that job. For now, we just make sure to not call soft-update too often.</span>
<span class="line-added">+         if (jobData.type == ServiceWorkerJobType::Update &amp;&amp; jobData.connectionIdentifier() == Process::identifier())</span>
<span class="line-added">+             return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     jobQueue.enqueueJob(WTFMove(jobData));</span>
      if (jobQueue.size() == 1)
          jobQueue.runNextJob();
  }
  
  void SWServer::rejectJob(const ServiceWorkerJobData&amp; jobData, const ExceptionData&amp; exceptionData)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 341,12 ***</span>
  
  void SWServer::resolveRegistrationJob(const ServiceWorkerJobData&amp; jobData, const ServiceWorkerRegistrationData&amp; registrationData, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
  {
      LOG(ServiceWorker, &quot;Resolved ServiceWorker job %s in server with registration %s&quot;, jobData.identifier().loggingString().utf8().data(), registrationData.identifier.loggingString().utf8().data());
      auto* connection = m_connections.get(jobData.connectionIdentifier());
<span class="line-modified">!     if (!connection)</span>
          return;
  
      connection-&gt;resolveRegistrationJobInClient(jobData.identifier().jobIdentifier, registrationData, shouldNotifyWhenResolved);
  }
  
  void SWServer::resolveUnregistrationJob(const ServiceWorkerJobData&amp; jobData, const ServiceWorkerRegistrationKey&amp; registrationKey, bool unregistrationResult)
<span class="line-new-header">--- 369,15 ---</span>
  
  void SWServer::resolveRegistrationJob(const ServiceWorkerJobData&amp; jobData, const ServiceWorkerRegistrationData&amp; registrationData, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
  {
      LOG(ServiceWorker, &quot;Resolved ServiceWorker job %s in server with registration %s&quot;, jobData.identifier().loggingString().utf8().data(), registrationData.identifier.loggingString().utf8().data());
      auto* connection = m_connections.get(jobData.connectionIdentifier());
<span class="line-modified">!     if (!connection) {</span>
<span class="line-added">+         if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes &amp;&amp; jobData.connectionIdentifier() == Process::identifier())</span>
<span class="line-added">+             didResolveRegistrationPromise(nullptr, registrationData.key);</span>
          return;
<span class="line-added">+     }</span>
  
      connection-&gt;resolveRegistrationJobInClient(jobData.identifier().jobIdentifier, registrationData, shouldNotifyWhenResolved);
  }
  
  void SWServer::resolveUnregistrationJob(const ServiceWorkerJobData&amp; jobData, const ServiceWorkerRegistrationKey&amp; registrationKey, bool unregistrationResult)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 356,30 ***</span>
          return;
  
      connection-&gt;resolveUnregistrationJobInClient(jobData.identifier().jobIdentifier, registrationKey, unregistrationResult);
  }
  
<span class="line-modified">! void SWServer::startScriptFetch(const ServiceWorkerJobData&amp; jobData, FetchOptions::Cache cachePolicy)</span>
  {
      LOG(ServiceWorker, &quot;Server issuing startScriptFetch for current job %s in client&quot;, jobData.identifier().loggingString().utf8().data());
      auto* connection = m_connections.get(jobData.connectionIdentifier());
      ASSERT_WITH_MESSAGE(connection, &quot;If the connection was lost, this job should have been cancelled&quot;);
<span class="line-removed">-     if (connection)</span>
<span class="line-removed">-         connection-&gt;startScriptFetchInClient(jobData.identifier().jobIdentifier, jobData.registrationKey(), cachePolicy);</span>
  }
  
<span class="line-modified">! void SWServer::scriptFetchFinished(Connection&amp; connection, const ServiceWorkerFetchResult&amp; result)</span>
  {
      LOG(ServiceWorker, &quot;Server handling scriptFetchFinished for current job %s in client&quot;, result.jobDataIdentifier.loggingString().utf8().data());
  
<span class="line-modified">!     ASSERT(m_connections.contains(result.jobDataIdentifier.connectionIdentifier));</span>
  
      auto jobQueue = m_jobQueues.get(result.registrationKey);
      if (!jobQueue)
          return;
  
<span class="line-modified">!     jobQueue-&gt;scriptFetchFinished(connection, result);</span>
  }
  
  void SWServer::scriptContextFailedToStart(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker, const String&amp; message)
  {
      if (!jobDataIdentifier)
<span class="line-new-header">--- 387,67 ---</span>
          return;
  
      connection-&gt;resolveUnregistrationJobInClient(jobData.identifier().jobIdentifier, registrationKey, unregistrationResult);
  }
  
<span class="line-modified">! URL static inline originURL(const SecurityOrigin&amp; origin)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     URL url;</span>
<span class="line-added">+     url.setProtocol(origin.protocol());</span>
<span class="line-added">+     url.setHost(origin.host());</span>
<span class="line-added">+     if (origin.port())</span>
<span class="line-added">+         url.setPort(*origin.port());</span>
<span class="line-added">+     return url;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void SWServer::startScriptFetch(const ServiceWorkerJobData&amp; jobData, bool shouldRefreshCache)</span>
  {
      LOG(ServiceWorker, &quot;Server issuing startScriptFetch for current job %s in client&quot;, jobData.identifier().loggingString().utf8().data());
      auto* connection = m_connections.get(jobData.connectionIdentifier());
<span class="line-added">+     if (connection) {</span>
<span class="line-added">+         connection-&gt;startScriptFetchInClient(jobData.identifier().jobIdentifier, jobData.registrationKey(), shouldRefreshCache ? FetchOptions::Cache::NoCache : FetchOptions::Cache::Default);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (jobData.connectionIdentifier() == Process::identifier()) {</span>
<span class="line-added">+         ASSERT(jobData.type == ServiceWorkerJobType::Update);</span>
<span class="line-added">+         // This is a soft-update job, create directly a network load to fetch the script.</span>
<span class="line-added">+         ResourceRequest request { jobData.scriptURL };</span>
<span class="line-added">+ </span>
<span class="line-added">+         auto topOrigin = jobData.topOrigin.securityOrigin();</span>
<span class="line-added">+         auto origin = SecurityOrigin::create(jobData.scriptURL);</span>
<span class="line-added">+ </span>
<span class="line-added">+         request.setDomainForCachePartition(topOrigin-&gt;domainForCachePartition());</span>
<span class="line-added">+         request.setAllowCookies(true);</span>
<span class="line-added">+         request.setFirstPartyForCookies(originURL(topOrigin));</span>
<span class="line-added">+ </span>
<span class="line-added">+         request.setHTTPHeaderField(HTTPHeaderName::Origin, origin-&gt;toString());</span>
<span class="line-added">+         request.setHTTPHeaderField(HTTPHeaderName::ServiceWorker, &quot;script&quot;_s);</span>
<span class="line-added">+         request.setHTTPReferrer(originURL(origin));</span>
<span class="line-added">+         request.setHTTPUserAgent(serviceWorkerClientUserAgent(ClientOrigin { jobData.topOrigin, SecurityOrigin::create(jobData.scriptURL)-&gt;data() }));</span>
<span class="line-added">+         request.setPriority(ResourceLoadPriority::Low);</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_softUpdateCallback(ServiceWorkerJobData { jobData }, shouldRefreshCache, WTFMove(request), [this, weakThis = makeWeakPtr(this)](auto&amp; result) {</span>
<span class="line-added">+             if (!weakThis)</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             scriptFetchFinished(result);</span>
<span class="line-added">+         });</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
      ASSERT_WITH_MESSAGE(connection, &quot;If the connection was lost, this job should have been cancelled&quot;);
  }
  
<span class="line-modified">! void SWServer::scriptFetchFinished(const ServiceWorkerFetchResult&amp; result)</span>
  {
      LOG(ServiceWorker, &quot;Server handling scriptFetchFinished for current job %s in client&quot;, result.jobDataIdentifier.loggingString().utf8().data());
  
<span class="line-modified">!     ASSERT(m_connections.contains(result.jobDataIdentifier.connectionIdentifier) || result.jobDataIdentifier.connectionIdentifier == Process::identifier());</span>
  
      auto jobQueue = m_jobQueues.get(result.registrationKey);
      if (!jobQueue)
          return;
  
<span class="line-modified">!     jobQueue-&gt;scriptFetchFinished(result);</span>
  }
  
  void SWServer::scriptContextFailedToStart(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker, const String&amp; message)
  {
      if (!jobDataIdentifier)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 411,11 ***</span>
  }
  
  void SWServer::terminatePreinstallationWorker(SWServerWorker&amp; worker)
  {
      worker.terminate();
<span class="line-modified">!     auto* registration = getRegistration(worker.registrationKey());</span>
      if (registration &amp;&amp; registration-&gt;preInstallationWorker() == &amp;worker)
          registration-&gt;setPreInstallationWorker(nullptr);
  }
  
  void SWServer::didFinishInstall(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker, bool wasSuccessful)
<span class="line-new-header">--- 479,11 ---</span>
  }
  
  void SWServer::terminatePreinstallationWorker(SWServerWorker&amp; worker)
  {
      worker.terminate();
<span class="line-modified">!     auto* registration = worker.registration();</span>
      if (registration &amp;&amp; registration-&gt;preInstallationWorker() == &amp;worker)
          registration-&gt;setPreInstallationWorker(nullptr);
  }
  
  void SWServer::didFinishInstall(const Optional&lt;ServiceWorkerJobDataIdentifier&gt;&amp; jobDataIdentifier, SWServerWorker&amp; worker, bool wasSuccessful)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 427,18 ***</span>
          RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::didFinishInstall: Successfuly finished SW install for job %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data());
      else
          RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::didFinishInstall: Failed SW install for job %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data());
  
      if (auto* jobQueue = m_jobQueues.get(worker.registrationKey()))
<span class="line-modified">!         jobQueue-&gt;didFinishInstall(*jobDataIdentifier, worker.identifier(), wasSuccessful);</span>
  }
  
  void SWServer::didFinishActivation(SWServerWorker&amp; worker)
  {
      RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::didFinishActivation: Finished activation for service worker %llu&quot;, this, worker.identifier().toUInt64());
  
<span class="line-modified">!     auto* registration = getRegistration(worker.registrationKey());</span>
      if (!registration)
          return;
  
      if (m_registrationStore)
          m_registrationStore-&gt;updateRegistration(worker.contextData());
<span class="line-new-header">--- 495,18 ---</span>
          RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::didFinishInstall: Successfuly finished SW install for job %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data());
      else
          RELEASE_LOG_ERROR(ServiceWorker, &quot;%p - SWServer::didFinishInstall: Failed SW install for job %s&quot;, this, jobDataIdentifier-&gt;loggingString().utf8().data());
  
      if (auto* jobQueue = m_jobQueues.get(worker.registrationKey()))
<span class="line-modified">!         jobQueue-&gt;didFinishInstall(*jobDataIdentifier, worker, wasSuccessful);</span>
  }
  
  void SWServer::didFinishActivation(SWServerWorker&amp; worker)
  {
      RELEASE_LOG(ServiceWorker, &quot;%p - SWServer::didFinishActivation: Finished activation for service worker %llu&quot;, this, worker.identifier().toUInt64());
  
<span class="line-modified">!     auto* registration = worker.registration();</span>
      if (!registration)
          return;
  
      if (m_registrationStore)
          m_registrationStore-&gt;updateRegistration(worker.contextData());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 492,65 ***</span>
          if (!result.isNewEntry) {
              auto previousIdentifier = result.iterator-&gt;value;
              if (previousIdentifier == registration-&gt;identifier())
                  return;
              result.iterator-&gt;value = registration-&gt;identifier();
<span class="line-modified">!             if (auto* controllingRegistration = m_registrationsByID.get(previousIdentifier))</span>
                  controllingRegistration-&gt;removeClientUsingRegistration(clientData.identifier);
          }
          registration-&gt;controlClient(clientData.identifier);
      });
  }
  
<span class="line-modified">! void SWServer::didResolveRegistrationPromise(Connection&amp; connection, const ServiceWorkerRegistrationKey&amp; registrationKey)</span>
  {
<span class="line-modified">!     ASSERT_UNUSED(connection, m_connections.contains(connection.identifier()));</span>
  
      if (auto* jobQueue = m_jobQueues.get(registrationKey))
          jobQueue-&gt;didResolveRegistrationPromise();
  }
  
  void SWServer::addClientServiceWorkerRegistration(Connection&amp; connection, ServiceWorkerRegistrationIdentifier identifier)
  {
<span class="line-modified">!     auto* registration = m_registrationsByID.get(identifier);</span>
      if (!registration) {
          LOG_ERROR(&quot;Request to add client-side ServiceWorkerRegistration to non-existent server-side registration&quot;);
          return;
      }
  
      registration-&gt;addClientServiceWorkerRegistration(connection.identifier());
  }
  
  void SWServer::removeClientServiceWorkerRegistration(Connection&amp; connection, ServiceWorkerRegistrationIdentifier identifier)
  {
<span class="line-modified">!     if (auto* registration = m_registrationsByID.get(identifier))</span>
          registration-&gt;removeClientServiceWorkerRegistration(connection.identifier());
  }
  
<span class="line-modified">! void SWServer::updateWorker(Connection&amp;, const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, SWServerRegistration&amp; registration, const URL&amp; url, const String&amp; script, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicy, const String&amp; referrerPolicy, WorkerType type, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt;&amp;&amp; scriptResourceMap)</span>
  {
<span class="line-modified">!     tryInstallContextData({ jobDataIdentifier, registration.data(), ServiceWorkerIdentifier::generate(), script, contentSecurityPolicy, referrerPolicy, url, type, sessionID(), false, WTFMove(scriptResourceMap) });</span>
  }
  
  void SWServer::tryInstallContextData(ServiceWorkerContextData&amp;&amp; data)
  {
      RegistrableDomain registrableDomain(data.scriptURL);
<span class="line-modified">!     auto* connection = SWServerToContextConnection::connectionForRegistrableDomain(registrableDomain);</span>
      if (!connection) {
<span class="line-modified">!         m_pendingContextDatas.ensure(WTFMove(registrableDomain), [] {</span>
              return Vector&lt;ServiceWorkerContextData&gt; { };
          }).iterator-&gt;value.append(WTFMove(data));
          return;
      }
  
      installContextData(data);
  }
  
<span class="line-modified">! void SWServer::serverToContextConnectionCreated(SWServerToContextConnection&amp; contextConnection)</span>
  {
      for (auto&amp; connection : m_connections.values())
<span class="line-modified">!         connection-&gt;serverToContextConnectionCreated(contextConnection);</span>
  
      auto pendingContextDatas = m_pendingContextDatas.take(contextConnection.registrableDomain());
      for (auto&amp; data : pendingContextDatas)
          installContextData(data);
  
<span class="line-new-header">--- 560,67 ---</span>
          if (!result.isNewEntry) {
              auto previousIdentifier = result.iterator-&gt;value;
              if (previousIdentifier == registration-&gt;identifier())
                  return;
              result.iterator-&gt;value = registration-&gt;identifier();
<span class="line-modified">!             if (auto* controllingRegistration = m_registrations.get(previousIdentifier))</span>
                  controllingRegistration-&gt;removeClientUsingRegistration(clientData.identifier);
          }
          registration-&gt;controlClient(clientData.identifier);
      });
  }
  
<span class="line-modified">! void SWServer::didResolveRegistrationPromise(Connection* connection, const ServiceWorkerRegistrationKey&amp; registrationKey)</span>
  {
<span class="line-modified">!     ASSERT_UNUSED(connection, !connection || m_connections.contains(connection-&gt;identifier()));</span>
  
      if (auto* jobQueue = m_jobQueues.get(registrationKey))
          jobQueue-&gt;didResolveRegistrationPromise();
  }
  
  void SWServer::addClientServiceWorkerRegistration(Connection&amp; connection, ServiceWorkerRegistrationIdentifier identifier)
  {
<span class="line-modified">!     auto* registration = m_registrations.get(identifier);</span>
      if (!registration) {
          LOG_ERROR(&quot;Request to add client-side ServiceWorkerRegistration to non-existent server-side registration&quot;);
          return;
      }
  
      registration-&gt;addClientServiceWorkerRegistration(connection.identifier());
  }
  
  void SWServer::removeClientServiceWorkerRegistration(Connection&amp; connection, ServiceWorkerRegistrationIdentifier identifier)
  {
<span class="line-modified">!     if (auto* registration = m_registrations.get(identifier))</span>
          registration-&gt;removeClientServiceWorkerRegistration(connection.identifier());
  }
  
<span class="line-modified">! void SWServer::updateWorker(const ServiceWorkerJobDataIdentifier&amp; jobDataIdentifier, SWServerRegistration&amp; registration, const URL&amp; url, const String&amp; script, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicy, const String&amp; referrerPolicy, WorkerType type, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt;&amp;&amp; scriptResourceMap)</span>
  {
<span class="line-modified">!     tryInstallContextData({ jobDataIdentifier, registration.data(), ServiceWorkerIdentifier::generate(), script, contentSecurityPolicy, referrerPolicy, url, type, false, WTFMove(scriptResourceMap) });</span>
  }
  
  void SWServer::tryInstallContextData(ServiceWorkerContextData&amp;&amp; data)
  {
      RegistrableDomain registrableDomain(data.scriptURL);
<span class="line-modified">!     auto* connection = contextConnectionForRegistrableDomain(registrableDomain);</span>
      if (!connection) {
<span class="line-modified">!         m_pendingContextDatas.ensure(registrableDomain, [] {</span>
              return Vector&lt;ServiceWorkerContextData&gt; { };
          }).iterator-&gt;value.append(WTFMove(data));
<span class="line-added">+ </span>
<span class="line-added">+         createContextConnection(registrableDomain);</span>
          return;
      }
  
      installContextData(data);
  }
  
<span class="line-modified">! void SWServer::contextConnectionCreated(SWServerToContextConnection&amp; contextConnection)</span>
  {
      for (auto&amp; connection : m_connections.values())
<span class="line-modified">!         connection-&gt;contextConnectionCreated(contextConnection);</span>
  
      auto pendingContextDatas = m_pendingContextDatas.take(contextConnection.registrableDomain());
      for (auto&amp; data : pendingContextDatas)
          installContextData(data);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 571,13 ***</span>
          auto* jobQueue = m_jobQueues.get(data.registration.key);
          if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*data.jobDataIdentifier))
              return;
      }
  
<span class="line-modified">!     auto* registration = m_registrations.get(data.registration.key);</span>
<span class="line-removed">-     RELEASE_ASSERT(registration);</span>
<span class="line-removed">- </span>
      auto worker = SWServerWorker::create(*this, *registration, data.scriptURL, data.script, data.contentSecurityPolicy, String { data.referrerPolicy }, data.workerType, data.serviceWorkerIdentifier, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt; { data.scriptResourceMap });
  
      auto* connection = worker-&gt;contextConnection();
      ASSERT(connection);
  
<span class="line-new-header">--- 641,11 ---</span>
          auto* jobQueue = m_jobQueues.get(data.registration.key);
          if (!jobQueue || !jobQueue-&gt;isCurrentlyProcessingJob(*data.jobDataIdentifier))
              return;
      }
  
<span class="line-modified">!     auto* registration = m_scopeToRegistrationMap.get(data.registration.key).get();</span>
      auto worker = SWServerWorker::create(*this, *registration, data.scriptURL, data.script, data.contentSecurityPolicy, String { data.referrerPolicy }, data.workerType, data.serviceWorkerIdentifier, HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt; { data.scriptResourceMap });
  
      auto* connection = worker-&gt;contextConnection();
      ASSERT(connection);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 585,11 ***</span>
      worker-&gt;setState(SWServerWorker::State::Running);
      auto userAgent = worker-&gt;userAgent();
      auto result = m_runningOrTerminatingWorkers.add(data.serviceWorkerIdentifier, WTFMove(worker));
      ASSERT_UNUSED(result, result.isNewEntry);
  
<span class="line-modified">!     connection-&gt;installServiceWorkerContext(data, m_sessionID, userAgent);</span>
  }
  
  void SWServer::runServiceWorkerIfNecessary(ServiceWorkerIdentifier identifier, RunServiceWorkerCallback&amp;&amp; callback)
  {
      auto* worker = workerByID(identifier);
<span class="line-new-header">--- 653,11 ---</span>
      worker-&gt;setState(SWServerWorker::State::Running);
      auto userAgent = worker-&gt;userAgent();
      auto result = m_runningOrTerminatingWorkers.add(data.serviceWorkerIdentifier, WTFMove(worker));
      ASSERT_UNUSED(result, result.isNewEntry);
  
<span class="line-modified">!     connection-&gt;installServiceWorkerContext(data, userAgent);</span>
  }
  
  void SWServer::runServiceWorkerIfNecessary(ServiceWorkerIdentifier identifier, RunServiceWorkerCallback&amp;&amp; callback)
  {
      auto* worker = workerByID(identifier);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 603,17 ***</span>
<span class="line-new-header">--- 671,24 ---</span>
          ASSERT(contextConnection);
          callback(contextConnection);
          return;
      }
  
<span class="line-added">+     if (worker-&gt;state() == ServiceWorkerState::Redundant) {</span>
<span class="line-added">+         callback(nullptr);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if (!contextConnection) {
          auto&amp; serviceWorkerRunRequestsForOrigin = m_serviceWorkerRunRequests.ensure(worker-&gt;registrableDomain(), [] {
              return HashMap&lt;ServiceWorkerIdentifier, Vector&lt;RunServiceWorkerCallback&gt;&gt; { };
          }).iterator-&gt;value;
          serviceWorkerRunRequestsForOrigin.ensure(identifier, [&amp;] {
              return Vector&lt;RunServiceWorkerCallback&gt; { };
          }).iterator-&gt;value.append(WTFMove(callback));
<span class="line-added">+ </span>
<span class="line-added">+         createContextConnection(worker-&gt;registrableDomain());</span>
          return;
      }
  
      bool success = runServiceWorker(identifier);
      callback(success ? contextConnection : nullptr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 623,24 ***</span>
  {
      auto* worker = workerByID(identifier);
      if (!worker)
          return false;
  
<span class="line-modified">!     // If the registration for a working has been removed then the request to run</span>
      // the worker is moot.
<span class="line-modified">!     if (!getRegistration(worker-&gt;registrationKey()))</span>
          return false;
  
      auto addResult = m_runningOrTerminatingWorkers.add(identifier, *worker);
      ASSERT_UNUSED(addResult, addResult.isNewEntry || worker-&gt;isTerminating());
  
      worker-&gt;setState(SWServerWorker::State::Running);
  
      auto* contextConnection = worker-&gt;contextConnection();
      ASSERT(contextConnection);
  
<span class="line-modified">!     contextConnection-&gt;installServiceWorkerContext(worker-&gt;contextData(), m_sessionID, worker-&gt;userAgent());</span>
  
      return true;
  }
  
  void SWServer::terminateWorker(SWServerWorker&amp; worker)
<span class="line-new-header">--- 698,24 ---</span>
  {
      auto* worker = workerByID(identifier);
      if (!worker)
          return false;
  
<span class="line-modified">!     // If the registration for a worker has been removed then the request to run</span>
      // the worker is moot.
<span class="line-modified">!     if (!worker-&gt;registration())</span>
          return false;
  
      auto addResult = m_runningOrTerminatingWorkers.add(identifier, *worker);
      ASSERT_UNUSED(addResult, addResult.isNewEntry || worker-&gt;isTerminating());
  
      worker-&gt;setState(SWServerWorker::State::Running);
  
      auto* contextConnection = worker-&gt;contextConnection();
      ASSERT(contextConnection);
  
<span class="line-modified">!     contextConnection-&gt;installServiceWorkerContext(worker-&gt;contextData(), worker-&gt;userAgent());</span>
  
      return true;
  }
  
  void SWServer::terminateWorker(SWServerWorker&amp; worker)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 745,28 ***</span>
          jobQueue-&gt;cancelJobsFromConnection(connectionIdentifier);
  }
  
  SWServerRegistration* SWServer::doRegistrationMatching(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
  {
      SWServerRegistration* selectedRegistration = nullptr;
<span class="line-modified">!     for (auto&amp; registration : m_registrations.values()) {</span>
<span class="line-modified">!         if (!registration-&gt;key().isMatching(topOrigin, clientURL))</span>
              continue;
<span class="line-modified">!         if (!selectedRegistration || selectedRegistration-&gt;key().scopeLength() &lt; registration-&gt;key().scopeLength())</span>
<span class="line-modified">!             selectedRegistration = registration.get();</span>
      }
  
<span class="line-modified">!     return (selectedRegistration &amp;&amp; !selectedRegistration-&gt;isUninstalling()) ? selectedRegistration : nullptr;</span>
  }
  
  SWServerRegistration* SWServer::registrationFromServiceWorkerIdentifier(ServiceWorkerIdentifier identifier)
  {
      auto iterator = m_runningOrTerminatingWorkers.find(identifier);
      if (iterator == m_runningOrTerminatingWorkers.end())
          return nullptr;
<span class="line-modified">! </span>
<span class="line-removed">-     return m_registrations.get(iterator-&gt;value-&gt;registrationKey());</span>
  }
  
  void SWServer::registerServiceWorkerClient(ClientOrigin&amp;&amp; clientOrigin, ServiceWorkerClientData&amp;&amp; data, const Optional&lt;ServiceWorkerRegistrationIdentifier&gt;&amp; controllingServiceWorkerRegistrationIdentifier, String&amp;&amp; userAgent)
  {
      auto clientIdentifier = data.identifier;
<span class="line-new-header">--- 820,28 ---</span>
          jobQueue-&gt;cancelJobsFromConnection(connectionIdentifier);
  }
  
  SWServerRegistration* SWServer::doRegistrationMatching(const SecurityOriginData&amp; topOrigin, const URL&amp; clientURL)
  {
<span class="line-added">+     ASSERT(isImportCompleted());</span>
      SWServerRegistration* selectedRegistration = nullptr;
<span class="line-modified">!     for (auto&amp; pair : m_scopeToRegistrationMap) {</span>
<span class="line-modified">!         if (!pair.key.isMatching(topOrigin, clientURL))</span>
              continue;
<span class="line-modified">!         if (!selectedRegistration || selectedRegistration-&gt;key().scopeLength() &lt; pair.key.scopeLength())</span>
<span class="line-modified">!             selectedRegistration = pair.value.get();</span>
      }
  
<span class="line-modified">!     return selectedRegistration;</span>
  }
  
  SWServerRegistration* SWServer::registrationFromServiceWorkerIdentifier(ServiceWorkerIdentifier identifier)
  {
      auto iterator = m_runningOrTerminatingWorkers.find(identifier);
      if (iterator == m_runningOrTerminatingWorkers.end())
          return nullptr;
<span class="line-modified">!     return iterator-&gt;value-&gt;registration();</span>
  }
  
  void SWServer::registerServiceWorkerClient(ClientOrigin&amp;&amp; clientOrigin, ServiceWorkerClientData&amp;&amp; data, const Optional&lt;ServiceWorkerRegistrationIdentifier&gt;&amp; controllingServiceWorkerRegistrationIdentifier, String&amp;&amp; userAgent)
  {
      auto clientIdentifier = data.identifier;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 792,11 ***</span>
      }).iterator-&gt;value.add(clientIdentifier);
  
      if (!controllingServiceWorkerRegistrationIdentifier)
          return;
  
<span class="line-modified">!     auto* controllingRegistration = m_registrationsByID.get(*controllingServiceWorkerRegistrationIdentifier);</span>
      if (!controllingRegistration || !controllingRegistration-&gt;activeWorker())
          return;
  
      controllingRegistration-&gt;addClientUsingRegistration(clientIdentifier);
      ASSERT(!m_clientToControllingRegistration.contains(clientIdentifier));
<span class="line-new-header">--- 867,11 ---</span>
      }).iterator-&gt;value.add(clientIdentifier);
  
      if (!controllingServiceWorkerRegistrationIdentifier)
          return;
  
<span class="line-modified">!     auto* controllingRegistration = m_registrations.get(*controllingServiceWorkerRegistrationIdentifier);</span>
      if (!controllingRegistration || !controllingRegistration-&gt;activeWorker())
          return;
  
      controllingRegistration-&gt;addClientUsingRegistration(clientIdentifier);
      ASSERT(!m_clientToControllingRegistration.contains(clientIdentifier));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 828,17 ***</span>
              }
              for (auto* worker : workersToTerminate)
                  terminateWorker(*worker);
  
              if (!m_clientsByRegistrableDomain.contains(clientRegistrableDomain)) {
<span class="line-modified">!                 if (auto* connection = SWServerToContextConnection::connectionForRegistrableDomain(clientRegistrableDomain))</span>
<span class="line-modified">!                     connection-&gt;connectionMayNoLongerBeNeeded();</span>
              }
  
              m_clientIdentifiersPerOrigin.remove(clientOrigin);
          });
<span class="line-modified">!         iterator-&gt;value.terminateServiceWorkersTimer-&gt;startOneShot(m_shouldDisableServiceWorkerProcessTerminationDelay ? 0_s : terminationDelay);</span>
      }
  
      auto clientsByRegistrableDomainIterator = m_clientsByRegistrableDomain.find(clientRegistrableDomain);
      ASSERT(clientsByRegistrableDomainIterator != m_clientsByRegistrableDomain.end());
      auto&amp; clientsForRegistrableDomain = clientsByRegistrableDomainIterator-&gt;value;
<span class="line-new-header">--- 903,19 ---</span>
              }
              for (auto* worker : workersToTerminate)
                  terminateWorker(*worker);
  
              if (!m_clientsByRegistrableDomain.contains(clientRegistrableDomain)) {
<span class="line-modified">!                 if (auto* connection = contextConnectionForRegistrableDomain(clientRegistrableDomain)) {</span>
<span class="line-modified">!                     removeContextConnection(*connection);</span>
<span class="line-added">+                     connection-&gt;connectionIsNoLongerNeeded();</span>
<span class="line-added">+                 }</span>
              }
  
              m_clientIdentifiersPerOrigin.remove(clientOrigin);
          });
<span class="line-modified">!         iterator-&gt;value.terminateServiceWorkersTimer-&gt;startOneShot(m_isProcessTerminationDelayEnabled &amp;&amp; !MemoryPressureHandler::singleton().isUnderMemoryPressure() ? terminationDelay : 0_s);</span>
      }
  
      auto clientsByRegistrableDomainIterator = m_clientsByRegistrableDomain.find(clientRegistrableDomain);
      ASSERT(clientsByRegistrableDomainIterator != m_clientsByRegistrableDomain.end());
      auto&amp; clientsForRegistrableDomain = clientsByRegistrableDomainIterator-&gt;value;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 848,17 ***</span>
  
      auto registrationIterator = m_clientToControllingRegistration.find(clientIdentifier);
      if (registrationIterator == m_clientToControllingRegistration.end())
          return;
  
<span class="line-modified">!     if (auto* registration = m_registrationsByID.get(registrationIterator-&gt;value))</span>
          registration-&gt;removeClientUsingRegistration(clientIdentifier);
  
      m_clientToControllingRegistration.remove(registrationIterator);
  }
  
<span class="line-modified">! bool SWServer::needsServerToContextConnectionForRegistrableDomain(const RegistrableDomain&amp; registrableDomain) const</span>
  {
      return m_clientsByRegistrableDomain.contains(registrableDomain);
  }
  
  void SWServer::resolveRegistrationReadyRequests(SWServerRegistration&amp; registration)
<span class="line-new-header">--- 925,33 ---</span>
  
      auto registrationIterator = m_clientToControllingRegistration.find(clientIdentifier);
      if (registrationIterator == m_clientToControllingRegistration.end())
          return;
  
<span class="line-modified">!     if (auto* registration = m_registrations.get(registrationIterator-&gt;value))</span>
          registration-&gt;removeClientUsingRegistration(clientIdentifier);
  
      m_clientToControllingRegistration.remove(registrationIterator);
  }
  
<span class="line-modified">! void SWServer::handleLowMemoryWarning()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     // Accelerating the delayed termination of unused service workers due to memory pressure.</span>
<span class="line-added">+     if (m_isProcessTerminationDelayEnabled) {</span>
<span class="line-added">+         for (auto&amp; clients : m_clientIdentifiersPerOrigin.values()) {</span>
<span class="line-added">+             if (clients.terminateServiceWorkersTimer)</span>
<span class="line-added">+                 clients.terminateServiceWorkersTimer-&gt;startOneShot(0_s);</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void SWServer::removeFromScopeToRegistrationMap(const ServiceWorkerRegistrationKey&amp; key)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     m_scopeToRegistrationMap.remove(key);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool SWServer::needsContextConnectionForRegistrableDomain(const RegistrableDomain&amp; registrableDomain) const</span>
  {
      return m_clientsByRegistrableDomain.contains(registrableDomain);
  }
  
  void SWServer::resolveRegistrationReadyRequests(SWServerRegistration&amp; registration)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 913,18 ***</span>
  
      if (m_getOriginsWithRegistrationsCallbacks.isEmpty())
          return;
  
      HashSet&lt;SecurityOriginData&gt; originsWithRegistrations;
<span class="line-modified">!     for (auto&amp; key : m_registrations.keys()) {</span>
          originsWithRegistrations.add(key.topOrigin());
          originsWithRegistrations.add(SecurityOriginData { key.scope().protocol().toString(), key.scope().host().toString(), key.scope().port() });
      }
  
      auto callbacks = WTFMove(m_getOriginsWithRegistrationsCallbacks);
      for (auto&amp; callback : callbacks)
          callback(originsWithRegistrations);
  }
  
  } // namespace WebCore
  
  #endif // ENABLE(SERVICE_WORKER)
<span class="line-new-header">--- 1006,91 ---</span>
  
      if (m_getOriginsWithRegistrationsCallbacks.isEmpty())
          return;
  
      HashSet&lt;SecurityOriginData&gt; originsWithRegistrations;
<span class="line-modified">!     for (auto&amp; key : m_scopeToRegistrationMap.keys()) {</span>
          originsWithRegistrations.add(key.topOrigin());
          originsWithRegistrations.add(SecurityOriginData { key.scope().protocol().toString(), key.scope().host().toString(), key.scope().port() });
      }
  
      auto callbacks = WTFMove(m_getOriginsWithRegistrationsCallbacks);
      for (auto&amp; callback : callbacks)
          callback(originsWithRegistrations);
  }
  
<span class="line-added">+ void SWServer::addContextConnection(SWServerToContextConnection&amp; connection)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     RELEASE_LOG(ServiceWorker, &quot;SWServer::addContextConnection&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(!m_contextConnections.contains(connection.registrableDomain()));</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_contextConnections.add(connection.registrableDomain(), &amp;connection);</span>
<span class="line-added">+ </span>
<span class="line-added">+     contextConnectionCreated(connection);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void SWServer::removeContextConnection(SWServerToContextConnection&amp; connection)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     RELEASE_LOG(ServiceWorker, &quot;SWServer::removeContextConnection&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto&amp; registrableDomain = connection.registrableDomain();</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(m_contextConnections.get(registrableDomain) == &amp;connection);</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_contextConnections.remove(registrableDomain);</span>
<span class="line-added">+     markAllWorkersForRegistrableDomainAsTerminated(registrableDomain);</span>
<span class="line-added">+     if (needsContextConnectionForRegistrableDomain(registrableDomain))</span>
<span class="line-added">+         createContextConnection(registrableDomain);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void SWServer::createContextConnection(const RegistrableDomain&amp; registrableDomain)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(!m_contextConnections.contains(registrableDomain));</span>
<span class="line-added">+     if (m_pendingConnectionDomains.contains(registrableDomain))</span>
<span class="line-added">+         return;</span>
<span class="line-added">+ </span>
<span class="line-added">+     RELEASE_LOG(ServiceWorker, &quot;SWServer::createContextConnection will create a connection&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_pendingConnectionDomains.add(registrableDomain);</span>
<span class="line-added">+     m_createContextConnectionCallback(registrableDomain, [this, weakThis = makeWeakPtr(this), registrableDomain] {</span>
<span class="line-added">+         if (!weakThis)</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
<span class="line-added">+         RELEASE_LOG(ServiceWorker, &quot;SWServer::createContextConnection should now have created a connection&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         ASSERT(m_pendingConnectionDomains.contains(registrableDomain));</span>
<span class="line-added">+         m_pendingConnectionDomains.remove(registrableDomain);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (m_contextConnections.contains(registrableDomain))</span>
<span class="line-added">+             return;</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (needsContextConnectionForRegistrableDomain(registrableDomain))</span>
<span class="line-added">+             createContextConnection(registrableDomain);</span>
<span class="line-added">+     });</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool SWServer::canHandleScheme(StringView scheme) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (scheme.isNull())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     if (!equalLettersIgnoringASCIICase(scheme.substring(0, 4), &quot;http&quot;))</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     if (scheme.length() == 5 &amp;&amp; isASCIIAlphaCaselessEqual(scheme[4], &#39;s&#39;))</span>
<span class="line-added">+         return true;</span>
<span class="line-added">+     return scheme.length() == 4;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // https://w3c.github.io/ServiceWorker/#soft-update</span>
<span class="line-added">+ void SWServer::softUpdate(SWServerRegistration&amp; registration)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ServiceWorkerJobData jobData(Process::identifier(), ServiceWorkerIdentifier::generate());</span>
<span class="line-added">+     jobData.scriptURL = registration.scriptURL();</span>
<span class="line-added">+     jobData.topOrigin = registration.key().topOrigin();</span>
<span class="line-added">+     jobData.scopeURL = registration.scopeURLWithoutFragment();</span>
<span class="line-added">+     jobData.type = ServiceWorkerJobType::Update;</span>
<span class="line-added">+     scheduleJob(WTFMove(jobData));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } // namespace WebCore
  
  #endif // ENABLE(SERVICE_WORKER)
</pre>
<center><a href="RegistrationDatabase.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SWServer.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
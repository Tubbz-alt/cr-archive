<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/PODRedBlackTree.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.
  3  * Copyright (C) 2019-2020 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 17  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 18  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 19  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 22  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 24  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 // A red-black tree, which is a form of a balanced binary tree. It
 28 // supports efficient insertion, deletion and queries of comparable
 29 // elements. The same element may be inserted multiple times. The
 30 // algorithmic complexity of common operations is:
 31 //
 32 //   Insertion: O(lg(n))
 33 //   Deletion:  O(lg(n))
 34 //   Querying:  O(lg(n))
 35 //
 36 // Type T must supply a default constructor, a copy constructor, and
 37 // the &quot;&lt;&quot; and &quot;==&quot; operators.
 38 //
 39 // In debug mode, printing of the data contained in the tree is
 40 // enabled. This makes use of WTF::TextStream.
 41 //
 42 // This red-black tree is designed to be _augmented_; subclasses can
 43 // add additional and summary information to each node to efficiently
 44 // store and index more complex data structures. A concrete example is
 45 // the IntervalTree, which extends each node with a summary statistic
 46 // to efficiently store one-dimensional intervals.
 47 //
 48 // The design of this red-black tree comes from Cormen, Leiserson,
 49 // and Rivest, _Introduction to Algorithms_, MIT Press, 1990.
 50 
 51 #pragma once
 52 
 53 #include &lt;wtf/Assertions.h&gt;
 54 #include &lt;wtf/Noncopyable.h&gt;
 55 
 56 #ifndef NDEBUG
 57 #include &lt;wtf/text/StringBuilder.h&gt;
 58 #include &lt;wtf/text/TextStream.h&gt;
 59 #endif
 60 
 61 // FIXME: The prefix &quot;POD&quot; here isn&#39;t correct; this tree works with non-POD types too.
 62 // FIXME: Extend WTF::RedBlackTree and implement this on top of it rather than keeping two quite similar class templates around.
 63 
 64 namespace WebCore {
 65 
 66 template&lt;typename T, typename NodeUpdaterType&gt; class PODRedBlackTree {
 67     WTF_MAKE_NONCOPYABLE(PODRedBlackTree);
 68 public:
 69     PODRedBlackTree() = default;
 70 
 71     ~PODRedBlackTree()
 72     {
 73         clear();
 74     }
 75 
 76     void clear()
 77     {
 78         if (!m_root)
 79             return;
 80         Node* next;
 81         for (Node* node = treeMinimum(m_root); node; node = next) {
 82             next = treeSuccessorInPostOrder(node);
 83             delete node;
 84         }
 85         m_root = nullptr;
 86     }
 87 
 88     void add(const T&amp; data)
 89     {
 90         add(T { data });
 91     }
 92 
 93     void add(T&amp;&amp; data)
 94     {
 95         insertNode(new Node(WTFMove(data)));
 96     }
 97 
 98     // Returns true if the datum was found in the tree.
 99     bool remove(const T&amp; data)
100     {
101         Node* node = treeSearch(data);
102         if (node) {
103             deleteNode(node);
104             return true;
105         }
106         return false;
107     }
108 
109     bool contains(const T&amp; data) const
110     {
111         return treeSearch(data);
112     }
113 
114     bool isEmpty() const
115     {
116         return !m_root;
117     }
118 
119 #ifndef NDEBUG
120 
121     bool checkInvariants() const
122     {
123         int blackCount;
124         return checkInvariantsFromNode(m_root, blackCount);
125     }
126 
127     // Dumps the tree&#39;s contents to the logging info stream for debugging purposes.
128     void dump() const
129     {
130         dumpSubtree(m_root, 0);
131     }
132 
133     // Turns on or off verbose debugging of the tree, causing many
134     // messages to be logged during insertion and other operations in
135     // debug mode.
136     void setVerboseDebugging(bool verboseDebugging)
137     {
138         m_verboseDebugging = verboseDebugging;
139     }
140 
141 #endif
142 
143 protected:
144     enum Color { Red, Black };
145 
146     class Node {
147         WTF_MAKE_FAST_ALLOCATED;
148         WTF_MAKE_NONCOPYABLE(Node);
149     public:
150         explicit Node(T&amp;&amp; data)
151             : m_data(WTFMove(data))
152         {
153         }
154 
155         Color color() const { return m_color; }
156         void setColor(Color color) { m_color = color; }
157 
158         T&amp; data() { return m_data; }
159 
160         void moveDataFrom(Node&amp; src) { m_data = WTFMove(src.m_data); }
161 
162         Node* left() const { return m_left; }
163         void setLeft(Node* node) { m_left = node; }
164 
165         Node* right() const { return m_right; }
166         void setRight(Node* node) { m_right = node; }
167 
168         Node* parent() const { return m_parent; }
169         void setParent(Node* node) { m_parent = node; }
170 
171     private:
172         Node* m_left { nullptr };
173         Node* m_right { nullptr };
174         Node* m_parent { nullptr };
175         Color m_color { Red };
176         T m_data;
177     };
178 
179     // Returns the root of the tree, which is needed by some subclasses.
180     Node* root() const { return m_root; }
181 
182 private:
183     // The update function is the hook that subclasses should use when
184     // augmenting the red-black tree with additional per-node summary
185     // information. For example, in the case of an interval tree, this
186     // is used to compute the maximum endpoint of the subtree below the
187     // given node based on the values in the left and right children. It
188     // is guaranteed that this will be called in the correct order to
189     // properly update such summary information based only on the values
190     // in the left and right children. The function should return true if
191     // the node&#39;s summary information changed.
192     static bool updateNode(Node&amp; node)
193     {
194         return NodeUpdaterType::update(node);
195     }
196 
197     Node* treeSearch(const T&amp; data) const
198     {
199         for (auto* current = m_root; current; ) {
200             if (current-&gt;data() == data)
201                 return current;
202             if (data &lt; current-&gt;data())
203                 current = current-&gt;left();
204             else
205                 current = current-&gt;right();
206         }
207         return nullptr;
208     }
209 
210     void treeInsert(Node* z)
211     {
212         Node* y = nullptr;
213         Node* x = m_root;
214         while (x) {
215             y = x;
216             if (z-&gt;data() &lt; x-&gt;data())
217                 x = x-&gt;left();
218             else
219                 x = x-&gt;right();
220         }
221         z-&gt;setParent(y);
222         if (!y)
223             m_root = z;
224         else {
225             if (z-&gt;data() &lt; y-&gt;data())
226                 y-&gt;setLeft(z);
227             else
228                 y-&gt;setRight(z);
229         }
230     }
231 
232     // Finds the node following the given one in sequential ordering of
233     // their data, or null if none exists.
234     static Node* treeSuccessor(Node* x)
235     {
236         if (x-&gt;right())
237             return treeMinimum(x-&gt;right());
238         Node* y = x-&gt;parent();
239         while (y &amp;&amp; x == y-&gt;right()) {
240             x = y;
241             y = y-&gt;parent();
242         }
243         return y;
244     }
245 
246     // Finds the minimum element in the sub-tree rooted at the given node.
247     static Node* treeMinimum(Node* x)
248     {
249         while (x-&gt;left())
250             x = x-&gt;left();
251         return x;
252     }
253 
254     static Node* treeSuccessorInPostOrder(Node* x)
255     {
256         Node* y = x-&gt;parent();
257         if (y &amp;&amp; x == y-&gt;left() &amp;&amp; y-&gt;right())
258             return treeMinimum(y-&gt;right());
259         return y;
260     }
261 
262     //----------------------------------------------------------------------
263     // Red-Black tree operations
264     //
265 
266     // Left-rotates the subtree rooted at x.
267     // Returns the new root of the subtree (x&#39;s right child).
268     Node* leftRotate(Node* x)
269     {
270         // Set y.
271         Node* y = x-&gt;right();
272 
273         // Turn y&#39;s left subtree into x&#39;s right subtree.
274         x-&gt;setRight(y-&gt;left());
275         if (y-&gt;left())
276             y-&gt;left()-&gt;setParent(x);
277 
278         // Link x&#39;s parent to y.
279         y-&gt;setParent(x-&gt;parent());
280         if (!x-&gt;parent())
281             m_root = y;
282         else {
283             if (x == x-&gt;parent()-&gt;left())
284                 x-&gt;parent()-&gt;setLeft(y);
285             else
286                 x-&gt;parent()-&gt;setRight(y);
287         }
288 
289         // Put x on y&#39;s left.
290         y-&gt;setLeft(x);
291         x-&gt;setParent(y);
292 
293         // Update nodes lowest to highest.
294         updateNode(*x);
295         updateNode(*y);
296         return y;
297     }
298 
299     static void propagateUpdates(Node* start)
300     {
301         while (start &amp;&amp; updateNode(*start))
302             start = start-&gt;parent();
303     }
304 
305     // Right-rotates the subtree rooted at y.
306     // Returns the new root of the subtree (y&#39;s left child).
307     Node* rightRotate(Node* y)
308     {
309         // Set x.
310         Node* x = y-&gt;left();
311 
312         // Turn x&#39;s right subtree into y&#39;s left subtree.
313         y-&gt;setLeft(x-&gt;right());
314         if (x-&gt;right())
315             x-&gt;right()-&gt;setParent(y);
316 
317         // Link y&#39;s parent to x.
318         x-&gt;setParent(y-&gt;parent());
319         if (!y-&gt;parent())
320             m_root = x;
321         else {
322             if (y == y-&gt;parent()-&gt;left())
323                 y-&gt;parent()-&gt;setLeft(x);
324             else
325                 y-&gt;parent()-&gt;setRight(x);
326         }
327 
328         // Put y on x&#39;s right.
329         x-&gt;setRight(y);
330         y-&gt;setParent(x);
331 
332         // Update nodes lowest to highest.
333         updateNode(*y);
334         updateNode(*x);
335         return x;
336     }
337 
338     // Inserts the given node into the tree.
339     void insertNode(Node* x)
340     {
341         treeInsert(x);
342         x-&gt;setColor(Red);
343         updateNode(*x);
344 
345         logIfVerbose(&quot;  PODRedBlackTree::InsertNode&quot;);
346 
347         // The node from which to start propagating updates upwards.
348         Node* updateStart = x-&gt;parent();
349 
350         while (x != m_root &amp;&amp; x-&gt;parent()-&gt;color() == Red) {
351             if (x-&gt;parent() == x-&gt;parent()-&gt;parent()-&gt;left()) {
352                 Node* y = x-&gt;parent()-&gt;parent()-&gt;right();
353                 if (y &amp;&amp; y-&gt;color() == Red) {
354                     // Case 1
355                     logIfVerbose(&quot;  Case 1/1&quot;);
356                     x-&gt;parent()-&gt;setColor(Black);
357                     y-&gt;setColor(Black);
358                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
359                     updateNode(*x-&gt;parent());
360                     x = x-&gt;parent()-&gt;parent();
361                     updateNode(*x);
362                     updateStart = x-&gt;parent();
363                 } else {
364                     if (x == x-&gt;parent()-&gt;right()) {
365                         logIfVerbose(&quot;  Case 1/2&quot;);
366                         // Case 2
367                         x = x-&gt;parent();
368                         leftRotate(x);
369                     }
370                     // Case 3
371                     logIfVerbose(&quot;  Case 1/3&quot;);
372                     x-&gt;parent()-&gt;setColor(Black);
373                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
374                     Node* newSubTreeRoot = rightRotate(x-&gt;parent()-&gt;parent());
375                     updateStart = newSubTreeRoot-&gt;parent();
376                 }
377             } else {
378                 // Same as &quot;then&quot; clause with &quot;right&quot; and &quot;left&quot; exchanged.
379                 Node* y = x-&gt;parent()-&gt;parent()-&gt;left();
380                 if (y &amp;&amp; y-&gt;color() == Red) {
381                     // Case 1
382                     logIfVerbose(&quot;  Case 2/1&quot;);
383                     x-&gt;parent()-&gt;setColor(Black);
384                     y-&gt;setColor(Black);
385                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
386                     updateNode(*x-&gt;parent());
387                     x = x-&gt;parent()-&gt;parent();
388                     updateNode(*x);
389                     updateStart = x-&gt;parent();
390                 } else {
391                     if (x == x-&gt;parent()-&gt;left()) {
392                         // Case 2
393                         logIfVerbose(&quot;  Case 2/2&quot;);
394                         x = x-&gt;parent();
395                         rightRotate(x);
396                     }
397                     // Case 3
398                     logIfVerbose(&quot;  Case 2/3&quot;);
399                     x-&gt;parent()-&gt;setColor(Black);
400                     x-&gt;parent()-&gt;parent()-&gt;setColor(Red);
401                     Node* newSubTreeRoot = leftRotate(x-&gt;parent()-&gt;parent());
402                     updateStart = newSubTreeRoot-&gt;parent();
403                 }
404             }
405         }
406 
407         propagateUpdates(updateStart);
408 
409         m_root-&gt;setColor(Black);
410     }
411 
412     // Restores the red-black property to the tree after splicing out
413     // a node. Note that x may be null, which is why xParent must be supplied.
414     void deleteFixup(Node* x, Node* xParent)
415     {
416         while (x != m_root &amp;&amp; (!x || x-&gt;color() == Black)) {
417             if (x == xParent-&gt;left()) {
418                 // Note: the text points out that w can not be null.
419                 // The reason is not obvious from simply looking at
420                 // the code; it comes about from the properties of the
421                 // red-black tree.
422                 Node* w = xParent-&gt;right();
423                 ASSERT(w); // x&#39;s sibling should not be null.
424                 if (w-&gt;color() == Red) {
425                     // Case 1
426                     w-&gt;setColor(Black);
427                     xParent-&gt;setColor(Red);
428                     leftRotate(xParent);
429                     w = xParent-&gt;right();
430                 }
431                 if ((!w-&gt;left() || w-&gt;left()-&gt;color() == Black)
432                     &amp;&amp; (!w-&gt;right() || w-&gt;right()-&gt;color() == Black)) {
433                     // Case 2
434                     w-&gt;setColor(Red);
435                     x = xParent;
436                     xParent = x-&gt;parent();
437                 } else {
438                     if (!w-&gt;right() || w-&gt;right()-&gt;color() == Black) {
439                         // Case 3
440                         w-&gt;left()-&gt;setColor(Black);
441                         w-&gt;setColor(Red);
442                         rightRotate(w);
443                         w = xParent-&gt;right();
444                     }
445                     // Case 4
446                     w-&gt;setColor(xParent-&gt;color());
447                     xParent-&gt;setColor(Black);
448                     if (w-&gt;right())
449                         w-&gt;right()-&gt;setColor(Black);
450                     leftRotate(xParent);
451                     x = m_root;
452                     xParent = x-&gt;parent();
453                 }
454             } else {
455                 // Same as &quot;then&quot; clause with &quot;right&quot; and &quot;left&quot;
456                 // exchanged.
457 
458                 // Note: the text points out that w can not be null.
459                 // The reason is not obvious from simply looking at
460                 // the code; it comes about from the properties of the
461                 // red-black tree.
462                 Node* w = xParent-&gt;left();
463                 ASSERT(w); // x&#39;s sibling should not be null.
464                 if (w-&gt;color() == Red) {
465                     // Case 1
466                     w-&gt;setColor(Black);
467                     xParent-&gt;setColor(Red);
468                     rightRotate(xParent);
469                     w = xParent-&gt;left();
470                 }
471                 if ((!w-&gt;right() || w-&gt;right()-&gt;color() == Black)
472                     &amp;&amp; (!w-&gt;left() || w-&gt;left()-&gt;color() == Black)) {
473                     // Case 2
474                     w-&gt;setColor(Red);
475                     x = xParent;
476                     xParent = x-&gt;parent();
477                 } else {
478                     if (!w-&gt;left() || w-&gt;left()-&gt;color() == Black) {
479                         // Case 3
480                         w-&gt;right()-&gt;setColor(Black);
481                         w-&gt;setColor(Red);
482                         leftRotate(w);
483                         w = xParent-&gt;left();
484                     }
485                     // Case 4
486                     w-&gt;setColor(xParent-&gt;color());
487                     xParent-&gt;setColor(Black);
488                     if (w-&gt;left())
489                         w-&gt;left()-&gt;setColor(Black);
490                     rightRotate(xParent);
491                     x = m_root;
492                     xParent = x-&gt;parent();
493                 }
494             }
495         }
496         if (x)
497             x-&gt;setColor(Black);
498     }
499 
500     // Deletes the given node from the tree. Note that this
501     // particular node may not actually be removed from the tree;
502     // instead, another node might be removed and its contents
503     // copied into z.
504     void deleteNode(Node* z)
505     {
506         // Y is the node to be unlinked from the tree.
507         Node* y;
508         if (!z-&gt;left() || !z-&gt;right())
509             y = z;
510         else
511             y = treeSuccessor(z);
512 
513         // Y is guaranteed to be non-null at this point.
514         Node* x;
515         if (y-&gt;left())
516             x = y-&gt;left();
517         else
518             x = y-&gt;right();
519 
520         // X is the child of y which might potentially replace y in
521         // the tree. X might be null at this point.
522         Node* xParent;
523         if (x) {
524             x-&gt;setParent(y-&gt;parent());
525             xParent = x-&gt;parent();
526         } else
527             xParent = y-&gt;parent();
528         if (!y-&gt;parent())
529             m_root = x;
530         else {
531             if (y == y-&gt;parent()-&gt;left())
532                 y-&gt;parent()-&gt;setLeft(x);
533             else
534                 y-&gt;parent()-&gt;setRight(x);
535         }
536         if (y != z) {
537             z-&gt;moveDataFrom(*y);
538             // This node has changed location in the tree and must be updated.
539             updateNode(*z);
540             // The parent and its parents may now be out of date.
541             propagateUpdates(z-&gt;parent());
542         }
543 
544         // If we haven&#39;t already updated starting from xParent, do so now.
545         if (xParent &amp;&amp; xParent != y &amp;&amp; xParent != z)
546             propagateUpdates(xParent);
547         if (y-&gt;color() == Black)
548             deleteFixup(x, xParent);
549 
550         delete y;
551     }
552 
553     //----------------------------------------------------------------------
554     // Verification and debugging routines
555     //
556 
557 #ifndef NDEBUG
558 
559     // Returns in the &quot;blackCount&quot; parameter the number of black
560     // children along all paths to all leaves of the given node.
561     bool checkInvariantsFromNode(Node* node, int&amp; blackCount) const
562     {
563         // Base case is a leaf node.
564         if (!node) {
565             blackCount = 1;
566             return true;
567         }
568 
569         // Each node is either red or black.
570         if (!(node-&gt;color() == Red || node-&gt;color() == Black))
571             return false;
572 
573         // Every leaf (or null) is black.
574 
575         if (node-&gt;color() == Red) {
576             // Both of its children are black.
577             if (!((!node-&gt;left() || node-&gt;left()-&gt;color() == Black)))
578                 return false;
579             if (!((!node-&gt;right() || node-&gt;right()-&gt;color() == Black)))
580                 return false;
581         }
582 
583         // Every simple path to a leaf node contains the same number of black nodes.
584         int leftCount = 0, rightCount = 0;
585         bool leftValid = checkInvariantsFromNode(node-&gt;left(), leftCount);
586         bool rightValid = checkInvariantsFromNode(node-&gt;right(), rightCount);
587         if (!leftValid || !rightValid)
588             return false;
589         blackCount = leftCount + (node-&gt;color() == Black ? 1 : 0);
590         return leftCount == rightCount;
591     }
592 
593 #endif
594 
595 #ifdef NDEBUG
596     void logIfVerbose(const char*) const { }
597 #else
598     void logIfVerbose(const char* output) const
599     {
600         if (m_verboseDebugging)
601             LOG_ERROR(&quot;%s&quot;, output);
602     }
603 #endif
604 
605 #ifndef NDEBUG
606 
607     void dumpSubtree(Node* node, int indentation) const
608     {
609         StringBuilder builder;
610         for (int i = 0; i &lt; indentation; i++)
611             builder.append(&#39; &#39;);
612         builder.append(&#39;-&#39;);
613         if (node) {
614             builder.append(&#39; &#39;);
615             TextStream stream;
616             stream &lt;&lt; node-&gt;data();
617             builder.append(stream.release());
618             builder.append((node-&gt;color() == Black) ? &quot; (black)&quot; : &quot; (red)&quot;);
619         }
620         LOG_ERROR(&quot;%s&quot;, builder.toString().utf8().data());
621         if (node) {
622             dumpSubtree(node-&gt;left(), indentation + 2);
623             dumpSubtree(node-&gt;right(), indentation + 2);
624         }
625     }
626 
627 #endif
628 
629     Node* m_root { nullptr };
630 #ifndef NDEBUG
631     bool m_verboseDebugging { false };
632 #endif
633 };
634 
635 } // namespace WebCore
    </pre>
  </body>
</html>
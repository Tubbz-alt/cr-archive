<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/x86.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="transform.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../parser/ASTBuilder.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/x86.rb</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  34 #
  35 # eax =&gt; t0, a2, r0
  36 # edx =&gt; t1, a1, r1
  37 # ecx =&gt; t2, a0
  38 # ebx =&gt; t3, a3     (callee-save)
  39 # esi =&gt; t4         (callee-save)
  40 # edi =&gt; t5         (callee-save)
  41 # ebp =&gt; cfr
  42 # esp =&gt; sp
  43 #
  44 # On x86-64 non-windows
  45 #
  46 # rax =&gt; t0,     r0
  47 # rdi =&gt;     a0
  48 # rsi =&gt; t1, a1
  49 # rdx =&gt; t2, a2, r1
  50 # rcx =&gt; t3, a3
  51 #  r8 =&gt; t4
  52 #  r9 =&gt; t5
  53 # r10 =&gt; t6
<span class="line-modified">  54 # rbx =&gt;             csr0 (callee-save, PB, unused in baseline)</span>
<span class="line-modified">  55 # r12 =&gt;             csr1 (callee-save)</span>
<span class="line-modified">  56 # r13 =&gt;             csr2 (callee-save)</span>
  57 # r14 =&gt;             csr3 (callee-save, tagTypeNumber)
  58 # r15 =&gt;             csr4 (callee-save, tagMask)
  59 # rsp =&gt; sp
  60 # rbp =&gt; cfr
  61 # r11 =&gt;                  (scratch)
  62 #
  63 # On x86-64 windows
  64 # Arguments need to be push/pop&#39;d on the stack in addition to being stored in
  65 # the registers. Also, &gt;8 return types are returned in a weird way.
  66 #
  67 # rax =&gt; t0,     r0
  68 # rcx =&gt; t5, a0
  69 # rdx =&gt; t1, a1, r1
  70 #  r8 =&gt; t2, a2
  71 #  r9 =&gt; t3, a3
  72 # r10 =&gt; t4
  73 # rbx =&gt;             csr0 (callee-save, PB, unused in baseline)
  74 # rsi =&gt;             csr1 (callee-save)
  75 # rdi =&gt;             csr2 (callee-save)
  76 # r12 =&gt;             csr3 (callee-save)
  77 # r13 =&gt;             csr4 (callee-save)
<span class="line-modified">  78 # r14 =&gt;             csr5 (callee-save, tagTypeNumber)</span>
<span class="line-modified">  79 # r15 =&gt;             csr6 (callee-save, tagMask)</span>
  80 # rsp =&gt; sp
  81 # rbp =&gt; cfr
  82 # r11 =&gt;                  (scratch)
  83 
  84 def isX64
  85     case $activeBackend
  86     when &quot;X86&quot;
  87         false
  88     when &quot;X86_WIN&quot;
  89         false
  90     when &quot;X86_64&quot;
  91         true
  92     when &quot;X86_64_WIN&quot;
  93         true
  94     else
  95         raise &quot;bad value for $activeBackend: #{$activeBackend}&quot;
  96     end
  97 end
  98 
  99 def isWin
</pre>
<hr />
<pre>
 114 def isMSVC
 115     $options.has_key?(:assembler) &amp;&amp; $options[:assembler] == &quot;MASM&quot;
 116 end
 117 
 118 def isIntelSyntax
 119     $options.has_key?(:assembler) &amp;&amp; $options[:assembler] == &quot;MASM&quot;
 120 end
 121 
 122 def register(name)
 123     isIntelSyntax ? name : &quot;%&quot; + name
 124 end
 125 
 126 def offsetRegister(off, register)
 127     isIntelSyntax ? &quot;[#{off} + #{register}]&quot; : &quot;#{off}(#{register})&quot;
 128 end
 129 
 130 def callPrefix
 131     isIntelSyntax ? &quot;&quot; : &quot;*&quot;
 132 end
 133 
<span class="line-modified"> 134 def orderOperands(opA, opB)</span>
<span class="line-modified"> 135     isIntelSyntax ? &quot;#{opB}, #{opA}&quot; : &quot;#{opA}, #{opB}&quot;</span>
 136 end
 137 
 138 def const(c)
 139     isIntelSyntax ? &quot;#{c}&quot; : &quot;$#{c}&quot;
 140 end
 141 
 142 def getSizeString(kind)
 143     if !isIntelSyntax
 144         return &quot;&quot;
 145     end
 146 
 147     size = &quot;&quot;
 148     case kind
 149     when :byte
 150         size = &quot;byte&quot;
 151     when :half
 152         size = &quot;word&quot;
 153     when :int
 154         size = &quot;dword&quot;
 155     when :ptr
 156         size =  isX64 ? &quot;qword&quot; : &quot;dword&quot;


 157     when :double
 158         size = &quot;qword&quot;
 159     when :quad
 160         size = &quot;qword&quot;
 161     else
 162         raise &quot;Invalid kind #{kind}&quot;
 163     end
 164 
 165     return size + &quot; &quot; + &quot;ptr&quot; + &quot; &quot;;
 166 end
 167 
 168 class SpecialRegister &lt; NoChildren
 169     def x86Operand(kind)
 170         raise unless @name =~ /^r/
 171         raise unless isX64
 172         case kind
 173         when :half
 174             register(@name + &quot;w&quot;)
 175         when :int
 176             register(@name + &quot;d&quot;)
 177         when :ptr
 178             register(@name)
 179         when :quad
 180             register(@name)
 181         else
<span class="line-modified"> 182             raise</span>
 183         end
 184     end
 185     def x86CallOperand(kind)
 186         # Call operands are not allowed to be partial registers.
 187         &quot;#{callPrefix}#{x86Operand(:quad)}&quot;
 188     end
 189 end
 190 
 191 X64_SCRATCH_REGISTER = SpecialRegister.new(&quot;r11&quot;)
 192 
 193 def x86GPRName(name, kind)
 194     case name
 195     when &quot;eax&quot;, &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;
 196         name8 = name[1] + &#39;l&#39;
 197         name16 = name[1..2]
 198     when &quot;esi&quot;, &quot;edi&quot;, &quot;ebp&quot;, &quot;esp&quot;
 199         name16 = name[1..2]
 200         name8 = name16 + &#39;l&#39;
 201     when &quot;rax&quot;, &quot;rbx&quot;, &quot;rcx&quot;, &quot;rdx&quot;
 202         raise &quot;bad GPR name #{name} in 32-bit X86&quot; unless isX64
</pre>
<hr />
<pre>
 237     def x86LoadOperand(type, dst)
 238         x86Operand(type)
 239     end
 240 end
 241 
 242 class RegisterID
 243     def supports8BitOnX86
 244         case x86GPR
 245         when &quot;eax&quot;, &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;, &quot;edi&quot;, &quot;esi&quot;, &quot;ebp&quot;, &quot;esp&quot;
 246             true
 247         when &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r12&quot;, &quot;r13&quot;, &quot;r14&quot;, &quot;r15&quot;
 248             false
 249         else
 250             raise
 251         end
 252     end
 253 
 254     def x86GPR
 255         if isX64
 256             case name
<span class="line-modified"> 257             when &quot;t0&quot;, &quot;r0&quot;</span>
 258                 &quot;eax&quot;
 259             when &quot;r1&quot;
 260                 &quot;edx&quot; # t1 = a1 when isWin, t2 = a2 otherwise
<span class="line-modified"> 261             when &quot;a0&quot;</span>
 262                 isWin ? &quot;ecx&quot; : &quot;edi&quot;
<span class="line-modified"> 263             when &quot;t1&quot;, &quot;a1&quot;</span>
 264                 isWin ? &quot;edx&quot; : &quot;esi&quot;
<span class="line-modified"> 265             when &quot;t2&quot;, &quot;a2&quot;</span>
 266                 isWin ? &quot;r8&quot; : &quot;edx&quot;
<span class="line-modified"> 267             when &quot;t3&quot;, &quot;a3&quot;</span>
 268                 isWin ? &quot;r9&quot; : &quot;ecx&quot;
<span class="line-modified"> 269             when &quot;t4&quot;</span>
 270                 isWin ? &quot;r10&quot; : &quot;r8&quot;
<span class="line-modified"> 271             when &quot;t5&quot;</span>
<span class="line-modified"> 272                 isWin ? &quot;ecx&quot; : &quot;r10&quot;</span>



 273             when &quot;csr0&quot;
 274                 &quot;ebx&quot;
 275             when &quot;csr1&quot;
 276                 isWin ? &quot;esi&quot; : &quot;r12&quot;
 277             when &quot;csr2&quot;
 278                 isWin ? &quot;edi&quot; : &quot;r13&quot;
 279             when &quot;csr3&quot;
 280                 isWin ? &quot;r12&quot; : &quot;r14&quot;
 281             when &quot;csr4&quot;
 282                 isWin ? &quot;r13&quot; : &quot;r15&quot;
 283             when &quot;csr5&quot;
 284                 raise &quot;cannot use register #{name} on X86-64&quot; unless isWin
 285                 &quot;r14&quot;
 286             when &quot;csr6&quot;
 287                 raise &quot;cannot use register #{name} on X86-64&quot; unless isWin
 288                 &quot;r15&quot;
 289             when &quot;cfr&quot;
 290                 &quot;ebp&quot;
 291             when &quot;sp&quot;
 292                 &quot;esp&quot;
</pre>
<hr />
<pre>
 309                 &quot;edi&quot;
 310             when &quot;cfr&quot;
 311                 &quot;ebp&quot;
 312             when &quot;sp&quot;
 313                 &quot;esp&quot;
 314             end
 315         end
 316     end
 317 
 318     def x86Operand(kind)
 319         x86GPRName(x86GPR, kind)
 320     end
 321 
 322     def x86CallOperand(kind)
 323         &quot;#{callPrefix}#{x86Operand(:ptr)}&quot;
 324     end
 325 end
 326 
 327 class FPRegisterID
 328     def x86Operand(kind)
<span class="line-modified"> 329         raise unless kind == :double</span>
 330         case name
<span class="line-modified"> 331         when &quot;ft0&quot;, &quot;fa0&quot;, &quot;fr&quot;</span>
 332             register(&quot;xmm0&quot;)
<span class="line-modified"> 333         when &quot;ft1&quot;, &quot;fa1&quot;</span>
 334             register(&quot;xmm1&quot;)
<span class="line-modified"> 335         when &quot;ft2&quot;, &quot;fa2&quot;</span>
 336             register(&quot;xmm2&quot;)
<span class="line-modified"> 337         when &quot;ft3&quot;, &quot;fa3&quot;</span>
 338             register(&quot;xmm3&quot;)
<span class="line-modified"> 339         when &quot;ft4&quot;</span>
 340             register(&quot;xmm4&quot;)
<span class="line-modified"> 341         when &quot;ft5&quot;</span>
 342             register(&quot;xmm5&quot;)




 343         else
 344             raise &quot;Bad register #{name} for X86 at #{codeOriginString}&quot;
 345         end
 346     end
 347     def x86CallOperand(kind)
 348         &quot;#{callPrefix}#{x86Operand(kind)}&quot;
 349     end
 350 end
 351 
 352 class Immediate
 353     def validX86Immediate?
 354         if isX64
 355             value &gt;= -0x80000000 and value &lt;= 0x7fffffff
 356         else
 357             true
 358         end
 359     end
 360     def x86Operand(kind)
 361         &quot;#{const(value)}&quot;
 362     end
</pre>
<hr />
<pre>
 481                         node.is_a? LocalLabel or
 482                         node.is_a? Skip
 483                     raise &quot;Unexpected #{node.inspect} at #{node.codeOrigin}&quot; 
 484                 end
 485             end
 486             if newNode
 487                 newList &lt;&lt; newNode
 488             end
 489         }
 490         
 491         return newList
 492     end
 493     def getModifiedListX86_64_WIN
 494         getModifiedListX86_64
 495     end
 496 end
 497 
 498 class Instruction
 499     
 500     def x86Operands(*kinds)
<span class="line-modified"> 501         raise unless kinds.size == operands.size</span>
 502         result = []
 503         kinds.size.times {
 504             | idx |
 505             i = isIntelSyntax ? (kinds.size - idx - 1) : idx
 506             result &lt;&lt; operands[i].x86Operand(kinds[i])
 507         }
 508         result.join(&quot;, &quot;)
 509     end
 510     
 511     def x86LoadOperands(srcKind, dstKind)
 512         orderOperands(operands[0].x86LoadOperand(srcKind, operands[1]), operands[1].x86Operand(dstKind))
 513     end
 514 
 515     def x86Suffix(kind)
<span class="line-modified"> 516         if isIntelSyntax</span>
 517             return &quot;&quot;
 518         end
 519 
 520         case kind
 521         when :byte
 522             &quot;b&quot;
 523         when :half
 524             &quot;w&quot;
 525         when :int
 526             &quot;l&quot;
 527         when :ptr
 528             isX64 ? &quot;q&quot; : &quot;l&quot;
 529         when :quad
 530             isX64 ? &quot;q&quot; : raise


 531         when :double
 532             &quot;sd&quot;
 533         else
 534             raise
 535         end
 536     end
 537     
 538     def x86Bytes(kind)
 539         case kind
 540         when :byte
 541             1
 542         when :half
 543             2
 544         when :int
 545             4
 546         when :ptr
 547             isX64 ? 8 : 4
 548         when :quad
 549             isX64 ? 8 : raise


 550         when :double
 551             8
 552         else
 553             raise
 554         end
 555     end
 556 
 557     def emitX86Lea(src, dst, kind)
 558         if src.is_a? LabelReference
 559             src.used
 560             if !isIntelSyntax
 561                 $asm.puts &quot;movq #{src.asmLabel}@GOTPCREL(%rip), #{dst.x86Operand(:ptr)}&quot;
 562             else
 563                 $asm.puts &quot;lea #{dst.x86Operand(:ptr)}, #{src.asmLabel}&quot;
 564             end
 565         else
 566             $asm.puts &quot;lea#{x86Suffix(kind)} #{orderOperands(src.x86AddressOperand(kind), dst.x86Operand(kind))}&quot;
 567         end
 568     end
 569 
</pre>
<hr />
<pre>
 583             end
 584         else
 585             $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 586         end
 587     end
 588     
 589     def handleX86Op(opcode, kind)
 590         handleX86OpWithNumOperands(opcode, kind, operands.size)
 591     end
 592     
 593     def handleX86Shift(opcode, kind)
 594         if operands[0].is_a? Immediate or operands[0].x86GPR == &quot;ecx&quot;
 595             $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(:byte), operands[1].x86Operand(kind))}&quot;
 596         else
 597             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operands[0].x86Operand(:ptr)}, #{x86GPRName(&quot;ecx&quot;, :ptr)}&quot;
 598             $asm.puts &quot;#{opcode} #{orderOperands(register(&quot;cl&quot;), operands[1].x86Operand(kind))}&quot;
 599             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operands[0].x86Operand(:ptr)}, #{x86GPRName(&quot;ecx&quot;, :ptr)}&quot;
 600         end
 601     end
 602     
<span class="line-modified"> 603     def handleX86DoubleBranch(branchOpcode, mode)</span>
 604         case mode
 605         when :normal
<span class="line-modified"> 606             $asm.puts &quot;ucomisd #{orderOperands(operands[1].x86Operand(:double), operands[0].x86Operand(:double))}&quot;</span>
 607         when :reverse
<span class="line-modified"> 608             $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;</span>
 609         else
 610             raise mode.inspect
 611         end
 612         $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
 613     end
 614     
 615     def handleX86IntCompare(opcodeSuffix, kind)
 616         if operands[0].is_a? Immediate and operands[0].value == 0 and operands[1].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)
 617             $asm.puts &quot;test#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 618         elsif operands[1].is_a? Immediate and operands[1].value == 0 and operands[0].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)
 619             $asm.puts &quot;test#{x86Suffix(kind)}  #{orderOperands(operands[0].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
 620         else
 621             $asm.puts &quot;cmp#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
 622         end
 623     end
 624     










 625     def handleX86IntBranch(branchOpcode, kind)
 626         handleX86IntCompare(branchOpcode[1..-1], kind)
 627         $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
 628     end
 629     
 630     def handleX86Set(setOpcode, operand)
 631         if operand.supports8BitOnX86
 632             $asm.puts &quot;#{setOpcode} #{operand.x86Operand(:byte)}&quot;
 633             if !isIntelSyntax
 634                 $asm.puts &quot;movzbl #{orderOperands(operand.x86Operand(:byte), operand.x86Operand(:int))}&quot;
 635             else
 636                 $asm.puts &quot;movzx #{orderOperands(operand.x86Operand(:byte), operand.x86Operand(:int))}&quot;
 637             end
 638         else
 639             ax = RegisterID.new(nil, &quot;r0&quot;)
 640             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operand.x86Operand(:ptr)}, #{ax.x86Operand(:ptr)}&quot;
 641             $asm.puts &quot;#{setOpcode} #{ax.x86Operand(:byte)}&quot;
 642             if !isIntelSyntax
 643                 $asm.puts &quot;movzbl #{ax.x86Operand(:byte)}, #{ax.x86Operand(:int)}&quot;
 644             else
 645                 $asm.puts &quot;movzx #{ax.x86Operand(:int)}, #{ax.x86Operand(:byte)}&quot;
 646             end
 647             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operand.x86Operand(:ptr)}, #{ax.x86Operand(:ptr)}&quot;
 648         end
 649     end
 650     
 651     def handleX86IntCompareSet(setOpcode, kind)
 652         handleX86IntCompare(setOpcode[3..-1], kind)
 653         handleX86Set(setOpcode, operands[2])
 654     end





















































 655     
 656     def handleX86Test(kind)
 657         value = operands[0]
 658         case operands.size
 659         when 2
 660             mask = Immediate.new(codeOrigin, -1)
 661         when 3
 662             mask = operands[1]
 663         else
 664             raise &quot;Expected 2 or 3 operands, but got #{operands.size} at #{codeOriginString}&quot;
 665         end
 666         
 667         if mask.is_a? Immediate and mask.value == -1
 668             if value.is_a? RegisterID
 669                 $asm.puts &quot;test#{x86Suffix(kind)} #{value.x86Operand(kind)}, #{value.x86Operand(kind)}&quot;
 670             else
 671                 $asm.puts &quot;cmp#{x86Suffix(kind)} #{orderOperands(const(0), value.x86Operand(kind))}&quot;
 672             end
 673         else
 674             $asm.puts &quot;test#{x86Suffix(kind)} #{orderOperands(mask.x86Operand(kind), value.x86Operand(kind))}&quot;
</pre>
<hr />
<pre>
 732                 $asm.puts &quot;lea#{x86Suffix(kind)} #{orderOperands(offsetRegister(operands[0].value, operands[1].x86Operand(kind)), operands[2].x86Operand(kind))}&quot;
 733             end
 734         elsif operands.size == 3 and operands[0].is_a? RegisterID
 735             raise unless operands[1].is_a? RegisterID
 736             raise unless operands[2].is_a? RegisterID
 737             if operands[0] == operands[2]
 738                 $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 739             else
 740                 if !isIntelSyntax
 741                     $asm.puts &quot;lea#{x86Suffix(kind)} (#{operands[0].x86Operand(kind)}, #{operands[1].x86Operand(kind)}), #{operands[2].x86Operand(kind)}&quot;
 742                 else
 743                     $asm.puts &quot;lea#{x86Suffix(kind)} #{operands[2].x86Operand(kind)}, [#{operands[0].x86Operand(kind)} + #{operands[1].x86Operand(kind)}]&quot;
 744                 end
 745             end
 746         else
 747             unless Immediate.new(nil, 0) == operands[0]
 748                 $asm.puts &quot;add#{x86Suffix(kind)} #{x86Operands(kind, kind)}&quot;
 749             end
 750         end
 751     end
<span class="line-modified"> 752     </span>
 753     def handleX86Sub(kind)
 754         if operands.size == 3
 755             if Immediate.new(nil, 0) == operands[1]
 756                 raise unless operands[0].is_a? RegisterID
 757                 raise unless operands[2].is_a? RegisterID
 758                 if operands[0] != operands[2]
 759                     $asm.puts &quot;mov#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 760                 end
 761                 return
 762             end
 763             if operands[1] == operands[2]
 764                 $asm.puts &quot;neg#{x86Suffix(kind)} #{operands[2].x86Operand(kind)}&quot;
 765                 if Immediate.new(nil, 0) != operands[0]
 766                     $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 767                 end
 768                 return
 769             end
 770         end
 771 
 772         if operands.size == 2
</pre>
<hr />
<pre>
 778         handleX86Op(&quot;sub#{x86Suffix(kind)}&quot;, kind)
 779     end
 780     
 781     def handleX86Mul(kind)
 782         if operands.size == 3 and operands[0].is_a? Immediate
 783             $asm.puts &quot;imul#{x86Suffix(kind)} #{x86Operands(kind, kind, kind)}&quot;
 784             return
 785         end
 786 
 787         if operands.size == 2 and operands[0].is_a? Immediate
 788             imm = operands[0].value
 789             if imm &gt; 0 and isPowerOfTwo(imm)
 790                 $asm.puts &quot;sal#{x86Suffix(kind)} #{orderOperands(Immediate.new(nil, Math.log2(imm).to_i).x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 791                 return
 792             end
 793         end
 794 
 795         handleX86Op(&quot;imul#{x86Suffix(kind)}&quot;, kind)
 796     end
 797     








































 798     def handleX86Peek()
 799         sp = RegisterID.new(nil, &quot;sp&quot;)
 800         opA = offsetRegister(operands[0].value * x86Bytes(:ptr), sp.x86Operand(:ptr))
 801         opB = operands[1].x86Operand(:ptr)
 802         $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(opA, opB)}&quot;
 803     end
 804 
 805     def handleX86Poke()
 806         sp = RegisterID.new(nil, &quot;sp&quot;)
 807         opA = operands[0].x86Operand(:ptr)
 808         opB = offsetRegister(operands[1].value * x86Bytes(:ptr), sp.x86Operand(:ptr))
 809         $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(opA, opB)}&quot;
 810     end
 811 
 812     def handleMove
 813         if Immediate.new(nil, 0) == operands[0] and operands[1].is_a? RegisterID
 814             if isX64
 815                 $asm.puts &quot;xor#{x86Suffix(:quad)} #{operands[1].x86Operand(:quad)}, #{operands[1].x86Operand(:quad)}&quot;
 816             else
 817                 $asm.puts &quot;xor#{x86Suffix(:ptr)} #{operands[1].x86Operand(:ptr)}, #{operands[1].x86Operand(:ptr)}&quot;
 818             end
 819         elsif operands[0] != operands[1]
 820             if isX64
 821                 $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86Operands(:quad, :quad)}&quot;
 822             else
 823                 $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86Operands(:ptr, :ptr)}&quot;
 824             end
 825         end
 826     end
 827 


















































































































 828     def lowerX86
 829         raise unless $activeBackend == &quot;X86&quot;
 830         lowerX86Common
 831     end
 832 
 833     def lowerX86_WIN
 834         raise unless $activeBackend == &quot;X86_WIN&quot; 
 835         lowerX86Common
 836     end
 837     
 838     def lowerX86_64
 839         raise unless $activeBackend == &quot;X86_64&quot;
 840         lowerX86Common
 841     end
 842 
 843     def lowerX86_64_WIN
 844         raise unless $activeBackend == &quot;X86_64_WIN&quot;
 845         lowerX86Common
 846     end
 847 
 848     def lowerX86Common
 849         case opcode
 850         when &quot;addi&quot;
 851             handleX86Add(:int)
 852         when &quot;addp&quot;
 853             handleX86Add(:ptr)
 854         when &quot;addq&quot;
 855             handleX86Add(:quad)
 856         when &quot;andi&quot;
 857             handleX86Op(&quot;and#{x86Suffix(:int)}&quot;, :int)
 858         when &quot;andp&quot;
 859             handleX86Op(&quot;and#{x86Suffix(:ptr)}&quot;, :ptr)
 860         when &quot;andq&quot;
 861             handleX86Op(&quot;and#{x86Suffix(:quad)}&quot;, :quad)




 862         when &quot;lshifti&quot;
 863             handleX86Shift(&quot;sal#{x86Suffix(:int)}&quot;, :int)
 864         when &quot;lshiftp&quot;
 865             handleX86Shift(&quot;sal#{x86Suffix(:ptr)}&quot;, :ptr)
 866         when &quot;lshiftq&quot;
 867             handleX86Shift(&quot;sal#{x86Suffix(:quad)}&quot;, :quad)
 868         when &quot;muli&quot;
 869             handleX86Mul(:int)
 870         when &quot;mulp&quot;
 871             handleX86Mul(:ptr)
 872         when &quot;mulq&quot;
 873             handleX86Mul(:quad)
 874         when &quot;negi&quot;
 875             $asm.puts &quot;neg#{x86Suffix(:int)} #{x86Operands(:int)}&quot;
 876         when &quot;negp&quot;
 877             $asm.puts &quot;neg#{x86Suffix(:ptr)} #{x86Operands(:ptr)}&quot;
 878         when &quot;negq&quot;
 879             $asm.puts &quot;neg#{x86Suffix(:quad)} #{x86Operands(:quad)}&quot;
 880         when &quot;noti&quot;
 881             $asm.puts &quot;not#{x86Suffix(:int)} #{x86Operands(:int)}&quot;
 882         when &quot;ori&quot;
 883             handleX86Op(&quot;or#{x86Suffix(:int)}&quot;, :int)
 884         when &quot;orp&quot;
 885             handleX86Op(&quot;or#{x86Suffix(:ptr)}&quot;, :ptr)
 886         when &quot;orq&quot;
 887             handleX86Op(&quot;or#{x86Suffix(:quad)}&quot;, :quad)






 888         when &quot;rshifti&quot;
 889             handleX86Shift(&quot;sar#{x86Suffix(:int)}&quot;, :int)
 890         when &quot;rshiftp&quot;
 891             handleX86Shift(&quot;sar#{x86Suffix(:ptr)}&quot;, :ptr)
 892         when &quot;rshiftq&quot;
 893             handleX86Shift(&quot;sar#{x86Suffix(:quad)}&quot;, :quad)
 894         when &quot;urshifti&quot;
 895             handleX86Shift(&quot;shr#{x86Suffix(:int)}&quot;, :int)
 896         when &quot;urshiftp&quot;
 897             handleX86Shift(&quot;shr#{x86Suffix(:ptr)}&quot;, :ptr)
 898         when &quot;urshiftq&quot;
 899             handleX86Shift(&quot;shr#{x86Suffix(:quad)}&quot;, :quad)








 900         when &quot;subi&quot;
 901             handleX86Sub(:int)
 902         when &quot;subp&quot;
 903             handleX86Sub(:ptr)
 904         when &quot;subq&quot;
 905             handleX86Sub(:quad)
 906         when &quot;xori&quot;
 907             handleX86Op(&quot;xor#{x86Suffix(:int)}&quot;, :int)
 908         when &quot;xorp&quot;
 909             handleX86Op(&quot;xor#{x86Suffix(:ptr)}&quot;, :ptr)
 910         when &quot;xorq&quot;
 911             handleX86Op(&quot;xor#{x86Suffix(:quad)}&quot;, :quad)
 912         when &quot;leap&quot;
 913             emitX86Lea(operands[0], operands[1], :ptr)
 914         when &quot;loadi&quot;
 915             $asm.puts &quot;mov#{x86Suffix(:int)} #{x86LoadOperands(:int, :int)}&quot;
 916         when &quot;storei&quot;
 917             $asm.puts &quot;mov#{x86Suffix(:int)} #{x86Operands(:int, :int)}&quot;
 918         when &quot;loadis&quot;
 919             if isX64
</pre>
<hr />
<pre>
 954         when &quot;loadh&quot;
 955             if !isIntelSyntax
 956                 $asm.puts &quot;movzwl #{x86LoadOperands(:half, :int)}&quot;
 957             else
 958                 $asm.puts &quot;movzx #{x86LoadOperands(:half, :int)}&quot;
 959             end
 960         when &quot;loadhsi&quot;
 961             if !isIntelSyntax
 962                 $asm.puts &quot;movswl #{x86LoadOperands(:half, :int)}&quot;
 963             else
 964                 $asm.puts &quot;movsx #{x86LoadOperands(:half, :int)}&quot;
 965             end
 966         when &quot;loadhsq&quot;
 967             if !isIntelSyntax
 968                 $asm.puts &quot;movswq #{x86LoadOperands(:half, :quad)}&quot;
 969             else
 970                 $asm.puts &quot;movsx #{x86LoadOperands(:half, :quad)}&quot;
 971             end
 972         when &quot;storeb&quot;
 973             $asm.puts &quot;mov#{x86Suffix(:byte)} #{x86Operands(:byte, :byte)}&quot;




 974         when &quot;loadd&quot;
 975             $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;
 976         when &quot;moved&quot;
 977             $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;


 978         when &quot;stored&quot;
 979             $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;


 980         when &quot;addd&quot;
<span class="line-modified"> 981             $asm.puts &quot;addsd #{x86Operands(:double, :double)}&quot;</span>


 982         when &quot;muld&quot;
<span class="line-modified"> 983             $asm.puts &quot;mulsd #{x86Operands(:double, :double)}&quot;</span>


 984         when &quot;subd&quot;
<span class="line-modified"> 985             $asm.puts &quot;subsd #{x86Operands(:double, :double)}&quot;</span>


 986         when &quot;divd&quot;
<span class="line-modified"> 987             $asm.puts &quot;divsd #{x86Operands(:double, :double)}&quot;</span>


 988         when &quot;sqrtd&quot;
 989             $asm.puts &quot;sqrtsd #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;
































 990         when &quot;ci2d&quot;


 991             $asm.puts &quot;cvtsi2sd #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:double))}&quot;
















 992         when &quot;bdeq&quot;
 993             $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
 994             if operands[0] == operands[1]
 995                 # This is just a jump ordered, which is a jnp.
 996                 $asm.puts &quot;jnp #{operands[2].asmLabel}&quot;
 997             else
 998                 isUnordered = LocalLabel.unique(&quot;bdeq&quot;)
<span class="line-modified"> 999                 $asm.puts &quot;jp #{LabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="line-modified">1000                 $asm.puts &quot;je #{LabelReference.new(codeOrigin, operands[2]).asmLabel}&quot;</span>
<span class="line-modified">1001                 isUnordered.lower(&quot;X86&quot;)</span>
1002             end
1003         when &quot;bdneq&quot;
<span class="line-modified">1004             handleX86DoubleBranch(&quot;jne&quot;, :normal)</span>
1005         when &quot;bdgt&quot;
<span class="line-modified">1006             handleX86DoubleBranch(&quot;ja&quot;, :normal)</span>
1007         when &quot;bdgteq&quot;
<span class="line-modified">1008             handleX86DoubleBranch(&quot;jae&quot;, :normal)</span>
1009         when &quot;bdlt&quot;
<span class="line-modified">1010             handleX86DoubleBranch(&quot;ja&quot;, :reverse)</span>
1011         when &quot;bdlteq&quot;
<span class="line-modified">1012             handleX86DoubleBranch(&quot;jae&quot;, :reverse)</span>
1013         when &quot;bdequn&quot;
<span class="line-modified">1014             handleX86DoubleBranch(&quot;je&quot;, :normal)</span>
1015         when &quot;bdnequn&quot;
1016             $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
1017             if operands[0] == operands[1]
1018                 # This is just a jump unordered, which is a jp.
1019                 $asm.puts &quot;jp #{operands[2].asmLabel}&quot;
1020             else
1021                 isUnordered = LocalLabel.unique(&quot;bdnequn&quot;)
1022                 isEqual = LocalLabel.unique(&quot;bdnequn&quot;)
<span class="line-modified">1023                 $asm.puts &quot;jp #{LabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="line-modified">1024                 $asm.puts &quot;je #{LabelReference.new(codeOrigin, isEqual).asmLabel}&quot;</span>
<span class="line-modified">1025                 isUnordered.lower(&quot;X86&quot;)</span>
1026                 $asm.puts &quot;jmp #{operands[2].asmLabel}&quot;
<span class="line-modified">1027                 isEqual.lower(&quot;X86&quot;)</span>
1028             end
1029         when &quot;bdgtun&quot;
<span class="line-modified">1030             handleX86DoubleBranch(&quot;jb&quot;, :reverse)</span>
1031         when &quot;bdgtequn&quot;
<span class="line-modified">1032             handleX86DoubleBranch(&quot;jbe&quot;, :reverse)</span>
1033         when &quot;bdltun&quot;
<span class="line-modified">1034             handleX86DoubleBranch(&quot;jb&quot;, :normal)</span>
1035         when &quot;bdltequn&quot;
<span class="line-modified">1036             handleX86DoubleBranch(&quot;jbe&quot;, :normal)</span>

























1037         when &quot;btd2i&quot;
1038             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1039             $asm.puts &quot;cmpl $0x80000000 #{operands[1].x86Operand(:int)}&quot;
1040             $asm.puts &quot;je #{operands[2].asmLabel}&quot;
1041         when &quot;td2i&quot;
1042             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1043         when &quot;bcd2i&quot;
1044             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1045             $asm.puts &quot;test#{x86Suffix(:int)} #{operands[1].x86Operand(:int)}, #{operands[1].x86Operand(:int)}&quot;
1046             $asm.puts &quot;je #{operands[2].asmLabel}&quot;
1047             $asm.puts &quot;cvtsi2sd #{operands[1].x86Operand(:int)}, %xmm7&quot;
1048             $asm.puts &quot;ucomisd #{operands[0].x86Operand(:double)}, %xmm7&quot;
1049             $asm.puts &quot;jp #{operands[2].asmLabel}&quot;
1050             $asm.puts &quot;jne #{operands[2].asmLabel}&quot;
1051         when &quot;movdz&quot;
1052             $asm.puts &quot;xorpd #{operands[0].x86Operand(:double)}, #{operands[0].x86Operand(:double)}&quot;
1053         when &quot;pop&quot;
1054             operands.each {
1055                 | op |
1056                 $asm.puts &quot;pop #{op.x86Operand(:ptr)}&quot;
</pre>
<hr />
<pre>
1299         when &quot;cpgteq&quot;
1300             handleX86IntCompareSet(&quot;setge&quot;, :ptr)
1301         when &quot;cqgteq&quot;
1302             handleX86IntCompareSet(&quot;setge&quot;, :quad)
1303         when &quot;cilt&quot;
1304             handleX86IntCompareSet(&quot;setl&quot;, :int)
1305         when &quot;cblt&quot;
1306             handleX86IntCompareSet(&quot;setl&quot;, :byte)
1307         when &quot;cplt&quot;
1308             handleX86IntCompareSet(&quot;setl&quot;, :ptr)
1309         when &quot;cqlt&quot;
1310             handleX86IntCompareSet(&quot;setl&quot;, :quad)
1311         when &quot;cilteq&quot;
1312             handleX86IntCompareSet(&quot;setle&quot;, :int)
1313         when &quot;cblteq&quot;
1314             handleX86IntCompareSet(&quot;setle&quot;, :byte)
1315         when &quot;cplteq&quot;
1316             handleX86IntCompareSet(&quot;setle&quot;, :ptr)
1317         when &quot;cqlteq&quot;
1318             handleX86IntCompareSet(&quot;setle&quot;, :quad)




























1319         when &quot;tis&quot;
1320             handleX86SetTest(&quot;sets&quot;, :int)
1321         when &quot;tiz&quot;
1322             handleX86SetTest(&quot;setz&quot;, :int)
1323         when &quot;tinz&quot;
1324             handleX86SetTest(&quot;setnz&quot;, :int)
1325         when &quot;tps&quot;
1326             handleX86SetTest(&quot;sets&quot;, :ptr)
1327         when &quot;tpz&quot;
1328             handleX86SetTest(&quot;setz&quot;, :ptr)
1329         when &quot;tpnz&quot;
1330             handleX86SetTest(&quot;setnz&quot;, :ptr)
1331         when &quot;tqs&quot;
1332             handleX86SetTest(&quot;sets&quot;, :quad)
1333         when &quot;tqz&quot;
1334             handleX86SetTest(&quot;setz&quot;, :quad)
1335         when &quot;tqnz&quot;
1336             handleX86SetTest(&quot;setnz&quot;, :quad)
1337         when &quot;tbs&quot;
1338             handleX86SetTest(&quot;sets&quot;, :byte)
1339         when &quot;tbz&quot;
1340             handleX86SetTest(&quot;setz&quot;, :byte)
1341         when &quot;tbnz&quot;
1342             handleX86SetTest(&quot;setnz&quot;, :byte)
1343         when &quot;peek&quot;
1344             handleX86Peek()
1345         when &quot;poke&quot;
1346             handleX86Poke()
1347         when &quot;cdqi&quot;
1348             $asm.puts &quot;cdq&quot;


1349         when &quot;idivi&quot;
1350             $asm.puts &quot;idiv#{x86Suffix(:int)} #{operands[0].x86Operand(:int)}&quot;


















1351         when &quot;fii2d&quot;
1352             $asm.puts &quot;movd #{operands[0].x86Operand(:int)}, #{operands[2].x86Operand(:double)}&quot;
1353             $asm.puts &quot;movd #{operands[1].x86Operand(:int)}, %xmm7&quot;
1354             $asm.puts &quot;psllq $32, %xmm7&quot;
1355             $asm.puts &quot;por %xmm7, #{operands[2].x86Operand(:double)}&quot;
1356         when &quot;fd2ii&quot;
1357             $asm.puts &quot;movd #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1358             $asm.puts &quot;movsd #{operands[0].x86Operand(:double)}, %xmm7&quot;
1359             $asm.puts &quot;psrlq $32, %xmm7&quot;
1360             $asm.puts &quot;movd %xmm7, #{operands[2].x86Operand(:int)}&quot;
1361         when &quot;fq2d&quot;
1362             if !isIntelSyntax
1363                 $asm.puts &quot;movq #{operands[0].x86Operand(:quad)}, #{operands[1].x86Operand(:double)}&quot;
1364             else
1365                 # MASM does not accept register operands with movq.
1366                 # Debugging shows that movd actually moves a qword when using MASM.
1367                 $asm.puts &quot;movd #{operands[1].x86Operand(:double)}, #{operands[0].x86Operand(:quad)}&quot;
1368             end
1369         when &quot;fd2q&quot;
1370             if !isIntelSyntax
1371                 $asm.puts &quot;movq #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:quad)}&quot;
1372             else
1373                 # MASM does not accept register operands with movq.
1374                 # Debugging shows that movd actually moves a qword when using MASM.
1375                 $asm.puts &quot;movd #{operands[1].x86Operand(:quad)}, #{operands[0].x86Operand(:double)}&quot;
1376             end




1377         when &quot;bo&quot;
1378             $asm.puts &quot;jo #{operands[0].asmLabel}&quot;
1379         when &quot;bs&quot;
1380             $asm.puts &quot;js #{operands[0].asmLabel}&quot;
1381         when &quot;bz&quot;
1382             $asm.puts &quot;jz #{operands[0].asmLabel}&quot;
1383         when &quot;bnz&quot;
1384             $asm.puts &quot;jnz #{operands[0].asmLabel}&quot;
1385         when &quot;leai&quot;
1386             $asm.puts &quot;lea#{x86Suffix(:int)} #{orderOperands(operands[0].x86AddressOperand(:int), operands[1].x86Operand(:int))}&quot;
1387         when &quot;leap&quot;
1388             $asm.puts &quot;lea#{x86Suffix(:ptr)} #{orderOperands(operands[0].x86AddressOperand(:ptr), operands[1].x86Operand(:ptr))}&quot;
1389         when &quot;memfence&quot;
1390             sp = RegisterID.new(nil, &quot;sp&quot;)
1391             if isIntelSyntax
1392                 $asm.puts &quot;mfence&quot;
1393             else
1394                 $asm.puts &quot;lock; orl $0, (#{sp.x86Operand(:ptr)})&quot;
1395             end








































1396         else
1397             lowerDefault
1398         end
1399     end
1400 end
1401 
</pre>
</td>
<td>
<hr />
<pre>
  34 #
  35 # eax =&gt; t0, a2, r0
  36 # edx =&gt; t1, a1, r1
  37 # ecx =&gt; t2, a0
  38 # ebx =&gt; t3, a3     (callee-save)
  39 # esi =&gt; t4         (callee-save)
  40 # edi =&gt; t5         (callee-save)
  41 # ebp =&gt; cfr
  42 # esp =&gt; sp
  43 #
  44 # On x86-64 non-windows
  45 #
  46 # rax =&gt; t0,     r0
  47 # rdi =&gt;     a0
  48 # rsi =&gt; t1, a1
  49 # rdx =&gt; t2, a2, r1
  50 # rcx =&gt; t3, a3
  51 #  r8 =&gt; t4
  52 #  r9 =&gt; t5
  53 # r10 =&gt; t6
<span class="line-modified">  54 # rbx =&gt;             csr0 (callee-save, wasmInstance)</span>
<span class="line-modified">  55 # r12 =&gt;             csr1 (callee-save, metadataTable)</span>
<span class="line-modified">  56 # r13 =&gt;             csr2 (callee-save, PB)</span>
  57 # r14 =&gt;             csr3 (callee-save, tagTypeNumber)
  58 # r15 =&gt;             csr4 (callee-save, tagMask)
  59 # rsp =&gt; sp
  60 # rbp =&gt; cfr
  61 # r11 =&gt;                  (scratch)
  62 #
  63 # On x86-64 windows
  64 # Arguments need to be push/pop&#39;d on the stack in addition to being stored in
  65 # the registers. Also, &gt;8 return types are returned in a weird way.
  66 #
  67 # rax =&gt; t0,     r0
  68 # rcx =&gt; t5, a0
  69 # rdx =&gt; t1, a1, r1
  70 #  r8 =&gt; t2, a2
  71 #  r9 =&gt; t3, a3
  72 # r10 =&gt; t4
  73 # rbx =&gt;             csr0 (callee-save, PB, unused in baseline)
  74 # rsi =&gt;             csr1 (callee-save)
  75 # rdi =&gt;             csr2 (callee-save)
  76 # r12 =&gt;             csr3 (callee-save)
  77 # r13 =&gt;             csr4 (callee-save)
<span class="line-modified">  78 # r14 =&gt;             csr5 (callee-save, numberTag)</span>
<span class="line-modified">  79 # r15 =&gt;             csr6 (callee-save, notCellMask)</span>
  80 # rsp =&gt; sp
  81 # rbp =&gt; cfr
  82 # r11 =&gt;                  (scratch)
  83 
  84 def isX64
  85     case $activeBackend
  86     when &quot;X86&quot;
  87         false
  88     when &quot;X86_WIN&quot;
  89         false
  90     when &quot;X86_64&quot;
  91         true
  92     when &quot;X86_64_WIN&quot;
  93         true
  94     else
  95         raise &quot;bad value for $activeBackend: #{$activeBackend}&quot;
  96     end
  97 end
  98 
  99 def isWin
</pre>
<hr />
<pre>
 114 def isMSVC
 115     $options.has_key?(:assembler) &amp;&amp; $options[:assembler] == &quot;MASM&quot;
 116 end
 117 
 118 def isIntelSyntax
 119     $options.has_key?(:assembler) &amp;&amp; $options[:assembler] == &quot;MASM&quot;
 120 end
 121 
 122 def register(name)
 123     isIntelSyntax ? name : &quot;%&quot; + name
 124 end
 125 
 126 def offsetRegister(off, register)
 127     isIntelSyntax ? &quot;[#{off} + #{register}]&quot; : &quot;#{off}(#{register})&quot;
 128 end
 129 
 130 def callPrefix
 131     isIntelSyntax ? &quot;&quot; : &quot;*&quot;
 132 end
 133 
<span class="line-modified"> 134 def orderOperands(*operands)</span>
<span class="line-modified"> 135     (isIntelSyntax ? operands.reverse : operands).join(&quot;, &quot;)</span>
 136 end
 137 
 138 def const(c)
 139     isIntelSyntax ? &quot;#{c}&quot; : &quot;$#{c}&quot;
 140 end
 141 
 142 def getSizeString(kind)
 143     if !isIntelSyntax
 144         return &quot;&quot;
 145     end
 146 
 147     size = &quot;&quot;
 148     case kind
 149     when :byte
 150         size = &quot;byte&quot;
 151     when :half
 152         size = &quot;word&quot;
 153     when :int
 154         size = &quot;dword&quot;
 155     when :ptr
 156         size =  isX64 ? &quot;qword&quot; : &quot;dword&quot;
<span class="line-added"> 157     when :float</span>
<span class="line-added"> 158         size = &quot;dword&quot;</span>
 159     when :double
 160         size = &quot;qword&quot;
 161     when :quad
 162         size = &quot;qword&quot;
 163     else
 164         raise &quot;Invalid kind #{kind}&quot;
 165     end
 166 
 167     return size + &quot; &quot; + &quot;ptr&quot; + &quot; &quot;;
 168 end
 169 
 170 class SpecialRegister &lt; NoChildren
 171     def x86Operand(kind)
 172         raise unless @name =~ /^r/
 173         raise unless isX64
 174         case kind
 175         when :half
 176             register(@name + &quot;w&quot;)
 177         when :int
 178             register(@name + &quot;d&quot;)
 179         when :ptr
 180             register(@name)
 181         when :quad
 182             register(@name)
 183         else
<span class="line-modified"> 184             raise codeOriginString</span>
 185         end
 186     end
 187     def x86CallOperand(kind)
 188         # Call operands are not allowed to be partial registers.
 189         &quot;#{callPrefix}#{x86Operand(:quad)}&quot;
 190     end
 191 end
 192 
 193 X64_SCRATCH_REGISTER = SpecialRegister.new(&quot;r11&quot;)
 194 
 195 def x86GPRName(name, kind)
 196     case name
 197     when &quot;eax&quot;, &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;
 198         name8 = name[1] + &#39;l&#39;
 199         name16 = name[1..2]
 200     when &quot;esi&quot;, &quot;edi&quot;, &quot;ebp&quot;, &quot;esp&quot;
 201         name16 = name[1..2]
 202         name8 = name16 + &#39;l&#39;
 203     when &quot;rax&quot;, &quot;rbx&quot;, &quot;rcx&quot;, &quot;rdx&quot;
 204         raise &quot;bad GPR name #{name} in 32-bit X86&quot; unless isX64
</pre>
<hr />
<pre>
 239     def x86LoadOperand(type, dst)
 240         x86Operand(type)
 241     end
 242 end
 243 
 244 class RegisterID
 245     def supports8BitOnX86
 246         case x86GPR
 247         when &quot;eax&quot;, &quot;ebx&quot;, &quot;ecx&quot;, &quot;edx&quot;, &quot;edi&quot;, &quot;esi&quot;, &quot;ebp&quot;, &quot;esp&quot;
 248             true
 249         when &quot;r8&quot;, &quot;r9&quot;, &quot;r10&quot;, &quot;r12&quot;, &quot;r13&quot;, &quot;r14&quot;, &quot;r15&quot;
 250             false
 251         else
 252             raise
 253         end
 254     end
 255 
 256     def x86GPR
 257         if isX64
 258             case name
<span class="line-modified"> 259             when &quot;t0&quot;, &quot;r0&quot;, &quot;ws0&quot;</span>
 260                 &quot;eax&quot;
 261             when &quot;r1&quot;
 262                 &quot;edx&quot; # t1 = a1 when isWin, t2 = a2 otherwise
<span class="line-modified"> 263             when &quot;a0&quot;, &quot;wa0&quot;</span>
 264                 isWin ? &quot;ecx&quot; : &quot;edi&quot;
<span class="line-modified"> 265             when &quot;t1&quot;, &quot;a1&quot;, &quot;wa1&quot;</span>
 266                 isWin ? &quot;edx&quot; : &quot;esi&quot;
<span class="line-modified"> 267             when &quot;t2&quot;, &quot;a2&quot;, &quot;wa2&quot;</span>
 268                 isWin ? &quot;r8&quot; : &quot;edx&quot;
<span class="line-modified"> 269             when &quot;t3&quot;, &quot;a3&quot;, &quot;wa3&quot;</span>
 270                 isWin ? &quot;r9&quot; : &quot;ecx&quot;
<span class="line-modified"> 271             when &quot;t4&quot;, &quot;wa4&quot;</span>
 272                 isWin ? &quot;r10&quot; : &quot;r8&quot;
<span class="line-modified"> 273             when &quot;t5&quot;, &quot;wa5&quot;</span>
<span class="line-modified"> 274                 isWin ? &quot;ecx&quot; : &quot;r9&quot;</span>
<span class="line-added"> 275             when &quot;t6&quot;, &quot;ws1&quot;</span>
<span class="line-added"> 276                 raise &quot;cannot use register #{name} on X86-64 Windows&quot; if isWin</span>
<span class="line-added"> 277                 &quot;r10&quot;</span>
 278             when &quot;csr0&quot;
 279                 &quot;ebx&quot;
 280             when &quot;csr1&quot;
 281                 isWin ? &quot;esi&quot; : &quot;r12&quot;
 282             when &quot;csr2&quot;
 283                 isWin ? &quot;edi&quot; : &quot;r13&quot;
 284             when &quot;csr3&quot;
 285                 isWin ? &quot;r12&quot; : &quot;r14&quot;
 286             when &quot;csr4&quot;
 287                 isWin ? &quot;r13&quot; : &quot;r15&quot;
 288             when &quot;csr5&quot;
 289                 raise &quot;cannot use register #{name} on X86-64&quot; unless isWin
 290                 &quot;r14&quot;
 291             when &quot;csr6&quot;
 292                 raise &quot;cannot use register #{name} on X86-64&quot; unless isWin
 293                 &quot;r15&quot;
 294             when &quot;cfr&quot;
 295                 &quot;ebp&quot;
 296             when &quot;sp&quot;
 297                 &quot;esp&quot;
</pre>
<hr />
<pre>
 314                 &quot;edi&quot;
 315             when &quot;cfr&quot;
 316                 &quot;ebp&quot;
 317             when &quot;sp&quot;
 318                 &quot;esp&quot;
 319             end
 320         end
 321     end
 322 
 323     def x86Operand(kind)
 324         x86GPRName(x86GPR, kind)
 325     end
 326 
 327     def x86CallOperand(kind)
 328         &quot;#{callPrefix}#{x86Operand(:ptr)}&quot;
 329     end
 330 end
 331 
 332 class FPRegisterID
 333     def x86Operand(kind)
<span class="line-modified"> 334         raise unless [:float, :double].include? kind</span>
 335         case name
<span class="line-modified"> 336         when &quot;ft0&quot;, &quot;fa0&quot;, &quot;fr&quot;, &quot;wfa0&quot;</span>
 337             register(&quot;xmm0&quot;)
<span class="line-modified"> 338         when &quot;ft1&quot;, &quot;fa1&quot;, &quot;wfa1&quot;</span>
 339             register(&quot;xmm1&quot;)
<span class="line-modified"> 340         when &quot;ft2&quot;, &quot;fa2&quot;, &quot;wfa2&quot;</span>
 341             register(&quot;xmm2&quot;)
<span class="line-modified"> 342         when &quot;ft3&quot;, &quot;fa3&quot;, &quot;wfa3&quot;</span>
 343             register(&quot;xmm3&quot;)
<span class="line-modified"> 344         when &quot;ft4&quot;, &quot;wfa4&quot;</span>
 345             register(&quot;xmm4&quot;)
<span class="line-modified"> 346         when &quot;ft5&quot;, &quot;wfa5&quot;</span>
 347             register(&quot;xmm5&quot;)
<span class="line-added"> 348         when &quot;wfa6&quot;</span>
<span class="line-added"> 349             register(&quot;xmm6&quot;)</span>
<span class="line-added"> 350         when &quot;wfa7&quot;</span>
<span class="line-added"> 351             register(&quot;xmm7&quot;)</span>
 352         else
 353             raise &quot;Bad register #{name} for X86 at #{codeOriginString}&quot;
 354         end
 355     end
 356     def x86CallOperand(kind)
 357         &quot;#{callPrefix}#{x86Operand(kind)}&quot;
 358     end
 359 end
 360 
 361 class Immediate
 362     def validX86Immediate?
 363         if isX64
 364             value &gt;= -0x80000000 and value &lt;= 0x7fffffff
 365         else
 366             true
 367         end
 368     end
 369     def x86Operand(kind)
 370         &quot;#{const(value)}&quot;
 371     end
</pre>
<hr />
<pre>
 490                         node.is_a? LocalLabel or
 491                         node.is_a? Skip
 492                     raise &quot;Unexpected #{node.inspect} at #{node.codeOrigin}&quot; 
 493                 end
 494             end
 495             if newNode
 496                 newList &lt;&lt; newNode
 497             end
 498         }
 499         
 500         return newList
 501     end
 502     def getModifiedListX86_64_WIN
 503         getModifiedListX86_64
 504     end
 505 end
 506 
 507 class Instruction
 508     
 509     def x86Operands(*kinds)
<span class="line-modified"> 510         raise &quot;Expected size of kinds to be #{operands.size}, but it was #{kinds.size}&quot; unless kinds.size == operands.size</span>
 511         result = []
 512         kinds.size.times {
 513             | idx |
 514             i = isIntelSyntax ? (kinds.size - idx - 1) : idx
 515             result &lt;&lt; operands[i].x86Operand(kinds[i])
 516         }
 517         result.join(&quot;, &quot;)
 518     end
 519     
 520     def x86LoadOperands(srcKind, dstKind)
 521         orderOperands(operands[0].x86LoadOperand(srcKind, operands[1]), operands[1].x86Operand(dstKind))
 522     end
 523 
 524     def x86Suffix(kind)
<span class="line-modified"> 525         if isIntelSyntax and not [:float, :double].include? kind</span>
 526             return &quot;&quot;
 527         end
 528 
 529         case kind
 530         when :byte
 531             &quot;b&quot;
 532         when :half
 533             &quot;w&quot;
 534         when :int
 535             &quot;l&quot;
 536         when :ptr
 537             isX64 ? &quot;q&quot; : &quot;l&quot;
 538         when :quad
 539             isX64 ? &quot;q&quot; : raise
<span class="line-added"> 540         when :float</span>
<span class="line-added"> 541             &quot;ss&quot;</span>
 542         when :double
 543             &quot;sd&quot;
 544         else
 545             raise
 546         end
 547     end
 548     
 549     def x86Bytes(kind)
 550         case kind
 551         when :byte
 552             1
 553         when :half
 554             2
 555         when :int
 556             4
 557         when :ptr
 558             isX64 ? 8 : 4
 559         when :quad
 560             isX64 ? 8 : raise
<span class="line-added"> 561         when :float</span>
<span class="line-added"> 562             4</span>
 563         when :double
 564             8
 565         else
 566             raise
 567         end
 568     end
 569 
 570     def emitX86Lea(src, dst, kind)
 571         if src.is_a? LabelReference
 572             src.used
 573             if !isIntelSyntax
 574                 $asm.puts &quot;movq #{src.asmLabel}@GOTPCREL(%rip), #{dst.x86Operand(:ptr)}&quot;
 575             else
 576                 $asm.puts &quot;lea #{dst.x86Operand(:ptr)}, #{src.asmLabel}&quot;
 577             end
 578         else
 579             $asm.puts &quot;lea#{x86Suffix(kind)} #{orderOperands(src.x86AddressOperand(kind), dst.x86Operand(kind))}&quot;
 580         end
 581     end
 582 
</pre>
<hr />
<pre>
 596             end
 597         else
 598             $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 599         end
 600     end
 601     
 602     def handleX86Op(opcode, kind)
 603         handleX86OpWithNumOperands(opcode, kind, operands.size)
 604     end
 605     
 606     def handleX86Shift(opcode, kind)
 607         if operands[0].is_a? Immediate or operands[0].x86GPR == &quot;ecx&quot;
 608             $asm.puts &quot;#{opcode} #{orderOperands(operands[0].x86Operand(:byte), operands[1].x86Operand(kind))}&quot;
 609         else
 610             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operands[0].x86Operand(:ptr)}, #{x86GPRName(&quot;ecx&quot;, :ptr)}&quot;
 611             $asm.puts &quot;#{opcode} #{orderOperands(register(&quot;cl&quot;), operands[1].x86Operand(kind))}&quot;
 612             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operands[0].x86Operand(:ptr)}, #{x86GPRName(&quot;ecx&quot;, :ptr)}&quot;
 613         end
 614     end
 615     
<span class="line-modified"> 616     def handleX86FPBranch(kind, branchOpcode, mode)</span>
 617         case mode
 618         when :normal
<span class="line-modified"> 619             $asm.puts &quot;ucomi#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(:double), operands[0].x86Operand(:double))}&quot;</span>
 620         when :reverse
<span class="line-modified"> 621             $asm.puts &quot;ucomi#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;</span>
 622         else
 623             raise mode.inspect
 624         end
 625         $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
 626     end
 627     
 628     def handleX86IntCompare(opcodeSuffix, kind)
 629         if operands[0].is_a? Immediate and operands[0].value == 0 and operands[1].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)
 630             $asm.puts &quot;test#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 631         elsif operands[1].is_a? Immediate and operands[1].value == 0 and operands[0].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)
 632             $asm.puts &quot;test#{x86Suffix(kind)}  #{orderOperands(operands[0].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
 633         else
 634             $asm.puts &quot;cmp#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
 635         end
 636     end
 637     
<span class="line-added"> 638     def handleX86IntCompare(opcodeSuffix, kind)</span>
<span class="line-added"> 639         if operands[0].is_a? Immediate and operands[0].value == 0 and operands[1].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)</span>
<span class="line-added"> 640             $asm.puts &quot;test#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[1].x86Operand(kind))}&quot;</span>
<span class="line-added"> 641         elsif operands[1].is_a? Immediate and operands[1].value == 0 and operands[0].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)</span>
<span class="line-added"> 642             $asm.puts &quot;test#{x86Suffix(kind)}  #{orderOperands(operands[0].x86Operand(kind), operands[0].x86Operand(kind))}&quot;</span>
<span class="line-added"> 643         else</span>
<span class="line-added"> 644             $asm.puts &quot;cmp#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind))}&quot;</span>
<span class="line-added"> 645         end</span>
<span class="line-added"> 646     end</span>
<span class="line-added"> 647 </span>
 648     def handleX86IntBranch(branchOpcode, kind)
 649         handleX86IntCompare(branchOpcode[1..-1], kind)
 650         $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
 651     end
 652     
 653     def handleX86Set(setOpcode, operand)
 654         if operand.supports8BitOnX86
 655             $asm.puts &quot;#{setOpcode} #{operand.x86Operand(:byte)}&quot;
 656             if !isIntelSyntax
 657                 $asm.puts &quot;movzbl #{orderOperands(operand.x86Operand(:byte), operand.x86Operand(:int))}&quot;
 658             else
 659                 $asm.puts &quot;movzx #{orderOperands(operand.x86Operand(:byte), operand.x86Operand(:int))}&quot;
 660             end
 661         else
 662             ax = RegisterID.new(nil, &quot;r0&quot;)
 663             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operand.x86Operand(:ptr)}, #{ax.x86Operand(:ptr)}&quot;
 664             $asm.puts &quot;#{setOpcode} #{ax.x86Operand(:byte)}&quot;
 665             if !isIntelSyntax
 666                 $asm.puts &quot;movzbl #{ax.x86Operand(:byte)}, #{ax.x86Operand(:int)}&quot;
 667             else
 668                 $asm.puts &quot;movzx #{ax.x86Operand(:int)}, #{ax.x86Operand(:byte)}&quot;
 669             end
 670             $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operand.x86Operand(:ptr)}, #{ax.x86Operand(:ptr)}&quot;
 671         end
 672     end
 673     
 674     def handleX86IntCompareSet(setOpcode, kind)
 675         handleX86IntCompare(setOpcode[3..-1], kind)
 676         handleX86Set(setOpcode, operands[2])
 677     end
<span class="line-added"> 678 </span>
<span class="line-added"> 679     def handleX86FPCompareSet(kind, setOpcode, order = :normal)</span>
<span class="line-added"> 680         is_special = setOpcode.is_a? Symbol</span>
<span class="line-added"> 681         left = operands[0]</span>
<span class="line-added"> 682         right = operands[1]</span>
<span class="line-added"> 683         target = operands[2]</span>
<span class="line-added"> 684 </span>
<span class="line-added"> 685         compare = lambda do |lhs, rhs|</span>
<span class="line-added"> 686             $asm.puts &quot;ucomi#{x86Suffix(kind)} #{orderOperands(lhs.x86Operand(:double), rhs.x86Operand(:double))}&quot;</span>
<span class="line-added"> 687         end</span>
<span class="line-added"> 688 </span>
<span class="line-added"> 689         if is_special</span>
<span class="line-added"> 690             case setOpcode</span>
<span class="line-added"> 691             when :eq</span>
<span class="line-added"> 692                 if left == right</span>
<span class="line-added"> 693                     compare.call(right, left)</span>
<span class="line-added"> 694                     handleX86Set(&quot;setnp&quot;, operands[2])</span>
<span class="line-added"> 695                     return</span>
<span class="line-added"> 696                 end</span>
<span class="line-added"> 697 </span>
<span class="line-added"> 698                 isUnordered = LocalLabel.unique(&quot;isUnordered&quot;)</span>
<span class="line-added"> 699                 $asm.puts &quot;movq $0, #{target.x86Operand(:quad)}&quot;</span>
<span class="line-added"> 700                 compare.call(right, left)</span>
<span class="line-added"> 701                 $asm.puts &quot;jp #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="line-added"> 702                 handleX86Set(&quot;sete&quot;, target)</span>
<span class="line-added"> 703                 isUnordered.lower($activeBackend)</span>
<span class="line-added"> 704                 return</span>
<span class="line-added"> 705             when :nequn</span>
<span class="line-added"> 706                 if left == right</span>
<span class="line-added"> 707                     compare.call(right, left)</span>
<span class="line-added"> 708                     handleX86Set(&quot;setp&quot;, target)</span>
<span class="line-added"> 709                     return</span>
<span class="line-added"> 710                 end</span>
<span class="line-added"> 711 </span>
<span class="line-added"> 712                 isUnordered = LocalLabel.unique(&quot;isUnordered&quot;)</span>
<span class="line-added"> 713                 $asm.puts &quot;movq $1, #{target.x86Operand(:quad)}&quot;</span>
<span class="line-added"> 714                 compare.call(right, left);</span>
<span class="line-added"> 715                 $asm.puts &quot;jp #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="line-added"> 716                 handleX86Set(&quot;setne&quot;, target)</span>
<span class="line-added"> 717                 isUnordered.lower($activeBackend)</span>
<span class="line-added"> 718                 return</span>
<span class="line-added"> 719             else</span>
<span class="line-added"> 720                 raise &quot;Uhandled special opcode: #{setOpcode}&quot;</span>
<span class="line-added"> 721             end</span>
<span class="line-added"> 722         end</span>
<span class="line-added"> 723 </span>
<span class="line-added"> 724         if order == :normal</span>
<span class="line-added"> 725             compare.call(right, left)</span>
<span class="line-added"> 726         else</span>
<span class="line-added"> 727             compare.call(left, right)</span>
<span class="line-added"> 728         end</span>
<span class="line-added"> 729         handleX86Set(setOpcode, target)</span>
<span class="line-added"> 730     end</span>
 731     
 732     def handleX86Test(kind)
 733         value = operands[0]
 734         case operands.size
 735         when 2
 736             mask = Immediate.new(codeOrigin, -1)
 737         when 3
 738             mask = operands[1]
 739         else
 740             raise &quot;Expected 2 or 3 operands, but got #{operands.size} at #{codeOriginString}&quot;
 741         end
 742         
 743         if mask.is_a? Immediate and mask.value == -1
 744             if value.is_a? RegisterID
 745                 $asm.puts &quot;test#{x86Suffix(kind)} #{value.x86Operand(kind)}, #{value.x86Operand(kind)}&quot;
 746             else
 747                 $asm.puts &quot;cmp#{x86Suffix(kind)} #{orderOperands(const(0), value.x86Operand(kind))}&quot;
 748             end
 749         else
 750             $asm.puts &quot;test#{x86Suffix(kind)} #{orderOperands(mask.x86Operand(kind), value.x86Operand(kind))}&quot;
</pre>
<hr />
<pre>
 808                 $asm.puts &quot;lea#{x86Suffix(kind)} #{orderOperands(offsetRegister(operands[0].value, operands[1].x86Operand(kind)), operands[2].x86Operand(kind))}&quot;
 809             end
 810         elsif operands.size == 3 and operands[0].is_a? RegisterID
 811             raise unless operands[1].is_a? RegisterID
 812             raise unless operands[2].is_a? RegisterID
 813             if operands[0] == operands[2]
 814                 $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 815             else
 816                 if !isIntelSyntax
 817                     $asm.puts &quot;lea#{x86Suffix(kind)} (#{operands[0].x86Operand(kind)}, #{operands[1].x86Operand(kind)}), #{operands[2].x86Operand(kind)}&quot;
 818                 else
 819                     $asm.puts &quot;lea#{x86Suffix(kind)} #{operands[2].x86Operand(kind)}, [#{operands[0].x86Operand(kind)} + #{operands[1].x86Operand(kind)}]&quot;
 820                 end
 821             end
 822         else
 823             unless Immediate.new(nil, 0) == operands[0]
 824                 $asm.puts &quot;add#{x86Suffix(kind)} #{x86Operands(kind, kind)}&quot;
 825             end
 826         end
 827     end
<span class="line-modified"> 828 </span>
 829     def handleX86Sub(kind)
 830         if operands.size == 3
 831             if Immediate.new(nil, 0) == operands[1]
 832                 raise unless operands[0].is_a? RegisterID
 833                 raise unless operands[2].is_a? RegisterID
 834                 if operands[0] != operands[2]
 835                     $asm.puts &quot;mov#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 836                 end
 837                 return
 838             end
 839             if operands[1] == operands[2]
 840                 $asm.puts &quot;neg#{x86Suffix(kind)} #{operands[2].x86Operand(kind)}&quot;
 841                 if Immediate.new(nil, 0) != operands[0]
 842                     $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;
 843                 end
 844                 return
 845             end
 846         end
 847 
 848         if operands.size == 2
</pre>
<hr />
<pre>
 854         handleX86Op(&quot;sub#{x86Suffix(kind)}&quot;, kind)
 855     end
 856     
 857     def handleX86Mul(kind)
 858         if operands.size == 3 and operands[0].is_a? Immediate
 859             $asm.puts &quot;imul#{x86Suffix(kind)} #{x86Operands(kind, kind, kind)}&quot;
 860             return
 861         end
 862 
 863         if operands.size == 2 and operands[0].is_a? Immediate
 864             imm = operands[0].value
 865             if imm &gt; 0 and isPowerOfTwo(imm)
 866                 $asm.puts &quot;sal#{x86Suffix(kind)} #{orderOperands(Immediate.new(nil, Math.log2(imm).to_i).x86Operand(kind), operands[1].x86Operand(kind))}&quot;
 867                 return
 868             end
 869         end
 870 
 871         handleX86Op(&quot;imul#{x86Suffix(kind)}&quot;, kind)
 872     end
 873     
<span class="line-added"> 874     def handleX86AddFP(kind)</span>
<span class="line-added"> 875         if operands.size == 2</span>
<span class="line-added"> 876             $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;</span>
<span class="line-added"> 877         elsif operands.size == 3</span>
<span class="line-added"> 878             $asm.puts &quot;vadd#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;</span>
<span class="line-added"> 879         else</span>
<span class="line-added"> 880             raise &quot;Unexpected number of operands for floating point addition: #{operands.size}&quot;</span>
<span class="line-added"> 881         end</span>
<span class="line-added"> 882     end</span>
<span class="line-added"> 883 </span>
<span class="line-added"> 884     def handleX86SubFP(kind)</span>
<span class="line-added"> 885         if operands.size == 2</span>
<span class="line-added"> 886             $asm.puts &quot;sub#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;</span>
<span class="line-added"> 887         elsif operands.size == 3</span>
<span class="line-added"> 888             $asm.puts &quot;vsub#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;</span>
<span class="line-added"> 889         else</span>
<span class="line-added"> 890             raise &quot;Unexpected number of operands for floating point addition: #{operands.size}&quot;</span>
<span class="line-added"> 891         end</span>
<span class="line-added"> 892     end</span>
<span class="line-added"> 893 </span>
<span class="line-added"> 894     def handleX86MulFP(kind)</span>
<span class="line-added"> 895         if operands.size == 2</span>
<span class="line-added"> 896             $asm.puts &quot;mul#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;</span>
<span class="line-added"> 897         elsif operands.size == 3</span>
<span class="line-added"> 898             $asm.puts &quot;vmul#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;</span>
<span class="line-added"> 899         else</span>
<span class="line-added"> 900             raise &quot;Unexpected number of operands for floating point addition: #{operands.size}&quot;</span>
<span class="line-added"> 901         end</span>
<span class="line-added"> 902     end</span>
<span class="line-added"> 903 </span>
<span class="line-added"> 904     def handleX86DivFP(kind)</span>
<span class="line-added"> 905         if operands.size == 2</span>
<span class="line-added"> 906             $asm.puts &quot;div#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;</span>
<span class="line-added"> 907         elsif operands.size == 3</span>
<span class="line-added"> 908             $asm.puts &quot;vdiv#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;</span>
<span class="line-added"> 909         else</span>
<span class="line-added"> 910             raise &quot;Unexpected number of operands for floating point addition: #{operands.size}&quot;</span>
<span class="line-added"> 911         end</span>
<span class="line-added"> 912     end</span>
<span class="line-added"> 913 </span>
 914     def handleX86Peek()
 915         sp = RegisterID.new(nil, &quot;sp&quot;)
 916         opA = offsetRegister(operands[0].value * x86Bytes(:ptr), sp.x86Operand(:ptr))
 917         opB = operands[1].x86Operand(:ptr)
 918         $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(opA, opB)}&quot;
 919     end
 920 
 921     def handleX86Poke()
 922         sp = RegisterID.new(nil, &quot;sp&quot;)
 923         opA = operands[0].x86Operand(:ptr)
 924         opB = offsetRegister(operands[1].value * x86Bytes(:ptr), sp.x86Operand(:ptr))
 925         $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(opA, opB)}&quot;
 926     end
 927 
 928     def handleMove
 929         if Immediate.new(nil, 0) == operands[0] and operands[1].is_a? RegisterID
 930             if isX64
 931                 $asm.puts &quot;xor#{x86Suffix(:quad)} #{operands[1].x86Operand(:quad)}, #{operands[1].x86Operand(:quad)}&quot;
 932             else
 933                 $asm.puts &quot;xor#{x86Suffix(:ptr)} #{operands[1].x86Operand(:ptr)}, #{operands[1].x86Operand(:ptr)}&quot;
 934             end
 935         elsif operands[0] != operands[1]
 936             if isX64
 937                 $asm.puts &quot;mov#{x86Suffix(:quad)} #{x86Operands(:quad, :quad)}&quot;
 938             else
 939                 $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86Operands(:ptr, :ptr)}&quot;
 940             end
 941         end
 942     end
 943 
<span class="line-added"> 944     def countLeadingZeros(kind)</span>
<span class="line-added"> 945         target = operands[1]</span>
<span class="line-added"> 946         srcIsNonZero = LocalLabel.unique(&quot;srcIsNonZero&quot;)</span>
<span class="line-added"> 947         skipNonZeroCase = LocalLabel.unique(&quot;skipNonZeroCase&quot;)</span>
<span class="line-added"> 948         zeroValue = Immediate.new(codeOrigin, x86Bytes(kind) * 8)</span>
<span class="line-added"> 949         xorValue = Immediate.new(codeOrigin, kind == :quad ? 0x3f : 0x1f)</span>
<span class="line-added"> 950         xor = kind == :quad ? &quot;xorq&quot; : &quot;xori&quot;</span>
<span class="line-added"> 951 </span>
<span class="line-added"> 952         $asm.puts &quot;bsr#{x86Suffix(kind)} #{x86Operands(kind, kind)}&quot;</span>
<span class="line-added"> 953 </span>
<span class="line-added"> 954         Sequence.new(codeOrigin, [</span>
<span class="line-added"> 955             Instruction.new(codeOrigin, &quot;bnz&quot;, [LocalLabelReference.new(codeOrigin, srcIsNonZero)]),</span>
<span class="line-added"> 956             Instruction.new(codeOrigin, &quot;move&quot;, [zeroValue, target]),</span>
<span class="line-added"> 957             Instruction.new(codeOrigin, &quot;jmp&quot;, [LocalLabelReference.new(codeOrigin, skipNonZeroCase)]),</span>
<span class="line-added"> 958 </span>
<span class="line-added"> 959             srcIsNonZero,</span>
<span class="line-added"> 960             Instruction.new(codeOrigin, xor, [xorValue, target]),</span>
<span class="line-added"> 961 </span>
<span class="line-added"> 962             skipNonZeroCase,</span>
<span class="line-added"> 963         ]).lower($activeBackend)</span>
<span class="line-added"> 964     end</span>
<span class="line-added"> 965 </span>
<span class="line-added"> 966     def countTrailingZeros(kind)</span>
<span class="line-added"> 967         target = operands[1]</span>
<span class="line-added"> 968         srcIsNonZero = LocalLabel.unique(&quot;srcIsNonZero&quot;)</span>
<span class="line-added"> 969         zeroValue = Immediate.new(codeOrigin, x86Bytes(kind) * 8)</span>
<span class="line-added"> 970 </span>
<span class="line-added"> 971         $asm.puts &quot;bsf#{x86Suffix(kind)} #{x86Operands(kind, kind)}&quot;</span>
<span class="line-added"> 972 </span>
<span class="line-added"> 973         Sequence.new(codeOrigin, [</span>
<span class="line-added"> 974             Instruction.new(codeOrigin, &quot;bnz&quot;, [LocalLabelReference.new(codeOrigin, srcIsNonZero)]),</span>
<span class="line-added"> 975             Instruction.new(codeOrigin, &quot;move&quot;, [zeroValue, target]),</span>
<span class="line-added"> 976             srcIsNonZero,</span>
<span class="line-added"> 977         ]).lower($activeBackend)</span>
<span class="line-added"> 978     end</span>
<span class="line-added"> 979 </span>
<span class="line-added"> 980     def truncateFloatingPointToQuad(kind)</span>
<span class="line-added"> 981         src = operands[0]</span>
<span class="line-added"> 982         dst = operands[1]</span>
<span class="line-added"> 983         slow = LocalLabel.unique(&quot;slow&quot;)</span>
<span class="line-added"> 984         done = LocalLabel.unique(&quot;done&quot;)</span>
<span class="line-added"> 985         gprScratch = X64_SCRATCH_REGISTER</span>
<span class="line-added"> 986         fprScratch = FPRegisterID.forName(codeOrigin, &quot;wfa7&quot;)</span>
<span class="line-added"> 987         int64SignBit = Immediate.new(codeOrigin, 0x8000000000000000)</span>
<span class="line-added"> 988         case kind</span>
<span class="line-added"> 989         when :float</span>
<span class="line-added"> 990             int64Min = Immediate.new(codeOrigin, 0xdf000000)</span>
<span class="line-added"> 991             negInt64Min = Immediate.new(codeOrigin, 0x5f000000)</span>
<span class="line-added"> 992             integerSuffix = &quot;i&quot;</span>
<span class="line-added"> 993             floatingSuffix = &quot;f&quot;</span>
<span class="line-added"> 994         when :double</span>
<span class="line-added"> 995             int64Min = Immediate.new(codeOrigin, 0xc3e0000000000000)</span>
<span class="line-added"> 996             negInt64Min = Immediate.new(codeOrigin, 0x43e0000000000000)</span>
<span class="line-added"> 997             integerSuffix = &quot;q&quot;</span>
<span class="line-added"> 998             floatingSuffix = &quot;d&quot;</span>
<span class="line-added"> 999         else</span>
<span class="line-added">1000             raise</span>
<span class="line-added">1001         end</span>
<span class="line-added">1002 </span>
<span class="line-added">1003         Sequence.new(codeOrigin, [</span>
<span class="line-added">1004             Instruction.new(codeOrigin, &quot;move&quot;, [negInt64Min, gprScratch]),</span>
<span class="line-added">1005             Instruction.new(codeOrigin, &quot;f#{integerSuffix}2#{floatingSuffix}&quot;, [gprScratch, fprScratch]),</span>
<span class="line-added">1006             Instruction.new(codeOrigin, &quot;b#{floatingSuffix}gteq&quot;, [src, fprScratch, LocalLabelReference.new(codeOrigin, slow)]),</span>
<span class="line-added">1007             Instruction.new(codeOrigin, &quot;truncate#{floatingSuffix}2qs&quot;, [src, dst]),</span>
<span class="line-added">1008             Instruction.new(codeOrigin, &quot;jmp&quot;, [LocalLabelReference.new(codeOrigin, done)]),</span>
<span class="line-added">1009 </span>
<span class="line-added">1010             slow,</span>
<span class="line-added">1011             Instruction.new(codeOrigin, &quot;move&quot;, [int64Min, gprScratch]),</span>
<span class="line-added">1012             Instruction.new(codeOrigin, &quot;f#{integerSuffix}2#{floatingSuffix}&quot;, [gprScratch, fprScratch]),</span>
<span class="line-added">1013             Instruction.new(codeOrigin, &quot;add#{floatingSuffix}&quot;, [src, fprScratch]),</span>
<span class="line-added">1014             Instruction.new(codeOrigin, &quot;truncate#{floatingSuffix}2qs&quot;, [fprScratch, dst]),</span>
<span class="line-added">1015             Instruction.new(codeOrigin, &quot;move&quot;, [int64SignBit, gprScratch]),</span>
<span class="line-added">1016             Instruction.new(codeOrigin, &quot;orq&quot;, [gprScratch, dst]),</span>
<span class="line-added">1017 </span>
<span class="line-added">1018             done,</span>
<span class="line-added">1019         ]).lower($activeBackend)</span>
<span class="line-added">1020     end</span>
<span class="line-added">1021 </span>
<span class="line-added">1022     def convertQuadToFloatingPoint(kind)</span>
<span class="line-added">1023         src = operands[0]</span>
<span class="line-added">1024         scratch1 = operands[1]</span>
<span class="line-added">1025         dst = operands[2]</span>
<span class="line-added">1026         slow = LocalLabel.unique(&quot;slow&quot;)</span>
<span class="line-added">1027         done = LocalLabel.unique(&quot;done&quot;)</span>
<span class="line-added">1028         scratch2 = X64_SCRATCH_REGISTER</span>
<span class="line-added">1029         one = Immediate.new(codeOrigin, 0x1)</span>
<span class="line-added">1030 </span>
<span class="line-added">1031         case kind</span>
<span class="line-added">1032         when :float</span>
<span class="line-added">1033             floatingSuffix = &quot;f&quot;</span>
<span class="line-added">1034         when :double</span>
<span class="line-added">1035             floatingSuffix = &quot;d&quot;</span>
<span class="line-added">1036         else</span>
<span class="line-added">1037             raise</span>
<span class="line-added">1038         end</span>
<span class="line-added">1039 </span>
<span class="line-added">1040         Sequence.new(codeOrigin, [</span>
<span class="line-added">1041             Instruction.new(codeOrigin, &quot;btqs&quot;, [src, LocalLabelReference.new(codeOrigin, slow)]),</span>
<span class="line-added">1042             Instruction.new(codeOrigin, &quot;cq2#{floatingSuffix}s&quot;, [src, dst]),</span>
<span class="line-added">1043             Instruction.new(codeOrigin, &quot;jmp&quot;, [LocalLabelReference.new(codeOrigin, done)]),</span>
<span class="line-added">1044 </span>
<span class="line-added">1045             slow,</span>
<span class="line-added">1046             Instruction.new(codeOrigin, &quot;move&quot;, [src, scratch1]),</span>
<span class="line-added">1047             Instruction.new(codeOrigin, &quot;move&quot;, [src, scratch2]),</span>
<span class="line-added">1048             Instruction.new(codeOrigin, &quot;urshiftq&quot;, [one, scratch1]),</span>
<span class="line-added">1049             Instruction.new(codeOrigin, &quot;andq&quot;, [one, scratch2]),</span>
<span class="line-added">1050             Instruction.new(codeOrigin, &quot;orq&quot;, [scratch1, scratch2]),</span>
<span class="line-added">1051             Instruction.new(codeOrigin, &quot;cq2#{floatingSuffix}s&quot;, [scratch2, dst]),</span>
<span class="line-added">1052             Instruction.new(codeOrigin, &quot;add#{floatingSuffix}&quot;, [dst, dst]),</span>
<span class="line-added">1053 </span>
<span class="line-added">1054             done,</span>
<span class="line-added">1055         ]).lower($activeBackend)</span>
<span class="line-added">1056     end</span>
<span class="line-added">1057 </span>
1058     def lowerX86
1059         raise unless $activeBackend == &quot;X86&quot;
1060         lowerX86Common
1061     end
1062 
1063     def lowerX86_WIN
1064         raise unless $activeBackend == &quot;X86_WIN&quot; 
1065         lowerX86Common
1066     end
1067     
1068     def lowerX86_64
1069         raise unless $activeBackend == &quot;X86_64&quot;
1070         lowerX86Common
1071     end
1072 
1073     def lowerX86_64_WIN
1074         raise unless $activeBackend == &quot;X86_64_WIN&quot;
1075         lowerX86Common
1076     end
1077 
1078     def lowerX86Common
1079         case opcode
1080         when &quot;addi&quot;
1081             handleX86Add(:int)
1082         when &quot;addp&quot;
1083             handleX86Add(:ptr)
1084         when &quot;addq&quot;
1085             handleX86Add(:quad)
1086         when &quot;andi&quot;
1087             handleX86Op(&quot;and#{x86Suffix(:int)}&quot;, :int)
1088         when &quot;andp&quot;
1089             handleX86Op(&quot;and#{x86Suffix(:ptr)}&quot;, :ptr)
1090         when &quot;andq&quot;
1091             handleX86Op(&quot;and#{x86Suffix(:quad)}&quot;, :quad)
<span class="line-added">1092         when &quot;andf&quot;</span>
<span class="line-added">1093             handleX86Op(&quot;andps&quot;, :float)</span>
<span class="line-added">1094         when &quot;andd&quot;</span>
<span class="line-added">1095             handleX86Op(&quot;andpd&quot;, :double)</span>
1096         when &quot;lshifti&quot;
1097             handleX86Shift(&quot;sal#{x86Suffix(:int)}&quot;, :int)
1098         when &quot;lshiftp&quot;
1099             handleX86Shift(&quot;sal#{x86Suffix(:ptr)}&quot;, :ptr)
1100         when &quot;lshiftq&quot;
1101             handleX86Shift(&quot;sal#{x86Suffix(:quad)}&quot;, :quad)
1102         when &quot;muli&quot;
1103             handleX86Mul(:int)
1104         when &quot;mulp&quot;
1105             handleX86Mul(:ptr)
1106         when &quot;mulq&quot;
1107             handleX86Mul(:quad)
1108         when &quot;negi&quot;
1109             $asm.puts &quot;neg#{x86Suffix(:int)} #{x86Operands(:int)}&quot;
1110         when &quot;negp&quot;
1111             $asm.puts &quot;neg#{x86Suffix(:ptr)} #{x86Operands(:ptr)}&quot;
1112         when &quot;negq&quot;
1113             $asm.puts &quot;neg#{x86Suffix(:quad)} #{x86Operands(:quad)}&quot;
1114         when &quot;noti&quot;
1115             $asm.puts &quot;not#{x86Suffix(:int)} #{x86Operands(:int)}&quot;
1116         when &quot;ori&quot;
1117             handleX86Op(&quot;or#{x86Suffix(:int)}&quot;, :int)
1118         when &quot;orp&quot;
1119             handleX86Op(&quot;or#{x86Suffix(:ptr)}&quot;, :ptr)
1120         when &quot;orq&quot;
1121             handleX86Op(&quot;or#{x86Suffix(:quad)}&quot;, :quad)
<span class="line-added">1122         when &quot;orf&quot;</span>
<span class="line-added">1123             handleX86Op(&quot;orps&quot;, :float)</span>
<span class="line-added">1124         when &quot;ord&quot;</span>
<span class="line-added">1125             handleX86Op(&quot;orpd&quot;, :double)</span>
<span class="line-added">1126         when &quot;orh&quot;</span>
<span class="line-added">1127             handleX86Op(&quot;or#{x86Suffix(:half)}&quot;, :half)</span>
1128         when &quot;rshifti&quot;
1129             handleX86Shift(&quot;sar#{x86Suffix(:int)}&quot;, :int)
1130         when &quot;rshiftp&quot;
1131             handleX86Shift(&quot;sar#{x86Suffix(:ptr)}&quot;, :ptr)
1132         when &quot;rshiftq&quot;
1133             handleX86Shift(&quot;sar#{x86Suffix(:quad)}&quot;, :quad)
1134         when &quot;urshifti&quot;
1135             handleX86Shift(&quot;shr#{x86Suffix(:int)}&quot;, :int)
1136         when &quot;urshiftp&quot;
1137             handleX86Shift(&quot;shr#{x86Suffix(:ptr)}&quot;, :ptr)
1138         when &quot;urshiftq&quot;
1139             handleX86Shift(&quot;shr#{x86Suffix(:quad)}&quot;, :quad)
<span class="line-added">1140         when &quot;rrotatei&quot;</span>
<span class="line-added">1141             handleX86Shift(&quot;ror#{x86Suffix(:int)}&quot;, :int)</span>
<span class="line-added">1142         when &quot;rrotateq&quot;</span>
<span class="line-added">1143             handleX86Shift(&quot;ror#{x86Suffix(:quad)}&quot;, :quad)</span>
<span class="line-added">1144         when &quot;lrotatei&quot;</span>
<span class="line-added">1145             handleX86Shift(&quot;rol#{x86Suffix(:int)}&quot;, :int)</span>
<span class="line-added">1146         when &quot;lrotateq&quot;</span>
<span class="line-added">1147             handleX86Shift(&quot;rol#{x86Suffix(:quad)}&quot;, :quad)</span>
1148         when &quot;subi&quot;
1149             handleX86Sub(:int)
1150         when &quot;subp&quot;
1151             handleX86Sub(:ptr)
1152         when &quot;subq&quot;
1153             handleX86Sub(:quad)
1154         when &quot;xori&quot;
1155             handleX86Op(&quot;xor#{x86Suffix(:int)}&quot;, :int)
1156         when &quot;xorp&quot;
1157             handleX86Op(&quot;xor#{x86Suffix(:ptr)}&quot;, :ptr)
1158         when &quot;xorq&quot;
1159             handleX86Op(&quot;xor#{x86Suffix(:quad)}&quot;, :quad)
1160         when &quot;leap&quot;
1161             emitX86Lea(operands[0], operands[1], :ptr)
1162         when &quot;loadi&quot;
1163             $asm.puts &quot;mov#{x86Suffix(:int)} #{x86LoadOperands(:int, :int)}&quot;
1164         when &quot;storei&quot;
1165             $asm.puts &quot;mov#{x86Suffix(:int)} #{x86Operands(:int, :int)}&quot;
1166         when &quot;loadis&quot;
1167             if isX64
</pre>
<hr />
<pre>
1202         when &quot;loadh&quot;
1203             if !isIntelSyntax
1204                 $asm.puts &quot;movzwl #{x86LoadOperands(:half, :int)}&quot;
1205             else
1206                 $asm.puts &quot;movzx #{x86LoadOperands(:half, :int)}&quot;
1207             end
1208         when &quot;loadhsi&quot;
1209             if !isIntelSyntax
1210                 $asm.puts &quot;movswl #{x86LoadOperands(:half, :int)}&quot;
1211             else
1212                 $asm.puts &quot;movsx #{x86LoadOperands(:half, :int)}&quot;
1213             end
1214         when &quot;loadhsq&quot;
1215             if !isIntelSyntax
1216                 $asm.puts &quot;movswq #{x86LoadOperands(:half, :quad)}&quot;
1217             else
1218                 $asm.puts &quot;movsx #{x86LoadOperands(:half, :quad)}&quot;
1219             end
1220         when &quot;storeb&quot;
1221             $asm.puts &quot;mov#{x86Suffix(:byte)} #{x86Operands(:byte, :byte)}&quot;
<span class="line-added">1222         when &quot;storeh&quot;</span>
<span class="line-added">1223             $asm.puts &quot;mov#{x86Suffix(:half)} #{x86Operands(:half, :half)}&quot;</span>
<span class="line-added">1224         when &quot;loadf&quot;</span>
<span class="line-added">1225             $asm.puts &quot;movss #{x86Operands(:float, :float)}&quot;</span>
1226         when &quot;loadd&quot;
1227             $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;
1228         when &quot;moved&quot;
1229             $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;
<span class="line-added">1230         when &quot;storef&quot;</span>
<span class="line-added">1231             $asm.puts &quot;movss #{x86Operands(:float, :float)}&quot;</span>
1232         when &quot;stored&quot;
1233             $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;
<span class="line-added">1234         when &quot;addf&quot;</span>
<span class="line-added">1235             handleX86AddFP(:float)</span>
1236         when &quot;addd&quot;
<span class="line-modified">1237             handleX86AddFP(:double)</span>
<span class="line-added">1238         when &quot;mulf&quot;</span>
<span class="line-added">1239             handleX86MulFP(:float)</span>
1240         when &quot;muld&quot;
<span class="line-modified">1241             handleX86MulFP(:double)</span>
<span class="line-added">1242         when &quot;subf&quot;</span>
<span class="line-added">1243             handleX86SubFP(:float)</span>
1244         when &quot;subd&quot;
<span class="line-modified">1245             handleX86SubFP(:double)</span>
<span class="line-added">1246         when &quot;divf&quot;</span>
<span class="line-added">1247             handleX86DivFP(:float)</span>
1248         when &quot;divd&quot;
<span class="line-modified">1249             handleX86DivFP(:double)</span>
<span class="line-added">1250         when &quot;sqrtf&quot;</span>
<span class="line-added">1251             $asm.puts &quot;sqrtss #{operands[0].x86Operand(:float)}, #{operands[1].x86Operand(:float)}&quot;</span>
1252         when &quot;sqrtd&quot;
1253             $asm.puts &quot;sqrtsd #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;
<span class="line-added">1254         when &quot;roundf&quot;</span>
<span class="line-added">1255             $asm.puts &quot;roundss $0, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="line-added">1256         when &quot;roundd&quot;</span>
<span class="line-added">1257             $asm.puts &quot;roundsd $0, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="line-added">1258         when &quot;floorf&quot;</span>
<span class="line-added">1259             $asm.puts &quot;roundss $1, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="line-added">1260         when &quot;floord&quot;</span>
<span class="line-added">1261             $asm.puts &quot;roundsd $1, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="line-added">1262         when &quot;ceilf&quot;</span>
<span class="line-added">1263             $asm.puts &quot;roundss $2, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="line-added">1264         when &quot;ceild&quot;</span>
<span class="line-added">1265             $asm.puts &quot;roundsd $2, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="line-added">1266         when &quot;truncatef&quot;</span>
<span class="line-added">1267             $asm.puts &quot;roundss $3, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="line-added">1268         when &quot;truncated&quot;</span>
<span class="line-added">1269             $asm.puts &quot;roundsd $3, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="line-added">1270         when &quot;truncatef2i&quot;</span>
<span class="line-added">1271             $asm.puts &quot;cvttss2si #{operands[0].x86Operand(:float)}, #{operands[1].x86Operand(:quad)}&quot;</span>
<span class="line-added">1272         when &quot;truncated2i&quot;</span>
<span class="line-added">1273             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:quad)}&quot;</span>
<span class="line-added">1274         when &quot;truncatef2q&quot;</span>
<span class="line-added">1275             truncateFloatingPointToQuad(:float)</span>
<span class="line-added">1276         when &quot;truncated2q&quot;</span>
<span class="line-added">1277             truncateFloatingPointToQuad(:double)</span>
<span class="line-added">1278         when &quot;truncatef2is&quot;</span>
<span class="line-added">1279             $asm.puts &quot;cvttss2si #{operands[0].x86Operand(:float)}, #{operands[1].x86Operand(:int)}&quot;</span>
<span class="line-added">1280         when &quot;truncatef2qs&quot;</span>
<span class="line-added">1281             $asm.puts &quot;cvttss2si #{operands[0].x86Operand(:float)}, #{operands[1].x86Operand(:quad)}&quot;</span>
<span class="line-added">1282         when &quot;truncated2is&quot;</span>
<span class="line-added">1283             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;</span>
<span class="line-added">1284         when &quot;truncated2qs&quot;</span>
<span class="line-added">1285             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:quad)}&quot;</span>
1286         when &quot;ci2d&quot;
<span class="line-added">1287             $asm.puts &quot;cvtsi2sd #{orderOperands(operands[0].x86Operand(:quad), operands[1].x86Operand(:double))}&quot;</span>
<span class="line-added">1288         when &quot;ci2ds&quot;</span>
1289             $asm.puts &quot;cvtsi2sd #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:double))}&quot;
<span class="line-added">1290         when &quot;ci2fs&quot;</span>
<span class="line-added">1291             $asm.puts &quot;cvtsi2ss #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:float))}&quot;</span>
<span class="line-added">1292         when &quot;ci2f&quot;</span>
<span class="line-added">1293             $asm.puts &quot;cvtsi2ss #{orderOperands(operands[0].x86Operand(:quad), operands[1].x86Operand(:float))}&quot;</span>
<span class="line-added">1294         when &quot;cq2f&quot;</span>
<span class="line-added">1295             convertQuadToFloatingPoint(:float)</span>
<span class="line-added">1296         when &quot;cq2d&quot;</span>
<span class="line-added">1297             convertQuadToFloatingPoint(:double)</span>
<span class="line-added">1298         when &quot;cq2fs&quot;</span>
<span class="line-added">1299             $asm.puts &quot;cvtsi2ssq #{orderOperands(operands[0].x86Operand(:quad), operands[1].x86Operand(:float))}&quot;</span>
<span class="line-added">1300         when &quot;cq2ds&quot;</span>
<span class="line-added">1301             $asm.puts &quot;cvtsi2sdq #{orderOperands(operands[0].x86Operand(:quad), operands[1].x86Operand(:double))}&quot;</span>
<span class="line-added">1302         when &quot;cd2f&quot;</span>
<span class="line-added">1303             $asm.puts &quot;cvtsd2ss #{x86Operands(:double, :float)}&quot;</span>
<span class="line-added">1304         when &quot;cf2d&quot;</span>
<span class="line-added">1305             $asm.puts &quot;cvtss2sd #{x86Operands(:float, :double)}&quot;</span>
1306         when &quot;bdeq&quot;
1307             $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
1308             if operands[0] == operands[1]
1309                 # This is just a jump ordered, which is a jnp.
1310                 $asm.puts &quot;jnp #{operands[2].asmLabel}&quot;
1311             else
1312                 isUnordered = LocalLabel.unique(&quot;bdeq&quot;)
<span class="line-modified">1313                 $asm.puts &quot;jp #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="line-modified">1314                 $asm.puts &quot;je #{LocalLabelReference.new(codeOrigin, operands[2]).asmLabel}&quot;</span>
<span class="line-modified">1315                 isUnordered.lower($activeBackend)</span>
1316             end
1317         when &quot;bdneq&quot;
<span class="line-modified">1318             handleX86FPBranch(:double, &quot;jne&quot;, :normal)</span>
1319         when &quot;bdgt&quot;
<span class="line-modified">1320             handleX86FPBranch(:double, &quot;ja&quot;, :normal)</span>
1321         when &quot;bdgteq&quot;
<span class="line-modified">1322             handleX86FPBranch(:double, &quot;jae&quot;, :normal)</span>
1323         when &quot;bdlt&quot;
<span class="line-modified">1324             handleX86FPBranch(:double, &quot;ja&quot;, :reverse)</span>
1325         when &quot;bdlteq&quot;
<span class="line-modified">1326             handleX86FPBranch(:double, &quot;jae&quot;, :reverse)</span>
1327         when &quot;bdequn&quot;
<span class="line-modified">1328             handleX86FPBranch(:double, &quot;je&quot;, :normal)</span>
1329         when &quot;bdnequn&quot;
1330             $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
1331             if operands[0] == operands[1]
1332                 # This is just a jump unordered, which is a jp.
1333                 $asm.puts &quot;jp #{operands[2].asmLabel}&quot;
1334             else
1335                 isUnordered = LocalLabel.unique(&quot;bdnequn&quot;)
1336                 isEqual = LocalLabel.unique(&quot;bdnequn&quot;)
<span class="line-modified">1337                 $asm.puts &quot;jp #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="line-modified">1338                 $asm.puts &quot;je #{LocalLabelReference.new(codeOrigin, isEqual).asmLabel}&quot;</span>
<span class="line-modified">1339                 isUnordered.lower($activeBackend)</span>
1340                 $asm.puts &quot;jmp #{operands[2].asmLabel}&quot;
<span class="line-modified">1341                 isEqual.lower($activeBackend)</span>
1342             end
1343         when &quot;bdgtun&quot;
<span class="line-modified">1344             handleX86FPBranch(:double, &quot;jb&quot;, :reverse)</span>
1345         when &quot;bdgtequn&quot;
<span class="line-modified">1346             handleX86FPBranch(:double, &quot;jbe&quot;, :reverse)</span>
1347         when &quot;bdltun&quot;
<span class="line-modified">1348             handleX86FPBranch(:double, &quot;jb&quot;, :normal)</span>
1349         when &quot;bdltequn&quot;
<span class="line-modified">1350             handleX86FPBranch(:double, &quot;jbe&quot;, :normal)</span>
<span class="line-added">1351         when &quot;bfeq&quot;</span>
<span class="line-added">1352             $asm.puts &quot;ucomiss #{orderOperands(operands[0].x86Operand(:float), operands[1].x86Operand(:float))}&quot;</span>
<span class="line-added">1353             if operands[0] == operands[1]</span>
<span class="line-added">1354                 # This is just a jump ordered, which is a jnp.</span>
<span class="line-added">1355                 $asm.puts &quot;jnp #{operands[2].asmLabel}&quot;</span>
<span class="line-added">1356             else</span>
<span class="line-added">1357                 isUnordered = LocalLabel.unique(&quot;bfeq&quot;)</span>
<span class="line-added">1358                 $asm.puts &quot;jp #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="line-added">1359                 $asm.puts &quot;je #{LocalLabelReference.new(codeOrigin, operands[2]).asmLabel}&quot;</span>
<span class="line-added">1360                 isUnordered.lower($activeBackend)</span>
<span class="line-added">1361             end</span>
<span class="line-added">1362         when &quot;bfgt&quot;</span>
<span class="line-added">1363             handleX86FPBranch(:float, &quot;ja&quot;, :normal)</span>
<span class="line-added">1364         when &quot;bfgteq&quot;</span>
<span class="line-added">1365             handleX86FPBranch(:float, &quot;jae&quot;, :normal)</span>
<span class="line-added">1366         when &quot;bflt&quot;</span>
<span class="line-added">1367             handleX86FPBranch(:float, &quot;ja&quot;, :reverse)</span>
<span class="line-added">1368         when &quot;bfgtun&quot;</span>
<span class="line-added">1369             handleX86FPBranch(:float, &quot;jb&quot;, :reverse)</span>
<span class="line-added">1370         when &quot;bfgtequn&quot;</span>
<span class="line-added">1371             handleX86FPBranch(:float, &quot;jbe&quot;, :reverse)</span>
<span class="line-added">1372         when &quot;bfltun&quot;</span>
<span class="line-added">1373             handleX86FPBranch(:float, &quot;jb&quot;, :normal)</span>
<span class="line-added">1374         when &quot;bfltequn&quot;</span>
<span class="line-added">1375             handleX86FPBranch(:float, &quot;jbe&quot;, :normal)</span>
1376         when &quot;btd2i&quot;
1377             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1378             $asm.puts &quot;cmpl $0x80000000 #{operands[1].x86Operand(:int)}&quot;
1379             $asm.puts &quot;je #{operands[2].asmLabel}&quot;
1380         when &quot;td2i&quot;
1381             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1382         when &quot;bcd2i&quot;
1383             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1384             $asm.puts &quot;test#{x86Suffix(:int)} #{operands[1].x86Operand(:int)}, #{operands[1].x86Operand(:int)}&quot;
1385             $asm.puts &quot;je #{operands[2].asmLabel}&quot;
1386             $asm.puts &quot;cvtsi2sd #{operands[1].x86Operand(:int)}, %xmm7&quot;
1387             $asm.puts &quot;ucomisd #{operands[0].x86Operand(:double)}, %xmm7&quot;
1388             $asm.puts &quot;jp #{operands[2].asmLabel}&quot;
1389             $asm.puts &quot;jne #{operands[2].asmLabel}&quot;
1390         when &quot;movdz&quot;
1391             $asm.puts &quot;xorpd #{operands[0].x86Operand(:double)}, #{operands[0].x86Operand(:double)}&quot;
1392         when &quot;pop&quot;
1393             operands.each {
1394                 | op |
1395                 $asm.puts &quot;pop #{op.x86Operand(:ptr)}&quot;
</pre>
<hr />
<pre>
1638         when &quot;cpgteq&quot;
1639             handleX86IntCompareSet(&quot;setge&quot;, :ptr)
1640         when &quot;cqgteq&quot;
1641             handleX86IntCompareSet(&quot;setge&quot;, :quad)
1642         when &quot;cilt&quot;
1643             handleX86IntCompareSet(&quot;setl&quot;, :int)
1644         when &quot;cblt&quot;
1645             handleX86IntCompareSet(&quot;setl&quot;, :byte)
1646         when &quot;cplt&quot;
1647             handleX86IntCompareSet(&quot;setl&quot;, :ptr)
1648         when &quot;cqlt&quot;
1649             handleX86IntCompareSet(&quot;setl&quot;, :quad)
1650         when &quot;cilteq&quot;
1651             handleX86IntCompareSet(&quot;setle&quot;, :int)
1652         when &quot;cblteq&quot;
1653             handleX86IntCompareSet(&quot;setle&quot;, :byte)
1654         when &quot;cplteq&quot;
1655             handleX86IntCompareSet(&quot;setle&quot;, :ptr)
1656         when &quot;cqlteq&quot;
1657             handleX86IntCompareSet(&quot;setle&quot;, :quad)
<span class="line-added">1658         when &quot;cfeq&quot;</span>
<span class="line-added">1659             handleX86FPCompareSet(:float, :eq)</span>
<span class="line-added">1660         when &quot;cdeq&quot;</span>
<span class="line-added">1661             handleX86FPCompareSet(:double, :eq)</span>
<span class="line-added">1662         when &quot;cfneq&quot;</span>
<span class="line-added">1663             handleX86FPCompareSet(:float, &quot;setne&quot;)</span>
<span class="line-added">1664         when &quot;cdneq&quot;</span>
<span class="line-added">1665             handleX86FPCompareSet(:double, &quot;setne&quot;)</span>
<span class="line-added">1666         when &quot;cfnequn&quot;</span>
<span class="line-added">1667             handleX86FPCompareSet(:float, :nequn)</span>
<span class="line-added">1668         when &quot;cdnequn&quot;</span>
<span class="line-added">1669             handleX86FPCompareSet(:double, :nequn)</span>
<span class="line-added">1670         when &quot;cfgt&quot;</span>
<span class="line-added">1671             handleX86FPCompareSet(:float, &quot;seta&quot;)</span>
<span class="line-added">1672         when &quot;cdgt&quot;</span>
<span class="line-added">1673             handleX86FPCompareSet(:double, &quot;seta&quot;)</span>
<span class="line-added">1674         when &quot;cfgteq&quot;</span>
<span class="line-added">1675             handleX86FPCompareSet(:float, &quot;setae&quot;)</span>
<span class="line-added">1676         when &quot;cdgteq&quot;</span>
<span class="line-added">1677             handleX86FPCompareSet(:double, &quot;setae&quot;)</span>
<span class="line-added">1678         when &quot;cflt&quot;</span>
<span class="line-added">1679             handleX86FPCompareSet(:float, &quot;seta&quot;, :reverse)</span>
<span class="line-added">1680         when &quot;cdlt&quot;</span>
<span class="line-added">1681             handleX86FPCompareSet(:double, &quot;seta&quot;, :reverse)</span>
<span class="line-added">1682         when &quot;cflteq&quot;</span>
<span class="line-added">1683             handleX86FPCompareSet(:float, &quot;setae&quot;, :reverse)</span>
<span class="line-added">1684         when &quot;cdlteq&quot;</span>
<span class="line-added">1685             handleX86FPCompareSet(:double, &quot;setae&quot;, :reverse)</span>
1686         when &quot;tis&quot;
1687             handleX86SetTest(&quot;sets&quot;, :int)
1688         when &quot;tiz&quot;
1689             handleX86SetTest(&quot;setz&quot;, :int)
1690         when &quot;tinz&quot;
1691             handleX86SetTest(&quot;setnz&quot;, :int)
1692         when &quot;tps&quot;
1693             handleX86SetTest(&quot;sets&quot;, :ptr)
1694         when &quot;tpz&quot;
1695             handleX86SetTest(&quot;setz&quot;, :ptr)
1696         when &quot;tpnz&quot;
1697             handleX86SetTest(&quot;setnz&quot;, :ptr)
1698         when &quot;tqs&quot;
1699             handleX86SetTest(&quot;sets&quot;, :quad)
1700         when &quot;tqz&quot;
1701             handleX86SetTest(&quot;setz&quot;, :quad)
1702         when &quot;tqnz&quot;
1703             handleX86SetTest(&quot;setnz&quot;, :quad)
1704         when &quot;tbs&quot;
1705             handleX86SetTest(&quot;sets&quot;, :byte)
1706         when &quot;tbz&quot;
1707             handleX86SetTest(&quot;setz&quot;, :byte)
1708         when &quot;tbnz&quot;
1709             handleX86SetTest(&quot;setnz&quot;, :byte)
1710         when &quot;peek&quot;
1711             handleX86Peek()
1712         when &quot;poke&quot;
1713             handleX86Poke()
1714         when &quot;cdqi&quot;
1715             $asm.puts &quot;cdq&quot;
<span class="line-added">1716         when &quot;cqoq&quot;</span>
<span class="line-added">1717             $asm.puts &quot;cqo&quot;</span>
1718         when &quot;idivi&quot;
1719             $asm.puts &quot;idiv#{x86Suffix(:int)} #{operands[0].x86Operand(:int)}&quot;
<span class="line-added">1720         when &quot;udivi&quot;</span>
<span class="line-added">1721             $asm.puts &quot;div#{x86Suffix(:int)} #{operands[0].x86Operand(:int)}&quot;</span>
<span class="line-added">1722         when &quot;idivq&quot;</span>
<span class="line-added">1723             $asm.puts &quot;idiv#{x86Suffix(:quad)} #{operands[0].x86Operand(:quad)}&quot;</span>
<span class="line-added">1724         when &quot;udivq&quot;</span>
<span class="line-added">1725             $asm.puts &quot;div#{x86Suffix(:quad)} #{operands[0].x86Operand(:quad)}&quot;</span>
<span class="line-added">1726         when &quot;popcnti&quot;</span>
<span class="line-added">1727             $asm.puts &quot;popcnt#{x86Suffix(:int)} #{x86Operands(:int, :int)}&quot;</span>
<span class="line-added">1728         when &quot;popcntq&quot;</span>
<span class="line-added">1729             $asm.puts &quot;popcnt#{x86Suffix(:quad)} #{x86Operands(:quad, :quad)}&quot;</span>
<span class="line-added">1730         when &quot;tzcnti&quot;</span>
<span class="line-added">1731             countTrailingZeros(:int)</span>
<span class="line-added">1732         when &quot;tzcntq&quot;</span>
<span class="line-added">1733             countTrailingZeros(:quad)</span>
<span class="line-added">1734         when &quot;lzcnti&quot;</span>
<span class="line-added">1735             countLeadingZeros(:int)</span>
<span class="line-added">1736         when &quot;lzcntq&quot;</span>
<span class="line-added">1737             countLeadingZeros(:quad)</span>
1738         when &quot;fii2d&quot;
1739             $asm.puts &quot;movd #{operands[0].x86Operand(:int)}, #{operands[2].x86Operand(:double)}&quot;
1740             $asm.puts &quot;movd #{operands[1].x86Operand(:int)}, %xmm7&quot;
1741             $asm.puts &quot;psllq $32, %xmm7&quot;
1742             $asm.puts &quot;por %xmm7, #{operands[2].x86Operand(:double)}&quot;
1743         when &quot;fd2ii&quot;
1744             $asm.puts &quot;movd #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
1745             $asm.puts &quot;movsd #{operands[0].x86Operand(:double)}, %xmm7&quot;
1746             $asm.puts &quot;psrlq $32, %xmm7&quot;
1747             $asm.puts &quot;movd %xmm7, #{operands[2].x86Operand(:int)}&quot;
1748         when &quot;fq2d&quot;
1749             if !isIntelSyntax
1750                 $asm.puts &quot;movq #{operands[0].x86Operand(:quad)}, #{operands[1].x86Operand(:double)}&quot;
1751             else
1752                 # MASM does not accept register operands with movq.
1753                 # Debugging shows that movd actually moves a qword when using MASM.
1754                 $asm.puts &quot;movd #{operands[1].x86Operand(:double)}, #{operands[0].x86Operand(:quad)}&quot;
1755             end
1756         when &quot;fd2q&quot;
1757             if !isIntelSyntax
1758                 $asm.puts &quot;movq #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:quad)}&quot;
1759             else
1760                 # MASM does not accept register operands with movq.
1761                 # Debugging shows that movd actually moves a qword when using MASM.
1762                 $asm.puts &quot;movd #{operands[1].x86Operand(:quad)}, #{operands[0].x86Operand(:double)}&quot;
1763             end
<span class="line-added">1764         when &quot;fi2f&quot;</span>
<span class="line-added">1765             $asm.puts &quot;movd #{x86Operands(:int, :float)}&quot;</span>
<span class="line-added">1766         when &quot;ff2i&quot;</span>
<span class="line-added">1767             $asm.puts &quot;movd #{x86Operands(:float, :int)}&quot;</span>
1768         when &quot;bo&quot;
1769             $asm.puts &quot;jo #{operands[0].asmLabel}&quot;
1770         when &quot;bs&quot;
1771             $asm.puts &quot;js #{operands[0].asmLabel}&quot;
1772         when &quot;bz&quot;
1773             $asm.puts &quot;jz #{operands[0].asmLabel}&quot;
1774         when &quot;bnz&quot;
1775             $asm.puts &quot;jnz #{operands[0].asmLabel}&quot;
1776         when &quot;leai&quot;
1777             $asm.puts &quot;lea#{x86Suffix(:int)} #{orderOperands(operands[0].x86AddressOperand(:int), operands[1].x86Operand(:int))}&quot;
1778         when &quot;leap&quot;
1779             $asm.puts &quot;lea#{x86Suffix(:ptr)} #{orderOperands(operands[0].x86AddressOperand(:ptr), operands[1].x86Operand(:ptr))}&quot;
1780         when &quot;memfence&quot;
1781             sp = RegisterID.new(nil, &quot;sp&quot;)
1782             if isIntelSyntax
1783                 $asm.puts &quot;mfence&quot;
1784             else
1785                 $asm.puts &quot;lock; orl $0, (#{sp.x86Operand(:ptr)})&quot;
1786             end
<span class="line-added">1787         when &quot;absf&quot;</span>
<span class="line-added">1788             $asm.puts &quot;movl #{orderOperands(&quot;$0x80000000&quot;, X64_SCRATCH_REGISTER.x86Operand(:int))}&quot;</span>
<span class="line-added">1789             $asm.puts &quot;movd #{orderOperands(X64_SCRATCH_REGISTER.x86Operand(:int), operands[1].x86Operand(:float))}&quot;</span>
<span class="line-added">1790             $asm.puts &quot;andnps #{orderOperands(operands[0].x86Operand(:float), operands[1].x86Operand(:float))}&quot;</span>
<span class="line-added">1791         when &quot;absd&quot;</span>
<span class="line-added">1792             $asm.puts &quot;movq #{orderOperands(&quot;$0x8000000000000000&quot;, X64_SCRATCH_REGISTER.x86Operand(:quad))}&quot;</span>
<span class="line-added">1793             $asm.puts &quot;movd #{orderOperands(X64_SCRATCH_REGISTER.x86Operand(:quad), operands[1].x86Operand(:double))}&quot;</span>
<span class="line-added">1794             $asm.puts &quot;andnps #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;</span>
<span class="line-added">1795         when &quot;negf&quot;</span>
<span class="line-added">1796             $asm.puts &quot;movl #{orderOperands(&quot;$0x80000000&quot;, X64_SCRATCH_REGISTER.x86Operand(:int))}&quot;</span>
<span class="line-added">1797             $asm.puts &quot;movd #{orderOperands(X64_SCRATCH_REGISTER.x86Operand(:int), operands[1].x86Operand(:float))}&quot;</span>
<span class="line-added">1798             $asm.puts &quot;xorps #{orderOperands(operands[0].x86Operand(:float), operands[1].x86Operand(:float))}&quot;</span>
<span class="line-added">1799         when &quot;negd&quot;</span>
<span class="line-added">1800             $asm.puts &quot;movq #{orderOperands(&quot;$0x8000000000000000&quot;, X64_SCRATCH_REGISTER.x86Operand(:quad))}&quot;</span>
<span class="line-added">1801             $asm.puts &quot;movd #{orderOperands(X64_SCRATCH_REGISTER.x86Operand(:quad), operands[1].x86Operand(:double))}&quot;</span>
<span class="line-added">1802             $asm.puts &quot;xorpd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;</span>
<span class="line-added">1803         when &quot;tls_loadp&quot;</span>
<span class="line-added">1804             raise &quot;tls_loadp is only supported on x64&quot; unless isX64</span>
<span class="line-added">1805             if operands[0].immediate?</span>
<span class="line-added">1806                 mem = &quot;%gs:#{operands[0].value * 8}&quot;</span>
<span class="line-added">1807             else</span>
<span class="line-added">1808                 mem = BaseIndex.new(codeOrigin, nil, operands[0], 8, &quot;%gs:&quot;).x86AddressOperand(:quad)</span>
<span class="line-added">1809             end</span>
<span class="line-added">1810             $asm.puts &quot;movq #{orderOperands(mem, operands[1].x86Operand(:quad))}&quot;</span>
<span class="line-added">1811         when &quot;tls_loadp&quot;</span>
<span class="line-added">1812             raise &quot;tls_loadp is only supported on x64&quot; unless isX64</span>
<span class="line-added">1813             if operands[0].immediate?</span>
<span class="line-added">1814                 mem = &quot;%gs:#{operands[0].value * x86Bytes(:ptr)}&quot;</span>
<span class="line-added">1815             else</span>
<span class="line-added">1816                 mem = BaseIndex.new(codeOrigin, nil, operands[0], x86Bytes(:ptr), &quot;%gs:&quot;).x86AddressOperand(:quad)</span>
<span class="line-added">1817             end</span>
<span class="line-added">1818             $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(mem, operands[1].x86Operand(:quad))}&quot;</span>
<span class="line-added">1819         when &quot;tls_storep&quot;</span>
<span class="line-added">1820             raise &quot;tls_loadp is only supported on x64&quot; unless isX64</span>
<span class="line-added">1821             if operands[1].immediate?</span>
<span class="line-added">1822                 mem = &quot;%gs:#{operands[1].value * x86Bytes(:ptr)}&quot;</span>
<span class="line-added">1823             else</span>
<span class="line-added">1824                 mem = BaseIndex.new(codeOrigin, nil, operands[1], x86Bytes(:ptr), &quot;%gs:&quot;).x86AddressOperand(:ptr)</span>
<span class="line-added">1825             end</span>
<span class="line-added">1826             $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(operands[0].x86Operand(:ptr), mem)}&quot;</span>
1827         else
1828             lowerDefault
1829         end
1830     end
1831 end
1832 
</pre>
</td>
</tr>
</table>
<center><a href="transform.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../parser/ASTBuilder.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
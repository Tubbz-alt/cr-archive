<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGCFGSimplificationPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGCFAPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGCPSRethreadingPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGCFGSimplificationPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
286         if (!livenessNode)
287             return;
288         NodeType nodeType;
289         if (livenessNode-&gt;flags() &amp; NodeIsFlushed)
290             nodeType = Flush;
291         else {
292             // This seems like it shouldn&#39;t be necessary because we could just rematerialize
293             // PhantomLocals or something similar using bytecode liveness. However, in ThreadedCPS, it&#39;s
294             // worth the sanity to maintain this eagerly. See
295             // https://bugs.webkit.org/show_bug.cgi?id=144086
296             nodeType = PhantomLocal;
297         }
298         block-&gt;appendNode(
299             m_graph, SpecNone, nodeType, nodeOrigin,
300             OpInfo(livenessNode-&gt;variableAccessData()));
301     }
302 
303     void jettisonBlock(BasicBlock* block, BasicBlock* jettisonedBlock, NodeOrigin boundaryNodeOrigin)
304     {
305         for (size_t i = 0; i &lt; jettisonedBlock-&gt;variablesAtHead.numberOfArguments(); ++i)
<span class="line-modified">306             keepOperandAlive(block, jettisonedBlock, boundaryNodeOrigin, virtualRegisterForArgument(i));</span>
307         for (size_t i = 0; i &lt; jettisonedBlock-&gt;variablesAtHead.numberOfLocals(); ++i)
308             keepOperandAlive(block, jettisonedBlock, boundaryNodeOrigin, virtualRegisterForLocal(i));
309 
310         fixJettisonedPredecessors(block, jettisonedBlock);
311     }
312 
313     void fixJettisonedPredecessors(BasicBlock* block, BasicBlock* jettisonedBlock)
314     {
315         jettisonedBlock-&gt;removePredecessor(block);
316     }
317 
318     Vector&lt;BasicBlock*, 1&gt; noBlocks()
319     {
320         return Vector&lt;BasicBlock*, 1&gt;();
321     }
322 
323     Vector&lt;BasicBlock*, 1&gt; oneBlock(BasicBlock* block)
324     {
325         Vector&lt;BasicBlock*, 1&gt; result;
326         result.append(block);
</pre>
<hr />
<pre>
337         // SetLocals in the first block are relinked. If jettisonedBlock is not NoBlock,
338         // then Phantoms are inserted for anything that the jettisonedBlock would have
339         // kept alive.
340 
341         // Remove the terminal of firstBlock since we don&#39;t need it anymore. Well, we don&#39;t
342         // really remove it; we actually turn it into a check.
343         Node* terminal = firstBlock-&gt;terminal();
344         ASSERT(terminal-&gt;isTerminal());
345         NodeOrigin boundaryNodeOrigin = terminal-&gt;origin;
346         terminal-&gt;remove(m_graph);
347         ASSERT(terminal-&gt;refCount() == 1);
348 
349         for (unsigned i = jettisonedBlocks.size(); i--;) {
350             BasicBlock* jettisonedBlock = jettisonedBlocks[i];
351 
352             // Time to insert ghosties for things that need to be kept alive in case we OSR
353             // exit prior to hitting the firstBlock&#39;s terminal, and end up going down a
354             // different path than secondBlock.
355 
356             for (size_t i = 0; i &lt; jettisonedBlock-&gt;variablesAtHead.numberOfArguments(); ++i)
<span class="line-modified">357                 keepOperandAlive(firstBlock, jettisonedBlock, boundaryNodeOrigin, virtualRegisterForArgument(i));</span>
358             for (size_t i = 0; i &lt; jettisonedBlock-&gt;variablesAtHead.numberOfLocals(); ++i)
359                 keepOperandAlive(firstBlock, jettisonedBlock, boundaryNodeOrigin, virtualRegisterForLocal(i));
360         }
361 
362         for (size_t i = 0; i &lt; secondBlock-&gt;phis.size(); ++i)
363             firstBlock-&gt;phis.append(secondBlock-&gt;phis[i]);
364 
365         for (size_t i = 0; i &lt; secondBlock-&gt;size(); ++i)
366             firstBlock-&gt;append(secondBlock-&gt;at(i));
367 
368         ASSERT(firstBlock-&gt;terminal()-&gt;isTerminal());
369 
370         // Fix the predecessors of my new successors. This is tricky, since we are going to reset
371         // all predecessors anyway due to reachability analysis. But we need to fix the
372         // predecessors eagerly to ensure that we know what they are in case the next block we
373         // consider in this phase wishes to query the predecessors of one of the blocks we
374         // affected.
375         for (unsigned i = firstBlock-&gt;numSuccessors(); i--;) {
376             BasicBlock* successor = firstBlock-&gt;successor(i);
377             for (unsigned j = 0; j &lt; successor-&gt;predecessors.size(); ++j) {
</pre>
</td>
<td>
<hr />
<pre>
286         if (!livenessNode)
287             return;
288         NodeType nodeType;
289         if (livenessNode-&gt;flags() &amp; NodeIsFlushed)
290             nodeType = Flush;
291         else {
292             // This seems like it shouldn&#39;t be necessary because we could just rematerialize
293             // PhantomLocals or something similar using bytecode liveness. However, in ThreadedCPS, it&#39;s
294             // worth the sanity to maintain this eagerly. See
295             // https://bugs.webkit.org/show_bug.cgi?id=144086
296             nodeType = PhantomLocal;
297         }
298         block-&gt;appendNode(
299             m_graph, SpecNone, nodeType, nodeOrigin,
300             OpInfo(livenessNode-&gt;variableAccessData()));
301     }
302 
303     void jettisonBlock(BasicBlock* block, BasicBlock* jettisonedBlock, NodeOrigin boundaryNodeOrigin)
304     {
305         for (size_t i = 0; i &lt; jettisonedBlock-&gt;variablesAtHead.numberOfArguments(); ++i)
<span class="line-modified">306             keepOperandAlive(block, jettisonedBlock, boundaryNodeOrigin, virtualRegisterForArgumentIncludingThis(i));</span>
307         for (size_t i = 0; i &lt; jettisonedBlock-&gt;variablesAtHead.numberOfLocals(); ++i)
308             keepOperandAlive(block, jettisonedBlock, boundaryNodeOrigin, virtualRegisterForLocal(i));
309 
310         fixJettisonedPredecessors(block, jettisonedBlock);
311     }
312 
313     void fixJettisonedPredecessors(BasicBlock* block, BasicBlock* jettisonedBlock)
314     {
315         jettisonedBlock-&gt;removePredecessor(block);
316     }
317 
318     Vector&lt;BasicBlock*, 1&gt; noBlocks()
319     {
320         return Vector&lt;BasicBlock*, 1&gt;();
321     }
322 
323     Vector&lt;BasicBlock*, 1&gt; oneBlock(BasicBlock* block)
324     {
325         Vector&lt;BasicBlock*, 1&gt; result;
326         result.append(block);
</pre>
<hr />
<pre>
337         // SetLocals in the first block are relinked. If jettisonedBlock is not NoBlock,
338         // then Phantoms are inserted for anything that the jettisonedBlock would have
339         // kept alive.
340 
341         // Remove the terminal of firstBlock since we don&#39;t need it anymore. Well, we don&#39;t
342         // really remove it; we actually turn it into a check.
343         Node* terminal = firstBlock-&gt;terminal();
344         ASSERT(terminal-&gt;isTerminal());
345         NodeOrigin boundaryNodeOrigin = terminal-&gt;origin;
346         terminal-&gt;remove(m_graph);
347         ASSERT(terminal-&gt;refCount() == 1);
348 
349         for (unsigned i = jettisonedBlocks.size(); i--;) {
350             BasicBlock* jettisonedBlock = jettisonedBlocks[i];
351 
352             // Time to insert ghosties for things that need to be kept alive in case we OSR
353             // exit prior to hitting the firstBlock&#39;s terminal, and end up going down a
354             // different path than secondBlock.
355 
356             for (size_t i = 0; i &lt; jettisonedBlock-&gt;variablesAtHead.numberOfArguments(); ++i)
<span class="line-modified">357                 keepOperandAlive(firstBlock, jettisonedBlock, boundaryNodeOrigin, virtualRegisterForArgumentIncludingThis(i));</span>
358             for (size_t i = 0; i &lt; jettisonedBlock-&gt;variablesAtHead.numberOfLocals(); ++i)
359                 keepOperandAlive(firstBlock, jettisonedBlock, boundaryNodeOrigin, virtualRegisterForLocal(i));
360         }
361 
362         for (size_t i = 0; i &lt; secondBlock-&gt;phis.size(); ++i)
363             firstBlock-&gt;phis.append(secondBlock-&gt;phis[i]);
364 
365         for (size_t i = 0; i &lt; secondBlock-&gt;size(); ++i)
366             firstBlock-&gt;append(secondBlock-&gt;at(i));
367 
368         ASSERT(firstBlock-&gt;terminal()-&gt;isTerminal());
369 
370         // Fix the predecessors of my new successors. This is tricky, since we are going to reset
371         // all predecessors anyway due to reachability analysis. But we need to fix the
372         // predecessors eagerly to ensure that we know what they are in case the next block we
373         // consider in this phase wishes to query the predecessors of one of the blocks we
374         // affected.
375         for (unsigned i = firstBlock-&gt;numSuccessors(); i--;) {
376             BasicBlock* successor = firstBlock-&gt;successor(i);
377             for (unsigned j = 0; j &lt; successor-&gt;predecessors.size(); ++j) {
</pre>
</td>
</tr>
</table>
<center><a href="DFGCFAPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGCPSRethreadingPhase.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedMetadataTable.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="UnlinkedFunctionExecutable.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UnlinkedMetadataTable.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedMetadataTable.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,20 ***</span>
  #include &quot;UnlinkedMetadataTableInlines.h&quot;
  #include &lt;wtf/FastMalloc.h&gt;
  
  namespace JSC {
  
  #define JSC_ALIGNMENT_CHECK(size) static_assert(size &lt;= UnlinkedMetadataTable::s_maxMetadataAlignment);
  FOR_EACH_BYTECODE_METADATA_ALIGNMENT(JSC_ALIGNMENT_CHECK)
  #undef JSC_ALIGNMENT_CHECK
  
  void UnlinkedMetadataTable::finalize()
  {
      ASSERT(!m_isFinalized);
      m_isFinalized = true;
      if (!m_hasMetadata) {
<span class="line-modified">!         fastFree(m_rawBuffer);</span>
          m_rawBuffer = nullptr;
          return;
      }
  
      unsigned offset = s_offset16TableSize;
<span class="line-new-header">--- 33,22 ---</span>
  #include &quot;UnlinkedMetadataTableInlines.h&quot;
  #include &lt;wtf/FastMalloc.h&gt;
  
  namespace JSC {
  
<span class="line-added">+ DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(MetadataTable);</span>
<span class="line-added">+ </span>
  #define JSC_ALIGNMENT_CHECK(size) static_assert(size &lt;= UnlinkedMetadataTable::s_maxMetadataAlignment);
  FOR_EACH_BYTECODE_METADATA_ALIGNMENT(JSC_ALIGNMENT_CHECK)
  #undef JSC_ALIGNMENT_CHECK
  
  void UnlinkedMetadataTable::finalize()
  {
      ASSERT(!m_isFinalized);
      m_isFinalized = true;
      if (!m_hasMetadata) {
<span class="line-modified">!         MetadataTableMalloc::free(m_rawBuffer);</span>
          m_rawBuffer = nullptr;
          return;
      }
  
      unsigned offset = s_offset16TableSize;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 67,11 ***</span>
          buffer[s_offsetTableEntries - 1] = offset;
          m_is32Bit = offset &gt; UINT16_MAX;
      }
  
      if (m_is32Bit) {
<span class="line-modified">!         m_rawBuffer = reinterpret_cast&lt;uint8_t*&gt;(fastRealloc(m_rawBuffer, s_offset16TableSize + s_offset32TableSize + sizeof(LinkingData)));</span>
          memmove(m_rawBuffer + sizeof(LinkingData) + s_offset16TableSize, m_rawBuffer + sizeof(LinkingData), s_offset32TableSize);
          memset(m_rawBuffer + sizeof(LinkingData), 0, s_offset16TableSize);
          Offset32* buffer = bitwise_cast&lt;Offset32*&gt;(m_rawBuffer + sizeof(LinkingData) + s_offset16TableSize);
          // This adjustment does not break the alignment calculated for metadata in the above loop so long as s_offset32TableSize is rounded with 8.
          for (unsigned i = 0; i &lt; s_offsetTableEntries; i++)
<span class="line-new-header">--- 69,11 ---</span>
          buffer[s_offsetTableEntries - 1] = offset;
          m_is32Bit = offset &gt; UINT16_MAX;
      }
  
      if (m_is32Bit) {
<span class="line-modified">!         m_rawBuffer = reinterpret_cast&lt;uint8_t*&gt;(MetadataTableMalloc::realloc(m_rawBuffer, s_offset16TableSize + s_offset32TableSize + sizeof(LinkingData)));</span>
          memmove(m_rawBuffer + sizeof(LinkingData) + s_offset16TableSize, m_rawBuffer + sizeof(LinkingData), s_offset32TableSize);
          memset(m_rawBuffer + sizeof(LinkingData), 0, s_offset16TableSize);
          Offset32* buffer = bitwise_cast&lt;Offset32*&gt;(m_rawBuffer + sizeof(LinkingData) + s_offset16TableSize);
          // This adjustment does not break the alignment calculated for metadata in the above loop so long as s_offset32TableSize is rounded with 8.
          for (unsigned i = 0; i &lt; s_offsetTableEntries; i++)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 79,10 ***</span>
      } else {
          Offset32* oldBuffer = bitwise_cast&lt;Offset32*&gt;(m_rawBuffer + sizeof(LinkingData));
          Offset16* buffer = bitwise_cast&lt;Offset16*&gt;(m_rawBuffer + sizeof(LinkingData));
          for (unsigned i = 0; i &lt; s_offsetTableEntries; i++)
              buffer[i] = oldBuffer[i];
<span class="line-modified">!         m_rawBuffer = static_cast&lt;uint8_t*&gt;(fastRealloc(m_rawBuffer, s_offset16TableSize + sizeof(LinkingData)));</span>
      }
  }
  
  } // namespace JSC
<span class="line-new-header">--- 81,10 ---</span>
      } else {
          Offset32* oldBuffer = bitwise_cast&lt;Offset32*&gt;(m_rawBuffer + sizeof(LinkingData));
          Offset16* buffer = bitwise_cast&lt;Offset16*&gt;(m_rawBuffer + sizeof(LinkingData));
          for (unsigned i = 0; i &lt; s_offsetTableEntries; i++)
              buffer[i] = oldBuffer[i];
<span class="line-modified">!         m_rawBuffer = static_cast&lt;uint8_t*&gt;(MetadataTableMalloc::realloc(m_rawBuffer, s_offset16TableSize + sizeof(LinkingData)));</span>
      }
  }
  
  } // namespace JSC
</pre>
<center><a href="UnlinkedFunctionExecutable.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UnlinkedMetadataTable.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
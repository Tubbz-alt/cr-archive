<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSString.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSSourceCode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSString.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSString.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 47     return newString;
 48 }
 49 
 50 template&lt;&gt;
 51 void JSRopeString::RopeBuilder&lt;RecordOverflow&gt;::expand()
 52 {
 53     RELEASE_ASSERT(!this-&gt;hasOverflowed());
 54     ASSERT(m_strings.size() == JSRopeString::s_maxInternalRopeLength);
 55     static_assert(3 == JSRopeString::s_maxInternalRopeLength, &quot;&quot;);
 56     ASSERT(m_length);
 57     ASSERT(asString(m_strings.at(0))-&gt;length());
 58     ASSERT(asString(m_strings.at(1))-&gt;length());
 59     ASSERT(asString(m_strings.at(2))-&gt;length());
 60 
 61     JSString* string = JSRopeString::create(m_vm, asString(m_strings.at(0)), asString(m_strings.at(1)), asString(m_strings.at(2)));
 62     ASSERT(string-&gt;length() == m_length);
 63     m_strings.clear();
 64     m_strings.append(string);
 65 }
 66 
<span class="line-removed"> 67 void JSString::destroy(JSCell* cell)</span>
<span class="line-removed"> 68 {</span>
<span class="line-removed"> 69     static_cast&lt;JSString*&gt;(cell)-&gt;JSString::~JSString();</span>
<span class="line-removed"> 70 }</span>
<span class="line-removed"> 71 </span>
 72 void JSString::dumpToStream(const JSCell* cell, PrintStream&amp; out)
 73 {
 74     VM&amp; vm = cell-&gt;vm();
 75     const JSString* thisObject = jsCast&lt;const JSString*&gt;(cell);
 76     out.printf(&quot;&lt;%p, %s, [%u], &quot;, thisObject, thisObject-&gt;className(vm), thisObject-&gt;length());
 77     uintptr_t pointer = thisObject-&gt;m_fiber;
 78     if (pointer &amp; isRopeInPointer) {
 79         if (pointer &amp; JSRopeString::isSubstringInPointer)
 80             out.printf(&quot;[substring]&quot;);
 81         else
 82             out.printf(&quot;[rope]&quot;);
 83     } else {
 84         if (WTF::StringImpl* ourImpl = bitwise_cast&lt;StringImpl*&gt;(pointer)) {
 85             if (ourImpl-&gt;is8Bit())
 86                 out.printf(&quot;[8 %p]&quot;, ourImpl-&gt;characters8());
 87             else
 88                 out.printf(&quot;[16 %p]&quot;, ourImpl-&gt;characters16());
 89         }
 90     }
 91     out.printf(&quot;&gt;&quot;);
 92 }
 93 
<span class="line-modified"> 94 bool JSString::equalSlowCase(ExecState* exec, JSString* other) const</span>
 95 {
<span class="line-modified"> 96     VM&amp; vm = exec-&gt;vm();</span>
 97     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 98     String str1 = value(exec);</span>
 99     RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">100     String str2 = other-&gt;value(exec);</span>
101     RETURN_IF_EXCEPTION(scope, false);
102     return WTF::equal(*str1.impl(), *str2.impl());
103 }
104 
105 size_t JSString::estimatedSize(JSCell* cell, VM&amp; vm)
106 {
107     JSString* thisObject = asString(cell);
108     uintptr_t pointer = thisObject-&gt;m_fiber;
109     if (pointer &amp; isRopeInPointer)
110         return Base::estimatedSize(cell, vm);
111     return Base::estimatedSize(cell, vm) + bitwise_cast&lt;StringImpl*&gt;(pointer)-&gt;costDuringGC();
112 }
113 
114 void JSString::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
115 {
116     JSString* thisObject = asString(cell);
117     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
118     Base::visitChildren(thisObject, visitor);
119 
120     uintptr_t pointer = thisObject-&gt;m_fiber;
</pre>
<hr />
<pre>
132             case 1:
133                 fiber = static_cast&lt;JSRopeString*&gt;(thisObject)-&gt;fiber1();
134                 break;
135             case 2:
136                 fiber = static_cast&lt;JSRopeString*&gt;(thisObject)-&gt;fiber2();
137                 break;
138             default:
139                 ASSERT_NOT_REACHED();
140                 return;
141             }
142             if (!fiber)
143                 break;
144             visitor.appendUnbarriered(fiber);
145         }
146         return;
147     }
148     if (StringImpl* impl = bitwise_cast&lt;StringImpl*&gt;(pointer))
149         visitor.reportExtraMemoryVisited(impl-&gt;costDuringGC());
150 }
151 
<span class="line-modified">152 static const unsigned maxLengthForOnStackResolve = 2048;</span>
153 
154 void JSRopeString::resolveRopeInternal8(LChar* buffer) const
155 {
156     if (isSubstring()) {
157         StringImpl::copyCharacters(buffer, substringBase()-&gt;valueInternal().characters8() + substringOffset(), length());
158         return;
159     }
160 
<span class="line-modified">161     resolveRopeInternal8NoSubstring(buffer);</span>
<span class="line-removed">162 }</span>
<span class="line-removed">163 </span>
<span class="line-removed">164 void JSRopeString::resolveRopeInternal8NoSubstring(LChar* buffer) const</span>
<span class="line-removed">165 {</span>
<span class="line-removed">166     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {</span>
<span class="line-removed">167         if (fiber(i)-&gt;isRope()) {</span>
<span class="line-removed">168             resolveRopeSlowCase8(buffer);</span>
<span class="line-removed">169             return;</span>
<span class="line-removed">170         }</span>
<span class="line-removed">171     }</span>
<span class="line-removed">172 </span>
<span class="line-removed">173     LChar* position = buffer;</span>
<span class="line-removed">174     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {</span>
<span class="line-removed">175         const StringImpl&amp; fiberString = *fiber(i)-&gt;valueInternal().impl();</span>
<span class="line-removed">176         unsigned length = fiberString.length();</span>
<span class="line-removed">177         StringImpl::copyCharacters(position, fiberString.characters8(), length);</span>
<span class="line-removed">178         position += length;</span>
<span class="line-removed">179     }</span>
<span class="line-removed">180     ASSERT((buffer + length()) == position);</span>
181 }
182 
183 void JSRopeString::resolveRopeInternal16(UChar* buffer) const
184 {
185     if (isSubstring()) {
186         StringImpl::copyCharacters(
187             buffer, substringBase()-&gt;valueInternal().characters16() + substringOffset(), length());
188         return;
189     }
190 
<span class="line-modified">191     resolveRopeInternal16NoSubstring(buffer);</span>
192 }
193 
<span class="line-modified">194 void JSRopeString::resolveRopeInternal16NoSubstring(UChar* buffer) const</span>

195 {
196     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {
197         if (fiber(i)-&gt;isRope()) {
198             resolveRopeSlowCase(buffer);
199             return;
200         }
201     }
202 
<span class="line-modified">203     UChar* position = buffer;</span>
204     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {
205         const StringImpl&amp; fiberString = *fiber(i)-&gt;valueInternal().impl();
206         unsigned length = fiberString.length();
207         if (fiberString.is8Bit())
208             StringImpl::copyCharacters(position, fiberString.characters8(), length);
209         else
210             StringImpl::copyCharacters(position, fiberString.characters16(), length);
211         position += length;
212     }
213     ASSERT((buffer + length()) == position);
214 }
215 
<span class="line-modified">216 AtomString JSRopeString::resolveRopeToAtomString(ExecState* exec) const</span>
217 {
<span class="line-modified">218     VM&amp; vm = exec-&gt;vm();</span>
219     auto scope = DECLARE_THROW_SCOPE(vm);
220 
221     if (length() &gt; maxLengthForOnStackResolve) {
222         scope.release();
<span class="line-modified">223         return resolveRopeWithFunction(exec, [&amp;] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) {</span>
224             return AtomStringImpl::add(newImpl.ptr());
225         });
226     }
227 
228     if (is8Bit()) {
229         LChar buffer[maxLengthForOnStackResolve];
230         resolveRopeInternal8(buffer);
231         convertToNonRope(AtomStringImpl::add(buffer, length()));
232     } else {
233         UChar buffer[maxLengthForOnStackResolve];
234         resolveRopeInternal16(buffer);
235         convertToNonRope(AtomStringImpl::add(buffer, length()));
236     }
237 
238     // If we resolved a string that didn&#39;t previously exist, notify the heap that we&#39;ve grown.
239     if (valueInternal().impl()-&gt;hasOneRef())
240         vm.heap.reportExtraMemoryAllocated(valueInternal().impl()-&gt;cost());
241     return valueInternal();
242 }
243 
244 inline void JSRopeString::convertToNonRope(String&amp;&amp; string) const
245 {
246     // Concurrent compiler threads can access String held by JSString. So we always emit
247     // store-store barrier here to ensure concurrent compiler threads see initialized String.
248     ASSERT(JSString::isRope());
249     WTF::storeStoreFence();
250     new (&amp;uninitializedValueInternal()) String(WTFMove(string));
251     static_assert(sizeof(String) == sizeof(RefPtr&lt;StringImpl&gt;), &quot;JSString&#39;s String initialization must be done in one pointer move.&quot;);
252     // We do not clear the trailing fibers and length information (fiber1 and fiber2) because we could be reading the length concurrently.
253     ASSERT(!JSString::isRope());
254 }
255 
<span class="line-modified">256 RefPtr&lt;AtomStringImpl&gt; JSRopeString::resolveRopeToExistingAtomString(ExecState* exec) const</span>
257 {
<span class="line-modified">258     VM&amp; vm = exec-&gt;vm();</span>
259     auto scope = DECLARE_THROW_SCOPE(vm);
260 
261     if (length() &gt; maxLengthForOnStackResolve) {
262         RefPtr&lt;AtomStringImpl&gt; existingAtomString;
<span class="line-modified">263         resolveRopeWithFunction(exec, [&amp;] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) -&gt; Ref&lt;StringImpl&gt; {</span>
264             existingAtomString = AtomStringImpl::lookUp(newImpl.ptr());
265             if (existingAtomString)
266                 return makeRef(*existingAtomString);
267             return WTFMove(newImpl);
268         });
269         RETURN_IF_EXCEPTION(scope, nullptr);
270         return existingAtomString;
271     }
272 
273     if (is8Bit()) {
274         LChar buffer[maxLengthForOnStackResolve];
275         resolveRopeInternal8(buffer);
276         if (RefPtr&lt;AtomStringImpl&gt; existingAtomString = AtomStringImpl::lookUp(buffer, length())) {
277             convertToNonRope(*existingAtomString);
278             return existingAtomString;
279         }
280     } else {
281         UChar buffer[maxLengthForOnStackResolve];
282         resolveRopeInternal16(buffer);
283         if (RefPtr&lt;AtomStringImpl&gt; existingAtomString = AtomStringImpl::lookUp(buffer, length())) {
284             convertToNonRope(*existingAtomString);
285             return existingAtomString;
286         }
287     }
288 
289     return nullptr;
290 }
291 
292 template&lt;typename Function&gt;
<span class="line-modified">293 const String&amp; JSRopeString::resolveRopeWithFunction(ExecState* nullOrExecForOOM, Function&amp;&amp; function) const</span>
294 {
295     ASSERT(isRope());
296 
297     VM&amp; vm = this-&gt;vm();
298     if (isSubstring()) {
299         ASSERT(!substringBase()-&gt;isRope());
300         auto newImpl = substringBase()-&gt;valueInternal().substringSharingImpl(substringOffset(), length());
301         convertToNonRope(function(newImpl.releaseImpl().releaseNonNull()));
302         return valueInternal();
303     }
304 
305     if (is8Bit()) {
306         LChar* buffer;
307         auto newImpl = StringImpl::tryCreateUninitialized(length(), buffer);
308         if (!newImpl) {
<span class="line-modified">309             outOfMemory(nullOrExecForOOM);</span>
310             return nullString();
311         }
312         vm.heap.reportExtraMemoryAllocated(newImpl-&gt;cost());
313 
<span class="line-modified">314         resolveRopeInternal8NoSubstring(buffer);</span>
315         convertToNonRope(function(newImpl.releaseNonNull()));
316         return valueInternal();
317     }
318 
319     UChar* buffer;
320     auto newImpl = StringImpl::tryCreateUninitialized(length(), buffer);
321     if (!newImpl) {
<span class="line-modified">322         outOfMemory(nullOrExecForOOM);</span>
323         return nullString();
324     }
325     vm.heap.reportExtraMemoryAllocated(newImpl-&gt;cost());
326 
<span class="line-modified">327     resolveRopeInternal16NoSubstring(buffer);</span>
328     convertToNonRope(function(newImpl.releaseNonNull()));
329     return valueInternal();
330 }
331 
<span class="line-modified">332 const String&amp; JSRopeString::resolveRope(ExecState* nullOrExecForOOM) const</span>
333 {
<span class="line-modified">334     return resolveRopeWithFunction(nullOrExecForOOM, [] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) {</span>
335         return WTFMove(newImpl);
336     });
337 }
338 
339 // Overview: These functions convert a JSString from holding a string in rope form
340 // down to a simple String representation. It does so by building up the string
341 // backwards, since we want to avoid recursion, we expect that the tree structure
342 // representing the rope is likely imbalanced with more nodes down the left side
343 // (since appending to the string is likely more common) - and as such resolving
344 // in this fashion should minimize work queue size.  (If we built the queue forwards
345 // we would likely have to place all of the constituent StringImpls into the
346 // Vector before performing any concatenation, but by working backwards we likely
347 // only fill the queue with the number of substrings at any given level in a
348 // rope-of-ropes.)
<span class="line-modified">349 void JSRopeString::resolveRopeSlowCase8(LChar* buffer) const</span>
<span class="line-modified">350 {</span>
<span class="line-removed">351     LChar* position = buffer + length(); // We will be working backwards over the rope.</span>
<span class="line-removed">352     Vector&lt;JSString*, 32, UnsafeVectorOverflow&gt; workQueue; // Putting strings into a Vector is only OK because there are no GC points in this method.</span>
<span class="line-removed">353 </span>
<span class="line-removed">354     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i)</span>
<span class="line-removed">355         workQueue.append(fiber(i));</span>
<span class="line-removed">356 </span>
<span class="line-removed">357     while (!workQueue.isEmpty()) {</span>
<span class="line-removed">358         JSString* currentFiber = workQueue.last();</span>
<span class="line-removed">359         workQueue.removeLast();</span>
<span class="line-removed">360 </span>
<span class="line-removed">361         const LChar* characters;</span>
<span class="line-removed">362 </span>
<span class="line-removed">363         if (currentFiber-&gt;isRope()) {</span>
<span class="line-removed">364             JSRopeString* currentFiberAsRope = static_cast&lt;JSRopeString*&gt;(currentFiber);</span>
<span class="line-removed">365             if (!currentFiberAsRope-&gt;isSubstring()) {</span>
<span class="line-removed">366                 for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; currentFiberAsRope-&gt;fiber(i); ++i)</span>
<span class="line-removed">367                     workQueue.append(currentFiberAsRope-&gt;fiber(i));</span>
<span class="line-removed">368                 continue;</span>
<span class="line-removed">369             }</span>
<span class="line-removed">370             ASSERT(!currentFiberAsRope-&gt;substringBase()-&gt;isRope());</span>
<span class="line-removed">371             characters =</span>
<span class="line-removed">372                 currentFiberAsRope-&gt;substringBase()-&gt;valueInternal().characters8() +</span>
<span class="line-removed">373                 currentFiberAsRope-&gt;substringOffset();</span>
<span class="line-removed">374         } else</span>
<span class="line-removed">375             characters = currentFiber-&gt;valueInternal().characters8();</span>
<span class="line-removed">376 </span>
<span class="line-removed">377         unsigned length = currentFiber-&gt;length();</span>
<span class="line-removed">378         position -= length;</span>
<span class="line-removed">379         StringImpl::copyCharacters(position, characters, length);</span>
<span class="line-removed">380     }</span>
<span class="line-removed">381 </span>
<span class="line-removed">382     ASSERT(buffer == position);</span>
<span class="line-removed">383 }</span>
<span class="line-removed">384 </span>
<span class="line-removed">385 void JSRopeString::resolveRopeSlowCase(UChar* buffer) const</span>
386 {
<span class="line-modified">387     UChar* position = buffer + length(); // We will be working backwards over the rope.</span>
388     Vector&lt;JSString*, 32, UnsafeVectorOverflow&gt; workQueue; // These strings are kept alive by the parent rope, so using a Vector is OK.
389 
390     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i)
391         workQueue.append(fiber(i));
392 
393     while (!workQueue.isEmpty()) {
394         JSString* currentFiber = workQueue.last();
395         workQueue.removeLast();
396 
397         if (currentFiber-&gt;isRope()) {
398             JSRopeString* currentFiberAsRope = static_cast&lt;JSRopeString*&gt;(currentFiber);
399             if (currentFiberAsRope-&gt;isSubstring()) {
400                 ASSERT(!currentFiberAsRope-&gt;substringBase()-&gt;isRope());
401                 StringImpl* string = static_cast&lt;StringImpl*&gt;(
402                     currentFiberAsRope-&gt;substringBase()-&gt;valueInternal().impl());
403                 unsigned offset = currentFiberAsRope-&gt;substringOffset();
404                 unsigned length = currentFiberAsRope-&gt;length();
405                 position -= length;
406                 if (string-&gt;is8Bit())
407                     StringImpl::copyCharacters(position, string-&gt;characters8() + offset, length);
</pre>
<hr />
<pre>
409                     StringImpl::copyCharacters(position, string-&gt;characters16() + offset, length);
410                 continue;
411             }
412             for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; currentFiberAsRope-&gt;fiber(i); ++i)
413                 workQueue.append(currentFiberAsRope-&gt;fiber(i));
414             continue;
415         }
416 
417         StringImpl* string = static_cast&lt;StringImpl*&gt;(currentFiber-&gt;valueInternal().impl());
418         unsigned length = string-&gt;length();
419         position -= length;
420         if (string-&gt;is8Bit())
421             StringImpl::copyCharacters(position, string-&gt;characters8(), length);
422         else
423             StringImpl::copyCharacters(position, string-&gt;characters16(), length);
424     }
425 
426     ASSERT(buffer == position);
427 }
428 
<span class="line-modified">429 void JSRopeString::outOfMemory(ExecState* nullOrExecForOOM) const</span>
430 {
431     ASSERT(isRope());
<span class="line-modified">432     if (nullOrExecForOOM) {</span>
<span class="line-modified">433         VM&amp; vm = nullOrExecForOOM-&gt;vm();</span>
434         auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">435         throwOutOfMemoryError(nullOrExecForOOM, scope);</span>
436     }
437 }
438 
<span class="line-modified">439 JSValue JSString::toPrimitive(ExecState*, PreferredPrimitiveType) const</span>
440 {
441     return const_cast&lt;JSString*&gt;(this);
442 }
443 
<span class="line-modified">444 bool JSString::getPrimitiveNumber(ExecState* exec, double&amp; number, JSValue&amp; result) const</span>
445 {
<span class="line-modified">446     VM&amp; vm = exec-&gt;vm();</span>
447     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">448     StringView view = unsafeView(exec);</span>
449     RETURN_IF_EXCEPTION(scope, false);
450     result = this;
451     number = jsToNumber(view);
452     return false;
453 }
454 
<span class="line-modified">455 double JSString::toNumber(ExecState* exec) const</span>
456 {
<span class="line-modified">457     VM&amp; vm = exec-&gt;vm();</span>
458     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">459     StringView view = unsafeView(exec);</span>
460     RETURN_IF_EXCEPTION(scope, 0);
461     return jsToNumber(view);
462 }
463 
464 inline StringObject* StringObject::create(VM&amp; vm, JSGlobalObject* globalObject, JSString* string)
465 {
466     StringObject* object = new (NotNull, allocateCell&lt;StringObject&gt;(vm.heap)) StringObject(vm, globalObject-&gt;stringObjectStructure());
467     object-&gt;finishCreation(vm, string);
468     return object;
469 }
470 
<span class="line-modified">471 JSObject* JSString::toObject(ExecState* exec, JSGlobalObject* globalObject) const</span>
472 {
<span class="line-modified">473     return StringObject::create(exec-&gt;vm(), globalObject, const_cast&lt;JSString*&gt;(this));</span>
474 }
475 
<span class="line-modified">476 JSValue JSString::toThis(JSCell* cell, ExecState* exec, ECMAMode ecmaMode)</span>
477 {
478     if (ecmaMode == StrictMode)
479         return cell;
<span class="line-modified">480     return StringObject::create(exec-&gt;vm(), exec-&gt;lexicalGlobalObject(), asString(cell));</span>
481 }
482 
<span class="line-modified">483 bool JSString::getStringPropertyDescriptor(ExecState* exec, PropertyName propertyName, PropertyDescriptor&amp; descriptor)</span>
484 {
<span class="line-modified">485     VM&amp; vm = exec-&gt;vm();</span>
486     if (propertyName == vm.propertyNames-&gt;length) {
487         descriptor.setDescriptor(jsNumber(length()), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
488         return true;
489     }
490 
491     Optional&lt;uint32_t&gt; index = parseIndex(propertyName);
492     if (index &amp;&amp; index.value() &lt; length()) {
<span class="line-modified">493         descriptor.setDescriptor(getIndex(exec, index.value()), PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);</span>
494         return true;
495     }
496 
497     return false;
498 }
499 
500 JSString* jsStringWithCacheSlowCase(VM&amp; vm, StringImpl&amp; stringImpl)
501 {
502     if (JSString* string = vm.stringCache.get(&amp;stringImpl))
503         return string;
504 
505     JSString* string = jsString(vm, String(stringImpl));
506     vm.lastCachedString.set(vm, string);
507     return string;
508 }
509 
510 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 47     return newString;
 48 }
 49 
 50 template&lt;&gt;
 51 void JSRopeString::RopeBuilder&lt;RecordOverflow&gt;::expand()
 52 {
 53     RELEASE_ASSERT(!this-&gt;hasOverflowed());
 54     ASSERT(m_strings.size() == JSRopeString::s_maxInternalRopeLength);
 55     static_assert(3 == JSRopeString::s_maxInternalRopeLength, &quot;&quot;);
 56     ASSERT(m_length);
 57     ASSERT(asString(m_strings.at(0))-&gt;length());
 58     ASSERT(asString(m_strings.at(1))-&gt;length());
 59     ASSERT(asString(m_strings.at(2))-&gt;length());
 60 
 61     JSString* string = JSRopeString::create(m_vm, asString(m_strings.at(0)), asString(m_strings.at(1)), asString(m_strings.at(2)));
 62     ASSERT(string-&gt;length() == m_length);
 63     m_strings.clear();
 64     m_strings.append(string);
 65 }
 66 





 67 void JSString::dumpToStream(const JSCell* cell, PrintStream&amp; out)
 68 {
 69     VM&amp; vm = cell-&gt;vm();
 70     const JSString* thisObject = jsCast&lt;const JSString*&gt;(cell);
 71     out.printf(&quot;&lt;%p, %s, [%u], &quot;, thisObject, thisObject-&gt;className(vm), thisObject-&gt;length());
 72     uintptr_t pointer = thisObject-&gt;m_fiber;
 73     if (pointer &amp; isRopeInPointer) {
 74         if (pointer &amp; JSRopeString::isSubstringInPointer)
 75             out.printf(&quot;[substring]&quot;);
 76         else
 77             out.printf(&quot;[rope]&quot;);
 78     } else {
 79         if (WTF::StringImpl* ourImpl = bitwise_cast&lt;StringImpl*&gt;(pointer)) {
 80             if (ourImpl-&gt;is8Bit())
 81                 out.printf(&quot;[8 %p]&quot;, ourImpl-&gt;characters8());
 82             else
 83                 out.printf(&quot;[16 %p]&quot;, ourImpl-&gt;characters16());
 84         }
 85     }
 86     out.printf(&quot;&gt;&quot;);
 87 }
 88 
<span class="line-modified"> 89 bool JSString::equalSlowCase(JSGlobalObject* globalObject, JSString* other) const</span>
 90 {
<span class="line-modified"> 91     VM&amp; vm = globalObject-&gt;vm();</span>
 92     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 93     String str1 = value(globalObject);</span>
 94     RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified"> 95     String str2 = other-&gt;value(globalObject);</span>
 96     RETURN_IF_EXCEPTION(scope, false);
 97     return WTF::equal(*str1.impl(), *str2.impl());
 98 }
 99 
100 size_t JSString::estimatedSize(JSCell* cell, VM&amp; vm)
101 {
102     JSString* thisObject = asString(cell);
103     uintptr_t pointer = thisObject-&gt;m_fiber;
104     if (pointer &amp; isRopeInPointer)
105         return Base::estimatedSize(cell, vm);
106     return Base::estimatedSize(cell, vm) + bitwise_cast&lt;StringImpl*&gt;(pointer)-&gt;costDuringGC();
107 }
108 
109 void JSString::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
110 {
111     JSString* thisObject = asString(cell);
112     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
113     Base::visitChildren(thisObject, visitor);
114 
115     uintptr_t pointer = thisObject-&gt;m_fiber;
</pre>
<hr />
<pre>
127             case 1:
128                 fiber = static_cast&lt;JSRopeString*&gt;(thisObject)-&gt;fiber1();
129                 break;
130             case 2:
131                 fiber = static_cast&lt;JSRopeString*&gt;(thisObject)-&gt;fiber2();
132                 break;
133             default:
134                 ASSERT_NOT_REACHED();
135                 return;
136             }
137             if (!fiber)
138                 break;
139             visitor.appendUnbarriered(fiber);
140         }
141         return;
142     }
143     if (StringImpl* impl = bitwise_cast&lt;StringImpl*&gt;(pointer))
144         visitor.reportExtraMemoryVisited(impl-&gt;costDuringGC());
145 }
146 
<span class="line-modified">147 static constexpr unsigned maxLengthForOnStackResolve = 2048;</span>
148 
149 void JSRopeString::resolveRopeInternal8(LChar* buffer) const
150 {
151     if (isSubstring()) {
152         StringImpl::copyCharacters(buffer, substringBase()-&gt;valueInternal().characters8() + substringOffset(), length());
153         return;
154     }
155 
<span class="line-modified">156     resolveRopeInternalNoSubstring(buffer);</span>



















157 }
158 
159 void JSRopeString::resolveRopeInternal16(UChar* buffer) const
160 {
161     if (isSubstring()) {
162         StringImpl::copyCharacters(
163             buffer, substringBase()-&gt;valueInternal().characters16() + substringOffset(), length());
164         return;
165     }
166 
<span class="line-modified">167     resolveRopeInternalNoSubstring(buffer);</span>
168 }
169 
<span class="line-modified">170 template&lt;typename CharacterType&gt;</span>
<span class="line-added">171 void JSRopeString::resolveRopeInternalNoSubstring(CharacterType* buffer) const</span>
172 {
173     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {
174         if (fiber(i)-&gt;isRope()) {
175             resolveRopeSlowCase(buffer);
176             return;
177         }
178     }
179 
<span class="line-modified">180     CharacterType* position = buffer;</span>
181     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i) {
182         const StringImpl&amp; fiberString = *fiber(i)-&gt;valueInternal().impl();
183         unsigned length = fiberString.length();
184         if (fiberString.is8Bit())
185             StringImpl::copyCharacters(position, fiberString.characters8(), length);
186         else
187             StringImpl::copyCharacters(position, fiberString.characters16(), length);
188         position += length;
189     }
190     ASSERT((buffer + length()) == position);
191 }
192 
<span class="line-modified">193 AtomString JSRopeString::resolveRopeToAtomString(JSGlobalObject* globalObject) const</span>
194 {
<span class="line-modified">195     VM&amp; vm = globalObject-&gt;vm();</span>
196     auto scope = DECLARE_THROW_SCOPE(vm);
197 
198     if (length() &gt; maxLengthForOnStackResolve) {
199         scope.release();
<span class="line-modified">200         return resolveRopeWithFunction(globalObject, [&amp;] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) {</span>
201             return AtomStringImpl::add(newImpl.ptr());
202         });
203     }
204 
205     if (is8Bit()) {
206         LChar buffer[maxLengthForOnStackResolve];
207         resolveRopeInternal8(buffer);
208         convertToNonRope(AtomStringImpl::add(buffer, length()));
209     } else {
210         UChar buffer[maxLengthForOnStackResolve];
211         resolveRopeInternal16(buffer);
212         convertToNonRope(AtomStringImpl::add(buffer, length()));
213     }
214 
215     // If we resolved a string that didn&#39;t previously exist, notify the heap that we&#39;ve grown.
216     if (valueInternal().impl()-&gt;hasOneRef())
217         vm.heap.reportExtraMemoryAllocated(valueInternal().impl()-&gt;cost());
218     return valueInternal();
219 }
220 
221 inline void JSRopeString::convertToNonRope(String&amp;&amp; string) const
222 {
223     // Concurrent compiler threads can access String held by JSString. So we always emit
224     // store-store barrier here to ensure concurrent compiler threads see initialized String.
225     ASSERT(JSString::isRope());
226     WTF::storeStoreFence();
227     new (&amp;uninitializedValueInternal()) String(WTFMove(string));
228     static_assert(sizeof(String) == sizeof(RefPtr&lt;StringImpl&gt;), &quot;JSString&#39;s String initialization must be done in one pointer move.&quot;);
229     // We do not clear the trailing fibers and length information (fiber1 and fiber2) because we could be reading the length concurrently.
230     ASSERT(!JSString::isRope());
231 }
232 
<span class="line-modified">233 RefPtr&lt;AtomStringImpl&gt; JSRopeString::resolveRopeToExistingAtomString(JSGlobalObject* globalObject) const</span>
234 {
<span class="line-modified">235     VM&amp; vm = globalObject-&gt;vm();</span>
236     auto scope = DECLARE_THROW_SCOPE(vm);
237 
238     if (length() &gt; maxLengthForOnStackResolve) {
239         RefPtr&lt;AtomStringImpl&gt; existingAtomString;
<span class="line-modified">240         resolveRopeWithFunction(globalObject, [&amp;] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) -&gt; Ref&lt;StringImpl&gt; {</span>
241             existingAtomString = AtomStringImpl::lookUp(newImpl.ptr());
242             if (existingAtomString)
243                 return makeRef(*existingAtomString);
244             return WTFMove(newImpl);
245         });
246         RETURN_IF_EXCEPTION(scope, nullptr);
247         return existingAtomString;
248     }
249 
250     if (is8Bit()) {
251         LChar buffer[maxLengthForOnStackResolve];
252         resolveRopeInternal8(buffer);
253         if (RefPtr&lt;AtomStringImpl&gt; existingAtomString = AtomStringImpl::lookUp(buffer, length())) {
254             convertToNonRope(*existingAtomString);
255             return existingAtomString;
256         }
257     } else {
258         UChar buffer[maxLengthForOnStackResolve];
259         resolveRopeInternal16(buffer);
260         if (RefPtr&lt;AtomStringImpl&gt; existingAtomString = AtomStringImpl::lookUp(buffer, length())) {
261             convertToNonRope(*existingAtomString);
262             return existingAtomString;
263         }
264     }
265 
266     return nullptr;
267 }
268 
269 template&lt;typename Function&gt;
<span class="line-modified">270 const String&amp; JSRopeString::resolveRopeWithFunction(JSGlobalObject* nullOrGlobalObjectForOOM, Function&amp;&amp; function) const</span>
271 {
272     ASSERT(isRope());
273 
274     VM&amp; vm = this-&gt;vm();
275     if (isSubstring()) {
276         ASSERT(!substringBase()-&gt;isRope());
277         auto newImpl = substringBase()-&gt;valueInternal().substringSharingImpl(substringOffset(), length());
278         convertToNonRope(function(newImpl.releaseImpl().releaseNonNull()));
279         return valueInternal();
280     }
281 
282     if (is8Bit()) {
283         LChar* buffer;
284         auto newImpl = StringImpl::tryCreateUninitialized(length(), buffer);
285         if (!newImpl) {
<span class="line-modified">286             outOfMemory(nullOrGlobalObjectForOOM);</span>
287             return nullString();
288         }
289         vm.heap.reportExtraMemoryAllocated(newImpl-&gt;cost());
290 
<span class="line-modified">291         resolveRopeInternalNoSubstring(buffer);</span>
292         convertToNonRope(function(newImpl.releaseNonNull()));
293         return valueInternal();
294     }
295 
296     UChar* buffer;
297     auto newImpl = StringImpl::tryCreateUninitialized(length(), buffer);
298     if (!newImpl) {
<span class="line-modified">299         outOfMemory(nullOrGlobalObjectForOOM);</span>
300         return nullString();
301     }
302     vm.heap.reportExtraMemoryAllocated(newImpl-&gt;cost());
303 
<span class="line-modified">304     resolveRopeInternalNoSubstring(buffer);</span>
305     convertToNonRope(function(newImpl.releaseNonNull()));
306     return valueInternal();
307 }
308 
<span class="line-modified">309 const String&amp; JSRopeString::resolveRope(JSGlobalObject* nullOrGlobalObjectForOOM) const</span>
310 {
<span class="line-modified">311     return resolveRopeWithFunction(nullOrGlobalObjectForOOM, [] (Ref&lt;StringImpl&gt;&amp;&amp; newImpl) {</span>
312         return WTFMove(newImpl);
313     });
314 }
315 
316 // Overview: These functions convert a JSString from holding a string in rope form
317 // down to a simple String representation. It does so by building up the string
318 // backwards, since we want to avoid recursion, we expect that the tree structure
319 // representing the rope is likely imbalanced with more nodes down the left side
320 // (since appending to the string is likely more common) - and as such resolving
321 // in this fashion should minimize work queue size.  (If we built the queue forwards
322 // we would likely have to place all of the constituent StringImpls into the
323 // Vector before performing any concatenation, but by working backwards we likely
324 // only fill the queue with the number of substrings at any given level in a
325 // rope-of-ropes.)
<span class="line-modified">326 template&lt;typename CharacterType&gt;</span>
<span class="line-modified">327 void JSRopeString::resolveRopeSlowCase(CharacterType* buffer) const</span>



































328 {
<span class="line-modified">329     CharacterType* position = buffer + length(); // We will be working backwards over the rope.</span>
330     Vector&lt;JSString*, 32, UnsafeVectorOverflow&gt; workQueue; // These strings are kept alive by the parent rope, so using a Vector is OK.
331 
332     for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; fiber(i); ++i)
333         workQueue.append(fiber(i));
334 
335     while (!workQueue.isEmpty()) {
336         JSString* currentFiber = workQueue.last();
337         workQueue.removeLast();
338 
339         if (currentFiber-&gt;isRope()) {
340             JSRopeString* currentFiberAsRope = static_cast&lt;JSRopeString*&gt;(currentFiber);
341             if (currentFiberAsRope-&gt;isSubstring()) {
342                 ASSERT(!currentFiberAsRope-&gt;substringBase()-&gt;isRope());
343                 StringImpl* string = static_cast&lt;StringImpl*&gt;(
344                     currentFiberAsRope-&gt;substringBase()-&gt;valueInternal().impl());
345                 unsigned offset = currentFiberAsRope-&gt;substringOffset();
346                 unsigned length = currentFiberAsRope-&gt;length();
347                 position -= length;
348                 if (string-&gt;is8Bit())
349                     StringImpl::copyCharacters(position, string-&gt;characters8() + offset, length);
</pre>
<hr />
<pre>
351                     StringImpl::copyCharacters(position, string-&gt;characters16() + offset, length);
352                 continue;
353             }
354             for (size_t i = 0; i &lt; s_maxInternalRopeLength &amp;&amp; currentFiberAsRope-&gt;fiber(i); ++i)
355                 workQueue.append(currentFiberAsRope-&gt;fiber(i));
356             continue;
357         }
358 
359         StringImpl* string = static_cast&lt;StringImpl*&gt;(currentFiber-&gt;valueInternal().impl());
360         unsigned length = string-&gt;length();
361         position -= length;
362         if (string-&gt;is8Bit())
363             StringImpl::copyCharacters(position, string-&gt;characters8(), length);
364         else
365             StringImpl::copyCharacters(position, string-&gt;characters16(), length);
366     }
367 
368     ASSERT(buffer == position);
369 }
370 
<span class="line-modified">371 void JSRopeString::outOfMemory(JSGlobalObject* nullOrGlobalObjectForOOM) const</span>
372 {
373     ASSERT(isRope());
<span class="line-modified">374     if (nullOrGlobalObjectForOOM) {</span>
<span class="line-modified">375         VM&amp; vm = nullOrGlobalObjectForOOM-&gt;vm();</span>
376         auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">377         throwOutOfMemoryError(nullOrGlobalObjectForOOM, scope);</span>
378     }
379 }
380 
<span class="line-modified">381 JSValue JSString::toPrimitive(JSGlobalObject*, PreferredPrimitiveType) const</span>
382 {
383     return const_cast&lt;JSString*&gt;(this);
384 }
385 
<span class="line-modified">386 bool JSString::getPrimitiveNumber(JSGlobalObject* globalObject, double&amp; number, JSValue&amp; result) const</span>
387 {
<span class="line-modified">388     VM&amp; vm = globalObject-&gt;vm();</span>
389     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">390     StringView view = unsafeView(globalObject);</span>
391     RETURN_IF_EXCEPTION(scope, false);
392     result = this;
393     number = jsToNumber(view);
394     return false;
395 }
396 
<span class="line-modified">397 double JSString::toNumber(JSGlobalObject* globalObject) const</span>
398 {
<span class="line-modified">399     VM&amp; vm = globalObject-&gt;vm();</span>
400     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">401     StringView view = unsafeView(globalObject);</span>
402     RETURN_IF_EXCEPTION(scope, 0);
403     return jsToNumber(view);
404 }
405 
406 inline StringObject* StringObject::create(VM&amp; vm, JSGlobalObject* globalObject, JSString* string)
407 {
408     StringObject* object = new (NotNull, allocateCell&lt;StringObject&gt;(vm.heap)) StringObject(vm, globalObject-&gt;stringObjectStructure());
409     object-&gt;finishCreation(vm, string);
410     return object;
411 }
412 
<span class="line-modified">413 JSObject* JSString::toObject(JSGlobalObject* globalObject) const</span>
414 {
<span class="line-modified">415     return StringObject::create(globalObject-&gt;vm(), globalObject, const_cast&lt;JSString*&gt;(this));</span>
416 }
417 
<span class="line-modified">418 JSValue JSString::toThis(JSCell* cell, JSGlobalObject* globalObject, ECMAMode ecmaMode)</span>
419 {
420     if (ecmaMode == StrictMode)
421         return cell;
<span class="line-modified">422     return StringObject::create(globalObject-&gt;vm(), globalObject, asString(cell));</span>
423 }
424 
<span class="line-modified">425 bool JSString::getStringPropertyDescriptor(JSGlobalObject* globalObject, PropertyName propertyName, PropertyDescriptor&amp; descriptor)</span>
426 {
<span class="line-modified">427     VM&amp; vm = globalObject-&gt;vm();</span>
428     if (propertyName == vm.propertyNames-&gt;length) {
429         descriptor.setDescriptor(jsNumber(length()), PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);
430         return true;
431     }
432 
433     Optional&lt;uint32_t&gt; index = parseIndex(propertyName);
434     if (index &amp;&amp; index.value() &lt; length()) {
<span class="line-modified">435         descriptor.setDescriptor(getIndex(globalObject, index.value()), PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly);</span>
436         return true;
437     }
438 
439     return false;
440 }
441 
442 JSString* jsStringWithCacheSlowCase(VM&amp; vm, StringImpl&amp; stringImpl)
443 {
444     if (JSString* string = vm.stringCache.get(&amp;stringImpl))
445         return string;
446 
447     JSString* string = jsString(vm, String(stringImpl));
448     vm.lastCachedString.set(vm, string);
449     return string;
450 }
451 
452 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSSourceCode.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSString.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
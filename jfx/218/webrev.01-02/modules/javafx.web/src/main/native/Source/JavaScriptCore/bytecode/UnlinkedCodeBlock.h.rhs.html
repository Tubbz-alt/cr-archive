<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlock.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012-2019 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;BytecodeConventions.h&quot;
 29 #include &quot;CodeType.h&quot;
 30 #include &quot;DFGExitProfile.h&quot;
 31 #include &quot;ExpressionRangeInfo.h&quot;
 32 #include &quot;HandlerInfo.h&quot;
 33 #include &quot;Identifier.h&quot;
 34 #include &quot;InstructionStream.h&quot;
 35 #include &quot;JSCast.h&quot;
 36 #include &quot;LockDuringMarking.h&quot;
 37 #include &quot;Opcode.h&quot;
 38 #include &quot;ParserModes.h&quot;
 39 #include &quot;RegExp.h&quot;
<a name="1" id="anc1"></a>
 40 #include &quot;UnlinkedFunctionExecutable.h&quot;
 41 #include &quot;UnlinkedMetadataTable.h&quot;
 42 #include &quot;VirtualRegister.h&quot;
 43 #include &lt;algorithm&gt;
 44 #include &lt;wtf/BitVector.h&gt;
 45 #include &lt;wtf/HashSet.h&gt;
<a name="2" id="anc2"></a><span class="line-added"> 46 #include &lt;wtf/RefCountedArray.h&gt;</span>
 47 #include &lt;wtf/TriState.h&gt;
 48 #include &lt;wtf/Vector.h&gt;
 49 #include &lt;wtf/text/UniquedStringImpl.h&gt;
 50 
 51 namespace JSC {
 52 
<a name="3" id="anc3"></a>
 53 class BytecodeLivenessAnalysis;
 54 class BytecodeRewriter;
 55 class CodeBlock;
 56 class Debugger;
 57 class FunctionExecutable;
 58 class ParserError;
 59 class ScriptExecutable;
 60 class SourceCode;
 61 class SourceProvider;
 62 class UnlinkedCodeBlock;
<a name="4" id="anc4"></a><span class="line-added"> 63 class UnlinkedCodeBlockGenerator;</span>
 64 class UnlinkedFunctionCodeBlock;
 65 class UnlinkedFunctionExecutable;
 66 struct ExecutableInfo;
<a name="5" id="anc5"></a><span class="line-added"> 67 enum class LinkTimeConstant : int32_t;</span>
 68 
 69 template&lt;typename CodeBlockType&gt;
 70 class CachedCodeBlock;
 71 
 72 typedef unsigned UnlinkedValueProfile;
 73 typedef unsigned UnlinkedArrayProfile;
 74 typedef unsigned UnlinkedArrayAllocationProfile;
 75 typedef unsigned UnlinkedObjectAllocationProfile;
 76 typedef unsigned UnlinkedLLIntCallLinkInfo;
 77 using ConstantIdentifierSetEntry = std::pair&lt;IdentifierSet, unsigned&gt;;
 78 
 79 struct UnlinkedStringJumpTable {
 80     struct OffsetLocation {
 81         int32_t branchOffset;
 82     };
 83 
 84     typedef HashMap&lt;RefPtr&lt;StringImpl&gt;, OffsetLocation&gt; StringOffsetTable;
 85     StringOffsetTable offsetTable;
 86 
 87     inline int32_t offsetForValue(StringImpl* value, int32_t defaultOffset)
 88     {
 89         StringOffsetTable::const_iterator end = offsetTable.end();
 90         StringOffsetTable::const_iterator loc = offsetTable.find(value);
 91         if (loc == end)
 92             return defaultOffset;
 93         return loc-&gt;value.branchOffset;
 94     }
 95 
 96 };
 97 
 98 struct UnlinkedSimpleJumpTable {
<a name="6" id="anc6"></a><span class="line-modified"> 99     RefCountedArray&lt;int32_t&gt; branchOffsets;</span>
100     int32_t min;
101 
102     int32_t offsetForValue(int32_t value, int32_t defaultOffset);
103     void add(int32_t key, int32_t offset)
104     {
105         if (!branchOffsets[key])
106             branchOffsets[key] = offset;
107     }
108 };
109 
110 class UnlinkedCodeBlock : public JSCell {
111 public:
112     typedef JSCell Base;
<a name="7" id="anc7"></a><span class="line-modified">113     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
114 
<a name="8" id="anc8"></a><span class="line-modified">115     static constexpr bool needsDestruction = true;</span>
<span class="line-added">116 </span>
<span class="line-added">117     template&lt;typename, SubspaceAccess&gt;</span>
<span class="line-added">118     static void subspaceFor(VM&amp;)</span>
<span class="line-added">119     {</span>
<span class="line-added">120         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">121     }</span>
122 
123     enum { CallFunction, ApplyFunction };
124 
125     bool isConstructor() const { return m_isConstructor; }
126     bool isStrictMode() const { return m_isStrictMode; }
127     bool usesEval() const { return m_usesEval; }
128     SourceParseMode parseMode() const { return m_parseMode; }
129     bool isArrowFunction() const { return isArrowFunctionParseMode(parseMode()); }
130     DerivedContextType derivedContextType() const { return static_cast&lt;DerivedContextType&gt;(m_derivedContextType); }
131     EvalContextType evalContextType() const { return static_cast&lt;EvalContextType&gt;(m_evalContextType); }
132     bool isArrowFunctionContext() const { return m_isArrowFunctionContext; }
133     bool isClassContext() const { return m_isClassContext; }
134     bool hasTailCalls() const { return m_hasTailCalls; }
135     void setHasTailCalls() { m_hasTailCalls = true; }
136     bool allowDirectEvalCache() const { return !(m_features &amp; NoEvalCacheFeature); }
137 
<a name="9" id="anc9"></a>




138     bool hasExpressionInfo() { return m_expressionInfo.size(); }
<a name="10" id="anc10"></a><span class="line-modified">139     const RefCountedArray&lt;ExpressionRangeInfo&gt;&amp; expressionInfo() { return m_expressionInfo; }</span>
<span class="line-added">140 </span>
<span class="line-added">141     bool hasCheckpoints() const { return m_hasCheckpoints; }</span>
<span class="line-added">142     void setHasCheckpoints() { m_hasCheckpoints = true; }</span>
143 
144     // Special registers
145     void setThisRegister(VirtualRegister thisRegister) { m_thisRegister = thisRegister; }
146     void setScopeRegister(VirtualRegister scopeRegister) { m_scopeRegister = scopeRegister; }
147 
148     // Parameter information
149     void setNumParameters(int newValue) { m_numParameters = newValue; }
<a name="11" id="anc11"></a>
150     unsigned numParameters() const { return m_numParameters; }
151 
152     // Constant Pools
153 
154     size_t numberOfIdentifiers() const { return m_identifiers.size(); }
<a name="12" id="anc12"></a>
155     const Identifier&amp; identifier(int index) const { return m_identifiers[index]; }
<a name="13" id="anc13"></a><span class="line-modified">156     const RefCountedArray&lt;Identifier&gt;&amp; identifiers() const { return m_identifiers; }</span>
157 
158     BitVector&amp; bitVector(size_t i) { ASSERT(m_rareData); return m_rareData-&gt;m_bitVectors[i]; }
<a name="14" id="anc14"></a>





159 
<a name="15" id="anc15"></a><span class="line-modified">160     const RefCountedArray&lt;WriteBarrier&lt;Unknown&gt;&gt;&amp; constantRegisters() { return m_constantRegisters; }</span>
<span class="line-modified">161     const WriteBarrier&lt;Unknown&gt;&amp; constantRegister(VirtualRegister reg) const { return m_constantRegisters[reg.toConstantIndex()]; }</span>
<span class="line-modified">162     ALWAYS_INLINE JSValue getConstant(VirtualRegister reg) const { return m_constantRegisters[reg.toConstantIndex()].get(); }</span>
<span class="line-modified">163     const RefCountedArray&lt;SourceCodeRepresentation&gt;&amp; constantsSourceCodeRepresentation() { return m_constantsSourceCodeRepresentation; }</span>











































164 
165     unsigned numberOfConstantIdentifierSets() const { return m_rareData ? m_rareData-&gt;m_constantIdentifierSets.size() : 0; }
<a name="16" id="anc16"></a><span class="line-modified">166     const RefCountedArray&lt;ConstantIdentifierSetEntry&gt;&amp; constantIdentifierSets() { ASSERT(m_rareData); return m_rareData-&gt;m_constantIdentifierSets; }</span>
167 
168     // Jumps
169     size_t numberOfJumpTargets() const { return m_jumpTargets.size(); }
<a name="17" id="anc17"></a>
170     unsigned jumpTarget(int index) const { return m_jumpTargets[index]; }
171     unsigned lastJumpTarget() const { return m_jumpTargets.last(); }
172 
<a name="18" id="anc18"></a><span class="line-modified">173     UnlinkedHandlerInfo* handlerForBytecodeIndex(BytecodeIndex, RequiredHandler = RequiredHandler::AnyHandler);</span>
174     UnlinkedHandlerInfo* handlerForIndex(unsigned, RequiredHandler = RequiredHandler::AnyHandler);
175 
176     bool isBuiltinFunction() const { return m_isBuiltinFunction; }
177 
178     ConstructorKind constructorKind() const { return static_cast&lt;ConstructorKind&gt;(m_constructorKind); }
179     SuperBinding superBinding() const { return static_cast&lt;SuperBinding&gt;(m_superBinding); }
180     JSParserScriptMode scriptMode() const { return static_cast&lt;JSParserScriptMode&gt;(m_scriptMode); }
181 
<a name="19" id="anc19"></a>


182     const InstructionStream&amp; instructions() const;
183 
184     int numCalleeLocals() const { return m_numCalleeLocals; }
185     int numVars() const { return m_numVars; }
186 
187     // Jump Tables
188 
189     size_t numberOfSwitchJumpTables() const { return m_rareData ? m_rareData-&gt;m_switchJumpTables.size() : 0; }
<a name="20" id="anc20"></a>
190     UnlinkedSimpleJumpTable&amp; switchJumpTable(int tableIndex) { ASSERT(m_rareData); return m_rareData-&gt;m_switchJumpTables[tableIndex]; }
191 
192     size_t numberOfStringSwitchJumpTables() const { return m_rareData ? m_rareData-&gt;m_stringSwitchJumpTables.size() : 0; }
<a name="21" id="anc21"></a>
193     UnlinkedStringJumpTable&amp; stringSwitchJumpTable(int tableIndex) { ASSERT(m_rareData); return m_rareData-&gt;m_stringSwitchJumpTables[tableIndex]; }
194 
<a name="22" id="anc22"></a>








195     UnlinkedFunctionExecutable* functionDecl(int index) { return m_functionDecls[index].get(); }
196     size_t numberOfFunctionDecls() { return m_functionDecls.size(); }
<a name="23" id="anc23"></a>








197     UnlinkedFunctionExecutable* functionExpr(int index) { return m_functionExprs[index].get(); }
198     size_t numberOfFunctionExprs() { return m_functionExprs.size(); }
199 
200     // Exception handling support
201     size_t numberOfExceptionHandlers() const { return m_rareData ? m_rareData-&gt;m_exceptionHandlers.size() : 0; }
<a name="24" id="anc24"></a>
202     UnlinkedHandlerInfo&amp; exceptionHandler(int index) { ASSERT(m_rareData); return m_rareData-&gt;m_exceptionHandlers[index]; }
203 
204     CodeType codeType() const { return static_cast&lt;CodeType&gt;(m_codeType); }
205 
206     VirtualRegister thisRegister() const { return m_thisRegister; }
207     VirtualRegister scopeRegister() const { return m_scopeRegister; }
208 
<a name="25" id="anc25"></a>







209     bool hasRareData() const { return m_rareData.get(); }
210 
<a name="26" id="anc26"></a><span class="line-modified">211     int lineNumberForBytecodeIndex(BytecodeIndex);</span>
212 
<a name="27" id="anc27"></a><span class="line-modified">213     void expressionRangeForBytecodeIndex(BytecodeIndex, int&amp; divot,</span>
214         int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const;
215 
216     bool typeProfilerExpressionInfoForBytecodeOffset(unsigned bytecodeOffset, unsigned&amp; startDivot, unsigned&amp; endDivot);
217 
218     void recordParse(CodeFeatures features, bool hasCapturedVariables, unsigned lineCount, unsigned endColumn)
219     {
220         m_features = features;
221         m_hasCapturedVariables = hasCapturedVariables;
222         m_lineCount = lineCount;
223         // For the UnlinkedCodeBlock, startColumn is always 0.
224         m_endColumn = endColumn;
225     }
226 
<a name="28" id="anc28"></a><span class="line-modified">227     StringImpl* sourceURLDirective() const { return m_sourceURLDirective.get(); }</span>
<span class="line-modified">228     StringImpl* sourceMappingURLDirective() const { return m_sourceMappingURLDirective.get(); }</span>
<span class="line-modified">229     void setSourceURLDirective(const String&amp; sourceURL) { m_sourceURLDirective = sourceURL.impl(); }</span>
<span class="line-modified">230     void setSourceMappingURLDirective(const String&amp; sourceMappingURL) { m_sourceMappingURLDirective = sourceMappingURL.impl(); }</span>
231 
232     CodeFeatures codeFeatures() const { return m_features; }
233     bool hasCapturedVariables() const { return m_hasCapturedVariables; }
234     unsigned lineCount() const { return m_lineCount; }
235     ALWAYS_INLINE unsigned startColumn() const { return 0; }
236     unsigned endColumn() const { return m_endColumn; }
237 
<a name="29" id="anc29"></a><span class="line-modified">238     const RefCountedArray&lt;InstructionStream::Offset&gt;&amp; opProfileControlFlowBytecodeOffsets() const</span>





239     {
240         ASSERT(m_rareData);
241         return m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets;
242     }
243     bool hasOpProfileControlFlowBytecodeOffsets() const
244     {
245         return m_rareData &amp;&amp; !m_rareData-&gt;m_opProfileControlFlowBytecodeOffsets.isEmpty();
246     }
247 
248     void dumpExpressionRangeInfo(); // For debugging purpose only.
249 
250     bool wasCompiledWithDebuggingOpcodes() const { return m_codeGenerationMode.contains(CodeGenerationMode::Debugger); }
251     bool wasCompiledWithTypeProfilerOpcodes() const { return m_codeGenerationMode.contains(CodeGenerationMode::TypeProfiler); }
252     bool wasCompiledWithControlFlowProfilerOpcodes() const { return m_codeGenerationMode.contains(CodeGenerationMode::ControlFlowProfiler); }
253     OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode() const { return m_codeGenerationMode; }
254 
255     TriState didOptimize() const { return static_cast&lt;TriState&gt;(m_didOptimize); }
256     void setDidOptimize(TriState didOptimize) { m_didOptimize = static_cast&lt;unsigned&gt;(didOptimize); }
257 
258     static constexpr unsigned maxAge = 7;
259 
260     unsigned age() const { return m_age; }
261     void resetAge() { m_age = 0; }
262 
<a name="30" id="anc30"></a><span class="line-added">263     NeedsClassFieldInitializer needsClassFieldInitializer() const</span>
<span class="line-added">264     {</span>
<span class="line-added">265         if (m_rareData)</span>
<span class="line-added">266             return static_cast&lt;NeedsClassFieldInitializer&gt;(m_rareData-&gt;m_needsClassFieldInitializer);</span>
<span class="line-added">267         return NeedsClassFieldInitializer::No;</span>
<span class="line-added">268     }</span>
<span class="line-added">269 </span>
270     void dump(PrintStream&amp;) const;
271 
272     BytecodeLivenessAnalysis&amp; livenessAnalysis(CodeBlock* codeBlock)
273     {
274         if (m_liveness)
275             return *m_liveness;
276         return livenessAnalysisSlow(codeBlock);
277     }
278 
279 #if ENABLE(DFG_JIT)
280     bool hasExitSite(const ConcurrentJSLocker&amp; locker, const DFG::FrequentExitSite&amp; site) const
281     {
282         return m_exitProfile.hasExitSite(locker, site);
283     }
284 
285     bool hasExitSite(const DFG::FrequentExitSite&amp; site)
286     {
287         ConcurrentJSLocker locker(m_lock);
288         return hasExitSite(locker, site);
289     }
290 
291     DFG::ExitProfile&amp; exitProfile() { return m_exitProfile; }
292 #endif
293 
294     UnlinkedMetadataTable&amp; metadata() { return m_metadata.get(); }
295 
296     size_t metadataSizeInBytes()
297     {
298         return m_metadata-&gt;sizeInBytes();
299     }
300 
301 
302 protected:
303     UnlinkedCodeBlock(VM&amp;, Structure*, CodeType, const ExecutableInfo&amp;, OptionSet&lt;CodeGenerationMode&gt;);
304 
305     template&lt;typename CodeBlockType&gt;
306     UnlinkedCodeBlock(Decoder&amp;, Structure*, const CachedCodeBlock&lt;CodeBlockType&gt;&amp;);
307 
308     ~UnlinkedCodeBlock();
309 
310     void finishCreation(VM&amp; vm)
311     {
312         Base::finishCreation(vm);
313     }
314 
315 private:
316     friend class BytecodeRewriter;
<a name="31" id="anc31"></a><span class="line-modified">317     friend class UnlinkedCodeBlockGenerator;</span>
<span class="line-added">318     template&lt;typename Traits&gt;</span>
<span class="line-added">319     friend class BytecodeGeneratorBase;</span>
320 
321     template&lt;typename CodeBlockType&gt;
322     friend class CachedCodeBlock;
323 
<a name="32" id="anc32"></a><span class="line-modified">324     void createRareDataIfNecessary(const AbstractLocker&amp;)</span>


325     {
<a name="33" id="anc33"></a><span class="line-modified">326         if (!m_rareData)</span>

327             m_rareData = makeUnique&lt;RareData&gt;();
<a name="34" id="anc34"></a>
328     }
329 
330     void getLineAndColumn(const ExpressionRangeInfo&amp;, unsigned&amp; line, unsigned&amp; column) const;
331     BytecodeLivenessAnalysis&amp; livenessAnalysisSlow(CodeBlock*);
332 
333 
334     VirtualRegister m_thisRegister;
335     VirtualRegister m_scopeRegister;
336 
<a name="35" id="anc35"></a>

337     unsigned m_usesEval : 1;
338     unsigned m_isStrictMode : 1;
339     unsigned m_isConstructor : 1;
340     unsigned m_hasCapturedVariables : 1;
341     unsigned m_isBuiltinFunction : 1;
342     unsigned m_superBinding : 1;
343     unsigned m_scriptMode: 1;
344     unsigned m_isArrowFunctionContext : 1;
345     unsigned m_isClassContext : 1;
346     unsigned m_hasTailCalls : 1;
347     unsigned m_constructorKind : 2;
348     unsigned m_derivedContextType : 2;
349     unsigned m_evalContextType : 2;
350     unsigned m_codeType : 2;
351     unsigned m_didOptimize : 2;
352     unsigned m_age : 3;
353     static_assert(((1U &lt;&lt; 3) - 1) &gt;= maxAge);
<a name="36" id="anc36"></a><span class="line-added">354     bool m_hasCheckpoints : 1;</span>
355 public:
356     ConcurrentJSLock m_lock;
357 private:
358     CodeFeatures m_features { 0 };
359     SourceParseMode m_parseMode;
360     OptionSet&lt;CodeGenerationMode&gt; m_codeGenerationMode;
361 
362     unsigned m_lineCount { 0 };
363     unsigned m_endColumn { UINT_MAX };
364 
365     int m_numVars { 0 };
366     int m_numCalleeLocals { 0 };
367     int m_numParameters { 0 };
368 
<a name="37" id="anc37"></a><span class="line-modified">369     PackedRefPtr&lt;StringImpl&gt; m_sourceURLDirective;</span>
<span class="line-modified">370     PackedRefPtr&lt;StringImpl&gt; m_sourceMappingURLDirective;</span>
371 
<a name="38" id="anc38"></a><span class="line-modified">372     RefCountedArray&lt;InstructionStream::Offset&gt; m_jumpTargets;</span>
373     Ref&lt;UnlinkedMetadataTable&gt; m_metadata;
374     std::unique_ptr&lt;InstructionStream&gt; m_instructions;
375     std::unique_ptr&lt;BytecodeLivenessAnalysis&gt; m_liveness;
376 
377 
378 #if ENABLE(DFG_JIT)
379     DFG::ExitProfile m_exitProfile;
380 #endif
381 
<a name="39" id="anc39"></a>


382     // Constant Pools
<a name="40" id="anc40"></a><span class="line-modified">383     RefCountedArray&lt;Identifier&gt; m_identifiers;</span>
<span class="line-modified">384     RefCountedArray&lt;WriteBarrier&lt;Unknown&gt;&gt; m_constantRegisters;</span>
<span class="line-modified">385     RefCountedArray&lt;SourceCodeRepresentation&gt; m_constantsSourceCodeRepresentation;</span>
<span class="line-modified">386     using FunctionExpressionVector = RefCountedArray&lt;WriteBarrier&lt;UnlinkedFunctionExecutable&gt;&gt;;</span>
387     FunctionExpressionVector m_functionDecls;
388     FunctionExpressionVector m_functionExprs;
389 
390 public:
391     struct RareData {
392         WTF_MAKE_STRUCT_FAST_ALLOCATED;
393 
<a name="41" id="anc41"></a><span class="line-modified">394         RefCountedArray&lt;UnlinkedHandlerInfo&gt; m_exceptionHandlers;</span>
395 
396         // Jump Tables
<a name="42" id="anc42"></a><span class="line-modified">397         RefCountedArray&lt;UnlinkedSimpleJumpTable&gt; m_switchJumpTables;</span>
<span class="line-modified">398         RefCountedArray&lt;UnlinkedStringJumpTable&gt; m_stringSwitchJumpTables;</span>
399 
<a name="43" id="anc43"></a><span class="line-modified">400         RefCountedArray&lt;ExpressionRangeInfo::FatPosition&gt; m_expressionInfoFatPositions;</span>
401 
402         struct TypeProfilerExpressionRange {
403             unsigned m_startDivot;
404             unsigned m_endDivot;
405         };
406         HashMap&lt;unsigned, TypeProfilerExpressionRange&gt; m_typeProfilerInfoMap;
<a name="44" id="anc44"></a><span class="line-modified">407         RefCountedArray&lt;InstructionStream::Offset&gt; m_opProfileControlFlowBytecodeOffsets;</span>
<span class="line-modified">408         RefCountedArray&lt;BitVector&gt; m_bitVectors;</span>
<span class="line-modified">409         RefCountedArray&lt;ConstantIdentifierSetEntry&gt; m_constantIdentifierSets;</span>
<span class="line-added">410 </span>
<span class="line-added">411         unsigned m_needsClassFieldInitializer : 1;</span>
412     };
413 
<a name="45" id="anc45"></a>
414     int outOfLineJumpOffset(InstructionStream::Offset);
415     int outOfLineJumpOffset(const InstructionStream::Ref&amp; instruction)
416     {
417         return outOfLineJumpOffset(instruction.offset());
418     }
419 
420 private:
421     using OutOfLineJumpTargets = HashMap&lt;InstructionStream::Offset, int&gt;;
422 
<a name="46" id="anc46"></a>






423     OutOfLineJumpTargets m_outOfLineJumpTargets;
424     std::unique_ptr&lt;RareData&gt; m_rareData;
<a name="47" id="anc47"></a><span class="line-modified">425     RefCountedArray&lt;ExpressionRangeInfo&gt; m_expressionInfo;</span>
426 
427 protected:
428     static void visitChildren(JSCell*, SlotVisitor&amp;);
429     static size_t estimatedSize(JSCell*, VM&amp;);
430 
431 public:
432     DECLARE_INFO;
433 };
434 
435 }
<a name="48" id="anc48"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="48" type="hidden" />
</body>
</html>
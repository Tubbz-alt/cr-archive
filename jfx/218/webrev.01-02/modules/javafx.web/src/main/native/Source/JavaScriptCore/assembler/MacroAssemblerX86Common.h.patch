diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerX86Common.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerX86Common.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerX86Common.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerX86Common.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2008-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -38,11 +38,11 @@
 
 class MacroAssemblerX86Common : public AbstractMacroAssembler<Assembler> {
 public:
 #if CPU(X86_64)
     // Use this directly only if you're not generating code with it.
-    static const X86Registers::RegisterID s_scratchRegister = X86Registers::r11;
+    static constexpr X86Registers::RegisterID s_scratchRegister = X86Registers::r11;
 
     // Use this when generating code so that we get enforcement of the disallowing of scratch register
     // usage.
     X86Registers::RegisterID scratchRegister()
     {
@@ -50,13 +50,13 @@
         return s_scratchRegister;
     }
 #endif
 
 protected:
-    static const int DoubleConditionBitInvert = 0x10;
-    static const int DoubleConditionBitSpecial = 0x20;
-    static const int DoubleConditionBits = DoubleConditionBitInvert | DoubleConditionBitSpecial;
+    static constexpr int DoubleConditionBitInvert = 0x10;
+    static constexpr int DoubleConditionBitSpecial = 0x20;
+    static constexpr int DoubleConditionBits = DoubleConditionBitInvert | DoubleConditionBitSpecial;
 
 public:
     typedef X86Assembler::XMMRegisterID XMMRegisterID;
 
     static bool isCompactPtrAlignedAddressOffset(ptrdiff_t value)
@@ -104,12 +104,12 @@
     };
     COMPILE_ASSERT(
         !((X86Assembler::ConditionE | X86Assembler::ConditionNE | X86Assembler::ConditionA | X86Assembler::ConditionAE | X86Assembler::ConditionB | X86Assembler::ConditionBE) & DoubleConditionBits),
         DoubleConditionBits_should_not_interfere_with_X86Assembler_Condition_codes);
 
-    static const RegisterID stackPointerRegister = X86Registers::esp;
-    static const RegisterID framePointerRegister = X86Registers::ebp;
+    static constexpr RegisterID stackPointerRegister = X86Registers::esp;
+    static constexpr RegisterID framePointerRegister = X86Registers::ebp;
 
     static bool canBlind() { return true; }
     static bool shouldBlindForSpecificArch(uint32_t value) { return value >= 0x00ffffff; }
     static bool shouldBlindForSpecificArch(uint64_t value) { return value >= 0x00ffffff; }
 
@@ -1101,19 +1101,19 @@
     }
 
     void absDouble(FPRegisterID src, FPRegisterID dst)
     {
         ASSERT(src != dst);
-        static const double negativeZeroConstant = -0.0;
+        static constexpr double negativeZeroConstant = -0.0;
         loadDouble(TrustedImmPtr(&negativeZeroConstant), dst);
         m_assembler.andnpd_rr(src, dst);
     }
 
     void negateDouble(FPRegisterID src, FPRegisterID dst)
     {
         ASSERT(src != dst);
-        static const double negativeZeroConstant = -0.0;
+        static constexpr double negativeZeroConstant = -0.0;
         loadDouble(TrustedImmPtr(&negativeZeroConstant), dst);
         m_assembler.xorpd_rr(src, dst);
     }
 
     void ceilDouble(FPRegisterID src, FPRegisterID dst)

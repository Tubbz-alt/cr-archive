<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITNegGenerator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015, 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JITNegGenerator.h&quot;
 28 
 29 #include &quot;ArithProfile.h&quot;
 30 
 31 #if ENABLE(JIT)
 32 
 33 namespace JSC {
 34 
 35 JITMathICInlineResult JITNegGenerator::generateInline(CCallHelpers&amp; jit, MathICGenerationState&amp; state, const ArithProfile* arithProfile)
 36 {
 37     ASSERT(m_scratchGPR != InvalidGPRReg);
 38     ASSERT(m_scratchGPR != m_src.payloadGPR());
 39     ASSERT(m_scratchGPR != m_result.payloadGPR());
 40 #if USE(JSVALUE32_64)
 41     ASSERT(m_scratchGPR != m_src.tagGPR());
 42     ASSERT(m_scratchGPR != m_result.tagGPR());
 43 #endif
 44 
 45     // We default to speculating int32.
 46     ObservedType observedTypes = ObservedType().withInt32();
 47     if (arithProfile)
 48         observedTypes = arithProfile-&gt;lhsObservedType();
 49     ASSERT_WITH_MESSAGE(!observedTypes.isEmpty(), &quot;We should not attempt to generate anything if we do not have a profile.&quot;);
 50 
 51     if (observedTypes.isOnlyNonNumber())
 52         return JITMathICInlineResult::DontGenerate;
 53 
 54     if (observedTypes.isOnlyInt32()) {
 55         jit.moveValueRegs(m_src, m_result);
 56         state.slowPathJumps.append(jit.branchIfNotInt32(m_src));
 57         state.slowPathJumps.append(jit.branchTest32(CCallHelpers::Zero, m_src.payloadGPR(), CCallHelpers::TrustedImm32(0x7fffffff)));
 58         jit.neg32(m_result.payloadGPR());
 59 #if USE(JSVALUE64)
 60         jit.boxInt32(m_result.payloadGPR(), m_result);
 61 #endif
 62 
 63         return JITMathICInlineResult::GeneratedFastPath;
 64     }
 65     if (observedTypes.isOnlyNumber()) {
 66         state.slowPathJumps.append(jit.branchIfInt32(m_src));
 67         state.slowPathJumps.append(jit.branchIfNotNumber(m_src, m_scratchGPR));
 68 #if USE(JSVALUE64)
 69         if (m_src.payloadGPR() != m_result.payloadGPR()) {
 70             jit.move(CCallHelpers::TrustedImm64(static_cast&lt;int64_t&gt;(1ull &lt;&lt; 63)), m_result.payloadGPR());
 71             jit.xor64(m_src.payloadGPR(), m_result.payloadGPR());
 72         } else {
 73             jit.move(CCallHelpers::TrustedImm64(static_cast&lt;int64_t&gt;(1ull &lt;&lt; 63)), m_scratchGPR);
 74             jit.xor64(m_scratchGPR, m_result.payloadGPR());
 75         }
 76 #else
 77         jit.moveValueRegs(m_src, m_result);
 78         jit.xor32(CCallHelpers::TrustedImm32(1 &lt;&lt; 31), m_result.tagGPR());
 79 #endif
 80         return JITMathICInlineResult::GeneratedFastPath;
 81     }
 82     return JITMathICInlineResult::GenerateFullSnippet;
 83 }
 84 
 85 bool JITNegGenerator::generateFastPath(CCallHelpers&amp; jit, CCallHelpers::JumpList&amp; endJumpList, CCallHelpers::JumpList&amp; slowPathJumpList, const ArithProfile* arithProfile, bool shouldEmitProfiling)
 86 {
 87     ASSERT(m_scratchGPR != m_src.payloadGPR());
 88     ASSERT(m_scratchGPR != m_result.payloadGPR());
 89     ASSERT(m_scratchGPR != InvalidGPRReg);
 90 #if USE(JSVALUE32_64)
 91     ASSERT(m_scratchGPR != m_src.tagGPR());
 92     ASSERT(m_scratchGPR != m_result.tagGPR());
 93 #endif
 94 
 95     jit.moveValueRegs(m_src, m_result);
 96     CCallHelpers::Jump srcNotInt = jit.branchIfNotInt32(m_src);
 97 
 98     // -0 should produce a double, and hence cannot be negated as an int.
 99     // The negative int32 0x80000000 doesn&#39;t have a positive int32 representation, and hence cannot be negated as an int.
100     slowPathJumpList.append(jit.branchTest32(CCallHelpers::Zero, m_src.payloadGPR(), CCallHelpers::TrustedImm32(0x7fffffff)));
101 
102     jit.neg32(m_result.payloadGPR());
103 #if USE(JSVALUE64)
104     jit.boxInt32(m_result.payloadGPR(), m_result);
105 #endif
106     endJumpList.append(jit.jump());
107 
108     srcNotInt.link(&amp;jit);
109     slowPathJumpList.append(jit.branchIfNotNumber(m_src, m_scratchGPR));
110 
111     // For a double, all we need to do is to invert the sign bit.
112 #if USE(JSVALUE64)
113     jit.move(CCallHelpers::TrustedImm64((int64_t)(1ull &lt;&lt; 63)), m_scratchGPR);
114     jit.xor64(m_scratchGPR, m_result.payloadGPR());
115 #else
116     jit.xor32(CCallHelpers::TrustedImm32(1 &lt;&lt; 31), m_result.tagGPR());
117 #endif
118     // The flags of ArithNegate are basic in DFG.
119     // We only need to know if we ever produced a number.
120     if (shouldEmitProfiling &amp;&amp; arithProfile &amp;&amp; !arithProfile-&gt;lhsObservedType().sawNumber() &amp;&amp; !arithProfile-&gt;didObserveDouble())
121         arithProfile-&gt;emitSetDouble(jit);
122     return true;
123 }
124 
125 } // namespace JSC
126 
127 #endif // ENABLE(JIT)
    </pre>
  </body>
</html>
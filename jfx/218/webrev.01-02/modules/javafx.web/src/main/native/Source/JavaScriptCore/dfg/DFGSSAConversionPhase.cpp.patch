diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSSAConversionPhase.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSSAConversionPhase.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSSAConversionPhase.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSSAConversionPhase.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2013-2017 Apple Inc. All rights reserved.
+ * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -46,11 +46,11 @@
 } while (0)
 
 namespace JSC { namespace DFG {
 
 class SSAConversionPhase : public Phase {
-    static const bool verbose = false;
+    static constexpr bool verbose = false;
 
 public:
     SSAConversionPhase(Graph& graph)
         : Phase(graph, "SSA conversion")
         , m_insertionSet(graph)
@@ -95,18 +95,18 @@
                 ASSERT(oldRoot->predecessors.isEmpty());
                 oldRoot->predecessors.append(newRoot);
 
                 if (oldRoot->isCatchEntrypoint) {
                     ASSERT(!!entrypointIndex);
-                    m_graph.m_entrypointIndexToCatchBytecodeOffset.add(entrypointIndex, oldRoot->bytecodeBegin);
+                    m_graph.m_entrypointIndexToCatchBytecodeIndex.add(entrypointIndex, oldRoot->bytecodeBegin);
                 }
             }
 
             RELEASE_ASSERT(entrySwitchData->cases[0] == m_graph.block(0)); // We strongly assume the normal call entrypoint is the first item in the list.
 
             const bool exitOK = false;
-            NodeOrigin origin { CodeOrigin(0), CodeOrigin(0), exitOK };
+            NodeOrigin origin { CodeOrigin(BytecodeIndex(0)), CodeOrigin(BytecodeIndex(0)), exitOK };
             newRoot->appendNode(
                 m_graph, SpecNone, EntrySwitch, origin, OpInfo(entrySwitchData));
 
             m_graph.m_roots.clear();
             m_graph.m_roots.append(newRoot);
@@ -156,12 +156,12 @@
                 else {
                     ASSERT(node->op() == SetArgumentDefinitely);
                     childNode = m_insertionSet.insertNode(
                         nodeIndex, node->variableAccessData()->prediction(),
                         GetStack, node->origin,
-                        OpInfo(m_graph.m_stackAccessData.add(variable->local(), variable->flushFormat())));
-                    if (!ASSERT_DISABLED)
+                        OpInfo(m_graph.m_stackAccessData.add(variable->operand(), variable->flushFormat())));
+                    if (ASSERT_ENABLED)
                         m_argumentGetters.add(childNode);
                     m_argumentMapping.add(node, childNode);
                 }
 
                 calculator.newDef(
@@ -176,11 +176,11 @@
         calculator.computePhis(
             [&] (SSACalculator::Variable* ssaVariable, BasicBlock* block) -> Node* {
                 VariableAccessData* variable = m_variableForSSAIndex[ssaVariable->index()];
 
                 // Prune by liveness. This doesn't buy us much other than compile times.
-                Node* headNode = block->variablesAtHead.operand(variable->local());
+                Node* headNode = block->variablesAtHead.operand(variable->operand());
                 if (!headNode)
                     return nullptr;
 
                 // There is the possibiltiy of "rebirths". The SSA calculator will already prune
                 // rebirths for the same VariableAccessData. But it will not be able to prune
@@ -298,11 +298,11 @@
                         // would not in turn have a replacement.
                         node = node->replacement();
                         ASSERT(!node->replacement());
                     }
                     if (verbose)
-                        dataLog("Mapping: ", VirtualRegister(valueForOperand.operandForIndex(i)), " -> ", node, "\n");
+                        dataLog("Mapping: ", valueForOperand.operandForIndex(i), " -> ", node, "\n");
                     valueForOperand[i] = node;
                 }
             }
 
             // Insert Phis by asking the calculator what phis there are in this block. Also update
@@ -311,15 +311,15 @@
             size_t phiInsertionPoint = 0;
             for (SSACalculator::Def* phiDef : calculator.phisForBlock(block)) {
                 VariableAccessData* variable = m_variableForSSAIndex[phiDef->variable()->index()];
 
                 m_insertionSet.insert(phiInsertionPoint, phiDef->value());
-                valueForOperand.operand(variable->local()) = phiDef->value();
+                valueForOperand.operand(variable->operand()) = phiDef->value();
 
                 m_insertionSet.insertNode(
                     phiInsertionPoint, SpecNone, MovHint, block->at(0)->origin.withInvalidExit(),
-                    OpInfo(variable->local().offset()), phiDef->value()->defaultEdge());
+                    OpInfo(variable->operand()), phiDef->value()->defaultEdge());
             }
 
             if (block->at(0)->origin.exitOK)
                 m_insertionSet.insertNode(phiInsertionPoint, SpecNone, ExitOK, block->at(0)->origin);
 
@@ -335,11 +335,11 @@
 
                 switch (node->op()) {
                 case MovHint: {
                     m_insertionSet.insertNode(
                         nodeIndex, SpecNone, KillStack, node->origin,
-                        OpInfo(node->unlinkedLocal().offset()));
+                        OpInfo(node->unlinkedOperand()));
                     node->origin.exitOK = false; // KillStack clobbers exit.
                     break;
                 }
 
                 case SetLocal: {
@@ -347,34 +347,34 @@
                     Node* child = node->child1().node();
 
                     if (!!(node->flags() & NodeIsFlushed)) {
                         node->convertToPutStack(
                             m_graph.m_stackAccessData.add(
-                                variable->local(), variable->flushFormat()));
+                                variable->operand(), variable->flushFormat()));
                     } else
                         node->remove(m_graph);
 
                     if (verbose)
-                        dataLog("Mapping: ", variable->local(), " -> ", child, "\n");
-                    valueForOperand.operand(variable->local()) = child;
+                        dataLog("Mapping: ", variable->operand(), " -> ", child, "\n");
+                    valueForOperand.operand(variable->operand()) = child;
                     break;
                 }
 
                 case GetStack: {
                     ASSERT(m_argumentGetters.contains(node));
-                    valueForOperand.operand(node->stackAccessData()->local) = node;
+                    valueForOperand.operand(node->stackAccessData()->operand) = node;
                     break;
                 }
 
                 case GetLocal: {
                     VariableAccessData* variable = node->variableAccessData();
                     node->children.reset();
 
                     node->remove(m_graph);
                     if (verbose)
-                        dataLog("Replacing node ", node, " with ", valueForOperand.operand(variable->local()), "\n");
-                    node->setReplacement(valueForOperand.operand(variable->local()));
+                        dataLog("Replacing node ", node, " with ", valueForOperand.operand(variable->operand()), "\n");
+                    node->setReplacement(valueForOperand.operand(variable->operand()));
                     break;
                 }
 
                 case Flush: {
                     node->children.reset();
@@ -383,11 +383,11 @@
                 }
 
                 case PhantomLocal: {
                     ASSERT(node->child1().useKind() == UntypedUse);
                     VariableAccessData* variable = node->variableAccessData();
-                    node->child1() = valueForOperand.operand(variable->local())->defaultEdge();
+                    node->child1() = valueForOperand.operand(variable->operand())->defaultEdge();
                     node->remove(m_graph);
                     break;
                 }
 
                 case SetArgumentDefinitely: {
@@ -423,14 +423,16 @@
                     // We can use an unchecked use kind because the SetLocal was turned into a Check.
                     // We have to use an unchecked use because at least sometimes, the end of the block
                     // is not exitOK.
                     UseKind useKind = uncheckedUseKindFor(format);
 
+                    dataLogLnIf(verbose, "Inserting Upsilon for ", variable->operand(), " propagating ", valueForOperand.operand(variable->operand()), " to ", phiNode);
+
                     m_insertionSet.insertNode(
                         upsilonInsertionPoint, SpecNone, Upsilon, upsilonOrigin,
                         OpInfo(phiNode), Edge(
-                            valueForOperand.operand(variable->local()),
+                            valueForOperand.operand(variable->operand()),
                             useKind));
                 }
             }
 
             m_insertionSet.execute(block);

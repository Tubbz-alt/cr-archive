<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollView.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScrollView.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScrollableArea.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollView.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 118,11 ***</span>
      bool verticalScrollbarLock() const { return m_verticalScrollbarLock; }
  
      void setScrollingModesLock(bool lock = true) { m_horizontalScrollbarLock = m_verticalScrollbarLock = lock; }
  
      WEBCORE_EXPORT virtual void setCanHaveScrollbars(bool);
<span class="line-removed">-     bool canHaveScrollbars() const { return horizontalScrollbarMode() != ScrollbarAlwaysOff || verticalScrollbarMode() != ScrollbarAlwaysOff; }</span>
  
      virtual bool avoidScrollbarCreation() const { return false; }
  
      void setScrollbarOverlayStyle(ScrollbarOverlayStyle) final;
  
<span class="line-new-header">--- 118,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,11 ***</span>
      WEBCORE_EXPORT void setDelegatesScrolling(bool);
  
      // Overridden by FrameView to create custom CSS scrollbars if applicable.
      virtual Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation);
  
<span class="line-modified">!     void styleDidChange();</span>
  
      // If the prohibits scrolling flag is set, then all scrolling in the view (even programmatic scrolling) is turned off.
      void setProhibitsScrolling(bool b) { m_prohibitsScrolling = b; }
      bool prohibitsScrolling() const { return m_prohibitsScrolling; }
  
<span class="line-new-header">--- 137,11 ---</span>
      WEBCORE_EXPORT void setDelegatesScrolling(bool);
  
      // Overridden by FrameView to create custom CSS scrollbars if applicable.
      virtual Ref&lt;Scrollbar&gt; createScrollbar(ScrollbarOrientation);
  
<span class="line-modified">!     virtual void styleDidChange();</span>
  
      // If the prohibits scrolling flag is set, then all scrolling in the view (even programmatic scrolling) is turned off.
      void setProhibitsScrolling(bool b) { m_prohibitsScrolling = b; }
      bool prohibitsScrolling() const { return m_prohibitsScrolling; }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,25 ***</span>
  
      // Parts of the document can be visible through transparent or blured UI widgets of the chrome. Those parts
      // contribute to painting but not to the scrollable area.
      // The unobscuredContentRect is the area that is not covered by UI elements.
      WEBCORE_EXPORT IntRect unobscuredContentRect(VisibleContentRectIncludesScrollbars = ExcludeScrollbars) const;
  #if PLATFORM(IOS_FAMILY)
      IntRect unobscuredContentRectIncludingScrollbars() const { return unobscuredContentRect(IncludeScrollbars); }
  #else
      IntRect unobscuredContentRectIncludingScrollbars() const { return visibleContentRectIncludingScrollbars(); }
  #endif
  
<span class="line-removed">- #if PLATFORM(IOS_FAMILY)</span>
      // This is the area that is partially or fully exposed, and may extend under overlapping UI elements.
      WEBCORE_EXPORT FloatRect exposedContentRect() const;
  
      // The given rects are only used if there is no platform widget.
      WEBCORE_EXPORT void setExposedContentRect(const FloatRect&amp;);
<span class="line-modified">!     const FloatSize&amp; unobscuredContentSize() const { return m_unobscuredContentSize; }</span>
      WEBCORE_EXPORT void setUnobscuredContentSize(const FloatSize&amp;);
  
      void setActualScrollPosition(const IntPoint&amp;);
      LegacyTileCache* legacyTileCache();
  #endif
  
      // Size available for view contents, including content inset areas. Not affected by zooming.
<span class="line-new-header">--- 173,27 ---</span>
  
      // Parts of the document can be visible through transparent or blured UI widgets of the chrome. Those parts
      // contribute to painting but not to the scrollable area.
      // The unobscuredContentRect is the area that is not covered by UI elements.
      WEBCORE_EXPORT IntRect unobscuredContentRect(VisibleContentRectIncludesScrollbars = ExcludeScrollbars) const;
<span class="line-added">+ </span>
  #if PLATFORM(IOS_FAMILY)
      IntRect unobscuredContentRectIncludingScrollbars() const { return unobscuredContentRect(IncludeScrollbars); }
  #else
      IntRect unobscuredContentRectIncludingScrollbars() const { return visibleContentRectIncludingScrollbars(); }
  #endif
  
      // This is the area that is partially or fully exposed, and may extend under overlapping UI elements.
      WEBCORE_EXPORT FloatRect exposedContentRect() const;
  
      // The given rects are only used if there is no platform widget.
      WEBCORE_EXPORT void setExposedContentRect(const FloatRect&amp;);
<span class="line-modified">! </span>
<span class="line-added">+     WEBCORE_EXPORT FloatSize unobscuredContentSize() const;</span>
      WEBCORE_EXPORT void setUnobscuredContentSize(const FloatSize&amp;);
  
<span class="line-added">+ #if PLATFORM(IOS_FAMILY)</span>
      void setActualScrollPosition(const IntPoint&amp;);
      LegacyTileCache* legacyTileCache();
  #endif
  
      // Size available for view contents, including content inset areas. Not affected by zooming.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 228,11 ***</span>
      int scrollX() const { return scrollPosition().x(); }
      int scrollY() const { return scrollPosition().y(); }
  
      // Scroll position used by web-exposed features (has legacy iOS behavior).
      WEBCORE_EXPORT IntPoint contentsScrollPosition() const;
<span class="line-modified">!     void setContentsScrollPosition(const IntPoint&amp;);</span>
  
  #if PLATFORM(IOS_FAMILY)
      int actualScrollX() const { return unobscuredContentRect().x(); }
      int actualScrollY() const { return unobscuredContentRect().y(); }
      // FIXME: maybe fix scrollPosition() on iOS to return the actual scroll position.
<span class="line-new-header">--- 229,11 ---</span>
      int scrollX() const { return scrollPosition().x(); }
      int scrollY() const { return scrollPosition().y(); }
  
      // Scroll position used by web-exposed features (has legacy iOS behavior).
      WEBCORE_EXPORT IntPoint contentsScrollPosition() const;
<span class="line-modified">!     void setContentsScrollPosition(const IntPoint&amp;, ScrollClamping = ScrollClamping::Clamped);</span>
  
  #if PLATFORM(IOS_FAMILY)
      int actualScrollX() const { return unobscuredContentRect().x(); }
      int actualScrollY() const { return unobscuredContentRect().y(); }
      // FIXME: maybe fix scrollPosition() on iOS to return the actual scroll position.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 258,11 ***</span>
  
      void cacheCurrentScrollPosition() { m_cachedScrollPosition = scrollPosition(); }
      ScrollPosition cachedScrollPosition() const { return m_cachedScrollPosition; }
  
      // Functions for scrolling the view.
<span class="line-modified">!     virtual void setScrollPosition(const ScrollPosition&amp;);</span>
      void scrollBy(const IntSize&amp; s) { return setScrollPosition(scrollPosition() + s); }
  
      // This function scrolls by lines, pages or pixels.
      bool scroll(ScrollDirection, ScrollGranularity);
  
<span class="line-new-header">--- 259,11 ---</span>
  
      void cacheCurrentScrollPosition() { m_cachedScrollPosition = scrollPosition(); }
      ScrollPosition cachedScrollPosition() const { return m_cachedScrollPosition; }
  
      // Functions for scrolling the view.
<span class="line-modified">!     virtual void setScrollPosition(const ScrollPosition&amp;, ScrollClamping = ScrollClamping::Clamped);</span>
      void scrollBy(const IntSize&amp; s) { return setScrollPosition(scrollPosition() + s); }
  
      // This function scrolls by lines, pages or pixels.
      bool scroll(ScrollDirection, ScrollGranularity);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 423,13 ***</span>
  
      virtual bool shouldDeferScrollUpdateAfterContentSizeChange() = 0;
  
      virtual void scrollOffsetChangedViaPlatformWidgetImpl(const ScrollOffset&amp;, const ScrollOffset&amp;) = 0;
  
<span class="line-removed">- #if PLATFORM(IOS_FAMILY)</span>
      virtual void unobscuredContentSizeChanged() = 0;
<span class="line-removed">- #endif</span>
  
  #if PLATFORM(COCOA) &amp;&amp; defined __OBJC__
  public:
      WEBCORE_EXPORT NSView* documentView() const;
  
<span class="line-new-header">--- 424,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 463,17 ***</span>
<span class="line-new-header">--- 462,24 ---</span>
      void platformRemoveChild(Widget*);
      void platformSetScrollbarModes();
      void platformScrollbarModes(ScrollbarMode&amp; horizontal, ScrollbarMode&amp; vertical) const;
      void platformSetCanBlitOnScroll(bool);
      bool platformCanBlitOnScroll() const;
<span class="line-added">+ </span>
      IntRect platformVisibleContentRect(bool includeScrollbars) const;
      IntSize platformVisibleContentSize(bool includeScrollbars) const;
      IntRect platformVisibleContentRectIncludingObscuredArea(bool includeScrollbars) const;
      IntSize platformVisibleContentSizeIncludingObscuredArea(bool includeScrollbars) const;
<span class="line-added">+ </span>
<span class="line-added">+     IntRect platformUnobscuredContentRect(VisibleContentRectIncludesScrollbars) const;</span>
<span class="line-added">+     FloatRect platformExposedContentRect() const;</span>
<span class="line-added">+ </span>
      void platformSetContentsSize();
<span class="line-added">+ </span>
      IntRect platformContentsToScreen(const IntRect&amp;) const;
      IntPoint platformScreenToContents(const IntPoint&amp;) const;
<span class="line-added">+ </span>
      void platformSetScrollPosition(const IntPoint&amp;);
      bool platformScroll(ScrollDirection, ScrollGranularity);
      void platformSetScrollbarsSuppressed(bool repaintOnUnsuppress);
      void platformRepaintContentRectangle(const IntRect&amp;);
      bool platformIsOffscreen() const;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 488,17 ***</span>
      RefPtr&lt;Scrollbar&gt; m_horizontalScrollbar;
      RefPtr&lt;Scrollbar&gt; m_verticalScrollbar;
      ScrollbarMode m_horizontalScrollbarMode { ScrollbarAuto };
      ScrollbarMode m_verticalScrollbarMode { ScrollbarAuto };
  
<span class="line-modified">! #if PLATFORM(IOS_FAMILY)</span>
      // FIXME: exposedContentRect is a very similar concept to fixedVisibleContentRect except it does not differentiate
      // between exposed and unobscured areas. The two attributes should eventually be merged.
<span class="line-removed">-     FloatRect m_exposedContentRect;</span>
<span class="line-removed">-     FloatSize m_unobscuredContentSize;</span>
<span class="line-removed">-     // This is only used for history scroll position restoration.</span>
<span class="line-removed">- #else</span>
      IntRect m_fixedVisibleContentRect;
  #endif
      ScrollPosition m_scrollPosition;
      IntPoint m_cachedScrollPosition;
      IntSize m_fixedLayoutSize;
<span class="line-new-header">--- 494,21 ---</span>
      RefPtr&lt;Scrollbar&gt; m_horizontalScrollbar;
      RefPtr&lt;Scrollbar&gt; m_verticalScrollbar;
      ScrollbarMode m_horizontalScrollbarMode { ScrollbarAuto };
      ScrollbarMode m_verticalScrollbarMode { ScrollbarAuto };
  
<span class="line-modified">! </span>
<span class="line-added">+     // FIXME: More things will move into here.</span>
<span class="line-added">+     struct DelegatedScrollingGeometry {</span>
<span class="line-added">+         FloatSize unobscuredContentSize;</span>
<span class="line-added">+         FloatRect exposedContentRect;</span>
<span class="line-added">+     };</span>
<span class="line-added">+     Optional&lt;DelegatedScrollingGeometry&gt; m_delegatedScrollingGeometry;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if USE(COORDINATED_GRAPHICS)</span>
      // FIXME: exposedContentRect is a very similar concept to fixedVisibleContentRect except it does not differentiate
      // between exposed and unobscured areas. The two attributes should eventually be merged.
      IntRect m_fixedVisibleContentRect;
  #endif
      ScrollPosition m_scrollPosition;
      IntPoint m_cachedScrollPosition;
      IntSize m_fixedLayoutSize;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 527,10 ***</span>
<span class="line-new-header">--- 537,11 ---</span>
      bool m_drawPanScrollIcon { false };
      bool m_useFixedLayout { false };
  
      bool m_paintsEntireContents { false };
      bool m_delegatesScrolling { false };
<span class="line-added">+ </span>
  }; // class ScrollView
  
  } // namespace WebCore
  
  SPECIALIZE_TYPE_TRAITS_WIDGET(ScrollView, isScrollView())
</pre>
<center><a href="ScrollView.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScrollableArea.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
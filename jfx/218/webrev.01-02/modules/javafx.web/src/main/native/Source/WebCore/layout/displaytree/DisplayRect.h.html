<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/displaytree/DisplayRect.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 29 
 30 #include &quot;LayoutRect.h&quot;
 31 #include &quot;LayoutUnits.h&quot;
 32 
 33 namespace WebCore {
 34 namespace Display {
 35 
 36 class Rect {
 37 public:
 38     Rect() = default;
 39     Rect(LayoutUnit top, LayoutUnit left, LayoutUnit width, LayoutUnit height);
 40     Rect(LayoutPoint topLeft, LayoutUnit width, LayoutUnit height);
 41 
 42     LayoutUnit top() const;
 43     LayoutUnit left() const;
 44     LayoutPoint topLeft() const;
 45 
 46     LayoutUnit bottom() const;
 47     LayoutUnit right() const;
 48     LayoutPoint bottomRight() const;
 49 
 50     LayoutUnit width() const;
 51     LayoutUnit height() const;
 52     LayoutSize size() const;
 53 
 54     void setTop(LayoutUnit);
 55     void setLeft(LayoutUnit);
 56     void setTopLeft(const LayoutPoint&amp;);
 57     void setWidth(LayoutUnit);
 58     void setHeight(LayoutUnit);
 59     void setSize(const LayoutSize&amp;);
 60 
 61     void shiftLeftTo(LayoutUnit);
 62     void shiftRightTo(LayoutUnit);
 63     void shiftTopTo(LayoutUnit);
 64     void shiftBottomTo(LayoutUnit);
 65 
 66     void moveHorizontally(LayoutUnit);
 67     void moveVertically(LayoutUnit);
 68 
 69     void expand(Optional&lt;LayoutUnit&gt;, Optional&lt;LayoutUnit&gt;);
 70     void expandHorizontally(LayoutUnit delta) { expand(delta, { }); }
 71     void expandVertically(LayoutUnit delta) { expand({ }, delta); }
 72     bool intersects(const Rect&amp; rect) const { return m_rect.intersects(rect); }
 73 
 74     Rect clone() const;
 75     operator LayoutRect() const;
 76 
 77 private:
 78 #if ASSERT_ENABLED
 79     void invalidateTop() { m_hasValidTop = false; }
 80     void invalidateLeft() { m_hasValidLeft = false; }
 81     void invalidateWidth() { m_hasValidWidth = false; }
 82     void invalidateHeight() { m_hasValidHeight = false; }
 83     void invalidatePosition();
 84 
 85     bool hasValidPosition() const { return m_hasValidTop &amp;&amp; m_hasValidLeft; }
 86     bool hasValidSize() const { return m_hasValidWidth &amp;&amp; m_hasValidHeight; }
 87     bool hasValidGeometry() const { return hasValidPosition() &amp;&amp; hasValidSize(); }
 88 
 89     void setHasValidPosition();
 90     void setHasValidSize();
 91 
 92     bool m_hasValidTop { false };
 93     bool m_hasValidLeft { false };
 94     bool m_hasValidWidth { false };
 95     bool m_hasValidHeight { false };
 96 #endif // ASSERT_ENABLED
 97     LayoutRect m_rect;
 98 };
 99 
100 inline Rect::Rect(LayoutUnit top, LayoutUnit left, LayoutUnit width, LayoutUnit height)
101     : m_rect(left, top, width, height)
102 {
103 #if ASSERT_ENABLED
104     m_hasValidTop = true;
105     m_hasValidLeft = true;
106     m_hasValidWidth = true;
107     m_hasValidHeight = true;
108 #endif
109 }
110 
111 inline Rect::Rect(LayoutPoint topLeft, LayoutUnit width, LayoutUnit height)
112     : Rect(topLeft.y(), topLeft.x(), width, height)
113 {
114 }
115 
116 #if ASSERT_ENABLED
117 inline void Rect::invalidatePosition()
118 {
119     invalidateTop();
120     invalidateLeft();
121 }
122 
123 inline void Rect::setHasValidPosition()
124 {
125     m_hasValidTop = true;
126     m_hasValidLeft = true;
127 }
128 
129 inline void Rect::setHasValidSize()
130 {
131     m_hasValidWidth = true;
132     m_hasValidHeight = true;
133 }
134 #endif
135 
136 inline LayoutUnit Rect::top() const
137 {
138     ASSERT(m_hasValidTop);
139     return m_rect.y();
140 }
141 
142 inline LayoutUnit Rect::left() const
143 {
144     ASSERT(m_hasValidLeft);
145     return m_rect.x();
146 }
147 
148 inline LayoutUnit Rect::bottom() const
149 {
150     ASSERT(m_hasValidTop &amp;&amp; m_hasValidHeight);
151     return m_rect.maxY();
152 }
153 
154 inline LayoutUnit Rect::right() const
155 {
156     ASSERT(m_hasValidLeft &amp;&amp; m_hasValidWidth);
157     return m_rect.maxX();
158 }
159 
160 inline LayoutPoint Rect::topLeft() const
161 {
162     ASSERT(hasValidPosition());
163     return m_rect.minXMinYCorner();
164 }
165 
166 inline LayoutPoint Rect::bottomRight() const
167 {
168     ASSERT(hasValidGeometry());
169     return m_rect.maxXMaxYCorner();
170 }
171 
172 inline LayoutSize Rect::size() const
173 {
174     ASSERT(hasValidSize());
175     return m_rect.size();
176 }
177 
178 inline LayoutUnit Rect::width() const
179 {
180     ASSERT(m_hasValidWidth);
181     return m_rect.width();
182 }
183 
184 inline LayoutUnit Rect::height() const
185 {
186     ASSERT(m_hasValidHeight);
187     return m_rect.height();
188 }
189 
190 inline void Rect::setTopLeft(const LayoutPoint&amp; topLeft)
191 {
192 #if ASSERT_ENABLED
193     setHasValidPosition();
194 #endif
195     m_rect.setLocation(topLeft);
196 }
197 
198 inline void Rect::setTop(LayoutUnit top)
199 {
200 #if ASSERT_ENABLED
201     m_hasValidTop = true;
202 #endif
203     m_rect.setY(top);
204 }
205 
206 inline void Rect::setLeft(LayoutUnit left)
207 {
208 #if ASSERT_ENABLED
209     m_hasValidLeft = true;
210 #endif
211     m_rect.setX(left);
212 }
213 
214 inline void Rect::setWidth(LayoutUnit width)
215 {
216 #if ASSERT_ENABLED
217     m_hasValidWidth = true;
218 #endif
219     m_rect.setWidth(width);
220 }
221 
222 inline void Rect::setHeight(LayoutUnit height)
223 {
224 #if ASSERT_ENABLED
225     m_hasValidHeight = true;
226 #endif
227     m_rect.setHeight(height);
228 }
229 
230 inline void Rect::setSize(const LayoutSize&amp; size)
231 {
232 #if ASSERT_ENABLED
233     setHasValidSize();
234 #endif
235     m_rect.setSize(size);
236 }
237 
238 inline void Rect::shiftLeftTo(LayoutUnit left)
239 {
240     ASSERT(m_hasValidLeft);
241     m_rect.shiftXEdgeTo(left);
242 }
243 
244 inline void Rect::shiftRightTo(LayoutUnit right)
245 {
246     ASSERT(m_hasValidLeft &amp;&amp; m_hasValidWidth);
247     m_rect.shiftMaxXEdgeTo(right);
248 }
249 
250 inline void Rect::shiftTopTo(LayoutUnit top)
251 {
252     ASSERT(m_hasValidTop);
253     m_rect.shiftYEdgeTo(top);
254 }
255 
256 inline void Rect::shiftBottomTo(LayoutUnit bottom)
257 {
258     ASSERT(m_hasValidTop &amp;&amp; m_hasValidHeight);
259     m_rect.shiftMaxYEdgeTo(bottom);
260 }
261 
262 inline void Rect::moveHorizontally(LayoutUnit offset)
263 {
264     ASSERT(m_hasValidLeft);
265     m_rect.move(LayoutSize { offset, 0 });
266 }
267 
268 inline void Rect::moveVertically(LayoutUnit offset)
269 {
270     ASSERT(m_hasValidTop);
271     m_rect.move(LayoutSize { 0, offset });
272 }
273 
274 inline void Rect::expand(Optional&lt;LayoutUnit&gt; width, Optional&lt;LayoutUnit&gt; height)
275 {
276     ASSERT(!width || m_hasValidWidth);
277     ASSERT(!height || m_hasValidHeight);
278     m_rect.expand(width.valueOr(0), height.valueOr(0));
279 }
280 
281 inline Rect Rect::clone() const
282 {
283     Rect rect;
284 #if ASSERT_ENABLED
285     rect.m_hasValidTop = m_hasValidTop;
286     rect.m_hasValidLeft = m_hasValidLeft;
287     rect.m_hasValidWidth = m_hasValidWidth;
288     rect.m_hasValidHeight  = m_hasValidHeight;
289 #endif
290     rect.m_rect = m_rect;
291     return rect;
292 }
293 
294 inline Rect::operator LayoutRect() const
295 {
296     ASSERT(hasValidGeometry());
297     return m_rect;
298 }
299 
300 }
301 }
302 #endif
    </pre>
  </body>
</html>
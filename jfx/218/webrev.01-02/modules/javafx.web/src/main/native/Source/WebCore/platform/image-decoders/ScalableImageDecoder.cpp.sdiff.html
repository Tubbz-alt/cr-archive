<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/image-decoders/ScalableImageDecoder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../graphics/wayland/PlatformDisplayWayland.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="jpeg/JPEGImageDecoder.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/image-decoders/ScalableImageDecoder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
173     if (!frame.isComplete())
174         return true;
175     return frame.hasAlpha();
176 }
177 
178 unsigned ScalableImageDecoder::frameBytesAtIndex(size_t index, SubsamplingLevel) const
179 {
180     LockHolder lockHolder(m_mutex);
181     if (m_frameBufferCache.size() &lt;= index)
182         return 0;
183     // FIXME: Use the dimension of the requested frame.
184     return (m_size.area() * sizeof(uint32_t)).unsafeGet();
185 }
186 
187 Seconds ScalableImageDecoder::frameDurationAtIndex(size_t index) const
188 {
189     LockHolder lockHolder(m_mutex);
190     if (index &gt;= m_frameBufferCache.size())
191         return 0_s;
192 
<span class="line-removed">193     // Returning 0_s in case of an incomplete frame can break display of animated image formats.</span>
<span class="line-removed">194     // We pick up the decoded duration if it&#39;s available, otherwise the default 0_s value is</span>
<span class="line-removed">195     // adjusted below.</span>
<span class="line-removed">196     Seconds duration = 0_s;</span>
197     auto&amp; frame = m_frameBufferCache[index];
<span class="line-modified">198     if (frame.isComplete())</span>
<span class="line-modified">199         duration = frame.duration();</span>
200 
201     // Many annoying ads specify a 0 duration to make an image flash as quickly as possible.
202     // We follow Firefox&#39;s behavior and use a duration of 100 ms for any frames that specify
203     // a duration of &lt;= 10 ms. See &lt;rdar://problem/7689300&gt; and &lt;http://webkit.org/b/36082&gt;
204     // for more information.

205     if (duration &lt; 11_ms)
206         return 100_ms;
207     return duration;
208 }
209 
210 NativeImagePtr ScalableImageDecoder::createFrameImageAtIndex(size_t index, SubsamplingLevel, const DecodingOptions&amp;)
211 {
212     LockHolder lockHolder(m_mutex);
213     // Zero-height images can cause problems for some ports. If we have an empty image dimension, just bail.
214     if (size().isEmpty())
215         return nullptr;
216 
217     auto* buffer = frameBufferAtIndex(index);
218     if (!buffer || buffer-&gt;isInvalid() || !buffer-&gt;hasBackingStore())
219         return nullptr;
220 
221     // Return the buffer contents as a native image. For some ports, the data
222     // is already in a native container, and this just increments its refcount.
223     return buffer-&gt;backingStore()-&gt;image();
224 }
</pre>
</td>
<td>
<hr />
<pre>
173     if (!frame.isComplete())
174         return true;
175     return frame.hasAlpha();
176 }
177 
178 unsigned ScalableImageDecoder::frameBytesAtIndex(size_t index, SubsamplingLevel) const
179 {
180     LockHolder lockHolder(m_mutex);
181     if (m_frameBufferCache.size() &lt;= index)
182         return 0;
183     // FIXME: Use the dimension of the requested frame.
184     return (m_size.area() * sizeof(uint32_t)).unsafeGet();
185 }
186 
187 Seconds ScalableImageDecoder::frameDurationAtIndex(size_t index) const
188 {
189     LockHolder lockHolder(m_mutex);
190     if (index &gt;= m_frameBufferCache.size())
191         return 0_s;
192 




193     auto&amp; frame = m_frameBufferCache[index];
<span class="line-modified">194     if (!frame.isComplete())</span>
<span class="line-modified">195         return 0_s;</span>
196 
197     // Many annoying ads specify a 0 duration to make an image flash as quickly as possible.
198     // We follow Firefox&#39;s behavior and use a duration of 100 ms for any frames that specify
199     // a duration of &lt;= 10 ms. See &lt;rdar://problem/7689300&gt; and &lt;http://webkit.org/b/36082&gt;
200     // for more information.
<span class="line-added">201     Seconds duration = frame.duration();</span>
202     if (duration &lt; 11_ms)
203         return 100_ms;
204     return duration;
205 }
206 
207 NativeImagePtr ScalableImageDecoder::createFrameImageAtIndex(size_t index, SubsamplingLevel, const DecodingOptions&amp;)
208 {
209     LockHolder lockHolder(m_mutex);
210     // Zero-height images can cause problems for some ports. If we have an empty image dimension, just bail.
211     if (size().isEmpty())
212         return nullptr;
213 
214     auto* buffer = frameBufferAtIndex(index);
215     if (!buffer || buffer-&gt;isInvalid() || !buffer-&gt;hasBackingStore())
216         return nullptr;
217 
218     // Return the buffer contents as a native image. For some ports, the data
219     // is already in a native container, and this just increments its refcount.
220     return buffer-&gt;backingStore()-&gt;image();
221 }
</pre>
</td>
</tr>
</table>
<center><a href="../graphics/wayland/PlatformDisplayWayland.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="jpeg/JPEGImageDecoder.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/debugger/Debugger.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
  4  *  Copyright (C) 2008, 2009, 2013, 2014 Apple Inc. All rights reserved.
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Lesser General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Lesser General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;Breakpoint.h&quot;
 25 #include &quot;CallData.h&quot;
 26 #include &quot;DebuggerCallFrame.h&quot;
 27 #include &quot;DebuggerParseData.h&quot;
 28 #include &quot;DebuggerPrimitives.h&quot;
 29 #include &quot;JSCJSValue.h&quot;
 30 #include &lt;wtf/HashMap.h&gt;
 31 #include &lt;wtf/HashSet.h&gt;
 32 #include &lt;wtf/RefPtr.h&gt;
 33 #include &lt;wtf/text/TextPosition.h&gt;
 34 
 35 namespace JSC {
 36 
<a name="1" id="anc1"></a><span class="line-added"> 37 class CallFrame;</span>
 38 class CodeBlock;
 39 class Exception;
<a name="2" id="anc2"></a>
 40 class JSGlobalObject;
 41 class SourceProvider;
 42 class VM;
 43 
<a name="3" id="anc3"></a>

 44 class JS_EXPORT_PRIVATE Debugger {
 45     WTF_MAKE_FAST_ALLOCATED;
 46 public:
 47     Debugger(VM&amp;);
 48     virtual ~Debugger();
 49 
 50     VM&amp; vm() { return m_vm; }
 51 
 52     JSC::DebuggerCallFrame&amp; currentDebuggerCallFrame();
 53     bool hasHandlerForExceptionCallback() const
 54     {
 55         ASSERT(m_reasonForPause == PausedForException);
 56         return m_hasHandlerForExceptionCallback;
 57     }
 58     JSValue currentException()
 59     {
 60         ASSERT(m_reasonForPause == PausedForException);
 61         return m_currentException;
 62     }
 63 
 64     bool needsExceptionCallbacks() const { return m_breakpointsActivated &amp;&amp; m_pauseOnExceptionsState != DontPauseOnExceptions; }
 65     bool isInteractivelyDebugging() const { return m_breakpointsActivated; }
 66 
 67     enum ReasonForDetach {
 68         TerminatingDebuggingSession,
 69         GlobalObjectIsDestructing
 70     };
 71     void attach(JSGlobalObject*);
 72     void detach(JSGlobalObject*, ReasonForDetach);
 73     bool isAttached(JSGlobalObject*);
 74 
 75     void resolveBreakpoint(Breakpoint&amp;, SourceProvider*);
 76     BreakpointID setBreakpoint(Breakpoint&amp;, bool&amp; existing);
 77     void removeBreakpoint(BreakpointID);
 78     void clearBreakpoints();
 79 
 80     void activateBreakpoints() { setBreakpointsActivated(true); }
 81     void deactivateBreakpoints() { setBreakpointsActivated(false); }
 82     bool breakpointsActive() const { return m_breakpointsActivated; }
 83 
 84     enum PauseOnExceptionsState {
 85         DontPauseOnExceptions,
 86         PauseOnAllExceptions,
 87         PauseOnUncaughtExceptions
 88     };
 89     PauseOnExceptionsState pauseOnExceptionsState() const { return m_pauseOnExceptionsState; }
 90     void setPauseOnExceptionsState(PauseOnExceptionsState);
 91 
<a name="4" id="anc4"></a><span class="line-added"> 92     void setPauseOnDebuggerStatements(bool enabled) { m_pauseOnDebuggerStatements = enabled; }</span>
<span class="line-added"> 93 </span>
 94     enum ReasonForPause {
 95         NotPaused,
 96         PausedForException,
 97         PausedAtStatement,
 98         PausedAtExpression,
 99         PausedBeforeReturn,
100         PausedAtEndOfProgram,
101         PausedForBreakpoint,
102         PausedForDebuggerStatement,
<a name="5" id="anc5"></a><span class="line-added">103         PausedAfterBlackboxedScript,</span>
104     };
105     ReasonForPause reasonForPause() const { return m_reasonForPause; }
106     BreakpointID pausingBreakpointID() const { return m_pausingBreakpointID; }
107 
108     void setPauseOnNextStatement(bool);
109     void breakProgram();
110     void continueProgram();
111     void stepIntoStatement();
112     void stepOverStatement();
113     void stepOutOfFunction();
114 
<a name="6" id="anc6"></a><span class="line-modified">115     enum class BlackboxType { Deferred, Ignored };</span>
<span class="line-modified">116     void setBlackboxType(SourceID, Optional&lt;BlackboxType&gt;);</span>
<span class="line-modified">117     void clearBlackbox();</span>
118 
119     bool isPaused() const { return m_isPaused; }
120     bool isStepping() const { return m_steppingMode == SteppingModeEnabled; }
121 
122     bool suppressAllPauses() const { return m_suppressAllPauses; }
123     void setSuppressAllPauses(bool suppress) { m_suppressAllPauses = suppress; }
124 
<a name="7" id="anc7"></a><span class="line-modified">125     virtual void sourceParsed(JSGlobalObject*, SourceProvider*, int errorLineNumber, const WTF::String&amp; errorMessage) = 0;</span>
126     virtual void willRunMicrotask() { }
127     virtual void didRunMicrotask() { }
128 
<a name="8" id="anc8"></a><span class="line-modified">129     void exception(JSGlobalObject*, CallFrame*, JSValue exceptionValue, bool hasCatchHandler);</span>
130     void atStatement(CallFrame*);
131     void atExpression(CallFrame*);
132     void callEvent(CallFrame*);
133     void returnEvent(CallFrame*);
134     void unwindEvent(CallFrame*);
135     void willExecuteProgram(CallFrame*);
136     void didExecuteProgram(CallFrame*);
<a name="9" id="anc9"></a><span class="line-modified">137     void didReachDebuggerStatement(CallFrame*);</span>
138 
139     virtual void recompileAllJSFunctions();
140 
141     void registerCodeBlock(CodeBlock*);
142 
143     class ProfilingClient {
144     public:
145         virtual ~ProfilingClient();
146         virtual bool isAlreadyProfiling() const = 0;
147         virtual Seconds willEvaluateScript() = 0;
148         virtual void didEvaluateScript(Seconds startTime, ProfilingReason) = 0;
149     };
150 
151     void setProfilingClient(ProfilingClient*);
152     bool hasProfilingClient() const { return m_profilingClient != nullptr; }
153     bool isAlreadyProfiling() const { return m_profilingClient &amp;&amp; m_profilingClient-&gt;isAlreadyProfiling(); }
154     Seconds willEvaluateScript();
155     void didEvaluateScript(Seconds startTime, ProfilingReason);
156 
157 protected:
158     virtual void handleBreakpointHit(JSGlobalObject*, const Breakpoint&amp;) { }
<a name="10" id="anc10"></a><span class="line-modified">159     virtual void handleExceptionInBreakpointCondition(JSGlobalObject*, Exception*) const { }</span>
160     virtual void handlePause(JSGlobalObject*, ReasonForPause) { }
161     virtual void notifyDoneProcessingDebuggerEvents() { }
162 
163 private:
164     typedef HashMap&lt;BreakpointID, Breakpoint*&gt; BreakpointIDToBreakpointMap;
165 
166     typedef HashMap&lt;unsigned, RefPtr&lt;BreakpointsList&gt;, WTF::IntHash&lt;int&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;int&gt;&gt; LineToBreakpointsMap;
167     typedef HashMap&lt;SourceID, LineToBreakpointsMap, WTF::IntHash&lt;SourceID&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;SourceID&gt;&gt; SourceIDToBreakpointsMap;
168 
169     class ClearCodeBlockDebuggerRequestsFunctor;
170     class ClearDebuggerRequestsFunctor;
171     class SetSteppingModeFunctor;
172     class ToggleBreakpointFunctor;
173 
174     class PauseReasonDeclaration {
175     public:
176         PauseReasonDeclaration(Debugger&amp; debugger, ReasonForPause reason)
177             : m_debugger(debugger)
178         {
179             m_debugger.m_reasonForPause = reason;
180         }
181 
182         ~PauseReasonDeclaration()
183         {
184             m_debugger.m_reasonForPause = NotPaused;
185         }
186     private:
187         Debugger&amp; m_debugger;
188     };
189 
190     bool hasBreakpoint(SourceID, const TextPosition&amp;, Breakpoint* hitBreakpoint);
191 
192     DebuggerParseData&amp; debuggerParseData(SourceID, SourceProvider*);
193 
194     void updateNeedForOpDebugCallbacks();
195 
196     // These update functions are only needed because our current breakpoints are
197     // key&#39;ed off the source position instead of the bytecode PC. This ensures
198     // that we don&#39;t break on the same line more than once. Once we switch to a
199     // bytecode PC key&#39;ed breakpoint, we will not need these anymore and should
200     // be able to remove them.
201     enum CallFrameUpdateAction { AttemptPause, NoPause };
<a name="11" id="anc11"></a><span class="line-modified">202     void updateCallFrame(JSC::JSGlobalObject*, JSC::CallFrame*, CallFrameUpdateAction);</span>
203     void updateCallFrameInternal(JSC::CallFrame*);
<a name="12" id="anc12"></a><span class="line-modified">204     void pauseIfNeeded(JSC::JSGlobalObject*);</span>
205     void clearNextPauseState();
206 
207     enum SteppingMode {
208         SteppingModeDisabled,
209         SteppingModeEnabled
210     };
211     void setSteppingMode(SteppingMode);
212 
213     enum BreakpointState {
214         BreakpointDisabled,
215         BreakpointEnabled
216     };
217     void setBreakpointsActivated(bool);
218     void toggleBreakpoint(CodeBlock*, Breakpoint&amp;, BreakpointState);
219     void applyBreakpoints(CodeBlock*);
220     void toggleBreakpoint(Breakpoint&amp;, BreakpointState);
221 
222     void clearDebuggerRequests(JSGlobalObject*);
223     void clearParsedData();
224 
225     VM&amp; m_vm;
226     HashSet&lt;JSGlobalObject*&gt; m_globalObjects;
227     HashMap&lt;SourceID, DebuggerParseData, WTF::IntHash&lt;SourceID&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;SourceID&gt;&gt; m_parseDataMap;
<a name="13" id="anc13"></a><span class="line-modified">228     HashMap&lt;SourceID, BlackboxType, WTF::IntHash&lt;SourceID&gt;, WTF::UnsignedWithZeroKeyHashTraits&lt;SourceID&gt;&gt; m_blackboxedScripts;</span>
229 
230     PauseOnExceptionsState m_pauseOnExceptionsState;
<a name="14" id="anc14"></a><span class="line-added">231     bool m_pauseOnDebuggerStatements : 1;</span>
232     bool m_pauseAtNextOpportunity : 1;
233     bool m_pauseOnStepOut : 1;
234     bool m_pastFirstExpressionInStatement : 1;
235     bool m_isPaused : 1;
236     bool m_breakpointsActivated : 1;
237     bool m_hasHandlerForExceptionCallback : 1;
238     bool m_suppressAllPauses : 1;
239     unsigned m_steppingMode : 1; // SteppingMode
240 
241     ReasonForPause m_reasonForPause;
242     JSValue m_currentException;
243     CallFrame* m_pauseOnCallFrame { nullptr };
244     CallFrame* m_currentCallFrame { nullptr };
245     unsigned m_lastExecutedLine;
246     SourceID m_lastExecutedSourceID;
<a name="15" id="anc15"></a><span class="line-added">247     bool m_afterBlackboxedScript { false };</span>
248 
249     BreakpointID m_topBreakpointID;
250     BreakpointID m_pausingBreakpointID;
251     BreakpointIDToBreakpointMap m_breakpointIDToBreakpoint;
252     SourceIDToBreakpointsMap m_sourceIDToBreakpoints;
253 
254     RefPtr&lt;JSC::DebuggerCallFrame&gt; m_currentDebuggerCallFrame;
255 
256     ProfilingClient* m_profilingClient { nullptr };
257 
258     friend class DebuggerPausedScope;
259     friend class TemporaryPausedState;
260     friend class LLIntOffsetsExtractor;
261 };
262 
263 } // namespace JSC
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
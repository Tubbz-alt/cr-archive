<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/loader/NavigationScheduler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
  3  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
  4  * Copyright (C) 2008, 2009 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
  5  * Copyright (C) 2009 Adam Barth. All rights reserved.
  6  *
  7  * Redistribution and use in source and binary forms, with or without
  8  * modification, are permitted provided that the following conditions
  9  * are met:
 10  *
 11  * 1.  Redistributions of source code must retain the above copyright
 12  *     notice, this list of conditions and the following disclaimer.
 13  * 2.  Redistributions in binary form must reproduce the above copyright
 14  *     notice, this list of conditions and the following disclaimer in the
 15  *     documentation and/or other materials provided with the distribution.
 16  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 17  *     its contributors may be used to endorse or promote products derived
 18  *     from this software without specific prior written permission.
 19  *
 20  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 21  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 22  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 23  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 24  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 25  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 26  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 27  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 29  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;NavigationScheduler.h&quot;
 34 
 35 #include &quot;BackForwardController.h&quot;
 36 #include &quot;CommonVM.h&quot;
 37 #include &quot;DOMWindow.h&quot;
 38 #include &quot;DocumentLoader.h&quot;
 39 #include &quot;Event.h&quot;
 40 #include &quot;FormState.h&quot;
 41 #include &quot;FormSubmission.h&quot;
 42 #include &quot;Frame.h&quot;
 43 #include &quot;FrameLoadRequest.h&quot;
 44 #include &quot;FrameLoader.h&quot;
 45 #include &quot;FrameLoaderStateMachine.h&quot;
 46 #include &quot;HTMLFormElement.h&quot;
 47 #include &quot;HTMLFrameOwnerElement.h&quot;
 48 #include &quot;HistoryItem.h&quot;
 49 #include &quot;InspectorInstrumentation.h&quot;
 50 #include &quot;Logging.h&quot;
 51 #include &quot;NavigationDisabler.h&quot;
 52 #include &quot;Page.h&quot;
 53 #include &quot;PolicyChecker.h&quot;
 54 #include &quot;ScriptController.h&quot;
 55 #include &quot;UserGestureIndicator.h&quot;
 56 #include &lt;wtf/Ref.h&gt;
 57 
 58 namespace WebCore {
 59 
 60 unsigned NavigationDisabler::s_globalNavigationDisableCount = 0;
 61 
 62 class ScheduledNavigation {
 63     WTF_MAKE_NONCOPYABLE(ScheduledNavigation); WTF_MAKE_FAST_ALLOCATED;
 64 public:
 65     ScheduledNavigation(double delay, LockHistory lockHistory, LockBackForwardList lockBackForwardList, bool wasDuringLoad, bool isLocationChange)
 66         : m_delay(delay)
 67         , m_lockHistory(lockHistory)
 68         , m_lockBackForwardList(lockBackForwardList)
 69         , m_wasDuringLoad(wasDuringLoad)
 70         , m_isLocationChange(isLocationChange)
 71         , m_userGestureToForward(UserGestureIndicator::currentUserGesture())
 72     {
 73     }
 74     ScheduledNavigation(double delay, LockHistory lockHistory, LockBackForwardList lockBackForwardList, bool wasDuringLoad, bool isLocationChange, ShouldOpenExternalURLsPolicy externalURLPolicy)
 75         : m_delay(delay)
 76         , m_lockHistory(lockHistory)
 77         , m_lockBackForwardList(lockBackForwardList)
 78         , m_wasDuringLoad(wasDuringLoad)
 79         , m_isLocationChange(isLocationChange)
 80         , m_userGestureToForward(UserGestureIndicator::currentUserGesture())
 81         , m_shouldOpenExternalURLsPolicy(externalURLPolicy)
 82     {
 83         if (auto* frame = lexicalFrameFromCommonVM()) {
 84             if (frame-&gt;isMainFrame())
 85                 m_initiatedByMainFrame = InitiatedByMainFrame::Yes;
 86         }
 87     }
 88     virtual ~ScheduledNavigation() = default;
 89 
 90     virtual void fire(Frame&amp;) = 0;
 91 
 92     virtual bool shouldStartTimer(Frame&amp;) { return true; }
 93     virtual void didStartTimer(Frame&amp;, Timer&amp;) { }
 94     virtual void didStopTimer(Frame&amp;, NewLoadInProgress) { }
 95 
 96     double delay() const { return m_delay; }
 97     LockHistory lockHistory() const { return m_lockHistory; }
 98     LockBackForwardList lockBackForwardList() const { return m_lockBackForwardList; }
 99     bool wasDuringLoad() const { return m_wasDuringLoad; }
100     bool isLocationChange() const { return m_isLocationChange; }
101     UserGestureToken* userGestureToForward() const { return m_userGestureToForward.get(); }
102 
103 protected:
104     void clearUserGesture() { m_userGestureToForward = nullptr; }
105     ShouldOpenExternalURLsPolicy shouldOpenExternalURLs() const { return m_shouldOpenExternalURLsPolicy; }
106     InitiatedByMainFrame initiatedByMainFrame() const { return m_initiatedByMainFrame; };
107 
108 private:
109     double m_delay;
110     LockHistory m_lockHistory;
111     LockBackForwardList m_lockBackForwardList;
112     bool m_wasDuringLoad;
113     bool m_isLocationChange;
114     RefPtr&lt;UserGestureToken&gt; m_userGestureToForward;
115     ShouldOpenExternalURLsPolicy m_shouldOpenExternalURLsPolicy { ShouldOpenExternalURLsPolicy::ShouldNotAllow };
116     InitiatedByMainFrame m_initiatedByMainFrame { InitiatedByMainFrame::Unknown };
117 };
118 
119 class ScheduledURLNavigation : public ScheduledNavigation {
120 protected:
121     ScheduledURLNavigation(Document&amp; initiatingDocument, double delay, SecurityOrigin* securityOrigin, const URL&amp; url, const String&amp; referrer, LockHistory lockHistory, LockBackForwardList lockBackForwardList, bool duringLoad, bool isLocationChange)
122         : ScheduledNavigation(delay, lockHistory, lockBackForwardList, duringLoad, isLocationChange, initiatingDocument.shouldOpenExternalURLsPolicyToPropagate())
123         , m_initiatingDocument { makeRef(initiatingDocument) }
124         , m_securityOrigin{ makeRefPtr(securityOrigin) }
125         , m_url { url }
126         , m_referrer { referrer }
127     {
128     }
129 
130     void didStartTimer(Frame&amp; frame, Timer&amp; timer) override
131     {
132         if (m_haveToldClient)
133             return;
134         m_haveToldClient = true;
135 
136         UserGestureIndicator gestureIndicator(userGestureToForward());
137         frame.loader().clientRedirected(m_url, delay(), WallTime::now() + timer.nextFireInterval(), lockBackForwardList());
138     }
139 
140     void didStopTimer(Frame&amp; frame, NewLoadInProgress newLoadInProgress) override
141     {
142         if (!m_haveToldClient)
143             return;
144 
145         // Do not set a UserGestureIndicator because
146         // clientRedirectCancelledOrFinished() is also called from many places
147         // inside FrameLoader, where the gesture state is not set and is in
148         // fact unavailable. We need to be consistent with them, otherwise the
149         // gesture state will sometimes be set and sometimes not within
150         // dispatchDidCancelClientRedirect().
151         frame.loader().clientRedirectCancelledOrFinished(newLoadInProgress);
152     }
153 
154     Document&amp; initiatingDocument() { return m_initiatingDocument.get(); }
155     SecurityOrigin* securityOrigin() const { return m_securityOrigin.get(); }
156     const URL&amp; url() const { return m_url; }
157     String referrer() const { return m_referrer; }
158 
159 private:
160     Ref&lt;Document&gt; m_initiatingDocument;
161     RefPtr&lt;SecurityOrigin&gt; m_securityOrigin;
162     URL m_url;
163     String m_referrer;
164     bool m_haveToldClient { false };
165 };
166 
167 class ScheduledRedirect : public ScheduledURLNavigation {
168 public:
169     ScheduledRedirect(Document&amp; initiatingDocument, double delay, SecurityOrigin* securityOrigin, const URL&amp; url, LockHistory lockHistory, LockBackForwardList lockBackForwardList)
170         : ScheduledURLNavigation(initiatingDocument, delay, securityOrigin, url, String(), lockHistory, lockBackForwardList, false, false)
171     {
172         clearUserGesture();
173     }
174 
175     bool shouldStartTimer(Frame&amp; frame) override
176     {
177         return frame.loader().allAncestorsAreComplete();
178     }
179 
180     void fire(Frame&amp; frame) override
181     {
182         UserGestureIndicator gestureIndicator { userGestureToForward() };
183 
184         bool refresh = equalIgnoringFragmentIdentifier(frame.document()-&gt;url(), url());
185         ResourceRequest resourceRequest { url(), referrer(), refresh ? ResourceRequestCachePolicy::ReloadIgnoringCacheData : ResourceRequestCachePolicy::UseProtocolCachePolicy };
186         if (initiatedByMainFrame() == InitiatedByMainFrame::Yes)
187             resourceRequest.setRequester(ResourceRequest::Requester::Main);
188         FrameLoadRequest frameLoadRequest { initiatingDocument(), *securityOrigin(), resourceRequest, &quot;_self&quot;, lockHistory(), lockBackForwardList(), MaybeSendReferrer, AllowNavigationToInvalidURL::No, NewFrameOpenerPolicy::Allow, shouldOpenExternalURLs(), initiatedByMainFrame() };
189 
190         frame.loader().changeLocation(WTFMove(frameLoadRequest));
191     }
192 };
193 
194 class ScheduledLocationChange : public ScheduledURLNavigation {
195 public:
196     ScheduledLocationChange(Document&amp; initiatingDocument, SecurityOrigin* securityOrigin, const URL&amp; url, const String&amp; referrer, LockHistory lockHistory, LockBackForwardList lockBackForwardList, bool duringLoad, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
197         : ScheduledURLNavigation(initiatingDocument, 0.0, securityOrigin, url, referrer, lockHistory, lockBackForwardList, duringLoad, true)
198         , m_completionHandler(WTFMove(completionHandler))
199     {
200     }
201 
202     ~ScheduledLocationChange()
203     {
204         if (m_completionHandler)
205             m_completionHandler();
206     }
207 
208     void fire(Frame&amp; frame) override
209     {
210         UserGestureIndicator gestureIndicator { userGestureToForward() };
211 
212         ResourceRequest resourceRequest { url(), referrer(), ResourceRequestCachePolicy::UseProtocolCachePolicy };
213         FrameLoadRequest frameLoadRequest { initiatingDocument(), *securityOrigin(), resourceRequest, &quot;_self&quot;, lockHistory(), lockBackForwardList(), MaybeSendReferrer, AllowNavigationToInvalidURL::No, NewFrameOpenerPolicy::Allow, shouldOpenExternalURLs(), initiatedByMainFrame() };
214 
215         auto completionHandler = WTFMove(m_completionHandler);
216         frame.loader().changeLocation(WTFMove(frameLoadRequest));
217         completionHandler();
218     }
219 
220 private:
221     CompletionHandler&lt;void()&gt; m_completionHandler;
222 };
223 
224 class ScheduledRefresh : public ScheduledURLNavigation {
225 public:
226     ScheduledRefresh(Document&amp; initiatingDocument, SecurityOrigin* securityOrigin, const URL&amp; url, const String&amp; referrer)
227         : ScheduledURLNavigation(initiatingDocument, 0.0, securityOrigin, url, referrer, LockHistory::Yes, LockBackForwardList::Yes, false, true)
228     {
229     }
230 
231     void fire(Frame&amp; frame) override
232     {
233         UserGestureIndicator gestureIndicator { userGestureToForward() };
234 
235         ResourceRequest resourceRequest { url(), referrer(), ResourceRequestCachePolicy::ReloadIgnoringCacheData };
236         FrameLoadRequest frameLoadRequest { initiatingDocument(), *securityOrigin(), resourceRequest, &quot;_self&quot;, lockHistory(), lockBackForwardList(), MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, shouldOpenExternalURLs(), initiatedByMainFrame() };
237 
238         frame.loader().changeLocation(WTFMove(frameLoadRequest));
239     }
240 };
241 
242 class ScheduledHistoryNavigation : public ScheduledNavigation {
243 public:
244     explicit ScheduledHistoryNavigation(int historySteps)
245         : ScheduledNavigation(0, LockHistory::No, LockBackForwardList::No, false, true)
246         , m_historySteps(historySteps)
247     {
248     }
249 
250     void fire(Frame&amp; frame) override
251     {
252         UserGestureIndicator gestureIndicator(userGestureToForward());
253 
254         if (!m_historySteps) {
255             // Special case for go(0) from a frame -&gt; reload only the frame
256             // To follow Firefox and IE&#39;s behavior, history reload can only navigate the self frame.
257             frame.loader().urlSelected(frame.document()-&gt;url(), &quot;_self&quot;, 0, lockHistory(), lockBackForwardList(), MaybeSendReferrer, shouldOpenExternalURLs());
258             return;
259         }
260 
261         // go(i!=0) from a frame navigates into the history of the frame only,
262         // in both IE and NS (but not in Mozilla). We can&#39;t easily do that.
263         frame.page()-&gt;backForward().goBackOrForward(m_historySteps);
264     }
265 
266 private:
267     int m_historySteps;
268 };
269 
270 class ScheduledFormSubmission : public ScheduledNavigation {
271 public:
272     ScheduledFormSubmission(Ref&lt;FormSubmission&gt;&amp;&amp; submission, LockBackForwardList lockBackForwardList, bool duringLoad)
273         : ScheduledNavigation(0, submission-&gt;lockHistory(), lockBackForwardList, duringLoad, true, submission-&gt;state().sourceDocument().shouldOpenExternalURLsPolicyToPropagate())
274         , m_submission(WTFMove(submission))
275     {
276     }
277 
278     void fire(Frame&amp; frame) override
279     {
<a name="1" id="anc1"></a><span class="line-added">280         if (m_submission-&gt;wasCancelled())</span>
<span class="line-added">281             return;</span>
<span class="line-added">282 </span>
283         UserGestureIndicator gestureIndicator(userGestureToForward());
284 
285         // The submitForm function will find a target frame before using the redirection timer.
286         // Now that the timer has fired, we need to repeat the security check which normally is done when
287         // selecting a target, in case conditions have changed. Other code paths avoid this by targeting
288         // without leaving a time window. If we fail the check just silently drop the form submission.
289         auto&amp; requestingDocument = m_submission-&gt;state().sourceDocument();
290         if (!requestingDocument.canNavigate(&amp;frame))
291             return;
292         FrameLoadRequest frameLoadRequest { requestingDocument, requestingDocument.securityOrigin(), { }, { }, lockHistory(), lockBackForwardList(), MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, shouldOpenExternalURLs(), initiatedByMainFrame() };
293         m_submission-&gt;populateFrameLoadRequest(frameLoadRequest);
294         frame.loader().loadFrameRequest(WTFMove(frameLoadRequest), m_submission-&gt;event(), m_submission-&gt;takeState());
295     }
296 
297     void didStartTimer(Frame&amp; frame, Timer&amp; timer) override
298     {
299         if (m_haveToldClient)
300             return;
301         m_haveToldClient = true;
302 
303         UserGestureIndicator gestureIndicator(userGestureToForward());
304         frame.loader().clientRedirected(m_submission-&gt;requestURL(), delay(), WallTime::now() + timer.nextFireInterval(), lockBackForwardList());
305     }
306 
307     void didStopTimer(Frame&amp; frame, NewLoadInProgress newLoadInProgress) override
308     {
309         if (!m_haveToldClient)
310             return;
311 
312         // Do not set a UserGestureIndicator because
313         // clientRedirectCancelledOrFinished() is also called from many places
314         // inside FrameLoader, where the gesture state is not set and is in
315         // fact unavailable. We need to be consistent with them, otherwise the
316         // gesture state will sometimes be set and sometimes not within
317         // dispatchDidCancelClientRedirect().
318         frame.loader().clientRedirectCancelledOrFinished(newLoadInProgress);
319     }
320 
321 private:
322     Ref&lt;FormSubmission&gt; m_submission;
323     bool m_haveToldClient { false };
324 };
325 
326 class ScheduledPageBlock final : public ScheduledNavigation {
327 public:
328     ScheduledPageBlock(Document&amp; originDocument)
329         : ScheduledNavigation(0, LockHistory::Yes, LockBackForwardList::Yes, false, false)
330         , m_originDocument(originDocument)
331     {
332     }
333 
334     void fire(Frame&amp; frame) override
335     {
336         UserGestureIndicator gestureIndicator { userGestureToForward() };
337 
338         ResourceResponse replacementResponse { m_originDocument.url(), &quot;text/plain&quot;_s, 0, &quot;UTF-8&quot;_s };
339         SubstituteData replacementData { SharedBuffer::create(), m_originDocument.url(), replacementResponse, SubstituteData::SessionHistoryVisibility::Hidden };
340 
341         ResourceRequest resourceRequest { m_originDocument.url(), emptyString(), ResourceRequestCachePolicy::ReloadIgnoringCacheData };
342         FrameLoadRequest frameLoadRequest { m_originDocument, m_originDocument.securityOrigin(), resourceRequest, { }, lockHistory(), lockBackForwardList(), MaybeSendReferrer, AllowNavigationToInvalidURL::Yes, NewFrameOpenerPolicy::Allow, shouldOpenExternalURLs(), initiatedByMainFrame() };
343         frameLoadRequest.setSubstituteData(replacementData);
344         frame.loader().load(WTFMove(frameLoadRequest));
345     }
346 
347 private:
348     Document&amp; m_originDocument;
349 };
350 
351 NavigationScheduler::NavigationScheduler(Frame&amp; frame)
352     : m_frame(frame)
353     , m_timer(*this, &amp;NavigationScheduler::timerFired)
354 {
355 }
356 
357 NavigationScheduler::~NavigationScheduler() = default;
358 
359 bool NavigationScheduler::redirectScheduledDuringLoad()
360 {
361     return m_redirect &amp;&amp; m_redirect-&gt;wasDuringLoad();
362 }
363 
364 bool NavigationScheduler::locationChangePending()
365 {
366     return m_redirect &amp;&amp; m_redirect-&gt;isLocationChange();
367 }
368 
369 void NavigationScheduler::clear()
370 {
371     if (m_timer.isActive())
372         InspectorInstrumentation::frameClearedScheduledNavigation(m_frame);
373     m_timer.stop();
374     m_redirect = nullptr;
375 }
376 
377 inline bool NavigationScheduler::shouldScheduleNavigation() const
378 {
379     return m_frame.page();
380 }
381 
382 inline bool NavigationScheduler::shouldScheduleNavigation(const URL&amp; url) const
383 {
384     if (!shouldScheduleNavigation())
385         return false;
386     if (WTF::protocolIsJavaScript(url))
387         return true;
388     return NavigationDisabler::isNavigationAllowed(m_frame);
389 }
390 
391 void NavigationScheduler::scheduleRedirect(Document&amp; initiatingDocument, double delay, const URL&amp; url)
392 {
393     if (!shouldScheduleNavigation(url))
394         return;
395     if (delay &lt; 0 || delay &gt; INT_MAX / 1000)
396         return;
397     if (url.isEmpty())
398         return;
399 
400     // We want a new back/forward list item if the refresh timeout is &gt; 1 second.
401     if (!m_redirect || delay &lt;= m_redirect-&gt;delay()) {
402         auto lockBackForwardList = delay &lt;= 1 ? LockBackForwardList::Yes : LockBackForwardList::No;
403         schedule(makeUnique&lt;ScheduledRedirect&gt;(initiatingDocument, delay, &amp;m_frame.document()-&gt;securityOrigin(), url, LockHistory::Yes, lockBackForwardList));
404     }
405 }
406 
407 LockBackForwardList NavigationScheduler::mustLockBackForwardList(Frame&amp; targetFrame)
408 {
409     // Non-user navigation before the page has finished firing onload should not create a new back/forward item.
410     // See https://webkit.org/b/42861 for the original motivation for this.
411     if (!UserGestureIndicator::processingUserGesture() &amp;&amp; targetFrame.loader().documentLoader() &amp;&amp; !targetFrame.loader().documentLoader()-&gt;wasOnloadDispatched())
412         return LockBackForwardList::Yes;
413 
414     // Navigation of a subframe during loading of an ancestor frame does not create a new back/forward item.
415     // The definition of &quot;during load&quot; is any time before all handlers for the load event have been run.
416     // See https://bugs.webkit.org/show_bug.cgi?id=14957 for the original motivation for this.
417     for (Frame* ancestor = targetFrame.tree().parent(); ancestor; ancestor = ancestor-&gt;tree().parent()) {
418         Document* document = ancestor-&gt;document();
419         if (!ancestor-&gt;loader().isComplete() || (document &amp;&amp; document-&gt;processingLoadEvent()))
420             return LockBackForwardList::Yes;
421     }
422     return LockBackForwardList::No;
423 }
424 
425 void NavigationScheduler::scheduleLocationChange(Document&amp; initiatingDocument, SecurityOrigin&amp; securityOrigin, const URL&amp; url, const String&amp; referrer, LockHistory lockHistory, LockBackForwardList lockBackForwardList, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
426 {
427     if (!shouldScheduleNavigation(url))
428         return completionHandler();
429 
430     if (lockBackForwardList == LockBackForwardList::No)
431         lockBackForwardList = mustLockBackForwardList(m_frame);
432 
433     FrameLoader&amp; loader = m_frame.loader();
434 
435     // If the URL we&#39;re going to navigate to is the same as the current one, except for the
436     // fragment part, we don&#39;t need to schedule the location change.
437     if (url.hasFragmentIdentifier() &amp;&amp; equalIgnoringFragmentIdentifier(m_frame.document()-&gt;url(), url)) {
438         ResourceRequest resourceRequest { m_frame.document()-&gt;completeURL(url), referrer, ResourceRequestCachePolicy::UseProtocolCachePolicy };
439         auto* frame = lexicalFrameFromCommonVM();
440         auto initiatedByMainFrame = frame &amp;&amp; frame-&gt;isMainFrame() ? InitiatedByMainFrame::Yes : InitiatedByMainFrame::Unknown;
441 
442         FrameLoadRequest frameLoadRequest { initiatingDocument, securityOrigin, resourceRequest, &quot;_self&quot;_s, lockHistory, lockBackForwardList, MaybeSendReferrer, AllowNavigationToInvalidURL::No, NewFrameOpenerPolicy::Allow, initiatingDocument.shouldOpenExternalURLsPolicyToPropagate(), initiatedByMainFrame };
443         loader.changeLocation(WTFMove(frameLoadRequest));
444         return completionHandler();
445     }
446 
447     // Handle a location change of a page with no document as a special case.
448     // This may happen when a frame changes the location of another frame.
449     bool duringLoad = !loader.stateMachine().committedFirstRealDocumentLoad();
450 
451     schedule(makeUnique&lt;ScheduledLocationChange&gt;(initiatingDocument, &amp;securityOrigin, url, referrer, lockHistory, lockBackForwardList, duringLoad, WTFMove(completionHandler)));
452 }
453 
454 void NavigationScheduler::scheduleFormSubmission(Ref&lt;FormSubmission&gt;&amp;&amp; submission)
455 {
456     ASSERT(m_frame.page());
457 
458     // FIXME: Do we need special handling for form submissions where the URL is the same
459     // as the current one except for the fragment part? See scheduleLocationChange above.
460 
461     // Handle a location change of a page with no document as a special case.
462     // This may happen when a frame changes the location of another frame.
463     bool duringLoad = !m_frame.loader().stateMachine().committedFirstRealDocumentLoad();
464 
465     // If this is a child frame and the form submission was triggered by a script, lock the back/forward list
466     // to match IE and Opera.
467     // See https://bugs.webkit.org/show_bug.cgi?id=32383 for the original motivation for this.
468     LockBackForwardList lockBackForwardList = mustLockBackForwardList(m_frame);
469     if (lockBackForwardList == LockBackForwardList::No
470         &amp;&amp; (submission-&gt;state().formSubmissionTrigger() == SubmittedByJavaScript &amp;&amp; m_frame.tree().parent() &amp;&amp; !UserGestureIndicator::processingUserGesture())) {
471         lockBackForwardList = LockBackForwardList::Yes;
472     }
473 
474     schedule(makeUnique&lt;ScheduledFormSubmission&gt;(WTFMove(submission), lockBackForwardList, duringLoad));
475 }
476 
477 void NavigationScheduler::scheduleRefresh(Document&amp; initiatingDocument)
478 {
479     if (!shouldScheduleNavigation())
480         return;
481     const URL&amp; url = m_frame.document()-&gt;url();
482     if (url.isEmpty())
483         return;
484 
485     schedule(makeUnique&lt;ScheduledRefresh&gt;(initiatingDocument, &amp;m_frame.document()-&gt;securityOrigin(), url, m_frame.loader().outgoingReferrer()));
486 }
487 
488 void NavigationScheduler::scheduleHistoryNavigation(int steps)
489 {
490     LOG(History, &quot;NavigationScheduler %p scheduleHistoryNavigation(%d) - shouldSchedule %d&quot;, this, steps, shouldScheduleNavigation());
491     if (!shouldScheduleNavigation())
492         return;
493 
494     // Invalid history navigations (such as history.forward() during a new load) have the side effect of cancelling any scheduled
495     // redirects. We also avoid the possibility of cancelling the current load by avoiding the scheduled redirection altogether.
496     BackForwardController&amp; backForward = m_frame.page()-&gt;backForward();
497     if ((steps &gt; 0 &amp;&amp; static_cast&lt;unsigned&gt;(steps) &gt; backForward.forwardCount())
498         || (steps &lt; 0 &amp;&amp; static_cast&lt;unsigned&gt;(-steps) &gt; backForward.backCount())) {
499         cancel();
500         return;
501     }
502 
503     // In all other cases, schedule the history traversal to occur asynchronously.
504     schedule(makeUnique&lt;ScheduledHistoryNavigation&gt;(steps));
505 }
506 
507 void NavigationScheduler::schedulePageBlock(Document&amp; originDocument)
508 {
509     if (shouldScheduleNavigation())
510         schedule(makeUnique&lt;ScheduledPageBlock&gt;(originDocument));
511 }
512 
513 void NavigationScheduler::timerFired()
514 {
515     if (!m_frame.page())
516         return;
517     if (m_frame.page()-&gt;defersLoading()) {
518         InspectorInstrumentation::frameClearedScheduledNavigation(m_frame);
519         return;
520     }
521 
522     Ref&lt;Frame&gt; protect(m_frame);
523 
524     std::unique_ptr&lt;ScheduledNavigation&gt; redirect = WTFMove(m_redirect);
525     LOG(History, &quot;NavigationScheduler %p timerFired - firing redirect %p&quot;, this, redirect.get());
526 
527     redirect-&gt;fire(m_frame);
528     InspectorInstrumentation::frameClearedScheduledNavigation(m_frame);
529 }
530 
531 void NavigationScheduler::schedule(std::unique_ptr&lt;ScheduledNavigation&gt; redirect)
532 {
533     ASSERT(m_frame.page());
534 
535     Ref&lt;Frame&gt; protect(m_frame);
536 
537     // If a redirect was scheduled during a load, then stop the current load.
538     // Otherwise when the current load transitions from a provisional to a
539     // committed state, pending redirects may be cancelled.
540     if (redirect-&gt;wasDuringLoad()) {
541         if (DocumentLoader* provisionalDocumentLoader = m_frame.loader().provisionalDocumentLoader())
542             provisionalDocumentLoader-&gt;stopLoading();
543         m_frame.loader().stopLoading(UnloadEventPolicyUnloadAndPageHide);
544     }
545 
546     cancel();
547     m_redirect = WTFMove(redirect);
548 
549     if (!m_frame.loader().isComplete() &amp;&amp; m_redirect-&gt;isLocationChange())
550         m_frame.loader().completed();
551 
552     if (!m_frame.page())
553         return;
554 
555     startTimer();
556 }
557 
558 void NavigationScheduler::startTimer()
559 {
560     if (!m_redirect)
561         return;
562 
563     ASSERT(m_frame.page());
564     if (m_timer.isActive())
565         return;
566     if (!m_redirect-&gt;shouldStartTimer(m_frame))
567         return;
568 
569     Seconds delay = 1_s * m_redirect-&gt;delay();
570     m_timer.startOneShot(delay);
571     InspectorInstrumentation::frameScheduledNavigation(m_frame, delay);
572     m_redirect-&gt;didStartTimer(m_frame, m_timer); // m_redirect may be null on return (e.g. the client canceled the load)
573 }
574 
575 void NavigationScheduler::cancel(NewLoadInProgress newLoadInProgress)
576 {
577     LOG(History, &quot;NavigationScheduler %p cancel(newLoadInProgress=%d)&quot;, this, newLoadInProgress == NewLoadInProgress::Yes);
578 
579     if (m_timer.isActive())
580         InspectorInstrumentation::frameClearedScheduledNavigation(m_frame);
581     m_timer.stop();
582 
583     if (auto redirect = WTFMove(m_redirect))
584         redirect-&gt;didStopTimer(m_frame, newLoadInProgress);
585 }
586 
587 } // namespace WebCore
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
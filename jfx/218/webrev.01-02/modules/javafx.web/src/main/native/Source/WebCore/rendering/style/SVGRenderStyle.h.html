<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/style/SVGRenderStyle.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2     Copyright (C) 2004, 2005, 2007 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3                   2004, 2005 Rob Buis &lt;buis@kde.org&gt;
  4     Copyright (C) 2005-2017 Apple Inc. All rights reserved.
  5     Copyright (C) Research In Motion Limited 2010. All rights reserved.
  6     Copyright (C) 2014 Adobe Systems Incorporated. All rights reserved.
  7 
  8     This library is free software; you can redistribute it and/or
  9     modify it under the terms of the GNU Library General Public
 10     License as published by the Free Software Foundation; either
 11     version 2 of the License, or (at your option) any later version.
 12 
 13     This library is distributed in the hope that it will be useful,
 14     but WITHOUT ANY WARRANTY; without even the implied warranty of
 15     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16     Library General Public License for more details.
 17 
 18     You should have received a copy of the GNU Library General Public License
 19     along with this library; see the file COPYING.LIB.  If not, write to
 20     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21     Boston, MA 02110-1301, USA.
 22 */
 23 
 24 #pragma once
 25 
 26 #include &quot;DataRef.h&quot;
 27 #include &quot;RenderStyleConstants.h&quot;
 28 #include &quot;SVGRenderStyleDefs.h&quot;
 29 #include &quot;WindRule.h&quot;
 30 
 31 namespace WebCore {
 32 
 33 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SVGRenderStyle);
 34 class SVGRenderStyle : public RefCounted&lt;SVGRenderStyle&gt; {
 35     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(SVGRenderStyle);
 36 public:
 37     static Ref&lt;SVGRenderStyle&gt; createDefaultStyle();
 38     static Ref&lt;SVGRenderStyle&gt; create() { return adoptRef(*new SVGRenderStyle); }
 39     Ref&lt;SVGRenderStyle&gt; copy() const;
 40     ~SVGRenderStyle();
 41 
 42     bool inheritedEqual(const SVGRenderStyle&amp;) const;
 43     void inheritFrom(const SVGRenderStyle&amp;);
 44     void copyNonInheritedFrom(const SVGRenderStyle&amp;);
 45 
 46     StyleDifference diff(const SVGRenderStyle&amp;) const;
 47 
 48     bool operator==(const SVGRenderStyle&amp;) const;
 49     bool operator!=(const SVGRenderStyle&amp; other) const { return !(*this == other); }
 50 
 51     // Initial values for all the properties
 52     static AlignmentBaseline initialAlignmentBaseline() { return AlignmentBaseline::Auto; }
 53     static DominantBaseline initialDominantBaseline() { return DominantBaseline::Auto; }
 54     static BaselineShift initialBaselineShift() { return BaselineShift::Baseline; }
 55     static VectorEffect initialVectorEffect() { return VectorEffect::None; }
 56     static BufferedRendering initialBufferedRendering() { return BufferedRendering::Auto; }
 57     static WindRule initialClipRule() { return WindRule::NonZero; }
 58     static ColorInterpolation initialColorInterpolation() { return ColorInterpolation::SRGB; }
 59     static ColorInterpolation initialColorInterpolationFilters() { return ColorInterpolation::LinearRGB; }
 60     static ColorRendering initialColorRendering() { return ColorRendering::Auto; }
 61     static WindRule initialFillRule() { return WindRule::NonZero; }
 62     static ShapeRendering initialShapeRendering() { return ShapeRendering::Auto; }
 63     static TextAnchor initialTextAnchor() { return TextAnchor::Start; }
 64     static GlyphOrientation initialGlyphOrientationHorizontal() { return GlyphOrientation::Degrees0; }
 65     static GlyphOrientation initialGlyphOrientationVertical() { return GlyphOrientation::Auto; }
 66     static float initialFillOpacity() { return 1; }
 67     static SVGPaintType initialFillPaintType() { return SVGPaintType::RGBColor; }
 68     static Color initialFillPaintColor() { return Color::black; }
 69     static String initialFillPaintUri() { return String(); }
 70     static float initialStrokeOpacity() { return 1; }
 71     static SVGPaintType initialStrokePaintType() { return SVGPaintType::None; }
 72     static Color initialStrokePaintColor() { return Color(); }
 73     static String initialStrokePaintUri() { return String(); }
 74     static Vector&lt;SVGLengthValue&gt; initialStrokeDashArray() { return { }; }
 75     static float initialStopOpacity() { return 1; }
 76     static Color initialStopColor() { return Color(0, 0, 0); }
 77     static float initialFloodOpacity() { return 1; }
 78     static Color initialFloodColor() { return Color(0, 0, 0); }
 79     static Color initialLightingColor() { return Color(255, 255, 255); }
 80     static ShadowData* initialShadow() { return nullptr; }
 81     static String initialMaskerResource() { return String(); }
 82     static String initialMarkerStartResource() { return String(); }
 83     static String initialMarkerMidResource() { return String(); }
 84     static String initialMarkerEndResource() { return String(); }
 85     static MaskType initialMaskType() { return MaskType::Luminance; }
 86     static SVGLengthValue initialBaselineShiftValue() { return SVGLengthValue(0, SVGLengthType::Number); }
 87     static SVGLengthValue initialKerning() { return SVGLengthValue(0, SVGLengthType::Number); }
 88 
 89     // SVG CSS Property setters
 90     void setAlignmentBaseline(AlignmentBaseline val) { m_nonInheritedFlags.flagBits.alignmentBaseline = static_cast&lt;unsigned&gt;(val); }
 91     void setDominantBaseline(DominantBaseline val) { m_nonInheritedFlags.flagBits.dominantBaseline = static_cast&lt;unsigned&gt;(val); }
 92     void setBaselineShift(BaselineShift val) { m_nonInheritedFlags.flagBits.baselineShift = static_cast&lt;unsigned&gt;(val); }
 93     void setVectorEffect(VectorEffect val) { m_nonInheritedFlags.flagBits.vectorEffect = static_cast&lt;unsigned&gt;(val); }
 94     void setBufferedRendering(BufferedRendering val) { m_nonInheritedFlags.flagBits.bufferedRendering = static_cast&lt;unsigned&gt;(val); }
 95     void setClipRule(WindRule val) { m_inheritedFlags.clipRule = static_cast&lt;unsigned&gt;(val); }
 96     void setColorInterpolation(ColorInterpolation val) { m_inheritedFlags.colorInterpolation = static_cast&lt;unsigned&gt;(val); }
 97     void setColorInterpolationFilters(ColorInterpolation val) { m_inheritedFlags.colorInterpolationFilters = static_cast&lt;unsigned&gt;(val); }
 98     void setColorRendering(ColorRendering val) { m_inheritedFlags.colorRendering = static_cast&lt;unsigned&gt;(val); }
 99     void setFillRule(WindRule val) { m_inheritedFlags.fillRule = static_cast&lt;unsigned&gt;(val); }
100     void setShapeRendering(ShapeRendering val) { m_inheritedFlags.shapeRendering = static_cast&lt;unsigned&gt;(val); }
101     void setTextAnchor(TextAnchor val) { m_inheritedFlags.textAnchor = static_cast&lt;unsigned&gt;(val); }
102     void setGlyphOrientationHorizontal(GlyphOrientation val) { m_inheritedFlags.glyphOrientationHorizontal = static_cast&lt;unsigned&gt;(val); }
103     void setGlyphOrientationVertical(GlyphOrientation val) { m_inheritedFlags.glyphOrientationVertical = static_cast&lt;unsigned&gt;(val); }
104     void setMaskType(MaskType val) { m_nonInheritedFlags.flagBits.maskType = static_cast&lt;unsigned&gt;(val); }
105     void setCx(const Length&amp;);
106     void setCy(const Length&amp;);
107     void setR(const Length&amp;);
108     void setRx(const Length&amp;);
109     void setRy(const Length&amp;);
110     void setX(const Length&amp;);
111     void setY(const Length&amp;);
112     void setFillOpacity(float);
113     void setFillPaint(SVGPaintType, const Color&amp;, const String&amp; uri, bool applyToRegularStyle = true, bool applyToVisitedLinkStyle = false);
114     void setStrokeOpacity(float);
115     void setStrokePaint(SVGPaintType, const Color&amp;, const String&amp; uri, bool applyToRegularStyle = true, bool applyToVisitedLinkStyle = false);
116 
117     void setStrokeDashArray(const Vector&lt;SVGLengthValue&gt;&amp;);
118     void setStrokeDashOffset(const Length&amp;);
119     void setKerning(const SVGLengthValue&amp;);
120     void setStopOpacity(float);
121     void setStopColor(const Color&amp;);
122     void setFloodOpacity(float);
123     void setFloodColor(const Color&amp;);
124     void setLightingColor(const Color&amp;);
125     void setBaselineShiftValue(const SVGLengthValue&amp;);
126 
127     void setShadow(std::unique_ptr&lt;ShadowData&gt;&amp;&amp; data) { m_shadowData.access().shadow = WTFMove(data); }
128 
129     // Setters for non-inherited resources
130     void setMaskerResource(const String&amp;);
131 
132     // Setters for inherited resources
133     void setMarkerStartResource(const String&amp;);
134     void setMarkerMidResource(const String&amp;);
135     void setMarkerEndResource(const String&amp;);
136 
137     // Read accessors for all the properties
138     AlignmentBaseline alignmentBaseline() const { return static_cast&lt;AlignmentBaseline&gt;(m_nonInheritedFlags.flagBits.alignmentBaseline); }
139     DominantBaseline dominantBaseline() const { return static_cast&lt;DominantBaseline&gt;(m_nonInheritedFlags.flagBits.dominantBaseline); }
140     BaselineShift baselineShift() const { return static_cast&lt;BaselineShift&gt;(m_nonInheritedFlags.flagBits.baselineShift); }
141     VectorEffect vectorEffect() const { return static_cast&lt;VectorEffect&gt;(m_nonInheritedFlags.flagBits.vectorEffect); }
142     BufferedRendering bufferedRendering() const { return static_cast&lt;BufferedRendering&gt;(m_nonInheritedFlags.flagBits.bufferedRendering); }
143     WindRule clipRule() const { return static_cast&lt;WindRule&gt;(m_inheritedFlags.clipRule); }
144     ColorInterpolation colorInterpolation() const { return static_cast&lt;ColorInterpolation&gt;(m_inheritedFlags.colorInterpolation); }
145     ColorInterpolation colorInterpolationFilters() const { return static_cast&lt;ColorInterpolation&gt;(m_inheritedFlags.colorInterpolationFilters); }
146     ColorRendering colorRendering() const { return static_cast&lt;ColorRendering&gt;(m_inheritedFlags.colorRendering); }
147     WindRule fillRule() const { return static_cast&lt;WindRule&gt;(m_inheritedFlags.fillRule); }
148     ShapeRendering shapeRendering() const { return static_cast&lt;ShapeRendering&gt;(m_inheritedFlags.shapeRendering); }
149     TextAnchor textAnchor() const { return static_cast&lt;TextAnchor&gt;(m_inheritedFlags.textAnchor); }
150     GlyphOrientation glyphOrientationHorizontal() const { return static_cast&lt;GlyphOrientation&gt;(m_inheritedFlags.glyphOrientationHorizontal); }
151     GlyphOrientation glyphOrientationVertical() const { return static_cast&lt;GlyphOrientation&gt;(m_inheritedFlags.glyphOrientationVertical); }
152     float fillOpacity() const { return m_fillData-&gt;opacity; }
153     SVGPaintType fillPaintType() const { return static_cast&lt;SVGPaintType&gt;(m_fillData-&gt;paintType); }
154     const Color&amp; fillPaintColor() const { return m_fillData-&gt;paintColor; }
155     const String&amp; fillPaintUri() const { return m_fillData-&gt;paintUri; }
156     float strokeOpacity() const { return m_strokeData-&gt;opacity; }
157     SVGPaintType strokePaintType() const { return static_cast&lt;SVGPaintType&gt;(m_strokeData-&gt;paintType); }
158     const Color&amp; strokePaintColor() const { return m_strokeData-&gt;paintColor; }
159     const String&amp; strokePaintUri() const { return m_strokeData-&gt;paintUri; }
160     Vector&lt;SVGLengthValue&gt; strokeDashArray() const { return m_strokeData-&gt;dashArray; }
161     const Length&amp; strokeDashOffset() const { return m_strokeData-&gt;dashOffset; }
162     SVGLengthValue kerning() const { return m_textData-&gt;kerning; }
163     float stopOpacity() const { return m_stopData-&gt;opacity; }
164     const Color&amp; stopColor() const { return m_stopData-&gt;color; }
165     float floodOpacity() const { return m_miscData-&gt;floodOpacity; }
166     const Color&amp; floodColor() const { return m_miscData-&gt;floodColor; }
167     const Color&amp; lightingColor() const { return m_miscData-&gt;lightingColor; }
168     SVGLengthValue baselineShiftValue() const { return m_miscData-&gt;baselineShiftValue; }
169     ShadowData* shadow() const { return m_shadowData-&gt;shadow.get(); }
170     const Length&amp; cx() const { return m_layoutData-&gt;cx; }
171     const Length&amp; cy() const { return m_layoutData-&gt;cy; }
172     const Length&amp; r() const { return m_layoutData-&gt;r; }
173     const Length&amp; rx() const { return m_layoutData-&gt;rx; }
174     const Length&amp; ry() const { return m_layoutData-&gt;ry; }
175     const Length&amp; x() const { return m_layoutData-&gt;x; }
176     const Length&amp; y() const { return m_layoutData-&gt;y; }
177     const String&amp; maskerResource() const { return m_nonInheritedResourceData-&gt;masker; }
178     const String&amp; markerStartResource() const { return m_inheritedResourceData-&gt;markerStart; }
179     const String&amp; markerMidResource() const { return m_inheritedResourceData-&gt;markerMid; }
180     const String&amp; markerEndResource() const { return m_inheritedResourceData-&gt;markerEnd; }
181     MaskType maskType() const { return static_cast&lt;MaskType&gt;(m_nonInheritedFlags.flagBits.maskType); }
182 
183     SVGPaintType visitedLinkFillPaintType() const { return static_cast&lt;SVGPaintType&gt;(m_fillData-&gt;visitedLinkPaintType); }
184     const Color&amp; visitedLinkFillPaintColor() const { return m_fillData-&gt;visitedLinkPaintColor; }
185     const String&amp; visitedLinkFillPaintUri() const { return m_fillData-&gt;visitedLinkPaintUri; }
186     SVGPaintType visitedLinkStrokePaintType() const { return static_cast&lt;SVGPaintType&gt;(m_strokeData-&gt;visitedLinkPaintType); }
187     const Color&amp; visitedLinkStrokePaintColor() const { return m_strokeData-&gt;visitedLinkPaintColor; }
188     const String&amp; visitedLinkStrokePaintUri() const { return m_strokeData-&gt;visitedLinkPaintUri; }
189 
190     // convenience
191     bool hasMasker() const { return !maskerResource().isEmpty(); }
192     bool hasMarkers() const { return !markerStartResource().isEmpty() || !markerMidResource().isEmpty() || !markerEndResource().isEmpty(); }
193     bool hasStroke() const { return strokePaintType() != SVGPaintType::None; }
194     bool hasFill() const { return fillPaintType() != SVGPaintType::None; }
195     bool isolatesBlending() const { return hasMasker() || shadow(); }
196 
197 private:
198     SVGRenderStyle();
199     SVGRenderStyle(const SVGRenderStyle&amp;);
200 
201     enum CreateDefaultType { CreateDefault };
202     SVGRenderStyle(CreateDefaultType); // Used to create the default style.
203 
204     void setBitDefaults();
205 
206     struct InheritedFlags {
207         bool operator==(const InheritedFlags&amp;) const;
208         bool operator!=(const InheritedFlags&amp; other) const { return !(*this == other); }
209 
210         unsigned colorRendering : 2; // ColorRendering
211         unsigned shapeRendering : 2; // ShapeRendering
212         unsigned clipRule : 1; // WindRule
213         unsigned fillRule : 1; // WindRule
214         unsigned textAnchor : 2; // TextAnchor
215         unsigned colorInterpolation : 2; // ColorInterpolation
216         unsigned colorInterpolationFilters : 2; // ColorInterpolation
217         unsigned glyphOrientationHorizontal : 3; // GlyphOrientation
218         unsigned glyphOrientationVertical : 3; // GlyphOrientation
219     };
220 
221     struct NonInheritedFlags {
222         // 32 bit non-inherited, don&#39;t add to the struct, or the operator will break.
223         bool operator==(const NonInheritedFlags&amp; other) const { return flags == other.flags; }
224         bool operator!=(const NonInheritedFlags&amp; other) const { return flags != other.flags; }
225 
226         union {
227             struct {
228                 unsigned alignmentBaseline : 4; // AlignmentBaseline
229                 unsigned dominantBaseline : 4; // DominantBaseline
230                 unsigned baselineShift : 2; // BaselineShift
231                 unsigned vectorEffect: 1; // VectorEffect
232                 unsigned bufferedRendering: 2; // BufferedRendering
233                 unsigned maskType: 1; // MaskType
234                 // 18 bits unused
235             } flagBits;
236             uint32_t flags;
237         };
238     };
239 
240     InheritedFlags m_inheritedFlags;
241     NonInheritedFlags m_nonInheritedFlags;
242 
243     // inherited attributes
244     DataRef&lt;StyleFillData&gt; m_fillData;
245     DataRef&lt;StyleStrokeData&gt; m_strokeData;
246     DataRef&lt;StyleTextData&gt; m_textData;
247     DataRef&lt;StyleInheritedResourceData&gt; m_inheritedResourceData;
248 
249     // non-inherited attributes
250     DataRef&lt;StyleStopData&gt; m_stopData;
251     DataRef&lt;StyleMiscData&gt; m_miscData;
252     DataRef&lt;StyleShadowSVGData&gt; m_shadowData;
253     DataRef&lt;StyleLayoutData&gt; m_layoutData;
254     DataRef&lt;StyleResourceData&gt; m_nonInheritedResourceData;
255 };
256 
257 inline void SVGRenderStyle::setCx(const Length&amp; length)
258 {
259     if (!(m_layoutData-&gt;cx == length))
260         m_layoutData.access().cx = length;
261 }
262 
263 inline void SVGRenderStyle::setCy(const Length&amp; length)
264 {
265     if (!(m_layoutData-&gt;cy == length))
266         m_layoutData.access().cy = length;
267 }
268 
269 inline void SVGRenderStyle::setR(const Length&amp; length)
270 {
271     if (!(m_layoutData-&gt;r == length))
272         m_layoutData.access().r = length;
273 }
274 
275 inline void SVGRenderStyle::setRx(const Length&amp; length)
276 {
277     if (!(m_layoutData-&gt;rx == length))
278         m_layoutData.access().rx = length;
279 }
280 
281 inline void SVGRenderStyle::setRy(const Length&amp; length)
282 {
283     if (!(m_layoutData-&gt;ry == length))
284         m_layoutData.access().ry = length;
285 }
286 
287 inline void SVGRenderStyle::setX(const Length&amp; length)
288 {
289     if (!(m_layoutData-&gt;x == length))
290         m_layoutData.access().x = length;
291 }
292 
293 inline void SVGRenderStyle::setY(const Length&amp; length)
294 {
295     if (!(m_layoutData-&gt;y == length))
296         m_layoutData.access().y = length;
297 }
298 
299 inline void SVGRenderStyle::setFillOpacity(float opacity)
300 {
301     if (!(m_fillData-&gt;opacity == opacity))
302         m_fillData.access().opacity = opacity;
303 }
304 
305 inline void SVGRenderStyle::setFillPaint(SVGPaintType type, const Color&amp; color, const String&amp; uri, bool applyToRegularStyle, bool applyToVisitedLinkStyle)
306 {
307     if (applyToRegularStyle) {
308         if (!(m_fillData-&gt;paintType == type))
309             m_fillData.access().paintType = type;
310         if (!(m_fillData-&gt;paintColor == color))
311             m_fillData.access().paintColor = color;
312         if (!(m_fillData-&gt;paintUri == uri))
313             m_fillData.access().paintUri = uri;
314     }
315     if (applyToVisitedLinkStyle) {
316         if (!(m_fillData-&gt;visitedLinkPaintType == type))
317             m_fillData.access().visitedLinkPaintType = type;
318         if (!(m_fillData-&gt;visitedLinkPaintColor == color))
319             m_fillData.access().visitedLinkPaintColor = color;
320         if (!(m_fillData-&gt;visitedLinkPaintUri == uri))
321             m_fillData.access().visitedLinkPaintUri = uri;
322     }
323 }
324 
325 inline void SVGRenderStyle::setStrokeOpacity(float opacity)
326 {
327     if (!(m_strokeData-&gt;opacity == opacity))
328         m_strokeData.access().opacity = opacity;
329 }
330 
331 inline void SVGRenderStyle::setStrokePaint(SVGPaintType type, const Color&amp; color, const String&amp; uri, bool applyToRegularStyle, bool applyToVisitedLinkStyle)
332 {
333     if (applyToRegularStyle) {
334         if (!(m_strokeData-&gt;paintType == type))
335             m_strokeData.access().paintType = type;
336         if (!(m_strokeData-&gt;paintColor == color))
337             m_strokeData.access().paintColor = color;
338         if (!(m_strokeData-&gt;paintUri == uri))
339             m_strokeData.access().paintUri = uri;
340     }
341     if (applyToVisitedLinkStyle) {
342         if (!(m_strokeData-&gt;visitedLinkPaintType == type))
343             m_strokeData.access().visitedLinkPaintType = type;
344         if (!(m_strokeData-&gt;visitedLinkPaintColor == color))
345             m_strokeData.access().visitedLinkPaintColor = color;
346         if (!(m_strokeData-&gt;visitedLinkPaintUri == uri))
347             m_strokeData.access().visitedLinkPaintUri = uri;
348     }
349 }
350 
351 inline void SVGRenderStyle::setStrokeDashArray(const Vector&lt;SVGLengthValue&gt;&amp; array)
352 {
353     if (!(m_strokeData-&gt;dashArray == array))
354         m_strokeData.access().dashArray = array;
355 }
356 
357 inline void SVGRenderStyle::setStrokeDashOffset(const Length&amp; offset)
358 {
359     if (!(m_strokeData-&gt;dashOffset == offset))
360         m_strokeData.access().dashOffset = offset;
361 }
362 
363 inline void SVGRenderStyle::setKerning(const SVGLengthValue&amp; kerning)
364 {
365     if (!(m_textData-&gt;kerning == kerning))
366         m_textData.access().kerning = kerning;
367 }
368 
369 inline void SVGRenderStyle::setStopOpacity(float opacity)
370 {
371     if (!(m_stopData-&gt;opacity == opacity))
372         m_stopData.access().opacity = opacity;
373 }
374 
375 inline void SVGRenderStyle::setStopColor(const Color&amp; color)
376 {
377     if (!(m_stopData-&gt;color == color))
378         m_stopData.access().color = color;
379 }
380 
381 inline void SVGRenderStyle::setFloodOpacity(float opacity)
382 {
383     if (!(m_miscData-&gt;floodOpacity == opacity))
384         m_miscData.access().floodOpacity = opacity;
385 }
386 
387 inline void SVGRenderStyle::setFloodColor(const Color&amp; color)
388 {
389     if (!(m_miscData-&gt;floodColor == color))
390         m_miscData.access().floodColor = color;
391 }
392 
393 inline void SVGRenderStyle::setLightingColor(const Color&amp; color)
394 {
395     if (!(m_miscData-&gt;lightingColor == color))
396         m_miscData.access().lightingColor = color;
397 }
398 
399 inline void SVGRenderStyle::setBaselineShiftValue(const SVGLengthValue&amp; shiftValue)
400 {
401     if (!(m_miscData-&gt;baselineShiftValue == shiftValue))
402         m_miscData.access().baselineShiftValue = shiftValue;
403 }
404 
405 inline void SVGRenderStyle::setMaskerResource(const String&amp; resource)
406 {
407     if (!(m_nonInheritedResourceData-&gt;masker == resource))
408         m_nonInheritedResourceData.access().masker = resource;
409 }
410 
411 inline void SVGRenderStyle::setMarkerStartResource(const String&amp; resource)
412 {
413     if (!(m_inheritedResourceData-&gt;markerStart == resource))
414         m_inheritedResourceData.access().markerStart = resource;
415 }
416 
417 inline void SVGRenderStyle::setMarkerMidResource(const String&amp; resource)
418 {
419     if (!(m_inheritedResourceData-&gt;markerMid == resource))
420         m_inheritedResourceData.access().markerMid = resource;
421 }
422 
423 inline void SVGRenderStyle::setMarkerEndResource(const String&amp; resource)
424 {
425     if (!(m_inheritedResourceData-&gt;markerEnd == resource))
426         m_inheritedResourceData.access().markerEnd = resource;
427 }
428 
429 inline void SVGRenderStyle::setBitDefaults()
430 {
431     m_inheritedFlags.clipRule = static_cast&lt;unsigned&gt;(initialClipRule());
432     m_inheritedFlags.colorRendering = static_cast&lt;unsigned&gt;(initialColorRendering());
433     m_inheritedFlags.fillRule = static_cast&lt;unsigned&gt;(initialFillRule());
434     m_inheritedFlags.shapeRendering = static_cast&lt;unsigned&gt;(initialShapeRendering());
435     m_inheritedFlags.textAnchor = static_cast&lt;unsigned&gt;(initialTextAnchor());
436     m_inheritedFlags.colorInterpolation = static_cast&lt;unsigned&gt;(initialColorInterpolation());
437     m_inheritedFlags.colorInterpolationFilters = static_cast&lt;unsigned&gt;(initialColorInterpolationFilters());
438     m_inheritedFlags.glyphOrientationHorizontal = static_cast&lt;unsigned&gt;(initialGlyphOrientationHorizontal());
439     m_inheritedFlags.glyphOrientationVertical = static_cast&lt;unsigned&gt;(initialGlyphOrientationVertical());
440 
441     m_nonInheritedFlags.flags = 0;
442     m_nonInheritedFlags.flagBits.alignmentBaseline = static_cast&lt;unsigned&gt;(initialAlignmentBaseline());
443     m_nonInheritedFlags.flagBits.dominantBaseline = static_cast&lt;unsigned&gt;(initialDominantBaseline());
444     m_nonInheritedFlags.flagBits.baselineShift = static_cast&lt;unsigned&gt;(initialBaselineShift());
445     m_nonInheritedFlags.flagBits.vectorEffect = static_cast&lt;unsigned&gt;(initialVectorEffect());
446     m_nonInheritedFlags.flagBits.bufferedRendering = static_cast&lt;unsigned&gt;(initialBufferedRendering());
447     m_nonInheritedFlags.flagBits.maskType = static_cast&lt;unsigned&gt;(initialMaskType());
448 }
449 
450 inline bool SVGRenderStyle::InheritedFlags::operator==(const InheritedFlags&amp; other) const
451 {
452     return colorRendering == other.colorRendering
453         &amp;&amp; shapeRendering == other.shapeRendering
454         &amp;&amp; clipRule == other.clipRule
455         &amp;&amp; fillRule == other.fillRule
456         &amp;&amp; textAnchor == other.textAnchor
457         &amp;&amp; colorInterpolation == other.colorInterpolation
458         &amp;&amp; colorInterpolationFilters == other.colorInterpolationFilters
459         &amp;&amp; glyphOrientationHorizontal == other.glyphOrientationHorizontal
460         &amp;&amp; glyphOrientationVertical == other.glyphOrientationVertical;
461 }
462 
463 } // namespace WebCore
    </pre>
  </body>
</html>
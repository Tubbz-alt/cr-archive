diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPutStackSinkingPhase.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPutStackSinkingPhase.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPutStackSinkingPhase.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPutStackSinkingPhase.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2014-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2014-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -40,15 +40,12 @@
 
 namespace JSC { namespace DFG {
 
 namespace {
 
-namespace DFGPutStackSinkingPhaseInternal {
-static const bool verbose = false;
-}
-
 class PutStackSinkingPhase : public Phase {
+    static constexpr bool verbose = false;
 public:
     PutStackSinkingPhase(Graph& graph)
         : Phase(graph, "PutStack sinking")
     {
     }
@@ -71,11 +68,11 @@
         // More important is that KillStack should swallow any deferral. After a KillStack, the
         // local should behave like a TOP deferral because it would be invalid for anyone to trust
         // the stack. It's not clear to me if this is important or not.
         // https://bugs.webkit.org/show_bug.cgi?id=145296
 
-        if (DFGPutStackSinkingPhaseInternal::verbose) {
+        if (verbose) {
             dataLog("Graph before PutStack sinking:\n");
             m_graph.dump();
         }
 
         m_graph.ensureSSADominators();
@@ -86,15 +83,12 @@
         // First figure out where various locals are live.
         BlockMap<Operands<bool>> liveAtHead(m_graph);
         BlockMap<Operands<bool>> liveAtTail(m_graph);
 
         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
-            liveAtHead[block] = Operands<bool>(OperandsLike, block->variablesAtHead);
-            liveAtTail[block] = Operands<bool>(OperandsLike, block->variablesAtHead);
-
-            liveAtHead[block].fill(false);
-            liveAtTail[block].fill(false);
+            liveAtHead[block] = Operands<bool>(OperandsLike, block->variablesAtHead, false);
+            liveAtTail[block] = Operands<bool>(OperandsLike, block->variablesAtHead, false);
         }
 
         bool changed;
         do {
             changed = false;
@@ -105,37 +99,38 @@
                     continue;
 
                 Operands<bool> live = liveAtTail[block];
                 for (unsigned nodeIndex = block->size(); nodeIndex--;) {
                     Node* node = block->at(nodeIndex);
-                    if (DFGPutStackSinkingPhaseInternal::verbose)
+                    if (verbose)
                         dataLog("Live at ", node, ": ", live, "\n");
 
-                    Vector<VirtualRegister, 4> reads;
-                    Vector<VirtualRegister, 4> writes;
-                    auto escapeHandler = [&] (VirtualRegister operand) {
+                    Vector<Operand, 4> reads;
+                    Vector<Operand, 4> writes;
+                    auto escapeHandler = [&] (Operand operand) {
                         if (operand.isHeader())
                             return;
-                        if (DFGPutStackSinkingPhaseInternal::verbose)
+                        if (verbose)
                             dataLog("    ", operand, " is live at ", node, "\n");
                         reads.append(operand);
                     };
 
-                    auto writeHandler = [&] (VirtualRegister operand) {
+                    auto writeHandler = [&] (Operand operand) {
                         if (operand.isHeader())
                             return;
-                        RELEASE_ASSERT(node->op() == PutStack || node->op() == LoadVarargs || node->op() == ForwardVarargs || node->op() == KillStack);
+                        auto op = node->op();
+                        RELEASE_ASSERT(op == PutStack || op == LoadVarargs || op == ForwardVarargs || op == KillStack);
                         writes.append(operand);
                     };
 
                     preciseLocalClobberize(
                         m_graph, node, escapeHandler, writeHandler,
-                        [&] (VirtualRegister, LazyNode) { });
+                        [&] (Operand, LazyNode) { });
 
-                    for (VirtualRegister operand : writes)
+                    for (Operand operand : writes)
                         live.operand(operand) = false;
-                    for (VirtualRegister operand : reads)
+                    for (Operand operand : reads)
                         live.operand(operand) = true;
                 }
 
                 if (live == liveAtHead[block])
                     continue;
@@ -232,11 +227,11 @@
 
             for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
                 Operands<FlushFormat> deferred = deferredAtHead[block];
 
                 for (Node* node : *block) {
-                    if (DFGPutStackSinkingPhaseInternal::verbose)
+                    if (verbose)
                         dataLog("Deferred at ", node, ":", deferred, "\n");
 
                     if (node->op() == GetStack) {
                         // Handle the case that the input doesn't match our requirements. This is
                         // really a bug, but it's a benign one if we simply don't run this phase.
@@ -259,11 +254,11 @@
                         // disabled we silently let this fly and we just abort this phase.
                         // FIXME: Get rid of all remaining cases of conflicting GetStacks.
                         // https://bugs.webkit.org/show_bug.cgi?id=150398
 
                         bool isConflicting =
-                            deferred.operand(node->stackAccessData()->local) == ConflictingFlush;
+                            deferred.operand(node->stackAccessData()->operand) == ConflictingFlush;
 
                         if (validationEnabled())
                             DFG_ASSERT(m_graph, node, !isConflicting);
 
                         if (isConflicting) {
@@ -273,55 +268,60 @@
 
                         // A GetStack doesn't affect anything, since we know which local we are reading
                         // from.
                         continue;
                     } else if (node->op() == PutStack) {
-                        VirtualRegister operand = node->stackAccessData()->local;
+                        Operand operand = node->stackAccessData()->operand;
+                        dataLogLnIf(verbose, "Setting flush format for ", node, " at operand ", operand);
                         deferred.operand(operand) = node->stackAccessData()->format;
                         continue;
                     } else if (node->op() == KillStack) {
                         // We don't want to sink a PutStack past a KillStack.
-                        deferred.operand(node->unlinkedLocal()) = ConflictingFlush;
+                        if (verbose)
+                            dataLogLn("Killing stack for ", node->unlinkedOperand());
+                        deferred.operand(node->unlinkedOperand()) = ConflictingFlush;
                         continue;
                     }
 
-                    auto escapeHandler = [&] (VirtualRegister operand) {
-                        if (DFGPutStackSinkingPhaseInternal::verbose)
+                    auto escapeHandler = [&] (Operand operand) {
+                        if (verbose)
                             dataLog("For ", node, " escaping ", operand, "\n");
                         if (operand.isHeader())
                             return;
                         // We will materialize just before any reads.
                         deferred.operand(operand) = DeadFlush;
                     };
 
-                    auto writeHandler = [&] (VirtualRegister operand) {
+                    auto writeHandler = [&] (Operand operand) {
+                        ASSERT(!operand.isTmp());
                         if (operand.isHeader())
                             return;
-                        RELEASE_ASSERT(node->op() == LoadVarargs || node->op() == ForwardVarargs);
+                        RELEASE_ASSERT(node->op() == VarargsLength || node->op() == LoadVarargs || node->op() == ForwardVarargs);
+                        dataLogLnIf(verbose, "Writing dead flush for ", node, " at operand ", operand);
                         deferred.operand(operand) = DeadFlush;
                     };
 
                     preciseLocalClobberize(
                         m_graph, node, escapeHandler, writeHandler,
-                        [&] (VirtualRegister, LazyNode) { });
+                        [&] (Operand, LazyNode) { });
                 }
 
                 if (deferred == deferredAtTail[block])
                     continue;
 
                 deferredAtTail[block] = deferred;
                 changed = true;
 
                 for (BasicBlock* successor : block->successors()) {
                     for (size_t i = deferred.size(); i--;) {
-                        if (DFGPutStackSinkingPhaseInternal::verbose)
-                            dataLog("Considering ", VirtualRegister(deferred.operandForIndex(i)), " at ", pointerDump(block), "->", pointerDump(successor), ": ", deferred[i], " and ", deferredAtHead[successor][i], " merges to ");
+                        if (verbose)
+                            dataLog("Considering ", deferred.operandForIndex(i), " at ", pointerDump(block), "->", pointerDump(successor), ": ", deferred[i], " and ", deferredAtHead[successor][i], " merges to ");
 
                         deferredAtHead[successor][i] =
                             merge(deferredAtHead[successor][i], deferred[i]);
 
-                        if (DFGPutStackSinkingPhaseInternal::verbose)
+                        if (verbose)
                             dataLog(deferredAtHead[successor][i], "\n");
                     }
                 }
             }
 
@@ -350,13 +350,13 @@
         // This means that we have an SSACalculator::Variable for each local, and a Def is any
         // PutStack in the original program. The original PutStacks will simply vanish.
 
         Operands<SSACalculator::Variable*> operandToVariable(
             OperandsLike, m_graph.block(0)->variablesAtHead);
-        Vector<VirtualRegister> indexToOperand;
+        Vector<Operand> indexToOperand;
         for (size_t i = m_graph.block(0)->variablesAtHead.size(); i--;) {
-            VirtualRegister operand(m_graph.block(0)->variablesAtHead.operandForIndex(i));
+            Operand operand = m_graph.block(0)->variablesAtHead.operandForIndex(i);
 
             SSACalculator::Variable* variable = ssaCalculator.newVariable();
             operandToVariable.operand(operand) = variable;
             ASSERT(indexToOperand.size() == variable->index());
             indexToOperand.append(operand);
@@ -368,38 +368,38 @@
             for (Node* node : *block) {
                 switch (node->op()) {
                 case PutStack:
                     putStacksToSink.add(node);
                     ssaCalculator.newDef(
-                        operandToVariable.operand(node->stackAccessData()->local),
+                        operandToVariable.operand(node->stackAccessData()->operand),
                         block, node->child1().node());
                     break;
                 case GetStack:
                     ssaCalculator.newDef(
-                        operandToVariable.operand(node->stackAccessData()->local),
+                        operandToVariable.operand(node->stackAccessData()->operand),
                         block, node);
                     break;
                 default:
                     break;
                 }
             }
         }
 
         ssaCalculator.computePhis(
             [&] (SSACalculator::Variable* variable, BasicBlock* block) -> Node* {
-                VirtualRegister operand = indexToOperand[variable->index()];
+                Operand operand = indexToOperand[variable->index()];
 
                 if (!liveAtHead[block].operand(operand))
                     return nullptr;
 
                 FlushFormat format = deferredAtHead[block].operand(operand);
 
                 // We could have an invalid deferral because liveness is imprecise.
                 if (!isConcrete(format))
                     return nullptr;
 
-                if (DFGPutStackSinkingPhaseInternal::verbose)
+                if (verbose)
                     dataLog("Adding Phi for ", operand, " at ", pointerDump(block), "\n");
 
                 Node* phiNode = m_graph.addNode(SpecHeapTop, Phi, block->at(0)->origin.withInvalidExit());
                 phiNode->mergeFlags(resultFor(format));
                 return phiNode;
@@ -409,85 +409,85 @@
         Operands<FlushFormat> deferred;
         for (BasicBlock* block : m_graph.blocksInNaturalOrder()) {
             mapping.fill(nullptr);
 
             for (size_t i = mapping.size(); i--;) {
-                VirtualRegister operand(mapping.operandForIndex(i));
+                Operand operand(mapping.operandForIndex(i));
 
                 SSACalculator::Variable* variable = operandToVariable.operand(operand);
                 SSACalculator::Def* def = ssaCalculator.reachingDefAtHead(block, variable);
                 if (!def)
                     continue;
 
                 mapping.operand(operand) = def->value();
             }
 
-            if (DFGPutStackSinkingPhaseInternal::verbose)
+            if (verbose)
                 dataLog("Mapping at top of ", pointerDump(block), ": ", mapping, "\n");
 
             for (SSACalculator::Def* phiDef : ssaCalculator.phisForBlock(block)) {
-                VirtualRegister operand = indexToOperand[phiDef->variable()->index()];
+                Operand operand = indexToOperand[phiDef->variable()->index()];
 
                 insertionSet.insert(0, phiDef->value());
 
-                if (DFGPutStackSinkingPhaseInternal::verbose)
+                if (verbose)
                     dataLog("   Mapping ", operand, " to ", phiDef->value(), "\n");
                 mapping.operand(operand) = phiDef->value();
             }
 
             deferred = deferredAtHead[block];
             for (unsigned nodeIndex = 0; nodeIndex < block->size(); ++nodeIndex) {
                 Node* node = block->at(nodeIndex);
-                if (DFGPutStackSinkingPhaseInternal::verbose)
+                if (verbose)
                     dataLog("Deferred at ", node, ":", deferred, "\n");
 
                 switch (node->op()) {
                 case PutStack: {
                     StackAccessData* data = node->stackAccessData();
-                    VirtualRegister operand = data->local;
+                    Operand operand = data->operand;
                     deferred.operand(operand) = data->format;
-                    if (DFGPutStackSinkingPhaseInternal::verbose)
+                    if (verbose)
                         dataLog("   Mapping ", operand, " to ", node->child1().node(), " at ", node, "\n");
                     mapping.operand(operand) = node->child1().node();
                     break;
                 }
 
                 case GetStack: {
                     StackAccessData* data = node->stackAccessData();
-                    FlushFormat format = deferred.operand(data->local);
+                    FlushFormat format = deferred.operand(data->operand);
                     if (!isConcrete(format)) {
                         DFG_ASSERT(
                             m_graph, node,
-                            deferred.operand(data->local) != ConflictingFlush, deferred.operand(data->local));
+                            deferred.operand(data->operand) != ConflictingFlush, deferred.operand(data->operand));
 
                         // This means there is no deferral. No deferral means that the most
                         // authoritative value for this stack slot is what is stored in the stack. So,
                         // keep the GetStack.
-                        mapping.operand(data->local) = node;
+                        mapping.operand(data->operand) = node;
                         break;
                     }
 
                     // We have a concrete deferral, which means a PutStack that hasn't executed yet. It
                     // would have stored a value with a certain format. That format must match our
                     // format. But more importantly, we can simply use the value that the PutStack would
                     // have stored and get rid of the GetStack.
                     DFG_ASSERT(m_graph, node, format == data->format, format, data->format);
 
-                    Node* incoming = mapping.operand(data->local);
+                    Node* incoming = mapping.operand(data->operand);
                     node->child1() = incoming->defaultEdge();
                     node->convertToIdentity();
                     break;
                 }
 
                 case KillStack: {
-                    deferred.operand(node->unlinkedLocal()) = ConflictingFlush;
+                    deferred.operand(node->unlinkedOperand()) = ConflictingFlush;
                     break;
                 }
 
                 default: {
-                    auto escapeHandler = [&] (VirtualRegister operand) {
-                        if (DFGPutStackSinkingPhaseInternal::verbose)
+                    auto escapeHandler = [&] (Operand operand) {
+                        if (verbose)
                             dataLog("For ", node, " escaping ", operand, "\n");
 
                         if (operand.isHeader())
                             return;
 
@@ -497,11 +497,11 @@
                             deferred.operand(operand) = DeadFlush;
                             return;
                         }
 
                         // Gotta insert a PutStack.
-                        if (DFGPutStackSinkingPhaseInternal::verbose)
+                        if (verbose)
                             dataLog("Inserting a PutStack for ", operand, " at ", node, "\n");
 
                         Node* incoming = mapping.operand(operand);
                         DFG_ASSERT(m_graph, node, incoming);
 
@@ -511,25 +511,25 @@
                             Edge(incoming, uncheckedUseKindFor(format)));
 
                         deferred.operand(operand) = DeadFlush;
                     };
 
-                    auto writeHandler = [&] (VirtualRegister operand) {
+                    auto writeHandler = [&] (Operand operand) {
                         if (operand.isHeader())
                             return;
                         // LoadVarargs and ForwardVarargs are unconditional writes to the stack
                         // locations they claim to write to. They do not read from the stack
                         // locations they write to. This makes those stack locations dead right
                         // before a LoadVarargs/ForwardVarargs. This means we should never sink
                         // PutStacks right to this point.
-                        RELEASE_ASSERT(node->op() == LoadVarargs || node->op() == ForwardVarargs);
+                        RELEASE_ASSERT(node->op() == VarargsLength || node->op() == LoadVarargs || node->op() == ForwardVarargs);
                         deferred.operand(operand) = DeadFlush;
                     };
 
                     preciseLocalClobberize(
                         m_graph, node, escapeHandler, writeHandler,
-                        [&] (VirtualRegister, LazyNode) { });
+                        [&] (Operand, LazyNode) { });
                     break;
                 } }
             }
 
             NodeAndIndex terminal = block->findTerminal();
@@ -537,12 +537,12 @@
             NodeOrigin upsilonOrigin = terminal.node->origin;
             for (BasicBlock* successorBlock : block->successors()) {
                 for (SSACalculator::Def* phiDef : ssaCalculator.phisForBlock(successorBlock)) {
                     Node* phiNode = phiDef->value();
                     SSACalculator::Variable* variable = phiDef->variable();
-                    VirtualRegister operand = indexToOperand[variable->index()];
-                    if (DFGPutStackSinkingPhaseInternal::verbose)
+                    Operand operand = indexToOperand[variable->index()];
+                    if (verbose)
                         dataLog("Creating Upsilon for ", operand, " at ", pointerDump(block), "->", pointerDump(successorBlock), "\n");
                     FlushFormat format = deferredAtHead[successorBlock].operand(operand);
                     DFG_ASSERT(m_graph, nullptr, isConcrete(format), format);
                     UseKind useKind = uncheckedUseKindFor(format);
 
@@ -583,11 +583,11 @@
 
                 node->remove(m_graph);
             }
         }
 
-        if (DFGPutStackSinkingPhaseInternal::verbose) {
+        if (verbose) {
             dataLog("Graph after PutStack sinking:\n");
             m_graph.dump();
         }
 
         return true;

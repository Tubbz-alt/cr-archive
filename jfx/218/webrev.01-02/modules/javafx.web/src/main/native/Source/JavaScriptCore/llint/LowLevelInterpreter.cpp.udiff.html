<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LowLevelInterpreter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="LowLevelInterpreter.asm.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LowLevelInterpreter.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LowLevelInterpreter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -142,11 +142,10 @@</span>
      ALWAYS_INLINE intptr_t* ip() const { return bitwise_cast&lt;intptr_t*&gt;(m_value); }
      ALWAYS_INLINE int8_t* i8p() const { return bitwise_cast&lt;int8_t*&gt;(m_value); }
      ALWAYS_INLINE void* vp() const { return bitwise_cast&lt;void*&gt;(m_value); }
      ALWAYS_INLINE const void* cvp() const { return bitwise_cast&lt;const void*&gt;(m_value); }
      ALWAYS_INLINE CallFrame* callFrame() const { return bitwise_cast&lt;CallFrame*&gt;(m_value); }
<span class="udiff-line-removed">-     ALWAYS_INLINE ExecState* execState() const { return bitwise_cast&lt;ExecState*&gt;(m_value); }</span>
      ALWAYS_INLINE const void* instruction() const { return bitwise_cast&lt;const void*&gt;(m_value); }
      ALWAYS_INLINE VM* vm() const { return bitwise_cast&lt;VM*&gt;(m_value); }
      ALWAYS_INLINE JSCell* cell() const { return bitwise_cast&lt;JSCell*&gt;(m_value); }
      ALWAYS_INLINE ProtoCallFrame* protoCallFrame() const { return bitwise_cast&lt;ProtoCallFrame*&gt;(m_value); }
      ALWAYS_INLINE NativeFunction nativeFunc() const { return bitwise_cast&lt;NativeFunction&gt;(m_value); }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -155,11 +154,11 @@</span>
      ALWAYS_INLINE uint64_t u64() const { return m_value; }
      ALWAYS_INLINE EncodedJSValue encodedJSValue() const { return bitwise_cast&lt;EncodedJSValue&gt;(m_value); }
  #endif
      ALWAYS_INLINE Opcode opcode() const { return bitwise_cast&lt;Opcode&gt;(m_value); }
  
<span class="udiff-line-modified-removed">-     operator ExecState*() { return bitwise_cast&lt;ExecState*&gt;(m_value); }</span>
<span class="udiff-line-modified-added">+     operator CallFrame*() { return bitwise_cast&lt;CallFrame*&gt;(m_value); }</span>
      operator const Instruction*() { return bitwise_cast&lt;const Instruction*&gt;(m_value); }
      operator JSCell*() { return bitwise_cast&lt;JSCell*&gt;(m_value); }
      operator ProtoCallFrame*() { return bitwise_cast&lt;ProtoCallFrame*&gt;(m_value); }
      operator Register*() { return bitwise_cast&lt;Register*&gt;(m_value); }
      operator VM*() { return bitwise_cast&lt;VM*&gt;(m_value); }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -279,11 +278,11 @@</span>
  
          // Note: we can only set the exceptionInstructions after we have
          // initialized the opcodeMap above. This is because getCodePtr()
          // can depend on the opcodeMap.
          uint8_t* exceptionInstructions = reinterpret_cast&lt;uint8_t*&gt;(LLInt::exceptionInstructions());
<span class="udiff-line-modified-removed">-         for (int i = 0; i &lt; maxOpcodeLength + 1; ++i)</span>
<span class="udiff-line-modified-added">+         for (unsigned i = 0; i &lt; maxOpcodeLength + 1; ++i)</span>
              exceptionInstructions[i] = llint_throw_from_slow_path_trampoline;
  
          return JSValue();
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -314,12 +313,13 @@</span>
      // 2. 32 bit result values will be in the low 32-bit of t0.
      // 3. 64 bit result values will be in t0.
  
      CLoopRegister t0, t1, t2, t3, t5, sp, cfr, lr, pc;
  #if USE(JSVALUE64)
<span class="udiff-line-modified-removed">-     CLoopRegister pcBase, tagTypeNumber, tagMask;</span>
<span class="udiff-line-modified-added">+     CLoopRegister numberTag, notCellMask;</span>
  #endif
<span class="udiff-line-added">+     CLoopRegister pcBase;</span>
      CLoopRegister metadataTable;
      CLoopDoubleRegister d0, d1;
  
      struct StackPointerScope {
          StackPointerScope(CLoopStack&amp; stack)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -354,12 +354,12 @@</span>
      t2 = protoCallFrame;
  
  #if USE(JSVALUE64)
      // For the ASM llint, JITStubs takes care of this initialization. We do
      // it explicitly here for the C loop:
<span class="udiff-line-modified-removed">-     tagTypeNumber = 0xFFFF000000000000;</span>
<span class="udiff-line-modified-removed">-     tagMask = 0xFFFF000000000002;</span>
<span class="udiff-line-modified-added">+     numberTag = JSValue::NumberTag;</span>
<span class="udiff-line-modified-added">+     notCellMask = JSValue::NotCellMask;</span>
  #endif // USE(JSVALUE64)
  
      // Interpreter variables for value passing between opcodes and/or helpers:
      NativeFunction nativeFunc = nullptr;
      JSValue functionReturnValue;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -381,22 +381,10 @@</span>
  #define RECORD_OPCODE_STATS(__opcode) OpcodeStats::recordInstruction(__opcode)
  #else
  #define RECORD_OPCODE_STATS(__opcode)
  #endif
  
<span class="udiff-line-removed">- #if USE(JSVALUE32_64)</span>
<span class="udiff-line-removed">- #define FETCH_OPCODE() *pc.i8p</span>
<span class="udiff-line-removed">- #else // USE(JSVALUE64)</span>
<span class="udiff-line-removed">- #define FETCH_OPCODE() *bitwise_cast&lt;OpcodeID*&gt;(pcBase.i8p + pc.i)</span>
<span class="udiff-line-removed">- #endif // USE(JSVALUE64)</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- #define NEXT_INSTRUCTION() \</span>
<span class="udiff-line-removed">-     do {                         \</span>
<span class="udiff-line-removed">-         opcode = FETCH_OPCODE(); \</span>
<span class="udiff-line-removed">-         DISPATCH_OPCODE();       \</span>
<span class="udiff-line-removed">-     } while (false)</span>
<span class="udiff-line-removed">- </span>
  #if ENABLE(COMPUTED_GOTO_OPCODES)
  
      //========================================================================
      // Loop dispatch mechanism using computed goto statements:
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -483,11 +471,10 @@</span>
          UNUSED_LABEL(__opcode);
          FOR_EACH_OPCODE_ID(LLINT_OPCODE_ENTRY);
      #undef LLINT_OPCODE_ENTRY
  #endif
  
<span class="udiff-line-removed">-     #undef NEXT_INSTRUCTION</span>
      #undef DEFINE_OPCODE
      #undef CHECK_FOR_TIMEOUT
      #undef CAST
  
      return JSValue(); // to suppress a compiler warning.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -503,11 +490,11 @@</span>
  
  // These are for building an interpreter from generated assembly code:
  #define OFFLINE_ASM_BEGIN   asm (
  #define OFFLINE_ASM_END     );
  
<span class="udiff-line-modified-removed">- #if USE(LLINT_EMBEDDED_OPCODE_ID)</span>
<span class="udiff-line-modified-added">+ #if ENABLE(LLINT_EMBEDDED_OPCODE_ID)</span>
  #define EMBED_OPCODE_ID_IF_NEEDED(__opcode) &quot;.int &quot; __opcode##_value_string &quot;\n&quot;
  #else
  #define EMBED_OPCODE_ID_IF_NEEDED(__opcode)
  #endif
  
</pre>
<center><a href="LowLevelInterpreter.asm.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LowLevelInterpreter.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
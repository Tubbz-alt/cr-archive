<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFragmentContainer.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderFragmentContainer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderFragmentedFlow.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderFragmentContainer.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
104     virtual void adjustFragmentBoundsFromFragmentedFlowPortionRect(LayoutRect&amp; fragmentBounds) const;
105 
106     void addLayoutOverflowForBox(const RenderBox*, const LayoutRect&amp;);
107     void addVisualOverflowForBox(const RenderBox*, const LayoutRect&amp;);
108     LayoutRect layoutOverflowRectForBox(const RenderBox*);
109     LayoutRect visualOverflowRectForBox(const RenderBoxModelObject&amp;);
110     LayoutRect layoutOverflowRectForBoxForPropagation(const RenderBox*);
111     LayoutRect visualOverflowRectForBoxForPropagation(const RenderBoxModelObject&amp;);
112 
113     LayoutRect rectFlowPortionForBox(const RenderBox*, const LayoutRect&amp;) const;
114 
115     void setFragmentObjectsFragmentStyle();
116     void restoreFragmentObjectsOriginalStyle();
117 
118     bool canHaveChildren() const override { return false; }
119     bool canHaveGeneratedChildren() const override { return true; }
120     VisiblePosition positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*) override;
121 
122     virtual void absoluteQuadsForBoxInFragment(Vector&lt;FloatQuad&gt;&amp;, bool*, const RenderBox*, float, float) { }
123 
<span class="line-removed">124     String debugString() const;</span>
<span class="line-removed">125 </span>
126 protected:
127     RenderFragmentContainer(Element&amp;, RenderStyle&amp;&amp;, RenderFragmentedFlow*);
128     RenderFragmentContainer(Document&amp;, RenderStyle&amp;&amp;, RenderFragmentedFlow*);
129 
130     void ensureOverflowForBox(const RenderBox*, RefPtr&lt;RenderOverflow&gt;&amp;, bool);
131 
132     void computePreferredLogicalWidths() override;
133     void computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const override;
134 
135     enum OverflowType {
136         LayoutOverflow = 0,
137         VisualOverflow
138     };
139 
140     LayoutRect overflowRectForFragmentedFlowPortion(const LayoutRect&amp; fragmentedFlowPortionRect, bool isFirstPortion, bool isLastPortion, OverflowType);
141     void repaintFragmentedFlowContentRectangle(const LayoutRect&amp; repaintRect, const LayoutRect&amp; fragmentedFlowPortionRect, const LayoutPoint&amp; fragmentLocation, const LayoutRect* fragmentedFlowPortionClipRect = 0);
142 
143     void computeOverflowFromFragmentedFlow();
144 
145 private:
</pre>
<hr />
<pre>
163     // A RenderBoxFragmentInfo* tells us about any layout information for a RenderBox that
164     // is unique to the fragment. For now it just holds logical width information for RenderBlocks, but eventually
165     // it will also hold a custom style for any box (for fragment styling).
166     typedef HashMap&lt;const RenderBox*, std::unique_ptr&lt;RenderBoxFragmentInfo&gt;&gt; RenderBoxFragmentInfoMap;
167     RenderBoxFragmentInfoMap m_renderBoxFragmentInfo;
168 
169     bool m_isValid : 1;
170 };
171 
172 class CurrentRenderFragmentContainerMaintainer {
173     WTF_MAKE_NONCOPYABLE(CurrentRenderFragmentContainerMaintainer);
174 public:
175     CurrentRenderFragmentContainerMaintainer(RenderFragmentContainer&amp;);
176     ~CurrentRenderFragmentContainerMaintainer();
177 
178     RenderFragmentContainer&amp; fragment() const { return m_fragment; }
179 private:
180     RenderFragmentContainer&amp; m_fragment;
181 };
182 




183 } // namespace WebCore
184 
185 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderFragmentContainer, isRenderFragmentContainer())
</pre>
</td>
<td>
<hr />
<pre>
104     virtual void adjustFragmentBoundsFromFragmentedFlowPortionRect(LayoutRect&amp; fragmentBounds) const;
105 
106     void addLayoutOverflowForBox(const RenderBox*, const LayoutRect&amp;);
107     void addVisualOverflowForBox(const RenderBox*, const LayoutRect&amp;);
108     LayoutRect layoutOverflowRectForBox(const RenderBox*);
109     LayoutRect visualOverflowRectForBox(const RenderBoxModelObject&amp;);
110     LayoutRect layoutOverflowRectForBoxForPropagation(const RenderBox*);
111     LayoutRect visualOverflowRectForBoxForPropagation(const RenderBoxModelObject&amp;);
112 
113     LayoutRect rectFlowPortionForBox(const RenderBox*, const LayoutRect&amp;) const;
114 
115     void setFragmentObjectsFragmentStyle();
116     void restoreFragmentObjectsOriginalStyle();
117 
118     bool canHaveChildren() const override { return false; }
119     bool canHaveGeneratedChildren() const override { return true; }
120     VisiblePosition positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*) override;
121 
122     virtual void absoluteQuadsForBoxInFragment(Vector&lt;FloatQuad&gt;&amp;, bool*, const RenderBox*, float, float) { }
123 


124 protected:
125     RenderFragmentContainer(Element&amp;, RenderStyle&amp;&amp;, RenderFragmentedFlow*);
126     RenderFragmentContainer(Document&amp;, RenderStyle&amp;&amp;, RenderFragmentedFlow*);
127 
128     void ensureOverflowForBox(const RenderBox*, RefPtr&lt;RenderOverflow&gt;&amp;, bool);
129 
130     void computePreferredLogicalWidths() override;
131     void computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const override;
132 
133     enum OverflowType {
134         LayoutOverflow = 0,
135         VisualOverflow
136     };
137 
138     LayoutRect overflowRectForFragmentedFlowPortion(const LayoutRect&amp; fragmentedFlowPortionRect, bool isFirstPortion, bool isLastPortion, OverflowType);
139     void repaintFragmentedFlowContentRectangle(const LayoutRect&amp; repaintRect, const LayoutRect&amp; fragmentedFlowPortionRect, const LayoutPoint&amp; fragmentLocation, const LayoutRect* fragmentedFlowPortionClipRect = 0);
140 
141     void computeOverflowFromFragmentedFlow();
142 
143 private:
</pre>
<hr />
<pre>
161     // A RenderBoxFragmentInfo* tells us about any layout information for a RenderBox that
162     // is unique to the fragment. For now it just holds logical width information for RenderBlocks, but eventually
163     // it will also hold a custom style for any box (for fragment styling).
164     typedef HashMap&lt;const RenderBox*, std::unique_ptr&lt;RenderBoxFragmentInfo&gt;&gt; RenderBoxFragmentInfoMap;
165     RenderBoxFragmentInfoMap m_renderBoxFragmentInfo;
166 
167     bool m_isValid : 1;
168 };
169 
170 class CurrentRenderFragmentContainerMaintainer {
171     WTF_MAKE_NONCOPYABLE(CurrentRenderFragmentContainerMaintainer);
172 public:
173     CurrentRenderFragmentContainerMaintainer(RenderFragmentContainer&amp;);
174     ~CurrentRenderFragmentContainerMaintainer();
175 
176     RenderFragmentContainer&amp; fragment() const { return m_fragment; }
177 private:
178     RenderFragmentContainer&amp; m_fragment;
179 };
180 
<span class="line-added">181 #ifndef NDEBUG</span>
<span class="line-added">182 TextStream&amp; operator&lt;&lt;(TextStream&amp;, const RenderFragmentContainer&amp;);</span>
<span class="line-added">183 #endif</span>
<span class="line-added">184 </span>
185 } // namespace WebCore
186 
187 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderFragmentContainer, isRenderFragmentContainer())
</pre>
</td>
</tr>
</table>
<center><a href="RenderFragmentContainer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderFragmentedFlow.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGCommonData.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGCommonData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGCompilationKey.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGCommonData.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 77         , frameRegisterCount(std::numeric_limits&lt;unsigned&gt;::max())
 78         , requiredRegisterCountForExit(std::numeric_limits&lt;unsigned&gt;::max())
 79     { }
 80     ~CommonData();
 81 
 82     void notifyCompilingStructureTransition(Plan&amp;, CodeBlock*, Node*);
 83     CallSiteIndex addCodeOrigin(CodeOrigin);
 84     CallSiteIndex addUniqueCallSiteIndex(CodeOrigin);
 85     CallSiteIndex lastCallSite() const;
 86 
 87     DisposableCallSiteIndex addDisposableCallSiteIndex(CodeOrigin);
 88     void removeDisposableCallSiteIndex(DisposableCallSiteIndex);
 89 
 90     void shrinkToFit();
 91 
 92     bool invalidate(); // Returns true if we did invalidate, or false if the code block was already invalidated.
 93     bool hasInstalledVMTrapsBreakpoints() const { return isStillValid &amp;&amp; hasVMTrapsBreakpointsInstalled; }
 94     void installVMTrapBreakpoints(CodeBlock* owner);
 95     bool isVMTrapBreakpoint(void* address);
 96 
<span class="line-modified"> 97     CatchEntrypointData* catchOSREntryDataForBytecodeIndex(unsigned bytecodeIndex)</span>
 98     {
<span class="line-modified"> 99         return tryBinarySearch&lt;CatchEntrypointData, unsigned&gt;(</span>
100             catchEntrypoints, catchEntrypoints.size(), bytecodeIndex,
101             [] (const CatchEntrypointData* item) { return item-&gt;bytecodeIndex; });
102     }
103 
<span class="line-modified">104     void appendCatchEntrypoint(unsigned bytecodeIndex, MacroAssemblerCodePtr&lt;ExceptionHandlerPtrTag&gt; machineCode, Vector&lt;FlushFormat&gt;&amp;&amp; argumentFormats)</span>
105     {
106         catchEntrypoints.append(CatchEntrypointData { machineCode,  WTFMove(argumentFormats), bytecodeIndex });
107     }
108 
109     void finalizeCatchEntrypoints();
110 
111     unsigned requiredRegisterCountForExecutionAndExit() const
112     {
113         return std::max(frameRegisterCount, requiredRegisterCountForExit);
114     }
115 
116     void validateReferences(const TrackedReferences&amp;);
117 
118     static ptrdiff_t frameRegisterCountOffset() { return OBJECT_OFFSETOF(CommonData, frameRegisterCount); }
119 
120     void clearWatchpoints();
121 
122     RefPtr&lt;InlineCallFrameSet&gt; inlineCallFrames;
123     Vector&lt;CodeOrigin, 0, UnsafeVectorOverflow&gt; codeOrigins;
124 
125     Vector&lt;Identifier&gt; dfgIdentifiers;
126     Vector&lt;WeakReferenceTransition&gt; transitions;
127     Vector&lt;WriteBarrier&lt;JSCell&gt;&gt; weakReferences;
<span class="line-modified">128     Vector&lt;WriteBarrier&lt;Structure&gt;&gt; weakStructureReferences;</span>
129     Vector&lt;CatchEntrypointData&gt; catchEntrypoints;
130     Bag&lt;CodeBlockJettisoningWatchpoint&gt; watchpoints;
131     Bag&lt;AdaptiveStructureWatchpoint&gt; adaptiveStructureWatchpoints;
132     Bag&lt;AdaptiveInferredPropertyValueWatchpoint&gt; adaptiveInferredPropertyValueWatchpoints;
133     RecordedStatuses recordedStatuses;
134     Vector&lt;JumpReplacement&gt; jumpReplacements;
135 
136     ScratchBuffer* catchOSREntryBuffer;
137     RefPtr&lt;Profiler::Compilation&gt; compilation;
138     bool livenessHasBeenProved; // Initialized and used on every GC.
139     bool allTransitionsHaveBeenMarked; // Initialized and used on every GC.
140     bool isStillValid;
141     bool hasVMTrapsBreakpointsInstalled { false };
142 
143 #if USE(JSVALUE32_64)
144     std::unique_ptr&lt;Bag&lt;double&gt;&gt; doubleConstants;
145 #endif
146 
147     unsigned frameRegisterCount;
148     unsigned requiredRegisterCountForExit;
</pre>
</td>
<td>
<hr />
<pre>
 77         , frameRegisterCount(std::numeric_limits&lt;unsigned&gt;::max())
 78         , requiredRegisterCountForExit(std::numeric_limits&lt;unsigned&gt;::max())
 79     { }
 80     ~CommonData();
 81 
 82     void notifyCompilingStructureTransition(Plan&amp;, CodeBlock*, Node*);
 83     CallSiteIndex addCodeOrigin(CodeOrigin);
 84     CallSiteIndex addUniqueCallSiteIndex(CodeOrigin);
 85     CallSiteIndex lastCallSite() const;
 86 
 87     DisposableCallSiteIndex addDisposableCallSiteIndex(CodeOrigin);
 88     void removeDisposableCallSiteIndex(DisposableCallSiteIndex);
 89 
 90     void shrinkToFit();
 91 
 92     bool invalidate(); // Returns true if we did invalidate, or false if the code block was already invalidated.
 93     bool hasInstalledVMTrapsBreakpoints() const { return isStillValid &amp;&amp; hasVMTrapsBreakpointsInstalled; }
 94     void installVMTrapBreakpoints(CodeBlock* owner);
 95     bool isVMTrapBreakpoint(void* address);
 96 
<span class="line-modified"> 97     CatchEntrypointData* catchOSREntryDataForBytecodeIndex(BytecodeIndex bytecodeIndex)</span>
 98     {
<span class="line-modified"> 99         return tryBinarySearch&lt;CatchEntrypointData, BytecodeIndex&gt;(</span>
100             catchEntrypoints, catchEntrypoints.size(), bytecodeIndex,
101             [] (const CatchEntrypointData* item) { return item-&gt;bytecodeIndex; });
102     }
103 
<span class="line-modified">104     void appendCatchEntrypoint(BytecodeIndex bytecodeIndex, MacroAssemblerCodePtr&lt;ExceptionHandlerPtrTag&gt; machineCode, Vector&lt;FlushFormat&gt;&amp;&amp; argumentFormats)</span>
105     {
106         catchEntrypoints.append(CatchEntrypointData { machineCode,  WTFMove(argumentFormats), bytecodeIndex });
107     }
108 
109     void finalizeCatchEntrypoints();
110 
111     unsigned requiredRegisterCountForExecutionAndExit() const
112     {
113         return std::max(frameRegisterCount, requiredRegisterCountForExit);
114     }
115 
116     void validateReferences(const TrackedReferences&amp;);
117 
118     static ptrdiff_t frameRegisterCountOffset() { return OBJECT_OFFSETOF(CommonData, frameRegisterCount); }
119 
120     void clearWatchpoints();
121 
122     RefPtr&lt;InlineCallFrameSet&gt; inlineCallFrames;
123     Vector&lt;CodeOrigin, 0, UnsafeVectorOverflow&gt; codeOrigins;
124 
125     Vector&lt;Identifier&gt; dfgIdentifiers;
126     Vector&lt;WeakReferenceTransition&gt; transitions;
127     Vector&lt;WriteBarrier&lt;JSCell&gt;&gt; weakReferences;
<span class="line-modified">128     Vector&lt;StructureID&gt; weakStructureReferences;</span>
129     Vector&lt;CatchEntrypointData&gt; catchEntrypoints;
130     Bag&lt;CodeBlockJettisoningWatchpoint&gt; watchpoints;
131     Bag&lt;AdaptiveStructureWatchpoint&gt; adaptiveStructureWatchpoints;
132     Bag&lt;AdaptiveInferredPropertyValueWatchpoint&gt; adaptiveInferredPropertyValueWatchpoints;
133     RecordedStatuses recordedStatuses;
134     Vector&lt;JumpReplacement&gt; jumpReplacements;
135 
136     ScratchBuffer* catchOSREntryBuffer;
137     RefPtr&lt;Profiler::Compilation&gt; compilation;
138     bool livenessHasBeenProved; // Initialized and used on every GC.
139     bool allTransitionsHaveBeenMarked; // Initialized and used on every GC.
140     bool isStillValid;
141     bool hasVMTrapsBreakpointsInstalled { false };
142 
143 #if USE(JSVALUE32_64)
144     std::unique_ptr&lt;Bag&lt;double&gt;&gt; doubleConstants;
145 #endif
146 
147     unsigned frameRegisterCount;
148     unsigned requiredRegisterCountForExit;
</pre>
</td>
</tr>
</table>
<center><a href="DFGCommonData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGCompilationKey.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
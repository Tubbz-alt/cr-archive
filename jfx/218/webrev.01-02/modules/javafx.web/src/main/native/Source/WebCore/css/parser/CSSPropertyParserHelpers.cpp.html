<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSPropertyParserHelpers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Copyright 2016 The Chromium Authors. All rights reserved.
   2 // Copyright (C) 2016 Apple Inc. All rights reserved.
   3 //
   4 // Redistribution and use in source and binary forms, with or without
   5 // modification, are permitted provided that the following conditions are
   6 // met:
   7 //
   8 //    * Redistributions of source code must retain the above copyright
   9 // notice, this list of conditions and the following disclaimer.
  10 //    * Redistributions in binary form must reproduce the above
  11 // copyright notice, this list of conditions and the following disclaimer
  12 // in the documentation and/or other materials provided with the
  13 // distribution.
  14 //    * Neither the name of Google Inc. nor the names of its
  15 // contributors may be used to endorse or promote products derived from
  16 // this software without specific prior written permission.
  17 //
  18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;CSSPropertyParserHelpers.h&quot;
  32 
  33 #include &quot;CSSCalculationValue.h&quot;
  34 #include &quot;CSSCanvasValue.h&quot;
  35 #include &quot;CSSCrossfadeValue.h&quot;
  36 #include &quot;CSSFilterImageValue.h&quot;
  37 #include &quot;CSSGradientValue.h&quot;
  38 #include &quot;CSSImageSetValue.h&quot;
  39 #include &quot;CSSImageValue.h&quot;
  40 #include &quot;CSSNamedImageValue.h&quot;
  41 #include &quot;CSSPaintImageValue.h&quot;
  42 #include &quot;CSSParserIdioms.h&quot;
  43 #include &quot;CSSValuePool.h&quot;
  44 #include &quot;Pair.h&quot;
  45 #include &quot;RuntimeEnabledFeatures.h&quot;
  46 #include &quot;StyleColor.h&quot;
  47 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  48 
  49 namespace WebCore {
  50 
  51 namespace CSSPropertyParserHelpers {
  52 
  53 bool consumeCommaIncludingWhitespace(CSSParserTokenRange&amp; range)
  54 {
  55     CSSParserToken value = range.peek();
  56     if (value.type() != CommaToken)
  57         return false;
  58     range.consumeIncludingWhitespace();
  59     return true;
  60 }
  61 
  62 bool consumeSlashIncludingWhitespace(CSSParserTokenRange&amp; range)
  63 {
  64     CSSParserToken value = range.peek();
  65     if (value.type() != DelimiterToken || value.delimiter() != &#39;/&#39;)
  66         return false;
  67     range.consumeIncludingWhitespace();
  68     return true;
  69 }
  70 
  71 CSSParserTokenRange consumeFunction(CSSParserTokenRange&amp; range)
  72 {
  73     ASSERT(range.peek().type() == FunctionToken);
  74     CSSParserTokenRange contents = range.consumeBlock();
  75     range.consumeWhitespace();
  76     contents.consumeWhitespace();
  77     return contents;
  78 }
  79 
  80 // FIXME: consider pulling in the parsing logic from CSSCalculationValue.cpp.
  81 class CalcParser {
  82 public:
  83     explicit CalcParser(CSSParserTokenRange&amp; range, CalculationCategory destinationCategory, ValueRange valueRange = ValueRangeAll)
  84         : m_sourceRange(range)
  85         , m_range(range)
  86     {
  87         const CSSParserToken&amp; token = range.peek();
  88         auto functionId = token.functionId();
  89         if (CSSCalcValue::isCalcFunction(functionId))
  90             m_calcValue = CSSCalcValue::create(functionId, consumeFunction(m_range), destinationCategory, valueRange);
  91     }
  92 
  93     const CSSCalcValue* value() const { return m_calcValue.get(); }
  94 
  95     RefPtr&lt;CSSPrimitiveValue&gt; consumeValue()
  96     {
  97         if (!m_calcValue)
  98             return nullptr;
  99         m_sourceRange = m_range;
 100         return CSSValuePool::singleton().createValue(WTFMove(m_calcValue));
 101     }
 102 
 103     RefPtr&lt;CSSPrimitiveValue&gt; consumeInteger(double minimumValue)
 104     {
 105         if (!m_calcValue)
 106             return nullptr;
 107         m_sourceRange = m_range;
 108         double value = std::max(m_calcValue-&gt;doubleValue(), minimumValue);
 109         value = std::round(value);
 110         return CSSValuePool::singleton().createValue(value, CSSUnitType::CSS_NUMBER);
 111     }
 112 
 113     RefPtr&lt;CSSPrimitiveValue&gt; consumeNumber()
 114     {
 115         if (!m_calcValue)
 116             return nullptr;
 117         m_sourceRange = m_range;
 118         return CSSValuePool::singleton().createValue(m_calcValue-&gt;doubleValue(), CSSUnitType::CSS_NUMBER);
 119     }
 120 
 121     bool consumeNumberRaw(double&amp; result)
 122     {
 123         if (!m_calcValue || m_calcValue-&gt;category() != CalculationCategory::Number)
 124             return false;
 125         m_sourceRange = m_range;
 126         result = m_calcValue-&gt;doubleValue();
 127         return true;
 128     }
 129 
 130 private:
 131     CSSParserTokenRange&amp; m_sourceRange;
 132     CSSParserTokenRange m_range;
 133     RefPtr&lt;CSSCalcValue&gt; m_calcValue;
 134 };
 135 
 136 RefPtr&lt;CSSPrimitiveValue&gt; consumeInteger(CSSParserTokenRange&amp; range, double minimumValue)
 137 {
 138     const CSSParserToken&amp; token = range.peek();
 139     if (token.type() == NumberToken) {
 140         if (token.numericValueType() == NumberValueType || token.numericValue() &lt; minimumValue)
 141             return nullptr;
 142         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), CSSUnitType::CSS_NUMBER);
 143     }
 144 
 145     if (token.type() != FunctionToken)
 146         return nullptr;
 147 
 148     CalcParser calcParser(range, CalculationCategory::Number);
 149     if (const CSSCalcValue* calculation = calcParser.value()) {
 150         if (calculation-&gt;category() != CalculationCategory::Number)
 151             return nullptr;
 152         return calcParser.consumeInteger(minimumValue);
 153     }
 154 
 155     return nullptr;
 156 }
 157 
 158 RefPtr&lt;CSSPrimitiveValue&gt; consumePositiveInteger(CSSParserTokenRange&amp; range)
 159 {
 160     return consumeInteger(range, 1);
 161 }
 162 
 163 bool consumeNumberRaw(CSSParserTokenRange&amp; range, double&amp; result)
 164 {
 165     const CSSParserToken&amp; token = range.peek();
 166     if (token.type() == NumberToken) {
 167         result = range.consumeIncludingWhitespace().numericValue();
 168         return true;
 169     }
 170 
 171     if (token.type() != FunctionToken)
 172         return false;
 173 
 174     CalcParser calcParser(range, CalculationCategory::Number, ValueRangeAll);
 175     return calcParser.consumeNumberRaw(result);
 176 }
 177 
 178 // FIXME: Work out if this can just call consumeNumberRaw
 179 RefPtr&lt;CSSPrimitiveValue&gt; consumeNumber(CSSParserTokenRange&amp; range, ValueRange valueRange)
 180 {
 181     const CSSParserToken&amp; token = range.peek();
 182     if (token.type() == NumberToken) {
 183         if (valueRange == ValueRangeNonNegative &amp;&amp; token.numericValue() &lt; 0)
 184             return nullptr;
 185         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), token.unitType());
 186     }
 187 
 188     if (token.type() != FunctionToken)
 189         return nullptr;
 190 
 191     CalcParser calcParser(range, CalculationCategory::Number, valueRange);
 192     if (const CSSCalcValue* calcValue = calcParser.value()) {
 193         if (calcValue-&gt;category() != CalculationCategory::Number)
 194             return nullptr;
 195         return calcParser.consumeValue();
 196     }
 197 
 198     return nullptr;
 199 }
 200 
 201 #if !ENABLE(VARIATION_FONTS)
 202 static inline bool divisibleBy100(double value)
 203 {
 204     return static_cast&lt;int&gt;(value / 100) * 100 == value;
 205 }
 206 #endif
 207 
 208 RefPtr&lt;CSSPrimitiveValue&gt; consumeFontWeightNumber(CSSParserTokenRange&amp; range)
 209 {
 210     // Values less than or equal to 0 or greater than or equal to 1000 are parse errors.
 211     auto&amp; token = range.peek();
 212     if (token.type() == NumberToken &amp;&amp; token.numericValue() &gt;= 1 &amp;&amp; token.numericValue() &lt;= 1000
 213 #if !ENABLE(VARIATION_FONTS)
 214         &amp;&amp; token.numericValueType() == IntegerValueType &amp;&amp; divisibleBy100(token.numericValue())
 215 #endif
 216     )
 217         return consumeNumber(range, ValueRangeAll);
 218 
 219     if (token.type() != FunctionToken)
 220         return nullptr;
 221 
 222     // &quot;[For calc()], the used value resulting from an expression must be clamped to the range allowed in the target context.&quot;
 223     CalcParser calcParser(range, CalculationCategory::Number, ValueRangeAll);
 224     double result;
 225     if (calcParser.consumeNumberRaw(result)
 226 #if !ENABLE(VARIATION_FONTS)
 227         &amp;&amp; result &gt; 0 &amp;&amp; result &lt; 1000 &amp;&amp; divisibleBy100(result)
 228 #endif
 229     ) {
 230         result = std::min(std::max(result, std::nextafter(0., 1.)), std::nextafter(1000., 0.));
 231         return CSSValuePool::singleton().createValue(result, CSSUnitType::CSS_NUMBER);
 232     }
 233 
 234     return nullptr;
 235 }
 236 
 237 inline bool shouldAcceptUnitlessValue(double value, CSSParserMode cssParserMode, UnitlessQuirk unitless)
 238 {
 239     // FIXME: Presentational HTML attributes shouldn&#39;t use the CSS parser for lengths
 240     return value == 0
 241         || isUnitLessValueParsingEnabledForMode(cssParserMode)
 242         || (cssParserMode == HTMLQuirksMode &amp;&amp; unitless == UnitlessQuirk::Allow);
 243 }
 244 
 245 RefPtr&lt;CSSPrimitiveValue&gt; consumeLength(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, ValueRange valueRange, UnitlessQuirk unitless)
 246 {
 247     const CSSParserToken&amp; token = range.peek();
 248     if (token.type() == DimensionToken) {
 249         switch (token.unitType()) {
 250         case CSSUnitType::CSS_QUIRKY_EMS:
 251             if (cssParserMode != UASheetMode)
 252                 return nullptr;
 253             FALLTHROUGH;
 254         case CSSUnitType::CSS_EMS:
 255         case CSSUnitType::CSS_REMS:
 256         case CSSUnitType::CSS_CHS:
 257         case CSSUnitType::CSS_EXS:
 258         case CSSUnitType::CSS_PX:
 259         case CSSUnitType::CSS_CM:
 260         case CSSUnitType::CSS_MM:
 261         case CSSUnitType::CSS_IN:
 262         case CSSUnitType::CSS_PT:
 263         case CSSUnitType::CSS_PC:
 264         case CSSUnitType::CSS_VW:
 265         case CSSUnitType::CSS_VH:
 266         case CSSUnitType::CSS_VMIN:
 267         case CSSUnitType::CSS_VMAX:
 268         case CSSUnitType::CSS_Q:
 269             break;
 270         default:
 271             return nullptr;
 272         }
 273         if ((valueRange == ValueRangeNonNegative &amp;&amp; token.numericValue() &lt; 0) || std::isinf(token.numericValue()))
 274             return nullptr;
 275         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), token.unitType());
 276     }
 277     if (token.type() == NumberToken) {
 278         if (!shouldAcceptUnitlessValue(token.numericValue(), cssParserMode, unitless)
 279             || (valueRange == ValueRangeNonNegative &amp;&amp; token.numericValue() &lt; 0))
 280             return nullptr;
 281         if (std::isinf(token.numericValue()))
 282             return nullptr;
 283         CSSUnitType unitType = CSSUnitType::CSS_PX;
 284         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), unitType);
 285     }
 286 
 287     if (token.type() != FunctionToken)
 288         return nullptr;
 289 
 290     CalcParser calcParser(range, CalculationCategory::Length, valueRange);
 291     if (calcParser.value() &amp;&amp; calcParser.value()-&gt;category() == CalculationCategory::Length)
 292         return calcParser.consumeValue();
 293 
 294     return nullptr;
 295 }
 296 
 297 RefPtr&lt;CSSPrimitiveValue&gt; consumePercent(CSSParserTokenRange&amp; range, ValueRange valueRange)
 298 {
 299     const CSSParserToken&amp; token = range.peek();
 300     if (token.type() == PercentageToken) {
 301         if ((valueRange == ValueRangeNonNegative &amp;&amp; token.numericValue() &lt; 0) || std::isinf(token.numericValue()))
 302             return nullptr;
 303         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), CSSUnitType::CSS_PERCENTAGE);
 304     }
 305 
 306     if (token.type() != FunctionToken)
 307         return nullptr;
 308 
 309     CalcParser calcParser(range, CalculationCategory::Percent, valueRange);
 310     if (const CSSCalcValue* calculation = calcParser.value()) {
 311         if (calculation-&gt;category() == CalculationCategory::Percent)
 312             return calcParser.consumeValue();
 313     }
 314     return nullptr;
 315 }
 316 
 317 static bool canConsumeCalcValue(CalculationCategory category, CSSParserMode cssParserMode)
 318 {
 319     if (category == CalculationCategory::Length || category == CalculationCategory::Percent || category == CalculationCategory::PercentLength)
 320         return true;
 321 
 322     if (cssParserMode != SVGAttributeMode)
 323         return false;
 324 
 325     if (category == CalculationCategory::Number || category == CalculationCategory::PercentNumber)
 326         return true;
 327 
 328     return false;
 329 }
 330 
 331 RefPtr&lt;CSSPrimitiveValue&gt; consumeLengthOrPercent(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, ValueRange valueRange, UnitlessQuirk unitless)
 332 {
 333     const CSSParserToken&amp; token = range.peek();
 334     if (token.type() == DimensionToken || token.type() == NumberToken)
 335         return consumeLength(range, cssParserMode, valueRange, unitless);
 336     if (token.type() == PercentageToken)
 337         return consumePercent(range, valueRange);
 338 
 339     if (token.type() != FunctionToken)
 340         return nullptr;
 341 
 342     CalcParser calcParser(range, CalculationCategory::Length, valueRange);
 343     if (const CSSCalcValue* calculation = calcParser.value()) {
 344         if (canConsumeCalcValue(calculation-&gt;category(), cssParserMode))
 345             return calcParser.consumeValue();
 346     }
 347     return nullptr;
 348 }
 349 
 350 RefPtr&lt;CSSPrimitiveValue&gt; consumeAngle(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless)
 351 {
 352     const CSSParserToken&amp; token = range.peek();
 353     if (token.type() == DimensionToken) {
 354         switch (token.unitType()) {
 355         case CSSUnitType::CSS_DEG:
 356         case CSSUnitType::CSS_RAD:
 357         case CSSUnitType::CSS_GRAD:
 358         case CSSUnitType::CSS_TURN:
 359             return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), token.unitType());
 360         default:
 361             return nullptr;
 362         }
 363     }
 364 
 365     if (token.type() == NumberToken &amp;&amp; shouldAcceptUnitlessValue(token.numericValue(), cssParserMode, unitless))
 366         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), CSSUnitType::CSS_DEG);
 367 
 368     if (token.type() != FunctionToken)
 369         return nullptr;
 370 
 371     CalcParser calcParser(range, CalculationCategory::Angle, ValueRangeAll);
 372     if (const CSSCalcValue* calculation = calcParser.value()) {
 373         if (calculation-&gt;category() == CalculationCategory::Angle)
 374             return calcParser.consumeValue();
 375     }
 376     return nullptr;
 377 }
 378 
 379 static RefPtr&lt;CSSPrimitiveValue&gt; consumeAngleOrPercent(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, ValueRange valueRange, UnitlessQuirk unitless)
 380 {
 381     const CSSParserToken&amp; token = range.peek();
 382     if (token.type() == DimensionToken) {
 383         switch (token.unitType()) {
 384         case CSSUnitType::CSS_DEG:
 385         case CSSUnitType::CSS_RAD:
 386         case CSSUnitType::CSS_GRAD:
 387         case CSSUnitType::CSS_TURN:
 388             return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), token.unitType());
 389         default:
 390             return nullptr;
 391         }
 392     }
 393     if (token.type() == NumberToken &amp;&amp; shouldAcceptUnitlessValue(token.numericValue(), cssParserMode, unitless))
 394         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), CSSUnitType::CSS_DEG);
 395 
 396     if (token.type() == PercentageToken)
 397         return consumePercent(range, valueRange);
 398 
 399      if (token.type() != FunctionToken)
 400          return nullptr;
 401 
 402     CalcParser angleCalcParser(range, CalculationCategory::Angle, valueRange);
 403     if (const CSSCalcValue* calculation = angleCalcParser.value()) {
 404         if (calculation-&gt;category() == CalculationCategory::Angle)
 405             return angleCalcParser.consumeValue();
 406     }
 407 
 408     CalcParser percentCalcParser(range, CalculationCategory::Percent, valueRange);
 409     if (const CSSCalcValue* calculation = percentCalcParser.value()) {
 410         if (calculation-&gt;category() == CalculationCategory::Percent)
 411             return percentCalcParser.consumeValue();
 412     }
 413     return nullptr;
 414 }
 415 
 416 RefPtr&lt;CSSPrimitiveValue&gt; consumeTime(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, ValueRange valueRange, UnitlessQuirk unitless)
 417 {
 418     const CSSParserToken&amp; token = range.peek();
 419     CSSUnitType unit = token.unitType();
 420     bool acceptUnitless = token.type() == NumberToken &amp;&amp; unitless == UnitlessQuirk::Allow &amp;&amp; shouldAcceptUnitlessValue(token.numericValue(), cssParserMode, unitless);
 421     if (acceptUnitless)
 422         unit = CSSUnitType::CSS_MS;
 423     if (token.type() == DimensionToken || acceptUnitless) {
 424         if (valueRange == ValueRangeNonNegative &amp;&amp; token.numericValue() &lt; 0)
 425             return nullptr;
 426         if (unit == CSSUnitType::CSS_MS || unit == CSSUnitType::CSS_S)
 427             return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), unit);
 428         return nullptr;
 429     }
 430 
 431     if (token.type() != FunctionToken)
 432         return nullptr;
 433 
 434     CalcParser calcParser(range, CalculationCategory::Time, valueRange);
 435     if (const CSSCalcValue* calculation = calcParser.value()) {
 436         if (calculation-&gt;category() == CalculationCategory::Time)
 437             return calcParser.consumeValue();
 438     }
 439     return nullptr;
 440 }
 441 
 442 RefPtr&lt;CSSPrimitiveValue&gt; consumeResolution(CSSParserTokenRange&amp; range, AllowXResolutionUnit allowX)
 443 {
 444     const CSSParserToken&amp; token = range.peek();
 445     // Unlike the other types, calc() does not work with &lt;resolution&gt;.
 446     if (token.type() != DimensionToken)
 447         return nullptr;
 448     CSSUnitType unit = token.unitType();
 449     if (unit == CSSUnitType::CSS_DPPX || unit == CSSUnitType::CSS_DPI || unit == CSSUnitType::CSS_DPCM)
 450         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), unit);
 451     if (allowX == AllowXResolutionUnit::Allow &amp;&amp; token.value() == &quot;x&quot;)
 452         return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().numericValue(), CSSUnitType::CSS_DPPX);
 453 
 454     return nullptr;
 455 }
 456 
 457 RefPtr&lt;CSSPrimitiveValue&gt; consumeIdent(CSSParserTokenRange&amp; range)
 458 {
 459     if (range.peek().type() != IdentToken)
 460         return nullptr;
 461     return CSSValuePool::singleton().createIdentifierValue(range.consumeIncludingWhitespace().id());
 462 }
 463 
 464 RefPtr&lt;CSSPrimitiveValue&gt; consumeIdentRange(CSSParserTokenRange&amp; range, CSSValueID lower, CSSValueID upper)
 465 {
 466     if (range.peek().id() &lt; lower || range.peek().id() &gt; upper)
 467         return nullptr;
 468     return consumeIdent(range);
 469 }
 470 
 471 // FIXME-NEWPARSER: Eventually we&#39;d like this to use CSSCustomIdentValue, but we need
 472 // to do other plumbing work first (like changing Pair to CSSValuePair and make it not
 473 // use only primitive values).
 474 RefPtr&lt;CSSPrimitiveValue&gt; consumeCustomIdent(CSSParserTokenRange&amp; range)
 475 {
 476     if (range.peek().type() != IdentToken || isCSSWideKeyword(range.peek().id()))
 477         return nullptr;
 478     return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().value().toString(), CSSUnitType::CSS_STRING);
 479 }
 480 
 481 RefPtr&lt;CSSPrimitiveValue&gt; consumeString(CSSParserTokenRange&amp; range)
 482 {
 483     if (range.peek().type() != StringToken)
 484         return nullptr;
 485     return CSSValuePool::singleton().createValue(range.consumeIncludingWhitespace().value().toString(), CSSUnitType::CSS_STRING);
 486 }
 487 
 488 StringView consumeUrlAsStringView(CSSParserTokenRange&amp; range)
 489 {
 490     const CSSParserToken&amp; token = range.peek();
 491     if (token.type() == UrlToken) {
 492         range.consumeIncludingWhitespace();
 493         return token.value();
 494     }
 495     if (token.functionId() == CSSValueUrl) {
 496         CSSParserTokenRange urlRange = range;
 497         CSSParserTokenRange urlArgs = urlRange.consumeBlock();
 498         const CSSParserToken&amp; next = urlArgs.consumeIncludingWhitespace();
 499         if (next.type() == BadStringToken || !urlArgs.atEnd())
 500             return StringView();
 501         ASSERT(next.type() == StringToken);
 502         range = urlRange;
 503         range.consumeWhitespace();
 504         return next.value();
 505     }
 506 
 507     return StringView();
 508 }
 509 
 510 RefPtr&lt;CSSPrimitiveValue&gt; consumeUrl(CSSParserTokenRange&amp; range)
 511 {
 512     StringView url = consumeUrlAsStringView(range);
 513     if (url.isNull())
 514         return nullptr;
 515     return CSSValuePool::singleton().createValue(url.toString(), CSSUnitType::CSS_URI);
 516 }
 517 
 518 static int clampRGBComponent(const CSSPrimitiveValue&amp; value)
 519 {
 520     double result = value.doubleValue();
 521     if (value.isPercentage())
 522         result = result / 100.0 * 255.0;
 523 
 524     return clampTo&lt;int&gt;(round(result), 0, 255);
 525 }
 526 
 527 static Color parseRGBParameters(CSSParserTokenRange&amp; range)
 528 {
 529     ASSERT(range.peek().functionId() == CSSValueRgb || range.peek().functionId() == CSSValueRgba);
 530     Color result;
 531     CSSParserTokenRange args = consumeFunction(range);
 532     RefPtr&lt;CSSPrimitiveValue&gt; colorParameter = consumeNumber(args, ValueRangeAll);
 533     if (!colorParameter)
 534         colorParameter = consumePercent(args, ValueRangeAll);
 535     if (!colorParameter)
 536         return Color();
 537 
 538     const bool isPercent = colorParameter-&gt;isPercentage();
 539 
 540     enum class ColorSyntax {
 541         Commas,
 542         WhitespaceSlash,
 543     };
 544 
 545     ColorSyntax syntax = ColorSyntax::Commas;
 546     auto consumeSeparator = [&amp;] {
 547         if (syntax == ColorSyntax::Commas)
 548             return consumeCommaIncludingWhitespace(args);
 549 
 550         return true;
 551     };
 552 
 553     int colorArray[3];
 554     colorArray[0] = clampRGBComponent(*colorParameter);
 555     for (int i = 1; i &lt; 3; i++) {
 556         if (i == 1)
 557             syntax = consumeCommaIncludingWhitespace(args) ? ColorSyntax::Commas : ColorSyntax::WhitespaceSlash;
 558         else if (!consumeSeparator())
 559             return Color();
 560 
 561         colorParameter = isPercent ? consumePercent(args, ValueRangeAll) : consumeNumber(args, ValueRangeAll);
 562         if (!colorParameter)
 563             return Color();
 564         colorArray[i] = clampRGBComponent(*colorParameter);
 565     }
 566 
 567     // Historically, alpha was only parsed for rgba(), but css-color-4 specifies that rgba() is a simple alias for rgb().
 568     auto consumeAlphaSeparator = [&amp;] {
 569         if (syntax == ColorSyntax::Commas)
 570             return consumeCommaIncludingWhitespace(args);
 571 
 572         return consumeSlashIncludingWhitespace(args);
 573     };
 574 
 575     int alphaComponent = 255;
 576     if (consumeAlphaSeparator()) {
 577         double alpha;
 578         if (!consumeNumberRaw(args, alpha)) {
 579             auto alphaPercent = consumePercent(args, ValueRangeAll);
 580             if (!alphaPercent)
 581                 return Color();
 582             alpha = alphaPercent-&gt;doubleValue() / 100.0;
 583         }
 584 
 585         // W3 standard stipulates a 2.55 alpha value multiplication factor.
 586         alphaComponent = static_cast&lt;int&gt;(lroundf(clampTo&lt;double&gt;(alpha, 0.0, 1.0) * 255.0f));
 587     };
 588 
 589     result = Color(makeRGBA(colorArray[0], colorArray[1], colorArray[2], alphaComponent));
 590 
 591     if (!args.atEnd())
 592         return Color();
 593 
 594     return result;
 595 }
 596 
 597 static Color parseHSLParameters(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
 598 {
 599     ASSERT(range.peek().functionId() == CSSValueHsl || range.peek().functionId() == CSSValueHsla);
 600     CSSParserTokenRange args = consumeFunction(range);
 601     auto hslValue = consumeAngle(args, cssParserMode, UnitlessQuirk::Forbid);
 602     double angleInDegrees;
 603     if (!hslValue) {
 604         hslValue = consumeNumber(args, ValueRangeAll);
 605         if (!hslValue)
 606             return Color();
 607         angleInDegrees = hslValue-&gt;doubleValue();
 608     } else
 609         angleInDegrees = hslValue-&gt;computeDegrees();
 610 
 611     double colorArray[3];
 612     colorArray[0] = fmod(fmod(angleInDegrees, 360.0) + 360.0, 360.0) / 360.0;
 613     bool requiresCommas = false;
 614     for (int i = 1; i &lt; 3; i++) {
 615         if (consumeCommaIncludingWhitespace(args)) {
 616             if (i != 1 &amp;&amp; !requiresCommas)
 617                 return Color();
 618             requiresCommas = true;
 619         } else if (requiresCommas || args.atEnd() || (&amp;args.peek() - 1)-&gt;type() != WhitespaceToken)
 620             return Color();
 621         hslValue = consumePercent(args, ValueRangeAll);
 622         if (!hslValue)
 623             return Color();
 624         double doubleValue = hslValue-&gt;doubleValue();
 625         colorArray[i] = clampTo&lt;double&gt;(doubleValue, 0.0, 100.0) / 100.0; // Needs to be value between 0 and 1.0.
 626     }
 627 
 628     double alpha = 1.0;
 629     bool commaConsumed = consumeCommaIncludingWhitespace(args);
 630     bool slashConsumed = consumeSlashIncludingWhitespace(args);
 631     if ((commaConsumed &amp;&amp; !requiresCommas) || (slashConsumed &amp;&amp; requiresCommas))
 632         return Color();
 633     if (commaConsumed || slashConsumed) {
 634         if (!consumeNumberRaw(args, alpha)) {
 635             auto alphaPercent = consumePercent(args, ValueRangeAll);
 636             if (!alphaPercent)
 637                 return Color();
 638             alpha = alphaPercent-&gt;doubleValue() / 100.0f;
 639         }
 640         alpha = clampTo&lt;double&gt;(alpha, 0.0, 1.0);
 641     }
 642 
 643     if (!args.atEnd())
 644         return Color();
 645 
 646     return Color(makeRGBAFromHSLA(static_cast&lt;float&gt;(colorArray[0]), static_cast&lt;float&gt;(colorArray[1]), static_cast&lt;float&gt;(colorArray[2]), static_cast&lt;float&gt;(alpha)));
 647 }
 648 
 649 static Color parseColorFunctionParameters(CSSParserTokenRange&amp; range)
 650 {
 651     ASSERT(range.peek().functionId() == CSSValueColor);
 652     CSSParserTokenRange args = consumeFunction(range);
 653 
 654     ColorSpace colorSpace;
 655     switch (args.peek().id()) {
 656     case CSSValueSRGB:
 657         colorSpace = ColorSpace::SRGB;
 658         break;
 659     case CSSValueDisplayP3:
 660         colorSpace = ColorSpace::DisplayP3;
 661         break;
 662     default:
 663         return Color();
 664     }
 665     consumeIdent(args);
 666 
 667     double colorChannels[4] = { 0, 0, 0, 1 };
 668     for (int i = 0; i &lt; 3; ++i) {
 669         double value;
 670         if (consumeNumberRaw(args, value))
 671             colorChannels[i] = std::max(0.0, std::min(1.0, value));
 672         else
 673             break;
 674     }
 675 
 676     if (consumeSlashIncludingWhitespace(args)) {
 677         auto alphaParameter = consumePercent(args, ValueRangeAll);
 678         if (!alphaParameter)
 679             alphaParameter = consumeNumber(args, ValueRangeAll);
 680         if (!alphaParameter)
 681             return Color();
 682 
 683         colorChannels[3] = std::max(0.0, std::min(1.0, alphaParameter-&gt;isPercentage() ? (alphaParameter-&gt;doubleValue() / 100) : alphaParameter-&gt;doubleValue()));
 684     }
 685 
 686     // FIXME: Support the comma-separated list of fallback color values.
 687 
 688     if (!args.atEnd())
 689         return Color();
 690 
 691     return Color(colorChannels[0], colorChannels[1], colorChannels[2], colorChannels[3], colorSpace);
 692 }
 693 
 694 static Color parseHexColor(CSSParserTokenRange&amp; range, bool acceptQuirkyColors)
 695 {
 696     RGBA32 result;
 697     const CSSParserToken&amp; token = range.peek();
 698     if (token.type() == HashToken) {
 699         if (!Color::parseHexColor(token.value(), result))
 700             return Color();
 701     } else if (acceptQuirkyColors) {
 702         String color;
 703         if (token.type() == NumberToken || token.type() == DimensionToken) {
 704             if (token.numericValueType() != IntegerValueType
 705                 || token.numericValue() &lt; 0. || token.numericValue() &gt;= 1000000.)
 706                 return Color();
 707             if (token.type() == NumberToken) // e.g. 112233
 708                 color = String::number(static_cast&lt;int&gt;(token.numericValue()));
 709             else // e.g. 0001FF
 710                 color = makeString(static_cast&lt;int&gt;(token.numericValue()), token.value().toString());
 711             while (color.length() &lt; 6)
 712                 color = &quot;0&quot; + color;
 713         } else if (token.type() == IdentToken) { // e.g. FF0000
 714             color = token.value().toString();
 715         }
 716         unsigned length = color.length();
 717         if (length != 3 &amp;&amp; length != 6)
 718             return Color();
 719         if (!Color::parseHexColor(color, result))
 720             return Color();
 721     } else {
 722         return Color();
 723     }
 724     range.consumeIncludingWhitespace();
 725     return Color(result);
 726 }
 727 
 728 static Color parseColorFunction(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode)
 729 {
 730     CSSParserTokenRange colorRange = range;
 731     CSSValueID functionId = range.peek().functionId();
 732     Color color;
 733     switch (functionId) {
 734     case CSSValueRgb:
 735     case CSSValueRgba:
 736         color = parseRGBParameters(colorRange);
 737         break;
 738     case CSSValueHsl:
 739     case CSSValueHsla:
 740         color = parseHSLParameters(colorRange, cssParserMode);
 741         break;
 742     case CSSValueColor:
 743         color = parseColorFunctionParameters(colorRange);
 744         break;
 745     default:
 746         return Color();
 747     }
 748     if (color.isValid())
 749         range = colorRange;
 750     return color;
 751 }
 752 
 753 RefPtr&lt;CSSPrimitiveValue&gt; consumeColor(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, bool acceptQuirkyColors)
 754 {
 755     CSSValueID id = range.peek().id();
 756     if (StyleColor::isColorKeyword(id)) {
 757         if (!isValueAllowedInMode(id, cssParserMode))
 758             return nullptr;
 759         return consumeIdent(range);
 760     }
 761     Color color = parseHexColor(range, acceptQuirkyColors);
 762     if (!color.isValid())
 763         color = parseColorFunction(range, cssParserMode);
 764     if (!color.isValid())
 765         return nullptr;
 766     return CSSValuePool::singleton().createValue(color);
 767 }
 768 
 769 static RefPtr&lt;CSSPrimitiveValue&gt; consumePositionComponent(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless)
 770 {
 771     if (range.peek().type() == IdentToken)
 772         return consumeIdent&lt;CSSValueLeft, CSSValueTop, CSSValueBottom, CSSValueRight, CSSValueCenter&gt;(range);
 773     return consumeLengthOrPercent(range, cssParserMode, ValueRangeAll, unitless);
 774 }
 775 
 776 static bool isHorizontalPositionKeywordOnly(const CSSPrimitiveValue&amp; value)
 777 {
 778     return value.isValueID() &amp;&amp; (value.valueID() == CSSValueLeft || value.valueID() == CSSValueRight);
 779 }
 780 
 781 static bool isVerticalPositionKeywordOnly(const CSSPrimitiveValue&amp; value)
 782 {
 783     return value.isValueID() &amp;&amp; (value.valueID() == CSSValueTop || value.valueID() == CSSValueBottom);
 784 }
 785 
 786 static void positionFromOneValue(CSSPrimitiveValue&amp; value, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultX, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultY)
 787 {
 788     bool valueAppliesToYAxisOnly = isVerticalPositionKeywordOnly(value);
 789     resultX = &amp;value;
 790     resultY = CSSPrimitiveValue::createIdentifier(CSSValueCenter);
 791     if (valueAppliesToYAxisOnly)
 792         std::swap(resultX, resultY);
 793 }
 794 
 795 static bool positionFromTwoValues(CSSPrimitiveValue&amp; value1, CSSPrimitiveValue&amp; value2,
 796     RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultX, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultY)
 797 {
 798     bool mustOrderAsXY = isHorizontalPositionKeywordOnly(value1) || isVerticalPositionKeywordOnly(value2)
 799         || !value1.isValueID() || !value2.isValueID();
 800     bool mustOrderAsYX = isVerticalPositionKeywordOnly(value1) || isHorizontalPositionKeywordOnly(value2);
 801     if (mustOrderAsXY &amp;&amp; mustOrderAsYX)
 802         return false;
 803     resultX = &amp;value1;
 804     resultY = &amp;value2;
 805     if (mustOrderAsYX)
 806         std::swap(resultX, resultY);
 807     return true;
 808 }
 809 
 810 namespace CSSPropertyParserHelpersInternal {
 811 template&lt;typename... Args&gt;
 812 static Ref&lt;CSSPrimitiveValue&gt; createPrimitiveValuePair(Args&amp;&amp;... args)
 813 {
 814     return CSSValuePool::singleton().createValue(Pair::create(std::forward&lt;Args&gt;(args)...));
 815 }
 816 }
 817 
 818 // https://drafts.csswg.org/css-backgrounds-3/#propdef-background-position
 819 // background-position has special parsing rules, allowing a 3-value syntax:
 820 // &lt;bg-position&gt; =  [ left | center | right | top | bottom | &lt;length-percentage&gt; ]
 821 // |
 822 //   [ left | center | right | &lt;length-percentage&gt; ]
 823 //   [ top | center | bottom | &lt;length-percentage&gt; ]
 824 // |
 825 //   [ center | [ left | right ] &lt;length-percentage&gt;? ] &amp;&amp;
 826 //   [ center | [ top | bottom ] &lt;length-percentage&gt;? ]
 827 //
 828 static bool backgroundPositionFromThreeValues(const std::array&lt;CSSPrimitiveValue*, 5&gt;&amp; values, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultX, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultY)
 829 {
 830     CSSPrimitiveValue* center = nullptr;
 831     for (int i = 0; values[i]; i++) {
 832         CSSPrimitiveValue* currentValue = values[i];
 833         if (!currentValue-&gt;isValueID())
 834             return false;
 835 
 836         CSSValueID id = currentValue-&gt;valueID();
 837         if (id == CSSValueCenter) {
 838             if (center)
 839                 return false;
 840             center = currentValue;
 841             continue;
 842         }
 843 
 844         RefPtr&lt;CSSPrimitiveValue&gt; result;
 845         if (values[i + 1] &amp;&amp; !values[i + 1]-&gt;isValueID())
 846             result = CSSPropertyParserHelpersInternal::createPrimitiveValuePair(currentValue, values[++i]);
 847         else
 848             result = currentValue;
 849 
 850         if (id == CSSValueLeft || id == CSSValueRight) {
 851             if (resultX)
 852                 return false;
 853             resultX = result;
 854         } else {
 855             ASSERT(id == CSSValueTop || id == CSSValueBottom);
 856             if (resultY)
 857                 return false;
 858             resultY = result;
 859         }
 860     }
 861 
 862     if (center) {
 863         ASSERT(resultX || resultY);
 864         if (resultX &amp;&amp; resultY)
 865             return false;
 866         if (!resultX)
 867             resultX = center;
 868         else
 869             resultY = center;
 870     }
 871 
 872     ASSERT(resultX &amp;&amp; resultY);
 873     return true;
 874 }
 875 
 876 // https://drafts.csswg.org/css-values-4/#typedef-position
 877 // &lt;position&gt; = [
 878 //   [ left | center | right ] || [ top | center | bottom ]
 879 // |
 880 //   [ left | center | right | &lt;length-percentage&gt; ]
 881 //   [ top | center | bottom | &lt;length-percentage&gt; ]?
 882 // |
 883 //   [ [ left | right ] &lt;length-percentage&gt; ] &amp;&amp;
 884 //   [ [ top | bottom ] &lt;length-percentage&gt; ]
 885 //
 886 static bool positionFromFourValues(const std::array&lt;CSSPrimitiveValue*, 5&gt;&amp; values, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultX, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultY)
 887 {
 888     for (int i = 0; values[i]; i++) {
 889         CSSPrimitiveValue* currentValue = values[i];
 890         if (!currentValue-&gt;isValueID())
 891             return false;
 892 
 893         CSSValueID id = currentValue-&gt;valueID();
 894         if (id == CSSValueCenter)
 895             return false;
 896 
 897         RefPtr&lt;CSSPrimitiveValue&gt; result;
 898         if (values[i + 1] &amp;&amp; !values[i + 1]-&gt;isValueID())
 899             result = CSSPropertyParserHelpersInternal::createPrimitiveValuePair(currentValue, values[++i]);
 900         else
 901             result = currentValue;
 902 
 903         if (id == CSSValueLeft || id == CSSValueRight) {
 904             if (resultX)
 905                 return false;
 906             resultX = result;
 907         } else {
 908             ASSERT(id == CSSValueTop || id == CSSValueBottom);
 909             if (resultY)
 910                 return false;
 911             resultY = result;
 912         }
 913     }
 914 
 915     ASSERT(resultX &amp;&amp; resultY);
 916     return true;
 917 }
 918 
 919 // FIXME: This may consume from the range upon failure. The background
 920 // shorthand works around it, but we should just fix it here.
 921 bool consumePosition(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless, PositionSyntax positionSyntax, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultX, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultY)
 922 {
 923     RefPtr&lt;CSSPrimitiveValue&gt; value1 = consumePositionComponent(range, cssParserMode, unitless);
 924     if (!value1)
 925         return false;
 926 
 927     RefPtr&lt;CSSPrimitiveValue&gt; value2 = consumePositionComponent(range, cssParserMode, unitless);
 928     if (!value2) {
 929         positionFromOneValue(*value1, resultX, resultY);
 930         return true;
 931     }
 932 
 933     RefPtr&lt;CSSPrimitiveValue&gt; value3 = consumePositionComponent(range, cssParserMode, unitless);
 934     if (!value3)
 935         return positionFromTwoValues(*value1, *value2, resultX, resultY);
 936 
 937     RefPtr&lt;CSSPrimitiveValue&gt; value4 = consumePositionComponent(range, cssParserMode, unitless);
 938 
 939     std::array&lt;CSSPrimitiveValue*, 5&gt; values;
 940     values[0] = value1.get();
 941     values[1] = value2.get();
 942     values[2] = value3.get();
 943     values[3] = value4.get();
 944     values[4] = nullptr;
 945 
 946     if (value4)
 947         return positionFromFourValues(values, resultX, resultY);
 948 
 949     if (positionSyntax != PositionSyntax::BackgroundPosition)
 950         return false;
 951 
 952     return backgroundPositionFromThreeValues(values, resultX, resultY);
 953 }
 954 
 955 RefPtr&lt;CSSPrimitiveValue&gt; consumePosition(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless, PositionSyntax positionSyntax)
 956 {
 957     RefPtr&lt;CSSPrimitiveValue&gt; resultX;
 958     RefPtr&lt;CSSPrimitiveValue&gt; resultY;
 959     if (consumePosition(range, cssParserMode, unitless, positionSyntax, resultX, resultY))
 960         return CSSPropertyParserHelpersInternal::createPrimitiveValuePair(resultX.releaseNonNull(), resultY.releaseNonNull());
 961     return nullptr;
 962 }
 963 
 964 bool consumeOneOrTwoValuedPosition(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, UnitlessQuirk unitless, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultX, RefPtr&lt;CSSPrimitiveValue&gt;&amp; resultY)
 965 {
 966     RefPtr&lt;CSSPrimitiveValue&gt; value1 = consumePositionComponent(range, cssParserMode, unitless);
 967     if (!value1)
 968         return false;
 969     RefPtr&lt;CSSPrimitiveValue&gt; value2 = consumePositionComponent(range, cssParserMode, unitless);
 970     if (!value2) {
 971         positionFromOneValue(*value1, resultX, resultY);
 972         return true;
 973     }
 974     return positionFromTwoValues(*value1, *value2, resultX, resultY);
 975 }
 976 
 977 // This should go away once we drop support for -webkit-gradient
 978 static RefPtr&lt;CSSPrimitiveValue&gt; consumeDeprecatedGradientPoint(CSSParserTokenRange&amp; args, bool horizontal)
 979 {
 980     if (args.peek().type() == IdentToken) {
 981         if ((horizontal &amp;&amp; consumeIdent&lt;CSSValueLeft&gt;(args)) || (!horizontal &amp;&amp; consumeIdent&lt;CSSValueTop&gt;(args)))
 982             return CSSValuePool::singleton().createValue(0., CSSUnitType::CSS_PERCENTAGE);
 983         if ((horizontal &amp;&amp; consumeIdent&lt;CSSValueRight&gt;(args)) || (!horizontal &amp;&amp; consumeIdent&lt;CSSValueBottom&gt;(args)))
 984             return CSSValuePool::singleton().createValue(100., CSSUnitType::CSS_PERCENTAGE);
 985         if (consumeIdent&lt;CSSValueCenter&gt;(args))
 986             return CSSValuePool::singleton().createValue(50., CSSUnitType::CSS_PERCENTAGE);
 987         return nullptr;
 988     }
 989     RefPtr&lt;CSSPrimitiveValue&gt; result = consumePercent(args, ValueRangeAll);
 990     if (!result)
 991         result = consumeNumber(args, ValueRangeAll);
 992     return result;
 993 }
 994 
 995 // Used to parse colors for -webkit-gradient(...).
 996 static RefPtr&lt;CSSPrimitiveValue&gt; consumeDeprecatedGradientStopColor(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode)
 997 {
 998     if (args.peek().id() == CSSValueCurrentcolor)
 999         return nullptr;
1000     return consumeColor(args, cssParserMode);
1001 }
1002 
1003 static bool consumeDeprecatedGradientColorStop(CSSParserTokenRange&amp; range, CSSGradientColorStop&amp; stop, CSSParserMode cssParserMode)
1004 {
1005     CSSValueID id = range.peek().functionId();
1006     if (id != CSSValueFrom &amp;&amp; id != CSSValueTo &amp;&amp; id != CSSValueColorStop)
1007         return false;
1008 
1009     CSSParserTokenRange args = consumeFunction(range);
1010     double position;
1011     if (id == CSSValueFrom || id == CSSValueTo) {
1012         position = (id == CSSValueFrom) ? 0 : 1;
1013     } else {
1014         ASSERT(id == CSSValueColorStop);
1015         if (auto percentValue = consumePercent(args, ValueRangeAll))
1016             position = percentValue-&gt;doubleValue() / 100.0;
1017         else if (!consumeNumberRaw(args, position))
1018             return false;
1019 
1020         if (!consumeCommaIncludingWhitespace(args))
1021             return false;
1022     }
1023 
1024     stop.m_position = CSSValuePool::singleton().createValue(position, CSSUnitType::CSS_NUMBER);
1025     stop.m_color = consumeDeprecatedGradientStopColor(args, cssParserMode);
1026     return stop.m_color &amp;&amp; args.atEnd();
1027 }
1028 
1029 static RefPtr&lt;CSSValue&gt; consumeDeprecatedGradient(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode)
1030 {
1031     RefPtr&lt;CSSGradientValue&gt; result;
1032     CSSValueID id = args.consumeIncludingWhitespace().id();
1033     bool isDeprecatedRadialGradient = (id == CSSValueRadial);
1034     if (isDeprecatedRadialGradient)
1035         result = CSSRadialGradientValue::create(NonRepeating, CSSDeprecatedRadialGradient);
1036     else if (id == CSSValueLinear)
1037         result = CSSLinearGradientValue::create(NonRepeating, CSSDeprecatedLinearGradient);
1038     if (!result || !consumeCommaIncludingWhitespace(args))
1039         return nullptr;
1040 
1041     auto point = consumeDeprecatedGradientPoint(args, true);
1042     if (!point)
1043         return nullptr;
1044     result-&gt;setFirstX(point.copyRef());
1045     point = consumeDeprecatedGradientPoint(args, false);
1046     if (!point)
1047         return nullptr;
1048     result-&gt;setFirstY(point.copyRef());
1049 
1050     if (!consumeCommaIncludingWhitespace(args))
1051         return nullptr;
1052 
1053     // For radial gradients only, we now expect a numeric radius.
1054     if (isDeprecatedRadialGradient) {
1055         auto radius = consumeNumber(args, ValueRangeNonNegative);
1056         if (!radius || !consumeCommaIncludingWhitespace(args))
1057             return nullptr;
1058         downcast&lt;CSSRadialGradientValue&gt;(result.get())-&gt;setFirstRadius(radius.copyRef());
1059     }
1060 
1061     point = consumeDeprecatedGradientPoint(args, true);
1062     if (!point)
1063         return nullptr;
1064     result-&gt;setSecondX(point.copyRef());
1065     point = consumeDeprecatedGradientPoint(args, false);
1066     if (!point)
1067         return nullptr;
1068     result-&gt;setSecondY(point.copyRef());
1069 
1070     // For radial gradients only, we now expect the second radius.
1071     if (isDeprecatedRadialGradient) {
1072         if (!consumeCommaIncludingWhitespace(args))
1073             return nullptr;
1074         auto radius = consumeNumber(args, ValueRangeNonNegative);
1075         if (!radius)
1076             return nullptr;
1077         downcast&lt;CSSRadialGradientValue&gt;(result.get())-&gt;setSecondRadius(radius.copyRef());
1078     }
1079 
1080     CSSGradientColorStop stop;
1081     while (consumeCommaIncludingWhitespace(args)) {
1082         if (!consumeDeprecatedGradientColorStop(args, stop, cssParserMode))
1083             return nullptr;
1084         result-&gt;addStop(stop);
1085     }
1086 
1087     result-&gt;doneAddingStops();
1088     return result;
1089 }
1090 
1091 static bool consumeGradientColorStops(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, CSSGradientValue&amp; gradient)
1092 {
1093     bool supportsColorHints = gradient.gradientType() == CSSLinearGradient || gradient.gradientType() == CSSRadialGradient || gradient.gradientType() == CSSConicGradient;
1094 
1095     bool isConicGradient = gradient.gradientType() == CSSConicGradient;
1096 
1097     // The first color stop cannot be a color hint.
1098     bool previousStopWasColorHint = true;
1099     do {
1100         CSSGradientColorStop stop;
1101         stop.m_color = consumeColor(range, cssParserMode);
1102         // Two hints in a row are not allowed.
1103         if (!stop.m_color &amp;&amp; (!supportsColorHints || previousStopWasColorHint))
1104             return false;
1105 
1106         previousStopWasColorHint = !stop.m_color;
1107 
1108         // FIXME-NEWPARSER: This boolean could be removed. Null checking color would be sufficient.
1109         stop.isMidpoint = !stop.m_color;
1110 
1111         if (isConicGradient)
1112             stop.m_position = consumeAngleOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Forbid);
1113         else
1114             stop.m_position = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll);
1115 
1116         if (!stop.m_color &amp;&amp; !stop.m_position)
1117             return false;
1118 
1119         gradient.addStop(stop);
1120 
1121         if (!stop.m_color || !stop.m_position)
1122             continue;
1123 
1124         CSSGradientColorStop secondStop;
1125         if (isConicGradient)
1126             secondStop.m_position = consumeAngleOrPercent(range, cssParserMode, ValueRangeAll, UnitlessQuirk::Forbid);
1127         else
1128             secondStop.m_position = consumeLengthOrPercent(range, cssParserMode, ValueRangeAll);
1129 
1130         if (secondStop.m_position)
1131             gradient.addStop(secondStop);
1132 
1133     } while (consumeCommaIncludingWhitespace(range));
1134 
1135     gradient.doneAddingStops();
1136 
1137     // The last color stop cannot be a color hint.
1138     if (previousStopWasColorHint)
1139         return false;
1140 
1141     // Must have 2 or more stops to be valid.
1142     return gradient.stopCount() &gt;= 2;
1143 }
1144 
1145 static RefPtr&lt;CSSValue&gt; consumeDeprecatedRadialGradient(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, CSSGradientRepeat repeating)
1146 {
1147     RefPtr&lt;CSSRadialGradientValue&gt; result = CSSRadialGradientValue::create(repeating, CSSPrefixedRadialGradient);
1148     RefPtr&lt;CSSPrimitiveValue&gt; centerX;
1149     RefPtr&lt;CSSPrimitiveValue&gt; centerY;
1150     consumeOneOrTwoValuedPosition(args, cssParserMode, UnitlessQuirk::Forbid, centerX, centerY);
1151     if ((centerX || centerY) &amp;&amp; !consumeCommaIncludingWhitespace(args))
1152         return nullptr;
1153 
1154     result-&gt;setFirstX(centerX.copyRef());
1155     result-&gt;setFirstY(centerY.copyRef());
1156     result-&gt;setSecondX(centerX.copyRef());
1157     result-&gt;setSecondY(centerY.copyRef());
1158 
1159     auto shape = consumeIdent&lt;CSSValueCircle, CSSValueEllipse&gt;(args);
1160     auto sizeKeyword = consumeIdent&lt;CSSValueClosestSide, CSSValueClosestCorner, CSSValueFarthestSide, CSSValueFarthestCorner, CSSValueContain, CSSValueCover&gt;(args);
1161     if (!shape)
1162         shape = consumeIdent&lt;CSSValueCircle, CSSValueEllipse&gt;(args);
1163     result-&gt;setShape(shape.copyRef());
1164     result-&gt;setSizingBehavior(sizeKeyword.copyRef());
1165 
1166     // Or, two lengths or percentages
1167     if (!shape &amp;&amp; !sizeKeyword) {
1168         auto horizontalSize = consumeLengthOrPercent(args, cssParserMode, ValueRangeNonNegative);
1169         RefPtr&lt;CSSPrimitiveValue&gt; verticalSize;
1170         if (horizontalSize) {
1171             verticalSize = consumeLengthOrPercent(args, cssParserMode, ValueRangeNonNegative);
1172             if (!verticalSize)
1173                 return nullptr;
1174             consumeCommaIncludingWhitespace(args);
1175             result-&gt;setEndHorizontalSize(horizontalSize.copyRef());
1176             result-&gt;setEndVerticalSize(verticalSize.copyRef());
1177         }
1178     } else {
1179         consumeCommaIncludingWhitespace(args);
1180     }
1181     if (!consumeGradientColorStops(args, cssParserMode, *result))
1182         return nullptr;
1183 
1184     return result;
1185 }
1186 
1187 static RefPtr&lt;CSSValue&gt; consumeRadialGradient(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, CSSGradientRepeat repeating)
1188 {
1189     RefPtr&lt;CSSRadialGradientValue&gt; result = CSSRadialGradientValue::create(repeating, CSSRadialGradient);
1190 
1191     RefPtr&lt;CSSPrimitiveValue&gt; shape;
1192     RefPtr&lt;CSSPrimitiveValue&gt; sizeKeyword;
1193     RefPtr&lt;CSSPrimitiveValue&gt; horizontalSize;
1194     RefPtr&lt;CSSPrimitiveValue&gt; verticalSize;
1195 
1196     // First part of grammar, the size/shape clause:
1197     // [ circle || &lt;length&gt; ] |
1198     // [ ellipse || [ &lt;length&gt; | &lt;percentage&gt; ]{2} ] |
1199     // [ [ circle | ellipse] || &lt;size-keyword&gt; ]
1200     for (int i = 0; i &lt; 3; ++i) {
1201         if (args.peek().type() == IdentToken) {
1202             CSSValueID id = args.peek().id();
1203             if (id == CSSValueCircle || id == CSSValueEllipse) {
1204                 if (shape)
1205                     return nullptr;
1206                 shape = consumeIdent(args);
1207             } else if (id == CSSValueClosestSide || id == CSSValueClosestCorner || id == CSSValueFarthestSide || id == CSSValueFarthestCorner) {
1208                 if (sizeKeyword)
1209                     return nullptr;
1210                 sizeKeyword = consumeIdent(args);
1211             } else {
1212                 break;
1213             }
1214         } else {
1215             auto center = consumeLengthOrPercent(args, cssParserMode, ValueRangeNonNegative);
1216             if (!center)
1217                 break;
1218             if (horizontalSize)
1219                 return nullptr;
1220             horizontalSize = center;
1221             center = consumeLengthOrPercent(args, cssParserMode, ValueRangeNonNegative);
1222             if (center) {
1223                 verticalSize = center;
1224                 ++i;
1225             }
1226         }
1227     }
1228 
1229     // You can specify size as a keyword or a length/percentage, not both.
1230     if (sizeKeyword &amp;&amp; horizontalSize)
1231         return nullptr;
1232     // Circles must have 0 or 1 lengths.
1233     if (shape &amp;&amp; shape-&gt;valueID() == CSSValueCircle &amp;&amp; verticalSize)
1234         return nullptr;
1235     // Ellipses must have 0 or 2 length/percentages.
1236     if (shape &amp;&amp; shape-&gt;valueID() == CSSValueEllipse &amp;&amp; horizontalSize &amp;&amp; !verticalSize)
1237         return nullptr;
1238     // If there&#39;s only one size, it must be a length.
1239     if (!verticalSize &amp;&amp; horizontalSize &amp;&amp; horizontalSize-&gt;isPercentage())
1240         return nullptr;
1241     if ((horizontalSize &amp;&amp; horizontalSize-&gt;isCalculatedPercentageWithLength())
1242         || (verticalSize &amp;&amp; verticalSize-&gt;isCalculatedPercentageWithLength()))
1243         return nullptr;
1244 
1245     result-&gt;setShape(shape.copyRef());
1246     result-&gt;setSizingBehavior(sizeKeyword.copyRef());
1247     result-&gt;setEndHorizontalSize(horizontalSize.copyRef());
1248     result-&gt;setEndVerticalSize(verticalSize.copyRef());
1249 
1250     RefPtr&lt;CSSPrimitiveValue&gt; centerX;
1251     RefPtr&lt;CSSPrimitiveValue&gt; centerY;
1252     if (args.peek().id() == CSSValueAt) {
1253         args.consumeIncludingWhitespace();
1254         consumePosition(args, cssParserMode, UnitlessQuirk::Forbid, PositionSyntax::Position, centerX, centerY);
1255         if (!(centerX &amp;&amp; centerY))
1256             return nullptr;
1257 
1258         result-&gt;setFirstX(centerX.copyRef());
1259         result-&gt;setFirstY(centerY.copyRef());
1260 
1261         // Right now, CSS radial gradients have the same start and end centers.
1262         result-&gt;setSecondX(centerX.copyRef());
1263         result-&gt;setSecondY(centerY.copyRef());
1264     }
1265 
1266     if ((shape || sizeKeyword || horizontalSize || centerX || centerY) &amp;&amp; !consumeCommaIncludingWhitespace(args))
1267         return nullptr;
1268     if (!consumeGradientColorStops(args, cssParserMode, *result))
1269         return nullptr;
1270     return result;
1271 }
1272 
1273 static RefPtr&lt;CSSValue&gt; consumeLinearGradient(CSSParserTokenRange&amp; args, CSSParserMode cssParserMode, CSSGradientRepeat repeating, CSSGradientType gradientType)
1274 {
1275     RefPtr&lt;CSSLinearGradientValue&gt; result = CSSLinearGradientValue::create(repeating, gradientType);
1276 
1277     bool expectComma = true;
1278     RefPtr&lt;CSSPrimitiveValue&gt; angle = consumeAngle(args, cssParserMode, UnitlessQuirk::Forbid);
1279     if (angle)
1280         result-&gt;setAngle(angle.releaseNonNull());
1281     else if (gradientType == CSSPrefixedLinearGradient || consumeIdent&lt;CSSValueTo&gt;(args)) {
1282         RefPtr&lt;CSSPrimitiveValue&gt; endX = consumeIdent&lt;CSSValueLeft, CSSValueRight&gt;(args);
1283         RefPtr&lt;CSSPrimitiveValue&gt; endY = consumeIdent&lt;CSSValueBottom, CSSValueTop&gt;(args);
1284         if (!endX &amp;&amp; !endY) {
1285             if (gradientType == CSSLinearGradient)
1286                 return nullptr;
1287             endY = CSSPrimitiveValue::createIdentifier(CSSValueTop);
1288             expectComma = false;
1289         } else if (!endX) {
1290             endX = consumeIdent&lt;CSSValueLeft, CSSValueRight&gt;(args);
1291         }
1292 
1293         result-&gt;setFirstX(endX.copyRef());
1294         result-&gt;setFirstY(endY.copyRef());
1295     } else {
1296         expectComma = false;
1297     }
1298 
1299     if (expectComma &amp;&amp; !consumeCommaIncludingWhitespace(args))
1300         return nullptr;
1301     if (!consumeGradientColorStops(args, cssParserMode, *result))
1302         return nullptr;
1303     return result;
1304 }
1305 
1306 static RefPtr&lt;CSSValue&gt; consumeConicGradient(CSSParserTokenRange&amp; args, CSSParserContext context, CSSGradientRepeat repeating)
1307 {
1308 #if ENABLE(CSS_CONIC_GRADIENTS)
1309     RefPtr&lt;CSSConicGradientValue&gt; result = CSSConicGradientValue::create(repeating);
1310 
1311     bool expectComma = false;
1312     if (args.peek().type() == IdentToken) {
1313         if (consumeIdent&lt;CSSValueFrom&gt;(args)) {
1314             auto angle = consumeAngle(args, context.mode, UnitlessQuirk::Forbid);
1315             if (!angle)
1316                 return nullptr;
1317             result-&gt;setAngle(angle.releaseNonNull());
1318             expectComma = true;
1319         }
1320 
1321         if (consumeIdent&lt;CSSValueAt&gt;(args)) {
1322             RefPtr&lt;CSSPrimitiveValue&gt; centerX;
1323             RefPtr&lt;CSSPrimitiveValue&gt; centerY;
1324             consumePosition(args, context.mode, UnitlessQuirk::Forbid, PositionSyntax::Position, centerX, centerY);
1325             if (!(centerX &amp;&amp; centerY))
1326                 return nullptr;
1327 
1328             result-&gt;setFirstX(centerX.copyRef());
1329             result-&gt;setFirstY(centerY.copyRef());
1330 
1331             // Right now, conic gradients have the same start and end centers.
1332             result-&gt;setSecondX(centerX.copyRef());
1333             result-&gt;setSecondY(centerY.copyRef());
1334 
1335             expectComma = true;
1336         }
1337     }
1338 
1339     if (expectComma &amp;&amp; !consumeCommaIncludingWhitespace(args))
1340         return nullptr;
1341     if (!consumeGradientColorStops(args, context.mode, *result))
1342         return nullptr;
1343     return result;
1344 #else
1345     UNUSED_PARAM(args);
1346     UNUSED_PARAM(context);
1347     UNUSED_PARAM(repeating);
1348     return nullptr;
1349 #endif
1350 }
1351 
1352 RefPtr&lt;CSSValue&gt; consumeImageOrNone(CSSParserTokenRange&amp; range, CSSParserContext context)
1353 {
1354     if (range.peek().id() == CSSValueNone)
1355         return consumeIdent(range);
1356     return consumeImage(range, context);
1357 }
1358 
1359 static RefPtr&lt;CSSValue&gt; consumeCrossFade(CSSParserTokenRange&amp; args, CSSParserContext context, bool prefixed)
1360 {
1361     RefPtr&lt;CSSValue&gt; fromImageValue = consumeImageOrNone(args, context);
1362     if (!fromImageValue || !consumeCommaIncludingWhitespace(args))
1363         return nullptr;
1364     RefPtr&lt;CSSValue&gt; toImageValue = consumeImageOrNone(args, context);
1365     if (!toImageValue || !consumeCommaIncludingWhitespace(args))
1366         return nullptr;
1367 
1368     RefPtr&lt;CSSPrimitiveValue&gt; percentage;
1369     if (auto percentValue = consumePercent(args, ValueRangeAll))
1370         percentage = CSSValuePool::singleton().createValue(clampTo&lt;double&gt;(percentValue-&gt;doubleValue() / 100.0, 0, 1), CSSUnitType::CSS_NUMBER);
1371     else if (auto numberValue = consumeNumber(args, ValueRangeAll))
1372         percentage = CSSValuePool::singleton().createValue(clampTo&lt;double&gt;(numberValue-&gt;doubleValue(), 0, 1), CSSUnitType::CSS_NUMBER);
1373 
1374     if (!percentage)
1375         return nullptr;
1376     return CSSCrossfadeValue::create(fromImageValue.releaseNonNull(), toImageValue.releaseNonNull(), percentage.releaseNonNull(), prefixed);
1377 }
1378 
1379 static RefPtr&lt;CSSValue&gt; consumeWebkitCanvas(CSSParserTokenRange&amp; args)
1380 {
1381     if (args.peek().type() != IdentToken)
1382         return nullptr;
1383     auto canvasName = args.consumeIncludingWhitespace().value().toString();
1384     if (!args.atEnd())
1385         return nullptr;
1386     return CSSCanvasValue::create(canvasName);
1387 }
1388 
1389 static RefPtr&lt;CSSValue&gt; consumeWebkitNamedImage(CSSParserTokenRange&amp; args)
1390 {
1391     if (args.peek().type() != IdentToken)
1392         return nullptr;
1393     auto imageName = args.consumeIncludingWhitespace().value().toString();
1394     if (!args.atEnd())
1395         return nullptr;
1396     return CSSNamedImageValue::create(imageName);
1397 }
1398 
1399 static RefPtr&lt;CSSValue&gt; consumeFilterImage(CSSParserTokenRange&amp; args, const CSSParserContext&amp; context)
1400 {
1401     auto imageValue = consumeImageOrNone(args, context);
1402     if (!imageValue || !consumeCommaIncludingWhitespace(args))
1403         return nullptr;
1404 
1405     auto filterValue = consumeFilter(args, context, AllowedFilterFunctions::PixelFilters);
1406 
1407     if (!filterValue)
1408         return nullptr;
1409 
1410     if (!args.atEnd())
1411         return nullptr;
1412 
1413     return CSSFilterImageValue::create(imageValue.releaseNonNull(), filterValue.releaseNonNull());
1414 }
1415 
1416 #if ENABLE(CSS_PAINTING_API)
1417 static RefPtr&lt;CSSValue&gt; consumeCustomPaint(CSSParserTokenRange&amp; args)
1418 {
1419     if (!RuntimeEnabledFeatures::sharedFeatures().cssPaintingAPIEnabled())
1420         return nullptr;
1421     if (args.peek().type() != IdentToken)
1422         return nullptr;
1423     auto name = args.consumeIncludingWhitespace().value().toString();
1424 
1425     if (!args.atEnd() &amp;&amp; args.peek() != CommaToken)
1426         return nullptr;
1427     if (!args.atEnd())
1428         args.consume();
1429 
1430     auto argumentList = CSSVariableData::create(args);
1431 
1432     while (!args.atEnd())
1433         args.consume();
1434 
1435     return CSSPaintImageValue::create(name, WTFMove(argumentList));
1436 }
1437 #endif
1438 
1439 static RefPtr&lt;CSSValue&gt; consumeGeneratedImage(CSSParserTokenRange&amp; range, CSSParserContext context)
1440 {
1441     CSSValueID id = range.peek().functionId();
1442     CSSParserTokenRange rangeCopy = range;
1443     CSSParserTokenRange args = consumeFunction(rangeCopy);
1444     RefPtr&lt;CSSValue&gt; result;
1445     if (id == CSSValueRadialGradient)
1446         result = consumeRadialGradient(args, context.mode, NonRepeating);
1447     else if (id == CSSValueRepeatingRadialGradient)
1448         result = consumeRadialGradient(args, context.mode, Repeating);
1449     else if (id == CSSValueWebkitLinearGradient)
1450         result = consumeLinearGradient(args, context.mode, NonRepeating, CSSPrefixedLinearGradient);
1451     else if (id == CSSValueWebkitRepeatingLinearGradient)
1452         result = consumeLinearGradient(args, context.mode, Repeating, CSSPrefixedLinearGradient);
1453     else if (id == CSSValueRepeatingLinearGradient)
1454         result = consumeLinearGradient(args, context.mode, Repeating, CSSLinearGradient);
1455     else if (id == CSSValueLinearGradient)
1456         result = consumeLinearGradient(args, context.mode, NonRepeating, CSSLinearGradient);
1457     else if (id == CSSValueWebkitGradient)
1458         result = consumeDeprecatedGradient(args, context.mode);
1459     else if (id == CSSValueWebkitRadialGradient)
1460         result = consumeDeprecatedRadialGradient(args, context.mode, NonRepeating);
1461     else if (id == CSSValueWebkitRepeatingRadialGradient)
1462         result = consumeDeprecatedRadialGradient(args, context.mode, Repeating);
1463     else if (id == CSSValueConicGradient)
1464         result = consumeConicGradient(args, context, NonRepeating);
1465     else if (id == CSSValueRepeatingConicGradient)
1466         result = consumeConicGradient(args, context, Repeating);
1467     else if (id == CSSValueWebkitCrossFade || id == CSSValueCrossFade)
1468         result = consumeCrossFade(args, context, id == CSSValueWebkitCrossFade);
1469     else if (id == CSSValueWebkitCanvas)
1470         result = consumeWebkitCanvas(args);
1471     else if (id == CSSValueWebkitNamedImage)
1472         result = consumeWebkitNamedImage(args);
1473     else if (id == CSSValueWebkitFilter || id == CSSValueFilter)
1474         result = consumeFilterImage(args, context);
1475 #if ENABLE(CSS_PAINTING_API)
1476     else if (id == CSSValuePaint)
1477         result = consumeCustomPaint(args);
1478 #endif
1479     if (!result || !args.atEnd())
1480         return nullptr;
1481     range = rangeCopy;
1482     return result;
1483 }
1484 
1485 static RefPtr&lt;CSSValue&gt; consumeImageSet(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, OptionSet&lt;AllowedImageType&gt; allowedImageTypes)
1486 {
1487     CSSParserTokenRange rangeCopy = range;
1488     CSSParserTokenRange args = consumeFunction(rangeCopy);
1489     RefPtr&lt;CSSImageSetValue&gt; imageSet = CSSImageSetValue::create();
1490     do {
1491         auto image = consumeImage(args, context, allowedImageTypes);
1492         if (!image)
1493             return nullptr;
1494 
1495         imageSet-&gt;append(image.releaseNonNull());
1496 
1497         auto resolution = consumeResolution(args, AllowXResolutionUnit::Allow);
1498         if (!resolution || resolution-&gt;floatValue() &lt;= 0)
1499             return nullptr;
1500 
1501         imageSet-&gt;append(resolution.releaseNonNull());
1502     } while (consumeCommaIncludingWhitespace(args));
1503     if (!args.atEnd())
1504         return nullptr;
1505     range = rangeCopy;
1506     return imageSet;
1507 }
1508 
1509 static bool isGeneratedImage(CSSValueID id)
1510 {
1511     return id == CSSValueLinearGradient
1512         || id == CSSValueRadialGradient
1513         || id == CSSValueConicGradient
1514         || id == CSSValueRepeatingLinearGradient
1515         || id == CSSValueRepeatingRadialGradient
1516         || id == CSSValueRepeatingConicGradient
1517         || id == CSSValueWebkitLinearGradient
1518         || id == CSSValueWebkitRadialGradient
1519         || id == CSSValueWebkitRepeatingLinearGradient
1520         || id == CSSValueWebkitRepeatingRadialGradient
1521         || id == CSSValueWebkitGradient
1522         || id == CSSValueWebkitCrossFade
1523         || id == CSSValueWebkitCanvas
1524         || id == CSSValueCrossFade
1525         || id == CSSValueWebkitNamedImage
1526         || id == CSSValueWebkitFilter
1527 #if ENABLE(CSS_PAINTING_API)
1528         || id == CSSValuePaint
1529 #endif
1530         || id == CSSValueFilter;
1531 }
1532 
1533 static bool isPixelFilterFunction(CSSValueID filterFunction)
1534 {
1535     switch (filterFunction) {
1536     case CSSValueBlur:
1537     case CSSValueBrightness:
1538     case CSSValueContrast:
1539     case CSSValueDropShadow:
1540     case CSSValueGrayscale:
1541     case CSSValueHueRotate:
1542     case CSSValueInvert:
1543     case CSSValueOpacity:
1544     case CSSValueSaturate:
1545     case CSSValueSepia:
1546         return true;
1547     default:
1548         return false;
1549     }
1550 }
1551 
1552 static bool isColorFilterFunction(CSSValueID filterFunction)
1553 {
1554     switch (filterFunction) {
1555     case CSSValueBrightness:
1556     case CSSValueContrast:
1557     case CSSValueGrayscale:
1558     case CSSValueHueRotate:
1559     case CSSValueInvert:
1560     case CSSValueOpacity:
1561     case CSSValueSaturate:
1562     case CSSValueSepia:
1563     case CSSValueAppleInvertLightness:
1564         return true;
1565     default:
1566         return false;
1567     }
1568 }
1569 
1570 static bool allowsValuesGreaterThanOne(CSSValueID filterFunction)
1571 {
1572     switch (filterFunction) {
1573     case CSSValueBrightness:
1574     case CSSValueContrast:
1575     case CSSValueSaturate:
1576         return true;
1577     default:
1578         return false;
1579     }
1580 }
1581 
1582 static RefPtr&lt;CSSFunctionValue&gt; consumeFilterFunction(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, AllowedFilterFunctions allowedFunctions)
1583 {
1584     CSSValueID filterType = range.peek().functionId();
1585     switch (allowedFunctions) {
1586     case AllowedFilterFunctions::PixelFilters:
1587         if (!isPixelFilterFunction(filterType))
1588             return nullptr;
1589         break;
1590     case AllowedFilterFunctions::ColorFilters:
1591         if (!isColorFilterFunction(filterType))
1592             return nullptr;
1593         break;
1594     }
1595 
1596     CSSParserTokenRange args = consumeFunction(range);
1597     RefPtr&lt;CSSFunctionValue&gt; filterValue = CSSFunctionValue::create(filterType);
1598 
1599     if (filterType == CSSValueAppleInvertLightness) {
1600         if (!args.atEnd())
1601             return nullptr;
1602         return filterValue;
1603     }
1604 
1605     RefPtr&lt;CSSValue&gt; parsedValue;
1606 
1607     if (filterType == CSSValueDropShadow)
1608         parsedValue = consumeSingleShadow(args, context.mode, false, false);
1609     else {
1610         if (args.atEnd())
1611             return filterValue;
1612 
1613         if (filterType == CSSValueHueRotate)
1614             parsedValue = consumeAngle(args, context.mode, UnitlessQuirk::Forbid);
1615         else if (filterType == CSSValueBlur)
1616             parsedValue = consumeLength(args, HTMLStandardMode, ValueRangeNonNegative);
1617         else {
1618             parsedValue = consumePercent(args, ValueRangeNonNegative);
1619             if (!parsedValue)
1620                 parsedValue = consumeNumber(args, ValueRangeNonNegative);
1621             if (parsedValue &amp;&amp; !allowsValuesGreaterThanOne(filterType)) {
1622                 bool isPercentage = downcast&lt;CSSPrimitiveValue&gt;(*parsedValue).isPercentage();
1623                 double maxAllowed = isPercentage ? 100.0 : 1.0;
1624                 if (downcast&lt;CSSPrimitiveValue&gt;(*parsedValue).doubleValue() &gt; maxAllowed)
1625                     parsedValue = CSSPrimitiveValue::create(maxAllowed, isPercentage ? CSSUnitType::CSS_PERCENTAGE : CSSUnitType::CSS_NUMBER);
1626             }
1627         }
1628     }
1629     if (!parsedValue || !args.atEnd())
1630         return nullptr;
1631     filterValue-&gt;append(parsedValue.releaseNonNull());
1632     return filterValue;
1633 }
1634 
1635 RefPtr&lt;CSSValue&gt; consumeFilter(CSSParserTokenRange&amp; range, const CSSParserContext&amp; context, AllowedFilterFunctions allowedFunctions)
1636 {
1637     if (range.peek().id() == CSSValueNone)
1638         return consumeIdent(range);
1639 
1640     bool referenceFiltersAllowed = allowedFunctions == AllowedFilterFunctions::PixelFilters;
1641     auto list = CSSValueList::createSpaceSeparated();
1642     do {
1643         RefPtr&lt;CSSValue&gt; filterValue = referenceFiltersAllowed ? consumeUrl(range) : nullptr;
1644         if (!filterValue) {
1645             filterValue = consumeFilterFunction(range, context, allowedFunctions);
1646             if (!filterValue)
1647                 return nullptr;
1648         }
1649         list-&gt;append(filterValue.releaseNonNull());
1650     } while (!range.atEnd());
1651 
1652     return list.ptr();
1653 }
1654 
1655 RefPtr&lt;CSSShadowValue&gt; consumeSingleShadow(CSSParserTokenRange&amp; range, CSSParserMode cssParserMode, bool allowInset, bool allowSpread)
1656 {
1657     RefPtr&lt;CSSPrimitiveValue&gt; style;
1658     RefPtr&lt;CSSPrimitiveValue&gt; color;
1659 
1660     if (range.atEnd())
1661         return nullptr;
1662     if (range.peek().id() == CSSValueInset) {
1663         if (!allowInset)
1664             return nullptr;
1665         style = consumeIdent(range);
1666     }
1667     color = consumeColor(range, cssParserMode);
1668 
1669     auto horizontalOffset = consumeLength(range, cssParserMode, ValueRangeAll);
1670     if (!horizontalOffset)
1671         return nullptr;
1672 
1673     auto verticalOffset = consumeLength(range, cssParserMode, ValueRangeAll);
1674     if (!verticalOffset)
1675         return nullptr;
1676 
1677     RefPtr&lt;CSSPrimitiveValue&gt; blurRadius;
1678     RefPtr&lt;CSSPrimitiveValue&gt; spreadDistance;
1679 
1680     const CSSParserToken&amp; token = range.peek();
1681     // The explicit check for calc() is unfortunate. This is ensuring that we only fail parsing if there is a length, but it fails the range check.
1682     if (token.type() == DimensionToken || token.type() == NumberToken || (token.type() == FunctionToken &amp;&amp; CSSCalcValue::isCalcFunction(token.functionId()))) {
1683         blurRadius = consumeLength(range, cssParserMode, ValueRangeNonNegative);
1684         if (!blurRadius)
1685             return nullptr;
1686     }
1687 
1688     if (blurRadius &amp;&amp; allowSpread)
1689         spreadDistance = consumeLength(range, cssParserMode, ValueRangeAll);
1690 
1691     if (!range.atEnd()) {
1692         if (!color)
1693             color = consumeColor(range, cssParserMode);
1694         if (range.peek().id() == CSSValueInset) {
1695             if (!allowInset || style)
1696                 return nullptr;
1697             style = consumeIdent(range);
1698         }
1699     }
1700 
1701     return CSSShadowValue::create(WTFMove(horizontalOffset), WTFMove(verticalOffset), WTFMove(blurRadius), WTFMove(spreadDistance), WTFMove(style), WTFMove(color));
1702 }
1703 
1704 RefPtr&lt;CSSValue&gt; consumeImage(CSSParserTokenRange&amp; range, CSSParserContext context, OptionSet&lt;AllowedImageType&gt; allowedImageTypes)
1705 {
1706     if ((range.peek().type() == StringToken) &amp;&amp; (allowedImageTypes.contains(AllowedImageType::RawStringAsURL))) {
1707         auto urlStringView = range.consumeIncludingWhitespace().value();
1708         return CSSImageValue::create(completeURL(context, urlStringView.toAtomString()), context.isContentOpaque ? LoadedFromOpaqueSource::Yes : LoadedFromOpaqueSource::No);
1709     }
1710 
1711     if (range.peek().type() == FunctionToken) {
1712         CSSValueID functionId = range.peek().functionId();
1713         if ((allowedImageTypes.contains(AllowedImageType::GeneratedImage)) &amp;&amp; isGeneratedImage(functionId))
1714             return consumeGeneratedImage(range, context);
1715 
1716         if (allowedImageTypes.contains(AllowedImageType::ImageSet)) {
1717             if (functionId == CSSValueImageSet)
1718                 return consumeImageSet(range, context, (allowedImageTypes | AllowedImageType::RawStringAsURL) - AllowedImageType::ImageSet);
1719             if (functionId == CSSValueWebkitImageSet)
1720                 return consumeImageSet(range, context, AllowedImageType::URLFunction);
1721         }
1722     }
1723 
1724     if (allowedImageTypes.contains(AllowedImageType::URLFunction)) {
1725         auto uri = consumeUrlAsStringView(range);
1726         if (!uri.isNull())
1727             return CSSImageValue::create(completeURL(context, uri.toAtomString()), context.isContentOpaque ? LoadedFromOpaqueSource::Yes : LoadedFromOpaqueSource::No);
1728     }
1729 
1730     return nullptr;
1731 }
1732 
1733 } // namespace CSSPropertyParserHelpers
1734 
1735 } // namespace WebCore
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/NodesCodegen.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Label.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegisterID.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecompiler/NodesCodegen.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,17 ***</span>
  #include &quot;Nodes.h&quot;
  #include &quot;NodeConstructors.h&quot;
  
  #include &quot;BuiltinNames.h&quot;
  #include &quot;BytecodeGenerator.h&quot;
  #include &quot;CallFrame.h&quot;
  #include &quot;JIT.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSFunction.h&quot;
<span class="line-modified">! #include &quot;JSGeneratorFunction.h&quot;</span>
  #include &quot;JSGlobalObject.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;LabelScope.h&quot;
  #include &quot;Lexer.h&quot;
  #include &quot;Parser.h&quot;
  #include &quot;StackAlignment.h&quot;
  #include &quot;UnlinkedMetadataTableInlines.h&quot;
<span class="line-new-header">--- 28,21 ---</span>
  #include &quot;Nodes.h&quot;
  #include &quot;NodeConstructors.h&quot;
  
  #include &quot;BuiltinNames.h&quot;
  #include &quot;BytecodeGenerator.h&quot;
<span class="line-added">+ #include &quot;BytecodeGeneratorBaseInlines.h&quot;</span>
  #include &quot;CallFrame.h&quot;
  #include &quot;JIT.h&quot;
<span class="line-added">+ #include &quot;JSArrayIterator.h&quot;</span>
<span class="line-added">+ #include &quot;JSAsyncGenerator.h&quot;</span>
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSFunction.h&quot;
<span class="line-modified">! #include &quot;JSGenerator.h&quot;</span>
  #include &quot;JSGlobalObject.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
<span class="line-added">+ #include &quot;JSStringIterator.h&quot;</span>
  #include &quot;LabelScope.h&quot;
  #include &quot;Lexer.h&quot;
  #include &quot;Parser.h&quot;
  #include &quot;StackAlignment.h&quot;
  #include &quot;UnlinkedMetadataTableInlines.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,11 ***</span>
  
  RegisterID* ConstantNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      if (dst == generator.ignoredResult())
          return 0;
<span class="line-modified">!     return generator.emitLoad(dst, jsValue(generator));</span>
  }
  
  JSValue StringNode::jsValue(BytecodeGenerator&amp; generator) const
  {
      return generator.addStringConstant(m_value);
<span class="line-new-header">--- 117,16 ---</span>
  
  RegisterID* ConstantNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      if (dst == generator.ignoredResult())
          return 0;
<span class="line-modified">!     JSValue constant = jsValue(generator);</span>
<span class="line-added">+     if (UNLIKELY(!constant)) {</span>
<span class="line-added">+         // This can happen if we try to parse a string or BigInt so enormous that we OOM.</span>
<span class="line-added">+         return generator.emitThrowExpressionTooDeepException();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return generator.emitLoad(dst, constant);</span>
  }
  
  JSValue StringNode::jsValue(BytecodeGenerator&amp; generator) const
  {
      return generator.addStringConstant(m_value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 163,20 ***</span>
      generator.ensureThis();
      if (dst == generator.ignoredResult())
          return 0;
  
      RegisterID* result = generator.move(dst, generator.thisRegister());
<span class="line-modified">!     static const unsigned thisLength = 4;</span>
<span class="line-modified">!     generator.emitProfileType(generator.thisRegister(), position(), JSTextPosition(-1, position().offset + thisLength, -1));</span>
      return result;
  }
  
  // ------------------------------ SuperNode -------------------------------------
  
  static RegisterID* emitHomeObjectForCallee(BytecodeGenerator&amp; generator)
  {
<span class="line-modified">!     if (generator.isDerivedClassContext() || generator.isDerivedConstructorContext()) {</span>
          RegisterID* derivedConstructor = generator.emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment();
          return generator.emitGetById(generator.newTemporary(), derivedConstructor, generator.propertyNames().builtinNames().homeObjectPrivateName());
      }
  
      RegisterID callee;
<span class="line-new-header">--- 172,20 ---</span>
      generator.ensureThis();
      if (dst == generator.ignoredResult())
          return 0;
  
      RegisterID* result = generator.move(dst, generator.thisRegister());
<span class="line-modified">!     static const unsigned thisLength = strlen(&quot;this&quot;);</span>
<span class="line-modified">!     generator.emitProfileType(generator.thisRegister(), position(), position() + thisLength);</span>
      return result;
  }
  
  // ------------------------------ SuperNode -------------------------------------
  
  static RegisterID* emitHomeObjectForCallee(BytecodeGenerator&amp; generator)
  {
<span class="line-modified">!     if ((generator.isDerivedClassContext() || generator.isDerivedConstructorContext()) &amp;&amp; generator.parseMode() != SourceParseMode::InstanceFieldInitializerMode) {</span>
          RegisterID* derivedConstructor = generator.emitLoadDerivedConstructorFromArrowFunctionLexicalEnvironment();
          return generator.emitGetById(generator.newTemporary(), derivedConstructor, generator.propertyNames().builtinNames().homeObjectPrivateName());
      }
  
      RegisterID callee;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 208,11 ***</span>
  
  // ------------------------------ ImportNode -------------------------------------
  
  RegisterID* ImportNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; importModule = generator.emitGetGlobalPrivate(generator.newTemporary(), generator.propertyNames().builtinNames().importModulePrivateName());</span>
      CallArguments arguments(generator, nullptr, 1);
      generator.emitLoad(arguments.thisRegister(), jsUndefined());
      generator.emitNode(arguments.argumentRegister(0), m_expr);
      return generator.emitCall(generator.finalDestination(dst, importModule.get()), importModule.get(), NoExpectedFunction, arguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);
  }
<span class="line-new-header">--- 217,11 ---</span>
  
  // ------------------------------ ImportNode -------------------------------------
  
  RegisterID* ImportNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; importModule = generator.moveLinkTimeConstant(nullptr, LinkTimeConstant::importModule);</span>
      CallArguments arguments(generator, nullptr, 1);
      generator.emitLoad(arguments.thisRegister(), jsUndefined());
      generator.emitNode(arguments.argumentRegister(0), m_expr);
      return generator.emitCall(generator.finalDestination(dst, importModule.get()), importModule.get(), NoExpectedFunction, arguments, divot(), divotStart(), divotEnd(), DebuggableCall::No);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 247,11 ***</span>
      if (RegisterID* local = var.local()) {
          generator.emitTDZCheckIfNecessary(var, local, nullptr);
          if (dst == generator.ignoredResult())
              return nullptr;
  
<span class="line-modified">!         generator.emitProfileType(local, var, m_position, JSTextPosition(-1, m_position.offset + m_ident.length(), -1));</span>
          return generator.move(dst, local);
      }
  
      JSTextPosition divot = m_start + m_ident.length();
      generator.emitExpressionInfo(divot, m_start, divot);
<span class="line-new-header">--- 256,11 ---</span>
      if (RegisterID* local = var.local()) {
          generator.emitTDZCheckIfNecessary(var, local, nullptr);
          if (dst == generator.ignoredResult())
              return nullptr;
  
<span class="line-modified">!         generator.emitProfileType(local, var, m_position, m_position + m_ident.length());</span>
          return generator.move(dst, local);
      }
  
      JSTextPosition divot = m_start + m_ident.length();
      generator.emitExpressionInfo(divot, m_start, divot);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 259,11 ***</span>
      RegisterID* finalDest = generator.finalDestination(dst);
      RefPtr&lt;RegisterID&gt; uncheckedResult = generator.newTemporary();
      generator.emitGetFromScope(uncheckedResult.get(), scope.get(), var, ThrowIfNotFound);
      generator.emitTDZCheckIfNecessary(var, uncheckedResult.get(), nullptr);
      generator.move(finalDest, uncheckedResult.get());
<span class="line-modified">!     generator.emitProfileType(finalDest, var, m_position, JSTextPosition(-1, m_position.offset + m_ident.length(), -1));</span>
      return finalDest;
  }
  
  // ------------------------------ TemplateStringNode -----------------------------------
  
<span class="line-new-header">--- 268,11 ---</span>
      RegisterID* finalDest = generator.finalDestination(dst);
      RefPtr&lt;RegisterID&gt; uncheckedResult = generator.newTemporary();
      generator.emitGetFromScope(uncheckedResult.get(), scope.get(), var, ThrowIfNotFound);
      generator.emitTDZCheckIfNecessary(var, uncheckedResult.get(), nullptr);
      generator.move(finalDest, uncheckedResult.get());
<span class="line-modified">!     generator.emitProfileType(finalDest, var, m_position, m_position + m_ident.length());</span>
      return finalDest;
  }
  
  // ------------------------------ TemplateStringNode -----------------------------------
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 536,17 ***</span>
  static inline void emitPutHomeObject(BytecodeGenerator&amp; generator, RegisterID* function, RegisterID* homeObject)
  {
      generator.emitPutById(function, generator.propertyNames().builtinNames().homeObjectPrivateName(), homeObject);
  }
  
<span class="line-modified">! RegisterID* PropertyListNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dstOrConstructor, RegisterID* prototype)</span>
  {
      // Fast case: this loop just handles regular value properties.
      PropertyListNode* p = this;
      RegisterID* dst = nullptr;
      for (; p &amp;&amp; (p-&gt;m_node-&gt;m_type &amp; PropertyNode::Constant); p = p-&gt;m_next) {
          dst = p-&gt;m_node-&gt;isInstanceClassProperty() ? prototype : dstOrConstructor;
          emitPutConstantProperty(generator, dst, *p-&gt;m_node);
      }
  
      // Were there any get/set properties?
      if (p) {
<span class="line-new-header">--- 545,27 ---</span>
  static inline void emitPutHomeObject(BytecodeGenerator&amp; generator, RegisterID* function, RegisterID* homeObject)
  {
      generator.emitPutById(function, generator.propertyNames().builtinNames().homeObjectPrivateName(), homeObject);
  }
  
<span class="line-modified">! RegisterID* PropertyListNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dstOrConstructor, RegisterID* prototype, Vector&lt;JSTextPosition&gt;* instanceFieldLocations)</span>
  {
      // Fast case: this loop just handles regular value properties.
      PropertyListNode* p = this;
      RegisterID* dst = nullptr;
      for (; p &amp;&amp; (p-&gt;m_node-&gt;m_type &amp; PropertyNode::Constant); p = p-&gt;m_next) {
          dst = p-&gt;m_node-&gt;isInstanceClassProperty() ? prototype : dstOrConstructor;
<span class="line-added">+ </span>
<span class="line-added">+         if (p-&gt;isComputedClassField())</span>
<span class="line-added">+             emitSaveComputedFieldName(generator, *p-&gt;m_node);</span>
<span class="line-added">+ </span>
<span class="line-added">+         if (p-&gt;isInstanceClassField()) {</span>
<span class="line-added">+             ASSERT(instanceFieldLocations);</span>
<span class="line-added">+             instanceFieldLocations-&gt;append(p-&gt;position());</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          emitPutConstantProperty(generator, dst, *p-&gt;m_node);
      }
  
      // Were there any get/set properties?
      if (p) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 590,10 ***</span>
<span class="line-new-header">--- 609,20 ---</span>
          // Iterate over the remaining properties in the list.
          for (; p; p = p-&gt;m_next) {
              PropertyNode* node = p-&gt;m_node;
              dst = node-&gt;isInstanceClassProperty() ? prototype : dstOrConstructor;
  
<span class="line-added">+             if (p-&gt;isComputedClassField())</span>
<span class="line-added">+                 emitSaveComputedFieldName(generator, *p-&gt;m_node);</span>
<span class="line-added">+ </span>
<span class="line-added">+             if (p-&gt;isInstanceClassField()) {</span>
<span class="line-added">+                 ASSERT(instanceFieldLocations);</span>
<span class="line-added">+                 ASSERT(node-&gt;m_type &amp; PropertyNode::Constant);</span>
<span class="line-added">+                 instanceFieldLocations-&gt;append(p-&gt;position());</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              // Handle regular values.
              if (node-&gt;m_type &amp; PropertyNode::Constant) {
                  emitPutConstantProperty(generator, dst, *node);
                  continue;
              } else if (node-&gt;m_type &amp; PropertyNode::Spread) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 711,10 ***</span>
<span class="line-new-header">--- 740,27 ---</span>
      RefPtr&lt;RegisterID&gt; propertyName = generator.emitNode(node.m_expression);
      generator.emitSetFunctionNameIfNeeded(node.m_assign, value.get(), propertyName.get());
      generator.emitDirectPutByVal(newObj, propertyName.get(), value.get());
  }
  
<span class="line-added">+ void PropertyListNode::emitSaveComputedFieldName(BytecodeGenerator&amp; generator, PropertyNode&amp; node)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(node.isComputedClassField());</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; propertyExpr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // The &#39;name&#39; refers to a synthetic numeric variable name in the private name scope, where the property key is saved for later use.</span>
<span class="line-added">+     const Identifier&amp; description = *node.name();</span>
<span class="line-added">+     Variable var = generator.variable(description);</span>
<span class="line-added">+     ASSERT(!var.local());</span>
<span class="line-added">+ </span>
<span class="line-added">+     propertyExpr = generator.emitNode(node.m_expression);</span>
<span class="line-added">+     RegisterID* propertyName = generator.emitToPropertyKey(generator.newTemporary(), propertyExpr.get());</span>
<span class="line-added">+ </span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);</span>
<span class="line-added">+     generator.emitPutToScope(scope.get(), var, propertyName, ThrowIfNotFound, InitializationMode::ConstInitialization);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // ------------------------------ BracketAccessorNode --------------------------------
  
  static bool isNonIndexStringElement(ExpressionNode&amp; element)
  {
      return element.isString() &amp;&amp; !parseIndex(static_cast&lt;StringNode&amp;&gt;(element).value());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 918,10 ***</span>
<span class="line-new-header">--- 964,17 ---</span>
          generator.move(generator.thisRegister(), ret);
  
          if (generator.isDerivedConstructorContext() || doWeUseArrowFunctionInConstructor)
              generator.emitPutThisToArrowFunctionContextScope();
  
<span class="line-added">+         // Initialize instance fields after super-call.</span>
<span class="line-added">+         if (Options::useClassFields() &amp;&amp; generator.needsClassFieldInitializer() == NeedsClassFieldInitializer::Yes) {</span>
<span class="line-added">+             ASSERT(generator.isConstructor() || generator.isDerivedConstructorContext());</span>
<span class="line-added">+             func = generator.emitLoadDerivedConstructor();</span>
<span class="line-added">+             generator.emitInstanceFieldInitializationIfNeeded(generator.thisRegister(), func.get(), divot(), divotStart(), divotEnd());</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          return ret;
      }
  
      RefPtr&lt;RegisterID&gt; func = generator.emitNode(m_expr);
      RefPtr&lt;RegisterID&gt; returnValue = generator.finalDestination(dst, func.get());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 937,12 ***</span>
  
  // ------------------------------ FunctionCallResolveNode ----------------------------------
  
  RegisterID* FunctionCallResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
<span class="line-modified">!     if (UNLIKELY(m_ident == generator.vm().propertyNames-&gt;builtinNames().assertPrivateName())) {</span>
<span class="line-modified">!         if (ASSERT_DISABLED)</span>
              return generator.move(dst, generator.emitLoad(nullptr, jsUndefined()));
      }
  
      ExpectedFunction expectedFunction = generator.expectedFunctionForIdentifier(m_ident);
  
<span class="line-new-header">--- 990,12 ---</span>
  
  // ------------------------------ FunctionCallResolveNode ----------------------------------
  
  RegisterID* FunctionCallResolveNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
<span class="line-modified">!     if (!ASSERT_ENABLED) {</span>
<span class="line-modified">!         if (UNLIKELY(m_ident == generator.vm().propertyNames-&gt;builtinNames().assertPrivateName()))</span>
              return generator.move(dst, generator.emitLoad(nullptr, jsUndefined()));
      }
  
      ExpectedFunction expectedFunction = generator.expectedFunctionForIdentifier(m_ident);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 982,11 ***</span>
  
  // ------------------------------ BytecodeIntrinsicNode ----------------------------------
  
  RegisterID* BytecodeIntrinsicNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
<span class="line-modified">!     return (this-&gt;*m_emitter)(generator, dst);</span>
  }
  
  RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getByIdDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      ArgumentListNode* node = m_args-&gt;m_listNode;
<span class="line-new-header">--- 1035,15 ---</span>
  
  // ------------------------------ BytecodeIntrinsicNode ----------------------------------
  
  RegisterID* BytecodeIntrinsicNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
<span class="line-modified">!     if (m_entry.type() == BytecodeIntrinsicRegistry::Type::Emitter)</span>
<span class="line-added">+         return (this-&gt;*m_entry.emitter())(generator, dst);</span>
<span class="line-added">+     if (dst == generator.ignoredResult())</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     return generator.moveLinkTimeConstant(dst, m_entry.linkTimeConstant());</span>
  }
  
  RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getByIdDirect(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      ArgumentListNode* node = m_args-&gt;m_listNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1008,10 ***</span>
<span class="line-new-header">--- 1065,146 ---</span>
      ASSERT(symbol);
      ASSERT(!node-&gt;m_next);
      return generator.emitDirectGetById(generator.finalDestination(dst), base.get(), generator.parserArena().identifierArena().makeIdentifier(generator.vm(), symbol));
  }
  
<span class="line-added">+ static JSPromise::Field promiseInternalFieldIndex(BytecodeIntrinsicNode* node)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(node-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter);</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_promiseFieldFlags)</span>
<span class="line-added">+         return JSPromise::Field::Flags;</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_promiseFieldReactionsOrResult)</span>
<span class="line-added">+         return JSPromise::Field::ReactionsOrResult;</span>
<span class="line-added">+     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+     return JSPromise::Field::Flags;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static JSGenerator::Field generatorInternalFieldIndex(BytecodeIntrinsicNode* node)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(node-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter);</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldState)</span>
<span class="line-added">+         return JSGenerator::Field::State;</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldNext)</span>
<span class="line-added">+         return JSGenerator::Field::Next;</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldThis)</span>
<span class="line-added">+         return JSGenerator::Field::This;</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldFrame)</span>
<span class="line-added">+         return JSGenerator::Field::Frame;</span>
<span class="line-added">+     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+     return JSGenerator::Field::State;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static JSAsyncGenerator::Field asyncGeneratorInternalFieldIndex(BytecodeIntrinsicNode* node)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(node-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter);</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldState)</span>
<span class="line-added">+         return JSAsyncGenerator::Field::State;</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldNext)</span>
<span class="line-added">+         return JSAsyncGenerator::Field::Next;</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldThis)</span>
<span class="line-added">+         return JSAsyncGenerator::Field::This;</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_generatorFieldFrame)</span>
<span class="line-added">+         return JSAsyncGenerator::Field::Frame;</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_asyncGeneratorFieldSuspendReason)</span>
<span class="line-added">+         return JSAsyncGenerator::Field::SuspendReason;</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_asyncGeneratorFieldQueueFirst)</span>
<span class="line-added">+         return JSAsyncGenerator::Field::QueueFirst;</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_asyncGeneratorFieldQueueLast)</span>
<span class="line-added">+         return JSAsyncGenerator::Field::QueueLast;</span>
<span class="line-added">+     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+     return JSAsyncGenerator::Field::State;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static JSArrayIterator::Field arrayIteratorInternalFieldIndex(BytecodeIntrinsicNode* node)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(node-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter);</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_arrayIteratorFieldIndex)</span>
<span class="line-added">+         return JSArrayIterator::Field::Index;</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_arrayIteratorFieldIteratedObject)</span>
<span class="line-added">+         return JSArrayIterator::Field::IteratedObject;</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_arrayIteratorFieldKind)</span>
<span class="line-added">+         return JSArrayIterator::Field::Kind;</span>
<span class="line-added">+     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+     return JSArrayIterator::Field::Index;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static JSStringIterator::Field stringIteratorInternalFieldIndex(BytecodeIntrinsicNode* node)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(node-&gt;entry().type() == BytecodeIntrinsicRegistry::Type::Emitter);</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_stringIteratorFieldIndex)</span>
<span class="line-added">+         return JSStringIterator::Field::Index;</span>
<span class="line-added">+     if (node-&gt;entry().emitter() == &amp;BytecodeIntrinsicNode::emit_intrinsic_stringIteratorFieldIteratedString)</span>
<span class="line-added">+         return JSStringIterator::Field::IteratedString;</span>
<span class="line-added">+     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">+     return JSStringIterator::Field::Index;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getPromiseInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">+     node = node-&gt;m_next;</span>
<span class="line-added">+     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">+     unsigned index = static_cast&lt;unsigned&gt;(promiseInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">+     ASSERT(index &lt; JSPromise::numberOfInternalFields);</span>
<span class="line-added">+     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return generator.emitGetInternalField(generator.finalDestination(dst), base.get(), index);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getGeneratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">+     node = node-&gt;m_next;</span>
<span class="line-added">+     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">+     unsigned index = static_cast&lt;unsigned&gt;(generatorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">+     ASSERT(index &lt; JSGenerator::numberOfInternalFields);</span>
<span class="line-added">+     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return generator.emitGetInternalField(generator.finalDestination(dst), base.get(), index);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getAsyncGeneratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">+     node = node-&gt;m_next;</span>
<span class="line-added">+     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">+     unsigned index = static_cast&lt;unsigned&gt;(asyncGeneratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">+     ASSERT(index &lt; JSAsyncGenerator::numberOfInternalFields);</span>
<span class="line-added">+     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return generator.emitGetInternalField(generator.finalDestination(dst), base.get(), index);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getArrayIteratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">+     node = node-&gt;m_next;</span>
<span class="line-added">+     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">+     unsigned index = static_cast&lt;unsigned&gt;(arrayIteratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">+     ASSERT(index &lt; JSArrayIterator::numberOfInternalFields);</span>
<span class="line-added">+     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return generator.emitGetInternalField(generator.finalDestination(dst), base.get(), index);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeIntrinsicNode::emit_intrinsic_getStringIteratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">+     node = node-&gt;m_next;</span>
<span class="line-added">+     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">+     unsigned index = static_cast&lt;unsigned&gt;(stringIteratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">+     ASSERT(index &lt; JSStringIterator::numberOfInternalFields);</span>
<span class="line-added">+     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return generator.emitGetInternalField(generator.finalDestination(dst), base.get(), index);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  RegisterID* BytecodeIntrinsicNode::emit_intrinsic_argument(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      ArgumentListNode* node = m_args-&gt;m_listNode;
      ASSERT(node-&gt;m_expr-&gt;isNumber());
      double value = static_cast&lt;NumberNode*&gt;(node-&gt;m_expr)-&gt;value();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1077,10 ***</span>
<span class="line-new-header">--- 1270,90 ---</span>
      ASSERT(!node-&gt;m_next);
  
      return generator.move(dst, generator.emitDirectPutByVal(base.get(), index.get(), value.get()));
  }
  
<span class="line-added">+ RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putPromiseInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">+     node = node-&gt;m_next;</span>
<span class="line-added">+     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">+     unsigned index = static_cast&lt;unsigned&gt;(promiseInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">+     ASSERT(index &lt; JSPromise::numberOfInternalFields);</span>
<span class="line-added">+     node = node-&gt;m_next;</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return generator.move(dst, generator.emitPutInternalField(base.get(), index, value.get()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putGeneratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">+     node = node-&gt;m_next;</span>
<span class="line-added">+     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">+     unsigned index = static_cast&lt;unsigned&gt;(generatorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">+     ASSERT(index &lt; JSGenerator::numberOfInternalFields);</span>
<span class="line-added">+     node = node-&gt;m_next;</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return generator.move(dst, generator.emitPutInternalField(base.get(), index, value.get()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putAsyncGeneratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">+     node = node-&gt;m_next;</span>
<span class="line-added">+     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">+     unsigned index = static_cast&lt;unsigned&gt;(asyncGeneratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">+     ASSERT(index &lt; JSAsyncGenerator::numberOfInternalFields);</span>
<span class="line-added">+     node = node-&gt;m_next;</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return generator.move(dst, generator.emitPutInternalField(base.get(), index, value.get()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putArrayIteratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">+     node = node-&gt;m_next;</span>
<span class="line-added">+     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">+     unsigned index = static_cast&lt;unsigned&gt;(arrayIteratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">+     ASSERT(index &lt; JSArrayIterator::numberOfInternalFields);</span>
<span class="line-added">+     node = node-&gt;m_next;</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return generator.move(dst, generator.emitPutInternalField(base.get(), index, value.get()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ RegisterID* BytecodeIntrinsicNode::emit_intrinsic_putStringIteratorInternalField(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; base = generator.emitNode(node);</span>
<span class="line-added">+     node = node-&gt;m_next;</span>
<span class="line-added">+     RELEASE_ASSERT(node-&gt;m_expr-&gt;isBytecodeIntrinsicNode());</span>
<span class="line-added">+     unsigned index = static_cast&lt;unsigned&gt;(stringIteratorInternalFieldIndex(static_cast&lt;BytecodeIntrinsicNode*&gt;(node-&gt;m_expr)));</span>
<span class="line-added">+     ASSERT(index &lt; JSStringIterator::numberOfInternalFields);</span>
<span class="line-added">+     node = node-&gt;m_next;</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; value = generator.emitNode(node);</span>
<span class="line-added">+ </span>
<span class="line-added">+     ASSERT(!node-&gt;m_next);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return generator.move(dst, generator.emitPutInternalField(base.get(), index, value.get()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  RegisterID* BytecodeIntrinsicNode::emit_intrinsic_tailCallForwardArguments(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      ArgumentListNode* node = m_args-&gt;m_listNode;
      RefPtr&lt;RegisterID&gt; function = generator.emitNode(node);
      node = node-&gt;m_next;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1191,91 ***</span>
      }
  
      return generator.move(dst, generator.emitIdWithProfile(idValue.get(), speculation));
  }
  
<span class="line-modified">! RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isJSArray(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);</span>
<span class="line-modified">!     ASSERT(!node-&gt;m_next);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return generator.move(dst, generator.emitIsJSArray(generator.tempDestination(dst), src.get()));</span>
<span class="line-modified">! }</span>
<span class="line-removed">- </span>
<span class="line-removed">- RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isProxyObject(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);</span>
<span class="line-removed">-     ASSERT(!node-&gt;m_next);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return generator.move(dst, generator.emitIsProxyObject(generator.tempDestination(dst), src.get()));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isRegExpObject(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);</span>
<span class="line-removed">-     ASSERT(!node-&gt;m_next);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return generator.move(dst, generator.emitIsRegExpObject(generator.tempDestination(dst), src.get()));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isObject(BytecodeGenerator&amp; generator, RegisterID* dst)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);</span>
<span class="line-removed">-     ASSERT(!node-&gt;m_next);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return generator.move(dst, generator.emitIsObject(generator.tempDestination(dst), src.get()));</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isDerivedArray(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);</span>
<span class="line-modified">!     ASSERT(!node-&gt;m_next);</span>
  
<span class="line-modified">!     return generator.move(dst, generator.emitIsDerivedArray(generator.tempDestination(dst), src.get()));</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isMap(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
  {
      ArgumentListNode* node = m_args-&gt;m_listNode;
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);</span>
      ASSERT(!node-&gt;m_next);
  
<span class="line-modified">!     return generator.move(dst, generator.emitIsMap(generator.tempDestination(dst), src.get()));</span>
  }
  
<span class="line-modified">! RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isSet(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
  {
      ArgumentListNode* node = m_args-&gt;m_listNode;
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);</span>
      ASSERT(!node-&gt;m_next);
  
<span class="line-modified">!     return generator.move(dst, generator.emitIsSet(generator.tempDestination(dst), src.get()));</span>
  }
  
<span class="line-modified">! RegisterID* BytecodeIntrinsicNode::emit_intrinsic_isUndefinedOrNull(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
  {
<span class="line-modified">!     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);</span>
<span class="line-modified">!     ASSERT(!node-&gt;m_next);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return generator.move(dst, generator.emitIsUndefinedOrNull(generator.tempDestination(dst), src.get()));</span>
  }
  
<span class="line-modified">! RegisterID* BytecodeIntrinsicNode::emit_intrinsic_newArrayWithSize(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
  {
<span class="line-modified">!     ArgumentListNode* node = m_args-&gt;m_listNode;</span>
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; size = generator.emitNode(node);</span>
<span class="line-removed">-     ASSERT(!node-&gt;m_next);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; finalDestination = generator.finalDestination(dst);</span>
<span class="line-removed">-     generator.emitNewArrayWithSize(finalDestination.get(), size.get());</span>
<span class="line-removed">-     return finalDestination.get();</span>
  }
  
  RegisterID* BytecodeIntrinsicNode::emit_intrinsic_defineEnumerableWritableConfigurableDataProperty(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
  {
      ArgumentListNode* node = m_args-&gt;m_listNode;
<span class="line-new-header">--- 1464,70 ---</span>
      }
  
      return generator.move(dst, generator.emitIdWithProfile(idValue.get(), speculation));
  }
  
<span class="line-modified">! #define CREATE_INTRINSIC_FOR_BRAND_CHECK(lowerName, upperName) \</span>
<span class="line-modified">!     RegisterID* BytecodeIntrinsicNode::emit_intrinsic_##lowerName(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst) \</span>
<span class="line-modified">!     {                                                                                                                      \</span>
<span class="line-modified">!         ArgumentListNode* node = m_args-&gt;m_listNode;                                                                       \</span>
<span class="line-modified">!         RefPtr&lt;RegisterID&gt; src = generator.emitNode(node);                                                                 \</span>
<span class="line-modified">!         ASSERT(!node-&gt;m_next);                                                                                             \</span>
<span class="line-modified">!         return generator.move(dst, generator.emit##upperName(generator.tempDestination(dst), src.get()));                  \</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">! CREATE_INTRINSIC_FOR_BRAND_CHECK(isObject, IsObject)</span>
<span class="line-modified">! CREATE_INTRINSIC_FOR_BRAND_CHECK(isJSArray, IsJSArray)</span>
<span class="line-modified">! CREATE_INTRINSIC_FOR_BRAND_CHECK(isProxyObject, IsProxyObject)</span>
<span class="line-modified">! CREATE_INTRINSIC_FOR_BRAND_CHECK(isDerivedArray, IsDerivedArray)</span>
<span class="line-modified">! CREATE_INTRINSIC_FOR_BRAND_CHECK(isGenerator, IsGenerator)</span>
<span class="line-added">+ CREATE_INTRINSIC_FOR_BRAND_CHECK(isAsyncGenerator, IsAsyncGenerator)</span>
<span class="line-added">+ CREATE_INTRINSIC_FOR_BRAND_CHECK(isPromise, IsPromise)</span>
<span class="line-added">+ CREATE_INTRINSIC_FOR_BRAND_CHECK(isRegExpObject, IsRegExpObject)</span>
<span class="line-added">+ CREATE_INTRINSIC_FOR_BRAND_CHECK(isMap, IsMap)</span>
<span class="line-added">+ CREATE_INTRINSIC_FOR_BRAND_CHECK(isSet, IsSet)</span>
<span class="line-added">+ CREATE_INTRINSIC_FOR_BRAND_CHECK(isStringIterator, IsStringIterator)</span>
<span class="line-added">+ CREATE_INTRINSIC_FOR_BRAND_CHECK(isArrayIterator, IsArrayIterator)</span>
<span class="line-added">+ CREATE_INTRINSIC_FOR_BRAND_CHECK(isUndefinedOrNull, IsUndefinedOrNull)</span>
  
<span class="line-modified">! #undef CREATE_INTRINSIC_FOR_BRAND_CHECK</span>
  
<span class="line-modified">! RegisterID* BytecodeIntrinsicNode::emit_intrinsic_newArrayWithSize(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
  {
      ArgumentListNode* node = m_args-&gt;m_listNode;
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; size = generator.emitNode(node);</span>
      ASSERT(!node-&gt;m_next);
  
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; finalDestination = generator.finalDestination(dst);</span>
<span class="line-added">+     generator.emitNewArrayWithSize(finalDestination.get(), size.get());</span>
<span class="line-added">+     return finalDestination.get();</span>
  }
  
<span class="line-modified">! RegisterID* BytecodeIntrinsicNode::emit_intrinsic_createPromise(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
  {
      ArgumentListNode* node = m_args-&gt;m_listNode;
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; newTarget = generator.emitNode(node);</span>
<span class="line-added">+     node = node-&gt;m_next;</span>
<span class="line-added">+     bool isInternalPromise = static_cast&lt;BooleanNode*&gt;(node-&gt;m_expr)-&gt;value();</span>
      ASSERT(!node-&gt;m_next);
  
<span class="line-modified">!     return generator.emitCreatePromise(generator.finalDestination(dst), newTarget.get(), isInternalPromise);</span>
  }
  
<span class="line-modified">! RegisterID* BytecodeIntrinsicNode::emit_intrinsic_newPromise(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
  {
<span class="line-modified">!     ASSERT(!m_args-&gt;m_listNode);</span>
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; finalDestination = generator.finalDestination(dst);</span>
<span class="line-modified">!     bool isInternalPromise = false;</span>
<span class="line-modified">!     generator.emitNewPromise(finalDestination.get(), isInternalPromise);</span>
<span class="line-modified">!     return finalDestination.get();</span>
  }
  
<span class="line-modified">! RegisterID* BytecodeIntrinsicNode::emit_intrinsic_createArgumentsButterfly(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)</span>
  {
<span class="line-modified">!     ASSERT(!m_args-&gt;m_listNode);</span>
<span class="line-modified">!     return generator.emitCreateArgumentsButterfly(generator.finalDestination(dst));</span>
  }
  
  RegisterID* BytecodeIntrinsicNode::emit_intrinsic_defineEnumerableWritableConfigurableDataProperty(JSC::BytecodeGenerator&amp; generator, JSC::RegisterID* dst)
  {
      ArgumentListNode* node = m_args-&gt;m_listNode;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1602,13 ***</span>
  }
  
  static RegisterID* emitPostIncOrDec(BytecodeGenerator&amp; generator, RegisterID* dst, RegisterID* srcDst, Operator oper)
  {
      if (dst == srcDst)
<span class="line-modified">!         return generator.emitToNumber(generator.finalDestination(dst), srcDst);</span>
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; tmp = generator.emitToNumber(generator.tempDestination(dst), srcDst);</span>
<span class="line-modified">!     emitIncOrDec(generator, srcDst, oper);</span>
      return generator.move(dst, tmp.get());
  }
  
  RegisterID* PostfixNode::emitResolve(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
<span class="line-new-header">--- 1854,16 ---</span>
  }
  
  static RegisterID* emitPostIncOrDec(BytecodeGenerator&amp; generator, RegisterID* dst, RegisterID* srcDst, Operator oper)
  {
      if (dst == srcDst)
<span class="line-modified">!         return generator.emitToNumeric(generator.finalDestination(dst), srcDst);</span>
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; tmp = generator.emitToNumeric(generator.newTemporary(), srcDst);</span>
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; result = generator.tempDestination(srcDst);</span>
<span class="line-added">+     generator.move(result.get(), tmp.get());</span>
<span class="line-added">+     emitIncOrDec(generator, result.get(), oper);</span>
<span class="line-added">+     generator.move(srcDst, result.get());</span>
      return generator.move(dst, tmp.get());
  }
  
  RegisterID* PostfixNode::emitResolve(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1955,11 ***</span>
  
  RegisterID* UnaryOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      RefPtr&lt;RegisterID&gt; src = generator.emitNode(m_expr);
      generator.emitExpressionInfo(position(), position(), position());
<span class="line-modified">!     return generator.emitUnaryOp(opcodeID(), generator.finalDestination(dst), src.get(), OperandTypes(m_expr-&gt;resultDescriptor()));</span>
  }
  
  // ------------------------------ UnaryPlusNode -----------------------------------
  
  RegisterID* UnaryPlusNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
<span class="line-new-header">--- 2210,11 ---</span>
  
  RegisterID* UnaryOpNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      RefPtr&lt;RegisterID&gt; src = generator.emitNode(m_expr);
      generator.emitExpressionInfo(position(), position(), position());
<span class="line-modified">!     return generator.emitUnaryOp(opcodeID(), generator.finalDestination(dst), src.get(), m_expr-&gt;resultDescriptor());</span>
  }
  
  // ------------------------------ UnaryPlusNode -----------------------------------
  
  RegisterID* UnaryPlusNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2802,11 ***</span>
  
  // ------------------------------ DebuggerStatementNode ---------------------------
  
  void DebuggerStatementNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
  {
<span class="line-modified">!     generator.emitDebugHook(DidReachBreakpoint, position());</span>
  }
  
  // ------------------------------ ExprStatementNode ----------------------------
  
  void ExprStatementNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
<span class="line-new-header">--- 3057,11 ---</span>
  
  // ------------------------------ DebuggerStatementNode ---------------------------
  
  void DebuggerStatementNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
  {
<span class="line-modified">!     generator.emitDebugHook(DidReachDebuggerStatement, position());</span>
  }
  
  // ------------------------------ ExprStatementNode ----------------------------
  
  void ExprStatementNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2831,15 ***</span>
      if (!generator.shouldEmitTypeProfilerHooks())
          return nullptr;
  
      Variable var = generator.variable(m_ident);
      if (RegisterID* local = var.local())
<span class="line-modified">!         generator.emitProfileType(local, var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));</span>
      else {
          RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
          RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, DoNotThrowIfNotFound);
<span class="line-modified">!         generator.emitProfileType(value.get(), var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));</span>
      }
  
      return nullptr;
  }
  
<span class="line-new-header">--- 3086,15 ---</span>
      if (!generator.shouldEmitTypeProfilerHooks())
          return nullptr;
  
      Variable var = generator.variable(m_ident);
      if (RegisterID* local = var.local())
<span class="line-modified">!         generator.emitProfileType(local, var, position(), position() + m_ident.length());</span>
      else {
          RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
          RefPtr&lt;RegisterID&gt; value = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, DoNotThrowIfNotFound);
<span class="line-modified">!         generator.emitProfileType(value.get(), var, position(), position() + m_ident.length());</span>
      }
  
      return nullptr;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2850,16 ***</span>
      // Lexical declarations like &#39;let&#39; must move undefined into their variables so we don&#39;t
      // get TDZ errors for situations like this: `let x; x;`
      Variable var = generator.variable(m_ident);
      if (RegisterID* local = var.local()) {
          generator.emitLoad(local, jsUndefined());
<span class="line-modified">!         generator.emitProfileType(local, var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));</span>
      } else {
          RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
          RefPtr&lt;RegisterID&gt; value = generator.emitLoad(nullptr, jsUndefined());
          generator.emitPutToScope(scope.get(), var, value.get(), generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::Initialization);
<span class="line-modified">!         generator.emitProfileType(value.get(), var, position(), JSTextPosition(-1, position().offset + m_ident.length(), -1));</span>
      }
  
      generator.liftTDZCheckIfPossible(var);
  
      // It&#39;s safe to return null here because this node will always be a child node of DeclarationStatement which ignores our return value.
<span class="line-new-header">--- 3105,16 ---</span>
      // Lexical declarations like &#39;let&#39; must move undefined into their variables so we don&#39;t
      // get TDZ errors for situations like this: `let x; x;`
      Variable var = generator.variable(m_ident);
      if (RegisterID* local = var.local()) {
          generator.emitLoad(local, jsUndefined());
<span class="line-modified">!         generator.emitProfileType(local, var, position(), position() + m_ident.length());</span>
      } else {
          RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
          RefPtr&lt;RegisterID&gt; value = generator.emitLoad(nullptr, jsUndefined());
          generator.emitPutToScope(scope.get(), var, value.get(), generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::Initialization);
<span class="line-modified">!         generator.emitProfileType(value.get(), var, position(), position() + m_ident.length());</span>
      }
  
      generator.liftTDZCheckIfPossible(var);
  
      // It&#39;s safe to return null here because this node will always be a child node of DeclarationStatement which ignores our return value.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3072,11 ***</span>
                  generator.emitReadOnlyExceptionIfNeeded(var);
              RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
              generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
              generator.emitPutToScope(scope.get(), var, propertyName, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
          }
<span class="line-modified">!         generator.emitProfileType(propertyName, var, m_lexpr-&gt;position(), JSTextPosition(-1, m_lexpr-&gt;position().offset + ident.length(), -1));</span>
      };
  
      if (m_lexpr-&gt;isResolveNode()) {
          const Identifier&amp; ident = static_cast&lt;ResolveNode*&gt;(m_lexpr)-&gt;identifier();
          lambdaEmitResolveVariable(ident);
<span class="line-new-header">--- 3327,11 ---</span>
                  generator.emitReadOnlyExceptionIfNeeded(var);
              RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
              generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
              generator.emitPutToScope(scope.get(), var, propertyName, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
          }
<span class="line-modified">!         generator.emitProfileType(propertyName, var, m_lexpr-&gt;position(), m_lexpr-&gt;position() + ident.length());</span>
      };
  
      if (m_lexpr-&gt;isResolveNode()) {
          const Identifier&amp; ident = static_cast&lt;ResolveNode*&gt;(m_lexpr)-&gt;identifier();
          lambdaEmitResolveVariable(ident);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3329,11 ***</span>
                      generator.emitReadOnlyExceptionIfNeeded(var);
                  RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
                  generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
                  generator.emitPutToScope(scope.get(), var, value, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
              }
<span class="line-modified">!             generator.emitProfileType(value, var, m_lexpr-&gt;position(), JSTextPosition(-1, m_lexpr-&gt;position().offset + ident.length(), -1));</span>
          } else if (m_lexpr-&gt;isDotAccessorNode()) {
              DotAccessorNode* assignNode = static_cast&lt;DotAccessorNode*&gt;(m_lexpr);
              const Identifier&amp; ident = assignNode-&gt;identifier();
              RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
  
<span class="line-new-header">--- 3584,11 ---</span>
                      generator.emitReadOnlyExceptionIfNeeded(var);
                  RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, var);
                  generator.emitExpressionInfo(divot(), divotStart(), divotEnd());
                  generator.emitPutToScope(scope.get(), var, value, generator.isStrictMode() ? ThrowIfNotFound : DoNotThrowIfNotFound, InitializationMode::NotInitialization);
              }
<span class="line-modified">!             generator.emitProfileType(value, var, m_lexpr-&gt;position(), m_lexpr-&gt;position() + ident.length());</span>
          } else if (m_lexpr-&gt;isDotAccessorNode()) {
              DotAccessorNode* assignNode = static_cast&lt;DotAccessorNode*&gt;(m_lexpr);
              const Identifier&amp; ident = assignNode-&gt;identifier();
              RefPtr&lt;RegisterID&gt; base = generator.emitNode(assignNode-&gt;base());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3912,22 ***</span>
  
          ASSERT(startOffset() &gt;= lineStartOffset());
          generator.emitDebugHook(WillLeaveCallFrame, lastLine(), startOffset(), lineStartOffset());
  
          // load and call @asyncFunctionResume
<span class="line-modified">!         auto var = generator.variable(generator.propertyNames().builtinNames().asyncFunctionResumePrivateName());</span>
<span class="line-removed">-         RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();</span>
<span class="line-removed">-         generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));</span>
<span class="line-removed">-         RefPtr&lt;RegisterID&gt; asyncFunctionResume = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);</span>
  
          CallArguments args(generator, nullptr, 4);
          unsigned argumentCount = 0;
          generator.emitLoad(args.thisRegister(), jsUndefined());
          generator.move(args.argumentRegister(argumentCount++), generator.generatorRegister());
<span class="line-modified">!         generator.move(args.argumentRegister(argumentCount++), generator.promiseCapabilityRegister());</span>
          generator.emitLoad(args.argumentRegister(argumentCount++), jsUndefined());
<span class="line-modified">!         generator.emitLoad(args.argumentRegister(argumentCount++), jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode)));</span>
          // JSTextPosition(int _line, int _offset, int _lineStartOffset)
          JSTextPosition divot(firstLine(), startOffset(), lineStartOffset());
  
          RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
          generator.emitCallInTailPosition(result.get(), asyncFunctionResume.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
<span class="line-new-header">--- 4167,19 ---</span>
  
          ASSERT(startOffset() &gt;= lineStartOffset());
          generator.emitDebugHook(WillLeaveCallFrame, lastLine(), startOffset(), lineStartOffset());
  
          // load and call @asyncFunctionResume
<span class="line-modified">!         RefPtr&lt;RegisterID&gt; asyncFunctionResume = generator.moveLinkTimeConstant(nullptr, LinkTimeConstant::asyncFunctionResume);</span>
  
          CallArguments args(generator, nullptr, 4);
          unsigned argumentCount = 0;
          generator.emitLoad(args.thisRegister(), jsUndefined());
          generator.move(args.argumentRegister(argumentCount++), generator.generatorRegister());
<span class="line-modified">!         generator.move(args.argumentRegister(argumentCount++), generator.promiseRegister());</span>
          generator.emitLoad(args.argumentRegister(argumentCount++), jsUndefined());
<span class="line-modified">!         generator.emitLoad(args.argumentRegister(argumentCount++), jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::NormalMode)));</span>
          // JSTextPosition(int _line, int _offset, int _lineStartOffset)
          JSTextPosition divot(firstLine(), startOffset(), lineStartOffset());
  
          RefPtr&lt;RegisterID&gt; result = generator.newTemporary();
          generator.emitCallInTailPosition(result.get(), asyncFunctionResume.get(), NoExpectedFunction, args, divot, divot, divot, DebuggableCall::No);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3940,15 ***</span>
      case SourceParseMode::AsyncFunctionBodyMode:
      case SourceParseMode::GeneratorBodyMode: {
          Ref&lt;Label&gt; generatorBodyLabel = generator.newLabel();
          {
              RefPtr&lt;RegisterID&gt; condition = generator.newTemporary();
<span class="line-modified">!             generator.emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generator.generatorResumeModeRegister(), generator.emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::NormalMode))));</span>
              generator.emitJumpIfTrue(condition.get(), generatorBodyLabel.get());
  
              Ref&lt;Label&gt; throwLabel = generator.newLabel();
<span class="line-modified">!             generator.emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generator.generatorResumeModeRegister(), generator.emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorResumeMode::ThrowMode))));</span>
              generator.emitJumpIfTrue(condition.get(), throwLabel.get());
  
              generator.emitReturn(generator.generatorValueRegister());
  
              generator.emitLabel(throwLabel.get());
<span class="line-new-header">--- 4192,15 ---</span>
      case SourceParseMode::AsyncFunctionBodyMode:
      case SourceParseMode::GeneratorBodyMode: {
          Ref&lt;Label&gt; generatorBodyLabel = generator.newLabel();
          {
              RefPtr&lt;RegisterID&gt; condition = generator.newTemporary();
<span class="line-modified">!             generator.emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generator.generatorResumeModeRegister(), generator.emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::NormalMode))));</span>
              generator.emitJumpIfTrue(condition.get(), generatorBodyLabel.get());
  
              Ref&lt;Label&gt; throwLabel = generator.newLabel();
<span class="line-modified">!             generator.emitEqualityOp&lt;OpStricteq&gt;(condition.get(), generator.generatorResumeModeRegister(), generator.emitLoad(nullptr, jsNumber(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorResumeMode::ThrowMode))));</span>
              generator.emitJumpIfTrue(condition.get(), throwLabel.get());
  
              generator.emitReturn(generator.generatorValueRegister());
  
              generator.emitLabel(throwLabel.get());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3981,11 ***</span>
          // If there is no return we must automatically insert one.
          if (!returnNode) {
              if (generator.constructorKind() == ConstructorKind::Extends &amp;&amp; generator.needsToUpdateArrowFunctionContext() &amp;&amp; generator.isSuperCallUsedInInnerArrowFunction())
                  generator.emitLoadThisFromArrowFunctionLexicalEnvironment(); // Arrow function can invoke &#39;super&#39; in constructor and before leave constructor we need load &#39;this&#39; from lexical arrow function environment
  
<span class="line-modified">!             RegisterID* r0 = generator.isConstructor() ? generator.thisRegister() : generator.emitLoad(0, jsUndefined());</span>
              generator.emitProfileType(r0, ProfileTypeBytecodeFunctionReturnStatement); // Do not emit expression info for this profile because it&#39;s not in the user&#39;s source code.
              ASSERT(startOffset() &gt;= lineStartOffset());
              generator.emitWillLeaveCallFrameDebugHook();
              generator.emitReturn(r0);
              return;
<span class="line-new-header">--- 4233,15 ---</span>
          // If there is no return we must automatically insert one.
          if (!returnNode) {
              if (generator.constructorKind() == ConstructorKind::Extends &amp;&amp; generator.needsToUpdateArrowFunctionContext() &amp;&amp; generator.isSuperCallUsedInInnerArrowFunction())
                  generator.emitLoadThisFromArrowFunctionLexicalEnvironment(); // Arrow function can invoke &#39;super&#39; in constructor and before leave constructor we need load &#39;this&#39; from lexical arrow function environment
  
<span class="line-modified">!             RegisterID* r0 = nullptr;</span>
<span class="line-added">+             if (generator.isConstructor() &amp;&amp; generator.constructorKind() != ConstructorKind::Naked)</span>
<span class="line-added">+                 r0 = generator.thisRegister();</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 r0 = generator.emitLoad(0, jsUndefined());</span>
              generator.emitProfileType(r0, ProfileTypeBytecodeFunctionReturnStatement); // Do not emit expression info for this profile because it&#39;s not in the user&#39;s source code.
              ASSERT(startOffset() &gt;= lineStartOffset());
              generator.emitWillLeaveCallFrameDebugHook();
              generator.emitReturn(r0);
              return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4032,11 ***</span>
          if (argument()) {
              arg = generator.newTemporary();
              generator.emitNode(arg.get(), argument());
          } else
              arg = generator.emitLoad(nullptr, jsUndefined());
<span class="line-modified">!         RefPtr&lt;RegisterID&gt; value = generator.emitYield(arg.get(), JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Yield);</span>
          if (dst == generator.ignoredResult())
              return nullptr;
          return generator.move(generator.finalDestination(dst), value.get());
      }
      RefPtr&lt;RegisterID&gt; arg = generator.newTemporary();
<span class="line-new-header">--- 4288,11 ---</span>
          if (argument()) {
              arg = generator.newTemporary();
              generator.emitNode(arg.get(), argument());
          } else
              arg = generator.emitLoad(nullptr, jsUndefined());
<span class="line-modified">!         RefPtr&lt;RegisterID&gt; value = generator.emitYield(arg.get(), JSAsyncGenerator::AsyncGeneratorSuspendReason::Yield);</span>
          if (dst == generator.ignoredResult())
              return nullptr;
          return generator.move(generator.finalDestination(dst), value.get());
      }
      RefPtr&lt;RegisterID&gt; arg = generator.newTemporary();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4051,16 ***</span>
  
  RegisterID* AwaitExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      RefPtr&lt;RegisterID&gt; arg = generator.newTemporary();
      generator.emitNode(arg.get(), argument());
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; value = generator.emitYield(arg.get(), JSAsyncGeneratorFunction::AsyncGeneratorSuspendReason::Await);</span>
      if (dst == generator.ignoredResult())
          return nullptr;
      return generator.move(generator.finalDestination(dst), value.get());
  }
  
  // ------------------------------ ClassDeclNode ---------------------------------
  
  void ClassDeclNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
  {
      generator.emitNode(m_classDeclaration);
<span class="line-new-header">--- 4307,58 ---</span>
  
  RegisterID* AwaitExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
      RefPtr&lt;RegisterID&gt; arg = generator.newTemporary();
      generator.emitNode(arg.get(), argument());
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; value = generator.emitYield(arg.get(), JSAsyncGenerator::AsyncGeneratorSuspendReason::Await);</span>
      if (dst == generator.ignoredResult())
          return nullptr;
      return generator.move(generator.finalDestination(dst), value.get());
  }
  
<span class="line-added">+ // ------------------------------ DefineFieldNode ---------------------------------</span>
<span class="line-added">+ </span>
<span class="line-added">+ void DefineFieldNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     RefPtr&lt;RegisterID&gt; value = generator.newTemporary();</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!m_assign)</span>
<span class="line-added">+         generator.emitLoad(value.get(), jsUndefined());</span>
<span class="line-added">+     else {</span>
<span class="line-added">+         generator.emitNode(value.get(), m_assign);</span>
<span class="line-added">+         if (m_ident)</span>
<span class="line-added">+             generator.emitSetFunctionNameIfNeeded(m_assign, value.get(), *m_ident);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     switch (m_type) {</span>
<span class="line-added">+     case DefineFieldNode::Type::Name: {</span>
<span class="line-added">+         // FIXME: Improve performance of public class fields</span>
<span class="line-added">+         // https://bugs.webkit.org/show_bug.cgi?id=198330</span>
<span class="line-added">+         RefPtr&lt;RegisterID&gt; propertyName = generator.emitLoad(nullptr, *m_ident);</span>
<span class="line-added">+         generator.emitCallDefineProperty(generator.thisRegister(), propertyName.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable | BytecodeGenerator::PropertyEnumerable, m_position);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     case DefineFieldNode::Type::ComputedName: {</span>
<span class="line-added">+         // FIXME: Improve performance of public class fields</span>
<span class="line-added">+         // https://bugs.webkit.org/show_bug.cgi?id=198330</span>
<span class="line-added">+ </span>
<span class="line-added">+         // For ComputedNames, the expression has already been evaluated earlier during evaluation of a ClassExprNode.</span>
<span class="line-added">+         // Here, `m_ident` refers to an integer ID in a class lexical scope, containing the value already converted to an Expression.</span>
<span class="line-added">+         Variable var = generator.variable(*m_ident);</span>
<span class="line-added">+         ASSERT_WITH_MESSAGE(!var.local(), &quot;Computed names must be stored in captured variables&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+         generator.emitExpressionInfo(position(), position(), position() + 1);</span>
<span class="line-added">+         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(generator.newTemporary(), var);</span>
<span class="line-added">+         RefPtr&lt;RegisterID&gt; privateName = generator.newTemporary();</span>
<span class="line-added">+         generator.emitGetFromScope(privateName.get(), scope.get(), var, ThrowIfNotFound);</span>
<span class="line-added">+         generator.emitProfileType(privateName.get(), var, m_position, m_position + m_ident-&gt;length());</span>
<span class="line-added">+         generator.emitCallDefineProperty(generator.thisRegister(), privateName.get(), value.get(), nullptr, nullptr, BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable | BytecodeGenerator::PropertyEnumerable, m_position);</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // ------------------------------ ClassDeclNode ---------------------------------
  
  void ClassDeclNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID*)
  {
      generator.emitNode(m_classDeclaration);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4068,11 ***</span>
  
  // ------------------------------ ClassExprNode ---------------------------------
  
  RegisterID* ClassExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
<span class="line-modified">!     if (!m_name.isNull())</span>
          generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested);
  
      RefPtr&lt;RegisterID&gt; superclass;
      if (m_classHeritage) {
          superclass = generator.newTemporary();
<span class="line-new-header">--- 4366,11 ---</span>
  
  // ------------------------------ ClassExprNode ---------------------------------
  
  RegisterID* ClassExprNode::emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst)
  {
<span class="line-modified">!     if (m_needsLexicalScope)</span>
          generator.pushLexicalScope(this, BytecodeGenerator::TDZCheckOptimization::Optimize, BytecodeGenerator::NestedScopeType::IsNested);
  
      RefPtr&lt;RegisterID&gt; superclass;
      if (m_classHeritage) {
          superclass = generator.newTemporary();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4080,19 ***</span>
      }
  
      RefPtr&lt;RegisterID&gt; constructor = generator.tempDestination(dst);
      bool needsHomeObject = false;
  
      if (m_constructorExpression) {
          ASSERT(m_constructorExpression-&gt;isFuncExprNode());
          FunctionMetadataNode* metadata = static_cast&lt;FuncExprNode*&gt;(m_constructorExpression)-&gt;metadata();
          metadata-&gt;setEcmaName(ecmaName());
          metadata-&gt;setClassSource(m_classSource);
          constructor = generator.emitNode(constructor.get(), m_constructorExpression);
          needsHomeObject = m_classHeritage || metadata-&gt;superBinding() == SuperBinding::Needed;
      } else
<span class="line-modified">!         constructor = generator.emitNewDefaultConstructor(constructor.get(), m_classHeritage ? ConstructorKind::Extends : ConstructorKind::Base, m_name, ecmaName(), m_classSource);</span>
  
      const auto&amp; propertyNames = generator.propertyNames();
      RefPtr&lt;RegisterID&gt; prototype = generator.emitNewObject(generator.newTemporary());
  
      if (superclass) {
<span class="line-new-header">--- 4378,22 ---</span>
      }
  
      RefPtr&lt;RegisterID&gt; constructor = generator.tempDestination(dst);
      bool needsHomeObject = false;
  
<span class="line-added">+     auto needsClassFieldInitializer = this-&gt;hasInstanceFields() ? NeedsClassFieldInitializer::Yes : NeedsClassFieldInitializer::No;</span>
<span class="line-added">+ </span>
      if (m_constructorExpression) {
          ASSERT(m_constructorExpression-&gt;isFuncExprNode());
          FunctionMetadataNode* metadata = static_cast&lt;FuncExprNode*&gt;(m_constructorExpression)-&gt;metadata();
          metadata-&gt;setEcmaName(ecmaName());
          metadata-&gt;setClassSource(m_classSource);
<span class="line-added">+         metadata-&gt;setNeedsClassFieldInitializer(needsClassFieldInitializer == NeedsClassFieldInitializer::Yes);</span>
          constructor = generator.emitNode(constructor.get(), m_constructorExpression);
          needsHomeObject = m_classHeritage || metadata-&gt;superBinding() == SuperBinding::Needed;
      } else
<span class="line-modified">!         constructor = generator.emitNewDefaultConstructor(constructor.get(), m_classHeritage ? ConstructorKind::Extends : ConstructorKind::Base, m_name, ecmaName(), m_classSource, needsClassFieldInitializer);</span>
  
      const auto&amp; propertyNames = generator.propertyNames();
      RefPtr&lt;RegisterID&gt; prototype = generator.emitNewObject(generator.newTemporary());
  
      if (superclass) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4134,18 ***</span>
          BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable, m_position);
  
      RefPtr&lt;RegisterID&gt; prototypeNameRegister = generator.emitLoad(nullptr, propertyNames.prototype);
      generator.emitCallDefineProperty(constructor.get(), prototypeNameRegister.get(), prototype.get(), nullptr, nullptr, 0, m_position);
  
<span class="line-modified">!     if (m_classElements)</span>
<span class="line-modified">!         generator.emitDefineClassElements(m_classElements, constructor.get(), prototype.get());</span>
  
<span class="line-modified">!     if (!m_name.isNull()) {</span>
<span class="line-modified">!         Variable classNameVar = generator.variable(m_name);</span>
<span class="line-modified">!         RELEASE_ASSERT(classNameVar.isResolved());</span>
<span class="line-modified">!         RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, classNameVar);</span>
<span class="line-modified">!         generator.emitPutToScope(scope.get(), classNameVar, constructor.get(), ThrowIfNotFound, InitializationMode::Initialization);</span>
          generator.popLexicalScope(this);
      }
  
      return generator.move(generator.finalDestination(dst, constructor.get()), constructor.get());
  }
<span class="line-new-header">--- 4435,31 ---</span>
          BytecodeGenerator::PropertyConfigurable | BytecodeGenerator::PropertyWritable, m_position);
  
      RefPtr&lt;RegisterID&gt; prototypeNameRegister = generator.emitLoad(nullptr, propertyNames.prototype);
      generator.emitCallDefineProperty(constructor.get(), prototypeNameRegister.get(), prototype.get(), nullptr, nullptr, 0, m_position);
  
<span class="line-modified">!     if (m_classElements) {</span>
<span class="line-modified">!         Vector&lt;JSTextPosition&gt; instanceFieldLocations;</span>
<span class="line-added">+         generator.emitDefineClassElements(m_classElements, constructor.get(), prototype.get(), instanceFieldLocations);</span>
<span class="line-added">+         if (!instanceFieldLocations.isEmpty()) {</span>
<span class="line-added">+             RefPtr&lt;RegisterID&gt; instanceFieldInitializer = generator.emitNewInstanceFieldInitializerFunction(generator.newTemporary(), WTFMove(instanceFieldLocations), m_classHeritage);</span>
<span class="line-added">+ </span>
<span class="line-added">+             // FIXME: Skip this if the initializer function isn&#39;t going to need a home object (no eval or super properties)</span>
<span class="line-added">+             // https://bugs.webkit.org/show_bug.cgi?id=196867</span>
<span class="line-added">+             emitPutHomeObject(generator, instanceFieldInitializer.get(), prototype.get());</span>
  
<span class="line-modified">!             generator.emitDirectPutById(constructor.get(), generator.propertyNames().builtinNames().instanceFieldInitializerPrivateName(), instanceFieldInitializer.get(), PropertyNode::Unknown);</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (m_needsLexicalScope) {</span>
<span class="line-added">+         if (!m_name.isNull()) {</span>
<span class="line-added">+             Variable classNameVar = generator.variable(m_name);</span>
<span class="line-added">+             RELEASE_ASSERT(classNameVar.isResolved());</span>
<span class="line-added">+             RefPtr&lt;RegisterID&gt; scope = generator.emitResolveScope(nullptr, classNameVar);</span>
<span class="line-added">+             generator.emitPutToScope(scope.get(), classNameVar, constructor.get(), ThrowIfNotFound, InitializationMode::Initialization);</span>
<span class="line-added">+         }</span>
          generator.popLexicalScope(this);
      }
  
      return generator.move(generator.finalDestination(dst, constructor.get()), constructor.get());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4390,15 ***</span>
  
      RefPtr&lt;RegisterID&gt; excludedList;
      IdentifierSet excludedSet;
      RefPtr&lt;RegisterID&gt; addMethod;
      if (m_containsRestElement &amp;&amp; m_containsComputedProperty) {
<span class="line-modified">!         auto var = generator.variable(generator.propertyNames().builtinNames().SetPrivateName());</span>
<span class="line-removed">- </span>
<span class="line-removed">-         RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();</span>
<span class="line-removed">-         generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));</span>
<span class="line-removed">-         RefPtr&lt;RegisterID&gt; setConstructor = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);</span>
  
          CallArguments args(generator, nullptr, 0);
          excludedList = generator.emitConstruct(generator.newTemporary(), setConstructor.get(), setConstructor.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd());
  
          addMethod = generator.emitGetById(generator.newTemporary(), excludedList.get(), generator.propertyNames().builtinNames().addPrivateName());
<span class="line-new-header">--- 4704,11 ---</span>
  
      RefPtr&lt;RegisterID&gt; excludedList;
      IdentifierSet excludedSet;
      RefPtr&lt;RegisterID&gt; addMethod;
      if (m_containsRestElement &amp;&amp; m_containsComputedProperty) {
<span class="line-modified">!         RefPtr&lt;RegisterID&gt; setConstructor = generator.moveLinkTimeConstant(nullptr, LinkTimeConstant::Set);</span>
  
          CallArguments args(generator, nullptr, 0);
          excludedList = generator.emitConstruct(generator.newTemporary(), setConstructor.get(), setConstructor.get(), NoExpectedFunction, args, divot(), divotStart(), divotEnd());
  
          addMethod = generator.emitGetById(generator.newTemporary(), excludedList.get(), generator.propertyNames().builtinNames().addPrivateName());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4445,15 ***</span>
              ASSERT(target.bindingType == BindingType::RestElement);
              ASSERT(i == m_targetPatterns.size() - 1);
              RefPtr&lt;RegisterID&gt; newObject = generator.emitNewObject(generator.newTemporary());
  
              // load and call @copyDataProperties
<span class="line-modified">!             auto var = generator.variable(generator.propertyNames().builtinNames().copyDataPropertiesPrivateName());</span>
<span class="line-removed">- </span>
<span class="line-removed">-             RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();</span>
<span class="line-removed">-             generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));</span>
<span class="line-removed">-             RefPtr&lt;RegisterID&gt; copyDataProperties = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);</span>
  
              CallArguments args(generator, nullptr, 3);
              generator.emitLoad(args.thisRegister(), jsUndefined());
              generator.move(args.argumentRegister(0), newObject.get());
              generator.move(args.argumentRegister(1), rhs);
<span class="line-new-header">--- 4755,11 ---</span>
              ASSERT(target.bindingType == BindingType::RestElement);
              ASSERT(i == m_targetPatterns.size() - 1);
              RefPtr&lt;RegisterID&gt; newObject = generator.emitNewObject(generator.newTemporary());
  
              // load and call @copyDataProperties
<span class="line-modified">!             RefPtr&lt;RegisterID&gt; copyDataProperties = generator.moveLinkTimeConstant(nullptr, LinkTimeConstant::copyDataProperties);</span>
  
              CallArguments args(generator, nullptr, 3);
              generator.emitLoad(args.thisRegister(), jsUndefined());
              generator.move(args.argumentRegister(0), newObject.get());
              generator.move(args.argumentRegister(1), rhs);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4622,15 ***</span>
  {
      RefPtr&lt;RegisterID&gt; src = generator.newTemporary();
      generator.emitNode(src.get(), m_expression);
  
      // load and call @copyDataPropertiesNoExclusions
<span class="line-modified">!     auto var = generator.variable(generator.propertyNames().builtinNames().copyDataPropertiesNoExclusionsPrivateName());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; scope = generator.newTemporary();</span>
<span class="line-removed">-     generator.move(scope.get(), generator.emitResolveScope(scope.get(), var));</span>
<span class="line-removed">-     RefPtr&lt;RegisterID&gt; copyDataProperties = generator.emitGetFromScope(generator.newTemporary(), scope.get(), var, ThrowIfNotFound);</span>
  
      CallArguments args(generator, nullptr, 2);
      generator.emitLoad(args.thisRegister(), jsUndefined());
      generator.move(args.argumentRegister(0), dst);
      generator.move(args.argumentRegister(1), src.get());
<span class="line-new-header">--- 4928,11 ---</span>
  {
      RefPtr&lt;RegisterID&gt; src = generator.newTemporary();
      generator.emitNode(src.get(), m_expression);
  
      // load and call @copyDataPropertiesNoExclusions
<span class="line-modified">!     RefPtr&lt;RegisterID&gt; copyDataProperties = generator.moveLinkTimeConstant(nullptr, LinkTimeConstant::copyDataPropertiesNoExclusions);</span>
  
      CallArguments args(generator, nullptr, 2);
      generator.emitLoad(args.thisRegister(), jsUndefined());
      generator.move(args.argumentRegister(0), dst);
      generator.move(args.argumentRegister(1), src.get());
</pre>
<center><a href="Label.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RegisterID.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
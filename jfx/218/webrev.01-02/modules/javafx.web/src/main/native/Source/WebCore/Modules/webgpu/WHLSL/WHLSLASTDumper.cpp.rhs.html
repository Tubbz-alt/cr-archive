<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/WHLSLASTDumper.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLASTDumper.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 #include &quot;WHLSLAST.h&quot;
 32 #include &quot;WHLSLProgram.h&quot;
 33 
 34 namespace WebCore {
 35 
 36 namespace WHLSL {
 37 
 38 void ASTDumper::visit(Program&amp; program)
 39 {
 40     m_out.println();
 41 
 42     for (size_t i = 0; i &lt; program.nativeTypeDeclarations().size(); ++i)
 43         visit(program.nativeTypeDeclarations()[i]);
 44     if (program.nativeTypeDeclarations().size())
 45         m_out.print(&quot;\n\n&quot;);
 46 
 47     for (size_t i = 0; i &lt; program.nativeFunctionDeclarations().size(); ++i)
 48         visit(program.nativeFunctionDeclarations()[i]);
 49     if (program.nativeFunctionDeclarations().size())
 50         m_out.print(&quot;\n\n&quot;);
 51 
 52     for (size_t i = 0; i &lt; program.typeDefinitions().size(); ++i)
 53         visit(program.typeDefinitions()[i]);
 54     if (program.typeDefinitions().size())
 55         m_out.print(&quot;\n\n&quot;);
 56 
 57     for (size_t i = 0; i &lt; program.structureDefinitions().size(); ++i)
 58         visit(program.structureDefinitions()[i]);
 59     if (program.structureDefinitions().size())
 60         m_out.print(&quot;\n\n&quot;);
 61 
 62     for (size_t i = 0; i &lt; program.enumerationDefinitions().size(); ++i)
 63         visit(program.enumerationDefinitions()[i]);
 64     if (program.enumerationDefinitions().size())
 65         m_out.print(&quot;\n\n&quot;);
 66 
 67     for (size_t i = 0; i &lt; program.functionDefinitions().size(); ++i)
 68         visit(program.functionDefinitions()[i]);
 69 
 70     m_out.println();
 71 }
 72 
 73 void ASTDumper::visit(AST::UnnamedType&amp; unnamedType)
 74 {
 75     Base::visit(unnamedType);
 76 }
 77 
 78 void ASTDumper::visit(AST::NamedType&amp; namedType)
 79 {
 80     Base::visit(namedType);
 81 }
 82 
 83 void ASTDumper::visit(AST::TypeDefinition&amp; typeDefinition)
 84 {
 85     m_out.print(&quot;typedef &quot;, typeDefinition.name(), &quot; = &quot;);
 86     visit(typeDefinition.type());
 87     m_out.println(&quot;;&quot;);
 88 }
 89 
 90 void ASTDumper::visit(AST::StructureDefinition&amp; structureDefinition)
 91 {
 92     m_out.println(m_indent, &quot;struct &quot;, structureDefinition.name(), &quot; {&quot;);
 93     {
 94         auto indent = bumpIndent();
 95         for (auto&amp; structureElement : structureDefinition.structureElements())
 96             visit(structureElement);
 97     }
 98     m_out.println(m_indent, &quot;}&quot;);
 99     m_out.println();
100 }
101 
102 void ASTDumper::visit(AST::StructureElement&amp; structureElement)
103 {
104     m_out.print(m_indent);
105     visit(structureElement.type());
106     m_out.print(&quot; &quot;, structureElement.name());
107     if (structureElement.semantic())
108         visit(*structureElement.semantic());
109     m_out.println(&quot;;&quot;);
110 }
111 
112 void ASTDumper::visit(AST::EnumerationDefinition&amp; enumerationDefinition)
113 {
114     m_out.print(m_indent, &quot;enum &quot;);
115     visit(enumerationDefinition.type());
116     m_out.print(&quot; {&quot;);
117 
118     {
119         auto indent = bumpIndent();
120         bool once = false;
121         for (auto&amp; enumerationMember : enumerationDefinition.enumerationMembers()) {
122             if (once)
123                 m_out.print(&quot;, &quot;);
124             m_out.println();
125             m_out.print(m_indent);
126             visit(enumerationMember);
127         }
128     }
129 
130     m_out.println();
131     m_out.println(m_indent, &quot;}&quot;);
132     m_out.println();
133 }
134 
135 void ASTDumper::visit(AST::EnumerationMember&amp; enumerationMember)
136 {
137     m_out.print(enumerationMember.name(), &quot; = &quot;, enumerationMember.value());
138 }
139 
140 void ASTDumper::visit(AST::FunctionDefinition&amp; functionDefinition)
141 {
142     m_out.print(m_indent);
143     visit(static_cast&lt;AST::FunctionDeclaration&amp;&gt;(functionDefinition));
144     visit(functionDefinition.block());
145     m_out.print(&quot;\n\n&quot;);
146 }
147 
148 void ASTDumper::visit(AST::NativeFunctionDeclaration&amp; nativeFunctionDeclaration)
149 {
150     m_out.print(m_indent);
151     m_out.print(&quot;native &quot;);
152     visit(static_cast&lt;AST::FunctionDeclaration&amp;&gt;(nativeFunctionDeclaration));
153     m_out.println();
154 }
155 
156 void ASTDumper::visit(AST::FunctionDeclaration&amp; functionDeclaration)
157 {
158     visit(functionDeclaration.attributeBlock());
159     if (functionDeclaration.entryPointType())
160         m_out.print(AST::toString(*functionDeclaration.entryPointType()), &quot; &quot;);
161     visit(functionDeclaration.type());
162     m_out.print(&quot; &quot;, functionDeclaration.name(), &quot;(&quot;);
163     bool once = false;
164     for (auto&amp; parameter : functionDeclaration.parameters()) {
165         if (once)
166             m_out.print(&quot;, &quot;);
167         once = true;
168         visit(parameter);
169     }
170     m_out.print(&quot;)&quot;);
171     if (functionDeclaration.semantic())
172         visit(*functionDeclaration.semantic());
173     m_out.print(&quot; &quot;);
174 }
175 
176 void ASTDumper::visit(AST::NativeTypeDeclaration&amp; nativeTypeDeclaration)
177 {
178     m_out.print(m_indent, &quot;native typedef &quot;);
179     m_out.print(nativeTypeDeclaration.name());
180     if (nativeTypeDeclaration.typeArguments().size()) {
181         m_out.print(&quot;&lt;&quot;);
182         bool once = false;
183         for (auto&amp; typeArgument : nativeTypeDeclaration.typeArguments()) {
184             if (once)
185                 m_out.print(&quot;, &quot;);
186             once = true;
187             visit(typeArgument);
188         }
189         m_out.print(&quot;&gt;&quot;);
190     }
191     m_out.println(&quot;;&quot;);
192 }
193 
194 void ASTDumper::visit(AST::TypeReference&amp; typeReference)
195 {
196     m_out.print(typeReference.name());
197 
198     if (typeReference.typeArguments().size()) {
199         bool once = false;
200         m_out.print(&quot;&lt;&quot;);
201         for (auto&amp; typeArgument : typeReference.typeArguments()) {
202             if (once)
203                 m_out.print(&quot;, &quot;);
204             once = true;
205             visit(typeArgument);
206         }
207         m_out.print(&quot;&gt;&quot;);
208     }
209 }
210 
211 void ASTDumper::visit(AST::PointerType&amp; pointerType)
212 {
213     visit(static_cast&lt;AST::ReferenceType&amp;&gt;(pointerType));
214     m_out.print(&quot;*&quot;);
215 }
216 
217 void ASTDumper::visit(AST::ArrayReferenceType&amp; arrayReferenceType)
218 {
219     visit(static_cast&lt;AST::ReferenceType&amp;&gt;(arrayReferenceType));
220     m_out.print(&quot;[]&quot;);
221 }
222 
223 void ASTDumper::visit(AST::ArrayType&amp; arrayType)
224 {
225     visit(arrayType.type());
226     m_out.print(&quot;[&quot;, arrayType.numElements(), &quot;]&quot;);
227 }
228 
229 void ASTDumper::visit(AST::TypeArgument&amp; typeArgument)
230 {
231     Base::visit(typeArgument);
232 }
233 
234 void ASTDumper::visit(AST::ReferenceType&amp; referenceType)
235 {
236     m_out.print(AST::toString(referenceType.addressSpace()), &quot; &quot;);
237     visit(referenceType.elementType());
238 }
239 
240 void ASTDumper::visit(AST::Semantic&amp; semantic)
241 {
242     m_out.print(&quot; : &quot;);
243     WTF::visit(WTF::makeVisitor([&amp;](AST::BuiltInSemantic&amp; builtInSemantic) {
244         visit(builtInSemantic);
245     }, [&amp;](AST::ResourceSemantic&amp; resourceSemantic) {
246         visit(resourceSemantic);
247     }, [&amp;](AST::SpecializationConstantSemantic&amp; specializationConstantSemantic) {
248         visit(specializationConstantSemantic);
249     }, [&amp;](AST::StageInOutSemantic&amp; stageInOutSemantic) {
250         visit(stageInOutSemantic);
251     }), semantic);
252 }
253 
254 void ASTDumper::visit(AST::ConstantExpression&amp; constantExpression)
255 {
256     Base::visit(constantExpression);
257 }
258 
259 void ASTDumper::visit(AST::AttributeBlock&amp; attributeBlock)
260 {
261     if (attributeBlock.isEmpty())
262         return;
263 
264     m_out.print(&quot;[&quot;);
265     for (auto&amp; functionAttribute : attributeBlock)
266         visit(functionAttribute);
267     m_out.print(&quot;] &quot;);
268 }
269 
270 void ASTDumper::visit(AST::BuiltInSemantic&amp; builtInSemantic)
271 {
272     m_out.print(builtInSemantic.toString());
273 }
274 
275 void ASTDumper::visit(AST::ResourceSemantic&amp; resourceSemantic)
276 {
277     m_out.print(resourceSemantic.toString());
278 }
279 
280 void ASTDumper::visit(AST::SpecializationConstantSemantic&amp;)
281 {
282     // FIXME: Handle this when we implement it.
283 }
284 
285 void ASTDumper::visit(AST::StageInOutSemantic&amp; stageInOutSemantic)
286 {
287     m_out.print(&quot;attribute(&quot;, stageInOutSemantic.index(), &quot;)&quot;);
288 }
289 
290 void ASTDumper::visit(AST::IntegerLiteral&amp; integerLiteral)
291 {
292     m_out.print(integerLiteral.value());
293 }
294 
295 void ASTDumper::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
296 {
297     m_out.print(unsignedIntegerLiteral.value());
298 }
299 
300 void ASTDumper::visit(AST::FloatLiteral&amp; floatLiteral)
301 {
302     m_out.print(floatLiteral.value());
303 }
304 
<a name="1" id="anc1"></a>





305 void ASTDumper::visit(AST::BooleanLiteral&amp; booleanLiteral)
306 {
307     if (booleanLiteral.value())
308         m_out.print(&quot;true&quot;);
309     else
310         m_out.print(&quot;false&quot;);
311 }
312 
313 void ASTDumper::visit(AST::IntegerLiteralType&amp;)
314 {
315 }
316 
317 void ASTDumper::visit(AST::UnsignedIntegerLiteralType&amp;)
318 {
319 }
320 
321 void ASTDumper::visit(AST::FloatLiteralType&amp;)
322 {
323 }
324 
<a name="2" id="anc2"></a>



325 void ASTDumper::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
326 {
327     m_out.print(enumerationMemberLiteral.left(), &quot;.&quot;, enumerationMemberLiteral.right());
328 }
329 
330 void ASTDumper::visit(AST::FunctionAttribute&amp; functionAttribute)
331 {
332     WTF::visit(WTF::makeVisitor([&amp;](AST::NumThreadsFunctionAttribute&amp; numThreadsFunctionAttribute) {
333         visit(numThreadsFunctionAttribute);
334     }), functionAttribute);
335 }
336 
337 void ASTDumper::visit(AST::NumThreadsFunctionAttribute&amp; numThreadsAttribute)
338 {
339     m_out.print(&quot;numthreads(&quot;, numThreadsAttribute.width(), &quot;, &quot;, numThreadsAttribute.height(), &quot;, &quot;, numThreadsAttribute.depth(), &quot;)&quot;);
340 }
341 
342 void ASTDumper::visit(AST::Block&amp; block)
343 {
344     m_out.println(&quot;{&quot;);
345     {
346         auto indent = bumpIndent();
347         for (auto&amp; statement : block.statements()) {
348             m_out.print(m_indent);
349             visit(statement);
350             m_out.println(&quot;;&quot;);
351         }
352     }
353     m_out.print(m_indent, &quot;}&quot;);
354 }
355 
356 void ASTDumper::visit(AST::Statement&amp; statement)
357 {
358     Base::visit(statement);
359 }
360 
361 void ASTDumper::visit(AST::StatementList&amp; statementList)
362 {
363     bool once = false;
364     for (auto&amp; statement : statementList.statements()) {
365         if (once)
366             m_out.print(&quot;;\n&quot;, m_indent);
367         once = true;
368         visit(statement);
369     }
370 }
371 
372 void ASTDumper::visit(AST::Break&amp;)
373 {
374     m_out.print(&quot;break&quot;);
375 }
376 
377 void ASTDumper::visit(AST::Continue&amp;)
378 {
379     m_out.print(&quot;continue&quot;);
380 }
381 
382 void ASTDumper::visit(AST::WhileLoop&amp; whileLoop)
383 {
384     m_out.print(&quot;while (&quot;);
385     visit(whileLoop.conditional());
386     m_out.print(&quot;)&quot;);
387     visit(whileLoop.body());
388 }
389 
390 void ASTDumper::visit(AST::DoWhileLoop&amp; doWhileLoop)
391 {
392     m_out.print(&quot;do &quot;);
393     visit(doWhileLoop.body());
394     m_out.print(&quot; while(&quot;);
395     visit(doWhileLoop.conditional());
396     m_out.print(&quot;)&quot;);
397 }
398 
399 void ASTDumper::visit(AST::ForLoop&amp; forLoop)
400 {
401     m_out.print(&quot;for (&quot;);
402     visit(forLoop.initialization());
403     m_out.print(&quot;; &quot;);
404     if (forLoop.condition())
405         visit(*forLoop.condition());
406     m_out.print(&quot;; &quot;);
407     if (forLoop.increment())
408         visit(*forLoop.increment());
409     m_out.print(&quot;) &quot;);
410     visit(forLoop.body());
411 }
412 
413 void ASTDumper::visit(AST::Expression&amp; expression)
414 {
415     bool skipParens = is&lt;AST::BooleanLiteral&gt;(expression)
416         || is&lt;AST::FloatLiteral&gt;(expression)
417         || is&lt;AST::IntegerLiteral&gt;(expression)
<a name="3" id="anc3"></a>
418         || is&lt;AST::UnsignedIntegerLiteral&gt;(expression)
419         || is&lt;AST::EnumerationMemberLiteral&gt;(expression)
420         || is&lt;AST::CommaExpression&gt;(expression)
421         || is&lt;AST::VariableReference&gt;(expression);
422 
423     if (auto* annotation = expression.maybeTypeAnnotation()) {
424         if (auto addressSpace = annotation-&gt;leftAddressSpace())
425             m_out.print(&quot;&lt;LV:&quot;, AST::toString(*addressSpace));
426         else if (annotation-&gt;isAbstractLeftValue())
427             m_out.print(&quot;&lt;ALV&quot;);
428         else if (annotation-&gt;isRightValue())
429             m_out.print(&quot;&lt;RV&quot;);
430 
431         m_out.print(&quot;, &quot;, expression.resolvedType().toString(), &quot;&gt;&quot;);
432 
433         skipParens = false;
434     }
435 
436     if (!skipParens)
437         m_out.print(&quot;(&quot;);
438     Base::visit(expression);
439     if (!skipParens)
440         m_out.print(&quot;)&quot;);
441 }
442 
443 void ASTDumper::visit(AST::DotExpression&amp; dotExpression)
444 {
445     visit(static_cast&lt;AST::PropertyAccessExpression&amp;&gt;(dotExpression));
446     m_out.print(&quot;.&quot;, dotExpression.fieldName());
447 }
448 
449 void ASTDumper::visit(AST::GlobalVariableReference&amp; globalVariableReference)
450 {
451     visit(globalVariableReference.base());
452     m_out.print(&quot;=&gt;&quot;, globalVariableReference.structField().name());
453 }
454 
455 void ASTDumper::visit(AST::IndexExpression&amp; indexExpression)
456 {
457     visit(static_cast&lt;AST::PropertyAccessExpression&amp;&gt;(indexExpression));
458     m_out.print(&quot;[&quot;);
459     visit(indexExpression.indexExpression());
460     m_out.print(&quot;]&quot;);
461 }
462 
463 void ASTDumper::visit(AST::PropertyAccessExpression&amp; expression)
464 {
465     Base::visit(expression);
466 }
467 
468 void ASTDumper::visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement)
469 {
470     Base::visit(effectfulExpressionStatement);
471 }
472 
473 void ASTDumper::visit(AST::Fallthrough&amp;)
474 {
475     m_out.print(&quot;fallthrough&quot;);
476 }
477 
478 void ASTDumper::visit(AST::IfStatement&amp; ifStatement)
479 {
480     m_out.print(&quot;if (&quot;);
481     visit(ifStatement.conditional());
482     m_out.print(&quot;) &quot;);
483     visit(ifStatement.body());
484     if (ifStatement.elseBody()) {
485         m_out.print(&quot; else &quot;);
486         visit(*ifStatement.elseBody());
487     }
488 }
489 
490 void ASTDumper::visit(AST::Return&amp; returnStatement)
491 {
492     m_out.print(&quot;return&quot;);
493     if (returnStatement.value()) {
494         m_out.print(&quot; &quot;);
495         visit(*returnStatement.value());
496     }
497 }
498 
499 void ASTDumper::visit(AST::SwitchStatement&amp; switchStatement)
500 {
501     m_out.print(&quot;switch (&quot;);
502     visit(switchStatement.value());
503     m_out.println(&quot;) {&quot;);
504     bool once = false;
505     for (auto&amp; switchCase : switchStatement.switchCases()) {
506         if (once)
507             m_out.println();
508         once = true;
509         m_out.print(m_indent);
510         visit(switchCase);
511     }
512     m_out.print(&quot;\n&quot;, m_indent, &quot;}&quot;);
513 
514 }
515 
516 void ASTDumper::visit(AST::SwitchCase&amp; switchCase)
517 {
518     if (switchCase.value()) {
519         m_out.print(&quot;case &quot;);
520         visit(*switchCase.value());
521         m_out.print(&quot;: &quot;);
522     } else
523         m_out.print(&quot;default: &quot;);
524     visit(switchCase.block());
525 }
526 
527 void ASTDumper::visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement)
528 {
529     Base::visit(variableDeclarationsStatement);
530 }
531 
532 void ASTDumper::visit(AST::VariableDeclaration&amp; variableDeclaration)
533 {
534     if (variableDeclaration.type()) {
535         visit(*variableDeclaration.type());
536         m_out.print(&quot; &quot;);
537     }
538 
539     if (variableDeclaration.name().isEmpty())
540         m_out.print(&quot;$&quot;, RawPointer(&amp;variableDeclaration));
541     else
542         m_out.print(variableDeclaration.name());
543 
544     if (variableDeclaration.semantic())
545         visit(*variableDeclaration.semantic());
546     if (variableDeclaration.initializer()) {
547         m_out.print(&quot; = &quot;);
548         visit(*variableDeclaration.initializer());
549     }
550 }
551 
552 void ASTDumper::visit(AST::AssignmentExpression&amp; assignmentExpression)
553 {
554     visit(assignmentExpression.left());
555     m_out.print(&quot; = &quot;);
556     visit(assignmentExpression.right());
557 }
558 
559 void ASTDumper::visit(AST::CallExpression&amp; callExpression)
560 {
561     m_out.print(callExpression.name(), &quot;(&quot;);
562     bool once = false;
563     for (auto&amp; argument : callExpression.arguments()) {
564         if (once)
565             m_out.print(&quot;, &quot;);
566         once = true;
567         visit(argument);
568     }
569     m_out.print(&quot;)&quot;);
570 }
571 
572 void ASTDumper::visit(AST::CommaExpression&amp; commaExpression)
573 {
574     m_out.print(&quot;(&quot;);
575     bool once = false;
576     for (auto&amp; expression : commaExpression.list()) {
577         if (once)
578             m_out.print(&quot;, &quot;);
579         once = true;
580         visit(expression);
581     }
582     m_out.print(&quot;)&quot;);
583 }
584 
585 void ASTDumper::visit(AST::DereferenceExpression&amp; dereferenceExpression)
586 {
587     m_out.print(&quot;*&quot;);
588     visit(dereferenceExpression.pointer());
589 }
590 
591 void ASTDumper::visit(AST::LogicalExpression&amp; logicalExpression)
592 {
593     m_out.print(&quot;(&quot;);
594     visit(logicalExpression.left());
595     switch (logicalExpression.type()) {
596     case AST::LogicalExpression::Type::And:
597         m_out.print(&quot; &amp;&amp; &quot;);
598         break;
599     case AST::LogicalExpression::Type::Or:
600         m_out.print(&quot; || &quot;);
601         break;
602     }
603     visit(logicalExpression.right());
604     m_out.print(&quot;)&quot;);
605 }
606 
607 void ASTDumper::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
608 {
609     m_out.print(&quot;!(&quot;);
610     visit(logicalNotExpression.operand());
611     m_out.print(&quot;)&quot;);
612 }
613 
614 void ASTDumper::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
615 {
616     m_out.print(&quot;@&quot;);
617     visit(makeArrayReferenceExpression.leftValue());
618 }
619 
620 void ASTDumper::visit(AST::MakePointerExpression&amp; makePointerExpression)
621 {
622     m_out.print(&quot;&amp;&quot;);
623     visit(makePointerExpression.leftValue());
624 }
625 
626 void ASTDumper::visit(AST::ReadModifyWriteExpression&amp; readModifyWriteExpression)
627 {
628     auto oldVariable = readModifyWriteExpression.oldVariableReference();
629     auto newVariable = readModifyWriteExpression.newVariableReference();
630 
631     m_out.print(&quot;RMW(&quot;);
632     visit(oldVariable.get());
633     m_out.print(&quot; = &quot;);
634     visit(readModifyWriteExpression.leftValue());
635     m_out.print(&quot;, &quot;);
636 
637     visit(newVariable.get());
638     m_out.print(&quot; = &quot;);
639     visit(readModifyWriteExpression.newValueExpression());
640     m_out.print(&quot;, &quot;);
641 
642     visit(readModifyWriteExpression.leftValue());
643     m_out.print(&quot; = &quot;);
644     visit(newVariable.get());
645     m_out.print(&quot;, &quot;);
646 
647     visit(readModifyWriteExpression.resultExpression());
648     m_out.print(&quot;)&quot;);
649 }
650 
651 void ASTDumper::visit(AST::TernaryExpression&amp; ternaryExpression)
652 {
653     visit(ternaryExpression.predicate());
654     m_out.print(&quot; ? &quot;);
655     visit(ternaryExpression.bodyExpression());
656     m_out.print(&quot; : &quot;);
657     visit(ternaryExpression.elseExpression());
658 }
659 
660 void ASTDumper::visit(AST::VariableReference&amp; variableReference)
661 {
662     if (variableReference.name().isEmpty())
663         m_out.print(&quot;$&quot;, RawPointer(variableReference.variable()));
664     else
665         m_out.print(variableReference.name());
666 }
667 
668 } // namespace WHLSL
669 
670 } // namespace WebCore
671 
672 #endif
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
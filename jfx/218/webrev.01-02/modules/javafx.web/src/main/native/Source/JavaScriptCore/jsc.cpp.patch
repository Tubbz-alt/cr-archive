diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/jsc.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/jsc.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/jsc.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/jsc.cpp
@@ -25,13 +25,15 @@
 #include "ArrayBuffer.h"
 #include "ArrayPrototype.h"
 #include "BuiltinNames.h"
 #include "ButterflyInlines.h"
 #include "BytecodeCacheError.h"
+#include "CallFrameInlines.h"
 #include "CatchScope.h"
 #include "CodeBlock.h"
 #include "CodeCache.h"
+#include "CompilerTimingScope.h"
 #include "Completion.h"
 #include "ConfigFile.h"
 #include "Disassembler.h"
 #include "Exception.h"
 #include "ExceptionHelpers.h"
@@ -44,34 +46,35 @@
 #include "JSArrayBuffer.h"
 #include "JSBigInt.h"
 #include "JSCInlines.h"
 #include "JSFunction.h"
 #include "JSInternalPromise.h"
-#include "JSInternalPromiseDeferred.h"
 #include "JSLock.h"
 #include "JSModuleLoader.h"
 #include "JSNativeStdFunction.h"
 #include "JSONObject.h"
+#include "JSObjectInlines.h"
 #include "JSSourceCode.h"
 #include "JSString.h"
 #include "JSTypedArrays.h"
 #include "JSWebAssemblyInstance.h"
 #include "JSWebAssemblyMemory.h"
 #include "LLIntThunks.h"
 #include "ObjectConstructor.h"
 #include "ParserError.h"
 #include "ProfilerDatabase.h"
-#include "PromiseDeferredTimer.h"
+#include "PromiseTimer.h"
 #include "ProtoCallFrame.h"
 #include "ReleaseHeapAccessScope.h"
 #include "SamplingProfiler.h"
 #include "StackVisitor.h"
 #include "StructureInlines.h"
 #include "StructureRareDataInlines.h"
 #include "SuperSampler.h"
 #include "TestRunnerUtils.h"
 #include "TypedArrayInlines.h"
+#include "VMInspector.h"
 #include "WasmCapabilities.h"
 #include "WasmContext.h"
 #include "WasmFaultSignalHandler.h"
 #include "WasmMemory.h"
 #include <locale.h>
@@ -82,10 +85,11 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 #include <thread>
 #include <type_traits>
 #include <wtf/Box.h>
+#include <wtf/CPUTime.h>
 #include <wtf/CommaPrinter.h>
 #include <wtf/FileSystem.h>
 #include <wtf/MainThread.h>
 #include <wtf/MemoryPressureHandler.h>
 #include <wtf/MonotonicTime.h>
@@ -130,17 +134,22 @@
 #include <crtdbg.h>
 #include <mmsystem.h>
 #include <windows.h>
 #endif
 
-#if PLATFORM(IOS_FAMILY) && CPU(ARM_THUMB2)
+#if OS(DARWIN) && CPU(ARM_THUMB2)
 #include <fenv.h>
 #include <arm/arch.h>
 #endif
 
 #if OS(DARWIN)
 #include <wtf/spi/darwin/ProcessMemoryFootprint.h>
+#elif OS(LINUX)
+#include <wtf/linux/ProcessMemoryFootprint.h>
+#endif
+
+#if OS(DARWIN) || OS(LINUX)
 struct MemoryFootprint : ProcessMemoryFootprint {
     MemoryFootprint(const ProcessMemoryFootprint& src)
         : ProcessMemoryFootprint(src)
     {
     }
@@ -193,11 +202,11 @@
         : Base(vm, structure)
     {
     }
 
     typedef JSNonFinalObject Base;
-    static const unsigned StructureFlags = Base::StructureFlags | JSC::MasqueradesAsUndefined;
+    static constexpr unsigned StructureFlags = Base::StructureFlags | JSC::MasqueradesAsUndefined;
 
     static Masquerader* create(VM& vm, JSGlobalObject* globalObject)
     {
         globalObject->masqueradesAsUndefinedWatchpoint()->fireAll(vm, "Masquerading object allocated");
         Structure* structure = createStructure(vm, globalObject, jsNull());
@@ -228,11 +237,11 @@
 class GlobalObject;
 class Workers;
 
 template<typename Func>
 int runJSC(const CommandLine&, bool isWorker, const Func&);
-static void checkException(ExecState*, GlobalObject*, bool isLastFile, bool hasException, JSValue, CommandLine&, bool& success);
+static void checkException(GlobalObject*, bool isLastFile, bool hasException, JSValue, CommandLine&, bool& success);
 
 class Message : public ThreadSafeRefCounted<Message> {
 public:
     Message(ArrayBufferContents&&, int32_t);
     ~Message();
@@ -286,107 +295,106 @@
     SentinelLinkedList<Worker, BasicRawSentinelNode<Worker>> m_workers;
     Deque<String> m_reports;
 };
 
 
-static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState*);
-
-static EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDebug(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionJSCStack(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionGCAndSweep(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionFullGC(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionForceGCSlowPaths(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionHeapSize(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionAddressOf(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionVersion(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionRun(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionRunString(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionLoad(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionLoadString(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionReadFile(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionCheckSyntax(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionReadline(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionNoDFG(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionNoFTL(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(ExecState*);
-static NO_RETURN_WITH_VALUE EncodedJSValue JSC_HOST_CALL functionQuit(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionFalse(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionUndefined1(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionUndefined2(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionIsInt32(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionIsPureNaN(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionEffectful42(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionIdentity(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(ExecState*);
+static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(JSGlobalObject*, CallFrame*);
+
+static EncodedJSValue JSC_HOST_CALL functionPrintStdOut(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionPrintStdErr(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionDebug(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionDescribe(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionDescribeArray(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionSleepSeconds(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionJSCStack(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionGCAndSweep(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionFullGC(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionEdenGC(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionHeapSize(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionAddressOf(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionVersion(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionRun(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionRunString(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionLoad(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionLoadString(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionReadFile(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionCheckSyntax(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionReadline(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionPreciseTime(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionNoDFG(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionNoFTL(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionCallerIsOMGCompiled(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionJSCOptions(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(JSGlobalObject*, CallFrame*);
+static NO_RETURN_WITH_VALUE EncodedJSValue JSC_HOST_CALL functionQuit(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionFalse(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionUndefined1(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionUndefined2(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionIsInt32(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionIsPureNaN(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionEffectful42(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionIdentity(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(JSGlobalObject*, CallFrame*);
 #if ENABLE(SAMPLING_PROFILER)
-static EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(ExecState*);
+static EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(JSGlobalObject*, CallFrame*);
 #endif
 
-static EncodedJSValue JSC_HOST_CALL functionMaxArguments(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(ExecState*);
+static EncodedJSValue JSC_HOST_CALL functionMaxArguments(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(JSGlobalObject*, CallFrame*);
 
 #if ENABLE(WEBASSEMBLY)
-static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState*);
+static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(JSGlobalObject*, CallFrame*);
 #endif
 
 #if ENABLE(SAMPLING_FLAGS)
-static EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(ExecState*);
+static EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(JSGlobalObject*, CallFrame*);
 #endif
 
-static EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionIsRope(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionWaitForReport(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionMallocInALoop(ExecState*);
-static EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(ExecState*);
-
-static EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(ExecState*);
+static EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionIsRope(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionWaitForReport(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionHeapCapacity(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionMallocInALoop(JSGlobalObject*, CallFrame*);
+static EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(JSGlobalObject*, CallFrame*);
+
+static EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(JSGlobalObject*, CallFrame*);
 
 struct Script {
     enum class StrictMode {
         Strict,
         Sloppy
@@ -476,11 +484,11 @@
 static inline String stringFromUTF(const Vector& utf8)
 {
     return String::fromUTF8WithLatin1Fallback(utf8.data(), utf8.size());
 }
 
-class GlobalObject : public JSGlobalObject {
+class GlobalObject final : public JSGlobalObject {
 private:
     GlobalObject(VM&, Structure*);
 
 public:
     typedef JSGlobalObject Base;
@@ -490,12 +498,10 @@
         GlobalObject* object = new (NotNull, allocateCell<GlobalObject>(vm.heap)) GlobalObject(vm, structure);
         object->finishCreation(vm, arguments);
         return object;
     }
 
-    static const bool needsDestruction = false;
-
     DECLARE_INFO;
     static const GlobalObjectMethodTable s_globalObjectMethodTable;
 
     static Structure* createStructure(VM& vm, JSValue prototype)
     {
@@ -516,11 +522,10 @@
         addFunction(vm, "printErr", functionPrintStdErr, 1);
         addFunction(vm, "quit", functionQuit, 0);
         addFunction(vm, "gc", functionGCAndSweep, 0);
         addFunction(vm, "fullGC", functionFullGC, 0);
         addFunction(vm, "edenGC", functionEdenGC, 0);
-        addFunction(vm, "forceGCSlowPaths", functionForceGCSlowPaths, 0);
         addFunction(vm, "gcHeapSize", functionHeapSize, 0);
         addFunction(vm, "MemoryFootprint", functionCreateMemoryFootprint, 0);
         addFunction(vm, "resetMemoryPeak", functionResetMemoryPeak, 0);
         addFunction(vm, "addressOf", functionAddressOf, 1);
         addFunction(vm, "version", functionVersion, 1);
@@ -539,10 +544,11 @@
         addFunction(vm, "noInline", functionNeverInlineFunction, 1);
         addFunction(vm, "noDFG", functionNoDFG, 1);
         addFunction(vm, "noFTL", functionNoFTL, 1);
         addFunction(vm, "noOSRExitFuzzing", functionNoOSRExitFuzzing, 1);
         addFunction(vm, "numberOfDFGCompiles", functionNumberOfDFGCompiles, 1);
+        addFunction(vm, "callerIsOMGCompiled", functionCallerIsOMGCompiled, 0);
         addFunction(vm, "jscOptions", functionJSCOptions, 0);
         addFunction(vm, "optimizeNextInvocation", functionOptimizeNextInvocation, 1);
         addFunction(vm, "reoptimizationRetryCount", functionReoptimizationRetryCount, 1);
         addFunction(vm, "transferArrayBuffer", functionTransferArrayBuffer, 1);
         addFunction(vm, "failNextNewCodeBlock", functionFailNextNewCodeBlock, 1);
@@ -596,13 +602,13 @@
 #if ENABLE(WEBASSEMBLY)
         addFunction(vm, "WebAssemblyMemoryMode", functionWebAssemblyMemoryMode, 1);
 #endif
 
         if (!arguments.isEmpty()) {
-            JSArray* array = constructEmptyArray(globalExec(), 0);
+            JSArray* array = constructEmptyArray(this, 0);
             for (size_t i = 0; i < arguments.size(); ++i)
-                array->putDirectIndex(globalExec(), i, jsString(vm, arguments[i]));
+                array->putDirectIndex(this, i, jsString(vm, arguments[i]));
             putDirect(vm, Identifier::fromString(vm, "arguments"), array);
         }
 
         putDirect(vm, Identifier::fromString(vm, "console"), jsUndefined());
 
@@ -611,11 +617,11 @@
         JSObject* dollar = JSFinalObject::create(vm, plainObjectStructure);
         putDirect(vm, Identifier::fromString(vm, "$"), dollar);
         putDirect(vm, Identifier::fromString(vm, "$262"), dollar);
 
         addFunction(vm, dollar, "createRealm", functionDollarCreateRealm, 0);
-        addFunction(vm, dollar, "detachArrayBuffer", functionDollarDetachArrayBuffer, 1);
+        addFunction(vm, dollar, "detachArrayBuffer", functionTransferArrayBuffer, 1);
         addFunction(vm, dollar, "evalScript", functionDollarEvalScript, 1);
 
         dollar->putDirect(vm, Identifier::fromString(vm, "global"), this);
 
         JSObject* agent = JSFinalObject::create(vm, plainObjectStructure);
@@ -653,15 +659,16 @@
     void addFunction(VM& vm, const char* name, NativeFunction function, unsigned arguments)
     {
         addFunction(vm, this, name, function, arguments);
     }
 
-    static JSInternalPromise* moduleLoaderImportModule(JSGlobalObject*, ExecState*, JSModuleLoader*, JSString*, JSValue, const SourceOrigin&);
-    static Identifier moduleLoaderResolve(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);
-    static JSInternalPromise* moduleLoaderFetch(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSValue, JSValue);
-    static JSObject* moduleLoaderCreateImportMetaProperties(JSGlobalObject*, ExecState*, JSModuleLoader*, JSValue, JSModuleRecord*, JSValue);
+    static JSInternalPromise* moduleLoaderImportModule(JSGlobalObject*, JSModuleLoader*, JSString*, JSValue, const SourceOrigin&);
+    static Identifier moduleLoaderResolve(JSGlobalObject*, JSModuleLoader*, JSValue, JSValue, JSValue);
+    static JSInternalPromise* moduleLoaderFetch(JSGlobalObject*, JSModuleLoader*, JSValue, JSValue, JSValue);
+    static JSObject* moduleLoaderCreateImportMetaProperties(JSGlobalObject*, JSModuleLoader*, JSValue, JSModuleRecord*, JSValue);
 };
+STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(GlobalObject, JSGlobalObject);
 
 static bool supportsRichSourceInfo = true;
 static bool shellSupportsRichSourceInfo(const JSGlobalObject*)
 {
     return supportsRichSourceInfo;
@@ -814,81 +821,81 @@
     if (!directoryName)
         return fileName;
     return resolvePath(directoryName.value(), ModuleName(fileName.impl()));
 }
 
-JSInternalPromise* GlobalObject::moduleLoaderImportModule(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSString* moduleNameValue, JSValue parameters, const SourceOrigin& sourceOrigin)
+JSInternalPromise* GlobalObject::moduleLoaderImportModule(JSGlobalObject* globalObject, JSModuleLoader*, JSString* moduleNameValue, JSValue parameters, const SourceOrigin& sourceOrigin)
 {
     VM& vm = globalObject->vm();
     auto throwScope = DECLARE_THROW_SCOPE(vm);
 
-    auto* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);
-    RETURN_IF_EXCEPTION(throwScope, nullptr);
+    auto* promise = JSInternalPromise::create(vm, globalObject->internalPromiseStructure());
 
     auto catchScope = DECLARE_CATCH_SCOPE(vm);
     auto reject = [&] (JSValue rejectionReason) {
         catchScope.clearException();
-        auto result = deferred->reject(exec, rejectionReason);
+        promise->reject(globalObject, rejectionReason);
         catchScope.clearException();
-        return result;
+        return promise;
     };
 
     if (sourceOrigin.isNull())
-        return reject(createError(exec, "Could not resolve the module specifier."_s));
+        return reject(createError(globalObject, "Could not resolve the module specifier."_s));
 
-    const auto& referrer = sourceOrigin.string();
-    const auto& moduleName = moduleNameValue->value(exec);
+    auto referrer = sourceOrigin.string();
+    auto moduleName = moduleNameValue->value(globalObject);
+    RETURN_IF_EXCEPTION(throwScope, nullptr);
     if (UNLIKELY(catchScope.exception()))
         return reject(catchScope.exception());
 
     auto directoryName = extractDirectoryName(referrer.impl());
     if (!directoryName)
-        return reject(createError(exec, makeString("Could not resolve the referrer name '", String(referrer.impl()), "'.")));
+        return reject(createError(globalObject, makeString("Could not resolve the referrer name '", String(referrer.impl()), "'.")));
 
-    auto result = JSC::importModule(exec, Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(moduleName))), parameters, jsUndefined());
+    auto result = JSC::importModule(globalObject, Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(moduleName))), parameters, jsUndefined());
     if (UNLIKELY(catchScope.exception()))
         return reject(catchScope.exception());
     return result;
 }
 
-Identifier GlobalObject::moduleLoaderResolve(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue keyValue, JSValue referrerValue, JSValue)
+Identifier GlobalObject::moduleLoaderResolve(JSGlobalObject* globalObject, JSModuleLoader*, JSValue keyValue, JSValue referrerValue, JSValue)
 {
     VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     scope.releaseAssertNoException();
-    const Identifier key = keyValue.toPropertyKey(exec);
+    const Identifier key = keyValue.toPropertyKey(globalObject);
     RETURN_IF_EXCEPTION(scope, { });
 
     if (key.isSymbol())
         return key;
 
     if (referrerValue.isUndefined()) {
         auto directoryName = currentWorkingDirectory();
         if (!directoryName) {
-            throwException(exec, scope, createError(exec, "Could not resolve the current working directory."_s));
+            throwException(globalObject, scope, createError(globalObject, "Could not resolve the current working directory."_s));
             return { };
         }
         return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
     }
 
-    const Identifier referrer = referrerValue.toPropertyKey(exec);
+    const Identifier referrer = referrerValue.toPropertyKey(globalObject);
     RETURN_IF_EXCEPTION(scope, { });
 
     if (referrer.isSymbol()) {
         auto directoryName = currentWorkingDirectory();
         if (!directoryName) {
-            throwException(exec, scope, createError(exec, "Could not resolve the current working directory."_s));
+            throwException(globalObject, scope, createError(globalObject, "Could not resolve the current working directory."_s));
             return { };
         }
         return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
     }
 
     // If the referrer exists, we assume that the referrer is the correct absolute path.
     auto directoryName = extractDirectoryName(referrer.impl());
     if (!directoryName) {
-        throwException(exec, scope, createError(exec, makeString("Could not resolve the referrer name '", String(referrer.impl()), "'.")));
+        throwException(globalObject, scope, createError(globalObject, makeString("Could not resolve the referrer name '", String(referrer.impl()), "'.")));
         return { };
     }
     return Identifier::fromString(vm, resolvePath(directoryName.value(), ModuleName(key.impl())));
 }
 
@@ -1150,33 +1157,31 @@
     fclose(f);
 
     return result;
 }
 
-JSInternalPromise* GlobalObject::moduleLoaderFetch(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue key, JSValue, JSValue)
+JSInternalPromise* GlobalObject::moduleLoaderFetch(JSGlobalObject* globalObject, JSModuleLoader*, JSValue key, JSValue, JSValue)
 {
     VM& vm = globalObject->vm();
-    auto throwScope = DECLARE_THROW_SCOPE(vm);
-    JSInternalPromiseDeferred* deferred = JSInternalPromiseDeferred::tryCreate(exec, globalObject);
-    RETURN_IF_EXCEPTION(throwScope, nullptr);
+    JSInternalPromise* promise = JSInternalPromise::create(vm, globalObject->internalPromiseStructure());
 
     auto catchScope = DECLARE_CATCH_SCOPE(vm);
     auto reject = [&] (JSValue rejectionReason) {
         catchScope.clearException();
-        auto result = deferred->reject(exec, rejectionReason);
+        promise->reject(globalObject, rejectionReason);
         catchScope.clearException();
-        return result;
+        return promise;
     };
 
-    String moduleKey = key.toWTFString(exec);
+    String moduleKey = key.toWTFString(globalObject);
     if (UNLIKELY(catchScope.exception()))
         return reject(catchScope.exception());
 
     // Here, now we consider moduleKey as the fileName.
     Vector<uint8_t> buffer;
     if (!fetchModuleFromLocalFileSystem(moduleKey, buffer))
-        return reject(createError(exec, makeString("Could not open file '", moduleKey, "'.")));
+        return reject(createError(globalObject, makeString("Could not open file '", moduleKey, "'.")));
 
 
     URL moduleURL = URL({ }, moduleKey);
 #if ENABLE(WEBASSEMBLY)
     // FileSystem does not have mime-type header. The JSC shell recognizes WebAssembly's magic header.
@@ -1184,80 +1189,80 @@
         if (buffer[0] == '\0' && buffer[1] == 'a' && buffer[2] == 's' && buffer[3] == 'm') {
             auto source = SourceCode(WebAssemblySourceProvider::create(WTFMove(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL)));
             catchScope.releaseAssertNoException();
             auto sourceCode = JSSourceCode::create(vm, WTFMove(source));
             catchScope.releaseAssertNoException();
-            auto result = deferred->resolve(exec, sourceCode);
+            promise->resolve(globalObject, sourceCode);
             catchScope.clearException();
-            return result;
+            return promise;
         }
     }
 #endif
 
     auto sourceCode = JSSourceCode::create(vm, jscSource(stringFromUTF(buffer), SourceOrigin { moduleKey }, WTFMove(moduleURL), TextPosition(), SourceProviderSourceType::Module));
     catchScope.releaseAssertNoException();
-    auto result = deferred->resolve(exec, sourceCode);
+    promise->resolve(globalObject, sourceCode);
     catchScope.clearException();
-    return result;
+    return promise;
 }
 
-JSObject* GlobalObject::moduleLoaderCreateImportMetaProperties(JSGlobalObject* globalObject, ExecState* exec, JSModuleLoader*, JSValue key, JSModuleRecord*, JSValue)
+JSObject* GlobalObject::moduleLoaderCreateImportMetaProperties(JSGlobalObject* globalObject, JSModuleLoader*, JSValue key, JSModuleRecord*, JSValue)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSObject* metaProperties = constructEmptyObject(exec, globalObject->nullPrototypeObjectStructure());
+    JSObject* metaProperties = constructEmptyObject(vm, globalObject->nullPrototypeObjectStructure());
     RETURN_IF_EXCEPTION(scope, nullptr);
 
     metaProperties->putDirect(vm, Identifier::fromString(vm, "filename"), key);
     RETURN_IF_EXCEPTION(scope, nullptr);
 
     return metaProperties;
 }
 
-static CString cStringFromViewWithString(ExecState* exec, ThrowScope& scope, StringViewWithUnderlyingString& viewWithString)
+static CString cStringFromViewWithString(JSGlobalObject* globalObject, ThrowScope& scope, StringViewWithUnderlyingString& viewWithString)
 {
     Expected<CString, UTF8ConversionError> expectedString = viewWithString.view.tryGetUtf8();
     if (expectedString)
         return expectedString.value();
     switch (expectedString.error()) {
     case UTF8ConversionError::OutOfMemory:
-        throwOutOfMemoryError(exec, scope);
+        throwOutOfMemoryError(globalObject, scope);
         break;
     case UTF8ConversionError::IllegalSource:
-        scope.throwException(exec, createError(exec, "Illegal source encountered during UTF8 conversion"));
+        scope.throwException(globalObject, createError(globalObject, "Illegal source encountered during UTF8 conversion"));
         break;
     case UTF8ConversionError::SourceExhausted:
-        scope.throwException(exec, createError(exec, "Source exhausted during UTF8 conversion"));
+        scope.throwException(globalObject, createError(globalObject, "Source exhausted during UTF8 conversion"));
         break;
     default:
         RELEASE_ASSERT_NOT_REACHED();
     }
     return { };
 }
 
-static EncodedJSValue printInternal(ExecState* exec, FILE* out)
+static EncodedJSValue printInternal(JSGlobalObject* globalObject, CallFrame* callFrame, FILE* out)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (asyncTestExpectedPasses) {
-        JSValue value = exec->argument(0);
-        if (value.isString() && WTF::equal(asString(value)->value(exec).impl(), "Test262:AsyncTestComplete")) {
+        JSValue value = callFrame->argument(0);
+        if (value.isString() && WTF::equal(asString(value)->value(globalObject).impl(), "Test262:AsyncTestComplete")) {
             asyncTestPasses++;
             return JSValue::encode(jsUndefined());
         }
     }
 
-    for (unsigned i = 0; i < exec->argumentCount(); ++i) {
+    for (unsigned i = 0; i < callFrame->argumentCount(); ++i) {
         if (i)
             if (EOF == fputc(' ', out))
                 goto fail;
 
-        auto viewWithString = exec->uncheckedArgument(i).toString(exec)->viewWithUnderlyingString(exec);
+        auto viewWithString = callFrame->uncheckedArgument(i).toString(globalObject)->viewWithUnderlyingString(globalObject);
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
-        auto string = cStringFromViewWithString(exec, scope, viewWithString);
+        auto string = cStringFromViewWithString(globalObject, scope, viewWithString);
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
         if (fprintf(out, "%s", string.data()) < 0)
             goto fail;
     }
 
@@ -1265,51 +1270,51 @@
 fail:
     fflush(out);
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionPrintStdOut(ExecState* exec) { return printInternal(exec, stdout); }
-EncodedJSValue JSC_HOST_CALL functionPrintStdErr(ExecState* exec) { return printInternal(exec, stderr); }
+EncodedJSValue JSC_HOST_CALL functionPrintStdOut(JSGlobalObject* globalObject, CallFrame* callFrame) { return printInternal(globalObject, callFrame, stdout); }
+EncodedJSValue JSC_HOST_CALL functionPrintStdErr(JSGlobalObject* globalObject, CallFrame* callFrame) { return printInternal(globalObject, callFrame, stderr); }
 
-EncodedJSValue JSC_HOST_CALL functionDebug(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionDebug(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
-    auto viewWithString = exec->argument(0).toString(exec)->viewWithUnderlyingString(exec);
+    auto viewWithString = callFrame->argument(0).toString(globalObject)->viewWithUnderlyingString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    auto string = cStringFromViewWithString(exec, scope, viewWithString);
+    auto string = cStringFromViewWithString(globalObject, scope, viewWithString);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     fprintf(stderr, "--> %s\n", string.data());
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionDescribe(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionDescribe(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
-    if (exec->argumentCount() < 1)
+    VM& vm = globalObject->vm();
+    if (callFrame->argumentCount() < 1)
         return JSValue::encode(jsUndefined());
-    return JSValue::encode(jsString(vm, toString(exec->argument(0))));
+    return JSValue::encode(jsString(vm, toString(callFrame->argument(0))));
 }
 
-EncodedJSValue JSC_HOST_CALL functionDescribeArray(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionDescribeArray(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    if (exec->argumentCount() < 1)
+    if (callFrame->argumentCount() < 1)
         return JSValue::encode(jsUndefined());
-    VM& vm = exec->vm();
-    JSObject* object = jsDynamicCast<JSObject*>(vm, exec->argument(0));
+    VM& vm = globalObject->vm();
+    JSObject* object = jsDynamicCast<JSObject*>(vm, callFrame->argument(0));
     if (!object)
         return JSValue::encode(jsNontrivialString(vm, "<not object>"_s));
     return JSValue::encode(jsNontrivialString(vm, toString("<Butterfly: ", RawPointer(object->butterfly()), "; public length: ", object->getArrayLength(), "; vector length: ", object->getVectorLength(), ">")));
 }
 
-EncodedJSValue JSC_HOST_CALL functionSleepSeconds(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionSleepSeconds(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    if (exec->argumentCount() >= 1) {
-        Seconds seconds = Seconds(exec->argument(0).toNumber(exec));
+    if (callFrame->argumentCount() >= 1) {
+        Seconds seconds = Seconds(callFrame->argument(0).toNumber(globalObject));
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
         sleep(seconds);
     }
 
     return JSValue::encode(jsUndefined());
@@ -1330,56 +1335,49 @@
 
 private:
     StringBuilder& m_trace;
 };
 
-EncodedJSValue JSC_HOST_CALL functionJSCStack(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionJSCStack(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
+    VM& vm = globalObject->vm();
     StringBuilder trace;
     trace.appendLiteral("--> Stack trace:\n");
 
     FunctionJSCStackFunctor functor(trace);
-    exec->iterate(functor);
+    callFrame->iterate(vm, functor);
     fprintf(stderr, "%s", trace.toString().utf8().data());
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionGCAndSweep(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionGCAndSweep(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     JSLockHolder lock(vm);
     vm.heap.collectNow(Sync, CollectionScope::Full);
     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
 }
 
-EncodedJSValue JSC_HOST_CALL functionFullGC(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionFullGC(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     JSLockHolder lock(vm);
     vm.heap.collectSync(CollectionScope::Full);
     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastFullCollection()));
 }
 
-EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionEdenGC(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     JSLockHolder lock(vm);
     vm.heap.collectSync(CollectionScope::Eden);
     return JSValue::encode(jsNumber(vm.heap.sizeAfterLastEdenCollection()));
 }
 
-EncodedJSValue JSC_HOST_CALL functionForceGCSlowPaths(ExecState*)
+EncodedJSValue JSC_HOST_CALL functionHeapSize(JSGlobalObject* globalObject, CallFrame*)
 {
-    // It's best for this to be the first thing called in the
-    // JS program so the option is set to true before we JIT.
-    Options::forceGCSlowPaths() = true;
-    return JSValue::encode(jsUndefined());
-}
-
-EncodedJSValue JSC_HOST_CALL functionHeapSize(ExecState* exec)
-{
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     JSLockHolder lock(vm);
     return JSValue::encode(jsNumber(vm.heap.size()));
 }
 
 class JSCMemoryFootprint : public JSDestructibleObject {
@@ -1426,307 +1424,328 @@
     }
 };
 
 const ClassInfo JSCMemoryFootprint::s_info = { "MemoryFootprint", &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSCMemoryFootprint) };
 
-EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionCreateMemoryFootprint(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     JSLockHolder lock(vm);
-    return JSValue::encode(JSCMemoryFootprint::create(vm, exec->lexicalGlobalObject()));
+    return JSValue::encode(JSCMemoryFootprint::create(vm, globalObject));
 }
 
-EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(ExecState*)
+EncodedJSValue JSC_HOST_CALL functionResetMemoryPeak(JSGlobalObject*, CallFrame*)
 {
     MemoryFootprint::resetPeak();
     return JSValue::encode(jsUndefined());
 }
 
 // This function is not generally very helpful in 64-bit code as the tag and payload
 // share a register. But in 32-bit JITed code the tag may not be checked if an
 // optimization removes type checking requirements, such as in ===.
-EncodedJSValue JSC_HOST_CALL functionAddressOf(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionAddressOf(JSGlobalObject*, CallFrame* callFrame)
 {
-    JSValue value = exec->argument(0);
+    JSValue value = callFrame->argument(0);
     if (!value.isCell())
         return JSValue::encode(jsUndefined());
     // Need to cast to uint64_t so bitwise_cast will play along.
     uint64_t asNumber = reinterpret_cast<uint64_t>(value.asCell());
     EncodedJSValue returnValue = JSValue::encode(jsNumber(bitwise_cast<double>(asNumber)));
     return returnValue;
 }
 
-EncodedJSValue JSC_HOST_CALL functionVersion(ExecState*)
+EncodedJSValue JSC_HOST_CALL functionVersion(JSGlobalObject*, CallFrame*)
 {
     // We need this function for compatibility with the Mozilla JS tests but for now
     // we don't actually do any version-specific handling
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionRun(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionRun(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    String fileName = exec->argument(0).toWTFString(exec);
+    String fileName = callFrame->argument(0).toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     Vector<char> script;
     if (!fetchScriptFromLocalFileSystem(fileName, script))
-        return JSValue::encode(throwException(exec, scope, createError(exec, "Could not open file."_s)));
+        return JSValue::encode(throwException(globalObject, scope, createError(globalObject, "Could not open file."_s)));
 
-    GlobalObject* globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector<String>());
+    GlobalObject* realm = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector<String>());
 
-    JSArray* array = constructEmptyArray(globalObject->globalExec(), 0);
+    JSArray* array = constructEmptyArray(realm, 0);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    for (unsigned i = 1; i < exec->argumentCount(); ++i) {
-        array->putDirectIndex(globalObject->globalExec(), i - 1, exec->uncheckedArgument(i));
+    for (unsigned i = 1; i < callFrame->argumentCount(); ++i) {
+        array->putDirectIndex(realm, i - 1, callFrame->uncheckedArgument(i));
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
     }
-    globalObject->putDirect(vm, Identifier::fromString(vm, "arguments"), array);
+    realm->putDirect(vm, Identifier::fromString(vm, "arguments"), array);
 
     NakedPtr<Exception> exception;
     StopWatch stopWatch;
     stopWatch.start();
-    evaluate(globalObject->globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), exception);
+    evaluate(realm, jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), exception);
     stopWatch.stop();
 
     if (exception) {
-        throwException(globalObject->globalExec(), scope, exception);
+        throwException(realm, scope, exception);
         return JSValue::encode(jsUndefined());
     }
 
     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
 }
 
-EncodedJSValue JSC_HOST_CALL functionRunString(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionRunString(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    String source = exec->argument(0).toWTFString(exec);
+    String source = callFrame->argument(0).toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
-    GlobalObject* globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector<String>());
+    GlobalObject* realm = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector<String>());
 
-    JSArray* array = constructEmptyArray(globalObject->globalExec(), 0);
+    JSArray* array = constructEmptyArray(realm, 0);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    for (unsigned i = 1; i < exec->argumentCount(); ++i) {
-        array->putDirectIndex(globalObject->globalExec(), i - 1, exec->uncheckedArgument(i));
+    for (unsigned i = 1; i < callFrame->argumentCount(); ++i) {
+        array->putDirectIndex(realm, i - 1, callFrame->uncheckedArgument(i));
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
     }
-    globalObject->putDirect(vm, Identifier::fromString(vm, "arguments"), array);
+    realm->putDirect(vm, Identifier::fromString(vm, "arguments"), array);
 
     NakedPtr<Exception> exception;
-    evaluate(globalObject->globalExec(), jscSource(source, exec->callerSourceOrigin()), JSValue(), exception);
+    evaluate(realm, jscSource(source, callFrame->callerSourceOrigin(vm)), JSValue(), exception);
 
     if (exception) {
-        scope.throwException(globalObject->globalExec(), exception);
+        scope.throwException(realm, exception);
         return JSValue::encode(jsUndefined());
     }
 
-    return JSValue::encode(globalObject);
+    return JSValue::encode(realm);
 }
 
-EncodedJSValue JSC_HOST_CALL functionLoad(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionLoad(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    String fileName = exec->argument(0).toWTFString(exec);
+    String fileName = callFrame->argument(0).toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     Vector<char> script;
     if (!fetchScriptFromLocalFileSystem(fileName, script))
-        return JSValue::encode(throwException(exec, scope, createError(exec, "Could not open file."_s)));
-
-    JSGlobalObject* globalObject = exec->lexicalGlobalObject();
+        return JSValue::encode(throwException(globalObject, scope, createError(globalObject, "Could not open file."_s)));
 
     NakedPtr<Exception> evaluationException;
-    JSValue result = evaluate(globalObject->globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);
+    JSValue result = evaluate(globalObject, jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);
     if (evaluationException)
-        throwException(exec, scope, evaluationException);
+        throwException(globalObject, scope, evaluationException);
     return JSValue::encode(result);
 }
 
-EncodedJSValue JSC_HOST_CALL functionLoadString(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionLoadString(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    String sourceCode = exec->argument(0).toWTFString(exec);
+    String sourceCode = callFrame->argument(0).toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    JSGlobalObject* globalObject = exec->lexicalGlobalObject();
 
     NakedPtr<Exception> evaluationException;
-    JSValue result = evaluate(globalObject->globalExec(), jscSource(sourceCode, exec->callerSourceOrigin()), JSValue(), evaluationException);
+    JSValue result = evaluate(globalObject, jscSource(sourceCode, callFrame->callerSourceOrigin(vm)), JSValue(), evaluationException);
     if (evaluationException)
-        throwException(exec, scope, evaluationException);
+        throwException(globalObject, scope, evaluationException);
     return JSValue::encode(result);
 }
 
-EncodedJSValue JSC_HOST_CALL functionReadFile(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionReadFile(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    String fileName = exec->argument(0).toWTFString(exec);
+    String fileName = callFrame->argument(0).toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
     bool isBinary = false;
-    if (exec->argumentCount() > 1) {
-        String type = exec->argument(1).toWTFString(exec);
+    if (callFrame->argumentCount() > 1) {
+        String type = callFrame->argument(1).toWTFString(globalObject);
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
         if (type != "binary")
-            return throwVMError(exec, scope, "Expected 'binary' as second argument.");
+            return throwVMError(globalObject, scope, "Expected 'binary' as second argument.");
         isBinary = true;
     }
 
     RefPtr<Uint8Array> content = fillBufferWithContentsOfFile(fileName);
     if (!content)
-        return throwVMError(exec, scope, "Could not open file.");
+        return throwVMError(globalObject, scope, "Could not open file.");
 
     if (!isBinary)
         return JSValue::encode(jsString(vm, String::fromUTF8WithLatin1Fallback(content->data(), content->length())));
 
-    Structure* structure = exec->lexicalGlobalObject()->typedArrayStructure(TypeUint8);
+    Structure* structure = globalObject->typedArrayStructure(TypeUint8);
     JSObject* result = JSUint8Array::create(vm, structure, WTFMove(content));
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
     return JSValue::encode(result);
 }
 
-EncodedJSValue JSC_HOST_CALL functionCheckSyntax(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionCheckSyntax(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    String fileName = exec->argument(0).toWTFString(exec);
+    String fileName = callFrame->argument(0).toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     Vector<char> script;
     if (!fetchScriptFromLocalFileSystem(fileName, script))
-        return JSValue::encode(throwException(exec, scope, createError(exec, "Could not open file."_s)));
-
-    JSGlobalObject* globalObject = exec->lexicalGlobalObject();
+        return JSValue::encode(throwException(globalObject, scope, createError(globalObject, "Could not open file."_s)));
 
     StopWatch stopWatch;
     stopWatch.start();
 
     JSValue syntaxException;
-    bool validSyntax = checkSyntax(globalObject->globalExec(), jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), &syntaxException);
+    bool validSyntax = checkSyntax(globalObject, jscSource(script, SourceOrigin { absolutePath(fileName) }, fileName), &syntaxException);
     stopWatch.stop();
 
     if (!validSyntax)
-        throwException(exec, scope, syntaxException);
+        throwException(globalObject, scope, syntaxException);
     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
 }
 
 #if ENABLE(SAMPLING_FLAGS)
-EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionSetSamplingFlags(JSGlobalObject*, CallFrame* callFrame)
 {
-    for (unsigned i = 0; i < exec->argumentCount(); ++i) {
-        unsigned flag = static_cast<unsigned>(exec->uncheckedArgument(i).toNumber(exec));
+    for (unsigned i = 0; i < callFrame->argumentCount(); ++i) {
+        unsigned flag = static_cast<unsigned>(callFrame->uncheckedArgument(i).toNumber(globalObject));
         if ((flag >= 1) && (flag <= 32))
             SamplingFlags::setFlag(flag);
     }
     return JSValue::encode(jsNull());
 }
 
-EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionClearSamplingFlags(JSGlobalObject*, CallFrame* callFrame)
 {
-    for (unsigned i = 0; i < exec->argumentCount(); ++i) {
-        unsigned flag = static_cast<unsigned>(exec->uncheckedArgument(i).toNumber(exec));
+    for (unsigned i = 0; i < callFrame->argumentCount(); ++i) {
+        unsigned flag = static_cast<unsigned>(callFrame->uncheckedArgument(i).toNumber(globalObject));
         if ((flag >= 1) && (flag <= 32))
             SamplingFlags::clearFlag(flag);
     }
     return JSValue::encode(jsNull());
 }
 #endif
 
-EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionGetRandomSeed(JSGlobalObject* globalObject, CallFrame*)
 {
-    return JSValue::encode(jsNumber(exec->lexicalGlobalObject()->weakRandom().seed()));
+    return JSValue::encode(jsNumber(globalObject->weakRandom().seed()));
 }
 
-EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionSetRandomSeed(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    unsigned seed = exec->argument(0).toUInt32(exec);
+    unsigned seed = callFrame->argument(0).toUInt32(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    exec->lexicalGlobalObject()->weakRandom().setSeed(seed);
+    globalObject->weakRandom().setSeed(seed);
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionIsRope(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionIsRope(JSGlobalObject*, CallFrame* callFrame)
 {
-    JSValue argument = exec->argument(0);
+    JSValue argument = callFrame->argument(0);
     if (!argument.isString())
         return JSValue::encode(jsBoolean(false));
     const StringImpl* impl = asString(argument)->tryGetValueImpl();
     return JSValue::encode(jsBoolean(!impl));
 }
 
-EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(ExecState* state)
+EncodedJSValue JSC_HOST_CALL functionCallerSourceOrigin(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    SourceOrigin sourceOrigin = state->callerSourceOrigin();
+    VM& vm = globalObject->vm();
+    SourceOrigin sourceOrigin = callFrame->callerSourceOrigin(vm);
     if (sourceOrigin.isNull())
         return JSValue::encode(jsNull());
-    return JSValue::encode(jsString(state->vm(), sourceOrigin.string()));
+    return JSValue::encode(jsString(vm, sourceOrigin.string()));
 }
 
-EncodedJSValue JSC_HOST_CALL functionReadline(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionReadline(JSGlobalObject* globalObject, CallFrame*)
 {
     Vector<char, 256> line;
     int c;
     while ((c = getchar()) != EOF) {
         // FIXME: Should we also break on \r?
         if (c == '\n')
             break;
         line.append(c);
     }
     line.append('\0');
-    return JSValue::encode(jsString(exec->vm(), line.data()));
+    return JSValue::encode(jsString(globalObject->vm(), line.data()));
 }
 
-EncodedJSValue JSC_HOST_CALL functionPreciseTime(ExecState*)
+EncodedJSValue JSC_HOST_CALL functionPreciseTime(JSGlobalObject*, CallFrame*)
 {
     return JSValue::encode(jsNumber(WallTime::now().secondsSinceEpoch().value()));
 }
 
-EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionNeverInlineFunction(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    return JSValue::encode(setNeverInline(exec));
+    return JSValue::encode(setNeverInline(globalObject, callFrame));
 }
 
-EncodedJSValue JSC_HOST_CALL functionNoDFG(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionNoDFG(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    return JSValue::encode(setNeverOptimize(exec));
+    return JSValue::encode(setNeverOptimize(globalObject, callFrame));
 }
 
-EncodedJSValue JSC_HOST_CALL functionNoFTL(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionNoFTL(JSGlobalObject*, CallFrame* callFrame)
 {
-    if (exec->argumentCount()) {
-        FunctionExecutable* executable = getExecutableForFunction(exec->argument(0));
+    if (callFrame->argumentCount()) {
+        FunctionExecutable* executable = getExecutableForFunction(callFrame->argument(0));
         if (executable)
             executable->setNeverFTLOptimize(true);
     }
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionNoOSRExitFuzzing(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    return JSValue::encode(setCannotUseOSRExitFuzzing(exec));
+    return JSValue::encode(setCannotUseOSRExitFuzzing(globalObject, callFrame));
 }
 
-EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionOptimizeNextInvocation(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    return JSValue::encode(optimizeNextInvocation(exec));
+    return JSValue::encode(optimizeNextInvocation(globalObject, callFrame));
 }
 
-EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionNumberOfDFGCompiles(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    return JSValue::encode(numberOfDFGCompiles(exec));
+    return JSValue::encode(numberOfDFGCompiles(globalObject, callFrame));
+}
+
+EncodedJSValue JSC_HOST_CALL functionCallerIsOMGCompiled(JSGlobalObject* globalObject, CallFrame* callFrame)
+{
+    VM& vm = globalObject->vm();
+    auto scope = DECLARE_THROW_SCOPE(vm);
+
+    if (!Options::useBBQTierUpChecks())
+        return JSValue::encode(jsBoolean(true));
+
+    CallerFunctor wasmToJSFrame;
+    StackVisitor::visit(callFrame, vm, wasmToJSFrame);
+    if (!wasmToJSFrame.callerFrame()->isAnyWasmCallee())
+        return throwVMError(globalObject, scope, "caller is not a wasm->js import function");
+
+    // We have a wrapper frame that we generate for imports. If we ever can direct call from wasm we would need to change this.
+    ASSERT(!wasmToJSFrame.callerFrame()->callee().isWasm());
+    CallerFunctor wasmFrame;
+    StackVisitor::visit(wasmToJSFrame.callerFrame(), vm, wasmFrame);
+    ASSERT(wasmFrame.callerFrame()->callee().isWasm());
+#if ENABLE(WEBASSEMBLY)
+    auto mode = wasmFrame.callerFrame()->callee().asWasmCallee()->compilationMode();
+    return JSValue::encode(jsBoolean(mode == Wasm::CompilationMode::OMGMode || mode == Wasm::CompilationMode::OMGForOSREntryMode));
+#endif
+    RELEASE_ASSERT_NOT_REACHED();
 }
 
 Message::Message(ArrayBufferContents&& contents, int32_t index)
     : m_contents(WTFMove(contents))
     , m_index(index)
@@ -1836,49 +1855,44 @@
             result = new Workers();
         });
     return *result;
 }
 
-EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionDollarCreateRealm(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     GlobalObject* result = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector<String>());
     return JSValue::encode(result->getDirect(vm, Identifier::fromString(vm, "$")));
 }
 
-EncodedJSValue JSC_HOST_CALL functionDollarDetachArrayBuffer(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    return functionTransferArrayBuffer(exec);
-}
-
-EncodedJSValue JSC_HOST_CALL functionDollarEvalScript(ExecState* exec)
-{
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    String sourceCode = exec->argument(0).toWTFString(exec);
+    String sourceCode = callFrame->argument(0).toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
-    GlobalObject* globalObject = jsDynamicCast<GlobalObject*>(vm,
-        exec->thisValue().get(exec, Identifier::fromString(vm, "global")));
+    GlobalObject* realm = jsDynamicCast<GlobalObject*>(vm,
+        callFrame->thisValue().get(globalObject, Identifier::fromString(vm, "global")));
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
-    if (!globalObject)
-        return JSValue::encode(throwException(exec, scope, createError(exec, "Expected global to point to a global object"_s)));
+    if (!realm)
+        return JSValue::encode(throwException(globalObject, scope, createError(globalObject, "Expected global to point to a global object"_s)));
 
     NakedPtr<Exception> evaluationException;
-    JSValue result = evaluate(globalObject->globalExec(), jscSource(sourceCode, exec->callerSourceOrigin()), JSValue(), evaluationException);
+    JSValue result = evaluate(realm, jscSource(sourceCode, callFrame->callerSourceOrigin(vm)), JSValue(), evaluationException);
     if (evaluationException)
-        throwException(exec, scope, evaluationException);
+        throwException(globalObject, scope, evaluationException);
     return JSValue::encode(result);
 }
 
-EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionDollarAgentStart(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    String sourceCode = exec->argument(0).toWTFString(exec).isolatedCopy();
+    String sourceCode = callFrame->argument(0).toWTFString(globalObject).isolatedCopy();
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
     Lock didStartLock;
     Condition didStartCondition;
     bool didStart = false;
@@ -1898,14 +1912,14 @@
                         didStartCondition.notifyOne();
                     }
 
                     NakedPtr<Exception> evaluationException;
                     JSValue result;
-                    result = evaluate(globalObject->globalExec(), jscSource(sourceCode, SourceOrigin("worker"_s)), JSValue(), evaluationException);
+                    result = evaluate(globalObject, jscSource(sourceCode, SourceOrigin("worker"_s)), JSValue(), evaluationException);
                     if (evaluationException)
                         result = evaluationException->value();
-                    checkException(globalObject->globalExec(), globalObject, true, evaluationException, result, commandLine, success);
+                    checkException(globalObject, true, evaluationException, result, commandLine, success);
                     if (!success)
                         exit(1);
                 });
         })->detach();
 
@@ -1916,75 +1930,75 @@
     }
 
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionDollarAgentReceiveBroadcast(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue callback = exec->argument(0);
+    JSValue callback = callFrame->argument(0);
     CallData callData;
     CallType callType = getCallData(vm, callback, callData);
     if (callType == CallType::None)
-        return JSValue::encode(throwException(exec, scope, createError(exec, "Expected callback"_s)));
+        return JSValue::encode(throwException(globalObject, scope, createError(globalObject, "Expected callback"_s)));
 
     RefPtr<Message> message;
     {
         ReleaseHeapAccessScope releaseAccess(vm.heap);
         message = Worker::current().dequeue();
     }
 
     auto nativeBuffer = ArrayBuffer::create(message->releaseContents());
     ArrayBufferSharingMode sharingMode = nativeBuffer->sharingMode();
-    JSArrayBuffer* jsBuffer = JSArrayBuffer::create(vm, exec->lexicalGlobalObject()->arrayBufferStructure(sharingMode), WTFMove(nativeBuffer));
+    JSArrayBuffer* jsBuffer = JSArrayBuffer::create(vm, globalObject->arrayBufferStructure(sharingMode), WTFMove(nativeBuffer));
 
     MarkedArgumentBuffer args;
     args.append(jsBuffer);
     args.append(jsNumber(message->index()));
     if (UNLIKELY(args.hasOverflowed()))
-        return JSValue::encode(throwOutOfMemoryError(exec, scope));
-    RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, callback, callType, callData, jsNull(), args)));
+        return JSValue::encode(throwOutOfMemoryError(globalObject, scope));
+    RELEASE_AND_RETURN(scope, JSValue::encode(call(globalObject, callback, callType, callData, jsNull(), args)));
 }
 
-EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionDollarAgentReport(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    String report = exec->argument(0).toWTFString(exec);
+    String report = callFrame->argument(0).toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
     Workers::singleton().report(report);
 
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionDollarAgentSleep(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    if (exec->argumentCount() >= 1) {
-        Seconds seconds = Seconds::fromMilliseconds(exec->argument(0).toNumber(exec));
+    if (callFrame->argumentCount() >= 1) {
+        Seconds seconds = Seconds::fromMilliseconds(callFrame->argument(0).toNumber(globalObject));
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
         sleep(seconds);
     }
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionDollarAgentBroadcast(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSArrayBuffer* jsBuffer = jsDynamicCast<JSArrayBuffer*>(vm, exec->argument(0));
+    JSArrayBuffer* jsBuffer = jsDynamicCast<JSArrayBuffer*>(vm, callFrame->argument(0));
     if (!jsBuffer || !jsBuffer->isShared())
-        return JSValue::encode(throwException(exec, scope, createError(exec, "Expected SharedArrayBuffer"_s)));
+        return JSValue::encode(throwException(globalObject, scope, createError(globalObject, "Expected SharedArrayBuffer"_s)));
 
-    int32_t index = exec->argument(1).toInt32(exec);
+    int32_t index = callFrame->argument(1).toInt32(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
     Workers::singleton().broadcast(
         [&] (const AbstractLocker& locker, Worker& worker) {
             ArrayBuffer* nativeBuffer = jsBuffer->impl();
@@ -1995,34 +2009,34 @@
         });
 
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionDollarAgentGetReport(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
 
     String string = Workers::singleton().tryGetReport();
     if (!string)
         return JSValue::encode(jsNull());
 
     return JSValue::encode(jsString(vm, string));
 }
 
-EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(ExecState*)
+EncodedJSValue JSC_HOST_CALL functionDollarAgentLeaving(JSGlobalObject*, CallFrame*)
 {
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(ExecState*)
+EncodedJSValue JSC_HOST_CALL functionDollarAgentMonotonicNow(JSGlobalObject*, CallFrame*)
 {
     return JSValue::encode(jsNumber(MonotonicTime::now().secondsSinceEpoch().milliseconds()));
 }
 
-EncodedJSValue JSC_HOST_CALL functionWaitForReport(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionWaitForReport(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
 
     String string;
     {
         ReleaseHeapAccessScope releaseAccess(vm.heap);
         string = Workers::singleton().getReport();
@@ -2031,51 +2045,51 @@
         return JSValue::encode(jsNull());
 
     return JSValue::encode(jsString(vm, string));
 }
 
-EncodedJSValue JSC_HOST_CALL functionHeapCapacity(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionHeapCapacity(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     return JSValue::encode(jsNumber(vm.heap.capacity()));
 }
 
-EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionFlashHeapAccess(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     double sleepTimeMs = 0;
-    if (exec->argumentCount() >= 1) {
-        sleepTimeMs = exec->argument(0).toNumber(exec);
+    if (callFrame->argumentCount() >= 1) {
+        sleepTimeMs = callFrame->argument(0).toNumber(globalObject);
         RETURN_IF_EXCEPTION(scope, encodedJSValue());
     }
 
     vm.heap.releaseAccess();
     if (sleepTimeMs)
         sleep(Seconds::fromMilliseconds(sleepTimeMs));
     vm.heap.acquireAccess();
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(ExecState*)
+EncodedJSValue JSC_HOST_CALL functionDisableRichSourceInfo(JSGlobalObject*, CallFrame*)
 {
     supportsRichSourceInfo = false;
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionMallocInALoop(ExecState*)
+EncodedJSValue JSC_HOST_CALL functionMallocInALoop(JSGlobalObject*, CallFrame*)
 {
     Vector<void*> ptrs;
     for (unsigned i = 0; i < 5000; ++i)
         ptrs.append(fastMalloc(1024 * 2));
     for (void* ptr : ptrs)
         fastFree(ptr);
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(ExecState*)
+EncodedJSValue JSC_HOST_CALL functionTotalCompileTime(JSGlobalObject*, CallFrame*)
 {
 #if ENABLE(JIT)
     return JSValue::encode(jsNumber(JIT::totalCompileTime().milliseconds()));
 #else
     return JSValue::encode(jsNumber(0));
@@ -2089,88 +2103,88 @@
 typename std::enable_if<std::is_fundamental<ValueType>::value>::type addOption(VM& vm, JSObject* optionsObject, const Identifier& identifier, ValueType value)
 {
     optionsObject->putDirect(vm, identifier, JSValue(value));
 }
 
-EncodedJSValue JSC_HOST_CALL functionJSCOptions(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionJSCOptions(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
-    JSObject* optionsObject = constructEmptyObject(exec);
-#define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \
+    VM& vm = globalObject->vm();
+    JSObject* optionsObject = constructEmptyObject(globalObject);
+#define READ_OPTION(type_, name_, defaultValue_, availability_, description_) \
     addOption(vm, optionsObject, Identifier::fromString(vm, #name_), Options::name_());
-    JSC_OPTIONS(FOR_EACH_OPTION)
-#undef FOR_EACH_OPTION
+    FOR_EACH_JSC_OPTION(READ_OPTION)
+#undef READ_OPTION
     return JSValue::encode(optionsObject);
 }
 
-EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionReoptimizationRetryCount(JSGlobalObject*, CallFrame* callFrame)
 {
-    if (exec->argumentCount() < 1)
+    if (callFrame->argumentCount() < 1)
         return JSValue::encode(jsUndefined());
 
-    CodeBlock* block = getSomeBaselineCodeBlockForFunction(exec->argument(0));
+    CodeBlock* block = getSomeBaselineCodeBlockForFunction(callFrame->argument(0));
     if (!block)
         return JSValue::encode(jsNumber(0));
 
     return JSValue::encode(jsNumber(block->reoptimizationRetryCounter()));
 }
 
-EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionTransferArrayBuffer(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    if (exec->argumentCount() < 1)
-        return JSValue::encode(throwException(exec, scope, createError(exec, "Not enough arguments"_s)));
+    if (callFrame->argumentCount() < 1)
+        return JSValue::encode(throwException(globalObject, scope, createError(globalObject, "Not enough arguments"_s)));
 
-    JSArrayBuffer* buffer = jsDynamicCast<JSArrayBuffer*>(vm, exec->argument(0));
+    JSArrayBuffer* buffer = jsDynamicCast<JSArrayBuffer*>(vm, callFrame->argument(0));
     if (!buffer)
-        return JSValue::encode(throwException(exec, scope, createError(exec, "Expected an array buffer"_s)));
+        return JSValue::encode(throwException(globalObject, scope, createError(globalObject, "Expected an array buffer"_s)));
 
     ArrayBufferContents dummyContents;
     buffer->impl()->transferTo(vm, dummyContents);
 
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionFailNextNewCodeBlock(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     vm.setFailNextNewCodeBlock();
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionQuit(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionQuit(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     vm.codeCache()->write(vm);
 
     jscExit(EXIT_SUCCESS);
 
 #if COMPILER(MSVC)
     // Without this, Visual Studio will complain that this method does not return a value.
     return JSValue::encode(jsUndefined());
 #endif
 }
 
-EncodedJSValue JSC_HOST_CALL functionFalse(ExecState*) { return JSValue::encode(jsBoolean(false)); }
+EncodedJSValue JSC_HOST_CALL functionFalse(JSGlobalObject*, CallFrame*) { return JSValue::encode(jsBoolean(false)); }
 
-EncodedJSValue JSC_HOST_CALL functionUndefined1(ExecState*) { return JSValue::encode(jsUndefined()); }
-EncodedJSValue JSC_HOST_CALL functionUndefined2(ExecState*) { return JSValue::encode(jsUndefined()); }
-EncodedJSValue JSC_HOST_CALL functionIsInt32(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionUndefined1(JSGlobalObject*, CallFrame*) { return JSValue::encode(jsUndefined()); }
+EncodedJSValue JSC_HOST_CALL functionUndefined2(JSGlobalObject*, CallFrame*) { return JSValue::encode(jsUndefined()); }
+EncodedJSValue JSC_HOST_CALL functionIsInt32(JSGlobalObject*, CallFrame* callFrame)
 {
-    for (size_t i = 0; i < exec->argumentCount(); ++i) {
-        if (!exec->argument(i).isInt32())
+    for (size_t i = 0; i < callFrame->argumentCount(); ++i) {
+        if (!callFrame->argument(i).isInt32())
             return JSValue::encode(jsBoolean(false));
     }
     return JSValue::encode(jsBoolean(true));
 }
 
-EncodedJSValue JSC_HOST_CALL functionIsPureNaN(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionIsPureNaN(JSGlobalObject*, CallFrame* callFrame)
 {
-    for (size_t i = 0; i < exec->argumentCount(); ++i) {
-        JSValue value = exec->argument(i);
+    for (size_t i = 0; i < callFrame->argumentCount(); ++i) {
+        JSValue value = callFrame->argument(i);
         if (!value.isNumber())
             return JSValue::encode(jsBoolean(false));
         double number = value.asNumber();
         if (!std::isnan(number))
             return JSValue::encode(jsBoolean(false));
@@ -2178,115 +2192,115 @@
             return JSValue::encode(jsBoolean(false));
     }
     return JSValue::encode(jsBoolean(true));
 }
 
-EncodedJSValue JSC_HOST_CALL functionIdentity(ExecState* exec) { return JSValue::encode(exec->argument(0)); }
+EncodedJSValue JSC_HOST_CALL functionIdentity(JSGlobalObject*, CallFrame* callFrame) { return JSValue::encode(callFrame->argument(0)); }
 
-EncodedJSValue JSC_HOST_CALL functionEffectful42(ExecState*)
+EncodedJSValue JSC_HOST_CALL functionEffectful42(JSGlobalObject*, CallFrame*)
 {
     return JSValue::encode(jsNumber(42));
 }
 
-EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionMakeMasquerader(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
-    return JSValue::encode(Masquerader::create(vm, exec->lexicalGlobalObject()));
+    VM& vm = globalObject->vm();
+    return JSValue::encode(Masquerader::create(vm, globalObject));
 }
 
-EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionHasCustomProperties(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    JSValue value = exec->argument(0);
+    JSValue value = callFrame->argument(0);
     if (value.isObject())
-        return JSValue::encode(jsBoolean(asObject(value)->hasCustomProperties(exec->vm())));
+        return JSValue::encode(jsBoolean(asObject(value)->hasCustomProperties(globalObject->vm())));
     return JSValue::encode(jsBoolean(false));
 }
 
-EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionDumpTypesForAllVariables(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     vm.dumpTypeProfilerData();
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionDrainMicrotasks(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     vm.drainMicrotasks();
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionReleaseWeakRefs(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     vm.finalizeSynchronousJSExecution();
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(ExecState*)
+EncodedJSValue JSC_HOST_CALL functionIs32BitPlatform(JSGlobalObject*, CallFrame*)
 {
 #if USE(JSVALUE64)
     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
 #else
     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
 #endif
 }
 
-EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     return JSValue::encode(GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), Vector<String>()));
 }
 
-EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionCheckModuleSyntax(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    String source = exec->argument(0).toWTFString(exec);
+    String source = callFrame->argument(0).toWTFString(globalObject);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 
     StopWatch stopWatch;
     stopWatch.start();
 
     ParserError error;
-    bool validSyntax = checkModuleSyntax(exec, jscSource(source, { }, URL(), TextPosition(), SourceProviderSourceType::Module), error);
+    bool validSyntax = checkModuleSyntax(globalObject, jscSource(source, { }, URL(), TextPosition(), SourceProviderSourceType::Module), error);
     RETURN_IF_EXCEPTION(scope, encodedJSValue());
     stopWatch.stop();
 
     if (!validSyntax)
-        throwException(exec, scope, jsNontrivialString(vm, toString("SyntaxError: ", error.message(), ":", error.line())));
+        throwException(globalObject, scope, jsNontrivialString(vm, toString("SyntaxError: ", error.message(), ":", error.line())));
     return JSValue::encode(jsNumber(stopWatch.getElapsedMS()));
 }
 
-EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(ExecState*)
+EncodedJSValue JSC_HOST_CALL functionPlatformSupportsSamplingProfiler(JSGlobalObject*, CallFrame*)
 {
 #if ENABLE(SAMPLING_PROFILER)
     return JSValue::encode(JSValue(JSC::JSValue::JSTrue));
 #else
     return JSValue::encode(JSValue(JSC::JSValue::JSFalse));
 #endif
 }
 
-EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshot(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     JSLockHolder lock(vm);
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     HeapSnapshotBuilder snapshotBuilder(vm.ensureHeapProfiler());
     snapshotBuilder.buildSnapshot();
 
     String jsonString = snapshotBuilder.json();
-    EncodedJSValue result = JSValue::encode(JSONParse(exec, jsonString));
+    EncodedJSValue result = JSValue::encode(JSONParse(globalObject, jsonString));
     scope.releaseAssertNoException();
     return result;
 }
 
-EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionGenerateHeapSnapshotForGCDebugging(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     JSLockHolder lock(vm);
     auto scope = DECLARE_THROW_SCOPE(vm);
     String jsonString;
     {
         DeferGCForAWhile deferGC(vm.heap); // Prevent concurrent GC from interfering with the full GC that the snapshot does.
@@ -2298,107 +2312,107 @@
     }
     scope.releaseAssertNoException();
     return JSValue::encode(jsString(vm, jsonString));
 }
 
-EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(ExecState*)
+EncodedJSValue JSC_HOST_CALL functionResetSuperSamplerState(JSGlobalObject*, CallFrame*)
 {
     resetSuperSamplerState();
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionEnsureArrayStorage(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
-    for (unsigned i = 0; i < exec->argumentCount(); ++i) {
-        if (JSObject* object = jsDynamicCast<JSObject*>(vm, exec->argument(i)))
+    VM& vm = globalObject->vm();
+    for (unsigned i = 0; i < callFrame->argumentCount(); ++i) {
+        if (JSObject* object = jsDynamicCast<JSObject*>(vm, callFrame->argument(i)))
             object->ensureArrayStorage(vm);
     }
     return JSValue::encode(jsUndefined());
 }
 
 #if ENABLE(SAMPLING_PROFILER)
-EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionStartSamplingProfiler(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     SamplingProfiler& samplingProfiler = vm.ensureSamplingProfiler(WTF::Stopwatch::create());
     samplingProfiler.noticeCurrentThreadAsJSCExecutionThread();
     samplingProfiler.start();
     return JSValue::encode(jsUndefined());
 }
 
-EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionSamplingProfilerStackTraces(JSGlobalObject* globalObject, CallFrame*)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (!vm.samplingProfiler())
-        return JSValue::encode(throwException(exec, scope, createError(exec, "Sampling profiler was never started"_s)));
+        return JSValue::encode(throwException(globalObject, scope, createError(globalObject, "Sampling profiler was never started"_s)));
 
     String jsonString = vm.samplingProfiler()->stackTracesAsJSON();
-    EncodedJSValue result = JSValue::encode(JSONParse(exec, jsonString));
+    EncodedJSValue result = JSValue::encode(JSONParse(globalObject, jsonString));
     scope.releaseAssertNoException();
     return result;
 }
 #endif // ENABLE(SAMPLING_PROFILER)
 
-EncodedJSValue JSC_HOST_CALL functionMaxArguments(ExecState*)
+EncodedJSValue JSC_HOST_CALL functionMaxArguments(JSGlobalObject*, CallFrame*)
 {
     return JSValue::encode(jsNumber(JSC::maxArguments));
 }
 
-EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionAsyncTestStart(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
-    JSValue numberOfAsyncPasses = exec->argument(0);
+    JSValue numberOfAsyncPasses = callFrame->argument(0);
     if (!numberOfAsyncPasses.isUInt32())
-        return throwVMError(exec, scope, "Expected first argument to be a uint32"_s);
+        return throwVMError(globalObject, scope, "Expected first argument to be a uint32"_s);
 
     asyncTestExpectedPasses += numberOfAsyncPasses.asUInt32();
     return encodedJSUndefined();
 }
 
-EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(ExecState*)
+EncodedJSValue JSC_HOST_CALL functionAsyncTestPassed(JSGlobalObject*, CallFrame*)
 {
     asyncTestPasses++;
     return encodedJSUndefined();
 }
 
 #if ENABLE(WEBASSEMBLY)
 
-static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(ExecState* exec)
+static EncodedJSValue JSC_HOST_CALL functionWebAssemblyMemoryMode(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (!Wasm::isSupported())
-        return throwVMTypeError(exec, scope, "WebAssemblyMemoryMode should only be called if the useWebAssembly option is set"_s);
+        return throwVMTypeError(globalObject, scope, "WebAssemblyMemoryMode should only be called if the useWebAssembly option is set"_s);
 
-    if (JSObject* object = exec->argument(0).getObject()) {
+    if (JSObject* object = callFrame->argument(0).getObject()) {
         if (auto* memory = jsDynamicCast<JSWebAssemblyMemory*>(vm, object))
             return JSValue::encode(jsString(vm, makeString(memory->memory().mode())));
         if (auto* instance = jsDynamicCast<JSWebAssemblyInstance*>(vm, object))
             return JSValue::encode(jsString(vm, makeString(instance->memoryMode())));
     }
 
-    return throwVMTypeError(exec, scope, "WebAssemblyMemoryMode expects either a WebAssembly.Memory or WebAssembly.Instance"_s);
+    return throwVMTypeError(globalObject, scope, "WebAssemblyMemoryMode expects either a WebAssembly.Memory or WebAssembly.Instance"_s);
 }
 
 #endif // ENABLE(WEBASSEMBLY)
 
-EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(ExecState* exec)
+EncodedJSValue JSC_HOST_CALL functionSetUnhandledRejectionCallback(JSGlobalObject* globalObject, CallFrame* callFrame)
 {
-    VM& vm = exec->vm();
-    JSObject* object = exec->argument(0).getObject();
+    VM& vm = globalObject->vm();
+    JSObject* object = callFrame->argument(0).getObject();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     if (!object || !object->isFunction(vm))
-        return throwVMTypeError(exec, scope);
+        return throwVMTypeError(globalObject, scope);
 
-    exec->lexicalGlobalObject()->setUnhandledRejectionCallback(vm, object);
+    globalObject->setUnhandledRejectionCallback(vm, object);
     return JSValue::encode(jsUndefined());
 }
 
 // Use SEH for Release builds only to get rid of the crash report dialog
 // (luckily the same tests fail in Release and Debug builds so far). Need to
@@ -2415,31 +2429,65 @@
 
 int jscmain(int argc, char** argv);
 
 static double s_desiredTimeout;
 static double s_timeoutMultiplier = 1.0;
+static Seconds s_timeoutDuration;
+static Seconds s_maxAllowedCPUTime;
+static VM* s_vm;
+
+static void startTimeoutTimer(Seconds duration)
+{
+    Thread::create("jsc Timeout Thread", [=] () {
+        sleep(duration);
+        VMInspector::forEachVM([&] (VM& vm) -> VMInspector::FunctorStatus {
+            if (&vm != s_vm)
+                return VMInspector::FunctorStatus::Continue;
+            vm.notifyNeedShellTimeoutCheck();
+            return VMInspector::FunctorStatus::Done;
+        });
+    });
+}
 
-static void startTimeoutThreadIfNeeded()
+static void timeoutCheckCallback(VM& vm)
+{
+    RELEASE_ASSERT(&vm == s_vm);
+    auto cpuTime = CPUTime::forCurrentThread();
+    if (cpuTime >= s_maxAllowedCPUTime) {
+        dataLog("Timed out after ", s_timeoutDuration, " seconds!\n");
+        CRASH();
+    }
+    auto remainingTime = s_maxAllowedCPUTime - cpuTime;
+    startTimeoutTimer(remainingTime);
+}
+
+static void initializeTimeoutIfNeeded()
 {
     if (char* timeoutString = getenv("JSCTEST_timeout")) {
         if (sscanf(timeoutString, "%lf", &s_desiredTimeout) != 1) {
             dataLog("WARNING: timeout string is malformed, got ", timeoutString,
                 " but expected a number. Not using a timeout.\n");
-        } else {
-            Thread::create("jsc Timeout Thread", [] () {
-                Seconds timeoutDuration(s_desiredTimeout * s_timeoutMultiplier);
-                sleep(timeoutDuration);
-                dataLog("Timed out after ", timeoutDuration, " seconds!\n");
-                CRASH();
-            });
-        }
+        } else
+            g_jscConfig.shellTimeoutCheckCallback = timeoutCheckCallback;
     }
 }
 
+static void startTimeoutThreadIfNeeded(VM& vm)
+{
+    if (!g_jscConfig.shellTimeoutCheckCallback)
+        return;
+
+    s_vm = &vm;
+    s_timeoutDuration = Seconds(s_desiredTimeout * s_timeoutMultiplier);
+    s_maxAllowedCPUTime = CPUTime::forCurrentThread() + s_timeoutDuration;
+    Seconds timeoutDuration(s_desiredTimeout * s_timeoutMultiplier);
+    startTimeoutTimer(timeoutDuration);
+}
+
 int main(int argc, char** argv)
 {
-#if PLATFORM(IOS_FAMILY) && CPU(ARM_THUMB2)
+#if OS(DARWIN) && CPU(ARM_THUMB2)
     // Enabled IEEE754 denormal support.
     fenv_t env;
     fegetenv( &env );
     env.__fpscr &= ~0x01000000u;
     fesetenv( &env );
@@ -2501,11 +2549,12 @@
             scope.clearException(); \
             return; \
         } \
     } while (false)
 
-    auto exceptionString = exception.toWTFString(globalObject->globalExec());
+    auto exceptionString = exception.toWTFString(globalObject);
+    CHECK_EXCEPTION();
     Expected<CString, UTF8ConversionError> expectedCString = exceptionString.tryGetUtf8();
     if (expectedCString)
         printf("Exception: %s\n", expectedCString.value().data());
     else
         printf("Exception: <out of memory while extracting exception string>\n");
@@ -2517,29 +2566,33 @@
     Identifier lineNumberID = Identifier::fromString(vm, "line");
     CHECK_EXCEPTION();
     Identifier stackID = Identifier::fromString(vm, "stack");
     CHECK_EXCEPTION();
 
-    JSValue nameValue = exception.get(globalObject->globalExec(), nameID);
+    JSValue nameValue = exception.get(globalObject, nameID);
     CHECK_EXCEPTION();
-    JSValue fileNameValue = exception.get(globalObject->globalExec(), fileNameID);
+    JSValue fileNameValue = exception.get(globalObject, fileNameID);
     CHECK_EXCEPTION();
-    JSValue lineNumberValue = exception.get(globalObject->globalExec(), lineNumberID);
+    JSValue lineNumberValue = exception.get(globalObject, lineNumberID);
     CHECK_EXCEPTION();
-    JSValue stackValue = exception.get(globalObject->globalExec(), stackID);
+    JSValue stackValue = exception.get(globalObject, stackID);
     CHECK_EXCEPTION();
 
-    if (nameValue.toWTFString(globalObject->globalExec()) == "SyntaxError"
-        && (!fileNameValue.isUndefinedOrNull() || !lineNumberValue.isUndefinedOrNull())) {
-        printf(
-            "at %s:%s\n",
-            fileNameValue.toWTFString(globalObject->globalExec()).utf8().data(),
-            lineNumberValue.toWTFString(globalObject->globalExec()).utf8().data());
+    auto nameString = nameValue.toWTFString(globalObject);
+    CHECK_EXCEPTION();
+
+    if (nameString == "SyntaxError" && (!fileNameValue.isUndefinedOrNull() || !lineNumberValue.isUndefinedOrNull())) {
+        auto fileNameString = fileNameValue.toWTFString(globalObject);
+        CHECK_EXCEPTION();
+        auto lineNumberString = lineNumberValue.toWTFString(globalObject);
+        CHECK_EXCEPTION();
+        printf("at %s:%s\n", fileNameString.utf8().data(), lineNumberString.utf8().data());
     }
 
     if (!stackValue.isUndefinedOrNull()) {
-        auto stackString = stackValue.toWTFString(globalObject->globalExec());
+        auto stackString = stackValue.toWTFString(globalObject);
+        CHECK_EXCEPTION();
         if (stackString.length())
             printf("%s\n", stackString.utf8().data());
     }
 
 #undef CHECK_EXCEPTION
@@ -2553,18 +2606,17 @@
     if (!exception) {
         printf("Expected uncaught exception with name '%s' but none was thrown\n", expectedExceptionName.utf8().data());
         return false;
     }
 
-    ExecState* exec = globalObject->globalExec();
-    JSValue exceptionClass = globalObject->get(exec, Identifier::fromString(vm, expectedExceptionName));
+    JSValue exceptionClass = globalObject->get(globalObject, Identifier::fromString(vm, expectedExceptionName));
     if (!exceptionClass.isObject() || scope.exception()) {
         printf("Expected uncaught exception with name '%s' but given exception class is not defined\n", expectedExceptionName.utf8().data());
         return false;
     }
 
-    bool isInstanceOfExpectedException = jsCast<JSObject*>(exceptionClass)->hasInstance(exec, exception);
+    bool isInstanceOfExpectedException = jsCast<JSObject*>(exceptionClass)->hasInstance(globalObject, exception);
     if (scope.exception()) {
         printf("Expected uncaught exception with name '%s' but given exception class fails performing hasInstance\n", expectedExceptionName.utf8().data());
         return false;
     }
     if (isInstanceOfExpectedException) {
@@ -2576,11 +2628,11 @@
     printf("Expected uncaught exception with name '%s' but exception value is not instance of this exception class\n", expectedExceptionName.utf8().data());
     dumpException(globalObject, exception);
     return false;
 }
 
-static void checkException(ExecState* exec, GlobalObject* globalObject, bool isLastFile, bool hasException, JSValue value, CommandLine& options, bool& success)
+static void checkException(GlobalObject* globalObject, bool isLastFile, bool hasException, JSValue value, CommandLine& options, bool& success)
 {
     VM& vm = globalObject->vm();
 
     if (options.m_treatWatchdogExceptionAsSuccess && value.inherits<TerminatedExecutionError>(vm)) {
         ASSERT(hasException);
@@ -2588,11 +2640,11 @@
     }
 
     if (!options.m_uncaughtExceptionName || !isLastFile) {
         success = success && !hasException;
         if (options.m_dump && !hasException)
-            printf("End: %s\n", value.toWTFString(exec).utf8().data());
+            printf("End: %s\n", value.toWTFString(globalObject).utf8().data());
         if (hasException)
             dumpException(globalObject, value);
     } else
         success = success && checkUncaughtException(vm, globalObject, (hasException) ? value : JSValue(), options);
 }
@@ -2601,13 +2653,10 @@
 {
     Vector<Script>& scripts = options.m_scripts;
     String fileName;
     Vector<char> scriptBuffer;
 
-    if (options.m_dump)
-        JSC::Options::dumpGeneratedBytecodes() = true;
-
     VM& vm = globalObject->vm();
     auto scope = DECLARE_CATCH_SCOPE(vm);
 
 #if ENABLE(SAMPLING_FLAGS)
     SamplingFlags::start();
@@ -2620,11 +2669,11 @@
             fileName = scripts[i].argument;
             if (scripts[i].strictMode == Script::StrictMode::Strict)
                 scriptBuffer.append("\"use strict\";\n", strlen("\"use strict\";\n"));
 
             if (isModule) {
-                promise = loadAndEvaluateModule(globalObject->globalExec(), fileName, jsUndefined(), jsUndefined());
+                promise = loadAndEvaluateModule(globalObject, fileName, jsUndefined(), jsUndefined());
                 scope.releaseAssertNoException();
             } else {
                 if (!fetchScriptFromLocalFileSystem(fileName, scriptBuffer)) {
                     success = false; // fail early so we can catch missing files
                     return;
@@ -2639,34 +2688,34 @@
 
         bool isLastFile = i == scripts.size() - 1;
         if (isModule) {
             if (!promise) {
                 // FIXME: This should use an absolute file URL https://bugs.webkit.org/show_bug.cgi?id=193077
-                promise = loadAndEvaluateModule(globalObject->globalExec(), jscSource(stringFromUTF(scriptBuffer), SourceOrigin { absolutePath(fileName) }, URL({ }, fileName), TextPosition(), SourceProviderSourceType::Module), jsUndefined());
+                promise = loadAndEvaluateModule(globalObject, jscSource(stringFromUTF(scriptBuffer), SourceOrigin { absolutePath(fileName) }, URL({ }, fileName), TextPosition(), SourceProviderSourceType::Module), jsUndefined());
             }
             scope.clearException();
 
-            JSFunction* fulfillHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&success, &options, isLastFile](ExecState* exec) {
-                checkException(exec, jsCast<GlobalObject*>(exec->lexicalGlobalObject()), isLastFile, false, exec->argument(0), options, success);
+            JSFunction* fulfillHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&success, &options, isLastFile](JSGlobalObject* globalObject, CallFrame* callFrame) {
+                checkException(jsCast<GlobalObject*>(globalObject), isLastFile, false, callFrame->argument(0), options, success);
                 return JSValue::encode(jsUndefined());
             });
 
-            JSFunction* rejectHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&success, &options, isLastFile](ExecState* exec) {
-                checkException(exec, jsCast<GlobalObject*>(exec->lexicalGlobalObject()), isLastFile, true, exec->argument(0), options, success);
+            JSFunction* rejectHandler = JSNativeStdFunction::create(vm, globalObject, 1, String(), [&success, &options, isLastFile](JSGlobalObject* globalObject, CallFrame* callFrame) {
+                checkException(jsCast<GlobalObject*>(globalObject), isLastFile, true, callFrame->argument(0), options, success);
                 return JSValue::encode(jsUndefined());
             });
 
-            promise->then(globalObject->globalExec(), fulfillHandler, rejectHandler);
+            promise->then(globalObject, fulfillHandler, rejectHandler);
             scope.releaseAssertNoException();
             vm.drainMicrotasks();
         } else {
             NakedPtr<Exception> evaluationException;
-            JSValue returnValue = evaluate(globalObject->globalExec(), jscSource(scriptBuffer, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);
+            JSValue returnValue = evaluate(globalObject, jscSource(scriptBuffer, SourceOrigin { absolutePath(fileName) }, fileName), JSValue(), evaluationException);
             scope.assertNoException();
             if (evaluationException)
                 returnValue = evaluationException->value();
-            checkException(globalObject->globalExec(), globalObject, isLastFile, evaluationException, returnValue, options, success);
+            checkException(globalObject, isLastFile, evaluationException, returnValue, options, success);
         }
 
         scriptBuffer.clear();
         scope.clearException();
     }
@@ -2715,11 +2764,11 @@
             continue;
         }
 
 
         NakedPtr<Exception> evaluationException;
-        JSValue returnValue = evaluate(globalObject->globalExec(), jscSource(source, sourceOrigin), JSValue(), evaluationException);
+        JSValue returnValue = evaluate(globalObject, jscSource(source, sourceOrigin), JSValue(), evaluationException);
 #else
         printf("%s", interactivePrompt);
         Vector<char, 256> line;
         int c;
         while ((c = getchar()) != EOF) {
@@ -2730,16 +2779,16 @@
         }
         if (line.isEmpty())
             break;
 
         NakedPtr<Exception> evaluationException;
-        JSValue returnValue = evaluate(globalObject->globalExec(), jscSource(line, sourceOrigin, sourceOrigin.string()), JSValue(), evaluationException);
+        JSValue returnValue = evaluate(globalObject, jscSource(line, sourceOrigin, sourceOrigin.string()), JSValue(), evaluationException);
 #endif
         if (evaluationException)
-            printf("Exception: %s\n", evaluationException->value().toWTFString(globalObject->globalExec()).utf8().data());
+            printf("Exception: %s\n", evaluationException->value().toWTFString(globalObject).utf8().data());
         else
-            printf("%s\n", returnValue.toWTFString(globalObject->globalExec()).utf8().data());
+            printf("%s\n", returnValue.toWTFString(globalObject).utf8().data());
 
         scope.clearException();
         vm.drainMicrotasks();
     }
     printf("\n");
@@ -2882,10 +2931,14 @@
         }
         if (!strcmp(arg, "--destroy-vm")) {
             m_destroyVM = true;
             continue;
         }
+        if (!strcmp(arg, "--disableOptionsFreezingForTesting")) {
+            Config::disableFreezingForTesting();
+            continue;
+        }
 
         static const char* timeoutMultiplierOptStr = "--timeoutMultiplier=";
         static const unsigned timeoutMultiplierOptStrLength = strlen(timeoutMultiplierOptStr);
         if (!strncmp(arg, timeoutMultiplierOptStr, timeoutMultiplierOptStrLength)) {
             const char* valueStr = &arg[timeoutMultiplierOptStrLength];
@@ -2982,19 +3035,20 @@
     bool success = true;
     GlobalObject* globalObject = nullptr;
     {
         JSLockHolder locker(vm);
 
+        startTimeoutThreadIfNeeded(vm);
         if (options.m_profile && !vm.m_perBytecodeProfiler)
             vm.m_perBytecodeProfiler = makeUnique<Profiler::Database>(vm);
 
         globalObject = GlobalObject::create(vm, GlobalObject::createStructure(vm, jsNull()), options.m_arguments);
         globalObject->setRemoteDebuggingEnabled(options.m_enableRemoteDebugging);
         func(vm, globalObject, success);
         vm.drainMicrotasks();
     }
-    vm.promiseDeferredTimer->runRunLoop();
+    vm.promiseTimer->runRunLoop();
     {
         JSLockHolder locker(vm);
         if (options.m_interactive && success)
             runInteractive(globalObject);
     }
@@ -3034,10 +3088,13 @@
         for (auto& entry : compileTimeStats)
             compileTimeKeys.append(entry.key);
         std::sort(compileTimeKeys.begin(), compileTimeKeys.end());
         for (const CString& key : compileTimeKeys)
             printf("%40s: %.3lf ms\n", key.data(), compileTimeStats.get(key).milliseconds());
+
+        if (Options::reportTotalPhaseTimes())
+            logTotalPhaseTimes();
     }
 #endif
 
     if (Options::gcAtEnd()) {
         // We need to hold the API lock to do a GC.
@@ -3068,27 +3125,38 @@
 }
 
 int jscmain(int argc, char** argv)
 {
     // Need to override and enable restricted options before we start parsing options below.
-    Options::enableRestrictedOptions(true);
+    Config::enableRestrictedOptions();
 
     WTF::initializeMainThread();
 
     // Note that the options parsing can affect VM creation, and thus
     // comes first.
     CommandLine options(argc, argv);
 
     processConfigFile(Options::configFile(), "jsc");
+    if (options.m_dump)
+        JSC::Options::dumpGeneratedBytecodes() = true;
 
     // Initialize JSC before getting VM.
     JSC::initializeThreading();
-    startTimeoutThreadIfNeeded();
+    initializeTimeoutIfNeeded();
 #if ENABLE(WEBASSEMBLY)
     JSC::Wasm::enableFastMemory();
 #endif
-    Gigacage::disableDisablingPrimitiveGigacageIfShouldBeEnabled();
+
+    bool gigacageDisableRequested = false;
+#if GIGACAGE_ENABLED && !COMPILER(MSVC)
+    if (char* gigacageEnabled = getenv("GIGACAGE_ENABLED")) {
+        if (!strcasecmp(gigacageEnabled, "no") || !strcasecmp(gigacageEnabled, "false") || !strcasecmp(gigacageEnabled, "0"))
+            gigacageDisableRequested = true;
+    }
+#endif
+    if (!gigacageDisableRequested)
+        Gigacage::forbidDisablingPrimitiveGigacage();
 
 #if PLATFORM(COCOA)
     auto& memoryPressureHandler = MemoryPressureHandler::singleton();
     {
         dispatch_queue_t queue = dispatch_queue_create("jsc shell memory pressure handler", DISPATCH_QUEUE_SERIAL);

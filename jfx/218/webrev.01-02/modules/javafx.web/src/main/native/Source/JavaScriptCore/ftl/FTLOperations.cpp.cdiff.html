<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOperations.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FTLOSRExitCompiler.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLOperations.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOperations.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,30 ***</span>
  #include &quot;ClonedArguments.h&quot;
  #include &quot;CommonSlowPaths.h&quot;
  #include &quot;DirectArguments.h&quot;
  #include &quot;FTLJITCode.h&quot;
  #include &quot;FTLLazySlowPath.h&quot;
  #include &quot;InlineCallFrame.h&quot;
  #include &quot;Interpreter.h&quot;
  #include &quot;JSAsyncFunction.h&quot;
  #include &quot;JSAsyncGeneratorFunction.h&quot;
  #include &quot;JSCInlines.h&quot;
<span class="line-removed">- #include &quot;JSFixedArray.h&quot;</span>
  #include &quot;JSGeneratorFunction.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;JSLexicalEnvironment.h&quot;
  #include &quot;RegExpObject.h&quot;
  
  namespace JSC { namespace FTL {
  
<span class="line-modified">! extern &quot;C&quot; void JIT_OPERATION operationPopulateObjectInOSR(</span>
<span class="line-removed">-     ExecState* exec, ExitTimeObjectMaterialization* materialization,</span>
<span class="line-removed">-     EncodedJSValue* encodedValue, EncodedJSValue* values)</span>
  {
      using namespace DFG;
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
  
      // We cannot GC. We&#39;ve got pointers in evil places.
      // FIXME: We are not doing anything that can GC here, and this is
      // probably unnecessary.
      DeferGCForAWhile deferGC(vm.heap);
<span class="line-new-header">--- 32,34 ---</span>
  #include &quot;ClonedArguments.h&quot;
  #include &quot;CommonSlowPaths.h&quot;
  #include &quot;DirectArguments.h&quot;
  #include &quot;FTLJITCode.h&quot;
  #include &quot;FTLLazySlowPath.h&quot;
<span class="line-added">+ #include &quot;FrameTracers.h&quot;</span>
  #include &quot;InlineCallFrame.h&quot;
  #include &quot;Interpreter.h&quot;
<span class="line-added">+ #include &quot;JSArrayIterator.h&quot;</span>
  #include &quot;JSAsyncFunction.h&quot;
  #include &quot;JSAsyncGeneratorFunction.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSGeneratorFunction.h&quot;
  #include &quot;JSImmutableButterfly.h&quot;
  #include &quot;JSLexicalEnvironment.h&quot;
  #include &quot;RegExpObject.h&quot;
  
<span class="line-added">+ IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)</span>
<span class="line-added">+ </span>
  namespace JSC { namespace FTL {
  
<span class="line-modified">! extern &quot;C&quot; void JIT_OPERATION operationPopulateObjectInOSR(JSGlobalObject* globalObject, ExitTimeObjectMaterialization* materialization, EncodedJSValue* encodedValue, EncodedJSValue* values)</span>
  {
      using namespace DFG;
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
<span class="line-added">+ </span>
<span class="line-added">+     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
  
      // We cannot GC. We&#39;ve got pointers in evil places.
      // FIXME: We are not doing anything that can GC here, and this is
      // probably unnecessary.
      DeferGCForAWhile deferGC(vm.heap);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 112,19 ***</span>
          }
  
          break;
      }
  
      case PhantomNewRegexp: {
          RegExpObject* regExpObject = jsCast&lt;RegExpObject*&gt;(JSValue::decode(*encodedValue));
  
          for (unsigned i = materialization-&gt;properties().size(); i--;) {
              const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
              if (property.location().kind() != RegExpObjectLastIndexPLoc)
                  continue;
  
<span class="line-modified">!             regExpObject-&gt;setLastIndex(exec, JSValue::decode(values[i]), false /* shouldThrow */);</span>
              break;
          }
          break;
      }
  
<span class="line-new-header">--- 116,32 ---</span>
          }
  
          break;
      }
  
<span class="line-added">+     case PhantomNewArrayIterator: {</span>
<span class="line-added">+         JSArrayIterator* arrayIterator = jsCast&lt;JSArrayIterator*&gt;(JSValue::decode(*encodedValue));</span>
<span class="line-added">+ </span>
<span class="line-added">+         // Figure out what to populate the iterator with</span>
<span class="line-added">+         for (unsigned i = materialization-&gt;properties().size(); i--;) {</span>
<span class="line-added">+             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];</span>
<span class="line-added">+             if (property.location().kind() != InternalFieldObjectPLoc)</span>
<span class="line-added">+                 continue;</span>
<span class="line-added">+             arrayIterator-&gt;internalField(static_cast&lt;JSArrayIterator::Field&gt;(property.location().info())).set(vm, arrayIterator, JSValue::decode(values[i]));</span>
<span class="line-added">+         }</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      case PhantomNewRegexp: {
          RegExpObject* regExpObject = jsCast&lt;RegExpObject*&gt;(JSValue::decode(*encodedValue));
  
          for (unsigned i = materialization-&gt;properties().size(); i--;) {
              const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
              if (property.location().kind() != RegExpObjectLastIndexPLoc)
                  continue;
  
<span class="line-modified">!             regExpObject-&gt;setLastIndex(globalObject, JSValue::decode(values[i]), false /* shouldThrow */);</span>
              break;
          }
          break;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 133,15 ***</span>
          break;
  
      }
  }
  
<span class="line-modified">! extern &quot;C&quot; JSCell* JIT_OPERATION operationMaterializeObjectInOSR(</span>
<span class="line-removed">-     ExecState* exec, ExitTimeObjectMaterialization* materialization, EncodedJSValue* values)</span>
  {
      using namespace DFG;
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
      // We cannot GC. We&#39;ve got pointers in evil places.
      DeferGCForAWhile deferGC(vm.heap);
  
      switch (materialization-&gt;type()) {
<span class="line-new-header">--- 150,16 ---</span>
          break;
  
      }
  }
  
<span class="line-modified">! extern &quot;C&quot; JSCell* JIT_OPERATION operationMaterializeObjectInOSR(JSGlobalObject* globalObject, ExitTimeObjectMaterialization* materialization, EncodedJSValue* values)</span>
  {
      using namespace DFG;
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+     JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
  
      // We cannot GC. We&#39;ve got pointers in evil places.
      DeferGCForAWhile deferGC(vm.heap);
  
      switch (materialization-&gt;type()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 223,11 ***</span>
          }
          RELEASE_ASSERT(scope);
          RELEASE_ASSERT(table);
  
          CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<span class="line-modified">!             materialization-&gt;origin(), exec-&gt;codeBlock()-&gt;baselineAlternative());</span>
          Structure* structure = codeBlock-&gt;globalObject()-&gt;activationStructure();
  
          // It doesn&#39;t matter what values we initialize as bottom values inside the activation constructor because
          // activation sinking will set bottom values for each slot.
          // FIXME: Slight optimization would be to create a constructor that doesn&#39;t initialize all slots.
<span class="line-new-header">--- 241,11 ---</span>
          }
          RELEASE_ASSERT(scope);
          RELEASE_ASSERT(table);
  
          CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<span class="line-modified">!             materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
          Structure* structure = codeBlock-&gt;globalObject()-&gt;activationStructure();
  
          // It doesn&#39;t matter what values we initialize as bottom values inside the activation constructor because
          // activation sinking will set bottom values for each slot.
          // FIXME: Slight optimization would be to create a constructor that doesn&#39;t initialize all slots.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 273,29 ***</span>
          }
  
          return result;
      }
  
      case PhantomCreateRest:
      case PhantomDirectArguments:
      case PhantomClonedArguments: {
          if (!materialization-&gt;origin().inlineCallFrame()) {
              switch (materialization-&gt;type()) {
              case PhantomDirectArguments:
<span class="line-modified">!                 return DirectArguments::createByCopying(exec);</span>
              case PhantomClonedArguments:
<span class="line-modified">!                 return ClonedArguments::createWithMachineFrame(exec, exec, ArgumentsMode::Cloned);</span>
              case PhantomCreateRest: {
                  CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<span class="line-modified">!                     materialization-&gt;origin(), exec-&gt;codeBlock()-&gt;baselineAlternative());</span>
  
                  unsigned numberOfArgumentsToSkip = codeBlock-&gt;numberOfArgumentsToSkip();
                  JSGlobalObject* globalObject = codeBlock-&gt;globalObject();
                  Structure* structure = globalObject-&gt;restParameterStructure();
<span class="line-modified">!                 JSValue* argumentsToCopyRegion = exec-&gt;addressOfArgumentsStart() + numberOfArgumentsToSkip;</span>
<span class="line-modified">!                 unsigned arraySize = exec-&gt;argumentCount() &gt; numberOfArgumentsToSkip ? exec-&gt;argumentCount() - numberOfArgumentsToSkip : 0;</span>
<span class="line-modified">!                 return constructArray(exec, structure, argumentsToCopyRegion, arraySize);</span>
              }
              default:
                  RELEASE_ASSERT_NOT_REACHED();
                  return nullptr;
              }
<span class="line-new-header">--- 291,51 ---</span>
          }
  
          return result;
      }
  
<span class="line-added">+     case PhantomNewArrayIterator: {</span>
<span class="line-added">+         // Figure out what structure.</span>
<span class="line-added">+         Structure* structure = nullptr;</span>
<span class="line-added">+         for (unsigned i = materialization-&gt;properties().size(); i--;) {</span>
<span class="line-added">+             const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];</span>
<span class="line-added">+             if (property.location() == PromotedLocationDescriptor(StructurePLoc)) {</span>
<span class="line-added">+                 RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;Structure&gt;(vm));</span>
<span class="line-added">+                 structure = jsCast&lt;Structure*&gt;(JSValue::decode(values[i]));</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+         RELEASE_ASSERT(structure);</span>
<span class="line-added">+ </span>
<span class="line-added">+         JSArrayIterator* result = JSArrayIterator::createWithInitialValues(vm, structure);</span>
<span class="line-added">+ </span>
<span class="line-added">+         RELEASE_ASSERT(materialization-&gt;properties().size() - 1 == JSArrayIterator::numberOfInternalFields);</span>
<span class="line-added">+ </span>
<span class="line-added">+         // The real values will be put subsequently by</span>
<span class="line-added">+         // operationPopulateNewObjectInOSR. See the PhantomNewObject</span>
<span class="line-added">+         // case for details.</span>
<span class="line-added">+         return result;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      case PhantomCreateRest:
      case PhantomDirectArguments:
      case PhantomClonedArguments: {
          if (!materialization-&gt;origin().inlineCallFrame()) {
              switch (materialization-&gt;type()) {
              case PhantomDirectArguments:
<span class="line-modified">!                 return DirectArguments::createByCopying(globalObject, callFrame);</span>
              case PhantomClonedArguments:
<span class="line-modified">!                 return ClonedArguments::createWithMachineFrame(globalObject, callFrame, ArgumentsMode::Cloned);</span>
              case PhantomCreateRest: {
                  CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<span class="line-modified">!                     materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
  
                  unsigned numberOfArgumentsToSkip = codeBlock-&gt;numberOfArgumentsToSkip();
                  JSGlobalObject* globalObject = codeBlock-&gt;globalObject();
                  Structure* structure = globalObject-&gt;restParameterStructure();
<span class="line-modified">!                 JSValue* argumentsToCopyRegion = callFrame-&gt;addressOfArgumentsStart() + numberOfArgumentsToSkip;</span>
<span class="line-modified">!                 unsigned arraySize = callFrame-&gt;argumentCount() &gt; numberOfArgumentsToSkip ? callFrame-&gt;argumentCount() - numberOfArgumentsToSkip : 0;</span>
<span class="line-modified">!                 return constructArray(globalObject, structure, argumentsToCopyRegion, arraySize);</span>
              }
              default:
                  RELEASE_ASSERT_NOT_REACHED();
                  return nullptr;
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,11 ***</span>
          } else
              callee = materialization-&gt;origin().inlineCallFrame()-&gt;calleeConstant();
          RELEASE_ASSERT(callee);
  
          CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<span class="line-modified">!             materialization-&gt;origin(), exec-&gt;codeBlock()-&gt;baselineAlternative());</span>
  
          // We have an inline frame and we have all of the data we need to recreate it.
          switch (materialization-&gt;type()) {
          case PhantomDirectArguments: {
              unsigned length = argumentCount - 1;
<span class="line-new-header">--- 368,11 ---</span>
          } else
              callee = materialization-&gt;origin().inlineCallFrame()-&gt;calleeConstant();
          RELEASE_ASSERT(callee);
  
          CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<span class="line-modified">!             materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
  
          // We have an inline frame and we have all of the data we need to recreate it.
          switch (materialization-&gt;type()) {
          case PhantomDirectArguments: {
              unsigned length = argumentCount - 1;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 374,11 ***</span>
                      continue;
  
                  unsigned index = property.location().info();
                  if (index &gt;= length)
                      continue;
<span class="line-modified">!                 result-&gt;putDirectIndex(exec, index, JSValue::decode(values[i]));</span>
              }
  
              return result;
          }
          case PhantomCreateRest: {
<span class="line-new-header">--- 414,11 ---</span>
                      continue;
  
                  unsigned index = property.location().info();
                  if (index &gt;= length)
                      continue;
<span class="line-modified">!                 result-&gt;putDirectIndex(globalObject, index, JSValue::decode(values[i]));</span>
              }
  
              return result;
          }
          case PhantomCreateRest: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 402,14 ***</span>
                  if (numberOfArgumentsToSkip &gt; argIndex)
                      continue;
                  unsigned arrayIndex = argIndex - numberOfArgumentsToSkip;
                  if (arrayIndex &gt;= arraySize)
                      continue;
<span class="line-modified">!                 array-&gt;putDirectIndex(exec, arrayIndex, JSValue::decode(values[i]));</span>
              }
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
              // We avoid this O(n^2) loop when asserts are disabled, but the condition checked here
              // must hold to ensure the correctness of the above loop because of how we allocate the array.
              for (unsigned targetIndex = 0; targetIndex &lt; arraySize; ++targetIndex) {
                  bool found = false;
                  for (unsigned i = materialization-&gt;properties().size(); i--;) {
<span class="line-new-header">--- 442,14 ---</span>
                  if (numberOfArgumentsToSkip &gt; argIndex)
                      continue;
                  unsigned arrayIndex = argIndex - numberOfArgumentsToSkip;
                  if (arrayIndex &gt;= arraySize)
                      continue;
<span class="line-modified">!                 array-&gt;putDirectIndex(globalObject, arrayIndex, JSValue::decode(values[i]));</span>
              }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
              // We avoid this O(n^2) loop when asserts are disabled, but the condition checked here
              // must hold to ensure the correctness of the above loop because of how we allocate the array.
              for (unsigned targetIndex = 0; targetIndex &lt; arraySize; ++targetIndex) {
                  bool found = false;
                  for (unsigned i = materialization-&gt;properties().size(); i--;) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 428,11 ***</span>
                          break;
                      }
                  }
                  ASSERT(found);
              }
<span class="line-modified">! #endif</span>
              return array;
          }
  
          default:
              RELEASE_ASSERT_NOT_REACHED();
<span class="line-new-header">--- 468,11 ---</span>
                          break;
                      }
                  }
                  ASSERT(found);
              }
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
              return array;
          }
  
          default:
              RELEASE_ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 449,15 ***</span>
                  break;
              }
          }
          RELEASE_ASSERT(array);
  
<span class="line-modified">!         // Note: it is sound for JSFixedArray::createFromArray to call getDirectIndex here</span>
          // because we&#39;re guaranteed we won&#39;t be calling any getters. The reason for this is
          // that we only support PhantomSpread over CreateRest, which is an array we create.
          // Any attempts to put a getter on any indices on the rest array will escape the array.
<span class="line-modified">!         JSFixedArray* fixedArray = JSFixedArray::createFromArray(exec, vm, array);</span>
          RELEASE_ASSERT(fixedArray);
          return fixedArray;
      }
  
      case PhantomNewArrayBuffer: {
<span class="line-new-header">--- 489,15 ---</span>
                  break;
              }
          }
          RELEASE_ASSERT(array);
  
<span class="line-modified">!         // Note: it is sound for JSImmutableButterfly::createFromArray to call getDirectIndex here</span>
          // because we&#39;re guaranteed we won&#39;t be calling any getters. The reason for this is
          // that we only support PhantomSpread over CreateRest, which is an array we create.
          // Any attempts to put a getter on any indices on the rest array will escape the array.
<span class="line-modified">!         auto* fixedArray = JSImmutableButterfly::createFromArray(globalObject, vm, array);</span>
          RELEASE_ASSERT(fixedArray);
          return fixedArray;
      }
  
      case PhantomNewArrayBuffer: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 471,25 ***</span>
          }
          RELEASE_ASSERT(immutableButterfly);
  
          // For now, we use array allocation profile in the actual CodeBlock. It is OK since current NewArrayBuffer
          // and PhantomNewArrayBuffer are always bound to a specific op_new_array_buffer.
<span class="line-modified">!         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(materialization-&gt;origin(), exec-&gt;codeBlock()-&gt;baselineAlternative());</span>
          const Instruction* currentInstruction = codeBlock-&gt;instructions().at(materialization-&gt;origin().bytecodeIndex()).ptr();
          if (!currentInstruction-&gt;is&lt;OpNewArrayBuffer&gt;()) {
              // This case can happen if Object.keys, an OpCall is first converted into a NewArrayBuffer which is then converted into a PhantomNewArrayBuffer.
              // There is no need to update the array allocation profile in that case.
              RELEASE_ASSERT(currentInstruction-&gt;is&lt;OpCall&gt;());
<span class="line-modified">!             Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;arrayStructureForIndexingTypeDuringAllocation(immutableButterfly-&gt;indexingMode());</span>
              return CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
          }
          auto newArrayBuffer = currentInstruction-&gt;as&lt;OpNewArrayBuffer&gt;();
          ArrayAllocationProfile* profile = &amp;newArrayBuffer.metadata(codeBlock).m_arrayAllocationProfile;
  
          // FIXME: Share the code with CommonSlowPaths. Currently, codeBlock etc. are slightly different.
          IndexingType indexingMode = profile-&gt;selectIndexingType();
<span class="line-modified">!         Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode);</span>
          ASSERT(isCopyOnWrite(indexingMode));
          ASSERT(!structure-&gt;outOfLineCapacity());
  
          if (UNLIKELY(immutableButterfly-&gt;indexingMode() != indexingMode)) {
              auto* newButterfly = JSImmutableButterfly::create(vm, indexingMode, immutableButterfly-&gt;length());
<span class="line-new-header">--- 511,25 ---</span>
          }
          RELEASE_ASSERT(immutableButterfly);
  
          // For now, we use array allocation profile in the actual CodeBlock. It is OK since current NewArrayBuffer
          // and PhantomNewArrayBuffer are always bound to a specific op_new_array_buffer.
<span class="line-modified">!         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
          const Instruction* currentInstruction = codeBlock-&gt;instructions().at(materialization-&gt;origin().bytecodeIndex()).ptr();
          if (!currentInstruction-&gt;is&lt;OpNewArrayBuffer&gt;()) {
              // This case can happen if Object.keys, an OpCall is first converted into a NewArrayBuffer which is then converted into a PhantomNewArrayBuffer.
              // There is no need to update the array allocation profile in that case.
              RELEASE_ASSERT(currentInstruction-&gt;is&lt;OpCall&gt;());
<span class="line-modified">!             Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(immutableButterfly-&gt;indexingMode());</span>
              return CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
          }
          auto newArrayBuffer = currentInstruction-&gt;as&lt;OpNewArrayBuffer&gt;();
          ArrayAllocationProfile* profile = &amp;newArrayBuffer.metadata(codeBlock).m_arrayAllocationProfile;
  
          // FIXME: Share the code with CommonSlowPaths. Currently, codeBlock etc. are slightly different.
          IndexingType indexingMode = profile-&gt;selectIndexingType();
<span class="line-modified">!         Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode);</span>
          ASSERT(isCopyOnWrite(indexingMode));
          ASSERT(!structure-&gt;outOfLineCapacity());
  
          if (UNLIKELY(immutableButterfly-&gt;indexingMode() != indexingMode)) {
              auto* newButterfly = JSImmutableButterfly::create(vm, indexingMode, immutableButterfly-&gt;length());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 499,34 ***</span>
  
              // FIXME: This is kinda gross and only works because we can&#39;t inline new_array_bufffer in the baseline.
              // We also cannot allocate a new butterfly from compilation threads since it&#39;s invalid to allocate cells from
              // a compilation thread.
              WTF::storeStoreFence();
<span class="line-modified">!             codeBlock-&gt;constantRegister(newArrayBuffer.m_immutableButterfly.offset()).set(vm, codeBlock, immutableButterfly);</span>
              WTF::storeStoreFence();
          }
  
          JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
          ArrayAllocationProfile::updateLastAllocationFor(profile, result);
          return result;
      }
  
      case PhantomNewArrayWithSpread: {
          CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<span class="line-modified">!             materialization-&gt;origin(), exec-&gt;codeBlock()-&gt;baselineAlternative());</span>
          JSGlobalObject* globalObject = codeBlock-&gt;globalObject();
          Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
  
          Checked&lt;unsigned, RecordOverflow&gt; checkedArraySize = 0;
          unsigned numProperties = 0;
          for (unsigned i = materialization-&gt;properties().size(); i--;) {
              const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
              if (property.location().kind() == NewArrayWithSpreadArgumentPLoc) {
                  ++numProperties;
                  JSValue value = JSValue::decode(values[i]);
<span class="line-modified">!                 if (JSFixedArray* fixedArray = jsDynamicCast&lt;JSFixedArray*&gt;(vm, value))</span>
<span class="line-modified">!                     checkedArraySize += fixedArray-&gt;size();</span>
                  else
                      checkedArraySize += 1;
              }
          }
  
<span class="line-new-header">--- 539,34 ---</span>
  
              // FIXME: This is kinda gross and only works because we can&#39;t inline new_array_bufffer in the baseline.
              // We also cannot allocate a new butterfly from compilation threads since it&#39;s invalid to allocate cells from
              // a compilation thread.
              WTF::storeStoreFence();
<span class="line-modified">!             codeBlock-&gt;constantRegister(newArrayBuffer.m_immutableButterfly).set(vm, codeBlock, immutableButterfly);</span>
              WTF::storeStoreFence();
          }
  
          JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
          ArrayAllocationProfile::updateLastAllocationFor(profile, result);
          return result;
      }
  
      case PhantomNewArrayWithSpread: {
          CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(
<span class="line-modified">!             materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
          JSGlobalObject* globalObject = codeBlock-&gt;globalObject();
          Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
  
          Checked&lt;unsigned, RecordOverflow&gt; checkedArraySize = 0;
          unsigned numProperties = 0;
          for (unsigned i = materialization-&gt;properties().size(); i--;) {
              const ExitPropertyValue&amp; property = materialization-&gt;properties()[i];
              if (property.location().kind() == NewArrayWithSpreadArgumentPLoc) {
                  ++numProperties;
                  JSValue value = JSValue::decode(values[i]);
<span class="line-modified">!                 if (JSImmutableButterfly* immutableButterfly = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, value))</span>
<span class="line-modified">!                     checkedArraySize += immutableButterfly-&gt;publicLength();</span>
                  else
                      checkedArraySize += 1;
              }
          }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 534,11 ***</span>
          // https://bugs.webkit.org/show_bug.cgi?id=169784
          unsigned arraySize = checkedArraySize.unsafeGet(); // Crashes if overflowed.
          JSArray* result = JSArray::tryCreate(vm, structure, arraySize);
          RELEASE_ASSERT(result);
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
          // Ensure we see indices for everything in the range: [0, numProperties)
          for (unsigned i = 0; i &lt; numProperties; ++i) {
              bool found = false;
              for (unsigned j = 0; j &lt; materialization-&gt;properties().size(); ++j) {
                  const ExitPropertyValue&amp; property = materialization-&gt;properties()[j];
<span class="line-new-header">--- 574,11 ---</span>
          // https://bugs.webkit.org/show_bug.cgi?id=169784
          unsigned arraySize = checkedArraySize.unsafeGet(); // Crashes if overflowed.
          JSArray* result = JSArray::tryCreate(vm, structure, arraySize);
          RELEASE_ASSERT(result);
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
          // Ensure we see indices for everything in the range: [0, numProperties)
          for (unsigned i = 0; i &lt; numProperties; ++i) {
              bool found = false;
              for (unsigned j = 0; j &lt; materialization-&gt;properties().size(); ++j) {
                  const ExitPropertyValue&amp; property = materialization-&gt;properties()[j];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 547,11 ***</span>
                      break;
                  }
              }
              ASSERT(found);
          }
<span class="line-modified">! #endif</span>
  
          Vector&lt;JSValue, 8&gt; arguments;
          arguments.grow(numProperties);
  
          for (unsigned i = materialization-&gt;properties().size(); i--;) {
<span class="line-new-header">--- 587,11 ---</span>
                      break;
                  }
              }
              ASSERT(found);
          }
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
          Vector&lt;JSValue, 8&gt; arguments;
          arguments.grow(numProperties);
  
          for (unsigned i = materialization-&gt;properties().size(); i--;) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 563,19 ***</span>
              }
          }
  
          unsigned arrayIndex = 0;
          for (JSValue value : arguments) {
<span class="line-modified">!             if (JSFixedArray* fixedArray = jsDynamicCast&lt;JSFixedArray*&gt;(vm, value)) {</span>
<span class="line-modified">!                 for (unsigned i = 0; i &lt; fixedArray-&gt;size(); i++) {</span>
<span class="line-modified">!                     ASSERT(fixedArray-&gt;get(i));</span>
<span class="line-modified">!                     result-&gt;putDirectIndex(exec, arrayIndex, fixedArray-&gt;get(i));</span>
                      ++arrayIndex;
                  }
              } else {
                  // We are not spreading.
<span class="line-modified">!                 result-&gt;putDirectIndex(exec, arrayIndex, value);</span>
                  ++arrayIndex;
              }
          }
  
          return result;
<span class="line-new-header">--- 603,19 ---</span>
              }
          }
  
          unsigned arrayIndex = 0;
          for (JSValue value : arguments) {
<span class="line-modified">!             if (JSImmutableButterfly* immutableButterfly = jsDynamicCast&lt;JSImmutableButterfly*&gt;(vm, value)) {</span>
<span class="line-modified">!                 for (unsigned i = 0; i &lt; immutableButterfly-&gt;publicLength(); i++) {</span>
<span class="line-modified">!                     ASSERT(immutableButterfly-&gt;get(i));</span>
<span class="line-modified">!                     result-&gt;putDirectIndex(globalObject, arrayIndex, immutableButterfly-&gt;get(i));</span>
                      ++arrayIndex;
                  }
              } else {
                  // We are not spreading.
<span class="line-modified">!                 result-&gt;putDirectIndex(globalObject, arrayIndex, value);</span>
                  ++arrayIndex;
              }
          }
  
          return result;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 589,36 ***</span>
                  RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;RegExp&gt;(vm));
                  regExp = jsCast&lt;RegExp*&gt;(JSValue::decode(values[i]));
              }
          }
          RELEASE_ASSERT(regExp);
<span class="line-modified">!         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(materialization-&gt;origin(), exec-&gt;codeBlock()-&gt;baselineAlternative());</span>
          Structure* structure = codeBlock-&gt;globalObject()-&gt;regExpStructure();
          return RegExpObject::create(vm, structure, regExp);
      }
  
      default:
          RELEASE_ASSERT_NOT_REACHED();
          return nullptr;
      }
  }
  
<span class="line-modified">! extern &quot;C&quot; void* JIT_OPERATION compileFTLLazySlowPath(ExecState* exec, unsigned index)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
      // We cannot GC. We&#39;ve got pointers in evil places.
      DeferGCForAWhile deferGC(vm.heap);
  
<span class="line-modified">!     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;ftl();
  
      LazySlowPath&amp; lazySlowPath = *jitCode-&gt;lazySlowPaths[index];
      lazySlowPath.generate(codeBlock);
  
      return lazySlowPath.stub().code().executableAddress();
  }
  
  } } // namespace JSC::FTL
  
  #endif // ENABLE(FTL_JIT)
  
<span class="line-new-header">--- 629,38 ---</span>
                  RELEASE_ASSERT(JSValue::decode(values[i]).asCell()-&gt;inherits&lt;RegExp&gt;(vm));
                  regExp = jsCast&lt;RegExp*&gt;(JSValue::decode(values[i]));
              }
          }
          RELEASE_ASSERT(regExp);
<span class="line-modified">!         CodeBlock* codeBlock = baselineCodeBlockForOriginAndBaselineCodeBlock(materialization-&gt;origin(), callFrame-&gt;codeBlock()-&gt;baselineAlternative());</span>
          Structure* structure = codeBlock-&gt;globalObject()-&gt;regExpStructure();
          return RegExpObject::create(vm, structure, regExp);
      }
  
      default:
          RELEASE_ASSERT_NOT_REACHED();
          return nullptr;
      }
  }
  
<span class="line-modified">! extern &quot;C&quot; void* JIT_OPERATION operationCompileFTLLazySlowPath(CallFrame* callFrame, unsigned index)</span>
  {
<span class="line-modified">!     VM&amp; vm = callFrame-&gt;deprecatedVM();</span>
  
      // We cannot GC. We&#39;ve got pointers in evil places.
      DeferGCForAWhile deferGC(vm.heap);
  
<span class="line-modified">!     CodeBlock* codeBlock = callFrame-&gt;codeBlock();</span>
      JITCode* jitCode = codeBlock-&gt;jitCode()-&gt;ftl();
  
      LazySlowPath&amp; lazySlowPath = *jitCode-&gt;lazySlowPaths[index];
      lazySlowPath.generate(codeBlock);
  
      return lazySlowPath.stub().code().executableAddress();
  }
  
  } } // namespace JSC::FTL
  
<span class="line-added">+ IGNORE_WARNINGS_END</span>
<span class="line-added">+ </span>
  #endif // ENABLE(FTL_JIT)
  
</pre>
<center><a href="FTLOSRExitCompiler.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLOperations.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
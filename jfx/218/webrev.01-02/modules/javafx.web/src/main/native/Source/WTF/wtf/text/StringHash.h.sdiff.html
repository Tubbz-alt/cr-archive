<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringHash.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringCommon.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringHasher.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringHash.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved</span>
  3  * Copyright (C) Research In Motion Limited 2009. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
</pre>
<hr />
<pre>
 39         String valueToBeDestroyed = WTFMove(value);
 40         constructDeletedValue(value);
 41     }
 42 
 43     // The hash() functions on StringHash and ASCIICaseInsensitiveHash do not support
 44     // null strings. get(), contains(), and add() on HashMap&lt;String,..., StringHash&gt;
 45     // cause a null-pointer dereference when passed null strings.
 46 
 47     // FIXME: We should really figure out a way to put the computeHash function that&#39;s
 48     // currently a member function of StringImpl into this file so we can be a little
 49     // closer to having all the nearly-identical hash functions in one place.
 50 
 51     struct StringHash {
 52         static unsigned hash(StringImpl* key) { return key-&gt;hash(); }
 53         static inline bool equal(const StringImpl* a, const StringImpl* b)
 54         {
 55             return WTF::equal(*a, *b);
 56         }
 57 
 58         static unsigned hash(const RefPtr&lt;StringImpl&gt;&amp; key) { return key-&gt;hash(); }

 59         static bool equal(const RefPtr&lt;StringImpl&gt;&amp; a, const RefPtr&lt;StringImpl&gt;&amp; b)
 60         {
 61             return equal(a.get(), b.get());
 62         }
 63         static bool equal(const RefPtr&lt;StringImpl&gt;&amp; a, const StringImpl* b)
 64         {
 65             return equal(a.get(), b);
 66         }
 67         static bool equal(const StringImpl* a, const RefPtr&lt;StringImpl&gt;&amp; b)
 68         {
 69             return equal(a, b.get());
 70         }
 71 













 72         static unsigned hash(const String&amp; key) { return key.impl()-&gt;hash(); }
 73         static bool equal(const String&amp; a, const String&amp; b)
 74         {
 75             return equal(a.impl(), b.impl());
 76         }
 77 
<span class="line-modified"> 78         static const bool safeToCompareToEmptyOrDeleted = false;</span>
 79     };
 80 
 81     struct ASCIICaseInsensitiveHash {
 82         template&lt;typename T&gt;
 83         struct FoldCase {
 84             static inline UChar convert(T character)
 85             {
 86                 return toASCIILower(character);
 87             }
 88         };
 89 
 90         static unsigned hash(const UChar* data, unsigned length)
 91         {
 92             return StringHasher::computeHashAndMaskTop8Bits&lt;UChar, FoldCase&lt;UChar&gt;&gt;(data, length);
 93         }
 94 
 95         static unsigned hash(StringImpl&amp; string)
 96         {
 97             if (string.is8Bit())
 98                 return hash(string.characters8(), string.length());
</pre>
<hr />
<pre>
118         {
119             return equalIgnoringASCIICase(a, b);
120         }
121         static inline bool equal(const StringImpl* a, const StringImpl* b)
122         {
123             ASSERT(a);
124             ASSERT(b);
125             return equal(*a, *b);
126         }
127 
128         static unsigned hash(const RefPtr&lt;StringImpl&gt;&amp; key)
129         {
130             return hash(key.get());
131         }
132 
133         static bool equal(const RefPtr&lt;StringImpl&gt;&amp; a, const RefPtr&lt;StringImpl&gt;&amp; b)
134         {
135             return equal(a.get(), b.get());
136         }
137 










138         static unsigned hash(const String&amp; key)
139         {
140             return hash(key.impl());
141         }
142         static unsigned hash(const AtomString&amp; key)
143         {
144             return hash(key.impl());
145         }
146         static bool equal(const String&amp; a, const String&amp; b)
147         {
148             return equal(a.impl(), b.impl());
149         }
150         static bool equal(const AtomString&amp; a, const AtomString&amp; b)
151         {
152             // FIXME: Is the &quot;a == b&quot; here a helpful optimization?
153             // It makes all cases where the strings are not identical slightly slower.
154             return a == b || equal(a.impl(), b.impl());
155         }
156 
<span class="line-modified">157         static const bool safeToCompareToEmptyOrDeleted = false;</span>
158     };
159 
160     // This hash can be used in cases where the key is a hash of a string, but we don&#39;t
161     // want to store the string. It&#39;s not really specific to string hashing, but all our
162     // current uses of it are for strings.
163     struct AlreadyHashed : IntHash&lt;unsigned&gt; {
164         static unsigned hash(unsigned key) { return key; }
165 
166         // To use a hash value as a key for a hash table, we need to eliminate the
167         // &quot;deleted&quot; value, which is negative one. That could be done by changing
168         // the string hash function to never generate negative one, but this works
169         // and is still relatively efficient.
170         static unsigned avoidDeletedValue(unsigned hash)
171         {
172             ASSERT(hash);
173             unsigned newHash = hash | (!(hash + 1) &lt;&lt; 31);
174             ASSERT(newHash);
175             ASSERT(newHash != 0xFFFFFFFF);
176             return newHash;
177         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2006-2019 Apple Inc. All rights reserved</span>
  3  * Copyright (C) Research In Motion Limited 2009. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
</pre>
<hr />
<pre>
 39         String valueToBeDestroyed = WTFMove(value);
 40         constructDeletedValue(value);
 41     }
 42 
 43     // The hash() functions on StringHash and ASCIICaseInsensitiveHash do not support
 44     // null strings. get(), contains(), and add() on HashMap&lt;String,..., StringHash&gt;
 45     // cause a null-pointer dereference when passed null strings.
 46 
 47     // FIXME: We should really figure out a way to put the computeHash function that&#39;s
 48     // currently a member function of StringImpl into this file so we can be a little
 49     // closer to having all the nearly-identical hash functions in one place.
 50 
 51     struct StringHash {
 52         static unsigned hash(StringImpl* key) { return key-&gt;hash(); }
 53         static inline bool equal(const StringImpl* a, const StringImpl* b)
 54         {
 55             return WTF::equal(*a, *b);
 56         }
 57 
 58         static unsigned hash(const RefPtr&lt;StringImpl&gt;&amp; key) { return key-&gt;hash(); }
<span class="line-added"> 59         static unsigned hash(const PackedPtr&lt;StringImpl&gt;&amp; key) { return key-&gt;hash(); }</span>
 60         static bool equal(const RefPtr&lt;StringImpl&gt;&amp; a, const RefPtr&lt;StringImpl&gt;&amp; b)
 61         {
 62             return equal(a.get(), b.get());
 63         }
 64         static bool equal(const RefPtr&lt;StringImpl&gt;&amp; a, const StringImpl* b)
 65         {
 66             return equal(a.get(), b);
 67         }
 68         static bool equal(const StringImpl* a, const RefPtr&lt;StringImpl&gt;&amp; b)
 69         {
 70             return equal(a, b.get());
 71         }
 72 
<span class="line-added"> 73         static bool equal(const PackedPtr&lt;StringImpl&gt;&amp; a, const PackedPtr&lt;StringImpl&gt;&amp; b)</span>
<span class="line-added"> 74         {</span>
<span class="line-added"> 75             return equal(a.get(), b.get());</span>
<span class="line-added"> 76         }</span>
<span class="line-added"> 77         static bool equal(const PackedPtr&lt;StringImpl&gt;&amp; a, const StringImpl* b)</span>
<span class="line-added"> 78         {</span>
<span class="line-added"> 79             return equal(a.get(), b);</span>
<span class="line-added"> 80         }</span>
<span class="line-added"> 81         static bool equal(const StringImpl* a, const PackedPtr&lt;StringImpl&gt;&amp; b)</span>
<span class="line-added"> 82         {</span>
<span class="line-added"> 83             return equal(a, b.get());</span>
<span class="line-added"> 84         }</span>
<span class="line-added"> 85 </span>
 86         static unsigned hash(const String&amp; key) { return key.impl()-&gt;hash(); }
 87         static bool equal(const String&amp; a, const String&amp; b)
 88         {
 89             return equal(a.impl(), b.impl());
 90         }
 91 
<span class="line-modified"> 92         static constexpr bool safeToCompareToEmptyOrDeleted = false;</span>
 93     };
 94 
 95     struct ASCIICaseInsensitiveHash {
 96         template&lt;typename T&gt;
 97         struct FoldCase {
 98             static inline UChar convert(T character)
 99             {
100                 return toASCIILower(character);
101             }
102         };
103 
104         static unsigned hash(const UChar* data, unsigned length)
105         {
106             return StringHasher::computeHashAndMaskTop8Bits&lt;UChar, FoldCase&lt;UChar&gt;&gt;(data, length);
107         }
108 
109         static unsigned hash(StringImpl&amp; string)
110         {
111             if (string.is8Bit())
112                 return hash(string.characters8(), string.length());
</pre>
<hr />
<pre>
132         {
133             return equalIgnoringASCIICase(a, b);
134         }
135         static inline bool equal(const StringImpl* a, const StringImpl* b)
136         {
137             ASSERT(a);
138             ASSERT(b);
139             return equal(*a, *b);
140         }
141 
142         static unsigned hash(const RefPtr&lt;StringImpl&gt;&amp; key)
143         {
144             return hash(key.get());
145         }
146 
147         static bool equal(const RefPtr&lt;StringImpl&gt;&amp; a, const RefPtr&lt;StringImpl&gt;&amp; b)
148         {
149             return equal(a.get(), b.get());
150         }
151 
<span class="line-added">152         static unsigned hash(const PackedPtr&lt;StringImpl&gt;&amp; key)</span>
<span class="line-added">153         {</span>
<span class="line-added">154             return hash(key.get());</span>
<span class="line-added">155         }</span>
<span class="line-added">156 </span>
<span class="line-added">157         static bool equal(const PackedPtr&lt;StringImpl&gt;&amp; a, const PackedPtr&lt;StringImpl&gt;&amp; b)</span>
<span class="line-added">158         {</span>
<span class="line-added">159             return equal(a.get(), b.get());</span>
<span class="line-added">160         }</span>
<span class="line-added">161 </span>
162         static unsigned hash(const String&amp; key)
163         {
164             return hash(key.impl());
165         }
166         static unsigned hash(const AtomString&amp; key)
167         {
168             return hash(key.impl());
169         }
170         static bool equal(const String&amp; a, const String&amp; b)
171         {
172             return equal(a.impl(), b.impl());
173         }
174         static bool equal(const AtomString&amp; a, const AtomString&amp; b)
175         {
176             // FIXME: Is the &quot;a == b&quot; here a helpful optimization?
177             // It makes all cases where the strings are not identical slightly slower.
178             return a == b || equal(a.impl(), b.impl());
179         }
180 
<span class="line-modified">181         static constexpr bool safeToCompareToEmptyOrDeleted = false;</span>
182     };
183 
184     // This hash can be used in cases where the key is a hash of a string, but we don&#39;t
185     // want to store the string. It&#39;s not really specific to string hashing, but all our
186     // current uses of it are for strings.
187     struct AlreadyHashed : IntHash&lt;unsigned&gt; {
188         static unsigned hash(unsigned key) { return key; }
189 
190         // To use a hash value as a key for a hash table, we need to eliminate the
191         // &quot;deleted&quot; value, which is negative one. That could be done by changing
192         // the string hash function to never generate negative one, but this works
193         // and is still relatively efficient.
194         static unsigned avoidDeletedValue(unsigned hash)
195         {
196             ASSERT(hash);
197             unsigned newHash = hash | (!(hash + 1) &lt;&lt; 31);
198             ASSERT(newHash);
199             ASSERT(newHash != 0xFFFFFFFF);
200             return newHash;
201         }
</pre>
</td>
</tr>
</table>
<center><a href="StringCommon.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringHasher.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
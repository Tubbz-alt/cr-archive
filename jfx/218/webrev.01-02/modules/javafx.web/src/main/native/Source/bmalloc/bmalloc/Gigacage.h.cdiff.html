<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Gigacage.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Gigacage.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Heap.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Gigacage.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 43,50 ***</span>
  
  
  namespace Gigacage {
  
  enum Kind {
<span class="line-removed">-     ReservedForFlagsAndNotABasePtr = 0,</span>
      Primitive,
      JSValue,
  };
  
  BINLINE const char* name(Kind kind)
  {
      switch (kind) {
<span class="line-removed">-     case ReservedForFlagsAndNotABasePtr:</span>
<span class="line-removed">-         RELEASE_BASSERT_NOT_REACHED();</span>
      case Primitive:
          return &quot;Primitive&quot;;
      case JSValue:
          return &quot;JSValue&quot;;
      }
      BCRASH();
      return nullptr;
  }
  
  #if GIGACAGE_ENABLED
  
<span class="line-modified">! #if BCPU(ARM64)</span>
  constexpr size_t primitiveGigacageSize = 2 * bmalloc::Sizes::GB;
  constexpr size_t jsValueGigacageSize = 2 * bmalloc::Sizes::GB;
<span class="line-removed">- constexpr size_t gigacageBasePtrsSize = 16 * bmalloc::Sizes::kB;</span>
  constexpr size_t maximumCageSizeReductionForSlide = bmalloc::Sizes::GB / 4;
<span class="line-removed">- #define GIGACAGE_ALLOCATION_CAN_FAIL 1</span>
  #else
  constexpr size_t primitiveGigacageSize = 32 * bmalloc::Sizes::GB;
  constexpr size_t jsValueGigacageSize = 16 * bmalloc::Sizes::GB;
<span class="line-removed">- constexpr size_t gigacageBasePtrsSize = 4 * bmalloc::Sizes::kB;</span>
  constexpr size_t maximumCageSizeReductionForSlide = 4 * bmalloc::Sizes::GB;
<span class="line-removed">- #define GIGACAGE_ALLOCATION_CAN_FAIL 0</span>
  #endif
  
  // In Linux, if `vm.overcommit_memory = 2` is specified, mmap with large size can fail if it exceeds the size of RAM.
  // So we specify GIGACAGE_ALLOCATION_CAN_FAIL = 1.
  #if BOS(LINUX)
<span class="line-removed">- #undef GIGACAGE_ALLOCATION_CAN_FAIL</span>
  #define GIGACAGE_ALLOCATION_CAN_FAIL 1
  #endif
  
  
  static_assert(bmalloc::isPowerOfTwo(primitiveGigacageSize), &quot;&quot;);
  static_assert(bmalloc::isPowerOfTwo(jsValueGigacageSize), &quot;&quot;);
<span class="line-new-header">--- 43,49 ---</span>
  
  
  namespace Gigacage {
  
  enum Kind {
      Primitive,
      JSValue,
<span class="line-added">+     NumberOfKinds</span>
  };
  
  BINLINE const char* name(Kind kind)
  {
      switch (kind) {
      case Primitive:
          return &quot;Primitive&quot;;
      case JSValue:
          return &quot;JSValue&quot;;
<span class="line-added">+     case NumberOfKinds:</span>
<span class="line-added">+         break;</span>
      }
      BCRASH();
      return nullptr;
  }
  
  #if GIGACAGE_ENABLED
  
<span class="line-modified">! constexpr size_t configSizeToProtect = 16 * bmalloc::Sizes::kB;</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if BOS_EFFECTIVE_ADDRESS_WIDTH &lt; 48</span>
  constexpr size_t primitiveGigacageSize = 2 * bmalloc::Sizes::GB;
  constexpr size_t jsValueGigacageSize = 2 * bmalloc::Sizes::GB;
  constexpr size_t maximumCageSizeReductionForSlide = bmalloc::Sizes::GB / 4;
  #else
  constexpr size_t primitiveGigacageSize = 32 * bmalloc::Sizes::GB;
  constexpr size_t jsValueGigacageSize = 16 * bmalloc::Sizes::GB;
  constexpr size_t maximumCageSizeReductionForSlide = 4 * bmalloc::Sizes::GB;
  #endif
  
  // In Linux, if `vm.overcommit_memory = 2` is specified, mmap with large size can fail if it exceeds the size of RAM.
  // So we specify GIGACAGE_ALLOCATION_CAN_FAIL = 1.
  #if BOS(LINUX)
  #define GIGACAGE_ALLOCATION_CAN_FAIL 1
<span class="line-added">+ #else</span>
<span class="line-added">+ #define GIGACAGE_ALLOCATION_CAN_FAIL 0</span>
  #endif
  
  
  static_assert(bmalloc::isPowerOfTwo(primitiveGigacageSize), &quot;&quot;);
  static_assert(bmalloc::isPowerOfTwo(jsValueGigacageSize), &quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 96,78 ***</span>
  constexpr size_t gigacageSizeToMask(size_t size) { return size - 1; }
  
  constexpr size_t primitiveGigacageMask = gigacageSizeToMask(primitiveGigacageSize);
  constexpr size_t jsValueGigacageMask = gigacageSizeToMask(jsValueGigacageSize);
  
<span class="line-modified">! extern &quot;C&quot; alignas(gigacageBasePtrsSize) BEXPORT char g_gigacageBasePtrs[gigacageBasePtrsSize];</span>
  
<span class="line-modified">! BINLINE bool wasEnabled() { return g_gigacageBasePtrs[0]; }</span>
<span class="line-modified">! BINLINE void setWasEnabled() { g_gigacageBasePtrs[0] = true; }</span>
  
<span class="line-modified">! struct BasePtrs {</span>
<span class="line-modified">!     uintptr_t reservedForFlags;</span>
<span class="line-modified">!     void* primitive;</span>
<span class="line-modified">!     void* jsValue;</span>
  };
  
<span class="line-modified">! static_assert(offsetof(BasePtrs, primitive) == Kind::Primitive * sizeof(void*), &quot;&quot;);</span>
<span class="line-modified">! static_assert(offsetof(BasePtrs, jsValue) == Kind::JSValue * sizeof(void*), &quot;&quot;);</span>
  
<span class="line-modified">! constexpr unsigned numKinds = 2;</span>
  
  BEXPORT void ensureGigacage();
  
  BEXPORT void disablePrimitiveGigacage();
  
  // This will call the disable callback immediately if the Primitive Gigacage is currently disabled.
  BEXPORT void addPrimitiveDisableCallback(void (*)(void*), void*);
  BEXPORT void removePrimitiveDisableCallback(void (*)(void*), void*);
  
<span class="line-modified">! BEXPORT void disableDisablingPrimitiveGigacageIfShouldBeEnabled();</span>
<span class="line-removed">- </span>
<span class="line-removed">- BEXPORT bool isDisablingPrimitiveGigacageDisabled();</span>
<span class="line-removed">- inline bool isPrimitiveGigacagePermanentlyEnabled() { return isDisablingPrimitiveGigacageDisabled(); }</span>
<span class="line-removed">- inline bool canPrimitiveGigacageBeDisabled() { return !isDisablingPrimitiveGigacageDisabled(); }</span>
  
<span class="line-modified">! BINLINE void*&amp; basePtr(BasePtrs&amp; basePtrs, Kind kind)</span>
<span class="line-modified">! {</span>
<span class="line-modified">!     switch (kind) {</span>
<span class="line-removed">-     case ReservedForFlagsAndNotABasePtr:</span>
<span class="line-removed">-         RELEASE_BASSERT_NOT_REACHED();</span>
<span class="line-removed">-     case Primitive:</span>
<span class="line-removed">-         return basePtrs.primitive;</span>
<span class="line-removed">-     case JSValue:</span>
<span class="line-removed">-         return basePtrs.jsValue;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     BCRASH();</span>
<span class="line-removed">-     return basePtrs.primitive;</span>
<span class="line-removed">- }</span>
  
<span class="line-modified">! BINLINE BasePtrs&amp; basePtrs()</span>
  {
<span class="line-modified">!     return *reinterpret_cast&lt;BasePtrs*&gt;(reinterpret_cast&lt;void*&gt;(g_gigacageBasePtrs));</span>
  }
  
<span class="line-modified">! BINLINE void*&amp; basePtr(Kind kind)</span>
  {
<span class="line-modified">!     return basePtr(basePtrs(), kind);</span>
  }
  
  BINLINE bool isEnabled(Kind kind)
  {
<span class="line-modified">!     return !!basePtr(kind);</span>
  }
  
  BINLINE size_t size(Kind kind)
  {
      switch (kind) {
<span class="line-removed">-     case ReservedForFlagsAndNotABasePtr:</span>
<span class="line-removed">-         RELEASE_BASSERT_NOT_REACHED();</span>
      case Primitive:
          return static_cast&lt;size_t&gt;(primitiveGigacageSize);
      case JSValue:
          return static_cast&lt;size_t&gt;(jsValueGigacageSize);
      }
      BCRASH();
      return 0;
  }
  
<span class="line-new-header">--- 95,97 ---</span>
  constexpr size_t gigacageSizeToMask(size_t size) { return size - 1; }
  
  constexpr size_t primitiveGigacageMask = gigacageSizeToMask(primitiveGigacageSize);
  constexpr size_t jsValueGigacageMask = gigacageSizeToMask(jsValueGigacageSize);
  
<span class="line-modified">! struct Config {</span>
<span class="line-added">+     void* basePtr(Kind kind) const</span>
<span class="line-added">+     {</span>
<span class="line-added">+         RELEASE_BASSERT(kind &lt; NumberOfKinds);</span>
<span class="line-added">+         return basePtrs[kind];</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     void setBasePtr(Kind kind, void* ptr)</span>
<span class="line-modified">!     {</span>
<span class="line-added">+         RELEASE_BASSERT(kind &lt; NumberOfKinds);</span>
<span class="line-added">+         basePtrs[kind] = ptr;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     union {</span>
<span class="line-modified">!         struct {</span>
<span class="line-modified">!             // All the fields in this struct should be chosen such that their</span>
<span class="line-modified">!             // initial value is 0 / null / falsy because Config is instantiated</span>
<span class="line-added">+             // as a global singleton.</span>
<span class="line-added">+ </span>
<span class="line-added">+             bool isEnabled;</span>
<span class="line-added">+             bool isPermanentlyFrozen;</span>
<span class="line-added">+             bool disablingPrimitiveGigacageIsForbidden;</span>
<span class="line-added">+             bool shouldBeEnabled;</span>
<span class="line-added">+ </span>
<span class="line-added">+             // We would like to just put the std::once_flag for these functions</span>
<span class="line-added">+             // here, but we can&#39;t because std::once_flag has a implicitly-deleted</span>
<span class="line-added">+             // default constructor. So, we use a boolean instead.</span>
<span class="line-added">+             bool shouldBeEnabledHasBeenCalled;</span>
<span class="line-added">+             bool ensureGigacageHasBeenCalled;</span>
<span class="line-added">+ </span>
<span class="line-added">+             void* start;</span>
<span class="line-added">+             size_t totalSize;</span>
<span class="line-added">+             void* basePtrs[NumberOfKinds];</span>
<span class="line-added">+         };</span>
<span class="line-added">+         char ensureSize[configSizeToProtect];</span>
<span class="line-added">+     };</span>
  };
<span class="line-added">+ static_assert(sizeof(Config) == configSizeToProtect, &quot;Gigacage Config must fit in configSizeToProtect&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+ extern &quot;C&quot; alignas(configSizeToProtect) BEXPORT Config g_gigacageConfig;</span>
  
<span class="line-modified">! // These constants are needed by the LLInt.</span>
<span class="line-modified">! constexpr ptrdiff_t offsetOfPrimitiveGigacageBasePtr = Kind::Primitive * sizeof(void*);</span>
<span class="line-added">+ constexpr ptrdiff_t offsetOfJSValueGigacageBasePtr = Kind::JSValue * sizeof(void*);</span>
  
<span class="line-modified">! </span>
<span class="line-added">+ BINLINE bool isEnabled() { return g_gigacageConfig.isEnabled; }</span>
  
  BEXPORT void ensureGigacage();
  
  BEXPORT void disablePrimitiveGigacage();
  
  // This will call the disable callback immediately if the Primitive Gigacage is currently disabled.
  BEXPORT void addPrimitiveDisableCallback(void (*)(void*), void*);
  BEXPORT void removePrimitiveDisableCallback(void (*)(void*), void*);
  
<span class="line-modified">! BEXPORT void forbidDisablingPrimitiveGigacage();</span>
  
<span class="line-modified">! BEXPORT bool isDisablingPrimitiveGigacageForbidden();</span>
<span class="line-modified">! inline bool isPrimitiveGigacagePermanentlyEnabled() { return isDisablingPrimitiveGigacageForbidden(); }</span>
<span class="line-modified">! inline bool canPrimitiveGigacageBeDisabled() { return !isDisablingPrimitiveGigacageForbidden(); }</span>
  
<span class="line-modified">! BINLINE void* basePtr(Kind kind)</span>
  {
<span class="line-modified">!     return g_gigacageConfig.basePtr(kind);</span>
  }
  
<span class="line-modified">! BINLINE void* addressOfBasePtr(Kind kind)</span>
  {
<span class="line-modified">!     RELEASE_BASSERT(kind &lt; NumberOfKinds);</span>
<span class="line-added">+     return &amp;g_gigacageConfig.basePtrs[kind];</span>
  }
  
  BINLINE bool isEnabled(Kind kind)
  {
<span class="line-modified">!     return !!g_gigacageConfig.basePtr(kind);</span>
  }
  
  BINLINE size_t size(Kind kind)
  {
      switch (kind) {
      case Primitive:
          return static_cast&lt;size_t&gt;(primitiveGigacageSize);
      case JSValue:
          return static_cast&lt;size_t&gt;(jsValueGigacageSize);
<span class="line-added">+     case NumberOfKinds:</span>
<span class="line-added">+         break;</span>
      }
      BCRASH();
      return 0;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 190,11 ***</span>
  
  template&lt;typename T&gt;
  BINLINE T* caged(Kind kind, T* ptr)
  {
      BASSERT(ptr);
<span class="line-modified">!     void* gigacageBasePtr = basePtr(kind);</span>
      if (!gigacageBasePtr)
          return ptr;
      return reinterpret_cast&lt;T*&gt;(
          reinterpret_cast&lt;uintptr_t&gt;(gigacageBasePtr) + (
              reinterpret_cast&lt;uintptr_t&gt;(ptr) &amp; mask(kind)));
<span class="line-new-header">--- 208,11 ---</span>
  
  template&lt;typename T&gt;
  BINLINE T* caged(Kind kind, T* ptr)
  {
      BASSERT(ptr);
<span class="line-modified">!     void* gigacageBasePtr = g_gigacageConfig.basePtr(kind);</span>
      if (!gigacageBasePtr)
          return ptr;
      return reinterpret_cast&lt;T*&gt;(
          reinterpret_cast&lt;uintptr_t&gt;(gigacageBasePtr) + (
              reinterpret_cast&lt;uintptr_t&gt;(ptr) &amp; mask(kind)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 211,28 ***</span>
  BINLINE bool isCaged(Kind kind, const void* ptr)
  {
      return caged(kind, ptr) == ptr;
  }
  
  BEXPORT bool shouldBeEnabled();
  
  #else // GIGACAGE_ENABLED
  
<span class="line-modified">! BINLINE void*&amp; basePtr(Kind)</span>
  {
      BCRASH();
      static void* unreachable;
      return unreachable;
  }
  BINLINE size_t size(Kind) { BCRASH(); return 0; }
  BINLINE void ensureGigacage() { }
<span class="line-modified">! BINLINE bool wasEnabled() { return false; }</span>
  BINLINE bool isCaged(Kind, const void*) { return true; }
  BINLINE bool isEnabled(Kind) { return false; }
  template&lt;typename T&gt; BINLINE T* caged(Kind, T* ptr) { return ptr; }
  template&lt;typename T&gt; BINLINE T* cagedMayBeNull(Kind, T* ptr) { return ptr; }
<span class="line-modified">! BINLINE void disableDisablingPrimitiveGigacageIfShouldBeEnabled() { }</span>
  BINLINE bool canPrimitiveGigacageBeDisabled() { return false; }
  BINLINE void disablePrimitiveGigacage() { }
  BINLINE void addPrimitiveDisableCallback(void (*)(void*), void*) { }
  BINLINE void removePrimitiveDisableCallback(void (*)(void*), void*) { }
  
<span class="line-new-header">--- 229,36 ---</span>
  BINLINE bool isCaged(Kind kind, const void* ptr)
  {
      return caged(kind, ptr) == ptr;
  }
  
<span class="line-added">+ BINLINE bool contains(const void* ptr)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto* start = reinterpret_cast&lt;const uint8_t*&gt;(g_gigacageConfig.start);</span>
<span class="line-added">+     auto* p = reinterpret_cast&lt;const uint8_t*&gt;(ptr);</span>
<span class="line-added">+     return static_cast&lt;size_t&gt;(p - start) &lt; g_gigacageConfig.totalSize;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  BEXPORT bool shouldBeEnabled();
  
  #else // GIGACAGE_ENABLED
  
<span class="line-modified">! BINLINE void* basePtr(Kind)</span>
  {
      BCRASH();
      static void* unreachable;
      return unreachable;
  }
  BINLINE size_t size(Kind) { BCRASH(); return 0; }
  BINLINE void ensureGigacage() { }
<span class="line-modified">! BINLINE bool contains(const void*) { return false; }</span>
<span class="line-added">+ BINLINE bool isEnabled() { return false; }</span>
  BINLINE bool isCaged(Kind, const void*) { return true; }
  BINLINE bool isEnabled(Kind) { return false; }
  template&lt;typename T&gt; BINLINE T* caged(Kind, T* ptr) { return ptr; }
  template&lt;typename T&gt; BINLINE T* cagedMayBeNull(Kind, T* ptr) { return ptr; }
<span class="line-modified">! BINLINE void forbidDisablingPrimitiveGigacage() { }</span>
  BINLINE bool canPrimitiveGigacageBeDisabled() { return false; }
  BINLINE void disablePrimitiveGigacage() { }
  BINLINE void addPrimitiveDisableCallback(void (*)(void*), void*) { }
  BINLINE void removePrimitiveDisableCallback(void (*)(void*), void*) { }
  
</pre>
<center><a href="Gigacage.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Heap.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VMTraps.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="VMInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VMTraps.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/VMTraps.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;VMTraps.h&quot;
 28 
 29 #include &quot;CallFrame.h&quot;

 30 #include &quot;CodeBlock.h&quot;
 31 #include &quot;CodeBlockSet.h&quot;
 32 #include &quot;DFGCommonData.h&quot;
 33 #include &quot;ExceptionHelpers.h&quot;
 34 #include &quot;HeapInlines.h&quot;
 35 #include &quot;JSCPtrTag.h&quot;
 36 #include &quot;LLIntPCRanges.h&quot;
 37 #include &quot;MachineContext.h&quot;
 38 #include &quot;MachineStackMarker.h&quot;
 39 #include &quot;MacroAssembler.h&quot;
 40 #include &quot;MacroAssemblerCodeRef.h&quot;
 41 #include &quot;VM.h&quot;
 42 #include &quot;VMInspector.h&quot;
 43 #include &quot;Watchdog.h&quot;
 44 #include &lt;wtf/ProcessID.h&gt;
 45 #include &lt;wtf/ThreadMessage.h&gt;
 46 #include &lt;wtf/threads/Signals.h&gt;
 47 
 48 namespace JSC {
 49 
</pre>
<hr />
<pre>
147         auto locker = tryHoldLock(*m_lock);
148         if (!locker)
149             return; // Let the SignalSender try again later.
150 
151         if (!needTrapHandling()) {
152             // Too late. Someone else already handled the trap.
153             return;
154         }
155 
156         if (!foundCodeBlock-&gt;hasInstalledVMTrapBreakpoints())
157             foundCodeBlock-&gt;installVMTrapBreakpoints();
158         return;
159     }
160 }
161 
162 void VMTraps::invalidateCodeBlocksOnStack()
163 {
164     invalidateCodeBlocksOnStack(vm().topCallFrame);
165 }
166 
<span class="line-modified">167 void VMTraps::invalidateCodeBlocksOnStack(ExecState* topCallFrame)</span>
168 {
169     auto codeBlockSetLocker = holdLock(vm().heap.codeBlockSet().getLock());
170     invalidateCodeBlocksOnStack(codeBlockSetLocker, topCallFrame);
171 }
172 
<span class="line-modified">173 void VMTraps::invalidateCodeBlocksOnStack(Locker&lt;Lock&gt;&amp;, ExecState* topCallFrame)</span>
174 {
175     if (!m_needToInvalidatedCodeBlocks)
176         return;
177 
178     m_needToInvalidatedCodeBlocks = false;
179 
180     EntryFrame* entryFrame = vm().topEntryFrame;
181     CallFrame* callFrame = topCallFrame;
182 
183     if (!entryFrame)
184         return; // Not running JS code. Nothing to invalidate.
185 
186     while (callFrame) {
187         CodeBlock* codeBlock = callFrame-&gt;codeBlock();
188         if (codeBlock &amp;&amp; JITCode::isOptimizingJIT(codeBlock-&gt;jitType()))
189             codeBlock-&gt;jettison(Profiler::JettisonDueToVMTraps);
190         callFrame = callFrame-&gt;callerFrame(entryFrame);
191     }
192 }
193 
</pre>
<hr />
<pre>
317     {
318         auto locker = holdLock(*m_lock);
319         ASSERT(!m_isShuttingDown);
320         setTrapForEvent(locker, eventType);
321         m_needToInvalidatedCodeBlocks = true;
322     }
323 
324 #if ENABLE(SIGNAL_BASED_VM_TRAPS)
325     if (!Options::usePollingTraps()) {
326         // sendSignal() can loop until it has confirmation that the mutator thread
327         // has received the trap request. We&#39;ll call it from another thread so that
328         // fireTrap() does not block.
329         auto locker = holdLock(*m_lock);
330         if (!m_signalSender)
331             m_signalSender = adoptRef(new SignalSender(locker, vm()));
332         m_condition-&gt;notifyAll(locker);
333     }
334 #endif
335 }
336 
<span class="line-modified">337 void VMTraps::handleTraps(ExecState* exec, VMTraps::Mask mask)</span>
338 {
339     VM&amp; vm = this-&gt;vm();
340     auto scope = DECLARE_THROW_SCOPE(vm);
341 
342     {
343         auto codeBlockSetLocker = holdLock(vm.heap.codeBlockSet().getLock());
344         vm.heap.forEachCodeBlockIgnoringJITPlans(codeBlockSetLocker, [&amp;] (CodeBlock* codeBlock) {
345             // We want to jettison all code blocks that have vm traps breakpoints, otherwise we could hit them later.
346             if (codeBlock-&gt;hasInstalledVMTrapBreakpoints())
347                 codeBlock-&gt;jettison(Profiler::JettisonDueToVMTraps);
348         });
349     }
350 
351     ASSERT(needTrapHandling(mask));
352     while (needTrapHandling(mask)) {
353         auto eventType = takeTopPriorityTrap(mask);
354         switch (eventType) {
355         case NeedDebuggerBreak:
356             dataLog(&quot;VM &quot;, RawPointer(&amp;vm), &quot; on pid &quot;, getCurrentProcessID(), &quot; received NeedDebuggerBreak trap\n&quot;);
<span class="line-modified">357             invalidateCodeBlocksOnStack(exec);</span>





358             break;
359 
360         case NeedWatchdogCheck:
361             ASSERT(vm.watchdog());
<span class="line-modified">362             if (LIKELY(!vm.watchdog()-&gt;shouldTerminate(exec)))</span>
363                 continue;
364             FALLTHROUGH;
365 
366         case NeedTermination:
<span class="line-modified">367             throwException(exec, scope, createTerminatedExecutionException(&amp;vm));</span>
368             return;
369 
370         default:
371             RELEASE_ASSERT_NOT_REACHED();
372         }
373     }
374 }
375 
376 auto VMTraps::takeTopPriorityTrap(VMTraps::Mask mask) -&gt; EventType
377 {
378     auto locker = holdLock(*m_lock);
379     for (int i = 0; i &lt; NumberOfEventTypes; ++i) {
380         EventType eventType = static_cast&lt;EventType&gt;(i);
381         if (hasTrapForEvent(locker, eventType, mask)) {
382             clearTrapForEvent(locker, eventType);
383             return eventType;
384         }
385     }
386     return Invalid;
387 }
</pre>
</td>
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;VMTraps.h&quot;
 28 
 29 #include &quot;CallFrame.h&quot;
<span class="line-added"> 30 #include &quot;CallFrameInlines.h&quot;</span>
 31 #include &quot;CodeBlock.h&quot;
 32 #include &quot;CodeBlockSet.h&quot;
 33 #include &quot;DFGCommonData.h&quot;
 34 #include &quot;ExceptionHelpers.h&quot;
 35 #include &quot;HeapInlines.h&quot;
 36 #include &quot;JSCPtrTag.h&quot;
 37 #include &quot;LLIntPCRanges.h&quot;
 38 #include &quot;MachineContext.h&quot;
 39 #include &quot;MachineStackMarker.h&quot;
 40 #include &quot;MacroAssembler.h&quot;
 41 #include &quot;MacroAssemblerCodeRef.h&quot;
 42 #include &quot;VM.h&quot;
 43 #include &quot;VMInspector.h&quot;
 44 #include &quot;Watchdog.h&quot;
 45 #include &lt;wtf/ProcessID.h&gt;
 46 #include &lt;wtf/ThreadMessage.h&gt;
 47 #include &lt;wtf/threads/Signals.h&gt;
 48 
 49 namespace JSC {
 50 
</pre>
<hr />
<pre>
148         auto locker = tryHoldLock(*m_lock);
149         if (!locker)
150             return; // Let the SignalSender try again later.
151 
152         if (!needTrapHandling()) {
153             // Too late. Someone else already handled the trap.
154             return;
155         }
156 
157         if (!foundCodeBlock-&gt;hasInstalledVMTrapBreakpoints())
158             foundCodeBlock-&gt;installVMTrapBreakpoints();
159         return;
160     }
161 }
162 
163 void VMTraps::invalidateCodeBlocksOnStack()
164 {
165     invalidateCodeBlocksOnStack(vm().topCallFrame);
166 }
167 
<span class="line-modified">168 void VMTraps::invalidateCodeBlocksOnStack(CallFrame* topCallFrame)</span>
169 {
170     auto codeBlockSetLocker = holdLock(vm().heap.codeBlockSet().getLock());
171     invalidateCodeBlocksOnStack(codeBlockSetLocker, topCallFrame);
172 }
173 
<span class="line-modified">174 void VMTraps::invalidateCodeBlocksOnStack(Locker&lt;Lock&gt;&amp;, CallFrame* topCallFrame)</span>
175 {
176     if (!m_needToInvalidatedCodeBlocks)
177         return;
178 
179     m_needToInvalidatedCodeBlocks = false;
180 
181     EntryFrame* entryFrame = vm().topEntryFrame;
182     CallFrame* callFrame = topCallFrame;
183 
184     if (!entryFrame)
185         return; // Not running JS code. Nothing to invalidate.
186 
187     while (callFrame) {
188         CodeBlock* codeBlock = callFrame-&gt;codeBlock();
189         if (codeBlock &amp;&amp; JITCode::isOptimizingJIT(codeBlock-&gt;jitType()))
190             codeBlock-&gt;jettison(Profiler::JettisonDueToVMTraps);
191         callFrame = callFrame-&gt;callerFrame(entryFrame);
192     }
193 }
194 
</pre>
<hr />
<pre>
318     {
319         auto locker = holdLock(*m_lock);
320         ASSERT(!m_isShuttingDown);
321         setTrapForEvent(locker, eventType);
322         m_needToInvalidatedCodeBlocks = true;
323     }
324 
325 #if ENABLE(SIGNAL_BASED_VM_TRAPS)
326     if (!Options::usePollingTraps()) {
327         // sendSignal() can loop until it has confirmation that the mutator thread
328         // has received the trap request. We&#39;ll call it from another thread so that
329         // fireTrap() does not block.
330         auto locker = holdLock(*m_lock);
331         if (!m_signalSender)
332             m_signalSender = adoptRef(new SignalSender(locker, vm()));
333         m_condition-&gt;notifyAll(locker);
334     }
335 #endif
336 }
337 
<span class="line-modified">338 void VMTraps::handleTraps(JSGlobalObject* globalObject, CallFrame* callFrame, VMTraps::Mask mask)</span>
339 {
340     VM&amp; vm = this-&gt;vm();
341     auto scope = DECLARE_THROW_SCOPE(vm);
342 
343     {
344         auto codeBlockSetLocker = holdLock(vm.heap.codeBlockSet().getLock());
345         vm.heap.forEachCodeBlockIgnoringJITPlans(codeBlockSetLocker, [&amp;] (CodeBlock* codeBlock) {
346             // We want to jettison all code blocks that have vm traps breakpoints, otherwise we could hit them later.
347             if (codeBlock-&gt;hasInstalledVMTrapBreakpoints())
348                 codeBlock-&gt;jettison(Profiler::JettisonDueToVMTraps);
349         });
350     }
351 
352     ASSERT(needTrapHandling(mask));
353     while (needTrapHandling(mask)) {
354         auto eventType = takeTopPriorityTrap(mask);
355         switch (eventType) {
356         case NeedDebuggerBreak:
357             dataLog(&quot;VM &quot;, RawPointer(&amp;vm), &quot; on pid &quot;, getCurrentProcessID(), &quot; received NeedDebuggerBreak trap\n&quot;);
<span class="line-modified">358             invalidateCodeBlocksOnStack(callFrame);</span>
<span class="line-added">359             break;</span>
<span class="line-added">360 </span>
<span class="line-added">361         case NeedShellTimeoutCheck:</span>
<span class="line-added">362             RELEASE_ASSERT(g_jscConfig.shellTimeoutCheckCallback);</span>
<span class="line-added">363             g_jscConfig.shellTimeoutCheckCallback(vm);</span>
364             break;
365 
366         case NeedWatchdogCheck:
367             ASSERT(vm.watchdog());
<span class="line-modified">368             if (LIKELY(!vm.watchdog()-&gt;shouldTerminate(globalObject)))</span>
369                 continue;
370             FALLTHROUGH;
371 
372         case NeedTermination:
<span class="line-modified">373             throwException(globalObject, scope, createTerminatedExecutionException(&amp;vm));</span>
374             return;
375 
376         default:
377             RELEASE_ASSERT_NOT_REACHED();
378         }
379     }
380 }
381 
382 auto VMTraps::takeTopPriorityTrap(VMTraps::Mask mask) -&gt; EventType
383 {
384     auto locker = holdLock(*m_lock);
385     for (int i = 0; i &lt; NumberOfEventTypes; ++i) {
386         EventType eventType = static_cast&lt;EventType&gt;(i);
387         if (hasTrapForEvent(locker, eventType, mask)) {
388             clearTrapForEvent(locker, eventType);
389             return eventType;
390         }
391     }
392     return Invalid;
393 }
</pre>
</td>
</tr>
</table>
<center><a href="VMInlines.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VMTraps.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
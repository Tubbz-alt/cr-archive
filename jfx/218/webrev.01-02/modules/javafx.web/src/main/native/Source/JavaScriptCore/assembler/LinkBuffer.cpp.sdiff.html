<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/LinkBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AssemblerCommon.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LinkBuffer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/LinkBuffer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LinkBuffer.h&quot;
 28 
 29 #if ENABLE(ASSEMBLER)
 30 
 31 #include &quot;CodeBlock.h&quot;
 32 #include &quot;Disassembler.h&quot;
 33 #include &quot;JITCode.h&quot;
 34 #include &quot;JSCInlines.h&quot;
 35 #include &quot;Options.h&quot;

 36 #include &lt;wtf/CompilationThread.h&gt;
 37 
 38 #if OS(LINUX)
 39 #include &quot;PerfLog.h&quot;
 40 #endif
 41 
 42 namespace JSC {
 43 
 44 bool shouldDumpDisassemblyFor(CodeBlock* codeBlock)
 45 {
 46     if (codeBlock &amp;&amp; JITCode::isOptimizingJIT(codeBlock-&gt;jitType()) &amp;&amp; Options::dumpDFGDisassembly())
 47         return true;
 48     return Options::dumpDisassembly();
 49 }
 50 
















 51 LinkBuffer::CodeRef&lt;LinkBufferPtrTag&gt; LinkBuffer::finalizeCodeWithoutDisassemblyImpl()
 52 {
 53     performFinalization();
 54 
 55     ASSERT(m_didAllocate);
 56     if (m_executableMemory)
 57         return CodeRef&lt;LinkBufferPtrTag&gt;(*m_executableMemory);
 58 
 59     return CodeRef&lt;LinkBufferPtrTag&gt;::createSelfManagedCodeRef(m_code);
 60 }
 61 
 62 LinkBuffer::CodeRef&lt;LinkBufferPtrTag&gt; LinkBuffer::finalizeCodeWithDisassemblyImpl(bool dumpDisassembly, const char* format, ...)
 63 {
 64     CodeRef&lt;LinkBufferPtrTag&gt; result = finalizeCodeWithoutDisassemblyImpl();
 65 
 66 #if OS(LINUX)
 67     if (Options::logJITCodeForPerf()) {
 68         StringPrintStream out;
 69         va_list argList;
 70         va_start(argList, format);
</pre>
<hr />
<pre>
176             // branches we need to be precise, forward branches we are pessimistic
177             const uint8_t* target;
178             if (jumpsToLink[i].to() &gt;= jumpsToLink[i].from())
179                 target = codeOutData + jumpsToLink[i].to() - offset; // Compensate for what we have collapsed so far
180             else
181                 target = codeOutData + jumpsToLink[i].to() - executableOffsetFor(jumpsToLink[i].to());
182 
183             JumpLinkType jumpLinkType = MacroAssembler::computeJumpType(jumpsToLink[i], codeOutData + writePtr, target);
184             // Compact branch if we can...
185             if (MacroAssembler::canCompact(jumpsToLink[i].type())) {
186                 // Step back in the write stream
187                 int32_t delta = MacroAssembler::jumpSizeDelta(jumpsToLink[i].type(), jumpLinkType);
188                 if (delta) {
189                     writePtr -= delta;
190                     recordLinkOffsets(m_assemblerStorage, jumpsToLink[i].from() - delta, readPtr, readPtr - writePtr);
191                 }
192             }
193             jumpsToLink[i].setFrom(writePtr);
194         }
195     } else {
<span class="line-modified">196         if (!ASSERT_DISABLED) {</span>
197             for (unsigned i = 0; i &lt; jumpCount; ++i)
198                 ASSERT(!MacroAssembler::canCompact(jumpsToLink[i].type()));
199         }
200     }
201 
202     // Copy everything after the last jump
203     {
204         InstructionType* dst = bitwise_cast&lt;InstructionType*&gt;(outData + writePtr);
205         InstructionType* src = bitwise_cast&lt;InstructionType*&gt;(inData + readPtr);
206         size_t bytes = initialSize - readPtr;
207 
208         RELEASE_ASSERT(bitwise_cast&lt;uintptr_t&gt;(dst) % sizeof(InstructionType) == 0);
209         RELEASE_ASSERT(bitwise_cast&lt;uintptr_t&gt;(src) % sizeof(InstructionType) == 0);
210         RELEASE_ASSERT(bytes % sizeof(InstructionType) == 0);
211 
212         for (size_t i = 0; i &lt; bytes; i += sizeof(InstructionType)) {
213             InstructionType insn = *src++;
214 #if CPU(ARM64E) &amp;&amp; ENABLE(FAST_JIT_PERMISSIONS)
215             verifyUncompactedHash.update(insn);
216 #endif
217             *dst++ = insn;
218         }
219     }
220 
221 #if CPU(ARM64E) &amp;&amp; ENABLE(FAST_JIT_PERMISSIONS)
222     if (verifyUncompactedHash.finalHash() != expectedFinalHash) {
223         dataLogLn(&quot;Hashes don&#39;t match: &quot;, RawPointer(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(verifyUncompactedHash.finalHash()))), &quot; &quot;, RawPointer(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(expectedFinalHash))));
224         dataLogLn(&quot;Crashing!&quot;);
225         CRASH();
226     }
227 #endif
228 
229     recordLinkOffsets(m_assemblerStorage, readPtr, initialSize, readPtr - writePtr);
230 
<span class="line-removed">231 #if CPU(ARM64E) &amp;&amp; ENABLE(FAST_JIT_PERMISSIONS)</span>
<span class="line-removed">232     auto memcpyFunction = tagCFunctionPtr&lt;CopyFunctionPtrTag&gt;(memcpy);</span>
<span class="line-removed">233 #else</span>
<span class="line-removed">234     auto memcpyFunction = tagCFunctionPtr&lt;CopyFunctionPtrTag&gt;(performJITMemcpy);</span>
<span class="line-removed">235 #endif</span>
236     for (unsigned i = 0; i &lt; jumpCount; ++i) {
237         uint8_t* location = codeOutData + jumpsToLink[i].from();
238         uint8_t* target = codeOutData + jumpsToLink[i].to() - executableOffsetFor(jumpsToLink[i].to());
<span class="line-modified">239         MacroAssembler::link(jumpsToLink[i], outData + jumpsToLink[i].from(), location, target, memcpyFunction);</span>




240     }
241 
242     size_t compactSize = writePtr + initialSize - readPtr;
243     if (!m_executableMemory) {
244         size_t nopSizeInBytes = initialSize - compactSize;
<span class="line-modified">245         MacroAssembler::AssemblerType_T::fillNops(outData + compactSize, nopSizeInBytes, memcpy);</span>




246     }
247 
248 #if CPU(ARM64E) &amp;&amp; ENABLE(FAST_JIT_PERMISSIONS)
249     os_thread_self_restrict_rwx_to_rx();
250 #endif
251 
252     if (m_executableMemory) {
253         m_size = compactSize;
254         m_executableMemory-&gt;shrink(m_size);
255     }
256 
257 #if !CPU(ARM64E) || !ENABLE(FAST_JIT_PERMISSIONS)
258     ASSERT(codeOutData != outData);
259     performJITMemcpy(codeOutData, outData, m_size);
260 #else
261     ASSERT(codeOutData == outData);
262     if (UNLIKELY(Options::dumpJITMemoryPath()))
263         dumpJITMemory(outData, outData, m_size);
264 #endif
265 
</pre>
</td>
<td>
<hr />
<pre>
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;LinkBuffer.h&quot;
 28 
 29 #if ENABLE(ASSEMBLER)
 30 
 31 #include &quot;CodeBlock.h&quot;
 32 #include &quot;Disassembler.h&quot;
 33 #include &quot;JITCode.h&quot;
 34 #include &quot;JSCInlines.h&quot;
 35 #include &quot;Options.h&quot;
<span class="line-added"> 36 #include &quot;WasmCompilationMode.h&quot;</span>
 37 #include &lt;wtf/CompilationThread.h&gt;
 38 
 39 #if OS(LINUX)
 40 #include &quot;PerfLog.h&quot;
 41 #endif
 42 
 43 namespace JSC {
 44 
 45 bool shouldDumpDisassemblyFor(CodeBlock* codeBlock)
 46 {
 47     if (codeBlock &amp;&amp; JITCode::isOptimizingJIT(codeBlock-&gt;jitType()) &amp;&amp; Options::dumpDFGDisassembly())
 48         return true;
 49     return Options::dumpDisassembly();
 50 }
 51 
<span class="line-added"> 52 bool shouldDumpDisassemblyFor(Wasm::CompilationMode mode)</span>
<span class="line-added"> 53 {</span>
<span class="line-added"> 54     if (Options::asyncDisassembly() || Options::dumpDisassembly() || Options::dumpWasmDisassembly())</span>
<span class="line-added"> 55         return true;</span>
<span class="line-added"> 56     switch (mode) {</span>
<span class="line-added"> 57     case Wasm::CompilationMode::BBQMode:</span>
<span class="line-added"> 58         return Options::dumpBBQDisassembly();</span>
<span class="line-added"> 59     case Wasm::CompilationMode::OMGMode:</span>
<span class="line-added"> 60     case Wasm::CompilationMode::OMGForOSREntryMode:</span>
<span class="line-added"> 61         return Options::dumpOMGDisassembly();</span>
<span class="line-added"> 62     default:</span>
<span class="line-added"> 63         break;</span>
<span class="line-added"> 64     }</span>
<span class="line-added"> 65     return false;</span>
<span class="line-added"> 66 }</span>
<span class="line-added"> 67 </span>
 68 LinkBuffer::CodeRef&lt;LinkBufferPtrTag&gt; LinkBuffer::finalizeCodeWithoutDisassemblyImpl()
 69 {
 70     performFinalization();
 71 
 72     ASSERT(m_didAllocate);
 73     if (m_executableMemory)
 74         return CodeRef&lt;LinkBufferPtrTag&gt;(*m_executableMemory);
 75 
 76     return CodeRef&lt;LinkBufferPtrTag&gt;::createSelfManagedCodeRef(m_code);
 77 }
 78 
 79 LinkBuffer::CodeRef&lt;LinkBufferPtrTag&gt; LinkBuffer::finalizeCodeWithDisassemblyImpl(bool dumpDisassembly, const char* format, ...)
 80 {
 81     CodeRef&lt;LinkBufferPtrTag&gt; result = finalizeCodeWithoutDisassemblyImpl();
 82 
 83 #if OS(LINUX)
 84     if (Options::logJITCodeForPerf()) {
 85         StringPrintStream out;
 86         va_list argList;
 87         va_start(argList, format);
</pre>
<hr />
<pre>
193             // branches we need to be precise, forward branches we are pessimistic
194             const uint8_t* target;
195             if (jumpsToLink[i].to() &gt;= jumpsToLink[i].from())
196                 target = codeOutData + jumpsToLink[i].to() - offset; // Compensate for what we have collapsed so far
197             else
198                 target = codeOutData + jumpsToLink[i].to() - executableOffsetFor(jumpsToLink[i].to());
199 
200             JumpLinkType jumpLinkType = MacroAssembler::computeJumpType(jumpsToLink[i], codeOutData + writePtr, target);
201             // Compact branch if we can...
202             if (MacroAssembler::canCompact(jumpsToLink[i].type())) {
203                 // Step back in the write stream
204                 int32_t delta = MacroAssembler::jumpSizeDelta(jumpsToLink[i].type(), jumpLinkType);
205                 if (delta) {
206                     writePtr -= delta;
207                     recordLinkOffsets(m_assemblerStorage, jumpsToLink[i].from() - delta, readPtr, readPtr - writePtr);
208                 }
209             }
210             jumpsToLink[i].setFrom(writePtr);
211         }
212     } else {
<span class="line-modified">213         if (ASSERT_ENABLED) {</span>
214             for (unsigned i = 0; i &lt; jumpCount; ++i)
215                 ASSERT(!MacroAssembler::canCompact(jumpsToLink[i].type()));
216         }
217     }
218 
219     // Copy everything after the last jump
220     {
221         InstructionType* dst = bitwise_cast&lt;InstructionType*&gt;(outData + writePtr);
222         InstructionType* src = bitwise_cast&lt;InstructionType*&gt;(inData + readPtr);
223         size_t bytes = initialSize - readPtr;
224 
225         RELEASE_ASSERT(bitwise_cast&lt;uintptr_t&gt;(dst) % sizeof(InstructionType) == 0);
226         RELEASE_ASSERT(bitwise_cast&lt;uintptr_t&gt;(src) % sizeof(InstructionType) == 0);
227         RELEASE_ASSERT(bytes % sizeof(InstructionType) == 0);
228 
229         for (size_t i = 0; i &lt; bytes; i += sizeof(InstructionType)) {
230             InstructionType insn = *src++;
231 #if CPU(ARM64E) &amp;&amp; ENABLE(FAST_JIT_PERMISSIONS)
232             verifyUncompactedHash.update(insn);
233 #endif
234             *dst++ = insn;
235         }
236     }
237 
238 #if CPU(ARM64E) &amp;&amp; ENABLE(FAST_JIT_PERMISSIONS)
239     if (verifyUncompactedHash.finalHash() != expectedFinalHash) {
240         dataLogLn(&quot;Hashes don&#39;t match: &quot;, RawPointer(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(verifyUncompactedHash.finalHash()))), &quot; &quot;, RawPointer(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(expectedFinalHash))));
241         dataLogLn(&quot;Crashing!&quot;);
242         CRASH();
243     }
244 #endif
245 
246     recordLinkOffsets(m_assemblerStorage, readPtr, initialSize, readPtr - writePtr);
247 





248     for (unsigned i = 0; i &lt; jumpCount; ++i) {
249         uint8_t* location = codeOutData + jumpsToLink[i].from();
250         uint8_t* target = codeOutData + jumpsToLink[i].to() - executableOffsetFor(jumpsToLink[i].to());
<span class="line-modified">251 #if CPU(ARM64E) &amp;&amp; ENABLE(FAST_JIT_PERMISSIONS)</span>
<span class="line-added">252         MacroAssembler::link&lt;memcpy&gt;(jumpsToLink[i], outData + jumpsToLink[i].from(), location, target);</span>
<span class="line-added">253 #else</span>
<span class="line-added">254         MacroAssembler::link&lt;performJITMemcpy&gt;(jumpsToLink[i], outData + jumpsToLink[i].from(), location, target);</span>
<span class="line-added">255 #endif</span>
256     }
257 
258     size_t compactSize = writePtr + initialSize - readPtr;
259     if (!m_executableMemory) {
260         size_t nopSizeInBytes = initialSize - compactSize;
<span class="line-modified">261 #if CPU(ARM64E) &amp;&amp; ENABLE(FAST_JIT_PERMISSIONS)</span>
<span class="line-added">262         Assembler::fillNops&lt;memcpy&gt;(outData + compactSize, nopSizeInBytes);</span>
<span class="line-added">263 #else</span>
<span class="line-added">264         Assembler::fillNops&lt;performJITMemcpy&gt;(outData + compactSize, nopSizeInBytes);</span>
<span class="line-added">265 #endif</span>
266     }
267 
268 #if CPU(ARM64E) &amp;&amp; ENABLE(FAST_JIT_PERMISSIONS)
269     os_thread_self_restrict_rwx_to_rx();
270 #endif
271 
272     if (m_executableMemory) {
273         m_size = compactSize;
274         m_executableMemory-&gt;shrink(m_size);
275     }
276 
277 #if !CPU(ARM64E) || !ENABLE(FAST_JIT_PERMISSIONS)
278     ASSERT(codeOutData != outData);
279     performJITMemcpy(codeOutData, outData, m_size);
280 #else
281     ASSERT(codeOutData == outData);
282     if (UNLIKELY(Options::dumpJITMemoryPath()))
283         dumpJITMemory(outData, outData, m_size);
284 #endif
285 
</pre>
</td>
</tr>
</table>
<center><a href="AssemblerCommon.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="LinkBuffer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
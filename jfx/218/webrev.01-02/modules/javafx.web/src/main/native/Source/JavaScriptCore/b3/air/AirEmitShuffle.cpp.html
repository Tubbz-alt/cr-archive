<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/AirEmitShuffle.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AirEmitShuffle.h&quot;
 28 
 29 #if ENABLE(B3_JIT)
 30 
 31 #include &quot;AirCode.h&quot;
 32 #include &quot;AirInstInlines.h&quot;
 33 #include &lt;wtf/GraphNodeWorklist.h&gt;
 34 #include &lt;wtf/ListDump.h&gt;
 35 
 36 namespace JSC { namespace B3 { namespace Air {
 37 
 38 namespace {
 39 
 40 namespace AirEmitShuffleInternal {
 41 static constexpr bool verbose = false;
 42 }
 43 
 44 template&lt;typename Functor&gt;
 45 Tmp findPossibleScratch(Code&amp; code, Bank bank, const Functor&amp; functor) {
 46     for (Reg reg : code.regsInPriorityOrder(bank)) {
 47         Tmp tmp(reg);
 48         if (functor(tmp))
 49             return tmp;
 50     }
 51     return Tmp();
 52 }
 53 
 54 Tmp findPossibleScratch(Code&amp; code, Bank bank, const Arg&amp; arg1, const Arg&amp; arg2) {
 55     return findPossibleScratch(
 56         code, bank,
 57         [&amp;] (Tmp tmp) -&gt; bool {
 58             return !arg1.usesTmp(tmp) &amp;&amp; !arg2.usesTmp(tmp);
 59         });
 60 }
 61 
 62 // Example: (a =&gt; b, b =&gt; a, a =&gt; c, b =&gt; d)
 63 struct Rotate {
 64     Vector&lt;ShufflePair&gt; loop; // in the example, this is the loop: (a =&gt; b, b =&gt; a)
 65     Vector&lt;ShufflePair&gt; fringe; // in the example, these are the associated shifts: (a =&gt; c, b =&gt; d)
 66 };
 67 
 68 } // anonymous namespace
 69 
 70 Bank ShufflePair::bank() const
 71 {
 72     if (src().isMemory() &amp;&amp; dst().isMemory() &amp;&amp; width() &gt; pointerWidth()) {
 73         // 8-byte memory-to-memory moves on a 32-bit platform are best handled as float moves.
 74         return FP;
 75     }
 76 
 77     if (src().isGP() &amp;&amp; dst().isGP()) {
 78         // This means that gpPairs gets memory-to-memory shuffles. The assumption is that we
 79         // can do that more efficiently using GPRs, except in the special case above.
 80         return GP;
 81     }
 82 
 83     return FP;
 84 }
 85 
 86 Vector&lt;Inst, 2&gt; ShufflePair::insts(Code&amp; code, Value* origin) const
 87 {
 88     if (UNLIKELY(src().isMemory() &amp;&amp; dst().isMemory()))
 89         return { Inst(moveFor(bank(), width()), origin, src(), dst(), code.newTmp(bank())) };
 90 
 91     if (isValidForm(moveFor(bank(), width()), src().kind(), dst().kind()))
 92         return { Inst(moveFor(bank(), width()), origin, src(), dst()) };
 93 
 94     // We must be a store immediate or a move immediate if we reach here. The reason:
 95     // 1. We&#39;re not a mem-&gt;mem move, given the above check.
 96     // 2. It&#39;s always valid to do a load from Addr into a tmp using Move/Move32/MoveFloat/MoveDouble.
 97     ASSERT(isValidForm(moveFor(bank(), width()), Arg::Addr, Arg::Tmp));
 98     // 3. It&#39;s also always valid to do a Tmp-&gt;Tmp move.
 99     ASSERT(isValidForm(moveFor(bank(), width()), Arg::Tmp, Arg::Tmp));
100     // 4. It&#39;s always valid to do a Tmp-&gt;Addr store.
101     ASSERT(isValidForm(moveFor(bank(), width()), Arg::Tmp, Arg::Addr));
102 
103     ASSERT(src().isSomeImm());
104     Tmp tmp = code.newTmp(bank());
105     ASSERT(isValidForm(Move, Arg::BigImm, Arg::Tmp));
106     ASSERT(isValidForm(moveFor(bank(), width()), Arg::Tmp, dst().kind()));
107     return {
108         Inst(Move, origin, Arg::bigImm(src().value()), tmp),
109         Inst(moveFor(bank(), width()), origin, tmp, dst()),
110     };
111 }
112 
113 void ShufflePair::dump(PrintStream&amp; out) const
114 {
115     out.print(width(), &quot;:&quot;, src(), &quot;=&gt;&quot;, dst());
116 }
117 
118 Inst createShuffle(Value* origin, const Vector&lt;ShufflePair&gt;&amp; pairs)
119 {
120     Inst result(Shuffle, origin);
121     for (const ShufflePair&amp; pair : pairs)
122         result.append(pair.src(), pair.dst(), Arg::widthArg(pair.width()));
123     return result;
124 }
125 
126 Vector&lt;Inst&gt; emitShuffle(
127     Code&amp; code, Vector&lt;ShufflePair&gt; pairs, std::array&lt;Arg, 2&gt; scratches, Bank bank,
128     Value* origin)
129 {
130     if (AirEmitShuffleInternal::verbose) {
131         dataLog(
132             &quot;Dealing with pairs: &quot;, listDump(pairs), &quot; and scratches &quot;, scratches[0], &quot;, &quot;,
133             scratches[1], &quot;\n&quot;);
134     }
135 
136     pairs.removeAllMatching(
137         [&amp;] (const ShufflePair&amp; pair) -&gt; bool {
138             return pair.src() == pair.dst();
139         });
140 
141     // First validate that this is the kind of shuffle that we know how to deal with.
142 #if ASSERT_ENABLED
143     for (const ShufflePair&amp; pair : pairs) {
144         ASSERT(pair.src().isBank(bank));
145         ASSERT(pair.dst().isBank(bank));
146         ASSERT(pair.dst().isTmp() || pair.dst().isMemory());
147     }
148 #endif // ASSERT_ENABLED
149 
150     // There are two possible kinds of operations that we will do:
151     //
152     // - Shift. Example: (a =&gt; b, b =&gt; c). We emit this as &quot;Move b, c; Move a, b&quot;. This only requires
153     //   scratch registers if there are memory-&gt;memory moves. We want to find as many of these as
154     //   possible because they are cheaper. Note that shifts can involve the same source mentioned
155     //   multiple times. Example: (a =&gt; b, a =&gt; c, b =&gt; d, b =&gt; e).
156     //
157     // - Rotate. Example: (a =&gt; b, b =&gt; a). We want to emit this as &quot;Swap a, b&quot;, but that instruction
158     //   may not be available, in which case we may need a scratch register or a scratch memory
159     //   location. A gnarlier example is (a =&gt; b, b =&gt; c, c =&gt; a). We can emit this as &quot;Swap b, c;
160     //   Swap a, b&quot;. Note that swapping has to be careful about differing widths.
161     //
162     // Note that a rotate can have &quot;fringe&quot;. For example, we might have (a =&gt; b, b =&gt; a, a =&gt;c,
163     // b =&gt; d). This has a rotate loop (a =&gt; b, b =&gt; a) and some fringe (a =&gt; c, b =&gt; d). We treat
164     // the whole thing as a single rotate.
165     //
166     // We will find multiple disjoint such operations. We can execute them in any order.
167 
168     // We interpret these as Moves that should be executed backwards. All shifts are keyed by their
169     // starting source.
170     HashMap&lt;Arg, Vector&lt;ShufflePair&gt;&gt; shifts;
171 
172     // We interpret these as Swaps over src()&#39;s that should be executed backwards, i.e. for a list
173     // of size 3 we would do &quot;Swap list[1].src(), list[2].src(); Swap list[0].src(), list[1].src()&quot;.
174     // Note that we actually can&#39;t do that if the widths don&#39;t match or other bad things happen.
175     // But, prior to executing all of that, we need to execute the fringe: the shifts comming off the
176     // rotate.
177     Vector&lt;Rotate&gt; rotates;
178 
179     {
180         HashMap&lt;Arg, Vector&lt;ShufflePair&gt;&gt; mapping;
181         for (const ShufflePair&amp; pair : pairs)
182             mapping.add(pair.src(), Vector&lt;ShufflePair&gt;()).iterator-&gt;value.append(pair);
183 
184         Vector&lt;ShufflePair&gt; currentPairs;
185 
186         while (!mapping.isEmpty()) {
187             ASSERT(currentPairs.isEmpty());
188             Arg originalSrc = mapping.begin()-&gt;key;
189             ASSERT(!shifts.contains(originalSrc));
190             if (AirEmitShuffleInternal::verbose)
191                 dataLog(&quot;Processing from &quot;, originalSrc, &quot;\n&quot;);
192 
193             GraphNodeWorklist&lt;Arg&gt; worklist;
194             worklist.push(originalSrc);
195             while (Arg src = worklist.pop()) {
196                 HashMap&lt;Arg, Vector&lt;ShufflePair&gt;&gt;::iterator iter = mapping.find(src);
197                 if (iter == mapping.end()) {
198                     // With a shift it&#39;s possible that we previously built the tail of this shift.
199                     // See if that&#39;s the case now.
200                     if (AirEmitShuffleInternal::verbose)
201                         dataLog(&quot;Trying to append shift at &quot;, src, &quot;\n&quot;);
202                     currentPairs.appendVector(shifts.take(src));
203                     continue;
204                 }
205                 Vector&lt;ShufflePair&gt; pairs = WTFMove(iter-&gt;value);
206                 mapping.remove(iter);
207 
208                 for (const ShufflePair&amp; pair : pairs) {
209                     currentPairs.append(pair);
210                     ASSERT(pair.src() == src);
211                     worklist.push(pair.dst());
212                 }
213             }
214 
215             ASSERT(currentPairs.size());
216             ASSERT(currentPairs[0].src() == originalSrc);
217 
218             if (AirEmitShuffleInternal::verbose)
219                 dataLog(&quot;currentPairs = &quot;, listDump(currentPairs), &quot;\n&quot;);
220 
221             bool isRotate = false;
222             for (const ShufflePair&amp; pair : currentPairs) {
223                 if (pair.dst() == originalSrc) {
224                     isRotate = true;
225                     break;
226                 }
227             }
228 
229             if (isRotate) {
230                 if (AirEmitShuffleInternal::verbose)
231                     dataLog(&quot;It&#39;s a rotate.\n&quot;);
232                 Rotate rotate;
233 
234                 // The common case is that the rotate does not have fringe. The only way to
235                 // check for this is to examine the whole rotate.
236                 bool ok;
237                 if (currentPairs.last().dst() == originalSrc) {
238                     ok = true;
239                     for (unsigned i = currentPairs.size() - 1; i--;)
240                         ok &amp;= currentPairs[i].dst() == currentPairs[i + 1].src();
241                 } else
242                     ok = false;
243 
244                 if (ok)
245                     rotate.loop = WTFMove(currentPairs);
246                 else {
247                     // This is the slow path. The rotate has fringe.
248 
249                     HashMap&lt;Arg, ShufflePair&gt; dstMapping;
250                     for (const ShufflePair&amp; pair : currentPairs)
251                         dstMapping.add(pair.dst(), pair);
252 
253                     ShufflePair pair = dstMapping.take(originalSrc);
254                     for (;;) {
255                         rotate.loop.append(pair);
256 
257                         auto iter = dstMapping.find(pair.src());
258                         if (iter == dstMapping.end())
259                             break;
260                         pair = iter-&gt;value;
261                         dstMapping.remove(iter);
262                     }
263 
264                     rotate.loop.reverse();
265 
266                     // Make sure that the fringe appears in the same order as how it appeared in the
267                     // currentPairs, since that&#39;s the DFS order.
268                     for (const ShufflePair&amp; pair : currentPairs) {
269                         // But of course we only include it if it&#39;s not in the loop.
270                         if (dstMapping.contains(pair.dst()))
271                             rotate.fringe.append(pair);
272                     }
273                 }
274 
275                 // If the graph search terminates because we returned to the first source, then the
276                 // pair list has to have a very particular shape.
277                 for (unsigned i = rotate.loop.size() - 1; i--;)
278                     ASSERT(rotate.loop[i].dst() == rotate.loop[i + 1].src());
279                 rotates.append(WTFMove(rotate));
280                 currentPairs.shrink(0);
281             } else {
282                 if (AirEmitShuffleInternal::verbose)
283                     dataLog(&quot;It&#39;s a shift.\n&quot;);
284                 shifts.add(originalSrc, WTFMove(currentPairs));
285             }
286         }
287     }
288 
289     if (AirEmitShuffleInternal::verbose) {
290         dataLog(&quot;Shifts:\n&quot;);
291         for (auto&amp; entry : shifts)
292             dataLog(&quot;    &quot;, entry.key, &quot;: &quot;, listDump(entry.value), &quot;\n&quot;);
293         dataLog(&quot;Rotates:\n&quot;);
294         for (auto&amp; rotate : rotates)
295             dataLog(&quot;    loop = &quot;, listDump(rotate.loop), &quot;, fringe = &quot;, listDump(rotate.fringe), &quot;\n&quot;);
296     }
297 
298     // In the worst case, we need two scratch registers. The way we do this is that the client passes
299     // us what scratch registers he happens to have laying around. We will need scratch registers in
300     // the following cases:
301     //
302     // - Shuffle pairs where both src and dst refer to memory.
303     // - Rotate when no Swap instruction is available.
304     //
305     // Lucky for us, we are guaranteed to have extra scratch registers anytime we have a Shift that
306     // ends with a register. We search for such a register right now.
307 
308     auto moveForWidth = [&amp;] (Width width) -&gt; Opcode {
309         return moveFor(bank, width);
310     };
311 
312     Opcode conservativeMove = moveForWidth(conservativeWidth(bank));
313 
314     // We will emit things in reverse. We maintain a list of packs of instructions, and then we emit
315     // append them together in reverse (for example the thing at the end of resultPacks is placed
316     // first). This is useful because the last thing we emit frees up its destination registers, so
317     // it affects how we emit things before it.
318     Vector&lt;Vector&lt;Inst&gt;&gt; resultPacks;
319     Vector&lt;Inst&gt; result;
320 
321     auto commitResult = [&amp;] () {
322         resultPacks.append(WTFMove(result));
323     };
324 
325     auto getScratch = [&amp;] (unsigned index, Tmp possibleScratch) -&gt; Tmp {
326         if (scratches[index].isTmp())
327             return scratches[index].tmp();
328 
329         if (!possibleScratch)
330             return Tmp();
331         result.append(Inst(conservativeMove, origin, possibleScratch, scratches[index]));
332         return possibleScratch;
333     };
334 
335     auto returnScratch = [&amp;] (unsigned index, Tmp tmp) {
336         if (Arg(tmp) != scratches[index])
337             result.append(Inst(conservativeMove, origin, scratches[index], tmp));
338     };
339 
340     auto handleShiftPair = [&amp;] (const ShufflePair&amp; pair, unsigned scratchIndex) {
341         Opcode move = moveForWidth(pair.width());
342 
343         if (!isValidForm(move, pair.src().kind(), pair.dst().kind())) {
344             Tmp scratch =
345                 getScratch(scratchIndex, findPossibleScratch(code, bank, pair.src(), pair.dst()));
346             RELEASE_ASSERT(scratch);
347             if (isValidForm(move, pair.src().kind(), Arg::Tmp))
348                 result.append(Inst(moveForWidth(pair.width()), origin, pair.src(), scratch));
349             else {
350                 ASSERT(pair.src().isSomeImm());
351                 ASSERT(move == Move32);
352                 result.append(Inst(Move, origin, Arg::bigImm(pair.src().value()), scratch));
353             }
354             result.append(Inst(moveForWidth(pair.width()), origin, scratch, pair.dst()));
355             returnScratch(scratchIndex, scratch);
356             return;
357         }
358 
359         result.append(Inst(move, origin, pair.src(), pair.dst()));
360     };
361 
362     auto handleShift = [&amp;] (Vector&lt;ShufflePair&gt;&amp; shift) {
363         // FIXME: We could optimize the spill behavior of the shifter by checking if any of the
364         // shifts need spills. If they do, then we could try to get a register out here. Note that
365         // this may fail where the current strategy succeeds: out here we need a register that does
366         // not interfere with any of the shifts, while the current strategy only needs to find a
367         // scratch register that does not interfer with a particular shift. So, this optimization
368         // will be opportunistic: if it succeeds, then the individual shifts can use that scratch,
369         // otherwise they will do what they do now.
370 
371         for (unsigned i = shift.size(); i--;)
372             handleShiftPair(shift[i], 0);
373 
374         Arg lastDst = shift.last().dst();
375         if (lastDst.isTmp()) {
376             for (Arg&amp; scratch : scratches) {
377                 ASSERT(scratch != lastDst);
378                 if (!scratch.isTmp()) {
379                     scratch = lastDst;
380                     break;
381                 }
382             }
383         }
384     };
385 
386     // First handle shifts whose last destination is a tmp because these free up scratch registers.
387     // These end up last in the final sequence, so the final destination of these shifts will be
388     // available as a scratch location for anything emitted prior (so, after, since we&#39;re emitting in
389     // reverse).
390     for (auto&amp; entry : shifts) {
391         Vector&lt;ShufflePair&gt;&amp; shift = entry.value;
392         if (shift.last().dst().isTmp())
393             handleShift(shift);
394         commitResult();
395     }
396 
397     // Now handle the rest of the shifts.
398     for (auto&amp; entry : shifts) {
399         Vector&lt;ShufflePair&gt;&amp; shift = entry.value;
400         if (!shift.last().dst().isTmp())
401             handleShift(shift);
402         commitResult();
403     }
404 
405     for (Rotate&amp; rotate : rotates) {
406         if (!rotate.fringe.isEmpty()) {
407             // Make sure we do the fringe first! This won&#39;t clobber any of the registers that are
408             // part of the rotation.
409             handleShift(rotate.fringe);
410         }
411 
412         bool canSwap = false;
413         Opcode swap = Oops;
414         Width swapWidth = Width8; // bogus value
415 
416         // Currently, the swap instruction is not available for floating point on any architecture we
417         // support.
418         if (bank == GP) {
419             // Figure out whether we will be doing 64-bit swaps or 32-bit swaps. If we have a mix of
420             // widths we handle that by fixing up the relevant register with zero-extends.
421             swap = Swap32;
422             swapWidth = Width32;
423             bool hasMemory = false;
424             bool hasIndex = false;
425             for (ShufflePair&amp; pair : rotate.loop) {
426                 switch (pair.width()) {
427                 case Width32:
428                     break;
429                 case Width64:
430                     swap = Swap64;
431                     swapWidth = Width64;
432                     break;
433                 default:
434                     RELEASE_ASSERT_NOT_REACHED();
435                     break;
436                 }
437 
438                 hasMemory |= pair.src().isMemory() || pair.dst().isMemory();
439                 hasIndex |= pair.src().isIndex() || pair.dst().isIndex();
440             }
441 
442             canSwap = isValidForm(swap, Arg::Tmp, Arg::Tmp);
443 
444             // We can totally use swaps even if there are shuffles involving memory. But, we play it
445             // safe in that case. There are corner cases we don&#39;t handle, and our ability to do it is
446             // contingent upon swap form availability.
447 
448             if (hasMemory) {
449                 canSwap &amp;= isValidForm(swap, Arg::Tmp, Arg::Addr);
450 
451                 // We don&#39;t take the swapping path if there is a mix of widths and some of the
452                 // shuffles involve memory. That gets too confusing. We might be able to relax this
453                 // to only bail if there are subwidth pairs involving memory, but I haven&#39;t thought
454                 // about it very hard. Anyway, this case is not common: rotates involving memory
455                 // don&#39;t arise for function calls, and they will only happen for rotates in user code
456                 // if some of the variables get spilled. It&#39;s hard to imagine a program that rotates
457                 // data around in variables while also doing a combination of uint32-&gt;uint64 and
458                 // int64-&gt;int32 casts.
459                 for (ShufflePair&amp; pair : rotate.loop)
460                     canSwap &amp;= pair.width() == swapWidth;
461             }
462 
463             if (hasIndex)
464                 canSwap &amp;= isValidForm(swap, Arg::Tmp, Arg::Index);
465         }
466 
467         if (canSwap) {
468             for (unsigned i = rotate.loop.size() - 1; i--;) {
469                 Arg left = rotate.loop[i].src();
470                 Arg right = rotate.loop[i + 1].src();
471 
472                 if (left.isMemory() &amp;&amp; right.isMemory()) {
473                     // Note that this is a super rare outcome. Rotates are rare. Spills are rare.
474                     // Moving data between two spills is rare. To get here a lot of rare stuff has to
475                     // all happen at once.
476 
477                     Tmp scratch = getScratch(0, findPossibleScratch(code, bank, left, right));
478                     RELEASE_ASSERT(scratch);
479                     result.append(Inst(moveForWidth(swapWidth), origin, left, scratch));
480                     result.append(Inst(swap, origin, scratch, right));
481                     result.append(Inst(moveForWidth(swapWidth), origin, scratch, left));
482                     returnScratch(0, scratch);
483                     continue;
484                 }
485 
486                 if (left.isMemory())
487                     std::swap(left, right);
488 
489                 result.append(Inst(swap, origin, left, right));
490             }
491 
492             for (ShufflePair pair : rotate.loop) {
493                 if (pair.width() == swapWidth)
494                     continue;
495 
496                 RELEASE_ASSERT(pair.width() == Width32);
497                 RELEASE_ASSERT(swapWidth == Width64);
498                 RELEASE_ASSERT(pair.dst().isTmp());
499 
500                 // Need to do an extra zero extension.
501                 result.append(Inst(Move32, origin, pair.dst(), pair.dst()));
502             }
503         } else {
504             // We can treat this as a shift so long as we take the last destination (i.e. first
505             // source) and save it first. Then we handle the first entry in the pair in the rotate
506             // specially, after we restore the last destination. This requires some special care to
507             // find a scratch register. It&#39;s possible that we have a rotate that uses the entire
508             // available register file.
509 
510             Tmp scratch = findPossibleScratch(
511                 code, bank,
512                 [&amp;] (Tmp tmp) -&gt; bool {
513                     for (ShufflePair pair : rotate.loop) {
514                         if (pair.src().usesTmp(tmp))
515                             return false;
516                         if (pair.dst().usesTmp(tmp))
517                             return false;
518                     }
519                     return true;
520                 });
521 
522             // NOTE: This is the most likely use of scratch registers.
523             scratch = getScratch(0, scratch);
524 
525             // We may not have found a scratch register. When this happens, we can just use the spill
526             // slot directly.
527             Arg rotateSave = scratch ? Arg(scratch) : scratches[0];
528 
529             handleShiftPair(
530                 ShufflePair(rotate.loop.last().dst(), rotateSave, rotate.loop[0].width()), 1);
531 
532             for (unsigned i = rotate.loop.size(); i-- &gt; 1;)
533                 handleShiftPair(rotate.loop[i], 1);
534 
535             handleShiftPair(
536                 ShufflePair(rotateSave, rotate.loop[0].dst(), rotate.loop[0].width()), 1);
537 
538             if (scratch)
539                 returnScratch(0, scratch);
540         }
541 
542         commitResult();
543     }
544 
545     ASSERT(result.isEmpty());
546 
547     for (unsigned i = resultPacks.size(); i--;)
548         result.appendVector(resultPacks[i]);
549 
550     return result;
551 }
552 
553 Vector&lt;Inst&gt; emitShuffle(
554     Code&amp; code, const Vector&lt;ShufflePair&gt;&amp; pairs,
555     const std::array&lt;Arg, 2&gt;&amp; gpScratch, const std::array&lt;Arg, 2&gt;&amp; fpScratch,
556     Value* origin)
557 {
558     Vector&lt;ShufflePair&gt; gpPairs;
559     Vector&lt;ShufflePair&gt; fpPairs;
560     for (const ShufflePair&amp; pair : pairs) {
561         switch (pair.bank()) {
562         case GP:
563             gpPairs.append(pair);
564             break;
565         case FP:
566             fpPairs.append(pair);
567             break;
568         }
569     }
570 
571     Vector&lt;Inst&gt; result;
572     result.appendVector(emitShuffle(code, gpPairs, gpScratch, GP, origin));
573     result.appendVector(emitShuffle(code, fpPairs, fpScratch, FP, origin));
574     return result;
575 }
576 
577 } } } // namespace JSC::B3::Air
578 
579 #endif // ENABLE(B3_JIT)
580 
    </pre>
  </body>
</html>
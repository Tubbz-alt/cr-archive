<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLFramebuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGLFramebuffer.h&quot;
 28 
 29 #if ENABLE(WEBGL)
 30 
<a name="1" id="anc1"></a><span class="line-modified"> 31 #include &quot;ExtensionsGL.h&quot;</span>
 32 #include &quot;WebGLContextGroup.h&quot;
 33 #include &quot;WebGLDrawBuffers.h&quot;
 34 #include &quot;WebGLRenderingContextBase.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 namespace {
 39 
 40     class WebGLRenderbufferAttachment : public WebGLFramebuffer::WebGLAttachment {
 41     public:
 42         static Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; create(WebGLRenderbuffer*);
 43 
 44     private:
 45         WebGLRenderbufferAttachment(WebGLRenderbuffer*);
<a name="2" id="anc2"></a><span class="line-modified"> 46         GCGLsizei getWidth() const override;</span>
<span class="line-modified"> 47         GCGLsizei getHeight() const override;</span>
<span class="line-modified"> 48         GCGLenum getFormat() const override;</span>
 49         WebGLSharedObject* getObject() const override;
 50         bool isSharedObject(WebGLSharedObject*) const override;
 51         bool isValid() const override;
 52         bool isInitialized() const override;
 53         void setInitialized() override;
<a name="3" id="anc3"></a><span class="line-modified"> 54         void onDetached(GraphicsContextGLOpenGL*) override;</span>
<span class="line-modified"> 55         void attach(GraphicsContextGLOpenGL*, GCGLenum attachment) override;</span>
<span class="line-modified"> 56         void unattach(GraphicsContextGLOpenGL*, GCGLenum attachment) override;</span>
 57 
 58         WebGLRenderbufferAttachment() { };
 59 
 60         RefPtr&lt;WebGLRenderbuffer&gt; m_renderbuffer;
 61     };
 62 
 63     Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; WebGLRenderbufferAttachment::create(WebGLRenderbuffer* renderbuffer)
 64     {
 65         return adoptRef(*new WebGLRenderbufferAttachment(renderbuffer));
 66     }
 67 
 68     WebGLRenderbufferAttachment::WebGLRenderbufferAttachment(WebGLRenderbuffer* renderbuffer)
 69         : m_renderbuffer(renderbuffer)
 70     {
 71     }
 72 
<a name="4" id="anc4"></a><span class="line-modified"> 73     GCGLsizei WebGLRenderbufferAttachment::getWidth() const</span>
 74     {
 75         return m_renderbuffer-&gt;getWidth();
 76     }
 77 
<a name="5" id="anc5"></a><span class="line-modified"> 78     GCGLsizei WebGLRenderbufferAttachment::getHeight() const</span>
 79     {
 80         return m_renderbuffer-&gt;getHeight();
 81     }
 82 
<a name="6" id="anc6"></a><span class="line-modified"> 83     GCGLenum WebGLRenderbufferAttachment::getFormat() const</span>
 84     {
 85         return m_renderbuffer-&gt;getInternalFormat();
 86     }
 87 
 88     WebGLSharedObject* WebGLRenderbufferAttachment::getObject() const
 89     {
 90         return m_renderbuffer-&gt;object() ? m_renderbuffer.get() : 0;
 91     }
 92 
 93     bool WebGLRenderbufferAttachment::isSharedObject(WebGLSharedObject* object) const
 94     {
 95         return object == m_renderbuffer;
 96     }
 97 
 98     bool WebGLRenderbufferAttachment::isValid() const
 99     {
100         return m_renderbuffer-&gt;object();
101     }
102 
103     bool WebGLRenderbufferAttachment::isInitialized() const
104     {
105         return m_renderbuffer-&gt;object() &amp;&amp; m_renderbuffer-&gt;isInitialized();
106     }
107 
108     void WebGLRenderbufferAttachment::setInitialized()
109     {
110         if (m_renderbuffer-&gt;object())
111             m_renderbuffer-&gt;setInitialized();
112     }
113 
<a name="7" id="anc7"></a><span class="line-modified">114     void WebGLRenderbufferAttachment::onDetached(GraphicsContextGLOpenGL* context)</span>
115     {
116         m_renderbuffer-&gt;onDetached(context);
117     }
118 
<a name="8" id="anc8"></a><span class="line-modified">119     void WebGLRenderbufferAttachment::attach(GraphicsContextGLOpenGL* context, GCGLenum attachment)</span>
120     {
<a name="9" id="anc9"></a><span class="line-modified">121         PlatformGLObject object = objectOrZero(m_renderbuffer.get());</span>
<span class="line-modified">122         context-&gt;framebufferRenderbuffer(GraphicsContextGL::FRAMEBUFFER, attachment, GraphicsContextGL::RENDERBUFFER, object);</span>
123     }
124 
<a name="10" id="anc10"></a><span class="line-modified">125     void WebGLRenderbufferAttachment::unattach(GraphicsContextGLOpenGL* context, GCGLenum attachment)</span>
126     {
<a name="11" id="anc11"></a><span class="line-modified">127 #if !USE(ANGLE)</span>
<span class="line-modified">128         if (attachment == GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT) {</span>
<span class="line-modified">129             context-&gt;framebufferRenderbuffer(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::RENDERBUFFER, 0);</span>
<span class="line-added">130             context-&gt;framebufferRenderbuffer(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::STENCIL_ATTACHMENT, GraphicsContextGL::RENDERBUFFER, 0);</span>
131         } else
<a name="12" id="anc12"></a><span class="line-modified">132 #endif</span>
<span class="line-added">133             context-&gt;framebufferRenderbuffer(GraphicsContextGL::FRAMEBUFFER, attachment, GraphicsContextGL::RENDERBUFFER, 0);</span>
134     }
135 
136     class WebGLTextureAttachment : public WebGLFramebuffer::WebGLAttachment {
137     public:
<a name="13" id="anc13"></a><span class="line-modified">138         static Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; create(WebGLTexture*, GCGLenum target, GCGLint level);</span>
139 
140     private:
<a name="14" id="anc14"></a><span class="line-modified">141         WebGLTextureAttachment(WebGLTexture*, GCGLenum target, GCGLint level);</span>
<span class="line-modified">142         GCGLsizei getWidth() const override;</span>
<span class="line-modified">143         GCGLsizei getHeight() const override;</span>
<span class="line-modified">144         GCGLenum getFormat() const override;</span>
145         WebGLSharedObject* getObject() const override;
146         bool isSharedObject(WebGLSharedObject*) const override;
147         bool isValid() const override;
148         bool isInitialized() const override;
149         void setInitialized() override;
<a name="15" id="anc15"></a><span class="line-modified">150         void onDetached(GraphicsContextGLOpenGL*) override;</span>
<span class="line-modified">151         void attach(GraphicsContextGLOpenGL*, GCGLenum attachment) override;</span>
<span class="line-modified">152         void unattach(GraphicsContextGLOpenGL*, GCGLenum attachment) override;</span>
153 
154         WebGLTextureAttachment() { };
155 
156         RefPtr&lt;WebGLTexture&gt; m_texture;
<a name="16" id="anc16"></a><span class="line-modified">157         GCGLenum m_target;</span>
<span class="line-modified">158         GCGLint m_level;</span>
159     };
160 
<a name="17" id="anc17"></a><span class="line-modified">161     Ref&lt;WebGLFramebuffer::WebGLAttachment&gt; WebGLTextureAttachment::create(WebGLTexture* texture, GCGLenum target, GCGLint level)</span>
162     {
163         return adoptRef(*new WebGLTextureAttachment(texture, target, level));
164     }
165 
<a name="18" id="anc18"></a><span class="line-modified">166     WebGLTextureAttachment::WebGLTextureAttachment(WebGLTexture* texture, GCGLenum target, GCGLint level)</span>
167         : m_texture(texture)
168         , m_target(target)
169         , m_level(level)
170     {
171     }
172 
<a name="19" id="anc19"></a><span class="line-modified">173     GCGLsizei WebGLTextureAttachment::getWidth() const</span>
174     {
175         return m_texture-&gt;getWidth(m_target, m_level);
176     }
177 
<a name="20" id="anc20"></a><span class="line-modified">178     GCGLsizei WebGLTextureAttachment::getHeight() const</span>
179     {
180         return m_texture-&gt;getHeight(m_target, m_level);
181     }
182 
<a name="21" id="anc21"></a><span class="line-modified">183     GCGLenum WebGLTextureAttachment::getFormat() const</span>
184     {
185         return m_texture-&gt;getInternalFormat(m_target, m_level);
186     }
187 
188     WebGLSharedObject* WebGLTextureAttachment::getObject() const
189     {
190         return m_texture-&gt;object() ? m_texture.get() : 0;
191     }
192 
193     bool WebGLTextureAttachment::isSharedObject(WebGLSharedObject* object) const
194     {
195         return object == m_texture;
196     }
197 
198     bool WebGLTextureAttachment::isValid() const
199     {
200         return m_texture-&gt;object();
201     }
202 
203     bool WebGLTextureAttachment::isInitialized() const
204     {
205         // Textures are assumed to be initialized.
206         return true;
207     }
208 
209     void WebGLTextureAttachment::setInitialized()
210     {
211         // Textures are assumed to be initialized.
212     }
213 
<a name="22" id="anc22"></a><span class="line-modified">214     void WebGLTextureAttachment::onDetached(GraphicsContextGLOpenGL* context)</span>
215     {
216         m_texture-&gt;onDetached(context);
217     }
218 
<a name="23" id="anc23"></a><span class="line-modified">219     void WebGLTextureAttachment::attach(GraphicsContextGLOpenGL* context, GCGLenum attachment)</span>
220     {
<a name="24" id="anc24"></a><span class="line-modified">221         PlatformGLObject object = objectOrZero(m_texture.get());</span>
<span class="line-modified">222         context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, attachment, m_target, object, m_level);</span>
223     }
224 
<a name="25" id="anc25"></a><span class="line-modified">225     void WebGLTextureAttachment::unattach(GraphicsContextGLOpenGL* context, GCGLenum attachment)</span>
226     {
<a name="26" id="anc26"></a><span class="line-modified">227 #if !USE(ANGLE)</span>
<span class="line-modified">228         if (attachment == GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT) {</span>
<span class="line-modified">229             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::DEPTH_ATTACHMENT, m_target, 0, m_level);</span>
<span class="line-added">230             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, GraphicsContextGL::STENCIL_ATTACHMENT, m_target, 0, m_level);</span>
231         } else
<a name="27" id="anc27"></a><span class="line-modified">232 #endif</span>
<span class="line-added">233             context-&gt;framebufferTexture2D(GraphicsContextGL::FRAMEBUFFER, attachment, m_target, 0, m_level);</span>
234     }
235 
<a name="28" id="anc28"></a><span class="line-modified">236     bool isAttachmentComplete(WebGLFramebuffer::WebGLAttachment* attachedObject, GCGLenum attachment, const char** reason)</span>
237     {
238         ASSERT(attachedObject &amp;&amp; attachedObject-&gt;isValid());
239         ASSERT(reason);
<a name="29" id="anc29"></a><span class="line-modified">240         GCGLenum format = attachedObject-&gt;getFormat();</span>
<span class="line-modified">241         unsigned need = GraphicsContextGLOpenGL::getClearBitsByAttachmentType(attachment);</span>
<span class="line-modified">242         unsigned have = GraphicsContextGLOpenGL::getClearBitsByFormat(format);</span>
243 
244         if ((need &amp; have) != need) {
245             *reason = &quot;attachment type is not correct for attachment&quot;;
246             return false;
247         }
248         if (!attachedObject-&gt;getWidth() || !attachedObject-&gt;getHeight()) {
249             *reason = &quot;attachment has a 0 dimension&quot;;
250             return false;
251         }
<a name="30" id="anc30"></a><span class="line-modified">252         if ((attachment == GraphicsContextGL::DEPTH_ATTACHMENT || attachment == GraphicsContextGL::STENCIL_ATTACHMENT)</span>
<span class="line-modified">253             &amp;&amp; format == GraphicsContextGL::DEPTH_STENCIL) {</span>
254           *reason = &quot;attachment DEPTH_STENCIL not allowed on DEPTH or STENCIL attachment&quot;;
255           return false;
256         }
257         return true;
258     }
259 
260 } // anonymous namespace
261 
262 WebGLFramebuffer::WebGLAttachment::WebGLAttachment() = default;
263 
264 WebGLFramebuffer::WebGLAttachment::~WebGLAttachment() = default;
265 
266 Ref&lt;WebGLFramebuffer&gt; WebGLFramebuffer::create(WebGLRenderingContextBase&amp; ctx)
267 {
268     return adoptRef(*new WebGLFramebuffer(ctx));
269 }
270 
271 WebGLFramebuffer::WebGLFramebuffer(WebGLRenderingContextBase&amp; ctx)
272     : WebGLContextObject(ctx)
273     , m_hasEverBeenBound(false)
274 {
<a name="31" id="anc31"></a><span class="line-modified">275     setObject(ctx.graphicsContextGL()-&gt;createFramebuffer());</span>
276 }
277 
278 WebGLFramebuffer::~WebGLFramebuffer()
279 {
280     deleteObject(0);
281 }
282 
<a name="32" id="anc32"></a><span class="line-modified">283 void WebGLFramebuffer::setAttachmentForBoundFramebuffer(GCGLenum attachment, GCGLenum texTarget, WebGLTexture* texture, GCGLint level)</span>
284 {
285     ASSERT(isBound());
286     removeAttachmentFromBoundFramebuffer(attachment);
287     if (!object())
288         return;
289     if (texture &amp;&amp; texture-&gt;object()) {
290         m_attachments.add(attachment, WebGLTextureAttachment::create(texture, texTarget, level));
291         drawBuffersIfNecessary(false);
292         texture-&gt;onAttached();
293     }
294 }
295 
<a name="33" id="anc33"></a><span class="line-modified">296 void WebGLFramebuffer::setAttachmentForBoundFramebuffer(GCGLenum attachment, WebGLRenderbuffer* renderbuffer)</span>
297 {
298     ASSERT(isBound());
299     removeAttachmentFromBoundFramebuffer(attachment);
300     if (!object())
301         return;
302     if (renderbuffer &amp;&amp; renderbuffer-&gt;object()) {
303         m_attachments.add(attachment, WebGLRenderbufferAttachment::create(renderbuffer));
304         drawBuffersIfNecessary(false);
305         renderbuffer-&gt;onAttached();
306     }
307 }
308 
<a name="34" id="anc34"></a><span class="line-modified">309 void WebGLFramebuffer::attach(GCGLenum attachment, GCGLenum attachmentPoint)</span>
310 {
311     ASSERT(isBound());
312     RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
313     if (attachmentObject)
<a name="35" id="anc35"></a><span class="line-modified">314         attachmentObject-&gt;attach(context()-&gt;graphicsContextGL(), attachmentPoint);</span>
315 }
316 
<a name="36" id="anc36"></a><span class="line-modified">317 WebGLSharedObject* WebGLFramebuffer::getAttachmentObject(GCGLenum attachment) const</span>
318 {
319     if (!object())
320         return 0;
321     RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
322     return attachmentObject ? attachmentObject-&gt;getObject() : 0;
323 }
324 
<a name="37" id="anc37"></a><span class="line-modified">325 WebGLFramebuffer::WebGLAttachment* WebGLFramebuffer::getAttachment(GCGLenum attachment) const</span>
326 {
327     const AttachmentMap::const_iterator it = m_attachments.find(attachment);
328     return (it != m_attachments.end()) ? it-&gt;value.get() : 0;
329 }
330 
<a name="38" id="anc38"></a><span class="line-modified">331 void WebGLFramebuffer::removeAttachmentFromBoundFramebuffer(GCGLenum attachment)</span>
332 {
333     ASSERT(isBound());
334     if (!object())
335         return;
336 
337     RefPtr&lt;WebGLAttachment&gt; attachmentObject = getAttachment(attachment);
338     if (attachmentObject) {
<a name="39" id="anc39"></a><span class="line-modified">339         attachmentObject-&gt;onDetached(context()-&gt;graphicsContextGL());</span>
340         m_attachments.remove(attachment);
341         drawBuffersIfNecessary(false);
<a name="40" id="anc40"></a><span class="line-added">342 #if !USE(ANGLE)</span>
343         switch (attachment) {
<a name="41" id="anc41"></a><span class="line-modified">344         case GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT:</span>
<span class="line-modified">345             attach(GraphicsContextGL::DEPTH_ATTACHMENT, GraphicsContextGL::DEPTH_ATTACHMENT);</span>
<span class="line-modified">346             attach(GraphicsContextGL::STENCIL_ATTACHMENT, GraphicsContextGL::STENCIL_ATTACHMENT);</span>
347             break;
<a name="42" id="anc42"></a><span class="line-modified">348         case GraphicsContextGL::DEPTH_ATTACHMENT:</span>
<span class="line-modified">349             attach(GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT, GraphicsContextGL::DEPTH_ATTACHMENT);</span>
350             break;
<a name="43" id="anc43"></a><span class="line-modified">351         case GraphicsContextGL::STENCIL_ATTACHMENT:</span>
<span class="line-modified">352             attach(GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT, GraphicsContextGL::STENCIL_ATTACHMENT);</span>
353             break;
354         }
<a name="44" id="anc44"></a><span class="line-added">355 #endif</span>
356     }
357 }
358 
359 void WebGLFramebuffer::removeAttachmentFromBoundFramebuffer(WebGLSharedObject* attachment)
360 {
361     ASSERT(isBound());
362     if (!object())
363         return;
364     if (!attachment)
365         return;
366 
367     bool checkMore = true;
368     do {
369         checkMore = false;
370         for (auto&amp; entry : m_attachments) {
371             RefPtr&lt;WebGLAttachment&gt; attachmentObject = entry.value.get();
372             if (attachmentObject-&gt;isSharedObject(attachment)) {
<a name="45" id="anc45"></a><span class="line-modified">373                 GCGLenum attachmentType = entry.key;</span>
<span class="line-modified">374                 attachmentObject-&gt;unattach(context()-&gt;graphicsContextGL(), attachmentType);</span>
375                 removeAttachmentFromBoundFramebuffer(attachmentType);
376                 checkMore = true;
377                 break;
378             }
379         }
380     } while (checkMore);
381 }
382 
<a name="46" id="anc46"></a><span class="line-modified">383 GCGLsizei WebGLFramebuffer::getColorBufferWidth() const</span>
384 {
385     if (!object())
386         return 0;
<a name="47" id="anc47"></a><span class="line-modified">387     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContextGL::COLOR_ATTACHMENT0);</span>
388     if (!attachment)
389         return 0;
390 
391     return attachment-&gt;getWidth();
392 }
393 
<a name="48" id="anc48"></a><span class="line-modified">394 GCGLsizei WebGLFramebuffer::getColorBufferHeight() const</span>
395 {
396     if (!object())
397         return 0;
<a name="49" id="anc49"></a><span class="line-modified">398     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContextGL::COLOR_ATTACHMENT0);</span>
399     if (!attachment)
400         return 0;
401 
402     return attachment-&gt;getHeight();
403 }
404 
<a name="50" id="anc50"></a><span class="line-modified">405 GCGLenum WebGLFramebuffer::getColorBufferFormat() const</span>
406 {
407     if (!object())
408         return 0;
<a name="51" id="anc51"></a><span class="line-modified">409     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContextGL::COLOR_ATTACHMENT0);</span>
410     if (!attachment)
411         return 0;
412     return attachment-&gt;getFormat();
413 }
414 
<a name="52" id="anc52"></a><span class="line-modified">415 GCGLenum WebGLFramebuffer::checkStatus(const char** reason) const</span>
416 {
417     unsigned int count = 0;
<a name="53" id="anc53"></a><span class="line-modified">418     GCGLsizei width = 0, height = 0;</span>
419     bool haveDepth = false;
420     bool haveStencil = false;
421     bool haveDepthStencil = false;
422     for (auto&amp; entry : m_attachments) {
423         RefPtr&lt;WebGLAttachment&gt; attachment = entry.value.get();
424         if (!isAttachmentComplete(attachment.get(), entry.key, reason))
<a name="54" id="anc54"></a><span class="line-modified">425             return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;</span>
426         if (!attachment-&gt;isValid()) {
427             *reason = &quot;attachment is not valid&quot;;
<a name="55" id="anc55"></a><span class="line-modified">428             return GraphicsContextGL::FRAMEBUFFER_UNSUPPORTED;</span>
429         }
<a name="56" id="anc56"></a><span class="line-modified">430         GCGLenum attachmentFormat = attachment-&gt;getFormat();</span>
431 
432         // Attaching an SRGB_EXT format attachment to a framebuffer is invalid.
<a name="57" id="anc57"></a><span class="line-modified">433         if (attachmentFormat == ExtensionsGL::SRGB_EXT)</span>
434             attachmentFormat = 0;
435 
436         if (!attachmentFormat) {
437             *reason = &quot;attachment is an unsupported format&quot;;
<a name="58" id="anc58"></a><span class="line-modified">438             return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;</span>
439         }
440         switch (entry.key) {
<a name="59" id="anc59"></a><span class="line-modified">441         case GraphicsContextGL::DEPTH_ATTACHMENT:</span>
442             haveDepth = true;
443             break;
<a name="60" id="anc60"></a><span class="line-modified">444         case GraphicsContextGL::STENCIL_ATTACHMENT:</span>
445             haveStencil = true;
446             break;
<a name="61" id="anc61"></a><span class="line-modified">447         case GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT:</span>
448             haveDepthStencil = true;
449             break;
450         }
451         if (!count) {
452             width = attachment-&gt;getWidth();
453             height = attachment-&gt;getHeight();
454         } else {
455             if (width != attachment-&gt;getWidth() || height != attachment-&gt;getHeight()) {
456                 *reason = &quot;attachments do not have the same dimensions&quot;;
<a name="62" id="anc62"></a><span class="line-modified">457                 return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_DIMENSIONS;</span>
458             }
459         }
460         ++count;
461     }
462     if (!count) {
463         *reason = &quot;no attachments&quot;;
<a name="63" id="anc63"></a><span class="line-modified">464         return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT;</span>
465     }
466     if (!width || !height) {
467         *reason = &quot;framebuffer has a 0 dimension&quot;;
<a name="64" id="anc64"></a><span class="line-modified">468         return GraphicsContextGL::FRAMEBUFFER_INCOMPLETE_ATTACHMENT;</span>
469     }
470     // WebGL specific: no conflicting DEPTH/STENCIL/DEPTH_STENCIL attachments.
471     if ((haveDepthStencil &amp;&amp; (haveDepth || haveStencil)) || (haveDepth &amp;&amp; haveStencil)) {
472         *reason = &quot;conflicting DEPTH/STENCIL/DEPTH_STENCIL attachments&quot;;
<a name="65" id="anc65"></a><span class="line-modified">473         return GraphicsContextGL::FRAMEBUFFER_UNSUPPORTED;</span>
474     }
<a name="66" id="anc66"></a><span class="line-modified">475     return GraphicsContextGL::FRAMEBUFFER_COMPLETE;</span>
476 }
477 
<a name="67" id="anc67"></a><span class="line-modified">478 bool WebGLFramebuffer::onAccess(GraphicsContextGLOpenGL* context3d, const char** reason)</span>
479 {
<a name="68" id="anc68"></a><span class="line-modified">480     if (checkStatus(reason) != GraphicsContextGL::FRAMEBUFFER_COMPLETE)</span>
481         return false;
482     return initializeAttachments(context3d, reason);
483 }
484 
485 bool WebGLFramebuffer::hasStencilBuffer() const
486 {
<a name="69" id="anc69"></a><span class="line-modified">487     RefPtr&lt;WebGLAttachment&gt; attachment = getAttachment(GraphicsContextGL::STENCIL_ATTACHMENT);</span>
488     if (!attachment)
<a name="70" id="anc70"></a><span class="line-modified">489         attachment = getAttachment(GraphicsContextGL::DEPTH_STENCIL_ATTACHMENT);</span>
490     return attachment &amp;&amp; attachment-&gt;isValid();
491 }
492 
<a name="71" id="anc71"></a><span class="line-modified">493 void WebGLFramebuffer::deleteObjectImpl(GraphicsContextGLOpenGL* context3d, PlatformGLObject object)</span>
494 {
495     for (auto&amp; attachment : m_attachments.values())
496         attachment-&gt;onDetached(context3d);
497 
498     context3d-&gt;deleteFramebuffer(object);
499 }
500 
<a name="72" id="anc72"></a><span class="line-modified">501 bool WebGLFramebuffer::initializeAttachments(GraphicsContextGLOpenGL* g3d, const char** reason)</span>
502 {
503     ASSERT(object());
<a name="73" id="anc73"></a><span class="line-modified">504     GCGLbitfield mask = 0;</span>
505 
506     for (auto&amp; entry : m_attachments) {
<a name="74" id="anc74"></a><span class="line-modified">507         GCGLenum attachmentType = entry.key;</span>
508         RefPtr&lt;WebGLAttachment&gt; attachment = entry.value.get();
509         if (!attachment-&gt;isInitialized())
<a name="75" id="anc75"></a><span class="line-modified">510             mask |= GraphicsContextGLOpenGL::getClearBitsByAttachmentType(attachmentType);</span>
511     }
512     if (!mask)
513         return true;
514 
515     // We only clear un-initialized renderbuffers when they are ready to be
516     // read, i.e., when the framebuffer is complete.
<a name="76" id="anc76"></a><span class="line-modified">517     if (g3d-&gt;checkFramebufferStatus(GraphicsContextGL::FRAMEBUFFER) != GraphicsContextGL::FRAMEBUFFER_COMPLETE) {</span>
518         *reason = &quot;framebuffer not complete&quot;;
519         return false;
520     }
521 
<a name="77" id="anc77"></a><span class="line-modified">522     bool initColor = mask &amp; GraphicsContextGL::COLOR_BUFFER_BIT;</span>
<span class="line-modified">523     bool initDepth = mask &amp; GraphicsContextGL::DEPTH_BUFFER_BIT;</span>
<span class="line-modified">524     bool initStencil = mask &amp; GraphicsContextGL::STENCIL_BUFFER_BIT;</span>
525 
<a name="78" id="anc78"></a><span class="line-modified">526     GCGLfloat colorClearValue[] = {0, 0, 0, 0}, depthClearValue = 0;</span>
<span class="line-modified">527     GCGLint stencilClearValue = 0;</span>
<span class="line-modified">528     GCGLboolean colorMask[] = {0, 0, 0, 0}, depthMask = 0;</span>
<span class="line-modified">529     GCGLuint stencilMask = 0xffffffff;</span>
<span class="line-modified">530     GCGLboolean isScissorEnabled = 0;</span>
<span class="line-modified">531     GCGLboolean isDitherEnabled = 0;</span>
532     if (initColor) {
<a name="79" id="anc79"></a><span class="line-modified">533         g3d-&gt;getFloatv(GraphicsContextGL::COLOR_CLEAR_VALUE, colorClearValue);</span>
<span class="line-modified">534         g3d-&gt;getBooleanv(GraphicsContextGL::COLOR_WRITEMASK, colorMask);</span>
535         g3d-&gt;clearColor(0, 0, 0, 0);
536         g3d-&gt;colorMask(true, true, true, true);
537     }
538     if (initDepth) {
<a name="80" id="anc80"></a><span class="line-modified">539         g3d-&gt;getFloatv(GraphicsContextGL::DEPTH_CLEAR_VALUE, &amp;depthClearValue);</span>
<span class="line-modified">540         g3d-&gt;getBooleanv(GraphicsContextGL::DEPTH_WRITEMASK, &amp;depthMask);</span>
541         g3d-&gt;clearDepth(1.0f);
542         g3d-&gt;depthMask(true);
543     }
544     if (initStencil) {
<a name="81" id="anc81"></a><span class="line-modified">545         g3d-&gt;getIntegerv(GraphicsContextGL::STENCIL_CLEAR_VALUE, &amp;stencilClearValue);</span>
<span class="line-modified">546         g3d-&gt;getIntegerv(GraphicsContextGL::STENCIL_WRITEMASK, reinterpret_cast&lt;GCGLint*&gt;(&amp;stencilMask));</span>
547         g3d-&gt;clearStencil(0);
548         g3d-&gt;stencilMask(0xffffffff);
549     }
<a name="82" id="anc82"></a><span class="line-modified">550     isScissorEnabled = g3d-&gt;isEnabled(GraphicsContextGL::SCISSOR_TEST);</span>
<span class="line-modified">551     g3d-&gt;disable(GraphicsContextGL::SCISSOR_TEST);</span>
<span class="line-modified">552     isDitherEnabled = g3d-&gt;isEnabled(GraphicsContextGL::DITHER);</span>
<span class="line-modified">553     g3d-&gt;disable(GraphicsContextGL::DITHER);</span>
554 
555     g3d-&gt;clear(mask);
556 
557     if (initColor) {
558         g3d-&gt;clearColor(colorClearValue[0], colorClearValue[1], colorClearValue[2], colorClearValue[3]);
559         g3d-&gt;colorMask(colorMask[0], colorMask[1], colorMask[2], colorMask[3]);
560     }
561     if (initDepth) {
562         g3d-&gt;clearDepth(depthClearValue);
563         g3d-&gt;depthMask(depthMask);
564     }
565     if (initStencil) {
566         g3d-&gt;clearStencil(stencilClearValue);
567         g3d-&gt;stencilMask(stencilMask);
568     }
569     if (isScissorEnabled)
<a name="83" id="anc83"></a><span class="line-modified">570         g3d-&gt;enable(GraphicsContextGL::SCISSOR_TEST);</span>
571     else
<a name="84" id="anc84"></a><span class="line-modified">572         g3d-&gt;disable(GraphicsContextGL::SCISSOR_TEST);</span>
573     if (isDitherEnabled)
<a name="85" id="anc85"></a><span class="line-modified">574         g3d-&gt;enable(GraphicsContextGL::DITHER);</span>
575     else
<a name="86" id="anc86"></a><span class="line-modified">576         g3d-&gt;disable(GraphicsContextGL::DITHER);</span>
577 
578     for (AttachmentMap::iterator it = m_attachments.begin(); it != m_attachments.end(); ++it) {
<a name="87" id="anc87"></a><span class="line-modified">579         GCGLenum attachmentType = it-&gt;key;</span>
580         auto attachment = it-&gt;value;
<a name="88" id="anc88"></a><span class="line-modified">581         GCGLbitfield bits = GraphicsContextGLOpenGL::getClearBitsByAttachmentType(attachmentType);</span>
582         if (bits &amp; mask)
583             attachment-&gt;setInitialized();
584     }
585     return true;
586 }
587 
588 bool WebGLFramebuffer::isBound() const
589 {
590     return (context()-&gt;m_framebufferBinding.get() == this) || (context()-&gt;m_readFramebufferBinding.get() == this);
591 }
592 
<a name="89" id="anc89"></a><span class="line-modified">593 void WebGLFramebuffer::drawBuffers(const Vector&lt;GCGLenum&gt;&amp; bufs)</span>
594 {
595     m_drawBuffers = bufs;
596     m_filteredDrawBuffers.resize(m_drawBuffers.size());
597     for (auto&amp; buffer : m_filteredDrawBuffers)
<a name="90" id="anc90"></a><span class="line-modified">598         buffer = GraphicsContextGL::NONE;</span>
599     drawBuffersIfNecessary(true);
600 }
601 
602 void WebGLFramebuffer::drawBuffersIfNecessary(bool force)
603 {
604 #if ENABLE(WEBGL2)
605     // FIXME: The logic here seems wrong. If we don&#39;t have WebGL 2 enabled at all, then
606     // we skip the m_webglDrawBuffers check. But if we do have WebGL 2 enabled, then we
607     // perform this check, for WebGL 1 contexts only.
608     if (!context()-&gt;m_webglDrawBuffers &amp;&amp; !context()-&gt;isWebGL2())
609         return;
610 #endif
611     bool reset = force;
612     // This filtering works around graphics driver bugs on Mac OS X.
613     for (size_t i = 0; i &lt; m_drawBuffers.size(); ++i) {
<a name="91" id="anc91"></a><span class="line-modified">614         if (m_drawBuffers[i] != GraphicsContextGL::NONE &amp;&amp; getAttachment(m_drawBuffers[i])) {</span>
615             if (m_filteredDrawBuffers[i] != m_drawBuffers[i]) {
616                 m_filteredDrawBuffers[i] = m_drawBuffers[i];
617                 reset = true;
618             }
619         } else {
<a name="92" id="anc92"></a><span class="line-modified">620             if (m_filteredDrawBuffers[i] != GraphicsContextGL::NONE) {</span>
<span class="line-modified">621                 m_filteredDrawBuffers[i] = GraphicsContextGL::NONE;</span>
622                 reset = true;
623             }
624         }
625     }
626     if (reset) {
<a name="93" id="anc93"></a><span class="line-modified">627         context()-&gt;graphicsContextGL()-&gt;getExtensions().drawBuffersEXT(</span>
628             m_filteredDrawBuffers.size(), m_filteredDrawBuffers.data());
629     }
630 }
631 
<a name="94" id="anc94"></a><span class="line-modified">632 GCGLenum WebGLFramebuffer::getDrawBuffer(GCGLenum drawBuffer)</span>
633 {
<a name="95" id="anc95"></a><span class="line-modified">634     int index = static_cast&lt;int&gt;(drawBuffer - ExtensionsGL::DRAW_BUFFER0_EXT);</span>
635     ASSERT(index &gt;= 0);
636     if (index &lt; static_cast&lt;int&gt;(m_drawBuffers.size()))
637         return m_drawBuffers[index];
<a name="96" id="anc96"></a><span class="line-modified">638     if (drawBuffer == ExtensionsGL::DRAW_BUFFER0_EXT)</span>
<span class="line-modified">639         return GraphicsContextGL::COLOR_ATTACHMENT0;</span>
<span class="line-modified">640     return GraphicsContextGL::NONE;</span>
641 }
642 
643 }
644 
645 #endif // ENABLE(WEBGL)
<a name="97" id="anc97"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="97" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/AxisScrollSnapOffsets.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014-2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;AxisScrollSnapOffsets.h&quot;
 28 
 29 #include &quot;ElementChildIterator.h&quot;
 30 #include &quot;HTMLCollection.h&quot;
 31 #include &quot;HTMLElement.h&quot;
 32 #include &quot;Length.h&quot;
 33 #include &quot;Logging.h&quot;
 34 #include &quot;RenderBox.h&quot;
 35 #include &quot;RenderView.h&quot;
 36 #include &quot;ScrollableArea.h&quot;
 37 #include &quot;StyleScrollSnapPoints.h&quot;
 38 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 39 
 40 #if ENABLE(CSS_SCROLL_SNAP)
 41 
 42 namespace WebCore {
 43 
 44 enum class InsetOrOutset {
 45     Inset,
 46     Outset
 47 };
 48 
 49 static LayoutRect computeScrollSnapPortOrAreaRect(const LayoutRect&amp; rect, const LengthBox&amp; insetOrOutsetBox, InsetOrOutset insetOrOutset)
 50 {
 51     LayoutBoxExtent extents(valueForLength(insetOrOutsetBox.top(), rect.height()), valueForLength(insetOrOutsetBox.right(), rect.width()), valueForLength(insetOrOutsetBox.bottom(), rect.height()), valueForLength(insetOrOutsetBox.left(), rect.width()));
 52     auto snapPortOrArea(rect);
 53     if (insetOrOutset == InsetOrOutset::Inset)
 54         snapPortOrArea.contract(extents);
 55     else
 56         snapPortOrArea.expand(extents);
 57     return snapPortOrArea;
 58 }
 59 
 60 static LayoutUnit computeScrollSnapAlignOffset(const LayoutUnit&amp; leftOrTop, const LayoutUnit&amp; widthOrHeight, ScrollSnapAxisAlignType alignment)
 61 {
 62     switch (alignment) {
 63     case ScrollSnapAxisAlignType::Start:
 64         return leftOrTop;
 65     case ScrollSnapAxisAlignType::Center:
 66         return leftOrTop + widthOrHeight / 2;
 67     case ScrollSnapAxisAlignType::End:
 68         return leftOrTop + widthOrHeight;
 69     default:
 70         ASSERT_NOT_REACHED();
 71         return 0;
 72     }
 73 }
 74 
 75 #if !LOG_DISABLED
 76 
 77 static String snapOffsetsToString(const Vector&lt;LayoutUnit&gt;&amp; snapOffsets)
 78 {
 79     StringBuilder builder;
 80     builder.appendLiteral(&quot;[ &quot;);
 81     for (auto&amp; offset : snapOffsets)
 82         builder.append(offset.toFloat(), &#39; &#39;);
 83     builder.append(&#39;]&#39;);
 84     return builder.toString();
 85 }
 86 
 87 static String snapOffsetRangesToString(const Vector&lt;ScrollOffsetRange&lt;LayoutUnit&gt;&gt;&amp; ranges)
 88 {
 89     StringBuilder builder;
 90     builder.appendLiteral(&quot;[ &quot;);
 91     for (auto&amp; range : ranges)
 92         builder.append(&#39;(&#39;, range.start.toFloat(), &quot;, &quot;, range.end.toFloat(), &quot;) &quot;);
 93     builder.append(&#39;]&#39;);
 94     return builder.toString();
 95 }
 96 
 97 static String snapPortOrAreaToString(const LayoutRect&amp; rect)
 98 {
 99     return makeString(&quot;{{&quot;, rect.x().toFloat(), &quot;, &quot;, rect.y().toFloat(), &quot;} {&quot;, rect.width().toFloat(), &quot;, &quot;, rect.height().toFloat(), &quot;}}&quot;);
100 }
101 
102 #endif
103 
104 template &lt;typename LayoutType&gt;
105 static void indicesOfNearestSnapOffsetRanges(LayoutType offset, const Vector&lt;ScrollOffsetRange&lt;LayoutType&gt;&gt;&amp; snapOffsetRanges, unsigned&amp; lowerIndex, unsigned&amp; upperIndex)
106 {
107     if (snapOffsetRanges.isEmpty()) {
108         lowerIndex = invalidSnapOffsetIndex;
109         upperIndex = invalidSnapOffsetIndex;
110         return;
111     }
112 
113     int lowerIndexAsInt = -1;
114     int upperIndexAsInt = snapOffsetRanges.size();
115     do {
116         int middleIndex = (lowerIndexAsInt + upperIndexAsInt) / 2;
117         auto&amp; range = snapOffsetRanges[middleIndex];
118         if (range.start &lt; offset &amp;&amp; offset &lt; range.end) {
119             lowerIndexAsInt = middleIndex;
120             upperIndexAsInt = middleIndex;
121             break;
122         }
123 
124         if (offset &gt; range.end)
125             lowerIndexAsInt = middleIndex;
126         else
127             upperIndexAsInt = middleIndex;
128     } while (lowerIndexAsInt &lt; upperIndexAsInt - 1);
129 
130     if (offset &lt;= snapOffsetRanges.first().start)
131         lowerIndex = invalidSnapOffsetIndex;
132     else
133         lowerIndex = lowerIndexAsInt;
134 
135     if (offset &gt;= snapOffsetRanges.last().end)
136         upperIndex = invalidSnapOffsetIndex;
137     else
138         upperIndex = upperIndexAsInt;
139 }
140 
141 template &lt;typename LayoutType&gt;
142 static void indicesOfNearestSnapOffsets(LayoutType offset, const Vector&lt;LayoutType&gt;&amp; snapOffsets, unsigned&amp; lowerIndex, unsigned&amp; upperIndex)
143 {
144     lowerIndex = 0;
145     upperIndex = snapOffsets.size() - 1;
146     while (lowerIndex &lt; upperIndex - 1) {
147         int middleIndex = (lowerIndex + upperIndex) / 2;
148         auto middleOffset = snapOffsets[middleIndex];
149         if (offset == middleOffset) {
150             upperIndex = middleIndex;
151             lowerIndex = middleIndex;
152             break;
153         }
154 
155         if (offset &gt; middleOffset)
156             lowerIndex = middleIndex;
157         else
158             upperIndex = middleIndex;
159     }
160 }
161 
162 static void adjustAxisSnapOffsetsForScrollExtent(Vector&lt;LayoutUnit&gt;&amp; snapOffsets, float maxScrollExtent)
163 {
164     if (snapOffsets.isEmpty())
165         return;
166 
167     std::sort(snapOffsets.begin(), snapOffsets.end());
168     if (snapOffsets.last() != maxScrollExtent)
169         snapOffsets.append(maxScrollExtent);
170     if (snapOffsets.first())
171         snapOffsets.insert(0, 0);
172 }
173 
174 static void computeAxisProximitySnapOffsetRanges(const Vector&lt;LayoutUnit&gt;&amp; snapOffsets, Vector&lt;ScrollOffsetRange&lt;LayoutUnit&gt;&gt;&amp; offsetRanges, LayoutUnit scrollPortAxisLength)
175 {
176     // This is an arbitrary choice for what it means to be &quot;in proximity&quot; of a snap offset. We should play around with
177     // this and see what feels best.
178     static const float ratioOfScrollPortAxisLengthToBeConsideredForProximity = 0.3;
179     if (snapOffsets.size() &lt; 2)
180         return;
181 
182     // The extra rule accounting for scroll offset ranges in between the scroll destination and a potential snap offset
183     // handles the corner case where the user scrolls with momentum very lightly away from a snap offset, such that the
184     // predicted scroll destination is still within proximity of the snap offset. In this case, the regular (mandatory
185     // scroll snapping) behavior would be to snap to the next offset in the direction of momentum scrolling, but
186     // instead, it is more intuitive to either return to the original snap position (which we arbitrarily choose here)
187     // or scroll just outside of the snap offset range. This is another minor behavior tweak that we should play around
188     // with to see what feels best.
189     LayoutUnit proximityDistance { ratioOfScrollPortAxisLengthToBeConsideredForProximity * scrollPortAxisLength };
190     for (size_t index = 1; index &lt; snapOffsets.size(); ++index) {
191         auto startOffset = snapOffsets[index - 1] + proximityDistance;
192         auto endOffset = snapOffsets[index] - proximityDistance;
193         if (startOffset &lt; endOffset)
194             offsetRanges.append({ startOffset, endOffset });
195     }
196 }
197 
198 void updateSnapOffsetsForScrollableArea(ScrollableArea&amp; scrollableArea, HTMLElement&amp; scrollingElement, const RenderBox&amp; scrollingElementBox, const RenderStyle&amp; scrollingElementStyle)
199 {
200     auto* scrollContainer = scrollingElement.renderer();
201     auto scrollSnapType = scrollingElementStyle.scrollSnapType();
202     if (!scrollContainer || scrollSnapType.strictness == ScrollSnapStrictness::None || scrollContainer-&gt;view().boxesWithScrollSnapPositions().isEmpty()) {
203         scrollableArea.clearHorizontalSnapOffsets();
204         scrollableArea.clearVerticalSnapOffsets();
205         return;
206     }
207 
208     Vector&lt;LayoutUnit&gt; verticalSnapOffsets;
209     Vector&lt;LayoutUnit&gt; horizontalSnapOffsets;
210     Vector&lt;ScrollOffsetRange&lt;LayoutUnit&gt;&gt; verticalSnapOffsetRanges;
211     Vector&lt;ScrollOffsetRange&lt;LayoutUnit&gt;&gt; horizontalSnapOffsetRanges;
212     HashSet&lt;float&gt; seenVerticalSnapOffsets;
213     HashSet&lt;float&gt; seenHorizontalSnapOffsets;
214     bool hasHorizontalSnapOffsets = scrollSnapType.axis == ScrollSnapAxis::Both || scrollSnapType.axis == ScrollSnapAxis::XAxis || scrollSnapType.axis == ScrollSnapAxis::Inline;
215     bool hasVerticalSnapOffsets = scrollSnapType.axis == ScrollSnapAxis::Both || scrollSnapType.axis == ScrollSnapAxis::YAxis || scrollSnapType.axis == ScrollSnapAxis::Block;
216     auto maxScrollLeft = scrollingElementBox.scrollWidth() - scrollingElementBox.contentWidth();
217     auto maxScrollTop = scrollingElementBox.scrollHeight() - scrollingElementBox.contentHeight();
218     LayoutPoint containerScrollOffset(scrollingElementBox.scrollLeft(), scrollingElementBox.scrollTop());
219 
220     // The bounds of the scrolling container&#39;s snap port, where the top left of the scrolling container&#39;s border box is the origin.
221     auto scrollSnapPort = computeScrollSnapPortOrAreaRect(scrollingElementBox.paddingBoxRect(), scrollingElementStyle.scrollPadding(), InsetOrOutset::Inset);
222 #if !LOG_DISABLED
223     LOG(Scrolling, &quot;Computing scroll snap offsets in snap port: %s&quot;, snapPortOrAreaToString(scrollSnapPort).utf8().data());
224 #endif
225     for (auto* child : scrollContainer-&gt;view().boxesWithScrollSnapPositions()) {
226         if (child-&gt;enclosingScrollableContainerForSnapping() != scrollContainer)
227             continue;
228 
229         // The bounds of the child element&#39;s snap area, where the top left of the scrolling container&#39;s border box is the origin.
230         // The snap area is the bounding box of the child element&#39;s border box, after applying transformations.
231         auto scrollSnapArea = LayoutRect(child-&gt;localToContainerQuad(FloatQuad(child-&gt;borderBoundingBox()), scrollingElement.renderBox()).boundingBox());
232         scrollSnapArea.moveBy(containerScrollOffset);
233         scrollSnapArea = computeScrollSnapPortOrAreaRect(scrollSnapArea, child-&gt;style().scrollSnapMargin(), InsetOrOutset::Outset);
234 #if !LOG_DISABLED
235         LOG(Scrolling, &quot;    Considering scroll snap area: %s&quot;, snapPortOrAreaToString(scrollSnapArea).utf8().data());
236 #endif
237         auto alignment = child-&gt;style().scrollSnapAlign();
238         if (hasHorizontalSnapOffsets &amp;&amp; alignment.x != ScrollSnapAxisAlignType::None) {
239             auto absoluteScrollOffset = clampTo&lt;LayoutUnit&gt;(computeScrollSnapAlignOffset(scrollSnapArea.x(), scrollSnapArea.width(), alignment.x) - computeScrollSnapAlignOffset(scrollSnapPort.x(), scrollSnapPort.width(), alignment.x), 0, maxScrollLeft);
240             if (!seenHorizontalSnapOffsets.contains(absoluteScrollOffset)) {
241                 seenHorizontalSnapOffsets.add(absoluteScrollOffset);
242                 horizontalSnapOffsets.append(absoluteScrollOffset);
243             }
244         }
245         if (hasVerticalSnapOffsets &amp;&amp; alignment.y != ScrollSnapAxisAlignType::None) {
246             auto absoluteScrollOffset = clampTo&lt;LayoutUnit&gt;(computeScrollSnapAlignOffset(scrollSnapArea.y(), scrollSnapArea.height(), alignment.y) - computeScrollSnapAlignOffset(scrollSnapPort.y(), scrollSnapPort.height(), alignment.y), 0, maxScrollTop);
247             if (!seenVerticalSnapOffsets.contains(absoluteScrollOffset)) {
248                 seenVerticalSnapOffsets.add(absoluteScrollOffset);
249                 verticalSnapOffsets.append(absoluteScrollOffset);
250             }
251         }
252     }
253 
254     if (!horizontalSnapOffsets.isEmpty()) {
255         adjustAxisSnapOffsetsForScrollExtent(horizontalSnapOffsets, maxScrollLeft);
256 #if !LOG_DISABLED
257         LOG(Scrolling, &quot; =&gt; Computed horizontal scroll snap offsets: %s&quot;, snapOffsetsToString(horizontalSnapOffsets).utf8().data());
258         LOG(Scrolling, &quot; =&gt; Computed horizontal scroll snap offset ranges: %s&quot;, snapOffsetRangesToString(horizontalSnapOffsetRanges).utf8().data());
259 #endif
260         if (scrollSnapType.strictness == ScrollSnapStrictness::Proximity)
261             computeAxisProximitySnapOffsetRanges(horizontalSnapOffsets, horizontalSnapOffsetRanges, scrollSnapPort.width());
262 
263         scrollableArea.setHorizontalSnapOffsets(horizontalSnapOffsets);
264         scrollableArea.setHorizontalSnapOffsetRanges(horizontalSnapOffsetRanges);
265     } else
266         scrollableArea.clearHorizontalSnapOffsets();
267 
268     if (!verticalSnapOffsets.isEmpty()) {
269         adjustAxisSnapOffsetsForScrollExtent(verticalSnapOffsets, maxScrollTop);
270 #if !LOG_DISABLED
271         LOG(Scrolling, &quot; =&gt; Computed vertical scroll snap offsets: %s&quot;, snapOffsetsToString(verticalSnapOffsets).utf8().data());
272         LOG(Scrolling, &quot; =&gt; Computed vertical scroll snap offset ranges: %s&quot;, snapOffsetRangesToString(verticalSnapOffsetRanges).utf8().data());
273 #endif
274         if (scrollSnapType.strictness == ScrollSnapStrictness::Proximity)
275             computeAxisProximitySnapOffsetRanges(verticalSnapOffsets, verticalSnapOffsetRanges, scrollSnapPort.height());
276 
277         scrollableArea.setVerticalSnapOffsets(verticalSnapOffsets);
278         scrollableArea.setVerticalSnapOffsetRanges(verticalSnapOffsetRanges);
279     } else
280         scrollableArea.clearVerticalSnapOffsets();
281 }
282 
283 template &lt;typename LayoutType&gt;
284 LayoutType closestSnapOffset(const Vector&lt;LayoutType&gt;&amp; snapOffsets, const Vector&lt;ScrollOffsetRange&lt;LayoutType&gt;&gt;&amp; snapOffsetRanges, LayoutType scrollDestination, float velocity, unsigned&amp; activeSnapIndex)
285 {
286     ASSERT(snapOffsets.size());
287     activeSnapIndex = 0;
288 
289     unsigned lowerSnapOffsetRangeIndex;
290     unsigned upperSnapOffsetRangeIndex;
291     indicesOfNearestSnapOffsetRanges&lt;LayoutType&gt;(scrollDestination, snapOffsetRanges, lowerSnapOffsetRangeIndex, upperSnapOffsetRangeIndex);
292     if (lowerSnapOffsetRangeIndex == upperSnapOffsetRangeIndex &amp;&amp; upperSnapOffsetRangeIndex != invalidSnapOffsetIndex) {
293         activeSnapIndex = invalidSnapOffsetIndex;
294         return scrollDestination;
295     }
296 
297     if (scrollDestination &lt;= snapOffsets.first())
298         return snapOffsets.first();
299 
300     activeSnapIndex = snapOffsets.size() - 1;
301     if (scrollDestination &gt;= snapOffsets.last())
302         return snapOffsets.last();
303 
304     unsigned lowerIndex;
305     unsigned upperIndex;
306     indicesOfNearestSnapOffsets&lt;LayoutType&gt;(scrollDestination, snapOffsets, lowerIndex, upperIndex);
307     LayoutType lowerSnapPosition = snapOffsets[lowerIndex];
308     LayoutType upperSnapPosition = snapOffsets[upperIndex];
309     if (!std::abs(velocity)) {
310         bool isCloserToLowerSnapPosition = scrollDestination - lowerSnapPosition &lt;= upperSnapPosition - scrollDestination;
311         activeSnapIndex = isCloserToLowerSnapPosition ? lowerIndex : upperIndex;
312         return isCloserToLowerSnapPosition ? lowerSnapPosition : upperSnapPosition;
313     }
314 
315     // Non-zero velocity indicates a flick gesture. Even if another snap point is closer, we should choose the one in the direction of the flick gesture
316     // as long as a scroll snap offset range does not lie between the scroll destination and the targeted snap offset.
317     if (velocity &lt; 0) {
318         if (lowerSnapOffsetRangeIndex != invalidSnapOffsetIndex &amp;&amp; lowerSnapPosition &lt; snapOffsetRanges[lowerSnapOffsetRangeIndex].end) {
319             activeSnapIndex = upperIndex;
320             return upperSnapPosition;
321         }
322         activeSnapIndex = lowerIndex;
323         return lowerSnapPosition;
324     }
325 
326     if (upperSnapOffsetRangeIndex != invalidSnapOffsetIndex &amp;&amp; snapOffsetRanges[upperSnapOffsetRangeIndex].start &lt; upperSnapPosition) {
327         activeSnapIndex = lowerIndex;
328         return lowerSnapPosition;
329     }
330     activeSnapIndex = upperIndex;
331     return upperSnapPosition;
332 }
333 
334 LayoutUnit closestSnapOffset(const Vector&lt;LayoutUnit&gt;&amp; snapOffsets, const Vector&lt;ScrollOffsetRange&lt;LayoutUnit&gt;&gt;&amp; snapOffsetRanges, LayoutUnit scrollDestination, float velocity, unsigned&amp; activeSnapIndex)
335 {
336     return closestSnapOffset&lt;LayoutUnit&gt;(snapOffsets, snapOffsetRanges, scrollDestination, velocity, activeSnapIndex);
337 }
338 
339 float closestSnapOffset(const Vector&lt;float&gt;&amp; snapOffsets, const Vector&lt;ScrollOffsetRange&lt;float&gt;&gt;&amp; snapOffsetRanges, float scrollDestination, float velocity, unsigned&amp; activeSnapIndex)
340 {
341     return closestSnapOffset&lt;float&gt;(snapOffsets, snapOffsetRanges, scrollDestination, velocity, activeSnapIndex);
342 }
343 
344 } // namespace WebCore
345 
346 #endif // CSS_SCROLL_SNAP
    </pre>
  </body>
</html>
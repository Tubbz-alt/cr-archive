<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertBufferSource.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;BufferSource.h&quot;
 29 #include &quot;IDLTypes.h&quot;
 30 #include &quot;JSDOMConvertBase.h&quot;
 31 #include &quot;JSDOMWrapperCache.h&quot;
 32 #include &lt;JavaScriptCore/JSTypedArrays.h&gt;
 33 
 34 namespace WebCore {
 35 
 36 struct IDLInt8Array : IDLTypedArray&lt;JSC::Int8Array&gt; { };
 37 struct IDLInt16Array : IDLTypedArray&lt;JSC::Int16Array&gt; { };
 38 struct IDLInt32Array : IDLTypedArray&lt;JSC::Int32Array&gt; { };
 39 struct IDLUint8Array : IDLTypedArray&lt;JSC::Uint8Array&gt; { };
 40 struct IDLUint16Array : IDLTypedArray&lt;JSC::Uint16Array&gt; { };
 41 struct IDLUint32Array : IDLTypedArray&lt;JSC::Uint32Array&gt; { };
 42 struct IDLUint8ClampedArray : IDLTypedArray&lt;JSC::Uint8ClampedArray&gt; { };
 43 struct IDLFloat32Array : IDLTypedArray&lt;JSC::Float32Array&gt; { };
 44 struct IDLFloat64Array : IDLTypedArray&lt;JSC::Float64Array&gt; { };
 45 
 46 inline RefPtr&lt;JSC::Int8Array&gt; toPossiblySharedInt8Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Int8Adaptor&gt;(vm, value); }
 47 inline RefPtr&lt;JSC::Int16Array&gt; toPossiblySharedInt16Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Int16Adaptor&gt;(vm, value); }
 48 inline RefPtr&lt;JSC::Int32Array&gt; toPossiblySharedInt32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Int32Adaptor&gt;(vm, value); }
 49 inline RefPtr&lt;JSC::Uint8Array&gt; toPossiblySharedUint8Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Uint8Adaptor&gt;(vm, value); }
 50 inline RefPtr&lt;JSC::Uint8ClampedArray&gt; toPossiblySharedUint8ClampedArray(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Uint8ClampedAdaptor&gt;(vm, value); }
 51 inline RefPtr&lt;JSC::Uint16Array&gt; toPossiblySharedUint16Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Uint16Adaptor&gt;(vm, value); }
 52 inline RefPtr&lt;JSC::Uint32Array&gt; toPossiblySharedUint32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Uint32Adaptor&gt;(vm, value); }
 53 inline RefPtr&lt;JSC::Float32Array&gt; toPossiblySharedFloat32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Float32Adaptor&gt;(vm, value); }
 54 inline RefPtr&lt;JSC::Float64Array&gt; toPossiblySharedFloat64Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toPossiblySharedNativeTypedView&lt;JSC::Float64Adaptor&gt;(vm, value); }
 55 
 56 inline RefPtr&lt;JSC::Int8Array&gt; toUnsharedInt8Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Int8Adaptor&gt;(vm, value); }
 57 inline RefPtr&lt;JSC::Int16Array&gt; toUnsharedInt16Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Int16Adaptor&gt;(vm, value); }
 58 inline RefPtr&lt;JSC::Int32Array&gt; toUnsharedInt32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Int32Adaptor&gt;(vm, value); }
 59 inline RefPtr&lt;JSC::Uint8Array&gt; toUnsharedUint8Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Uint8Adaptor&gt;(vm, value); }
 60 inline RefPtr&lt;JSC::Uint8ClampedArray&gt; toUnsharedUint8ClampedArray(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Uint8ClampedAdaptor&gt;(vm, value); }
 61 inline RefPtr&lt;JSC::Uint16Array&gt; toUnsharedUint16Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Uint16Adaptor&gt;(vm, value); }
 62 inline RefPtr&lt;JSC::Uint32Array&gt; toUnsharedUint32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Uint32Adaptor&gt;(vm, value); }
 63 inline RefPtr&lt;JSC::Float32Array&gt; toUnsharedFloat32Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Float32Adaptor&gt;(vm, value); }
 64 inline RefPtr&lt;JSC::Float64Array&gt; toUnsharedFloat64Array(JSC::VM&amp; vm, JSC::JSValue value) { return JSC::toUnsharedNativeTypedView&lt;JSC::Float64Adaptor&gt;(vm, value); }
 65 
<a name="1" id="anc1"></a><span class="line-modified"> 66 inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, JSC::ArrayBuffer&amp; buffer)</span>
 67 {
 68     if (auto result = getCachedWrapper(globalObject-&gt;world(), buffer))
 69         return result;
 70 
 71     // The JSArrayBuffer::create function will register the wrapper in finishCreation.
<a name="2" id="anc2"></a><span class="line-modified"> 72     return JSC::JSArrayBuffer::create(JSC::getVM(lexicalGlobalObject), globalObject-&gt;arrayBufferStructure(buffer.sharingMode()), &amp;buffer);</span>
 73 }
 74 
<a name="3" id="anc3"></a><span class="line-modified"> 75 inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSC::JSGlobalObject* globalObject, JSC::ArrayBufferView&amp; view)</span>
 76 {
<a name="4" id="anc4"></a><span class="line-modified"> 77     return view.wrap(lexicalGlobalObject, globalObject);</span>
 78 }
 79 
<a name="5" id="anc5"></a><span class="line-modified"> 80 inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, JSC::ArrayBuffer* buffer)</span>
 81 {
 82     if (!buffer)
 83         return JSC::jsNull();
<a name="6" id="anc6"></a><span class="line-modified"> 84     return toJS(lexicalGlobalObject, globalObject, *buffer);</span>
 85 }
 86 
<a name="7" id="anc7"></a><span class="line-modified"> 87 inline JSC::JSValue toJS(JSC::JSGlobalObject* lexicalGlobalObject, JSC::JSGlobalObject* globalObject, JSC::ArrayBufferView* view)</span>
 88 {
 89     if (!view)
 90         return JSC::jsNull();
<a name="8" id="anc8"></a><span class="line-modified"> 91     return toJS(lexicalGlobalObject, globalObject, *view);</span>
 92 }
 93 
 94 inline RefPtr&lt;JSC::ArrayBufferView&gt; toPossiblySharedArrayBufferView(JSC::VM&amp; vm, JSC::JSValue value)
 95 {
 96     auto* wrapper = JSC::jsDynamicCast&lt;JSC::JSArrayBufferView*&gt;(vm, value);
 97     if (!wrapper)
 98         return nullptr;
 99     return wrapper-&gt;possiblySharedImpl();
100 }
101 
102 inline RefPtr&lt;JSC::ArrayBufferView&gt; toUnsharedArrayBufferView(JSC::VM&amp; vm, JSC::JSValue value)
103 {
104     auto result = toPossiblySharedArrayBufferView(vm, value);
105     if (!result || result-&gt;isShared())
106         return nullptr;
107     return result;
108 }
109 
110 namespace Detail {
111 
112 template&lt;typename BufferSourceType&gt;
113 struct BufferSourceConverter {
114     using WrapperType = typename Converter&lt;BufferSourceType&gt;::WrapperType;
115     using ReturnType = typename Converter&lt;BufferSourceType&gt;::ReturnType;
116 
117     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<a name="9" id="anc9"></a><span class="line-modified">118     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
119     {
<a name="10" id="anc10"></a><span class="line-modified">120         auto&amp; vm = JSC::getVM(&amp;lexicalGlobalObject);</span>
121         auto scope = DECLARE_THROW_SCOPE(vm);
122         ReturnType object = WrapperType::toWrapped(vm, value);
123         if (UNLIKELY(!object))
<a name="11" id="anc11"></a><span class="line-modified">124             exceptionThrower(lexicalGlobalObject, scope);</span>
125         return object;
126     }
127 };
128 
129 }
130 
131 template&lt;&gt; struct Converter&lt;IDLArrayBuffer&gt; : DefaultConverter&lt;IDLArrayBuffer&gt; {
132     using WrapperType = JSC::JSArrayBuffer;
133     using ReturnType = JSC::ArrayBuffer*;
134 
135     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<a name="12" id="anc12"></a><span class="line-modified">136     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
137     {
<a name="13" id="anc13"></a><span class="line-modified">138         return Detail::BufferSourceConverter&lt;IDLArrayBuffer&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
139     }
140 };
141 
142 template&lt;&gt; struct JSConverter&lt;IDLArrayBuffer&gt; {
143     static constexpr bool needsState = true;
144     static constexpr bool needsGlobalObject = true;
145 
146     template &lt;typename U&gt;
<a name="14" id="anc14"></a><span class="line-modified">147     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
148     {
<a name="15" id="anc15"></a><span class="line-modified">149         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
150     }
151 };
152 
153 template&lt;&gt; struct Converter&lt;IDLDataView&gt; : DefaultConverter&lt;IDLDataView&gt; {
154     using WrapperType = JSC::JSDataView;
155     using ReturnType = RefPtr&lt;JSC::DataView&gt;;
156 
157     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<a name="16" id="anc16"></a><span class="line-modified">158     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
159     {
<a name="17" id="anc17"></a><span class="line-modified">160         return Detail::BufferSourceConverter&lt;IDLDataView&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
161     }
162 };
163 
164 template&lt;&gt; struct JSConverter&lt;IDLDataView&gt; {
165     static constexpr bool needsState = true;
166     static constexpr bool needsGlobalObject = true;
167 
168     template &lt;typename U&gt;
<a name="18" id="anc18"></a><span class="line-modified">169     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
170     {
<a name="19" id="anc19"></a><span class="line-modified">171         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
172     }
173 };
174 
175 template&lt;&gt; struct Converter&lt;IDLInt8Array&gt; : DefaultConverter&lt;IDLInt8Array&gt; {
176     using WrapperType = JSC::JSInt8Array;
177     using ReturnType = RefPtr&lt;JSC::Int8Array&gt;;
178 
179     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<a name="20" id="anc20"></a><span class="line-modified">180     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
181     {
<a name="21" id="anc21"></a><span class="line-modified">182         return Detail::BufferSourceConverter&lt;IDLInt8Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
183     }
184 };
185 
186 template&lt;&gt; struct JSConverter&lt;IDLInt8Array&gt; {
187     static constexpr bool needsState = true;
188     static constexpr bool needsGlobalObject = true;
189 
190     template &lt;typename U&gt;
<a name="22" id="anc22"></a><span class="line-modified">191     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
192     {
<a name="23" id="anc23"></a><span class="line-modified">193         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
194     }
195 };
196 
197 template&lt;&gt; struct Converter&lt;IDLInt16Array&gt; : DefaultConverter&lt;IDLInt16Array&gt; {
198     using WrapperType = JSC::JSInt16Array;
199     using ReturnType = RefPtr&lt;JSC::Int16Array&gt;;
200 
201     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<a name="24" id="anc24"></a><span class="line-modified">202     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
203     {
<a name="25" id="anc25"></a><span class="line-modified">204         return Detail::BufferSourceConverter&lt;IDLInt16Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
205     }
206 };
207 
208 template&lt;&gt; struct JSConverter&lt;IDLInt16Array&gt; {
209     static constexpr bool needsState = true;
210     static constexpr bool needsGlobalObject = true;
211 
212     template &lt;typename U&gt;
<a name="26" id="anc26"></a><span class="line-modified">213     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
214     {
<a name="27" id="anc27"></a><span class="line-modified">215         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
216     }
217 };
218 
219 template&lt;&gt; struct Converter&lt;IDLInt32Array&gt; : DefaultConverter&lt;IDLInt32Array&gt; {
220     using WrapperType = JSC::JSInt32Array;
221     using ReturnType = RefPtr&lt;JSC::Int32Array&gt;;
222 
223     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<a name="28" id="anc28"></a><span class="line-modified">224     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
225     {
<a name="29" id="anc29"></a><span class="line-modified">226         return Detail::BufferSourceConverter&lt;IDLInt32Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
227     }
228 };
229 
230 template&lt;&gt; struct JSConverter&lt;IDLInt32Array&gt; {
231     static constexpr bool needsState = true;
232     static constexpr bool needsGlobalObject = true;
233 
234     template &lt;typename U&gt;
<a name="30" id="anc30"></a><span class="line-modified">235     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
236     {
<a name="31" id="anc31"></a><span class="line-modified">237         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
238     }
239 };
240 
241 template&lt;&gt; struct Converter&lt;IDLUint8Array&gt; : DefaultConverter&lt;IDLUint8Array&gt; {
242     using WrapperType = JSC::JSUint8Array;
243     using ReturnType = RefPtr&lt;JSC::Uint8Array&gt;;
244 
245     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<a name="32" id="anc32"></a><span class="line-modified">246     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
247     {
<a name="33" id="anc33"></a><span class="line-modified">248         return Detail::BufferSourceConverter&lt;IDLUint8Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
249     }
250 };
251 
252 template&lt;&gt; struct JSConverter&lt;IDLUint8Array&gt; {
253     static constexpr bool needsState = true;
254     static constexpr bool needsGlobalObject = true;
255 
256     template &lt;typename U&gt;
<a name="34" id="anc34"></a><span class="line-modified">257     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
258     {
<a name="35" id="anc35"></a><span class="line-modified">259         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
260     }
261 };
262 
263 template&lt;&gt; struct Converter&lt;IDLUint16Array&gt; : DefaultConverter&lt;IDLUint16Array&gt; {
264     using WrapperType = JSC::JSUint16Array;
265     using ReturnType = RefPtr&lt;JSC::Uint16Array&gt;;
266 
267     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<a name="36" id="anc36"></a><span class="line-modified">268     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
269     {
<a name="37" id="anc37"></a><span class="line-modified">270         return Detail::BufferSourceConverter&lt;IDLUint16Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
271     }
272 };
273 
274 template&lt;&gt; struct JSConverter&lt;IDLUint16Array&gt; {
275     static constexpr bool needsState = true;
276     static constexpr bool needsGlobalObject = true;
277 
278     template &lt;typename U&gt;
<a name="38" id="anc38"></a><span class="line-modified">279     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
280     {
<a name="39" id="anc39"></a><span class="line-modified">281         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
282     }
283 };
284 
285 template&lt;&gt; struct Converter&lt;IDLUint32Array&gt; : DefaultConverter&lt;IDLUint32Array&gt; {
286     using WrapperType = JSC::JSUint32Array;
287     using ReturnType = RefPtr&lt;JSC::Uint32Array&gt;;
288 
289     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<a name="40" id="anc40"></a><span class="line-modified">290     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
291     {
<a name="41" id="anc41"></a><span class="line-modified">292         return Detail::BufferSourceConverter&lt;IDLUint32Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
293     }
294 };
295 
296 template&lt;&gt; struct JSConverter&lt;IDLUint32Array&gt; {
297     static constexpr bool needsState = true;
298     static constexpr bool needsGlobalObject = true;
299 
300     template &lt;typename U&gt;
<a name="42" id="anc42"></a><span class="line-modified">301     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
302     {
<a name="43" id="anc43"></a><span class="line-modified">303         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
304     }
305 };
306 
307 template&lt;&gt; struct Converter&lt;IDLUint8ClampedArray&gt; : DefaultConverter&lt;IDLUint8ClampedArray&gt; {
308     using WrapperType = JSC::JSUint8ClampedArray;
309     using ReturnType = RefPtr&lt;JSC::Uint8ClampedArray&gt;;
310 
311     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<a name="44" id="anc44"></a><span class="line-modified">312     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
313     {
<a name="45" id="anc45"></a><span class="line-modified">314         return Detail::BufferSourceConverter&lt;IDLUint8ClampedArray&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
315     }
316 };
317 
318 template&lt;&gt; struct JSConverter&lt;IDLUint8ClampedArray&gt; {
319     static constexpr bool needsState = true;
320     static constexpr bool needsGlobalObject = true;
321 
322     template &lt;typename U&gt;
<a name="46" id="anc46"></a><span class="line-modified">323     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
324     {
<a name="47" id="anc47"></a><span class="line-modified">325         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
326     }
327 };
328 
329 template&lt;&gt; struct Converter&lt;IDLFloat32Array&gt; : DefaultConverter&lt;IDLFloat32Array&gt; {
330     using WrapperType = JSC::JSFloat32Array;
331     using ReturnType = RefPtr&lt;JSC::Float32Array&gt;;
332 
333     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<a name="48" id="anc48"></a><span class="line-modified">334     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
335     {
<a name="49" id="anc49"></a><span class="line-modified">336         return Detail::BufferSourceConverter&lt;IDLFloat32Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
337     }
338 };
339 
340 template&lt;&gt; struct JSConverter&lt;IDLFloat32Array&gt; {
341     static constexpr bool needsState = true;
342     static constexpr bool needsGlobalObject = true;
343 
344     template &lt;typename U&gt;
<a name="50" id="anc50"></a><span class="line-modified">345     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
346     {
<a name="51" id="anc51"></a><span class="line-modified">347         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
348     }
349 };
350 
351 template&lt;&gt; struct Converter&lt;IDLFloat64Array&gt; : DefaultConverter&lt;IDLFloat64Array&gt; {
352     using WrapperType = JSC::JSFloat64Array;
353     using ReturnType = RefPtr&lt;JSC::Float64Array&gt;;
354 
355     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<a name="52" id="anc52"></a><span class="line-modified">356     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
357     {
<a name="53" id="anc53"></a><span class="line-modified">358         return Detail::BufferSourceConverter&lt;IDLFloat64Array&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
359     }
360 };
361 
362 template&lt;&gt; struct JSConverter&lt;IDLFloat64Array&gt; {
363     static constexpr bool needsState = true;
364     static constexpr bool needsGlobalObject = true;
365 
366     template &lt;typename U&gt;
<a name="54" id="anc54"></a><span class="line-modified">367     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
368     {
<a name="55" id="anc55"></a><span class="line-modified">369         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
370     }
371 };
372 
373 template&lt;&gt; struct Converter&lt;IDLArrayBufferView&gt; : DefaultConverter&lt;IDLArrayBufferView&gt; {
374     using WrapperType = JSC::JSArrayBufferView;
375     using ReturnType = RefPtr&lt;JSC::ArrayBufferView&gt;;
376 
377     template&lt;typename ExceptionThrower = DefaultExceptionThrower&gt;
<a name="56" id="anc56"></a><span class="line-modified">378     static ReturnType convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue value, ExceptionThrower&amp;&amp; exceptionThrower = ExceptionThrower())</span>
379     {
<a name="57" id="anc57"></a><span class="line-modified">380         return Detail::BufferSourceConverter&lt;IDLArrayBufferView&gt;::convert(lexicalGlobalObject, value, std::forward&lt;ExceptionThrower&gt;(exceptionThrower));</span>
381     }
382 };
383 
384 template&lt;&gt; struct JSConverter&lt;IDLArrayBufferView&gt; {
385     static constexpr bool needsState = true;
386     static constexpr bool needsGlobalObject = true;
387 
388     template &lt;typename U&gt;
<a name="58" id="anc58"></a><span class="line-modified">389     static JSC::JSValue convert(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const U&amp; value)</span>
390     {
<a name="59" id="anc59"></a><span class="line-modified">391         return toJS(&amp;lexicalGlobalObject, &amp;globalObject, Detail::getPtrOrRef(value));</span>
392     }
393 };
394 
395 } // namespace WebCore
<a name="60" id="anc60"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="60" type="hidden" />
</body>
</html>
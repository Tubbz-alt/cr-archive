<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/StyleRule.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * (C) 1999-2003 Lars Knoll (knoll@kde.org)
  3  * (C) 2002-2003 Dirk Mueller (mueller@kde.org)
  4  * Copyright (C) 2002, 2005, 2006, 2008, 2012 Apple Inc. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;StyleRule.h&quot;
 24 
 25 #include &quot;CSSDeferredParser.h&quot;
 26 #include &quot;CSSFontFaceRule.h&quot;
 27 #include &quot;CSSImportRule.h&quot;
 28 #include &quot;CSSKeyframeRule.h&quot;
 29 #include &quot;CSSKeyframesRule.h&quot;
 30 #include &quot;CSSMediaRule.h&quot;
 31 #include &quot;CSSNamespaceRule.h&quot;
 32 #include &quot;CSSPageRule.h&quot;
 33 #include &quot;CSSStyleRule.h&quot;
 34 #include &quot;CSSSupportsRule.h&quot;
 35 #include &quot;MediaList.h&quot;
 36 #include &quot;StyleProperties.h&quot;
 37 #include &quot;StyleRuleImport.h&quot;
 38 #include &quot;WebKitCSSViewportRule.h&quot;
 39 
 40 namespace WebCore {
 41 
 42 struct SameSizeAsStyleRuleBase : public WTF::RefCountedBase {
 43     unsigned bitfields : 5;
 44 };
 45 
 46 COMPILE_ASSERT(sizeof(StyleRuleBase) == sizeof(SameSizeAsStyleRuleBase), StyleRuleBase_should_stay_small);
 47 
 48 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StyleRuleBase);
 49 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(StyleRule);
 50 
 51 Ref&lt;CSSRule&gt; StyleRuleBase::createCSSOMWrapper(CSSStyleSheet* parentSheet) const
 52 {
 53     return createCSSOMWrapper(parentSheet, nullptr);
 54 }
 55 
 56 Ref&lt;CSSRule&gt; StyleRuleBase::createCSSOMWrapper(CSSRule* parentRule) const
 57 {
 58     return createCSSOMWrapper(nullptr, parentRule);
 59 }
 60 
 61 void StyleRuleBase::destroy()
 62 {
 63     switch (type()) {
 64     case StyleRuleType::Style:
 65         delete downcast&lt;StyleRule&gt;(this);
 66         return;
 67     case StyleRuleType::Page:
 68         delete downcast&lt;StyleRulePage&gt;(this);
 69         return;
 70     case StyleRuleType::FontFace:
 71         delete downcast&lt;StyleRuleFontFace&gt;(this);
 72         return;
 73     case StyleRuleType::Media:
 74         delete downcast&lt;StyleRuleMedia&gt;(this);
 75         return;
 76     case StyleRuleType::Supports:
 77         delete downcast&lt;StyleRuleSupports&gt;(this);
 78         return;
 79     case StyleRuleType::Import:
 80         delete downcast&lt;StyleRuleImport&gt;(this);
 81         return;
 82     case StyleRuleType::Keyframes:
 83         delete downcast&lt;StyleRuleKeyframes&gt;(this);
 84         return;
 85 #if ENABLE(CSS_DEVICE_ADAPTATION)
 86     case StyleRuleType::Viewport:
 87         delete downcast&lt;StyleRuleViewport&gt;(this);
 88         return;
 89 #endif
 90     case StyleRuleType::Namespace:
 91         delete downcast&lt;StyleRuleNamespace&gt;(this);
 92         return;
 93     case StyleRuleType::Keyframe:
 94         delete downcast&lt;StyleRuleKeyframe&gt;(this);
 95         return;
 96     case StyleRuleType::Charset:
 97         delete downcast&lt;StyleRuleCharset&gt;(this);
 98         return;
 99     case StyleRuleType::Unknown:
100         ASSERT_NOT_REACHED();
101         return;
102     }
103     ASSERT_NOT_REACHED();
104 }
105 
106 Ref&lt;StyleRuleBase&gt; StyleRuleBase::copy() const
107 {
108     switch (type()) {
109     case StyleRuleType::Style:
110         return downcast&lt;StyleRule&gt;(*this).copy();
111     case StyleRuleType::Page:
112         return downcast&lt;StyleRulePage&gt;(*this).copy();
113     case StyleRuleType::FontFace:
114         return downcast&lt;StyleRuleFontFace&gt;(*this).copy();
115     case StyleRuleType::Media:
116         return downcast&lt;StyleRuleMedia&gt;(*this).copy();
117     case StyleRuleType::Supports:
118         return downcast&lt;StyleRuleSupports&gt;(*this).copy();
119     case StyleRuleType::Keyframes:
120         return downcast&lt;StyleRuleKeyframes&gt;(*this).copy();
121 #if ENABLE(CSS_DEVICE_ADAPTATION)
122     case StyleRuleType::Viewport:
123         return downcast&lt;StyleRuleViewport&gt;(*this).copy();
124 #endif
125     case StyleRuleType::Import:
126     case StyleRuleType::Namespace:
127         // FIXME: Copy import and namespace rules.
128         break;
129     case StyleRuleType::Unknown:
130     case StyleRuleType::Charset:
131     case StyleRuleType::Keyframe:
132         break;
133     }
134     CRASH();
135 }
136 
137 Ref&lt;CSSRule&gt; StyleRuleBase::createCSSOMWrapper(CSSStyleSheet* parentSheet, CSSRule* parentRule) const
138 {
139     RefPtr&lt;CSSRule&gt; rule;
140     StyleRuleBase&amp; self = const_cast&lt;StyleRuleBase&amp;&gt;(*this);
141     switch (type()) {
142     case StyleRuleType::Style:
143         rule = CSSStyleRule::create(downcast&lt;StyleRule&gt;(self), parentSheet);
144         break;
145     case StyleRuleType::Page:
146         rule = CSSPageRule::create(downcast&lt;StyleRulePage&gt;(self), parentSheet);
147         break;
148     case StyleRuleType::FontFace:
149         rule = CSSFontFaceRule::create(downcast&lt;StyleRuleFontFace&gt;(self), parentSheet);
150         break;
151     case StyleRuleType::Media:
152         rule = CSSMediaRule::create(downcast&lt;StyleRuleMedia&gt;(self), parentSheet);
153         break;
154     case StyleRuleType::Supports:
155         rule = CSSSupportsRule::create(downcast&lt;StyleRuleSupports&gt;(self), parentSheet);
156         break;
157     case StyleRuleType::Import:
158         rule = CSSImportRule::create(downcast&lt;StyleRuleImport&gt;(self), parentSheet);
159         break;
160     case StyleRuleType::Keyframes:
161         rule = CSSKeyframesRule::create(downcast&lt;StyleRuleKeyframes&gt;(self), parentSheet);
162         break;
163 #if ENABLE(CSS_DEVICE_ADAPTATION)
164     case StyleRuleType::Viewport:
165         rule = WebKitCSSViewportRule::create(downcast&lt;StyleRuleViewport&gt;(self), parentSheet);
166         break;
167 #endif
168     case StyleRuleType::Namespace:
169         rule = CSSNamespaceRule::create(downcast&lt;StyleRuleNamespace&gt;(self), parentSheet);
170         break;
171     case StyleRuleType::Unknown:
172     case StyleRuleType::Charset:
173     case StyleRuleType::Keyframe:
174         ASSERT_NOT_REACHED();
175         break;
176     }
177     ASSERT(rule);
178 
179     if (parentRule)
180         rule-&gt;setParentRule(parentRule);
181     return rule.releaseNonNull();
182 }
183 
184 unsigned StyleRule::averageSizeInBytes()
185 {
186     return sizeof(StyleRule) + sizeof(CSSSelector) + StyleProperties::averageSizeInBytes();
187 }
188 
189 StyleRule::StyleRule(Ref&lt;StylePropertiesBase&gt;&amp;&amp; properties, bool hasDocumentSecurityOrigin, CSSSelectorList&amp;&amp; selectors)
190     : StyleRuleBase(StyleRuleType::Style, hasDocumentSecurityOrigin)
191     , m_properties(WTFMove(properties))
192     , m_selectorList(WTFMove(selectors))
193 {
194 }
195 
196 StyleRule::StyleRule(const StyleRule&amp; o)
197     : StyleRuleBase(o)
198     , m_properties(o.properties().mutableCopy())
199     , m_selectorList(o.m_selectorList)
200 {
201 }
202 
203 StyleRule::~StyleRule() = default;
204 
205 const StyleProperties&amp; StyleRule::properties() const
206 {
207     if (m_properties-&gt;type() == DeferredPropertiesType)
208         m_properties = downcast&lt;DeferredStyleProperties&gt;(m_properties.get()).parseDeferredProperties();
209     return downcast&lt;StyleProperties&gt;(m_properties.get());
210 }
211 
212 MutableStyleProperties&amp; StyleRule::mutableProperties()
213 {
214     if (!is&lt;MutableStyleProperties&gt;(m_properties.get()))
215         m_properties = properties().mutableCopy();
216     return downcast&lt;MutableStyleProperties&gt;(m_properties.get());
217 }
218 
219 Ref&lt;StyleRule&gt; StyleRule::createForSplitting(const Vector&lt;const CSSSelector*&gt;&amp; selectors, Ref&lt;StyleProperties&gt;&amp;&amp; properties, bool hasDocumentSecurityOrigin)
220 {
221     ASSERT_WITH_SECURITY_IMPLICATION(!selectors.isEmpty());
222     auto selectorListArray = makeUniqueArray&lt;CSSSelector&gt;(selectors.size());
223     for (unsigned i = 0; i &lt; selectors.size(); ++i)
224         new (NotNull, &amp;selectorListArray[i]) CSSSelector(*selectors.at(i));
225     selectorListArray[selectors.size() - 1].setLastInSelectorList();
226     return StyleRule::create(WTFMove(properties), hasDocumentSecurityOrigin, CSSSelectorList(WTFMove(selectorListArray)));
227 }
228 
229 Vector&lt;RefPtr&lt;StyleRule&gt;&gt; StyleRule::splitIntoMultipleRulesWithMaximumSelectorComponentCount(unsigned maxCount) const
230 {
231     ASSERT(selectorList().componentCount() &gt; maxCount);
232 
233     Vector&lt;RefPtr&lt;StyleRule&gt;&gt; rules;
234     Vector&lt;const CSSSelector*&gt; componentsSinceLastSplit;
235 
236     for (const CSSSelector* selector = selectorList().first(); selector; selector = CSSSelectorList::next(selector)) {
237         Vector&lt;const CSSSelector*, 8&gt; componentsInThisSelector;
238         for (const CSSSelector* component = selector; component; component = component-&gt;tagHistory())
239             componentsInThisSelector.append(component);
240 
241         if (componentsInThisSelector.size() + componentsSinceLastSplit.size() &gt; maxCount &amp;&amp; !componentsSinceLastSplit.isEmpty()) {
242             rules.append(createForSplitting(componentsSinceLastSplit, const_cast&lt;StyleProperties&amp;&gt;(properties()), hasDocumentSecurityOrigin()));
243             componentsSinceLastSplit.clear();
244         }
245 
246         componentsSinceLastSplit.appendVector(componentsInThisSelector);
247     }
248 
249     if (!componentsSinceLastSplit.isEmpty())
250         rules.append(createForSplitting(componentsSinceLastSplit, const_cast&lt;StyleProperties&amp;&gt;(properties()), hasDocumentSecurityOrigin()));
251 
252     return rules;
253 }
254 
255 StyleRulePage::StyleRulePage(Ref&lt;StyleProperties&gt;&amp;&amp; properties, CSSSelectorList&amp;&amp; selectors)
256     : StyleRuleBase(StyleRuleType::Page)
257     , m_properties(WTFMove(properties))
258     , m_selectorList(WTFMove(selectors))
259 {
260 }
261 
262 StyleRulePage::StyleRulePage(const StyleRulePage&amp; o)
263     : StyleRuleBase(o)
264     , m_properties(o.m_properties-&gt;mutableCopy())
265     , m_selectorList(o.m_selectorList)
266 {
267 }
268 
269 StyleRulePage::~StyleRulePage() = default;
270 
271 MutableStyleProperties&amp; StyleRulePage::mutableProperties()
272 {
273     if (!is&lt;MutableStyleProperties&gt;(m_properties.get()))
274         m_properties = m_properties-&gt;mutableCopy();
275     return downcast&lt;MutableStyleProperties&gt;(m_properties.get());
276 }
277 
278 StyleRuleFontFace::StyleRuleFontFace(Ref&lt;StyleProperties&gt;&amp;&amp; properties)
279     : StyleRuleBase(StyleRuleType::FontFace)
280     , m_properties(WTFMove(properties))
281 {
282 }
283 
284 StyleRuleFontFace::StyleRuleFontFace(const StyleRuleFontFace&amp; o)
285     : StyleRuleBase(o)
286     , m_properties(o.m_properties-&gt;mutableCopy())
287 {
288 }
289 
290 StyleRuleFontFace::~StyleRuleFontFace() = default;
291 
292 MutableStyleProperties&amp; StyleRuleFontFace::mutableProperties()
293 {
294     if (!is&lt;MutableStyleProperties&gt;(m_properties.get()))
295         m_properties = m_properties-&gt;mutableCopy();
296     return downcast&lt;MutableStyleProperties&gt;(m_properties.get());
297 }
298 
299 DeferredStyleGroupRuleList::DeferredStyleGroupRuleList(const CSSParserTokenRange&amp; range, CSSDeferredParser&amp; parser)
300     : m_parser(parser)
301 {
302     size_t length = range.end() - range.begin();
303     m_tokens.reserveCapacity(length);
304     m_tokens.append(range.begin(), length);
305 }
306 
307 void DeferredStyleGroupRuleList::parseDeferredRules(Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; childRules)
308 {
309     m_parser-&gt;parseRuleList(m_tokens, childRules);
310 }
311 
312 void DeferredStyleGroupRuleList::parseDeferredKeyframes(StyleRuleKeyframes&amp; keyframesRule)
313 {
314     m_parser-&gt;parseKeyframeList(m_tokens, keyframesRule);
315 }
316 
317 StyleRuleGroup::StyleRuleGroup(StyleRuleType type, Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; adoptRule)
318     : StyleRuleBase(type)
319 {
320     m_childRules.swap(adoptRule);
321 }
322 
323 StyleRuleGroup::StyleRuleGroup(StyleRuleType type, std::unique_ptr&lt;DeferredStyleGroupRuleList&gt;&amp;&amp; deferredRules)
324     : StyleRuleBase(type)
325     , m_deferredRules(WTFMove(deferredRules))
326 {
327 }
328 
329 StyleRuleGroup::StyleRuleGroup(const StyleRuleGroup&amp; o)
330     : StyleRuleBase(o)
331 {
332     m_childRules.reserveInitialCapacity(o.childRules().size());
333     for (auto&amp; childRule : o.childRules())
334         m_childRules.uncheckedAppend(childRule-&gt;copy());
335 }
336 
337 const Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; StyleRuleGroup::childRules() const
338 {
339     parseDeferredRulesIfNeeded();
340     return m_childRules;
341 }
342 
343 void StyleRuleGroup::wrapperInsertRule(unsigned index, Ref&lt;StyleRuleBase&gt;&amp;&amp; rule)
344 {
345     parseDeferredRulesIfNeeded();
346     m_childRules.insert(index, WTFMove(rule));
347 }
348 
349 void StyleRuleGroup::wrapperRemoveRule(unsigned index)
350 {
351     parseDeferredRulesIfNeeded();
352     m_childRules.remove(index);
353 }
354 
355 void StyleRuleGroup::parseDeferredRulesIfNeeded() const
356 {
357     if (!m_deferredRules)
358         return;
359 
360     m_deferredRules-&gt;parseDeferredRules(m_childRules);
361     m_deferredRules = nullptr;
362 }
363 
364 StyleRuleMedia::StyleRuleMedia(Ref&lt;MediaQuerySet&gt;&amp;&amp; media, Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; adoptRules)
365     : StyleRuleGroup(StyleRuleType::Media, adoptRules)
366     , m_mediaQueries(WTFMove(media))
367 {
368 }
369 
370 StyleRuleMedia::StyleRuleMedia(Ref&lt;MediaQuerySet&gt;&amp;&amp; media, std::unique_ptr&lt;DeferredStyleGroupRuleList&gt;&amp;&amp; deferredRules)
371     : StyleRuleGroup(StyleRuleType::Media, WTFMove(deferredRules))
372     , m_mediaQueries(WTFMove(media))
373 {
374 }
375 
376 StyleRuleMedia::StyleRuleMedia(const StyleRuleMedia&amp; o)
377     : StyleRuleGroup(o)
378 {
379     if (o.m_mediaQueries)
380         m_mediaQueries = o.m_mediaQueries-&gt;copy();
381 }
382 
383 
384 StyleRuleSupports::StyleRuleSupports(const String&amp; conditionText, bool conditionIsSupported, Vector&lt;RefPtr&lt;StyleRuleBase&gt;&gt;&amp; adoptRules)
385     : StyleRuleGroup(StyleRuleType::Supports, adoptRules)
386     , m_conditionText(conditionText)
387     , m_conditionIsSupported(conditionIsSupported)
388 {
389 }
390 
391 StyleRuleSupports::StyleRuleSupports(const String&amp; conditionText, bool conditionIsSupported,  std::unique_ptr&lt;DeferredStyleGroupRuleList&gt;&amp;&amp; deferredRules)
392     : StyleRuleGroup(StyleRuleType::Supports, WTFMove(deferredRules))
393     , m_conditionText(conditionText)
394     , m_conditionIsSupported(conditionIsSupported)
395 {
396 }
397 
398 StyleRuleSupports::StyleRuleSupports(const StyleRuleSupports&amp; o)
399     : StyleRuleGroup(o)
400     , m_conditionText(o.m_conditionText)
401     , m_conditionIsSupported(o.m_conditionIsSupported)
402 {
403 }
404 
405 #if ENABLE(CSS_DEVICE_ADAPTATION)
406 StyleRuleViewport::StyleRuleViewport(Ref&lt;StyleProperties&gt;&amp;&amp; properties)
407     : StyleRuleBase(StyleRuleType::Viewport)
408     , m_properties(WTFMove(properties))
409 {
410 }
411 
412 StyleRuleViewport::StyleRuleViewport(const StyleRuleViewport&amp; o)
413     : StyleRuleBase(o)
414     , m_properties(o.m_properties-&gt;mutableCopy())
415 {
416 }
417 
418 StyleRuleViewport::~StyleRuleViewport() = default;
419 
420 MutableStyleProperties&amp; StyleRuleViewport::mutableProperties()
421 {
422     if (!m_properties-&gt;isMutable())
423         m_properties = m_properties-&gt;mutableCopy();
424     return static_cast&lt;MutableStyleProperties&amp;&gt;(m_properties.get());
425 }
426 #endif // ENABLE(CSS_DEVICE_ADAPTATION)
427 
428 StyleRuleCharset::StyleRuleCharset()
429     : StyleRuleBase(StyleRuleType::Charset)
430 {
431 }
432 
433 StyleRuleCharset::StyleRuleCharset(const StyleRuleCharset&amp; o)
434     : StyleRuleBase(o)
435 {
436 }
437 
438 StyleRuleCharset::~StyleRuleCharset() = default;
439 
440 StyleRuleNamespace::StyleRuleNamespace(AtomString prefix, AtomString uri)
441     : StyleRuleBase(StyleRuleType::Namespace)
442     , m_prefix(prefix)
443     , m_uri(uri)
444 {
445 }
446 
447 StyleRuleNamespace::StyleRuleNamespace(const StyleRuleNamespace&amp; o)
448     : StyleRuleBase(o)
449     , m_prefix(o.m_prefix)
450     , m_uri(o.m_uri)
451 {
452 }
453 
454 StyleRuleNamespace::~StyleRuleNamespace() = default;
455 
456 } // namespace WebCore
    </pre>
  </body>
</html>
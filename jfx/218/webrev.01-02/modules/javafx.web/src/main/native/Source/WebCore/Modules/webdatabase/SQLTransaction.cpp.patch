diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/webdatabase/SQLTransaction.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/webdatabase/SQLTransaction.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/webdatabase/SQLTransaction.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/webdatabase/SQLTransaction.cpp
@@ -45,10 +45,11 @@
 #include "SQLTransactionCallback.h"
 #include "SQLTransactionCoordinator.h"
 #include "SQLTransactionErrorCallback.h"
 #include "SQLiteTransaction.h"
 #include "VoidCallback.h"
+#include "WindowEventLoop.h"
 #include <wtf/Optional.h>
 #include <wtf/StdLibExtras.h>
 #include <wtf/Vector.h>
 
 namespace WebCore {
@@ -107,10 +108,11 @@
     m_backend.runStateMachine();
 }
 
 void SQLTransaction::performPendingCallback()
 {
+    ASSERT(isMainThread());
     LOG(StorageAPI, "Callback %s\n", debugStepName(m_nextStep));
 
     ASSERT(m_nextStep == &SQLTransaction::deliverTransactionCallback
            || m_nextStep == &SQLTransaction::deliverTransactionErrorCallback
            || m_nextStep == &SQLTransaction::deliverStatementCallback
@@ -126,10 +128,22 @@
 void SQLTransaction::notifyDatabaseThreadIsShuttingDown()
 {
     m_backend.notifyDatabaseThreadIsShuttingDown();
 }
 
+void SQLTransaction::callErrorCallbackDueToInterruption()
+{
+    ASSERT(isMainThread());
+    auto errorCallback = m_errorCallbackWrapper.unwrap();
+    if (!errorCallback)
+        return;
+
+    m_database->document().eventLoop().queueTask(TaskSource::Networking, [errorCallback = WTFMove(errorCallback)]() mutable {
+        errorCallback->handleEvent(SQLError::create(SQLError::DATABASE_ERR, "the database was closed"));
+    });
+}
+
 void SQLTransaction::enqueueStatement(std::unique_ptr<SQLStatement> statement)
 {
     LockHolder locker(m_statementMutex);
     m_statementQueue.append(WTFMove(statement));
 }
@@ -178,10 +192,12 @@
 
     LockHolder locker(m_statementMutex);
     m_statementQueue.clear();
     m_nextStep = nullptr;
 
+    callErrorCallbackDueToInterruption();
+
     // Release the unneeded callbacks, to break reference cycles.
     m_callbackWrapper.clear();
     m_successCallbackWrapper.clear();
     m_errorCallbackWrapper.clear();
 
@@ -392,12 +408,15 @@
     ASSERT(m_transactionError);
 
     // Spec 4.3.2.10: If exists, invoke error callback with the last
     // error to have occurred in this transaction.
     RefPtr<SQLTransactionErrorCallback> errorCallback = m_errorCallbackWrapper.unwrap();
-    if (errorCallback)
-        errorCallback->handleEvent(*m_transactionError);
+    if (errorCallback) {
+        m_database->document().eventLoop().queueTask(TaskSource::Networking, [errorCallback = WTFMove(errorCallback), transactionError = m_transactionError]() mutable {
+            errorCallback->handleEvent(*transactionError);
+        });
+    }
 
     clearCallbackWrappers();
 
     // Spec 4.3.2.10: Rollback the transaction.
     m_backend.requestTransitToState(SQLTransactionState::CleanupAfterTransactionErrorCallback);
@@ -440,12 +459,15 @@
 
 void SQLTransaction::deliverSuccessCallback()
 {
     // Spec 4.3.2.8: Deliver success callback.
     RefPtr<VoidCallback> successCallback = m_successCallbackWrapper.unwrap();
-    if (successCallback)
-        successCallback->handleEvent();
+    if (successCallback) {
+        m_database->document().eventLoop().queueTask(TaskSource::Networking, [successCallback = WTFMove(successCallback)]() mutable {
+            successCallback->handleEvent();
+        });
+    }
 
     clearCallbackWrappers();
 
     // Schedule a "post-success callback" step to return control to the database thread in case there
     // are further transactions queued up for this Database
@@ -473,11 +495,12 @@
             || m_nextState == SQLTransactionState::DeliverQuotaIncreaseCallback
             || m_nextState == SQLTransactionState::DeliverSuccessCallback);
 
         LOG(StorageAPI, "Callback %s\n", nameForSQLTransactionState(m_nextState));
         return;
-    }
+    } else
+        callErrorCallbackDueToInterruption();
 
     clearCallbackWrappers();
     m_backend.requestTransitToState(SQLTransactionState::CleanupAndTerminate);
 }
 

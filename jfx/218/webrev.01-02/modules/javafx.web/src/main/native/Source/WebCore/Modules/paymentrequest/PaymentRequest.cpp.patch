diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/paymentrequest/PaymentRequest.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/paymentrequest/PaymentRequest.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/paymentrequest/PaymentRequest.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/paymentrequest/PaymentRequest.cpp
@@ -30,10 +30,11 @@
 
 #include "ApplePayPaymentHandler.h"
 #include "Document.h"
 #include "EventNames.h"
 #include "JSDOMPromise.h"
+#include "JSDOMPromiseDeferred.h"
 #include "JSPaymentDetailsUpdate.h"
 #include "JSPaymentResponse.h"
 #include "Page.h"
 #include "PaymentAddress.h"
 #include "PaymentCoordinator.h"
@@ -248,11 +249,11 @@
 enum class ShouldValidatePaymentMethodIdentifier {
     No,
     Yes,
 };
 
-static ExceptionOr<std::tuple<String, Vector<String>>> checkAndCanonicalizeDetails(JSC::ExecState& execState, PaymentDetailsBase& details, bool requestShipping, ShouldValidatePaymentMethodIdentifier shouldValidatePaymentMethodIdentifier)
+static ExceptionOr<std::tuple<String, Vector<String>>> checkAndCanonicalizeDetails(JSC::JSGlobalObject& execState, PaymentDetailsBase& details, bool requestShipping, ShouldValidatePaymentMethodIdentifier shouldValidatePaymentMethodIdentifier)
 {
     for (auto& item : details.displayItems) {
         auto exception = checkAndCanonicalizeAmount(item.amount);
         if (exception.hasException())
             return exception.releaseException();
@@ -308,10 +309,19 @@
     }
 
     return std::make_tuple(WTFMove(selectedShippingOption), WTFMove(serializedModifierData));
 }
 
+static ExceptionOr<JSC::JSValue> parse(ScriptExecutionContext& context, const String& string)
+{
+    auto scope = DECLARE_THROW_SCOPE(context.vm());
+    JSC::JSValue data = JSONParse(context.execState(), string);
+    if (scope.exception())
+        return Exception { ExistingExceptionError };
+    return data;
+}
+
 // Implements the PaymentRequest Constructor
 // https://www.w3.org/TR/payment-request/#constructor
 ExceptionOr<Ref<PaymentRequest>> PaymentRequest::create(Document& document, Vector<PaymentMethodData>&& methodData, PaymentDetailsInit&& details, PaymentOptions&& options)
 {
     auto canCreateSession = PaymentHandler::canCreateSession(document);
@@ -335,10 +345,18 @@
         if (paymentMethod.data) {
             auto scope = DECLARE_THROW_SCOPE(document.execState()->vm());
             serializedData = JSONStringify(document.execState(), paymentMethod.data.get(), 0);
             if (scope.exception())
                 return Exception { ExistingExceptionError };
+
+            auto parsedDataOrException = parse(document, serializedData);
+            if (parsedDataOrException.hasException())
+                return parsedDataOrException.releaseException();
+
+            auto exception = PaymentHandler::validateData(document, parsedDataOrException.releaseReturnValue(), *identifier);
+            if (exception.hasException())
+                return exception.releaseException();
         }
         serializedMethodData.uncheckedAppend({ WTFMove(*identifier), WTFMove(serializedData) });
     }
 
     auto totalResult = checkAndCanonicalizeTotal(details.total.amount);
@@ -373,19 +391,10 @@
 {
     ASSERT(!hasPendingActivity());
     ASSERT(!m_activePaymentHandler);
 }
 
-static ExceptionOr<JSC::JSValue> parse(ScriptExecutionContext& context, const String& string)
-{
-    auto scope = DECLARE_THROW_SCOPE(context.vm());
-    JSC::JSValue data = JSONParse(context.execState(), string);
-    if (scope.exception())
-        return Exception { ExistingExceptionError };
-    return WTFMove(data);
-}
-
 // https://www.w3.org/TR/payment-request/#show()-method
 void PaymentRequest::show(Document& document, RefPtr<DOMPromise>&& detailsPromise, ShowPromise&& promise)
 {
     if (!document.frame()) {
         promise.reject(Exception { AbortError });
@@ -408,11 +417,11 @@
         return;
     }
 
     m_state = State::Interactive;
     ASSERT(!m_showPromise);
-    m_showPromise = WTFMove(promise);
+    m_showPromise = WTF::makeUnique<ShowPromise>(WTFMove(promise));
 
     RefPtr<PaymentHandler> selectedPaymentHandler;
     for (auto& paymentMethod : m_serializedMethodData) {
         auto data = parse(document, paymentMethod.serializedData);
         if (data.hasException()) {
@@ -466,11 +475,11 @@
         settleShowPromise(WTFMove(exception));
 }
 
 void PaymentRequest::settleShowPromise(ExceptionOr<PaymentResponse&>&& result)
 {
-    if (auto showPromise = std::exchange(m_showPromise, WTF::nullopt))
+    if (auto showPromise = std::exchange(m_showPromise, nullptr))
         showPromise->settle(WTFMove(result));
 }
 
 void PaymentRequest::closeActivePaymentHandler()
 {
@@ -485,10 +494,24 @@
 {
     closeActivePaymentHandler();
     settleShowPromise(Exception { AbortError });
 }
 
+void PaymentRequest::suspend(ReasonForSuspension reason)
+{
+    if (reason != ReasonForSuspension::BackForwardCache)
+        return;
+
+    if (!m_activePaymentHandler) {
+        ASSERT(!m_showPromise);
+        ASSERT(m_state != State::Interactive);
+        return;
+    }
+
+    stop();
+}
+
 // https://www.w3.org/TR/payment-request/#abort()-method
 void PaymentRequest::abort(AbortPromise&& promise)
 {
     if (m_response && m_response->hasRetryPromise()) {
         promise.reject(Exception { InvalidStateError });
@@ -536,15 +559,10 @@
     if (m_options.requestShipping)
         return m_options.shippingType;
     return WTF::nullopt;
 }
 
-bool PaymentRequest::canSuspendForDocumentSuspension() const
-{
-    return !hasPendingActivity();
-}
-
 void PaymentRequest::shippingAddressChanged(Ref<PaymentAddress>&& shippingAddress)
 {
     whenDetailsSettled([this, protectedThis = makeRefPtr(this), shippingAddress = makeRefPtr(shippingAddress.get())]() mutable {
         m_shippingAddress = WTFMove(shippingAddress);
         dispatchEvent(PaymentRequestUpdateEvent::create(eventNames().shippingaddresschangeEvent));

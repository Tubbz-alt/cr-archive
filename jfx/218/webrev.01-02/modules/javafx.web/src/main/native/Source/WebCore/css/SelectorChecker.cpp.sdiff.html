<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/SelectorChecker.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGCSSComputedStyleDeclaration.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorChecker.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/SelectorChecker.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 251         updatedContext.element = downcast&lt;ShadowRoot&gt;(*context.element-&gt;parentNode()).host();
 252         updatedContext.mayMatchHostPseudoClass = true;
 253         return updatedContext;
 254     }
 255 
 256     updatedContext.element = context.element-&gt;parentElement();
 257     return updatedContext;
 258 }
 259 
 260 // Recursive check of selectors and combinators
 261 // It can return 4 different values:
 262 // * SelectorMatches          - the selector matches the element e
 263 // * SelectorFailsLocally     - the selector fails for the element e
 264 // * SelectorFailsAllSiblings - the selector fails for e and any sibling of e
 265 // * SelectorFailsCompletely  - the selector fails for e and any sibling or ancestor of e
 266 SelectorChecker::MatchResult SelectorChecker::matchRecursively(CheckingContext&amp; checkingContext, const LocalContext&amp; context, PseudoIdSet&amp; dynamicPseudoIdSet, unsigned&amp; specificity) const
 267 {
 268     MatchType matchType = MatchType::Element;
 269 
 270     // The first selector has to match.
<span class="line-modified"> 271     if (!checkOne(checkingContext, context, dynamicPseudoIdSet, matchType, specificity))</span>
 272         return MatchResult::fails(Match::SelectorFailsLocally);
 273 
 274     if (context.selector-&gt;match() == CSSSelector::PseudoElement) {
 275         if (context.selector-&gt;isCustomPseudoElement()) {
 276             // In functional pseudo class, custom pseudo elements are always disabled.
 277             // FIXME: We should accept custom pseudo elements inside :matches().
 278             if (context.inFunctionalPseudoClass)
 279                 return MatchResult::fails(Match::SelectorFailsCompletely);
 280             if (ShadowRoot* root = context.element-&gt;containingShadowRoot()) {
 281                 if (context.element-&gt;shadowPseudoId() != context.selector-&gt;value())
 282                     return MatchResult::fails(Match::SelectorFailsLocally);
 283 
 284                 if (context.selector-&gt;isWebKitCustomPseudoElement() &amp;&amp; root-&gt;mode() != ShadowRootMode::UserAgent)
 285                     return MatchResult::fails(Match::SelectorFailsLocally);
 286             } else
 287                 return MatchResult::fails(Match::SelectorFailsLocally);
 288         } else {
 289             if (!context.pseudoElementEffective)
 290                 return MatchResult::fails(Match::SelectorFailsCompletely);
 291 
</pre>
<hr />
<pre>
 303     auto relation = context.selector-&gt;relation();
 304 
 305     // Prepare next selector
 306     const CSSSelector* leftSelector = context.selector-&gt;tagHistory();
 307     if (!leftSelector)
 308         return MatchResult::matches(matchType);
 309 
 310     LocalContext nextContext(context);
 311     nextContext.selector = leftSelector;
 312 
 313     if (relation != CSSSelector::Subselector) {
 314         // Bail-out if this selector is irrelevant for the pseudoId
 315         if (context.pseudoId != PseudoId::None &amp;&amp; !dynamicPseudoIdSet.has(context.pseudoId))
 316             return MatchResult::fails(Match::SelectorFailsCompletely);
 317 
 318         // Disable :visited matching when we try to match anything else than an ancestors.
 319         if (!context.selector-&gt;hasDescendantOrChildRelation())
 320             nextContext.visitedMatchType = VisitedMatchType::Disabled;
 321 
 322         nextContext.pseudoId = PseudoId::None;



 323         // Virtual pseudo element is only effective in the rightmost fragment.
<span class="line-modified"> 324         nextContext.pseudoElementEffective = false;</span>


 325         nextContext.isMatchElement = false;
 326     }
 327 
 328     switch (relation) {
 329     case CSSSelector::DescendantSpace:
 330         nextContext = localContextForParent(nextContext);
 331         nextContext.firstSelectorOfTheFragment = nextContext.selector;
 332         for (; nextContext.element; nextContext = localContextForParent(nextContext)) {
 333             PseudoIdSet ignoreDynamicPseudo;
 334             unsigned descendantsSpecificity = 0;
 335             MatchResult result = matchRecursively(checkingContext, nextContext, ignoreDynamicPseudo, descendantsSpecificity);
 336             ASSERT(!nextContext.pseudoElementEffective &amp;&amp; !ignoreDynamicPseudo);
 337 
 338             if (result.match == Match::SelectorMatches)
 339                 specificity = CSSSelector::addSpecificities(specificity, descendantsSpecificity);
 340 
 341             if (result.match == Match::SelectorMatches || result.match == Match::SelectorFailsCompletely)
 342                 return MatchResult::updateWithMatchType(result, matchType);
 343         }
 344         return MatchResult::fails(Match::SelectorFailsCompletely);
</pre>
<hr />
<pre>
 412             // a selector is invalid if something follows a pseudo-element
 413             // We make an exception for scrollbar pseudo elements and allow a set of pseudo classes (but nothing else)
 414             // to follow the pseudo elements.
 415             nextContext.hasScrollbarPseudo = hasScrollbarPseudoElement(dynamicPseudoIdSet);
 416             nextContext.hasSelectionPseudo = dynamicPseudoIdSet.has(PseudoId::Selection);
 417             if ((context.isMatchElement || checkingContext.resolvingMode == Mode::CollectingRules) &amp;&amp; dynamicPseudoIdSet
 418                 &amp;&amp; !nextContext.hasSelectionPseudo
 419                 &amp;&amp; !(nextContext.hasScrollbarPseudo &amp;&amp; nextContext.selector-&gt;match() == CSSSelector::PseudoClass))
 420                 return MatchResult::fails(Match::SelectorFailsCompletely);
 421 
 422             unsigned subselectorSpecificity = 0;
 423             MatchResult result = matchRecursively(checkingContext, nextContext, dynamicPseudoIdSet, subselectorSpecificity);
 424 
 425             if (result.match == Match::SelectorMatches)
 426                 specificity = CSSSelector::addSpecificities(specificity, subselectorSpecificity);
 427 
 428             return MatchResult::updateWithMatchType(result, matchType);
 429         }
 430     case CSSSelector::ShadowDescendant:
 431         {
<span class="line-modified"> 432             Element* shadowHostNode = context.element-&gt;shadowHost();</span>
<span class="line-modified"> 433             if (!shadowHostNode)</span>


 434                 return MatchResult::fails(Match::SelectorFailsCompletely);
<span class="line-modified"> 435             nextContext.element = shadowHostNode;</span>
 436             nextContext.firstSelectorOfTheFragment = nextContext.selector;
 437             nextContext.isSubjectOrAdjacentElement = false;
 438             PseudoIdSet ignoreDynamicPseudo;
 439             unsigned shadowDescendantSpecificity = 0;
 440             MatchResult result = matchRecursively(checkingContext, nextContext, ignoreDynamicPseudo, shadowDescendantSpecificity);
 441 
 442             if (result.match == Match::SelectorMatches)
 443                 specificity = CSSSelector::addSpecificities(specificity, shadowDescendantSpecificity);
 444 
 445             return MatchResult::updateWithMatchType(result, matchType);
 446         }
 447     }
 448 
 449 
 450     ASSERT_NOT_REACHED();
 451     return MatchResult::fails(Match::SelectorFailsCompletely);
 452 }
 453 
 454 static bool attributeValueMatches(const Attribute&amp; attribute, CSSSelector::Match match, const AtomString&amp; selectorValue, bool caseSensitive)
 455 {
</pre>
<hr />
<pre>
 627             return false;
 628     }
 629     return false;
 630 }
 631 
 632 static inline bool tagMatches(const Element&amp; element, const CSSSelector&amp; simpleSelector)
 633 {
 634     const QualifiedName&amp; tagQName = simpleSelector.tagQName();
 635 
 636     if (tagQName == anyQName())
 637         return true;
 638 
 639     const AtomString&amp; localName = (element.isHTMLElement() &amp;&amp; element.document().isHTMLDocument()) ? simpleSelector.tagLowercaseLocalName() : tagQName.localName();
 640 
 641     if (localName != starAtom() &amp;&amp; localName != element.localName())
 642         return false;
 643     const AtomString&amp; namespaceURI = tagQName.namespaceURI();
 644     return namespaceURI == starAtom() || namespaceURI == element.namespaceURI();
 645 }
 646 
<span class="line-modified"> 647 bool SelectorChecker::checkOne(CheckingContext&amp; checkingContext, const LocalContext&amp; context, PseudoIdSet&amp; dynamicPseudoIdSet, MatchType&amp; matchType, unsigned&amp; specificity) const</span>
 648 {
 649     const Element&amp; element = *context.element;
 650     const CSSSelector&amp; selector = *context.selector;
 651 
 652     specificity = CSSSelector::addSpecificities(specificity, selector.simpleSelectorSpecificity());
 653 
 654     if (context.mayMatchHostPseudoClass) {
 655         // :host doesn&#39;t combine with anything except pseudo elements.
 656         bool isHostPseudoClass = selector.match() == CSSSelector::PseudoClass &amp;&amp; selector.pseudoClassType() == CSSSelector::PseudoClassHost;
 657         bool isPseudoElement = selector.match() == CSSSelector::PseudoElement;
 658         if (!isHostPseudoClass &amp;&amp; !isPseudoElement)
 659             return false;
 660     }
 661 
 662     if (selector.match() == CSSSelector::Tag)
 663         return tagMatches(element, selector);
 664 
 665     if (selector.match() == CSSSelector::Class)
 666         return element.hasClass() &amp;&amp; element.classNames().contains(selector.value());
 667 
</pre>
<hr />
<pre>
 817                 addStyleRelation(checkingContext, parentElement, backwardRelation);
 818 
 819                 if (!parentElement.isFinishedParsingChildren())
 820                     return false;
 821             } else if (!is&lt;ShadowRoot&gt;(parent))
 822                 break; // FIXME: Add the support for specifying relations on ShadowRoot.
 823             return isFirstOfType(element, element.tagQName()) &amp;&amp; isLastOfType(element, element.tagQName());
 824         }
 825         case CSSSelector::PseudoClassMatches:
 826             {
 827                 bool hasMatchedAnything = false;
 828                 unsigned maxSpecificity = 0;
 829 
 830                 MatchType localMatchType = MatchType::VirtualPseudoElementOnly;
 831                 for (const CSSSelector* subselector = selector.selectorList()-&gt;first(); subselector; subselector = CSSSelectorList::next(subselector)) {
 832                     LocalContext subcontext(context);
 833                     subcontext.inFunctionalPseudoClass = true;
 834                     subcontext.pseudoElementEffective = context.pseudoElementEffective;
 835                     subcontext.selector = subselector;
 836                     subcontext.firstSelectorOfTheFragment = subselector;

 837                     PseudoIdSet localDynamicPseudoIdSet;
 838                     unsigned localSpecificity = 0;
 839                     MatchResult result = matchRecursively(checkingContext, subcontext, localDynamicPseudoIdSet, localSpecificity);





 840                     if (result.match == Match::SelectorMatches) {
 841                         maxSpecificity = std::max(maxSpecificity, localSpecificity);
 842 
 843                         if (result.matchType == MatchType::Element)
 844                             localMatchType = MatchType::Element;
 845 
<span class="line-removed"> 846                         dynamicPseudoIdSet.merge(localDynamicPseudoIdSet);</span>
 847                         hasMatchedAnything = true;
 848                     }
 849                 }
 850                 if (hasMatchedAnything) {
 851                     matchType = localMatchType;
 852                     specificity = CSSSelector::addSpecificities(specificity, maxSpecificity);
 853                 }
 854                 return hasMatchedAnything;
 855             }
 856         case CSSSelector::PseudoClassPlaceholderShown:
 857             if (is&lt;HTMLTextFormControlElement&gt;(element)) {
 858                 addStyleRelation(checkingContext, element, Style::Relation::Unique);
 859                 return downcast&lt;HTMLTextFormControlElement&gt;(element).isPlaceholderVisible();
 860             }
 861             return false;
 862         case CSSSelector::PseudoClassNthChild: {
 863             auto* parent = element.parentNode();
 864             if (is&lt;Element&gt;(parent)) {
 865                 auto relation = context.isSubjectOrAdjacentElement ? Style::Relation::ChildrenAffectedByForwardPositionalRules : Style::Relation::DescendantsAffectedByForwardPositionalRules;
 866                 addStyleRelation(checkingContext, downcast&lt;Element&gt;(*parent), relation);
</pre>
<hr />
<pre>
 967                 }
 968             }
 969             break;
 970         case CSSSelector::PseudoClassAutofill:
 971             return isAutofilled(element);
 972         case CSSSelector::PseudoClassAutofillStrongPassword:
 973             return isAutofilledStrongPassword(element);
 974         case CSSSelector::PseudoClassAutofillStrongPasswordViewable:
 975             return isAutofilledStrongPasswordViewable(element);
 976         case CSSSelector::PseudoClassAnyLink:
 977         case CSSSelector::PseudoClassAnyLinkDeprecated:
 978         case CSSSelector::PseudoClassLink:
 979             // :visited and :link matches are separated later when applying the style. Here both classes match all links...
 980             return element.isLink();
 981         case CSSSelector::PseudoClassVisited:
 982             // ...except if :visited matching is disabled for ancestor/sibling matching.
 983             // Inside functional pseudo class except for :not, :visited never matches.
 984             if (context.inFunctionalPseudoClass)
 985                 return false;
 986             return element.isLink() &amp;&amp; context.visitedMatchType == VisitedMatchType::Enabled;


 987         case CSSSelector::PseudoClassDrag:
 988             addStyleRelation(checkingContext, element, Style::Relation::AffectedByDrag);
 989 
 990             if (element.renderer() &amp;&amp; element.renderer()-&gt;isDragging())
 991                 return true;
 992             break;
 993         case CSSSelector::PseudoClassFocus:
 994             return matchesFocusPseudoClass(element);
 995         case CSSSelector::PseudoClassFocusWithin:
 996             addStyleRelation(checkingContext, element, Style::Relation::AffectedByFocusWithin);
 997             return element.hasFocusWithin();
 998         case CSSSelector::PseudoClassHover:
 999             if (m_strictParsing || element.isLink() || canMatchHoverOrActiveInQuirksMode(context)) {
1000                 addStyleRelation(checkingContext, element, Style::Relation::AffectedByHover);
1001 
1002                 // See the comment in generateElementIsHovered() in SelectorCompiler.
1003                 if (checkingContext.resolvingMode == SelectorChecker::Mode::CollectingRulesIgnoringVirtualPseudoElements &amp;&amp; !context.isMatchElement)
1004                     return true;
1005 
1006                 if (element.hovered() || InspectorInstrumentation::forcePseudoState(element, CSSSelector::PseudoClassHover))
</pre>
<hr />
<pre>
1028         case CSSSelector::PseudoClassReadWrite:
1029             return matchesReadWritePseudoClass(element);
1030         case CSSSelector::PseudoClassOptional:
1031             return isOptionalFormControl(element);
1032         case CSSSelector::PseudoClassRequired:
1033             return isRequiredFormControl(element);
1034         case CSSSelector::PseudoClassValid:
1035             return isValid(element);
1036         case CSSSelector::PseudoClassInvalid:
1037             return isInvalid(element);
1038         case CSSSelector::PseudoClassChecked:
1039             return isChecked(element);
1040         case CSSSelector::PseudoClassIndeterminate:
1041             return matchesIndeterminatePseudoClass(element);
1042         case CSSSelector::PseudoClassRoot:
1043             if (&amp;element == element.document().documentElement())
1044                 return true;
1045             break;
1046         case CSSSelector::PseudoClassLang:
1047             {
<span class="line-modified">1048                 ASSERT(selector.langArgumentList() &amp;&amp; !selector.langArgumentList()-&gt;isEmpty());</span>
<span class="line-modified">1049                 return matchesLangPseudoClass(element, *selector.langArgumentList());</span>
1050             }
1051 #if ENABLE(FULLSCREEN_API)
1052         case CSSSelector::PseudoClassFullScreen:
1053             return matchesFullScreenPseudoClass(element);
1054         case CSSSelector::PseudoClassAnimatingFullScreenTransition:
1055             return matchesFullScreenAnimatingFullScreenTransitionPseudoClass(element);
1056         case CSSSelector::PseudoClassFullScreenAncestor:
1057             return matchesFullScreenAncestorPseudoClass(element);
1058         case CSSSelector::PseudoClassFullScreenDocument:
1059             return matchesFullScreenDocumentPseudoClass(element);
1060         case CSSSelector::PseudoClassFullScreenControlsHidden:
1061             return matchesFullScreenControlsHiddenPseudoClass(element);




1062 #endif
1063         case CSSSelector::PseudoClassInRange:
1064             return isInRange(element);
1065         case CSSSelector::PseudoClassOutOfRange:
1066             return isOutOfRange(element);
1067 #if ENABLE(VIDEO_TRACK)
1068         case CSSSelector::PseudoClassFuture:
1069             return matchesFutureCuePseudoClass(element);
1070         case CSSSelector::PseudoClassPast:
1071             return matchesPastCuePseudoClass(element);
1072 #endif
1073 
1074         case CSSSelector::PseudoClassScope: {
1075             const Node* contextualReferenceNode = !checkingContext.scope ? element.document().documentElement() : checkingContext.scope;
1076             if (&amp;element == contextualReferenceNode)
1077                 return true;
1078             break;
1079         }
1080         case CSSSelector::PseudoClassHost: {
1081             if (!context.mayMatchHostPseudoClass)
</pre>
<hr />
<pre>
1107         // FIXME: Implement :dir() selector.
1108         case CSSSelector::PseudoClassDir:
1109             return false;
1110 
1111         // FIXME: Implement :role() selector.
1112         case CSSSelector::PseudoClassRole:
1113             return false;
1114 #endif
1115 
1116 #if ENABLE(ATTACHMENT_ELEMENT)
1117         case CSSSelector::PseudoClassHasAttachment:
1118             return hasAttachment(element);
1119 #endif
1120 
1121         case CSSSelector::PseudoClassUnknown:
1122             ASSERT_NOT_REACHED();
1123             break;
1124         }
1125         return false;
1126     }



1127 #if ENABLE(VIDEO_TRACK)
<span class="line-modified">1128     if (selector.match() == CSSSelector::PseudoElement &amp;&amp; selector.pseudoElementType() == CSSSelector::PseudoElementCue) {</span>
<span class="line-modified">1129         LocalContext subcontext(context);</span>
1130 
<span class="line-modified">1131         const CSSSelector* const &amp; selector = context.selector;</span>
<span class="line-modified">1132         for (subcontext.selector = selector-&gt;selectorList()-&gt;first(); subcontext.selector; subcontext.selector = CSSSelectorList::next(subcontext.selector)) {</span>
<span class="line-modified">1133             subcontext.firstSelectorOfTheFragment = subcontext.selector;</span>
<span class="line-modified">1134             subcontext.inFunctionalPseudoClass = true;</span>
<span class="line-modified">1135             subcontext.pseudoElementEffective = false;</span>
<span class="line-modified">1136             PseudoIdSet ignoredDynamicPseudo;</span>
<span class="line-modified">1137             unsigned ignoredSpecificity = 0;</span>
<span class="line-modified">1138             if (matchRecursively(checkingContext, subcontext, ignoredDynamicPseudo, ignoredSpecificity).match == Match::SelectorMatches)</span>
<span class="line-modified">1139                 return true;</span>


1140         }
<span class="line-removed">1141         return false;</span>
<span class="line-removed">1142     }</span>
1143 #endif
<span class="line-modified">1144     if (selector.match() == CSSSelector::PseudoElement &amp;&amp; selector.pseudoElementType() == CSSSelector::PseudoElementSlotted) {</span>
<span class="line-modified">1145         // We see ::slotted() pseudo elements when collecting slotted rules from the slot shadow tree only.</span>
<span class="line-modified">1146         ASSERT(checkingContext.resolvingMode == Mode::CollectingRules);</span>
<span class="line-modified">1147         return is&lt;HTMLSlotElement&gt;(element);</span>










































1148     }
1149     return true;
1150 }
1151 
1152 bool SelectorChecker::matchSelectorList(CheckingContext&amp; checkingContext, const LocalContext&amp; context, const Element&amp; element, const CSSSelectorList&amp; selectorList, unsigned&amp; specificity) const
1153 {
1154     specificity = 0;
1155     bool hasMatchedAnything = false;
1156 
1157     for (const CSSSelector* subselector = selectorList.first(); subselector; subselector = CSSSelectorList::next(subselector)) {
1158         LocalContext subcontext(context);
1159         subcontext.element = &amp;element;
1160         subcontext.selector = subselector;
1161         subcontext.inFunctionalPseudoClass = true;
1162         subcontext.pseudoElementEffective = false;
1163         subcontext.firstSelectorOfTheFragment = subselector;
1164         PseudoIdSet ignoreDynamicPseudo;
1165         unsigned localSpecificity = 0;
1166         if (matchRecursively(checkingContext, subcontext, ignoreDynamicPseudo, localSpecificity).match == Match::SelectorMatches) {
1167             ASSERT(!ignoreDynamicPseudo);
</pre>
<hr />
<pre>
1231             default:
1232                 break;
1233             }
1234         }
1235         auto relation = selector-&gt;relation();
1236         if (relation == CSSSelector::Subselector)
1237             continue;
1238         if (!selector-&gt;hasDescendantOrChildRelation())
1239             return linkMatchType;
1240         if (linkMatchType != MatchAll)
1241             return linkMatchType;
1242     }
1243     return linkMatchType;
1244 }
1245 
1246 static bool isFrameFocused(const Element&amp; element)
1247 {
1248     return element.document().frame() &amp;&amp; element.document().frame()-&gt;selection().isFocusedAndActive();
1249 }
1250 






1251 bool SelectorChecker::matchesFocusPseudoClass(const Element&amp; element)
1252 {
1253     if (InspectorInstrumentation::forcePseudoState(element, CSSSelector::PseudoClassFocus))
1254         return true;











1255     return element.focused() &amp;&amp; isFrameFocused(element);
1256 }
1257 
1258 }
</pre>
</td>
<td>
<hr />
<pre>
 251         updatedContext.element = downcast&lt;ShadowRoot&gt;(*context.element-&gt;parentNode()).host();
 252         updatedContext.mayMatchHostPseudoClass = true;
 253         return updatedContext;
 254     }
 255 
 256     updatedContext.element = context.element-&gt;parentElement();
 257     return updatedContext;
 258 }
 259 
 260 // Recursive check of selectors and combinators
 261 // It can return 4 different values:
 262 // * SelectorMatches          - the selector matches the element e
 263 // * SelectorFailsLocally     - the selector fails for the element e
 264 // * SelectorFailsAllSiblings - the selector fails for e and any sibling of e
 265 // * SelectorFailsCompletely  - the selector fails for e and any sibling or ancestor of e
 266 SelectorChecker::MatchResult SelectorChecker::matchRecursively(CheckingContext&amp; checkingContext, const LocalContext&amp; context, PseudoIdSet&amp; dynamicPseudoIdSet, unsigned&amp; specificity) const
 267 {
 268     MatchType matchType = MatchType::Element;
 269 
 270     // The first selector has to match.
<span class="line-modified"> 271     if (!checkOne(checkingContext, context, matchType, specificity))</span>
 272         return MatchResult::fails(Match::SelectorFailsLocally);
 273 
 274     if (context.selector-&gt;match() == CSSSelector::PseudoElement) {
 275         if (context.selector-&gt;isCustomPseudoElement()) {
 276             // In functional pseudo class, custom pseudo elements are always disabled.
 277             // FIXME: We should accept custom pseudo elements inside :matches().
 278             if (context.inFunctionalPseudoClass)
 279                 return MatchResult::fails(Match::SelectorFailsCompletely);
 280             if (ShadowRoot* root = context.element-&gt;containingShadowRoot()) {
 281                 if (context.element-&gt;shadowPseudoId() != context.selector-&gt;value())
 282                     return MatchResult::fails(Match::SelectorFailsLocally);
 283 
 284                 if (context.selector-&gt;isWebKitCustomPseudoElement() &amp;&amp; root-&gt;mode() != ShadowRootMode::UserAgent)
 285                     return MatchResult::fails(Match::SelectorFailsLocally);
 286             } else
 287                 return MatchResult::fails(Match::SelectorFailsLocally);
 288         } else {
 289             if (!context.pseudoElementEffective)
 290                 return MatchResult::fails(Match::SelectorFailsCompletely);
 291 
</pre>
<hr />
<pre>
 303     auto relation = context.selector-&gt;relation();
 304 
 305     // Prepare next selector
 306     const CSSSelector* leftSelector = context.selector-&gt;tagHistory();
 307     if (!leftSelector)
 308         return MatchResult::matches(matchType);
 309 
 310     LocalContext nextContext(context);
 311     nextContext.selector = leftSelector;
 312 
 313     if (relation != CSSSelector::Subselector) {
 314         // Bail-out if this selector is irrelevant for the pseudoId
 315         if (context.pseudoId != PseudoId::None &amp;&amp; !dynamicPseudoIdSet.has(context.pseudoId))
 316             return MatchResult::fails(Match::SelectorFailsCompletely);
 317 
 318         // Disable :visited matching when we try to match anything else than an ancestors.
 319         if (!context.selector-&gt;hasDescendantOrChildRelation())
 320             nextContext.visitedMatchType = VisitedMatchType::Disabled;
 321 
 322         nextContext.pseudoId = PseudoId::None;
<span class="line-added"> 323 </span>
<span class="line-added"> 324         bool nextIsPart = leftSelector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; leftSelector-&gt;pseudoElementType() == CSSSelector::PseudoElementPart;</span>
<span class="line-added"> 325         bool allowMultiplePseudoElements = relation == CSSSelector::ShadowDescendant &amp;&amp; nextIsPart;</span>
 326         // Virtual pseudo element is only effective in the rightmost fragment.
<span class="line-modified"> 327         if (!allowMultiplePseudoElements)</span>
<span class="line-added"> 328             nextContext.pseudoElementEffective = false;</span>
<span class="line-added"> 329 </span>
 330         nextContext.isMatchElement = false;
 331     }
 332 
 333     switch (relation) {
 334     case CSSSelector::DescendantSpace:
 335         nextContext = localContextForParent(nextContext);
 336         nextContext.firstSelectorOfTheFragment = nextContext.selector;
 337         for (; nextContext.element; nextContext = localContextForParent(nextContext)) {
 338             PseudoIdSet ignoreDynamicPseudo;
 339             unsigned descendantsSpecificity = 0;
 340             MatchResult result = matchRecursively(checkingContext, nextContext, ignoreDynamicPseudo, descendantsSpecificity);
 341             ASSERT(!nextContext.pseudoElementEffective &amp;&amp; !ignoreDynamicPseudo);
 342 
 343             if (result.match == Match::SelectorMatches)
 344                 specificity = CSSSelector::addSpecificities(specificity, descendantsSpecificity);
 345 
 346             if (result.match == Match::SelectorMatches || result.match == Match::SelectorFailsCompletely)
 347                 return MatchResult::updateWithMatchType(result, matchType);
 348         }
 349         return MatchResult::fails(Match::SelectorFailsCompletely);
</pre>
<hr />
<pre>
 417             // a selector is invalid if something follows a pseudo-element
 418             // We make an exception for scrollbar pseudo elements and allow a set of pseudo classes (but nothing else)
 419             // to follow the pseudo elements.
 420             nextContext.hasScrollbarPseudo = hasScrollbarPseudoElement(dynamicPseudoIdSet);
 421             nextContext.hasSelectionPseudo = dynamicPseudoIdSet.has(PseudoId::Selection);
 422             if ((context.isMatchElement || checkingContext.resolvingMode == Mode::CollectingRules) &amp;&amp; dynamicPseudoIdSet
 423                 &amp;&amp; !nextContext.hasSelectionPseudo
 424                 &amp;&amp; !(nextContext.hasScrollbarPseudo &amp;&amp; nextContext.selector-&gt;match() == CSSSelector::PseudoClass))
 425                 return MatchResult::fails(Match::SelectorFailsCompletely);
 426 
 427             unsigned subselectorSpecificity = 0;
 428             MatchResult result = matchRecursively(checkingContext, nextContext, dynamicPseudoIdSet, subselectorSpecificity);
 429 
 430             if (result.match == Match::SelectorMatches)
 431                 specificity = CSSSelector::addSpecificities(specificity, subselectorSpecificity);
 432 
 433             return MatchResult::updateWithMatchType(result, matchType);
 434         }
 435     case CSSSelector::ShadowDescendant:
 436         {
<span class="line-modified"> 437             // When matching foo::part(bar) we skip directly to the tree of element &#39;foo&#39;.</span>
<span class="line-modified"> 438             bool isPart = context.selector-&gt;match() == CSSSelector::PseudoElement &amp;&amp; context.selector-&gt;pseudoElementType() == CSSSelector::PseudoElementPart;</span>
<span class="line-added"> 439             auto* shadowHost = isPart ? checkingContext.shadowHostInPartRuleScope : context.element-&gt;shadowHost();</span>
<span class="line-added"> 440             if (!shadowHost)</span>
 441                 return MatchResult::fails(Match::SelectorFailsCompletely);
<span class="line-modified"> 442             nextContext.element = shadowHost;</span>
 443             nextContext.firstSelectorOfTheFragment = nextContext.selector;
 444             nextContext.isSubjectOrAdjacentElement = false;
 445             PseudoIdSet ignoreDynamicPseudo;
 446             unsigned shadowDescendantSpecificity = 0;
 447             MatchResult result = matchRecursively(checkingContext, nextContext, ignoreDynamicPseudo, shadowDescendantSpecificity);
 448 
 449             if (result.match == Match::SelectorMatches)
 450                 specificity = CSSSelector::addSpecificities(specificity, shadowDescendantSpecificity);
 451 
 452             return MatchResult::updateWithMatchType(result, matchType);
 453         }
 454     }
 455 
 456 
 457     ASSERT_NOT_REACHED();
 458     return MatchResult::fails(Match::SelectorFailsCompletely);
 459 }
 460 
 461 static bool attributeValueMatches(const Attribute&amp; attribute, CSSSelector::Match match, const AtomString&amp; selectorValue, bool caseSensitive)
 462 {
</pre>
<hr />
<pre>
 634             return false;
 635     }
 636     return false;
 637 }
 638 
 639 static inline bool tagMatches(const Element&amp; element, const CSSSelector&amp; simpleSelector)
 640 {
 641     const QualifiedName&amp; tagQName = simpleSelector.tagQName();
 642 
 643     if (tagQName == anyQName())
 644         return true;
 645 
 646     const AtomString&amp; localName = (element.isHTMLElement() &amp;&amp; element.document().isHTMLDocument()) ? simpleSelector.tagLowercaseLocalName() : tagQName.localName();
 647 
 648     if (localName != starAtom() &amp;&amp; localName != element.localName())
 649         return false;
 650     const AtomString&amp; namespaceURI = tagQName.namespaceURI();
 651     return namespaceURI == starAtom() || namespaceURI == element.namespaceURI();
 652 }
 653 
<span class="line-modified"> 654 bool SelectorChecker::checkOne(CheckingContext&amp; checkingContext, const LocalContext&amp; context, MatchType&amp; matchType, unsigned&amp; specificity) const</span>
 655 {
 656     const Element&amp; element = *context.element;
 657     const CSSSelector&amp; selector = *context.selector;
 658 
 659     specificity = CSSSelector::addSpecificities(specificity, selector.simpleSelectorSpecificity());
 660 
 661     if (context.mayMatchHostPseudoClass) {
 662         // :host doesn&#39;t combine with anything except pseudo elements.
 663         bool isHostPseudoClass = selector.match() == CSSSelector::PseudoClass &amp;&amp; selector.pseudoClassType() == CSSSelector::PseudoClassHost;
 664         bool isPseudoElement = selector.match() == CSSSelector::PseudoElement;
 665         if (!isHostPseudoClass &amp;&amp; !isPseudoElement)
 666             return false;
 667     }
 668 
 669     if (selector.match() == CSSSelector::Tag)
 670         return tagMatches(element, selector);
 671 
 672     if (selector.match() == CSSSelector::Class)
 673         return element.hasClass() &amp;&amp; element.classNames().contains(selector.value());
 674 
</pre>
<hr />
<pre>
 824                 addStyleRelation(checkingContext, parentElement, backwardRelation);
 825 
 826                 if (!parentElement.isFinishedParsingChildren())
 827                     return false;
 828             } else if (!is&lt;ShadowRoot&gt;(parent))
 829                 break; // FIXME: Add the support for specifying relations on ShadowRoot.
 830             return isFirstOfType(element, element.tagQName()) &amp;&amp; isLastOfType(element, element.tagQName());
 831         }
 832         case CSSSelector::PseudoClassMatches:
 833             {
 834                 bool hasMatchedAnything = false;
 835                 unsigned maxSpecificity = 0;
 836 
 837                 MatchType localMatchType = MatchType::VirtualPseudoElementOnly;
 838                 for (const CSSSelector* subselector = selector.selectorList()-&gt;first(); subselector; subselector = CSSSelectorList::next(subselector)) {
 839                     LocalContext subcontext(context);
 840                     subcontext.inFunctionalPseudoClass = true;
 841                     subcontext.pseudoElementEffective = context.pseudoElementEffective;
 842                     subcontext.selector = subselector;
 843                     subcontext.firstSelectorOfTheFragment = subselector;
<span class="line-added"> 844                     subcontext.pseudoId = PseudoId::None;</span>
 845                     PseudoIdSet localDynamicPseudoIdSet;
 846                     unsigned localSpecificity = 0;
 847                     MatchResult result = matchRecursively(checkingContext, subcontext, localDynamicPseudoIdSet, localSpecificity);
<span class="line-added"> 848 </span>
<span class="line-added"> 849                     // Pseudo elements are not valid inside :matches</span>
<span class="line-added"> 850                     if (localDynamicPseudoIdSet)</span>
<span class="line-added"> 851                         continue;</span>
<span class="line-added"> 852 </span>
 853                     if (result.match == Match::SelectorMatches) {
 854                         maxSpecificity = std::max(maxSpecificity, localSpecificity);
 855 
 856                         if (result.matchType == MatchType::Element)
 857                             localMatchType = MatchType::Element;
 858 

 859                         hasMatchedAnything = true;
 860                     }
 861                 }
 862                 if (hasMatchedAnything) {
 863                     matchType = localMatchType;
 864                     specificity = CSSSelector::addSpecificities(specificity, maxSpecificity);
 865                 }
 866                 return hasMatchedAnything;
 867             }
 868         case CSSSelector::PseudoClassPlaceholderShown:
 869             if (is&lt;HTMLTextFormControlElement&gt;(element)) {
 870                 addStyleRelation(checkingContext, element, Style::Relation::Unique);
 871                 return downcast&lt;HTMLTextFormControlElement&gt;(element).isPlaceholderVisible();
 872             }
 873             return false;
 874         case CSSSelector::PseudoClassNthChild: {
 875             auto* parent = element.parentNode();
 876             if (is&lt;Element&gt;(parent)) {
 877                 auto relation = context.isSubjectOrAdjacentElement ? Style::Relation::ChildrenAffectedByForwardPositionalRules : Style::Relation::DescendantsAffectedByForwardPositionalRules;
 878                 addStyleRelation(checkingContext, downcast&lt;Element&gt;(*parent), relation);
</pre>
<hr />
<pre>
 979                 }
 980             }
 981             break;
 982         case CSSSelector::PseudoClassAutofill:
 983             return isAutofilled(element);
 984         case CSSSelector::PseudoClassAutofillStrongPassword:
 985             return isAutofilledStrongPassword(element);
 986         case CSSSelector::PseudoClassAutofillStrongPasswordViewable:
 987             return isAutofilledStrongPasswordViewable(element);
 988         case CSSSelector::PseudoClassAnyLink:
 989         case CSSSelector::PseudoClassAnyLinkDeprecated:
 990         case CSSSelector::PseudoClassLink:
 991             // :visited and :link matches are separated later when applying the style. Here both classes match all links...
 992             return element.isLink();
 993         case CSSSelector::PseudoClassVisited:
 994             // ...except if :visited matching is disabled for ancestor/sibling matching.
 995             // Inside functional pseudo class except for :not, :visited never matches.
 996             if (context.inFunctionalPseudoClass)
 997                 return false;
 998             return element.isLink() &amp;&amp; context.visitedMatchType == VisitedMatchType::Enabled;
<span class="line-added"> 999         case CSSSelector::PseudoClassDirectFocus:</span>
<span class="line-added">1000             return matchesDirectFocusPseudoClass(element);</span>
1001         case CSSSelector::PseudoClassDrag:
1002             addStyleRelation(checkingContext, element, Style::Relation::AffectedByDrag);
1003 
1004             if (element.renderer() &amp;&amp; element.renderer()-&gt;isDragging())
1005                 return true;
1006             break;
1007         case CSSSelector::PseudoClassFocus:
1008             return matchesFocusPseudoClass(element);
1009         case CSSSelector::PseudoClassFocusWithin:
1010             addStyleRelation(checkingContext, element, Style::Relation::AffectedByFocusWithin);
1011             return element.hasFocusWithin();
1012         case CSSSelector::PseudoClassHover:
1013             if (m_strictParsing || element.isLink() || canMatchHoverOrActiveInQuirksMode(context)) {
1014                 addStyleRelation(checkingContext, element, Style::Relation::AffectedByHover);
1015 
1016                 // See the comment in generateElementIsHovered() in SelectorCompiler.
1017                 if (checkingContext.resolvingMode == SelectorChecker::Mode::CollectingRulesIgnoringVirtualPseudoElements &amp;&amp; !context.isMatchElement)
1018                     return true;
1019 
1020                 if (element.hovered() || InspectorInstrumentation::forcePseudoState(element, CSSSelector::PseudoClassHover))
</pre>
<hr />
<pre>
1042         case CSSSelector::PseudoClassReadWrite:
1043             return matchesReadWritePseudoClass(element);
1044         case CSSSelector::PseudoClassOptional:
1045             return isOptionalFormControl(element);
1046         case CSSSelector::PseudoClassRequired:
1047             return isRequiredFormControl(element);
1048         case CSSSelector::PseudoClassValid:
1049             return isValid(element);
1050         case CSSSelector::PseudoClassInvalid:
1051             return isInvalid(element);
1052         case CSSSelector::PseudoClassChecked:
1053             return isChecked(element);
1054         case CSSSelector::PseudoClassIndeterminate:
1055             return matchesIndeterminatePseudoClass(element);
1056         case CSSSelector::PseudoClassRoot:
1057             if (&amp;element == element.document().documentElement())
1058                 return true;
1059             break;
1060         case CSSSelector::PseudoClassLang:
1061             {
<span class="line-modified">1062                 ASSERT(selector.argumentList() &amp;&amp; !selector.argumentList()-&gt;isEmpty());</span>
<span class="line-modified">1063                 return matchesLangPseudoClass(element, *selector.argumentList());</span>
1064             }
1065 #if ENABLE(FULLSCREEN_API)
1066         case CSSSelector::PseudoClassFullScreen:
1067             return matchesFullScreenPseudoClass(element);
1068         case CSSSelector::PseudoClassAnimatingFullScreenTransition:
1069             return matchesFullScreenAnimatingFullScreenTransitionPseudoClass(element);
1070         case CSSSelector::PseudoClassFullScreenAncestor:
1071             return matchesFullScreenAncestorPseudoClass(element);
1072         case CSSSelector::PseudoClassFullScreenDocument:
1073             return matchesFullScreenDocumentPseudoClass(element);
1074         case CSSSelector::PseudoClassFullScreenControlsHidden:
1075             return matchesFullScreenControlsHiddenPseudoClass(element);
<span class="line-added">1076 #endif</span>
<span class="line-added">1077 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">1078         case CSSSelector::PseudoClassPictureInPicture:</span>
<span class="line-added">1079             return matchesPictureInPicturePseudoClass(element);</span>
1080 #endif
1081         case CSSSelector::PseudoClassInRange:
1082             return isInRange(element);
1083         case CSSSelector::PseudoClassOutOfRange:
1084             return isOutOfRange(element);
1085 #if ENABLE(VIDEO_TRACK)
1086         case CSSSelector::PseudoClassFuture:
1087             return matchesFutureCuePseudoClass(element);
1088         case CSSSelector::PseudoClassPast:
1089             return matchesPastCuePseudoClass(element);
1090 #endif
1091 
1092         case CSSSelector::PseudoClassScope: {
1093             const Node* contextualReferenceNode = !checkingContext.scope ? element.document().documentElement() : checkingContext.scope;
1094             if (&amp;element == contextualReferenceNode)
1095                 return true;
1096             break;
1097         }
1098         case CSSSelector::PseudoClassHost: {
1099             if (!context.mayMatchHostPseudoClass)
</pre>
<hr />
<pre>
1125         // FIXME: Implement :dir() selector.
1126         case CSSSelector::PseudoClassDir:
1127             return false;
1128 
1129         // FIXME: Implement :role() selector.
1130         case CSSSelector::PseudoClassRole:
1131             return false;
1132 #endif
1133 
1134 #if ENABLE(ATTACHMENT_ELEMENT)
1135         case CSSSelector::PseudoClassHasAttachment:
1136             return hasAttachment(element);
1137 #endif
1138 
1139         case CSSSelector::PseudoClassUnknown:
1140             ASSERT_NOT_REACHED();
1141             break;
1142         }
1143         return false;
1144     }
<span class="line-added">1145 </span>
<span class="line-added">1146     if (selector.match() == CSSSelector::PseudoElement) {</span>
<span class="line-added">1147         switch (selector.pseudoElementType()) {</span>
1148 #if ENABLE(VIDEO_TRACK)
<span class="line-modified">1149         case CSSSelector::PseudoElementCue: {</span>
<span class="line-modified">1150             LocalContext subcontext(context);</span>
1151 
<span class="line-modified">1152             const CSSSelector* const &amp; selector = context.selector;</span>
<span class="line-modified">1153             for (subcontext.selector = selector-&gt;selectorList()-&gt;first(); subcontext.selector; subcontext.selector = CSSSelectorList::next(subcontext.selector)) {</span>
<span class="line-modified">1154                 subcontext.firstSelectorOfTheFragment = subcontext.selector;</span>
<span class="line-modified">1155                 subcontext.inFunctionalPseudoClass = true;</span>
<span class="line-modified">1156                 subcontext.pseudoElementEffective = false;</span>
<span class="line-modified">1157                 PseudoIdSet ignoredDynamicPseudo;</span>
<span class="line-modified">1158                 unsigned ignoredSpecificity = 0;</span>
<span class="line-modified">1159                 if (matchRecursively(checkingContext, subcontext, ignoredDynamicPseudo, ignoredSpecificity).match == Match::SelectorMatches)</span>
<span class="line-modified">1160                     return true;</span>
<span class="line-added">1161             }</span>
<span class="line-added">1162             return false;</span>
1163         }


1164 #endif
<span class="line-modified">1165         case CSSSelector::PseudoElementSlotted:</span>
<span class="line-modified">1166             // We see ::slotted() pseudo elements when collecting slotted rules from the slot shadow tree only.</span>
<span class="line-modified">1167             ASSERT(checkingContext.resolvingMode == Mode::CollectingRules);</span>
<span class="line-modified">1168             return is&lt;HTMLSlotElement&gt;(element);</span>
<span class="line-added">1169 </span>
<span class="line-added">1170         case CSSSelector::PseudoElementPart: {</span>
<span class="line-added">1171             auto translatePartNameToRuleScope = [&amp;](AtomString partName) {</span>
<span class="line-added">1172                 Vector&lt;AtomString, 1&gt; mappedNames { partName };</span>
<span class="line-added">1173                 for (auto* shadowRoot = element.containingShadowRoot(); shadowRoot; shadowRoot = shadowRoot-&gt;host()-&gt;containingShadowRoot()) {</span>
<span class="line-added">1174                     // Apply mappings up to the scope the rules are coming from.</span>
<span class="line-added">1175                     if (shadowRoot-&gt;host() == checkingContext.shadowHostInPartRuleScope)</span>
<span class="line-added">1176                         break;</span>
<span class="line-added">1177 </span>
<span class="line-added">1178                     Vector&lt;AtomString, 1&gt; newMappedNames;</span>
<span class="line-added">1179                     for (auto&amp; name : mappedNames)</span>
<span class="line-added">1180                         newMappedNames.appendVector(shadowRoot-&gt;partMappings().get(name));</span>
<span class="line-added">1181                     mappedNames = newMappedNames;</span>
<span class="line-added">1182 </span>
<span class="line-added">1183                     if (mappedNames.isEmpty())</span>
<span class="line-added">1184                         break;</span>
<span class="line-added">1185                 }</span>
<span class="line-added">1186                 return mappedNames;</span>
<span class="line-added">1187             };</span>
<span class="line-added">1188 </span>
<span class="line-added">1189             Vector&lt;AtomString, 4&gt; translatedPartNames;</span>
<span class="line-added">1190             for (unsigned i = 0; i &lt; element.partNames().size(); ++i)</span>
<span class="line-added">1191                 translatedPartNames.appendVector(translatePartNameToRuleScope(element.partNames()[i]));</span>
<span class="line-added">1192 </span>
<span class="line-added">1193             for (auto&amp; part : *selector.argumentList()) {</span>
<span class="line-added">1194                 if (!translatedPartNames.contains(part))</span>
<span class="line-added">1195                     return false;</span>
<span class="line-added">1196             }</span>
<span class="line-added">1197             return true;</span>
<span class="line-added">1198         }</span>
<span class="line-added">1199 </span>
<span class="line-added">1200         case CSSSelector::PseudoElementHighlight:</span>
<span class="line-added">1201             // Always matches when not specifically requested so it gets added to the pseudoIdSet.</span>
<span class="line-added">1202             if (checkingContext.pseudoId == PseudoId::None)</span>
<span class="line-added">1203                 return true;</span>
<span class="line-added">1204             if (checkingContext.pseudoId != PseudoId::Highlight)</span>
<span class="line-added">1205                 return false;</span>
<span class="line-added">1206             return selector.argumentList()-&gt;first() == checkingContext.nameForHightlightPseudoElement;</span>
<span class="line-added">1207 </span>
<span class="line-added">1208         default:</span>
<span class="line-added">1209             return true;</span>
<span class="line-added">1210         }</span>
1211     }
1212     return true;
1213 }
1214 
1215 bool SelectorChecker::matchSelectorList(CheckingContext&amp; checkingContext, const LocalContext&amp; context, const Element&amp; element, const CSSSelectorList&amp; selectorList, unsigned&amp; specificity) const
1216 {
1217     specificity = 0;
1218     bool hasMatchedAnything = false;
1219 
1220     for (const CSSSelector* subselector = selectorList.first(); subselector; subselector = CSSSelectorList::next(subselector)) {
1221         LocalContext subcontext(context);
1222         subcontext.element = &amp;element;
1223         subcontext.selector = subselector;
1224         subcontext.inFunctionalPseudoClass = true;
1225         subcontext.pseudoElementEffective = false;
1226         subcontext.firstSelectorOfTheFragment = subselector;
1227         PseudoIdSet ignoreDynamicPseudo;
1228         unsigned localSpecificity = 0;
1229         if (matchRecursively(checkingContext, subcontext, ignoreDynamicPseudo, localSpecificity).match == Match::SelectorMatches) {
1230             ASSERT(!ignoreDynamicPseudo);
</pre>
<hr />
<pre>
1294             default:
1295                 break;
1296             }
1297         }
1298         auto relation = selector-&gt;relation();
1299         if (relation == CSSSelector::Subselector)
1300             continue;
1301         if (!selector-&gt;hasDescendantOrChildRelation())
1302             return linkMatchType;
1303         if (linkMatchType != MatchAll)
1304             return linkMatchType;
1305     }
1306     return linkMatchType;
1307 }
1308 
1309 static bool isFrameFocused(const Element&amp; element)
1310 {
1311     return element.document().frame() &amp;&amp; element.document().frame()-&gt;selection().isFocusedAndActive();
1312 }
1313 
<span class="line-added">1314 static bool doesShadowTreeContainFocusedElement(const Element&amp; element)</span>
<span class="line-added">1315 {</span>
<span class="line-added">1316     auto* shadowRoot = element.shadowRoot();</span>
<span class="line-added">1317     return shadowRoot &amp;&amp; shadowRoot-&gt;containsFocusedElement();</span>
<span class="line-added">1318 }</span>
<span class="line-added">1319 </span>
1320 bool SelectorChecker::matchesFocusPseudoClass(const Element&amp; element)
1321 {
1322     if (InspectorInstrumentation::forcePseudoState(element, CSSSelector::PseudoClassFocus))
1323         return true;
<span class="line-added">1324 </span>
<span class="line-added">1325     return (element.focused() || doesShadowTreeContainFocusedElement(element)) &amp;&amp; isFrameFocused(element);</span>
<span class="line-added">1326 }</span>
<span class="line-added">1327 </span>
<span class="line-added">1328 // This needs to match a subset of elements matchesFocusPseudoClass match since direct focus is treated</span>
<span class="line-added">1329 // as a part of focus pseudo class selectors in ElementRuleCollector::collectMatchingRules.</span>
<span class="line-added">1330 bool SelectorChecker::matchesDirectFocusPseudoClass(const Element&amp; element)</span>
<span class="line-added">1331 {</span>
<span class="line-added">1332     if (InspectorInstrumentation::forcePseudoState(element, CSSSelector::PseudoClassFocus))</span>
<span class="line-added">1333         return true;</span>
<span class="line-added">1334 </span>
1335     return element.focused() &amp;&amp; isFrameFocused(element);
1336 }
1337 
1338 }
</pre>
</td>
</tr>
</table>
<center><a href="SVGCSSComputedStyleDeclaration.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorChecker.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
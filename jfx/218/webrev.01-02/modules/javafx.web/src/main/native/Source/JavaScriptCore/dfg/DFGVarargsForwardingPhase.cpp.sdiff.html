<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVarargsForwardingPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGValidate.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGVariableAccessData.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVarargsForwardingPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGVarargsForwardingPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;ClonedArguments.h&quot;
 32 #include &quot;DFGArgumentsUtilities.h&quot;
 33 #include &quot;DFGClobberize.h&quot;
 34 #include &quot;DFGForAllKills.h&quot;
 35 #include &quot;DFGGraph.h&quot;
 36 #include &quot;DFGPhase.h&quot;
 37 #include &quot;JSCInlines.h&quot;
 38 #include &lt;wtf/ListDump.h&gt;
 39 
 40 namespace JSC { namespace DFG {
 41 
 42 namespace {
 43 
<span class="line-removed"> 44 namespace DFGVarargsForwardingPhaseInternal {</span>
<span class="line-removed"> 45 static const bool verbose = false;</span>
<span class="line-removed"> 46 }</span>
 47 
 48 class VarargsForwardingPhase : public Phase {

 49 public:
 50     VarargsForwardingPhase(Graph&amp; graph)
 51         : Phase(graph, &quot;varargs forwarding&quot;)
 52     {
 53     }
 54 
 55     bool run()
 56     {
 57         DFG_ASSERT(m_graph, nullptr, m_graph.m_form != SSA);
 58 
<span class="line-modified"> 59         if (DFGVarargsForwardingPhaseInternal::verbose) {</span>
 60             dataLog(&quot;Graph before varargs forwarding:\n&quot;);
 61             m_graph.dump();
 62         }
 63 
 64         m_changed = false;
 65         for (BasicBlock* block : m_graph.blocksInNaturalOrder())
 66             handleBlock(block);
 67         return m_changed;
 68     }
 69 
 70 private:
 71     void handleBlock(BasicBlock* block)
 72     {
 73         for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
 74             Node* node = block-&gt;at(nodeIndex);
 75             switch (node-&gt;op()) {
 76             case CreateDirectArguments:
 77             case CreateClonedArguments:
 78                 handleCandidate(block, nodeIndex);
 79                 break;
 80             default:
 81                 break;
 82             }
 83         }
 84     }
 85 
 86     void handleCandidate(BasicBlock* block, unsigned candidateNodeIndex)
 87     {
 88         // We expect calls into this function to be rare. So, this is written in a simple O(n) manner.
 89 
 90         Node* candidate = block-&gt;at(candidateNodeIndex);
<span class="line-modified"> 91         if (DFGVarargsForwardingPhaseInternal::verbose)</span>
 92             dataLog(&quot;Handling candidate &quot;, candidate, &quot;\n&quot;);
 93 
 94         // We eliminate GetButterfly over CreateClonedArguments if the butterfly is only
 95         // used by a GetByOffset  that loads the CreateClonedArguments&#39;s length. We also
 96         // eliminate it if the GetButterfly node is totally unused.
 97         Vector&lt;Node*, 1&gt; candidateButterflies;
 98 
 99         // Find the index of the last node in this block to use the candidate, and look for escaping
100         // sites.
101         unsigned lastUserIndex = candidateNodeIndex;
102         Vector&lt;VirtualRegister, 2&gt; relevantLocals; // This is a set. We expect it to be a small set.
103         for (unsigned nodeIndex = candidateNodeIndex + 1; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
104             Node* node = block-&gt;at(nodeIndex);
105 
106             auto defaultEscape = [&amp;] {
107                 if (m_graph.uses(node, candidate)) {
<span class="line-modified">108                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
109                         dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
110                     return true;
111                 }
112                 return false;
113             };
114 
115             bool validGetByOffset = false;
116             switch (node-&gt;op()) {
117             case MovHint:
118                 if (node-&gt;child1() != candidate)
119                     break;

120                 lastUserIndex = nodeIndex;
<span class="line-modified">121                 if (!relevantLocals.contains(node-&gt;unlinkedLocal()))</span>
<span class="line-modified">122                     relevantLocals.append(node-&gt;unlinkedLocal());</span>
123                 break;
124 
125             case CheckVarargs:
126             case Check: {
127                 bool sawEscape = false;
128                 m_graph.doToChildren(
129                     node,
130                     [&amp;] (Edge edge) {
131                         if (edge == candidate)
132                             lastUserIndex = nodeIndex;
133 
134                         if (edge.willNotHaveCheck())
135                             return;
136 
137                         if (alreadyChecked(edge.useKind(), SpecObject))
138                             return;
139 
140                         sawEscape = true;
141                     });
142                 if (sawEscape) {
<span class="line-modified">143                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
144                         dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
145                     return;
146                 }
147                 break;
148             }
149 

150             case LoadVarargs:
151                 if (m_graph.uses(node, candidate))
152                     lastUserIndex = nodeIndex;
153                 break;
154 
155             case CallVarargs:
156             case ConstructVarargs:
157             case TailCallVarargs:
158             case TailCallVarargsInlinedCaller:
159                 if (node-&gt;child1() == candidate || node-&gt;child2() == candidate) {
<span class="line-modified">160                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
161                         dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
162                     return;
163                 }
164                 if (node-&gt;child2() == candidate)
165                     lastUserIndex = nodeIndex;
166                 break;
167 
168             case SetLocal:
169                 if (node-&gt;child1() == candidate &amp;&amp; node-&gt;variableAccessData()-&gt;isLoadedFrom()) {
<span class="line-modified">170                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
171                         dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
172                     return;
173                 }
174                 break;
175 
176             case GetArrayLength: {
177                 if (node-&gt;arrayMode().type() == Array::DirectArguments &amp;&amp; node-&gt;child1() == candidate &amp;&amp; node-&gt;child1()-&gt;op() == CreateDirectArguments) {
178                     lastUserIndex = nodeIndex;
179                     break;
180                 }
181                 if (defaultEscape())
182                     return;
183                 break;
184             }
185 
186             case GetButterfly: {
187                 if (node-&gt;child1() == candidate &amp;&amp; candidate-&gt;op() == CreateClonedArguments) {
188                     lastUserIndex = nodeIndex;
189                     candidateButterflies.append(node);
190                     break;
191                 }
192                 if (defaultEscape())
193                     return;
194                 break;
195             }
196 
<span class="line-modified">197             case FilterGetByIdStatus:</span>
198             case FilterPutByIdStatus:
199             case FilterCallLinkStatus:
200             case FilterInByIdStatus:
201                 break;
202 
203             case GetByOffset: {
204                 if (node-&gt;child1()-&gt;op() == GetButterfly
205                     &amp;&amp; candidateButterflies.contains(node-&gt;child1().node())
206                     &amp;&amp; node-&gt;child2() == candidate
207                     &amp;&amp; node-&gt;storageAccessData().offset == clonedArgumentsLengthPropertyOffset) {
208                     ASSERT(node-&gt;child1()-&gt;child1() == candidate);
209                     ASSERT(isOutOfLineOffset(clonedArgumentsLengthPropertyOffset));
210                     // We&#39;re good to go. This is getting the length of the arguments.
211                     lastUserIndex = nodeIndex;
212                     validGetByOffset = true;
213                     break;
214                 }
215                 if (defaultEscape())
216                     return;
217                 break;
218             }
219 
220             default:
221                 if (defaultEscape())
222                     return;
223                 break;
224             }
225 
226             if (!validGetByOffset) {
227                 for (Node* butterfly : candidateButterflies) {
228                     if (m_graph.uses(node, butterfly)) {
<span class="line-modified">229                         if (DFGVarargsForwardingPhaseInternal::verbose)</span>
230                             dataLog(&quot;    Butterfly escaped at &quot;, node, &quot;\n&quot;);
231                         return;
232                     }
233                 }
234             }
235 
236             forAllKilledOperands(
237                 m_graph, node, block-&gt;tryAt(nodeIndex + 1),
<span class="line-modified">238                 [&amp;] (VirtualRegister reg) {</span>
<span class="line-modified">239                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
<span class="line-modified">240                         dataLog(&quot;    Killing &quot;, reg, &quot; while we are interested in &quot;, listDump(relevantLocals), &quot;\n&quot;);</span>
241                     for (unsigned i = 0; i &lt; relevantLocals.size(); ++i) {
<span class="line-modified">242                         if (relevantLocals[i] == reg) {</span>
243                             relevantLocals[i--] = relevantLocals.last();
244                             relevantLocals.removeLast();
245                             lastUserIndex = nodeIndex;
246                         }
247                     }
248                 });
249         }
<span class="line-modified">250         if (DFGVarargsForwardingPhaseInternal::verbose)</span>
251             dataLog(&quot;Selected lastUserIndex = &quot;, lastUserIndex, &quot;, &quot;, block-&gt;at(lastUserIndex), &quot;\n&quot;);
252 
253         // We&#39;re still in business. Determine if between the candidate and the last user there is any
254         // effect that could interfere with sinking.
255         for (unsigned nodeIndex = candidateNodeIndex + 1; nodeIndex &lt;= lastUserIndex; ++nodeIndex) {
256             Node* node = block-&gt;at(nodeIndex);
257 
258             // We have our own custom switch to detect some interferences that clobberize() wouldn&#39;t know
259             // about, and also some of the common ones, too. In particular, clobberize() doesn&#39;t know
260             // that Flush, MovHint, ZombieHint, and KillStack are bad because it&#39;s not worried about
261             // what gets read on OSR exit.
262             switch (node-&gt;op()) {
263             case MovHint:
264             case ZombieHint:
265             case KillStack:
<span class="line-modified">266                 if (argumentsInvolveStackSlot(candidate, node-&gt;unlinkedLocal())) {</span>
<span class="line-modified">267                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
268                         dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
269                     return;
270                 }
271                 break;
272 
273             case PutStack:
<span class="line-modified">274                 if (argumentsInvolveStackSlot(candidate, node-&gt;stackAccessData()-&gt;local)) {</span>
<span class="line-modified">275                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
276                         dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
277                     return;
278                 }
279                 break;
280 
281             case SetLocal:
282             case Flush:
<span class="line-modified">283                 if (argumentsInvolveStackSlot(candidate, node-&gt;local())) {</span>
<span class="line-modified">284                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
285                         dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
286                     return;
287                 }
288                 break;
289 
290             default: {
291                 bool doesInterfere = false;
292                 clobberize(
293                     m_graph, node, NoOpClobberize(),
294                     [&amp;] (AbstractHeap heap) {
295                         if (heap.kind() != Stack) {
296                             ASSERT(!heap.overlaps(Stack));
297                             return;
298                         }
299                         ASSERT(!heap.payload().isTop());
<span class="line-modified">300                         VirtualRegister reg(heap.payload().value32());</span>
<span class="line-removed">301                         if (argumentsInvolveStackSlot(candidate, reg))</span>
302                             doesInterfere = true;
303                     },
304                     NoOpClobberize());
305                 if (doesInterfere) {
<span class="line-modified">306                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
307                         dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
308                     return;
309                 }
310             } }
311         }
312 
313         // We can make this work.
<span class="line-modified">314         if (DFGVarargsForwardingPhaseInternal::verbose)</span>
315             dataLog(&quot;    Will do forwarding!\n&quot;);
316         m_changed = true;
317 
318         // Transform the program.
319         switch (candidate-&gt;op()) {
320         case CreateDirectArguments:
321             candidate-&gt;setOpAndDefaultFlags(PhantomDirectArguments);
322             break;
323 
324         case CreateClonedArguments:
325             candidate-&gt;setOpAndDefaultFlags(PhantomClonedArguments);
326             break;
327 
328         default:
329             DFG_CRASH(m_graph, candidate, &quot;bad node type&quot;);
330             break;
331         }
332 
333         InsertionSet insertionSet(m_graph);
334         for (unsigned nodeIndex = candidateNodeIndex + 1; nodeIndex &lt;= lastUserIndex; ++nodeIndex) {
335             Node* node = block-&gt;at(nodeIndex);
336             switch (node-&gt;op()) {
337             case Check:
338             case CheckVarargs:
339             case MovHint:
340             case PutHint:
341                 // We don&#39;t need to change anything with these.
342                 break;
343 








344             case LoadVarargs:
<span class="line-modified">345                 if (node-&gt;child1() != candidate)</span>
346                     break;
347                 node-&gt;setOpAndDefaultFlags(ForwardVarargs);
348                 break;
349 
350             case CallVarargs:
351                 if (node-&gt;child3() != candidate)
352                     break;
353                 node-&gt;setOpAndDefaultFlags(CallForwardVarargs);
354                 break;
355 
356             case ConstructVarargs:
357                 if (node-&gt;child3() != candidate)
358                     break;
359                 node-&gt;setOpAndDefaultFlags(ConstructForwardVarargs);
360                 break;
361 
362             case TailCallVarargs:
363                 if (node-&gt;child3() != candidate)
364                     break;
365                 node-&gt;setOpAndDefaultFlags(TailCallForwardVarargs);
</pre>
<hr />
<pre>
371                 node-&gt;setOpAndDefaultFlags(TailCallForwardVarargsInlinedCaller);
372                 break;
373 
374             case SetLocal:
375                 // This is super odd. We don&#39;t have to do anything here, since in DFG IR, the phantom
376                 // arguments nodes do produce a JSValue. Also, we know that if this SetLocal referenecs a
377                 // candidate then the SetLocal - along with all of its references - will die off pretty
378                 // soon, since it has no real users. DCE will surely kill it. If we make it to SSA, then
379                 // SSA conversion will kill it.
380                 break;
381 
382             case GetButterfly: {
383                 if (node-&gt;child1().node() == candidate) {
384                     ASSERT(candidateButterflies.contains(node));
385                     node-&gt;child1() = Edge();
386                     node-&gt;remove(m_graph);
387                 }
388                 break;
389             }
390 
<span class="line-modified">391             case FilterGetByIdStatus:</span>
392             case FilterPutByIdStatus:
393             case FilterCallLinkStatus:
394             case FilterInByIdStatus:
395                 if (node-&gt;child1().node() == candidate)
396                     node-&gt;remove(m_graph);
397                 break;
398 
399             case GetByOffset: {
400                 if (node-&gt;child2() == candidate) {
401                     ASSERT(candidateButterflies.contains(node-&gt;child1().node())); // It&#39;s no longer a GetButterfly node, but it should&#39;ve been a candidate butterfly.
402                     ASSERT(node-&gt;storageAccessData().offset == clonedArgumentsLengthPropertyOffset);
403                     node-&gt;convertToIdentityOn(
404                         emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, node-&gt;origin));
405                 }
406                 break;
407             }
408 
409             case GetArrayLength:
410                 if (node-&gt;arrayMode().type() == Array::DirectArguments &amp;&amp; node-&gt;child1() == candidate) {
411                     node-&gt;convertToIdentityOn(
412                         emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, node-&gt;origin));
413                 }
414                 break;
415 
416             default:
<span class="line-modified">417                 if (ASSERT_DISABLED)</span>
418                     break;
419                 m_graph.doToChildren(
420                     node,
421                     [&amp;] (Edge edge) {
422                         DFG_ASSERT(m_graph, node, edge != candidate);
423                     });
424                 break;
425             }
426         }
427 
428         insertionSet.execute(block);
429     }
430 
431     bool m_changed;
432 };
433 
434 } // anonymous namespace
435 
436 bool performVarargsForwarding(Graph&amp; graph)
437 {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGVarargsForwardingPhase.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;ClonedArguments.h&quot;
 32 #include &quot;DFGArgumentsUtilities.h&quot;
 33 #include &quot;DFGClobberize.h&quot;
 34 #include &quot;DFGForAllKills.h&quot;
 35 #include &quot;DFGGraph.h&quot;
 36 #include &quot;DFGPhase.h&quot;
 37 #include &quot;JSCInlines.h&quot;
 38 #include &lt;wtf/ListDump.h&gt;
 39 
 40 namespace JSC { namespace DFG {
 41 
 42 namespace {
 43 



 44 
 45 class VarargsForwardingPhase : public Phase {
<span class="line-added"> 46     static constexpr bool verbose = false;</span>
 47 public:
 48     VarargsForwardingPhase(Graph&amp; graph)
 49         : Phase(graph, &quot;varargs forwarding&quot;)
 50     {
 51     }
 52 
 53     bool run()
 54     {
 55         DFG_ASSERT(m_graph, nullptr, m_graph.m_form != SSA);
 56 
<span class="line-modified"> 57         if (verbose) {</span>
 58             dataLog(&quot;Graph before varargs forwarding:\n&quot;);
 59             m_graph.dump();
 60         }
 61 
 62         m_changed = false;
 63         for (BasicBlock* block : m_graph.blocksInNaturalOrder())
 64             handleBlock(block);
 65         return m_changed;
 66     }
 67 
 68 private:
 69     void handleBlock(BasicBlock* block)
 70     {
 71         for (unsigned nodeIndex = 0; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
 72             Node* node = block-&gt;at(nodeIndex);
 73             switch (node-&gt;op()) {
 74             case CreateDirectArguments:
 75             case CreateClonedArguments:
 76                 handleCandidate(block, nodeIndex);
 77                 break;
 78             default:
 79                 break;
 80             }
 81         }
 82     }
 83 
 84     void handleCandidate(BasicBlock* block, unsigned candidateNodeIndex)
 85     {
 86         // We expect calls into this function to be rare. So, this is written in a simple O(n) manner.
 87 
 88         Node* candidate = block-&gt;at(candidateNodeIndex);
<span class="line-modified"> 89         if (verbose)</span>
 90             dataLog(&quot;Handling candidate &quot;, candidate, &quot;\n&quot;);
 91 
 92         // We eliminate GetButterfly over CreateClonedArguments if the butterfly is only
 93         // used by a GetByOffset  that loads the CreateClonedArguments&#39;s length. We also
 94         // eliminate it if the GetButterfly node is totally unused.
 95         Vector&lt;Node*, 1&gt; candidateButterflies;
 96 
 97         // Find the index of the last node in this block to use the candidate, and look for escaping
 98         // sites.
 99         unsigned lastUserIndex = candidateNodeIndex;
100         Vector&lt;VirtualRegister, 2&gt; relevantLocals; // This is a set. We expect it to be a small set.
101         for (unsigned nodeIndex = candidateNodeIndex + 1; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
102             Node* node = block-&gt;at(nodeIndex);
103 
104             auto defaultEscape = [&amp;] {
105                 if (m_graph.uses(node, candidate)) {
<span class="line-modified">106                     if (verbose)</span>
107                         dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
108                     return true;
109                 }
110                 return false;
111             };
112 
113             bool validGetByOffset = false;
114             switch (node-&gt;op()) {
115             case MovHint:
116                 if (node-&gt;child1() != candidate)
117                     break;
<span class="line-added">118                 ASSERT_WITH_MESSAGE(!node-&gt;unlinkedOperand().isTmp(), &quot;We don&#39;t currently support a tmp referring to an arguments object.&quot;);</span>
119                 lastUserIndex = nodeIndex;
<span class="line-modified">120                 if (!relevantLocals.contains(node-&gt;unlinkedOperand().virtualRegister()))</span>
<span class="line-modified">121                     relevantLocals.append(node-&gt;unlinkedOperand().virtualRegister());</span>
122                 break;
123 
124             case CheckVarargs:
125             case Check: {
126                 bool sawEscape = false;
127                 m_graph.doToChildren(
128                     node,
129                     [&amp;] (Edge edge) {
130                         if (edge == candidate)
131                             lastUserIndex = nodeIndex;
132 
133                         if (edge.willNotHaveCheck())
134                             return;
135 
136                         if (alreadyChecked(edge.useKind(), SpecObject))
137                             return;
138 
139                         sawEscape = true;
140                     });
141                 if (sawEscape) {
<span class="line-modified">142                     if (verbose)</span>
143                         dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
144                     return;
145                 }
146                 break;
147             }
148 
<span class="line-added">149             case VarargsLength:</span>
150             case LoadVarargs:
151                 if (m_graph.uses(node, candidate))
152                     lastUserIndex = nodeIndex;
153                 break;
154 
155             case CallVarargs:
156             case ConstructVarargs:
157             case TailCallVarargs:
158             case TailCallVarargsInlinedCaller:
159                 if (node-&gt;child1() == candidate || node-&gt;child2() == candidate) {
<span class="line-modified">160                     if (verbose)</span>
161                         dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
162                     return;
163                 }
164                 if (node-&gt;child2() == candidate)
165                     lastUserIndex = nodeIndex;
166                 break;
167 
168             case SetLocal:
169                 if (node-&gt;child1() == candidate &amp;&amp; node-&gt;variableAccessData()-&gt;isLoadedFrom()) {
<span class="line-modified">170                     if (verbose)</span>
171                         dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
172                     return;
173                 }
174                 break;
175 
176             case GetArrayLength: {
177                 if (node-&gt;arrayMode().type() == Array::DirectArguments &amp;&amp; node-&gt;child1() == candidate &amp;&amp; node-&gt;child1()-&gt;op() == CreateDirectArguments) {
178                     lastUserIndex = nodeIndex;
179                     break;
180                 }
181                 if (defaultEscape())
182                     return;
183                 break;
184             }
185 
186             case GetButterfly: {
187                 if (node-&gt;child1() == candidate &amp;&amp; candidate-&gt;op() == CreateClonedArguments) {
188                     lastUserIndex = nodeIndex;
189                     candidateButterflies.append(node);
190                     break;
191                 }
192                 if (defaultEscape())
193                     return;
194                 break;
195             }
196 
<span class="line-modified">197             case FilterGetByStatus:</span>
198             case FilterPutByIdStatus:
199             case FilterCallLinkStatus:
200             case FilterInByIdStatus:
201                 break;
202 
203             case GetByOffset: {
204                 if (node-&gt;child1()-&gt;op() == GetButterfly
205                     &amp;&amp; candidateButterflies.contains(node-&gt;child1().node())
206                     &amp;&amp; node-&gt;child2() == candidate
207                     &amp;&amp; node-&gt;storageAccessData().offset == clonedArgumentsLengthPropertyOffset) {
208                     ASSERT(node-&gt;child1()-&gt;child1() == candidate);
209                     ASSERT(isOutOfLineOffset(clonedArgumentsLengthPropertyOffset));
210                     // We&#39;re good to go. This is getting the length of the arguments.
211                     lastUserIndex = nodeIndex;
212                     validGetByOffset = true;
213                     break;
214                 }
215                 if (defaultEscape())
216                     return;
217                 break;
218             }
219 
220             default:
221                 if (defaultEscape())
222                     return;
223                 break;
224             }
225 
226             if (!validGetByOffset) {
227                 for (Node* butterfly : candidateButterflies) {
228                     if (m_graph.uses(node, butterfly)) {
<span class="line-modified">229                         if (verbose)</span>
230                             dataLog(&quot;    Butterfly escaped at &quot;, node, &quot;\n&quot;);
231                         return;
232                     }
233                 }
234             }
235 
236             forAllKilledOperands(
237                 m_graph, node, block-&gt;tryAt(nodeIndex + 1),
<span class="line-modified">238                 [&amp;] (Operand operand) {</span>
<span class="line-modified">239                     if (verbose)</span>
<span class="line-modified">240                         dataLog(&quot;    Killing &quot;, operand, &quot; while we are interested in &quot;, listDump(relevantLocals), &quot;\n&quot;);</span>
241                     for (unsigned i = 0; i &lt; relevantLocals.size(); ++i) {
<span class="line-modified">242                         if (operand == relevantLocals[i]) {</span>
243                             relevantLocals[i--] = relevantLocals.last();
244                             relevantLocals.removeLast();
245                             lastUserIndex = nodeIndex;
246                         }
247                     }
248                 });
249         }
<span class="line-modified">250         if (verbose)</span>
251             dataLog(&quot;Selected lastUserIndex = &quot;, lastUserIndex, &quot;, &quot;, block-&gt;at(lastUserIndex), &quot;\n&quot;);
252 
253         // We&#39;re still in business. Determine if between the candidate and the last user there is any
254         // effect that could interfere with sinking.
255         for (unsigned nodeIndex = candidateNodeIndex + 1; nodeIndex &lt;= lastUserIndex; ++nodeIndex) {
256             Node* node = block-&gt;at(nodeIndex);
257 
258             // We have our own custom switch to detect some interferences that clobberize() wouldn&#39;t know
259             // about, and also some of the common ones, too. In particular, clobberize() doesn&#39;t know
260             // that Flush, MovHint, ZombieHint, and KillStack are bad because it&#39;s not worried about
261             // what gets read on OSR exit.
262             switch (node-&gt;op()) {
263             case MovHint:
264             case ZombieHint:
265             case KillStack:
<span class="line-modified">266                 if (argumentsInvolveStackSlot(candidate, node-&gt;unlinkedOperand())) {</span>
<span class="line-modified">267                     if (verbose)</span>
268                         dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
269                     return;
270                 }
271                 break;
272 
273             case PutStack:
<span class="line-modified">274                 if (argumentsInvolveStackSlot(candidate, node-&gt;stackAccessData()-&gt;operand)) {</span>
<span class="line-modified">275                     if (verbose)</span>
276                         dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
277                     return;
278                 }
279                 break;
280 
281             case SetLocal:
282             case Flush:
<span class="line-modified">283                 if (argumentsInvolveStackSlot(candidate, node-&gt;operand())) {</span>
<span class="line-modified">284                     if (verbose)</span>
285                         dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
286                     return;
287                 }
288                 break;
289 
290             default: {
291                 bool doesInterfere = false;
292                 clobberize(
293                     m_graph, node, NoOpClobberize(),
294                     [&amp;] (AbstractHeap heap) {
295                         if (heap.kind() != Stack) {
296                             ASSERT(!heap.overlaps(Stack));
297                             return;
298                         }
299                         ASSERT(!heap.payload().isTop());
<span class="line-modified">300                         if (argumentsInvolveStackSlot(candidate, heap.operand()))</span>

301                             doesInterfere = true;
302                     },
303                     NoOpClobberize());
304                 if (doesInterfere) {
<span class="line-modified">305                     if (verbose)</span>
306                         dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
307                     return;
308                 }
309             } }
310         }
311 
312         // We can make this work.
<span class="line-modified">313         if (verbose)</span>
314             dataLog(&quot;    Will do forwarding!\n&quot;);
315         m_changed = true;
316 
317         // Transform the program.
318         switch (candidate-&gt;op()) {
319         case CreateDirectArguments:
320             candidate-&gt;setOpAndDefaultFlags(PhantomDirectArguments);
321             break;
322 
323         case CreateClonedArguments:
324             candidate-&gt;setOpAndDefaultFlags(PhantomClonedArguments);
325             break;
326 
327         default:
328             DFG_CRASH(m_graph, candidate, &quot;bad node type&quot;);
329             break;
330         }
331 
332         InsertionSet insertionSet(m_graph);
333         for (unsigned nodeIndex = candidateNodeIndex + 1; nodeIndex &lt;= lastUserIndex; ++nodeIndex) {
334             Node* node = block-&gt;at(nodeIndex);
335             switch (node-&gt;op()) {
336             case Check:
337             case CheckVarargs:
338             case MovHint:
339             case PutHint:
340                 // We don&#39;t need to change anything with these.
341                 break;
342 
<span class="line-added">343             case VarargsLength: {</span>
<span class="line-added">344                 if (node-&gt;argumentsChild() != candidate)</span>
<span class="line-added">345                     break;</span>
<span class="line-added">346 </span>
<span class="line-added">347                 node-&gt;convertToIdentityOn(emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, node-&gt;origin, /* addThis = */ true));</span>
<span class="line-added">348                 break;</span>
<span class="line-added">349             }</span>
<span class="line-added">350 </span>
351             case LoadVarargs:
<span class="line-modified">352                 if (node-&gt;argumentsChild() != candidate)</span>
353                     break;
354                 node-&gt;setOpAndDefaultFlags(ForwardVarargs);
355                 break;
356 
357             case CallVarargs:
358                 if (node-&gt;child3() != candidate)
359                     break;
360                 node-&gt;setOpAndDefaultFlags(CallForwardVarargs);
361                 break;
362 
363             case ConstructVarargs:
364                 if (node-&gt;child3() != candidate)
365                     break;
366                 node-&gt;setOpAndDefaultFlags(ConstructForwardVarargs);
367                 break;
368 
369             case TailCallVarargs:
370                 if (node-&gt;child3() != candidate)
371                     break;
372                 node-&gt;setOpAndDefaultFlags(TailCallForwardVarargs);
</pre>
<hr />
<pre>
378                 node-&gt;setOpAndDefaultFlags(TailCallForwardVarargsInlinedCaller);
379                 break;
380 
381             case SetLocal:
382                 // This is super odd. We don&#39;t have to do anything here, since in DFG IR, the phantom
383                 // arguments nodes do produce a JSValue. Also, we know that if this SetLocal referenecs a
384                 // candidate then the SetLocal - along with all of its references - will die off pretty
385                 // soon, since it has no real users. DCE will surely kill it. If we make it to SSA, then
386                 // SSA conversion will kill it.
387                 break;
388 
389             case GetButterfly: {
390                 if (node-&gt;child1().node() == candidate) {
391                     ASSERT(candidateButterflies.contains(node));
392                     node-&gt;child1() = Edge();
393                     node-&gt;remove(m_graph);
394                 }
395                 break;
396             }
397 
<span class="line-modified">398             case FilterGetByStatus:</span>
399             case FilterPutByIdStatus:
400             case FilterCallLinkStatus:
401             case FilterInByIdStatus:
402                 if (node-&gt;child1().node() == candidate)
403                     node-&gt;remove(m_graph);
404                 break;
405 
406             case GetByOffset: {
407                 if (node-&gt;child2() == candidate) {
408                     ASSERT(candidateButterflies.contains(node-&gt;child1().node())); // It&#39;s no longer a GetButterfly node, but it should&#39;ve been a candidate butterfly.
409                     ASSERT(node-&gt;storageAccessData().offset == clonedArgumentsLengthPropertyOffset);
410                     node-&gt;convertToIdentityOn(
411                         emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, node-&gt;origin));
412                 }
413                 break;
414             }
415 
416             case GetArrayLength:
417                 if (node-&gt;arrayMode().type() == Array::DirectArguments &amp;&amp; node-&gt;child1() == candidate) {
418                     node-&gt;convertToIdentityOn(
419                         emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, node-&gt;origin));
420                 }
421                 break;
422 
423             default:
<span class="line-modified">424                 if (!ASSERT_ENABLED)</span>
425                     break;
426                 m_graph.doToChildren(
427                     node,
428                     [&amp;] (Edge edge) {
429                         DFG_ASSERT(m_graph, node, edge != candidate);
430                     });
431                 break;
432             }
433         }
434 
435         insertionSet.execute(block);
436     }
437 
438     bool m_changed;
439 };
440 
441 } // anonymous namespace
442 
443 bool performVarargsForwarding(Graph&amp; graph)
444 {
</pre>
</td>
</tr>
</table>
<center><a href="DFGValidate.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGVariableAccessData.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
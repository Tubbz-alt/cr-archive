<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WasmToJS.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSWebAssemblyTable.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WasmToJS.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/WasmToJS.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -28,24 +28,29 @@</span>
  
  #if ENABLE(WEBASSEMBLY)
  
  #include &quot;CCallHelpers.h&quot;
  #include &quot;FrameTracers.h&quot;
<span class="udiff-line-added">+ #include &quot;IteratorOperations.h&quot;</span>
  #include &quot;JITExceptions.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSWebAssemblyHelpers.h&quot;
  #include &quot;JSWebAssemblyInstance.h&quot;
  #include &quot;JSWebAssemblyRuntimeError.h&quot;
  #include &quot;LinkBuffer.h&quot;
  #include &quot;NativeErrorConstructor.h&quot;
  #include &quot;ThunkGenerators.h&quot;
  #include &quot;WasmCallingConvention.h&quot;
<span class="udiff-line-modified-removed">- #include &quot;WasmContext.h&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;WasmContextInlines.h&quot;</span>
  #include &quot;WasmExceptionType.h&quot;
  #include &quot;WasmInstance.h&quot;
<span class="udiff-line-added">+ #include &quot;WasmOperations.h&quot;</span>
  #include &quot;WasmSignatureInlines.h&quot;
  
<span class="udiff-line-added">+ #include &lt;wtf/FunctionTraits.h&gt;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ </span>
  namespace JSC { namespace Wasm {
  
  using JIT = CCallHelpers;
  
  static void materializeImportJSCell(JIT&amp; jit, unsigned importIndex, GPRReg result)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -53,317 +58,72 @@</span>
      // We&#39;re calling out of the current WebAssembly.Instance. That Instance has a list of all its import functions.
      jit.loadWasmContextInstance(result);
      jit.loadPtr(JIT::Address(result, Instance::offsetOfImportFunction(importIndex)), result);
  }
  
<span class="udiff-line-modified-removed">- static Expected&lt;MacroAssemblerCodeRef&lt;WasmEntryPtrTag&gt;, BindingFailure&gt; handleBadI64Use(VM* vm, JIT&amp; jit, const Signature&amp; signature, unsigned importIndex)</span>
<span class="udiff-line-modified-added">+ static Expected&lt;MacroAssemblerCodeRef&lt;WasmEntryPtrTag&gt;, BindingFailure&gt; handleBadI64Use(VM&amp; vm, JIT&amp; jit, unsigned importIndex)</span>
  {
<span class="udiff-line-modified-removed">-     unsigned argCount = signature.argumentCount();</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     bool hasBadI64Use = false;</span>
<span class="udiff-line-removed">-     hasBadI64Use |= signature.returnType() == I64;</span>
<span class="udiff-line-removed">-     for (unsigned argNum = 0; argNum &lt; argCount &amp;&amp; !hasBadI64Use; ++argNum) {</span>
<span class="udiff-line-removed">-         Type argType = signature.argument(argNum);</span>
<span class="udiff-line-removed">-         switch (argType) {</span>
<span class="udiff-line-removed">-         case Void:</span>
<span class="udiff-line-removed">-         case Func:</span>
<span class="udiff-line-removed">-             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         case I64: {</span>
<span class="udiff-line-removed">-             hasBadI64Use = true;</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         default:</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (hasBadI64Use) {</span>
<span class="udiff-line-removed">-         jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);</span>
<span class="udiff-line-removed">-         jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);</span>
<span class="udiff-line-removed">-         jit.loadWasmContextInstance(GPRInfo::argumentGPR1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Store Callee.</span>
<span class="udiff-line-removed">-         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR1, Instance::offsetOfOwner()), GPRInfo::argumentGPR1);</span>
<span class="udiff-line-removed">-         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR1, JSWebAssemblyInstance::offsetOfCallee()), GPRInfo::argumentGPR2);</span>
<span class="udiff-line-removed">-         jit.storePtr(GPRInfo::argumentGPR2, JIT::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         auto call = jit.call(OperationPtrTag);</span>
<span class="udiff-line-removed">-         jit.jumpToExceptionHandler(*vm);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         void (*throwBadI64)(ExecState*, JSWebAssemblyInstance*) = [] (ExecState* exec, JSWebAssemblyInstance* instance) -&gt; void {</span>
<span class="udiff-line-removed">-             VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-removed">-             NativeCallFrameTracer tracer(vm, exec);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             {</span>
<span class="udiff-line-removed">-                 auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="udiff-line-removed">-                 JSGlobalObject* globalObject = instance-&gt;globalObject(vm);</span>
<span class="udiff-line-removed">-                 auto* error = ErrorInstance::create(exec, vm, globalObject-&gt;errorStructure(ErrorType::TypeError), &quot;i64 not allowed as return type or argument to an imported function&quot;_s);</span>
<span class="udiff-line-removed">-                 throwException(exec, throwScope, error);</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-modified-added">+     jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm.topEntryFrame);</span>
<span class="udiff-line-modified-added">+     jit.loadWasmContextInstance(GPRInfo::argumentGPR0);</span>
  
<span class="udiff-line-modified-removed">-             genericUnwind(vm, exec);</span>
<span class="udiff-line-modified-removed">-             ASSERT(!!vm.callFrameForCatch);</span>
<span class="udiff-line-modified-removed">-         };</span>
<span class="udiff-line-modified-added">+     // Store Callee.</span>
<span class="udiff-line-modified-added">+     jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, Instance::offsetOfOwner()), GPRInfo::argumentGPR0);</span>
<span class="udiff-line-modified-added">+     jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, JSWebAssemblyInstance::offsetOfModule()), GPRInfo::argumentGPR1);</span>
<span class="udiff-line-added">+     jit.prepareCallOperation(vm);</span>
<span class="udiff-line-added">+     jit.storePtr(GPRInfo::argumentGPR1, JIT::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));</span>
  
<span class="udiff-line-modified-removed">-         LinkBuffer linkBuffer(jit, GLOBAL_THUNK_ID, JITCompilationCanFail);</span>
<span class="udiff-line-modified-removed">-         if (UNLIKELY(linkBuffer.didFailToAllocate()))</span>
<span class="udiff-line-removed">-             return makeUnexpected(BindingFailure::OutOfMemory);</span>
<span class="udiff-line-modified-added">+     auto call = jit.call(OperationPtrTag);</span>
<span class="udiff-line-modified-added">+     jit.jumpToExceptionHandler(vm);</span>
  
<span class="udiff-line-modified-removed">-         linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(throwBadI64));</span>
<span class="udiff-line-modified-removed">-         return FINALIZE_CODE(linkBuffer, WasmEntryPtrTag, &quot;WebAssembly-&gt;JavaScript invalid i64 use in import[%i]&quot;, importIndex);</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-added">+     LinkBuffer linkBuffer(jit, GLOBAL_THUNK_ID, JITCompilationCanFail);</span>
<span class="udiff-line-modified-added">+     if (UNLIKELY(linkBuffer.didFailToAllocate()))</span>
<span class="udiff-line-modified-added">+         return makeUnexpected(BindingFailure::OutOfMemory);</span>
  
<span class="udiff-line-modified-removed">-     return MacroAssemblerCodeRef&lt;WasmEntryPtrTag&gt;();</span>
<span class="udiff-line-modified-added">+     linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(operationWasmThrowBadI64));</span>
<span class="udiff-line-added">+     return FINALIZE_WASM_CODE(linkBuffer, WasmEntryPtrTag, &quot;WebAssembly-&gt;JavaScript invalid i64 use in import[%i]&quot;, importIndex);</span>
  }
  
<span class="udiff-line-modified-removed">- Expected&lt;MacroAssemblerCodeRef&lt;WasmEntryPtrTag&gt;, BindingFailure&gt; wasmToJS(VM* vm, Bag&lt;CallLinkInfo&gt;&amp; callLinkInfos, SignatureIndex signatureIndex, unsigned importIndex)</span>
<span class="udiff-line-modified-added">+ Expected&lt;MacroAssemblerCodeRef&lt;WasmEntryPtrTag&gt;, BindingFailure&gt; wasmToJS(VM&amp; vm, Bag&lt;CallLinkInfo&gt;&amp; callLinkInfos, SignatureIndex signatureIndex, unsigned importIndex)</span>
  {
      // FIXME: This function doesn&#39;t properly abstract away the calling convention.
      // It&#39;d be super easy to do so: https://bugs.webkit.org/show_bug.cgi?id=169401
<span class="udiff-line-modified-removed">-     const WasmCallingConvention&amp; wasmCC = wasmCallingConvention();</span>
<span class="udiff-line-modified-removed">-     const JSCCallingConvention&amp; jsCC = jscCallingConvention();</span>
<span class="udiff-line-modified-added">+     const auto&amp; wasmCC = wasmCallingConvention();</span>
<span class="udiff-line-modified-added">+     const auto&amp; jsCC = jsCallingConvention();</span>
      const Signature&amp; signature = SignatureInformation::get(signatureIndex);
      unsigned argCount = signature.argumentCount();
      JIT jit;
  
<span class="udiff-line-added">+     CallInformation wasmCallInfo = wasmCC.callInformationFor(signature, CallRole::Callee);</span>
<span class="udiff-line-added">+     RegisterAtOffsetList savedResultRegisters = wasmCallInfo.computeResultsOffsetList();</span>
<span class="udiff-line-added">+ </span>
      // Note: WasmB3IRGenerator assumes that this stub treats SP as a callee save.
      // If we ever change this, we will also need to change WasmB3IRGenerator.
  
      // Below, we assume that the JS calling convention is always on the stack.
<span class="udiff-line-modified-removed">-     ASSERT(!jsCC.m_gprArgs.size());</span>
<span class="udiff-line-modified-removed">-     ASSERT(!jsCC.m_fprArgs.size());</span>
<span class="udiff-line-modified-added">+     ASSERT(!jsCC.gprArgs.size());</span>
<span class="udiff-line-modified-added">+     ASSERT(!jsCC.fprArgs.size());</span>
  
      jit.emitFunctionPrologue();
      jit.store64(JIT::TrustedImm32(0), JIT::Address(GPRInfo::callFrameRegister, CallFrameSlot::codeBlock * static_cast&lt;int&gt;(sizeof(Register)))); // FIXME Stop using 0 as codeBlocks. https://bugs.webkit.org/show_bug.cgi?id=165321
  
<span class="udiff-line-modified-removed">-     auto badI64 = handleBadI64Use(vm, jit, signature, importIndex);</span>
<span class="udiff-line-modified-removed">-     if (!badI64 || badI64.value())</span>
<span class="udiff-line-removed">-         return badI64;</span>
<span class="udiff-line-modified-added">+     if (wasmCallInfo.argumentsIncludeI64 || wasmCallInfo.resultsIncludeI64)</span>
<span class="udiff-line-modified-added">+         return handleBadI64Use(vm, jit, importIndex);</span>
  
      // Here we assume that the JS calling convention saves at least all the wasm callee saved. We therefore don&#39;t need to save and restore more registers since the wasm callee already took care of this.
<span class="udiff-line-modified-removed">-     RegisterSet missingCalleeSaves = wasmCC.m_calleeSaveRegisters;</span>
<span class="udiff-line-modified-removed">-     missingCalleeSaves.exclude(jsCC.m_calleeSaveRegisters);</span>
<span class="udiff-line-modified-added">+     RegisterSet missingCalleeSaves = wasmCC.calleeSaveRegisters;</span>
<span class="udiff-line-modified-added">+     missingCalleeSaves.exclude(jsCC.calleeSaveRegisters);</span>
      ASSERT(missingCalleeSaves.isEmpty());
  
<span class="udiff-line-removed">-     if (!Options::useCallICsForWebAssemblyToJSCalls()) {</span>
<span class="udiff-line-removed">-         ScratchBuffer* scratchBuffer = vm-&gt;scratchBufferForSize(argCount * sizeof(uint64_t));</span>
<span class="udiff-line-removed">-         char* buffer = argCount ? static_cast&lt;char*&gt;(scratchBuffer-&gt;dataBuffer()) : nullptr;</span>
<span class="udiff-line-removed">-         unsigned marshalledGPRs = 0;</span>
<span class="udiff-line-removed">-         unsigned marshalledFPRs = 0;</span>
<span class="udiff-line-removed">-         unsigned bufferOffset = 0;</span>
<span class="udiff-line-removed">-         unsigned frOffset = CallFrame::headerSizeInRegisters * static_cast&lt;int&gt;(sizeof(Register));</span>
<span class="udiff-line-removed">-         const GPRReg scratchGPR = GPRInfo::regCS0;</span>
<span class="udiff-line-removed">-         jit.subPtr(MacroAssembler::TrustedImm32(WTF::roundUpToMultipleOf(stackAlignmentBytes(), sizeof(Register))), MacroAssembler::stackPointerRegister);</span>
<span class="udiff-line-removed">-         jit.storePtr(scratchGPR, MacroAssembler::Address(MacroAssembler::stackPointerRegister));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         for (unsigned argNum = 0; argNum &lt; argCount; ++argNum) {</span>
<span class="udiff-line-removed">-             Type argType = signature.argument(argNum);</span>
<span class="udiff-line-removed">-             switch (argType) {</span>
<span class="udiff-line-removed">-             case Void:</span>
<span class="udiff-line-removed">-             case Func:</span>
<span class="udiff-line-removed">-             case I64:</span>
<span class="udiff-line-removed">-                 RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-removed">-             case Anyref:</span>
<span class="udiff-line-removed">-             case Funcref:</span>
<span class="udiff-line-removed">-             case I32: {</span>
<span class="udiff-line-removed">-                 GPRReg gprReg;</span>
<span class="udiff-line-removed">-                 if (marshalledGPRs &lt; wasmCC.m_gprArgs.size())</span>
<span class="udiff-line-removed">-                     gprReg = wasmCC.m_gprArgs[marshalledGPRs].gpr();</span>
<span class="udiff-line-removed">-                 else {</span>
<span class="udiff-line-removed">-                     // We&#39;ve already spilled all arguments, these registers are available as scratch.</span>
<span class="udiff-line-removed">-                     gprReg = GPRInfo::argumentGPR0;</span>
<span class="udiff-line-removed">-                     jit.load64(JIT::Address(GPRInfo::callFrameRegister, frOffset), gprReg);</span>
<span class="udiff-line-removed">-                     frOffset += sizeof(Register);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 if (argType == I32)</span>
<span class="udiff-line-removed">-                     jit.zeroExtend32ToPtr(gprReg, gprReg);</span>
<span class="udiff-line-removed">-                 jit.store64(gprReg, buffer + bufferOffset);</span>
<span class="udiff-line-removed">-                 ++marshalledGPRs;</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             case F32: {</span>
<span class="udiff-line-removed">-                 FPRReg fprReg;</span>
<span class="udiff-line-removed">-                 if (marshalledFPRs &lt; wasmCC.m_fprArgs.size())</span>
<span class="udiff-line-removed">-                     fprReg = wasmCC.m_fprArgs[marshalledFPRs].fpr();</span>
<span class="udiff-line-removed">-                 else {</span>
<span class="udiff-line-removed">-                     // We&#39;ve already spilled all arguments, these registers are available as scratch.</span>
<span class="udiff-line-removed">-                     fprReg = FPRInfo::argumentFPR0;</span>
<span class="udiff-line-removed">-                     jit.loadFloat(JIT::Address(GPRInfo::callFrameRegister, frOffset), fprReg);</span>
<span class="udiff-line-removed">-                     frOffset += sizeof(Register);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 jit.convertFloatToDouble(fprReg, fprReg);</span>
<span class="udiff-line-removed">-                 jit.moveDoubleTo64(fprReg, scratchGPR);</span>
<span class="udiff-line-removed">-                 jit.store64(scratchGPR, buffer + bufferOffset);</span>
<span class="udiff-line-removed">-                 ++marshalledFPRs;</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             case F64: {</span>
<span class="udiff-line-removed">-                 FPRReg fprReg;</span>
<span class="udiff-line-removed">-                 if (marshalledFPRs &lt; wasmCC.m_fprArgs.size())</span>
<span class="udiff-line-removed">-                     fprReg = wasmCC.m_fprArgs[marshalledFPRs].fpr();</span>
<span class="udiff-line-removed">-                 else {</span>
<span class="udiff-line-removed">-                     // We&#39;ve already spilled all arguments, these registers are available as scratch.</span>
<span class="udiff-line-removed">-                     fprReg = FPRInfo::argumentFPR0;</span>
<span class="udiff-line-removed">-                     jit.loadDouble(JIT::Address(GPRInfo::callFrameRegister, frOffset), fprReg);</span>
<span class="udiff-line-removed">-                     frOffset += sizeof(Register);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 jit.moveDoubleTo64(fprReg, scratchGPR);</span>
<span class="udiff-line-removed">-                 jit.store64(scratchGPR, buffer + bufferOffset);</span>
<span class="udiff-line-removed">-                 ++marshalledFPRs;</span>
<span class="udiff-line-removed">-                 break;</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-             bufferOffset += sizeof(Register);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         jit.loadPtr(MacroAssembler::Address(MacroAssembler::stackPointerRegister), scratchGPR);</span>
<span class="udiff-line-removed">-         if (argCount) {</span>
<span class="udiff-line-removed">-             // The GC should not look at this buffer at all, these aren&#39;t JSValues.</span>
<span class="udiff-line-removed">-             jit.move(CCallHelpers::TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), GPRInfo::argumentGPR0);</span>
<span class="udiff-line-removed">-             jit.storePtr(CCallHelpers::TrustedImmPtr(nullptr), GPRInfo::argumentGPR0);</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         uint64_t (*callFunc)(ExecState*, JSObject*, SignatureIndex, uint64_t*) =</span>
<span class="udiff-line-removed">-             [] (ExecState* exec, JSObject* callee, SignatureIndex signatureIndex, uint64_t* buffer) -&gt; uint64_t {</span>
<span class="udiff-line-removed">-                 VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-removed">-                 NativeCallFrameTracer tracer(vm, exec);</span>
<span class="udiff-line-removed">-                 auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="udiff-line-removed">-                 const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="udiff-line-removed">-                 MarkedArgumentBuffer args;</span>
<span class="udiff-line-removed">-                 for (unsigned argNum = 0; argNum &lt; signature.argumentCount(); ++argNum) {</span>
<span class="udiff-line-removed">-                     Type argType = signature.argument(argNum);</span>
<span class="udiff-line-removed">-                     JSValue arg;</span>
<span class="udiff-line-removed">-                     switch (argType) {</span>
<span class="udiff-line-removed">-                     case Void:</span>
<span class="udiff-line-removed">-                     case Func:</span>
<span class="udiff-line-removed">-                     case I64:</span>
<span class="udiff-line-removed">-                         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-removed">-                     case I32:</span>
<span class="udiff-line-removed">-                         arg = jsNumber(static_cast&lt;int32_t&gt;(buffer[argNum]));</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     case Funcref: {</span>
<span class="udiff-line-removed">-                         arg = JSValue::decode(buffer[argNum]);</span>
<span class="udiff-line-removed">-                         ASSERT(isWebAssemblyHostFunction(vm, arg) || arg.isNull());</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     case Anyref:</span>
<span class="udiff-line-removed">-                         arg = JSValue::decode(buffer[argNum]);</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     case F32:</span>
<span class="udiff-line-removed">-                     case F64:</span>
<span class="udiff-line-removed">-                         arg = jsNumber(purifyNaN(bitwise_cast&lt;double&gt;(buffer[argNum])));</span>
<span class="udiff-line-removed">-                         break;</span>
<span class="udiff-line-removed">-                     }</span>
<span class="udiff-line-removed">-                     args.append(arg);</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 if (UNLIKELY(args.hasOverflowed())) {</span>
<span class="udiff-line-removed">-                     throwOutOfMemoryError(exec, throwScope);</span>
<span class="udiff-line-removed">-                     return 0;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 CallData callData;</span>
<span class="udiff-line-removed">-                 CallType callType = callee-&gt;methodTable(vm)-&gt;getCallData(callee, callData);</span>
<span class="udiff-line-removed">-                 RELEASE_ASSERT(callType != CallType::None);</span>
<span class="udiff-line-removed">-                 JSValue result = call(exec, callee, callType, callData, jsUndefined(), args);</span>
<span class="udiff-line-removed">-                 RETURN_IF_EXCEPTION(throwScope, 0);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 uint64_t realResult;</span>
<span class="udiff-line-removed">-                 switch (signature.returnType()) {</span>
<span class="udiff-line-removed">-                 case Func:</span>
<span class="udiff-line-removed">-                 case I64:</span>
<span class="udiff-line-removed">-                     RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-removed">-                     break;</span>
<span class="udiff-line-removed">-                 case Void:</span>
<span class="udiff-line-removed">-                     break;</span>
<span class="udiff-line-removed">-                 case I32: {</span>
<span class="udiff-line-removed">-                     realResult = static_cast&lt;uint64_t&gt;(static_cast&lt;uint32_t&gt;(result.toInt32(exec)));</span>
<span class="udiff-line-removed">-                     break;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 case Funcref: {</span>
<span class="udiff-line-removed">-                     realResult = JSValue::encode(result);</span>
<span class="udiff-line-removed">-                     ASSERT(result.isFunction(vm) || result.isNull());</span>
<span class="udiff-line-removed">-                     break;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 case Anyref: {</span>
<span class="udiff-line-removed">-                     realResult = JSValue::encode(result);</span>
<span class="udiff-line-removed">-                     break;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 case F64:</span>
<span class="udiff-line-removed">-                 case F32: {</span>
<span class="udiff-line-removed">-                     realResult = bitwise_cast&lt;uint64_t&gt;(result.toNumber(exec));</span>
<span class="udiff-line-removed">-                     break;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-                 RETURN_IF_EXCEPTION(throwScope, 0);</span>
<span class="udiff-line-removed">-                 return realResult;</span>
<span class="udiff-line-removed">-             };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         jit.loadWasmContextInstance(GPRInfo::argumentGPR0);</span>
<span class="udiff-line-removed">-         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, Instance::offsetOfOwner()), GPRInfo::argumentGPR0);</span>
<span class="udiff-line-removed">-         jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, JSWebAssemblyInstance::offsetOfCallee()), GPRInfo::argumentGPR0);</span>
<span class="udiff-line-removed">-         jit.storePtr(GPRInfo::argumentGPR0, JIT::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         materializeImportJSCell(jit, importIndex, GPRInfo::argumentGPR1);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         static_assert(GPRInfo::numberOfArgumentRegisters &gt;= 4, &quot;We rely on this with the call below.&quot;);</span>
<span class="udiff-line-removed">-         static_assert(sizeof(SignatureIndex) == sizeof(uint64_t), &quot;Following code assumes SignatureIndex is 64bit.&quot;);</span>
<span class="udiff-line-removed">-         jit.setupArguments&lt;decltype(callFunc)&gt;(GPRInfo::argumentGPR1, CCallHelpers::TrustedImm64(signatureIndex), CCallHelpers::TrustedImmPtr(buffer));</span>
<span class="udiff-line-removed">-         auto call = jit.call(OperationPtrTag);</span>
<span class="udiff-line-removed">-         auto noException = jit.emitExceptionCheck(*vm, AssemblyHelpers::InvertedExceptionCheck);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         // Exception here.</span>
<span class="udiff-line-removed">-         jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);</span>
<span class="udiff-line-removed">-         jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);</span>
<span class="udiff-line-removed">-         void (*doUnwinding)(ExecState*) = [] (ExecState* exec) -&gt; void {</span>
<span class="udiff-line-removed">-             VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-removed">-             NativeCallFrameTracer tracer(vm, exec);</span>
<span class="udiff-line-removed">-             genericUnwind(vm, exec);</span>
<span class="udiff-line-removed">-             ASSERT(!!vm.callFrameForCatch);</span>
<span class="udiff-line-removed">-         };</span>
<span class="udiff-line-removed">-         auto exceptionCall = jit.call(OperationPtrTag);</span>
<span class="udiff-line-removed">-         jit.jumpToExceptionHandler(*vm);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         noException.link(&amp;jit);</span>
<span class="udiff-line-removed">-         switch (signature.returnType()) {</span>
<span class="udiff-line-removed">-         case F64: {</span>
<span class="udiff-line-removed">-             jit.move64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         case F32: {</span>
<span class="udiff-line-removed">-             jit.move64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);</span>
<span class="udiff-line-removed">-             jit.convertDoubleToFloat(FPRInfo::returnValueFPR, FPRInfo::returnValueFPR);</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         default:</span>
<span class="udiff-line-removed">-             break;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         jit.emitFunctionEpilogue();</span>
<span class="udiff-line-removed">-         jit.ret();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         LinkBuffer linkBuffer(jit, GLOBAL_THUNK_ID, JITCompilationCanFail);</span>
<span class="udiff-line-removed">-         if (UNLIKELY(linkBuffer.didFailToAllocate()))</span>
<span class="udiff-line-removed">-             return makeUnexpected(BindingFailure::OutOfMemory);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(callFunc));</span>
<span class="udiff-line-removed">-         linkBuffer.link(exceptionCall, FunctionPtr&lt;OperationPtrTag&gt;(doUnwinding));</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         return FINALIZE_CODE(linkBuffer, WasmEntryPtrTag, &quot;WebAssembly-&gt;JavaScript import[%i] %s&quot;, importIndex, signature.toString().ascii().data());</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      // Note: We don&#39;t need to perform a stack check here since WasmB3IRGenerator
      // will do the stack check for us. Whenever it detects that it might make
      // a call to this thunk, it&#39;ll make sure its stack check includes space
      // for us here.
  
      const unsigned numberOfParameters = argCount + 1; // There is a &quot;this&quot; argument.
      const unsigned numberOfRegsForCall = CallFrame::headerSizeInRegisters + numberOfParameters;
      const unsigned numberOfBytesForCall = numberOfRegsForCall * sizeof(Register) - sizeof(CallerFrameAndPC);
<span class="udiff-line-modified-removed">-     const unsigned stackOffset = WTF::roundUpToMultipleOf(stackAlignmentBytes(), numberOfBytesForCall);</span>
<span class="udiff-line-modified-added">+     const unsigned stackOffset = WTF::roundUpToMultipleOf(stackAlignmentBytes(), std::max&lt;unsigned&gt;(numberOfBytesForCall, savedResultRegisters.size() * sizeof(CPURegister)));</span>
      jit.subPtr(MacroAssembler::TrustedImm32(stackOffset), MacroAssembler::stackPointerRegister);
      JIT::Address calleeFrame = CCallHelpers::Address(MacroAssembler::stackPointerRegister, -static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC)));
  
      // FIXME make these loops which switch on Signature if there are many arguments on the stack. It&#39;ll otherwise be huge for huge signatures. https://bugs.webkit.org/show_bug.cgi?id=165547
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -382,12 +142,12 @@</span>
                  RELEASE_ASSERT_NOT_REACHED(); // Handled above.
              case Anyref:
              case Funcref:
              case I32: {
                  GPRReg gprReg;
<span class="udiff-line-modified-removed">-                 if (marshalledGPRs &lt; wasmCC.m_gprArgs.size())</span>
<span class="udiff-line-modified-removed">-                     gprReg = wasmCC.m_gprArgs[marshalledGPRs].gpr();</span>
<span class="udiff-line-modified-added">+                 if (marshalledGPRs &lt; wasmCC.gprArgs.size())</span>
<span class="udiff-line-modified-added">+                     gprReg = wasmCC.gprArgs[marshalledGPRs].gpr();</span>
                  else {
                      // We&#39;ve already spilled all arguments, these registers are available as scratch.
                      gprReg = GPRInfo::argumentGPR0;
                      jit.load64(JIT::Address(GPRInfo::callFrameRegister, frOffset), gprReg);
                      frOffset += sizeof(Register);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -402,11 +162,11 @@</span>
                  break;
              }
              case F32:
              case F64:
                  // Skipped: handled below.
<span class="udiff-line-modified-removed">-                 if (marshalledFPRs &gt;= wasmCC.m_fprArgs.size())</span>
<span class="udiff-line-modified-added">+                 if (marshalledFPRs &gt;= wasmCC.fprArgs.size())</span>
                      frOffset += sizeof(Register);
                  ++marshalledFPRs;
                  calleeFrameOffset += sizeof(Register);
                  break;
              }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -418,13 +178,16 @@</span>
          GPRReg doubleEncodeOffsetGPRReg = GPRInfo::argumentGPR0;
          GPRReg scratch = GPRInfo::argumentGPR1;
          bool hasMaterializedDoubleEncodeOffset = false;
          auto materializeDoubleEncodeOffset = [&amp;hasMaterializedDoubleEncodeOffset, &amp;jit] (GPRReg dest) {
              if (!hasMaterializedDoubleEncodeOffset) {
<span class="udiff-line-modified-removed">-                 static_assert(DoubleEncodeOffset == 1ll &lt;&lt; 48, &quot;codegen assumes this below&quot;);</span>
<span class="udiff-line-modified-added">+ #if CPU(ARM64)</span>
<span class="udiff-line-added">+                 jit.move(JIT::TrustedImm64(JSValue::DoubleEncodeOffset), dest);</span>
<span class="udiff-line-added">+ #else</span>
                  jit.move(JIT::TrustedImm32(1), dest);
<span class="udiff-line-modified-removed">-                 jit.lshift64(JIT::TrustedImm32(48), dest);</span>
<span class="udiff-line-modified-added">+                 jit.lshift64(JIT::TrustedImm32(JSValue::DoubleEncodeOffsetBit), dest);</span>
<span class="udiff-line-added">+ #endif</span>
                  hasMaterializedDoubleEncodeOffset = true;
              }
          };
  
          unsigned marshalledGPRs = 0;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -451,19 +214,19 @@</span>
                  RELEASE_ASSERT_NOT_REACHED(); // Handled above.
              case Anyref:
              case Funcref:
              case I32:
                  // Skipped: handled above.
<span class="udiff-line-modified-removed">-                 if (marshalledGPRs &gt;= wasmCC.m_gprArgs.size())</span>
<span class="udiff-line-modified-added">+                 if (marshalledGPRs &gt;= wasmCC.gprArgs.size())</span>
                      frOffset += sizeof(Register);
                  ++marshalledGPRs;
                  calleeFrameOffset += sizeof(Register);
                  break;
              case F32: {
                  FPRReg fprReg;
<span class="udiff-line-modified-removed">-                 if (marshalledFPRs &lt; wasmCC.m_fprArgs.size())</span>
<span class="udiff-line-modified-removed">-                     fprReg = wasmCC.m_fprArgs[marshalledFPRs].fpr();</span>
<span class="udiff-line-modified-added">+                 if (marshalledFPRs &lt; wasmCC.fprArgs.size())</span>
<span class="udiff-line-modified-added">+                     fprReg = wasmCC.fprArgs[marshalledFPRs].fpr();</span>
                  else {
                      // We&#39;ve already spilled all arguments, these registers are available as scratch.
                      fprReg = FPRInfo::argumentFPR0;
                      jit.loadFloat(JIT::Address(GPRInfo::callFrameRegister, frOffset), fprReg);
                      frOffset += sizeof(Register);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -472,12 +235,12 @@</span>
                  marshallFPR(fprReg);
                  break;
              }
              case F64: {
                  FPRReg fprReg;
<span class="udiff-line-modified-removed">-                 if (marshalledFPRs &lt; wasmCC.m_fprArgs.size())</span>
<span class="udiff-line-modified-removed">-                     fprReg = wasmCC.m_fprArgs[marshalledFPRs].fpr();</span>
<span class="udiff-line-modified-added">+                 if (marshalledFPRs &lt; wasmCC.fprArgs.size())</span>
<span class="udiff-line-modified-added">+                     fprReg = wasmCC.fprArgs[marshalledFPRs].fpr();</span>
                  else {
                      // We&#39;ve already spilled all arguments, these registers are available as scratch.
                      fprReg = FPRInfo::argumentFPR0;
                      jit.loadDouble(JIT::Address(GPRInfo::callFrameRegister, frOffset), fprReg);
                      frOffset += sizeof(Register);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -489,21 +252,21 @@</span>
          }
      }
  
      jit.loadWasmContextInstance(GPRInfo::argumentGPR0);
      jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, Instance::offsetOfOwner()), GPRInfo::argumentGPR0);
<span class="udiff-line-modified-removed">-     jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, JSWebAssemblyInstance::offsetOfCallee()), GPRInfo::argumentGPR0);</span>
<span class="udiff-line-modified-added">+     jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR0, JSWebAssemblyInstance::offsetOfModule()), GPRInfo::argumentGPR0);</span>
      jit.storePtr(GPRInfo::argumentGPR0, JIT::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));
  
      GPRReg importJSCellGPRReg = GPRInfo::regT0; // Callee needs to be in regT0 for slow path below.
  
<span class="udiff-line-modified-removed">-     ASSERT(!wasmCC.m_calleeSaveRegisters.get(importJSCellGPRReg));</span>
<span class="udiff-line-modified-added">+     ASSERT(!wasmCC.calleeSaveRegisters.get(importJSCellGPRReg));</span>
      materializeImportJSCell(jit, importIndex, importJSCellGPRReg);
  
      jit.store64(importJSCellGPRReg, calleeFrame.withOffset(CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));
<span class="udiff-line-modified-removed">-     jit.store32(JIT::TrustedImm32(numberOfParameters), calleeFrame.withOffset(CallFrameSlot::argumentCount * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset));</span>
<span class="udiff-line-modified-removed">-     jit.store64(JIT::TrustedImm64(ValueUndefined), calleeFrame.withOffset(CallFrameSlot::thisArgument * static_cast&lt;int&gt;(sizeof(Register))));</span>
<span class="udiff-line-modified-added">+     jit.store32(JIT::TrustedImm32(numberOfParameters), calleeFrame.withOffset(CallFrameSlot::argumentCountIncludingThis * static_cast&lt;int&gt;(sizeof(Register)) + PayloadOffset));</span>
<span class="udiff-line-modified-added">+     jit.store64(JIT::TrustedImm64(JSValue::ValueUndefined), calleeFrame.withOffset(CallFrameSlot::thisArgument * static_cast&lt;int&gt;(sizeof(Register))));</span>
  
      // FIXME Tail call if the wasm return type is void and no registers were spilled. https://bugs.webkit.org/show_bug.cgi?id=165488
  
      CallLinkInfo* callLinkInfo = callLinkInfos.add();
      callLinkInfo-&gt;setUpCall(CallLinkInfo::Call, CodeOrigin(), importJSCellGPRReg);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -513,194 +276,159 @@</span>
      JIT::Call fastCall = jit.nearCall();
      JIT::Jump done = jit.jump();
      slowPath.link(&amp;jit);
      // Callee needs to be in regT0 here.
      jit.move(MacroAssembler::TrustedImmPtr(callLinkInfo), GPRInfo::regT2); // Link info needs to be in regT2.
<span class="udiff-line-added">+     jit.loadWasmContextInstance(GPRInfo::regT3);</span>
<span class="udiff-line-added">+     jit.loadPtr(CCallHelpers::Address(GPRInfo::regT3, Instance::offsetOfOwner()), GPRInfo::regT3);</span>
<span class="udiff-line-added">+     jit.loadPtr(CCallHelpers::Address(GPRInfo::regT3, JSWebAssemblyInstance::offsetOfGlobalObject()), GPRInfo::regT3);</span>
      JIT::Call slowCall = jit.nearCall();
      done.link(&amp;jit);
  
      CCallHelpers::JumpList exceptionChecks;
  
<span class="udiff-line-modified-removed">-     switch (signature.returnType()) {</span>
<span class="udiff-line-modified-removed">-     case Void:</span>
<span class="udiff-line-modified-removed">-         // Discard.</span>
<span class="udiff-line-modified-removed">-         break;</span>
<span class="udiff-line-modified-removed">-     case Func:</span>
<span class="udiff-line-modified-removed">-         // For the JavaScript embedding, imports with these types in their signature return are a WebAssembly.Module validation error.</span>
<span class="udiff-line-modified-removed">-         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-modified-removed">-         break;</span>
<span class="udiff-line-modified-removed">-     case I64: {</span>
<span class="udiff-line-modified-removed">-         RELEASE_ASSERT_NOT_REACHED(); // Handled above.</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-     case I32: {</span>
<span class="udiff-line-modified-removed">-         CCallHelpers::JumpList done;</span>
<span class="udiff-line-modified-removed">-         CCallHelpers::JumpList slowPath;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         int32_t (*convertToI32)(ExecState*, JSValue) = [] (ExecState* exec, JSValue v) -&gt; int32_t {</span>
<span class="udiff-line-modified-removed">-             VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-removed">-             NativeCallFrameTracer tracer(vm, exec);</span>
<span class="udiff-line-modified-removed">-             return v.toInt32(exec);</span>
<span class="udiff-line-modified-removed">-         };</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         slowPath.append(jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters));</span>
<span class="udiff-line-modified-removed">-         slowPath.append(jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters));</span>
<span class="udiff-line-modified-removed">-         jit.zeroExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-removed">-         done.append(jit.jump());</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         slowPath.link(&amp;jit);</span>
<span class="udiff-line-modified-removed">-         jit.setupArguments&lt;decltype(convertToI32)&gt;(GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-removed">-         auto call = jit.call(OperationPtrTag);</span>
<span class="udiff-line-modified-removed">-         exceptionChecks.append(jit.emitJumpIfException(*vm));</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {</span>
<span class="udiff-line-modified-removed">-             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(convertToI32));</span>
<span class="udiff-line-modified-removed">-         });</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         done.link(&amp;jit);</span>
<span class="udiff-line-modified-removed">-         break;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-     case Funcref:</span>
<span class="udiff-line-modified-removed">-     case Anyref:</span>
<span class="udiff-line-modified-removed">-         break;</span>
<span class="udiff-line-modified-removed">-     case F32: {</span>
<span class="udiff-line-modified-removed">-         CCallHelpers::JumpList done;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         float (*convertToF32)(ExecState*, JSValue) = [] (ExecState* exec, JSValue v) -&gt; float {</span>
<span class="udiff-line-modified-removed">-             VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-removed">-             NativeCallFrameTracer tracer(vm, exec);</span>
<span class="udiff-line-modified-removed">-             return static_cast&lt;float&gt;(v.toNumber(exec));</span>
<span class="udiff-line-modified-removed">-         };</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         auto notANumber = jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters);</span>
<span class="udiff-line-modified-removed">-         auto isDouble = jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters);</span>
<span class="udiff-line-modified-removed">-         // We&#39;re an int32</span>
<span class="udiff-line-modified-removed">-         jit.signExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-removed">-         jit.convertInt64ToFloat(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);</span>
<span class="udiff-line-modified-removed">-         done.append(jit.jump());</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         isDouble.link(&amp;jit);</span>
<span class="udiff-line-modified-removed">-         jit.move(JIT::TrustedImm64(TagTypeNumber), GPRInfo::returnValueGPR2);</span>
<span class="udiff-line-modified-removed">-         jit.add64(GPRInfo::returnValueGPR2, GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-removed">-         jit.move64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);</span>
<span class="udiff-line-modified-removed">-         jit.convertDoubleToFloat(FPRInfo::returnValueFPR, FPRInfo::returnValueFPR);</span>
<span class="udiff-line-modified-removed">-         done.append(jit.jump());</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         notANumber.link(&amp;jit);</span>
<span class="udiff-line-modified-removed">-         jit.setupArguments&lt;decltype(convertToF32)&gt;(GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-removed">-         auto call = jit.call(OperationPtrTag);</span>
<span class="udiff-line-modified-removed">-         exceptionChecks.append(jit.emitJumpIfException(*vm));</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {</span>
<span class="udiff-line-modified-removed">-             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(convertToF32));</span>
<span class="udiff-line-modified-removed">-         });</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         done.link(&amp;jit);</span>
<span class="udiff-line-modified-removed">-         break;</span>
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-     case F64: {</span>
<span class="udiff-line-modified-removed">-         CCallHelpers::JumpList done;</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         double (*convertToF64)(ExecState*, JSValue) = [] (ExecState* exec, JSValue v) -&gt; double {</span>
<span class="udiff-line-modified-removed">-             VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-removed">-             NativeCallFrameTracer tracer(vm, exec);</span>
<span class="udiff-line-modified-removed">-             return v.toNumber(exec);</span>
<span class="udiff-line-modified-removed">-         };</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         auto notANumber = jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters);</span>
<span class="udiff-line-modified-removed">-         auto isDouble = jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters);</span>
<span class="udiff-line-modified-removed">-         // We&#39;re an int32</span>
<span class="udiff-line-modified-removed">-         jit.signExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-removed">-         jit.convertInt64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);</span>
<span class="udiff-line-modified-removed">-         done.append(jit.jump());</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         isDouble.link(&amp;jit);</span>
<span class="udiff-line-modified-removed">-         jit.move(JIT::TrustedImm64(TagTypeNumber), GPRInfo::returnValueGPR2);</span>
<span class="udiff-line-modified-removed">-         jit.add64(GPRInfo::returnValueGPR2, GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-removed">-         jit.move64ToDouble(GPRInfo::returnValueGPR, FPRInfo::returnValueFPR);</span>
<span class="udiff-line-modified-removed">-         done.append(jit.jump());</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-modified-removed">-         notANumber.link(&amp;jit);</span>
<span class="udiff-line-modified-removed">-         jit.setupArguments&lt;decltype(convertToF64)&gt;(GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-removed">-         auto call = jit.call(OperationPtrTag);</span>
<span class="udiff-line-modified-removed">-         exceptionChecks.append(jit.emitJumpIfException(*vm));</span>
<span class="udiff-line-modified-added">+     if (signature.returnCount() == 1) {</span>
<span class="udiff-line-modified-added">+         switch (signature.returnType(0)) {</span>
<span class="udiff-line-modified-added">+         case Void:</span>
<span class="udiff-line-modified-added">+         case Func:</span>
<span class="udiff-line-modified-added">+             // For the JavaScript embedding, imports with these types in their signature return are a WebAssembly.Module validation error.</span>
<span class="udiff-line-modified-added">+             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="udiff-line-modified-added">+             break;</span>
<span class="udiff-line-modified-added">+         case I64: {</span>
<span class="udiff-line-modified-added">+             RELEASE_ASSERT_NOT_REACHED(); // Handled above.</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+         case I32: {</span>
<span class="udiff-line-modified-added">+             CCallHelpers::JumpList done;</span>
<span class="udiff-line-modified-added">+             CCallHelpers::JumpList slowPath;</span>
<span class="udiff-line-modified-added">+             GPRReg dest = wasmCallInfo.results[0].gpr();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             slowPath.append(jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters));</span>
<span class="udiff-line-modified-added">+             slowPath.append(jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters));</span>
<span class="udiff-line-modified-added">+             jit.zeroExtend32ToPtr(GPRInfo::returnValueGPR, dest);</span>
<span class="udiff-line-modified-added">+             done.append(jit.jump());</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             slowPath.link(&amp;jit);</span>
<span class="udiff-line-modified-added">+             jit.setupArguments&lt;decltype(operationConvertToI32)&gt;(GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-added">+             auto call = jit.call(OperationPtrTag);</span>
<span class="udiff-line-modified-added">+             exceptionChecks.append(jit.emitJumpIfException(vm));</span>
<span class="udiff-line-modified-added">+             jit.move(GPRInfo::returnValueGPR, dest);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {</span>
<span class="udiff-line-modified-added">+                 linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(operationConvertToI32));</span>
<span class="udiff-line-modified-added">+             });</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             done.link(&amp;jit);</span>
<span class="udiff-line-modified-added">+             break;</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+         case Funcref:</span>
<span class="udiff-line-modified-added">+         case Anyref:</span>
<span class="udiff-line-modified-added">+             jit.move(GPRInfo::returnValueGPR, wasmCallInfo.results[0].gpr());</span>
<span class="udiff-line-modified-added">+             break;</span>
<span class="udiff-line-modified-added">+         case F32: {</span>
<span class="udiff-line-modified-added">+             CCallHelpers::JumpList done;</span>
<span class="udiff-line-modified-added">+             FPRReg dest = wasmCallInfo.results[0].fpr();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             auto notANumber = jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters);</span>
<span class="udiff-line-modified-added">+             auto isDouble = jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters);</span>
<span class="udiff-line-modified-added">+             // We&#39;re an int32</span>
<span class="udiff-line-modified-added">+             jit.signExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-added">+             jit.convertInt64ToFloat(GPRInfo::returnValueGPR, dest);</span>
<span class="udiff-line-modified-added">+             done.append(jit.jump());</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             isDouble.link(&amp;jit);</span>
<span class="udiff-line-modified-added">+             jit.move(JIT::TrustedImm64(JSValue::NumberTag), GPRInfo::returnValueGPR2);</span>
<span class="udiff-line-modified-added">+             jit.add64(GPRInfo::returnValueGPR2, GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-added">+             jit.move64ToDouble(GPRInfo::returnValueGPR, dest);</span>
<span class="udiff-line-modified-added">+             jit.convertDoubleToFloat(dest, dest);</span>
<span class="udiff-line-modified-added">+             done.append(jit.jump());</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             notANumber.link(&amp;jit);</span>
<span class="udiff-line-modified-added">+             jit.setupArguments&lt;decltype(operationConvertToF32)&gt;(GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-added">+             auto call = jit.call(OperationPtrTag);</span>
<span class="udiff-line-modified-added">+             exceptionChecks.append(jit.emitJumpIfException(vm));</span>
<span class="udiff-line-modified-added">+             jit.move(FPRInfo::returnValueFPR , dest);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {</span>
<span class="udiff-line-modified-added">+                 linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(operationConvertToF32));</span>
<span class="udiff-line-modified-added">+             });</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             done.link(&amp;jit);</span>
<span class="udiff-line-modified-added">+             break;</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+         case F64: {</span>
<span class="udiff-line-modified-added">+             CCallHelpers::JumpList done;</span>
<span class="udiff-line-modified-added">+             FPRReg dest = wasmCallInfo.results[0].fpr();</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             auto notANumber = jit.branchIfNotNumber(GPRInfo::returnValueGPR, DoNotHaveTagRegisters);</span>
<span class="udiff-line-modified-added">+             auto isDouble = jit.branchIfNotInt32(JSValueRegs(GPRInfo::returnValueGPR), DoNotHaveTagRegisters);</span>
<span class="udiff-line-modified-added">+             // We&#39;re an int32</span>
<span class="udiff-line-modified-added">+             jit.signExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-added">+             jit.convertInt64ToDouble(GPRInfo::returnValueGPR, dest);</span>
<span class="udiff-line-modified-added">+             done.append(jit.jump());</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             isDouble.link(&amp;jit);</span>
<span class="udiff-line-modified-added">+             jit.move(JIT::TrustedImm64(JSValue::NumberTag), GPRInfo::returnValueGPR2);</span>
<span class="udiff-line-modified-added">+             jit.add64(GPRInfo::returnValueGPR2, GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-added">+             jit.move64ToDouble(GPRInfo::returnValueGPR, dest);</span>
<span class="udiff-line-modified-added">+             done.append(jit.jump());</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             notANumber.link(&amp;jit);</span>
<span class="udiff-line-modified-added">+             jit.setupArguments&lt;decltype(operationConvertToF64)&gt;(GPRInfo::returnValueGPR);</span>
<span class="udiff-line-modified-added">+             auto call = jit.call(OperationPtrTag);</span>
<span class="udiff-line-modified-added">+             exceptionChecks.append(jit.emitJumpIfException(vm));</span>
<span class="udiff-line-modified-added">+             jit.move(FPRInfo::returnValueFPR, dest);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {</span>
<span class="udiff-line-modified-added">+                 linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(operationConvertToF64));</span>
<span class="udiff-line-modified-added">+             });</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+             done.link(&amp;jit);</span>
<span class="udiff-line-modified-added">+             break;</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+         }</span>
<span class="udiff-line-modified-added">+     } else if (signature.returnCount() &gt; 1) {</span>
<span class="udiff-line-modified-added">+         GPRReg wasmContextInstanceGPR = PinnedRegisterInfo::get().wasmContextInstancePointer;</span>
<span class="udiff-line-modified-added">+         if (Context::useFastTLS()) {</span>
<span class="udiff-line-added">+             wasmContextInstanceGPR = GPRInfo::argumentGPR1;</span>
<span class="udiff-line-added">+             static_assert(std::is_same_v&lt;Wasm::Instance*, typename FunctionTraits&lt;decltype(operationIterateResults)&gt;::ArgumentType&lt;1&gt;&gt;, &quot;Instance should be the second parameter.&quot;);</span>
<span class="udiff-line-added">+             jit.loadWasmContextInstance(wasmContextInstanceGPR);</span>
<span class="udiff-line-added">+         }</span>
  
<span class="udiff-line-modified-removed">-         jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {</span>
<span class="udiff-line-modified-removed">-             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(convertToF64));</span>
<span class="udiff-line-modified-removed">-         });</span>
<span class="udiff-line-modified-added">+         jit.setupArguments&lt;decltype(operationIterateResults)&gt;(wasmContextInstanceGPR, &amp;signature, GPRInfo::returnValueGPR, CCallHelpers::stackPointerRegister, CCallHelpers::framePointerRegister);</span>
<span class="udiff-line-modified-added">+         jit.callOperation(FunctionPtr&lt;OperationPtrTag&gt;(operationIterateResults));</span>
<span class="udiff-line-modified-added">+         exceptionChecks.append(jit.emitJumpIfException(vm));</span>
  
<span class="udiff-line-modified-removed">-         done.link(&amp;jit);</span>
<span class="udiff-line-modified-removed">-         break;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+         for (RegisterAtOffset location : savedResultRegisters)</span>
<span class="udiff-line-modified-added">+             jit.load64ToReg(CCallHelpers::Address(CCallHelpers::stackPointerRegister, location.offset()), location.reg());</span>
      }
  
      jit.emitFunctionEpilogue();
      jit.ret();
  
      if (!exceptionChecks.empty()) {
          exceptionChecks.link(&amp;jit);
<span class="udiff-line-modified-removed">-         jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm-&gt;topEntryFrame);</span>
<span class="udiff-line-modified-added">+         jit.copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm.topEntryFrame);</span>
          jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
          auto call = jit.call(OperationPtrTag);
<span class="udiff-line-modified-removed">-         jit.jumpToExceptionHandler(*vm);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         void (*doUnwinding)(ExecState*) = [] (ExecState* exec) -&gt; void {</span>
<span class="udiff-line-removed">-             VM&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-removed">-             NativeCallFrameTracer tracer(vm, exec);</span>
<span class="udiff-line-removed">-             genericUnwind(vm, exec);</span>
<span class="udiff-line-removed">-             ASSERT(!!vm.callFrameForCatch);</span>
<span class="udiff-line-removed">-         };</span>
<span class="udiff-line-modified-added">+         jit.jumpToExceptionHandler(vm);</span>
  
          jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
<span class="udiff-line-modified-removed">-             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(doUnwinding));</span>
<span class="udiff-line-modified-added">+             linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(operationWasmUnwind));</span>
          });
      }
  
      LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID, JITCompilationCanFail);
      if (UNLIKELY(patchBuffer.didFailToAllocate()))
          return makeUnexpected(BindingFailure::OutOfMemory);
  
<span class="udiff-line-modified-removed">-     patchBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(vm-&gt;getCTIStub(linkCallThunkGenerator).code()));</span>
<span class="udiff-line-modified-added">+     patchBuffer.link(slowCall, FunctionPtr&lt;JITThunkPtrTag&gt;(vm.getCTIStub(linkCallThunkGenerator).code()));</span>
      CodeLocationLabel&lt;JSInternalPtrTag&gt; callReturnLocation(patchBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(slowCall));
      CodeLocationLabel&lt;JSInternalPtrTag&gt; hotPathBegin(patchBuffer.locationOf&lt;JSInternalPtrTag&gt;(targetToCheck));
      CodeLocationNearCall&lt;JSInternalPtrTag&gt; hotPathOther = patchBuffer.locationOfNearCall&lt;JSInternalPtrTag&gt;(fastCall);
      callLinkInfo-&gt;setCallLocations(callReturnLocation, hotPathBegin, hotPathOther);
  
<span class="udiff-line-modified-removed">-     return FINALIZE_CODE(patchBuffer, WasmEntryPtrTag, &quot;WebAssembly-&gt;JavaScript import[%i] %s&quot;, importIndex, signature.toString().ascii().data());</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void* wasmToJSException(ExecState* exec, Wasm::ExceptionType type, Instance* wasmInstance)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     wasmInstance-&gt;storeTopCallFrame(exec);</span>
<span class="udiff-line-removed">-     JSWebAssemblyInstance* instance = wasmInstance-&gt;owner&lt;JSWebAssemblyInstance&gt;();</span>
<span class="udiff-line-removed">-     JSGlobalObject* globalObject = instance-&gt;globalObject();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     // Do not retrieve VM&amp; from ExecState since ExecState&#39;s callee is not a JSCell.</span>
<span class="udiff-line-removed">-     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     {</span>
<span class="udiff-line-removed">-         auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-         JSObject* error;</span>
<span class="udiff-line-removed">-         if (type == ExceptionType::StackOverflow)</span>
<span class="udiff-line-removed">-             error = createStackOverflowError(exec, globalObject);</span>
<span class="udiff-line-removed">-         else</span>
<span class="udiff-line-removed">-             error = JSWebAssemblyRuntimeError::create(exec, vm, globalObject-&gt;webAssemblyRuntimeErrorStructure(), Wasm::errorMessageForExceptionType(type));</span>
<span class="udiff-line-removed">-         throwException(exec, throwScope, error);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     genericUnwind(vm, exec);</span>
<span class="udiff-line-removed">-     ASSERT(!!vm.callFrameForCatch);</span>
<span class="udiff-line-removed">-     ASSERT(!!vm.targetMachinePCForThrow);</span>
<span class="udiff-line-removed">-     // FIXME: We could make this better:</span>
<span class="udiff-line-removed">-     // This is a total hack, but the llint (both op_catch and handleUncaughtException)</span>
<span class="udiff-line-removed">-     // require a cell in the callee field to load the VM. (The baseline JIT does not require</span>
<span class="udiff-line-removed">-     // this since it is compiled with a constant VM pointer.) We could make the calling convention</span>
<span class="udiff-line-removed">-     // for exceptions first load callFrameForCatch info call frame register before jumping</span>
<span class="udiff-line-removed">-     // to the exception handler. If we did this, we could remove this terrible hack.</span>
<span class="udiff-line-removed">-     // https://bugs.webkit.org/show_bug.cgi?id=170440</span>
<span class="udiff-line-removed">-     bitwise_cast&lt;uint64_t*&gt;(exec)[CallFrameSlot::callee] = bitwise_cast&lt;uint64_t&gt;(instance-&gt;webAssemblyToJSCallee());</span>
<span class="udiff-line-removed">-     return vm.targetMachinePCForThrow;</span>
<span class="udiff-line-modified-added">+     return FINALIZE_WASM_CODE(patchBuffer, WasmEntryPtrTag, &quot;WebAssembly-&gt;JavaScript import[%i] %s&quot;, importIndex, signature.toString().ascii().data());</span>
  }
  
  void emitThrowWasmToJSException(CCallHelpers&amp; jit, GPRReg wasmInstance, Wasm::ExceptionType type)
  {
      ASSERT(wasmInstance != GPRInfo::argumentGPR0);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -714,11 +442,11 @@</span>
  
      jit.farJump(GPRInfo::returnValueGPR, ExceptionHandlerPtrTag);
      jit.breakpoint(); // We should not reach this.
  
      jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
<span class="udiff-line-modified-removed">-         linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(Wasm::wasmToJSException));</span>
<span class="udiff-line-modified-added">+         linkBuffer.link(call, FunctionPtr&lt;OperationPtrTag&gt;(Wasm::operationWasmToJSException));</span>
      });
  }
  
  } } // namespace JSC::Wasm
  
</pre>
<center><a href="JSWebAssemblyTable.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WasmToJS.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
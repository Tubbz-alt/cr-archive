<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLFunctionWriter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WHLSLEntryPointScaffolding.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLMetalCodeGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLFunctionWriter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 46 namespace WHLSL {
 47 
 48 namespace Metal {
 49 
 50 static void declareFunction(StringBuilder&amp; stringBuilder, AST::FunctionDeclaration&amp; functionDeclaration, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping)
 51 {
 52     if (functionDeclaration.entryPointType())
 53         return;
 54 
 55     auto iterator = functionMapping.find(&amp;functionDeclaration);
 56     ASSERT(iterator != functionMapping.end());
 57     stringBuilder.append(typeNamer.mangledNameForType(functionDeclaration.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);
 58     for (size_t i = 0; i &lt; functionDeclaration.parameters().size(); ++i) {
 59         if (i)
 60             stringBuilder.append(&quot;, &quot;);
 61         stringBuilder.append(typeNamer.mangledNameForType(*functionDeclaration.parameters()[i]-&gt;type()));
 62     }
 63     stringBuilder.append(&quot;);\n&quot;);
 64 }
 65 





 66 class FunctionDefinitionWriter : public Visitor {













































 67 public:
 68     FunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, Layout&amp; layout)
 69         : m_stringBuilder(stringBuilder)
 70         , m_intrinsics(intrinsics)
 71         , m_typeNamer(typeNamer)
 72         , m_functionMapping(functionMapping)
 73         , m_layout(layout)
 74     {
 75     }
 76 
 77     virtual ~FunctionDefinitionWriter() = default;
 78 
 79     void visit(AST::NativeFunctionDeclaration&amp;) override;
 80     void visit(AST::FunctionDefinition&amp;) override;
 81 
 82 protected:
 83     virtual std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) = 0;
 84 
 85     void visit(AST::FunctionDeclaration&amp;) override;
 86     void visit(AST::Statement&amp;) override;
 87     void visit(AST::Block&amp;) override;
 88     void visit(AST::Break&amp;) override;
 89     void visit(AST::Continue&amp;) override;
 90     void visit(AST::DoWhileLoop&amp;) override;
 91     void visit(AST::EffectfulExpressionStatement&amp;) override;
 92     void visit(AST::Fallthrough&amp;) override;
 93     void visit(AST::ForLoop&amp;) override;
 94     void visit(AST::IfStatement&amp;) override;
 95     void visit(AST::Return&amp;) override;
 96     void visit(AST::SwitchStatement&amp;) override;
 97     void visit(AST::SwitchCase&amp;) override;
 98     void visit(AST::VariableDeclarationsStatement&amp;) override;
 99     void visit(AST::WhileLoop&amp;) override;
100     void visit(AST::IntegerLiteral&amp;) override;
101     void visit(AST::UnsignedIntegerLiteral&amp;) override;
102     void visit(AST::FloatLiteral&amp;) override;
<span class="line-removed">103     void visit(AST::NullLiteral&amp;) override;</span>
104     void visit(AST::BooleanLiteral&amp;) override;
105     void visit(AST::EnumerationMemberLiteral&amp;) override;
106     void visit(AST::Expression&amp;) override;
<span class="line-removed">107     void visit(AST::DotExpression&amp;) override;</span>
108     void visit(AST::GlobalVariableReference&amp;) override;

109     void visit(AST::IndexExpression&amp;) override;
<span class="line-removed">110     void visit(AST::PropertyAccessExpression&amp;) override;</span>
111     void visit(AST::VariableDeclaration&amp;) override;
112     void visit(AST::AssignmentExpression&amp;) override;
113     void visit(AST::CallExpression&amp;) override;
114     void visit(AST::CommaExpression&amp;) override;
115     void visit(AST::DereferenceExpression&amp;) override;
116     void visit(AST::LogicalExpression&amp;) override;
117     void visit(AST::LogicalNotExpression&amp;) override;
118     void visit(AST::MakeArrayReferenceExpression&amp;) override;
119     void visit(AST::MakePointerExpression&amp;) override;
120     void visit(AST::ReadModifyWriteExpression&amp;) override;
121     void visit(AST::TernaryExpression&amp;) override;
122     void visit(AST::VariableReference&amp;) override;
123 
124     enum class LoopConditionLocation {
125         BeforeBody,
126         AfterBody
127     };
128     void emitLoop(LoopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body);
129 
130     void emitConstantExpressionString(AST::ConstantExpression&amp;);
131 
132     MangledVariableName generateNextVariableName() { return { m_variableCount++ }; }
133 
<span class="line-removed">134     enum class Nullability : uint8_t {</span>
<span class="line-removed">135         NotNull,</span>
<span class="line-removed">136         CanBeNull</span>
<span class="line-removed">137     };</span>
<span class="line-removed">138 </span>
<span class="line-removed">139     struct StackItem {</span>
<span class="line-removed">140         MangledVariableName value;</span>
<span class="line-removed">141         MangledVariableName leftValue;</span>
<span class="line-removed">142         Nullability valueNullability;</span>
<span class="line-removed">143         Nullability leftValueNullability;</span>
<span class="line-removed">144         std::function&lt;MangledVariableName()&gt; generateLeftValue;</span>
<span class="line-removed">145     };</span>
<span class="line-removed">146 </span>
<span class="line-removed">147     struct StackValue {</span>
<span class="line-removed">148         MangledVariableName value;</span>
<span class="line-removed">149         Nullability nullability;</span>
<span class="line-removed">150     };</span>
<span class="line-removed">151 </span>
<span class="line-removed">152     // This is the important data flow step where we can take the nullability of an lvalue</span>
<span class="line-removed">153     // and transfer it into the nullability of an rvalue. This is conveyed in MakePointerExpression</span>
<span class="line-removed">154     // and DereferenceExpression. MakePointerExpression will try to produce rvalues which are</span>
<span class="line-removed">155     // non-null, and DereferenceExpression will take a non-null rvalue and try to produce</span>
<span class="line-removed">156     // a non-null lvalue.</span>
<span class="line-removed">157     void appendRightValueWithNullability(AST::Expression&amp;, MangledVariableName value, Nullability nullability)</span>
<span class="line-removed">158     {</span>
<span class="line-removed">159         m_stack.append({ WTFMove(value), { }, nullability, Nullability::CanBeNull, { } });</span>
<span class="line-removed">160     }</span>
<span class="line-removed">161 </span>
<span class="line-removed">162     void appendRightValue(AST::Expression&amp; expression, MangledVariableName value)</span>
<span class="line-removed">163     {</span>
<span class="line-removed">164         appendRightValueWithNullability(expression, WTFMove(value), Nullability::CanBeNull);</span>
<span class="line-removed">165     }</span>
<span class="line-removed">166 </span>
<span class="line-removed">167     void appendLeftValue(AST::Expression&amp; expression, MangledVariableName value, MangledVariableName leftValue, Nullability nullability, std::function&lt;MangledVariableName()&gt; generateLeftValue = { })</span>
<span class="line-removed">168     {</span>
<span class="line-removed">169         ASSERT_UNUSED(expression, expression.typeAnnotation().leftAddressSpace());</span>
<span class="line-removed">170         ASSERT(leftValue || generateLeftValue);</span>
<span class="line-removed">171         m_stack.append({ WTFMove(value), WTFMove(leftValue), Nullability::CanBeNull, nullability, WTFMove(generateLeftValue) });</span>
<span class="line-removed">172     }</span>
<span class="line-removed">173 </span>
<span class="line-removed">174     MangledVariableName takeLastValue()</span>
<span class="line-removed">175     {</span>
<span class="line-removed">176         return m_stack.takeLast().value;</span>
<span class="line-removed">177     }</span>
<span class="line-removed">178 </span>
<span class="line-removed">179     StackValue takeLastValueAndNullability()</span>
<span class="line-removed">180     {</span>
<span class="line-removed">181         auto last = m_stack.takeLast();</span>
<span class="line-removed">182         return { last.value, last.valueNullability };</span>
<span class="line-removed">183     }</span>
<span class="line-removed">184 </span>
<span class="line-removed">185     StackValue takeLastLeftValue()</span>
<span class="line-removed">186     {</span>
<span class="line-removed">187         auto last = m_stack.takeLast();</span>
<span class="line-removed">188         if (!last.leftValue)</span>
<span class="line-removed">189             last.leftValue = last.generateLeftValue();</span>
<span class="line-removed">190         return { last.leftValue, last.leftValueNullability };</span>
<span class="line-removed">191     }</span>
<span class="line-removed">192 </span>
193     enum class BreakContext {
194         Loop,
195         Switch
196     };
197 
198     Optional&lt;BreakContext&gt; m_currentBreakContext;
199 
200     StringBuilder&amp; m_stringBuilder;
201     Intrinsics&amp; m_intrinsics;
202     TypeNamer&amp; m_typeNamer;
203     HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; m_functionMapping;
204     HashMap&lt;AST::VariableDeclaration*, MangledVariableName&gt; m_variableMapping;
205 
<span class="line-removed">206     Vector&lt;StackItem&gt; m_stack;</span>
207     std::unique_ptr&lt;EntryPointScaffolding&gt; m_entryPointScaffolding;
208     Layout&amp; m_layout;
209     unsigned m_variableCount { 0 };
210     Optional&lt;MangledVariableName&gt; m_breakOutOfCurrentLoopEarlyVariable;
211     Indentation&lt;4&gt; m_indent { 0 };

212 };
213 
214 void FunctionDefinitionWriter::visit(AST::NativeFunctionDeclaration&amp;)
215 {
216     // We inline native function calls.
217 }
218 
219 void FunctionDefinitionWriter::visit(AST::FunctionDefinition&amp; functionDefinition)
220 {














221     auto iterator = m_functionMapping.find(&amp;functionDefinition);
222     ASSERT(iterator != m_functionMapping.end());
223     if (functionDefinition.entryPointType()) {
224         auto entryPointScaffolding = createEntryPointScaffolding(functionDefinition);
225         if (!entryPointScaffolding)
226             return;
227         m_entryPointScaffolding = WTFMove(entryPointScaffolding);
228 
229         m_entryPointScaffolding-&gt;emitHelperTypes(m_stringBuilder, m_indent);
230         m_entryPointScaffolding-&gt;emitSignature(m_stringBuilder, iterator-&gt;value, m_indent);
231         m_stringBuilder.append(m_indent, &quot;{\n&quot;);
232         {
233             IndentationScope scope(m_indent);
234 
235             m_entryPointScaffolding-&gt;emitUnpack(m_stringBuilder, m_indent);
236 
237             for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
238                 auto addResult = m_variableMapping.add(&amp;functionDefinition.parameters()[i], m_entryPointScaffolding-&gt;parameterVariables()[i]);
239                 ASSERT_UNUSED(addResult, addResult.isNewEntry);
240             }



241             checkErrorAndVisit(functionDefinition.block());
<span class="line-removed">242             ASSERT(m_stack.isEmpty());</span>
243         }
244         m_stringBuilder.append(&quot;}\n\n&quot;);
245 
246         m_entryPointScaffolding = nullptr;
247     } else {
248         ASSERT(m_entryPointScaffolding == nullptr);
249         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(functionDefinition.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);
250         for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
<span class="line-removed">251             auto&amp; parameter = functionDefinition.parameters()[i];</span>
252             if (i)
253                 m_stringBuilder.append(&quot;, &quot;);

254             auto parameterName = generateNextVariableName();
255             auto addResult = m_variableMapping.add(&amp;parameter, parameterName);
256             ASSERT_UNUSED(addResult, addResult.isNewEntry);
257             m_stringBuilder.append(m_typeNamer.mangledNameForType(*parameter-&gt;type()), &#39; &#39;, parameterName);
258         }
259         m_stringBuilder.append(&quot;)\n&quot;);





260         checkErrorAndVisit(functionDefinition.block());
<span class="line-modified">261         ASSERT(m_stack.isEmpty());</span>
262         m_stringBuilder.append(&#39;\n&#39;);
263     }
264 }
265 
266 void FunctionDefinitionWriter::visit(AST::FunctionDeclaration&amp;)
267 {
268     ASSERT_NOT_REACHED();
269 }
270 
271 void FunctionDefinitionWriter::visit(AST::Statement&amp; statement)
272 {
273     Visitor::visit(statement);
274 }
275 
276 void FunctionDefinitionWriter::visit(AST::Block&amp; block)
277 {
278     m_stringBuilder.append(m_indent, &quot;{\n&quot;);
279     {
280         IndentationScope scope(m_indent);
281         for (auto&amp; statement : block.statements())
</pre>
<hr />
<pre>
292         m_stringBuilder.append(m_indent, &quot;break;\n&quot;);
293         break;
294     case BreakContext::Loop:
295         ASSERT(m_breakOutOfCurrentLoopEarlyVariable);
296         m_stringBuilder.append(
297             m_indent, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = true;\n&quot;,
298             m_indent, &quot;break;\n&quot;
299         );
300         break;
301     }
302 }
303 
304 void FunctionDefinitionWriter::visit(AST::Continue&amp;)
305 {
306     ASSERT(m_breakOutOfCurrentLoopEarlyVariable);
307     m_stringBuilder.append(m_indent, &quot;break;\n&quot;);
308 }
309 
310 void FunctionDefinitionWriter::visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement)
311 {

312     checkErrorAndVisit(effectfulExpressionStatement.effectfulExpression());
<span class="line-modified">313     takeLastValue(); // The statement is already effectful, so we don&#39;t need to do anything with the result.</span>
314 }
315 
316 void FunctionDefinitionWriter::visit(AST::Fallthrough&amp;)
317 {
318     m_stringBuilder.append(m_indent, &quot;[[clang::fallthrough]];\n&quot;); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195808 Make sure this is okay. Alternatively, we could do nothing and just return here instead.
319 }
320 
321 void FunctionDefinitionWriter::emitLoop(LoopConditionLocation loopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body)
322 {
323     SetForScope&lt;Optional&lt;MangledVariableName&gt;&gt; loopVariableScope(m_breakOutOfCurrentLoopEarlyVariable, generateNextVariableName());
324 
325     m_stringBuilder.append(
326         m_indent, &quot;bool &quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = false;\n&quot;,
327         m_indent, &quot;while (true) {\n&quot;
328     );
329     {
330         IndentationScope whileScope(m_indent);
331 
332         if (loopConditionLocation == LoopConditionLocation::BeforeBody &amp;&amp; conditionExpression) {


333             checkErrorAndVisit(*conditionExpression);
334             m_stringBuilder.append(
<span class="line-modified">335                 m_indent, &quot;if (!&quot;, takeLastValue(), &quot;)\n&quot;,</span>
<span class="line-modified">336                 m_indent, &quot;    break;\n&quot;);</span>
337         }
338 
339         m_stringBuilder.append(m_indent, &quot;do {\n&quot;);
340         SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Loop);
341 
342         {
343             IndentationScope doScope(m_indent);
344             checkErrorAndVisit(body);
345         }
346         m_stringBuilder.append(m_indent, &quot;} while(false); \n&quot;);
347 
348         m_stringBuilder.append(
349             m_indent, &quot;if (&quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot;)\n&quot;,
350             m_indent, &quot;    break;\n&quot;);
351 
352         if (increment) {

353             checkErrorAndVisit(*increment);
<span class="line-modified">354             // Expression results get pushed to m_stack. We don&#39;t use the result</span>
<span class="line-removed">355             // of increment, so we dispense of that now.</span>
<span class="line-removed">356             takeLastValue();</span>
357         }
358 
359         if (loopConditionLocation == LoopConditionLocation::AfterBody &amp;&amp; conditionExpression) {


360             checkErrorAndVisit(*conditionExpression);
361             m_stringBuilder.append(
<span class="line-modified">362                 m_indent, &quot;if (!&quot;, takeLastValue(), &quot;)\n&quot;,</span>
<span class="line-modified">363                 m_indent, &quot;    break;\n&quot;);</span>
364         }
365     }
366 
367     m_stringBuilder.append(m_indent, &quot;} \n&quot;);
368 }
369 
370 void FunctionDefinitionWriter::visit(AST::DoWhileLoop&amp; doWhileLoop)
371 {
372     emitLoop(LoopConditionLocation::AfterBody, &amp;doWhileLoop.conditional(), nullptr, doWhileLoop.body());
373 }
374 
375 void FunctionDefinitionWriter::visit(AST::WhileLoop&amp; whileLoop)
376 {
377     emitLoop(LoopConditionLocation::BeforeBody, &amp;whileLoop.conditional(), nullptr, whileLoop.body());
378 }
379 
380 void FunctionDefinitionWriter::visit(AST::ForLoop&amp; forLoop)
381 {
382     m_stringBuilder.append(m_indent, &quot;{\n&quot;);
383     {
384         IndentationScope scope(m_indent);
385         checkErrorAndVisit(forLoop.initialization());
386         emitLoop(LoopConditionLocation::BeforeBody, forLoop.condition(), forLoop.increment(), forLoop.body());
387     }
388     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
389 }
390 
391 void FunctionDefinitionWriter::visit(AST::IfStatement&amp; ifStatement)
392 {

393     checkErrorAndVisit(ifStatement.conditional());
<span class="line-modified">394     m_stringBuilder.append(m_indent, &quot;if (&quot;, takeLastValue(), &quot;) {\n&quot;);</span>

395     {
396         IndentationScope ifScope(m_indent);
397         checkErrorAndVisit(ifStatement.body());
398     }

399     if (ifStatement.elseBody()) {
400         m_stringBuilder.append(m_indent, &quot;} else {\n&quot;);
401         {
402             IndentationScope elseScope(m_indent);
403             checkErrorAndVisit(*ifStatement.elseBody());
404         }
405     }

406     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
407 }
408 
409 void FunctionDefinitionWriter::visit(AST::Return&amp; returnStatement)
410 {
411     if (returnStatement.value()) {


412         checkErrorAndVisit(*returnStatement.value());

413 
414         if (m_entryPointScaffolding) {
415             auto variableName = generateNextVariableName();
<span class="line-modified">416             m_entryPointScaffolding-&gt;emitPack(m_stringBuilder, takeLastValue(), variableName, m_indent);</span>
417             m_stringBuilder.append(m_indent, &quot;return &quot;, variableName, &quot;;\n&quot;);
418         } else
<span class="line-modified">419             m_stringBuilder.append(m_indent, &quot;return &quot;, takeLastValue(), &quot;;\n&quot;);</span>
420     } else
421         m_stringBuilder.append(m_indent, &quot;return;\n&quot;);
422 }
423 
424 void FunctionDefinitionWriter::visit(AST::SwitchStatement&amp; switchStatement)
425 {

426     checkErrorAndVisit(switchStatement.value());

427 
<span class="line-removed">428     m_stringBuilder.append(m_indent, &quot;switch (&quot;, takeLastValue(), &quot;) {&quot;);</span>
429     {
430         IndentationScope switchScope(m_indent);
431         for (auto&amp; switchCase : switchStatement.switchCases())
432             checkErrorAndVisit(switchCase);
433     }
434     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
435 }
436 
437 void FunctionDefinitionWriter::visit(AST::SwitchCase&amp; switchCase)
438 {
439     if (switchCase.value()) {
440         m_stringBuilder.append(m_indent, &quot;case &quot;);
441         emitConstantExpressionString(*switchCase.value());
442         m_stringBuilder.append(&quot;:\n&quot;);
443     } else
444         m_stringBuilder.append(m_indent, &quot;default:\n&quot;);
445     SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Switch);
446     checkErrorAndVisit(switchCase.block());
447     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195812 Figure out whether we need to break or fallthrough.
448 }
449 
450 void FunctionDefinitionWriter::visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement)
451 {
452     Visitor::visit(variableDeclarationsStatement);
453 }
454 
455 void FunctionDefinitionWriter::visit(AST::IntegerLiteral&amp; integerLiteral)
456 {
<span class="line-removed">457     auto variableName = generateNextVariableName();</span>
458     auto mangledTypeName = m_typeNamer.mangledNameForType(integerLiteral.resolvedType());
<span class="line-modified">459     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, integerLiteral.value(), &quot;);\n&quot;);</span>
<span class="line-removed">460     appendRightValue(integerLiteral, variableName);</span>
461 }
462 
463 void FunctionDefinitionWriter::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
464 {
<span class="line-removed">465     auto variableName = generateNextVariableName();</span>
466     auto mangledTypeName = m_typeNamer.mangledNameForType(unsignedIntegerLiteral.resolvedType());
<span class="line-modified">467     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, unsignedIntegerLiteral.value(), &quot;);\n&quot;);</span>
<span class="line-removed">468     appendRightValue(unsignedIntegerLiteral, variableName);</span>
469 }
470 
471 void FunctionDefinitionWriter::visit(AST::FloatLiteral&amp; floatLiteral)
472 {
<span class="line-removed">473     auto variableName = generateNextVariableName();</span>
474     auto mangledTypeName = m_typeNamer.mangledNameForType(floatLiteral.resolvedType());
<span class="line-modified">475     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, floatLiteral.value(), &quot;);\n&quot;);</span>
<span class="line-removed">476     appendRightValue(floatLiteral, variableName);</span>
<span class="line-removed">477 }</span>
<span class="line-removed">478 </span>
<span class="line-removed">479 void FunctionDefinitionWriter::visit(AST::NullLiteral&amp; nullLiteral)</span>
<span class="line-removed">480 {</span>
<span class="line-removed">481     auto&amp; unifyNode = nullLiteral.resolvedType().unifyNode();</span>
<span class="line-removed">482     auto&amp; unnamedType = downcast&lt;AST::UnnamedType&gt;(unifyNode);</span>
<span class="line-removed">483     bool isArrayReferenceType = is&lt;AST::ArrayReferenceType&gt;(unnamedType);</span>
<span class="line-removed">484 </span>
<span class="line-removed">485     auto variableName = generateNextVariableName();</span>
<span class="line-removed">486     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(nullLiteral.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;);</span>
<span class="line-removed">487     if (isArrayReferenceType)</span>
<span class="line-removed">488         m_stringBuilder.append(&quot;{ nullptr, 0 };\n&quot;);</span>
<span class="line-removed">489     else</span>
<span class="line-removed">490         m_stringBuilder.append(&quot;nullptr;\n&quot;);</span>
<span class="line-removed">491     appendRightValue(nullLiteral, variableName);</span>
492 }
493 
494 void FunctionDefinitionWriter::visit(AST::BooleanLiteral&amp; booleanLiteral)
495 {
<span class="line-removed">496     auto variableName = generateNextVariableName();</span>
497     auto mangledTypeName = m_typeNamer.mangledNameForType(booleanLiteral.resolvedType());
<span class="line-modified">498     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, booleanLiteral.value() ? &quot;true&quot; : &quot;false&quot;, &quot;);\n&quot;);</span>
<span class="line-removed">499     appendRightValue(booleanLiteral, variableName);</span>
500 }
501 
502 void FunctionDefinitionWriter::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
503 {
504     ASSERT(enumerationMemberLiteral.enumerationDefinition());
505     ASSERT(enumerationMemberLiteral.enumerationDefinition());
<span class="line-removed">506     auto variableName = generateNextVariableName();</span>
507     auto mangledTypeName = m_typeNamer.mangledNameForType(enumerationMemberLiteral.resolvedType());
<span class="line-modified">508     m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, mangledTypeName, &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()), &quot;;\n&quot;);</span>
<span class="line-removed">509     appendRightValue(enumerationMemberLiteral, variableName);</span>
510 }
511 
512 void FunctionDefinitionWriter::visit(AST::Expression&amp; expression)
513 {
514     Visitor::visit(expression);
515 }
516 
<span class="line-removed">517 void FunctionDefinitionWriter::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-removed">518 {</span>
<span class="line-removed">519     // This should be lowered already.</span>
<span class="line-removed">520     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="line-removed">521     notImplemented();</span>
<span class="line-removed">522     appendRightValue(dotExpression, generateNextVariableName());</span>
<span class="line-removed">523 }</span>
<span class="line-removed">524 </span>
525 void FunctionDefinitionWriter::visit(AST::GlobalVariableReference&amp; globalVariableReference)
526 {
<span class="line-modified">527     auto valueName = generateNextVariableName();</span>
<span class="line-modified">528     MangledTypeName mangledTypeName = m_typeNamer.mangledNameForType(globalVariableReference.resolvedType());</span>
<span class="line-removed">529 </span>
530     checkErrorAndVisit(globalVariableReference.base());
<span class="line-modified">531     MangledVariableName structVariable = takeLastValue();</span>

532 
<span class="line-modified">533     MangledStructureElementName mangledFieldName = m_typeNamer.mangledNameForStructureElement(globalVariableReference.structField());</span>


534 
<span class="line-modified">535     m_stringBuilder.append(</span>
<span class="line-modified">536         m_indent, mangledTypeName, &#39; &#39;, valueName, &quot; = &quot;, structVariable, &quot;-&gt;&quot;, mangledFieldName, &quot;;\n&quot;);</span>



537 
<span class="line-modified">538     appendLeftValue(globalVariableReference, valueName, { }, Nullability::NotNull,</span>
<span class="line-modified">539         [this, mangledTypeName, structVariable, mangledFieldName] {</span>
<span class="line-modified">540             auto pointerName = generateNextVariableName();</span>
<span class="line-modified">541             m_stringBuilder.append(</span>
<span class="line-modified">542                 m_indent, &quot;thread &quot;, mangledTypeName, &quot;* &quot;, pointerName, &quot; = &amp;&quot;, structVariable, &quot;-&gt;&quot;, mangledFieldName, &quot;;\n&quot;);</span>
<span class="line-modified">543             return pointerName;</span>
<span class="line-modified">544         });</span>


















545 }
546 
547 void FunctionDefinitionWriter::visit(AST::IndexExpression&amp; indexExpression)
548 {
<span class="line-modified">549     // This should be lowered already.</span>
<span class="line-modified">550     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="line-modified">551     notImplemented();</span>
<span class="line-modified">552     appendRightValue(indexExpression, generateNextVariableName());</span>
<span class="line-modified">553 }</span>
<span class="line-modified">554 </span>
<span class="line-modified">555 void FunctionDefinitionWriter::visit(AST::PropertyAccessExpression&amp; propertyAccessExpression)</span>
<span class="line-modified">556 {</span>
<span class="line-modified">557     // This should be lowered already.</span>
<span class="line-modified">558     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195788 Replace this with ASSERT_NOT_REACHED().</span>
<span class="line-modified">559     notImplemented();</span>
<span class="line-modified">560     appendRightValue(propertyAccessExpression, generateNextVariableName());</span>


























561 }
562 
563 void FunctionDefinitionWriter::visit(AST::VariableDeclaration&amp; variableDeclaration)
564 {
565     ASSERT(variableDeclaration.type());
566     auto variableName = generateNextVariableName();
567     auto addResult = m_variableMapping.add(&amp;variableDeclaration, variableName);
568     ASSERT_UNUSED(addResult, addResult.isNewEntry);
569     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198160 Implement qualifiers.
570     if (variableDeclaration.initializer()) {

571         checkErrorAndVisit(*variableDeclaration.initializer());
<span class="line-modified">572         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = &quot;, takeLastValue(), &quot;;\n&quot;);</span>
573     } else
574         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = { };\n&quot;);
575 }
576 
577 void FunctionDefinitionWriter::visit(AST::AssignmentExpression&amp; assignmentExpression)
578 {

579     checkErrorAndVisit(assignmentExpression.left());
<span class="line-modified">580     auto [pointerName, nullability] = takeLastLeftValue();</span>

581     checkErrorAndVisit(assignmentExpression.right());
<span class="line-modified">582     auto [rightName, rightNullability] = takeLastValueAndNullability();</span>
<span class="line-removed">583 </span>
<span class="line-removed">584     if (nullability == Nullability::CanBeNull)</span>
<span class="line-removed">585         m_stringBuilder.append(</span>
<span class="line-removed">586             m_indent, &quot;if (&quot;, pointerName, &quot;)\n&quot;,</span>
<span class="line-removed">587             m_indent, &quot;    *&quot;, pointerName, &quot; = &quot;, rightName, &quot;;\n&quot;);</span>
<span class="line-removed">588     else</span>
<span class="line-removed">589         m_stringBuilder.append(m_indent, &quot;*&quot;, pointerName, &quot; = &quot;, rightName, &quot;;\n&quot;);</span>
<span class="line-removed">590     appendRightValueWithNullability(assignmentExpression, rightName, rightNullability);</span>
591 }
592 
593 void FunctionDefinitionWriter::visit(AST::CallExpression&amp; callExpression)
594 {




595     Vector&lt;MangledVariableName&gt; argumentNames;
<span class="line-removed">596     for (auto&amp; argument : callExpression.arguments()) {</span>
<span class="line-removed">597         checkErrorAndVisit(argument);</span>
<span class="line-removed">598         argumentNames.append(takeLastValue());</span>
<span class="line-removed">599     }</span>
600 
<span class="line-modified">601     bool isVoid = matches(callExpression.resolvedType(), m_intrinsics.voidType());</span>
<span class="line-modified">602     MangledVariableName returnName;</span>
<span class="line-modified">603     if (!isVoid) {</span>
<span class="line-modified">604         returnName = generateNextVariableName();</span>
<span class="line-modified">605         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(callExpression.resolvedType()), &#39; &#39;, returnName, &quot;;\n&quot;);</span>





606     }
607 
608     if (is&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function())) {
<span class="line-modified">609         auto generateNextVariableName = [this]() -&gt; MangledVariableName {</span>
<span class="line-removed">610             return this-&gt;generateNextVariableName();</span>
<span class="line-removed">611         };</span>
<span class="line-removed">612 </span>
<span class="line-removed">613         m_stringBuilder.append(&#39;\n&#39;);</span>
<span class="line-removed">614         inlineNativeFunction(m_stringBuilder, downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()), returnName, argumentNames, m_intrinsics, m_typeNamer, WTFMove(generateNextVariableName), m_indent);</span>
<span class="line-removed">615         m_stringBuilder.append(&#39;\n&#39;);</span>
616     } else {
<span class="line-removed">617         m_stringBuilder.append(m_indent);</span>
<span class="line-removed">618 </span>
619         auto iterator = m_functionMapping.find(&amp;callExpression.function());
620         ASSERT(iterator != m_functionMapping.end());
<span class="line-removed">621         if (!isVoid)</span>
<span class="line-removed">622             m_stringBuilder.append(returnName, &quot; = &quot;);</span>
623         m_stringBuilder.append(iterator-&gt;value, &#39;(&#39;);
<span class="line-modified">624         for (size_t i = 0; i &lt; argumentNames.size(); ++i) {</span>
625             if (i)
626                 m_stringBuilder.append(&quot;, &quot;);
<span class="line-modified">627             m_stringBuilder.append(argumentNames[i]);</span>
628         }
<span class="line-modified">629         m_stringBuilder.append(&quot;);\n&quot;);</span>
630     }
631 
<span class="line-modified">632     appendRightValue(callExpression, returnName);</span>
633 }
634 
635 void FunctionDefinitionWriter::visit(AST::CommaExpression&amp; commaExpression)
636 {
<span class="line-modified">637     Optional&lt;MangledVariableName&gt; result;</span>

638     for (auto&amp; expression : commaExpression.list()) {



639         checkErrorAndVisit(expression);
<span class="line-removed">640         result = takeLastValue();</span>
641     }
<span class="line-modified">642     ASSERT(result);</span>
<span class="line-removed">643     appendRightValue(commaExpression, *result);</span>
644 }
645 
646 void FunctionDefinitionWriter::visit(AST::DereferenceExpression&amp; dereferenceExpression)
647 {

648     checkErrorAndVisit(dereferenceExpression.pointer());
<span class="line-modified">649     auto [inputPointer, nullability] = takeLastValueAndNullability();</span>
<span class="line-removed">650     auto resultValue = generateNextVariableName();</span>
<span class="line-removed">651     auto resultType = m_typeNamer.mangledNameForType(dereferenceExpression.resolvedType());</span>
<span class="line-removed">652 </span>
<span class="line-removed">653     if (nullability == Nullability::CanBeNull) {</span>
<span class="line-removed">654         m_stringBuilder.append(</span>
<span class="line-removed">655             m_indent, resultType , &#39; &#39;, resultValue, &quot; = &quot;, inputPointer, &quot; ? &quot;, &#39;*&#39;, inputPointer, &quot; : &quot;, resultType, &quot;{ };\n&quot;);</span>
<span class="line-removed">656     } else</span>
<span class="line-removed">657         m_stringBuilder.append(m_indent, resultValue, &quot; = *&quot;, inputPointer, &quot;;\n&quot;);</span>
<span class="line-removed">658 </span>
<span class="line-removed">659     appendLeftValue(dereferenceExpression, resultValue, inputPointer, nullability);</span>
660 }
661 
662 void FunctionDefinitionWriter::visit(AST::LogicalExpression&amp; logicalExpression)
663 {

664     checkErrorAndVisit(logicalExpression.left());
<span class="line-modified">665     auto left = takeLastValue();</span>
<span class="line-removed">666     checkErrorAndVisit(logicalExpression.right());</span>
<span class="line-removed">667     auto right = takeLastValue();</span>
<span class="line-removed">668     auto variableName = generateNextVariableName();</span>
669 
<span class="line-removed">670     m_stringBuilder.append(</span>
<span class="line-removed">671         m_indent, m_typeNamer.mangledNameForType(logicalExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, left);</span>
672     switch (logicalExpression.type()) {
673     case AST::LogicalExpression::Type::And:
674         m_stringBuilder.append(&quot; &amp;&amp; &quot;);
675         break;
<span class="line-modified">676     default:</span>
<span class="line-removed">677         ASSERT(logicalExpression.type() == AST::LogicalExpression::Type::Or);</span>
678         m_stringBuilder.append(&quot; || &quot;);
679         break;
680     }
<span class="line-modified">681     m_stringBuilder.append(right, &quot;;\n&quot;);</span>
<span class="line-modified">682     appendRightValue(logicalExpression, variableName);</span>


683 }
684 
685 void FunctionDefinitionWriter::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
686 {

687     checkErrorAndVisit(logicalNotExpression.operand());
<span class="line-modified">688     auto operand = takeLastValue();</span>
<span class="line-removed">689     auto variableName = generateNextVariableName();</span>
<span class="line-removed">690 </span>
<span class="line-removed">691     m_stringBuilder.append(</span>
<span class="line-removed">692         m_indent, m_typeNamer.mangledNameForType(logicalNotExpression.resolvedType()), &#39; &#39;, variableName, &quot; = !&quot;, operand, &quot;;\n&quot;);</span>
<span class="line-removed">693     appendRightValue(logicalNotExpression, variableName);</span>
694 }
695 
696 void FunctionDefinitionWriter::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
697 {
<span class="line-removed">698     checkErrorAndVisit(makeArrayReferenceExpression.leftValue());</span>
699     // FIXME: This needs to be made to work. It probably should be using the last leftValue too.
700     // https://bugs.webkit.org/show_bug.cgi?id=198838
<span class="line-removed">701     auto variableName = generateNextVariableName();</span>
<span class="line-removed">702 </span>
703     auto mangledTypeName = m_typeNamer.mangledNameForType(makeArrayReferenceExpression.resolvedType());
704     if (is&lt;AST::PointerType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {
<span class="line-modified">705         auto ptrValue = takeLastValue();</span>
<span class="line-modified">706         m_stringBuilder.append(</span>
<span class="line-modified">707             m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = &quot;, ptrValue, &quot; ? &quot;, mangledTypeName, &quot;{ &quot;, ptrValue, &quot;, 1 } : &quot;, mangledTypeName, &quot;{ nullptr, 0 };\n&quot;);</span>
708     } else if (is&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {
<span class="line-removed">709         auto lValue = takeLastLeftValue().value;</span>
710         auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType());
<span class="line-modified">711         m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;-&gt;data(), &quot;, arrayType.numElements(), &quot; };\n&quot;);</span>


712     } else {
<span class="line-modified">713         auto lValue = takeLastLeftValue().value;</span>
<span class="line-modified">714         m_stringBuilder.append(m_indent, mangledTypeName, &#39; &#39;, variableName, &quot; = { &quot;, lValue, &quot;, 1 };\n&quot;);</span>

715     }
<span class="line-removed">716     appendRightValue(makeArrayReferenceExpression, variableName);</span>
717 }
718 
719 void FunctionDefinitionWriter::visit(AST::MakePointerExpression&amp; makePointerExpression)
720 {

721     checkErrorAndVisit(makePointerExpression.leftValue());
<span class="line-modified">722     auto [pointer, nullability] = takeLastLeftValue();</span>
<span class="line-removed">723     auto variableName = generateNextVariableName();</span>
<span class="line-removed">724     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(makePointerExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, pointer, &quot;;\n&quot;);</span>
<span class="line-removed">725     appendRightValueWithNullability(makePointerExpression, variableName, nullability);</span>
726 }
727 
<span class="line-modified">728 void FunctionDefinitionWriter::visit(AST::ReadModifyWriteExpression&amp;)</span>
729 {
<span class="line-modified">730     // This should be lowered already.</span>
<span class="line-modified">731     ASSERT_NOT_REACHED();</span>

































732 }
733 
734 void FunctionDefinitionWriter::visit(AST::TernaryExpression&amp; ternaryExpression)
735 {

736     checkErrorAndVisit(ternaryExpression.predicate());
<span class="line-modified">737     auto check = takeLastValue();</span>
738     checkErrorAndVisit(ternaryExpression.bodyExpression());
<span class="line-modified">739     auto body = takeLastValue();</span>
740     checkErrorAndVisit(ternaryExpression.elseExpression());
<span class="line-modified">741     auto elseBody = takeLastValue();</span>
<span class="line-removed">742 </span>
<span class="line-removed">743     auto variableName = generateNextVariableName();</span>
<span class="line-removed">744     m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(ternaryExpression.resolvedType()), &#39; &#39;, variableName, &quot; = &quot;, check, &quot; ? &quot;, body, &quot; : &quot;, elseBody, &quot;;\n&quot;);</span>
<span class="line-removed">745     appendRightValue(ternaryExpression, variableName);</span>
746 }
747 
748 void FunctionDefinitionWriter::visit(AST::VariableReference&amp; variableReference)
749 {
750     ASSERT(variableReference.variable());
751     auto iterator = m_variableMapping.find(variableReference.variable());
752     ASSERT(iterator != m_variableMapping.end());
753 
754     MangledVariableName variableName = iterator-&gt;value;
<span class="line-modified">755 </span>
<span class="line-removed">756     appendLeftValue(variableReference, variableName, { }, Nullability::NotNull,</span>
<span class="line-removed">757         [this, &amp;variableReference, variableName] {</span>
<span class="line-removed">758             auto pointerName = generateNextVariableName();</span>
<span class="line-removed">759             m_stringBuilder.append(m_indent, &quot;thread &quot;, m_typeNamer.mangledNameForType(variableReference.resolvedType()), &quot;* &quot;, pointerName, &quot; = &amp;&quot;, variableName, &quot;;\n&quot;);</span>
<span class="line-removed">760             return pointerName;</span>
<span class="line-removed">761         });</span>
762 }
763 
764 void FunctionDefinitionWriter::emitConstantExpressionString(AST::ConstantExpression&amp; constantExpression)
765 {
766     constantExpression.visit(WTF::makeVisitor(
767         [&amp;](AST::IntegerLiteral&amp; integerLiteral) {
768             m_stringBuilder.append(integerLiteral.value());
769         },
770         [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {
771             m_stringBuilder.append(unsignedIntegerLiteral.value());
772         },
773         [&amp;](AST::FloatLiteral&amp; floatLiteral) {
774             m_stringBuilder.append(floatLiteral.value());
775         },
<span class="line-removed">776         [&amp;](AST::NullLiteral&amp;) {</span>
<span class="line-removed">777             m_stringBuilder.append(&quot;nullptr&quot;);</span>
<span class="line-removed">778         },</span>
779         [&amp;](AST::BooleanLiteral&amp; booleanLiteral) {
780             if (booleanLiteral.value())
781                 m_stringBuilder.append(&quot;true&quot;);
782             else
783                 m_stringBuilder.append(&quot;false&quot;);
784         },
785         [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
786             ASSERT(enumerationMemberLiteral.enumerationDefinition());
787             ASSERT(enumerationMemberLiteral.enumerationDefinition());
788             m_stringBuilder.append(m_typeNamer.mangledNameForType(*enumerationMemberLiteral.enumerationDefinition()), &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()));
789         }
790     ));
791 }
792 
793 class RenderFunctionDefinitionWriter final : public FunctionDefinitionWriter {
794 public:
795     RenderFunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, MatchedRenderSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
796         : FunctionDefinitionWriter(stringBuilder, intrinsics, typeNamer, functionMapping, layout)
797         , m_matchedSemantics(WTFMove(matchedSemantics))
798     {
</pre>
</td>
<td>
<hr />
<pre>
 46 namespace WHLSL {
 47 
 48 namespace Metal {
 49 
 50 static void declareFunction(StringBuilder&amp; stringBuilder, AST::FunctionDeclaration&amp; functionDeclaration, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping)
 51 {
 52     if (functionDeclaration.entryPointType())
 53         return;
 54 
 55     auto iterator = functionMapping.find(&amp;functionDeclaration);
 56     ASSERT(iterator != functionMapping.end());
 57     stringBuilder.append(typeNamer.mangledNameForType(functionDeclaration.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);
 58     for (size_t i = 0; i &lt; functionDeclaration.parameters().size(); ++i) {
 59         if (i)
 60             stringBuilder.append(&quot;, &quot;);
 61         stringBuilder.append(typeNamer.mangledNameForType(*functionDeclaration.parameters()[i]-&gt;type()));
 62     }
 63     stringBuilder.append(&quot;);\n&quot;);
 64 }
 65 
<span class="line-added"> 66 struct Variable {</span>
<span class="line-added"> 67     MangledVariableName name;</span>
<span class="line-added"> 68     MangledTypeName type;</span>
<span class="line-added"> 69 };</span>
<span class="line-added"> 70 </span>
 71 class FunctionDefinitionWriter : public Visitor {
<span class="line-added"> 72     class HoistedVariableCollector : public Visitor {</span>
<span class="line-added"> 73         public:</span>
<span class="line-added"> 74         HoistedVariableCollector(FunctionDefinitionWriter&amp; functionDefinitionWriter)</span>
<span class="line-added"> 75             : functionDefinitionWriter(functionDefinitionWriter)</span>
<span class="line-added"> 76         {</span>
<span class="line-added"> 77         }</span>
<span class="line-added"> 78 </span>
<span class="line-added"> 79         void visit(AST::CallExpression&amp; callExpression) override</span>
<span class="line-added"> 80         {</span>
<span class="line-added"> 81             Vector&lt;Variable&gt; variables;</span>
<span class="line-added"> 82             size_t size = callExpression.arguments().size();</span>
<span class="line-added"> 83             bool isVoid = matches(callExpression.resolvedType(), functionDefinitionWriter.m_intrinsics.voidType());</span>
<span class="line-added"> 84             if (!isVoid)</span>
<span class="line-added"> 85                 ++size;</span>
<span class="line-added"> 86             variables.reserveInitialCapacity(size);</span>
<span class="line-added"> 87 </span>
<span class="line-added"> 88             for (auto&amp; argument : callExpression.arguments()) {</span>
<span class="line-added"> 89                 auto type = functionDefinitionWriter.m_typeNamer.mangledNameForType(argument-&gt;resolvedType());</span>
<span class="line-added"> 90                 auto name = functionDefinitionWriter.generateNextVariableName();</span>
<span class="line-added"> 91                 variables.uncheckedAppend(Variable { name, type });</span>
<span class="line-added"> 92             }</span>
<span class="line-added"> 93 </span>
<span class="line-added"> 94             if (!isVoid)</span>
<span class="line-added"> 95                 variables.uncheckedAppend(Variable { functionDefinitionWriter.generateNextVariableName(), functionDefinitionWriter.m_typeNamer.mangledNameForType(callExpression.resolvedType()) });</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97             toHoist.add(&amp;callExpression, WTFMove(variables));</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99             Visitor::visit(callExpression);</span>
<span class="line-added">100         }</span>
<span class="line-added">101 </span>
<span class="line-added">102         void visit(AST::ReadModifyWriteExpression&amp; readModifyWrite) override</span>
<span class="line-added">103         {</span>
<span class="line-added">104             Vector&lt;Variable&gt; variables;</span>
<span class="line-added">105             variables.append(Variable { functionDefinitionWriter.generateNextVariableName(), functionDefinitionWriter.m_typeNamer.mangledNameForType(*readModifyWrite.oldValue().type()) });</span>
<span class="line-added">106             variables.append(Variable { functionDefinitionWriter.generateNextVariableName(), functionDefinitionWriter.m_typeNamer.mangledNameForType(*readModifyWrite.newValue().type()) });</span>
<span class="line-added">107 </span>
<span class="line-added">108             toHoist.add(&amp;readModifyWrite, WTFMove(variables));</span>
<span class="line-added">109 </span>
<span class="line-added">110             Visitor::visit(readModifyWrite);</span>
<span class="line-added">111         }</span>
<span class="line-added">112 </span>
<span class="line-added">113         FunctionDefinitionWriter&amp; functionDefinitionWriter;</span>
<span class="line-added">114         HashMap&lt;AST::Expression*, Vector&lt;Variable&gt;&gt; toHoist;</span>
<span class="line-added">115     };</span>
<span class="line-added">116 </span>
117 public:
118     FunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, Layout&amp; layout)
119         : m_stringBuilder(stringBuilder)
120         , m_intrinsics(intrinsics)
121         , m_typeNamer(typeNamer)
122         , m_functionMapping(functionMapping)
123         , m_layout(layout)
124     {
125     }
126 
127     virtual ~FunctionDefinitionWriter() = default;
128 
129     void visit(AST::NativeFunctionDeclaration&amp;) override;
130     void visit(AST::FunctionDefinition&amp;) override;
131 
132 protected:
133     virtual std::unique_ptr&lt;EntryPointScaffolding&gt; createEntryPointScaffolding(AST::FunctionDefinition&amp;) = 0;
134 
135     void visit(AST::FunctionDeclaration&amp;) override;
136     void visit(AST::Statement&amp;) override;
137     void visit(AST::Block&amp;) override;
138     void visit(AST::Break&amp;) override;
139     void visit(AST::Continue&amp;) override;
140     void visit(AST::DoWhileLoop&amp;) override;
141     void visit(AST::EffectfulExpressionStatement&amp;) override;
142     void visit(AST::Fallthrough&amp;) override;
143     void visit(AST::ForLoop&amp;) override;
144     void visit(AST::IfStatement&amp;) override;
145     void visit(AST::Return&amp;) override;
146     void visit(AST::SwitchStatement&amp;) override;
147     void visit(AST::SwitchCase&amp;) override;
148     void visit(AST::VariableDeclarationsStatement&amp;) override;
149     void visit(AST::WhileLoop&amp;) override;
150     void visit(AST::IntegerLiteral&amp;) override;
151     void visit(AST::UnsignedIntegerLiteral&amp;) override;
152     void visit(AST::FloatLiteral&amp;) override;

153     void visit(AST::BooleanLiteral&amp;) override;
154     void visit(AST::EnumerationMemberLiteral&amp;) override;
155     void visit(AST::Expression&amp;) override;

156     void visit(AST::GlobalVariableReference&amp;) override;
<span class="line-added">157     void visit(AST::DotExpression&amp;) override;</span>
158     void visit(AST::IndexExpression&amp;) override;

159     void visit(AST::VariableDeclaration&amp;) override;
160     void visit(AST::AssignmentExpression&amp;) override;
161     void visit(AST::CallExpression&amp;) override;
162     void visit(AST::CommaExpression&amp;) override;
163     void visit(AST::DereferenceExpression&amp;) override;
164     void visit(AST::LogicalExpression&amp;) override;
165     void visit(AST::LogicalNotExpression&amp;) override;
166     void visit(AST::MakeArrayReferenceExpression&amp;) override;
167     void visit(AST::MakePointerExpression&amp;) override;
168     void visit(AST::ReadModifyWriteExpression&amp;) override;
169     void visit(AST::TernaryExpression&amp;) override;
170     void visit(AST::VariableReference&amp;) override;
171 
172     enum class LoopConditionLocation {
173         BeforeBody,
174         AfterBody
175     };
176     void emitLoop(LoopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body);
177 
178     void emitConstantExpressionString(AST::ConstantExpression&amp;);
179 
180     MangledVariableName generateNextVariableName() { return { m_variableCount++ }; }
181 



























































182     enum class BreakContext {
183         Loop,
184         Switch
185     };
186 
187     Optional&lt;BreakContext&gt; m_currentBreakContext;
188 
189     StringBuilder&amp; m_stringBuilder;
190     Intrinsics&amp; m_intrinsics;
191     TypeNamer&amp; m_typeNamer;
192     HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; m_functionMapping;
193     HashMap&lt;AST::VariableDeclaration*, MangledVariableName&gt; m_variableMapping;
194 

195     std::unique_ptr&lt;EntryPointScaffolding&gt; m_entryPointScaffolding;
196     Layout&amp; m_layout;
197     unsigned m_variableCount { 0 };
198     Optional&lt;MangledVariableName&gt; m_breakOutOfCurrentLoopEarlyVariable;
199     Indentation&lt;4&gt; m_indent { 0 };
<span class="line-added">200     HashMap&lt;AST::Expression*, Vector&lt;Variable&gt;&gt; m_hoistedVariables;</span>
201 };
202 
203 void FunctionDefinitionWriter::visit(AST::NativeFunctionDeclaration&amp;)
204 {
205     // We inline native function calls.
206 }
207 
208 void FunctionDefinitionWriter::visit(AST::FunctionDefinition&amp; functionDefinition)
209 {
<span class="line-added">210 </span>
<span class="line-added">211     {</span>
<span class="line-added">212         HoistedVariableCollector collector(*this);</span>
<span class="line-added">213         collector.Visitor::visit(functionDefinition);</span>
<span class="line-added">214         m_hoistedVariables = WTFMove(collector.toHoist);</span>
<span class="line-added">215     }</span>
<span class="line-added">216 </span>
<span class="line-added">217     auto defineHoistedVariables = [&amp;] {</span>
<span class="line-added">218         for (const auto&amp; vector : m_hoistedVariables.values()) {</span>
<span class="line-added">219             for (auto variable : vector)</span>
<span class="line-added">220                 m_stringBuilder.append(m_indent, variable.type, &#39; &#39;, variable.name, &quot;;\n&quot;);</span>
<span class="line-added">221         }</span>
<span class="line-added">222     };</span>
<span class="line-added">223 </span>
224     auto iterator = m_functionMapping.find(&amp;functionDefinition);
225     ASSERT(iterator != m_functionMapping.end());
226     if (functionDefinition.entryPointType()) {
227         auto entryPointScaffolding = createEntryPointScaffolding(functionDefinition);
228         if (!entryPointScaffolding)
229             return;
230         m_entryPointScaffolding = WTFMove(entryPointScaffolding);
231 
232         m_entryPointScaffolding-&gt;emitHelperTypes(m_stringBuilder, m_indent);
233         m_entryPointScaffolding-&gt;emitSignature(m_stringBuilder, iterator-&gt;value, m_indent);
234         m_stringBuilder.append(m_indent, &quot;{\n&quot;);
235         {
236             IndentationScope scope(m_indent);
237 
238             m_entryPointScaffolding-&gt;emitUnpack(m_stringBuilder, m_indent);
239 
240             for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {
241                 auto addResult = m_variableMapping.add(&amp;functionDefinition.parameters()[i], m_entryPointScaffolding-&gt;parameterVariables()[i]);
242                 ASSERT_UNUSED(addResult, addResult.isNewEntry);
243             }
<span class="line-added">244 </span>
<span class="line-added">245             defineHoistedVariables();</span>
<span class="line-added">246 </span>
247             checkErrorAndVisit(functionDefinition.block());

248         }
249         m_stringBuilder.append(&quot;}\n\n&quot;);
250 
251         m_entryPointScaffolding = nullptr;
252     } else {
253         ASSERT(m_entryPointScaffolding == nullptr);
254         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(functionDefinition.type()), &#39; &#39;, iterator-&gt;value, &#39;(&#39;);
255         for (size_t i = 0; i &lt; functionDefinition.parameters().size(); ++i) {

256             if (i)
257                 m_stringBuilder.append(&quot;, &quot;);
<span class="line-added">258             auto&amp; parameter = functionDefinition.parameters()[i];</span>
259             auto parameterName = generateNextVariableName();
260             auto addResult = m_variableMapping.add(&amp;parameter, parameterName);
261             ASSERT_UNUSED(addResult, addResult.isNewEntry);
262             m_stringBuilder.append(m_typeNamer.mangledNameForType(*parameter-&gt;type()), &#39; &#39;, parameterName);
263         }
264         m_stringBuilder.append(&quot;)\n&quot;);
<span class="line-added">265 </span>
<span class="line-added">266         m_stringBuilder.append(&quot;{\n&quot;);</span>
<span class="line-added">267 </span>
<span class="line-added">268         defineHoistedVariables();</span>
<span class="line-added">269 </span>
270         checkErrorAndVisit(functionDefinition.block());
<span class="line-modified">271         m_stringBuilder.append(&quot;}\n&quot;);</span>
272         m_stringBuilder.append(&#39;\n&#39;);
273     }
274 }
275 
276 void FunctionDefinitionWriter::visit(AST::FunctionDeclaration&amp;)
277 {
278     ASSERT_NOT_REACHED();
279 }
280 
281 void FunctionDefinitionWriter::visit(AST::Statement&amp; statement)
282 {
283     Visitor::visit(statement);
284 }
285 
286 void FunctionDefinitionWriter::visit(AST::Block&amp; block)
287 {
288     m_stringBuilder.append(m_indent, &quot;{\n&quot;);
289     {
290         IndentationScope scope(m_indent);
291         for (auto&amp; statement : block.statements())
</pre>
<hr />
<pre>
302         m_stringBuilder.append(m_indent, &quot;break;\n&quot;);
303         break;
304     case BreakContext::Loop:
305         ASSERT(m_breakOutOfCurrentLoopEarlyVariable);
306         m_stringBuilder.append(
307             m_indent, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = true;\n&quot;,
308             m_indent, &quot;break;\n&quot;
309         );
310         break;
311     }
312 }
313 
314 void FunctionDefinitionWriter::visit(AST::Continue&amp;)
315 {
316     ASSERT(m_breakOutOfCurrentLoopEarlyVariable);
317     m_stringBuilder.append(m_indent, &quot;break;\n&quot;);
318 }
319 
320 void FunctionDefinitionWriter::visit(AST::EffectfulExpressionStatement&amp; effectfulExpressionStatement)
321 {
<span class="line-added">322     m_stringBuilder.append(m_indent);</span>
323     checkErrorAndVisit(effectfulExpressionStatement.effectfulExpression());
<span class="line-modified">324     m_stringBuilder.append(&quot;;\n&quot;);</span>
325 }
326 
327 void FunctionDefinitionWriter::visit(AST::Fallthrough&amp;)
328 {
329     m_stringBuilder.append(m_indent, &quot;[[clang::fallthrough]];\n&quot;); // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195808 Make sure this is okay. Alternatively, we could do nothing and just return here instead.
330 }
331 
332 void FunctionDefinitionWriter::emitLoop(LoopConditionLocation loopConditionLocation, AST::Expression* conditionExpression, AST::Expression* increment, AST::Statement&amp; body)
333 {
334     SetForScope&lt;Optional&lt;MangledVariableName&gt;&gt; loopVariableScope(m_breakOutOfCurrentLoopEarlyVariable, generateNextVariableName());
335 
336     m_stringBuilder.append(
337         m_indent, &quot;bool &quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot; = false;\n&quot;,
338         m_indent, &quot;while (true) {\n&quot;
339     );
340     {
341         IndentationScope whileScope(m_indent);
342 
343         if (loopConditionLocation == LoopConditionLocation::BeforeBody &amp;&amp; conditionExpression) {
<span class="line-added">344             m_stringBuilder.append(</span>
<span class="line-added">345                 m_indent, &quot;if (!(&quot;);</span>
346             checkErrorAndVisit(*conditionExpression);
347             m_stringBuilder.append(
<span class="line-modified">348                 &quot;))\n&quot;,</span>
<span class="line-modified">349                 &quot;    break;\n&quot;);</span>
350         }
351 
352         m_stringBuilder.append(m_indent, &quot;do {\n&quot;);
353         SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Loop);
354 
355         {
356             IndentationScope doScope(m_indent);
357             checkErrorAndVisit(body);
358         }
359         m_stringBuilder.append(m_indent, &quot;} while(false); \n&quot;);
360 
361         m_stringBuilder.append(
362             m_indent, &quot;if (&quot;, *m_breakOutOfCurrentLoopEarlyVariable, &quot;)\n&quot;,
363             m_indent, &quot;    break;\n&quot;);
364 
365         if (increment) {
<span class="line-added">366             m_stringBuilder.append(&quot;(&quot;);</span>
367             checkErrorAndVisit(*increment);
<span class="line-modified">368             m_stringBuilder.append(&quot;);\n&quot;);</span>


369         }
370 
371         if (loopConditionLocation == LoopConditionLocation::AfterBody &amp;&amp; conditionExpression) {
<span class="line-added">372             m_stringBuilder.append(</span>
<span class="line-added">373                 m_indent, &quot;if (!(&quot;);</span>
374             checkErrorAndVisit(*conditionExpression);
375             m_stringBuilder.append(
<span class="line-modified">376                 &quot;))\n&quot;,</span>
<span class="line-modified">377                 &quot;    break;\n&quot;);</span>
378         }
379     }
380 
381     m_stringBuilder.append(m_indent, &quot;} \n&quot;);
382 }
383 
384 void FunctionDefinitionWriter::visit(AST::DoWhileLoop&amp; doWhileLoop)
385 {
386     emitLoop(LoopConditionLocation::AfterBody, &amp;doWhileLoop.conditional(), nullptr, doWhileLoop.body());
387 }
388 
389 void FunctionDefinitionWriter::visit(AST::WhileLoop&amp; whileLoop)
390 {
391     emitLoop(LoopConditionLocation::BeforeBody, &amp;whileLoop.conditional(), nullptr, whileLoop.body());
392 }
393 
394 void FunctionDefinitionWriter::visit(AST::ForLoop&amp; forLoop)
395 {
396     m_stringBuilder.append(m_indent, &quot;{\n&quot;);
397     {
398         IndentationScope scope(m_indent);
399         checkErrorAndVisit(forLoop.initialization());
400         emitLoop(LoopConditionLocation::BeforeBody, forLoop.condition(), forLoop.increment(), forLoop.body());
401     }
402     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
403 }
404 
405 void FunctionDefinitionWriter::visit(AST::IfStatement&amp; ifStatement)
406 {
<span class="line-added">407     m_stringBuilder.append(m_indent, &quot;if (&quot;);</span>
408     checkErrorAndVisit(ifStatement.conditional());
<span class="line-modified">409     m_stringBuilder.append(&quot;) {\n&quot;);</span>
<span class="line-added">410 </span>
411     {
412         IndentationScope ifScope(m_indent);
413         checkErrorAndVisit(ifStatement.body());
414     }
<span class="line-added">415 </span>
416     if (ifStatement.elseBody()) {
417         m_stringBuilder.append(m_indent, &quot;} else {\n&quot;);
418         {
419             IndentationScope elseScope(m_indent);
420             checkErrorAndVisit(*ifStatement.elseBody());
421         }
422     }
<span class="line-added">423 </span>
424     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
425 }
426 
427 void FunctionDefinitionWriter::visit(AST::Return&amp; returnStatement)
428 {
429     if (returnStatement.value()) {
<span class="line-added">430         auto tempReturnName = generateNextVariableName();</span>
<span class="line-added">431         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(returnStatement.value()-&gt;resolvedType()), &#39; &#39;, tempReturnName, &quot; = &quot;);</span>
432         checkErrorAndVisit(*returnStatement.value());
<span class="line-added">433         m_stringBuilder.append(&quot;;\n&quot;);</span>
434 
435         if (m_entryPointScaffolding) {
436             auto variableName = generateNextVariableName();
<span class="line-modified">437             m_entryPointScaffolding-&gt;emitPack(m_stringBuilder, tempReturnName, variableName, m_indent);</span>
438             m_stringBuilder.append(m_indent, &quot;return &quot;, variableName, &quot;;\n&quot;);
439         } else
<span class="line-modified">440             m_stringBuilder.append(m_indent, &quot;return &quot;, tempReturnName, &quot;;\n&quot;);</span>
441     } else
442         m_stringBuilder.append(m_indent, &quot;return;\n&quot;);
443 }
444 
445 void FunctionDefinitionWriter::visit(AST::SwitchStatement&amp; switchStatement)
446 {
<span class="line-added">447     m_stringBuilder.append(m_indent, &quot;switch (&quot;);</span>
448     checkErrorAndVisit(switchStatement.value());
<span class="line-added">449     m_stringBuilder.append(&quot;) {&quot;);</span>
450 

451     {
452         IndentationScope switchScope(m_indent);
453         for (auto&amp; switchCase : switchStatement.switchCases())
454             checkErrorAndVisit(switchCase);
455     }
456     m_stringBuilder.append(m_indent, &quot;}\n&quot;);
457 }
458 
459 void FunctionDefinitionWriter::visit(AST::SwitchCase&amp; switchCase)
460 {
461     if (switchCase.value()) {
462         m_stringBuilder.append(m_indent, &quot;case &quot;);
463         emitConstantExpressionString(*switchCase.value());
464         m_stringBuilder.append(&quot;:\n&quot;);
465     } else
466         m_stringBuilder.append(m_indent, &quot;default:\n&quot;);
467     SetForScope&lt;Optional&lt;BreakContext&gt;&gt; breakContext(m_currentBreakContext, BreakContext::Switch);
468     checkErrorAndVisit(switchCase.block());
469     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=195812 Figure out whether we need to break or fallthrough.
470 }
471 
472 void FunctionDefinitionWriter::visit(AST::VariableDeclarationsStatement&amp; variableDeclarationsStatement)
473 {
474     Visitor::visit(variableDeclarationsStatement);
475 }
476 
477 void FunctionDefinitionWriter::visit(AST::IntegerLiteral&amp; integerLiteral)
478 {

479     auto mangledTypeName = m_typeNamer.mangledNameForType(integerLiteral.resolvedType());
<span class="line-modified">480     m_stringBuilder.append(&quot;static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, integerLiteral.value(), &quot;)&quot;);</span>

481 }
482 
483 void FunctionDefinitionWriter::visit(AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral)
484 {

485     auto mangledTypeName = m_typeNamer.mangledNameForType(unsignedIntegerLiteral.resolvedType());
<span class="line-modified">486     m_stringBuilder.append(&quot;static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, unsignedIntegerLiteral.value(), &quot;)&quot;);</span>

487 }
488 
489 void FunctionDefinitionWriter::visit(AST::FloatLiteral&amp; floatLiteral)
490 {

491     auto mangledTypeName = m_typeNamer.mangledNameForType(floatLiteral.resolvedType());
<span class="line-modified">492     m_stringBuilder.append(&quot;static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, floatLiteral.value(), &quot;)&quot;);</span>
















493 }
494 
495 void FunctionDefinitionWriter::visit(AST::BooleanLiteral&amp; booleanLiteral)
496 {

497     auto mangledTypeName = m_typeNamer.mangledNameForType(booleanLiteral.resolvedType());
<span class="line-modified">498     m_stringBuilder.append(&quot;static_cast&lt;&quot;, mangledTypeName, &quot;&gt;(&quot;, booleanLiteral.value() ? &quot;true&quot; : &quot;false&quot;, &quot;)&quot;);</span>

499 }
500 
501 void FunctionDefinitionWriter::visit(AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral)
502 {
503     ASSERT(enumerationMemberLiteral.enumerationDefinition());
504     ASSERT(enumerationMemberLiteral.enumerationDefinition());

505     auto mangledTypeName = m_typeNamer.mangledNameForType(enumerationMemberLiteral.resolvedType());
<span class="line-modified">506     m_stringBuilder.append(mangledTypeName, &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()));</span>

507 }
508 
509 void FunctionDefinitionWriter::visit(AST::Expression&amp; expression)
510 {
511     Visitor::visit(expression);
512 }
513 








514 void FunctionDefinitionWriter::visit(AST::GlobalVariableReference&amp; globalVariableReference)
515 {
<span class="line-modified">516     MangledStructureElementName mangledFieldName = m_typeNamer.mangledNameForStructureElement(globalVariableReference.structField());</span>
<span class="line-modified">517     m_stringBuilder.append(&#39;(&#39;);</span>

518     checkErrorAndVisit(globalVariableReference.base());
<span class="line-modified">519     m_stringBuilder.append(&quot;)-&gt;&quot;, mangledFieldName);</span>
<span class="line-added">520 }</span>
521 
<span class="line-modified">522 void FunctionDefinitionWriter::visit(AST::DotExpression&amp; dotExpression)</span>
<span class="line-added">523 {</span>
<span class="line-added">524     auto&amp; type = dotExpression.base().resolvedType().unifyNode();</span>
525 
<span class="line-modified">526     if (is&lt;AST::StructureDefinition&gt;(type)) {</span>
<span class="line-modified">527         auto&amp; structureDefinition = downcast&lt;AST::StructureDefinition&gt;(type);</span>
<span class="line-added">528         auto* structureElement = structureDefinition.find(dotExpression.fieldName());</span>
<span class="line-added">529         ASSERT(structureElement);</span>
<span class="line-added">530         auto elementName = m_typeNamer.mangledNameForStructureElement(*structureElement);</span>
531 
<span class="line-modified">532         m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-modified">533         checkErrorAndVisit(dotExpression.base());</span>
<span class="line-modified">534         m_stringBuilder.append(&quot;).&quot;, elementName);</span>
<span class="line-modified">535     } else {</span>
<span class="line-modified">536         String elementName = dotExpression.fieldName();</span>
<span class="line-modified">537         if (elementName == &quot;length&quot; &amp;&amp; (is&lt;AST::ArrayReferenceType&gt;(type) || is&lt;AST::ArrayType&gt;(type) || (is&lt;AST::NativeTypeDeclaration&gt;(type) &amp;&amp; downcast&lt;AST::NativeTypeDeclaration&gt;(type).isVector()))) {</span>
<span class="line-modified">538             if (is&lt;AST::ArrayReferenceType&gt;(type)) {</span>
<span class="line-added">539                 m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">540                 checkErrorAndVisit(dotExpression.base());</span>
<span class="line-added">541                 m_stringBuilder.append(&quot;).length&quot;);</span>
<span class="line-added">542             } else if (is&lt;AST::ArrayType&gt;(type)) {</span>
<span class="line-added">543                 m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">544                 checkErrorAndVisit(dotExpression.base());</span>
<span class="line-added">545                 m_stringBuilder.append(&quot;, &quot;, downcast&lt;AST::ArrayType&gt;(type).numElements(), &quot;)&quot;);</span>
<span class="line-added">546             } else {</span>
<span class="line-added">547                 m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">548                 checkErrorAndVisit(dotExpression.base());</span>
<span class="line-added">549                 m_stringBuilder.append(&quot;, &quot;, downcast&lt;AST::NativeTypeDeclaration&gt;(type).vectorSize(), &quot;)&quot;);</span>
<span class="line-added">550             }</span>
<span class="line-added">551         } else {</span>
<span class="line-added">552             m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">553             checkErrorAndVisit(dotExpression.base());</span>
<span class="line-added">554             m_stringBuilder.append(&quot;).&quot;, elementName);</span>
<span class="line-added">555         }</span>
<span class="line-added">556     }</span>
557 }
558 
559 void FunctionDefinitionWriter::visit(AST::IndexExpression&amp; indexExpression)
560 {
<span class="line-modified">561     auto&amp; type = indexExpression.base().resolvedType().unifyNode();</span>
<span class="line-modified">562     if (is&lt;AST::ArrayReferenceType&gt;(type)) {</span>
<span class="line-modified">563         m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-modified">564         checkErrorAndVisit(indexExpression.base());</span>
<span class="line-modified">565         m_stringBuilder.append(&quot;).pointer[(&quot;);</span>
<span class="line-modified">566         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="line-modified">567         m_stringBuilder.append(&quot;) &lt; (&quot;);</span>
<span class="line-modified">568         checkErrorAndVisit(indexExpression.base());</span>
<span class="line-modified">569         m_stringBuilder.append(&quot;).length ? &quot;);</span>
<span class="line-modified">570         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="line-modified">571         m_stringBuilder.append(&quot; : 0]&quot;);</span>
<span class="line-modified">572     } else if (is&lt;AST::ArrayType&gt;(type)) {</span>
<span class="line-added">573         m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">574         checkErrorAndVisit(indexExpression.base());</span>
<span class="line-added">575         m_stringBuilder.append(&quot;).data()[(&quot;);</span>
<span class="line-added">576         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="line-added">577         m_stringBuilder.append(&quot;) &lt; &quot;, downcast&lt;AST::ArrayType&gt;(type).numElements(), &quot; ? &quot;);</span>
<span class="line-added">578         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="line-added">579         m_stringBuilder.append(&quot; : 0]&quot;);</span>
<span class="line-added">580     } else if (is&lt;AST::NativeTypeDeclaration&gt;(type)) {</span>
<span class="line-added">581         auto&amp; nativeType = downcast&lt;AST::NativeTypeDeclaration&gt;(type);</span>
<span class="line-added">582         unsigned size;</span>
<span class="line-added">583         if (nativeType.isMatrix())</span>
<span class="line-added">584             size = nativeType.numberOfMatrixColumns();</span>
<span class="line-added">585         else if (nativeType.isVector())</span>
<span class="line-added">586             size = nativeType.vectorSize();</span>
<span class="line-added">587         else</span>
<span class="line-added">588             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">589 </span>
<span class="line-added">590         m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">591         checkErrorAndVisit(indexExpression.base());</span>
<span class="line-added">592         m_stringBuilder.append(&quot;)[(&quot;);</span>
<span class="line-added">593         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="line-added">594         m_stringBuilder.append(&quot; &lt; &quot;, size, &quot;) ? (&quot;);</span>
<span class="line-added">595         checkErrorAndVisit(indexExpression.indexExpression());</span>
<span class="line-added">596         m_stringBuilder.append(&quot;) : 0]&quot;);</span>
<span class="line-added">597     } else</span>
<span class="line-added">598         RELEASE_ASSERT_NOT_REACHED();</span>
599 }
600 
601 void FunctionDefinitionWriter::visit(AST::VariableDeclaration&amp; variableDeclaration)
602 {
603     ASSERT(variableDeclaration.type());
604     auto variableName = generateNextVariableName();
605     auto addResult = m_variableMapping.add(&amp;variableDeclaration, variableName);
606     ASSERT_UNUSED(addResult, addResult.isNewEntry);
607     // FIXME: https://bugs.webkit.org/show_bug.cgi?id=198160 Implement qualifiers.
608     if (variableDeclaration.initializer()) {
<span class="line-added">609         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = &quot;);</span>
610         checkErrorAndVisit(*variableDeclaration.initializer());
<span class="line-modified">611         m_stringBuilder.append(&quot;;\n&quot;);</span>
612     } else
613         m_stringBuilder.append(m_indent, m_typeNamer.mangledNameForType(*variableDeclaration.type()), &#39; &#39;, variableName, &quot; = { };\n&quot;);
614 }
615 
616 void FunctionDefinitionWriter::visit(AST::AssignmentExpression&amp; assignmentExpression)
617 {
<span class="line-added">618     m_stringBuilder.append(&#39;(&#39;);</span>
619     checkErrorAndVisit(assignmentExpression.left());
<span class="line-modified">620     m_stringBuilder.append(&#39;)&#39;);</span>
<span class="line-added">621     m_stringBuilder.append(&quot; = (&quot;);</span>
622     checkErrorAndVisit(assignmentExpression.right());
<span class="line-modified">623     m_stringBuilder.append(&#39;)&#39;);</span>








624 }
625 
626 void FunctionDefinitionWriter::visit(AST::CallExpression&amp; callExpression)
627 {
<span class="line-added">628     auto iter = m_hoistedVariables.find(&amp;callExpression);</span>
<span class="line-added">629     RELEASE_ASSERT(iter != m_hoistedVariables.end());</span>
<span class="line-added">630     auto&amp; variables = iter-&gt;value;</span>
<span class="line-added">631     RELEASE_ASSERT(callExpression.arguments().size() &lt;= variables.size());</span>
632     Vector&lt;MangledVariableName&gt; argumentNames;




633 
<span class="line-modified">634     MangledVariableName resultName;</span>
<span class="line-modified">635     if (!matches(callExpression.resolvedType(), m_intrinsics.voidType()))</span>
<span class="line-modified">636         resultName = variables.last().name;</span>
<span class="line-modified">637 </span>
<span class="line-modified">638     m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">639     for (size_t i = 0; i &lt; callExpression.arguments().size(); ++i) {</span>
<span class="line-added">640         argumentNames.append(variables[i].name);</span>
<span class="line-added">641         m_stringBuilder.append(variables[i].name, &quot; = (&quot;);</span>
<span class="line-added">642         checkErrorAndVisit(callExpression.arguments()[i]);</span>
<span class="line-added">643         m_stringBuilder.append(&quot;), &quot;);</span>
644     }
645 
646     if (is&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function())) {
<span class="line-modified">647         inlineNativeFunction(m_stringBuilder, downcast&lt;AST::NativeFunctionDeclaration&gt;(callExpression.function()), argumentNames, resultName, m_typeNamer);</span>






648     } else {


649         auto iterator = m_functionMapping.find(&amp;callExpression.function());
650         ASSERT(iterator != m_functionMapping.end());


651         m_stringBuilder.append(iterator-&gt;value, &#39;(&#39;);
<span class="line-modified">652         for (size_t i = 0; i &lt; callExpression.arguments().size(); ++i) {</span>
653             if (i)
654                 m_stringBuilder.append(&quot;, &quot;);
<span class="line-modified">655             m_stringBuilder.append(variables[i].name);</span>
656         }
<span class="line-modified">657         m_stringBuilder.append(&#39;)&#39;);</span>
658     }
659 
<span class="line-modified">660     m_stringBuilder.append(&#39;)&#39;);</span>
661 }
662 
663 void FunctionDefinitionWriter::visit(AST::CommaExpression&amp; commaExpression)
664 {
<span class="line-modified">665     m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">666     bool ranOnce = false;</span>
667     for (auto&amp; expression : commaExpression.list()) {
<span class="line-added">668         if (ranOnce)</span>
<span class="line-added">669             m_stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">670         ranOnce = true;</span>
671         checkErrorAndVisit(expression);

672     }
<span class="line-modified">673     m_stringBuilder.append(&#39;)&#39;);</span>

674 }
675 
676 void FunctionDefinitionWriter::visit(AST::DereferenceExpression&amp; dereferenceExpression)
677 {
<span class="line-added">678     m_stringBuilder.append(&quot;*(&quot;);</span>
679     checkErrorAndVisit(dereferenceExpression.pointer());
<span class="line-modified">680     m_stringBuilder.append(&#39;)&#39;);</span>










681 }
682 
683 void FunctionDefinitionWriter::visit(AST::LogicalExpression&amp; logicalExpression)
684 {
<span class="line-added">685     m_stringBuilder.append(&quot;((&quot;);</span>
686     checkErrorAndVisit(logicalExpression.left());
<span class="line-modified">687     m_stringBuilder.append(&#39;)&#39;);</span>



688 


689     switch (logicalExpression.type()) {
690     case AST::LogicalExpression::Type::And:
691         m_stringBuilder.append(&quot; &amp;&amp; &quot;);
692         break;
<span class="line-modified">693     case AST::LogicalExpression::Type::Or:</span>

694         m_stringBuilder.append(&quot; || &quot;);
695         break;
696     }
<span class="line-modified">697 </span>
<span class="line-modified">698     m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">699     checkErrorAndVisit(logicalExpression.right());</span>
<span class="line-added">700     m_stringBuilder.append(&quot;))&quot;);</span>
701 }
702 
703 void FunctionDefinitionWriter::visit(AST::LogicalNotExpression&amp; logicalNotExpression)
704 {
<span class="line-added">705     m_stringBuilder.append(&quot;!(&quot;);</span>
706     checkErrorAndVisit(logicalNotExpression.operand());
<span class="line-modified">707     m_stringBuilder.append(&#39;)&#39;);</span>





708 }
709 
710 void FunctionDefinitionWriter::visit(AST::MakeArrayReferenceExpression&amp; makeArrayReferenceExpression)
711 {

712     // FIXME: This needs to be made to work. It probably should be using the last leftValue too.
713     // https://bugs.webkit.org/show_bug.cgi?id=198838


714     auto mangledTypeName = m_typeNamer.mangledNameForType(makeArrayReferenceExpression.resolvedType());
715     if (is&lt;AST::PointerType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {
<span class="line-modified">716         m_stringBuilder.append(mangledTypeName, &quot;{ &quot;);</span>
<span class="line-modified">717         checkErrorAndVisit(makeArrayReferenceExpression.leftValue());</span>
<span class="line-modified">718         m_stringBuilder.append(&quot;, 1 }&quot;);</span>
719     } else if (is&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType())) {

720         auto&amp; arrayType = downcast&lt;AST::ArrayType&gt;(makeArrayReferenceExpression.leftValue().resolvedType());
<span class="line-modified">721         m_stringBuilder.append(mangledTypeName, &quot; { &quot;);</span>
<span class="line-added">722         checkErrorAndVisit(makeArrayReferenceExpression.leftValue());</span>
<span class="line-added">723         m_stringBuilder.append(&quot;.data(), &quot;, arrayType.numElements(), &quot; }&quot;);</span>
724     } else {
<span class="line-modified">725         m_stringBuilder.append(mangledTypeName, &quot; { &amp;&quot;);</span>
<span class="line-modified">726         checkErrorAndVisit(makeArrayReferenceExpression.leftValue());</span>
<span class="line-added">727         m_stringBuilder.append(&quot;, 1 }&quot;);</span>
728     }

729 }
730 
731 void FunctionDefinitionWriter::visit(AST::MakePointerExpression&amp; makePointerExpression)
732 {
<span class="line-added">733     m_stringBuilder.append(&quot;&amp;(&quot;);</span>
734     checkErrorAndVisit(makePointerExpression.leftValue());
<span class="line-modified">735     m_stringBuilder.append(&#39;)&#39;);</span>



736 }
737 
<span class="line-modified">738 void FunctionDefinitionWriter::visit(AST::ReadModifyWriteExpression&amp; readModifyWrite)</span>
739 {
<span class="line-modified">740     /*</span>
<span class="line-modified">741      *  1. Evaluate m_leftValue</span>
<span class="line-added">742      *  2. Assign the result to m_oldValue</span>
<span class="line-added">743      *  3. Evaluate m_newValueExpression</span>
<span class="line-added">744      *  4. Assign the result to m_newValue</span>
<span class="line-added">745      *  5. Assign the result to m_leftValue</span>
<span class="line-added">746      *  6. Evaluate m_resultExpression</span>
<span class="line-added">747      *  7. Return the result</span>
<span class="line-added">748      */</span>
<span class="line-added">749 </span>
<span class="line-added">750     auto iter = m_hoistedVariables.find(&amp;readModifyWrite);</span>
<span class="line-added">751     RELEASE_ASSERT(iter != m_hoistedVariables.end());</span>
<span class="line-added">752     auto&amp; variables = iter-&gt;value;</span>
<span class="line-added">753     RELEASE_ASSERT(variables.size() == 2);</span>
<span class="line-added">754 </span>
<span class="line-added">755     MangledVariableName oldValueVariable = variables[0].name;</span>
<span class="line-added">756     MangledVariableName newValueVariable = variables[1].name;</span>
<span class="line-added">757 </span>
<span class="line-added">758     m_variableMapping.add(&amp;readModifyWrite.oldValue(), oldValueVariable);</span>
<span class="line-added">759     m_variableMapping.add(&amp;readModifyWrite.newValue(), newValueVariable);</span>
<span class="line-added">760 </span>
<span class="line-added">761     m_stringBuilder.append(&#39;(&#39;);</span>
<span class="line-added">762 </span>
<span class="line-added">763     m_stringBuilder.append(oldValueVariable, &quot; = &quot;);</span>
<span class="line-added">764     checkErrorAndVisit(readModifyWrite.leftValue());</span>
<span class="line-added">765 </span>
<span class="line-added">766     m_stringBuilder.append(&quot;, &quot;, newValueVariable, &quot; = &quot;);</span>
<span class="line-added">767     checkErrorAndVisit(readModifyWrite.newValueExpression());</span>
<span class="line-added">768 </span>
<span class="line-added">769     m_stringBuilder.append(&quot;, &quot;);</span>
<span class="line-added">770     checkErrorAndVisit(readModifyWrite.leftValue());</span>
<span class="line-added">771     m_stringBuilder.append(&quot; = &quot;, newValueVariable, &quot;, &quot;);</span>
<span class="line-added">772 </span>
<span class="line-added">773     checkErrorAndVisit(readModifyWrite.resultExpression());</span>
<span class="line-added">774     m_stringBuilder.append(&#39;)&#39;);</span>
775 }
776 
777 void FunctionDefinitionWriter::visit(AST::TernaryExpression&amp; ternaryExpression)
778 {
<span class="line-added">779     m_stringBuilder.append(&#39;(&#39;);</span>
780     checkErrorAndVisit(ternaryExpression.predicate());
<span class="line-modified">781     m_stringBuilder.append(&quot;) ? (&quot;);</span>
782     checkErrorAndVisit(ternaryExpression.bodyExpression());
<span class="line-modified">783     m_stringBuilder.append(&quot;) : (&quot;);</span>
784     checkErrorAndVisit(ternaryExpression.elseExpression());
<span class="line-modified">785     m_stringBuilder.append(&#39;)&#39;);</span>




786 }
787 
788 void FunctionDefinitionWriter::visit(AST::VariableReference&amp; variableReference)
789 {
790     ASSERT(variableReference.variable());
791     auto iterator = m_variableMapping.find(variableReference.variable());
792     ASSERT(iterator != m_variableMapping.end());
793 
794     MangledVariableName variableName = iterator-&gt;value;
<span class="line-modified">795     m_stringBuilder.append(variableName);</span>






796 }
797 
798 void FunctionDefinitionWriter::emitConstantExpressionString(AST::ConstantExpression&amp; constantExpression)
799 {
800     constantExpression.visit(WTF::makeVisitor(
801         [&amp;](AST::IntegerLiteral&amp; integerLiteral) {
802             m_stringBuilder.append(integerLiteral.value());
803         },
804         [&amp;](AST::UnsignedIntegerLiteral&amp; unsignedIntegerLiteral) {
805             m_stringBuilder.append(unsignedIntegerLiteral.value());
806         },
807         [&amp;](AST::FloatLiteral&amp; floatLiteral) {
808             m_stringBuilder.append(floatLiteral.value());
809         },



810         [&amp;](AST::BooleanLiteral&amp; booleanLiteral) {
811             if (booleanLiteral.value())
812                 m_stringBuilder.append(&quot;true&quot;);
813             else
814                 m_stringBuilder.append(&quot;false&quot;);
815         },
816         [&amp;](AST::EnumerationMemberLiteral&amp; enumerationMemberLiteral) {
817             ASSERT(enumerationMemberLiteral.enumerationDefinition());
818             ASSERT(enumerationMemberLiteral.enumerationDefinition());
819             m_stringBuilder.append(m_typeNamer.mangledNameForType(*enumerationMemberLiteral.enumerationDefinition()), &quot;::&quot;, m_typeNamer.mangledNameForEnumerationMember(*enumerationMemberLiteral.enumerationMember()));
820         }
821     ));
822 }
823 
824 class RenderFunctionDefinitionWriter final : public FunctionDefinitionWriter {
825 public:
826     RenderFunctionDefinitionWriter(StringBuilder&amp; stringBuilder, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, HashMap&lt;AST::FunctionDeclaration*, MangledFunctionName&gt;&amp; functionMapping, MatchedRenderSemantics&amp;&amp; matchedSemantics, Layout&amp; layout)
827         : FunctionDefinitionWriter(stringBuilder, intrinsics, typeNamer, functionMapping, layout)
828         , m_matchedSemantics(WTFMove(matchedSemantics))
829     {
</pre>
</td>
</tr>
</table>
<center><a href="WHLSLEntryPointScaffolding.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLMetalCodeGenerator.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
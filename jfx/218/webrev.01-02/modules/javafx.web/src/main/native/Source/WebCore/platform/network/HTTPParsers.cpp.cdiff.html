<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/network/HTTPParsers.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTTPHeaderNames.in.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="HTTPParsers.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/network/HTTPParsers.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 31,31 ***</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;HTTPParsers.h&quot;
  
  #include &quot;HTTPHeaderNames.h&quot;
  #include &lt;wtf/DateMath.h&gt;
  #include &lt;wtf/Language.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/Optional.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  #include &lt;wtf/unicode/CharacterNames.h&gt;
  
  
  namespace WebCore {
  
  // true if there is more to parse, after incrementing pos past whitespace.
  // Note: Might return pos == str.length()
  static inline bool skipWhiteSpace(const String&amp; str, unsigned&amp; pos)
  {
<span class="line-modified">!     unsigned len = str.length();</span>
<span class="line-modified">! </span>
<span class="line-removed">-     while (pos &lt; len &amp;&amp; (str[pos] == &#39;\t&#39; || str[pos] == &#39; &#39;))</span>
<span class="line-removed">-         ++pos;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return pos &lt; len;</span>
  }
  
  // Returns true if the function can match the whole token (case insensitive)
  // incrementing pos on match, otherwise leaving pos unchanged.
  // Note: Might return pos == str.length()
<span class="line-new-header">--- 31,41 ---</span>
   */
  
  #include &quot;config.h&quot;
  #include &quot;HTTPParsers.h&quot;
  
<span class="line-added">+ #include &quot;HTTPHeaderField.h&quot;</span>
  #include &quot;HTTPHeaderNames.h&quot;
<span class="line-added">+ #include &quot;ParsedContentType.h&quot;</span>
  #include &lt;wtf/DateMath.h&gt;
  #include &lt;wtf/Language.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
  #include &lt;wtf/Optional.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  #include &lt;wtf/unicode/CharacterNames.h&gt;
  
  
  namespace WebCore {
  
<span class="line-added">+ // True if characters which satisfy the predicate are present, incrementing</span>
<span class="line-added">+ // &quot;pos&quot; to the next character which does not satisfy the predicate.</span>
<span class="line-added">+ // Note: might return pos == str.length().</span>
<span class="line-added">+ static inline bool skipWhile(const String&amp; str, unsigned&amp; pos, const WTF::Function&lt;bool(const UChar)&gt;&amp; predicate)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     const unsigned start = pos;</span>
<span class="line-added">+     const unsigned len = str.length();</span>
<span class="line-added">+     while (pos &lt; len &amp;&amp; predicate(str[pos]))</span>
<span class="line-added">+         ++pos;</span>
<span class="line-added">+     return pos != start;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // true if there is more to parse, after incrementing pos past whitespace.
  // Note: Might return pos == str.length()
  static inline bool skipWhiteSpace(const String&amp; str, unsigned&amp; pos)
  {
<span class="line-modified">!     skipWhile(str, pos, RFC7230::isWhitespace);</span>
<span class="line-modified">!     return pos &lt; str.length();</span>
  }
  
  // Returns true if the function can match the whole token (case insensitive)
  // incrementing pos on match, otherwise leaving pos unchanged.
  // Note: Might return pos == str.length()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,22 ***</span>
          ++pos;
      }
      return pos != start;
  }
  
<span class="line-removed">- // True if characters which satisfy the predicate are present, incrementing</span>
<span class="line-removed">- // &quot;pos&quot; to the next character which does not satisfy the predicate.</span>
<span class="line-removed">- // Note: might return pos == str.length().</span>
<span class="line-removed">- static inline bool skipWhile(const String&amp; str, unsigned&amp; pos, const WTF::Function&lt;bool(const UChar)&gt;&amp; predicate)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     const unsigned start = pos;</span>
<span class="line-removed">-     const unsigned len = str.length();</span>
<span class="line-removed">-     while (pos &lt; len &amp;&amp; predicate(str[pos]))</span>
<span class="line-removed">-         ++pos;</span>
<span class="line-removed">-     return pos != start;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // See RFC 7230, Section 3.1.2.
  bool isValidReasonPhrase(const String&amp; value)
  {
      for (unsigned i = 0; i &lt; value.length(); ++i) {
          UChar c = value[i];
<span class="line-new-header">--- 105,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,48 ***</span>
              return false;
      }
      return true;
  }
  
<span class="line-removed">- // See RFC 7230, Section 3.2.6.</span>
<span class="line-removed">- static bool isDelimiterCharacter(const UChar c)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // DQUOTE and &quot;(),/:;&lt;=&gt;?@[\]{}&quot;</span>
<span class="line-removed">-     return (c == &#39;&quot;&#39; || c == &#39;(&#39; || c == &#39;)&#39; || c == &#39;,&#39; || c == &#39;/&#39; || c == &#39;:&#39; || c == &#39;;&#39;</span>
<span class="line-removed">-         || c == &#39;&lt;&#39; || c == &#39;=&#39; || c == &#39;&gt;&#39; || c == &#39;?&#39; || c == &#39;@&#39; || c == &#39;[&#39; || c == &#39;\\&#39;</span>
<span class="line-removed">-         || c == &#39;]&#39; || c == &#39;{&#39; || c == &#39;}&#39;);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // See RFC 7230, Section 3.2.6.</span>
<span class="line-removed">- static inline bool isVisibleCharacter(const UChar c)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // VCHAR = %x21-7E</span>
<span class="line-removed">-     return (c &gt;= 0x21 &amp;&amp; c &lt;= 0x7E);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // See RFC 7230, Section 3.2.6.</span>
<span class="line-removed">- static inline bool isOctectInFieldContentCharacter(const UChar c)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // obs-text = %x80-FF</span>
<span class="line-removed">-     return (c &gt;= 0x80 &amp;&amp; c &lt;= 0xFF);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // See RFC 7230, Section 3.2.6.</span>
<span class="line-removed">- static bool isCommentTextCharacter(const UChar c)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // ctext = HTAB / SP</span>
<span class="line-removed">-     //       / %x21-27 ; &#39;!&#39;-&#39;&#39;&#39;</span>
<span class="line-removed">-     //       / %x2A-5B ; &#39;*&#39;-&#39;[&#39;</span>
<span class="line-removed">-     //       / %x5D-7E ; &#39;]&#39;-&#39;~&#39;</span>
<span class="line-removed">-     //       / obs-text</span>
<span class="line-removed">-     return (c == &#39;\t&#39; || c == &#39; &#39;</span>
<span class="line-removed">-         || (c &gt;= 0x21 &amp;&amp; c &lt;= 0x27)</span>
<span class="line-removed">-         || (c &gt;= 0x2A &amp;&amp; c &lt;= 0x5B)</span>
<span class="line-removed">-         || (c &gt;= 0x5D &amp;&amp; c &lt;= 0x7E)</span>
<span class="line-removed">-         || isOctectInFieldContentCharacter(c));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // See RFC 7231, Section 5.3.2.
  bool isValidAcceptHeaderValue(const String&amp; value)
  {
      for (unsigned i = 0; i &lt; value.length(); ++i) {
          UChar c = value[i];
<span class="line-new-header">--- 134,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 188,17 ***</span>
  
          ASSERT(isLatin1(c));
          if (c == 0x7F || (c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;))
              return false;
  
<span class="line-modified">!         if (isDelimiterCharacter(c))</span>
              return false;
      }
  
      return true;
  }
  
  // See RFC 7231, Section 5.3.5 and 3.1.3.2.
  bool isValidLanguageHeaderValue(const String&amp; value)
  {
      for (unsigned i = 0; i &lt; value.length(); ++i) {
          UChar c = value[i];
<span class="line-new-header">--- 148,30 ---</span>
  
          ASSERT(isLatin1(c));
          if (c == 0x7F || (c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;))
              return false;
  
<span class="line-modified">!         if (RFC7230::isDelimiter(c))</span>
              return false;
      }
  
      return true;
  }
  
<span class="line-added">+ static bool containsCORSUnsafeRequestHeaderBytes(const String&amp; value)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     for (unsigned i = 0; i &lt; value.length(); ++i) {</span>
<span class="line-added">+         UChar c = value[i];</span>
<span class="line-added">+         // https://fetch.spec.whatwg.org/#cors-unsafe-request-header-byte</span>
<span class="line-added">+         if ((c &lt; 0x20 &amp;&amp; c != &#39;\t&#39;) || (c == &#39;&quot;&#39; || c == &#39;(&#39; || c == &#39;)&#39; || c == &#39;:&#39; || c == &#39;&lt;&#39; || c == &#39;&gt;&#39; || c == &#39;?&#39;</span>
<span class="line-added">+             || c == &#39;@&#39; || c == &#39;[&#39; || c == &#39;\\&#39; || c == &#39;]&#39; || c == 0x7B || c == &#39;{&#39; || c == &#39;}&#39; || c == 0x7F))</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // See RFC 7231, Section 5.3.5 and 3.1.3.2.
  bool isValidLanguageHeaderValue(const String&amp; value)
  {
      for (unsigned i = 0; i &lt; value.length(); ++i) {
          UChar c = value[i];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 212,30 ***</span>
      // Language tags https://tools.ietf.org/html/rfc7231#section-3.1.3.1
      // Language tag syntax https://tools.ietf.org/html/bcp47#section-2.1
      return true;
  }
  
<span class="line-removed">- // See RFC 7230, Section 3.2.6.</span>
<span class="line-removed">- static inline bool isHTTPTokenCharacter(const UChar c)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // Any VCHAR, except delimiters</span>
<span class="line-removed">-     return c &gt; 0x20 &amp;&amp; c &lt; 0x7F &amp;&amp; !isDelimiterCharacter(c);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // See RFC 7230, Section 3.2.6.
  bool isValidHTTPToken(const String&amp; value)
  {
      if (value.isEmpty())
          return false;
      auto valueStringView = StringView(value);
      for (UChar c : valueStringView.codeUnits()) {
<span class="line-modified">!         if (!isHTTPTokenCharacter(c))</span>
              return false;
      }
      return true;
  }
  
  // True if the character at the given position satisifies a predicate, incrementing &quot;pos&quot; by one.
  // Note: Might return pos == str.length()
  static inline bool skipCharacter(const String&amp; value, unsigned&amp; pos, WTF::Function&lt;bool(const UChar)&gt;&amp;&amp; predicate)
  {
      if (pos &lt; value.length() &amp;&amp; predicate(value[pos])) {
<span class="line-new-header">--- 185,24 ---</span>
      // Language tags https://tools.ietf.org/html/rfc7231#section-3.1.3.1
      // Language tag syntax https://tools.ietf.org/html/bcp47#section-2.1
      return true;
  }
  
  // See RFC 7230, Section 3.2.6.
  bool isValidHTTPToken(const String&amp; value)
  {
      if (value.isEmpty())
          return false;
      auto valueStringView = StringView(value);
      for (UChar c : valueStringView.codeUnits()) {
<span class="line-modified">!         if (!RFC7230::isTokenCharacter(c))</span>
              return false;
      }
      return true;
  }
  
<span class="line-added">+ #if USE(GLIB)</span>
  // True if the character at the given position satisifies a predicate, incrementing &quot;pos&quot; by one.
  // Note: Might return pos == str.length()
  static inline bool skipCharacter(const String&amp; value, unsigned&amp; pos, WTF::Function&lt;bool(const UChar)&gt;&amp;&amp; predicate)
  {
      if (pos &lt; value.length() &amp;&amp; predicate(value[pos])) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 259,17 ***</span>
  // See RFC 7230, Section 3.2.6.
  static constexpr auto QuotedPairStartCharacter = &#39;\\&#39;;
  static bool skipQuotedPair(const String&amp; value, unsigned&amp; pos)
  {
      // quoted-pair = &quot;\&quot; ( HTAB / SP / VCHAR / obs-text )
<span class="line-modified">!     if (!skipCharacter(value, pos, QuotedPairStartCharacter))</span>
<span class="line-modified">!         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return skipCharacter(value, pos, &#39;\t&#39;)</span>
<span class="line-removed">-         || skipCharacter(value, pos, &#39; &#39;)</span>
<span class="line-removed">-         || skipCharacter(value, pos, isVisibleCharacter)</span>
<span class="line-removed">-         || skipCharacter(value, pos, isOctectInFieldContentCharacter);</span>
  }
  
  // True if a comment is present, incrementing &quot;pos&quot; to the position after the comment.
  // Note: Might return pos == str.length()
  // See RFC 7230, Section 3.2.6.
<span class="line-new-header">--- 226,12 ---</span>
  // See RFC 7230, Section 3.2.6.
  static constexpr auto QuotedPairStartCharacter = &#39;\\&#39;;
  static bool skipQuotedPair(const String&amp; value, unsigned&amp; pos)
  {
      // quoted-pair = &quot;\&quot; ( HTAB / SP / VCHAR / obs-text )
<span class="line-modified">!     return skipCharacter(value, pos, QuotedPairStartCharacter)</span>
<span class="line-modified">!         &amp;&amp; skipCharacter(value, pos, RFC7230::isQuotedPairSecondOctet);</span>
  }
  
  // True if a comment is present, incrementing &quot;pos&quot; to the position after the comment.
  // Note: Might return pos == str.length()
  // See RFC 7230, Section 3.2.6.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 292,11 ***</span>
          case QuotedPairStartCharacter:
              if (!skipQuotedPair(value, pos))
                  return false;
              break;
          default:
<span class="line-modified">!             if (!skipWhile(value, pos, isCommentTextCharacter))</span>
                  return false;
          }
      }
      return skipCharacter(value, pos, CommentEndCharacter);
  }
<span class="line-new-header">--- 254,11 ---</span>
          case QuotedPairStartCharacter:
              if (!skipQuotedPair(value, pos))
                  return false;
              break;
          default:
<span class="line-modified">!             if (!skipWhile(value, pos, RFC7230::isCommentText))</span>
                  return false;
          }
      }
      return skipCharacter(value, pos, CommentEndCharacter);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 304,11 ***</span>
  // True if an HTTP header token is present, incrementing &quot;pos&quot; to the position after it.
  // Note: Might return pos == str.length()
  // See RFC 7230, Section 3.2.6.
  static bool skipHTTPToken(const String&amp; value, unsigned&amp; pos)
  {
<span class="line-modified">!     return skipWhile(value, pos, isHTTPTokenCharacter);</span>
  }
  
  // True if a product specifier (as in an User-Agent header) is present, incrementing &quot;pos&quot; to the position after it.
  // Note: Might return pos == str.length()
  // See RFC 7231, Section 5.5.3.
<span class="line-new-header">--- 266,11 ---</span>
  // True if an HTTP header token is present, incrementing &quot;pos&quot; to the position after it.
  // Note: Might return pos == str.length()
  // See RFC 7230, Section 3.2.6.
  static bool skipHTTPToken(const String&amp; value, unsigned&amp; pos)
  {
<span class="line-modified">!     return skipWhile(value, pos, RFC7230::isTokenCharacter);</span>
  }
  
  // True if a product specifier (as in an User-Agent header) is present, incrementing &quot;pos&quot; to the position after it.
  // Note: Might return pos == str.length()
  // See RFC 7231, Section 5.5.3.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 343,79 ***</span>
          }
      }
  
      return pos == value.length();
  }
  
  static const size_t maxInputSampleSize = 128;
  static String trimInputSample(const char* p, size_t length)
  {
      String s = String(p, std::min&lt;size_t&gt;(length, maxInputSampleSize));
      if (length &gt; maxInputSampleSize)
          s.append(horizontalEllipsis);
      return s;
  }
  
<span class="line-removed">- bool parseHTTPRefresh(const String&amp; refresh, double&amp; delay, String&amp; url)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     unsigned len = refresh.length();</span>
<span class="line-removed">-     unsigned pos = 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!skipWhiteSpace(refresh, pos))</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     while (pos != len &amp;&amp; refresh[pos] != &#39;,&#39; &amp;&amp; refresh[pos] != &#39;;&#39;)</span>
<span class="line-removed">-         ++pos;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (pos == len) { // no URL</span>
<span class="line-removed">-         url = String();</span>
<span class="line-removed">-         bool ok;</span>
<span class="line-removed">-         delay = refresh.stripWhiteSpace().toDouble(&amp;ok);</span>
<span class="line-removed">-         return ok;</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-         bool ok;</span>
<span class="line-removed">-         delay = refresh.left(pos).stripWhiteSpace().toDouble(&amp;ok);</span>
<span class="line-removed">-         if (!ok)</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         ++pos;</span>
<span class="line-removed">-         skipWhiteSpace(refresh, pos);</span>
<span class="line-removed">-         unsigned urlStartPos = pos;</span>
<span class="line-removed">-         if (refresh.findIgnoringASCIICase(&quot;url&quot;, urlStartPos) == urlStartPos) {</span>
<span class="line-removed">-             urlStartPos += 3;</span>
<span class="line-removed">-             skipWhiteSpace(refresh, urlStartPos);</span>
<span class="line-removed">-             if (refresh[urlStartPos] == &#39;=&#39;) {</span>
<span class="line-removed">-                 ++urlStartPos;</span>
<span class="line-removed">-                 skipWhiteSpace(refresh, urlStartPos);</span>
<span class="line-removed">-             } else</span>
<span class="line-removed">-                 urlStartPos = pos;  // e.g. &quot;Refresh: 0; url.html&quot;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         unsigned urlEndPos = len;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (refresh[urlStartPos] == &#39;&quot;&#39; || refresh[urlStartPos] == &#39;\&#39;&#39;) {</span>
<span class="line-removed">-             UChar quotationMark = refresh[urlStartPos];</span>
<span class="line-removed">-             urlStartPos++;</span>
<span class="line-removed">-             while (urlEndPos &gt; urlStartPos) {</span>
<span class="line-removed">-                 urlEndPos--;</span>
<span class="line-removed">-                 if (refresh[urlEndPos] == quotationMark)</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-             }</span>
<span class="line-removed">- </span>
<span class="line-removed">-             // https://bugs.webkit.org/show_bug.cgi?id=27868</span>
<span class="line-removed">-             // Sometimes there is no closing quote for the end of the URL even though there was an opening quote.</span>
<span class="line-removed">-             // If we looped over the entire alleged URL string back to the opening quote, just use everything</span>
<span class="line-removed">-             // after the opening quote instead.</span>
<span class="line-removed">-             if (urlEndPos == urlStartPos)</span>
<span class="line-removed">-                 urlEndPos = len;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">- </span>
<span class="line-removed">-         url = refresh.substring(urlStartPos, urlEndPos - urlStartPos).stripWhiteSpace();</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  Optional&lt;WallTime&gt; parseHTTPDate(const String&amp; value)
  {
      double dateInMillisecondsSinceEpoch = parseDateFromNullTerminatedCharacters(value.utf8().data());
      if (!std::isfinite(dateInMillisecondsSinceEpoch))
          return WTF::nullopt;
<span class="line-new-header">--- 305,21 ---</span>
          }
      }
  
      return pos == value.length();
  }
<span class="line-added">+ #endif</span>
  
  static const size_t maxInputSampleSize = 128;
  static String trimInputSample(const char* p, size_t length)
  {
      String s = String(p, std::min&lt;size_t&gt;(length, maxInputSampleSize));
      if (length &gt; maxInputSampleSize)
          s.append(horizontalEllipsis);
      return s;
  }
  
  Optional&lt;WallTime&gt; parseHTTPDate(const String&amp; value)
  {
      double dateInMillisecondsSinceEpoch = parseDateFromNullTerminatedCharacters(value.utf8().data());
      if (!std::isfinite(dateInMillisecondsSinceEpoch))
          return WTF::nullopt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 958,10 ***</span>
<span class="line-new-header">--- 862,34 ---</span>
          }
      }
      return startsWithLettersIgnoringASCIICase(name, &quot;sec-&quot;) || startsWithLettersIgnoringASCIICase(name, &quot;proxy-&quot;);
  }
  
<span class="line-added">+ // Implements &lt;https://fetch.spec.whatwg.org/#no-cors-safelisted-request-header-name&gt;.</span>
<span class="line-added">+ bool isNoCORSSafelistedRequestHeaderName(const String&amp; name)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     HTTPHeaderName headerName;</span>
<span class="line-added">+     if (findHTTPHeaderName(name, headerName)) {</span>
<span class="line-added">+         switch (headerName) {</span>
<span class="line-added">+         case HTTPHeaderName::Accept:</span>
<span class="line-added">+         case HTTPHeaderName::AcceptLanguage:</span>
<span class="line-added">+         case HTTPHeaderName::ContentLanguage:</span>
<span class="line-added">+         case HTTPHeaderName::ContentType:</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         default:</span>
<span class="line-added">+             break;</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Implements &lt;https://fetch.spec.whatwg.org/#privileged-no-cors-request-header-name&gt;.</span>
<span class="line-added">+ bool isPriviledgedNoCORSRequestHeaderName(const String&amp; name)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return equalLettersIgnoringASCIICase(name, &quot;range&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Implements &lt;https://fetch.spec.whatwg.org/#forbidden-response-header-name&gt;.
  bool isForbiddenResponseHeaderName(const String&amp; name)
  {
      return equalLettersIgnoringASCIICase(name, &quot;set-cookie&quot;) || equalLettersIgnoringASCIICase(name, &quot;set-cookie2&quot;);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1001,11 ***</span>
      return accessControlExposeHeaderSet.contains(httpHeaderNameString(name).toStringWithoutCopying());
  }
  
  bool isCrossOriginSafeHeader(const String&amp; name, const HTTPHeaderSet&amp; accessControlExposeHeaderSet)
  {
<span class="line-modified">! #ifndef ASSERT_DISABLED</span>
      HTTPHeaderName headerName;
      ASSERT(!findHTTPHeaderName(name, headerName));
  #endif
      return accessControlExposeHeaderSet.contains(name);
  }
<span class="line-new-header">--- 929,11 ---</span>
      return accessControlExposeHeaderSet.contains(httpHeaderNameString(name).toStringWithoutCopying());
  }
  
  bool isCrossOriginSafeHeader(const String&amp; name, const HTTPHeaderSet&amp; accessControlExposeHeaderSet)
  {
<span class="line-modified">! #if ASSERT_ENABLED</span>
      HTTPHeaderName headerName;
      ASSERT(!findHTTPHeaderName(name, headerName));
  #endif
      return accessControlExposeHeaderSet.contains(name);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1023,11 ***</span>
          if (!isValidLanguageHeaderValue(value))
              return false;
          break;
      case HTTPHeaderName::ContentType: {
          // Preflight is required for MIME types that can not be sent via form submission.
<span class="line-modified">!         String mimeType = extractMIMETypeFromMediaType(value);</span>
          if (!(equalLettersIgnoringASCIICase(mimeType, &quot;application/x-www-form-urlencoded&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;multipart/form-data&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;text/plain&quot;)))
              return false;
          break;
      }
      default:
<span class="line-new-header">--- 951,16 ---</span>
          if (!isValidLanguageHeaderValue(value))
              return false;
          break;
      case HTTPHeaderName::ContentType: {
          // Preflight is required for MIME types that can not be sent via form submission.
<span class="line-modified">!         if (containsCORSUnsafeRequestHeaderBytes(value))</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         auto parsedContentType = ParsedContentType::create(value);</span>
<span class="line-added">+         if (!parsedContentType)</span>
<span class="line-added">+             return false;</span>
<span class="line-added">+         String mimeType = parsedContentType-&gt;mimeType();</span>
          if (!(equalLettersIgnoringASCIICase(mimeType, &quot;application/x-www-form-urlencoded&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;multipart/form-data&quot;) || equalLettersIgnoringASCIICase(mimeType, &quot;text/plain&quot;)))
              return false;
          break;
      }
      default:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1050,10 ***</span>
<span class="line-new-header">--- 983,21 ---</span>
          }
      }
      return method;
  }
  
<span class="line-added">+ // Defined by https://tools.ietf.org/html/rfc7231#section-4.2.1</span>
<span class="line-added">+ bool isSafeMethod(const String&amp; method)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     const ASCIILiteral safeMethods[] = { &quot;GET&quot;_s, &quot;HEAD&quot;_s, &quot;OPTIONS&quot;_s, &quot;TRACE&quot;_s };</span>
<span class="line-added">+     for (auto value : safeMethods) {</span>
<span class="line-added">+         if (equalIgnoringASCIICase(method, value.characters()))</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  CrossOriginResourcePolicy parseCrossOriginResourcePolicyHeader(StringView header)
  {
      auto strippedHeader = stripLeadingAndTrailingHTTPSpaces(header);
  
      if (strippedHeader.isEmpty())
</pre>
<center><a href="HTTPHeaderNames.in.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="HTTPParsers.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
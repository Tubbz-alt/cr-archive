diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/Microtasks.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/Microtasks.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/Microtasks.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/Microtasks.cpp
@@ -21,90 +21,49 @@
 
 #include "config.h"
 #include "Microtasks.h"
 
 #include "CommonVM.h"
+#include "EventLoop.h"
 #include "WorkerGlobalScope.h"
 #include <wtf/MainThread.h>
 #include <wtf/NeverDestroyed.h>
 #include <wtf/SetForScope.h>
 
 namespace WebCore {
 
-void Microtask::removeSelfFromQueue(MicrotaskQueue& queue)
-{
-    queue.remove(*this);
-}
-
 MicrotaskQueue::MicrotaskQueue(JSC::VM& vm)
     : m_vm(makeRef(vm))
-    , m_timer(*this, &MicrotaskQueue::timerFired)
 {
 }
 
 MicrotaskQueue::~MicrotaskQueue() = default;
 
-MicrotaskQueue& MicrotaskQueue::mainThreadQueue()
-{
-    ASSERT(isMainThread());
-    static NeverDestroyed<MicrotaskQueue> queue(commonVM());
-    return queue;
-}
-
-MicrotaskQueue& MicrotaskQueue::contextQueue(ScriptExecutionContext& context)
-{
-    // While main thread has many ScriptExecutionContexts, WorkerGlobalScope and worker thread have
-    // one on one correspondence. The lifetime of MicrotaskQueue is aligned to this semantics.
-    // While main thread MicrotaskQueue is persistently held, worker's MicrotaskQueue is held by
-    // WorkerGlobalScope.
-    if (isMainThread())
-        return mainThreadQueue();
-    return downcast<WorkerGlobalScope>(context).microtaskQueue();
-}
-
-void MicrotaskQueue::append(std::unique_ptr<Microtask>&& task)
+void MicrotaskQueue::append(std::unique_ptr<EventLoopTask>&& task)
 {
     m_microtaskQueue.append(WTFMove(task));
-
-    m_timer.startOneShot(0_s);
-}
-
-void MicrotaskQueue::remove(const Microtask& task)
-{
-    for (size_t i = 0; i < m_microtaskQueue.size(); ++i) {
-        if (m_microtaskQueue[i].get() == &task) {
-            m_microtaskQueue.remove(i);
-            return;
-        }
-    }
-}
-
-void MicrotaskQueue::timerFired()
-{
-    performMicrotaskCheckpoint();
 }
 
 void MicrotaskQueue::performMicrotaskCheckpoint()
 {
     if (m_performingMicrotaskCheckpoint)
         return;
 
     SetForScope<bool> change(m_performingMicrotaskCheckpoint, true);
     JSC::JSLockHolder locker(vm());
 
-    Vector<std::unique_ptr<Microtask>> toKeep;
+    Vector<std::unique_ptr<EventLoopTask>> toKeep;
     while (!m_microtaskQueue.isEmpty()) {
-        Vector<std::unique_ptr<Microtask>> queue = WTFMove(m_microtaskQueue);
+        Vector<std::unique_ptr<EventLoopTask>> queue = WTFMove(m_microtaskQueue);
         for (auto& task : queue) {
-            auto result = task->run();
-            switch (result) {
-            case Microtask::Result::Done:
-                break;
-            case Microtask::Result::KeepInQueue:
+            auto* group = task->group();
+            if (!group || group->isStoppedPermanently())
+                continue;
+            if (group->isSuspended())
                 toKeep.append(WTFMove(task));
-                break;
-            }
+            else
+                task->execute();
         }
     }
 
     vm().finalizeSynchronousJSExecution();
     m_microtaskQueue = WTFMove(toKeep);

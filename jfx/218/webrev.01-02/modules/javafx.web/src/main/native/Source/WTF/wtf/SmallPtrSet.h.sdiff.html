<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/SmallPtrSet.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SizeLimits.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackBounds.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/SmallPtrSet.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/Assertions.h&gt;
 29 #include &lt;wtf/FastMalloc.h&gt;
 30 #include &lt;wtf/HashFunctions.h&gt;
 31 #include &lt;wtf/Noncopyable.h&gt;
 32 
 33 namespace WTF {
 34 


 35 template&lt;typename PtrType, unsigned SmallArraySize = 8&gt;
 36 class SmallPtrSet {
 37     WTF_MAKE_FAST_ALLOCATED;
 38     WTF_MAKE_NONCOPYABLE(SmallPtrSet);
 39     static_assert(std::is_trivially_destructible&lt;PtrType&gt;::value, &quot;We currently don&#39;t support non-trivially destructible pointer types.&quot;);
 40     static_assert(sizeof(PtrType) == sizeof(void*), &quot;Only support pointer sized things.&quot;);
 41     static_assert(!(SmallArraySize &amp; (SmallArraySize - 1)), &quot;Inline size must be a power of two.&quot;);
 42 
 43 public:
 44     SmallPtrSet()
 45     {
 46         initialize();
 47     }
 48 
 49     // We take care to have SmallPtrSet have partial move semantics allowable through
 50     // memcpy. It&#39;s partial move semantics because our destructor should not be called
 51     // on the SmallPtrObject in the old memory we were moved from (otherwise, we might free m_buffer twice)
 52     // unless that old memory is reset to be isSmall(). See move constructor below.
 53     // To maintain these semantics, we determine if we&#39;re small by checking our size
 54     // and not our m_buffer pointer. And when we&#39;re small, we don&#39;t do operations on
 55     // m_buffer, instead, we perform operations on m_smallStorage directly. The reason we want
 56     // these semantics is that it&#39;s beneficial to have a Vector that contains SmallPtrSet
 57     // (or an object with SmallPtrSet as a field) be allowed to use memcpy for its move operation.
 58 
 59     SmallPtrSet(SmallPtrSet&amp;&amp; other)
 60     {
 61         memcpy(this, &amp;other, sizeof(SmallPtrSet));
 62         other.initialize();
 63     }
 64 
 65     SmallPtrSet&amp; operator=(SmallPtrSet&amp;&amp; other)
 66     {
 67         this-&gt;~SmallPtrSet();
 68         new (this) SmallPtrSet(WTFMove(other));
 69         return *this;
 70     }
 71 
 72     ~SmallPtrSet()
 73     {
 74         if (!isSmall())
<span class="line-modified"> 75             fastFree(m_buffer);</span>
 76     }
 77 
 78     inline void add(PtrType ptr)
 79     {
 80         ASSERT(isValidEntry(ptr));
 81 
 82         if (isSmall()) {
 83             for (unsigned i = 0; i &lt; m_size; i++) {
 84                 if (m_smallStorage[i] == ptr)
 85                     return;
 86             }
 87 
 88             if (m_size &lt; SmallArraySize) {
 89                 m_smallStorage[m_size] = ptr;
 90                 ++m_size;
 91                 return;
 92             }
 93 
 94             grow(std::max(64u, SmallArraySize * 2));
 95             // Fall through. We&#39;re no longer small :(
</pre>
<hr />
<pre>
192         return m_capacity == SmallArraySize;
193     }
194 
195     inline void initialize()
196     {
197         m_size = 0;
198         m_buffer = nullptr;
199         m_capacity = SmallArraySize;
200         memset(m_smallStorage, -1, sizeof(void*) * SmallArraySize);
201         ASSERT(isSmall());
202     }
203 
204     inline void grow(unsigned size)
205     {
206         ASSERT(static_cast&lt;int32_t&gt;(bitwise_cast&lt;intptr_t&gt;(emptyValue())) == -1);
207 
208         size_t allocationSize = sizeof(void*) * size;
209         bool wasSmall = isSmall();
210         void** oldBuffer = wasSmall ? m_smallStorage : m_buffer;
211         unsigned oldCapacity = m_capacity;
<span class="line-modified">212         m_buffer = static_cast&lt;void**&gt;(fastMalloc(allocationSize));</span>
213         memset(m_buffer, -1, allocationSize);
214         m_capacity = size;
215 
216         for (unsigned i = 0; i &lt; oldCapacity; i++) {
217             if (oldBuffer[i] != emptyValue()) {
218                 void** ptr = this-&gt;bucket(static_cast&lt;PtrType&gt;(oldBuffer[i]));
219                 *ptr = oldBuffer[i];
220             }
221         }
222 
223         if (!wasSmall)
<span class="line-modified">224             fastFree(oldBuffer);</span>
225     }
226 
227 
228     inline void** bucket(PtrType target) const
229     {
230         ASSERT(!(m_capacity &amp; (m_capacity - 1)));
231         unsigned bucket = PtrHashBase&lt;PtrType, false /* isSmartPtr */&gt;::hash(target) &amp; (m_capacity - 1);
232         unsigned index = 0;
233         while (true) {
234             void** ptr = m_buffer + bucket;
235             if (*ptr == emptyValue())
236                 return ptr;
237             if (*ptr == target)
238                 return ptr;
239             index++;
240             bucket = (bucket + index) &amp; (m_capacity - 1);
241         }
242     }
243 
244     unsigned m_size;
</pre>
</td>
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/Assertions.h&gt;
 29 #include &lt;wtf/FastMalloc.h&gt;
 30 #include &lt;wtf/HashFunctions.h&gt;
 31 #include &lt;wtf/Noncopyable.h&gt;
 32 
 33 namespace WTF {
 34 
<span class="line-added"> 35 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SmallPtrSet);</span>
<span class="line-added"> 36 </span>
 37 template&lt;typename PtrType, unsigned SmallArraySize = 8&gt;
 38 class SmallPtrSet {
 39     WTF_MAKE_FAST_ALLOCATED;
 40     WTF_MAKE_NONCOPYABLE(SmallPtrSet);
 41     static_assert(std::is_trivially_destructible&lt;PtrType&gt;::value, &quot;We currently don&#39;t support non-trivially destructible pointer types.&quot;);
 42     static_assert(sizeof(PtrType) == sizeof(void*), &quot;Only support pointer sized things.&quot;);
 43     static_assert(!(SmallArraySize &amp; (SmallArraySize - 1)), &quot;Inline size must be a power of two.&quot;);
 44 
 45 public:
 46     SmallPtrSet()
 47     {
 48         initialize();
 49     }
 50 
 51     // We take care to have SmallPtrSet have partial move semantics allowable through
 52     // memcpy. It&#39;s partial move semantics because our destructor should not be called
 53     // on the SmallPtrObject in the old memory we were moved from (otherwise, we might free m_buffer twice)
 54     // unless that old memory is reset to be isSmall(). See move constructor below.
 55     // To maintain these semantics, we determine if we&#39;re small by checking our size
 56     // and not our m_buffer pointer. And when we&#39;re small, we don&#39;t do operations on
 57     // m_buffer, instead, we perform operations on m_smallStorage directly. The reason we want
 58     // these semantics is that it&#39;s beneficial to have a Vector that contains SmallPtrSet
 59     // (or an object with SmallPtrSet as a field) be allowed to use memcpy for its move operation.
 60 
 61     SmallPtrSet(SmallPtrSet&amp;&amp; other)
 62     {
 63         memcpy(this, &amp;other, sizeof(SmallPtrSet));
 64         other.initialize();
 65     }
 66 
 67     SmallPtrSet&amp; operator=(SmallPtrSet&amp;&amp; other)
 68     {
 69         this-&gt;~SmallPtrSet();
 70         new (this) SmallPtrSet(WTFMove(other));
 71         return *this;
 72     }
 73 
 74     ~SmallPtrSet()
 75     {
 76         if (!isSmall())
<span class="line-modified"> 77             SmallPtrSetMalloc::free(m_buffer);</span>
 78     }
 79 
 80     inline void add(PtrType ptr)
 81     {
 82         ASSERT(isValidEntry(ptr));
 83 
 84         if (isSmall()) {
 85             for (unsigned i = 0; i &lt; m_size; i++) {
 86                 if (m_smallStorage[i] == ptr)
 87                     return;
 88             }
 89 
 90             if (m_size &lt; SmallArraySize) {
 91                 m_smallStorage[m_size] = ptr;
 92                 ++m_size;
 93                 return;
 94             }
 95 
 96             grow(std::max(64u, SmallArraySize * 2));
 97             // Fall through. We&#39;re no longer small :(
</pre>
<hr />
<pre>
194         return m_capacity == SmallArraySize;
195     }
196 
197     inline void initialize()
198     {
199         m_size = 0;
200         m_buffer = nullptr;
201         m_capacity = SmallArraySize;
202         memset(m_smallStorage, -1, sizeof(void*) * SmallArraySize);
203         ASSERT(isSmall());
204     }
205 
206     inline void grow(unsigned size)
207     {
208         ASSERT(static_cast&lt;int32_t&gt;(bitwise_cast&lt;intptr_t&gt;(emptyValue())) == -1);
209 
210         size_t allocationSize = sizeof(void*) * size;
211         bool wasSmall = isSmall();
212         void** oldBuffer = wasSmall ? m_smallStorage : m_buffer;
213         unsigned oldCapacity = m_capacity;
<span class="line-modified">214         m_buffer = static_cast&lt;void**&gt;(SmallPtrSetMalloc::malloc(allocationSize));</span>
215         memset(m_buffer, -1, allocationSize);
216         m_capacity = size;
217 
218         for (unsigned i = 0; i &lt; oldCapacity; i++) {
219             if (oldBuffer[i] != emptyValue()) {
220                 void** ptr = this-&gt;bucket(static_cast&lt;PtrType&gt;(oldBuffer[i]));
221                 *ptr = oldBuffer[i];
222             }
223         }
224 
225         if (!wasSmall)
<span class="line-modified">226             SmallPtrSetMalloc::free(oldBuffer);</span>
227     }
228 
229 
230     inline void** bucket(PtrType target) const
231     {
232         ASSERT(!(m_capacity &amp; (m_capacity - 1)));
233         unsigned bucket = PtrHashBase&lt;PtrType, false /* isSmartPtr */&gt;::hash(target) &amp; (m_capacity - 1);
234         unsigned index = 0;
235         while (true) {
236             void** ptr = m_buffer + bucket;
237             if (*ptr == emptyValue())
238                 return ptr;
239             if (*ptr == target)
240                 return ptr;
241             index++;
242             bucket = (bucket + index) &amp; (m_capacity - 1);
243         }
244     }
245 
246     unsigned m_size;
</pre>
</td>
</tr>
</table>
<center><a href="SizeLimits.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="StackBounds.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
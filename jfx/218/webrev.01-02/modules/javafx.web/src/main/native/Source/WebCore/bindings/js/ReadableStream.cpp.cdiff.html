<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ReadableStream.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSXPathNSResolverCustom.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ReadableStream.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ReadableStream.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 33,116 ***</span>
  
  
  namespace WebCore {
  using namespace JSC;
  
<span class="line-modified">! Ref&lt;ReadableStream&gt; ReadableStream::create(JSC::ExecState&amp; execState, RefPtr&lt;ReadableStreamSource&gt;&amp;&amp; source)</span>
  {
<span class="line-modified">!     VM&amp; vm = execState.vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      auto&amp; clientData = *static_cast&lt;JSVMClientData*&gt;(vm.clientData);
<span class="line-modified">!     auto&amp; globalObject = *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(execState.lexicalGlobalObject());</span>
  
<span class="line-modified">!     auto* constructor = JSC::asObject(globalObject.get(&amp;execState, clientData.builtinNames().ReadableStreamPrivateName()));</span>
  
      ConstructData constructData;
      ConstructType constructType = constructor-&gt;methodTable(vm)-&gt;getConstructData(constructor, constructData);
      ASSERT(constructType != ConstructType::None);
  
      MarkedArgumentBuffer args;
<span class="line-modified">!     args.append(source ? toJSNewlyCreated(&amp;execState, &amp;globalObject, source.releaseNonNull()) : JSC::jsUndefined());</span>
      ASSERT(!args.hasOverflowed());
  
<span class="line-modified">!     auto newReadableStream = jsDynamicCast&lt;JSReadableStream*&gt;(vm, JSC::construct(&amp;execState, constructor, constructType, constructData, args));</span>
      scope.assertNoException();
  
      return create(globalObject, *newReadableStream);
  }
  
  namespace ReadableStreamInternal {
<span class="line-modified">! static inline JSC::JSValue callFunction(JSC::ExecState&amp; state, JSC::JSValue jsFunction, JSC::JSValue thisValue, const JSC::ArgList&amp; arguments)</span>
  {
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
      JSC::CallData callData;
      auto callType = JSC::getCallData(vm, jsFunction, callData);
      ASSERT(callType != JSC::CallType::None);
<span class="line-modified">!     auto result = call(&amp;state, jsFunction, callType, callData, thisValue, arguments);</span>
      scope.assertNoException();
      return result;
  }
  }
  
  void ReadableStream::pipeTo(ReadableStreamSink&amp; sink)
  {
<span class="line-modified">!     auto&amp; state = *m_globalObject-&gt;globalExec();</span>
<span class="line-modified">!     JSVMClientData* clientData = static_cast&lt;JSVMClientData*&gt;(state.vm().clientData);</span>
      const Identifier&amp; privateName = clientData-&gt;builtinFunctions().readableStreamInternalsBuiltins().readableStreamPipeToPrivateName();
  
<span class="line-modified">!     auto readableStreamPipeTo = m_globalObject-&gt;get(&amp;state, privateName);</span>
<span class="line-modified">!     ASSERT(readableStreamPipeTo.isFunction(state.vm()));</span>
  
      MarkedArgumentBuffer arguments;
      arguments.append(readableStream());
<span class="line-modified">!     arguments.append(toJS(&amp;state, m_globalObject.get(), sink));</span>
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     ReadableStreamInternal::callFunction(state, readableStreamPipeTo, JSC::jsUndefined(), arguments);</span>
  }
  
  std::pair&lt;Ref&lt;ReadableStream&gt;, Ref&lt;ReadableStream&gt;&gt; ReadableStream::tee()
  {
<span class="line-modified">!     auto&amp; state = *m_globalObject-&gt;globalExec();</span>
<span class="line-modified">!     JSVMClientData* clientData = static_cast&lt;JSVMClientData*&gt;(state.vm().clientData);</span>
      const Identifier&amp; privateName = clientData-&gt;builtinFunctions().readableStreamInternalsBuiltins().readableStreamTeePrivateName();
  
<span class="line-modified">!     auto readableStreamTee = m_globalObject-&gt;get(&amp;state, privateName);</span>
<span class="line-modified">!     ASSERT(readableStreamTee.isFunction(state.vm()));</span>
  
      MarkedArgumentBuffer arguments;
      arguments.append(readableStream());
      arguments.append(JSC::jsBoolean(true));
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     auto returnedValue = ReadableStreamInternal::callFunction(state, readableStreamTee, JSC::jsUndefined(), arguments);</span>
  
<span class="line-modified">!     auto results = Detail::SequenceConverter&lt;IDLInterface&lt;ReadableStream&gt;&gt;::convert(state, returnedValue);</span>
  
      ASSERT(results.size() == 2);
      return std::make_pair(results[0].releaseNonNull(), results[1].releaseNonNull());
  }
  
  void ReadableStream::lock()
  {
<span class="line-modified">!     auto&amp; state = *m_globalObject-&gt;globalExec();</span>
<span class="line-modified">!     VM&amp; vm = state.vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      auto&amp; clientData = *static_cast&lt;JSVMClientData*&gt;(vm.clientData);
  
<span class="line-modified">!     auto* constructor = JSC::asObject(m_globalObject-&gt;get(&amp;state, clientData.builtinNames().ReadableStreamDefaultReaderPrivateName()));</span>
  
      ConstructData constructData;
      ConstructType constructType = constructor-&gt;methodTable(vm)-&gt;getConstructData(constructor, constructData);
      ASSERT(constructType != ConstructType::None);
  
      MarkedArgumentBuffer args;
      args.append(readableStream());
      ASSERT(!args.hasOverflowed());
  
<span class="line-modified">!     JSC::construct(&amp;state, constructor, constructType, constructData, args);</span>
      scope.assertNoException();
  }
  
  static inline bool checkReadableStream(JSDOMGlobalObject&amp; globalObject, JSReadableStream* readableStream, JSC::JSValue function)
  {
<span class="line-modified">!     auto&amp; state = *globalObject.globalExec();</span>
  
      ASSERT(function);
      JSC::MarkedArgumentBuffer arguments;
      arguments.append(readableStream);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     return ReadableStreamInternal::callFunction(state, function, JSC::jsUndefined(), arguments).isTrue();</span>
  }
  
  bool ReadableStream::isLocked() const
  {
      return checkReadableStream(*globalObject(), readableStream(), globalObject()-&gt;builtinInternalFunctions().readableStreamInternals().m_isReadableStreamLockedFunction.get());
<span class="line-new-header">--- 33,116 ---</span>
  
  
  namespace WebCore {
  using namespace JSC;
  
<span class="line-modified">! Ref&lt;ReadableStream&gt; ReadableStream::create(JSC::JSGlobalObject&amp; lexicalGlobalObject, RefPtr&lt;ReadableStreamSource&gt;&amp;&amp; source)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      auto&amp; clientData = *static_cast&lt;JSVMClientData*&gt;(vm.clientData);
<span class="line-modified">!     auto&amp; globalObject = *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject);</span>
  
<span class="line-modified">!     auto* constructor = JSC::asObject(globalObject.get(&amp;lexicalGlobalObject, clientData.builtinNames().ReadableStreamPrivateName()));</span>
  
      ConstructData constructData;
      ConstructType constructType = constructor-&gt;methodTable(vm)-&gt;getConstructData(constructor, constructData);
      ASSERT(constructType != ConstructType::None);
  
      MarkedArgumentBuffer args;
<span class="line-modified">!     args.append(source ? toJSNewlyCreated(&amp;lexicalGlobalObject, &amp;globalObject, source.releaseNonNull()) : JSC::jsUndefined());</span>
      ASSERT(!args.hasOverflowed());
  
<span class="line-modified">!     auto newReadableStream = jsDynamicCast&lt;JSReadableStream*&gt;(vm, JSC::construct(&amp;lexicalGlobalObject, constructor, constructType, constructData, args));</span>
      scope.assertNoException();
  
      return create(globalObject, *newReadableStream);
  }
  
  namespace ReadableStreamInternal {
<span class="line-modified">! static inline JSC::JSValue callFunction(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::JSValue jsFunction, JSC::JSValue thisValue, const JSC::ArgList&amp; arguments)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
      JSC::CallData callData;
      auto callType = JSC::getCallData(vm, jsFunction, callData);
      ASSERT(callType != JSC::CallType::None);
<span class="line-modified">!     auto result = call(&amp;lexicalGlobalObject, jsFunction, callType, callData, thisValue, arguments);</span>
      scope.assertNoException();
      return result;
  }
  }
  
  void ReadableStream::pipeTo(ReadableStreamSink&amp; sink)
  {
<span class="line-modified">!     auto&amp; lexicalGlobalObject = *m_globalObject;</span>
<span class="line-modified">!     JSVMClientData* clientData = static_cast&lt;JSVMClientData*&gt;(lexicalGlobalObject.vm().clientData);</span>
      const Identifier&amp; privateName = clientData-&gt;builtinFunctions().readableStreamInternalsBuiltins().readableStreamPipeToPrivateName();
  
<span class="line-modified">!     auto readableStreamPipeTo = m_globalObject-&gt;get(&amp;lexicalGlobalObject, privateName);</span>
<span class="line-modified">!     ASSERT(readableStreamPipeTo.isFunction(lexicalGlobalObject.vm()));</span>
  
      MarkedArgumentBuffer arguments;
      arguments.append(readableStream());
<span class="line-modified">!     arguments.append(toJS(&amp;lexicalGlobalObject, m_globalObject.get(), sink));</span>
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     ReadableStreamInternal::callFunction(lexicalGlobalObject, readableStreamPipeTo, JSC::jsUndefined(), arguments);</span>
  }
  
  std::pair&lt;Ref&lt;ReadableStream&gt;, Ref&lt;ReadableStream&gt;&gt; ReadableStream::tee()
  {
<span class="line-modified">!     auto&amp; lexicalGlobalObject = *m_globalObject;</span>
<span class="line-modified">!     JSVMClientData* clientData = static_cast&lt;JSVMClientData*&gt;(lexicalGlobalObject.vm().clientData);</span>
      const Identifier&amp; privateName = clientData-&gt;builtinFunctions().readableStreamInternalsBuiltins().readableStreamTeePrivateName();
  
<span class="line-modified">!     auto readableStreamTee = m_globalObject-&gt;get(&amp;lexicalGlobalObject, privateName);</span>
<span class="line-modified">!     ASSERT(readableStreamTee.isFunction(lexicalGlobalObject.vm()));</span>
  
      MarkedArgumentBuffer arguments;
      arguments.append(readableStream());
      arguments.append(JSC::jsBoolean(true));
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     auto returnedValue = ReadableStreamInternal::callFunction(lexicalGlobalObject, readableStreamTee, JSC::jsUndefined(), arguments);</span>
  
<span class="line-modified">!     auto results = Detail::SequenceConverter&lt;IDLInterface&lt;ReadableStream&gt;&gt;::convert(lexicalGlobalObject, returnedValue);</span>
  
      ASSERT(results.size() == 2);
      return std::make_pair(results[0].releaseNonNull(), results[1].releaseNonNull());
  }
  
  void ReadableStream::lock()
  {
<span class="line-modified">!     auto&amp; lexicalGlobalObject = *m_globalObject;</span>
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject.vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
  
      auto&amp; clientData = *static_cast&lt;JSVMClientData*&gt;(vm.clientData);
  
<span class="line-modified">!     auto* constructor = JSC::asObject(m_globalObject-&gt;get(&amp;lexicalGlobalObject, clientData.builtinNames().ReadableStreamDefaultReaderPrivateName()));</span>
  
      ConstructData constructData;
      ConstructType constructType = constructor-&gt;methodTable(vm)-&gt;getConstructData(constructor, constructData);
      ASSERT(constructType != ConstructType::None);
  
      MarkedArgumentBuffer args;
      args.append(readableStream());
      ASSERT(!args.hasOverflowed());
  
<span class="line-modified">!     JSC::construct(&amp;lexicalGlobalObject, constructor, constructType, constructData, args);</span>
      scope.assertNoException();
  }
  
  static inline bool checkReadableStream(JSDOMGlobalObject&amp; globalObject, JSReadableStream* readableStream, JSC::JSValue function)
  {
<span class="line-modified">!     auto&amp; lexicalGlobalObject = globalObject;</span>
  
      ASSERT(function);
      JSC::MarkedArgumentBuffer arguments;
      arguments.append(readableStream);
      ASSERT(!arguments.hasOverflowed());
<span class="line-modified">!     return ReadableStreamInternal::callFunction(lexicalGlobalObject, function, JSC::jsUndefined(), arguments).isTrue();</span>
  }
  
  bool ReadableStream::isLocked() const
  {
      return checkReadableStream(*globalObject(), readableStream(), globalObject()-&gt;builtinInternalFunctions().readableStreamInternals().m_isReadableStreamLockedFunction.get());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 151,14 ***</span>
  bool ReadableStream::isDisturbed() const
  {
      return checkReadableStream(*globalObject(), readableStream(), globalObject()-&gt;builtinInternalFunctions().readableStreamInternals().m_isReadableStreamDisturbedFunction.get());
  }
  
<span class="line-modified">! bool ReadableStream::isDisturbed(ExecState&amp; state, JSValue value)</span>
  {
<span class="line-modified">!     auto&amp; vm = state.vm();</span>
<span class="line-modified">!     auto&amp; globalObject = *jsDynamicCast&lt;JSDOMGlobalObject*&gt;(vm, state.lexicalGlobalObject());</span>
      auto* readableStream = jsDynamicCast&lt;JSReadableStream*&gt;(vm, value);
  
      return checkReadableStream(globalObject, readableStream, globalObject.builtinInternalFunctions().readableStreamInternals().m_isReadableStreamDisturbedFunction.get());
  }
  
<span class="line-new-header">--- 151,14 ---</span>
  bool ReadableStream::isDisturbed() const
  {
      return checkReadableStream(*globalObject(), readableStream(), globalObject()-&gt;builtinInternalFunctions().readableStreamInternals().m_isReadableStreamDisturbedFunction.get());
  }
  
<span class="line-modified">! bool ReadableStream::isDisturbed(JSGlobalObject&amp; lexicalGlobalObject, JSValue value)</span>
  {
<span class="line-modified">!     auto&amp; vm = lexicalGlobalObject.vm();</span>
<span class="line-modified">!     auto&amp; globalObject = *jsDynamicCast&lt;JSDOMGlobalObject*&gt;(vm, &amp;lexicalGlobalObject);</span>
      auto* readableStream = jsDynamicCast&lt;JSReadableStream*&gt;(vm, value);
  
      return checkReadableStream(globalObject, readableStream, globalObject.builtinInternalFunctions().readableStreamInternals().m_isReadableStreamDisturbedFunction.get());
  }
  
</pre>
<center><a href="JSXPathNSResolverCustom.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ReadableStream.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ReflectObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RandomizingFuzzerAgent.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReflectObject.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ReflectObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 32,20 ***</span>
  #include &quot;Lookup.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectConstruct(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectDefineProperty(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectGet(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectGetOwnPropertyDescriptor(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectGetPrototypeOf(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectIsExtensible(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectOwnKeys(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectPreventExtensions(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectSet(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectSetPrototypeOf(ExecState*);</span>
  
  }
  
  #include &quot;ReflectObject.lut.h&quot;
  
<span class="line-new-header">--- 32,20 ---</span>
  #include &quot;Lookup.h&quot;
  #include &quot;ObjectConstructor.h&quot;
  
  namespace JSC {
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectConstruct(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectDefineProperty(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectGet(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectGetOwnPropertyDescriptor(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectGetPrototypeOf(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectIsExtensible(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectOwnKeys(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectPreventExtensions(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectSet(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL reflectObjectSetPrototypeOf(JSGlobalObject*, CallFrame*);</span>
  
  }
  
  #include &quot;ReflectObject.lut.h&quot;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 85,207 ***</span>
  }
  
  // ------------------------------ Functions --------------------------------
  
  // https://tc39.github.io/ecma262/#sec-reflect.construct
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectConstruct(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = exec-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(exec, scope, &quot;Reflect.construct requires the first argument be a constructor&quot;_s));</span>
  
      ConstructData constructData;
      ConstructType constructType;
      if (!target.isConstructor(vm, constructType, constructData))
<span class="line-modified">!         return JSValue::encode(throwTypeError(exec, scope, &quot;Reflect.construct requires the first argument be a constructor&quot;_s));</span>
  
      JSValue newTarget = target;
<span class="line-modified">!     if (exec-&gt;argumentCount() &gt;= 3) {</span>
<span class="line-modified">!         newTarget = exec-&gt;argument(2);</span>
          if (!newTarget.isConstructor(vm))
<span class="line-modified">!             return JSValue::encode(throwTypeError(exec, scope, &quot;Reflect.construct requires the third argument be a constructor if present&quot;_s));</span>
      }
  
      MarkedArgumentBuffer arguments;
<span class="line-modified">!     JSObject* argumentsObject = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(1));</span>
      if (!argumentsObject)
<span class="line-modified">!         return JSValue::encode(throwTypeError(exec, scope, &quot;Reflect.construct requires the second argument be an object&quot;_s));</span>
  
<span class="line-modified">!     createListFromArrayLike(exec, argumentsObject, RuntimeTypeMaskAllTypes, &quot;This error must not be raised&quot;_s, &quot;This error must not be raised&quot;_s, [&amp;] (JSValue value, RuntimeType) -&gt; bool {</span>
          arguments.append(value);
          return false;
      });
      RETURN_IF_EXCEPTION(scope, (arguments.overflowCheckNotNeeded(), encodedJSValue()));
      if (UNLIKELY(arguments.hasOverflowed())) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return encodedJSValue();
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(construct(exec, target, constructType, constructData, arguments, newTarget)));</span>
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.defineproperty
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectDefineProperty(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = exec-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(exec, scope, &quot;Reflect.defineProperty requires the first argument be an object&quot;_s));</span>
<span class="line-modified">!     auto propertyName = exec-&gt;argument(1).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      PropertyDescriptor descriptor;
<span class="line-modified">!     bool success = toPropertyDescriptor(exec, exec-&gt;argument(2), descriptor);</span>
      EXCEPTION_ASSERT(!scope.exception() == success);
      if (UNLIKELY(!success))
          return encodedJSValue();
      ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
      scope.assertNoException();
  
      // Reflect.defineProperty should not throw an error when the defineOwnProperty operation fails.
      bool shouldThrow = false;
      JSObject* targetObject = asObject(target);
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(targetObject-&gt;methodTable(vm)-&gt;defineOwnProperty(targetObject, exec, propertyName, descriptor, shouldThrow))));</span>
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.get
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectGet(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = exec-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(exec, scope, &quot;Reflect.get requires the first argument be an object&quot;_s));</span>
  
<span class="line-modified">!     const Identifier propertyName = exec-&gt;argument(1).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      JSValue receiver = target;
<span class="line-modified">!     if (exec-&gt;argumentCount() &gt;= 3)</span>
<span class="line-modified">!         receiver = exec-&gt;argument(2);</span>
  
      PropertySlot slot(receiver, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(target.get(exec, propertyName, slot)));</span>
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.getownpropertydescriptor
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectGetOwnPropertyDescriptor(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = exec-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(exec, scope, &quot;Reflect.getOwnPropertyDescriptor requires the first argument be an object&quot;_s));</span>
  
<span class="line-modified">!     auto key = exec-&gt;argument(1).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(objectConstructorGetOwnPropertyDescriptor(exec, asObject(target), key)));</span>
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.getprototypeof
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectGetPrototypeOf(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = exec-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(exec, scope, &quot;Reflect.getPrototypeOf requires the first argument be an object&quot;_s));</span>
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(asObject(target)-&gt;getPrototype(vm, exec)));</span>
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.isextensible
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectIsExtensible(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = exec-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(exec, scope, &quot;Reflect.isExtensible requires the first argument be an object&quot;_s));</span>
  
<span class="line-modified">!     bool isExtensible = asObject(target)-&gt;isExtensible(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsBoolean(isExtensible));
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.ownkeys
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectOwnKeys(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = exec-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(exec, scope, &quot;Reflect.ownKeys requires the first argument be an object&quot;_s));</span>
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(exec, jsCast&lt;JSObject*&gt;(target), PropertyNameMode::StringsAndSymbols, DontEnumPropertiesMode::Include)));</span>
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.preventextensions
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectPreventExtensions(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = exec-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(exec, scope, &quot;Reflect.preventExtensions requires the first argument be an object&quot;_s));</span>
      JSObject* object = asObject(target);
<span class="line-modified">!     bool result = object-&gt;methodTable(vm)-&gt;preventExtensions(object, exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsBoolean(result));
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.set
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectSet(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = exec-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(exec, scope, &quot;Reflect.set requires the first argument be an object&quot;_s));</span>
      JSObject* targetObject = asObject(target);
  
<span class="line-modified">!     auto propertyName = exec-&gt;argument(1).toPropertyKey(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      JSValue receiver = target;
<span class="line-modified">!     if (exec-&gt;argumentCount() &gt;= 4)</span>
<span class="line-modified">!         receiver = exec-&gt;argument(3);</span>
  
      // Do not raise any readonly errors that happen in strict mode.
      bool shouldThrowIfCantSet = false;
      PutPropertySlot slot(receiver, shouldThrowIfCantSet);
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(targetObject-&gt;methodTable(vm)-&gt;put(targetObject, exec, propertyName, exec-&gt;argument(2), slot))));</span>
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.setprototypeof
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectSetPrototypeOf(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = exec-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(exec, scope, &quot;Reflect.setPrototypeOf requires the first argument be an object&quot;_s));</span>
<span class="line-modified">!     JSValue proto = exec-&gt;argument(1);</span>
      if (!proto.isObject() &amp;&amp; !proto.isNull())
<span class="line-modified">!         return JSValue::encode(throwTypeError(exec, scope, &quot;Reflect.setPrototypeOf requires the second argument be either an object or null&quot;_s));</span>
  
      JSObject* object = asObject(target);
  
      bool shouldThrowIfCantSet = false;
<span class="line-modified">!     bool didSetPrototype = object-&gt;setPrototype(vm, exec, proto, shouldThrowIfCantSet);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsBoolean(didSetPrototype));
  }
  
  } // namespace JSC
<span class="line-new-header">--- 85,207 ---</span>
  }
  
  // ------------------------------ Functions --------------------------------
  
  // https://tc39.github.io/ecma262/#sec-reflect.construct
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectConstruct(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = callFrame-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(globalObject, scope, &quot;Reflect.construct requires the first argument be a constructor&quot;_s));</span>
  
      ConstructData constructData;
      ConstructType constructType;
      if (!target.isConstructor(vm, constructType, constructData))
<span class="line-modified">!         return JSValue::encode(throwTypeError(globalObject, scope, &quot;Reflect.construct requires the first argument be a constructor&quot;_s));</span>
  
      JSValue newTarget = target;
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &gt;= 3) {</span>
<span class="line-modified">!         newTarget = callFrame-&gt;argument(2);</span>
          if (!newTarget.isConstructor(vm))
<span class="line-modified">!             return JSValue::encode(throwTypeError(globalObject, scope, &quot;Reflect.construct requires the third argument be a constructor if present&quot;_s));</span>
      }
  
      MarkedArgumentBuffer arguments;
<span class="line-modified">!     JSObject* argumentsObject = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(1));</span>
      if (!argumentsObject)
<span class="line-modified">!         return JSValue::encode(throwTypeError(globalObject, scope, &quot;Reflect.construct requires the second argument be an object&quot;_s));</span>
  
<span class="line-modified">!     createListFromArrayLike(globalObject, argumentsObject, RuntimeTypeMaskAllTypes, &quot;This error must not be raised&quot;_s, &quot;This error must not be raised&quot;_s, [&amp;] (JSValue value, RuntimeType) -&gt; bool {</span>
          arguments.append(value);
          return false;
      });
      RETURN_IF_EXCEPTION(scope, (arguments.overflowCheckNotNeeded(), encodedJSValue()));
      if (UNLIKELY(arguments.hasOverflowed())) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return encodedJSValue();
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(construct(globalObject, target, constructType, constructData, arguments, newTarget)));</span>
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.defineproperty
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectDefineProperty(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = callFrame-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(globalObject, scope, &quot;Reflect.defineProperty requires the first argument be an object&quot;_s));</span>
<span class="line-modified">!     auto propertyName = callFrame-&gt;argument(1).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      PropertyDescriptor descriptor;
<span class="line-modified">!     bool success = toPropertyDescriptor(globalObject, callFrame-&gt;argument(2), descriptor);</span>
      EXCEPTION_ASSERT(!scope.exception() == success);
      if (UNLIKELY(!success))
          return encodedJSValue();
      ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
      scope.assertNoException();
  
      // Reflect.defineProperty should not throw an error when the defineOwnProperty operation fails.
      bool shouldThrow = false;
      JSObject* targetObject = asObject(target);
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(targetObject-&gt;methodTable(vm)-&gt;defineOwnProperty(targetObject, globalObject, propertyName, descriptor, shouldThrow))));</span>
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.get
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectGet(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = callFrame-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(globalObject, scope, &quot;Reflect.get requires the first argument be an object&quot;_s));</span>
  
<span class="line-modified">!     const Identifier propertyName = callFrame-&gt;argument(1).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      JSValue receiver = target;
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &gt;= 3)</span>
<span class="line-modified">!         receiver = callFrame-&gt;argument(2);</span>
  
      PropertySlot slot(receiver, PropertySlot::InternalMethodType::Get);
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(target.get(globalObject, propertyName, slot)));</span>
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.getownpropertydescriptor
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectGetOwnPropertyDescriptor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = callFrame-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(globalObject, scope, &quot;Reflect.getOwnPropertyDescriptor requires the first argument be an object&quot;_s));</span>
  
<span class="line-modified">!     auto key = callFrame-&gt;argument(1).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(objectConstructorGetOwnPropertyDescriptor(globalObject, asObject(target), key)));</span>
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.getprototypeof
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectGetPrototypeOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = callFrame-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(globalObject, scope, &quot;Reflect.getPrototypeOf requires the first argument be an object&quot;_s));</span>
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(asObject(target)-&gt;getPrototype(vm, globalObject)));</span>
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.isextensible
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectIsExtensible(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = callFrame-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(globalObject, scope, &quot;Reflect.isExtensible requires the first argument be an object&quot;_s));</span>
  
<span class="line-modified">!     bool isExtensible = asObject(target)-&gt;isExtensible(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsBoolean(isExtensible));
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.ownkeys
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectOwnKeys(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = callFrame-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(globalObject, scope, &quot;Reflect.ownKeys requires the first argument be an object&quot;_s));</span>
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(ownPropertyKeys(globalObject, jsCast&lt;JSObject*&gt;(target), PropertyNameMode::StringsAndSymbols, DontEnumPropertiesMode::Include)));</span>
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.preventextensions
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectPreventExtensions(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = callFrame-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(globalObject, scope, &quot;Reflect.preventExtensions requires the first argument be an object&quot;_s));</span>
      JSObject* object = asObject(target);
<span class="line-modified">!     bool result = object-&gt;methodTable(vm)-&gt;preventExtensions(object, globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsBoolean(result));
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.set
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectSet(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = callFrame-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(globalObject, scope, &quot;Reflect.set requires the first argument be an object&quot;_s));</span>
      JSObject* targetObject = asObject(target);
  
<span class="line-modified">!     auto propertyName = callFrame-&gt;argument(1).toPropertyKey(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
      JSValue receiver = target;
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &gt;= 4)</span>
<span class="line-modified">!         receiver = callFrame-&gt;argument(3);</span>
  
      // Do not raise any readonly errors that happen in strict mode.
      bool shouldThrowIfCantSet = false;
      PutPropertySlot slot(receiver, shouldThrowIfCantSet);
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(targetObject-&gt;methodTable(vm)-&gt;put(targetObject, globalObject, propertyName, callFrame-&gt;argument(2), slot))));</span>
  }
  
  // https://tc39.github.io/ecma262/#sec-reflect.setprototypeof
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL reflectObjectSetPrototypeOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue target = callFrame-&gt;argument(0);</span>
      if (!target.isObject())
<span class="line-modified">!         return JSValue::encode(throwTypeError(globalObject, scope, &quot;Reflect.setPrototypeOf requires the first argument be an object&quot;_s));</span>
<span class="line-modified">!     JSValue proto = callFrame-&gt;argument(1);</span>
      if (!proto.isObject() &amp;&amp; !proto.isNull())
<span class="line-modified">!         return JSValue::encode(throwTypeError(globalObject, scope, &quot;Reflect.setPrototypeOf requires the second argument be either an object or null&quot;_s));</span>
  
      JSObject* object = asObject(target);
  
      bool shouldThrowIfCantSet = false;
<span class="line-modified">!     bool didSetPrototype = object-&gt;setPrototype(vm, globalObject, proto, shouldThrowIfCantSet);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      return JSValue::encode(jsBoolean(didSetPrototype));
  }
  
  } // namespace JSC
</pre>
<center><a href="RandomizingFuzzerAgent.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ReflectObject.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
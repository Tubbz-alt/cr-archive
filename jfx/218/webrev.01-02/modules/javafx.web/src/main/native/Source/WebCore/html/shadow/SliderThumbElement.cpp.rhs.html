<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/shadow/SliderThumbElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2006-2018 Apple Inc. All rights reserved.
  3  * Copyright (C) 2010 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 
 33 #include &quot;config.h&quot;
 34 #include &quot;SliderThumbElement.h&quot;
 35 
 36 #include &quot;CSSValueKeywords.h&quot;
 37 #include &quot;Event.h&quot;
 38 #include &quot;EventHandler.h&quot;
 39 #include &quot;EventNames.h&quot;
 40 #include &quot;Frame.h&quot;
 41 #include &quot;HTMLInputElement.h&quot;
 42 #include &quot;HTMLParserIdioms.h&quot;
 43 #include &quot;MouseEvent.h&quot;
 44 #include &quot;RenderFlexibleBox.h&quot;
 45 #include &quot;RenderSlider.h&quot;
 46 #include &quot;RenderTheme.h&quot;
 47 #include &quot;ShadowRoot.h&quot;
 48 #include &quot;StyleResolver.h&quot;
 49 #include &lt;wtf/IsoMallocInlines.h&gt;
 50 
 51 #if ENABLE(IOS_TOUCH_EVENTS)
 52 #include &quot;Document.h&quot;
 53 #include &quot;Page.h&quot;
 54 #include &quot;TouchEvent.h&quot;
 55 #endif
 56 
 57 namespace WebCore {
 58 
 59 using namespace HTMLNames;
 60 
 61 WTF_MAKE_ISO_ALLOCATED_IMPL(SliderThumbElement);
 62 WTF_MAKE_ISO_ALLOCATED_IMPL(SliderContainerElement);
 63 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderSliderThumb);
 64 
 65 inline static Decimal sliderPosition(HTMLInputElement&amp; element)
 66 {
 67     const StepRange stepRange(element.createStepRange(RejectAny));
 68     const Decimal oldValue = parseToDecimalForNumberType(element.value(), stepRange.defaultValue());
 69     return stepRange.proportionFromValue(stepRange.clampValue(oldValue));
 70 }
 71 
 72 inline static bool hasVerticalAppearance(HTMLInputElement&amp; input)
 73 {
 74     ASSERT(input.renderer());
 75     const RenderStyle&amp; sliderStyle = input.renderer()-&gt;style();
 76 
 77 #if ENABLE(VIDEO)
 78     if (sliderStyle.appearance() == MediaVolumeSliderPart &amp;&amp; input.renderer()-&gt;theme().usesVerticalVolumeSlider())
 79         return true;
 80 #endif
 81 
 82     return sliderStyle.appearance() == SliderVerticalPart;
 83 }
 84 
 85 // --------------------------------
 86 
 87 RenderSliderThumb::RenderSliderThumb(SliderThumbElement&amp; element, RenderStyle&amp;&amp; style)
 88     : RenderBlockFlow(element, WTFMove(style))
 89 {
 90 }
 91 
 92 void RenderSliderThumb::updateAppearance(const RenderStyle* parentStyle)
 93 {
 94     if (parentStyle-&gt;appearance() == SliderVerticalPart)
 95         mutableStyle().setAppearance(SliderThumbVerticalPart);
 96     else if (parentStyle-&gt;appearance() == SliderHorizontalPart)
 97         mutableStyle().setAppearance(SliderThumbHorizontalPart);
 98     else if (parentStyle-&gt;appearance() == MediaSliderPart)
 99         mutableStyle().setAppearance(MediaSliderThumbPart);
100     else if (parentStyle-&gt;appearance() == MediaVolumeSliderPart)
101         mutableStyle().setAppearance(MediaVolumeSliderThumbPart);
102     else if (parentStyle-&gt;appearance() == MediaFullScreenVolumeSliderPart)
103         mutableStyle().setAppearance(MediaFullScreenVolumeSliderThumbPart);
104     if (style().hasAppearance()) {
105         ASSERT(element());
106         theme().adjustSliderThumbSize(mutableStyle(), element());
107     }
108 }
109 
110 bool RenderSliderThumb::isSliderThumb() const
111 {
112     return true;
113 }
114 
115 // --------------------------------
116 
117 // FIXME: Find a way to cascade appearance and adjust heights, and get rid of this class.
118 // http://webkit.org/b/62535
119 class RenderSliderContainer final : public RenderFlexibleBox {
120     WTF_MAKE_ISO_ALLOCATED_INLINE(RenderSliderContainer);
121 public:
122     RenderSliderContainer(SliderContainerElement&amp; element, RenderStyle&amp;&amp; style)
123         : RenderFlexibleBox(element, WTFMove(style))
124     {
125     }
126 
127 public:
128     RenderBox::LogicalExtentComputedValues computeLogicalHeight(LayoutUnit logicalHeight, LayoutUnit logicalTop) const override;
129 
130 private:
131     void layout() override;
132     bool isFlexibleBoxImpl() const override { return true; }
133 };
134 
135 RenderBox::LogicalExtentComputedValues RenderSliderContainer::computeLogicalHeight(LayoutUnit logicalHeight, LayoutUnit logicalTop) const
136 {
137     ASSERT(element()-&gt;shadowHost());
138     auto&amp; input = downcast&lt;HTMLInputElement&gt;(*element()-&gt;shadowHost());
139     bool isVertical = hasVerticalAppearance(input);
140 
141 #if ENABLE(DATALIST_ELEMENT)
142     if (input.renderer()-&gt;isSlider() &amp;&amp; !isVertical &amp;&amp; input.list()) {
143         int offsetFromCenter = theme().sliderTickOffsetFromTrackCenter();
144         LayoutUnit trackHeight;
145         if (offsetFromCenter &lt; 0)
146             trackHeight = -2 * offsetFromCenter;
147         else {
148             int tickLength = theme().sliderTickSize().height();
149             trackHeight = 2 * (offsetFromCenter + tickLength);
150         }
151         float zoomFactor = style().effectiveZoom();
152         if (zoomFactor != 1.0)
153             trackHeight *= zoomFactor;
154 
155         return RenderBox::computeLogicalHeight(trackHeight, logicalTop);
156     }
157 #endif
158     if (isVertical)
159         logicalHeight = RenderSlider::defaultTrackLength;
160     return RenderBox::computeLogicalHeight(logicalHeight, logicalTop);
161 }
162 
163 void RenderSliderContainer::layout()
164 {
165     ASSERT(element()-&gt;shadowHost());
166     auto&amp; input = downcast&lt;HTMLInputElement&gt;(*element()-&gt;shadowHost());
167     bool isVertical = hasVerticalAppearance(input);
168     mutableStyle().setFlexDirection(isVertical ? FlexDirection::Column : FlexDirection::Row);
169     TextDirection oldTextDirection = style().direction();
170     if (isVertical) {
171         // FIXME: Work around rounding issues in RTL vertical sliders. We want them to
172         // render identically to LTR vertical sliders. We can remove this work around when
173         // subpixel rendering is enabled on all ports.
174         mutableStyle().setDirection(TextDirection::LTR);
175     }
176 
177     RenderBox* thumb = input.sliderThumbElement() ? input.sliderThumbElement()-&gt;renderBox() : nullptr;
178     RenderBox* track = input.sliderTrackElement() ? input.sliderTrackElement()-&gt;renderBox() : nullptr;
179     // Force a layout to reset the position of the thumb so the code below doesn&#39;t move the thumb to the wrong place.
180     // FIXME: Make a custom Render class for the track and move the thumb positioning code there.
181     if (track)
182         track-&gt;setChildNeedsLayout(MarkOnlyThis);
183 
184     RenderFlexibleBox::layout();
185 
186     mutableStyle().setDirection(oldTextDirection);
187     // These should always exist, unless someone mutates the shadow DOM (e.g., in the inspector).
188     if (!thumb || !track)
189         return;
190 
191     double percentageOffset = sliderPosition(input).toDouble();
192     LayoutUnit availableExtent = isVertical ? track-&gt;contentHeight() : track-&gt;contentWidth();
193     availableExtent -= isVertical ? thumb-&gt;height() : thumb-&gt;width();
194     LayoutUnit offset { percentageOffset * availableExtent };
195     LayoutPoint thumbLocation = thumb-&gt;location();
196     if (isVertical)
197         thumbLocation.setY(thumbLocation.y() + track-&gt;contentHeight() - thumb-&gt;height() - offset);
198     else if (style().isLeftToRightDirection())
199         thumbLocation.setX(thumbLocation.x() + offset);
200     else
201         thumbLocation.setX(thumbLocation.x() - offset);
202     thumb-&gt;setLocation(thumbLocation);
203     thumb-&gt;repaint();
204 }
205 
206 // --------------------------------
207 
208 SliderThumbElement::SliderThumbElement(Document&amp; document)
209     : HTMLDivElement(HTMLNames::divTag, document)
210 {
211     setHasCustomStyleResolveCallbacks();
212 }
213 
214 void SliderThumbElement::setPositionFromValue()
215 {
216     // Since the code to calculate position is in the RenderSliderThumb layout
217     // path, we don&#39;t actually update the value here. Instead, we poke at the
218     // renderer directly to trigger layout.
219     if (renderer())
220         renderer()-&gt;setNeedsLayout();
221 }
222 
223 RenderPtr&lt;RenderElement&gt; SliderThumbElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
224 {
225     return createRenderer&lt;RenderSliderThumb&gt;(*this, WTFMove(style));
226 }
227 
228 bool SliderThumbElement::isDisabledFormControl() const
229 {
230     auto input = hostInput();
231     return !input || input-&gt;isDisabledFormControl();
232 }
233 
234 bool SliderThumbElement::matchesReadWritePseudoClass() const
235 {
236     auto input = hostInput();
237     return input &amp;&amp; input-&gt;matchesReadWritePseudoClass();
238 }
239 
240 RefPtr&lt;Element&gt; SliderThumbElement::focusDelegate()
241 {
242     return hostInput();
243 }
244 
245 void SliderThumbElement::dragFrom(const LayoutPoint&amp; point)
246 {
247     Ref&lt;SliderThumbElement&gt; protectedThis(*this);
248     setPositionFromPoint(point);
<a name="1" id="anc1"></a>
249     startDragging();
<a name="2" id="anc2"></a>
250 }
251 
252 void SliderThumbElement::setPositionFromPoint(const LayoutPoint&amp; absolutePoint)
253 {
254     auto input = hostInput();
255     if (!input)
256         return;
257 
258     auto* inputRenderer = input-&gt;renderBox();
259     if (!inputRenderer)
260         return;
261 
262     auto* thumbRenderer = renderBox();
263     if (!thumbRenderer)
264         return;
265 
266     ASSERT(input-&gt;sliderTrackElement());
267     auto* trackRenderer = input-&gt;sliderTrackElement()-&gt;renderBox();
268     if (!trackRenderer)
269         return;
270 
271     // Do all the tracking math relative to the input&#39;s renderer&#39;s box.
272 
273     bool isVertical = hasVerticalAppearance(*input);
274     bool isLeftToRightDirection = thumbRenderer-&gt;style().isLeftToRightDirection();
275 
276     auto offset = inputRenderer-&gt;absoluteToLocal(absolutePoint, UseTransforms);
277     auto trackBoundingBox = trackRenderer-&gt;localToContainerQuad(FloatRect { { }, trackRenderer-&gt;size() }, inputRenderer).enclosingBoundingBox();
278 
279     LayoutUnit trackLength;
280     LayoutUnit position;
281     if (isVertical) {
282         trackLength = trackRenderer-&gt;contentHeight() - thumbRenderer-&gt;height();
283         position = offset.y() - thumbRenderer-&gt;height() / 2 - trackBoundingBox.y() - thumbRenderer-&gt;marginBottom();
284     } else {
285         trackLength = trackRenderer-&gt;contentWidth() - thumbRenderer-&gt;width();
286         position = offset.x() - thumbRenderer-&gt;width() / 2 - trackBoundingBox.x();
287         position -= isLeftToRightDirection ? thumbRenderer-&gt;marginLeft() : thumbRenderer-&gt;marginRight();
288     }
289 
290     position = std::max&lt;LayoutUnit&gt;(0, std::min(position, trackLength));
291     auto ratio = Decimal::fromDouble(static_cast&lt;double&gt;(position) / trackLength);
292     auto fraction = isVertical || !isLeftToRightDirection ? Decimal(1) - ratio : ratio;
293     auto stepRange = input-&gt;createStepRange(RejectAny);
294     auto value = stepRange.clampValue(stepRange.valueFromProportion(fraction));
295 
296 #if ENABLE(DATALIST_ELEMENT)
297     const LayoutUnit snappingThreshold = renderer()-&gt;theme().sliderTickSnappingThreshold();
298     if (snappingThreshold &gt; 0) {
299         if (Optional&lt;Decimal&gt; closest = input-&gt;findClosestTickMarkValue(value)) {
300             double closestFraction = stepRange.proportionFromValue(*closest).toDouble();
301             double closestRatio = isVertical || !isLeftToRightDirection ? 1.0 - closestFraction : closestFraction;
302             LayoutUnit closestPosition { trackLength * closestRatio };
303             if ((closestPosition - position).abs() &lt;= snappingThreshold)
304                 value = *closest;
305         }
306     }
307 #endif
308 
309     String valueString = serializeForNumberType(value);
310     if (valueString == input-&gt;value())
311         return;
312 
313     // FIXME: This is no longer being set from renderer. Consider updating the method name.
314     input-&gt;setValueFromRenderer(valueString);
315     if (renderer())
316         renderer()-&gt;setNeedsLayout();
317 }
318 
319 void SliderThumbElement::startDragging()
320 {
321     if (RefPtr&lt;Frame&gt; frame = document().frame()) {
322         frame-&gt;eventHandler().setCapturingMouseEventsElement(this);
323         m_inDragMode = true;
324     }
325 }
326 
327 void SliderThumbElement::stopDragging()
328 {
329     if (!m_inDragMode)
330         return;
331 
332     if (RefPtr&lt;Frame&gt; frame = document().frame())
333         frame-&gt;eventHandler().setCapturingMouseEventsElement(nullptr);
334     m_inDragMode = false;
335     if (renderer())
336         renderer()-&gt;setNeedsLayout();
337 }
338 
<a name="3" id="anc3"></a>
339 void SliderThumbElement::defaultEventHandler(Event&amp; event)
340 {
341     if (!is&lt;MouseEvent&gt;(event)) {
342         HTMLDivElement::defaultEventHandler(event);
343         return;
344     }
345 
346     // FIXME: Should handle this readonly/disabled check in more general way.
347     // Missing this kind of check is likely to occur elsewhere if adding it in each shadow element.
348     auto input = hostInput();
349     if (!input || input-&gt;isDisabledFormControl()) {
350         HTMLDivElement::defaultEventHandler(event);
351         return;
352     }
353 
354     MouseEvent&amp; mouseEvent = downcast&lt;MouseEvent&gt;(event);
355     bool isLeftButton = mouseEvent.button() == LeftButton;
356     const AtomString&amp; eventType = mouseEvent.type();
357 
358     // We intentionally do not call event-&gt;setDefaultHandled() here because
359     // MediaControlTimelineElement::defaultEventHandler() wants to handle these
360     // mouse events.
361     if (eventType == eventNames().mousedownEvent &amp;&amp; isLeftButton) {
362         startDragging();
363         return;
364     } else if (eventType == eventNames().mouseupEvent &amp;&amp; isLeftButton) {
365         input-&gt;dispatchFormControlChangeEvent();
366         stopDragging();
367         return;
368     } else if (eventType == eventNames().mousemoveEvent) {
369         if (m_inDragMode)
370             setPositionFromPoint(mouseEvent.absoluteLocation());
371         return;
372     }
373 
374     HTMLDivElement::defaultEventHandler(mouseEvent);
375 }
<a name="4" id="anc4"></a>


376 
377 bool SliderThumbElement::willRespondToMouseMoveEvents()
378 {
379     const auto input = hostInput();
380     if (input &amp;&amp; !input-&gt;isDisabledFormControl() &amp;&amp; m_inDragMode)
381         return true;
382 
383     return HTMLDivElement::willRespondToMouseMoveEvents();
384 }
385 
386 bool SliderThumbElement::willRespondToMouseClickEvents()
387 {
388     const auto input = hostInput();
389     if (input &amp;&amp; !input-&gt;isDisabledFormControl())
390         return true;
391 
392     return HTMLDivElement::willRespondToMouseClickEvents();
393 }
394 
<a name="5" id="anc5"></a>
395 
396 void SliderThumbElement::willDetachRenderers()
397 {
398     if (m_inDragMode) {
399         if (RefPtr&lt;Frame&gt; frame = document().frame())
400             frame-&gt;eventHandler().setCapturingMouseEventsElement(nullptr);
401     }
402 #if ENABLE(IOS_TOUCH_EVENTS)
403     unregisterForTouchEvents();
404 #endif
405 }
406 
407 #if ENABLE(IOS_TOUCH_EVENTS)
408 
409 unsigned SliderThumbElement::exclusiveTouchIdentifier() const
410 {
411     return m_exclusiveTouchIdentifier;
412 }
413 
414 void SliderThumbElement::setExclusiveTouchIdentifier(unsigned identifier)
415 {
416     ASSERT(m_exclusiveTouchIdentifier == NoIdentifier);
417     m_exclusiveTouchIdentifier = identifier;
418 }
419 
420 void SliderThumbElement::clearExclusiveTouchIdentifier()
421 {
422     m_exclusiveTouchIdentifier = NoIdentifier;
423 }
424 
425 static Touch* findTouchWithIdentifier(TouchList&amp; list, unsigned identifier)
426 {
427     unsigned length = list.length();
428     for (unsigned i = 0; i &lt; length; ++i) {
429         RefPtr&lt;Touch&gt; touch = list.item(i);
430         if (touch-&gt;identifier() == identifier)
431             return touch.get();
432     }
433     return nullptr;
434 }
435 
436 void SliderThumbElement::handleTouchStart(TouchEvent&amp; touchEvent)
437 {
438     RefPtr&lt;TouchList&gt; targetTouches = touchEvent.targetTouches();
439     if (!targetTouches)
440         return;
441 
442     if (targetTouches-&gt;length() != 1)
443         return;
444 
445     RefPtr&lt;Touch&gt; touch = targetTouches-&gt;item(0);
446     if (!renderer())
447         return;
448     IntRect boundingBox = renderer()-&gt;absoluteBoundingBoxRect();
449     // Ignore the touch if it is not really inside the thumb.
450     if (!boundingBox.contains(touch-&gt;pageX(), touch-&gt;pageY()))
451         return;
452 
453     setExclusiveTouchIdentifier(touch-&gt;identifier());
454 
455     startDragging();
456     touchEvent.setDefaultHandled();
457 }
458 
459 void SliderThumbElement::handleTouchMove(TouchEvent&amp; touchEvent)
460 {
461     unsigned identifier = exclusiveTouchIdentifier();
462     if (identifier == NoIdentifier)
463         return;
464 
465     RefPtr&lt;TouchList&gt; targetTouches = touchEvent.targetTouches();
466     if (!targetTouches)
467         return;
468 
469     RefPtr&lt;Touch&gt; touch = findTouchWithIdentifier(*targetTouches, identifier);
470     if (!touch)
471         return;
472 
473     if (m_inDragMode)
474         setPositionFromPoint(IntPoint(touch-&gt;pageX(), touch-&gt;pageY()));
475     touchEvent.setDefaultHandled();
476 }
477 
478 void SliderThumbElement::handleTouchEndAndCancel(TouchEvent&amp; touchEvent)
479 {
480     unsigned identifier = exclusiveTouchIdentifier();
481     if (identifier == NoIdentifier)
482         return;
483 
484     RefPtr&lt;TouchList&gt; targetTouches = touchEvent.targetTouches();
485     if (!targetTouches)
486         return;
487     // If our exclusive touch still exists, it was not the touch
488     // that ended, so we should not stop dragging.
489     RefPtr&lt;Touch&gt; exclusiveTouch = findTouchWithIdentifier(*targetTouches, identifier);
490     if (exclusiveTouch)
491         return;
492 
493     clearExclusiveTouchIdentifier();
494 
495     auto input = hostInput();
496     if (input)
497         input-&gt;dispatchFormControlChangeEvent();
498     stopDragging();
499 }
500 
501 void SliderThumbElement::didAttachRenderers()
502 {
503     if (shouldAcceptTouchEvents())
504         registerForTouchEvents();
505 }
506 
507 void SliderThumbElement::handleTouchEvent(TouchEvent&amp; touchEvent)
508 {
509     auto input = hostInput();
510     ASSERT(input);
511     if (input-&gt;isReadOnly() || input-&gt;isDisabledFormControl()) {
512         clearExclusiveTouchIdentifier();
513         stopDragging();
514         touchEvent.setDefaultHandled();
515         HTMLDivElement::defaultEventHandler(touchEvent);
516         return;
517     }
518 
519     const AtomString&amp; eventType = touchEvent.type();
520     if (eventType == eventNames().touchstartEvent) {
521         handleTouchStart(touchEvent);
522         return;
523     }
524     if (eventType == eventNames().touchendEvent || eventType == eventNames().touchcancelEvent) {
525         handleTouchEndAndCancel(touchEvent);
526         return;
527     }
528     if (eventType == eventNames().touchmoveEvent) {
529         handleTouchMove(touchEvent);
530         return;
531     }
532 
533     HTMLDivElement::defaultEventHandler(touchEvent);
534 }
535 
536 bool SliderThumbElement::shouldAcceptTouchEvents()
537 {
538     return renderer() &amp;&amp; !isDisabledFormControl();
539 }
540 
541 void SliderThumbElement::registerForTouchEvents()
542 {
543     if (m_isRegisteredAsTouchEventListener)
544         return;
545 
546     ASSERT(shouldAcceptTouchEvents());
547 
548     document().addTouchEventHandler(*this);
549     m_isRegisteredAsTouchEventListener = true;
550 }
551 
552 void SliderThumbElement::unregisterForTouchEvents()
553 {
554     if (!m_isRegisteredAsTouchEventListener)
555         return;
556 
557     clearExclusiveTouchIdentifier();
558     stopDragging();
559 
560     document().removeTouchEventHandler(*this);
561     m_isRegisteredAsTouchEventListener = false;
562 }
563 
564 #endif // ENABLE(IOS_TOUCH_EVENTS)
565 
566 void SliderThumbElement::hostDisabledStateChanged()
567 {
568     if (isDisabledFormControl())
569         stopDragging();
570 
571 #if ENABLE(IOS_TOUCH_EVENTS)
572     if (shouldAcceptTouchEvents())
573         registerForTouchEvents();
574     else
575         unregisterForTouchEvents();
576 #endif
577 }
578 
579 RefPtr&lt;HTMLInputElement&gt; SliderThumbElement::hostInput() const
580 {
581     // Only HTMLInputElement creates SliderThumbElement instances as its shadow nodes.
582     // So, shadowHost() must be an HTMLInputElement.
583     return downcast&lt;HTMLInputElement&gt;(shadowHost());
584 }
585 
<a name="6" id="anc6"></a><span class="line-modified">586 Optional&lt;Style::ElementStyle&gt; SliderThumbElement::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle* hostStyle)</span>
587 {
588     // This doesn&#39;t actually compute style. This is just a hack to pick shadow pseudo id when host style is known.
589 
590     static NeverDestroyed&lt;const AtomString&gt; sliderThumbShadowPseudoId(&quot;-webkit-slider-thumb&quot;, AtomString::ConstructFromLiteral);
591     static NeverDestroyed&lt;const AtomString&gt; mediaSliderThumbShadowPseudoId(&quot;-webkit-media-slider-thumb&quot;, AtomString::ConstructFromLiteral);
592 
593     if (!hostStyle)
594         return WTF::nullopt;
595 
596     switch (hostStyle-&gt;appearance()) {
597     case MediaSliderPart:
598     case MediaSliderThumbPart:
599     case MediaVolumeSliderPart:
600     case MediaVolumeSliderThumbPart:
601     case MediaFullScreenVolumeSliderPart:
602     case MediaFullScreenVolumeSliderThumbPart:
603         m_shadowPseudoId = mediaSliderThumbShadowPseudoId;
604         break;
605     default:
606         m_shadowPseudoId = sliderThumbShadowPseudoId;
607     }
608 
609     return WTF::nullopt;
610 }
611 
612 const AtomString&amp; SliderThumbElement::shadowPseudoId() const
613 {
614     return m_shadowPseudoId;
615 }
616 
617 Ref&lt;Element&gt; SliderThumbElement::cloneElementWithoutAttributesAndChildren(Document&amp; targetDocument)
618 {
619     return create(targetDocument);
620 }
621 
622 // --------------------------------
623 
624 inline SliderContainerElement::SliderContainerElement(Document&amp; document)
625     : HTMLDivElement(HTMLNames::divTag, document)
626 {
627     setHasCustomStyleResolveCallbacks();
628 }
629 
630 Ref&lt;SliderContainerElement&gt; SliderContainerElement::create(Document&amp; document)
631 {
632     return adoptRef(*new SliderContainerElement(document));
633 }
634 
635 RenderPtr&lt;RenderElement&gt; SliderContainerElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
636 {
637     return createRenderer&lt;RenderSliderContainer&gt;(*this, WTFMove(style));
638 }
639 
<a name="7" id="anc7"></a><span class="line-modified">640 Optional&lt;Style::ElementStyle&gt; SliderContainerElement::resolveCustomStyle(const RenderStyle&amp;, const RenderStyle* hostStyle)</span>
641 {
642     // This doesn&#39;t actually compute style. This is just a hack to pick shadow pseudo id when host style is known.
643 
644     static NeverDestroyed&lt;const AtomString&gt; mediaSliderContainer(&quot;-webkit-media-slider-container&quot;, AtomString::ConstructFromLiteral);
645     static NeverDestroyed&lt;const AtomString&gt; sliderContainer(&quot;-webkit-slider-container&quot;, AtomString::ConstructFromLiteral);
646 
647     if (!hostStyle)
648         return WTF::nullopt;
649 
650     switch (hostStyle-&gt;appearance()) {
651     case MediaSliderPart:
652     case MediaSliderThumbPart:
653     case MediaVolumeSliderPart:
654     case MediaVolumeSliderThumbPart:
655     case MediaFullScreenVolumeSliderPart:
656     case MediaFullScreenVolumeSliderThumbPart:
657         m_shadowPseudoId = mediaSliderContainer;
658         break;
659     default:
660         m_shadowPseudoId = sliderContainer;
661     }
662 
663     return WTF::nullopt;
664 }
665 
666 const AtomString&amp; SliderContainerElement::shadowPseudoId() const
667 {
668     return m_shadowPseudoId;
669 }
670 
671 }
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
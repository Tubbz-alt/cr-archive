<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Gigacage.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Gigacage.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Heap.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/Gigacage.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28 #include &quot;Algorithm.h&quot;
 29 #include &quot;BAssert.h&quot;
 30 #include &quot;BExport.h&quot;
 31 #include &quot;BInline.h&quot;
 32 #include &quot;BPlatform.h&quot;
 33 #include &quot;Sizes.h&quot;
 34 #include &lt;cstddef&gt;
 35 #include &lt;inttypes.h&gt;
 36 
 37 #if ((BOS(DARWIN) || BOS(LINUX)) &amp;&amp; \
 38     (BCPU(X86_64) || (BCPU(ARM64) &amp;&amp; !defined(__ILP32__) &amp;&amp; (!BPLATFORM(IOS_FAMILY) || BPLATFORM(IOS)))))
 39 #define GIGACAGE_ENABLED 1
 40 #else
 41 #define GIGACAGE_ENABLED 0
 42 #endif
 43 
 44 
 45 namespace Gigacage {
 46 
 47 enum Kind {
<span class="line-removed"> 48     ReservedForFlagsAndNotABasePtr = 0,</span>
 49     Primitive,
 50     JSValue,

 51 };
 52 
 53 BINLINE const char* name(Kind kind)
 54 {
 55     switch (kind) {
<span class="line-removed"> 56     case ReservedForFlagsAndNotABasePtr:</span>
<span class="line-removed"> 57         RELEASE_BASSERT_NOT_REACHED();</span>
 58     case Primitive:
 59         return &quot;Primitive&quot;;
 60     case JSValue:
 61         return &quot;JSValue&quot;;


 62     }
 63     BCRASH();
 64     return nullptr;
 65 }
 66 
 67 #if GIGACAGE_ENABLED
 68 
<span class="line-modified"> 69 #if BCPU(ARM64)</span>


 70 constexpr size_t primitiveGigacageSize = 2 * bmalloc::Sizes::GB;
 71 constexpr size_t jsValueGigacageSize = 2 * bmalloc::Sizes::GB;
<span class="line-removed"> 72 constexpr size_t gigacageBasePtrsSize = 16 * bmalloc::Sizes::kB;</span>
 73 constexpr size_t maximumCageSizeReductionForSlide = bmalloc::Sizes::GB / 4;
<span class="line-removed"> 74 #define GIGACAGE_ALLOCATION_CAN_FAIL 1</span>
 75 #else
 76 constexpr size_t primitiveGigacageSize = 32 * bmalloc::Sizes::GB;
 77 constexpr size_t jsValueGigacageSize = 16 * bmalloc::Sizes::GB;
<span class="line-removed"> 78 constexpr size_t gigacageBasePtrsSize = 4 * bmalloc::Sizes::kB;</span>
 79 constexpr size_t maximumCageSizeReductionForSlide = 4 * bmalloc::Sizes::GB;
<span class="line-removed"> 80 #define GIGACAGE_ALLOCATION_CAN_FAIL 0</span>
 81 #endif
 82 
 83 // In Linux, if `vm.overcommit_memory = 2` is specified, mmap with large size can fail if it exceeds the size of RAM.
 84 // So we specify GIGACAGE_ALLOCATION_CAN_FAIL = 1.
 85 #if BOS(LINUX)
<span class="line-removed"> 86 #undef GIGACAGE_ALLOCATION_CAN_FAIL</span>
 87 #define GIGACAGE_ALLOCATION_CAN_FAIL 1


 88 #endif
 89 
 90 
 91 static_assert(bmalloc::isPowerOfTwo(primitiveGigacageSize), &quot;&quot;);
 92 static_assert(bmalloc::isPowerOfTwo(jsValueGigacageSize), &quot;&quot;);
 93 static_assert(primitiveGigacageSize &gt; maximumCageSizeReductionForSlide, &quot;&quot;);
 94 static_assert(jsValueGigacageSize &gt; maximumCageSizeReductionForSlide, &quot;&quot;);
 95 
 96 constexpr size_t gigacageSizeToMask(size_t size) { return size - 1; }
 97 
 98 constexpr size_t primitiveGigacageMask = gigacageSizeToMask(primitiveGigacageSize);
 99 constexpr size_t jsValueGigacageMask = gigacageSizeToMask(jsValueGigacageSize);
100 
<span class="line-modified">101 extern &quot;C&quot; alignas(gigacageBasePtrsSize) BEXPORT char g_gigacageBasePtrs[gigacageBasePtrsSize];</span>





102 
<span class="line-modified">103 BINLINE bool wasEnabled() { return g_gigacageBasePtrs[0]; }</span>
<span class="line-modified">104 BINLINE void setWasEnabled() { g_gigacageBasePtrs[0] = true; }</span>



105 
<span class="line-modified">106 struct BasePtrs {</span>
<span class="line-modified">107     uintptr_t reservedForFlags;</span>
<span class="line-modified">108     void* primitive;</span>
<span class="line-modified">109     void* jsValue;</span>



















110 };



111 
<span class="line-modified">112 static_assert(offsetof(BasePtrs, primitive) == Kind::Primitive * sizeof(void*), &quot;&quot;);</span>
<span class="line-modified">113 static_assert(offsetof(BasePtrs, jsValue) == Kind::JSValue * sizeof(void*), &quot;&quot;);</span>

114 
<span class="line-modified">115 constexpr unsigned numKinds = 2;</span>

116 
117 BEXPORT void ensureGigacage();
118 
119 BEXPORT void disablePrimitiveGigacage();
120 
121 // This will call the disable callback immediately if the Primitive Gigacage is currently disabled.
122 BEXPORT void addPrimitiveDisableCallback(void (*)(void*), void*);
123 BEXPORT void removePrimitiveDisableCallback(void (*)(void*), void*);
124 
<span class="line-modified">125 BEXPORT void disableDisablingPrimitiveGigacageIfShouldBeEnabled();</span>
<span class="line-removed">126 </span>
<span class="line-removed">127 BEXPORT bool isDisablingPrimitiveGigacageDisabled();</span>
<span class="line-removed">128 inline bool isPrimitiveGigacagePermanentlyEnabled() { return isDisablingPrimitiveGigacageDisabled(); }</span>
<span class="line-removed">129 inline bool canPrimitiveGigacageBeDisabled() { return !isDisablingPrimitiveGigacageDisabled(); }</span>
130 
<span class="line-modified">131 BINLINE void*&amp; basePtr(BasePtrs&amp; basePtrs, Kind kind)</span>
<span class="line-modified">132 {</span>
<span class="line-modified">133     switch (kind) {</span>
<span class="line-removed">134     case ReservedForFlagsAndNotABasePtr:</span>
<span class="line-removed">135         RELEASE_BASSERT_NOT_REACHED();</span>
<span class="line-removed">136     case Primitive:</span>
<span class="line-removed">137         return basePtrs.primitive;</span>
<span class="line-removed">138     case JSValue:</span>
<span class="line-removed">139         return basePtrs.jsValue;</span>
<span class="line-removed">140     }</span>
<span class="line-removed">141     BCRASH();</span>
<span class="line-removed">142     return basePtrs.primitive;</span>
<span class="line-removed">143 }</span>
144 
<span class="line-modified">145 BINLINE BasePtrs&amp; basePtrs()</span>
146 {
<span class="line-modified">147     return *reinterpret_cast&lt;BasePtrs*&gt;(reinterpret_cast&lt;void*&gt;(g_gigacageBasePtrs));</span>
148 }
149 
<span class="line-modified">150 BINLINE void*&amp; basePtr(Kind kind)</span>
151 {
<span class="line-modified">152     return basePtr(basePtrs(), kind);</span>

153 }
154 
155 BINLINE bool isEnabled(Kind kind)
156 {
<span class="line-modified">157     return !!basePtr(kind);</span>
158 }
159 
160 BINLINE size_t size(Kind kind)
161 {
162     switch (kind) {
<span class="line-removed">163     case ReservedForFlagsAndNotABasePtr:</span>
<span class="line-removed">164         RELEASE_BASSERT_NOT_REACHED();</span>
165     case Primitive:
166         return static_cast&lt;size_t&gt;(primitiveGigacageSize);
167     case JSValue:
168         return static_cast&lt;size_t&gt;(jsValueGigacageSize);


169     }
170     BCRASH();
171     return 0;
172 }
173 
174 BINLINE size_t alignment(Kind kind)
175 {
176     return size(kind);
177 }
178 
179 BINLINE size_t mask(Kind kind)
180 {
181     return gigacageSizeToMask(size(kind));
182 }
183 
184 template&lt;typename Func&gt;
185 void forEachKind(const Func&amp; func)
186 {
187     func(Primitive);
188     func(JSValue);
189 }
190 
191 template&lt;typename T&gt;
192 BINLINE T* caged(Kind kind, T* ptr)
193 {
194     BASSERT(ptr);
<span class="line-modified">195     void* gigacageBasePtr = basePtr(kind);</span>
196     if (!gigacageBasePtr)
197         return ptr;
198     return reinterpret_cast&lt;T*&gt;(
199         reinterpret_cast&lt;uintptr_t&gt;(gigacageBasePtr) + (
200             reinterpret_cast&lt;uintptr_t&gt;(ptr) &amp; mask(kind)));
201 }
202 
203 template&lt;typename T&gt;
204 BINLINE T* cagedMayBeNull(Kind kind, T* ptr)
205 {
206     if (!ptr)
207         return ptr;
208     return caged(kind, ptr);
209 }
210 
211 BINLINE bool isCaged(Kind kind, const void* ptr)
212 {
213     return caged(kind, ptr) == ptr;
214 }
215 







216 BEXPORT bool shouldBeEnabled();
217 
218 #else // GIGACAGE_ENABLED
219 
<span class="line-modified">220 BINLINE void*&amp; basePtr(Kind)</span>
221 {
222     BCRASH();
223     static void* unreachable;
224     return unreachable;
225 }
226 BINLINE size_t size(Kind) { BCRASH(); return 0; }
227 BINLINE void ensureGigacage() { }
<span class="line-modified">228 BINLINE bool wasEnabled() { return false; }</span>

229 BINLINE bool isCaged(Kind, const void*) { return true; }
230 BINLINE bool isEnabled(Kind) { return false; }
231 template&lt;typename T&gt; BINLINE T* caged(Kind, T* ptr) { return ptr; }
232 template&lt;typename T&gt; BINLINE T* cagedMayBeNull(Kind, T* ptr) { return ptr; }
<span class="line-modified">233 BINLINE void disableDisablingPrimitiveGigacageIfShouldBeEnabled() { }</span>
234 BINLINE bool canPrimitiveGigacageBeDisabled() { return false; }
235 BINLINE void disablePrimitiveGigacage() { }
236 BINLINE void addPrimitiveDisableCallback(void (*)(void*), void*) { }
237 BINLINE void removePrimitiveDisableCallback(void (*)(void*), void*) { }
238 
239 #endif // GIGACAGE_ENABLED
240 
241 } // namespace Gigacage
242 
243 
244 
</pre>
</td>
<td>
<hr />
<pre>
 28 #include &quot;Algorithm.h&quot;
 29 #include &quot;BAssert.h&quot;
 30 #include &quot;BExport.h&quot;
 31 #include &quot;BInline.h&quot;
 32 #include &quot;BPlatform.h&quot;
 33 #include &quot;Sizes.h&quot;
 34 #include &lt;cstddef&gt;
 35 #include &lt;inttypes.h&gt;
 36 
 37 #if ((BOS(DARWIN) || BOS(LINUX)) &amp;&amp; \
 38     (BCPU(X86_64) || (BCPU(ARM64) &amp;&amp; !defined(__ILP32__) &amp;&amp; (!BPLATFORM(IOS_FAMILY) || BPLATFORM(IOS)))))
 39 #define GIGACAGE_ENABLED 1
 40 #else
 41 #define GIGACAGE_ENABLED 0
 42 #endif
 43 
 44 
 45 namespace Gigacage {
 46 
 47 enum Kind {

 48     Primitive,
 49     JSValue,
<span class="line-added"> 50     NumberOfKinds</span>
 51 };
 52 
 53 BINLINE const char* name(Kind kind)
 54 {
 55     switch (kind) {


 56     case Primitive:
 57         return &quot;Primitive&quot;;
 58     case JSValue:
 59         return &quot;JSValue&quot;;
<span class="line-added"> 60     case NumberOfKinds:</span>
<span class="line-added"> 61         break;</span>
 62     }
 63     BCRASH();
 64     return nullptr;
 65 }
 66 
 67 #if GIGACAGE_ENABLED
 68 
<span class="line-modified"> 69 constexpr size_t configSizeToProtect = 16 * bmalloc::Sizes::kB;</span>
<span class="line-added"> 70 </span>
<span class="line-added"> 71 #if BOS_EFFECTIVE_ADDRESS_WIDTH &lt; 48</span>
 72 constexpr size_t primitiveGigacageSize = 2 * bmalloc::Sizes::GB;
 73 constexpr size_t jsValueGigacageSize = 2 * bmalloc::Sizes::GB;

 74 constexpr size_t maximumCageSizeReductionForSlide = bmalloc::Sizes::GB / 4;

 75 #else
 76 constexpr size_t primitiveGigacageSize = 32 * bmalloc::Sizes::GB;
 77 constexpr size_t jsValueGigacageSize = 16 * bmalloc::Sizes::GB;

 78 constexpr size_t maximumCageSizeReductionForSlide = 4 * bmalloc::Sizes::GB;

 79 #endif
 80 
 81 // In Linux, if `vm.overcommit_memory = 2` is specified, mmap with large size can fail if it exceeds the size of RAM.
 82 // So we specify GIGACAGE_ALLOCATION_CAN_FAIL = 1.
 83 #if BOS(LINUX)

 84 #define GIGACAGE_ALLOCATION_CAN_FAIL 1
<span class="line-added"> 85 #else</span>
<span class="line-added"> 86 #define GIGACAGE_ALLOCATION_CAN_FAIL 0</span>
 87 #endif
 88 
 89 
 90 static_assert(bmalloc::isPowerOfTwo(primitiveGigacageSize), &quot;&quot;);
 91 static_assert(bmalloc::isPowerOfTwo(jsValueGigacageSize), &quot;&quot;);
 92 static_assert(primitiveGigacageSize &gt; maximumCageSizeReductionForSlide, &quot;&quot;);
 93 static_assert(jsValueGigacageSize &gt; maximumCageSizeReductionForSlide, &quot;&quot;);
 94 
 95 constexpr size_t gigacageSizeToMask(size_t size) { return size - 1; }
 96 
 97 constexpr size_t primitiveGigacageMask = gigacageSizeToMask(primitiveGigacageSize);
 98 constexpr size_t jsValueGigacageMask = gigacageSizeToMask(jsValueGigacageSize);
 99 
<span class="line-modified">100 struct Config {</span>
<span class="line-added">101     void* basePtr(Kind kind) const</span>
<span class="line-added">102     {</span>
<span class="line-added">103         RELEASE_BASSERT(kind &lt; NumberOfKinds);</span>
<span class="line-added">104         return basePtrs[kind];</span>
<span class="line-added">105     }</span>
106 
<span class="line-modified">107     void setBasePtr(Kind kind, void* ptr)</span>
<span class="line-modified">108     {</span>
<span class="line-added">109         RELEASE_BASSERT(kind &lt; NumberOfKinds);</span>
<span class="line-added">110         basePtrs[kind] = ptr;</span>
<span class="line-added">111     }</span>
112 
<span class="line-modified">113     union {</span>
<span class="line-modified">114         struct {</span>
<span class="line-modified">115             // All the fields in this struct should be chosen such that their</span>
<span class="line-modified">116             // initial value is 0 / null / falsy because Config is instantiated</span>
<span class="line-added">117             // as a global singleton.</span>
<span class="line-added">118 </span>
<span class="line-added">119             bool isEnabled;</span>
<span class="line-added">120             bool isPermanentlyFrozen;</span>
<span class="line-added">121             bool disablingPrimitiveGigacageIsForbidden;</span>
<span class="line-added">122             bool shouldBeEnabled;</span>
<span class="line-added">123 </span>
<span class="line-added">124             // We would like to just put the std::once_flag for these functions</span>
<span class="line-added">125             // here, but we can&#39;t because std::once_flag has a implicitly-deleted</span>
<span class="line-added">126             // default constructor. So, we use a boolean instead.</span>
<span class="line-added">127             bool shouldBeEnabledHasBeenCalled;</span>
<span class="line-added">128             bool ensureGigacageHasBeenCalled;</span>
<span class="line-added">129 </span>
<span class="line-added">130             void* start;</span>
<span class="line-added">131             size_t totalSize;</span>
<span class="line-added">132             void* basePtrs[NumberOfKinds];</span>
<span class="line-added">133         };</span>
<span class="line-added">134         char ensureSize[configSizeToProtect];</span>
<span class="line-added">135     };</span>
136 };
<span class="line-added">137 static_assert(sizeof(Config) == configSizeToProtect, &quot;Gigacage Config must fit in configSizeToProtect&quot;);</span>
<span class="line-added">138 </span>
<span class="line-added">139 extern &quot;C&quot; alignas(configSizeToProtect) BEXPORT Config g_gigacageConfig;</span>
140 
<span class="line-modified">141 // These constants are needed by the LLInt.</span>
<span class="line-modified">142 constexpr ptrdiff_t offsetOfPrimitiveGigacageBasePtr = Kind::Primitive * sizeof(void*);</span>
<span class="line-added">143 constexpr ptrdiff_t offsetOfJSValueGigacageBasePtr = Kind::JSValue * sizeof(void*);</span>
144 
<span class="line-modified">145 </span>
<span class="line-added">146 BINLINE bool isEnabled() { return g_gigacageConfig.isEnabled; }</span>
147 
148 BEXPORT void ensureGigacage();
149 
150 BEXPORT void disablePrimitiveGigacage();
151 
152 // This will call the disable callback immediately if the Primitive Gigacage is currently disabled.
153 BEXPORT void addPrimitiveDisableCallback(void (*)(void*), void*);
154 BEXPORT void removePrimitiveDisableCallback(void (*)(void*), void*);
155 
<span class="line-modified">156 BEXPORT void forbidDisablingPrimitiveGigacage();</span>




157 
<span class="line-modified">158 BEXPORT bool isDisablingPrimitiveGigacageForbidden();</span>
<span class="line-modified">159 inline bool isPrimitiveGigacagePermanentlyEnabled() { return isDisablingPrimitiveGigacageForbidden(); }</span>
<span class="line-modified">160 inline bool canPrimitiveGigacageBeDisabled() { return !isDisablingPrimitiveGigacageForbidden(); }</span>










161 
<span class="line-modified">162 BINLINE void* basePtr(Kind kind)</span>
163 {
<span class="line-modified">164     return g_gigacageConfig.basePtr(kind);</span>
165 }
166 
<span class="line-modified">167 BINLINE void* addressOfBasePtr(Kind kind)</span>
168 {
<span class="line-modified">169     RELEASE_BASSERT(kind &lt; NumberOfKinds);</span>
<span class="line-added">170     return &amp;g_gigacageConfig.basePtrs[kind];</span>
171 }
172 
173 BINLINE bool isEnabled(Kind kind)
174 {
<span class="line-modified">175     return !!g_gigacageConfig.basePtr(kind);</span>
176 }
177 
178 BINLINE size_t size(Kind kind)
179 {
180     switch (kind) {


181     case Primitive:
182         return static_cast&lt;size_t&gt;(primitiveGigacageSize);
183     case JSValue:
184         return static_cast&lt;size_t&gt;(jsValueGigacageSize);
<span class="line-added">185     case NumberOfKinds:</span>
<span class="line-added">186         break;</span>
187     }
188     BCRASH();
189     return 0;
190 }
191 
192 BINLINE size_t alignment(Kind kind)
193 {
194     return size(kind);
195 }
196 
197 BINLINE size_t mask(Kind kind)
198 {
199     return gigacageSizeToMask(size(kind));
200 }
201 
202 template&lt;typename Func&gt;
203 void forEachKind(const Func&amp; func)
204 {
205     func(Primitive);
206     func(JSValue);
207 }
208 
209 template&lt;typename T&gt;
210 BINLINE T* caged(Kind kind, T* ptr)
211 {
212     BASSERT(ptr);
<span class="line-modified">213     void* gigacageBasePtr = g_gigacageConfig.basePtr(kind);</span>
214     if (!gigacageBasePtr)
215         return ptr;
216     return reinterpret_cast&lt;T*&gt;(
217         reinterpret_cast&lt;uintptr_t&gt;(gigacageBasePtr) + (
218             reinterpret_cast&lt;uintptr_t&gt;(ptr) &amp; mask(kind)));
219 }
220 
221 template&lt;typename T&gt;
222 BINLINE T* cagedMayBeNull(Kind kind, T* ptr)
223 {
224     if (!ptr)
225         return ptr;
226     return caged(kind, ptr);
227 }
228 
229 BINLINE bool isCaged(Kind kind, const void* ptr)
230 {
231     return caged(kind, ptr) == ptr;
232 }
233 
<span class="line-added">234 BINLINE bool contains(const void* ptr)</span>
<span class="line-added">235 {</span>
<span class="line-added">236     auto* start = reinterpret_cast&lt;const uint8_t*&gt;(g_gigacageConfig.start);</span>
<span class="line-added">237     auto* p = reinterpret_cast&lt;const uint8_t*&gt;(ptr);</span>
<span class="line-added">238     return static_cast&lt;size_t&gt;(p - start) &lt; g_gigacageConfig.totalSize;</span>
<span class="line-added">239 }</span>
<span class="line-added">240 </span>
241 BEXPORT bool shouldBeEnabled();
242 
243 #else // GIGACAGE_ENABLED
244 
<span class="line-modified">245 BINLINE void* basePtr(Kind)</span>
246 {
247     BCRASH();
248     static void* unreachable;
249     return unreachable;
250 }
251 BINLINE size_t size(Kind) { BCRASH(); return 0; }
252 BINLINE void ensureGigacage() { }
<span class="line-modified">253 BINLINE bool contains(const void*) { return false; }</span>
<span class="line-added">254 BINLINE bool isEnabled() { return false; }</span>
255 BINLINE bool isCaged(Kind, const void*) { return true; }
256 BINLINE bool isEnabled(Kind) { return false; }
257 template&lt;typename T&gt; BINLINE T* caged(Kind, T* ptr) { return ptr; }
258 template&lt;typename T&gt; BINLINE T* cagedMayBeNull(Kind, T* ptr) { return ptr; }
<span class="line-modified">259 BINLINE void forbidDisablingPrimitiveGigacage() { }</span>
260 BINLINE bool canPrimitiveGigacageBeDisabled() { return false; }
261 BINLINE void disablePrimitiveGigacage() { }
262 BINLINE void addPrimitiveDisableCallback(void (*)(void*), void*) { }
263 BINLINE void removePrimitiveDisableCallback(void (*)(void*), void*) { }
264 
265 #endif // GIGACAGE_ENABLED
266 
267 } // namespace Gigacage
268 
269 
270 
</pre>
</td>
</tr>
</table>
<center><a href="Gigacage.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Heap.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
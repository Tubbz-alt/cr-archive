<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/loader/DocumentLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2006-2020 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2011 Google Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  *
   9  * 1.  Redistributions of source code must retain the above copyright
  10  *     notice, this list of conditions and the following disclaimer.
  11  * 2.  Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
  15  *     its contributors may be used to endorse or promote products derived
  16  *     from this software without specific prior written permission.
  17  *
  18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;DocumentLoader.h&quot;
  32 
  33 #include &quot;ApplicationCacheHost.h&quot;
  34 #include &quot;Archive.h&quot;
  35 #include &quot;ArchiveResourceCollection.h&quot;
  36 #include &quot;CachedPage.h&quot;
  37 #include &quot;CachedRawResource.h&quot;
  38 #include &quot;CachedResourceLoader.h&quot;
  39 #include &quot;ContentExtensionError.h&quot;
  40 #include &quot;ContentSecurityPolicy.h&quot;
  41 #include &quot;CustomHeaderFields.h&quot;
  42 #include &quot;DOMWindow.h&quot;
  43 #include &quot;Document.h&quot;
  44 #include &quot;DocumentParser.h&quot;
  45 #include &quot;DocumentWriter.h&quot;
  46 #include &quot;ElementChildIterator.h&quot;
  47 #include &quot;Event.h&quot;
  48 #include &quot;EventNames.h&quot;
  49 #include &quot;ExtensionStyleSheets.h&quot;
  50 #include &quot;FormState.h&quot;
  51 #include &quot;Frame.h&quot;
  52 #include &quot;FrameLoader.h&quot;
  53 #include &quot;FrameLoaderClient.h&quot;
  54 #include &quot;FrameTree.h&quot;
  55 #include &quot;HTMLFormElement.h&quot;
  56 #include &quot;HTMLFrameOwnerElement.h&quot;
  57 #include &quot;HTTPHeaderNames.h&quot;
  58 #include &quot;HistoryItem.h&quot;
  59 #include &quot;HistoryController.h&quot;
  60 #include &quot;IconLoader.h&quot;
  61 #include &quot;InspectorInstrumentation.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  62 #include &quot;LegacySchemeRegistry.h&quot;</span>
  63 #include &quot;LinkIconCollector.h&quot;
  64 #include &quot;LinkIconType.h&quot;
  65 #include &quot;LoaderStrategy.h&quot;
  66 #include &quot;Logging.h&quot;
  67 #include &quot;MemoryCache.h&quot;
  68 #include &quot;NetworkLoadMetrics.h&quot;
  69 #include &quot;Page.h&quot;
  70 #include &quot;PingLoader.h&quot;
  71 #include &quot;PlatformStrategies.h&quot;
  72 #include &quot;PolicyChecker.h&quot;
  73 #include &quot;ProgressTracker.h&quot;
  74 #include &quot;ResourceHandle.h&quot;
  75 #include &quot;ResourceLoadObserver.h&quot;
  76 #include &quot;RuntimeEnabledFeatures.h&quot;
  77 #include &quot;SWClientConnection.h&quot;
<a name="3" id="anc3"></a>
  78 #include &quot;ScriptableDocumentParser.h&quot;
  79 #include &quot;SecurityPolicy.h&quot;
  80 #include &quot;ServiceWorker.h&quot;
  81 #include &quot;ServiceWorkerClientData.h&quot;
  82 #include &quot;ServiceWorkerProvider.h&quot;
  83 #include &quot;Settings.h&quot;
  84 #include &quot;SubresourceLoader.h&quot;
  85 #include &quot;TextResourceDecoder.h&quot;
  86 #include &lt;wtf/Assertions.h&gt;
  87 #include &lt;wtf/CompletionHandler.h&gt;
  88 #include &lt;wtf/NeverDestroyed.h&gt;
  89 #include &lt;wtf/Ref.h&gt;
  90 #include &lt;wtf/text/CString.h&gt;
  91 #include &lt;wtf/text/WTFString.h&gt;
  92 
  93 #if ENABLE(APPLICATION_MANIFEST)
  94 #include &quot;ApplicationManifestLoader.h&quot;
  95 #include &quot;HTMLHeadElement.h&quot;
  96 #include &quot;HTMLLinkElement.h&quot;
  97 #endif
  98 
  99 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 100 #include &quot;ArchiveFactory.h&quot;
 101 #endif
 102 
 103 #if ENABLE(CONTENT_FILTERING)
 104 #include &quot;ContentFilter.h&quot;
<a name="4" id="anc4"></a><span class="line-added"> 105 #include &quot;FrameLoadRequest.h&quot;</span>
<span class="line-added"> 106 #include &quot;ScriptController.h&quot;</span>
 107 #endif
 108 
 109 #if USE(QUICK_LOOK)
 110 #include &quot;PreviewConverter.h&quot;
 111 #include &quot;QuickLook.h&quot;
 112 #endif
 113 
 114 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - DocumentLoader::&quot; fmt, this, ##__VA_ARGS__)
 115 
 116 namespace WebCore {
 117 
 118 static void cancelAll(const ResourceLoaderMap&amp; loaders)
 119 {
 120     for (auto&amp; loader : copyToVector(loaders.values()))
 121         loader-&gt;cancel();
 122 }
 123 
 124 static void setAllDefersLoading(const ResourceLoaderMap&amp; loaders, bool defers)
 125 {
 126     for (auto&amp; loader : copyToVector(loaders.values()))
 127         loader-&gt;setDefersLoading(defers);
 128 }
 129 
<a name="5" id="anc5"></a><span class="line-modified"> 130 static HashMap&lt;DocumentIdentifier, DocumentLoader*&gt;&amp; temporaryIdentifierToLoaderMap()</span>
 131 {
<a name="6" id="anc6"></a><span class="line-modified"> 132     static NeverDestroyed&lt;HashMap&lt;DocumentIdentifier, DocumentLoader*&gt;&gt; map;</span>
<span class="line-modified"> 133     return map.get();</span>






























 134 }
 135 
<a name="7" id="anc7"></a><span class="line-modified"> 136 DocumentLoader* DocumentLoader::fromTemporaryDocumentIdentifier(DocumentIdentifier identifier)</span>
 137 {
<a name="8" id="anc8"></a><span class="line-modified"> 138     return temporaryIdentifierToLoaderMap().get(identifier);</span>













 139 }
 140 
<a name="9" id="anc9"></a><span class="line-added"> 141 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(DocumentLoader);</span>
<span class="line-added"> 142 </span>
 143 DocumentLoader::DocumentLoader(const ResourceRequest&amp; request, const SubstituteData&amp; substituteData)
 144     : FrameDestructionObserver(nullptr)
 145     , m_cachedResourceLoader(CachedResourceLoader::create(this))
 146     , m_originalRequest(request)
 147     , m_substituteData(substituteData)
 148     , m_originalRequestCopy(request)
 149     , m_request(request)
 150     , m_originalSubstituteDataWasValid(substituteData.isValid())
 151     , m_substituteResourceDeliveryTimer(*this, &amp;DocumentLoader::substituteResourceDeliveryTimerFired)
 152     , m_dataLoadTimer(*this, &amp;DocumentLoader::handleSubstituteDataLoadNow)
 153     , m_applicationCacheHost(makeUnique&lt;ApplicationCacheHost&gt;(*this))
 154 {
 155 }
 156 
 157 FrameLoader* DocumentLoader::frameLoader() const
 158 {
 159     if (!m_frame)
 160         return nullptr;
 161     return &amp;m_frame-&gt;loader();
 162 }
 163 
 164 SubresourceLoader* DocumentLoader::mainResourceLoader() const
 165 {
 166     if (!m_mainResource)
 167         return nullptr;
 168     return m_mainResource-&gt;loader();
 169 }
 170 
 171 DocumentLoader::~DocumentLoader()
 172 {
 173     ASSERT(!m_frame || !isLoading() || frameLoader()-&gt;activeDocumentLoader() != this);
 174     ASSERT_WITH_MESSAGE(!m_waitingForContentPolicy, &quot;The content policy callback should never outlive its DocumentLoader.&quot;);
 175     ASSERT_WITH_MESSAGE(!m_waitingForNavigationPolicy, &quot;The navigation policy callback should never outlive its DocumentLoader.&quot;);
 176 
 177     m_cachedResourceLoader-&gt;clearDocumentLoader();
 178     clearMainResource();
<a name="10" id="anc10"></a><span class="line-added"> 179 </span>
<span class="line-added"> 180 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-added"> 181     if (m_temporaryServiceWorkerClient) {</span>
<span class="line-added"> 182         ASSERT(temporaryIdentifierToLoaderMap().contains(*m_temporaryServiceWorkerClient));</span>
<span class="line-added"> 183         temporaryIdentifierToLoaderMap().remove(*m_temporaryServiceWorkerClient);</span>
<span class="line-added"> 184     }</span>
<span class="line-added"> 185 #endif</span>
 186 }
 187 
 188 RefPtr&lt;SharedBuffer&gt; DocumentLoader::mainResourceData() const
 189 {
 190     if (m_substituteData.isValid())
 191         return m_substituteData.content()-&gt;copy();
 192     if (m_mainResource)
 193         return m_mainResource-&gt;resourceBuffer();
 194     return nullptr;
 195 }
 196 
 197 Document* DocumentLoader::document() const
 198 {
 199     if (m_frame &amp;&amp; m_frame-&gt;loader().documentLoader() == this)
 200         return m_frame-&gt;document();
 201     return nullptr;
 202 }
 203 
 204 void DocumentLoader::replaceRequestURLForSameDocumentNavigation(const URL&amp; url)
 205 {
 206     m_originalRequestCopy.setURL(url);
 207     m_request.setURL(url);
 208 }
 209 
 210 void DocumentLoader::setRequest(const ResourceRequest&amp; req)
 211 {
 212     // Replacing an unreachable URL with alternate content looks like a server-side
 213     // redirect at this point, but we can replace a committed dataSource.
 214     bool handlingUnreachableURL = false;
 215 
 216     handlingUnreachableURL = m_substituteData.isValid() &amp;&amp; !m_substituteData.failingURL().isEmpty();
 217 
 218     bool shouldNotifyAboutProvisionalURLChange = false;
 219     if (handlingUnreachableURL)
 220         m_committed = false;
 221     else if (isLoadingMainResource() &amp;&amp; req.url() != m_request.url())
 222         shouldNotifyAboutProvisionalURLChange = true;
 223 
 224     // We should never be getting a redirect callback after the data
 225     // source is committed, except in the unreachable URL case. It
 226     // would be a WebFoundation bug if it sent a redirect callback after commit.
 227     ASSERT(!m_committed);
 228 
 229     m_request = req;
<a name="11" id="anc11"></a><span class="line-modified"> 230     if (shouldNotifyAboutProvisionalURLChange) {</span>
<span class="line-added"> 231         // Logging for &lt;rdar://problem/54830233&gt;.</span>
<span class="line-added"> 232         if (!frameLoader()-&gt;provisionalDocumentLoader())</span>
<span class="line-added"> 233             RELEASE_LOG_IF_ALLOWED(&quot;DocumentLoader::setRequest: With no provisional document loader (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);</span>
 234         frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();
<a name="12" id="anc12"></a><span class="line-added"> 235     }</span>
 236 }
 237 
 238 void DocumentLoader::setMainDocumentError(const ResourceError&amp; error)
 239 {
 240     if (!error.isNull())
 241         RELEASE_LOG_IF_ALLOWED(&quot;setMainDocumentError: (frame = %p, main = %d, type = %d, code = %d)&quot;, m_frame, m_frame-&gt;isMainFrame(), static_cast&lt;int&gt;(error.type()), error.errorCode());
 242 
 243     m_mainDocumentError = error;
 244     frameLoader()-&gt;client().setMainDocumentError(this, error);
 245 }
 246 
 247 void DocumentLoader::mainReceivedError(const ResourceError&amp; error)
 248 {
 249     ASSERT(!error.isNull());
 250 
 251     if (!frameLoader())
 252         return;
 253 
 254     if (!error.isNull())
 255         RELEASE_LOG_IF_ALLOWED(&quot;mainReceivedError: (frame = %p, main = %d, type = %d, code = %d)&quot;, m_frame, m_frame-&gt;isMainFrame(), static_cast&lt;int&gt;(error.type()), error.errorCode());
 256 
 257     if (m_identifierForLoadWithoutResourceLoader) {
 258         ASSERT(!mainResourceLoader());
 259         frameLoader()-&gt;client().dispatchDidFailLoading(this, m_identifierForLoadWithoutResourceLoader, error);
 260     }
 261 
 262     // There is a bug in CFNetwork where callbacks can be dispatched even when loads are deferred.
 263     // See &lt;rdar://problem/6304600&gt; for more details.
 264 #if !USE(CF)
 265     ASSERT(!mainResourceLoader() || !mainResourceLoader()-&gt;defersLoading());
 266 #endif
 267 
 268     m_applicationCacheHost-&gt;failedLoadingMainResource();
 269 
 270     setMainDocumentError(error);
 271     clearMainResourceLoader();
 272     frameLoader()-&gt;receivedMainResourceError(error);
 273 }
 274 
 275 // Cancels the data source&#39;s pending loads.  Conceptually, a data source only loads
 276 // one document at a time, but one document may have many related resources.
 277 // stopLoading will stop all loads initiated by the data source,
 278 // but not loads initiated by child frames&#39; data sources -- that&#39;s the WebFrame&#39;s job.
 279 void DocumentLoader::stopLoading()
 280 {
 281     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
 282     Ref&lt;DocumentLoader&gt; protectedThis(*this);
 283 
 284     // In some rare cases, calling FrameLoader::stopLoading could cause isLoading() to return false.
 285     // (This can happen when there&#39;s a single XMLHttpRequest currently loading and stopLoading causes it
 286     // to stop loading. Because of this, we need to save it so we don&#39;t return early.
 287     bool loading = isLoading();
 288 
<a name="13" id="anc13"></a>






 289     if (m_committed) {
 290         // Attempt to stop the frame if the document loader is loading, or if it is done loading but
 291         // still  parsing. Failure to do so can cause a world leak.
 292         Document* doc = m_frame-&gt;document();
 293 
 294         if (loading || doc-&gt;parsing())
 295             m_frame-&gt;loader().stopLoading(UnloadEventPolicyNone);
 296     }
 297 
 298     for (auto callbackIdentifier : m_iconLoaders.values())
 299         notifyFinishedLoadingIcon(callbackIdentifier, nullptr);
 300     m_iconLoaders.clear();
 301     m_iconsPendingLoadDecision.clear();
 302 
 303 #if ENABLE(APPLICATION_MANIFEST)
 304     for (auto callbackIdentifier : m_applicationManifestLoaders.values())
 305         notifyFinishedLoadingApplicationManifest(callbackIdentifier, WTF::nullopt);
 306     m_applicationManifestLoaders.clear();
 307 #endif
 308 
 309     // Always cancel multipart loaders
 310     cancelAll(m_multipartSubresourceLoaders);
 311 
 312     // Appcache uses ResourceHandle directly, DocumentLoader doesn&#39;t count these loads.
 313     m_applicationCacheHost-&gt;stopLoadingInFrame(*m_frame);
 314 
 315 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
 316     clearArchiveResources();
 317 #endif
 318 
 319     if (!loading) {
 320         // If something above restarted loading we might run into mysterious crashes like
 321         // https://bugs.webkit.org/show_bug.cgi?id=62764 and &lt;rdar://problem/9328684&gt;
 322         ASSERT(!isLoading());
 323         return;
 324     }
 325 
 326     // We might run in to infinite recursion if we&#39;re stopping loading as the result of
 327     // detaching from the frame, so break out of that recursion here.
 328     // See &lt;rdar://problem/9673866&gt; for more details.
 329     if (m_isStopping)
 330         return;
 331 
 332     m_isStopping = true;
 333 
 334     // The frame may have been detached from this document by the onunload handler
 335     if (auto* frameLoader = DocumentLoader::frameLoader()) {
 336         RELEASE_LOG_IF_ALLOWED(&quot;stopLoading: canceling load (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 337         if (isLoadingMainResource()) {
 338             // Stop the main resource loader and let it send the cancelled message.
 339             cancelMainResourceLoad(frameLoader-&gt;cancelledError(m_request));
 340         } else if (!m_subresourceLoaders.isEmpty() || !m_plugInStreamLoaders.isEmpty()) {
 341             // The main resource loader already finished loading. Set the cancelled error on the
 342             // document and let the subresourceLoaders and pluginLoaders send individual cancelled messages below.
 343             setMainDocumentError(frameLoader-&gt;cancelledError(m_request));
 344         } else {
 345             // If there are no resource loaders, we need to manufacture a cancelled message.
 346             // (A back/forward navigation has no resource loaders because its resources are cached.)
 347             mainReceivedError(frameLoader-&gt;cancelledError(m_request));
 348         }
 349     }
 350 
 351     // We always need to explicitly cancel the Document&#39;s parser when stopping the load.
 352     // Otherwise cancelling the parser while starting the next page load might result
 353     // in unexpected side effects such as erroneous event dispatch. ( http://webkit.org/b/117112 )
 354     if (Document* document = this-&gt;document())
 355         document-&gt;cancelParsing();
 356 
 357     stopLoadingSubresources();
 358     stopLoadingPlugIns();
 359 
 360     m_isStopping = false;
 361 }
 362 
 363 void DocumentLoader::commitIfReady()
 364 {
 365     if (!m_committed) {
 366         m_committed = true;
 367         frameLoader()-&gt;commitProvisionalLoad();
 368     }
 369 }
 370 
 371 bool DocumentLoader::isLoading() const
 372 {
 373     // if (document() &amp;&amp; document()-&gt;hasActiveParser())
 374     //     return true;
 375     // FIXME: The above code should be enabled, but it seems to cause
 376     // http/tests/security/feed-urls-from-remote.html to timeout on Mac WK1
 377     // see http://webkit.org/b/110554 and http://webkit.org/b/110401
 378 
 379     return isLoadingMainResource() || !m_subresourceLoaders.isEmpty() || !m_plugInStreamLoaders.isEmpty();
 380 }
 381 
 382 void DocumentLoader::notifyFinished(CachedResource&amp; resource)
 383 {
 384     ASSERT(isMainThread());
 385 #if ENABLE(CONTENT_FILTERING)
 386     if (m_contentFilter &amp;&amp; !m_contentFilter-&gt;continueAfterNotifyFinished(resource))
 387         return;
 388 #endif
 389 
 390     ASSERT_UNUSED(resource, m_mainResource == &amp;resource);
 391     ASSERT(m_mainResource);
 392     if (!m_mainResource-&gt;errorOccurred() &amp;&amp; !m_mainResource-&gt;wasCanceled()) {
 393         finishedLoading();
 394         return;
 395     }
 396 
 397     if (m_request.cachePolicy() == ResourceRequestCachePolicy::ReturnCacheDataDontLoad &amp;&amp; !m_mainResource-&gt;wasCanceled()) {
 398         frameLoader()-&gt;retryAfterFailedCacheOnlyMainResourceLoad();
 399         return;
 400     }
 401 
 402     if (!m_mainResource-&gt;resourceError().isNull())
 403         RELEASE_LOG_IF_ALLOWED(&quot;notifyFinished: canceling load (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 404 
 405     mainReceivedError(m_mainResource-&gt;resourceError());
 406 }
 407 
 408 void DocumentLoader::finishedLoading()
 409 {
 410     // There is a bug in CFNetwork where callbacks can be dispatched even when loads are deferred.
 411     // See &lt;rdar://problem/6304600&gt; for more details.
 412 #if !USE(CF)
 413     ASSERT(!m_frame-&gt;page()-&gt;defersLoading() || frameLoader()-&gt;stateMachine().creatingInitialEmptyDocument() || InspectorInstrumentation::isDebuggerPaused(m_frame));
 414 #endif
 415 
 416     Ref&lt;DocumentLoader&gt; protectedThis(*this);
 417 
 418     if (m_identifierForLoadWithoutResourceLoader) {
 419         // A didFinishLoading delegate might try to cancel the load (despite it
 420         // being finished). Clear m_identifierForLoadWithoutResourceLoader
 421         // before calling dispatchDidFinishLoading so that we don&#39;t later try to
 422         // cancel the already-finished substitute load.
 423         NetworkLoadMetrics emptyMetrics;
 424         unsigned long identifier = m_identifierForLoadWithoutResourceLoader;
 425         m_identifierForLoadWithoutResourceLoader = 0;
 426         frameLoader()-&gt;notifier().dispatchDidFinishLoading(this, identifier, emptyMetrics, nullptr);
 427     }
 428 
 429     maybeFinishLoadingMultipartContent();
 430 
 431     MonotonicTime responseEndTime = m_timeOfLastDataReceived ? m_timeOfLastDataReceived : MonotonicTime::now();
 432     timing().setResponseEnd(responseEndTime);
 433 
 434     commitIfReady();
 435     if (!frameLoader())
 436         return;
 437 
 438     if (!maybeCreateArchive()) {
 439         // If this is an empty document, it will not have actually been created yet. Commit dummy data so that
 440         // DocumentWriter::begin() gets called and creates the Document.
 441         if (!m_gotFirstByte)
 442             commitData(0, 0);
 443         frameLoader()-&gt;client().finishedLoading(this);
 444     }
 445 
 446     m_writer.end();
 447     if (!m_mainDocumentError.isNull())
 448         return;
 449     clearMainResourceLoader();
 450     if (!frameLoader())
 451         return;
 452     if (!frameLoader()-&gt;stateMachine().creatingInitialEmptyDocument())
 453         frameLoader()-&gt;checkLoadComplete();
 454 
 455     // If the document specified an application cache manifest, it violates the author&#39;s intent if we store it in the memory cache
 456     // and deny the appcache the chance to intercept it in the future, so remove from the memory cache.
 457     if (m_frame) {
 458         if (m_mainResource &amp;&amp; m_frame-&gt;document()-&gt;hasManifest())
 459             MemoryCache::singleton().remove(*m_mainResource);
 460     }
 461     m_applicationCacheHost-&gt;finishedLoadingMainResource();
 462 }
 463 
 464 bool DocumentLoader::isPostOrRedirectAfterPost(const ResourceRequest&amp; newRequest, const ResourceResponse&amp; redirectResponse)
 465 {
 466     if (newRequest.httpMethod() == &quot;POST&quot;)
 467         return true;
 468 
 469     int status = redirectResponse.httpStatusCode();
 470     if (((status &gt;= 301 &amp;&amp; status &lt;= 303) || status == 307)
 471         &amp;&amp; m_originalRequest.httpMethod() == &quot;POST&quot;)
 472         return true;
 473 
 474     return false;
 475 }
 476 
 477 void DocumentLoader::handleSubstituteDataLoadNow()
 478 {
 479     ResourceResponse response = m_substituteData.response();
 480     if (response.url().isEmpty())
 481         response = ResourceResponse(m_request.url(), m_substituteData.mimeType(), m_substituteData.content()-&gt;size(), m_substituteData.textEncoding());
 482 
 483     responseReceived(response, nullptr);
 484 }
 485 
 486 void DocumentLoader::startDataLoadTimer()
 487 {
 488     m_dataLoadTimer.startOneShot(0_s);
 489 
 490 #if HAVE(RUNLOOP_TIMER)
 491     if (SchedulePairHashSet* scheduledPairs = m_frame-&gt;page()-&gt;scheduledRunLoopPairs())
 492         m_dataLoadTimer.schedule(*scheduledPairs);
 493 #endif
 494 }
 495 
 496 #if ENABLE(SERVICE_WORKER)
<a name="14" id="anc14"></a><span class="line-added"> 497 bool DocumentLoader::setControllingServiceWorkerRegistration(ServiceWorkerRegistrationData&amp;&amp; data)</span>
<span class="line-added"> 498 {</span>
<span class="line-added"> 499     if (!m_loadingMainResource)</span>
<span class="line-added"> 500         return false;</span>
<span class="line-added"> 501 </span>
<span class="line-added"> 502     ASSERT(!m_gotFirstByte);</span>
<span class="line-added"> 503     m_serviceWorkerRegistrationData = WTFMove(data);</span>
<span class="line-added"> 504     return true;</span>
<span class="line-added"> 505 }</span>
<span class="line-added"> 506 </span>
 507 void DocumentLoader::matchRegistration(const URL&amp; url, SWClientConnection::RegistrationCallback&amp;&amp; callback)
 508 {
<a name="15" id="anc15"></a><span class="line-modified"> 509     auto shouldTryLoadingThroughServiceWorker = !frameLoader()-&gt;isReloadingFromOrigin() &amp;&amp; m_frame-&gt;page() &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; LegacySchemeRegistry::canServiceWorkersHandleURLScheme(url.protocol().toStringWithoutCopying());</span>
 510     if (!shouldTryLoadingThroughServiceWorker) {
 511         callback(WTF::nullopt);
 512         return;
 513     }
 514 
 515     auto origin = (!m_frame-&gt;isMainFrame() &amp;&amp; m_frame-&gt;document()) ? m_frame-&gt;document()-&gt;topOrigin().data() : SecurityOriginData::fromURL(url);
<a name="16" id="anc16"></a><span class="line-modified"> 516     if (!ServiceWorkerProvider::singleton().serviceWorkerConnection().mayHaveServiceWorkerRegisteredForOrigin(origin)) {</span>


 517         callback(WTF::nullopt);
 518         return;
 519     }
 520 
<a name="17" id="anc17"></a><span class="line-modified"> 521     auto&amp; connection = ServiceWorkerProvider::singleton().serviceWorkerConnection();</span>
 522     connection.matchRegistration(WTFMove(origin), url, WTFMove(callback));
 523 }
 524 
 525 static inline bool areRegistrationsEqual(const Optional&lt;ServiceWorkerRegistrationData&gt;&amp; a, const Optional&lt;ServiceWorkerRegistrationData&gt;&amp; b)
 526 {
 527     if (!a)
 528         return !b;
 529     if (!b)
 530         return false;
 531     return a-&gt;identifier == b-&gt;identifier;
 532 }
 533 #endif
 534 
 535 void DocumentLoader::redirectReceived(CachedResource&amp; resource, ResourceRequest&amp;&amp; request, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
 536 {
 537     ASSERT_UNUSED(resource, &amp;resource == m_mainResource);
 538 #if ENABLE(SERVICE_WORKER)
<a name="18" id="anc18"></a><span class="line-modified"> 539     if (m_serviceWorkerRegistrationData) {</span>
<span class="line-modified"> 540         m_serviceWorkerRegistrationData = { };</span>
<span class="line-added"> 541         unregisterTemporaryServiceWorkerClient();</span>
<span class="line-added"> 542     }</span>
<span class="line-added"> 543     willSendRequest(WTFMove(request), redirectResponse, [completionHandler = WTFMove(completionHandler), protectedThis = makeRef(*this), this] (auto&amp;&amp; request) mutable {</span>
 544         ASSERT(!m_substituteData.isValid());
 545         if (request.isNull() || !m_mainDocumentError.isNull() || !m_frame) {
 546             completionHandler({ });
 547             return;
 548         }
 549 
<a name="19" id="anc19"></a><span class="line-modified"> 550         if (m_applicationCacheHost-&gt;canLoadMainResource(request)) {</span>
<span class="line-modified"> 551             auto url = request.url();</span>
<span class="line-modified"> 552             // Let&#39;s check service worker registration to see whether loading from network or not.</span>
<span class="line-modified"> 553             this-&gt;matchRegistration(url, [request = WTFMove(request), completionHandler = WTFMove(completionHandler), protectedThis = WTFMove(protectedThis), this](auto&amp;&amp; registrationData) mutable {</span>
<span class="line-modified"> 554                 if (!m_mainDocumentError.isNull() || !m_frame) {</span>
<span class="line-modified"> 555                     completionHandler({ });</span>
<span class="line-modified"> 556                     return;</span>
<span class="line-modified"> 557                 }</span>
<span class="line-modified"> 558                 if (!registrationData &amp;&amp; this-&gt;tryLoadingRedirectRequestFromApplicationCache(request)) {</span>
<span class="line-modified"> 559                     completionHandler({ });</span>
<span class="line-modified"> 560                     return;</span>
<span class="line-modified"> 561                 }</span>




 562                 completionHandler(WTFMove(request));
<a name="20" id="anc20"></a><span class="line-modified"> 563             });</span>




 564             return;
<a name="21" id="anc21"></a><span class="line-modified"> 565         }</span>
<span class="line-added"> 566         completionHandler(WTFMove(request));</span>
 567     });
 568 #else
 569     willSendRequest(WTFMove(request), redirectResponse, WTFMove(completionHandler));
 570 #endif
 571 }
 572 
 573 void DocumentLoader::willSendRequest(ResourceRequest&amp;&amp; newRequest, const ResourceResponse&amp; redirectResponse, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp; completionHandler)
 574 {
 575     // Note that there are no asserts here as there are for the other callbacks. This is due to the
 576     // fact that this &quot;callback&quot; is sent when starting every load, and the state of callback
 577     // deferrals plays less of a part in this function in preventing the bad behavior deferring
 578     // callbacks is meant to prevent.
 579     ASSERT(!newRequest.isNull());
 580 
<a name="22" id="anc22"></a><span class="line-added"> 581     // Logging for &lt;rdar://problem/54830233&gt;.</span>
<span class="line-added"> 582     if (!frameLoader() || !frameLoader()-&gt;provisionalDocumentLoader())</span>
<span class="line-added"> 583         RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: With no provisional document loader (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);</span>
<span class="line-added"> 584 </span>
 585     bool didReceiveRedirectResponse = !redirectResponse.isNull();
 586     if (!frameLoader()-&gt;checkIfFormActionAllowedByCSP(newRequest.url(), didReceiveRedirectResponse)) {
 587         RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: canceling - form action not allowed by CSP (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 588         cancelMainResourceLoad(frameLoader()-&gt;cancelledError(newRequest));
 589         return completionHandler(WTFMove(newRequest));
 590     }
 591 
 592     ASSERT(timing().fetchStart());
 593     if (didReceiveRedirectResponse) {
 594         // If the redirecting url is not allowed to display content from the target origin,
 595         // then block the redirect.
 596         Ref&lt;SecurityOrigin&gt; redirectingOrigin(SecurityOrigin::create(redirectResponse.url()));
 597         if (!redirectingOrigin.get().canDisplay(newRequest.url())) {
 598             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: canceling - redirecting URL not allowed to display content from target(frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 599             FrameLoader::reportLocalLoadFailed(m_frame, newRequest.url().string());
 600             cancelMainResourceLoad(frameLoader()-&gt;cancelledError(newRequest));
 601             return completionHandler(WTFMove(newRequest));
 602         }
 603         if (!portAllowed(newRequest.url())) {
 604             RELEASE_LOG_IF_ALLOWED(&quot;willSendRequest: canceling - port not allowed (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 605             FrameLoader::reportBlockedPortFailed(m_frame, newRequest.url().string());
 606             cancelMainResourceLoad(frameLoader()-&gt;blockedError(newRequest));
 607             return completionHandler(WTFMove(newRequest));
 608         }
 609         timing().addRedirect(redirectResponse.url(), newRequest.url());
 610     }
 611 
 612     ASSERT(m_frame);
 613 
 614     Frame&amp; topFrame = m_frame-&gt;tree().top();
 615 
 616     ASSERT(m_frame-&gt;document());
 617     ASSERT(topFrame.document());
 618 
 619     // Update cookie policy base URL as URL changes, except for subframes, which use the
 620     // URL of the main frame which doesn&#39;t change when we redirect.
 621     if (m_frame-&gt;isMainFrame())
 622         newRequest.setFirstPartyForCookies(newRequest.url());
 623 
 624     FrameLoader::addSameSiteInfoToRequestIfNeeded(newRequest, m_frame-&gt;document());
 625 
 626     if (!didReceiveRedirectResponse)
 627         frameLoader()-&gt;client().dispatchWillChangeDocument(m_frame-&gt;document()-&gt;url(), newRequest.url());
 628 
 629     // If we&#39;re fielding a redirect in response to a POST, force a load from origin, since
 630     // this is a common site technique to return to a page viewing some data that the POST
 631     // just modified.
 632     // Also, POST requests always load from origin, but this does not affect subresources.
 633     if (newRequest.cachePolicy() == ResourceRequestCachePolicy::UseProtocolCachePolicy &amp;&amp; isPostOrRedirectAfterPost(newRequest, redirectResponse))
 634         newRequest.setCachePolicy(ResourceRequestCachePolicy::ReloadIgnoringCacheData);
 635 
 636     if (&amp;topFrame != m_frame) {
 637         if (!m_frame-&gt;loader().mixedContentChecker().canDisplayInsecureContent(m_frame-&gt;document()-&gt;securityOrigin(), MixedContentChecker::ContentType::Active, newRequest.url(), MixedContentChecker::AlwaysDisplayInNonStrictMode::Yes)) {
 638             cancelMainResourceLoad(frameLoader()-&gt;cancelledError(newRequest));
 639             return completionHandler(WTFMove(newRequest));
 640         }
 641         if (!frameLoader()-&gt;mixedContentChecker().canDisplayInsecureContent(topFrame.document()-&gt;securityOrigin(), MixedContentChecker::ContentType::Active, newRequest.url())) {
 642             cancelMainResourceLoad(frameLoader()-&gt;cancelledError(newRequest));
 643             return completionHandler(WTFMove(newRequest));
 644         }
 645     }
 646 
 647 #if ENABLE(CONTENT_FILTERING)
 648     if (m_contentFilter &amp;&amp; !m_contentFilter-&gt;continueAfterWillSendRequest(newRequest, redirectResponse))
 649         return completionHandler(WTFMove(newRequest));
 650 #endif
 651 
 652     setRequest(newRequest);
 653 
 654     if (!didReceiveRedirectResponse)
 655         return completionHandler(WTFMove(newRequest));
 656 
 657     auto navigationPolicyCompletionHandler = [this, protectedThis = makeRef(*this), completionHandler = WTFMove(completionHandler)] (ResourceRequest&amp;&amp; request, WeakPtr&lt;FormState&gt;&amp;&amp;, NavigationPolicyDecision navigationPolicyDecision) mutable {
 658         m_waitingForNavigationPolicy = false;
 659         switch (navigationPolicyDecision) {
 660         case NavigationPolicyDecision::IgnoreLoad:
 661         case NavigationPolicyDecision::StopAllLoads:
 662             stopLoadingForPolicyChange();
 663             break;
 664         case NavigationPolicyDecision::ContinueLoad:
 665             break;
 666         }
 667 
 668         completionHandler(WTFMove(request));
 669     };
 670 
 671     ASSERT(!m_waitingForNavigationPolicy);
 672     m_waitingForNavigationPolicy = true;
 673 
 674     // FIXME: Add a load type check.
 675     auto&amp; policyChecker = frameLoader()-&gt;policyChecker();
 676     RELEASE_ASSERT(!isBackForwardLoadType(policyChecker.loadType()) || frameLoader()-&gt;history().provisionalItem());
 677     policyChecker.checkNavigationPolicy(WTFMove(newRequest), redirectResponse, WTFMove(navigationPolicyCompletionHandler));
 678 }
 679 
 680 bool DocumentLoader::tryLoadingRequestFromApplicationCache()
 681 {
 682     m_applicationCacheHost-&gt;maybeLoadMainResource(m_request, m_substituteData);
 683     return tryLoadingSubstituteData();
 684 }
 685 
 686 bool DocumentLoader::tryLoadingSubstituteData()
 687 {
 688     if (!m_substituteData.isValid() || !m_frame-&gt;page())
 689         return false;
 690 
 691     RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Returning substitute data (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 692     m_identifierForLoadWithoutResourceLoader = m_frame-&gt;page()-&gt;progress().createUniqueIdentifier();
 693     frameLoader()-&gt;notifier().assignIdentifierToInitialRequest(m_identifierForLoadWithoutResourceLoader, this, m_request);
 694     frameLoader()-&gt;notifier().dispatchWillSendRequest(this, m_identifierForLoadWithoutResourceLoader, m_request, ResourceResponse());
 695 
 696     if (!m_deferMainResourceDataLoad || frameLoader()-&gt;loadsSynchronously())
 697         handleSubstituteDataLoadNow();
 698     else
 699         startDataLoadTimer();
 700 
 701     return true;
 702 }
 703 
 704 bool DocumentLoader::tryLoadingRedirectRequestFromApplicationCache(const ResourceRequest&amp; request)
 705 {
 706     m_applicationCacheHost-&gt;maybeLoadMainResourceForRedirect(request, m_substituteData);
 707     if (!m_substituteData.isValid())
 708         return false;
 709 
 710     RELEASE_ASSERT(m_mainResource);
 711     auto* loader = m_mainResource-&gt;loader();
 712     m_identifierForLoadWithoutResourceLoader = loader ? loader-&gt;identifier() : m_mainResource-&gt;identifierForLoadWithoutResourceLoader();
 713 
 714     // We need to remove our reference to the CachedResource in favor of a SubstituteData load, which can triger the cancellation of the underyling ResourceLoader.
 715     // If the ResourceLoader is indeed cancelled, it would normally send resource load callbacks.
 716     // Therefore, sever our relationship with the network load but prevent the ResourceLoader from sending ResourceLoadNotifier callbacks.
 717 
 718     auto resourceLoader = makeRefPtr(mainResourceLoader());
 719     if (resourceLoader) {
 720         ASSERT(resourceLoader-&gt;shouldSendResourceLoadCallbacks());
 721         resourceLoader-&gt;setSendCallbackPolicy(SendCallbackPolicy::DoNotSendCallbacks);
 722     }
 723 
 724     clearMainResource();
 725 
 726     if (resourceLoader)
 727         resourceLoader-&gt;setSendCallbackPolicy(SendCallbackPolicy::SendCallbacks);
 728 
 729     handleSubstituteDataLoadNow();
 730     return true;
 731 }
 732 
<a name="23" id="anc23"></a>













 733 void DocumentLoader::stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(unsigned long identifier, const ResourceResponse&amp; response)
 734 {
 735     Ref&lt;DocumentLoader&gt; protectedThis { *this };
 736     InspectorInstrumentation::continueAfterXFrameOptionsDenied(*m_frame, identifier, *this, response);
 737     m_frame-&gt;document()-&gt;enforceSandboxFlags(SandboxOrigin);
 738     if (HTMLFrameOwnerElement* ownerElement = m_frame-&gt;ownerElement())
 739         ownerElement-&gt;dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));
 740 
 741     // The load event might have detached this frame. In that case, the load will already have been cancelled during detach.
 742     if (FrameLoader* frameLoader = this-&gt;frameLoader())
 743         cancelMainResourceLoad(frameLoader-&gt;cancelledError(m_request));
 744 }
 745 
 746 void DocumentLoader::responseReceived(CachedResource&amp; resource, const ResourceResponse&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 747 {
 748     ASSERT_UNUSED(resource, m_mainResource == &amp;resource);
<a name="24" id="anc24"></a><span class="line-added"> 749 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-added"> 750     if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled() &amp;&amp; response.source() == ResourceResponse::Source::MemoryCache) {</span>
<span class="line-added"> 751         matchRegistration(response.url(), [this, protectedThis = makeRef(*this), response, completionHandler = WTFMove(completionHandler)](auto&amp;&amp; registrationData) mutable {</span>
<span class="line-added"> 752             if (!m_mainDocumentError.isNull() || !m_frame) {</span>
<span class="line-added"> 753                 completionHandler();</span>
<span class="line-added"> 754                 return;</span>
<span class="line-added"> 755             }</span>
<span class="line-added"> 756             m_serviceWorkerRegistrationData = WTFMove(registrationData);</span>
<span class="line-added"> 757             responseReceived(response, WTFMove(completionHandler));</span>
<span class="line-added"> 758         });</span>
<span class="line-added"> 759         return;</span>
<span class="line-added"> 760     }</span>
<span class="line-added"> 761 #endif</span>
 762     responseReceived(response, WTFMove(completionHandler));
 763 }
 764 
 765 void DocumentLoader::responseReceived(const ResourceResponse&amp; response, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
 766 {
<a name="25" id="anc25"></a><span class="line-added"> 767     ASSERT(response.certificateInfo());</span>
 768     CompletionHandlerCallingScope completionHandlerCaller(WTFMove(completionHandler));
 769 
 770 #if ENABLE(CONTENT_FILTERING)
 771     if (m_contentFilter &amp;&amp; !m_contentFilter-&gt;continueAfterResponseReceived(response))
 772         return;
 773 #endif
 774 
 775     Ref&lt;DocumentLoader&gt; protectedThis(*this);
 776     bool willLoadFallback = m_applicationCacheHost-&gt;maybeLoadFallbackForMainResponse(request(), response);
 777 
 778     // The memory cache doesn&#39;t understand the application cache or its caching rules. So if a main resource is served
 779     // from the application cache, ensure we don&#39;t save the result for future use.
 780     if (willLoadFallback)
 781         MemoryCache::singleton().remove(*m_mainResource);
 782 
 783     if (willLoadFallback)
 784         return;
 785 
 786     ASSERT(m_identifierForLoadWithoutResourceLoader || m_mainResource);
 787     unsigned long identifier = m_identifierForLoadWithoutResourceLoader ? m_identifierForLoadWithoutResourceLoader : m_mainResource-&gt;identifier();
 788     ASSERT(identifier);
 789 
 790     if (m_substituteData.isValid() || !platformStrategies()-&gt;loaderStrategy()-&gt;havePerformedSecurityChecks(response)) {
 791         auto url = response.url();
 792         ContentSecurityPolicy contentSecurityPolicy(URL { url }, this);
 793         contentSecurityPolicy.didReceiveHeaders(ContentSecurityPolicyResponseHeaders { response }, m_request.httpReferrer());
 794         if (!contentSecurityPolicy.allowFrameAncestors(*m_frame, url)) {
 795             stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(identifier, response);
 796             return;
 797         }
 798 
 799         if (!contentSecurityPolicy.overridesXFrameOptions()) {
 800             String frameOptions = response.httpHeaderFields().get(HTTPHeaderName::XFrameOptions);
 801             if (!frameOptions.isNull()) {
 802                 if (frameLoader()-&gt;shouldInterruptLoadForXFrameOptions(frameOptions, url, identifier)) {
 803                     String message = &quot;Refused to display &#39;&quot; + url.stringCenterEllipsizedToLength() + &quot;&#39; in a frame because it set &#39;X-Frame-Options&#39; to &#39;&quot; + frameOptions + &quot;&#39;.&quot;;
 804                     m_frame-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message, identifier);
 805                     stopLoadingAfterXFrameOptionsOrContentSecurityPolicyDenied(identifier, response);
 806                     return;
 807                 }
 808             }
 809         }
 810     }
 811 
 812     // There is a bug in CFNetwork where callbacks can be dispatched even when loads are deferred.
 813     // See &lt;rdar://problem/6304600&gt; for more details.
 814 #if !USE(CF)
 815     ASSERT(!mainResourceLoader() || !mainResourceLoader()-&gt;defersLoading());
 816 #endif
 817 
 818     if (m_isLoadingMultipartContent) {
 819         setupForReplace();
 820         m_mainResource-&gt;clear();
 821     } else if (response.isMultipart())
 822         m_isLoadingMultipartContent = true;
 823 
 824     m_response = response;
 825 
 826     if (m_identifierForLoadWithoutResourceLoader) {
 827         if (m_mainResource &amp;&amp; m_mainResource-&gt;wasRedirected()) {
 828             ASSERT(m_mainResource-&gt;status() == CachedResource::Status::Cached);
 829             frameLoader()-&gt;client().dispatchDidReceiveServerRedirectForProvisionalLoad();
 830         }
 831         addResponse(m_response);
 832         frameLoader()-&gt;notifier().dispatchDidReceiveResponse(this, m_identifierForLoadWithoutResourceLoader, m_response, 0);
 833     }
 834 
 835     ASSERT(!m_waitingForContentPolicy);
 836     ASSERT(frameLoader());
 837     m_waitingForContentPolicy = true;
 838 
 839     // Always show content with valid substitute data.
 840     if (m_substituteData.isValid()) {
 841         continueAfterContentPolicy(PolicyAction::Use);
 842         return;
 843     }
 844 
 845 #if ENABLE(FTPDIR)
 846     // Respect the hidden FTP Directory Listing pref so it can be tested even if the policy delegate might otherwise disallow it
 847     if (m_frame-&gt;settings().forceFTPDirectoryListings() &amp;&amp; m_response.mimeType() == &quot;application/x-ftp-directory&quot;) {
 848         continueAfterContentPolicy(PolicyAction::Use);
 849         return;
 850     }
 851 #endif
 852 
 853     RefPtr&lt;SubresourceLoader&gt; mainResourceLoader = this-&gt;mainResourceLoader();
 854     if (mainResourceLoader)
 855         mainResourceLoader-&gt;markInAsyncResponsePolicyCheck();
 856     auto requestIdentifier = PolicyCheckIdentifier::create();
 857     frameLoader()-&gt;checkContentPolicy(m_response, requestIdentifier, [this, protectedThis = makeRef(*this), mainResourceLoader = WTFMove(mainResourceLoader),
<a name="26" id="anc26"></a><span class="line-modified"> 858         completionHandler = completionHandlerCaller.release(), requestIdentifier] (PolicyAction policy, PolicyCheckIdentifier responseIdentifier) mutable {</span>
<span class="line-modified"> 859         RELEASE_ASSERT(responseIdentifier.isValidFor(requestIdentifier));</span>
 860         continueAfterContentPolicy(policy);
 861         if (mainResourceLoader)
 862             mainResourceLoader-&gt;didReceiveResponsePolicy();
 863         if (completionHandler)
 864             completionHandler();
 865     });
 866 }
 867 
 868 // Prevent web archives from loading if
 869 // 1) it is remote;
 870 // 2) it is not the main frame;
 871 // 3) it is not any of { loaded by clients; loaded by drag; reloaded from any of the previous two };
 872 // because they can claim to be from any domain and thus avoid cross-domain security checks (4120255, 45524528, 47610130).
 873 bool DocumentLoader::disallowWebArchive() const
 874 {
 875     using MIMETypeHashSet = HashSet&lt;String, ASCIICaseInsensitiveHash&gt;;
 876     static NeverDestroyed&lt;MIMETypeHashSet&gt; webArchiveMIMETypes {
 877         MIMETypeHashSet {
 878             &quot;application/x-webarchive&quot;_s,
 879             &quot;application/x-mimearchive&quot;_s,
 880             &quot;multipart/related&quot;_s,
 881 #if PLATFORM(GTK)
 882             &quot;message/rfc822&quot;_s,
 883 #endif
 884         }
 885     };
 886 
 887     String mimeType = m_response.mimeType();
 888     if (mimeType.isNull() || !webArchiveMIMETypes.get().contains(mimeType))
 889         return false;
 890 
 891 #if USE(QUICK_LOOK)
 892     if (isQuickLookPreviewURL(m_response.url()))
 893         return false;
 894 #endif
 895 
 896     if (m_substituteData.isValid())
 897         return false;
 898 
<a name="27" id="anc27"></a><span class="line-modified"> 899     if (!LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(m_request.url().protocol().toStringWithoutCopying()))</span>
 900         return true;
 901 
 902     if (!frame() || (frame()-&gt;isMainFrame() &amp;&amp; m_allowsWebArchiveForMainFrame))
 903         return false;
 904 
 905     // On purpose of maintaining existing tests.
 906     if (frame()-&gt;mainFrame().loader().alwaysAllowLocalWebarchive())
 907         return false;
 908     return true;
 909 }
 910 
<a name="28" id="anc28"></a><span class="line-added"> 911 // Prevent data URIs from loading as the main frame unless the result of user action.</span>
<span class="line-added"> 912 bool DocumentLoader::disallowDataRequest() const</span>
<span class="line-added"> 913 {</span>
<span class="line-added"> 914     if (!m_response.url().protocolIsData())</span>
<span class="line-added"> 915         return false;</span>
<span class="line-added"> 916 </span>
<span class="line-added"> 917     if (!frame() || !frame()-&gt;isMainFrame() || m_allowsDataURLsForMainFrame || frame()-&gt;settings().allowTopNavigationToDataURLs())</span>
<span class="line-added"> 918         return false;</span>
<span class="line-added"> 919 </span>
<span class="line-added"> 920     if (auto* currentDocument = frame()-&gt;document()) {</span>
<span class="line-added"> 921         unsigned long identifier = m_identifierForLoadWithoutResourceLoader ? m_identifierForLoadWithoutResourceLoader : m_mainResource-&gt;identifier();</span>
<span class="line-added"> 922         ASSERT(identifier);</span>
<span class="line-added"> 923 </span>
<span class="line-added"> 924         currentDocument-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, makeString(&quot;Not allowed to navigate top frame to data URL &#39;&quot;, m_response.url().stringCenterEllipsizedToLength(), &quot;&#39;.&quot;), identifier);</span>
<span class="line-added"> 925     }</span>
<span class="line-added"> 926     RELEASE_LOG_IF_ALLOWED(&quot;continueAfterContentPolicy: cannot show URL (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());</span>
<span class="line-added"> 927 </span>
<span class="line-added"> 928     return true;</span>
<span class="line-added"> 929 }</span>
<span class="line-added"> 930 </span>
 931 void DocumentLoader::continueAfterContentPolicy(PolicyAction policy)
 932 {
 933     ASSERT(m_waitingForContentPolicy);
 934     m_waitingForContentPolicy = false;
 935     if (isStopping())
 936         return;
 937 
<a name="29" id="anc29"></a><span class="line-added"> 938     if (!m_frame) {</span>
<span class="line-added"> 939         RELEASE_LOG_IF_ALLOWED(&quot;continueAfterContentPolicy: Policy action %i received by DocumentLoader with null frame&quot;, (int)policy);</span>
<span class="line-added"> 940         return;</span>
<span class="line-added"> 941     }</span>
<span class="line-added"> 942 </span>
 943     switch (policy) {
 944     case PolicyAction::Use: {
<a name="30" id="anc30"></a><span class="line-modified"> 945         if (!frameLoader()-&gt;client().canShowMIMEType(m_response.mimeType()) || disallowWebArchive() || disallowDataRequest()) {</span>
 946             frameLoader()-&gt;policyChecker().cannotShowMIMEType(m_response);
 947             // Check reachedTerminalState since the load may have already been canceled inside of _handleUnimplementablePolicyWithErrorCode::.
 948             stopLoadingForPolicyChange();
 949             return;
 950         }
 951         break;
 952     }
 953 
 954     case PolicyAction::Download: {
 955         // m_mainResource can be null, e.g. when loading a substitute resource from application cache.
 956         if (!m_mainResource) {
 957             RELEASE_LOG_IF_ALLOWED(&quot;continueAfterContentPolicy: cannot show URL (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
 958             mainReceivedError(frameLoader()-&gt;client().cannotShowURLError(m_request));
 959             return;
 960         }
 961 
 962         if (ResourceLoader* mainResourceLoader = this-&gt;mainResourceLoader())
 963             InspectorInstrumentation::continueWithPolicyDownload(*m_frame, mainResourceLoader-&gt;identifier(), *this, m_response);
 964 
 965         // When starting the request, we didn&#39;t know that it would result in download and not navigation. Now we know that main document URL didn&#39;t change.
 966         // Download may use this knowledge for purposes unrelated to cookies, notably for setting file quarantine data.
 967         frameLoader()-&gt;setOriginalURLForDownloadRequest(m_request);
 968 
<a name="31" id="anc31"></a>



 969         if (m_request.url().protocolIsData()) {
 970             // We decode data URL internally, there is no resource load to convert.
 971             frameLoader()-&gt;client().startDownload(m_request);
 972         } else
<a name="32" id="anc32"></a><span class="line-modified"> 973             frameLoader()-&gt;client().convertMainResourceLoadToDownload(this, m_request, m_response);</span>
 974 
 975         // The main resource might be loading from the memory cache, or its loader might have gone missing.
 976         if (mainResourceLoader()) {
 977             static_cast&lt;ResourceLoader*&gt;(mainResourceLoader())-&gt;didFail(interruptedForPolicyChangeError());
 978             return;
 979         }
 980 
 981         // We must stop loading even if there is no main resource loader. Otherwise, we might remain
 982         // the client of a CachedRawResource that will continue to send us data.
 983         stopLoadingForPolicyChange();
 984         return;
 985     }
 986     case PolicyAction::StopAllLoads:
 987         ASSERT_NOT_REACHED();
<a name="33" id="anc33"></a><span class="line-modified"> 988 #if !ASSERT_ENABLED</span>
 989         FALLTHROUGH;
 990 #endif
 991     case PolicyAction::Ignore:
 992         if (ResourceLoader* mainResourceLoader = this-&gt;mainResourceLoader())
 993             InspectorInstrumentation::continueWithPolicyIgnore(*m_frame, mainResourceLoader-&gt;identifier(), *this, m_response);
 994         stopLoadingForPolicyChange();
 995         return;
 996     }
 997 
 998     if (m_response.isHTTP()) {
 999         int status = m_response.httpStatusCode(); // Status may be zero when loading substitute data, in particular from a WebArchive.
1000         if (status &amp;&amp; (status &lt; 200 || status &gt;= 300)) {
1001             bool hostedByObject = frameLoader()-&gt;isHostedByObjectElement();
1002 
1003             frameLoader()-&gt;handleFallbackContent();
1004             // object elements are no longer rendered after we fallback, so don&#39;t
1005             // keep trying to process data from their load
1006 
1007             if (hostedByObject)
1008                 cancelMainResourceLoad(frameLoader()-&gt;cancelledError(m_request));
1009         }
1010     }
1011 
1012     if (!isStopping() &amp;&amp; m_substituteData.isValid() &amp;&amp; isLoadingMainResource()) {
1013         auto content = m_substituteData.content();
1014         if (content &amp;&amp; content-&gt;size())
1015             dataReceived(content-&gt;data(), content-&gt;size());
1016         if (isLoadingMainResource())
1017             finishedLoading();
1018 
1019         // Remove ourselves as a client of this CachedResource as we&#39;ve decided to commit substitute data but the
1020         // load may keep going and be useful to other clients of the CachedResource. If we did not do this, we
1021         // may receive data later on even though this DocumentLoader has finished loading.
1022         clearMainResource();
1023     }
1024 }
1025 
1026 void DocumentLoader::commitLoad(const char* data, int length)
1027 {
1028     // Both unloading the old page and parsing the new page may execute JavaScript which destroys the datasource
1029     // by starting a new load, so retain temporarily.
1030     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
1031     Ref&lt;DocumentLoader&gt; protectedThis(*this);
1032 
1033     commitIfReady();
1034     FrameLoader* frameLoader = DocumentLoader::frameLoader();
1035     if (!frameLoader)
1036         return;
1037 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1038     if (ArchiveFactory::isArchiveMIMEType(response().mimeType()))
1039         return;
1040 #endif
1041     frameLoader-&gt;client().committedLoad(this, data, length);
1042 
1043     if (isMultipartReplacingLoad())
1044         frameLoader-&gt;client().didReplaceMultipartContent();
1045 }
1046 
1047 ResourceError DocumentLoader::interruptedForPolicyChangeError() const
1048 {
1049     return frameLoader()-&gt;client().interruptedForPolicyChangeError(request());
1050 }
1051 
1052 void DocumentLoader::stopLoadingForPolicyChange()
1053 {
1054     ResourceError error = interruptedForPolicyChangeError();
1055     error.setType(ResourceError::Type::Cancellation);
1056     cancelMainResourceLoad(error);
1057 }
1058 
1059 #if ENABLE(SERVICE_WORKER)
<a name="34" id="anc34"></a><span class="line-modified">1060 // https://w3c.github.io/ServiceWorker/#control-and-use-window-client</span>
<span class="line-added">1061 static inline bool shouldUseActiveServiceWorkerFromParent(const Document&amp; document, const Document&amp; parent)</span>
1062 {
<a name="35" id="anc35"></a><span class="line-modified">1063     return !document.url().protocolIsInHTTPFamily() &amp;&amp; !document.securityOrigin().isUnique() &amp;&amp; parent.securityOrigin().canAccess(document.securityOrigin());</span>


1064 }
1065 #endif
1066 
1067 void DocumentLoader::commitData(const char* bytes, size_t length)
1068 {
1069     if (!m_gotFirstByte) {
1070         m_gotFirstByte = true;
1071         bool hasBegun = m_writer.begin(documentURL(), false);
1072         m_writer.setDocumentWasLoadedAsPartOfNavigation();
1073 
1074         if (SecurityPolicy::allowSubstituteDataAccessToLocal() &amp;&amp; m_originalSubstituteDataWasValid) {
1075             // If this document was loaded with substituteData, then the document can
1076             // load local resources. See https://bugs.webkit.org/show_bug.cgi?id=16756
1077             // and https://bugs.webkit.org/show_bug.cgi?id=19760 for further
1078             // discussion.
1079             m_frame-&gt;document()-&gt;securityOrigin().grantLoadLocalResources();
1080         }
1081 
1082         if (frameLoader()-&gt;stateMachine().creatingInitialEmptyDocument())
1083             return;
1084 
1085 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1086         if (m_archive &amp;&amp; m_archive-&gt;shouldOverrideBaseURL())
1087             m_frame-&gt;document()-&gt;setBaseURLOverride(m_archive-&gt;mainResource()-&gt;url());
1088 #endif
1089 #if ENABLE(SERVICE_WORKER)
1090         if (RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled()) {
1091             if (m_serviceWorkerRegistrationData &amp;&amp; m_serviceWorkerRegistrationData-&gt;activeWorker) {
1092                 m_frame-&gt;document()-&gt;setActiveServiceWorker(ServiceWorker::getOrCreate(*m_frame-&gt;document(), WTFMove(m_serviceWorkerRegistrationData-&gt;activeWorker.value())));
1093                 m_serviceWorkerRegistrationData = { };
<a name="36" id="anc36"></a><span class="line-modified">1094             } else if (auto* parent = m_frame-&gt;document()-&gt;parentDocument()) {</span>
<span class="line-modified">1095                 if (shouldUseActiveServiceWorkerFromParent(*m_frame-&gt;document(), *parent))</span>
1096                     m_frame-&gt;document()-&gt;setActiveServiceWorker(parent-&gt;activeServiceWorker());
1097             }
1098 
<a name="37" id="anc37"></a><span class="line-modified">1099             if (m_frame-&gt;document()-&gt;activeServiceWorker() || LegacySchemeRegistry::canServiceWorkersHandleURLScheme(m_frame-&gt;document()-&gt;url().protocol().toStringWithoutCopying()))</span>
<span class="line-modified">1100                 m_frame-&gt;document()-&gt;setServiceWorkerConnection(&amp;ServiceWorkerProvider::singleton().serviceWorkerConnection());</span>
1101 
1102             // We currently unregister the temporary service worker client since we now registered the real document.
1103             // FIXME: We should make the real document use the temporary client identifier.
1104             unregisterTemporaryServiceWorkerClient();
1105         }
1106 #endif
1107         // Call receivedFirstData() exactly once per load. We should only reach this point multiple times
1108         // for multipart loads, and FrameLoader::isReplacing() will be true after the first time.
1109         if (!isMultipartReplacingLoad())
1110             frameLoader()-&gt;receivedFirstData();
1111 
1112         // The load could be canceled under receivedFirstData(), which makes delegate calls and even sometimes dispatches DOM events.
1113         if (!isLoading())
1114             return;
1115 
1116         if (auto* window = m_frame-&gt;document()-&gt;domWindow())
1117             window-&gt;prewarmLocalStorageIfNecessary();
1118 
1119         bool userChosen;
1120         String encoding;
1121         if (overrideEncoding().isNull()) {
1122             userChosen = false;
1123             encoding = response().textEncodingName();
1124 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1125             if (m_archive &amp;&amp; m_archive-&gt;shouldUseMainResourceEncoding())
1126                 encoding = m_archive-&gt;mainResource()-&gt;textEncoding();
1127 #endif
1128         } else {
1129             userChosen = true;
1130             encoding = overrideEncoding();
1131         }
1132 
1133         m_writer.setEncoding(encoding, userChosen);
1134 
1135         RELEASE_ASSERT(hasBegun);
1136     }
1137 
1138 #if ENABLE(CONTENT_EXTENSIONS)
1139     auto&amp; extensionStyleSheets = m_frame-&gt;document()-&gt;extensionStyleSheets();
1140 
1141     for (auto&amp; pendingStyleSheet : m_pendingNamedContentExtensionStyleSheets)
1142         extensionStyleSheets.maybeAddContentExtensionSheet(pendingStyleSheet.key, *pendingStyleSheet.value);
1143     for (auto&amp; pendingSelectorEntry : m_pendingContentExtensionDisplayNoneSelectors) {
1144         for (const auto&amp; pendingSelector : pendingSelectorEntry.value)
1145             extensionStyleSheets.addDisplayNoneSelector(pendingSelectorEntry.key, pendingSelector.first, pendingSelector.second);
1146     }
1147 
1148     m_pendingNamedContentExtensionStyleSheets.clear();
1149     m_pendingContentExtensionDisplayNoneSelectors.clear();
1150 #endif
1151 
1152     ASSERT(m_frame-&gt;document()-&gt;parsing());
1153     m_writer.addData(bytes, length);
1154 }
1155 
1156 void DocumentLoader::dataReceived(CachedResource&amp; resource, const char* data, int length)
1157 {
1158     ASSERT_UNUSED(resource, &amp;resource == m_mainResource);
1159     dataReceived(data, length);
1160 }
1161 
1162 void DocumentLoader::dataReceived(const char* data, int length)
1163 {
1164 #if ENABLE(CONTENT_FILTERING)
1165     if (m_contentFilter &amp;&amp; !m_contentFilter-&gt;continueAfterDataReceived(data, length))
1166         return;
1167 #endif
1168 
1169     ASSERT(data);
1170     ASSERT(length);
1171     ASSERT(!m_response.isNull());
1172 
1173     // There is a bug in CFNetwork where callbacks can be dispatched even when loads are deferred.
1174     // See &lt;rdar://problem/6304600&gt; for more details.
1175 #if !USE(CF)
1176     ASSERT(!mainResourceLoader() || !mainResourceLoader()-&gt;defersLoading());
1177 #endif
1178 
1179     if (m_identifierForLoadWithoutResourceLoader)
1180         frameLoader()-&gt;notifier().dispatchDidReceiveData(this, m_identifierForLoadWithoutResourceLoader, data, length, -1);
1181 
1182     m_applicationCacheHost-&gt;mainResourceDataReceived(data, length, -1, false);
1183     m_timeOfLastDataReceived = MonotonicTime::now();
1184 
1185     if (!isMultipartReplacingLoad())
1186         commitLoad(data, length);
1187 }
1188 
1189 void DocumentLoader::setupForReplace()
1190 {
1191     if (!mainResourceData())
1192         return;
1193 
1194     frameLoader()-&gt;client().willReplaceMultipartContent();
1195 
1196     maybeFinishLoadingMultipartContent();
1197     maybeCreateArchive();
1198     m_writer.end();
1199     frameLoader()-&gt;setReplacing();
1200     m_gotFirstByte = false;
1201 
1202     stopLoadingSubresources();
1203     stopLoadingPlugIns();
1204 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1205     clearArchiveResources();
1206 #endif
1207 }
1208 
1209 void DocumentLoader::checkLoadComplete()
1210 {
1211     if (!m_frame || isLoading())
1212         return;
1213 
<a name="38" id="anc38"></a><span class="line-modified">1214     // ASSERT(this == frameLoader()-&gt;activeDocumentLoader());</span>
1215     m_frame-&gt;document()-&gt;domWindow()-&gt;finishedLoading();
1216 }
1217 
1218 void DocumentLoader::applyPoliciesToSettings()
1219 {
1220     if (!m_frame) {
1221         ASSERT_NOT_REACHED();
1222         return;
1223     }
1224 
1225     if (!m_frame-&gt;isMainFrame())
1226         return;
1227 
1228 #if ENABLE(MEDIA_SOURCE)
1229     m_frame-&gt;settings().setMediaSourceEnabled(m_mediaSourcePolicy == MediaSourcePolicy::Default ? Settings::platformDefaultMediaSourceEnabled() : m_mediaSourcePolicy == MediaSourcePolicy::Enable);
1230 #endif
1231 }
1232 
1233 void DocumentLoader::attachToFrame(Frame&amp; frame)
1234 {
1235     if (m_frame == &amp;frame)
1236         return;
1237 
1238     ASSERT(!m_frame);
1239     observeFrame(&amp;frame);
1240     m_writer.setFrame(frame);
1241     attachToFrame();
1242 
<a name="39" id="anc39"></a><span class="line-modified">1243 #if ASSERT_ENABLED</span>
1244     m_hasEverBeenAttached = true;
1245 #endif
1246 
1247     applyPoliciesToSettings();
1248 }
1249 
1250 void DocumentLoader::attachToFrame()
1251 {
1252     ASSERT(m_frame);
1253 }
1254 
1255 void DocumentLoader::detachFromFrame()
1256 {
<a name="40" id="anc40"></a><span class="line-modified">1257 #if ASSERT_ENABLED</span>
1258     if (m_hasEverBeenAttached)
1259         ASSERT_WITH_MESSAGE(m_frame, &quot;detachFromFrame() is being called on a DocumentLoader twice without an attachToFrame() inbetween&quot;);
1260     else
1261         ASSERT_WITH_MESSAGE(m_frame, &quot;detachFromFrame() is being called on a DocumentLoader that has never attached to any Frame&quot;);
1262 #endif
1263     RefPtr&lt;Frame&gt; protectedFrame(m_frame);
1264     Ref&lt;DocumentLoader&gt; protectedThis(*this);
1265 
1266     // It never makes sense to have a document loader that is detached from its
1267     // frame have any loads active, so kill all the loads.
1268     stopLoading();
1269     if (m_mainResource &amp;&amp; m_mainResource-&gt;hasClient(*this))
1270         m_mainResource-&gt;removeClient(*this);
1271 #if ENABLE(CONTENT_FILTERING)
1272     if (m_contentFilter)
1273         m_contentFilter-&gt;stopFilteringMainResource();
1274 #endif
1275 
1276     m_applicationCacheHost-&gt;setDOMApplicationCache(nullptr);
1277 
1278     cancelPolicyCheckIfNeeded();
1279 
1280     // cancelPolicyCheckIfNeeded can clear m_frame if the policy check
1281     // is stopped, resulting in a recursive call into this detachFromFrame.
1282     // If m_frame is nullptr after cancelPolicyCheckIfNeeded, our work is
1283     // already done so just return.
1284     if (!m_frame)
1285         return;
1286 
1287     InspectorInstrumentation::loaderDetachedFromFrame(*m_frame, *this);
1288 
1289     observeFrame(nullptr);
1290 }
1291 
1292 void DocumentLoader::clearMainResourceLoader()
1293 {
1294     m_loadingMainResource = false;
1295 
<a name="41" id="anc41"></a><span class="line-modified">1296     auto* frameLoader = this-&gt;frameLoader();</span>
<span class="line-added">1297 </span>
<span class="line-added">1298     if (!frameLoader)</span>
<span class="line-added">1299         return;</span>
<span class="line-added">1300 </span>
<span class="line-added">1301     if (this == frameLoader-&gt;activeDocumentLoader())</span>
1302         checkLoadComplete();
1303 }
1304 
1305 #if ENABLE(APPLICATION_MANIFEST)
1306 uint64_t DocumentLoader::loadApplicationManifest()
1307 {
1308     static uint64_t nextCallbackID = 1;
1309 
1310     auto* document = this-&gt;document();
1311     if (!document)
1312         return 0;
1313 
1314     if (!m_frame-&gt;isMainFrame())
1315         return 0;
1316 
1317     if (document-&gt;url().isEmpty() || document-&gt;url().protocolIsAbout())
1318         return 0;
1319 
1320     auto head = document-&gt;head();
1321     if (!head)
1322         return 0;
1323 
1324     URL manifestURL;
1325     bool useCredentials = false;
1326     for (const auto&amp; link : childrenOfType&lt;HTMLLinkElement&gt;(*head)) {
1327         if (link.isApplicationManifest()) {
1328             manifestURL = link.href();
1329             useCredentials = equalIgnoringASCIICase(link.attributeWithoutSynchronization(HTMLNames::crossoriginAttr), &quot;use-credentials&quot;);
1330             break;
1331         }
1332     }
1333 
1334     if (manifestURL.isEmpty() || !manifestURL.isValid())
1335         return 0;
1336 
1337     auto manifestLoader = makeUnique&lt;ApplicationManifestLoader&gt;(*this, manifestURL, useCredentials);
1338     auto* rawManifestLoader = manifestLoader.get();
1339     auto callbackID = nextCallbackID++;
1340     m_applicationManifestLoaders.set(WTFMove(manifestLoader), callbackID);
1341 
1342     if (!rawManifestLoader-&gt;startLoading()) {
1343         m_applicationManifestLoaders.remove(rawManifestLoader);
1344         return 0;
1345     }
1346 
1347     return callbackID;
1348 }
1349 
1350 void DocumentLoader::finishedLoadingApplicationManifest(ApplicationManifestLoader&amp; loader)
1351 {
1352     // If the DocumentLoader has detached from its frame, all manifest loads should have already been canceled.
1353     ASSERT(m_frame);
1354 
1355     auto callbackIdentifier = m_applicationManifestLoaders.get(&amp;loader);
1356     notifyFinishedLoadingApplicationManifest(callbackIdentifier, loader.processManifest());
1357     m_applicationManifestLoaders.remove(&amp;loader);
1358 }
1359 
1360 void DocumentLoader::notifyFinishedLoadingApplicationManifest(uint64_t callbackIdentifier, Optional&lt;ApplicationManifest&gt; manifest)
1361 {
1362     RELEASE_ASSERT(callbackIdentifier);
1363     RELEASE_ASSERT(m_frame);
1364     m_frame-&gt;loader().client().finishedLoadingApplicationManifest(callbackIdentifier, manifest);
1365 }
1366 #endif
1367 
1368 bool DocumentLoader::isLoadingInAPISense() const
1369 {
1370     // Once a frame has loaded, we no longer need to consider subresources,
1371     // but we still need to consider subframes.
1372     if (frameLoader()-&gt;state() != FrameStateComplete) {
1373         if (m_frame-&gt;settings().needsIsLoadingInAPISenseQuirk() &amp;&amp; !m_subresourceLoaders.isEmpty())
1374             return true;
1375 
1376         ASSERT(m_frame-&gt;document());
1377         auto&amp; document = *m_frame-&gt;document();
1378         if ((isLoadingMainResource() || !document.loadEventFinished()) &amp;&amp; isLoading())
1379             return true;
1380         if (m_cachedResourceLoader-&gt;requestCount())
1381             return true;
1382         if (document.isDelayingLoadEvent())
1383             return true;
1384         if (document.processingLoadEvent())
1385             return true;
1386         if (document.hasActiveParser())
1387             return true;
1388         auto* scriptableParser = document.scriptableDocumentParser();
1389         if (scriptableParser &amp;&amp; scriptableParser-&gt;hasScriptsWaitingForStylesheets())
1390             return true;
1391     }
1392     return frameLoader()-&gt;subframeIsLoading();
1393 }
1394 
1395 bool DocumentLoader::maybeCreateArchive()
1396 {
1397 #if !ENABLE(WEB_ARCHIVE) &amp;&amp; !ENABLE(MHTML)
1398     return false;
1399 #else
1400     // Give the archive machinery a crack at this document. If the MIME type is not an archive type, it will return 0.
1401     m_archive = ArchiveFactory::create(m_response.url(), mainResourceData().get(), m_response.mimeType());
1402     if (!m_archive)
1403         return false;
1404 
1405     addAllArchiveResources(*m_archive);
1406     ASSERT(m_archive-&gt;mainResource());
1407     auto&amp; mainResource = *m_archive-&gt;mainResource();
1408     m_parsedArchiveData = &amp;mainResource.data();
1409     m_writer.setMIMEType(mainResource.mimeType());
1410 
1411     ASSERT(m_frame-&gt;document());
1412     commitData(mainResource.data().data(), mainResource.data().size());
1413     return true;
1414 #endif
1415 }
1416 
1417 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1418 
1419 void DocumentLoader::setArchive(Ref&lt;Archive&gt;&amp;&amp; archive)
1420 {
1421     m_archive = WTFMove(archive);
1422     addAllArchiveResources(*m_archive);
1423 }
1424 
1425 void DocumentLoader::addAllArchiveResources(Archive&amp; archive)
1426 {
1427     if (!m_archiveResourceCollection)
1428         m_archiveResourceCollection = makeUnique&lt;ArchiveResourceCollection&gt;();
1429     m_archiveResourceCollection-&gt;addAllResources(archive);
1430 }
1431 
1432 // FIXME: Adding a resource directly to a DocumentLoader/ArchiveResourceCollection seems like bad design, but is API some apps rely on.
1433 // Can we change the design in a manner that will let us deprecate that API without reducing functionality of those apps?
1434 void DocumentLoader::addArchiveResource(Ref&lt;ArchiveResource&gt;&amp;&amp; resource)
1435 {
1436     if (!m_archiveResourceCollection)
1437         m_archiveResourceCollection = makeUnique&lt;ArchiveResourceCollection&gt;();
1438     m_archiveResourceCollection-&gt;addResource(WTFMove(resource));
1439 }
1440 
1441 RefPtr&lt;Archive&gt; DocumentLoader::popArchiveForSubframe(const String&amp; frameName, const URL&amp; url)
1442 {
1443     return m_archiveResourceCollection ? m_archiveResourceCollection-&gt;popSubframeArchive(frameName, url) : nullptr;
1444 }
1445 
1446 void DocumentLoader::clearArchiveResources()
1447 {
1448     m_archiveResourceCollection = nullptr;
1449     m_substituteResourceDeliveryTimer.stop();
1450 }
1451 
1452 SharedBuffer* DocumentLoader::parsedArchiveData() const
1453 {
1454     return m_parsedArchiveData.get();
1455 }
1456 
1457 #endif // ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1458 
1459 ArchiveResource* DocumentLoader::archiveResourceForURL(const URL&amp; url) const
1460 {
1461     if (!m_archiveResourceCollection)
1462         return nullptr;
1463     auto* resource = m_archiveResourceCollection-&gt;archiveResourceForURL(url);
1464     if (!resource || resource-&gt;shouldIgnoreWhenUnarchiving())
1465         return nullptr;
1466     return resource;
1467 }
1468 
1469 RefPtr&lt;ArchiveResource&gt; DocumentLoader::mainResource() const
1470 {
1471     RefPtr&lt;SharedBuffer&gt; data = mainResourceData();
1472     if (!data)
1473         data = SharedBuffer::create();
1474     auto&amp; response = this-&gt;response();
1475     return ArchiveResource::create(WTFMove(data), response.url(), response.mimeType(), response.textEncodingName(), frame()-&gt;tree().uniqueName());
1476 }
1477 
1478 RefPtr&lt;ArchiveResource&gt; DocumentLoader::subresource(const URL&amp; url) const
1479 {
1480     if (!isCommitted())
1481         return nullptr;
1482 
1483     auto* resource = m_cachedResourceLoader-&gt;cachedResource(url);
1484     if (!resource || !resource-&gt;isLoaded())
1485         return archiveResourceForURL(url);
1486 
1487     if (resource-&gt;type() == CachedResource::Type::MainResource)
1488         return nullptr;
1489 
1490     auto* data = resource-&gt;resourceBuffer();
1491     if (!data)
1492         return nullptr;
1493 
1494     return ArchiveResource::create(data, url, resource-&gt;response());
1495 }
1496 
1497 Vector&lt;Ref&lt;ArchiveResource&gt;&gt; DocumentLoader::subresources() const
1498 {
1499     if (!isCommitted())
1500         return { };
1501 
1502     Vector&lt;Ref&lt;ArchiveResource&gt;&gt; subresources;
1503     for (auto&amp; handle : m_cachedResourceLoader-&gt;allCachedResources().values()) {
1504         if (auto subresource = this-&gt;subresource({ { }, handle-&gt;url() }))
1505             subresources.append(subresource.releaseNonNull());
1506     }
1507     return subresources;
1508 }
1509 
1510 void DocumentLoader::deliverSubstituteResourcesAfterDelay()
1511 {
1512     if (m_pendingSubstituteResources.isEmpty())
1513         return;
1514     ASSERT(m_frame);
1515     ASSERT(m_frame-&gt;page());
1516     if (m_frame-&gt;page()-&gt;defersLoading())
1517         return;
1518 
1519     if (!m_substituteResourceDeliveryTimer.isActive())
1520         m_substituteResourceDeliveryTimer.startOneShot(0_s);
1521 }
1522 
1523 void DocumentLoader::substituteResourceDeliveryTimerFired()
1524 {
1525     if (m_pendingSubstituteResources.isEmpty())
1526         return;
1527     ASSERT(m_frame);
1528     ASSERT(m_frame-&gt;page());
1529     if (m_frame-&gt;page()-&gt;defersLoading())
1530         return;
1531 
1532     auto pendingSubstituteResources = WTFMove(m_pendingSubstituteResources);
1533     for (auto&amp; pendingSubstituteResource : pendingSubstituteResources) {
1534         auto&amp; loader = pendingSubstituteResource.key;
1535         if (auto&amp; resource = pendingSubstituteResource.value)
1536             resource-&gt;deliver(*loader);
1537         else {
1538             // A null resource means that we should fail the load.
1539             // FIXME: Maybe we should use another error here - something like &quot;not in cache&quot;.
1540             loader-&gt;didFail(loader-&gt;cannotShowURLError());
1541         }
1542     }
1543 }
1544 
<a name="42" id="anc42"></a><span class="line-modified">1545 #if ASSERT_ENABLED</span>
1546 
1547 bool DocumentLoader::isSubstituteLoadPending(ResourceLoader* loader) const
1548 {
1549     return m_pendingSubstituteResources.contains(loader);
1550 }
1551 
<a name="43" id="anc43"></a><span class="line-modified">1552 #endif // ASSERT_ENABLED</span>
1553 
1554 void DocumentLoader::cancelPendingSubstituteLoad(ResourceLoader* loader)
1555 {
1556     if (m_pendingSubstituteResources.isEmpty())
1557         return;
1558     m_pendingSubstituteResources.remove(loader);
1559     if (m_pendingSubstituteResources.isEmpty())
1560         m_substituteResourceDeliveryTimer.stop();
1561 }
1562 
1563 #if ENABLE(WEB_ARCHIVE) || ENABLE(MHTML)
1564 
1565 bool DocumentLoader::scheduleArchiveLoad(ResourceLoader&amp; loader, const ResourceRequest&amp; request)
1566 {
1567     if (auto* resource = archiveResourceForURL(request.url())) {
1568         scheduleSubstituteResourceLoad(loader, *resource);
1569         return true;
1570     }
1571 
1572     if (!m_archive)
1573         return false;
1574 
1575 #if ENABLE(WEB_ARCHIVE)
1576     // The idea of WebArchiveDebugMode is that we should fail instead of trying to fetch from the network.
1577     // Returning true ensures the caller will not try to fetch from the network.
1578     if (m_frame-&gt;settings().webArchiveDebugModeEnabled() &amp;&amp; responseMIMEType() == &quot;application/x-webarchive&quot;)
1579         return true;
1580 #endif
1581 
1582     // If we want to load from the archive only, then we should always return true so that the caller
1583     // does not try to fetch form the network.
1584     return m_archive-&gt;shouldLoadFromArchiveOnly();
1585 }
1586 
1587 #endif
1588 
1589 void DocumentLoader::scheduleSubstituteResourceLoad(ResourceLoader&amp; loader, SubstituteResource&amp; resource)
1590 {
1591 #if ENABLE(SERVICE_WORKER)
1592     ASSERT(!loader.options().serviceWorkerRegistrationIdentifier);
1593 #endif
1594     m_pendingSubstituteResources.set(&amp;loader, &amp;resource);
1595     deliverSubstituteResourcesAfterDelay();
1596 }
1597 
1598 void DocumentLoader::scheduleCannotShowURLError(ResourceLoader&amp; loader)
1599 {
1600     m_pendingSubstituteResources.set(&amp;loader, nullptr);
1601     deliverSubstituteResourcesAfterDelay();
1602 }
1603 
1604 void DocumentLoader::addResponse(const ResourceResponse&amp; response)
1605 {
1606     if (!m_stopRecordingResponses)
1607         m_responses.append(response);
1608 }
1609 
1610 void DocumentLoader::stopRecordingResponses()
1611 {
1612     m_stopRecordingResponses = true;
1613     m_responses.shrinkToFit();
1614 }
1615 
1616 void DocumentLoader::setCustomHeaderFields(Vector&lt;CustomHeaderFields&gt;&amp;&amp; fields)
1617 {
1618     m_customHeaderFields = WTFMove(fields);
1619 }
1620 
1621 void DocumentLoader::setTitle(const StringWithDirection&amp; title)
1622 {
1623     if (m_pageTitle == title)
1624         return;
1625 
1626     frameLoader()-&gt;willChangeTitle(this);
1627     m_pageTitle = title;
1628     frameLoader()-&gt;didChangeTitle(this);
1629 }
1630 
1631 URL DocumentLoader::urlForHistory() const
1632 {
1633     // Return the URL to be used for history and B/F list.
1634     // Returns nil for WebDataProtocol URLs that aren&#39;t alternates
1635     // for unreachable URLs, because these can&#39;t be stored in history.
1636     if (m_substituteData.isValid() &amp;&amp; !m_substituteData.shouldRevealToSessionHistory())
1637         return unreachableURL();
1638 
1639     return m_originalRequestCopy.url();
1640 }
1641 
1642 bool DocumentLoader::urlForHistoryReflectsFailure() const
1643 {
1644     return m_substituteData.isValid() || m_response.httpStatusCode() &gt;= 400;
1645 }
1646 
1647 URL DocumentLoader::documentURL() const
1648 {
1649     URL url = substituteData().response().url();
1650 #if ENABLE(WEB_ARCHIVE)
1651     if (url.isEmpty() &amp;&amp; m_archive &amp;&amp; m_archive-&gt;shouldUseMainResourceURL())
1652         url = m_archive-&gt;mainResource()-&gt;url();
1653 #endif
1654     if (url.isEmpty())
1655         url = m_request.url();
1656     if (url.isEmpty())
1657         url = m_response.url();
1658     return url;
1659 }
1660 
1661 #if PLATFORM(IOS_FAMILY)
1662 
1663 // FIXME: This method seems to violate the encapsulation of this class.
1664 void DocumentLoader::setResponseMIMEType(const String&amp; responseMimeType)
1665 {
1666     m_response.setMimeType(responseMimeType);
1667 }
1668 
1669 #endif
1670 
1671 void DocumentLoader::setDefersLoading(bool defers)
1672 {
1673     // Multiple frames may be loading the same main resource simultaneously. If deferral state changes,
1674     // each frame&#39;s DocumentLoader will try to send a setDefersLoading() to the same underlying ResourceLoader. Ensure only
1675     // the &quot;owning&quot; DocumentLoader does so, as setDefersLoading() is not resilient to setting the same value repeatedly.
1676     if (mainResourceLoader() &amp;&amp; mainResourceLoader()-&gt;documentLoader() == this)
1677         mainResourceLoader()-&gt;setDefersLoading(defers);
1678 
1679     setAllDefersLoading(m_subresourceLoaders, defers);
1680     setAllDefersLoading(m_plugInStreamLoaders, defers);
1681     if (!defers)
1682         deliverSubstituteResourcesAfterDelay();
1683 }
1684 
1685 void DocumentLoader::setMainResourceDataBufferingPolicy(DataBufferingPolicy dataBufferingPolicy)
1686 {
1687     if (m_mainResource)
1688         m_mainResource-&gt;setDataBufferingPolicy(dataBufferingPolicy);
1689 }
1690 
1691 void DocumentLoader::stopLoadingPlugIns()
1692 {
1693     cancelAll(m_plugInStreamLoaders);
1694 }
1695 
1696 void DocumentLoader::stopLoadingSubresources()
1697 {
1698     cancelAll(m_subresourceLoaders);
1699     ASSERT(m_subresourceLoaders.isEmpty());
1700 }
1701 
1702 void DocumentLoader::addSubresourceLoader(ResourceLoader* loader)
1703 {
1704     // The main resource&#39;s underlying ResourceLoader will ask to be added here.
1705     // It is much simpler to handle special casing of main resource loads if we don&#39;t
1706     // let it be added. In the main resource load case, mainResourceLoader()
1707     // will still be null at this point, but m_gotFirstByte should be false here if and only
1708     // if we are just starting the main resource load.
1709     if (!m_gotFirstByte)
1710         return;
1711     ASSERT(loader-&gt;identifier());
1712     ASSERT(!m_subresourceLoaders.contains(loader-&gt;identifier()));
1713     ASSERT(!mainResourceLoader() || mainResourceLoader() != loader);
1714 
1715     // Application Cache loaders are handled by their ApplicationCacheGroup directly.
1716     if (loader-&gt;options().applicationCacheMode == ApplicationCacheMode::Bypass)
1717         return;
1718 
<a name="44" id="anc44"></a><span class="line-modified">1719 #if ASSERT_ENABLED</span>
1720     if (document()) {
<a name="45" id="anc45"></a><span class="line-modified">1721         switch (document()-&gt;backForwardCacheState()) {</span>
<span class="line-modified">1722         case Document::NotInBackForwardCache:</span>
1723             break;
<a name="46" id="anc46"></a><span class="line-modified">1724         case Document::AboutToEnterBackForwardCache: {</span>
<span class="line-modified">1725             // A page about to enter the BackForwardCache should only be able to start ping loads.</span>
1726             auto* cachedResource = MemoryCache::singleton().resourceForRequest(loader-&gt;request(), loader-&gt;frameLoader()-&gt;frame().page()-&gt;sessionID());
1727             ASSERT(cachedResource &amp;&amp; CachedResource::shouldUsePingLoad(cachedResource-&gt;type()));
1728             break;
1729         }
<a name="47" id="anc47"></a><span class="line-modified">1730         case Document::InBackForwardCache:</span>
<span class="line-modified">1731             // A page in the BackForwardCache should not be able to start loads.</span>
1732             ASSERT_NOT_REACHED();
1733             break;
1734         }
1735     }
1736 #endif
1737 
1738     m_subresourceLoaders.add(loader-&gt;identifier(), loader);
1739 }
1740 
1741 void DocumentLoader::removeSubresourceLoader(LoadCompletionType type, ResourceLoader* loader)
1742 {
1743     ASSERT(loader-&gt;identifier());
1744 
1745     if (!m_subresourceLoaders.remove(loader-&gt;identifier()))
1746         return;
1747     checkLoadComplete();
1748     if (Frame* frame = m_frame)
1749         frame-&gt;loader().subresourceLoadDone(type);
1750 }
1751 
1752 void DocumentLoader::addPlugInStreamLoader(ResourceLoader&amp; loader)
1753 {
1754     ASSERT(loader.identifier());
1755     ASSERT(!m_plugInStreamLoaders.contains(loader.identifier()));
1756 
1757     m_plugInStreamLoaders.add(loader.identifier(), &amp;loader);
1758 }
1759 
1760 void DocumentLoader::removePlugInStreamLoader(ResourceLoader&amp; loader)
1761 {
1762     ASSERT(loader.identifier());
1763     ASSERT(&amp;loader == m_plugInStreamLoaders.get(loader.identifier()));
1764 
1765     m_plugInStreamLoaders.remove(loader.identifier());
1766     checkLoadComplete();
1767 }
1768 
1769 bool DocumentLoader::isMultipartReplacingLoad() const
1770 {
1771     return isLoadingMultipartContent() &amp;&amp; frameLoader()-&gt;isReplacing();
1772 }
1773 
1774 bool DocumentLoader::maybeLoadEmpty()
1775 {
<a name="48" id="anc48"></a><span class="line-modified">1776     bool shouldLoadEmpty = !m_substituteData.isValid() &amp;&amp; (m_request.url().isEmpty() || LegacySchemeRegistry::shouldLoadURLSchemeAsEmptyDocument(m_request.url().protocol().toStringWithoutCopying()));</span>
1777     if (!shouldLoadEmpty &amp;&amp; !frameLoader()-&gt;client().representationExistsForURLScheme(m_request.url().protocol().toStringWithoutCopying()))
1778         return false;
1779 
1780     if (m_request.url().isEmpty() &amp;&amp; !frameLoader()-&gt;stateMachine().creatingInitialEmptyDocument()) {
1781         m_request.setURL(WTF::blankURL());
1782         if (isLoadingMainResource())
1783             frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();
1784     }
1785 
1786     String mimeType = shouldLoadEmpty ? &quot;text/html&quot; : frameLoader()-&gt;client().generatedMIMETypeForURLScheme(m_request.url().protocol().toStringWithoutCopying());
1787     m_response = ResourceResponse(m_request.url(), mimeType, 0, String());
1788     finishedLoading();
1789     return true;
1790 }
1791 
1792 void DocumentLoader::startLoadingMainResource()
1793 {
1794     m_mainDocumentError = ResourceError();
1795     timing().markStartTimeAndFetchStart();
1796     ASSERT(!m_mainResource);
1797     ASSERT(!m_loadingMainResource);
1798     m_loadingMainResource = true;
1799 
1800     Ref&lt;DocumentLoader&gt; protectedThis(*this);
1801 
1802     if (maybeLoadEmpty()) {
1803         RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Returning empty document (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);
1804         return;
1805     }
1806 
1807 #if ENABLE(CONTENT_FILTERING)
1808     m_contentFilter = !m_substituteData.isValid() ? ContentFilter::create(*this) : nullptr;
1809 #endif
1810 
1811     // Make sure we re-apply the user agent to the Document&#39;s ResourceRequest upon reload in case the embedding
1812     // application has changed it.
1813     m_request.clearHTTPUserAgent();
1814     frameLoader()-&gt;addExtraFieldsToMainResourceRequest(m_request);
1815 
1816     ASSERT(timing().startTime());
1817     ASSERT(timing().fetchStart());
1818 
1819     willSendRequest(ResourceRequest(m_request), ResourceResponse(), [this, protectedThis = WTFMove(protectedThis)] (ResourceRequest&amp;&amp; request) mutable {
1820         m_request = request;
<a name="49" id="anc49"></a><span class="line-added">1821         // FIXME: Implement local URL interception by getting the service worker of the parent.</span>
1822 
1823         // willSendRequest() may lead to our Frame being detached or cancelling the load via nulling the ResourceRequest.
1824         if (!m_frame || m_request.isNull()) {
1825             RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Load canceled after willSendRequest (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);
1826             return;
1827         }
1828 
1829         request.setRequester(ResourceRequest::Requester::Main);
1830         // If this is a reload the cache layer might have made the previous request conditional. DocumentLoader can&#39;t handle 304 responses itself.
1831         request.makeUnconditional();
1832 
1833         RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Starting load (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1834 
1835 #if ENABLE(SERVICE_WORKER)
<a name="50" id="anc50"></a><span class="line-modified">1836         if (m_applicationCacheHost-&gt;canLoadMainResource(request) || m_substituteData.isValid()) {</span>
<span class="line-modified">1837             auto url = request.url();</span>
<span class="line-modified">1838             matchRegistration(url, [request = WTFMove(request), protectedThis = WTFMove(protectedThis), this] (auto&amp;&amp; registrationData) mutable {</span>
<span class="line-modified">1839                 if (!m_mainDocumentError.isNull() || !m_frame) {</span>
<span class="line-modified">1840                     RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource callback: Load canceled because of main document error (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);</span>
<span class="line-modified">1841                     return;</span>
<span class="line-modified">1842                 }</span>
1843 
<a name="51" id="anc51"></a><span class="line-modified">1844                 m_serviceWorkerRegistrationData = WTFMove(registrationData);</span>
<span class="line-added">1845                 // Prefer existing substitute data (from WKWebView.loadData etc) over service worker fetch.</span>
<span class="line-added">1846                 if (this-&gt;tryLoadingSubstituteData()) {</span>
<span class="line-added">1847                     RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource callback: Load canceled because of substitute data (frame = %p, main = %d)&quot;, m_frame, m_frame ? m_frame-&gt;isMainFrame() : false);</span>
<span class="line-added">1848                     return;</span>
<span class="line-added">1849                 }</span>
1850 
<a name="52" id="anc52"></a><span class="line-modified">1851                 if (!m_serviceWorkerRegistrationData &amp;&amp; this-&gt;tryLoadingRequestFromApplicationCache()) {</span>
<span class="line-modified">1852                     RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource callback: Loaded from Application Cache (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());</span>
<span class="line-modified">1853                     return;</span>
<span class="line-modified">1854                 }</span>
<span class="line-modified">1855                 this-&gt;loadMainResource(WTFMove(request));</span>
<span class="line-modified">1856             });</span>
<span class="line-modified">1857             return;</span>
<span class="line-modified">1858         }</span>




1859 #else
1860         if (tryLoadingRequestFromApplicationCache()) {
1861             RELEASE_LOG_IF_ALLOWED(&quot;startLoadingMainResource: Loaded from Application Cache (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1862             return;
1863         }
<a name="53" id="anc53"></a>
1864 #endif
<a name="54" id="anc54"></a><span class="line-added">1865         loadMainResource(WTFMove(request));</span>
1866     });
1867 }
1868 
<a name="55" id="anc55"></a>




























1869 void DocumentLoader::unregisterTemporaryServiceWorkerClient()
1870 {
1871 #if ENABLE(SERVICE_WORKER)
<a name="56" id="anc56"></a><span class="line-modified">1872     if (!m_temporaryServiceWorkerClient || !RuntimeEnabledFeatures::sharedFeatures().serviceWorkerEnabled())</span>
1873         return;
1874 
<a name="57" id="anc57"></a><span class="line-modified">1875     auto&amp; serviceWorkerConnection = ServiceWorkerProvider::singleton().serviceWorkerConnection();</span>
<span class="line-modified">1876     serviceWorkerConnection.unregisterServiceWorkerClient(*m_temporaryServiceWorkerClient);</span>

1877 #endif
1878 }
1879 
1880 void DocumentLoader::loadMainResource(ResourceRequest&amp;&amp; request)
1881 {
<a name="58" id="anc58"></a><span class="line-modified">1882     ResourceLoaderOptions mainResourceLoadOptions(</span>
1883         SendCallbackPolicy::SendCallbacks,
1884         ContentSniffingPolicy::SniffContent,
1885         DataBufferingPolicy::BufferData,
1886         StoredCredentialsPolicy::Use,
1887         ClientCredentialPolicy::MayAskClientForCredentials,
1888         FetchOptions::Credentials::Include,
1889         SecurityCheckPolicy::SkipSecurityCheck,
1890         FetchOptions::Mode::Navigate,
1891         CertificateInfoPolicy::IncludeCertificateInfo,
1892         ContentSecurityPolicyImposition::SkipPolicyCheck,
1893         DefersLoadingPolicy::AllowDefersLoading,
1894         CachingPolicy::AllowCaching);
<a name="59" id="anc59"></a><span class="line-added">1895 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-added">1896     if (!m_temporaryServiceWorkerClient) {</span>
<span class="line-added">1897         // The main navigation load will trigger the registration of the temp client.</span>
<span class="line-added">1898         m_temporaryServiceWorkerClient = DocumentIdentifier::generate();</span>
<span class="line-added">1899         ASSERT(!temporaryIdentifierToLoaderMap().contains(*m_temporaryServiceWorkerClient));</span>
<span class="line-added">1900         temporaryIdentifierToLoaderMap().add(*m_temporaryServiceWorkerClient, this);</span>
<span class="line-added">1901     }</span>
<span class="line-added">1902     mainResourceLoadOptions.clientIdentifier = m_temporaryServiceWorkerClient;</span>
<span class="line-added">1903 #endif</span>
1904     CachedResourceRequest mainResourceRequest(WTFMove(request), mainResourceLoadOptions);
1905     if (!m_frame-&gt;isMainFrame() &amp;&amp; m_frame-&gt;document()) {
1906         // If we are loading the main resource of a subframe, use the cache partition of the main document.
1907         mainResourceRequest.setDomainForCachePartition(*m_frame-&gt;document());
1908     } else {
1909         auto origin = SecurityOrigin::create(mainResourceRequest.resourceRequest().url());
1910         origin-&gt;setStorageBlockingPolicy(frameLoader()-&gt;frame().settings().storageBlockingPolicy());
1911         mainResourceRequest.setDomainForCachePartition(origin-&gt;domainForCachePartition());
1912     }
1913 
<a name="60" id="anc60"></a>








1914     m_mainResource = m_cachedResourceLoader-&gt;requestMainResource(WTFMove(mainResourceRequest)).value_or(nullptr);
1915 
1916     if (!m_mainResource) {
1917         // The frame may have gone away if this load was cancelled synchronously and this was the last pending load.
1918         // This is because we may have fired the load event in a parent frame.
1919         if (!m_frame) {
1920             RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, frame has gone away (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1921             return;
1922         }
1923 
1924         if (!m_request.url().isValid()) {
1925             RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, URL is invalid (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1926             cancelMainResourceLoad(frameLoader()-&gt;client().cannotShowURLError(m_request));
1927             return;
1928         }
1929 
1930         RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Unable to load main resource, returning empty document (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1931 
1932         setRequest(ResourceRequest());
1933         // If the load was aborted by clearing m_request, it&#39;s possible the ApplicationCacheHost
1934         // is now in a state where starting an empty load will be inconsistent. Replace it with
1935         // a new ApplicationCacheHost.
1936         m_applicationCacheHost = makeUnique&lt;ApplicationCacheHost&gt;(*this);
1937         maybeLoadEmpty();
1938         return;
1939     }
1940 
1941     ASSERT(m_frame);
1942 
1943 #if ENABLE(CONTENT_EXTENSIONS)
1944     if (m_mainResource-&gt;errorOccurred() &amp;&amp; m_frame-&gt;page() &amp;&amp; m_mainResource-&gt;resourceError().domain() == ContentExtensions::WebKitContentBlockerDomain) {
1945         RELEASE_LOG_IF_ALLOWED(&quot;loadMainResource: Blocked by content blocker error (frame = %p, main = %d)&quot;, m_frame, m_frame-&gt;isMainFrame());
1946         cancelMainResourceLoad(frameLoader()-&gt;blockedByContentBlockerError(m_request));
1947         return;
1948     }
1949 #endif
1950 
1951     if (!mainResourceLoader()) {
1952         m_identifierForLoadWithoutResourceLoader = m_frame-&gt;page()-&gt;progress().createUniqueIdentifier();
1953         frameLoader()-&gt;notifier().assignIdentifierToInitialRequest(m_identifierForLoadWithoutResourceLoader, this, mainResourceRequest.resourceRequest());
1954         frameLoader()-&gt;notifier().dispatchWillSendRequest(this, m_identifierForLoadWithoutResourceLoader, mainResourceRequest.resourceRequest(), ResourceResponse());
1955     }
1956 
1957     becomeMainResourceClient();
1958 
1959     // A bunch of headers are set when the underlying ResourceLoader is created, and m_request needs to include those.
1960     ResourceRequest updatedRequest = mainResourceLoader() ? mainResourceLoader()-&gt;originalRequest() : mainResourceRequest.resourceRequest();
1961     // If there was a fragment identifier on m_request, the cache will have stripped it. m_request should include
1962     // the fragment identifier, so add that back in.
1963     if (equalIgnoringFragmentIdentifier(m_request.url(), updatedRequest.url()))
1964         updatedRequest.setURL(m_request.url());
1965     setRequest(updatedRequest);
1966 }
1967 
1968 void DocumentLoader::cancelPolicyCheckIfNeeded()
1969 {
1970     if (m_waitingForContentPolicy || m_waitingForNavigationPolicy) {
1971         RELEASE_ASSERT(frameLoader());
1972         frameLoader()-&gt;policyChecker().stopCheck();
1973         m_waitingForContentPolicy = false;
1974         m_waitingForNavigationPolicy = false;
1975     }
1976 }
1977 
1978 void DocumentLoader::cancelMainResourceLoad(const ResourceError&amp; resourceError)
1979 {
1980     Ref&lt;DocumentLoader&gt; protectedThis(*this);
1981     ResourceError error = resourceError.isNull() ? frameLoader()-&gt;cancelledError(m_request) : resourceError;
1982 
1983     RELEASE_LOG_IF_ALLOWED(&quot;cancelMainResourceLoad: (frame = %p, main = %d, type = %d, code = %d)&quot;, m_frame, m_frame-&gt;isMainFrame(), static_cast&lt;int&gt;(error.type()), error.errorCode());
1984 
1985     m_dataLoadTimer.stop();
1986 
1987     cancelPolicyCheckIfNeeded();
1988 
1989     if (mainResourceLoader())
1990         mainResourceLoader()-&gt;cancel(error);
1991 
1992     clearMainResource();
1993 
1994     mainReceivedError(error);
1995 }
1996 
1997 void DocumentLoader::willContinueMainResourceLoadAfterRedirect(const ResourceRequest&amp; newRequest)
1998 {
1999     setRequest(newRequest);
2000 }
2001 
2002 void DocumentLoader::clearMainResource()
2003 {
2004     ASSERT(isMainThread());
2005     if (m_mainResource &amp;&amp; m_mainResource-&gt;hasClient(*this))
2006         m_mainResource-&gt;removeClient(*this);
2007 #if ENABLE(CONTENT_FILTERING)
2008     if (m_contentFilter)
2009         m_contentFilter-&gt;stopFilteringMainResource();
2010 #endif
2011 
2012     m_mainResource = nullptr;
2013 
2014     unregisterTemporaryServiceWorkerClient();
2015 }
2016 
2017 void DocumentLoader::subresourceLoaderFinishedLoadingOnePart(ResourceLoader* loader)
2018 {
2019     unsigned long identifier = loader-&gt;identifier();
2020     ASSERT(identifier);
2021 
2022     if (!m_multipartSubresourceLoaders.add(identifier, loader).isNewEntry) {
2023         ASSERT(m_multipartSubresourceLoaders.get(identifier) == loader);
2024         ASSERT(!m_subresourceLoaders.contains(identifier));
2025     } else {
2026         ASSERT(m_subresourceLoaders.contains(identifier));
2027         m_subresourceLoaders.remove(identifier);
2028     }
2029 
2030     checkLoadComplete();
2031     if (Frame* frame = m_frame)
2032         frame-&gt;loader().checkLoadComplete();
2033 }
2034 
2035 void DocumentLoader::maybeFinishLoadingMultipartContent()
2036 {
2037     if (!isMultipartReplacingLoad())
2038         return;
2039 
2040     frameLoader()-&gt;setupForReplace();
2041     m_committed = false;
2042     RefPtr&lt;SharedBuffer&gt; resourceData = mainResourceData();
2043     commitLoad(resourceData-&gt;data(), resourceData-&gt;size());
2044 }
2045 
2046 void DocumentLoader::startIconLoading()
2047 {
2048     static uint64_t nextIconCallbackID = 1;
2049 
2050     auto* document = this-&gt;document();
2051     if (!document)
2052         return;
2053 
2054     if (!m_frame-&gt;isMainFrame())
2055         return;
2056 
2057     if (document-&gt;url().isEmpty() || document-&gt;url().protocolIsAbout())
2058         return;
2059 
2060     m_linkIcons = LinkIconCollector { *document }.iconsOfTypes({ LinkIconType::Favicon, LinkIconType::TouchIcon, LinkIconType::TouchPrecomposedIcon });
2061 
2062     auto findResult = m_linkIcons.findMatching([](auto&amp; icon) { return icon.type == LinkIconType::Favicon; });
2063     if (findResult == notFound)
2064         m_linkIcons.append({ document-&gt;completeURL(&quot;/favicon.ico&quot;_s), LinkIconType::Favicon, String(), WTF::nullopt, { } });
2065 
2066     if (!m_linkIcons.size())
2067         return;
2068 
2069     Vector&lt;std::pair&lt;WebCore::LinkIcon&amp;, uint64_t&gt;&gt; iconDecisions;
2070     iconDecisions.reserveInitialCapacity(m_linkIcons.size());
2071     for (auto&amp; icon : m_linkIcons) {
2072         auto result = m_iconsPendingLoadDecision.add(nextIconCallbackID++, icon);
2073         iconDecisions.uncheckedAppend({ icon, result.iterator-&gt;key });
2074     }
2075 
2076     m_frame-&gt;loader().client().getLoadDecisionForIcons(iconDecisions);
2077 }
2078 
2079 void DocumentLoader::didGetLoadDecisionForIcon(bool decision, uint64_t loadIdentifier, uint64_t newCallbackID)
2080 {
2081     auto icon = m_iconsPendingLoadDecision.take(loadIdentifier);
2082 
2083     // If the decision was not to load or this DocumentLoader is already detached, there is no load to perform.
2084     if (!decision || !m_frame)
2085         return;
2086 
2087     // If the LinkIcon we just took is empty, then the DocumentLoader had all of its loaders stopped
2088     // while this icon load decision was pending.
2089     // In this case we need to notify the client that the icon finished loading with empty data.
2090     if (icon.url.isEmpty()) {
2091         notifyFinishedLoadingIcon(newCallbackID, nullptr);
2092         return;
2093     }
2094 
2095     auto iconLoader = makeUnique&lt;IconLoader&gt;(*this, icon.url);
2096     auto* rawIconLoader = iconLoader.get();
2097     m_iconLoaders.set(WTFMove(iconLoader), newCallbackID);
2098 
2099     rawIconLoader-&gt;startLoading();
2100 }
2101 
2102 void DocumentLoader::finishedLoadingIcon(IconLoader&amp; loader, SharedBuffer* buffer)
2103 {
2104     // If the DocumentLoader has detached from its frame, all icon loads should have already been cancelled.
2105     ASSERT(m_frame);
2106 
2107     auto callbackIdentifier = m_iconLoaders.take(&amp;loader);
2108     notifyFinishedLoadingIcon(callbackIdentifier, buffer);
2109 }
2110 
2111 void DocumentLoader::notifyFinishedLoadingIcon(uint64_t callbackIdentifier, SharedBuffer* buffer)
2112 {
2113     RELEASE_ASSERT(callbackIdentifier);
2114     RELEASE_ASSERT(m_frame);
2115     m_frame-&gt;loader().client().finishedLoadingIcon(callbackIdentifier, buffer);
2116 }
2117 
2118 void DocumentLoader::dispatchOnloadEvents()
2119 {
2120     m_wasOnloadDispatched = true;
2121     m_applicationCacheHost-&gt;stopDeferringEvents();
2122 }
2123 
2124 void DocumentLoader::setTriggeringAction(NavigationAction&amp;&amp; action)
2125 {
2126     m_triggeringAction = WTFMove(action);
2127     m_triggeringAction.setShouldOpenExternalURLsPolicy(m_frame ? shouldOpenExternalURLsPolicyToPropagate() : m_shouldOpenExternalURLsPolicy);
2128 }
2129 
2130 ShouldOpenExternalURLsPolicy DocumentLoader::shouldOpenExternalURLsPolicyToPropagate() const
2131 {
2132     if (!m_frame)
2133         return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
2134 
2135     if (m_frame-&gt;isMainFrame())
2136         return m_shouldOpenExternalURLsPolicy;
2137 
2138     if (auto* currentDocument = document()) {
2139         if (currentDocument-&gt;securityOrigin().isSameOriginAs(currentDocument-&gt;topOrigin()))
2140             return m_shouldOpenExternalURLsPolicy;
2141     }
2142 
2143     return ShouldOpenExternalURLsPolicy::ShouldNotAllow;
2144 }
2145 
2146 void DocumentLoader::becomeMainResourceClient()
2147 {
2148 #if ENABLE(CONTENT_FILTERING)
2149     if (m_contentFilter)
2150         m_contentFilter-&gt;startFilteringMainResource(*m_mainResource);
2151 #endif
2152     m_mainResource-&gt;addClient(*this);
2153 }
2154 
2155 #if ENABLE(CONTENT_EXTENSIONS)
2156 void DocumentLoader::addPendingContentExtensionSheet(const String&amp; identifier, StyleSheetContents&amp; sheet)
2157 {
2158     ASSERT(!m_gotFirstByte);
2159     m_pendingNamedContentExtensionStyleSheets.set(identifier, &amp;sheet);
2160 }
2161 
2162 void DocumentLoader::addPendingContentExtensionDisplayNoneSelector(const String&amp; identifier, const String&amp; selector, uint32_t selectorID)
2163 {
2164     ASSERT(!m_gotFirstByte);
2165     auto addResult = m_pendingContentExtensionDisplayNoneSelectors.add(identifier, Vector&lt;std::pair&lt;String, uint32_t&gt;&gt;());
2166     addResult.iterator-&gt;value.append(std::make_pair(selector, selectorID));
2167 }
2168 #endif
2169 
2170 bool DocumentLoader::isAlwaysOnLoggingAllowed() const
2171 {
2172     return !m_frame || m_frame-&gt;isAlwaysOnLoggingAllowed();
2173 }
2174 
2175 #if USE(QUICK_LOOK)
2176 
<a name="61" id="anc61"></a><span class="line-modified">2177 void DocumentLoader::previewResponseReceived(CachedResource&amp; resource, const ResourceResponse&amp; response)</span>
<span class="line-added">2178 {</span>
<span class="line-added">2179     ASSERT_UNUSED(resource, m_mainResource == &amp;resource);</span>
<span class="line-added">2180     m_response = response;</span>
<span class="line-added">2181 }</span>
<span class="line-added">2182 </span>
<span class="line-added">2183 void DocumentLoader::setPreviewConverter(RefPtr&lt;PreviewConverter&gt;&amp;&amp; previewConverter)</span>
2184 {
2185     m_previewConverter = WTFMove(previewConverter);
2186 }
2187 
2188 PreviewConverter* DocumentLoader::previewConverter() const
2189 {
2190     return m_previewConverter.get();
2191 }
2192 
2193 #endif
2194 
2195 void DocumentLoader::addConsoleMessage(MessageSource messageSource, MessageLevel messageLevel, const String&amp; message, unsigned long requestIdentifier)
2196 {
2197     static_cast&lt;ScriptExecutionContext*&gt;(m_frame-&gt;document())-&gt;addConsoleMessage(messageSource, messageLevel, message, requestIdentifier);
2198 }
2199 
2200 void DocumentLoader::sendCSPViolationReport(URL&amp;&amp; reportURL, Ref&lt;FormData&gt;&amp;&amp; report)
2201 {
2202     PingLoader::sendViolationReport(*m_frame, WTFMove(reportURL), WTFMove(report), ViolationReportType::ContentSecurityPolicy);
2203 }
2204 
2205 void DocumentLoader::enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp; eventInit)
2206 {
2207     m_frame-&gt;document()-&gt;enqueueSecurityPolicyViolationEvent(WTFMove(eventInit));
2208 }
2209 
<a name="62" id="anc62"></a><span class="line-added">2210 #if ENABLE(CONTENT_FILTERING)</span>
<span class="line-added">2211 void DocumentLoader::dataReceivedThroughContentFilter(const char* data, int size)</span>
<span class="line-added">2212 {</span>
<span class="line-added">2213     dataReceived(data, size);</span>
<span class="line-added">2214 }</span>
<span class="line-added">2215 </span>
<span class="line-added">2216 void DocumentLoader::cancelMainResourceLoadForContentFilter(const ResourceError&amp; error)</span>
<span class="line-added">2217 {</span>
<span class="line-added">2218     cancelMainResourceLoad(error);</span>
<span class="line-added">2219 }</span>
<span class="line-added">2220 </span>
<span class="line-added">2221 void DocumentLoader::handleProvisionalLoadFailureFromContentFilter(const URL&amp; blockedPageURL, SubstituteData&amp; substituteData)</span>
<span class="line-added">2222 {</span>
<span class="line-added">2223     frameLoader()-&gt;load(FrameLoadRequest(*frame(), blockedPageURL, ShouldOpenExternalURLsPolicy::ShouldNotAllow, substituteData));</span>
<span class="line-added">2224 }</span>
<span class="line-added">2225 </span>
<span class="line-added">2226 ResourceError DocumentLoader::contentFilterDidBlock(ContentFilterUnblockHandler unblockHandler, WTF::String&amp;&amp; unblockRequestDeniedScript)</span>
<span class="line-added">2227 {</span>
<span class="line-added">2228     unblockHandler.setUnreachableURL(documentURL());</span>
<span class="line-added">2229     if (!unblockRequestDeniedScript.isEmpty() &amp;&amp; frame()) {</span>
<span class="line-added">2230         unblockHandler.wrapWithDecisionHandler([scriptController = makeWeakPtr(frame()-&gt;script()), script = unblockRequestDeniedScript.isolatedCopy()](bool unblocked) {</span>
<span class="line-added">2231             if (!unblocked &amp;&amp; scriptController)</span>
<span class="line-added">2232                 scriptController-&gt;executeScriptIgnoringException(script);</span>
<span class="line-added">2233         });</span>
<span class="line-added">2234     }</span>
<span class="line-added">2235     frameLoader()-&gt;client().contentFilterDidBlockLoad(WTFMove(unblockHandler));</span>
<span class="line-added">2236     return frameLoader()-&gt;blockedByContentFilterError(request());</span>
<span class="line-added">2237 }</span>
<span class="line-added">2238 #endif // ENABLE(CONTENT_FILTERING)</span>
<span class="line-added">2239 </span>
2240 } // namespace WebCore
<a name="63" id="anc63"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="63" type="hidden" />
</body>
</html>
diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssemblyMemory.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssemblyMemory.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssemblyMemory.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssemblyMemory.h
@@ -26,46 +26,45 @@
 #pragma once
 
 #if ENABLE(WEBASSEMBLY)
 
 #include "JSDestructibleObject.h"
-#include "JSObject.h"
 #include "WasmMemory.h"
 #include <wtf/Ref.h>
 #include <wtf/RefPtr.h>
 
 namespace JSC {
 
 class ArrayBuffer;
 class JSArrayBuffer;
 
-class JSWebAssemblyMemory final : public JSDestructibleObject {
+class JSWebAssemblyMemory final : public JSNonFinalObject {
 public:
-    typedef JSDestructibleObject Base;
+    using Base = JSNonFinalObject;
+    static constexpr bool needsDestruction = true;
+    static void destroy(JSCell*);
 
-    template<typename CellType, SubspaceAccess>
-    static CompleteSubspace* subspaceFor(VM& vm)
+    template<typename CellType, SubspaceAccess mode>
+    static IsoSubspace* subspaceFor(VM& vm)
     {
-        // We hold onto a lot of memory, so it makes a lot of sense to be swept eagerly.
-        return &vm.eagerlySweptDestructibleObjectSpace;
+        return vm.webAssemblyMemorySpace<mode>();
     }
 
-    static JSWebAssemblyMemory* create(ExecState*, VM&, Structure*);
+    static JSWebAssemblyMemory* tryCreate(JSGlobalObject*, VM&, Structure*);
     static Structure* createStructure(VM&, JSGlobalObject*, JSValue);
 
     DECLARE_EXPORT_INFO;
 
     void adopt(Ref<Wasm::Memory>&&);
     Wasm::Memory& memory() { return m_memory.get(); }
     JSArrayBuffer* buffer(VM& vm, JSGlobalObject*);
-    Wasm::PageCount grow(VM&, ExecState*, uint32_t delta);
+    Wasm::PageCount grow(VM&, JSGlobalObject*, uint32_t delta);
     void growSuccessCallback(VM&, Wasm::PageCount oldPageCount, Wasm::PageCount newPageCount);
 
 private:
     JSWebAssemblyMemory(VM&, Structure*);
     void finishCreation(VM&);
-    static void destroy(JSCell*);
     static void visitChildren(JSCell*, SlotVisitor&);
 
     Ref<Wasm::Memory> m_memory;
     WriteBarrier<JSArrayBuffer> m_bufferWrapper;
     RefPtr<ArrayBuffer> m_buffer;

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/shapes/PolygonShape.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BoxShape.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RectangleShape.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/shapes/PolygonShape.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
108 
109     float xi =  circleXIntercept((y2 &lt; center.y() ? y2 : y1) - center.y(), radius);
110     return FloatShapeInterval(center.x() - xi, center.x() + xi);
111 }
112 
113 LayoutRect PolygonShape::shapeMarginLogicalBoundingBox() const
114 {
115     FloatRect box = m_polygon.boundingBox();
116     box.inflate(shapeMargin());
117     return LayoutRect(box);
118 }
119 
120 LineSegment PolygonShape::getExcludedInterval(LayoutUnit logicalTop, LayoutUnit logicalHeight) const
121 {
122     float y1 = logicalTop;
123     float y2 = logicalTop + logicalHeight;
124 
125     if (m_polygon.isEmpty() || !m_polygon.boundingBox().overlapsYRange(y1 - shapeMargin(), y2 + shapeMargin()))
126         return LineSegment();
127 
<span class="line-removed">128     Vector&lt;const FloatPolygonEdge*&gt; overlappingEdges;</span>
<span class="line-removed">129     if (!m_polygon.overlappingEdges(y1 - shapeMargin(), y2 + shapeMargin(), overlappingEdges))</span>
<span class="line-removed">130         return LineSegment();</span>
<span class="line-removed">131 </span>
132     FloatShapeInterval excludedInterval;
<span class="line-modified">133     for (unsigned i = 0; i &lt; overlappingEdges.size(); i++) {</span>
<span class="line-removed">134         const FloatPolygonEdge&amp; edge = *(overlappingEdges[i]);</span>
135         if (edge.maxY() == edge.minY())
136             continue;
137         if (!shapeMargin())
138             excludedInterval.unite(OffsetPolygonEdge(edge, FloatSize()).clippedEdgeXRange(y1, y2));
139         else {
140             excludedInterval.unite(OffsetPolygonEdge(edge, outwardEdgeNormal(edge) * shapeMargin()).clippedEdgeXRange(y1, y2));
141             excludedInterval.unite(OffsetPolygonEdge(edge, inwardEdgeNormal(edge) * shapeMargin()).clippedEdgeXRange(y1, y2));
142             excludedInterval.unite(clippedCircleXRange(edge.vertex1(), shapeMargin(), y1, y2));
143             excludedInterval.unite(clippedCircleXRange(edge.vertex2(), shapeMargin(), y1, y2));
144         }
145     }
146 
147     if (excludedInterval.isEmpty())
148         return LineSegment();
149 
150     return LineSegment(excludedInterval.x1(), excludedInterval.x2());
151 }
152 
153 void PolygonShape::buildDisplayPaths(DisplayPaths&amp; paths) const
154 {
</pre>
</td>
<td>
<hr />
<pre>
108 
109     float xi =  circleXIntercept((y2 &lt; center.y() ? y2 : y1) - center.y(), radius);
110     return FloatShapeInterval(center.x() - xi, center.x() + xi);
111 }
112 
113 LayoutRect PolygonShape::shapeMarginLogicalBoundingBox() const
114 {
115     FloatRect box = m_polygon.boundingBox();
116     box.inflate(shapeMargin());
117     return LayoutRect(box);
118 }
119 
120 LineSegment PolygonShape::getExcludedInterval(LayoutUnit logicalTop, LayoutUnit logicalHeight) const
121 {
122     float y1 = logicalTop;
123     float y2 = logicalTop + logicalHeight;
124 
125     if (m_polygon.isEmpty() || !m_polygon.boundingBox().overlapsYRange(y1 - shapeMargin(), y2 + shapeMargin()))
126         return LineSegment();
127 




128     FloatShapeInterval excludedInterval;
<span class="line-modified">129     for (const FloatPolygonEdge&amp; edge : m_polygon.overlappingEdges(y1 - shapeMargin(), y2 + shapeMargin())) {</span>

130         if (edge.maxY() == edge.minY())
131             continue;
132         if (!shapeMargin())
133             excludedInterval.unite(OffsetPolygonEdge(edge, FloatSize()).clippedEdgeXRange(y1, y2));
134         else {
135             excludedInterval.unite(OffsetPolygonEdge(edge, outwardEdgeNormal(edge) * shapeMargin()).clippedEdgeXRange(y1, y2));
136             excludedInterval.unite(OffsetPolygonEdge(edge, inwardEdgeNormal(edge) * shapeMargin()).clippedEdgeXRange(y1, y2));
137             excludedInterval.unite(clippedCircleXRange(edge.vertex1(), shapeMargin(), y1, y2));
138             excludedInterval.unite(clippedCircleXRange(edge.vertex2(), shapeMargin(), y1, y2));
139         }
140     }
141 
142     if (excludedInterval.isEmpty())
143         return LineSegment();
144 
145     return LineSegment(excludedInterval.x1(), excludedInterval.x2());
146 }
147 
148 void PolygonShape::buildDisplayPaths(DisplayPaths&amp; paths) const
149 {
</pre>
</td>
</tr>
</table>
<center><a href="BoxShape.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RectangleShape.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
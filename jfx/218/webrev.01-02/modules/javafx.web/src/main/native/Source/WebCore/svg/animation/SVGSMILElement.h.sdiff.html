<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/svg/animation/SVGSMILElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SVGSMILElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../graphics/SVGImage.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/svg/animation/SVGSMILElement.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 65     enum Restart { RestartAlways, RestartWhenNotActive, RestartNever };
 66     Restart restart() const;
 67 
 68     enum FillMode { FillRemove, FillFreeze };
 69     FillMode fill() const;
 70 
 71     SMILTime dur() const;
 72     SMILTime repeatDur() const;
 73     SMILTime repeatCount() const;
 74     SMILTime maxValue() const;
 75     SMILTime minValue() const;
 76 
 77     SMILTime elapsed() const;
 78 
 79     SMILTime intervalBegin() const { return m_intervalBegin; }
 80     SMILTime intervalEnd() const { return m_intervalEnd; }
 81     SMILTime previousIntervalBegin() const { return m_previousIntervalBegin; }
 82     SMILTime simpleDuration() const;
 83 
 84     void seekToIntervalCorrespondingToTime(SMILTime elapsed);
<span class="line-modified"> 85     bool progress(SMILTime elapsed, SVGSMILElement* resultsElement, bool seekToTime);</span>
 86     SMILTime nextProgressTime() const;
 87 
 88     void reset();
 89 
 90     static SMILTime parseClockValue(const String&amp;);
 91     static SMILTime parseOffsetValue(const String&amp;);
 92 
 93     bool isContributing(SMILTime elapsed) const;
 94     bool isInactive() const;
 95     bool isFrozen() const;
 96 
 97     unsigned documentOrderIndex() const { return m_documentOrderIndex; }
 98     void setDocumentOrderIndex(unsigned index) { m_documentOrderIndex = index; }
 99 
100     virtual bool isAdditive() const = 0;
<span class="line-modified">101     virtual void resetAnimatedType() = 0;</span>
<span class="line-modified">102     virtual void clearAnimatedType(SVGElement* targetElement) = 0;</span>
103     virtual void applyResultsToTarget() = 0;
104 
105     void connectConditions();
106     bool hasConditionsConnected() const { return m_conditionsConnected; }
107 
108     void dispatchPendingEvent(SMILEventSender*);
109 
110 protected:
111     void addBeginTime(SMILTime eventTime, SMILTime endTime, SMILTimeWithOrigin::Origin = SMILTimeWithOrigin::ParserOrigin);
112     void addEndTime(SMILTime eventTime, SMILTime endTime, SMILTimeWithOrigin::Origin = SMILTimeWithOrigin::ParserOrigin);
113 
114     void setInactive() { m_activeState = Inactive; }
115 
116     bool rendererIsNeeded(const RenderStyle&amp;) override { return false; }
117 
118     // Sub-classes may need to take action when the target is changed.
119     virtual void setTargetElement(SVGElement*);
120     virtual void setAttributeName(const QualifiedName&amp;);
121 
122     void didFinishInsertingNode() override;
123 
124 private:
125     void buildPendingResource() override;
126     void clearResourceReferences();
127 
128     void clearTarget() override;
129 
130     virtual void startedActiveInterval() = 0;
131     void endedActiveInterval();
<span class="line-modified">132     virtual void updateAnimation(float percent, unsigned repeat, SVGSMILElement* resultElement) = 0;</span>
133 
134     static bool isSupportedAttribute(const QualifiedName&amp;);
135     QualifiedName constructAttributeName() const;
136     void updateAttributeName();
137 
138     enum BeginOrEnd { Begin, End };
139     SMILTime findInstanceTime(BeginOrEnd, SMILTime minimumTime, bool equalsMinimumOK) const;
140     void resolveFirstInterval();
141     void resolveNextInterval(bool notifyDependents);
142     void resolveInterval(bool first, SMILTime&amp; beginResult, SMILTime&amp; endResult) const;
143     SMILTime resolveActiveEnd(SMILTime resolvedBegin, SMILTime resolvedEnd) const;
144     SMILTime repeatingDuration() const;
145     void checkRestart(SMILTime elapsed);
146     void beginListChanged(SMILTime eventTime);
147     void endListChanged(SMILTime eventTime);
148 
149     // This represents conditions on elements begin or end list that need to be resolved on runtime
150     // for example &lt;animate begin=&quot;otherElement.begin + 8s; button.click&quot; ... /&gt;
151     struct Condition {
152         enum Type { EventBase, Syncbase, AccessKey };
</pre>
</td>
<td>
<hr />
<pre>
 65     enum Restart { RestartAlways, RestartWhenNotActive, RestartNever };
 66     Restart restart() const;
 67 
 68     enum FillMode { FillRemove, FillFreeze };
 69     FillMode fill() const;
 70 
 71     SMILTime dur() const;
 72     SMILTime repeatDur() const;
 73     SMILTime repeatCount() const;
 74     SMILTime maxValue() const;
 75     SMILTime minValue() const;
 76 
 77     SMILTime elapsed() const;
 78 
 79     SMILTime intervalBegin() const { return m_intervalBegin; }
 80     SMILTime intervalEnd() const { return m_intervalEnd; }
 81     SMILTime previousIntervalBegin() const { return m_previousIntervalBegin; }
 82     SMILTime simpleDuration() const;
 83 
 84     void seekToIntervalCorrespondingToTime(SMILTime elapsed);
<span class="line-modified"> 85     bool progress(SMILTime elapsed, SVGSMILElement&amp; firstAnimation, bool seekToTime);</span>
 86     SMILTime nextProgressTime() const;
 87 
 88     void reset();
 89 
 90     static SMILTime parseClockValue(const String&amp;);
 91     static SMILTime parseOffsetValue(const String&amp;);
 92 
 93     bool isContributing(SMILTime elapsed) const;
 94     bool isInactive() const;
 95     bool isFrozen() const;
 96 
 97     unsigned documentOrderIndex() const { return m_documentOrderIndex; }
 98     void setDocumentOrderIndex(unsigned index) { m_documentOrderIndex = index; }
 99 
100     virtual bool isAdditive() const = 0;
<span class="line-modified">101     virtual void startAnimation() = 0;</span>
<span class="line-modified">102     virtual void stopAnimation(SVGElement* targetElement) = 0;</span>
103     virtual void applyResultsToTarget() = 0;
104 
105     void connectConditions();
106     bool hasConditionsConnected() const { return m_conditionsConnected; }
107 
108     void dispatchPendingEvent(SMILEventSender*);
109 
110 protected:
111     void addBeginTime(SMILTime eventTime, SMILTime endTime, SMILTimeWithOrigin::Origin = SMILTimeWithOrigin::ParserOrigin);
112     void addEndTime(SMILTime eventTime, SMILTime endTime, SMILTimeWithOrigin::Origin = SMILTimeWithOrigin::ParserOrigin);
113 
114     void setInactive() { m_activeState = Inactive; }
115 
116     bool rendererIsNeeded(const RenderStyle&amp;) override { return false; }
117 
118     // Sub-classes may need to take action when the target is changed.
119     virtual void setTargetElement(SVGElement*);
120     virtual void setAttributeName(const QualifiedName&amp;);
121 
122     void didFinishInsertingNode() override;
123 
124 private:
125     void buildPendingResource() override;
126     void clearResourceReferences();
127 
128     void clearTarget() override;
129 
130     virtual void startedActiveInterval() = 0;
131     void endedActiveInterval();
<span class="line-modified">132     virtual void updateAnimation(float percent, unsigned repeat) = 0;</span>
133 
134     static bool isSupportedAttribute(const QualifiedName&amp;);
135     QualifiedName constructAttributeName() const;
136     void updateAttributeName();
137 
138     enum BeginOrEnd { Begin, End };
139     SMILTime findInstanceTime(BeginOrEnd, SMILTime minimumTime, bool equalsMinimumOK) const;
140     void resolveFirstInterval();
141     void resolveNextInterval(bool notifyDependents);
142     void resolveInterval(bool first, SMILTime&amp; beginResult, SMILTime&amp; endResult) const;
143     SMILTime resolveActiveEnd(SMILTime resolvedBegin, SMILTime resolvedEnd) const;
144     SMILTime repeatingDuration() const;
145     void checkRestart(SMILTime elapsed);
146     void beginListChanged(SMILTime eventTime);
147     void endListChanged(SMILTime eventTime);
148 
149     // This represents conditions on elements begin or end list that need to be resolved on runtime
150     // for example &lt;animate begin=&quot;otherElement.begin + 8s; button.click&quot; ... /&gt;
151     struct Condition {
152         enum Type { EventBase, Syncbase, AccessKey };
</pre>
</td>
</tr>
</table>
<center><a href="SVGSMILElement.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../graphics/SVGImage.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/generic/KeyedDecoderGeneric.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../encryptedmedia/clearkey/CDMClearKey.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="KeyedDecoderGeneric.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/generic/KeyedDecoderGeneric.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;KeyedDecoderGeneric.h&quot;
 28 
 29 #include &quot;KeyedEncoderGeneric.h&quot;
 30 #include &lt;wtf/HashMap.h&gt;
 31 #include &lt;wtf/Variant.h&gt;
 32 #include &lt;wtf/Vector.h&gt;
 33 #include &lt;wtf/persistence/PersistentDecoder.h&gt;
 34 #include &lt;wtf/text/StringHash.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 class KeyedDecoderGeneric::Dictionary {
 39     WTF_MAKE_FAST_ALLOCATED;
 40 public:
 41     using Node = Variant&lt;Vector&lt;uint8_t&gt;, bool, uint32_t, uint64_t, int32_t, int64_t, float, double, String, std::unique_ptr&lt;Dictionary&gt;, std::unique_ptr&lt;Array&gt;&gt;;
 42 
 43     template &lt;typename T&gt;
 44     void add(const String&amp; key, T&amp;&amp; value) { m_map.add(key, makeUnique&lt;Node&gt;(std::forward&lt;T&gt;(value))); }
<span class="line-modified"> 45     Node&amp; get(const String&amp; key) { return *m_map.get(key); }</span>
 46 
 47 private:
 48     HashMap&lt;String, std::unique_ptr&lt;Node&gt;&gt; m_map;
 49 };
 50 
 51 static bool readString(WTF::Persistence::Decoder&amp; decoder, String&amp; result)
 52 {
 53     size_t size;
 54     if (!decoder.decode(size))
 55         return false;





 56     Vector&lt;uint8_t&gt; buffer(size);
 57     if (!decoder.decodeFixedLengthData(buffer.data(), size))
 58         return false;
 59     result = String::fromUTF8(buffer.data(), size);



 60     return true;
 61 }
 62 
 63 template&lt;typename T&gt;
 64 static bool readSimpleValue(WTF::Persistence::Decoder&amp; decoder, KeyedDecoderGeneric::Dictionary&amp; dictionary)
 65 {
 66     String key;
 67     bool ok = readString(decoder, key);
 68     if (!ok)
 69         return false;
 70     T value;
 71     ok = decoder.decode(value);
 72     if (!ok)
 73         return false;
 74     dictionary.add(key, WTFMove(value));
 75     return true;
 76 }
 77 
 78 std::unique_ptr&lt;KeyedDecoder&gt; KeyedDecoder::decoder(const uint8_t* data, size_t size)
 79 {
</pre>
<hr />
<pre>
164         case KeyedEncoderGeneric::Type::BeginArrayElement: {
165             auto newDictionary = makeUnique&lt;Dictionary&gt;();
166             m_dictionaryStack.append(newDictionary.get());
167             m_arrayStack.last()-&gt;append(WTFMove(newDictionary));
168             break;
169         }
170         case KeyedEncoderGeneric::Type::EndArrayElement:
171             m_dictionaryStack.removeLast();
172             break;
173         case KeyedEncoderGeneric::Type::EndArray:
174             m_arrayStack.removeLast();
175             break;
176         }
177     }
178     while (m_dictionaryStack.size() &gt; 1)
179         m_dictionaryStack.removeLast();
180     while (!m_arrayStack.isEmpty())
181         m_arrayStack.removeLast();
182 }
183 























184 bool KeyedDecoderGeneric::decodeBytes(const String&amp; key, const uint8_t*&amp; data, size_t&amp; size)
185 {
<span class="line-modified">186     auto* value = WTF::get_if&lt;Vector&lt;uint8_t&gt;&gt;(m_dictionaryStack.last()-&gt;get(key));</span>
187     if (!value)
188         return false;

189     data = value-&gt;data();
190     size = value-&gt;size();
191     return true;
192 }
193 
194 bool KeyedDecoderGeneric::decodeBool(const String&amp; key, bool&amp; result)
195 {
<span class="line-modified">196     auto* value = WTF::get_if&lt;bool&gt;(m_dictionaryStack.last()-&gt;get(key));</span>
<span class="line-removed">197     if (!value)</span>
<span class="line-removed">198         return false;</span>
<span class="line-removed">199     result = *value;</span>
<span class="line-removed">200     return true;</span>
201 }
202 
203 bool KeyedDecoderGeneric::decodeUInt32(const String&amp; key, uint32_t&amp; result)
204 {
<span class="line-modified">205     auto* value = WTF::get_if&lt;uint32_t&gt;(m_dictionaryStack.last()-&gt;get(key));</span>
<span class="line-removed">206     if (!value)</span>
<span class="line-removed">207         return false;</span>
<span class="line-removed">208     result = *value;</span>
<span class="line-removed">209     return true;</span>
210 }
211 
212 bool KeyedDecoderGeneric::decodeUInt64(const String&amp; key, uint64_t&amp; result)
213 {
<span class="line-modified">214     auto* value = WTF::get_if&lt;uint64_t&gt;(m_dictionaryStack.last()-&gt;get(key));</span>
<span class="line-removed">215     if (!value)</span>
<span class="line-removed">216         return false;</span>
<span class="line-removed">217     result = *value;</span>
<span class="line-removed">218     return true;</span>
219 }
220 
221 bool KeyedDecoderGeneric::decodeInt32(const String&amp; key, int32_t&amp; result)
222 {
<span class="line-modified">223     auto* value = WTF::get_if&lt;int32_t&gt;(m_dictionaryStack.last()-&gt;get(key));</span>
<span class="line-removed">224     if (!value)</span>
<span class="line-removed">225         return false;</span>
<span class="line-removed">226     result = *value;</span>
<span class="line-removed">227     return true;</span>
228 }
229 
230 bool KeyedDecoderGeneric::decodeInt64(const String&amp; key, int64_t&amp; result)
231 {
<span class="line-modified">232     auto* value = WTF::get_if&lt;int64_t&gt;(m_dictionaryStack.last()-&gt;get(key));</span>
<span class="line-removed">233     if (!value)</span>
<span class="line-removed">234         return false;</span>
<span class="line-removed">235     result = *value;</span>
<span class="line-removed">236     return true;</span>
237 }
238 
239 bool KeyedDecoderGeneric::decodeFloat(const String&amp; key, float&amp; result)
240 {
<span class="line-modified">241     auto* value = WTF::get_if&lt;float&gt;(m_dictionaryStack.last()-&gt;get(key));</span>
<span class="line-removed">242     if (!value)</span>
<span class="line-removed">243         return false;</span>
<span class="line-removed">244     result = *value;</span>
<span class="line-removed">245     return true;</span>
246 }
247 
248 bool KeyedDecoderGeneric::decodeDouble(const String&amp; key, double&amp; result)
249 {
<span class="line-modified">250     auto* value = WTF::get_if&lt;double&gt;(m_dictionaryStack.last()-&gt;get(key));</span>
<span class="line-removed">251     if (!value)</span>
<span class="line-removed">252         return false;</span>
<span class="line-removed">253     result = *value;</span>
<span class="line-removed">254     return true;</span>
255 }
256 
257 bool KeyedDecoderGeneric::decodeString(const String&amp; key, String&amp; result)
258 {
<span class="line-modified">259     auto* value = WTF::get_if&lt;String&gt;(m_dictionaryStack.last()-&gt;get(key));</span>
<span class="line-removed">260     if (!value)</span>
<span class="line-removed">261         return false;</span>
<span class="line-removed">262     result = *value;</span>
<span class="line-removed">263     return true;</span>
264 }
265 
266 bool KeyedDecoderGeneric::beginObject(const String&amp; key)
267 {
<span class="line-modified">268     auto* value = WTF::get_if&lt;std::unique_ptr&lt;Dictionary&gt;&gt;(m_dictionaryStack.last()-&gt;get(key));</span>
269     if (!value)
270         return false;

271     m_dictionaryStack.append(value-&gt;get());
272     return true;
273 }
274 
275 void KeyedDecoderGeneric::endObject()
276 {
277     m_dictionaryStack.removeLast();
278 }
279 
280 bool KeyedDecoderGeneric::beginArray(const String&amp; key)
281 {
<span class="line-modified">282     auto* value = WTF::get_if&lt;std::unique_ptr&lt;Array&gt;&gt;(m_dictionaryStack.last()-&gt;get(key));</span>
283     if (!value)
284         return false;

285     m_arrayStack.append(value-&gt;get());
286     m_arrayIndexStack.append(0);
287     return true;
288 }
289 
290 bool KeyedDecoderGeneric::beginArrayElement()
291 {
292     if (m_arrayIndexStack.last() &gt;= m_arrayStack.last()-&gt;size())
293         return false;
294 
295     auto dictionary = m_arrayStack.last()-&gt;at(m_arrayIndexStack.last()++).get();
296     m_dictionaryStack.append(dictionary);
297     return true;
298 }
299 
300 void KeyedDecoderGeneric::endArrayElement()
301 {
302     m_dictionaryStack.removeLast();
303 }
304 
</pre>
</td>
<td>
<hr />
<pre>
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;KeyedDecoderGeneric.h&quot;
 28 
 29 #include &quot;KeyedEncoderGeneric.h&quot;
 30 #include &lt;wtf/HashMap.h&gt;
 31 #include &lt;wtf/Variant.h&gt;
 32 #include &lt;wtf/Vector.h&gt;
 33 #include &lt;wtf/persistence/PersistentDecoder.h&gt;
 34 #include &lt;wtf/text/StringHash.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 class KeyedDecoderGeneric::Dictionary {
 39     WTF_MAKE_FAST_ALLOCATED;
 40 public:
 41     using Node = Variant&lt;Vector&lt;uint8_t&gt;, bool, uint32_t, uint64_t, int32_t, int64_t, float, double, String, std::unique_ptr&lt;Dictionary&gt;, std::unique_ptr&lt;Array&gt;&gt;;
 42 
 43     template &lt;typename T&gt;
 44     void add(const String&amp; key, T&amp;&amp; value) { m_map.add(key, makeUnique&lt;Node&gt;(std::forward&lt;T&gt;(value))); }
<span class="line-modified"> 45     Node* get(const String&amp; key) { return m_map.get(key); }</span>
 46 
 47 private:
 48     HashMap&lt;String, std::unique_ptr&lt;Node&gt;&gt; m_map;
 49 };
 50 
 51 static bool readString(WTF::Persistence::Decoder&amp; decoder, String&amp; result)
 52 {
 53     size_t size;
 54     if (!decoder.decode(size))
 55         return false;
<span class="line-added"> 56     if (!size) {</span>
<span class="line-added"> 57         result = emptyString();</span>
<span class="line-added"> 58         return true;</span>
<span class="line-added"> 59     }</span>
<span class="line-added"> 60 </span>
 61     Vector&lt;uint8_t&gt; buffer(size);
 62     if (!decoder.decodeFixedLengthData(buffer.data(), size))
 63         return false;
 64     result = String::fromUTF8(buffer.data(), size);
<span class="line-added"> 65     if (result.isNull())</span>
<span class="line-added"> 66         return false;</span>
<span class="line-added"> 67 </span>
 68     return true;
 69 }
 70 
 71 template&lt;typename T&gt;
 72 static bool readSimpleValue(WTF::Persistence::Decoder&amp; decoder, KeyedDecoderGeneric::Dictionary&amp; dictionary)
 73 {
 74     String key;
 75     bool ok = readString(decoder, key);
 76     if (!ok)
 77         return false;
 78     T value;
 79     ok = decoder.decode(value);
 80     if (!ok)
 81         return false;
 82     dictionary.add(key, WTFMove(value));
 83     return true;
 84 }
 85 
 86 std::unique_ptr&lt;KeyedDecoder&gt; KeyedDecoder::decoder(const uint8_t* data, size_t size)
 87 {
</pre>
<hr />
<pre>
172         case KeyedEncoderGeneric::Type::BeginArrayElement: {
173             auto newDictionary = makeUnique&lt;Dictionary&gt;();
174             m_dictionaryStack.append(newDictionary.get());
175             m_arrayStack.last()-&gt;append(WTFMove(newDictionary));
176             break;
177         }
178         case KeyedEncoderGeneric::Type::EndArrayElement:
179             m_dictionaryStack.removeLast();
180             break;
181         case KeyedEncoderGeneric::Type::EndArray:
182             m_arrayStack.removeLast();
183             break;
184         }
185     }
186     while (m_dictionaryStack.size() &gt; 1)
187         m_dictionaryStack.removeLast();
188     while (!m_arrayStack.isEmpty())
189         m_arrayStack.removeLast();
190 }
191 
<span class="line-added">192 template&lt;typename T&gt;</span>
<span class="line-added">193 const T* KeyedDecoderGeneric::getPointerFromDictionaryStack(const String&amp; key)</span>
<span class="line-added">194 {</span>
<span class="line-added">195     auto&amp; dictionary = m_dictionaryStack.last();</span>
<span class="line-added">196 </span>
<span class="line-added">197     auto node = dictionary-&gt;get(key);</span>
<span class="line-added">198     if (!node)</span>
<span class="line-added">199         return nullptr;</span>
<span class="line-added">200 </span>
<span class="line-added">201     return WTF::get_if&lt;T&gt;(*node);</span>
<span class="line-added">202 }</span>
<span class="line-added">203 </span>
<span class="line-added">204 template&lt;typename T&gt;</span>
<span class="line-added">205 bool KeyedDecoderGeneric::decodeSimpleValue(const String&amp; key, T&amp; result)</span>
<span class="line-added">206 {</span>
<span class="line-added">207     auto value = getPointerFromDictionaryStack&lt;T&gt;(key);</span>
<span class="line-added">208     if (!value)</span>
<span class="line-added">209         return false;</span>
<span class="line-added">210 </span>
<span class="line-added">211     result = *value;</span>
<span class="line-added">212     return true;</span>
<span class="line-added">213 }</span>
<span class="line-added">214 </span>
215 bool KeyedDecoderGeneric::decodeBytes(const String&amp; key, const uint8_t*&amp; data, size_t&amp; size)
216 {
<span class="line-modified">217     auto value = getPointerFromDictionaryStack&lt;Vector&lt;uint8_t&gt;&gt;(key);</span>
218     if (!value)
219         return false;
<span class="line-added">220 </span>
221     data = value-&gt;data();
222     size = value-&gt;size();
223     return true;
224 }
225 
226 bool KeyedDecoderGeneric::decodeBool(const String&amp; key, bool&amp; result)
227 {
<span class="line-modified">228     return decodeSimpleValue(key, result);</span>




229 }
230 
231 bool KeyedDecoderGeneric::decodeUInt32(const String&amp; key, uint32_t&amp; result)
232 {
<span class="line-modified">233     return decodeSimpleValue(key, result);</span>




234 }
235 
236 bool KeyedDecoderGeneric::decodeUInt64(const String&amp; key, uint64_t&amp; result)
237 {
<span class="line-modified">238     return decodeSimpleValue(key, result);</span>




239 }
240 
241 bool KeyedDecoderGeneric::decodeInt32(const String&amp; key, int32_t&amp; result)
242 {
<span class="line-modified">243     return decodeSimpleValue(key, result);</span>




244 }
245 
246 bool KeyedDecoderGeneric::decodeInt64(const String&amp; key, int64_t&amp; result)
247 {
<span class="line-modified">248     return decodeSimpleValue(key, result);</span>




249 }
250 
251 bool KeyedDecoderGeneric::decodeFloat(const String&amp; key, float&amp; result)
252 {
<span class="line-modified">253     return decodeSimpleValue(key, result);</span>




254 }
255 
256 bool KeyedDecoderGeneric::decodeDouble(const String&amp; key, double&amp; result)
257 {
<span class="line-modified">258     return decodeSimpleValue(key, result);</span>




259 }
260 
261 bool KeyedDecoderGeneric::decodeString(const String&amp; key, String&amp; result)
262 {
<span class="line-modified">263     return decodeSimpleValue(key, result);</span>




264 }
265 
266 bool KeyedDecoderGeneric::beginObject(const String&amp; key)
267 {
<span class="line-modified">268     auto value = getPointerFromDictionaryStack&lt;std::unique_ptr&lt;Dictionary&gt;&gt;(key);</span>
269     if (!value)
270         return false;
<span class="line-added">271 </span>
272     m_dictionaryStack.append(value-&gt;get());
273     return true;
274 }
275 
276 void KeyedDecoderGeneric::endObject()
277 {
278     m_dictionaryStack.removeLast();
279 }
280 
281 bool KeyedDecoderGeneric::beginArray(const String&amp; key)
282 {
<span class="line-modified">283     auto value = getPointerFromDictionaryStack&lt;std::unique_ptr&lt;Array&gt;&gt;(key);</span>
284     if (!value)
285         return false;
<span class="line-added">286 </span>
287     m_arrayStack.append(value-&gt;get());
288     m_arrayIndexStack.append(0);
289     return true;
290 }
291 
292 bool KeyedDecoderGeneric::beginArrayElement()
293 {
294     if (m_arrayIndexStack.last() &gt;= m_arrayStack.last()-&gt;size())
295         return false;
296 
297     auto dictionary = m_arrayStack.last()-&gt;at(m_arrayIndexStack.last()++).get();
298     m_dictionaryStack.append(dictionary);
299     return true;
300 }
301 
302 void KeyedDecoderGeneric::endArrayElement()
303 {
304     m_dictionaryStack.removeLast();
305 }
306 
</pre>
</td>
</tr>
</table>
<center><a href="../encryptedmedia/clearkey/CDMClearKey.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="KeyedDecoderGeneric.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
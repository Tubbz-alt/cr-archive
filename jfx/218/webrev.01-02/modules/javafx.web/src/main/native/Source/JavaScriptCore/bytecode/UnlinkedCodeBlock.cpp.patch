diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlock.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlock.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlock.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/UnlinkedCodeBlock.cpp
@@ -70,33 +70,36 @@
     , m_derivedContextType(static_cast<unsigned>(info.derivedContextType()))
     , m_evalContextType(static_cast<unsigned>(info.evalContextType()))
     , m_codeType(static_cast<unsigned>(codeType))
     , m_didOptimize(static_cast<unsigned>(MixedTriState))
     , m_age(0)
+    , m_hasCheckpoints(false)
     , m_parseMode(info.parseMode())
     , m_codeGenerationMode(codeGenerationMode)
     , m_metadata(UnlinkedMetadataTable::create())
 {
-    for (auto& constantRegisterIndex : m_linkTimeConstants)
-        constantRegisterIndex = 0;
     ASSERT(m_constructorKind == static_cast<unsigned>(info.constructorKind()));
     ASSERT(m_codeType == static_cast<unsigned>(codeType));
     ASSERT(m_didOptimize == static_cast<unsigned>(MixedTriState));
+    if (info.needsClassFieldInitializer() == NeedsClassFieldInitializer::Yes) {
+        createRareDataIfNecessary(holdLock(cellLock()));
+        m_rareData->m_needsClassFieldInitializer = static_cast<unsigned>(NeedsClassFieldInitializer::Yes);
+    }
 }
 
 void UnlinkedCodeBlock::visitChildren(JSCell* cell, SlotVisitor& visitor)
 {
     UnlinkedCodeBlock* thisObject = jsCast<UnlinkedCodeBlock*>(cell);
     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
     Base::visitChildren(thisObject, visitor);
     auto locker = holdLock(thisObject->cellLock());
     if (visitor.isFirstVisit())
         thisObject->m_age = std::min<unsigned>(static_cast<unsigned>(thisObject->m_age) + 1, maxAge);
-    for (FunctionExpressionVector::iterator ptr = thisObject->m_functionDecls.begin(), end = thisObject->m_functionDecls.end(); ptr != end; ++ptr)
-        visitor.append(*ptr);
-    for (FunctionExpressionVector::iterator ptr = thisObject->m_functionExprs.begin(), end = thisObject->m_functionExprs.end(); ptr != end; ++ptr)
-        visitor.append(*ptr);
+    for (auto& barrier : thisObject->m_functionDecls)
+        visitor.append(barrier);
+    for (auto& barrier : thisObject->m_functionExprs)
+        visitor.append(barrier);
     visitor.appendValues(thisObject->m_constantRegisters.data(), thisObject->m_constantRegisters.size());
     size_t extraMemory = thisObject->m_metadata->sizeInBytes();
     if (thisObject->m_instructions)
         extraMemory += thisObject->m_instructions->sizeInBytes();
     visitor.reportExtraMemoryVisited(extraMemory);
@@ -109,19 +112,19 @@
     if (thisObject->m_instructions)
         extraSize += thisObject->m_instructions->sizeInBytes();
     return Base::estimatedSize(cell, vm) + extraSize;
 }
 
-int UnlinkedCodeBlock::lineNumberForBytecodeOffset(unsigned bytecodeOffset)
+int UnlinkedCodeBlock::lineNumberForBytecodeIndex(BytecodeIndex bytecodeIndex)
 {
-    ASSERT(bytecodeOffset < instructions().size());
+    ASSERT(bytecodeIndex.offset() < instructions().size());
     int divot { 0 };
     int startOffset { 0 };
     int endOffset { 0 };
     unsigned line { 0 };
     unsigned column { 0 };
-    expressionRangeForBytecodeOffset(bytecodeOffset, divot, startOffset, endOffset, line, column);
+    expressionRangeForBytecodeIndex(bytecodeIndex, divot, startOffset, endOffset, line, column);
     return line;
 }
 
 inline void UnlinkedCodeBlock::getLineAndColumn(const ExpressionRangeInfo& info,
     unsigned& line, unsigned& column) const
@@ -151,22 +154,22 @@
     if (instruction->is<OpDebug>()) {
         switch (instruction->as<OpDebug>().m_debugHookType) {
         case WillExecuteProgram: event = " WillExecuteProgram"; break;
         case DidExecuteProgram: event = " DidExecuteProgram"; break;
         case DidEnterCallFrame: event = " DidEnterCallFrame"; break;
-        case DidReachBreakpoint: event = " DidReachBreakpoint"; break;
+        case DidReachDebuggerStatement: event = " DidReachDebuggerStatement"; break;
         case WillLeaveCallFrame: event = " WillLeaveCallFrame"; break;
         case WillExecuteStatement: event = " WillExecuteStatement"; break;
         case WillExecuteExpression: event = " WillExecuteExpression"; break;
         }
     }
     dataLogF("  [%zu] pc %u @ line %u col %u : %s%s\n", index, instructionOffset, line, column, instruction->name(), event);
 }
 
 void UnlinkedCodeBlock::dumpExpressionRangeInfo()
 {
-    Vector<ExpressionRangeInfo>& expressionInfo = m_expressionInfo;
+    RefCountedArray<ExpressionRangeInfo>& expressionInfo = m_expressionInfo;
 
     size_t size = m_expressionInfo.size();
     dataLogF("UnlinkedCodeBlock %p expressionRangeInfo[%zu] {\n", this, size);
     for (size_t i = 0; i < size; i++) {
         ExpressionRangeInfo& info = expressionInfo[i];
@@ -177,31 +180,31 @@
     }
     dataLog("}\n");
 }
 #endif
 
-void UnlinkedCodeBlock::expressionRangeForBytecodeOffset(unsigned bytecodeOffset,
+void UnlinkedCodeBlock::expressionRangeForBytecodeIndex(BytecodeIndex bytecodeIndex,
     int& divot, int& startOffset, int& endOffset, unsigned& line, unsigned& column) const
 {
-    ASSERT(bytecodeOffset < instructions().size());
+    ASSERT(bytecodeIndex.offset() < instructions().size());
 
     if (!m_expressionInfo.size()) {
         startOffset = 0;
         endOffset = 0;
         divot = 0;
         line = 0;
         column = 0;
         return;
     }
 
-    const Vector<ExpressionRangeInfo>& expressionInfo = m_expressionInfo;
+    const RefCountedArray<ExpressionRangeInfo>& expressionInfo = m_expressionInfo;
 
     int low = 0;
     int high = expressionInfo.size();
     while (low < high) {
         int mid = low + (high - low) / 2;
-        if (expressionInfo[mid].instructionOffset <= bytecodeOffset)
+        if (expressionInfo[mid].instructionOffset <= bytecodeIndex.offset())
             low = mid + 1;
         else
             high = mid;
     }
 
@@ -213,67 +216,13 @@
     endOffset = info.endOffset;
     divot = info.divotPoint;
     getLineAndColumn(info, line, column);
 }
 
-void UnlinkedCodeBlock::addExpressionInfo(unsigned instructionOffset,
-    int divot, int startOffset, int endOffset, unsigned line, unsigned column)
-{
-    if (divot > ExpressionRangeInfo::MaxDivot) {
-        // Overflow has occurred, we can only give line number info for errors for this region
-        divot = 0;
-        startOffset = 0;
-        endOffset = 0;
-    } else if (startOffset > ExpressionRangeInfo::MaxOffset) {
-        // If the start offset is out of bounds we clear both offsets
-        // so we only get the divot marker. Error message will have to be reduced
-        // to line and charPosition number.
-        startOffset = 0;
-        endOffset = 0;
-    } else if (endOffset > ExpressionRangeInfo::MaxOffset) {
-        // The end offset is only used for additional context, and is much more likely
-        // to overflow (eg. function call arguments) so we are willing to drop it without
-        // dropping the rest of the range.
-        endOffset = 0;
-    }
-
-    unsigned positionMode =
-        (line <= ExpressionRangeInfo::MaxFatLineModeLine && column <= ExpressionRangeInfo::MaxFatLineModeColumn)
-        ? ExpressionRangeInfo::FatLineMode
-        : (line <= ExpressionRangeInfo::MaxFatColumnModeLine && column <= ExpressionRangeInfo::MaxFatColumnModeColumn)
-        ? ExpressionRangeInfo::FatColumnMode
-        : ExpressionRangeInfo::FatLineAndColumnMode;
-
-    ExpressionRangeInfo info;
-    info.instructionOffset = instructionOffset;
-    info.divotPoint = divot;
-    info.startOffset = startOffset;
-    info.endOffset = endOffset;
-
-    info.mode = positionMode;
-    switch (positionMode) {
-    case ExpressionRangeInfo::FatLineMode:
-        info.encodeFatLineMode(line, column);
-        break;
-    case ExpressionRangeInfo::FatColumnMode:
-        info.encodeFatColumnMode(line, column);
-        break;
-    case ExpressionRangeInfo::FatLineAndColumnMode: {
-        createRareDataIfNecessary();
-        unsigned fatIndex = m_rareData->m_expressionInfoFatPositions.size();
-        ExpressionRangeInfo::FatPosition fatPos = { line, column };
-        m_rareData->m_expressionInfoFatPositions.append(fatPos);
-        info.position = fatIndex;
-    }
-    } // switch
-
-    m_expressionInfo.append(info);
-}
-
 bool UnlinkedCodeBlock::typeProfilerExpressionInfoForBytecodeOffset(unsigned bytecodeOffset, unsigned& startDivot, unsigned& endDivot)
 {
-    static const bool verbose = false;
+    static constexpr bool verbose = false;
     if (!m_rareData) {
         if (verbose)
             dataLogF("Don't have assignment info for offset:%u\n", bytecodeOffset);
         startDivot = UINT_MAX;
         endDivot = UINT_MAX;
@@ -293,114 +242,30 @@
     startDivot = range.m_startDivot;
     endDivot = range.m_endDivot;
     return true;
 }
 
-void UnlinkedCodeBlock::addTypeProfilerExpressionInfo(unsigned instructionOffset, unsigned startDivot, unsigned endDivot)
-{
-    createRareDataIfNecessary();
-    RareData::TypeProfilerExpressionRange range;
-    range.m_startDivot = startDivot;
-    range.m_endDivot = endDivot;
-    m_rareData->m_typeProfilerInfoMap.set(instructionOffset, range);
-}
-
 UnlinkedCodeBlock::~UnlinkedCodeBlock()
 {
 }
 
-void UnlinkedCodeBlock::setInstructions(std::unique_ptr<InstructionStream> instructions)
-{
-    ASSERT(instructions);
-    {
-        auto locker = holdLock(cellLock());
-        m_instructions = WTFMove(instructions);
-        m_metadata->finalize();
-    }
-    Heap::heap(this)->reportExtraMemoryAllocated(m_instructions->sizeInBytes() + m_metadata->sizeInBytes());
-}
-
 const InstructionStream& UnlinkedCodeBlock::instructions() const
 {
     ASSERT(m_instructions.get());
     return *m_instructions;
 }
 
-UnlinkedHandlerInfo* UnlinkedCodeBlock::handlerForBytecodeOffset(unsigned bytecodeOffset, RequiredHandler requiredHandler)
+UnlinkedHandlerInfo* UnlinkedCodeBlock::handlerForBytecodeIndex(BytecodeIndex bytecodeIndex, RequiredHandler requiredHandler)
 {
-    return handlerForIndex(bytecodeOffset, requiredHandler);
+    return handlerForIndex(bytecodeIndex.offset(), requiredHandler);
 }
 
 UnlinkedHandlerInfo* UnlinkedCodeBlock::handlerForIndex(unsigned index, RequiredHandler requiredHandler)
 {
     if (!m_rareData)
         return nullptr;
-    return UnlinkedHandlerInfo::handlerForIndex(m_rareData->m_exceptionHandlers, index, requiredHandler);
-}
-
-void UnlinkedCodeBlock::applyModification(BytecodeRewriter& rewriter, InstructionStreamWriter& instructions)
-{
-    // Before applying the changes, we adjust the jumps based on the original bytecode offset, the offset to the jump target, and
-    // the insertion information.
-
-    rewriter.adjustJumpTargets();
-
-    // Then, exception handlers should be adjusted.
-    if (m_rareData) {
-        for (UnlinkedHandlerInfo& handler : m_rareData->m_exceptionHandlers) {
-            handler.target = rewriter.adjustAbsoluteOffset(handler.target);
-            handler.start = rewriter.adjustAbsoluteOffset(handler.start);
-            handler.end = rewriter.adjustAbsoluteOffset(handler.end);
-        }
-
-        for (size_t i = 0; i < m_rareData->m_opProfileControlFlowBytecodeOffsets.size(); ++i)
-            m_rareData->m_opProfileControlFlowBytecodeOffsets[i] = rewriter.adjustAbsoluteOffset(m_rareData->m_opProfileControlFlowBytecodeOffsets[i]);
-
-        if (!m_rareData->m_typeProfilerInfoMap.isEmpty()) {
-            HashMap<unsigned, RareData::TypeProfilerExpressionRange> adjustedTypeProfilerInfoMap;
-            for (auto& entry : m_rareData->m_typeProfilerInfoMap)
-                adjustedTypeProfilerInfoMap.set(rewriter.adjustAbsoluteOffset(entry.key), entry.value);
-            m_rareData->m_typeProfilerInfoMap.swap(adjustedTypeProfilerInfoMap);
-        }
-    }
-
-    for (size_t i = 0; i < m_propertyAccessInstructions.size(); ++i)
-        m_propertyAccessInstructions[i] = rewriter.adjustAbsoluteOffset(m_propertyAccessInstructions[i]);
-
-    for (size_t i = 0; i < m_expressionInfo.size(); ++i)
-        m_expressionInfo[i].instructionOffset = rewriter.adjustAbsoluteOffset(m_expressionInfo[i].instructionOffset);
-
-    // Then, modify the unlinked instructions.
-    rewriter.applyModification();
-
-    // And recompute the jump target based on the modified unlinked instructions.
-    m_jumpTargets.clear();
-    recomputePreciseJumpTargets(this, instructions, m_jumpTargets);
-}
-
-void UnlinkedCodeBlock::shrinkToFit()
-{
-    auto locker = holdLock(cellLock());
-
-    m_jumpTargets.shrinkToFit();
-    m_propertyAccessInstructions.shrinkToFit();
-    m_identifiers.shrinkToFit();
-    m_constantRegisters.shrinkToFit();
-    m_constantsSourceCodeRepresentation.shrinkToFit();
-    m_functionDecls.shrinkToFit();
-    m_functionExprs.shrinkToFit();
-    m_expressionInfo.shrinkToFit();
-
-    if (m_rareData) {
-        m_rareData->m_exceptionHandlers.shrinkToFit();
-        m_rareData->m_switchJumpTables.shrinkToFit();
-        m_rareData->m_stringSwitchJumpTables.shrinkToFit();
-        m_rareData->m_expressionInfoFatPositions.shrinkToFit();
-        m_rareData->m_opProfileControlFlowBytecodeOffsets.shrinkToFit();
-        m_rareData->m_bitVectors.shrinkToFit();
-        m_rareData->m_constantIdentifierSets.shrinkToFit();
-    }
+    return UnlinkedHandlerInfo::handlerForIndex<UnlinkedHandlerInfo>(m_rareData->m_exceptionHandlers, index, requiredHandler);
 }
 
 void UnlinkedCodeBlock::dump(PrintStream&) const
 {
 }
@@ -419,16 +284,10 @@
     }
 
     return *m_liveness;
 }
 
-void UnlinkedCodeBlock::addOutOfLineJumpTarget(InstructionStream::Offset bytecodeOffset, int target)
-{
-    RELEASE_ASSERT(target);
-    m_outOfLineJumpTargets.set(bytecodeOffset, target);
-}
-
 int UnlinkedCodeBlock::outOfLineJumpOffset(InstructionStream::Offset bytecodeOffset)
 {
     ASSERT(m_outOfLineJumpTargets.contains(bytecodeOffset));
     return m_outOfLineJumpTargets.get(bytecodeOffset);
 }

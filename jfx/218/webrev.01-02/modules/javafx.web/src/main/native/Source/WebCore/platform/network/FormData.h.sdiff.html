<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/network/FormData.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FormData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FormDataBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/network/FormData.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB. If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 #pragma once
 21 
 22 #include &quot;BlobData.h&quot;
<span class="line-removed"> 23 #include &lt;pal/SessionID.h&gt;</span>
 24 #include &lt;wtf/Forward.h&gt;
 25 #include &lt;wtf/RefCounted.h&gt;
 26 #include &lt;wtf/URL.h&gt;
 27 #include &lt;wtf/Variant.h&gt;
 28 #include &lt;wtf/Vector.h&gt;
 29 #include &lt;wtf/text/WTFString.h&gt;
 30 
 31 namespace WebCore {
 32 
 33 class BlobRegistryImpl;
 34 class DOMFormData;
 35 class File;
 36 class SharedBuffer;
 37 class TextEncoding;
 38 
 39 struct FormDataElement {
 40     struct EncodedFileData;
 41     struct EncodedBlobData;
 42     using Data = Variant&lt;Vector&lt;char&gt;, EncodedFileData, EncodedBlobData&gt;;
 43 
 44     FormDataElement() = default;
 45     explicit FormDataElement(Data&amp;&amp; data)
 46         : data(WTFMove(data)) { }
 47     explicit FormDataElement(Vector&lt;char&gt;&amp;&amp; array)
 48         : data(WTFMove(array)) { }
 49     FormDataElement(const String&amp; filename, int64_t fileStart, int64_t fileLength, Optional&lt;WallTime&gt; expectedFileModificationTime)
 50         : data(EncodedFileData { filename, fileStart, fileLength, expectedFileModificationTime }) { }
 51     explicit FormDataElement(const URL&amp; blobURL)
 52         : data(EncodedBlobData { blobURL }) { }
 53 
<span class="line-modified"> 54     uint64_t lengthInBytes(BlobRegistryImpl*) const;</span>
<span class="line-modified"> 55     uint64_t lengthInBytes(PAL::SessionID) const;</span>
 56 
 57     FormDataElement isolatedCopy() const;
 58 
 59     template&lt;typename Encoder&gt; void encode(Encoder&amp; encoder) const
 60     {
 61         encoder &lt;&lt; data;
 62     }
 63     template&lt;typename Decoder&gt; static Optional&lt;FormDataElement&gt; decode(Decoder&amp; decoder)
 64     {
 65         Optional&lt;Data&gt; data;
 66         decoder &gt;&gt; data;
 67         if (!data)
 68             return WTF::nullopt;
 69         return FormDataElement(WTFMove(*data));
 70     }
 71 
 72     struct EncodedFileData {
 73         String filename;
 74         int64_t fileStart { 0 };
 75         int64_t fileLength { 0 };
</pre>
<hr />
<pre>
204     // FIXME: Both these functions perform a deep copy of m_elements, but differ in handling of other data members.
205     // How much of that is intentional? We need better names that explain the difference.
206     Ref&lt;FormData&gt; copy() const;
207     WEBCORE_EXPORT Ref&lt;FormData&gt; isolatedCopy() const;
208 
209     template&lt;typename Encoder&gt;
210     void encode(Encoder&amp;) const;
211     template&lt;typename Decoder&gt;
212     static RefPtr&lt;FormData&gt; decode(Decoder&amp;);
213 
214     WEBCORE_EXPORT void appendData(const void* data, size_t);
215     void appendFile(const String&amp; filePath);
216     WEBCORE_EXPORT void appendFileRange(const String&amp; filename, long long start, long long length, Optional&lt;WallTime&gt; expectedModificationTime);
217     WEBCORE_EXPORT void appendBlob(const URL&amp; blobURL);
218 
219     WEBCORE_EXPORT Vector&lt;char&gt; flatten() const; // omits files
220     String flattenToString() const; // omits files
221 
222     // Resolve all blob references so we only have file and data.
223     // If the FormData has no blob references to resolve, this is returned.
<span class="line-modified">224     WEBCORE_EXPORT Ref&lt;FormData&gt; resolveBlobReferences(BlobRegistryImpl*);</span>
225 
226     WEBCORE_EXPORT FormDataForUpload prepareForUpload();
227 
228     bool isEmpty() const { return m_elements.isEmpty(); }
229     const Vector&lt;FormDataElement&gt;&amp; elements() const { return m_elements; }
230     const Vector&lt;char&gt;&amp; boundary() const { return m_boundary; }
231 
232     RefPtr&lt;SharedBuffer&gt; asSharedBuffer() const;
233 
234     bool alwaysStream() const { return m_alwaysStream; }
235     void setAlwaysStream(bool alwaysStream) { m_alwaysStream = alwaysStream; }
236 
237     // Identifies a particular form submission instance.  A value of 0 is used
238     // to indicate an unspecified identifier.
239     void setIdentifier(int64_t identifier) { m_identifier = identifier; }
240     int64_t identifier() const { return m_identifier; }
241 
242     bool containsPasswordData() const { return m_containsPasswordData; }
243     void setContainsPasswordData(bool containsPasswordData) { m_containsPasswordData = containsPasswordData; }
244 
245     static EncodingType parseEncodingType(const String&amp; type)
246     {
247         if (equalLettersIgnoringASCIICase(type, &quot;text/plain&quot;))
248             return TextPlain;
249         if (equalLettersIgnoringASCIICase(type, &quot;multipart/form-data&quot;))
250             return MultipartFormData;
251         return FormURLEncoded;
252     }
253 
<span class="line-modified">254     uint64_t lengthInBytes(PAL::SessionID) const;</span>
255 
256     WEBCORE_EXPORT URL asBlobURL() const;
257 
258 private:
259     FormData();
260     FormData(const FormData&amp;);
261 
262     void appendMultiPartFileValue(const File&amp;, Vector&lt;char&gt;&amp; header, TextEncoding&amp;);
263     void appendMultiPartStringValue(const String&amp;, Vector&lt;char&gt;&amp; header, TextEncoding&amp;);
264     void appendMultiPartKeyValuePairItems(const DOMFormData&amp;);
265     void appendNonMultiPartKeyValuePairItems(const DOMFormData&amp;, EncodingType);
266 
267     Vector&lt;FormDataElement&gt; m_elements;
268 
269     int64_t m_identifier { 0 };
270     bool m_alwaysStream { false };
271     Vector&lt;char&gt; m_boundary;
272     bool m_containsPasswordData { false };
273     mutable Optional&lt;uint64_t&gt; m_lengthInBytes;
274 };
</pre>
</td>
<td>
<hr />
<pre>
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB. If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 #pragma once
 21 
 22 #include &quot;BlobData.h&quot;

 23 #include &lt;wtf/Forward.h&gt;
 24 #include &lt;wtf/RefCounted.h&gt;
 25 #include &lt;wtf/URL.h&gt;
 26 #include &lt;wtf/Variant.h&gt;
 27 #include &lt;wtf/Vector.h&gt;
 28 #include &lt;wtf/text/WTFString.h&gt;
 29 
 30 namespace WebCore {
 31 
 32 class BlobRegistryImpl;
 33 class DOMFormData;
 34 class File;
 35 class SharedBuffer;
 36 class TextEncoding;
 37 
 38 struct FormDataElement {
 39     struct EncodedFileData;
 40     struct EncodedBlobData;
 41     using Data = Variant&lt;Vector&lt;char&gt;, EncodedFileData, EncodedBlobData&gt;;
 42 
 43     FormDataElement() = default;
 44     explicit FormDataElement(Data&amp;&amp; data)
 45         : data(WTFMove(data)) { }
 46     explicit FormDataElement(Vector&lt;char&gt;&amp;&amp; array)
 47         : data(WTFMove(array)) { }
 48     FormDataElement(const String&amp; filename, int64_t fileStart, int64_t fileLength, Optional&lt;WallTime&gt; expectedFileModificationTime)
 49         : data(EncodedFileData { filename, fileStart, fileLength, expectedFileModificationTime }) { }
 50     explicit FormDataElement(const URL&amp; blobURL)
 51         : data(EncodedBlobData { blobURL }) { }
 52 
<span class="line-modified"> 53     uint64_t lengthInBytes(const Function&lt;uint64_t(const URL&amp;)&gt;&amp;) const;</span>
<span class="line-modified"> 54     uint64_t lengthInBytes() const;</span>
 55 
 56     FormDataElement isolatedCopy() const;
 57 
 58     template&lt;typename Encoder&gt; void encode(Encoder&amp; encoder) const
 59     {
 60         encoder &lt;&lt; data;
 61     }
 62     template&lt;typename Decoder&gt; static Optional&lt;FormDataElement&gt; decode(Decoder&amp; decoder)
 63     {
 64         Optional&lt;Data&gt; data;
 65         decoder &gt;&gt; data;
 66         if (!data)
 67             return WTF::nullopt;
 68         return FormDataElement(WTFMove(*data));
 69     }
 70 
 71     struct EncodedFileData {
 72         String filename;
 73         int64_t fileStart { 0 };
 74         int64_t fileLength { 0 };
</pre>
<hr />
<pre>
203     // FIXME: Both these functions perform a deep copy of m_elements, but differ in handling of other data members.
204     // How much of that is intentional? We need better names that explain the difference.
205     Ref&lt;FormData&gt; copy() const;
206     WEBCORE_EXPORT Ref&lt;FormData&gt; isolatedCopy() const;
207 
208     template&lt;typename Encoder&gt;
209     void encode(Encoder&amp;) const;
210     template&lt;typename Decoder&gt;
211     static RefPtr&lt;FormData&gt; decode(Decoder&amp;);
212 
213     WEBCORE_EXPORT void appendData(const void* data, size_t);
214     void appendFile(const String&amp; filePath);
215     WEBCORE_EXPORT void appendFileRange(const String&amp; filename, long long start, long long length, Optional&lt;WallTime&gt; expectedModificationTime);
216     WEBCORE_EXPORT void appendBlob(const URL&amp; blobURL);
217 
218     WEBCORE_EXPORT Vector&lt;char&gt; flatten() const; // omits files
219     String flattenToString() const; // omits files
220 
221     // Resolve all blob references so we only have file and data.
222     // If the FormData has no blob references to resolve, this is returned.
<span class="line-modified">223     WEBCORE_EXPORT Ref&lt;FormData&gt; resolveBlobReferences(BlobRegistryImpl* = nullptr);</span>
224 
225     WEBCORE_EXPORT FormDataForUpload prepareForUpload();
226 
227     bool isEmpty() const { return m_elements.isEmpty(); }
228     const Vector&lt;FormDataElement&gt;&amp; elements() const { return m_elements; }
229     const Vector&lt;char&gt;&amp; boundary() const { return m_boundary; }
230 
231     RefPtr&lt;SharedBuffer&gt; asSharedBuffer() const;
232 
233     bool alwaysStream() const { return m_alwaysStream; }
234     void setAlwaysStream(bool alwaysStream) { m_alwaysStream = alwaysStream; }
235 
236     // Identifies a particular form submission instance.  A value of 0 is used
237     // to indicate an unspecified identifier.
238     void setIdentifier(int64_t identifier) { m_identifier = identifier; }
239     int64_t identifier() const { return m_identifier; }
240 
241     bool containsPasswordData() const { return m_containsPasswordData; }
242     void setContainsPasswordData(bool containsPasswordData) { m_containsPasswordData = containsPasswordData; }
243 
244     static EncodingType parseEncodingType(const String&amp; type)
245     {
246         if (equalLettersIgnoringASCIICase(type, &quot;text/plain&quot;))
247             return TextPlain;
248         if (equalLettersIgnoringASCIICase(type, &quot;multipart/form-data&quot;))
249             return MultipartFormData;
250         return FormURLEncoded;
251     }
252 
<span class="line-modified">253     uint64_t lengthInBytes() const;</span>
254 
255     WEBCORE_EXPORT URL asBlobURL() const;
256 
257 private:
258     FormData();
259     FormData(const FormData&amp;);
260 
261     void appendMultiPartFileValue(const File&amp;, Vector&lt;char&gt;&amp; header, TextEncoding&amp;);
262     void appendMultiPartStringValue(const String&amp;, Vector&lt;char&gt;&amp; header, TextEncoding&amp;);
263     void appendMultiPartKeyValuePairItems(const DOMFormData&amp;);
264     void appendNonMultiPartKeyValuePairItems(const DOMFormData&amp;, EncodingType);
265 
266     Vector&lt;FormDataElement&gt; m_elements;
267 
268     int64_t m_identifier { 0 };
269     bool m_alwaysStream { false };
270     Vector&lt;char&gt; m_boundary;
271     bool m_containsPasswordData { false };
272     mutable Optional&lt;uint64_t&gt; m_lengthInBytes;
273 };
</pre>
</td>
</tr>
</table>
<center><a href="FormData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FormDataBuilder.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
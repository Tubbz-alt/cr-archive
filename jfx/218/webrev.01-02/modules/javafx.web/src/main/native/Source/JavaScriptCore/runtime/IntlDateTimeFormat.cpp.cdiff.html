<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlDateTimeFormat.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IntlCollatorPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IntlDateTimeFormat.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlDateTimeFormat.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  /*
   * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
<span class="line-modified">!  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,8 ---</span>
  /*
   * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
<span class="line-modified">!  * Copyright (C) 2016-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 84,25 ***</span>
  {
      return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  }
  
  IntlDateTimeFormat::IntlDateTimeFormat(VM&amp; vm, Structure* structure)
<span class="line-modified">!     : JSDestructibleObject(vm, structure)</span>
  {
  }
  
  void IntlDateTimeFormat::finishCreation(VM&amp; vm)
  {
      Base::finishCreation(vm);
      ASSERT(inherits(vm, info()));
  }
  
<span class="line-removed">- void IntlDateTimeFormat::destroy(JSCell* cell)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     static_cast&lt;IntlDateTimeFormat*&gt;(cell)-&gt;IntlDateTimeFormat::~IntlDateTimeFormat();</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void IntlDateTimeFormat::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
  {
      IntlDateTimeFormat* thisObject = jsCast&lt;IntlDateTimeFormat*&gt;(cell);
      ASSERT_GC_OBJECT_INHERITS(thisObject, info());
  
<span class="line-new-header">--- 84,20 ---</span>
  {
      return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  }
  
  IntlDateTimeFormat::IntlDateTimeFormat(VM&amp; vm, Structure* structure)
<span class="line-modified">!     : Base(vm, structure)</span>
  {
  }
  
  void IntlDateTimeFormat::finishCreation(VM&amp; vm)
  {
      Base::finishCreation(vm);
      ASSERT(inherits(vm, info()));
  }
  
  void IntlDateTimeFormat::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
  {
      IntlDateTimeFormat* thisObject = jsCast&lt;IntlDateTimeFormat*&gt;(cell);
      ASSERT_GC_OBJECT_INHERITS(thisObject, info());
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 236,26 ***</span>
          ASSERT_NOT_REACHED();
      }
      return keyLocaleData;
  }
  
<span class="line-modified">! static JSObject* toDateTimeOptionsAnyDate(ExecState&amp; exec, JSValue originalOptions)</span>
  {
      // 12.1.1 ToDateTimeOptions abstract operation (ECMA-402 2.0)
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. If options is undefined, then let options be null, else let options be ToObject(options).
      // 2. ReturnIfAbrupt(options).
      // 3. Let options be ObjectCreate(options).
      JSObject* options;
      if (originalOptions.isUndefined())
<span class="line-modified">!         options = constructEmptyObject(&amp;exec, exec.lexicalGlobalObject()-&gt;nullPrototypeObjectStructure());</span>
      else {
<span class="line-modified">!         JSObject* originalToObject = originalOptions.toObject(&amp;exec);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!         options = constructEmptyObject(&amp;exec, originalToObject);</span>
      }
  
      // 4. Let needDefaults be true.
      bool needDefaults = true;
  
<span class="line-new-header">--- 231,26 ---</span>
          ASSERT_NOT_REACHED();
      }
      return keyLocaleData;
  }
  
<span class="line-modified">! static JSObject* toDateTimeOptionsAnyDate(JSGlobalObject* globalObject, JSValue originalOptions)</span>
  {
      // 12.1.1 ToDateTimeOptions abstract operation (ECMA-402 2.0)
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 1. If options is undefined, then let options be null, else let options be ToObject(options).
      // 2. ReturnIfAbrupt(options).
      // 3. Let options be ObjectCreate(options).
      JSObject* options;
      if (originalOptions.isUndefined())
<span class="line-modified">!         options = constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure());</span>
      else {
<span class="line-modified">!         JSObject* originalToObject = originalOptions.toObject(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, nullptr);
<span class="line-modified">!         options = constructEmptyObject(globalObject, originalToObject);</span>
      }
  
      // 4. Let needDefaults be true.
      bool needDefaults = true;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 265,26 ***</span>
      // a. For each of the property names &quot;weekday&quot;, &quot;year&quot;, &quot;month&quot;, &quot;day&quot;:
      // i. Let prop be the property name.
      // ii. Let value be Get(options, prop).
      // iii. ReturnIfAbrupt(value).
      // iv. If value is not undefined, then let needDefaults be false.
<span class="line-modified">!     JSValue weekday = options-&gt;get(&amp;exec, vm.propertyNames-&gt;weekday);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!weekday.isUndefined())
          needDefaults = false;
  
<span class="line-modified">!     JSValue year = options-&gt;get(&amp;exec, vm.propertyNames-&gt;year);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!year.isUndefined())
          needDefaults = false;
  
<span class="line-modified">!     JSValue month = options-&gt;get(&amp;exec, vm.propertyNames-&gt;month);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!month.isUndefined())
          needDefaults = false;
  
<span class="line-modified">!     JSValue day = options-&gt;get(&amp;exec, vm.propertyNames-&gt;day);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!day.isUndefined())
          needDefaults = false;
  
      // 6. If required is &quot;time&quot; or &quot;any&quot;,
<span class="line-new-header">--- 260,26 ---</span>
      // a. For each of the property names &quot;weekday&quot;, &quot;year&quot;, &quot;month&quot;, &quot;day&quot;:
      // i. Let prop be the property name.
      // ii. Let value be Get(options, prop).
      // iii. ReturnIfAbrupt(value).
      // iv. If value is not undefined, then let needDefaults be false.
<span class="line-modified">!     JSValue weekday = options-&gt;get(globalObject, vm.propertyNames-&gt;weekday);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!weekday.isUndefined())
          needDefaults = false;
  
<span class="line-modified">!     JSValue year = options-&gt;get(globalObject, vm.propertyNames-&gt;year);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!year.isUndefined())
          needDefaults = false;
  
<span class="line-modified">!     JSValue month = options-&gt;get(globalObject, vm.propertyNames-&gt;month);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!month.isUndefined())
          needDefaults = false;
  
<span class="line-modified">!     JSValue day = options-&gt;get(globalObject, vm.propertyNames-&gt;day);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!day.isUndefined())
          needDefaults = false;
  
      // 6. If required is &quot;time&quot; or &quot;any&quot;,
</pre>
<hr />
<pre>
<span class="line-old-header">*** 293,21 ***</span>
      // a. For each of the property names &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;:
      // i. Let prop be the property name.
      // ii. Let value be Get(options, prop).
      // iii. ReturnIfAbrupt(value).
      // iv. If value is not undefined, then let needDefaults be false.
<span class="line-modified">!     JSValue hour = options-&gt;get(&amp;exec, vm.propertyNames-&gt;hour);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!hour.isUndefined())
          needDefaults = false;
  
<span class="line-modified">!     JSValue minute = options-&gt;get(&amp;exec, vm.propertyNames-&gt;minute);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!minute.isUndefined())
          needDefaults = false;
  
<span class="line-modified">!     JSValue second = options-&gt;get(&amp;exec, vm.propertyNames-&gt;second);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!second.isUndefined())
          needDefaults = false;
  
      // 7. If needDefaults is true and defaults is either &quot;date&quot; or &quot;all&quot;, then
<span class="line-new-header">--- 288,21 ---</span>
      // a. For each of the property names &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;:
      // i. Let prop be the property name.
      // ii. Let value be Get(options, prop).
      // iii. ReturnIfAbrupt(value).
      // iv. If value is not undefined, then let needDefaults be false.
<span class="line-modified">!     JSValue hour = options-&gt;get(globalObject, vm.propertyNames-&gt;hour);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!hour.isUndefined())
          needDefaults = false;
  
<span class="line-modified">!     JSValue minute = options-&gt;get(globalObject, vm.propertyNames-&gt;minute);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!minute.isUndefined())
          needDefaults = false;
  
<span class="line-modified">!     JSValue second = options-&gt;get(globalObject, vm.propertyNames-&gt;second);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      if (!second.isUndefined())
          needDefaults = false;
  
      // 7. If needDefaults is true and defaults is either &quot;date&quot; or &quot;all&quot;, then
</pre>
<hr />
<pre>
<span class="line-old-header">*** 439,50 ***</span>
              break;
          }
      }
  }
  
<span class="line-modified">! void IntlDateTimeFormat::initializeDateTimeFormat(ExecState&amp; exec, JSValue locales, JSValue originalOptions)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 12.1.1 InitializeDateTimeFormat (dateTimeFormat, locales, options) (ECMA-402)
      // https://tc39.github.io/ecma402/#sec-initializedatetimeformat
  
<span class="line-modified">!     Vector&lt;String&gt; requestedLocales = canonicalizeLocaleList(exec, locales);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!     JSObject* options = IntlDTFInternal::toDateTimeOptionsAnyDate(exec, originalOptions);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      HashMap&lt;String, String&gt; opt;
  
<span class="line-modified">!     String localeMatcher = intlStringOption(exec, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);</span>
      RETURN_IF_EXCEPTION(scope, void());
      opt.add(vm.propertyNames-&gt;localeMatcher.string(), localeMatcher);
  
      bool isHour12Undefined;
<span class="line-modified">!     bool hour12 = intlBooleanOption(exec, options, vm.propertyNames-&gt;hour12, isHour12Undefined);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!     String hourCycle = intlStringOption(exec, options, vm.propertyNames-&gt;hourCycle, { &quot;h11&quot;, &quot;h12&quot;, &quot;h23&quot;, &quot;h24&quot; }, &quot;hourCycle must be \&quot;h11\&quot;, \&quot;h12\&quot;, \&quot;h23\&quot;, or \&quot;h24\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (isHour12Undefined) {
          // Set hour12 here to simplify hour logic later.
          hour12 = (hourCycle == &quot;h11&quot; || hourCycle == &quot;h12&quot;);
          if (!hourCycle.isNull())
              opt.add(&quot;hc&quot;_s, hourCycle);
      } else
          opt.add(&quot;hc&quot;_s, String());
  
<span class="line-modified">!     const HashSet&lt;String&gt; availableLocales = exec.jsCallee()-&gt;globalObject(vm)-&gt;intlDateTimeFormatAvailableLocales();</span>
<span class="line-modified">!     HashMap&lt;String, String&gt; resolved = resolveLocale(exec, availableLocales, requestedLocales, opt, IntlDTFInternal::relevantExtensionKeys, WTF_ARRAY_LENGTH(IntlDTFInternal::relevantExtensionKeys), IntlDTFInternal::localeData);</span>
  
      m_locale = resolved.get(vm.propertyNames-&gt;locale.string());
      if (m_locale.isEmpty()) {
<span class="line-modified">!         throwTypeError(&amp;exec, scope, &quot;failed to initialize DateTimeFormat due to invalid locale&quot;_s);</span>
          return;
      }
  
      m_calendar = resolved.get(&quot;ca&quot;_s);
      if (m_calendar == &quot;gregorian&quot;)
<span class="line-new-header">--- 434,50 ---</span>
              break;
          }
      }
  }
  
<span class="line-modified">! void IntlDateTimeFormat::initializeDateTimeFormat(JSGlobalObject* globalObject, JSValue locales, JSValue originalOptions)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 12.1.1 InitializeDateTimeFormat (dateTimeFormat, locales, options) (ECMA-402)
      // https://tc39.github.io/ecma402/#sec-initializedatetimeformat
  
<span class="line-modified">!     Vector&lt;String&gt; requestedLocales = canonicalizeLocaleList(globalObject, locales);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!     JSObject* options = IntlDTFInternal::toDateTimeOptionsAnyDate(globalObject, originalOptions);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      HashMap&lt;String, String&gt; opt;
  
<span class="line-modified">!     String localeMatcher = intlStringOption(globalObject, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);</span>
      RETURN_IF_EXCEPTION(scope, void());
      opt.add(vm.propertyNames-&gt;localeMatcher.string(), localeMatcher);
  
      bool isHour12Undefined;
<span class="line-modified">!     bool hour12 = intlBooleanOption(globalObject, options, vm.propertyNames-&gt;hour12, isHour12Undefined);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!     String hourCycle = intlStringOption(globalObject, options, vm.propertyNames-&gt;hourCycle, { &quot;h11&quot;, &quot;h12&quot;, &quot;h23&quot;, &quot;h24&quot; }, &quot;hourCycle must be \&quot;h11\&quot;, \&quot;h12\&quot;, \&quot;h23\&quot;, or \&quot;h24\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (isHour12Undefined) {
          // Set hour12 here to simplify hour logic later.
          hour12 = (hourCycle == &quot;h11&quot; || hourCycle == &quot;h12&quot;);
          if (!hourCycle.isNull())
              opt.add(&quot;hc&quot;_s, hourCycle);
      } else
          opt.add(&quot;hc&quot;_s, String());
  
<span class="line-modified">!     const HashSet&lt;String&gt;&amp; availableLocales = intlDateTimeFormatAvailableLocales();</span>
<span class="line-modified">!     HashMap&lt;String, String&gt; resolved = resolveLocale(globalObject, availableLocales, requestedLocales, opt, IntlDTFInternal::relevantExtensionKeys, WTF_ARRAY_LENGTH(IntlDTFInternal::relevantExtensionKeys), IntlDTFInternal::localeData);</span>
  
      m_locale = resolved.get(vm.propertyNames-&gt;locale.string());
      if (m_locale.isEmpty()) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;failed to initialize DateTimeFormat due to invalid locale&quot;_s);</span>
          return;
      }
  
      m_calendar = resolved.get(&quot;ca&quot;_s);
      if (m_calendar == &quot;gregorian&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 494,19 ***</span>
  
      m_hourCycle = resolved.get(&quot;hc&quot;_s);
      m_numberingSystem = resolved.get(&quot;nu&quot;_s);
      String dataLocale = resolved.get(&quot;dataLocale&quot;_s);
  
<span class="line-modified">!     JSValue tzValue = options-&gt;get(&amp;exec, vm.propertyNames-&gt;timeZone);</span>
      RETURN_IF_EXCEPTION(scope, void());
      String tz;
      if (!tzValue.isUndefined()) {
<span class="line-modified">!         String originalTz = tzValue.toWTFString(&amp;exec);</span>
          RETURN_IF_EXCEPTION(scope, void());
          tz = canonicalizeTimeZoneName(originalTz);
          if (tz.isNull()) {
<span class="line-modified">!             throwRangeError(&amp;exec, scope, &quot;invalid time zone: &quot; + originalTz);</span>
              return;
          }
      } else
          tz = defaultTimeZone();
      m_timeZone = tz;
<span class="line-new-header">--- 489,19 ---</span>
  
      m_hourCycle = resolved.get(&quot;hc&quot;_s);
      m_numberingSystem = resolved.get(&quot;nu&quot;_s);
      String dataLocale = resolved.get(&quot;dataLocale&quot;_s);
  
<span class="line-modified">!     JSValue tzValue = options-&gt;get(globalObject, vm.propertyNames-&gt;timeZone);</span>
      RETURN_IF_EXCEPTION(scope, void());
      String tz;
      if (!tzValue.isUndefined()) {
<span class="line-modified">!         String originalTz = tzValue.toWTFString(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, void());
          tz = canonicalizeTimeZoneName(originalTz);
          if (tz.isNull()) {
<span class="line-modified">!             throwRangeError(globalObject, scope, &quot;invalid time zone: &quot; + originalTz);</span>
              return;
          }
      } else
          tz = defaultTimeZone();
      m_timeZone = tz;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 515,42 ***</span>
      auto narrowShortLong = { &quot;narrow&quot;, &quot;short&quot;, &quot;long&quot; };
      auto twoDigitNumeric = { &quot;2-digit&quot;, &quot;numeric&quot; };
      auto twoDigitNumericNarrowShortLong = { &quot;2-digit&quot;, &quot;numeric&quot;, &quot;narrow&quot;, &quot;short&quot;, &quot;long&quot; };
      auto shortLong = { &quot;short&quot;, &quot;long&quot; };
  
<span class="line-modified">!     String weekday = intlStringOption(exec, options, vm.propertyNames-&gt;weekday, narrowShortLong, &quot;weekday must be \&quot;narrow\&quot;, \&quot;short\&quot;, or \&quot;long\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!weekday.isNull()) {
          if (weekday == &quot;narrow&quot;)
              skeletonBuilder.appendLiteral(&quot;EEEEE&quot;);
          else if (weekday == &quot;short&quot;)
              skeletonBuilder.appendLiteral(&quot;EEE&quot;);
          else if (weekday == &quot;long&quot;)
              skeletonBuilder.appendLiteral(&quot;EEEE&quot;);
      }
  
<span class="line-modified">!     String era = intlStringOption(exec, options, vm.propertyNames-&gt;era, narrowShortLong, &quot;era must be \&quot;narrow\&quot;, \&quot;short\&quot;, or \&quot;long\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!era.isNull()) {
          if (era == &quot;narrow&quot;)
              skeletonBuilder.appendLiteral(&quot;GGGGG&quot;);
          else if (era == &quot;short&quot;)
              skeletonBuilder.appendLiteral(&quot;GGG&quot;);
          else if (era == &quot;long&quot;)
              skeletonBuilder.appendLiteral(&quot;GGGG&quot;);
      }
  
<span class="line-modified">!     String year = intlStringOption(exec, options, vm.propertyNames-&gt;year, twoDigitNumeric, &quot;year must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!year.isNull()) {
          if (year == &quot;2-digit&quot;)
              skeletonBuilder.appendLiteral(&quot;yy&quot;);
          else if (year == &quot;numeric&quot;)
              skeletonBuilder.append(&#39;y&#39;);
      }
  
<span class="line-modified">!     String month = intlStringOption(exec, options, vm.propertyNames-&gt;month, twoDigitNumericNarrowShortLong, &quot;month must be \&quot;2-digit\&quot;, \&quot;numeric\&quot;, \&quot;narrow\&quot;, \&quot;short\&quot;, or \&quot;long\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!month.isNull()) {
          if (month == &quot;2-digit&quot;)
              skeletonBuilder.appendLiteral(&quot;MM&quot;);
          else if (month == &quot;numeric&quot;)
<span class="line-new-header">--- 510,42 ---</span>
      auto narrowShortLong = { &quot;narrow&quot;, &quot;short&quot;, &quot;long&quot; };
      auto twoDigitNumeric = { &quot;2-digit&quot;, &quot;numeric&quot; };
      auto twoDigitNumericNarrowShortLong = { &quot;2-digit&quot;, &quot;numeric&quot;, &quot;narrow&quot;, &quot;short&quot;, &quot;long&quot; };
      auto shortLong = { &quot;short&quot;, &quot;long&quot; };
  
<span class="line-modified">!     String weekday = intlStringOption(globalObject, options, vm.propertyNames-&gt;weekday, narrowShortLong, &quot;weekday must be \&quot;narrow\&quot;, \&quot;short\&quot;, or \&quot;long\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!weekday.isNull()) {
          if (weekday == &quot;narrow&quot;)
              skeletonBuilder.appendLiteral(&quot;EEEEE&quot;);
          else if (weekday == &quot;short&quot;)
              skeletonBuilder.appendLiteral(&quot;EEE&quot;);
          else if (weekday == &quot;long&quot;)
              skeletonBuilder.appendLiteral(&quot;EEEE&quot;);
      }
  
<span class="line-modified">!     String era = intlStringOption(globalObject, options, vm.propertyNames-&gt;era, narrowShortLong, &quot;era must be \&quot;narrow\&quot;, \&quot;short\&quot;, or \&quot;long\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!era.isNull()) {
          if (era == &quot;narrow&quot;)
              skeletonBuilder.appendLiteral(&quot;GGGGG&quot;);
          else if (era == &quot;short&quot;)
              skeletonBuilder.appendLiteral(&quot;GGG&quot;);
          else if (era == &quot;long&quot;)
              skeletonBuilder.appendLiteral(&quot;GGGG&quot;);
      }
  
<span class="line-modified">!     String year = intlStringOption(globalObject, options, vm.propertyNames-&gt;year, twoDigitNumeric, &quot;year must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!year.isNull()) {
          if (year == &quot;2-digit&quot;)
              skeletonBuilder.appendLiteral(&quot;yy&quot;);
          else if (year == &quot;numeric&quot;)
              skeletonBuilder.append(&#39;y&#39;);
      }
  
<span class="line-modified">!     String month = intlStringOption(globalObject, options, vm.propertyNames-&gt;month, twoDigitNumericNarrowShortLong, &quot;month must be \&quot;2-digit\&quot;, \&quot;numeric\&quot;, \&quot;narrow\&quot;, \&quot;short\&quot;, or \&quot;long\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!month.isNull()) {
          if (month == &quot;2-digit&quot;)
              skeletonBuilder.appendLiteral(&quot;MM&quot;);
          else if (month == &quot;numeric&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 561,20 ***</span>
              skeletonBuilder.appendLiteral(&quot;MMM&quot;);
          else if (month == &quot;long&quot;)
              skeletonBuilder.appendLiteral(&quot;MMMM&quot;);
      }
  
<span class="line-modified">!     String day = intlStringOption(exec, options, vm.propertyNames-&gt;day, twoDigitNumeric, &quot;day must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!day.isNull()) {
          if (day == &quot;2-digit&quot;)
              skeletonBuilder.appendLiteral(&quot;dd&quot;);
          else if (day == &quot;numeric&quot;)
              skeletonBuilder.append(&#39;d&#39;);
      }
  
<span class="line-modified">!     String hour = intlStringOption(exec, options, vm.propertyNames-&gt;hour, twoDigitNumeric, &quot;hour must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (hour == &quot;2-digit&quot;) {
          if (isHour12Undefined &amp;&amp; m_hourCycle.isNull())
              skeletonBuilder.appendLiteral(&quot;jj&quot;);
          else if (hour12)
<span class="line-new-header">--- 556,20 ---</span>
              skeletonBuilder.appendLiteral(&quot;MMM&quot;);
          else if (month == &quot;long&quot;)
              skeletonBuilder.appendLiteral(&quot;MMMM&quot;);
      }
  
<span class="line-modified">!     String day = intlStringOption(globalObject, options, vm.propertyNames-&gt;day, twoDigitNumeric, &quot;day must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!day.isNull()) {
          if (day == &quot;2-digit&quot;)
              skeletonBuilder.appendLiteral(&quot;dd&quot;);
          else if (day == &quot;numeric&quot;)
              skeletonBuilder.append(&#39;d&#39;);
      }
  
<span class="line-modified">!     String hour = intlStringOption(globalObject, options, vm.propertyNames-&gt;hour, twoDigitNumeric, &quot;hour must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (hour == &quot;2-digit&quot;) {
          if (isHour12Undefined &amp;&amp; m_hourCycle.isNull())
              skeletonBuilder.appendLiteral(&quot;jj&quot;);
          else if (hour12)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 589,45 ***</span>
          else
              skeletonBuilder.append(&#39;H&#39;);
      } else
          m_hourCycle = String();
  
<span class="line-modified">!     String minute = intlStringOption(exec, options, vm.propertyNames-&gt;minute, twoDigitNumeric, &quot;minute must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!minute.isNull()) {
          if (minute == &quot;2-digit&quot;)
              skeletonBuilder.appendLiteral(&quot;mm&quot;);
          else if (minute == &quot;numeric&quot;)
              skeletonBuilder.append(&#39;m&#39;);
      }
  
<span class="line-modified">!     String second = intlStringOption(exec, options, vm.propertyNames-&gt;second, twoDigitNumeric, &quot;second must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!second.isNull()) {
          if (second == &quot;2-digit&quot;)
              skeletonBuilder.appendLiteral(&quot;ss&quot;);
          else if (second == &quot;numeric&quot;)
              skeletonBuilder.append(&#39;s&#39;);
      }
  
<span class="line-modified">!     String timeZoneName = intlStringOption(exec, options, vm.propertyNames-&gt;timeZoneName, shortLong, &quot;timeZoneName must be \&quot;short\&quot; or \&quot;long\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!timeZoneName.isNull()) {
          if (timeZoneName == &quot;short&quot;)
              skeletonBuilder.append(&#39;z&#39;);
          else if (timeZoneName == &quot;long&quot;)
              skeletonBuilder.appendLiteral(&quot;zzzz&quot;);
      }
  
<span class="line-modified">!     intlStringOption(exec, options, vm.propertyNames-&gt;formatMatcher, { &quot;basic&quot;, &quot;best fit&quot; }, &quot;formatMatcher must be either \&quot;basic\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      // Always use ICU date format generator, rather than our own pattern list and matcher.
      UErrorCode status = U_ZERO_ERROR;
      UDateTimePatternGenerator* generator = udatpg_open(dataLocale.utf8().data(), &amp;status);
      if (U_FAILURE(status)) {
<span class="line-modified">!         throwTypeError(&amp;exec, scope, &quot;failed to initialize DateTimeFormat&quot;_s);</span>
          return;
      }
  
      String skeleton = skeletonBuilder.toString();
      StringView skeletonView(skeleton);
<span class="line-new-header">--- 584,45 ---</span>
          else
              skeletonBuilder.append(&#39;H&#39;);
      } else
          m_hourCycle = String();
  
<span class="line-modified">!     String minute = intlStringOption(globalObject, options, vm.propertyNames-&gt;minute, twoDigitNumeric, &quot;minute must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!minute.isNull()) {
          if (minute == &quot;2-digit&quot;)
              skeletonBuilder.appendLiteral(&quot;mm&quot;);
          else if (minute == &quot;numeric&quot;)
              skeletonBuilder.append(&#39;m&#39;);
      }
  
<span class="line-modified">!     String second = intlStringOption(globalObject, options, vm.propertyNames-&gt;second, twoDigitNumeric, &quot;second must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!second.isNull()) {
          if (second == &quot;2-digit&quot;)
              skeletonBuilder.appendLiteral(&quot;ss&quot;);
          else if (second == &quot;numeric&quot;)
              skeletonBuilder.append(&#39;s&#39;);
      }
  
<span class="line-modified">!     String timeZoneName = intlStringOption(globalObject, options, vm.propertyNames-&gt;timeZoneName, shortLong, &quot;timeZoneName must be \&quot;short\&quot; or \&quot;long\&quot;&quot;, nullptr);</span>
      RETURN_IF_EXCEPTION(scope, void());
      if (!timeZoneName.isNull()) {
          if (timeZoneName == &quot;short&quot;)
              skeletonBuilder.append(&#39;z&#39;);
          else if (timeZoneName == &quot;long&quot;)
              skeletonBuilder.appendLiteral(&quot;zzzz&quot;);
      }
  
<span class="line-modified">!     intlStringOption(globalObject, options, vm.propertyNames-&gt;formatMatcher, { &quot;basic&quot;, &quot;best fit&quot; }, &quot;formatMatcher must be either \&quot;basic\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);</span>
      RETURN_IF_EXCEPTION(scope, void());
  
      // Always use ICU date format generator, rather than our own pattern list and matcher.
      UErrorCode status = U_ZERO_ERROR;
      UDateTimePatternGenerator* generator = udatpg_open(dataLocale.utf8().data(), &amp;status);
      if (U_FAILURE(status)) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;failed to initialize DateTimeFormat&quot;_s);</span>
          return;
      }
  
      String skeleton = skeletonBuilder.toString();
      StringView skeletonView(skeleton);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 639,11 ***</span>
          patternBuffer.grow(patternLength);
          udatpg_getBestPattern(generator, skeletonView.upconvertedCharacters(), skeletonView.length(), patternBuffer.data(), patternLength, &amp;status);
      }
      udatpg_close(generator);
      if (U_FAILURE(status)) {
<span class="line-modified">!         throwTypeError(&amp;exec, scope, &quot;failed to initialize DateTimeFormat&quot;_s);</span>
          return;
      }
  
      // Enforce our hourCycle, replacing hour characters in pattern.
      if (!m_hourCycle.isNull()) {
<span class="line-new-header">--- 634,11 ---</span>
          patternBuffer.grow(patternLength);
          udatpg_getBestPattern(generator, skeletonView.upconvertedCharacters(), skeletonView.length(), patternBuffer.data(), patternLength, &amp;status);
      }
      udatpg_close(generator);
      if (U_FAILURE(status)) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;failed to initialize DateTimeFormat&quot;_s);</span>
          return;
      }
  
      // Enforce our hourCycle, replacing hour characters in pattern.
      if (!m_hourCycle.isNull()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 675,11 ***</span>
  
      status = U_ZERO_ERROR;
      StringView timeZoneView(m_timeZone);
      m_dateFormat = std::unique_ptr&lt;UDateFormat, UDateFormatDeleter&gt;(udat_open(UDAT_PATTERN, UDAT_PATTERN, m_locale.utf8().data(), timeZoneView.upconvertedCharacters(), timeZoneView.length(), pattern.upconvertedCharacters(), pattern.length(), &amp;status));
      if (U_FAILURE(status)) {
<span class="line-modified">!         throwTypeError(&amp;exec, scope, &quot;failed to initialize DateTimeFormat&quot;_s);</span>
          return;
      }
  
      // Gregorian calendar should be used from the beginning of ECMAScript time.
      // Failure here means unsupported calendar, and can safely be ignored.
<span class="line-new-header">--- 670,11 ---</span>
  
      status = U_ZERO_ERROR;
      StringView timeZoneView(m_timeZone);
      m_dateFormat = std::unique_ptr&lt;UDateFormat, UDateFormatDeleter&gt;(udat_open(UDAT_PATTERN, UDAT_PATTERN, m_locale.utf8().data(), timeZoneView.upconvertedCharacters(), timeZoneView.length(), pattern.upconvertedCharacters(), pattern.length(), &amp;status));
      if (U_FAILURE(status)) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;failed to initialize DateTimeFormat&quot;_s);</span>
          return;
      }
  
      // Gregorian calendar should be used from the beginning of ECMAScript time.
      // Failure here means unsupported calendar, and can safely be ignored.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 832,29 ***</span>
      }
      ASSERT_NOT_REACHED();
      return ASCIILiteral::null();
  }
  
<span class="line-modified">! JSObject* IntlDateTimeFormat::resolvedOptions(ExecState&amp; exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 12.3.5 Intl.DateTimeFormat.prototype.resolvedOptions() (ECMA-402 2.0)
      // The function returns a new object whose properties and attributes are set as if constructed by an object literal assigning to each of the following properties the value of the corresponding internal slot of this DateTimeFormat object (see 12.4): locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day, hour, minute, second, and timeZoneName. Properties whose corresponding internal slots are not present are not assigned.
      // Note: In this version of the ECMAScript 2015 Internationalization API, the timeZone property will be the name of the default time zone if no timeZone property was provided in the options object provided to the Intl.DateTimeFormat constructor. The previous version left the timeZone property undefined in this case.
      if (!m_initializedDateTimeFormat) {
<span class="line-modified">!         initializeDateTimeFormat(exec, jsUndefined(), jsUndefined());</span>
          scope.assertNoException();
      }
  
<span class="line-modified">!     JSObject* options = constructEmptyObject(&amp;exec);</span>
      options-&gt;putDirect(vm, vm.propertyNames-&gt;locale, jsNontrivialString(vm, m_locale));
      options-&gt;putDirect(vm, vm.propertyNames-&gt;calendar, jsNontrivialString(vm, m_calendar));
      options-&gt;putDirect(vm, vm.propertyNames-&gt;numberingSystem, jsNontrivialString(vm, m_numberingSystem));
      options-&gt;putDirect(vm, vm.propertyNames-&gt;timeZone, jsNontrivialString(vm, m_timeZone));
  
      if (m_weekday != Weekday::None)
          options-&gt;putDirect(vm, vm.propertyNames-&gt;weekday, jsNontrivialString(vm, weekdayString(m_weekday)));
  
      if (m_era != Era::None)
          options-&gt;putDirect(vm, vm.propertyNames-&gt;era, jsNontrivialString(vm, eraString(m_era)));
<span class="line-new-header">--- 827,34 ---</span>
      }
      ASSERT_NOT_REACHED();
      return ASCIILiteral::null();
  }
  
<span class="line-modified">! JSObject* IntlDateTimeFormat::resolvedOptions(JSGlobalObject* globalObject)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 12.3.5 Intl.DateTimeFormat.prototype.resolvedOptions() (ECMA-402 2.0)
      // The function returns a new object whose properties and attributes are set as if constructed by an object literal assigning to each of the following properties the value of the corresponding internal slot of this DateTimeFormat object (see 12.4): locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day, hour, minute, second, and timeZoneName. Properties whose corresponding internal slots are not present are not assigned.
      // Note: In this version of the ECMAScript 2015 Internationalization API, the timeZone property will be the name of the default time zone if no timeZone property was provided in the options object provided to the Intl.DateTimeFormat constructor. The previous version left the timeZone property undefined in this case.
      if (!m_initializedDateTimeFormat) {
<span class="line-modified">!         initializeDateTimeFormat(globalObject, jsUndefined(), jsUndefined());</span>
          scope.assertNoException();
      }
  
<span class="line-modified">!     JSObject* options = constructEmptyObject(globalObject);</span>
      options-&gt;putDirect(vm, vm.propertyNames-&gt;locale, jsNontrivialString(vm, m_locale));
      options-&gt;putDirect(vm, vm.propertyNames-&gt;calendar, jsNontrivialString(vm, m_calendar));
      options-&gt;putDirect(vm, vm.propertyNames-&gt;numberingSystem, jsNontrivialString(vm, m_numberingSystem));
      options-&gt;putDirect(vm, vm.propertyNames-&gt;timeZone, jsNontrivialString(vm, m_timeZone));
  
<span class="line-added">+     if (!m_hourCycle.isNull()) {</span>
<span class="line-added">+         options-&gt;putDirect(vm, vm.propertyNames-&gt;hourCycle, jsNontrivialString(vm, m_hourCycle));</span>
<span class="line-added">+         options-&gt;putDirect(vm, vm.propertyNames-&gt;hour12, jsBoolean(m_hourCycle == &quot;h11&quot; || m_hourCycle == &quot;h12&quot;));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
      if (m_weekday != Weekday::None)
          options-&gt;putDirect(vm, vm.propertyNames-&gt;weekday, jsNontrivialString(vm, weekdayString(m_weekday)));
  
      if (m_era != Era::None)
          options-&gt;putDirect(vm, vm.propertyNames-&gt;era, jsNontrivialString(vm, eraString(m_era)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 869,15 ***</span>
          options-&gt;putDirect(vm, vm.propertyNames-&gt;day, jsNontrivialString(vm, dayString(m_day)));
  
      if (m_hour != Hour::None)
          options-&gt;putDirect(vm, vm.propertyNames-&gt;hour, jsNontrivialString(vm, hourString(m_hour)));
  
<span class="line-removed">-     if (!m_hourCycle.isNull()) {</span>
<span class="line-removed">-         options-&gt;putDirect(vm, vm.propertyNames-&gt;hourCycle, jsNontrivialString(vm, m_hourCycle));</span>
<span class="line-removed">-         options-&gt;putDirect(vm, vm.propertyNames-&gt;hour12, jsBoolean(m_hourCycle == &quot;h11&quot; || m_hourCycle == &quot;h12&quot;));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      if (m_minute != Minute::None)
          options-&gt;putDirect(vm, vm.propertyNames-&gt;minute, jsNontrivialString(vm, minuteString(m_minute)));
  
      if (m_second != Second::None)
          options-&gt;putDirect(vm, vm.propertyNames-&gt;second, jsNontrivialString(vm, secondString(m_second)));
<span class="line-new-header">--- 869,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 886,24 ***</span>
          options-&gt;putDirect(vm, vm.propertyNames-&gt;timeZoneName, jsNontrivialString(vm, timeZoneNameString(m_timeZoneName)));
  
      return options;
  }
  
<span class="line-modified">! JSValue IntlDateTimeFormat::format(ExecState&amp; exec, double value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 12.3.4 FormatDateTime abstract operation (ECMA-402 2.0)
      if (!m_initializedDateTimeFormat) {
<span class="line-modified">!         initializeDateTimeFormat(exec, jsUndefined(), jsUndefined());</span>
          scope.assertNoException();
      }
  
      // 1. If x is not a finite Number, then throw a RangeError exception.
      if (!std::isfinite(value))
<span class="line-modified">!         return throwRangeError(&amp;exec, scope, &quot;date value is not finite in DateTimeFormat format()&quot;_s);</span>
  
      // Delegate remaining steps to ICU.
      UErrorCode status = U_ZERO_ERROR;
      Vector&lt;UChar, 32&gt; result(32);
      auto resultLength = udat_format(m_dateFormat.get(), value, result.data(), result.size(), nullptr, &amp;status);
<span class="line-new-header">--- 881,24 ---</span>
          options-&gt;putDirect(vm, vm.propertyNames-&gt;timeZoneName, jsNontrivialString(vm, timeZoneNameString(m_timeZoneName)));
  
      return options;
  }
  
<span class="line-modified">! JSValue IntlDateTimeFormat::format(JSGlobalObject* globalObject, double value)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 12.3.4 FormatDateTime abstract operation (ECMA-402 2.0)
      if (!m_initializedDateTimeFormat) {
<span class="line-modified">!         initializeDateTimeFormat(globalObject, jsUndefined(), jsUndefined());</span>
          scope.assertNoException();
      }
  
      // 1. If x is not a finite Number, then throw a RangeError exception.
      if (!std::isfinite(value))
<span class="line-modified">!         return throwRangeError(globalObject, scope, &quot;date value is not finite in DateTimeFormat format()&quot;_s);</span>
  
      // Delegate remaining steps to ICU.
      UErrorCode status = U_ZERO_ERROR;
      Vector&lt;UChar, 32&gt; result(32);
      auto resultLength = udat_format(m_dateFormat.get(), value, result.data(), result.size(), nullptr, &amp;status);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 911,11 ***</span>
          status = U_ZERO_ERROR;
          result.grow(resultLength);
          udat_format(m_dateFormat.get(), value, result.data(), resultLength, nullptr, &amp;status);
      }
      if (U_FAILURE(status))
<span class="line-modified">!         return throwTypeError(&amp;exec, scope, &quot;failed to format date value&quot;_s);</span>
  
      return jsString(vm, String(result.data(), resultLength));
  }
  
  #if JSC_ICU_HAS_UFIELDPOSITER
<span class="line-new-header">--- 906,11 ---</span>
          status = U_ZERO_ERROR;
          result.grow(resultLength);
          udat_format(m_dateFormat.get(), value, result.data(), resultLength, nullptr, &amp;status);
      }
      if (U_FAILURE(status))
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;failed to format date value&quot;_s);</span>
  
      return jsString(vm, String(result.data(), resultLength));
  }
  
  #if JSC_ICU_HAS_UFIELDPOSITER
</pre>
<hr />
<pre>
<span class="line-old-header">*** 983,45 ***</span>
      }
      return &quot;unknown&quot;_s;
  }
  
  
<span class="line-modified">! JSValue IntlDateTimeFormat::formatToParts(ExecState&amp; exec, double value)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec.vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 12.1.8 FormatDateTimeToParts (ECMA-402 4.0)
      // https://tc39.github.io/ecma402/#sec-formatdatetimetoparts
  
      if (!std::isfinite(value))
<span class="line-modified">!         return throwRangeError(&amp;exec, scope, &quot;date value is not finite in DateTimeFormat formatToParts()&quot;_s);</span>
  
      UErrorCode status = U_ZERO_ERROR;
      auto fields = std::unique_ptr&lt;UFieldPositionIterator, UFieldPositionIteratorDeleter&gt;(ufieldpositer_open(&amp;status));
      if (U_FAILURE(status))
<span class="line-modified">!         return throwTypeError(&amp;exec, scope, &quot;failed to open field position iterator&quot;_s);</span>
  
      status = U_ZERO_ERROR;
      Vector&lt;UChar, 32&gt; result(32);
      auto resultLength = udat_formatForFields(m_dateFormat.get(), value, result.data(), result.size(), fields.get(), &amp;status);
      if (status == U_BUFFER_OVERFLOW_ERROR) {
          status = U_ZERO_ERROR;
          result.grow(resultLength);
          udat_formatForFields(m_dateFormat.get(), value, result.data(), resultLength, fields.get(), &amp;status);
      }
      if (U_FAILURE(status))
<span class="line-modified">!         return throwTypeError(&amp;exec, scope, &quot;failed to format date value&quot;_s);</span>
  
<span class="line-removed">-     JSGlobalObject* globalObject = exec.jsCallee()-&gt;globalObject(vm);</span>
      JSArray* parts = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), 0);
      if (!parts)
<span class="line-modified">!         return throwOutOfMemoryError(&amp;exec, scope);</span>
  
      auto resultString = String(result.data(), resultLength);
      auto typePropertyName = Identifier::fromString(vm, &quot;type&quot;);
<span class="line-modified">!     auto literalString = jsString(vm, &quot;literal&quot;_s);</span>
  
      int32_t previousEndIndex = 0;
      int32_t beginIndex = 0;
      int32_t endIndex = 0;
      while (previousEndIndex &lt; resultLength) {
<span class="line-new-header">--- 978,44 ---</span>
      }
      return &quot;unknown&quot;_s;
  }
  
  
<span class="line-modified">! JSValue IntlDateTimeFormat::formatToParts(JSGlobalObject* globalObject, double value)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      // 12.1.8 FormatDateTimeToParts (ECMA-402 4.0)
      // https://tc39.github.io/ecma402/#sec-formatdatetimetoparts
  
      if (!std::isfinite(value))
<span class="line-modified">!         return throwRangeError(globalObject, scope, &quot;date value is not finite in DateTimeFormat formatToParts()&quot;_s);</span>
  
      UErrorCode status = U_ZERO_ERROR;
      auto fields = std::unique_ptr&lt;UFieldPositionIterator, UFieldPositionIteratorDeleter&gt;(ufieldpositer_open(&amp;status));
      if (U_FAILURE(status))
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;failed to open field position iterator&quot;_s);</span>
  
      status = U_ZERO_ERROR;
      Vector&lt;UChar, 32&gt; result(32);
      auto resultLength = udat_formatForFields(m_dateFormat.get(), value, result.data(), result.size(), fields.get(), &amp;status);
      if (status == U_BUFFER_OVERFLOW_ERROR) {
          status = U_ZERO_ERROR;
          result.grow(resultLength);
          udat_formatForFields(m_dateFormat.get(), value, result.data(), resultLength, fields.get(), &amp;status);
      }
      if (U_FAILURE(status))
<span class="line-modified">!         return throwTypeError(globalObject, scope, &quot;failed to format date value&quot;_s);</span>
  
      JSArray* parts = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), 0);
      if (!parts)
<span class="line-modified">!         return throwOutOfMemoryError(globalObject, scope);</span>
  
      auto resultString = String(result.data(), resultLength);
      auto typePropertyName = Identifier::fromString(vm, &quot;type&quot;);
<span class="line-modified">!     auto literalString = jsNontrivialString(vm, &quot;literal&quot;_s);</span>
  
      int32_t previousEndIndex = 0;
      int32_t beginIndex = 0;
      int32_t endIndex = 0;
      while (previousEndIndex &lt; resultLength) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1029,25 ***</span>
          if (fieldType &lt; 0)
              beginIndex = endIndex = resultLength;
  
          if (previousEndIndex &lt; beginIndex) {
              auto value = jsString(vm, resultString.substring(previousEndIndex, beginIndex - previousEndIndex));
<span class="line-modified">!             JSObject* part = constructEmptyObject(&amp;exec);</span>
              part-&gt;putDirect(vm, typePropertyName, literalString);
              part-&gt;putDirect(vm, vm.propertyNames-&gt;value, value);
<span class="line-modified">!             parts-&gt;push(&amp;exec, part);</span>
              RETURN_IF_EXCEPTION(scope, { });
          }
          previousEndIndex = endIndex;
  
          if (fieldType &gt;= 0) {
              auto type = jsString(vm, partTypeString(UDateFormatField(fieldType)));
              auto value = jsString(vm, resultString.substring(beginIndex, endIndex - beginIndex));
<span class="line-modified">!             JSObject* part = constructEmptyObject(&amp;exec);</span>
              part-&gt;putDirect(vm, typePropertyName, type);
              part-&gt;putDirect(vm, vm.propertyNames-&gt;value, value);
<span class="line-modified">!             parts-&gt;push(&amp;exec, part);</span>
              RETURN_IF_EXCEPTION(scope, { });
          }
      }
  
  
<span class="line-new-header">--- 1023,25 ---</span>
          if (fieldType &lt; 0)
              beginIndex = endIndex = resultLength;
  
          if (previousEndIndex &lt; beginIndex) {
              auto value = jsString(vm, resultString.substring(previousEndIndex, beginIndex - previousEndIndex));
<span class="line-modified">!             JSObject* part = constructEmptyObject(globalObject);</span>
              part-&gt;putDirect(vm, typePropertyName, literalString);
              part-&gt;putDirect(vm, vm.propertyNames-&gt;value, value);
<span class="line-modified">!             parts-&gt;push(globalObject, part);</span>
              RETURN_IF_EXCEPTION(scope, { });
          }
          previousEndIndex = endIndex;
  
          if (fieldType &gt;= 0) {
              auto type = jsString(vm, partTypeString(UDateFormatField(fieldType)));
              auto value = jsString(vm, resultString.substring(beginIndex, endIndex - beginIndex));
<span class="line-modified">!             JSObject* part = constructEmptyObject(globalObject);</span>
              part-&gt;putDirect(vm, typePropertyName, type);
              part-&gt;putDirect(vm, vm.propertyNames-&gt;value, value);
<span class="line-modified">!             parts-&gt;push(globalObject, part);</span>
              RETURN_IF_EXCEPTION(scope, { });
          }
      }
  
  
</pre>
<center><a href="IntlCollatorPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IntlDateTimeFormat.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/CSSSelector.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSSegmentedFontFace.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSSelector.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/CSSSelector.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * License as published by the Free Software Foundation; either
 13  * version 2 of the License, or (at your option) any later version.
 14  *
 15  * This library is distributed in the hope that it will be useful,
 16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 18  * Library General Public License for more details.
 19  *
 20  * You should have received a copy of the GNU Library General Public License
 21  * along with this library; see the file COPYING.LIB.  If not, write to
 22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 23  * Boston, MA 02110-1301, USA.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CSSSelector.h&quot;
 28 
 29 #include &quot;CSSMarkup.h&quot;
 30 #include &quot;CSSSelectorList.h&quot;
 31 #include &quot;HTMLNames.h&quot;

 32 #include &quot;SelectorPseudoTypeMap.h&quot;
 33 #include &lt;wtf/Assertions.h&gt;
 34 #include &lt;wtf/StdLibExtras.h&gt;
 35 #include &lt;wtf/Vector.h&gt;
 36 #include &lt;wtf/text/AtomStringHash.h&gt;
 37 #include &lt;wtf/text/StringBuilder.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 using namespace HTMLNames;
 42 
 43 struct SameSizeAsCSSSelector {
 44     unsigned flags;
 45     void* unionPointer;
 46 };
 47 
 48 static_assert(CSSSelector::RelationType::Subselector == 0, &quot;Subselector must be 0 for consumeCombinator.&quot;);
 49 static_assert(sizeof(CSSSelector) == sizeof(SameSizeAsCSSSelector), &quot;CSSSelector should remain small.&quot;);
 50 


 51 CSSSelector::CSSSelector(const QualifiedName&amp; tagQName, bool tagIsForNamespaceRule)
 52     : m_relation(DescendantSpace)
 53     , m_match(Tag)
 54     , m_pseudoType(0)
 55     , m_isLastInSelectorList(false)
 56     , m_isLastInTagHistory(true)
 57     , m_hasRareData(false)
 58     , m_hasNameWithCase(false)
 59     , m_isForPage(false)
 60     , m_tagIsForNamespaceRule(tagIsForNamespaceRule)
 61     , m_caseInsensitiveAttributeValueMatching(false)
 62 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
 63     , m_destructorHasBeenCalled(false)
 64 #endif
 65 {
 66     const AtomString&amp; tagLocalName = tagQName.localName();
 67     const AtomString tagLocalNameASCIILowercase = tagLocalName.convertToASCIILowercase();
 68 
 69     if (tagLocalName == tagLocalNameASCIILowercase) {
 70         m_data.m_tagQName = tagQName.impl();
</pre>
<hr />
<pre>
257                 s += 1;
258                 break;
259             }
260             break;
261         default:
262             break;
263         }
264     }
265     return s;
266 }
267 
268 PseudoId CSSSelector::pseudoId(PseudoElementType type)
269 {
270     switch (type) {
271     case PseudoElementFirstLine:
272         return PseudoId::FirstLine;
273     case PseudoElementFirstLetter:
274         return PseudoId::FirstLetter;
275     case PseudoElementSelection:
276         return PseudoId::Selection;


277     case PseudoElementMarker:
278         return PseudoId::Marker;
279     case PseudoElementBefore:
280         return PseudoId::Before;
281     case PseudoElementAfter:
282         return PseudoId::After;
283     case PseudoElementScrollbar:
284         return PseudoId::Scrollbar;
285     case PseudoElementScrollbarButton:
286         return PseudoId::ScrollbarButton;
287     case PseudoElementScrollbarCorner:
288         return PseudoId::ScrollbarCorner;
289     case PseudoElementScrollbarThumb:
290         return PseudoId::ScrollbarThumb;
291     case PseudoElementScrollbarTrack:
292         return PseudoId::ScrollbarTrack;
293     case PseudoElementScrollbarTrackPiece:
294         return PseudoId::ScrollbarTrackPiece;
295     case PseudoElementResizer:
296         return PseudoId::Resizer;
297 #if ENABLE(VIDEO_TRACK)
298     case PseudoElementCue:
299 #endif
300     case PseudoElementSlotted:

301     case PseudoElementUnknown:
302     case PseudoElementWebKitCustom:
303     case PseudoElementWebKitCustomLegacyPrefixed:
304         return PseudoId::None;
305     }
306 
307     ASSERT_NOT_REACHED();
308     return PseudoId::None;
309 }
310 
311 CSSSelector::PseudoElementType CSSSelector::parsePseudoElementType(StringView name)
312 {
313     if (name.isNull())
314         return PseudoElementUnknown;

315     auto type = parsePseudoElementString(name);
316     if (type == PseudoElementUnknown) {
317         if (name.startsWith(&quot;-webkit-&quot;))
318             type = PseudoElementWebKitCustom;
319     }







320     return type;
321 }
322 
323 bool CSSSelector::operator==(const CSSSelector&amp; other) const
324 {
325     const CSSSelector* sel1 = this;
326     const CSSSelector* sel2 = &amp;other;
327 
328     while (sel1 &amp;&amp; sel2) {
329         if (sel1-&gt;attribute() != sel2-&gt;attribute()
330             || sel1-&gt;relation() != sel2-&gt;relation()
331             || sel1-&gt;match() != sel2-&gt;match()
332             || sel1-&gt;value() != sel2-&gt;value()
333             || sel1-&gt;m_pseudoType != sel2-&gt;m_pseudoType
334             || sel1-&gt;argument() != sel2-&gt;argument()) {
335             return false;
336         }
337         if (sel1-&gt;match() == Tag) {
338             if (sel1-&gt;tagQName() != sel2-&gt;tagQName())
339                 return false;
340         }
341         sel1 = sel1-&gt;tagHistory();
342         sel2 = sel2-&gt;tagHistory();
343     }
344 
345     if (sel1 || sel2)
346         return false;
347 
348     return true;
349 }
350 
<span class="line-modified">351 static void appendPseudoClassFunctionTail(StringBuilder&amp; str, const CSSSelector* selector)</span>
352 {
353     switch (selector-&gt;pseudoClassType()) {
354 #if ENABLE(CSS_SELECTORS_LEVEL4)
355     case CSSSelector::PseudoClassDir:
356 #endif
357     case CSSSelector::PseudoClassLang:
358     case CSSSelector::PseudoClassNthChild:
359     case CSSSelector::PseudoClassNthLastChild:
360     case CSSSelector::PseudoClassNthOfType:
361     case CSSSelector::PseudoClassNthLastOfType:
362 #if ENABLE(CSS_SELECTORS_LEVEL4)
363     case CSSSelector::PseudoClassRole:
364 #endif
<span class="line-modified">365         str.append(selector-&gt;argument());</span>
<span class="line-modified">366         str.append(&#39;)&#39;);</span>
367         break;
368     default:
369         break;
370     }
371 
372 }
373 
<span class="line-modified">374 static void appendLangArgumentList(StringBuilder&amp; str, const Vector&lt;AtomString&gt;&amp; argumentList)</span>
375 {
376     unsigned argumentListSize = argumentList.size();
377     for (unsigned i = 0; i &lt; argumentListSize; ++i) {
<span class="line-modified">378         str.append(&#39;&quot;&#39;);</span>
<span class="line-modified">379         str.append(argumentList[i]);</span>
<span class="line-modified">380         str.append(&#39;&quot;&#39;);</span>
381         if (i != argumentListSize - 1)
<span class="line-modified">382             str.appendLiteral(&quot;, &quot;);</span>




































383     }
384 }
385 
386 String CSSSelector::selectorText(const String&amp; rightSide) const
387 {
<span class="line-modified">388     StringBuilder str;</span>
389 
390     if (match() == CSSSelector::Tag &amp;&amp; !m_tagIsForNamespaceRule) {
391         if (tagQName().prefix().isNull())
<span class="line-modified">392             str.append(tagQName().localName());</span>
393         else {
<span class="line-modified">394             str.append(tagQName().prefix().string());</span>
<span class="line-modified">395             str.append(&#39;|&#39;);</span>
<span class="line-modified">396             str.append(tagQName().localName());</span>
397         }
398     }
399 
400     const CSSSelector* cs = this;
401     while (true) {
402         if (cs-&gt;match() == CSSSelector::Id) {
<span class="line-modified">403             str.append(&#39;#&#39;);</span>
<span class="line-modified">404             serializeIdentifier(cs-&gt;serializingValue(), str);</span>
405         } else if (cs-&gt;match() == CSSSelector::Class) {
<span class="line-modified">406             str.append(&#39;.&#39;);</span>
<span class="line-modified">407             serializeIdentifier(cs-&gt;serializingValue(), str);</span>
408         } else if (cs-&gt;match() == CSSSelector::PseudoClass) {
409             switch (cs-&gt;pseudoClassType()) {
410 #if ENABLE(FULLSCREEN_API)
411             case CSSSelector::PseudoClassAnimatingFullScreenTransition:
<span class="line-modified">412                 str.appendLiteral(&quot;:-webkit-animating-full-screen-transition&quot;);</span>
413                 break;
414 #endif
415             case CSSSelector::PseudoClassAny: {
<span class="line-modified">416                 str.appendLiteral(&quot;:-webkit-any(&quot;);</span>
<span class="line-modified">417                 cs-&gt;selectorList()-&gt;buildSelectorsText(str);</span>
<span class="line-modified">418                 str.append(&#39;)&#39;);</span>
419                 break;
420             }
421             case CSSSelector::PseudoClassAnyLink:
<span class="line-modified">422                 str.appendLiteral(&quot;:any-link&quot;);</span>
423                 break;
424             case CSSSelector::PseudoClassAnyLinkDeprecated:
<span class="line-modified">425                 str.appendLiteral(&quot;:-webkit-any-link&quot;);</span>
426                 break;
427             case CSSSelector::PseudoClassAutofill:
<span class="line-modified">428                 str.appendLiteral(&quot;:-webkit-autofill&quot;);</span>
429                 break;
430             case CSSSelector::PseudoClassAutofillStrongPassword:
<span class="line-modified">431                 str.appendLiteral(&quot;:-webkit-autofill-strong-password&quot;);</span>
432                 break;
433             case CSSSelector::PseudoClassAutofillStrongPasswordViewable:
<span class="line-modified">434                 str.appendLiteral(&quot;:-webkit-autofill-strong-password-viewable&quot;);</span>



435                 break;
436             case CSSSelector::PseudoClassDrag:
<span class="line-modified">437                 str.appendLiteral(&quot;:-webkit-drag&quot;);</span>
438                 break;
439             case CSSSelector::PseudoClassFullPageMedia:
<span class="line-modified">440                 str.appendLiteral(&quot;:-webkit-full-page-media&quot;);</span>
441                 break;
442 #if ENABLE(FULLSCREEN_API)
443             case CSSSelector::PseudoClassFullScreen:
<span class="line-modified">444                 str.appendLiteral(&quot;:-webkit-full-screen&quot;);</span>
445                 break;
446             case CSSSelector::PseudoClassFullScreenAncestor:
<span class="line-modified">447                 str.appendLiteral(&quot;:-webkit-full-screen-ancestor&quot;);</span>
448                 break;
449             case CSSSelector::PseudoClassFullScreenDocument:
<span class="line-modified">450                 str.appendLiteral(&quot;:-webkit-full-screen-document&quot;);</span>
451                 break;
452             case CSSSelector::PseudoClassFullScreenControlsHidden:
<span class="line-modified">453                 str.appendLiteral(&quot;:-webkit-full-screen-controls-hidden&quot;);</span>





454                 break;
455 #endif
456             case CSSSelector::PseudoClassActive:
<span class="line-modified">457                 str.appendLiteral(&quot;:active&quot;);</span>
458                 break;
459             case CSSSelector::PseudoClassChecked:
<span class="line-modified">460                 str.appendLiteral(&quot;:checked&quot;);</span>
461                 break;
462             case CSSSelector::PseudoClassCornerPresent:
<span class="line-modified">463                 str.appendLiteral(&quot;:corner-present&quot;);</span>
464                 break;
465             case CSSSelector::PseudoClassDecrement:
<span class="line-modified">466                 str.appendLiteral(&quot;:decrement&quot;);</span>
467                 break;
468             case CSSSelector::PseudoClassDefault:
<span class="line-modified">469                 str.appendLiteral(&quot;:default&quot;);</span>
470                 break;
471 #if ENABLE(CSS_SELECTORS_LEVEL4)
472             case CSSSelector::PseudoClassDir:
<span class="line-modified">473                 str.appendLiteral(&quot;:dir(&quot;);</span>
<span class="line-modified">474                 appendPseudoClassFunctionTail(str, cs);</span>
475                 break;
476 #endif
477             case CSSSelector::PseudoClassDisabled:
<span class="line-modified">478                 str.appendLiteral(&quot;:disabled&quot;);</span>
479                 break;
480             case CSSSelector::PseudoClassDoubleButton:
<span class="line-modified">481                 str.appendLiteral(&quot;:double-button&quot;);</span>
482                 break;
483             case CSSSelector::PseudoClassEmpty:
<span class="line-modified">484                 str.appendLiteral(&quot;:empty&quot;);</span>
485                 break;
486             case CSSSelector::PseudoClassEnabled:
<span class="line-modified">487                 str.appendLiteral(&quot;:enabled&quot;);</span>
488                 break;
489             case CSSSelector::PseudoClassEnd:
<span class="line-modified">490                 str.appendLiteral(&quot;:end&quot;);</span>
491                 break;
492             case CSSSelector::PseudoClassFirstChild:
<span class="line-modified">493                 str.appendLiteral(&quot;:first-child&quot;);</span>
494                 break;
495             case CSSSelector::PseudoClassFirstOfType:
<span class="line-modified">496                 str.appendLiteral(&quot;:first-of-type&quot;);</span>
497                 break;
498             case CSSSelector::PseudoClassFocus:
<span class="line-modified">499                 str.appendLiteral(&quot;:focus&quot;);</span>
500                 break;
501             case CSSSelector::PseudoClassFocusWithin:
<span class="line-modified">502                 str.appendLiteral(&quot;:focus-within&quot;);</span>
503                 break;
504 #if ENABLE(VIDEO_TRACK)
505             case CSSSelector::PseudoClassFuture:
<span class="line-modified">506                 str.appendLiteral(&quot;:future&quot;);</span>
507                 break;
508 #endif
509 #if ENABLE(ATTACHMENT_ELEMENT)
510             case CSSSelector::PseudoClassHasAttachment:
<span class="line-modified">511                 str.appendLiteral(&quot;:has-attachment&quot;);</span>
512                 break;
513 #endif
514             case CSSSelector::PseudoClassHorizontal:
<span class="line-modified">515                 str.appendLiteral(&quot;:horizontal&quot;);</span>
516                 break;
517             case CSSSelector::PseudoClassHover:
<span class="line-modified">518                 str.appendLiteral(&quot;:hover&quot;);</span>
519                 break;
520             case CSSSelector::PseudoClassInRange:
<span class="line-modified">521                 str.appendLiteral(&quot;:in-range&quot;);</span>
522                 break;
523             case CSSSelector::PseudoClassIncrement:
<span class="line-modified">524                 str.appendLiteral(&quot;:increment&quot;);</span>
525                 break;
526             case CSSSelector::PseudoClassIndeterminate:
<span class="line-modified">527                 str.appendLiteral(&quot;:indeterminate&quot;);</span>
528                 break;
529             case CSSSelector::PseudoClassInvalid:
<span class="line-modified">530                 str.appendLiteral(&quot;:invalid&quot;);</span>
531                 break;
532             case CSSSelector::PseudoClassLang:
<span class="line-modified">533                 str.appendLiteral(&quot;:lang(&quot;);</span>
<span class="line-modified">534                 ASSERT_WITH_MESSAGE(cs-&gt;langArgumentList() &amp;&amp; !cs-&gt;langArgumentList()-&gt;isEmpty(), &quot;An empty :lang() is invalid and should never be generated by the parser.&quot;);</span>
<span class="line-modified">535                 appendLangArgumentList(str, *cs-&gt;langArgumentList());</span>
<span class="line-modified">536                 str.append(&#39;)&#39;);</span>
537                 break;
538             case CSSSelector::PseudoClassLastChild:
<span class="line-modified">539                 str.appendLiteral(&quot;:last-child&quot;);</span>
540                 break;
541             case CSSSelector::PseudoClassLastOfType:
<span class="line-modified">542                 str.appendLiteral(&quot;:last-of-type&quot;);</span>
543                 break;
544             case CSSSelector::PseudoClassLink:
<span class="line-modified">545                 str.appendLiteral(&quot;:link&quot;);</span>
546                 break;
547             case CSSSelector::PseudoClassNoButton:
<span class="line-modified">548                 str.appendLiteral(&quot;:no-button&quot;);</span>
549                 break;
550             case CSSSelector::PseudoClassNot:
<span class="line-modified">551                 str.appendLiteral(&quot;:not(&quot;);</span>
<span class="line-modified">552                 cs-&gt;selectorList()-&gt;buildSelectorsText(str);</span>
<span class="line-modified">553                 str.append(&#39;)&#39;);</span>
554                 break;
555             case CSSSelector::PseudoClassNthChild:
<span class="line-modified">556                 str.appendLiteral(&quot;:nth-child(&quot;);</span>
<span class="line-modified">557                 str.append(cs-&gt;argument());</span>
558                 if (const CSSSelectorList* selectorList = cs-&gt;selectorList()) {
<span class="line-modified">559                     str.appendLiteral(&quot; of &quot;);</span>
<span class="line-modified">560                     selectorList-&gt;buildSelectorsText(str);</span>
561                 }
<span class="line-modified">562                 str.append(&#39;)&#39;);</span>
563                 break;
564             case CSSSelector::PseudoClassNthLastChild:
<span class="line-modified">565                 str.appendLiteral(&quot;:nth-last-child(&quot;);</span>
<span class="line-modified">566                 str.append(cs-&gt;argument());</span>
567                 if (const CSSSelectorList* selectorList = cs-&gt;selectorList()) {
<span class="line-modified">568                     str.appendLiteral(&quot; of &quot;);</span>
<span class="line-modified">569                     selectorList-&gt;buildSelectorsText(str);</span>
570                 }
<span class="line-modified">571                 str.append(&#39;)&#39;);</span>
572                 break;
573             case CSSSelector::PseudoClassNthLastOfType:
<span class="line-modified">574                 str.appendLiteral(&quot;:nth-last-of-type(&quot;);</span>
<span class="line-modified">575                 appendPseudoClassFunctionTail(str, cs);</span>
576                 break;
577             case CSSSelector::PseudoClassNthOfType:
<span class="line-modified">578                 str.appendLiteral(&quot;:nth-of-type(&quot;);</span>
<span class="line-modified">579                 appendPseudoClassFunctionTail(str, cs);</span>
580                 break;
581             case CSSSelector::PseudoClassOnlyChild:
<span class="line-modified">582                 str.appendLiteral(&quot;:only-child&quot;);</span>
583                 break;
584             case CSSSelector::PseudoClassOnlyOfType:
<span class="line-modified">585                 str.appendLiteral(&quot;:only-of-type&quot;);</span>
586                 break;
587             case CSSSelector::PseudoClassOptional:
<span class="line-modified">588                 str.appendLiteral(&quot;:optional&quot;);</span>
589                 break;
590             case CSSSelector::PseudoClassMatches: {
<span class="line-modified">591                 str.appendLiteral(&quot;:matches(&quot;);</span>
<span class="line-modified">592                 cs-&gt;selectorList()-&gt;buildSelectorsText(str);</span>
<span class="line-modified">593                 str.append(&#39;)&#39;);</span>
594                 break;
595             }
596             case CSSSelector::PseudoClassPlaceholderShown:
<span class="line-modified">597                 str.appendLiteral(&quot;:placeholder-shown&quot;);</span>
598                 break;
599             case CSSSelector::PseudoClassOutOfRange:
<span class="line-modified">600                 str.appendLiteral(&quot;:out-of-range&quot;);</span>
601                 break;
602 #if ENABLE(VIDEO_TRACK)
603             case CSSSelector::PseudoClassPast:
<span class="line-modified">604                 str.appendLiteral(&quot;:past&quot;);</span>
605                 break;
606 #endif
607             case CSSSelector::PseudoClassReadOnly:
<span class="line-modified">608                 str.appendLiteral(&quot;:read-only&quot;);</span>
609                 break;
610             case CSSSelector::PseudoClassReadWrite:
<span class="line-modified">611                 str.appendLiteral(&quot;:read-write&quot;);</span>
612                 break;
613             case CSSSelector::PseudoClassRequired:
<span class="line-modified">614                 str.appendLiteral(&quot;:required&quot;);</span>
615                 break;
616 #if ENABLE(CSS_SELECTORS_LEVEL4)
617             case CSSSelector::PseudoClassRole:
<span class="line-modified">618                 str.appendLiteral(&quot;:role(&quot;);</span>
<span class="line-modified">619                 appendPseudoClassFunctionTail(str, cs);</span>
620                 break;
621 #endif
622             case CSSSelector::PseudoClassRoot:
<span class="line-modified">623                 str.appendLiteral(&quot;:root&quot;);</span>
624                 break;
625             case CSSSelector::PseudoClassScope:
<span class="line-modified">626                 str.appendLiteral(&quot;:scope&quot;);</span>
627                 break;
628             case CSSSelector::PseudoClassSingleButton:
<span class="line-modified">629                 str.appendLiteral(&quot;:single-button&quot;);</span>
630                 break;
631             case CSSSelector::PseudoClassStart:
<span class="line-modified">632                 str.appendLiteral(&quot;:start&quot;);</span>
633                 break;
634             case CSSSelector::PseudoClassTarget:
<span class="line-modified">635                 str.appendLiteral(&quot;:target&quot;);</span>
636                 break;
637             case CSSSelector::PseudoClassValid:
<span class="line-modified">638                 str.appendLiteral(&quot;:valid&quot;);</span>
639                 break;
640             case CSSSelector::PseudoClassVertical:
<span class="line-modified">641                 str.appendLiteral(&quot;:vertical&quot;);</span>
642                 break;
643             case CSSSelector::PseudoClassVisited:
<span class="line-modified">644                 str.appendLiteral(&quot;:visited&quot;);</span>
645                 break;
646             case CSSSelector::PseudoClassWindowInactive:
<span class="line-modified">647                 str.appendLiteral(&quot;:window-inactive&quot;);</span>
648                 break;
649             case CSSSelector::PseudoClassHost:
<span class="line-modified">650                 str.appendLiteral(&quot;:host&quot;);</span>
651                 break;
652             case CSSSelector::PseudoClassDefined:
<span class="line-modified">653                 str.appendLiteral(&quot;:defined&quot;);</span>
654                 break;
655             case CSSSelector::PseudoClassUnknown:
656                 ASSERT_NOT_REACHED();
657             }
658         } else if (cs-&gt;match() == CSSSelector::PseudoElement) {
659             switch (cs-&gt;pseudoElementType()) {
660             case CSSSelector::PseudoElementSlotted:
<span class="line-modified">661                 str.appendLiteral(&quot;::slotted(&quot;);</span>
<span class="line-modified">662                 cs-&gt;selectorList()-&gt;buildSelectorsText(str);</span>
<span class="line-modified">663                 str.append(&#39;)&#39;);</span>











664                 break;

665             case CSSSelector::PseudoElementWebKitCustomLegacyPrefixed:
666                 if (cs-&gt;value() == &quot;placeholder&quot;)
<span class="line-modified">667                     str.appendLiteral(&quot;::-webkit-input-placeholder&quot;);</span>
668                 break;











669             default:
<span class="line-modified">670                 str.appendLiteral(&quot;::&quot;);</span>
<span class="line-modified">671                 str.append(cs-&gt;serializingValue());</span>
672             }
673         } else if (cs-&gt;isAttributeSelector()) {
<span class="line-modified">674             str.append(&#39;[&#39;);</span>
675             const AtomString&amp; prefix = cs-&gt;attribute().prefix();
676             if (!prefix.isEmpty()) {
<span class="line-modified">677                 str.append(prefix);</span>
<span class="line-modified">678                 str.append(&#39;|&#39;);</span>
679             }
<span class="line-modified">680             str.append(cs-&gt;attribute().localName());</span>
681             switch (cs-&gt;match()) {
682                 case CSSSelector::Exact:
<span class="line-modified">683                     str.append(&#39;=&#39;);</span>
684                     break;
685                 case CSSSelector::Set:
686                     // set has no operator or value, just the attrName
<span class="line-modified">687                     str.append(&#39;]&#39;);</span>
688                     break;
689                 case CSSSelector::List:
<span class="line-modified">690                     str.appendLiteral(&quot;~=&quot;);</span>
691                     break;
692                 case CSSSelector::Hyphen:
<span class="line-modified">693                     str.appendLiteral(&quot;|=&quot;);</span>
694                     break;
695                 case CSSSelector::Begin:
<span class="line-modified">696                     str.appendLiteral(&quot;^=&quot;);</span>
697                     break;
698                 case CSSSelector::End:
<span class="line-modified">699                     str.appendLiteral(&quot;$=&quot;);</span>
700                     break;
701                 case CSSSelector::Contain:
<span class="line-modified">702                     str.appendLiteral(&quot;*=&quot;);</span>
703                     break;
704                 default:
705                     break;
706             }
707             if (cs-&gt;match() != CSSSelector::Set) {
<span class="line-modified">708                 serializeString(cs-&gt;serializingValue(), str);</span>
709                 if (cs-&gt;attributeValueMatchingIsCaseInsensitive())
<span class="line-modified">710                     str.appendLiteral(&quot; i]&quot;);</span>
711                 else
<span class="line-modified">712                     str.append(&#39;]&#39;);</span>
713             }
714         } else if (cs-&gt;match() == CSSSelector::PagePseudoClass) {
715             switch (cs-&gt;pagePseudoClassType()) {
716             case PagePseudoClassFirst:
<span class="line-modified">717                 str.appendLiteral(&quot;:first&quot;);</span>
718                 break;
719             case PagePseudoClassLeft:
<span class="line-modified">720                 str.appendLiteral(&quot;:left&quot;);</span>
721                 break;
722             case PagePseudoClassRight:
<span class="line-modified">723                 str.appendLiteral(&quot;:right&quot;);</span>
724                 break;
725             }
726         }
727 
728         if (cs-&gt;relation() != CSSSelector::Subselector || !cs-&gt;tagHistory())
729             break;
730         cs = cs-&gt;tagHistory();
731     }
732 
733     if (const CSSSelector* tagHistory = cs-&gt;tagHistory()) {
734         switch (cs-&gt;relation()) {
735         case CSSSelector::DescendantSpace:
<span class="line-modified">736             return tagHistory-&gt;selectorText(&quot; &quot; + str.toString() + rightSide);</span>
737         case CSSSelector::Child:
<span class="line-modified">738             return tagHistory-&gt;selectorText(&quot; &gt; &quot; + str.toString() + rightSide);</span>
739         case CSSSelector::DirectAdjacent:
<span class="line-modified">740             return tagHistory-&gt;selectorText(&quot; + &quot; + str.toString() + rightSide);</span>
741         case CSSSelector::IndirectAdjacent:
<span class="line-modified">742             return tagHistory-&gt;selectorText(&quot; ~ &quot; + str.toString() + rightSide);</span>
743         case CSSSelector::Subselector:
744             ASSERT_NOT_REACHED();
<span class="line-modified">745 #if ASSERT_DISABLED</span>
746             FALLTHROUGH;
747 #endif
748         case CSSSelector::ShadowDescendant:
<span class="line-modified">749             return tagHistory-&gt;selectorText(str.toString() + rightSide);</span>
750         }
751     }
<span class="line-modified">752     return str.toString() + rightSide;</span>
753 }
754 
755 void CSSSelector::setAttribute(const QualifiedName&amp; value, bool convertToLowercase, AttributeMatchType matchType)
756 {
757     createRareData();
758     m_data.m_rareData-&gt;m_attribute = value;
759     m_data.m_rareData-&gt;m_attributeCanonicalLocalName = convertToLowercase ? value.localName().convertToASCIILowercase() : value.localName();
760     m_caseInsensitiveAttributeValueMatching = matchType == CaseInsensitive;
761 }
762 
763 void CSSSelector::setArgument(const AtomString&amp; value)
764 {
765     createRareData();
766     m_data.m_rareData-&gt;m_argument = value;
767 }
768 
<span class="line-modified">769 void CSSSelector::setLangArgumentList(std::unique_ptr&lt;Vector&lt;AtomString&gt;&gt; argumentList)</span>
770 {
771     createRareData();
<span class="line-modified">772     m_data.m_rareData-&gt;m_langArgumentList = WTFMove(argumentList);</span>
773 }
774 
775 void CSSSelector::setSelectorList(std::unique_ptr&lt;CSSSelectorList&gt; selectorList)
776 {
777     createRareData();
778     m_data.m_rareData-&gt;m_selectorList = WTFMove(selectorList);
779 }
780 
781 void CSSSelector::setNth(int a, int b)
782 {
783     createRareData();
784     m_data.m_rareData-&gt;m_a = a;
785     m_data.m_rareData-&gt;m_b = b;
786 }
787 
788 bool CSSSelector::matchNth(int count) const
789 {
790     ASSERT(m_hasRareData);
791     return m_data.m_rareData-&gt;matchNth(count);
792 }
</pre>
</td>
<td>
<hr />
<pre>
 12  * License as published by the Free Software Foundation; either
 13  * version 2 of the License, or (at your option) any later version.
 14  *
 15  * This library is distributed in the hope that it will be useful,
 16  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 17  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 18  * Library General Public License for more details.
 19  *
 20  * You should have received a copy of the GNU Library General Public License
 21  * along with this library; see the file COPYING.LIB.  If not, write to
 22  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 23  * Boston, MA 02110-1301, USA.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;CSSSelector.h&quot;
 28 
 29 #include &quot;CSSMarkup.h&quot;
 30 #include &quot;CSSSelectorList.h&quot;
 31 #include &quot;HTMLNames.h&quot;
<span class="line-added"> 32 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
 33 #include &quot;SelectorPseudoTypeMap.h&quot;
 34 #include &lt;wtf/Assertions.h&gt;
 35 #include &lt;wtf/StdLibExtras.h&gt;
 36 #include &lt;wtf/Vector.h&gt;
 37 #include &lt;wtf/text/AtomStringHash.h&gt;
 38 #include &lt;wtf/text/StringBuilder.h&gt;
 39 
 40 namespace WebCore {
 41 
 42 using namespace HTMLNames;
 43 
 44 struct SameSizeAsCSSSelector {
 45     unsigned flags;
 46     void* unionPointer;
 47 };
 48 
 49 static_assert(CSSSelector::RelationType::Subselector == 0, &quot;Subselector must be 0 for consumeCombinator.&quot;);
 50 static_assert(sizeof(CSSSelector) == sizeof(SameSizeAsCSSSelector), &quot;CSSSelector should remain small.&quot;);
 51 
<span class="line-added"> 52 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(CSSSelectorRareData);</span>
<span class="line-added"> 53 </span>
 54 CSSSelector::CSSSelector(const QualifiedName&amp; tagQName, bool tagIsForNamespaceRule)
 55     : m_relation(DescendantSpace)
 56     , m_match(Tag)
 57     , m_pseudoType(0)
 58     , m_isLastInSelectorList(false)
 59     , m_isLastInTagHistory(true)
 60     , m_hasRareData(false)
 61     , m_hasNameWithCase(false)
 62     , m_isForPage(false)
 63     , m_tagIsForNamespaceRule(tagIsForNamespaceRule)
 64     , m_caseInsensitiveAttributeValueMatching(false)
 65 #if !ASSERT_WITH_SECURITY_IMPLICATION_DISABLED
 66     , m_destructorHasBeenCalled(false)
 67 #endif
 68 {
 69     const AtomString&amp; tagLocalName = tagQName.localName();
 70     const AtomString tagLocalNameASCIILowercase = tagLocalName.convertToASCIILowercase();
 71 
 72     if (tagLocalName == tagLocalNameASCIILowercase) {
 73         m_data.m_tagQName = tagQName.impl();
</pre>
<hr />
<pre>
260                 s += 1;
261                 break;
262             }
263             break;
264         default:
265             break;
266         }
267     }
268     return s;
269 }
270 
271 PseudoId CSSSelector::pseudoId(PseudoElementType type)
272 {
273     switch (type) {
274     case PseudoElementFirstLine:
275         return PseudoId::FirstLine;
276     case PseudoElementFirstLetter:
277         return PseudoId::FirstLetter;
278     case PseudoElementSelection:
279         return PseudoId::Selection;
<span class="line-added">280     case PseudoElementHighlight:</span>
<span class="line-added">281         return PseudoId::Highlight;</span>
282     case PseudoElementMarker:
283         return PseudoId::Marker;
284     case PseudoElementBefore:
285         return PseudoId::Before;
286     case PseudoElementAfter:
287         return PseudoId::After;
288     case PseudoElementScrollbar:
289         return PseudoId::Scrollbar;
290     case PseudoElementScrollbarButton:
291         return PseudoId::ScrollbarButton;
292     case PseudoElementScrollbarCorner:
293         return PseudoId::ScrollbarCorner;
294     case PseudoElementScrollbarThumb:
295         return PseudoId::ScrollbarThumb;
296     case PseudoElementScrollbarTrack:
297         return PseudoId::ScrollbarTrack;
298     case PseudoElementScrollbarTrackPiece:
299         return PseudoId::ScrollbarTrackPiece;
300     case PseudoElementResizer:
301         return PseudoId::Resizer;
302 #if ENABLE(VIDEO_TRACK)
303     case PseudoElementCue:
304 #endif
305     case PseudoElementSlotted:
<span class="line-added">306     case PseudoElementPart:</span>
307     case PseudoElementUnknown:
308     case PseudoElementWebKitCustom:
309     case PseudoElementWebKitCustomLegacyPrefixed:
310         return PseudoId::None;
311     }
312 
313     ASSERT_NOT_REACHED();
314     return PseudoId::None;
315 }
316 
317 CSSSelector::PseudoElementType CSSSelector::parsePseudoElementType(StringView name)
318 {
319     if (name.isNull())
320         return PseudoElementUnknown;
<span class="line-added">321 </span>
322     auto type = parsePseudoElementString(name);
323     if (type == PseudoElementUnknown) {
324         if (name.startsWith(&quot;-webkit-&quot;))
325             type = PseudoElementWebKitCustom;
326     }
<span class="line-added">327 </span>
<span class="line-added">328     if (type == PseudoElementHighlight &amp;&amp; !RuntimeEnabledFeatures::sharedFeatures().highlightAPIEnabled())</span>
<span class="line-added">329         return PseudoElementUnknown;</span>
<span class="line-added">330 </span>
<span class="line-added">331     if (type == PseudoElementPart &amp;&amp; !RuntimeEnabledFeatures::sharedFeatures().cssShadowPartsEnabled())</span>
<span class="line-added">332         return PseudoElementUnknown;</span>
<span class="line-added">333 </span>
334     return type;
335 }
336 
337 bool CSSSelector::operator==(const CSSSelector&amp; other) const
338 {
339     const CSSSelector* sel1 = this;
340     const CSSSelector* sel2 = &amp;other;
341 
342     while (sel1 &amp;&amp; sel2) {
343         if (sel1-&gt;attribute() != sel2-&gt;attribute()
344             || sel1-&gt;relation() != sel2-&gt;relation()
345             || sel1-&gt;match() != sel2-&gt;match()
346             || sel1-&gt;value() != sel2-&gt;value()
347             || sel1-&gt;m_pseudoType != sel2-&gt;m_pseudoType
348             || sel1-&gt;argument() != sel2-&gt;argument()) {
349             return false;
350         }
351         if (sel1-&gt;match() == Tag) {
352             if (sel1-&gt;tagQName() != sel2-&gt;tagQName())
353                 return false;
354         }
355         sel1 = sel1-&gt;tagHistory();
356         sel2 = sel2-&gt;tagHistory();
357     }
358 
359     if (sel1 || sel2)
360         return false;
361 
362     return true;
363 }
364 
<span class="line-modified">365 static void appendPseudoClassFunctionTail(StringBuilder&amp; builder, const CSSSelector* selector)</span>
366 {
367     switch (selector-&gt;pseudoClassType()) {
368 #if ENABLE(CSS_SELECTORS_LEVEL4)
369     case CSSSelector::PseudoClassDir:
370 #endif
371     case CSSSelector::PseudoClassLang:
372     case CSSSelector::PseudoClassNthChild:
373     case CSSSelector::PseudoClassNthLastChild:
374     case CSSSelector::PseudoClassNthOfType:
375     case CSSSelector::PseudoClassNthLastOfType:
376 #if ENABLE(CSS_SELECTORS_LEVEL4)
377     case CSSSelector::PseudoClassRole:
378 #endif
<span class="line-modified">379         builder.append(selector-&gt;argument());</span>
<span class="line-modified">380         builder.append(&#39;)&#39;);</span>
381         break;
382     default:
383         break;
384     }
385 
386 }
387 
<span class="line-modified">388 static void appendLangArgumentList(StringBuilder&amp; builder, const Vector&lt;AtomString&gt;&amp; argumentList)</span>
389 {
390     unsigned argumentListSize = argumentList.size();
391     for (unsigned i = 0; i &lt; argumentListSize; ++i) {
<span class="line-modified">392         builder.append(&#39;&quot;&#39;);</span>
<span class="line-modified">393         builder.append(argumentList[i]);</span>
<span class="line-modified">394         builder.append(&#39;&quot;&#39;);</span>
395         if (i != argumentListSize - 1)
<span class="line-modified">396             builder.appendLiteral(&quot;, &quot;);</span>
<span class="line-added">397     }</span>
<span class="line-added">398 }</span>
<span class="line-added">399 </span>
<span class="line-added">400 // http://dev.w3.org/csswg/css-syntax/#serializing-anb</span>
<span class="line-added">401 static void outputNthChildAnPlusB(const CSSSelector&amp; selector, StringBuilder&amp; builder)</span>
<span class="line-added">402 {</span>
<span class="line-added">403     auto outputFirstTerm = [&amp;builder] (int a) {</span>
<span class="line-added">404         switch (a) {</span>
<span class="line-added">405         case 1:</span>
<span class="line-added">406             break;</span>
<span class="line-added">407         case -1:</span>
<span class="line-added">408             builder.append(&#39;-&#39;);</span>
<span class="line-added">409             break;</span>
<span class="line-added">410         default:</span>
<span class="line-added">411             builder.append(a);</span>
<span class="line-added">412         }</span>
<span class="line-added">413     };</span>
<span class="line-added">414 </span>
<span class="line-added">415     if (selector.argument() == nullAtom())</span>
<span class="line-added">416         return;</span>
<span class="line-added">417 </span>
<span class="line-added">418     int a = selector.nthA();</span>
<span class="line-added">419     int b = selector.nthB();</span>
<span class="line-added">420     if (a == 0 &amp;&amp; b == 0)</span>
<span class="line-added">421         builder.append(&#39;0&#39;);</span>
<span class="line-added">422     else if (a == 0)</span>
<span class="line-added">423         builder.append(b);</span>
<span class="line-added">424     else if (b == 0) {</span>
<span class="line-added">425         outputFirstTerm(a);</span>
<span class="line-added">426         builder.append(&#39;n&#39;);</span>
<span class="line-added">427     } else if (b &lt; 0) {</span>
<span class="line-added">428         outputFirstTerm(a);</span>
<span class="line-added">429         builder.append(&#39;n&#39;, b);</span>
<span class="line-added">430     } else {</span>
<span class="line-added">431         outputFirstTerm(a);</span>
<span class="line-added">432         builder.append(&quot;n+&quot;, b);</span>
433     }
434 }
435 
436 String CSSSelector::selectorText(const String&amp; rightSide) const
437 {
<span class="line-modified">438     StringBuilder builder;</span>
439 
440     if (match() == CSSSelector::Tag &amp;&amp; !m_tagIsForNamespaceRule) {
441         if (tagQName().prefix().isNull())
<span class="line-modified">442             builder.append(tagQName().localName());</span>
443         else {
<span class="line-modified">444             builder.append(tagQName().prefix().string());</span>
<span class="line-modified">445             builder.append(&#39;|&#39;);</span>
<span class="line-modified">446             builder.append(tagQName().localName());</span>
447         }
448     }
449 
450     const CSSSelector* cs = this;
451     while (true) {
452         if (cs-&gt;match() == CSSSelector::Id) {
<span class="line-modified">453             builder.append(&#39;#&#39;);</span>
<span class="line-modified">454             serializeIdentifier(cs-&gt;serializingValue(), builder);</span>
455         } else if (cs-&gt;match() == CSSSelector::Class) {
<span class="line-modified">456             builder.append(&#39;.&#39;);</span>
<span class="line-modified">457             serializeIdentifier(cs-&gt;serializingValue(), builder);</span>
458         } else if (cs-&gt;match() == CSSSelector::PseudoClass) {
459             switch (cs-&gt;pseudoClassType()) {
460 #if ENABLE(FULLSCREEN_API)
461             case CSSSelector::PseudoClassAnimatingFullScreenTransition:
<span class="line-modified">462                 builder.appendLiteral(&quot;:-webkit-animating-full-screen-transition&quot;);</span>
463                 break;
464 #endif
465             case CSSSelector::PseudoClassAny: {
<span class="line-modified">466                 builder.appendLiteral(&quot;:-webkit-any(&quot;);</span>
<span class="line-modified">467                 cs-&gt;selectorList()-&gt;buildSelectorsText(builder);</span>
<span class="line-modified">468                 builder.append(&#39;)&#39;);</span>
469                 break;
470             }
471             case CSSSelector::PseudoClassAnyLink:
<span class="line-modified">472                 builder.appendLiteral(&quot;:any-link&quot;);</span>
473                 break;
474             case CSSSelector::PseudoClassAnyLinkDeprecated:
<span class="line-modified">475                 builder.appendLiteral(&quot;:-webkit-any-link&quot;);</span>
476                 break;
477             case CSSSelector::PseudoClassAutofill:
<span class="line-modified">478                 builder.appendLiteral(&quot;:-webkit-autofill&quot;);</span>
479                 break;
480             case CSSSelector::PseudoClassAutofillStrongPassword:
<span class="line-modified">481                 builder.appendLiteral(&quot;:-webkit-autofill-strong-password&quot;);</span>
482                 break;
483             case CSSSelector::PseudoClassAutofillStrongPasswordViewable:
<span class="line-modified">484                 builder.appendLiteral(&quot;:-webkit-autofill-strong-password-viewable&quot;);</span>
<span class="line-added">485                 break;</span>
<span class="line-added">486             case CSSSelector::PseudoClassDirectFocus:</span>
<span class="line-added">487                 builder.appendLiteral(&quot;:-webkit-direct-focus&quot;);</span>
488                 break;
489             case CSSSelector::PseudoClassDrag:
<span class="line-modified">490                 builder.appendLiteral(&quot;:-webkit-drag&quot;);</span>
491                 break;
492             case CSSSelector::PseudoClassFullPageMedia:
<span class="line-modified">493                 builder.appendLiteral(&quot;:-webkit-full-page-media&quot;);</span>
494                 break;
495 #if ENABLE(FULLSCREEN_API)
496             case CSSSelector::PseudoClassFullScreen:
<span class="line-modified">497                 builder.appendLiteral(&quot;:-webkit-full-screen&quot;);</span>
498                 break;
499             case CSSSelector::PseudoClassFullScreenAncestor:
<span class="line-modified">500                 builder.appendLiteral(&quot;:-webkit-full-screen-ancestor&quot;);</span>
501                 break;
502             case CSSSelector::PseudoClassFullScreenDocument:
<span class="line-modified">503                 builder.appendLiteral(&quot;:-webkit-full-screen-document&quot;);</span>
504                 break;
505             case CSSSelector::PseudoClassFullScreenControlsHidden:
<span class="line-modified">506                 builder.appendLiteral(&quot;:-webkit-full-screen-controls-hidden&quot;);</span>
<span class="line-added">507                 break;</span>
<span class="line-added">508 #endif</span>
<span class="line-added">509 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">510             case CSSSelector::PseudoClassPictureInPicture:</span>
<span class="line-added">511                 builder.appendLiteral(&quot;:picture-in-picture&quot;);</span>
512                 break;
513 #endif
514             case CSSSelector::PseudoClassActive:
<span class="line-modified">515                 builder.appendLiteral(&quot;:active&quot;);</span>
516                 break;
517             case CSSSelector::PseudoClassChecked:
<span class="line-modified">518                 builder.appendLiteral(&quot;:checked&quot;);</span>
519                 break;
520             case CSSSelector::PseudoClassCornerPresent:
<span class="line-modified">521                 builder.appendLiteral(&quot;:corner-present&quot;);</span>
522                 break;
523             case CSSSelector::PseudoClassDecrement:
<span class="line-modified">524                 builder.appendLiteral(&quot;:decrement&quot;);</span>
525                 break;
526             case CSSSelector::PseudoClassDefault:
<span class="line-modified">527                 builder.appendLiteral(&quot;:default&quot;);</span>
528                 break;
529 #if ENABLE(CSS_SELECTORS_LEVEL4)
530             case CSSSelector::PseudoClassDir:
<span class="line-modified">531                 builder.appendLiteral(&quot;:dir(&quot;);</span>
<span class="line-modified">532                 appendPseudoClassFunctionTail(builder, cs);</span>
533                 break;
534 #endif
535             case CSSSelector::PseudoClassDisabled:
<span class="line-modified">536                 builder.appendLiteral(&quot;:disabled&quot;);</span>
537                 break;
538             case CSSSelector::PseudoClassDoubleButton:
<span class="line-modified">539                 builder.appendLiteral(&quot;:double-button&quot;);</span>
540                 break;
541             case CSSSelector::PseudoClassEmpty:
<span class="line-modified">542                 builder.appendLiteral(&quot;:empty&quot;);</span>
543                 break;
544             case CSSSelector::PseudoClassEnabled:
<span class="line-modified">545                 builder.appendLiteral(&quot;:enabled&quot;);</span>
546                 break;
547             case CSSSelector::PseudoClassEnd:
<span class="line-modified">548                 builder.appendLiteral(&quot;:end&quot;);</span>
549                 break;
550             case CSSSelector::PseudoClassFirstChild:
<span class="line-modified">551                 builder.appendLiteral(&quot;:first-child&quot;);</span>
552                 break;
553             case CSSSelector::PseudoClassFirstOfType:
<span class="line-modified">554                 builder.appendLiteral(&quot;:first-of-type&quot;);</span>
555                 break;
556             case CSSSelector::PseudoClassFocus:
<span class="line-modified">557                 builder.appendLiteral(&quot;:focus&quot;);</span>
558                 break;
559             case CSSSelector::PseudoClassFocusWithin:
<span class="line-modified">560                 builder.appendLiteral(&quot;:focus-within&quot;);</span>
561                 break;
562 #if ENABLE(VIDEO_TRACK)
563             case CSSSelector::PseudoClassFuture:
<span class="line-modified">564                 builder.appendLiteral(&quot;:future&quot;);</span>
565                 break;
566 #endif
567 #if ENABLE(ATTACHMENT_ELEMENT)
568             case CSSSelector::PseudoClassHasAttachment:
<span class="line-modified">569                 builder.appendLiteral(&quot;:has-attachment&quot;);</span>
570                 break;
571 #endif
572             case CSSSelector::PseudoClassHorizontal:
<span class="line-modified">573                 builder.appendLiteral(&quot;:horizontal&quot;);</span>
574                 break;
575             case CSSSelector::PseudoClassHover:
<span class="line-modified">576                 builder.appendLiteral(&quot;:hover&quot;);</span>
577                 break;
578             case CSSSelector::PseudoClassInRange:
<span class="line-modified">579                 builder.appendLiteral(&quot;:in-range&quot;);</span>
580                 break;
581             case CSSSelector::PseudoClassIncrement:
<span class="line-modified">582                 builder.appendLiteral(&quot;:increment&quot;);</span>
583                 break;
584             case CSSSelector::PseudoClassIndeterminate:
<span class="line-modified">585                 builder.appendLiteral(&quot;:indeterminate&quot;);</span>
586                 break;
587             case CSSSelector::PseudoClassInvalid:
<span class="line-modified">588                 builder.appendLiteral(&quot;:invalid&quot;);</span>
589                 break;
590             case CSSSelector::PseudoClassLang:
<span class="line-modified">591                 builder.appendLiteral(&quot;:lang(&quot;);</span>
<span class="line-modified">592                 ASSERT_WITH_MESSAGE(cs-&gt;argumentList() &amp;&amp; !cs-&gt;argumentList()-&gt;isEmpty(), &quot;An empty :lang() is invalid and should never be generated by the parser.&quot;);</span>
<span class="line-modified">593                 appendLangArgumentList(builder, *cs-&gt;argumentList());</span>
<span class="line-modified">594                 builder.append(&#39;)&#39;);</span>
595                 break;
596             case CSSSelector::PseudoClassLastChild:
<span class="line-modified">597                 builder.appendLiteral(&quot;:last-child&quot;);</span>
598                 break;
599             case CSSSelector::PseudoClassLastOfType:
<span class="line-modified">600                 builder.appendLiteral(&quot;:last-of-type&quot;);</span>
601                 break;
602             case CSSSelector::PseudoClassLink:
<span class="line-modified">603                 builder.appendLiteral(&quot;:link&quot;);</span>
604                 break;
605             case CSSSelector::PseudoClassNoButton:
<span class="line-modified">606                 builder.appendLiteral(&quot;:no-button&quot;);</span>
607                 break;
608             case CSSSelector::PseudoClassNot:
<span class="line-modified">609                 builder.appendLiteral(&quot;:not(&quot;);</span>
<span class="line-modified">610                 cs-&gt;selectorList()-&gt;buildSelectorsText(builder);</span>
<span class="line-modified">611                 builder.append(&#39;)&#39;);</span>
612                 break;
613             case CSSSelector::PseudoClassNthChild:
<span class="line-modified">614                 builder.appendLiteral(&quot;:nth-child(&quot;);</span>
<span class="line-modified">615                 outputNthChildAnPlusB(*cs, builder);</span>
616                 if (const CSSSelectorList* selectorList = cs-&gt;selectorList()) {
<span class="line-modified">617                     builder.appendLiteral(&quot; of &quot;);</span>
<span class="line-modified">618                     selectorList-&gt;buildSelectorsText(builder);</span>
619                 }
<span class="line-modified">620                 builder.append(&#39;)&#39;);</span>
621                 break;
622             case CSSSelector::PseudoClassNthLastChild:
<span class="line-modified">623                 builder.appendLiteral(&quot;:nth-last-child(&quot;);</span>
<span class="line-modified">624                 outputNthChildAnPlusB(*cs, builder);</span>
625                 if (const CSSSelectorList* selectorList = cs-&gt;selectorList()) {
<span class="line-modified">626                     builder.appendLiteral(&quot; of &quot;);</span>
<span class="line-modified">627                     selectorList-&gt;buildSelectorsText(builder);</span>
628                 }
<span class="line-modified">629                 builder.append(&#39;)&#39;);</span>
630                 break;
631             case CSSSelector::PseudoClassNthLastOfType:
<span class="line-modified">632                 builder.appendLiteral(&quot;:nth-last-of-type(&quot;);</span>
<span class="line-modified">633                 appendPseudoClassFunctionTail(builder, cs);</span>
634                 break;
635             case CSSSelector::PseudoClassNthOfType:
<span class="line-modified">636                 builder.appendLiteral(&quot;:nth-of-type(&quot;);</span>
<span class="line-modified">637                 appendPseudoClassFunctionTail(builder, cs);</span>
638                 break;
639             case CSSSelector::PseudoClassOnlyChild:
<span class="line-modified">640                 builder.appendLiteral(&quot;:only-child&quot;);</span>
641                 break;
642             case CSSSelector::PseudoClassOnlyOfType:
<span class="line-modified">643                 builder.appendLiteral(&quot;:only-of-type&quot;);</span>
644                 break;
645             case CSSSelector::PseudoClassOptional:
<span class="line-modified">646                 builder.appendLiteral(&quot;:optional&quot;);</span>
647                 break;
648             case CSSSelector::PseudoClassMatches: {
<span class="line-modified">649                 builder.appendLiteral(&quot;:matches(&quot;);</span>
<span class="line-modified">650                 cs-&gt;selectorList()-&gt;buildSelectorsText(builder);</span>
<span class="line-modified">651                 builder.append(&#39;)&#39;);</span>
652                 break;
653             }
654             case CSSSelector::PseudoClassPlaceholderShown:
<span class="line-modified">655                 builder.appendLiteral(&quot;:placeholder-shown&quot;);</span>
656                 break;
657             case CSSSelector::PseudoClassOutOfRange:
<span class="line-modified">658                 builder.appendLiteral(&quot;:out-of-range&quot;);</span>
659                 break;
660 #if ENABLE(VIDEO_TRACK)
661             case CSSSelector::PseudoClassPast:
<span class="line-modified">662                 builder.appendLiteral(&quot;:past&quot;);</span>
663                 break;
664 #endif
665             case CSSSelector::PseudoClassReadOnly:
<span class="line-modified">666                 builder.appendLiteral(&quot;:read-only&quot;);</span>
667                 break;
668             case CSSSelector::PseudoClassReadWrite:
<span class="line-modified">669                 builder.appendLiteral(&quot;:read-write&quot;);</span>
670                 break;
671             case CSSSelector::PseudoClassRequired:
<span class="line-modified">672                 builder.appendLiteral(&quot;:required&quot;);</span>
673                 break;
674 #if ENABLE(CSS_SELECTORS_LEVEL4)
675             case CSSSelector::PseudoClassRole:
<span class="line-modified">676                 builder.appendLiteral(&quot;:role(&quot;);</span>
<span class="line-modified">677                 appendPseudoClassFunctionTail(builder, cs);</span>
678                 break;
679 #endif
680             case CSSSelector::PseudoClassRoot:
<span class="line-modified">681                 builder.appendLiteral(&quot;:root&quot;);</span>
682                 break;
683             case CSSSelector::PseudoClassScope:
<span class="line-modified">684                 builder.appendLiteral(&quot;:scope&quot;);</span>
685                 break;
686             case CSSSelector::PseudoClassSingleButton:
<span class="line-modified">687                 builder.appendLiteral(&quot;:single-button&quot;);</span>
688                 break;
689             case CSSSelector::PseudoClassStart:
<span class="line-modified">690                 builder.appendLiteral(&quot;:start&quot;);</span>
691                 break;
692             case CSSSelector::PseudoClassTarget:
<span class="line-modified">693                 builder.appendLiteral(&quot;:target&quot;);</span>
694                 break;
695             case CSSSelector::PseudoClassValid:
<span class="line-modified">696                 builder.appendLiteral(&quot;:valid&quot;);</span>
697                 break;
698             case CSSSelector::PseudoClassVertical:
<span class="line-modified">699                 builder.appendLiteral(&quot;:vertical&quot;);</span>
700                 break;
701             case CSSSelector::PseudoClassVisited:
<span class="line-modified">702                 builder.appendLiteral(&quot;:visited&quot;);</span>
703                 break;
704             case CSSSelector::PseudoClassWindowInactive:
<span class="line-modified">705                 builder.appendLiteral(&quot;:window-inactive&quot;);</span>
706                 break;
707             case CSSSelector::PseudoClassHost:
<span class="line-modified">708                 builder.appendLiteral(&quot;:host&quot;);</span>
709                 break;
710             case CSSSelector::PseudoClassDefined:
<span class="line-modified">711                 builder.appendLiteral(&quot;:defined&quot;);</span>
712                 break;
713             case CSSSelector::PseudoClassUnknown:
714                 ASSERT_NOT_REACHED();
715             }
716         } else if (cs-&gt;match() == CSSSelector::PseudoElement) {
717             switch (cs-&gt;pseudoElementType()) {
718             case CSSSelector::PseudoElementSlotted:
<span class="line-modified">719                 builder.appendLiteral(&quot;::slotted(&quot;);</span>
<span class="line-modified">720                 cs-&gt;selectorList()-&gt;buildSelectorsText(builder);</span>
<span class="line-modified">721                 builder.append(&#39;)&#39;);</span>
<span class="line-added">722                 break;</span>
<span class="line-added">723             case CSSSelector::PseudoElementPart: {</span>
<span class="line-added">724                 builder.appendLiteral(&quot;::part(&quot;);</span>
<span class="line-added">725                 bool isFirst = true;</span>
<span class="line-added">726                 for (auto&amp; partName : *cs-&gt;argumentList()) {</span>
<span class="line-added">727                     if (!isFirst)</span>
<span class="line-added">728                         builder.append(&#39; &#39;);</span>
<span class="line-added">729                     isFirst = false;</span>
<span class="line-added">730                     builder.append(partName);</span>
<span class="line-added">731                 }</span>
<span class="line-added">732                 builder.append(&#39;)&#39;);</span>
733                 break;
<span class="line-added">734             }</span>
735             case CSSSelector::PseudoElementWebKitCustomLegacyPrefixed:
736                 if (cs-&gt;value() == &quot;placeholder&quot;)
<span class="line-modified">737                     builder.appendLiteral(&quot;::-webkit-input-placeholder&quot;);</span>
738                 break;
<span class="line-added">739 #if ENABLE(VIDEO_TRACK)</span>
<span class="line-added">740             case CSSSelector::PseudoElementCue: {</span>
<span class="line-added">741                 if (auto* selectorList = cs-&gt;selectorList()) {</span>
<span class="line-added">742                     builder.appendLiteral(&quot;::cue(&quot;);</span>
<span class="line-added">743                     selectorList-&gt;buildSelectorsText(builder);</span>
<span class="line-added">744                     builder.append(&#39;)&#39;);</span>
<span class="line-added">745                 } else</span>
<span class="line-added">746                     builder.appendLiteral(&quot;::cue&quot;);</span>
<span class="line-added">747                 break;</span>
<span class="line-added">748             }</span>
<span class="line-added">749 #endif</span>
750             default:
<span class="line-modified">751                 builder.appendLiteral(&quot;::&quot;);</span>
<span class="line-modified">752                 builder.append(cs-&gt;serializingValue());</span>
753             }
754         } else if (cs-&gt;isAttributeSelector()) {
<span class="line-modified">755             builder.append(&#39;[&#39;);</span>
756             const AtomString&amp; prefix = cs-&gt;attribute().prefix();
757             if (!prefix.isEmpty()) {
<span class="line-modified">758                 builder.append(prefix);</span>
<span class="line-modified">759                 builder.append(&#39;|&#39;);</span>
760             }
<span class="line-modified">761             builder.append(cs-&gt;attribute().localName());</span>
762             switch (cs-&gt;match()) {
763                 case CSSSelector::Exact:
<span class="line-modified">764                     builder.append(&#39;=&#39;);</span>
765                     break;
766                 case CSSSelector::Set:
767                     // set has no operator or value, just the attrName
<span class="line-modified">768                     builder.append(&#39;]&#39;);</span>
769                     break;
770                 case CSSSelector::List:
<span class="line-modified">771                     builder.appendLiteral(&quot;~=&quot;);</span>
772                     break;
773                 case CSSSelector::Hyphen:
<span class="line-modified">774                     builder.appendLiteral(&quot;|=&quot;);</span>
775                     break;
776                 case CSSSelector::Begin:
<span class="line-modified">777                     builder.appendLiteral(&quot;^=&quot;);</span>
778                     break;
779                 case CSSSelector::End:
<span class="line-modified">780                     builder.appendLiteral(&quot;$=&quot;);</span>
781                     break;
782                 case CSSSelector::Contain:
<span class="line-modified">783                     builder.appendLiteral(&quot;*=&quot;);</span>
784                     break;
785                 default:
786                     break;
787             }
788             if (cs-&gt;match() != CSSSelector::Set) {
<span class="line-modified">789                 serializeString(cs-&gt;serializingValue(), builder);</span>
790                 if (cs-&gt;attributeValueMatchingIsCaseInsensitive())
<span class="line-modified">791                     builder.appendLiteral(&quot; i]&quot;);</span>
792                 else
<span class="line-modified">793                     builder.append(&#39;]&#39;);</span>
794             }
795         } else if (cs-&gt;match() == CSSSelector::PagePseudoClass) {
796             switch (cs-&gt;pagePseudoClassType()) {
797             case PagePseudoClassFirst:
<span class="line-modified">798                 builder.appendLiteral(&quot;:first&quot;);</span>
799                 break;
800             case PagePseudoClassLeft:
<span class="line-modified">801                 builder.appendLiteral(&quot;:left&quot;);</span>
802                 break;
803             case PagePseudoClassRight:
<span class="line-modified">804                 builder.appendLiteral(&quot;:right&quot;);</span>
805                 break;
806             }
807         }
808 
809         if (cs-&gt;relation() != CSSSelector::Subselector || !cs-&gt;tagHistory())
810             break;
811         cs = cs-&gt;tagHistory();
812     }
813 
814     if (const CSSSelector* tagHistory = cs-&gt;tagHistory()) {
815         switch (cs-&gt;relation()) {
816         case CSSSelector::DescendantSpace:
<span class="line-modified">817             return tagHistory-&gt;selectorText(&quot; &quot; + builder.toString() + rightSide);</span>
818         case CSSSelector::Child:
<span class="line-modified">819             return tagHistory-&gt;selectorText(&quot; &gt; &quot; + builder.toString() + rightSide);</span>
820         case CSSSelector::DirectAdjacent:
<span class="line-modified">821             return tagHistory-&gt;selectorText(&quot; + &quot; + builder.toString() + rightSide);</span>
822         case CSSSelector::IndirectAdjacent:
<span class="line-modified">823             return tagHistory-&gt;selectorText(&quot; ~ &quot; + builder.toString() + rightSide);</span>
824         case CSSSelector::Subselector:
825             ASSERT_NOT_REACHED();
<span class="line-modified">826 #if !ASSERT_ENABLED</span>
827             FALLTHROUGH;
828 #endif
829         case CSSSelector::ShadowDescendant:
<span class="line-modified">830             return tagHistory-&gt;selectorText(builder.toString() + rightSide);</span>
831         }
832     }
<span class="line-modified">833     return builder.toString() + rightSide;</span>
834 }
835 
836 void CSSSelector::setAttribute(const QualifiedName&amp; value, bool convertToLowercase, AttributeMatchType matchType)
837 {
838     createRareData();
839     m_data.m_rareData-&gt;m_attribute = value;
840     m_data.m_rareData-&gt;m_attributeCanonicalLocalName = convertToLowercase ? value.localName().convertToASCIILowercase() : value.localName();
841     m_caseInsensitiveAttributeValueMatching = matchType == CaseInsensitive;
842 }
843 
844 void CSSSelector::setArgument(const AtomString&amp; value)
845 {
846     createRareData();
847     m_data.m_rareData-&gt;m_argument = value;
848 }
849 
<span class="line-modified">850 void CSSSelector::setArgumentList(std::unique_ptr&lt;Vector&lt;AtomString&gt;&gt; argumentList)</span>
851 {
852     createRareData();
<span class="line-modified">853     m_data.m_rareData-&gt;m_argumentList = WTFMove(argumentList);</span>
854 }
855 
856 void CSSSelector::setSelectorList(std::unique_ptr&lt;CSSSelectorList&gt; selectorList)
857 {
858     createRareData();
859     m_data.m_rareData-&gt;m_selectorList = WTFMove(selectorList);
860 }
861 
862 void CSSSelector::setNth(int a, int b)
863 {
864     createRareData();
865     m_data.m_rareData-&gt;m_a = a;
866     m_data.m_rareData-&gt;m_b = b;
867 }
868 
869 bool CSSSelector::matchNth(int count) const
870 {
871     ASSERT(m_hasRareData);
872     return m_data.m_rareData-&gt;matchNth(count);
873 }
</pre>
</td>
</tr>
</table>
<center><a href="CSSSegmentedFontFace.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSSelector.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringCommon.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringBuilder.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringHash.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/text/StringCommon.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
155 }
156 
157 ALWAYS_INLINE bool equal(const UChar* aUChar, const UChar* bUChar, unsigned length)
158 {
159     const char* a = reinterpret_cast&lt;const char*&gt;(aUChar);
160     const char* b = reinterpret_cast&lt;const char*&gt;(bUChar);
161 
162     unsigned wordLength = length &gt;&gt; 1;
163     for (unsigned i = 0; i != wordLength; ++i) {
164         if (unalignedLoad&lt;uint32_t&gt;(a) != unalignedLoad&lt;uint32_t&gt;(b))
165             return false;
166         a += sizeof(uint32_t);
167         b += sizeof(uint32_t);
168     }
169 
170     if (length &amp; 1 &amp;&amp; *reinterpret_cast&lt;const UChar*&gt;(a) != *reinterpret_cast&lt;const UChar*&gt;(b))
171         return false;
172 
173     return true;
174 }
<span class="line-modified">175 #elif PLATFORM(IOS_FAMILY) &amp;&amp; WTF_ARM_ARCH_AT_LEAST(7) &amp;&amp; !ASAN_ENABLED</span>
176 ALWAYS_INLINE bool equal(const LChar* a, const LChar* b, unsigned length)
177 {
178     bool isEqual = false;
179     uint32_t aValue;
180     uint32_t bValue;
181     asm(&quot;subs   %[length], #4\n&quot;
182         &quot;blo    2f\n&quot;
183 
184         &quot;0:\n&quot; // Label 0 = Start of loop over 32 bits.
185         &quot;ldr    %[aValue], [%[a]], #4\n&quot;
186         &quot;ldr    %[bValue], [%[b]], #4\n&quot;
187         &quot;cmp    %[aValue], %[bValue]\n&quot;
188         &quot;bne    66f\n&quot;
189         &quot;subs   %[length], #4\n&quot;
190         &quot;bhs    0b\n&quot;
191 
192         // At this point, length can be:
193         // -0: 00000000000000000000000000000000 (0 bytes left)
194         // -1: 11111111111111111111111111111111 (3 bytes left)
195         // -2: 11111111111111111111111111111110 (2 bytes left)
</pre>
<hr />
<pre>
553 }
554 
555 inline size_t find(const LChar* characters, unsigned length, UChar matchCharacter, unsigned index = 0)
556 {
557     if (!isLatin1(matchCharacter))
558         return notFound;
559     return find(characters, length, static_cast&lt;LChar&gt;(matchCharacter), index);
560 }
561 
562 template&lt;typename StringClass&gt;
563 size_t findCommon(const StringClass&amp; haystack, const StringClass&amp; needle, unsigned start)
564 {
565     unsigned needleLength = needle.length();
566 
567     if (needleLength == 1) {
568         if (haystack.is8Bit())
569             return WTF::find(haystack.characters8(), haystack.length(), needle[0], start);
570         return WTF::find(haystack.characters16(), haystack.length(), needle[0], start);
571     }
572 
<span class="line-removed">573     if (!needleLength)</span>
<span class="line-removed">574         return std::min(start, haystack.length());</span>
<span class="line-removed">575 </span>
576     if (start &gt; haystack.length())
577         return notFound;




578     unsigned searchLength = haystack.length() - start;
579     if (needleLength &gt; searchLength)
580         return notFound;
581 
582     if (haystack.is8Bit()) {
583         if (needle.is8Bit())
584             return findInner(haystack.characters8() + start, needle.characters8(), start, searchLength, needleLength);
585         return findInner(haystack.characters8() + start, needle.characters16(), start, searchLength, needleLength);
586     }
587 
588     if (needle.is8Bit())
589         return findInner(haystack.characters16() + start, needle.characters8(), start, searchLength, needleLength);
590 
591     return findInner(haystack.characters16() + start, needle.characters16(), start, searchLength, needleLength);
592 }
593 
594 // This is marked inline since it&#39;s mostly used in non-inline functions for each string type.
595 // When used directly in code it&#39;s probably OK to be inline; maybe the loop will be unrolled.
596 template&lt;typename CharacterType&gt; inline bool equalLettersIgnoringASCIICase(const CharacterType* characters, const char* lowercaseLetters, unsigned length)
597 {
598     for (unsigned i = 0; i &lt; length; ++i) {
599         if (!isASCIIAlphaCaselessEqual(characters[i], lowercaseLetters[i]))
600             return false;
601     }
602     return true;
603 }
604 
605 template&lt;typename CharacterType, unsigned lowercaseLettersLength&gt; inline bool equalLettersIgnoringASCIICase(const CharacterType* characters, unsigned charactersLength, const char (&amp;lowercaseLetters)[lowercaseLettersLength])
606 {
607     ASSERT(strlen(lowercaseLetters) == lowercaseLettersLength - 1);
608     unsigned lowercaseLettersStringLength = lowercaseLettersLength - 1;
609     return charactersLength == lowercaseLettersStringLength &amp;&amp; equalLettersIgnoringASCIICase(characters, lowercaseLetters, lowercaseLettersStringLength);
610 }
611 
612 template&lt;typename StringClass&gt; bool inline hasPrefixWithLettersIgnoringASCIICaseCommon(const StringClass&amp; string, const char* lowercaseLetters, unsigned length)
613 {
<span class="line-modified">614 #if !ASSERT_DISABLED</span>
615     ASSERT(*lowercaseLetters);
616     for (const char* letter = lowercaseLetters; *letter; ++letter)
617         ASSERT(toASCIILowerUnchecked(*letter) == *letter);
618 #endif
619     ASSERT(string.length() &gt;= length);
620 
621     if (string.is8Bit())
622         return equalLettersIgnoringASCIICase(string.characters8(), lowercaseLetters, length);
623     return equalLettersIgnoringASCIICase(string.characters16(), lowercaseLetters, length);
624 }
625 
626 // This is intentionally not marked inline because it&#39;s used often and is not speed-critical enough to want it inlined everywhere.
627 template&lt;typename StringClass&gt; bool equalLettersIgnoringASCIICaseCommonWithoutLength(const StringClass&amp; string, const char* lowercaseLetters)
628 {
629     unsigned length = string.length();
630     if (length != strlen(lowercaseLetters))
631         return false;
632     return hasPrefixWithLettersIgnoringASCIICaseCommon(string, lowercaseLetters, length);
633 }
634 
</pre>
</td>
<td>
<hr />
<pre>
155 }
156 
157 ALWAYS_INLINE bool equal(const UChar* aUChar, const UChar* bUChar, unsigned length)
158 {
159     const char* a = reinterpret_cast&lt;const char*&gt;(aUChar);
160     const char* b = reinterpret_cast&lt;const char*&gt;(bUChar);
161 
162     unsigned wordLength = length &gt;&gt; 1;
163     for (unsigned i = 0; i != wordLength; ++i) {
164         if (unalignedLoad&lt;uint32_t&gt;(a) != unalignedLoad&lt;uint32_t&gt;(b))
165             return false;
166         a += sizeof(uint32_t);
167         b += sizeof(uint32_t);
168     }
169 
170     if (length &amp; 1 &amp;&amp; *reinterpret_cast&lt;const UChar*&gt;(a) != *reinterpret_cast&lt;const UChar*&gt;(b))
171         return false;
172 
173     return true;
174 }
<span class="line-modified">175 #elif OS(DARWIN) &amp;&amp; WTF_ARM_ARCH_AT_LEAST(7) &amp;&amp; !ASAN_ENABLED</span>
176 ALWAYS_INLINE bool equal(const LChar* a, const LChar* b, unsigned length)
177 {
178     bool isEqual = false;
179     uint32_t aValue;
180     uint32_t bValue;
181     asm(&quot;subs   %[length], #4\n&quot;
182         &quot;blo    2f\n&quot;
183 
184         &quot;0:\n&quot; // Label 0 = Start of loop over 32 bits.
185         &quot;ldr    %[aValue], [%[a]], #4\n&quot;
186         &quot;ldr    %[bValue], [%[b]], #4\n&quot;
187         &quot;cmp    %[aValue], %[bValue]\n&quot;
188         &quot;bne    66f\n&quot;
189         &quot;subs   %[length], #4\n&quot;
190         &quot;bhs    0b\n&quot;
191 
192         // At this point, length can be:
193         // -0: 00000000000000000000000000000000 (0 bytes left)
194         // -1: 11111111111111111111111111111111 (3 bytes left)
195         // -2: 11111111111111111111111111111110 (2 bytes left)
</pre>
<hr />
<pre>
553 }
554 
555 inline size_t find(const LChar* characters, unsigned length, UChar matchCharacter, unsigned index = 0)
556 {
557     if (!isLatin1(matchCharacter))
558         return notFound;
559     return find(characters, length, static_cast&lt;LChar&gt;(matchCharacter), index);
560 }
561 
562 template&lt;typename StringClass&gt;
563 size_t findCommon(const StringClass&amp; haystack, const StringClass&amp; needle, unsigned start)
564 {
565     unsigned needleLength = needle.length();
566 
567     if (needleLength == 1) {
568         if (haystack.is8Bit())
569             return WTF::find(haystack.characters8(), haystack.length(), needle[0], start);
570         return WTF::find(haystack.characters16(), haystack.length(), needle[0], start);
571     }
572 



573     if (start &gt; haystack.length())
574         return notFound;
<span class="line-added">575 </span>
<span class="line-added">576     if (!needleLength)</span>
<span class="line-added">577         return start;</span>
<span class="line-added">578 </span>
579     unsigned searchLength = haystack.length() - start;
580     if (needleLength &gt; searchLength)
581         return notFound;
582 
583     if (haystack.is8Bit()) {
584         if (needle.is8Bit())
585             return findInner(haystack.characters8() + start, needle.characters8(), start, searchLength, needleLength);
586         return findInner(haystack.characters8() + start, needle.characters16(), start, searchLength, needleLength);
587     }
588 
589     if (needle.is8Bit())
590         return findInner(haystack.characters16() + start, needle.characters8(), start, searchLength, needleLength);
591 
592     return findInner(haystack.characters16() + start, needle.characters16(), start, searchLength, needleLength);
593 }
594 
595 // This is marked inline since it&#39;s mostly used in non-inline functions for each string type.
596 // When used directly in code it&#39;s probably OK to be inline; maybe the loop will be unrolled.
597 template&lt;typename CharacterType&gt; inline bool equalLettersIgnoringASCIICase(const CharacterType* characters, const char* lowercaseLetters, unsigned length)
598 {
599     for (unsigned i = 0; i &lt; length; ++i) {
600         if (!isASCIIAlphaCaselessEqual(characters[i], lowercaseLetters[i]))
601             return false;
602     }
603     return true;
604 }
605 
606 template&lt;typename CharacterType, unsigned lowercaseLettersLength&gt; inline bool equalLettersIgnoringASCIICase(const CharacterType* characters, unsigned charactersLength, const char (&amp;lowercaseLetters)[lowercaseLettersLength])
607 {
608     ASSERT(strlen(lowercaseLetters) == lowercaseLettersLength - 1);
609     unsigned lowercaseLettersStringLength = lowercaseLettersLength - 1;
610     return charactersLength == lowercaseLettersStringLength &amp;&amp; equalLettersIgnoringASCIICase(characters, lowercaseLetters, lowercaseLettersStringLength);
611 }
612 
613 template&lt;typename StringClass&gt; bool inline hasPrefixWithLettersIgnoringASCIICaseCommon(const StringClass&amp; string, const char* lowercaseLetters, unsigned length)
614 {
<span class="line-modified">615 #if ASSERT_ENABLED</span>
616     ASSERT(*lowercaseLetters);
617     for (const char* letter = lowercaseLetters; *letter; ++letter)
618         ASSERT(toASCIILowerUnchecked(*letter) == *letter);
619 #endif
620     ASSERT(string.length() &gt;= length);
621 
622     if (string.is8Bit())
623         return equalLettersIgnoringASCIICase(string.characters8(), lowercaseLetters, length);
624     return equalLettersIgnoringASCIICase(string.characters16(), lowercaseLetters, length);
625 }
626 
627 // This is intentionally not marked inline because it&#39;s used often and is not speed-critical enough to want it inlined everywhere.
628 template&lt;typename StringClass&gt; bool equalLettersIgnoringASCIICaseCommonWithoutLength(const StringClass&amp; string, const char* lowercaseLetters)
629 {
630     unsigned length = string.length();
631     if (length != strlen(lowercaseLetters))
632         return false;
633     return hasPrefixWithLettersIgnoringASCIICaseCommon(string, lowercaseLetters, length);
634 }
635 
</pre>
</td>
</tr>
</table>
<center><a href="StringBuilder.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="StringHash.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
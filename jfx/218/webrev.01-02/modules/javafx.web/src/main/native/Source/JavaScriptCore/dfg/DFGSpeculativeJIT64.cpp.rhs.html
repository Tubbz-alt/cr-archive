<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;DFGSpeculativeJIT.h&quot;
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;AtomicsObject.h&quot;
  33 #include &quot;CallFrameShuffler.h&quot;
  34 #include &quot;DFGAbstractInterpreterInlines.h&quot;
  35 #include &quot;DFGCallArrayAllocatorSlowPathGenerator.h&quot;
  36 #include &quot;DFGDoesGC.h&quot;
  37 #include &quot;DFGOperations.h&quot;
  38 #include &quot;DFGSlowPathGenerator.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  39 #include &quot;DateInstance.h&quot;</span>
  40 #include &quot;DirectArguments.h&quot;
  41 #include &quot;GetterSetter.h&quot;
  42 #include &quot;HasOwnPropertyCache.h&quot;
  43 #include &quot;JSCInlines.h&quot;
  44 #include &quot;JSLexicalEnvironment.h&quot;
  45 #include &quot;JSMap.h&quot;
  46 #include &quot;JSPropertyNameEnumerator.h&quot;
  47 #include &quot;JSSet.h&quot;
  48 #include &quot;ObjectPrototype.h&quot;
  49 #include &quot;SetupVarargsFrame.h&quot;
  50 #include &quot;SpillRegistersMode.h&quot;
  51 #include &quot;StringPrototype.h&quot;
  52 #include &quot;SuperSampler.h&quot;
  53 #include &quot;Watchdog.h&quot;
  54 
  55 namespace JSC { namespace DFG {
  56 
  57 #if USE(JSVALUE64)
  58 
  59 void SpeculativeJIT::boxInt52(GPRReg sourceGPR, GPRReg targetGPR, DataFormat format)
  60 {
  61     GPRReg tempGPR;
  62     if (sourceGPR == targetGPR)
  63         tempGPR = allocate();
  64     else
  65         tempGPR = targetGPR;
  66 
  67     FPRReg fpr = fprAllocate();
  68 
  69     if (format == DataFormatInt52)
  70         m_jit.rshift64(TrustedImm32(JSValue::int52ShiftAmount), sourceGPR);
  71     else
  72         ASSERT(format == DataFormatStrictInt52);
  73 
  74     m_jit.boxInt52(sourceGPR, targetGPR, tempGPR, fpr);
  75 
  76     if (format == DataFormatInt52 &amp;&amp; sourceGPR != targetGPR)
  77         m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), sourceGPR);
  78 
  79     if (tempGPR != targetGPR)
  80         unlock(tempGPR);
  81 
  82     unlock(fpr);
  83 }
  84 
  85 GPRReg SpeculativeJIT::fillJSValue(Edge edge)
  86 {
  87     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
  88     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
  89 
  90     switch (info.registerFormat()) {
  91     case DataFormatNone: {
  92         GPRReg gpr = allocate();
  93 
  94         if (edge-&gt;hasConstant()) {
  95             JSValue jsValue = edge-&gt;asJSValue();
  96             m_jit.move(MacroAssembler::TrustedImm64(JSValue::encode(jsValue)), gpr);
  97             info.fillJSValue(*m_stream, gpr, DataFormatJS);
  98             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
  99         } else {
 100             DataFormat spillFormat = info.spillFormat();
 101             m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
 102             switch (spillFormat) {
 103             case DataFormatInt32: {
 104                 m_jit.load32(JITCompiler::addressFor(virtualRegister), gpr);
<a name="2" id="anc2"></a><span class="line-modified"> 105                 m_jit.or64(GPRInfo::numberTagRegister, gpr);</span>
 106                 spillFormat = DataFormatJSInt32;
 107                 break;
 108             }
 109 
 110             default:
 111                 m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
 112                 DFG_ASSERT(m_jit.graph(), m_currentNode, spillFormat &amp; DataFormatJS, spillFormat);
 113                 break;
 114             }
 115             info.fillJSValue(*m_stream, gpr, spillFormat);
 116         }
 117         return gpr;
 118     }
 119 
 120     case DataFormatInt32: {
 121         GPRReg gpr = info.gpr();
 122         // If the register has already been locked we need to take a copy.
 123         // If not, we&#39;ll zero extend in place, so mark on the info that this is now type DataFormatInt32, not DataFormatJSInt32.
 124         if (m_gprs.isLocked(gpr)) {
 125             GPRReg result = allocate();
<a name="3" id="anc3"></a><span class="line-modified"> 126             m_jit.or64(GPRInfo::numberTagRegister, gpr, result);</span>
 127             return result;
 128         }
 129         m_gprs.lock(gpr);
<a name="4" id="anc4"></a><span class="line-modified"> 130         m_jit.or64(GPRInfo::numberTagRegister, gpr);</span>
 131         info.fillJSValue(*m_stream, gpr, DataFormatJSInt32);
 132         return gpr;
 133     }
 134 
 135     case DataFormatCell:
 136         // No retag required on JSVALUE64!
 137     case DataFormatJS:
 138     case DataFormatJSInt32:
 139     case DataFormatJSDouble:
 140     case DataFormatJSCell:
 141     case DataFormatJSBoolean: {
 142         GPRReg gpr = info.gpr();
 143         m_gprs.lock(gpr);
 144         return gpr;
 145     }
 146 
 147     case DataFormatBoolean:
 148     case DataFormatStorage:
 149     case DataFormatDouble:
 150     case DataFormatInt52:
 151         // this type currently never occurs
 152         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
 153 
 154     default:
 155         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Corrupt data format&quot;);
 156         return InvalidGPRReg;
 157     }
 158 }
 159 
 160 void SpeculativeJIT::cachedGetById(CodeOrigin origin, JSValueRegs base, JSValueRegs result, unsigned identifierNumber, JITCompiler::Jump slowPathTarget , SpillRegistersMode mode, AccessType type)
 161 {
 162     cachedGetById(origin, base.gpr(), result.gpr(), identifierNumber, slowPathTarget, mode, type);
 163 }
 164 
 165 void SpeculativeJIT::cachedGetById(CodeOrigin codeOrigin, GPRReg baseGPR, GPRReg resultGPR, unsigned identifierNumber, JITCompiler::Jump slowPathTarget, SpillRegistersMode spillMode, AccessType type)
 166 {
 167     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 168     RegisterSet usedRegisters = this-&gt;usedRegisters();
 169     if (spillMode == DontSpill) {
 170         // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
 171         usedRegisters.set(baseGPR, false);
 172         usedRegisters.set(resultGPR, false);
 173     }
 174     JITGetByIdGenerator gen(
 175         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
 176         JSValueRegs(baseGPR), JSValueRegs(resultGPR), type);
 177     gen.generateFastPath(m_jit);
 178 
 179     JITCompiler::JumpList slowCases;
 180     slowCases.append(slowPathTarget);
 181     slowCases.append(gen.slowPathJump());
 182 
 183     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
 184         slowCases, this, appropriateOptimizingGetByIdFunction(type),
 185         spillMode, ExceptionCheckRequirement::CheckNeeded,
<a name="5" id="anc5"></a><span class="line-modified"> 186         resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), baseGPR, identifierUID(identifierNumber));</span>
 187 
 188     m_jit.addGetById(gen, slowPath.get());
 189     addSlowPathGenerator(WTFMove(slowPath));
 190 }
 191 
 192 void SpeculativeJIT::cachedGetByIdWithThis(CodeOrigin codeOrigin, GPRReg baseGPR, GPRReg thisGPR, GPRReg resultGPR, unsigned identifierNumber, const JITCompiler::JumpList&amp; slowPathTarget)
 193 {
 194     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());
 195     RegisterSet usedRegisters = this-&gt;usedRegisters();
 196     // We&#39;ve already flushed registers to the stack, we don&#39;t need to spill these.
 197     usedRegisters.set(baseGPR, false);
 198     usedRegisters.set(thisGPR, false);
 199     usedRegisters.set(resultGPR, false);
 200 
 201     JITGetByIdWithThisGenerator gen(
 202         m_jit.codeBlock(), codeOrigin, callSite, usedRegisters, identifierUID(identifierNumber),
<a name="6" id="anc6"></a><span class="line-modified"> 203         JSValueRegs(resultGPR), JSValueRegs(baseGPR), JSValueRegs(thisGPR));</span>
 204     gen.generateFastPath(m_jit);
 205 
 206     JITCompiler::JumpList slowCases;
 207     slowCases.append(slowPathTarget);
 208     slowCases.append(gen.slowPathJump());
 209 
 210     std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(
 211         slowCases, this, operationGetByIdWithThisOptimize,
 212         DontSpill, ExceptionCheckRequirement::CheckNeeded,
<a name="7" id="anc7"></a><span class="line-modified"> 213         resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), baseGPR, thisGPR, identifierUID(identifierNumber));</span>
 214 
 215     m_jit.addGetByIdWithThis(gen, slowPath.get());
 216     addSlowPathGenerator(WTFMove(slowPath));
 217 }
 218 
 219 void SpeculativeJIT::nonSpeculativeNonPeepholeCompareNullOrUndefined(Edge operand)
 220 {
 221     JSValueOperand arg(this, operand, ManualOperandSpeculation);
 222     GPRReg argGPR = arg.gpr();
 223 
 224     GPRTemporary result(this);
 225     GPRReg resultGPR = result.gpr();
 226 
 227     m_jit.move(TrustedImm32(0), resultGPR);
 228 
 229     JITCompiler::JumpList done;
 230     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 231         if (!isKnownNotCell(operand.node()))
 232             done.append(m_jit.branchIfCell(JSValueRegs(argGPR)));
 233     } else {
 234         GPRTemporary localGlobalObject(this);
 235         GPRTemporary remoteGlobalObject(this);
 236         GPRTemporary scratch(this);
 237 
 238         JITCompiler::Jump notCell;
 239         if (!isKnownCell(operand.node()))
 240             notCell = m_jit.branchIfNotCell(JSValueRegs(argGPR));
 241 
 242         JITCompiler::Jump isNotMasqueradesAsUndefined = m_jit.branchTest8(
 243             JITCompiler::Zero,
 244             JITCompiler::Address(argGPR, JSCell::typeInfoFlagsOffset()),
 245             JITCompiler::TrustedImm32(MasqueradesAsUndefined));
 246         done.append(isNotMasqueradesAsUndefined);
 247 
 248         GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
 249         GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
 250         m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic)), localGlobalObjectGPR);
 251         m_jit.emitLoadStructure(vm(), argGPR, resultGPR, scratch.gpr());
 252         m_jit.loadPtr(JITCompiler::Address(resultGPR, Structure::globalObjectOffset()), remoteGlobalObjectGPR);
 253         m_jit.comparePtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, resultGPR);
 254         done.append(m_jit.jump());
 255         if (!isKnownCell(operand.node()))
 256             notCell.link(&amp;m_jit);
 257     }
 258 
 259     if (!isKnownNotOther(operand.node())) {
 260         m_jit.move(argGPR, resultGPR);
<a name="8" id="anc8"></a><span class="line-modified"> 261         m_jit.and64(JITCompiler::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
<span class="line-modified"> 262         m_jit.compare64(JITCompiler::Equal, resultGPR, JITCompiler::TrustedImm32(JSValue::ValueNull), resultGPR);</span>
 263     }
 264 
 265     done.link(&amp;m_jit);
 266 
<a name="9" id="anc9"></a><span class="line-modified"> 267     m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
 268     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
 269 }
 270 
 271 void SpeculativeJIT::nonSpeculativePeepholeBranchNullOrUndefined(Edge operand, Node* branchNode)
 272 {
 273     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 274     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 275 
 276     JSValueOperand arg(this, operand, ManualOperandSpeculation);
 277     GPRReg argGPR = arg.gpr();
 278 
 279     GPRTemporary result(this, Reuse, arg);
 280     GPRReg resultGPR = result.gpr();
 281 
 282     // First, handle the case where &quot;operand&quot; is a cell.
 283     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
 284         if (!isKnownNotCell(operand.node())) {
 285             JITCompiler::Jump isCell = m_jit.branchIfCell(JSValueRegs(argGPR));
 286             addBranch(isCell, notTaken);
 287         }
 288     } else {
 289         GPRTemporary localGlobalObject(this);
 290         GPRTemporary remoteGlobalObject(this);
 291         GPRTemporary scratch(this);
 292 
 293         JITCompiler::Jump notCell;
 294         if (!isKnownCell(operand.node()))
 295             notCell = m_jit.branchIfNotCell(JSValueRegs(argGPR));
 296 
 297         branchTest8(JITCompiler::Zero,
 298             JITCompiler::Address(argGPR, JSCell::typeInfoFlagsOffset()),
 299             JITCompiler::TrustedImm32(MasqueradesAsUndefined), notTaken);
 300 
 301         GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
 302         GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
 303         m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic)), localGlobalObjectGPR);
 304         m_jit.emitLoadStructure(vm(), argGPR, resultGPR, scratch.gpr());
 305         m_jit.loadPtr(JITCompiler::Address(resultGPR, Structure::globalObjectOffset()), remoteGlobalObjectGPR);
 306         branchPtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, taken);
 307 
 308         if (!isKnownCell(operand.node())) {
 309             jump(notTaken, ForceJump);
 310             notCell.link(&amp;m_jit);
 311         }
 312     }
 313 
 314     if (isKnownNotOther(operand.node()))
 315         jump(notTaken);
 316     else {
 317         JITCompiler::RelationalCondition condition = JITCompiler::Equal;
 318         if (taken == nextBlock()) {
 319             condition = JITCompiler::NotEqual;
 320             std::swap(taken, notTaken);
 321         }
 322         m_jit.move(argGPR, resultGPR);
<a name="10" id="anc10"></a><span class="line-modified"> 323         m_jit.and64(JITCompiler::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
<span class="line-modified"> 324         branch64(condition, resultGPR, JITCompiler::TrustedImm64(JSValue::ValueNull), taken);</span>
 325         jump(notTaken);
 326     }
 327 }
 328 
 329 void SpeculativeJIT::nonSpeculativePeepholeStrictEq(Node* node, Node* branchNode, bool invert)
 330 {
 331     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
 332     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
 333 
 334     // The branch instruction will branch to the taken block.
 335     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
 336     if (taken == nextBlock()) {
 337         invert = !invert;
 338         BasicBlock* tmp = taken;
 339         taken = notTaken;
 340         notTaken = tmp;
 341     }
 342 
 343     JSValueOperand arg1(this, node-&gt;child1());
 344     JSValueOperand arg2(this, node-&gt;child2());
 345     GPRReg arg1GPR = arg1.gpr();
 346     GPRReg arg2GPR = arg2.gpr();
 347 
 348     GPRTemporary result(this);
 349     GPRReg resultGPR = result.gpr();
 350 
 351     arg1.use();
 352     arg2.use();
 353 
 354     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 355         // see if we get lucky: if the arguments are cells and they reference the same
 356         // cell, then they must be strictly equal.
 357         branch64(JITCompiler::Equal, arg1GPR, arg2GPR, invert ? notTaken : taken);
 358 
 359         silentSpillAllRegisters(resultGPR);
<a name="11" id="anc11"></a><span class="line-modified"> 360         callOperation(operationCompareStrictEqCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR);</span>
 361         silentFillAllRegisters();
 362         m_jit.exceptionCheck();
 363 
 364         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultGPR, taken);
 365     } else {
 366         m_jit.or64(arg1GPR, arg2GPR, resultGPR);
 367 
 368         JITCompiler::Jump twoCellsCase = m_jit.branchIfCell(resultGPR);
 369 
 370         JITCompiler::Jump leftOK = m_jit.branchIfInt32(arg1GPR);
 371         JITCompiler::Jump leftDouble = m_jit.branchIfNumber(arg1GPR);
 372         leftOK.link(&amp;m_jit);
 373         JITCompiler::Jump rightOK = m_jit.branchIfInt32(arg2GPR);
 374         JITCompiler::Jump rightDouble = m_jit.branchIfNumber(arg2GPR);
 375         rightOK.link(&amp;m_jit);
 376 
 377         branch64(invert ? JITCompiler::NotEqual : JITCompiler::Equal, arg1GPR, arg2GPR, taken);
 378         jump(notTaken, ForceJump);
 379 
 380         twoCellsCase.link(&amp;m_jit);
 381         branch64(JITCompiler::Equal, arg1GPR, arg2GPR, invert ? notTaken : taken);
 382 
 383         leftDouble.link(&amp;m_jit);
 384         rightDouble.link(&amp;m_jit);
 385 
 386         silentSpillAllRegisters(resultGPR);
<a name="12" id="anc12"></a><span class="line-modified"> 387         callOperation(operationCompareStrictEq, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR);</span>
 388         silentFillAllRegisters();
 389         m_jit.exceptionCheck();
 390 
 391         branchTest32(invert ? JITCompiler::Zero : JITCompiler::NonZero, resultGPR, taken);
 392     }
 393 
 394     jump(notTaken);
 395 }
 396 
 397 void SpeculativeJIT::nonSpeculativeNonPeepholeStrictEq(Node* node, bool invert)
 398 {
 399     JSValueOperand arg1(this, node-&gt;child1());
 400     JSValueOperand arg2(this, node-&gt;child2());
 401     JSValueRegs arg1Regs = arg1.jsValueRegs();
 402     JSValueRegs arg2Regs = arg2.jsValueRegs();
 403 
 404     GPRTemporary result(this);
 405     GPRReg resultGPR = result.gpr();
 406 
 407     arg1.use();
 408     arg2.use();
 409 
 410     if (isKnownCell(node-&gt;child1().node()) &amp;&amp; isKnownCell(node-&gt;child2().node())) {
 411         // see if we get lucky: if the arguments are cells and they reference the same
 412         // cell, then they must be strictly equal.
 413         // FIXME: this should flush registers instead of silent spill/fill.
 414         JITCompiler::Jump notEqualCase = m_jit.branch64(JITCompiler::NotEqual, arg1Regs.gpr(), arg2Regs.gpr());
 415 
 416         m_jit.move(JITCompiler::TrustedImm64(!invert), resultGPR);
 417 
 418         JITCompiler::Jump done = m_jit.jump();
 419 
 420         notEqualCase.link(&amp;m_jit);
 421 
 422         silentSpillAllRegisters(resultGPR);
<a name="13" id="anc13"></a><span class="line-modified"> 423         callOperation(operationCompareStrictEqCell, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs);</span>
 424         silentFillAllRegisters();
 425         m_jit.exceptionCheck();
 426 
 427         done.link(&amp;m_jit);
 428         unblessedBooleanResult(resultGPR, m_currentNode, UseChildrenCalledExplicitly);
 429         return;
 430     }
 431 
 432     m_jit.or64(arg1Regs.gpr(), arg2Regs.gpr(), resultGPR);
 433 
 434     JITCompiler::JumpList slowPathCases;
 435 
 436     JITCompiler::Jump twoCellsCase = m_jit.branchIfCell(resultGPR);
 437 
 438     JITCompiler::Jump leftOK = m_jit.branchIfInt32(arg1Regs);
 439     slowPathCases.append(m_jit.branchIfNumber(arg1Regs, InvalidGPRReg));
 440     leftOK.link(&amp;m_jit);
 441     JITCompiler::Jump rightOK = m_jit.branchIfInt32(arg2Regs);
 442     slowPathCases.append(m_jit.branchIfNumber(arg2Regs, InvalidGPRReg));
 443     rightOK.link(&amp;m_jit);
 444 
 445     m_jit.compare64(invert ? JITCompiler::NotEqual : JITCompiler::Equal, arg1Regs.gpr(), arg2Regs.gpr(), resultGPR);
 446 
 447     JITCompiler::Jump done = m_jit.jump();
 448 
 449     twoCellsCase.link(&amp;m_jit);
 450     slowPathCases.append(m_jit.branch64(JITCompiler::NotEqual, arg1Regs.gpr(), arg2Regs.gpr()));
 451 
 452     m_jit.move(JITCompiler::TrustedImm64(!invert), resultGPR);
 453 
<a name="14" id="anc14"></a><span class="line-modified"> 454     addSlowPathGenerator(slowPathCall(slowPathCases, this, operationCompareStrictEq, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1Regs, arg2Regs));</span>
 455 
 456     done.link(&amp;m_jit);
 457 
 458     unblessedBooleanResult(resultGPR, m_currentNode, UseChildrenCalledExplicitly);
 459 }
 460 
 461 void SpeculativeJIT::emitCall(Node* node)
 462 {
 463     CallLinkInfo::CallType callType;
 464     bool isVarargs = false;
 465     bool isForwardVarargs = false;
 466     bool isTail = false;
 467     bool isEmulatedTail = false;
 468     bool isDirect = false;
 469     switch (node-&gt;op()) {
 470     case Call:
 471     case CallEval:
 472         callType = CallLinkInfo::Call;
 473         break;
 474     case TailCall:
 475         callType = CallLinkInfo::TailCall;
 476         isTail = true;
 477         break;
 478     case TailCallInlinedCaller:
 479         callType = CallLinkInfo::Call;
 480         isEmulatedTail = true;
 481         break;
 482     case Construct:
 483         callType = CallLinkInfo::Construct;
 484         break;
 485     case CallVarargs:
 486         callType = CallLinkInfo::CallVarargs;
 487         isVarargs = true;
 488         break;
 489     case TailCallVarargs:
 490         callType = CallLinkInfo::TailCallVarargs;
 491         isVarargs = true;
 492         isTail = true;
 493         break;
 494     case TailCallVarargsInlinedCaller:
 495         callType = CallLinkInfo::CallVarargs;
 496         isVarargs = true;
 497         isEmulatedTail = true;
 498         break;
 499     case ConstructVarargs:
 500         callType = CallLinkInfo::ConstructVarargs;
 501         isVarargs = true;
 502         break;
 503     case CallForwardVarargs:
 504         callType = CallLinkInfo::CallVarargs;
 505         isForwardVarargs = true;
 506         break;
 507     case ConstructForwardVarargs:
 508         callType = CallLinkInfo::ConstructVarargs;
 509         isForwardVarargs = true;
 510         break;
 511     case TailCallForwardVarargs:
 512         callType = CallLinkInfo::TailCallVarargs;
 513         isTail = true;
 514         isForwardVarargs = true;
 515         break;
 516     case TailCallForwardVarargsInlinedCaller:
 517         callType = CallLinkInfo::CallVarargs;
 518         isEmulatedTail = true;
 519         isForwardVarargs = true;
 520         break;
 521     case DirectCall:
 522         callType = CallLinkInfo::DirectCall;
 523         isDirect = true;
 524         break;
 525     case DirectConstruct:
 526         callType = CallLinkInfo::DirectConstruct;
 527         isDirect = true;
 528         break;
 529     case DirectTailCall:
 530         callType = CallLinkInfo::DirectTailCall;
 531         isTail = true;
 532         isDirect = true;
 533         break;
 534     case DirectTailCallInlinedCaller:
 535         callType = CallLinkInfo::DirectCall;
 536         isEmulatedTail = true;
 537         isDirect = true;
 538         break;
 539     default:
 540         DFG_CRASH(m_jit.graph(), node, &quot;bad node type&quot;);
 541         break;
 542     }
 543 
 544     GPRReg calleeGPR = InvalidGPRReg;
 545     CallFrameShuffleData shuffleData;
 546 
<a name="15" id="anc15"></a><span class="line-added"> 547     JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);</span>
 548     ExecutableBase* executable = nullptr;
 549     FunctionExecutable* functionExecutable = nullptr;
 550     if (isDirect) {
 551         executable = node-&gt;castOperand&lt;ExecutableBase*&gt;();
 552         functionExecutable = jsDynamicCast&lt;FunctionExecutable*&gt;(vm(), executable);
 553     }
 554 
 555     unsigned numPassedArgs = 0;
 556     unsigned numAllocatedArgs = 0;
 557 
 558     // Gotta load the arguments somehow. Varargs is trickier.
 559     if (isVarargs || isForwardVarargs) {
 560         RELEASE_ASSERT(!isDirect);
 561         CallVarargsData* data = node-&gt;callVarargsData();
 562 
 563         int numUsedStackSlots = m_jit.graph().m_nextMachineLocal;
 564 
 565         if (isForwardVarargs) {
 566             flushRegisters();
 567             if (node-&gt;child3())
 568                 use(node-&gt;child3());
 569 
 570             GPRReg scratchGPR1;
 571             GPRReg scratchGPR2;
 572             GPRReg scratchGPR3;
 573 
 574             scratchGPR1 = JITCompiler::selectScratchGPR();
 575             scratchGPR2 = JITCompiler::selectScratchGPR(scratchGPR1);
 576             scratchGPR3 = JITCompiler::selectScratchGPR(scratchGPR1, scratchGPR2);
 577 
 578             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR2);
 579             JITCompiler::JumpList slowCase;
 580             InlineCallFrame* inlineCallFrame;
 581             if (node-&gt;child3())
 582                 inlineCallFrame = node-&gt;child3()-&gt;origin.semantic.inlineCallFrame();
 583             else
 584                 inlineCallFrame = node-&gt;origin.semantic.inlineCallFrame();
 585             // emitSetupVarargsFrameFastCase modifies the stack pointer if it succeeds.
 586             emitSetupVarargsFrameFastCase(vm(), m_jit, scratchGPR2, scratchGPR1, scratchGPR2, scratchGPR3, inlineCallFrame, data-&gt;firstVarArgOffset, slowCase);
 587             JITCompiler::Jump done = m_jit.jump();
 588             slowCase.link(&amp;m_jit);
<a name="16" id="anc16"></a><span class="line-modified"> 589             callOperation(operationThrowStackOverflowForVarargs, TrustedImmPtr::weakPointer(m_graph, globalObject));</span>
 590             m_jit.exceptionCheck();
 591             m_jit.abortWithReason(DFGVarargsThrowingPathDidNotThrow);
 592             done.link(&amp;m_jit);
 593         } else {
 594             GPRReg argumentsGPR;
 595             GPRReg scratchGPR1;
 596             GPRReg scratchGPR2;
 597             GPRReg scratchGPR3;
 598 
 599             auto loadArgumentsGPR = [&amp;] (GPRReg reservedGPR) {
 600                 if (reservedGPR != InvalidGPRReg)
 601                     lock(reservedGPR);
 602                 JSValueOperand arguments(this, node-&gt;child3());
 603                 argumentsGPR = arguments.gpr();
 604                 if (reservedGPR != InvalidGPRReg)
 605                     unlock(reservedGPR);
 606                 flushRegisters();
 607 
 608                 scratchGPR1 = JITCompiler::selectScratchGPR(argumentsGPR, reservedGPR);
 609                 scratchGPR2 = JITCompiler::selectScratchGPR(argumentsGPR, scratchGPR1, reservedGPR);
 610                 scratchGPR3 = JITCompiler::selectScratchGPR(argumentsGPR, scratchGPR1, scratchGPR2, reservedGPR);
 611             };
 612 
 613             loadArgumentsGPR(InvalidGPRReg);
 614 
 615             DFG_ASSERT(m_jit.graph(), node, isFlushed());
 616 
 617             // Right now, arguments is in argumentsGPR and the register file is flushed.
<a name="17" id="anc17"></a><span class="line-modified"> 618             callOperation(operationSizeFrameForVarargs, GPRInfo::returnValueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentsGPR, numUsedStackSlots, data-&gt;firstVarArgOffset);</span>
 619             m_jit.exceptionCheck();
 620 
 621             // Now we have the argument count of the callee frame, but we&#39;ve lost the arguments operand.
 622             // Reconstruct the arguments operand while preserving the callee frame.
 623             loadArgumentsGPR(GPRInfo::returnValueGPR);
 624             m_jit.move(TrustedImm32(numUsedStackSlots), scratchGPR1);
 625             emitSetVarargsFrame(m_jit, GPRInfo::returnValueGPR, false, scratchGPR1, scratchGPR1);
 626             m_jit.addPtr(TrustedImm32(-(sizeof(CallerFrameAndPC) + WTF::roundUpToMultipleOf(stackAlignmentBytes(), 5 * sizeof(void*)))), scratchGPR1, JITCompiler::stackPointerRegister);
 627 
<a name="18" id="anc18"></a><span class="line-modified"> 628             callOperation(operationSetupVarargsFrame, GPRInfo::returnValueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), scratchGPR1, argumentsGPR, data-&gt;firstVarArgOffset, GPRInfo::returnValueGPR);</span>
 629             m_jit.exceptionCheck();
 630             m_jit.addPtr(TrustedImm32(sizeof(CallerFrameAndPC)), GPRInfo::returnValueGPR, JITCompiler::stackPointerRegister);
 631         }
 632 
 633         DFG_ASSERT(m_jit.graph(), node, isFlushed());
 634 
 635         // We don&#39;t need the arguments array anymore.
 636         if (isVarargs)
 637             use(node-&gt;child3());
 638 
 639         // Now set up the &quot;this&quot; argument.
 640         JSValueOperand thisArgument(this, node-&gt;child2());
 641         GPRReg thisArgumentGPR = thisArgument.gpr();
 642         thisArgument.use();
 643 
 644         m_jit.store64(thisArgumentGPR, JITCompiler::calleeArgumentSlot(0));
 645     } else {
 646         // The call instruction&#39;s first child is the function; the subsequent children are the
 647         // arguments.
 648         numPassedArgs = node-&gt;numChildren() - 1;
 649         numAllocatedArgs = numPassedArgs;
 650 
 651         if (functionExecutable) {
 652             // Allocate more args if this would let us avoid arity checks. This is throttled by
 653             // CallLinkInfo&#39;s limit. It&#39;s probably good to throttle it - if the callee wants a
 654             // ginormous amount of argument space then it&#39;s better for them to do it so that when we
 655             // make calls to other things, we don&#39;t waste space.
 656             unsigned desiredNumAllocatedArgs = static_cast&lt;unsigned&gt;(functionExecutable-&gt;parameterCount()) + 1;
 657             if (desiredNumAllocatedArgs &lt;= Options::maximumDirectCallStackSize()) {
 658                 numAllocatedArgs = std::max(numAllocatedArgs, desiredNumAllocatedArgs);
 659 
 660                 // Whoever converts to DirectCall should do this adjustment. It&#39;s too late for us to
 661                 // do this adjustment now since we will have already emitted code that relied on the
 662                 // value of m_parameterSlots.
 663                 DFG_ASSERT(
 664                     m_jit.graph(), node,
 665                     Graph::parameterSlotsForArgCount(numAllocatedArgs)
 666                     &lt;= m_jit.graph().m_parameterSlots);
 667             }
 668         }
 669 
 670         if (isTail) {
 671             Edge calleeEdge = m_jit.graph().child(node, 0);
 672             JSValueOperand callee(this, calleeEdge);
 673             calleeGPR = callee.gpr();
 674             if (!isDirect)
 675                 callee.use();
 676 
<a name="19" id="anc19"></a><span class="line-modified"> 677             shuffleData.numberTagRegister = GPRInfo::numberTagRegister;</span>
 678             shuffleData.numLocals = m_jit.graph().frameRegisterCount();
 679             shuffleData.callee = ValueRecovery::inGPR(calleeGPR, DataFormatJS);
 680             shuffleData.args.resize(numAllocatedArgs);
 681             shuffleData.numPassedArgs = numPassedArgs;
 682 
 683             for (unsigned i = 0; i &lt; numPassedArgs; ++i) {
 684                 Edge argEdge = m_jit.graph().varArgChild(node, i + 1);
 685                 GenerationInfo&amp; info = generationInfo(argEdge.node());
 686                 if (!isDirect)
 687                     use(argEdge);
 688                 shuffleData.args[i] = info.recovery(argEdge-&gt;virtualRegister());
 689             }
 690 
 691             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 692                 shuffleData.args[i] = ValueRecovery::constant(jsUndefined());
 693 
 694             shuffleData.setupCalleeSaveRegisters(m_jit.codeBlock());
 695         } else {
<a name="20" id="anc20"></a><span class="line-modified"> 696             m_jit.store32(MacroAssembler::TrustedImm32(numPassedArgs), JITCompiler::calleeFramePayloadSlot(CallFrameSlot::argumentCountIncludingThis));</span>
 697 
 698             for (unsigned i = 0; i &lt; numPassedArgs; i++) {
 699                 Edge argEdge = m_jit.graph().m_varArgChildren[node-&gt;firstChild() + 1 + i];
 700                 JSValueOperand arg(this, argEdge);
 701                 GPRReg argGPR = arg.gpr();
 702                 use(argEdge);
 703 
 704                 m_jit.store64(argGPR, JITCompiler::calleeArgumentSlot(i));
 705             }
 706 
 707             for (unsigned i = numPassedArgs; i &lt; numAllocatedArgs; ++i)
 708                 m_jit.storeTrustedValue(jsUndefined(), JITCompiler::calleeArgumentSlot(i));
 709         }
 710     }
 711 
 712     if (!isTail || isVarargs || isForwardVarargs) {
 713         Edge calleeEdge = m_jit.graph().child(node, 0);
 714         JSValueOperand callee(this, calleeEdge);
 715         calleeGPR = callee.gpr();
 716         callee.use();
 717         m_jit.store64(calleeGPR, JITCompiler::calleeFrameSlot(CallFrameSlot::callee));
 718 
 719         flushRegisters();
 720     }
 721 
 722     CodeOrigin staticOrigin = node-&gt;origin.semantic;
 723     InlineCallFrame* staticInlineCallFrame = staticOrigin.inlineCallFrame();
 724     ASSERT(!isTail || !staticInlineCallFrame || !staticInlineCallFrame-&gt;getCallerSkippingTailCalls());
 725     ASSERT(!isEmulatedTail || (staticInlineCallFrame &amp;&amp; staticInlineCallFrame-&gt;getCallerSkippingTailCalls()));
 726     CodeOrigin dynamicOrigin =
 727         isEmulatedTail ? *staticInlineCallFrame-&gt;getCallerSkippingTailCalls() : staticOrigin;
 728 
 729     CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(dynamicOrigin, m_stream-&gt;size());
 730 
 731     auto setResultAndResetStack = [&amp;] () {
 732         GPRFlushedCallResult result(this);
 733         GPRReg resultGPR = result.gpr();
 734         m_jit.move(GPRInfo::returnValueGPR, resultGPR);
 735 
 736         jsValueResult(resultGPR, m_currentNode, DataFormatJS, UseChildrenCalledExplicitly);
 737 
 738         // After the calls are done, we need to reestablish our stack
 739         // pointer. We rely on this for varargs calls, calls with arity
 740         // mismatch (the callframe is slided) and tail calls.
 741         m_jit.addPtr(TrustedImm32(m_jit.graph().stackPointerOffset() * sizeof(Register)), GPRInfo::callFrameRegister, JITCompiler::stackPointerRegister);
 742     };
 743 
 744     CallLinkInfo* callLinkInfo = m_jit.codeBlock()-&gt;addCallLinkInfo();
 745     callLinkInfo-&gt;setUpCall(callType, m_currentNode-&gt;origin.semantic, calleeGPR);
 746 
 747     if (node-&gt;op() == CallEval) {
 748         // We want to call operationCallEval but we don&#39;t want to overwrite the parameter area in
 749         // which we have created a prototypical eval call frame. This means that we have to
 750         // subtract stack to make room for the call. Lucky for us, at this point we have the whole
 751         // register file to ourselves.
 752 
 753         m_jit.emitStoreCallSiteIndex(callSite);
 754         m_jit.addPtr(TrustedImm32(-static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC))), JITCompiler::stackPointerRegister, GPRInfo::regT0);
 755         m_jit.storePtr(GPRInfo::callFrameRegister, JITCompiler::Address(GPRInfo::regT0, CallFrame::callerFrameOffset()));
 756 
 757         // Now we need to make room for:
 758         // - The caller frame and PC of a call to operationCallEval.
 759         // - Potentially two arguments on the stack.
<a name="21" id="anc21"></a><span class="line-modified"> 760         unsigned requiredBytes = sizeof(CallerFrameAndPC) + sizeof(CallFrame*) * 2;</span>
 761         requiredBytes = WTF::roundUpToMultipleOf(stackAlignmentBytes(), requiredBytes);
 762         m_jit.subPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
<a name="22" id="anc22"></a><span class="line-modified"> 763         m_jit.setupArguments&lt;decltype(operationCallEval)&gt;(TrustedImmPtr::weakPointer(m_graph, globalObject), GPRInfo::regT0);</span>
 764         prepareForExternalCall();
 765         m_jit.appendCall(operationCallEval);
 766         m_jit.exceptionCheck();
 767         JITCompiler::Jump done = m_jit.branchIfNotEmpty(GPRInfo::returnValueGPR);
 768 
 769         // This is the part where we meant to make a normal call. Oops.
 770         m_jit.addPtr(TrustedImm32(requiredBytes), JITCompiler::stackPointerRegister);
 771         m_jit.load64(JITCompiler::calleeFrameSlot(CallFrameSlot::callee), GPRInfo::regT0);
<a name="23" id="anc23"></a><span class="line-modified"> 772         m_jit.emitDumbVirtualCall(vm(), globalObject, callLinkInfo);</span>
 773 
 774         done.link(&amp;m_jit);
 775         setResultAndResetStack();
 776         return;
 777     }
 778 
 779     if (isDirect) {
 780         callLinkInfo-&gt;setExecutableDuringCompilation(executable);
<a name="24" id="anc24"></a><span class="line-modified"> 781         callLinkInfo-&gt;setMaxArgumentCountIncludingThis(numAllocatedArgs);</span>
 782 
 783         if (isTail) {
 784             RELEASE_ASSERT(node-&gt;op() == DirectTailCall);
 785 
 786             JITCompiler::PatchableJump patchableJump = m_jit.patchableJump();
 787             JITCompiler::Label mainPath = m_jit.label();
 788 
 789             m_jit.emitStoreCallSiteIndex(callSite);
 790 
 791             callLinkInfo-&gt;setFrameShuffleData(shuffleData);
 792             CallFrameShuffler(m_jit, shuffleData).prepareForTailCall();
 793 
 794             JITCompiler::Call call = m_jit.nearTailCall();
 795 
 796             JITCompiler::Label slowPath = m_jit.label();
 797             patchableJump.m_jump.linkTo(slowPath, &amp;m_jit);
 798 
 799             silentSpillAllRegisters(InvalidGPRReg);
 800             callOperation(operationLinkDirectCall, callLinkInfo, calleeGPR);
 801             silentFillAllRegisters();
 802             m_jit.exceptionCheck();
 803             m_jit.jump().linkTo(mainPath, &amp;m_jit);
 804 
 805             useChildren(node);
 806 
 807             m_jit.addJSDirectTailCall(patchableJump, call, slowPath, callLinkInfo);
 808             return;
 809         }
 810 
 811         JITCompiler::Label mainPath = m_jit.label();
 812 
 813         m_jit.emitStoreCallSiteIndex(callSite);
 814 
 815         JITCompiler::Call call = m_jit.nearCall();
 816         JITCompiler::Jump done = m_jit.jump();
 817 
 818         JITCompiler::Label slowPath = m_jit.label();
 819         if (isX86())
 820             m_jit.pop(JITCompiler::selectScratchGPR(calleeGPR));
 821 
 822         callOperation(operationLinkDirectCall, callLinkInfo, calleeGPR);
 823         m_jit.exceptionCheck();
 824         m_jit.jump().linkTo(mainPath, &amp;m_jit);
 825 
 826         done.link(&amp;m_jit);
 827 
 828         setResultAndResetStack();
 829 
 830         m_jit.addJSDirectCall(call, slowPath, callLinkInfo);
 831         return;
 832     }
 833 
 834     m_jit.emitStoreCallSiteIndex(callSite);
 835 
 836     JITCompiler::DataLabelPtr targetToCheck;
 837     JITCompiler::Jump slowPath = m_jit.branchPtrWithPatch(MacroAssembler::NotEqual, calleeGPR, targetToCheck, TrustedImmPtr(nullptr));
 838 
 839     if (isTail) {
 840         if (node-&gt;op() == TailCall) {
 841             callLinkInfo-&gt;setFrameShuffleData(shuffleData);
 842             CallFrameShuffler(m_jit, shuffleData).prepareForTailCall();
 843         } else {
 844             m_jit.emitRestoreCalleeSaves();
 845             m_jit.prepareForTailCallSlow();
 846         }
 847     }
 848 
 849     JITCompiler::Call fastCall = isTail ? m_jit.nearTailCall() : m_jit.nearCall();
 850 
 851     JITCompiler::Jump done = m_jit.jump();
 852 
 853     slowPath.link(&amp;m_jit);
 854 
 855     if (node-&gt;op() == TailCall) {
 856         CallFrameShuffler callFrameShuffler(m_jit, shuffleData);
 857         callFrameShuffler.setCalleeJSValueRegs(JSValueRegs(GPRInfo::regT0));
 858         callFrameShuffler.prepareForSlowPath();
 859     } else {
 860         m_jit.move(calleeGPR, GPRInfo::regT0); // Callee needs to be in regT0
 861 
 862         if (isTail)
 863             m_jit.emitRestoreCalleeSaves(); // This needs to happen after we moved calleeGPR to regT0
 864     }
 865 
 866     m_jit.move(TrustedImmPtr(callLinkInfo), GPRInfo::regT2); // Link info needs to be in regT2
<a name="25" id="anc25"></a><span class="line-added"> 867     m_jit.move(TrustedImmPtr::weakPointer(m_graph, globalObject), GPRInfo::regT3); // JSGlobalObject needs to be in regT3</span>
 868     JITCompiler::Call slowCall = m_jit.nearCall();
 869 
 870     done.link(&amp;m_jit);
 871 
 872     if (isTail)
 873         m_jit.abortWithReason(JITDidReturnFromTailCall);
 874     else
 875         setResultAndResetStack();
 876 
 877     m_jit.addJSCall(fastCall, slowCall, targetToCheck, callLinkInfo);
 878 }
 879 
 880 // Clang should allow unreachable [[clang::fallthrough]] in template functions if any template expansion uses it
 881 // http://llvm.org/bugs/show_bug.cgi?id=18619
 882 IGNORE_WARNINGS_BEGIN(&quot;implicit-fallthrough&quot;)
 883 template&lt;bool strict&gt;
 884 GPRReg SpeculativeJIT::fillSpeculateInt32Internal(Edge edge, DataFormat&amp; returnFormat)
 885 {
 886     AbstractValue&amp; value = m_state.forNode(edge);
 887     SpeculatedType type = value.m_type;
 888     ASSERT(edge.useKind() != KnownInt32Use || !(value.m_type &amp; ~SpecInt32Only));
 889 
 890     m_interpreter.filter(value, SpecInt32Only);
 891     if (value.isClear()) {
 892         if (mayHaveTypeCheck(edge.useKind()))
 893             terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
 894         returnFormat = DataFormatInt32;
 895         return allocate();
 896     }
 897 
 898     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
 899     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 900 
 901     switch (info.registerFormat()) {
 902     case DataFormatNone: {
 903         GPRReg gpr = allocate();
 904 
 905         if (edge-&gt;hasConstant()) {
 906             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
 907             ASSERT(edge-&gt;isInt32Constant());
 908             m_jit.move(MacroAssembler::Imm32(edge-&gt;asInt32()), gpr);
 909             info.fillInt32(*m_stream, gpr);
 910             returnFormat = DataFormatInt32;
 911             return gpr;
 912         }
 913 
 914         DataFormat spillFormat = info.spillFormat();
 915 
 916         DFG_ASSERT(m_jit.graph(), m_currentNode, (spillFormat &amp; DataFormatJS) || spillFormat == DataFormatInt32, spillFormat);
 917 
 918         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
 919 
 920         if (spillFormat == DataFormatJSInt32 || spillFormat == DataFormatInt32) {
 921             // If we know this was spilled as an integer we can fill without checking.
 922             if (strict) {
 923                 m_jit.load32(JITCompiler::addressFor(virtualRegister), gpr);
 924                 info.fillInt32(*m_stream, gpr);
 925                 returnFormat = DataFormatInt32;
 926                 return gpr;
 927             }
 928             if (spillFormat == DataFormatInt32) {
 929                 m_jit.load32(JITCompiler::addressFor(virtualRegister), gpr);
 930                 info.fillInt32(*m_stream, gpr);
 931                 returnFormat = DataFormatInt32;
 932             } else {
 933                 m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
 934                 info.fillJSValue(*m_stream, gpr, DataFormatJSInt32);
 935                 returnFormat = DataFormatJSInt32;
 936             }
 937             return gpr;
 938         }
 939         m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
 940 
 941         // Fill as JSValue, and fall through.
 942         info.fillJSValue(*m_stream, gpr, DataFormatJSInt32);
 943         m_gprs.unlock(gpr);
 944         FALLTHROUGH;
 945     }
 946 
 947     case DataFormatJS: {
 948         DFG_ASSERT(m_jit.graph(), m_currentNode, !(type &amp; SpecInt52Any));
 949         // Check the value is an integer.
 950         GPRReg gpr = info.gpr();
 951         m_gprs.lock(gpr);
 952         if (type &amp; ~SpecInt32Only)
 953             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchIfNotInt32(gpr));
 954         info.fillJSValue(*m_stream, gpr, DataFormatJSInt32);
 955         // If !strict we&#39;re done, return.
 956         if (!strict) {
 957             returnFormat = DataFormatJSInt32;
 958             return gpr;
 959         }
 960         // else fall through &amp; handle as DataFormatJSInt32.
 961         m_gprs.unlock(gpr);
 962         FALLTHROUGH;
 963     }
 964 
 965     case DataFormatJSInt32: {
 966         // In a strict fill we need to strip off the value tag.
 967         if (strict) {
 968             GPRReg gpr = info.gpr();
 969             GPRReg result;
 970             // If the register has already been locked we need to take a copy.
 971             // If not, we&#39;ll zero extend in place, so mark on the info that this is now type DataFormatInt32, not DataFormatJSInt32.
 972             if (m_gprs.isLocked(gpr))
 973                 result = allocate();
 974             else {
 975                 m_gprs.lock(gpr);
 976                 info.fillInt32(*m_stream, gpr);
 977                 result = gpr;
 978             }
 979             m_jit.zeroExtend32ToPtr(gpr, result);
 980             returnFormat = DataFormatInt32;
 981             return result;
 982         }
 983 
 984         GPRReg gpr = info.gpr();
 985         m_gprs.lock(gpr);
 986         returnFormat = DataFormatJSInt32;
 987         return gpr;
 988     }
 989 
 990     case DataFormatInt32: {
 991         GPRReg gpr = info.gpr();
 992         m_gprs.lock(gpr);
 993         returnFormat = DataFormatInt32;
 994         return gpr;
 995     }
 996 
 997     case DataFormatJSDouble:
 998     case DataFormatCell:
 999     case DataFormatBoolean:
1000     case DataFormatJSCell:
1001     case DataFormatJSBoolean:
1002     case DataFormatDouble:
1003     case DataFormatStorage:
1004     case DataFormatInt52:
1005     case DataFormatStrictInt52:
1006         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
1007 
1008     default:
1009         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Corrupt data format&quot;);
1010         return InvalidGPRReg;
1011     }
1012 }
1013 IGNORE_WARNINGS_END
1014 
1015 GPRReg SpeculativeJIT::fillSpeculateInt32(Edge edge, DataFormat&amp; returnFormat)
1016 {
1017     return fillSpeculateInt32Internal&lt;false&gt;(edge, returnFormat);
1018 }
1019 
1020 GPRReg SpeculativeJIT::fillSpeculateInt32Strict(Edge edge)
1021 {
1022     DataFormat mustBeDataFormatInt32;
1023     GPRReg result = fillSpeculateInt32Internal&lt;true&gt;(edge, mustBeDataFormatInt32);
1024     DFG_ASSERT(m_jit.graph(), m_currentNode, mustBeDataFormatInt32 == DataFormatInt32, mustBeDataFormatInt32);
1025     return result;
1026 }
1027 
1028 GPRReg SpeculativeJIT::fillSpeculateInt52(Edge edge, DataFormat desiredFormat)
1029 {
1030     ASSERT(desiredFormat == DataFormatInt52 || desiredFormat == DataFormatStrictInt52);
1031     AbstractValue&amp; value = m_state.forNode(edge);
1032 
1033     m_interpreter.filter(value, SpecInt52Any);
1034     if (value.isClear()) {
1035         if (mayHaveTypeCheck(edge.useKind()))
1036             terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
1037         return allocate();
1038     }
1039 
1040     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1041     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1042 
1043     switch (info.registerFormat()) {
1044     case DataFormatNone: {
1045         GPRReg gpr = allocate();
1046 
1047         if (edge-&gt;hasConstant()) {
1048             JSValue jsValue = edge-&gt;asJSValue();
1049             ASSERT(jsValue.isAnyInt());
1050             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1051             int64_t value = jsValue.asAnyInt();
1052             if (desiredFormat == DataFormatInt52)
1053                 value = value &lt;&lt; JSValue::int52ShiftAmount;
1054             m_jit.move(MacroAssembler::Imm64(value), gpr);
1055             info.fillGPR(*m_stream, gpr, desiredFormat);
1056             return gpr;
1057         }
1058 
1059         DataFormat spillFormat = info.spillFormat();
1060 
1061         DFG_ASSERT(m_jit.graph(), m_currentNode, spillFormat == DataFormatInt52 || spillFormat == DataFormatStrictInt52, spillFormat);
1062 
1063         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1064 
1065         m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
1066         if (desiredFormat == DataFormatStrictInt52) {
1067             if (spillFormat == DataFormatInt52)
1068                 m_jit.rshift64(TrustedImm32(JSValue::int52ShiftAmount), gpr);
1069             info.fillStrictInt52(*m_stream, gpr);
1070             return gpr;
1071         }
1072         if (spillFormat == DataFormatStrictInt52)
1073             m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), gpr);
1074         info.fillInt52(*m_stream, gpr);
1075         return gpr;
1076     }
1077 
1078     case DataFormatStrictInt52: {
1079         GPRReg gpr = info.gpr();
1080         bool wasLocked = m_gprs.isLocked(gpr);
1081         lock(gpr);
1082         if (desiredFormat == DataFormatStrictInt52)
1083             return gpr;
1084         if (wasLocked) {
1085             GPRReg result = allocate();
1086             m_jit.move(gpr, result);
1087             unlock(gpr);
1088             gpr = result;
1089         } else
1090             info.fillInt52(*m_stream, gpr);
1091         m_jit.lshift64(TrustedImm32(JSValue::int52ShiftAmount), gpr);
1092         return gpr;
1093     }
1094 
1095     case DataFormatInt52: {
1096         GPRReg gpr = info.gpr();
1097         bool wasLocked = m_gprs.isLocked(gpr);
1098         lock(gpr);
1099         if (desiredFormat == DataFormatInt52)
1100             return gpr;
1101         if (wasLocked) {
1102             GPRReg result = allocate();
1103             m_jit.move(gpr, result);
1104             unlock(gpr);
1105             gpr = result;
1106         } else
1107             info.fillStrictInt52(*m_stream, gpr);
1108         m_jit.rshift64(TrustedImm32(JSValue::int52ShiftAmount), gpr);
1109         return gpr;
1110     }
1111 
1112     default:
1113         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
1114         return InvalidGPRReg;
1115     }
1116 }
1117 
1118 FPRReg SpeculativeJIT::fillSpeculateDouble(Edge edge)
1119 {
1120     ASSERT(edge.useKind() == DoubleRepUse || edge.useKind() == DoubleRepRealUse || edge.useKind() == DoubleRepAnyIntUse);
1121     ASSERT(edge-&gt;hasDoubleResult());
1122     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1123     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1124 
1125     if (info.registerFormat() == DataFormatNone) {
1126         if (edge-&gt;hasConstant()) {
1127             if (edge-&gt;isNumberConstant()) {
1128                 FPRReg fpr = fprAllocate();
1129                 int64_t doubleAsInt = reinterpretDoubleToInt64(edge-&gt;asNumber());
1130                 if (!doubleAsInt)
1131                     m_jit.moveZeroToDouble(fpr);
1132                 else {
1133                     GPRReg gpr = allocate();
1134                     m_jit.move(MacroAssembler::Imm64(doubleAsInt), gpr);
1135                     m_jit.move64ToDouble(gpr, fpr);
1136                     unlock(gpr);
1137                 }
1138 
1139                 m_fprs.retain(fpr, virtualRegister, SpillOrderDouble);
1140                 info.fillDouble(*m_stream, fpr);
1141                 return fpr;
1142             }
1143             if (mayHaveTypeCheck(edge.useKind()))
1144                 terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
1145             return fprAllocate();
1146         }
1147 
1148         DataFormat spillFormat = info.spillFormat();
1149         if (spillFormat != DataFormatDouble) {
1150             DFG_CRASH(
1151                 m_jit.graph(), m_currentNode, toCString(
1152                     &quot;Expected &quot;, edge, &quot; to have double format but instead it is spilled as &quot;,
1153                     dataFormatToString(spillFormat)).data());
1154         }
1155         DFG_ASSERT(m_jit.graph(), m_currentNode, spillFormat == DataFormatDouble, spillFormat);
1156         FPRReg fpr = fprAllocate();
1157         m_jit.loadDouble(JITCompiler::addressFor(virtualRegister), fpr);
1158         m_fprs.retain(fpr, virtualRegister, SpillOrderDouble);
1159         info.fillDouble(*m_stream, fpr);
1160         return fpr;
1161     }
1162 
1163     DFG_ASSERT(m_jit.graph(), m_currentNode, info.registerFormat() == DataFormatDouble, info.registerFormat());
1164     FPRReg fpr = info.fpr();
1165     m_fprs.lock(fpr);
1166     return fpr;
1167 }
1168 
1169 GPRReg SpeculativeJIT::fillSpeculateCell(Edge edge)
1170 {
1171     AbstractValue&amp; value = m_state.forNode(edge);
1172     SpeculatedType type = value.m_type;
1173     ASSERT((edge.useKind() != KnownCellUse &amp;&amp; edge.useKind() != KnownStringUse) || !(value.m_type &amp; ~SpecCellCheck));
1174 
1175     m_interpreter.filter(value, SpecCellCheck);
1176     if (value.isClear()) {
1177         if (mayHaveTypeCheck(edge.useKind()))
1178             terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
1179         return allocate();
1180     }
1181 
1182     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1183     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1184 
1185     switch (info.registerFormat()) {
1186     case DataFormatNone: {
1187         GPRReg gpr = allocate();
1188 
1189         if (edge-&gt;hasConstant()) {
1190             JSValue jsValue = edge-&gt;asJSValue();
1191             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1192             m_jit.move(MacroAssembler::TrustedImm64(JSValue::encode(jsValue)), gpr);
1193             info.fillJSValue(*m_stream, gpr, DataFormatJSCell);
1194             return gpr;
1195         }
1196 
1197         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1198         m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
1199 
1200         info.fillJSValue(*m_stream, gpr, DataFormatJS);
1201         if (type &amp; ~SpecCellCheck)
1202             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchIfNotCell(JSValueRegs(gpr)));
1203         info.fillJSValue(*m_stream, gpr, DataFormatJSCell);
1204         return gpr;
1205     }
1206 
1207     case DataFormatCell:
1208     case DataFormatJSCell: {
1209         GPRReg gpr = info.gpr();
1210         m_gprs.lock(gpr);
<a name="26" id="anc26"></a><span class="line-modified">1211         if (ASSERT_ENABLED) {</span>
1212             MacroAssembler::Jump checkCell = m_jit.branchIfCell(JSValueRegs(gpr));
1213             m_jit.abortWithReason(DFGIsNotCell);
1214             checkCell.link(&amp;m_jit);
1215         }
1216         return gpr;
1217     }
1218 
1219     case DataFormatJS: {
1220         GPRReg gpr = info.gpr();
1221         m_gprs.lock(gpr);
1222         if (type &amp; ~SpecCellCheck)
1223             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchIfNotCell(JSValueRegs(gpr)));
1224         info.fillJSValue(*m_stream, gpr, DataFormatJSCell);
1225         return gpr;
1226     }
1227 
1228     case DataFormatJSInt32:
1229     case DataFormatInt32:
1230     case DataFormatJSDouble:
1231     case DataFormatJSBoolean:
1232     case DataFormatBoolean:
1233     case DataFormatDouble:
1234     case DataFormatStorage:
1235     case DataFormatInt52:
1236     case DataFormatStrictInt52:
1237         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
1238 
1239     default:
1240         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Corrupt data format&quot;);
1241         return InvalidGPRReg;
1242     }
1243 }
1244 
1245 GPRReg SpeculativeJIT::fillSpeculateBoolean(Edge edge)
1246 {
1247     AbstractValue&amp; value = m_state.forNode(edge);
1248     SpeculatedType type = value.m_type;
1249     ASSERT(edge.useKind() != KnownBooleanUse || !(value.m_type &amp; ~SpecBoolean));
1250 
1251     m_interpreter.filter(value, SpecBoolean);
1252     if (value.isClear()) {
1253         if (mayHaveTypeCheck(edge.useKind()))
1254             terminateSpeculativeExecution(Uncountable, JSValueRegs(), 0);
1255         return allocate();
1256     }
1257 
1258     VirtualRegister virtualRegister = edge-&gt;virtualRegister();
1259     GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
1260 
1261     switch (info.registerFormat()) {
1262     case DataFormatNone: {
1263         GPRReg gpr = allocate();
1264 
1265         if (edge-&gt;hasConstant()) {
1266             JSValue jsValue = edge-&gt;asJSValue();
1267             m_gprs.retain(gpr, virtualRegister, SpillOrderConstant);
1268             m_jit.move(MacroAssembler::TrustedImm64(JSValue::encode(jsValue)), gpr);
1269             info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
1270             return gpr;
1271         }
1272         DFG_ASSERT(m_jit.graph(), m_currentNode, info.spillFormat() &amp; DataFormatJS, info.spillFormat());
1273         m_gprs.retain(gpr, virtualRegister, SpillOrderSpilled);
1274         m_jit.load64(JITCompiler::addressFor(virtualRegister), gpr);
1275 
1276         info.fillJSValue(*m_stream, gpr, DataFormatJS);
1277         if (type &amp; ~SpecBoolean) {
<a name="27" id="anc27"></a><span class="line-modified">1278             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), gpr);</span>
1279             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchTest64(MacroAssembler::NonZero, gpr, TrustedImm32(static_cast&lt;int32_t&gt;(~1))), SpeculationRecovery(BooleanSpeculationCheck, gpr, InvalidGPRReg));
<a name="28" id="anc28"></a><span class="line-modified">1280             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), gpr);</span>
1281         }
1282         info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
1283         return gpr;
1284     }
1285 
1286     case DataFormatBoolean:
1287     case DataFormatJSBoolean: {
1288         GPRReg gpr = info.gpr();
1289         m_gprs.lock(gpr);
1290         return gpr;
1291     }
1292 
1293     case DataFormatJS: {
1294         GPRReg gpr = info.gpr();
1295         m_gprs.lock(gpr);
1296         if (type &amp; ~SpecBoolean) {
<a name="29" id="anc29"></a><span class="line-modified">1297             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), gpr);</span>
1298             speculationCheck(BadType, JSValueRegs(gpr), edge, m_jit.branchTest64(MacroAssembler::NonZero, gpr, TrustedImm32(static_cast&lt;int32_t&gt;(~1))), SpeculationRecovery(BooleanSpeculationCheck, gpr, InvalidGPRReg));
<a name="30" id="anc30"></a><span class="line-modified">1299             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), gpr);</span>
1300         }
1301         info.fillJSValue(*m_stream, gpr, DataFormatJSBoolean);
1302         return gpr;
1303     }
1304 
1305     case DataFormatJSInt32:
1306     case DataFormatInt32:
1307     case DataFormatJSDouble:
1308     case DataFormatJSCell:
1309     case DataFormatCell:
1310     case DataFormatDouble:
1311     case DataFormatStorage:
1312     case DataFormatInt52:
1313     case DataFormatStrictInt52:
1314         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad data format&quot;);
1315 
1316     default:
1317         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Corrupt data format&quot;);
1318         return InvalidGPRReg;
1319     }
1320 }
1321 
1322 void SpeculativeJIT::compileObjectStrictEquality(Edge objectChild, Edge otherChild)
1323 {
1324     SpeculateCellOperand op1(this, objectChild);
1325     JSValueOperand op2(this, otherChild);
1326     GPRTemporary result(this);
1327 
1328     GPRReg op1GPR = op1.gpr();
1329     GPRReg op2GPR = op2.gpr();
1330     GPRReg resultGPR = result.gpr();
1331 
1332     DFG_TYPE_CHECK(JSValueSource::unboxedCell(op1GPR), objectChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1333 
1334     // At this point we know that we can perform a straight-forward equality comparison on pointer
1335     // values because we are doing strict equality.
1336     m_jit.compare64(MacroAssembler::Equal, op1GPR, op2GPR, resultGPR);
<a name="31" id="anc31"></a><span class="line-modified">1337     m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
1338     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
1339 }
1340 
1341 void SpeculativeJIT::compilePeepHoleObjectStrictEquality(Edge objectChild, Edge otherChild, Node* branchNode)
1342 {
1343     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1344     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1345 
1346     SpeculateCellOperand op1(this, objectChild);
1347     JSValueOperand op2(this, otherChild);
1348 
1349     GPRReg op1GPR = op1.gpr();
1350     GPRReg op2GPR = op2.gpr();
1351 
1352     DFG_TYPE_CHECK(JSValueSource::unboxedCell(op1GPR), objectChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1353 
1354     if (taken == nextBlock()) {
1355         branchPtr(MacroAssembler::NotEqual, op1GPR, op2GPR, notTaken);
1356         jump(taken);
1357     } else {
1358         branchPtr(MacroAssembler::Equal, op1GPR, op2GPR, taken);
1359         jump(notTaken);
1360     }
1361 }
1362 
1363 void SpeculativeJIT::compileObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild)
1364 {
1365     SpeculateCellOperand op1(this, leftChild);
1366     JSValueOperand op2(this, rightChild, ManualOperandSpeculation);
1367     GPRTemporary result(this);
1368 
1369     GPRReg op1GPR = op1.gpr();
1370     GPRReg op2GPR = op2.gpr();
1371     GPRReg resultGPR = result.gpr();
1372 
1373     bool masqueradesAsUndefinedWatchpointValid =
1374         masqueradesAsUndefinedWatchpointIsStillValid();
1375 
1376     if (masqueradesAsUndefinedWatchpointValid) {
1377         DFG_TYPE_CHECK(
1378             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1379     } else {
1380         DFG_TYPE_CHECK(
1381             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1382         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), leftChild,
1383             m_jit.branchTest8(
1384                 MacroAssembler::NonZero,
1385                 MacroAssembler::Address(op1GPR, JSCell::typeInfoFlagsOffset()),
1386                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1387     }
1388 
1389     // It seems that most of the time when programs do a == b where b may be either null/undefined
1390     // or an object, b is usually an object. Balance the branches to make that case fast.
1391     MacroAssembler::Jump rightNotCell = m_jit.branchIfNotCell(JSValueRegs(op2GPR));
1392 
1393     // We know that within this branch, rightChild must be a cell.
1394     if (masqueradesAsUndefinedWatchpointValid) {
1395         DFG_TYPE_CHECK(
1396             JSValueRegs(op2GPR), rightChild, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(op2GPR));
1397     } else {
1398         DFG_TYPE_CHECK(
1399             JSValueRegs(op2GPR), rightChild, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(op2GPR));
1400         speculationCheck(BadType, JSValueRegs(op2GPR), rightChild,
1401             m_jit.branchTest8(
1402                 MacroAssembler::NonZero,
1403                 MacroAssembler::Address(op2GPR, JSCell::typeInfoFlagsOffset()),
1404                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1405     }
1406 
1407     // At this point we know that we can perform a straight-forward equality comparison on pointer
1408     // values because both left and right are pointers to objects that have no special equality
1409     // protocols.
1410     m_jit.compare64(MacroAssembler::Equal, op1GPR, op2GPR, resultGPR);
1411     MacroAssembler::Jump done = m_jit.jump();
1412 
1413     rightNotCell.link(&amp;m_jit);
1414 
1415     // We know that within this branch, rightChild must not be a cell. Check if that is enough to
1416     // prove that it is either null or undefined.
1417     if (needsTypeCheck(rightChild, SpecCellCheck | SpecOther)) {
1418         m_jit.move(op2GPR, resultGPR);
<a name="32" id="anc32"></a><span class="line-modified">1419         m_jit.and64(MacroAssembler::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
1420 
1421         typeCheck(
1422             JSValueRegs(op2GPR), rightChild, SpecCellCheck | SpecOther,
1423             m_jit.branch64(
1424                 MacroAssembler::NotEqual, resultGPR,
<a name="33" id="anc33"></a><span class="line-modified">1425                 MacroAssembler::TrustedImm64(JSValue::ValueNull)));</span>
1426     }
1427     m_jit.move(TrustedImm32(0), result.gpr());
1428 
1429     done.link(&amp;m_jit);
<a name="34" id="anc34"></a><span class="line-modified">1430     m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
1431     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
1432 }
1433 
1434 void SpeculativeJIT::compilePeepHoleObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild, Node* branchNode)
1435 {
1436     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1437     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1438 
1439     SpeculateCellOperand op1(this, leftChild);
1440     JSValueOperand op2(this, rightChild, ManualOperandSpeculation);
1441     GPRTemporary result(this);
1442 
1443     GPRReg op1GPR = op1.gpr();
1444     GPRReg op2GPR = op2.gpr();
1445     GPRReg resultGPR = result.gpr();
1446 
1447     bool masqueradesAsUndefinedWatchpointValid =
1448         masqueradesAsUndefinedWatchpointIsStillValid();
1449 
1450     if (masqueradesAsUndefinedWatchpointValid) {
1451         DFG_TYPE_CHECK(
1452             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1453     } else {
1454         DFG_TYPE_CHECK(
1455             JSValueSource::unboxedCell(op1GPR), leftChild, SpecObject, m_jit.branchIfNotObject(op1GPR));
1456         speculationCheck(BadType, JSValueSource::unboxedCell(op1GPR), leftChild,
1457             m_jit.branchTest8(
1458                 MacroAssembler::NonZero,
1459                 MacroAssembler::Address(op1GPR, JSCell::typeInfoFlagsOffset()),
1460                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1461     }
1462 
1463     // It seems that most of the time when programs do a == b where b may be either null/undefined
1464     // or an object, b is usually an object. Balance the branches to make that case fast.
1465     MacroAssembler::Jump rightNotCell = m_jit.branchIfNotCell(JSValueRegs(op2GPR));
1466 
1467     // We know that within this branch, rightChild must be a cell.
1468     if (masqueradesAsUndefinedWatchpointValid) {
1469         DFG_TYPE_CHECK(
1470             JSValueRegs(op2GPR), rightChild, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(op2GPR));
1471     } else {
1472         DFG_TYPE_CHECK(
1473             JSValueRegs(op2GPR), rightChild, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(op2GPR));
1474         speculationCheck(BadType, JSValueRegs(op2GPR), rightChild,
1475             m_jit.branchTest8(
1476                 MacroAssembler::NonZero,
1477                 MacroAssembler::Address(op2GPR, JSCell::typeInfoFlagsOffset()),
1478                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined)));
1479     }
1480 
1481     // At this point we know that we can perform a straight-forward equality comparison on pointer
1482     // values because both left and right are pointers to objects that have no special equality
1483     // protocols.
1484     branch64(MacroAssembler::Equal, op1GPR, op2GPR, taken);
1485 
1486     // We know that within this branch, rightChild must not be a cell. Check if that is enough to
1487     // prove that it is either null or undefined.
1488     if (!needsTypeCheck(rightChild, SpecCellCheck | SpecOther))
1489         rightNotCell.link(&amp;m_jit);
1490     else {
1491         jump(notTaken, ForceJump);
1492 
1493         rightNotCell.link(&amp;m_jit);
1494         m_jit.move(op2GPR, resultGPR);
<a name="35" id="anc35"></a><span class="line-modified">1495         m_jit.and64(MacroAssembler::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
1496 
1497         typeCheck(
1498             JSValueRegs(op2GPR), rightChild, SpecCellCheck | SpecOther, m_jit.branch64(
1499                 MacroAssembler::NotEqual, resultGPR,
<a name="36" id="anc36"></a><span class="line-modified">1500                 MacroAssembler::TrustedImm64(JSValue::ValueNull)));</span>
1501     }
1502 
1503     jump(notTaken);
1504 }
1505 
1506 void SpeculativeJIT::compileSymbolUntypedEquality(Node* node, Edge symbolEdge, Edge untypedEdge)
1507 {
1508     SpeculateCellOperand symbol(this, symbolEdge);
1509     JSValueOperand untyped(this, untypedEdge);
1510     GPRTemporary result(this, Reuse, symbol, untyped);
1511 
1512     GPRReg symbolGPR = symbol.gpr();
1513     GPRReg untypedGPR = untyped.gpr();
1514     GPRReg resultGPR = result.gpr();
1515 
1516     speculateSymbol(symbolEdge, symbolGPR);
1517 
1518     // At this point we know that we can perform a straight-forward equality comparison on pointer
1519     // values because we are doing strict equality.
1520     m_jit.compare64(MacroAssembler::Equal, symbolGPR, untypedGPR, resultGPR);
1521     unblessedBooleanResult(resultGPR, node);
1522 }
1523 
1524 void SpeculativeJIT::compileInt52Compare(Node* node, MacroAssembler::RelationalCondition condition)
1525 {
1526     SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
1527     SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
1528     GPRTemporary result(this, Reuse, op1, op2);
1529 
1530     m_jit.compare64(condition, op1.gpr(), op2.gpr(), result.gpr());
1531 
1532     // If we add a DataFormatBool, we should use it here.
<a name="37" id="anc37"></a><span class="line-modified">1533     m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
1534     jsValueResult(result.gpr(), m_currentNode, DataFormatJSBoolean);
1535 }
1536 
1537 void SpeculativeJIT::compilePeepHoleInt52Branch(Node* node, Node* branchNode, JITCompiler::RelationalCondition condition)
1538 {
1539     BasicBlock* taken = branchNode-&gt;branchData()-&gt;taken.block;
1540     BasicBlock* notTaken = branchNode-&gt;branchData()-&gt;notTaken.block;
1541 
1542     // The branch instruction will branch to the taken block.
1543     // If taken is next, switch taken with notTaken &amp; invert the branch condition so we can fall through.
1544     if (taken == nextBlock()) {
1545         condition = JITCompiler::invert(condition);
1546         BasicBlock* tmp = taken;
1547         taken = notTaken;
1548         notTaken = tmp;
1549     }
1550 
1551     SpeculateWhicheverInt52Operand op1(this, node-&gt;child1());
1552     SpeculateWhicheverInt52Operand op2(this, node-&gt;child2(), op1);
1553 
1554     branch64(condition, op1.gpr(), op2.gpr(), taken);
1555     jump(notTaken);
1556 }
1557 
1558 void SpeculativeJIT::compileCompareEqPtr(Node* node)
1559 {
1560     JSValueOperand value(this, node-&gt;child1());
1561     GPRTemporary result(this);
1562     GPRReg valueGPR = value.gpr();
1563     GPRReg resultGPR = result.gpr();
1564 
1565     m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), node-&gt;cellOperand()-&gt;cell()), resultGPR);
1566     m_jit.compare64(MacroAssembler::Equal, valueGPR, resultGPR, resultGPR);
1567     unblessedBooleanResult(resultGPR, node);
1568 }
1569 
1570 void SpeculativeJIT::compileObjectOrOtherLogicalNot(Edge nodeUse)
1571 {
1572     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
1573     GPRTemporary result(this);
1574     GPRReg valueGPR = value.gpr();
1575     GPRReg resultGPR = result.gpr();
1576     GPRTemporary structure;
1577     GPRReg structureGPR = InvalidGPRReg;
1578     GPRTemporary scratch;
1579     GPRReg scratchGPR = InvalidGPRReg;
1580 
1581     bool masqueradesAsUndefinedWatchpointValid =
1582         masqueradesAsUndefinedWatchpointIsStillValid();
1583 
1584     if (!masqueradesAsUndefinedWatchpointValid) {
1585         // The masquerades as undefined case will use the structure register, so allocate it here.
1586         // Do this at the top of the function to avoid branching around a register allocation.
1587         GPRTemporary realStructure(this);
1588         GPRTemporary realScratch(this);
1589         structure.adopt(realStructure);
1590         scratch.adopt(realScratch);
1591         structureGPR = structure.gpr();
1592         scratchGPR = scratch.gpr();
1593     }
1594 
1595     MacroAssembler::Jump notCell = m_jit.branchIfNotCell(JSValueRegs(valueGPR));
1596     if (masqueradesAsUndefinedWatchpointValid) {
1597         DFG_TYPE_CHECK(
1598             JSValueRegs(valueGPR), nodeUse, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(valueGPR));
1599     } else {
1600         DFG_TYPE_CHECK(
1601             JSValueRegs(valueGPR), nodeUse, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(valueGPR));
1602 
1603         MacroAssembler::Jump isNotMasqueradesAsUndefined =
1604             m_jit.branchTest8(
1605                 MacroAssembler::Zero,
1606                 MacroAssembler::Address(valueGPR, JSCell::typeInfoFlagsOffset()),
1607                 MacroAssembler::TrustedImm32(MasqueradesAsUndefined));
1608 
1609         m_jit.emitLoadStructure(vm(), valueGPR, structureGPR, scratchGPR);
1610         speculationCheck(BadType, JSValueRegs(valueGPR), nodeUse,
1611             m_jit.branchPtr(
1612                 MacroAssembler::Equal,
1613                 MacroAssembler::Address(structureGPR, Structure::globalObjectOffset()),
1614                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic))));
1615 
1616         isNotMasqueradesAsUndefined.link(&amp;m_jit);
1617     }
<a name="38" id="anc38"></a><span class="line-modified">1618     m_jit.move(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
1619     MacroAssembler::Jump done = m_jit.jump();
1620 
1621     notCell.link(&amp;m_jit);
1622 
1623     if (needsTypeCheck(nodeUse, SpecCellCheck | SpecOther)) {
1624         m_jit.move(valueGPR, resultGPR);
<a name="39" id="anc39"></a><span class="line-modified">1625         m_jit.and64(MacroAssembler::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
1626         typeCheck(
1627             JSValueRegs(valueGPR), nodeUse, SpecCellCheck | SpecOther, m_jit.branch64(
1628                 MacroAssembler::NotEqual,
1629                 resultGPR,
<a name="40" id="anc40"></a><span class="line-modified">1630                 MacroAssembler::TrustedImm64(JSValue::ValueNull)));</span>
1631     }
<a name="41" id="anc41"></a><span class="line-modified">1632     m_jit.move(TrustedImm32(JSValue::ValueTrue), resultGPR);</span>
1633 
1634     done.link(&amp;m_jit);
1635 
1636     jsValueResult(resultGPR, m_currentNode, DataFormatJSBoolean);
1637 }
1638 
1639 void SpeculativeJIT::compileLogicalNot(Node* node)
1640 {
1641     switch (node-&gt;child1().useKind()) {
1642     case ObjectOrOtherUse: {
1643         compileObjectOrOtherLogicalNot(node-&gt;child1());
1644         return;
1645     }
1646 
1647     case Int32Use: {
1648         SpeculateInt32Operand value(this, node-&gt;child1());
1649         GPRTemporary result(this, Reuse, value);
1650         m_jit.compare32(MacroAssembler::Equal, value.gpr(), MacroAssembler::TrustedImm32(0), result.gpr());
<a name="42" id="anc42"></a><span class="line-modified">1651         m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
1652         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1653         return;
1654     }
1655 
1656     case DoubleRepUse: {
1657         SpeculateDoubleOperand value(this, node-&gt;child1());
1658         FPRTemporary scratch(this);
1659         GPRTemporary result(this);
<a name="43" id="anc43"></a><span class="line-modified">1660         m_jit.move(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
1661         MacroAssembler::Jump nonZero = m_jit.branchDoubleNonZero(value.fpr(), scratch.fpr());
1662         m_jit.xor32(TrustedImm32(true), result.gpr());
1663         nonZero.link(&amp;m_jit);
1664         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1665         return;
1666     }
1667 
1668     case BooleanUse:
1669     case KnownBooleanUse: {
1670         if (!needsTypeCheck(node-&gt;child1(), SpecBoolean)) {
1671             SpeculateBooleanOperand value(this, node-&gt;child1());
1672             GPRTemporary result(this, Reuse, value);
1673 
1674             m_jit.move(value.gpr(), result.gpr());
1675             m_jit.xor64(TrustedImm32(true), result.gpr());
1676 
1677             jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1678             return;
1679         }
1680 
1681         JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
1682         GPRTemporary result(this); // FIXME: We could reuse, but on speculation fail would need recovery to restore tag (akin to add).
1683 
1684         m_jit.move(value.gpr(), result.gpr());
<a name="44" id="anc44"></a><span class="line-modified">1685         m_jit.xor64(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
1686         typeCheck(
1687             JSValueRegs(value.gpr()), node-&gt;child1(), SpecBoolean, m_jit.branchTest64(
1688                 JITCompiler::NonZero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
<a name="45" id="anc45"></a><span class="line-modified">1689         m_jit.xor64(TrustedImm32(JSValue::ValueTrue), result.gpr());</span>
1690 
1691         // If we add a DataFormatBool, we should use it here.
1692         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
1693         return;
1694     }
1695 
1696     case UntypedUse: {
1697         JSValueOperand arg1(this, node-&gt;child1());
1698         GPRTemporary result(this);
1699 
1700         GPRReg arg1GPR = arg1.gpr();
1701         GPRReg resultGPR = result.gpr();
1702 
1703         FPRTemporary valueFPR(this);
1704         FPRTemporary tempFPR(this);
1705 
1706         bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1707         JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
1708         Optional&lt;GPRTemporary&gt; scratch;
1709         GPRReg scratchGPR = InvalidGPRReg;
1710         if (shouldCheckMasqueradesAsUndefined) {
1711             scratch.emplace(this);
1712             scratchGPR = scratch-&gt;gpr();
1713         }
1714         bool negateResult = true;
1715         m_jit.emitConvertValueToBoolean(vm(), JSValueRegs(arg1GPR), resultGPR, scratchGPR, valueFPR.fpr(), tempFPR.fpr(), shouldCheckMasqueradesAsUndefined, globalObject, negateResult);
<a name="46" id="anc46"></a><span class="line-modified">1716         m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
1717         jsValueResult(resultGPR, node, DataFormatJSBoolean);
1718         return;
1719     }
1720     case StringUse:
1721         return compileStringZeroLength(node);
1722 
1723     case StringOrOtherUse:
1724         return compileLogicalNotStringOrOther(node);
1725 
1726     default:
1727         DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
1728         break;
1729     }
1730 }
1731 
1732 void SpeculativeJIT::emitObjectOrOtherBranch(Edge nodeUse, BasicBlock* taken, BasicBlock* notTaken)
1733 {
1734     JSValueOperand value(this, nodeUse, ManualOperandSpeculation);
1735     GPRTemporary scratch(this);
1736     GPRTemporary structure;
1737     GPRReg valueGPR = value.gpr();
1738     GPRReg scratchGPR = scratch.gpr();
1739     GPRReg structureGPR = InvalidGPRReg;
1740 
1741     if (!masqueradesAsUndefinedWatchpointIsStillValid()) {
1742         GPRTemporary realStructure(this);
1743         structure.adopt(realStructure);
1744         structureGPR = structure.gpr();
1745     }
1746 
1747     MacroAssembler::Jump notCell = m_jit.branchIfNotCell(JSValueRegs(valueGPR));
1748     if (masqueradesAsUndefinedWatchpointIsStillValid()) {
1749         DFG_TYPE_CHECK(
1750             JSValueRegs(valueGPR), nodeUse, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(valueGPR));
1751     } else {
1752         DFG_TYPE_CHECK(
1753             JSValueRegs(valueGPR), nodeUse, (~SpecCellCheck) | SpecObject, m_jit.branchIfNotObject(valueGPR));
1754 
1755         JITCompiler::Jump isNotMasqueradesAsUndefined = m_jit.branchTest8(
1756             JITCompiler::Zero,
1757             MacroAssembler::Address(valueGPR, JSCell::typeInfoFlagsOffset()),
1758             TrustedImm32(MasqueradesAsUndefined));
1759 
1760         m_jit.emitLoadStructure(vm(), valueGPR, structureGPR, scratchGPR);
1761         speculationCheck(BadType, JSValueRegs(valueGPR), nodeUse,
1762             m_jit.branchPtr(
1763                 MacroAssembler::Equal,
1764                 MacroAssembler::Address(structureGPR, Structure::globalObjectOffset()),
1765                 TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.graph().globalObjectFor(m_currentNode-&gt;origin.semantic))));
1766 
1767         isNotMasqueradesAsUndefined.link(&amp;m_jit);
1768     }
1769     jump(taken, ForceJump);
1770 
1771     notCell.link(&amp;m_jit);
1772 
1773     if (needsTypeCheck(nodeUse, SpecCellCheck | SpecOther)) {
1774         m_jit.move(valueGPR, scratchGPR);
<a name="47" id="anc47"></a><span class="line-modified">1775         m_jit.and64(MacroAssembler::TrustedImm32(~JSValue::UndefinedTag), scratchGPR);</span>
1776         typeCheck(
1777             JSValueRegs(valueGPR), nodeUse, SpecCellCheck | SpecOther, m_jit.branch64(
<a name="48" id="anc48"></a><span class="line-modified">1778                 MacroAssembler::NotEqual, scratchGPR, MacroAssembler::TrustedImm64(JSValue::ValueNull)));</span>
1779     }
1780     jump(notTaken);
1781 
1782     noResult(m_currentNode);
1783 }
1784 
1785 void SpeculativeJIT::emitBranch(Node* node)
1786 {
1787     BasicBlock* taken = node-&gt;branchData()-&gt;taken.block;
1788     BasicBlock* notTaken = node-&gt;branchData()-&gt;notTaken.block;
1789 
1790     switch (node-&gt;child1().useKind()) {
1791     case ObjectOrOtherUse: {
1792         emitObjectOrOtherBranch(node-&gt;child1(), taken, notTaken);
1793         return;
1794     }
1795 
1796     case Int32Use:
1797     case DoubleRepUse: {
1798         if (node-&gt;child1().useKind() == Int32Use) {
1799             bool invert = false;
1800 
1801             if (taken == nextBlock()) {
1802                 invert = true;
1803                 BasicBlock* tmp = taken;
1804                 taken = notTaken;
1805                 notTaken = tmp;
1806             }
1807 
1808             SpeculateInt32Operand value(this, node-&gt;child1());
1809             branchTest32(invert ? MacroAssembler::Zero : MacroAssembler::NonZero, value.gpr(), taken);
1810         } else {
1811             SpeculateDoubleOperand value(this, node-&gt;child1());
1812             FPRTemporary scratch(this);
1813             branchDoubleNonZero(value.fpr(), scratch.fpr(), taken);
1814         }
1815 
1816         jump(notTaken);
1817 
1818         noResult(node);
1819         return;
1820     }
1821 
1822     case StringUse: {
1823         emitStringBranch(node-&gt;child1(), taken, notTaken);
1824         return;
1825     }
1826 
1827     case StringOrOtherUse: {
1828         emitStringOrOtherBranch(node-&gt;child1(), taken, notTaken);
1829         return;
1830     }
1831 
1832     case UntypedUse:
1833     case BooleanUse:
1834     case KnownBooleanUse: {
1835         JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
1836         GPRReg valueGPR = value.gpr();
1837 
1838         if (node-&gt;child1().useKind() == BooleanUse || node-&gt;child1().useKind() == KnownBooleanUse) {
1839             if (!needsTypeCheck(node-&gt;child1(), SpecBoolean)) {
1840                 MacroAssembler::ResultCondition condition = MacroAssembler::NonZero;
1841 
1842                 if (taken == nextBlock()) {
1843                     condition = MacroAssembler::Zero;
1844                     BasicBlock* tmp = taken;
1845                     taken = notTaken;
1846                     notTaken = tmp;
1847                 }
1848 
1849                 branchTest32(condition, valueGPR, TrustedImm32(true), taken);
1850                 jump(notTaken);
1851             } else {
1852                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(false))), notTaken);
1853                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(true))), taken);
1854 
1855                 typeCheck(JSValueRegs(valueGPR), node-&gt;child1(), SpecBoolean, m_jit.jump());
1856             }
1857             value.use();
1858         } else {
1859             GPRTemporary result(this);
1860             FPRTemporary fprValue(this);
1861             FPRTemporary fprTemp(this);
1862             Optional&lt;GPRTemporary&gt; scratch;
1863 
1864             GPRReg scratchGPR = InvalidGPRReg;
1865             bool shouldCheckMasqueradesAsUndefined = !masqueradesAsUndefinedWatchpointIsStillValid();
1866             if (shouldCheckMasqueradesAsUndefined) {
1867                 scratch.emplace(this);
1868                 scratchGPR = scratch-&gt;gpr();
1869             }
1870 
1871             GPRReg resultGPR = result.gpr();
1872             FPRReg valueFPR = fprValue.fpr();
1873             FPRReg tempFPR = fprTemp.fpr();
1874 
1875             if (node-&gt;child1()-&gt;prediction() &amp; SpecInt32Only) {
1876                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsNumber(0))), notTaken);
<a name="49" id="anc49"></a><span class="line-modified">1877                 branch64(MacroAssembler::AboveOrEqual, valueGPR, GPRInfo::numberTagRegister, taken);</span>
1878             }
1879 
1880             if (node-&gt;child1()-&gt;prediction() &amp; SpecBoolean) {
1881                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(false))), notTaken);
1882                 branch64(MacroAssembler::Equal, valueGPR, MacroAssembler::TrustedImm64(JSValue::encode(jsBoolean(true))), taken);
1883             }
1884 
1885             value.use();
1886 
1887             JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
1888             auto truthy = m_jit.branchIfTruthy(vm(), JSValueRegs(valueGPR), resultGPR, scratchGPR, valueFPR, tempFPR, shouldCheckMasqueradesAsUndefined, globalObject);
1889             addBranch(truthy, taken);
1890             jump(notTaken);
1891         }
1892 
1893         noResult(node, UseChildrenCalledExplicitly);
1894         return;
1895     }
1896 
1897     default:
1898         DFG_CRASH(m_jit.graph(), m_currentNode, &quot;Bad use kind&quot;);
1899     }
1900 }
1901 
1902 void SpeculativeJIT::compile(Node* node)
1903 {
1904     NodeType op = node-&gt;op();
1905 
1906     if (validateDFGDoesGC) {
1907         bool expectDoesGC = doesGC(m_jit.graph(), node);
1908         m_jit.store8(TrustedImm32(expectDoesGC), vm().heap.addressOfExpectDoesGC());
1909     }
1910 
1911 #if ENABLE(DFG_REGISTER_ALLOCATION_VALIDATION)
1912     m_jit.clearRegisterAllocationOffsets();
1913 #endif
1914 
1915     switch (op) {
1916     case JSConstant:
1917     case DoubleConstant:
1918     case Int52Constant:
1919     case PhantomDirectArguments:
1920     case PhantomClonedArguments:
1921         initConstantInfo(node);
1922         break;
1923 
1924     case LazyJSConstant:
1925         compileLazyJSConstant(node);
1926         break;
1927 
1928     case Identity: {
1929         compileIdentity(node);
1930         break;
1931     }
1932 
<a name="50" id="anc50"></a><span class="line-added">1933     case Inc:</span>
<span class="line-added">1934     case Dec:</span>
<span class="line-added">1935         compileIncOrDec(node);</span>
<span class="line-added">1936         break;</span>
<span class="line-added">1937 </span>
1938     case GetLocal: {
<a name="51" id="anc51"></a><span class="line-modified">1939         AbstractValue&amp; value = m_state.operand(node-&gt;operand());</span>
1940 
1941         // If the CFA is tracking this variable and it found that the variable
1942         // cannot have been assigned, then don&#39;t attempt to proceed.
1943         if (value.isClear()) {
1944             m_compileOkay = false;
1945             break;
1946         }
1947 
1948         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
1949         case FlushedDouble: {
1950             FPRTemporary result(this);
1951             m_jit.loadDouble(JITCompiler::addressFor(node-&gt;machineLocal()), result.fpr());
1952             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1953             m_fprs.retain(result.fpr(), virtualRegister, SpillOrderDouble);
1954             generationInfoFromVirtualRegister(virtualRegister).initDouble(node, node-&gt;refCount(), result.fpr());
1955             break;
1956         }
1957 
1958         case FlushedInt32: {
1959             GPRTemporary result(this);
1960             m_jit.load32(JITCompiler::payloadFor(node-&gt;machineLocal()), result.gpr());
1961 
1962             // Like int32Result, but don&#39;t useChildren - our children are phi nodes,
1963             // and don&#39;t represent values within this dataflow with virtual registers.
1964             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1965             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderInteger);
1966             generationInfoFromVirtualRegister(virtualRegister).initInt32(node, node-&gt;refCount(), result.gpr());
1967             break;
1968         }
1969 
1970         case FlushedInt52: {
1971             GPRTemporary result(this);
1972             m_jit.load64(JITCompiler::addressFor(node-&gt;machineLocal()), result.gpr());
1973 
1974             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1975             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderJS);
1976             generationInfoFromVirtualRegister(virtualRegister).initInt52(node, node-&gt;refCount(), result.gpr());
1977             break;
1978         }
1979 
1980         default:
1981             GPRTemporary result(this);
1982             m_jit.load64(JITCompiler::addressFor(node-&gt;machineLocal()), result.gpr());
1983 
1984             // Like jsValueResult, but don&#39;t useChildren - our children are phi nodes,
1985             // and don&#39;t represent values within this dataflow with virtual registers.
1986             VirtualRegister virtualRegister = node-&gt;virtualRegister();
1987             m_gprs.retain(result.gpr(), virtualRegister, SpillOrderJS);
1988 
1989             DataFormat format;
1990             if (isCellSpeculation(value.m_type))
1991                 format = DataFormatJSCell;
1992             else if (isBooleanSpeculation(value.m_type))
1993                 format = DataFormatJSBoolean;
1994             else
1995                 format = DataFormatJS;
1996 
1997             generationInfoFromVirtualRegister(virtualRegister).initJSValue(node, node-&gt;refCount(), result.gpr(), format);
1998             break;
1999         }
2000         break;
2001     }
2002 
2003     case MovHint: {
2004         compileMovHint(m_currentNode);
2005         noResult(node);
2006         break;
2007     }
2008 
2009     case ZombieHint: {
<a name="52" id="anc52"></a><span class="line-modified">2010         recordSetLocal(m_currentNode-&gt;unlinkedOperand(), VirtualRegister(), DataFormatDead);</span>
2011         noResult(node);
2012         break;
2013     }
2014 
2015     case ExitOK: {
2016         noResult(node);
2017         break;
2018     }
2019 
2020     case SetLocal: {
2021         switch (node-&gt;variableAccessData()-&gt;flushFormat()) {
2022         case FlushedDouble: {
2023             SpeculateDoubleOperand value(this, node-&gt;child1());
2024             m_jit.storeDouble(value.fpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
2025             noResult(node);
2026             // Indicate that it&#39;s no longer necessary to retrieve the value of
2027             // this bytecode variable from registers or other locations in the stack,
2028             // but that it is stored as a double.
2029             recordSetLocal(DataFormatDouble);
2030             break;
2031         }
2032 
2033         case FlushedInt32: {
2034             SpeculateInt32Operand value(this, node-&gt;child1());
2035             m_jit.store32(value.gpr(), JITCompiler::payloadFor(node-&gt;machineLocal()));
2036             noResult(node);
2037             recordSetLocal(DataFormatInt32);
2038             break;
2039         }
2040 
2041         case FlushedInt52: {
2042             SpeculateInt52Operand value(this, node-&gt;child1());
2043             m_jit.store64(value.gpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
2044             noResult(node);
2045             recordSetLocal(DataFormatInt52);
2046             break;
2047         }
2048 
2049         case FlushedCell: {
2050             SpeculateCellOperand cell(this, node-&gt;child1());
2051             GPRReg cellGPR = cell.gpr();
2052             m_jit.store64(cellGPR, JITCompiler::addressFor(node-&gt;machineLocal()));
2053             noResult(node);
2054             recordSetLocal(DataFormatCell);
2055             break;
2056         }
2057 
2058         case FlushedBoolean: {
2059             SpeculateBooleanOperand boolean(this, node-&gt;child1());
2060             m_jit.store64(boolean.gpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
2061             noResult(node);
2062             recordSetLocal(DataFormatBoolean);
2063             break;
2064         }
2065 
2066         case FlushedJSValue: {
2067             JSValueOperand value(this, node-&gt;child1());
2068             m_jit.store64(value.gpr(), JITCompiler::addressFor(node-&gt;machineLocal()));
2069             noResult(node);
2070             recordSetLocal(dataFormatFor(node-&gt;variableAccessData()-&gt;flushFormat()));
2071             break;
2072         }
2073 
2074         default:
2075             DFG_CRASH(m_jit.graph(), node, &quot;Bad flush format&quot;);
2076             break;
2077         }
2078 
2079         break;
2080     }
2081 
2082     case SetArgumentDefinitely:
2083     case SetArgumentMaybe:
2084         // This is a no-op; it just marks the fact that the argument is being used.
2085         // But it may be profitable to use this as a hook to run speculation checks
2086         // on arguments, thereby allowing us to trivially eliminate such checks if
2087         // the argument is not used.
2088         recordSetLocal(dataFormatFor(node-&gt;variableAccessData()-&gt;flushFormat()));
2089         break;
2090 
2091     case ValueBitNot:
2092         compileValueBitNot(node);
2093         break;
2094 
2095     case ArithBitNot:
2096         compileBitwiseNot(node);
2097         break;
2098 
2099     case ValueBitAnd:
2100     case ValueBitXor:
2101     case ValueBitOr:
2102         compileValueBitwiseOp(node);
2103         break;
2104 
2105     case ArithBitAnd:
2106     case ArithBitOr:
2107     case ArithBitXor:
2108         compileBitwiseOp(node);
2109         break;
2110 
2111     case ValueBitLShift:
2112         compileValueLShiftOp(node);
2113         break;
2114 
<a name="53" id="anc53"></a><span class="line-modified">2115     case ValueBitRShift:</span>
<span class="line-added">2116         compileValueBitRShift(node);</span>
<span class="line-added">2117         break;</span>
<span class="line-added">2118 </span>
<span class="line-added">2119     case ArithBitRShift:</span>
2120     case ArithBitLShift:
2121     case BitURShift:
2122         compileShiftOp(node);
2123         break;
2124 
2125     case UInt32ToNumber: {
2126         compileUInt32ToNumber(node);
2127         break;
2128     }
2129 
2130     case DoubleAsInt32: {
2131         compileDoubleAsInt32(node);
2132         break;
2133     }
2134 
2135     case ValueToInt32: {
2136         compileValueToInt32(node);
2137         break;
2138     }
2139 
2140     case DoubleRep: {
2141         compileDoubleRep(node);
2142         break;
2143     }
2144 
2145     case ValueRep: {
2146         compileValueRep(node);
2147         break;
2148     }
2149 
2150     case Int52Rep: {
2151         switch (node-&gt;child1().useKind()) {
2152         case Int32Use: {
2153             SpeculateInt32Operand operand(this, node-&gt;child1());
2154             GPRTemporary result(this, Reuse, operand);
2155 
2156             m_jit.signExtend32ToPtr(operand.gpr(), result.gpr());
2157 
2158             strictInt52Result(result.gpr(), node);
2159             break;
2160         }
2161 
2162         case AnyIntUse: {
2163             GPRTemporary result(this);
2164             GPRReg resultGPR = result.gpr();
2165 
2166             convertAnyInt(node-&gt;child1(), resultGPR);
2167 
2168             strictInt52Result(resultGPR, node);
2169             break;
2170         }
2171 
2172         case DoubleRepAnyIntUse: {
2173             SpeculateDoubleOperand value(this, node-&gt;child1());
2174             FPRReg valueFPR = value.fpr();
2175 
2176             flushRegisters();
2177             GPRFlushedCallResult result(this);
2178             GPRReg resultGPR = result.gpr();
2179             callOperation(operationConvertDoubleToInt52, resultGPR, valueFPR);
2180 
2181             DFG_TYPE_CHECK_WITH_EXIT_KIND(Int52Overflow,
2182                 JSValueRegs(), node-&gt;child1(), SpecAnyIntAsDouble,
2183                 m_jit.branch64(
2184                     JITCompiler::Equal, resultGPR,
2185                     JITCompiler::TrustedImm64(JSValue::notInt52)));
2186 
2187             strictInt52Result(resultGPR, node);
2188             break;
2189         }
2190 
2191         default:
2192             DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
2193         }
2194         break;
2195     }
2196 
2197     case ValueNegate:
2198         compileValueNegate(node);
2199         break;
2200 
2201     case ValueAdd:
2202         compileValueAdd(node);
2203         break;
2204 
2205     case ValueSub:
2206         compileValueSub(node);
2207         break;
2208 
2209     case StrCat: {
2210         compileStrCat(node);
2211         break;
2212     }
2213 
2214     case ArithAdd:
2215         compileArithAdd(node);
2216         break;
2217 
2218     case ArithClz32:
2219         compileArithClz32(node);
2220         break;
2221 
2222     case MakeRope:
2223         compileMakeRope(node);
2224         break;
2225 
2226     case ArithSub:
2227         compileArithSub(node);
2228         break;
2229 
2230     case ArithNegate:
2231         compileArithNegate(node);
2232         break;
2233 
2234     case ArithMul:
2235         compileArithMul(node);
2236         break;
2237 
2238     case ValueMul:
2239         compileValueMul(node);
2240         break;
2241 
2242     case ValueDiv: {
2243         compileValueDiv(node);
2244         break;
2245     }
2246 
2247     case ArithDiv: {
2248         compileArithDiv(node);
2249         break;
2250     }
2251 
2252     case ValueMod: {
2253         compileValueMod(node);
2254         break;
2255     }
2256 
2257     case ArithMod: {
2258         compileArithMod(node);
2259         break;
2260     }
2261 
2262     case ArithAbs:
2263         compileArithAbs(node);
2264         break;
2265 
2266     case ArithMin:
2267     case ArithMax: {
2268         compileArithMinMax(node);
2269         break;
2270     }
2271 
2272     case ValuePow:
2273         compileValuePow(node);
2274         break;
2275 
2276     case ArithPow:
2277         compileArithPow(node);
2278         break;
2279 
2280     case ArithSqrt:
2281         compileArithSqrt(node);
2282         break;
2283 
2284     case ArithFRound:
2285         compileArithFRound(node);
2286         break;
2287 
2288     case ArithRandom:
2289         compileArithRandom(node);
2290         break;
2291 
2292     case ArithRound:
2293     case ArithFloor:
2294     case ArithCeil:
2295     case ArithTrunc:
2296         compileArithRounding(node);
2297         break;
2298 
2299     case ArithUnary:
2300         compileArithUnary(node);
2301         break;
2302 
2303     case LogicalNot:
2304         compileLogicalNot(node);
2305         break;
2306 
2307     case CompareLess:
2308         if (compare(node, JITCompiler::LessThan, JITCompiler::DoubleLessThan, operationCompareLess))
2309             return;
2310         break;
2311 
2312     case CompareLessEq:
2313         if (compare(node, JITCompiler::LessThanOrEqual, JITCompiler::DoubleLessThanOrEqual, operationCompareLessEq))
2314             return;
2315         break;
2316 
2317     case CompareGreater:
2318         if (compare(node, JITCompiler::GreaterThan, JITCompiler::DoubleGreaterThan, operationCompareGreater))
2319             return;
2320         break;
2321 
2322     case CompareGreaterEq:
2323         if (compare(node, JITCompiler::GreaterThanOrEqual, JITCompiler::DoubleGreaterThanOrEqual, operationCompareGreaterEq))
2324             return;
2325         break;
2326 
2327     case CompareBelow:
2328         compileCompareUnsigned(node, JITCompiler::Below);
2329         break;
2330 
2331     case CompareBelowEq:
2332         compileCompareUnsigned(node, JITCompiler::BelowOrEqual);
2333         break;
2334 
2335     case CompareEq:
2336         if (compare(node, JITCompiler::Equal, JITCompiler::DoubleEqual, operationCompareEq))
2337             return;
2338         break;
2339 
2340     case CompareStrictEq:
2341         if (compileStrictEq(node))
2342             return;
2343         break;
2344 
2345     case CompareEqPtr:
2346         compileCompareEqPtr(node);
2347         break;
2348 
2349     case SameValue:
2350         compileSameValue(node);
2351         break;
2352 
2353     case StringCharCodeAt: {
2354         compileGetCharCodeAt(node);
2355         break;
2356     }
2357 
<a name="54" id="anc54"></a><span class="line-added">2358     case StringCodePointAt: {</span>
<span class="line-added">2359         compileStringCodePointAt(node);</span>
<span class="line-added">2360         break;</span>
<span class="line-added">2361     }</span>
<span class="line-added">2362 </span>
2363     case StringCharAt: {
2364         // Relies on StringCharAt node having same basic layout as GetByVal
2365         compileGetByValOnString(node);
2366         break;
2367     }
2368 
2369     case StringFromCharCode: {
2370         compileFromCharCode(node);
2371         break;
2372     }
2373 
<a name="55" id="anc55"></a><span class="line-added">2374     case CheckNeutered: {</span>
<span class="line-added">2375         compileCheckNeutered(node);</span>
<span class="line-added">2376         break;</span>
<span class="line-added">2377     }</span>
<span class="line-added">2378 </span>
<span class="line-added">2379     case CheckArrayOrEmpty:</span>
2380     case CheckArray: {
2381         checkArray(node);
2382         break;
2383     }
2384 
2385     case Arrayify:
2386     case ArrayifyToStructure: {
2387         arrayify(node);
2388         break;
2389     }
2390 
2391     case GetByVal: {
2392         switch (node-&gt;arrayMode().type()) {
2393         case Array::AnyTypedArray:
2394         case Array::ForceExit:
2395         case Array::SelectUsingArguments:
2396         case Array::SelectUsingPredictions:
2397         case Array::Unprofiled:
2398             DFG_CRASH(m_jit.graph(), node, &quot;Bad array mode type&quot;);
2399             break;
2400         case Array::Undecided: {
2401             SpeculateStrictInt32Operand index(this, m_graph.varArgChild(node, 1));
2402             GPRTemporary result(this, Reuse, index);
2403             GPRReg indexGPR = index.gpr();
2404             GPRReg resultGPR = result.gpr();
2405 
2406             speculationCheck(OutOfBounds, JSValueRegs(), node,
2407                 m_jit.branch32(MacroAssembler::LessThan, indexGPR, MacroAssembler::TrustedImm32(0)));
2408 
2409             use(m_graph.varArgChild(node, 0));
2410             index.use();
2411 
<a name="56" id="anc56"></a><span class="line-modified">2412             m_jit.move(MacroAssembler::TrustedImm64(JSValue::ValueUndefined), resultGPR);</span>
2413             jsValueResult(resultGPR, node, UseChildrenCalledExplicitly);
2414             break;
2415         }
2416         case Array::Generic: {
<a name="57" id="anc57"></a><span class="line-modified">2417             if (m_graph.m_slowGetByVal.contains(node)) {</span>
<span class="line-modified">2418                 if (m_graph.varArgChild(node, 0).useKind() == ObjectUse) {</span>
<span class="line-modified">2419                     if (m_graph.varArgChild(node, 1).useKind() == StringUse) {</span>
<span class="line-modified">2420                         compileGetByValForObjectWithString(node);</span>
<span class="line-added">2421                         break;</span>
<span class="line-added">2422                     }</span>
<span class="line-added">2423 </span>
<span class="line-added">2424                     if (m_graph.varArgChild(node, 1).useKind() == SymbolUse) {</span>
<span class="line-added">2425                         compileGetByValForObjectWithSymbol(node);</span>
<span class="line-added">2426                         break;</span>
<span class="line-added">2427                     }</span>
2428                 }
2429 
<a name="58" id="anc58"></a><span class="line-modified">2430                 JSValueOperand base(this, m_graph.varArgChild(node, 0));</span>
<span class="line-modified">2431                 JSValueOperand property(this, m_graph.varArgChild(node, 1));</span>
<span class="line-modified">2432                 GPRReg baseGPR = base.gpr();</span>
<span class="line-modified">2433                 GPRReg propertyGPR = property.gpr();</span>
<span class="line-added">2434 </span>
<span class="line-added">2435                 flushRegisters();</span>
<span class="line-added">2436                 GPRFlushedCallResult result(this);</span>
<span class="line-added">2437                 callOperation(operationGetByVal, result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, propertyGPR);</span>
<span class="line-added">2438                 m_jit.exceptionCheck();</span>
<span class="line-added">2439 </span>
<span class="line-added">2440                 jsValueResult(result.gpr(), node);</span>
<span class="line-added">2441                 break;</span>
2442             }
<a name="59" id="anc59"></a><span class="line-modified">2443 </span>
<span class="line-modified">2444             speculate(node, m_graph.varArgChild(node, 0));</span>
<span class="line-added">2445             speculate(node, m_graph.varArgChild(node, 1));</span>
<span class="line-added">2446 </span>
<span class="line-added">2447             JSValueOperand base(this, m_graph.varArgChild(node, 0), ManualOperandSpeculation);</span>
<span class="line-added">2448             JSValueOperand property(this, m_graph.varArgChild(node, 1), ManualOperandSpeculation);</span>
<span class="line-added">2449             GPRTemporary result(this, Reuse, property);</span>
2450             GPRReg baseGPR = base.gpr();
2451             GPRReg propertyGPR = property.gpr();
<a name="60" id="anc60"></a><span class="line-added">2452             GPRReg resultGPR = result.gpr();</span>
2453 
<a name="61" id="anc61"></a><span class="line-modified">2454             CodeOrigin codeOrigin = node-&gt;origin.semantic;</span>
<span class="line-modified">2455             CallSiteIndex callSite = m_jit.recordCallSiteAndGenerateExceptionHandlingOSRExitIfNeeded(codeOrigin, m_stream-&gt;size());</span>
<span class="line-modified">2456             RegisterSet usedRegisters = this-&gt;usedRegisters();</span>

2457 
<a name="62" id="anc62"></a><span class="line-modified">2458             JITCompiler::JumpList slowCases;</span>
<span class="line-added">2459             if (!m_state.forNode(m_graph.varArgChild(node, 0)).isType(SpecCell))</span>
<span class="line-added">2460                 slowCases.append(m_jit.branchIfNotCell(baseGPR));</span>
<span class="line-added">2461 </span>
<span class="line-added">2462             JITGetByValGenerator gen(</span>
<span class="line-added">2463                 m_jit.codeBlock(), codeOrigin, callSite, usedRegisters,</span>
<span class="line-added">2464                 JSValueRegs(baseGPR), JSValueRegs(propertyGPR), JSValueRegs(resultGPR));</span>
<span class="line-added">2465 </span>
<span class="line-added">2466             if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecString))</span>
<span class="line-added">2467                 gen.stubInfo()-&gt;propertyIsString = true;</span>
<span class="line-added">2468             else if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecInt32Only))</span>
<span class="line-added">2469                 gen.stubInfo()-&gt;propertyIsInt32 = true;</span>
<span class="line-added">2470             else if (m_state.forNode(m_graph.varArgChild(node, 1)).isType(SpecSymbol))</span>
<span class="line-added">2471                 gen.stubInfo()-&gt;propertyIsSymbol = true;</span>
<span class="line-added">2472 </span>
<span class="line-added">2473             gen.generateFastPath(m_jit);</span>
<span class="line-added">2474 </span>
<span class="line-added">2475             slowCases.append(gen.slowPathJump());</span>
<span class="line-added">2476 </span>
<span class="line-added">2477             std::unique_ptr&lt;SlowPathGenerator&gt; slowPath = slowPathCall(</span>
<span class="line-added">2478                 slowCases, this, operationGetByValOptimize,</span>
<span class="line-added">2479                 resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(codeOrigin)), gen.stubInfo(), nullptr, baseGPR, propertyGPR);</span>
<span class="line-added">2480 </span>
<span class="line-added">2481             m_jit.addGetByVal(gen, slowPath.get());</span>
<span class="line-added">2482             addSlowPathGenerator(WTFMove(slowPath));</span>
<span class="line-added">2483 </span>
<span class="line-added">2484             jsValueResult(resultGPR, node);</span>
2485             break;
2486         }
2487         case Array::Int32:
2488         case Array::Contiguous: {
2489             if (node-&gt;arrayMode().isInBounds()) {
2490                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2491                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2492 
2493                 GPRReg propertyReg = property.gpr();
2494                 GPRReg storageReg = storage.gpr();
2495 
2496                 if (!m_compileOkay)
2497                     return;
2498 
2499                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2500 
2501                 GPRTemporary result(this);
2502 
2503                 m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), result.gpr());
2504                 if (node-&gt;arrayMode().isSaneChain()) {
2505                     ASSERT(node-&gt;arrayMode().type() == Array::Contiguous);
2506                     JITCompiler::Jump notHole = m_jit.branchIfNotEmpty(result.gpr());
2507                     m_jit.move(TrustedImm64(JSValue::encode(jsUndefined())), result.gpr());
2508                     notHole.link(&amp;m_jit);
2509                 } else {
2510                     speculationCheck(
2511                         LoadFromHole, JSValueRegs(), 0,
2512                         m_jit.branchIfEmpty(result.gpr()));
2513                 }
2514                 jsValueResult(result.gpr(), node, node-&gt;arrayMode().type() == Array::Int32 ? DataFormatJSInt32 : DataFormatJS);
2515                 break;
2516             }
2517 
2518             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
2519             SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2520             StorageOperand storage(this, m_graph.varArgChild(node, 2));
2521 
2522             GPRReg baseReg = base.gpr();
2523             GPRReg propertyReg = property.gpr();
2524             GPRReg storageReg = storage.gpr();
2525 
2526             if (!m_compileOkay)
2527                 return;
2528 
2529             GPRTemporary result(this);
2530             GPRReg resultReg = result.gpr();
2531 
2532             MacroAssembler::JumpList slowCases;
2533 
2534             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2535 
2536             m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), resultReg);
2537             slowCases.append(m_jit.branchIfEmpty(resultReg));
2538 
2539             addSlowPathGenerator(
2540                 slowPathCall(
2541                     slowCases, this, operationGetByValObjectInt,
<a name="63" id="anc63"></a><span class="line-modified">2542                     result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));</span>
2543 
2544             jsValueResult(resultReg, node);
2545             break;
2546         }
2547 
2548         case Array::Double: {
2549             if (node-&gt;arrayMode().isInBounds()) {
2550                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2551                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2552 
2553                 GPRReg propertyReg = property.gpr();
2554                 GPRReg storageReg = storage.gpr();
2555 
2556                 if (!m_compileOkay)
2557                     return;
2558 
2559                 FPRTemporary result(this);
2560                 FPRReg resultReg = result.fpr();
2561 
2562                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2563 
2564                 m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), resultReg);
2565                 if (!node-&gt;arrayMode().isSaneChain())
2566                     speculationCheck(LoadFromHole, JSValueRegs(), 0, m_jit.branchIfNaN(resultReg));
2567                 doubleResult(resultReg, node);
2568                 break;
2569             }
2570 
2571             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
2572             SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2573             StorageOperand storage(this, m_graph.varArgChild(node, 2));
2574 
2575             GPRReg baseReg = base.gpr();
2576             GPRReg propertyReg = property.gpr();
2577             GPRReg storageReg = storage.gpr();
2578 
2579             if (!m_compileOkay)
2580                 return;
2581 
2582             GPRTemporary result(this);
2583             FPRTemporary temp(this);
2584             GPRReg resultReg = result.gpr();
2585             FPRReg tempReg = temp.fpr();
2586 
2587             MacroAssembler::JumpList slowCases;
2588 
2589             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2590 
2591             m_jit.loadDouble(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight), tempReg);
2592             slowCases.append(m_jit.branchIfNaN(tempReg));
2593             boxDouble(tempReg, resultReg);
2594 
2595             addSlowPathGenerator(
2596                 slowPathCall(
2597                     slowCases, this, operationGetByValObjectInt,
<a name="64" id="anc64"></a><span class="line-modified">2598                     result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));</span>
2599 
2600             jsValueResult(resultReg, node);
2601             break;
2602         }
2603 
2604         case Array::ArrayStorage:
2605         case Array::SlowPutArrayStorage: {
2606             if (node-&gt;arrayMode().isInBounds()) {
2607                 SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2608                 StorageOperand storage(this, m_graph.varArgChild(node, 2));
2609 
2610                 GPRReg propertyReg = property.gpr();
2611                 GPRReg storageReg = storage.gpr();
2612 
2613                 if (!m_compileOkay)
2614                     return;
2615 
2616                 speculationCheck(OutOfBounds, JSValueRegs(), 0, m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset())));
2617 
2618                 GPRTemporary result(this);
2619                 m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), result.gpr());
2620                 speculationCheck(LoadFromHole, JSValueRegs(), 0, m_jit.branchIfEmpty(result.gpr()));
2621 
2622                 jsValueResult(result.gpr(), node);
2623                 break;
2624             }
2625 
2626             SpeculateCellOperand base(this, m_graph.varArgChild(node, 0));
2627             SpeculateStrictInt32Operand property(this, m_graph.varArgChild(node, 1));
2628             StorageOperand storage(this, m_graph.varArgChild(node, 2));
2629 
2630             GPRReg baseReg = base.gpr();
2631             GPRReg propertyReg = property.gpr();
2632             GPRReg storageReg = storage.gpr();
2633 
2634             if (!m_compileOkay)
2635                 return;
2636 
2637             GPRTemporary result(this);
2638             GPRReg resultReg = result.gpr();
2639 
2640             MacroAssembler::JumpList slowCases;
2641 
2642             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset())));
2643 
2644             m_jit.load64(MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), resultReg);
2645             slowCases.append(m_jit.branchIfEmpty(resultReg));
2646 
2647             addSlowPathGenerator(
2648                 slowPathCall(
2649                     slowCases, this, operationGetByValObjectInt,
<a name="65" id="anc65"></a><span class="line-modified">2650                     result.gpr(), TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg));</span>
2651 
2652             jsValueResult(resultReg, node);
2653             break;
2654         }
2655         case Array::String:
2656             compileGetByValOnString(node);
2657             break;
2658         case Array::DirectArguments:
2659             compileGetByValOnDirectArguments(node);
2660             break;
2661         case Array::ScopedArguments:
2662             compileGetByValOnScopedArguments(node);
2663             break;
2664         case Array::Int8Array:
2665         case Array::Int16Array:
2666         case Array::Int32Array:
2667         case Array::Uint8Array:
2668         case Array::Uint8ClampedArray:
2669         case Array::Uint16Array:
2670         case Array::Uint32Array:
2671         case Array::Float32Array:
2672         case Array::Float64Array: {
2673             TypedArrayType type = node-&gt;arrayMode().typedArrayType();
2674             if (isInt(type))
2675                 compileGetByValOnIntTypedArray(node, type);
2676             else
2677                 compileGetByValOnFloatTypedArray(node, type);
2678         } }
2679         break;
2680     }
2681 
2682     case GetByValWithThis: {
2683         compileGetByValWithThis(node);
2684         break;
2685     }
2686 
2687     case PutByValDirect:
2688     case PutByVal:
2689     case PutByValAlias: {
2690         Edge child1 = m_jit.graph().varArgChild(node, 0);
2691         Edge child2 = m_jit.graph().varArgChild(node, 1);
2692         Edge child3 = m_jit.graph().varArgChild(node, 2);
2693         Edge child4 = m_jit.graph().varArgChild(node, 3);
2694 
2695         ArrayMode arrayMode = node-&gt;arrayMode().modeForPut();
2696         bool alreadyHandled = false;
2697 
2698         switch (arrayMode.type()) {
2699         case Array::SelectUsingPredictions:
2700         case Array::ForceExit:
2701             DFG_CRASH(m_jit.graph(), node, &quot;Bad array mode type&quot;);
2702             break;
2703         case Array::Generic: {
2704             DFG_ASSERT(m_jit.graph(), node, node-&gt;op() == PutByVal || node-&gt;op() == PutByValDirect, node-&gt;op());
2705 
2706             if (child1.useKind() == CellUse) {
2707                 if (child2.useKind() == StringUse) {
2708                     compilePutByValForCellWithString(node, child1, child2, child3);
2709                     alreadyHandled = true;
2710                     break;
2711                 }
2712 
2713                 if (child2.useKind() == SymbolUse) {
2714                     compilePutByValForCellWithSymbol(node, child1, child2, child3);
2715                     alreadyHandled = true;
2716                     break;
2717                 }
2718             }
2719 
2720             JSValueOperand arg1(this, child1);
2721             JSValueOperand arg2(this, child2);
2722             JSValueOperand arg3(this, child3);
2723             GPRReg arg1GPR = arg1.gpr();
2724             GPRReg arg2GPR = arg2.gpr();
2725             GPRReg arg3GPR = arg3.gpr();
2726             flushRegisters();
2727             if (node-&gt;op() == PutByValDirect)
<a name="66" id="anc66"></a><span class="line-modified">2728                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValDirectStrict : operationPutByValDirectNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR, arg3GPR);</span>
2729             else
<a name="67" id="anc67"></a><span class="line-modified">2730                 callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValStrict : operationPutByValNonStrict, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), arg1GPR, arg2GPR, arg3GPR);</span>
2731             m_jit.exceptionCheck();
2732 
2733             noResult(node);
2734             alreadyHandled = true;
2735             break;
2736         }
2737         default:
2738             break;
2739         }
2740 
2741         if (alreadyHandled)
2742             break;
2743 
2744         SpeculateCellOperand base(this, child1);
2745         SpeculateStrictInt32Operand property(this, child2);
2746 
2747         GPRReg baseReg = base.gpr();
2748         GPRReg propertyReg = property.gpr();
2749 
2750         switch (arrayMode.type()) {
2751         case Array::Int32:
2752         case Array::Contiguous: {
2753             JSValueOperand value(this, child3, ManualOperandSpeculation);
2754 
2755             GPRReg valueReg = value.gpr();
2756 
2757             if (!m_compileOkay)
2758                 return;
2759 
2760             if (arrayMode.type() == Array::Int32) {
2761                 DFG_TYPE_CHECK(
2762                     JSValueRegs(valueReg), child3, SpecInt32Only,
2763                     m_jit.branchIfNotInt32(valueReg));
2764             }
2765 
2766             StorageOperand storage(this, child4);
2767             GPRReg storageReg = storage.gpr();
2768 
2769             if (node-&gt;op() == PutByValAlias) {
2770                 // Store the value to the array.
2771                 GPRReg propertyReg = property.gpr();
2772                 GPRReg valueReg = value.gpr();
2773                 m_jit.store64(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
2774 
2775                 noResult(node);
2776                 break;
2777             }
2778 
2779             GPRTemporary temporary;
2780             GPRReg temporaryReg = temporaryRegisterForPutByVal(temporary, node);
2781 
2782             MacroAssembler::Jump slowCase;
2783 
2784             if (arrayMode.isInBounds()) {
2785                 speculationCheck(
2786                     OutOfBounds, JSValueRegs(), 0,
2787                     m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength())));
2788             } else {
2789                 MacroAssembler::Jump inBounds = m_jit.branch32(MacroAssembler::Below, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
2790 
2791                 slowCase = m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfVectorLength()));
2792 
2793                 if (!arrayMode.isOutOfBounds())
2794                     speculationCheck(OutOfBounds, JSValueRegs(), 0, slowCase);
2795 
2796                 m_jit.add32(TrustedImm32(1), propertyReg, temporaryReg);
2797                 m_jit.store32(temporaryReg, MacroAssembler::Address(storageReg, Butterfly::offsetOfPublicLength()));
2798 
2799                 inBounds.link(&amp;m_jit);
2800             }
2801 
2802             m_jit.store64(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight));
2803 
2804             base.use();
2805             property.use();
2806             value.use();
2807             storage.use();
2808 
2809             if (arrayMode.isOutOfBounds()) {
2810                 addSlowPathGenerator(slowPathCall(
2811                     slowCase, this,
2812                     m_jit.isStrictModeFor(node-&gt;origin.semantic)
2813                         ? (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
2814                         : (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
<a name="68" id="anc68"></a><span class="line-modified">2815                     NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, valueReg));</span>
2816             }
2817 
2818             noResult(node, UseChildrenCalledExplicitly);
2819             break;
2820         }
2821 
2822         case Array::Double: {
2823             compileDoublePutByVal(node, base, property);
2824             break;
2825         }
2826 
2827         case Array::ArrayStorage:
2828         case Array::SlowPutArrayStorage: {
2829             JSValueOperand value(this, child3);
2830 
2831             GPRReg valueReg = value.gpr();
2832 
2833             if (!m_compileOkay)
2834                 return;
2835 
2836             StorageOperand storage(this, child4);
2837             GPRReg storageReg = storage.gpr();
2838 
2839             if (node-&gt;op() == PutByValAlias) {
2840                 // Store the value to the array.
2841                 GPRReg propertyReg = property.gpr();
2842                 GPRReg valueReg = value.gpr();
2843                 m_jit.store64(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()));
2844 
2845                 noResult(node);
2846                 break;
2847             }
2848 
2849             GPRTemporary temporary;
2850             GPRReg temporaryReg = temporaryRegisterForPutByVal(temporary, node);
2851 
2852             MacroAssembler::JumpList slowCases;
2853 
2854             MacroAssembler::Jump beyondArrayBounds = m_jit.branch32(MacroAssembler::AboveOrEqual, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::vectorLengthOffset()));
2855             if (!arrayMode.isOutOfBounds())
2856                 speculationCheck(OutOfBounds, JSValueRegs(), 0, beyondArrayBounds);
2857             else
2858                 slowCases.append(beyondArrayBounds);
2859 
2860             // Check if we&#39;re writing to a hole; if so increment m_numValuesInVector.
2861             if (arrayMode.isInBounds()) {
2862                 speculationCheck(
2863                     StoreToHole, JSValueRegs(), 0,
2864                     m_jit.branchTest64(MacroAssembler::Zero, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset())));
2865             } else {
2866                 MacroAssembler::Jump notHoleValue = m_jit.branchTest64(MacroAssembler::NonZero, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()));
2867                 if (arrayMode.isSlowPut()) {
2868                     // This is sort of strange. If we wanted to optimize this code path, we would invert
2869                     // the above branch. But it&#39;s simply not worth it since this only happens if we&#39;re
2870                     // already having a bad time.
2871                     slowCases.append(m_jit.jump());
2872                 } else {
2873                     m_jit.add32(TrustedImm32(1), MacroAssembler::Address(storageReg, ArrayStorage::numValuesInVectorOffset()));
2874 
2875                     // If we&#39;re writing to a hole we might be growing the array;
2876                     MacroAssembler::Jump lengthDoesNotNeedUpdate = m_jit.branch32(MacroAssembler::Below, propertyReg, MacroAssembler::Address(storageReg, ArrayStorage::lengthOffset()));
2877                     m_jit.add32(TrustedImm32(1), propertyReg, temporaryReg);
2878                     m_jit.store32(temporaryReg, MacroAssembler::Address(storageReg, ArrayStorage::lengthOffset()));
2879 
2880                     lengthDoesNotNeedUpdate.link(&amp;m_jit);
2881                 }
2882                 notHoleValue.link(&amp;m_jit);
2883             }
2884 
2885             // Store the value to the array.
2886             m_jit.store64(valueReg, MacroAssembler::BaseIndex(storageReg, propertyReg, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()));
2887 
2888             base.use();
2889             property.use();
2890             value.use();
2891             storage.use();
2892 
2893             if (!slowCases.empty()) {
2894                 addSlowPathGenerator(slowPathCall(
2895                     slowCases, this,
2896                     m_jit.isStrictModeFor(node-&gt;origin.semantic)
2897                         ? (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsStrict : operationPutByValBeyondArrayBoundsStrict)
2898                         : (node-&gt;op() == PutByValDirect ? operationPutByValDirectBeyondArrayBoundsNonStrict : operationPutByValBeyondArrayBoundsNonStrict),
<a name="69" id="anc69"></a><span class="line-modified">2899                     NoResult, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseReg, propertyReg, valueReg));</span>
2900             }
2901 
2902             noResult(node, UseChildrenCalledExplicitly);
2903             break;
2904         }
2905 
2906         case Array::Int8Array:
2907         case Array::Int16Array:
2908         case Array::Int32Array:
2909         case Array::Uint8Array:
2910         case Array::Uint8ClampedArray:
2911         case Array::Uint16Array:
2912         case Array::Uint32Array:
2913         case Array::Float32Array:
2914         case Array::Float64Array: {
2915             TypedArrayType type = arrayMode.typedArrayType();
2916             if (isInt(type))
2917                 compilePutByValForIntTypedArray(base.gpr(), property.gpr(), node, type);
2918             else
2919                 compilePutByValForFloatTypedArray(base.gpr(), property.gpr(), node, type);
2920             break;
2921         }
2922 
2923         case Array::AnyTypedArray:
2924         case Array::String:
2925         case Array::DirectArguments:
2926         case Array::ForceExit:
2927         case Array::Generic:
2928         case Array::ScopedArguments:
2929         case Array::SelectUsingArguments:
2930         case Array::SelectUsingPredictions:
2931         case Array::Undecided:
2932         case Array::Unprofiled:
2933             RELEASE_ASSERT_NOT_REACHED();
2934         }
2935         break;
2936     }
2937 
2938     case AtomicsAdd:
2939     case AtomicsAnd:
2940     case AtomicsCompareExchange:
2941     case AtomicsExchange:
2942     case AtomicsLoad:
2943     case AtomicsOr:
2944     case AtomicsStore:
2945     case AtomicsSub:
2946     case AtomicsXor: {
2947         unsigned numExtraArgs = numExtraAtomicsArgs(node-&gt;op());
2948         Edge baseEdge = m_jit.graph().child(node, 0);
2949         Edge indexEdge = m_jit.graph().child(node, 1);
2950         Edge argEdges[maxNumExtraAtomicsArgs];
2951         for (unsigned i = numExtraArgs; i--;)
2952             argEdges[i] = m_jit.graph().child(node, 2 + i);
2953         Edge storageEdge = m_jit.graph().child(node, 2 + numExtraArgs);
2954 
2955         GPRReg baseGPR;
2956         GPRReg indexGPR;
2957         GPRReg argGPRs[2];
2958         GPRReg resultGPR;
2959 
2960         auto callSlowPath = [&amp;] () {
<a name="70" id="anc70"></a><span class="line-added">2961             auto globalObjectImmPtr = TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic));</span>
2962             switch (node-&gt;op()) {
2963             case AtomicsAdd:
<a name="71" id="anc71"></a><span class="line-modified">2964                 callOperation(operationAtomicsAdd, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
2965                 break;
2966             case AtomicsAnd:
<a name="72" id="anc72"></a><span class="line-modified">2967                 callOperation(operationAtomicsAnd, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
2968                 break;
2969             case AtomicsCompareExchange:
<a name="73" id="anc73"></a><span class="line-modified">2970                 callOperation(operationAtomicsCompareExchange, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0], argGPRs[1]);</span>
2971                 break;
2972             case AtomicsExchange:
<a name="74" id="anc74"></a><span class="line-modified">2973                 callOperation(operationAtomicsExchange, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
2974                 break;
2975             case AtomicsLoad:
<a name="75" id="anc75"></a><span class="line-modified">2976                 callOperation(operationAtomicsLoad, resultGPR, globalObjectImmPtr, baseGPR, indexGPR);</span>
2977                 break;
2978             case AtomicsOr:
<a name="76" id="anc76"></a><span class="line-modified">2979                 callOperation(operationAtomicsOr, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
2980                 break;
2981             case AtomicsStore:
<a name="77" id="anc77"></a><span class="line-modified">2982                 callOperation(operationAtomicsStore, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
2983                 break;
2984             case AtomicsSub:
<a name="78" id="anc78"></a><span class="line-modified">2985                 callOperation(operationAtomicsSub, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
2986                 break;
2987             case AtomicsXor:
<a name="79" id="anc79"></a><span class="line-modified">2988                 callOperation(operationAtomicsXor, resultGPR, globalObjectImmPtr, baseGPR, indexGPR, argGPRs[0]);</span>
2989                 break;
2990             default:
2991                 RELEASE_ASSERT_NOT_REACHED();
2992                 break;
2993             }
2994         };
2995 
2996         if (!storageEdge) {
2997             // We are in generic mode!
2998             JSValueOperand base(this, baseEdge);
2999             JSValueOperand index(this, indexEdge);
3000             Optional&lt;JSValueOperand&gt; args[2];
3001             baseGPR = base.gpr();
3002             indexGPR = index.gpr();
3003             for (unsigned i = numExtraArgs; i--;) {
3004                 args[i].emplace(this, argEdges[i]);
3005                 argGPRs[i] = args[i]-&gt;gpr();
3006             }
3007 
3008             flushRegisters();
3009             GPRFlushedCallResult result(this);
3010             resultGPR = result.gpr();
3011             callSlowPath();
3012             m_jit.exceptionCheck();
3013 
3014             jsValueResult(resultGPR, node);
3015             break;
3016         }
3017 
3018         TypedArrayType type = node-&gt;arrayMode().typedArrayType();
3019 
3020         SpeculateCellOperand base(this, baseEdge);
3021         SpeculateStrictInt32Operand index(this, indexEdge);
3022 
3023         baseGPR = base.gpr();
3024         indexGPR = index.gpr();
3025 
3026         emitTypedArrayBoundsCheck(node, baseGPR, indexGPR);
3027 
3028         GPRTemporary args[2];
3029 
3030         JITCompiler::JumpList slowPathCases;
3031 
3032         bool ok = true;
3033         for (unsigned i = numExtraArgs; i--;) {
3034             if (!getIntTypedArrayStoreOperand(args[i], indexGPR, argEdges[i], slowPathCases)) {
3035                 noResult(node);
3036                 ok = false;
3037             }
3038             argGPRs[i] = args[i].gpr();
3039         }
3040         if (!ok)
3041             break;
3042 
3043         StorageOperand storage(this, storageEdge);
3044         GPRTemporary oldValue(this);
3045         GPRTemporary result(this);
3046         GPRTemporary newValue(this);
3047         GPRReg storageGPR = storage.gpr();
3048         GPRReg oldValueGPR = oldValue.gpr();
3049         resultGPR = result.gpr();
3050         GPRReg newValueGPR = newValue.gpr();
3051 
3052         // FIXME: It shouldn&#39;t be necessary to nop-pad between register allocation and a jump label.
3053         // https://bugs.webkit.org/show_bug.cgi?id=170974
3054         m_jit.nop();
3055 
3056         JITCompiler::Label loop = m_jit.label();
3057 
3058         loadFromIntTypedArray(storageGPR, indexGPR, oldValueGPR, type);
3059         m_jit.move(oldValueGPR, newValueGPR);
3060         m_jit.move(oldValueGPR, resultGPR);
3061 
3062         switch (node-&gt;op()) {
3063         case AtomicsAdd:
3064             m_jit.add32(argGPRs[0], newValueGPR);
3065             break;
3066         case AtomicsAnd:
3067             m_jit.and32(argGPRs[0], newValueGPR);
3068             break;
3069         case AtomicsCompareExchange: {
3070             switch (elementSize(type)) {
3071             case 1:
3072                 if (isSigned(type))
3073                     m_jit.signExtend8To32(argGPRs[0], argGPRs[0]);
3074                 else
3075                     m_jit.and32(TrustedImm32(0xff), argGPRs[0]);
3076                 break;
3077             case 2:
3078                 if (isSigned(type))
3079                     m_jit.signExtend16To32(argGPRs[0], argGPRs[0]);
3080                 else
3081                     m_jit.and32(TrustedImm32(0xffff), argGPRs[0]);
3082                 break;
3083             case 4:
3084                 break;
3085             default:
3086                 RELEASE_ASSERT_NOT_REACHED();
3087                 break;
3088             }
3089             JITCompiler::Jump fail = m_jit.branch32(JITCompiler::NotEqual, oldValueGPR, argGPRs[0]);
3090             m_jit.move(argGPRs[1], newValueGPR);
3091             fail.link(&amp;m_jit);
3092             break;
3093         }
3094         case AtomicsExchange:
3095             m_jit.move(argGPRs[0], newValueGPR);
3096             break;
3097         case AtomicsLoad:
3098             break;
3099         case AtomicsOr:
3100             m_jit.or32(argGPRs[0], newValueGPR);
3101             break;
3102         case AtomicsStore:
3103             m_jit.move(argGPRs[0], newValueGPR);
3104             m_jit.move(argGPRs[0], resultGPR);
3105             break;
3106         case AtomicsSub:
3107             m_jit.sub32(argGPRs[0], newValueGPR);
3108             break;
3109         case AtomicsXor:
3110             m_jit.xor32(argGPRs[0], newValueGPR);
3111             break;
3112         default:
3113             RELEASE_ASSERT_NOT_REACHED();
3114             break;
3115         }
3116 
3117         JITCompiler::JumpList success;
3118         switch (elementSize(type)) {
3119         case 1:
3120             success = m_jit.branchAtomicWeakCAS8(JITCompiler::Success, oldValueGPR, newValueGPR, JITCompiler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesOne));
3121             break;
3122         case 2:
3123             success = m_jit.branchAtomicWeakCAS16(JITCompiler::Success, oldValueGPR, newValueGPR, JITCompiler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesTwo));
3124             break;
3125         case 4:
3126             success = m_jit.branchAtomicWeakCAS32(JITCompiler::Success, oldValueGPR, newValueGPR, JITCompiler::BaseIndex(storageGPR, indexGPR, MacroAssembler::TimesFour));
3127             break;
3128         default:
3129             RELEASE_ASSERT_NOT_REACHED();
3130             break;
3131         }
3132         m_jit.jump().linkTo(loop, &amp;m_jit);
3133 
3134         if (!slowPathCases.empty()) {
3135             slowPathCases.link(&amp;m_jit);
3136             silentSpillAllRegisters(resultGPR);
3137             // Since we spilled, we can do things to registers.
3138             m_jit.boxCell(baseGPR, JSValueRegs(baseGPR));
3139             m_jit.boxInt32(indexGPR, JSValueRegs(indexGPR));
3140             for (unsigned i = numExtraArgs; i--;)
3141                 m_jit.boxInt32(argGPRs[i], JSValueRegs(argGPRs[i]));
3142             callSlowPath();
3143             silentFillAllRegisters();
3144             m_jit.exceptionCheck();
3145         }
3146 
3147         success.link(&amp;m_jit);
3148         setIntTypedArrayLoadResult(node, resultGPR, type);
3149         break;
3150     }
3151 
3152     case AtomicsIsLockFree: {
3153         if (node-&gt;child1().useKind() != Int32Use) {
3154             JSValueOperand operand(this, node-&gt;child1());
3155             GPRReg operandGPR = operand.gpr();
3156             flushRegisters();
3157             GPRFlushedCallResult result(this);
3158             GPRReg resultGPR = result.gpr();
<a name="80" id="anc80"></a><span class="line-modified">3159             callOperation(operationAtomicsIsLockFree, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), operandGPR);</span>
3160             m_jit.exceptionCheck();
3161             jsValueResult(resultGPR, node);
3162             break;
3163         }
3164 
3165         SpeculateInt32Operand operand(this, node-&gt;child1());
3166         GPRTemporary result(this);
3167         GPRReg operandGPR = operand.gpr();
3168         GPRReg resultGPR = result.gpr();
<a name="81" id="anc81"></a><span class="line-modified">3169         m_jit.move(TrustedImm32(JSValue::ValueTrue), resultGPR);</span>
3170         JITCompiler::JumpList done;
3171         done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(4)));
3172         done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(1)));
3173         done.append(m_jit.branch32(JITCompiler::Equal, operandGPR, TrustedImm32(2)));
<a name="82" id="anc82"></a><span class="line-modified">3174         m_jit.move(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
3175         done.link(&amp;m_jit);
3176         jsValueResult(resultGPR, node);
3177         break;
3178     }
3179 
3180     case RegExpExec: {
3181         compileRegExpExec(node);
3182         break;
3183     }
3184 
3185     case RegExpExecNonGlobalOrSticky: {
3186         compileRegExpExecNonGlobalOrSticky(node);
3187         break;
3188     }
3189 
3190     case RegExpMatchFastGlobal: {
3191         compileRegExpMatchFastGlobal(node);
3192         break;
3193     }
3194 
3195     case RegExpTest: {
3196         compileRegExpTest(node);
3197         break;
3198     }
3199 
3200     case RegExpMatchFast: {
3201         compileRegExpMatchFast(node);
3202         break;
3203     }
3204 
3205     case StringReplace:
3206     case StringReplaceRegExp: {
3207         compileStringReplace(node);
3208         break;
3209     }
3210 
3211     case GetRegExpObjectLastIndex: {
3212         compileGetRegExpObjectLastIndex(node);
3213         break;
3214     }
3215 
3216     case SetRegExpObjectLastIndex: {
3217         compileSetRegExpObjectLastIndex(node);
3218         break;
3219     }
3220 
3221     case RecordRegExpCachedResult: {
3222         compileRecordRegExpCachedResult(node);
3223         break;
3224     }
3225 
3226     case ArrayPush: {
3227         compileArrayPush(node);
3228         break;
3229     }
3230 
3231     case ArraySlice: {
3232         compileArraySlice(node);
3233         break;
3234     }
3235 
3236     case ArrayIndexOf: {
3237         compileArrayIndexOf(node);
3238         break;
3239     }
3240 
3241     case ArrayPop: {
3242         ASSERT(node-&gt;arrayMode().isJSArray());
3243 
3244         SpeculateCellOperand base(this, node-&gt;child1());
3245         StorageOperand storage(this, node-&gt;child2());
3246         GPRTemporary value(this);
3247         GPRTemporary storageLength(this);
3248         FPRTemporary temp(this); // This is kind of lame, since we don&#39;t always need it. I&#39;m relying on the fact that we don&#39;t have FPR pressure, especially in code that uses pop().
3249 
3250         GPRReg baseGPR = base.gpr();
3251         GPRReg storageGPR = storage.gpr();
3252         GPRReg valueGPR = value.gpr();
3253         GPRReg storageLengthGPR = storageLength.gpr();
3254         FPRReg tempFPR = temp.fpr();
3255 
3256         switch (node-&gt;arrayMode().type()) {
3257         case Array::Int32:
3258         case Array::Double:
3259         case Array::Contiguous: {
3260             m_jit.load32(
3261                 MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()), storageLengthGPR);
3262             MacroAssembler::Jump undefinedCase =
3263                 m_jit.branchTest32(MacroAssembler::Zero, storageLengthGPR);
3264             m_jit.sub32(TrustedImm32(1), storageLengthGPR);
3265             m_jit.store32(
3266                 storageLengthGPR, MacroAssembler::Address(storageGPR, Butterfly::offsetOfPublicLength()));
3267             MacroAssembler::Jump slowCase;
3268             if (node-&gt;arrayMode().type() == Array::Double) {
3269                 m_jit.loadDouble(
3270                     MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight),
3271                     tempFPR);
3272                 // FIXME: This would not have to be here if changing the publicLength also zeroed the values between the old
3273                 // length and the new length.
3274                 m_jit.store64(
3275                     MacroAssembler::TrustedImm64(bitwise_cast&lt;int64_t&gt;(PNaN)), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
3276                 slowCase = m_jit.branchIfNaN(tempFPR);
3277                 boxDouble(tempFPR, valueGPR);
3278             } else {
3279                 m_jit.load64(
3280                     MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight),
3281                     valueGPR);
3282                 // FIXME: This would not have to be here if changing the publicLength also zeroed the values between the old
3283                 // length and the new length.
3284                 m_jit.store64(
3285                 MacroAssembler::TrustedImm64((int64_t)0), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight));
3286                 slowCase = m_jit.branchIfEmpty(valueGPR);
3287             }
3288 
3289             addSlowPathGenerator(
3290                 slowPathMove(
3291                     undefinedCase, this,
3292                     MacroAssembler::TrustedImm64(JSValue::encode(jsUndefined())), valueGPR));
3293             addSlowPathGenerator(
3294                 slowPathCall(
<a name="83" id="anc83"></a><span class="line-modified">3295                     slowCase, this, operationArrayPopAndRecoverLength, valueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR));</span>
3296 
3297             // We can&#39;t know for sure that the result is an int because of the slow paths. :-/
3298             jsValueResult(valueGPR, node);
3299             break;
3300         }
3301 
3302         case Array::ArrayStorage: {
3303             m_jit.load32(MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()), storageLengthGPR);
3304 
3305             JITCompiler::Jump undefinedCase =
3306                 m_jit.branchTest32(MacroAssembler::Zero, storageLengthGPR);
3307 
3308             m_jit.sub32(TrustedImm32(1), storageLengthGPR);
3309 
3310             JITCompiler::JumpList slowCases;
3311             slowCases.append(m_jit.branch32(MacroAssembler::AboveOrEqual, storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::vectorLengthOffset())));
3312 
3313             m_jit.load64(MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight, ArrayStorage::vectorOffset()), valueGPR);
3314             slowCases.append(m_jit.branchIfEmpty(valueGPR));
3315 
3316             m_jit.store32(storageLengthGPR, MacroAssembler::Address(storageGPR, ArrayStorage::lengthOffset()));
3317 
3318             m_jit.store64(MacroAssembler::TrustedImm64((int64_t)0), MacroAssembler::BaseIndex(storageGPR, storageLengthGPR, MacroAssembler::TimesEight,  ArrayStorage::vectorOffset()));
3319             m_jit.sub32(MacroAssembler::TrustedImm32(1), MacroAssembler::Address(storageGPR, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
3320 
3321             addSlowPathGenerator(
3322                 slowPathMove(
3323                     undefinedCase, this,
3324                     MacroAssembler::TrustedImm64(JSValue::encode(jsUndefined())), valueGPR));
3325 
3326             addSlowPathGenerator(
3327                 slowPathCall(
<a name="84" id="anc84"></a><span class="line-modified">3328                     slowCases, this, operationArrayPop, valueGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR));</span>
3329 
3330             jsValueResult(valueGPR, node);
3331             break;
3332         }
3333 
3334         default:
3335             CRASH();
3336             break;
3337         }
3338         break;
3339     }
3340 
3341     case DFG::Jump: {
3342         jump(node-&gt;targetBlock());
3343         noResult(node);
3344         break;
3345     }
3346 
3347     case Branch:
3348         emitBranch(node);
3349         break;
3350 
3351     case Switch:
3352         emitSwitch(node);
3353         break;
3354 
3355     case Return: {
3356         ASSERT(GPRInfo::callFrameRegister != GPRInfo::regT1);
3357         ASSERT(GPRInfo::regT1 != GPRInfo::returnValueGPR);
3358         ASSERT(GPRInfo::returnValueGPR != GPRInfo::callFrameRegister);
3359 
3360         // Return the result in returnValueGPR.
3361         JSValueOperand op1(this, node-&gt;child1());
3362         m_jit.move(op1.gpr(), GPRInfo::returnValueGPR);
3363 
3364         m_jit.emitRestoreCalleeSaves();
3365         m_jit.emitFunctionEpilogue();
3366         m_jit.ret();
3367 
3368         noResult(node);
3369         break;
3370     }
3371 
3372     case Throw: {
3373         compileThrow(node);
3374         break;
3375     }
3376 
3377     case ThrowStaticError: {
3378         compileThrowStaticError(node);
3379         break;
3380     }
3381 
3382     case BooleanToNumber: {
3383         switch (node-&gt;child1().useKind()) {
3384         case BooleanUse: {
3385             JSValueOperand value(this, node-&gt;child1(), ManualOperandSpeculation);
3386             GPRTemporary result(this); // FIXME: We could reuse, but on speculation fail would need recovery to restore tag (akin to add).
3387 
3388             m_jit.move(value.gpr(), result.gpr());
<a name="85" id="anc85"></a><span class="line-modified">3389             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
3390             DFG_TYPE_CHECK(
3391                 JSValueRegs(value.gpr()), node-&gt;child1(), SpecBoolean, m_jit.branchTest64(
3392                     JITCompiler::NonZero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1))));
3393 
3394             int32Result(result.gpr(), node);
3395             break;
3396         }
3397 
3398         case UntypedUse: {
3399             JSValueOperand value(this, node-&gt;child1());
3400             GPRTemporary result(this);
3401 
3402             if (!m_interpreter.needsTypeCheck(node-&gt;child1(), SpecBoolInt32 | SpecBoolean)) {
3403                 m_jit.move(value.gpr(), result.gpr());
3404                 m_jit.and32(TrustedImm32(1), result.gpr());
3405                 int32Result(result.gpr(), node);
3406                 break;
3407             }
3408 
3409             m_jit.move(value.gpr(), result.gpr());
<a name="86" id="anc86"></a><span class="line-modified">3410             m_jit.xor64(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
3411             JITCompiler::Jump isBoolean = m_jit.branchTest64(
3412                 JITCompiler::Zero, result.gpr(), TrustedImm32(static_cast&lt;int32_t&gt;(~1)));
3413             m_jit.move(value.gpr(), result.gpr());
3414             JITCompiler::Jump done = m_jit.jump();
3415             isBoolean.link(&amp;m_jit);
<a name="87" id="anc87"></a><span class="line-modified">3416             m_jit.or64(GPRInfo::numberTagRegister, result.gpr());</span>
3417             done.link(&amp;m_jit);
3418 
3419             jsValueResult(result.gpr(), node);
3420             break;
3421         }
3422 
3423         default:
3424             DFG_CRASH(m_jit.graph(), node, &quot;Bad use kind&quot;);
3425             break;
3426         }
3427         break;
3428     }
3429 
3430     case ToPrimitive: {
3431         compileToPrimitive(node);
3432         break;
3433     }
3434 
<a name="88" id="anc88"></a><span class="line-added">3435     case ToPropertyKey: {</span>
<span class="line-added">3436         compileToPropertyKey(node);</span>
<span class="line-added">3437         break;</span>
<span class="line-added">3438     }</span>
<span class="line-added">3439 </span>
3440     case ToNumber: {
3441         JSValueOperand argument(this, node-&gt;child1());
3442         GPRTemporary result(this, Reuse, argument);
3443 
3444         GPRReg argumentGPR = argument.gpr();
3445         GPRReg resultGPR = result.gpr();
3446 
3447         argument.use();
3448 
3449         // We have several attempts to remove ToNumber. But ToNumber still exists.
3450         // It means that converting non-numbers to numbers by this ToNumber is not rare.
3451         // Instead of the slow path generator, we emit callOperation here.
3452         if (!(m_state.forNode(node-&gt;child1()).m_type &amp; SpecBytecodeNumber)) {
3453             flushRegisters();
<a name="89" id="anc89"></a><span class="line-modified">3454             callOperation(operationToNumber, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentGPR);</span>
3455             m_jit.exceptionCheck();
3456         } else {
3457             MacroAssembler::Jump notNumber = m_jit.branchIfNotNumber(argumentGPR);
3458             m_jit.move(argumentGPR, resultGPR);
3459             MacroAssembler::Jump done = m_jit.jump();
3460 
3461             notNumber.link(&amp;m_jit);
3462             silentSpillAllRegisters(resultGPR);
<a name="90" id="anc90"></a><span class="line-modified">3463             callOperation(operationToNumber, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), argumentGPR);</span>
3464             silentFillAllRegisters();
3465             m_jit.exceptionCheck();
3466 
3467             done.link(&amp;m_jit);
3468         }
3469 
3470         jsValueResult(resultGPR, node, UseChildrenCalledExplicitly);
3471         break;
3472     }
3473 
<a name="91" id="anc91"></a><span class="line-added">3474     case ToNumeric: {</span>
<span class="line-added">3475         compileToNumeric(node);</span>
<span class="line-added">3476         break;</span>
<span class="line-added">3477     }</span>
<span class="line-added">3478 </span>
3479     case ToString:
3480     case CallStringConstructor:
3481     case StringValueOf: {
3482         compileToStringOrCallStringConstructorOrStringValueOf(node);
3483         break;
3484     }
3485 
3486     case NewStringObject: {
3487         compileNewStringObject(node);
3488         break;
3489     }
3490 
3491     case NewSymbol: {
3492         compileNewSymbol(node);
3493         break;
3494     }
3495 
3496     case NewArray: {
3497         compileNewArray(node);
3498         break;
3499     }
3500 
3501     case NewArrayWithSpread: {
3502         compileNewArrayWithSpread(node);
3503         break;
3504     }
3505 
3506     case Spread: {
3507         compileSpread(node);
3508         break;
3509     }
3510 
3511     case NewArrayWithSize: {
3512         compileNewArrayWithSize(node);
3513         break;
3514     }
3515 
3516     case NewArrayBuffer: {
3517         compileNewArrayBuffer(node);
3518         break;
3519     }
3520 
3521     case NewTypedArray: {
3522         compileNewTypedArray(node);
3523         break;
3524     }
3525 
3526     case NewRegexp: {
3527         compileNewRegexp(node);
3528         break;
3529     }
3530 
3531     case ToObject:
3532     case CallObjectConstructor: {
3533         compileToObjectOrCallObjectConstructor(node);
3534         break;
3535     }
3536 
3537     case ToThis: {
3538         compileToThis(node);
3539         break;
3540     }
3541 
3542     case ObjectCreate: {
3543         compileObjectCreate(node);
3544         break;
3545     }
3546 
3547     case ObjectKeys: {
3548         compileObjectKeys(node);
3549         break;
3550     }
3551 
3552     case CreateThis: {
3553         compileCreateThis(node);
3554         break;
3555     }
3556 
<a name="92" id="anc92"></a><span class="line-added">3557     case CreatePromise: {</span>
<span class="line-added">3558         compileCreatePromise(node);</span>
<span class="line-added">3559         break;</span>
<span class="line-added">3560     }</span>
<span class="line-added">3561 </span>
<span class="line-added">3562     case CreateGenerator: {</span>
<span class="line-added">3563         compileCreateGenerator(node);</span>
<span class="line-added">3564         break;</span>
<span class="line-added">3565     }</span>
<span class="line-added">3566 </span>
<span class="line-added">3567     case CreateAsyncGenerator: {</span>
<span class="line-added">3568         compileCreateAsyncGenerator(node);</span>
<span class="line-added">3569         break;</span>
<span class="line-added">3570     }</span>
<span class="line-added">3571 </span>
3572     case NewObject: {
3573         compileNewObject(node);
3574         break;
3575     }
3576 
<a name="93" id="anc93"></a><span class="line-added">3577     case NewPromise: {</span>
<span class="line-added">3578         compileNewPromise(node);</span>
<span class="line-added">3579         break;</span>
<span class="line-added">3580     }</span>
<span class="line-added">3581 </span>
<span class="line-added">3582     case NewGenerator: {</span>
<span class="line-added">3583         compileNewGenerator(node);</span>
<span class="line-added">3584         break;</span>
<span class="line-added">3585     }</span>
<span class="line-added">3586 </span>
<span class="line-added">3587     case NewAsyncGenerator: {</span>
<span class="line-added">3588         compileNewAsyncGenerator(node);</span>
<span class="line-added">3589         break;</span>
<span class="line-added">3590     }</span>
<span class="line-added">3591 </span>
<span class="line-added">3592     case NewArrayIterator: {</span>
<span class="line-added">3593         compileNewArrayIterator(node);</span>
<span class="line-added">3594         break;</span>
<span class="line-added">3595     }</span>
<span class="line-added">3596 </span>
3597     case GetCallee: {
3598         compileGetCallee(node);
3599         break;
3600     }
3601 
3602     case SetCallee: {
3603         compileSetCallee(node);
3604         break;
3605     }
3606 
3607     case GetArgumentCountIncludingThis: {
3608         compileGetArgumentCountIncludingThis(node);
3609         break;
3610     }
3611 
3612     case SetArgumentCountIncludingThis:
3613         compileSetArgumentCountIncludingThis(node);
3614         break;
3615 
3616     case GetRestLength: {
3617         compileGetRestLength(node);
3618         break;
3619     }
3620 
3621     case GetScope:
3622         compileGetScope(node);
3623         break;
3624 
3625     case SkipScope:
3626         compileSkipScope(node);
3627         break;
3628 
3629     case GetGlobalObject:
3630         compileGetGlobalObject(node);
3631         break;
3632 
3633     case GetGlobalThis:
3634         compileGetGlobalThis(node);
3635         break;
3636 
3637     case GetClosureVar: {
3638         compileGetClosureVar(node);
3639         break;
3640     }
3641     case PutClosureVar: {
3642         compilePutClosureVar(node);
3643         break;
3644     }
3645 
<a name="94" id="anc94"></a><span class="line-added">3646     case GetInternalField: {</span>
<span class="line-added">3647         compileGetInternalField(node);</span>
<span class="line-added">3648         break;</span>
<span class="line-added">3649     }</span>
<span class="line-added">3650 </span>
<span class="line-added">3651     case PutInternalField: {</span>
<span class="line-added">3652         compilePutInternalField(node);</span>
<span class="line-added">3653         break;</span>
<span class="line-added">3654     }</span>
<span class="line-added">3655 </span>
3656     case TryGetById: {
<a name="95" id="anc95"></a><span class="line-modified">3657         compileGetById(node, AccessType::TryGetById);</span>
3658         break;
3659     }
3660 
3661     case GetByIdDirect: {
<a name="96" id="anc96"></a><span class="line-modified">3662         compileGetById(node, AccessType::GetByIdDirect);</span>
3663         break;
3664     }
3665 
3666     case GetByIdDirectFlush: {
<a name="97" id="anc97"></a><span class="line-modified">3667         compileGetByIdFlush(node, AccessType::GetByIdDirect);</span>
3668         break;
3669     }
3670 
3671     case GetById: {
<a name="98" id="anc98"></a><span class="line-modified">3672         compileGetById(node, AccessType::GetById);</span>
3673         break;
3674     }
3675 
3676     case GetByIdFlush: {
<a name="99" id="anc99"></a><span class="line-modified">3677         compileGetByIdFlush(node, AccessType::GetById);</span>
3678         break;
3679     }
3680 
3681     case GetByIdWithThis: {
3682         if (node-&gt;child1().useKind() == CellUse &amp;&amp; node-&gt;child2().useKind() == CellUse) {
3683             SpeculateCellOperand base(this, node-&gt;child1());
3684             GPRReg baseGPR = base.gpr();
3685             SpeculateCellOperand thisValue(this, node-&gt;child2());
3686             GPRReg thisValueGPR = thisValue.gpr();
3687 
3688             GPRFlushedCallResult result(this);
3689             GPRReg resultGPR = result.gpr();
3690 
3691             flushRegisters();
3692 
3693             cachedGetByIdWithThis(node-&gt;origin.semantic, baseGPR, thisValueGPR, resultGPR, node-&gt;identifierNumber(), JITCompiler::JumpList());
3694 
3695             jsValueResult(resultGPR, node);
3696 
3697         } else {
3698             JSValueOperand base(this, node-&gt;child1());
3699             GPRReg baseGPR = base.gpr();
3700             JSValueOperand thisValue(this, node-&gt;child2());
3701             GPRReg thisValueGPR = thisValue.gpr();
3702 
3703             GPRFlushedCallResult result(this);
3704             GPRReg resultGPR = result.gpr();
3705 
3706             flushRegisters();
3707 
3708             JITCompiler::JumpList notCellList;
3709             notCellList.append(m_jit.branchIfNotCell(JSValueRegs(baseGPR)));
3710             notCellList.append(m_jit.branchIfNotCell(JSValueRegs(thisValueGPR)));
3711 
3712             cachedGetByIdWithThis(node-&gt;origin.semantic, baseGPR, thisValueGPR, resultGPR, node-&gt;identifierNumber(), notCellList);
3713 
3714             jsValueResult(resultGPR, node);
3715         }
3716 
3717         break;
3718     }
3719 
3720     case GetArrayLength:
3721         compileGetArrayLength(node);
3722         break;
3723 
3724     case DeleteById: {
3725         compileDeleteById(node);
3726         break;
3727     }
3728 
3729     case DeleteByVal: {
3730         compileDeleteByVal(node);
3731         break;
3732     }
3733 
3734     case CheckCell: {
3735         compileCheckCell(node);
3736         break;
3737     }
3738 
3739     case CheckNotEmpty: {
3740         compileCheckNotEmpty(node);
3741         break;
3742     }
3743 
3744     case AssertNotEmpty: {
3745         if (validationEnabled()) {
3746             JSValueOperand operand(this, node-&gt;child1());
3747             GPRReg input = operand.gpr();
3748             auto done = m_jit.branchIfNotEmpty(input);
3749             m_jit.breakpoint();
3750             done.link(&amp;m_jit);
3751         }
3752         noResult(node);
3753         break;
3754     }
3755 
<a name="100" id="anc100"></a><span class="line-modified">3756     case CheckIdent:</span>
<span class="line-modified">3757         compileCheckIdent(node);</span>
3758         break;
3759 
3760     case GetExecutable: {
3761         compileGetExecutable(node);
3762         break;
3763     }
3764 
3765     case CheckStructureOrEmpty: {
3766         SpeculateCellOperand cell(this, node-&gt;child1());
3767         GPRReg cellGPR = cell.gpr();
3768 
3769         GPRReg tempGPR = InvalidGPRReg;
3770         Optional&lt;GPRTemporary&gt; temp;
3771         if (node-&gt;structureSet().size() &gt; 1) {
3772             temp.emplace(this);
3773             tempGPR = temp-&gt;gpr();
3774         }
3775 
3776         MacroAssembler::Jump isEmpty;
3777         if (m_interpreter.forNode(node-&gt;child1()).m_type &amp; SpecEmpty)
3778             isEmpty = m_jit.branchIfEmpty(cellGPR);
3779 
3780         emitStructureCheck(node, cellGPR, tempGPR);
3781 
3782         if (isEmpty.isSet())
3783             isEmpty.link(&amp;m_jit);
3784 
3785         noResult(node);
3786         break;
3787     }
3788 
3789     case CheckStructure: {
3790         compileCheckStructure(node);
3791         break;
3792     }
3793 
3794     case PutStructure: {
3795         RegisteredStructure oldStructure = node-&gt;transition()-&gt;previous;
3796         RegisteredStructure newStructure = node-&gt;transition()-&gt;next;
3797 
3798         m_jit.jitCode()-&gt;common.notifyCompilingStructureTransition(m_jit.graph().m_plan, m_jit.codeBlock(), node);
3799 
3800         SpeculateCellOperand base(this, node-&gt;child1());
3801         GPRReg baseGPR = base.gpr();
3802 
3803         ASSERT_UNUSED(oldStructure, oldStructure-&gt;indexingMode() == newStructure-&gt;indexingMode());
3804         ASSERT(oldStructure-&gt;typeInfo().type() == newStructure-&gt;typeInfo().type());
3805         ASSERT(oldStructure-&gt;typeInfo().inlineTypeFlags() == newStructure-&gt;typeInfo().inlineTypeFlags());
3806         m_jit.store32(MacroAssembler::TrustedImm32(newStructure-&gt;id()), MacroAssembler::Address(baseGPR, JSCell::structureIDOffset()));
3807 
3808         noResult(node);
3809         break;
3810     }
3811 
3812     case AllocatePropertyStorage:
3813         compileAllocatePropertyStorage(node);
3814         break;
3815 
3816     case ReallocatePropertyStorage:
3817         compileReallocatePropertyStorage(node);
3818         break;
3819 
3820     case NukeStructureAndSetButterfly:
3821         compileNukeStructureAndSetButterfly(node);
3822         break;
3823 
3824     case GetButterfly:
3825         compileGetButterfly(node);
3826         break;
3827 
3828     case GetIndexedPropertyStorage: {
3829         compileGetIndexedPropertyStorage(node);
3830         break;
3831     }
3832 
3833     case ConstantStoragePointer: {
3834         compileConstantStoragePointer(node);
3835         break;
3836     }
3837 
3838     case GetTypedArrayByteOffset: {
3839         compileGetTypedArrayByteOffset(node);
3840         break;
3841     }
3842 
3843     case GetPrototypeOf: {
3844         compileGetPrototypeOf(node);
3845         break;
3846     }
3847 
3848     case GetByOffset:
3849     case GetGetterSetterByOffset: {
3850         compileGetByOffset(node);
3851         break;
3852     }
3853 
3854     case MatchStructure: {
3855         compileMatchStructure(node);
3856         break;
3857     }
3858 
3859     case GetGetter: {
3860         compileGetGetter(node);
3861         break;
3862     }
3863 
3864     case GetSetter: {
3865         compileGetSetter(node);
3866         break;
3867     }
3868 
3869     case PutByOffset: {
3870         compilePutByOffset(node);
3871         break;
3872     }
3873 
3874     case PutByIdFlush: {
3875         compilePutByIdFlush(node);
3876         break;
3877     }
3878 
3879     case PutById: {
3880         compilePutById(node);
3881         break;
3882     }
3883 
3884     case PutByIdWithThis: {
3885         compilePutByIdWithThis(node);
3886         break;
3887     }
3888 
3889     case PutByValWithThis: {
3890         JSValueOperand base(this, m_jit.graph().varArgChild(node, 0));
3891         GPRReg baseGPR = base.gpr();
3892         JSValueOperand thisValue(this, m_jit.graph().varArgChild(node, 1));
3893         GPRReg thisValueGPR = thisValue.gpr();
3894         JSValueOperand property(this, m_jit.graph().varArgChild(node, 2));
3895         GPRReg propertyGPR = property.gpr();
3896         JSValueOperand value(this, m_jit.graph().varArgChild(node, 3));
3897         GPRReg valueGPR = value.gpr();
3898 
3899         flushRegisters();
<a name="101" id="anc101"></a><span class="line-modified">3900         callOperation(m_jit.isStrictModeFor(node-&gt;origin.semantic) ? operationPutByValWithThisStrict : operationPutByValWithThis, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), baseGPR, thisValueGPR, propertyGPR, valueGPR);</span>
3901         m_jit.exceptionCheck();
3902 
3903         noResult(node);
3904         break;
3905     }
3906 
3907     case PutByIdDirect: {
3908         compilePutByIdDirect(node);
3909         break;
3910     }
3911 
3912     case PutGetterById:
3913     case PutSetterById: {
3914         compilePutAccessorById(node);
3915         break;
3916     }
3917 
3918     case PutGetterSetterById: {
3919         compilePutGetterSetterById(node);
3920         break;
3921     }
3922 
3923     case PutGetterByVal:
3924     case PutSetterByVal: {
3925         compilePutAccessorByVal(node);
3926         break;
3927     }
3928 
3929     case DefineDataProperty: {
3930         compileDefineDataProperty(node);
3931         break;
3932     }
3933 
3934     case DefineAccessorProperty: {
3935         compileDefineAccessorProperty(node);
3936         break;
3937     }
3938 
3939     case GetGlobalLexicalVariable:
3940     case GetGlobalVar: {
3941         compileGetGlobalVariable(node);
3942         break;
3943     }
3944 
3945     case PutGlobalVariable: {
3946         compilePutGlobalVariable(node);
3947         break;
3948     }
3949 
3950     case PutDynamicVar: {
3951         compilePutDynamicVar(node);
3952         break;
3953     }
3954 
3955     case GetDynamicVar: {
3956         compileGetDynamicVar(node);
3957         break;
3958     }
3959 
3960     case ResolveScopeForHoistingFuncDeclInEval: {
3961         compileResolveScopeForHoistingFuncDeclInEval(node);
3962         break;
3963     }
3964 
3965     case ResolveScope: {
3966         compileResolveScope(node);
3967         break;
3968     }
3969 
3970     case NotifyWrite: {
3971         compileNotifyWrite(node);
3972         break;
3973     }
3974 
3975     case CheckTypeInfoFlags: {
3976         compileCheckTypeInfoFlags(node);
3977         break;
3978     }
3979 
3980     case ParseInt: {
3981         compileParseInt(node);
3982         break;
3983     }
3984 
3985     case OverridesHasInstance: {
3986         compileOverridesHasInstance(node);
3987         break;
3988     }
3989 
3990     case InstanceOf: {
3991         compileInstanceOf(node);
3992         break;
3993     }
3994 
3995     case InstanceOfCustom: {
3996         compileInstanceOfCustom(node);
3997         break;
3998     }
3999 
4000     case IsEmpty: {
4001         JSValueOperand value(this, node-&gt;child1());
4002         GPRTemporary result(this, Reuse, value);
4003 
4004         m_jit.comparePtr(JITCompiler::Equal, value.gpr(), TrustedImm32(JSValue::encode(JSValue())), result.gpr());
<a name="102" id="anc102"></a><span class="line-modified">4005         m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
4006 
4007         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
4008         break;
4009     }
4010 
4011     case IsUndefined: {
4012         JSValueOperand value(this, node-&gt;child1());
4013         GPRTemporary result(this);
4014         GPRTemporary localGlobalObject(this);
4015         GPRTemporary remoteGlobalObject(this);
4016         GPRTemporary scratch(this);
4017 
4018         JITCompiler::Jump isCell = m_jit.branchIfCell(value.jsValueRegs());
4019 
<a name="103" id="anc103"></a><span class="line-modified">4020         m_jit.compare64(JITCompiler::Equal, value.gpr(), TrustedImm32(JSValue::ValueUndefined), result.gpr());</span>
4021         JITCompiler::Jump done = m_jit.jump();
4022 
4023         isCell.link(&amp;m_jit);
4024         JITCompiler::Jump notMasqueradesAsUndefined;
4025         if (masqueradesAsUndefinedWatchpointIsStillValid()) {
4026             m_jit.move(TrustedImm32(0), result.gpr());
4027             notMasqueradesAsUndefined = m_jit.jump();
4028         } else {
4029             JITCompiler::Jump isMasqueradesAsUndefined = m_jit.branchTest8(
4030                 JITCompiler::NonZero,
4031                 JITCompiler::Address(value.gpr(), JSCell::typeInfoFlagsOffset()),
4032                 TrustedImm32(MasqueradesAsUndefined));
4033             m_jit.move(TrustedImm32(0), result.gpr());
4034             notMasqueradesAsUndefined = m_jit.jump();
4035 
4036             isMasqueradesAsUndefined.link(&amp;m_jit);
4037             GPRReg localGlobalObjectGPR = localGlobalObject.gpr();
4038             GPRReg remoteGlobalObjectGPR = remoteGlobalObject.gpr();
4039             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), m_jit.globalObjectFor(node-&gt;origin.semantic)), localGlobalObjectGPR);
4040             m_jit.emitLoadStructure(vm(), value.gpr(), result.gpr(), scratch.gpr());
4041             m_jit.loadPtr(JITCompiler::Address(result.gpr(), Structure::globalObjectOffset()), remoteGlobalObjectGPR);
4042             m_jit.comparePtr(JITCompiler::Equal, localGlobalObjectGPR, remoteGlobalObjectGPR, result.gpr());
4043         }
4044 
4045         notMasqueradesAsUndefined.link(&amp;m_jit);
4046         done.link(&amp;m_jit);
<a name="104" id="anc104"></a><span class="line-modified">4047         m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
4048         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
4049         break;
4050     }
4051 
4052     case IsUndefinedOrNull: {
4053         JSValueOperand value(this, node-&gt;child1());
4054         GPRTemporary result(this, Reuse, value);
4055 
4056         GPRReg valueGPR = value.gpr();
4057         GPRReg resultGPR = result.gpr();
4058 
4059         m_jit.move(valueGPR, resultGPR);
<a name="105" id="anc105"></a><span class="line-modified">4060         m_jit.and64(CCallHelpers::TrustedImm32(~JSValue::UndefinedTag), resultGPR);</span>
<span class="line-modified">4061         m_jit.compare64(CCallHelpers::Equal, resultGPR, CCallHelpers::TrustedImm32(JSValue::ValueNull), resultGPR);</span>
4062 
4063         unblessedBooleanResult(resultGPR, node);
4064         break;
4065     }
4066 
4067     case IsBoolean: {
4068         JSValueOperand value(this, node-&gt;child1());
4069         GPRTemporary result(this, Reuse, value);
4070 
4071         m_jit.move(value.gpr(), result.gpr());
<a name="106" id="anc106"></a><span class="line-modified">4072         m_jit.xor64(JITCompiler::TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
4073         m_jit.test64(JITCompiler::Zero, result.gpr(), JITCompiler::TrustedImm32(static_cast&lt;int32_t&gt;(~1)), result.gpr());
<a name="107" id="anc107"></a><span class="line-modified">4074         m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
4075         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
4076         break;
4077     }
4078 
4079     case IsNumber: {
4080         JSValueOperand value(this, node-&gt;child1());
4081         GPRTemporary result(this, Reuse, value);
4082 
<a name="108" id="anc108"></a><span class="line-modified">4083         m_jit.test64(JITCompiler::NonZero, value.gpr(), GPRInfo::numberTagRegister, result.gpr());</span>
<span class="line-modified">4084         m_jit.or32(TrustedImm32(JSValue::ValueFalse), result.gpr());</span>
4085         jsValueResult(result.gpr(), node, DataFormatJSBoolean);
4086         break;
4087     }
4088 
4089     case NumberIsInteger: {
4090         JSValueOperand value(this, node-&gt;child1());
4091         GPRTemporary result(this, Reuse, value);
4092 
4093         FPRTemporary temp1(this);
4094         FPRTemporary temp2(this);
4095 
4096         JSValueRegs valueRegs = JSValueRegs(value.gpr());
4097         GPRReg resultGPR = result.gpr();
4098 
4099         FPRReg tempFPR1 = temp1.fpr();
4100         FPRReg tempFPR2 = temp2.fpr();
4101 
4102         MacroAssembler::JumpList done;
4103 
4104         auto isInt32 = m_jit.branchIfInt32(valueRegs);
4105         auto notNumber = m_jit.branchIfNotDoubleKnownNotInt32(valueRegs);
4106 
4107         // We&#39;re a double here.
4108         m_jit.unboxDouble(valueRegs.gpr(), resultGPR, tempFPR1);
4109         m_jit.urshift64(TrustedImm32(52), resultGPR);
4110         m_jit.and32(TrustedImm32(0x7ff), resultGPR);
4111         auto notNanNorInfinity = m_jit.branch32(JITCompiler::NotEqual, TrustedImm32(0x7ff), resultGPR);
<a name="109" id="anc109"></a><span class="line-modified">4112         m_jit.move(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
4113         done.append(m_jit.jump());
4114 
4115         notNanNorInfinity.link(&amp;m_jit);
4116         m_jit.roundTowardZeroDouble(tempFPR1, tempFPR2);
4117         m_jit.compareDouble(JITCompiler::DoubleEqual, tempFPR1, tempFPR2, resultGPR);
<a name="110" id="anc110"></a><span class="line-modified">4118         m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
4119         done.append(m_jit.jump());
4120 
4121         isInt32.link(&amp;m_jit);
<a name="111" id="anc111"></a><span class="line-modified">4122         m_jit.move(TrustedImm32(JSValue::ValueTrue), resultGPR);</span>
4123         done.append(m_jit.jump());
4124 
4125         notNumber.link(&amp;m_jit);
<a name="112" id="anc112"></a><span class="line-modified">4126         m_jit.move(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
4127 
4128         done.link(&amp;m_jit);
4129         jsValueResult(resultGPR, node, DataFormatJSBoolean);
4130         break;
4131     }
4132 
4133     case MapHash: {
4134         switch (node-&gt;child1().useKind()) {
4135         case BooleanUse:
4136         case Int32Use:
4137         case SymbolUse:
4138         case ObjectUse: {
4139             JSValueOperand input(this, node-&gt;child1(), ManualOperandSpeculation);
4140             GPRTemporary result(this, Reuse, input);
4141             GPRTemporary temp(this);
4142 
4143             GPRReg inputGPR = input.gpr();
4144             GPRReg resultGPR = result.gpr();
4145             GPRReg tempGPR = temp.gpr();
4146 
4147             speculate(node, node-&gt;child1());
4148 
4149             m_jit.move(inputGPR, resultGPR);
4150             m_jit.wangsInt64Hash(resultGPR, tempGPR);
4151             int32Result(resultGPR, node);
4152             break;
4153         }
4154         case CellUse:
4155         case StringUse: {
4156             SpeculateCellOperand input(this, node-&gt;child1());
4157             GPRTemporary result(this);
4158             Optional&lt;GPRTemporary&gt; temp;
4159 
4160             GPRReg tempGPR = InvalidGPRReg;
4161             if (node-&gt;child1().useKind() == CellUse) {
4162                 temp.emplace(this);
4163                 tempGPR = temp-&gt;gpr();
4164             }
4165 
4166             GPRReg inputGPR = input.gpr();
4167             GPRReg resultGPR = result.gpr();
4168 
4169             MacroAssembler::JumpList slowPath;
4170             MacroAssembler::JumpList done;
4171 
4172             if (node-&gt;child1().useKind() == StringUse)
4173                 speculateString(node-&gt;child1(), inputGPR);
4174             else {
4175                 auto isString = m_jit.branchIfString(inputGPR);
4176                 m_jit.move(inputGPR, resultGPR);
4177                 m_jit.wangsInt64Hash(resultGPR, tempGPR);
4178                 done.append(m_jit.jump());
4179                 isString.link(&amp;m_jit);
4180             }
4181 
4182             m_jit.loadPtr(MacroAssembler::Address(inputGPR, JSString::offsetOfValue()), resultGPR);
4183             slowPath.append(m_jit.branchIfRopeStringImpl(resultGPR));
4184             m_jit.load32(MacroAssembler::Address(resultGPR, StringImpl::flagsOffset()), resultGPR);
4185             m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), resultGPR);
4186             slowPath.append(m_jit.branchTest32(MacroAssembler::Zero, resultGPR));
4187             done.append(m_jit.jump());
4188 
4189             slowPath.link(&amp;m_jit);
4190             silentSpillAllRegisters(resultGPR);
<a name="113" id="anc113"></a><span class="line-modified">4191             callOperation(operationMapHash, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), JSValueRegs(inputGPR));</span>
4192             silentFillAllRegisters();
4193             m_jit.exceptionCheck();
4194 
4195             done.link(&amp;m_jit);
4196             int32Result(resultGPR, node);
4197             break;
4198         }
4199         default:
4200             RELEASE_ASSERT(node-&gt;child1().useKind() == UntypedUse);
4201             break;
4202         }
4203 
4204         if (node-&gt;child1().useKind() != UntypedUse)
4205             break;
4206 
4207         JSValueOperand input(this, node-&gt;child1());
4208         GPRTemporary temp(this);
4209         GPRTemporary result(this);
4210 
4211         GPRReg inputGPR = input.gpr();
4212         GPRReg resultGPR = result.gpr();
4213         GPRReg tempGPR = temp.gpr();
4214 
4215         MacroAssembler::JumpList straightHash;
4216         MacroAssembler::JumpList done;
4217         straightHash.append(m_jit.branchIfNotCell(inputGPR));
4218         MacroAssembler::JumpList slowPath;
4219         straightHash.append(m_jit.branchIfNotString(inputGPR));
4220         m_jit.loadPtr(MacroAssembler::Address(inputGPR, JSString::offsetOfValue()), resultGPR);
4221         slowPath.append(m_jit.branchIfRopeStringImpl(resultGPR));
4222         m_jit.load32(MacroAssembler::Address(resultGPR, StringImpl::flagsOffset()), resultGPR);
4223         m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), resultGPR);
4224         slowPath.append(m_jit.branchTest32(MacroAssembler::Zero, resultGPR));
4225         done.append(m_jit.jump());
4226 
4227         straightHash.link(&amp;m_jit);
4228         m_jit.move(inputGPR, resultGPR);
4229         m_jit.wangsInt64Hash(resultGPR, tempGPR);
4230         done.append(m_jit.jump());
4231 
4232         slowPath.link(&amp;m_jit);
4233         silentSpillAllRegisters(resultGPR);
<a name="114" id="anc114"></a><span class="line-modified">4234         callOperation(operationMapHash, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), JSValueRegs(inputGPR));</span>
4235         silentFillAllRegisters();
4236         m_jit.exceptionCheck();
4237 
4238         done.link(&amp;m_jit);
4239         int32Result(resultGPR, node);
4240         break;
4241     }
4242 
4243     case NormalizeMapKey: {
4244         compileNormalizeMapKey(node);
4245         break;
4246     }
4247 
4248     case GetMapBucket: {
4249         SpeculateCellOperand map(this, node-&gt;child1());
4250         JSValueOperand key(this, node-&gt;child2(), ManualOperandSpeculation);
4251         SpeculateInt32Operand hash(this, node-&gt;child3());
4252         GPRTemporary mask(this);
4253         GPRTemporary index(this);
4254         GPRTemporary buffer(this);
4255         GPRTemporary bucket(this);
4256         GPRTemporary result(this);
4257 
4258         GPRReg hashGPR = hash.gpr();
4259         GPRReg mapGPR = map.gpr();
4260         GPRReg maskGPR = mask.gpr();
4261         GPRReg indexGPR = index.gpr();
4262         GPRReg bufferGPR = buffer.gpr();
4263         GPRReg bucketGPR = bucket.gpr();
4264         GPRReg keyGPR = key.gpr();
4265         GPRReg resultGPR = result.gpr();
4266 
4267         if (node-&gt;child1().useKind() == MapObjectUse)
4268             speculateMapObject(node-&gt;child1(), mapGPR);
4269         else if (node-&gt;child1().useKind() == SetObjectUse)
4270             speculateSetObject(node-&gt;child1(), mapGPR);
4271         else
4272             RELEASE_ASSERT_NOT_REACHED();
4273 
4274         if (node-&gt;child2().useKind() != UntypedUse)
4275             speculate(node, node-&gt;child2());
4276 
4277         m_jit.load32(MacroAssembler::Address(mapGPR, HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfCapacity()), maskGPR);
4278         m_jit.loadPtr(MacroAssembler::Address(mapGPR, HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::offsetOfBuffer()), bufferGPR);
4279         m_jit.sub32(TrustedImm32(1), maskGPR);
4280         m_jit.move(hashGPR, indexGPR);
4281 
4282         MacroAssembler::Label loop = m_jit.label();
4283         MacroAssembler::JumpList done;
4284         MacroAssembler::JumpList slowPathCases;
4285         MacroAssembler::JumpList loopAround;
4286 
4287         m_jit.and32(maskGPR, indexGPR);
4288         m_jit.loadPtr(MacroAssembler::BaseIndex(bufferGPR, indexGPR, MacroAssembler::TimesEight), bucketGPR);
4289         m_jit.move(bucketGPR, resultGPR);
4290         auto notPresentInTable = m_jit.branchPtr(MacroAssembler::Equal,
4291             bucketGPR, TrustedImmPtr(bitwise_cast&lt;size_t&gt;(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::emptyValue())));
4292         loopAround.append(m_jit.branchPtr(MacroAssembler::Equal,
4293             bucketGPR, TrustedImmPtr(bitwise_cast&lt;size_t&gt;(HashMapImpl&lt;HashMapBucket&lt;HashMapBucketDataKey&gt;&gt;::deletedValue()))));
4294 
4295         m_jit.load64(MacroAssembler::Address(bucketGPR, HashMapBucket&lt;HashMapBucketDataKey&gt;::offsetOfKey()), bucketGPR);
4296 
4297         // Perform Object.is()
4298         switch (node-&gt;child2().useKind()) {
4299         case BooleanUse:
4300         case Int32Use:
4301         case SymbolUse:
4302         case ObjectUse: {
4303             done.append(m_jit.branch64(MacroAssembler::Equal, bucketGPR, keyGPR)); // They&#39;re definitely the same value, we found the bucket we were looking for!
4304             // Otherwise, loop around.
4305             break;
4306         }
4307         case CellUse: {
4308             done.append(m_jit.branch64(MacroAssembler::Equal, bucketGPR, keyGPR));
4309             loopAround.append(m_jit.branchIfNotCell(JSValueRegs(bucketGPR)));
4310             loopAround.append(m_jit.branchIfNotString(bucketGPR));
4311             loopAround.append(m_jit.branchIfNotString(keyGPR));
4312             // They&#39;re both strings.
4313             slowPathCases.append(m_jit.jump());
4314             break;
4315         }
4316         case StringUse: {
4317             done.append(m_jit.branch64(MacroAssembler::Equal, bucketGPR, keyGPR)); // They&#39;re definitely the same value, we found the bucket we were looking for!
4318             loopAround.append(m_jit.branchIfNotCell(JSValueRegs(bucketGPR)));
4319             loopAround.append(m_jit.branchIfNotString(bucketGPR));
4320             slowPathCases.append(m_jit.jump());
4321             break;
4322         }
4323         case UntypedUse: {
4324             done.append(m_jit.branch64(MacroAssembler::Equal, bucketGPR, keyGPR)); // They&#39;re definitely the same value, we found the bucket we were looking for!
4325             // The input key and bucket&#39;s key are already normalized. So if 64-bit compare fails and one is not a cell, they&#39;re definitely not equal.
4326             loopAround.append(m_jit.branchIfNotCell(JSValueRegs(bucketGPR)));
4327             // first is a cell here.
4328             loopAround.append(m_jit.branchIfNotCell(JSValueRegs(keyGPR)));
4329             // Both are cells here.
4330             loopAround.append(m_jit.branchIfNotString(bucketGPR));
4331             // The first is a string here.
4332             slowPathCases.append(m_jit.branchIfString(keyGPR));
4333             // The first is a string, but the second is not, we continue to loop around.
4334             loopAround.append(m_jit.jump());
4335             break;
4336         }
4337         default:
4338             RELEASE_ASSERT_NOT_REACHED();
4339         }
4340 
4341 
4342         if (!loopAround.empty())
4343             loopAround.link(&amp;m_jit);
4344 
4345         m_jit.add32(TrustedImm32(1), indexGPR);
4346         m_jit.jump().linkTo(loop, &amp;m_jit);
4347 
4348         if (!slowPathCases.empty()) {
4349             slowPathCases.link(&amp;m_jit);
4350             silentSpillAllRegisters(indexGPR);
4351             if (node-&gt;child1().useKind() == MapObjectUse)
<a name="115" id="anc115"></a><span class="line-modified">4352                 callOperation(operationJSMapFindBucket, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), mapGPR, keyGPR, hashGPR);</span>
4353             else
<a name="116" id="anc116"></a><span class="line-modified">4354                 callOperation(operationJSSetFindBucket, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), mapGPR, keyGPR, hashGPR);</span>
4355             silentFillAllRegisters();
4356             m_jit.exceptionCheck();
4357             done.append(m_jit.jump());
4358         }
4359 
4360         notPresentInTable.link(&amp;m_jit);
4361         if (node-&gt;child1().useKind() == MapObjectUse)
4362             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), vm().sentinelMapBucket()), resultGPR);
4363         else
4364             m_jit.move(TrustedImmPtr::weakPointer(m_jit.graph(), vm().sentinelSetBucket()), resultGPR);
4365         done.link(&amp;m_jit);
4366         cellResult(resultGPR, node);
4367         break;
4368     }
4369 
4370     case GetMapBucketHead:
4371         compileGetMapBucketHead(node);
4372         break;
4373 
4374     case GetMapBucketNext:
4375         compileGetMapBucketNext(node);
4376         break;
4377 
4378     case LoadKeyFromMapBucket:
4379         compileLoadKeyFromMapBucket(node);
4380         break;
4381 
4382     case LoadValueFromMapBucket:
4383         compileLoadValueFromMapBucket(node);
4384         break;
4385 
4386     case ExtractValueFromWeakMapGet:
4387         compileExtractValueFromWeakMapGet(node);
4388         break;
4389 
4390     case SetAdd:
4391         compileSetAdd(node);
4392         break;
4393 
4394     case MapSet:
4395         compileMapSet(node);
4396         break;
4397 
4398     case WeakMapGet:
4399         compileWeakMapGet(node);
4400         break;
4401 
4402     case WeakSetAdd:
4403         compileWeakSetAdd(node);
4404         break;
4405 
4406     case WeakMapSet:
4407         compileWeakMapSet(node);
4408         break;
4409 
4410     case StringSlice: {
4411         compileStringSlice(node);
4412         break;
4413     }
4414 
4415     case ToLowerCase: {
4416         compileToLowerCase(node);
4417         break;
4418     }
4419 
4420     case NumberToStringWithRadix: {
4421         compileNumberToStringWithRadix(node);
4422         break;
4423     }
4424 
4425     case NumberToStringWithValidRadixConstant: {
4426         compileNumberToStringWithValidRadixConstant(node);
4427         break;
4428     }
4429 
4430     case IsObject: {
4431         compileIsObject(node);
4432         break;
4433     }
4434 
4435     case IsObjectOrNull: {
4436         compileIsObjectOrNull(node);
4437         break;
4438     }
4439 
4440     case IsFunction: {
4441         compileIsFunction(node);
4442         break;
4443     }
4444 
4445     case IsCellWithType: {
4446         compileIsCellWithType(node);
4447         break;
4448     }
4449 
4450     case IsTypedArrayView: {
4451         compileIsTypedArrayView(node);
4452         break;
4453     }
4454 
4455     case TypeOf: {
4456         compileTypeOf(node);
4457         break;
4458     }
4459 
4460     case Flush:
4461         break;
4462 
4463     case Call:
4464     case TailCall:
4465     case TailCallInlinedCaller:
4466     case Construct:
4467     case CallVarargs:
4468     case TailCallVarargs:
4469     case TailCallVarargsInlinedCaller:
4470     case CallForwardVarargs:
4471     case ConstructVarargs:
4472     case ConstructForwardVarargs:
4473     case TailCallForwardVarargs:
4474     case TailCallForwardVarargsInlinedCaller:
4475     case CallEval:
4476     case DirectCall:
4477     case DirectConstruct:
4478     case DirectTailCall:
4479     case DirectTailCallInlinedCaller:
4480         emitCall(node);
4481         break;
4482 
<a name="117" id="anc117"></a><span class="line-added">4483     case VarargsLength: {</span>
<span class="line-added">4484         compileVarargsLength(node);</span>
<span class="line-added">4485         break;</span>
<span class="line-added">4486     }</span>
<span class="line-added">4487 </span>
4488     case LoadVarargs: {
4489         compileLoadVarargs(node);
4490         break;
4491     }
4492 
4493     case ForwardVarargs: {
4494         compileForwardVarargs(node);
4495         break;
4496     }
4497 
4498     case CreateActivation: {
4499         compileCreateActivation(node);
4500         break;
4501     }
4502 
4503     case PushWithScope: {
4504         compilePushWithScope(node);
4505         break;
4506     }
4507 
4508     case CreateDirectArguments: {
4509         compileCreateDirectArguments(node);
4510         break;
4511     }
4512 
4513     case GetFromArguments: {
4514         compileGetFromArguments(node);
4515         break;
4516     }
4517 
4518     case PutToArguments: {
4519         compilePutToArguments(node);
4520         break;
4521     }
4522 
4523     case GetArgument: {
4524         compileGetArgument(node);
4525         break;
4526     }
4527 
4528     case CreateScopedArguments: {
4529         compileCreateScopedArguments(node);
4530         break;
4531     }
4532 
4533     case CreateClonedArguments: {
4534         compileCreateClonedArguments(node);
4535         break;
4536     }
<a name="118" id="anc118"></a><span class="line-added">4537 </span>
<span class="line-added">4538     case CreateArgumentsButterfly: {</span>
<span class="line-added">4539         compileCreateArgumentsButterfly(node);</span>
<span class="line-added">4540         break;</span>
<span class="line-added">4541     }</span>
<span class="line-added">4542 </span>
4543     case CreateRest: {
4544         compileCreateRest(node);
4545         break;
4546     }
4547 
4548     case NewFunction:
4549     case NewGeneratorFunction:
4550     case NewAsyncGeneratorFunction:
4551     case NewAsyncFunction:
4552         compileNewFunction(node);
4553         break;
4554 
4555     case SetFunctionName:
4556         compileSetFunctionName(node);
4557         break;
4558 
4559     case InById:
4560         compileInById(node);
4561         break;
4562 
4563     case InByVal:
4564         compileInByVal(node);
4565         break;
4566 
4567     case HasOwnProperty: {
4568         SpeculateCellOperand object(this, node-&gt;child1());
4569         GPRTemporary uniquedStringImpl(this);
4570         GPRTemporary temp(this);
4571         GPRTemporary hash(this);
4572         GPRTemporary structureID(this);
4573         GPRTemporary result(this);
4574 
4575         Optional&lt;SpeculateCellOperand&gt; keyAsCell;
4576         Optional&lt;JSValueOperand&gt; keyAsValue;
4577         GPRReg keyGPR;
4578         if (node-&gt;child2().useKind() == UntypedUse) {
4579             keyAsValue.emplace(this, node-&gt;child2());
4580             keyGPR = keyAsValue-&gt;gpr();
4581         } else {
4582             ASSERT(node-&gt;child2().useKind() == StringUse || node-&gt;child2().useKind() == SymbolUse);
4583             keyAsCell.emplace(this, node-&gt;child2());
4584             keyGPR = keyAsCell-&gt;gpr();
4585         }
4586 
4587         GPRReg objectGPR = object.gpr();
4588         GPRReg implGPR = uniquedStringImpl.gpr();
4589         GPRReg tempGPR = temp.gpr();
4590         GPRReg hashGPR = hash.gpr();
4591         GPRReg structureIDGPR = structureID.gpr();
4592         GPRReg resultGPR = result.gpr();
4593 
4594         speculateObject(node-&gt;child1());
4595 
4596         MacroAssembler::JumpList slowPath;
4597         switch (node-&gt;child2().useKind()) {
4598         case SymbolUse: {
4599             speculateSymbol(node-&gt;child2(), keyGPR);
4600             m_jit.loadPtr(MacroAssembler::Address(keyGPR, Symbol::offsetOfSymbolImpl()), implGPR);
4601             break;
4602         }
4603         case StringUse: {
4604             speculateString(node-&gt;child2(), keyGPR);
4605             m_jit.loadPtr(MacroAssembler::Address(keyGPR, JSString::offsetOfValue()), implGPR);
4606             slowPath.append(m_jit.branchIfRopeStringImpl(implGPR));
4607             slowPath.append(m_jit.branchTest32(
4608                 MacroAssembler::Zero, MacroAssembler::Address(implGPR, StringImpl::flagsOffset()),
4609                 MacroAssembler::TrustedImm32(StringImpl::flagIsAtom())));
4610             break;
4611         }
4612         case UntypedUse: {
4613             slowPath.append(m_jit.branchIfNotCell(JSValueRegs(keyGPR)));
4614             auto isNotString = m_jit.branchIfNotString(keyGPR);
4615             m_jit.loadPtr(MacroAssembler::Address(keyGPR, JSString::offsetOfValue()), implGPR);
4616             slowPath.append(m_jit.branchIfRopeStringImpl(implGPR));
4617             slowPath.append(m_jit.branchTest32(
4618                 MacroAssembler::Zero, MacroAssembler::Address(implGPR, StringImpl::flagsOffset()),
4619                 MacroAssembler::TrustedImm32(StringImpl::flagIsAtom())));
4620             auto hasUniquedImpl = m_jit.jump();
4621 
4622             isNotString.link(&amp;m_jit);
4623             slowPath.append(m_jit.branchIfNotSymbol(keyGPR));
4624             m_jit.loadPtr(MacroAssembler::Address(keyGPR, Symbol::offsetOfSymbolImpl()), implGPR);
4625 
4626             hasUniquedImpl.link(&amp;m_jit);
4627             break;
4628         }
4629         default:
4630             RELEASE_ASSERT_NOT_REACHED();
4631         }
4632 
4633         // Note that we don&#39;t test if the hash is zero here. AtomStringImpl&#39;s can&#39;t have a zero
4634         // hash, however, a SymbolImpl may. But, because this is a cache, we don&#39;t care. We only
4635         // ever load the result from the cache if the cache entry matches what we are querying for.
4636         // So we either get super lucky and use zero for the hash and somehow collide with the entity
4637         // we&#39;re looking for, or we realize we&#39;re comparing against another entity, and go to the
4638         // slow path anyways.
4639         m_jit.load32(MacroAssembler::Address(implGPR, UniquedStringImpl::flagsOffset()), hashGPR);
4640         m_jit.urshift32(MacroAssembler::TrustedImm32(StringImpl::s_flagCount), hashGPR);
4641         m_jit.load32(MacroAssembler::Address(objectGPR, JSCell::structureIDOffset()), structureIDGPR);
4642         m_jit.add32(structureIDGPR, hashGPR);
4643         m_jit.and32(TrustedImm32(HasOwnPropertyCache::mask), hashGPR);
4644         if (hasOneBitSet(sizeof(HasOwnPropertyCache::Entry))) // is a power of 2
4645             m_jit.lshift32(TrustedImm32(getLSBSet(sizeof(HasOwnPropertyCache::Entry))), hashGPR);
4646         else
4647             m_jit.mul32(TrustedImm32(sizeof(HasOwnPropertyCache::Entry)), hashGPR, hashGPR);
4648         ASSERT(vm().hasOwnPropertyCache());
4649         m_jit.move(TrustedImmPtr(vm().hasOwnPropertyCache()), tempGPR);
4650         slowPath.append(m_jit.branchPtr(MacroAssembler::NotEqual,
4651             MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfImpl()), implGPR));
4652         m_jit.load8(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfResult()), resultGPR);
4653         m_jit.load32(MacroAssembler::BaseIndex(tempGPR, hashGPR, MacroAssembler::TimesOne, HasOwnPropertyCache::Entry::offsetOfStructureID()), tempGPR);
4654         slowPath.append(m_jit.branch32(MacroAssembler::NotEqual, tempGPR, structureIDGPR));
4655         auto done = m_jit.jump();
4656 
4657         slowPath.link(&amp;m_jit);
4658         silentSpillAllRegisters(resultGPR);
<a name="119" id="anc119"></a><span class="line-modified">4659         callOperation(operationHasOwnProperty, resultGPR, TrustedImmPtr::weakPointer(m_graph, m_graph.globalObjectFor(node-&gt;origin.semantic)), objectGPR, keyGPR);</span>
4660         silentFillAllRegisters();
4661         m_jit.exceptionCheck();
4662 
4663         done.link(&amp;m_jit);
<a name="120" id="anc120"></a><span class="line-modified">4664         m_jit.or32(TrustedImm32(JSValue::ValueFalse), resultGPR);</span>
4665         jsValueResult(resultGPR, node, DataFormatJSBoolean);
4666         break;
4667     }
4668 
4669     case CountExecution:
4670         m_jit.add64(TrustedImm32(1), MacroAssembler::AbsoluteAddress(node-&gt;executionCounter()-&gt;address()));
4671         break;
4672 
4673     case SuperSamplerBegin:
4674         m_jit.add32(TrustedImm32(1), MacroAssembler::AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
4675         break;
4676 
4677     case SuperSamplerEnd:
4678         m_jit.sub32(TrustedImm32(1), MacroAssembler::AbsoluteAddress(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount)));
4679         break;
4680 
4681     case ForceOSRExit: {
4682         terminateSpeculativeExecution(InadequateCoverage, JSValueRegs(), 0);
4683         break;
4684     }
4685 
4686     case InvalidationPoint:
4687         emitInvalidationPoint(node);
4688         break;
4689 
4690     case CheckTraps:
4691         compileCheckTraps(node);
4692         break;
4693 
4694     case Phantom:
4695     case Check:
4696     case CheckVarargs:
4697         DFG_NODE_DO_TO_CHILDREN(m_jit.graph(), node, speculate);
4698         noResult(node);
4699         break;
4700 
4701     case PhantomLocal:
4702     case LoopHint:
4703         // This is a no-op.
4704         noResult(node);
4705         break;
4706 
4707     case Unreachable:
4708         unreachable(node);
4709         break;
4710 
4711     case StoreBarrier:
4712     case FencedStoreBarrier: {
4713         compileStoreBarrier(node);
4714         break;
4715     }
4716 
4717     case GetEnumerableLength: {
4718         compileGetEnumerableLength(node);
4719         break;
4720     }
4721     case HasGenericProperty: {
4722         compileHasGenericProperty(node);
4723         break;
4724     }
4725     case HasStructureProperty: {
4726         compileHasStructureProperty(node);
4727         break;
4728     }
4729     case HasIndexedProperty: {
4730         compileHasIndexedProperty(node);
4731         break;
4732     }
4733     case GetDirectPname: {
4734         compileGetDirectPname(node);
4735         break;
4736     }
4737     case GetPropertyEnumerator: {
4738         compileGetPropertyEnumerator(node);
4739         break;
4740     }
4741     case GetEnumeratorStructurePname:
4742     case GetEnumeratorGenericPname: {
4743         compileGetEnumeratorPname(node);
4744         break;
4745     }
4746     case ToIndexString: {
4747         compileToIndexString(node);
4748         break;
4749     }
4750     case ProfileType: {
4751         compileProfileType(node);
4752         break;
4753     }
4754     case ProfileControlFlow: {
4755         BasicBlockLocation* basicBlockLocation = node-&gt;basicBlockLocation();
4756         basicBlockLocation-&gt;emitExecuteCode(m_jit);
4757         noResult(node);
4758         break;
4759     }
4760 
4761     case LogShadowChickenPrologue: {
4762         compileLogShadowChickenPrologue(node);
4763         break;
4764     }
4765 
4766     case LogShadowChickenTail: {
4767         compileLogShadowChickenTail(node);
4768         break;
4769     }
4770 
4771     case MaterializeNewObject:
4772         compileMaterializeNewObject(node);
4773         break;
4774 
4775     case CallDOM:
4776         compileCallDOM(node);
4777         break;
4778 
4779     case CallDOMGetter:
4780         compileCallDOMGetter(node);
4781         break;
4782 
4783     case CheckSubClass:
4784         compileCheckSubClass(node);
4785         break;
4786 
4787     case ExtractCatchLocal: {
4788         compileExtractCatchLocal(node);
4789         break;
4790     }
4791 
4792     case ClearCatchLocals:
4793         compileClearCatchLocals(node);
4794         break;
4795 
4796     case DataViewGetFloat:
4797     case DataViewGetInt: {
4798         SpeculateCellOperand dataView(this, node-&gt;child1());
4799         GPRReg dataViewGPR = dataView.gpr();
4800         speculateDataViewObject(node-&gt;child1(), dataViewGPR);
4801 
4802         SpeculateInt32Operand index(this, node-&gt;child2());
4803         GPRReg indexGPR = index.gpr();
4804 
4805         GPRTemporary temp1(this);
4806         GPRReg t1 = temp1.gpr();
4807         GPRTemporary temp2(this);
4808         GPRReg t2 = temp2.gpr();
4809 
4810         Optional&lt;SpeculateBooleanOperand&gt; isLittleEndianOperand;
4811         if (node-&gt;child3())
4812             isLittleEndianOperand.emplace(this, node-&gt;child3());
4813         GPRReg isLittleEndianGPR = isLittleEndianOperand ? isLittleEndianOperand-&gt;gpr() : InvalidGPRReg;
4814 
4815         DataViewData data = node-&gt;dataViewData();
4816 
4817         m_jit.zeroExtend32ToPtr(indexGPR, t2);
4818         if (data.byteSize &gt; 1)
4819             m_jit.add64(TrustedImm32(data.byteSize - 1), t2);
4820         m_jit.load32(MacroAssembler::Address(dataViewGPR, JSArrayBufferView::offsetOfLength()), t1);
4821         speculationCheck(OutOfBounds, JSValueRegs(), node,
4822             m_jit.branch64(MacroAssembler::AboveOrEqual, t2, t1));
4823 
4824         m_jit.loadPtr(JITCompiler::Address(dataViewGPR, JSArrayBufferView::offsetOfVector()), t2);
4825         cageTypedArrayStorage(dataViewGPR, t2);
4826 
4827         m_jit.zeroExtend32ToPtr(indexGPR, t1);
4828         auto baseIndex = JITCompiler::BaseIndex(t2, t1, MacroAssembler::TimesOne);
4829 
4830         if (node-&gt;op() == DataViewGetInt) {
4831             switch (data.byteSize) {
4832             case 1:
4833                 if (data.isSigned)
4834                     m_jit.load8SignedExtendTo32(baseIndex, t2);
4835                 else
4836                     m_jit.load8(baseIndex, t2);
4837                 int32Result(t2, node);
4838                 break;
4839             case 2: {
4840                 auto emitLittleEndianLoad = [&amp;] {
4841                     if (data.isSigned)
4842                         m_jit.load16SignedExtendTo32(baseIndex, t2);
4843                     else
4844                         m_jit.load16(baseIndex, t2);
4845                 };
4846                 auto emitBigEndianLoad = [&amp;] {
4847                     m_jit.load16(baseIndex, t2);
4848                     m_jit.byteSwap16(t2);
4849                     if (data.isSigned)
4850                         m_jit.signExtend16To32(t2, t2);
4851                 };
4852 
4853                 if (data.isLittleEndian == FalseTriState)
4854                     emitBigEndianLoad();
4855                 else if (data.isLittleEndian == TrueTriState)
4856                     emitLittleEndianLoad();
4857                 else {
4858                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4859                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4860                     emitLittleEndianLoad();
4861                     auto done = m_jit.jump();
4862                     isBigEndian.link(&amp;m_jit);
4863                     emitBigEndianLoad();
4864                     done.link(&amp;m_jit);
4865                 }
4866                 int32Result(t2, node);
4867                 break;
4868             }
4869             case 4: {
4870                 m_jit.load32(baseIndex, t2);
4871 
4872                 if (data.isLittleEndian == FalseTriState)
4873                     m_jit.byteSwap32(t2);
4874                 else if (data.isLittleEndian == MixedTriState) {
4875                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4876                     auto isLittleEndian = m_jit.branchTest32(MacroAssembler::NonZero, isLittleEndianGPR, TrustedImm32(1));
4877                     m_jit.byteSwap32(t2);
4878                     isLittleEndian.link(&amp;m_jit);
4879                 }
4880 
4881                 if (data.isSigned)
4882                     int32Result(t2, node);
4883                 else
4884                     strictInt52Result(t2, node);
4885                 break;
4886             }
4887             default:
4888                 RELEASE_ASSERT_NOT_REACHED();
4889             }
4890         } else {
4891             FPRTemporary result(this);
4892             FPRReg resultFPR = result.fpr();
4893 
4894             switch (data.byteSize) {
4895             case 4: {
4896                 auto emitLittleEndianCode = [&amp;] {
4897                     m_jit.loadFloat(baseIndex, resultFPR);
4898                     m_jit.convertFloatToDouble(resultFPR, resultFPR);
4899                 };
4900 
4901                 auto emitBigEndianCode = [&amp;] {
4902                     m_jit.load32(baseIndex, t2);
4903                     m_jit.byteSwap32(t2);
4904                     m_jit.move32ToFloat(t2, resultFPR);
4905                     m_jit.convertFloatToDouble(resultFPR, resultFPR);
4906                 };
4907 
4908                 if (data.isLittleEndian == TrueTriState)
4909                     emitLittleEndianCode();
4910                 else if (data.isLittleEndian == FalseTriState)
4911                     emitBigEndianCode();
4912                 else {
4913                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4914                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4915                     emitLittleEndianCode();
4916                     auto done = m_jit.jump();
4917                     isBigEndian.link(&amp;m_jit);
4918                     emitBigEndianCode();
4919                     done.link(&amp;m_jit);
4920                 }
4921 
4922                 break;
4923             }
4924             case 8: {
4925                 auto emitLittleEndianCode = [&amp;] {
4926                     m_jit.loadDouble(baseIndex, resultFPR);
4927                 };
4928 
4929                 auto emitBigEndianCode = [&amp;] {
4930                     m_jit.load64(baseIndex, t2);
4931                     m_jit.byteSwap64(t2);
4932                     m_jit.move64ToDouble(t2, resultFPR);
4933                 };
4934 
4935                 if (data.isLittleEndian == TrueTriState)
4936                     emitLittleEndianCode();
4937                 else if (data.isLittleEndian == FalseTriState)
4938                     emitBigEndianCode();
4939                 else {
4940                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
4941                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
4942                     emitLittleEndianCode();
4943                     auto done = m_jit.jump();
4944                     isBigEndian.link(&amp;m_jit);
4945                     emitBigEndianCode();
4946                     done.link(&amp;m_jit);
4947                 }
4948 
4949                 break;
4950             }
4951             default:
4952                 RELEASE_ASSERT_NOT_REACHED();
4953             }
4954 
4955             doubleResult(resultFPR, node);
4956         }
4957 
4958         break;
4959     }
4960 
<a name="121" id="anc121"></a><span class="line-added">4961     case DateGetInt32OrNaN:</span>
<span class="line-added">4962     case DateGetTime:</span>
<span class="line-added">4963         compileDateGet(node);</span>
<span class="line-added">4964         break;</span>
<span class="line-added">4965 </span>
4966     case DataViewSet: {
4967         SpeculateCellOperand dataView(this, m_graph.varArgChild(node, 0));
4968         GPRReg dataViewGPR = dataView.gpr();
4969         speculateDataViewObject(m_graph.varArgChild(node, 0), dataViewGPR);
4970 
4971         SpeculateInt32Operand index(this, m_graph.varArgChild(node, 1));
4972         GPRReg indexGPR = index.gpr();
4973 
4974         Optional&lt;SpeculateStrictInt52Operand&gt; int52Value;
4975         Optional&lt;SpeculateDoubleOperand&gt; doubleValue;
4976         Optional&lt;SpeculateInt32Operand&gt; int32Value;
4977         Optional&lt;FPRTemporary&gt; fprTemporary;
4978         GPRReg valueGPR = InvalidGPRReg;
4979         FPRReg valueFPR = InvalidFPRReg;
4980         FPRReg tempFPR = InvalidFPRReg;
4981 
4982         DataViewData data = node-&gt;dataViewData();
4983 
4984         Edge&amp; valueEdge = m_graph.varArgChild(node, 2);
4985         switch (valueEdge.useKind()) {
4986         case Int32Use:
4987             int32Value.emplace(this, valueEdge);
4988             valueGPR = int32Value-&gt;gpr();
4989             break;
4990         case DoubleRepUse:
4991             doubleValue.emplace(this, valueEdge);
4992             valueFPR = doubleValue-&gt;fpr();
4993             if (data.byteSize == 4) {
4994                 fprTemporary.emplace(this);
4995                 tempFPR = fprTemporary-&gt;fpr();
4996             }
4997             break;
4998         case Int52RepUse:
4999             int52Value.emplace(this, valueEdge);
5000             valueGPR = int52Value-&gt;gpr();
5001             break;
5002         default:
5003             RELEASE_ASSERT_NOT_REACHED();
5004         }
5005 
5006         GPRTemporary temp1(this);
5007         GPRReg t1 = temp1.gpr();
5008         GPRTemporary temp2(this);
5009         GPRReg t2 = temp2.gpr();
5010         GPRTemporary temp3(this);
5011         GPRReg t3 = temp3.gpr();
5012 
5013         Optional&lt;SpeculateBooleanOperand&gt; isLittleEndianOperand;
5014         if (m_graph.varArgChild(node, 3))
5015             isLittleEndianOperand.emplace(this, m_graph.varArgChild(node, 3));
5016         GPRReg isLittleEndianGPR = isLittleEndianOperand ? isLittleEndianOperand-&gt;gpr() : InvalidGPRReg;
5017 
5018         m_jit.zeroExtend32ToPtr(indexGPR, t2);
5019         if (data.byteSize &gt; 1)
5020             m_jit.add64(TrustedImm32(data.byteSize - 1), t2);
5021         m_jit.load32(MacroAssembler::Address(dataViewGPR, JSArrayBufferView::offsetOfLength()), t1);
5022         speculationCheck(OutOfBounds, JSValueRegs(), node,
5023             m_jit.branch64(MacroAssembler::AboveOrEqual, t2, t1));
5024 
5025         m_jit.loadPtr(JITCompiler::Address(dataViewGPR, JSArrayBufferView::offsetOfVector()), t2);
5026         cageTypedArrayStorage(dataViewGPR, t2);
5027 
5028         m_jit.zeroExtend32ToPtr(indexGPR, t1);
5029         auto baseIndex = JITCompiler::BaseIndex(t2, t1, MacroAssembler::TimesOne);
5030 
5031         if (data.isFloatingPoint) {
5032             RELEASE_ASSERT(valueFPR != InvalidFPRReg);
5033             if (data.byteSize == 4) {
5034                 RELEASE_ASSERT(tempFPR != InvalidFPRReg);
5035                 m_jit.convertDoubleToFloat(valueFPR, tempFPR);
5036 
5037                 auto emitLittleEndianCode = [&amp;] {
5038                     m_jit.storeFloat(tempFPR, baseIndex);
5039                 };
5040 
5041                 auto emitBigEndianCode = [&amp;] {
5042                     m_jit.moveFloatTo32(tempFPR, t3);
5043                     m_jit.byteSwap32(t3);
5044                     m_jit.store32(t3, baseIndex);
5045                 };
5046 
5047                 if (data.isLittleEndian == FalseTriState)
5048                     emitBigEndianCode();
5049                 else if (data.isLittleEndian == TrueTriState)
5050                     emitLittleEndianCode();
5051                 else {
5052                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
5053                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
5054                     emitLittleEndianCode();
5055                     auto done = m_jit.jump();
5056                     isBigEndian.link(&amp;m_jit);
5057                     emitBigEndianCode();
5058                     done.link(&amp;m_jit);
5059                 }
5060             } else {
5061                 RELEASE_ASSERT(data.byteSize == 8);
5062                 RELEASE_ASSERT(valueFPR != InvalidFPRReg);
5063 
5064                 auto emitLittleEndianCode = [&amp;] {
5065                     m_jit.storeDouble(valueFPR, baseIndex);
5066                 };
5067                 auto emitBigEndianCode = [&amp;] {
5068                     m_jit.moveDoubleTo64(valueFPR, t3);
5069                     m_jit.byteSwap64(t3);
5070                     m_jit.store64(t3, baseIndex);
5071                 };
5072 
5073                 if (data.isLittleEndian == FalseTriState)
5074                     emitBigEndianCode();
5075                 else if (data.isLittleEndian == TrueTriState)
5076                     emitLittleEndianCode();
5077                 else {
5078                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
5079                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
5080                     emitLittleEndianCode();
5081                     auto done = m_jit.jump();
5082                     isBigEndian.link(&amp;m_jit);
5083                     emitBigEndianCode();
5084                     done.link(&amp;m_jit);
5085                 }
5086             }
5087         } else {
5088             switch (data.byteSize) {
5089             case 1:
5090                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use);
5091                 RELEASE_ASSERT(valueGPR != InvalidGPRReg);
5092                 m_jit.store8(valueGPR, baseIndex);
5093                 break;
5094             case 2: {
5095                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use);
5096                 RELEASE_ASSERT(valueGPR != InvalidGPRReg);
5097 
5098                 auto emitLittleEndianCode = [&amp;] {
5099                     m_jit.store16(valueGPR, baseIndex);
5100                 };
5101                 auto emitBigEndianCode = [&amp;] {
5102                     m_jit.move(valueGPR, t3);
5103                     m_jit.byteSwap16(t3);
5104                     m_jit.store16(t3, baseIndex);
5105                 };
5106 
5107                 if (data.isLittleEndian == FalseTriState)
5108                     emitBigEndianCode();
5109                 else if (data.isLittleEndian == TrueTriState)
5110                     emitLittleEndianCode();
5111                 else {
5112                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
5113                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
5114                     emitLittleEndianCode();
5115                     auto done = m_jit.jump();
5116                     isBigEndian.link(&amp;m_jit);
5117                     emitBigEndianCode();
5118                     done.link(&amp;m_jit);
5119                 }
5120                 break;
5121             }
5122             case 4: {
5123                 RELEASE_ASSERT(valueEdge.useKind() == Int32Use || valueEdge.useKind() == Int52RepUse);
5124 
5125                 auto emitLittleEndianCode = [&amp;] {
5126                     m_jit.store32(valueGPR, baseIndex);
5127                 };
5128 
5129                 auto emitBigEndianCode = [&amp;] {
5130                     m_jit.zeroExtend32ToPtr(valueGPR, t3);
5131                     m_jit.byteSwap32(t3);
5132                     m_jit.store32(t3, baseIndex);
5133                 };
5134 
5135                 if (data.isLittleEndian == FalseTriState)
5136                     emitBigEndianCode();
5137                 else if (data.isLittleEndian == TrueTriState)
5138                     emitLittleEndianCode();
5139                 else {
5140                     RELEASE_ASSERT(isLittleEndianGPR != InvalidGPRReg);
5141                     auto isBigEndian = m_jit.branchTest32(MacroAssembler::Zero, isLittleEndianGPR, TrustedImm32(1));
5142                     emitLittleEndianCode();
5143                     auto done = m_jit.jump();
5144                     isBigEndian.link(&amp;m_jit);
5145                     emitBigEndianCode();
5146                     done.link(&amp;m_jit);
5147                 }
5148 
5149                 break;
5150             }
5151             default:
5152                 RELEASE_ASSERT_NOT_REACHED();
5153             }
5154         }
5155 
5156         noResult(node);
5157         break;
5158     }
5159 
5160 #if ENABLE(FTL_JIT)
5161     case CheckTierUpInLoop: {
5162         MacroAssembler::Jump callTierUp = m_jit.branchAdd32(
5163             MacroAssembler::PositiveOrZero,
5164             TrustedImm32(Options::ftlTierUpCounterIncrementForLoop()),
5165             MacroAssembler::AbsoluteAddress(&amp;m_jit.jitCode()-&gt;tierUpCounter.m_counter));
5166 
5167         MacroAssembler::Label toNextOperation = m_jit.label();
5168 
5169         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
5170         silentSpillAllRegistersImpl(false, savePlans, InvalidGPRReg);
<a name="122" id="anc122"></a><span class="line-modified">5171         BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
5172 
5173         addSlowPathGeneratorLambda([=]() {
5174             callTierUp.link(&amp;m_jit);
5175 
5176             silentSpill(savePlans);
<a name="123" id="anc123"></a><span class="line-modified">5177             callOperation(operationTriggerTierUpNowInLoop, &amp;vm(), TrustedImm32(bytecodeIndex.asBits()));</span>
5178             silentFill(savePlans);
5179 
5180             m_jit.jump().linkTo(toNextOperation, &amp;m_jit);
5181         });
5182         break;
5183     }
5184 
5185     case CheckTierUpAtReturn: {
5186         MacroAssembler::Jump done = m_jit.branchAdd32(
5187             MacroAssembler::Signed,
5188             TrustedImm32(Options::ftlTierUpCounterIncrementForReturn()),
5189             MacroAssembler::AbsoluteAddress(&amp;m_jit.jitCode()-&gt;tierUpCounter.m_counter));
5190 
5191         silentSpillAllRegisters(InvalidGPRReg);
<a name="124" id="anc124"></a><span class="line-modified">5192         callOperation(operationTriggerTierUpNow, &amp;vm());</span>
5193         silentFillAllRegisters();
5194 
5195         done.link(&amp;m_jit);
5196         break;
5197     }
5198 
5199     case CheckTierUpAndOSREnter: {
5200         ASSERT(!node-&gt;origin.semantic.inlineCallFrame());
5201 
5202         GPRTemporary temp(this);
5203         GPRReg tempGPR = temp.gpr();
5204 
<a name="125" id="anc125"></a><span class="line-modified">5205         BytecodeIndex bytecodeIndex = node-&gt;origin.semantic.bytecodeIndex();</span>
5206         auto triggerIterator = m_jit.jitCode()-&gt;tierUpEntryTriggers.find(bytecodeIndex);
5207         DFG_ASSERT(m_jit.graph(), node, triggerIterator != m_jit.jitCode()-&gt;tierUpEntryTriggers.end());
5208         JITCode::TriggerReason* forceEntryTrigger = &amp;(m_jit.jitCode()-&gt;tierUpEntryTriggers.find(bytecodeIndex)-&gt;value);
5209         static_assert(!static_cast&lt;uint8_t&gt;(JITCode::TriggerReason::DontTrigger), &quot;the JIT code assumes non-zero means &#39;enter&#39;&quot;);
5210         static_assert(sizeof(JITCode::TriggerReason) == 1, &quot;branchTest8 assumes this size&quot;);
5211 
5212         MacroAssembler::Jump forceOSREntry = m_jit.branchTest8(MacroAssembler::NonZero, MacroAssembler::AbsoluteAddress(forceEntryTrigger));
5213         MacroAssembler::Jump overflowedCounter = m_jit.branchAdd32(
5214             MacroAssembler::PositiveOrZero,
5215             TrustedImm32(Options::ftlTierUpCounterIncrementForLoop()),
5216             MacroAssembler::AbsoluteAddress(&amp;m_jit.jitCode()-&gt;tierUpCounter.m_counter));
5217         MacroAssembler::Label toNextOperation = m_jit.label();
5218 
5219         Vector&lt;SilentRegisterSavePlan&gt; savePlans;
5220         silentSpillAllRegistersImpl(false, savePlans, tempGPR);
5221 
5222         unsigned streamIndex = m_stream-&gt;size();
5223         m_jit.jitCode()-&gt;bytecodeIndexToStreamIndex.add(bytecodeIndex, streamIndex);
5224 
5225         addSlowPathGeneratorLambda([=]() {
5226             forceOSREntry.link(&amp;m_jit);
5227             overflowedCounter.link(&amp;m_jit);
5228 
5229             silentSpill(savePlans);
<a name="126" id="anc126"></a><span class="line-modified">5230             callOperation(operationTriggerOSREntryNow, tempGPR, &amp;vm(), TrustedImm32(bytecodeIndex.asBits()));</span>
5231 
5232             if (savePlans.isEmpty())
5233                 m_jit.branchTestPtr(MacroAssembler::Zero, tempGPR).linkTo(toNextOperation, &amp;m_jit);
5234             else {
5235                 MacroAssembler::Jump osrEnter = m_jit.branchTestPtr(MacroAssembler::NonZero, tempGPR);
5236                 silentFill(savePlans);
5237                 m_jit.jump().linkTo(toNextOperation, &amp;m_jit);
5238                 osrEnter.link(&amp;m_jit);
5239             }
5240             m_jit.emitRestoreCalleeSaves();
5241             m_jit.farJump(tempGPR, GPRInfo::callFrameRegister);
5242         });
5243         break;
5244     }
5245 
5246 #else // ENABLE(FTL_JIT)
5247     case CheckTierUpInLoop:
5248     case CheckTierUpAtReturn:
5249     case CheckTierUpAndOSREnter:
5250         DFG_CRASH(m_jit.graph(), node, &quot;Unexpected tier-up node&quot;);
5251         break;
5252 #endif // ENABLE(FTL_JIT)
5253 
5254     case FilterCallLinkStatus:
<a name="127" id="anc127"></a><span class="line-modified">5255     case FilterGetByStatus:</span>
5256     case FilterPutByIdStatus:
5257     case FilterInByIdStatus:
5258         m_interpreter.filterICStatus(node);
5259         noResult(node);
5260         break;
5261 
5262     case LastNodeType:
5263     case EntrySwitch:
5264     case InitializeEntrypointArguments:
5265     case Phi:
5266     case Upsilon:
5267     case ExtractOSREntryLocal:
5268     case CheckInBounds:
5269     case ArithIMul:
5270     case MultiGetByOffset:
5271     case MultiPutByOffset:
5272     case FiatInt52:
5273     case CheckBadCell:
5274     case BottomValue:
5275     case PhantomNewObject:
5276     case PhantomNewFunction:
5277     case PhantomNewGeneratorFunction:
5278     case PhantomNewAsyncFunction:
5279     case PhantomNewAsyncGeneratorFunction:
<a name="128" id="anc128"></a><span class="line-added">5280     case PhantomNewArrayIterator:</span>
5281     case PhantomCreateActivation:
5282     case PhantomNewRegexp:
5283     case GetMyArgumentByVal:
5284     case GetMyArgumentByValOutOfBounds:
5285     case GetVectorLength:
5286     case PutHint:
5287     case CheckStructureImmediate:
5288     case MaterializeCreateActivation:
<a name="129" id="anc129"></a><span class="line-added">5289     case MaterializeNewInternalFieldObject:</span>
5290     case PutStack:
5291     case KillStack:
5292     case GetStack:
5293     case PhantomCreateRest:
5294     case PhantomSpread:
5295     case PhantomNewArrayWithSpread:
5296     case PhantomNewArrayBuffer:
5297     case IdentityWithProfile:
5298     case CPUIntrinsic:
5299         DFG_CRASH(m_jit.graph(), node, &quot;Unexpected node&quot;);
5300         break;
5301     }
5302 
5303     if (!m_compileOkay)
5304         return;
5305 
5306     if (node-&gt;hasResult() &amp;&amp; node-&gt;mustGenerate())
5307         use(node);
5308 }
5309 
5310 void SpeculativeJIT::moveTrueTo(GPRReg gpr)
5311 {
<a name="130" id="anc130"></a><span class="line-modified">5312     m_jit.move(TrustedImm32(JSValue::ValueTrue), gpr);</span>
5313 }
5314 
5315 void SpeculativeJIT::moveFalseTo(GPRReg gpr)
5316 {
<a name="131" id="anc131"></a><span class="line-modified">5317     m_jit.move(TrustedImm32(JSValue::ValueFalse), gpr);</span>
5318 }
5319 
5320 void SpeculativeJIT::blessBoolean(GPRReg gpr)
5321 {
<a name="132" id="anc132"></a><span class="line-modified">5322     m_jit.or32(TrustedImm32(JSValue::ValueFalse), gpr);</span>
5323 }
5324 
5325 void SpeculativeJIT::convertAnyInt(Edge valueEdge, GPRReg resultGPR)
5326 {
5327     JSValueOperand value(this, valueEdge, ManualOperandSpeculation);
5328     GPRReg valueGPR = value.gpr();
5329 
5330     JITCompiler::Jump notInt32 = m_jit.branchIfNotInt32(valueGPR);
5331 
5332     m_jit.signExtend32ToPtr(valueGPR, resultGPR);
5333     JITCompiler::Jump done = m_jit.jump();
5334 
5335     notInt32.link(&amp;m_jit);
5336     silentSpillAllRegisters(resultGPR);
5337     callOperation(operationConvertBoxedDoubleToInt52, resultGPR, valueGPR);
5338     silentFillAllRegisters();
5339 
5340     DFG_TYPE_CHECK(
5341         JSValueRegs(valueGPR), valueEdge, SpecInt32Only | SpecAnyIntAsDouble,
5342         m_jit.branch64(
5343             JITCompiler::Equal, resultGPR,
5344             JITCompiler::TrustedImm64(JSValue::notInt52)));
5345     done.link(&amp;m_jit);
5346 }
5347 
5348 void SpeculativeJIT::speculateAnyInt(Edge edge)
5349 {
5350     if (!needsTypeCheck(edge, SpecInt32Only | SpecAnyIntAsDouble))
5351         return;
5352 
5353     GPRTemporary temp(this);
5354     convertAnyInt(edge, temp.gpr());
5355 }
5356 
5357 void SpeculativeJIT::speculateInt32(Edge edge, JSValueRegs regs)
5358 {
5359     DFG_TYPE_CHECK(regs, edge, SpecInt32Only, m_jit.branchIfNotInt32(regs));
5360 }
5361 
5362 void SpeculativeJIT::speculateDoubleRepAnyInt(Edge edge)
5363 {
5364     if (!needsTypeCheck(edge, SpecAnyIntAsDouble))
5365         return;
5366 
5367     SpeculateDoubleOperand value(this, edge);
5368     FPRReg valueFPR = value.fpr();
5369 
5370     flushRegisters();
5371     GPRFlushedCallResult result(this);
5372     GPRReg resultGPR = result.gpr();
5373     callOperation(operationConvertDoubleToInt52, resultGPR, valueFPR);
5374 
5375     DFG_TYPE_CHECK(
5376         JSValueRegs(), edge, SpecAnyIntAsDouble,
5377         m_jit.branch64(
5378             JITCompiler::Equal, resultGPR,
5379             JITCompiler::TrustedImm64(JSValue::notInt52)));
5380 }
5381 
5382 void SpeculativeJIT::compileArithRandom(Node* node)
5383 {
5384     JSGlobalObject* globalObject = m_jit.graph().globalObjectFor(node-&gt;origin.semantic);
5385     GPRTemporary temp1(this);
5386     GPRTemporary temp2(this);
5387     GPRTemporary temp3(this);
5388     FPRTemporary result(this);
5389     m_jit.emitRandomThunk(globalObject, temp1.gpr(), temp2.gpr(), temp3.gpr(), result.fpr());
5390     doubleResult(result.fpr(), node);
5391 }
5392 
<a name="133" id="anc133"></a><span class="line-added">5393 void SpeculativeJIT::compileStringCodePointAt(Node* node)</span>
<span class="line-added">5394 {</span>
<span class="line-added">5395     // We emit CheckArray on this node as we do in StringCharCodeAt node so that we do not need to check SpecString here.</span>
<span class="line-added">5396     // And CheckArray also ensures that this String is not a rope.</span>
<span class="line-added">5397     SpeculateCellOperand string(this, node-&gt;child1());</span>
<span class="line-added">5398     SpeculateStrictInt32Operand index(this, node-&gt;child2());</span>
<span class="line-added">5399     StorageOperand storage(this, node-&gt;child3());</span>
<span class="line-added">5400     GPRTemporary scratch1(this);</span>
<span class="line-added">5401     GPRTemporary scratch2(this);</span>
<span class="line-added">5402     GPRTemporary scratch3(this);</span>
<span class="line-added">5403 </span>
<span class="line-added">5404     GPRReg stringGPR = string.gpr();</span>
<span class="line-added">5405     GPRReg indexGPR = index.gpr();</span>
<span class="line-added">5406     GPRReg storageGPR = storage.gpr();</span>
<span class="line-added">5407     GPRReg scratch1GPR = scratch1.gpr();</span>
<span class="line-added">5408     GPRReg scratch2GPR = scratch2.gpr();</span>
<span class="line-added">5409     GPRReg scratch3GPR = scratch3.gpr();</span>
<span class="line-added">5410 </span>
<span class="line-added">5411     m_jit.loadPtr(CCallHelpers::Address(stringGPR, JSString::offsetOfValue()), scratch1GPR);</span>
<span class="line-added">5412     m_jit.load32(CCallHelpers::Address(scratch1GPR, StringImpl::lengthMemoryOffset()), scratch2GPR);</span>
<span class="line-added">5413 </span>
<span class="line-added">5414     // unsigned comparison so we can filter out negative indices and indices that are too large</span>
<span class="line-added">5415     speculationCheck(Uncountable, JSValueRegs(), 0, m_jit.branch32(CCallHelpers::AboveOrEqual, indexGPR, scratch2GPR));</span>
<span class="line-added">5416 </span>
<span class="line-added">5417     // Load the character into scratch1GPR</span>
<span class="line-added">5418     auto is16Bit = m_jit.branchTest32(CCallHelpers::Zero, CCallHelpers::Address(scratch1GPR, StringImpl::flagsOffset()), TrustedImm32(StringImpl::flagIs8Bit()));</span>
<span class="line-added">5419 </span>
<span class="line-added">5420     CCallHelpers::JumpList done;</span>
<span class="line-added">5421 </span>
<span class="line-added">5422     m_jit.load8(CCallHelpers::BaseIndex(storageGPR, indexGPR, CCallHelpers::TimesOne, 0), scratch1GPR);</span>
<span class="line-added">5423     done.append(m_jit.jump());</span>
<span class="line-added">5424 </span>
<span class="line-added">5425     is16Bit.link(&amp;m_jit);</span>
<span class="line-added">5426     m_jit.load16(CCallHelpers::BaseIndex(storageGPR, indexGPR, CCallHelpers::TimesTwo, 0), scratch1GPR);</span>
<span class="line-added">5427     // This is ok. indexGPR must be positive int32_t here and adding 1 never causes overflow if we treat indexGPR as uint32_t.</span>
<span class="line-added">5428     m_jit.add32(CCallHelpers::TrustedImm32(1), indexGPR, scratch3GPR);</span>
<span class="line-added">5429     done.append(m_jit.branch32(CCallHelpers::AboveOrEqual, scratch3GPR, scratch2GPR));</span>
<span class="line-added">5430     m_jit.and32(CCallHelpers::TrustedImm32(0xfffffc00), scratch1GPR, scratch2GPR);</span>
<span class="line-added">5431     done.append(m_jit.branch32(CCallHelpers::NotEqual, scratch2GPR, CCallHelpers::TrustedImm32(0xd800)));</span>
<span class="line-added">5432     m_jit.load16(CCallHelpers::BaseIndex(storageGPR, scratch3GPR, CCallHelpers::TimesTwo, 0), scratch3GPR);</span>
<span class="line-added">5433     m_jit.and32(CCallHelpers::TrustedImm32(0xfffffc00), scratch3GPR, scratch2GPR);</span>
<span class="line-added">5434     done.append(m_jit.branch32(CCallHelpers::NotEqual, scratch2GPR, CCallHelpers::TrustedImm32(0xdc00)));</span>
<span class="line-added">5435     m_jit.lshift32(CCallHelpers::TrustedImm32(10), scratch1GPR);</span>
<span class="line-added">5436     m_jit.getEffectiveAddress(CCallHelpers::BaseIndex(scratch1GPR, scratch3GPR, CCallHelpers::TimesOne, -U16_SURROGATE_OFFSET), scratch1GPR);</span>
<span class="line-added">5437     done.link(&amp;m_jit);</span>
<span class="line-added">5438 </span>
<span class="line-added">5439     int32Result(scratch1GPR, m_currentNode);</span>
<span class="line-added">5440 }</span>
<span class="line-added">5441 </span>
<span class="line-added">5442 void SpeculativeJIT::compileDateGet(Node* node)</span>
<span class="line-added">5443 {</span>
<span class="line-added">5444     SpeculateCellOperand base(this, node-&gt;child1());</span>
<span class="line-added">5445     GPRReg baseGPR = base.gpr();</span>
<span class="line-added">5446     speculateDateObject(node-&gt;child1(), baseGPR);</span>
<span class="line-added">5447 </span>
<span class="line-added">5448     auto emitGetCodeWithCallback = [&amp;] (ptrdiff_t cachedDoubleOffset, ptrdiff_t cachedDataOffset, auto* operation, auto callback) {</span>
<span class="line-added">5449         JSValueRegsTemporary result(this);</span>
<span class="line-added">5450         FPRTemporary temp1(this);</span>
<span class="line-added">5451         FPRTemporary temp2(this);</span>
<span class="line-added">5452 </span>
<span class="line-added">5453         JSValueRegs resultRegs = result.regs();</span>
<span class="line-added">5454         FPRReg temp1FPR = temp1.fpr();</span>
<span class="line-added">5455         FPRReg temp2FPR = temp2.fpr();</span>
<span class="line-added">5456 </span>
<span class="line-added">5457         CCallHelpers::JumpList slowCases;</span>
<span class="line-added">5458 </span>
<span class="line-added">5459         m_jit.loadPtr(CCallHelpers::Address(baseGPR, DateInstance::offsetOfData()), resultRegs.payloadGPR());</span>
<span class="line-added">5460         slowCases.append(m_jit.branchTestPtr(CCallHelpers::Zero, resultRegs.payloadGPR()));</span>
<span class="line-added">5461         m_jit.loadDouble(CCallHelpers::Address(baseGPR, DateInstance::offsetOfInternalNumber()), temp1FPR);</span>
<span class="line-added">5462         m_jit.loadDouble(CCallHelpers::Address(resultRegs.payloadGPR(), cachedDoubleOffset), temp2FPR);</span>
<span class="line-added">5463         slowCases.append(m_jit.branchDouble(CCallHelpers::DoubleNotEqualOrUnordered, temp1FPR, temp2FPR));</span>
<span class="line-added">5464         m_jit.load32(CCallHelpers::Address(resultRegs.payloadGPR(), cachedDataOffset), resultRegs.payloadGPR());</span>
<span class="line-added">5465         callback(resultRegs.payloadGPR());</span>
<span class="line-added">5466         m_jit.boxInt32(resultRegs.payloadGPR(), resultRegs);</span>
<span class="line-added">5467 </span>
<span class="line-added">5468         addSlowPathGenerator(slowPathCall(slowCases, this, operation, resultRegs, &amp;vm(), baseGPR));</span>
<span class="line-added">5469 </span>
<span class="line-added">5470         jsValueResult(resultRegs, node);</span>
<span class="line-added">5471     };</span>
<span class="line-added">5472 </span>
<span class="line-added">5473     auto emitGetCode = [&amp;] (ptrdiff_t cachedDoubleOffset, ptrdiff_t cachedDataOffset, auto* operation) {</span>
<span class="line-added">5474         emitGetCodeWithCallback(cachedDoubleOffset, cachedDataOffset, operation, [] (GPRReg) { });</span>
<span class="line-added">5475     };</span>
<span class="line-added">5476 </span>
<span class="line-added">5477     switch (node-&gt;intrinsic()) {</span>
<span class="line-added">5478     case DatePrototypeGetTimeIntrinsic: {</span>
<span class="line-added">5479         FPRTemporary result(this);</span>
<span class="line-added">5480         FPRReg resultFPR = result.fpr();</span>
<span class="line-added">5481         m_jit.loadDouble(CCallHelpers::Address(baseGPR, DateInstance::offsetOfInternalNumber()), resultFPR);</span>
<span class="line-added">5482         doubleResult(resultFPR, node);</span>
<span class="line-added">5483         break;</span>
<span class="line-added">5484     }</span>
<span class="line-added">5485 </span>
<span class="line-added">5486     // We do not have any timezone offset which affects on milliseconds.</span>
<span class="line-added">5487     // So Date#getMilliseconds and Date#getUTCMilliseconds have the same implementation.</span>
<span class="line-added">5488     case DatePrototypeGetMillisecondsIntrinsic:</span>
<span class="line-added">5489     case DatePrototypeGetUTCMillisecondsIntrinsic: {</span>
<span class="line-added">5490         JSValueRegsTemporary result(this);</span>
<span class="line-added">5491         FPRTemporary temp1(this);</span>
<span class="line-added">5492         FPRTemporary temp2(this);</span>
<span class="line-added">5493         FPRTemporary temp3(this);</span>
<span class="line-added">5494         JSValueRegs resultRegs = result.regs();</span>
<span class="line-added">5495         FPRReg temp1FPR = temp1.fpr();</span>
<span class="line-added">5496         FPRReg temp2FPR = temp2.fpr();</span>
<span class="line-added">5497         FPRReg temp3FPR = temp3.fpr();</span>
<span class="line-added">5498 </span>
<span class="line-added">5499         m_jit.moveTrustedValue(jsNaN(), resultRegs);</span>
<span class="line-added">5500         m_jit.loadDouble(CCallHelpers::Address(baseGPR, DateInstance::offsetOfInternalNumber()), temp1FPR);</span>
<span class="line-added">5501         auto isNaN = m_jit.branchIfNaN(temp1FPR);</span>
<span class="line-added">5502 </span>
<span class="line-added">5503         static const double msPerSecondConstant = msPerSecond;</span>
<span class="line-added">5504         m_jit.loadDouble(TrustedImmPtr(&amp;msPerSecondConstant), temp2FPR);</span>
<span class="line-added">5505         m_jit.divDouble(temp1FPR, temp2FPR, temp3FPR);</span>
<span class="line-added">5506         m_jit.floorDouble(temp3FPR, temp3FPR);</span>
<span class="line-added">5507         m_jit.mulDouble(temp3FPR, temp2FPR, temp3FPR);</span>
<span class="line-added">5508         m_jit.subDouble(temp1FPR, temp3FPR, temp1FPR);</span>
<span class="line-added">5509         m_jit.truncateDoubleToInt32(temp1FPR, resultRegs.payloadGPR());</span>
<span class="line-added">5510         m_jit.boxInt32(resultRegs.payloadGPR(), resultRegs);</span>
<span class="line-added">5511 </span>
<span class="line-added">5512         isNaN.link(&amp;m_jit);</span>
<span class="line-added">5513         jsValueResult(resultRegs, node);</span>
<span class="line-added">5514         break;</span>
<span class="line-added">5515     }</span>
<span class="line-added">5516 </span>
<span class="line-added">5517     case DatePrototypeGetFullYearIntrinsic:</span>
<span class="line-added">5518         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfYear(), operationDateGetFullYear);</span>
<span class="line-added">5519         break;</span>
<span class="line-added">5520     case DatePrototypeGetUTCFullYearIntrinsic:</span>
<span class="line-added">5521         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfYear(), operationDateGetUTCFullYear);</span>
<span class="line-added">5522         break;</span>
<span class="line-added">5523     case DatePrototypeGetMonthIntrinsic:</span>
<span class="line-added">5524         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfMonth(), operationDateGetMonth);</span>
<span class="line-added">5525         break;</span>
<span class="line-added">5526     case DatePrototypeGetUTCMonthIntrinsic:</span>
<span class="line-added">5527         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfMonth(), operationDateGetUTCMonth);</span>
<span class="line-added">5528         break;</span>
<span class="line-added">5529     case DatePrototypeGetDateIntrinsic:</span>
<span class="line-added">5530         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfMonthDay(), operationDateGetDate);</span>
<span class="line-added">5531         break;</span>
<span class="line-added">5532     case DatePrototypeGetUTCDateIntrinsic:</span>
<span class="line-added">5533         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfMonthDay(), operationDateGetUTCDate);</span>
<span class="line-added">5534         break;</span>
<span class="line-added">5535     case DatePrototypeGetDayIntrinsic:</span>
<span class="line-added">5536         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfWeekDay(), operationDateGetDay);</span>
<span class="line-added">5537         break;</span>
<span class="line-added">5538     case DatePrototypeGetUTCDayIntrinsic:</span>
<span class="line-added">5539         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfWeekDay(), operationDateGetUTCDay);</span>
<span class="line-added">5540         break;</span>
<span class="line-added">5541     case DatePrototypeGetHoursIntrinsic:</span>
<span class="line-added">5542         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfHour(), operationDateGetHours);</span>
<span class="line-added">5543         break;</span>
<span class="line-added">5544     case DatePrototypeGetUTCHoursIntrinsic:</span>
<span class="line-added">5545         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfHour(), operationDateGetUTCHours);</span>
<span class="line-added">5546         break;</span>
<span class="line-added">5547     case DatePrototypeGetMinutesIntrinsic:</span>
<span class="line-added">5548         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfMinute(), operationDateGetMinutes);</span>
<span class="line-added">5549         break;</span>
<span class="line-added">5550     case DatePrototypeGetUTCMinutesIntrinsic:</span>
<span class="line-added">5551         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfMinute(), operationDateGetUTCMinutes);</span>
<span class="line-added">5552         break;</span>
<span class="line-added">5553     case DatePrototypeGetSecondsIntrinsic:</span>
<span class="line-added">5554         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfSecond(), operationDateGetSeconds);</span>
<span class="line-added">5555         break;</span>
<span class="line-added">5556     case DatePrototypeGetUTCSecondsIntrinsic:</span>
<span class="line-added">5557         emitGetCode(DateInstanceData::offsetOfGregorianDateTimeUTCCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTimeUTC() + GregorianDateTime::offsetOfSecond(), operationDateGetUTCSeconds);</span>
<span class="line-added">5558         break;</span>
<span class="line-added">5559 </span>
<span class="line-added">5560     case DatePrototypeGetTimezoneOffsetIntrinsic: {</span>
<span class="line-added">5561         emitGetCodeWithCallback(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfUTCOffsetInMinute(), operationDateGetTimezoneOffset, [&amp;] (GPRReg offsetGPR) {</span>
<span class="line-added">5562             m_jit.neg32(offsetGPR);</span>
<span class="line-added">5563         });</span>
<span class="line-added">5564         break;</span>
<span class="line-added">5565     }</span>
<span class="line-added">5566 </span>
<span class="line-added">5567     case DatePrototypeGetYearIntrinsic: {</span>
<span class="line-added">5568         emitGetCodeWithCallback(DateInstanceData::offsetOfGregorianDateTimeCachedForMS(), DateInstanceData::offsetOfCachedGregorianDateTime() + GregorianDateTime::offsetOfYear(), operationDateGetYear, [&amp;] (GPRReg yearGPR) {</span>
<span class="line-added">5569             m_jit.sub32(TrustedImm32(1900), yearGPR);</span>
<span class="line-added">5570         });</span>
<span class="line-added">5571         break;</span>
<span class="line-added">5572     }</span>
<span class="line-added">5573 </span>
<span class="line-added">5574     default:</span>
<span class="line-added">5575         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">5576     }</span>
<span class="line-added">5577 }</span>
<span class="line-added">5578 </span>
5579 #endif
5580 
5581 } } // namespace JSC::DFG
5582 
5583 #endif
<a name="134" id="anc134"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="134" type="hidden" />
</body>
</html>
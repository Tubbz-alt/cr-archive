<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayerBacking.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2009, 2010, 2011 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;FloatPoint.h&quot;
 29 #include &quot;FloatPoint3D.h&quot;
 30 #include &quot;GraphicsLayer.h&quot;
 31 #include &quot;GraphicsLayerClient.h&quot;
 32 #include &quot;RenderLayer.h&quot;
 33 #include &quot;RenderLayerCompositor.h&quot;
 34 #include &quot;ScrollingCoordinator.h&quot;
 35 
 36 namespace WebCore {
 37 
<a name="1" id="anc1"></a><span class="line-added"> 38 class EventRegionContext;</span>
 39 class KeyframeList;
 40 class PaintedContentsInfo;
 41 class RenderLayerCompositor;
 42 class TiledBacking;
 43 class TransformationMatrix;
 44 
<a name="2" id="anc2"></a><span class="line-added"> 45 </span>
<span class="line-added"> 46 #if __WORDSIZE == 64</span>
<span class="line-added"> 47 #define USE_OWNING_LAYER_BEAR_TRAP 1</span>
<span class="line-added"> 48 #define BEAR_TRAP_VALUE 0xEEEEEEEEEEEEEEEE</span>
<span class="line-added"> 49 #else</span>
<span class="line-added"> 50 #define USE_OWNING_LAYER_BEAR_TRAP 0</span>
<span class="line-added"> 51 #endif</span>
<span class="line-added"> 52 </span>
<span class="line-added"> 53 </span>
 54 enum CompositingLayerType {
 55     NormalCompositingLayer, // non-tiled layer with backing store
 56     TiledCompositingLayer, // tiled layer (always has backing store)
 57     MediaCompositingLayer, // layer that contains an image, video, WebGL or plugin
 58     ContainerCompositingLayer // layer with no backing store
 59 };
 60 
 61 // RenderLayerBacking controls the compositing behavior for a single RenderLayer.
 62 // It holds the various GraphicsLayers, and makes decisions about intra-layer rendering
 63 // optimizations.
 64 //
 65 // There is one RenderLayerBacking for each RenderLayer that is composited.
 66 
 67 class RenderLayerBacking final : public GraphicsLayerClient {
 68     WTF_MAKE_NONCOPYABLE(RenderLayerBacking); WTF_MAKE_FAST_ALLOCATED;
 69 public:
 70     explicit RenderLayerBacking(RenderLayer&amp;);
 71     ~RenderLayerBacking();
 72 
 73 #if PLATFORM(IOS_FAMILY)
 74     void layerWillBeDestroyed();
 75 #endif
 76 
 77     // Do cleanup while layer-&gt;backing() is still valid.
 78     void willBeDestroyed();
 79 
 80     RenderLayer&amp; owningLayer() const { return m_owningLayer; }
 81 
 82     // Included layers are non-z-order descendant layers that are painted into this backing.
 83     const Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp; backingSharingLayers() const { return m_backingSharingLayers; }
 84     void setBackingSharingLayers(Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt;&amp;&amp;);
 85 
 86     bool hasBackingSharingLayers() const { return !m_backingSharingLayers.isEmpty(); }
 87 
 88     void removeBackingSharingLayer(RenderLayer&amp;);
 89     void clearBackingSharingLayers();
 90 
 91     void updateConfigurationAfterStyleChange();
 92 
 93     // Returns true if layer configuration changed.
<a name="3" id="anc3"></a><span class="line-modified"> 94     bool updateConfiguration(const RenderLayer* compositingAncestor);</span>
 95 
 96     // Update graphics layer position and bounds.
<a name="4" id="anc4"></a><span class="line-modified"> 97     void updateGeometry(const RenderLayer* compositingAncestor);</span>
 98 
 99     // Update state the requires that descendant layers have been updated.
100     void updateAfterDescendants();
101 
102     // Update contents and clipping structure.
103     void updateDrawsContent();
104 
105     void updateAfterLayout(bool needsClippingUpdate, bool needsFullRepaint);
106 
107     GraphicsLayer* graphicsLayer() const { return m_graphicsLayer.get(); }
108 
109     // Layer to clip children
110     bool hasClippingLayer() const { return (m_childContainmentLayer &amp;&amp; !m_isFrameLayerWithTiledBacking); }
111     GraphicsLayer* clippingLayer() const { return !m_isFrameLayerWithTiledBacking ? m_childContainmentLayer.get() : nullptr; }
112 
113     bool hasAncestorClippingLayers() const { return !!m_ancestorClippingStack; }
114     LayerAncestorClippingStack* ancestorClippingStack() const { return m_ancestorClippingStack.get(); }
115     bool updateAncestorClippingStack(Vector&lt;CompositedClipData&gt;&amp;&amp;);
116 
117     GraphicsLayer* contentsContainmentLayer() const { return m_contentsContainmentLayer.get(); }
118 
119     GraphicsLayer* foregroundLayer() const { return m_foregroundLayer.get(); }
120     GraphicsLayer* backgroundLayer() const { return m_backgroundLayer.get(); }
121     bool backgroundLayerPaintsFixedRootBackground() const { return m_backgroundLayerPaintsFixedRootBackground; }
122 
123     bool requiresBackgroundLayer() const { return m_requiresBackgroundLayer; }
124     void setRequiresBackgroundLayer(bool);
125 
126     bool hasScrollingLayer() const { return m_scrollContainerLayer != nullptr; }
127     GraphicsLayer* scrollContainerLayer() const { return m_scrollContainerLayer.get(); }
128     GraphicsLayer* scrolledContentsLayer() const { return m_scrolledContentsLayer.get(); }
129 
130     void detachFromScrollingCoordinator(OptionSet&lt;ScrollCoordinationRole&gt;);
131 
132     ScrollingNodeID scrollingNodeIDForRole(ScrollCoordinationRole role) const
133     {
134         switch (role) {
135         case ScrollCoordinationRole::Scrolling:
136             return m_scrollingNodeID;
137         case ScrollCoordinationRole::ScrollingProxy:
138             // These nodeIDs are stored in m_ancestorClippingStack.
139             ASSERT_NOT_REACHED();
140             return 0;
141         case ScrollCoordinationRole::FrameHosting:
142             return m_frameHostingNodeID;
143         case ScrollCoordinationRole::ViewportConstrained:
144             return m_viewportConstrainedNodeID;
145         case ScrollCoordinationRole::Positioning:
146             return m_positioningNodeID;
147         }
148         return 0;
149     }
150 
151     void setScrollingNodeIDForRole(ScrollingNodeID nodeID, ScrollCoordinationRole role)
152     {
153         switch (role) {
154         case ScrollCoordinationRole::Scrolling:
155             m_scrollingNodeID = nodeID;
156             break;
157         case ScrollCoordinationRole::ScrollingProxy:
158             // These nodeIDs are stored in m_ancestorClippingStack.
159             ASSERT_NOT_REACHED();
160             break;
161         case ScrollCoordinationRole::FrameHosting:
162             m_frameHostingNodeID = nodeID;
163             break;
164         case ScrollCoordinationRole::ViewportConstrained:
165             m_viewportConstrainedNodeID = nodeID;
166             break;
167         case ScrollCoordinationRole::Positioning:
168             m_positioningNodeID = nodeID;
169             break;
170         }
171     }
172 
173     ScrollingNodeID scrollingNodeIDForChildren() const;
174 
175     bool hasMaskLayer() const { return m_maskLayer; }
176     bool hasChildClippingMaskLayer() const { return m_childClippingMaskLayer != nullptr; }
177 
178     GraphicsLayer* parentForSublayers() const;
179     GraphicsLayer* childForSuperlayers() const;
180 
181     // RenderLayers with backing normally short-circuit paintLayer() because
182     // their content is rendered via callbacks from GraphicsLayer. However, the document
183     // layer is special, because it has a GraphicsLayer to act as a container for the GraphicsLayers
184     // for descendants, but its contents usually render into the window (in which case this returns true).
185     // This returns false for other layers, and when the document layer actually needs to paint into its backing store
186     // for some reason.
187     bool paintsIntoWindow() const;
188 
189     // Returns true for a composited layer that has no backing store of its own, so
190     // paints into some ancestor layer.
191     bool paintsIntoCompositedAncestor() const { return !m_requiresOwnBackingStore; }
192 
193     void setRequiresOwnBackingStore(bool);
194 
195     void setContentsNeedDisplay(GraphicsLayer::ShouldClipToLayer = GraphicsLayer::ClipToLayer);
196     // r is in the coordinate space of the layer&#39;s render object
197     void setContentsNeedDisplayInRect(const LayoutRect&amp;, GraphicsLayer::ShouldClipToLayer = GraphicsLayer::ClipToLayer);
198 
199     // Notification from the renderer that its content changed.
200     void contentChanged(ContentChangeType);
201 
202     // Interface to start, finish, suspend and resume animations and transitions
203     bool startTransition(double, CSSPropertyID, const RenderStyle* fromStyle, const RenderStyle* toStyle);
204     void transitionPaused(double timeOffset, CSSPropertyID);
205     void transitionFinished(CSSPropertyID);
206 
207     bool startAnimation(double timeOffset, const Animation&amp;, const KeyframeList&amp;);
208     void animationPaused(double timeOffset, const String&amp; name);
209     void animationSeeked(double timeOffset, const String&amp; name);
210     void animationFinished(const String&amp; name);
211 
212     void suspendAnimations(MonotonicTime = MonotonicTime());
213     void resumeAnimations();
214 
215     LayoutRect compositedBounds() const;
216     // Returns true if changed.
217     bool setCompositedBounds(const LayoutRect&amp;);
218     // Returns true if changed.
219     bool updateCompositedBounds();
220 
221     void updateAllowsBackingStoreDetaching(const LayoutRect&amp; absoluteBounds);
222 
223     void updateEventRegion();
224 
225     void updateAfterWidgetResize();
226     void positionOverflowControlsLayers();
227 
228     bool isFrameLayerWithTiledBacking() const { return m_isFrameLayerWithTiledBacking; }
229 
230     WEBCORE_EXPORT TiledBacking* tiledBacking() const;
231     void adjustTiledBackingCoverage();
232     void setTiledBackingHasMargins(bool hasExtendedBackgroundOnLeftAndRight, bool hasExtendedBackgroundOnTopAndBottom);
233 
234     void updateDebugIndicators(bool showBorder, bool showRepaintCounter);
235     bool paintsSubpixelAntialiasedText() const { return m_paintsSubpixelAntialiasedText; }
236 
237     // GraphicsLayerClient interface
238     void tiledBackingUsageChanged(const GraphicsLayer*, bool /*usingTiledBacking*/) override;
239     void notifyAnimationStarted(const GraphicsLayer*, const String&amp; animationKey, MonotonicTime startTime) override;
240     void notifyFlushRequired(const GraphicsLayer*) override;
241     void notifyFlushBeforeDisplayRefresh(const GraphicsLayer*) override;
242 
<a name="5" id="anc5"></a><span class="line-modified">243     void paintContents(const GraphicsLayer*, GraphicsContext&amp;, const FloatRect&amp; clip, GraphicsLayerPaintBehavior) override;</span>
244 
245     float deviceScaleFactor() const override;
246     float contentsScaleMultiplierForNewTiles(const GraphicsLayer*) const override;
247 
248     bool paintsOpaquelyAtNonIntegralScales(const GraphicsLayer*) const override;
249 
250     float pageScaleFactor() const override;
251     float zoomedOutPageScaleFactor() const override;
252 
253     void didChangePlatformLayerForLayer(const GraphicsLayer*) override;
254     bool getCurrentTransform(const GraphicsLayer*, TransformationMatrix&amp;) const override;
255 
256     bool isTrackingRepaints() const override;
257     bool shouldSkipLayerInDump(const GraphicsLayer*, LayerTreeAsTextBehavior) const override;
258     bool shouldDumpPropertyForLayer(const GraphicsLayer*, const char* propertyName, LayerTreeAsTextBehavior) const override;
259 
260     bool shouldAggressivelyRetainTiles(const GraphicsLayer*) const override;
261     bool shouldTemporarilyRetainTileCohorts(const GraphicsLayer*) const override;
262     bool useGiantTiles() const override;
263     void logFilledVisibleFreshTile(unsigned) override;
264     bool needsPixelAligment() const override { return !m_isMainFrameRenderViewLayer; }
265 
266     LayoutSize subpixelOffsetFromRenderer() const { return m_subpixelOffsetFromRenderer; }
267 
268 #if PLATFORM(IOS_FAMILY)
269     bool needsIOSDumpRenderTreeMainFrameRenderViewLayerIsAlwaysOpaqueHack(const GraphicsLayer&amp;) const override;
270 #endif
271 
272 #ifndef NDEBUG
273     void verifyNotPainting() override;
274 #endif
275 
276     WEBCORE_EXPORT LayoutRect contentsBox() const;
277 
278     // For informative purposes only.
279     WEBCORE_EXPORT CompositingLayerType compositingLayerType() const;
280 
281     GraphicsLayer* layerForHorizontalScrollbar() const { return m_layerForHorizontalScrollbar.get(); }
282     GraphicsLayer* layerForVerticalScrollbar() const { return m_layerForVerticalScrollbar.get(); }
283     GraphicsLayer* layerForScrollCorner() const { return m_layerForScrollCorner.get(); }
284 
285     bool canCompositeFilters() const { return m_canCompositeFilters; }
286 #if ENABLE(FILTERS_LEVEL_2)
287     bool canCompositeBackdropFilters() const { return m_canCompositeBackdropFilters; }
288 #endif
289 
290     // Return an estimate of the backing store area (in pixels) allocated by this object&#39;s GraphicsLayers.
291     WEBCORE_EXPORT double backingStoreMemoryEstimate() const;
292 
293     // For testing only.
294     WEBCORE_EXPORT void setUsesDisplayListDrawing(bool);
295     WEBCORE_EXPORT String displayListAsText(DisplayList::AsTextFlags) const;
296 
297     WEBCORE_EXPORT void setIsTrackingDisplayListReplay(bool);
298     WEBCORE_EXPORT String replayDisplayListAsText(DisplayList::AsTextFlags) const;
299 
300 private:
301     friend class PaintedContentsInfo;
302 
303     FloatRect backgroundBoxForSimpleContainerPainting() const;
304 
305     void createPrimaryGraphicsLayer();
306     void destroyGraphicsLayers();
307 
308     void willDestroyLayer(const GraphicsLayer*);
309 
310     LayoutRect compositedBoundsIncludingMargin() const;
311 
312     Ref&lt;GraphicsLayer&gt; createGraphicsLayer(const String&amp;, GraphicsLayer::Type = GraphicsLayer::Type::Normal);
313 
314     RenderLayerModelObject&amp; renderer() const { return m_owningLayer.renderer(); }
315     RenderBox* renderBox() const { return m_owningLayer.renderBox(); }
316     RenderLayerCompositor&amp; compositor() const { return m_owningLayer.compositor(); }
317 
318     void updateInternalHierarchy();
319     bool updateAncestorClipping(bool needsAncestorClip, const RenderLayer* compositingAncestor);
320     bool updateDescendantClippingLayer(bool needsDescendantClip);
321     bool updateOverflowControlsLayers(bool needsHorizontalScrollbarLayer, bool needsVerticalScrollbarLayer, bool needsScrollCornerLayer);
322     bool updateForegroundLayer(bool needsForegroundLayer);
323     bool updateBackgroundLayer(bool needsBackgroundLayer);
324     bool updateMaskingLayer(bool hasMask, bool hasClipPath);
325     bool requiresHorizontalScrollbarLayer() const;
326     bool requiresVerticalScrollbarLayer() const;
327     bool requiresScrollCornerLayer() const;
328     bool updateScrollingLayers(bool scrollingLayers);
329 
330     void updateScrollOffset(ScrollOffset);
331     void setLocationOfScrolledContents(ScrollOffset, ScrollingLayerPositionAction);
332 
333     void updateChildClippingStrategy(bool needsDescendantsClippingLayer);
334     void updateMaskingLayerGeometry();
335     void updateRootLayerConfiguration();
336     void updatePaintingPhases();
337 
338     void setBackgroundLayerPaintsFixedRootBackground(bool);
339 
340     LayoutSize contentOffsetInCompositingLayer() const;
341     // Result is transform origin in device pixels.
342     FloatPoint3D computeTransformOriginForPainting(const LayoutRect&amp; borderBox) const;
343 
344     void updateOpacity(const RenderStyle&amp;);
345     void updateTransform(const RenderStyle&amp;);
346     void updateFilters(const RenderStyle&amp;);
347 #if ENABLE(FILTERS_LEVEL_2)
348     void updateBackdropFilters(const RenderStyle&amp;);
349     void updateBackdropFiltersGeometry();
350 #endif
351 #if ENABLE(CSS_COMPOSITING)
352     void updateBlendMode(const RenderStyle&amp;);
353 #endif
354     void updateCustomAppearance(const RenderStyle&amp;);
355 
356     // Return the opacity value that this layer should use for compositing.
357     float compositingOpacity(float rendererOpacity) const;
358     Color rendererBackgroundColor() const;
359 
360     bool isMainFrameRenderViewLayer() const;
361 
362     bool paintsBoxDecorations() const;
363     bool paintsContent(RenderLayer::PaintedContentRequest&amp;) const;
364 
365     void updateDrawsContent(PaintedContentsInfo&amp;);
366 
367     // Returns true if this compositing layer has no visible content.
368     bool isSimpleContainerCompositingLayer(PaintedContentsInfo&amp;) const;
369     // Returns true if this layer has content that needs to be rendered by painting into the backing store.
370     bool containsPaintedContent(PaintedContentsInfo&amp;) const;
371     // Returns true if the RenderLayer just contains an image that we can composite directly.
372     bool isDirectlyCompositedImage() const;
373     void updateImageContents(PaintedContentsInfo&amp;);
374 
375     void updateDirectlyCompositedBoxDecorations(PaintedContentsInfo&amp;, bool&amp; didUpdateContentsRect);
376     void updateDirectlyCompositedBackgroundColor(PaintedContentsInfo&amp;, bool&amp; didUpdateContentsRect);
377     void updateDirectlyCompositedBackgroundImage(PaintedContentsInfo&amp;, bool&amp; didUpdateContentsRect);
378 
379     void resetContentsRect();
380 
381     bool isPaintDestinationForDescendantLayers(RenderLayer::PaintedContentRequest&amp;) const;
382     bool hasVisibleNonCompositedDescendants() const;
383 
384     bool shouldClipCompositedBounds() const;
385 
386     bool hasTiledBackingFlatteningLayer() const { return (m_childContainmentLayer &amp;&amp; m_isFrameLayerWithTiledBacking); }
387     GraphicsLayer* tileCacheFlatteningLayer() const { return m_isFrameLayerWithTiledBacking ? m_childContainmentLayer.get() : nullptr; }
388 
<a name="6" id="anc6"></a><span class="line-modified">389     void paintIntoLayer(const GraphicsLayer*, GraphicsContext&amp;, const IntRect&amp; paintDirtyRect, OptionSet&lt;PaintBehavior&gt;, EventRegionContext* = nullptr);</span>
<span class="line-added">390     OptionSet&lt;RenderLayer::PaintLayerFlag&gt; paintFlagsForLayer(const GraphicsLayer&amp;) const;</span>
391 
392     void paintDebugOverlays(const GraphicsLayer*, GraphicsContext&amp;);
393 
394     static CSSPropertyID graphicsLayerToCSSProperty(AnimatedPropertyID);
395     static AnimatedPropertyID cssToGraphicsLayerProperty(CSSPropertyID);
396 
397     bool canIssueSetNeedsDisplay() const { return !paintsIntoWindow() &amp;&amp; !paintsIntoCompositedAncestor(); }
398     LayoutRect computeParentGraphicsLayerRect(const RenderLayer* compositedAncestor) const;
<a name="7" id="anc7"></a><span class="line-modified">399     LayoutRect computePrimaryGraphicsLayerRect(const RenderLayer* compositedAncestor, const LayoutRect&amp; parentGraphicsLayerRect) const;</span>
400 
<a name="8" id="anc8"></a><span class="line-added">401 #if USE(OWNING_LAYER_BEAR_TRAP)</span>
<span class="line-added">402     uintptr_t m_owningLayerBearTrap { BEAR_TRAP_VALUE }; // webkit.org/b.206915</span>
<span class="line-added">403 #endif</span>
404     RenderLayer&amp; m_owningLayer;
405 
406     // A list other layers that paint into this backing store, later than m_owningLayer in paint order.
407     Vector&lt;WeakPtr&lt;RenderLayer&gt;&gt; m_backingSharingLayers;
408 
409     std::unique_ptr&lt;LayerAncestorClippingStack&gt; m_ancestorClippingStack; // Only used if we are clipped by an ancestor which is not a stacking context.
410 
411     RefPtr&lt;GraphicsLayer&gt; m_contentsContainmentLayer; // Only used if we have a background layer; takes the transform.
412     RefPtr&lt;GraphicsLayer&gt; m_graphicsLayer;
413     RefPtr&lt;GraphicsLayer&gt; m_foregroundLayer; // Only used in cases where we need to draw the foreground separately.
414     RefPtr&lt;GraphicsLayer&gt; m_backgroundLayer; // Only used in cases where we need to draw the background separately.
415     RefPtr&lt;GraphicsLayer&gt; m_childContainmentLayer; // Only used if we have clipping on a stacking context with compositing children, or if the layer has a tile cache.
416     RefPtr&lt;GraphicsLayer&gt; m_maskLayer; // Only used if we have a mask and/or clip-path.
417     RefPtr&lt;GraphicsLayer&gt; m_childClippingMaskLayer; // Only used if we have to clip child layers or accelerated contents with border radius or clip-path.
418 
419     RefPtr&lt;GraphicsLayer&gt; m_layerForHorizontalScrollbar;
420     RefPtr&lt;GraphicsLayer&gt; m_layerForVerticalScrollbar;
421     RefPtr&lt;GraphicsLayer&gt; m_layerForScrollCorner;
422 
423     RefPtr&lt;GraphicsLayer&gt; m_scrollContainerLayer; // Only used if the layer is using composited scrolling.
424     RefPtr&lt;GraphicsLayer&gt; m_scrolledContentsLayer; // Only used if the layer is using composited scrolling.
425 
426     LayoutRect m_compositedBounds;
427     LayoutSize m_subpixelOffsetFromRenderer; // This is the subpixel distance between the primary graphics layer and the associated renderer&#39;s bounds.
428     LayoutSize m_compositedBoundsOffsetFromGraphicsLayer; // This is the subpixel distance between the primary graphics layer and the render layer bounds.
429 
430     ScrollingNodeID m_viewportConstrainedNodeID { 0 };
431     ScrollingNodeID m_scrollingNodeID { 0 };
432     ScrollingNodeID m_frameHostingNodeID { 0 };
433     ScrollingNodeID m_positioningNodeID { 0 };
434 
435     bool m_artificiallyInflatedBounds { false }; // bounds had to be made non-zero to make transform-origin work
436     bool m_isMainFrameRenderViewLayer { false };
437     bool m_isFrameLayerWithTiledBacking { false };
438     bool m_requiresOwnBackingStore { true };
439     bool m_canCompositeFilters { false };
440 #if ENABLE(FILTERS_LEVEL_2)
441     bool m_canCompositeBackdropFilters { false };
442 #endif
443     bool m_backgroundLayerPaintsFixedRootBackground { false };
444     bool m_requiresBackgroundLayer { false };
445     bool m_hasSubpixelRounding { false };
446     bool m_paintsSubpixelAntialiasedText { false }; // This is for logging only.
447 };
448 
449 enum CanvasCompositingStrategy {
450     UnacceleratedCanvas,
451     CanvasPaintedToLayer,
452     CanvasAsLayerContents
453 };
454 CanvasCompositingStrategy canvasCompositingStrategy(const RenderObject&amp;);
455 
456 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const RenderLayerBacking&amp;);
457 
458 } // namespace WebCore
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
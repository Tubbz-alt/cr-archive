diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/ThreadSafeRefCounted.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/ThreadSafeRefCounted.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/ThreadSafeRefCounted.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/ThreadSafeRefCounted.h
@@ -30,23 +30,43 @@
 #include <wtf/MainThread.h>
 #include <wtf/Noncopyable.h>
 
 namespace WTF {
 
+#if defined(NDEBUG) && !ENABLE(SECURITY_ASSERTIONS)
+#define CHECK_THREAD_SAFE_REF_COUNTED_LIFECYCLE 0
+#else
+#define CHECK_THREAD_SAFE_REF_COUNTED_LIFECYCLE 1
+#endif
+
 class ThreadSafeRefCountedBase {
     WTF_MAKE_NONCOPYABLE(ThreadSafeRefCountedBase);
     WTF_MAKE_FAST_ALLOCATED;
 public:
     ThreadSafeRefCountedBase() = default;
 
+#if CHECK_THREAD_SAFE_REF_COUNTED_LIFECYCLE
+    ~ThreadSafeRefCountedBase()
+    {
+        // When this ThreadSafeRefCounted object is a part of another object, derefBase() is never called on this object.
+        m_deletionHasBegun = true;
+    }
+#endif
+
     void ref() const
     {
+#if CHECK_THREAD_SAFE_REF_COUNTED_LIFECYCLE
+        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);
+#endif
         ++m_refCount;
     }
 
     bool hasOneRef() const
     {
+#if CHECK_THREAD_SAFE_REF_COUNTED_LIFECYCLE
+        ASSERT(!m_deletionHasBegun);
+#endif
         return refCount() == 1;
     }
 
     unsigned refCount() const
     {
@@ -55,15 +75,35 @@
 
 protected:
     // Returns whether the pointer should be freed or not.
     bool derefBase() const
     {
-        return !--m_refCount;
+        ASSERT(m_refCount);
+
+#if CHECK_THREAD_SAFE_REF_COUNTED_LIFECYCLE
+        ASSERT_WITH_SECURITY_IMPLICATION(!m_deletionHasBegun);
+#endif
+
+        if (UNLIKELY(!--m_refCount)) {
+            // Setting m_refCount to 1 here prevents double delete within the destructor but not from another thread
+            // since such a thread could have ref'ed this object long after it had been deleted. See webkit.org/b/201576.
+            m_refCount = 1;
+#if CHECK_THREAD_SAFE_REF_COUNTED_LIFECYCLE
+            m_deletionHasBegun = true;
+#endif
+            return true;
+        }
+
+        return false;
     }
 
 private:
     mutable std::atomic<unsigned> m_refCount { 1 };
+
+#if CHECK_THREAD_SAFE_REF_COUNTED_LIFECYCLE
+    mutable std::atomic<bool> m_deletionHasBegun { false };
+#endif
 };
 
 enum class DestructionThread { Any, Main, MainRunLoop };
 
 template<class T, DestructionThread destructionThread = DestructionThread::Any> class ThreadSafeRefCounted : public ThreadSafeRefCountedBase {

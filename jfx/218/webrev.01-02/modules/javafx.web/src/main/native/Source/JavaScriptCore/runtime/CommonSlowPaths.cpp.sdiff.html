<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CommonIdentifiers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CommonSlowPaths.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/CommonSlowPaths.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  29 #include &quot;ArithProfile.h&quot;
  30 #include &quot;ArrayConstructor.h&quot;
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;BytecodeStructs.h&quot;
  33 #include &quot;CallFrame.h&quot;
  34 #include &quot;ClonedArguments.h&quot;
  35 #include &quot;CodeProfiling.h&quot;
  36 #include &quot;DefinePropertyAttributes.h&quot;
  37 #include &quot;DirectArguments.h&quot;
  38 #include &quot;Error.h&quot;
  39 #include &quot;ErrorHandlingScope.h&quot;
  40 #include &quot;ExceptionFuzz.h&quot;
  41 #include &quot;FrameTracers.h&quot;
  42 #include &quot;GetterSetter.h&quot;
  43 #include &quot;HostCallReturnValue.h&quot;
  44 #include &quot;ICStats.h&quot;
  45 #include &quot;Interpreter.h&quot;
  46 #include &quot;IteratorOperations.h&quot;
  47 #include &quot;JIT.h&quot;
  48 #include &quot;JSArrayInlines.h&quot;

  49 #include &quot;JSCInlines.h&quot;
  50 #include &quot;JSCJSValue.h&quot;
<span class="line-removed">  51 #include &quot;JSFixedArray.h&quot;</span>
  52 #include &quot;JSGlobalObjectFunctions.h&quot;
  53 #include &quot;JSImmutableButterfly.h&quot;


  54 #include &quot;JSLexicalEnvironment.h&quot;

  55 #include &quot;JSPropertyNameEnumerator.h&quot;
  56 #include &quot;JSString.h&quot;
  57 #include &quot;JSWithScope.h&quot;
  58 #include &quot;LLIntCommon.h&quot;
  59 #include &quot;LLIntExceptions.h&quot;
  60 #include &quot;LowLevelInterpreter.h&quot;
  61 #include &quot;MathCommon.h&quot;
  62 #include &quot;ObjectConstructor.h&quot;
  63 #include &quot;OpcodeInlines.h&quot;
  64 #include &quot;ScopedArguments.h&quot;
  65 #include &quot;StructureRareDataInlines.h&quot;
  66 #include &quot;ThunkGenerators.h&quot;
  67 #include &quot;TypeProfilerLog.h&quot;
  68 #include &lt;wtf/StringPrintStream.h&gt;
  69 #include &lt;wtf/Variant.h&gt;
  70 
  71 namespace JSC {
  72 
  73 #define BEGIN_NO_SET_PC() \
<span class="line-modified">  74     VM&amp; vm = exec-&gt;vm();      \</span>
<span class="line-modified">  75     NativeCallFrameTracer tracer(vm, exec); \</span>


  76     auto throwScope = DECLARE_THROW_SCOPE(vm); \
  77     UNUSED_PARAM(throwScope)
  78 
  79 #ifndef NDEBUG
  80 #define SET_PC_FOR_STUBS() do { \
<span class="line-modified">  81         exec-&gt;codeBlock()-&gt;bytecodeOffset(pc); \</span>
<span class="line-modified">  82         exec-&gt;setCurrentVPC(pc); \</span>
  83     } while (false)
  84 #else
  85 #define SET_PC_FOR_STUBS() do { \
<span class="line-modified">  86         exec-&gt;setCurrentVPC(pc); \</span>
  87     } while (false)
  88 #endif
  89 
<span class="line-modified">  90 #define RETURN_TO_THROW(exec, pc)   pc = LLInt::returnToThrow(exec)</span>
  91 
  92 #define BEGIN()                           \
  93     BEGIN_NO_SET_PC();                    \
  94     SET_PC_FOR_STUBS()
  95 
<span class="line-modified">  96 #define GET(operand) (exec-&gt;uncheckedR(operand.offset()))</span>
<span class="line-modified">  97 #define GET_C(operand) (exec-&gt;r(operand.offset()))</span>
  98 
  99 #define RETURN_TWO(first, second) do {       \
 100         return encodeResult(first, second);        \
 101     } while (false)
 102 
<span class="line-modified"> 103 #define END_IMPL() RETURN_TWO(pc, exec)</span>
 104 
 105 #define THROW(exceptionToThrow) do {                        \
<span class="line-modified"> 106         throwException(exec, throwScope, exceptionToThrow); \</span>
<span class="line-modified"> 107         RETURN_TO_THROW(exec, pc);                          \</span>
 108         END_IMPL();                                         \
 109     } while (false)
 110 
 111 #define CHECK_EXCEPTION() do {                    \
<span class="line-modified"> 112         doExceptionFuzzingIfEnabled(exec, throwScope, &quot;CommonSlowPaths&quot;, pc);   \</span>
 113         if (UNLIKELY(throwScope.exception())) {   \
<span class="line-modified"> 114             RETURN_TO_THROW(exec, pc);            \</span>
 115             END_IMPL();                           \
 116         }                                         \
 117     } while (false)
 118 
 119 #define END() do {                        \
 120         CHECK_EXCEPTION();                \
 121         END_IMPL();                       \
 122     } while (false)
 123 
 124 #define BRANCH(condition) do {                      \
 125         bool bCondition = (condition);                         \
 126         CHECK_EXCEPTION();                                  \
 127         if (bCondition)                                        \
 128             pc = bytecode.m_targetLabel \
 129                 ? reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + bytecode.m_targetLabel) \
<span class="line-modified"> 130                 : exec-&gt;codeBlock()-&gt;outOfLineJumpTarget(pc);                              \</span>
 131         else                                                      \
 132             pc = reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + pc-&gt;size()); \
 133         END_IMPL();                                         \
 134     } while (false)
 135 
 136 #define RETURN_WITH_PROFILING_CUSTOM(result__, value__, profilingAction__) do { \
 137         JSValue returnValue__ = (value__);  \
 138         CHECK_EXCEPTION();                  \
 139         GET(result__) = returnValue__;              \
 140         profilingAction__;                  \
 141         END_IMPL();                         \
 142     } while (false)
 143 
 144 #define RETURN_WITH_PROFILING(value__, profilingAction__) RETURN_WITH_PROFILING_CUSTOM(bytecode.m_dst, value__, profilingAction__)
 145 
 146 #define RETURN(value) \
 147     RETURN_WITH_PROFILING(value, { })
 148 
 149 #define RETURN_PROFILED(value__) \
 150     RETURN_WITH_PROFILING(value__, PROFILE_VALUE(returnValue__))
 151 
 152 #define PROFILE_VALUE(value) do { \
<span class="line-modified"> 153         bytecode.metadata(exec).m_profile.m_buckets[0] = JSValue::encode(value); \</span>
 154     } while (false)
 155 
<span class="line-modified"> 156 #define CALL_END_IMPL(exec, callTarget, callTargetTag) \</span>
<span class="line-removed"> 157     RETURN_TWO(retagCodePtr((callTarget), callTargetTag, SlowPathPtrTag), (exec))</span>
<span class="line-removed"> 158 </span>
<span class="line-removed"> 159 #define CALL_CHECK_EXCEPTION(exec, pc) do {                          \</span>
<span class="line-removed"> 160         ExecState* cceExec = (exec);                                 \</span>
<span class="line-removed"> 161         Instruction* ccePC = (pc);                                   \</span>
<span class="line-removed"> 162         if (UNLIKELY(throwScope.exception()))                        \</span>
<span class="line-removed"> 163             CALL_END_IMPL(cceExec, LLInt::callToThrow(cceExec), ExceptionHandlerPtrTag); \</span>
<span class="line-removed"> 164     } while (false)</span>
<span class="line-removed"> 165 </span>
<span class="line-removed"> 166 static void throwArityCheckStackOverflowError(ExecState* exec, ThrowScope&amp; scope)</span>
 167 {
<span class="line-modified"> 168     JSObject* error = createStackOverflowError(exec);</span>
<span class="line-modified"> 169     throwException(exec, scope, error);</span>
 170 #if LLINT_TRACING
 171     if (UNLIKELY(Options::traceLLIntSlowPath()))
 172         dataLog(&quot;Throwing exception &quot;, JSValue(scope.exception()), &quot;.\n&quot;);
 173 #endif
 174 }
 175 
 176 SLOW_PATH_DECL(slow_path_call_arityCheck)
 177 {
 178     BEGIN();
<span class="line-modified"> 179     int slotsToAdd = CommonSlowPaths::arityCheckFor(exec, vm, CodeForCall);</span>
 180     if (UNLIKELY(slotsToAdd &lt; 0)) {
<span class="line-modified"> 181         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForCall);</span>
<span class="line-modified"> 182         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified"> 183         NativeCallFrameTracer tracer(vm, exec);</span>
 184         ErrorHandlingScope errorScope(vm);
 185         throwScope.release();
<span class="line-modified"> 186         throwArityCheckStackOverflowError(exec, throwScope);</span>
<span class="line-modified"> 187         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), exec);</span>
 188     }
 189     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 190 }
 191 
 192 SLOW_PATH_DECL(slow_path_construct_arityCheck)
 193 {
 194     BEGIN();
<span class="line-modified"> 195     int slotsToAdd = CommonSlowPaths::arityCheckFor(exec, vm, CodeForConstruct);</span>
 196     if (UNLIKELY(slotsToAdd &lt; 0)) {
<span class="line-modified"> 197         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(exec, CodeForConstruct);</span>
<span class="line-modified"> 198         exec-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified"> 199         NativeCallFrameTracer tracer(vm, exec);</span>
 200         ErrorHandlingScope errorScope(vm);
<span class="line-modified"> 201         throwArityCheckStackOverflowError(exec, throwScope);</span>
<span class="line-modified"> 202         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), exec);</span>
 203     }
 204     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 205 }
 206 
 207 SLOW_PATH_DECL(slow_path_create_direct_arguments)
 208 {
 209     BEGIN();
 210     auto bytecode = pc-&gt;as&lt;OpCreateDirectArguments&gt;();
<span class="line-modified"> 211     RETURN(DirectArguments::createByCopying(exec));</span>
 212 }
 213 
 214 SLOW_PATH_DECL(slow_path_create_scoped_arguments)
 215 {
 216     BEGIN();
 217     auto bytecode = pc-&gt;as&lt;OpCreateScopedArguments&gt;();
 218     JSLexicalEnvironment* scope = jsCast&lt;JSLexicalEnvironment*&gt;(GET(bytecode.m_scope).jsValue());
 219     ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
<span class="line-modified"> 220     RETURN(ScopedArguments::createByCopying(exec, table, scope));</span>
 221 }
 222 
 223 SLOW_PATH_DECL(slow_path_create_cloned_arguments)
 224 {
 225     BEGIN();
 226     auto bytecode = pc-&gt;as&lt;OpCreateClonedArguments&gt;();
<span class="line-modified"> 227     RETURN(ClonedArguments::createWithMachineFrame(exec, exec, ArgumentsMode::Cloned));</span>













 228 }
 229 
 230 SLOW_PATH_DECL(slow_path_create_this)
 231 {
 232     BEGIN();
 233     auto bytecode = pc-&gt;as&lt;OpCreateThis&gt;();
 234     JSObject* result;
 235     JSObject* constructorAsObject = asObject(GET(bytecode.m_callee).jsValue());
<span class="line-modified"> 236     if (constructorAsObject-&gt;type() == JSFunctionType &amp;&amp; jsCast&lt;JSFunction*&gt;(constructorAsObject)-&gt;canUseAllocationProfile()) {</span>
<span class="line-modified"> 237         JSFunction* constructor = jsCast&lt;JSFunction*&gt;(constructorAsObject);</span>
<span class="line-modified"> 238         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(exec).m_cachedCallee;</span>
 239         if (!cachedCallee)
<span class="line-modified"> 240             cachedCallee.set(vm, exec-&gt;codeBlock(), constructor);</span>
 241         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)
 242             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());
 243 
 244         size_t inlineCapacity = bytecode.m_inlineCapacity;
<span class="line-modified"> 245         ObjectAllocationProfileWithPrototype* allocationProfile = constructor-&gt;ensureRareDataAndAllocationProfile(exec, inlineCapacity)-&gt;objectAllocationProfile();</span>
 246         throwScope.releaseAssertNoException();
 247         Structure* structure = allocationProfile-&gt;structure();
<span class="line-modified"> 248         result = constructEmptyObject(exec, structure);</span>
 249         if (structure-&gt;hasPolyProto()) {
 250             JSObject* prototype = allocationProfile-&gt;prototype();
<span class="line-modified"> 251             ASSERT(prototype == constructor-&gt;prototypeForConstruction(vm, exec));</span>
 252             result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
 253             prototype-&gt;didBecomePrototype();
 254             ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
 255         }
 256     } else {
 257         // http://ecma-international.org/ecma-262/6.0/#sec-ordinarycreatefromconstructor
<span class="line-modified"> 258         JSValue proto = constructorAsObject-&gt;get(exec, vm.propertyNames-&gt;prototype);</span>
 259         CHECK_EXCEPTION();
 260         if (proto.isObject())
<span class="line-modified"> 261             result = constructEmptyObject(exec, asObject(proto));</span>
 262         else
<span class="line-modified"> 263             result = constructEmptyObject(exec);</span>
 264     }
 265     RETURN(result);
 266 }
 267 


















































































 268 SLOW_PATH_DECL(slow_path_to_this)
 269 {
 270     BEGIN();
 271     auto bytecode = pc-&gt;as&lt;OpToThis&gt;();
<span class="line-modified"> 272     auto&amp; metadata = bytecode.metadata(exec);</span>
 273     JSValue v1 = GET(bytecode.m_srcDst).jsValue();
 274     if (v1.isCell()) {
 275         StructureID myStructureID = v1.asCell()-&gt;structureID();
 276         StructureID otherStructureID = metadata.m_cachedStructureID;
 277         if (myStructureID != otherStructureID) {
 278             if (otherStructureID)
 279                 metadata.m_toThisStatus = ToThisConflicted;
 280             metadata.m_cachedStructureID = myStructureID;
<span class="line-modified"> 281             vm.heap.writeBarrier(exec-&gt;codeBlock(), vm.getStructure(myStructureID));</span>
 282         }
 283     } else {
 284         metadata.m_toThisStatus = ToThisConflicted;
 285         metadata.m_cachedStructureID = 0;
 286     }
 287     // Note: We only need to do this value profiling here on the slow path. The fast path
 288     // just returns the input to to_this if the structure check succeeds. If the structure
 289     // check succeeds, doing value profiling here is equivalent to doing it with a potentially
 290     // different object that still has the same structure on the fast path since it&#39;ll produce
 291     // the same SpeculatedType. Therefore, we don&#39;t need to worry about value profiling on the
 292     // fast path.
<span class="line-modified"> 293     auto value = v1.toThis(exec, exec-&gt;codeBlock()-&gt;isStrictMode() ? StrictMode : NotStrictMode);</span>
 294     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, value, PROFILE_VALUE(value));
 295 }
 296 
 297 SLOW_PATH_DECL(slow_path_throw_tdz_error)
 298 {
 299     BEGIN();
<span class="line-modified"> 300     THROW(createTDZError(exec));</span>
 301 }
 302 
 303 SLOW_PATH_DECL(slow_path_check_tdz)
 304 {
 305     BEGIN();
<span class="line-modified"> 306     THROW(createTDZError(exec));</span>
 307 }
 308 
 309 SLOW_PATH_DECL(slow_path_throw_strict_mode_readonly_property_write_error)
 310 {
 311     BEGIN();
<span class="line-modified"> 312     THROW(createTypeError(exec, ReadonlyPropertyWriteError));</span>
 313 }
 314 
 315 SLOW_PATH_DECL(slow_path_not)
 316 {
 317     BEGIN();
 318     auto bytecode = pc-&gt;as&lt;OpNot&gt;();
<span class="line-modified"> 319     RETURN(jsBoolean(!GET_C(bytecode.m_operand).jsValue().toBoolean(exec)));</span>
 320 }
 321 
 322 SLOW_PATH_DECL(slow_path_eq)
 323 {
 324     BEGIN();
 325     auto bytecode = pc-&gt;as&lt;OpEq&gt;();
<span class="line-modified"> 326     RETURN(jsBoolean(JSValue::equal(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 327 }
 328 
 329 SLOW_PATH_DECL(slow_path_neq)
 330 {
 331     BEGIN();
 332     auto bytecode = pc-&gt;as&lt;OpNeq&gt;();
<span class="line-modified"> 333     RETURN(jsBoolean(!JSValue::equal(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 334 }
 335 
 336 SLOW_PATH_DECL(slow_path_stricteq)
 337 {
 338     BEGIN();
 339     auto bytecode = pc-&gt;as&lt;OpStricteq&gt;();
<span class="line-modified"> 340     RETURN(jsBoolean(JSValue::strictEqual(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 341 }
 342 
 343 SLOW_PATH_DECL(slow_path_nstricteq)
 344 {
 345     BEGIN();
 346     auto bytecode = pc-&gt;as&lt;OpNstricteq&gt;();
<span class="line-modified"> 347     RETURN(jsBoolean(!JSValue::strictEqual(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 348 }
 349 
 350 SLOW_PATH_DECL(slow_path_less)
 351 {
 352     BEGIN();
 353     auto bytecode = pc-&gt;as&lt;OpLess&gt;();
<span class="line-modified"> 354     RETURN(jsBoolean(jsLess&lt;true&gt;(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 355 }
 356 
 357 SLOW_PATH_DECL(slow_path_lesseq)
 358 {
 359     BEGIN();
 360     auto bytecode = pc-&gt;as&lt;OpLesseq&gt;();
<span class="line-modified"> 361     RETURN(jsBoolean(jsLessEq&lt;true&gt;(exec, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 362 }
 363 
 364 SLOW_PATH_DECL(slow_path_greater)
 365 {
 366     BEGIN();
 367     auto bytecode = pc-&gt;as&lt;OpGreater&gt;();
<span class="line-modified"> 368     RETURN(jsBoolean(jsLess&lt;false&gt;(exec, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));</span>
 369 }
 370 
 371 SLOW_PATH_DECL(slow_path_greatereq)
 372 {
 373     BEGIN();
 374     auto bytecode = pc-&gt;as&lt;OpGreatereq&gt;();
<span class="line-modified"> 375     RETURN(jsBoolean(jsLessEq&lt;false&gt;(exec, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));</span>
 376 }
 377 
 378 SLOW_PATH_DECL(slow_path_inc)
 379 {
 380     BEGIN();
 381     auto bytecode = pc-&gt;as&lt;OpInc&gt;();
<span class="line-modified"> 382     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, jsNumber(GET(bytecode.m_srcDst).jsValue().toNumber(exec) + 1), { });</span>








 383 }
 384 
 385 SLOW_PATH_DECL(slow_path_dec)
 386 {
 387     BEGIN();
 388     auto bytecode = pc-&gt;as&lt;OpDec&gt;();
<span class="line-modified"> 389     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, jsNumber(GET(bytecode.m_srcDst).jsValue().toNumber(exec) - 1), { });</span>








 390 }
 391 
 392 SLOW_PATH_DECL(slow_path_to_string)
 393 {
 394     BEGIN();
 395     auto bytecode = pc-&gt;as&lt;OpToString&gt;();
<span class="line-modified"> 396     RETURN(GET_C(bytecode.m_operand).jsValue().toString(exec));</span>
 397 }
 398 
 399 #if ENABLE(JIT)
 400 static void updateArithProfileForUnaryArithOp(OpNegate::Metadata&amp; metadata, JSValue result, JSValue operand)
 401 {
<span class="line-modified"> 402     ArithProfile&amp; profile = metadata.m_arithProfile;</span>
<span class="line-modified"> 403     profile.observeLHS(operand);</span>
 404     ASSERT(result.isNumber() || result.isBigInt());
 405     if (result.isNumber()) {
 406         if (!result.isInt32()) {
 407             if (operand.isInt32())
 408                 profile.setObservedInt32Overflow();
 409 
 410             double doubleVal = result.asNumber();
 411             if (!doubleVal &amp;&amp; std::signbit(doubleVal))
 412                 profile.setObservedNegZeroDouble();
 413             else {
 414                 profile.setObservedNonNegZeroDouble();
 415 
 416                 // The Int52 overflow check here intentionally omits 1ll &lt;&lt; 51 as a valid negative Int52 value.
 417                 // Therefore, we will get a false positive if the result is that value. This is intentionally
 418                 // done to simplify the checking algorithm.
 419                 static const int64_t int52OverflowPoint = (1ll &lt;&lt; 51);
 420                 int64_t int64Val = static_cast&lt;int64_t&gt;(std::abs(doubleVal));
 421                 if (int64Val &gt;= int52OverflowPoint)
 422                     profile.setObservedInt52Overflow();
 423             }
 424         }
 425     } else if (result.isBigInt())
 426         profile.setObservedBigInt();
 427     else
 428         profile.setObservedNonNumeric();
 429 }
 430 #else
 431 static void updateArithProfileForUnaryArithOp(OpNegate::Metadata&amp;, JSValue, JSValue) { }
 432 #endif
 433 
 434 SLOW_PATH_DECL(slow_path_negate)
 435 {
 436     BEGIN();
 437     auto bytecode = pc-&gt;as&lt;OpNegate&gt;();
<span class="line-modified"> 438     auto&amp; metadata = bytecode.metadata(exec);</span>
 439     JSValue operand = GET_C(bytecode.m_operand).jsValue();
<span class="line-modified"> 440     JSValue primValue = operand.toPrimitive(exec, PreferNumber);</span>
 441     CHECK_EXCEPTION();
 442 
 443     if (primValue.isBigInt()) {
 444         JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
 445         RETURN_WITH_PROFILING(result, {
 446             updateArithProfileForUnaryArithOp(metadata, result, operand);
 447         });
 448     }
 449 
<span class="line-modified"> 450     JSValue result = jsNumber(-primValue.toNumber(exec));</span>
 451     CHECK_EXCEPTION();
 452     RETURN_WITH_PROFILING(result, {
 453         updateArithProfileForUnaryArithOp(metadata, result, operand);
 454     });
 455 }
 456 
 457 #if ENABLE(DFG_JIT)
<span class="line-modified"> 458 static void updateArithProfileForBinaryArithOp(ExecState* exec, const Instruction* pc, JSValue result, JSValue left, JSValue right)</span>
 459 {
<span class="line-modified"> 460     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
<span class="line-removed"> 461     ArithProfile&amp; profile = *codeBlock-&gt;arithProfileForPC(pc);</span>
 462 
 463     if (result.isNumber()) {
 464         if (!result.isInt32()) {
 465             if (left.isInt32() &amp;&amp; right.isInt32())
 466                 profile.setObservedInt32Overflow();
 467 
 468             double doubleVal = result.asNumber();
 469             if (!doubleVal &amp;&amp; std::signbit(doubleVal))
 470                 profile.setObservedNegZeroDouble();
 471             else {
 472                 profile.setObservedNonNegZeroDouble();
 473 
 474                 // The Int52 overflow check here intentionally omits 1ll &lt;&lt; 51 as a valid negative Int52 value.
 475                 // Therefore, we will get a false positive if the result is that value. This is intentionally
 476                 // done to simplify the checking algorithm.
 477                 static const int64_t int52OverflowPoint = (1ll &lt;&lt; 51);
 478                 int64_t int64Val = static_cast&lt;int64_t&gt;(std::abs(doubleVal));
 479                 if (int64Val &gt;= int52OverflowPoint)
 480                     profile.setObservedInt52Overflow();
 481             }
 482         }
 483     } else if (result.isBigInt())
 484         profile.setObservedBigInt();
 485     else
 486         profile.setObservedNonNumeric();
 487 }
 488 #else
<span class="line-modified"> 489 static void updateArithProfileForBinaryArithOp(ExecState*, const Instruction*, JSValue, JSValue, JSValue) { }</span>
 490 #endif
 491 
 492 SLOW_PATH_DECL(slow_path_to_number)
 493 {
 494     BEGIN();
 495     auto bytecode = pc-&gt;as&lt;OpToNumber&gt;();
 496     JSValue argument = GET_C(bytecode.m_operand).jsValue();
<span class="line-modified"> 497     JSValue result = jsNumber(argument.toNumber(exec));</span>















 498     RETURN_PROFILED(result);
 499 }
 500 
 501 SLOW_PATH_DECL(slow_path_to_object)
 502 {
 503     BEGIN();
 504     auto bytecode = pc-&gt;as&lt;OpToObject&gt;();
 505     JSValue argument = GET_C(bytecode.m_operand).jsValue();
 506     if (UNLIKELY(argument.isUndefinedOrNull())) {
<span class="line-modified"> 507         const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_message);</span>
 508         if (!ident.isEmpty())
<span class="line-modified"> 509             THROW(createTypeError(exec, ident.impl()));</span>
 510     }
<span class="line-modified"> 511     JSObject* result = argument.toObject(exec);</span>
 512     RETURN_PROFILED(result);
 513 }
 514 
 515 SLOW_PATH_DECL(slow_path_add)
 516 {
 517     BEGIN();
 518     auto bytecode = pc-&gt;as&lt;OpAdd&gt;();
 519     JSValue v1 = GET_C(bytecode.m_lhs).jsValue();
 520     JSValue v2 = GET_C(bytecode.m_rhs).jsValue();
 521 
<span class="line-modified"> 522     ArithProfile&amp; arithProfile = *exec-&gt;codeBlock()-&gt;arithProfileForPC(pc);</span>
 523     arithProfile.observeLHSAndRHS(v1, v2);
 524 
<span class="line-modified"> 525     JSValue result = jsAdd(exec, v1, v2);</span>
 526 
 527     RETURN_WITH_PROFILING(result, {
<span class="line-modified"> 528         updateArithProfileForBinaryArithOp(exec, pc, result, v1, v2);</span>
 529     });
 530 }
 531 
 532 // The following arithmetic and bitwise operations need to be sure to run
 533 // toNumber() on their operands in order.  (A call to toNumber() is idempotent
<span class="line-modified"> 534 // if an exception is already set on the ExecState.)</span>
 535 
 536 SLOW_PATH_DECL(slow_path_mul)
 537 {
 538     BEGIN();
 539     auto bytecode = pc-&gt;as&lt;OpMul&gt;();
 540     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 541     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified"> 542     JSValue result = jsMul(exec, left, right);</span>
 543     CHECK_EXCEPTION();
 544     RETURN_WITH_PROFILING(result, {
<span class="line-modified"> 545         updateArithProfileForBinaryArithOp(exec, pc, result, left, right);</span>
 546     });
 547 }
 548 
 549 SLOW_PATH_DECL(slow_path_sub)
 550 {
 551     BEGIN();
 552     auto bytecode = pc-&gt;as&lt;OpSub&gt;();
 553     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 554     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified"> 555     auto leftNumeric = left.toNumeric(exec);</span>
 556     CHECK_EXCEPTION();
<span class="line-modified"> 557     auto rightNumeric = right.toNumeric(exec);</span>
 558     CHECK_EXCEPTION();
 559 
 560     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 561         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 562             JSBigInt* result = JSBigInt::sub(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 563             CHECK_EXCEPTION();
 564             RETURN_WITH_PROFILING(result, {
<span class="line-modified"> 565                 updateArithProfileForBinaryArithOp(exec, pc, result, left, right);</span>
 566             });
 567         }
 568 
<span class="line-modified"> 569         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in subtraction.&quot;));</span>
 570     }
 571 
 572     JSValue result = jsNumber(WTF::get&lt;double&gt;(leftNumeric) - WTF::get&lt;double&gt;(rightNumeric));
 573     RETURN_WITH_PROFILING(result, {
<span class="line-modified"> 574         updateArithProfileForBinaryArithOp(exec, pc, result, left, right);</span>
 575     });
 576 }
 577 
 578 SLOW_PATH_DECL(slow_path_div)
 579 {
 580     BEGIN();
 581     auto bytecode = pc-&gt;as&lt;OpDiv&gt;();
 582     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 583     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified"> 584     auto leftNumeric = left.toNumeric(exec);</span>
 585     CHECK_EXCEPTION();
<span class="line-modified"> 586     auto rightNumeric = right.toNumeric(exec);</span>
 587     CHECK_EXCEPTION();
 588 
 589     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 590         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 591             JSBigInt* result = JSBigInt::divide(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 592             CHECK_EXCEPTION();
 593             RETURN_WITH_PROFILING(result, {
<span class="line-modified"> 594                 updateArithProfileForBinaryArithOp(exec, pc, result, left, right);</span>
 595             });
 596         }
 597 
<span class="line-modified"> 598         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in division.&quot;));</span>
 599     }
 600 
 601     double a = WTF::get&lt;double&gt;(leftNumeric);
 602     double b = WTF::get&lt;double&gt;(rightNumeric);
 603     JSValue result = jsNumber(a / b);
 604     RETURN_WITH_PROFILING(result, {
<span class="line-modified"> 605         updateArithProfileForBinaryArithOp(exec, pc, result, left, right);</span>
 606     });
 607 }
 608 
 609 SLOW_PATH_DECL(slow_path_mod)
 610 {
 611     BEGIN();
 612     auto bytecode = pc-&gt;as&lt;OpMod&gt;();
 613     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 614     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified"> 615     auto leftNumeric = left.toNumeric(exec);</span>
 616     CHECK_EXCEPTION();
<span class="line-modified"> 617     auto rightNumeric = right.toNumeric(exec);</span>
 618     CHECK_EXCEPTION();
 619 
 620     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 621         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 622             JSBigInt* result = JSBigInt::remainder(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 623             CHECK_EXCEPTION();
 624             RETURN(result);
 625         }
 626 
<span class="line-modified"> 627         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;));</span>
 628     }
 629 
 630     double a = WTF::get&lt;double&gt;(leftNumeric);
 631     double b = WTF::get&lt;double&gt;(rightNumeric);
 632     RETURN(jsNumber(jsMod(a, b)));
 633 }
 634 
 635 SLOW_PATH_DECL(slow_path_pow)
 636 {
 637     BEGIN();
 638     auto bytecode = pc-&gt;as&lt;OpPow&gt;();
 639     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 640     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified"> 641     auto leftNumeric = left.toNumeric(exec);</span>
 642     CHECK_EXCEPTION();
<span class="line-modified"> 643     auto rightNumeric = right.toNumeric(exec);</span>
 644     CHECK_EXCEPTION();
 645 
 646     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 647         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 648             JSBigInt* result = JSBigInt::exponentiate(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 649             CHECK_EXCEPTION();
 650             RETURN(result);
 651         }
 652 
<span class="line-modified"> 653         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in exponentiation operation.&quot;));</span>
 654     }
 655 
 656     double a = WTF::get&lt;double&gt;(leftNumeric);
 657     double b = WTF::get&lt;double&gt;(rightNumeric);
 658 
 659     RETURN(jsNumber(operationMathPow(a, b)));
 660 }
 661 
 662 SLOW_PATH_DECL(slow_path_lshift)
 663 {
 664     BEGIN();
 665     auto bytecode = pc-&gt;as&lt;OpLshift&gt;();
 666     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 667     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified"> 668     auto leftNumeric = left.toBigIntOrInt32(exec);</span>
 669     CHECK_EXCEPTION();
<span class="line-modified"> 670     auto rightNumeric = right.toBigIntOrInt32(exec);</span>
 671     CHECK_EXCEPTION();
 672 
 673     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 674         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 675             JSBigInt* result = JSBigInt::leftShift(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 676             CHECK_EXCEPTION();
 677             RETURN_PROFILED(result);
 678         }
 679 
<span class="line-modified"> 680         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;));</span>
 681     }
 682 
 683     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &lt;&lt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));
 684 }
 685 
 686 SLOW_PATH_DECL(slow_path_rshift)
 687 {
 688     BEGIN();
 689     auto bytecode = pc-&gt;as&lt;OpRshift&gt;();
 690     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 691     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified"> 692     auto leftNumeric = left.toBigIntOrInt32(exec);</span>
 693     CHECK_EXCEPTION();
<span class="line-modified"> 694     auto rightNumeric = right.toBigIntOrInt32(exec);</span>
 695     CHECK_EXCEPTION();
 696 
 697     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 698         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 699             JSBigInt* result = JSBigInt::signedRightShift(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 700             CHECK_EXCEPTION();
<span class="line-modified"> 701             RETURN(result);</span>
 702         }
 703 
<span class="line-modified"> 704         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in signed right shift operation.&quot;));</span>
 705     }
 706 
<span class="line-modified"> 707     RETURN(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &gt;&gt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));</span>
 708 }
 709 
 710 SLOW_PATH_DECL(slow_path_urshift)
 711 {
 712     BEGIN();
 713     auto bytecode = pc-&gt;as&lt;OpUrshift&gt;();
<span class="line-modified"> 714     uint32_t a = GET_C(bytecode.m_lhs).jsValue().toUInt32(exec);</span>
 715     if (UNLIKELY(throwScope.exception()))
 716         RETURN(JSValue());
<span class="line-modified"> 717     uint32_t b = GET_C(bytecode.m_rhs).jsValue().toUInt32(exec);</span>
 718     RETURN(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 31))));
 719 }
 720 
 721 SLOW_PATH_DECL(slow_path_unsigned)
 722 {
 723     BEGIN();
 724     auto bytecode = pc-&gt;as&lt;OpUnsigned&gt;();
<span class="line-modified"> 725     uint32_t a = GET_C(bytecode.m_operand).jsValue().toUInt32(exec);</span>
 726     RETURN(jsNumber(a));
 727 }
 728 
 729 SLOW_PATH_DECL(slow_path_bitnot)
 730 {
 731     BEGIN();
 732     auto bytecode = pc-&gt;as&lt;OpBitnot&gt;();
<span class="line-modified"> 733     auto operandNumeric = GET_C(bytecode.m_operand).jsValue().toBigIntOrInt32(exec);</span>
 734     CHECK_EXCEPTION();
 735 
 736     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric)) {
<span class="line-modified"> 737         JSBigInt* result = JSBigInt::bitwiseNot(exec, WTF::get&lt;JSBigInt*&gt;(operandNumeric));</span>
 738         CHECK_EXCEPTION();
 739         RETURN_PROFILED(result);
 740     }
 741 
 742     RETURN_PROFILED(jsNumber(~WTF::get&lt;int32_t&gt;(operandNumeric)));
 743 }
 744 
 745 SLOW_PATH_DECL(slow_path_bitand)
 746 {
 747     BEGIN();
 748     auto bytecode = pc-&gt;as&lt;OpBitand&gt;();
<span class="line-modified"> 749     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);</span>
 750     CHECK_EXCEPTION();
<span class="line-modified"> 751     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);</span>
 752     CHECK_EXCEPTION();
 753     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 754         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 755             JSBigInt* result = JSBigInt::bitwiseAnd(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 756             CHECK_EXCEPTION();
 757             RETURN_PROFILED(result);
 758         }
 759 
<span class="line-modified"> 760         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;));</span>
 761     }
 762 
 763     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &amp; WTF::get&lt;int32_t&gt;(rightNumeric)));
 764 }
 765 
 766 SLOW_PATH_DECL(slow_path_bitor)
 767 {
 768     BEGIN();
 769     auto bytecode = pc-&gt;as&lt;OpBitor&gt;();
<span class="line-modified"> 770     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);</span>
 771     CHECK_EXCEPTION();
<span class="line-modified"> 772     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);</span>
 773     CHECK_EXCEPTION();
 774     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 775         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 776             JSBigInt* result = JSBigInt::bitwiseOr(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 777             CHECK_EXCEPTION();
 778             RETURN_PROFILED(result);
 779         }
 780 
<span class="line-modified"> 781         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;));</span>
 782     }
 783 
 784     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) | WTF::get&lt;int32_t&gt;(rightNumeric)));
 785 }
 786 
 787 SLOW_PATH_DECL(slow_path_bitxor)
 788 {
 789     BEGIN();
 790     auto bytecode = pc-&gt;as&lt;OpBitxor&gt;();
<span class="line-modified"> 791     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(exec);</span>
 792     CHECK_EXCEPTION();
<span class="line-modified"> 793     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(exec);</span>
 794     CHECK_EXCEPTION();
 795     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 796         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 797             JSBigInt* result = JSBigInt::bitwiseXor(exec, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 798             CHECK_EXCEPTION();
 799             RETURN_PROFILED(result);
 800         }
 801 
<span class="line-modified"> 802         THROW(createTypeError(exec, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;));</span>
 803     }
 804 
 805     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) ^ WTF::get&lt;int32_t&gt;(rightNumeric)));
 806 }
 807 
 808 SLOW_PATH_DECL(slow_path_typeof)
 809 {
 810     BEGIN();
 811     auto bytecode = pc-&gt;as&lt;OpTypeof&gt;();
<span class="line-modified"> 812     RETURN(jsTypeStringForValue(exec, GET_C(bytecode.m_value).jsValue()));</span>
 813 }
 814 
 815 SLOW_PATH_DECL(slow_path_is_object_or_null)
 816 {
 817     BEGIN();
 818     auto bytecode = pc-&gt;as&lt;OpIsObjectOrNull&gt;();
<span class="line-modified"> 819     RETURN(jsBoolean(jsIsObjectTypeOrNull(exec, GET_C(bytecode.m_operand).jsValue())));</span>
 820 }
 821 
 822 SLOW_PATH_DECL(slow_path_is_function)
 823 {
 824     BEGIN();
 825     auto bytecode = pc-&gt;as&lt;OpIsFunction&gt;();
 826     RETURN(jsBoolean(GET_C(bytecode.m_operand).jsValue().isFunction(vm)));
 827 }
 828 
 829 SLOW_PATH_DECL(slow_path_in_by_val)
 830 {
 831     BEGIN();
 832     auto bytecode = pc-&gt;as&lt;OpInByVal&gt;();
<span class="line-modified"> 833     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified"> 834     RETURN(jsBoolean(CommonSlowPaths::opInByVal(exec, GET_C(bytecode.m_base).jsValue(), GET_C(bytecode.m_property).jsValue(), &amp;metadata.m_arrayProfile)));</span>
 835 }
 836 
 837 SLOW_PATH_DECL(slow_path_in_by_id)
 838 {
 839     BEGIN();
 840 
 841     auto bytecode = pc-&gt;as&lt;OpInById&gt;();
 842     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
 843     if (!baseValue.isObject())
<span class="line-modified"> 844         THROW(createInvalidInParameterError(exec, baseValue));</span>
 845 
<span class="line-modified"> 846     RETURN(jsBoolean(asObject(baseValue)-&gt;hasProperty(exec, exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property))));</span>
 847 }
 848 
 849 SLOW_PATH_DECL(slow_path_del_by_val)
 850 {
 851     BEGIN();
 852     auto bytecode = pc-&gt;as&lt;OpDelByVal&gt;();
 853     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
<span class="line-modified"> 854     JSObject* baseObject = baseValue.toObject(exec);</span>
 855     CHECK_EXCEPTION();
 856 
 857     JSValue subscript = GET_C(bytecode.m_property).jsValue();
 858 
 859     bool couldDelete;
 860 
 861     uint32_t i;
 862     if (subscript.getUInt32(i))
<span class="line-modified"> 863         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObject, exec, i);</span>
 864     else {
 865         CHECK_EXCEPTION();
<span class="line-modified"> 866         auto property = subscript.toPropertyKey(exec);</span>
 867         CHECK_EXCEPTION();
<span class="line-modified"> 868         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, exec, property);</span>
 869     }

 870 
<span class="line-modified"> 871     if (!couldDelete &amp;&amp; exec-&gt;codeBlock()-&gt;isStrictMode())</span>
<span class="line-modified"> 872         THROW(createTypeError(exec, UnableToDeletePropertyError));</span>
 873 
 874     RETURN(jsBoolean(couldDelete));
 875 }
 876 
 877 SLOW_PATH_DECL(slow_path_strcat)
 878 {
 879     BEGIN();
 880     auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
<span class="line-modified"> 881     RETURN(jsStringFromRegisterArray(exec, &amp;GET(bytecode.m_src), bytecode.m_count));</span>
 882 }
 883 
 884 SLOW_PATH_DECL(slow_path_to_primitive)
 885 {
 886     BEGIN();
 887     auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
<span class="line-modified"> 888     RETURN(GET_C(bytecode.m_src).jsValue().toPrimitive(exec));</span>














 889 }
 890 
 891 SLOW_PATH_DECL(slow_path_get_enumerable_length)
 892 {
 893     BEGIN();
 894     auto bytecode = pc-&gt;as&lt;OpGetEnumerableLength&gt;();
 895     JSValue enumeratorValue = GET(bytecode.m_base).jsValue();
 896     if (enumeratorValue.isUndefinedOrNull())
 897         RETURN(jsNumber(0));
 898 
 899     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(enumeratorValue.asCell());
 900 
 901     RETURN(jsNumber(enumerator-&gt;indexedLength()));
 902 }
 903 
 904 SLOW_PATH_DECL(slow_path_has_indexed_property)
 905 {
 906     BEGIN();
 907     auto bytecode = pc-&gt;as&lt;OpHasIndexedProperty&gt;();
<span class="line-modified"> 908     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-modified"> 909     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);</span>
 910     CHECK_EXCEPTION();
 911     JSValue property = GET(bytecode.m_property).jsValue();
 912     metadata.m_arrayProfile.observeStructure(base-&gt;structure(vm));
 913     ASSERT(property.isUInt32AsAnyInt());
<span class="line-modified"> 914     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, property.asUInt32AsAnyInt(), PropertySlot::InternalMethodType::GetOwnProperty)));</span>
 915 }
 916 
 917 SLOW_PATH_DECL(slow_path_has_structure_property)
 918 {
 919     BEGIN();
 920     auto bytecode = pc-&gt;as&lt;OpHasStructureProperty&gt;();
<span class="line-modified"> 921     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);</span>
 922     CHECK_EXCEPTION();
 923     JSValue property = GET(bytecode.m_property).jsValue();
 924     ASSERT(property.isString());
 925     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 926     if (base-&gt;structure(vm)-&gt;id() == enumerator-&gt;cachedStructureID())
 927         RETURN(jsBoolean(true));
 928     JSString* string = asString(property);
<span class="line-modified"> 929     auto propertyName = string-&gt;toIdentifier(exec);</span>
 930     CHECK_EXCEPTION();
<span class="line-modified"> 931     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
 932 }
 933 
 934 SLOW_PATH_DECL(slow_path_has_generic_property)
 935 {
 936     BEGIN();
 937     auto bytecode = pc-&gt;as&lt;OpHasGenericProperty&gt;();
<span class="line-modified"> 938     JSObject* base = GET(bytecode.m_base).jsValue().toObject(exec);</span>
 939     CHECK_EXCEPTION();
 940     JSValue property = GET(bytecode.m_property).jsValue();
 941     ASSERT(property.isString());
 942     JSString* string = asString(property);
<span class="line-modified"> 943     auto propertyName = string-&gt;toIdentifier(exec);</span>
 944     CHECK_EXCEPTION();
<span class="line-modified"> 945     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(exec, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
 946 }
 947 
 948 SLOW_PATH_DECL(slow_path_get_direct_pname)
 949 {
 950     BEGIN();
 951     auto bytecode = pc-&gt;as&lt;OpGetDirectPname&gt;();
 952     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
 953     JSValue property = GET(bytecode.m_property).jsValue();
 954     ASSERT(property.isString());
 955     JSString* string = asString(property);
<span class="line-modified"> 956     auto propertyName = string-&gt;toIdentifier(exec);</span>
 957     CHECK_EXCEPTION();
<span class="line-modified"> 958     RETURN(baseValue.get(exec, propertyName));</span>
 959 }
 960 
 961 SLOW_PATH_DECL(slow_path_get_property_enumerator)
 962 {
 963     BEGIN();
 964     auto bytecode = pc-&gt;as&lt;OpGetPropertyEnumerator&gt;();
 965     JSValue baseValue = GET(bytecode.m_base).jsValue();
 966     if (baseValue.isUndefinedOrNull())
 967         RETURN(vm.emptyPropertyNameEnumerator());
 968 
<span class="line-modified"> 969     JSObject* base = baseValue.toObject(exec);</span>
 970     CHECK_EXCEPTION();
 971 
<span class="line-modified"> 972     RETURN(propertyNameEnumerator(exec, base));</span>
 973 }
 974 
 975 SLOW_PATH_DECL(slow_path_enumerator_structure_pname)
 976 {
 977     BEGIN();
 978     auto bytecode = pc-&gt;as&lt;OpEnumeratorStructurePname&gt;();
 979     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
 980     uint32_t index = GET(bytecode.m_index).jsValue().asUInt32();
 981 
 982     JSString* propertyName = nullptr;
 983     if (index &lt; enumerator-&gt;endStructurePropertyIndex())
 984         propertyName = enumerator-&gt;propertyNameAtIndex(index);
 985     RETURN(propertyName ? propertyName : jsNull());
 986 }
 987 
 988 SLOW_PATH_DECL(slow_path_enumerator_generic_pname)
 989 {
 990     BEGIN();
 991     auto bytecode = pc-&gt;as&lt;OpEnumeratorGenericPname&gt;();
 992     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
</pre>
<hr />
<pre>
1008 }
1009 
1010 SLOW_PATH_DECL(slow_path_profile_type_clear_log)
1011 {
1012     BEGIN();
1013     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;LLInt log full.&quot;_s);
1014     END();
1015 }
1016 
1017 SLOW_PATH_DECL(slow_path_unreachable)
1018 {
1019     BEGIN();
1020     UNREACHABLE_FOR_PLATFORM();
1021     END();
1022 }
1023 
1024 SLOW_PATH_DECL(slow_path_create_lexical_environment)
1025 {
1026     BEGIN();
1027     auto bytecode = pc-&gt;as&lt;OpCreateLexicalEnvironment&gt;();
<span class="line-modified">1028     int scopeReg = bytecode.m_scope.offset();</span>
<span class="line-removed">1029     JSScope* currentScope = exec-&gt;uncheckedR(scopeReg).Register::scope();</span>
1030     SymbolTable* symbolTable = jsCast&lt;SymbolTable*&gt;(GET_C(bytecode.m_symbolTable).jsValue());
1031     JSValue initialValue = GET_C(bytecode.m_initialValue).jsValue();
1032     ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
<span class="line-modified">1033     JSScope* newScope = JSLexicalEnvironment::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, symbolTable, initialValue);</span>
1034     RETURN(newScope);
1035 }
1036 
1037 SLOW_PATH_DECL(slow_path_push_with_scope)
1038 {
1039     BEGIN();
1040     auto bytecode = pc-&gt;as&lt;OpPushWithScope&gt;();
<span class="line-modified">1041     JSObject* newScope = GET_C(bytecode.m_newScope).jsValue().toObject(exec);</span>
1042     CHECK_EXCEPTION();
1043 
<span class="line-modified">1044     int scopeReg = bytecode.m_currentScope.offset();</span>
<span class="line-modified">1045     JSScope* currentScope = exec-&gt;uncheckedR(scopeReg).Register::scope();</span>
<span class="line-removed">1046     RETURN(JSWithScope::create(vm, exec-&gt;lexicalGlobalObject(), currentScope, newScope));</span>
1047 }
1048 
1049 SLOW_PATH_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval)
1050 {
1051     BEGIN();
1052     auto bytecode = pc-&gt;as&lt;OpResolveScopeForHoistingFuncDeclInEval&gt;();
<span class="line-modified">1053     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property);</span>
<span class="line-modified">1054     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope.offset()).Register::scope();</span>
<span class="line-modified">1055     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(exec, scope, ident);</span>
1056 
1057     CHECK_EXCEPTION();
1058 
1059     RETURN(resolvedScope);
1060 }
1061 
1062 SLOW_PATH_DECL(slow_path_resolve_scope)
1063 {
1064     BEGIN();
1065     auto bytecode = pc-&gt;as&lt;OpResolveScope&gt;();
<span class="line-modified">1066     auto&amp; metadata = bytecode.metadata(exec);</span>
<span class="line-removed">1067     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
1068     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
<span class="line-modified">1069     JSScope* scope = exec-&gt;uncheckedR(bytecode.m_scope.offset()).Register::scope();</span>
<span class="line-modified">1070     JSObject* resolvedScope = JSScope::resolve(exec, scope, ident);</span>
1071     // Proxy can throw an error here, e.g. Proxy in with statement&#39;s @unscopables.
1072     CHECK_EXCEPTION();
1073 
1074     ResolveType resolveType = metadata.m_resolveType;
1075 
1076     // ModuleVar does not keep the scope register value alive in DFG.
1077     ASSERT(resolveType != ModuleVar);
1078 
1079     switch (resolveType) {
1080     case GlobalProperty:
1081     case GlobalPropertyWithVarInjectionChecks:
1082     case UnresolvedProperty:
1083     case UnresolvedPropertyWithVarInjectionChecks: {
1084         if (resolvedScope-&gt;isGlobalObject()) {
1085             JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(resolvedScope);
<span class="line-modified">1086             bool hasProperty = globalObject-&gt;hasProperty(exec, ident);</span>
1087             CHECK_EXCEPTION();
1088             if (hasProperty) {
1089                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
1090                 metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;
1091                 metadata.m_globalObject.set(vm, codeBlock, globalObject);
1092                 metadata.m_globalLexicalBindingEpoch = globalObject-&gt;globalLexicalBindingEpoch();
1093             }
1094         } else if (resolvedScope-&gt;isGlobalLexicalEnvironment()) {
1095             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(resolvedScope);
1096             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
1097             metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;
1098             metadata.m_globalLexicalEnvironment.set(vm, codeBlock, globalLexicalEnvironment);
1099         }
1100         break;
1101     }
1102     default:
1103         break;
1104     }
1105 
1106     RETURN(resolvedScope);
1107 }
1108 
1109 SLOW_PATH_DECL(slow_path_create_rest)
1110 {
1111     BEGIN();
1112     auto bytecode = pc-&gt;as&lt;OpCreateRest&gt;();
1113     unsigned arraySize = GET_C(bytecode.m_arraySize).jsValue().asUInt32();
<span class="line-removed">1114     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
1115     Structure* structure = globalObject-&gt;restParameterStructure();
1116     unsigned numParamsToSkip = bytecode.m_numParametersToSkip;
<span class="line-modified">1117     JSValue* argumentsToCopyRegion = exec-&gt;addressOfArgumentsStart() + numParamsToSkip;</span>
<span class="line-modified">1118     RETURN(constructArray(exec, structure, argumentsToCopyRegion, arraySize));</span>
1119 }
1120 
1121 SLOW_PATH_DECL(slow_path_get_by_id_with_this)
1122 {
1123     BEGIN();
1124     auto bytecode = pc-&gt;as&lt;OpGetByIdWithThis&gt;();
<span class="line-modified">1125     const Identifier&amp; ident = exec-&gt;codeBlock()-&gt;identifier(bytecode.m_property);</span>
1126     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1127     JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
1128     PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
<span class="line-modified">1129     JSValue result = baseValue.get(exec, ident, slot);</span>
1130     RETURN_PROFILED(result);
1131 }
1132 
1133 SLOW_PATH_DECL(slow_path_get_by_val_with_this)
1134 {
1135     BEGIN();
1136 
1137     auto bytecode = pc-&gt;as&lt;OpGetByValWithThis&gt;();
1138     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1139     JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
1140     JSValue subscript = GET_C(bytecode.m_property).jsValue();
1141 
1142     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1143         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1144         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">1145             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(exec);</span>
1146             CHECK_EXCEPTION();
1147             if (existingAtomString) {
1148                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
1149                     RETURN_PROFILED(result);
1150             }
1151         }
1152     }
1153 
1154     PropertySlot slot(thisValue, PropertySlot::PropertySlot::InternalMethodType::Get);
1155     if (subscript.isUInt32()) {
1156         uint32_t i = subscript.asUInt32();
1157         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
<span class="line-modified">1158             RETURN_PROFILED(asString(baseValue)-&gt;getIndex(exec, i));</span>
1159 
<span class="line-modified">1160         RETURN_PROFILED(baseValue.get(exec, i, slot));</span>
1161     }
1162 
<span class="line-modified">1163     baseValue.requireObjectCoercible(exec);</span>
1164     CHECK_EXCEPTION();
<span class="line-modified">1165     auto property = subscript.toPropertyKey(exec);</span>
1166     CHECK_EXCEPTION();
<span class="line-modified">1167     RETURN_PROFILED(baseValue.get(exec, property, slot));</span>
1168 }
1169 
1170 SLOW_PATH_DECL(slow_path_put_by_id_with_this)
1171 {
1172     BEGIN();
1173     auto bytecode = pc-&gt;as&lt;OpPutByIdWithThis&gt;();
<span class="line-removed">1174     CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
1175     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
1176     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1177     JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
1178     JSValue putValue = GET_C(bytecode.m_value).jsValue();
1179     PutPropertySlot slot(thisVal, codeBlock-&gt;isStrictMode(), codeBlock-&gt;putByIdContext());
<span class="line-modified">1180     baseValue.putInline(exec, ident, putValue, slot);</span>
1181     END();
1182 }
1183 
1184 SLOW_PATH_DECL(slow_path_put_by_val_with_this)
1185 {
1186     BEGIN();
1187     auto bytecode = pc-&gt;as&lt;OpPutByValWithThis&gt;();
1188     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1189     JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
1190     JSValue subscript = GET_C(bytecode.m_property).jsValue();
1191     JSValue value = GET_C(bytecode.m_value).jsValue();
1192 
<span class="line-modified">1193     auto property = subscript.toPropertyKey(exec);</span>
1194     CHECK_EXCEPTION();
<span class="line-modified">1195     PutPropertySlot slot(thisValue, exec-&gt;codeBlock()-&gt;isStrictMode());</span>
<span class="line-modified">1196     baseValue.put(exec, property, value, slot);</span>
1197     END();
1198 }
1199 
1200 SLOW_PATH_DECL(slow_path_define_data_property)
1201 {
1202     BEGIN();
1203     auto bytecode = pc-&gt;as&lt;OpDefineDataProperty&gt;();
1204     JSObject* base = asObject(GET_C(bytecode.m_base).jsValue());
1205     JSValue property = GET_C(bytecode.m_property).jsValue();
1206     JSValue value = GET_C(bytecode.m_value).jsValue();
1207     JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
1208     ASSERT(attributes.isInt32());
1209 
<span class="line-modified">1210     auto propertyName = property.toPropertyKey(exec);</span>
1211     CHECK_EXCEPTION();
1212     PropertyDescriptor descriptor = toPropertyDescriptor(value, jsUndefined(), jsUndefined(), DefinePropertyAttributes(attributes.asInt32()));
1213     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
<span class="line-modified">1214     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);</span>
1215     END();
1216 }
1217 
1218 SLOW_PATH_DECL(slow_path_define_accessor_property)
1219 {
1220     BEGIN();
1221     auto bytecode = pc-&gt;as&lt;OpDefineAccessorProperty&gt;();
1222     JSObject* base = asObject(GET_C(bytecode.m_base).jsValue());
1223     JSValue property = GET_C(bytecode.m_property).jsValue();
1224     JSValue getter = GET_C(bytecode.m_getter).jsValue();
1225     JSValue setter = GET_C(bytecode.m_setter).jsValue();
1226     JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
1227     ASSERT(attributes.isInt32());
1228 
<span class="line-modified">1229     auto propertyName = property.toPropertyKey(exec);</span>
1230     CHECK_EXCEPTION();
1231     PropertyDescriptor descriptor = toPropertyDescriptor(jsUndefined(), getter, setter, DefinePropertyAttributes(attributes.asInt32()));
1232     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
<span class="line-modified">1233     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, exec, propertyName, descriptor, true);</span>
1234     END();
1235 }
1236 
1237 SLOW_PATH_DECL(slow_path_throw_static_error)
1238 {
1239     BEGIN();
1240     auto bytecode = pc-&gt;as&lt;OpThrowStaticError&gt;();
1241     JSValue errorMessageValue = GET_C(bytecode.m_message).jsValue();
1242     RELEASE_ASSERT(errorMessageValue.isString());
<span class="line-modified">1243     String errorMessage = asString(errorMessageValue)-&gt;value(exec);</span>
1244     ErrorType errorType = bytecode.m_errorType;
<span class="line-modified">1245     THROW(createError(exec, errorType, errorMessage));</span>
1246 }
1247 
1248 SLOW_PATH_DECL(slow_path_new_array_with_spread)
1249 {
1250     BEGIN();
1251     auto bytecode = pc-&gt;as&lt;OpNewArrayWithSpread&gt;();
1252     int numItems = bytecode.m_argc;
1253     ASSERT(numItems &gt;= 0);
<span class="line-modified">1254     const BitVector&amp; bitVector = exec-&gt;codeBlock()-&gt;unlinkedCodeBlock()-&gt;bitVector(bytecode.m_bitVector);</span>
1255 
1256     JSValue* values = bitwise_cast&lt;JSValue*&gt;(&amp;GET(bytecode.m_argv));
1257 








1258     Checked&lt;unsigned, RecordOverflow&gt; checkedArraySize = 0;
1259     for (int i = 0; i &lt; numItems; i++) {
1260         if (bitVector.get(i)) {
1261             JSValue value = values[-i];
<span class="line-modified">1262             JSFixedArray* array = jsCast&lt;JSFixedArray*&gt;(value);</span>
<span class="line-modified">1263             checkedArraySize += array-&gt;size();</span>
1264         } else
1265             checkedArraySize += 1;
1266     }
1267     if (UNLIKELY(checkedArraySize.hasOverflowed()))
<span class="line-modified">1268         THROW(createOutOfMemoryError(exec));</span>
1269 
1270     unsigned arraySize = checkedArraySize.unsafeGet();
1271     if (UNLIKELY(arraySize &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH))
<span class="line-modified">1272         THROW(createOutOfMemoryError(exec));</span>
1273 
<span class="line-removed">1274     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
1275     Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
1276 
1277     JSArray* result = JSArray::tryCreate(vm, structure, arraySize);
1278     if (UNLIKELY(!result))
<span class="line-modified">1279         THROW(createOutOfMemoryError(exec));</span>
1280     CHECK_EXCEPTION();
1281 
1282     unsigned index = 0;
1283     for (int i = 0; i &lt; numItems; i++) {
1284         JSValue value = values[-i];
1285         if (bitVector.get(i)) {
1286             // We are spreading.
<span class="line-modified">1287             JSFixedArray* array = jsCast&lt;JSFixedArray*&gt;(value);</span>
<span class="line-modified">1288             for (unsigned i = 0; i &lt; array-&gt;size(); i++) {</span>
1289                 RELEASE_ASSERT(array-&gt;get(i));
<span class="line-modified">1290                 result-&gt;putDirectIndex(exec, index, array-&gt;get(i));</span>
1291                 CHECK_EXCEPTION();
1292                 ++index;
1293             }
1294         } else {
1295             // We are not spreading.
<span class="line-modified">1296             result-&gt;putDirectIndex(exec, index, value);</span>
1297             CHECK_EXCEPTION();
1298             ++index;
1299         }
1300     }
1301 
1302     RETURN(result);
1303 }
1304 
1305 SLOW_PATH_DECL(slow_path_new_array_buffer)
1306 {
1307     BEGIN();
1308     auto bytecode = pc-&gt;as&lt;OpNewArrayBuffer&gt;();
<span class="line-modified">1309     ASSERT(exec-&gt;codeBlock()-&gt;isConstantRegisterIndex(bytecode.m_immutableButterfly.offset()));</span>
1310     JSImmutableButterfly* immutableButterfly = bitwise_cast&lt;JSImmutableButterfly*&gt;(GET_C(bytecode.m_immutableButterfly).jsValue().asCell());
<span class="line-modified">1311     auto&amp; profile = bytecode.metadata(exec).m_arrayAllocationProfile;</span>
1312 
1313     IndexingType indexingMode = profile.selectIndexingType();
<span class="line-modified">1314     Structure* structure = exec-&gt;lexicalGlobalObject()-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode);</span>
1315     ASSERT(isCopyOnWrite(indexingMode));
1316     ASSERT(!structure-&gt;outOfLineCapacity());
1317 
1318     if (UNLIKELY(immutableButterfly-&gt;indexingMode() != indexingMode)) {
1319         auto* newButterfly = JSImmutableButterfly::create(vm, indexingMode, immutableButterfly-&gt;length());
1320         for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); ++i)
1321             newButterfly-&gt;setIndex(vm, i, immutableButterfly-&gt;get(i));
1322         immutableButterfly = newButterfly;
<span class="line-removed">1323         CodeBlock* codeBlock = exec-&gt;codeBlock();</span>
1324 
1325         // FIXME: This is kinda gross and only works because we can&#39;t inline new_array_bufffer in the baseline.
1326         // We also cannot allocate a new butterfly from compilation threads since it&#39;s invalid to allocate cells from
1327         // a compilation thread.
1328         WTF::storeStoreFence();
<span class="line-modified">1329         codeBlock-&gt;constantRegister(bytecode.m_immutableButterfly.offset()).set(vm, codeBlock, immutableButterfly);</span>
1330         WTF::storeStoreFence();
1331     }
1332 
1333     JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
<span class="line-modified">1334     ASSERT(isCopyOnWrite(result-&gt;indexingMode()) || exec-&gt;lexicalGlobalObject()-&gt;isHavingABadTime());</span>
1335     ArrayAllocationProfile::updateLastAllocationFor(&amp;profile, result);
1336     RETURN(result);
1337 }
1338 
1339 SLOW_PATH_DECL(slow_path_spread)
1340 {
1341     BEGIN();
1342 
1343     auto bytecode = pc-&gt;as&lt;OpSpread&gt;();
1344     JSValue iterable = GET_C(bytecode.m_argument).jsValue();
1345 
1346     if (iterable.isCell() &amp;&amp; isJSArray(iterable.asCell())) {
1347         JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
1348         if (array-&gt;isIteratorProtocolFastAndNonObservable()) {
<span class="line-modified">1349             // JSFixedArray::createFromArray does not consult the prototype chain,</span>
1350             // so we must be sure that not consulting the prototype chain would
1351             // produce the same value during iteration.
<span class="line-modified">1352             RETURN(JSFixedArray::createFromArray(exec, vm, array));</span>
1353         }
1354     }
1355 
<span class="line-removed">1356     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed">1357 </span>
1358     JSArray* array;
1359     {
1360         JSFunction* iterationFunction = globalObject-&gt;iteratorProtocolFunction();
1361         CallData callData;
1362         CallType callType = JSC::getCallData(vm, iterationFunction, callData);
1363         ASSERT(callType != CallType::None);
1364 
1365         MarkedArgumentBuffer arguments;
1366         arguments.append(iterable);
1367         ASSERT(!arguments.hasOverflowed());
<span class="line-modified">1368         JSValue arrayResult = call(exec, iterationFunction, callType, callData, jsNull(), arguments);</span>
1369         CHECK_EXCEPTION();
1370         array = jsCast&lt;JSArray*&gt;(arrayResult);
1371     }
1372 
<span class="line-modified">1373     RETURN(JSFixedArray::createFromArray(exec, vm, array));</span>
1374 }
1375 
1376 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  29 #include &quot;ArithProfile.h&quot;
  30 #include &quot;ArrayConstructor.h&quot;
  31 #include &quot;BuiltinNames.h&quot;
  32 #include &quot;BytecodeStructs.h&quot;
  33 #include &quot;CallFrame.h&quot;
  34 #include &quot;ClonedArguments.h&quot;
  35 #include &quot;CodeProfiling.h&quot;
  36 #include &quot;DefinePropertyAttributes.h&quot;
  37 #include &quot;DirectArguments.h&quot;
  38 #include &quot;Error.h&quot;
  39 #include &quot;ErrorHandlingScope.h&quot;
  40 #include &quot;ExceptionFuzz.h&quot;
  41 #include &quot;FrameTracers.h&quot;
  42 #include &quot;GetterSetter.h&quot;
  43 #include &quot;HostCallReturnValue.h&quot;
  44 #include &quot;ICStats.h&quot;
  45 #include &quot;Interpreter.h&quot;
  46 #include &quot;IteratorOperations.h&quot;
  47 #include &quot;JIT.h&quot;
  48 #include &quot;JSArrayInlines.h&quot;
<span class="line-added">  49 #include &quot;JSAsyncGenerator.h&quot;</span>
  50 #include &quot;JSCInlines.h&quot;
  51 #include &quot;JSCJSValue.h&quot;

  52 #include &quot;JSGlobalObjectFunctions.h&quot;
  53 #include &quot;JSImmutableButterfly.h&quot;
<span class="line-added">  54 #include &quot;JSInternalPromise.h&quot;</span>
<span class="line-added">  55 #include &quot;JSInternalPromiseConstructor.h&quot;</span>
  56 #include &quot;JSLexicalEnvironment.h&quot;
<span class="line-added">  57 #include &quot;JSPromiseConstructor.h&quot;</span>
  58 #include &quot;JSPropertyNameEnumerator.h&quot;
  59 #include &quot;JSString.h&quot;
  60 #include &quot;JSWithScope.h&quot;
  61 #include &quot;LLIntCommon.h&quot;
  62 #include &quot;LLIntExceptions.h&quot;
  63 #include &quot;LowLevelInterpreter.h&quot;
  64 #include &quot;MathCommon.h&quot;
  65 #include &quot;ObjectConstructor.h&quot;
  66 #include &quot;OpcodeInlines.h&quot;
  67 #include &quot;ScopedArguments.h&quot;
  68 #include &quot;StructureRareDataInlines.h&quot;
  69 #include &quot;ThunkGenerators.h&quot;
  70 #include &quot;TypeProfilerLog.h&quot;
  71 #include &lt;wtf/StringPrintStream.h&gt;
  72 #include &lt;wtf/Variant.h&gt;
  73 
  74 namespace JSC {
  75 
  76 #define BEGIN_NO_SET_PC() \
<span class="line-modified">  77     CodeBlock* codeBlock = callFrame-&gt;codeBlock(); \</span>
<span class="line-modified">  78     JSGlobalObject* globalObject = codeBlock-&gt;globalObject(); \</span>
<span class="line-added">  79     VM&amp; vm = codeBlock-&gt;vm(); \</span>
<span class="line-added">  80     SlowPathFrameTracer tracer(vm, callFrame); \</span>
  81     auto throwScope = DECLARE_THROW_SCOPE(vm); \
  82     UNUSED_PARAM(throwScope)
  83 
  84 #ifndef NDEBUG
  85 #define SET_PC_FOR_STUBS() do { \
<span class="line-modified">  86         codeBlock-&gt;bytecodeOffset(pc); \</span>
<span class="line-modified">  87         callFrame-&gt;setCurrentVPC(pc); \</span>
  88     } while (false)
  89 #else
  90 #define SET_PC_FOR_STUBS() do { \
<span class="line-modified">  91         callFrame-&gt;setCurrentVPC(pc); \</span>
  92     } while (false)
  93 #endif
  94 
<span class="line-modified">  95 #define RETURN_TO_THROW(pc)   pc = LLInt::returnToThrow(vm)</span>
  96 
  97 #define BEGIN()                           \
  98     BEGIN_NO_SET_PC();                    \
  99     SET_PC_FOR_STUBS()
 100 
<span class="line-modified"> 101 #define GET(operand) (callFrame-&gt;uncheckedR(operand))</span>
<span class="line-modified"> 102 #define GET_C(operand) (callFrame-&gt;r(operand))</span>
 103 
 104 #define RETURN_TWO(first, second) do {       \
 105         return encodeResult(first, second);        \
 106     } while (false)
 107 
<span class="line-modified"> 108 #define END_IMPL() RETURN_TWO(pc, callFrame)</span>
 109 
 110 #define THROW(exceptionToThrow) do {                        \
<span class="line-modified"> 111         throwException(globalObject, throwScope, exceptionToThrow); \</span>
<span class="line-modified"> 112         RETURN_TO_THROW(pc);                          \</span>
 113         END_IMPL();                                         \
 114     } while (false)
 115 
 116 #define CHECK_EXCEPTION() do {                    \
<span class="line-modified"> 117         doExceptionFuzzingIfEnabled(globalObject, throwScope, &quot;CommonSlowPaths&quot;, pc);   \</span>
 118         if (UNLIKELY(throwScope.exception())) {   \
<span class="line-modified"> 119             RETURN_TO_THROW(pc);            \</span>
 120             END_IMPL();                           \
 121         }                                         \
 122     } while (false)
 123 
 124 #define END() do {                        \
 125         CHECK_EXCEPTION();                \
 126         END_IMPL();                       \
 127     } while (false)
 128 
 129 #define BRANCH(condition) do {                      \
 130         bool bCondition = (condition);                         \
 131         CHECK_EXCEPTION();                                  \
 132         if (bCondition)                                        \
 133             pc = bytecode.m_targetLabel \
 134                 ? reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + bytecode.m_targetLabel) \
<span class="line-modified"> 135                 : codeBlock-&gt;outOfLineJumpTarget(pc);                              \</span>
 136         else                                                      \
 137             pc = reinterpret_cast&lt;const Instruction*&gt;(reinterpret_cast&lt;const uint8_t*&gt;(pc) + pc-&gt;size()); \
 138         END_IMPL();                                         \
 139     } while (false)
 140 
 141 #define RETURN_WITH_PROFILING_CUSTOM(result__, value__, profilingAction__) do { \
 142         JSValue returnValue__ = (value__);  \
 143         CHECK_EXCEPTION();                  \
 144         GET(result__) = returnValue__;              \
 145         profilingAction__;                  \
 146         END_IMPL();                         \
 147     } while (false)
 148 
 149 #define RETURN_WITH_PROFILING(value__, profilingAction__) RETURN_WITH_PROFILING_CUSTOM(bytecode.m_dst, value__, profilingAction__)
 150 
 151 #define RETURN(value) \
 152     RETURN_WITH_PROFILING(value, { })
 153 
 154 #define RETURN_PROFILED(value__) \
 155     RETURN_WITH_PROFILING(value__, PROFILE_VALUE(returnValue__))
 156 
 157 #define PROFILE_VALUE(value) do { \
<span class="line-modified"> 158         bytecode.metadata(codeBlock).m_profile.m_buckets[0] = JSValue::encode(value); \</span>
 159     } while (false)
 160 
<span class="line-modified"> 161 static void throwArityCheckStackOverflowError(JSGlobalObject* globalObject, ThrowScope&amp; scope)</span>










 162 {
<span class="line-modified"> 163     JSObject* error = createStackOverflowError(globalObject);</span>
<span class="line-modified"> 164     throwException(globalObject, scope, error);</span>
 165 #if LLINT_TRACING
 166     if (UNLIKELY(Options::traceLLIntSlowPath()))
 167         dataLog(&quot;Throwing exception &quot;, JSValue(scope.exception()), &quot;.\n&quot;);
 168 #endif
 169 }
 170 
 171 SLOW_PATH_DECL(slow_path_call_arityCheck)
 172 {
 173     BEGIN();
<span class="line-modified"> 174     int slotsToAdd = CommonSlowPaths::arityCheckFor(vm, callFrame, CodeForCall);</span>
 175     if (UNLIKELY(slotsToAdd &lt; 0)) {
<span class="line-modified"> 176         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(callFrame, CodeForCall);</span>
<span class="line-modified"> 177         callFrame-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified"> 178         SlowPathFrameTracer tracer(vm, callFrame);</span>
 179         ErrorHandlingScope errorScope(vm);
 180         throwScope.release();
<span class="line-modified"> 181         throwArityCheckStackOverflowError(globalObject, throwScope);</span>
<span class="line-modified"> 182         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), callFrame);</span>
 183     }
 184     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 185 }
 186 
 187 SLOW_PATH_DECL(slow_path_construct_arityCheck)
 188 {
 189     BEGIN();
<span class="line-modified"> 190     int slotsToAdd = CommonSlowPaths::arityCheckFor(vm, callFrame, CodeForConstruct);</span>
 191     if (UNLIKELY(slotsToAdd &lt; 0)) {
<span class="line-modified"> 192         CodeBlock* codeBlock = CommonSlowPaths::codeBlockFromCallFrameCallee(callFrame, CodeForConstruct);</span>
<span class="line-modified"> 193         callFrame-&gt;convertToStackOverflowFrame(vm, codeBlock);</span>
<span class="line-modified"> 194         SlowPathFrameTracer tracer(vm, callFrame);</span>
 195         ErrorHandlingScope errorScope(vm);
<span class="line-modified"> 196         throwArityCheckStackOverflowError(globalObject, throwScope);</span>
<span class="line-modified"> 197         RETURN_TWO(bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(1)), callFrame);</span>
 198     }
 199     RETURN_TWO(0, bitwise_cast&lt;void*&gt;(static_cast&lt;uintptr_t&gt;(slotsToAdd)));
 200 }
 201 
 202 SLOW_PATH_DECL(slow_path_create_direct_arguments)
 203 {
 204     BEGIN();
 205     auto bytecode = pc-&gt;as&lt;OpCreateDirectArguments&gt;();
<span class="line-modified"> 206     RETURN(DirectArguments::createByCopying(globalObject, callFrame));</span>
 207 }
 208 
 209 SLOW_PATH_DECL(slow_path_create_scoped_arguments)
 210 {
 211     BEGIN();
 212     auto bytecode = pc-&gt;as&lt;OpCreateScopedArguments&gt;();
 213     JSLexicalEnvironment* scope = jsCast&lt;JSLexicalEnvironment*&gt;(GET(bytecode.m_scope).jsValue());
 214     ScopedArgumentsTable* table = scope-&gt;symbolTable()-&gt;arguments();
<span class="line-modified"> 215     RETURN(ScopedArguments::createByCopying(globalObject, callFrame, table, scope));</span>
 216 }
 217 
 218 SLOW_PATH_DECL(slow_path_create_cloned_arguments)
 219 {
 220     BEGIN();
 221     auto bytecode = pc-&gt;as&lt;OpCreateClonedArguments&gt;();
<span class="line-modified"> 222     RETURN(ClonedArguments::createWithMachineFrame(globalObject, callFrame, ArgumentsMode::Cloned));</span>
<span class="line-added"> 223 }</span>
<span class="line-added"> 224 </span>
<span class="line-added"> 225 SLOW_PATH_DECL(slow_path_create_arguments_butterfly)</span>
<span class="line-added"> 226 {</span>
<span class="line-added"> 227     BEGIN();</span>
<span class="line-added"> 228     auto bytecode = pc-&gt;as&lt;OpCreateArgumentsButterfly&gt;();</span>
<span class="line-added"> 229     int32_t argumentCount = callFrame-&gt;argumentCount();</span>
<span class="line-added"> 230     JSImmutableButterfly* butterfly = JSImmutableButterfly::tryCreate(vm, vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get(), argumentCount);</span>
<span class="line-added"> 231     if (!butterfly)</span>
<span class="line-added"> 232         THROW(createOutOfMemoryError(globalObject));</span>
<span class="line-added"> 233     for (int32_t index = 0; index &lt; argumentCount; ++index)</span>
<span class="line-added"> 234         butterfly-&gt;setIndex(vm, index, callFrame-&gt;uncheckedArgument(index));</span>
<span class="line-added"> 235     RETURN(butterfly);</span>
 236 }
 237 
 238 SLOW_PATH_DECL(slow_path_create_this)
 239 {
 240     BEGIN();
 241     auto bytecode = pc-&gt;as&lt;OpCreateThis&gt;();
 242     JSObject* result;
 243     JSObject* constructorAsObject = asObject(GET(bytecode.m_callee).jsValue());
<span class="line-modified"> 244     JSFunction* constructor = jsDynamicCast&lt;JSFunction*&gt;(vm, constructorAsObject);</span>
<span class="line-modified"> 245     if (constructor &amp;&amp; constructor-&gt;canUseAllocationProfile()) {</span>
<span class="line-modified"> 246         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(codeBlock).m_cachedCallee;</span>
 247         if (!cachedCallee)
<span class="line-modified"> 248             cachedCallee.set(vm, codeBlock, constructor);</span>
 249         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)
 250             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());
 251 
 252         size_t inlineCapacity = bytecode.m_inlineCapacity;
<span class="line-modified"> 253         ObjectAllocationProfileWithPrototype* allocationProfile = constructor-&gt;ensureRareDataAndAllocationProfile(globalObject, inlineCapacity)-&gt;objectAllocationProfile();</span>
 254         throwScope.releaseAssertNoException();
 255         Structure* structure = allocationProfile-&gt;structure();
<span class="line-modified"> 256         result = constructEmptyObject(vm, structure);</span>
 257         if (structure-&gt;hasPolyProto()) {
 258             JSObject* prototype = allocationProfile-&gt;prototype();
<span class="line-modified"> 259             ASSERT(prototype == constructor-&gt;prototypeForConstruction(vm, globalObject));</span>
 260             result-&gt;putDirect(vm, knownPolyProtoOffset, prototype);
 261             prototype-&gt;didBecomePrototype();
 262             ASSERT_WITH_MESSAGE(!hasIndexedProperties(result-&gt;indexingType()), &quot;We rely on JSFinalObject not starting out with an indexing type otherwise we would potentially need to convert to slow put storage&quot;);
 263         }
 264     } else {
 265         // http://ecma-international.org/ecma-262/6.0/#sec-ordinarycreatefromconstructor
<span class="line-modified"> 266         JSValue proto = constructorAsObject-&gt;get(globalObject, vm.propertyNames-&gt;prototype);</span>
 267         CHECK_EXCEPTION();
 268         if (proto.isObject())
<span class="line-modified"> 269             result = constructEmptyObject(globalObject, asObject(proto));</span>
 270         else
<span class="line-modified"> 271             result = constructEmptyObject(globalObject);</span>
 272     }
 273     RETURN(result);
 274 }
 275 
<span class="line-added"> 276 SLOW_PATH_DECL(slow_path_create_promise)</span>
<span class="line-added"> 277 {</span>
<span class="line-added"> 278     BEGIN();</span>
<span class="line-added"> 279     auto bytecode = pc-&gt;as&lt;OpCreatePromise&gt;();</span>
<span class="line-added"> 280     JSObject* constructorAsObject = asObject(GET(bytecode.m_callee).jsValue());</span>
<span class="line-added"> 281 </span>
<span class="line-added"> 282     JSPromise* result = nullptr;</span>
<span class="line-added"> 283     if (bytecode.m_isInternalPromise) {</span>
<span class="line-added"> 284         Structure* structure = InternalFunction::createSubclassStructure(globalObject, globalObject-&gt;internalPromiseConstructor(), constructorAsObject, globalObject-&gt;internalPromiseStructure());</span>
<span class="line-added"> 285         CHECK_EXCEPTION();</span>
<span class="line-added"> 286         result = JSInternalPromise::create(vm, structure);</span>
<span class="line-added"> 287     } else {</span>
<span class="line-added"> 288         Structure* structure = InternalFunction::createSubclassStructure(globalObject, globalObject-&gt;promiseConstructor(), constructorAsObject, globalObject-&gt;promiseStructure());</span>
<span class="line-added"> 289         CHECK_EXCEPTION();</span>
<span class="line-added"> 290         result = JSPromise::create(vm, structure);</span>
<span class="line-added"> 291     }</span>
<span class="line-added"> 292 </span>
<span class="line-added"> 293     JSFunction* constructor = jsDynamicCast&lt;JSFunction*&gt;(vm, constructorAsObject);</span>
<span class="line-added"> 294     if (constructor &amp;&amp; constructor-&gt;canUseAllocationProfile()) {</span>
<span class="line-added"> 295         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(codeBlock).m_cachedCallee;</span>
<span class="line-added"> 296         if (!cachedCallee)</span>
<span class="line-added"> 297             cachedCallee.set(vm, codeBlock, constructor);</span>
<span class="line-added"> 298         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)</span>
<span class="line-added"> 299             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());</span>
<span class="line-added"> 300     }</span>
<span class="line-added"> 301     RETURN(result);</span>
<span class="line-added"> 302 }</span>
<span class="line-added"> 303 </span>
<span class="line-added"> 304 SLOW_PATH_DECL(slow_path_new_promise)</span>
<span class="line-added"> 305 {</span>
<span class="line-added"> 306     BEGIN();</span>
<span class="line-added"> 307     auto bytecode = pc-&gt;as&lt;OpNewPromise&gt;();</span>
<span class="line-added"> 308     JSPromise* result = nullptr;</span>
<span class="line-added"> 309     if (bytecode.m_isInternalPromise)</span>
<span class="line-added"> 310         result = JSInternalPromise::create(vm, globalObject-&gt;internalPromiseStructure());</span>
<span class="line-added"> 311     else</span>
<span class="line-added"> 312         result = JSPromise::create(vm, globalObject-&gt;promiseStructure());</span>
<span class="line-added"> 313     RETURN(result);</span>
<span class="line-added"> 314 }</span>
<span class="line-added"> 315 </span>
<span class="line-added"> 316 template&lt;typename JSClass, typename Bytecode&gt;</span>
<span class="line-added"> 317 static JSClass* createInternalFieldObject(JSGlobalObject* globalObject, VM&amp; vm, CodeBlock* codeBlock, const Bytecode&amp; bytecode, JSObject* constructorAsObject, Structure* baseStructure)</span>
<span class="line-added"> 318 {</span>
<span class="line-added"> 319     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 320 </span>
<span class="line-added"> 321     Structure* structure = InternalFunction::createSubclassStructure(globalObject, nullptr, constructorAsObject, baseStructure);</span>
<span class="line-added"> 322     RETURN_IF_EXCEPTION(scope, nullptr);</span>
<span class="line-added"> 323     JSClass* result = JSClass::create(vm, structure);</span>
<span class="line-added"> 324 </span>
<span class="line-added"> 325     JSFunction* constructor = jsDynamicCast&lt;JSFunction*&gt;(vm, constructorAsObject);</span>
<span class="line-added"> 326     if (constructor &amp;&amp; constructor-&gt;canUseAllocationProfile()) {</span>
<span class="line-added"> 327         WriteBarrier&lt;JSCell&gt;&amp; cachedCallee = bytecode.metadata(codeBlock).m_cachedCallee;</span>
<span class="line-added"> 328         if (!cachedCallee)</span>
<span class="line-added"> 329             cachedCallee.set(vm, codeBlock, constructor);</span>
<span class="line-added"> 330         else if (cachedCallee.unvalidatedGet() != JSCell::seenMultipleCalleeObjects() &amp;&amp; cachedCallee.get() != constructor)</span>
<span class="line-added"> 331             cachedCallee.setWithoutWriteBarrier(JSCell::seenMultipleCalleeObjects());</span>
<span class="line-added"> 332     }</span>
<span class="line-added"> 333     RELEASE_AND_RETURN(scope, result);</span>
<span class="line-added"> 334 }</span>
<span class="line-added"> 335 </span>
<span class="line-added"> 336 SLOW_PATH_DECL(slow_path_create_generator)</span>
<span class="line-added"> 337 {</span>
<span class="line-added"> 338     BEGIN();</span>
<span class="line-added"> 339     auto bytecode = pc-&gt;as&lt;OpCreateGenerator&gt;();</span>
<span class="line-added"> 340     RETURN(createInternalFieldObject&lt;JSGenerator&gt;(globalObject, vm, codeBlock, bytecode, asObject(GET(bytecode.m_callee).jsValue()), globalObject-&gt;generatorStructure()));</span>
<span class="line-added"> 341 }</span>
<span class="line-added"> 342 </span>
<span class="line-added"> 343 SLOW_PATH_DECL(slow_path_create_async_generator)</span>
<span class="line-added"> 344 {</span>
<span class="line-added"> 345     BEGIN();</span>
<span class="line-added"> 346     auto bytecode = pc-&gt;as&lt;OpCreateAsyncGenerator&gt;();</span>
<span class="line-added"> 347     RETURN(createInternalFieldObject&lt;JSAsyncGenerator&gt;(globalObject, vm, codeBlock, bytecode, asObject(GET(bytecode.m_callee).jsValue()), globalObject-&gt;asyncGeneratorStructure()));</span>
<span class="line-added"> 348 }</span>
<span class="line-added"> 349 </span>
<span class="line-added"> 350 SLOW_PATH_DECL(slow_path_new_generator)</span>
<span class="line-added"> 351 {</span>
<span class="line-added"> 352     BEGIN();</span>
<span class="line-added"> 353     auto bytecode = pc-&gt;as&lt;OpNewGenerator&gt;();</span>
<span class="line-added"> 354     JSGenerator* result = JSGenerator::create(vm, globalObject-&gt;generatorStructure());</span>
<span class="line-added"> 355     RETURN(result);</span>
<span class="line-added"> 356 }</span>
<span class="line-added"> 357 </span>
 358 SLOW_PATH_DECL(slow_path_to_this)
 359 {
 360     BEGIN();
 361     auto bytecode = pc-&gt;as&lt;OpToThis&gt;();
<span class="line-modified"> 362     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
 363     JSValue v1 = GET(bytecode.m_srcDst).jsValue();
 364     if (v1.isCell()) {
 365         StructureID myStructureID = v1.asCell()-&gt;structureID();
 366         StructureID otherStructureID = metadata.m_cachedStructureID;
 367         if (myStructureID != otherStructureID) {
 368             if (otherStructureID)
 369                 metadata.m_toThisStatus = ToThisConflicted;
 370             metadata.m_cachedStructureID = myStructureID;
<span class="line-modified"> 371             vm.heap.writeBarrier(codeBlock, vm.getStructure(myStructureID));</span>
 372         }
 373     } else {
 374         metadata.m_toThisStatus = ToThisConflicted;
 375         metadata.m_cachedStructureID = 0;
 376     }
 377     // Note: We only need to do this value profiling here on the slow path. The fast path
 378     // just returns the input to to_this if the structure check succeeds. If the structure
 379     // check succeeds, doing value profiling here is equivalent to doing it with a potentially
 380     // different object that still has the same structure on the fast path since it&#39;ll produce
 381     // the same SpeculatedType. Therefore, we don&#39;t need to worry about value profiling on the
 382     // fast path.
<span class="line-modified"> 383     auto value = v1.toThis(globalObject, codeBlock-&gt;isStrictMode() ? StrictMode : NotStrictMode);</span>
 384     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, value, PROFILE_VALUE(value));
 385 }
 386 
 387 SLOW_PATH_DECL(slow_path_throw_tdz_error)
 388 {
 389     BEGIN();
<span class="line-modified"> 390     THROW(createTDZError(globalObject));</span>
 391 }
 392 
 393 SLOW_PATH_DECL(slow_path_check_tdz)
 394 {
 395     BEGIN();
<span class="line-modified"> 396     THROW(createTDZError(globalObject));</span>
 397 }
 398 
 399 SLOW_PATH_DECL(slow_path_throw_strict_mode_readonly_property_write_error)
 400 {
 401     BEGIN();
<span class="line-modified"> 402     THROW(createTypeError(globalObject, ReadonlyPropertyWriteError));</span>
 403 }
 404 
 405 SLOW_PATH_DECL(slow_path_not)
 406 {
 407     BEGIN();
 408     auto bytecode = pc-&gt;as&lt;OpNot&gt;();
<span class="line-modified"> 409     RETURN(jsBoolean(!GET_C(bytecode.m_operand).jsValue().toBoolean(globalObject)));</span>
 410 }
 411 
 412 SLOW_PATH_DECL(slow_path_eq)
 413 {
 414     BEGIN();
 415     auto bytecode = pc-&gt;as&lt;OpEq&gt;();
<span class="line-modified"> 416     RETURN(jsBoolean(JSValue::equal(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 417 }
 418 
 419 SLOW_PATH_DECL(slow_path_neq)
 420 {
 421     BEGIN();
 422     auto bytecode = pc-&gt;as&lt;OpNeq&gt;();
<span class="line-modified"> 423     RETURN(jsBoolean(!JSValue::equal(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 424 }
 425 
 426 SLOW_PATH_DECL(slow_path_stricteq)
 427 {
 428     BEGIN();
 429     auto bytecode = pc-&gt;as&lt;OpStricteq&gt;();
<span class="line-modified"> 430     RETURN(jsBoolean(JSValue::strictEqual(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 431 }
 432 
 433 SLOW_PATH_DECL(slow_path_nstricteq)
 434 {
 435     BEGIN();
 436     auto bytecode = pc-&gt;as&lt;OpNstricteq&gt;();
<span class="line-modified"> 437     RETURN(jsBoolean(!JSValue::strictEqual(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 438 }
 439 
 440 SLOW_PATH_DECL(slow_path_less)
 441 {
 442     BEGIN();
 443     auto bytecode = pc-&gt;as&lt;OpLess&gt;();
<span class="line-modified"> 444     RETURN(jsBoolean(jsLess&lt;true&gt;(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 445 }
 446 
 447 SLOW_PATH_DECL(slow_path_lesseq)
 448 {
 449     BEGIN();
 450     auto bytecode = pc-&gt;as&lt;OpLesseq&gt;();
<span class="line-modified"> 451     RETURN(jsBoolean(jsLessEq&lt;true&gt;(globalObject, GET_C(bytecode.m_lhs).jsValue(), GET_C(bytecode.m_rhs).jsValue())));</span>
 452 }
 453 
 454 SLOW_PATH_DECL(slow_path_greater)
 455 {
 456     BEGIN();
 457     auto bytecode = pc-&gt;as&lt;OpGreater&gt;();
<span class="line-modified"> 458     RETURN(jsBoolean(jsLess&lt;false&gt;(globalObject, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));</span>
 459 }
 460 
 461 SLOW_PATH_DECL(slow_path_greatereq)
 462 {
 463     BEGIN();
 464     auto bytecode = pc-&gt;as&lt;OpGreatereq&gt;();
<span class="line-modified"> 465     RETURN(jsBoolean(jsLessEq&lt;false&gt;(globalObject, GET_C(bytecode.m_rhs).jsValue(), GET_C(bytecode.m_lhs).jsValue())));</span>
 466 }
 467 
 468 SLOW_PATH_DECL(slow_path_inc)
 469 {
 470     BEGIN();
 471     auto bytecode = pc-&gt;as&lt;OpInc&gt;();
<span class="line-modified"> 472     JSValue argument = GET_C(bytecode.m_srcDst).jsValue();</span>
<span class="line-added"> 473     Variant&lt;JSBigInt*, double&gt; resultVariant = argument.toNumeric(globalObject);</span>
<span class="line-added"> 474     CHECK_EXCEPTION();</span>
<span class="line-added"> 475     JSValue result;</span>
<span class="line-added"> 476     if (WTF::holds_alternative&lt;JSBigInt*&gt;(resultVariant))</span>
<span class="line-added"> 477         result = JSBigInt::inc(globalObject, WTF::get&lt;JSBigInt*&gt;(resultVariant));</span>
<span class="line-added"> 478     else</span>
<span class="line-added"> 479         result = jsNumber(WTF::get&lt;double&gt;(resultVariant) + 1);</span>
<span class="line-added"> 480     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, result, { });</span>
 481 }
 482 
 483 SLOW_PATH_DECL(slow_path_dec)
 484 {
 485     BEGIN();
 486     auto bytecode = pc-&gt;as&lt;OpDec&gt;();
<span class="line-modified"> 487     JSValue argument = GET_C(bytecode.m_srcDst).jsValue();</span>
<span class="line-added"> 488     Variant&lt;JSBigInt*, double&gt; resultVariant = argument.toNumeric(globalObject);</span>
<span class="line-added"> 489     CHECK_EXCEPTION();</span>
<span class="line-added"> 490     JSValue result;</span>
<span class="line-added"> 491     if (WTF::holds_alternative&lt;JSBigInt*&gt;(resultVariant))</span>
<span class="line-added"> 492         result = JSBigInt::dec(globalObject, WTF::get&lt;JSBigInt*&gt;(resultVariant));</span>
<span class="line-added"> 493     else</span>
<span class="line-added"> 494         result = jsNumber(WTF::get&lt;double&gt;(resultVariant) - 1);</span>
<span class="line-added"> 495     RETURN_WITH_PROFILING_CUSTOM(bytecode.m_srcDst, result, { });</span>
 496 }
 497 
 498 SLOW_PATH_DECL(slow_path_to_string)
 499 {
 500     BEGIN();
 501     auto bytecode = pc-&gt;as&lt;OpToString&gt;();
<span class="line-modified"> 502     RETURN(GET_C(bytecode.m_operand).jsValue().toString(globalObject));</span>
 503 }
 504 
 505 #if ENABLE(JIT)
 506 static void updateArithProfileForUnaryArithOp(OpNegate::Metadata&amp; metadata, JSValue result, JSValue operand)
 507 {
<span class="line-modified"> 508     UnaryArithProfile&amp; profile = metadata.m_arithProfile;</span>
<span class="line-modified"> 509     profile.observeArg(operand);</span>
 510     ASSERT(result.isNumber() || result.isBigInt());
 511     if (result.isNumber()) {
 512         if (!result.isInt32()) {
 513             if (operand.isInt32())
 514                 profile.setObservedInt32Overflow();
 515 
 516             double doubleVal = result.asNumber();
 517             if (!doubleVal &amp;&amp; std::signbit(doubleVal))
 518                 profile.setObservedNegZeroDouble();
 519             else {
 520                 profile.setObservedNonNegZeroDouble();
 521 
 522                 // The Int52 overflow check here intentionally omits 1ll &lt;&lt; 51 as a valid negative Int52 value.
 523                 // Therefore, we will get a false positive if the result is that value. This is intentionally
 524                 // done to simplify the checking algorithm.
 525                 static const int64_t int52OverflowPoint = (1ll &lt;&lt; 51);
 526                 int64_t int64Val = static_cast&lt;int64_t&gt;(std::abs(doubleVal));
 527                 if (int64Val &gt;= int52OverflowPoint)
 528                     profile.setObservedInt52Overflow();
 529             }
 530         }
 531     } else if (result.isBigInt())
 532         profile.setObservedBigInt();
 533     else
 534         profile.setObservedNonNumeric();
 535 }
 536 #else
 537 static void updateArithProfileForUnaryArithOp(OpNegate::Metadata&amp;, JSValue, JSValue) { }
 538 #endif
 539 
 540 SLOW_PATH_DECL(slow_path_negate)
 541 {
 542     BEGIN();
 543     auto bytecode = pc-&gt;as&lt;OpNegate&gt;();
<span class="line-modified"> 544     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
 545     JSValue operand = GET_C(bytecode.m_operand).jsValue();
<span class="line-modified"> 546     JSValue primValue = operand.toPrimitive(globalObject, PreferNumber);</span>
 547     CHECK_EXCEPTION();
 548 
 549     if (primValue.isBigInt()) {
 550         JSBigInt* result = JSBigInt::unaryMinus(vm, asBigInt(primValue));
 551         RETURN_WITH_PROFILING(result, {
 552             updateArithProfileForUnaryArithOp(metadata, result, operand);
 553         });
 554     }
 555 
<span class="line-modified"> 556     JSValue result = jsNumber(-primValue.toNumber(globalObject));</span>
 557     CHECK_EXCEPTION();
 558     RETURN_WITH_PROFILING(result, {
 559         updateArithProfileForUnaryArithOp(metadata, result, operand);
 560     });
 561 }
 562 
 563 #if ENABLE(DFG_JIT)
<span class="line-modified"> 564 static void updateArithProfileForBinaryArithOp(JSGlobalObject*, CodeBlock* codeBlock, const Instruction* pc, JSValue result, JSValue left, JSValue right)</span>
 565 {
<span class="line-modified"> 566     BinaryArithProfile&amp; profile = *codeBlock-&gt;binaryArithProfileForPC(pc);</span>

 567 
 568     if (result.isNumber()) {
 569         if (!result.isInt32()) {
 570             if (left.isInt32() &amp;&amp; right.isInt32())
 571                 profile.setObservedInt32Overflow();
 572 
 573             double doubleVal = result.asNumber();
 574             if (!doubleVal &amp;&amp; std::signbit(doubleVal))
 575                 profile.setObservedNegZeroDouble();
 576             else {
 577                 profile.setObservedNonNegZeroDouble();
 578 
 579                 // The Int52 overflow check here intentionally omits 1ll &lt;&lt; 51 as a valid negative Int52 value.
 580                 // Therefore, we will get a false positive if the result is that value. This is intentionally
 581                 // done to simplify the checking algorithm.
 582                 static const int64_t int52OverflowPoint = (1ll &lt;&lt; 51);
 583                 int64_t int64Val = static_cast&lt;int64_t&gt;(std::abs(doubleVal));
 584                 if (int64Val &gt;= int52OverflowPoint)
 585                     profile.setObservedInt52Overflow();
 586             }
 587         }
 588     } else if (result.isBigInt())
 589         profile.setObservedBigInt();
 590     else
 591         profile.setObservedNonNumeric();
 592 }
 593 #else
<span class="line-modified"> 594 static void updateArithProfileForBinaryArithOp(JSGlobalObject*, CodeBlock*, const Instruction*, JSValue, JSValue, JSValue) { }</span>
 595 #endif
 596 
 597 SLOW_PATH_DECL(slow_path_to_number)
 598 {
 599     BEGIN();
 600     auto bytecode = pc-&gt;as&lt;OpToNumber&gt;();
 601     JSValue argument = GET_C(bytecode.m_operand).jsValue();
<span class="line-modified"> 602     JSValue result = jsNumber(argument.toNumber(globalObject));</span>
<span class="line-added"> 603     RETURN_PROFILED(result);</span>
<span class="line-added"> 604 }</span>
<span class="line-added"> 605 </span>
<span class="line-added"> 606 SLOW_PATH_DECL(slow_path_to_numeric)</span>
<span class="line-added"> 607 {</span>
<span class="line-added"> 608     BEGIN();</span>
<span class="line-added"> 609     auto bytecode = pc-&gt;as&lt;OpToNumeric&gt;();</span>
<span class="line-added"> 610     JSValue argument = GET_C(bytecode.m_operand).jsValue();</span>
<span class="line-added"> 611     Variant&lt;JSBigInt*, double&gt; resultVariant = argument.toNumeric(globalObject);</span>
<span class="line-added"> 612     CHECK_EXCEPTION();</span>
<span class="line-added"> 613     JSValue result;</span>
<span class="line-added"> 614     if (WTF::holds_alternative&lt;JSBigInt*&gt;(resultVariant))</span>
<span class="line-added"> 615         result = WTF::get&lt;JSBigInt*&gt;(resultVariant);</span>
<span class="line-added"> 616     else</span>
<span class="line-added"> 617         result = jsNumber(WTF::get&lt;double&gt;(resultVariant));</span>
 618     RETURN_PROFILED(result);
 619 }
 620 
 621 SLOW_PATH_DECL(slow_path_to_object)
 622 {
 623     BEGIN();
 624     auto bytecode = pc-&gt;as&lt;OpToObject&gt;();
 625     JSValue argument = GET_C(bytecode.m_operand).jsValue();
 626     if (UNLIKELY(argument.isUndefinedOrNull())) {
<span class="line-modified"> 627         const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_message);</span>
 628         if (!ident.isEmpty())
<span class="line-modified"> 629             THROW(createTypeError(globalObject, ident.impl()));</span>
 630     }
<span class="line-modified"> 631     JSObject* result = argument.toObject(globalObject);</span>
 632     RETURN_PROFILED(result);
 633 }
 634 
 635 SLOW_PATH_DECL(slow_path_add)
 636 {
 637     BEGIN();
 638     auto bytecode = pc-&gt;as&lt;OpAdd&gt;();
 639     JSValue v1 = GET_C(bytecode.m_lhs).jsValue();
 640     JSValue v2 = GET_C(bytecode.m_rhs).jsValue();
 641 
<span class="line-modified"> 642     BinaryArithProfile&amp; arithProfile = *codeBlock-&gt;binaryArithProfileForPC(pc);</span>
 643     arithProfile.observeLHSAndRHS(v1, v2);
 644 
<span class="line-modified"> 645     JSValue result = jsAdd(globalObject, v1, v2);</span>
 646 
 647     RETURN_WITH_PROFILING(result, {
<span class="line-modified"> 648         updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, v1, v2);</span>
 649     });
 650 }
 651 
 652 // The following arithmetic and bitwise operations need to be sure to run
 653 // toNumber() on their operands in order.  (A call to toNumber() is idempotent
<span class="line-modified"> 654 // if an exception is already set on the CallFrame.)</span>
 655 
 656 SLOW_PATH_DECL(slow_path_mul)
 657 {
 658     BEGIN();
 659     auto bytecode = pc-&gt;as&lt;OpMul&gt;();
 660     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 661     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified"> 662     JSValue result = jsMul(globalObject, left, right);</span>
 663     CHECK_EXCEPTION();
 664     RETURN_WITH_PROFILING(result, {
<span class="line-modified"> 665         updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);</span>
 666     });
 667 }
 668 
 669 SLOW_PATH_DECL(slow_path_sub)
 670 {
 671     BEGIN();
 672     auto bytecode = pc-&gt;as&lt;OpSub&gt;();
 673     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 674     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified"> 675     auto leftNumeric = left.toNumeric(globalObject);</span>
 676     CHECK_EXCEPTION();
<span class="line-modified"> 677     auto rightNumeric = right.toNumeric(globalObject);</span>
 678     CHECK_EXCEPTION();
 679 
 680     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 681         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 682             JSBigInt* result = JSBigInt::sub(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 683             CHECK_EXCEPTION();
 684             RETURN_WITH_PROFILING(result, {
<span class="line-modified"> 685                 updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);</span>
 686             });
 687         }
 688 
<span class="line-modified"> 689         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in subtraction.&quot;));</span>
 690     }
 691 
 692     JSValue result = jsNumber(WTF::get&lt;double&gt;(leftNumeric) - WTF::get&lt;double&gt;(rightNumeric));
 693     RETURN_WITH_PROFILING(result, {
<span class="line-modified"> 694         updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);</span>
 695     });
 696 }
 697 
 698 SLOW_PATH_DECL(slow_path_div)
 699 {
 700     BEGIN();
 701     auto bytecode = pc-&gt;as&lt;OpDiv&gt;();
 702     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 703     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified"> 704     auto leftNumeric = left.toNumeric(globalObject);</span>
 705     CHECK_EXCEPTION();
<span class="line-modified"> 706     auto rightNumeric = right.toNumeric(globalObject);</span>
 707     CHECK_EXCEPTION();
 708 
 709     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 710         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 711             JSBigInt* result = JSBigInt::divide(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 712             CHECK_EXCEPTION();
 713             RETURN_WITH_PROFILING(result, {
<span class="line-modified"> 714                 updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);</span>
 715             });
 716         }
 717 
<span class="line-modified"> 718         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in division.&quot;));</span>
 719     }
 720 
 721     double a = WTF::get&lt;double&gt;(leftNumeric);
 722     double b = WTF::get&lt;double&gt;(rightNumeric);
 723     JSValue result = jsNumber(a / b);
 724     RETURN_WITH_PROFILING(result, {
<span class="line-modified"> 725         updateArithProfileForBinaryArithOp(globalObject, codeBlock, pc, result, left, right);</span>
 726     });
 727 }
 728 
 729 SLOW_PATH_DECL(slow_path_mod)
 730 {
 731     BEGIN();
 732     auto bytecode = pc-&gt;as&lt;OpMod&gt;();
 733     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 734     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified"> 735     auto leftNumeric = left.toNumeric(globalObject);</span>
 736     CHECK_EXCEPTION();
<span class="line-modified"> 737     auto rightNumeric = right.toNumeric(globalObject);</span>
 738     CHECK_EXCEPTION();
 739 
 740     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 741         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 742             JSBigInt* result = JSBigInt::remainder(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 743             CHECK_EXCEPTION();
 744             RETURN(result);
 745         }
 746 
<span class="line-modified"> 747         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in remainder operation.&quot;));</span>
 748     }
 749 
 750     double a = WTF::get&lt;double&gt;(leftNumeric);
 751     double b = WTF::get&lt;double&gt;(rightNumeric);
 752     RETURN(jsNumber(jsMod(a, b)));
 753 }
 754 
 755 SLOW_PATH_DECL(slow_path_pow)
 756 {
 757     BEGIN();
 758     auto bytecode = pc-&gt;as&lt;OpPow&gt;();
 759     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 760     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified"> 761     auto leftNumeric = left.toNumeric(globalObject);</span>
 762     CHECK_EXCEPTION();
<span class="line-modified"> 763     auto rightNumeric = right.toNumeric(globalObject);</span>
 764     CHECK_EXCEPTION();
 765 
 766     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 767         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 768             JSBigInt* result = JSBigInt::exponentiate(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 769             CHECK_EXCEPTION();
 770             RETURN(result);
 771         }
 772 
<span class="line-modified"> 773         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in exponentiation operation.&quot;));</span>
 774     }
 775 
 776     double a = WTF::get&lt;double&gt;(leftNumeric);
 777     double b = WTF::get&lt;double&gt;(rightNumeric);
 778 
 779     RETURN(jsNumber(operationMathPow(a, b)));
 780 }
 781 
 782 SLOW_PATH_DECL(slow_path_lshift)
 783 {
 784     BEGIN();
 785     auto bytecode = pc-&gt;as&lt;OpLshift&gt;();
 786     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 787     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified"> 788     auto leftNumeric = left.toBigIntOrInt32(globalObject);</span>
 789     CHECK_EXCEPTION();
<span class="line-modified"> 790     auto rightNumeric = right.toBigIntOrInt32(globalObject);</span>
 791     CHECK_EXCEPTION();
 792 
 793     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 794         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 795             JSBigInt* result = JSBigInt::leftShift(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 796             CHECK_EXCEPTION();
 797             RETURN_PROFILED(result);
 798         }
 799 
<span class="line-modified"> 800         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in left shift operation.&quot;));</span>
 801     }
 802 
 803     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &lt;&lt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));
 804 }
 805 
 806 SLOW_PATH_DECL(slow_path_rshift)
 807 {
 808     BEGIN();
 809     auto bytecode = pc-&gt;as&lt;OpRshift&gt;();
 810     JSValue left = GET_C(bytecode.m_lhs).jsValue();
 811     JSValue right = GET_C(bytecode.m_rhs).jsValue();
<span class="line-modified"> 812     auto leftNumeric = left.toBigIntOrInt32(globalObject);</span>
 813     CHECK_EXCEPTION();
<span class="line-modified"> 814     auto rightNumeric = right.toBigIntOrInt32(globalObject);</span>
 815     CHECK_EXCEPTION();
 816 
 817     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 818         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 819             JSBigInt* result = JSBigInt::signedRightShift(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 820             CHECK_EXCEPTION();
<span class="line-modified"> 821             RETURN_PROFILED(result);</span>
 822         }
 823 
<span class="line-modified"> 824         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in signed right shift operation.&quot;_s));</span>
 825     }
 826 
<span class="line-modified"> 827     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &gt;&gt; (WTF::get&lt;int32_t&gt;(rightNumeric) &amp; 31)));</span>
 828 }
 829 
 830 SLOW_PATH_DECL(slow_path_urshift)
 831 {
 832     BEGIN();
 833     auto bytecode = pc-&gt;as&lt;OpUrshift&gt;();
<span class="line-modified"> 834     uint32_t a = GET_C(bytecode.m_lhs).jsValue().toUInt32(globalObject);</span>
 835     if (UNLIKELY(throwScope.exception()))
 836         RETURN(JSValue());
<span class="line-modified"> 837     uint32_t b = GET_C(bytecode.m_rhs).jsValue().toUInt32(globalObject);</span>
 838     RETURN(jsNumber(static_cast&lt;int32_t&gt;(a &gt;&gt; (b &amp; 31))));
 839 }
 840 
 841 SLOW_PATH_DECL(slow_path_unsigned)
 842 {
 843     BEGIN();
 844     auto bytecode = pc-&gt;as&lt;OpUnsigned&gt;();
<span class="line-modified"> 845     uint32_t a = GET_C(bytecode.m_operand).jsValue().toUInt32(globalObject);</span>
 846     RETURN(jsNumber(a));
 847 }
 848 
 849 SLOW_PATH_DECL(slow_path_bitnot)
 850 {
 851     BEGIN();
 852     auto bytecode = pc-&gt;as&lt;OpBitnot&gt;();
<span class="line-modified"> 853     auto operandNumeric = GET_C(bytecode.m_operand).jsValue().toBigIntOrInt32(globalObject);</span>
 854     CHECK_EXCEPTION();
 855 
 856     if (WTF::holds_alternative&lt;JSBigInt*&gt;(operandNumeric)) {
<span class="line-modified"> 857         JSBigInt* result = JSBigInt::bitwiseNot(globalObject, WTF::get&lt;JSBigInt*&gt;(operandNumeric));</span>
 858         CHECK_EXCEPTION();
 859         RETURN_PROFILED(result);
 860     }
 861 
 862     RETURN_PROFILED(jsNumber(~WTF::get&lt;int32_t&gt;(operandNumeric)));
 863 }
 864 
 865 SLOW_PATH_DECL(slow_path_bitand)
 866 {
 867     BEGIN();
 868     auto bytecode = pc-&gt;as&lt;OpBitand&gt;();
<span class="line-modified"> 869     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(globalObject);</span>
 870     CHECK_EXCEPTION();
<span class="line-modified"> 871     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(globalObject);</span>
 872     CHECK_EXCEPTION();
 873     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 874         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 875             JSBigInt* result = JSBigInt::bitwiseAnd(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 876             CHECK_EXCEPTION();
 877             RETURN_PROFILED(result);
 878         }
 879 
<span class="line-modified"> 880         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in bitwise &#39;and&#39; operation.&quot;));</span>
 881     }
 882 
 883     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) &amp; WTF::get&lt;int32_t&gt;(rightNumeric)));
 884 }
 885 
 886 SLOW_PATH_DECL(slow_path_bitor)
 887 {
 888     BEGIN();
 889     auto bytecode = pc-&gt;as&lt;OpBitor&gt;();
<span class="line-modified"> 890     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(globalObject);</span>
 891     CHECK_EXCEPTION();
<span class="line-modified"> 892     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(globalObject);</span>
 893     CHECK_EXCEPTION();
 894     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 895         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 896             JSBigInt* result = JSBigInt::bitwiseOr(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 897             CHECK_EXCEPTION();
 898             RETURN_PROFILED(result);
 899         }
 900 
<span class="line-modified"> 901         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in bitwise &#39;or&#39; operation.&quot;));</span>
 902     }
 903 
 904     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) | WTF::get&lt;int32_t&gt;(rightNumeric)));
 905 }
 906 
 907 SLOW_PATH_DECL(slow_path_bitxor)
 908 {
 909     BEGIN();
 910     auto bytecode = pc-&gt;as&lt;OpBitxor&gt;();
<span class="line-modified"> 911     auto leftNumeric = GET_C(bytecode.m_lhs).jsValue().toBigIntOrInt32(globalObject);</span>
 912     CHECK_EXCEPTION();
<span class="line-modified"> 913     auto rightNumeric = GET_C(bytecode.m_rhs).jsValue().toBigIntOrInt32(globalObject);</span>
 914     CHECK_EXCEPTION();
 915     if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) || WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
 916         if (WTF::holds_alternative&lt;JSBigInt*&gt;(leftNumeric) &amp;&amp; WTF::holds_alternative&lt;JSBigInt*&gt;(rightNumeric)) {
<span class="line-modified"> 917             JSBigInt* result = JSBigInt::bitwiseXor(globalObject, WTF::get&lt;JSBigInt*&gt;(leftNumeric), WTF::get&lt;JSBigInt*&gt;(rightNumeric));</span>
 918             CHECK_EXCEPTION();
 919             RETURN_PROFILED(result);
 920         }
 921 
<span class="line-modified"> 922         THROW(createTypeError(globalObject, &quot;Invalid mix of BigInt and other type in bitwise &#39;xor&#39; operation.&quot;));</span>
 923     }
 924 
 925     RETURN_PROFILED(jsNumber(WTF::get&lt;int32_t&gt;(leftNumeric) ^ WTF::get&lt;int32_t&gt;(rightNumeric)));
 926 }
 927 
 928 SLOW_PATH_DECL(slow_path_typeof)
 929 {
 930     BEGIN();
 931     auto bytecode = pc-&gt;as&lt;OpTypeof&gt;();
<span class="line-modified"> 932     RETURN(jsTypeStringForValue(globalObject, GET_C(bytecode.m_value).jsValue()));</span>
 933 }
 934 
 935 SLOW_PATH_DECL(slow_path_is_object_or_null)
 936 {
 937     BEGIN();
 938     auto bytecode = pc-&gt;as&lt;OpIsObjectOrNull&gt;();
<span class="line-modified"> 939     RETURN(jsBoolean(jsIsObjectTypeOrNull(globalObject, GET_C(bytecode.m_operand).jsValue())));</span>
 940 }
 941 
 942 SLOW_PATH_DECL(slow_path_is_function)
 943 {
 944     BEGIN();
 945     auto bytecode = pc-&gt;as&lt;OpIsFunction&gt;();
 946     RETURN(jsBoolean(GET_C(bytecode.m_operand).jsValue().isFunction(vm)));
 947 }
 948 
 949 SLOW_PATH_DECL(slow_path_in_by_val)
 950 {
 951     BEGIN();
 952     auto bytecode = pc-&gt;as&lt;OpInByVal&gt;();
<span class="line-modified"> 953     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified"> 954     RETURN(jsBoolean(CommonSlowPaths::opInByVal(globalObject, GET_C(bytecode.m_base).jsValue(), GET_C(bytecode.m_property).jsValue(), &amp;metadata.m_arrayProfile)));</span>
 955 }
 956 
 957 SLOW_PATH_DECL(slow_path_in_by_id)
 958 {
 959     BEGIN();
 960 
 961     auto bytecode = pc-&gt;as&lt;OpInById&gt;();
 962     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
 963     if (!baseValue.isObject())
<span class="line-modified"> 964         THROW(createInvalidInParameterError(globalObject, baseValue));</span>
 965 
<span class="line-modified"> 966     RETURN(jsBoolean(asObject(baseValue)-&gt;hasProperty(globalObject, codeBlock-&gt;identifier(bytecode.m_property))));</span>
 967 }
 968 
 969 SLOW_PATH_DECL(slow_path_del_by_val)
 970 {
 971     BEGIN();
 972     auto bytecode = pc-&gt;as&lt;OpDelByVal&gt;();
 973     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
<span class="line-modified"> 974     JSObject* baseObject = baseValue.toObject(globalObject);</span>
 975     CHECK_EXCEPTION();
 976 
 977     JSValue subscript = GET_C(bytecode.m_property).jsValue();
 978 
 979     bool couldDelete;
 980 
 981     uint32_t i;
 982     if (subscript.getUInt32(i))
<span class="line-modified"> 983         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(baseObject, globalObject, i);</span>
 984     else {
 985         CHECK_EXCEPTION();
<span class="line-modified"> 986         auto property = subscript.toPropertyKey(globalObject);</span>
 987         CHECK_EXCEPTION();
<span class="line-modified"> 988         couldDelete = baseObject-&gt;methodTable(vm)-&gt;deleteProperty(baseObject, globalObject, property);</span>
 989     }
<span class="line-added"> 990     CHECK_EXCEPTION();</span>
 991 
<span class="line-modified"> 992     if (!couldDelete &amp;&amp; codeBlock-&gt;isStrictMode())</span>
<span class="line-modified"> 993         THROW(createTypeError(globalObject, UnableToDeletePropertyError));</span>
 994 
 995     RETURN(jsBoolean(couldDelete));
 996 }
 997 
 998 SLOW_PATH_DECL(slow_path_strcat)
 999 {
1000     BEGIN();
1001     auto bytecode = pc-&gt;as&lt;OpStrcat&gt;();
<span class="line-modified">1002     RETURN(jsStringFromRegisterArray(globalObject, &amp;GET(bytecode.m_src), bytecode.m_count));</span>
1003 }
1004 
1005 SLOW_PATH_DECL(slow_path_to_primitive)
1006 {
1007     BEGIN();
1008     auto bytecode = pc-&gt;as&lt;OpToPrimitive&gt;();
<span class="line-modified">1009     RETURN(GET_C(bytecode.m_src).jsValue().toPrimitive(globalObject));</span>
<span class="line-added">1010 }</span>
<span class="line-added">1011 </span>
<span class="line-added">1012 SLOW_PATH_DECL(slow_path_enter)</span>
<span class="line-added">1013 {</span>
<span class="line-added">1014     BEGIN();</span>
<span class="line-added">1015     Heap::heap(codeBlock)-&gt;writeBarrier(codeBlock);</span>
<span class="line-added">1016     END();</span>
<span class="line-added">1017 }</span>
<span class="line-added">1018 </span>
<span class="line-added">1019 SLOW_PATH_DECL(slow_path_to_property_key)</span>
<span class="line-added">1020 {</span>
<span class="line-added">1021     BEGIN();</span>
<span class="line-added">1022     auto bytecode = pc-&gt;as&lt;OpToPropertyKey&gt;();</span>
<span class="line-added">1023     RETURN(GET_C(bytecode.m_src).jsValue().toPropertyKeyValue(globalObject));</span>
1024 }
1025 
1026 SLOW_PATH_DECL(slow_path_get_enumerable_length)
1027 {
1028     BEGIN();
1029     auto bytecode = pc-&gt;as&lt;OpGetEnumerableLength&gt;();
1030     JSValue enumeratorValue = GET(bytecode.m_base).jsValue();
1031     if (enumeratorValue.isUndefinedOrNull())
1032         RETURN(jsNumber(0));
1033 
1034     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(enumeratorValue.asCell());
1035 
1036     RETURN(jsNumber(enumerator-&gt;indexedLength()));
1037 }
1038 
1039 SLOW_PATH_DECL(slow_path_has_indexed_property)
1040 {
1041     BEGIN();
1042     auto bytecode = pc-&gt;as&lt;OpHasIndexedProperty&gt;();
<span class="line-modified">1043     auto&amp; metadata = bytecode.metadata(codeBlock);</span>
<span class="line-modified">1044     JSObject* base = GET(bytecode.m_base).jsValue().toObject(globalObject);</span>
1045     CHECK_EXCEPTION();
1046     JSValue property = GET(bytecode.m_property).jsValue();
1047     metadata.m_arrayProfile.observeStructure(base-&gt;structure(vm));
1048     ASSERT(property.isUInt32AsAnyInt());
<span class="line-modified">1049     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(globalObject, property.asUInt32AsAnyInt(), PropertySlot::InternalMethodType::GetOwnProperty)));</span>
1050 }
1051 
1052 SLOW_PATH_DECL(slow_path_has_structure_property)
1053 {
1054     BEGIN();
1055     auto bytecode = pc-&gt;as&lt;OpHasStructureProperty&gt;();
<span class="line-modified">1056     JSObject* base = GET(bytecode.m_base).jsValue().toObject(globalObject);</span>
1057     CHECK_EXCEPTION();
1058     JSValue property = GET(bytecode.m_property).jsValue();
1059     ASSERT(property.isString());
1060     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
1061     if (base-&gt;structure(vm)-&gt;id() == enumerator-&gt;cachedStructureID())
1062         RETURN(jsBoolean(true));
1063     JSString* string = asString(property);
<span class="line-modified">1064     auto propertyName = string-&gt;toIdentifier(globalObject);</span>
1065     CHECK_EXCEPTION();
<span class="line-modified">1066     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
1067 }
1068 
1069 SLOW_PATH_DECL(slow_path_has_generic_property)
1070 {
1071     BEGIN();
1072     auto bytecode = pc-&gt;as&lt;OpHasGenericProperty&gt;();
<span class="line-modified">1073     JSObject* base = GET(bytecode.m_base).jsValue().toObject(globalObject);</span>
1074     CHECK_EXCEPTION();
1075     JSValue property = GET(bytecode.m_property).jsValue();
1076     ASSERT(property.isString());
1077     JSString* string = asString(property);
<span class="line-modified">1078     auto propertyName = string-&gt;toIdentifier(globalObject);</span>
1079     CHECK_EXCEPTION();
<span class="line-modified">1080     RETURN(jsBoolean(base-&gt;hasPropertyGeneric(globalObject, propertyName, PropertySlot::InternalMethodType::GetOwnProperty)));</span>
1081 }
1082 
1083 SLOW_PATH_DECL(slow_path_get_direct_pname)
1084 {
1085     BEGIN();
1086     auto bytecode = pc-&gt;as&lt;OpGetDirectPname&gt;();
1087     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1088     JSValue property = GET(bytecode.m_property).jsValue();
1089     ASSERT(property.isString());
1090     JSString* string = asString(property);
<span class="line-modified">1091     auto propertyName = string-&gt;toIdentifier(globalObject);</span>
1092     CHECK_EXCEPTION();
<span class="line-modified">1093     RETURN(baseValue.get(globalObject, propertyName));</span>
1094 }
1095 
1096 SLOW_PATH_DECL(slow_path_get_property_enumerator)
1097 {
1098     BEGIN();
1099     auto bytecode = pc-&gt;as&lt;OpGetPropertyEnumerator&gt;();
1100     JSValue baseValue = GET(bytecode.m_base).jsValue();
1101     if (baseValue.isUndefinedOrNull())
1102         RETURN(vm.emptyPropertyNameEnumerator());
1103 
<span class="line-modified">1104     JSObject* base = baseValue.toObject(globalObject);</span>
1105     CHECK_EXCEPTION();
1106 
<span class="line-modified">1107     RETURN(propertyNameEnumerator(globalObject, base));</span>
1108 }
1109 
1110 SLOW_PATH_DECL(slow_path_enumerator_structure_pname)
1111 {
1112     BEGIN();
1113     auto bytecode = pc-&gt;as&lt;OpEnumeratorStructurePname&gt;();
1114     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
1115     uint32_t index = GET(bytecode.m_index).jsValue().asUInt32();
1116 
1117     JSString* propertyName = nullptr;
1118     if (index &lt; enumerator-&gt;endStructurePropertyIndex())
1119         propertyName = enumerator-&gt;propertyNameAtIndex(index);
1120     RETURN(propertyName ? propertyName : jsNull());
1121 }
1122 
1123 SLOW_PATH_DECL(slow_path_enumerator_generic_pname)
1124 {
1125     BEGIN();
1126     auto bytecode = pc-&gt;as&lt;OpEnumeratorGenericPname&gt;();
1127     JSPropertyNameEnumerator* enumerator = jsCast&lt;JSPropertyNameEnumerator*&gt;(GET(bytecode.m_enumerator).jsValue().asCell());
</pre>
<hr />
<pre>
1143 }
1144 
1145 SLOW_PATH_DECL(slow_path_profile_type_clear_log)
1146 {
1147     BEGIN();
1148     vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;LLInt log full.&quot;_s);
1149     END();
1150 }
1151 
1152 SLOW_PATH_DECL(slow_path_unreachable)
1153 {
1154     BEGIN();
1155     UNREACHABLE_FOR_PLATFORM();
1156     END();
1157 }
1158 
1159 SLOW_PATH_DECL(slow_path_create_lexical_environment)
1160 {
1161     BEGIN();
1162     auto bytecode = pc-&gt;as&lt;OpCreateLexicalEnvironment&gt;();
<span class="line-modified">1163     JSScope* currentScope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>

1164     SymbolTable* symbolTable = jsCast&lt;SymbolTable*&gt;(GET_C(bytecode.m_symbolTable).jsValue());
1165     JSValue initialValue = GET_C(bytecode.m_initialValue).jsValue();
1166     ASSERT(initialValue == jsUndefined() || initialValue == jsTDZValue());
<span class="line-modified">1167     JSScope* newScope = JSLexicalEnvironment::create(vm, globalObject, currentScope, symbolTable, initialValue);</span>
1168     RETURN(newScope);
1169 }
1170 
1171 SLOW_PATH_DECL(slow_path_push_with_scope)
1172 {
1173     BEGIN();
1174     auto bytecode = pc-&gt;as&lt;OpPushWithScope&gt;();
<span class="line-modified">1175     JSObject* newScope = GET_C(bytecode.m_newScope).jsValue().toObject(globalObject);</span>
1176     CHECK_EXCEPTION();
1177 
<span class="line-modified">1178     JSScope* currentScope = callFrame-&gt;uncheckedR(bytecode.m_currentScope).Register::scope();</span>
<span class="line-modified">1179     RETURN(JSWithScope::create(vm, globalObject, currentScope, newScope));</span>

1180 }
1181 
1182 SLOW_PATH_DECL(slow_path_resolve_scope_for_hoisting_func_decl_in_eval)
1183 {
1184     BEGIN();
1185     auto bytecode = pc-&gt;as&lt;OpResolveScopeForHoistingFuncDeclInEval&gt;();
<span class="line-modified">1186     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);</span>
<span class="line-modified">1187     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
<span class="line-modified">1188     JSValue resolvedScope = JSScope::resolveScopeForHoistingFuncDeclInEval(globalObject, scope, ident);</span>
1189 
1190     CHECK_EXCEPTION();
1191 
1192     RETURN(resolvedScope);
1193 }
1194 
1195 SLOW_PATH_DECL(slow_path_resolve_scope)
1196 {
1197     BEGIN();
1198     auto bytecode = pc-&gt;as&lt;OpResolveScope&gt;();
<span class="line-modified">1199     auto&amp; metadata = bytecode.metadata(codeBlock);</span>

1200     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_var);
<span class="line-modified">1201     JSScope* scope = callFrame-&gt;uncheckedR(bytecode.m_scope).Register::scope();</span>
<span class="line-modified">1202     JSObject* resolvedScope = JSScope::resolve(globalObject, scope, ident);</span>
1203     // Proxy can throw an error here, e.g. Proxy in with statement&#39;s @unscopables.
1204     CHECK_EXCEPTION();
1205 
1206     ResolveType resolveType = metadata.m_resolveType;
1207 
1208     // ModuleVar does not keep the scope register value alive in DFG.
1209     ASSERT(resolveType != ModuleVar);
1210 
1211     switch (resolveType) {
1212     case GlobalProperty:
1213     case GlobalPropertyWithVarInjectionChecks:
1214     case UnresolvedProperty:
1215     case UnresolvedPropertyWithVarInjectionChecks: {
1216         if (resolvedScope-&gt;isGlobalObject()) {
1217             JSGlobalObject* globalObject = jsCast&lt;JSGlobalObject*&gt;(resolvedScope);
<span class="line-modified">1218             bool hasProperty = globalObject-&gt;hasProperty(globalObject, ident);</span>
1219             CHECK_EXCEPTION();
1220             if (hasProperty) {
1221                 ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
1222                 metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalPropertyWithVarInjectionChecks : GlobalProperty;
1223                 metadata.m_globalObject.set(vm, codeBlock, globalObject);
1224                 metadata.m_globalLexicalBindingEpoch = globalObject-&gt;globalLexicalBindingEpoch();
1225             }
1226         } else if (resolvedScope-&gt;isGlobalLexicalEnvironment()) {
1227             JSGlobalLexicalEnvironment* globalLexicalEnvironment = jsCast&lt;JSGlobalLexicalEnvironment*&gt;(resolvedScope);
1228             ConcurrentJSLocker locker(codeBlock-&gt;m_lock);
1229             metadata.m_resolveType = needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar;
1230             metadata.m_globalLexicalEnvironment.set(vm, codeBlock, globalLexicalEnvironment);
1231         }
1232         break;
1233     }
1234     default:
1235         break;
1236     }
1237 
1238     RETURN(resolvedScope);
1239 }
1240 
1241 SLOW_PATH_DECL(slow_path_create_rest)
1242 {
1243     BEGIN();
1244     auto bytecode = pc-&gt;as&lt;OpCreateRest&gt;();
1245     unsigned arraySize = GET_C(bytecode.m_arraySize).jsValue().asUInt32();

1246     Structure* structure = globalObject-&gt;restParameterStructure();
1247     unsigned numParamsToSkip = bytecode.m_numParametersToSkip;
<span class="line-modified">1248     JSValue* argumentsToCopyRegion = callFrame-&gt;addressOfArgumentsStart() + numParamsToSkip;</span>
<span class="line-modified">1249     RETURN(constructArray(globalObject, structure, argumentsToCopyRegion, arraySize));</span>
1250 }
1251 
1252 SLOW_PATH_DECL(slow_path_get_by_id_with_this)
1253 {
1254     BEGIN();
1255     auto bytecode = pc-&gt;as&lt;OpGetByIdWithThis&gt;();
<span class="line-modified">1256     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);</span>
1257     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1258     JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
1259     PropertySlot slot(thisVal, PropertySlot::PropertySlot::InternalMethodType::Get);
<span class="line-modified">1260     JSValue result = baseValue.get(globalObject, ident, slot);</span>
1261     RETURN_PROFILED(result);
1262 }
1263 
1264 SLOW_PATH_DECL(slow_path_get_by_val_with_this)
1265 {
1266     BEGIN();
1267 
1268     auto bytecode = pc-&gt;as&lt;OpGetByValWithThis&gt;();
1269     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1270     JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
1271     JSValue subscript = GET_C(bytecode.m_property).jsValue();
1272 
1273     if (LIKELY(baseValue.isCell() &amp;&amp; subscript.isString())) {
1274         Structure&amp; structure = *baseValue.asCell()-&gt;structure(vm);
1275         if (JSCell::canUseFastGetOwnProperty(structure)) {
<span class="line-modified">1276             RefPtr&lt;AtomStringImpl&gt; existingAtomString = asString(subscript)-&gt;toExistingAtomString(globalObject);</span>
1277             CHECK_EXCEPTION();
1278             if (existingAtomString) {
1279                 if (JSValue result = baseValue.asCell()-&gt;fastGetOwnProperty(vm, structure, existingAtomString.get()))
1280                     RETURN_PROFILED(result);
1281             }
1282         }
1283     }
1284 
1285     PropertySlot slot(thisValue, PropertySlot::PropertySlot::InternalMethodType::Get);
1286     if (subscript.isUInt32()) {
1287         uint32_t i = subscript.asUInt32();
1288         if (isJSString(baseValue) &amp;&amp; asString(baseValue)-&gt;canGetIndex(i))
<span class="line-modified">1289             RETURN_PROFILED(asString(baseValue)-&gt;getIndex(globalObject, i));</span>
1290 
<span class="line-modified">1291         RETURN_PROFILED(baseValue.get(globalObject, i, slot));</span>
1292     }
1293 
<span class="line-modified">1294     baseValue.requireObjectCoercible(globalObject);</span>
1295     CHECK_EXCEPTION();
<span class="line-modified">1296     auto property = subscript.toPropertyKey(globalObject);</span>
1297     CHECK_EXCEPTION();
<span class="line-modified">1298     RETURN_PROFILED(baseValue.get(globalObject, property, slot));</span>
1299 }
1300 
1301 SLOW_PATH_DECL(slow_path_put_by_id_with_this)
1302 {
1303     BEGIN();
1304     auto bytecode = pc-&gt;as&lt;OpPutByIdWithThis&gt;();

1305     const Identifier&amp; ident = codeBlock-&gt;identifier(bytecode.m_property);
1306     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1307     JSValue thisVal = GET_C(bytecode.m_thisValue).jsValue();
1308     JSValue putValue = GET_C(bytecode.m_value).jsValue();
1309     PutPropertySlot slot(thisVal, codeBlock-&gt;isStrictMode(), codeBlock-&gt;putByIdContext());
<span class="line-modified">1310     baseValue.putInline(globalObject, ident, putValue, slot);</span>
1311     END();
1312 }
1313 
1314 SLOW_PATH_DECL(slow_path_put_by_val_with_this)
1315 {
1316     BEGIN();
1317     auto bytecode = pc-&gt;as&lt;OpPutByValWithThis&gt;();
1318     JSValue baseValue = GET_C(bytecode.m_base).jsValue();
1319     JSValue thisValue = GET_C(bytecode.m_thisValue).jsValue();
1320     JSValue subscript = GET_C(bytecode.m_property).jsValue();
1321     JSValue value = GET_C(bytecode.m_value).jsValue();
1322 
<span class="line-modified">1323     auto property = subscript.toPropertyKey(globalObject);</span>
1324     CHECK_EXCEPTION();
<span class="line-modified">1325     PutPropertySlot slot(thisValue, codeBlock-&gt;isStrictMode());</span>
<span class="line-modified">1326     baseValue.put(globalObject, property, value, slot);</span>
1327     END();
1328 }
1329 
1330 SLOW_PATH_DECL(slow_path_define_data_property)
1331 {
1332     BEGIN();
1333     auto bytecode = pc-&gt;as&lt;OpDefineDataProperty&gt;();
1334     JSObject* base = asObject(GET_C(bytecode.m_base).jsValue());
1335     JSValue property = GET_C(bytecode.m_property).jsValue();
1336     JSValue value = GET_C(bytecode.m_value).jsValue();
1337     JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
1338     ASSERT(attributes.isInt32());
1339 
<span class="line-modified">1340     auto propertyName = property.toPropertyKey(globalObject);</span>
1341     CHECK_EXCEPTION();
1342     PropertyDescriptor descriptor = toPropertyDescriptor(value, jsUndefined(), jsUndefined(), DefinePropertyAttributes(attributes.asInt32()));
1343     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
<span class="line-modified">1344     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, globalObject, propertyName, descriptor, true);</span>
1345     END();
1346 }
1347 
1348 SLOW_PATH_DECL(slow_path_define_accessor_property)
1349 {
1350     BEGIN();
1351     auto bytecode = pc-&gt;as&lt;OpDefineAccessorProperty&gt;();
1352     JSObject* base = asObject(GET_C(bytecode.m_base).jsValue());
1353     JSValue property = GET_C(bytecode.m_property).jsValue();
1354     JSValue getter = GET_C(bytecode.m_getter).jsValue();
1355     JSValue setter = GET_C(bytecode.m_setter).jsValue();
1356     JSValue attributes = GET_C(bytecode.m_attributes).jsValue();
1357     ASSERT(attributes.isInt32());
1358 
<span class="line-modified">1359     auto propertyName = property.toPropertyKey(globalObject);</span>
1360     CHECK_EXCEPTION();
1361     PropertyDescriptor descriptor = toPropertyDescriptor(jsUndefined(), getter, setter, DefinePropertyAttributes(attributes.asInt32()));
1362     ASSERT((descriptor.attributes() &amp; PropertyAttribute::Accessor) || (!descriptor.isAccessorDescriptor()));
<span class="line-modified">1363     base-&gt;methodTable(vm)-&gt;defineOwnProperty(base, globalObject, propertyName, descriptor, true);</span>
1364     END();
1365 }
1366 
1367 SLOW_PATH_DECL(slow_path_throw_static_error)
1368 {
1369     BEGIN();
1370     auto bytecode = pc-&gt;as&lt;OpThrowStaticError&gt;();
1371     JSValue errorMessageValue = GET_C(bytecode.m_message).jsValue();
1372     RELEASE_ASSERT(errorMessageValue.isString());
<span class="line-modified">1373     String errorMessage = asString(errorMessageValue)-&gt;value(globalObject);</span>
1374     ErrorType errorType = bytecode.m_errorType;
<span class="line-modified">1375     THROW(createError(globalObject, errorType, errorMessage));</span>
1376 }
1377 
1378 SLOW_PATH_DECL(slow_path_new_array_with_spread)
1379 {
1380     BEGIN();
1381     auto bytecode = pc-&gt;as&lt;OpNewArrayWithSpread&gt;();
1382     int numItems = bytecode.m_argc;
1383     ASSERT(numItems &gt;= 0);
<span class="line-modified">1384     const BitVector&amp; bitVector = codeBlock-&gt;unlinkedCodeBlock()-&gt;bitVector(bytecode.m_bitVector);</span>
1385 
1386     JSValue* values = bitwise_cast&lt;JSValue*&gt;(&amp;GET(bytecode.m_argv));
1387 
<span class="line-added">1388     if (numItems == 1 &amp;&amp; bitVector.get(0)) {</span>
<span class="line-added">1389         Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(CopyOnWriteArrayWithContiguous);</span>
<span class="line-added">1390         if (isCopyOnWrite(structure-&gt;indexingMode())) {</span>
<span class="line-added">1391             JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, jsCast&lt;JSImmutableButterfly*&gt;(values[0]));</span>
<span class="line-added">1392             RETURN(result);</span>
<span class="line-added">1393         }</span>
<span class="line-added">1394     }</span>
<span class="line-added">1395 </span>
1396     Checked&lt;unsigned, RecordOverflow&gt; checkedArraySize = 0;
1397     for (int i = 0; i &lt; numItems; i++) {
1398         if (bitVector.get(i)) {
1399             JSValue value = values[-i];
<span class="line-modified">1400             JSImmutableButterfly* array = jsCast&lt;JSImmutableButterfly*&gt;(value);</span>
<span class="line-modified">1401             checkedArraySize += array-&gt;publicLength();</span>
1402         } else
1403             checkedArraySize += 1;
1404     }
1405     if (UNLIKELY(checkedArraySize.hasOverflowed()))
<span class="line-modified">1406         THROW(createOutOfMemoryError(globalObject));</span>
1407 
1408     unsigned arraySize = checkedArraySize.unsafeGet();
1409     if (UNLIKELY(arraySize &gt;= MIN_ARRAY_STORAGE_CONSTRUCTION_LENGTH))
<span class="line-modified">1410         THROW(createOutOfMemoryError(globalObject));</span>
1411 

1412     Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous);
1413 
1414     JSArray* result = JSArray::tryCreate(vm, structure, arraySize);
1415     if (UNLIKELY(!result))
<span class="line-modified">1416         THROW(createOutOfMemoryError(globalObject));</span>
1417     CHECK_EXCEPTION();
1418 
1419     unsigned index = 0;
1420     for (int i = 0; i &lt; numItems; i++) {
1421         JSValue value = values[-i];
1422         if (bitVector.get(i)) {
1423             // We are spreading.
<span class="line-modified">1424             JSImmutableButterfly* array = jsCast&lt;JSImmutableButterfly*&gt;(value);</span>
<span class="line-modified">1425             for (unsigned i = 0; i &lt; array-&gt;publicLength(); i++) {</span>
1426                 RELEASE_ASSERT(array-&gt;get(i));
<span class="line-modified">1427                 result-&gt;putDirectIndex(globalObject, index, array-&gt;get(i));</span>
1428                 CHECK_EXCEPTION();
1429                 ++index;
1430             }
1431         } else {
1432             // We are not spreading.
<span class="line-modified">1433             result-&gt;putDirectIndex(globalObject, index, value);</span>
1434             CHECK_EXCEPTION();
1435             ++index;
1436         }
1437     }
1438 
1439     RETURN(result);
1440 }
1441 
1442 SLOW_PATH_DECL(slow_path_new_array_buffer)
1443 {
1444     BEGIN();
1445     auto bytecode = pc-&gt;as&lt;OpNewArrayBuffer&gt;();
<span class="line-modified">1446     ASSERT(bytecode.m_immutableButterfly.isConstant());</span>
1447     JSImmutableButterfly* immutableButterfly = bitwise_cast&lt;JSImmutableButterfly*&gt;(GET_C(bytecode.m_immutableButterfly).jsValue().asCell());
<span class="line-modified">1448     auto&amp; profile = bytecode.metadata(codeBlock).m_arrayAllocationProfile;</span>
1449 
1450     IndexingType indexingMode = profile.selectIndexingType();
<span class="line-modified">1451     Structure* structure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(indexingMode);</span>
1452     ASSERT(isCopyOnWrite(indexingMode));
1453     ASSERT(!structure-&gt;outOfLineCapacity());
1454 
1455     if (UNLIKELY(immutableButterfly-&gt;indexingMode() != indexingMode)) {
1456         auto* newButterfly = JSImmutableButterfly::create(vm, indexingMode, immutableButterfly-&gt;length());
1457         for (unsigned i = 0; i &lt; immutableButterfly-&gt;length(); ++i)
1458             newButterfly-&gt;setIndex(vm, i, immutableButterfly-&gt;get(i));
1459         immutableButterfly = newButterfly;

1460 
1461         // FIXME: This is kinda gross and only works because we can&#39;t inline new_array_bufffer in the baseline.
1462         // We also cannot allocate a new butterfly from compilation threads since it&#39;s invalid to allocate cells from
1463         // a compilation thread.
1464         WTF::storeStoreFence();
<span class="line-modified">1465         codeBlock-&gt;constantRegister(bytecode.m_immutableButterfly).set(vm, codeBlock, immutableButterfly);</span>
1466         WTF::storeStoreFence();
1467     }
1468 
1469     JSArray* result = CommonSlowPaths::allocateNewArrayBuffer(vm, structure, immutableButterfly);
<span class="line-modified">1470     ASSERT(isCopyOnWrite(result-&gt;indexingMode()) || globalObject-&gt;isHavingABadTime());</span>
1471     ArrayAllocationProfile::updateLastAllocationFor(&amp;profile, result);
1472     RETURN(result);
1473 }
1474 
1475 SLOW_PATH_DECL(slow_path_spread)
1476 {
1477     BEGIN();
1478 
1479     auto bytecode = pc-&gt;as&lt;OpSpread&gt;();
1480     JSValue iterable = GET_C(bytecode.m_argument).jsValue();
1481 
1482     if (iterable.isCell() &amp;&amp; isJSArray(iterable.asCell())) {
1483         JSArray* array = jsCast&lt;JSArray*&gt;(iterable);
1484         if (array-&gt;isIteratorProtocolFastAndNonObservable()) {
<span class="line-modified">1485             // JSImmutableButterfly::createFromArray does not consult the prototype chain,</span>
1486             // so we must be sure that not consulting the prototype chain would
1487             // produce the same value during iteration.
<span class="line-modified">1488             RETURN(JSImmutableButterfly::createFromArray(globalObject, vm, array));</span>
1489         }
1490     }
1491 


1492     JSArray* array;
1493     {
1494         JSFunction* iterationFunction = globalObject-&gt;iteratorProtocolFunction();
1495         CallData callData;
1496         CallType callType = JSC::getCallData(vm, iterationFunction, callData);
1497         ASSERT(callType != CallType::None);
1498 
1499         MarkedArgumentBuffer arguments;
1500         arguments.append(iterable);
1501         ASSERT(!arguments.hasOverflowed());
<span class="line-modified">1502         JSValue arrayResult = call(globalObject, iterationFunction, callType, callData, jsNull(), arguments);</span>
1503         CHECK_EXCEPTION();
1504         array = jsCast&lt;JSArray*&gt;(arrayResult);
1505     }
1506 
<span class="line-modified">1507     RETURN(JSImmutableButterfly::createFromArray(globalObject, vm, array));</span>
1508 }
1509 
1510 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="CommonIdentifiers.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CommonSlowPaths.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
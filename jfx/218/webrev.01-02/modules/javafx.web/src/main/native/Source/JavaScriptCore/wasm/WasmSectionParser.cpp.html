<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSectionParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
  3  * Copyright (C) 2018 Yusuke Suzuki &lt;yusukesuzuki@slowstart.org&gt;.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;WasmSectionParser.h&quot;
 29 
 30 #if ENABLE(WEBASSEMBLY)
 31 
 32 #include &quot;IdentifierInlines.h&quot;
 33 #include &quot;JSCJSValueInlines.h&quot;
 34 #include &quot;WasmMemoryInformation.h&quot;
 35 #include &quot;WasmNameSectionParser.h&quot;
 36 #include &quot;WasmOps.h&quot;
 37 #include &quot;WasmSections.h&quot;
 38 #include &quot;WasmSignatureInlines.h&quot;
 39 #include &lt;wtf/Optional.h&gt;
 40 
 41 namespace JSC { namespace Wasm {
 42 
 43 auto SectionParser::parseType() -&gt; PartialResult
 44 {
 45     uint32_t count;
 46 
 47     WASM_PARSER_FAIL_IF(!parseVarUInt32(count), &quot;can&#39;t get Type section&#39;s count&quot;);
 48     WASM_PARSER_FAIL_IF(count &gt; maxTypes, &quot;Type section&#39;s count is too big &quot;, count, &quot; maximum &quot;, maxTypes);
 49     WASM_PARSER_FAIL_IF(!m_info-&gt;usedSignatures.tryReserveCapacity(count), &quot;can&#39;t allocate enough memory for Type section&#39;s &quot;, count, &quot; entries&quot;);
 50 
 51     for (uint32_t i = 0; i &lt; count; ++i) {
 52         int8_t type;
 53         uint32_t argumentCount;
 54         Vector&lt;Type&gt; argumentTypes;
 55 
 56         WASM_PARSER_FAIL_IF(!parseInt7(type), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s type&quot;);
 57         WASM_PARSER_FAIL_IF(type != Func, i, &quot;th Type is non-Func &quot;, type);
 58         WASM_PARSER_FAIL_IF(!parseVarUInt32(argumentCount), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s argument count&quot;);
 59         WASM_PARSER_FAIL_IF(argumentCount &gt; maxFunctionParams, i, &quot;th argument count is too big &quot;, argumentCount, &quot; maximum &quot;, maxFunctionParams);
 60         Vector&lt;Type&gt; arguments;
 61         WASM_PARSER_FAIL_IF(!arguments.tryReserveCapacity(argumentCount), &quot;can&#39;t allocate enough memory for Type section&#39;s &quot;, i, &quot;th signature&quot;);
 62 
 63         for (unsigned i = 0; i &lt; argumentCount; ++i) {
 64             Type argumentType;
 65             WASM_PARSER_FAIL_IF(!parseValueType(argumentType), &quot;can&#39;t get &quot;, i, &quot;th argument Type&quot;);
 66             arguments.append(argumentType);
 67         }
 68 
 69         uint32_t returnCount;
 70         WASM_PARSER_FAIL_IF(!parseVarUInt32(returnCount), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s return count&quot;);
 71         WASM_PARSER_FAIL_IF(returnCount &gt; 1 &amp;&amp; !Options::useWebAssemblyMultiValues(), &quot;Signatures cannot have more than one result type yet.&quot;);
 72 
 73         Vector&lt;Type, 1&gt; returnTypes;
 74         WASM_PARSER_FAIL_IF(!returnTypes.tryReserveCapacity(argumentCount), &quot;can&#39;t allocate enough memory for Type section&#39;s &quot;, i, &quot;th signature&quot;);
 75         for (unsigned i = 0; i &lt; returnCount; ++i) {
 76             Type value;
 77             WASM_PARSER_FAIL_IF(!parseValueType(value), &quot;can&#39;t get &quot;, i, &quot;th Type&#39;s return value&quot;);
 78             returnTypes.append(value);
 79         }
 80 
 81         RefPtr&lt;Signature&gt; signature = SignatureInformation::signatureFor(returnTypes, arguments);
 82         WASM_PARSER_FAIL_IF(!signature, &quot;can&#39;t allocate enough memory for Type section&#39;s &quot;, i, &quot;th signature&quot;);
 83 
 84         m_info-&gt;usedSignatures.uncheckedAppend(signature.releaseNonNull());
 85     }
 86     return { };
 87 }
 88 
 89 auto SectionParser::parseImport() -&gt; PartialResult
 90 {
 91     uint32_t importCount;
 92     WASM_PARSER_FAIL_IF(!parseVarUInt32(importCount), &quot;can&#39;t get Import section&#39;s count&quot;);
 93     WASM_PARSER_FAIL_IF(importCount &gt; maxImports, &quot;Import section&#39;s count is too big &quot;, importCount, &quot; maximum &quot;, maxImports);
 94     WASM_PARSER_FAIL_IF(!m_info-&gt;globals.tryReserveCapacity(importCount), &quot;can&#39;t allocate enough memory for &quot;, importCount, &quot; globals&quot;); // FIXME this over-allocates when we fix the FIXMEs below.
 95     WASM_PARSER_FAIL_IF(!m_info-&gt;imports.tryReserveCapacity(importCount), &quot;can&#39;t allocate enough memory for &quot;, importCount, &quot; imports&quot;); // FIXME this over-allocates when we fix the FIXMEs below.
 96     WASM_PARSER_FAIL_IF(!m_info-&gt;importFunctionSignatureIndices.tryReserveCapacity(importCount), &quot;can&#39;t allocate enough memory for &quot;, importCount, &quot; import function signatures&quot;); // FIXME this over-allocates when we fix the FIXMEs below.
 97 
 98     for (uint32_t importNumber = 0; importNumber &lt; importCount; ++importNumber) {
 99         uint32_t moduleLen;
100         uint32_t fieldLen;
101         Name moduleString;
102         Name fieldString;
103         ExternalKind kind;
104         unsigned kindIndex { 0 };
105 
106         WASM_PARSER_FAIL_IF(!parseVarUInt32(moduleLen), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s module name length&quot;);
107         WASM_PARSER_FAIL_IF(!consumeUTF8String(moduleString, moduleLen), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s module name of length &quot;, moduleLen);
108 
109         WASM_PARSER_FAIL_IF(!parseVarUInt32(fieldLen), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s field name length in module &#39;&quot;, moduleString, &quot;&#39;&quot;);
110         WASM_PARSER_FAIL_IF(!consumeUTF8String(fieldString, fieldLen), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s field name of length &quot;, moduleLen, &quot; in module &#39;&quot;, moduleString, &quot;&#39;&quot;);
111 
112         WASM_PARSER_FAIL_IF(!parseExternalKind(kind), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s kind in module &#39;&quot;, moduleString, &quot;&#39; field &#39;&quot;, fieldString, &quot;&#39;&quot;);
113         switch (kind) {
114         case ExternalKind::Function: {
115             uint32_t functionSignatureIndex;
116             WASM_PARSER_FAIL_IF(!parseVarUInt32(functionSignatureIndex), &quot;can&#39;t get &quot;, importNumber, &quot;th Import&#39;s function signature in module &#39;&quot;, moduleString, &quot;&#39; field &#39;&quot;, fieldString, &quot;&#39;&quot;);
117             WASM_PARSER_FAIL_IF(functionSignatureIndex &gt;= m_info-&gt;usedSignatures.size(), &quot;invalid function signature for &quot;, importNumber, &quot;th Import, &quot;, functionSignatureIndex, &quot; is out of range of &quot;, m_info-&gt;usedSignatures.size(), &quot; in module &#39;&quot;, moduleString, &quot;&#39; field &#39;&quot;, fieldString, &quot;&#39;&quot;);
118             kindIndex = m_info-&gt;importFunctionSignatureIndices.size();
119             SignatureIndex signatureIndex = SignatureInformation::get(m_info-&gt;usedSignatures[functionSignatureIndex]);
120             m_info-&gt;importFunctionSignatureIndices.uncheckedAppend(signatureIndex);
121             break;
122         }
123         case ExternalKind::Table: {
124             bool isImport = true;
125             kindIndex = m_info-&gt;tables.size();
126             PartialResult result = parseTableHelper(isImport);
127             if (UNLIKELY(!result))
128                 return makeUnexpected(WTFMove(result.error()));
129             break;
130         }
131         case ExternalKind::Memory: {
132             bool isImport = true;
133             PartialResult result = parseMemoryHelper(isImport);
134             if (UNLIKELY(!result))
135                 return makeUnexpected(WTFMove(result.error()));
136             break;
137         }
138         case ExternalKind::Global: {
139             GlobalInformation global;
140             WASM_FAIL_IF_HELPER_FAILS(parseGlobalType(global));
141             // Only mutable globals need floating bindings.
142             if (global.mutability == GlobalInformation::Mutability::Mutable)
143                 global.bindingMode = GlobalInformation::BindingMode::Portable;
144             kindIndex = m_info-&gt;globals.size();
145             m_info-&gt;globals.uncheckedAppend(WTFMove(global));
146             break;
147         }
148         }
149 
150         m_info-&gt;imports.uncheckedAppend({ WTFMove(moduleString), WTFMove(fieldString), kind, kindIndex });
151     }
152 
153     m_info-&gt;firstInternalGlobal = m_info-&gt;globals.size();
154     return { };
155 }
156 
157 auto SectionParser::parseFunction() -&gt; PartialResult
158 {
159     uint32_t count;
160     WASM_PARSER_FAIL_IF(!parseVarUInt32(count), &quot;can&#39;t get Function section&#39;s count&quot;);
161     WASM_PARSER_FAIL_IF(count &gt; maxFunctions, &quot;Function section&#39;s count is too big &quot;, count, &quot; maximum &quot;, maxFunctions);
162     WASM_PARSER_FAIL_IF(!m_info-&gt;internalFunctionSignatureIndices.tryReserveCapacity(count), &quot;can&#39;t allocate enough memory for &quot;, count, &quot; Function signatures&quot;);
163     WASM_PARSER_FAIL_IF(!m_info-&gt;functions.tryReserveCapacity(count), &quot;can&#39;t allocate enough memory for &quot;, count, &quot;Function locations&quot;);
164 
165     for (uint32_t i = 0; i &lt; count; ++i) {
166         uint32_t typeNumber;
167         WASM_PARSER_FAIL_IF(!parseVarUInt32(typeNumber), &quot;can&#39;t get &quot;, i, &quot;th Function&#39;s type number&quot;);
168         WASM_PARSER_FAIL_IF(typeNumber &gt;= m_info-&gt;usedSignatures.size(), i, &quot;th Function type number is invalid &quot;, typeNumber);
169 
170         SignatureIndex signatureIndex = SignatureInformation::get(m_info-&gt;usedSignatures[typeNumber]);
171         // The Code section fixes up start and end.
172         size_t start = 0;
173         size_t end = 0;
174         m_info-&gt;internalFunctionSignatureIndices.uncheckedAppend(signatureIndex);
175         m_info-&gt;functions.uncheckedAppend({ start, end, Vector&lt;uint8_t&gt;() });
176     }
177 
178     return { };
179 }
180 
181 auto SectionParser::parseResizableLimits(uint32_t&amp; initial, Optional&lt;uint32_t&gt;&amp; maximum) -&gt; PartialResult
182 {
183     ASSERT(!maximum);
184 
185     uint8_t flags;
186     WASM_PARSER_FAIL_IF(!parseVarUInt1(flags), &quot;can&#39;t parse resizable limits flags&quot;);
187     WASM_PARSER_FAIL_IF(!parseVarUInt32(initial), &quot;can&#39;t parse resizable limits initial page count&quot;);
188 
189     if (flags) {
190         uint32_t maximumInt;
191         WASM_PARSER_FAIL_IF(!parseVarUInt32(maximumInt), &quot;can&#39;t parse resizable limits maximum page count&quot;);
192         WASM_PARSER_FAIL_IF(initial &gt; maximumInt, &quot;resizable limits has an initial page count of &quot;, initial, &quot; which is greater than its maximum &quot;, maximumInt);
193         maximum = maximumInt;
194     }
195 
196     return { };
197 }
198 
199 auto SectionParser::parseTableHelper(bool isImport) -&gt; PartialResult
200 {
201     WASM_PARSER_FAIL_IF(m_info-&gt;tableCount() &gt;= maxTables, &quot;Table count of &quot;, m_info-&gt;tableCount(), &quot; is too big, maximum &quot;, maxTables);
202 
203     int8_t type;
204     WASM_PARSER_FAIL_IF(!parseInt7(type), &quot;can&#39;t parse Table type&quot;);
205     WASM_PARSER_FAIL_IF(type != Wasm::Funcref &amp;&amp; type != Wasm::Anyref, &quot;Table type should be funcref or anyref, got &quot;, type);
206 
207     uint32_t initial;
208     Optional&lt;uint32_t&gt; maximum;
209     PartialResult limits = parseResizableLimits(initial, maximum);
210     if (UNLIKELY(!limits))
211         return makeUnexpected(WTFMove(limits.error()));
212     WASM_PARSER_FAIL_IF(initial &gt; maxTableEntries, &quot;Table&#39;s initial page count of &quot;, initial, &quot; is too big, maximum &quot;, maxTableEntries);
213 
214     ASSERT(!maximum || *maximum &gt;= initial);
215 
216     TableElementType tableType = type == Wasm::Funcref ? TableElementType::Funcref : TableElementType::Anyref;
217     m_info-&gt;tables.append(TableInformation(initial, maximum, isImport, tableType));
218 
219     return { };
220 }
221 
222 auto SectionParser::parseTable() -&gt; PartialResult
223 {
224     uint32_t count;
225     WASM_PARSER_FAIL_IF(!parseVarUInt32(count), &quot;can&#39;t get Table&#39;s count&quot;);
226 
227     for (unsigned i = 0; i &lt; count; ++i) {
228         bool isImport = false;
229         PartialResult result = parseTableHelper(isImport);
230         if (UNLIKELY(!result))
231             return makeUnexpected(WTFMove(result.error()));
232     }
233 
234     return { };
235 }
236 
237 auto SectionParser::parseMemoryHelper(bool isImport) -&gt; PartialResult
238 {
239     WASM_PARSER_FAIL_IF(m_info-&gt;memoryCount(), &quot;there can at most be one Memory section for now&quot;);
240 
241     PageCount initialPageCount;
242     PageCount maximumPageCount;
243     {
244         uint32_t initial;
245         Optional&lt;uint32_t&gt; maximum;
246         PartialResult limits = parseResizableLimits(initial, maximum);
247         if (UNLIKELY(!limits))
248             return makeUnexpected(WTFMove(limits.error()));
249         ASSERT(!maximum || *maximum &gt;= initial);
250         WASM_PARSER_FAIL_IF(!PageCount::isValid(initial), &quot;Memory&#39;s initial page count of &quot;, initial, &quot; is invalid&quot;);
251 
252         initialPageCount = PageCount(initial);
253 
254         if (maximum) {
255             WASM_PARSER_FAIL_IF(!PageCount::isValid(*maximum), &quot;Memory&#39;s maximum page count of &quot;, *maximum, &quot; is invalid&quot;);
256             maximumPageCount = PageCount(*maximum);
257         }
258     }
259     ASSERT(initialPageCount);
260     ASSERT(!maximumPageCount || maximumPageCount &gt;= initialPageCount);
261 
262     m_info-&gt;memory = MemoryInformation(initialPageCount, maximumPageCount, isImport);
263     return { };
264 }
265 
266 auto SectionParser::parseMemory() -&gt; PartialResult
267 {
268     uint8_t count;
269     WASM_PARSER_FAIL_IF(!parseVarUInt1(count), &quot;can&#39;t parse Memory section&#39;s count&quot;);
270 
271     if (!count)
272         return { };
273 
274     WASM_PARSER_FAIL_IF(count != 1, &quot;Memory section has more than one memory, WebAssembly currently only allows zero or one&quot;);
275 
276     bool isImport = false;
277     return parseMemoryHelper(isImport);
278 }
279 
280 auto SectionParser::parseGlobal() -&gt; PartialResult
281 {
282     uint32_t globalCount;
283     WASM_PARSER_FAIL_IF(!parseVarUInt32(globalCount), &quot;can&#39;t get Global section&#39;s count&quot;);
284     WASM_PARSER_FAIL_IF(globalCount &gt; maxGlobals, &quot;Global section&#39;s count is too big &quot;, globalCount, &quot; maximum &quot;, maxGlobals);
285     size_t totalBytes = globalCount + m_info-&gt;firstInternalGlobal;
286     WASM_PARSER_FAIL_IF((static_cast&lt;uint32_t&gt;(totalBytes) &lt; globalCount) || !m_info-&gt;globals.tryReserveCapacity(totalBytes), &quot;can&#39;t allocate memory for &quot;, totalBytes, &quot; globals&quot;);
287 
288     for (uint32_t globalIndex = 0; globalIndex &lt; globalCount; ++globalIndex) {
289         GlobalInformation global;
290         uint8_t initOpcode;
291 
292         WASM_FAIL_IF_HELPER_FAILS(parseGlobalType(global));
293         Type typeForInitOpcode;
294         WASM_FAIL_IF_HELPER_FAILS(parseInitExpr(initOpcode, global.initialBitsOrImportNumber, typeForInitOpcode));
295         if (initOpcode == GetGlobal)
296             global.initializationType = GlobalInformation::FromGlobalImport;
297         else if (initOpcode == RefFunc)
298             global.initializationType = GlobalInformation::FromRefFunc;
299         else
300             global.initializationType = GlobalInformation::FromExpression;
301         WASM_PARSER_FAIL_IF(!isSubtype(typeForInitOpcode, global.type), &quot;Global init_expr opcode of type &quot;, typeForInitOpcode, &quot; doesn&#39;t match global&#39;s type &quot;, global.type);
302 
303         m_info-&gt;globals.uncheckedAppend(WTFMove(global));
304     }
305 
306     return { };
307 }
308 
309 auto SectionParser::parseExport() -&gt; PartialResult
310 {
311     uint32_t exportCount;
312     WASM_PARSER_FAIL_IF(!parseVarUInt32(exportCount), &quot;can&#39;t get Export section&#39;s count&quot;);
313     WASM_PARSER_FAIL_IF(exportCount &gt; maxExports, &quot;Export section&#39;s count is too big &quot;, exportCount, &quot; maximum &quot;, maxExports);
314     WASM_PARSER_FAIL_IF(!m_info-&gt;exports.tryReserveCapacity(exportCount), &quot;can&#39;t allocate enough memory for &quot;, exportCount, &quot; exports&quot;);
315 
316     HashSet&lt;String&gt; exportNames;
317     for (uint32_t exportNumber = 0; exportNumber &lt; exportCount; ++exportNumber) {
318         uint32_t fieldLen;
319         Name fieldString;
320         ExternalKind kind;
321         unsigned kindIndex;
322 
323         WASM_PARSER_FAIL_IF(!parseVarUInt32(fieldLen), &quot;can&#39;t get &quot;, exportNumber, &quot;th Export&#39;s field name length&quot;);
324         WASM_PARSER_FAIL_IF(!consumeUTF8String(fieldString, fieldLen), &quot;can&#39;t get &quot;, exportNumber, &quot;th Export&#39;s field name of length &quot;, fieldLen);
325         String fieldName = String::fromUTF8(fieldString);
326         WASM_PARSER_FAIL_IF(exportNames.contains(fieldName), &quot;duplicate export: &#39;&quot;, fieldString, &quot;&#39;&quot;);
327         exportNames.add(fieldName);
328 
329         WASM_PARSER_FAIL_IF(!parseExternalKind(kind), &quot;can&#39;t get &quot;, exportNumber, &quot;th Export&#39;s kind, named &#39;&quot;, fieldString, &quot;&#39;&quot;);
330         WASM_PARSER_FAIL_IF(!parseVarUInt32(kindIndex), &quot;can&#39;t get &quot;, exportNumber, &quot;th Export&#39;s kind index, named &#39;&quot;, fieldString, &quot;&#39;&quot;);
331         switch (kind) {
332         case ExternalKind::Function: {
333             WASM_PARSER_FAIL_IF(kindIndex &gt;= m_info-&gt;functionIndexSpaceSize(), exportNumber, &quot;th Export has invalid function number &quot;, kindIndex, &quot; it exceeds the function index space &quot;, m_info-&gt;functionIndexSpaceSize(), &quot;, named &#39;&quot;, fieldString, &quot;&#39;&quot;);
334             break;
335         }
336         case ExternalKind::Table: {
337             WASM_PARSER_FAIL_IF(kindIndex &gt;= m_info-&gt;tableCount(), &quot;can&#39;t export Table &quot;, kindIndex, &quot; there are &quot;, m_info-&gt;tableCount(), &quot; Tables&quot;);
338             break;
339         }
340         case ExternalKind::Memory: {
341             WASM_PARSER_FAIL_IF(!m_info-&gt;memory, &quot;can&#39;t export a non-existent Memory&quot;);
342             WASM_PARSER_FAIL_IF(kindIndex, &quot;can&#39;t export Memory &quot;, kindIndex, &quot; only one Table is currently supported&quot;);
343             break;
344         }
345         case ExternalKind::Global: {
346             WASM_PARSER_FAIL_IF(kindIndex &gt;= m_info-&gt;globals.size(), exportNumber, &quot;th Export has invalid global number &quot;, kindIndex, &quot; it exceeds the globals count &quot;, m_info-&gt;globals.size(), &quot;, named &#39;&quot;, fieldString, &quot;&#39;&quot;);
347             // Only mutable globals need floating bindings.
348             GlobalInformation&amp; global = m_info-&gt;globals[kindIndex];
349             if (global.mutability == GlobalInformation::Mutability::Mutable)
350                 global.bindingMode = GlobalInformation::BindingMode::Portable;
351             break;
352         }
353         }
354 
355         m_info-&gt;exports.uncheckedAppend({ WTFMove(fieldString), kind, kindIndex });
356     }
357 
358     return { };
359 }
360 
361 auto SectionParser::parseStart() -&gt; PartialResult
362 {
363     uint32_t startFunctionIndex;
364     WASM_PARSER_FAIL_IF(!parseVarUInt32(startFunctionIndex), &quot;can&#39;t get Start index&quot;);
365     WASM_PARSER_FAIL_IF(startFunctionIndex &gt;= m_info-&gt;functionIndexSpaceSize(), &quot;Start index &quot;, startFunctionIndex, &quot; exceeds function index space &quot;, m_info-&gt;functionIndexSpaceSize());
366     SignatureIndex signatureIndex = m_info-&gt;signatureIndexFromFunctionIndexSpace(startFunctionIndex);
367     const Signature&amp; signature = SignatureInformation::get(signatureIndex);
368     WASM_PARSER_FAIL_IF(signature.argumentCount(), &quot;Start function can&#39;t have arguments&quot;);
369     WASM_PARSER_FAIL_IF(!signature.returnsVoid(), &quot;Start function can&#39;t return a value&quot;);
370     m_info-&gt;startFunctionIndexSpace = startFunctionIndex;
371     return { };
372 }
373 
374 auto SectionParser::parseElement() -&gt; PartialResult
375 {
376     uint32_t elementCount;
377     WASM_PARSER_FAIL_IF(!parseVarUInt32(elementCount), &quot;can&#39;t get Element section&#39;s count&quot;);
378     WASM_PARSER_FAIL_IF(elementCount &gt; maxTableEntries, &quot;Element section&#39;s count is too big &quot;, elementCount, &quot; maximum &quot;, maxTableEntries);
379     WASM_PARSER_FAIL_IF(!m_info-&gt;elements.tryReserveCapacity(elementCount), &quot;can&#39;t allocate memory for &quot;, elementCount, &quot; Elements&quot;);
380     for (unsigned elementNum = 0; elementNum &lt; elementCount; ++elementNum) {
381         uint32_t tableIndex;
382         uint64_t initExprBits;
383         uint8_t initOpcode;
384         uint32_t indexCount;
385 
386         uint8_t magic;
387         WASM_PARSER_FAIL_IF(!parseUInt8(magic) || (magic &amp;&amp; magic != 2), &quot;can&#39;t get &quot;, elementNum, &quot;th Element reserved byte, which should be either 0x00 or 0x02 followed by a table index&quot;);
388 
389         if (magic == 2)
390             WASM_PARSER_FAIL_IF(!parseVarUInt32(tableIndex), &quot;can&#39;t get &quot;, elementNum, &quot;th Element table index&quot;);
391         else
392             tableIndex = 0;
393 
394         WASM_PARSER_FAIL_IF(tableIndex &gt;= m_info-&gt;tableCount(), &quot;Element section for Table &quot;, tableIndex, &quot; exceeds available Table &quot;, m_info-&gt;tableCount());
395         WASM_PARSER_FAIL_IF(m_info-&gt;tables[tableIndex].type() != TableElementType::Funcref, &quot;Table &quot;, tableIndex, &quot; must have type &#39;funcref&#39; to have an element section&quot;);
396         Type initExprType;
397         WASM_FAIL_IF_HELPER_FAILS(parseInitExpr(initOpcode, initExprBits, initExprType));
398         WASM_PARSER_FAIL_IF(initExprType != I32, &quot;Element init_expr must produce an i32&quot;);
399         WASM_PARSER_FAIL_IF(!parseVarUInt32(indexCount), &quot;can&#39;t get &quot;, elementNum, &quot;th index count for Element section&quot;);
400         WASM_PARSER_FAIL_IF(indexCount == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;Element section&#39;s &quot;, elementNum, &quot;th index count is too big &quot;, indexCount);
401 
402         ASSERT(!!m_info-&gt;tables[tableIndex]);
403 
404         Element element(tableIndex, makeI32InitExpr(initOpcode, initExprBits));
405         WASM_PARSER_FAIL_IF(!element.functionIndices.tryReserveCapacity(indexCount), &quot;can&#39;t allocate memory for &quot;, indexCount, &quot; Element indices&quot;);
406 
407         for (unsigned index = 0; index &lt; indexCount; ++index) {
408             uint32_t functionIndex;
409             WASM_PARSER_FAIL_IF(!parseVarUInt32(functionIndex), &quot;can&#39;t get Element section&#39;s &quot;, elementNum, &quot;th element&#39;s &quot;, index, &quot;th index&quot;);
410             WASM_PARSER_FAIL_IF(functionIndex &gt;= m_info-&gt;functionIndexSpaceSize(), &quot;Element section&#39;s &quot;, elementNum, &quot;th element&#39;s &quot;, index, &quot;th index is &quot;, functionIndex, &quot; which exceeds the function index space size of &quot;, m_info-&gt;functionIndexSpaceSize());
411 
412             element.functionIndices.uncheckedAppend(functionIndex);
413         }
414 
415         m_info-&gt;elements.uncheckedAppend(WTFMove(element));
416     }
417 
418     return { };
419 }
420 
421 auto SectionParser::parseCode() -&gt; PartialResult
422 {
423     // The Code section is handled specially in StreamingParser.
424     RELEASE_ASSERT_NOT_REACHED();
425     return { };
426 }
427 
428 auto SectionParser::parseInitExpr(uint8_t&amp; opcode, uint64_t&amp; bitsOrImportNumber, Type&amp; resultType) -&gt; PartialResult
429 {
430     WASM_PARSER_FAIL_IF(!parseUInt8(opcode), &quot;can&#39;t get init_expr&#39;s opcode&quot;);
431 
432     switch (opcode) {
433     case I32Const: {
434         int32_t constant;
435         WASM_PARSER_FAIL_IF(!parseVarInt32(constant), &quot;can&#39;t get constant value for init_expr&#39;s i32.const&quot;);
436         bitsOrImportNumber = static_cast&lt;uint64_t&gt;(constant);
437         resultType = I32;
438         break;
439     }
440 
441     case I64Const: {
442         int64_t constant;
443         WASM_PARSER_FAIL_IF(!parseVarInt64(constant), &quot;can&#39;t get constant value for init_expr&#39;s i64.const&quot;);
444         bitsOrImportNumber = constant;
445         resultType = I64;
446         break;
447     }
448 
449     case F32Const: {
450         uint32_t constant;
451         WASM_PARSER_FAIL_IF(!parseUInt32(constant), &quot;can&#39;t get constant value for init_expr&#39;s f32.const&quot;);
452         bitsOrImportNumber = constant;
453         resultType = F32;
454         break;
455     }
456 
457     case F64Const: {
458         uint64_t constant;
459         WASM_PARSER_FAIL_IF(!parseUInt64(constant), &quot;can&#39;t get constant value for init_expr&#39;s f64.const&quot;);
460         bitsOrImportNumber = constant;
461         resultType = F64;
462         break;
463     }
464 
465     case GetGlobal: {
466         uint32_t index;
467         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get get_global&#39;s index&quot;);
468 
469         WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;globals.size(), &quot;get_global&#39;s index &quot;, index, &quot; exceeds the number of globals &quot;, m_info-&gt;globals.size());
470         WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;firstInternalGlobal, &quot;get_global import kind index &quot;, index, &quot; exceeds the first internal global &quot;, m_info-&gt;firstInternalGlobal);
471         WASM_PARSER_FAIL_IF(m_info-&gt;globals[index].mutability != GlobalInformation::Immutable, &quot;get_global import kind index &quot;, index, &quot; is mutable &quot;);
472 
473         resultType = m_info-&gt;globals[index].type;
474         bitsOrImportNumber = index;
475         break;
476     }
477 
478     case RefNull: {
479         resultType = Funcref;
480         bitsOrImportNumber = JSValue::encode(jsNull());
481         break;
482     }
483 
484     case RefFunc: {
485         uint32_t index;
486         WASM_PARSER_FAIL_IF(!parseVarUInt32(index), &quot;can&#39;t get ref.func index&quot;);
487         WASM_PARSER_FAIL_IF(index &gt;= m_info-&gt;functions.size(), &quot;ref.func index&quot;, index, &quot; exceeds the number of functions &quot;, m_info-&gt;functions.size());
488 
489         resultType = Funcref;
490         bitsOrImportNumber = index;
491         break;
492     }
493 
494     default:
495         WASM_PARSER_FAIL_IF(true, &quot;unknown init_expr opcode &quot;, opcode);
496     }
497 
498     uint8_t endOpcode;
499     WASM_PARSER_FAIL_IF(!parseUInt8(endOpcode), &quot;can&#39;t get init_expr&#39;s end opcode&quot;);
500     WASM_PARSER_FAIL_IF(endOpcode != OpType::End, &quot;init_expr should end with end, ended with &quot;, endOpcode);
501 
502     return { };
503 }
504 
505 auto SectionParser::parseGlobalType(GlobalInformation&amp; global) -&gt; PartialResult
506 {
507     uint8_t mutability;
508     WASM_PARSER_FAIL_IF(!parseValueType(global.type), &quot;can&#39;t get Global&#39;s value type&quot;);
509     WASM_PARSER_FAIL_IF(!parseVarUInt1(mutability), &quot;can&#39;t get Global type&#39;s mutability&quot;);
510     global.mutability = static_cast&lt;GlobalInformation::Mutability&gt;(mutability);
511     return { };
512 }
513 
514 auto SectionParser::parseData() -&gt; PartialResult
515 {
516     uint32_t segmentCount;
517     WASM_PARSER_FAIL_IF(!parseVarUInt32(segmentCount), &quot;can&#39;t get Data section&#39;s count&quot;);
518     WASM_PARSER_FAIL_IF(segmentCount &gt; maxDataSegments, &quot;Data section&#39;s count is too big &quot;, segmentCount, &quot; maximum &quot;, maxDataSegments);
519     WASM_PARSER_FAIL_IF(!m_info-&gt;data.tryReserveCapacity(segmentCount), &quot;can&#39;t allocate enough memory for Data section&#39;s &quot;, segmentCount, &quot; segments&quot;);
520 
521     for (uint32_t segmentNumber = 0; segmentNumber &lt; segmentCount; ++segmentNumber) {
522         uint32_t memoryIndex;
523         uint64_t initExprBits;
524         uint8_t initOpcode;
525         uint32_t dataByteLength;
526 
527         WASM_PARSER_FAIL_IF(!parseVarUInt32(memoryIndex), &quot;can&#39;t get &quot;, segmentNumber, &quot;th Data segment&#39;s index&quot;);
528         WASM_PARSER_FAIL_IF(memoryIndex &gt;= m_info-&gt;memoryCount(), segmentNumber, &quot;th Data segment has index &quot;, memoryIndex, &quot; which exceeds the number of Memories &quot;, m_info-&gt;memoryCount());
529         Type initExprType;
530         WASM_FAIL_IF_HELPER_FAILS(parseInitExpr(initOpcode, initExprBits, initExprType));
531         WASM_PARSER_FAIL_IF(initExprType != I32, segmentNumber, &quot;th Data segment&#39;s init_expr must produce an i32&quot;);
532         WASM_PARSER_FAIL_IF(!parseVarUInt32(dataByteLength), &quot;can&#39;t get &quot;, segmentNumber, &quot;th Data segment&#39;s data byte length&quot;);
533         WASM_PARSER_FAIL_IF(dataByteLength &gt; maxModuleSize, segmentNumber, &quot;th Data segment&#39;s data byte length is too big &quot;, dataByteLength, &quot; maximum &quot;, maxModuleSize);
534 
535         Segment* segment = Segment::create(makeI32InitExpr(initOpcode, initExprBits), dataByteLength);
536         WASM_PARSER_FAIL_IF(!segment, &quot;can&#39;t allocate enough memory for &quot;, segmentNumber, &quot;th Data segment of size &quot;, dataByteLength);
537         m_info-&gt;data.uncheckedAppend(Segment::adoptPtr(segment));
538         for (uint32_t dataByte = 0; dataByte &lt; dataByteLength; ++dataByte) {
539             uint8_t byte;
540             WASM_PARSER_FAIL_IF(!parseUInt8(byte), &quot;can&#39;t get &quot;, dataByte, &quot;th data byte from &quot;, segmentNumber, &quot;th Data segment&quot;);
541             segment-&gt;byte(dataByte) = byte;
542         }
543     }
544     return { };
545 }
546 
547 auto SectionParser::parseCustom() -&gt; PartialResult
548 {
549     CustomSection section;
550     uint32_t customSectionNumber = m_info-&gt;customSections.size() + 1;
551     uint32_t nameLen;
552     WASM_PARSER_FAIL_IF(!m_info-&gt;customSections.tryReserveCapacity(customSectionNumber), &quot;can&#39;t allocate enough memory for &quot;, customSectionNumber, &quot;th custom section&quot;);
553     WASM_PARSER_FAIL_IF(!parseVarUInt32(nameLen), &quot;can&#39;t get &quot;, customSectionNumber, &quot;th custom section&#39;s name length&quot;);
554     WASM_PARSER_FAIL_IF(!consumeUTF8String(section.name, nameLen), &quot;nameLen get &quot;, customSectionNumber, &quot;th custom section&#39;s name of length &quot;, nameLen);
555 
556     uint32_t payloadBytes = length() - m_offset;
557     WASM_PARSER_FAIL_IF(!section.payload.tryReserveCapacity(payloadBytes), &quot;can&#39;t allocate enough memory for &quot;, customSectionNumber, &quot;th custom section&#39;s &quot;, payloadBytes, &quot; bytes&quot;);
558     for (uint32_t byteNumber = 0; byteNumber &lt; payloadBytes; ++byteNumber) {
559         uint8_t byte;
560         WASM_PARSER_FAIL_IF(!parseUInt8(byte), &quot;can&#39;t get &quot;, byteNumber, &quot;th data byte from &quot;, customSectionNumber, &quot;th custom section&quot;);
561         section.payload.uncheckedAppend(byte);
562     }
563 
564     Name nameName = { &#39;n&#39;, &#39;a&#39;, &#39;m&#39;, &#39;e&#39; };
565     if (section.name == nameName) {
566         NameSectionParser nameSectionParser(section.payload.begin(), section.payload.size(), m_info);
567         if (auto nameSection = nameSectionParser.parse())
568             m_info-&gt;nameSection = WTFMove(*nameSection);
569     }
570 
571     m_info-&gt;customSections.uncheckedAppend(WTFMove(section));
572 
573     return { };
574 }
575 
576 } } // namespace JSC::Wasm
577 
578 #endif // ENABLE(WEBASSEMBLY)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmStreamingParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmSignatureInlines.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmStreamingParser.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmStreamingParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -26,12 +26,13 @@</span>
  #include &quot;config.h&quot;
  #include &quot;WasmStreamingParser.h&quot;
  
  #if ENABLE(WEBASSEMBLY)
  
<span class="udiff-line-modified-removed">- #include &quot;WasmModuleParser.h&quot;</span>
<span class="udiff-line-modified-added">+ #include &quot;WasmOps.h&quot;</span>
  #include &quot;WasmSectionParser.h&quot;
<span class="udiff-line-added">+ #include &quot;WasmSignatureInlines.h&quot;</span>
  #include &lt;wtf/Optional.h&gt;
  #include &lt;wtf/UnalignedAccess.h&gt;
  
  namespace JSC { namespace Wasm {
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -65,12 +66,13 @@</span>
      m_errorMessage = makeString(&quot;WebAssembly.Module doesn&#39;t parse at byte &quot;_s, String::number(m_offset), &quot;: &quot;_s, makeString(args)...);
      dataLogLnIf(WasmStreamingParserInternal::verbose, m_errorMessage);
      return State::FatalError;
  }
  
<span class="udiff-line-modified-removed">- StreamingParser::StreamingParser(ModuleInformation&amp; info)</span>
<span class="udiff-line-modified-added">+ StreamingParser::StreamingParser(ModuleInformation&amp; info, StreamingParserClient&amp; client)</span>
      : m_info(info)
<span class="udiff-line-added">+     , m_client(client)</span>
  {
      dataLogLnIf(WasmStreamingParserInternal::verbose, &quot;starting validation&quot;);
  }
  
  auto StreamingParser::parseModuleHeader(Vector&lt;uint8_t&gt;&amp;&amp; data) -&gt; State
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -118,10 +120,12 @@</span>
      WASM_PARSER_FAIL_IF(functionCount == std::numeric_limits&lt;uint32_t&gt;::max(), &quot;Code section&#39;s count is too big &quot;, functionCount);
      WASM_PARSER_FAIL_IF(functionCount != m_info-&gt;functions.size(), &quot;Code section count &quot;, functionCount, &quot; exceeds the declared number of functions &quot;, m_info-&gt;functions.size());
  
      if (m_functionIndex == m_functionCount) {
          WASM_PARSER_FAIL_IF((m_codeOffset + m_sectionLength) != m_nextOffset, &quot;parsing ended before the end of &quot;, m_section, &quot; section&quot;);
<span class="udiff-line-added">+         if (!m_client.didReceiveSectionData(m_section))</span>
<span class="udiff-line-added">+             return State::FatalError;</span>
          return State::SectionID;
      }
      return State::FunctionSize;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -137,13 +141,18 @@</span>
      auto&amp; function = m_info-&gt;functions[m_functionIndex];
      function.start = m_offset;
      function.end = m_offset + m_functionSize;
      function.data = WTFMove(data);
      dataLogLnIf(WasmStreamingParserInternal::verbose, &quot;Processing function starting at: &quot;, function.start, &quot; and ending at: &quot;, function.end);
<span class="udiff-line-added">+     if (!m_client.didReceiveFunctionData(m_functionIndex, function))</span>
<span class="udiff-line-added">+         return State::FatalError;</span>
      ++m_functionIndex;
<span class="udiff-line-added">+ </span>
      if (m_functionIndex == m_functionCount) {
          WASM_PARSER_FAIL_IF((m_codeOffset + m_sectionLength) != (m_offset + m_functionSize), &quot;parsing ended before the end of &quot;, m_section, &quot; section&quot;);
<span class="udiff-line-added">+         if (!m_client.didReceiveSectionData(m_section))</span>
<span class="udiff-line-added">+             return State::FatalError;</span>
          return State::SectionID;
      }
      return State::FunctionSize;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -170,10 +179,12 @@</span>
      }
      }
  
      WASM_PARSER_FAIL_IF(parser.length() != parser.offset(), &quot;parsing ended before the end of &quot;, m_section, &quot; section&quot;);
  
<span class="udiff-line-added">+     if (!m_client.didReceiveSectionData(m_section))</span>
<span class="udiff-line-added">+         return State::FatalError;</span>
      return State::SectionID;
  }
  
  auto StreamingParser::consume(const uint8_t* bytes, size_t bytesSize, size_t&amp; offsetInBytes, size_t requiredSize) -&gt; Optional&lt;Vector&lt;uint8_t&gt;&gt;
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -376,14 +387,19 @@</span>
      case State::Finished:
      case State::FatalError:
          break;
  
      case State::SectionID:
<span class="udiff-line-added">+         if (m_functionIndex != m_info-&gt;functions.size()) {</span>
<span class="udiff-line-added">+             m_state = fail(&quot;Number of functions parsed (&quot;, m_functionCount, &quot;) does not match the number of declared functions (&quot;, m_info-&gt;functions.size(), &quot;)&quot;);</span>
<span class="udiff-line-added">+             break;</span>
<span class="udiff-line-added">+         }</span>
          if (m_remaining.isEmpty()) {
              if (UNLIKELY(Options::useEagerWebAssemblyModuleHashing()))
                  m_info-&gt;nameSection-&gt;setHash(m_hasher.computeHexDigest());
              m_state = State::Finished;
<span class="udiff-line-added">+             m_client.didFinishParsing();</span>
          } else
              m_state = failOnState(State::SectionID);
          break;
      }
      return m_state;
</pre>
<center><a href="WasmSignatureInlines.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmStreamingParser.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorOverlay.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorNodeFinder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorShaderProgram.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/InspectorOverlay.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 204     Path path;
 205     path.moveTo(quad.p1());
 206     path.addLineTo(quad.p2());
 207     path.addLineTo(quad.p3());
 208     path.addLineTo(quad.p4());
 209     path.closeSubpath();
 210 
 211     bounds.unite(path.boundingRect());
 212 
 213     return path;
 214 }
 215 
 216 static void drawOutlinedQuadWithClip(GraphicsContext&amp; context, const FloatQuad&amp; quad, const FloatQuad&amp; clipQuad, const Color&amp; fillColor, Highlight::Bounds&amp; bounds)
 217 {
 218     GraphicsContextStateSaver stateSaver(context);
 219 
 220     context.setFillColor(fillColor);
 221     context.setStrokeThickness(0);
 222     context.fillPath(quadToPath(quad, bounds));
 223 
<span class="line-modified"> 224     context.setCompositeOperation(CompositeDestinationOut);</span>
<span class="line-modified"> 225     context.setFillColor(Color::createUnchecked(255, 0, 0));</span>
 226     context.fillPath(quadToPath(clipQuad, bounds));
 227 }
 228 
 229 static void drawOutlinedQuad(GraphicsContext&amp; context, const FloatQuad&amp; quad, const Color&amp; fillColor, const Color&amp; outlineColor, Highlight::Bounds&amp; bounds)
 230 {
 231     Path path = quadToPath(quad, bounds);
 232 
 233     GraphicsContextStateSaver stateSaver(context);
 234 
 235     context.setStrokeThickness(2);
 236 
 237     context.clipPath(path);
 238 
 239     context.setFillColor(fillColor);
 240     context.fillPath(path);
 241 
 242     context.setStrokeColor(outlineColor);
 243     context.strokePath(path);
 244 }
 245 
</pre>
<hr />
<pre>
 298     Shape::DisplayPaths paths;
 299     shapeOutsideInfo-&gt;computedShape().buildDisplayPaths(paths);
 300 
 301     if (paths.shape.isEmpty()) {
 302         LayoutRect shapeBounds = shapeOutsideInfo-&gt;computedShapePhysicalBoundingBox();
 303         FloatQuad shapeQuad = renderer-&gt;localToAbsoluteQuad(FloatRect(shapeBounds));
 304         contentsQuadToCoordinateSystem(mainView, containingView, shapeQuad, InspectorOverlay::CoordinateSystem::Document);
 305         drawOutlinedQuad(context, shapeQuad, shapeHighlightColor, Color::transparent, bounds);
 306         return;
 307     }
 308 
 309     const auto mapPoints = [&amp;] (const Path&amp; path) {
 310         Path newPath;
 311         path.apply([&amp;] (const PathElement&amp; pathElement) {
 312             const auto localToRoot = [&amp;] (size_t index) {
 313                 const FloatPoint&amp; point = pathElement.points[index];
 314                 return localPointToRootPoint(containingView, renderer-&gt;localToAbsolute(shapeOutsideInfo-&gt;shapeToRendererPoint(point)));
 315             };
 316 
 317             switch (pathElement.type) {
<span class="line-modified"> 318             case PathElementMoveToPoint:</span>
 319                 newPath.moveTo(localToRoot(0));
 320                 break;
 321 
<span class="line-modified"> 322             case PathElementAddLineToPoint:</span>
 323                 newPath.addLineTo(localToRoot(0));
 324                 break;
 325 
<span class="line-modified"> 326             case PathElementAddCurveToPoint:</span>
 327                 newPath.addBezierCurveTo(localToRoot(0), localToRoot(1), localToRoot(2));
 328                 break;
 329 
<span class="line-modified"> 330             case PathElementAddQuadCurveToPoint:</span>
 331                 newPath.addQuadCurveTo(localToRoot(0), localToRoot(1));
 332                 break;
 333 
<span class="line-modified"> 334             case PathElementCloseSubpath:</span>
 335                 newPath.closeSubpath();
 336                 break;
 337             }
 338         });
 339         return newPath;
 340     };
 341 
 342     if (paths.marginShape.length()) {
 343         Path marginPath = mapPoints(paths.marginShape);
 344         bounds.unite(marginPath.boundingRect());
 345 
 346         GraphicsContextStateSaver stateSaver(context);
 347 
 348         const Color shapeMarginHighlightColor(96, 82, 127, 153);
 349         context.setFillColor(shapeMarginHighlightColor);
 350         context.fillPath(marginPath);
 351     }
 352 
 353     Path shapePath = mapPoints(paths.shape);
 354     bounds.unite(shapePath.boundingRect());
</pre>
<hr />
<pre>
 774                 float lineLength = 0.0f;
 775                 if (std::fmod(x, rulerStepIncrement)) {
 776                     lineLength = rulerSubStepLength;
 777                     context.setStrokeColor(lightRulerColor);
 778                 } else {
 779                     lineLength = std::fmod(x, rulerStepIncrement * 2) ? rulerSubStepLength : rulerStepLength;
 780                     context.setStrokeColor(darkRulerColor);
 781                 }
 782                 path.addLineTo({ zoom(x), scrollY + (drawTopEdge ? lineLength : rulerSize - lineLength) });
 783 
 784                 context.strokePath(path);
 785             }
 786 
 787             // Draw labels.
 788             for (float x = multipleBelow(minX, rulerStepIncrement * 2); x &lt; maxX; x += rulerStepIncrement * 2) {
 789                 if (!x &amp;&amp; !scrollX)
 790                     continue;
 791 
 792                 GraphicsContextStateSaver verticalLabelStateSaver(context);
 793                 context.translate(zoom(x) + 0.5f, scrollY);
<span class="line-modified"> 794                 context.drawText(font, TextRun(String::numberToStringFixedPrecision(x)), { 2, drawTopEdge ? rulerLabelSize : rulerLabelSize - rulerSize + font.fontMetrics().height() - 1.0f });</span>
 795             }
 796         }
 797 
 798         // Draw vertical ruler.
 799         {
 800             GraphicsContextStateSaver veritcalRulerStateSaver(context);
 801 
 802             context.translate(cornerX - scrollX, contentInset.height() - scrollY + 0.5f);
 803 
 804             for (float y = multipleBelow(minY, rulerSubStepIncrement); y &lt; maxY; y += rulerSubStepIncrement) {
 805                 if (!y &amp;&amp; !scrollY)
 806                     continue;
 807 
 808                 Path path;
 809                 path.moveTo({ drawLeftEdge ? scrollX : scrollX + rulerSize, zoom(y) });
 810 
 811                 float lineLength = 0.0f;
 812                 if (std::fmod(y, rulerStepIncrement)) {
 813                     lineLength = rulerSubStepLength;
 814                     context.setStrokeColor(lightRulerColor);
 815                 } else {
 816                     lineLength = std::fmod(y, rulerStepIncrement * 2) ? rulerSubStepLength : rulerStepLength;
 817                     context.setStrokeColor(darkRulerColor);
 818                 }
 819                 path.addLineTo({ scrollX + (drawLeftEdge ? lineLength : rulerSize - lineLength), zoom(y) });
 820 
 821                 context.strokePath(path);
 822             }
 823 
 824             // Draw labels.
 825             for (float y = multipleBelow(minY, rulerStepIncrement * 2); y &lt; maxY; y += rulerStepIncrement * 2) {
 826                 if (!y &amp;&amp; !scrollY)
 827                     continue;
 828 
 829                 GraphicsContextStateSaver horizontalLabelStateSaver(context);
 830                 context.translate(scrollX, zoom(y) + 0.5f);
 831                 context.rotate(drawLeftEdge ? -piOverTwoFloat : piOverTwoFloat);
<span class="line-modified"> 832                 context.drawText(font, TextRun(String::numberToStringFixedPrecision(y)), { 2, drawLeftEdge ? rulerLabelSize : rulerLabelSize - rulerSize });</span>
 833             }
 834         }
 835     }
 836 
 837     // Draw viewport size.
 838     {
 839         FontCascadeDescription fontDescription;
 840         fontDescription.setOneFamily(m_page.settings().sansSerifFontFamily());
 841         fontDescription.setComputedSize(12);
 842 
 843         FontCascade font(WTFMove(fontDescription), 0, 0);
 844         font.update(nullptr);
 845 
 846         auto viewportRect = pageView-&gt;visualViewportRect();
<span class="line-modified"> 847         auto viewportWidthText = String::numberToStringFixedPrecision(viewportRect.width() / pageZoomFactor);</span>
<span class="line-removed"> 848         auto viewportHeightText = String::numberToStringFixedPrecision(viewportRect.height() / pageZoomFactor);</span>
<span class="line-removed"> 849         TextRun viewportTextRun(makeString(viewportWidthText, &quot;px&quot;, &#39; &#39;, multiplicationSign, &#39; &#39;, viewportHeightText, &quot;px&quot;));</span>
 850 
 851         const float margin = 4;
 852         const float padding = 2;
 853         const float radius = 4;
 854         float fontWidth = font.width(viewportTextRun);
 855         float fontHeight = font.fontMetrics().floatHeight();
 856         FloatRect viewportTextRect(margin, margin, (padding * 2.0f) + fontWidth, (padding * 2.0f) + fontHeight);
 857         const auto viewportTextRectCenter = viewportTextRect.center();
 858 
 859         GraphicsContextStateSaver viewportSizeStateSaver(context);
 860 
 861         float leftTranslateX = rulerSize;
 862         float rightTranslateX = 0.0f - (margin * 2.0f) - (padding * 2.0f) - fontWidth;
 863         float translateX = cornerX + (drawLeftEdge ? leftTranslateX : rightTranslateX);
 864 
 865         float topTranslateY = rulerSize;
 866         float bottomTranslateY = 0.0f - (margin * 2.0f) - (padding * 2.0f) - fontHeight;
 867         float translateY = cornerY + (drawTopEdge ? topTranslateY : bottomTranslateY);
 868 
 869         FloatPoint translate(translateX, translateY);
</pre>
</td>
<td>
<hr />
<pre>
 204     Path path;
 205     path.moveTo(quad.p1());
 206     path.addLineTo(quad.p2());
 207     path.addLineTo(quad.p3());
 208     path.addLineTo(quad.p4());
 209     path.closeSubpath();
 210 
 211     bounds.unite(path.boundingRect());
 212 
 213     return path;
 214 }
 215 
 216 static void drawOutlinedQuadWithClip(GraphicsContext&amp; context, const FloatQuad&amp; quad, const FloatQuad&amp; clipQuad, const Color&amp; fillColor, Highlight::Bounds&amp; bounds)
 217 {
 218     GraphicsContextStateSaver stateSaver(context);
 219 
 220     context.setFillColor(fillColor);
 221     context.setStrokeThickness(0);
 222     context.fillPath(quadToPath(quad, bounds));
 223 
<span class="line-modified"> 224     context.setCompositeOperation(CompositeOperator::DestinationOut);</span>
<span class="line-modified"> 225     context.setFillColor(Color(255, 0, 0));</span>
 226     context.fillPath(quadToPath(clipQuad, bounds));
 227 }
 228 
 229 static void drawOutlinedQuad(GraphicsContext&amp; context, const FloatQuad&amp; quad, const Color&amp; fillColor, const Color&amp; outlineColor, Highlight::Bounds&amp; bounds)
 230 {
 231     Path path = quadToPath(quad, bounds);
 232 
 233     GraphicsContextStateSaver stateSaver(context);
 234 
 235     context.setStrokeThickness(2);
 236 
 237     context.clipPath(path);
 238 
 239     context.setFillColor(fillColor);
 240     context.fillPath(path);
 241 
 242     context.setStrokeColor(outlineColor);
 243     context.strokePath(path);
 244 }
 245 
</pre>
<hr />
<pre>
 298     Shape::DisplayPaths paths;
 299     shapeOutsideInfo-&gt;computedShape().buildDisplayPaths(paths);
 300 
 301     if (paths.shape.isEmpty()) {
 302         LayoutRect shapeBounds = shapeOutsideInfo-&gt;computedShapePhysicalBoundingBox();
 303         FloatQuad shapeQuad = renderer-&gt;localToAbsoluteQuad(FloatRect(shapeBounds));
 304         contentsQuadToCoordinateSystem(mainView, containingView, shapeQuad, InspectorOverlay::CoordinateSystem::Document);
 305         drawOutlinedQuad(context, shapeQuad, shapeHighlightColor, Color::transparent, bounds);
 306         return;
 307     }
 308 
 309     const auto mapPoints = [&amp;] (const Path&amp; path) {
 310         Path newPath;
 311         path.apply([&amp;] (const PathElement&amp; pathElement) {
 312             const auto localToRoot = [&amp;] (size_t index) {
 313                 const FloatPoint&amp; point = pathElement.points[index];
 314                 return localPointToRootPoint(containingView, renderer-&gt;localToAbsolute(shapeOutsideInfo-&gt;shapeToRendererPoint(point)));
 315             };
 316 
 317             switch (pathElement.type) {
<span class="line-modified"> 318             case PathElement::Type::MoveToPoint:</span>
 319                 newPath.moveTo(localToRoot(0));
 320                 break;
 321 
<span class="line-modified"> 322             case PathElement::Type::AddLineToPoint:</span>
 323                 newPath.addLineTo(localToRoot(0));
 324                 break;
 325 
<span class="line-modified"> 326             case PathElement::Type::AddCurveToPoint:</span>
 327                 newPath.addBezierCurveTo(localToRoot(0), localToRoot(1), localToRoot(2));
 328                 break;
 329 
<span class="line-modified"> 330             case PathElement::Type::AddQuadCurveToPoint:</span>
 331                 newPath.addQuadCurveTo(localToRoot(0), localToRoot(1));
 332                 break;
 333 
<span class="line-modified"> 334             case PathElement::Type::CloseSubpath:</span>
 335                 newPath.closeSubpath();
 336                 break;
 337             }
 338         });
 339         return newPath;
 340     };
 341 
 342     if (paths.marginShape.length()) {
 343         Path marginPath = mapPoints(paths.marginShape);
 344         bounds.unite(marginPath.boundingRect());
 345 
 346         GraphicsContextStateSaver stateSaver(context);
 347 
 348         const Color shapeMarginHighlightColor(96, 82, 127, 153);
 349         context.setFillColor(shapeMarginHighlightColor);
 350         context.fillPath(marginPath);
 351     }
 352 
 353     Path shapePath = mapPoints(paths.shape);
 354     bounds.unite(shapePath.boundingRect());
</pre>
<hr />
<pre>
 774                 float lineLength = 0.0f;
 775                 if (std::fmod(x, rulerStepIncrement)) {
 776                     lineLength = rulerSubStepLength;
 777                     context.setStrokeColor(lightRulerColor);
 778                 } else {
 779                     lineLength = std::fmod(x, rulerStepIncrement * 2) ? rulerSubStepLength : rulerStepLength;
 780                     context.setStrokeColor(darkRulerColor);
 781                 }
 782                 path.addLineTo({ zoom(x), scrollY + (drawTopEdge ? lineLength : rulerSize - lineLength) });
 783 
 784                 context.strokePath(path);
 785             }
 786 
 787             // Draw labels.
 788             for (float x = multipleBelow(minX, rulerStepIncrement * 2); x &lt; maxX; x += rulerStepIncrement * 2) {
 789                 if (!x &amp;&amp; !scrollX)
 790                     continue;
 791 
 792                 GraphicsContextStateSaver verticalLabelStateSaver(context);
 793                 context.translate(zoom(x) + 0.5f, scrollY);
<span class="line-modified"> 794                 context.drawText(font, TextRun(String::number(x)), { 2, drawTopEdge ? rulerLabelSize : rulerLabelSize - rulerSize + font.fontMetrics().height() - 1.0f });</span>
 795             }
 796         }
 797 
 798         // Draw vertical ruler.
 799         {
 800             GraphicsContextStateSaver veritcalRulerStateSaver(context);
 801 
 802             context.translate(cornerX - scrollX, contentInset.height() - scrollY + 0.5f);
 803 
 804             for (float y = multipleBelow(minY, rulerSubStepIncrement); y &lt; maxY; y += rulerSubStepIncrement) {
 805                 if (!y &amp;&amp; !scrollY)
 806                     continue;
 807 
 808                 Path path;
 809                 path.moveTo({ drawLeftEdge ? scrollX : scrollX + rulerSize, zoom(y) });
 810 
 811                 float lineLength = 0.0f;
 812                 if (std::fmod(y, rulerStepIncrement)) {
 813                     lineLength = rulerSubStepLength;
 814                     context.setStrokeColor(lightRulerColor);
 815                 } else {
 816                     lineLength = std::fmod(y, rulerStepIncrement * 2) ? rulerSubStepLength : rulerStepLength;
 817                     context.setStrokeColor(darkRulerColor);
 818                 }
 819                 path.addLineTo({ scrollX + (drawLeftEdge ? lineLength : rulerSize - lineLength), zoom(y) });
 820 
 821                 context.strokePath(path);
 822             }
 823 
 824             // Draw labels.
 825             for (float y = multipleBelow(minY, rulerStepIncrement * 2); y &lt; maxY; y += rulerStepIncrement * 2) {
 826                 if (!y &amp;&amp; !scrollY)
 827                     continue;
 828 
 829                 GraphicsContextStateSaver horizontalLabelStateSaver(context);
 830                 context.translate(scrollX, zoom(y) + 0.5f);
 831                 context.rotate(drawLeftEdge ? -piOverTwoFloat : piOverTwoFloat);
<span class="line-modified"> 832                 context.drawText(font, TextRun(String::number(y)), { 2, drawLeftEdge ? rulerLabelSize : rulerLabelSize - rulerSize });</span>
 833             }
 834         }
 835     }
 836 
 837     // Draw viewport size.
 838     {
 839         FontCascadeDescription fontDescription;
 840         fontDescription.setOneFamily(m_page.settings().sansSerifFontFamily());
 841         fontDescription.setComputedSize(12);
 842 
 843         FontCascade font(WTFMove(fontDescription), 0, 0);
 844         font.update(nullptr);
 845 
 846         auto viewportRect = pageView-&gt;visualViewportRect();
<span class="line-modified"> 847         TextRun viewportTextRun(makeString(viewportRect.width() / pageZoomFactor, &quot;px&quot;, &#39; &#39;, multiplicationSign, &#39; &#39;, viewportRect.height() / pageZoomFactor, &quot;px&quot;));</span>


 848 
 849         const float margin = 4;
 850         const float padding = 2;
 851         const float radius = 4;
 852         float fontWidth = font.width(viewportTextRun);
 853         float fontHeight = font.fontMetrics().floatHeight();
 854         FloatRect viewportTextRect(margin, margin, (padding * 2.0f) + fontWidth, (padding * 2.0f) + fontHeight);
 855         const auto viewportTextRectCenter = viewportTextRect.center();
 856 
 857         GraphicsContextStateSaver viewportSizeStateSaver(context);
 858 
 859         float leftTranslateX = rulerSize;
 860         float rightTranslateX = 0.0f - (margin * 2.0f) - (padding * 2.0f) - fontWidth;
 861         float translateX = cornerX + (drawLeftEdge ? leftTranslateX : rightTranslateX);
 862 
 863         float topTranslateY = rulerSize;
 864         float bottomTranslateY = 0.0f - (margin * 2.0f) - (padding * 2.0f) - fontHeight;
 865         float translateY = cornerY + (drawTopEdge ? topTranslateY : bottomTranslateY);
 866 
 867         FloatPoint translate(translateX, translateY);
</pre>
</td>
</tr>
</table>
<center><a href="InspectorNodeFinder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="InspectorShaderProgram.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/Brigand.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 // Brigand library
   2 //
   3 // Copyright (c) 2015 Edouard Alligand and Joel Falcou
   4 //
   5 // Boost Software License - Version 1.0 - August 17th, 2003
   6 //
   7 // Permission is hereby granted, free of charge, to any person or organization
   8 // obtaining a copy of the software and accompanying documentation covered by
   9 // this license (the &quot;Software&quot;) to use, reproduce, display, distribute,
  10 // execute, and transmit the Software, and to prepare derivative works of the
  11 // Software, and to permit third-parties to whom the Software is furnished to
  12 // do so, all subject to the following:
  13 //
  14 // The copyright notices in the Software and this entire statement, including
  15 // the above license grant, this restriction and the following disclaimer,
  16 // must be included in all copies of the Software, in whole or in part, and
  17 // all derivative works of the Software, unless such copies or derivative
  18 // works are solely in the form of machine-executable object code generated by
  19 // a source language processor.
  20 //
  21 // THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  22 // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  23 // FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
  24 // SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
  25 // FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
  26 // ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
  27 // DEALINGS IN THE SOFTWARE.
  28 
  29 // This file contains a standalone version of Edouard Alligand and Joel Falcou&#39;s
  30 // Brigand library, which can be found at https://github.com/edouarda/brigand
  31 
  32 #pragma once
  33 
  34 #if defined(_MSC_VER) &amp;&amp; !defined(__GNUC__) &amp;&amp; !defined(__clang__)
  35 #define BRIGAND_COMP_MSVC
  36 #if _MSC_VER == 1900
  37 #define BRIGAND_COMP_MSVC_2015
  38 #elif _MSC_VER == 1800
  39 #define BRIGAND_COMP_MSVC_2013
  40 #endif
  41 #elif __GNUC__
  42 #ifndef __clang__
  43 #define BRIGAND_COMP_GCC
  44 #else
  45 #define BRIGAND_COMP_CLANG
  46 #endif
  47 #endif
  48 
  49 #define BRIGAND_NO_BOOST_SUPPORT 1
  50 
  51 #include &lt;cstddef&gt;
  52 #include &lt;cstdint&gt;
  53 #include &lt;cstring&gt;
  54 #include &lt;initializer_list&gt;
  55 #include &lt;tuple&gt;
  56 #include &lt;type_traits&gt;
  57 #include &lt;utility&gt;
  58 
  59 #if !defined(BRIGAND_NO_BOOST_SUPPORT)
  60 #include &lt;boost/fusion/container/vector/vector_fwd.hpp&gt;
  61 #include &lt;boost/fusion/container/deque/deque_fwd.hpp&gt;
  62 #include &lt;boost/fusion/container/list/list_fwd.hpp&gt;
  63 #include &lt;boost/fusion/container/set/set_fwd.hpp&gt;
  64 #include &lt;boost/variant.hpp&gt;
  65 #endif
  66 
  67 namespace brigand
  68 {
  69   template &lt;class... T&gt; struct list {};
  70   template&lt;typename T, T... Values&gt;
  71   using integral_list = brigand::list&lt; std::integral_constant&lt;T,Values&gt;...&gt;;
  72   using empty_sequence = brigand::list&lt;&gt;;
  73 }
  74 namespace brigand
  75 {
  76   namespace lazy
  77   {
  78     template &lt;class A, template&lt;class...&gt; class B&gt; struct wrap;
  79     template&lt;template&lt;class...&gt; class A, class... T, template&lt;class...&gt; class B&gt;
  80     struct wrap&lt;A&lt;T...&gt;, B&gt;
  81     {
  82       using type = B&lt;T...&gt;;
  83     };
  84   }
  85   template&lt;class A, template&lt;class...&gt; class B&gt;
  86   using wrap = typename lazy::wrap&lt;A, B&gt;::type;
  87 }
  88 namespace brigand
  89 {
  90 namespace detail
  91 {
  92     template &lt;typename... Ts&gt;
  93     struct append_impl
  94     {
  95         using type = brigand::empty_sequence;
  96     };
  97     template &lt;typename T&gt;
  98     struct append_impl&lt;T&gt;
  99     {
 100         using type = T;
 101     };
 102     template &lt;template &lt;typename...&gt; class L1, template &lt;typename...&gt; class L2, typename... T1s,
 103               typename... T2s, typename... Ts&gt;
 104     struct append_impl&lt;L1&lt;T1s...&gt;, L2&lt;T2s...&gt;, Ts...&gt; : append_impl&lt;L1&lt;T1s..., T2s...&gt;, Ts...&gt;
 105     {
 106     };
 107     template &lt;template &lt;typename...&gt; class L, template &lt;typename...&gt; class L1,
 108               template &lt;typename...&gt; class L2, template &lt;typename...&gt; class L3,
 109               template &lt;typename...&gt; class L4, template &lt;typename...&gt; class L5,
 110               template &lt;typename...&gt; class L6, template &lt;typename...&gt; class L7,
 111               template &lt;typename...&gt; class L8, template &lt;typename...&gt; class L9,
 112               template &lt;typename...&gt; class L10, template &lt;typename...&gt; class L11,
 113               template &lt;typename...&gt; class L12, template &lt;typename...&gt; class L13,
 114               template &lt;typename...&gt; class L14, template &lt;typename...&gt; class L15,
 115               template &lt;typename...&gt; class L16, typename... Ts, typename... T1s, typename... T2s,
 116               typename... T3s, typename... T4s, typename... T5s, typename... T6s, typename... T7s,
 117               typename... T8s, typename... T9s, typename... T10s, typename... T11s,
 118               typename... T12s, typename... T13s, typename... T14s, typename... T15s,
 119               typename... T16s, typename... Us&gt;
 120     struct append_impl&lt;L&lt;Ts...&gt;, L1&lt;T1s...&gt;, L2&lt;T2s...&gt;, L3&lt;T3s...&gt;, L4&lt;T4s...&gt;, L5&lt;T5s...&gt;,
 121                        L6&lt;T6s...&gt;, L7&lt;T7s...&gt;, L8&lt;T8s...&gt;, L9&lt;T9s...&gt;, L10&lt;T10s...&gt;, L11&lt;T11s...&gt;,
 122                        L12&lt;T12s...&gt;, L13&lt;T13s...&gt;, L14&lt;T14s...&gt;, L15&lt;T15s...&gt;, L16&lt;T16s...&gt;, Us...&gt;
 123         : append_impl&lt;L&lt;Ts..., T1s..., T2s..., T3s..., T4s..., T5s..., T6s..., T7s..., T8s...,
 124                         T9s..., T10s..., T11s..., T12s..., T13s..., T14s..., T15s..., T16s...&gt;,
 125                       Us...&gt;
 126     {
 127     };
 128 }
 129 namespace lazy
 130 {
 131     template &lt;typename... Ts&gt;
 132     using append = detail::append_impl&lt;Ts...&gt;;
 133 }
 134 template &lt;typename... Ts&gt;
 135 using append = typename detail::append_impl&lt;Ts...&gt;::type;
 136 namespace lazy
 137 {
 138     template &lt;typename T&gt;
 139     struct join;
 140     template&lt;template&lt;typename...&gt; class L, typename...Ts&gt;
 141     struct join&lt;L&lt;Ts...&gt;&gt; : ::brigand::detail::append_impl&lt;L&lt;&gt;,Ts...&gt;
 142     {
 143     };
 144 }
 145 template &lt;typename T&gt;
 146 using join = wrap&lt;T,append&gt;;
 147 }
 148 namespace brigand
 149 {
 150     template &lt;typename First, typename Second&gt;
 151     struct pair
 152     {
 153         using first_type = First;
 154         using second_type = Second;
 155     };
 156 }
 157 namespace brigand
 158 {
 159   template&lt;typename T&gt; struct type_ { using type = T; };
 160   template&lt;typename T&gt; using type_from = typename T::type;
 161 }
 162 namespace brigand
 163 {
 164     struct no_such_type_ {};
 165 }
 166 namespace brigand
 167 {
 168 namespace lazy
 169 {
 170     template &lt;typename M, typename K&gt;
 171     struct lookup
 172     : decltype(M::at(type_&lt;K&gt;{}))
 173     {};
 174 }
 175     template &lt;typename M, typename K&gt;
 176     using lookup = typename lazy::lookup&lt;M,K&gt;::type;
 177 namespace detail
 178 {
 179     template &lt;class... T&gt;
 180     struct map_impl;
 181     template &lt;&gt;
 182     struct map_impl&lt;&gt;
 183     {
 184         template &lt;typename U&gt;
 185         static type_&lt;no_such_type_&gt; at(U);
 186         template &lt;class K&gt;
 187         static std::false_type has_key(type_&lt;K&gt;);
 188         template &lt;class K&gt;
 189         static map_impl erase(type_&lt;K&gt;);
 190         template &lt;class P&gt;
 191         static map_impl&lt;P&gt; insert(type_&lt;P&gt;);
 192     };
 193     template &lt;class... Ts&gt;
 194     struct map_impl
 195     {
 196     private:
 197         struct Pack : pair&lt;typename Ts::first_type, Ts&gt;... {};
 198         template&lt;class K, class P&gt;
 199         static type_&lt;typename P::second_type&gt; at_impl(pair&lt;K,P&gt;*);
 200     public:
 201         template&lt;class K&gt;
 202         static decltype(at_impl&lt;K&gt;(static_cast&lt;Pack*&gt;(nullptr))) at(type_&lt;K&gt;);
 203         template&lt;class K&gt;
 204         static type_&lt;no_such_type_&gt; at(K);
 205         template &lt;class K, class = decltype(at_impl&lt;K&gt;(static_cast&lt;Pack*&gt;(nullptr)))&gt;
 206         static std::true_type has_key(type_&lt;K&gt;);
 207         template &lt;class K&gt;
 208         static std::false_type has_key(K);
 209         template &lt;class K&gt;
 210         static append&lt;map_impl&lt;&gt;, typename std::conditional&lt;std::is_same&lt;K, typename Ts::first_type&gt;::value, list&lt;&gt;, list&lt;Ts&gt;&gt;::type...&gt; erase(type_&lt;K&gt;);
 211         template &lt;class P, class = decltype(static_cast&lt;pair&lt;typename P::first_type, P&gt;*&gt;(static_cast&lt;Pack*&gt;(nullptr)))&gt;
 212         static map_impl insert(type_&lt;P&gt;);
 213         template &lt;class P&gt;
 214         static map_impl&lt;Ts..., typename P::type&gt; insert(P);
 215     };
 216     template&lt;class... Ts&gt;
 217     struct make_map : type_&lt;typename Ts::first_type&gt;... {
 218       using type = map_impl&lt;Ts...&gt;;
 219     };
 220 }
 221     template&lt;class... Ts&gt;
 222     using map = typename detail::make_map&lt;Ts...&gt;::type;
 223 }
 224 namespace brigand
 225 {
 226 namespace detail
 227 {
 228   template&lt;class, class&gt;
 229   struct dup_append_list;
 230   template&lt;template&lt;class...&gt; class List, class... Ts, class... Us&gt;
 231   struct dup_append_list&lt;List&lt;Ts...&gt;, List&lt;Us...&gt;&gt;
 232   {
 233     using type = List&lt;Ts..., Ts..., Us...&gt;;
 234   };
 235   template&lt;class T, template&lt;class...&gt; class List, std::size_t N&gt;
 236   struct filled_list_impl
 237   : dup_append_list&lt;
 238     typename filled_list_impl&lt;T, List, N/2&gt;::type,
 239     typename filled_list_impl&lt;T, List, N - N/2*2&gt;::type
 240   &gt;
 241   {};
 242   template&lt;class T, template&lt;class...&gt; class List&gt;
 243   struct filled_list_impl&lt;T, List, 1&gt;
 244   {
 245     using type = List&lt;T&gt;;
 246   };
 247   template&lt;class T, template&lt;class...&gt; class List&gt;
 248   struct filled_list_impl&lt;T, List, 0&gt;
 249   {
 250     using type = List&lt;&gt;;
 251   };
 252 }
 253   template&lt;class T, std::size_t N, template&lt;class...&gt; class List = list&gt;
 254   using filled_list = typename detail::filled_list_impl&lt;T, List, N&gt;::type;
 255 }
 256 namespace brigand
 257 {
 258   namespace detail
 259   {
 260     template&lt;class T&gt; struct element_at;
 261     template&lt;class... Ts&gt;
 262     struct element_at&lt;list&lt;Ts...&gt;&gt;
 263     {
 264       template&lt;class T&gt; type_&lt;T&gt; static at(Ts..., type_&lt;T&gt;*, ...);
 265     };
 266     template&lt;std::size_t N, typename Seq&gt; struct at_impl;
 267     template&lt;std::size_t N, template&lt;typename...&gt; class L, class... Ts&gt;
 268     struct at_impl&lt;N,L&lt;Ts...&gt;&gt;
 269     : decltype(element_at&lt;brigand::filled_list&lt;void const *, N&gt;&gt;::at(static_cast&lt;type_&lt;Ts&gt;*&gt;(nullptr)...))
 270     {
 271     };
 272   }
 273   template &lt;class L, std::size_t Index&gt;
 274   using at_c = typename detail::at_impl&lt;Index, L&gt;::type;
 275 namespace detail
 276 {
 277     template &lt;typename T&gt;
 278     struct has_at_method
 279     {
 280         struct dummy {};
 281         template &lt;typename C, typename P&gt;
 282         static auto test(P * p) -&gt; decltype(C::at(*p), std::true_type());
 283         template &lt;typename, typename&gt;
 284         static std::false_type test(...);
<a name="1" id="anc1"></a><span class="line-modified"> 285         static const bool value = std::is_same&lt;std::true_type, decltype(test&lt;T, dummy&gt;(nullptr))&gt;::value;</span>
 286     };
 287     template &lt;class L, typename Index, bool&gt;
 288     struct at_dispatch
 289     {
 290         using type = at_c&lt;L, Index::value&gt;;
 291     };
 292     template &lt;class L, typename Index&gt;
 293     struct at_dispatch&lt;L, Index, true&gt;
 294     {
 295         using type = lookup&lt;L, Index&gt;;
 296     };
 297 }
 298     template &lt;class Seq, typename K&gt;
 299     using at = typename detail::at_dispatch&lt;Seq, K, detail::has_at_method&lt;Seq&gt;::value&gt;::type;
 300 }
 301 namespace brigand
 302 {
 303     template &lt;template &lt;typename...&gt; class, typename...&gt;
 304     struct bind
 305     {
 306     };
 307 }
 308 namespace brigand
 309 {
 310   template&lt;std::size_t Index&gt; struct args
 311   {
 312   };
 313   struct _1 {};
 314   struct _2 {};
 315   using _3 = args&lt;2&gt;;
 316   using _4 = args&lt;3&gt;;
 317   using _5 = args&lt;4&gt;;
 318   using _6 = args&lt;5&gt;;
 319   using _7 = args&lt;6&gt;;
 320   using _8 = args&lt;7&gt;;
 321   using _9 = args&lt;8&gt;;
 322   using _state = _1;
 323   using _element = _2;
 324 }
 325 namespace brigand
 326 {
 327 template &lt;typename T&gt;
 328 struct defer
 329 {
 330 };
 331 template &lt;typename T&gt;
 332 struct pin
 333 {
 334 };
 335 template &lt;typename T&gt;
 336 struct parent
 337 {
 338 };
 339 namespace detail
 340 {
 341     template &lt;typename T, typename... Ts&gt;
 342     struct packaged_lcall
 343     {
 344     };
 345     template &lt;typename T, typename... Ls&gt;
 346     struct apply {
 347         using type = T;
 348     };
 349     template &lt;template&lt;typename...&gt; class F, typename...Ts, typename... Args&gt;
 350     struct apply&lt;bind&lt;F,Ts...&gt;, Args...&gt;
 351     {
 352         using type = F&lt;typename apply&lt;Ts, Args...&gt;::type...&gt;;
 353     };
 354     template &lt;template &lt;typename...&gt; class F, typename... Ts, typename L, typename... Ls&gt;
 355     struct apply&lt;F&lt;Ts...&gt;, L, Ls...&gt; : F&lt;typename apply&lt;Ts, L, Ls...&gt;::type...&gt;
 356     {
 357     };
 358     template &lt;typename T, typename... Args, typename...Ls&gt;
 359     struct apply&lt;pin&lt;T&gt;, list&lt;Args...&gt;, Ls...&gt;
 360     {
 361         using type = T;
 362     };
 363     template &lt;std::size_t N, typename L, typename...Ls&gt;
 364     struct apply&lt;args&lt;N&gt;, L, Ls...&gt;
 365     {
 366         using type = at_c&lt;L, N&gt;;
 367     };
 368     template &lt;typename T, typename...Ts, typename...Ls&gt;
 369     struct apply&lt;_1, list&lt;T, Ts...&gt;, Ls...&gt;
 370     {
 371         using type = T;
 372     };
 373     template &lt;typename T, typename U, typename...Ts, typename...Ls&gt;
 374     struct apply&lt;_2, list&lt;T, U, Ts...&gt;, Ls...&gt;
 375     {
 376         using type = U;
 377     };
 378     template &lt;typename T, typename L, typename...Ls&gt;
 379     struct apply&lt;parent&lt;T&gt;, L, Ls...&gt; : apply&lt;T,Ls...&gt;
 380     {
 381     };
 382     template &lt;typename Lambda, typename L, typename...Ls&gt;
 383     struct apply&lt;defer&lt;Lambda&gt;, L, Ls...&gt;
 384     {
 385         using type = packaged_lcall&lt;Lambda, L, Ls...&gt;;
 386     };
 387     template &lt;template &lt;typename...&gt; class Lambda, typename... Ts, typename... PLs, typename L, typename...Ls&gt;
 388     struct apply&lt;packaged_lcall&lt;Lambda&lt;Ts...&gt;, PLs...&gt;, L, Ls...&gt; : Lambda&lt;typename apply&lt;Ts, L, Ls..., PLs...&gt;::type...&gt;
 389     {
 390     };
 391     template &lt;template &lt;typename...&gt; class Lambda, typename... Ts, typename... PLs, typename L, typename...Ls&gt;
 392     struct apply&lt;packaged_lcall&lt;bind&lt;Lambda,Ts...&gt;, PLs...&gt;, L, Ls...&gt;
 393     {
 394         using type = Lambda&lt;typename apply&lt;Ts, L, Ls..., PLs...&gt;::type...&gt;;
 395     };
 396     template&lt;typename T, typename...Ts&gt;
 397     using bound_apply = typename apply&lt;T, brigand::list&lt;Ts...&gt;&gt;::type;
 398 }
 399 template &lt;typename Lambda, typename... Args&gt;
 400 using apply = typename detail::apply&lt;Lambda, brigand::list&lt;Args...&gt;&gt;::type;
 401 }
 402 namespace brigand
 403 {
 404   template&lt;std::size_t Index&gt; struct args;
 405   namespace detail
 406   {
 407     template&lt;typename T, typename List&gt;
 408     struct substitute_impl
 409     {
 410       using type = T;
 411     };
 412     template&lt;template&lt;class...&gt; class T, typename... Ts, typename List&gt;
 413     struct substitute_impl&lt;T&lt;Ts...&gt;,List&gt;
 414     {
 415       using type = T&lt;typename substitute_impl&lt;Ts,List&gt;::type...&gt;;
 416     };
 417     template&lt;std::size_t Index, typename List&gt;
 418     struct substitute_impl&lt;args&lt;Index&gt;,List&gt;
 419     {
 420       using type = brigand::at_c&lt;List,Index&gt;;
 421     };
 422   }
 423   template&lt;typename T, typename List&gt;
 424   using substitute = typename detail::substitute_impl&lt;T,List&gt;::type;
 425 }
 426 
 427 namespace brigand
 428 {
 429   template &lt;std::int8_t V&gt;
 430   using int8_t = std::integral_constant&lt;std::int8_t, V&gt;;
 431   template &lt;std::uint8_t V&gt;
 432   using uint8_t = std::integral_constant&lt;std::uint8_t, V&gt;;
 433   template &lt;std::int16_t V&gt;
 434   using int16_t = std::integral_constant&lt;std::int16_t, V&gt;;
 435   template &lt;std::uint16_t V&gt;
 436   using uint16_t = std::integral_constant&lt;std::uint16_t, V&gt;;
 437   template &lt;std::int32_t V&gt;
 438   using int32_t = std::integral_constant&lt;std::int32_t, V&gt;;
 439   template &lt;std::uint32_t V&gt;
 440   using uint32_t = std::integral_constant&lt;std::uint32_t, V&gt;;
 441   template &lt;std::int64_t V&gt;
 442   using int64_t = std::integral_constant&lt;std::int64_t, V&gt;;
 443   template &lt;std::uint64_t V&gt;
 444   using uint64_t = std::integral_constant&lt;std::uint64_t, V&gt;;
 445   template&lt;std::size_t V&gt;
 446   using size_t    = std::integral_constant&lt;std::size_t, V&gt;;
 447   template&lt;std::ptrdiff_t V&gt;
 448   using ptrdiff_t = std::integral_constant&lt;std::ptrdiff_t, V&gt;;
 449 }
 450 
 451 namespace brigand
 452 {
 453 namespace detail
 454 {
 455     constexpr std::size_t count_bools(bool const * const begin, bool const * const end,
 456         std::size_t n)
 457     {
 458         return begin == end ? n : detail::count_bools(begin + 1, end, n + *begin);
 459     }
 460     template &lt;bool... Bs&gt;
 461     struct template_count_bools
 462     {
 463         using type = ::brigand::size_t&lt;0&gt;;
 464     };
 465     template &lt;bool B, bool... Bs&gt;
 466     struct template_count_bools&lt;B, Bs...&gt;
 467     {
 468         using type = ::brigand::size_t&lt;B + template_count_bools&lt;Bs...&gt;::type::value&gt;;
 469     };
 470     template &lt;bool B1, bool B2, bool B3, bool B4, bool B5, bool B6, bool B7, bool B8, bool B9,
 471               bool B10, bool B11, bool B12, bool B13, bool B14, bool B15, bool B16, bool... Bs&gt;
 472     struct template_count_bools&lt;B1, B2, B3, B4, B5, B6, B7, B8, B9, B10, B11, B12, B13, B14, B15,
 473                                 B16, Bs...&gt;
 474     {
 475         using type =
 476             ::brigand::size_t&lt;B1 + B2 + B3 + B4 + B5 + B6 + B7 + B8 + B9 + B10 + B11 + B12 + B13 +
 477                               B14 + B15 + B16 + template_count_bools&lt;Bs...&gt;::type::value&gt;;
 478     };
 479 }
 480 namespace lazy
 481 {
 482     template &lt;typename List, typename Pred&gt;
 483     struct count_if
 484     {
 485     };
 486     template &lt;template &lt;typename...&gt; class S, typename Pred&gt;
 487     struct count_if&lt;S&lt;&gt;, Pred&gt;
 488     {
 489         using type = ::brigand::size_t&lt;0&gt;;
 490     };
 491 #if defined(BRIGAND_COMP_GCC) || defined(BRIGAND_COMP_CLANG)
 492     template &lt;template &lt;typename...&gt; class S, template &lt;typename...&gt; class F&gt;
 493     struct count_if&lt;S&lt;&gt;, bind&lt;F, _1&gt;&gt;
 494     {
 495         using type = ::brigand::size_t&lt;0&gt;;
 496     };
 497     template &lt;template &lt;typename...&gt; class S, template &lt;typename...&gt; class F&gt;
 498     struct count_if&lt;S&lt;&gt;, F&lt;_1&gt;&gt;
 499     {
 500         using type = ::brigand::size_t&lt;0&gt;;
 501     };
 502     template &lt;template&lt;typename...&gt; class S, typename... Ts, typename Pred&gt;
 503     struct count_if&lt;S&lt;Ts...&gt;, Pred&gt;
 504     {
 505         static constexpr bool s_v[] = { ::brigand::apply&lt;Pred, Ts&gt;::type::value... };
 506         using type = brigand::size_t&lt;::brigand::detail::count_bools(s_v, s_v + sizeof...(Ts), 0u)&gt;;
 507     };
 508     template &lt;template &lt;typename...&gt; class S, typename... Ts, template &lt;typename...&gt; class F&gt;
 509     struct count_if&lt;S&lt;Ts...&gt;, bind&lt;F, _1&gt;&gt;
 510     {
 511         static constexpr bool s_v[] = { F&lt;Ts&gt;::value... };
 512         using type = brigand::size_t&lt;::brigand::detail::count_bools(s_v, s_v + sizeof...(Ts), 0u)&gt;;
 513     };
 514     template &lt;template &lt;typename...&gt; class S, typename... Ts, template &lt;typename...&gt; class F&gt;
 515     struct count_if&lt;S&lt;Ts...&gt;, F&lt;_1&gt;&gt;
 516     {
 517         static constexpr bool s_v[] = { F&lt;Ts&gt;::type::value... };
 518         using type = brigand::size_t&lt;::brigand::detail::count_bools(s_v, s_v + sizeof...(Ts), 0u)&gt;;
 519     };
 520 #else
 521     template &lt;template &lt;typename...&gt; class S, typename... Ts, typename Pred&gt;
 522     struct count_if&lt;S&lt;Ts...&gt;, Pred&gt; : ::brigand::detail::template_count_bools&lt;::brigand::apply&lt;Pred, Ts&gt;::value...&gt;
 523     {
 524     };
 525 #endif
 526 }
 527 template &lt;typename List, typename Pred&gt;
 528 using count_if = typename lazy::count_if&lt;List, Pred&gt;::type;
 529 template &lt;class... T&gt;
 530 using count = std::integral_constant&lt;std::size_t, sizeof...(T)&gt;;
 531 }
 532 namespace brigand
 533 {
 534   template&lt;class L&gt; using size = wrap&lt;L, count&gt;;
 535 }
 536 namespace brigand
 537 {
 538   namespace detail
 539   {
 540     template&lt;class L, class... T&gt; struct push_front_impl;
 541     template&lt;template&lt;class...&gt; class L, class... U, class... T&gt;
 542     struct push_front_impl&lt;L&lt;U...&gt;, T...&gt;
 543     {
 544       using type = L&lt;T..., U...&gt;;
 545     };
 546   }
 547   namespace lazy {
 548       template&lt;class L, class... T&gt;
 549       struct push_front : detail::push_front_impl&lt;L, T...&gt;{};
 550   }
 551   template&lt;class L, class... T&gt;
 552   using push_front = typename detail::push_front_impl&lt;L, T...&gt;::type;
 553   namespace detail
 554   {
 555     template&lt;class L&gt; struct front_impl;
 556     template&lt;template&lt;class...&gt; class L, class T, class... U&gt;
 557     struct front_impl&lt;L&lt;T, U...&gt;&gt;
 558     {
 559       using type = T;
 560     };
 561   }
 562   template &lt;class L&gt;
 563   using front = typename detail::front_impl&lt;L&gt;::type;
 564   namespace detail
 565   {
 566     template &lt;class L, std::size_t N&gt; struct pop_front_impl;
 567     template&lt;template&lt;class...&gt; class L, class T, class... U&gt;
 568     struct pop_front_impl&lt;L&lt;T, U...&gt;, 1&gt;
 569     {
 570       using type = L&lt;U...&gt;;
 571     };
 572     template&lt;template&lt;class...&gt; class L, class&gt; struct pop_front_element;
 573     template&lt;template&lt;class...&gt; class L, class... Ts&gt;
 574     struct pop_front_element&lt;L, list&lt;Ts...&gt;&gt;
 575     {
 576       template&lt;class... Us&gt;
 577       static L&lt;Us...&gt; impl(Ts..., type_&lt;Us&gt;*...);
 578     };
 579     template&lt;template&lt;class...&gt; class L, class... Ts, std::size_t N&gt;
 580     struct pop_front_impl&lt;L&lt;Ts...&gt;, N&gt;
 581     {
 582       using type = decltype(pop_front_element&lt;L, filled_list&lt;
 583         void const *, N
 584       &gt;&gt;::impl(static_cast&lt;type_&lt;Ts&gt;*&gt;(nullptr)...));
 585     };
 586   }
 587   namespace lazy {
 588       template &lt;class L, class N = std::integral_constant&lt;std::size_t, 1&gt;&gt;
 589       struct pop_front : detail::pop_front_impl&lt;L, N::value&gt; {};
 590   }
 591   template &lt;class L, class N = std::integral_constant&lt;std::size_t, 1&gt;&gt;
 592   using pop_front = typename detail::pop_front_impl&lt;L, N::value&gt;::type;
 593 }
 594 
 595 namespace brigand
 596 {
 597 namespace detail
 598 {
 599   template&lt;class L&gt;
 600   struct clear_impl;
 601   template&lt;template&lt;class...&gt; class L, class... Ts&gt;
 602   struct clear_impl&lt;L&lt;Ts...&gt;&gt;
 603   {
 604     using type = L&lt;&gt;;
 605   };
 606 }
 607   template&lt;class L&gt;
 608   using clear = typename detail::clear_impl&lt;L&gt;::type;
 609 }
 610 namespace brigand
 611 {
 612 namespace detail
 613 {
 614     template &lt;bool b, typename O, typename L, std::size_t I&gt;
 615     struct split_at_impl;
 616     template &lt;template &lt;typename...&gt; class S, typename... Os, typename T, typename... Ts&gt;
 617     struct split_at_impl&lt;false, S&lt;Os...&gt;, S&lt;T, Ts...&gt;, 0&gt;
 618     {
 619         using type = S&lt;S&lt;Os...&gt;, S&lt;T, Ts...&gt;&gt;;
 620     };
 621     template &lt;template &lt;typename...&gt; class S, typename... Os, typename... Ts&gt;
 622     struct split_at_impl&lt;false, S&lt;Os...&gt;, S&lt;Ts...&gt;, 0&gt;
 623     {
 624         using type = S&lt;S&lt;Os...&gt;, S&lt;Ts...&gt;&gt;;
 625     };
 626     template &lt;template &lt;typename...&gt; class S, typename... Os, typename T, typename... Ts,
 627               std::size_t I&gt;
 628     struct split_at_impl&lt;false, S&lt;Os...&gt;, S&lt;T, Ts...&gt;, I&gt;
 629         : split_at_impl&lt;false, S&lt;Os..., T&gt;, S&lt;Ts...&gt;, (I - 1)&gt;
 630     {
 631     };
 632     template &lt;template &lt;typename...&gt; class S, typename... Os, typename T1, typename T2, typename T3,
 633               typename T4, typename T5, typename T6, typename T7, typename T8, typename T9,
 634               typename T10, typename T11, typename T12, typename T13, typename T14, typename T15,
 635               typename T16, typename... Ts, std::size_t I&gt;
 636     struct split_at_impl&lt;
 637         true, S&lt;Os...&gt;,
 638         S&lt;T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, Ts...&gt;, I&gt;
 639         : split_at_impl&lt;((I - 16) &gt; 16), S&lt;Os..., T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12,
 640                                            T13, T14, T15, T16&gt;,
 641                         S&lt;Ts...&gt;, (I - 16)&gt;
 642     {
 643     };
 644     template &lt;typename L, typename I&gt;
 645     struct call_split_at_impl : split_at_impl&lt;(I::value &gt; 16), brigand::clear&lt;L&gt;, L, I::value&gt;
 646     {
 647     };
 648 }
 649 namespace lazy
 650 {
 651     template &lt;typename L, typename I&gt;
 652     using split_at = ::brigand::detail::call_split_at_impl&lt;L, I&gt;;
 653 }
 654 template &lt;typename L, typename I&gt;
 655 using split_at = typename ::brigand::lazy::split_at&lt;L, I&gt;::type;
 656 }
 657 namespace brigand
 658 {
 659   namespace detail
 660   {
 661     template&lt;class L, class... T&gt; struct push_back_impl;
 662     template&lt;template&lt;class...&gt; class L, class... U, class... T&gt;
 663     struct push_back_impl&lt;L&lt;U...&gt;, T...&gt;
 664     {
 665         using type = L&lt;U..., T...&gt;;
 666     };
 667   }
 668   template&lt;class L, class... T&gt;
 669   using push_back = typename detail::push_back_impl&lt;L, T...&gt;::type;
 670   template &lt;class L&gt;
 671   using back = at_c&lt;L, size&lt;L&gt;::value-1&gt;;
 672   template &lt;class L, class N = std::integral_constant&lt;std::size_t, 1&gt;&gt;
 673   using pop_back = front&lt;split_at&lt;L, std::integral_constant&lt;std::size_t, size&lt;L&gt;::value - N::value&gt;&gt;&gt;;
 674 }
 675 namespace brigand
 676 {
 677   namespace detail
 678   {
 679     template&lt;class L1, class L2&gt;
 680     struct rot90;
 681     template&lt;
 682       class... L1,
 683       template&lt;class...&gt; class S1, class... T1,
 684       template&lt;class...&gt; class S2, class... T2,
 685       template&lt;class...&gt; class S3, class... T3,
 686       template&lt;class...&gt; class S4, class... T4,
 687       template&lt;class...&gt; class S5, class... T5,
 688       template&lt;class...&gt; class S6, class... T6,
 689       template&lt;class...&gt; class S7, class... T7,
 690       template&lt;class...&gt; class S8, class... T8,
 691       class... L2&gt;
 692     struct rot90&lt;list&lt;L1...&gt;, list&lt;
 693       S1&lt;T1...&gt;, S2&lt;T2...&gt;, S3&lt;T3...&gt;, S4&lt;T4...&gt;,
 694       S5&lt;T5...&gt;, S6&lt;T6...&gt;, S7&lt;T7...&gt;, S8&lt;T8...&gt;, L2...&gt;&gt;
 695     : rot90&lt;list&lt;push_back&lt;L1, T1, T2, T3, T4, T5, T6, T7, T8&gt;...&gt;, list&lt;L2...&gt;&gt;
 696     {};
 697     template&lt;class... L1, template&lt;class...&gt; class S, class... T, class... L2&gt;
 698     struct rot90&lt;list&lt;L1...&gt;, list&lt;S&lt;T...&gt;, L2...&gt;&gt;
 699     : rot90&lt;list&lt;push_back&lt;L1, T&gt;...&gt;, list&lt;L2...&gt;&gt;
 700     {};
 701     template&lt;class L1&gt;
 702     struct rot90&lt;L1, list&lt;&gt;&gt;
 703     {
 704       using type = L1;
 705     };
 706     template&lt;class Func, class Seq1, class Seq2, class Seqs&gt;
 707     struct transform_impl;
 708     template&lt;class F, class T1, class T2, class Seq&gt;
 709     struct transform_apply;
 710     template&lt;class F, class T1, class T2, class... Ts&gt;
 711     struct transform_apply&lt;F, T1, T2, list&lt;Ts...&gt;&gt;
 712     {
 713       using type = brigand::apply&lt;F, T1, T2, Ts...&gt;;
 714     };
 715     template&lt;
 716       class Func,
 717       template&lt;class...&gt; class Seq1, class... T1,
 718       template&lt;class...&gt; class Seq2, class... T2,
 719       class... Seqs&gt;
 720     struct transform_impl&lt;Func, Seq1&lt;T1...&gt;, Seq2&lt;T2...&gt;, list&lt;Seqs...&gt;&gt;
 721     {
 722       using type = Seq1&lt;typename transform_apply&lt;Func, T1, T2, Seqs&gt;::type...&gt;;
 723     };
 724     template&lt;std::size_t N, class Seq1, class Seq2, class... FuncOrSeqs&gt;
 725     struct transform
 726     : transform_impl&lt;back&lt;list&lt;FuncOrSeqs...&gt;&gt;, Seq1, Seq2,
 727       typename rot90&lt;filled_list&lt;list&lt;&gt;, size&lt;Seq1&gt;::value&gt;, pop_back&lt;list&lt;FuncOrSeqs...&gt;&gt;&gt;::type&gt;
 728     {};
 729     template&lt;template&lt;class...&gt; class Seq, class... T, class Func&gt;
 730     struct transform&lt;0, Seq&lt;T...&gt;, Func&gt;
 731     {
 732       using type = Seq&lt;brigand::apply&lt;Func, T&gt;...&gt;;
 733     };
 734     template&lt;template&lt;class...&gt; class Seq, class... T, template&lt;typename...&gt; class Func&gt;
 735     struct transform&lt;0, Seq&lt;T...&gt;, bind&lt;Func, _1&gt;&gt;
 736     {
 737         using type = Seq&lt;Func&lt;T&gt;...&gt;;
 738     };
 739     template&lt;template&lt;class...&gt; class Seq, class... T, template&lt;typename...&gt; class Func&gt;
 740     struct transform&lt;0, Seq&lt;T...&gt;, Func&lt;_1&gt;&gt;
 741     {
 742         using type = Seq&lt;typename Func&lt;T&gt;::type...&gt;;
 743     };
 744     template&lt;template&lt;class...&gt; class Seq1, class... T1, template&lt;class...&gt; class Seq2, class... T2, class Func&gt;
 745     struct transform&lt;1, Seq1&lt;T1...&gt;, Seq2&lt;T2...&gt;, Func&gt;
 746     {
 747       using type = Seq1&lt;brigand::apply&lt;Func, T1, T2&gt;...&gt;;
 748     };
 749   }
 750   namespace lazy
 751   {
 752     template&lt;typename Sequence1, typename OpSeq1, typename... OpSeq2&gt;
 753     struct transform : detail::transform&lt;sizeof...(OpSeq2), Sequence1, OpSeq1, OpSeq2...&gt; {};
 754   }
 755   template&lt;typename Sequence1, typename OpSeq1, typename... OpSeq2&gt;
 756   using transform = typename detail::transform&lt;sizeof...(OpSeq2), Sequence1, OpSeq1, OpSeq2...&gt;::type;
 757 }
 758 namespace brigand
 759 {
 760     template &lt;typename T&gt;
 761     struct make_integral : std::integral_constant &lt;typename T::value_type, T::value&gt; {};
 762     template &lt;typename L&gt;
 763     using as_integral_list = transform&lt;L, make_integral&lt;brigand::_1&gt;&gt;;
 764 }
 765 namespace brigand
 766 {
 767 namespace detail
 768 {
 769     template &lt;typename L, template &lt;class...&gt; class Sequence&gt;
 770     struct as_sequence_impl
 771     {
 772         using type = wrap&lt;L, Sequence&gt;;
 773     };
 774 }
 775 template &lt;typename L, template &lt;class...&gt; class Sequence&gt;
 776 using as_sequence = typename detail::as_sequence_impl&lt;L, Sequence&gt;::type;
 777 template &lt;typename L&gt;
 778 using as_list = as_sequence&lt;L, brigand::list&gt;;
 779 }
 780 namespace brigand
 781 {
 782   template &lt;typename... T&gt;
 783   struct pair_wrapper_
 784   {
 785     static_assert (sizeof...(T) == 2
 786                   , &quot;as_pair requires a type list of exactly two types&quot;
 787                   );
 788     using type = no_such_type_;
 789   };
 790   template &lt;typename T, typename U&gt;
 791   struct pair_wrapper_&lt;T,U&gt;
 792   {
 793       using type = std::pair&lt;T,U&gt;;
 794   };
 795   template &lt;typename... T&gt;
 796   using pair_wrapper = typename pair_wrapper_&lt;T...&gt;::type;
 797   template &lt;typename L&gt;
 798   using as_pair = wrap&lt;L, pair_wrapper&gt;;
 799 }
 800 namespace brigand
 801 {
 802   template &lt;typename... T&gt;
 803   using tuple_wrapper = typename std::tuple&lt;T...&gt;;
 804   template &lt;typename L&gt;
 805   using as_tuple = wrap&lt;L, tuple_wrapper&gt;;
 806 }
 807 #if !defined(BRIGAND_NO_BOOST_SUPPORT)
 808 namespace brigand
 809 {
 810   template &lt;typename... T&gt;
 811   using fusion_vector_wrapper = boost::fusion::vector&lt;T...&gt;;
 812   template &lt;typename... T&gt;
 813   using fusion_list_wrapper = boost::fusion::list&lt;T...&gt;;
 814   template &lt;typename... T&gt;
 815   using fusion_deque_wrapper = boost::fusion::deque&lt;T...&gt;;
 816   template &lt;typename... T&gt;
 817   using fusion_set_wrapper = boost::fusion::set&lt;T...&gt;;
 818   template &lt;typename L&gt; using as_fusion_vector = wrap&lt;L, fusion_vector_wrapper&gt;;
 819   template &lt;typename L&gt; using as_fusion_deque  = wrap&lt;L, fusion_deque_wrapper&gt;;
 820   template &lt;typename L&gt; using as_fusion_list   = wrap&lt;L, fusion_list_wrapper&gt;;
 821   template &lt;typename L&gt; using as_fusion_set    = wrap&lt;L, fusion_set_wrapper&gt;;
 822 }
 823 namespace brigand
 824 {
 825   template &lt;typename... T&gt;
 826   using variant_wrapper = typename boost::variant&lt;T...&gt;;
 827   template &lt;typename L&gt;
 828   using as_variant = wrap&lt;L, variant_wrapper&gt;;
 829 }
 830 #endif
 831 
 832 namespace brigand
 833 {
 834   template &lt;bool B&gt;
 835   using bool_ = std::integral_constant&lt;bool, B&gt;;
 836 }
 837 namespace brigand
 838 {
 839 namespace detail
 840 {
 841     template &lt;typename Args&gt;
 842     struct non_null_impl : bool_&lt;Args::value != 0&gt;{};
 843     using non_null = non_null_impl&lt;_1&gt;;
 844 }
 845 }
 846 
 847 namespace brigand
 848 {
 849 #ifdef BRIGAND_COMP_MSVC_2013
 850     namespace detail
 851     {
 852         template &lt;bool...&gt; struct bools_ {};
 853         template&lt; typename Sequence, typename Predicate, typename... Ts&gt; struct all_impl;
 854         template&lt; template&lt;class...&gt; class Sequence, typename Predicate, typename... Ts&gt;
 855         struct  all_impl&lt;Sequence&lt;Ts...&gt;, Predicate&gt;
 856             : std::is_same&lt; bools_&lt;true, ::brigand::apply&lt;Predicate, Ts&gt;::value...&gt;
 857             , bools_&lt;::brigand::apply&lt;Predicate, Ts&gt;::value..., true&gt;
 858             &gt;
 859         {};
 860     }
 861 #else
 862     namespace detail
 863     {
 864         struct all_same
 865         {
 866             const bool value = false;
 867             constexpr all_same(...) {}
 868             template &lt;typename T&gt;
 869             constexpr all_same(std::initializer_list&lt;T *&gt;) : value{ true }
 870             {
 871             }
 872         };
 873         template &lt;typename Sequence, typename Predicate&gt;
 874         struct all_impl : bool_&lt;true&gt;{};
 875         template &lt;template &lt;class...&gt; class Sequence, typename Predicate, typename T, typename... Ts&gt;
 876         struct all_impl&lt;Sequence&lt;T,Ts...&gt;, Predicate&gt;
 877         {
 878             static constexpr all_same tester{ static_cast&lt;::brigand::apply&lt;Predicate, T&gt; *&gt;(nullptr),
 879                 static_cast&lt;::brigand::apply&lt;Predicate, Ts&gt; *&gt;(nullptr)... };
 880             using type = bool_&lt;(::brigand::apply&lt;Predicate, T&gt;::value != 0 &amp;&amp; tester.value)&gt;;
 881         };
 882         template &lt;template &lt;class...&gt; class Sequence, template &lt;typename...&gt; class F, typename T,
 883             typename... Ts&gt;
 884             struct all_impl&lt;Sequence&lt;T, Ts...&gt;, bind&lt;F, _1&gt;&gt;
 885         {
 886             static constexpr all_same tester{ static_cast&lt;F&lt;T&gt; *&gt;(nullptr),
 887                 static_cast&lt;F&lt;Ts&gt; *&gt;(nullptr)... };
 888             using type = bool_&lt;(F&lt;T&gt;::value != 0 &amp;&amp; tester.value)&gt;;
 889         };
 890         template &lt;template &lt;class...&gt; class Sequence, template &lt;typename...&gt; class F, typename T,
 891             typename... Ts&gt;
 892             struct all_impl&lt;Sequence&lt;T, Ts...&gt;, F&lt;_1&gt;&gt;
 893         {
 894             static constexpr all_same tester{ static_cast&lt;typename F&lt;T&gt;::type *&gt;(nullptr),
 895                 static_cast&lt;typename F&lt;Ts&gt;::type *&gt;(nullptr)... };
 896             using type = bool_&lt;(F&lt;T&gt;::type::value != 0 &amp;&amp; tester.value)&gt;;
 897         };
 898     }
 899 #endif
 900     template &lt;typename Sequence, typename Predicate = detail::non_null&gt;
 901     using all = typename detail::all_impl&lt;Sequence, Predicate&gt;::type;
 902 }
 903 namespace brigand
 904 {
 905 #ifdef BRIGAND_COMP_MSVC_2013
 906     namespace detail
 907     {
 908         template&lt;typename Sequence, typename Pred&gt; struct none_impl
 909         {
 910             template&lt;typename T&gt;
 911             struct nope
 912             {
 913                 using that = brigand::apply&lt;Pred, T&gt;;
 914                 using type = bool_&lt;!that::value&gt;;
 915             };
 916             using type = all&lt;Sequence, nope&lt;_1&gt;&gt;;
 917         };
 918     }
 919 #else
 920   namespace detail
 921   {
 922       template &lt;typename Sequence, typename Predicate&gt;
 923       struct none_impl : bool_&lt;true&gt;{};
 924       template &lt;template &lt;class...&gt; class Sequence, typename Predicate, typename T, typename... Ts&gt;
 925       struct none_impl&lt;Sequence&lt;T,Ts...&gt;, Predicate&gt;
 926       {
 927           static constexpr all_same tester{ static_cast&lt;::brigand::apply&lt;Predicate, T&gt; *&gt;(nullptr),
 928               static_cast&lt;::brigand::apply&lt;Predicate, Ts&gt; *&gt;(nullptr)... };
 929           using type = bool_&lt;(::brigand::apply&lt;Predicate, T&gt;::value == 0 &amp;&amp; tester.value)&gt;;
 930       };
 931       template &lt;template &lt;class...&gt; class Sequence, template &lt;typename...&gt; class F, typename T,
 932           typename... Ts&gt;
 933           struct none_impl&lt;Sequence&lt;T, Ts...&gt;, bind&lt;F, _1&gt;&gt;
 934       {
 935           static constexpr all_same tester{ static_cast&lt;F&lt;T&gt; *&gt;(nullptr),
 936               static_cast&lt;F&lt;Ts&gt; *&gt;(nullptr)... };
 937           using type = bool_&lt;(F&lt;T&gt;::value == 0 &amp;&amp; tester.value)&gt;;
 938       };
 939       template &lt;template &lt;class...&gt; class Sequence, template &lt;typename...&gt; class F, typename T,
 940           typename... Ts&gt;
 941           struct none_impl&lt;Sequence&lt;T, Ts...&gt;, F&lt;_1&gt;&gt;
 942       {
 943           static constexpr all_same tester{ static_cast&lt;typename F&lt;T&gt;::type *&gt;(nullptr),
 944               static_cast&lt;typename F&lt;Ts&gt;::type *&gt;(nullptr)... };
 945           using type = bool_&lt;(F&lt;T&gt;::type::value == 0 &amp;&amp; tester.value)&gt;;
 946       };
 947   }
 948 #endif
 949   template&lt; typename Sequence, typename Predicate = detail::non_null&gt;
 950   using none = typename detail::none_impl&lt;Sequence,Predicate&gt;::type;
 951 }
 952 namespace brigand
 953 {
 954   namespace detail
 955   {
 956     template&lt; typename Sequence, typename Predicate &gt;
 957     struct any_impl : bool_&lt;!none&lt;Sequence,Predicate&gt;::value&gt; {};
 958   }
 959   template&lt;typename Sequence, typename Predicate = detail::non_null&gt;
 960   using any = typename detail::any_impl&lt;Sequence,Predicate&gt;::type;
 961 }
 962 namespace brigand
 963 {
 964 namespace detail
 965 {
 966     template &lt;template &lt;typename...&gt; class S, template &lt;typename...&gt; class F, typename... Ts&gt;
 967     struct finder
 968     {
 969         template &lt;typename T&gt;
 970         using P = F&lt;Ts..., T&gt;;
 971         template &lt;bool InNext8, bool Match, typename... Ls&gt;
 972         struct find
 973         {
 974             using type = S&lt;&gt;;
 975         };
 976         template &lt;typename L&gt;
 977         struct find&lt;true, false, L&gt;
 978         {
 979             using type = S&lt;&gt;;
 980         };
 981         template &lt;typename L, typename... Ls&gt;
 982         struct find&lt;true, true, L, Ls...&gt;
 983         {
 984             using type = S&lt;L, Ls...&gt;;
 985         };
 986         template &lt;typename L1, typename L2, typename... Ls&gt;
 987         struct find&lt;true, false, L1, L2, Ls...&gt; : find&lt;true, F&lt;Ts..., L2&gt;::value, L2, Ls...&gt;
 988         {
 989         };
 990         template &lt;typename L0, typename L1, typename L2, typename L3, typename L4, typename L5,
 991                   typename L6, typename L7, typename L8,
 992                   typename... Ls&gt;
 993         struct find&lt;false, false, L0, L1, L2, L3, L4, L5, L6, L7, L8, Ls...&gt;
 994             : find&lt;true, F&lt;Ts..., L8&gt;::value, L8, Ls...&gt;
 995         {
 996         };
 997         template &lt;typename L1, typename L2, typename L3, typename L4, typename L5, typename L6,
 998                   typename L7, typename L8, typename L9, typename L10, typename L11, typename L12,
 999                   typename L13, typename L14, typename L15, typename L16,
1000                   typename... Ls&gt;
1001         struct find&lt;false, false, L1, L2, L3, L4, L5, L6, L7, L8, L9, L10, L11, L12, L13, L14, L15,
1002                     L16, Ls...&gt;
1003             : find&lt;(P&lt;L9&gt;::value || P&lt;L10&gt;::value || P&lt;L11&gt;::value || P&lt;L12&gt;::value ||
1004                     P&lt;L13&gt;::value || P&lt;L14&gt;::value || P&lt;L15&gt;::value || P&lt;L16&gt;::value),
1005                    P&lt;L9&gt;::value, L9, L10, L11, L12, L13, L14, L15, L16, Ls...&gt;
1006         {
1007         };
1008     };
1009 }
1010 }
1011 namespace brigand
1012 {
1013 namespace detail
1014 {
1015     template &lt;template&lt;class...&gt; class L, class...&gt;
1016     struct reverse_elements;
1017     template &lt;template &lt;class...&gt; class L&gt;
1018     struct reverse_elements&lt;L&gt;
1019     {
1020         using type = L&lt;&gt;;
1021     };
1022     template &lt;template &lt;class...&gt; class L, class T0, class... Ts&gt;
1023     struct reverse_elements&lt;L, T0, Ts...&gt;
1024     : append_impl&lt;typename reverse_elements&lt;L, Ts...&gt;::type, L&lt;T0&gt;&gt;
1025     {
1026     };
1027     template &lt;template &lt;class...&gt; class L, class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13, class T14, class T15, class... Ts&gt;
1028     struct reverse_elements&lt;L, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, Ts...&gt;
1029     : append_impl&lt;typename reverse_elements&lt;L, Ts...&gt;::type, L&lt;T15, T14, T13, T12, T11, T10, T9, T8, T7, T6, T5, T4, T3, T2, T1, T0&gt;&gt;
1030     {
1031     };
1032     template&lt;class L&gt;
1033     struct reverse_impl;
1034     template&lt;template&lt;class...&gt; class L, class... U&gt;
1035     struct reverse_impl&lt;L&lt;U...&gt;&gt;
1036     : reverse_elements&lt;L, U...&gt;
1037     {
1038     };
1039 }
1040 namespace lazy
1041 {
1042     template &lt;typename L&gt;
1043     using reverse = typename detail::reverse_impl&lt;L&gt;;
1044 }
1045     template &lt;typename L&gt;
1046     using reverse = typename detail::reverse_impl&lt;L&gt;::type;
1047 }
1048 namespace brigand
1049 {
1050 namespace lazy
1051 {
1052     template &lt;typename Sequence, typename Predicate = ::brigand::detail::non_null&gt;
1053     struct find;
1054     template &lt;template &lt;typename...&gt; class Sequence, typename... Ls, typename Pred&gt;
1055     struct find&lt;Sequence&lt;Ls...&gt;, Pred&gt;
1056         : detail::finder&lt;Sequence, detail::bound_apply, Pred&gt;::template find&lt;
1057               false, false, void, void, void, void, void, void, void, void, Ls...&gt;
1058     {
1059     };
1060     template &lt;template &lt;typename...&gt; class Sequence, typename... Ls, template &lt;typename...&gt; class F&gt;
1061     struct find&lt;Sequence&lt;Ls...&gt;, bind&lt;F, _1&gt;&gt;
1062         : detail::finder&lt;Sequence, F&gt;::template find&lt;false, false, void, void, void, void, void,
1063                                                      void, void, void, Ls...&gt;
1064     {
1065     };
1066 }
1067 template &lt;typename Sequence, typename Predicate = brigand::detail::non_null&gt;
1068 using find = typename lazy::find&lt;Sequence, Predicate&gt;::type;
1069 namespace lazy
1070 {
1071     template &lt;typename Sequence, typename Predicate = detail::non_null&gt;
1072     using reverse_find =
1073         ::brigand::lazy::reverse&lt;::brigand::find&lt;brigand::reverse&lt;Sequence&gt;, Predicate&gt;&gt;;
1074 }
1075 template &lt;typename Sequence, typename Predicate = detail::non_null&gt;
1076 using reverse_find = typename ::brigand::lazy::reverse_find&lt;Sequence, Predicate&gt;::type;
1077 namespace detail
1078 {
1079     template &lt;typename Sequence, typename Predicate&gt;
1080     using find_size = size&lt;brigand::find&lt;Sequence, Predicate&gt;&gt;;
1081     template &lt;typename Sequence, typename Predicate&gt;
1082     using empty_find = bool_&lt;find_size&lt;Sequence, Predicate&gt;::value == 0&gt;;
1083     template &lt;typename Sequence, typename Predicate&gt;
1084     using non_empty_find = bool_&lt;find_size&lt;Sequence, Predicate&gt;::value != 0&gt;;
1085 }
1086 template &lt;typename Sequence, typename Predicate = detail::non_null&gt;
1087 using not_found = typename detail::empty_find&lt;Sequence, Predicate&gt;;
1088 template &lt;typename Sequence, typename Predicate = detail::non_null&gt;
1089 using found = typename detail::non_empty_find&lt;Sequence, Predicate&gt;;
1090 }
1091 namespace brigand
1092 {
1093 namespace detail
1094 {
1095     template &lt;class L&gt;
1096     struct flatten_impl
1097     {
1098         using type = L;
1099     };
1100     template &lt;template&lt;class...&gt; class L, class T&gt;
1101     struct flatten_element_impl
1102     {
1103         using type = L&lt;T&gt;;
1104     };
1105     template &lt;template&lt;class...&gt; class L, class... Ts&gt;
1106     struct flatten_element_impl&lt;L, L&lt;Ts...&gt;&gt;
1107     : append_impl&lt;typename flatten_element_impl&lt;L, Ts&gt;::type...&gt;
1108     {
1109     };
1110     template &lt;template&lt;class...&gt; class L, class... Ts&gt;
1111     struct flatten_impl&lt;L&lt;Ts...&gt;&gt;
1112     : flatten_element_impl&lt;L, L&lt;Ts...&gt;&gt;
1113     {
1114     };
1115 }
1116 namespace lazy
1117 {
1118     template &lt;typename Sequence&gt;
1119     using flatten = typename detail::flatten_impl&lt;Sequence&gt;;
1120 }
1121 template &lt;typename Sequence&gt;
1122 using flatten = typename lazy::flatten&lt;Sequence&gt;::type;
1123 }
1124 namespace brigand { namespace detail
1125 {
1126   template&lt;class Functor, class State, class Sequence&gt;
1127   struct fold_impl
1128   {
1129       using type = State;
1130   };
1131   template&lt;
1132       class Functor, class State, template &lt;class...&gt; class Sequence,
1133       class T0&gt;
1134   struct fold_impl&lt;Functor, State, Sequence&lt;T0&gt;&gt;
1135   {
1136       using type = brigand::apply&lt;Functor, State, T0&gt;;
1137   };
1138   template&lt;
1139       class Functor, class State, template &lt;class...&gt; class Sequence,
1140       class T0, class T1&gt;
1141   struct fold_impl&lt;Functor, State, Sequence&lt;T0, T1&gt;&gt;
1142   {
1143       using type = brigand::apply&lt;Functor,
1144           brigand::apply&lt;Functor,State, T0&gt;, T1
1145       &gt;;
1146   };
1147   template&lt;
1148       class Functor, class State, template &lt;class...&gt; class Sequence,
1149       class T0, class T1, class T2&gt;
1150   struct fold_impl&lt;Functor, State, Sequence&lt;T0, T1, T2&gt;&gt;
1151   {
1152       using type = brigand::apply&lt;Functor,
1153           brigand::apply&lt;Functor,
1154               brigand::apply&lt;Functor, State, T0&gt;, T1
1155           &gt;, T2
1156       &gt;;
1157   };
1158   template&lt;
1159       class Functor, class State, template &lt;class...&gt; class Sequence,
1160       class T0, class T1, class T2, class T3&gt;
1161   struct fold_impl&lt;Functor, State, Sequence&lt;T0, T1, T2, T3&gt;&gt;
1162   {
1163       using type = brigand::apply&lt;Functor,
1164           brigand::apply&lt;Functor,
1165               brigand::apply&lt;Functor,
1166                   brigand::apply&lt;Functor, State, T0&gt;, T1
1167               &gt;, T2
1168           &gt;, T3
1169       &gt;;
1170   };
1171   template&lt;
1172       class Functor, class State, template &lt;class...&gt; class Sequence,
1173       class T0, class T1, class T2, class T3, class T4&gt;
1174   struct fold_impl&lt;Functor, State, Sequence&lt;T0, T1, T2, T3, T4&gt;&gt;
1175   {
1176       using type = brigand::apply&lt;Functor,
1177           brigand::apply&lt;Functor,
1178               brigand::apply&lt;Functor,
1179                   brigand::apply&lt;Functor,
1180                       brigand::apply&lt;Functor, State, T0&gt;, T1
1181                   &gt;, T2
1182               &gt;, T3
1183           &gt;, T4
1184       &gt;;
1185   };
1186   template&lt;
1187       class Functor, class State, template &lt;class...&gt; class Sequence,
1188       class T0, class T1, class T2, class T3, class T4, class T5&gt;
1189   struct fold_impl&lt;Functor, State, Sequence&lt;T0, T1, T2, T3, T4, T5&gt;&gt;
1190   {
1191       using type = brigand::apply&lt;Functor,
1192           brigand::apply&lt;Functor,
1193               brigand::apply&lt;Functor,
1194                   brigand::apply&lt;Functor,
1195                       brigand::apply&lt;Functor,
1196                           brigand::apply&lt;Functor, State, T0&gt;, T1
1197                       &gt;, T2
1198                   &gt;, T3
1199               &gt;, T4
1200           &gt;, T5
1201       &gt;;
1202   };
1203   template&lt;
1204       class Functor, class State, template &lt;class...&gt; class Sequence,
1205       class T0, class T1, class T2, class T3, class T4, class T5, class T6&gt;
1206   struct fold_impl&lt;Functor, State, Sequence&lt;T0, T1, T2, T3, T4, T5, T6&gt;&gt;
1207   {
1208       using type = brigand::apply&lt;Functor,
1209           brigand::apply&lt;Functor,
1210               brigand::apply&lt;Functor,
1211                   brigand::apply&lt;Functor,
1212                       brigand::apply&lt;Functor,
1213                           brigand::apply&lt;Functor,
1214                               brigand::apply&lt;Functor, State, T0&gt;, T1
1215                           &gt;, T2
1216                       &gt;, T3
1217                   &gt;, T4
1218               &gt;, T5
1219           &gt;, T6
1220       &gt;;
1221   };
1222   template&lt;
1223       class Functor, class State, template &lt;class...&gt; class Sequence,
1224       class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7&gt;
1225   struct fold_impl&lt;Functor, State, Sequence&lt;T0, T1, T2, T3, T4, T5, T6, T7&gt;&gt;
1226   {
1227       using type = brigand::apply&lt;Functor,
1228           brigand::apply&lt;Functor,
1229               brigand::apply&lt;Functor,
1230                   brigand::apply&lt;Functor,
1231                       brigand::apply&lt;Functor,
1232                           brigand::apply&lt;Functor,
1233                               brigand::apply&lt;Functor,
1234                                   brigand::apply&lt;Functor, State, T0&gt;, T1
1235                               &gt;, T2
1236                           &gt;, T3
1237                       &gt;, T4
1238                   &gt;, T5
1239               &gt;, T6
1240           &gt;, T7
1241       &gt;;
1242   };
1243   template&lt;
1244       class Functor, class State, template &lt;class...&gt; class Sequence,
1245       class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class... T&gt;
1246   struct fold_impl&lt;Functor, State, Sequence&lt;T0, T1, T2, T3, T4, T5, T6, T7, T...&gt;&gt;
1247   : fold_impl&lt;
1248       Functor,
1249       brigand::apply&lt;Functor,
1250           brigand::apply&lt;Functor,
1251               brigand::apply&lt;Functor,
1252                   brigand::apply&lt;Functor,
1253                       brigand::apply&lt;Functor,
1254                           brigand::apply&lt;Functor,
1255                               brigand::apply&lt;Functor,
1256                                   brigand::apply&lt;Functor,
1257                                       State, T0
1258                                   &gt;, T1
1259                               &gt;, T2
1260                           &gt;, T3
1261                       &gt;, T4
1262                   &gt;, T5
1263               &gt;, T6
1264           &gt;, T7
1265       &gt;,
1266       Sequence&lt;T...&gt;
1267   &gt;
1268   {};
1269   template&lt;typename Functor, typename State, typename Sequence&gt;
1270   struct reverse_fold_impl
1271   {
1272     using type = State;
1273   };
1274   template &lt;typename Functor, typename State, template &lt;typename...&gt; class L, typename T, typename... Ts&gt;
1275   struct reverse_fold_impl&lt;Functor, State, L&lt;T, Ts...&gt;&gt;
1276   {
1277       using type =
1278           brigand::apply&lt;Functor, typename reverse_fold_impl&lt;Functor, State, L&lt;Ts...&gt;&gt;::type, T&gt;;
1279   };
1280   template&lt;
1281     typename Functor, typename State, template &lt;typename...&gt; class L,
1282     typename T0, typename T1, typename T2, typename T3, typename T4, typename T5, typename T6, typename T7, typename... Ts&gt;
1283     struct reverse_fold_impl&lt;Functor, State, L&lt;T0, T1, T2, T3, T4, T5, T6, T7, Ts...&gt;&gt;{
1284     using type = brigand::apply&lt;Functor,
1285       brigand::apply&lt;Functor,
1286       brigand::apply&lt;Functor,
1287       brigand::apply&lt;Functor,
1288       brigand::apply&lt;Functor,
1289       brigand::apply&lt;Functor,
1290       brigand::apply&lt;Functor,
1291       brigand::apply&lt;Functor,
1292       typename reverse_fold_impl&lt;Functor, State, L&lt;Ts...&gt;&gt;::type, T7
1293       &gt;, T6
1294       &gt;, T5
1295       &gt;, T4
1296       &gt;, T3
1297       &gt;, T2
1298       &gt;, T1
1299       &gt;, T0
1300       &gt;;
1301   };
1302 } }
1303 namespace brigand
1304 {
1305 namespace lazy
1306 {
1307     template &lt;class Sequence, class State, class Functor&gt;
1308     using fold = typename detail::fold_impl&lt;Functor, State, Sequence&gt;;
1309     template &lt;class Sequence, class State, class Functor&gt;
1310     using reverse_fold = typename detail::reverse_fold_impl&lt;Functor, State, Sequence&gt;;
1311 }
1312 template &lt;class Sequence, class State, class Functor&gt;
1313 using fold = typename ::brigand::lazy::fold&lt;Sequence, State, Functor&gt;::type;
1314 template &lt;class Sequence, class State, class Functor&gt;
1315 using reverse_fold = typename ::brigand::lazy::reverse_fold&lt;Sequence, State, Functor&gt;::type;
1316 }
1317 namespace brigand
1318 {
1319   template&lt;class F, class...Ts&gt; F for_each_args(F f, Ts&amp;&amp;...a)
1320   {
1321     return (void)std::initializer_list&lt;int&gt;{((void)std::ref(f)(static_cast&lt;Ts&amp;&amp;&gt;(a)),0)...}, f;
1322   }
1323 }
1324 namespace brigand
1325 {
1326   namespace detail
1327   {
1328     template&lt;template&lt;class...&gt; class List, typename... Elements, typename Functor&gt;
1329     Functor for_each_impl( List&lt;Elements...&gt;&amp;&amp;, Functor f )
1330     {
1331       return for_each_args( f, type_&lt;Elements&gt;()... );
1332     }
1333   }
1334   template&lt;typename List, typename Functor&gt; Functor for_each( Functor f )
1335   {
1336     return detail::for_each_impl( List{}, f );
1337   }
1338 }
1339 namespace brigand
1340 {
1341 namespace detail
1342 {
1343     template &lt;bool Found, class Sequence, typename Predicate, typename NotFoundType&gt;
1344     struct index_if_impl
1345     {
1346         using type = ::brigand::size_t&lt;size&lt;Sequence&gt;::value -
1347                                        size&lt;::brigand::find&lt;Sequence, Predicate&gt;&gt;::value&gt;;
1348     };
1349     template &lt;class Sequence, typename Predicate, typename NotFoundType&gt;
1350     struct index_if_impl&lt;false, Sequence, Predicate, NotFoundType&gt;
1351     {
1352         using type = NotFoundType;
1353     };
1354 }
1355 template &lt;class Sequence, class Predicate, class NotFoundType = no_such_type_&gt;
1356 using index_if = typename detail::index_if_impl&lt;::brigand::found&lt;Sequence, Predicate&gt;::value,
1357                                                 Sequence, Predicate, NotFoundType&gt;::type;
1358 template &lt;class Sequence, typename T&gt;
1359 using index_of = index_if&lt;Sequence, std::is_same&lt;T, ::brigand::_1&gt;&gt;;
1360 }
1361 
1362 namespace brigand
1363 {
1364   namespace detail
1365   {
1366     template&lt;class T, class, class, T&gt;
1367     struct range_cat;
1368 #ifdef BRIGAND_COMP_MSVC
1369     template&lt;class T, T Start, T Int&gt;
1370     struct int_plus
1371     {
1372       using type = std::integral_constant&lt;T, Start + Int&gt;;
1373     };
1374 #endif
1375     template&lt;class T, class... Ts, T... Ints, T Start&gt;
1376     struct range_cat&lt;T, list&lt;Ts...&gt;, list&lt;std::integral_constant&lt;T, Ints&gt;...&gt;, Start&gt;
1377     {
1378 #ifdef BRIGAND_COMP_MSVC
1379       using type = list&lt;Ts..., typename int_plus&lt;T, Start, Ints&gt;::type...&gt;;
1380 #else
1381       using type = list&lt;Ts..., std::integral_constant&lt;T, Start + Ints&gt;...&gt;;
1382 #endif
1383     };
1384     template&lt;class T, T Start, std::size_t N&gt;
1385     struct range_impl
1386     : range_cat&lt;
1387       T,
1388       typename range_impl&lt;T, Start, N/2&gt;::type,
1389       typename range_impl&lt;T, Start, N - N/2&gt;::type,
1390       N/2
1391     &gt;
1392     {};
1393     template&lt;class T, T Start&gt;
1394     struct range_impl&lt;T, Start, 1&gt;
1395     {
1396       using type = list&lt;std::integral_constant&lt;T, Start&gt;&gt;;
1397     };
1398     template&lt;class T, T Start&gt;
1399     struct range_impl&lt;T, Start, 0&gt;
1400     {
1401       using type = list&lt;&gt;;
1402     };
1403     template&lt;class T, class, class, T&gt;
1404     struct reverse_range_cat;
1405 #ifdef BRIGAND_COMP_MSVC
1406     template&lt;class T, T Start, T Int&gt;
1407     struct int_minus
1408     {
1409       using type = std::integral_constant&lt;T, Int - Start&gt;;
1410     };
1411 #endif
1412     template&lt;class T, class... Ts, T... Ints, T Start&gt;
1413     struct reverse_range_cat&lt;T, list&lt;Ts...&gt;, list&lt;std::integral_constant&lt;T, Ints&gt;...&gt;, Start&gt;
1414     {
1415 #ifdef BRIGAND_COMP_MSVC
1416       using type = list&lt;Ts..., typename int_minus&lt;T, Start, Ints&gt;::type...&gt;;
1417 #else
1418       using type = list&lt;Ts..., std::integral_constant&lt;T, Ints - Start&gt;...&gt;;
1419 #endif
1420     };
1421     template&lt;class T, T Start, std::size_t N&gt;
1422     struct reverse_range_impl
1423     : reverse_range_cat&lt;
1424       T,
1425       typename reverse_range_impl&lt;T, Start, N/2&gt;::type,
1426       typename reverse_range_impl&lt;T, Start, N - N/2&gt;::type,
1427       N/2
1428     &gt;
1429     {
1430     };
1431     template&lt;class T, T Start&gt;
1432     struct reverse_range_impl&lt;T, Start, 1&gt;
1433     {
1434       using type = list&lt;std::integral_constant&lt;T, Start&gt;&gt;;
1435     };
1436     template&lt;class T, T Start&gt;
1437     struct reverse_range_impl&lt;T, Start, 0&gt;
1438     {
1439       using type = list&lt;&gt;;
1440     };
1441     template &lt;class T, T Start, T Stop&gt;
1442     struct reverse_range_safe
1443     {
1444         static_assert(Start &gt;= Stop, &quot;Invalid parameters. reverse_range&lt;&gt; syntax is reverse_range&lt;type, from, down_to&gt;&quot;);
1445         using type = typename reverse_range_impl&lt;T, Start, Start-Stop&gt;::type;
1446     };
1447   }
1448   template&lt;class T, T Start, T Stop&gt;
1449   using range = typename detail::range_impl&lt;T, Start, Stop-Start&gt;::type;
1450   template&lt;class T, T Start, T Stop&gt;
1451   using reverse_range = typename detail::reverse_range_safe&lt;T, Start, Stop&gt;::type;
1452 }
1453 namespace brigand
1454 {
1455 namespace detail
1456 {
1457   template&lt;class, class T&gt; struct unique_x_t
1458   { operator type_&lt;T&gt; (); };
1459   template&lt;class Ints, class... Ts&gt;
1460   struct is_set_impl;
1461   template&lt;&gt;
1462   struct is_set_impl&lt;list&lt;&gt;&gt;
1463   {
1464     using type = std::true_type;
1465   };
1466   inline std::true_type true_fn(...);
1467   template&lt;class... Ints, class... Ts&gt;
1468   struct is_set_impl&lt;list&lt;Ints...&gt;, Ts...&gt;
1469   {
1470     struct Pack : unique_x_t&lt;Ints, Ts&gt;... {};
1471     template&lt;class... Us&gt;
1472     static auto is_set(Us...) -&gt; decltype(true_fn(static_cast&lt;Us&gt;(Pack())...));
1473     static std::false_type is_set(...);
1474     using type = decltype(is_set(type_&lt;Ts&gt;()...));
1475   };
1476 }
1477   template&lt;class... Ts&gt;
1478   using is_set = typename detail::is_set_impl&lt;range&lt;int, 0, sizeof...(Ts)&gt;, Ts...&gt;::type;
1479 }
1480 
1481 namespace brigand
1482 {
1483 #if defined(BRIGAND_COMP_GCC) || defined(BRIGAND_COMP_CLANG)
1484     namespace lazy
1485     {
1486         template &lt;typename L, typename Pred&gt;
1487         struct remove_if;
1488         template &lt;template &lt;class...&gt; class L, typename... Ts, typename Pred&gt;
1489         struct remove_if&lt;L&lt;Ts...&gt;, Pred&gt;
1490             : ::brigand::detail::append_impl&lt;
1491             L&lt;&gt;, typename std::conditional&lt;::brigand::apply&lt;Pred, Ts&gt;::value, list&lt;&gt;, list&lt;Ts&gt;&gt;::type...&gt;
1492         {
1493         };
1494         template &lt;template &lt;class...&gt; class L, typename... Ts, template&lt;typename...&gt; class F&gt;
1495         struct remove_if&lt;L&lt;Ts...&gt;, bind&lt;F,_1&gt;&gt;
1496             : ::brigand::detail::append_impl&lt;
1497             L&lt;&gt;, typename std::conditional&lt;F&lt;Ts&gt;::value, list&lt;&gt;, list&lt;Ts&gt;&gt;::type...&gt;
1498         {
1499         };
1500         template &lt;template &lt;class...&gt; class L, typename... Ts, template&lt;typename...&gt; class F&gt;
1501         struct remove_if&lt;L&lt;Ts...&gt;, F&lt;_1&gt;&gt;
1502             : ::brigand::detail::append_impl&lt;
1503             L&lt;&gt;, typename std::conditional&lt;F&lt;Ts&gt;::type::value, list&lt;&gt;, list&lt;Ts&gt;&gt;::type...&gt;
1504         {
1505         };
1506     }
1507     namespace lazy
1508     {
1509         template &lt;typename L, typename T&gt;
1510         struct remove;
1511         template &lt;template &lt;class...&gt; class L, typename... Ts, typename T&gt;
1512         struct remove&lt;L&lt;Ts...&gt;, T&gt;
1513             : ::brigand::detail::append_impl&lt;
1514             L&lt;&gt;, typename std::conditional&lt;std::is_same&lt;Ts, T&gt;::value, list&lt;&gt;, list&lt;Ts&gt;&gt;::type...&gt;
1515         {
1516         };
1517     }
1518     namespace lazy
1519     {
1520         template &lt;typename L, typename Pred&gt;
1521         struct filter;
1522         template &lt;template &lt;class...&gt; class L, typename... Ts, typename Pred&gt;
1523         struct filter&lt;L&lt;Ts...&gt;, Pred&gt;
1524             : ::brigand::detail::append_impl&lt;
1525             L&lt;&gt;, typename std::conditional&lt;::brigand::apply&lt;Pred, Ts&gt;::value, list&lt;Ts&gt;, list&lt;&gt;&gt;::type...&gt;
1526         {
1527         };
1528         template &lt;template &lt;class...&gt; class L, typename... Ts, template&lt;typename...&gt; class F&gt;
1529         struct filter&lt;L&lt;Ts...&gt;, bind&lt;F, _1&gt;&gt;
1530             : ::brigand::detail::append_impl&lt;
1531             L&lt;&gt;, typename std::conditional&lt;F&lt;Ts&gt;::value, list&lt;Ts&gt;, list&lt;&gt;&gt;::type...&gt;
1532         {
1533         };
1534         template &lt;template &lt;class...&gt; class L, typename... Ts, template&lt;typename...&gt; class F&gt;
1535         struct filter&lt;L&lt;Ts...&gt;, F&lt;_1&gt;&gt;
1536             : ::brigand::detail::append_impl&lt;
1537             L&lt;&gt;, typename std::conditional&lt;F&lt;Ts&gt;::type::value, list&lt;Ts&gt;, list&lt;&gt;&gt;::type...&gt;
1538         {
1539         };
1540     }
1541 #else
1542 namespace detail
1543 {
1544     template &lt;typename Pred, typename T, bool B&gt;
1545     struct empty_if_true : std::conditional&lt;::brigand::apply&lt;Pred, T&gt;::value == B, list&lt;&gt;, list&lt;T&gt;&gt;
1546     {
1547     };
1548     template &lt;template &lt;typename...&gt; class F, typename T, bool B&gt;
1549     struct empty_if_true&lt;bind&lt;F, _1&gt;, T, B&gt; : std::conditional&lt;F&lt;T&gt;::value == B, list&lt;&gt;, list&lt;T&gt;&gt;
1550     {
1551     };
1552     template &lt;template &lt;typename...&gt; class F, typename T, bool B&gt;
1553     struct empty_if_true&lt;F&lt;_1&gt;, T, B&gt; : std::conditional&lt;F&lt;T&gt;::type::value == B, list&lt;&gt;, list&lt;T&gt;&gt;
1554     {
1555     };
1556 }
1557 namespace lazy
1558 {
1559     template &lt;typename L, typename Pred&gt;
1560     struct remove_if;
1561     template &lt;template &lt;class...&gt; class L, typename... Ts, typename Pred&gt;
1562     struct remove_if&lt;L&lt;Ts...&gt;, Pred&gt;
1563         : ::brigand::detail::append_impl&lt;
1564               L&lt;&gt;, typename ::brigand::detail::empty_if_true&lt;Pred, Ts, true&gt;::type...&gt;
1565     {
1566     };
1567 }
1568 namespace lazy
1569 {
1570     template &lt;typename L, typename T&gt;
1571     struct remove;
1572     template &lt;template &lt;class...&gt; class L, typename... Ts, typename T&gt;
1573     struct remove&lt;L&lt;Ts...&gt;, T&gt;
1574         : ::brigand::detail::append_impl&lt;
1575               L&lt;&gt;, typename std::conditional&lt;std::is_same&lt;Ts, T&gt;::value, list&lt;&gt;, list&lt;Ts&gt;&gt;::type...&gt;
1576     {
1577     };
1578 }
1579 namespace lazy
1580 {
1581     template &lt;typename L, typename Pred&gt;
1582     struct filter;
1583     template &lt;template &lt;class...&gt; class L, typename... Ts, typename Pred&gt;
1584     struct filter&lt;L&lt;Ts...&gt;, Pred&gt;
1585         : ::brigand::detail::append_impl&lt;
1586               L&lt;&gt;, typename ::brigand::detail::empty_if_true&lt;Pred, Ts, false&gt;::type...&gt;
1587     {
1588     };
1589 }
1590 #endif
1591 template &lt;typename L, typename Pred&gt;
1592 using remove_if = typename lazy::remove_if&lt;L, Pred&gt;::type;
1593 template &lt;typename L, typename T&gt;
1594 using remove = typename lazy::remove&lt;L, T&gt;::type;
1595 template &lt;typename L, typename Pred&gt;
1596 using filter = typename lazy::filter&lt;L, Pred&gt;::type;
1597 }
1598 namespace brigand
1599 {
1600 template &lt;class Seq, class Pred&gt;
1601 using partition = pair&lt;filter&lt;Seq, Pred&gt;, remove_if&lt;Seq, Pred&gt;&gt;;
1602 }
1603 
1604 namespace brigand
1605 {
1606     namespace detail
1607     {
1608         template &lt;typename T, typename Pred, typename NewType&gt;
1609         struct replacer : std::conditional&lt;::brigand::apply&lt;Pred, T&gt;::value, NewType, T&gt;
1610         {
1611         };
1612         template &lt;typename T, template &lt;typename...&gt; class F, typename NewType&gt;
1613         struct replacer&lt;T, bind&lt;F, _1&gt;, NewType&gt; : std::conditional&lt;F&lt;T&gt;::value, NewType, T&gt;
1614         {
1615         };
1616         template &lt;typename T, template &lt;typename...&gt; class F, typename NewType&gt;
1617         struct replacer&lt;T, F&lt;_1&gt;, NewType&gt; : std::conditional&lt;F&lt;T&gt;::type::value, NewType, T&gt;
1618         {
1619         };
1620     }
1621 namespace lazy
1622 {
1623     template &lt;typename Sequence, typename Predicate, typename NewType&gt;
1624     struct replace_if;
1625     template &lt;template &lt;typename...&gt; class S, typename... Ts, typename Predicate, typename NewType&gt;
1626     struct replace_if&lt;S&lt;Ts...&gt;, Predicate, NewType&gt;
1627     {
1628         using type = S&lt;typename detail::replacer&lt;Ts, Predicate, NewType&gt;::type...&gt;;
1629     };
1630     template &lt;typename Sequence, typename OldType, typename NewType&gt;
1631     using replace = replace_if&lt;Sequence, std::is_same&lt;_1, pin&lt;OldType&gt;&gt;, NewType&gt;;
1632 }
1633 template &lt;typename Sequence, typename Predicate, typename NewType&gt;
1634 using replace_if = typename ::brigand::lazy::replace_if&lt;Sequence, Predicate, NewType&gt;::type;
1635 template &lt;typename Sequence, typename OldType, typename NewType&gt;
1636 using replace = typename ::brigand::lazy::replace&lt;Sequence, OldType, NewType&gt;::type;
1637 }
1638 
1639 namespace brigand
1640 {
1641   template&lt;typename C, typename T, typename F&gt;
1642   inline typename std::enable_if&lt;C::value,T&amp;&amp;&gt;::type select(T&amp;&amp; t, F&amp;&amp;)
1643   {
1644     return std::forward&lt;T&gt;(t);
1645   }
1646   template&lt;typename C, typename T, typename F&gt;
1647   inline typename std::enable_if&lt;!C::value,F&amp;&amp;&gt;::type select(T&amp;&amp;, F&amp;&amp; f)
1648   {
1649     return std::forward&lt;F&gt;(f);
1650   }
1651 }
1652 namespace brigand
1653 {
1654 namespace detail
1655 {
1656     template&lt;typename TOut, typename TCurrent, typename TDelim, typename... Ts&gt;
1657     struct split_impl;
1658     template&lt;template&lt;typename...&gt; class L, typename... Os, typename... Cs, typename TDelim, typename T, typename... Ts&gt;
1659     struct split_impl&lt;L&lt;Os...&gt;, L&lt;Cs...&gt;, TDelim, T, Ts...&gt; :
1660         split_impl&lt;L&lt;Os...&gt;, L&lt;Cs..., T&gt;, TDelim, Ts...&gt; {};
1661     template&lt;template&lt;typename...&gt; class L, typename... Os, typename... Cs, typename TDelim, typename T&gt;
1662     struct split_impl&lt;L&lt;Os...&gt;, L&lt;Cs...&gt;, TDelim, T&gt; {
1663         using type = L&lt;Os..., L&lt;Cs..., T&gt;&gt;;
1664     };
1665     template&lt;template&lt;typename...&gt; class L, typename... Os, typename... Cs, typename TDelim, typename... Ts&gt;
1666     struct split_impl&lt;L&lt;Os...&gt;, L&lt;Cs...&gt;, TDelim, TDelim, Ts...&gt; :
1667         split_impl&lt;L&lt;Os..., L&lt;Cs...&gt;&gt;, L&lt;&gt;, TDelim, Ts...&gt; {};
1668     template&lt;template&lt;typename...&gt; class L, typename... Os, typename... Cs, typename TDelim&gt;
1669     struct split_impl&lt;L&lt;Os...&gt;, L&lt;Cs...&gt;, TDelim, TDelim&gt; {
1670         using type = L&lt;Os..., L&lt;Cs...&gt;&gt;;
1671     };
1672     template&lt;template&lt;typename...&gt; class L, typename... Os, typename TDelim, typename... Ts&gt;
1673     struct split_impl&lt;L&lt;Os...&gt;, L&lt;&gt;, TDelim, TDelim, Ts...&gt; :
1674         split_impl&lt;L&lt;Os...&gt;, L&lt;&gt;, TDelim, Ts...&gt; {};
1675     template&lt;template&lt;typename...&gt; class L, typename... Os, typename TDelim&gt;
1676     struct split_impl&lt;L&lt;Os...&gt;, L&lt;&gt;, TDelim, TDelim&gt; {
1677         using type = L&lt;Os...&gt;;
1678     };
1679     template&lt;template&lt;typename...&gt; class L, typename... Os, typename TDelim&gt;
1680     struct split_impl&lt;L&lt;Os...&gt;, L&lt;&gt;, TDelim&gt; {
1681         using type = L&lt;Os...&gt;;
1682     };
1683     template&lt;typename TList, typename TDelim&gt;
1684     struct split_helper;
1685     template&lt;template&lt;typename...&gt; class L, typename T, typename... Ts, typename TDelim&gt;
1686     struct split_helper&lt;L&lt;T,Ts...&gt;, TDelim&gt; : split_impl&lt;L&lt;&gt;, L&lt;&gt;, TDelim, T, Ts...&gt;{};
1687     template&lt;template&lt;typename...&gt; class L, typename... T, typename TDelim&gt;
1688     struct split_helper&lt;L&lt;T...&gt;, TDelim&gt; {
1689         using type = L&lt;&gt;;
1690     };
1691 }
1692 namespace lazy
1693 {
1694     template&lt;typename TList, typename TDelim&gt;
1695     using split = detail::split_helper&lt;TList, TDelim&gt;;
1696 }
1697 template&lt;typename TList, typename TDelim&gt;
1698 using split = typename lazy::split&lt;TList, TDelim&gt;::type;
1699 }
1700 namespace brigand
1701 {
1702   template &lt;typename A, typename B&gt;
1703   struct less : bool_ &lt; (A::value &lt; B::value) &gt; {};
1704 }
1705 
1706 namespace brigand
1707 {
1708   namespace detail
1709   {
1710     template&lt;class L, class Seq1, class Seq2, class Comp&gt;
1711     struct merge_impl;
1712     template&lt;bool, class L, class Seq1, class Seq2, class Comp&gt;
1713     struct merge_insert;
1714     template&lt;class... R, class T0, class T1, class... Ts, class U, class... Us, class Comp&gt;
1715     struct merge_insert&lt;true, list&lt;R...&gt;, list&lt;T0,T1,Ts...&gt;, list&lt;U,Us...&gt;, Comp&gt;
1716     : merge_insert&lt;::brigand::apply&lt;Comp,T1,U&gt;::value, list&lt;R...,T0&gt;, list&lt;T1,Ts...&gt;, list&lt;U,Us...&gt;, Comp&gt;
1717     {};
1718     template&lt;class... R, class T, class U, class... Us, class Comp&gt;
1719     struct merge_insert&lt;true, list&lt;R...&gt;, list&lt;T&gt;, list&lt;U,Us...&gt;, Comp&gt;
1720     {
1721       using list = ::brigand::list&lt;R...,T&gt;;
1722       using left = ::brigand::list&lt;&gt;;
1723       using right = ::brigand::list&lt;U,Us...&gt;;
1724     };
1725     template&lt;class... R, class T, class... Ts, class U0, class U1, class... Us, class Comp&gt;
1726     struct merge_insert&lt;false, list&lt;R...&gt;, list&lt;T,Ts...&gt;, list&lt;U0,U1,Us...&gt;, Comp&gt;
1727     : merge_insert&lt;::brigand::apply&lt;Comp,T,U1&gt;::value, list&lt;R...,U0&gt;, list&lt;T,Ts...&gt;, list&lt;U1,Us...&gt;, Comp&gt;
1728     {};
1729     template&lt;class... R, class T, class... Ts, class U, class Comp&gt;
1730     struct merge_insert&lt;false, list&lt;R...&gt;, list&lt;T,Ts...&gt;, list&lt;U&gt;, Comp&gt;
1731     {
1732       using list = ::brigand::list&lt;R...,U&gt;;
1733       using left = ::brigand::list&lt;T,Ts...&gt;;
1734       using right = ::brigand::list&lt;&gt;;
1735     };
1736     template&lt;
1737       class... R,
1738       class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class... Ts,
1739       class U0, class U1, class U2, class U3, class U4, class U5, class U6, class U7, class U8, class U9, class... Us, class Comp&gt;
1740     struct merge_impl&lt;list&lt;R...&gt;, list&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8,T9,Ts...&gt;, list&lt;U0,U1,U2,U3,U4,U5,U6,U7,U8,U9,Us...&gt;, Comp&gt;
1741     {
1742       using sub = merge_insert&lt;::brigand::apply&lt;Comp,T0,U0&gt;::value, list&lt;&gt;, list&lt;T0,T1,T2,T3,T4,T5,T6,T7,T8,T9&gt;, list&lt;U0,U1,U2,U3,U4,U5,U6,U7,U8,U9&gt;, Comp&gt;;
1743       using type = typename merge_impl&lt;
1744         append&lt;list&lt;R...&gt;, typename sub::list&gt;,
1745         append&lt;typename sub::left, list&lt;Ts...&gt;&gt;,
1746         append&lt;typename sub::right, list&lt;Us...&gt;&gt;,
1747         Comp
1748       &gt;::type;
1749     };
1750     template&lt;class... R, class T, class... Ts, class U, class... Us, class Comp&gt;
1751     struct merge_impl&lt;list&lt;R...&gt;, list&lt;T,Ts...&gt;, list&lt;U,Us...&gt;, Comp&gt;
1752     : std::conditional&lt;
1753         ::brigand::apply&lt;Comp,T,U&gt;::value,
1754         merge_impl&lt;list&lt;R...,T&gt;, list&lt;Ts...&gt;, list&lt;U,Us...&gt;, Comp&gt;,
1755         merge_impl&lt;list&lt;R...,U&gt;, list&lt;T,Ts...&gt;, list&lt;Us...&gt;, Comp&gt;
1756     &gt;::type
1757     {};
1758     template&lt;class... R, class... Ts, class Comp&gt;
1759     struct merge_impl&lt;list&lt;R...&gt;, list&lt;Ts...&gt;, list&lt;&gt;, Comp&gt;
1760     {
1761       using type = list&lt;R..., Ts...&gt;;
1762     };
1763     template&lt;class... R, class... Us, class Comp&gt;
1764     struct merge_impl&lt;list&lt;R...&gt;, list&lt;&gt;, list&lt;Us...&gt;, Comp&gt;
1765     {
1766       using type = list&lt;R..., Us...&gt;;
1767     };
1768     template&lt;class... R, class Comp&gt;
1769     struct merge_impl&lt;list&lt;R...&gt;, list&lt;&gt;, list&lt;&gt;, Comp&gt;
1770     {
1771       using type = list&lt;R...&gt;;
1772     };
1773   }
1774   template&lt;class Seq1, class Seq2, class Comp = less&lt;_1,_2&gt;&gt;
1775   using merge = append&lt;clear&lt;Seq1&gt;, typename detail::merge_impl&lt;list&lt;&gt;, wrap&lt;Seq1, list&gt;, wrap&lt;Seq2, list&gt;, Comp&gt;::type&gt;;
1776 }
1777 namespace brigand
1778 {
1779 namespace detail
1780 {
1781     template &lt;class Ls, class Seq, typename Comp&gt;
1782     struct sort_impl;
1783     template&lt;class L, class Comp&gt;
1784     struct mini_sort;
1785     template&lt;class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class... Ts, class Comp&gt;
1786     struct mini_sort&lt;list&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, Ts...&gt;, Comp&gt;
1787     : merge_impl&lt;
1788       list&lt;&gt;,
1789       typename mini_sort&lt;list&lt;T0, T1, T2, T3, T4, T5, T6, T7&gt;, Comp&gt;::type,
1790       typename mini_sort&lt;list&lt;T8, Ts...&gt;, Comp&gt;::type, Comp&gt;
1791     {};
1792     template&lt;class T0, class T1, class T2, class T3, class T4, class... Ts, class Comp&gt;
1793     struct mini_sort&lt;list&lt;T0, T1, T2, T3, T4, Ts...&gt;, Comp&gt;
1794     : merge_impl&lt;list&lt;&gt;, typename mini_sort&lt;list&lt;T0, T1, T2, T3&gt;, Comp&gt;::type, typename mini_sort&lt;list&lt;T4, Ts...&gt;, Comp&gt;::type, Comp&gt;
1795     {};
1796     template&lt;class T0, class T1, class T2, class T3, class Comp&gt;
1797     struct mini_sort&lt;list&lt;T0, T1, T2, T3&gt;, Comp&gt;
1798     : merge_impl&lt;list&lt;&gt;, typename mini_sort&lt;list&lt;T0, T1&gt;, Comp&gt;::type, typename mini_sort&lt;list&lt;T2, T3&gt;, Comp&gt;::type, Comp&gt;
1799     {};
1800     template&lt;class T0, class T1, class T2, class Comp&gt;
1801     struct mini_sort&lt;list&lt;T0, T1, T2&gt;, Comp&gt;
1802     : merge_impl&lt;list&lt;&gt;, typename mini_sort&lt;list&lt;T0, T1&gt;, Comp&gt;::type, list&lt;T2&gt;, Comp&gt;
1803     {};
1804     template&lt;class T0, class T1, class Comp&gt;
1805     struct mini_sort&lt;list&lt;T0, T1&gt;, Comp&gt;
1806     {
1807       using type = typename std::conditional&lt;::brigand::apply&lt;Comp, T0, T1&gt;::value, list&lt;T0, T1&gt;, list&lt;T1, T0&gt;&gt;::type;
1808     };
1809     template&lt;class T0, class Comp&gt;
1810     struct mini_sort&lt;list&lt;T0&gt;, Comp&gt;
1811     {
1812       using type = list&lt;T0&gt;;
1813     };
1814     template &lt;
1815       class T0, class T1, class T2, class T3, class T4, class T5, class T6,
1816       class T7, class T8, class T9, class T10, class T11, class T12, class T13,
1817       class T14, class T15, class T16, class T17, class... Ts, typename Comp&gt;
1818     struct sort_impl&lt;list&lt;&gt;, list&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, Ts...&gt;, Comp&gt;
1819     : sort_impl&lt;
1820       list&lt;typename mini_sort&lt;list&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17&gt;, Comp&gt;::type&gt;,
1821       list&lt;Ts...&gt;, Comp&gt;
1822     {};
1823     template &lt;
1824       class L0,
1825       class T0, class T1, class T2, class T3, class T4, class T5, class T6,
1826       class T7, class T8, class T9, class T10, class T11, class T12, class T13,
1827       class T14, class T15, class T16, class T17, class... Ts, typename Comp&gt;
1828     struct sort_impl&lt;list&lt;L0&gt;, list&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, Ts...&gt;, Comp&gt;
1829     : sort_impl&lt;
1830       list&lt;L0, typename mini_sort&lt;list&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17&gt;, Comp&gt;::type&gt;,
1831       list&lt;Ts...&gt;, Comp&gt;
1832     {};
1833     template &lt;
1834       class L0, class L1,
1835       class T0, class T1, class T2, class T3, class T4, class T5, class T6,
1836       class T7, class T8, class T9, class T10, class T11, class T12, class T13,
1837       class T14, class T15, class T16, class T17, class... Ts, typename Comp&gt;
1838     struct sort_impl&lt;list&lt;L0,L1&gt;, list&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, Ts...&gt;, Comp&gt;
1839     : sort_impl&lt;
1840       list&lt;L0, L1, typename mini_sort&lt;list&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17&gt;, Comp&gt;::type&gt;,
1841       list&lt;Ts...&gt;, Comp&gt;
1842     {};
1843     template &lt;
1844       class L0, class L1, class L2,
1845       class T0, class T1, class T2, class T3, class T4, class T5, class T6,
1846       class T7, class T8, class T9, class T10, class T11, class T12, class T13,
1847       class T14, class T15, class T16, class T17, class... Ts, typename Comp&gt;
1848     struct sort_impl&lt;list&lt;L0,L1,L2&gt;, list&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, Ts...&gt;, Comp&gt;
1849     : sort_impl&lt;
1850       list&lt;
1851         merge&lt;L0, L1, Comp&gt;,
1852         merge&lt;
1853           typename mini_sort&lt;list&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17&gt;, Comp&gt;::type, L2, Comp&gt;&gt;,
1854       list&lt;Ts...&gt;, Comp&gt;
1855     {};
1856     template &lt;class T, class... Ts, typename Comp&gt;
1857     struct sort_impl&lt;list&lt;&gt;, list&lt;T, Ts...&gt;, Comp&gt;
1858     {
1859       using type = typename mini_sort&lt;list&lt;T, Ts...&gt;, Comp&gt;::type;
1860     };
1861     template &lt;class L, class T, class... Ts, typename Comp&gt;
1862     struct sort_impl&lt;list&lt;L&gt;, list&lt;T, Ts...&gt;, Comp&gt;
1863     {
1864       using type = merge&lt;typename mini_sort&lt;list&lt;T, Ts...&gt;, Comp&gt;::type, L, Comp&gt;;
1865     };
1866     template &lt;class L0, class L1, class T, class... Ts, typename Comp&gt;
1867     struct sort_impl&lt;list&lt;L0, L1&gt;, list&lt;T, Ts...&gt;, Comp&gt;
1868     {
1869       using type = merge&lt;L0, merge&lt;typename mini_sort&lt;list&lt;T, Ts...&gt;, Comp&gt;::type, L1, Comp&gt;, Comp&gt;;
1870     };
1871     template &lt;class L0, class L1, class L2, class T, class... Ts, typename Comp&gt;
1872     struct sort_impl&lt;list&lt;L0, L1, L2&gt;, list&lt;T, Ts...&gt;, Comp&gt;
1873     {
1874       using type = merge&lt;merge&lt;L0, L1, Comp&gt;, merge&lt;typename mini_sort&lt;list&lt;T, Ts...&gt;, Comp&gt;::type, L2, Comp&gt;, Comp&gt;;
1875     };
1876     template &lt;class L, typename Comp&gt;
1877     struct sort_impl&lt;list&lt;L&gt;, list&lt;&gt;, Comp&gt;
1878     {
1879       using type = L;
1880     };
1881     template &lt;class L0, class L1, typename Comp&gt;
1882     struct sort_impl&lt;list&lt;L0, L1&gt;, list&lt;&gt;, Comp&gt;
1883     {
1884       using type = merge&lt;L0,L1,Comp&gt;;
1885     };
1886     template &lt;class L0, class L1, class L2, typename Comp&gt;
1887     struct sort_impl&lt;list&lt;L0,L1,L2&gt;, list&lt;&gt;, Comp&gt;
1888     {
1889       using type = merge&lt;merge&lt;L0,L1,Comp&gt;,L2,Comp&gt;;
1890     };
1891     template &lt;typename Comp&gt;
1892     struct sort_impl&lt;list&lt;&gt;, list&lt;&gt;, Comp&gt;
1893     {
1894       using type = list&lt;&gt;;
1895     };
1896     template &lt;
1897       class T0, class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12,
1898       class T13, class T14, class T15, class T16, class T17, class T18, class T19, class T20, class T21, class T22, class T23, class T24,
1899       class T25, class T26, class T27, class T28, class T29, class T30, class T31, class T32, class T33, class T34, class T35, class T36,
1900       class T37, class T38, class T39, class T40, class T41, class T42, class T43, class T44, class T45, class T46, class T47, class T48,
1901       class T49, class T50, class T51, class T52, class T53, class T54, class T55, class T56, class T57, class T58, class T59, class T60,
1902       class T61, class T62, class T63, class T64, class T65, class T66, class T67, class T68, class T69, class T70, class T71, class T72,
1903       class T73, class T74, class T75, class T76, class T77, class T78, class T79, class T80, class T81, class T82, class T83, class T84,
1904       class T85, class T86, class T87, class T88, class T89, class T90, class T91, class T92, class T93, class T94, class T95, class T96,
1905       class T97, class T98, class T99, class T100, class T101, class T102, class T103, class T104, class T105, class T106, class T107,
1906       class T108, class T109, class T110, class T111, class T112, class T113, class T114, class T115, class T116, class T117, class T118,
1907       class T119, class T120, class T121, class T122, class T123, class T124, class T125, class T126, class T127, class T128, class T129,
1908       class T130, class T131, class T132, class T133, class T134, class T135, class T136, class T137, class T138, class T139, class T140,
1909       class T141, class T142, class T143, class T144, class T145, class T146, class T147, class T148, class T149, class T150, class T151,
1910       class T152, class T153, class T154, class T155, class T156, class T157, class T158, class T159, class T160, class T161, class T162,
1911       class T163, class T164, class T165, class T166, class T167, class T168, class T169, class T170, class T171, class T172, class T173,
1912       class T174, class T175, class T176, class T177, class T178, class T179, class T180, class T181, class T182, class T183, class T184,
1913       class T185, class T186, class T187, class T188, class T189, class T190, class T191, class T192, class T193, class T194, class T195,
1914       class T196, class T197, class T198, class T199, class T200, class T201, class T202, class T203, class T204, class T205, class T206,
1915       class T207, class T208, class T209, class T210, class T211, class T212, class T213, class T214, class T215, class T216, class T217,
1916       class T218, class T219, class T220, class T221, class T222, class T223, class T224, class T225, class T226, class T227, class T228,
1917       class T229, class T230, class T231, class T232, class T233, class T234, class T235, class T236, class T237, class T238, class T239,
1918       class T240, class T241, class T242, class T243, class T244, class T245, class T246, class T247, class T248, class T249, class T250,
1919       class T251, class T252, class T253, class T254, class T255, typename... Ts, typename Comp&gt;
1920     struct sort_impl&lt;list&lt;&gt;, list&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21,
1921       T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47,
1922       T48, T49, T50, T51, T52, T53, T54, T55, T56, T57, T58, T59, T60, T61, T62, T63, T64, T65, T66, T67, T68, T69, T70, T71, T72, T73,
1923       T74, T75, T76, T77, T78, T79, T80, T81, T82, T83, T84, T85, T86, T87, T88, T89, T90, T91, T92, T93, T94, T95, T96, T97, T98, T99,
1924       T100, T101, T102, T103, T104, T105, T106, T107, T108, T109, T110, T111, T112, T113, T114, T115, T116, T117, T118, T119, T120, T121,
1925       T122, T123, T124, T125, T126, T127, T128, T129, T130, T131, T132, T133, T134, T135, T136, T137, T138, T139, T140, T141, T142, T143,
1926       T144, T145, T146, T147, T148, T149, T150, T151, T152, T153, T154, T155, T156, T157, T158, T159, T160, T161, T162, T163, T164, T165,
1927       T166, T167, T168, T169, T170, T171, T172, T173, T174, T175, T176, T177, T178, T179, T180, T181, T182, T183, T184, T185, T186, T187,
1928       T188, T189, T190, T191, T192, T193, T194, T195, T196, T197, T198, T199, T200, T201, T202, T203, T204, T205, T206, T207, T208, T209,
1929       T210, T211, T212, T213, T214, T215, T216, T217, T218, T219, T220, T221, T222, T223, T224, T225, T226, T227, T228, T229, T230, T231,
1930       T232, T233, T234, T235, T236, T237, T238, T239, T240, T241, T242, T243, T244, T245, T246, T247, T248, T249, T250, T251, T252, T253,
1931       T254, T255, Ts...&gt;, Comp&gt;
1932     {
1933         using type = merge&lt;
1934             typename sort_impl&lt;list&lt;&gt;, list&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20,
1935               T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45,
1936               T46, T47, T48, T49, T50, T51, T52, T53, T54, T55, T56, T57, T58, T59, T60, T61, T62, T63, T64, T65, T66, T67, T68, T69, T70,
1937               T71, T72, T73, T74, T75, T76, T77, T78, T79, T80, T81, T82, T83, T84, T85, T86, T87, T88, T89, T90, T91, T92, T93, T94, T95,
1938               T96, T97, T98, T99, T100, T101, T102, T103, T104, T105, T106, T107, T108, T109, T110, T111, T112, T113, T114, T115, T116,
1939               T117, T118, T119, T120, T121, T122, T123, T124, T125, T126, T127, T128, T129, T130, T131, T132, T133, T134, T135, T136, T137,
1940               T138, T139, T140, T141, T142, T143, T144, T145, T146, T147, T148, T149, T150, T151, T152, T153, T154, T155, T156, T157, T158,
1941               T159, T160, T161, T162, T163, T164, T165, T166, T167, T168, T169, T170, T171, T172, T173, T174, T175, T176, T177, T178, T179,
1942               T180, T181, T182, T183, T184, T185, T186, T187, T188, T189, T190, T191, T192, T193, T194, T195, T196, T197, T198, T199, T200,
1943               T201, T202, T203, T204, T205, T206, T207, T208, T209, T210, T211, T212, T213, T214, T215, T216, T217, T218, T219, T220, T221,
1944               T222, T223, T224, T225, T226, T227, T228, T229, T230, T231, T232, T233, T234, T235, T236, T237, T238, T239, T240, T241, T242,
1945               T243, T244, T245, T246, T247, T248, T249, T250, T251, T252, T253, T254&gt;, Comp&gt;::type,
1946             typename sort_impl&lt;list&lt;&gt;, list&lt;T255, Ts...&gt;, Comp&gt;::type, Comp
1947         &gt;;
1948     };
1949 }
1950 template &lt;class Seq, class Comp = less&lt;_1,_2&gt;&gt;
1951 using sort = append&lt;clear&lt;Seq&gt;, typename detail::sort_impl&lt;list&lt;&gt;, wrap&lt;Seq, list&gt;, Comp&gt;::type&gt;;
1952 }
1953 
1954 namespace brigand
1955 {
1956   template &lt;typename A&gt;
1957   struct complement : std::integral_constant&lt; typename A::value_type
1958                                             , typename A::value_type(~A::value)
1959                                             &gt; {};
1960 }
1961 
1962 namespace brigand
1963 {
1964   template &lt;typename A, typename B&gt;
1965   struct divides : std::integral_constant &lt; typename A::value_type, A::value / B::value &gt; {};
1966 }
1967 namespace brigand
1968 {
1969   template&lt;class T&gt;
1970   struct identity
1971   {
1972     using type = T;
1973   };
1974 }
1975 
1976 namespace brigand
1977 {
1978   template &lt;typename A, typename B&gt;
1979   struct max : std::integral_constant &lt; typename A::value_type
1980                                       , (A::value &lt; B::value) ? B::value : A::value
1981                                       &gt;
1982   {};
1983 }
1984 
1985 namespace brigand
1986 {
1987   template &lt;typename A, typename B&gt;
1988   struct min : std::integral_constant &lt; typename A::value_type
1989                                       , (A::value &lt; B::value) ? A::value : B::value
1990                                       &gt;
1991   {};
1992 }
1993 
1994 namespace brigand
1995 {
1996   template &lt;typename A, typename B&gt;
1997   struct minus : std::integral_constant &lt; typename A::value_type, A::value - B::value &gt; {};
1998 }
1999 
2000 namespace brigand
2001 {
2002   template &lt;typename A, typename B&gt;
2003   struct modulo : std::integral_constant &lt; typename A::value_type, A::value % B::value &gt; {};
2004 }
2005 
2006 namespace brigand
2007 {
2008   template &lt;typename A&gt;
2009   struct negate : std::integral_constant &lt; typename A::value_type, -A::value &gt; {};
2010 }
2011 
2012 namespace brigand
2013 {
2014   template &lt;typename A&gt;
2015   struct next : std::integral_constant &lt; typename A::value_type, A::value + 1 &gt; {};
2016 }
2017 
2018 namespace brigand
2019 {
2020   template &lt;typename A, typename B&gt;
2021   struct plus : std::integral_constant &lt; typename A::value_type, A::value + B::value &gt; {};
2022 }
2023 
2024 namespace brigand
2025 {
2026   template &lt;typename A&gt;
2027   struct prev : std::integral_constant &lt; typename A::value_type, A::value - 1 &gt; {};
2028 }
2029 
2030 namespace brigand
2031 {
2032   template &lt;typename A, typename B&gt;
2033   struct times : std::integral_constant &lt; typename A::value_type, A::value * B::value &gt; {};
2034 }
2035 
2036 namespace brigand
2037 {
2038   template &lt;typename A, typename B&gt;
2039   struct bitand_ : std::integral_constant&lt;typename A::value_type, A::value &amp; B::value&gt; {};
2040 }
2041 
2042 namespace brigand
2043 {
2044   template &lt;typename A, typename B&gt;
2045   struct bitor_ : std::integral_constant&lt;typename A::value_type, A::value | B::value&gt; {};
2046 }
2047 
2048 namespace brigand
2049 {
2050   template &lt;typename A, typename B&gt;
2051   struct bitxor_ : std::integral_constant&lt;typename A::value_type, A::value ^ B::value&gt; {};
2052 }
2053 
2054 namespace brigand
2055 {
2056   template &lt;typename A, typename B&gt;
2057   struct shift_left : std::integral_constant&lt;typename A::value_type, (A::value &lt;&lt; B::value)&gt; {};
2058 }
2059 
2060 namespace brigand
2061 {
2062   template &lt;typename A, typename B&gt;
2063   struct shift_right : std::integral_constant&lt;typename A::value_type, (A::value &gt;&gt; B::value)&gt; {};
2064 }
2065 namespace brigand
2066 {
2067   template &lt;typename A, typename B&gt;
2068   struct equal_to : bool_ &lt; (A::value == B::value) &gt; {};
2069 }
2070 namespace brigand
2071 {
2072   template &lt;typename A, typename B&gt;
2073   struct greater : bool_&lt;(A::value &gt; B::value) &gt; {};
2074 }
2075 namespace brigand
2076 {
2077   template &lt;typename A, typename B&gt;
2078   struct greater_equal : bool_ &lt; (A::value &gt;= B::value) &gt; {};
2079 }
2080 namespace brigand
2081 {
2082   template &lt;typename A, typename B&gt;
2083   struct less_equal : bool_ &lt; (A::value &lt;= B::value) &gt; {};
2084 }
2085 namespace brigand
2086 {
2087   template &lt;typename A, typename B&gt;
2088   struct not_equal_to : bool_ &lt; (A::value != B::value) &gt; {};
2089 }
2090 
2091 namespace brigand
2092 {
2093   template &lt;typename Condition, typename A, typename B&gt;
2094   struct eval_if
2095   {
2096     using type = typename std::conditional&lt;Condition::value, A, B&gt;::type::type;
2097   };
2098   template &lt;bool Condition, typename A, typename B&gt;
2099   struct eval_if_c
2100   {
2101     using type = typename std::conditional&lt;Condition, A, B&gt;::type::type;
2102   };
2103 }
2104 
2105 namespace brigand
2106 {
2107   template &lt;typename Condition, typename A, typename B&gt;
2108   struct if_ : std::conditional&lt;Condition::value, A, B&gt; {};
2109   template &lt;bool Condition, typename A, typename B&gt;
2110   struct if_c : std::conditional&lt;Condition, A, B&gt; {};
2111 }
2112 
2113 namespace brigand
2114 {
2115   template &lt;typename A, typename B&gt;
2116   struct and_ : std::integral_constant &lt;typename A::value_type, A::value &amp;&amp; B::value &gt; {};
2117 }
2118 
2119 namespace brigand
2120 {
2121   template &lt;typename T&gt;
2122   struct not_ : std::integral_constant&lt;typename T::value_type, !T::value&gt; {};
2123 }
2124 
2125 namespace brigand
2126 {
2127   template &lt;typename A, typename B&gt;
2128   struct or_ : std::integral_constant &lt; typename A::value_type, A::value || B::value &gt; {};
2129 }
2130 
2131 namespace brigand
2132 {
2133   template &lt;typename A, typename B&gt;
2134   struct xor_ : std::integral_constant&lt;typename A::value_type, A::value != B::value&gt; {};
2135 }
2136 namespace brigand
2137 {
2138   template&lt;class T&gt;
2139   struct always
2140   {
2141      using type = T;
2142   };
2143 }
2144 namespace brigand
2145 {
2146 namespace detail
2147 {
2148     template&lt;template&lt;class&gt; class F, unsigned N, class T&gt;
2149     struct repeat_impl
2150     : repeat_impl&lt;F, N-7, F&lt;F&lt;F&lt;F&lt;F&lt;F&lt;F&lt;T&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;
2151     {};
2152     template&lt;template&lt;class&gt; class F, class T&gt;
2153     struct repeat_impl&lt;F, 7, T&gt;
2154     {
2155         using type = F&lt;F&lt;F&lt;F&lt;F&lt;F&lt;F&lt;T&gt;&gt;&gt;&gt;&gt;&gt;&gt;;
2156     };
2157     template&lt;template&lt;class&gt; class F, class T&gt;
2158     struct repeat_impl&lt;F, 6, T&gt;
2159     {
2160         using type = F&lt;F&lt;F&lt;F&lt;F&lt;F&lt;T&gt;&gt;&gt;&gt;&gt;&gt;;
2161     };
2162     template&lt;template&lt;class&gt; class F, class T&gt;
2163     struct repeat_impl&lt;F, 5, T&gt;
2164     {
2165         using type = F&lt;F&lt;F&lt;F&lt;F&lt;T&gt;&gt;&gt;&gt;&gt;;
2166     };
2167     template&lt;template&lt;class&gt; class F, class T&gt;
2168     struct repeat_impl&lt;F, 4, T&gt;
2169     {
2170         using type = F&lt;F&lt;F&lt;F&lt;T&gt;&gt;&gt;&gt;;
2171     };
2172     template&lt;template&lt;class&gt; class F, class T&gt;
2173     struct repeat_impl&lt;F, 3, T&gt;
2174     {
2175         using type = F&lt;F&lt;F&lt;T&gt;&gt;&gt;;
2176     };
2177     template&lt;template&lt;class&gt; class F, class T&gt;
2178     struct repeat_impl&lt;F, 2, T&gt;
2179     {
2180         using type = F&lt;F&lt;T&gt;&gt;;
2181     };
2182     template&lt;template&lt;class&gt; class F, class T&gt;
2183     struct repeat_impl&lt;F, 1, T&gt;
2184     {
2185         using type = F&lt;T&gt;;
2186     };
2187     template&lt;template&lt;class&gt; class F, class T&gt;
2188     struct repeat_impl&lt;F, 0, T&gt;
2189     {
2190         using type = T;
2191     };
2192 }
2193 namespace lazy
2194 {
2195     template&lt;template&lt;class&gt; class F, class N, class T&gt;
2196     using repeat = typename detail::repeat_impl&lt;F, N::value, T&gt;;
2197 }
2198     template&lt;template&lt;class&gt; class F, class N, class T&gt;
2199     using repeat = typename ::brigand::lazy::repeat&lt;F, N, T&gt;::type;
2200 }
2201 
2202 namespace brigand
2203 {
2204   template&lt;typename T&gt;
2205   struct sizeof_ : std::integral_constant &lt;std::size_t, sizeof(T)&gt; {};
2206 }
2207 namespace brigand
2208 {
2209 namespace detail
2210 {
2211     template&lt;class C, class K&gt;
2212     struct has_key_impl
2213     {
2214         using type = decltype(C::has_key(type_&lt;K&gt;{}));
2215     };
2216 }
2217     template&lt;class L, class K&gt;
2218     using has_key = typename detail::has_key_impl&lt;L, K&gt;::type;
2219 }
2220 namespace brigand
2221 {
2222 namespace detail
2223 {
2224     template&lt;class Start, unsigned N, class Next, class... E&gt;
2225     struct mksq8
2226     : mksq8&lt;brigand::apply&lt;Next, Start&gt;, N-1, Next, E..., Start&gt;
2227     {};
2228     template&lt;class Start, class Next, class... E&gt;
2229     struct mksq8&lt;Start, 0, Next, E...&gt;
2230     {
2231         using type = list&lt;E...&gt;;
2232     };
2233     template&lt;class Start, class Next, class... E&gt;
2234     struct mksq8&lt;Start, 1, Next, E...&gt;
2235     {
2236         using type = list&lt;E..., Start&gt;;
2237     };
2238     template&lt;class Start, class Next&gt;
2239     struct mksq8&lt;Start, 8, Next&gt;
2240     {
2241         using t1 = brigand::apply&lt;Next, Start&gt;;
2242         using t2 = brigand::apply&lt;Next, t1&gt;;
2243         using t3 = brigand::apply&lt;Next, t2&gt;;
2244         using t4 = brigand::apply&lt;Next, t3&gt;;
2245         using t5 = brigand::apply&lt;Next, t4&gt;;
2246         using t6 = brigand::apply&lt;Next, t5&gt;;
2247         using t7 = brigand::apply&lt;Next, t6&gt;;
2248         using type = list&lt;Start, t1, t2, t3, t4, t5, t6, t7&gt;;
2249     };
2250     template&lt;template&lt;class...&gt; class List, class Start, unsigned N, class Next, bool, class... L&gt;
2251     struct make_sequence_impl
2252     : make_sequence_impl&lt;
2253         List,
2254         brigand::apply&lt;Next, typename mksq8&lt;Start, 8, Next&gt;::t7&gt;,
2255         N-8,
2256         Next,
2257         (N-8&lt;=8),
2258         L...,
2259         typename mksq8&lt;Start, 8, Next&gt;::type
2260     &gt;
2261     {};
2262     template&lt;template&lt;class...&gt; class List, class Start, unsigned N, class Next, class... L&gt;
2263     struct make_sequence_impl&lt;List, Start, N, Next, true, L...&gt;
2264     {
2265         using type = append&lt;List&lt;&gt;, L..., typename mksq8&lt;Start, N, Next&gt;::type&gt;;
2266     };
2267 }
2268     template&lt;class Start, unsigned N, class Next = next&lt;_1&gt;, template&lt;class...&gt; class List = list&gt;
2269     using make_sequence = typename detail::make_sequence_impl&lt;List, Start, N, Next, (N&lt;=8)&gt;::type;
2270 }
2271 
2272 namespace brigand
2273 {
2274     template&lt;class L, std::size_t Index&gt;
2275     using erase_c = append&lt;
2276         front&lt;split_at&lt;L, size_t&lt;Index&gt;&gt;&gt;,
2277         pop_front&lt;back&lt;split_at&lt;L, size_t&lt;Index&gt;&gt;&gt;&gt;
2278     &gt;;
2279 namespace detail
2280 {
2281     template &lt;typename T&gt;
2282     struct has_erase_method
2283     {
2284         struct dummy {};
2285         template &lt;typename C, typename P&gt;
2286         static auto test(P * p) -&gt; decltype(C::erase(type_&lt;P&gt;{}), std::true_type());
2287         template &lt;typename, typename&gt;
2288         static std::false_type test(...);
<a name="2" id="anc2"></a><span class="line-modified">2289         static const bool value = std::is_same&lt;std::true_type, decltype(test&lt;T, dummy&gt;(nullptr))&gt;::value;</span>
2290     };
2291     template&lt;class L, class I, bool&gt;
2292     struct erase_dispatch
2293     {
2294         using type = erase_c&lt;L, I::value&gt;;
2295     };
2296     template&lt;class C, class K&gt;
2297     struct erase_dispatch&lt;C, K, true&gt;
2298     {
2299         using type = decltype(C::erase(type_&lt;K&gt;{}));
2300     };
2301 }
2302     template&lt;class L, class K&gt;
2303     using erase = typename detail::erase_dispatch&lt;L, K, detail::has_erase_method&lt;L&gt;::value&gt;::type;
2304 }
2305 namespace brigand
2306 {
2307 namespace detail
2308 {
2309     template &lt;class C, class T&gt;
2310     struct insert_impl
2311     {
2312         using type = decltype(C::insert(type_&lt;T&gt;{}));
2313     };
2314 }
2315     template&lt;class L, class T&gt;
2316     using insert = typename detail::insert_impl&lt;L, T&gt;::type;
2317 }
2318 namespace brigand
2319 {
2320 namespace detail
2321 {
2322     template &lt;class L, class K&gt;
2323     struct contains_impl
2324     {
2325         using type = decltype(L::contains(type_&lt;K&gt;{}));
2326     };
2327 }
2328     template &lt;class L, class K&gt;
2329     using contains = typename detail::contains_impl&lt;L, K&gt;::type;
2330 }
2331 namespace brigand
2332 {
2333 namespace detail
2334 {
2335     template&lt;class... Ts&gt;
2336     struct make_set;
2337     template&lt;class U, class K&gt;
2338     struct set_erase_pred_impl
2339     {
2340         using type = list&lt;U&gt;;
2341     };
2342     template&lt;class K&gt;
2343     struct set_erase_pred_impl&lt;K,K&gt;
2344     {
2345         using type = list&lt;&gt;;
2346     };
2347     template &lt;class... T&gt;
2348     struct set_impl
2349     {
2350         template &lt;typename K, typename = decltype(static_cast&lt;type_&lt;K&gt;*&gt;(static_cast&lt;make_set&lt;T...&gt;*&gt;(nullptr)))&gt;
2351         static std::true_type contains(type_&lt;K&gt;);
2352         template &lt;typename K&gt;
2353         static std::false_type contains(K);
2354         template &lt;typename K, typename = decltype(static_cast&lt;type_&lt;K&gt;*&gt;(static_cast&lt;make_set&lt;T...&gt;*&gt;(nullptr)))&gt;
2355         static std::true_type has_key(type_&lt;K&gt;);
2356         template &lt;typename K&gt;
2357         static std::false_type has_key(K);
2358         template &lt;class K&gt;
2359         static append&lt;set_impl&lt;&gt;, typename set_erase_pred_impl&lt;T, K&gt;::type...&gt; erase(type_&lt;K&gt;);
2360         template&lt;class K, class = decltype(static_cast&lt;type_&lt;K&gt;*&gt;(static_cast&lt;make_set&lt;T...&gt;*&gt;(nullptr)))&gt;
2361         static set_impl insert(type_&lt;K&gt;);
2362         template&lt;class K&gt;
2363         static set_impl&lt;T..., typename K::type&gt; insert(K);
2364     };
2365     template&lt;class... Ts&gt;
2366     struct make_set : type_&lt;Ts&gt;...
2367     {
2368       using type = set_impl&lt;Ts...&gt;;
2369     };
2370 }
2371     template&lt;class... Ts&gt;
2372     using set = typename detail::make_set&lt;Ts...&gt;::type;
2373 }
2374 namespace brigand
2375 {
2376 namespace detail
2377 {
2378     template &lt;typename Pair&gt;
2379     struct get_second {
2380         using type = typename Pair::second_type;
2381     };
2382 }
2383 template &lt;typename Map, template &lt;class...&gt; class Sequence = brigand::list&gt;
2384 using values_as_sequence = transform&lt;as_sequence&lt;Map, Sequence&gt;, detail::get_second&lt;_1&gt;&gt;;
2385 }
2386 namespace brigand
2387 {
2388 namespace detail
2389 {
2390     template &lt;typename Pair&gt;
2391     struct get_first {
2392         using type = typename Pair::first_type;
2393     };
2394 }
2395 template &lt;typename Map, template &lt;class...&gt; class Sequence = brigand::set&gt;
2396 using keys_as_sequence = transform&lt;as_sequence&lt;Map, Sequence&gt;, detail::get_first&lt;_1&gt;&gt;;
2397 }
2398 namespace brigand
2399 {
2400   struct empty_base {};
2401 }
2402 namespace brigand
2403 {
2404   template&lt;typename T, typename R = void &gt; struct has_type
2405   {
2406     using type = R;
2407   };
2408 }
2409 namespace brigand
2410 {
2411   template&lt;typename... Ts&gt; struct inherit;
2412   template&lt;typename T&gt; struct inherit&lt;T&gt;
2413   {
2414     struct type : public T {};
2415   };
2416   template&lt;&gt; struct inherit&lt;&gt;
2417   {
2418     using type = empty_base;
2419   };
2420   template&lt;&gt; struct inherit&lt;empty_base&gt;
2421   {
2422     using type = empty_base;
2423   };
2424   template&lt;typename T1, typename T2&gt; struct inherit&lt;T1,T2&gt;
2425   {
2426     struct type : public T1, T2 {};
2427   };
2428   template&lt;typename T1&gt; struct inherit&lt;T1,empty_base&gt;
2429   {
2430     using type = T1;
2431   };
2432   template&lt;typename T2&gt; struct inherit&lt;empty_base,T2&gt;
2433   {
2434     using type = T2;
2435   };
2436   template&lt;&gt; struct inherit&lt;empty_base,empty_base&gt;
2437   {
2438     using type = empty_base;
2439   };
2440   template&lt;typename T1, typename T2, typename T3, typename... Ts&gt;
2441   struct  inherit&lt;T1, T2, T3, Ts...&gt;
2442         : inherit&lt;T1, typename inherit&lt;T2,typename inherit&lt;T3, Ts...&gt;::type&gt;::type&gt;
2443   {};
2444 }
2445 namespace brigand
2446 {
2447   namespace lazy
2448   {
2449       template&lt; typename Types
2450           , typename Node
2451           , typename Root = brigand::empty_base
2452       &gt;
2453           struct inherit_linearly;
2454     template&lt; typename Types
2455           , template&lt;typename...&gt; class Node, typename...Ts
2456           , typename Root
2457       &gt;
2458     struct inherit_linearly&lt;Types,Node&lt;Ts...&gt;,Root&gt;
2459     {
2460       using type = brigand::fold&lt;Types,Root,bind&lt;Node,Ts...&gt;&gt;;
2461     };
2462   }
2463   template&lt; typename Types
2464             , typename Node
2465             , typename Root = brigand::empty_base
2466             &gt;
2467   using inherit_linearly = typename lazy::inherit_linearly&lt;Types,Node,Root&gt;::type;
2468 }
2469 
2470 namespace brigand
2471 {
2472   template&lt;typename RealType, typename Type, Type Value&gt;
2473   struct real_ : std::integral_constant&lt;Type,Value&gt;
2474   {
2475     using value_type  = RealType;
2476     using parent      = std::integral_constant&lt;Type,Value&gt;;
2477     inline operator value_type() const
2478     {
2479       value_type that;
2480       std::memcpy(&amp;that, &amp;parent::value, sizeof(value_type));
2481       return that;
2482     }
2483   };
2484   template&lt;std::uint32_t Value&gt;
2485   struct single_ : real_&lt;float, std::uint32_t, Value&gt; {};
2486   template&lt;std::uint64_t Value&gt;
2487   struct double_ : real_&lt;double, std::uint64_t,Value&gt; {};
2488 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
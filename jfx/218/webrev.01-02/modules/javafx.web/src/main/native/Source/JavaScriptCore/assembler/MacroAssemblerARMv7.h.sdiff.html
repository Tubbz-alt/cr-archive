<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerARMv7.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MacroAssemblerARM64E.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MacroAssemblerCodeRef.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerARMv7.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2009-2018 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2010 University of Szeged
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #pragma once
  28 
  29 #if ENABLE(ASSEMBLER)
  30 
  31 #include &quot;ARMv7Assembler.h&quot;
  32 #include &quot;AbstractMacroAssembler.h&quot;
  33 
  34 namespace JSC {
  35 
  36 using Assembler = TARGET_ASSEMBLER;
  37 
  38 class MacroAssemblerARMv7 : public AbstractMacroAssembler&lt;Assembler&gt; {
<span class="line-modified">  39     static const RegisterID dataTempRegister = ARMRegisters::ip;</span>
<span class="line-modified">  40     static const RegisterID addressTempRegister = ARMRegisters::r6;</span>
  41 
<span class="line-modified">  42     static const ARMRegisters::FPDoubleRegisterID fpTempRegister = ARMRegisters::d7;</span>
  43     inline ARMRegisters::FPSingleRegisterID fpTempRegisterAsSingle() { return ARMRegisters::asSingle(fpTempRegister); }
  44 
  45 public:
<span class="line-modified">  46     static const unsigned numGPRs = 16;</span>
<span class="line-modified">  47     static const unsigned numFPRs = 16;</span>
  48 
  49     MacroAssemblerARMv7()
  50         : m_makeJumpPatchable(false)
  51     {
  52     }
  53 
  54     typedef ARMv7Assembler::LinkRecord LinkRecord;
  55     typedef ARMv7Assembler::JumpType JumpType;
  56     typedef ARMv7Assembler::JumpLinkType JumpLinkType;
  57     typedef ARMv7Assembler::Condition Condition;
  58 
<span class="line-modified">  59     static const ARMv7Assembler::Condition DefaultCondition = ARMv7Assembler::ConditionInvalid;</span>
<span class="line-modified">  60     static const ARMv7Assembler::JumpType DefaultJump = ARMv7Assembler::JumpNoConditionFixedSize;</span>
  61 
  62     static bool isCompactPtrAlignedAddressOffset(ptrdiff_t value)
  63     {
  64         return value &gt;= -255 &amp;&amp; value &lt;= 255;
  65     }
  66 
  67     Vector&lt;LinkRecord, 0, UnsafeVectorOverflow&gt;&amp; jumpsToLink() { return m_assembler.jumpsToLink(); }
  68     static bool canCompact(JumpType jumpType) { return ARMv7Assembler::canCompact(jumpType); }
  69     static JumpLinkType computeJumpType(JumpType jumpType, const uint8_t* from, const uint8_t* to) { return ARMv7Assembler::computeJumpType(jumpType, from, to); }
  70     static JumpLinkType computeJumpType(LinkRecord&amp; record, const uint8_t* from, const uint8_t* to) { return ARMv7Assembler::computeJumpType(record, from, to); }
  71     static int jumpSizeDelta(JumpType jumpType, JumpLinkType jumpLinkType) { return ARMv7Assembler::jumpSizeDelta(jumpType, jumpLinkType); }
<span class="line-modified">  72     template &lt;typename CopyFunction&gt;</span>
<span class="line-modified">  73     static void link(LinkRecord&amp; record, uint8_t* from, const uint8_t* fromInstruction, uint8_t* to, CopyFunction copy) { return ARMv7Assembler::link(record, from, fromInstruction, to, copy); }</span>
  74 
  75     struct ArmAddress {
  76         enum AddressType {
  77             HasOffset,
  78             HasIndex,
  79         } type;
  80         RegisterID base;
  81         union {
  82             int32_t offset;
  83             struct {
  84                 RegisterID index;
  85                 Scale scale;
  86             };
  87         } u;
  88 
  89         explicit ArmAddress(RegisterID base, int32_t offset = 0)
  90             : type(HasOffset)
  91             , base(base)
  92         {
  93             u.offset = offset;
  94         }
  95 
  96         explicit ArmAddress(RegisterID base, RegisterID index, Scale scale = TimesOne)
  97             : type(HasIndex)
  98             , base(base)
  99         {
 100             u.index = index;
 101             u.scale = scale;
 102         }
 103     };
 104 
 105 public:
<span class="line-modified"> 106     static const Scale ScalePtr = TimesFour;</span>
 107 
 108     enum RelationalCondition {
 109         Equal = ARMv7Assembler::ConditionEQ,
 110         NotEqual = ARMv7Assembler::ConditionNE,
 111         Above = ARMv7Assembler::ConditionHI,
 112         AboveOrEqual = ARMv7Assembler::ConditionHS,
 113         Below = ARMv7Assembler::ConditionLO,
 114         BelowOrEqual = ARMv7Assembler::ConditionLS,
 115         GreaterThan = ARMv7Assembler::ConditionGT,
 116         GreaterThanOrEqual = ARMv7Assembler::ConditionGE,
 117         LessThan = ARMv7Assembler::ConditionLT,
 118         LessThanOrEqual = ARMv7Assembler::ConditionLE
 119     };
 120 
 121     enum ResultCondition {
 122         Overflow = ARMv7Assembler::ConditionVS,
 123         Signed = ARMv7Assembler::ConditionMI,
 124         PositiveOrZero = ARMv7Assembler::ConditionPL,
 125         Zero = ARMv7Assembler::ConditionEQ,
 126         NonZero = ARMv7Assembler::ConditionNE
 127     };
 128 
 129     enum DoubleCondition {
 130         // These conditions will only evaluate to true if the comparison is ordered - i.e. neither operand is NaN.
 131         DoubleEqual = ARMv7Assembler::ConditionEQ,
 132         DoubleNotEqual = ARMv7Assembler::ConditionVC, // Not the right flag! check for this &amp; handle differently.
 133         DoubleGreaterThan = ARMv7Assembler::ConditionGT,
 134         DoubleGreaterThanOrEqual = ARMv7Assembler::ConditionGE,
 135         DoubleLessThan = ARMv7Assembler::ConditionLO,
 136         DoubleLessThanOrEqual = ARMv7Assembler::ConditionLS,
 137         // If either operand is NaN, these conditions always evaluate to true.
 138         DoubleEqualOrUnordered = ARMv7Assembler::ConditionVS, // Not the right flag! check for this &amp; handle differently.
 139         DoubleNotEqualOrUnordered = ARMv7Assembler::ConditionNE,
 140         DoubleGreaterThanOrUnordered = ARMv7Assembler::ConditionHI,
 141         DoubleGreaterThanOrEqualOrUnordered = ARMv7Assembler::ConditionHS,
 142         DoubleLessThanOrUnordered = ARMv7Assembler::ConditionLT,
 143         DoubleLessThanOrEqualOrUnordered = ARMv7Assembler::ConditionLE,
 144     };
 145 
<span class="line-modified"> 146     static const RegisterID stackPointerRegister = ARMRegisters::sp;</span>
<span class="line-modified"> 147     static const RegisterID framePointerRegister = ARMRegisters::fp;</span>
<span class="line-modified"> 148     static const RegisterID linkRegister = ARMRegisters::lr;</span>
 149 
 150     // Integer arithmetic operations:
 151     //
 152     // Operations are typically two operand - operation(source, srcDst)
 153     // For many operations the source may be an TrustedImm32, the srcDst operand
 154     // may often be a memory location (explictly described using an Address
 155     // object).
 156 
 157     void add32(RegisterID src, RegisterID dest)
 158     {
 159         m_assembler.add(dest, dest, src);
 160     }
 161 
 162     void add32(RegisterID left, RegisterID right, RegisterID dest)
 163     {
 164         m_assembler.add(dest, left, right);
 165     }
 166 
 167     void add32(TrustedImm32 imm, RegisterID dest)
 168     {
</pre>
<hr />
<pre>
 349     {
 350         move(imm, dataTempRegister);
 351         m_assembler.smull(dest, dataTempRegister, src, dataTempRegister);
 352     }
 353 
 354     void neg32(RegisterID srcDest)
 355     {
 356         m_assembler.neg(srcDest, srcDest);
 357     }
 358 
 359     void neg32(RegisterID src, RegisterID dest)
 360     {
 361         m_assembler.neg(dest, src);
 362     }
 363 
 364     void or32(RegisterID src, RegisterID dest)
 365     {
 366         m_assembler.orr(dest, dest, src);
 367     }
 368 


















 369     void or32(RegisterID src, AbsoluteAddress dest)
 370     {
 371         move(TrustedImmPtr(dest.m_ptr), addressTempRegister);
 372         load32(addressTempRegister, dataTempRegister);
 373         or32(src, dataTempRegister);
 374         store32(dataTempRegister, addressTempRegister);
 375     }
 376 
 377     void or32(TrustedImm32 imm, AbsoluteAddress address)
 378     {
 379         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(imm.m_value);
 380         if (armImm.isValid()) {
 381             move(TrustedImmPtr(address.m_ptr), addressTempRegister);
 382             load32(addressTempRegister, dataTempRegister);
 383             m_assembler.orr(dataTempRegister, dataTempRegister, armImm);
 384             store32(dataTempRegister, addressTempRegister);
 385         } else {
 386             move(TrustedImmPtr(address.m_ptr), addressTempRegister);
 387             load32(addressTempRegister, dataTempRegister);
 388             move(imm, addressTempRegister);
</pre>
<hr />
<pre>
 765     DataLabel32 load32WithAddressOffsetPatch(Address address, RegisterID dest)
 766     {
 767         DataLabel32 label = moveWithPatch(TrustedImm32(address.offset), dataTempRegister);
 768         load32(ArmAddress(address.base, dataTempRegister), dest);
 769         return label;
 770     }
 771 
 772     DataLabelCompact load32WithCompactAddressOffsetPatch(Address address, RegisterID dest)
 773     {
 774         padBeforePatch();
 775 
 776         RegisterID base = address.base;
 777 
 778         DataLabelCompact label(this);
 779         ASSERT(isCompactPtrAlignedAddressOffset(address.offset));
 780 
 781         m_assembler.ldr(dest, base, address.offset, true, false);
 782         return label;
 783     }
 784 






 785     void load16(BaseIndex address, RegisterID dest)
 786     {
 787         m_assembler.ldrh(dest, makeBaseIndexBase(address), address.index, address.scale);
 788     }
 789 
 790     void load16SignedExtendTo32(BaseIndex address, RegisterID dest)
 791     {
 792         load16SignedExtendTo32(setupArmAddress(address), dest);
 793     }
 794 
 795     void load16(ImplicitAddress address, RegisterID dest)
 796     {
 797         ARMThumbImmediate armImm = ARMThumbImmediate::makeUInt12(address.offset);
 798         if (armImm.isValid())
 799             m_assembler.ldrh(dest, address.base, armImm);
 800         else {
 801             move(TrustedImm32(address.offset), dataTempRegister);
 802             m_assembler.ldrh(dest, address.base, dataTempRegister);
 803         }
 804     }
</pre>
<hr />
<pre>
 872         store8(dataTempRegister, address);
 873     }
 874 
 875     void store8(TrustedImm32 imm, Address address)
 876     {
 877         TrustedImm32 imm8(static_cast&lt;int8_t&gt;(imm.m_value));
 878         move(imm8, dataTempRegister);
 879         store8(dataTempRegister, address);
 880     }
 881 
 882     void store16(RegisterID src, ImplicitAddress address)
 883     {
 884         store16(src, setupArmAddress(address));
 885     }
 886 
 887     void store16(RegisterID src, BaseIndex address)
 888     {
 889         store16(src, setupArmAddress(address));
 890     }
 891 












 892     // Possibly clobbers src, but not on this architecture.
 893     void moveDoubleToInts(FPRegisterID src, RegisterID dest1, RegisterID dest2)
 894     {
 895         m_assembler.vmov(dest1, dest2, src);
 896     }
 897 
 898     void moveIntsToDouble(RegisterID src1, RegisterID src2, FPRegisterID dest, FPRegisterID scratch)
 899     {
 900         UNUSED_PARAM(scratch);
 901         m_assembler.vmov(dest, src1, src2);
 902     }
 903 
 904     static bool shouldBlindForSpecificArch(uint32_t value)
 905     {
 906         ARMThumbImmediate immediate = ARMThumbImmediate::makeEncodedImm(value);
 907 
 908         // Couldn&#39;t be encoded as an immediate, so assume it&#39;s untrusted.
 909         if (!immediate.isValid())
 910             return true;
 911 
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2010 University of Szeged
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #pragma once
  28 
  29 #if ENABLE(ASSEMBLER)
  30 
  31 #include &quot;ARMv7Assembler.h&quot;
  32 #include &quot;AbstractMacroAssembler.h&quot;
  33 
  34 namespace JSC {
  35 
  36 using Assembler = TARGET_ASSEMBLER;
  37 
  38 class MacroAssemblerARMv7 : public AbstractMacroAssembler&lt;Assembler&gt; {
<span class="line-modified">  39     static constexpr RegisterID dataTempRegister = ARMRegisters::ip;</span>
<span class="line-modified">  40     static constexpr RegisterID addressTempRegister = ARMRegisters::r6;</span>
  41 
<span class="line-modified">  42     static constexpr ARMRegisters::FPDoubleRegisterID fpTempRegister = ARMRegisters::d7;</span>
  43     inline ARMRegisters::FPSingleRegisterID fpTempRegisterAsSingle() { return ARMRegisters::asSingle(fpTempRegister); }
  44 
  45 public:
<span class="line-modified">  46     static constexpr unsigned numGPRs = 16;</span>
<span class="line-modified">  47     static constexpr unsigned numFPRs = 16;</span>
  48 
  49     MacroAssemblerARMv7()
  50         : m_makeJumpPatchable(false)
  51     {
  52     }
  53 
  54     typedef ARMv7Assembler::LinkRecord LinkRecord;
  55     typedef ARMv7Assembler::JumpType JumpType;
  56     typedef ARMv7Assembler::JumpLinkType JumpLinkType;
  57     typedef ARMv7Assembler::Condition Condition;
  58 
<span class="line-modified">  59     static constexpr ARMv7Assembler::Condition DefaultCondition = ARMv7Assembler::ConditionInvalid;</span>
<span class="line-modified">  60     static constexpr ARMv7Assembler::JumpType DefaultJump = ARMv7Assembler::JumpNoConditionFixedSize;</span>
  61 
  62     static bool isCompactPtrAlignedAddressOffset(ptrdiff_t value)
  63     {
  64         return value &gt;= -255 &amp;&amp; value &lt;= 255;
  65     }
  66 
  67     Vector&lt;LinkRecord, 0, UnsafeVectorOverflow&gt;&amp; jumpsToLink() { return m_assembler.jumpsToLink(); }
  68     static bool canCompact(JumpType jumpType) { return ARMv7Assembler::canCompact(jumpType); }
  69     static JumpLinkType computeJumpType(JumpType jumpType, const uint8_t* from, const uint8_t* to) { return ARMv7Assembler::computeJumpType(jumpType, from, to); }
  70     static JumpLinkType computeJumpType(LinkRecord&amp; record, const uint8_t* from, const uint8_t* to) { return ARMv7Assembler::computeJumpType(record, from, to); }
  71     static int jumpSizeDelta(JumpType jumpType, JumpLinkType jumpLinkType) { return ARMv7Assembler::jumpSizeDelta(jumpType, jumpLinkType); }
<span class="line-modified">  72     template &lt;Assembler::CopyFunction copy&gt;</span>
<span class="line-modified">  73     static void link(LinkRecord&amp; record, uint8_t* from, const uint8_t* fromInstruction, uint8_t* to) { return ARMv7Assembler::link&lt;copy&gt;(record, from, fromInstruction, to); }</span>
  74 
  75     struct ArmAddress {
  76         enum AddressType {
  77             HasOffset,
  78             HasIndex,
  79         } type;
  80         RegisterID base;
  81         union {
  82             int32_t offset;
  83             struct {
  84                 RegisterID index;
  85                 Scale scale;
  86             };
  87         } u;
  88 
  89         explicit ArmAddress(RegisterID base, int32_t offset = 0)
  90             : type(HasOffset)
  91             , base(base)
  92         {
  93             u.offset = offset;
  94         }
  95 
  96         explicit ArmAddress(RegisterID base, RegisterID index, Scale scale = TimesOne)
  97             : type(HasIndex)
  98             , base(base)
  99         {
 100             u.index = index;
 101             u.scale = scale;
 102         }
 103     };
 104 
 105 public:
<span class="line-modified"> 106     static constexpr Scale ScalePtr = TimesFour;</span>
 107 
 108     enum RelationalCondition {
 109         Equal = ARMv7Assembler::ConditionEQ,
 110         NotEqual = ARMv7Assembler::ConditionNE,
 111         Above = ARMv7Assembler::ConditionHI,
 112         AboveOrEqual = ARMv7Assembler::ConditionHS,
 113         Below = ARMv7Assembler::ConditionLO,
 114         BelowOrEqual = ARMv7Assembler::ConditionLS,
 115         GreaterThan = ARMv7Assembler::ConditionGT,
 116         GreaterThanOrEqual = ARMv7Assembler::ConditionGE,
 117         LessThan = ARMv7Assembler::ConditionLT,
 118         LessThanOrEqual = ARMv7Assembler::ConditionLE
 119     };
 120 
 121     enum ResultCondition {
 122         Overflow = ARMv7Assembler::ConditionVS,
 123         Signed = ARMv7Assembler::ConditionMI,
 124         PositiveOrZero = ARMv7Assembler::ConditionPL,
 125         Zero = ARMv7Assembler::ConditionEQ,
 126         NonZero = ARMv7Assembler::ConditionNE
 127     };
 128 
 129     enum DoubleCondition {
 130         // These conditions will only evaluate to true if the comparison is ordered - i.e. neither operand is NaN.
 131         DoubleEqual = ARMv7Assembler::ConditionEQ,
 132         DoubleNotEqual = ARMv7Assembler::ConditionVC, // Not the right flag! check for this &amp; handle differently.
 133         DoubleGreaterThan = ARMv7Assembler::ConditionGT,
 134         DoubleGreaterThanOrEqual = ARMv7Assembler::ConditionGE,
 135         DoubleLessThan = ARMv7Assembler::ConditionLO,
 136         DoubleLessThanOrEqual = ARMv7Assembler::ConditionLS,
 137         // If either operand is NaN, these conditions always evaluate to true.
 138         DoubleEqualOrUnordered = ARMv7Assembler::ConditionVS, // Not the right flag! check for this &amp; handle differently.
 139         DoubleNotEqualOrUnordered = ARMv7Assembler::ConditionNE,
 140         DoubleGreaterThanOrUnordered = ARMv7Assembler::ConditionHI,
 141         DoubleGreaterThanOrEqualOrUnordered = ARMv7Assembler::ConditionHS,
 142         DoubleLessThanOrUnordered = ARMv7Assembler::ConditionLT,
 143         DoubleLessThanOrEqualOrUnordered = ARMv7Assembler::ConditionLE,
 144     };
 145 
<span class="line-modified"> 146     static constexpr RegisterID stackPointerRegister = ARMRegisters::sp;</span>
<span class="line-modified"> 147     static constexpr RegisterID framePointerRegister = ARMRegisters::fp;</span>
<span class="line-modified"> 148     static constexpr RegisterID linkRegister = ARMRegisters::lr;</span>
 149 
 150     // Integer arithmetic operations:
 151     //
 152     // Operations are typically two operand - operation(source, srcDst)
 153     // For many operations the source may be an TrustedImm32, the srcDst operand
 154     // may often be a memory location (explictly described using an Address
 155     // object).
 156 
 157     void add32(RegisterID src, RegisterID dest)
 158     {
 159         m_assembler.add(dest, dest, src);
 160     }
 161 
 162     void add32(RegisterID left, RegisterID right, RegisterID dest)
 163     {
 164         m_assembler.add(dest, left, right);
 165     }
 166 
 167     void add32(TrustedImm32 imm, RegisterID dest)
 168     {
</pre>
<hr />
<pre>
 349     {
 350         move(imm, dataTempRegister);
 351         m_assembler.smull(dest, dataTempRegister, src, dataTempRegister);
 352     }
 353 
 354     void neg32(RegisterID srcDest)
 355     {
 356         m_assembler.neg(srcDest, srcDest);
 357     }
 358 
 359     void neg32(RegisterID src, RegisterID dest)
 360     {
 361         m_assembler.neg(dest, src);
 362     }
 363 
 364     void or32(RegisterID src, RegisterID dest)
 365     {
 366         m_assembler.orr(dest, dest, src);
 367     }
 368 
<span class="line-added"> 369     void or16(TrustedImm32 imm, AbsoluteAddress dest)</span>
<span class="line-added"> 370     {</span>
<span class="line-added"> 371         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(imm.m_value);</span>
<span class="line-added"> 372         if (armImm.isValid()) {</span>
<span class="line-added"> 373             move(TrustedImmPtr(dest.m_ptr), addressTempRegister);</span>
<span class="line-added"> 374             load16(addressTempRegister, dataTempRegister);</span>
<span class="line-added"> 375             m_assembler.orr(dataTempRegister, dataTempRegister, armImm);</span>
<span class="line-added"> 376             store16(dataTempRegister, addressTempRegister);</span>
<span class="line-added"> 377         } else {</span>
<span class="line-added"> 378             move(TrustedImmPtr(dest.m_ptr), addressTempRegister);</span>
<span class="line-added"> 379             load16(addressTempRegister, dataTempRegister);</span>
<span class="line-added"> 380             move(imm, addressTempRegister);</span>
<span class="line-added"> 381             m_assembler.orr(dataTempRegister, dataTempRegister, addressTempRegister);</span>
<span class="line-added"> 382             move(TrustedImmPtr(dest.m_ptr), addressTempRegister);</span>
<span class="line-added"> 383             store16(dataTempRegister, addressTempRegister);</span>
<span class="line-added"> 384         }</span>
<span class="line-added"> 385     }</span>
<span class="line-added"> 386 </span>
 387     void or32(RegisterID src, AbsoluteAddress dest)
 388     {
 389         move(TrustedImmPtr(dest.m_ptr), addressTempRegister);
 390         load32(addressTempRegister, dataTempRegister);
 391         or32(src, dataTempRegister);
 392         store32(dataTempRegister, addressTempRegister);
 393     }
 394 
 395     void or32(TrustedImm32 imm, AbsoluteAddress address)
 396     {
 397         ARMThumbImmediate armImm = ARMThumbImmediate::makeEncodedImm(imm.m_value);
 398         if (armImm.isValid()) {
 399             move(TrustedImmPtr(address.m_ptr), addressTempRegister);
 400             load32(addressTempRegister, dataTempRegister);
 401             m_assembler.orr(dataTempRegister, dataTempRegister, armImm);
 402             store32(dataTempRegister, addressTempRegister);
 403         } else {
 404             move(TrustedImmPtr(address.m_ptr), addressTempRegister);
 405             load32(addressTempRegister, dataTempRegister);
 406             move(imm, addressTempRegister);
</pre>
<hr />
<pre>
 783     DataLabel32 load32WithAddressOffsetPatch(Address address, RegisterID dest)
 784     {
 785         DataLabel32 label = moveWithPatch(TrustedImm32(address.offset), dataTempRegister);
 786         load32(ArmAddress(address.base, dataTempRegister), dest);
 787         return label;
 788     }
 789 
 790     DataLabelCompact load32WithCompactAddressOffsetPatch(Address address, RegisterID dest)
 791     {
 792         padBeforePatch();
 793 
 794         RegisterID base = address.base;
 795 
 796         DataLabelCompact label(this);
 797         ASSERT(isCompactPtrAlignedAddressOffset(address.offset));
 798 
 799         m_assembler.ldr(dest, base, address.offset, true, false);
 800         return label;
 801     }
 802 
<span class="line-added"> 803     void load16(const void* address, RegisterID dest)</span>
<span class="line-added"> 804     {</span>
<span class="line-added"> 805         move(TrustedImmPtr(address), addressTempRegister);</span>
<span class="line-added"> 806         m_assembler.ldrh(dest, addressTempRegister, ARMThumbImmediate::makeUInt16(0));</span>
<span class="line-added"> 807     }</span>
<span class="line-added"> 808 </span>
 809     void load16(BaseIndex address, RegisterID dest)
 810     {
 811         m_assembler.ldrh(dest, makeBaseIndexBase(address), address.index, address.scale);
 812     }
 813 
 814     void load16SignedExtendTo32(BaseIndex address, RegisterID dest)
 815     {
 816         load16SignedExtendTo32(setupArmAddress(address), dest);
 817     }
 818 
 819     void load16(ImplicitAddress address, RegisterID dest)
 820     {
 821         ARMThumbImmediate armImm = ARMThumbImmediate::makeUInt12(address.offset);
 822         if (armImm.isValid())
 823             m_assembler.ldrh(dest, address.base, armImm);
 824         else {
 825             move(TrustedImm32(address.offset), dataTempRegister);
 826             m_assembler.ldrh(dest, address.base, dataTempRegister);
 827         }
 828     }
</pre>
<hr />
<pre>
 896         store8(dataTempRegister, address);
 897     }
 898 
 899     void store8(TrustedImm32 imm, Address address)
 900     {
 901         TrustedImm32 imm8(static_cast&lt;int8_t&gt;(imm.m_value));
 902         move(imm8, dataTempRegister);
 903         store8(dataTempRegister, address);
 904     }
 905 
 906     void store16(RegisterID src, ImplicitAddress address)
 907     {
 908         store16(src, setupArmAddress(address));
 909     }
 910 
 911     void store16(RegisterID src, BaseIndex address)
 912     {
 913         store16(src, setupArmAddress(address));
 914     }
 915 
<span class="line-added"> 916     void store16(RegisterID src, const void* address)</span>
<span class="line-added"> 917     {</span>
<span class="line-added"> 918         move(TrustedImmPtr(address), addressTempRegister);</span>
<span class="line-added"> 919         m_assembler.strh(src, addressTempRegister, ARMThumbImmediate::makeUInt12(0));</span>
<span class="line-added"> 920     }</span>
<span class="line-added"> 921 </span>
<span class="line-added"> 922     void store16(TrustedImm32 imm, const void* address)</span>
<span class="line-added"> 923     {</span>
<span class="line-added"> 924         move(imm, dataTempRegister);</span>
<span class="line-added"> 925         store16(dataTempRegister, address);</span>
<span class="line-added"> 926     }</span>
<span class="line-added"> 927 </span>
 928     // Possibly clobbers src, but not on this architecture.
 929     void moveDoubleToInts(FPRegisterID src, RegisterID dest1, RegisterID dest2)
 930     {
 931         m_assembler.vmov(dest1, dest2, src);
 932     }
 933 
 934     void moveIntsToDouble(RegisterID src1, RegisterID src2, FPRegisterID dest, FPRegisterID scratch)
 935     {
 936         UNUSED_PARAM(scratch);
 937         m_assembler.vmov(dest, src1, src2);
 938     }
 939 
 940     static bool shouldBlindForSpecificArch(uint32_t value)
 941     {
 942         ARMThumbImmediate immediate = ARMThumbImmediate::makeEncodedImm(value);
 943 
 944         // Couldn&#39;t be encoded as an immediate, so assume it&#39;s untrusted.
 945         if (!immediate.isValid())
 946             return true;
 947 
</pre>
</td>
</tr>
</table>
<center><a href="MacroAssemblerARM64E.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MacroAssemblerCodeRef.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSNodeCustom.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSNavigatorCustom.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSNodeCustom.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSNodeCustom.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 49,14 ***</span>
<span class="line-new-header">--- 49,16 ---</span>
  #include &quot;JSDocumentFragment.h&quot;
  #include &quot;JSDocumentType.h&quot;
  #include &quot;JSEventListener.h&quot;
  #include &quot;JSHTMLElement.h&quot;
  #include &quot;JSHTMLElementWrapperFactory.h&quot;
<span class="line-added">+ #include &quot;JSMathMLElementWrapperFactory.h&quot;</span>
  #include &quot;JSProcessingInstruction.h&quot;
  #include &quot;JSSVGElementWrapperFactory.h&quot;
  #include &quot;JSShadowRoot.h&quot;
  #include &quot;JSText.h&quot;
<span class="line-added">+ #include &quot;MathMLElement.h&quot;</span>
  #include &quot;Node.h&quot;
  #include &quot;ProcessingInstruction.h&quot;
  #include &quot;RegisteredEventListener.h&quot;
  #include &quot;SVGElement.h&quot;
  #include &quot;ScriptState.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 125,33 ***</span>
  {
      JSNode* jsNode = jsCast&lt;JSNode*&gt;(handle.slot()-&gt;asCell());
      return isReachableFromDOM(&amp;jsNode-&gt;wrapped(), visitor, reason);
  }
  
<span class="line-modified">! JSScope* JSNode::pushEventHandlerScope(ExecState* exec, JSScope* node) const</span>
  {
<span class="line-modified">!     if (inherits&lt;JSHTMLElement&gt;(exec-&gt;vm()))</span>
<span class="line-modified">!         return jsCast&lt;const JSHTMLElement*&gt;(this)-&gt;pushEventHandlerScope(exec, node);</span>
      return node;
  }
  
  void JSNode::visitAdditionalChildren(SlotVisitor&amp; visitor)
  {
      visitor.addOpaqueRoot(root(wrapped()));
  }
  
<span class="line-modified">! static ALWAYS_INLINE JSValue createWrapperInline(ExecState* exec, JSDOMGlobalObject* globalObject, Ref&lt;Node&gt;&amp;&amp; node)</span>
  {
      ASSERT(!getCachedWrapper(globalObject-&gt;world(), node));
  
      JSDOMObject* wrapper;
      switch (node-&gt;nodeType()) {
          case Node::ELEMENT_NODE:
              if (is&lt;HTMLElement&gt;(node))
                  wrapper = createJSHTMLWrapper(globalObject, static_reference_cast&lt;HTMLElement&gt;(WTFMove(node)));
              else if (is&lt;SVGElement&gt;(node))
                  wrapper = createJSSVGWrapper(globalObject, static_reference_cast&lt;SVGElement&gt;(WTFMove(node)));
              else
                  wrapper = createWrapper&lt;Element&gt;(globalObject, WTFMove(node));
              break;
          case Node::ATTRIBUTE_NODE:
              wrapper = createWrapper&lt;Attr&gt;(globalObject, WTFMove(node));
<span class="line-new-header">--- 127,37 ---</span>
  {
      JSNode* jsNode = jsCast&lt;JSNode*&gt;(handle.slot()-&gt;asCell());
      return isReachableFromDOM(&amp;jsNode-&gt;wrapped(), visitor, reason);
  }
  
<span class="line-modified">! JSScope* JSNode::pushEventHandlerScope(JSGlobalObject* lexicalGlobalObject, JSScope* node) const</span>
  {
<span class="line-modified">!     if (inherits&lt;JSHTMLElement&gt;(lexicalGlobalObject-&gt;vm()))</span>
<span class="line-modified">!         return jsCast&lt;const JSHTMLElement*&gt;(this)-&gt;pushEventHandlerScope(lexicalGlobalObject, node);</span>
      return node;
  }
  
  void JSNode::visitAdditionalChildren(SlotVisitor&amp; visitor)
  {
      visitor.addOpaqueRoot(root(wrapped()));
  }
  
<span class="line-modified">! static ALWAYS_INLINE JSValue createWrapperInline(JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, Ref&lt;Node&gt;&amp;&amp; node)</span>
  {
      ASSERT(!getCachedWrapper(globalObject-&gt;world(), node));
  
      JSDOMObject* wrapper;
      switch (node-&gt;nodeType()) {
          case Node::ELEMENT_NODE:
              if (is&lt;HTMLElement&gt;(node))
                  wrapper = createJSHTMLWrapper(globalObject, static_reference_cast&lt;HTMLElement&gt;(WTFMove(node)));
              else if (is&lt;SVGElement&gt;(node))
                  wrapper = createJSSVGWrapper(globalObject, static_reference_cast&lt;SVGElement&gt;(WTFMove(node)));
<span class="line-added">+ #if ENABLE(MATHML)</span>
<span class="line-added">+             else if (is&lt;MathMLElement&gt;(node))</span>
<span class="line-added">+                 wrapper = createJSMathMLWrapper(globalObject, static_reference_cast&lt;MathMLElement&gt;(WTFMove(node)));</span>
<span class="line-added">+ #endif</span>
              else
                  wrapper = createWrapper&lt;Element&gt;(globalObject, WTFMove(node));
              break;
          case Node::ATTRIBUTE_NODE:
              wrapper = createWrapper&lt;Attr&gt;(globalObject, WTFMove(node));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 168,11 ***</span>
          case Node::COMMENT_NODE:
              wrapper = createWrapper&lt;Comment&gt;(globalObject, WTFMove(node));
              break;
          case Node::DOCUMENT_NODE:
              // we don&#39;t want to cache the document itself in the per-document dictionary
<span class="line-modified">!             return toJS(exec, globalObject, downcast&lt;Document&gt;(node.get()));</span>
          case Node::DOCUMENT_TYPE_NODE:
              wrapper = createWrapper&lt;DocumentType&gt;(globalObject, WTFMove(node));
              break;
          case Node::DOCUMENT_FRAGMENT_NODE:
              if (node-&gt;isShadowRoot())
<span class="line-new-header">--- 174,11 ---</span>
          case Node::COMMENT_NODE:
              wrapper = createWrapper&lt;Comment&gt;(globalObject, WTFMove(node));
              break;
          case Node::DOCUMENT_NODE:
              // we don&#39;t want to cache the document itself in the per-document dictionary
<span class="line-modified">!             return toJS(lexicalGlobalObject, globalObject, downcast&lt;Document&gt;(node.get()));</span>
          case Node::DOCUMENT_TYPE_NODE:
              wrapper = createWrapper&lt;DocumentType&gt;(globalObject, WTFMove(node));
              break;
          case Node::DOCUMENT_FRAGMENT_NODE:
              if (node-&gt;isShadowRoot())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 185,32 ***</span>
      }
  
      return wrapper;
  }
  
<span class="line-modified">! JSValue createWrapper(ExecState* exec, JSDOMGlobalObject* globalObject, Ref&lt;Node&gt;&amp;&amp; node)</span>
  {
<span class="line-modified">!     return createWrapperInline(exec, globalObject, WTFMove(node));</span>
  }
  
<span class="line-modified">! JSValue toJSNewlyCreated(ExecState* exec, JSDOMGlobalObject* globalObject, Ref&lt;Node&gt;&amp;&amp; node)</span>
  {
<span class="line-modified">!     return createWrapperInline(exec, globalObject, WTFMove(node));</span>
  }
  
  JSC::JSObject* getOutOfLineCachedWrapper(JSDOMGlobalObject* globalObject, Node&amp; node)
  {
      ASSERT(!globalObject-&gt;world().isNormal());
      return globalObject-&gt;world().wrappers().get(&amp;node);
  }
  
  void willCreatePossiblyOrphanedTreeByRemovalSlowCase(Node* root)
  {
<span class="line-modified">!     JSC::ExecState* scriptState = mainWorldExecState(root-&gt;document().frame());</span>
<span class="line-modified">!     if (!scriptState)</span>
          return;
  
<span class="line-modified">!     JSLockHolder lock(scriptState);</span>
<span class="line-modified">!     toJS(scriptState, static_cast&lt;JSDOMGlobalObject*&gt;(scriptState-&gt;lexicalGlobalObject()), *root);</span>
  }
  
  } // namespace WebCore
<span class="line-new-header">--- 191,32 ---</span>
      }
  
      return wrapper;
  }
  
<span class="line-modified">! JSValue createWrapper(JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, Ref&lt;Node&gt;&amp;&amp; node)</span>
  {
<span class="line-modified">!     return createWrapperInline(lexicalGlobalObject, globalObject, WTFMove(node));</span>
  }
  
<span class="line-modified">! JSValue toJSNewlyCreated(JSGlobalObject* lexicalGlobalObject, JSDOMGlobalObject* globalObject, Ref&lt;Node&gt;&amp;&amp; node)</span>
  {
<span class="line-modified">!     return createWrapperInline(lexicalGlobalObject, globalObject, WTFMove(node));</span>
  }
  
  JSC::JSObject* getOutOfLineCachedWrapper(JSDOMGlobalObject* globalObject, Node&amp; node)
  {
      ASSERT(!globalObject-&gt;world().isNormal());
      return globalObject-&gt;world().wrappers().get(&amp;node);
  }
  
  void willCreatePossiblyOrphanedTreeByRemovalSlowCase(Node* root)
  {
<span class="line-modified">!     JSC::JSGlobalObject* lexicalGlobalObject = mainWorldExecState(root-&gt;document().frame());</span>
<span class="line-modified">!     if (!lexicalGlobalObject)</span>
          return;
  
<span class="line-modified">!     JSLockHolder lock(lexicalGlobalObject);</span>
<span class="line-modified">!     toJS(lexicalGlobalObject, static_cast&lt;JSDOMGlobalObject*&gt;(lexicalGlobalObject), *root);</span>
  }
  
  } // namespace WebCore
</pre>
<center><a href="JSNavigatorCustom.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSNodeCustom.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
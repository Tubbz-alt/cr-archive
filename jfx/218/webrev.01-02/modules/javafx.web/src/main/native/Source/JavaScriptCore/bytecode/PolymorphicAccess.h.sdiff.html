<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolymorphicAccess.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PolymorphicAccess.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PreciseJumpTargets.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolymorphicAccess.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2014-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 28 #if ENABLE(JIT)
 29 
 30 #include &quot;AccessCase.h&quot;
 31 #include &quot;JITStubRoutine.h&quot;
 32 #include &quot;JSFunctionInlines.h&quot;
 33 #include &quot;MacroAssembler.h&quot;
 34 #include &quot;ScratchRegisterAllocator.h&quot;
 35 #include &lt;wtf/Vector.h&gt;
 36 
 37 namespace JSC {
 38 namespace DOMJIT {
 39 class GetterSetter;
 40 }
 41 
 42 class CodeBlock;
 43 class PolymorphicAccess;
 44 class StructureStubInfo;
 45 class WatchpointsOnStructureStubInfo;
 46 class ScratchRegisterAllocator;
 47 


 48 class AccessGenerationResult {
 49 public:
 50     enum Kind {
 51         MadeNoChanges,
 52         GaveUp,
 53         Buffered,
 54         GeneratedNewCode,
 55         GeneratedFinalCode, // Generated so much code that we never want to generate code again.
 56         ResetStubAndFireWatchpoints // We found out some data that makes us want to start over fresh with this stub. Currently, this happens when we detect poly proto.
 57     };
 58 
 59 
 60     AccessGenerationResult() = default;
 61     AccessGenerationResult(AccessGenerationResult&amp;&amp;) = default;
 62     AccessGenerationResult&amp; operator=(AccessGenerationResult&amp;&amp;) = default;
 63 
 64     AccessGenerationResult(Kind kind)
 65         : m_kind(kind)
 66     {
 67         RELEASE_ASSERT(kind != GeneratedNewCode);
</pre>
<hr />
<pre>
112 
113     void addWatchpointToFire(InlineWatchpointSet&amp; set, StringFireDetail detail)
114     {
115         m_watchpointsToFire.append(std::pair&lt;InlineWatchpointSet&amp;, StringFireDetail&gt;(set, detail));
116     }
117     void fireWatchpoints(VM&amp; vm)
118     {
119         ASSERT(m_kind == ResetStubAndFireWatchpoints);
120         for (auto&amp; pair : m_watchpointsToFire)
121             pair.first.invalidate(vm, pair.second);
122     }
123 
124 private:
125     Kind m_kind;
126     MacroAssemblerCodePtr&lt;JITStubRoutinePtrTag&gt; m_code;
127     Vector&lt;std::pair&lt;InlineWatchpointSet&amp;, StringFireDetail&gt;&gt; m_watchpointsToFire;
128 };
129 
130 class PolymorphicAccess {
131     WTF_MAKE_NONCOPYABLE(PolymorphicAccess);
<span class="line-modified">132     WTF_MAKE_FAST_ALLOCATED;</span>
133 public:
134     PolymorphicAccess();
135     ~PolymorphicAccess();
136 
137     // When this fails (returns GaveUp), this will leave the old stub intact but you should not try
138     // to call this method again for that PolymorphicAccess instance.
139     AccessGenerationResult addCases(
<span class="line-modified">140         const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;, const Identifier&amp;, Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt;);</span>
141 
142     AccessGenerationResult addCase(
<span class="line-modified">143         const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;, const Identifier&amp;, std::unique_ptr&lt;AccessCase&gt;);</span>
144 
<span class="line-modified">145     AccessGenerationResult regenerate(const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;, const Identifier&amp;);</span>
146 
147     bool isEmpty() const { return m_list.isEmpty(); }
148     unsigned size() const { return m_list.size(); }
149     const AccessCase&amp; at(unsigned i) const { return *m_list[i]; }
150     const AccessCase&amp; operator[](unsigned i) const { return *m_list[i]; }
151 


152     // If this returns false then we are requesting a reset of the owning StructureStubInfo.
153     bool visitWeak(VM&amp;) const;
154 
155     // This returns true if it has marked everything it will ever marked. This can be used as an
156     // optimization to then avoid calling this method again during the fixpoint.
157     bool propagateTransitions(SlotVisitor&amp;) const;
158 
159     void aboutToDie();
160 
161     void dump(PrintStream&amp; out) const;
162     bool containsPC(void* pc) const
163     {
164         if (!m_stubRoutine)
165             return false;
166 
167         uintptr_t pcAsInt = bitwise_cast&lt;uintptr_t&gt;(pc);
168         return m_stubRoutine-&gt;startAddress() &lt;= pcAsInt &amp;&amp; pcAsInt &lt;= m_stubRoutine-&gt;endAddress();
169     }
170 
171 private:
172     friend class AccessCase;
173     friend class CodeBlock;
174     friend struct AccessGenerationState;
175 
176     typedef Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt; ListType;
177 
178     void commit(
179         const GCSafeConcurrentJSLocker&amp;, VM&amp;, std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt;&amp;, CodeBlock*, StructureStubInfo&amp;,
<span class="line-modified">180         const Identifier&amp;, AccessCase&amp;);</span>
181 
182     ListType m_list;
183     RefPtr&lt;JITStubRoutine&gt; m_stubRoutine;
184     std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt; m_watchpoints;
185     std::unique_ptr&lt;Vector&lt;WriteBarrier&lt;JSCell&gt;&gt;&gt; m_weakReferences;
186 };
187 
188 struct AccessGenerationState {
189     AccessGenerationState(VM&amp; vm, JSGlobalObject* globalObject)
190         : m_vm(vm)
191         , m_globalObject(globalObject)
192         , m_calculatedRegistersForCallAndExceptionHandling(false)
193         , m_needsToRestoreRegistersIfException(false)
194         , m_calculatedCallSiteIndex(false)
195     {

196     }
197     VM&amp; m_vm;
198     JSGlobalObject* m_globalObject;
199     CCallHelpers* jit { nullptr };
200     ScratchRegisterAllocator* allocator;
201     ScratchRegisterAllocator::PreservedState preservedReusedRegisterState;
202     PolymorphicAccess* access { nullptr };
203     StructureStubInfo* stubInfo { nullptr };
204     MacroAssembler::JumpList success;
205     MacroAssembler::JumpList failAndRepatch;
206     MacroAssembler::JumpList failAndIgnore;
207     GPRReg baseGPR { InvalidGPRReg };
<span class="line-modified">208     GPRReg thisGPR { InvalidGPRReg };</span>




209     JSValueRegs valueRegs;
210     GPRReg scratchGPR { InvalidGPRReg };
<span class="line-modified">211     const Identifier* ident;</span>
212     std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt; watchpoints;
213     Vector&lt;WriteBarrier&lt;JSCell&gt;&gt; weakReferences;

214 
<span class="line-modified">215     Watchpoint* addWatchpoint(const ObjectPropertyCondition&amp; = ObjectPropertyCondition());</span>
216 
217     void restoreScratch();
218     void succeed();
219 
220     struct SpillState {
221         SpillState() = default;
222         SpillState(RegisterSet&amp;&amp; regs, unsigned usedStackBytes)
223             : spilledRegisters(WTFMove(regs))
224             , numberOfStackBytesUsedForRegisterPreservation(usedStackBytes)
225         {
226         }
227 
228         RegisterSet spilledRegisters { };
229         unsigned numberOfStackBytesUsedForRegisterPreservation { std::numeric_limits&lt;unsigned&gt;::max() };
230 
231         bool isEmpty() const { return numberOfStackBytesUsedForRegisterPreservation == std::numeric_limits&lt;unsigned&gt;::max(); }
232     };
233 
234     const RegisterSet&amp; calculateLiveRegistersForCallAndExceptionHandling();
235 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2014-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 28 #if ENABLE(JIT)
 29 
 30 #include &quot;AccessCase.h&quot;
 31 #include &quot;JITStubRoutine.h&quot;
 32 #include &quot;JSFunctionInlines.h&quot;
 33 #include &quot;MacroAssembler.h&quot;
 34 #include &quot;ScratchRegisterAllocator.h&quot;
 35 #include &lt;wtf/Vector.h&gt;
 36 
 37 namespace JSC {
 38 namespace DOMJIT {
 39 class GetterSetter;
 40 }
 41 
 42 class CodeBlock;
 43 class PolymorphicAccess;
 44 class StructureStubInfo;
 45 class WatchpointsOnStructureStubInfo;
 46 class ScratchRegisterAllocator;
 47 
<span class="line-added"> 48 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(PolymorphicAccess);</span>
<span class="line-added"> 49 </span>
 50 class AccessGenerationResult {
 51 public:
 52     enum Kind {
 53         MadeNoChanges,
 54         GaveUp,
 55         Buffered,
 56         GeneratedNewCode,
 57         GeneratedFinalCode, // Generated so much code that we never want to generate code again.
 58         ResetStubAndFireWatchpoints // We found out some data that makes us want to start over fresh with this stub. Currently, this happens when we detect poly proto.
 59     };
 60 
 61 
 62     AccessGenerationResult() = default;
 63     AccessGenerationResult(AccessGenerationResult&amp;&amp;) = default;
 64     AccessGenerationResult&amp; operator=(AccessGenerationResult&amp;&amp;) = default;
 65 
 66     AccessGenerationResult(Kind kind)
 67         : m_kind(kind)
 68     {
 69         RELEASE_ASSERT(kind != GeneratedNewCode);
</pre>
<hr />
<pre>
114 
115     void addWatchpointToFire(InlineWatchpointSet&amp; set, StringFireDetail detail)
116     {
117         m_watchpointsToFire.append(std::pair&lt;InlineWatchpointSet&amp;, StringFireDetail&gt;(set, detail));
118     }
119     void fireWatchpoints(VM&amp; vm)
120     {
121         ASSERT(m_kind == ResetStubAndFireWatchpoints);
122         for (auto&amp; pair : m_watchpointsToFire)
123             pair.first.invalidate(vm, pair.second);
124     }
125 
126 private:
127     Kind m_kind;
128     MacroAssemblerCodePtr&lt;JITStubRoutinePtrTag&gt; m_code;
129     Vector&lt;std::pair&lt;InlineWatchpointSet&amp;, StringFireDetail&gt;&gt; m_watchpointsToFire;
130 };
131 
132 class PolymorphicAccess {
133     WTF_MAKE_NONCOPYABLE(PolymorphicAccess);
<span class="line-modified">134     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(PolymorphicAccess);</span>
135 public:
136     PolymorphicAccess();
137     ~PolymorphicAccess();
138 
139     // When this fails (returns GaveUp), this will leave the old stub intact but you should not try
140     // to call this method again for that PolymorphicAccess instance.
141     AccessGenerationResult addCases(
<span class="line-modified">142         const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;, Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt;);</span>
143 
144     AccessGenerationResult addCase(
<span class="line-modified">145         const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;, std::unique_ptr&lt;AccessCase&gt;);</span>
146 
<span class="line-modified">147     AccessGenerationResult regenerate(const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;);</span>
148 
149     bool isEmpty() const { return m_list.isEmpty(); }
150     unsigned size() const { return m_list.size(); }
151     const AccessCase&amp; at(unsigned i) const { return *m_list[i]; }
152     const AccessCase&amp; operator[](unsigned i) const { return *m_list[i]; }
153 
<span class="line-added">154     void visitAggregate(SlotVisitor&amp;);</span>
<span class="line-added">155 </span>
156     // If this returns false then we are requesting a reset of the owning StructureStubInfo.
157     bool visitWeak(VM&amp;) const;
158 
159     // This returns true if it has marked everything it will ever marked. This can be used as an
160     // optimization to then avoid calling this method again during the fixpoint.
161     bool propagateTransitions(SlotVisitor&amp;) const;
162 
163     void aboutToDie();
164 
165     void dump(PrintStream&amp; out) const;
166     bool containsPC(void* pc) const
167     {
168         if (!m_stubRoutine)
169             return false;
170 
171         uintptr_t pcAsInt = bitwise_cast&lt;uintptr_t&gt;(pc);
172         return m_stubRoutine-&gt;startAddress() &lt;= pcAsInt &amp;&amp; pcAsInt &lt;= m_stubRoutine-&gt;endAddress();
173     }
174 
175 private:
176     friend class AccessCase;
177     friend class CodeBlock;
178     friend struct AccessGenerationState;
179 
180     typedef Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt; ListType;
181 
182     void commit(
183         const GCSafeConcurrentJSLocker&amp;, VM&amp;, std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt;&amp;, CodeBlock*, StructureStubInfo&amp;,
<span class="line-modified">184         AccessCase&amp;);</span>
185 
186     ListType m_list;
187     RefPtr&lt;JITStubRoutine&gt; m_stubRoutine;
188     std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt; m_watchpoints;
189     std::unique_ptr&lt;Vector&lt;WriteBarrier&lt;JSCell&gt;&gt;&gt; m_weakReferences;
190 };
191 
192 struct AccessGenerationState {
193     AccessGenerationState(VM&amp; vm, JSGlobalObject* globalObject)
194         : m_vm(vm)
195         , m_globalObject(globalObject)
196         , m_calculatedRegistersForCallAndExceptionHandling(false)
197         , m_needsToRestoreRegistersIfException(false)
198         , m_calculatedCallSiteIndex(false)
199     {
<span class="line-added">200         u.thisGPR = InvalidGPRReg;</span>
201     }
202     VM&amp; m_vm;
203     JSGlobalObject* m_globalObject;
204     CCallHelpers* jit { nullptr };
205     ScratchRegisterAllocator* allocator;
206     ScratchRegisterAllocator::PreservedState preservedReusedRegisterState;
207     PolymorphicAccess* access { nullptr };
208     StructureStubInfo* stubInfo { nullptr };
209     MacroAssembler::JumpList success;
210     MacroAssembler::JumpList failAndRepatch;
211     MacroAssembler::JumpList failAndIgnore;
212     GPRReg baseGPR { InvalidGPRReg };
<span class="line-modified">213     union {</span>
<span class="line-added">214         GPRReg thisGPR;</span>
<span class="line-added">215         GPRReg prototypeGPR;</span>
<span class="line-added">216         GPRReg propertyGPR;</span>
<span class="line-added">217     } u;</span>
218     JSValueRegs valueRegs;
219     GPRReg scratchGPR { InvalidGPRReg };
<span class="line-modified">220     FPRReg scratchFPR { InvalidFPRReg };</span>
221     std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt; watchpoints;
222     Vector&lt;WriteBarrier&lt;JSCell&gt;&gt; weakReferences;
<span class="line-added">223     Bag&lt;CallLinkInfo&gt; m_callLinkInfos;</span>
224 
<span class="line-modified">225     void installWatchpoint(const ObjectPropertyCondition&amp;);</span>
226 
227     void restoreScratch();
228     void succeed();
229 
230     struct SpillState {
231         SpillState() = default;
232         SpillState(RegisterSet&amp;&amp; regs, unsigned usedStackBytes)
233             : spilledRegisters(WTFMove(regs))
234             , numberOfStackBytesUsedForRegisterPreservation(usedStackBytes)
235         {
236         }
237 
238         RegisterSet spilledRegisters { };
239         unsigned numberOfStackBytesUsedForRegisterPreservation { std::numeric_limits&lt;unsigned&gt;::max() };
240 
241         bool isEmpty() const { return numberOfStackBytesUsedForRegisterPreservation == std::numeric_limits&lt;unsigned&gt;::max(); }
242     };
243 
244     const RegisterSet&amp; calculateLiveRegistersForCallAndExceptionHandling();
245 
</pre>
</td>
</tr>
</table>
<center><a href="PolymorphicAccess.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PreciseJumpTargets.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGEllipse.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../style/WillChangeData.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGImage.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGEllipse.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 52,47 ***</span>
      m_center = FloatPoint();
      m_radii = FloatSize();
  
      calculateRadiiAndCenter();
  
<span class="line-modified">!     // Element is invalid if either dimension is negative.</span>
<span class="line-modified">!     if (m_radii.width() &lt; 0 || m_radii.height() &lt; 0)</span>
          return;
  
<span class="line-modified">!     // Spec: &quot;A value of zero disables rendering of the element.&quot;</span>
<span class="line-modified">!     if (!m_radii.isEmpty()) {</span>
<span class="line-modified">!         if (hasNonScalingStroke()) {</span>
<span class="line-modified">!             // Fallback to RenderSVGShape if shape has a non-scaling stroke.</span>
<span class="line-modified">!             RenderSVGShape::updateShapeFromElement();</span>
<span class="line-removed">-             m_usePathFallback = true;</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         m_usePathFallback = false;</span>
      }
  
      m_fillBoundingBox = FloatRect(m_center.x() - m_radii.width(), m_center.y() - m_radii.height(), 2 * m_radii.width(), 2 * m_radii.height());
      m_strokeBoundingBox = m_fillBoundingBox;
      if (style().svgStyle().hasStroke())
          m_strokeBoundingBox.inflate(strokeWidth() / 2);
  }
  
  void RenderSVGEllipse::calculateRadiiAndCenter()
  {
      SVGLengthContext lengthContext(&amp;graphicsElement());
      m_center = FloatPoint(
<span class="line-modified">!         lengthContext.valueForLength(style().svgStyle().cx(), LengthModeWidth),</span>
<span class="line-modified">!         lengthContext.valueForLength(style().svgStyle().cy(), LengthModeHeight));</span>
      if (is&lt;SVGCircleElement&gt;(graphicsElement())) {
          float radius = lengthContext.valueForLength(style().svgStyle().r());
          m_radii = FloatSize(radius, radius);
          return;
      }
  
      ASSERT(is&lt;SVGEllipseElement&gt;(graphicsElement()));
      m_radii = FloatSize(
<span class="line-modified">!         lengthContext.valueForLength(style().svgStyle().rx(), LengthModeWidth),</span>
<span class="line-modified">!         lengthContext.valueForLength(style().svgStyle().ry(), LengthModeHeight));</span>
  }
  
  void RenderSVGEllipse::fillShape(GraphicsContext&amp; context) const
  {
      if (m_usePathFallback) {
<span class="line-new-header">--- 52,48 ---</span>
      m_center = FloatPoint();
      m_radii = FloatSize();
  
      calculateRadiiAndCenter();
  
<span class="line-modified">!     // Spec: &quot;A negative value is illegal. A value of zero disables rendering of the element.&quot;</span>
<span class="line-modified">!     if (m_radii.isEmpty())</span>
          return;
  
<span class="line-modified">!     if (hasNonScalingStroke()) {</span>
<span class="line-modified">!         // Fallback to RenderSVGShape if shape has a non-scaling stroke.</span>
<span class="line-modified">!         RenderSVGShape::updateShapeFromElement();</span>
<span class="line-modified">!         m_usePathFallback = true;</span>
<span class="line-modified">!         return;</span>
      }
  
<span class="line-added">+     m_usePathFallback = false;</span>
<span class="line-added">+ </span>
      m_fillBoundingBox = FloatRect(m_center.x() - m_radii.width(), m_center.y() - m_radii.height(), 2 * m_radii.width(), 2 * m_radii.height());
      m_strokeBoundingBox = m_fillBoundingBox;
      if (style().svgStyle().hasStroke())
          m_strokeBoundingBox.inflate(strokeWidth() / 2);
  }
  
  void RenderSVGEllipse::calculateRadiiAndCenter()
  {
      SVGLengthContext lengthContext(&amp;graphicsElement());
      m_center = FloatPoint(
<span class="line-modified">!         lengthContext.valueForLength(style().svgStyle().cx(), SVGLengthMode::Width),</span>
<span class="line-modified">!         lengthContext.valueForLength(style().svgStyle().cy(), SVGLengthMode::Height));</span>
      if (is&lt;SVGCircleElement&gt;(graphicsElement())) {
          float radius = lengthContext.valueForLength(style().svgStyle().r());
          m_radii = FloatSize(radius, radius);
          return;
      }
  
      ASSERT(is&lt;SVGEllipseElement&gt;(graphicsElement()));
<span class="line-added">+ </span>
<span class="line-added">+     Length rx = style().svgStyle().rx();</span>
<span class="line-added">+     Length ry = style().svgStyle().ry();</span>
      m_radii = FloatSize(
<span class="line-modified">!         lengthContext.valueForLength(rx.isAuto() ? ry : rx, SVGLengthMode::Width),</span>
<span class="line-modified">!         lengthContext.valueForLength(ry.isAuto() ? rx : ry, SVGLengthMode::Height));</span>
  }
  
  void RenderSVGEllipse::fillShape(GraphicsContext&amp; context) const
  {
      if (m_usePathFallback) {
</pre>
<center><a href="../style/WillChangeData.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGImage.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArithMode.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGArgumentsUtilities.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGArrayMode.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGArithMode.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 namespace JSC {
 31 
<span class="line-modified"> 32 class ExecState;</span>

 33 using EncodedJSValue = int64_t;
 34 
 35 namespace DFG {
 36 
 37 // Arith::Mode describes the mode of an arithmetic operation that speculates integer.
 38 // Note that not all modes are valid for all operations.
 39 namespace Arith {
 40 enum Mode {
 41     NotSet, // Arithmetic mode is either not relevant because we&#39;re using doubles anyway or we are at a phase in compilation where we don&#39;t know what we&#39;re doing, yet. Should never see this after FixupPhase except for nodes that take doubles as inputs already.
 42     Unchecked, // Don&#39;t check anything and just do the direct hardware operation.
 43     CheckOverflow, // Check for overflow but don&#39;t bother with negative zero.
 44     CheckOverflowAndNegativeZero, // Check for both overflow and negative zero.
 45     DoOverflow // Up-convert to the smallest type that soundly represents all possible results after input type speculation.
 46 };
 47 
 48 // Define the type of operation the rounding operation will perform.
 49 enum class RoundingMode {
 50     Int32, // The round operation produces a integer and -0 is considered as 0.
 51     Int32WithNegativeZeroCheck, // The round operation produces a integer and checks for -0.
 52     Double // The round operation produce a double. The result can be -0, NaN or (+/-)Infinity.
</pre>
<hr />
<pre>
 65     macro(ASinh, asinh) \
 66     macro(ACos, acos) \
 67     macro(ACosh, acosh) \
 68     macro(ATan, atan) \
 69     macro(ATanh, atanh) \
 70     macro(Log, log) \
 71     macro(Log10, log10) \
 72     macro(Log1p, log1p) \
 73     macro(Log2, log2) \
 74     macro(Cbrt, cbrt) \
 75     macro(Exp, exp) \
 76     macro(Expm1, expm1) \
 77 
 78 enum class UnaryType : uint32_t {
 79 #define DFG_ARITH_UNARY_ENUM(capitalizedName, lowerName) capitalizedName,
 80     FOR_EACH_DFG_ARITH_UNARY_OP(DFG_ARITH_UNARY_ENUM)
 81 #undef DFG_ARITH_UNARY_ENUM
 82 };
 83 
 84 typedef double (*UnaryFunction)(double);
<span class="line-modified"> 85 typedef double (*UnaryOperation)(ExecState*, EncodedJSValue);</span>
 86 
 87 } // namespace Arith
 88 
 89 inline bool doesOverflow(Arith::Mode mode)
 90 {
 91     switch (mode) {
 92     case Arith::NotSet:
 93         ASSERT_NOT_REACHED();
<span class="line-modified"> 94 #if ASSERT_DISABLED</span>
 95         FALLTHROUGH;
 96 #endif
 97     case Arith::Unchecked:
 98     case Arith::CheckOverflow:
 99     case Arith::CheckOverflowAndNegativeZero:
100         return false;
101     case Arith::DoOverflow:
102         return true;
103     }
104     ASSERT_NOT_REACHED();
105     return true;
106 }
107 
108 // It&#39;s only valid to call this once you&#39;ve determined that you don&#39;t need to *do*
109 // overflow. For most nodes, that&#39;s implicit.
110 inline bool shouldCheckOverflow(Arith::Mode mode)
111 {
112     switch (mode) {
113     case Arith::NotSet:
114     case Arith::DoOverflow:
</pre>
</td>
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(DFG_JIT)
 29 
 30 namespace JSC {
 31 
<span class="line-modified"> 32 class CallFrame;</span>
<span class="line-added"> 33 class JSGlobalObject;</span>
 34 using EncodedJSValue = int64_t;
 35 
 36 namespace DFG {
 37 
 38 // Arith::Mode describes the mode of an arithmetic operation that speculates integer.
 39 // Note that not all modes are valid for all operations.
 40 namespace Arith {
 41 enum Mode {
 42     NotSet, // Arithmetic mode is either not relevant because we&#39;re using doubles anyway or we are at a phase in compilation where we don&#39;t know what we&#39;re doing, yet. Should never see this after FixupPhase except for nodes that take doubles as inputs already.
 43     Unchecked, // Don&#39;t check anything and just do the direct hardware operation.
 44     CheckOverflow, // Check for overflow but don&#39;t bother with negative zero.
 45     CheckOverflowAndNegativeZero, // Check for both overflow and negative zero.
 46     DoOverflow // Up-convert to the smallest type that soundly represents all possible results after input type speculation.
 47 };
 48 
 49 // Define the type of operation the rounding operation will perform.
 50 enum class RoundingMode {
 51     Int32, // The round operation produces a integer and -0 is considered as 0.
 52     Int32WithNegativeZeroCheck, // The round operation produces a integer and checks for -0.
 53     Double // The round operation produce a double. The result can be -0, NaN or (+/-)Infinity.
</pre>
<hr />
<pre>
 66     macro(ASinh, asinh) \
 67     macro(ACos, acos) \
 68     macro(ACosh, acosh) \
 69     macro(ATan, atan) \
 70     macro(ATanh, atanh) \
 71     macro(Log, log) \
 72     macro(Log10, log10) \
 73     macro(Log1p, log1p) \
 74     macro(Log2, log2) \
 75     macro(Cbrt, cbrt) \
 76     macro(Exp, exp) \
 77     macro(Expm1, expm1) \
 78 
 79 enum class UnaryType : uint32_t {
 80 #define DFG_ARITH_UNARY_ENUM(capitalizedName, lowerName) capitalizedName,
 81     FOR_EACH_DFG_ARITH_UNARY_OP(DFG_ARITH_UNARY_ENUM)
 82 #undef DFG_ARITH_UNARY_ENUM
 83 };
 84 
 85 typedef double (*UnaryFunction)(double);
<span class="line-modified"> 86 typedef double (*UnaryOperation)(JSGlobalObject*, EncodedJSValue);</span>
 87 
 88 } // namespace Arith
 89 
 90 inline bool doesOverflow(Arith::Mode mode)
 91 {
 92     switch (mode) {
 93     case Arith::NotSet:
 94         ASSERT_NOT_REACHED();
<span class="line-modified"> 95 #if !ASSERT_ENABLED</span>
 96         FALLTHROUGH;
 97 #endif
 98     case Arith::Unchecked:
 99     case Arith::CheckOverflow:
100     case Arith::CheckOverflowAndNegativeZero:
101         return false;
102     case Arith::DoOverflow:
103         return true;
104     }
105     ASSERT_NOT_REACHED();
106     return true;
107 }
108 
109 // It&#39;s only valid to call this once you&#39;ve determined that you don&#39;t need to *do*
110 // overflow. For most nodes, that&#39;s implicit.
111 inline bool shouldCheckOverflow(Arith::Mode mode)
112 {
113     switch (mode) {
114     case Arith::NotSet:
115     case Arith::DoOverflow:
</pre>
</td>
</tr>
</table>
<center><a href="DFGArgumentsUtilities.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGArrayMode.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
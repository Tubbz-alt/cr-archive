<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RootInlineBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderView.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectionRangeData.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RootInlineBox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 92,11 ***</span>
      }
  }
  
  bool RootInlineBox::isHyphenated() const
  {
<span class="line-modified">!     for (InlineBox* box = firstLeafChild(); box; box = box-&gt;nextLeafChild()) {</span>
          if (is&lt;InlineTextBox&gt;(*box) &amp;&amp; downcast&lt;InlineTextBox&gt;(*box).hasHyphen())
              return true;
      }
      return false;
  }
<span class="line-new-header">--- 92,11 ---</span>
      }
  }
  
  bool RootInlineBox::isHyphenated() const
  {
<span class="line-modified">!     for (InlineBox* box = firstLeafDescendant(); box; box = box-&gt;nextLeafOnLine()) {</span>
          if (is&lt;InlineTextBox&gt;(*box) &amp;&amp; downcast&lt;InlineTextBox&gt;(*box).hasHyphen())
              return true;
      }
      return false;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 450,11 ***</span>
      // We can see that the |bbb| run is not part of the selection while the runs around it are.
      if (firstBox &amp;&amp; firstBox != lastBox) {
          // Now fill in any gaps on the line that occurred between two selected elements.
          LayoutUnit lastLogicalLeft { firstBox-&gt;logicalRight() };
          bool isPreviousBoxSelected = firstBox-&gt;selectionState() != RenderObject::SelectionNone;
<span class="line-modified">!         for (InlineBox* box = firstBox-&gt;nextLeafChild(); box; box = box-&gt;nextLeafChild()) {</span>
              if (box-&gt;selectionState() != RenderObject::SelectionNone) {
                  LayoutRect logicalRect { lastLogicalLeft, selTop, LayoutUnit(box-&gt;logicalLeft() - lastLogicalLeft), selHeight };
                  logicalRect.move(renderer().isHorizontalWritingMode() ? offsetFromRootBlock : LayoutSize(offsetFromRootBlock.height(), offsetFromRootBlock.width()));
                  LayoutRect gapRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, logicalRect);
                  if (isPreviousBoxSelected &amp;&amp; gapRect.width() &gt; 0 &amp;&amp; gapRect.height() &gt; 0) {
<span class="line-new-header">--- 450,11 ---</span>
      // We can see that the |bbb| run is not part of the selection while the runs around it are.
      if (firstBox &amp;&amp; firstBox != lastBox) {
          // Now fill in any gaps on the line that occurred between two selected elements.
          LayoutUnit lastLogicalLeft { firstBox-&gt;logicalRight() };
          bool isPreviousBoxSelected = firstBox-&gt;selectionState() != RenderObject::SelectionNone;
<span class="line-modified">!         for (InlineBox* box = firstBox-&gt;nextLeafOnLine(); box; box = box-&gt;nextLeafOnLine()) {</span>
              if (box-&gt;selectionState() != RenderObject::SelectionNone) {
                  LayoutRect logicalRect { lastLogicalLeft, selTop, LayoutUnit(box-&gt;logicalLeft() - lastLogicalLeft), selHeight };
                  logicalRect.move(renderer().isHorizontalWritingMode() ? offsetFromRootBlock : LayoutSize(offsetFromRootBlock.height(), offsetFromRootBlock.width()));
                  LayoutRect gapRect = rootBlock.logicalRectToPhysicalRect(rootBlockPhysicalPosition, logicalRect);
                  if (isPreviousBoxSelected &amp;&amp; gapRect.width() &gt; 0 &amp;&amp; gapRect.height() &gt; 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 529,11 ***</span>
  
  RenderObject::SelectionState RootInlineBox::selectionState()
  {
      // Walk over all of the selected boxes.
      RenderObject::SelectionState state = RenderObject::SelectionNone;
<span class="line-modified">!     for (InlineBox* box = firstLeafChild(); box; box = box-&gt;nextLeafChild()) {</span>
          RenderObject::SelectionState boxState = box-&gt;selectionState();
          if ((boxState == RenderObject::SelectionStart &amp;&amp; state == RenderObject::SelectionEnd) ||
              (boxState == RenderObject::SelectionEnd &amp;&amp; state == RenderObject::SelectionStart))
              state = RenderObject::SelectionBoth;
          else if (state == RenderObject::SelectionNone ||
<span class="line-new-header">--- 529,11 ---</span>
  
  RenderObject::SelectionState RootInlineBox::selectionState()
  {
      // Walk over all of the selected boxes.
      RenderObject::SelectionState state = RenderObject::SelectionNone;
<span class="line-modified">!     for (InlineBox* box = firstLeafDescendant(); box; box = box-&gt;nextLeafOnLine()) {</span>
          RenderObject::SelectionState boxState = box-&gt;selectionState();
          if ((boxState == RenderObject::SelectionStart &amp;&amp; state == RenderObject::SelectionEnd) ||
              (boxState == RenderObject::SelectionEnd &amp;&amp; state == RenderObject::SelectionStart))
              state = RenderObject::SelectionBoth;
          else if (state == RenderObject::SelectionNone ||
</pre>
<hr />
<pre>
<span class="line-old-header">*** 551,20 ***</span>
      return state;
  }
  
  InlineBox* RootInlineBox::firstSelectedBox()
  {
<span class="line-modified">!     for (auto* box = firstLeafChild(); box; box = box-&gt;nextLeafChild()) {</span>
          if (box-&gt;selectionState() != RenderObject::SelectionNone)
              return box;
      }
      return nullptr;
  }
  
  InlineBox* RootInlineBox::lastSelectedBox()
  {
<span class="line-modified">!     for (auto* box = lastLeafChild(); box; box = box-&gt;prevLeafChild()) {</span>
          if (box-&gt;selectionState() != RenderObject::SelectionNone)
              return box;
      }
      return nullptr;
  }
<span class="line-new-header">--- 551,20 ---</span>
      return state;
  }
  
  InlineBox* RootInlineBox::firstSelectedBox()
  {
<span class="line-modified">!     for (auto* box = firstLeafDescendant(); box; box = box-&gt;nextLeafOnLine()) {</span>
          if (box-&gt;selectionState() != RenderObject::SelectionNone)
              return box;
      }
      return nullptr;
  }
  
  InlineBox* RootInlineBox::lastSelectedBox()
  {
<span class="line-modified">!     for (auto* box = lastLeafDescendant(); box; box = box-&gt;previousLeafOnLine()) {</span>
          if (box-&gt;selectionState() != RenderObject::SelectionNone)
              return box;
      }
      return nullptr;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 764,18 ***</span>
      return closestLeafChildForLogicalLeftPosition(blockFlow().isHorizontalWritingMode() ? pointInContents.x() : pointInContents.y(), onlyEditableLeaves);
  }
  
  InlineBox* RootInlineBox::closestLeafChildForLogicalLeftPosition(int leftPosition, bool onlyEditableLeaves)
  {
<span class="line-modified">!     InlineBox* firstLeaf = firstLeafChild();</span>
<span class="line-modified">!     InlineBox* lastLeaf = lastLeafChild();</span>
  
      if (firstLeaf != lastLeaf) {
          if (firstLeaf-&gt;isLineBreak())
<span class="line-modified">!             firstLeaf = firstLeaf-&gt;nextLeafChildIgnoringLineBreak();</span>
          else if (lastLeaf-&gt;isLineBreak())
<span class="line-modified">!             lastLeaf = lastLeaf-&gt;prevLeafChildIgnoringLineBreak();</span>
      }
  
      if (firstLeaf == lastLeaf &amp;&amp; (!onlyEditableLeaves || isEditableLeaf(firstLeaf)))
          return firstLeaf;
  
<span class="line-new-header">--- 764,18 ---</span>
      return closestLeafChildForLogicalLeftPosition(blockFlow().isHorizontalWritingMode() ? pointInContents.x() : pointInContents.y(), onlyEditableLeaves);
  }
  
  InlineBox* RootInlineBox::closestLeafChildForLogicalLeftPosition(int leftPosition, bool onlyEditableLeaves)
  {
<span class="line-modified">!     InlineBox* firstLeaf = firstLeafDescendant();</span>
<span class="line-modified">!     InlineBox* lastLeaf = lastLeafDescendant();</span>
  
      if (firstLeaf != lastLeaf) {
          if (firstLeaf-&gt;isLineBreak())
<span class="line-modified">!             firstLeaf = firstLeaf-&gt;nextLeafOnLineIgnoringLineBreak();</span>
          else if (lastLeaf-&gt;isLineBreak())
<span class="line-modified">!             lastLeaf = lastLeaf-&gt;previousLeafOnLineIgnoringLineBreak();</span>
      }
  
      if (firstLeaf == lastLeaf &amp;&amp; (!onlyEditableLeaves || isEditableLeaf(firstLeaf)))
          return firstLeaf;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 789,11 ***</span>
          // The leftPosition coordinate is greater or equal to right edge of the lastLeaf.
          // Return it.
          return lastLeaf;
  
      InlineBox* closestLeaf = nullptr;
<span class="line-modified">!     for (InlineBox* leaf = firstLeaf; leaf; leaf = leaf-&gt;nextLeafChildIgnoringLineBreak()) {</span>
          if (!leaf-&gt;renderer().isListMarker() &amp;&amp; (!onlyEditableLeaves || isEditableLeaf(leaf))) {
              closestLeaf = leaf;
              if (leftPosition &lt; leaf-&gt;logicalRight())
                  // The x coordinate is less than the right edge of the box.
                  // Return it.
<span class="line-new-header">--- 789,11 ---</span>
          // The leftPosition coordinate is greater or equal to right edge of the lastLeaf.
          // Return it.
          return lastLeaf;
  
      InlineBox* closestLeaf = nullptr;
<span class="line-modified">!     for (InlineBox* leaf = firstLeaf; leaf; leaf = leaf-&gt;nextLeafOnLineIgnoringLineBreak()) {</span>
          if (!leaf-&gt;renderer().isListMarker() &amp;&amp; (!onlyEditableLeaves || isEditableLeaf(leaf))) {
              closestLeaf = leaf;
              if (leftPosition &lt; leaf-&gt;logicalRight())
                  // The x coordinate is less than the right edge of the box.
                  // Return it.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 826,11 ***</span>
      return gEllipsisBoxMap-&gt;get(this);
  }
  
  void RootInlineBox::removeLineBoxFromRenderObject()
  {
<span class="line-modified">!     blockFlow().complexLineLayout()-&gt;lineBoxes().removeLineBox(this);</span>
  }
  
  void RootInlineBox::extractLineBoxFromRenderObject()
  {
      blockFlow().complexLineLayout()-&gt;lineBoxes().extractLineBox(this);
<span class="line-new-header">--- 826,13 ---</span>
      return gEllipsisBoxMap-&gt;get(this);
  }
  
  void RootInlineBox::removeLineBoxFromRenderObject()
  {
<span class="line-modified">!     // Null if we are destroying ComplexLineLayout.</span>
<span class="line-added">+     if (auto* complexLineLayout = blockFlow().complexLineLayout())</span>
<span class="line-added">+         complexLineLayout-&gt;lineBoxes().removeLineBox(this);</span>
  }
  
  void RootInlineBox::extractLineBoxFromRenderObject()
  {
      blockFlow().complexLineLayout()-&gt;lineBoxes().extractLineBox(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 880,11 ***</span>
      bool ascentDescentSet = false;
  
      // Replaced boxes will return 0 for the line-height if line-box-contain says they are
      // not to be included.
      if (box.renderer().isReplaced()) {
<span class="line-modified">!         if (lineStyle().lineBoxContain() &amp; LineBoxContainReplaced) {</span>
              ascent = box.baselinePosition(baselineType());
              descent = box.lineHeight() - ascent;
  
              // Replaced elements always affect both the ascent and descent.
              affectsAscent = true;
<span class="line-new-header">--- 882,11 ---</span>
      bool ascentDescentSet = false;
  
      // Replaced boxes will return 0 for the line-height if line-box-contain says they are
      // not to be included.
      if (box.renderer().isReplaced()) {
<span class="line-modified">!         if (lineStyle().lineBoxContain().contains(LineBoxContain::Replaced)) {</span>
              ascent = box.baselinePosition(baselineType());
              descent = box.lineHeight() - ascent;
  
              // Replaced elements always affect both the ascent and descent.
              affectsAscent = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1066,70 ***</span>
  bool RootInlineBox::includeLeadingForBox(InlineBox&amp; box) const
  {
      if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
          return false;
  
<span class="line-modified">!     LineBoxContain lineBoxContain = renderer().style().lineBoxContain();</span>
<span class="line-modified">!     return (lineBoxContain &amp; LineBoxContainInline) || (&amp;box == this &amp;&amp; (lineBoxContain &amp; LineBoxContainBlock));</span>
  }
  
  bool RootInlineBox::includeFontForBox(InlineBox&amp; box) const
  {
      if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
          return false;
  
      if (!box.behavesLikeText() &amp;&amp; is&lt;InlineFlowBox&gt;(box) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(box).hasTextChildren())
          return false;
  
<span class="line-modified">!     LineBoxContain lineBoxContain = renderer().style().lineBoxContain();</span>
<span class="line-removed">-     return (lineBoxContain &amp; LineBoxContainFont);</span>
  }
  
  bool RootInlineBox::includeGlyphsForBox(InlineBox&amp; box) const
  {
      if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
          return false;
  
      if (!box.behavesLikeText() &amp;&amp; is&lt;InlineFlowBox&gt;(box) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(box).hasTextChildren())
          return false;
  
<span class="line-modified">!     LineBoxContain lineBoxContain = renderer().style().lineBoxContain();</span>
<span class="line-removed">-     return (lineBoxContain &amp; LineBoxContainGlyphs);</span>
  }
  
  bool RootInlineBox::includeInitialLetterForBox(InlineBox&amp; box) const
  {
      if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
          return false;
  
      if (!box.behavesLikeText() &amp;&amp; is&lt;InlineFlowBox&gt;(box) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(box).hasTextChildren())
          return false;
  
<span class="line-modified">!     LineBoxContain lineBoxContain = renderer().style().lineBoxContain();</span>
<span class="line-removed">-     return (lineBoxContain &amp; LineBoxContainInitialLetter);</span>
  }
  
  bool RootInlineBox::includeMarginForBox(InlineBox&amp; box) const
  {
      if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
          return false;
  
<span class="line-modified">!     LineBoxContain lineBoxContain = renderer().style().lineBoxContain();</span>
<span class="line-removed">-     return lineBoxContain &amp; LineBoxContainInlineBox;</span>
  }
  
<span class="line-removed">- </span>
  bool RootInlineBox::fitsToGlyphs() const
  {
<span class="line-modified">!     LineBoxContain lineBoxContain = renderer().style().lineBoxContain();</span>
<span class="line-removed">-     return ((lineBoxContain &amp; LineBoxContainGlyphs) || (lineBoxContain &amp; LineBoxContainInitialLetter));</span>
  }
  
  bool RootInlineBox::includesRootLineBoxFontOrLeading() const
  {
<span class="line-modified">!     LineBoxContain lineBoxContain = renderer().style().lineBoxContain();</span>
<span class="line-removed">-     return (lineBoxContain &amp; LineBoxContainBlock) || (lineBoxContain &amp; LineBoxContainInline) || (lineBoxContain &amp; LineBoxContainFont);</span>
  }
  
  Node* RootInlineBox::getLogicalStartBoxWithNode(InlineBox*&amp; startBox) const
  {
      Vector&lt;InlineBox*&gt; leafBoxesInLogicalOrder;
<span class="line-new-header">--- 1068,63 ---</span>
  bool RootInlineBox::includeLeadingForBox(InlineBox&amp; box) const
  {
      if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
          return false;
  
<span class="line-modified">!     auto lineBoxContain = renderer().style().lineBoxContain();</span>
<span class="line-modified">!     return lineBoxContain.contains(LineBoxContain::Inline) || (&amp;box == this &amp;&amp; lineBoxContain.contains(LineBoxContain::Block));</span>
  }
  
  bool RootInlineBox::includeFontForBox(InlineBox&amp; box) const
  {
      if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
          return false;
  
      if (!box.behavesLikeText() &amp;&amp; is&lt;InlineFlowBox&gt;(box) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(box).hasTextChildren())
          return false;
  
<span class="line-modified">!     return renderer().style().lineBoxContain().contains(LineBoxContain::Font);</span>
  }
  
  bool RootInlineBox::includeGlyphsForBox(InlineBox&amp; box) const
  {
      if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
          return false;
  
      if (!box.behavesLikeText() &amp;&amp; is&lt;InlineFlowBox&gt;(box) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(box).hasTextChildren())
          return false;
  
<span class="line-modified">!     return renderer().style().lineBoxContain().contains(LineBoxContain::Glyphs);</span>
  }
  
  bool RootInlineBox::includeInitialLetterForBox(InlineBox&amp; box) const
  {
      if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
          return false;
  
      if (!box.behavesLikeText() &amp;&amp; is&lt;InlineFlowBox&gt;(box) &amp;&amp; !downcast&lt;InlineFlowBox&gt;(box).hasTextChildren())
          return false;
  
<span class="line-modified">!     return renderer().style().lineBoxContain().contains(LineBoxContain::InitialLetter);</span>
  }
  
  bool RootInlineBox::includeMarginForBox(InlineBox&amp; box) const
  {
      if (box.renderer().isReplaced() || (box.renderer().isTextOrLineBreak() &amp;&amp; !box.behavesLikeText()))
          return false;
  
<span class="line-modified">!     return renderer().style().lineBoxContain().contains(LineBoxContain::InlineBox);</span>
  }
  
  bool RootInlineBox::fitsToGlyphs() const
  {
<span class="line-modified">!     return renderer().style().lineBoxContain().containsAny({ LineBoxContain::Glyphs, LineBoxContain::InitialLetter });</span>
  }
  
  bool RootInlineBox::includesRootLineBoxFontOrLeading() const
  {
<span class="line-modified">!     return renderer().style().lineBoxContain().containsAny({ LineBoxContain::Block, LineBoxContain::Inline, LineBoxContain::Font });</span>
  }
  
  Node* RootInlineBox::getLogicalStartBoxWithNode(InlineBox*&amp; startBox) const
  {
      Vector&lt;InlineBox*&gt; leafBoxesInLogicalOrder;
</pre>
<center><a href="RenderView.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectionRangeData.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
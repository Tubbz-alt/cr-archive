<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLThunks.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FTLState.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLThunks.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLThunks.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 69     unsigned numberOfRequiredPops = 0;
 70     do {
 71         jit.pushToSave(GPRInfo::regT0);
 72         stackMisalignment += MacroAssembler::pushToSaveByteOffset();
 73         numberOfRequiredPops++;
 74     } while (stackMisalignment % stackAlignmentBytes());
 75 
 76     ScratchBuffer* scratchBuffer = vm.scratchBufferForSize(requiredScratchMemorySizeInBytes());
 77     char* buffer = static_cast&lt;char*&gt;(scratchBuffer-&gt;dataBuffer());
 78 
 79     saveAllRegisters(jit, buffer);
 80 
 81     // Tell GC mark phase how much of the scratch buffer is active during call.
 82     jit.move(MacroAssembler::TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), GPRInfo::nonArgGPR0);
 83     jit.storePtr(MacroAssembler::TrustedImmPtr(requiredScratchMemorySizeInBytes()), GPRInfo::nonArgGPR0);
 84 
 85     jit.loadPtr(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
 86     jit.peek(
 87         GPRInfo::argumentGPR1,
 88         (stackMisalignment - MacroAssembler::pushToSaveByteOffset()) / sizeof(void*));

 89     MacroAssembler::Call functionCall = jit.call(OperationPtrTag);
 90 
 91     // At this point we want to make a tail call to what was returned to us in the
 92     // returnValueGPR. But at the same time as we do this, we must restore all registers.
 93     // The way we will accomplish this is by arranging to have the tail call target in the
 94     // return address &quot;slot&quot; (be it a register or the stack).
 95 
 96     jit.move(GPRInfo::returnValueGPR, GPRInfo::regT0);
 97 
 98     // Make sure we tell the GC that we&#39;re not using the scratch buffer anymore.
 99     jit.move(MacroAssembler::TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), GPRInfo::regT1);
100     jit.storePtr(MacroAssembler::TrustedImmPtr(nullptr), GPRInfo::regT1);
101 
102     // Prepare for tail call.
103     while (numberOfRequiredPops--)
104         jit.popToRestore(GPRInfo::regT1);
105     jit.popToRestore(MacroAssembler::framePointerRegister);
106 
107     // When we came in here, there was an additional thing pushed to the stack. Some clients want it
108     // popped before proceeding.
</pre>
<hr />
<pre>
115 
116     restoreAllRegisters(jit, buffer);
117 
118 #if CPU(ARM64E)
119     jit.untagPtr(resultTag, AssemblyHelpers::linkRegister);
120     jit.tagReturnAddress();
121 #else
122     UNUSED_PARAM(resultTag);
123 #endif
124     jit.ret();
125 
126     LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID);
127     patchBuffer.link(functionCall, generationFunction.retagged&lt;OperationPtrTag&gt;());
128     return FINALIZE_CODE(patchBuffer, JITThunkPtrTag, &quot;%s&quot;, name);
129 }
130 
131 MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; osrExitGenerationThunkGenerator(VM&amp; vm)
132 {
133     unsigned extraPopsToRestore = 0;
134     return genericGenerationThunkGenerator(
<span class="line-modified">135         vm, compileFTLOSRExit, OSRExitPtrTag, &quot;FTL OSR exit generation thunk&quot;, extraPopsToRestore, FrameAndStackAdjustmentRequirement::Needed);</span>
136 }
137 
138 MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; lazySlowPathGenerationThunkGenerator(VM&amp; vm)
139 {
140     unsigned extraPopsToRestore = 1;
141     return genericGenerationThunkGenerator(
<span class="line-modified">142         vm, compileFTLLazySlowPath, JITStubRoutinePtrTag, &quot;FTL lazy slow path generation thunk&quot;, extraPopsToRestore, FrameAndStackAdjustmentRequirement::NotNeeded);</span>
143 }
144 
145 static void registerClobberCheck(AssemblyHelpers&amp; jit, RegisterSet dontClobber)
146 {
147     if (!Options::clobberAllRegsInFTLICSlowPath())
148         return;
149 
150     RegisterSet clobber = RegisterSet::allRegisters();
151     clobber.exclude(RegisterSet::reservedHardwareRegisters());
152     clobber.exclude(RegisterSet::stackRegisters());
153     clobber.exclude(RegisterSet::calleeSaveRegisters());
154     clobber.exclude(dontClobber);
155 
<span class="line-modified">156     GPRReg someGPR;</span>
157     for (Reg reg = Reg::first(); reg &lt;= Reg::last(); reg = reg.next()) {
158         if (!clobber.get(reg) || !reg.isGPR())
159             continue;
160 
161         jit.move(AssemblyHelpers::TrustedImm32(0x1337beef), reg.gpr());
162         someGPR = reg.gpr();
163     }
164 
165     for (Reg reg = Reg::first(); reg &lt;= Reg::last(); reg = reg.next()) {
166         if (!clobber.get(reg) || !reg.isFPR())
167             continue;
168 
169         jit.move64ToDouble(someGPR, reg.fpr());
170     }
171 }
172 
<span class="line-modified">173 MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; slowPathCallThunkGenerator(const SlowPathCallKey&amp; key)</span>
174 {
175     AssemblyHelpers jit(nullptr);
176     jit.tagReturnAddress();
177 
178     // We want to save the given registers at the given offset, then we want to save the
179     // old return address somewhere past that offset, and then finally we want to make the
180     // call.
181 
182     size_t currentOffset = key.offset() + sizeof(void*);
183 
<span class="line-modified">184 #if CPU(X86) || CPU(X86_64)</span>
185     currentOffset += sizeof(void*);
186 #endif
187 
188     for (MacroAssembler::RegisterID reg = MacroAssembler::firstRegister(); reg &lt;= MacroAssembler::lastRegister(); reg = static_cast&lt;MacroAssembler::RegisterID&gt;(reg + 1)) {
189         if (!key.usedRegisters().get(reg))
190             continue;
191         jit.storePtr(reg, AssemblyHelpers::Address(MacroAssembler::stackPointerRegister, currentOffset));
192         currentOffset += sizeof(void*);
193     }
194 
195     for (MacroAssembler::FPRegisterID reg = MacroAssembler::firstFPRegister(); reg &lt;= MacroAssembler::lastFPRegister(); reg = static_cast&lt;MacroAssembler::FPRegisterID&gt;(reg + 1)) {
196         if (!key.usedRegisters().get(reg))
197             continue;
198         jit.storeDouble(reg, AssemblyHelpers::Address(MacroAssembler::stackPointerRegister, currentOffset));
199         currentOffset += sizeof(double);
200     }
201 
202     jit.preserveReturnAddressAfterCall(GPRInfo::nonArgGPR0);
203     jit.storePtr(GPRInfo::nonArgGPR0, AssemblyHelpers::Address(MacroAssembler::stackPointerRegister, key.offset()));

204 
205     registerClobberCheck(jit, key.argumentRegisters());
206 
207     AssemblyHelpers::Call call = jit.call(OperationPtrTag);
208 
209     jit.loadPtr(AssemblyHelpers::Address(MacroAssembler::stackPointerRegister, key.offset()), GPRInfo::nonPreservedNonReturnGPR);
210     jit.restoreReturnAddressBeforeReturn(GPRInfo::nonPreservedNonReturnGPR);
211 
212     for (MacroAssembler::FPRegisterID reg = MacroAssembler::lastFPRegister(); ; reg = static_cast&lt;MacroAssembler::FPRegisterID&gt;(reg - 1)) {
213         if (key.usedRegisters().get(reg)) {
214             currentOffset -= sizeof(double);
215             jit.loadDouble(AssemblyHelpers::Address(MacroAssembler::stackPointerRegister, currentOffset), reg);
216         }
217         if (reg == MacroAssembler::firstFPRegister())
218             break;
219     }
220 
221     for (MacroAssembler::RegisterID reg = MacroAssembler::lastRegister(); ; reg = static_cast&lt;MacroAssembler::RegisterID&gt;(reg - 1)) {
222         if (key.usedRegisters().get(reg)) {
223             currentOffset -= sizeof(void*);
</pre>
</td>
<td>
<hr />
<pre>
 69     unsigned numberOfRequiredPops = 0;
 70     do {
 71         jit.pushToSave(GPRInfo::regT0);
 72         stackMisalignment += MacroAssembler::pushToSaveByteOffset();
 73         numberOfRequiredPops++;
 74     } while (stackMisalignment % stackAlignmentBytes());
 75 
 76     ScratchBuffer* scratchBuffer = vm.scratchBufferForSize(requiredScratchMemorySizeInBytes());
 77     char* buffer = static_cast&lt;char*&gt;(scratchBuffer-&gt;dataBuffer());
 78 
 79     saveAllRegisters(jit, buffer);
 80 
 81     // Tell GC mark phase how much of the scratch buffer is active during call.
 82     jit.move(MacroAssembler::TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), GPRInfo::nonArgGPR0);
 83     jit.storePtr(MacroAssembler::TrustedImmPtr(requiredScratchMemorySizeInBytes()), GPRInfo::nonArgGPR0);
 84 
 85     jit.loadPtr(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
 86     jit.peek(
 87         GPRInfo::argumentGPR1,
 88         (stackMisalignment - MacroAssembler::pushToSaveByteOffset()) / sizeof(void*));
<span class="line-added"> 89     jit.prepareCallOperation(vm);</span>
 90     MacroAssembler::Call functionCall = jit.call(OperationPtrTag);
 91 
 92     // At this point we want to make a tail call to what was returned to us in the
 93     // returnValueGPR. But at the same time as we do this, we must restore all registers.
 94     // The way we will accomplish this is by arranging to have the tail call target in the
 95     // return address &quot;slot&quot; (be it a register or the stack).
 96 
 97     jit.move(GPRInfo::returnValueGPR, GPRInfo::regT0);
 98 
 99     // Make sure we tell the GC that we&#39;re not using the scratch buffer anymore.
100     jit.move(MacroAssembler::TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), GPRInfo::regT1);
101     jit.storePtr(MacroAssembler::TrustedImmPtr(nullptr), GPRInfo::regT1);
102 
103     // Prepare for tail call.
104     while (numberOfRequiredPops--)
105         jit.popToRestore(GPRInfo::regT1);
106     jit.popToRestore(MacroAssembler::framePointerRegister);
107 
108     // When we came in here, there was an additional thing pushed to the stack. Some clients want it
109     // popped before proceeding.
</pre>
<hr />
<pre>
116 
117     restoreAllRegisters(jit, buffer);
118 
119 #if CPU(ARM64E)
120     jit.untagPtr(resultTag, AssemblyHelpers::linkRegister);
121     jit.tagReturnAddress();
122 #else
123     UNUSED_PARAM(resultTag);
124 #endif
125     jit.ret();
126 
127     LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID);
128     patchBuffer.link(functionCall, generationFunction.retagged&lt;OperationPtrTag&gt;());
129     return FINALIZE_CODE(patchBuffer, JITThunkPtrTag, &quot;%s&quot;, name);
130 }
131 
132 MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; osrExitGenerationThunkGenerator(VM&amp; vm)
133 {
134     unsigned extraPopsToRestore = 0;
135     return genericGenerationThunkGenerator(
<span class="line-modified">136         vm, operationCompileFTLOSRExit, OSRExitPtrTag, &quot;FTL OSR exit generation thunk&quot;, extraPopsToRestore, FrameAndStackAdjustmentRequirement::Needed);</span>
137 }
138 
139 MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; lazySlowPathGenerationThunkGenerator(VM&amp; vm)
140 {
141     unsigned extraPopsToRestore = 1;
142     return genericGenerationThunkGenerator(
<span class="line-modified">143         vm, operationCompileFTLLazySlowPath, JITStubRoutinePtrTag, &quot;FTL lazy slow path generation thunk&quot;, extraPopsToRestore, FrameAndStackAdjustmentRequirement::NotNeeded);</span>
144 }
145 
146 static void registerClobberCheck(AssemblyHelpers&amp; jit, RegisterSet dontClobber)
147 {
148     if (!Options::clobberAllRegsInFTLICSlowPath())
149         return;
150 
151     RegisterSet clobber = RegisterSet::allRegisters();
152     clobber.exclude(RegisterSet::reservedHardwareRegisters());
153     clobber.exclude(RegisterSet::stackRegisters());
154     clobber.exclude(RegisterSet::calleeSaveRegisters());
155     clobber.exclude(dontClobber);
156 
<span class="line-modified">157     GPRReg someGPR = InvalidGPRReg;</span>
158     for (Reg reg = Reg::first(); reg &lt;= Reg::last(); reg = reg.next()) {
159         if (!clobber.get(reg) || !reg.isGPR())
160             continue;
161 
162         jit.move(AssemblyHelpers::TrustedImm32(0x1337beef), reg.gpr());
163         someGPR = reg.gpr();
164     }
165 
166     for (Reg reg = Reg::first(); reg &lt;= Reg::last(); reg = reg.next()) {
167         if (!clobber.get(reg) || !reg.isFPR())
168             continue;
169 
170         jit.move64ToDouble(someGPR, reg.fpr());
171     }
172 }
173 
<span class="line-modified">174 MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; slowPathCallThunkGenerator(VM&amp; vm, const SlowPathCallKey&amp; key)</span>
175 {
176     AssemblyHelpers jit(nullptr);
177     jit.tagReturnAddress();
178 
179     // We want to save the given registers at the given offset, then we want to save the
180     // old return address somewhere past that offset, and then finally we want to make the
181     // call.
182 
183     size_t currentOffset = key.offset() + sizeof(void*);
184 
<span class="line-modified">185 #if CPU(X86_64)</span>
186     currentOffset += sizeof(void*);
187 #endif
188 
189     for (MacroAssembler::RegisterID reg = MacroAssembler::firstRegister(); reg &lt;= MacroAssembler::lastRegister(); reg = static_cast&lt;MacroAssembler::RegisterID&gt;(reg + 1)) {
190         if (!key.usedRegisters().get(reg))
191             continue;
192         jit.storePtr(reg, AssemblyHelpers::Address(MacroAssembler::stackPointerRegister, currentOffset));
193         currentOffset += sizeof(void*);
194     }
195 
196     for (MacroAssembler::FPRegisterID reg = MacroAssembler::firstFPRegister(); reg &lt;= MacroAssembler::lastFPRegister(); reg = static_cast&lt;MacroAssembler::FPRegisterID&gt;(reg + 1)) {
197         if (!key.usedRegisters().get(reg))
198             continue;
199         jit.storeDouble(reg, AssemblyHelpers::Address(MacroAssembler::stackPointerRegister, currentOffset));
200         currentOffset += sizeof(double);
201     }
202 
203     jit.preserveReturnAddressAfterCall(GPRInfo::nonArgGPR0);
204     jit.storePtr(GPRInfo::nonArgGPR0, AssemblyHelpers::Address(MacroAssembler::stackPointerRegister, key.offset()));
<span class="line-added">205     jit.prepareCallOperation(vm);</span>
206 
207     registerClobberCheck(jit, key.argumentRegisters());
208 
209     AssemblyHelpers::Call call = jit.call(OperationPtrTag);
210 
211     jit.loadPtr(AssemblyHelpers::Address(MacroAssembler::stackPointerRegister, key.offset()), GPRInfo::nonPreservedNonReturnGPR);
212     jit.restoreReturnAddressBeforeReturn(GPRInfo::nonPreservedNonReturnGPR);
213 
214     for (MacroAssembler::FPRegisterID reg = MacroAssembler::lastFPRegister(); ; reg = static_cast&lt;MacroAssembler::FPRegisterID&gt;(reg - 1)) {
215         if (key.usedRegisters().get(reg)) {
216             currentOffset -= sizeof(double);
217             jit.loadDouble(AssemblyHelpers::Address(MacroAssembler::stackPointerRegister, currentOffset), reg);
218         }
219         if (reg == MacroAssembler::firstFPRegister())
220             break;
221     }
222 
223     for (MacroAssembler::RegisterID reg = MacroAssembler::lastRegister(); ; reg = static_cast&lt;MacroAssembler::RegisterID&gt;(reg - 1)) {
224         if (key.usedRegisters().get(reg)) {
225             currentOffset -= sizeof(void*);
</pre>
</td>
</tr>
</table>
<center><a href="FTLState.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLThunks.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLTexture.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WebGLSync.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLTexture.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLTexture.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 41,110 ***</span>
  }
  
  WebGLTexture::WebGLTexture(WebGLRenderingContextBase&amp; ctx)
      : WebGLSharedObject(ctx)
      , m_target(0)
<span class="line-modified">!     , m_minFilter(GraphicsContext3D::NEAREST_MIPMAP_LINEAR)</span>
<span class="line-modified">!     , m_magFilter(GraphicsContext3D::LINEAR)</span>
<span class="line-modified">!     , m_wrapS(GraphicsContext3D::REPEAT)</span>
<span class="line-modified">!     , m_wrapT(GraphicsContext3D::REPEAT)</span>
      , m_isNPOT(false)
      , m_isComplete(false)
      , m_needToUseBlackTexture(false)
      , m_isCompressed(false)
      , m_isFloatType(false)
      , m_isHalfFloatType(false)
      , m_isForWebGL1(ctx.isWebGL1())
  {
<span class="line-modified">!     setObject(ctx.graphicsContext3D()-&gt;createTexture());</span>
  }
  
  WebGLTexture::~WebGLTexture()
  {
      deleteObject(0);
  }
  
<span class="line-modified">! void WebGLTexture::setTarget(GC3Denum target, GC3Dint maxLevel)</span>
  {
      if (!object())
          return;
      // Target is finalized the first time bindTexture() is called.
      if (m_target)
          return;
      switch (target) {
<span class="line-modified">!     case GraphicsContext3D::TEXTURE_2D:</span>
          m_target = target;
          m_info.resize(1);
          m_info[0].resize(maxLevel);
          break;
<span class="line-modified">!     case GraphicsContext3D::TEXTURE_CUBE_MAP:</span>
          m_target = target;
          m_info.resize(6);
          for (int ii = 0; ii &lt; 6; ++ii)
              m_info[ii].resize(maxLevel);
          break;
      }
  }
  
<span class="line-modified">! void WebGLTexture::setParameteri(GC3Denum pname, GC3Dint param)</span>
  {
      if (!object() || !m_target)
          return;
      switch (pname) {
<span class="line-modified">!     case GraphicsContext3D::TEXTURE_MIN_FILTER:</span>
          switch (param) {
<span class="line-modified">!         case GraphicsContext3D::NEAREST:</span>
<span class="line-modified">!         case GraphicsContext3D::LINEAR:</span>
<span class="line-modified">!         case GraphicsContext3D::NEAREST_MIPMAP_NEAREST:</span>
<span class="line-modified">!         case GraphicsContext3D::LINEAR_MIPMAP_NEAREST:</span>
<span class="line-modified">!         case GraphicsContext3D::NEAREST_MIPMAP_LINEAR:</span>
<span class="line-modified">!         case GraphicsContext3D::LINEAR_MIPMAP_LINEAR:</span>
              m_minFilter = param;
              break;
          }
          break;
<span class="line-modified">!     case GraphicsContext3D::TEXTURE_MAG_FILTER:</span>
          switch (param) {
<span class="line-modified">!         case GraphicsContext3D::NEAREST:</span>
<span class="line-modified">!         case GraphicsContext3D::LINEAR:</span>
              m_magFilter = param;
              break;
          }
          break;
<span class="line-modified">!     case GraphicsContext3D::TEXTURE_WRAP_S:</span>
          switch (param) {
<span class="line-modified">!         case GraphicsContext3D::CLAMP_TO_EDGE:</span>
<span class="line-modified">!         case GraphicsContext3D::MIRRORED_REPEAT:</span>
<span class="line-modified">!         case GraphicsContext3D::REPEAT:</span>
              m_wrapS = param;
              break;
          }
          break;
<span class="line-modified">!     case GraphicsContext3D::TEXTURE_WRAP_T:</span>
          switch (param) {
<span class="line-modified">!         case GraphicsContext3D::CLAMP_TO_EDGE:</span>
<span class="line-modified">!         case GraphicsContext3D::MIRRORED_REPEAT:</span>
<span class="line-modified">!         case GraphicsContext3D::REPEAT:</span>
              m_wrapT = param;
              break;
          }
          break;
      default:
          return;
      }
      update();
  }
  
<span class="line-modified">! void WebGLTexture::setParameterf(GC3Denum pname, GC3Dfloat param)</span>
  {
      if (!object() || !m_target)
          return;
<span class="line-modified">!     GC3Dint iparam = static_cast&lt;GC3Dint&gt;(param);</span>
      setParameteri(pname, iparam);
  }
  
<span class="line-modified">! void WebGLTexture::setLevelInfo(GC3Denum target, GC3Dint level, GC3Denum internalFormat, GC3Dsizei width, GC3Dsizei height, GC3Denum type)</span>
  {
      if (!object() || !m_target)
          return;
      // We assume level, internalFormat, width, height, and type have all been
      // validated already.
<span class="line-new-header">--- 41,110 ---</span>
  }
  
  WebGLTexture::WebGLTexture(WebGLRenderingContextBase&amp; ctx)
      : WebGLSharedObject(ctx)
      , m_target(0)
<span class="line-modified">!     , m_minFilter(GraphicsContextGL::NEAREST_MIPMAP_LINEAR)</span>
<span class="line-modified">!     , m_magFilter(GraphicsContextGL::LINEAR)</span>
<span class="line-modified">!     , m_wrapS(GraphicsContextGL::REPEAT)</span>
<span class="line-modified">!     , m_wrapT(GraphicsContextGL::REPEAT)</span>
      , m_isNPOT(false)
      , m_isComplete(false)
      , m_needToUseBlackTexture(false)
      , m_isCompressed(false)
      , m_isFloatType(false)
      , m_isHalfFloatType(false)
      , m_isForWebGL1(ctx.isWebGL1())
  {
<span class="line-modified">!     setObject(ctx.graphicsContextGL()-&gt;createTexture());</span>
  }
  
  WebGLTexture::~WebGLTexture()
  {
      deleteObject(0);
  }
  
<span class="line-modified">! void WebGLTexture::setTarget(GCGLenum target, GCGLint maxLevel)</span>
  {
      if (!object())
          return;
      // Target is finalized the first time bindTexture() is called.
      if (m_target)
          return;
      switch (target) {
<span class="line-modified">!     case GraphicsContextGL::TEXTURE_2D:</span>
          m_target = target;
          m_info.resize(1);
          m_info[0].resize(maxLevel);
          break;
<span class="line-modified">!     case GraphicsContextGL::TEXTURE_CUBE_MAP:</span>
          m_target = target;
          m_info.resize(6);
          for (int ii = 0; ii &lt; 6; ++ii)
              m_info[ii].resize(maxLevel);
          break;
      }
  }
  
<span class="line-modified">! void WebGLTexture::setParameteri(GCGLenum pname, GCGLint param)</span>
  {
      if (!object() || !m_target)
          return;
      switch (pname) {
<span class="line-modified">!     case GraphicsContextGL::TEXTURE_MIN_FILTER:</span>
          switch (param) {
<span class="line-modified">!         case GraphicsContextGL::NEAREST:</span>
<span class="line-modified">!         case GraphicsContextGL::LINEAR:</span>
<span class="line-modified">!         case GraphicsContextGL::NEAREST_MIPMAP_NEAREST:</span>
<span class="line-modified">!         case GraphicsContextGL::LINEAR_MIPMAP_NEAREST:</span>
<span class="line-modified">!         case GraphicsContextGL::NEAREST_MIPMAP_LINEAR:</span>
<span class="line-modified">!         case GraphicsContextGL::LINEAR_MIPMAP_LINEAR:</span>
              m_minFilter = param;
              break;
          }
          break;
<span class="line-modified">!     case GraphicsContextGL::TEXTURE_MAG_FILTER:</span>
          switch (param) {
<span class="line-modified">!         case GraphicsContextGL::NEAREST:</span>
<span class="line-modified">!         case GraphicsContextGL::LINEAR:</span>
              m_magFilter = param;
              break;
          }
          break;
<span class="line-modified">!     case GraphicsContextGL::TEXTURE_WRAP_S:</span>
          switch (param) {
<span class="line-modified">!         case GraphicsContextGL::CLAMP_TO_EDGE:</span>
<span class="line-modified">!         case GraphicsContextGL::MIRRORED_REPEAT:</span>
<span class="line-modified">!         case GraphicsContextGL::REPEAT:</span>
              m_wrapS = param;
              break;
          }
          break;
<span class="line-modified">!     case GraphicsContextGL::TEXTURE_WRAP_T:</span>
          switch (param) {
<span class="line-modified">!         case GraphicsContextGL::CLAMP_TO_EDGE:</span>
<span class="line-modified">!         case GraphicsContextGL::MIRRORED_REPEAT:</span>
<span class="line-modified">!         case GraphicsContextGL::REPEAT:</span>
              m_wrapT = param;
              break;
          }
          break;
      default:
          return;
      }
      update();
  }
  
<span class="line-modified">! void WebGLTexture::setParameterf(GCGLenum pname, GCGLfloat param)</span>
  {
      if (!object() || !m_target)
          return;
<span class="line-modified">!     GCGLint iparam = static_cast&lt;GCGLint&gt;(param);</span>
      setParameteri(pname, iparam);
  }
  
<span class="line-modified">! void WebGLTexture::setLevelInfo(GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLenum type)</span>
  {
      if (!object() || !m_target)
          return;
      // We assume level, internalFormat, width, height, and type have all been
      // validated already.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 162,14 ***</span>
      if (!canGenerateMipmaps())
          return;
      if (!m_isComplete) {
          for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
              const LevelInfo&amp; info0 = m_info[ii][0];
<span class="line-modified">!             GC3Dsizei width = info0.width;</span>
<span class="line-modified">!             GC3Dsizei height = info0.height;</span>
<span class="line-modified">!             GC3Dint levelCount = computeLevelCount(width, height);</span>
<span class="line-modified">!             for (GC3Dint level = 1; level &lt; levelCount; ++level) {</span>
                  width = std::max(1, width &gt;&gt; 1);
                  height = std::max(1, height &gt;&gt; 1);
                  LevelInfo&amp; info = m_info[ii][level];
                  info.setInfo(info0.internalFormat, width, height, info0.type);
              }
<span class="line-new-header">--- 162,14 ---</span>
      if (!canGenerateMipmaps())
          return;
      if (!m_isComplete) {
          for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
              const LevelInfo&amp; info0 = m_info[ii][0];
<span class="line-modified">!             GCGLsizei width = info0.width;</span>
<span class="line-modified">!             GCGLsizei height = info0.height;</span>
<span class="line-modified">!             GCGLint levelCount = computeLevelCount(width, height);</span>
<span class="line-modified">!             for (GCGLint level = 1; level &lt; levelCount; ++level) {</span>
                  width = std::max(1, width &gt;&gt; 1);
                  height = std::max(1, height &gt;&gt; 1);
                  LevelInfo&amp; info = m_info[ii][level];
                  info.setInfo(info0.internalFormat, width, height, info0.type);
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 177,61 ***</span>
          m_isComplete = true;
      }
      m_needToUseBlackTexture = false;
  }
  
<span class="line-modified">! GC3Denum WebGLTexture::getInternalFormat(GC3Denum target, GC3Dint level) const</span>
  {
      const LevelInfo* info = getLevelInfo(target, level);
      if (!info)
          return 0;
      return info-&gt;internalFormat;
  }
  
<span class="line-modified">! GC3Denum WebGLTexture::getType(GC3Denum target, GC3Dint level) const</span>
  {
      ASSERT(m_isForWebGL1);
      const LevelInfo* info = getLevelInfo(target, level);
      if (!info)
          return 0;
      return info-&gt;type;
  }
  
<span class="line-modified">! GC3Dsizei WebGLTexture::getWidth(GC3Denum target, GC3Dint level) const</span>
  {
      const LevelInfo* info = getLevelInfo(target, level);
      if (!info)
          return 0;
      return info-&gt;width;
  }
  
<span class="line-modified">! GC3Dsizei WebGLTexture::getHeight(GC3Denum target, GC3Dint level) const</span>
  {
      const LevelInfo* info = getLevelInfo(target, level);
      if (!info)
          return 0;
      return info-&gt;height;
  }
  
<span class="line-modified">! bool WebGLTexture::isValid(GC3Denum target, GC3Dint level) const</span>
  {
      const LevelInfo* info = getLevelInfo(target, level);
      if (!info)
          return 0;
      return info-&gt;valid;
  }
  
<span class="line-modified">! void WebGLTexture::markInvalid(GC3Denum target, GC3Dint level)</span>
  {
      int index = mapTargetToIndex(target);
      if (index &lt; 0)
          return;
      m_info[index][level].valid = false;
      update();
  }
  
<span class="line-modified">! bool WebGLTexture::isNPOT(GC3Dsizei width, GC3Dsizei height)</span>
  {
      ASSERT(width &gt;= 0 &amp;&amp; height &gt;= 0);
      if (!width || !height)
          return false;
      if ((width &amp; (width - 1)) || (height &amp; (height - 1)))
<span class="line-new-header">--- 177,61 ---</span>
          m_isComplete = true;
      }
      m_needToUseBlackTexture = false;
  }
  
<span class="line-modified">! GCGLenum WebGLTexture::getInternalFormat(GCGLenum target, GCGLint level) const</span>
  {
      const LevelInfo* info = getLevelInfo(target, level);
      if (!info)
          return 0;
      return info-&gt;internalFormat;
  }
  
<span class="line-modified">! GCGLenum WebGLTexture::getType(GCGLenum target, GCGLint level) const</span>
  {
      ASSERT(m_isForWebGL1);
      const LevelInfo* info = getLevelInfo(target, level);
      if (!info)
          return 0;
      return info-&gt;type;
  }
  
<span class="line-modified">! GCGLsizei WebGLTexture::getWidth(GCGLenum target, GCGLint level) const</span>
  {
      const LevelInfo* info = getLevelInfo(target, level);
      if (!info)
          return 0;
      return info-&gt;width;
  }
  
<span class="line-modified">! GCGLsizei WebGLTexture::getHeight(GCGLenum target, GCGLint level) const</span>
  {
      const LevelInfo* info = getLevelInfo(target, level);
      if (!info)
          return 0;
      return info-&gt;height;
  }
  
<span class="line-modified">! bool WebGLTexture::isValid(GCGLenum target, GCGLint level) const</span>
  {
      const LevelInfo* info = getLevelInfo(target, level);
      if (!info)
          return 0;
      return info-&gt;valid;
  }
  
<span class="line-modified">! void WebGLTexture::markInvalid(GCGLenum target, GCGLint level)</span>
  {
      int index = mapTargetToIndex(target);
      if (index &lt; 0)
          return;
      m_info[index][level].valid = false;
      update();
  }
  
<span class="line-modified">! bool WebGLTexture::isNPOT(GCGLsizei width, GCGLsizei height)</span>
  {
      ASSERT(width &gt;= 0 &amp;&amp; height &gt;= 0);
      if (!width || !height)
          return false;
      if ((width &amp; (width - 1)) || (height &amp; (height - 1)))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 250,11 ***</span>
  {
      if (!object())
          return false;
      if (m_needToUseBlackTexture)
          return true;
<span class="line-modified">!     if (m_magFilter == GraphicsContext3D::NEAREST &amp;&amp; (m_minFilter == GraphicsContext3D::NEAREST || m_minFilter == GraphicsContext3D::NEAREST_MIPMAP_NEAREST))</span>
          return false;
      if (m_isForWebGL1 &amp;&amp; m_isHalfFloatType &amp;&amp; !(extensions &amp; TextureExtensionHalfFloatLinearEnabled))
          return true;
      if (m_isFloatType &amp;&amp; !(extensions &amp; TextureExtensionFloatLinearEnabled))
          return true;
<span class="line-new-header">--- 250,11 ---</span>
  {
      if (!object())
          return false;
      if (m_needToUseBlackTexture)
          return true;
<span class="line-modified">!     if (m_magFilter == GraphicsContextGL::NEAREST &amp;&amp; (m_minFilter == GraphicsContextGL::NEAREST || m_minFilter == GraphicsContextGL::NEAREST_MIPMAP_NEAREST))</span>
          return false;
      if (m_isForWebGL1 &amp;&amp; m_isHalfFloatType &amp;&amp; !(extensions &amp; TextureExtensionHalfFloatLinearEnabled))
          return true;
      if (m_isFloatType &amp;&amp; !(extensions &amp; TextureExtensionFloatLinearEnabled))
          return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 272,33 ***</span>
  {
      ASSERT(object());
      m_isCompressed = true;
  }
  
<span class="line-modified">! void WebGLTexture::deleteObjectImpl(GraphicsContext3D* context3d, Platform3DObject object)</span>
  {
      context3d-&gt;deleteTexture(object);
  }
  
<span class="line-modified">! int WebGLTexture::mapTargetToIndex(GC3Denum target) const</span>
  {
<span class="line-modified">!     if (m_target == GraphicsContext3D::TEXTURE_2D) {</span>
<span class="line-modified">!         if (target == GraphicsContext3D::TEXTURE_2D)</span>
              return 0;
<span class="line-modified">!     } else if (m_target == GraphicsContext3D::TEXTURE_CUBE_MAP) {</span>
          switch (target) {
<span class="line-modified">!         case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
              return 0;
<span class="line-modified">!         case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
              return 1;
<span class="line-modified">!         case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
              return 2;
<span class="line-modified">!         case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
              return 3;
<span class="line-modified">!         case GraphicsContext3D::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
              return 4;
<span class="line-modified">!         case GraphicsContext3D::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
              return 5;
          }
      }
      return -1;
  }
<span class="line-new-header">--- 272,33 ---</span>
  {
      ASSERT(object());
      m_isCompressed = true;
  }
  
<span class="line-modified">! void WebGLTexture::deleteObjectImpl(GraphicsContextGLOpenGL* context3d, PlatformGLObject object)</span>
  {
      context3d-&gt;deleteTexture(object);
  }
  
<span class="line-modified">! int WebGLTexture::mapTargetToIndex(GCGLenum target) const</span>
  {
<span class="line-modified">!     if (m_target == GraphicsContextGL::TEXTURE_2D) {</span>
<span class="line-modified">!         if (target == GraphicsContextGL::TEXTURE_2D)</span>
              return 0;
<span class="line-modified">!     } else if (m_target == GraphicsContextGL::TEXTURE_CUBE_MAP) {</span>
          switch (target) {
<span class="line-modified">!         case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
              return 0;
<span class="line-modified">!         case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
              return 1;
<span class="line-modified">!         case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
              return 2;
<span class="line-modified">!         case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
              return 3;
<span class="line-modified">!         case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
              return 4;
<span class="line-modified">!         case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
              return 5;
          }
      }
      return -1;
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 316,54 ***</span>
              return false;
      }
      return true;
  }
  
<span class="line-modified">! GC3Dint WebGLTexture::computeLevelCount(GC3Dsizei width, GC3Dsizei height)</span>
  {
      // return 1 + log2Floor(std::max(width, height));
<span class="line-modified">!     GC3Dsizei n = std::max(width, height);</span>
      if (n &lt;= 0)
          return 0;
<span class="line-modified">!     GC3Dint log = 0;</span>
<span class="line-modified">!     GC3Dsizei value = n;</span>
      for (int ii = 4; ii &gt;= 0; --ii) {
          int shift = (1 &lt;&lt; ii);
<span class="line-modified">!         GC3Dsizei x = (value &gt;&gt; shift);</span>
          if (x) {
              value = x;
              log += shift;
          }
      }
      ASSERT(value == 1);
      return log + 1;
  }
  
<span class="line-modified">! static bool internalFormatIsFloatType(GC3Denum internalFormat)</span>
  {
      switch (internalFormat) {
<span class="line-modified">!     case GraphicsContext3D::R32F:</span>
<span class="line-modified">!     case GraphicsContext3D::RG32F:</span>
<span class="line-modified">!     case GraphicsContext3D::RGB32F:</span>
<span class="line-modified">!     case GraphicsContext3D::RGBA32F:</span>
<span class="line-modified">!     case GraphicsContext3D::DEPTH_COMPONENT32F:</span>
<span class="line-modified">!     case GraphicsContext3D::DEPTH32F_STENCIL8:</span>
          return true;
      default:
          return false;
      }
  }
  
<span class="line-modified">! static bool internalFormatIsHalfFloatType(GC3Denum internalFormat)</span>
  {
      switch (internalFormat) {
<span class="line-modified">!     case GraphicsContext3D::R16F:</span>
<span class="line-modified">!     case GraphicsContext3D::RG16F:</span>
<span class="line-modified">!     case GraphicsContext3D::R11F_G11F_B10F:</span>
<span class="line-modified">!     case GraphicsContext3D::RGB9_E5:</span>
<span class="line-modified">!     case GraphicsContext3D::RGB16F:</span>
<span class="line-modified">!     case GraphicsContext3D::RGBA16F:</span>
          return true;
      default:
          return false;
      }
  }
<span class="line-new-header">--- 316,54 ---</span>
              return false;
      }
      return true;
  }
  
<span class="line-modified">! GCGLint WebGLTexture::computeLevelCount(GCGLsizei width, GCGLsizei height)</span>
  {
      // return 1 + log2Floor(std::max(width, height));
<span class="line-modified">!     GCGLsizei n = std::max(width, height);</span>
      if (n &lt;= 0)
          return 0;
<span class="line-modified">!     GCGLint log = 0;</span>
<span class="line-modified">!     GCGLsizei value = n;</span>
      for (int ii = 4; ii &gt;= 0; --ii) {
          int shift = (1 &lt;&lt; ii);
<span class="line-modified">!         GCGLsizei x = (value &gt;&gt; shift);</span>
          if (x) {
              value = x;
              log += shift;
          }
      }
      ASSERT(value == 1);
      return log + 1;
  }
  
<span class="line-modified">! static bool internalFormatIsFloatType(GCGLenum internalFormat)</span>
  {
      switch (internalFormat) {
<span class="line-modified">!     case GraphicsContextGL::R32F:</span>
<span class="line-modified">!     case GraphicsContextGL::RG32F:</span>
<span class="line-modified">!     case GraphicsContextGL::RGB32F:</span>
<span class="line-modified">!     case GraphicsContextGL::RGBA32F:</span>
<span class="line-modified">!     case GraphicsContextGL::DEPTH_COMPONENT32F:</span>
<span class="line-modified">!     case GraphicsContextGL::DEPTH32F_STENCIL8:</span>
          return true;
      default:
          return false;
      }
  }
  
<span class="line-modified">! static bool internalFormatIsHalfFloatType(GCGLenum internalFormat)</span>
  {
      switch (internalFormat) {
<span class="line-modified">!     case GraphicsContextGL::R16F:</span>
<span class="line-modified">!     case GraphicsContextGL::RG16F:</span>
<span class="line-modified">!     case GraphicsContextGL::R11F_G11F_B10F:</span>
<span class="line-modified">!     case GraphicsContextGL::RGB9_E5:</span>
<span class="line-modified">!     case GraphicsContextGL::RGB16F:</span>
<span class="line-modified">!     case GraphicsContextGL::RGBA16F:</span>
          return true;
      default:
          return false;
      }
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 377,11 ***</span>
              break;
          }
      }
      m_isComplete = true;
      const LevelInfo&amp; first = m_info[0][0];
<span class="line-modified">!     GC3Dint levelCount = computeLevelCount(first.width, first.height);</span>
      if (levelCount &lt; 1)
          m_isComplete = false;
      else {
          for (size_t ii = 0; ii &lt; m_info.size() &amp;&amp; m_isComplete; ++ii) {
              const LevelInfo&amp; info0 = m_info[ii][0];
<span class="line-new-header">--- 377,11 ---</span>
              break;
          }
      }
      m_isComplete = true;
      const LevelInfo&amp; first = m_info[0][0];
<span class="line-modified">!     GCGLint levelCount = computeLevelCount(first.width, first.height);</span>
      if (levelCount &lt; 1)
          m_isComplete = false;
      else {
          for (size_t ii = 0; ii &lt; m_info.size() &amp;&amp; m_isComplete; ++ii) {
              const LevelInfo&amp; info0 = m_info[ii][0];
</pre>
<hr />
<pre>
<span class="line-old-header">*** 389,13 ***</span>
                  || info0.width != first.width || info0.height != first.height
                  || info0.internalFormat != first.internalFormat || (m_isForWebGL1 &amp;&amp; info0.type != first.type)) {
                  m_isComplete = false;
                  break;
              }
<span class="line-modified">!             GC3Dsizei width = info0.width;</span>
<span class="line-modified">!             GC3Dsizei height = info0.height;</span>
<span class="line-modified">!             for (GC3Dint level = 1; level &lt; levelCount; ++level) {</span>
                  width = std::max(1, width &gt;&gt; 1);
                  height = std::max(1, height &gt;&gt; 1);
                  const LevelInfo&amp; info = m_info[ii][level];
                  if (!info.valid
                      || info.width != width || info.height != height
<span class="line-new-header">--- 389,13 ---</span>
                  || info0.width != first.width || info0.height != first.height
                  || info0.internalFormat != first.internalFormat || (m_isForWebGL1 &amp;&amp; info0.type != first.type)) {
                  m_isComplete = false;
                  break;
              }
<span class="line-modified">!             GCGLsizei width = info0.width;</span>
<span class="line-modified">!             GCGLsizei height = info0.height;</span>
<span class="line-modified">!             for (GCGLint level = 1; level &lt; levelCount; ++level) {</span>
                  width = std::max(1, width &gt;&gt; 1);
                  height = std::max(1, height &gt;&gt; 1);
                  const LevelInfo&amp; info = m_info[ii][level];
                  if (!info.valid
                      || info.width != width || info.height != height
</pre>
<hr />
<pre>
<span class="line-old-header">*** 410,16 ***</span>
  
      m_isFloatType = false;
      if (m_isForWebGL1) {
          if (m_isComplete) {
              if (m_isForWebGL1)
<span class="line-modified">!                 m_isFloatType = m_info[0][0].type == GraphicsContext3D::FLOAT;</span>
              else
                  m_isFloatType = internalFormatIsFloatType(m_info[0][0].internalFormat);
          } else {
              for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
<span class="line-modified">!                 if ((m_isForWebGL1 &amp;&amp; m_info[ii][0].type == GraphicsContext3D::FLOAT)</span>
                      || (!m_isForWebGL1 &amp;&amp; internalFormatIsFloatType(m_info[ii][0].internalFormat))) {
                      m_isFloatType = true;
                      break;
                  }
              }
<span class="line-new-header">--- 410,16 ---</span>
  
      m_isFloatType = false;
      if (m_isForWebGL1) {
          if (m_isComplete) {
              if (m_isForWebGL1)
<span class="line-modified">!                 m_isFloatType = m_info[0][0].type == GraphicsContextGL::FLOAT;</span>
              else
                  m_isFloatType = internalFormatIsFloatType(m_info[0][0].internalFormat);
          } else {
              for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
<span class="line-modified">!                 if ((m_isForWebGL1 &amp;&amp; m_info[ii][0].type == GraphicsContextGL::FLOAT)</span>
                      || (!m_isForWebGL1 &amp;&amp; internalFormatIsFloatType(m_info[ii][0].internalFormat))) {
                      m_isFloatType = true;
                      break;
                  }
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 430,40 ***</span>
      if (m_isForWebGL1) {
          if (m_isComplete) {
              if (m_isForWebGL1)
                  m_isHalfFloatType = internalFormatIsHalfFloatType(m_info[0][0].internalFormat);
              else
<span class="line-modified">!                 m_isHalfFloatType = m_info[0][0].type == GraphicsContext3D::HALF_FLOAT_OES;</span>
          } else {
              for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
<span class="line-modified">!                 if ((m_isForWebGL1 &amp;&amp; m_info[ii][0].type == GraphicsContext3D::HALF_FLOAT_OES)</span>
                      || (!m_isForWebGL1 &amp;&amp; internalFormatIsHalfFloatType(m_info[ii][0].internalFormat))) {
                      m_isHalfFloatType = true;
                      break;
                  }
              }
          }
      }
  
      m_needToUseBlackTexture = false;
      // NPOT
<span class="line-modified">!     if (m_isNPOT &amp;&amp; ((m_minFilter != GraphicsContext3D::NEAREST &amp;&amp; m_minFilter != GraphicsContext3D::LINEAR)</span>
<span class="line-modified">!                      || m_wrapS != GraphicsContext3D::CLAMP_TO_EDGE || m_wrapT != GraphicsContext3D::CLAMP_TO_EDGE))</span>
          m_needToUseBlackTexture = true;
      // Completeness
<span class="line-modified">!     if (!m_isComplete &amp;&amp; m_minFilter != GraphicsContext3D::NEAREST &amp;&amp; m_minFilter != GraphicsContext3D::LINEAR)</span>
          m_needToUseBlackTexture = true;
  }
  
<span class="line-modified">! const WebGLTexture::LevelInfo* WebGLTexture::getLevelInfo(GC3Denum target, GC3Dint level) const</span>
  {
      if (!object() || !m_target)
          return 0;
      int targetIndex = mapTargetToIndex(target);
      if (targetIndex &lt; 0 || targetIndex &gt;= static_cast&lt;int&gt;(m_info.size()))
          return 0;
<span class="line-modified">!     if (level &lt; 0 || level &gt;= static_cast&lt;GC3Dint&gt;(m_info[targetIndex].size()))</span>
          return 0;
      return &amp;(m_info[targetIndex][level]);
  }
  
  }
<span class="line-new-header">--- 430,40 ---</span>
      if (m_isForWebGL1) {
          if (m_isComplete) {
              if (m_isForWebGL1)
                  m_isHalfFloatType = internalFormatIsHalfFloatType(m_info[0][0].internalFormat);
              else
<span class="line-modified">!                 m_isHalfFloatType = m_info[0][0].type == GraphicsContextGL::HALF_FLOAT_OES;</span>
          } else {
              for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
<span class="line-modified">!                 if ((m_isForWebGL1 &amp;&amp; m_info[ii][0].type == GraphicsContextGL::HALF_FLOAT_OES)</span>
                      || (!m_isForWebGL1 &amp;&amp; internalFormatIsHalfFloatType(m_info[ii][0].internalFormat))) {
                      m_isHalfFloatType = true;
                      break;
                  }
              }
          }
      }
  
      m_needToUseBlackTexture = false;
      // NPOT
<span class="line-modified">!     if (m_isNPOT &amp;&amp; ((m_minFilter != GraphicsContextGL::NEAREST &amp;&amp; m_minFilter != GraphicsContextGL::LINEAR)</span>
<span class="line-modified">!         || m_wrapS != GraphicsContextGL::CLAMP_TO_EDGE || m_wrapT != GraphicsContextGL::CLAMP_TO_EDGE))</span>
          m_needToUseBlackTexture = true;
      // Completeness
<span class="line-modified">!     if (!m_isComplete &amp;&amp; m_minFilter != GraphicsContextGL::NEAREST &amp;&amp; m_minFilter != GraphicsContextGL::LINEAR)</span>
          m_needToUseBlackTexture = true;
  }
  
<span class="line-modified">! const WebGLTexture::LevelInfo* WebGLTexture::getLevelInfo(GCGLenum target, GCGLint level) const</span>
  {
      if (!object() || !m_target)
          return 0;
      int targetIndex = mapTargetToIndex(target);
      if (targetIndex &lt; 0 || targetIndex &gt;= static_cast&lt;int&gt;(m_info.size()))
          return 0;
<span class="line-modified">!     if (level &lt; 0 || level &gt;= static_cast&lt;GCGLint&gt;(m_info[targetIndex].size()))</span>
          return 0;
      return &amp;(m_info[targetIndex][level]);
  }
  
  }
</pre>
<center><a href="WebGLSync.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="WebGLTexture.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
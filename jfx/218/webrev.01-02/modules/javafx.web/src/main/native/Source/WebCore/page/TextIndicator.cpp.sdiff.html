<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/TextIndicator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SuspendableTimer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UserContentURLPattern.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/TextIndicator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
274 
275     if (!(data.options &amp; TextIndicatorOptionUseBoundingRectAndPaintAllContentForComplexRanges))
276         return false;
277 
278     if (!(data.options &amp; TextIndicatorOptionComputeEstimatedBackgroundColor))
279         return false;
280 
281     bool hasOnlyLegibleTextColors = true;
282     if (data.options &amp; TextIndicatorOptionRespectTextColor) {
283         for (auto&amp; textColor : textColors) {
284             hasOnlyLegibleTextColors = textColorIsLegibleAgainstBackgroundColor(textColor, backgroundColor);
285             if (!hasOnlyLegibleTextColors)
286                 break;
287         }
288     } else
289         hasOnlyLegibleTextColors = textColorIsLegibleAgainstBackgroundColor(Color::black, backgroundColor);
290 
291     return !hasOnlyLegibleTextColors || textColors.isEmpty();
292 }
293 










294 static bool initializeIndicator(TextIndicatorData&amp; data, Frame&amp; frame, const Range&amp; range, FloatSize margin, bool indicatesCurrentSelection)
295 {
296     if (auto* document = frame.document())
297         document-&gt;updateLayoutIgnorePendingStylesheets();
298 
299     bool treatRangeAsComplexDueToIllegibleTextColors = false;
300     if (data.options &amp; TextIndicatorOptionComputeEstimatedBackgroundColor) {
301         data.estimatedBackgroundColor = estimatedBackgroundColorForRange(range, frame);
302         treatRangeAsComplexDueToIllegibleTextColors = hasAnyIllegibleColors(data, data.estimatedBackgroundColor, estimatedTextColorsForRange(range));
303     }
304 
305     Vector&lt;FloatRect&gt; textRects;
306 
307     // FIXME (138888): Ideally we wouldn&#39;t remove the margin in this case, but we need to
308     // ensure that the indicator and indicator-with-highlight overlap precisely, and
309     // we can&#39;t add a margin to the indicator-with-highlight.
310     if (indicatesCurrentSelection &amp;&amp; !(data.options &amp; TextIndicatorOptionIncludeMarginIfRangeMatchesSelection))
311         margin = FloatSize();
312 
313     FrameSelection::TextRectangleHeight textRectHeight = (data.options &amp; TextIndicatorOptionTightlyFitContent) ? FrameSelection::TextRectangleHeight::TextHeight : FrameSelection::TextRectangleHeight::SelectionHeight;
314 
<span class="line-modified">315     if ((data.options &amp; TextIndicatorOptionUseBoundingRectAndPaintAllContentForComplexRanges) &amp;&amp; (hasNonInlineOrReplacedElements(range) || treatRangeAsComplexDueToIllegibleTextColors))</span>







316         data.options |= TextIndicatorOptionPaintAllContent;
317 #if PLATFORM(IOS_FAMILY)
318     else if (data.options &amp; TextIndicatorOptionUseSelectionRectForSizing)
319         getSelectionRectsForRange(textRects, range);
320 #endif
321     else {
322         Vector&lt;IntRect&gt; absoluteTextRects;
323         range.absoluteTextRects(absoluteTextRects, textRectHeight == FrameSelection::TextRectangleHeight::SelectionHeight, nullptr, Range::BoundingRectBehavior::RespectClipping);
324 
325         textRects.reserveInitialCapacity(absoluteTextRects.size());
326         for (auto&amp; rect : absoluteTextRects)
327             textRects.uncheckedAppend(rect);
328     }
329 
330     if (textRects.isEmpty())
331         textRects.append(absoluteBoundingRectForRange(range));
332 
333     auto frameView = frame.view();
334 
335     // Use the exposedContentRect/viewExposedRect instead of visibleContentRect to avoid creating a huge indicator for a large view inside a scroll view.
</pre>
</td>
<td>
<hr />
<pre>
274 
275     if (!(data.options &amp; TextIndicatorOptionUseBoundingRectAndPaintAllContentForComplexRanges))
276         return false;
277 
278     if (!(data.options &amp; TextIndicatorOptionComputeEstimatedBackgroundColor))
279         return false;
280 
281     bool hasOnlyLegibleTextColors = true;
282     if (data.options &amp; TextIndicatorOptionRespectTextColor) {
283         for (auto&amp; textColor : textColors) {
284             hasOnlyLegibleTextColors = textColorIsLegibleAgainstBackgroundColor(textColor, backgroundColor);
285             if (!hasOnlyLegibleTextColors)
286                 break;
287         }
288     } else
289         hasOnlyLegibleTextColors = textColorIsLegibleAgainstBackgroundColor(Color::black, backgroundColor);
290 
291     return !hasOnlyLegibleTextColors || textColors.isEmpty();
292 }
293 
<span class="line-added">294 static bool containsOnlyWhiteSpaceText(const Range&amp; range)</span>
<span class="line-added">295 {</span>
<span class="line-added">296     auto* stop = range.pastLastNode();</span>
<span class="line-added">297     for (auto* node = range.firstNode(); node &amp;&amp; node != stop; node = NodeTraversal::next(*node)) {</span>
<span class="line-added">298         if (!is&lt;RenderText&gt;(node-&gt;renderer()))</span>
<span class="line-added">299             return false;</span>
<span class="line-added">300     }</span>
<span class="line-added">301     return plainTextReplacingNoBreakSpace(&amp;range).stripWhiteSpace().isEmpty();</span>
<span class="line-added">302 }</span>
<span class="line-added">303 </span>
304 static bool initializeIndicator(TextIndicatorData&amp; data, Frame&amp; frame, const Range&amp; range, FloatSize margin, bool indicatesCurrentSelection)
305 {
306     if (auto* document = frame.document())
307         document-&gt;updateLayoutIgnorePendingStylesheets();
308 
309     bool treatRangeAsComplexDueToIllegibleTextColors = false;
310     if (data.options &amp; TextIndicatorOptionComputeEstimatedBackgroundColor) {
311         data.estimatedBackgroundColor = estimatedBackgroundColorForRange(range, frame);
312         treatRangeAsComplexDueToIllegibleTextColors = hasAnyIllegibleColors(data, data.estimatedBackgroundColor, estimatedTextColorsForRange(range));
313     }
314 
315     Vector&lt;FloatRect&gt; textRects;
316 
317     // FIXME (138888): Ideally we wouldn&#39;t remove the margin in this case, but we need to
318     // ensure that the indicator and indicator-with-highlight overlap precisely, and
319     // we can&#39;t add a margin to the indicator-with-highlight.
320     if (indicatesCurrentSelection &amp;&amp; !(data.options &amp; TextIndicatorOptionIncludeMarginIfRangeMatchesSelection))
321         margin = FloatSize();
322 
323     FrameSelection::TextRectangleHeight textRectHeight = (data.options &amp; TextIndicatorOptionTightlyFitContent) ? FrameSelection::TextRectangleHeight::TextHeight : FrameSelection::TextRectangleHeight::SelectionHeight;
324 
<span class="line-modified">325     bool useBoundingRectAndPaintAllContentForComplexRanges = data.options &amp; TextIndicatorOptionUseBoundingRectAndPaintAllContentForComplexRanges;</span>
<span class="line-added">326     if (useBoundingRectAndPaintAllContentForComplexRanges &amp;&amp; containsOnlyWhiteSpaceText(range)) {</span>
<span class="line-added">327         auto commonAncestorContainer = makeRefPtr(range.commonAncestorContainer());</span>
<span class="line-added">328         if (auto* containerRenderer = commonAncestorContainer-&gt;renderer()) {</span>
<span class="line-added">329             data.options |= TextIndicatorOptionPaintAllContent;</span>
<span class="line-added">330             textRects.append(containerRenderer-&gt;absoluteBoundingBoxRect());</span>
<span class="line-added">331         }</span>
<span class="line-added">332     } else if (useBoundingRectAndPaintAllContentForComplexRanges &amp;&amp; (treatRangeAsComplexDueToIllegibleTextColors || hasNonInlineOrReplacedElements(range)))</span>
333         data.options |= TextIndicatorOptionPaintAllContent;
334 #if PLATFORM(IOS_FAMILY)
335     else if (data.options &amp; TextIndicatorOptionUseSelectionRectForSizing)
336         getSelectionRectsForRange(textRects, range);
337 #endif
338     else {
339         Vector&lt;IntRect&gt; absoluteTextRects;
340         range.absoluteTextRects(absoluteTextRects, textRectHeight == FrameSelection::TextRectangleHeight::SelectionHeight, nullptr, Range::BoundingRectBehavior::RespectClipping);
341 
342         textRects.reserveInitialCapacity(absoluteTextRects.size());
343         for (auto&amp; rect : absoluteTextRects)
344             textRects.uncheckedAppend(rect);
345     }
346 
347     if (textRects.isEmpty())
348         textRects.append(absoluteBoundingRectForRange(range));
349 
350     auto frameView = frame.view();
351 
352     // Use the exposedContentRect/viewExposedRect instead of visibleContentRect to avoid creating a huge indicator for a large view inside a scroll view.
</pre>
</td>
</tr>
</table>
<center><a href="SuspendableTimer.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="UserContentURLPattern.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
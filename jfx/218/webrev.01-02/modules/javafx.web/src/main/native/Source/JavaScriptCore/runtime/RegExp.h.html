<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExp.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2007-2019 Apple Inc. All rights reserved.
  4  *  Copyright (C) 2009 Torch Mobile, Inc.
  5  *
  6  *  This library is free software; you can redistribute it and/or
  7  *  modify it under the terms of the GNU Lesser General Public
  8  *  License as published by the Free Software Foundation; either
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Lesser General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;ConcurrentJSLock.h&quot;
 25 #include &quot;MatchResult.h&quot;
 26 #include &quot;RegExpKey.h&quot;
 27 #include &quot;Structure.h&quot;
 28 #include &quot;Yarr.h&quot;
 29 #include &lt;wtf/Forward.h&gt;
 30 #include &lt;wtf/text/WTFString.h&gt;
 31 
 32 #if ENABLE(YARR_JIT)
 33 #include &quot;YarrJIT.h&quot;
 34 #endif
 35 
 36 namespace JSC {
 37 
 38 struct RegExpRepresentation;
 39 class VM;
 40 
 41 class RegExp final : public JSCell {
 42     friend class CachedRegExp;
 43 
 44 public:
 45     using Base = JSCell;
 46     static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;
 47     static constexpr bool needsDestruction = true;
 48 
 49     template&lt;typename CellType, SubspaceAccess mode&gt;
 50     static IsoSubspace* subspaceFor(VM&amp; vm)
 51     {
 52         return &amp;vm.regExpSpace;
 53     }
 54 
 55     JS_EXPORT_PRIVATE static RegExp* create(VM&amp;, const String&amp; pattern, OptionSet&lt;Yarr::Flags&gt;);
 56     static void destroy(JSCell*);
 57     static size_t estimatedSize(JSCell*, VM&amp;);
 58     JS_EXPORT_PRIVATE static void dumpToStream(const JSCell*, PrintStream&amp;);
 59 
 60     bool global() const { return m_flags.contains(Yarr::Flags::Global); }
 61     bool ignoreCase() const { return m_flags.contains(Yarr::Flags::IgnoreCase); }
 62     bool multiline() const { return m_flags.contains(Yarr::Flags::Multiline); }
 63     bool sticky() const { return m_flags.contains(Yarr::Flags::Sticky); }
 64     bool globalOrSticky() const { return global() || sticky(); }
 65     bool unicode() const { return m_flags.contains(Yarr::Flags::Unicode); }
 66     bool dotAll() const { return m_flags.contains(Yarr::Flags::DotAll); }
 67 
 68     const String&amp; pattern() const { return m_patternString; }
 69 
 70     bool isValid() const { return !Yarr::hasError(m_constructionErrorCode); }
 71     const char* errorMessage() const { return Yarr::errorMessage(m_constructionErrorCode); }
 72     JSObject* errorToThrow(JSGlobalObject* globalObject) { return Yarr::errorToThrow(globalObject, m_constructionErrorCode); }
 73     void reset()
 74     {
 75         m_state = NotCompiled;
 76         m_constructionErrorCode = Yarr::ErrorCode::NoError;
 77     }
 78 
 79     JS_EXPORT_PRIVATE int match(VM&amp;, const String&amp;, unsigned startOffset, Vector&lt;int&gt;&amp; ovector);
 80 
 81     // Returns false if we couldn&#39;t run the regular expression for any reason.
 82     bool matchConcurrently(VM&amp;, const String&amp;, unsigned startOffset, int&amp; position, Vector&lt;int&gt;&amp; ovector);
 83 
 84     JS_EXPORT_PRIVATE MatchResult match(VM&amp;, const String&amp;, unsigned startOffset);
 85 
 86     bool matchConcurrently(VM&amp;, const String&amp;, unsigned startOffset, MatchResult&amp;);
 87 
 88     // Call these versions of the match functions if you&#39;re desperate for performance.
 89     template&lt;typename VectorType&gt;
 90     int matchInline(VM&amp;, const String&amp;, unsigned startOffset, VectorType&amp; ovector);
 91     MatchResult matchInline(VM&amp;, const String&amp;, unsigned startOffset);
 92 
 93     unsigned numSubpatterns() const { return m_numSubpatterns; }
 94 
 95     bool hasNamedCaptures()
 96     {
 97         return m_rareData &amp;&amp; !m_rareData-&gt;m_captureGroupNames.isEmpty();
 98     }
 99 
100     String getCaptureGroupName(unsigned i)
101     {
102         if (!i || !m_rareData || m_rareData-&gt;m_captureGroupNames.size() &lt;= i)
103             return String();
104         ASSERT(m_rareData);
105         return m_rareData-&gt;m_captureGroupNames[i];
106     }
107 
108     unsigned subpatternForName(String groupName)
109     {
110         if (!m_rareData)
111             return 0;
112         auto it = m_rareData-&gt;m_namedGroupToParenIndex.find(groupName);
113         if (it == m_rareData-&gt;m_namedGroupToParenIndex.end())
114             return 0;
115         return it-&gt;value;
116     }
117 
118     bool hasCode()
119     {
120         return m_state == JITCode || m_state == ByteCode;
121     }
122 
123     bool hasCodeFor(Yarr::YarrCharSize);
124     bool hasMatchOnlyCodeFor(Yarr::YarrCharSize);
125 
126     void deleteCode();
127 
128 #if ENABLE(REGEXP_TRACING)
129     void printTraceData();
130 #endif
131 
132     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
133     {
134         return Structure::create(vm, globalObject, prototype, TypeInfo(CellType, StructureFlags), info());
135     }
136 
137     DECLARE_INFO;
138 
139     RegExpKey key() { return RegExpKey(m_flags, m_patternString); }
140 
141 protected:
142     void finishCreation(VM&amp;);
143 
144 private:
145     friend class RegExpCache;
146     RegExp(VM&amp;, const String&amp;, OptionSet&lt;Yarr::Flags&gt;);
147 
148     static RegExp* createWithoutCaching(VM&amp;, const String&amp;, OptionSet&lt;Yarr::Flags&gt;);
149 
150     enum RegExpState : uint8_t {
151         ParseError,
152         JITCode,
153         ByteCode,
154         NotCompiled
155     };
156 
157     void byteCodeCompileIfNecessary(VM*);
158 
159     void compile(VM*, Yarr::YarrCharSize);
160     void compileIfNecessary(VM&amp;, Yarr::YarrCharSize);
161 
162     void compileMatchOnly(VM*, Yarr::YarrCharSize);
163     void compileIfNecessaryMatchOnly(VM&amp;, Yarr::YarrCharSize);
164 
165 #if ENABLE(YARR_JIT_DEBUG)
166     void matchCompareWithInterpreter(const String&amp;, int startOffset, int* offsetVector, int jitResult);
167 #endif
168 
169 #if ENABLE(YARR_JIT)
170     Yarr::YarrCodeBlock&amp; ensureRegExpJITCode()
171     {
172         if (!m_regExpJITCode)
173             m_regExpJITCode = makeUnique&lt;Yarr::YarrCodeBlock&gt;();
174         return *m_regExpJITCode.get();
175     }
176 #endif
177 
178     struct RareData {
179         WTF_MAKE_STRUCT_FAST_ALLOCATED;
180         Vector&lt;String&gt; m_captureGroupNames;
181         HashMap&lt;String, unsigned&gt; m_namedGroupToParenIndex;
182     };
183 
184     String m_patternString;
185     RegExpState m_state { NotCompiled };
186     OptionSet&lt;Yarr::Flags&gt; m_flags;
187     Yarr::ErrorCode m_constructionErrorCode { Yarr::ErrorCode::NoError };
188     unsigned m_numSubpatterns { 0 };
189     std::unique_ptr&lt;Yarr::BytecodePattern&gt; m_regExpBytecode;
190 #if ENABLE(YARR_JIT)
191     std::unique_ptr&lt;Yarr::YarrCodeBlock&gt; m_regExpJITCode;
192 #endif
193     std::unique_ptr&lt;RareData&gt; m_rareData;
194 #if ENABLE(REGEXP_TRACING)
195     double m_rtMatchOnlyTotalSubjectStringLen { 0.0 };
196     double m_rtMatchTotalSubjectStringLen { 0.0 };
197     unsigned m_rtMatchOnlyCallCount { 0 };
198     unsigned m_rtMatchOnlyFoundCount { 0 };
199     unsigned m_rtMatchCallCount { 0 };
200     unsigned m_rtMatchFoundCount { 0 };
201 #endif
202 };
203 
204 } // namespace JSC
    </pre>
  </body>
</html>
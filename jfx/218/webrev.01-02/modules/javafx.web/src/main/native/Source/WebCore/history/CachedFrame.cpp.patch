diff a/modules/javafx.web/src/main/native/Source/WebCore/history/CachedFrame.cpp b/modules/javafx.web/src/main/native/Source/WebCore/history/CachedFrame.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/history/CachedFrame.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/history/CachedFrame.cpp
@@ -24,10 +24,11 @@
  */
 
 #include "config.h"
 #include "CachedFrame.h"
 
+#include "BackForwardCache.h"
 #include "CSSAnimationController.h"
 #include "CachedFramePlatformData.h"
 #include "CachedPage.h"
 #include "CustomHeaderFields.h"
 #include "DOMWindow.h"
@@ -39,17 +40,16 @@
 #include "FrameLoaderClient.h"
 #include "FrameView.h"
 #include "Logging.h"
 #include "NavigationDisabler.h"
 #include "Page.h"
-#include "PageCache.h"
 #include "RenderWidget.h"
-#include "RuntimeEnabledFeatures.h"
 #include "SVGDocumentExtensions.h"
 #include "ScriptController.h"
 #include "SerializedScriptValue.h"
 #include "StyleTreeResolver.h"
+#include "WindowEventLoop.h"
 #include <wtf/RefCountedLeakCounter.h>
 #include <wtf/text/CString.h>
 
 #if PLATFORM(IOS_FAMILY) || ENABLE(TOUCH_EVENTS)
 #include "Chrome.h"
@@ -105,17 +105,17 @@
         m_cachedFrameScriptData->restore(frame.get());
 
         if (m_document->svgExtensions())
             m_document->accessSVGExtensions().unpauseAnimations();
 
-        m_document->resume(ReasonForSuspension::PageCache);
+        m_document->resume(ReasonForSuspension::BackForwardCache);
 
         // It is necessary to update any platform script objects after restoring the
         // cached page.
         frame->script().updatePlatformScriptObjects();
 
-        frame->loader().client().didRestoreFromPageCache();
+        frame->loader().client().didRestoreFromBackForwardCache();
 
         pruneDetachedChildFrames();
 
         // Reconstruct the FrameTree. And open the child CachedFrames in their respective FrameLoaders.
         for (auto& childFrame : m_childFrames) {
@@ -137,11 +137,11 @@
                 frame->page()->chrome().client().setNeedsScrollNotifications(frame, true);
         }
     }
 #endif
 
-    frame->view()->didRestoreFromPageCache();
+    frame->view()->didRestoreFromBackForwardCache();
 }
 
 CachedFrame::CachedFrame(Frame& frame)
     : CachedFrameBase(frame)
 {
@@ -149,11 +149,11 @@
     cachedFrameCounter.increment();
 #endif
     ASSERT(m_document);
     ASSERT(m_documentLoader);
     ASSERT(m_view);
-    ASSERT(m_document->pageCacheState() == Document::InPageCache);
+    ASSERT(m_document->backForwardCacheState() == Document::InBackForwardCache);
 
     RELEASE_ASSERT(m_document->domWindow());
     RELEASE_ASSERT(m_document->frame());
     RELEASE_ASSERT(m_document->domWindow()->frame());
 
@@ -168,42 +168,44 @@
     RELEASE_ASSERT(m_document->domWindow());
     RELEASE_ASSERT(m_document->frame());
     RELEASE_ASSERT(m_document->domWindow()->frame());
 
     // Active DOM objects must be suspended before we cache the frame script data.
-    m_document->suspend(ReasonForSuspension::PageCache);
+    m_document->suspend(ReasonForSuspension::BackForwardCache);
 
     m_cachedFrameScriptData = makeUnique<ScriptCachedFrameData>(frame);
 
-    m_document->domWindow()->suspendForPageCache();
+    m_document->domWindow()->suspendForBackForwardCache();
 
     // Clear FrameView to reset flags such as 'firstVisuallyNonEmptyLayoutCallbackPending' so that the
-    // 'DidFirstVisuallyNonEmptyLayout' callback gets called against when restoring from PageCache.
+    // 'DidFirstVisuallyNonEmptyLayout' callback gets called against when restoring from the BackForwardCache.
     m_view->resetLayoutMilestones();
 
+    // The main frame is reused for the navigation and the opener link to its should thus persist.
+    if (!frame.isMainFrame())
+        frame.loader().detachFromAllOpenedFrames();
+
     frame.loader().client().savePlatformDataToCachedFrame(this);
 
-    // documentWillSuspendForPageCache() can set up a layout timer on the FrameView, so clear timers after that.
+    // documentWillSuspendForBackForwardCache() can set up a layout timer on the FrameView, so clear timers after that.
     frame.clearTimers();
 
     // Deconstruct the FrameTree, to restore it later.
     // We do this for two reasons:
     // 1 - We reuse the main frame, so when it navigates to a new page load it needs to start with a blank FrameTree.
-    // 2 - It's much easier to destroy a CachedFrame while it resides in the PageCache if it is disconnected from its parent.
+    // 2 - It's much easier to destroy a CachedFrame while it resides in the BackForwardCache if it is disconnected from its parent.
     for (unsigned i = 0; i < m_childFrames.size(); ++i)
         frame.tree().removeChild(m_childFrames[i]->view()->frame());
 
     if (!m_isMainFrame)
         frame.page()->decrementSubframeCount();
 
-    frame.loader().client().didSaveToPageCache();
-
 #ifndef NDEBUG
     if (m_isMainFrame)
-        LOG(PageCache, "Finished creating CachedFrame for main frame url '%s' and DocumentLoader %p\n", m_url.string().utf8().data(), m_documentLoader.get());
+        LOG(BackForwardCache, "Finished creating CachedFrame for main frame url '%s' and DocumentLoader %p\n", m_url.string().utf8().data(), m_documentLoader.get());
     else
-        LOG(PageCache, "Finished creating CachedFrame for child frame with url '%s' and DocumentLoader %p\n", m_url.string().utf8().data(), m_documentLoader.get());
+        LOG(BackForwardCache, "Finished creating CachedFrame for child frame with url '%s' and DocumentLoader %p\n", m_url.string().utf8().data(), m_documentLoader.get());
 #endif
 
 #if PLATFORM(IOS_FAMILY)
     if (m_isMainFrame) {
         if (DOMWindow* domWindow = m_document->domWindow()) {
@@ -232,15 +234,15 @@
 void CachedFrame::clear()
 {
     if (!m_document)
         return;
 
-    // clear() should only be called for Frames representing documents that are no longer in the page cache.
+    // clear() should only be called for Frames representing documents that are no longer in the back/forward cache.
     // This means the CachedFrame has been:
     // 1 - Successfully restore()'d by going back/forward.
-    // 2 - destroy()'ed because the PageCache is pruning or the WebView was closed.
-    ASSERT(m_document->pageCacheState() == Document::NotInPageCache);
+    // 2 - destroy()'ed because the BackForwardCache is pruning or the WebView was closed.
+    ASSERT(m_document->backForwardCacheState() == Document::NotInBackForwardCache);
     ASSERT(m_view);
     ASSERT(!m_document->frame() || m_document->frame() == &m_view->frame());
 
     for (int i = m_childFrames.size() - 1; i >= 0; --i)
         m_childFrames[i]->clear();
@@ -256,12 +258,12 @@
 void CachedFrame::destroy()
 {
     if (!m_document)
         return;
 
-    // Only CachedFrames that are still in the PageCache should be destroyed in this manner
-    ASSERT(m_document->pageCacheState() == Document::InPageCache);
+    // Only CachedFrames that are still in the BackForwardCache should be destroyed in this manner
+    ASSERT(m_document->backForwardCacheState() == Document::InBackForwardCache);
     ASSERT(m_view);
     ASSERT(!m_document->frame());
 
     m_document->domWindow()->willDestroyCachedFrame();
 
@@ -278,15 +280,15 @@
 
     Frame::clearTimers(m_view.get(), m_document.get());
 
     m_view->frame().animation().detachFromDocument(m_document.get());
 
-    // FIXME: Why do we need to call removeAllEventListeners here? When the document is in page cache, this method won't work
+    // FIXME: Why do we need to call removeAllEventListeners here? When the document is in back/forward cache, this method won't work
     // fully anyway, because the document won't be able to access its DOMWindow object (due to being frameless).
     m_document->removeAllEventListeners();
 
-    m_document->setPageCacheState(Document::NotInPageCache);
+    m_document->setBackForwardCacheState(Document::NotInBackForwardCache);
     m_document->prepareForDestruction();
 
     clear();
 }
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/PODIntervalTree.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PODInterval.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PODRedBlackTree.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/PODIntervalTree.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.

  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 21  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 23  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
<span class="line-modified"> 26 #ifndef PODIntervalTree_h</span>
<span class="line-removed"> 27 #define PODIntervalTree_h</span>
 28 
 29 #include &quot;PODInterval.h&quot;
 30 #include &quot;PODRedBlackTree.h&quot;
<span class="line-removed"> 31 #include &lt;wtf/Assertions.h&gt;</span>
<span class="line-removed"> 32 #include &lt;wtf/Noncopyable.h&gt;</span>
 33 #include &lt;wtf/Optional.h&gt;
 34 #include &lt;wtf/Vector.h&gt;
<span class="line-removed"> 35 #include &lt;wtf/text/ValueToString.h&gt;</span>
 36 
<span class="line-modified"> 37 namespace WebCore {</span>
<span class="line-removed"> 38 </span>
<span class="line-removed"> 39 template &lt;class T, class UserData = void*&gt;</span>
<span class="line-removed"> 40 class PODIntervalSearchAdapter {</span>
<span class="line-removed"> 41 public:</span>
<span class="line-removed"> 42     typedef PODInterval&lt;T, UserData&gt; IntervalType;</span>
 43 
<span class="line-modified"> 44     PODIntervalSearchAdapter(Vector&lt;IntervalType&gt;&amp; result, const T&amp; lowValue, const T&amp; highValue)</span>
<span class="line-removed"> 45         : m_result(result)</span>
<span class="line-removed"> 46         , m_lowValue(lowValue)</span>
<span class="line-removed"> 47         , m_highValue(highValue)</span>
<span class="line-removed"> 48     {</span>
<span class="line-removed"> 49     }</span>
<span class="line-removed"> 50 </span>
<span class="line-removed"> 51     const T&amp; lowValue() const { return m_lowValue; }</span>
<span class="line-removed"> 52     const T&amp; highValue() const { return m_highValue; }</span>
<span class="line-removed"> 53     void collectIfNeeded(const IntervalType&amp; data) const</span>
<span class="line-removed"> 54     {</span>
<span class="line-removed"> 55         if (data.overlaps(m_lowValue, m_highValue))</span>
<span class="line-removed"> 56             m_result.append(data);</span>
<span class="line-removed"> 57     }</span>
 58 
<span class="line-modified"> 59 private:</span>
<span class="line-removed"> 60     Vector&lt;IntervalType&gt;&amp; m_result;</span>
<span class="line-removed"> 61     T m_lowValue;</span>
<span class="line-removed"> 62     T m_highValue;</span>
<span class="line-removed"> 63 };</span>
 64 
 65 // An interval tree, which is a form of augmented red-black tree. It
 66 // supports efficient (O(lg n)) insertion, removal and querying of
 67 // intervals in the tree.
<span class="line-modified"> 68 template&lt;class T, class UserData = void*&gt;</span>
<span class="line-removed"> 69 class PODIntervalTree : public PODRedBlackTree&lt;PODInterval&lt;T, UserData&gt;&gt; {</span>
 70     WTF_MAKE_FAST_ALLOCATED;
<span class="line-removed"> 71     WTF_MAKE_NONCOPYABLE(PODIntervalTree);</span>
 72 public:
<span class="line-modified"> 73     // Typedef to reduce typing when declaring intervals to be stored in</span>
<span class="line-modified"> 74     // this tree.</span>
<span class="line-removed"> 75     typedef PODInterval&lt;T, UserData&gt; IntervalType;</span>
<span class="line-removed"> 76     typedef PODIntervalSearchAdapter&lt;T, UserData&gt; IntervalSearchAdapterType;</span>
<span class="line-removed"> 77 </span>
<span class="line-removed"> 78     PODIntervalTree()</span>
<span class="line-removed"> 79         : PODRedBlackTree&lt;IntervalType&gt;()</span>
<span class="line-removed"> 80     {</span>
<span class="line-removed"> 81         init();</span>
<span class="line-removed"> 82     }</span>
 83 
<span class="line-modified"> 84     // Returns all intervals in the tree which overlap the given query</span>
<span class="line-removed"> 85     // interval. The returned intervals are sorted by increasing low</span>
<span class="line-removed"> 86     // endpoint.</span>
 87     Vector&lt;IntervalType&gt; allOverlaps(const IntervalType&amp; interval) const
 88     {
 89         Vector&lt;IntervalType&gt; result;
<span class="line-modified"> 90         allOverlaps(interval, result);</span>

 91         return result;
 92     }
 93 
<span class="line-modified"> 94     // Returns all intervals in the tree which overlap the given query</span>
<span class="line-removed"> 95     // interval. The returned intervals are sorted by increasing low</span>
<span class="line-removed"> 96     // endpoint.</span>
<span class="line-removed"> 97     void allOverlaps(const IntervalType&amp; interval, Vector&lt;IntervalType&gt;&amp; result) const</span>
<span class="line-removed"> 98     {</span>
<span class="line-removed"> 99         // Explicit dereference of &quot;this&quot; required because of</span>
<span class="line-removed">100         // inheritance rules in template classes.</span>
<span class="line-removed">101         IntervalSearchAdapterType adapter(result, interval.low(), interval.high());</span>
<span class="line-removed">102         searchForOverlapsFrom&lt;IntervalSearchAdapterType&gt;(this-&gt;root(), adapter);</span>
<span class="line-removed">103     }</span>
<span class="line-removed">104 </span>
<span class="line-removed">105     template &lt;class AdapterType&gt;</span>
<span class="line-removed">106     void allOverlapsWithAdapter(AdapterType&amp; adapter) const</span>
107     {
<span class="line-modified">108         // Explicit dereference of &quot;this&quot; required because of</span>
<span class="line-removed">109         // inheritance rules in template classes.</span>
<span class="line-removed">110         searchForOverlapsFrom&lt;AdapterType&gt;(this-&gt;root(), adapter);</span>
111     }
112 
<span class="line-modified">113     // Helper to create interval objects.</span>
<span class="line-removed">114     static IntervalType createInterval(const T&amp; low, const T&amp; high, const UserData data = 0)</span>
115     {
<span class="line-modified">116         return IntervalType(low, high, data);</span>
<span class="line-removed">117     }</span>
<span class="line-removed">118 </span>
<span class="line-removed">119     Optional&lt;IntervalType&gt; nextIntervalAfter(const IntervalType&amp; interval)</span>
<span class="line-removed">120     {</span>
<span class="line-removed">121         auto next = smallestNodeGreaterThanFrom(interval, this-&gt;root());</span>
122         if (!next)
123             return WTF::nullopt;
<span class="line-removed">124 </span>
125         return next-&gt;data();
126     }
127 
<span class="line-modified">128     bool checkInvariants() const override</span>


129     {
<span class="line-modified">130         if (!PODRedBlackTree&lt;IntervalType&gt;::checkInvariants())</span>
131             return false;
132         if (!this-&gt;root())
133             return true;
<span class="line-modified">134         return checkInvariantsFromNode(this-&gt;root(), 0);</span>
135     }
136 
<span class="line-modified">137 private:</span>
<span class="line-removed">138     typedef typename PODRedBlackTree&lt;IntervalType&gt;::Node IntervalNode;</span>
139 
<span class="line-modified">140     // Initializes the tree.</span>
<span class="line-modified">141     void init()</span>
<span class="line-modified">142     {</span>
<span class="line-removed">143         // Explicit dereference of &quot;this&quot; required because of</span>
<span class="line-removed">144         // inheritance rules in template classes.</span>
<span class="line-removed">145         this-&gt;setNeedsFullOrderingComparisons(true);</span>
<span class="line-removed">146     }</span>
147 
148     // Starting from the given node, adds all overlaps with the given
149     // interval to the result vector. The intervals are sorted by
150     // increasing low endpoint.
<span class="line-modified">151     template &lt;class AdapterType&gt;</span>
<span class="line-removed">152     void searchForOverlapsFrom(IntervalNode* node, AdapterType&amp; adapter) const</span>
153     {
154         if (!node)
155             return;
156 
157         // Because the intervals are sorted by left endpoint, inorder
158         // traversal produces results sorted as desired.
159 
160         // See whether we need to traverse the left subtree.
161         IntervalNode* left = node-&gt;left();
162         if (left
163             // This is phrased this way to avoid the need for operator
164             // &lt;= on type T.
165             &amp;&amp; !(left-&gt;data().maxHigh() &lt; adapter.lowValue()))
166             searchForOverlapsFrom&lt;AdapterType&gt;(left, adapter);
167 
168         // Check for overlap with current node.
169         adapter.collectIfNeeded(node-&gt;data());
170 
171         // See whether we need to traverse the right subtree.
172         // This is phrased this way to avoid the need for operator &lt;=
173         // on type T.
174         if (!(adapter.highValue() &lt; node-&gt;data().low()))
175             searchForOverlapsFrom&lt;AdapterType&gt;(node-&gt;right(), adapter);
176     }
177 
<span class="line-modified">178     IntervalNode* smallestNodeGreaterThanFrom(const IntervalType&amp; interval, IntervalNode* node) const</span>
179     {
180         if (!node)
181             return nullptr;
182 
<span class="line-modified">183         if (!(interval.high() &lt; node-&gt;data().low()))</span>
<span class="line-modified">184             return smallestNodeGreaterThanFrom(interval, node-&gt;right());</span>
185 
<span class="line-modified">186         if (auto left = smallestNodeGreaterThanFrom(interval, node-&gt;right()))</span>
187             return left;
188 
189         return node;
<span class="line-removed">190 }</span>
<span class="line-removed">191 </span>
<span class="line-removed">192     bool updateNode(IntervalNode* node) override</span>
<span class="line-removed">193     {</span>
<span class="line-removed">194         // Would use const T&amp;, but need to reassign this reference in this</span>
<span class="line-removed">195         // function.</span>
<span class="line-removed">196         const T* curMax = &amp;node-&gt;data().high();</span>
<span class="line-removed">197         IntervalNode* left = node-&gt;left();</span>
<span class="line-removed">198         if (left) {</span>
<span class="line-removed">199             if (*curMax &lt; left-&gt;data().maxHigh())</span>
<span class="line-removed">200                 curMax = &amp;left-&gt;data().maxHigh();</span>
<span class="line-removed">201         }</span>
<span class="line-removed">202         IntervalNode* right = node-&gt;right();</span>
<span class="line-removed">203         if (right) {</span>
<span class="line-removed">204             if (*curMax &lt; right-&gt;data().maxHigh())</span>
<span class="line-removed">205                 curMax = &amp;right-&gt;data().maxHigh();</span>
<span class="line-removed">206         }</span>
<span class="line-removed">207         // This is phrased like this to avoid needing operator!= on type T.</span>
<span class="line-removed">208         if (!(*curMax == node-&gt;data().maxHigh())) {</span>
<span class="line-removed">209             node-&gt;data().setMaxHigh(*curMax);</span>
<span class="line-removed">210             return true;</span>
<span class="line-removed">211         }</span>
<span class="line-removed">212         return false;</span>
213     }
214 


215     bool checkInvariantsFromNode(IntervalNode* node, T* currentMaxValue) const
216     {
217         // These assignments are only done in order to avoid requiring
218         // a default constructor on type T.
219         T leftMaxValue(node-&gt;data().maxHigh());
220         T rightMaxValue(node-&gt;data().maxHigh());
221         IntervalNode* left = node-&gt;left();
222         IntervalNode* right = node-&gt;right();
223         if (left) {
224             if (!checkInvariantsFromNode(left, &amp;leftMaxValue))
225                 return false;
226         }
227         if (right) {
228             if (!checkInvariantsFromNode(right, &amp;rightMaxValue))
229                 return false;
230         }
231         if (!left &amp;&amp; !right) {
232             // Base case.
233             if (currentMaxValue)
234                 *currentMaxValue = node-&gt;data().high();
235             return (node-&gt;data().high() == node-&gt;data().maxHigh());
236         }
237         T localMaxValue(node-&gt;data().maxHigh());
238         if (!left || !right) {
239             if (left)
240                 localMaxValue = leftMaxValue;
241             else
242                 localMaxValue = rightMaxValue;
243         } else
244             localMaxValue = (leftMaxValue &lt; rightMaxValue) ? rightMaxValue : leftMaxValue;
245         if (localMaxValue &lt; node-&gt;data().high())
246             localMaxValue = node-&gt;data().high();
247         if (!(localMaxValue == node-&gt;data().maxHigh())) {
<span class="line-modified">248 #ifndef NDEBUG</span>
<span class="line-modified">249             String localMaxValueString = ValueToString&lt;T&gt;::string(localMaxValue);</span>
<span class="line-modified">250             LOG_ERROR(&quot;PODIntervalTree verification failed at node 0x%p: localMaxValue=%s and data=%s&quot;,</span>
<span class="line-modified">251                       node, localMaxValueString.utf8().data(), node-&gt;data().toString().utf8().data());</span>
<span class="line-removed">252 #endif</span>
253             return false;
254         }
255         if (currentMaxValue)
256             *currentMaxValue = localMaxValue;
257         return true;
258     }



259 };
260 
<span class="line-modified">261 } // namespace WebCore</span>


262 
<span class="line-modified">263 #ifndef NDEBUG</span>
<span class="line-modified">264 namespace WTF {</span>



265 
<span class="line-modified">266 // Support for printing PODIntervals at the PODRedBlackTree level.</span>
<span class="line-modified">267 template&lt;class T, class UserData&gt;</span>
<span class="line-modified">268 struct ValueToString&lt;WebCore::PODInterval&lt;T, UserData&gt;&gt; {</span>
<span class="line-removed">269     static String string(const WebCore::PODInterval&lt;T, UserData&gt;&amp; interval)</span>
270     {
<span class="line-modified">271         return interval.toString();</span>

272     }




273 };
274 
<span class="line-modified">275 } // namespace WTF</span>
<span class="line-modified">276 #endif</span>




















277 
<span class="line-modified">278 #endif // PODIntervalTree_h</span>
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.
<span class="line-added">  3  * Copyright (C) 2019-2020 Apple Inc. All rights reserved.</span>
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 17  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 18  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 19  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 22  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 24  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
<span class="line-modified"> 27 #pragma once</span>

 28 
 29 #include &quot;PODInterval.h&quot;
 30 #include &quot;PODRedBlackTree.h&quot;


 31 #include &lt;wtf/Optional.h&gt;
 32 #include &lt;wtf/Vector.h&gt;

 33 
<span class="line-modified"> 34 // FIXME: The prefix &quot;POD&quot; here isn&#39;t correct; this tree works with non-POD types.</span>





 35 
<span class="line-modified"> 36 namespace WebCore {</span>













 37 
<span class="line-modified"> 38 struct PODIntervalNodeUpdater;</span>




 39 
 40 // An interval tree, which is a form of augmented red-black tree. It
 41 // supports efficient (O(lg n)) insertion, removal and querying of
 42 // intervals in the tree.
<span class="line-modified"> 43 template&lt;typename T, typename UserData&gt; class PODIntervalTree final : public PODRedBlackTree&lt;PODInterval&lt;T, UserData&gt;, PODIntervalNodeUpdater&gt; {</span>

 44     WTF_MAKE_FAST_ALLOCATED;

 45 public:
<span class="line-modified"> 46     using IntervalType = PODInterval&lt;T, UserData&gt;;</span>
<span class="line-modified"> 47     class OverlapsSearchAdapter;</span>








 48 
<span class="line-modified"> 49     // Returns all intervals in the tree which overlap the given query interval, sorted by the &lt; operator.</span>


 50     Vector&lt;IntervalType&gt; allOverlaps(const IntervalType&amp; interval) const
 51     {
 52         Vector&lt;IntervalType&gt; result;
<span class="line-modified"> 53         OverlapsSearchAdapter adapter(result, interval);</span>
<span class="line-added"> 54         allOverlapsWithAdapter(adapter);</span>
 55         return result;
 56     }
 57 
<span class="line-modified"> 58     template&lt;typename AdapterType&gt; void allOverlapsWithAdapter(AdapterType&amp; adapter) const</span>












 59     {
<span class="line-modified"> 60         searchForOverlapsFrom(this-&gt;root(), adapter);</span>


 61     }
 62 
<span class="line-modified"> 63     Optional&lt;IntervalType&gt; nextIntervalAfter(const T&amp; point)</span>

 64     {
<span class="line-modified"> 65         auto next = smallestNodeGreaterThanFrom(point, this-&gt;root());</span>





 66         if (!next)
 67             return WTF::nullopt;

 68         return next-&gt;data();
 69     }
 70 
<span class="line-modified"> 71 #ifndef NDEBUG</span>
<span class="line-added"> 72 </span>
<span class="line-added"> 73     bool checkInvariants() const</span>
 74     {
<span class="line-modified"> 75         if (!Base::checkInvariants())</span>
 76             return false;
 77         if (!this-&gt;root())
 78             return true;
<span class="line-modified"> 79         return checkInvariantsFromNode(this-&gt;root(), nullptr);</span>
 80     }
 81 
<span class="line-modified"> 82 #endif</span>

 83 
<span class="line-modified"> 84 private:</span>
<span class="line-modified"> 85     using Base = PODRedBlackTree&lt;PODInterval&lt;T, UserData&gt;, PODIntervalNodeUpdater&gt;;</span>
<span class="line-modified"> 86     using IntervalNode = typename Base::Node;</span>




 87 
 88     // Starting from the given node, adds all overlaps with the given
 89     // interval to the result vector. The intervals are sorted by
 90     // increasing low endpoint.
<span class="line-modified"> 91     template&lt;typename AdapterType&gt; void searchForOverlapsFrom(IntervalNode* node, AdapterType&amp; adapter) const</span>

 92     {
 93         if (!node)
 94             return;
 95 
 96         // Because the intervals are sorted by left endpoint, inorder
 97         // traversal produces results sorted as desired.
 98 
 99         // See whether we need to traverse the left subtree.
100         IntervalNode* left = node-&gt;left();
101         if (left
102             // This is phrased this way to avoid the need for operator
103             // &lt;= on type T.
104             &amp;&amp; !(left-&gt;data().maxHigh() &lt; adapter.lowValue()))
105             searchForOverlapsFrom&lt;AdapterType&gt;(left, adapter);
106 
107         // Check for overlap with current node.
108         adapter.collectIfNeeded(node-&gt;data());
109 
110         // See whether we need to traverse the right subtree.
111         // This is phrased this way to avoid the need for operator &lt;=
112         // on type T.
113         if (!(adapter.highValue() &lt; node-&gt;data().low()))
114             searchForOverlapsFrom&lt;AdapterType&gt;(node-&gt;right(), adapter);
115     }
116 
<span class="line-modified">117     IntervalNode* smallestNodeGreaterThanFrom(const T&amp; point, IntervalNode* node) const</span>
118     {
119         if (!node)
120             return nullptr;
121 
<span class="line-modified">122         if (!(point &lt; node-&gt;data().low()))</span>
<span class="line-modified">123             return smallestNodeGreaterThanFrom(point, node-&gt;right());</span>
124 
<span class="line-modified">125         if (auto left = smallestNodeGreaterThanFrom(point, node-&gt;right()))</span>
126             return left;
127 
128         return node;























129     }
130 
<span class="line-added">131 #ifndef NDEBUG</span>
<span class="line-added">132 </span>
133     bool checkInvariantsFromNode(IntervalNode* node, T* currentMaxValue) const
134     {
135         // These assignments are only done in order to avoid requiring
136         // a default constructor on type T.
137         T leftMaxValue(node-&gt;data().maxHigh());
138         T rightMaxValue(node-&gt;data().maxHigh());
139         IntervalNode* left = node-&gt;left();
140         IntervalNode* right = node-&gt;right();
141         if (left) {
142             if (!checkInvariantsFromNode(left, &amp;leftMaxValue))
143                 return false;
144         }
145         if (right) {
146             if (!checkInvariantsFromNode(right, &amp;rightMaxValue))
147                 return false;
148         }
149         if (!left &amp;&amp; !right) {
150             // Base case.
151             if (currentMaxValue)
152                 *currentMaxValue = node-&gt;data().high();
153             return (node-&gt;data().high() == node-&gt;data().maxHigh());
154         }
155         T localMaxValue(node-&gt;data().maxHigh());
156         if (!left || !right) {
157             if (left)
158                 localMaxValue = leftMaxValue;
159             else
160                 localMaxValue = rightMaxValue;
161         } else
162             localMaxValue = (leftMaxValue &lt; rightMaxValue) ? rightMaxValue : leftMaxValue;
163         if (localMaxValue &lt; node-&gt;data().high())
164             localMaxValue = node-&gt;data().high();
165         if (!(localMaxValue == node-&gt;data().maxHigh())) {
<span class="line-modified">166             TextStream stream;</span>
<span class="line-modified">167             stream &lt;&lt; &quot;localMaxValue=&quot; &lt;&lt; localMaxValue &lt;&lt; &quot;and data =&quot; &lt;&lt; node-&gt;data();</span>
<span class="line-modified">168             LOG_ERROR(&quot;PODIntervalTree verification failed at node 0x%p: %s&quot;,</span>
<span class="line-modified">169                 node, stream.release().utf8().data());</span>

170             return false;
171         }
172         if (currentMaxValue)
173             *currentMaxValue = localMaxValue;
174         return true;
175     }
<span class="line-added">176 </span>
<span class="line-added">177 #endif</span>
<span class="line-added">178 </span>
179 };
180 
<span class="line-modified">181 template&lt;typename T, typename UserData&gt; class PODIntervalTree&lt;T, UserData&gt;::OverlapsSearchAdapter {</span>
<span class="line-added">182 public:</span>
<span class="line-added">183     using IntervalType = PODInterval&lt;T, UserData&gt;;</span>
184 
<span class="line-modified">185     OverlapsSearchAdapter(Vector&lt;IntervalType&gt;&amp; result, const IntervalType&amp; interval)</span>
<span class="line-modified">186         : m_result(result)</span>
<span class="line-added">187         , m_interval(interval)</span>
<span class="line-added">188     {</span>
<span class="line-added">189     }</span>
190 
<span class="line-modified">191     const T&amp; lowValue() const { return m_interval.low(); }</span>
<span class="line-modified">192     const T&amp; highValue() const { return m_interval.high(); }</span>
<span class="line-modified">193     void collectIfNeeded(const IntervalType&amp; data) const</span>

194     {
<span class="line-modified">195         if (data.overlaps(m_interval))</span>
<span class="line-added">196             m_result.append(data);</span>
197     }
<span class="line-added">198 </span>
<span class="line-added">199 private:</span>
<span class="line-added">200     Vector&lt;IntervalType&gt;&amp; m_result;</span>
<span class="line-added">201     const IntervalType&amp; m_interval;</span>
202 };
203 
<span class="line-modified">204 struct PODIntervalNodeUpdater {</span>
<span class="line-modified">205     template&lt;typename Node&gt; static bool update(Node&amp; node)</span>
<span class="line-added">206     {</span>
<span class="line-added">207         auto* curMax = &amp;node.data().high();</span>
<span class="line-added">208         auto* left = node.left();</span>
<span class="line-added">209         if (left) {</span>
<span class="line-added">210             if (*curMax &lt; left-&gt;data().maxHigh())</span>
<span class="line-added">211                 curMax = &amp;left-&gt;data().maxHigh();</span>
<span class="line-added">212         }</span>
<span class="line-added">213         auto* right = node.right();</span>
<span class="line-added">214         if (right) {</span>
<span class="line-added">215             if (*curMax &lt; right-&gt;data().maxHigh())</span>
<span class="line-added">216                 curMax = &amp;right-&gt;data().maxHigh();</span>
<span class="line-added">217         }</span>
<span class="line-added">218         // This is phrased like this to avoid needing operator!= on type T.</span>
<span class="line-added">219         if (!(*curMax == node.data().maxHigh())) {</span>
<span class="line-added">220             node.data().setMaxHigh(*curMax);</span>
<span class="line-added">221             return true;</span>
<span class="line-added">222         }</span>
<span class="line-added">223         return false;</span>
<span class="line-added">224     }</span>
<span class="line-added">225 };</span>
226 
<span class="line-modified">227 } // namespace WebCore</span>
</pre>
</td>
</tr>
</table>
<center><a href="PODInterval.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PODRedBlackTree.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
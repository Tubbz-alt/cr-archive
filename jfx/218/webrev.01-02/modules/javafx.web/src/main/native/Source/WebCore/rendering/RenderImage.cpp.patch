diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderImage.cpp b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderImage.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderImage.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderImage.cpp
@@ -243,14 +243,12 @@
     if (m_needsToSetSizeForAltText) {
         if (!m_altText.isEmpty() && setImageSizeForAltText(cachedImage()))
             repaintOrMarkForLayout(ImageSizeChangeForAltText);
         m_needsToSetSizeForAltText = false;
     }
-#if ENABLE(CSS_IMAGE_ORIENTATION)
     if (diff == StyleDifference::Layout && oldStyle->imageOrientation() != style().imageOrientation())
         return repaintOrMarkForLayout(ImageSizeChangeNone);
-#endif
 
 #if ENABLE(CSS_IMAGE_RESOLUTION)
     if (diff == StyleDifference::Layout
         && (oldStyle->imageResolution() != style().imageResolution()
             || oldStyle->imageResolutionSnap() != style().imageResolutionSnap()
@@ -378,20 +376,34 @@
 
     if (is<HTMLImageElement>(element()))
         page().didFinishLoadingImageForElement(downcast<HTMLImageElement>(*element()));
 }
 
+void RenderImage::setImageDevicePixelRatio(float factor)
+{
+    if (m_imageDevicePixelRatio == factor)
+        return;
+
+    m_imageDevicePixelRatio = factor;
+    intrinsicSizeChanged();
+}
+
 bool RenderImage::isShowingMissingOrImageError() const
 {
     return !imageResource().cachedImage() || imageResource().errorOccurred();
 }
 
 bool RenderImage::isShowingAltText() const
 {
     return isShowingMissingOrImageError() && !m_altText.isEmpty();
 }
 
+bool RenderImage::shouldDisplayBrokenImageIcon() const
+{
+    return imageResource().errorOccurred();
+}
+
 bool RenderImage::hasNonBitmapImage() const
 {
     if (!imageResource().cachedImage())
         return false;
 
@@ -429,11 +441,11 @@
 
     auto contentSize = this->contentSize();
     float deviceScaleFactor = document().deviceScaleFactor();
     LayoutUnit missingImageBorderWidth(1 / deviceScaleFactor);
 
-    if (!imageResource().cachedImage() || imageResource().errorOccurred()) {
+    if (!imageResource().cachedImage() || shouldDisplayBrokenImageIcon()) {
         if (paintInfo.phase == PaintPhase::Selection)
             return;
 
         if (paintInfo.phase == PaintPhase::Foreground)
             page().addRelevantUnpaintedObject(this, visualOverflowRect());
@@ -447,21 +459,22 @@
             LayoutUnit topPad = paddingTop();
 
             bool errorPictureDrawn = false;
             LayoutSize imageOffset;
             // When calculating the usable dimensions, exclude the pixels of
-            // the ouline rect so the error image/alt text doesn't draw on it.
+            // the outline rect so the error image/alt text doesn't draw on it.
             LayoutSize usableSize = contentSize - LayoutSize(2 * missingImageBorderWidth, 2 * missingImageBorderWidth);
 
             RefPtr<Image> image = imageResource().image();
 
-            if (imageResource().errorOccurred() && !image->isNull() && usableSize.width() >= image->width() && usableSize.height() >= image->height()) {
+            if (shouldDisplayBrokenImageIcon() && !image->isNull() && usableSize.width() >= image->width() && usableSize.height() >= image->height()) {
                 // Call brokenImage() explicitly to ensure we get the broken image icon at the appropriate resolution.
                 std::pair<Image*, float> brokenImageAndImageScaleFactor = cachedImage()->brokenImage(deviceScaleFactor);
                 image = brokenImageAndImageScaleFactor.first;
                 FloatSize imageSize = image->size();
                 imageSize.scale(1 / brokenImageAndImageScaleFactor.second);
+
                 // Center the error image, accounting for border and padding.
                 LayoutUnit centerX { (usableSize.width() - imageSize.width()) / 2 };
                 if (centerX < 0)
                     centerX = 0;
                 LayoutUnit centerY { (usableSize.height() - imageSize.height()) / 2 };
@@ -615,26 +628,30 @@
     RefPtr<Image> img = imageResource().image(flooredIntSize(rect.size()));
     if (!img || img->isNull())
         return ImageDrawResult::DidNothing;
 
     HTMLImageElement* imageElement = is<HTMLImageElement>(element()) ? downcast<HTMLImageElement>(element()) : nullptr;
-    CompositeOperator compositeOperator = imageElement ? imageElement->compositeOperator() : CompositeSourceOver;
 
     // FIXME: Document when image != img.get().
     Image* image = imageResource().image().get();
-    InterpolationQuality interpolation = image ? chooseInterpolationQuality(paintInfo.context(), *image, image, LayoutSize(rect.size())) : InterpolationDefault;
 
 #if USE(CG)
     if (is<PDFDocumentImage>(image))
         downcast<PDFDocumentImage>(*image).setPdfImageCachingPolicy(settings().pdfImageCachingPolicy());
 #endif
 
     if (is<BitmapImage>(image))
         downcast<BitmapImage>(*image).updateFromSettings(settings());
 
-    auto decodingMode = decodingModeForImageDraw(*image, paintInfo);
-    auto drawResult = paintInfo.context().drawImage(*img, rect, { compositeOperator, BlendMode::Normal, decodingMode, imageOrientation(), interpolation });
+    ImagePaintingOptions options = {
+        imageElement ? imageElement->compositeOperator() : CompositeOperator::SourceOver,
+        decodingModeForImageDraw(*image, paintInfo),
+        imageOrientation(),
+        image ? chooseInterpolationQuality(paintInfo.context(), *image, image, LayoutSize(rect.size())) : InterpolationQuality::Default
+    };
+
+    auto drawResult = paintInfo.context().drawImage(*img, rect, options);
     if (drawResult == ImageDrawResult::DidRequestDecoding)
         imageResource().cachedImage()->addClientWaitingForAsyncDecoding(*this);
 
 #if USE(SYSTEM_PREVIEW)
     if (imageElement && imageElement->isSystemPreviewImage() && drawResult == ImageDrawResult::DidDraw && RuntimeEnabledFeatures::sharedFeatures().systemPreviewEnabled())
@@ -817,12 +834,13 @@
             auto& box = downcast<RenderBox>(*containingBlock);
             intrinsicSize.setWidth(box.availableLogicalWidth());
             intrinsicSize.setHeight(box.availableLogicalHeight(IncludeMarginBorderPadding));
         }
     }
+
     // Don't compute an intrinsic ratio to preserve historical WebKit behavior if we're painting alt text and/or a broken image.
-    if (imageResource().errorOccurred()) {
+    if (shouldDisplayBrokenImageIcon()) {
         intrinsicRatio = 1;
         return;
     }
 }
 

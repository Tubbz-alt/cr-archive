<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/Heap.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Heap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HeapCell.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/Heap.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Lesser General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;ArrayBuffer.h&quot;
 25 #include &quot;CellState.h&quot;
 26 #include &quot;CollectionScope.h&quot;
 27 #include &quot;CollectorPhase.h&quot;
 28 #include &quot;DeleteAllCodeEffort.h&quot;
 29 #include &quot;GCConductor.h&quot;
 30 #include &quot;GCIncomingRefCountedSet.h&quot;

 31 #include &quot;GCRequest.h&quot;
 32 #include &quot;HandleSet.h&quot;
 33 #include &quot;HeapFinalizerCallback.h&quot;
 34 #include &quot;HeapObserver.h&quot;
 35 #include &quot;MarkedBlock.h&quot;
 36 #include &quot;MarkedSpace.h&quot;
 37 #include &quot;MutatorState.h&quot;
 38 #include &quot;Options.h&quot;
 39 #include &quot;StructureIDTable.h&quot;
 40 #include &quot;Synchronousness.h&quot;
 41 #include &quot;WeakHandleOwner.h&quot;
 42 #include &lt;wtf/AutomaticThread.h&gt;
 43 #include &lt;wtf/ConcurrentPtrHashSet.h&gt;
 44 #include &lt;wtf/Deque.h&gt;
 45 #include &lt;wtf/HashCountedSet.h&gt;
 46 #include &lt;wtf/HashSet.h&gt;
 47 #include &lt;wtf/Markable.h&gt;
 48 #include &lt;wtf/ParallelHelperPool.h&gt;
 49 #include &lt;wtf/Threading.h&gt;
 50 
</pre>
<hr />
<pre>
 78 class MarkingConstraintSet;
 79 class MutatorScheduler;
 80 class RunningScope;
 81 class SlotVisitor;
 82 class SpaceTimeMutatorScheduler;
 83 class StopIfNecessaryTimer;
 84 class SweepingScope;
 85 class VM;
 86 class WeakGCMapBase;
 87 struct CurrentThreadState;
 88 
 89 #ifdef JSC_GLIB_API_ENABLED
 90 class JSCGLibWrapperObject;
 91 #endif
 92 
 93 namespace DFG {
 94 class SpeculativeJIT;
 95 class Worklist;
 96 }
 97 
<span class="line-modified"> 98 #if !ASSERT_DISABLED</span>
<span class="line-removed"> 99 #define ENABLE_DFG_DOES_GC_VALIDATION 1</span>
<span class="line-removed">100 #else</span>
<span class="line-removed">101 #define ENABLE_DFG_DOES_GC_VALIDATION 0</span>
<span class="line-removed">102 #endif</span>
103 constexpr bool validateDFGDoesGC = ENABLE_DFG_DOES_GC_VALIDATION;
104 
105 typedef HashCountedSet&lt;JSCell*&gt; ProtectCountSet;
106 typedef HashCountedSet&lt;const char*&gt; TypeCountSet;
107 
108 enum HeapType { SmallHeap, LargeHeap };
109 
110 class HeapUtil;
111 
112 class Heap {
113     WTF_MAKE_NONCOPYABLE(Heap);
114 public:
115     friend class JIT;
116     friend class DFG::SpeculativeJIT;
117     static Heap* heap(const JSValue); // 0 for immediate values
118     static Heap* heap(const HeapCell*);
119 
120     // This constant determines how many blocks we iterate between checks of our
121     // deadline when calling Heap::isPagedOut. Decreasing it will cause us to detect
122     // overstepping our deadline more quickly, while increasing it will cause
123     // our scan to run faster.
<span class="line-modified">124     static const unsigned s_timeCheckResolution = 16;</span>
125 
126     bool isMarked(const void*);
127     static bool testAndSetMarked(HeapVersion, const void*);
128 
129     static size_t cellSize(const void*);
130 
131     void writeBarrier(const JSCell* from);
132     void writeBarrier(const JSCell* from, JSValue to);
133     void writeBarrier(const JSCell* from, JSCell* to);
134 
135     void writeBarrierWithoutFence(const JSCell* from);
136 
137     void mutatorFence();
138 
139     // Take this if you know that from-&gt;cellState() &lt; barrierThreshold.
140     JS_EXPORT_PRIVATE void writeBarrierSlowPath(const JSCell* from);
141 
142     Heap(VM&amp;, HeapType);
143     ~Heap();
144     void lastChanceToFinalize();
</pre>
<hr />
<pre>
153 
154     JS_EXPORT_PRIVATE GCActivityCallback* fullActivityCallback();
155     JS_EXPORT_PRIVATE GCActivityCallback* edenActivityCallback();
156     JS_EXPORT_PRIVATE void setGarbageCollectionTimerEnabled(bool);
157 
158     JS_EXPORT_PRIVATE IncrementalSweeper&amp; sweeper();
159 
160     void addObserver(HeapObserver* observer) { m_observers.append(observer); }
161     void removeObserver(HeapObserver* observer) { m_observers.removeFirst(observer); }
162 
163     MutatorState mutatorState() const { return m_mutatorState; }
164     Optional&lt;CollectionScope&gt; collectionScope() const { return m_collectionScope; }
165     bool hasHeapAccess() const;
166     bool worldIsStopped() const;
167     bool worldIsRunning() const { return !worldIsStopped(); }
168 
169     // We&#39;re always busy on the collection threads. On the main thread, this returns true if we&#39;re
170     // helping heap.
171     JS_EXPORT_PRIVATE bool isCurrentThreadBusy();
172 
<span class="line-modified">173     typedef void (*Finalizer)(JSCell*);</span>
<span class="line-modified">174     JS_EXPORT_PRIVATE void addFinalizer(JSCell*, Finalizer);</span>


175 
176     void notifyIsSafeToCollect();
177     bool isSafeToCollect() const { return m_isSafeToCollect; }
178 
179     bool isShuttingDown() const { return m_isShuttingDown; }
180 
181     JS_EXPORT_PRIVATE bool isAnalyzingHeap() const;
182 
183     JS_EXPORT_PRIVATE void sweepSynchronously();
184 
185     bool shouldCollectHeuristic();
186 
187     // Queue up a collection. Returns immediately. This will not queue a collection if a collection
188     // of equal or greater strength exists. Full collections are stronger than WTF::nullopt collections
189     // and WTF::nullopt collections are stronger than Eden collections. WTF::nullopt means that the GC can
190     // choose Eden or Full. This implies that if you request a GC while that GC is ongoing, nothing
191     // will happen.
192     JS_EXPORT_PRIVATE void collectAsync(GCRequest = GCRequest());
193 
194     // Queue up a collection and wait for it to complete. This won&#39;t return until you get your own
</pre>
<hr />
<pre>
411     friend class HeapUtil;
412     friend class HeapVerifier;
413     friend class JITStubRoutine;
414     friend class LLIntOffsetsExtractor;
415     friend class MarkStackMergingConstraint;
416     friend class MarkedSpace;
417     friend class BlockDirectory;
418     friend class MarkedBlock;
419     friend class RunningScope;
420     friend class SlotVisitor;
421     friend class SpaceTimeMutatorScheduler;
422     friend class StochasticSpaceTimeMutatorScheduler;
423     friend class SweepingScope;
424     friend class IncrementalSweeper;
425     friend class VM;
426     friend class WeakSet;
427 
428     class HeapThread;
429     friend class HeapThread;
430 
<span class="line-modified">431     static const size_t minExtraMemory = 256;</span>




432 
<span class="line-modified">433     class FinalizerOwner : public WeakHandleOwner {</span>
434         void finalize(Handle&lt;Unknown&gt;, void* context) override;
435     };
436 
437     JS_EXPORT_PRIVATE bool isValidAllocation(size_t);
438     JS_EXPORT_PRIVATE void reportExtraMemoryAllocatedSlowCase(size_t);
439     JS_EXPORT_PRIVATE void deprecatedReportExtraMemorySlowCase(size_t);
440 
441     bool shouldCollectInCollectorThread(const AbstractLocker&amp;);
442     void collectInCollectorThread();
443 
444     void checkConn(GCConductor);
445 
446     enum class RunCurrentPhaseResult {
447         Finished,
448         Continue,
449         NeedCurrentThreadState
450     };
451     RunCurrentPhaseResult runCurrentPhase(GCConductor, CurrentThreadState*);
452 
453     // Returns true if we should keep doing things.
</pre>
<hr />
<pre>
616     std::unique_ptr&lt;HashSet&lt;MarkedArgumentBuffer*&gt;&gt; m_markListSet;
617 
618     std::unique_ptr&lt;MachineThreads&gt; m_machineThreads;
619 
620     std::unique_ptr&lt;SlotVisitor&gt; m_collectorSlotVisitor;
621     std::unique_ptr&lt;SlotVisitor&gt; m_mutatorSlotVisitor;
622     std::unique_ptr&lt;MarkStackArray&gt; m_mutatorMarkStack;
623     std::unique_ptr&lt;MarkStackArray&gt; m_raceMarkStack;
624     std::unique_ptr&lt;MarkingConstraintSet&gt; m_constraintSet;
625 
626     // We pool the slot visitors used by parallel marking threads. It&#39;s useful to be able to
627     // enumerate over them, and it&#39;s useful to have them cache some small amount of memory from
628     // one GC to the next. GC marking threads claim these at the start of marking, and return
629     // them at the end.
630     Vector&lt;std::unique_ptr&lt;SlotVisitor&gt;&gt; m_parallelSlotVisitors;
631     Vector&lt;SlotVisitor*&gt; m_availableParallelSlotVisitors;
632 
633     HandleSet m_handleSet;
634     std::unique_ptr&lt;CodeBlockSet&gt; m_codeBlocks;
635     std::unique_ptr&lt;JITStubRoutineSet&gt; m_jitStubRoutines;
<span class="line-modified">636     FinalizerOwner m_finalizerOwner;</span>

637 
638     Lock m_parallelSlotVisitorLock;
639     bool m_isSafeToCollect { false };
640     bool m_isShuttingDown { false };
641     bool m_mutatorShouldBeFenced { Options::forceFencedBarrier() };
642 
643     unsigned m_barrierThreshold { Options::forceFencedBarrier() ? tautologicalThreshold : blackThreshold };
644 
645     VM&amp; m_vm;
646     Seconds m_lastFullGCLength { 10_ms };
647     Seconds m_lastEdenGCLength { 10_ms };
648 
649     Vector&lt;WeakBlock*&gt; m_logicallyEmptyWeakBlocks;
650     size_t m_indexOfNextLogicallyEmptyWeakBlockToSweep { WTF::notFound };
651 
652     RefPtr&lt;FullGCActivityCallback&gt; m_fullActivityCallback;
653     RefPtr&lt;GCActivityCallback&gt; m_edenActivityCallback;
654     Ref&lt;IncrementalSweeper&gt; m_sweeper;
655     Ref&lt;StopIfNecessaryTimer&gt; m_stopIfNecessaryTimer;
656 
</pre>
<hr />
<pre>
661     std::unique_ptr&lt;HeapVerifier&gt; m_verifier;
662 
663 #if USE(FOUNDATION)
664     Vector&lt;RetainPtr&lt;CFTypeRef&gt;&gt; m_delayedReleaseObjects;
665     unsigned m_delayedReleaseRecursionCount { 0 };
666 #endif
667 #ifdef JSC_GLIB_API_ENABLED
668     Vector&lt;std::unique_ptr&lt;JSCGLibWrapperObject&gt;&gt; m_delayedReleaseObjects;
669     unsigned m_delayedReleaseRecursionCount { 0 };
670 #endif
671     unsigned m_deferralDepth { 0 };
672 
673     HashSet&lt;WeakGCMapBase*&gt; m_weakGCMaps;
674 
675     std::unique_ptr&lt;MarkStackArray&gt; m_sharedCollectorMarkStack;
676     std::unique_ptr&lt;MarkStackArray&gt; m_sharedMutatorMarkStack;
677     unsigned m_numberOfActiveParallelMarkers { 0 };
678     unsigned m_numberOfWaitingParallelMarkers { 0 };
679 
680     ConcurrentPtrHashSet m_opaqueRoots;
<span class="line-modified">681     static const size_t s_blockFragmentLength = 32;</span>
682 
683     ParallelHelperClient m_helperClient;
684     RefPtr&lt;SharedTask&lt;void(SlotVisitor&amp;)&gt;&gt; m_bonusVisitorTask;
685 
686 #if ENABLE(RESOURCE_USAGE)
687     size_t m_blockBytesAllocated { 0 };
688     size_t m_externalMemorySize { 0 };
689 #endif
690 
691     std::unique_ptr&lt;MutatorScheduler&gt; m_scheduler;
692 
<span class="line-modified">693     static const unsigned mutatorHasConnBit = 1u &lt;&lt; 0u; // Must also be protected by threadLock.</span>
<span class="line-modified">694     static const unsigned stoppedBit = 1u &lt;&lt; 1u; // Only set when !hasAccessBit</span>
<span class="line-modified">695     static const unsigned hasAccessBit = 1u &lt;&lt; 2u;</span>
<span class="line-modified">696     static const unsigned gcDidJITBit = 1u &lt;&lt; 3u; // Set when the GC did some JITing, so on resume we need to cpuid.</span>
<span class="line-modified">697     static const unsigned needFinalizeBit = 1u &lt;&lt; 4u;</span>
<span class="line-modified">698     static const unsigned mutatorWaitingBit = 1u &lt;&lt; 5u; // Allows the mutator to use this as a condition variable.</span>
699     Atomic&lt;unsigned&gt; m_worldState;
700     bool m_worldIsStopped { false };
701     Lock m_visitRaceLock;
702     Lock m_markingMutex;
703     Condition m_markingConditionVariable;
704 
705     MonotonicTime m_beforeGC;
706     MonotonicTime m_afterGC;
707     MonotonicTime m_stopTime;
708 
709     Deque&lt;GCRequest&gt; m_requests;
710     GCRequest m_currentRequest;
711     Ticket m_lastServedTicket { 0 };
712     Ticket m_lastGrantedTicket { 0 };
713 
714     CollectorPhase m_lastPhase { CollectorPhase::NotRunning };
715     CollectorPhase m_currentPhase { CollectorPhase::NotRunning };
716     CollectorPhase m_nextPhase { CollectorPhase::NotRunning };
717     bool m_collectorThreadIsRunning { false };
718     bool m_threadShouldStop { false };
</pre>
<hr />
<pre>
722     bool m_shouldStopCollectingContinuously { false };
723 
724     uint64_t m_mutatorExecutionVersion { 0 };
725     uint64_t m_phaseVersion { 0 };
726     Box&lt;Lock&gt; m_threadLock;
727     Ref&lt;AutomaticThreadCondition&gt; m_threadCondition; // The mutator must not wait on this. It would cause a deadlock.
728     RefPtr&lt;AutomaticThread&gt; m_thread;
729 
730     RefPtr&lt;Thread&gt; m_collectContinuouslyThread { nullptr };
731 
732     MonotonicTime m_lastGCStartTime;
733     MonotonicTime m_lastGCEndTime;
734     MonotonicTime m_currentGCStartTime;
735     Seconds m_totalGCTime;
736 
737     uintptr_t m_barriersExecuted { 0 };
738 
739     CurrentThreadState* m_currentThreadState { nullptr };
740     Thread* m_currentThread { nullptr }; // It&#39;s OK if this becomes a dangling pointer.
741 
<span class="line-modified">742 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-modified">743     unsigned m_precentAvailableMemoryCachedCallCount;</span>
<span class="line-modified">744     bool m_overCriticalMemoryThreshold;</span>
745 #endif
746 
747     bool m_parallelMarkersShouldExit { false };
748     Lock m_collectContinuouslyLock;
749     Condition m_collectContinuouslyCondition;
750 };
751 
752 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Lesser General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;ArrayBuffer.h&quot;
 25 #include &quot;CellState.h&quot;
 26 #include &quot;CollectionScope.h&quot;
 27 #include &quot;CollectorPhase.h&quot;
 28 #include &quot;DeleteAllCodeEffort.h&quot;
 29 #include &quot;GCConductor.h&quot;
 30 #include &quot;GCIncomingRefCountedSet.h&quot;
<span class="line-added"> 31 #include &quot;GCMemoryOperations.h&quot;</span>
 32 #include &quot;GCRequest.h&quot;
 33 #include &quot;HandleSet.h&quot;
 34 #include &quot;HeapFinalizerCallback.h&quot;
 35 #include &quot;HeapObserver.h&quot;
 36 #include &quot;MarkedBlock.h&quot;
 37 #include &quot;MarkedSpace.h&quot;
 38 #include &quot;MutatorState.h&quot;
 39 #include &quot;Options.h&quot;
 40 #include &quot;StructureIDTable.h&quot;
 41 #include &quot;Synchronousness.h&quot;
 42 #include &quot;WeakHandleOwner.h&quot;
 43 #include &lt;wtf/AutomaticThread.h&gt;
 44 #include &lt;wtf/ConcurrentPtrHashSet.h&gt;
 45 #include &lt;wtf/Deque.h&gt;
 46 #include &lt;wtf/HashCountedSet.h&gt;
 47 #include &lt;wtf/HashSet.h&gt;
 48 #include &lt;wtf/Markable.h&gt;
 49 #include &lt;wtf/ParallelHelperPool.h&gt;
 50 #include &lt;wtf/Threading.h&gt;
 51 
</pre>
<hr />
<pre>
 79 class MarkingConstraintSet;
 80 class MutatorScheduler;
 81 class RunningScope;
 82 class SlotVisitor;
 83 class SpaceTimeMutatorScheduler;
 84 class StopIfNecessaryTimer;
 85 class SweepingScope;
 86 class VM;
 87 class WeakGCMapBase;
 88 struct CurrentThreadState;
 89 
 90 #ifdef JSC_GLIB_API_ENABLED
 91 class JSCGLibWrapperObject;
 92 #endif
 93 
 94 namespace DFG {
 95 class SpeculativeJIT;
 96 class Worklist;
 97 }
 98 
<span class="line-modified"> 99 #define ENABLE_DFG_DOES_GC_VALIDATION ASSERT_ENABLED</span>




100 constexpr bool validateDFGDoesGC = ENABLE_DFG_DOES_GC_VALIDATION;
101 
102 typedef HashCountedSet&lt;JSCell*&gt; ProtectCountSet;
103 typedef HashCountedSet&lt;const char*&gt; TypeCountSet;
104 
105 enum HeapType { SmallHeap, LargeHeap };
106 
107 class HeapUtil;
108 
109 class Heap {
110     WTF_MAKE_NONCOPYABLE(Heap);
111 public:
112     friend class JIT;
113     friend class DFG::SpeculativeJIT;
114     static Heap* heap(const JSValue); // 0 for immediate values
115     static Heap* heap(const HeapCell*);
116 
117     // This constant determines how many blocks we iterate between checks of our
118     // deadline when calling Heap::isPagedOut. Decreasing it will cause us to detect
119     // overstepping our deadline more quickly, while increasing it will cause
120     // our scan to run faster.
<span class="line-modified">121     static constexpr unsigned s_timeCheckResolution = 16;</span>
122 
123     bool isMarked(const void*);
124     static bool testAndSetMarked(HeapVersion, const void*);
125 
126     static size_t cellSize(const void*);
127 
128     void writeBarrier(const JSCell* from);
129     void writeBarrier(const JSCell* from, JSValue to);
130     void writeBarrier(const JSCell* from, JSCell* to);
131 
132     void writeBarrierWithoutFence(const JSCell* from);
133 
134     void mutatorFence();
135 
136     // Take this if you know that from-&gt;cellState() &lt; barrierThreshold.
137     JS_EXPORT_PRIVATE void writeBarrierSlowPath(const JSCell* from);
138 
139     Heap(VM&amp;, HeapType);
140     ~Heap();
141     void lastChanceToFinalize();
</pre>
<hr />
<pre>
150 
151     JS_EXPORT_PRIVATE GCActivityCallback* fullActivityCallback();
152     JS_EXPORT_PRIVATE GCActivityCallback* edenActivityCallback();
153     JS_EXPORT_PRIVATE void setGarbageCollectionTimerEnabled(bool);
154 
155     JS_EXPORT_PRIVATE IncrementalSweeper&amp; sweeper();
156 
157     void addObserver(HeapObserver* observer) { m_observers.append(observer); }
158     void removeObserver(HeapObserver* observer) { m_observers.removeFirst(observer); }
159 
160     MutatorState mutatorState() const { return m_mutatorState; }
161     Optional&lt;CollectionScope&gt; collectionScope() const { return m_collectionScope; }
162     bool hasHeapAccess() const;
163     bool worldIsStopped() const;
164     bool worldIsRunning() const { return !worldIsStopped(); }
165 
166     // We&#39;re always busy on the collection threads. On the main thread, this returns true if we&#39;re
167     // helping heap.
168     JS_EXPORT_PRIVATE bool isCurrentThreadBusy();
169 
<span class="line-modified">170     typedef void (*CFinalizer)(JSCell*);</span>
<span class="line-modified">171     JS_EXPORT_PRIVATE void addFinalizer(JSCell*, CFinalizer);</span>
<span class="line-added">172     using LambdaFinalizer = WTF::Function&lt;void(JSCell*)&gt;;</span>
<span class="line-added">173     JS_EXPORT_PRIVATE void addFinalizer(JSCell*, LambdaFinalizer);</span>
174 
175     void notifyIsSafeToCollect();
176     bool isSafeToCollect() const { return m_isSafeToCollect; }
177 
178     bool isShuttingDown() const { return m_isShuttingDown; }
179 
180     JS_EXPORT_PRIVATE bool isAnalyzingHeap() const;
181 
182     JS_EXPORT_PRIVATE void sweepSynchronously();
183 
184     bool shouldCollectHeuristic();
185 
186     // Queue up a collection. Returns immediately. This will not queue a collection if a collection
187     // of equal or greater strength exists. Full collections are stronger than WTF::nullopt collections
188     // and WTF::nullopt collections are stronger than Eden collections. WTF::nullopt means that the GC can
189     // choose Eden or Full. This implies that if you request a GC while that GC is ongoing, nothing
190     // will happen.
191     JS_EXPORT_PRIVATE void collectAsync(GCRequest = GCRequest());
192 
193     // Queue up a collection and wait for it to complete. This won&#39;t return until you get your own
</pre>
<hr />
<pre>
410     friend class HeapUtil;
411     friend class HeapVerifier;
412     friend class JITStubRoutine;
413     friend class LLIntOffsetsExtractor;
414     friend class MarkStackMergingConstraint;
415     friend class MarkedSpace;
416     friend class BlockDirectory;
417     friend class MarkedBlock;
418     friend class RunningScope;
419     friend class SlotVisitor;
420     friend class SpaceTimeMutatorScheduler;
421     friend class StochasticSpaceTimeMutatorScheduler;
422     friend class SweepingScope;
423     friend class IncrementalSweeper;
424     friend class VM;
425     friend class WeakSet;
426 
427     class HeapThread;
428     friend class HeapThread;
429 
<span class="line-modified">430     static constexpr size_t minExtraMemory = 256;</span>
<span class="line-added">431 </span>
<span class="line-added">432     class CFinalizerOwner : public WeakHandleOwner {</span>
<span class="line-added">433         void finalize(Handle&lt;Unknown&gt;, void* context) override;</span>
<span class="line-added">434     };</span>
435 
<span class="line-modified">436     class LambdaFinalizerOwner : public WeakHandleOwner {</span>
437         void finalize(Handle&lt;Unknown&gt;, void* context) override;
438     };
439 
440     JS_EXPORT_PRIVATE bool isValidAllocation(size_t);
441     JS_EXPORT_PRIVATE void reportExtraMemoryAllocatedSlowCase(size_t);
442     JS_EXPORT_PRIVATE void deprecatedReportExtraMemorySlowCase(size_t);
443 
444     bool shouldCollectInCollectorThread(const AbstractLocker&amp;);
445     void collectInCollectorThread();
446 
447     void checkConn(GCConductor);
448 
449     enum class RunCurrentPhaseResult {
450         Finished,
451         Continue,
452         NeedCurrentThreadState
453     };
454     RunCurrentPhaseResult runCurrentPhase(GCConductor, CurrentThreadState*);
455 
456     // Returns true if we should keep doing things.
</pre>
<hr />
<pre>
619     std::unique_ptr&lt;HashSet&lt;MarkedArgumentBuffer*&gt;&gt; m_markListSet;
620 
621     std::unique_ptr&lt;MachineThreads&gt; m_machineThreads;
622 
623     std::unique_ptr&lt;SlotVisitor&gt; m_collectorSlotVisitor;
624     std::unique_ptr&lt;SlotVisitor&gt; m_mutatorSlotVisitor;
625     std::unique_ptr&lt;MarkStackArray&gt; m_mutatorMarkStack;
626     std::unique_ptr&lt;MarkStackArray&gt; m_raceMarkStack;
627     std::unique_ptr&lt;MarkingConstraintSet&gt; m_constraintSet;
628 
629     // We pool the slot visitors used by parallel marking threads. It&#39;s useful to be able to
630     // enumerate over them, and it&#39;s useful to have them cache some small amount of memory from
631     // one GC to the next. GC marking threads claim these at the start of marking, and return
632     // them at the end.
633     Vector&lt;std::unique_ptr&lt;SlotVisitor&gt;&gt; m_parallelSlotVisitors;
634     Vector&lt;SlotVisitor*&gt; m_availableParallelSlotVisitors;
635 
636     HandleSet m_handleSet;
637     std::unique_ptr&lt;CodeBlockSet&gt; m_codeBlocks;
638     std::unique_ptr&lt;JITStubRoutineSet&gt; m_jitStubRoutines;
<span class="line-modified">639     CFinalizerOwner m_cFinalizerOwner;</span>
<span class="line-added">640     LambdaFinalizerOwner m_lambdaFinalizerOwner;</span>
641 
642     Lock m_parallelSlotVisitorLock;
643     bool m_isSafeToCollect { false };
644     bool m_isShuttingDown { false };
645     bool m_mutatorShouldBeFenced { Options::forceFencedBarrier() };
646 
647     unsigned m_barrierThreshold { Options::forceFencedBarrier() ? tautologicalThreshold : blackThreshold };
648 
649     VM&amp; m_vm;
650     Seconds m_lastFullGCLength { 10_ms };
651     Seconds m_lastEdenGCLength { 10_ms };
652 
653     Vector&lt;WeakBlock*&gt; m_logicallyEmptyWeakBlocks;
654     size_t m_indexOfNextLogicallyEmptyWeakBlockToSweep { WTF::notFound };
655 
656     RefPtr&lt;FullGCActivityCallback&gt; m_fullActivityCallback;
657     RefPtr&lt;GCActivityCallback&gt; m_edenActivityCallback;
658     Ref&lt;IncrementalSweeper&gt; m_sweeper;
659     Ref&lt;StopIfNecessaryTimer&gt; m_stopIfNecessaryTimer;
660 
</pre>
<hr />
<pre>
665     std::unique_ptr&lt;HeapVerifier&gt; m_verifier;
666 
667 #if USE(FOUNDATION)
668     Vector&lt;RetainPtr&lt;CFTypeRef&gt;&gt; m_delayedReleaseObjects;
669     unsigned m_delayedReleaseRecursionCount { 0 };
670 #endif
671 #ifdef JSC_GLIB_API_ENABLED
672     Vector&lt;std::unique_ptr&lt;JSCGLibWrapperObject&gt;&gt; m_delayedReleaseObjects;
673     unsigned m_delayedReleaseRecursionCount { 0 };
674 #endif
675     unsigned m_deferralDepth { 0 };
676 
677     HashSet&lt;WeakGCMapBase*&gt; m_weakGCMaps;
678 
679     std::unique_ptr&lt;MarkStackArray&gt; m_sharedCollectorMarkStack;
680     std::unique_ptr&lt;MarkStackArray&gt; m_sharedMutatorMarkStack;
681     unsigned m_numberOfActiveParallelMarkers { 0 };
682     unsigned m_numberOfWaitingParallelMarkers { 0 };
683 
684     ConcurrentPtrHashSet m_opaqueRoots;
<span class="line-modified">685     static constexpr size_t s_blockFragmentLength = 32;</span>
686 
687     ParallelHelperClient m_helperClient;
688     RefPtr&lt;SharedTask&lt;void(SlotVisitor&amp;)&gt;&gt; m_bonusVisitorTask;
689 
690 #if ENABLE(RESOURCE_USAGE)
691     size_t m_blockBytesAllocated { 0 };
692     size_t m_externalMemorySize { 0 };
693 #endif
694 
695     std::unique_ptr&lt;MutatorScheduler&gt; m_scheduler;
696 
<span class="line-modified">697     static constexpr unsigned mutatorHasConnBit = 1u &lt;&lt; 0u; // Must also be protected by threadLock.</span>
<span class="line-modified">698     static constexpr unsigned stoppedBit = 1u &lt;&lt; 1u; // Only set when !hasAccessBit</span>
<span class="line-modified">699     static constexpr unsigned hasAccessBit = 1u &lt;&lt; 2u;</span>
<span class="line-modified">700     static constexpr unsigned gcDidJITBit = 1u &lt;&lt; 3u; // Set when the GC did some JITing, so on resume we need to cpuid.</span>
<span class="line-modified">701     static constexpr unsigned needFinalizeBit = 1u &lt;&lt; 4u;</span>
<span class="line-modified">702     static constexpr unsigned mutatorWaitingBit = 1u &lt;&lt; 5u; // Allows the mutator to use this as a condition variable.</span>
703     Atomic&lt;unsigned&gt; m_worldState;
704     bool m_worldIsStopped { false };
705     Lock m_visitRaceLock;
706     Lock m_markingMutex;
707     Condition m_markingConditionVariable;
708 
709     MonotonicTime m_beforeGC;
710     MonotonicTime m_afterGC;
711     MonotonicTime m_stopTime;
712 
713     Deque&lt;GCRequest&gt; m_requests;
714     GCRequest m_currentRequest;
715     Ticket m_lastServedTicket { 0 };
716     Ticket m_lastGrantedTicket { 0 };
717 
718     CollectorPhase m_lastPhase { CollectorPhase::NotRunning };
719     CollectorPhase m_currentPhase { CollectorPhase::NotRunning };
720     CollectorPhase m_nextPhase { CollectorPhase::NotRunning };
721     bool m_collectorThreadIsRunning { false };
722     bool m_threadShouldStop { false };
</pre>
<hr />
<pre>
726     bool m_shouldStopCollectingContinuously { false };
727 
728     uint64_t m_mutatorExecutionVersion { 0 };
729     uint64_t m_phaseVersion { 0 };
730     Box&lt;Lock&gt; m_threadLock;
731     Ref&lt;AutomaticThreadCondition&gt; m_threadCondition; // The mutator must not wait on this. It would cause a deadlock.
732     RefPtr&lt;AutomaticThread&gt; m_thread;
733 
734     RefPtr&lt;Thread&gt; m_collectContinuouslyThread { nullptr };
735 
736     MonotonicTime m_lastGCStartTime;
737     MonotonicTime m_lastGCEndTime;
738     MonotonicTime m_currentGCStartTime;
739     Seconds m_totalGCTime;
740 
741     uintptr_t m_barriersExecuted { 0 };
742 
743     CurrentThreadState* m_currentThreadState { nullptr };
744     Thread* m_currentThread { nullptr }; // It&#39;s OK if this becomes a dangling pointer.
745 
<span class="line-modified">746 #if USE(BMALLOC_MEMORY_FOOTPRINT_API)</span>
<span class="line-modified">747     unsigned m_percentAvailableMemoryCachedCallCount { 0 };</span>
<span class="line-modified">748     bool m_overCriticalMemoryThreshold { false };</span>
749 #endif
750 
751     bool m_parallelMarkersShouldExit { false };
752     Lock m_collectContinuouslyLock;
753     Condition m_collectContinuouslyCondition;
754 };
755 
756 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="Heap.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HeapCell.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
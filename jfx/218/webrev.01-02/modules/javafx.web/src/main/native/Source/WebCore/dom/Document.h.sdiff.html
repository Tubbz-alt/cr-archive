<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/Document.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Document.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Document.idl.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/Document.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  14  * version 2 of the License, or (at your option) any later version.
  15  *
  16  * This library is distributed in the hope that it will be useful,
  17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19  * Library General Public License for more details.
  20  *
  21  * You should have received a copy of the GNU Library General Public License
  22  * along with this library; see the file COPYING.LIB.  If not, write to
  23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24  * Boston, MA 02110-1301, USA.
  25  *
  26  */
  27 
  28 #pragma once
  29 
  30 #include &quot;CSSRegisteredCustomProperty.h&quot;
  31 #include &quot;Color.h&quot;
  32 #include &quot;ContainerNode.h&quot;
  33 #include &quot;DisabledAdaptations.h&quot;
<span class="line-removed">  34 #include &quot;DocumentEventQueue.h&quot;</span>
  35 #include &quot;DocumentIdentifier.h&quot;
  36 #include &quot;DocumentTiming.h&quot;
  37 #include &quot;ElementIdentifier.h&quot;
  38 #include &quot;FocusDirection.h&quot;
  39 #include &quot;FontSelectorClient.h&quot;
  40 #include &quot;FrameDestructionObserver.h&quot;

  41 #include &quot;GenericTaskQueue.h&quot;
  42 #include &quot;GraphicsTypes.h&quot;
  43 #include &quot;MediaProducer.h&quot;
  44 #include &quot;MutationObserver.h&quot;
  45 #include &quot;OrientationNotifier.h&quot;
  46 #include &quot;PageIdentifier.h&quot;
  47 #include &quot;PlatformEvent.h&quot;
  48 #include &quot;ReferrerPolicy.h&quot;
  49 #include &quot;Region.h&quot;
  50 #include &quot;RegistrableDomain.h&quot;
  51 #include &quot;RenderPtr.h&quot;
  52 #include &quot;ScriptExecutionContext.h&quot;
  53 #include &quot;SecurityPolicyViolationEvent.h&quot;
  54 #include &quot;StringWithDirection.h&quot;
  55 #include &quot;StyleColor.h&quot;
  56 #include &quot;Supplementable.h&quot;
  57 #include &quot;TextResourceDecoder.h&quot;
  58 #include &quot;Timer.h&quot;
  59 #include &quot;TreeScope.h&quot;
  60 #include &quot;UserActionElementSet.h&quot;
</pre>
<hr />
<pre>
  64 #include &lt;wtf/Deque.h&gt;
  65 #include &lt;wtf/Forward.h&gt;
  66 #include &lt;wtf/HashCountedSet.h&gt;
  67 #include &lt;wtf/HashSet.h&gt;
  68 #include &lt;wtf/Logger.h&gt;
  69 #include &lt;wtf/ObjectIdentifier.h&gt;
  70 #include &lt;wtf/UniqueRef.h&gt;
  71 #include &lt;wtf/WeakHashSet.h&gt;
  72 #include &lt;wtf/WeakPtr.h&gt;
  73 #include &lt;wtf/text/AtomStringHash.h&gt;
  74 
  75 #if PLATFORM(IOS_FAMILY)
  76 #include &quot;EventTrackingRegions.h&quot;
  77 #endif
  78 
  79 #if ENABLE(IOS_TOUCH_EVENTS)
  80 #include &lt;wtf/ThreadingPrimitives.h&gt;
  81 #endif
  82 
  83 namespace JSC {
<span class="line-modified">  84 class ExecState;</span>
  85 class InputCursor;
  86 }
  87 
  88 namespace WebCore {
  89 
<span class="line-removed">  90 class ApplicationStateChangeListener;</span>
  91 class AXObjectCache;
  92 class Attr;
  93 class CDATASection;
  94 class CSSCustomPropertyValue;
  95 class CSSFontSelector;
  96 class CSSStyleDeclaration;
  97 class CSSStyleSheet;
  98 class CachedCSSStyleSheet;
  99 class CachedFrameBase;
 100 class CachedResourceLoader;
 101 class CachedScript;
 102 class CanvasRenderingContext2D;
 103 class CharacterData;
 104 class Comment;
 105 class ConstantPropertyMap;
 106 class ContentChangeObserver;
 107 class DOMImplementation;
 108 class DOMSelection;
 109 class DOMTimerHoldingTank;
 110 class DOMWindow;
 111 class DOMWrapperWorld;
 112 class Database;
 113 class DatabaseThread;
 114 class DocumentFragment;
 115 class DocumentLoader;
 116 class DocumentMarkerController;
 117 class DocumentParser;
 118 class DocumentSharedObjectPool;
 119 class DocumentTimeline;
 120 class DocumentType;
 121 class EditingBehavior;


 122 class ExtensionStyleSheets;
 123 class FloatQuad;
 124 class FloatRect;
 125 class FontFaceSet;
 126 class FormController;
 127 class Frame;
 128 class FrameView;
 129 class FullscreenManager;

 130 class HTMLAllCollection;
 131 class HTMLBodyElement;
 132 class HTMLCanvasElement;
 133 class HTMLCollection;
 134 class HTMLDocument;
 135 class HTMLElement;
 136 class HTMLFrameOwnerElement;
 137 class HTMLHeadElement;
 138 class HTMLIFrameElement;
 139 class HTMLImageElement;
 140 class HTMLMapElement;
 141 class HTMLMediaElement;
<span class="line-modified"> 142 class HTMLPictureElement;</span>
 143 class HTMLScriptElement;

 144 class HitTestLocation;
 145 class HitTestRequest;
 146 class HitTestResult;


 147 class ImageBitmapRenderingContext;
 148 class IntPoint;
 149 class JSNode;
 150 class LayoutPoint;
 151 class LayoutRect;
 152 class LiveNodeList;
 153 class Locale;
 154 class Location;
 155 class MediaCanStartListener;
 156 class MediaPlaybackTarget;
 157 class MediaPlaybackTargetClient;
 158 class MediaQueryList;
 159 class MediaQueryMatcher;

 160 class MouseEventWithHitTestResults;
 161 class NodeFilter;
 162 class NodeIterator;
 163 class Page;
 164 class PaintWorkletGlobalScope;
 165 class PlatformMouseEvent;
 166 class ProcessingInstruction;
 167 class QualifiedName;
 168 class Quirks;
 169 class Range;
 170 class RenderTreeBuilder;
 171 class RenderView;
 172 class RequestAnimationFrameCallback;
 173 class SVGDocumentExtensions;
 174 class SVGSVGElement;
 175 class SVGUseElement;
 176 class SWClientConnection;
 177 class ScriptElementData;
 178 class ScriptModuleLoader;
 179 class ScriptRunner;
 180 class ScriptableDocumentParser;
 181 class ScriptedAnimationController;
 182 class SecurityOrigin;
 183 class SegmentedString;
 184 class SelectorQuery;
 185 class SelectorQueryCache;
 186 class SerializedScriptValue;
 187 class Settings;
 188 class StringCallback;
<span class="line-removed"> 189 class StyleResolver;</span>
 190 class StyleSheet;
 191 class StyleSheetContents;
 192 class StyleSheetList;
 193 class Text;

 194 class TextResourceDecoder;
 195 class TreeWalker;
 196 class UndoManager;
 197 class VisibilityChangeClient;
 198 class VisitedLinkState;
 199 class WebAnimation;
 200 class WebGL2RenderingContext;
 201 class WebGLRenderingContext;
<span class="line-modified"> 202 class GPUCanvasContext;</span>
 203 class WindowProxy;
 204 class Worklet;
 205 class XPathEvaluator;
 206 class XPathExpression;
 207 class XPathNSResolver;
 208 class XPathResult;
 209 
 210 template&lt;typename&gt; class ExceptionOr;
 211 
 212 enum CollectionType;
<span class="line-removed"> 213 enum class ShouldOpenExternalURLsPolicy : uint8_t;</span>
 214 
 215 enum class RouteSharingPolicy : uint8_t;

 216 
 217 using PlatformDisplayID = uint32_t;
 218 
 219 #if ENABLE(XSLT)
 220 class TransformSource;
 221 #endif
 222 
<span class="line-modified"> 223 #if ENABLE(TOUCH_EVENTS) || ENABLE(IOS_TOUCH_EVENTS)</span>
<span class="line-removed"> 224 class Touch;</span>
<span class="line-removed"> 225 class TouchList;</span>
<span class="line-removed"> 226 #endif</span>
<span class="line-removed"> 227 </span>
<span class="line-removed"> 228 #if ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-removed"> 229 #if PLATFORM(IOS_FAMILY)</span>
 230 class DeviceMotionClient;
 231 class DeviceMotionController;
 232 class DeviceOrientationClient;
 233 class DeviceOrientationController;
 234 #endif


 235 class DeviceOrientationAndMotionAccessController;
 236 #endif
 237 
 238 #if ENABLE(TEXT_AUTOSIZING)
 239 class TextAutoSizing;
 240 #endif
 241 
 242 #if ENABLE(MEDIA_SESSION)
 243 class MediaSession;
 244 #endif
 245 
 246 #if ENABLE(ATTACHMENT_ELEMENT)
 247 class HTMLAttachmentElement;
 248 #endif
 249 
 250 #if ENABLE(INTERSECTION_OBSERVER)
 251 class IntersectionObserver;
 252 #endif
 253 
 254 #if ENABLE(RESIZE_OBSERVER)
 255 class ResizeObserver;
 256 #endif
 257 
 258 namespace Style {

 259 class Scope;
 260 };
 261 
 262 const uint64_t HTMLMediaElementInvalidID = 0;
 263 
 264 enum PageshowEventPersistence { PageshowEventNotPersisted, PageshowEventPersisted };
 265 
 266 enum NodeListInvalidationType {
 267     DoNotInvalidateOnAttributeChanges,
 268     InvalidateOnClassAttrChange,
 269     InvalidateOnIdNameAttrChange,
 270     InvalidateOnNameAttrChange,
 271     InvalidateOnForTypeAttrChange,
 272     InvalidateForFormControls,
 273     InvalidateOnHRefAttrChange,
 274     InvalidateOnAnyAttrChange,
 275 };
 276 const int numNodeListInvalidationTypes = InvalidateOnAnyAttrChange + 1;
 277 
 278 enum class EventHandlerRemoval { One, All };
</pre>
<hr />
<pre>
 333 class DocumentParserYieldToken {
 334     WTF_MAKE_FAST_ALLOCATED;
 335 public:
 336     WEBCORE_EXPORT DocumentParserYieldToken(Document&amp;);
 337     WEBCORE_EXPORT ~DocumentParserYieldToken();
 338 
 339 private:
 340     WeakPtr&lt;Document&gt; m_document;
 341 };
 342 
 343 class Document
 344     : public ContainerNode
 345     , public TreeScope
 346     , public ScriptExecutionContext
 347     , public FontSelectorClient
 348     , public FrameDestructionObserver
 349     , public Supplementable&lt;Document&gt;
 350     , public Logger::Observer {
 351     WTF_MAKE_ISO_ALLOCATED(Document);
 352 public:
<span class="line-modified"> 353     static Ref&lt;Document&gt; create(PAL::SessionID, const URL&amp;);</span>
 354     static Ref&lt;Document&gt; createNonRenderedPlaceholder(Frame&amp;, const URL&amp;);
 355     static Ref&lt;Document&gt; create(Document&amp;);
 356 
 357     virtual ~Document();
 358 
 359     // Nodes belonging to this document increase referencingNodeCount -
 360     // these are enough to keep the document from being destroyed, but
 361     // not enough to keep it from removing its children. This allows a
 362     // node that outlives its document to still have a valid document
 363     // pointer without introducing reference cycles.
 364     void incrementReferencingNodeCount()
 365     {
 366         ASSERT(!m_deletionHasBegun);
 367         ++m_referencingNodeCount;
 368     }
 369 
 370     void decrementReferencingNodeCount()
 371     {
 372         ASSERT(!m_deletionHasBegun || !m_referencingNodeCount);
 373         --m_referencingNodeCount;
 374         if (!m_referencingNodeCount &amp;&amp; !refCount()) {
<span class="line-modified"> 375 #if !ASSERT_DISABLED</span>
 376             m_deletionHasBegun = true;
 377 #endif
 378             m_refCountAndParentBit = s_refCountIncrement; // Avoid double destruction through use of Ref&lt;T&gt;/RefPtr&lt;T&gt;. (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)
 379             delete this;
 380         }
 381     }
 382 
 383     unsigned referencingNodeCount() const { return m_referencingNodeCount; }
 384 
 385     void removedLastRef();
 386 
 387     DocumentIdentifier identifier() const { return m_identifier; }
 388 
 389     using DocumentsMap = HashMap&lt;DocumentIdentifier, Document*&gt;;
 390     WEBCORE_EXPORT static DocumentsMap::ValuesIteratorRange allDocuments();
 391     WEBCORE_EXPORT static DocumentsMap&amp; allDocumentsMap();
 392 
 393     WEBCORE_EXPORT ElementIdentifier identifierForElement(Element&amp;);
 394     WEBCORE_EXPORT Element* searchForElementByIdentifier(const ElementIdentifier&amp;);
 395     void identifiedElementWasRemovedFromDocument(Element&amp;);
 396 
 397     MediaQueryMatcher&amp; mediaQueryMatcher();
 398 
 399     using ContainerNode::ref;
 400     using ContainerNode::deref;
 401     using TreeScope::rootNode;
 402 
 403     bool canContainRangeEndPoint() const final { return true; }
 404 
 405     Element* elementForAccessKey(const String&amp; key);
 406     void invalidateAccessKeyCache();
 407 
 408     ExceptionOr&lt;SelectorQuery&amp;&gt; selectorQueryForString(const String&amp;);
 409     void clearSelectorQueryCache();
 410 
 411     void setViewportArguments(const ViewportArguments&amp; viewportArguments) { m_viewportArguments = viewportArguments; }
 412     WEBCORE_EXPORT ViewportArguments viewportArguments() const;
 413 
 414     OptionSet&lt;DisabledAdaptations&gt; disabledAdaptations() const { return m_disabledAdaptations; }
<span class="line-modified"> 415 #ifndef NDEBUG</span>
 416     bool didDispatchViewportPropertiesChanged() const { return m_didDispatchViewportPropertiesChanged; }
 417 #endif
 418 
 419     void setReferrerPolicy(ReferrerPolicy);
<span class="line-modified"> 420     ReferrerPolicy referrerPolicy() const { return m_referrerPolicy.valueOr(ReferrerPolicy::NoReferrerWhenDowngrade); }</span>
 421 
 422     WEBCORE_EXPORT DocumentType* doctype() const;
 423 
 424     WEBCORE_EXPORT DOMImplementation&amp; implementation();
 425 
 426     Element* documentElement() const { return m_documentElement.get(); }
 427     static ptrdiff_t documentElementMemoryOffset() { return OBJECT_OFFSETOF(Document, m_documentElement); }
 428 
 429     WEBCORE_EXPORT Element* activeElement();
 430     WEBCORE_EXPORT bool hasFocus() const;
 431 
 432     bool hasManifest() const;
 433 
 434     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Element&gt;&gt; createElementForBindings(const AtomString&amp; tagName);
 435     WEBCORE_EXPORT Ref&lt;DocumentFragment&gt; createDocumentFragment();
 436     WEBCORE_EXPORT Ref&lt;Text&gt; createTextNode(const String&amp; data);
 437     WEBCORE_EXPORT Ref&lt;Comment&gt; createComment(const String&amp; data);
 438     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;CDATASection&gt;&gt; createCDATASection(const String&amp; data);
 439     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;ProcessingInstruction&gt;&gt; createProcessingInstruction(const String&amp; target, const String&amp; data);
 440     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; createAttribute(const String&amp; name);
</pre>
<hr />
<pre>
 464 
 465     WEBCORE_EXPORT void setCharset(const String&amp;); // Used by ObjC / GOBject bindings only.
 466 
 467     void setContent(const String&amp;);
 468 
 469     String suggestedMIMEType() const;
 470 
 471     void overrideMIMEType(const String&amp;);
 472     WEBCORE_EXPORT String contentType() const;
 473 
 474     String contentLanguage() const { return m_contentLanguage; }
 475     void setContentLanguage(const String&amp;);
 476 
 477     String xmlEncoding() const { return m_xmlEncoding; }
 478     String xmlVersion() const { return m_xmlVersion; }
 479     enum class StandaloneStatus : uint8_t { Unspecified, Standalone, NotStandalone };
 480     bool xmlStandalone() const { return m_xmlStandalone == StandaloneStatus::Standalone; }
 481     StandaloneStatus xmlStandaloneStatus() const { return m_xmlStandalone; }
 482     bool hasXMLDeclaration() const { return m_hasXMLDeclaration; }
 483 



 484     void setXMLEncoding(const String&amp; encoding) { m_xmlEncoding = encoding; } // read-only property, only to be set from XMLDocumentParser
 485     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setXMLVersion(const String&amp;);
 486     WEBCORE_EXPORT void setXMLStandalone(bool);
 487     void setHasXMLDeclaration(bool hasXMLDeclaration) { m_hasXMLDeclaration = hasXMLDeclaration; }
 488 
 489     String documentURI() const { return m_documentURI; }
 490     WEBCORE_EXPORT void setDocumentURI(const String&amp;);
 491 
 492     WEBCORE_EXPORT VisibilityState visibilityState() const;
 493     void visibilityStateChanged();
 494     WEBCORE_EXPORT bool hidden() const;
 495 
 496     void setTimerThrottlingEnabled(bool);
 497     bool isTimerThrottlingEnabled() const { return m_isTimerThrottlingEnabled; }
 498 
 499     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Node&gt;&gt; adoptNode(Node&amp; source);
 500 
 501     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; images();
 502     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; embeds();
 503     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; plugins(); // an alias for embeds() required for the JS DOM bindings.
</pre>
<hr />
<pre>
 515     // Other methods (not part of DOM)
 516     bool isSynthesized() const { return m_isSynthesized; }
 517     bool isHTMLDocument() const { return m_documentClasses &amp; HTMLDocumentClass; }
 518     bool isXHTMLDocument() const { return m_documentClasses &amp; XHTMLDocumentClass; }
 519     bool isXMLDocument() const { return m_documentClasses &amp; XMLDocumentClass; }
 520     bool isImageDocument() const { return m_documentClasses &amp; ImageDocumentClass; }
 521     bool isSVGDocument() const { return m_documentClasses &amp; SVGDocumentClass; }
 522     bool isPluginDocument() const { return m_documentClasses &amp; PluginDocumentClass; }
 523     bool isMediaDocument() const { return m_documentClasses &amp; MediaDocumentClass; }
 524     bool isTextDocument() const { return m_documentClasses &amp; TextDocumentClass; }
 525     bool hasSVGRootNode() const;
 526     virtual bool isFrameSet() const { return false; }
 527 
 528     static ptrdiff_t documentClassesMemoryOffset() { return OBJECT_OFFSETOF(Document, m_documentClasses); }
 529     static uint32_t isHTMLDocumentClassFlag() { return HTMLDocumentClass; }
 530 
 531     bool isSrcdocDocument() const { return m_isSrcdocDocument; }
 532 
 533     bool sawElementsInKnownNamespaces() const { return m_sawElementsInKnownNamespaces; }
 534 
<span class="line-modified"> 535     StyleResolver&amp; userAgentShadowTreeStyleResolver();</span>
 536 
 537     CSSFontSelector&amp; fontSelector() { return m_fontSelector; }

 538 
 539     WEBCORE_EXPORT bool haveStylesheetsLoaded() const;
 540     bool isIgnoringPendingStylesheets() const { return m_ignorePendingStylesheets; }
 541 
 542     WEBCORE_EXPORT StyleSheetList&amp; styleSheets();
 543 
 544     Style::Scope&amp; styleScope() { return *m_styleScope; }
 545     const Style::Scope&amp; styleScope() const { return *m_styleScope; }
 546     ExtensionStyleSheets&amp; extensionStyleSheets() { return *m_extensionStyleSheets; }
 547     const ExtensionStyleSheets&amp; extensionStyleSheets() const { return *m_extensionStyleSheets; }
 548 
 549     bool gotoAnchorNeededAfterStylesheetsLoad() { return m_gotoAnchorNeededAfterStylesheetsLoad; }
 550     void setGotoAnchorNeededAfterStylesheetsLoad(bool b) { m_gotoAnchorNeededAfterStylesheetsLoad = b; }
 551 
<span class="line-modified"> 552     void evaluateMediaQueryList();</span>

 553 
 554     FormController&amp; formController();
 555     Vector&lt;String&gt; formElementsState() const;
 556     void setStateForNewFormElements(const Vector&lt;String&gt;&amp;);
 557 
 558     WEBCORE_EXPORT FrameView* view() const; // Can be null.
 559     WEBCORE_EXPORT Page* page() const; // Can be null.
 560     const Settings&amp; settings() const { return m_settings.get(); }
 561     Settings&amp; mutableSettings() { return m_settings.get(); }
 562     EditingBehavior editingBehavior() const;
 563 
 564     const Quirks&amp; quirks() const { return m_quirks; }
 565 
 566     float deviceScaleFactor() const;
 567 
 568     WEBCORE_EXPORT bool useSystemAppearance() const;
 569     WEBCORE_EXPORT bool useElevatedUserInterfaceLevel() const;
 570     WEBCORE_EXPORT bool useDarkAppearance(const RenderStyle*) const;
 571 
 572     OptionSet&lt;StyleColor::Options&gt; styleColorOptions(const RenderStyle*) const;
</pre>
<hr />
<pre>
 617     // Override ScriptExecutionContext methods to do additional work
 618     WEBCORE_EXPORT bool shouldBypassMainWorldContentSecurityPolicy() const final;
 619     void suspendActiveDOMObjects(ReasonForSuspension) final;
 620     void resumeActiveDOMObjects(ReasonForSuspension) final;
 621     void stopActiveDOMObjects() final;
 622 
 623     void suspendDeviceMotionAndOrientationUpdates();
 624     void resumeDeviceMotionAndOrientationUpdates();
 625 
 626     RenderView* renderView() const { return m_renderView.get(); }
 627 
 628     bool renderTreeBeingDestroyed() const { return m_renderTreeBeingDestroyed; }
 629     bool hasLivingRenderTree() const { return renderView() &amp;&amp; !renderTreeBeingDestroyed(); }
 630 
 631     bool updateLayoutIfDimensionsOutOfDate(Element&amp;, DimensionsCheck = AllDimensionsCheck);
 632 
 633     AXObjectCache* existingAXObjectCache() const;
 634     WEBCORE_EXPORT AXObjectCache* axObjectCache() const;
 635     void clearAXObjectCache();
 636 
<span class="line-modified"> 637     Optional&lt;PageIdentifier&gt; pageID() const;</span>
 638     // to get visually ordered hebrew and arabic pages right
 639     void setVisuallyOrdered();
 640     bool visuallyOrdered() const { return m_visuallyOrdered; }
 641 
 642     WEBCORE_EXPORT DocumentLoader* loader() const;
 643 
 644     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstDOMWindow, const String&amp; url, const AtomString&amp; name, const String&amp; features);
 645     WEBCORE_EXPORT ExceptionOr&lt;Document&amp;&gt; openForBindings(Document* responsibleDocument, const String&amp;, const String&amp;);
 646 
 647     // FIXME: We should rename this at some point and give back the name &#39;open&#39; to the HTML specified ones.
 648     WEBCORE_EXPORT ExceptionOr&lt;void&gt; open(Document* responsibleDocument = nullptr);
 649     void implicitOpen();
 650 
 651     WEBCORE_EXPORT ExceptionOr&lt;void&gt; closeForBindings();
 652 
 653     // FIXME: We should rename this at some point and give back the name &#39;close&#39; to the HTML specified one.
 654     WEBCORE_EXPORT void close();
 655     // In some situations (see the code), we ignore document.close().
 656     // explicitClose() bypass these checks and actually tries to close the
 657     // input stream.
</pre>
<hr />
<pre>
 663 
 664     ExceptionOr&lt;void&gt; write(Document* responsibleDocument, SegmentedString&amp;&amp;);
 665     WEBCORE_EXPORT ExceptionOr&lt;void&gt; write(Document* responsibleDocument, Vector&lt;String&gt;&amp;&amp;);
 666     WEBCORE_EXPORT ExceptionOr&lt;void&gt; writeln(Document* responsibleDocument, Vector&lt;String&gt;&amp;&amp;);
 667 
 668     bool wellFormed() const { return m_wellFormed; }
 669 
 670     const URL&amp; url() const final { return m_url; }
 671     void setURL(const URL&amp;);
 672     const URL&amp; urlForBindings() const { return m_url.isEmpty() ? WTF::blankURL() : m_url; }
 673 
 674     // To understand how these concepts relate to one another, please see the
 675     // comments surrounding their declaration.
 676     const URL&amp; baseURL() const { return m_baseURL; }
 677     void setBaseURLOverride(const URL&amp;);
 678     const URL&amp; baseURLOverride() const { return m_baseURLOverride; }
 679     const URL&amp; baseElementURL() const { return m_baseElementURL; }
 680     const String&amp; baseTarget() const { return m_baseTarget; }
 681     void processBaseElement();
 682 
<span class="line-modified"> 683     WEBCORE_EXPORT URL completeURL(const String&amp;) const final;</span>
<span class="line-modified"> 684     URL completeURL(const String&amp;, const URL&amp; baseURLOverride) const;</span>
<span class="line-removed"> 685     WEBCORE_EXPORT PAL::SessionID sessionID() const final;</span>
 686 
 687     String userAgent(const URL&amp;) const final;
 688 
 689     void disableEval(const String&amp; errorMessage) final;
 690     void disableWebAssembly(const String&amp; errorMessage) final;
 691 
 692 #if ENABLE(INDEXED_DATABASE)
 693     IDBClient::IDBConnectionProxy* idbConnectionProxy() final;
 694 #endif
 695     SocketProvider* socketProvider() final;
 696 
 697     bool canNavigate(Frame* targetFrame, const URL&amp; destinationURL = URL());
 698 
 699     bool usesStyleBasedEditability() const;
 700     void setHasElementUsingStyleBasedEditability();
 701 
 702     virtual Ref&lt;DocumentParser&gt; createParser();
 703     DocumentParser* parser() const { return m_parser.get(); }
 704     ScriptableDocumentParser* scriptableDocumentParser() const;
 705 
</pre>
<hr />
<pre>
 739     void setLinkColor(const Color&amp; c) { m_linkColor = c; }
 740     void setVisitedLinkColor(const Color&amp; c) { m_visitedLinkColor = c; }
 741     void setActiveLinkColor(const Color&amp; c) { m_activeLinkColor = c; }
 742     void resetLinkColor();
 743     void resetVisitedLinkColor();
 744     void resetActiveLinkColor();
 745     VisitedLinkState&amp; visitedLinkState() const { return *m_visitedLinkState; }
 746 
 747     MouseEventWithHitTestResults prepareMouseEvent(const HitTestRequest&amp;, const LayoutPoint&amp;, const PlatformMouseEvent&amp;);
 748 
 749     enum class FocusRemovalEventsMode { Dispatch, DoNotDispatch };
 750     WEBCORE_EXPORT bool setFocusedElement(Element*, FocusDirection = FocusDirectionNone,
 751         FocusRemovalEventsMode = FocusRemovalEventsMode::Dispatch);
 752     Element* focusedElement() const { return m_focusedElement.get(); }
 753     UserActionElementSet&amp; userActionElements()  { return m_userActionElements; }
 754     const UserActionElementSet&amp; userActionElements() const { return m_userActionElements; }
 755 
 756     void setFocusNavigationStartingNode(Node*);
 757     Element* focusNavigationStartingNode(FocusDirection) const;
 758 



 759     enum class NodeRemoval { Node, ChildrenOfNode };
 760     void adjustFocusedNodeOnNodeRemoval(Node&amp;, NodeRemoval = NodeRemoval::Node);
 761     void adjustFocusNavigationNodeOnNodeRemoval(Node&amp;, NodeRemoval = NodeRemoval::Node);
 762 
 763     void hoveredElementDidDetach(Element&amp;);
 764     void elementInActiveChainDidDetach(Element&amp;);
 765 
 766     enum class CaptureChange : uint8_t { Yes, No };
 767     void updateHoverActiveState(const HitTestRequest&amp;, Element*, CaptureChange = CaptureChange::No);
 768 
 769     // Updates for :target (CSS3 selector).
 770     void setCSSTarget(Element*);
 771     Element* cssTarget() const { return m_cssTarget; }
 772     static ptrdiff_t cssTargetMemoryOffset() { return OBJECT_OFFSETOF(Document, m_cssTarget); }
 773 
 774     WEBCORE_EXPORT void scheduleFullStyleRebuild();
 775     void scheduleStyleRecalc();
 776     void unscheduleStyleRecalc();
 777     bool hasPendingStyleRecalc() const;
 778     bool hasPendingFullStyleRebuild() const;
</pre>
<hr />
<pre>
 899 #endif
 900 
 901     // Returns the owning element in the parent document.
 902     // Returns nullptr if this is the top level document.
 903     HTMLFrameOwnerElement* ownerElement() const;
 904 
 905     // Used by DOM bindings; no direction known.
 906     const String&amp; title() const { return m_title.string; }
 907     WEBCORE_EXPORT void setTitle(const String&amp;);
 908 
 909     WEBCORE_EXPORT const AtomString&amp; dir() const;
 910     WEBCORE_EXPORT void setDir(const AtomString&amp;);
 911 
 912     void titleElementAdded(Element&amp; titleElement);
 913     void titleElementRemoved(Element&amp; titleElement);
 914     void titleElementTextChanged(Element&amp; titleElement);
 915 
 916     WEBCORE_EXPORT ExceptionOr&lt;String&gt; cookie();
 917     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setCookie(const String&amp;);
 918 
<span class="line-modified"> 919     WEBCORE_EXPORT String referrer() const;</span>
<span class="line-removed"> 920 </span>
<span class="line-removed"> 921     WEBCORE_EXPORT String origin() const final;</span>
 922 
 923     WEBCORE_EXPORT String domain() const;
 924     ExceptionOr&lt;void&gt; setDomain(const String&amp; newDomain);
 925 
 926     void overrideLastModified(const Optional&lt;WallTime&gt;&amp;);
 927     WEBCORE_EXPORT String lastModified() const;
 928 
 929     // The cookieURL is used to query the cookie database for this document&#39;s
 930     // cookies. For example, if the cookie URL is http://example.com, we&#39;ll
 931     // use the non-Secure cookies for example.com when computing
 932     // document.cookie.
 933     //
 934     // Q: How is the cookieURL different from the document&#39;s URL?
 935     // A: The two URLs are the same almost all the time.  However, if one
 936     //    document inherits the security context of another document, it
 937     //    inherits its cookieURL but not its URL.
 938     //
 939     const URL&amp; cookieURL() const { return m_cookieURL; }
 940     void setCookieURL(const URL&amp;);
 941 
</pre>
<hr />
<pre>
1020 
1021     bool shouldDeferAsynchronousScriptsUntilParsingFinishes() const;
1022 
1023 #if ENABLE(XSLT)
1024     void scheduleToApplyXSLTransforms();
1025     void applyPendingXSLTransformsNowIfScheduled();
1026     RefPtr&lt;Document&gt; transformSourceDocument() { return m_transformSourceDocument; }
1027     void setTransformSourceDocument(Document* document) { m_transformSourceDocument = document; }
1028 
1029     void setTransformSource(std::unique_ptr&lt;TransformSource&gt;);
1030     TransformSource* transformSource() const { return m_transformSource.get(); }
1031 #endif
1032 
1033     void incDOMTreeVersion() { m_domTreeVersion = ++s_globalTreeVersion; }
1034     uint64_t domTreeVersion() const { return m_domTreeVersion; }
1035 
1036     WEBCORE_EXPORT String originIdentifierForPasteboard() const;
1037 
1038     // XPathEvaluator methods
1039     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;XPathExpression&gt;&gt; createExpression(const String&amp; expression, RefPtr&lt;XPathNSResolver&gt;&amp;&amp;);
<span class="line-modified">1040     WEBCORE_EXPORT Ref&lt;XPathNSResolver&gt; createNSResolver(Node* nodeResolver);</span>
<span class="line-modified">1041     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; evaluate(const String&amp; expression, Node* contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp;, unsigned short type, XPathResult*);</span>
1042 
1043     bool hasNodesWithNonFinalStyle() const { return m_hasNodesWithNonFinalStyle; }
1044     void setHasNodesWithNonFinalStyle() { m_hasNodesWithNonFinalStyle = true; }
1045     bool hasNodesWithMissingStyle() const { return m_hasNodesWithMissingStyle; }
1046     void setHasNodesWithMissingStyle() { m_hasNodesWithMissingStyle = true; }
1047 
1048     // Extension for manipulating canvas drawing contexts for use in CSS
1049     Optional&lt;RenderingContext&gt; getCSSCanvasContext(const String&amp; type, const String&amp; name, int width, int height);
1050     HTMLCanvasElement* getCSSCanvasElement(const String&amp; name);
1051     String nameForCSSCanvasElement(const HTMLCanvasElement&amp;) const;
1052 
1053     bool isDNSPrefetchEnabled() const { return m_isDNSPrefetchEnabled; }
1054     void parseDNSPrefetchControlHeader(const String&amp;);
1055 
1056     WEBCORE_EXPORT void postTask(Task&amp;&amp;) final; // Executes the task on context&#39;s thread asynchronously.
1057 



1058     ScriptedAnimationController* scriptedAnimationController() { return m_scriptedAnimationController.get(); }
1059     void suspendScriptedAnimationControllerCallbacks();
1060     void resumeScriptedAnimationControllerCallbacks();
1061 
<span class="line-modified">1062     void updateAnimationsAndSendEvents(DOMHighResTimeStamp timestamp);</span>
<span class="line-modified">1063     void serviceRequestAnimationFrameCallbacks(DOMHighResTimeStamp timestamp);</span>
1064 
1065     void windowScreenDidChange(PlatformDisplayID);
1066 
1067     void finishedParsing();
1068 
<span class="line-modified">1069     enum PageCacheState { NotInPageCache, AboutToEnterPageCache, InPageCache };</span>
1070 
<span class="line-modified">1071     PageCacheState pageCacheState() const { return m_pageCacheState; }</span>
<span class="line-modified">1072     void setPageCacheState(PageCacheState);</span>
1073 
1074     void registerForDocumentSuspensionCallbacks(Element&amp;);
1075     void unregisterForDocumentSuspensionCallbacks(Element&amp;);
1076 
1077     void documentWillBecomeInactive();
1078     void suspend(ReasonForSuspension);
1079     void resume(ReasonForSuspension);
1080 
<span class="line-modified">1081     void registerForMediaVolumeCallbacks(Element&amp;);</span>
<span class="line-modified">1082     void unregisterForMediaVolumeCallbacks(Element&amp;);</span>
<span class="line-removed">1083     void mediaVolumeDidChange();</span>
1084 
1085     bool audioPlaybackRequiresUserGesture() const;
1086     bool videoPlaybackRequiresUserGesture() const;

1087 
1088 #if ENABLE(MEDIA_SESSION)
1089     MediaSession&amp; defaultMediaSession();
1090 #endif
1091 
<span class="line-removed">1092     void registerForPrivateBrowsingStateChangedCallbacks(Element&amp;);</span>
<span class="line-removed">1093     void unregisterForPrivateBrowsingStateChangedCallbacks(Element&amp;);</span>
<span class="line-removed">1094     void storageBlockingStateDidChange();</span>
1095     void privateBrowsingStateDidChange(PAL::SessionID);
1096 


1097 #if ENABLE(VIDEO_TRACK)
<span class="line-modified">1098     void registerForCaptionPreferencesChangedCallbacks(Element&amp;);</span>
<span class="line-modified">1099     void unregisterForCaptionPreferencesChangedCallbacks(Element&amp;);</span>
1100     void captionPreferencesChanged();
1101 #endif
1102 
<span class="line-removed">1103 #if ENABLE(MEDIA_CONTROLS_SCRIPT)</span>
<span class="line-removed">1104     void registerForPageScaleFactorChangedCallbacks(HTMLMediaElement&amp;);</span>
<span class="line-removed">1105     void unregisterForPageScaleFactorChangedCallbacks(HTMLMediaElement&amp;);</span>
<span class="line-removed">1106     void pageScaleFactorChangedAndStable();</span>
<span class="line-removed">1107     void registerForUserInterfaceLayoutDirectionChangedCallbacks(HTMLMediaElement&amp;);</span>
<span class="line-removed">1108     void unregisterForUserInterfaceLayoutDirectionChangedCallbacks(HTMLMediaElement&amp;);</span>
<span class="line-removed">1109     void userInterfaceLayoutDirectionChanged();</span>
<span class="line-removed">1110 #endif</span>
<span class="line-removed">1111 </span>
1112     void registerForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp;);
1113     void unregisterForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp;);
1114 
1115 #if ENABLE(VIDEO)
<span class="line-removed">1116     void registerForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp;);</span>
<span class="line-removed">1117     void unregisterForAllowsMediaDocumentInlinePlaybackChangedCallbacks(HTMLMediaElement&amp;);</span>
<span class="line-removed">1118     void allowsMediaDocumentInlinePlaybackChanged();</span>
<span class="line-removed">1119 </span>
1120     void stopAllMediaPlayback();
1121     void suspendAllMediaPlayback();
1122     void resumeAllMediaPlayback();
1123     void suspendAllMediaBuffering();
1124     void resumeAllMediaBuffering();
1125 #endif
1126 
1127     WEBCORE_EXPORT void setShouldCreateRenderers(bool);
1128     bool shouldCreateRenderers();
1129 
1130     void setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp;);
1131     TextResourceDecoder* decoder() const { return m_decoder.get(); }
1132 
1133     WEBCORE_EXPORT String displayStringModifiedByEncoding(const String&amp;) const;
1134 
1135     void invalidateRenderingDependentRegions();
1136 
1137     void removeAllEventListeners() final;
1138 
1139     WEBCORE_EXPORT const SVGDocumentExtensions* svgExtensions();
1140     WEBCORE_EXPORT SVGDocumentExtensions&amp; accessSVGExtensions();
1141 
1142     void addSVGUseElement(SVGUseElement&amp;);
1143     void removeSVGUseElement(SVGUseElement&amp;);
1144     HashSet&lt;SVGUseElement*&gt; const svgUseElements() const { return m_svgUseElements; }
1145 
1146     void initSecurityContext();
<span class="line-modified">1147     void initContentSecurityPolicy(ContentSecurityPolicy* previousPolicy);</span>
1148 
1149     void updateURLForPushOrReplaceState(const URL&amp;);
1150     void statePopped(Ref&lt;SerializedScriptValue&gt;&amp;&amp;);
1151 
1152     bool processingLoadEvent() const { return m_processingLoadEvent; }
1153     bool loadEventFinished() const { return m_loadEventFinished; }
1154 
1155     bool isContextThread() const final;
1156     bool isSecureContext() const final;
1157     bool isJSExecutionForbidden() const final { return false; }
1158 
<span class="line-modified">1159     void enqueueWindowEvent(Ref&lt;Event&gt;&amp;&amp;);</span>
<span class="line-modified">1160     void enqueueDocumentEvent(Ref&lt;Event&gt;&amp;&amp;);</span>
1161     void enqueueOverflowEvent(Ref&lt;Event&gt;&amp;&amp;);
1162     void dispatchPageshowEvent(PageshowEventPersistence);
1163     WEBCORE_EXPORT void enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp;);
1164     void enqueueHashchangeEvent(const String&amp; oldURL, const String&amp; newURL);
1165     void dispatchPopstateEvent(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; stateObject);
<span class="line-removed">1166     DocumentEventQueue&amp; eventQueue() const final { return m_eventQueue; }</span>
1167 
1168     WEBCORE_EXPORT void addMediaCanStartListener(MediaCanStartListener&amp;);
1169     WEBCORE_EXPORT void removeMediaCanStartListener(MediaCanStartListener&amp;);
1170     MediaCanStartListener* takeAnyMediaCanStartListener();
1171 
1172 #if ENABLE(FULLSCREEN_API)
1173     FullscreenManager&amp; fullscreenManager() { return m_fullscreenManager; }
1174     const FullscreenManager&amp; fullscreenManager() const { return m_fullscreenManager; }
1175 #endif
1176 
1177 #if ENABLE(POINTER_LOCK)
1178     WEBCORE_EXPORT void exitPointerLock();
1179 #endif
1180 
1181     // Used to allow element that loads data without going through a FrameLoader to delay the &#39;load&#39; event.
1182     void incrementLoadEventDelayCount() { ++m_loadEventDelayCount; }
1183     void decrementLoadEventDelayCount();
1184     bool isDelayingLoadEvent() const { return m_loadEventDelayCount; }
1185     void checkCompleted();
1186 
1187 #if ENABLE(IOS_TOUCH_EVENTS)
1188 #include &lt;WebKitAdditions/DocumentIOS.h&gt;
1189 #endif
1190 
<span class="line-modified">1191 #if ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-removed">1192 #if PLATFORM(IOS_FAMILY)</span>
1193     DeviceMotionController&amp; deviceMotionController() const;
1194     DeviceOrientationController&amp; deviceOrientationController() const;
1195     WEBCORE_EXPORT void simulateDeviceOrientationChange(double alpha, double beta, double gamma);
1196 #endif
1197 

1198     DeviceOrientationAndMotionAccessController&amp; deviceOrientationAndMotionAccessController();
<span class="line-modified">1199 #endif // ENABLE(DEVICE_ORIENTATION)</span>
1200 
1201     const DocumentTiming&amp; timing() const { return m_documentTiming; }
1202 
1203     WEBCORE_EXPORT double monotonicTimestamp() const;
1204 
1205     int requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp;);
1206     void cancelAnimationFrame(int id);
1207 




1208     EventTarget* errorEventTarget() final;
1209     void logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;) final;
1210 
1211     void initDNSPrefetch();
1212 
1213     void didAddWheelEventHandler(Node&amp;);
1214     void didRemoveWheelEventHandler(Node&amp;, EventHandlerRemoval = EventHandlerRemoval::One);
1215 
1216     MonotonicTime lastHandledUserGestureTimestamp() const { return m_lastHandledUserGestureTimestamp; }
1217     bool hasHadUserInteraction() const { return static_cast&lt;bool&gt;(m_lastHandledUserGestureTimestamp); }
1218     void updateLastHandledUserGestureTimestamp(MonotonicTime);
1219     bool processingUserGestureForMedia() const;
1220     void userActivatedMediaFinishedPlaying() { m_userActivatedMediaFinishedPlayingTimestamp = MonotonicTime::now(); }
1221 
1222     void setUserDidInteractWithPage(bool userDidInteractWithPage) { ASSERT(&amp;topDocument() == this); m_userDidInteractWithPage = userDidInteractWithPage; }
1223     bool userDidInteractWithPage() const { ASSERT(&amp;topDocument() == this); return m_userDidInteractWithPage; }
1224 
1225     // Used for testing. Count handlers in the main document, and one per frame which contains handlers.
1226     WEBCORE_EXPORT unsigned wheelEventHandlerCount() const;
1227     WEBCORE_EXPORT unsigned touchEventHandlerCount() const;
</pre>
<hr />
<pre>
1309     const Document* templateDocument() const;
1310     Document&amp; ensureTemplateDocument();
1311     void setTemplateDocumentHost(Document* templateDocumentHost) { m_templateDocumentHost = makeWeakPtr(templateDocumentHost); }
1312     Document* templateDocumentHost() { return m_templateDocumentHost.get(); }
1313 
1314     void didAssociateFormControl(Element&amp;);
1315     bool hasDisabledFieldsetElement() const { return m_disabledFieldsetElementsCount; }
1316     void addDisabledFieldsetElement() { m_disabledFieldsetElementsCount++; }
1317     void removeDisabledFieldsetElement() { ASSERT(m_disabledFieldsetElementsCount); m_disabledFieldsetElementsCount--; }
1318 
1319     void getParserLocation(String&amp; url, unsigned&amp; line, unsigned&amp; column) const;
1320 
1321     WEBCORE_EXPORT void addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp;) final;
1322 
1323     // The following addConsoleMessage function is deprecated.
1324     // Callers should try to create the ConsoleMessage themselves.
1325     WEBCORE_EXPORT void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier = 0) final;
1326 
1327     // The following addMessage function is deprecated.
1328     // Callers should try to create the ConsoleMessage themselves.
<span class="line-modified">1329     void addMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, JSC::ExecState* = nullptr, unsigned long requestIdentifier = 0) final;</span>
1330 
1331     SecurityOrigin&amp; securityOrigin() const { return *SecurityContext::securityOrigin(); }
1332     SecurityOrigin&amp; topOrigin() const final { return topDocument().securityOrigin(); }
1333 



1334     Ref&lt;FontFaceSet&gt; fonts();
1335 
1336     void ensurePlugInsInjectedScript(DOMWrapperWorld&amp;);
1337 
1338     void setVisualUpdatesAllowedByClient(bool);
1339 
1340 #if ENABLE(WEB_CRYPTO)
1341     bool wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey) final;
1342     bool unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key) final;
1343 #endif
1344 
1345     void setHasStyleWithViewportUnits() { m_hasStyleWithViewportUnits = true; }
1346     bool hasStyleWithViewportUnits() const { return m_hasStyleWithViewportUnits; }
1347     void updateViewportUnitsOnResize();
1348 








1349     WEBCORE_EXPORT void addAudioProducer(MediaProducer&amp;);
1350     WEBCORE_EXPORT void removeAudioProducer(MediaProducer&amp;);
1351     MediaProducer::MediaStateFlags mediaState() const { return m_mediaState; }
1352     void noteUserInteractionWithMediaElement();
1353     bool isCapturing() const { return MediaProducer::isCapturing(m_mediaState); }
1354     WEBCORE_EXPORT void updateIsPlayingMedia(uint64_t = HTMLMediaElementInvalidID);
1355     void pageMutedStateDidChange();
1356 
1357 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1358     void addPlaybackTargetPickerClient(MediaPlaybackTargetClient&amp;);
1359     void removePlaybackTargetPickerClient(MediaPlaybackTargetClient&amp;);
1360     void showPlaybackTargetPicker(MediaPlaybackTargetClient&amp;, bool, RouteSharingPolicy, const String&amp;);
1361     void playbackTargetPickerClientStateDidChange(MediaPlaybackTargetClient&amp;, MediaProducer::MediaStateFlags);
1362 
1363     void setPlaybackTarget(uint64_t, Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;);
1364     void playbackTargetAvailabilityDidChange(uint64_t, bool);
1365     void setShouldPlayToPlaybackTarget(uint64_t, bool);

1366 #endif
1367 
1368     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToPropagate() const;
1369     bool shouldEnforceContentDispositionAttachmentSandbox() const;
1370     void applyContentDispositionAttachmentSandbox();
1371 
<span class="line-modified">1372     void addViewportDependentPicture(HTMLPictureElement&amp;);</span>
<span class="line-modified">1373     void removeViewportDependentPicture(HTMLPictureElement&amp;);</span>
<span class="line-removed">1374 </span>
<span class="line-removed">1375     void addAppearanceDependentPicture(HTMLPictureElement&amp;);</span>
<span class="line-removed">1376     void removeAppearanceDependentPicture(HTMLPictureElement&amp;);</span>
1377 
1378     void scheduleTimedRenderingUpdate();
1379 
1380 #if ENABLE(INTERSECTION_OBSERVER)
1381     void addIntersectionObserver(IntersectionObserver&amp;);
1382     void removeIntersectionObserver(IntersectionObserver&amp;);
1383     unsigned numberOfIntersectionObservers() const { return m_intersectionObservers.size(); }
1384     void updateIntersectionObservations();
1385     void scheduleInitialIntersectionObservationUpdate();
1386 #endif
1387 
1388 #if ENABLE(RESIZE_OBSERVER)
1389     void addResizeObserver(ResizeObserver&amp;);
1390     void removeResizeObserver(ResizeObserver&amp;);
1391     bool hasResizeObservers();
1392     // Return the minDepth of the active observations.
1393     size_t gatherResizeObservations(size_t deeperThan);
1394     void deliverResizeObservations();
1395     bool hasSkippedResizeObservations() const;
1396     void setHasSkippedResizeObservations(bool);
1397     void updateResizeObservations(Page&amp;);
1398 #endif
1399 
1400 #if ENABLE(MEDIA_STREAM)
1401     void setHasCaptureMediaStreamTrack() { m_hasHadCaptureMediaStreamTrack = true; }
1402     bool hasHadCaptureMediaStreamTrack() const { return m_hasHadCaptureMediaStreamTrack; }
1403     void setDeviceIDHashSalt(const String&amp;);
1404     String deviceIDHashSalt() const { return m_idHashSalt; }
1405     void stopMediaCapture();
<span class="line-removed">1406     void registerForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp;);</span>
<span class="line-removed">1407     void unregisterForMediaStreamStateChangeCallbacks(HTMLMediaElement&amp;);</span>
1408     void mediaStreamCaptureStateChanged();
1409 #endif
1410 
1411 // FIXME: Find a better place for this functionality.
1412 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
1413     // These functions provide a two-level setting:
1414     //    - A user-settable wantsTelephoneNumberParsing (at the Page / WebView level)
1415     //    - A read-only telephoneNumberParsingAllowed which is set by the
1416     //      document if it has the appropriate meta tag.
1417     //    - isTelephoneNumberParsingEnabled() == isTelephoneNumberParsingAllowed() &amp;&amp; page()-&gt;settings()-&gt;isTelephoneNumberParsingEnabled()
1418     WEBCORE_EXPORT bool isTelephoneNumberParsingAllowed() const;
1419     WEBCORE_EXPORT bool isTelephoneNumberParsingEnabled() const;
1420 #endif
1421 
1422     using ContainerNode::setAttributeEventListener;
1423     void setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; value, DOMWrapperWorld&amp; isolatedWorld);
1424 
1425     DOMSelection* getSelection();
1426 
1427     void didInsertInDocumentShadowRoot(ShadowRoot&amp;);
</pre>
<hr />
<pre>
1448     WEBCORE_EXPORT void setVlinkColor(const String&amp;);
1449 
1450     // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-clear, this method does nothing.
1451     void clear() { }
1452     // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-captureevents, this method does nothing.
1453     void captureEvents() { }
1454     // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-releaseevents, this method does nothing.
1455     void releaseEvents() { }
1456 
1457 #if ENABLE(TEXT_AUTOSIZING)
1458     TextAutoSizing&amp; textAutoSizing();
1459 #endif
1460 
1461     // For debugging rdar://problem/49877867.
1462     void setMayBeDetachedFromFrame(bool mayBeDetachedFromFrame) { m_mayBeDetachedFromFrame = mayBeDetachedFromFrame; }
1463 
1464     Logger&amp; logger();
1465 
1466     WEBCORE_EXPORT void setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp;); // For testing.
1467 


1468     WEBCORE_EXPORT DocumentTimeline&amp; timeline();
1469     DocumentTimeline* existingTimeline() const { return m_timeline.get(); }
1470     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; getAnimations();
1471 
1472 #if ENABLE(ATTACHMENT_ELEMENT)
1473     void registerAttachmentIdentifier(const String&amp;);
1474     void didInsertAttachmentElement(HTMLAttachmentElement&amp;);
1475     void didRemoveAttachmentElement(HTMLAttachmentElement&amp;);
1476     WEBCORE_EXPORT RefPtr&lt;HTMLAttachmentElement&gt; attachmentForIdentifier(const String&amp;) const;
1477     const HashMap&lt;String, Ref&lt;HTMLAttachmentElement&gt;&gt;&amp; attachmentElementsByIdentifier() const { return m_attachmentIdentifierToElementMap; }
1478 #endif
1479 
1480 #if ENABLE(SERVICE_WORKER)
1481     void setServiceWorkerConnection(SWClientConnection*);
1482 #endif
1483 
<span class="line-modified">1484     void addApplicationStateChangeListener(ApplicationStateChangeListener&amp;);</span>
<span class="line-modified">1485     void removeApplicationStateChangeListener(ApplicationStateChangeListener&amp;);</span>
<span class="line-modified">1486     void forEachApplicationStateChangeListener(const Function&lt;void(ApplicationStateChangeListener&amp;)&gt;&amp;);</span>
1487 
1488 #if ENABLE(IOS_TOUCH_EVENTS)
1489     bool handlingTouchEvent() const { return m_handlingTouchEvent; }
1490 #endif
1491 
1492 #if ENABLE(RESOURCE_LOAD_STATISTICS)
<span class="line-modified">1493     bool hasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp;);</span>
<span class="line-modified">1494     void setHasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp;);</span>
1495     WEBCORE_EXPORT void wasLoadedWithDataTransferFromPrevalentResource();
1496     void downgradeReferrerToRegistrableDomain();
1497 #endif
1498 
1499     String signedPublicKeyAndChallengeString(unsigned keySizeIndex, const String&amp; challengeString, const URL&amp;);
1500 
1501     void registerArticleElement(Element&amp;);
1502     void unregisterArticleElement(Element&amp;);
1503     void updateMainArticleElementAfterLayout();
1504     bool hasMainArticleElement() const { return !!m_mainArticleElement; }
1505 
1506     const CSSRegisteredCustomPropertySet&amp; getCSSRegisteredCustomPropertySet() const { return m_CSSRegisteredPropertySet; }
1507     bool registerCSSProperty(CSSRegisteredCustomProperty&amp;&amp;);
1508 
1509 #if ENABLE(CSS_PAINTING_API)
1510     Worklet&amp; ensurePaintWorklet();
1511     PaintWorkletGlobalScope* paintWorkletGlobalScopeForName(const String&amp; name);
1512     void setPaintWorkletGlobalScopeForName(const String&amp; name, Ref&lt;PaintWorkletGlobalScope&gt;&amp;&amp;);
1513 #endif
1514 
1515     WEBCORE_EXPORT bool hasEvaluatedUserAgentScripts() const;
1516     WEBCORE_EXPORT bool isRunningUserScripts() const;
1517     WEBCORE_EXPORT void setAsRunningUserScripts();
1518     void setHasEvaluatedUserAgentScripts();
1519 #if ENABLE(APPLE_PAY)
1520     WEBCORE_EXPORT bool isApplePayActive() const;
1521     WEBCORE_EXPORT void setApplePayIsActive();
1522 #endif
1523 
1524     void frameWasDisconnectedFromOwner();
1525 
1526     WEBCORE_EXPORT bool hitTest(const HitTestRequest&amp;, HitTestResult&amp;);
1527     bool hitTest(const HitTestRequest&amp;, const HitTestLocation&amp;, HitTestResult&amp;);
<span class="line-modified">1528 #if !ASSERT_DISABLED</span>
1529     bool inHitTesting() const { return m_inHitTesting; }
1530 #endif
1531 

















1532 protected:
1533     enum ConstructionFlags { Synthesized = 1, NonRenderedPlaceholder = 1 &lt;&lt; 1 };
<span class="line-modified">1534     Document(PAL::SessionID, Frame*, const URL&amp;, unsigned = DefaultDocumentClass, unsigned constructionFlags = 0);</span>
1535 
1536     void clearXMLVersion() { m_xmlVersion = String(); }
1537 
1538     virtual Ref&lt;Document&gt; cloneDocumentWithoutChildren() const;
1539 
1540 private:
1541     friend class DocumentParserYieldToken;
1542     friend class Node;
1543     friend class ThrowOnDynamicMarkupInsertionCountIncrementer;
1544     friend class IgnoreOpensDuringUnloadCountIncrementer;
1545     friend class IgnoreDestructiveWriteCountIncrementer;
1546 
<span class="line-removed">1547     bool shouldInheritContentSecurityPolicy() const;</span>
<span class="line-removed">1548 </span>
1549     void updateTitleElement(Element&amp; changingTitleElement);
1550     void willDetachPage() final;
1551     void frameDestroyed() final;
1552 
1553     void commonTeardown();
1554 
1555     RenderObject* renderer() const = delete;
1556     void setRenderer(RenderObject*) = delete;
1557 
1558     void createRenderTree();
1559     void detachParser();
1560 
1561     // FontSelectorClient
1562     void fontsNeedUpdate(FontSelector&amp;) final;
1563 
1564     bool isDocument() const final { return true; }
1565 
1566     void childrenChanged(const ChildChange&amp;) final;
1567 
1568     String nodeName() const final;
</pre>
<hr />
<pre>
1601     void setVisualUpdatesAllowed(ReadyState);
1602     void setVisualUpdatesAllowed(bool);
1603     void visualUpdatesSuppressionTimerFired();
1604 
1605     void addListenerType(ListenerType listenerType) { m_listenerTypes |= listenerType; }
1606 
1607     void didAssociateFormControlsTimerFired();
1608 
1609     void wheelEventHandlersChanged();
1610 
1611     HttpEquivPolicy httpEquivPolicy() const;
1612     AXObjectCache* existingAXObjectCacheSlow() const;
1613 
1614     // DOM Cookies caching.
1615     const String&amp; cachedDOMCookies() const { return m_cachedDOMCookies; }
1616     void setCachedDOMCookies(const String&amp;);
1617     bool isDOMCookieCacheValid() const { return m_cookieCacheExpiryTimer.isActive(); }
1618     void invalidateDOMCookieCache();
1619     void didLoadResourceSynchronously() final;
1620 
<span class="line-removed">1621     void checkViewportDependentPictures();</span>
<span class="line-removed">1622     void checkAppearanceDependentPictures();</span>
<span class="line-removed">1623 </span>
1624     bool canNavigateInternal(Frame&amp; targetFrame);
1625     bool isNavigationBlockedByThirdPartyIFrameRedirectBlocking(Frame&amp; targetFrame, const URL&amp; destinationURL);
1626 
1627 #if ENABLE(INTERSECTION_OBSERVER)
1628     void notifyIntersectionObserversTimerFired();
1629 #endif
1630 
1631 #if USE(QUICK_LOOK)
1632     bool shouldEnforceQuickLookSandbox() const;
1633     void applyQuickLookSandbox();
1634 #endif
1635 
1636     bool shouldEnforceHTTP09Sandbox() const;
1637 
1638     void platformSuspendOrStopActiveDOMObjects();
1639 
1640     bool isBodyPotentiallyScrollable(HTMLBodyElement&amp;);
1641 


1642     const Ref&lt;Settings&gt; m_settings;
1643 
1644     UniqueRef&lt;Quirks&gt; m_quirks;
1645 
<span class="line-modified">1646     std::unique_ptr&lt;StyleResolver&gt; m_userAgentShadowTreeStyleResolver;</span>
1647 
1648     RefPtr&lt;DOMWindow&gt; m_domWindow;
1649     WeakPtr&lt;Document&gt; m_contextDocument;
1650 
1651     Ref&lt;CachedResourceLoader&gt; m_cachedResourceLoader;
1652     RefPtr&lt;DocumentParser&gt; m_parser;
1653 
1654     unsigned m_parserYieldTokenCount { 0 };
1655 
1656     // Document URLs.
1657     URL m_url; // Document.URL: The URL from which this document was retrieved.
1658     URL m_baseURL; // Node.baseURI: The URL to use when resolving relative URLs.
1659     URL m_baseURLOverride; // An alternative base URL that takes precedence over m_baseURL (but not m_baseElementURL).
1660     URL m_baseElementURL; // The URL set by the &lt;base&gt; element.
1661     URL m_cookieURL; // The URL to use for cookie access.
1662     URL m_firstPartyForCookies; // The policy URL for third-party cookie blocking.
1663     URL m_siteForCookies; // The policy URL for Same-Site cookies.
1664 
1665     // Document.documentURI:
1666     // Although URL-like, Document.documentURI can actually be set to any
</pre>
<hr />
<pre>
1743 
1744     RefPtr&lt;TextResourceDecoder&gt; m_decoder;
1745 
1746     HashSet&lt;LiveNodeList*&gt; m_listsInvalidatedAtDocument;
1747     HashSet&lt;HTMLCollection*&gt; m_collectionsInvalidatedAtDocument;
1748     unsigned m_nodeListAndCollectionCounts[numNodeListInvalidationTypes];
1749 
1750     RefPtr&lt;XPathEvaluator&gt; m_xpathEvaluator;
1751 
1752     std::unique_ptr&lt;SVGDocumentExtensions&gt; m_svgExtensions;
1753     HashSet&lt;SVGUseElement*&gt; m_svgUseElements;
1754 
1755 #if ENABLE(DARK_MODE_CSS)
1756     OptionSet&lt;ColorScheme&gt; m_colorScheme;
1757     bool m_allowsColorSchemeTransformations { true };
1758 #endif
1759 
1760     HashMap&lt;String, RefPtr&lt;HTMLCanvasElement&gt;&gt; m_cssCanvasElements;
1761 
1762     HashSet&lt;Element*&gt; m_documentSuspensionCallbackElements;
<span class="line-modified">1763     HashSet&lt;Element*&gt; m_mediaVolumeCallbackElements;</span>
<span class="line-modified">1764     HashSet&lt;Element*&gt; m_privateBrowsingStateChangedElements;</span>



1765 #if ENABLE(VIDEO_TRACK)
<span class="line-modified">1766     HashSet&lt;Element*&gt; m_captionPreferencesChangedElements;</span>
1767 #endif
1768 
1769     Element* m_mainArticleElement { nullptr };
1770     HashSet&lt;Element*&gt; m_articleElements;
1771 
<span class="line-removed">1772 #if ENABLE(MEDIA_CONTROLS_SCRIPT)</span>
<span class="line-removed">1773     HashSet&lt;HTMLMediaElement*&gt; m_pageScaleFactorChangedElements;</span>
<span class="line-removed">1774     HashSet&lt;HTMLMediaElement*&gt; m_userInterfaceLayoutDirectionChangedElements;</span>
<span class="line-removed">1775 #endif</span>
<span class="line-removed">1776 </span>
1777     HashSet&lt;VisibilityChangeClient*&gt; m_visibilityStateCallbackClients;
<span class="line-removed">1778 #if ENABLE(VIDEO)</span>
<span class="line-removed">1779     HashSet&lt;HTMLMediaElement*&gt; m_allowsMediaDocumentInlinePlaybackElements;</span>
<span class="line-removed">1780 #endif</span>
1781 
1782     std::unique_ptr&lt;HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt;&gt; m_accessKeyCache;
1783 
1784     std::unique_ptr&lt;ConstantPropertyMap&gt; m_constantPropertyMap;
1785 
1786     std::unique_ptr&lt;SelectorQueryCache&gt; m_selectorQueryCache;
1787 
1788     DocumentClassFlags m_documentClasses;
1789 
1790     RenderPtr&lt;RenderView&gt; m_renderView;
<span class="line-removed">1791     mutable DocumentEventQueue m_eventQueue;</span>
1792 
1793     HashSet&lt;MediaCanStartListener*&gt; m_mediaCanStartListeners;
1794 
1795 #if ENABLE(FULLSCREEN_API)
1796     UniqueRef&lt;FullscreenManager&gt; m_fullscreenManager;
1797 #endif
1798 
<span class="line-modified">1799     HashSet&lt;HTMLPictureElement*&gt; m_viewportDependentPictures;</span>
<span class="line-removed">1800     HashSet&lt;HTMLPictureElement*&gt; m_appearanceDependentPictures;</span>
1801 
1802 #if ENABLE(INTERSECTION_OBSERVER)
1803     Vector&lt;WeakPtr&lt;IntersectionObserver&gt;&gt; m_intersectionObservers;
1804     Vector&lt;WeakPtr&lt;IntersectionObserver&gt;&gt; m_intersectionObserversWithPendingNotifications;
1805     Timer m_intersectionObserversNotifyTimer;
1806     Timer m_intersectionObserversInitialUpdateTimer;
1807 #endif
1808 
1809 #if ENABLE(RESIZE_OBSERVER)
1810     Vector&lt;WeakPtr&lt;ResizeObserver&gt;&gt; m_resizeObservers;
1811 #endif
1812 
1813     Timer m_loadEventDelayTimer;
1814 
1815     ViewportArguments m_viewportArguments;
1816     OptionSet&lt;DisabledAdaptations&gt; m_disabledAdaptations;
1817 
1818     DocumentTiming m_documentTiming;
1819 
1820     RefPtr&lt;MediaQueryMatcher&gt; m_mediaQueryMatcher;
1821 
1822 #if ENABLE(TOUCH_EVENTS)
1823     std::unique_ptr&lt;EventTargetSet&gt; m_touchEventTargets;
1824 #endif
1825 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)
1826     bool m_mayHaveElementsWithNonAutoTouchAction { false };
1827 #endif
1828     std::unique_ptr&lt;EventTargetSet&gt; m_wheelEventTargets;
1829 
1830     MonotonicTime m_lastHandledUserGestureTimestamp;
1831     MonotonicTime m_userActivatedMediaFinishedPlayingTimestamp;
1832 
1833     void clearScriptedAnimationController();
1834     RefPtr&lt;ScriptedAnimationController&gt; m_scriptedAnimationController;
1835 
<span class="line-modified">1836     void notifyMediaCaptureOfVisibilityChanged();</span>
<span class="line-removed">1837 </span>
<span class="line-removed">1838     void didLogMessage(const WTFLogChannel&amp;, WTFLogLevel, Vector&lt;JSONLogValue&gt;&amp;&amp;) final;</span>
1839 
<span class="line-modified">1840 #if ENABLE(DEVICE_ORIENTATION)</span>
<span class="line-removed">1841 #if PLATFORM(IOS_FAMILY)</span>
1842     std::unique_ptr&lt;DeviceMotionClient&gt; m_deviceMotionClient;
1843     std::unique_ptr&lt;DeviceMotionController&gt; m_deviceMotionController;
1844     std::unique_ptr&lt;DeviceOrientationClient&gt; m_deviceOrientationClient;
1845     std::unique_ptr&lt;DeviceOrientationController&gt; m_deviceOrientationController;
1846 #endif


1847     std::unique_ptr&lt;DeviceOrientationAndMotionAccessController&gt; m_deviceOrientationAndMotionAccessController;
1848 #endif
1849 
1850     GenericTaskQueue&lt;Timer&gt; m_logMessageTaskQueue;
1851 
1852     Timer m_pendingTasksTimer;
1853     Vector&lt;Task&gt; m_pendingTasks;
1854 
1855 #if ENABLE(TEXT_AUTOSIZING)
1856     std::unique_ptr&lt;TextAutoSizing&gt; m_textAutoSizing;
1857 #endif
1858 


1859     Timer m_visualUpdatesSuppressionTimer;
1860 
1861     void clearSharedObjectPool();
1862     Timer m_sharedObjectPoolClearTimer;
1863 
1864     std::unique_ptr&lt;DocumentSharedObjectPool&gt; m_sharedObjectPool;
1865 
1866     typedef HashMap&lt;AtomString, std::unique_ptr&lt;Locale&gt;&gt; LocaleIdentifierToLocaleMap;
1867     LocaleIdentifierToLocaleMap m_localeCache;
1868 
1869     RefPtr&lt;Document&gt; m_templateDocument;
1870     WeakPtr&lt;Document&gt; m_templateDocumentHost; // Manually managed weakref (backpointer from m_templateDocument).
1871 
1872     Ref&lt;CSSFontSelector&gt; m_fontSelector;
1873 
1874     WeakHashSet&lt;MediaProducer&gt; m_audioProducers;
1875 
1876     HashSet&lt;ShadowRoot*&gt; m_inDocumentShadowRoots;
1877 
1878 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
</pre>
<hr />
<pre>
1911     int m_loadEventDelayCount { 0 };
1912     unsigned m_lastStyleUpdateSizeForTesting { 0 };
1913 
1914     // https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#throw-on-dynamic-markup-insertion-counter
1915     unsigned m_throwOnDynamicMarkupInsertionCount { 0 };
1916 
1917     // https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#ignore-opens-during-unload-counter
1918     unsigned m_ignoreOpensDuringUnloadCount { 0 };
1919 
1920     // https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#ignore-destructive-writes-counter
1921     unsigned m_ignoreDestructiveWriteCount { 0 };
1922 
1923     unsigned m_activeParserCount { 0 };
1924     unsigned m_styleRecalcCount { 0 };
1925 
1926     unsigned m_writeRecursionDepth { 0 };
1927 
1928     InheritedBool m_designMode { inherit };
1929     MediaProducer::MediaStateFlags m_mediaState { MediaProducer::IsNotPlaying };
1930     bool m_userHasInteractedWithMediaElement { false };
<span class="line-modified">1931     PageCacheState m_pageCacheState { NotInPageCache };</span>
1932     Optional&lt;ReferrerPolicy&gt; m_referrerPolicy;
1933     ReadyState m_readyState { Complete };
1934 
1935     MutationObserverOptions m_mutationObserverTypes { 0 };
1936 

1937     bool m_writeRecursionIsTooDeep { false };
1938     bool m_wellFormed { false };
1939     bool m_createRenderers { true };
1940 
1941     bool m_hasNodesWithNonFinalStyle { false };
1942     bool m_hasNodesWithMissingStyle { false };
1943     // But sometimes you need to ignore pending stylesheet count to
1944     // force an immediate layout when requested by JS.
1945     bool m_ignorePendingStylesheets { false };
1946 
1947     bool m_hasElementUsingStyleBasedEditability { false };
1948     bool m_focusNavigationStartingNodeIsRemoved { false };
1949 
1950     bool m_printing { false };
1951     bool m_paginatedForScreen { false };
1952 
1953     DocumentCompatibilityMode m_compatibilityMode { DocumentCompatibilityMode::NoQuirksMode };
1954     bool m_compatibilityModeLocked { false }; // This is cheaper than making setCompatibilityMode virtual.
1955 
1956     // FIXME: Merge these 2 variables into an enum. Also, FrameLoader::m_didCallImplicitClose
1957     // is almost a duplication of this data, so that should probably get merged in too.
1958     // FIXME: Document::m_processingLoadEvent and DocumentLoader::m_wasOnloadDispatched are roughly the same
1959     // and should be merged.
1960     bool m_processingLoadEvent { false };
1961     bool m_loadEventFinished { false };
1962 
1963     bool m_visuallyOrdered { false };
1964     bool m_bParsing { false }; // FIXME: rename
1965 
1966     bool m_needsFullStyleRebuild { false };
1967     bool m_inStyleRecalc { false };
<span class="line-removed">1968     bool m_closeAfterStyleRecalc { false };</span>
1969     bool m_inRenderTreeUpdate { false };
1970     bool m_isResolvingTreeStyle { false };
1971 
1972     bool m_gotoAnchorNeededAfterStylesheetsLoad { false };
1973     bool m_isDNSPrefetchEnabled { false };
1974     bool m_haveExplicitlyDisabledDNSPrefetch { false };
1975 
1976     bool m_isSynthesized { false };
1977     bool m_isNonRenderedPlaceholder { false };
1978 
1979     bool m_sawElementsInKnownNamespaces { false };
1980     bool m_isSrcdocDocument { false };
1981 
1982     bool m_hasInjectedPlugInsScript { false };
1983     bool m_renderTreeBeingDestroyed { false };
1984     bool m_hasPreparedForDestruction { false };
1985 
1986     bool m_hasStyleWithViewportUnits { false };



1987     bool m_isTimerThrottlingEnabled { false };
1988     bool m_isSuspended { false };
1989 
1990     bool m_scheduledTasksAreSuspended { false };
1991     bool m_visualUpdatesAllowed { true };
1992 
1993     bool m_areDeviceMotionAndOrientationUpdatesSuspended { false };
1994     bool m_userDidInteractWithPage { false };
<span class="line-modified">1995 #if !ASSERT_DISABLED</span>
1996     bool m_inHitTesting { false };
1997 #endif
1998 
1999 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
2000     bool m_isTelephoneNumberParsingAllowed { true };
2001 #endif
2002 



2003 #if ENABLE(MEDIA_STREAM)
2004     HashSet&lt;HTMLMediaElement*&gt; m_mediaStreamStateChangeElements;
2005     String m_idHashSalt;
2006     bool m_hasHadCaptureMediaStreamTrack { false };
2007 #endif
2008 
<span class="line-modified">2009 #ifndef NDEBUG</span>
2010     bool m_didDispatchViewportPropertiesChanged { false };
2011 #endif
2012 
2013     OrientationNotifier m_orientationNotifier;
<span class="line-removed">2014     mutable PAL::SessionID m_sessionID;</span>
2015     mutable RefPtr&lt;Logger&gt; m_logger;
2016     RefPtr&lt;StringCallback&gt; m_consoleMessageListener;
2017 
2018     static bool hasEverCreatedAnAXObjectCache;
2019 
2020     RefPtr&lt;DocumentTimeline&gt; m_timeline;


2021     DocumentIdentifier m_identifier;
2022 



2023 #if ENABLE(SERVICE_WORKER)
2024     RefPtr&lt;SWClientConnection&gt; m_serviceWorkerConnection;
2025 #endif
2026 
<span class="line-removed">2027     HashSet&lt;ApplicationStateChangeListener*&gt; m_applicationStateChangeListeners;</span>
<span class="line-removed">2028 </span>
2029 #if ENABLE(RESOURCE_LOAD_STATISTICS)
2030     RegistrableDomain m_registrableDomainRequestedPageSpecificStorageAccessWithUserInteraction { };
2031     String m_referrerOverride;
2032 #endif
2033 
2034     CSSRegisteredCustomPropertySet m_CSSRegisteredPropertySet;
2035 
2036 #if ENABLE(CSS_PAINTING_API)
2037     RefPtr&lt;Worklet&gt; m_paintWorklet;
2038     HashMap&lt;String, Ref&lt;PaintWorkletGlobalScope&gt;&gt; m_paintWorkletGlobalScopes;
2039 #endif
<span class="line-modified">2040 </span>
2041     bool m_hasEvaluatedUserAgentScripts { false };
2042     bool m_isRunningUserScripts { false };
2043     bool m_mayBeDetachedFromFrame { true };



2044 #if ENABLE(APPLE_PAY)
2045     bool m_hasStartedApplePaySession { false };
2046 #endif
2047 
2048     Ref&lt;UndoManager&gt; m_undoManager;
2049 #if PLATFORM(IOS_FAMILY)
2050     std::unique_ptr&lt;ContentChangeObserver&gt; m_contentChangeObserver;
2051     std::unique_ptr&lt;DOMTimerHoldingTank&gt; m_domTimerHoldingTank;
2052 #endif
2053 






2054     HashMap&lt;Element*, ElementIdentifier&gt; m_identifiedElementsMap;
2055 };
2056 
2057 Element* eventTargetElementForDocument(Document*);
2058 
2059 inline TextEncoding Document::textEncoding() const
2060 {
2061     if (auto* decoder = this-&gt;decoder())
2062         return decoder-&gt;encoding();
2063     return TextEncoding();
2064 }
2065 
2066 inline const Document* Document::templateDocument() const
2067 {
2068     return m_templateDocumentHost ? this : m_templateDocument.get();
2069 }
2070 
2071 inline AXObjectCache* Document::existingAXObjectCache() const
2072 {
2073     if (!hasEverCreatedAnAXObjectCache)
2074         return nullptr;
2075     return existingAXObjectCacheSlow();
2076 }
2077 
<span class="line-modified">2078 inline Ref&lt;Document&gt; Document::create(PAL::SessionID sessionID, const URL&amp; url)</span>
2079 {
<span class="line-modified">2080     return adoptRef(*new Document(sessionID, nullptr, url));</span>
2081 }
2082 
2083 inline void Document::invalidateAccessKeyCache()
2084 {
2085     if (UNLIKELY(m_accessKeyCache))
2086         invalidateAccessKeyCacheSlowCase();
2087 }
2088 
2089 // These functions are here because they require the Document class definition and we want to inline them.
2090 
2091 inline ScriptExecutionContext* Node::scriptExecutionContext() const
2092 {
2093     return &amp;document().contextDocument();
2094 }
2095 
<span class="line-removed">2096 inline ActiveDOMObject::ActiveDOMObject(Document&amp; document)</span>
<span class="line-removed">2097     : ActiveDOMObject(static_cast&lt;ScriptExecutionContext*&gt;(&amp;document.contextDocument()))</span>
<span class="line-removed">2098 {</span>
<span class="line-removed">2099 }</span>
<span class="line-removed">2100 </span>
2101 } // namespace WebCore
2102 
2103 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::Document)
2104     static bool isType(const WebCore::ScriptExecutionContext&amp; context) { return context.isDocument(); }
2105     static bool isType(const WebCore::Node&amp; node) { return node.isDocumentNode(); }
2106 SPECIALIZE_TYPE_TRAITS_END()
</pre>
</td>
<td>
<hr />
<pre>
  14  * version 2 of the License, or (at your option) any later version.
  15  *
  16  * This library is distributed in the hope that it will be useful,
  17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  19  * Library General Public License for more details.
  20  *
  21  * You should have received a copy of the GNU Library General Public License
  22  * along with this library; see the file COPYING.LIB.  If not, write to
  23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  24  * Boston, MA 02110-1301, USA.
  25  *
  26  */
  27 
  28 #pragma once
  29 
  30 #include &quot;CSSRegisteredCustomProperty.h&quot;
  31 #include &quot;Color.h&quot;
  32 #include &quot;ContainerNode.h&quot;
  33 #include &quot;DisabledAdaptations.h&quot;

  34 #include &quot;DocumentIdentifier.h&quot;
  35 #include &quot;DocumentTiming.h&quot;
  36 #include &quot;ElementIdentifier.h&quot;
  37 #include &quot;FocusDirection.h&quot;
  38 #include &quot;FontSelectorClient.h&quot;
  39 #include &quot;FrameDestructionObserver.h&quot;
<span class="line-added">  40 #include &quot;FrameLoaderTypes.h&quot;</span>
  41 #include &quot;GenericTaskQueue.h&quot;
  42 #include &quot;GraphicsTypes.h&quot;
  43 #include &quot;MediaProducer.h&quot;
  44 #include &quot;MutationObserver.h&quot;
  45 #include &quot;OrientationNotifier.h&quot;
  46 #include &quot;PageIdentifier.h&quot;
  47 #include &quot;PlatformEvent.h&quot;
  48 #include &quot;ReferrerPolicy.h&quot;
  49 #include &quot;Region.h&quot;
  50 #include &quot;RegistrableDomain.h&quot;
  51 #include &quot;RenderPtr.h&quot;
  52 #include &quot;ScriptExecutionContext.h&quot;
  53 #include &quot;SecurityPolicyViolationEvent.h&quot;
  54 #include &quot;StringWithDirection.h&quot;
  55 #include &quot;StyleColor.h&quot;
  56 #include &quot;Supplementable.h&quot;
  57 #include &quot;TextResourceDecoder.h&quot;
  58 #include &quot;Timer.h&quot;
  59 #include &quot;TreeScope.h&quot;
  60 #include &quot;UserActionElementSet.h&quot;
</pre>
<hr />
<pre>
  64 #include &lt;wtf/Deque.h&gt;
  65 #include &lt;wtf/Forward.h&gt;
  66 #include &lt;wtf/HashCountedSet.h&gt;
  67 #include &lt;wtf/HashSet.h&gt;
  68 #include &lt;wtf/Logger.h&gt;
  69 #include &lt;wtf/ObjectIdentifier.h&gt;
  70 #include &lt;wtf/UniqueRef.h&gt;
  71 #include &lt;wtf/WeakHashSet.h&gt;
  72 #include &lt;wtf/WeakPtr.h&gt;
  73 #include &lt;wtf/text/AtomStringHash.h&gt;
  74 
  75 #if PLATFORM(IOS_FAMILY)
  76 #include &quot;EventTrackingRegions.h&quot;
  77 #endif
  78 
  79 #if ENABLE(IOS_TOUCH_EVENTS)
  80 #include &lt;wtf/ThreadingPrimitives.h&gt;
  81 #endif
  82 
  83 namespace JSC {
<span class="line-modified">  84 class CallFrame;</span>
  85 class InputCursor;
  86 }
  87 
  88 namespace WebCore {
  89 

  90 class AXObjectCache;
  91 class Attr;
  92 class CDATASection;
  93 class CSSCustomPropertyValue;
  94 class CSSFontSelector;
  95 class CSSStyleDeclaration;
  96 class CSSStyleSheet;
  97 class CachedCSSStyleSheet;
  98 class CachedFrameBase;
  99 class CachedResourceLoader;
 100 class CachedScript;
 101 class CanvasRenderingContext2D;
 102 class CharacterData;
 103 class Comment;
 104 class ConstantPropertyMap;
 105 class ContentChangeObserver;
 106 class DOMImplementation;
 107 class DOMSelection;
 108 class DOMTimerHoldingTank;
 109 class DOMWindow;
 110 class DOMWrapperWorld;
 111 class Database;
 112 class DatabaseThread;
 113 class DocumentFragment;
 114 class DocumentLoader;
 115 class DocumentMarkerController;
 116 class DocumentParser;
 117 class DocumentSharedObjectPool;
 118 class DocumentTimeline;
 119 class DocumentType;
 120 class EditingBehavior;
<span class="line-added"> 121 class EventLoop;</span>
<span class="line-added"> 122 class EventLoopTaskGroup;</span>
 123 class ExtensionStyleSheets;
 124 class FloatQuad;
 125 class FloatRect;
 126 class FontFaceSet;
 127 class FormController;
 128 class Frame;
 129 class FrameView;
 130 class FullscreenManager;
<span class="line-added"> 131 class GPUCanvasContext;</span>
 132 class HTMLAllCollection;
 133 class HTMLBodyElement;
 134 class HTMLCanvasElement;
 135 class HTMLCollection;
 136 class HTMLDocument;
 137 class HTMLElement;
 138 class HTMLFrameOwnerElement;
 139 class HTMLHeadElement;
 140 class HTMLIFrameElement;
 141 class HTMLImageElement;
 142 class HTMLMapElement;
 143 class HTMLMediaElement;
<span class="line-modified"> 144 class HTMLVideoElement;</span>
 145 class HTMLScriptElement;
<span class="line-added"> 146 class HighlightMap;</span>
 147 class HitTestLocation;
 148 class HitTestRequest;
 149 class HitTestResult;
<span class="line-added"> 150 class IdleCallbackController;</span>
<span class="line-added"> 151 class IdleRequestCallback;</span>
 152 class ImageBitmapRenderingContext;
 153 class IntPoint;
 154 class JSNode;
 155 class LayoutPoint;
 156 class LayoutRect;
 157 class LiveNodeList;
 158 class Locale;
 159 class Location;
 160 class MediaCanStartListener;
 161 class MediaPlaybackTarget;
 162 class MediaPlaybackTargetClient;
 163 class MediaQueryList;
 164 class MediaQueryMatcher;
<span class="line-added"> 165 class MessagePortChannelProvider;</span>
 166 class MouseEventWithHitTestResults;
 167 class NodeFilter;
 168 class NodeIterator;
 169 class Page;
 170 class PaintWorkletGlobalScope;
 171 class PlatformMouseEvent;
 172 class ProcessingInstruction;
 173 class QualifiedName;
 174 class Quirks;
 175 class Range;
 176 class RenderTreeBuilder;
 177 class RenderView;
 178 class RequestAnimationFrameCallback;
 179 class SVGDocumentExtensions;
 180 class SVGSVGElement;
 181 class SVGUseElement;
 182 class SWClientConnection;
 183 class ScriptElementData;
 184 class ScriptModuleLoader;
 185 class ScriptRunner;
 186 class ScriptableDocumentParser;
 187 class ScriptedAnimationController;
 188 class SecurityOrigin;
 189 class SegmentedString;
 190 class SelectorQuery;
 191 class SelectorQueryCache;
 192 class SerializedScriptValue;
 193 class Settings;
 194 class StringCallback;

 195 class StyleSheet;
 196 class StyleSheetContents;
 197 class StyleSheetList;
 198 class Text;
<span class="line-added"> 199 class TextManipulationController;</span>
 200 class TextResourceDecoder;
 201 class TreeWalker;
 202 class UndoManager;
 203 class VisibilityChangeClient;
 204 class VisitedLinkState;
 205 class WebAnimation;
 206 class WebGL2RenderingContext;
 207 class WebGLRenderingContext;
<span class="line-modified"> 208 class WindowEventLoop;</span>
 209 class WindowProxy;
 210 class Worklet;
 211 class XPathEvaluator;
 212 class XPathExpression;
 213 class XPathNSResolver;
 214 class XPathResult;
 215 
 216 template&lt;typename&gt; class ExceptionOr;
 217 
 218 enum CollectionType;

 219 
 220 enum class RouteSharingPolicy : uint8_t;
<span class="line-added"> 221 enum class ShouldOpenExternalURLsPolicy : uint8_t;</span>
 222 
 223 using PlatformDisplayID = uint32_t;
 224 
 225 #if ENABLE(XSLT)
 226 class TransformSource;
 227 #endif
 228 
<span class="line-modified"> 229 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)</span>






 230 class DeviceMotionClient;
 231 class DeviceMotionController;
 232 class DeviceOrientationClient;
 233 class DeviceOrientationController;
 234 #endif
<span class="line-added"> 235 </span>
<span class="line-added"> 236 #if ENABLE(DEVICE_ORIENTATION)</span>
 237 class DeviceOrientationAndMotionAccessController;
 238 #endif
 239 
 240 #if ENABLE(TEXT_AUTOSIZING)
 241 class TextAutoSizing;
 242 #endif
 243 
 244 #if ENABLE(MEDIA_SESSION)
 245 class MediaSession;
 246 #endif
 247 
 248 #if ENABLE(ATTACHMENT_ELEMENT)
 249 class HTMLAttachmentElement;
 250 #endif
 251 
 252 #if ENABLE(INTERSECTION_OBSERVER)
 253 class IntersectionObserver;
 254 #endif
 255 
 256 #if ENABLE(RESIZE_OBSERVER)
 257 class ResizeObserver;
 258 #endif
 259 
 260 namespace Style {
<span class="line-added"> 261 class Resolver;</span>
 262 class Scope;
 263 };
 264 
 265 const uint64_t HTMLMediaElementInvalidID = 0;
 266 
 267 enum PageshowEventPersistence { PageshowEventNotPersisted, PageshowEventPersisted };
 268 
 269 enum NodeListInvalidationType {
 270     DoNotInvalidateOnAttributeChanges,
 271     InvalidateOnClassAttrChange,
 272     InvalidateOnIdNameAttrChange,
 273     InvalidateOnNameAttrChange,
 274     InvalidateOnForTypeAttrChange,
 275     InvalidateForFormControls,
 276     InvalidateOnHRefAttrChange,
 277     InvalidateOnAnyAttrChange,
 278 };
 279 const int numNodeListInvalidationTypes = InvalidateOnAnyAttrChange + 1;
 280 
 281 enum class EventHandlerRemoval { One, All };
</pre>
<hr />
<pre>
 336 class DocumentParserYieldToken {
 337     WTF_MAKE_FAST_ALLOCATED;
 338 public:
 339     WEBCORE_EXPORT DocumentParserYieldToken(Document&amp;);
 340     WEBCORE_EXPORT ~DocumentParserYieldToken();
 341 
 342 private:
 343     WeakPtr&lt;Document&gt; m_document;
 344 };
 345 
 346 class Document
 347     : public ContainerNode
 348     , public TreeScope
 349     , public ScriptExecutionContext
 350     , public FontSelectorClient
 351     , public FrameDestructionObserver
 352     , public Supplementable&lt;Document&gt;
 353     , public Logger::Observer {
 354     WTF_MAKE_ISO_ALLOCATED(Document);
 355 public:
<span class="line-modified"> 356     static Ref&lt;Document&gt; create(const URL&amp;);</span>
 357     static Ref&lt;Document&gt; createNonRenderedPlaceholder(Frame&amp;, const URL&amp;);
 358     static Ref&lt;Document&gt; create(Document&amp;);
 359 
 360     virtual ~Document();
 361 
 362     // Nodes belonging to this document increase referencingNodeCount -
 363     // these are enough to keep the document from being destroyed, but
 364     // not enough to keep it from removing its children. This allows a
 365     // node that outlives its document to still have a valid document
 366     // pointer without introducing reference cycles.
 367     void incrementReferencingNodeCount()
 368     {
 369         ASSERT(!m_deletionHasBegun);
 370         ++m_referencingNodeCount;
 371     }
 372 
 373     void decrementReferencingNodeCount()
 374     {
 375         ASSERT(!m_deletionHasBegun || !m_referencingNodeCount);
 376         --m_referencingNodeCount;
 377         if (!m_referencingNodeCount &amp;&amp; !refCount()) {
<span class="line-modified"> 378 #if ASSERT_ENABLED</span>
 379             m_deletionHasBegun = true;
 380 #endif
 381             m_refCountAndParentBit = s_refCountIncrement; // Avoid double destruction through use of Ref&lt;T&gt;/RefPtr&lt;T&gt;. (This is a security mitigation in case of programmer error. It will ASSERT in debug builds.)
 382             delete this;
 383         }
 384     }
 385 
 386     unsigned referencingNodeCount() const { return m_referencingNodeCount; }
 387 
 388     void removedLastRef();
 389 
 390     DocumentIdentifier identifier() const { return m_identifier; }
 391 
 392     using DocumentsMap = HashMap&lt;DocumentIdentifier, Document*&gt;;
 393     WEBCORE_EXPORT static DocumentsMap::ValuesIteratorRange allDocuments();
 394     WEBCORE_EXPORT static DocumentsMap&amp; allDocumentsMap();
 395 
 396     WEBCORE_EXPORT ElementIdentifier identifierForElement(Element&amp;);
 397     WEBCORE_EXPORT Element* searchForElementByIdentifier(const ElementIdentifier&amp;);
 398     void identifiedElementWasRemovedFromDocument(Element&amp;);
 399 
 400     MediaQueryMatcher&amp; mediaQueryMatcher();
 401 
 402     using ContainerNode::ref;
 403     using ContainerNode::deref;
 404     using TreeScope::rootNode;
 405 
 406     bool canContainRangeEndPoint() const final { return true; }
 407 
 408     Element* elementForAccessKey(const String&amp; key);
 409     void invalidateAccessKeyCache();
 410 
 411     ExceptionOr&lt;SelectorQuery&amp;&gt; selectorQueryForString(const String&amp;);
 412     void clearSelectorQueryCache();
 413 
 414     void setViewportArguments(const ViewportArguments&amp; viewportArguments) { m_viewportArguments = viewportArguments; }
 415     WEBCORE_EXPORT ViewportArguments viewportArguments() const;
 416 
 417     OptionSet&lt;DisabledAdaptations&gt; disabledAdaptations() const { return m_disabledAdaptations; }
<span class="line-modified"> 418 #if ASSERT_ENABLED</span>
 419     bool didDispatchViewportPropertiesChanged() const { return m_didDispatchViewportPropertiesChanged; }
 420 #endif
 421 
 422     void setReferrerPolicy(ReferrerPolicy);
<span class="line-modified"> 423     ReferrerPolicy referrerPolicy() const final { return m_referrerPolicy.valueOr(ReferrerPolicy::NoReferrerWhenDowngrade); }</span>
 424 
 425     WEBCORE_EXPORT DocumentType* doctype() const;
 426 
 427     WEBCORE_EXPORT DOMImplementation&amp; implementation();
 428 
 429     Element* documentElement() const { return m_documentElement.get(); }
 430     static ptrdiff_t documentElementMemoryOffset() { return OBJECT_OFFSETOF(Document, m_documentElement); }
 431 
 432     WEBCORE_EXPORT Element* activeElement();
 433     WEBCORE_EXPORT bool hasFocus() const;
 434 
 435     bool hasManifest() const;
 436 
 437     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Element&gt;&gt; createElementForBindings(const AtomString&amp; tagName);
 438     WEBCORE_EXPORT Ref&lt;DocumentFragment&gt; createDocumentFragment();
 439     WEBCORE_EXPORT Ref&lt;Text&gt; createTextNode(const String&amp; data);
 440     WEBCORE_EXPORT Ref&lt;Comment&gt; createComment(const String&amp; data);
 441     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;CDATASection&gt;&gt; createCDATASection(const String&amp; data);
 442     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;ProcessingInstruction&gt;&gt; createProcessingInstruction(const String&amp; target, const String&amp; data);
 443     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Attr&gt;&gt; createAttribute(const String&amp; name);
</pre>
<hr />
<pre>
 467 
 468     WEBCORE_EXPORT void setCharset(const String&amp;); // Used by ObjC / GOBject bindings only.
 469 
 470     void setContent(const String&amp;);
 471 
 472     String suggestedMIMEType() const;
 473 
 474     void overrideMIMEType(const String&amp;);
 475     WEBCORE_EXPORT String contentType() const;
 476 
 477     String contentLanguage() const { return m_contentLanguage; }
 478     void setContentLanguage(const String&amp;);
 479 
 480     String xmlEncoding() const { return m_xmlEncoding; }
 481     String xmlVersion() const { return m_xmlVersion; }
 482     enum class StandaloneStatus : uint8_t { Unspecified, Standalone, NotStandalone };
 483     bool xmlStandalone() const { return m_xmlStandalone == StandaloneStatus::Standalone; }
 484     StandaloneStatus xmlStandaloneStatus() const { return m_xmlStandalone; }
 485     bool hasXMLDeclaration() const { return m_hasXMLDeclaration; }
 486 
<span class="line-added"> 487     bool shouldPreventEnteringBackForwardCacheForTesting() const { return m_shouldPreventEnteringBackForwardCacheForTesting; }</span>
<span class="line-added"> 488     void preventEnteringBackForwardCacheForTesting() { m_shouldPreventEnteringBackForwardCacheForTesting = true; }</span>
<span class="line-added"> 489 </span>
 490     void setXMLEncoding(const String&amp; encoding) { m_xmlEncoding = encoding; } // read-only property, only to be set from XMLDocumentParser
 491     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setXMLVersion(const String&amp;);
 492     WEBCORE_EXPORT void setXMLStandalone(bool);
 493     void setHasXMLDeclaration(bool hasXMLDeclaration) { m_hasXMLDeclaration = hasXMLDeclaration; }
 494 
 495     String documentURI() const { return m_documentURI; }
 496     WEBCORE_EXPORT void setDocumentURI(const String&amp;);
 497 
 498     WEBCORE_EXPORT VisibilityState visibilityState() const;
 499     void visibilityStateChanged();
 500     WEBCORE_EXPORT bool hidden() const;
 501 
 502     void setTimerThrottlingEnabled(bool);
 503     bool isTimerThrottlingEnabled() const { return m_isTimerThrottlingEnabled; }
 504 
 505     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;Node&gt;&gt; adoptNode(Node&amp; source);
 506 
 507     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; images();
 508     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; embeds();
 509     WEBCORE_EXPORT Ref&lt;HTMLCollection&gt; plugins(); // an alias for embeds() required for the JS DOM bindings.
</pre>
<hr />
<pre>
 521     // Other methods (not part of DOM)
 522     bool isSynthesized() const { return m_isSynthesized; }
 523     bool isHTMLDocument() const { return m_documentClasses &amp; HTMLDocumentClass; }
 524     bool isXHTMLDocument() const { return m_documentClasses &amp; XHTMLDocumentClass; }
 525     bool isXMLDocument() const { return m_documentClasses &amp; XMLDocumentClass; }
 526     bool isImageDocument() const { return m_documentClasses &amp; ImageDocumentClass; }
 527     bool isSVGDocument() const { return m_documentClasses &amp; SVGDocumentClass; }
 528     bool isPluginDocument() const { return m_documentClasses &amp; PluginDocumentClass; }
 529     bool isMediaDocument() const { return m_documentClasses &amp; MediaDocumentClass; }
 530     bool isTextDocument() const { return m_documentClasses &amp; TextDocumentClass; }
 531     bool hasSVGRootNode() const;
 532     virtual bool isFrameSet() const { return false; }
 533 
 534     static ptrdiff_t documentClassesMemoryOffset() { return OBJECT_OFFSETOF(Document, m_documentClasses); }
 535     static uint32_t isHTMLDocumentClassFlag() { return HTMLDocumentClass; }
 536 
 537     bool isSrcdocDocument() const { return m_isSrcdocDocument; }
 538 
 539     bool sawElementsInKnownNamespaces() const { return m_sawElementsInKnownNamespaces; }
 540 
<span class="line-modified"> 541     Style::Resolver&amp; userAgentShadowTreeStyleResolver();</span>
 542 
 543     CSSFontSelector&amp; fontSelector() { return m_fontSelector; }
<span class="line-added"> 544     const CSSFontSelector&amp; fontSelector() const { return m_fontSelector; }</span>
 545 
 546     WEBCORE_EXPORT bool haveStylesheetsLoaded() const;
 547     bool isIgnoringPendingStylesheets() const { return m_ignorePendingStylesheets; }
 548 
 549     WEBCORE_EXPORT StyleSheetList&amp; styleSheets();
 550 
 551     Style::Scope&amp; styleScope() { return *m_styleScope; }
 552     const Style::Scope&amp; styleScope() const { return *m_styleScope; }
 553     ExtensionStyleSheets&amp; extensionStyleSheets() { return *m_extensionStyleSheets; }
 554     const ExtensionStyleSheets&amp; extensionStyleSheets() const { return *m_extensionStyleSheets; }
 555 
 556     bool gotoAnchorNeededAfterStylesheetsLoad() { return m_gotoAnchorNeededAfterStylesheetsLoad; }
 557     void setGotoAnchorNeededAfterStylesheetsLoad(bool b) { m_gotoAnchorNeededAfterStylesheetsLoad = b; }
 558 
<span class="line-modified"> 559     void updateElementsAffectedByMediaQueries();</span>
<span class="line-added"> 560     void evaluateMediaQueriesAndReportChanges();</span>
 561 
 562     FormController&amp; formController();
 563     Vector&lt;String&gt; formElementsState() const;
 564     void setStateForNewFormElements(const Vector&lt;String&gt;&amp;);
 565 
 566     WEBCORE_EXPORT FrameView* view() const; // Can be null.
 567     WEBCORE_EXPORT Page* page() const; // Can be null.
 568     const Settings&amp; settings() const { return m_settings.get(); }
 569     Settings&amp; mutableSettings() { return m_settings.get(); }
 570     EditingBehavior editingBehavior() const;
 571 
 572     const Quirks&amp; quirks() const { return m_quirks; }
 573 
 574     float deviceScaleFactor() const;
 575 
 576     WEBCORE_EXPORT bool useSystemAppearance() const;
 577     WEBCORE_EXPORT bool useElevatedUserInterfaceLevel() const;
 578     WEBCORE_EXPORT bool useDarkAppearance(const RenderStyle*) const;
 579 
 580     OptionSet&lt;StyleColor::Options&gt; styleColorOptions(const RenderStyle*) const;
</pre>
<hr />
<pre>
 625     // Override ScriptExecutionContext methods to do additional work
 626     WEBCORE_EXPORT bool shouldBypassMainWorldContentSecurityPolicy() const final;
 627     void suspendActiveDOMObjects(ReasonForSuspension) final;
 628     void resumeActiveDOMObjects(ReasonForSuspension) final;
 629     void stopActiveDOMObjects() final;
 630 
 631     void suspendDeviceMotionAndOrientationUpdates();
 632     void resumeDeviceMotionAndOrientationUpdates();
 633 
 634     RenderView* renderView() const { return m_renderView.get(); }
 635 
 636     bool renderTreeBeingDestroyed() const { return m_renderTreeBeingDestroyed; }
 637     bool hasLivingRenderTree() const { return renderView() &amp;&amp; !renderTreeBeingDestroyed(); }
 638 
 639     bool updateLayoutIfDimensionsOutOfDate(Element&amp;, DimensionsCheck = AllDimensionsCheck);
 640 
 641     AXObjectCache* existingAXObjectCache() const;
 642     WEBCORE_EXPORT AXObjectCache* axObjectCache() const;
 643     void clearAXObjectCache();
 644 
<span class="line-modified"> 645     WEBCORE_EXPORT Optional&lt;PageIdentifier&gt; pageID() const;</span>
 646     // to get visually ordered hebrew and arabic pages right
 647     void setVisuallyOrdered();
 648     bool visuallyOrdered() const { return m_visuallyOrdered; }
 649 
 650     WEBCORE_EXPORT DocumentLoader* loader() const;
 651 
 652     WEBCORE_EXPORT ExceptionOr&lt;RefPtr&lt;WindowProxy&gt;&gt; openForBindings(DOMWindow&amp; activeWindow, DOMWindow&amp; firstDOMWindow, const String&amp; url, const AtomString&amp; name, const String&amp; features);
 653     WEBCORE_EXPORT ExceptionOr&lt;Document&amp;&gt; openForBindings(Document* responsibleDocument, const String&amp;, const String&amp;);
 654 
 655     // FIXME: We should rename this at some point and give back the name &#39;open&#39; to the HTML specified ones.
 656     WEBCORE_EXPORT ExceptionOr&lt;void&gt; open(Document* responsibleDocument = nullptr);
 657     void implicitOpen();
 658 
 659     WEBCORE_EXPORT ExceptionOr&lt;void&gt; closeForBindings();
 660 
 661     // FIXME: We should rename this at some point and give back the name &#39;close&#39; to the HTML specified one.
 662     WEBCORE_EXPORT void close();
 663     // In some situations (see the code), we ignore document.close().
 664     // explicitClose() bypass these checks and actually tries to close the
 665     // input stream.
</pre>
<hr />
<pre>
 671 
 672     ExceptionOr&lt;void&gt; write(Document* responsibleDocument, SegmentedString&amp;&amp;);
 673     WEBCORE_EXPORT ExceptionOr&lt;void&gt; write(Document* responsibleDocument, Vector&lt;String&gt;&amp;&amp;);
 674     WEBCORE_EXPORT ExceptionOr&lt;void&gt; writeln(Document* responsibleDocument, Vector&lt;String&gt;&amp;&amp;);
 675 
 676     bool wellFormed() const { return m_wellFormed; }
 677 
 678     const URL&amp; url() const final { return m_url; }
 679     void setURL(const URL&amp;);
 680     const URL&amp; urlForBindings() const { return m_url.isEmpty() ? WTF::blankURL() : m_url; }
 681 
 682     // To understand how these concepts relate to one another, please see the
 683     // comments surrounding their declaration.
 684     const URL&amp; baseURL() const { return m_baseURL; }
 685     void setBaseURLOverride(const URL&amp;);
 686     const URL&amp; baseURLOverride() const { return m_baseURLOverride; }
 687     const URL&amp; baseElementURL() const { return m_baseElementURL; }
 688     const String&amp; baseTarget() const { return m_baseTarget; }
 689     void processBaseElement();
 690 
<span class="line-modified"> 691     WEBCORE_EXPORT URL completeURL(const String&amp;, ForceUTF8 = ForceUTF8::No) const final;</span>
<span class="line-modified"> 692     URL completeURL(const String&amp;, const URL&amp; baseURLOverride, ForceUTF8 = ForceUTF8::No) const;</span>

 693 
 694     String userAgent(const URL&amp;) const final;
 695 
 696     void disableEval(const String&amp; errorMessage) final;
 697     void disableWebAssembly(const String&amp; errorMessage) final;
 698 
 699 #if ENABLE(INDEXED_DATABASE)
 700     IDBClient::IDBConnectionProxy* idbConnectionProxy() final;
 701 #endif
 702     SocketProvider* socketProvider() final;
 703 
 704     bool canNavigate(Frame* targetFrame, const URL&amp; destinationURL = URL());
 705 
 706     bool usesStyleBasedEditability() const;
 707     void setHasElementUsingStyleBasedEditability();
 708 
 709     virtual Ref&lt;DocumentParser&gt; createParser();
 710     DocumentParser* parser() const { return m_parser.get(); }
 711     ScriptableDocumentParser* scriptableDocumentParser() const;
 712 
</pre>
<hr />
<pre>
 746     void setLinkColor(const Color&amp; c) { m_linkColor = c; }
 747     void setVisitedLinkColor(const Color&amp; c) { m_visitedLinkColor = c; }
 748     void setActiveLinkColor(const Color&amp; c) { m_activeLinkColor = c; }
 749     void resetLinkColor();
 750     void resetVisitedLinkColor();
 751     void resetActiveLinkColor();
 752     VisitedLinkState&amp; visitedLinkState() const { return *m_visitedLinkState; }
 753 
 754     MouseEventWithHitTestResults prepareMouseEvent(const HitTestRequest&amp;, const LayoutPoint&amp;, const PlatformMouseEvent&amp;);
 755 
 756     enum class FocusRemovalEventsMode { Dispatch, DoNotDispatch };
 757     WEBCORE_EXPORT bool setFocusedElement(Element*, FocusDirection = FocusDirectionNone,
 758         FocusRemovalEventsMode = FocusRemovalEventsMode::Dispatch);
 759     Element* focusedElement() const { return m_focusedElement.get(); }
 760     UserActionElementSet&amp; userActionElements()  { return m_userActionElements; }
 761     const UserActionElementSet&amp; userActionElements() const { return m_userActionElements; }
 762 
 763     void setFocusNavigationStartingNode(Node*);
 764     Element* focusNavigationStartingNode(FocusDirection) const;
 765 
<span class="line-added"> 766     void didRejectSyncXHRDuringPageDismissal();</span>
<span class="line-added"> 767     bool shouldIgnoreSyncXHRs() const;</span>
<span class="line-added"> 768 </span>
 769     enum class NodeRemoval { Node, ChildrenOfNode };
 770     void adjustFocusedNodeOnNodeRemoval(Node&amp;, NodeRemoval = NodeRemoval::Node);
 771     void adjustFocusNavigationNodeOnNodeRemoval(Node&amp;, NodeRemoval = NodeRemoval::Node);
 772 
 773     void hoveredElementDidDetach(Element&amp;);
 774     void elementInActiveChainDidDetach(Element&amp;);
 775 
 776     enum class CaptureChange : uint8_t { Yes, No };
 777     void updateHoverActiveState(const HitTestRequest&amp;, Element*, CaptureChange = CaptureChange::No);
 778 
 779     // Updates for :target (CSS3 selector).
 780     void setCSSTarget(Element*);
 781     Element* cssTarget() const { return m_cssTarget; }
 782     static ptrdiff_t cssTargetMemoryOffset() { return OBJECT_OFFSETOF(Document, m_cssTarget); }
 783 
 784     WEBCORE_EXPORT void scheduleFullStyleRebuild();
 785     void scheduleStyleRecalc();
 786     void unscheduleStyleRecalc();
 787     bool hasPendingStyleRecalc() const;
 788     bool hasPendingFullStyleRebuild() const;
</pre>
<hr />
<pre>
 909 #endif
 910 
 911     // Returns the owning element in the parent document.
 912     // Returns nullptr if this is the top level document.
 913     HTMLFrameOwnerElement* ownerElement() const;
 914 
 915     // Used by DOM bindings; no direction known.
 916     const String&amp; title() const { return m_title.string; }
 917     WEBCORE_EXPORT void setTitle(const String&amp;);
 918 
 919     WEBCORE_EXPORT const AtomString&amp; dir() const;
 920     WEBCORE_EXPORT void setDir(const AtomString&amp;);
 921 
 922     void titleElementAdded(Element&amp; titleElement);
 923     void titleElementRemoved(Element&amp; titleElement);
 924     void titleElementTextChanged(Element&amp; titleElement);
 925 
 926     WEBCORE_EXPORT ExceptionOr&lt;String&gt; cookie();
 927     WEBCORE_EXPORT ExceptionOr&lt;void&gt; setCookie(const String&amp;);
 928 
<span class="line-modified"> 929     WEBCORE_EXPORT String referrer();</span>


 930 
 931     WEBCORE_EXPORT String domain() const;
 932     ExceptionOr&lt;void&gt; setDomain(const String&amp; newDomain);
 933 
 934     void overrideLastModified(const Optional&lt;WallTime&gt;&amp;);
 935     WEBCORE_EXPORT String lastModified() const;
 936 
 937     // The cookieURL is used to query the cookie database for this document&#39;s
 938     // cookies. For example, if the cookie URL is http://example.com, we&#39;ll
 939     // use the non-Secure cookies for example.com when computing
 940     // document.cookie.
 941     //
 942     // Q: How is the cookieURL different from the document&#39;s URL?
 943     // A: The two URLs are the same almost all the time.  However, if one
 944     //    document inherits the security context of another document, it
 945     //    inherits its cookieURL but not its URL.
 946     //
 947     const URL&amp; cookieURL() const { return m_cookieURL; }
 948     void setCookieURL(const URL&amp;);
 949 
</pre>
<hr />
<pre>
1028 
1029     bool shouldDeferAsynchronousScriptsUntilParsingFinishes() const;
1030 
1031 #if ENABLE(XSLT)
1032     void scheduleToApplyXSLTransforms();
1033     void applyPendingXSLTransformsNowIfScheduled();
1034     RefPtr&lt;Document&gt; transformSourceDocument() { return m_transformSourceDocument; }
1035     void setTransformSourceDocument(Document* document) { m_transformSourceDocument = document; }
1036 
1037     void setTransformSource(std::unique_ptr&lt;TransformSource&gt;);
1038     TransformSource* transformSource() const { return m_transformSource.get(); }
1039 #endif
1040 
1041     void incDOMTreeVersion() { m_domTreeVersion = ++s_globalTreeVersion; }
1042     uint64_t domTreeVersion() const { return m_domTreeVersion; }
1043 
1044     WEBCORE_EXPORT String originIdentifierForPasteboard() const;
1045 
1046     // XPathEvaluator methods
1047     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;XPathExpression&gt;&gt; createExpression(const String&amp; expression, RefPtr&lt;XPathNSResolver&gt;&amp;&amp;);
<span class="line-modified">1048     WEBCORE_EXPORT Ref&lt;XPathNSResolver&gt; createNSResolver(Node&amp; nodeResolver);</span>
<span class="line-modified">1049     WEBCORE_EXPORT ExceptionOr&lt;Ref&lt;XPathResult&gt;&gt; evaluate(const String&amp; expression, Node&amp; contextNode, RefPtr&lt;XPathNSResolver&gt;&amp;&amp;, unsigned short type, XPathResult*);</span>
1050 
1051     bool hasNodesWithNonFinalStyle() const { return m_hasNodesWithNonFinalStyle; }
1052     void setHasNodesWithNonFinalStyle() { m_hasNodesWithNonFinalStyle = true; }
1053     bool hasNodesWithMissingStyle() const { return m_hasNodesWithMissingStyle; }
1054     void setHasNodesWithMissingStyle() { m_hasNodesWithMissingStyle = true; }
1055 
1056     // Extension for manipulating canvas drawing contexts for use in CSS
1057     Optional&lt;RenderingContext&gt; getCSSCanvasContext(const String&amp; type, const String&amp; name, int width, int height);
1058     HTMLCanvasElement* getCSSCanvasElement(const String&amp; name);
1059     String nameForCSSCanvasElement(const HTMLCanvasElement&amp;) const;
1060 
1061     bool isDNSPrefetchEnabled() const { return m_isDNSPrefetchEnabled; }
1062     void parseDNSPrefetchControlHeader(const String&amp;);
1063 
1064     WEBCORE_EXPORT void postTask(Task&amp;&amp;) final; // Executes the task on context&#39;s thread asynchronously.
1065 
<span class="line-added">1066     EventLoopTaskGroup&amp; eventLoop() final;</span>
<span class="line-added">1067     WindowEventLoop&amp; windowEventLoop();</span>
<span class="line-added">1068 </span>
1069     ScriptedAnimationController* scriptedAnimationController() { return m_scriptedAnimationController.get(); }
1070     void suspendScriptedAnimationControllerCallbacks();
1071     void resumeScriptedAnimationControllerCallbacks();
1072 
<span class="line-modified">1073     void updateAnimationsAndSendEvents(DOMHighResTimeStamp);</span>
<span class="line-modified">1074     void serviceRequestAnimationFrameCallbacks(DOMHighResTimeStamp);</span>
1075 
1076     void windowScreenDidChange(PlatformDisplayID);
1077 
1078     void finishedParsing();
1079 
<span class="line-modified">1080     enum BackForwardCacheState { NotInBackForwardCache, AboutToEnterBackForwardCache, InBackForwardCache };</span>
1081 
<span class="line-modified">1082     BackForwardCacheState backForwardCacheState() const { return m_backForwardCacheState; }</span>
<span class="line-modified">1083     void setBackForwardCacheState(BackForwardCacheState);</span>
1084 
1085     void registerForDocumentSuspensionCallbacks(Element&amp;);
1086     void unregisterForDocumentSuspensionCallbacks(Element&amp;);
1087 
1088     void documentWillBecomeInactive();
1089     void suspend(ReasonForSuspension);
1090     void resume(ReasonForSuspension);
1091 
<span class="line-modified">1092     void registerMediaElement(HTMLMediaElement&amp;);</span>
<span class="line-modified">1093     void unregisterMediaElement(HTMLMediaElement&amp;);</span>

1094 
1095     bool audioPlaybackRequiresUserGesture() const;
1096     bool videoPlaybackRequiresUserGesture() const;
<span class="line-added">1097     bool mediaDataLoadsAutomatically() const;</span>
1098 
1099 #if ENABLE(MEDIA_SESSION)
1100     MediaSession&amp; defaultMediaSession();
1101 #endif
1102 



1103     void privateBrowsingStateDidChange(PAL::SessionID);
1104 
<span class="line-added">1105     void storageBlockingStateDidChange();</span>
<span class="line-added">1106 </span>
1107 #if ENABLE(VIDEO_TRACK)
<span class="line-modified">1108     void registerForCaptionPreferencesChangedCallbacks(HTMLMediaElement&amp;);</span>
<span class="line-modified">1109     void unregisterForCaptionPreferencesChangedCallbacks(HTMLMediaElement&amp;);</span>
1110     void captionPreferencesChanged();
1111 #endif
1112 









1113     void registerForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp;);
1114     void unregisterForVisibilityStateChangedCallbacks(VisibilityChangeClient&amp;);
1115 
1116 #if ENABLE(VIDEO)




1117     void stopAllMediaPlayback();
1118     void suspendAllMediaPlayback();
1119     void resumeAllMediaPlayback();
1120     void suspendAllMediaBuffering();
1121     void resumeAllMediaBuffering();
1122 #endif
1123 
1124     WEBCORE_EXPORT void setShouldCreateRenderers(bool);
1125     bool shouldCreateRenderers();
1126 
1127     void setDecoder(RefPtr&lt;TextResourceDecoder&gt;&amp;&amp;);
1128     TextResourceDecoder* decoder() const { return m_decoder.get(); }
1129 
1130     WEBCORE_EXPORT String displayStringModifiedByEncoding(const String&amp;) const;
1131 
1132     void invalidateRenderingDependentRegions();
1133 
1134     void removeAllEventListeners() final;
1135 
1136     WEBCORE_EXPORT const SVGDocumentExtensions* svgExtensions();
1137     WEBCORE_EXPORT SVGDocumentExtensions&amp; accessSVGExtensions();
1138 
1139     void addSVGUseElement(SVGUseElement&amp;);
1140     void removeSVGUseElement(SVGUseElement&amp;);
1141     HashSet&lt;SVGUseElement*&gt; const svgUseElements() const { return m_svgUseElements; }
1142 
1143     void initSecurityContext();
<span class="line-modified">1144     void initContentSecurityPolicy();</span>
1145 
1146     void updateURLForPushOrReplaceState(const URL&amp;);
1147     void statePopped(Ref&lt;SerializedScriptValue&gt;&amp;&amp;);
1148 
1149     bool processingLoadEvent() const { return m_processingLoadEvent; }
1150     bool loadEventFinished() const { return m_loadEventFinished; }
1151 
1152     bool isContextThread() const final;
1153     bool isSecureContext() const final;
1154     bool isJSExecutionForbidden() const final { return false; }
1155 
<span class="line-modified">1156     void queueTaskToDispatchEvent(TaskSource, Ref&lt;Event&gt;&amp;&amp;);</span>
<span class="line-modified">1157     void queueTaskToDispatchEventOnWindow(TaskSource, Ref&lt;Event&gt;&amp;&amp;);</span>
1158     void enqueueOverflowEvent(Ref&lt;Event&gt;&amp;&amp;);
1159     void dispatchPageshowEvent(PageshowEventPersistence);
1160     WEBCORE_EXPORT void enqueueSecurityPolicyViolationEvent(SecurityPolicyViolationEvent::Init&amp;&amp;);
1161     void enqueueHashchangeEvent(const String&amp; oldURL, const String&amp; newURL);
1162     void dispatchPopstateEvent(RefPtr&lt;SerializedScriptValue&gt;&amp;&amp; stateObject);

1163 
1164     WEBCORE_EXPORT void addMediaCanStartListener(MediaCanStartListener&amp;);
1165     WEBCORE_EXPORT void removeMediaCanStartListener(MediaCanStartListener&amp;);
1166     MediaCanStartListener* takeAnyMediaCanStartListener();
1167 
1168 #if ENABLE(FULLSCREEN_API)
1169     FullscreenManager&amp; fullscreenManager() { return m_fullscreenManager; }
1170     const FullscreenManager&amp; fullscreenManager() const { return m_fullscreenManager; }
1171 #endif
1172 
1173 #if ENABLE(POINTER_LOCK)
1174     WEBCORE_EXPORT void exitPointerLock();
1175 #endif
1176 
1177     // Used to allow element that loads data without going through a FrameLoader to delay the &#39;load&#39; event.
1178     void incrementLoadEventDelayCount() { ++m_loadEventDelayCount; }
1179     void decrementLoadEventDelayCount();
1180     bool isDelayingLoadEvent() const { return m_loadEventDelayCount; }
1181     void checkCompleted();
1182 
1183 #if ENABLE(IOS_TOUCH_EVENTS)
1184 #include &lt;WebKitAdditions/DocumentIOS.h&gt;
1185 #endif
1186 
<span class="line-modified">1187 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)</span>

1188     DeviceMotionController&amp; deviceMotionController() const;
1189     DeviceOrientationController&amp; deviceOrientationController() const;
1190     WEBCORE_EXPORT void simulateDeviceOrientationChange(double alpha, double beta, double gamma);
1191 #endif
1192 
<span class="line-added">1193 #if ENABLE(DEVICE_ORIENTATION)</span>
1194     DeviceOrientationAndMotionAccessController&amp; deviceOrientationAndMotionAccessController();
<span class="line-modified">1195 #endif</span>
1196 
1197     const DocumentTiming&amp; timing() const { return m_documentTiming; }
1198 
1199     WEBCORE_EXPORT double monotonicTimestamp() const;
1200 
1201     int requestAnimationFrame(Ref&lt;RequestAnimationFrameCallback&gt;&amp;&amp;);
1202     void cancelAnimationFrame(int id);
1203 
<span class="line-added">1204     int requestIdleCallback(Ref&lt;IdleRequestCallback&gt;&amp;&amp;, Seconds timeout);</span>
<span class="line-added">1205     void cancelIdleCallback(int id);</span>
<span class="line-added">1206     IdleCallbackController* idleCallbackController() { return m_idleCallbackController.get(); }</span>
<span class="line-added">1207 </span>
1208     EventTarget* errorEventTarget() final;
1209     void logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;) final;
1210 
1211     void initDNSPrefetch();
1212 
1213     void didAddWheelEventHandler(Node&amp;);
1214     void didRemoveWheelEventHandler(Node&amp;, EventHandlerRemoval = EventHandlerRemoval::One);
1215 
1216     MonotonicTime lastHandledUserGestureTimestamp() const { return m_lastHandledUserGestureTimestamp; }
1217     bool hasHadUserInteraction() const { return static_cast&lt;bool&gt;(m_lastHandledUserGestureTimestamp); }
1218     void updateLastHandledUserGestureTimestamp(MonotonicTime);
1219     bool processingUserGestureForMedia() const;
1220     void userActivatedMediaFinishedPlaying() { m_userActivatedMediaFinishedPlayingTimestamp = MonotonicTime::now(); }
1221 
1222     void setUserDidInteractWithPage(bool userDidInteractWithPage) { ASSERT(&amp;topDocument() == this); m_userDidInteractWithPage = userDidInteractWithPage; }
1223     bool userDidInteractWithPage() const { ASSERT(&amp;topDocument() == this); return m_userDidInteractWithPage; }
1224 
1225     // Used for testing. Count handlers in the main document, and one per frame which contains handlers.
1226     WEBCORE_EXPORT unsigned wheelEventHandlerCount() const;
1227     WEBCORE_EXPORT unsigned touchEventHandlerCount() const;
</pre>
<hr />
<pre>
1309     const Document* templateDocument() const;
1310     Document&amp; ensureTemplateDocument();
1311     void setTemplateDocumentHost(Document* templateDocumentHost) { m_templateDocumentHost = makeWeakPtr(templateDocumentHost); }
1312     Document* templateDocumentHost() { return m_templateDocumentHost.get(); }
1313 
1314     void didAssociateFormControl(Element&amp;);
1315     bool hasDisabledFieldsetElement() const { return m_disabledFieldsetElementsCount; }
1316     void addDisabledFieldsetElement() { m_disabledFieldsetElementsCount++; }
1317     void removeDisabledFieldsetElement() { ASSERT(m_disabledFieldsetElementsCount); m_disabledFieldsetElementsCount--; }
1318 
1319     void getParserLocation(String&amp; url, unsigned&amp; line, unsigned&amp; column) const;
1320 
1321     WEBCORE_EXPORT void addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp;) final;
1322 
1323     // The following addConsoleMessage function is deprecated.
1324     // Callers should try to create the ConsoleMessage themselves.
1325     WEBCORE_EXPORT void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier = 0) final;
1326 
1327     // The following addMessage function is deprecated.
1328     // Callers should try to create the ConsoleMessage themselves.
<span class="line-modified">1329     void addMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, JSC::JSGlobalObject* = nullptr, unsigned long requestIdentifier = 0) final;</span>
1330 
1331     SecurityOrigin&amp; securityOrigin() const { return *SecurityContext::securityOrigin(); }
1332     SecurityOrigin&amp; topOrigin() const final { return topDocument().securityOrigin(); }
1333 
<span class="line-added">1334     void willLoadScriptElement(const URL&amp;);</span>
<span class="line-added">1335     void willLoadFrameElement(const URL&amp;);</span>
<span class="line-added">1336 </span>
1337     Ref&lt;FontFaceSet&gt; fonts();
1338 
1339     void ensurePlugInsInjectedScript(DOMWrapperWorld&amp;);
1340 
1341     void setVisualUpdatesAllowedByClient(bool);
1342 
1343 #if ENABLE(WEB_CRYPTO)
1344     bool wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey) final;
1345     bool unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key) final;
1346 #endif
1347 
1348     void setHasStyleWithViewportUnits() { m_hasStyleWithViewportUnits = true; }
1349     bool hasStyleWithViewportUnits() const { return m_hasStyleWithViewportUnits; }
1350     void updateViewportUnitsOnResize();
1351 
<span class="line-added">1352     void setNeedsDOMWindowResizeEvent();</span>
<span class="line-added">1353     void setNeedsVisualViewportResize();</span>
<span class="line-added">1354     void runResizeSteps();</span>
<span class="line-added">1355 </span>
<span class="line-added">1356     void addPendingScrollEventTarget(ContainerNode&amp;);</span>
<span class="line-added">1357     void setNeedsVisualViewportScrollEvent();</span>
<span class="line-added">1358     void runScrollSteps();</span>
<span class="line-added">1359 </span>
1360     WEBCORE_EXPORT void addAudioProducer(MediaProducer&amp;);
1361     WEBCORE_EXPORT void removeAudioProducer(MediaProducer&amp;);
1362     MediaProducer::MediaStateFlags mediaState() const { return m_mediaState; }
1363     void noteUserInteractionWithMediaElement();
1364     bool isCapturing() const { return MediaProducer::isCapturing(m_mediaState); }
1365     WEBCORE_EXPORT void updateIsPlayingMedia(uint64_t = HTMLMediaElementInvalidID);
1366     void pageMutedStateDidChange();
1367 
1368 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1369     void addPlaybackTargetPickerClient(MediaPlaybackTargetClient&amp;);
1370     void removePlaybackTargetPickerClient(MediaPlaybackTargetClient&amp;);
1371     void showPlaybackTargetPicker(MediaPlaybackTargetClient&amp;, bool, RouteSharingPolicy, const String&amp;);
1372     void playbackTargetPickerClientStateDidChange(MediaPlaybackTargetClient&amp;, MediaProducer::MediaStateFlags);
1373 
1374     void setPlaybackTarget(uint64_t, Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;);
1375     void playbackTargetAvailabilityDidChange(uint64_t, bool);
1376     void setShouldPlayToPlaybackTarget(uint64_t, bool);
<span class="line-added">1377     void playbackTargetPickerWasDismissed(uint64_t);</span>
1378 #endif
1379 
1380     ShouldOpenExternalURLsPolicy shouldOpenExternalURLsPolicyToPropagate() const;
1381     bool shouldEnforceContentDispositionAttachmentSandbox() const;
1382     void applyContentDispositionAttachmentSandbox();
1383 
<span class="line-modified">1384     void addDynamicMediaQueryDependentImage(HTMLImageElement&amp;);</span>
<span class="line-modified">1385     void removeDynamicMediaQueryDependentImage(HTMLImageElement&amp;);</span>



1386 
1387     void scheduleTimedRenderingUpdate();
1388 
1389 #if ENABLE(INTERSECTION_OBSERVER)
1390     void addIntersectionObserver(IntersectionObserver&amp;);
1391     void removeIntersectionObserver(IntersectionObserver&amp;);
1392     unsigned numberOfIntersectionObservers() const { return m_intersectionObservers.size(); }
1393     void updateIntersectionObservations();
1394     void scheduleInitialIntersectionObservationUpdate();
1395 #endif
1396 
1397 #if ENABLE(RESIZE_OBSERVER)
1398     void addResizeObserver(ResizeObserver&amp;);
1399     void removeResizeObserver(ResizeObserver&amp;);
1400     bool hasResizeObservers();
1401     // Return the minDepth of the active observations.
1402     size_t gatherResizeObservations(size_t deeperThan);
1403     void deliverResizeObservations();
1404     bool hasSkippedResizeObservations() const;
1405     void setHasSkippedResizeObservations(bool);
1406     void updateResizeObservations(Page&amp;);
1407 #endif
1408 
1409 #if ENABLE(MEDIA_STREAM)
1410     void setHasCaptureMediaStreamTrack() { m_hasHadCaptureMediaStreamTrack = true; }
1411     bool hasHadCaptureMediaStreamTrack() const { return m_hasHadCaptureMediaStreamTrack; }
1412     void setDeviceIDHashSalt(const String&amp;);
1413     String deviceIDHashSalt() const { return m_idHashSalt; }
1414     void stopMediaCapture();


1415     void mediaStreamCaptureStateChanged();
1416 #endif
1417 
1418 // FIXME: Find a better place for this functionality.
1419 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
1420     // These functions provide a two-level setting:
1421     //    - A user-settable wantsTelephoneNumberParsing (at the Page / WebView level)
1422     //    - A read-only telephoneNumberParsingAllowed which is set by the
1423     //      document if it has the appropriate meta tag.
1424     //    - isTelephoneNumberParsingEnabled() == isTelephoneNumberParsingAllowed() &amp;&amp; page()-&gt;settings()-&gt;isTelephoneNumberParsingEnabled()
1425     WEBCORE_EXPORT bool isTelephoneNumberParsingAllowed() const;
1426     WEBCORE_EXPORT bool isTelephoneNumberParsingEnabled() const;
1427 #endif
1428 
1429     using ContainerNode::setAttributeEventListener;
1430     void setAttributeEventListener(const AtomString&amp; eventType, const QualifiedName&amp; attributeName, const AtomString&amp; value, DOMWrapperWorld&amp; isolatedWorld);
1431 
1432     DOMSelection* getSelection();
1433 
1434     void didInsertInDocumentShadowRoot(ShadowRoot&amp;);
</pre>
<hr />
<pre>
1455     WEBCORE_EXPORT void setVlinkColor(const String&amp;);
1456 
1457     // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-clear, this method does nothing.
1458     void clear() { }
1459     // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-captureevents, this method does nothing.
1460     void captureEvents() { }
1461     // Per https://html.spec.whatwg.org/multipage/obsolete.html#dom-document-releaseevents, this method does nothing.
1462     void releaseEvents() { }
1463 
1464 #if ENABLE(TEXT_AUTOSIZING)
1465     TextAutoSizing&amp; textAutoSizing();
1466 #endif
1467 
1468     // For debugging rdar://problem/49877867.
1469     void setMayBeDetachedFromFrame(bool mayBeDetachedFromFrame) { m_mayBeDetachedFromFrame = mayBeDetachedFromFrame; }
1470 
1471     Logger&amp; logger();
1472 
1473     WEBCORE_EXPORT void setConsoleMessageListener(RefPtr&lt;StringCallback&gt;&amp;&amp;); // For testing.
1474 
<span class="line-added">1475     void addTimeline(DocumentTimeline&amp;);</span>
<span class="line-added">1476     void removeTimeline(DocumentTimeline&amp;);</span>
1477     WEBCORE_EXPORT DocumentTimeline&amp; timeline();
1478     DocumentTimeline* existingTimeline() const { return m_timeline.get(); }
1479     Vector&lt;RefPtr&lt;WebAnimation&gt;&gt; getAnimations();
1480 
1481 #if ENABLE(ATTACHMENT_ELEMENT)
1482     void registerAttachmentIdentifier(const String&amp;);
1483     void didInsertAttachmentElement(HTMLAttachmentElement&amp;);
1484     void didRemoveAttachmentElement(HTMLAttachmentElement&amp;);
1485     WEBCORE_EXPORT RefPtr&lt;HTMLAttachmentElement&gt; attachmentForIdentifier(const String&amp;) const;
1486     const HashMap&lt;String, Ref&lt;HTMLAttachmentElement&gt;&gt;&amp; attachmentElementsByIdentifier() const { return m_attachmentIdentifierToElementMap; }
1487 #endif
1488 
1489 #if ENABLE(SERVICE_WORKER)
1490     void setServiceWorkerConnection(SWClientConnection*);
1491 #endif
1492 
<span class="line-modified">1493 #if ENABLE(VIDEO)</span>
<span class="line-modified">1494     void forEachMediaElement(const Function&lt;void(HTMLMediaElement&amp;)&gt;&amp;);</span>
<span class="line-modified">1495 #endif</span>
1496 
1497 #if ENABLE(IOS_TOUCH_EVENTS)
1498     bool handlingTouchEvent() const { return m_handlingTouchEvent; }
1499 #endif
1500 
1501 #if ENABLE(RESOURCE_LOAD_STATISTICS)
<span class="line-modified">1502     WEBCORE_EXPORT bool hasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp;);</span>
<span class="line-modified">1503     WEBCORE_EXPORT void setHasRequestedPageSpecificStorageAccessWithUserInteraction(const RegistrableDomain&amp;);</span>
1504     WEBCORE_EXPORT void wasLoadedWithDataTransferFromPrevalentResource();
1505     void downgradeReferrerToRegistrableDomain();
1506 #endif
1507 
1508     String signedPublicKeyAndChallengeString(unsigned keySizeIndex, const String&amp; challengeString, const URL&amp;);
1509 
1510     void registerArticleElement(Element&amp;);
1511     void unregisterArticleElement(Element&amp;);
1512     void updateMainArticleElementAfterLayout();
1513     bool hasMainArticleElement() const { return !!m_mainArticleElement; }
1514 
1515     const CSSRegisteredCustomPropertySet&amp; getCSSRegisteredCustomPropertySet() const { return m_CSSRegisteredPropertySet; }
1516     bool registerCSSProperty(CSSRegisteredCustomProperty&amp;&amp;);
1517 
1518 #if ENABLE(CSS_PAINTING_API)
1519     Worklet&amp; ensurePaintWorklet();
1520     PaintWorkletGlobalScope* paintWorkletGlobalScopeForName(const String&amp; name);
1521     void setPaintWorkletGlobalScopeForName(const String&amp; name, Ref&lt;PaintWorkletGlobalScope&gt;&amp;&amp;);
1522 #endif
1523 
1524     WEBCORE_EXPORT bool hasEvaluatedUserAgentScripts() const;
1525     WEBCORE_EXPORT bool isRunningUserScripts() const;
1526     WEBCORE_EXPORT void setAsRunningUserScripts();
1527     void setHasEvaluatedUserAgentScripts();
1528 #if ENABLE(APPLE_PAY)
1529     WEBCORE_EXPORT bool isApplePayActive() const;
1530     WEBCORE_EXPORT void setApplePayIsActive();
1531 #endif
1532 
1533     void frameWasDisconnectedFromOwner();
1534 
1535     WEBCORE_EXPORT bool hitTest(const HitTestRequest&amp;, HitTestResult&amp;);
1536     bool hitTest(const HitTestRequest&amp;, const HitTestLocation&amp;, HitTestResult&amp;);
<span class="line-modified">1537 #if ASSERT_ENABLED</span>
1538     bool inHitTesting() const { return m_inHitTesting; }
1539 #endif
1540 
<span class="line-added">1541     MessagePortChannelProvider&amp; messagePortChannelProvider();</span>
<span class="line-added">1542 </span>
<span class="line-added">1543 #if USE(SYSTEM_PREVIEW)</span>
<span class="line-added">1544     WEBCORE_EXPORT void dispatchSystemPreviewActionEvent(const SystemPreviewInfo&amp;, const String&amp; message);</span>
<span class="line-added">1545 #endif</span>
<span class="line-added">1546 </span>
<span class="line-added">1547 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">1548     HTMLVideoElement* pictureInPictureElement() const;</span>
<span class="line-added">1549     void setPictureInPictureElement(HTMLVideoElement*);</span>
<span class="line-added">1550 #endif</span>
<span class="line-added">1551 </span>
<span class="line-added">1552     WEBCORE_EXPORT TextManipulationController&amp; textManipulationController();</span>
<span class="line-added">1553     TextManipulationController* textManipulationControllerIfExists() { return m_textManipulationController.get(); }</span>
<span class="line-added">1554 </span>
<span class="line-added">1555     HighlightMap&amp; highlightMap();</span>
<span class="line-added">1556     void updateHighlightPositions();</span>
<span class="line-added">1557 </span>
1558 protected:
1559     enum ConstructionFlags { Synthesized = 1, NonRenderedPlaceholder = 1 &lt;&lt; 1 };
<span class="line-modified">1560     Document(Frame*, const URL&amp;, unsigned = DefaultDocumentClass, unsigned constructionFlags = 0);</span>
1561 
1562     void clearXMLVersion() { m_xmlVersion = String(); }
1563 
1564     virtual Ref&lt;Document&gt; cloneDocumentWithoutChildren() const;
1565 
1566 private:
1567     friend class DocumentParserYieldToken;
1568     friend class Node;
1569     friend class ThrowOnDynamicMarkupInsertionCountIncrementer;
1570     friend class IgnoreOpensDuringUnloadCountIncrementer;
1571     friend class IgnoreDestructiveWriteCountIncrementer;
1572 


1573     void updateTitleElement(Element&amp; changingTitleElement);
1574     void willDetachPage() final;
1575     void frameDestroyed() final;
1576 
1577     void commonTeardown();
1578 
1579     RenderObject* renderer() const = delete;
1580     void setRenderer(RenderObject*) = delete;
1581 
1582     void createRenderTree();
1583     void detachParser();
1584 
1585     // FontSelectorClient
1586     void fontsNeedUpdate(FontSelector&amp;) final;
1587 
1588     bool isDocument() const final { return true; }
1589 
1590     void childrenChanged(const ChildChange&amp;) final;
1591 
1592     String nodeName() const final;
</pre>
<hr />
<pre>
1625     void setVisualUpdatesAllowed(ReadyState);
1626     void setVisualUpdatesAllowed(bool);
1627     void visualUpdatesSuppressionTimerFired();
1628 
1629     void addListenerType(ListenerType listenerType) { m_listenerTypes |= listenerType; }
1630 
1631     void didAssociateFormControlsTimerFired();
1632 
1633     void wheelEventHandlersChanged();
1634 
1635     HttpEquivPolicy httpEquivPolicy() const;
1636     AXObjectCache* existingAXObjectCacheSlow() const;
1637 
1638     // DOM Cookies caching.
1639     const String&amp; cachedDOMCookies() const { return m_cachedDOMCookies; }
1640     void setCachedDOMCookies(const String&amp;);
1641     bool isDOMCookieCacheValid() const { return m_cookieCacheExpiryTimer.isActive(); }
1642     void invalidateDOMCookieCache();
1643     void didLoadResourceSynchronously() final;
1644 



1645     bool canNavigateInternal(Frame&amp; targetFrame);
1646     bool isNavigationBlockedByThirdPartyIFrameRedirectBlocking(Frame&amp; targetFrame, const URL&amp; destinationURL);
1647 
1648 #if ENABLE(INTERSECTION_OBSERVER)
1649     void notifyIntersectionObserversTimerFired();
1650 #endif
1651 
1652 #if USE(QUICK_LOOK)
1653     bool shouldEnforceQuickLookSandbox() const;
1654     void applyQuickLookSandbox();
1655 #endif
1656 
1657     bool shouldEnforceHTTP09Sandbox() const;
1658 
1659     void platformSuspendOrStopActiveDOMObjects();
1660 
1661     bool isBodyPotentiallyScrollable(HTMLBodyElement&amp;);
1662 
<span class="line-added">1663     void didLogMessage(const WTFLogChannel&amp;, WTFLogLevel, Vector&lt;JSONLogValue&gt;&amp;&amp;) final;</span>
<span class="line-added">1664 </span>
1665     const Ref&lt;Settings&gt; m_settings;
1666 
1667     UniqueRef&lt;Quirks&gt; m_quirks;
1668 
<span class="line-modified">1669     std::unique_ptr&lt;Style::Resolver&gt; m_userAgentShadowTreeStyleResolver;</span>
1670 
1671     RefPtr&lt;DOMWindow&gt; m_domWindow;
1672     WeakPtr&lt;Document&gt; m_contextDocument;
1673 
1674     Ref&lt;CachedResourceLoader&gt; m_cachedResourceLoader;
1675     RefPtr&lt;DocumentParser&gt; m_parser;
1676 
1677     unsigned m_parserYieldTokenCount { 0 };
1678 
1679     // Document URLs.
1680     URL m_url; // Document.URL: The URL from which this document was retrieved.
1681     URL m_baseURL; // Node.baseURI: The URL to use when resolving relative URLs.
1682     URL m_baseURLOverride; // An alternative base URL that takes precedence over m_baseURL (but not m_baseElementURL).
1683     URL m_baseElementURL; // The URL set by the &lt;base&gt; element.
1684     URL m_cookieURL; // The URL to use for cookie access.
1685     URL m_firstPartyForCookies; // The policy URL for third-party cookie blocking.
1686     URL m_siteForCookies; // The policy URL for Same-Site cookies.
1687 
1688     // Document.documentURI:
1689     // Although URL-like, Document.documentURI can actually be set to any
</pre>
<hr />
<pre>
1766 
1767     RefPtr&lt;TextResourceDecoder&gt; m_decoder;
1768 
1769     HashSet&lt;LiveNodeList*&gt; m_listsInvalidatedAtDocument;
1770     HashSet&lt;HTMLCollection*&gt; m_collectionsInvalidatedAtDocument;
1771     unsigned m_nodeListAndCollectionCounts[numNodeListInvalidationTypes];
1772 
1773     RefPtr&lt;XPathEvaluator&gt; m_xpathEvaluator;
1774 
1775     std::unique_ptr&lt;SVGDocumentExtensions&gt; m_svgExtensions;
1776     HashSet&lt;SVGUseElement*&gt; m_svgUseElements;
1777 
1778 #if ENABLE(DARK_MODE_CSS)
1779     OptionSet&lt;ColorScheme&gt; m_colorScheme;
1780     bool m_allowsColorSchemeTransformations { true };
1781 #endif
1782 
1783     HashMap&lt;String, RefPtr&lt;HTMLCanvasElement&gt;&gt; m_cssCanvasElements;
1784 
1785     HashSet&lt;Element*&gt; m_documentSuspensionCallbackElements;
<span class="line-modified">1786 </span>
<span class="line-modified">1787 #if ENABLE(VIDEO)</span>
<span class="line-added">1788     HashSet&lt;HTMLMediaElement*&gt; m_mediaElements;</span>
<span class="line-added">1789 #endif</span>
<span class="line-added">1790 </span>
1791 #if ENABLE(VIDEO_TRACK)
<span class="line-modified">1792     HashSet&lt;HTMLMediaElement*&gt; m_captionPreferencesChangedElements;</span>
1793 #endif
1794 
1795     Element* m_mainArticleElement { nullptr };
1796     HashSet&lt;Element*&gt; m_articleElements;
1797 





1798     HashSet&lt;VisibilityChangeClient*&gt; m_visibilityStateCallbackClients;



1799 
1800     std::unique_ptr&lt;HashMap&lt;String, Element*, ASCIICaseInsensitiveHash&gt;&gt; m_accessKeyCache;
1801 
1802     std::unique_ptr&lt;ConstantPropertyMap&gt; m_constantPropertyMap;
1803 
1804     std::unique_ptr&lt;SelectorQueryCache&gt; m_selectorQueryCache;
1805 
1806     DocumentClassFlags m_documentClasses;
1807 
1808     RenderPtr&lt;RenderView&gt; m_renderView;

1809 
1810     HashSet&lt;MediaCanStartListener*&gt; m_mediaCanStartListeners;
1811 
1812 #if ENABLE(FULLSCREEN_API)
1813     UniqueRef&lt;FullscreenManager&gt; m_fullscreenManager;
1814 #endif
1815 
<span class="line-modified">1816     WeakHashSet&lt;HTMLImageElement&gt; m_dynamicMediaQueryDependentImages;</span>

1817 
1818 #if ENABLE(INTERSECTION_OBSERVER)
1819     Vector&lt;WeakPtr&lt;IntersectionObserver&gt;&gt; m_intersectionObservers;
1820     Vector&lt;WeakPtr&lt;IntersectionObserver&gt;&gt; m_intersectionObserversWithPendingNotifications;
1821     Timer m_intersectionObserversNotifyTimer;
1822     Timer m_intersectionObserversInitialUpdateTimer;
1823 #endif
1824 
1825 #if ENABLE(RESIZE_OBSERVER)
1826     Vector&lt;WeakPtr&lt;ResizeObserver&gt;&gt; m_resizeObservers;
1827 #endif
1828 
1829     Timer m_loadEventDelayTimer;
1830 
1831     ViewportArguments m_viewportArguments;
1832     OptionSet&lt;DisabledAdaptations&gt; m_disabledAdaptations;
1833 
1834     DocumentTiming m_documentTiming;
1835 
1836     RefPtr&lt;MediaQueryMatcher&gt; m_mediaQueryMatcher;
1837 
1838 #if ENABLE(TOUCH_EVENTS)
1839     std::unique_ptr&lt;EventTargetSet&gt; m_touchEventTargets;
1840 #endif
1841 #if PLATFORM(IOS_FAMILY) &amp;&amp; ENABLE(POINTER_EVENTS)
1842     bool m_mayHaveElementsWithNonAutoTouchAction { false };
1843 #endif
1844     std::unique_ptr&lt;EventTargetSet&gt; m_wheelEventTargets;
1845 
1846     MonotonicTime m_lastHandledUserGestureTimestamp;
1847     MonotonicTime m_userActivatedMediaFinishedPlayingTimestamp;
1848 
1849     void clearScriptedAnimationController();
1850     RefPtr&lt;ScriptedAnimationController&gt; m_scriptedAnimationController;
1851 
<span class="line-modified">1852     std::unique_ptr&lt;IdleCallbackController&gt; m_idleCallbackController;</span>


1853 
<span class="line-modified">1854 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)</span>

1855     std::unique_ptr&lt;DeviceMotionClient&gt; m_deviceMotionClient;
1856     std::unique_ptr&lt;DeviceMotionController&gt; m_deviceMotionController;
1857     std::unique_ptr&lt;DeviceOrientationClient&gt; m_deviceOrientationClient;
1858     std::unique_ptr&lt;DeviceOrientationController&gt; m_deviceOrientationController;
1859 #endif
<span class="line-added">1860 </span>
<span class="line-added">1861 #if ENABLE(DEVICE_ORIENTATION)</span>
1862     std::unique_ptr&lt;DeviceOrientationAndMotionAccessController&gt; m_deviceOrientationAndMotionAccessController;
1863 #endif
1864 
1865     GenericTaskQueue&lt;Timer&gt; m_logMessageTaskQueue;
1866 
1867     Timer m_pendingTasksTimer;
1868     Vector&lt;Task&gt; m_pendingTasks;
1869 
1870 #if ENABLE(TEXT_AUTOSIZING)
1871     std::unique_ptr&lt;TextAutoSizing&gt; m_textAutoSizing;
1872 #endif
1873 
<span class="line-added">1874     RefPtr&lt;HighlightMap&gt; m_highlightMap;</span>
<span class="line-added">1875 </span>
1876     Timer m_visualUpdatesSuppressionTimer;
1877 
1878     void clearSharedObjectPool();
1879     Timer m_sharedObjectPoolClearTimer;
1880 
1881     std::unique_ptr&lt;DocumentSharedObjectPool&gt; m_sharedObjectPool;
1882 
1883     typedef HashMap&lt;AtomString, std::unique_ptr&lt;Locale&gt;&gt; LocaleIdentifierToLocaleMap;
1884     LocaleIdentifierToLocaleMap m_localeCache;
1885 
1886     RefPtr&lt;Document&gt; m_templateDocument;
1887     WeakPtr&lt;Document&gt; m_templateDocumentHost; // Manually managed weakref (backpointer from m_templateDocument).
1888 
1889     Ref&lt;CSSFontSelector&gt; m_fontSelector;
1890 
1891     WeakHashSet&lt;MediaProducer&gt; m_audioProducers;
1892 
1893     HashSet&lt;ShadowRoot*&gt; m_inDocumentShadowRoots;
1894 
1895 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
</pre>
<hr />
<pre>
1928     int m_loadEventDelayCount { 0 };
1929     unsigned m_lastStyleUpdateSizeForTesting { 0 };
1930 
1931     // https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#throw-on-dynamic-markup-insertion-counter
1932     unsigned m_throwOnDynamicMarkupInsertionCount { 0 };
1933 
1934     // https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#ignore-opens-during-unload-counter
1935     unsigned m_ignoreOpensDuringUnloadCount { 0 };
1936 
1937     // https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#ignore-destructive-writes-counter
1938     unsigned m_ignoreDestructiveWriteCount { 0 };
1939 
1940     unsigned m_activeParserCount { 0 };
1941     unsigned m_styleRecalcCount { 0 };
1942 
1943     unsigned m_writeRecursionDepth { 0 };
1944 
1945     InheritedBool m_designMode { inherit };
1946     MediaProducer::MediaStateFlags m_mediaState { MediaProducer::IsNotPlaying };
1947     bool m_userHasInteractedWithMediaElement { false };
<span class="line-modified">1948     BackForwardCacheState m_backForwardCacheState { NotInBackForwardCache };</span>
1949     Optional&lt;ReferrerPolicy&gt; m_referrerPolicy;
1950     ReadyState m_readyState { Complete };
1951 
1952     MutationObserverOptions m_mutationObserverTypes { 0 };
1953 
<span class="line-added">1954     bool m_activeParserWasAborted { false };</span>
1955     bool m_writeRecursionIsTooDeep { false };
1956     bool m_wellFormed { false };
1957     bool m_createRenderers { true };
1958 
1959     bool m_hasNodesWithNonFinalStyle { false };
1960     bool m_hasNodesWithMissingStyle { false };
1961     // But sometimes you need to ignore pending stylesheet count to
1962     // force an immediate layout when requested by JS.
1963     bool m_ignorePendingStylesheets { false };
1964 
1965     bool m_hasElementUsingStyleBasedEditability { false };
1966     bool m_focusNavigationStartingNodeIsRemoved { false };
1967 
1968     bool m_printing { false };
1969     bool m_paginatedForScreen { false };
1970 
1971     DocumentCompatibilityMode m_compatibilityMode { DocumentCompatibilityMode::NoQuirksMode };
1972     bool m_compatibilityModeLocked { false }; // This is cheaper than making setCompatibilityMode virtual.
1973 
1974     // FIXME: Merge these 2 variables into an enum. Also, FrameLoader::m_didCallImplicitClose
1975     // is almost a duplication of this data, so that should probably get merged in too.
1976     // FIXME: Document::m_processingLoadEvent and DocumentLoader::m_wasOnloadDispatched are roughly the same
1977     // and should be merged.
1978     bool m_processingLoadEvent { false };
1979     bool m_loadEventFinished { false };
1980 
1981     bool m_visuallyOrdered { false };
1982     bool m_bParsing { false }; // FIXME: rename
1983 
1984     bool m_needsFullStyleRebuild { false };
1985     bool m_inStyleRecalc { false };

1986     bool m_inRenderTreeUpdate { false };
1987     bool m_isResolvingTreeStyle { false };
1988 
1989     bool m_gotoAnchorNeededAfterStylesheetsLoad { false };
1990     bool m_isDNSPrefetchEnabled { false };
1991     bool m_haveExplicitlyDisabledDNSPrefetch { false };
1992 
1993     bool m_isSynthesized { false };
1994     bool m_isNonRenderedPlaceholder { false };
1995 
1996     bool m_sawElementsInKnownNamespaces { false };
1997     bool m_isSrcdocDocument { false };
1998 
1999     bool m_hasInjectedPlugInsScript { false };
2000     bool m_renderTreeBeingDestroyed { false };
2001     bool m_hasPreparedForDestruction { false };
2002 
2003     bool m_hasStyleWithViewportUnits { false };
<span class="line-added">2004     bool m_needsDOMWindowResizeEvent { false };</span>
<span class="line-added">2005     bool m_needsVisualViewportResizeEvent { false };</span>
<span class="line-added">2006     bool m_needsVisualViewportScrollEvent { false };</span>
2007     bool m_isTimerThrottlingEnabled { false };
2008     bool m_isSuspended { false };
2009 
2010     bool m_scheduledTasksAreSuspended { false };
2011     bool m_visualUpdatesAllowed { true };
2012 
2013     bool m_areDeviceMotionAndOrientationUpdatesSuspended { false };
2014     bool m_userDidInteractWithPage { false };
<span class="line-modified">2015 #if ASSERT_ENABLED</span>
2016     bool m_inHitTesting { false };
2017 #endif
2018 
2019 #if ENABLE(TELEPHONE_NUMBER_DETECTION)
2020     bool m_isTelephoneNumberParsingAllowed { true };
2021 #endif
2022 
<span class="line-added">2023     struct PendingScrollEventTargetList;</span>
<span class="line-added">2024     std::unique_ptr&lt;PendingScrollEventTargetList&gt; m_pendingScrollEventTargetList;</span>
<span class="line-added">2025 </span>
2026 #if ENABLE(MEDIA_STREAM)
2027     HashSet&lt;HTMLMediaElement*&gt; m_mediaStreamStateChangeElements;
2028     String m_idHashSalt;
2029     bool m_hasHadCaptureMediaStreamTrack { false };
2030 #endif
2031 
<span class="line-modified">2032 #if ASSERT_ENABLED</span>
2033     bool m_didDispatchViewportPropertiesChanged { false };
2034 #endif
2035 
2036     OrientationNotifier m_orientationNotifier;

2037     mutable RefPtr&lt;Logger&gt; m_logger;
2038     RefPtr&lt;StringCallback&gt; m_consoleMessageListener;
2039 
2040     static bool hasEverCreatedAnAXObjectCache;
2041 
2042     RefPtr&lt;DocumentTimeline&gt; m_timeline;
<span class="line-added">2043     WeakHashSet&lt;DocumentTimeline&gt; m_timelines;</span>
<span class="line-added">2044 </span>
2045     DocumentIdentifier m_identifier;
2046 
<span class="line-added">2047     RefPtr&lt;WindowEventLoop&gt; m_eventLoop;</span>
<span class="line-added">2048     std::unique_ptr&lt;EventLoopTaskGroup&gt; m_documentTaskGroup;</span>
<span class="line-added">2049 </span>
2050 #if ENABLE(SERVICE_WORKER)
2051     RefPtr&lt;SWClientConnection&gt; m_serviceWorkerConnection;
2052 #endif
2053 


2054 #if ENABLE(RESOURCE_LOAD_STATISTICS)
2055     RegistrableDomain m_registrableDomainRequestedPageSpecificStorageAccessWithUserInteraction { };
2056     String m_referrerOverride;
2057 #endif
2058 
2059     CSSRegisteredCustomPropertySet m_CSSRegisteredPropertySet;
2060 
2061 #if ENABLE(CSS_PAINTING_API)
2062     RefPtr&lt;Worklet&gt; m_paintWorklet;
2063     HashMap&lt;String, Ref&lt;PaintWorkletGlobalScope&gt;&gt; m_paintWorkletGlobalScopes;
2064 #endif
<span class="line-modified">2065     unsigned m_numberOfRejectedSyncXHRs { 0 };</span>
2066     bool m_hasEvaluatedUserAgentScripts { false };
2067     bool m_isRunningUserScripts { false };
2068     bool m_mayBeDetachedFromFrame { true };
<span class="line-added">2069     bool m_shouldPreventEnteringBackForwardCacheForTesting { false };</span>
<span class="line-added">2070     bool m_hasLoadedThirdPartyScript { false };</span>
<span class="line-added">2071     bool m_hasLoadedThirdPartyFrame { false };</span>
2072 #if ENABLE(APPLE_PAY)
2073     bool m_hasStartedApplePaySession { false };
2074 #endif
2075 
2076     Ref&lt;UndoManager&gt; m_undoManager;
2077 #if PLATFORM(IOS_FAMILY)
2078     std::unique_ptr&lt;ContentChangeObserver&gt; m_contentChangeObserver;
2079     std::unique_ptr&lt;DOMTimerHoldingTank&gt; m_domTimerHoldingTank;
2080 #endif
2081 
<span class="line-added">2082 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added">2083     WeakPtr&lt;HTMLVideoElement&gt; m_pictureInPictureElement;</span>
<span class="line-added">2084 #endif</span>
<span class="line-added">2085 </span>
<span class="line-added">2086     std::unique_ptr&lt;TextManipulationController&gt; m_textManipulationController;</span>
<span class="line-added">2087 </span>
2088     HashMap&lt;Element*, ElementIdentifier&gt; m_identifiedElementsMap;
2089 };
2090 
2091 Element* eventTargetElementForDocument(Document*);
2092 
2093 inline TextEncoding Document::textEncoding() const
2094 {
2095     if (auto* decoder = this-&gt;decoder())
2096         return decoder-&gt;encoding();
2097     return TextEncoding();
2098 }
2099 
2100 inline const Document* Document::templateDocument() const
2101 {
2102     return m_templateDocumentHost ? this : m_templateDocument.get();
2103 }
2104 
2105 inline AXObjectCache* Document::existingAXObjectCache() const
2106 {
2107     if (!hasEverCreatedAnAXObjectCache)
2108         return nullptr;
2109     return existingAXObjectCacheSlow();
2110 }
2111 
<span class="line-modified">2112 inline Ref&lt;Document&gt; Document::create(const URL&amp; url)</span>
2113 {
<span class="line-modified">2114     return adoptRef(*new Document(nullptr, url));</span>
2115 }
2116 
2117 inline void Document::invalidateAccessKeyCache()
2118 {
2119     if (UNLIKELY(m_accessKeyCache))
2120         invalidateAccessKeyCacheSlowCase();
2121 }
2122 
2123 // These functions are here because they require the Document class definition and we want to inline them.
2124 
2125 inline ScriptExecutionContext* Node::scriptExecutionContext() const
2126 {
2127     return &amp;document().contextDocument();
2128 }
2129 





2130 } // namespace WebCore
2131 
2132 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::Document)
2133     static bool isType(const WebCore::ScriptExecutionContext&amp; context) { return context.isDocument(); }
2134     static bool isType(const WebCore::Node&amp; node) { return node.isDocumentNode(); }
2135 SPECIALIZE_TYPE_TRAITS_END()
</pre>
</td>
</tr>
</table>
<center><a href="Document.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Document.idl.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
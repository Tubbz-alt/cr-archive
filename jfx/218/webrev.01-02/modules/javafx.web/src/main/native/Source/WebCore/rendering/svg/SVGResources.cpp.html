<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/SVGResources.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  3  *
  4  * This library is free software; you can redistribute it and/or
  5  * modify it under the terms of the GNU Library General Public
  6  * License as published by the Free Software Foundation; either
  7  * version 2 of the License, or (at your option) any later version.
  8  *
  9  * This library is distributed in the hope that it will be useful,
 10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  * Library General Public License for more details.
 13  *
 14  * You should have received a copy of the GNU Library General Public License
 15  * along with this library; see the file COPYING.LIB.  If not, write to
 16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  * Boston, MA 02110-1301, USA.
 18  */
 19 
 20 #include &quot;config.h&quot;
 21 #include &quot;SVGResources.h&quot;
 22 
 23 #include &quot;ClipPathOperation.h&quot;
 24 #include &quot;FilterOperation.h&quot;
 25 #include &quot;RenderSVGResourceClipper.h&quot;
 26 #include &quot;RenderSVGResourceFilter.h&quot;
 27 #include &quot;RenderSVGResourceMarker.h&quot;
 28 #include &quot;RenderSVGResourceMasker.h&quot;
 29 #include &quot;RenderSVGRoot.h&quot;
 30 #include &quot;SVGGradientElement.h&quot;
 31 #include &quot;SVGNames.h&quot;
 32 #include &quot;SVGPatternElement.h&quot;
 33 #include &quot;SVGRenderStyle.h&quot;
 34 #include &quot;SVGURIReference.h&quot;
 35 
 36 #if ENABLE(TREE_DEBUGGING)
 37 #include &lt;stdio.h&gt;
 38 #endif
 39 
 40 namespace WebCore {
 41 
 42 SVGResources::SVGResources()
 43 {
 44 }
 45 
 46 static HashSet&lt;AtomString&gt;&amp; clipperFilterMaskerTags()
 47 {
 48     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; s_tagList;
 49     if (s_tagList.get().isEmpty()) {
 50         // &quot;container elements&quot;: http://www.w3.org/TR/SVG11/intro.html#TermContainerElement
 51         // &quot;graphics elements&quot; : http://www.w3.org/TR/SVG11/intro.html#TermGraphicsElement
 52         s_tagList.get().add(SVGNames::aTag-&gt;localName());
 53         s_tagList.get().add(SVGNames::circleTag-&gt;localName());
 54         s_tagList.get().add(SVGNames::ellipseTag-&gt;localName());
 55         s_tagList.get().add(SVGNames::glyphTag-&gt;localName());
 56         s_tagList.get().add(SVGNames::gTag-&gt;localName());
 57         s_tagList.get().add(SVGNames::imageTag-&gt;localName());
 58         s_tagList.get().add(SVGNames::lineTag-&gt;localName());
 59         s_tagList.get().add(SVGNames::markerTag-&gt;localName());
 60         s_tagList.get().add(SVGNames::maskTag-&gt;localName());
 61         s_tagList.get().add(SVGNames::missing_glyphTag-&gt;localName());
 62         s_tagList.get().add(SVGNames::pathTag-&gt;localName());
 63         s_tagList.get().add(SVGNames::polygonTag-&gt;localName());
 64         s_tagList.get().add(SVGNames::polylineTag-&gt;localName());
 65         s_tagList.get().add(SVGNames::rectTag-&gt;localName());
 66         s_tagList.get().add(SVGNames::svgTag-&gt;localName());
 67         s_tagList.get().add(SVGNames::textTag-&gt;localName());
 68         s_tagList.get().add(SVGNames::useTag-&gt;localName());
 69 
 70         // Not listed in the definitions is the clipPath element, the SVG spec says though:
 71         // The &quot;clipPath&quot; element or any of its children can specify property &quot;clip-path&quot;.
 72         // So we have to add clipPathTag here, otherwhise clip-path on clipPath will fail.
 73         // (Already mailed SVG WG, waiting for a solution)
 74         s_tagList.get().add(SVGNames::clipPathTag-&gt;localName());
 75 
 76         // Not listed in the definitions are the text content elements, though filter/clipper/masker on tspan/text/.. is allowed.
 77         // (Already mailed SVG WG, waiting for a solution)
 78         s_tagList.get().add(SVGNames::altGlyphTag-&gt;localName());
 79         s_tagList.get().add(SVGNames::textPathTag-&gt;localName());
 80         s_tagList.get().add(SVGNames::trefTag-&gt;localName());
 81         s_tagList.get().add(SVGNames::tspanTag-&gt;localName());
 82 
 83         // Not listed in the definitions is the foreignObject element, but clip-path
 84         // is a supported attribute.
 85         s_tagList.get().add(SVGNames::foreignObjectTag-&gt;localName());
 86 
 87         // Elements that we ignore, as it doesn&#39;t make any sense.
 88         // defs, pattern, switch (FIXME: Mail SVG WG about these)
 89         // symbol (is converted to a svg element, when referenced by use, we can safely ignore it.)
 90     }
 91 
 92     return s_tagList;
 93 }
 94 
 95 static HashSet&lt;AtomString&gt;&amp; markerTags()
 96 {
 97     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; s_tagList;
 98     if (s_tagList.get().isEmpty()) {
 99         s_tagList.get().add(SVGNames::lineTag-&gt;localName());
100         s_tagList.get().add(SVGNames::pathTag-&gt;localName());
101         s_tagList.get().add(SVGNames::polygonTag-&gt;localName());
102         s_tagList.get().add(SVGNames::polylineTag-&gt;localName());
103     }
104 
105     return s_tagList;
106 }
107 
108 static HashSet&lt;AtomString&gt;&amp; fillAndStrokeTags()
109 {
110     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; s_tagList;
111     if (s_tagList.get().isEmpty()) {
112         s_tagList.get().add(SVGNames::altGlyphTag-&gt;localName());
113         s_tagList.get().add(SVGNames::circleTag-&gt;localName());
114         s_tagList.get().add(SVGNames::ellipseTag-&gt;localName());
115         s_tagList.get().add(SVGNames::lineTag-&gt;localName());
116         s_tagList.get().add(SVGNames::pathTag-&gt;localName());
117         s_tagList.get().add(SVGNames::polygonTag-&gt;localName());
118         s_tagList.get().add(SVGNames::polylineTag-&gt;localName());
119         s_tagList.get().add(SVGNames::rectTag-&gt;localName());
120         s_tagList.get().add(SVGNames::textTag-&gt;localName());
121         s_tagList.get().add(SVGNames::textPathTag-&gt;localName());
122         s_tagList.get().add(SVGNames::trefTag-&gt;localName());
123         s_tagList.get().add(SVGNames::tspanTag-&gt;localName());
124     }
125 
126     return s_tagList;
127 }
128 
129 static HashSet&lt;AtomString&gt;&amp; chainableResourceTags()
130 {
131     static NeverDestroyed&lt;HashSet&lt;AtomString&gt;&gt; s_tagList;
132     if (s_tagList.get().isEmpty()) {
133         s_tagList.get().add(SVGNames::linearGradientTag-&gt;localName());
134         s_tagList.get().add(SVGNames::filterTag-&gt;localName());
135         s_tagList.get().add(SVGNames::patternTag-&gt;localName());
136         s_tagList.get().add(SVGNames::radialGradientTag-&gt;localName());
137     }
138 
139     return s_tagList;
140 }
141 
142 static inline String targetReferenceFromResource(SVGElement&amp; element)
143 {
144     String target;
145     if (is&lt;SVGPatternElement&gt;(element))
146         target = downcast&lt;SVGPatternElement&gt;(element).href();
147     else if (is&lt;SVGGradientElement&gt;(element))
148         target = downcast&lt;SVGGradientElement&gt;(element).href();
149     else if (is&lt;SVGFilterElement&gt;(element))
150         target = downcast&lt;SVGFilterElement&gt;(element).href();
151     else
152         ASSERT_NOT_REACHED();
153 
154     return SVGURIReference::fragmentIdentifierFromIRIString(target, element.document());
155 }
156 
157 static inline bool isChainableResource(const SVGElement&amp; element, const SVGElement&amp; linkedResource)
158 {
159     if (is&lt;SVGPatternElement&gt;(element))
160         return is&lt;SVGPatternElement&gt;(linkedResource);
161 
162     if (is&lt;SVGGradientElement&gt;(element))
163         return is&lt;SVGGradientElement&gt;(linkedResource);
164 
165     if (is&lt;SVGFilterElement&gt;(element))
166         return is&lt;SVGFilterElement&gt;(linkedResource);
167 
168     ASSERT_NOT_REACHED();
169     return false;
170 }
171 
172 static inline RenderSVGResourceContainer* paintingResourceFromSVGPaint(Document&amp; document, const SVGPaintType&amp; paintType, const String&amp; paintUri, AtomString&amp; id, bool&amp; hasPendingResource)
173 {
174     if (paintType != SVGPaintType::URI &amp;&amp; paintType != SVGPaintType::URIRGBColor &amp;&amp; paintType != SVGPaintType::URICurrentColor)
175         return nullptr;
176 
177     id = SVGURIReference::fragmentIdentifierFromIRIString(paintUri, document);
178     RenderSVGResourceContainer* container = getRenderSVGResourceContainerById(document, id);
179     if (!container) {
180         hasPendingResource = true;
181         return nullptr;
182     }
183 
184     RenderSVGResourceType resourceType = container-&gt;resourceType();
185     if (resourceType != PatternResourceType &amp;&amp; resourceType != LinearGradientResourceType &amp;&amp; resourceType != RadialGradientResourceType)
186         return nullptr;
187 
188     return container;
189 }
190 
191 static inline void registerPendingResource(SVGDocumentExtensions&amp; extensions, const AtomString&amp; id, SVGElement&amp; element)
192 {
193     extensions.addPendingResource(id, element);
194 }
195 
196 bool SVGResources::buildCachedResources(const RenderElement&amp; renderer, const RenderStyle&amp; style)
197 {
198     ASSERT(renderer.element());
199     ASSERT_WITH_SECURITY_IMPLICATION(renderer.element()-&gt;isSVGElement());
200 
201     if (!renderer.element())
202         return false;
203 
204     auto&amp; element = downcast&lt;SVGElement&gt;(*renderer.element());
205 
206     Document&amp; document = element.document();
207 
208     SVGDocumentExtensions&amp; extensions = document.accessSVGExtensions();
209 
210     const AtomString&amp; tagName = element.localName();
211     if (tagName.isNull())
212         return false;
213 
214     const SVGRenderStyle&amp; svgStyle = style.svgStyle();
215 
216     bool foundResources = false;
217     if (clipperFilterMaskerTags().contains(tagName)) {
218         if (is&lt;ReferenceClipPathOperation&gt;(style.clipPath())) {
219             // FIXME: -webkit-clip-path should support external resources
220             // https://bugs.webkit.org/show_bug.cgi?id=127032
221             auto&amp; clipPath = downcast&lt;ReferenceClipPathOperation&gt;(*style.clipPath());
222             AtomString id(clipPath.fragment());
223             if (setClipper(getRenderSVGResourceById&lt;RenderSVGResourceClipper&gt;(document, id)))
224                 foundResources = true;
225             else
226                 registerPendingResource(extensions, id, element);
227         }
228 
229         if (style.hasFilter()) {
230             const FilterOperations&amp; filterOperations = style.filter();
231             if (filterOperations.size() == 1) {
232                 const FilterOperation&amp; filterOperation = *filterOperations.at(0);
233                 if (filterOperation.type() == FilterOperation::REFERENCE) {
234                     const auto&amp; referenceFilterOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
235                     AtomString id = SVGURIReference::fragmentIdentifierFromIRIString(referenceFilterOperation.url(), element.document());
236                     if (setFilter(getRenderSVGResourceById&lt;RenderSVGResourceFilter&gt;(document, id)))
237                         foundResources = true;
238                     else
239                         registerPendingResource(extensions, id, element);
240                 }
241             }
242         }
243 
244         if (svgStyle.hasMasker()) {
245             AtomString id(svgStyle.maskerResource());
246             if (setMasker(getRenderSVGResourceById&lt;RenderSVGResourceMasker&gt;(document, id)))
247                 foundResources = true;
248             else
249                 registerPendingResource(extensions, id, element);
250         }
251     }
252 
253     if (markerTags().contains(tagName) &amp;&amp; svgStyle.hasMarkers()) {
254         AtomString markerStartId(svgStyle.markerStartResource());
255         if (setMarkerStart(getRenderSVGResourceById&lt;RenderSVGResourceMarker&gt;(document, markerStartId)))
256             foundResources = true;
257         else
258             registerPendingResource(extensions, markerStartId, element);
259 
260         AtomString markerMidId(svgStyle.markerMidResource());
261         if (setMarkerMid(getRenderSVGResourceById&lt;RenderSVGResourceMarker&gt;(document, markerMidId)))
262             foundResources = true;
263         else
264             registerPendingResource(extensions, markerMidId, element);
265 
266         AtomString markerEndId(svgStyle.markerEndResource());
267         if (setMarkerEnd(getRenderSVGResourceById&lt;RenderSVGResourceMarker&gt;(document, markerEndId)))
268             foundResources = true;
269         else
270             registerPendingResource(extensions, markerEndId, element);
271     }
272 
273     if (fillAndStrokeTags().contains(tagName)) {
274         if (svgStyle.hasFill()) {
275             bool hasPendingResource = false;
276             AtomString id;
277             if (setFill(paintingResourceFromSVGPaint(document, svgStyle.fillPaintType(), svgStyle.fillPaintUri(), id, hasPendingResource)))
278                 foundResources = true;
279             else if (hasPendingResource)
280                 registerPendingResource(extensions, id, element);
281         }
282 
283         if (svgStyle.hasStroke()) {
284             bool hasPendingResource = false;
285             AtomString id;
286             if (setStroke(paintingResourceFromSVGPaint(document, svgStyle.strokePaintType(), svgStyle.strokePaintUri(), id, hasPendingResource)))
287                 foundResources = true;
288             else if (hasPendingResource)
289                 registerPendingResource(extensions, id, element);
290         }
291     }
292 
293     if (chainableResourceTags().contains(tagName)) {
294         AtomString id(targetReferenceFromResource(element));
295         auto* linkedResource = getRenderSVGResourceContainerById(document, id);
296         if (!linkedResource)
297             registerPendingResource(extensions, id, element);
298         else if (isChainableResource(element, linkedResource-&gt;element())) {
299             setLinkedResource(linkedResource);
300             foundResources = true;
301         }
302     }
303 
304     return foundResources;
305 }
306 
307 void SVGResources::layoutDifferentRootIfNeeded(const RenderSVGRoot* svgRoot)
308 {
309     if (clipper() &amp;&amp; svgRoot != SVGRenderSupport::findTreeRootObject(*clipper()))
310         clipper()-&gt;layoutIfNeeded();
311 
312     if (masker() &amp;&amp; svgRoot != SVGRenderSupport::findTreeRootObject(*masker()))
313         masker()-&gt;layoutIfNeeded();
314 
315     if (filter() &amp;&amp; svgRoot != SVGRenderSupport::findTreeRootObject(*filter()))
316         filter()-&gt;layoutIfNeeded();
317 
318     if (markerStart() &amp;&amp; svgRoot != SVGRenderSupport::findTreeRootObject(*markerStart()))
319         markerStart()-&gt;layoutIfNeeded();
320 
321     if (markerMid() &amp;&amp; svgRoot != SVGRenderSupport::findTreeRootObject(*markerMid()))
322         markerMid()-&gt;layoutIfNeeded();
323 
324     if (markerEnd() &amp;&amp; svgRoot != SVGRenderSupport::findTreeRootObject(*markerEnd()))
325         markerEnd()-&gt;layoutIfNeeded();
326 }
327 
328 bool SVGResources::markerReverseStart() const
329 {
330     return m_markerData
331         &amp;&amp; m_markerData-&gt;markerStart
332         &amp;&amp; m_markerData-&gt;markerStart-&gt;markerElement().orientType() == SVGMarkerOrientAutoStartReverse;
333 }
334 
335 void SVGResources::removeClientFromCache(RenderElement&amp; renderer, bool markForInvalidation) const
336 {
337     if (isEmpty())
338         return;
339 
340     if (m_linkedResource) {
341         ASSERT(!m_clipperFilterMaskerData);
342         ASSERT(!m_markerData);
343         ASSERT(!m_fillStrokeData);
344         m_linkedResource-&gt;removeClientFromCache(renderer, markForInvalidation);
345         return;
346     }
347 
348     if (m_clipperFilterMaskerData) {
349         if (m_clipperFilterMaskerData-&gt;clipper)
350             m_clipperFilterMaskerData-&gt;clipper-&gt;removeClientFromCache(renderer, markForInvalidation);
351         if (m_clipperFilterMaskerData-&gt;filter)
352             m_clipperFilterMaskerData-&gt;filter-&gt;removeClientFromCache(renderer, markForInvalidation);
353         if (m_clipperFilterMaskerData-&gt;masker)
354             m_clipperFilterMaskerData-&gt;masker-&gt;removeClientFromCache(renderer, markForInvalidation);
355     }
356 
357     if (m_markerData) {
358         if (m_markerData-&gt;markerStart)
359             m_markerData-&gt;markerStart-&gt;removeClientFromCache(renderer, markForInvalidation);
360         if (m_markerData-&gt;markerMid)
361             m_markerData-&gt;markerMid-&gt;removeClientFromCache(renderer, markForInvalidation);
362         if (m_markerData-&gt;markerEnd)
363             m_markerData-&gt;markerEnd-&gt;removeClientFromCache(renderer, markForInvalidation);
364     }
365 
366     if (m_fillStrokeData) {
367         if (m_fillStrokeData-&gt;fill)
368             m_fillStrokeData-&gt;fill-&gt;removeClientFromCache(renderer, markForInvalidation);
369         if (m_fillStrokeData-&gt;stroke)
370             m_fillStrokeData-&gt;stroke-&gt;removeClientFromCache(renderer, markForInvalidation);
371     }
372 }
373 
374 bool SVGResources::resourceDestroyed(RenderSVGResourceContainer&amp; resource)
375 {
376     if (isEmpty())
377         return false;
378 
379     if (m_linkedResource == &amp;resource) {
380         ASSERT(!m_clipperFilterMaskerData);
381         ASSERT(!m_markerData);
382         ASSERT(!m_fillStrokeData);
383         m_linkedResource-&gt;removeAllClientsFromCache();
384         m_linkedResource = nullptr;
385         return true;
386     }
387 
388     bool foundResources = false;
389     switch (resource.resourceType()) {
390     case MaskerResourceType:
391         if (!m_clipperFilterMaskerData)
392             break;
393         if (m_clipperFilterMaskerData-&gt;masker == &amp;resource) {
394             m_clipperFilterMaskerData-&gt;masker-&gt;removeAllClientsFromCache();
395             m_clipperFilterMaskerData-&gt;masker = nullptr;
396             foundResources = true;
397         }
398         break;
399     case MarkerResourceType:
400         if (!m_markerData)
401             break;
402         if (m_markerData-&gt;markerStart == &amp;resource) {
403             m_markerData-&gt;markerStart-&gt;removeAllClientsFromCache();
404             m_markerData-&gt;markerStart = nullptr;
405             foundResources = true;
406         }
407         if (m_markerData-&gt;markerMid == &amp;resource) {
408             m_markerData-&gt;markerMid-&gt;removeAllClientsFromCache();
409             m_markerData-&gt;markerMid = nullptr;
410             foundResources = true;
411         }
412         if (m_markerData-&gt;markerEnd == &amp;resource) {
413             m_markerData-&gt;markerEnd-&gt;removeAllClientsFromCache();
414             m_markerData-&gt;markerEnd = nullptr;
415             foundResources = true;
416         }
417         break;
418     case PatternResourceType:
419     case LinearGradientResourceType:
420     case RadialGradientResourceType:
421         if (!m_fillStrokeData)
422             break;
423         if (m_fillStrokeData-&gt;fill == &amp;resource) {
424             m_fillStrokeData-&gt;fill-&gt;removeAllClientsFromCache();
425             m_fillStrokeData-&gt;fill = nullptr;
426             foundResources = true;
427         }
428         if (m_fillStrokeData-&gt;stroke == &amp;resource) {
429             m_fillStrokeData-&gt;stroke-&gt;removeAllClientsFromCache();
430             m_fillStrokeData-&gt;stroke = nullptr;
431             foundResources = true;
432         }
433         break;
434     case FilterResourceType:
435         if (!m_clipperFilterMaskerData)
436             break;
437         if (m_clipperFilterMaskerData-&gt;filter == &amp;resource) {
438             m_clipperFilterMaskerData-&gt;filter-&gt;removeAllClientsFromCache();
439             m_clipperFilterMaskerData-&gt;filter = nullptr;
440             foundResources = true;
441         }
442         break;
443     case ClipperResourceType:
444         if (!m_clipperFilterMaskerData)
445             break;
446         if (m_clipperFilterMaskerData-&gt;clipper == &amp;resource) {
447             m_clipperFilterMaskerData-&gt;clipper-&gt;removeAllClientsFromCache();
448             m_clipperFilterMaskerData-&gt;clipper = nullptr;
449             foundResources = true;
450         }
451         break;
452     case SolidColorResourceType:
453         ASSERT_NOT_REACHED();
454     }
455     return foundResources;
456 }
457 
458 void SVGResources::buildSetOfResources(HashSet&lt;RenderSVGResourceContainer*&gt;&amp; set)
459 {
460     if (isEmpty())
461         return;
462 
463     if (m_linkedResource) {
464         ASSERT(!m_clipperFilterMaskerData);
465         ASSERT(!m_markerData);
466         ASSERT(!m_fillStrokeData);
467         set.add(m_linkedResource);
468         return;
469     }
470 
471     if (m_clipperFilterMaskerData) {
472         if (m_clipperFilterMaskerData-&gt;clipper)
473             set.add(m_clipperFilterMaskerData-&gt;clipper);
474         if (m_clipperFilterMaskerData-&gt;filter)
475             set.add(m_clipperFilterMaskerData-&gt;filter);
476         if (m_clipperFilterMaskerData-&gt;masker)
477             set.add(m_clipperFilterMaskerData-&gt;masker);
478     }
479 
480     if (m_markerData) {
481         if (m_markerData-&gt;markerStart)
482             set.add(m_markerData-&gt;markerStart);
483         if (m_markerData-&gt;markerMid)
484             set.add(m_markerData-&gt;markerMid);
485         if (m_markerData-&gt;markerEnd)
486             set.add(m_markerData-&gt;markerEnd);
487     }
488 
489     if (m_fillStrokeData) {
490         if (m_fillStrokeData-&gt;fill)
491             set.add(m_fillStrokeData-&gt;fill);
492         if (m_fillStrokeData-&gt;stroke)
493             set.add(m_fillStrokeData-&gt;stroke);
494     }
495 }
496 
497 bool SVGResources::setClipper(RenderSVGResourceClipper* clipper)
498 {
499     if (!clipper)
500         return false;
501 
502     ASSERT(clipper-&gt;resourceType() == ClipperResourceType);
503 
504     if (!m_clipperFilterMaskerData)
505         m_clipperFilterMaskerData = makeUnique&lt;ClipperFilterMaskerData&gt;();
506 
507     m_clipperFilterMaskerData-&gt;clipper = clipper;
508     return true;
509 }
510 
511 void SVGResources::resetClipper()
512 {
513     ASSERT(m_clipperFilterMaskerData);
514     ASSERT(m_clipperFilterMaskerData-&gt;clipper);
515     m_clipperFilterMaskerData-&gt;clipper = nullptr;
516 }
517 
518 bool SVGResources::setFilter(RenderSVGResourceFilter* filter)
519 {
520     if (!filter)
521         return false;
522 
523     ASSERT(filter-&gt;resourceType() == FilterResourceType);
524 
525     if (!m_clipperFilterMaskerData)
526         m_clipperFilterMaskerData = makeUnique&lt;ClipperFilterMaskerData&gt;();
527 
528     m_clipperFilterMaskerData-&gt;filter = filter;
529     return true;
530 }
531 
532 void SVGResources::resetFilter()
533 {
534     ASSERT(m_clipperFilterMaskerData);
535     ASSERT(m_clipperFilterMaskerData-&gt;filter);
536     m_clipperFilterMaskerData-&gt;filter = nullptr;
537 }
538 
539 bool SVGResources::setMarkerStart(RenderSVGResourceMarker* markerStart)
540 {
541     if (!markerStart)
542         return false;
543 
544     ASSERT(markerStart-&gt;resourceType() == MarkerResourceType);
545 
546     if (!m_markerData)
547         m_markerData = makeUnique&lt;MarkerData&gt;();
548 
549     m_markerData-&gt;markerStart = markerStart;
550     return true;
551 }
552 
553 void SVGResources::resetMarkerStart()
554 {
555     ASSERT(m_markerData);
556     ASSERT(m_markerData-&gt;markerStart);
557     m_markerData-&gt;markerStart = nullptr;
558 }
559 
560 bool SVGResources::setMarkerMid(RenderSVGResourceMarker* markerMid)
561 {
562     if (!markerMid)
563         return false;
564 
565     ASSERT(markerMid-&gt;resourceType() == MarkerResourceType);
566 
567     if (!m_markerData)
568         m_markerData = makeUnique&lt;MarkerData&gt;();
569 
570     m_markerData-&gt;markerMid = markerMid;
571     return true;
572 }
573 
574 void SVGResources::resetMarkerMid()
575 {
576     ASSERT(m_markerData);
577     ASSERT(m_markerData-&gt;markerMid);
578     m_markerData-&gt;markerMid = nullptr;
579 }
580 
581 bool SVGResources::setMarkerEnd(RenderSVGResourceMarker* markerEnd)
582 {
583     if (!markerEnd)
584         return false;
585 
586     ASSERT(markerEnd-&gt;resourceType() == MarkerResourceType);
587 
588     if (!m_markerData)
589         m_markerData = makeUnique&lt;MarkerData&gt;();
590 
591     m_markerData-&gt;markerEnd = markerEnd;
592     return true;
593 }
594 
595 void SVGResources::resetMarkerEnd()
596 {
597     ASSERT(m_markerData);
598     ASSERT(m_markerData-&gt;markerEnd);
599     m_markerData-&gt;markerEnd = nullptr;
600 }
601 
602 bool SVGResources::setMasker(RenderSVGResourceMasker* masker)
603 {
604     if (!masker)
605         return false;
606 
607     ASSERT(masker-&gt;resourceType() == MaskerResourceType);
608 
609     if (!m_clipperFilterMaskerData)
610         m_clipperFilterMaskerData = makeUnique&lt;ClipperFilterMaskerData&gt;();
611 
612     m_clipperFilterMaskerData-&gt;masker = masker;
613     return true;
614 }
615 
616 void SVGResources::resetMasker()
617 {
618     ASSERT(m_clipperFilterMaskerData);
619     ASSERT(m_clipperFilterMaskerData-&gt;masker);
620     m_clipperFilterMaskerData-&gt;masker = nullptr;
621 }
622 
623 bool SVGResources::setFill(RenderSVGResourceContainer* fill)
624 {
625     if (!fill)
626         return false;
627 
628     ASSERT(fill-&gt;resourceType() == PatternResourceType
629            || fill-&gt;resourceType() == LinearGradientResourceType
630            || fill-&gt;resourceType() == RadialGradientResourceType);
631 
632     if (!m_fillStrokeData)
633         m_fillStrokeData = makeUnique&lt;FillStrokeData&gt;();
634 
635     m_fillStrokeData-&gt;fill = fill;
636     return true;
637 }
638 
639 void SVGResources::resetFill()
640 {
641     ASSERT(m_fillStrokeData);
642     ASSERT(m_fillStrokeData-&gt;fill);
643     m_fillStrokeData-&gt;fill = nullptr;
644 }
645 
646 bool SVGResources::setStroke(RenderSVGResourceContainer* stroke)
647 {
648     if (!stroke)
649         return false;
650 
651     ASSERT(stroke-&gt;resourceType() == PatternResourceType
652            || stroke-&gt;resourceType() == LinearGradientResourceType
653            || stroke-&gt;resourceType() == RadialGradientResourceType);
654 
655     if (!m_fillStrokeData)
656         m_fillStrokeData = makeUnique&lt;FillStrokeData&gt;();
657 
658     m_fillStrokeData-&gt;stroke = stroke;
659     return true;
660 }
661 
662 void SVGResources::resetStroke()
663 {
664     ASSERT(m_fillStrokeData);
665     ASSERT(m_fillStrokeData-&gt;stroke);
666     m_fillStrokeData-&gt;stroke = nullptr;
667 }
668 
669 bool SVGResources::setLinkedResource(RenderSVGResourceContainer* linkedResource)
670 {
671     if (!linkedResource)
672         return false;
673 
674     m_linkedResource = linkedResource;
675     return true;
676 }
677 
678 void SVGResources::resetLinkedResource()
679 {
680     ASSERT(m_linkedResource);
681     m_linkedResource = nullptr;
682 }
683 
684 #if ENABLE(TREE_DEBUGGING)
685 void SVGResources::dump(const RenderObject* object)
686 {
687     ASSERT(object);
688     ASSERT(object-&gt;node());
689 
690     fprintf(stderr, &quot;-&gt; this=%p, SVGResources(renderer=%p, node=%p)\n&quot;, this, object, object-&gt;node());
691     fprintf(stderr, &quot; | DOM Tree:\n&quot;);
692     object-&gt;node()-&gt;showTreeForThis();
693 
694     fprintf(stderr, &quot;\n | List of resources:\n&quot;);
695     if (m_clipperFilterMaskerData) {
696         if (RenderSVGResourceClipper* clipper = m_clipperFilterMaskerData-&gt;clipper)
697             fprintf(stderr, &quot; |-&gt; Clipper    : %p (node=%p)\n&quot;, clipper, &amp;clipper-&gt;clipPathElement());
698         if (RenderSVGResourceFilter* filter = m_clipperFilterMaskerData-&gt;filter)
699             fprintf(stderr, &quot; |-&gt; Filter     : %p (node=%p)\n&quot;, filter, &amp;filter-&gt;filterElement());
700         if (RenderSVGResourceMasker* masker = m_clipperFilterMaskerData-&gt;masker)
701             fprintf(stderr, &quot; |-&gt; Masker     : %p (node=%p)\n&quot;, masker, &amp;masker-&gt;maskElement());
702     }
703 
704     if (m_markerData) {
705         if (RenderSVGResourceMarker* markerStart = m_markerData-&gt;markerStart)
706             fprintf(stderr, &quot; |-&gt; MarkerStart: %p (node=%p)\n&quot;, markerStart, &amp;markerStart-&gt;markerElement());
707         if (RenderSVGResourceMarker* markerMid = m_markerData-&gt;markerMid)
708             fprintf(stderr, &quot; |-&gt; MarkerMid  : %p (node=%p)\n&quot;, markerMid, &amp;markerMid-&gt;markerElement());
709         if (RenderSVGResourceMarker* markerEnd = m_markerData-&gt;markerEnd)
710             fprintf(stderr, &quot; |-&gt; MarkerEnd  : %p (node=%p)\n&quot;, markerEnd, &amp;markerEnd-&gt;markerElement());
711     }
712 
713     if (m_fillStrokeData) {
714         if (RenderSVGResourceContainer* fill = m_fillStrokeData-&gt;fill)
715             fprintf(stderr, &quot; |-&gt; Fill       : %p (node=%p)\n&quot;, fill, &amp;fill-&gt;element());
716         if (RenderSVGResourceContainer* stroke = m_fillStrokeData-&gt;stroke)
717             fprintf(stderr, &quot; |-&gt; Stroke     : %p (node=%p)\n&quot;, stroke, &amp;stroke-&gt;element());
718     }
719 
720     if (m_linkedResource)
721         fprintf(stderr, &quot; |-&gt; xlink:href : %p (node=%p)\n&quot;, m_linkedResource, &amp;m_linkedResource-&gt;element());
722 }
723 #endif
724 
725 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/ElementData.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ElementData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ElementDescendantIterator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/ElementData.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 58 };
 59 
 60 class AttributeIteratorAccessor {
 61 public:
 62     AttributeIteratorAccessor(const Attribute* array, unsigned size)
 63         : m_array(array)
 64         , m_size(size)
 65     {
 66     }
 67 
 68     AttributeConstIterator begin() const { return AttributeConstIterator(m_array, 0); }
 69     AttributeConstIterator end() const { return AttributeConstIterator(m_array, m_size); }
 70 
 71     unsigned attributeCount() const { return m_size; }
 72 
 73 private:
 74     const Attribute* m_array;
 75     unsigned m_size;
 76 };
 77 

 78 class ElementData : public RefCounted&lt;ElementData&gt; {
<span class="line-modified"> 79     WTF_MAKE_FAST_ALLOCATED;</span>
 80 public:
 81     // Override RefCounted&#39;s deref() to ensure operator delete is called on
 82     // the appropriate subclass type.
 83     void deref();
 84 
 85     static const unsigned attributeNotFound = static_cast&lt;unsigned&gt;(-1);
 86 
 87     void setClassNames(const SpaceSplitString&amp; classNames) const { m_classNames = classNames; }
 88     const SpaceSplitString&amp; classNames() const { return m_classNames; }
 89     static ptrdiff_t classNamesMemoryOffset() { return OBJECT_OFFSETOF(ElementData, m_classNames); }
 90 
 91     const AtomString&amp; idForStyleResolution() const { return m_idForStyleResolution; }
 92     static ptrdiff_t idForStyleResolutionMemoryOffset() { return OBJECT_OFFSETOF(ElementData, m_idForStyleResolution); }
 93     void setIdForStyleResolution(const AtomString&amp; newId) const { m_idForStyleResolution = newId; }
 94 
 95     const StyleProperties* inlineStyle() const { return m_inlineStyle.get(); }
 96     const StyleProperties* presentationAttributeStyle() const;
 97 
 98     unsigned length() const;
 99     bool isEmpty() const { return !length(); }
</pre>
<hr />
<pre>
166 private:
167     friend class Element;
168     friend class StyledElement;
169     friend class ShareableElementData;
170     friend class UniqueElementData;
171     friend class SVGElement;
172 
173     void destroy();
174 
175     const Attribute* attributeBase() const;
176     const Attribute* findAttributeByName(const AtomString&amp; name, bool shouldIgnoreAttributeCase) const;
177 
178     Ref&lt;UniqueElementData&gt; makeUniqueCopy() const;
179 };
180 
181 #if COMPILER(MSVC)
182 #pragma warning(push)
183 #pragma warning(disable: 4200) // Disable &quot;zero-sized array in struct/union&quot; warning
184 #endif
185 

186 class ShareableElementData : public ElementData {

187 public:
188     static Ref&lt;ShareableElementData&gt; createWithAttributes(const Vector&lt;Attribute&gt;&amp;);
189 
190     explicit ShareableElementData(const Vector&lt;Attribute&gt;&amp;);
191     explicit ShareableElementData(const UniqueElementData&amp;);
192     ~ShareableElementData();
193 
194     static ptrdiff_t attributeArrayMemoryOffset() { return OBJECT_OFFSETOF(ShareableElementData, m_attributeArray); }
195 
196     Attribute m_attributeArray[0];
197 };
198 
199 #if COMPILER(MSVC)
200 #pragma warning(pop)
201 #endif
202 
203 class UniqueElementData : public ElementData {
204 public:
205     static Ref&lt;UniqueElementData&gt; create();
206     Ref&lt;ShareableElementData&gt; makeShareableCopy() const;
</pre>
</td>
<td>
<hr />
<pre>
 58 };
 59 
 60 class AttributeIteratorAccessor {
 61 public:
 62     AttributeIteratorAccessor(const Attribute* array, unsigned size)
 63         : m_array(array)
 64         , m_size(size)
 65     {
 66     }
 67 
 68     AttributeConstIterator begin() const { return AttributeConstIterator(m_array, 0); }
 69     AttributeConstIterator end() const { return AttributeConstIterator(m_array, m_size); }
 70 
 71     unsigned attributeCount() const { return m_size; }
 72 
 73 private:
 74     const Attribute* m_array;
 75     unsigned m_size;
 76 };
 77 
<span class="line-added"> 78 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ElementData);</span>
 79 class ElementData : public RefCounted&lt;ElementData&gt; {
<span class="line-modified"> 80     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(ElementData);</span>
 81 public:
 82     // Override RefCounted&#39;s deref() to ensure operator delete is called on
 83     // the appropriate subclass type.
 84     void deref();
 85 
 86     static const unsigned attributeNotFound = static_cast&lt;unsigned&gt;(-1);
 87 
 88     void setClassNames(const SpaceSplitString&amp; classNames) const { m_classNames = classNames; }
 89     const SpaceSplitString&amp; classNames() const { return m_classNames; }
 90     static ptrdiff_t classNamesMemoryOffset() { return OBJECT_OFFSETOF(ElementData, m_classNames); }
 91 
 92     const AtomString&amp; idForStyleResolution() const { return m_idForStyleResolution; }
 93     static ptrdiff_t idForStyleResolutionMemoryOffset() { return OBJECT_OFFSETOF(ElementData, m_idForStyleResolution); }
 94     void setIdForStyleResolution(const AtomString&amp; newId) const { m_idForStyleResolution = newId; }
 95 
 96     const StyleProperties* inlineStyle() const { return m_inlineStyle.get(); }
 97     const StyleProperties* presentationAttributeStyle() const;
 98 
 99     unsigned length() const;
100     bool isEmpty() const { return !length(); }
</pre>
<hr />
<pre>
167 private:
168     friend class Element;
169     friend class StyledElement;
170     friend class ShareableElementData;
171     friend class UniqueElementData;
172     friend class SVGElement;
173 
174     void destroy();
175 
176     const Attribute* attributeBase() const;
177     const Attribute* findAttributeByName(const AtomString&amp; name, bool shouldIgnoreAttributeCase) const;
178 
179     Ref&lt;UniqueElementData&gt; makeUniqueCopy() const;
180 };
181 
182 #if COMPILER(MSVC)
183 #pragma warning(push)
184 #pragma warning(disable: 4200) // Disable &quot;zero-sized array in struct/union&quot; warning
185 #endif
186 
<span class="line-added">187 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ShareableElementData);</span>
188 class ShareableElementData : public ElementData {
<span class="line-added">189     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(ShareableElementData);</span>
190 public:
191     static Ref&lt;ShareableElementData&gt; createWithAttributes(const Vector&lt;Attribute&gt;&amp;);
192 
193     explicit ShareableElementData(const Vector&lt;Attribute&gt;&amp;);
194     explicit ShareableElementData(const UniqueElementData&amp;);
195     ~ShareableElementData();
196 
197     static ptrdiff_t attributeArrayMemoryOffset() { return OBJECT_OFFSETOF(ShareableElementData, m_attributeArray); }
198 
199     Attribute m_attributeArray[0];
200 };
201 
202 #if COMPILER(MSVC)
203 #pragma warning(pop)
204 #endif
205 
206 class UniqueElementData : public ElementData {
207 public:
208     static Ref&lt;UniqueElementData&gt; create();
209     Ref&lt;ShareableElementData&gt; makeShareableCopy() const;
</pre>
</td>
</tr>
</table>
<center><a href="ElementData.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ElementDescendantIterator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
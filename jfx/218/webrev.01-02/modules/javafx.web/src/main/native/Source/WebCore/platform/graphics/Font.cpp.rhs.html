<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Font.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2005, 2008, 2010, 2015 Apple Inc. All rights reserved.
  3  * Copyright (C) 2006 Alexey Proskuryakov
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 15  *     its contributors may be used to endorse or promote products derived
 16  *     from this software without specific prior written permission.
 17  *
 18  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 19  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 20  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 21  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 22  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 23  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 24  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 25  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 26  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 27  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 28  */
 29 
 30 #include &quot;config.h&quot;
 31 #include &quot;Font.h&quot;
 32 
 33 #if PLATFORM(COCOA)
 34 #include &lt;pal/spi/cocoa/CoreTextSPI.h&gt;
 35 #endif
<a name="1" id="anc1"></a><span class="line-added"> 36 #include &quot;CachedFont.h&quot;</span>
 37 #include &quot;CharacterProperties.h&quot;
 38 #include &quot;FontCache.h&quot;
 39 #include &quot;FontCascade.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 40 #include &quot;FontCustomPlatformData.h&quot;</span>
 41 #include &quot;OpenTypeMathData.h&quot;
<a name="3" id="anc3"></a><span class="line-added"> 42 #include &quot;SharedBuffer.h&quot;</span>
 43 #include &lt;wtf/MathExtras.h&gt;
 44 #include &lt;wtf/NeverDestroyed.h&gt;
 45 #include &lt;wtf/text/AtomStringHash.h&gt;
 46 
 47 #if ENABLE(OPENTYPE_VERTICAL)
 48 #include &quot;OpenTypeVerticalData.h&quot;
 49 #endif
 50 
 51 namespace WebCore {
 52 
 53 unsigned GlyphPage::s_count = 0;
 54 
 55 const float smallCapsFontSizeMultiplier = 0.7f;
 56 const float emphasisMarkFontSizeMultiplier = 0.5f;
 57 
<a name="4" id="anc4"></a><span class="line-added"> 58 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(Font);</span>
<span class="line-added"> 59 </span>
 60 Font::Font(const FontPlatformData&amp; platformData, Origin origin, Interstitial interstitial, Visibility visibility, OrientationFallback orientationFallback)
 61     : m_platformData(platformData)
 62     , m_origin(origin)
 63     , m_visibility(visibility)
 64     , m_treatAsFixedPitch(false)
 65     , m_isInterstitial(interstitial == Interstitial::Yes)
 66     , m_isTextOrientationFallback(orientationFallback == OrientationFallback::Yes)
 67     , m_isBrokenIdeographFallback(false)
 68     , m_hasVerticalGlyphs(false)
 69     , m_isUsedInSystemFallbackCache(false)
<a name="5" id="anc5"></a><span class="line-added"> 70     , m_allowsAntialiasing(true)</span>
 71 #if PLATFORM(IOS_FAMILY)
 72     , m_shouldNotBeUsedForArabic(false)
 73 #endif
 74 {
 75     platformInit();
 76     platformGlyphInit();
 77     platformCharWidthInit();
 78 #if ENABLE(OPENTYPE_VERTICAL)
 79     if (platformData.orientation() == FontOrientation::Vertical &amp;&amp; orientationFallback == OrientationFallback::No) {
 80         m_verticalData = FontCache::singleton().verticalData(platformData);
 81         m_hasVerticalGlyphs = m_verticalData.get() &amp;&amp; m_verticalData-&gt;hasVerticalMetrics();
 82     }
 83 #endif
 84 }
 85 
 86 // Estimates of avgCharWidth and maxCharWidth for platforms that don&#39;t support accessing these values from the font.
 87 void Font::initCharWidths()
 88 {
 89     auto* glyphPageZero = glyphPage(GlyphPage::pageNumberForCodePoint(&#39;0&#39;));
 90 
 91     // Treat the width of a &#39;0&#39; as the avgCharWidth.
 92     if (m_avgCharWidth &lt;= 0.f &amp;&amp; glyphPageZero) {
 93         Glyph digitZeroGlyph = glyphPageZero-&gt;glyphDataForCharacter(&#39;0&#39;).glyph;
 94         if (digitZeroGlyph)
 95             m_avgCharWidth = widthForGlyph(digitZeroGlyph);
 96     }
 97 
 98     // If we can&#39;t retrieve the width of a &#39;0&#39;, fall back to the x height.
 99     if (m_avgCharWidth &lt;= 0.f)
100         m_avgCharWidth = m_fontMetrics.xHeight();
101 
102     if (m_maxCharWidth &lt;= 0.f)
103         m_maxCharWidth = std::max(m_avgCharWidth, m_fontMetrics.floatAscent());
104 }
105 
106 void Font::platformGlyphInit()
107 {
108 #if USE(FREETYPE)
109     auto* glyphPageZeroWidthSpace = glyphPage(GlyphPage::pageNumberForCodePoint(zeroWidthSpace));
110     UChar32 zeroWidthSpaceCharacter = zeroWidthSpace;
111 #else
112     // Ask for the glyph for 0 to avoid paging in ZERO WIDTH SPACE. Control characters, including 0,
113     // are mapped to the ZERO WIDTH SPACE glyph for non FreeType based ports.
114     auto* glyphPageZeroWidthSpace = glyphPage(0);
115     UChar32 zeroWidthSpaceCharacter = 0;
116 #endif
117     auto* glyphPageCharacterZero = glyphPage(GlyphPage::pageNumberForCodePoint(&#39;0&#39;));
118     auto* glyphPageSpace = glyphPage(GlyphPage::pageNumberForCodePoint(space));
119 
120     if (glyphPageZeroWidthSpace)
121         m_zeroWidthSpaceGlyph = glyphPageZeroWidthSpace-&gt;glyphDataForCharacter(zeroWidthSpaceCharacter).glyph;
122 
123     // Nasty hack to determine if we should round or ceil space widths.
124     // If the font is monospace or fake monospace we ceil to ensure that
125     // every character and the space are the same width. Otherwise we round.
126     if (glyphPageSpace)
127         m_spaceGlyph = glyphPageSpace-&gt;glyphDataForCharacter(space).glyph;
<a name="6" id="anc6"></a>

128     if (glyphPageCharacterZero)
129         m_zeroGlyph = glyphPageCharacterZero-&gt;glyphDataForCharacter(&#39;0&#39;).glyph;
<a name="7" id="anc7"></a>


130 
131     // Force the glyph for ZERO WIDTH SPACE to have zero width, unless it is shared with SPACE.
132     // Helvetica is an example of a non-zero width ZERO WIDTH SPACE glyph.
133     // See &lt;http://bugs.webkit.org/show_bug.cgi?id=13178&gt; and Font::isZeroWidthSpaceGlyph()
134     if (m_zeroWidthSpaceGlyph == m_spaceGlyph)
135         m_zeroWidthSpaceGlyph = 0;
<a name="8" id="anc8"></a><span class="line-added">136 </span>
<span class="line-added">137     float width = widthForGlyph(m_spaceGlyph);</span>
<span class="line-added">138     m_spaceWidth = width;</span>
<span class="line-added">139     m_fontMetrics.setZeroWidth(widthForGlyph(m_zeroGlyph));</span>
<span class="line-added">140     determinePitch();</span>
<span class="line-added">141     m_adjustedSpaceWidth = m_treatAsFixedPitch ? ceilf(width) : roundf(width);</span>
142 }
143 
144 Font::~Font()
145 {
146     removeFromSystemFallbackCache();
147 }
148 
149 static bool fillGlyphPage(GlyphPage&amp; pageToFill, UChar* buffer, unsigned bufferLength, const Font&amp; font)
150 {
151     bool hasGlyphs = pageToFill.fill(buffer, bufferLength);
152 #if ENABLE(OPENTYPE_VERTICAL)
153     if (hasGlyphs &amp;&amp; font.verticalData())
154         font.verticalData()-&gt;substituteWithVerticalGlyphs(&amp;font, &amp;pageToFill);
155 #else
156     UNUSED_PARAM(font);
157 #endif
158     return hasGlyphs;
159 }
160 
161 static Optional&lt;size_t&gt; codePointSupportIndex(UChar32 codePoint)
162 {
163     // FIXME: Consider reordering these so the most common ones are at the front.
164     // Doing this could cause the BitVector to fit inside inline storage and therefore
165     // be both a performance and a memory progression.
166     if (codePoint &lt; 0x20)
167         return codePoint;
168     if (codePoint &gt;= 0x7F &amp;&amp; codePoint &lt; 0xA0)
169         return codePoint - 0x7F + 0x20;
170     Optional&lt;size_t&gt; result;
171     switch (codePoint) {
172     case softHyphen:
173         result = 0x41;
174         break;
175     case newlineCharacter:
176         result = 0x42;
177         break;
178     case tabCharacter:
179         result = 0x43;
180         break;
181     case noBreakSpace:
182         result = 0x44;
183         break;
184     case narrowNoBreakSpace:
185         result = 0x45;
186         break;
187     case leftToRightMark:
188         result = 0x46;
189         break;
190     case rightToLeftMark:
191         result = 0x47;
192         break;
193     case leftToRightEmbed:
194         result = 0x48;
195         break;
196     case rightToLeftEmbed:
197         result = 0x49;
198         break;
199     case leftToRightOverride:
200         result = 0x4A;
201         break;
202     case rightToLeftOverride:
203         result = 0x4B;
204         break;
205     case leftToRightIsolate:
206         result = 0x4C;
207         break;
208     case rightToLeftIsolate:
209         result = 0x4D;
210         break;
211     case zeroWidthNonJoiner:
212         result = 0x4E;
213         break;
214     case zeroWidthJoiner:
215         result = 0x4F;
216         break;
217     case popDirectionalFormatting:
218         result = 0x50;
219         break;
220     case popDirectionalIsolate:
221         result = 0x51;
222         break;
223     case firstStrongIsolate:
224         result = 0x52;
225         break;
226     case objectReplacementCharacter:
227         result = 0x53;
228         break;
229     case zeroWidthNoBreakSpace:
230         result = 0x54;
231         break;
232     default:
233         result = WTF::nullopt;
234     }
235 
236 #ifndef NDEBUG
237     UChar32 codePointOrder[] = {
238         0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
239         0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
240         0x7F,
241         0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
242         0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
243         softHyphen,
244         newlineCharacter,
245         tabCharacter,
246         noBreakSpace,
247         narrowNoBreakSpace,
248         leftToRightMark,
249         rightToLeftMark,
250         leftToRightEmbed,
251         rightToLeftEmbed,
252         leftToRightOverride,
253         rightToLeftOverride,
254         leftToRightIsolate,
255         rightToLeftIsolate,
256         zeroWidthNonJoiner,
257         zeroWidthJoiner,
258         popDirectionalFormatting,
259         popDirectionalIsolate,
260         firstStrongIsolate,
261         objectReplacementCharacter,
262         zeroWidthNoBreakSpace
263     };
264     bool found = false;
265     for (size_t i = 0; i &lt; WTF_ARRAY_LENGTH(codePointOrder); ++i) {
266         if (codePointOrder[i] == codePoint) {
267             ASSERT(i == result);
268             found = true;
269         }
270     }
271     ASSERT(found == static_cast&lt;bool&gt;(result));
272 #endif
273     return result;
274 }
275 
276 #if !USE(FREETYPE)
277 static void overrideControlCharacters(Vector&lt;UChar&gt;&amp; buffer, unsigned start, unsigned end)
278 {
279     auto overwriteCodePoints = [&amp;](unsigned minimum, unsigned maximum, UChar newCodePoint) {
280         unsigned begin = std::max(start, minimum);
281         unsigned complete = std::min(end, maximum);
282         for (unsigned i = begin; i &lt; complete; ++i) {
283             ASSERT(codePointSupportIndex(i));
284             buffer[i - start] = newCodePoint;
285         }
286     };
287 
288     auto overwriteCodePoint = [&amp;](UChar codePoint, UChar newCodePoint) {
289         ASSERT(codePointSupportIndex(codePoint));
290         if (codePoint &gt;= start &amp;&amp; codePoint &lt; end)
291             buffer[codePoint - start] = newCodePoint;
292     };
293 
294     // Code points 0x0 - 0x20 and 0x7F - 0xA0 are control character and shouldn&#39;t render. Map them to ZERO WIDTH SPACE.
295     overwriteCodePoints(0x0, 0x20, zeroWidthSpace);
296     overwriteCodePoints(0x7F, 0xA0, zeroWidthSpace);
297     overwriteCodePoint(softHyphen, zeroWidthSpace);
298     overwriteCodePoint(&#39;\n&#39;, space);
299     overwriteCodePoint(&#39;\t&#39;, space);
300     overwriteCodePoint(noBreakSpace, space);
301     overwriteCodePoint(narrowNoBreakSpace, zeroWidthSpace);
302     overwriteCodePoint(leftToRightMark, zeroWidthSpace);
303     overwriteCodePoint(rightToLeftMark, zeroWidthSpace);
304     overwriteCodePoint(leftToRightEmbed, zeroWidthSpace);
305     overwriteCodePoint(rightToLeftEmbed, zeroWidthSpace);
306     overwriteCodePoint(leftToRightOverride, zeroWidthSpace);
307     overwriteCodePoint(rightToLeftOverride, zeroWidthSpace);
308     overwriteCodePoint(leftToRightIsolate, zeroWidthSpace);
309     overwriteCodePoint(rightToLeftIsolate, zeroWidthSpace);
310     overwriteCodePoint(zeroWidthNonJoiner, zeroWidthSpace);
311     overwriteCodePoint(zeroWidthJoiner, zeroWidthSpace);
312     overwriteCodePoint(popDirectionalFormatting, zeroWidthSpace);
313     overwriteCodePoint(popDirectionalIsolate, zeroWidthSpace);
314     overwriteCodePoint(firstStrongIsolate, zeroWidthSpace);
315     overwriteCodePoint(objectReplacementCharacter, zeroWidthSpace);
316     overwriteCodePoint(zeroWidthNoBreakSpace, zeroWidthSpace);
317 }
318 #endif
319 
320 static RefPtr&lt;GlyphPage&gt; createAndFillGlyphPage(unsigned pageNumber, const Font&amp; font)
321 {
322 #if PLATFORM(IOS_FAMILY)
323     // FIXME: Times New Roman contains Arabic glyphs, but Core Text doesn&#39;t know how to shape them. See &lt;rdar://problem/9823975&gt;.
324     // Once we have the fix for &lt;rdar://problem/9823975&gt; then remove this code together with Font::shouldNotBeUsedForArabic()
325     // in &lt;rdar://problem/12096835&gt;.
326     if (GlyphPage::pageNumberIsUsedForArabic(pageNumber) &amp;&amp; font.shouldNotBeUsedForArabic())
327         return nullptr;
328 #endif
329 
330     unsigned glyphPageSize = GlyphPage::sizeForPageNumber(pageNumber);
331 
332     unsigned start = GlyphPage::startingCodePointInPageNumber(pageNumber);
333     Vector&lt;UChar&gt; buffer(glyphPageSize * 2 + 2);
334     unsigned bufferLength;
335     // Fill in a buffer with the entire &quot;page&quot; of characters that we want to look up glyphs for.
336     if (U_IS_BMP(start)) {
337         bufferLength = glyphPageSize;
338         for (unsigned i = 0; i &lt; bufferLength; i++)
339             buffer[i] = start + i;
340 
341 #if !USE(FREETYPE)
342         overrideControlCharacters(buffer, start, start + glyphPageSize);
343 #endif
344     } else {
345         bufferLength = glyphPageSize * 2;
346         for (unsigned i = 0; i &lt; glyphPageSize; i++) {
347             int c = i + start;
348             buffer[i * 2] = U16_LEAD(c);
349             buffer[i * 2 + 1] = U16_TRAIL(c);
350         }
351     }
352 
353     // Now that we have a buffer full of characters, we want to get back an array
354     // of glyph indices. This part involves calling into the platform-specific
355     // routine of our glyph map for actually filling in the page with the glyphs.
356     // Success is not guaranteed. For example, Times fails to fill page 260, giving glyph data
357     // for only 128 out of 256 characters.
358     Ref&lt;GlyphPage&gt; glyphPage = GlyphPage::create(font);
359 
360     bool haveGlyphs = fillGlyphPage(glyphPage, buffer.data(), bufferLength, font);
361     if (!haveGlyphs)
362         return nullptr;
363 
364     return glyphPage;
365 }
366 
367 const GlyphPage* Font::glyphPage(unsigned pageNumber) const
368 {
369     if (!pageNumber) {
370         if (!m_glyphPageZero)
371             m_glyphPageZero = createAndFillGlyphPage(0, *this);
372         return m_glyphPageZero.get();
373     }
374     auto addResult = m_glyphPages.add(pageNumber, nullptr);
375     if (addResult.isNewEntry)
376         addResult.iterator-&gt;value = createAndFillGlyphPage(pageNumber, *this);
377 
378     return addResult.iterator-&gt;value.get();
379 }
380 
381 Glyph Font::glyphForCharacter(UChar32 character) const
382 {
383     auto* page = glyphPage(GlyphPage::pageNumberForCodePoint(character));
384     if (!page)
385         return 0;
386     return page-&gt;glyphForCharacter(character);
387 }
388 
389 GlyphData Font::glyphDataForCharacter(UChar32 character) const
390 {
391     auto* page = glyphPage(GlyphPage::pageNumberForCodePoint(character));
392     if (!page)
393         return GlyphData();
394     return page-&gt;glyphDataForCharacter(character);
395 }
396 
397 auto Font::ensureDerivedFontData() const -&gt; DerivedFonts&amp;
398 {
399     if (!m_derivedFontData)
400         m_derivedFontData = makeUnique&lt;DerivedFonts&gt;();
401     return *m_derivedFontData;
402 }
403 
404 const Font&amp; Font::verticalRightOrientationFont() const
405 {
406     DerivedFonts&amp; derivedFontData = ensureDerivedFontData();
407     if (!derivedFontData.verticalRightOrientationFont) {
408         auto verticalRightPlatformData = FontPlatformData::cloneWithOrientation(m_platformData, FontOrientation::Horizontal);
409         derivedFontData.verticalRightOrientationFont = create(verticalRightPlatformData, origin(), Interstitial::No, Visibility::Visible, OrientationFallback::Yes);
410     }
411     ASSERT(derivedFontData.verticalRightOrientationFont != this);
412     return *derivedFontData.verticalRightOrientationFont;
413 }
414 
415 const Font&amp; Font::uprightOrientationFont() const
416 {
417     DerivedFonts&amp; derivedFontData = ensureDerivedFontData();
418     if (!derivedFontData.uprightOrientationFont)
419         derivedFontData.uprightOrientationFont = create(m_platformData, origin(), Interstitial::No, Visibility::Visible, OrientationFallback::Yes);
420     ASSERT(derivedFontData.uprightOrientationFont != this);
421     return *derivedFontData.uprightOrientationFont;
422 }
423 
424 const Font&amp; Font::invisibleFont() const
425 {
426     DerivedFonts&amp; derivedFontData = ensureDerivedFontData();
427     if (!derivedFontData.invisibleFont)
428         derivedFontData.invisibleFont = create(m_platformData, origin(), Interstitial::Yes, Visibility::Invisible);
429     ASSERT(derivedFontData.invisibleFont != this);
430     return *derivedFontData.invisibleFont;
431 }
432 
433 const Font* Font::smallCapsFont(const FontDescription&amp; fontDescription) const
434 {
435     DerivedFonts&amp; derivedFontData = ensureDerivedFontData();
436     if (!derivedFontData.smallCapsFont)
437         derivedFontData.smallCapsFont = createScaledFont(fontDescription, smallCapsFontSizeMultiplier);
438     ASSERT(derivedFontData.smallCapsFont != this);
439     return derivedFontData.smallCapsFont.get();
440 }
441 
442 const Font&amp; Font::noSynthesizableFeaturesFont() const
443 {
444 #if PLATFORM(COCOA)
445     DerivedFonts&amp; derivedFontData = ensureDerivedFontData();
446     if (!derivedFontData.noSynthesizableFeaturesFont)
447         derivedFontData.noSynthesizableFeaturesFont = createFontWithoutSynthesizableFeatures();
448     ASSERT(derivedFontData.noSynthesizableFeaturesFont != this);
449     return *derivedFontData.noSynthesizableFeaturesFont;
450 #else
451     return *this;
452 #endif
453 }
454 
455 const Font* Font::emphasisMarkFont(const FontDescription&amp; fontDescription) const
456 {
457     DerivedFonts&amp; derivedFontData = ensureDerivedFontData();
458     if (!derivedFontData.emphasisMarkFont)
459         derivedFontData.emphasisMarkFont = createScaledFont(fontDescription, emphasisMarkFontSizeMultiplier);
460     ASSERT(derivedFontData.emphasisMarkFont != this);
461     return derivedFontData.emphasisMarkFont.get();
462 }
463 
464 const Font&amp; Font::brokenIdeographFont() const
465 {
466     DerivedFonts&amp; derivedFontData = ensureDerivedFontData();
467     if (!derivedFontData.brokenIdeographFont) {
468         derivedFontData.brokenIdeographFont = create(m_platformData, origin(), Interstitial::No);
469         derivedFontData.brokenIdeographFont-&gt;m_isBrokenIdeographFallback = true;
470     }
471     ASSERT(derivedFontData.brokenIdeographFont != this);
472     return *derivedFontData.brokenIdeographFont;
473 }
474 
475 #if !LOG_DISABLED
476 String Font::description() const
477 {
478     if (origin() == Origin::Remote)
479         return &quot;[custom font]&quot;;
480 
481     return platformData().description();
482 }
483 #endif
484 
485 const OpenTypeMathData* Font::mathData() const
486 {
487     if (isInterstitial())
488         return nullptr;
489     if (!m_mathData) {
490         m_mathData = OpenTypeMathData::create(m_platformData);
491         if (!m_mathData-&gt;hasMathData())
492             m_mathData = nullptr;
493     }
494     return m_mathData.get();
495 }
496 
497 RefPtr&lt;Font&gt; Font::createScaledFont(const FontDescription&amp; fontDescription, float scaleFactor) const
498 {
499     return platformCreateScaledFont(fontDescription, scaleFactor);
500 }
501 
<a name="9" id="anc9"></a><span class="line-modified">502 #if !PLATFORM(COCOA)</span>
<span class="line-added">503 void Font::applyTransforms(GlyphBuffer&amp;, unsigned, bool, bool, const AtomString&amp;) const</span>
504 {
<a name="10" id="anc10"></a>










505 }
<a name="11" id="anc11"></a><span class="line-added">506 #endif</span>
507 
508 class CharacterFallbackMapKey {
509 public:
510     CharacterFallbackMapKey()
511     {
512     }
513 
514     CharacterFallbackMapKey(const AtomString&amp; locale, UChar32 character, IsForPlatformFont isForPlatformFont)
515         : locale(locale)
516         , character(character)
517         , isForPlatformFont(isForPlatformFont == IsForPlatformFont::Yes)
518     {
519     }
520 
521     CharacterFallbackMapKey(WTF::HashTableDeletedValueType)
522         : character(-1)
523     {
524     }
525 
526     bool isHashTableDeletedValue() const { return character == -1; }
527 
528     bool operator==(const CharacterFallbackMapKey&amp; other) const
529     {
530         return locale == other.locale &amp;&amp; character == other.character &amp;&amp; isForPlatformFont == other.isForPlatformFont;
531     }
532 
533     static const bool emptyValueIsZero = true;
534 
535 private:
536     friend struct CharacterFallbackMapKeyHash;
537 
538     AtomString locale;
539     UChar32 character { 0 };
540     bool isForPlatformFont { false };
541 };
542 
543 struct CharacterFallbackMapKeyHash {
544     static unsigned hash(const CharacterFallbackMapKey&amp; key)
545     {
546         IntegerHasher hasher;
547         hasher.add(key.character);
548         hasher.add(key.isForPlatformFont);
549         hasher.add(key.locale.existingHash());
550         return hasher.hash();
551     }
552 
553     static bool equal(const CharacterFallbackMapKey&amp; a, const CharacterFallbackMapKey&amp; b)
554     {
555         return a == b;
556     }
557 
558     static const bool safeToCompareToEmptyOrDeleted = true;
559 };
560 
561 // Fonts are not ref&#39;d to avoid cycles.
562 // FIXME: Shouldn&#39;t these be WeakPtrs?
563 typedef HashMap&lt;CharacterFallbackMapKey, Font*, CharacterFallbackMapKeyHash, WTF::SimpleClassHashTraits&lt;CharacterFallbackMapKey&gt;&gt; CharacterFallbackMap;
564 typedef HashMap&lt;const Font*, CharacterFallbackMap&gt; SystemFallbackCache;
565 
566 static SystemFallbackCache&amp; systemFallbackCache()
567 {
568     static NeverDestroyed&lt;SystemFallbackCache&gt; map;
569     return map.get();
570 }
571 
572 RefPtr&lt;Font&gt; Font::systemFallbackFontForCharacter(UChar32 character, const FontDescription&amp; description, IsForPlatformFont isForPlatformFont) const
573 {
574     auto fontAddResult = systemFallbackCache().add(this, CharacterFallbackMap());
575 
576     if (!character) {
577         UChar codeUnit = 0;
578         return FontCache::singleton().systemFallbackForCharacters(description, this, isForPlatformFont, FontCache::PreferColoredFont::No, &amp;codeUnit, 1);
579     }
580 
581     auto key = CharacterFallbackMapKey(description.locale(), character, isForPlatformFont);
582     auto characterAddResult = fontAddResult.iterator-&gt;value.add(WTFMove(key), nullptr);
583 
584     Font*&amp; fallbackFont = characterAddResult.iterator-&gt;value;
585 
586     if (!fallbackFont) {
587         UChar codeUnits[2];
588         unsigned codeUnitsLength;
589         if (U_IS_BMP(character)) {
590             codeUnits[0] = FontCascade::normalizeSpaces(character);
591             codeUnitsLength = 1;
592         } else {
593             codeUnits[0] = U16_LEAD(character);
594             codeUnits[1] = U16_TRAIL(character);
595             codeUnitsLength = 2;
596         }
597 
598         fallbackFont = FontCache::singleton().systemFallbackForCharacters(description, this, isForPlatformFont, FontCache::PreferColoredFont::No, codeUnits, codeUnitsLength).get();
599         if (fallbackFont)
600             fallbackFont-&gt;m_isUsedInSystemFallbackCache = true;
601     }
602 
603     return fallbackFont;
604 }
605 
606 void Font::removeFromSystemFallbackCache()
607 {
608     systemFallbackCache().remove(this);
609 
610     if (!m_isUsedInSystemFallbackCache)
611         return;
612 
613     for (auto&amp; characterMap : systemFallbackCache().values()) {
614         Vector&lt;CharacterFallbackMapKey, 512&gt; toRemove;
615         for (auto&amp; entry : characterMap) {
616             if (entry.value == this)
617                 toRemove.append(entry.key);
618         }
619         for (auto&amp; key : toRemove)
620             characterMap.remove(key);
621     }
622 }
623 
624 #if !PLATFORM(COCOA) &amp;&amp; !USE(FREETYPE)
625 bool Font::variantCapsSupportsCharacterForSynthesis(FontVariantCaps fontVariantCaps, UChar32) const
626 {
627     switch (fontVariantCaps) {
628     case FontVariantCaps::Small:
629     case FontVariantCaps::Petite:
630     case FontVariantCaps::AllSmall:
631     case FontVariantCaps::AllPetite:
632         return false;
633     default:
634         // Synthesis only supports the variant-caps values listed above.
635         return true;
636     }
637 }
638 
639 bool Font::platformSupportsCodePoint(UChar32 character, Optional&lt;UChar32&gt; variation) const
640 {
641     return variation ? false : glyphForCharacter(character);
642 }
643 #endif
644 
645 bool Font::supportsCodePoint(UChar32 character) const
646 {
647     // This is very similar to static_cast&lt;bool&gt;(glyphForCharacter(character))
648     // except that glyphForCharacter() maps certain code points to ZWS (because they
649     // shouldn&#39;t be visible). This function doesn&#39;t do that mapping, and instead is
650     // as honest as possible about what code points the font supports. This is so
651     // that we can accurately determine which characters are supported by this font
652     // so we know which boundaries to break strings when we send them to the complex
653     // text codepath. The complex text codepath is totally separate from this ZWS
654     // replacement logic (because CoreText handles those characters instead of WebKit).
655     if (auto index = codePointSupportIndex(character)) {
656         m_codePointSupport.ensureSize(2 * (*index + 1));
657         bool hasBeenSet = m_codePointSupport.quickSet(2 * *index);
658         if (!hasBeenSet &amp;&amp; platformSupportsCodePoint(character))
659             m_codePointSupport.quickSet(2 * *index + 1);
660         return m_codePointSupport.quickGet(2 * *index + 1);
661     }
662     return glyphForCharacter(character);
663 }
664 
665 bool Font::canRenderCombiningCharacterSequence(const UChar* characters, size_t length) const
666 {
667     ASSERT(isMainThread());
668 
669     auto codePoints = StringView(characters, length).codePoints();
670     auto it = codePoints.begin();
671     auto end = codePoints.end();
672     while (it != end) {
673         auto codePoint = *it;
674         ++it;
675 
676         if (it != end &amp;&amp; isVariationSelector(*it)) {
677             if (!platformSupportsCodePoint(codePoint, *it)) {
678                 // Try the characters individually.
679                 if (!supportsCodePoint(codePoint) || !supportsCodePoint(*it))
680                     return false;
681             }
682             ++it;
683             continue;
684         }
685 
686         if (!supportsCodePoint(codePoint))
687             return false;
688     }
689     return true;
690 }
691 
692 // Don&#39;t store the result of this! The hash map is free to rehash at any point, leaving this reference dangling.
693 const Path&amp; Font::pathForGlyph(Glyph glyph) const
694 {
695     if (const auto&amp; path = m_glyphPathMap.existingMetricsForGlyph(glyph))
696         return *path;
697     auto path = platformPathForGlyph(glyph);
698     m_glyphPathMap.setMetricsForGlyph(glyph, path);
699     return *m_glyphPathMap.existingMetricsForGlyph(glyph);
700 }
701 
<a name="12" id="anc12"></a><span class="line-added">702 void Font::setFontFaceData(RefPtr&lt;SharedBuffer&gt;&amp;&amp; fontFaceData)</span>
<span class="line-added">703 {</span>
<span class="line-added">704     m_fontFaceData = WTFMove(fontFaceData);</span>
<span class="line-added">705 }</span>
<span class="line-added">706 </span>
<span class="line-added">707 FontHandle::FontHandle(Ref&lt;SharedBuffer&gt;&amp;&amp; fontFaceData, Font::Origin origin, float fontSize, bool syntheticBold, bool syntheticItalic)</span>
<span class="line-added">708 {</span>
<span class="line-added">709     bool wrapping;</span>
<span class="line-added">710     auto customFontData = CachedFont::createCustomFontData(fontFaceData.get(), { }, wrapping);</span>
<span class="line-added">711     FontDescription description;</span>
<span class="line-added">712     description.setComputedSize(fontSize);</span>
<span class="line-added">713     font = Font::create(CachedFont::platformDataFromCustomData(*customFontData, description, syntheticBold, syntheticItalic, { }, { }), origin);</span>
<span class="line-added">714 }</span>
<span class="line-added">715 </span>
716 } // namespace WebCore
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
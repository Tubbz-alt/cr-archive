<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPredictionPropagationPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGPredictionInjectionPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGPromotedHeapLocation.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGPredictionPropagationPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 162                 changed |= mergePrediction(prediction);
 163             break;
 164         }
 165 
 166         case SetLocal: {
 167             VariableAccessData* variableAccessData = node-&gt;variableAccessData();
 168             changed |= variableAccessData-&gt;predict(node-&gt;child1()-&gt;prediction());
 169             break;
 170         }
 171 
 172         case UInt32ToNumber: {
 173             if (node-&gt;canSpeculateInt32(m_pass))
 174                 changed |= mergePrediction(SpecInt32Only);
 175             else if (enableInt52())
 176                 changed |= mergePrediction(SpecInt52Any);
 177             else
 178                 changed |= mergePrediction(SpecBytecodeNumber);
 179             break;
 180         }
 181 

 182         case ValueBitLShift: {
 183             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 184             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 185 
 186             if (left &amp;&amp; right) {
 187                 if (isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 188                     changed |= mergePrediction(SpecBigInt);
 189                 else if (isFullNumberOrBooleanSpeculationExpectingDefined(left) &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right))
 190                     changed |= mergePrediction(SpecInt32Only);
 191                 else
 192                     changed |= mergePrediction(node-&gt;getHeapPrediction());
 193             }
 194 
 195             break;
 196         }
 197 
 198         case ValueAdd: {
 199             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 200             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 201 
</pre>
<hr />
<pre>
 276                     if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 277                         changed |= mergePrediction(SpecInt32Only);
 278                     else if (m_graph.addShouldSpeculateInt52(node))
 279                         changed |= mergePrediction(SpecInt52Any);
 280                     else
 281                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 282                 } else if (isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 283                     changed |= mergePrediction(SpecBigInt);
 284                 else {
 285                     changed |= mergePrediction(SpecInt32Only);
 286                     if (node-&gt;mayHaveDoubleResult())
 287                         changed |= mergePrediction(SpecBytecodeDouble);
 288                     if (node-&gt;mayHaveBigIntResult())
 289                         changed |= mergePrediction(SpecBigInt);
 290                 }
 291             }
 292 
 293             break;
 294         }
 295 

























 296         case ValuePow: {
 297             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 298             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 299 
 300             if (left &amp;&amp; right) {
 301                 if (node-&gt;child1()-&gt;shouldSpeculateBigInt() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateBigInt())
 302                     changed |= mergePrediction(SpecBigInt);
 303                 else if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 304                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right))
 305                     changed |= mergePrediction(SpecBytecodeDouble);
 306                 else
 307                     changed |= mergePrediction(SpecBytecodeDouble | SpecBigInt);
 308             }
 309             break;
 310         }
 311 
 312         case ValueNegate:
 313         case ArithNegate: {
 314             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 315             if (prediction) {
</pre>
<hr />
<pre>
 532             if (isStrictMode)
 533                 changed |= mergePrediction(node-&gt;getHeapPrediction());
 534             else if (prediction) {
 535                 if (prediction &amp; ~SpecObject) {
 536                     // Wrapper objects are created only in sloppy mode.
 537                     prediction &amp;= SpecObject;
 538                     prediction = mergeSpeculations(prediction, SpecObjectOther);
 539                 }
 540                 changed |= mergePrediction(prediction);
 541             }
 542             break;
 543         }
 544 
 545         case ToPrimitive: {
 546             SpeculatedType child = node-&gt;child1()-&gt;prediction();
 547             if (child)
 548                 changed |= mergePrediction(resultOfToPrimitive(child));
 549             break;
 550         }
 551 







 552         case NormalizeMapKey: {
 553             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 554             if (prediction)
 555                 changed |= mergePrediction(prediction);
 556             break;
 557         }
 558 
 559         default:
 560             break;
 561         }
 562 
 563         m_changed |= changed;
 564     }
 565 
 566     void propagateForward()
 567     {
 568         for (Node* node : m_dependentNodes) {
 569             m_currentNode = node;
 570             propagate(m_currentNode);
 571         }
</pre>
<hr />
<pre>
 766     void processInvariantsForNode()
 767     {
 768         switch (m_currentNode-&gt;op()) {
 769         case JSConstant: {
 770             SpeculatedType type = speculationFromValue(m_currentNode-&gt;asJSValue());
 771             if (type == SpecAnyIntAsDouble &amp;&amp; enableInt52())
 772                 type = int52AwareSpeculationFromValue(m_currentNode-&gt;asJSValue());
 773             setPrediction(type);
 774             break;
 775         }
 776         case DoubleConstant: {
 777             SpeculatedType type = speculationFromValue(m_currentNode-&gt;asJSValue());
 778             setPrediction(type);
 779             break;
 780         }
 781 
 782         case ArithBitNot:
 783         case ArithBitAnd:
 784         case ArithBitOr:
 785         case ArithBitXor:
<span class="line-modified"> 786         case BitRShift:</span>
 787         case ArithBitLShift:
 788         case BitURShift:
 789         case ArithIMul:
 790         case ArithClz32: {
 791             setPrediction(SpecInt32Only);
 792             break;
 793         }
 794 
 795         case ArrayPop:
 796         case ArrayPush:
 797         case RegExpExec:
 798         case RegExpExecNonGlobalOrSticky:
 799         case RegExpTest:
 800         case RegExpMatchFast:
 801         case RegExpMatchFastGlobal:
 802         case StringReplace:
 803         case StringReplaceRegExp:
 804         case GetById:
 805         case GetByIdFlush:
 806         case GetByIdWithThis:
</pre>
<hr />
<pre>
 810         case GetByValWithThis:
 811         case GetByOffset:
 812         case MultiGetByOffset:
 813         case GetDirectPname:
 814         case Call:
 815         case DirectCall:
 816         case TailCallInlinedCaller:
 817         case DirectTailCallInlinedCaller:
 818         case Construct:
 819         case DirectConstruct:
 820         case CallVarargs:
 821         case CallEval:
 822         case TailCallVarargsInlinedCaller:
 823         case ConstructVarargs:
 824         case CallForwardVarargs:
 825         case ConstructForwardVarargs:
 826         case TailCallForwardVarargsInlinedCaller:
 827         case GetGlobalVar:
 828         case GetGlobalLexicalVariable:
 829         case GetClosureVar:

 830         case GetFromArguments:
 831         case LoadKeyFromMapBucket:
 832         case LoadValueFromMapBucket:
 833         case ToNumber:

 834         case ToObject:
 835         case ValueBitAnd:
 836         case ValueBitXor:
 837         case ValueBitOr:
 838         case ValueBitNot:
 839         case CallObjectConstructor:
 840         case GetArgument:
 841         case CallDOMGetter:
 842         case GetDynamicVar:
 843         case GetPrototypeOf:
 844         case ExtractValueFromWeakMapGet:
 845         case DataViewGetInt:
<span class="line-modified"> 846         case DataViewGetFloat: {</span>

 847             setPrediction(m_currentNode-&gt;getHeapPrediction());
 848             break;
 849         }
 850 





 851         case WeakMapGet:
 852         case ResolveScopeForHoistingFuncDeclInEval: {
 853             setPrediction(SpecBytecodeTop);
 854             break;
 855         }
 856 
 857         case GetGetterSetterByOffset:
 858         case GetExecutable: {
 859             setPrediction(SpecCellOther);
 860             break;
 861         }
 862 
 863         case GetGetter:
 864         case GetSetter:
 865         case GetCallee:
 866         case NewFunction:
 867         case NewGeneratorFunction:
 868         case NewAsyncGeneratorFunction:
 869         case NewAsyncFunction: {
 870             setPrediction(SpecFunction);
</pre>
<hr />
<pre>
 888         case GetMapBucketHead:
 889         case GetMapBucketNext:
 890         case SetAdd:
 891         case MapSet:
 892             setPrediction(SpecCellOther);
 893             break;
 894 
 895         case GetRestLength:
 896         case ArrayIndexOf: {
 897             setPrediction(SpecInt32Only);
 898             break;
 899         }
 900 
 901         case GetTypedArrayByteOffset:
 902         case GetArrayLength:
 903         case GetVectorLength: {
 904             setPrediction(SpecInt32Only);
 905             break;
 906         }
 907 
<span class="line-modified"> 908         case StringCharCodeAt: {</span>

 909             setPrediction(SpecInt32Only);
 910             break;
 911         }
 912 
 913         case StringValueOf:
 914         case StringSlice:
 915         case ToLowerCase:
 916             setPrediction(SpecString);
 917             break;
 918 
 919         case ArithPow:
 920         case ArithSqrt:
 921         case ArithFRound:
 922         case ArithUnary: {
 923             setPrediction(SpecBytecodeDouble);
 924             break;
 925         }
 926 
 927         case ArithRound:
 928         case ArithFloor:
</pre>
<hr />
<pre>
 992             setPrediction(SpecObjectOther);
 993             break;
 994         }
 995 
 996         case GetGlobalThis:
 997             setPrediction(SpecObject);
 998             break;
 999 
1000         case ResolveScope: {
1001             setPrediction(SpecObjectOther);
1002             break;
1003         }
1004 
1005         case ObjectCreate:
1006         case CreateThis:
1007         case NewObject: {
1008             setPrediction(SpecFinalObject);
1009             break;
1010         }
1011 













1012         case ArraySlice:
1013         case NewArrayWithSpread:
1014         case NewArray:
1015         case NewArrayWithSize:
1016         case CreateRest:
1017         case NewArrayBuffer:
1018         case ObjectKeys: {
1019             setPrediction(SpecArray);
1020             break;
1021         }
1022 
1023         case Spread:
1024             setPrediction(SpecCellOther);
1025             break;
1026 
1027         case NewTypedArray: {
1028             setPrediction(speculationFromTypedArrayType(m_currentNode-&gt;typedArrayType()));
1029             break;
1030         }
1031 
</pre>
<hr />
<pre>
1062         case NewSymbol: {
1063             setPrediction(SpecSymbol);
1064             break;
1065         }
1066 
1067         case CreateDirectArguments: {
1068             setPrediction(SpecDirectArguments);
1069             break;
1070         }
1071 
1072         case CreateScopedArguments: {
1073             setPrediction(SpecScopedArguments);
1074             break;
1075         }
1076 
1077         case CreateClonedArguments: {
1078             setPrediction(SpecObjectOther);
1079             break;
1080         }
1081 





1082         case FiatInt52: {
1083             RELEASE_ASSERT(enableInt52());
1084             setPrediction(SpecInt52Any);
1085             break;
1086         }
1087 
1088         case GetScope:
1089             setPrediction(SpecObjectOther);
1090             break;
1091 
1092         case InByVal:
1093         case InById:
1094             setPrediction(SpecBoolean);
1095             break;
1096 
1097         case HasOwnProperty:
1098             setPrediction(SpecBoolean);
1099             break;
1100 
1101         case GetEnumerableLength: {
</pre>
<hr />
<pre>
1137             setPrediction(m_currentNode-&gt;getForcedPrediction());
1138             break;
1139         }
1140 
1141         case ExtractCatchLocal: {
1142             setPrediction(m_currentNode-&gt;catchLocalPrediction());
1143             break;
1144         }
1145 
1146         case GetLocal:
1147         case SetLocal:
1148         case UInt32ToNumber:
1149         case ValueNegate:
1150         case ValueAdd:
1151         case ValueSub:
1152         case ValueMul:
1153         case ValueDiv:
1154         case ValueMod:
1155         case ValuePow:
1156         case ValueBitLShift:



1157         case ArithAdd:
1158         case ArithSub:
1159         case ArithNegate:
1160         case ArithMin:
1161         case ArithMax:
1162         case ArithMul:
1163         case ArithDiv:
1164         case ArithMod:
1165         case ArithAbs:
1166         case GetByVal:
1167         case ToThis:
1168         case ToPrimitive:

1169         case NormalizeMapKey:
1170         case AtomicsAdd:
1171         case AtomicsAnd:
1172         case AtomicsCompareExchange:
1173         case AtomicsExchange:
1174         case AtomicsLoad:
1175         case AtomicsOr:
1176         case AtomicsStore:
1177         case AtomicsSub:
1178         case AtomicsXor: {
1179             m_dependentNodes.append(m_currentNode);
1180             break;
1181         }
1182 
1183         case AtomicsIsLockFree: {
1184             setPrediction(SpecBoolean);
1185             break;
1186         }
1187 
1188         case CPUIntrinsic: {
1189             if (m_currentNode-&gt;intrinsic() == CPURdtscIntrinsic)
1190                 setPrediction(SpecInt32Only);
1191             else
1192                 setPrediction(SpecOther);
1193             break;
1194         }
1195 
1196         case PutByValAlias:
1197         case DoubleAsInt32:
<span class="line-removed">1198         case CheckArray:</span>
1199         case CheckTypeInfoFlags:
1200         case Arrayify:
1201         case ArrayifyToStructure:
1202         case CheckTierUpInLoop:
1203         case CheckTierUpAtReturn:
1204         case CheckTierUpAndOSREnter:
1205         case CheckInBounds:
1206         case ValueToInt32:
1207         case DoubleRep:
1208         case ValueRep:
1209         case Int52Rep:
1210         case Int52Constant:
1211         case Identity:
1212         case BooleanToNumber:
1213         case PhantomNewObject:
1214         case PhantomNewFunction:
1215         case PhantomNewGeneratorFunction:
1216         case PhantomNewAsyncGeneratorFunction:
1217         case PhantomNewAsyncFunction:
1218         case PhantomCreateActivation:
1219         case PhantomDirectArguments:
1220         case PhantomCreateRest:
1221         case PhantomSpread:
1222         case PhantomNewArrayWithSpread:
1223         case PhantomNewArrayBuffer:

1224         case PhantomClonedArguments:
1225         case PhantomNewRegexp:
1226         case GetMyArgumentByVal:
1227         case GetMyArgumentByValOutOfBounds:
1228         case PutHint:
1229         case CheckStructureImmediate:
1230         case CheckStructureOrEmpty:

1231         case MaterializeNewObject:
1232         case MaterializeCreateActivation:

1233         case PutStack:
1234         case KillStack:
1235         case StoreBarrier:
1236         case FencedStoreBarrier:
1237         case GetStack:
1238         case GetRegExpObjectLastIndex:
1239         case SetRegExpObjectLastIndex:
1240         case RecordRegExpCachedResult:
1241         case LazyJSConstant:
1242         case CallDOM: {
1243             // This node should never be visible at this stage of compilation.
1244             DFG_CRASH(m_graph, m_currentNode, &quot;Unexpected node during prediction propagation&quot;);
1245             break;
1246         }
1247 
1248         case Phi:
1249             // Phis should not be visible here since we&#39;re iterating the all-but-Phi&#39;s
1250             // part of basic blocks.
1251             RELEASE_ASSERT_NOT_REACHED();
1252             break;
1253 
1254         case EntrySwitch:
1255         case Upsilon:
1256             // These don&#39;t get inserted until we go into SSA.
1257             RELEASE_ASSERT_NOT_REACHED();
1258             break;
1259 
1260 #ifndef NDEBUG
1261         // These get ignored because they don&#39;t return anything.
1262         case PutByValDirect:
1263         case PutByValWithThis:
1264         case PutByIdWithThis:
1265         case PutByVal:
1266         case PutClosureVar:

1267         case PutToArguments:
1268         case Return:
1269         case Throw:
1270         case ThrowStaticError:
1271         case TailCall:
1272         case DirectTailCall:
1273         case TailCallVarargs:
1274         case TailCallForwardVarargs:
1275         case PutById:
1276         case PutByIdFlush:
1277         case PutByIdDirect:
1278         case PutByOffset:
1279         case MultiPutByOffset:
1280         case PutGetterById:
1281         case PutSetterById:
1282         case PutGetterSetterById:
1283         case PutGetterByVal:
1284         case PutSetterByVal:
1285         case DefineDataProperty:
1286         case DefineAccessorProperty:
1287         case DFG::Jump:
1288         case Branch:
1289         case Switch:
1290         case ProfileType:
1291         case ProfileControlFlow:
1292         case ForceOSRExit:
1293         case SetArgumentDefinitely:
1294         case SetArgumentMaybe:
1295         case SetFunctionName:
1296         case CheckStructure:
1297         case CheckCell:
1298         case CheckNotEmpty:
1299         case AssertNotEmpty:
<span class="line-modified">1300         case CheckStringIdent:</span>
1301         case CheckBadCell:
1302         case PutStructure:
1303         case Phantom:
1304         case Check:


1305         case CheckVarargs:
1306         case PutGlobalVariable:
1307         case CheckTraps:
1308         case LogShadowChickenPrologue:
1309         case LogShadowChickenTail:
1310         case Unreachable:
1311         case LoopHint:
1312         case NotifyWrite:
1313         case ConstantStoragePointer:
1314         case MovHint:
1315         case ZombieHint:
1316         case ExitOK:

1317         case LoadVarargs:
1318         case ForwardVarargs:
1319         case PutDynamicVar:
1320         case NukeStructureAndSetButterfly:
1321         case InitializeEntrypointArguments:
1322         case WeakSetAdd:
1323         case WeakMapSet:
1324         case FilterCallLinkStatus:
<span class="line-modified">1325         case FilterGetByIdStatus:</span>
1326         case FilterPutByIdStatus:
1327         case FilterInByIdStatus:
1328         case ClearCatchLocals:
1329         case DataViewSet:
1330         case InvalidationPoint:
1331             break;
1332 
1333         // This gets ignored because it only pretends to produce a value.
1334         case BottomValue:
1335             break;
1336 
1337         // This gets ignored because it already has a prediction.
1338         case ExtractOSREntryLocal:
1339             break;
1340 
1341         // These gets ignored because it doesn&#39;t do anything.
1342         case CountExecution:
1343         case SuperSamplerBegin:
1344         case SuperSamplerEnd:
1345         case PhantomLocal:
</pre>
<hr />
<pre>
1353         default:
1354             break;
1355 #endif
1356         }
1357     }
1358 
1359     SpeculatedType resultOfToPrimitive(SpeculatedType type)
1360     {
1361         if (type &amp; SpecObject) {
1362             // We try to be optimistic here about StringObjects since it&#39;s unlikely that
1363             // someone overrides the valueOf or toString methods.
1364             if (type &amp; SpecStringObject &amp;&amp; m_graph.canOptimizeStringObjectAccess(m_currentNode-&gt;origin.semantic))
1365                 return mergeSpeculations(type &amp; ~SpecObject, SpecString);
1366 
1367             return mergeSpeculations(type &amp; ~SpecObject, SpecPrimitive);
1368         }
1369 
1370         return type;
1371     }
1372 












1373     Vector&lt;Node*&gt; m_dependentNodes;
1374     Node* m_currentNode;
1375     bool m_changed { false };
1376     PredictionPass m_pass { PrimaryPass }; // We use different logic for considering predictions depending on how far along we are in propagation.
1377 };
1378 
1379 } // Anonymous namespace.
1380 
1381 bool performPredictionPropagation(Graph&amp; graph)
1382 {
1383     return runPhase&lt;PredictionPropagationPhase&gt;(graph);
1384 }
1385 
1386 } } // namespace JSC::DFG
1387 
1388 #endif // ENABLE(DFG_JIT)
1389 
</pre>
</td>
<td>
<hr />
<pre>
 162                 changed |= mergePrediction(prediction);
 163             break;
 164         }
 165 
 166         case SetLocal: {
 167             VariableAccessData* variableAccessData = node-&gt;variableAccessData();
 168             changed |= variableAccessData-&gt;predict(node-&gt;child1()-&gt;prediction());
 169             break;
 170         }
 171 
 172         case UInt32ToNumber: {
 173             if (node-&gt;canSpeculateInt32(m_pass))
 174                 changed |= mergePrediction(SpecInt32Only);
 175             else if (enableInt52())
 176                 changed |= mergePrediction(SpecInt52Any);
 177             else
 178                 changed |= mergePrediction(SpecBytecodeNumber);
 179             break;
 180         }
 181 
<span class="line-added"> 182         case ValueBitRShift:</span>
 183         case ValueBitLShift: {
 184             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 185             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 186 
 187             if (left &amp;&amp; right) {
 188                 if (isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 189                     changed |= mergePrediction(SpecBigInt);
 190                 else if (isFullNumberOrBooleanSpeculationExpectingDefined(left) &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right))
 191                     changed |= mergePrediction(SpecInt32Only);
 192                 else
 193                     changed |= mergePrediction(node-&gt;getHeapPrediction());
 194             }
 195 
 196             break;
 197         }
 198 
 199         case ValueAdd: {
 200             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 201             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 202 
</pre>
<hr />
<pre>
 277                     if (m_graph.addSpeculationMode(node, m_pass) != DontSpeculateInt32)
 278                         changed |= mergePrediction(SpecInt32Only);
 279                     else if (m_graph.addShouldSpeculateInt52(node))
 280                         changed |= mergePrediction(SpecInt52Any);
 281                     else
 282                         changed |= mergePrediction(speculatedDoubleTypeForPredictions(left, right));
 283                 } else if (isBigIntSpeculation(left) &amp;&amp; isBigIntSpeculation(right))
 284                     changed |= mergePrediction(SpecBigInt);
 285                 else {
 286                     changed |= mergePrediction(SpecInt32Only);
 287                     if (node-&gt;mayHaveDoubleResult())
 288                         changed |= mergePrediction(SpecBytecodeDouble);
 289                     if (node-&gt;mayHaveBigIntResult())
 290                         changed |= mergePrediction(SpecBigInt);
 291                 }
 292             }
 293 
 294             break;
 295         }
 296 
<span class="line-added"> 297         case Inc:</span>
<span class="line-added"> 298         case Dec: {</span>
<span class="line-added"> 299             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();</span>
<span class="line-added"> 300 </span>
<span class="line-added"> 301             if (prediction) {</span>
<span class="line-added"> 302                 if (isFullNumberOrBooleanSpeculationExpectingDefined(prediction)) {</span>
<span class="line-added"> 303                     if (m_graph.unaryArithShouldSpeculateInt32(node, m_pass))</span>
<span class="line-added"> 304                         changed |= mergePrediction(SpecInt32Only);</span>
<span class="line-added"> 305                     else if (m_graph.unaryArithShouldSpeculateInt52(node, m_pass))</span>
<span class="line-added"> 306                         changed |= mergePrediction(SpecInt52Any);</span>
<span class="line-added"> 307                     else</span>
<span class="line-added"> 308                         changed |= mergePrediction(speculatedDoubleTypeForPrediction(prediction));</span>
<span class="line-added"> 309                 } else if (isBigIntSpeculation(prediction))</span>
<span class="line-added"> 310                     changed |= mergePrediction(SpecBigInt);</span>
<span class="line-added"> 311                 else {</span>
<span class="line-added"> 312                     changed |= mergePrediction(SpecInt32Only);</span>
<span class="line-added"> 313                     if (node-&gt;mayHaveDoubleResult())</span>
<span class="line-added"> 314                         changed |= mergePrediction(SpecBytecodeDouble);</span>
<span class="line-added"> 315                     if (node-&gt;mayHaveBigIntResult())</span>
<span class="line-added"> 316                         changed |= mergePrediction(SpecBigInt);</span>
<span class="line-added"> 317                 }</span>
<span class="line-added"> 318             }</span>
<span class="line-added"> 319             break;</span>
<span class="line-added"> 320         }</span>
<span class="line-added"> 321 </span>
 322         case ValuePow: {
 323             SpeculatedType left = node-&gt;child1()-&gt;prediction();
 324             SpeculatedType right = node-&gt;child2()-&gt;prediction();
 325 
 326             if (left &amp;&amp; right) {
 327                 if (node-&gt;child1()-&gt;shouldSpeculateBigInt() &amp;&amp; node-&gt;child2()-&gt;shouldSpeculateBigInt())
 328                     changed |= mergePrediction(SpecBigInt);
 329                 else if (isFullNumberOrBooleanSpeculationExpectingDefined(left)
 330                     &amp;&amp; isFullNumberOrBooleanSpeculationExpectingDefined(right))
 331                     changed |= mergePrediction(SpecBytecodeDouble);
 332                 else
 333                     changed |= mergePrediction(SpecBytecodeDouble | SpecBigInt);
 334             }
 335             break;
 336         }
 337 
 338         case ValueNegate:
 339         case ArithNegate: {
 340             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 341             if (prediction) {
</pre>
<hr />
<pre>
 558             if (isStrictMode)
 559                 changed |= mergePrediction(node-&gt;getHeapPrediction());
 560             else if (prediction) {
 561                 if (prediction &amp; ~SpecObject) {
 562                     // Wrapper objects are created only in sloppy mode.
 563                     prediction &amp;= SpecObject;
 564                     prediction = mergeSpeculations(prediction, SpecObjectOther);
 565                 }
 566                 changed |= mergePrediction(prediction);
 567             }
 568             break;
 569         }
 570 
 571         case ToPrimitive: {
 572             SpeculatedType child = node-&gt;child1()-&gt;prediction();
 573             if (child)
 574                 changed |= mergePrediction(resultOfToPrimitive(child));
 575             break;
 576         }
 577 
<span class="line-added"> 578         case ToPropertyKey: {</span>
<span class="line-added"> 579             SpeculatedType child = node-&gt;child1()-&gt;prediction();</span>
<span class="line-added"> 580             if (child)</span>
<span class="line-added"> 581                 changed |= mergePrediction(resultOfToPropertyKey(child));</span>
<span class="line-added"> 582             break;</span>
<span class="line-added"> 583         }</span>
<span class="line-added"> 584 </span>
 585         case NormalizeMapKey: {
 586             SpeculatedType prediction = node-&gt;child1()-&gt;prediction();
 587             if (prediction)
 588                 changed |= mergePrediction(prediction);
 589             break;
 590         }
 591 
 592         default:
 593             break;
 594         }
 595 
 596         m_changed |= changed;
 597     }
 598 
 599     void propagateForward()
 600     {
 601         for (Node* node : m_dependentNodes) {
 602             m_currentNode = node;
 603             propagate(m_currentNode);
 604         }
</pre>
<hr />
<pre>
 799     void processInvariantsForNode()
 800     {
 801         switch (m_currentNode-&gt;op()) {
 802         case JSConstant: {
 803             SpeculatedType type = speculationFromValue(m_currentNode-&gt;asJSValue());
 804             if (type == SpecAnyIntAsDouble &amp;&amp; enableInt52())
 805                 type = int52AwareSpeculationFromValue(m_currentNode-&gt;asJSValue());
 806             setPrediction(type);
 807             break;
 808         }
 809         case DoubleConstant: {
 810             SpeculatedType type = speculationFromValue(m_currentNode-&gt;asJSValue());
 811             setPrediction(type);
 812             break;
 813         }
 814 
 815         case ArithBitNot:
 816         case ArithBitAnd:
 817         case ArithBitOr:
 818         case ArithBitXor:
<span class="line-modified"> 819         case ArithBitRShift:</span>
 820         case ArithBitLShift:
 821         case BitURShift:
 822         case ArithIMul:
 823         case ArithClz32: {
 824             setPrediction(SpecInt32Only);
 825             break;
 826         }
 827 
 828         case ArrayPop:
 829         case ArrayPush:
 830         case RegExpExec:
 831         case RegExpExecNonGlobalOrSticky:
 832         case RegExpTest:
 833         case RegExpMatchFast:
 834         case RegExpMatchFastGlobal:
 835         case StringReplace:
 836         case StringReplaceRegExp:
 837         case GetById:
 838         case GetByIdFlush:
 839         case GetByIdWithThis:
</pre>
<hr />
<pre>
 843         case GetByValWithThis:
 844         case GetByOffset:
 845         case MultiGetByOffset:
 846         case GetDirectPname:
 847         case Call:
 848         case DirectCall:
 849         case TailCallInlinedCaller:
 850         case DirectTailCallInlinedCaller:
 851         case Construct:
 852         case DirectConstruct:
 853         case CallVarargs:
 854         case CallEval:
 855         case TailCallVarargsInlinedCaller:
 856         case ConstructVarargs:
 857         case CallForwardVarargs:
 858         case ConstructForwardVarargs:
 859         case TailCallForwardVarargsInlinedCaller:
 860         case GetGlobalVar:
 861         case GetGlobalLexicalVariable:
 862         case GetClosureVar:
<span class="line-added"> 863         case GetInternalField:</span>
 864         case GetFromArguments:
 865         case LoadKeyFromMapBucket:
 866         case LoadValueFromMapBucket:
 867         case ToNumber:
<span class="line-added"> 868         case ToNumeric:</span>
 869         case ToObject:
 870         case ValueBitAnd:
 871         case ValueBitXor:
 872         case ValueBitOr:
 873         case ValueBitNot:
 874         case CallObjectConstructor:
 875         case GetArgument:
 876         case CallDOMGetter:
 877         case GetDynamicVar:
 878         case GetPrototypeOf:
 879         case ExtractValueFromWeakMapGet:
 880         case DataViewGetInt:
<span class="line-modified"> 881         case DataViewGetFloat:</span>
<span class="line-added"> 882         case DateGetInt32OrNaN: {</span>
 883             setPrediction(m_currentNode-&gt;getHeapPrediction());
 884             break;
 885         }
 886 
<span class="line-added"> 887         case DateGetTime: {</span>
<span class="line-added"> 888             setPrediction(SpecFullNumber);</span>
<span class="line-added"> 889             break;</span>
<span class="line-added"> 890         }</span>
<span class="line-added"> 891 </span>
 892         case WeakMapGet:
 893         case ResolveScopeForHoistingFuncDeclInEval: {
 894             setPrediction(SpecBytecodeTop);
 895             break;
 896         }
 897 
 898         case GetGetterSetterByOffset:
 899         case GetExecutable: {
 900             setPrediction(SpecCellOther);
 901             break;
 902         }
 903 
 904         case GetGetter:
 905         case GetSetter:
 906         case GetCallee:
 907         case NewFunction:
 908         case NewGeneratorFunction:
 909         case NewAsyncGeneratorFunction:
 910         case NewAsyncFunction: {
 911             setPrediction(SpecFunction);
</pre>
<hr />
<pre>
 929         case GetMapBucketHead:
 930         case GetMapBucketNext:
 931         case SetAdd:
 932         case MapSet:
 933             setPrediction(SpecCellOther);
 934             break;
 935 
 936         case GetRestLength:
 937         case ArrayIndexOf: {
 938             setPrediction(SpecInt32Only);
 939             break;
 940         }
 941 
 942         case GetTypedArrayByteOffset:
 943         case GetArrayLength:
 944         case GetVectorLength: {
 945             setPrediction(SpecInt32Only);
 946             break;
 947         }
 948 
<span class="line-modified"> 949         case StringCharCodeAt:</span>
<span class="line-added"> 950         case StringCodePointAt: {</span>
 951             setPrediction(SpecInt32Only);
 952             break;
 953         }
 954 
 955         case StringValueOf:
 956         case StringSlice:
 957         case ToLowerCase:
 958             setPrediction(SpecString);
 959             break;
 960 
 961         case ArithPow:
 962         case ArithSqrt:
 963         case ArithFRound:
 964         case ArithUnary: {
 965             setPrediction(SpecBytecodeDouble);
 966             break;
 967         }
 968 
 969         case ArithRound:
 970         case ArithFloor:
</pre>
<hr />
<pre>
1034             setPrediction(SpecObjectOther);
1035             break;
1036         }
1037 
1038         case GetGlobalThis:
1039             setPrediction(SpecObject);
1040             break;
1041 
1042         case ResolveScope: {
1043             setPrediction(SpecObjectOther);
1044             break;
1045         }
1046 
1047         case ObjectCreate:
1048         case CreateThis:
1049         case NewObject: {
1050             setPrediction(SpecFinalObject);
1051             break;
1052         }
1053 
<span class="line-added">1054         case CreatePromise:</span>
<span class="line-added">1055         case NewPromise:</span>
<span class="line-added">1056             setPrediction(SpecPromiseObject);</span>
<span class="line-added">1057             break;</span>
<span class="line-added">1058 </span>
<span class="line-added">1059         case CreateGenerator:</span>
<span class="line-added">1060         case NewGenerator:</span>
<span class="line-added">1061         case CreateAsyncGenerator:</span>
<span class="line-added">1062         case NewAsyncGenerator:</span>
<span class="line-added">1063         case NewArrayIterator:</span>
<span class="line-added">1064             setPrediction(SpecObjectOther);</span>
<span class="line-added">1065             break;</span>
<span class="line-added">1066 </span>
1067         case ArraySlice:
1068         case NewArrayWithSpread:
1069         case NewArray:
1070         case NewArrayWithSize:
1071         case CreateRest:
1072         case NewArrayBuffer:
1073         case ObjectKeys: {
1074             setPrediction(SpecArray);
1075             break;
1076         }
1077 
1078         case Spread:
1079             setPrediction(SpecCellOther);
1080             break;
1081 
1082         case NewTypedArray: {
1083             setPrediction(speculationFromTypedArrayType(m_currentNode-&gt;typedArrayType()));
1084             break;
1085         }
1086 
</pre>
<hr />
<pre>
1117         case NewSymbol: {
1118             setPrediction(SpecSymbol);
1119             break;
1120         }
1121 
1122         case CreateDirectArguments: {
1123             setPrediction(SpecDirectArguments);
1124             break;
1125         }
1126 
1127         case CreateScopedArguments: {
1128             setPrediction(SpecScopedArguments);
1129             break;
1130         }
1131 
1132         case CreateClonedArguments: {
1133             setPrediction(SpecObjectOther);
1134             break;
1135         }
1136 
<span class="line-added">1137         case CreateArgumentsButterfly: {</span>
<span class="line-added">1138             setPrediction(SpecCellOther);</span>
<span class="line-added">1139             break;</span>
<span class="line-added">1140         }</span>
<span class="line-added">1141 </span>
1142         case FiatInt52: {
1143             RELEASE_ASSERT(enableInt52());
1144             setPrediction(SpecInt52Any);
1145             break;
1146         }
1147 
1148         case GetScope:
1149             setPrediction(SpecObjectOther);
1150             break;
1151 
1152         case InByVal:
1153         case InById:
1154             setPrediction(SpecBoolean);
1155             break;
1156 
1157         case HasOwnProperty:
1158             setPrediction(SpecBoolean);
1159             break;
1160 
1161         case GetEnumerableLength: {
</pre>
<hr />
<pre>
1197             setPrediction(m_currentNode-&gt;getForcedPrediction());
1198             break;
1199         }
1200 
1201         case ExtractCatchLocal: {
1202             setPrediction(m_currentNode-&gt;catchLocalPrediction());
1203             break;
1204         }
1205 
1206         case GetLocal:
1207         case SetLocal:
1208         case UInt32ToNumber:
1209         case ValueNegate:
1210         case ValueAdd:
1211         case ValueSub:
1212         case ValueMul:
1213         case ValueDiv:
1214         case ValueMod:
1215         case ValuePow:
1216         case ValueBitLShift:
<span class="line-added">1217         case ValueBitRShift:</span>
<span class="line-added">1218         case Inc:</span>
<span class="line-added">1219         case Dec:</span>
1220         case ArithAdd:
1221         case ArithSub:
1222         case ArithNegate:
1223         case ArithMin:
1224         case ArithMax:
1225         case ArithMul:
1226         case ArithDiv:
1227         case ArithMod:
1228         case ArithAbs:
1229         case GetByVal:
1230         case ToThis:
1231         case ToPrimitive:
<span class="line-added">1232         case ToPropertyKey:</span>
1233         case NormalizeMapKey:
1234         case AtomicsAdd:
1235         case AtomicsAnd:
1236         case AtomicsCompareExchange:
1237         case AtomicsExchange:
1238         case AtomicsLoad:
1239         case AtomicsOr:
1240         case AtomicsStore:
1241         case AtomicsSub:
1242         case AtomicsXor: {
1243             m_dependentNodes.append(m_currentNode);
1244             break;
1245         }
1246 
1247         case AtomicsIsLockFree: {
1248             setPrediction(SpecBoolean);
1249             break;
1250         }
1251 
1252         case CPUIntrinsic: {
1253             if (m_currentNode-&gt;intrinsic() == CPURdtscIntrinsic)
1254                 setPrediction(SpecInt32Only);
1255             else
1256                 setPrediction(SpecOther);
1257             break;
1258         }
1259 
1260         case PutByValAlias:
1261         case DoubleAsInt32:

1262         case CheckTypeInfoFlags:
1263         case Arrayify:
1264         case ArrayifyToStructure:
1265         case CheckTierUpInLoop:
1266         case CheckTierUpAtReturn:
1267         case CheckTierUpAndOSREnter:
1268         case CheckInBounds:
1269         case ValueToInt32:
1270         case DoubleRep:
1271         case ValueRep:
1272         case Int52Rep:
1273         case Int52Constant:
1274         case Identity:
1275         case BooleanToNumber:
1276         case PhantomNewObject:
1277         case PhantomNewFunction:
1278         case PhantomNewGeneratorFunction:
1279         case PhantomNewAsyncGeneratorFunction:
1280         case PhantomNewAsyncFunction:
1281         case PhantomCreateActivation:
1282         case PhantomDirectArguments:
1283         case PhantomCreateRest:
1284         case PhantomSpread:
1285         case PhantomNewArrayWithSpread:
1286         case PhantomNewArrayBuffer:
<span class="line-added">1287         case PhantomNewArrayIterator:</span>
1288         case PhantomClonedArguments:
1289         case PhantomNewRegexp:
1290         case GetMyArgumentByVal:
1291         case GetMyArgumentByValOutOfBounds:
1292         case PutHint:
1293         case CheckStructureImmediate:
1294         case CheckStructureOrEmpty:
<span class="line-added">1295         case CheckArrayOrEmpty:</span>
1296         case MaterializeNewObject:
1297         case MaterializeCreateActivation:
<span class="line-added">1298         case MaterializeNewInternalFieldObject:</span>
1299         case PutStack:
1300         case KillStack:
1301         case StoreBarrier:
1302         case FencedStoreBarrier:
1303         case GetStack:
1304         case GetRegExpObjectLastIndex:
1305         case SetRegExpObjectLastIndex:
1306         case RecordRegExpCachedResult:
1307         case LazyJSConstant:
1308         case CallDOM: {
1309             // This node should never be visible at this stage of compilation.
1310             DFG_CRASH(m_graph, m_currentNode, &quot;Unexpected node during prediction propagation&quot;);
1311             break;
1312         }
1313 
1314         case Phi:
1315             // Phis should not be visible here since we&#39;re iterating the all-but-Phi&#39;s
1316             // part of basic blocks.
1317             RELEASE_ASSERT_NOT_REACHED();
1318             break;
1319 
1320         case EntrySwitch:
1321         case Upsilon:
1322             // These don&#39;t get inserted until we go into SSA.
1323             RELEASE_ASSERT_NOT_REACHED();
1324             break;
1325 
1326 #ifndef NDEBUG
1327         // These get ignored because they don&#39;t return anything.
1328         case PutByValDirect:
1329         case PutByValWithThis:
1330         case PutByIdWithThis:
1331         case PutByVal:
1332         case PutClosureVar:
<span class="line-added">1333         case PutInternalField:</span>
1334         case PutToArguments:
1335         case Return:
1336         case Throw:
1337         case ThrowStaticError:
1338         case TailCall:
1339         case DirectTailCall:
1340         case TailCallVarargs:
1341         case TailCallForwardVarargs:
1342         case PutById:
1343         case PutByIdFlush:
1344         case PutByIdDirect:
1345         case PutByOffset:
1346         case MultiPutByOffset:
1347         case PutGetterById:
1348         case PutSetterById:
1349         case PutGetterSetterById:
1350         case PutGetterByVal:
1351         case PutSetterByVal:
1352         case DefineDataProperty:
1353         case DefineAccessorProperty:
1354         case DFG::Jump:
1355         case Branch:
1356         case Switch:
1357         case ProfileType:
1358         case ProfileControlFlow:
1359         case ForceOSRExit:
1360         case SetArgumentDefinitely:
1361         case SetArgumentMaybe:
1362         case SetFunctionName:
1363         case CheckStructure:
1364         case CheckCell:
1365         case CheckNotEmpty:
1366         case AssertNotEmpty:
<span class="line-modified">1367         case CheckIdent:</span>
1368         case CheckBadCell:
1369         case PutStructure:
1370         case Phantom:
1371         case Check:
<span class="line-added">1372         case CheckArray:</span>
<span class="line-added">1373         case CheckNeutered:</span>
1374         case CheckVarargs:
1375         case PutGlobalVariable:
1376         case CheckTraps:
1377         case LogShadowChickenPrologue:
1378         case LogShadowChickenTail:
1379         case Unreachable:
1380         case LoopHint:
1381         case NotifyWrite:
1382         case ConstantStoragePointer:
1383         case MovHint:
1384         case ZombieHint:
1385         case ExitOK:
<span class="line-added">1386         case VarargsLength:</span>
1387         case LoadVarargs:
1388         case ForwardVarargs:
1389         case PutDynamicVar:
1390         case NukeStructureAndSetButterfly:
1391         case InitializeEntrypointArguments:
1392         case WeakSetAdd:
1393         case WeakMapSet:
1394         case FilterCallLinkStatus:
<span class="line-modified">1395         case FilterGetByStatus:</span>
1396         case FilterPutByIdStatus:
1397         case FilterInByIdStatus:
1398         case ClearCatchLocals:
1399         case DataViewSet:
1400         case InvalidationPoint:
1401             break;
1402 
1403         // This gets ignored because it only pretends to produce a value.
1404         case BottomValue:
1405             break;
1406 
1407         // This gets ignored because it already has a prediction.
1408         case ExtractOSREntryLocal:
1409             break;
1410 
1411         // These gets ignored because it doesn&#39;t do anything.
1412         case CountExecution:
1413         case SuperSamplerBegin:
1414         case SuperSamplerEnd:
1415         case PhantomLocal:
</pre>
<hr />
<pre>
1423         default:
1424             break;
1425 #endif
1426         }
1427     }
1428 
1429     SpeculatedType resultOfToPrimitive(SpeculatedType type)
1430     {
1431         if (type &amp; SpecObject) {
1432             // We try to be optimistic here about StringObjects since it&#39;s unlikely that
1433             // someone overrides the valueOf or toString methods.
1434             if (type &amp; SpecStringObject &amp;&amp; m_graph.canOptimizeStringObjectAccess(m_currentNode-&gt;origin.semantic))
1435                 return mergeSpeculations(type &amp; ~SpecObject, SpecString);
1436 
1437             return mergeSpeculations(type &amp; ~SpecObject, SpecPrimitive);
1438         }
1439 
1440         return type;
1441     }
1442 
<span class="line-added">1443     SpeculatedType resultOfToPropertyKey(SpeculatedType type)</span>
<span class="line-added">1444     {</span>
<span class="line-added">1445         // Propagate the prediction of the source directly if already proven to be a property key.</span>
<span class="line-added">1446         if (type &amp;&amp; !(type &amp; ~(SpecString | SpecSymbol)))</span>
<span class="line-added">1447             return type;</span>
<span class="line-added">1448 </span>
<span class="line-added">1449         if (type &amp; SpecStringObject &amp;&amp; m_graph.canOptimizeStringObjectAccess(m_currentNode-&gt;origin.semantic))</span>
<span class="line-added">1450             return mergeSpeculations(type &amp; SpecSymbol, SpecString);</span>
<span class="line-added">1451 </span>
<span class="line-added">1452         return SpecString | SpecSymbol;</span>
<span class="line-added">1453     }</span>
<span class="line-added">1454 </span>
1455     Vector&lt;Node*&gt; m_dependentNodes;
1456     Node* m_currentNode;
1457     bool m_changed { false };
1458     PredictionPass m_pass { PrimaryPass }; // We use different logic for considering predictions depending on how far along we are in propagation.
1459 };
1460 
1461 } // Anonymous namespace.
1462 
1463 bool performPredictionPropagation(Graph&amp; graph)
1464 {
1465     return runPhase&lt;PredictionPropagationPhase&gt;(graph);
1466 }
1467 
1468 } } // namespace JSC::DFG
1469 
1470 #endif // ENABLE(DFG_JIT)
1471 
</pre>
</td>
</tr>
</table>
<center><a href="DFGPredictionInjectionPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGPromotedHeapLocation.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
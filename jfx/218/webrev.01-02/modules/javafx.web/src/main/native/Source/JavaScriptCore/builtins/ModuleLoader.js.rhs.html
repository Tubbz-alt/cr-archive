<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/ModuleLoader.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2015, 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 // https://whatwg.github.io/loader/#loader-object
 27 // Module Loader has several hooks that can be customized by the platform.
 28 // For example, the [[Fetch]] hook can be provided by the JavaScriptCore shell
 29 // as fetching the payload from the local file system.
 30 // Currently, there are 4 hooks.
 31 //    1. Loader.resolve
 32 //    2. Loader.fetch
 33 
 34 @globalPrivate
 35 function setStateToMax(entry, newState)
 36 {
 37     // https://whatwg.github.io/loader/#set-state-to-max
 38 
 39     &quot;use strict&quot;;
 40 
 41     if (entry.state &lt; newState)
 42         entry.state = newState;
 43 }
 44 
 45 @globalPrivate
 46 function newRegistryEntry(key)
 47 {
 48     // https://whatwg.github.io/loader/#registry
 49     //
 50     // Each registry entry becomes one of the 5 states.
 51     // 1. Fetch
 52     //     Ready to fetch (or now fetching) the resource of this module.
 53     //     Typically, we fetch the source code over the network or from the file system.
 54     //     a. If the status is Fetch and there is no entry.fetch promise, the entry is ready to fetch.
 55     //     b. If the status is Fetch and there is the entry.fetch promise, the entry is just fetching the resource.
 56     //
 57     // 2. Instantiate (AnalyzeModule)
 58     //     Ready to instantiate (or now instantiating) the module record from the fetched
 59     //     source code.
 60     //     Typically, we parse the module code, extract the dependencies and binding information.
 61     //     a. If the status is Instantiate and there is no entry.instantiate promise, the entry is ready to instantiate.
 62     //     b. If the status is Instantiate and there is the entry.fetch promise, the entry is just instantiating
 63     //        the module record.
 64     //
 65     // 3. Satisfy
 66     //     Ready to request the dependent modules (or now requesting &amp; resolving).
 67     //     Without this state, the current draft causes infinite recursion when there is circular dependency.
 68     //     a. If the status is Satisfy and there is no entry.satisfy promise, the entry is ready to resolve the dependencies.
 69     //     b. If the status is Satisfy and there is the entry.satisfy promise, the entry is just resolving
 70     //        the dependencies.
 71     //
 72     // 4. Link
 73     //     Ready to link the module with the other modules.
 74     //     Linking means that the module imports and exports the bindings from/to the other modules.
 75     //
 76     // 5. Ready
 77     //     The module is linked, so the module is ready to be executed.
 78     //
 79     // Each registry entry has the 4 promises; &quot;fetch&quot;, &quot;instantiate&quot; and &quot;satisfy&quot;.
 80     // They are assigned when starting the each phase. And they are fulfilled when the each phase is completed.
 81     //
 82     // In the current module draft, linking will be performed after the whole modules are instantiated and the dependencies are resolved.
 83     // And execution is also done after the all modules are linked.
 84     //
 85     // TODO: We need to exploit the way to execute the module while fetching non-related modules.
 86     // One solution; introducing the ready promise chain to execute the modules concurrently while keeping
 87     // the execution order.
 88 
 89     &quot;use strict&quot;;
 90 
 91     return {
 92         key: key,
 93         state: @ModuleFetch,
 94         fetch: @undefined,
 95         instantiate: @undefined,
 96         satisfy: @undefined,
 97         dependencies: [], // To keep the module order, we store the module keys in the array.
 98         module: @undefined, // JSModuleRecord
 99         linkError: @undefined,
100         linkSucceeded: true,
101         evaluated: false,
102     };
103 }
104 
105 function ensureRegistered(key)
106 {
107     // https://whatwg.github.io/loader/#ensure-registered
108 
109     &quot;use strict&quot;;
110 
111     var entry = this.registry.@get(key);
112     if (entry)
113         return entry;
114 
115     entry = @newRegistryEntry(key);
116     this.registry.@set(key, entry);
117 
118     return entry;
119 }
120 
121 function forceFulfillPromise(promise, value)
122 {
123     &quot;use strict&quot;;
124 
<a name="1" id="anc1"></a><span class="line-modified">125     @assert(@isPromise(promise));</span>
<span class="line-added">126 </span>
<span class="line-added">127     if ((@getPromiseInternalField(promise, @promiseFieldFlags) &amp; @promiseStateMask) === @promiseStatePending)</span>
128         @fulfillPromise(promise, value);
129 }
130 
131 function fulfillFetch(entry, source)
132 {
133     // https://whatwg.github.io/loader/#fulfill-fetch
134 
135     &quot;use strict&quot;;
136 
137     if (!entry.fetch)
138         entry.fetch = @newPromiseCapability(@InternalPromise).@promise;
139     this.forceFulfillPromise(entry.fetch, source);
140     @setStateToMax(entry, @ModuleInstantiate);
141 }
142 
143 // Loader.
144 
145 function requestFetch(entry, parameters, fetcher)
146 {
147     // https://whatwg.github.io/loader/#request-fetch
148 
149     &quot;use strict&quot;;
150 
151     if (entry.fetch) {
152         var currentAttempt = entry.fetch;
153         if (entry.state !== @ModuleFetch)
154             return currentAttempt;
155 
156         return currentAttempt.catch((error) =&gt; {
157             // Even if the existing fetching request failed, this attempt may succeed.
158             // For example, previous attempt used invalid integrity=&quot;&quot; value. But this
159             // request could have the correct integrity=&quot;&quot; value. In that case, we should
160             // retry fetching for this request.
161             // https://html.spec.whatwg.org/#fetch-a-single-module-script
162             if (currentAttempt === entry.fetch)
163                 entry.fetch = @undefined;
164             return this.requestFetch(entry, parameters, fetcher);
165         });
166     }
167 
168     // Hook point.
169     // 2. Loader.fetch
170     //     https://whatwg.github.io/loader/#browser-fetch
171     //     Take the key and fetch the resource actually.
172     //     For example, JavaScriptCore shell can provide the hook fetching the resource
173     //     from the local file system.
174     var fetchPromise = this.fetch(entry.key, parameters, fetcher).then((source) =&gt; {
175         @setStateToMax(entry, @ModuleInstantiate);
176         return source;
177     });
178     entry.fetch = fetchPromise;
179     return fetchPromise;
180 }
181 
182 function requestInstantiate(entry, parameters, fetcher)
183 {
184     // https://whatwg.github.io/loader/#request-instantiate
185 
186     &quot;use strict&quot;;
187 
188     // entry.instantiate is set if fetch succeeds.
189     if (entry.instantiate)
190         return entry.instantiate;
191 
192     var instantiatePromise = (async () =&gt; {
193         var source = await this.requestFetch(entry, parameters, fetcher);
194         // https://html.spec.whatwg.org/#fetch-a-single-module-script
195         // Now fetching request succeeds. Then even if instantiation fails, we should cache it.
196         // Instantiation won&#39;t be retried.
197         if (entry.instantiate)
198             return await entry.instantiate;
199         entry.instantiate = instantiatePromise;
200 
201         var key = entry.key;
202         var moduleRecord = await this.parseModule(key, source);
203         var dependenciesMap = moduleRecord.dependenciesMap;
204         var requestedModules = this.requestedModules(moduleRecord);
205         var dependencies = @newArrayWithSize(requestedModules.length);
206         for (var i = 0, length = requestedModules.length; i &lt; length; ++i) {
207             var depName = requestedModules[i];
208             var depKey = this.resolveSync(depName, key, fetcher);
209             var depEntry = this.ensureRegistered(depKey);
210             @putByValDirect(dependencies, i, depEntry);
211             dependenciesMap.@set(depName, depEntry);
212         }
213         entry.dependencies = dependencies;
214         entry.module = moduleRecord;
215         @setStateToMax(entry, @ModuleSatisfy);
216         return entry;
217     })();
218     return instantiatePromise;
219 }
220 
221 function requestSatisfy(entry, parameters, fetcher, visited)
222 {
223     // https://html.spec.whatwg.org/#internal-module-script-graph-fetching-procedure
224 
225     &quot;use strict&quot;;
226 
227     if (entry.satisfy)
228         return entry.satisfy;
229 
230     visited.@add(entry);
231     var satisfyPromise = this.requestInstantiate(entry, parameters, fetcher).then((entry) =&gt; {
232         if (entry.satisfy)
233             return entry.satisfy;
234 
235         var depLoads = @newArrayWithSize(entry.dependencies.length);
236         for (var i = 0, length = entry.dependencies.length; i &lt; length; ++i) {
237             var depEntry = entry.dependencies[i];
238             var promise;
239 
240             // Recursive resolving. The dependencies of this entry is being resolved or already resolved.
241             // Stop tracing the circular dependencies.
242             // But to retrieve the instantiated module record correctly,
243             // we need to wait for the instantiation for the dependent module.
244             // For example, reaching here, the module is starting resolving the dependencies.
245             // But the module may or may not reach the instantiation phase in the loader&#39;s pipeline.
246             // If we wait for the Satisfy for this module, it construct the circular promise chain and
247             // rejected by the Promises runtime. Since only we need is the instantiated module, instead of waiting
248             // the Satisfy for this module, we just wait Instantiate for this.
249             if (visited.@has(depEntry))
250                 promise = this.requestInstantiate(depEntry, @undefined, fetcher);
251             else {
252                 // Currently, module loader do not pass any information for non-top-level module fetching.
253                 promise = this.requestSatisfy(depEntry, @undefined, fetcher, visited);
254             }
255             @putByValDirect(depLoads, i, promise);
256         }
257 
258         return @InternalPromise.internalAll(depLoads).then((entries) =&gt; {
259             if (entry.satisfy)
260                 return entry;
261             @setStateToMax(entry, @ModuleLink);
262             entry.satisfy = satisfyPromise;
263             return entry;
264         });
265     });
266 
267     return satisfyPromise;
268 }
269 
270 // Linking semantics.
271 
272 function link(entry, fetcher)
273 {
274     // https://html.spec.whatwg.org/#fetch-the-descendants-of-and-instantiate-a-module-script
275 
276     &quot;use strict&quot;;
277 
278     if (!entry.linkSucceeded)
279         throw entry.linkError;
280     if (entry.state === @ModuleReady)
281         return;
282     @setStateToMax(entry, @ModuleReady);
283 
284     try {
285         // Since we already have the &quot;dependencies&quot; field,
286         // we can call moduleDeclarationInstantiation with the correct order
287         // without constructing the dependency graph by calling dependencyGraph.
288         var dependencies = entry.dependencies;
289         for (var i = 0, length = dependencies.length; i &lt; length; ++i)
290             this.link(dependencies[i], fetcher);
291 
292         this.moduleDeclarationInstantiation(entry.module, fetcher);
293     } catch (error) {
294         entry.linkSucceeded = false;
295         entry.linkError = error;
296         throw error;
297     }
298 }
299 
300 // Module semantics.
301 
302 function moduleEvaluation(entry, fetcher)
303 {
304     // http://www.ecma-international.org/ecma-262/6.0/#sec-moduleevaluation
305 
306     &quot;use strict&quot;;
307 
308     if (entry.evaluated)
309         return;
310     entry.evaluated = true;
311 
312     // The contents of the [[RequestedModules]] is cloned into entry.dependencies.
313     var dependencies = entry.dependencies;
314     for (var i = 0, length = dependencies.length; i &lt; length; ++i)
315         this.moduleEvaluation(dependencies[i], fetcher);
316 
317     this.evaluate(entry.key, entry.module, fetcher);
318 }
319 
320 // APIs to control the module loader.
321 
322 function provideFetch(key, value)
323 {
324     &quot;use strict&quot;;
325 
326     var entry = this.ensureRegistered(key);
327 
328     if (entry.state &gt; @ModuleFetch)
329         @throwTypeError(&quot;Requested module is already fetched.&quot;);
330     this.fulfillFetch(entry, value);
331 }
332 
333 async function loadModule(moduleName, parameters, fetcher)
334 {
335     &quot;use strict&quot;;
336 
337     // Loader.resolve hook point.
338     // resolve: moduleName =&gt; Promise(moduleKey)
339     // Take the name and resolve it to the unique identifier for the resource location.
340     // For example, take the &quot;jquery&quot; and return the URL for the resource.
<a name="2" id="anc2"></a><span class="line-modified">341     var key = await this.resolve(moduleName, @undefined, fetcher);</span>
<span class="line-modified">342     var entry = await this.requestSatisfy(this.ensureRegistered(key), parameters, fetcher, new @Set);</span>
343     return entry.key;
344 }
345 
346 function linkAndEvaluateModule(key, fetcher)
347 {
348     &quot;use strict&quot;;
349 
350     var entry = this.ensureRegistered(key);
351     if (entry.state &lt; @ModuleLink)
352         @throwTypeError(&quot;Requested module is not instantiated yet.&quot;);
353 
354     this.link(entry, fetcher);
355     return this.moduleEvaluation(entry, fetcher);
356 }
357 
358 async function loadAndEvaluateModule(moduleName, parameters, fetcher)
359 {
360     &quot;use strict&quot;;
361 
<a name="3" id="anc3"></a><span class="line-modified">362     var key = await this.loadModule(moduleName, parameters, fetcher);</span>
363     return await this.linkAndEvaluateModule(key, fetcher);
364 }
365 
366 async function requestImportModule(key, parameters, fetcher)
367 {
368     &quot;use strict&quot;;
369 
<a name="4" id="anc4"></a><span class="line-modified">370     var entry = await this.requestSatisfy(this.ensureRegistered(key), parameters, fetcher, new @Set);</span>
371     this.linkAndEvaluateModule(entry.key, fetcher);
372     return this.getModuleNamespaceObject(entry.module);
373 }
374 
375 function dependencyKeysIfEvaluated(key)
376 {
377     &quot;use strict&quot;;
378 
<a name="5" id="anc5"></a><span class="line-modified">379     var entry = this.registry.@get(key);</span>
380     if (!entry || !entry.evaluated)
381         return null;
382 
<a name="6" id="anc6"></a><span class="line-modified">383     var dependencies = entry.dependencies;</span>
<span class="line-modified">384     var length = dependencies.length;</span>
<span class="line-modified">385     var result = new @Array(length);</span>
<span class="line-modified">386     for (var i = 0; i &lt; length; ++i)</span>
387         result[i] = dependencies[i].key;
388 
389     return result;
390 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
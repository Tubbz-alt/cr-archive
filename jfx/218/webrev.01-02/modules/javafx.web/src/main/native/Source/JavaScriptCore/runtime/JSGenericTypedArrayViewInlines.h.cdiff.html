<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayViewInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSGenericTypedArrayViewConstructorInlines.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGenericTypedArrayViewPrototypeFunctions.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayViewInlines.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,10 ***</span>
<span class="line-new-header">--- 28,11 ---</span>
  #include &quot;ArrayBufferView.h&quot;
  #include &quot;DeferGC.h&quot;
  #include &quot;Error.h&quot;
  #include &quot;ExceptionHelpers.h&quot;
  #include &quot;JSArrayBuffer.h&quot;
<span class="line-added">+ #include &quot;JSCellInlines.h&quot;</span>
  #include &quot;JSGenericTypedArrayView.h&quot;
  #include &quot;TypeError.h&quot;
  #include &quot;TypedArrays.h&quot;
  #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 44,17 ***</span>
  {
  }
  
  template&lt;typename Adaptor&gt;
  JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::create(
<span class="line-modified">!     ExecState* exec, Structure* structure, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      ConstructionContext context(vm, structure, length, sizeof(typename Adaptor::Type));
      if (!context) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
      JSGenericTypedArrayView* result =
          new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
          JSGenericTypedArrayView(vm, context);
<span class="line-new-header">--- 45,17 ---</span>
  {
  }
  
  template&lt;typename Adaptor&gt;
  JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::create(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      ConstructionContext context(vm, structure, length, sizeof(typename Adaptor::Type));
      if (!context) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
      JSGenericTypedArrayView* result =
          new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
          JSGenericTypedArrayView(vm, context);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 62,32 ***</span>
      return result;
  }
  
  template&lt;typename Adaptor&gt;
  JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::createWithFastVector(
<span class="line-modified">!     ExecState* exec, Structure* structure, unsigned length, void* vector)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      ConstructionContext context(structure, length, vector);
      RELEASE_ASSERT(context);
      JSGenericTypedArrayView* result =
          new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
          JSGenericTypedArrayView(vm, context);
      result-&gt;finishCreation(vm);
      return result;
  }
  
  template&lt;typename Adaptor&gt;
<span class="line-modified">! JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::createUninitialized(ExecState* exec, Structure* structure, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      ConstructionContext context(
          vm, structure, length, sizeof(typename Adaptor::Type),
          ConstructionContext::DontInitialize);
      if (!context) {
<span class="line-modified">!         throwOutOfMemoryError(exec, scope);</span>
          return nullptr;
      }
      JSGenericTypedArrayView* result =
          new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
          JSGenericTypedArrayView(vm, context);
<span class="line-new-header">--- 63,32 ---</span>
      return result;
  }
  
  template&lt;typename Adaptor&gt;
  JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::createWithFastVector(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, unsigned length, void* vector)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      ConstructionContext context(structure, length, vector);
      RELEASE_ASSERT(context);
      JSGenericTypedArrayView* result =
          new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
          JSGenericTypedArrayView(vm, context);
      result-&gt;finishCreation(vm);
      return result;
  }
  
  template&lt;typename Adaptor&gt;
<span class="line-modified">! JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::createUninitialized(JSGlobalObject* globalObject, Structure* structure, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      ConstructionContext context(
          vm, structure, length, sizeof(typename Adaptor::Type),
          ConstructionContext::DontInitialize);
      if (!context) {
<span class="line-modified">!         throwOutOfMemoryError(globalObject, scope);</span>
          return nullptr;
      }
      JSGenericTypedArrayView* result =
          new (NotNull, allocateCell&lt;JSGenericTypedArrayView&gt;(vm.heap))
          JSGenericTypedArrayView(vm, context);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 95,23 ***</span>
      return result;
  }
  
  template&lt;typename Adaptor&gt;
  JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::create(
<span class="line-modified">!     ExecState* exec, Structure* structure, RefPtr&lt;ArrayBuffer&gt;&amp;&amp; buffer,</span>
      unsigned byteOffset, unsigned length)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      size_t size = sizeof(typename Adaptor::Type);
      ASSERT(buffer);
      if (!ArrayBufferView::verifySubRangeLength(*buffer, byteOffset, length, size)) {
<span class="line-modified">!         throwException(exec, scope, createRangeError(exec, &quot;Length out of range of buffer&quot;));</span>
          return nullptr;
      }
      if (!ArrayBufferView::verifyByteOffsetAlignment(byteOffset, size)) {
<span class="line-modified">!         throwException(exec, scope, createRangeError(exec, &quot;Byte offset is not aligned&quot;));</span>
          return nullptr;
      }
      ConstructionContext context(vm, structure, WTFMove(buffer), byteOffset, length);
      ASSERT(context);
      JSGenericTypedArrayView* result =
<span class="line-new-header">--- 96,23 ---</span>
      return result;
  }
  
  template&lt;typename Adaptor&gt;
  JSGenericTypedArrayView&lt;Adaptor&gt;* JSGenericTypedArrayView&lt;Adaptor&gt;::create(
<span class="line-modified">!     JSGlobalObject* globalObject, Structure* structure, RefPtr&lt;ArrayBuffer&gt;&amp;&amp; buffer,</span>
      unsigned byteOffset, unsigned length)
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      size_t size = sizeof(typename Adaptor::Type);
      ASSERT(buffer);
      if (!ArrayBufferView::verifySubRangeLength(*buffer, byteOffset, length, size)) {
<span class="line-modified">!         throwException(globalObject, scope, createRangeError(globalObject, &quot;Length out of range of buffer&quot;));</span>
          return nullptr;
      }
      if (!ArrayBufferView::verifyByteOffsetAlignment(byteOffset, size)) {
<span class="line-modified">!         throwException(globalObject, scope, createRangeError(globalObject, &quot;Byte offset is not aligned&quot;));</span>
          return nullptr;
      }
      ConstructionContext context(vm, structure, WTFMove(buffer), byteOffset, length);
      ASSERT(context);
      JSGenericTypedArrayView* result =
</pre>
<hr />
<pre>
<span class="line-old-header">*** 142,25 ***</span>
      return create(globalObject-&gt;vm(), structure, WTFMove(impl));
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::validateRange(
<span class="line-modified">!     ExecState* exec, unsigned offset, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (canAccessRangeQuickly(offset, length))
          return true;
  
<span class="line-modified">!     throwException(exec, scope, createRangeError(exec, &quot;Range consisting of offset and length are out of bounds&quot;));</span>
      return false;
  }
  
  template&lt;typename Adaptor&gt;
  template&lt;typename OtherAdaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::setWithSpecificType(
<span class="line-modified">!     ExecState* exec, unsigned offset, JSGenericTypedArrayView&lt;OtherAdaptor&gt;* other,</span>
      unsigned otherOffset, unsigned length, CopyType type)
  {
      // Handle the hilarious case: the act of getting the length could have resulted
      // in neutering. Well, no. That&#39;ll never happen because there cannot be
      // side-effects on getting the length of a typed array. But predicting where there
<span class="line-new-header">--- 143,25 ---</span>
      return create(globalObject-&gt;vm(), structure, WTFMove(impl));
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::validateRange(
<span class="line-modified">!     JSGlobalObject* globalObject, unsigned offset, unsigned length)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (canAccessRangeQuickly(offset, length))
          return true;
  
<span class="line-modified">!     throwException(globalObject, scope, createRangeError(globalObject, &quot;Range consisting of offset and length are out of bounds&quot;));</span>
      return false;
  }
  
  template&lt;typename Adaptor&gt;
  template&lt;typename OtherAdaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::setWithSpecificType(
<span class="line-modified">!     JSGlobalObject* globalObject, unsigned offset, JSGenericTypedArrayView&lt;OtherAdaptor&gt;* other,</span>
      unsigned otherOffset, unsigned length, CopyType type)
  {
      // Handle the hilarious case: the act of getting the length could have resulted
      // in neutering. Well, no. That&#39;ll never happen because there cannot be
      // side-effects on getting the length of a typed array. But predicting where there
</pre>
<hr />
<pre>
<span class="line-old-header">*** 168,11 ***</span>
      // check. Worst case, if we&#39;re wrong, people start seeing less things get copied
      // but we won&#39;t have a security vulnerability.
      length = std::min(length, other-&gt;length());
  
      RELEASE_ASSERT(other-&gt;canAccessRangeQuickly(otherOffset, length));
<span class="line-modified">!     if (!validateRange(exec, offset, length))</span>
          return false;
  
      // This method doesn&#39;t support copying between the same array. Note that
      // set() will only call this if the types differ, which implicitly guarantees
      // that we can&#39;t be the same array. This is relevant because the way we detect
<span class="line-new-header">--- 169,11 ---</span>
      // check. Worst case, if we&#39;re wrong, people start seeing less things get copied
      // but we won&#39;t have a security vulnerability.
      length = std::min(length, other-&gt;length());
  
      RELEASE_ASSERT(other-&gt;canAccessRangeQuickly(otherOffset, length));
<span class="line-modified">!     if (!validateRange(globalObject, offset, length))</span>
          return false;
  
      // This method doesn&#39;t support copying between the same array. Note that
      // set() will only call this if the types differ, which implicitly guarantees
      // that we can&#39;t be the same array. This is relevant because the way we detect
</pre>
<hr />
<pre>
<span class="line-old-header">*** 237,23 ***</span>
      return true;
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::set(
<span class="line-modified">!     ExecState* exec, unsigned offset, JSObject* object, unsigned objectOffset, unsigned length, CopyType type)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      const ClassInfo* ci = object-&gt;classInfo(vm);
      if (ci-&gt;typedArrayStorageType == Adaptor::typeValue) {
          // The super fast case: we can just memcpy since we&#39;re the same type.
          JSGenericTypedArrayView* other = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
          length = std::min(length, other-&gt;length());
  
          RELEASE_ASSERT(other-&gt;canAccessRangeQuickly(objectOffset, length));
<span class="line-modified">!         bool success = validateRange(exec, offset, length);</span>
          EXCEPTION_ASSERT(!scope.exception() == success);
          if (!success)
              return false;
  
          memmove(typedVector() + offset, other-&gt;typedVector() + objectOffset, length * elementSize);
<span class="line-new-header">--- 238,23 ---</span>
      return true;
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::set(
<span class="line-modified">!     JSGlobalObject* globalObject, unsigned offset, JSObject* object, unsigned objectOffset, unsigned length, CopyType type)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      const ClassInfo* ci = object-&gt;classInfo(vm);
      if (ci-&gt;typedArrayStorageType == Adaptor::typeValue) {
          // The super fast case: we can just memcpy since we&#39;re the same type.
          JSGenericTypedArrayView* other = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
          length = std::min(length, other-&gt;length());
  
          RELEASE_ASSERT(other-&gt;canAccessRangeQuickly(objectOffset, length));
<span class="line-modified">!         bool success = validateRange(globalObject, offset, length);</span>
          EXCEPTION_ASSERT(!scope.exception() == success);
          if (!success)
              return false;
  
          memmove(typedVector() + offset, other-&gt;typedVector() + objectOffset, length * elementSize);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,47 ***</span>
      }
  
      switch (ci-&gt;typedArrayStorageType) {
      case TypeInt8:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Int8Adaptor&gt;(
<span class="line-modified">!             exec, offset, jsCast&lt;JSInt8Array*&gt;(object), objectOffset, length, type));</span>
      case TypeInt16:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Int16Adaptor&gt;(
<span class="line-modified">!             exec, offset, jsCast&lt;JSInt16Array*&gt;(object), objectOffset, length, type));</span>
      case TypeInt32:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Int32Adaptor&gt;(
<span class="line-modified">!             exec, offset, jsCast&lt;JSInt32Array*&gt;(object), objectOffset, length, type));</span>
      case TypeUint8:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint8Adaptor&gt;(
<span class="line-modified">!             exec, offset, jsCast&lt;JSUint8Array*&gt;(object), objectOffset, length, type));</span>
      case TypeUint8Clamped:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint8ClampedAdaptor&gt;(
<span class="line-modified">!             exec, offset, jsCast&lt;JSUint8ClampedArray*&gt;(object), objectOffset, length, type));</span>
      case TypeUint16:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint16Adaptor&gt;(
<span class="line-modified">!             exec, offset, jsCast&lt;JSUint16Array*&gt;(object), objectOffset, length, type));</span>
      case TypeUint32:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint32Adaptor&gt;(
<span class="line-modified">!             exec, offset, jsCast&lt;JSUint32Array*&gt;(object), objectOffset, length, type));</span>
      case TypeFloat32:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Float32Adaptor&gt;(
<span class="line-modified">!             exec, offset, jsCast&lt;JSFloat32Array*&gt;(object), objectOffset, length, type));</span>
      case TypeFloat64:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Float64Adaptor&gt;(
<span class="line-modified">!             exec, offset, jsCast&lt;JSFloat64Array*&gt;(object), objectOffset, length, type));</span>
      case NotTypedArray:
      case TypeDataView: {
<span class="line-modified">!         bool success = validateRange(exec, offset, length);</span>
          EXCEPTION_ASSERT(!scope.exception() == success);
          if (!success)
              return false;
  
          // We could optimize this case. But right now, we don&#39;t.
          for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">!             JSValue value = object-&gt;get(exec, i + objectOffset);</span>
              RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!             bool success = setIndex(exec, offset + i, value);</span>
              EXCEPTION_ASSERT(!scope.exception() || !success);
              if (!success)
                  return false;
          }
          return true;
<span class="line-new-header">--- 262,47 ---</span>
      }
  
      switch (ci-&gt;typedArrayStorageType) {
      case TypeInt8:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Int8Adaptor&gt;(
<span class="line-modified">!             globalObject, offset, jsCast&lt;JSInt8Array*&gt;(object), objectOffset, length, type));</span>
      case TypeInt16:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Int16Adaptor&gt;(
<span class="line-modified">!             globalObject, offset, jsCast&lt;JSInt16Array*&gt;(object), objectOffset, length, type));</span>
      case TypeInt32:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Int32Adaptor&gt;(
<span class="line-modified">!             globalObject, offset, jsCast&lt;JSInt32Array*&gt;(object), objectOffset, length, type));</span>
      case TypeUint8:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint8Adaptor&gt;(
<span class="line-modified">!             globalObject, offset, jsCast&lt;JSUint8Array*&gt;(object), objectOffset, length, type));</span>
      case TypeUint8Clamped:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint8ClampedAdaptor&gt;(
<span class="line-modified">!             globalObject, offset, jsCast&lt;JSUint8ClampedArray*&gt;(object), objectOffset, length, type));</span>
      case TypeUint16:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint16Adaptor&gt;(
<span class="line-modified">!             globalObject, offset, jsCast&lt;JSUint16Array*&gt;(object), objectOffset, length, type));</span>
      case TypeUint32:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Uint32Adaptor&gt;(
<span class="line-modified">!             globalObject, offset, jsCast&lt;JSUint32Array*&gt;(object), objectOffset, length, type));</span>
      case TypeFloat32:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Float32Adaptor&gt;(
<span class="line-modified">!             globalObject, offset, jsCast&lt;JSFloat32Array*&gt;(object), objectOffset, length, type));</span>
      case TypeFloat64:
          RELEASE_AND_RETURN(scope, setWithSpecificType&lt;Float64Adaptor&gt;(
<span class="line-modified">!             globalObject, offset, jsCast&lt;JSFloat64Array*&gt;(object), objectOffset, length, type));</span>
      case NotTypedArray:
      case TypeDataView: {
<span class="line-modified">!         bool success = validateRange(globalObject, offset, length);</span>
          EXCEPTION_ASSERT(!scope.exception() == success);
          if (!success)
              return false;
  
          // We could optimize this case. But right now, we don&#39;t.
          for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified">!             JSValue value = object-&gt;get(globalObject, i + objectOffset);</span>
              RETURN_IF_EXCEPTION(scope, false);
<span class="line-modified">!             bool success = setIndex(globalObject, offset + i, value);</span>
              EXCEPTION_ASSERT(!scope.exception() || !success);
              if (!success)
                  return false;
          }
          return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 328,21 ***</span>
  {
      return existingBufferInButterfly();
  }
  
  template&lt;typename Adaptor&gt;
<span class="line-modified">! EncodedJSValue JSGenericTypedArrayView&lt;Adaptor&gt;::throwNeuteredTypedArrayTypeError(ExecState* exec, EncodedJSValue object, PropertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      ASSERT_UNUSED(object, jsCast&lt;JSGenericTypedArrayView*&gt;(JSValue::decode(object))-&gt;isNeutered());
<span class="line-modified">!     return throwVMTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::getOwnPropertySlot(
<span class="line-modified">!     JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
  
      if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
          if (thisObject-&gt;isNeutered()) {
<span class="line-new-header">--- 329,21 ---</span>
  {
      return existingBufferInButterfly();
  }
  
  template&lt;typename Adaptor&gt;
<span class="line-modified">! EncodedJSValue JSGenericTypedArrayView&lt;Adaptor&gt;::throwNeuteredTypedArrayTypeError(JSGlobalObject* globalObject, EncodedJSValue object, PropertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      ASSERT_UNUSED(object, jsCast&lt;JSGenericTypedArrayView*&gt;(JSValue::decode(object))-&gt;isNeutered());
<span class="line-modified">!     return throwVMTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::getOwnPropertySlot(
<span class="line-modified">!     JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
  
      if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
          if (thisObject-&gt;isNeutered()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 365,51 ***</span>
          }
  
          return false;
      }
  
<span class="line-modified">!     return Base::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::put(
<span class="line-modified">!     JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value,</span>
      PutPropertySlot&amp; slot)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
  
      // https://tc39.github.io/ecma262/#sec-integer-indexed-exotic-objects-set-p-v-receiver
      // Ignore the receiver even if the receiver is altered to non base value.
      // 9.4.5.5-2-b-i Return ? IntegerIndexedElementSet(O, numericIndex, V).
      if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, putByIndex(thisObject, exec, index.value(), value, slot.isStrictMode()));</span>
  
      if (isCanonicalNumericIndexString(propertyName)) {
          if (thisObject-&gt;isNeutered())
<span class="line-modified">!             throwTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
          return false;
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::put(thisObject, exec, propertyName, value, slot));</span>
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::defineOwnProperty(
<span class="line-modified">!     JSObject* object, ExecState* exec, PropertyName propertyName,</span>
      const PropertyDescriptor&amp; descriptor, bool shouldThrow)
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
  
      if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
          auto throwTypeErrorIfNeeded = [&amp;] (const char* errorMessage) -&gt; bool {
              if (shouldThrow)
<span class="line-modified">!                 throwTypeError(exec, scope, makeString(errorMessage, *index));</span>
              return false;
          };
  
          if (index.value() &gt;= thisObject-&gt;m_length)
              return false;
<span class="line-new-header">--- 366,51 ---</span>
          }
  
          return false;
      }
  
<span class="line-modified">!     return Base::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);</span>
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::put(
<span class="line-modified">!     JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value,</span>
      PutPropertySlot&amp; slot)
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
  
      // https://tc39.github.io/ecma262/#sec-integer-indexed-exotic-objects-set-p-v-receiver
      // Ignore the receiver even if the receiver is altered to non base value.
      // 9.4.5.5-2-b-i Return ? IntegerIndexedElementSet(O, numericIndex, V).
      if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">!         RELEASE_AND_RETURN(scope, putByIndex(thisObject, globalObject, index.value(), value, slot.isStrictMode()));</span>
  
      if (isCanonicalNumericIndexString(propertyName)) {
          if (thisObject-&gt;isNeutered())
<span class="line-modified">!             throwTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
          return false;
      }
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::put(thisObject, globalObject, propertyName, value, slot));</span>
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::defineOwnProperty(
<span class="line-modified">!     JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName,</span>
      const PropertyDescriptor&amp; descriptor, bool shouldThrow)
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
  
      if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName)) {
          auto throwTypeErrorIfNeeded = [&amp;] (const char* errorMessage) -&gt; bool {
              if (shouldThrow)
<span class="line-modified">!                 throwTypeError(globalObject, scope, makeString(errorMessage, *index));</span>
              return false;
          };
  
          if (index.value() &gt;= thisObject-&gt;m_length)
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 422,41 ***</span>
  
          if (!descriptor.enumerable() || !descriptor.writable())
              return throwTypeErrorIfNeeded(&quot;Attempting to store non-enumerable or non-writable property on a typed array at index: &quot;);
  
          if (descriptor.value())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, thisObject-&gt;putByIndex(thisObject, exec, index.value(), descriptor.value(), shouldThrow));</span>
  
          return true;
      }
  
      if (isCanonicalNumericIndexString(propertyName))
          return false;
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow));</span>
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::deleteProperty(
<span class="line-modified">!     JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
  
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return typeError(exec, scope, true, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      if (parseIndex(propertyName))
          return false;
  
<span class="line-modified">!     return Base::deleteProperty(thisObject, exec, propertyName);</span>
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::getOwnPropertySlotByIndex(
<span class="line-modified">!     JSObject* object, ExecState*, unsigned propertyName, PropertySlot&amp; slot)</span>
  {
      JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
  
      if (thisObject-&gt;isNeutered()) {
          slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), throwNeuteredTypedArrayTypeError);
<span class="line-new-header">--- 423,41 ---</span>
  
          if (!descriptor.enumerable() || !descriptor.writable())
              return throwTypeErrorIfNeeded(&quot;Attempting to store non-enumerable or non-writable property on a typed array at index: &quot;);
  
          if (descriptor.value())
<span class="line-modified">!             RELEASE_AND_RETURN(scope, thisObject-&gt;putByIndex(thisObject, globalObject, index.value(), descriptor.value(), shouldThrow));</span>
  
          return true;
      }
  
      if (isCanonicalNumericIndexString(propertyName))
          return false;
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, Base::defineOwnProperty(thisObject, globalObject, propertyName, descriptor, shouldThrow));</span>
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::deleteProperty(
<span class="line-modified">!     JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
  
      if (thisObject-&gt;isNeutered())
<span class="line-modified">!         return typeError(globalObject, scope, true, typedArrayBufferHasBeenDetachedErrorMessage);</span>
  
      if (parseIndex(propertyName))
          return false;
  
<span class="line-modified">!     return Base::deleteProperty(thisObject, globalObject, propertyName);</span>
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::getOwnPropertySlotByIndex(
<span class="line-modified">!     JSObject* object, JSGlobalObject*, unsigned propertyName, PropertySlot&amp; slot)</span>
  {
      JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
  
      if (thisObject-&gt;isNeutered()) {
          slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(PropertyAttribute::None), throwNeuteredTypedArrayTypeError);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 470,37 ***</span>
      return true;
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::putByIndex(
<span class="line-modified">!     JSCell* cell, ExecState* exec, unsigned propertyName, JSValue value, bool)</span>
  {
      JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
<span class="line-modified">!     return thisObject-&gt;setIndex(exec, propertyName, value);</span>
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::deletePropertyByIndex(
<span class="line-modified">!     JSCell* cell, ExecState* exec, unsigned propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     return cell-&gt;methodTable(vm)-&gt;deleteProperty(cell, exec, Identifier::from(vm, propertyName));</span>
  }
  
  template&lt;typename Adaptor&gt;
  void JSGenericTypedArrayView&lt;Adaptor&gt;::getOwnPropertyNames(
<span class="line-modified">!     JSObject* object, ExecState* exec, PropertyNameArray&amp; array, EnumerationMode mode)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
  
      if (array.includeStringProperties()) {
          for (unsigned i = 0; i &lt; thisObject-&gt;m_length; ++i)
              array.add(Identifier::from(vm, i));
      }
  
<span class="line-modified">!     return Base::getOwnPropertyNames(object, exec, array, mode);</span>
  }
  
  template&lt;typename Adaptor&gt;
  size_t JSGenericTypedArrayView&lt;Adaptor&gt;::estimatedSize(JSCell* cell, VM&amp; vm)
  {
<span class="line-new-header">--- 471,37 ---</span>
      return true;
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::putByIndex(
<span class="line-modified">!     JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName, JSValue value, bool)</span>
  {
      JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(cell);
<span class="line-modified">!     return thisObject-&gt;setIndex(globalObject, propertyName, value);</span>
  }
  
  template&lt;typename Adaptor&gt;
  bool JSGenericTypedArrayView&lt;Adaptor&gt;::deletePropertyByIndex(
<span class="line-modified">!     JSCell* cell, JSGlobalObject* globalObject, unsigned propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     return cell-&gt;methodTable(vm)-&gt;deleteProperty(cell, globalObject, Identifier::from(vm, propertyName));</span>
  }
  
  template&lt;typename Adaptor&gt;
  void JSGenericTypedArrayView&lt;Adaptor&gt;::getOwnPropertyNames(
<span class="line-modified">!     JSObject* object, JSGlobalObject* globalObject, PropertyNameArray&amp; array, EnumerationMode mode)</span>
  {
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      JSGenericTypedArrayView* thisObject = jsCast&lt;JSGenericTypedArrayView*&gt;(object);
  
      if (array.includeStringProperties()) {
          for (unsigned i = 0; i &lt; thisObject-&gt;m_length; ++i)
              array.add(Identifier::from(vm, i));
      }
  
<span class="line-modified">!     return Base::getOwnPropertyNames(object, globalObject, array, mode);</span>
  }
  
  template&lt;typename Adaptor&gt;
  size_t JSGenericTypedArrayView&lt;Adaptor&gt;::estimatedSize(JSCell* cell, VM&amp; vm)
  {
</pre>
<center><a href="JSGenericTypedArrayViewConstructorInlines.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGenericTypedArrayViewPrototypeFunctions.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
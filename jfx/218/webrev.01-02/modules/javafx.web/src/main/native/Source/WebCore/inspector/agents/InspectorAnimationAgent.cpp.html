<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorAnimationAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorAnimationAgent.h&quot;
 28 
 29 #include &quot;AnimationEffect.h&quot;
 30 #include &quot;AnimationEffectPhase.h&quot;
 31 #include &quot;CSSAnimation.h&quot;
 32 #include &quot;CSSComputedStyleDeclaration.h&quot;
 33 #include &quot;CSSPropertyNames.h&quot;
 34 #include &quot;CSSTransition.h&quot;
 35 #include &quot;CSSValue.h&quot;
 36 #include &quot;DeclarativeAnimation.h&quot;
 37 #include &quot;Element.h&quot;
 38 #include &quot;Event.h&quot;
 39 #include &quot;FillMode.h&quot;
 40 #include &quot;Frame.h&quot;
 41 #include &quot;InspectorDOMAgent.h&quot;
 42 #include &quot;InstrumentingAgents.h&quot;
 43 #include &quot;JSExecState.h&quot;
 44 #include &quot;JSWebAnimation.h&quot;
 45 #include &quot;KeyframeEffect.h&quot;
 46 #include &quot;KeyframeList.h&quot;
 47 #include &quot;Page.h&quot;
 48 #include &quot;PlaybackDirection.h&quot;
 49 #include &quot;RenderElement.h&quot;
 50 #include &quot;TimingFunction.h&quot;
 51 #include &quot;WebAnimation.h&quot;
 52 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 53 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
 54 #include &lt;JavaScriptCore/InspectorEnvironment.h&gt;
 55 #include &lt;JavaScriptCore/ScriptCallStackFactory.h&gt;
 56 #include &lt;wtf/HashMap.h&gt;
 57 #include &lt;wtf/Optional.h&gt;
 58 #include &lt;wtf/Seconds.h&gt;
 59 #include &lt;wtf/Stopwatch.h&gt;
 60 #include &lt;wtf/Vector.h&gt;
 61 #include &lt;wtf/text/StringBuilder.h&gt;
 62 #include &lt;wtf/text/WTFString.h&gt;
 63 
 64 namespace WebCore {
 65 
 66 using namespace Inspector;
 67 
 68 static Optional&lt;double&gt; protocolValueForSeconds(const Seconds&amp; seconds)
 69 {
 70     if (seconds == Seconds::infinity() || seconds == Seconds::nan())
 71         return WTF::nullopt;
 72     return seconds.milliseconds();
 73 }
 74 
 75 static Optional&lt;Inspector::Protocol::Animation::PlaybackDirection&gt; protocolValueForPlaybackDirection(PlaybackDirection playbackDirection)
 76 {
 77     switch (playbackDirection) {
 78     case PlaybackDirection::Normal:
 79         return Inspector::Protocol::Animation::PlaybackDirection::Normal;
 80     case PlaybackDirection::Reverse:
 81         return Inspector::Protocol::Animation::PlaybackDirection::Reverse;
 82     case PlaybackDirection::Alternate:
 83         return Inspector::Protocol::Animation::PlaybackDirection::Alternate;
 84     case PlaybackDirection::AlternateReverse:
 85         return Inspector::Protocol::Animation::PlaybackDirection::AlternateReverse;
 86     }
 87 
 88     ASSERT_NOT_REACHED();
 89     return WTF::nullopt;
 90 }
 91 
 92 static Optional&lt;Inspector::Protocol::Animation::FillMode&gt; protocolValueForFillMode(FillMode fillMode)
 93 {
 94     switch (fillMode) {
 95     case FillMode::None:
 96         return Inspector::Protocol::Animation::FillMode::None;
 97     case FillMode::Forwards:
 98         return Inspector::Protocol::Animation::FillMode::Forwards;
 99     case FillMode::Backwards:
100         return Inspector::Protocol::Animation::FillMode::Backwards;
101     case FillMode::Both:
102         return Inspector::Protocol::Animation::FillMode::Both;
103     case FillMode::Auto:
104         return Inspector::Protocol::Animation::FillMode::Auto;
105     }
106 
107     ASSERT_NOT_REACHED();
108     return WTF::nullopt;
109 }
110 
111 static Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::Animation::Keyframe&gt;&gt; buildObjectForKeyframes(KeyframeEffect&amp; keyframeEffect)
112 {
113     auto keyframesPayload = JSON::ArrayOf&lt;Inspector::Protocol::Animation::Keyframe&gt;::create();
114 
115     const auto&amp; blendingKeyframes = keyframeEffect.blendingKeyframes();
116     const auto&amp; parsedKeyframes = keyframeEffect.parsedKeyframes();
117 
118     if (is&lt;DeclarativeAnimation&gt;(keyframeEffect.animation())) {
119         ASSERT(keyframeEffect.target());
120         auto* renderer = keyframeEffect.target()-&gt;renderer();
121 
122         // Synthesize CSS style declarations for each keyframe so the frontend can display them.
123         ComputedStyleExtractor computedStyleExtractor(keyframeEffect.target());
124 
125         for (size_t i = 0; i &lt; blendingKeyframes.size(); ++i) {
126             auto&amp; blendingKeyframe = blendingKeyframes[i];
127 
128             ASSERT(blendingKeyframe.style());
129             auto&amp; style = *blendingKeyframe.style();
130 
131             auto keyframePayload = Inspector::Protocol::Animation::Keyframe::create()
132                 .setOffset(blendingKeyframe.key())
133                 .release();
134 
135             RefPtr&lt;TimingFunction&gt; timingFunction;
136             if (!parsedKeyframes.isEmpty())
137                 timingFunction = parsedKeyframes[i].timingFunction;
138             if (!timingFunction)
139                 timingFunction = blendingKeyframe.timingFunction();
140             if (!timingFunction)
141                 timingFunction = downcast&lt;DeclarativeAnimation&gt;(*keyframeEffect.animation()).backingAnimation().timingFunction();
142             if (timingFunction)
143                 keyframePayload-&gt;setEasing(timingFunction-&gt;cssText());
144 
145             StringBuilder stylePayloadBuilder;
146             auto&amp; cssPropertyIds = blendingKeyframe.properties();
147             size_t count = cssPropertyIds.size();
148             for (auto cssPropertyId : cssPropertyIds) {
149                 --count;
150                 if (cssPropertyId == CSSPropertyCustom)
151                     continue;
152 
153                 stylePayloadBuilder.append(getPropertyNameString(cssPropertyId));
154                 stylePayloadBuilder.append(&quot;: &quot;);
155                 if (auto value = computedStyleExtractor.valueForPropertyInStyle(style, cssPropertyId, renderer))
156                     stylePayloadBuilder.append(value-&gt;cssText());
157                 stylePayloadBuilder.append(&#39;;&#39;);
158                 if (count &gt; 0)
159                     stylePayloadBuilder.append(&#39; &#39;);
160             }
161             if (!stylePayloadBuilder.isEmpty())
162                 keyframePayload-&gt;setStyle(stylePayloadBuilder.toString());
163 
164             keyframesPayload-&gt;addItem(WTFMove(keyframePayload));
165         }
166     } else {
167         for (const auto&amp; parsedKeyframe : parsedKeyframes) {
168             auto keyframePayload = Inspector::Protocol::Animation::Keyframe::create()
169                 .setOffset(parsedKeyframe.computedOffset)
170                 .release();
171 
172             if (!parsedKeyframe.easing.isEmpty())
173                 keyframePayload-&gt;setEasing(parsedKeyframe.easing);
174             else if (const auto&amp; timingFunction = parsedKeyframe.timingFunction)
175                 keyframePayload-&gt;setEasing(timingFunction-&gt;cssText());
176 
177             if (!parsedKeyframe.style-&gt;isEmpty())
178                 keyframePayload-&gt;setStyle(parsedKeyframe.style-&gt;asText());
179 
180             keyframesPayload-&gt;addItem(WTFMove(keyframePayload));
181         }
182     }
183 
184     return keyframesPayload;
185 }
186 
187 static Ref&lt;Inspector::Protocol::Animation::Effect&gt; buildObjectForEffect(AnimationEffect&amp; effect)
188 {
189     auto effectPayload = Inspector::Protocol::Animation::Effect::create()
190         .release();
191 
192     if (auto startDelay = protocolValueForSeconds(effect.delay()))
193         effectPayload-&gt;setStartDelay(startDelay.value());
194 
195     if (auto endDelay = protocolValueForSeconds(effect.endDelay()))
196         effectPayload-&gt;setEndDelay(endDelay.value());
197 
198     effectPayload-&gt;setIterationCount(effect.iterations());
199     effectPayload-&gt;setIterationStart(effect.iterationStart());
200 
201     if (auto iterationDuration = protocolValueForSeconds(effect.iterationDuration()))
202         effectPayload-&gt;setIterationDuration(iterationDuration.value());
203 
204     if (auto* timingFunction = effect.timingFunction())
205         effectPayload-&gt;setTimingFunction(timingFunction-&gt;cssText());
206 
207     if (auto playbackDirection = protocolValueForPlaybackDirection(effect.direction()))
208         effectPayload-&gt;setPlaybackDirection(playbackDirection.value());
209 
210     if (auto fillMode = protocolValueForFillMode(effect.fill()))
211         effectPayload-&gt;setFillMode(fillMode.value());
212 
213     if (is&lt;KeyframeEffect&gt;(effect))
214         effectPayload-&gt;setKeyframes(buildObjectForKeyframes(downcast&lt;KeyframeEffect&gt;(effect)));
215 
216     return effectPayload;
217 }
218 
219 InspectorAnimationAgent::InspectorAnimationAgent(PageAgentContext&amp; context)
220     : InspectorAgentBase(&quot;Animation&quot;_s, context)
221     , m_frontendDispatcher(makeUnique&lt;Inspector::AnimationFrontendDispatcher&gt;(context.frontendRouter))
222     , m_backendDispatcher(Inspector::AnimationBackendDispatcher::create(context.backendDispatcher, this))
223     , m_injectedScriptManager(context.injectedScriptManager)
224     , m_inspectedPage(context.inspectedPage)
225     , m_animationDestroyedTimer(*this, &amp;InspectorAnimationAgent::animationDestroyedTimerFired)
226 {
227 }
228 
229 InspectorAnimationAgent::~InspectorAnimationAgent() = default;
230 
231 void InspectorAnimationAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
232 {
233     ASSERT(m_instrumentingAgents.persistentInspectorAnimationAgent() != this);
234     m_instrumentingAgents.setPersistentInspectorAnimationAgent(this);
235 }
236 
237 void InspectorAnimationAgent::willDestroyFrontendAndBackend(DisconnectReason)
238 {
239     ErrorString ignored;
240     stopTracking(ignored);
241     disable(ignored);
242 
243     ASSERT(m_instrumentingAgents.persistentInspectorAnimationAgent() == this);
244     m_instrumentingAgents.setPersistentInspectorAnimationAgent(nullptr);
245 }
246 
247 void InspectorAnimationAgent::enable(ErrorString&amp; errorString)
248 {
249     if (m_instrumentingAgents.enabledInspectorAnimationAgent() == this) {
250         errorString = &quot;Animation domain already enabled&quot;_s;
251         return;
252     }
253 
254     m_instrumentingAgents.setEnabledInspectorAnimationAgent(this);
255 
256     const auto existsInCurrentPage = [&amp;] (ScriptExecutionContext* scriptExecutionContext) {
257         if (!is&lt;Document&gt;(scriptExecutionContext))
258             return false;
259 
260         // FIXME: &lt;https://webkit.org/b/168475&gt; Web Inspector: Correctly display iframe&#39;s WebSockets
261         auto* document = downcast&lt;Document&gt;(scriptExecutionContext);
262         return document-&gt;page() == &amp;m_inspectedPage;
263     };
264 
265     {
266         LockHolder lock(WebAnimation::instancesMutex());
267         for (auto* animation : WebAnimation::instances(lock)) {
268             if (existsInCurrentPage(animation-&gt;scriptExecutionContext()))
269                 bindAnimation(*animation, false);
270         }
271     }
272 }
273 
274 void InspectorAnimationAgent::disable(ErrorString&amp;)
275 {
276     m_instrumentingAgents.setEnabledInspectorAnimationAgent(nullptr);
277 
278     reset();
279 }
280 
281 void InspectorAnimationAgent::requestEffectTarget(ErrorString&amp; errorString, const String&amp; animationId, int* nodeId)
282 {
283     auto* animation = assertAnimation(errorString, animationId);
284     if (!animation)
285         return;
286 
287     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();
288     if (!domAgent) {
289         errorString = &quot;DOM domain must be enabled&quot;_s;
290         return;
291     }
292 
293     auto* effect = animation-&gt;effect();
294     if (!is&lt;KeyframeEffect&gt;(effect)) {
295         errorString = &quot;Animation for given animationId does not have an effect&quot;_s;
296         return;
297     }
298 
299     auto&amp; keyframeEffect = downcast&lt;KeyframeEffect&gt;(*effect);
300 
301     auto* target = keyframeEffect.target();
302     if (!target) {
303         errorString = &quot;Animation for given animationId does not have a target&quot;_s;
304         return;
305     }
306 
307     *nodeId = domAgent-&gt;pushNodePathToFrontend(errorString, target);
308 }
309 
310 void InspectorAnimationAgent::resolveAnimation(ErrorString&amp; errorString, const String&amp; animationId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
311 {
312     auto* animation = assertAnimation(errorString, animationId);
313     if (!animation)
314         return;
315 
316     auto* state = animation-&gt;scriptExecutionContext()-&gt;execState();
317     auto injectedScript = m_injectedScriptManager.injectedScriptFor(state);
318     ASSERT(!injectedScript.hasNoValue());
319 
320     JSC::JSValue value;
321     {
322         JSC::JSLockHolder lock(state);
323 
324         auto* globalObject = deprecatedGlobalObjectForPrototype(state);
325         value = toJS(state, globalObject, animation);
326     }
327 
328     if (!value) {
329         ASSERT_NOT_REACHED();
330         errorString = &quot;Internal error: unknown Animation for given animationId&quot;_s;
331         return;
332     }
333 
334     String objectGroupName = objectGroup ? *objectGroup : String();
335     result = injectedScript.wrapObject(value, objectGroupName);
336 }
337 
338 void InspectorAnimationAgent::startTracking(ErrorString&amp; errorString)
339 {
340     if (m_instrumentingAgents.trackingInspectorAnimationAgent() == this) {
341         errorString = &quot;Animation domain already tracking&quot;_s;
342         return;
343     }
344 
345     m_instrumentingAgents.setTrackingInspectorAnimationAgent(this);
346 
347     ASSERT(m_trackedDeclarativeAnimationData.isEmpty());
348 
349     m_frontendDispatcher-&gt;trackingStart(m_environment.executionStopwatch()-&gt;elapsedTime().seconds());
350 }
351 
352 void InspectorAnimationAgent::stopTracking(ErrorString&amp;)
353 {
354     if (m_instrumentingAgents.trackingInspectorAnimationAgent() != this)
355         return;
356 
357     m_instrumentingAgents.setTrackingInspectorAnimationAgent(nullptr);
358 
359     m_trackedDeclarativeAnimationData.clear();
360 
361     m_frontendDispatcher-&gt;trackingComplete(m_environment.executionStopwatch()-&gt;elapsedTime().seconds());
362 }
363 
364 static bool isDelayed(ComputedEffectTiming&amp; computedTiming)
365 {
366     if (!computedTiming.localTime)
367         return false;
368     return computedTiming.localTime.value() &lt; (computedTiming.endTime - computedTiming.activeDuration);
369 }
370 
371 void InspectorAnimationAgent::willApplyKeyframeEffect(Element&amp; target, KeyframeEffect&amp; keyframeEffect, ComputedEffectTiming computedTiming)
372 {
373     auto* animation = keyframeEffect.animation();
374     if (!is&lt;DeclarativeAnimation&gt;(animation))
375         return;
376 
377     auto ensureResult = m_trackedDeclarativeAnimationData.ensure(downcast&lt;DeclarativeAnimation&gt;(animation), [&amp;] () -&gt; TrackedDeclarativeAnimationData {
378         return { makeString(&quot;animation:&quot;_s, IdentifiersFactory::createIdentifier()), computedTiming };
379     });
380     auto&amp; trackingData = ensureResult.iterator-&gt;value;
381 
382     Optional&lt;Inspector::Protocol::Animation::AnimationState&gt; animationAnimationState;
383 
384     if ((ensureResult.isNewEntry || !isDelayed(trackingData.lastComputedTiming)) &amp;&amp; isDelayed(computedTiming))
385         animationAnimationState = Inspector::Protocol::Animation::AnimationState::Delayed;
386     else if (ensureResult.isNewEntry || trackingData.lastComputedTiming.phase != computedTiming.phase) {
387         switch (computedTiming.phase) {
388         case AnimationEffectPhase::Before:
389             animationAnimationState = Inspector::Protocol::Animation::AnimationState::Ready;
390             break;
391 
392         case AnimationEffectPhase::Active:
393             animationAnimationState = Inspector::Protocol::Animation::AnimationState::Active;
394             break;
395 
396         case AnimationEffectPhase::After:
397             animationAnimationState = Inspector::Protocol::Animation::AnimationState::Done;
398             break;
399 
400         case AnimationEffectPhase::Idle:
401             animationAnimationState = Inspector::Protocol::Animation::AnimationState::Canceled;
402             break;
403         }
404     } else if (trackingData.lastComputedTiming.currentIteration != computedTiming.currentIteration) {
405         // Iterations are represented by sequential &quot;active&quot; state events.
406         animationAnimationState = Inspector::Protocol::Animation::AnimationState::Active;
407     }
408 
409     trackingData.lastComputedTiming = computedTiming;
410 
411     if (!animationAnimationState)
412         return;
413 
414     auto event = Inspector::Protocol::Animation::TrackingUpdate::create()
415         .setTrackingAnimationId(trackingData.trackingAnimationId)
416         .setAnimationState(animationAnimationState.value())
417         .release();
418 
419     if (ensureResult.isNewEntry) {
420         if (auto* domAgent = m_instrumentingAgents.inspectorDOMAgent()) {
421             if (auto nodeId = domAgent-&gt;pushNodeToFrontend(&amp;target))
422                 event-&gt;setNodeId(nodeId);
423         }
424 
425         if (is&lt;CSSAnimation&gt;(animation))
426             event-&gt;setAnimationName(downcast&lt;CSSAnimation&gt;(*animation).animationName());
427         else if (is&lt;CSSTransition&gt;(animation))
428             event-&gt;setTransitionProperty(downcast&lt;CSSTransition&gt;(*animation).transitionProperty());
429         else
430             ASSERT_NOT_REACHED();
431     }
432 
433     m_frontendDispatcher-&gt;trackingUpdate(m_environment.executionStopwatch()-&gt;elapsedTime().seconds(), WTFMove(event));
434 }
435 
436 void InspectorAnimationAgent::didSetWebAnimationEffect(WebAnimation&amp; animation)
437 {
438     if (is&lt;DeclarativeAnimation&gt;(animation))
439         stopTrackingDeclarativeAnimation(downcast&lt;DeclarativeAnimation&gt;(animation));
440 
441     didChangeWebAnimationEffectTiming(animation);
442     didChangeWebAnimationEffectTarget(animation);
443 }
444 
445 void InspectorAnimationAgent::didChangeWebAnimationEffectTiming(WebAnimation&amp; animation)
446 {
447     // The `animationId` may be empty if Animation is tracking but not enabled.
448     auto animationId = findAnimationId(animation);
449     if (animationId.isEmpty())
450         return;
451 
452     if (auto* effect = animation.effect())
453         m_frontendDispatcher-&gt;effectChanged(animationId, buildObjectForEffect(*effect));
454     else
455         m_frontendDispatcher-&gt;effectChanged(animationId, nullptr);
456 }
457 
458 void InspectorAnimationAgent::didChangeWebAnimationEffectTarget(WebAnimation&amp; animation)
459 {
460     // The `animationId` may be empty if Animation is tracking but not enabled.
461     auto animationId = findAnimationId(animation);
462     if (animationId.isEmpty())
463         return;
464 
465     m_frontendDispatcher-&gt;targetChanged(animationId);
466 }
467 
468 void InspectorAnimationAgent::didCreateWebAnimation(WebAnimation&amp; animation)
469 {
470     if (!findAnimationId(animation).isEmpty()) {
471         ASSERT_NOT_REACHED();
472         return;
473     }
474 
475     bindAnimation(animation, true);
476 }
477 
478 void InspectorAnimationAgent::willDestroyWebAnimation(WebAnimation&amp; animation)
479 {
480     if (is&lt;DeclarativeAnimation&gt;(animation))
481         stopTrackingDeclarativeAnimation(downcast&lt;DeclarativeAnimation&gt;(animation));
482 
483     // The `animationId` may be empty if Animation is tracking but not enabled.
484     auto animationId = findAnimationId(animation);
485     if (!animationId.isEmpty())
486         unbindAnimation(animationId);
487 }
488 
489 void InspectorAnimationAgent::frameNavigated(Frame&amp; frame)
490 {
491     if (frame.isMainFrame()) {
492         reset();
493         return;
494     }
495 
496     Vector&lt;String&gt; animationIdsToRemove;
497     for (auto&amp; [animationId, animation] : m_animationIdMap) {
498         if (auto* scriptExecutionContext = animation-&gt;scriptExecutionContext()) {
499             if (is&lt;Document&gt;(scriptExecutionContext) &amp;&amp; downcast&lt;Document&gt;(*scriptExecutionContext).frame() == &amp;frame)
500                 animationIdsToRemove.append(animationId);
501         }
502     }
503     for (const auto&amp; animationId : animationIdsToRemove)
504         unbindAnimation(animationId);
505 }
506 
507 String InspectorAnimationAgent::findAnimationId(WebAnimation&amp; animation)
508 {
509     for (auto&amp; [animationId, existingAnimation] : m_animationIdMap) {
510         if (existingAnimation == &amp;animation)
511             return animationId;
512     }
513     return nullString();
514 }
515 
516 WebAnimation* InspectorAnimationAgent::assertAnimation(ErrorString&amp; errorString, const String&amp; animationId)
517 {
518     auto* animation = m_animationIdMap.get(animationId);
519     if (!animation)
520         errorString = &quot;Missing animation for given animationId&quot;_s;
521     return animation;
522 }
523 
524 void InspectorAnimationAgent::bindAnimation(WebAnimation&amp; animation, bool captureBacktrace)
525 {
526     auto animationId = makeString(&quot;animation:&quot; + IdentifiersFactory::createIdentifier());
527     m_animationIdMap.set(animationId, &amp;animation);
528 
529     auto animationPayload = Inspector::Protocol::Animation::Animation::create()
530         .setAnimationId(animationId)
531         .release();
532 
533     if (is&lt;CSSAnimation&gt;(animation))
534         animationPayload-&gt;setCssAnimationName(downcast&lt;CSSAnimation&gt;(animation).animationName());
535     else if (is&lt;CSSTransition&gt;(animation))
536         animationPayload-&gt;setCssTransitionProperty(downcast&lt;CSSTransition&gt;(animation).transitionProperty());
537 
538     if (auto* effect = animation.effect())
539         animationPayload-&gt;setEffect(buildObjectForEffect(*effect));
540 
541     if (captureBacktrace) {
542         auto stackTrace = Inspector::createScriptCallStack(JSExecState::currentState(), Inspector::ScriptCallStack::maxCallStackSizeToCapture);
543         animationPayload-&gt;setBacktrace(stackTrace-&gt;buildInspectorArray());
544     }
545 
546     m_frontendDispatcher-&gt;animationCreated(WTFMove(animationPayload));
547 }
548 
549 void InspectorAnimationAgent::unbindAnimation(const String&amp; animationId)
550 {
551     m_animationIdMap.remove(animationId);
552 
553     // This can be called in response to GC. Due to the single-process model used in WebKit1, the
554     // event must be dispatched from a timer to prevent the frontend from making JS allocations
555     // while the GC is still active.
556     m_removedAnimationIds.append(animationId);
557 
558     if (!m_animationDestroyedTimer.isActive())
559         m_animationDestroyedTimer.startOneShot(0_s);
560 }
561 
562 void InspectorAnimationAgent::animationDestroyedTimerFired()
563 {
564     if (!m_removedAnimationIds.size())
565         return;
566 
567     for (auto&amp; identifier : m_removedAnimationIds)
568         m_frontendDispatcher-&gt;animationDestroyed(identifier);
569 
570     m_removedAnimationIds.clear();
571 }
572 
573 void InspectorAnimationAgent::reset()
574 {
575     m_animationIdMap.clear();
576 
577     m_removedAnimationIds.clear();
578 
579     if (m_animationDestroyedTimer.isActive())
580         m_animationDestroyedTimer.stop();
581 }
582 
583 void InspectorAnimationAgent::stopTrackingDeclarativeAnimation(DeclarativeAnimation&amp; animation)
584 {
585     auto it = m_trackedDeclarativeAnimationData.find(&amp;animation);
586     if (it == m_trackedDeclarativeAnimationData.end())
587         return;
588 
589     if (it-&gt;value.lastComputedTiming.phase != AnimationEffectPhase::After &amp;&amp; it-&gt;value.lastComputedTiming.phase != AnimationEffectPhase::Idle) {
590         auto event = Inspector::Protocol::Animation::TrackingUpdate::create()
591             .setTrackingAnimationId(it-&gt;value.trackingAnimationId)
592             .setAnimationState(Inspector::Protocol::Animation::AnimationState::Canceled)
593             .release();
594         m_frontendDispatcher-&gt;trackingUpdate(m_environment.executionStopwatch()-&gt;elapsedTime().seconds(), WTFMove(event));
595     }
596 
597     m_trackedDeclarativeAnimationData.remove(it);
598 }
599 
600 } // namespace WebCore
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/bmalloc.cpp b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/bmalloc.cpp
--- a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/bmalloc.cpp
+++ b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/bmalloc.cpp
@@ -56,12 +56,12 @@
         result = debugHeap->memalignLarge(alignment, size);
     else {
         kind = mapToActiveHeapKind(kind);
         Heap& heap = PerProcess<PerHeapKind<Heap>>::get()->at(kind);
 
-        std::unique_lock<Mutex> lock(Heap::mutex());
-        result = heap.tryAllocateLarge(lock, alignment, size);
+        UniqueLockHolder lock(Heap::mutex());
+        result = heap.allocateLarge(lock, alignment, size, FailureAction::ReturnNull);
         if (result) {
             // Don't track this as dirty memory that dictates how we drive the scavenger.
             // FIXME: We should make it so that users of this API inform bmalloc which
             // pages they dirty:
             // https://bugs.webkit.org/show_bug.cgi?id=184207
@@ -80,11 +80,11 @@
         debugHeap->freeLarge(object);
         return;
     }
     kind = mapToActiveHeapKind(kind);
     Heap& heap = PerProcess<PerHeapKind<Heap>>::get()->at(kind);
-    std::unique_lock<Mutex> lock(Heap::mutex());
+    UniqueLockHolder lock(Heap::mutex());
     // Balance out the externalDecommit when we allocated the zeroed virtual memory.
     heap.externalCommit(lock, object, size);
     heap.deallocateLarge(lock, object);
 }
 
@@ -106,11 +106,11 @@
 #if BOS(DARWIN)
 void setScavengerThreadQOSClass(qos_class_t overrideClass)
 {
     if (DebugHeap::tryGet())
         return;
-    std::unique_lock<Mutex> lock(Heap::mutex());
+    UniqueLockHolder lock(Heap::mutex());
     Scavenger::get()->setScavengerThreadQOSClass(overrideClass);
 }
 #endif
 
 void commitAlignedPhysical(void* object, size_t size, HeapKind kind)

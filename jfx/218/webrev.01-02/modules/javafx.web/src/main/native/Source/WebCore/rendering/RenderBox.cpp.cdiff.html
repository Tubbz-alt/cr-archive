<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderBlockFlow.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBox.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBox.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 565,31 ***</span>
  int RenderBox::scrollTop() const
  {
      return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().y() : 0;
  }
  
<span class="line-modified">! static void setupWheelEventTestTrigger(RenderLayer&amp; layer)</span>
  {
      Page&amp; page = layer.renderer().page();
<span class="line-modified">!     if (!page.expectsWheelEventTriggers())</span>
          return;
<span class="line-modified">!     layer.scrollAnimator().setWheelEventTestTrigger(page.testTrigger());</span>
  }
  
  void RenderBox::setScrollLeft(int newLeft, ScrollType scrollType, ScrollClamping clamping)
  {
      if (!hasOverflowClip() || !layer())
          return;
<span class="line-modified">!     setupWheelEventTestTrigger(*layer());</span>
      layer()-&gt;scrollToXPosition(newLeft, scrollType, clamping);
  }
  
  void RenderBox::setScrollTop(int newTop, ScrollType scrollType, ScrollClamping clamping)
  {
      if (!hasOverflowClip() || !layer())
          return;
<span class="line-modified">!     setupWheelEventTestTrigger(*layer());</span>
      layer()-&gt;scrollToYPosition(newTop, scrollType, clamping);
  }
  
  void RenderBox::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
  {
<span class="line-new-header">--- 565,37 ---</span>
  int RenderBox::scrollTop() const
  {
      return hasOverflowClip() &amp;&amp; layer() ? layer()-&gt;scrollPosition().y() : 0;
  }
  
<span class="line-modified">! void RenderBox::resetLogicalHeightBeforeLayoutIfNeeded()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (shouldResetLogicalHeightBeforeLayout() || (is&lt;RenderBlock&gt;(parent()) &amp;&amp; downcast&lt;RenderBlock&gt;(*parent()).shouldResetChildLogicalHeightBeforeLayout(*this)))</span>
<span class="line-added">+         setLogicalHeight(0_lu);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void setupWheelEventMonitor(RenderLayer&amp; layer)</span>
  {
      Page&amp; page = layer.renderer().page();
<span class="line-modified">!     if (!page.isMonitoringWheelEvents())</span>
          return;
<span class="line-modified">!     layer.scrollAnimator().setWheelEventTestMonitor(page.wheelEventTestMonitor());</span>
  }
  
  void RenderBox::setScrollLeft(int newLeft, ScrollType scrollType, ScrollClamping clamping)
  {
      if (!hasOverflowClip() || !layer())
          return;
<span class="line-modified">!     setupWheelEventMonitor(*layer());</span>
      layer()-&gt;scrollToXPosition(newLeft, scrollType, clamping);
  }
  
  void RenderBox::setScrollTop(int newTop, ScrollType scrollType, ScrollClamping clamping)
  {
      if (!hasOverflowClip() || !layer())
          return;
<span class="line-modified">!     setupWheelEventMonitor(*layer());</span>
      layer()-&gt;scrollToYPosition(newTop, scrollType, clamping);
  }
  
  void RenderBox::absoluteRects(Vector&lt;IntRect&gt;&amp; rects, const LayoutPoint&amp; accumulatedOffset) const
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 724,11 ***</span>
  
  int RenderBox::reflectionOffset() const
  {
      if (!style().boxReflect())
          return 0;
<span class="line-modified">!     if (style().boxReflect()-&gt;direction() == ReflectionLeft || style().boxReflect()-&gt;direction() == ReflectionRight)</span>
          return valueForLength(style().boxReflect()-&gt;offset(), borderBoxRect().width());
      return valueForLength(style().boxReflect()-&gt;offset(), borderBoxRect().height());
  }
  
  LayoutRect RenderBox::reflectedRect(const LayoutRect&amp; r) const
<span class="line-new-header">--- 730,11 ---</span>
  
  int RenderBox::reflectionOffset() const
  {
      if (!style().boxReflect())
          return 0;
<span class="line-modified">!     if (style().boxReflect()-&gt;direction() == ReflectionDirection::Left || style().boxReflect()-&gt;direction() == ReflectionDirection::Right)</span>
          return valueForLength(style().boxReflect()-&gt;offset(), borderBoxRect().width());
      return valueForLength(style().boxReflect()-&gt;offset(), borderBoxRect().height());
  }
  
  LayoutRect RenderBox::reflectedRect(const LayoutRect&amp; r) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 737,22 ***</span>
          return LayoutRect();
  
      LayoutRect box = borderBoxRect();
      LayoutRect result = r;
      switch (style().boxReflect()-&gt;direction()) {
<span class="line-modified">!         case ReflectionBelow:</span>
<span class="line-modified">!             result.setY(box.maxY() + reflectionOffset() + (box.maxY() - r.maxY()));</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case ReflectionAbove:</span>
<span class="line-modified">!             result.setY(box.y() - reflectionOffset() - box.height() + (box.maxY() - r.maxY()));</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case ReflectionLeft:</span>
<span class="line-modified">!             result.setX(box.x() - reflectionOffset() - box.width() + (box.maxX() - r.maxX()));</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case ReflectionRight:</span>
<span class="line-modified">!             result.setX(box.maxX() + reflectionOffset() + (box.maxX() - r.maxX()));</span>
<span class="line-modified">!             break;</span>
      }
      return result;
  }
  
  bool RenderBox::fixedElementLaysOutRelativeToFrame(const FrameView&amp; frameView) const
<span class="line-new-header">--- 743,22 ---</span>
          return LayoutRect();
  
      LayoutRect box = borderBoxRect();
      LayoutRect result = r;
      switch (style().boxReflect()-&gt;direction()) {
<span class="line-modified">!     case ReflectionDirection::Below:</span>
<span class="line-modified">!         result.setY(box.maxY() + reflectionOffset() + (box.maxY() - r.maxY()));</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     case ReflectionDirection::Above:</span>
<span class="line-modified">!         result.setY(box.y() - reflectionOffset() - box.height() + (box.maxY() - r.maxY()));</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     case ReflectionDirection::Left:</span>
<span class="line-modified">!         result.setX(box.x() - reflectionOffset() - box.width() + (box.maxX() - r.maxX()));</span>
<span class="line-modified">!         break;</span>
<span class="line-modified">!     case ReflectionDirection::Right:</span>
<span class="line-modified">!         result.setX(box.maxX() + reflectionOffset() + (box.maxX() - r.maxX()));</span>
<span class="line-modified">!         break;</span>
      }
      return result;
  }
  
  bool RenderBox::fixedElementLaysOutRelativeToFrame(const FrameView&amp; frameView) const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1319,11 ***</span>
      BackgroundBleedAvoidance bleedAvoidance = determineBackgroundBleedAvoidance(paintInfo.context());
  
      // FIXME: Should eventually give the theme control over whether the box shadow should paint, since controls could have
      // custom shadows of their own.
      if (!boxShadowShouldBeAppliedToBackground(paintRect.location(), bleedAvoidance))
<span class="line-modified">!         paintBoxShadow(paintInfo, paintRect, style(), Normal);</span>
  
      GraphicsContextStateSaver stateSaver(paintInfo.context(), false);
      if (bleedAvoidance == BackgroundBleedUseTransparencyLayer) {
          // To avoid the background color bleeding out behind the border, we&#39;ll render background and border
          // into a transparency layer, and then clip that in one go (which requires setting up the clip before
<span class="line-new-header">--- 1325,11 ---</span>
      BackgroundBleedAvoidance bleedAvoidance = determineBackgroundBleedAvoidance(paintInfo.context());
  
      // FIXME: Should eventually give the theme control over whether the box shadow should paint, since controls could have
      // custom shadows of their own.
      if (!boxShadowShouldBeAppliedToBackground(paintRect.location(), bleedAvoidance))
<span class="line-modified">!         paintBoxShadow(paintInfo, paintRect, style(), ShadowStyle::Normal);</span>
  
      GraphicsContextStateSaver stateSaver(paintInfo.context(), false);
      if (bleedAvoidance == BackgroundBleedUseTransparencyLayer) {
          // To avoid the background color bleeding out behind the border, we&#39;ll render background and border
          // into a transparency layer, and then clip that in one go (which requires setting up the clip before
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1350,11 ***</span>
          paintBackground(paintInfo, paintRect, bleedAvoidance);
  
          if (style().hasAppearance())
              theme().paintDecorations(*this, paintInfo, paintRect);
      }
<span class="line-modified">!     paintBoxShadow(paintInfo, paintRect, style(), Inset);</span>
  
      // The theme will tell us whether or not we should also paint the CSS border.
      if (bleedAvoidance != BackgroundBleedBackgroundOverBorder &amp;&amp; (!style().hasAppearance() || (borderOrBackgroundPaintingIsNeeded &amp;&amp; theme().paintBorderOnly(*this, paintInfo, paintRect))) &amp;&amp; style().hasVisibleBorderDecoration())
          paintBorder(paintInfo, paintRect, style(), bleedAvoidance);
  
<span class="line-new-header">--- 1356,11 ---</span>
          paintBackground(paintInfo, paintRect, bleedAvoidance);
  
          if (style().hasAppearance())
              theme().paintDecorations(*this, paintInfo, paintRect);
      }
<span class="line-modified">!     paintBoxShadow(paintInfo, paintRect, style(), ShadowStyle::Inset);</span>
  
      // The theme will tell us whether or not we should also paint the CSS border.
      if (bleedAvoidance != BackgroundBleedBackgroundOverBorder &amp;&amp; (!style().hasAppearance() || (borderOrBackgroundPaintingIsNeeded &amp;&amp; theme().paintBorderOnly(*this, paintInfo, paintRect))) &amp;&amp; style().hasVisibleBorderDecoration())
          paintBorder(paintInfo, paintRect, style(), bleedAvoidance);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1474,11 ***</span>
          return false;
      if (RenderLayer* childLayer = childBox.layer()) {
          if (childLayer-&gt;isComposited())
              return false;
          // FIXME: Deal with z-index.
<span class="line-modified">!         if (!childStyle.hasAutoZIndex())</span>
              return false;
          if (childLayer-&gt;hasTransform() || childLayer-&gt;isTransparent() || childLayer-&gt;hasFilter())
              return false;
          if (!childBox.scrollPosition().isZero())
              return false;
<span class="line-new-header">--- 1480,11 ---</span>
          return false;
      if (RenderLayer* childLayer = childBox.layer()) {
          if (childLayer-&gt;isComposited())
              return false;
          // FIXME: Deal with z-index.
<span class="line-modified">!         if (!childStyle.hasAutoUsedZIndex())</span>
              return false;
          if (childLayer-&gt;hasTransform() || childLayer-&gt;isTransparent() || childLayer-&gt;hasFilter())
              return false;
          if (!childBox.scrollPosition().isZero())
              return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1581,11 ***</span>
  {
      // Figure out if we need to push a transparency layer to render our mask.
      bool pushTransparencyLayer = false;
      bool compositedMask = hasLayer() &amp;&amp; layer()-&gt;hasCompositedMask();
      bool flattenCompositingLayers = paintInfo.paintBehavior.contains(PaintBehavior::FlattenCompositingLayers);
<span class="line-modified">!     CompositeOperator compositeOp = CompositeSourceOver;</span>
  
      bool allMaskImagesLoaded = true;
  
      if (!compositedMask || flattenCompositingLayers) {
          pushTransparencyLayer = true;
<span class="line-new-header">--- 1587,11 ---</span>
  {
      // Figure out if we need to push a transparency layer to render our mask.
      bool pushTransparencyLayer = false;
      bool compositedMask = hasLayer() &amp;&amp; layer()-&gt;hasCompositedMask();
      bool flattenCompositingLayers = paintInfo.paintBehavior.contains(PaintBehavior::FlattenCompositingLayers);
<span class="line-modified">!     CompositeOperator compositeOp = CompositeOperator::SourceOver;</span>
  
      bool allMaskImagesLoaded = true;
  
      if (!compositedMask || flattenCompositingLayers) {
          pushTransparencyLayer = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1594,13 ***</span>
          if (auto* maskBoxImage = style().maskBoxImage().image())
              allMaskImagesLoaded &amp;= maskBoxImage-&gt;isLoaded();
  
          allMaskImagesLoaded &amp;= style().maskLayers().imagesAreLoaded();
  
<span class="line-modified">!         paintInfo.context().setCompositeOperation(CompositeDestinationIn);</span>
          paintInfo.context().beginTransparencyLayer(1);
<span class="line-modified">!         compositeOp = CompositeSourceOver;</span>
      }
  
      if (allMaskImagesLoaded) {
          paintFillLayers(paintInfo, Color(), style().maskLayers(), paintRect, BackgroundBleedNone, compositeOp);
          paintNinePieceImage(paintInfo.context(), paintRect, style(), style().maskBoxImage(), compositeOp);
<span class="line-new-header">--- 1600,13 ---</span>
          if (auto* maskBoxImage = style().maskBoxImage().image())
              allMaskImagesLoaded &amp;= maskBoxImage-&gt;isLoaded();
  
          allMaskImagesLoaded &amp;= style().maskLayers().imagesAreLoaded();
  
<span class="line-modified">!         paintInfo.context().setCompositeOperation(CompositeOperator::DestinationIn);</span>
          paintInfo.context().beginTransparencyLayer(1);
<span class="line-modified">!         compositeOp = CompositeOperator::SourceOver;</span>
      }
  
      if (allMaskImagesLoaded) {
          paintFillLayers(paintInfo, Color(), style().maskLayers(), paintRect, BackgroundBleedNone, compositeOp);
          paintNinePieceImage(paintInfo.context(), paintRect, style(), style().maskBoxImage(), compositeOp);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1700,13 ***</span>
          return;
      }
  
      ShapeValue* shapeOutsideValue = style().shapeOutside();
      if (!view().frameView().layoutContext().isInRenderTreeLayout() &amp;&amp; isFloating() &amp;&amp; shapeOutsideValue &amp;&amp; shapeOutsideValue-&gt;image() &amp;&amp; shapeOutsideValue-&gt;image()-&gt;data() == image) {
<span class="line-modified">!         ShapeOutsideInfo::ensureInfo(*this).markShapeAsDirty();</span>
<span class="line-modified">!         markShapeOutsideDependentsForLayout();</span>
<span class="line-modified">!     }</span>
  
      bool didFullRepaint = repaintLayerRectsForImage(image, style().backgroundLayers(), true);
      if (!didFullRepaint)
          repaintLayerRectsForImage(image, style().maskLayers(), false);
  
<span class="line-new-header">--- 1706,16 ---</span>
          return;
      }
  
      ShapeValue* shapeOutsideValue = style().shapeOutside();
      if (!view().frameView().layoutContext().isInRenderTreeLayout() &amp;&amp; isFloating() &amp;&amp; shapeOutsideValue &amp;&amp; shapeOutsideValue-&gt;image() &amp;&amp; shapeOutsideValue-&gt;image()-&gt;data() == image) {
<span class="line-modified">!         ShapeOutsideInfo&amp; info = ShapeOutsideInfo::ensureInfo(*this);</span>
<span class="line-modified">!         if (!info.isComputingShape()) {</span>
<span class="line-modified">!             info.markShapeAsDirty();</span>
<span class="line-added">+             markShapeOutsideDependentsForLayout();</span>
<span class="line-added">+         }</span>
<span class="line-added">+      }</span>
  
      bool didFullRepaint = repaintLayerRectsForImage(image, style().backgroundLayers(), true);
      if (!didFullRepaint)
          repaintLayerRectsForImage(image, style().maskLayers(), false);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4779,11 ***</span>
          // If we are relatively positioned or if we have a transform, then we have to convert
          // this rectangle into physical coordinates, apply relative positioning and transforms
          // to it, and then convert it back.
          flipForWritingMode(rect);
  
<span class="line-modified">!         if (hasTransform)</span>
              rect = layer()-&gt;currentTransform().mapRect(rect);
  
          if (isInFlowPositioned())
              rect.move(offsetForInFlowPosition());
  
<span class="line-new-header">--- 4788,11 ---</span>
          // If we are relatively positioned or if we have a transform, then we have to convert
          // this rectangle into physical coordinates, apply relative positioning and transforms
          // to it, and then convert it back.
          flipForWritingMode(rect);
  
<span class="line-modified">!         if (hasTransform &amp;&amp; hasLayer())</span>
              rect = layer()-&gt;currentTransform().mapRect(rect);
  
          if (isInFlowPositioned())
              rect.move(offsetForInFlowPosition());
  
</pre>
<center><a href="RenderBlockFlow.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBox.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
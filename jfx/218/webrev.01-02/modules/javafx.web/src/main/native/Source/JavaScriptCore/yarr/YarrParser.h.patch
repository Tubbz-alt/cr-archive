diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrParser.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrParser.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrParser.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/yarr/YarrParser.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2009, 2014-2016 Apple Inc. All rights reserved.
+ * Copyright (C) 2009-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -52,13 +52,14 @@
      * parseEscape() as an EscapeDelegate.  This allows parseEscape() to be reused
      * to perform the parsing of escape characters in character sets.
      */
     class CharacterClassParserDelegate {
     public:
-        CharacterClassParserDelegate(Delegate& delegate, ErrorCode& err)
+        CharacterClassParserDelegate(Delegate& delegate, ErrorCode& err, bool isUnicode)
             : m_delegate(delegate)
             , m_errorCode(err)
+            , m_isUnicode(isUnicode)
             , m_state(Empty)
             , m_character(0)
         {
         }
 
@@ -83,17 +84,18 @@
          */
         void atomPatternCharacter(UChar32 ch, bool hyphenIsRange = false)
         {
             switch (m_state) {
             case AfterCharacterClass:
-                // Following a builtin character class we need look out for a hyphen.
+                // Following a built-in character class we need look out for a hyphen.
                 // We're looking for invalid ranges, such as /[\d-x]/ or /[\d-\d]/.
-                // If we see a hyphen following a charater class then unlike usual
+                // If we see a hyphen following a character class then unlike usual
                 // we'll report it to the delegate immediately, and put ourself into
-                // a poisoned state. Any following calls to add another character or
-                // character class will result in an error. (A hypen following a
-                // character-class is itself valid, but only  at the end of a regex).
+                // a poisoned state. In a unicode pattern, any following calls to add
+                // another character or character class will result in syntax error.
+                // A hypen following a character class is itself valid, but only at
+                // the end of a regex.
                 if (hyphenIsRange && ch == '-') {
                     m_delegate.atomCharacterClassAtom('-');
                     m_state = AfterCharacterClassHyphen;
                     return;
                 }
@@ -114,25 +116,24 @@
                 }
                 return;
 
             case CachedCharacterHyphen:
                 if (ch < m_character) {
-                    m_errorCode = ErrorCode::CharacterClassOutOfOrder;
+                    m_errorCode = ErrorCode::CharacterClassRangeOutOfOrder;
                     return;
                 }
                 m_delegate.atomCharacterClassRange(m_character, ch);
                 m_state = Empty;
                 return;
 
-                // See coment in atomBuiltInCharacterClass below.
-                // This too is technically an error, per ECMA-262, and again we
-                // we chose to allow this.  Note a subtlely here that while we
-                // diverge from the spec's definition of CharacterRange we do
-                // remain in compliance with the grammar.  For example, consider
-                // the expression /[\d-a-z]/.  We comply with the grammar in
-                // this case by not allowing a-z to be matched as a range.
+                // If we hit this case, we have an invalid range like /[\d-a]/.
+                // See coment in atomBuiltInCharacterClass() below.
             case AfterCharacterClassHyphen:
+                if (m_isUnicode) {
+                    m_errorCode = ErrorCode::CharacterClassRangeInvalid;
+                    return;
+                }
                 m_delegate.atomCharacterClassAtom(ch);
                 m_state = Empty;
                 return;
             }
         }
@@ -149,27 +150,31 @@
                 // Flush the currently cached character, then fall through.
                 m_delegate.atomCharacterClassAtom(m_character);
                 FALLTHROUGH;
             case Empty:
             case AfterCharacterClass:
-                m_state = AfterCharacterClass;
                 m_delegate.atomCharacterClassBuiltIn(classID, invert);
+                m_state = AfterCharacterClass;
                 return;
 
                 // If we hit either of these cases, we have an invalid range that
-                // looks something like /[x-\d]/ or /[\d-\d]/.
-                // According to ECMA-262 this should be a syntax error, but
-                // empirical testing shows this to break teh webz.  Instead we
-                // comply with to the ECMA-262 grammar, and assume the grammar to
-                // have matched the range correctly, but tweak our interpretation
-                // of CharacterRange.  Effectively we implicitly handle the hyphen
-                // as if it were escaped, e.g. /[\w-_]/ is treated as /[\w\-_]/.
+                // looks something like /[a-\d]/ or /[\d-\d]/.
+                // Since ES2015, this should be syntax error in a unicode pattern,
+                // yet gracefully handled in a regular regex to avoid breaking the web.
+                // Effectively we handle the hyphen as if it was (implicitly) escaped,
+                // e.g. /[\d-a-z]/ is treated as /[\d\-a\-z]/.
+                // See usages of CharacterRangeOrUnion abstract op in
+                // https://tc39.es/ecma262/#sec-regular-expression-patterns-semantics
             case CachedCharacterHyphen:
                 m_delegate.atomCharacterClassAtom(m_character);
                 m_delegate.atomCharacterClassAtom('-');
                 FALLTHROUGH;
             case AfterCharacterClassHyphen:
+                if (m_isUnicode) {
+                    m_errorCode = ErrorCode::CharacterClassRangeInvalid;
+                    return;
+                }
                 m_delegate.atomCharacterClassBuiltIn(classID, invert);
                 m_state = Empty;
                 return;
             }
         }
@@ -199,10 +204,11 @@
         NO_RETURN_DUE_TO_ASSERT void atomNamedForwardReference(const String&) { RELEASE_ASSERT_NOT_REACHED(); }
 
     private:
         Delegate& m_delegate;
         ErrorCode& m_errorCode;
+        bool m_isUnicode;
         enum CharacterClassConstructionState {
             Empty,
             CachedCharacter,
             CachedCharacterHyphen,
             AfterCharacterClass,
@@ -223,11 +229,11 @@
     // The handling of IdentityEscapes is different depending on the unicode flag.
     // For Unicode patterns, IdentityEscapes only include SyntaxCharacters or '/'.
     // For non-unicode patterns, most any character can be escaped.
     bool isIdentityEscapeAnError(int ch)
     {
-        if (m_isUnicode && !strchr("^$\\.*+?()[]{}|/", ch)) {
+        if (m_isUnicode && (!strchr("^$\\.*+?()[]{}|/", ch) || !ch)) {
             m_errorCode = ErrorCode::InvalidIdentityEscape;
             return true;
         }
 
         return false;
@@ -389,16 +395,32 @@
             ParseState state = saveState();
             consume();
             if (!atEndOfPattern()) {
                 int control = consume();
 
-                // To match Firefox, inside a character class, we also accept numbers and '_' as control characters.
-                if (inCharacterClass ? WTF::isASCIIAlphanumeric(control) || (control == '_') : WTF::isASCIIAlpha(control)) {
+                if (WTF::isASCIIAlpha(control)) {
+                    delegate.atomPatternCharacter(control & 0x1f);
+                    break;
+                }
+
+                if (m_isUnicode) {
+                    m_errorCode = ErrorCode::InvalidControlLetterEscape;
+                    break;
+                }
+
+                // https://tc39.es/ecma262/#prod-annexB-ClassControlLetter
+                if (inCharacterClass && (WTF::isASCIIDigit(control) || control == '_')) {
                     delegate.atomPatternCharacter(control & 0x1f);
                     break;
                 }
             }
+
+            if (m_isUnicode) {
+                m_errorCode = ErrorCode::InvalidIdentityEscape;
+                break;
+            }
+
             restoreState(state);
             delegate.atomPatternCharacter('\\');
             break;
         }
 
@@ -593,11 +615,11 @@
     {
         ASSERT(!hasError(m_errorCode));
         ASSERT(peek() == '[');
         consume();
 
-        CharacterClassParserDelegate characterClassConstructor(m_delegate, m_errorCode);
+        CharacterClassParserDelegate characterClassConstructor(m_delegate, m_errorCode, m_isUnicode);
 
         characterClassConstructor.begin(tryConsume('^'));
 
         while (!atEndOfPattern()) {
             switch (peek()) {
@@ -630,10 +652,12 @@
     {
         ASSERT(!hasError(m_errorCode));
         ASSERT(peek() == '(');
         consume();
 
+        auto type = ParenthesesType::Subpattern;
+
         if (tryConsume('?')) {
             if (atEndOfPattern()) {
                 m_errorCode = ErrorCode::ParenthesesTypeInvalid;
                 return;
             }
@@ -643,14 +667,16 @@
                 m_delegate.atomParenthesesSubpatternBegin(false);
                 break;
 
             case '=':
                 m_delegate.atomParentheticalAssertionBegin();
+                type = ParenthesesType::Assertion;
                 break;
 
             case '!':
                 m_delegate.atomParentheticalAssertionBegin(true);
+                type = ParenthesesType::Assertion;
                 break;
 
             case '<': {
                 auto groupName = tryConsumeGroupName();
                 if (groupName) {
@@ -669,30 +695,36 @@
                 m_errorCode = ErrorCode::ParenthesesTypeInvalid;
             }
         } else
             m_delegate.atomParenthesesSubpatternBegin();
 
-        ++m_parenthesesNestingDepth;
+        m_parenthesesStack.append(type);
     }
 
     /*
      * parseParenthesesEnd():
      *
      * Helper for parseTokens(); checks for parse errors (due to unmatched parentheses).
+     *
+     * The boolean value returned by this method indicates whether the token parsed
+     * was either an Atom or, for web compatibility reasons, QuantifiableAssertion
+     * in non-Unicode pattern.
      */
-    void parseParenthesesEnd()
+    bool parseParenthesesEnd()
     {
         ASSERT(!hasError(m_errorCode));
         ASSERT(peek() == ')');
         consume();
 
-        if (m_parenthesesNestingDepth > 0)
-            m_delegate.atomParenthesesEnd();
-        else
+        if (m_parenthesesStack.isEmpty()) {
             m_errorCode = ErrorCode::ParenthesesUnmatched;
+            return false;
+        }
 
-        --m_parenthesesNestingDepth;
+        m_delegate.atomParenthesesEnd();
+        auto type = m_parenthesesStack.takeLast();
+        return type == ParenthesesType::Subpattern || !m_isUnicode;
     }
 
     /*
      * parseQuantifier():
      *
@@ -739,12 +771,11 @@
                 parseParenthesesBegin();
                 lastTokenWasAnAtom = false;
                 break;
 
             case ')':
-                parseParenthesesEnd();
-                lastTokenWasAnAtom = true;
+                lastTokenWasAnAtom = parseParenthesesEnd();
                 break;
 
             case '^':
                 consume();
                 m_delegate.assertionBOL();
@@ -766,10 +797,21 @@
             case '[':
                 parseCharacterClass();
                 lastTokenWasAnAtom = true;
                 break;
 
+            case ']':
+            case '}':
+                if (m_isUnicode) {
+                    m_errorCode = ErrorCode::BracketUnmatched;
+                    break;
+                }
+
+                m_delegate.atomPatternCharacter(consume());
+                lastTokenWasAnAtom = true;
+                break;
+
             case '\\':
                 lastTokenWasAnAtom = parseAtomEscape();
                 break;
 
             case '*':
@@ -809,25 +851,30 @@
                         lastTokenWasAnAtom = false;
                         break;
                     }
                 }
 
+                if (m_isUnicode) {
+                    m_errorCode = ErrorCode::QuantifierIncomplete;
+                    break;
+                }
+
                 restoreState(state);
+                // if we did not find a complete quantifer, fall through to the default case.
+                FALLTHROUGH;
             }
-            // if we did not find a complete quantifer, fall through to the default case.
-            FALLTHROUGH;
 
             default:
                 m_delegate.atomPatternCharacter(consumePossibleSurrogatePair());
                 lastTokenWasAnAtom = true;
             }
 
             if (hasError(m_errorCode))
                 return;
         }
 
-        if (m_parenthesesNestingDepth > 0)
+        if (!m_parenthesesStack.isEmpty())
             m_errorCode = ErrorCode::MissingParentheses;
     }
 
     /*
      * parse():
@@ -1104,22 +1151,24 @@
 
         m_errorCode = ErrorCode::InvalidUnicodePropertyExpression;
         return WTF::nullopt;
     }
 
+    enum class ParenthesesType : uint8_t { Subpattern, Assertion };
+
     Delegate& m_delegate;
     unsigned m_backReferenceLimit;
     ErrorCode m_errorCode { ErrorCode::NoError };
     const CharType* m_data;
     unsigned m_size;
     unsigned m_index { 0 };
     bool m_isUnicode;
-    unsigned m_parenthesesNestingDepth { 0 };
+    Vector<ParenthesesType, 16> m_parenthesesStack;
     HashSet<String> m_captureGroupNames;
 
     // Derived by empirical testing of compile time in PCRE and WREC.
-    static const unsigned MAX_PATTERN_SIZE = 1024 * 1024;
+    static constexpr unsigned MAX_PATTERN_SIZE = 1024 * 1024;
 };
 
 /*
  * Yarr::parse():
  *

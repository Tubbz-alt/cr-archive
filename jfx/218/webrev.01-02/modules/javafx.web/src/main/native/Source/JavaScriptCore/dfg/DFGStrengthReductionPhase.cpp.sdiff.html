<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGStrengthReductionPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGStoreBarrierInsertionPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGStructureAbstractValue.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGStrengthReductionPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2013-2018 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;DFGAbstractHeap.h&quot;
  32 #include &quot;DFGClobberize.h&quot;
  33 #include &quot;DFGGraph.h&quot;
  34 #include &quot;DFGInsertionSet.h&quot;
  35 #include &quot;DFGPhase.h&quot;
  36 #include &quot;DFGPredictionPropagationPhase.h&quot;
  37 #include &quot;DFGVariableAccessDataDump.h&quot;
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;MathCommon.h&quot;
  40 #include &quot;RegExpObject.h&quot;
  41 #include &quot;StringPrototype.h&quot;
  42 #include &lt;cstdlib&gt;
  43 #include &lt;wtf/text/StringBuilder.h&gt;
  44 
  45 namespace JSC { namespace DFG {
  46 
  47 class StrengthReductionPhase : public Phase {
<span class="line-modified">  48     static const bool verbose = false;</span>
  49 
  50 public:
  51     StrengthReductionPhase(Graph&amp; graph)
  52         : Phase(graph, &quot;strength reduction&quot;)
  53         , m_insertionSet(graph)
  54     {
  55     }
  56 
  57     bool run()
  58     {
  59         ASSERT(m_graph.m_fixpointState == FixpointNotConverged);
  60 
  61         m_changed = false;
  62 
  63         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
  64             m_block = m_graph.block(blockIndex);
  65             if (!m_block)
  66                 continue;
  67             for (m_nodeIndex = 0; m_nodeIndex &lt; m_block-&gt;size(); ++m_nodeIndex) {
  68                 m_node = m_block-&gt;at(m_nodeIndex);
</pre>
<hr />
<pre>
  76 
  77 private:
  78     void handleNode()
  79     {
  80         switch (m_node-&gt;op()) {
  81         case ArithBitOr:
  82             handleCommutativity();
  83 
  84             if (m_node-&gt;child1().useKind() != UntypedUse &amp;&amp; m_node-&gt;child2()-&gt;isInt32Constant() &amp;&amp; !m_node-&gt;child2()-&gt;asInt32()) {
  85                 convertToIdentityOverChild1();
  86                 break;
  87             }
  88             break;
  89 
  90         case ArithBitXor:
  91         case ArithBitAnd:
  92             handleCommutativity();
  93             break;
  94 
  95         case ArithBitLShift:
<span class="line-modified">  96         case BitRShift:</span>
  97         case BitURShift:
  98             if (m_node-&gt;child1().useKind() != UntypedUse &amp;&amp; m_node-&gt;child2()-&gt;isInt32Constant() &amp;&amp; !(m_node-&gt;child2()-&gt;asInt32() &amp; 0x1f)) {
  99                 convertToIdentityOverChild1();
 100                 break;
 101             }
 102             break;
 103 
 104         case UInt32ToNumber:
 105             if (m_node-&gt;child1()-&gt;op() == BitURShift
 106                 &amp;&amp; m_node-&gt;child1()-&gt;child2()-&gt;isInt32Constant()
 107                 &amp;&amp; (m_node-&gt;child1()-&gt;child2()-&gt;asInt32() &amp; 0x1f)
 108                 &amp;&amp; m_node-&gt;arithMode() != Arith::DoOverflow) {
 109                 m_node-&gt;convertToIdentity();
 110                 m_changed = true;
 111                 break;
 112             }
 113             break;
 114 
 115         case ArithAdd:
 116             handleCommutativity();
</pre>
<hr />
<pre>
 268                     continue;
 269 
 270                 default:
 271                     break;
 272                 }
 273                 break;
 274             }
 275             break;
 276         }
 277 
 278         case Flush: {
 279             ASSERT(m_graph.m_form != SSA);
 280 
 281             if (m_graph.willCatchExceptionInMachineFrame(m_node-&gt;origin.semantic)) {
 282                 // FIXME: We should be able to relax this:
 283                 // https://bugs.webkit.org/show_bug.cgi?id=150824
 284                 break;
 285             }
 286 
 287             Node* setLocal = nullptr;
<span class="line-modified"> 288             VirtualRegister local = m_node-&gt;local();</span>
 289 
 290             for (unsigned i = m_nodeIndex; i--;) {
 291                 Node* node = m_block-&gt;at(i);
 292 
<span class="line-modified"> 293                 if (node-&gt;op() == SetLocal &amp;&amp; node-&gt;local() == local) {</span>
 294                     setLocal = node;
 295                     break;
 296                 }
 297 
<span class="line-modified"> 298                 if (accessesOverlap(m_graph, node, AbstractHeap(Stack, local)))</span>
 299                     break;
 300 
 301             }
 302 
 303             if (!setLocal)
 304                 break;
 305 
 306             // The Flush should become a PhantomLocal at this point. This means that we want the
 307             // local&#39;s value during OSR, but we don&#39;t care if the value is stored to the stack. CPS
 308             // rethreading can canonicalize PhantomLocals for us.
 309             m_node-&gt;convertFlushToPhantomLocal();
 310             m_graph.dethread();
 311             m_changed = true;
 312             break;
 313         }
 314 
 315         // FIXME: we should probably do this in constant folding but this currently relies on OSR exit history:
 316         // https://bugs.webkit.org/show_bug.cgi?id=154832
 317         case OverridesHasInstance: {
 318             if (!m_node-&gt;child2().node()-&gt;isCellConstant())
</pre>
<hr />
<pre>
 589                         if (otherNode-&gt;op() == SetRegExpObjectLastIndex
 590                             &amp;&amp; otherNode-&gt;child1() == regExpObjectNode
 591                             &amp;&amp; otherNode-&gt;child2()-&gt;isInt32Constant()
 592                             &amp;&amp; otherNode-&gt;child2()-&gt;asInt32() &gt;= 0) {
 593                             lastIndex = static_cast&lt;unsigned&gt;(otherNode-&gt;child2()-&gt;asInt32());
 594                             break;
 595                         }
 596                         if (writesOverlap(m_graph, otherNode, RegExpObject_lastIndex))
 597                             break;
 598                     }
 599                     if (lastIndex == UINT_MAX) {
 600                         if (verbose)
 601                             dataLog(&quot;Giving up because the last index is not known.\n&quot;);
 602                         return false;
 603                     }
 604                 } else
 605                     lastIndex = 0;
 606 
 607                 m_graph.watchpoints().addLazily(globalObject-&gt;havingABadTimeWatchpoint());
 608 
<span class="line-modified"> 609                 Structure* structure;</span>
<span class="line-removed"> 610                 if ((m_node-&gt;op() == RegExpExec || m_node-&gt;op() == RegExpExecNonGlobalOrSticky) &amp;&amp; regExp-&gt;hasNamedCaptures())</span>
<span class="line-removed"> 611                     structure = globalObject-&gt;regExpMatchesArrayWithGroupsStructure();</span>
<span class="line-removed"> 612                 else</span>
<span class="line-removed"> 613                     structure = globalObject-&gt;regExpMatchesArrayStructure();</span>
<span class="line-removed"> 614 </span>
 615                 if (structure-&gt;indexingType() != ArrayWithContiguous) {
 616                     // This is further protection against a race with haveABadTime.
 617                     if (verbose)
 618                         dataLog(&quot;Giving up because the structure has the wrong indexing type.\n&quot;);
 619                     return false;
 620                 }
 621                 m_graph.registerStructure(structure);
 622 
 623                 FrozenValue* globalObjectFrozenValue = m_graph.freeze(globalObject);
 624 
 625                 MatchResult result;
 626                 Vector&lt;int&gt; ovector;
 627                 // We have to call the kind of match function that the main thread would have called.
 628                 // Otherwise, we might not have the desired Yarr code compiled, and the match will fail.
 629                 if (m_node-&gt;op() == RegExpExec || m_node-&gt;op() == RegExpExecNonGlobalOrSticky) {
 630                     int position;
 631                     if (!regExp-&gt;matchConcurrently(vm(), string, lastIndex, position, ovector)) {
 632                         if (verbose)
 633                             dataLog(&quot;Giving up because match failed.\n&quot;);
 634                         return false;
</pre>
<hr />
<pre>
 657                         RegisteredStructureSet* structureSet = m_graph.addStructureSet(structure);
 658 
 659                         // Create an array modeling the JS array that we will try to allocate. This is
 660                         // basically createRegExpMatchesArray but over C++ strings instead of JSStrings.
 661                         Vector&lt;String&gt; resultArray;
 662                         resultArray.append(string.substring(result.start, result.end - result.start));
 663                         for (unsigned i = 1; i &lt;= regExp-&gt;numSubpatterns(); ++i) {
 664                             int start = ovector[2 * i];
 665                             if (start &gt;= 0)
 666                                 resultArray.append(string.substring(start, ovector[2 * i + 1] - start));
 667                             else
 668                                 resultArray.append(String());
 669                         }
 670 
 671                         unsigned publicLength = resultArray.size();
 672                         unsigned vectorLength =
 673                             Butterfly::optimalContiguousVectorLength(structure, publicLength);
 674 
 675                         UniquedStringImpl* indexUID = vm().propertyNames-&gt;index.impl();
 676                         UniquedStringImpl* inputUID = vm().propertyNames-&gt;input.impl();

 677                         unsigned indexIndex = m_graph.identifiers().ensure(indexUID);
 678                         unsigned inputIndex = m_graph.identifiers().ensure(inputUID);

 679 
 680                         unsigned firstChild = m_graph.m_varArgChildren.size();
 681                         m_graph.m_varArgChildren.append(
 682                             m_insertionSet.insertConstantForUse(
 683                                 m_nodeIndex, origin, structure, KnownCellUse));
 684                         ObjectMaterializationData* data = m_graph.m_objectMaterializationData.add();
 685 
 686                         m_graph.m_varArgChildren.append(
 687                             m_insertionSet.insertConstantForUse(
 688                                 m_nodeIndex, origin, jsNumber(publicLength), KnownInt32Use));
 689                         data-&gt;m_properties.append(PublicLengthPLoc);
 690 
 691                         m_graph.m_varArgChildren.append(
 692                             m_insertionSet.insertConstantForUse(
 693                                 m_nodeIndex, origin, jsNumber(vectorLength), KnownInt32Use));
 694                         data-&gt;m_properties.append(VectorLengthPLoc);
 695 
 696                         m_graph.m_varArgChildren.append(
 697                             m_insertionSet.insertConstantForUse(
 698                                 m_nodeIndex, origin, jsNumber(result.start), UntypedUse));
 699                         data-&gt;m_properties.append(
 700                             PromotedLocationDescriptor(NamedPropertyPLoc, indexIndex));
 701 
 702                         m_graph.m_varArgChildren.append(Edge(stringNode, UntypedUse));
 703                         data-&gt;m_properties.append(
 704                             PromotedLocationDescriptor(NamedPropertyPLoc, inputIndex));
 705 








 706                         auto materializeString = [&amp;] (const String&amp; string) -&gt; Node* {
 707                             if (string.isNull())
 708                                 return nullptr;
 709                             if (string.isEmpty()) {
 710                                 return m_insertionSet.insertConstant(
 711                                     m_nodeIndex, origin, vm().smallStrings.emptyString());
 712                             }
 713                             LazyJSValue value = LazyJSValue::newString(m_graph, string);
 714                             return m_insertionSet.insertNode(
 715                                 m_nodeIndex, SpecNone, LazyJSConstant, origin,
 716                                 OpInfo(m_graph.m_lazyJSValues.add(value)));
 717                         };
 718 
 719                         for (unsigned i = 0; i &lt; resultArray.size(); ++i) {
 720                             if (Node* node = materializeString(resultArray[i])) {
 721                                 m_graph.m_varArgChildren.append(Edge(node, UntypedUse));
 722                                 data-&gt;m_properties.append(
 723                                     PromotedLocationDescriptor(IndexedPropertyPLoc, i));
 724                             }
 725                         }
</pre>
<hr />
<pre>
 881             NodeOrigin origin = m_node-&gt;origin;
 882 
 883             // Preserve any checks we have.
 884             m_insertionSet.insertNode(
 885                 m_nodeIndex, SpecNone, Check, origin, m_node-&gt;children.justChecks());
 886 
 887             if (regExp-&gt;global()) {
 888                 m_insertionSet.insertNode(
 889                     m_nodeIndex, SpecNone, SetRegExpObjectLastIndex, origin,
 890                     OpInfo(false),
 891                     Edge(regExpObjectNode, RegExpObjectUse),
 892                     m_insertionSet.insertConstantForUse(
 893                         m_nodeIndex, origin, jsNumber(0), UntypedUse));
 894 
 895                 origin = origin.withInvalidExit();
 896             }
 897 
 898             if (!lastIndex &amp;&amp; builder.isEmpty())
 899                 m_node-&gt;convertToIdentityOn(stringNode);
 900             else {
<span class="line-modified"> 901                 if (lastIndex &lt; string.length())</span>
<span class="line-removed"> 902                     builder.appendSubstring(string, lastIndex, string.length() - lastIndex);</span>
<span class="line-removed"> 903 </span>
 904                 m_node-&gt;convertToLazyJSConstant(m_graph, LazyJSValue::newString(m_graph, builder.toString()));
 905             }
 906 
 907             m_node-&gt;origin = origin;
 908             break;
 909         }
 910 
 911         case Call:
 912         case Construct:
 913         case TailCallInlinedCaller:
 914         case TailCall: {
 915             ExecutableBase* executable = nullptr;
 916             Edge callee = m_graph.varArgChild(m_node, 0);
 917             CallVariant callVariant;
 918             if (JSFunction* function = callee-&gt;dynamicCastConstant&lt;JSFunction*&gt;(vm())) {
 919                 executable = function-&gt;executable();
 920                 callVariant = CallVariant(function);
 921             } else if (callee-&gt;isFunctionAllocation()) {
 922                 executable = callee-&gt;castOperand&lt;FunctionExecutable*&gt;();
 923                 callVariant = CallVariant(executable);
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
  28 
  29 #if ENABLE(DFG_JIT)
  30 
  31 #include &quot;DFGAbstractHeap.h&quot;
  32 #include &quot;DFGClobberize.h&quot;
  33 #include &quot;DFGGraph.h&quot;
  34 #include &quot;DFGInsertionSet.h&quot;
  35 #include &quot;DFGPhase.h&quot;
  36 #include &quot;DFGPredictionPropagationPhase.h&quot;
  37 #include &quot;DFGVariableAccessDataDump.h&quot;
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;MathCommon.h&quot;
  40 #include &quot;RegExpObject.h&quot;
  41 #include &quot;StringPrototype.h&quot;
  42 #include &lt;cstdlib&gt;
  43 #include &lt;wtf/text/StringBuilder.h&gt;
  44 
  45 namespace JSC { namespace DFG {
  46 
  47 class StrengthReductionPhase : public Phase {
<span class="line-modified">  48     static constexpr bool verbose = false;</span>
  49 
  50 public:
  51     StrengthReductionPhase(Graph&amp; graph)
  52         : Phase(graph, &quot;strength reduction&quot;)
  53         , m_insertionSet(graph)
  54     {
  55     }
  56 
  57     bool run()
  58     {
  59         ASSERT(m_graph.m_fixpointState == FixpointNotConverged);
  60 
  61         m_changed = false;
  62 
  63         for (BlockIndex blockIndex = m_graph.numBlocks(); blockIndex--;) {
  64             m_block = m_graph.block(blockIndex);
  65             if (!m_block)
  66                 continue;
  67             for (m_nodeIndex = 0; m_nodeIndex &lt; m_block-&gt;size(); ++m_nodeIndex) {
  68                 m_node = m_block-&gt;at(m_nodeIndex);
</pre>
<hr />
<pre>
  76 
  77 private:
  78     void handleNode()
  79     {
  80         switch (m_node-&gt;op()) {
  81         case ArithBitOr:
  82             handleCommutativity();
  83 
  84             if (m_node-&gt;child1().useKind() != UntypedUse &amp;&amp; m_node-&gt;child2()-&gt;isInt32Constant() &amp;&amp; !m_node-&gt;child2()-&gt;asInt32()) {
  85                 convertToIdentityOverChild1();
  86                 break;
  87             }
  88             break;
  89 
  90         case ArithBitXor:
  91         case ArithBitAnd:
  92             handleCommutativity();
  93             break;
  94 
  95         case ArithBitLShift:
<span class="line-modified">  96         case ArithBitRShift:</span>
  97         case BitURShift:
  98             if (m_node-&gt;child1().useKind() != UntypedUse &amp;&amp; m_node-&gt;child2()-&gt;isInt32Constant() &amp;&amp; !(m_node-&gt;child2()-&gt;asInt32() &amp; 0x1f)) {
  99                 convertToIdentityOverChild1();
 100                 break;
 101             }
 102             break;
 103 
 104         case UInt32ToNumber:
 105             if (m_node-&gt;child1()-&gt;op() == BitURShift
 106                 &amp;&amp; m_node-&gt;child1()-&gt;child2()-&gt;isInt32Constant()
 107                 &amp;&amp; (m_node-&gt;child1()-&gt;child2()-&gt;asInt32() &amp; 0x1f)
 108                 &amp;&amp; m_node-&gt;arithMode() != Arith::DoOverflow) {
 109                 m_node-&gt;convertToIdentity();
 110                 m_changed = true;
 111                 break;
 112             }
 113             break;
 114 
 115         case ArithAdd:
 116             handleCommutativity();
</pre>
<hr />
<pre>
 268                     continue;
 269 
 270                 default:
 271                     break;
 272                 }
 273                 break;
 274             }
 275             break;
 276         }
 277 
 278         case Flush: {
 279             ASSERT(m_graph.m_form != SSA);
 280 
 281             if (m_graph.willCatchExceptionInMachineFrame(m_node-&gt;origin.semantic)) {
 282                 // FIXME: We should be able to relax this:
 283                 // https://bugs.webkit.org/show_bug.cgi?id=150824
 284                 break;
 285             }
 286 
 287             Node* setLocal = nullptr;
<span class="line-modified"> 288             Operand operand = m_node-&gt;operand();</span>
 289 
 290             for (unsigned i = m_nodeIndex; i--;) {
 291                 Node* node = m_block-&gt;at(i);
 292 
<span class="line-modified"> 293                 if (node-&gt;op() == SetLocal &amp;&amp; node-&gt;operand() == operand) {</span>
 294                     setLocal = node;
 295                     break;
 296                 }
 297 
<span class="line-modified"> 298                 if (accessesOverlap(m_graph, node, AbstractHeap(Stack, operand)))</span>
 299                     break;
 300 
 301             }
 302 
 303             if (!setLocal)
 304                 break;
 305 
 306             // The Flush should become a PhantomLocal at this point. This means that we want the
 307             // local&#39;s value during OSR, but we don&#39;t care if the value is stored to the stack. CPS
 308             // rethreading can canonicalize PhantomLocals for us.
 309             m_node-&gt;convertFlushToPhantomLocal();
 310             m_graph.dethread();
 311             m_changed = true;
 312             break;
 313         }
 314 
 315         // FIXME: we should probably do this in constant folding but this currently relies on OSR exit history:
 316         // https://bugs.webkit.org/show_bug.cgi?id=154832
 317         case OverridesHasInstance: {
 318             if (!m_node-&gt;child2().node()-&gt;isCellConstant())
</pre>
<hr />
<pre>
 589                         if (otherNode-&gt;op() == SetRegExpObjectLastIndex
 590                             &amp;&amp; otherNode-&gt;child1() == regExpObjectNode
 591                             &amp;&amp; otherNode-&gt;child2()-&gt;isInt32Constant()
 592                             &amp;&amp; otherNode-&gt;child2()-&gt;asInt32() &gt;= 0) {
 593                             lastIndex = static_cast&lt;unsigned&gt;(otherNode-&gt;child2()-&gt;asInt32());
 594                             break;
 595                         }
 596                         if (writesOverlap(m_graph, otherNode, RegExpObject_lastIndex))
 597                             break;
 598                     }
 599                     if (lastIndex == UINT_MAX) {
 600                         if (verbose)
 601                             dataLog(&quot;Giving up because the last index is not known.\n&quot;);
 602                         return false;
 603                     }
 604                 } else
 605                     lastIndex = 0;
 606 
 607                 m_graph.watchpoints().addLazily(globalObject-&gt;havingABadTimeWatchpoint());
 608 
<span class="line-modified"> 609                 Structure* structure = globalObject-&gt;regExpMatchesArrayStructure();</span>





 610                 if (structure-&gt;indexingType() != ArrayWithContiguous) {
 611                     // This is further protection against a race with haveABadTime.
 612                     if (verbose)
 613                         dataLog(&quot;Giving up because the structure has the wrong indexing type.\n&quot;);
 614                     return false;
 615                 }
 616                 m_graph.registerStructure(structure);
 617 
 618                 FrozenValue* globalObjectFrozenValue = m_graph.freeze(globalObject);
 619 
 620                 MatchResult result;
 621                 Vector&lt;int&gt; ovector;
 622                 // We have to call the kind of match function that the main thread would have called.
 623                 // Otherwise, we might not have the desired Yarr code compiled, and the match will fail.
 624                 if (m_node-&gt;op() == RegExpExec || m_node-&gt;op() == RegExpExecNonGlobalOrSticky) {
 625                     int position;
 626                     if (!regExp-&gt;matchConcurrently(vm(), string, lastIndex, position, ovector)) {
 627                         if (verbose)
 628                             dataLog(&quot;Giving up because match failed.\n&quot;);
 629                         return false;
</pre>
<hr />
<pre>
 652                         RegisteredStructureSet* structureSet = m_graph.addStructureSet(structure);
 653 
 654                         // Create an array modeling the JS array that we will try to allocate. This is
 655                         // basically createRegExpMatchesArray but over C++ strings instead of JSStrings.
 656                         Vector&lt;String&gt; resultArray;
 657                         resultArray.append(string.substring(result.start, result.end - result.start));
 658                         for (unsigned i = 1; i &lt;= regExp-&gt;numSubpatterns(); ++i) {
 659                             int start = ovector[2 * i];
 660                             if (start &gt;= 0)
 661                                 resultArray.append(string.substring(start, ovector[2 * i + 1] - start));
 662                             else
 663                                 resultArray.append(String());
 664                         }
 665 
 666                         unsigned publicLength = resultArray.size();
 667                         unsigned vectorLength =
 668                             Butterfly::optimalContiguousVectorLength(structure, publicLength);
 669 
 670                         UniquedStringImpl* indexUID = vm().propertyNames-&gt;index.impl();
 671                         UniquedStringImpl* inputUID = vm().propertyNames-&gt;input.impl();
<span class="line-added"> 672                         UniquedStringImpl* groupsUID = vm().propertyNames-&gt;groups.impl();</span>
 673                         unsigned indexIndex = m_graph.identifiers().ensure(indexUID);
 674                         unsigned inputIndex = m_graph.identifiers().ensure(inputUID);
<span class="line-added"> 675                         unsigned groupsIndex = m_graph.identifiers().ensure(groupsUID);</span>
 676 
 677                         unsigned firstChild = m_graph.m_varArgChildren.size();
 678                         m_graph.m_varArgChildren.append(
 679                             m_insertionSet.insertConstantForUse(
 680                                 m_nodeIndex, origin, structure, KnownCellUse));
 681                         ObjectMaterializationData* data = m_graph.m_objectMaterializationData.add();
 682 
 683                         m_graph.m_varArgChildren.append(
 684                             m_insertionSet.insertConstantForUse(
 685                                 m_nodeIndex, origin, jsNumber(publicLength), KnownInt32Use));
 686                         data-&gt;m_properties.append(PublicLengthPLoc);
 687 
 688                         m_graph.m_varArgChildren.append(
 689                             m_insertionSet.insertConstantForUse(
 690                                 m_nodeIndex, origin, jsNumber(vectorLength), KnownInt32Use));
 691                         data-&gt;m_properties.append(VectorLengthPLoc);
 692 
 693                         m_graph.m_varArgChildren.append(
 694                             m_insertionSet.insertConstantForUse(
 695                                 m_nodeIndex, origin, jsNumber(result.start), UntypedUse));
 696                         data-&gt;m_properties.append(
 697                             PromotedLocationDescriptor(NamedPropertyPLoc, indexIndex));
 698 
 699                         m_graph.m_varArgChildren.append(Edge(stringNode, UntypedUse));
 700                         data-&gt;m_properties.append(
 701                             PromotedLocationDescriptor(NamedPropertyPLoc, inputIndex));
 702 
<span class="line-added"> 703                         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=176464</span>
<span class="line-added"> 704                         // Implement strength reduction optimization for named capture groups.</span>
<span class="line-added"> 705                         m_graph.m_varArgChildren.append(</span>
<span class="line-added"> 706                             m_insertionSet.insertConstantForUse(</span>
<span class="line-added"> 707                                 m_nodeIndex, origin, jsUndefined(), UntypedUse));</span>
<span class="line-added"> 708                         data-&gt;m_properties.append(</span>
<span class="line-added"> 709                             PromotedLocationDescriptor(NamedPropertyPLoc, groupsIndex));</span>
<span class="line-added"> 710 </span>
 711                         auto materializeString = [&amp;] (const String&amp; string) -&gt; Node* {
 712                             if (string.isNull())
 713                                 return nullptr;
 714                             if (string.isEmpty()) {
 715                                 return m_insertionSet.insertConstant(
 716                                     m_nodeIndex, origin, vm().smallStrings.emptyString());
 717                             }
 718                             LazyJSValue value = LazyJSValue::newString(m_graph, string);
 719                             return m_insertionSet.insertNode(
 720                                 m_nodeIndex, SpecNone, LazyJSConstant, origin,
 721                                 OpInfo(m_graph.m_lazyJSValues.add(value)));
 722                         };
 723 
 724                         for (unsigned i = 0; i &lt; resultArray.size(); ++i) {
 725                             if (Node* node = materializeString(resultArray[i])) {
 726                                 m_graph.m_varArgChildren.append(Edge(node, UntypedUse));
 727                                 data-&gt;m_properties.append(
 728                                     PromotedLocationDescriptor(IndexedPropertyPLoc, i));
 729                             }
 730                         }
</pre>
<hr />
<pre>
 886             NodeOrigin origin = m_node-&gt;origin;
 887 
 888             // Preserve any checks we have.
 889             m_insertionSet.insertNode(
 890                 m_nodeIndex, SpecNone, Check, origin, m_node-&gt;children.justChecks());
 891 
 892             if (regExp-&gt;global()) {
 893                 m_insertionSet.insertNode(
 894                     m_nodeIndex, SpecNone, SetRegExpObjectLastIndex, origin,
 895                     OpInfo(false),
 896                     Edge(regExpObjectNode, RegExpObjectUse),
 897                     m_insertionSet.insertConstantForUse(
 898                         m_nodeIndex, origin, jsNumber(0), UntypedUse));
 899 
 900                 origin = origin.withInvalidExit();
 901             }
 902 
 903             if (!lastIndex &amp;&amp; builder.isEmpty())
 904                 m_node-&gt;convertToIdentityOn(stringNode);
 905             else {
<span class="line-modified"> 906                 builder.appendSubstring(string, lastIndex);</span>


 907                 m_node-&gt;convertToLazyJSConstant(m_graph, LazyJSValue::newString(m_graph, builder.toString()));
 908             }
 909 
 910             m_node-&gt;origin = origin;
 911             break;
 912         }
 913 
 914         case Call:
 915         case Construct:
 916         case TailCallInlinedCaller:
 917         case TailCall: {
 918             ExecutableBase* executable = nullptr;
 919             Edge callee = m_graph.varArgChild(m_node, 0);
 920             CallVariant callVariant;
 921             if (JSFunction* function = callee-&gt;dynamicCastConstant&lt;JSFunction*&gt;(vm())) {
 922                 executable = function-&gt;executable();
 923                 callVariant = CallVariant(function);
 924             } else if (callee-&gt;isFunctionAllocation()) {
 925                 executable = callee-&gt;castOperand&lt;FunctionExecutable*&gt;();
 926                 callVariant = CallVariant(executable);
</pre>
</td>
</tr>
</table>
<center><a href="DFGStoreBarrierInsertionPhase.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGStructureAbstractValue.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
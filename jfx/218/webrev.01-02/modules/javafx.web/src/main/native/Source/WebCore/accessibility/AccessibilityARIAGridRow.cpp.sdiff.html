<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityARIAGridRow.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibilityARIAGridCell.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityARIAGridRow.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityARIAGridRow.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 56 }
 57 
 58 void AccessibilityARIAGridRow::disclosedRows(AccessibilityChildrenVector&amp; disclosedRows)
 59 {
 60     // The contiguous disclosed rows will be the rows in the table that
 61     // have an aria-level of plus 1 from this row.
 62     AccessibilityObject* parent = parentObjectUnignored();
 63     if (!is&lt;AccessibilityTable&gt;(*parent) || !downcast&lt;AccessibilityTable&gt;(*parent).isExposableThroughAccessibility())
 64         return;
 65 
 66     // Search for rows that match the correct level.
 67     // Only take the subsequent rows from this one that are +1 from this row&#39;s level.
 68     int index = rowIndex();
 69     if (index &lt; 0)
 70         return;
 71 
 72     unsigned level = hierarchicalLevel();
 73     auto&amp; allRows = downcast&lt;AccessibilityTable&gt;(*parent).rows();
 74     int rowCount = allRows.size();
 75     for (int k = index + 1; k &lt; rowCount; ++k) {
<span class="line-modified"> 76         AccessibilityObject* row = allRows[k].get();</span>
 77         // Stop at the first row that doesn&#39;t match the correct level.
 78         if (row-&gt;hierarchicalLevel() != level + 1)
 79             break;
 80 
 81         disclosedRows.append(row);
 82     }
 83 }
 84 
<span class="line-modified"> 85 AccessibilityObject* AccessibilityARIAGridRow::disclosedByRow() const</span>
 86 {
 87     // The row that discloses this one is the row in the table
 88     // that is aria-level subtract 1 from this row.
 89     AccessibilityObject* parent = parentObjectUnignored();
 90     if (!is&lt;AccessibilityTable&gt;(*parent) || !downcast&lt;AccessibilityTable&gt;(*parent).isExposableThroughAccessibility())
 91         return nullptr;
 92 
 93     // If the level is 1 or less, than nothing discloses this row.
 94     unsigned level = hierarchicalLevel();
 95     if (level &lt;= 1)
 96         return nullptr;
 97 
 98     // Search for the previous row that matches the correct level.
 99     int index = rowIndex();
100     auto&amp; allRows = downcast&lt;AccessibilityTable&gt;(parent)-&gt;rows();
101     int rowCount = allRows.size();
102     if (index &gt;= rowCount)
103         return nullptr;
104 
105     for (int k = index - 1; k &gt;= 0; --k) {
<span class="line-modified">106         AccessibilityObject* row = allRows[k].get();</span>
107         if (row-&gt;hierarchicalLevel() == level - 1)
108             return row;
109     }
110 
111     return nullptr;
112 }
113 
114 AccessibilityObject* AccessibilityARIAGridRow::parentObjectUnignored() const
115 {
116     return parentTable();
117 }
118 
119 AccessibilityTable* AccessibilityARIAGridRow::parentTable() const
120 {
121     // The parent table might not be the direct ancestor of the row unfortunately. ARIA states that role=&quot;grid&quot; should
122     // only have &quot;row&quot; elements, but if not, we still should handle it gracefully by finding the right table.
123     for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
124         // The parent table for an ARIA grid row should be an ARIA table.
125         // Unless the row is a native tr element.
126         if (is&lt;AccessibilityTable&gt;(*parent)) {
127             AccessibilityTable&amp; tableParent = downcast&lt;AccessibilityTable&gt;(*parent);
128             if (tableParent.isExposableThroughAccessibility() &amp;&amp; (tableParent.isAriaTable() || node()-&gt;hasTagName(HTMLNames::trTag)))
129                 return &amp;tableParent;
130         }
131     }
132 
133     return nullptr;
134 }
135 
<span class="line-modified">136 AccessibilityObject* AccessibilityARIAGridRow::headerObject()</span>
137 {
138     for (const auto&amp; child : children()) {
139         if (child-&gt;ariaRoleAttribute() == AccessibilityRole::RowHeader)
140             return child.get();
141     }
142 
143     return nullptr;
144 }
145 
146 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 56 }
 57 
 58 void AccessibilityARIAGridRow::disclosedRows(AccessibilityChildrenVector&amp; disclosedRows)
 59 {
 60     // The contiguous disclosed rows will be the rows in the table that
 61     // have an aria-level of plus 1 from this row.
 62     AccessibilityObject* parent = parentObjectUnignored();
 63     if (!is&lt;AccessibilityTable&gt;(*parent) || !downcast&lt;AccessibilityTable&gt;(*parent).isExposableThroughAccessibility())
 64         return;
 65 
 66     // Search for rows that match the correct level.
 67     // Only take the subsequent rows from this one that are +1 from this row&#39;s level.
 68     int index = rowIndex();
 69     if (index &lt; 0)
 70         return;
 71 
 72     unsigned level = hierarchicalLevel();
 73     auto&amp; allRows = downcast&lt;AccessibilityTable&gt;(*parent).rows();
 74     int rowCount = allRows.size();
 75     for (int k = index + 1; k &lt; rowCount; ++k) {
<span class="line-modified"> 76         auto* row = allRows[k].get();</span>
 77         // Stop at the first row that doesn&#39;t match the correct level.
 78         if (row-&gt;hierarchicalLevel() != level + 1)
 79             break;
 80 
 81         disclosedRows.append(row);
 82     }
 83 }
 84 
<span class="line-modified"> 85 AXCoreObject* AccessibilityARIAGridRow::disclosedByRow() const</span>
 86 {
 87     // The row that discloses this one is the row in the table
 88     // that is aria-level subtract 1 from this row.
 89     AccessibilityObject* parent = parentObjectUnignored();
 90     if (!is&lt;AccessibilityTable&gt;(*parent) || !downcast&lt;AccessibilityTable&gt;(*parent).isExposableThroughAccessibility())
 91         return nullptr;
 92 
 93     // If the level is 1 or less, than nothing discloses this row.
 94     unsigned level = hierarchicalLevel();
 95     if (level &lt;= 1)
 96         return nullptr;
 97 
 98     // Search for the previous row that matches the correct level.
 99     int index = rowIndex();
100     auto&amp; allRows = downcast&lt;AccessibilityTable&gt;(parent)-&gt;rows();
101     int rowCount = allRows.size();
102     if (index &gt;= rowCount)
103         return nullptr;
104 
105     for (int k = index - 1; k &gt;= 0; --k) {
<span class="line-modified">106         auto* row = allRows[k].get();</span>
107         if (row-&gt;hierarchicalLevel() == level - 1)
108             return row;
109     }
110 
111     return nullptr;
112 }
113 
114 AccessibilityObject* AccessibilityARIAGridRow::parentObjectUnignored() const
115 {
116     return parentTable();
117 }
118 
119 AccessibilityTable* AccessibilityARIAGridRow::parentTable() const
120 {
121     // The parent table might not be the direct ancestor of the row unfortunately. ARIA states that role=&quot;grid&quot; should
122     // only have &quot;row&quot; elements, but if not, we still should handle it gracefully by finding the right table.
123     for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
124         // The parent table for an ARIA grid row should be an ARIA table.
125         // Unless the row is a native tr element.
126         if (is&lt;AccessibilityTable&gt;(*parent)) {
127             AccessibilityTable&amp; tableParent = downcast&lt;AccessibilityTable&gt;(*parent);
128             if (tableParent.isExposableThroughAccessibility() &amp;&amp; (tableParent.isAriaTable() || node()-&gt;hasTagName(HTMLNames::trTag)))
129                 return &amp;tableParent;
130         }
131     }
132 
133     return nullptr;
134 }
135 
<span class="line-modified">136 AXCoreObject* AccessibilityARIAGridRow::headerObject()</span>
137 {
138     for (const auto&amp; child : children()) {
139         if (child-&gt;ariaRoleAttribute() == AccessibilityRole::RowHeader)
140             return child.get();
141     }
142 
143     return nullptr;
144 }
145 
146 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="AccessibilityARIAGridCell.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityARIAGridRow.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLDialogElement.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLDialogElement.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLDialogElement.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/HTMLDialogElement.cpp
@@ -24,29 +24,27 @@
  */
 
 #include "config.h"
 #include "HTMLDialogElement.h"
 
+#include "HTMLNames.h"
 #include <wtf/IsoMallocInlines.h>
 
 namespace WebCore {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLDialogElement);
 
+using namespace HTMLNames;
+
 HTMLDialogElement::HTMLDialogElement(const QualifiedName& tagName, Document& document)
     : HTMLElement(tagName, document)
 {
 }
 
-bool HTMLDialogElement::open()
-{
-    return m_open;
-}
-
-void HTMLDialogElement::setOpen(bool open)
+bool HTMLDialogElement::isOpen() const
 {
-    m_open = open;
+    return m_isOpen;
 }
 
 const String& HTMLDialogElement::returnValue()
 {
     return m_returnValue;
@@ -57,16 +55,53 @@
     m_returnValue = WTFMove(returnValue);
 }
 
 void HTMLDialogElement::show()
 {
+    // If the element already has an open attribute, then return.
+    if (isOpen())
+        return;
+
+    toggleOpen();
 }
 
-void HTMLDialogElement::showModal()
+ExceptionOr<void> HTMLDialogElement::showModal()
 {
+    // If subject already has an open attribute, then throw an "InvalidStateError" DOMException.
+    if (isOpen())
+        return Exception { InvalidStateError };
+
+    // If subject is not connected, then throw an "InvalidStateError" DOMException.
+    if (!isConnected())
+        return Exception { InvalidStateError };
+
+    toggleOpen();
+    return { };
+}
+
+void HTMLDialogElement::close(const String& returnValue)
+{
+    if (!isOpen())
+        return;
+
+    toggleOpen();
+    if (!returnValue.isNull())
+        m_returnValue = returnValue;
+}
+
+void HTMLDialogElement::parseAttribute(const QualifiedName& name, const AtomString& value)
+{
+    if (name == HTMLNames::openAttr) {
+        m_isOpen = !value.isNull();
+        return;
+    }
+
+    HTMLElement::parseAttribute(name, value);
 }
 
-void HTMLDialogElement::close(const String&)
+void HTMLDialogElement::toggleOpen()
 {
+    m_isOpen = !m_isOpen;
+    setAttributeWithoutSynchronization(HTMLNames::openAttr, m_isOpen ? emptyAtom() : nullAtom());
 }
 
 }

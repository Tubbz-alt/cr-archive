<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/shapes/Shape.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RectangleShape.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ShapeOutsideInfo.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/shapes/Shape.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 83         return FloatPoint(point.y(), logicalBoxHeight - point.x());
 84     return point.transposedPoint();
 85 }
 86 
 87 static inline FloatSize physicalSizeToLogical(const FloatSize&amp; size, WritingMode writingMode)
 88 {
 89     if (isHorizontalWritingMode(writingMode))
 90         return size;
 91     return size.transposedSize();
 92 }
 93 
 94 std::unique_ptr&lt;Shape&gt; Shape::createShape(const BasicShape&amp; basicShape, const LayoutSize&amp; logicalBoxSize, WritingMode writingMode, float margin)
 95 {
 96     bool horizontalWritingMode = isHorizontalWritingMode(writingMode);
 97     float boxWidth = horizontalWritingMode ? logicalBoxSize.width() : logicalBoxSize.height();
 98     float boxHeight = horizontalWritingMode ? logicalBoxSize.height() : logicalBoxSize.width();
 99     std::unique_ptr&lt;Shape&gt; shape;
100 
101     switch (basicShape.type()) {
102 
<span class="line-modified">103     case BasicShape::BasicShapeCircleType: {</span>
104         const auto&amp; circle = downcast&lt;BasicShapeCircle&gt;(basicShape);
105         float centerX = floatValueForCenterCoordinate(circle.centerX(), boxWidth);
106         float centerY = floatValueForCenterCoordinate(circle.centerY(), boxHeight);
107         float radius = circle.floatValueForRadiusInBox(boxWidth, boxHeight);
108         FloatPoint logicalCenter = physicalPointToLogical(FloatPoint(centerX, centerY), logicalBoxSize.height(), writingMode);
109 
110         shape = createCircleShape(logicalCenter, radius);
111         break;
112     }
113 
<span class="line-modified">114     case BasicShape::BasicShapeEllipseType: {</span>
115         const auto&amp; ellipse = downcast&lt;BasicShapeEllipse&gt;(basicShape);
116         float centerX = floatValueForCenterCoordinate(ellipse.centerX(), boxWidth);
117         float centerY = floatValueForCenterCoordinate(ellipse.centerY(), boxHeight);
118         float radiusX = ellipse.floatValueForRadiusInBox(ellipse.radiusX(), centerX, boxWidth);
119         float radiusY = ellipse.floatValueForRadiusInBox(ellipse.radiusY(), centerY, boxHeight);
120         FloatPoint logicalCenter = physicalPointToLogical(FloatPoint(centerX, centerY), logicalBoxSize.height(), writingMode);
121 
122         shape = createEllipseShape(logicalCenter, FloatSize(radiusX, radiusY));
123         break;
124     }
125 
<span class="line-modified">126     case BasicShape::BasicShapePolygonType: {</span>
127         const auto&amp; polygon = downcast&lt;BasicShapePolygon&gt;(basicShape);
128         const Vector&lt;Length&gt;&amp; values = polygon.values();
129         size_t valuesSize = values.size();
130         ASSERT(!(valuesSize % 2));
131         std::unique_ptr&lt;Vector&lt;FloatPoint&gt;&gt; vertices = makeUnique&lt;Vector&lt;FloatPoint&gt;&gt;(valuesSize / 2);
132         for (unsigned i = 0; i &lt; valuesSize; i += 2) {
133             FloatPoint vertex(
134                 floatValueForLength(values.at(i), boxWidth),
135                 floatValueForLength(values.at(i + 1), boxHeight));
136             (*vertices)[i / 2] = physicalPointToLogical(vertex, logicalBoxSize.height(), writingMode);
137         }
138 
139         shape = createPolygonShape(WTFMove(vertices), polygon.windRule());
140         break;
141     }
142 
<span class="line-modified">143     case BasicShape::BasicShapeInsetType: {</span>
144         const auto&amp; inset = downcast&lt;BasicShapeInset&gt;(basicShape);
145         float left = floatValueForLength(inset.left(), boxWidth);
146         float top = floatValueForLength(inset.top(), boxHeight);
147         FloatRect rect(left,
148             top,
149             std::max&lt;float&gt;(boxWidth - left - floatValueForLength(inset.right(), boxWidth), 0),
150             std::max&lt;float&gt;(boxHeight - top - floatValueForLength(inset.bottom(), boxHeight), 0));
151         FloatRect logicalRect = physicalRectToLogical(rect, logicalBoxSize.height(), writingMode);
152 
153         FloatSize boxSize(boxWidth, boxHeight);
154         FloatSize topLeftRadius = physicalSizeToLogical(floatSizeForLengthSize(inset.topLeftRadius(), boxSize), writingMode);
155         FloatSize topRightRadius = physicalSizeToLogical(floatSizeForLengthSize(inset.topRightRadius(), boxSize), writingMode);
156         FloatSize bottomLeftRadius = physicalSizeToLogical(floatSizeForLengthSize(inset.bottomLeftRadius(), boxSize), writingMode);
157         FloatSize bottomRightRadius = physicalSizeToLogical(floatSizeForLengthSize(inset.bottomRightRadius(), boxSize), writingMode);
158         FloatRoundedRect::Radii cornerRadii(topLeftRadius, topRightRadius, bottomLeftRadius, bottomRightRadius);
159 
160         cornerRadii.scale(calcBorderRadiiConstraintScaleFor(logicalRect, cornerRadii));
161 
162         shape = createInsetShape(FloatRoundedRect(logicalRect, cornerRadii));
163         break;
164     }
165 
166     default:
167         ASSERT_NOT_REACHED();
168     }
169 
170     shape-&gt;m_writingMode = writingMode;
171     shape-&gt;m_margin = margin;
172 
173     return shape;
174 }
175 
176 std::unique_ptr&lt;Shape&gt; Shape::createRasterShape(Image* image, float threshold, const LayoutRect&amp; imageR, const LayoutRect&amp; marginR, WritingMode writingMode, float margin)
177 {
178     ASSERT(marginR.height() &gt;= 0);
179 
180     IntRect imageRect = snappedIntRect(imageR);
181     IntRect marginRect = snappedIntRect(marginR);
182     auto intervals = makeUnique&lt;RasterShapeIntervals&gt;(marginRect.height(), -marginRect.y());
183     // FIXME (149420): This buffer should not be unconditionally unaccelerated.
<span class="line-modified">184     std::unique_ptr&lt;ImageBuffer&gt; imageBuffer = ImageBuffer::create(imageRect.size(), Unaccelerated);</span>
185 
186     if (imageBuffer) {
187         GraphicsContext&amp; graphicsContext = imageBuffer-&gt;context();
188         if (image)
189             graphicsContext.drawImage(*image, IntRect(IntPoint(), imageRect.size()));
190 
191         RefPtr&lt;Uint8ClampedArray&gt; pixelArray = imageBuffer-&gt;getUnmultipliedImageData(IntRect(IntPoint(), imageRect.size()));
192         RELEASE_ASSERT(pixelArray);
193         unsigned pixelArrayLength = pixelArray-&gt;length();
194         unsigned pixelArrayOffset = 3; // Each pixel is four bytes: RGBA.
<span class="line-modified">195         uint8_t alphaPixelThreshold = threshold * 255;</span>
196 
197         int minBufferY = std::max(0, marginRect.y() - imageRect.y());
198         int maxBufferY = std::min(imageRect.height(), marginRect.maxY() - imageRect.y());
199 
200         if ((imageRect.area() * 4).unsafeGet() == pixelArrayLength) {
201             for (int y = minBufferY; y &lt; maxBufferY; ++y) {
202                 int startX = -1;
203                 for (int x = 0; x &lt; imageRect.width(); ++x, pixelArrayOffset += 4) {
204                     uint8_t alpha = pixelArray-&gt;item(pixelArrayOffset);
205                     bool alphaAboveThreshold = alpha &gt; alphaPixelThreshold;
206                     if (startX == -1 &amp;&amp; alphaAboveThreshold) {
207                         startX = x;
208                     } else if (startX != -1 &amp;&amp; (!alphaAboveThreshold || x == imageRect.width() - 1)) {
209                         // We&#39;re creating &quot;end-point exclusive&quot; intervals here. The value of an interval&#39;s x1 is
210                         // the first index of an above-threshold pixel for y, and the value of x2 is 1+ the index
211                         // of the last above-threshold pixel.
212                         int endX = alphaAboveThreshold ? x + 1 : x;
213                         intervals-&gt;intervalAt(y + imageRect.y()).unite(IntShapeInterval(startX + imageRect.x(), endX + imageRect.x()));
214                         startX = -1;
215                     }
</pre>
</td>
<td>
<hr />
<pre>
 83         return FloatPoint(point.y(), logicalBoxHeight - point.x());
 84     return point.transposedPoint();
 85 }
 86 
 87 static inline FloatSize physicalSizeToLogical(const FloatSize&amp; size, WritingMode writingMode)
 88 {
 89     if (isHorizontalWritingMode(writingMode))
 90         return size;
 91     return size.transposedSize();
 92 }
 93 
 94 std::unique_ptr&lt;Shape&gt; Shape::createShape(const BasicShape&amp; basicShape, const LayoutSize&amp; logicalBoxSize, WritingMode writingMode, float margin)
 95 {
 96     bool horizontalWritingMode = isHorizontalWritingMode(writingMode);
 97     float boxWidth = horizontalWritingMode ? logicalBoxSize.width() : logicalBoxSize.height();
 98     float boxHeight = horizontalWritingMode ? logicalBoxSize.height() : logicalBoxSize.width();
 99     std::unique_ptr&lt;Shape&gt; shape;
100 
101     switch (basicShape.type()) {
102 
<span class="line-modified">103     case BasicShape::Type::Circle: {</span>
104         const auto&amp; circle = downcast&lt;BasicShapeCircle&gt;(basicShape);
105         float centerX = floatValueForCenterCoordinate(circle.centerX(), boxWidth);
106         float centerY = floatValueForCenterCoordinate(circle.centerY(), boxHeight);
107         float radius = circle.floatValueForRadiusInBox(boxWidth, boxHeight);
108         FloatPoint logicalCenter = physicalPointToLogical(FloatPoint(centerX, centerY), logicalBoxSize.height(), writingMode);
109 
110         shape = createCircleShape(logicalCenter, radius);
111         break;
112     }
113 
<span class="line-modified">114     case BasicShape::Type::Ellipse: {</span>
115         const auto&amp; ellipse = downcast&lt;BasicShapeEllipse&gt;(basicShape);
116         float centerX = floatValueForCenterCoordinate(ellipse.centerX(), boxWidth);
117         float centerY = floatValueForCenterCoordinate(ellipse.centerY(), boxHeight);
118         float radiusX = ellipse.floatValueForRadiusInBox(ellipse.radiusX(), centerX, boxWidth);
119         float radiusY = ellipse.floatValueForRadiusInBox(ellipse.radiusY(), centerY, boxHeight);
120         FloatPoint logicalCenter = physicalPointToLogical(FloatPoint(centerX, centerY), logicalBoxSize.height(), writingMode);
121 
122         shape = createEllipseShape(logicalCenter, FloatSize(radiusX, radiusY));
123         break;
124     }
125 
<span class="line-modified">126     case BasicShape::Type::Polygon: {</span>
127         const auto&amp; polygon = downcast&lt;BasicShapePolygon&gt;(basicShape);
128         const Vector&lt;Length&gt;&amp; values = polygon.values();
129         size_t valuesSize = values.size();
130         ASSERT(!(valuesSize % 2));
131         std::unique_ptr&lt;Vector&lt;FloatPoint&gt;&gt; vertices = makeUnique&lt;Vector&lt;FloatPoint&gt;&gt;(valuesSize / 2);
132         for (unsigned i = 0; i &lt; valuesSize; i += 2) {
133             FloatPoint vertex(
134                 floatValueForLength(values.at(i), boxWidth),
135                 floatValueForLength(values.at(i + 1), boxHeight));
136             (*vertices)[i / 2] = physicalPointToLogical(vertex, logicalBoxSize.height(), writingMode);
137         }
138 
139         shape = createPolygonShape(WTFMove(vertices), polygon.windRule());
140         break;
141     }
142 
<span class="line-modified">143     case BasicShape::Type::Inset: {</span>
144         const auto&amp; inset = downcast&lt;BasicShapeInset&gt;(basicShape);
145         float left = floatValueForLength(inset.left(), boxWidth);
146         float top = floatValueForLength(inset.top(), boxHeight);
147         FloatRect rect(left,
148             top,
149             std::max&lt;float&gt;(boxWidth - left - floatValueForLength(inset.right(), boxWidth), 0),
150             std::max&lt;float&gt;(boxHeight - top - floatValueForLength(inset.bottom(), boxHeight), 0));
151         FloatRect logicalRect = physicalRectToLogical(rect, logicalBoxSize.height(), writingMode);
152 
153         FloatSize boxSize(boxWidth, boxHeight);
154         FloatSize topLeftRadius = physicalSizeToLogical(floatSizeForLengthSize(inset.topLeftRadius(), boxSize), writingMode);
155         FloatSize topRightRadius = physicalSizeToLogical(floatSizeForLengthSize(inset.topRightRadius(), boxSize), writingMode);
156         FloatSize bottomLeftRadius = physicalSizeToLogical(floatSizeForLengthSize(inset.bottomLeftRadius(), boxSize), writingMode);
157         FloatSize bottomRightRadius = physicalSizeToLogical(floatSizeForLengthSize(inset.bottomRightRadius(), boxSize), writingMode);
158         FloatRoundedRect::Radii cornerRadii(topLeftRadius, topRightRadius, bottomLeftRadius, bottomRightRadius);
159 
160         cornerRadii.scale(calcBorderRadiiConstraintScaleFor(logicalRect, cornerRadii));
161 
162         shape = createInsetShape(FloatRoundedRect(logicalRect, cornerRadii));
163         break;
164     }
165 
166     default:
167         ASSERT_NOT_REACHED();
168     }
169 
170     shape-&gt;m_writingMode = writingMode;
171     shape-&gt;m_margin = margin;
172 
173     return shape;
174 }
175 
176 std::unique_ptr&lt;Shape&gt; Shape::createRasterShape(Image* image, float threshold, const LayoutRect&amp; imageR, const LayoutRect&amp; marginR, WritingMode writingMode, float margin)
177 {
178     ASSERT(marginR.height() &gt;= 0);
179 
180     IntRect imageRect = snappedIntRect(imageR);
181     IntRect marginRect = snappedIntRect(marginR);
182     auto intervals = makeUnique&lt;RasterShapeIntervals&gt;(marginRect.height(), -marginRect.y());
183     // FIXME (149420): This buffer should not be unconditionally unaccelerated.
<span class="line-modified">184     std::unique_ptr&lt;ImageBuffer&gt; imageBuffer = ImageBuffer::create(imageRect.size(), RenderingMode::Unaccelerated);</span>
185 
186     if (imageBuffer) {
187         GraphicsContext&amp; graphicsContext = imageBuffer-&gt;context();
188         if (image)
189             graphicsContext.drawImage(*image, IntRect(IntPoint(), imageRect.size()));
190 
191         RefPtr&lt;Uint8ClampedArray&gt; pixelArray = imageBuffer-&gt;getUnmultipliedImageData(IntRect(IntPoint(), imageRect.size()));
192         RELEASE_ASSERT(pixelArray);
193         unsigned pixelArrayLength = pixelArray-&gt;length();
194         unsigned pixelArrayOffset = 3; // Each pixel is four bytes: RGBA.
<span class="line-modified">195         uint8_t alphaPixelThreshold = static_cast&lt;uint8_t&gt;(lroundf(clampTo&lt;float&gt;(threshold, 0, 1) * 255.0f));</span>
196 
197         int minBufferY = std::max(0, marginRect.y() - imageRect.y());
198         int maxBufferY = std::min(imageRect.height(), marginRect.maxY() - imageRect.y());
199 
200         if ((imageRect.area() * 4).unsafeGet() == pixelArrayLength) {
201             for (int y = minBufferY; y &lt; maxBufferY; ++y) {
202                 int startX = -1;
203                 for (int x = 0; x &lt; imageRect.width(); ++x, pixelArrayOffset += 4) {
204                     uint8_t alpha = pixelArray-&gt;item(pixelArrayOffset);
205                     bool alphaAboveThreshold = alpha &gt; alphaPixelThreshold;
206                     if (startX == -1 &amp;&amp; alphaAboveThreshold) {
207                         startX = x;
208                     } else if (startX != -1 &amp;&amp; (!alphaAboveThreshold || x == imageRect.width() - 1)) {
209                         // We&#39;re creating &quot;end-point exclusive&quot; intervals here. The value of an interval&#39;s x1 is
210                         // the first index of an above-threshold pixel for y, and the value of x2 is 1+ the index
211                         // of the last above-threshold pixel.
212                         int endX = alphaAboveThreshold ? x + 1 : x;
213                         intervals-&gt;intervalAt(y + imageRect.y()).unite(IntShapeInterval(startX + imageRect.x(), endX + imageRect.x()));
214                         startX = -1;
215                     }
</pre>
</td>
</tr>
</table>
<center><a href="RectangleShape.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ShapeOutsideInfo.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
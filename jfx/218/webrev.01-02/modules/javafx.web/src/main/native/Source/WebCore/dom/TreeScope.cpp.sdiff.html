<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/TreeScope.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TransitionEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TreeScope.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/TreeScope.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 #include &quot;config.h&quot;
 28 #include &quot;TreeScope.h&quot;
 29 
 30 #include &quot;Attr.h&quot;
 31 #include &quot;DOMWindow.h&quot;
 32 #include &quot;ElementIterator.h&quot;
 33 #include &quot;FocusController.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;HTMLAnchorElement.h&quot;
 37 #include &quot;HTMLFrameOwnerElement.h&quot;
 38 #include &quot;HTMLImageElement.h&quot;
 39 #include &quot;HTMLLabelElement.h&quot;
 40 #include &quot;HTMLMapElement.h&quot;
 41 #include &quot;HitTestResult.h&quot;
 42 #include &quot;IdTargetObserverRegistry.h&quot;
 43 #include &quot;NodeRareData.h&quot;
 44 #include &quot;Page.h&quot;
 45 #include &quot;PointerLockController.h&quot;
 46 #include &quot;PseudoElement.h&quot;

 47 #include &quot;RenderView.h&quot;
<span class="line-removed"> 48 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
 49 #include &quot;Settings.h&quot;
 50 #include &quot;ShadowRoot.h&quot;
 51 #include &lt;wtf/text/CString.h&gt;
 52 
 53 namespace WebCore {
 54 
 55 struct SameSizeAsTreeScope {
<span class="line-modified"> 56     void* pointers[9];</span>
 57 };
 58 
 59 COMPILE_ASSERT(sizeof(TreeScope) == sizeof(SameSizeAsTreeScope), treescope_should_stay_small);
 60 
 61 using namespace HTMLNames;
 62 
 63 TreeScope::TreeScope(ShadowRoot&amp; shadowRoot, Document&amp; document)
 64     : m_rootNode(shadowRoot)
 65     , m_documentScope(document)
 66     , m_parentTreeScope(&amp;document)
 67     , m_idTargetObserverRegistry(makeUnique&lt;IdTargetObserverRegistry&gt;())
 68 {
 69     shadowRoot.setTreeScope(*this);
 70 }
 71 
 72 TreeScope::TreeScope(Document&amp; document)
 73     : m_rootNode(document)
 74     , m_documentScope(document)
 75     , m_parentTreeScope(nullptr)
 76     , m_idTargetObserverRegistry(makeUnique&lt;IdTargetObserverRegistry&gt;())
</pre>
<hr />
<pre>
 95     ASSERT(!m_rootNode.isDocumentNode());
 96 
 97     m_parentTreeScope = &amp;newParentScope;
 98     setDocumentScope(newParentScope.documentScope());
 99 }
100 
101 Element* TreeScope::getElementById(const AtomString&amp; elementId) const
102 {
103     if (elementId.isNull())
104         return nullptr;
105     if (!m_elementsById)
106         return nullptr;
107     return m_elementsById-&gt;getElementById(*elementId.impl(), *this);
108 }
109 
110 Element* TreeScope::getElementById(const String&amp; elementId) const
111 {
112     if (!m_elementsById)
113         return nullptr;
114 
<span class="line-modified">115     if (RefPtr&lt;AtomStringImpl&gt; atomicElementId = AtomStringImpl::lookUp(elementId.impl()))</span>
<span class="line-modified">116         return m_elementsById-&gt;getElementById(*atomicElementId, *this);</span>
117 
118     return nullptr;
119 }
120 
121 Element* TreeScope::getElementById(StringView elementId) const
122 {
123     if (!m_elementsById)
124         return nullptr;
125 
<span class="line-modified">126     if (auto atomicElementId = elementId.toExistingAtomString())</span>
<span class="line-modified">127         return m_elementsById-&gt;getElementById(*atomicElementId, *this);</span>
128 
129     return nullptr;
130 }
131 
132 const Vector&lt;Element*&gt;* TreeScope::getAllElementsById(const AtomString&amp; elementId) const
133 {
134     if (elementId.isEmpty())
135         return nullptr;
136     if (!m_elementsById)
137         return nullptr;
138     return m_elementsById-&gt;getAllElementsById(*elementId.impl(), *this);
139 }
140 
141 void TreeScope::addElementById(const AtomStringImpl&amp; elementId, Element&amp; element, bool notifyObservers)
142 {
143     if (!m_elementsById)
144         m_elementsById = makeUnique&lt;TreeScopeOrderedMap&gt;();
145     m_elementsById-&gt;add(elementId, element, *this);
146     if (notifyObservers)
147         m_idTargetObserverRegistry-&gt;notifyObservers(elementId);
</pre>
<hr />
<pre>
522         return &amp;nodeA-&gt;treeScope();
523 
524     Vector&lt;TreeScope*, 5&gt; treeScopesA;
525     listTreeScopes(nodeA, treeScopesA);
526 
527     Vector&lt;TreeScope*, 5&gt; treeScopesB;
528     listTreeScopes(nodeB, treeScopesB);
529 
530     size_t indexA = treeScopesA.size();
531     size_t indexB = treeScopesB.size();
532 
533     for (; indexA &gt; 0 &amp;&amp; indexB &gt; 0 &amp;&amp; treeScopesA[indexA - 1] == treeScopesB[indexB - 1]; --indexA, --indexB) { }
534 
535     // If the nodes had no common tree scope, return immediately.
536     if (indexA == treeScopesA.size())
537         return nullptr;
538 
539     return treeScopesA[indexA] == treeScopesB[indexB] ? treeScopesA[indexA] : nullptr;
540 }
541 







542 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 27 #include &quot;config.h&quot;
 28 #include &quot;TreeScope.h&quot;
 29 
 30 #include &quot;Attr.h&quot;
 31 #include &quot;DOMWindow.h&quot;
 32 #include &quot;ElementIterator.h&quot;
 33 #include &quot;FocusController.h&quot;
 34 #include &quot;Frame.h&quot;
 35 #include &quot;FrameView.h&quot;
 36 #include &quot;HTMLAnchorElement.h&quot;
 37 #include &quot;HTMLFrameOwnerElement.h&quot;
 38 #include &quot;HTMLImageElement.h&quot;
 39 #include &quot;HTMLLabelElement.h&quot;
 40 #include &quot;HTMLMapElement.h&quot;
 41 #include &quot;HitTestResult.h&quot;
 42 #include &quot;IdTargetObserverRegistry.h&quot;
 43 #include &quot;NodeRareData.h&quot;
 44 #include &quot;Page.h&quot;
 45 #include &quot;PointerLockController.h&quot;
 46 #include &quot;PseudoElement.h&quot;
<span class="line-added"> 47 #include &quot;RadioButtonGroups.h&quot;</span>
 48 #include &quot;RenderView.h&quot;

 49 #include &quot;Settings.h&quot;
 50 #include &quot;ShadowRoot.h&quot;
 51 #include &lt;wtf/text/CString.h&gt;
 52 
 53 namespace WebCore {
 54 
 55 struct SameSizeAsTreeScope {
<span class="line-modified"> 56     void* pointers[10];</span>
 57 };
 58 
 59 COMPILE_ASSERT(sizeof(TreeScope) == sizeof(SameSizeAsTreeScope), treescope_should_stay_small);
 60 
 61 using namespace HTMLNames;
 62 
 63 TreeScope::TreeScope(ShadowRoot&amp; shadowRoot, Document&amp; document)
 64     : m_rootNode(shadowRoot)
 65     , m_documentScope(document)
 66     , m_parentTreeScope(&amp;document)
 67     , m_idTargetObserverRegistry(makeUnique&lt;IdTargetObserverRegistry&gt;())
 68 {
 69     shadowRoot.setTreeScope(*this);
 70 }
 71 
 72 TreeScope::TreeScope(Document&amp; document)
 73     : m_rootNode(document)
 74     , m_documentScope(document)
 75     , m_parentTreeScope(nullptr)
 76     , m_idTargetObserverRegistry(makeUnique&lt;IdTargetObserverRegistry&gt;())
</pre>
<hr />
<pre>
 95     ASSERT(!m_rootNode.isDocumentNode());
 96 
 97     m_parentTreeScope = &amp;newParentScope;
 98     setDocumentScope(newParentScope.documentScope());
 99 }
100 
101 Element* TreeScope::getElementById(const AtomString&amp; elementId) const
102 {
103     if (elementId.isNull())
104         return nullptr;
105     if (!m_elementsById)
106         return nullptr;
107     return m_elementsById-&gt;getElementById(*elementId.impl(), *this);
108 }
109 
110 Element* TreeScope::getElementById(const String&amp; elementId) const
111 {
112     if (!m_elementsById)
113         return nullptr;
114 
<span class="line-modified">115     if (auto atomElementId = AtomStringImpl::lookUp(elementId.impl()))</span>
<span class="line-modified">116         return m_elementsById-&gt;getElementById(*atomElementId, *this);</span>
117 
118     return nullptr;
119 }
120 
121 Element* TreeScope::getElementById(StringView elementId) const
122 {
123     if (!m_elementsById)
124         return nullptr;
125 
<span class="line-modified">126     if (auto atomElementId = elementId.toExistingAtomString())</span>
<span class="line-modified">127         return m_elementsById-&gt;getElementById(*atomElementId, *this);</span>
128 
129     return nullptr;
130 }
131 
132 const Vector&lt;Element*&gt;* TreeScope::getAllElementsById(const AtomString&amp; elementId) const
133 {
134     if (elementId.isEmpty())
135         return nullptr;
136     if (!m_elementsById)
137         return nullptr;
138     return m_elementsById-&gt;getAllElementsById(*elementId.impl(), *this);
139 }
140 
141 void TreeScope::addElementById(const AtomStringImpl&amp; elementId, Element&amp; element, bool notifyObservers)
142 {
143     if (!m_elementsById)
144         m_elementsById = makeUnique&lt;TreeScopeOrderedMap&gt;();
145     m_elementsById-&gt;add(elementId, element, *this);
146     if (notifyObservers)
147         m_idTargetObserverRegistry-&gt;notifyObservers(elementId);
</pre>
<hr />
<pre>
522         return &amp;nodeA-&gt;treeScope();
523 
524     Vector&lt;TreeScope*, 5&gt; treeScopesA;
525     listTreeScopes(nodeA, treeScopesA);
526 
527     Vector&lt;TreeScope*, 5&gt; treeScopesB;
528     listTreeScopes(nodeB, treeScopesB);
529 
530     size_t indexA = treeScopesA.size();
531     size_t indexB = treeScopesB.size();
532 
533     for (; indexA &gt; 0 &amp;&amp; indexB &gt; 0 &amp;&amp; treeScopesA[indexA - 1] == treeScopesB[indexB - 1]; --indexA, --indexB) { }
534 
535     // If the nodes had no common tree scope, return immediately.
536     if (indexA == treeScopesA.size())
537         return nullptr;
538 
539     return treeScopesA[indexA] == treeScopesB[indexB] ? treeScopesA[indexA] : nullptr;
540 }
541 
<span class="line-added">542 RadioButtonGroups&amp; TreeScope::radioButtonGroups()</span>
<span class="line-added">543 {</span>
<span class="line-added">544     if (!m_radioButtonGroups)</span>
<span class="line-added">545         m_radioButtonGroups = makeUnique&lt;RadioButtonGroups&gt;();</span>
<span class="line-added">546     return *m_radioButtonGroups;</span>
<span class="line-added">547 }</span>
<span class="line-added">548 </span>
549 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="TransitionEvent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="TreeScope.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
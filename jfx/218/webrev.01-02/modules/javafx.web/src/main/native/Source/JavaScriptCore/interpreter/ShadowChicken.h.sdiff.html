<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/ShadowChicken.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ShadowChicken.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ShadowChickenInlines.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/interpreter/ShadowChicken.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CallFrame.h&quot;
 29 #include &quot;JSCJSValue.h&quot;
 30 #include &lt;wtf/FastMalloc.h&gt;
 31 #include &lt;wtf/Noncopyable.h&gt;
 32 #include &lt;wtf/PrintStream.h&gt;
 33 #include &lt;wtf/StdLibExtras.h&gt;
 34 #include &lt;wtf/Vector.h&gt;
 35 
 36 namespace JSC {
 37 

 38 class CodeBlock;
<span class="line-removed"> 39 class ExecState;</span>
 40 class JSArray;
 41 class JSObject;
 42 class JSScope;
 43 class LLIntOffsetsExtractor;
 44 class SlotVisitor;
 45 class VM;
 46 
<span class="line-removed"> 47 typedef ExecState CallFrame;</span>
<span class="line-removed"> 48 </span>
 49 // ShadowChicken is a log that can be used to produce a shadow stack of CHICKEN-style stack frames.
 50 // This enables the debugger to almost always see the tail-deleted stack frames, so long as we have
 51 // memory inside ShadowChicken to remember them.
 52 //
 53 // The ShadowChicken log comprises packets that have one of two shapes:
 54 //
 55 // Prologue Packet, which has:
 56 //     - Callee object.
 57 //     - Frame pointer.
 58 //     - Caller frame pointer.
 59 //
 60 // Tail Call Packet, which has just:
 61 //     - Frame pointer.
 62 //
 63 // Prologue Packets are placed into the log in any JS function&#39;s prologue. Tail Call Packets are
 64 // placed into the log just before making a proper tail call. We never log returns, since that would
 65 // require a lot of infrastructure (unwinding, multiple ways of returning, etc). We don&#39;t need to
 66 // see the returns because the prologue packets have a frame pointer. The tail call packets tell us
 67 // when there was a tail call, and record the FP *before* the tail call.
 68 //
 69 // At any time it is possible to construct a shadow stack from the log and the actual machine stack.
 70 
 71 class ShadowChicken {
 72     WTF_MAKE_NONCOPYABLE(ShadowChicken);
 73     WTF_MAKE_FAST_ALLOCATED;
 74 public:
 75     struct Packet {
 76         Packet()
 77         {
 78         }
 79 
<span class="line-modified"> 80         static const constexpr unsigned unlikelyValue = 0x7a11;</span>
 81 
<span class="line-modified"> 82         static const constexpr intptr_t tailMarkerValue = static_cast&lt;intptr_t&gt;(unlikelyValue);</span>
 83         static JSObject* tailMarker()
 84         {
 85             return bitwise_cast&lt;JSObject*&gt;(tailMarkerValue);
 86         }
 87 
 88         static JSObject* throwMarker()
 89         {
 90             return bitwise_cast&lt;JSObject*&gt;(static_cast&lt;intptr_t&gt;(unlikelyValue + 1));
 91         }
 92 
 93         static Packet prologue(JSObject* callee, CallFrame* frame, CallFrame* callerFrame, JSScope* scope)
 94         {
 95             Packet result;
 96             result.callee = callee;
 97             result.frame = frame;
 98             result.callerFrame = callerFrame;
 99             result.scope = scope;
100             return result;
101         }
102 
</pre>
<hr />
<pre>
169             return !(*this == other);
170         }
171 
172         void dump(PrintStream&amp;) const;
173 
174         // FIXME: This should be able to hold the moral equivalent of StackVisitor::Frame, so that
175         // we can support inlining.
176         // https://bugs.webkit.org/show_bug.cgi?id=155686
177         JSObject* callee { nullptr };
178         CallFrame* frame { nullptr };
179         JSValue thisValue { JSValue() };
180         JSScope* scope { nullptr };
181         CodeBlock* codeBlock { nullptr };
182         CallSiteIndex callSiteIndex;
183         bool isTailDeleted { false };
184     };
185 
186     ShadowChicken();
187     ~ShadowChicken();
188 
<span class="line-modified">189     void log(VM&amp; vm, ExecState* exec, const Packet&amp;);</span>
190 
<span class="line-modified">191     void update(VM&amp;, ExecState*);</span>
192 
193     // Expects this signature: (const Frame&amp; frame) -&gt; bool. Return true to keep iterating. Return false to stop iterating.
194     // Note that this only works right with inlining disabled, but that&#39;s OK since for now we
195     // disable inlining when the inspector is attached. It would be easy to make this work with
196     // inlining, and would mostly require that we can request that StackVisitor doesn&#39;t skip tail
197     // frames.
198     template&lt;typename Functor&gt;
<span class="line-modified">199     void iterate(VM&amp;, ExecState*, const Functor&amp;);</span>
200 
201     void visitChildren(SlotVisitor&amp;);
202     void reset();
203 
204     // JIT support.
205     Packet* log() const { return m_log; }
206     unsigned logSize() const { return m_logSize; }
207     Packet** addressOfLogCursor() { return &amp;m_logCursor; }
208     Packet* logEnd() { return m_logEnd; }
209 
210     void dump(PrintStream&amp;) const;
211 
<span class="line-modified">212     JS_EXPORT_PRIVATE JSArray* functionsOnStack(ExecState*);</span>
213 
214 private:
215     friend class LLIntOffsetsExtractor;
216 
217     Packet* m_log { nullptr };
218     unsigned m_logSize { 0 };
219     Packet* m_logCursor { nullptr };
220     Packet* m_logEnd { nullptr };
221 
222     Vector&lt;Frame&gt; m_stack;
223 };
224 
225 } // namespace JSC
226 
</pre>
</td>
<td>
<hr />
<pre>
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CallFrame.h&quot;
 29 #include &quot;JSCJSValue.h&quot;
 30 #include &lt;wtf/FastMalloc.h&gt;
 31 #include &lt;wtf/Noncopyable.h&gt;
 32 #include &lt;wtf/PrintStream.h&gt;
 33 #include &lt;wtf/StdLibExtras.h&gt;
 34 #include &lt;wtf/Vector.h&gt;
 35 
 36 namespace JSC {
 37 
<span class="line-added"> 38 class CallFrame;</span>
 39 class CodeBlock;

 40 class JSArray;
 41 class JSObject;
 42 class JSScope;
 43 class LLIntOffsetsExtractor;
 44 class SlotVisitor;
 45 class VM;
 46 


 47 // ShadowChicken is a log that can be used to produce a shadow stack of CHICKEN-style stack frames.
 48 // This enables the debugger to almost always see the tail-deleted stack frames, so long as we have
 49 // memory inside ShadowChicken to remember them.
 50 //
 51 // The ShadowChicken log comprises packets that have one of two shapes:
 52 //
 53 // Prologue Packet, which has:
 54 //     - Callee object.
 55 //     - Frame pointer.
 56 //     - Caller frame pointer.
 57 //
 58 // Tail Call Packet, which has just:
 59 //     - Frame pointer.
 60 //
 61 // Prologue Packets are placed into the log in any JS function&#39;s prologue. Tail Call Packets are
 62 // placed into the log just before making a proper tail call. We never log returns, since that would
 63 // require a lot of infrastructure (unwinding, multiple ways of returning, etc). We don&#39;t need to
 64 // see the returns because the prologue packets have a frame pointer. The tail call packets tell us
 65 // when there was a tail call, and record the FP *before* the tail call.
 66 //
 67 // At any time it is possible to construct a shadow stack from the log and the actual machine stack.
 68 
 69 class ShadowChicken {
 70     WTF_MAKE_NONCOPYABLE(ShadowChicken);
 71     WTF_MAKE_FAST_ALLOCATED;
 72 public:
 73     struct Packet {
 74         Packet()
 75         {
 76         }
 77 
<span class="line-modified"> 78         static constexpr unsigned unlikelyValue = 0x7a11;</span>
 79 
<span class="line-modified"> 80         static constexpr intptr_t tailMarkerValue = static_cast&lt;intptr_t&gt;(unlikelyValue);</span>
 81         static JSObject* tailMarker()
 82         {
 83             return bitwise_cast&lt;JSObject*&gt;(tailMarkerValue);
 84         }
 85 
 86         static JSObject* throwMarker()
 87         {
 88             return bitwise_cast&lt;JSObject*&gt;(static_cast&lt;intptr_t&gt;(unlikelyValue + 1));
 89         }
 90 
 91         static Packet prologue(JSObject* callee, CallFrame* frame, CallFrame* callerFrame, JSScope* scope)
 92         {
 93             Packet result;
 94             result.callee = callee;
 95             result.frame = frame;
 96             result.callerFrame = callerFrame;
 97             result.scope = scope;
 98             return result;
 99         }
100 
</pre>
<hr />
<pre>
167             return !(*this == other);
168         }
169 
170         void dump(PrintStream&amp;) const;
171 
172         // FIXME: This should be able to hold the moral equivalent of StackVisitor::Frame, so that
173         // we can support inlining.
174         // https://bugs.webkit.org/show_bug.cgi?id=155686
175         JSObject* callee { nullptr };
176         CallFrame* frame { nullptr };
177         JSValue thisValue { JSValue() };
178         JSScope* scope { nullptr };
179         CodeBlock* codeBlock { nullptr };
180         CallSiteIndex callSiteIndex;
181         bool isTailDeleted { false };
182     };
183 
184     ShadowChicken();
185     ~ShadowChicken();
186 
<span class="line-modified">187     void log(VM&amp; vm, CallFrame*, const Packet&amp;);</span>
188 
<span class="line-modified">189     void update(VM&amp;, CallFrame*);</span>
190 
191     // Expects this signature: (const Frame&amp; frame) -&gt; bool. Return true to keep iterating. Return false to stop iterating.
192     // Note that this only works right with inlining disabled, but that&#39;s OK since for now we
193     // disable inlining when the inspector is attached. It would be easy to make this work with
194     // inlining, and would mostly require that we can request that StackVisitor doesn&#39;t skip tail
195     // frames.
196     template&lt;typename Functor&gt;
<span class="line-modified">197     void iterate(VM&amp;, CallFrame*, const Functor&amp;);</span>
198 
199     void visitChildren(SlotVisitor&amp;);
200     void reset();
201 
202     // JIT support.
203     Packet* log() const { return m_log; }
204     unsigned logSize() const { return m_logSize; }
205     Packet** addressOfLogCursor() { return &amp;m_logCursor; }
206     Packet* logEnd() { return m_logEnd; }
207 
208     void dump(PrintStream&amp;) const;
209 
<span class="line-modified">210     JS_EXPORT_PRIVATE JSArray* functionsOnStack(JSGlobalObject*, CallFrame*);</span>
211 
212 private:
213     friend class LLIntOffsetsExtractor;
214 
215     Packet* m_log { nullptr };
216     unsigned m_logSize { 0 };
217     Packet* m_logCursor { nullptr };
218     Packet* m_logEnd { nullptr };
219 
220     Vector&lt;Frame&gt; m_stack;
221 };
222 
223 } // namespace JSC
224 
</pre>
</td>
</tr>
</table>
<center><a href="ShadowChicken.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ShadowChickenInlines.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/PasteboardCustomData.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;PasteboardCustomData.h&quot;
 28 
 29 #include &quot;SharedBuffer.h&quot;
 30 #include &lt;wtf/URLParser.h&gt;
 31 #include &lt;wtf/persistence/PersistentCoders.h&gt;
 32 #include &lt;wtf/text/StringHash.h&gt;
 33 
 34 namespace WebCore {
 35 
 36 static Variant&lt;String, Ref&lt;SharedBuffer&gt;&gt; copyPlatformData(const Variant&lt;String, Ref&lt;SharedBuffer&gt;&gt;&amp; other)
 37 {
 38     if (WTF::holds_alternative&lt;String&gt;(other))
 39         return { WTF::get&lt;String&gt;(other) };
 40 
 41     if (WTF::holds_alternative&lt;Ref&lt;SharedBuffer&gt;&gt;(other))
 42         return { WTF::get&lt;Ref&lt;SharedBuffer&gt;&gt;(other).copyRef() };
 43 
 44     return { };
 45 }
 46 
 47 PasteboardCustomData::Entry::Entry(const Entry&amp; entry)
 48     : type(entry.type)
 49     , customData(entry.customData)
 50     , platformData(copyPlatformData(entry.platformData))
 51 {
 52 }
 53 
 54 PasteboardCustomData::Entry::Entry(const String&amp; dataType)
 55     : type(dataType)
 56 {
 57 }
 58 
 59 PasteboardCustomData::Entry::Entry() = default;
 60 PasteboardCustomData::Entry::Entry(Entry&amp;&amp;) = default;
 61 
 62 PasteboardCustomData::Entry&amp; PasteboardCustomData::Entry::operator=(const Entry&amp; entry)
 63 {
 64     type = entry.type;
 65     customData = entry.customData;
 66     platformData = copyPlatformData(entry.platformData);
 67     return *this;
 68 }
 69 
 70 PasteboardCustomData::Entry&amp; PasteboardCustomData::Entry::operator=(Entry&amp;&amp;) = default;
 71 
 72 PasteboardCustomData::PasteboardCustomData() = default;
 73 PasteboardCustomData::PasteboardCustomData(const PasteboardCustomData&amp;) = default;
 74 PasteboardCustomData::PasteboardCustomData(PasteboardCustomData&amp;&amp;) = default;
 75 PasteboardCustomData::~PasteboardCustomData() = default;
 76 
 77 PasteboardCustomData::PasteboardCustomData(String&amp;&amp; origin, Vector&lt;Entry&gt;&amp;&amp; data)
 78     : m_origin(WTFMove(origin))
 79     , m_data(WTFMove(data))
 80 {
 81 }
 82 
 83 Ref&lt;SharedBuffer&gt; PasteboardCustomData::createSharedBuffer() const
 84 {
 85     constexpr unsigned currentCustomDataSerializationVersion = 1;
 86 
 87     WTF::Persistence::Encoder encoder;
 88     encoder &lt;&lt; currentCustomDataSerializationVersion;
 89     encoder &lt;&lt; m_origin;
 90     encoder &lt;&lt; sameOriginCustomStringData();
 91     encoder &lt;&lt; orderedTypes();
 92     return SharedBuffer::create(encoder.buffer(), encoder.bufferSize());
 93 }
 94 
 95 PasteboardCustomData PasteboardCustomData::fromSharedBuffer(const SharedBuffer&amp; buffer)
 96 {
 97     constexpr unsigned maxSupportedDataSerializationVersionNumber = 1;
 98 
 99     PasteboardCustomData result;
100     auto decoder = buffer.decoder();
101     unsigned version;
102     if (!decoder.decode(version) || version &gt; maxSupportedDataSerializationVersionNumber)
103         return { };
104 
105     if (!decoder.decode(result.m_origin))
106         return { };
107 
108     HashMap&lt;String, String&gt; sameOriginCustomStringData;
109     if (!decoder.decode(sameOriginCustomStringData))
110         return { };
111 
112     Vector&lt;String&gt; orderedTypes;
113     if (!decoder.decode(orderedTypes))
114         return { };
115 
116     for (auto&amp; type : orderedTypes)
117         result.writeStringInCustomData(type, sameOriginCustomStringData.get(type));
118 
119     return result;
120 }
121 
122 void PasteboardCustomData::writeString(const String&amp; type, const String&amp; value)
123 {
124     addOrMoveEntryToEnd(type).platformData = { value };
125 }
126 
127 void PasteboardCustomData::writeData(const String&amp; type, Ref&lt;SharedBuffer&gt;&amp;&amp; data)
128 {
129     addOrMoveEntryToEnd(type).platformData = { WTFMove(data) };
130 }
131 
132 void PasteboardCustomData::writeStringInCustomData(const String&amp; type, const String&amp; value)
133 {
134     addOrMoveEntryToEnd(type).customData = value;
135 }
136 
137 PasteboardCustomData::Entry&amp; PasteboardCustomData::addOrMoveEntryToEnd(const String&amp; type)
138 {
139     auto index = m_data.findMatching([&amp;] (auto&amp; entry) {
140         return entry.type == type;
141     });
142     auto entry = index == notFound ? Entry(type) : m_data[index];
143     if (index != notFound)
144         m_data.remove(index);
145     m_data.append(WTFMove(entry));
146     return m_data.last();
147 }
148 
149 void PasteboardCustomData::clear()
150 {
151     m_data.clear();
152 }
153 
154 void PasteboardCustomData::clear(const String&amp; type)
155 {
156     m_data.removeFirstMatching([&amp;] (auto&amp; entry) {
157         return entry.type == type;
158     });
159 }
160 
161 PasteboardCustomData&amp; PasteboardCustomData::operator=(const PasteboardCustomData&amp; other)
162 {
163     m_origin = other.origin();
164     m_data = other.m_data;
165     return *this;
166 }
167 
168 Vector&lt;String&gt; PasteboardCustomData::orderedTypes() const
169 {
170     return m_data.map([&amp;] (auto&amp; entry) {
171         return entry.type;
172     });
173 }
174 
175 bool PasteboardCustomData::hasData() const
176 {
177     return !m_data.isEmpty();
178 }
179 
180 bool PasteboardCustomData::hasSameOriginCustomData() const
181 {
182     return notFound != m_data.findMatching([&amp;] (auto&amp; entry) {
183         return !entry.customData.isNull();
184     });
185 }
186 
187 HashMap&lt;String, String&gt; PasteboardCustomData::sameOriginCustomStringData() const
188 {
189     HashMap&lt;String, String&gt; customData;
190     for (auto&amp; entry : m_data)
191         customData.set(entry.type, entry.customData);
192     return customData;
193 }
194 
195 RefPtr&lt;SharedBuffer&gt; PasteboardCustomData::readBuffer(const String&amp; type) const
196 {
197     for (auto&amp; entry : m_data) {
198         if (entry.type != type)
199             continue;
200 
201         if (WTF::holds_alternative&lt;Ref&lt;SharedBuffer&gt;&gt;(entry.platformData))
202             return makeRefPtr(WTF::get&lt;Ref&lt;SharedBuffer&gt;&gt;(entry.platformData).get());
203 
204         return nullptr;
205     }
206     return nullptr;
207 }
208 
209 String PasteboardCustomData::readString(const String&amp; type) const
210 {
211     for (auto&amp; entry : m_data) {
212         if (entry.type != type)
213             continue;
214 
215         if (WTF::holds_alternative&lt;String&gt;(entry.platformData))
216             return WTF::get&lt;String&gt;(entry.platformData);
217 
218         return { };
219     }
220     return { };
221 }
222 
223 String PasteboardCustomData::readStringInCustomData(const String&amp; type) const
224 {
225     for (auto&amp; entry : m_data) {
226         if (entry.type == type)
227             return entry.customData;
228     }
229     return { };
230 }
231 
232 void PasteboardCustomData::forEachType(Function&lt;void(const String&amp;)&gt;&amp;&amp; function) const
233 {
234     for (auto&amp; entry : m_data)
235         function(entry.type);
236 }
237 
238 void PasteboardCustomData::forEachPlatformString(Function&lt;void(const String&amp; type, const String&amp; data)&gt;&amp;&amp; function) const
239 {
240     for (auto&amp; entry : m_data) {
241         if (!WTF::holds_alternative&lt;String&gt;(entry.platformData))
242             continue;
243 
244         auto string = WTF::get&lt;String&gt;(entry.platformData);
245         if (!string.isNull())
246             function(entry.type, string);
247     }
248 }
249 
250 void PasteboardCustomData::forEachCustomString(Function&lt;void(const String&amp; type, const String&amp; data)&gt;&amp;&amp; function) const
251 {
252     for (auto&amp; entry : m_data) {
253         if (!entry.customData.isNull())
254             function(entry.type, entry.customData);
255     }
256 }
257 
258 void PasteboardCustomData::forEachPlatformStringOrBuffer(Function&lt;void(const String&amp; type, const Variant&lt;String, Ref&lt;SharedBuffer&gt;&gt;&amp; data)&gt;&amp;&amp; function) const
259 {
260     for (auto&amp; entry : m_data) {
261         auto&amp; data = entry.platformData;
262         if ((WTF::holds_alternative&lt;String&gt;(data) &amp;&amp; !WTF::get&lt;String&gt;(data).isNull()) || WTF::holds_alternative&lt;Ref&lt;SharedBuffer&gt;&gt;(data))
263             function(entry.type, data);
264     }
265 }
266 
267 } // namespace WebCore
    </pre>
  </body>
</html>
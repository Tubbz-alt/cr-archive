<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/crypto/SubtleCrypto.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CryptoAlgorithm.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SubtleCrypto.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/crypto/SubtleCrypto.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 76,21 ***</span>
      WrapKey,
      UnwrapKey,
      GetKeyLength
  };
  
<span class="line-modified">! static ExceptionOr&lt;std::unique_ptr&lt;CryptoAlgorithmParameters&gt;&gt; normalizeCryptoAlgorithmParameters(ExecState&amp;, WebCore::SubtleCrypto::AlgorithmIdentifier, Operations);</span>
  
<span class="line-modified">! static ExceptionOr&lt;CryptoAlgorithmIdentifier&gt; toHashIdentifier(ExecState&amp; state, SubtleCrypto::AlgorithmIdentifier algorithmIdentifier)</span>
  {
      auto digestParams = normalizeCryptoAlgorithmParameters(state, algorithmIdentifier, Operations::Digest);
      if (digestParams.hasException())
          return digestParams.releaseException();
      return digestParams.returnValue()-&gt;identifier;
  }
  
<span class="line-modified">! static ExceptionOr&lt;std::unique_ptr&lt;CryptoAlgorithmParameters&gt;&gt; normalizeCryptoAlgorithmParameters(ExecState&amp; state, SubtleCrypto::AlgorithmIdentifier algorithmIdentifier, Operations operation)</span>
  {
      VM&amp; vm = state.vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (WTF::holds_alternative&lt;String&gt;(algorithmIdentifier)) {
<span class="line-new-header">--- 76,21 ---</span>
      WrapKey,
      UnwrapKey,
      GetKeyLength
  };
  
<span class="line-modified">! static ExceptionOr&lt;std::unique_ptr&lt;CryptoAlgorithmParameters&gt;&gt; normalizeCryptoAlgorithmParameters(JSGlobalObject&amp;, WebCore::SubtleCrypto::AlgorithmIdentifier, Operations);</span>
  
<span class="line-modified">! static ExceptionOr&lt;CryptoAlgorithmIdentifier&gt; toHashIdentifier(JSGlobalObject&amp; state, SubtleCrypto::AlgorithmIdentifier algorithmIdentifier)</span>
  {
      auto digestParams = normalizeCryptoAlgorithmParameters(state, algorithmIdentifier, Operations::Digest);
      if (digestParams.hasException())
          return digestParams.releaseException();
      return digestParams.returnValue()-&gt;identifier;
  }
  
<span class="line-modified">! static ExceptionOr&lt;std::unique_ptr&lt;CryptoAlgorithmParameters&gt;&gt; normalizeCryptoAlgorithmParameters(JSGlobalObject&amp; state, SubtleCrypto::AlgorithmIdentifier algorithmIdentifier, Operations operation)</span>
  {
      VM&amp; vm = state.vm();
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (WTF::holds_alternative&lt;String&gt;(algorithmIdentifier)) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 536,11 ***</span>
      }
  }
  
  // MARK: - Exposed functions.
  
<span class="line-modified">! void SubtleCrypto::encrypt(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Encrypt);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
<span class="line-new-header">--- 536,11 ---</span>
      }
  }
  
  // MARK: - Exposed functions.
  
<span class="line-modified">! void SubtleCrypto::encrypt(JSC::JSGlobalObject&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Encrypt);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 574,11 ***</span>
      };
  
      algorithm-&gt;encrypt(*params, key, WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
  }
  
<span class="line-modified">! void SubtleCrypto::decrypt(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Decrypt);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
<span class="line-new-header">--- 574,11 ---</span>
      };
  
      algorithm-&gt;encrypt(*params, key, WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
  }
  
<span class="line-modified">! void SubtleCrypto::decrypt(JSC::JSGlobalObject&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Decrypt);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 612,11 ***</span>
      };
  
      algorithm-&gt;decrypt(*params, key, WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
  }
  
<span class="line-modified">! void SubtleCrypto::sign(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Sign);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
<span class="line-new-header">--- 612,11 ---</span>
      };
  
      algorithm-&gt;decrypt(*params, key, WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
  }
  
<span class="line-modified">! void SubtleCrypto::sign(JSC::JSGlobalObject&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Sign);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 650,11 ***</span>
      };
  
      algorithm-&gt;sign(*params, key, WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
  }
  
<span class="line-modified">! void SubtleCrypto::verify(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; signatureBufferSource, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Verify);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
<span class="line-new-header">--- 650,11 ---</span>
      };
  
      algorithm-&gt;sign(*params, key, WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
  }
  
<span class="line-modified">! void SubtleCrypto::verify(JSC::JSGlobalObject&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; key, BufferSource&amp;&amp; signatureBufferSource, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Verify);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 689,11 ***</span>
      };
  
      algorithm-&gt;verify(*params, key, WTFMove(signature), WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
  }
  
<span class="line-modified">! void SubtleCrypto::digest(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Digest);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
<span class="line-new-header">--- 689,11 ---</span>
      };
  
      algorithm-&gt;verify(*params, key, WTFMove(signature), WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
  }
  
<span class="line-modified">! void SubtleCrypto::digest(JSC::JSGlobalObject&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, BufferSource&amp;&amp; dataBufferSource, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::Digest);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 717,11 ***</span>
      };
  
      algorithm-&gt;digest(WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
  }
  
<span class="line-modified">! void SubtleCrypto::generateKey(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, bool extractable, Vector&lt;CryptoKeyUsage&gt;&amp;&amp; keyUsages, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::GenerateKey);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
<span class="line-new-header">--- 717,11 ---</span>
      };
  
      algorithm-&gt;digest(WTFMove(data), WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
  }
  
<span class="line-modified">! void SubtleCrypto::generateKey(JSC::JSGlobalObject&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, bool extractable, Vector&lt;CryptoKeyUsage&gt;&amp;&amp; keyUsages, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::GenerateKey);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 764,11 ***</span>
      // regardless what kind of keys it produces: https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-method-generateKey
      // That&#39;s simply not efficient for AES, HMAC and EC keys. Therefore, we perform it as an async task only for RSA keys.
      algorithm-&gt;generateKey(*params, extractable, keyUsagesBitmap, WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext());
  }
  
<span class="line-modified">! void SubtleCrypto::deriveKey(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; baseKey, AlgorithmIdentifier&amp;&amp; derivedKeyType, bool extractable, Vector&lt;CryptoKeyUsage&gt;&amp;&amp; keyUsages, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::DeriveBits);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
<span class="line-new-header">--- 764,11 ---</span>
      // regardless what kind of keys it produces: https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-method-generateKey
      // That&#39;s simply not efficient for AES, HMAC and EC keys. Therefore, we perform it as an async task only for RSA keys.
      algorithm-&gt;generateKey(*params, extractable, keyUsagesBitmap, WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext());
  }
  
<span class="line-modified">! void SubtleCrypto::deriveKey(JSC::JSGlobalObject&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; baseKey, AlgorithmIdentifier&amp;&amp; derivedKeyType, bool extractable, Vector&lt;CryptoKeyUsage&gt;&amp;&amp; keyUsages, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::DeriveBits);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 841,11 ***</span>
      };
  
      algorithm-&gt;deriveBits(*params, baseKey, length, WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
  }
  
<span class="line-modified">! void SubtleCrypto::deriveBits(JSC::ExecState&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; baseKey, unsigned length, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::DeriveBits);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
<span class="line-new-header">--- 841,11 ---</span>
      };
  
      algorithm-&gt;deriveBits(*params, baseKey, length, WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
  }
  
<span class="line-modified">! void SubtleCrypto::deriveBits(JSC::JSGlobalObject&amp; state, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, CryptoKey&amp; baseKey, unsigned length, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::DeriveBits);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 877,11 ***</span>
      };
  
      algorithm-&gt;deriveBits(*params, baseKey, length, WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
  }
  
<span class="line-modified">! void SubtleCrypto::importKey(JSC::ExecState&amp; state, KeyFormat format, KeyDataVariant&amp;&amp; keyDataVariant, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, bool extractable, Vector&lt;CryptoKeyUsage&gt;&amp;&amp; keyUsages, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::ImportKey);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
<span class="line-new-header">--- 877,11 ---</span>
      };
  
      algorithm-&gt;deriveBits(*params, baseKey, length, WTFMove(callback), WTFMove(exceptionCallback), *scriptExecutionContext(), m_workQueue);
  }
  
<span class="line-modified">! void SubtleCrypto::importKey(JSC::JSGlobalObject&amp; state, KeyFormat format, KeyDataVariant&amp;&amp; keyDataVariant, AlgorithmIdentifier&amp;&amp; algorithmIdentifier, bool extractable, Vector&lt;CryptoKeyUsage&gt;&amp;&amp; keyUsages, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto paramsOrException = normalizeCryptoAlgorithmParameters(state, WTFMove(algorithmIdentifier), Operations::ImportKey);
      if (paramsOrException.hasException()) {
          promise-&gt;reject(paramsOrException.releaseException());
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 965,11 ***</span>
      // https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-method-exportKey
      // It is not beneficial for less time consuming operations. Therefore, we perform it synchronously.
      algorithm-&gt;exportKey(format, key, WTFMove(callback), WTFMove(exceptionCallback));
  }
  
<span class="line-modified">! void SubtleCrypto::wrapKey(JSC::ExecState&amp; state, KeyFormat format, CryptoKey&amp; key, CryptoKey&amp; wrappingKey, AlgorithmIdentifier&amp;&amp; wrapAlgorithmIdentifier, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      bool isEncryption = false;
  
      auto wrapParamsOrException = normalizeCryptoAlgorithmParameters(state, wrapAlgorithmIdentifier, Operations::WrapKey);
      if (wrapParamsOrException.hasException()) {
<span class="line-new-header">--- 965,11 ---</span>
      // https://www.w3.org/TR/WebCryptoAPI/#SubtleCrypto-method-exportKey
      // It is not beneficial for less time consuming operations. Therefore, we perform it synchronously.
      algorithm-&gt;exportKey(format, key, WTFMove(callback), WTFMove(exceptionCallback));
  }
  
<span class="line-modified">! void SubtleCrypto::wrapKey(JSC::JSGlobalObject&amp; state, KeyFormat format, CryptoKey&amp; key, CryptoKey&amp; wrappingKey, AlgorithmIdentifier&amp;&amp; wrapAlgorithmIdentifier, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      bool isEncryption = false;
  
      auto wrapParamsOrException = normalizeCryptoAlgorithmParameters(state, wrapAlgorithmIdentifier, Operations::WrapKey);
      if (wrapParamsOrException.hasException()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1023,12 ***</span>
                  case SubtleCrypto::KeyFormat::Raw:
                      bytes = WTF::get&lt;Vector&lt;uint8_t&gt;&gt;(key);
                      break;
                  case SubtleCrypto::KeyFormat::Jwk: {
                      // FIXME: Converting to JS just to JSON-Stringify seems inefficient. We should find a way to go directly from the struct to JSON.
<span class="line-modified">!                     auto jwk = toJS&lt;IDLDictionary&lt;JsonWebKey&gt;&gt;(*(promise-&gt;globalObject()-&gt;globalExec()), *(promise-&gt;globalObject()), WTFMove(WTF::get&lt;JsonWebKey&gt;(key)));</span>
<span class="line-modified">!                     String jwkString = JSONStringify(promise-&gt;globalObject()-&gt;globalExec(), jwk, 0);</span>
                      CString jwkUtf8String = jwkString.utf8(StrictConversion);
                      bytes.append(jwkUtf8String.data(), jwkUtf8String.length());
                  }
                  }
  
<span class="line-new-header">--- 1023,12 ---</span>
                  case SubtleCrypto::KeyFormat::Raw:
                      bytes = WTF::get&lt;Vector&lt;uint8_t&gt;&gt;(key);
                      break;
                  case SubtleCrypto::KeyFormat::Jwk: {
                      // FIXME: Converting to JS just to JSON-Stringify seems inefficient. We should find a way to go directly from the struct to JSON.
<span class="line-modified">!                     auto jwk = toJS&lt;IDLDictionary&lt;JsonWebKey&gt;&gt;(*(promise-&gt;globalObject()), *(promise-&gt;globalObject()), WTFMove(WTF::get&lt;JsonWebKey&gt;(key)));</span>
<span class="line-modified">!                     String jwkString = JSONStringify(promise-&gt;globalObject(), jwk, 0);</span>
                      CString jwkUtf8String = jwkString.utf8(StrictConversion);
                      bytes.append(jwkUtf8String.data(), jwkUtf8String.length());
                  }
                  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1060,11 ***</span>
  
      // The following operation should be performed synchronously.
      exportAlgorithm-&gt;exportKey(format, key, WTFMove(callback), WTFMove(exceptionCallback));
  }
  
<span class="line-modified">! void SubtleCrypto::unwrapKey(JSC::ExecState&amp; state, KeyFormat format, BufferSource&amp;&amp; wrappedKeyBufferSource, CryptoKey&amp; unwrappingKey, AlgorithmIdentifier&amp;&amp; unwrapAlgorithmIdentifier, AlgorithmIdentifier&amp;&amp; unwrappedKeyAlgorithmIdentifier, bool extractable, Vector&lt;CryptoKeyUsage&gt;&amp;&amp; keyUsages, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto wrappedKey = copyToVector(WTFMove(wrappedKeyBufferSource));
  
      bool isDecryption = false;
  
<span class="line-new-header">--- 1060,11 ---</span>
  
      // The following operation should be performed synchronously.
      exportAlgorithm-&gt;exportKey(format, key, WTFMove(callback), WTFMove(exceptionCallback));
  }
  
<span class="line-modified">! void SubtleCrypto::unwrapKey(JSC::JSGlobalObject&amp; state, KeyFormat format, BufferSource&amp;&amp; wrappedKeyBufferSource, CryptoKey&amp; unwrappingKey, AlgorithmIdentifier&amp;&amp; unwrapAlgorithmIdentifier, AlgorithmIdentifier&amp;&amp; unwrappedKeyAlgorithmIdentifier, bool extractable, Vector&lt;CryptoKeyUsage&gt;&amp;&amp; keyUsages, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)</span>
  {
      auto wrappedKey = copyToVector(WTFMove(wrappedKeyBufferSource));
  
      bool isDecryption = false;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1125,11 ***</span>
                  case SubtleCrypto::KeyFormat::Pkcs8:
                  case SubtleCrypto::KeyFormat::Raw:
                      keyData = bytes;
                      break;
                  case SubtleCrypto::KeyFormat::Jwk: {
<span class="line-modified">!                     auto&amp; state = *(promise-&gt;globalObject()-&gt;globalExec());</span>
                      auto&amp; vm = state.vm();
                      auto scope = DECLARE_THROW_SCOPE(vm);
  
                      String jwkString(reinterpret_cast_ptr&lt;const char*&gt;(bytes.data()), bytes.size());
                      JSLockHolder locker(vm);
<span class="line-new-header">--- 1125,11 ---</span>
                  case SubtleCrypto::KeyFormat::Pkcs8:
                  case SubtleCrypto::KeyFormat::Raw:
                      keyData = bytes;
                      break;
                  case SubtleCrypto::KeyFormat::Jwk: {
<span class="line-modified">!                     auto&amp; state = *(promise-&gt;globalObject());</span>
                      auto&amp; vm = state.vm();
                      auto scope = DECLARE_THROW_SCOPE(vm);
  
                      String jwkString(reinterpret_cast_ptr&lt;const char*&gt;(bytes.data()), bytes.size());
                      JSLockHolder locker(vm);
</pre>
<center><a href="CryptoAlgorithm.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SubtleCrypto.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
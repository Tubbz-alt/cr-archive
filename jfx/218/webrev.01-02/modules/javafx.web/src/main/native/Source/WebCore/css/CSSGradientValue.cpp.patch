diff a/modules/javafx.web/src/main/native/Source/WebCore/css/CSSGradientValue.cpp b/modules/javafx.web/src/main/native/Source/WebCore/css/CSSGradientValue.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/css/CSSGradientValue.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/css/CSSGradientValue.cpp
@@ -34,11 +34,11 @@
 #include "GradientImage.h"
 #include "NodeRenderStyle.h"
 #include "Pair.h"
 #include "RenderElement.h"
 #include "RenderView.h"
-#include "StyleResolver.h"
+#include "StyleBuilderState.h"
 #include <wtf/text/StringBuilder.h>
 
 namespace WebCore {
 
 static inline Ref<Gradient> createGradient(CSSGradientValue& value, RenderElement& renderer, FloatSize size)
@@ -68,12 +68,12 @@
 }
 
 // Should only ever be called for deprecated gradients.
 static inline bool compareStops(const CSSGradientColorStop& a, const CSSGradientColorStop& b)
 {
-    double aVal = a.m_position->doubleValue(CSSPrimitiveValue::CSS_NUMBER);
-    double bVal = b.m_position->doubleValue(CSSPrimitiveValue::CSS_NUMBER);
+    double aVal = a.m_position->doubleValue(CSSUnitType::CSS_NUMBER);
+    double bVal = b.m_position->doubleValue(CSSUnitType::CSS_NUMBER);
 
     return aVal < bVal;
 }
 
 void CSSGradientValue::sortStopsIfNeeded()
@@ -101,28 +101,53 @@
         return downcast<CSSRadialGradientValue>(value).clone();
     ASSERT(is<CSSConicGradientValue>(value));
     return downcast<CSSConicGradientValue>(value).clone();
 }
 
-Ref<CSSGradientValue> CSSGradientValue::gradientWithStylesResolved(const StyleResolver& styleResolver)
+template<typename Function>
+void resolveStopColors(Vector<CSSGradientColorStop, 2>& stops, Function&& colorResolveFunction)
+{
+    for (size_t i = 0; i < stops.size(); ++i) {
+        auto& stop = stops[i];
+        if (stop.isMidpoint)
+            continue;
+        if (stop.m_color)
+            stop.m_resolvedColor = colorResolveFunction(*stop.m_color);
+        else if (i) {
+            auto& previousStop = stops[i - 1];
+            ASSERT(previousStop.m_color);
+            stop.m_color = previousStop.m_color;
+            stop.m_resolvedColor = previousStop.m_resolvedColor;
+        }
+    }
+}
+
+Ref<CSSGradientValue> CSSGradientValue::gradientWithStylesResolved(Style::BuilderState& builderState)
 {
     bool colorIsDerivedFromElement = false;
     for (auto& stop : m_stops) {
-        if (!stop.isMidpoint && styleResolver.colorFromPrimitiveValueIsDerivedFromElement(*stop.m_color)) {
+        if (!stop.isMidpoint && stop.m_color && Style::BuilderState::isColorFromPrimitiveValueDerivedFromElement(*stop.m_color)) {
             stop.m_colorIsDerivedFromElement = true;
             colorIsDerivedFromElement = true;
             break;
         }
     }
     auto result = colorIsDerivedFromElement ? clone(*this) : makeRef(*this);
-    for (auto& stop : result->m_stops) {
-        if (!stop.isMidpoint)
-            stop.m_resolvedColor = styleResolver.colorFromPrimitiveValue(*stop.m_color);
-    }
+    resolveStopColors(result->m_stops, [&](const CSSPrimitiveValue& colorValue) {
+        return builderState.colorFromPrimitiveValue(colorValue);
+    });
     return result;
 }
 
+void CSSGradientValue::resolveRGBColors()
+{
+    resolveStopColors(m_stops, [&](const CSSPrimitiveValue& colorValue) {
+        ASSERT(colorValue.isRGBColor());
+        return colorValue.color();
+    });
+}
+
 class LinearGradientAdapter {
 public:
     explicit LinearGradientAdapter(Gradient::LinearData& data)
         : m_data(data)
     {
@@ -307,13 +332,13 @@
         result.reserveInitialCapacity(m_stops.size());
 
         for (auto& stop : m_stops) {
             float offset;
             if (stop.m_position->isPercentage())
-                offset = stop.m_position->floatValue(CSSPrimitiveValue::CSS_PERCENTAGE) / 100;
+                offset = stop.m_position->floatValue(CSSUnitType::CSS_PERCENTAGE) / 100;
             else
-                offset = stop.m_position->floatValue(CSSPrimitiveValue::CSS_NUMBER);
+                offset = stop.m_position->floatValue(CSSUnitType::CSS_NUMBER);
 
             Color color = stop.m_resolvedColor;
             if (style.hasAppleColorFilter())
                 style.appleColorFilter().transformColor(color);
             result.uncheckedAppend({ offset, color });
@@ -339,22 +364,22 @@
         stops[i].color = color;
 
         if (stop.m_position) {
             auto& positionValue = *stop.m_position;
             if (positionValue.isPercentage())
-                stops[i].offset = positionValue.floatValue(CSSPrimitiveValue::CSS_PERCENTAGE) / 100;
+                stops[i].offset = positionValue.floatValue(CSSUnitType::CSS_PERCENTAGE) / 100;
             else if (positionValue.isLength() || positionValue.isViewportPercentageLength() || positionValue.isCalculatedPercentageWithLength()) {
                 float length;
                 if (positionValue.isLength())
                     length = positionValue.computeLength<float>(conversionData);
                 else {
                     Ref<CalculationValue> calculationValue { positionValue.cssCalcValue()->createCalculationValue(conversionData) };
                     length = calculationValue->evaluate(gradientLength);
                 }
                 stops[i].offset = (gradientLength > 0) ? length / gradientLength : 0;
             } else if (positionValue.isAngle())
-                stops[i].offset = positionValue.floatValue(CSSPrimitiveValue::CSS_DEG) / 360;
+                stops[i].offset = positionValue.floatValue(CSSUnitType::CSS_DEG) / 360;
             else {
                 ASSERT_NOT_REACHED();
                 stops[i].offset = 0;
             }
             stops[i].specified = true;
@@ -667,17 +692,29 @@
 }
 
 static void appendGradientStops(StringBuilder& builder, const Vector<CSSGradientColorStop, 2>& stops)
 {
     for (auto& stop : stops) {
-        double position = stop.m_position->doubleValue(CSSPrimitiveValue::CSS_NUMBER);
+        double position = stop.m_position->doubleValue(CSSUnitType::CSS_NUMBER);
         if (!position)
             builder.append(", from(", stop.m_color->cssText(), ')');
         else if (position == 1)
             builder.append(", to(", stop.m_color->cssText(), ')');
         else
-            builder.append(", color-stop(", FormattedNumber::fixedPrecision(position), ", ", stop.m_color->cssText(), ')');
+            builder.append(", color-stop(", position, ", ", stop.m_color->cssText(), ')');
+    }
+}
+
+void CSSGradientValue::writeColorStop(StringBuilder& builder, const CSSGradientColorStop& stop) const
+{
+    if (!stop.isMidpoint && stop.m_color)
+        builder.append(stop.m_color->cssText());
+
+    if (stop.m_position) {
+        if (!stop.isMidpoint)
+            builder.append(' ');
+        builder.append(stop.m_position->cssText());
     }
 }
 
 String CSSLinearGradientValue::customCSSText() const
 {
@@ -701,13 +738,12 @@
             else if (m_firstY)
                 result.append(m_firstY->cssText());
         }
 
         for (auto& stop : m_stops) {
-            result.append(", ", stop.m_color->cssText());
-            if (stop.m_position)
-                result.append(' ', stop.m_position->cssText());
+            result.appendLiteral(", ");
+            writeColorStop(result, stop);
         }
     } else {
         if (m_repeating)
             result.appendLiteral("repeating-linear-gradient(");
         else
@@ -735,17 +771,11 @@
         bool wroteFirstStop = false;
         for (auto& stop : m_stops) {
             if (wroteFirstStop)
                 result.appendLiteral(", ");
             wroteFirstStop = true;
-            if (!stop.isMidpoint)
-                result.append(stop.m_color->cssText());
-            if (stop.m_position) {
-                if (!stop.isMidpoint)
-                    result.append(' ');
-                result.append(stop.m_position->cssText());
-            }
+            writeColorStop(result, stop);
         }
     }
 
     result.append(')');
     return result.toString();
@@ -826,11 +856,11 @@
     CSSToLengthConversionData conversionData(&renderer.style(), renderer.document().documentElement()->renderStyle(), &renderer.view());
 
     FloatPoint firstPoint;
     FloatPoint secondPoint;
     if (m_angle) {
-        float angle = m_angle->floatValue(CSSPrimitiveValue::CSS_DEG);
+        float angle = m_angle->floatValue(CSSUnitType::CSS_DEG);
         endPointsFromAngle(angle, size, firstPoint, secondPoint, m_gradientType);
     } else {
         switch (m_gradientType) {
         case CSSDeprecatedLinearGradient:
             firstPoint = computeEndPoint(m_firstX.get(), m_firstY.get(), conversionData, size);
@@ -893,10 +923,13 @@
             && compareCSSValuePtr(m_firstY, other.m_firstY)
             && compareCSSValuePtr(m_secondX, other.m_secondX)
             && compareCSSValuePtr(m_secondY, other.m_secondY)
             && m_stops == other.m_stops;
 
+    if (m_gradientType != other.m_gradientType)
+        return false;
+
     if (m_repeating != other.m_repeating)
         return false;
 
     if (m_angle)
         return compareCSSValuePtr(m_angle, other.m_angle) && m_stops == other.m_stops;
@@ -952,13 +985,12 @@
                 result.appendLiteral("cover");
         } else if (m_endHorizontalSize && m_endVerticalSize)
             result.append(", ", m_endHorizontalSize->cssText(), ' ', m_endVerticalSize->cssText());
 
         for (auto& stop : m_stops) {
-            result.append(", ", stop.m_color->cssText());
-            if (stop.m_position)
-                result.append(' ', stop.m_position->cssText());
+            result.appendLiteral(", ");
+            writeColorStop(result, stop);
         }
     } else {
         if (m_repeating)
             result.appendLiteral("repeating-radial-gradient(");
         else
@@ -1001,23 +1033,17 @@
         }
 
         if (wroteSomething)
             result.appendLiteral(", ");
 
-        for (unsigned i = 0; i < m_stops.size(); i++) {
-            const CSSGradientColorStop& stop = m_stops[i];
-            if (i)
+        bool wroteFirstStop = false;
+        for (auto& stop : m_stops) {
+            if (wroteFirstStop)
                 result.appendLiteral(", ");
-            if (!stop.isMidpoint)
-                result.append(stop.m_color->cssText());
-            if (stop.m_position) {
-                if (!stop.isMidpoint)
-                    result.append(' ');
-                result.append(stop.m_position->cssText());
-            }
+            wroteFirstStop = true;
+            writeColorStop(result, stop);
         }
-
     }
 
     result.append(')');
     return result.toString();
 }
@@ -1105,11 +1131,11 @@
 static inline float horizontalEllipseRadius(const FloatSize& p, float aspectRatio)
 {
     // x^2/a^2 + y^2/b^2 = 1
     // a/b = aspectRatio, b = a/aspectRatio
     // a = sqrt(x^2 + y^2/(1/r^2))
-    return sqrtf(p.width() * p.width() + (p.height() * p.height()) / (1 / (aspectRatio * aspectRatio)));
+    return std::hypot(p.width(), p.height() * aspectRatio);
 }
 
 // FIXME: share code with the linear version
 Ref<Gradient> CSSRadialGradientValue::createGradient(RenderElement& renderer, const FloatSize& size)
 {
@@ -1264,10 +1290,13 @@
             && compareCSSValuePtr(m_secondY, other.m_secondY)
             && compareCSSValuePtr(m_firstRadius, other.m_firstRadius)
             && compareCSSValuePtr(m_secondRadius, other.m_secondRadius)
             && m_stops == other.m_stops;
 
+    if (m_gradientType != other.m_gradientType)
+        return false;
+
     if (m_repeating != other.m_repeating)
         return false;
 
     bool equalXandY = false;
     if (m_firstX && m_firstY)
@@ -1330,17 +1359,11 @@
     bool wroteFirstStop = false;
     for (auto& stop : m_stops) {
         if (wroteFirstStop)
             result.appendLiteral(", ");
         wroteFirstStop = true;
-        if (!stop.isMidpoint)
-            result.append(stop.m_color->cssText());
-        if (stop.m_position) {
-            if (!stop.isMidpoint)
-                result.append(' ');
-            result.append(stop.m_position->cssText());
-        }
+        writeColorStop(result, stop);
     }
 
     result.append(')');
     return result.toString();
 }
@@ -1357,11 +1380,11 @@
     if (!m_firstY)
         centerPoint.setY(size.height() / 2);
 
     float angleRadians = 0;
     if (m_angle)
-        angleRadians = m_angle->floatValue(CSSPrimitiveValue::CSS_RAD);
+        angleRadians = m_angle->floatValue(CSSUnitType::CSS_RAD);
 
     Gradient::ConicData data { centerPoint, angleRadians };
     ConicGradientAdapter adapter;
     auto stops = computeStops(adapter, conversionData, renderer.style(), 1);
 

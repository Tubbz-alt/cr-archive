<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/JSDollarVM.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HeapVerifier.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSDollarVM.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/JSDollarVM.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 28,29 ***</span>
<span class="line-new-header">--- 28,34 ---</span>
  
  #include &quot;BuiltinExecutableCreator.h&quot;
  #include &quot;CodeBlock.h&quot;
  #include &quot;DOMAttributeGetterSetter.h&quot;
  #include &quot;DOMJITGetterSetter.h&quot;
<span class="line-added">+ #include &quot;Debugger.h&quot;</span>
<span class="line-added">+ #include &quot;Error.h&quot;</span>
  #include &quot;FrameTracers.h&quot;
  #include &quot;FunctionCodeBlock.h&quot;
  #include &quot;GetterSetter.h&quot;
  #include &quot;JSArray.h&quot;
  #include &quot;JSArrayBuffer.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSFunction.h&quot;
  #include &quot;JSONObject.h&quot;
  #include &quot;JSProxy.h&quot;
  #include &quot;JSString.h&quot;
<span class="line-added">+ #include &quot;Options.h&quot;</span>
  #include &quot;Parser.h&quot;
<span class="line-added">+ #include &quot;ProbeContext.h&quot;</span>
  #include &quot;ShadowChicken.h&quot;
  #include &quot;Snippet.h&quot;
  #include &quot;SnippetParams.h&quot;
  #include &quot;TypeProfiler.h&quot;
  #include &quot;TypeProfilerLog.h&quot;
  #include &quot;VMInspector.h&quot;
  #include &quot;WasmCapabilities.h&quot;
  #include &lt;wtf/Atomics.h&gt;
<span class="line-added">+ #include &lt;wtf/CPUTime.h&gt;</span>
  #include &lt;wtf/DataLog.h&gt;
  #include &lt;wtf/ProcessID.h&gt;
  #include &lt;wtf/StringPrintStream.h&gt;
  
  #if ENABLE(WEBASSEMBLY)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 58,45 ***</span>
  #include &quot;WasmStreamingParser.h&quot;
  #endif
  
  using namespace JSC;
  
  namespace {
  
<span class="line-modified">! class JSDollarVMCallFrame : public JSDestructibleObject {</span>
<span class="line-modified">!     using Base = JSDestructibleObject;</span>
  public:
      JSDollarVMCallFrame(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
<span class="line-modified">!     { }</span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
          return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
      }
  
<span class="line-modified">!     static JSDollarVMCallFrame* create(ExecState* exec, unsigned requestedFrameIndex)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!         JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
          Structure* structure = createStructure(vm, globalObject, jsNull());
          JSDollarVMCallFrame* frame = new (NotNull, allocateCell&lt;JSDollarVMCallFrame&gt;(vm.heap)) JSDollarVMCallFrame(vm, structure);
<span class="line-modified">!         frame-&gt;finishCreation(vm, exec, requestedFrameIndex);</span>
          return frame;
      }
  
<span class="line-modified">!     void finishCreation(VM&amp; vm, CallFrame* frame, unsigned requestedFrameIndex)</span>
      {
          Base::finishCreation(vm);
  
          auto addProperty = [&amp;] (VM&amp; vm, const char* name, JSValue value) {
              JSDollarVMCallFrame::addProperty(vm, name, value);
          };
  
          unsigned frameIndex = 0;
          bool isValid = false;
<span class="line-modified">!         frame-&gt;iterate([&amp;] (StackVisitor&amp; visitor) {</span>
  
              if (frameIndex++ != requestedFrameIndex)
                  return StackVisitor::Continue;
  
              addProperty(vm, &quot;name&quot;, jsString(vm, visitor-&gt;functionName()));
<span class="line-new-header">--- 63,91 ---</span>
  #include &quot;WasmStreamingParser.h&quot;
  #endif
  
  using namespace JSC;
  
<span class="line-added">+ IGNORE_WARNINGS_BEGIN(&quot;frame-address&quot;)</span>
<span class="line-added">+ </span>
<span class="line-added">+ extern &quot;C&quot; void ctiMasmProbeTrampoline();</span>
<span class="line-added">+ </span>
<span class="line-added">+ namespace JSC {</span>
<span class="line-added">+ </span>
<span class="line-added">+ // This class is only here as a simple way to grant JSDollarVM friend privileges</span>
<span class="line-added">+ // to all the classes that it needs special access to.</span>
<span class="line-added">+ class JSDollarVMHelper {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     JSDollarVMHelper(VM&amp; vm)</span>
<span class="line-added">+         : m_vm(vm)</span>
<span class="line-added">+     { }</span>
<span class="line-added">+ </span>
<span class="line-added">+     void updateVMStackLimits() { return m_vm.updateStackLimits(); };</span>
<span class="line-added">+ </span>
<span class="line-added">+     static EncodedJSValue JSC_HOST_CALL functionGetStructureTransitionList(JSGlobalObject*, CallFrame*);</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
<span class="line-added">+     VM&amp; m_vm;</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ } // namespace JSC</span>
<span class="line-added">+ </span>
  namespace {
  
<span class="line-modified">! // We must RELEASE_ASSERT(Options::useDollarVM()) in all JSDollarVM functions</span>
<span class="line-modified">! // that are non-trivial at an eye&#39;s glance. This includes (but is not limited to):</span>
<span class="line-added">+ //      constructors</span>
<span class="line-added">+ //      create() factory</span>
<span class="line-added">+ //      createStructure() factory</span>
<span class="line-added">+ //      finishCreation()</span>
<span class="line-added">+ //      HOST_CALL or operation functions</span>
<span class="line-added">+ //      Constructors and methods of utility and test classes</span>
<span class="line-added">+ //      lambda functions</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // The way to do this RELEASE_ASSERT is with the DollarVMAssertScope below.</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // The only exception are some constexpr constructors used for instantiating</span>
<span class="line-added">+ // globals (since these must have trivial constructors) e.g. DOMJITAttribute.</span>
<span class="line-added">+ // Instead, these constructors should always be ALWAYS_INLINE.</span>
<span class="line-added">+ </span>
<span class="line-added">+ class JSDollarVMCallFrame : public JSNonFinalObject {</span>
<span class="line-added">+     using Base = JSNonFinalObject;</span>
  public:
      JSDollarVMCallFrame(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
<span class="line-modified">!     {</span>
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
<span class="line-added">+     }</span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
      }
  
<span class="line-modified">!     static JSDollarVMCallFrame* create(JSGlobalObject* globalObject, CallFrame* callFrame, unsigned requestedFrameIndex)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-modified">!         VM&amp; vm = globalObject-&gt;vm();</span>
          Structure* structure = createStructure(vm, globalObject, jsNull());
          JSDollarVMCallFrame* frame = new (NotNull, allocateCell&lt;JSDollarVMCallFrame&gt;(vm.heap)) JSDollarVMCallFrame(vm, structure);
<span class="line-modified">!         frame-&gt;finishCreation(vm, callFrame, requestedFrameIndex);</span>
          return frame;
      }
  
<span class="line-modified">!     void finishCreation(VM&amp; vm, CallFrame* callFrame, unsigned requestedFrameIndex)</span>
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          Base::finishCreation(vm);
  
          auto addProperty = [&amp;] (VM&amp; vm, const char* name, JSValue value) {
<span class="line-added">+             DollarVMAssertScope assertScope;</span>
              JSDollarVMCallFrame::addProperty(vm, name, value);
          };
  
          unsigned frameIndex = 0;
          bool isValid = false;
<span class="line-modified">!         callFrame-&gt;iterate(vm, [&amp;] (StackVisitor&amp; visitor) {</span>
<span class="line-added">+             DollarVMAssertScope assertScope;</span>
  
              if (frameIndex++ != requestedFrameIndex)
                  return StackVisitor::Continue;
  
              addProperty(vm, &quot;name&quot;, jsString(vm, visitor-&gt;functionName()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 121,10 ***</span>
<span class="line-new-header">--- 172,11 ---</span>
      DECLARE_INFO;
  
  private:
      void addProperty(VM&amp; vm, const char* name, JSValue value)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          Identifier identifier = Identifier::fromString(vm, name);
          putDirect(vm, identifier, value);
      }
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 136,39 ***</span>
<span class="line-new-header">--- 188,43 ---</span>
  class Element : public JSNonFinalObject {
  public:
      Element(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
      }
  
      typedef JSNonFinalObject Base;
  
      Root* root() const { return m_root.get(); }
      void setRoot(VM&amp; vm, Root* root) { m_root.set(vm, this, root); }
  
      static Element* create(VM&amp; vm, JSGlobalObject* globalObject, Root* root)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          Structure* structure = createStructure(vm, globalObject, jsNull());
          Element* element = new (NotNull, allocateCell&lt;Element&gt;(vm.heap)) Element(vm, structure);
          element-&gt;finishCreation(vm, root);
          return element;
      }
  
      void finishCreation(VM&amp;, Root*);
  
      static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          Element* thisObject = jsCast&lt;Element*&gt;(cell);
          ASSERT_GC_OBJECT_INHERITS(thisObject, info());
          Base::visitChildren(thisObject, visitor);
          visitor.append(thisObject-&gt;m_root);
      }
  
      static ElementHandleOwner* handleOwner();
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
      }
  
      DECLARE_INFO;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 177,12 ***</span>
  };
  
  class ElementHandleOwner : public WeakHandleOwner {
      WTF_MAKE_FAST_ALLOCATED;
  public:
<span class="line-modified">!     bool isReachableFromOpaqueRoots(Handle&lt;JSC::Unknown&gt; handle, void*, SlotVisitor&amp; visitor, const char** reason) override</span>
      {
          if (UNLIKELY(reason))
              *reason = &quot;JSC::Element is opaque root&quot;;
          Element* element = jsCast&lt;Element*&gt;(handle.slot()-&gt;asCell());
          return visitor.containsOpaqueRoot(element-&gt;root());
      }
<span class="line-new-header">--- 233,13 ---</span>
  };
  
  class ElementHandleOwner : public WeakHandleOwner {
      WTF_MAKE_FAST_ALLOCATED;
  public:
<span class="line-modified">!     bool isReachableFromOpaqueRoots(JSC::Handle&lt;JSC::Unknown&gt; handle, void*, SlotVisitor&amp; visitor, const char** reason) override</span>
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          if (UNLIKELY(reason))
              *reason = &quot;JSC::Element is opaque root&quot;;
          Element* element = jsCast&lt;Element*&gt;(handle.slot()-&gt;asCell());
          return visitor.containsOpaqueRoot(element-&gt;root());
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,25 ***</span>
<span class="line-new-header">--- 248,28 ---</span>
  class Root : public JSDestructibleObject {
  public:
      Root(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
      }
  
      Element* element()
      {
          return m_element.get();
      }
  
      void setElement(Element* element)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          Weak&lt;Element&gt; newElement(element, Element::handleOwner());
          m_element.swap(newElement);
      }
  
      static Root* create(VM&amp; vm, JSGlobalObject* globalObject)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          Structure* structure = createStructure(vm, globalObject, jsNull());
          Root* root = new (NotNull, allocateCell&lt;Root&gt;(vm.heap)) Root(vm, structure);
          root-&gt;finishCreation(vm);
          return root;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 218,15 ***</span>
<span class="line-new-header">--- 278,17 ---</span>
  
      DECLARE_INFO;
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
      }
  
      static void visitChildren(JSCell* thisObject, SlotVisitor&amp; visitor)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          ASSERT_GC_OBJECT_INHERITS(thisObject, info());
          Base::visitChildren(thisObject, visitor);
          visitor.addOpaqueRoot(thisObject);
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 237,33 ***</span>
  class SimpleObject : public JSNonFinalObject {
  public:
      SimpleObject(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
      }
  
      typedef JSNonFinalObject Base;
<span class="line-modified">!     static const bool needsDestruction = false;</span>
  
      static SimpleObject* create(VM&amp; vm, JSGlobalObject* globalObject)
      {
          Structure* structure = createStructure(vm, globalObject, jsNull());
          SimpleObject* simpleObject = new (NotNull, allocateCell&lt;SimpleObject&gt;(vm.heap)) SimpleObject(vm, structure);
          simpleObject-&gt;finishCreation(vm);
          return simpleObject;
      }
  
      static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
      {
          SimpleObject* thisObject = jsCast&lt;SimpleObject*&gt;(cell);
          ASSERT_GC_OBJECT_INHERITS(thisObject, info());
          Base::visitChildren(thisObject, visitor);
          visitor.append(thisObject-&gt;m_hiddenValue);
      }
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
          return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
      }
  
      JSValue hiddenValue()
      {
<span class="line-new-header">--- 299,37 ---</span>
  class SimpleObject : public JSNonFinalObject {
  public:
      SimpleObject(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
      }
  
      typedef JSNonFinalObject Base;
<span class="line-modified">!     static constexpr bool needsDestruction = false;</span>
  
      static SimpleObject* create(VM&amp; vm, JSGlobalObject* globalObject)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          Structure* structure = createStructure(vm, globalObject, jsNull());
          SimpleObject* simpleObject = new (NotNull, allocateCell&lt;SimpleObject&gt;(vm.heap)) SimpleObject(vm, structure);
          simpleObject-&gt;finishCreation(vm);
          return simpleObject;
      }
  
      static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          SimpleObject* thisObject = jsCast&lt;SimpleObject*&gt;(cell);
          ASSERT_GC_OBJECT_INHERITS(thisObject, info());
          Base::visitChildren(thisObject, visitor);
          visitor.append(thisObject-&gt;m_hiddenValue);
      }
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
      }
  
      JSValue hiddenValue()
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 285,52 ***</span>
  class ImpureGetter : public JSNonFinalObject {
  public:
      ImpureGetter(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
      }
  
      DECLARE_INFO;
      typedef JSNonFinalObject Base;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags | JSC::GetOwnPropertySlotIsImpure | JSC::OverridesGetOwnPropertySlot;</span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
          return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
      }
  
      static ImpureGetter* create(VM&amp; vm, Structure* structure, JSObject* delegate)
      {
          ImpureGetter* getter = new (NotNull, allocateCell&lt;ImpureGetter&gt;(vm.heap)) ImpureGetter(vm, structure);
          getter-&gt;finishCreation(vm, delegate);
          return getter;
      }
  
      void finishCreation(VM&amp; vm, JSObject* delegate)
      {
          Base::finishCreation(vm);
          if (delegate)
              m_delegate.set(vm, this, delegate);
      }
  
<span class="line-modified">!     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName name, PropertySlot&amp; slot)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
          ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(object);
  
          if (thisObject-&gt;m_delegate) {
<span class="line-modified">!             if (thisObject-&gt;m_delegate-&gt;getPropertySlot(exec, name, slot))</span>
                  return true;
              RETURN_IF_EXCEPTION(scope, false);
          }
  
<span class="line-modified">!         return Base::getOwnPropertySlot(object, exec, name, slot);</span>
      }
  
      static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
      {
          ASSERT_GC_OBJECT_INHERITS(cell, info());
          Base::visitChildren(cell, visitor);
          ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(cell);
          visitor.append(thisObject-&gt;m_delegate);
      }
<span class="line-new-header">--- 351,58 ---</span>
  class ImpureGetter : public JSNonFinalObject {
  public:
      ImpureGetter(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
      }
  
      DECLARE_INFO;
      typedef JSNonFinalObject Base;
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags | JSC::GetOwnPropertySlotIsImpure | JSC::OverridesGetOwnPropertySlot;</span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
      }
  
      static ImpureGetter* create(VM&amp; vm, Structure* structure, JSObject* delegate)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          ImpureGetter* getter = new (NotNull, allocateCell&lt;ImpureGetter&gt;(vm.heap)) ImpureGetter(vm, structure);
          getter-&gt;finishCreation(vm, delegate);
          return getter;
      }
  
      void finishCreation(VM&amp; vm, JSObject* delegate)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          Base::finishCreation(vm);
          if (delegate)
              m_delegate.set(vm, this, delegate);
      }
  
<span class="line-modified">!     static bool getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName name, PropertySlot&amp; slot)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         VM&amp; vm = globalObject-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
          ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(object);
  
          if (thisObject-&gt;m_delegate) {
<span class="line-modified">!             if (thisObject-&gt;m_delegate-&gt;getPropertySlot(globalObject, name, slot))</span>
                  return true;
              RETURN_IF_EXCEPTION(scope, false);
          }
  
<span class="line-modified">!         return Base::getOwnPropertySlot(object, globalObject, name, slot);</span>
      }
  
      static void visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          ASSERT_GC_OBJECT_INHERITS(cell, info());
          Base::visitChildren(cell, visitor);
          ImpureGetter* thisObject = jsCast&lt;ImpureGetter*&gt;(cell);
          visitor.append(thisObject-&gt;m_delegate);
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 347,31 ***</span>
  class CustomGetter : public JSNonFinalObject {
  public:
      CustomGetter(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
      }
  
      DECLARE_INFO;
      typedef JSNonFinalObject Base;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags | JSC::OverridesGetOwnPropertySlot;</span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
          return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
      }
  
      static CustomGetter* create(VM&amp; vm, Structure* structure)
      {
          CustomGetter* getter = new (NotNull, allocateCell&lt;CustomGetter&gt;(vm.heap)) CustomGetter(vm, structure);
          getter-&gt;finishCreation(vm);
          return getter;
      }
  
<span class="line-modified">!     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          CustomGetter* thisObject = jsCast&lt;CustomGetter*&gt;(object);
          if (propertyName == PropertyName(Identifier::fromString(vm, &quot;customGetter&quot;))) {
              slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;customGetter);
              return true;
          }
<span class="line-new-header">--- 419,35 ---</span>
  class CustomGetter : public JSNonFinalObject {
  public:
      CustomGetter(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
      }
  
      DECLARE_INFO;
      typedef JSNonFinalObject Base;
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags | JSC::OverridesGetOwnPropertySlot;</span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
      }
  
      static CustomGetter* create(VM&amp; vm, Structure* structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          CustomGetter* getter = new (NotNull, allocateCell&lt;CustomGetter&gt;(vm.heap)) CustomGetter(vm, structure);
          getter-&gt;finishCreation(vm);
          return getter;
      }
  
<span class="line-modified">!     static bool getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         VM&amp; vm = globalObject-&gt;vm();</span>
          CustomGetter* thisObject = jsCast&lt;CustomGetter*&gt;(object);
          if (propertyName == PropertyName(Identifier::fromString(vm, &quot;customGetter&quot;))) {
              slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;customGetter);
              return true;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 379,73 ***</span>
          if (propertyName == PropertyName(Identifier::fromString(vm, &quot;customGetterAccessor&quot;))) {
              slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::CustomAccessor, thisObject-&gt;customGetterAcessor);
              return true;
          }
  
<span class="line-modified">!         return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
      }
  
  private:
<span class="line-modified">!     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
          CustomGetter* thisObject = jsDynamicCast&lt;CustomGetter*&gt;(vm, JSValue::decode(thisValue));
          if (!thisObject)
<span class="line-modified">!             return throwVMTypeError(exec, scope);</span>
<span class="line-modified">!         bool shouldThrow = thisObject-&gt;get(exec, PropertyName(Identifier::fromString(vm, &quot;shouldThrow&quot;))).toBoolean(exec);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (shouldThrow)
<span class="line-modified">!             return throwVMTypeError(exec, scope);</span>
          return JSValue::encode(jsNumber(100));
      }
  
<span class="line-modified">!     static EncodedJSValue customGetterAcessor(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
          JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
          if (!thisObject)
<span class="line-modified">!             return throwVMTypeError(exec, scope);</span>
<span class="line-modified">!         bool shouldThrow = thisObject-&gt;get(exec, PropertyName(Identifier::fromString(vm, &quot;shouldThrow&quot;))).toBoolean(exec);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (shouldThrow)
<span class="line-modified">!             return throwVMTypeError(exec, scope);</span>
          return JSValue::encode(jsNumber(100));
      }
  };
  
  class RuntimeArray : public JSArray {
  public:
      typedef JSArray Base;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | OverridesGetPropertyNames;</span>
  
<span class="line-modified">!     static RuntimeArray* create(ExecState* exec)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!         JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
          Structure* structure = createStructure(vm, globalObject, createPrototype(vm, globalObject));
<span class="line-modified">!         RuntimeArray* runtimeArray = new (NotNull, allocateCell&lt;RuntimeArray&gt;(vm.heap)) RuntimeArray(exec, structure);</span>
<span class="line-modified">!         runtimeArray-&gt;finishCreation(exec);</span>
          vm.heap.addFinalizer(runtimeArray, destroy);
          return runtimeArray;
      }
  
      ~RuntimeArray() { }
  
      static void destroy(JSCell* cell)
      {
          static_cast&lt;RuntimeArray*&gt;(cell)-&gt;RuntimeArray::~RuntimeArray();
      }
  
<span class="line-modified">!     static const bool needsDestruction = false;</span>
  
<span class="line-modified">!     static bool getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          RuntimeArray* thisObject = jsCast&lt;RuntimeArray*&gt;(object);
          if (propertyName == vm.propertyNames-&gt;length) {
              slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;lengthGetter);
              return true;
          }
<span class="line-new-header">--- 455,77 ---</span>
          if (propertyName == PropertyName(Identifier::fromString(vm, &quot;customGetterAccessor&quot;))) {
              slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::CustomAccessor, thisObject-&gt;customGetterAcessor);
              return true;
          }
  
<span class="line-modified">!         return JSObject::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);</span>
      }
  
  private:
<span class="line-modified">!     static EncodedJSValue customGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         VM&amp; vm = globalObject-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
          CustomGetter* thisObject = jsDynamicCast&lt;CustomGetter*&gt;(vm, JSValue::decode(thisValue));
          if (!thisObject)
<span class="line-modified">!             return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified">!         bool shouldThrow = thisObject-&gt;get(globalObject, PropertyName(Identifier::fromString(vm, &quot;shouldThrow&quot;))).toBoolean(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (shouldThrow)
<span class="line-modified">!             return throwVMTypeError(globalObject, scope);</span>
          return JSValue::encode(jsNumber(100));
      }
  
<span class="line-modified">!     static EncodedJSValue customGetterAcessor(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         VM&amp; vm = globalObject-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
          JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
          if (!thisObject)
<span class="line-modified">!             return throwVMTypeError(globalObject, scope);</span>
<span class="line-modified">!         bool shouldThrow = thisObject-&gt;get(globalObject, PropertyName(Identifier::fromString(vm, &quot;shouldThrow&quot;))).toBoolean(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          if (shouldThrow)
<span class="line-modified">!             return throwVMTypeError(globalObject, scope);</span>
          return JSValue::encode(jsNumber(100));
      }
  };
  
  class RuntimeArray : public JSArray {
  public:
      typedef JSArray Base;
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | OverridesGetPropertyNames;</span>
  
<span class="line-modified">!     static RuntimeArray* create(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-modified">!         VM&amp; vm = globalObject-&gt;vm();</span>
          Structure* structure = createStructure(vm, globalObject, createPrototype(vm, globalObject));
<span class="line-modified">!         RuntimeArray* runtimeArray = new (NotNull, allocateCell&lt;RuntimeArray&gt;(vm.heap)) RuntimeArray(globalObject, structure);</span>
<span class="line-modified">!         runtimeArray-&gt;finishCreation(globalObject, callFrame);</span>
          vm.heap.addFinalizer(runtimeArray, destroy);
          return runtimeArray;
      }
  
      ~RuntimeArray() { }
  
      static void destroy(JSCell* cell)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          static_cast&lt;RuntimeArray*&gt;(cell)-&gt;RuntimeArray::~RuntimeArray();
      }
  
<span class="line-modified">!     static constexpr bool needsDestruction = false;</span>
  
<span class="line-modified">!     static bool getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         VM&amp; vm = globalObject-&gt;vm();</span>
          RuntimeArray* thisObject = jsCast&lt;RuntimeArray*&gt;(object);
          if (propertyName == vm.propertyNames-&gt;length) {
              slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;lengthGetter);
              return true;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 454,110 ***</span>
          if (index &amp;&amp; index.value() &lt; thisObject-&gt;getLength()) {
              slot.setValue(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum, jsNumber(thisObject-&gt;m_vector[index.value()]));
              return true;
          }
  
<span class="line-modified">!         return JSObject::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
      }
  
<span class="line-modified">!     static bool getOwnPropertySlotByIndex(JSObject* object, ExecState* exec, unsigned index, PropertySlot&amp; slot)</span>
      {
          RuntimeArray* thisObject = jsCast&lt;RuntimeArray*&gt;(object);
          if (index &lt; thisObject-&gt;getLength()) {
              slot.setValue(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum, jsNumber(thisObject-&gt;m_vector[index]));
              return true;
          }
  
<span class="line-modified">!         return JSObject::getOwnPropertySlotByIndex(thisObject, exec, index, slot);</span>
      }
  
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;)</span>
      {
          RELEASE_ASSERT_NOT_REACHED();
      }
  
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH bool deleteProperty(JSCell*, ExecState*, PropertyName)</span>
      {
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      unsigned getLength() const { return m_vector.size(); }
  
      DECLARE_INFO;
  
      static ArrayPrototype* createPrototype(VM&amp;, JSGlobalObject* globalObject)
      {
          return globalObject-&gt;arrayPrototype();
      }
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
          return Structure::create(vm, globalObject, prototype, TypeInfo(DerivedArrayType, StructureFlags), info(), ArrayClass);
      }
  
  protected:
<span class="line-modified">!     void finishCreation(ExecState* exec)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          Base::finishCreation(vm);
          ASSERT(inherits(vm, info()));
  
<span class="line-modified">!         for (size_t i = 0; i &lt; exec-&gt;argumentCount(); i++)</span>
<span class="line-modified">!             m_vector.append(exec-&gt;argument(i).toInt32(exec));</span>
      }
  
  private:
<span class="line-modified">!     RuntimeArray(ExecState* exec, Structure* structure)</span>
<span class="line-modified">!         : JSArray(exec-&gt;vm(), structure, 0)</span>
      {
      }
  
<span class="line-modified">!     static EncodedJSValue lengthGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
          RuntimeArray* thisObject = jsDynamicCast&lt;RuntimeArray*&gt;(vm, JSValue::decode(thisValue));
          if (!thisObject)
<span class="line-modified">!             return throwVMTypeError(exec, scope);</span>
          return JSValue::encode(jsNumber(thisObject-&gt;getLength()));
      }
  
      Vector&lt;int&gt; m_vector;
  };
  
  class DOMJITNode : public JSNonFinalObject {
  public:
      DOMJITNode(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
      }
  
      DECLARE_INFO;
      typedef JSNonFinalObject Base;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags;</span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
          return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
      }
  
  #if ENABLE(JIT)
      static Ref&lt;Snippet&gt; checkSubClassSnippet()
      {
          Ref&lt;Snippet&gt; snippet = Snippet::create();
<span class="line-modified">!         snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>
              CCallHelpers::JumpList failureCases;
              failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
              return failureCases;
          });
          return snippet;
      }
  #endif
  
      static DOMJITNode* create(VM&amp; vm, Structure* structure)
      {
          DOMJITNode* getter = new (NotNull, allocateCell&lt;DOMJITNode&gt;(vm.heap)) DOMJITNode(vm, structure);
          getter-&gt;finishCreation(vm);
          return getter;
      }
  
<span class="line-new-header">--- 534,230 ---</span>
          if (index &amp;&amp; index.value() &lt; thisObject-&gt;getLength()) {
              slot.setValue(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum, jsNumber(thisObject-&gt;m_vector[index.value()]));
              return true;
          }
  
<span class="line-modified">!         return JSObject::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);</span>
      }
  
<span class="line-modified">!     static bool getOwnPropertySlotByIndex(JSObject* object, JSGlobalObject* globalObject, unsigned index, PropertySlot&amp; slot)</span>
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          RuntimeArray* thisObject = jsCast&lt;RuntimeArray*&gt;(object);
          if (index &lt; thisObject-&gt;getLength()) {
              slot.setValue(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::DontEnum, jsNumber(thisObject-&gt;m_vector[index]));
              return true;
          }
  
<span class="line-modified">!         return JSObject::getOwnPropertySlotByIndex(thisObject, globalObject, index, slot);</span>
      }
  
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;)</span>
      {
          RELEASE_ASSERT_NOT_REACHED();
      }
  
<span class="line-modified">!     static NO_RETURN_DUE_TO_CRASH bool deleteProperty(JSCell*, JSGlobalObject*, PropertyName)</span>
      {
          RELEASE_ASSERT_NOT_REACHED();
      }
  
      unsigned getLength() const { return m_vector.size(); }
  
      DECLARE_INFO;
  
      static ArrayPrototype* createPrototype(VM&amp;, JSGlobalObject* globalObject)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          return globalObject-&gt;arrayPrototype();
      }
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          return Structure::create(vm, globalObject, prototype, TypeInfo(DerivedArrayType, StructureFlags), info(), ArrayClass);
      }
  
  protected:
<span class="line-modified">!     void finishCreation(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         VM&amp; vm = globalObject-&gt;vm();</span>
          Base::finishCreation(vm);
          ASSERT(inherits(vm, info()));
  
<span class="line-modified">!         for (size_t i = 0; i &lt; callFrame-&gt;argumentCount(); i++)</span>
<span class="line-modified">!             m_vector.append(callFrame-&gt;argument(i).toInt32(globalObject));</span>
      }
  
  private:
<span class="line-modified">!     RuntimeArray(JSGlobalObject* globalObject, Structure* structure)</span>
<span class="line-modified">!         : JSArray(globalObject-&gt;vm(), structure, 0)</span>
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
      }
  
<span class="line-modified">!     static EncodedJSValue lengthGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         VM&amp; vm = globalObject-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
          RuntimeArray* thisObject = jsDynamicCast&lt;RuntimeArray*&gt;(vm, JSValue::decode(thisValue));
          if (!thisObject)
<span class="line-modified">!             return throwVMTypeError(globalObject, scope);</span>
          return JSValue::encode(jsNumber(thisObject-&gt;getLength()));
      }
  
      Vector&lt;int&gt; m_vector;
  };
  
<span class="line-added">+ static const struct CompactHashIndex staticCustomAccessorTableIndex[2] = {</span>
<span class="line-added">+     { 0, -1 },</span>
<span class="line-added">+     { -1, -1 },</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ static EncodedJSValue testStaticAccessorGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));</span>
<span class="line-added">+     RELEASE_ASSERT(thisObject);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (JSValue result = thisObject-&gt;getDirect(vm, PropertyName(Identifier::fromString(vm, &quot;testField&quot;))))</span>
<span class="line-added">+         return JSValue::encode(result);</span>
<span class="line-added">+     return JSValue::encode(jsUndefined());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static bool testStaticAccessorPutter(JSGlobalObject* globalObject, EncodedJSValue thisValue, EncodedJSValue value)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));</span>
<span class="line-added">+     RELEASE_ASSERT(thisObject);</span>
<span class="line-added">+ </span>
<span class="line-added">+     return thisObject-&gt;putDirect(vm, PropertyName(Identifier::fromString(vm, &quot;testField&quot;)), JSValue::decode(value));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static const struct HashTableValue staticCustomAccessorTableValues[1] = {</span>
<span class="line-added">+     { &quot;testStaticAccessor&quot;, static_cast&lt;unsigned&gt;(PropertyAttribute::CustomAccessor), NoIntrinsic, { (intptr_t)static_cast&lt;PropertySlot::GetValueFunc&gt;(testStaticAccessorGetter), (intptr_t)static_cast&lt;PutPropertySlot::PutValueFunc&gt;(testStaticAccessorPutter) } },</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ static const struct HashTable staticCustomAccessorTable =</span>
<span class="line-added">+     { 1, 1, true, nullptr, staticCustomAccessorTableValues, staticCustomAccessorTableIndex };</span>
<span class="line-added">+ </span>
<span class="line-added">+ class StaticCustomAccessor : public JSNonFinalObject {</span>
<span class="line-added">+     using Base = JSNonFinalObject;</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     StaticCustomAccessor(VM&amp; vm, Structure* structure)</span>
<span class="line-added">+         : Base(vm, structure)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     DECLARE_INFO;</span>
<span class="line-added">+ </span>
<span class="line-added">+     static constexpr unsigned StructureFlags = Base::StructureFlags | HasStaticPropertyTable | OverridesGetOwnPropertySlot;</span>
<span class="line-added">+ </span>
<span class="line-added">+     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     static StaticCustomAccessor* create(VM&amp; vm, Structure* structure)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         StaticCustomAccessor* accessor = new (NotNull, allocateCell&lt;StaticCustomAccessor&gt;(vm.heap)) StaticCustomAccessor(vm, structure);</span>
<span class="line-added">+         accessor-&gt;finishCreation(vm);</span>
<span class="line-added">+         return accessor;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     static bool getOwnPropertySlot(JSObject* thisObject, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         if (String(propertyName.uid()) == &quot;thinAirCustomGetter&quot;) {</span>
<span class="line-added">+             slot.setCacheableCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum | PropertyAttribute::CustomAccessor, testStaticAccessorGetter);</span>
<span class="line-added">+             return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return JSNonFinalObject::getOwnPropertySlot(thisObject, globalObject, propertyName, slot);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ class ObjectDoingSideEffectPutWithoutCorrectSlotStatus : public JSNonFinalObject {</span>
<span class="line-added">+     using Base = JSNonFinalObject;</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     ObjectDoingSideEffectPutWithoutCorrectSlotStatus(VM&amp; vm, Structure* structure)</span>
<span class="line-added">+         : Base(vm, structure)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     DECLARE_INFO;</span>
<span class="line-added">+ </span>
<span class="line-added">+     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     static ObjectDoingSideEffectPutWithoutCorrectSlotStatus* create(VM&amp; vm, Structure* structure)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         ObjectDoingSideEffectPutWithoutCorrectSlotStatus* accessor = new (NotNull, allocateCell&lt;ObjectDoingSideEffectPutWithoutCorrectSlotStatus&gt;(vm.heap)) ObjectDoingSideEffectPutWithoutCorrectSlotStatus(vm, structure);</span>
<span class="line-added">+         accessor-&gt;finishCreation(vm);</span>
<span class="line-added">+         return accessor;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     static bool put(JSCell* cell, JSGlobalObject* globalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         auto* thisObject = jsCast&lt;ObjectDoingSideEffectPutWithoutCorrectSlotStatus*&gt;(cell);</span>
<span class="line-added">+         auto throwScope = DECLARE_THROW_SCOPE(globalObject-&gt;vm());</span>
<span class="line-added">+         auto* string = value.toString(globalObject);</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(throwScope, false);</span>
<span class="line-added">+         RELEASE_AND_RETURN(throwScope, Base::put(thisObject, globalObject, propertyName, string, slot));</span>
<span class="line-added">+     }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  class DOMJITNode : public JSNonFinalObject {
  public:
      DOMJITNode(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
      }
  
      DECLARE_INFO;
      typedef JSNonFinalObject Base;
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
      }
  
  #if ENABLE(JIT)
      static Ref&lt;Snippet&gt; checkSubClassSnippet()
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          Ref&lt;Snippet&gt; snippet = Snippet::create();
<span class="line-modified">!         snippet-&gt;setGenerator([=] (CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>
<span class="line-added">+             DollarVMAssertScope assertScope;</span>
              CCallHelpers::JumpList failureCases;
              failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
              return failureCases;
          });
          return snippet;
      }
  #endif
  
      static DOMJITNode* create(VM&amp; vm, Structure* structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          DOMJITNode* getter = new (NotNull, allocateCell&lt;DOMJITNode&gt;(vm.heap)) DOMJITNode(vm, structure);
          getter-&gt;finishCreation(vm);
          return getter;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 575,31 ***</span>
  class DOMJITGetter : public DOMJITNode {
  public:
      DOMJITGetter(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
      }
  
      DECLARE_INFO;
      typedef DOMJITNode Base;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags;</span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
          return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
      }
  
      static DOMJITGetter* create(VM&amp; vm, Structure* structure)
      {
          DOMJITGetter* getter = new (NotNull, allocateCell&lt;DOMJITGetter&gt;(vm.heap)) DOMJITGetter(vm, structure);
          getter-&gt;finishCreation(vm);
          return getter;
      }
  
      class DOMJITAttribute : public DOMJIT::GetterSetter {
      public:
<span class="line-modified">!         constexpr DOMJITAttribute()</span>
              : DOMJIT::GetterSetter(
                  DOMJITGetter::customGetter,
  #if ENABLE(JIT)
                  &amp;callDOMGetter,
  #else
<span class="line-new-header">--- 775,34 ---</span>
  class DOMJITGetter : public DOMJITNode {
  public:
      DOMJITGetter(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
      }
  
      DECLARE_INFO;
      typedef DOMJITNode Base;
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
      }
  
      static DOMJITGetter* create(VM&amp; vm, Structure* structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          DOMJITGetter* getter = new (NotNull, allocateCell&lt;DOMJITGetter&gt;(vm.heap)) DOMJITGetter(vm, structure);
          getter-&gt;finishCreation(vm);
          return getter;
      }
  
      class DOMJITAttribute : public DOMJIT::GetterSetter {
      public:
<span class="line-modified">!         ALWAYS_INLINE constexpr DOMJITAttribute()</span>
              : DOMJIT::GetterSetter(
                  DOMJITGetter::customGetter,
  #if ENABLE(JIT)
                  &amp;callDOMGetter,
  #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 608,25 ***</span>
                  SpecInt32Only)
          {
          }
  
  #if ENABLE(JIT)
<span class="line-modified">!         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)</span>
          {
<span class="line-modified">!             VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!             NativeCallFrameTracer tracer(vm, exec);</span>
              return JSValue::encode(jsNumber(static_cast&lt;DOMJITGetter*&gt;(pointer)-&gt;value()));
          }
  
          static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
          {
              Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
<span class="line-modified">!             snippet-&gt;requireGlobalObject = false;</span>
<span class="line-modified">!             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>
                  JSValueRegs results = params[0].jsValueRegs();
<span class="line-modified">!                 GPRReg dom = params[1].gpr();</span>
<span class="line-modified">!                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, dom);</span>
                  return CCallHelpers::JumpList();
  
              });
              return snippet;
          }
<span class="line-new-header">--- 811,30 ---</span>
                  SpecInt32Only)
          {
          }
  
  #if ENABLE(JIT)
<span class="line-modified">!         static EncodedJSValue JIT_OPERATION slowCall(JSGlobalObject* globalObject, void* pointer)</span>
          {
<span class="line-modified">!             DollarVMAssertScope assertScope;</span>
<span class="line-modified">!             VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+             CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+             JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
              return JSValue::encode(jsNumber(static_cast&lt;DOMJITGetter*&gt;(pointer)-&gt;value()));
          }
  
          static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
          {
<span class="line-added">+             DollarVMAssertScope assertScope;</span>
              Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
<span class="line-modified">!             snippet-&gt;requireGlobalObject = true;</span>
<span class="line-modified">!             snippet-&gt;setGenerator([=] (CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>
<span class="line-added">+                 DollarVMAssertScope assertScope;</span>
                  JSValueRegs results = params[0].jsValueRegs();
<span class="line-modified">!                 GPRReg domGPR = params[1].gpr();</span>
<span class="line-modified">!                 GPRReg globalObjectGPR = params[2].gpr();</span>
<span class="line-added">+                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, globalObjectGPR, domGPR);</span>
                  return CCallHelpers::JumpList();
  
              });
              return snippet;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 634,55 ***</span>
      };
  
  private:
      void finishCreation(VM&amp;);
  
<span class="line-modified">!     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, JSValue::decode(thisValue));
          ASSERT(thisObject);
          return JSValue::encode(jsNumber(thisObject-&gt;value()));
      }
  };
  
  static const DOMJITGetter::DOMJITAttribute DOMJITGetterDOMJIT;
  
  void DOMJITGetter::finishCreation(VM&amp; vm)
  {
      Base::finishCreation(vm);
      const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterDOMJIT;
      auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITNode::info(), domJIT });
      putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
  }
  
  class DOMJITGetterComplex : public DOMJITNode {
  public:
      DOMJITGetterComplex(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
      }
  
      DECLARE_INFO;
      typedef DOMJITNode Base;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags;</span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
          return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
      }
  
      static DOMJITGetterComplex* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
      {
          DOMJITGetterComplex* getter = new (NotNull, allocateCell&lt;DOMJITGetterComplex&gt;(vm.heap)) DOMJITGetterComplex(vm, structure);
          getter-&gt;finishCreation(vm, globalObject);
          return getter;
      }
  
      class DOMJITAttribute : public DOMJIT::GetterSetter {
      public:
<span class="line-modified">!         constexpr DOMJITAttribute()</span>
              : DOMJIT::GetterSetter(
                  DOMJITGetterComplex::customGetter,
  #if ENABLE(JIT)
                  &amp;callDOMGetter,
  #else
<span class="line-new-header">--- 842,61 ---</span>
      };
  
  private:
      void finishCreation(VM&amp;);
  
<span class="line-modified">!     static EncodedJSValue customGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         VM&amp; vm = globalObject-&gt;vm();</span>
          DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, JSValue::decode(thisValue));
          ASSERT(thisObject);
          return JSValue::encode(jsNumber(thisObject-&gt;value()));
      }
  };
  
  static const DOMJITGetter::DOMJITAttribute DOMJITGetterDOMJIT;
  
  void DOMJITGetter::finishCreation(VM&amp; vm)
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      Base::finishCreation(vm);
      const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterDOMJIT;
      auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITNode::info(), domJIT });
      putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
  }
  
<span class="line-added">+ </span>
  class DOMJITGetterComplex : public DOMJITNode {
  public:
      DOMJITGetterComplex(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
      }
  
      DECLARE_INFO;
      typedef DOMJITNode Base;
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
      }
  
      static DOMJITGetterComplex* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          DOMJITGetterComplex* getter = new (NotNull, allocateCell&lt;DOMJITGetterComplex&gt;(vm.heap)) DOMJITGetterComplex(vm, structure);
          getter-&gt;finishCreation(vm, globalObject);
          return getter;
      }
  
      class DOMJITAttribute : public DOMJIT::GetterSetter {
      public:
<span class="line-modified">!         ALWAYS_INLINE constexpr DOMJITAttribute()</span>
              : DOMJIT::GetterSetter(
                  DOMJITGetterComplex::customGetter,
  #if ENABLE(JIT)
                  &amp;callDOMGetter,
  #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 691,76 ***</span>
                  SpecInt32Only)
          {
          }
  
  #if ENABLE(JIT)
<span class="line-modified">!         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)</span>
          {
<span class="line-modified">!             VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!             NativeCallFrameTracer tracer(vm, exec);</span>
              auto scope = DECLARE_THROW_SCOPE(vm);
              auto* object = static_cast&lt;DOMJITNode*&gt;(pointer);
              auto* domjitGetterComplex = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, object);
              if (domjitGetterComplex) {
                  if (domjitGetterComplex-&gt;m_enableException)
<span class="line-modified">!                     return JSValue::encode(throwException(exec, scope, createError(exec, &quot;DOMJITGetterComplex slow call exception&quot;_s)));</span>
              }
              return JSValue::encode(jsNumber(object-&gt;value()));
          }
  
          static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
          {
              Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
              static_assert(GPRInfo::numberOfRegisters &gt;= 4, &quot;Number of registers should be larger or equal to 4.&quot;);
              unsigned numGPScratchRegisters = GPRInfo::numberOfRegisters - 4;
              snippet-&gt;numGPScratchRegisters = numGPScratchRegisters;
              snippet-&gt;numFPScratchRegisters = 3;
<span class="line-modified">!             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>
                  JSValueRegs results = params[0].jsValueRegs();
                  GPRReg domGPR = params[1].gpr();
                  for (unsigned i = 0; i &lt; numGPScratchRegisters; ++i)
                      jit.move(CCallHelpers::TrustedImm32(42), params.gpScratch(i));
  
<span class="line-modified">!                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, domGPR);</span>
                  return CCallHelpers::JumpList();
              });
              return snippet;
          }
  #endif
      };
  
  private:
      void finishCreation(VM&amp;, JSGlobalObject*);
  
<span class="line-modified">!     static EncodedJSValue JSC_HOST_CALL functionEnableException(ExecState* exec)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!         auto* object = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, exec-&gt;thisValue());</span>
          if (object)
              object-&gt;m_enableException = true;
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
          auto* thisObject = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, JSValue::decode(thisValue));
          ASSERT(thisObject);
          if (thisObject-&gt;m_enableException)
<span class="line-modified">!             return JSValue::encode(throwException(exec, scope, createError(exec, &quot;DOMJITGetterComplex slow call exception&quot;_s)));</span>
          return JSValue::encode(jsNumber(thisObject-&gt;value()));
      }
  
      bool m_enableException { false };
  };
  
  static const DOMJITGetterComplex::DOMJITAttribute DOMJITGetterComplexDOMJIT;
  
  void DOMJITGetterComplex::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
  {
      Base::finishCreation(vm);
      const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterComplexDOMJIT;
      auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITGetterComplex::info(), domJIT });
      putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
      putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;enableException&quot;), 0, functionEnableException, NoIntrinsic, 0);
<span class="line-new-header">--- 905,85 ---</span>
                  SpecInt32Only)
          {
          }
  
  #if ENABLE(JIT)
<span class="line-modified">!         static EncodedJSValue JIT_OPERATION slowCall(JSGlobalObject* globalObject, void* pointer)</span>
          {
<span class="line-modified">!             DollarVMAssertScope assertScope;</span>
<span class="line-modified">!             VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+             CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+             JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
              auto scope = DECLARE_THROW_SCOPE(vm);
              auto* object = static_cast&lt;DOMJITNode*&gt;(pointer);
              auto* domjitGetterComplex = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, object);
              if (domjitGetterComplex) {
                  if (domjitGetterComplex-&gt;m_enableException)
<span class="line-modified">!                     return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;DOMJITGetterComplex slow call exception&quot;_s)));</span>
              }
              return JSValue::encode(jsNumber(object-&gt;value()));
          }
  
          static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
          {
<span class="line-added">+             DollarVMAssertScope assertScope;</span>
              Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
              static_assert(GPRInfo::numberOfRegisters &gt;= 4, &quot;Number of registers should be larger or equal to 4.&quot;);
              unsigned numGPScratchRegisters = GPRInfo::numberOfRegisters - 4;
              snippet-&gt;numGPScratchRegisters = numGPScratchRegisters;
              snippet-&gt;numFPScratchRegisters = 3;
<span class="line-modified">!             snippet-&gt;requireGlobalObject = true;</span>
<span class="line-added">+             snippet-&gt;setGenerator([=] (CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>
<span class="line-added">+                 DollarVMAssertScope assertScope;</span>
                  JSValueRegs results = params[0].jsValueRegs();
                  GPRReg domGPR = params[1].gpr();
<span class="line-added">+                 GPRReg globalObjectGPR = params[2].gpr();</span>
                  for (unsigned i = 0; i &lt; numGPScratchRegisters; ++i)
                      jit.move(CCallHelpers::TrustedImm32(42), params.gpScratch(i));
  
<span class="line-modified">!                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, globalObjectGPR, domGPR);</span>
                  return CCallHelpers::JumpList();
              });
              return snippet;
          }
  #endif
      };
  
  private:
      void finishCreation(VM&amp;, JSGlobalObject*);
  
<span class="line-modified">!     static EncodedJSValue JSC_HOST_CALL functionEnableException(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-modified">!         VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+         auto* object = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, callFrame-&gt;thisValue());</span>
          if (object)
              object-&gt;m_enableException = true;
          return JSValue::encode(jsUndefined());
      }
  
<span class="line-modified">!     static EncodedJSValue customGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         VM&amp; vm = globalObject-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
          auto* thisObject = jsDynamicCast&lt;DOMJITGetterComplex*&gt;(vm, JSValue::decode(thisValue));
          ASSERT(thisObject);
          if (thisObject-&gt;m_enableException)
<span class="line-modified">!             return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;DOMJITGetterComplex slow call exception&quot;_s)));</span>
          return JSValue::encode(jsNumber(thisObject-&gt;value()));
      }
  
      bool m_enableException { false };
  };
  
  static const DOMJITGetterComplex::DOMJITAttribute DOMJITGetterComplexDOMJIT;
  
  void DOMJITGetterComplex::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      Base::finishCreation(vm);
      const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterComplexDOMJIT;
      auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { DOMJITGetterComplex::info(), domJIT });
      putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
      putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;enableException&quot;), 0, functionEnableException, NoIntrinsic, 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 769,53 ***</span>
  class DOMJITFunctionObject : public DOMJITNode {
  public:
      DOMJITFunctionObject(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
      }
  
      DECLARE_INFO;
      typedef DOMJITNode Base;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags;</span>
<span class="line-removed">- </span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
          return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
      }
  
      static DOMJITFunctionObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
      {
          DOMJITFunctionObject* object = new (NotNull, allocateCell&lt;DOMJITFunctionObject&gt;(vm.heap)) DOMJITFunctionObject(vm, structure);
          object-&gt;finishCreation(vm, globalObject);
          return object;
      }
  
<span class="line-modified">!     static EncodedJSValue JSC_HOST_CALL functionWithTypeCheck(ExecState* exec)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, exec-&gt;thisValue());</span>
          if (!thisObject)
<span class="line-modified">!             return throwVMTypeError(exec, scope);</span>
          return JSValue::encode(jsNumber(thisObject-&gt;value()));
      }
  
<span class="line-modified">!     static EncodedJSValue JIT_OPERATION functionWithoutTypeCheck(ExecState* exec, DOMJITNode* node)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!         NativeCallFrameTracer tracer(vm, exec);</span>
          return JSValue::encode(jsNumber(node-&gt;value()));
      }
  
  #if ENABLE(JIT)
      static Ref&lt;Snippet&gt; checkSubClassSnippet()
      {
          Ref&lt;Snippet&gt; snippet = Snippet::create();
          snippet-&gt;numFPScratchRegisters = 1;
<span class="line-modified">!         snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>
              static const double value = 42.0;
              CCallHelpers::JumpList failureCases;
              // May use scratch registers.
              jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;value), params.fpScratch(0));
              failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
<span class="line-new-header">--- 992,60 ---</span>
  class DOMJITFunctionObject : public DOMJITNode {
  public:
      DOMJITFunctionObject(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
      }
  
      DECLARE_INFO;
      typedef DOMJITNode Base;
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
      }
  
      static DOMJITFunctionObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          DOMJITFunctionObject* object = new (NotNull, allocateCell&lt;DOMJITFunctionObject&gt;(vm.heap)) DOMJITFunctionObject(vm, structure);
          object-&gt;finishCreation(vm, globalObject);
          return object;
      }
  
<span class="line-modified">!     static EncodedJSValue JSC_HOST_CALL functionWithTypeCheck(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         VM&amp; vm = globalObject-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!         DOMJITNode* thisObject = jsDynamicCast&lt;DOMJITNode*&gt;(vm, callFrame-&gt;thisValue());</span>
          if (!thisObject)
<span class="line-modified">!             return throwVMTypeError(globalObject, scope);</span>
          return JSValue::encode(jsNumber(thisObject-&gt;value()));
      }
  
<span class="line-modified">!     static EncodedJSValue JIT_OPERATION functionWithoutTypeCheck(JSGlobalObject* globalObject, DOMJITNode* node)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-modified">!         VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+         CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+         JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
          return JSValue::encode(jsNumber(node-&gt;value()));
      }
  
  #if ENABLE(JIT)
      static Ref&lt;Snippet&gt; checkSubClassSnippet()
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          Ref&lt;Snippet&gt; snippet = Snippet::create();
          snippet-&gt;numFPScratchRegisters = 1;
<span class="line-modified">!         snippet-&gt;setGenerator([=] (CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>
<span class="line-added">+             DollarVMAssertScope assertScope;</span>
              static const double value = 42.0;
              CCallHelpers::JumpList failureCases;
              // May use scratch registers.
              jit.loadDouble(CCallHelpers::TrustedImmPtr(&amp;value), params.fpScratch(0));
              failureCases.append(jit.branchIfNotType(params[0].gpr(), JSC::JSType(LastJSCObjectType + 1)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 831,53 ***</span>
  
  static const DOMJIT::Signature DOMJITFunctionObjectSignature(DOMJITFunctionObject::functionWithoutTypeCheck, DOMJITFunctionObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);
  
  void DOMJITFunctionObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
  {
      Base::finishCreation(vm);
      putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;func&quot;), 0, functionWithTypeCheck, NoIntrinsic, &amp;DOMJITFunctionObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
  }
  
  class DOMJITCheckSubClassObject : public DOMJITNode {
  public:
      DOMJITCheckSubClassObject(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
      }
  
      DECLARE_INFO;
      typedef DOMJITNode Base;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags;</span>
<span class="line-removed">- </span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
          return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
      }
  
      static DOMJITCheckSubClassObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
      {
          DOMJITCheckSubClassObject* object = new (NotNull, allocateCell&lt;DOMJITCheckSubClassObject&gt;(vm.heap)) DOMJITCheckSubClassObject(vm, structure);
          object-&gt;finishCreation(vm, globalObject);
          return object;
      }
  
<span class="line-modified">!     static EncodedJSValue JSC_HOST_CALL functionWithTypeCheck(ExecState* exec)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!         auto* thisObject = jsDynamicCast&lt;DOMJITCheckSubClassObject*&gt;(vm, exec-&gt;thisValue());</span>
          if (!thisObject)
<span class="line-modified">!             return throwVMTypeError(exec, scope);</span>
          return JSValue::encode(jsNumber(thisObject-&gt;value()));
      }
  
<span class="line-modified">!     static EncodedJSValue JIT_OPERATION functionWithoutTypeCheck(ExecState* exec, DOMJITNode* node)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!         NativeCallFrameTracer tracer(vm, exec);</span>
          return JSValue::encode(jsNumber(node-&gt;value()));
      }
  
  private:
      void finishCreation(VM&amp;, JSGlobalObject*);
<span class="line-new-header">--- 1061,59 ---</span>
  
  static const DOMJIT::Signature DOMJITFunctionObjectSignature(DOMJITFunctionObject::functionWithoutTypeCheck, DOMJITFunctionObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);
  
  void DOMJITFunctionObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      Base::finishCreation(vm);
      putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;func&quot;), 0, functionWithTypeCheck, NoIntrinsic, &amp;DOMJITFunctionObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
  }
  
  class DOMJITCheckSubClassObject : public DOMJITNode {
  public:
      DOMJITCheckSubClassObject(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
      }
  
      DECLARE_INFO;
      typedef DOMJITNode Base;
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
      }
  
      static DOMJITCheckSubClassObject* create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          DOMJITCheckSubClassObject* object = new (NotNull, allocateCell&lt;DOMJITCheckSubClassObject&gt;(vm.heap)) DOMJITCheckSubClassObject(vm, structure);
          object-&gt;finishCreation(vm, globalObject);
          return object;
      }
  
<span class="line-modified">!     static EncodedJSValue JSC_HOST_CALL functionWithTypeCheck(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         VM&amp; vm = globalObject-&gt;vm();</span>
          auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!         auto* thisObject = jsDynamicCast&lt;DOMJITCheckSubClassObject*&gt;(vm, callFrame-&gt;thisValue());</span>
          if (!thisObject)
<span class="line-modified">!             return throwVMTypeError(globalObject, scope);</span>
          return JSValue::encode(jsNumber(thisObject-&gt;value()));
      }
  
<span class="line-modified">!     static EncodedJSValue JIT_OPERATION functionWithoutTypeCheck(JSGlobalObject* globalObject, DOMJITNode* node)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-modified">!         VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+         CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+         JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
          return JSValue::encode(jsNumber(node-&gt;value()));
      }
  
  private:
      void finishCreation(VM&amp;, JSGlobalObject*);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 885,40 ***</span>
  
  static const DOMJIT::Signature DOMJITCheckSubClassObjectSignature(DOMJITCheckSubClassObject::functionWithoutTypeCheck, DOMJITCheckSubClassObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);
  
  void DOMJITCheckSubClassObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
  {
      Base::finishCreation(vm);
      putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;func&quot;), 0, functionWithTypeCheck, NoIntrinsic, &amp;DOMJITCheckSubClassObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
  }
  
  class DOMJITGetterBaseJSObject : public DOMJITNode {
  public:
      DOMJITGetterBaseJSObject(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
      }
  
      DECLARE_INFO;
      using Base = DOMJITNode;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags;</span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
          return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
      }
  
      static DOMJITGetterBaseJSObject* create(VM&amp; vm, Structure* structure)
      {
          DOMJITGetterBaseJSObject* getter = new (NotNull, allocateCell&lt;DOMJITGetterBaseJSObject&gt;(vm.heap)) DOMJITGetterBaseJSObject(vm, structure);
          getter-&gt;finishCreation(vm);
          return getter;
      }
  
      class DOMJITAttribute : public DOMJIT::GetterSetter {
      public:
<span class="line-modified">!         constexpr DOMJITAttribute()</span>
              : DOMJIT::GetterSetter(
                  DOMJITGetterBaseJSObject::customGetter,
  #if ENABLE(JIT)
                  &amp;callDOMGetter,
  #else
<span class="line-new-header">--- 1121,44 ---</span>
  
  static const DOMJIT::Signature DOMJITCheckSubClassObjectSignature(DOMJITCheckSubClassObject::functionWithoutTypeCheck, DOMJITCheckSubClassObject::info(), DOMJIT::Effect::forRead(DOMJIT::HeapRange::top()), SpecInt32Only);
  
  void DOMJITCheckSubClassObject::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      Base::finishCreation(vm);
      putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;func&quot;), 0, functionWithTypeCheck, NoIntrinsic, &amp;DOMJITCheckSubClassObjectSignature, static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
  }
  
  class DOMJITGetterBaseJSObject : public DOMJITNode {
  public:
      DOMJITGetterBaseJSObject(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
      }
  
      DECLARE_INFO;
      using Base = DOMJITNode;
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          return Structure::create(vm, globalObject, prototype, TypeInfo(JSC::JSType(LastJSCObjectType + 1), StructureFlags), info());
      }
  
      static DOMJITGetterBaseJSObject* create(VM&amp; vm, Structure* structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          DOMJITGetterBaseJSObject* getter = new (NotNull, allocateCell&lt;DOMJITGetterBaseJSObject&gt;(vm.heap)) DOMJITGetterBaseJSObject(vm, structure);
          getter-&gt;finishCreation(vm);
          return getter;
      }
  
      class DOMJITAttribute : public DOMJIT::GetterSetter {
      public:
<span class="line-modified">!         ALWAYS_INLINE constexpr DOMJITAttribute()</span>
              : DOMJIT::GetterSetter(
                  DOMJITGetterBaseJSObject::customGetter,
  #if ENABLE(JIT)
                  &amp;callDOMGetter,
  #else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 927,26 ***</span>
                  SpecBytecodeTop)
          {
          }
  
  #if ENABLE(JIT)
<span class="line-modified">!         static EncodedJSValue JIT_OPERATION slowCall(ExecState* exec, void* pointer)</span>
          {
<span class="line-modified">!             VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!             NativeCallFrameTracer tracer(vm, exec);</span>
              JSObject* object = static_cast&lt;JSObject*&gt;(pointer);
              return JSValue::encode(object-&gt;getPrototypeDirect(vm));
          }
  
          static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
          {
              Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
<span class="line-modified">!             snippet-&gt;requireGlobalObject = false;</span>
<span class="line-modified">!             snippet-&gt;setGenerator([=](CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>
                  JSValueRegs results = params[0].jsValueRegs();
<span class="line-modified">!                 GPRReg dom = params[1].gpr();</span>
<span class="line-modified">!                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, dom);</span>
                  return CCallHelpers::JumpList();
  
              });
              return snippet;
          }
<span class="line-new-header">--- 1167,31 ---</span>
                  SpecBytecodeTop)
          {
          }
  
  #if ENABLE(JIT)
<span class="line-modified">!         static EncodedJSValue JIT_OPERATION slowCall(JSGlobalObject* globalObject, void* pointer)</span>
          {
<span class="line-modified">!             DollarVMAssertScope assertScope;</span>
<span class="line-modified">!             VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+             CallFrame* callFrame = DECLARE_CALL_FRAME(vm);</span>
<span class="line-added">+             JITOperationPrologueCallFrameTracer tracer(vm, callFrame);</span>
              JSObject* object = static_cast&lt;JSObject*&gt;(pointer);
              return JSValue::encode(object-&gt;getPrototypeDirect(vm));
          }
  
          static Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; callDOMGetter()
          {
<span class="line-added">+             DollarVMAssertScope assertScope;</span>
              Ref&lt;DOMJIT::CallDOMGetterSnippet&gt; snippet = DOMJIT::CallDOMGetterSnippet::create();
<span class="line-modified">!             snippet-&gt;requireGlobalObject = true;</span>
<span class="line-modified">!             snippet-&gt;setGenerator([=] (CCallHelpers&amp; jit, SnippetParams&amp; params) {</span>
<span class="line-added">+                 DollarVMAssertScope assertScope;</span>
                  JSValueRegs results = params[0].jsValueRegs();
<span class="line-modified">!                 GPRReg domGPR = params[1].gpr();</span>
<span class="line-modified">!                 GPRReg globalObjectGPR = params[2].gpr();</span>
<span class="line-added">+                 params.addSlowPathCall(jit.jump(), jit, slowCall, results, globalObjectGPR, domGPR);</span>
                  return CCallHelpers::JumpList();
  
              });
              return snippet;
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 954,23 ***</span>
      };
  
  private:
      void finishCreation(VM&amp;);
  
<span class="line-modified">!     static EncodedJSValue customGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName)</span>
      {
<span class="line-modified">!         VM&amp; vm = exec-&gt;vm();</span>
          JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
          RELEASE_ASSERT(thisObject);
          return JSValue::encode(thisObject-&gt;getPrototypeDirect(vm));
      }
  };
  
  static const DOMJITGetterBaseJSObject::DOMJITAttribute DOMJITGetterBaseJSObjectDOMJIT;
  
  void DOMJITGetterBaseJSObject::finishCreation(VM&amp; vm)
  {
      Base::finishCreation(vm);
      const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterBaseJSObjectDOMJIT;
      auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { JSObject::info(), domJIT });
      putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
  }
<span class="line-new-header">--- 1199,25 ---</span>
      };
  
  private:
      void finishCreation(VM&amp;);
  
<span class="line-modified">!     static EncodedJSValue customGetter(JSGlobalObject* globalObject, EncodedJSValue thisValue, PropertyName)</span>
      {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         VM&amp; vm = globalObject-&gt;vm();</span>
          JSObject* thisObject = jsDynamicCast&lt;JSObject*&gt;(vm, JSValue::decode(thisValue));
          RELEASE_ASSERT(thisObject);
          return JSValue::encode(thisObject-&gt;getPrototypeDirect(vm));
      }
  };
  
  static const DOMJITGetterBaseJSObject::DOMJITAttribute DOMJITGetterBaseJSObjectDOMJIT;
  
  void DOMJITGetterBaseJSObject::finishCreation(VM&amp; vm)
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      Base::finishCreation(vm);
      const DOMJIT::GetterSetter* domJIT = &amp;DOMJITGetterBaseJSObjectDOMJIT;
      auto* customGetterSetter = DOMAttributeGetterSetter::create(vm, domJIT-&gt;getter(), nullptr, DOMAttributeAnnotation { JSObject::info(), domJIT });
      putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customGetter&quot;), customGetterSetter, PropertyAttribute::ReadOnly | PropertyAttribute::CustomAccessor);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 989,77 ***</span>
  };
  
  class JSTestCustomGetterSetter : public JSNonFinalObject {
  public:
      using Base = JSNonFinalObject;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags;</span>
  
      JSTestCustomGetterSetter(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
<span class="line-modified">!     { }</span>
  
      static JSTestCustomGetterSetter* create(VM&amp; vm, JSGlobalObject*, Structure* structure)
      {
          JSTestCustomGetterSetter* result = new (NotNull, allocateCell&lt;JSTestCustomGetterSetter&gt;(vm.heap)) JSTestCustomGetterSetter(vm, structure);
          result-&gt;finishCreation(vm);
          return result;
      }
  
      void finishCreation(VM&amp;);
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject)
      {
          return Structure::create(vm, globalObject, globalObject-&gt;objectPrototype(), TypeInfo(ObjectType, StructureFlags), info());
      }
  
      DECLARE_INFO;
  };
  
  
<span class="line-modified">! static EncodedJSValue customGetAccessor(ExecState*, EncodedJSValue thisValue, PropertyName)</span>
  {
      // Passed |this|
      return thisValue;
  }
  
<span class="line-modified">! static EncodedJSValue customGetValue(ExecState* exec, EncodedJSValue slotValue, PropertyName)</span>
  {
<span class="line-modified">!     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(exec-&gt;vm()));</span>
      // Passed property holder.
      return slotValue;
  }
  
<span class="line-modified">! static bool customSetAccessor(ExecState* exec, EncodedJSValue thisObject, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
      JSValue value = JSValue::decode(encodedValue);
      RELEASE_ASSERT(value.isObject());
      JSObject* object = asObject(value);
      PutPropertySlot slot(object);
<span class="line-modified">!     object-&gt;put(object, exec, Identifier::fromString(vm, &quot;result&quot;), JSValue::decode(thisObject), slot);</span>
  
      return true;
  }
  
<span class="line-modified">! static bool customSetValue(ExecState* exec, EncodedJSValue slotValue, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
<span class="line-modified">!     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(exec-&gt;vm()));</span>
  
      JSValue value = JSValue::decode(encodedValue);
      RELEASE_ASSERT(value.isObject());
      JSObject* object = asObject(value);
      PutPropertySlot slot(object);
<span class="line-modified">!     object-&gt;put(object, exec, Identifier::fromString(vm, &quot;result&quot;), JSValue::decode(slotValue), slot);</span>
  
      return true;
  }
  
  void JSTestCustomGetterSetter::finishCreation(VM&amp; vm)
  {
      Base::finishCreation(vm);
  
      putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customValue&quot;),
          CustomGetterSetter::create(vm, customGetValue, customSetValue), 0);
      putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customAccessor&quot;),
<span class="line-new-header">--- 1236,84 ---</span>
  };
  
  class JSTestCustomGetterSetter : public JSNonFinalObject {
  public:
      using Base = JSNonFinalObject;
<span class="line-modified">!     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
  
      JSTestCustomGetterSetter(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
<span class="line-modified">!     {</span>
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
<span class="line-added">+     }</span>
  
      static JSTestCustomGetterSetter* create(VM&amp; vm, JSGlobalObject*, Structure* structure)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          JSTestCustomGetterSetter* result = new (NotNull, allocateCell&lt;JSTestCustomGetterSetter&gt;(vm.heap)) JSTestCustomGetterSetter(vm, structure);
          result-&gt;finishCreation(vm);
          return result;
      }
  
      void finishCreation(VM&amp;);
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          return Structure::create(vm, globalObject, globalObject-&gt;objectPrototype(), TypeInfo(ObjectType, StructureFlags), info());
      }
  
      DECLARE_INFO;
  };
  
  
<span class="line-modified">! static EncodedJSValue customGetAccessor(JSGlobalObject*, EncodedJSValue thisValue, PropertyName)</span>
  {
      // Passed |this|
      return thisValue;
  }
  
<span class="line-modified">! static EncodedJSValue customGetValue(JSGlobalObject* globalObject, EncodedJSValue slotValue, PropertyName)</span>
  {
<span class="line-modified">!     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(globalObject-&gt;vm()));</span>
      // Passed property holder.
      return slotValue;
  }
  
<span class="line-modified">! static bool customSetAccessor(JSGlobalObject* globalObject, EncodedJSValue thisObject, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
  
      JSValue value = JSValue::decode(encodedValue);
      RELEASE_ASSERT(value.isObject());
      JSObject* object = asObject(value);
      PutPropertySlot slot(object);
<span class="line-modified">!     object-&gt;put(object, globalObject, Identifier::fromString(vm, &quot;result&quot;), JSValue::decode(thisObject), slot);</span>
  
      return true;
  }
  
<span class="line-modified">! static bool customSetValue(JSGlobalObject* globalObject, EncodedJSValue slotValue, EncodedJSValue encodedValue)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
  
<span class="line-modified">!     RELEASE_ASSERT(JSValue::decode(slotValue).inherits&lt;JSTestCustomGetterSetter&gt;(globalObject-&gt;vm()));</span>
  
      JSValue value = JSValue::decode(encodedValue);
      RELEASE_ASSERT(value.isObject());
      JSObject* object = asObject(value);
      PutPropertySlot slot(object);
<span class="line-modified">!     object-&gt;put(object, globalObject, Identifier::fromString(vm, &quot;result&quot;), JSValue::decode(slotValue), slot);</span>
  
      return true;
  }
  
  void JSTestCustomGetterSetter::finishCreation(VM&amp; vm)
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      Base::finishCreation(vm);
  
      putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customValue&quot;),
          CustomGetterSetter::create(vm, customGetValue, customSetValue), 0);
      putDirectCustomAccessor(vm, Identifier::fromString(vm, &quot;customAccessor&quot;),
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1086,90 ***</span>
  const ClassInfo DOMJITFunctionObject::s_info = { &quot;DOMJITFunctionObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITFunctionObject) };
  #endif
  const ClassInfo DOMJITCheckSubClassObject::s_info = { &quot;DOMJITCheckSubClassObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITCheckSubClassObject) };
  const ClassInfo JSTestCustomGetterSetter::s_info = { &quot;JSTestCustomGetterSetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTestCustomGetterSetter) };
  
  ElementHandleOwner* Element::handleOwner()
  {
      static ElementHandleOwner* owner = 0;
      if (!owner)
          owner = new ElementHandleOwner();
      return owner;
  }
  
  void Element::finishCreation(VM&amp; vm, Root* root)
  {
      Base::finishCreation(vm);
      setRoot(vm, root);
      m_root-&gt;setElement(this);
  }
  
  #if ENABLE(WEBASSEMBLY)
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(ExecState*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(ExecState*);</span>
  
  class WasmStreamingParser : public JSDestructibleObject {
  public:
      WasmStreamingParser(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
          , m_info(Wasm::ModuleInformation::create())
<span class="line-modified">!         , m_streamingParser(m_info.get())</span>
      {
      }
  
      using Base = JSDestructibleObject;
  
      static WasmStreamingParser* create(VM&amp; vm, JSGlobalObject* globalObject)
      {
          Structure* structure = createStructure(vm, globalObject, jsNull());
          WasmStreamingParser* result = new (NotNull, allocateCell&lt;WasmStreamingParser&gt;(vm.heap)) WasmStreamingParser(vm, structure);
          result-&gt;finishCreation(vm);
          return result;
      }
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
          return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
      }
  
      Wasm::StreamingParser&amp; streamingParser() { return m_streamingParser; }
  
      void finishCreation(VM&amp; vm)
      {
          Base::finishCreation(vm);
  
          JSGlobalObject* globalObject = this-&gt;globalObject(vm);
          putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;addBytes&quot;), 0, functionWasmStreamingParserAddBytes, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
          putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;finalize&quot;), 0, functionWasmStreamingParserFinalize, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      }
  
      DECLARE_INFO;
  
      Ref&lt;Wasm::ModuleInformation&gt; m_info;
      Wasm::StreamingParser m_streamingParser;
  };
  
  const ClassInfo WasmStreamingParser::s_info = { &quot;WasmStreamingParser&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WasmStreamingParser) };
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());</span>
<span class="line-modified">!     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, exec-&gt;thisValue());</span>
      if (!thisObject)
          RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(false)));
  
<span class="line-modified">!     auto data = getWasmBufferFromValue(exec, exec-&gt;argument(0));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      RELEASE_AND_RETURN(scope, JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(thisObject-&gt;streamingParser().addBytes(bitwise_cast&lt;const uint8_t*&gt;(data.first), data.second)))));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, exec-&gt;thisValue());</span>
      if (!thisObject)
          return JSValue::encode(jsBoolean(false));
      return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(thisObject-&gt;streamingParser().finalize())));
  }
  
<span class="line-new-header">--- 1340,118 ---</span>
  const ClassInfo DOMJITFunctionObject::s_info = { &quot;DOMJITFunctionObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITFunctionObject) };
  #endif
  const ClassInfo DOMJITCheckSubClassObject::s_info = { &quot;DOMJITCheckSubClassObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(DOMJITCheckSubClassObject) };
  const ClassInfo JSTestCustomGetterSetter::s_info = { &quot;JSTestCustomGetterSetter&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSTestCustomGetterSetter) };
  
<span class="line-added">+ const ClassInfo StaticCustomAccessor::s_info = { &quot;StaticCustomAccessor&quot;, &amp;Base::s_info, &amp;staticCustomAccessorTable, nullptr, CREATE_METHOD_TABLE(StaticCustomAccessor) };</span>
<span class="line-added">+ const ClassInfo ObjectDoingSideEffectPutWithoutCorrectSlotStatus::s_info = { &quot;ObjectDoingSideEffectPutWithoutCorrectSlotStatus&quot;, &amp;Base::s_info, &amp;staticCustomAccessorTable, nullptr, CREATE_METHOD_TABLE(ObjectDoingSideEffectPutWithoutCorrectSlotStatus) };</span>
<span class="line-added">+ </span>
  ElementHandleOwner* Element::handleOwner()
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      static ElementHandleOwner* owner = 0;
      if (!owner)
          owner = new ElementHandleOwner();
      return owner;
  }
  
  void Element::finishCreation(VM&amp; vm, Root* root)
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      Base::finishCreation(vm);
      setRoot(vm, root);
      m_root-&gt;setElement(this);
  }
  
  #if ENABLE(WEBASSEMBLY)
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(JSGlobalObject*, CallFrame*);</span>
  
  class WasmStreamingParser : public JSDestructibleObject {
  public:
<span class="line-added">+     class Client final : public Wasm::StreamingParserClient {</span>
<span class="line-added">+     public:</span>
<span class="line-added">+         explicit Client(WasmStreamingParser* parser)</span>
<span class="line-added">+             : m_parser(parser)</span>
<span class="line-added">+         {</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
<span class="line-added">+         bool didReceiveSectionData(Wasm::Section) override { return true; }</span>
<span class="line-added">+         bool didReceiveFunctionData(unsigned, const Wasm::FunctionData&amp;) override { return true; }</span>
<span class="line-added">+         void didFinishParsing() override { }</span>
<span class="line-added">+ </span>
<span class="line-added">+         WasmStreamingParser* m_parser;</span>
<span class="line-added">+     };</span>
<span class="line-added">+ </span>
      WasmStreamingParser(VM&amp; vm, Structure* structure)
          : Base(vm, structure)
          , m_info(Wasm::ModuleInformation::create())
<span class="line-modified">!         , m_client(this)</span>
<span class="line-added">+         , m_streamingParser(m_info.get(), m_client)</span>
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
      }
  
      using Base = JSDestructibleObject;
  
      static WasmStreamingParser* create(VM&amp; vm, JSGlobalObject* globalObject)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          Structure* structure = createStructure(vm, globalObject, jsNull());
          WasmStreamingParser* result = new (NotNull, allocateCell&lt;WasmStreamingParser&gt;(vm.heap)) WasmStreamingParser(vm, structure);
          result-&gt;finishCreation(vm);
          return result;
      }
  
      static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
      }
  
      Wasm::StreamingParser&amp; streamingParser() { return m_streamingParser; }
  
      void finishCreation(VM&amp; vm)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          Base::finishCreation(vm);
  
          JSGlobalObject* globalObject = this-&gt;globalObject(vm);
          putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;addBytes&quot;), 0, functionWasmStreamingParserAddBytes, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
          putDirectNativeFunction(vm, globalObject, Identifier::fromString(vm, &quot;finalize&quot;), 0, functionWasmStreamingParserFinalize, NoIntrinsic, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
      }
  
      DECLARE_INFO;
  
      Ref&lt;Wasm::ModuleInformation&gt; m_info;
<span class="line-added">+     Client m_client;</span>
      Wasm::StreamingParser m_streamingParser;
  };
  
  const ClassInfo WasmStreamingParser::s_info = { &quot;WasmStreamingParser&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(WasmStreamingParser) };
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserAddBytes(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(globalObject-&gt;vm());</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, callFrame-&gt;thisValue());</span>
      if (!thisObject)
          RELEASE_AND_RETURN(scope, JSValue::encode(jsBoolean(false)));
  
<span class="line-modified">!     auto data = getWasmBufferFromValue(globalObject, callFrame-&gt;argument(0));</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
      RELEASE_AND_RETURN(scope, JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(thisObject-&gt;streamingParser().addBytes(bitwise_cast&lt;const uint8_t*&gt;(data.first), data.second)))));
  }
  
<span class="line-modified">! EncodedJSValue JSC_HOST_CALL functionWasmStreamingParserFinalize(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto* thisObject = jsDynamicCast&lt;WasmStreamingParser*&gt;(vm, callFrame-&gt;thisValue());</span>
      if (!thisObject)
          return JSValue::encode(jsBoolean(false));
      return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(thisObject-&gt;streamingParser().finalize())));
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1181,73 ***</span>
  
  const ClassInfo JSDollarVM::s_info = { &quot;DollarVM&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDollarVM) };
  
  // Triggers a crash immediately.
  // Usage: $vm.crash()
<span class="line-modified">! static NO_RETURN_DUE_TO_CRASH EncodedJSValue JSC_HOST_CALL functionCrash(ExecState*)</span>
  {
      CRASH();
  }
  
  // Executes a breakpoint instruction if the first argument is truthy or is unset.
  // Usage: $vm.breakpoint(&lt;condition&gt;)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionBreakpoint(ExecState* exec)</span>
  {
      // Nothing should throw here but we might as well double check...
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
      UNUSED_PARAM(scope);
<span class="line-modified">!     if (!exec-&gt;argumentCount() || exec-&gt;argument(0).toBoolean(exec))</span>
          WTFBreakpointTrap();
  
      return encodedJSUndefined();
  }
  
  // Returns true if the current frame is a DFG frame.
  // Usage: isDFG = $vm.dfgTrue()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDFGTrue(ExecState*)</span>
  {
      return JSValue::encode(jsBoolean(false));
  }
  
  // Returns true if the current frame is a FTL frame.
  // Usage: isFTL = $vm.ftlTrue()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionFTLTrue(ExecState*)</span>
  {
      return JSValue::encode(jsBoolean(false));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCpuMfence(ExecState*)</span>
  {
  #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
      asm volatile(&quot;mfence&quot; ::: &quot;memory&quot;);
  #endif
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCpuRdtsc(ExecState*)</span>
  {
  #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
      unsigned high;
      unsigned low;
      asm volatile (&quot;rdtsc&quot; : &quot;=a&quot;(low), &quot;=d&quot;(high));
      return JSValue::encode(jsNumber(low));
  #else
      return JSValue::encode(jsNumber(0));
  #endif
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCpuCpuid(ExecState*)</span>
  {
  #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
      WTF::x86_cpuid();
  #endif
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCpuPause(ExecState*)</span>
  {
  #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
      asm volatile (&quot;pause&quot; ::: &quot;memory&quot;);
  #endif
      return JSValue::encode(jsUndefined());
  }
<span class="line-new-header">--- 1463,81 ---</span>
  
  const ClassInfo JSDollarVM::s_info = { &quot;DollarVM&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSDollarVM) };
  
  // Triggers a crash immediately.
  // Usage: $vm.crash()
<span class="line-modified">! static NO_RETURN_DUE_TO_CRASH EncodedJSValue JSC_HOST_CALL functionCrash(JSGlobalObject*, CallFrame*)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      CRASH();
  }
  
  // Executes a breakpoint instruction if the first argument is truthy or is unset.
  // Usage: $vm.breakpoint(&lt;condition&gt;)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionBreakpoint(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      // Nothing should throw here but we might as well double check...
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_CATCH_SCOPE(vm);
      UNUSED_PARAM(scope);
<span class="line-modified">!     if (!callFrame-&gt;argumentCount() || callFrame-&gt;argument(0).toBoolean(globalObject))</span>
          WTFBreakpointTrap();
  
      return encodedJSUndefined();
  }
  
  // Returns true if the current frame is a DFG frame.
  // Usage: isDFG = $vm.dfgTrue()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDFGTrue(JSGlobalObject*, CallFrame*)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      return JSValue::encode(jsBoolean(false));
  }
  
  // Returns true if the current frame is a FTL frame.
  // Usage: isFTL = $vm.ftlTrue()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionFTLTrue(JSGlobalObject*, CallFrame*)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      return JSValue::encode(jsBoolean(false));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCpuMfence(JSGlobalObject*, CallFrame*)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
  #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
      asm volatile(&quot;mfence&quot; ::: &quot;memory&quot;);
  #endif
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCpuRdtsc(JSGlobalObject*, CallFrame*)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
  #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
      unsigned high;
      unsigned low;
      asm volatile (&quot;rdtsc&quot; : &quot;=a&quot;(low), &quot;=d&quot;(high));
      return JSValue::encode(jsNumber(low));
  #else
      return JSValue::encode(jsNumber(0));
  #endif
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCpuCpuid(JSGlobalObject*, CallFrame*)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
  #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
      WTF::x86_cpuid();
  #endif
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCpuPause(JSGlobalObject*, CallFrame*)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
  #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
      asm volatile (&quot;pause&quot; ::: &quot;memory&quot;);
  #endif
      return JSValue::encode(jsUndefined());
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1259,30 ***</span>
  // plus the second argument as a byte offset. It&#39;ll also flush on the object
  // itself so its length, etc, aren&#39;t in the cache.
  //
  // If the first argument is not a JSArrayBuffer, we load the butterfly
  // and clflush at the address of the butterfly.
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCpuClflush(ExecState* exec)</span>
  {
  #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
  
<span class="line-modified">!     if (!exec-&gt;argument(1).isInt32())</span>
          return JSValue::encode(jsBoolean(false));
  
      auto clflush = [] (void* ptr) {
          char* ptrToFlush = static_cast&lt;char*&gt;(ptr);
          asm volatile (&quot;clflush %0&quot; :: &quot;m&quot;(*ptrToFlush) : &quot;memory&quot;);
      };
  
      Vector&lt;void*&gt; toFlush;
  
<span class="line-modified">!     uint32_t offset = exec-&gt;argument(1).asUInt32();</span>
  
<span class="line-modified">!     if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, exec-&gt;argument(0)))</span>
          toFlush.append(bitwise_cast&lt;char*&gt;(view-&gt;vector()) + offset);
<span class="line-modified">!     else if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0))) {</span>
          switch (object-&gt;indexingType()) {
          case ALL_INT32_INDEXING_TYPES:
          case ALL_CONTIGUOUS_INDEXING_TYPES:
          case ALL_DOUBLE_INDEXING_TYPES:
              toFlush.append(bitwise_cast&lt;char*&gt;(object-&gt;butterfly()) + Butterfly::offsetOfVectorLength());
<span class="line-new-header">--- 1549,32 ---</span>
  // plus the second argument as a byte offset. It&#39;ll also flush on the object
  // itself so its length, etc, aren&#39;t in the cache.
  //
  // If the first argument is not a JSArrayBuffer, we load the butterfly
  // and clflush at the address of the butterfly.
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCpuClflush(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
  #if CPU(X86_64) &amp;&amp; !OS(WINDOWS)
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
  
<span class="line-modified">!     if (!callFrame-&gt;argument(1).isInt32())</span>
          return JSValue::encode(jsBoolean(false));
  
      auto clflush = [] (void* ptr) {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          char* ptrToFlush = static_cast&lt;char*&gt;(ptr);
          asm volatile (&quot;clflush %0&quot; :: &quot;m&quot;(*ptrToFlush) : &quot;memory&quot;);
      };
  
      Vector&lt;void*&gt; toFlush;
  
<span class="line-modified">!     uint32_t offset = callFrame-&gt;argument(1).asUInt32();</span>
  
<span class="line-modified">!     if (JSArrayBufferView* view = jsDynamicCast&lt;JSArrayBufferView*&gt;(vm, callFrame-&gt;argument(0)))</span>
          toFlush.append(bitwise_cast&lt;char*&gt;(view-&gt;vector()) + offset);
<span class="line-modified">!     else if (JSObject* object = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(0))) {</span>
          switch (object-&gt;indexingType()) {
          case ALL_INT32_INDEXING_TYPES:
          case ALL_CONTIGUOUS_INDEXING_TYPES:
          case ALL_DOUBLE_INDEXING_TYPES:
              toFlush.append(bitwise_cast&lt;char*&gt;(object-&gt;butterfly()) + Butterfly::offsetOfVectorLength());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1295,21 ***</span>
  
      for (void* ptr : toFlush)
          clflush(ptr);
      return JSValue::encode(jsBoolean(true));
  #else
<span class="line-modified">!     UNUSED_PARAM(exec);</span>
      return JSValue::encode(jsBoolean(false));
  #endif
  }
  
  class CallerFrameJITTypeFunctor {
  public:
      CallerFrameJITTypeFunctor()
          : m_currentFrame(0)
          , m_jitType(JITType::None)
      {
      }
  
      StackVisitor::Status operator()(StackVisitor&amp; visitor) const
      {
          if (m_currentFrame++ &gt; 1) {
<span class="line-new-header">--- 1587,23 ---</span>
  
      for (void* ptr : toFlush)
          clflush(ptr);
      return JSValue::encode(jsBoolean(true));
  #else
<span class="line-modified">!     UNUSED_PARAM(globalObject);</span>
<span class="line-added">+     UNUSED_PARAM(callFrame);</span>
      return JSValue::encode(jsBoolean(false));
  #endif
  }
  
  class CallerFrameJITTypeFunctor {
  public:
      CallerFrameJITTypeFunctor()
          : m_currentFrame(0)
          , m_jitType(JITType::None)
      {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
      }
  
      StackVisitor::Status operator()(StackVisitor&amp; visitor) const
      {
          if (m_currentFrame++ &gt; 1) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1326,10 ***</span>
<span class="line-new-header">--- 1620,11 ---</span>
      mutable JITType m_jitType;
  };
  
  static FunctionExecutable* getExecutableForFunction(JSValue theFunctionValue)
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      if (!theFunctionValue.isCell())
          return nullptr;
  
      VM&amp; vm = theFunctionValue.asCell()-&gt;vm();
      JSFunction* theFunction = jsDynamicCast&lt;JSFunction*&gt;(vm, theFunctionValue);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1342,68 ***</span>
      return executable;
  }
  
  // Returns true if the current frame is a LLInt frame.
  // Usage: isLLInt = $vm.llintTrue()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionLLintTrue(ExecState* exec)</span>
  {
<span class="line-modified">!     if (!exec)</span>
          return JSValue::encode(jsUndefined());
      CallerFrameJITTypeFunctor functor;
<span class="line-modified">!     exec-&gt;iterate(functor);</span>
      return JSValue::encode(jsBoolean(functor.jitType() == JITType::InterpreterThunk));
  }
  
  // Returns true if the current frame is a baseline JIT frame.
  // Usage: isBaselineJIT = $vm.jitTrue()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionJITTrue(ExecState* exec)</span>
  {
<span class="line-modified">!     if (!exec)</span>
          return JSValue::encode(jsUndefined());
      CallerFrameJITTypeFunctor functor;
<span class="line-modified">!     exec-&gt;iterate(functor);</span>
      return JSValue::encode(jsBoolean(functor.jitType() == JITType::BaselineJIT));
  }
  
  // Set that the argument function should not be inlined.
  // Usage:
  // function f() { };
  // $vm.noInline(f);
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionNoInline(ExecState* exec)</span>
  {
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     JSValue theFunctionValue = exec-&gt;uncheckedArgument(0);</span>
  
      if (FunctionExecutable* executable = getExecutableForFunction(theFunctionValue))
          executable-&gt;setNeverInline(true);
  
      return JSValue::encode(jsUndefined());
  }
  
  // Runs a full GC synchronously.
  // Usage: $vm.gc()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGC(ExecState* exec)</span>
  {
<span class="line-modified">!     VMInspector::gc(exec);</span>
      return JSValue::encode(jsUndefined());
  }
  
  // Runs the edenGC synchronously.
  // Usage: $vm.edenGC()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionEdenGC(ExecState* exec)</span>
  {
<span class="line-modified">!     VMInspector::edenGC(exec);</span>
      return JSValue::encode(jsUndefined());
  }
  
  // Dumps the hashes of all subspaces currently registered with the VM.
  // Usage: $vm.dumpSubspaceHashes()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpSubspaceHashes(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      VMInspector::dumpSubspaceHashes(&amp;vm);
      return JSValue::encode(jsUndefined());
  }
  
  // Gets a JSDollarVMCallFrame for a specified frame index.
<span class="line-new-header">--- 1637,76 ---</span>
      return executable;
  }
  
  // Returns true if the current frame is a LLInt frame.
  // Usage: isLLInt = $vm.llintTrue()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionLLintTrue(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     if (!callFrame)</span>
          return JSValue::encode(jsUndefined());
      CallerFrameJITTypeFunctor functor;
<span class="line-modified">!     callFrame-&gt;iterate(vm, functor);</span>
      return JSValue::encode(jsBoolean(functor.jitType() == JITType::InterpreterThunk));
  }
  
  // Returns true if the current frame is a baseline JIT frame.
  // Usage: isBaselineJIT = $vm.jitTrue()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionJITTrue(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     if (!callFrame)</span>
          return JSValue::encode(jsUndefined());
      CallerFrameJITTypeFunctor functor;
<span class="line-modified">!     callFrame-&gt;iterate(vm, functor);</span>
      return JSValue::encode(jsBoolean(functor.jitType() == JITType::BaselineJIT));
  }
  
  // Set that the argument function should not be inlined.
  // Usage:
  // function f() { };
  // $vm.noInline(f);
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionNoInline(JSGlobalObject*, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     JSValue theFunctionValue = callFrame-&gt;uncheckedArgument(0);</span>
  
      if (FunctionExecutable* executable = getExecutableForFunction(theFunctionValue))
          executable-&gt;setNeverInline(true);
  
      return JSValue::encode(jsUndefined());
  }
  
  // Runs a full GC synchronously.
  // Usage: $vm.gc()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGC(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VMInspector::gc(globalObject);</span>
      return JSValue::encode(jsUndefined());
  }
  
  // Runs the edenGC synchronously.
  // Usage: $vm.edenGC()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionEdenGC(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VMInspector::edenGC(globalObject);</span>
      return JSValue::encode(jsUndefined());
  }
  
  // Dumps the hashes of all subspaces currently registered with the VM.
  // Usage: $vm.dumpSubspaceHashes()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpSubspaceHashes(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      VMInspector::dumpSubspaceHashes(&amp;vm);
      return JSValue::encode(jsUndefined());
  }
  
  // Gets a JSDollarVMCallFrame for a specified frame index.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1418,57 ***</span>
  //    callFrame.executable;
  //
  // Note: you cannot toString() a codeBlock, unlinkedCodeBlock, or executable because
  // there are internal objects and not a JS object. Hence, you cannot do string
  // concatenation with them.
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCallFrame(ExecState* exec)</span>
  {
      unsigned frameNumber = 1;
<span class="line-modified">!     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">!         JSValue value = exec-&gt;uncheckedArgument(0);</span>
          if (!value.isUInt32())
              return JSValue::encode(jsUndefined());
  
          // We need to inc the frame number because the caller would consider
          // its own frame as frame 0. Hence, we need discount the frame for this
          // function.
          frameNumber = value.asUInt32() + 1;
      }
  
<span class="line-modified">!     return JSValue::encode(JSDollarVMCallFrame::create(exec, frameNumber));</span>
  }
  
  // Gets a token for the CodeBlock for a specified frame index.
  // Usage: codeBlockToken = $vm.codeBlockForFrame(0) // frame 0 is the top frame.
  // Usage: codeBlockToken = $vm.codeBlockForFrame() // implies frame 0 i.e. current frame.
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCodeBlockForFrame(ExecState* exec)</span>
  {
      unsigned frameNumber = 1;
<span class="line-modified">!     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">!         JSValue value = exec-&gt;uncheckedArgument(0);</span>
          if (!value.isUInt32())
              return JSValue::encode(jsUndefined());
  
          // We need to inc the frame number because the caller would consider
          // its own frame as frame 0. Hence, we need discount the frame for this
          // function.
          frameNumber = value.asUInt32() + 1;
      }
  
<span class="line-modified">!     CodeBlock* codeBlock = VMInspector::codeBlockForFrame(exec, frameNumber);</span>
      if (codeBlock)
          return JSValue::encode(codeBlock);
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static CodeBlock* codeBlockFromArg(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1)</span>
          return nullptr;
  
<span class="line-modified">!     JSValue value = exec-&gt;uncheckedArgument(0);</span>
      CodeBlock* candidateCodeBlock = nullptr;
      if (value.isCell()) {
          JSFunction* func = jsDynamicCast&lt;JSFunction*&gt;(vm, value.asCell());
          if (func) {
              if (func-&gt;isHostFunction())
<span class="line-new-header">--- 1721,60 ---</span>
  //    callFrame.executable;
  //
  // Note: you cannot toString() a codeBlock, unlinkedCodeBlock, or executable because
  // there are internal objects and not a JS object. Hence, you cannot do string
  // concatenation with them.
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCallFrame(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      unsigned frameNumber = 1;
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">!         JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
          if (!value.isUInt32())
              return JSValue::encode(jsUndefined());
  
          // We need to inc the frame number because the caller would consider
          // its own frame as frame 0. Hence, we need discount the frame for this
          // function.
          frameNumber = value.asUInt32() + 1;
      }
  
<span class="line-modified">!     return JSValue::encode(JSDollarVMCallFrame::create(globalObject, callFrame, frameNumber));</span>
  }
  
  // Gets a token for the CodeBlock for a specified frame index.
  // Usage: codeBlockToken = $vm.codeBlockForFrame(0) // frame 0 is the top frame.
  // Usage: codeBlockToken = $vm.codeBlockForFrame() // implies frame 0 i.e. current frame.
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCodeBlockForFrame(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      unsigned frameNumber = 1;
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">!         JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
          if (!value.isUInt32())
              return JSValue::encode(jsUndefined());
  
          // We need to inc the frame number because the caller would consider
          // its own frame as frame 0. Hence, we need discount the frame for this
          // function.
          frameNumber = value.asUInt32() + 1;
      }
  
<span class="line-modified">!     CodeBlock* codeBlock = VMInspector::codeBlockForFrame(globalObject, callFrame, frameNumber);</span>
      if (codeBlock)
          return JSValue::encode(codeBlock);
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static CodeBlock* codeBlockFromArg(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     if (callFrame-&gt;argumentCount() &lt; 1)</span>
          return nullptr;
  
<span class="line-modified">!     JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
      CodeBlock* candidateCodeBlock = nullptr;
      if (value.isCell()) {
          JSFunction* func = jsDynamicCast&lt;JSFunction*&gt;(vm, value.asCell());
          if (func) {
              if (func-&gt;isHostFunction())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1477,11 ***</span>
                  candidateCodeBlock = func-&gt;jsExecutable()-&gt;eitherCodeBlock();
          } else
              candidateCodeBlock = static_cast&lt;CodeBlock*&gt;(value.asCell());
      }
  
<span class="line-modified">!     if (candidateCodeBlock &amp;&amp; VMInspector::isValidCodeBlock(exec, candidateCodeBlock))</span>
          return candidateCodeBlock;
  
      if (candidateCodeBlock)
          dataLog(&quot;Invalid codeBlock: &quot;, RawPointer(candidateCodeBlock), &quot; &quot;, value, &quot;\n&quot;);
      else
<span class="line-new-header">--- 1783,11 ---</span>
                  candidateCodeBlock = func-&gt;jsExecutable()-&gt;eitherCodeBlock();
          } else
              candidateCodeBlock = static_cast&lt;CodeBlock*&gt;(value.asCell());
      }
  
<span class="line-modified">!     if (candidateCodeBlock &amp;&amp; VMInspector::isValidCodeBlock(globalObject, candidateCodeBlock))</span>
          return candidateCodeBlock;
  
      if (candidateCodeBlock)
          dataLog(&quot;Invalid codeBlock: &quot;, RawPointer(candidateCodeBlock), &quot; &quot;, value, &quot;\n&quot;);
      else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1491,119 ***</span>
  
  // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(functionObj))
  // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(codeBlockToken))
  // Note: you cannot toString() a codeBlock because it&#39;s an internal object and not
  // a JS object. Hence, you cannot do string concatenation with it.
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCodeBlockFor(ExecState* exec)</span>
  {
<span class="line-modified">!     CodeBlock* codeBlock = codeBlockFromArg(exec);</span>
      WTF::StringPrintStream stream;
      if (codeBlock) {
          stream.print(*codeBlock);
<span class="line-modified">!         return JSValue::encode(jsString(exec-&gt;vm(), stream.toString()));</span>
      }
      return JSValue::encode(jsUndefined());
  }
  
  // Usage: $vm.dumpSourceFor(functionObj)
  // Usage: $vm.dumpSourceFor(codeBlockToken)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpSourceFor(ExecState* exec)</span>
  {
<span class="line-modified">!     CodeBlock* codeBlock = codeBlockFromArg(exec);</span>
      if (codeBlock)
          codeBlock-&gt;dumpSource();
      return JSValue::encode(jsUndefined());
  }
  
  // Usage: $vm.dumpBytecodeFor(functionObj)
  // Usage: $vm.dumpBytecodeFor(codeBlock)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpBytecodeFor(ExecState* exec)</span>
  {
<span class="line-modified">!     CodeBlock* codeBlock = codeBlockFromArg(exec);</span>
      if (codeBlock)
          codeBlock-&gt;dumpBytecode();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue doPrint(ExecState* exec, bool addLineFeed)</span>
  {
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(exec-&gt;vm());</span>
<span class="line-modified">!     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
<span class="line-modified">!         JSValue arg = exec-&gt;uncheckedArgument(i);</span>
          if (arg.isCell()
              &amp;&amp; !arg.isObject()
              &amp;&amp; !arg.isString()
              &amp;&amp; !arg.isBigInt()) {
              dataLog(arg);
              continue;
          }
<span class="line-modified">!         String argStr = exec-&gt;uncheckedArgument(i).toWTFString(exec);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          dataLog(argStr);
      }
      if (addLineFeed)
          dataLog(&quot;\n&quot;);
      return JSValue::encode(jsUndefined());
  }
  
  // Prints a series of comma separate strings without appending a newline.
  // Usage: $vm.dataLog(str1, str2, str3)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDataLog(ExecState* exec)</span>
  {
      const bool addLineFeed = false;
<span class="line-modified">!     return doPrint(exec, addLineFeed);</span>
  }
  
  // Prints a series of comma separate strings and appends a newline.
  // Usage: $vm.print(str1, str2, str3)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionPrint(ExecState* exec)</span>
  {
      const bool addLineFeed = true;
<span class="line-modified">!     return doPrint(exec, addLineFeed);</span>
  }
  
  // Dumps the current CallFrame.
  // Usage: $vm.dumpCallFrame()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpCallFrame(ExecState* exec)</span>
  {
      // When the callers call this function, they are expecting to dump their
      // own frame. So skip 1 for this frame.
<span class="line-modified">!     VMInspector::dumpCallFrame(exec, 1);</span>
      return JSValue::encode(jsUndefined());
  }
  
  // Dumps the JS stack.
  // Usage: $vm.printStack()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpStack(ExecState* exec)</span>
  {
      // When the callers call this function, they are expecting to dump the
      // stack starting their own frame. So skip 1 for this frame.
<span class="line-modified">!     VMInspector::dumpStack(exec, 1);</span>
      return JSValue::encode(jsUndefined());
  }
  
  // Dumps the current CallFrame.
  // Usage: $vm.dumpRegisters(N) // dump the registers of the Nth CallFrame.
  // Usage: $vm.dumpRegisters() // dump the registers of the current CallFrame.
  // FIXME: Currently, this function dumps the physical frame. We should make
  // it dump the logical frame (i.e. be able to dump inlined frames as well).
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpRegisters(ExecState* exec)</span>
  {
      unsigned requestedFrameIndex = 1;
<span class="line-modified">!     if (exec-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">!         JSValue value = exec-&gt;uncheckedArgument(0);</span>
          if (!value.isUInt32())
              return JSValue::encode(jsUndefined());
  
          // We need to inc the frame number because the caller would consider
          // its own frame as frame 0. Hence, we need discount the frame for this
          // function.
          requestedFrameIndex = value.asUInt32() + 1;
      }
  
      unsigned frameIndex = 0;
<span class="line-modified">!     exec-&gt;iterate([&amp;] (StackVisitor&amp; visitor) {</span>
          if (frameIndex++ != requestedFrameIndex)
              return StackVisitor::Continue;
          VMInspector::dumpRegisters(visitor-&gt;callFrame());
          return StackVisitor::Done;
      });
<span class="line-new-header">--- 1797,130 ---</span>
  
  // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(functionObj))
  // Usage: $vm.print(&quot;codeblock = &quot;, $vm.codeBlockFor(codeBlockToken))
  // Note: you cannot toString() a codeBlock because it&#39;s an internal object and not
  // a JS object. Hence, you cannot do string concatenation with it.
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCodeBlockFor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     CodeBlock* codeBlock = codeBlockFromArg(globalObject, callFrame);</span>
      WTF::StringPrintStream stream;
      if (codeBlock) {
          stream.print(*codeBlock);
<span class="line-modified">!         return JSValue::encode(jsString(globalObject-&gt;vm(), stream.toString()));</span>
      }
      return JSValue::encode(jsUndefined());
  }
  
  // Usage: $vm.dumpSourceFor(functionObj)
  // Usage: $vm.dumpSourceFor(codeBlockToken)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpSourceFor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     CodeBlock* codeBlock = codeBlockFromArg(globalObject, callFrame);</span>
      if (codeBlock)
          codeBlock-&gt;dumpSource();
      return JSValue::encode(jsUndefined());
  }
  
  // Usage: $vm.dumpBytecodeFor(functionObj)
  // Usage: $vm.dumpBytecodeFor(codeBlock)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpBytecodeFor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     CodeBlock* codeBlock = codeBlockFromArg(globalObject, callFrame);</span>
      if (codeBlock)
          codeBlock-&gt;dumpBytecode();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue doPrint(JSGlobalObject* globalObject, CallFrame* callFrame, bool addLineFeed)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-modified">!     auto scope = DECLARE_THROW_SCOPE(globalObject-&gt;vm());</span>
<span class="line-modified">!     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
<span class="line-added">+         JSValue arg = callFrame-&gt;uncheckedArgument(i);</span>
          if (arg.isCell()
              &amp;&amp; !arg.isObject()
              &amp;&amp; !arg.isString()
              &amp;&amp; !arg.isBigInt()) {
              dataLog(arg);
              continue;
          }
<span class="line-modified">!         String argStr = callFrame-&gt;uncheckedArgument(i).toWTFString(globalObject);</span>
          RETURN_IF_EXCEPTION(scope, encodedJSValue());
          dataLog(argStr);
      }
      if (addLineFeed)
          dataLog(&quot;\n&quot;);
      return JSValue::encode(jsUndefined());
  }
  
  // Prints a series of comma separate strings without appending a newline.
  // Usage: $vm.dataLog(str1, str2, str3)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDataLog(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      const bool addLineFeed = false;
<span class="line-modified">!     return doPrint(globalObject, callFrame, addLineFeed);</span>
  }
  
  // Prints a series of comma separate strings and appends a newline.
  // Usage: $vm.print(str1, str2, str3)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionPrint(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      const bool addLineFeed = true;
<span class="line-modified">!     return doPrint(globalObject, callFrame, addLineFeed);</span>
  }
  
  // Dumps the current CallFrame.
  // Usage: $vm.dumpCallFrame()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpCallFrame(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      // When the callers call this function, they are expecting to dump their
      // own frame. So skip 1 for this frame.
<span class="line-modified">!     VMInspector::dumpCallFrame(globalObject, callFrame, 1);</span>
      return JSValue::encode(jsUndefined());
  }
  
  // Dumps the JS stack.
  // Usage: $vm.printStack()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpStack(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      // When the callers call this function, they are expecting to dump the
      // stack starting their own frame. So skip 1 for this frame.
<span class="line-modified">!     VMInspector::dumpStack(globalObject, callFrame, 1);</span>
      return JSValue::encode(jsUndefined());
  }
  
  // Dumps the current CallFrame.
  // Usage: $vm.dumpRegisters(N) // dump the registers of the Nth CallFrame.
  // Usage: $vm.dumpRegisters() // dump the registers of the current CallFrame.
  // FIXME: Currently, this function dumps the physical frame. We should make
  // it dump the logical frame (i.e. be able to dump inlined frames as well).
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpRegisters(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      unsigned requestedFrameIndex = 1;
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &gt;= 1) {</span>
<span class="line-modified">!         JSValue value = callFrame-&gt;uncheckedArgument(0);</span>
          if (!value.isUInt32())
              return JSValue::encode(jsUndefined());
  
          // We need to inc the frame number because the caller would consider
          // its own frame as frame 0. Hence, we need discount the frame for this
          // function.
          requestedFrameIndex = value.asUInt32() + 1;
      }
  
      unsigned frameIndex = 0;
<span class="line-modified">!     callFrame-&gt;iterate(vm, [&amp;] (StackVisitor&amp; visitor) {</span>
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          if (frameIndex++ != requestedFrameIndex)
              return StackVisitor::Continue;
          VMInspector::dumpRegisters(visitor-&gt;callFrame());
          return StackVisitor::Done;
      });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1611,540 ***</span>
      return encodedJSUndefined();
  }
  
  // Dumps the internal memory layout of a JSCell.
  // Usage: $vm.dumpCell(cell)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpCell(ExecState* exec)</span>
  {
<span class="line-modified">!     JSValue value = exec-&gt;argument(0);</span>
      if (!value.isCell())
          return encodedJSUndefined();
  
      VMInspector::dumpCellMemory(value.asCell());
      return encodedJSUndefined();
  }
  
  // Gets the dataLog dump of the indexingMode of the passed value.
  // Usage: $vm.print(&quot;indexingMode = &quot; + $vm.indexingMode(jsValue))
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionIndexingMode(ExecState* exec)</span>
  {
<span class="line-modified">!     if (!exec-&gt;argument(0).isObject())</span>
          return encodedJSUndefined();
  
      WTF::StringPrintStream stream;
<span class="line-modified">!     stream.print(IndexingTypeDump(exec-&gt;uncheckedArgument(0).getObject()-&gt;indexingMode()));</span>
<span class="line-modified">!     return JSValue::encode(jsString(exec-&gt;vm(), stream.toString()));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionInlineCapacity(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     if (auto* object = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0)))</span>
          return JSValue::encode(jsNumber(object-&gt;structure(vm)-&gt;inlineCapacity()));
  
      return encodedJSUndefined();
  }
  
  // Gets the dataLog dump of a given JS value as a string.
  // Usage: $vm.print(&quot;value = &quot; + $vm.value(jsValue))
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionValue(ExecState* exec)</span>
  {
      WTF::StringPrintStream stream;
<span class="line-modified">!     for (unsigned i = 0; i &lt; exec-&gt;argumentCount(); ++i) {</span>
          if (i)
              stream.print(&quot;, &quot;);
<span class="line-modified">!         stream.print(exec-&gt;uncheckedArgument(i));</span>
      }
  
<span class="line-modified">!     return JSValue::encode(jsString(exec-&gt;vm(), stream.toString()));</span>
  }
  
  // Gets the pid of the current process.
  // Usage: $vm.print(&quot;pid = &quot; + $vm.getpid())
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGetPID(ExecState*)</span>
  {
      return JSValue::encode(jsNumber(getCurrentProcessID()));
  }
  
  // Make the globalObject have a bad time. Does nothing if the object is not a JSGlobalObject.
  // Usage: $vm.haveABadTime(globalObject)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionHaveABadTime(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     JSValue objValue = exec-&gt;argument(0);</span>
      if (!objValue.isObject())
          return JSValue::encode(jsBoolean(false));
  
      JSObject* obj = asObject(objValue.asCell());
<span class="line-modified">!     JSGlobalObject* globalObject = jsDynamicCast&lt;JSGlobalObject*&gt;(vm, obj);</span>
<span class="line-modified">!     if (!globalObject)</span>
          JSValue::encode(jsBoolean(false));
  
<span class="line-modified">!     globalObject-&gt;haveABadTime(vm);</span>
      return JSValue::encode(jsBoolean(true));
  }
  
  // Checks if the object (or its global if the object is not a global) is having a bad time.
  // Usage: $vm.isHavingABadTime(obj)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionIsHavingABadTime(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     JSValue objValue = exec-&gt;argument(0);</span>
      if (!objValue.isObject())
          return JSValue::encode(jsUndefined());
  
      JSObject* obj = asObject(objValue.asCell());
<span class="line-modified">!     JSGlobalObject* globalObject = jsDynamicCast&lt;JSGlobalObject*&gt;(vm, obj);</span>
<span class="line-modified">!     if (globalObject)</span>
<span class="line-modified">!         JSValue::encode(jsBoolean(globalObject-&gt;isHavingABadTime()));</span>
  
<span class="line-modified">!     globalObject = obj-&gt;globalObject();</span>
<span class="line-modified">!     if (!globalObject)</span>
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     return JSValue::encode(jsBoolean(globalObject-&gt;isHavingABadTime()));</span>
  }
  
  // Creates a new global object.
  // Usage: $vm.createGlobalObject()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     JSGlobalObject* globalObject = JSGlobalObject::create(vm, JSGlobalObject::createStructure(vm, jsNull()));</span>
<span class="line-removed">-     return JSValue::encode(globalObject);</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateProxy(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     JSValue target = exec-&gt;argument(0);</span>
      if (!target.isObject())
          return JSValue::encode(jsUndefined());
      JSObject* jsTarget = asObject(target.asCell());
<span class="line-modified">!     Structure* structure = JSProxy::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsTarget-&gt;getPrototypeDirect(vm), ImpureProxyType);</span>
      JSProxy* proxy = JSProxy::create(vm, structure, jsTarget);
      return JSValue::encode(proxy);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateRuntimeArray(ExecState* exec)</span>
  {
<span class="line-modified">!     JSLockHolder lock(exec);</span>
<span class="line-modified">!     RuntimeArray* array = RuntimeArray::create(exec);</span>
      return JSValue::encode(array);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateNullRopeString(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
      return JSValue::encode(JSRopeString::createNullForTesting(vm));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateImpureGetter(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     JSValue target = exec-&gt;argument(0);</span>
      JSObject* delegate = nullptr;
      if (target.isObject())
          delegate = asObject(target.asCell());
<span class="line-modified">!     Structure* structure = ImpureGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
      ImpureGetter* result = ImpureGetter::create(vm, structure, delegate);
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateCustomGetterObject(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     Structure* structure = CustomGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
      CustomGetter* result = CustomGetter::create(vm, structure);
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITNodeObject(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     Structure* structure = DOMJITNode::createStructure(vm, exec-&gt;lexicalGlobalObject(), DOMJITGetter::create(vm, DOMJITGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull())));</span>
      DOMJITNode* result = DOMJITNode::create(vm, structure);
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterObject(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     Structure* structure = DOMJITGetter::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
      DOMJITGetter* result = DOMJITGetter::create(vm, structure);
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterComplexObject(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     Structure* structure = DOMJITGetterComplex::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
<span class="line-modified">!     DOMJITGetterComplex* result = DOMJITGetterComplex::create(vm, exec-&gt;lexicalGlobalObject(), structure);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITFunctionObject(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     Structure* structure = DOMJITFunctionObject::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
<span class="line-modified">!     DOMJITFunctionObject* result = DOMJITFunctionObject::create(vm, exec-&gt;lexicalGlobalObject(), structure);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITCheckSubClassObject(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     Structure* structure = DOMJITCheckSubClassObject::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
<span class="line-modified">!     DOMJITCheckSubClassObject* result = DOMJITCheckSubClassObject::create(vm, exec-&gt;lexicalGlobalObject(), structure);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterBaseJSObject(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     Structure* structure = DOMJITGetterBaseJSObject::createStructure(vm, exec-&gt;lexicalGlobalObject(), jsNull());</span>
      DOMJITGetterBaseJSObject* result = DOMJITGetterBaseJSObject::create(vm, structure);
      return JSValue::encode(result);
  }
  
  #if ENABLE(WEBASSEMBLY)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateWasmStreamingParser(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     return JSValue::encode(WasmStreamingParser::create(vm, exec-&gt;lexicalGlobalObject()));</span>
  }
  #endif
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionSetImpureGetterDelegate(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue base = exec-&gt;argument(0);</span>
      if (!base.isObject())
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     JSValue delegate = exec-&gt;argument(1);</span>
      if (!delegate.isObject())
          return JSValue::encode(jsUndefined());
      ImpureGetter* impureGetter = jsDynamicCast&lt;ImpureGetter*&gt;(vm, asObject(base.asCell()));
      if (UNLIKELY(!impureGetter)) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;argument is not an ImpureGetter&quot;_s);</span>
          return encodedJSValue();
      }
      impureGetter-&gt;setDelegate(vm, asObject(delegate.asCell()));
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateBuiltin(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 1 || !exec-&gt;argument(0).isString())</span>
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     String functionText = asString(exec-&gt;argument(0))-&gt;value(exec);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     const SourceCode&amp; source = makeSource(functionText, { });</span>
<span class="line-modified">!     JSFunction* func = JSFunction::create(vm, createBuiltinExecutable(vm, source, Identifier::fromString(vm, &quot;foo&quot;), ConstructorKind::None, ConstructAbility::CannotConstruct)-&gt;link(vm, nullptr, source), exec-&gt;lexicalGlobalObject());</span>
  
      return JSValue::encode(func);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGetPrivateProperty(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (exec-&gt;argumentCount() &lt; 2 || !exec-&gt;argument(1).isString())</span>
          return encodedJSUndefined();
  
<span class="line-modified">!     String str = asString(exec-&gt;argument(1))-&gt;value(exec);</span>
  
      SymbolImpl* symbol = vm.propertyNames-&gt;lookUpPrivateName(Identifier::fromString(vm, str));
      if (!symbol)
<span class="line-modified">!         return throwVMError(exec, scope, &quot;Unknown private name.&quot;);</span>
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(exec-&gt;argument(0).get(exec, symbol)));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateRoot(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     return JSValue::encode(Root::create(vm, exec-&gt;lexicalGlobalObject()));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateElement(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Root* root = jsDynamicCast&lt;Root*&gt;(vm, exec-&gt;argument(0));</span>
      if (!root)
<span class="line-modified">!         return JSValue::encode(throwException(exec, scope, createError(exec, &quot;Cannot create Element without a Root.&quot;_s)));</span>
<span class="line-modified">!     return JSValue::encode(Element::create(vm, exec-&gt;lexicalGlobalObject(), root));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGetElement(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     Root* root = jsDynamicCast&lt;Root*&gt;(vm, exec-&gt;argument(0));</span>
      if (!root)
          return JSValue::encode(jsUndefined());
      Element* result = root-&gt;element();
      return JSValue::encode(result ? result : jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateSimpleObject(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     return JSValue::encode(SimpleObject::create(vm, exec-&gt;lexicalGlobalObject()));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGetHiddenValue(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     SimpleObject* simpleObject = jsDynamicCast&lt;SimpleObject*&gt;(vm, exec-&gt;argument(0));</span>
      if (UNLIKELY(!simpleObject)) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Invalid use of getHiddenValue test function&quot;_s);</span>
          return encodedJSValue();
      }
      return JSValue::encode(simpleObject-&gt;hiddenValue());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionSetHiddenValue(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      JSLockHolder lock(vm);
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     SimpleObject* simpleObject = jsDynamicCast&lt;SimpleObject*&gt;(vm, exec-&gt;argument(0));</span>
      if (UNLIKELY(!simpleObject)) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Invalid use of setHiddenValue test function&quot;_s);</span>
          return encodedJSValue();
      }
<span class="line-modified">!     JSValue value = exec-&gt;argument(1);</span>
      simpleObject-&gt;setHiddenValue(vm, value);
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionShadowChickenFunctionsOnStack(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (auto* shadowChicken = vm.shadowChicken()) {
          scope.release();
<span class="line-modified">!         return JSValue::encode(shadowChicken-&gt;functionsOnStack(exec));</span>
      }
  
<span class="line-modified">!     JSArray* result = constructEmptyArray(exec, 0);</span>
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!     StackVisitor::visit(exec, &amp;vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {</span>
          if (visitor-&gt;isInlinedFrame())
              return StackVisitor::Continue;
          if (visitor-&gt;isWasmFrame())
              return StackVisitor::Continue;
<span class="line-modified">!         result-&gt;push(exec, jsCast&lt;JSObject*&gt;(visitor-&gt;callee().asCell()));</span>
          scope.releaseAssertNoException(); // This function is only called from tests.
          return StackVisitor::Continue;
      });
      RETURN_IF_EXCEPTION(scope, { });
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionSetGlobalConstRedeclarationShouldNotThrow(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      vm.setGlobalConstRedeclarationShouldThrow(false);
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionFindTypeForExpression(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      RELEASE_ASSERT(vm.typeProfiler());
      vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;jsc Testing API: functionFindTypeForExpression&quot;_s);
  
<span class="line-modified">!     JSValue functionValue = exec-&gt;argument(0);</span>
      RELEASE_ASSERT(functionValue.isFunction(vm));
      FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
  
<span class="line-modified">!     RELEASE_ASSERT(exec-&gt;argument(1).isString());</span>
<span class="line-modified">!     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);</span>
      String sourceCodeText = executable-&gt;source().view().toString();
      unsigned offset = static_cast&lt;unsigned&gt;(sourceCodeText.find(substring) + executable-&gt;source().startOffset());
  
      String jsonString = vm.typeProfiler()-&gt;typeInformationForExpressionAtOffset(TypeProfilerSearchDescriptorNormal, offset, executable-&gt;sourceID(), vm);
<span class="line-modified">!     return JSValue::encode(JSONParse(exec, jsonString));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionReturnTypeFor(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      RELEASE_ASSERT(vm.typeProfiler());
      vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;jsc Testing API: functionReturnTypeFor&quot;_s);
  
<span class="line-modified">!     JSValue functionValue = exec-&gt;argument(0);</span>
      RELEASE_ASSERT(functionValue.isFunction(vm));
      FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
  
      unsigned offset = executable-&gt;typeProfilingStartOffset(vm);
      String jsonString = vm.typeProfiler()-&gt;typeInformationForExpressionAtOffset(TypeProfilerSearchDescriptorFunctionReturn, offset, executable-&gt;sourceID(), vm);
<span class="line-modified">!     return JSValue::encode(JSONParse(exec, jsonString));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionFlattenDictionaryObject(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSValue value = exec-&gt;argument(0);</span>
      RELEASE_ASSERT(value.isObject() &amp;&amp; value.getObject()-&gt;structure()-&gt;isDictionary());
      value.getObject()-&gt;flattenDictionaryObject(vm);
      return encodedJSUndefined();
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpBasicBlockExecutionRanges(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      RELEASE_ASSERT(vm.controlFlowProfiler());
      vm.controlFlowProfiler()-&gt;dumpData();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionHasBasicBlockExecuted(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      RELEASE_ASSERT(vm.controlFlowProfiler());
  
<span class="line-modified">!     JSValue functionValue = exec-&gt;argument(0);</span>
      RELEASE_ASSERT(functionValue.isFunction(vm));
      FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
  
<span class="line-modified">!     RELEASE_ASSERT(exec-&gt;argument(1).isString());</span>
<span class="line-modified">!     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);</span>
      String sourceCodeText = executable-&gt;source().view().toString();
      RELEASE_ASSERT(sourceCodeText.contains(substring));
      int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
  
      bool hasExecuted = vm.controlFlowProfiler()-&gt;hasBasicBlockAtTextOffsetBeenExecuted(offset, executable-&gt;sourceID(), vm);
      return JSValue::encode(jsBoolean(hasExecuted));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionBasicBlockExecutionCount(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      RELEASE_ASSERT(vm.controlFlowProfiler());
  
<span class="line-modified">!     JSValue functionValue = exec-&gt;argument(0);</span>
      RELEASE_ASSERT(functionValue.isFunction(vm));
      FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
  
<span class="line-modified">!     RELEASE_ASSERT(exec-&gt;argument(1).isString());</span>
<span class="line-modified">!     String substring = asString(exec-&gt;argument(1))-&gt;value(exec);</span>
      String sourceCodeText = executable-&gt;source().view().toString();
      RELEASE_ASSERT(sourceCodeText.contains(substring));
      int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
  
      size_t executionCount = vm.controlFlowProfiler()-&gt;basicBlockExecutionCountAtTextOffset(offset, executable-&gt;sourceID(), vm);
      return JSValue::encode(JSValue(executionCount));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionEnableExceptionFuzz(ExecState*)</span>
  {
      Options::useExceptionFuzz() = true;
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue changeDebuggerModeWhenIdle(ExecState* exec, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode)</span>
  {
<span class="line-modified">!     bool newDebuggerMode = codeGenerationMode.contains(CodeGenerationMode::Debugger);</span>
<span class="line-modified">!     if (Options::forceDebuggerBytecodeGeneration() == newDebuggerMode)</span>
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      vm-&gt;whenIdle([=] () {
<span class="line-modified">!         Options::forceDebuggerBytecodeGeneration() = newDebuggerMode;</span>
<span class="line-modified">!         vm-&gt;deleteAllCode(PreventCollectionAndDeleteAllCode);</span>
<span class="line-modified">!         if (newDebuggerMode)</span>
<span class="line-modified">!             vm-&gt;ensureShadowChicken();</span>
      });
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionEnableDebuggerModeWhenIdle(ExecState* exec)</span>
  {
<span class="line-modified">!     return changeDebuggerModeWhenIdle(exec, { CodeGenerationMode::Debugger });</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDisableDebuggerModeWhenIdle(ExecState* exec)</span>
  {
<span class="line-modified">!     return changeDebuggerModeWhenIdle(exec, { });</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDeleteAllCodeWhenIdle(ExecState* exec)</span>
  {
<span class="line-modified">!     VM* vm = &amp;exec-&gt;vm();</span>
      vm-&gt;whenIdle([=] () {
          vm-&gt;deleteAllCode(PreventCollectionAndDeleteAllCode);
      });
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGlobalObjectCount(ExecState* exec)</span>
  {
<span class="line-modified">!     return JSValue::encode(jsNumber(exec-&gt;vm().heap.globalObjectCount()));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGlobalObjectForObject(ExecState* exec)</span>
  {
<span class="line-modified">!     JSValue value = exec-&gt;argument(0);</span>
      RELEASE_ASSERT(value.isObject());
<span class="line-modified">!     JSGlobalObject* globalObject = jsCast&lt;JSObject*&gt;(value)-&gt;globalObject(exec-&gt;vm());</span>
<span class="line-modified">!     RELEASE_ASSERT(globalObject);</span>
<span class="line-modified">!     return JSValue::encode(globalObject);</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGetGetterSetter(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue value = exec-&gt;argument(0);</span>
      if (!value.isObject())
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     JSValue property = exec-&gt;argument(1);</span>
      if (!property.isString())
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     auto propertyName = asString(property)-&gt;toIdentifier(exec);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      PropertySlot slot(value, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!     value.getPropertySlot(exec, propertyName, slot);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      JSValue result;
      if (slot.isCacheableGetter())
          result = slot.getterSetter();
<span class="line-new-header">--- 1928,755 ---</span>
      return encodedJSUndefined();
  }
  
  // Dumps the internal memory layout of a JSCell.
  // Usage: $vm.dumpCell(cell)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpCell(JSGlobalObject*, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     JSValue value = callFrame-&gt;argument(0);</span>
      if (!value.isCell())
          return encodedJSUndefined();
  
      VMInspector::dumpCellMemory(value.asCell());
      return encodedJSUndefined();
  }
  
  // Gets the dataLog dump of the indexingMode of the passed value.
  // Usage: $vm.print(&quot;indexingMode = &quot; + $vm.indexingMode(jsValue))
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionIndexingMode(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     if (!callFrame-&gt;argument(0).isObject())</span>
          return encodedJSUndefined();
  
      WTF::StringPrintStream stream;
<span class="line-modified">!     stream.print(IndexingTypeDump(callFrame-&gt;uncheckedArgument(0).getObject()-&gt;indexingMode()));</span>
<span class="line-modified">!     return JSValue::encode(jsString(globalObject-&gt;vm(), stream.toString()));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionInlineCapacity(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     if (auto* object = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(0)))</span>
          return JSValue::encode(jsNumber(object-&gt;structure(vm)-&gt;inlineCapacity()));
  
      return encodedJSUndefined();
  }
  
  // Gets the dataLog dump of a given JS value as a string.
  // Usage: $vm.print(&quot;value = &quot; + $vm.value(jsValue))
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionValue(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      WTF::StringPrintStream stream;
<span class="line-modified">!     for (unsigned i = 0; i &lt; callFrame-&gt;argumentCount(); ++i) {</span>
          if (i)
              stream.print(&quot;, &quot;);
<span class="line-modified">!         stream.print(callFrame-&gt;uncheckedArgument(i));</span>
      }
  
<span class="line-modified">!     return JSValue::encode(jsString(globalObject-&gt;vm(), stream.toString()));</span>
  }
  
  // Gets the pid of the current process.
  // Usage: $vm.print(&quot;pid = &quot; + $vm.getpid())
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGetPID(JSGlobalObject*, CallFrame*)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      return JSValue::encode(jsNumber(getCurrentProcessID()));
  }
  
  // Make the globalObject have a bad time. Does nothing if the object is not a JSGlobalObject.
  // Usage: $vm.haveABadTime(globalObject)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionHaveABadTime(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     JSValue objValue = callFrame-&gt;argument(0);</span>
      if (!objValue.isObject())
          return JSValue::encode(jsBoolean(false));
  
      JSObject* obj = asObject(objValue.asCell());
<span class="line-modified">!     JSGlobalObject* target = jsDynamicCast&lt;JSGlobalObject*&gt;(vm, obj);</span>
<span class="line-modified">!     if (!target)</span>
          JSValue::encode(jsBoolean(false));
  
<span class="line-modified">!     target-&gt;haveABadTime(vm);</span>
      return JSValue::encode(jsBoolean(true));
  }
  
  // Checks if the object (or its global if the object is not a global) is having a bad time.
  // Usage: $vm.isHavingABadTime(obj)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionIsHavingABadTime(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     JSValue objValue = callFrame-&gt;argument(0);</span>
      if (!objValue.isObject())
          return JSValue::encode(jsUndefined());
  
      JSObject* obj = asObject(objValue.asCell());
<span class="line-modified">!     JSGlobalObject* target = jsDynamicCast&lt;JSGlobalObject*&gt;(vm, obj);</span>
<span class="line-modified">!     if (target)</span>
<span class="line-modified">!         JSValue::encode(jsBoolean(target-&gt;isHavingABadTime()));</span>
  
<span class="line-modified">!     target= obj-&gt;globalObject();</span>
<span class="line-modified">!     if (!target)</span>
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     return JSValue::encode(jsBoolean(target-&gt;isHavingABadTime()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Calls the specified test function after adjusting the stack to have the specified</span>
<span class="line-added">+ // remaining size from the end of the physical stack.</span>
<span class="line-added">+ // Usage: $vm.callWithStackSize(funcToCall, desiredStackSize)</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // This function will only work in test configurations, specifically, only if JSC</span>
<span class="line-added">+ // options are not frozen. For the jsc shell, the --disableOptionsFreezingForTesting</span>
<span class="line-added">+ // argument needs to be passed in on the command line.</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(MASM_PROBE)</span>
<span class="line-added">+ static void callWithStackSizeProbeFunction(Probe::State* state)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     JSGlobalObject* globalObject = bitwise_cast&lt;JSGlobalObject*&gt;(state-&gt;arg);</span>
<span class="line-added">+     JSFunction* function = bitwise_cast&lt;JSFunction*&gt;(state-&gt;probeFunction);</span>
<span class="line-added">+     state-&gt;initializeStackFunction = nullptr;</span>
<span class="line-added">+     state-&gt;initializeStackArg = nullptr;</span>
<span class="line-added">+ </span>
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+ </span>
<span class="line-added">+     CallData callData;</span>
<span class="line-added">+     CallType callType = getCallData(vm, function, callData);</span>
<span class="line-added">+     MarkedArgumentBuffer args;</span>
<span class="line-added">+     call(globalObject, function, callType, callData, jsUndefined(), args);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ #endif // ENABLE(MASM_PROBE)</span>
<span class="line-added">+ </span>
<span class="line-added">+ SUPPRESS_ASAN</span>
<span class="line-added">+ static EncodedJSValue JSC_HOST_CALL functionCallWithStackSize(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     JSLockHolder lock(vm);</span>
<span class="line-added">+     auto throwScope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if OS(DARWIN) &amp;&amp; CPU(X86_64)</span>
<span class="line-added">+     constexpr bool isSupportedByPlatform = true;</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     constexpr bool isSupportedByPlatform = false;</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!isSupportedByPlatform)</span>
<span class="line-added">+         return throwVMError(globalObject, throwScope, &quot;Not supported for this platform&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ENABLE(MASM_PROBE)</span>
<span class="line-added">+     if (g_jscConfig.isPermanentlyFrozen || !g_jscConfig.disabledFreezingForTesting)</span>
<span class="line-added">+         return throwVMError(globalObject, throwScope, &quot;Options are frozen&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (callFrame-&gt;argumentCount() &lt; 2)</span>
<span class="line-added">+         return throwVMError(globalObject, throwScope, &quot;Invalid number of arguments&quot;);</span>
<span class="line-added">+     JSValue arg0 = callFrame-&gt;argument(0);</span>
<span class="line-added">+     JSValue arg1 = callFrame-&gt;argument(1);</span>
<span class="line-added">+     if (!arg0.isFunction(vm))</span>
<span class="line-added">+         return throwVMError(globalObject, throwScope, &quot;arg0 should be a function&quot;);</span>
<span class="line-added">+     if (!arg1.isNumber())</span>
<span class="line-added">+         return throwVMError(globalObject, throwScope, &quot;arg1 should be a number&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSFunction* function = jsCast&lt;JSFunction*&gt;(arg0);</span>
<span class="line-added">+     size_t desiredStackSize = arg1.asNumber();</span>
<span class="line-added">+ </span>
<span class="line-added">+     const StackBounds&amp; bounds = Thread::current().stack();</span>
<span class="line-added">+     uint8_t* currentStackPosition = bitwise_cast&lt;uint8_t*&gt;(currentStackPointer());</span>
<span class="line-added">+     uint8_t* end = bitwise_cast&lt;uint8_t*&gt;(bounds.end());</span>
<span class="line-added">+     uint8_t* desiredStart = end + desiredStackSize;</span>
<span class="line-added">+     if (desiredStart &gt;= currentStackPosition)</span>
<span class="line-added">+         return throwVMError(globalObject, throwScope, &quot;Unable to setup desired stack size&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSDollarVMHelper helper(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     unsigned originalMaxPerThreadStackUsage = Options::maxPerThreadStackUsage();</span>
<span class="line-added">+     void* originalVMSoftStackLimit = vm.softStackLimit();</span>
<span class="line-added">+     void* originalVMStackLimit = vm.stackLimit();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // This is a hack to make the VM think it&#39;s stack limits are near the end</span>
<span class="line-added">+     // of the physical stack.</span>
<span class="line-added">+     uint8_t* vmStackStart = bitwise_cast&lt;uint8_t*&gt;(vm.stackPointerAtVMEntry());</span>
<span class="line-added">+     uint8_t* vmStackEnd = vmStackStart - originalMaxPerThreadStackUsage;</span>
<span class="line-added">+     ptrdiff_t sizeDiff = vmStackEnd - end;</span>
<span class="line-added">+     RELEASE_ASSERT(sizeDiff &gt;= 0);</span>
<span class="line-added">+     RELEASE_ASSERT(sizeDiff &lt; UINT_MAX);</span>
<span class="line-added">+ </span>
<span class="line-added">+     Options::maxPerThreadStackUsage() = originalMaxPerThreadStackUsage + sizeDiff;</span>
<span class="line-added">+     helper.updateVMStackLimits();</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if OS(DARWIN) &amp;&amp; CPU(X86_64)</span>
<span class="line-added">+     __asm__ volatile (</span>
<span class="line-added">+         &quot;subq %[sizeDiff], %%rsp&quot; &quot;\n&quot;</span>
<span class="line-added">+         &quot;pushq %%rax&quot; &quot;\n&quot;</span>
<span class="line-added">+         &quot;pushq %%rcx&quot; &quot;\n&quot;</span>
<span class="line-added">+         &quot;pushq %%rdx&quot; &quot;\n&quot;</span>
<span class="line-added">+         &quot;pushq %%rbx&quot; &quot;\n&quot;</span>
<span class="line-added">+         &quot;callq *%%rax&quot; &quot;\n&quot;</span>
<span class="line-added">+         &quot;addq %[sizeDiff], %%rsp&quot; &quot;\n&quot;</span>
<span class="line-added">+         :</span>
<span class="line-added">+         : &quot;a&quot; (ctiMasmProbeTrampoline)</span>
<span class="line-added">+         , &quot;c&quot; (callWithStackSizeProbeFunction)</span>
<span class="line-added">+         , &quot;d&quot; (function)</span>
<span class="line-added">+         , &quot;b&quot; (globalObject)</span>
<span class="line-added">+         , [sizeDiff] &quot;rm&quot; (sizeDiff)</span>
<span class="line-added">+         : &quot;memory&quot;</span>
<span class="line-added">+     );</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     UNUSED_PARAM(function);</span>
<span class="line-added">+ #if !COMPILER(MSVC)</span>
<span class="line-added">+     UNUSED_PARAM(callWithStackSizeProbeFunction);</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ #endif // OS(DARWIN) &amp;&amp; CPU(X86_64)</span>
<span class="line-added">+ </span>
<span class="line-added">+     Options::maxPerThreadStackUsage() = originalMaxPerThreadStackUsage;</span>
<span class="line-added">+     helper.updateVMStackLimits();</span>
<span class="line-added">+     RELEASE_ASSERT(vm.softStackLimit() == originalVMSoftStackLimit);</span>
<span class="line-added">+     RELEASE_ASSERT(vm.stackLimit() == originalVMStackLimit);</span>
<span class="line-added">+ </span>
<span class="line-added">+     throwScope.release();</span>
<span class="line-added">+     return encodedJSUndefined();</span>
<span class="line-added">+ </span>
<span class="line-added">+ #else // not ENABLE(MASM_PROBE)</span>
<span class="line-added">+     UNUSED_PARAM(callFrame);</span>
<span class="line-added">+     return throwVMError(globalObject, throwScope, &quot;Not supported for this platform&quot;);</span>
<span class="line-added">+ #endif // ENABLE(MASM_PROBE)</span>
  }
  
  // Creates a new global object.
  // Usage: $vm.createGlobalObject()
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateGlobalObject(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     return JSValue::encode(JSGlobalObject::create(vm, JSGlobalObject::createStructure(vm, jsNull())));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateProxy(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     JSValue target = callFrame-&gt;argument(0);</span>
      if (!target.isObject())
          return JSValue::encode(jsUndefined());
      JSObject* jsTarget = asObject(target.asCell());
<span class="line-modified">!     Structure* structure = JSProxy::createStructure(vm, globalObject, jsTarget-&gt;getPrototypeDirect(vm), ImpureProxyType);</span>
      JSProxy* proxy = JSProxy::create(vm, structure, jsTarget);
      return JSValue::encode(proxy);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateRuntimeArray(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-modified">!     JSLockHolder lock(globalObject);</span>
<span class="line-added">+     RuntimeArray* array = RuntimeArray::create(globalObject, callFrame);</span>
      return JSValue::encode(array);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateNullRopeString(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
      return JSValue::encode(JSRopeString::createNullForTesting(vm));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateImpureGetter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     JSValue target = callFrame-&gt;argument(0);</span>
      JSObject* delegate = nullptr;
      if (target.isObject())
          delegate = asObject(target.asCell());
<span class="line-modified">!     Structure* structure = ImpureGetter::createStructure(vm, globalObject, jsNull());</span>
      ImpureGetter* result = ImpureGetter::create(vm, structure, delegate);
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateCustomGetterObject(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     Structure* structure = CustomGetter::createStructure(vm, globalObject, jsNull());</span>
      CustomGetter* result = CustomGetter::create(vm, structure);
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITNodeObject(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     Structure* structure = DOMJITNode::createStructure(vm, globalObject, DOMJITGetter::create(vm, DOMJITGetter::createStructure(vm, globalObject, jsNull())));</span>
      DOMJITNode* result = DOMJITNode::create(vm, structure);
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterObject(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     Structure* structure = DOMJITGetter::createStructure(vm, globalObject, jsNull());</span>
      DOMJITGetter* result = DOMJITGetter::create(vm, structure);
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterComplexObject(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     Structure* structure = DOMJITGetterComplex::createStructure(vm, globalObject, jsNull());</span>
<span class="line-modified">!     DOMJITGetterComplex* result = DOMJITGetterComplex::create(vm, globalObject, structure);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITFunctionObject(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     Structure* structure = DOMJITFunctionObject::createStructure(vm, globalObject, jsNull());</span>
<span class="line-modified">!     DOMJITFunctionObject* result = DOMJITFunctionObject::create(vm, globalObject, structure);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITCheckSubClassObject(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     Structure* structure = DOMJITCheckSubClassObject::createStructure(vm, globalObject, jsNull());</span>
<span class="line-modified">!     DOMJITCheckSubClassObject* result = DOMJITCheckSubClassObject::create(vm, globalObject, structure);</span>
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateDOMJITGetterBaseJSObject(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     Structure* structure = DOMJITGetterBaseJSObject::createStructure(vm, globalObject, jsNull());</span>
      DOMJITGetterBaseJSObject* result = DOMJITGetterBaseJSObject::create(vm, structure);
      return JSValue::encode(result);
  }
  
  #if ENABLE(WEBASSEMBLY)
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateWasmStreamingParser(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     return JSValue::encode(WasmStreamingParser::create(vm, globalObject));</span>
  }
  #endif
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateStaticCustomAccessor(JSGlobalObject* globalObject, CallFrame*)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     JSLockHolder lock(vm);</span>
<span class="line-added">+     Structure* structure = StaticCustomAccessor::createStructure(vm, globalObject, jsNull());</span>
<span class="line-added">+     auto* result = StaticCustomAccessor::create(vm, structure);</span>
<span class="line-added">+     return JSValue::encode(result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static EncodedJSValue JSC_HOST_CALL functionCreateObjectDoingSideEffectPutWithoutCorrectSlotStatus(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     JSLockHolder lock(vm);</span>
<span class="line-added">+ </span>
<span class="line-added">+     auto* dollarVM = jsDynamicCast&lt;JSDollarVM*&gt;(vm, callFrame-&gt;thisValue());</span>
<span class="line-added">+     RELEASE_ASSERT(dollarVM);</span>
<span class="line-added">+     auto* result = ObjectDoingSideEffectPutWithoutCorrectSlotStatus::create(vm, dollarVM-&gt;objectDoingSideEffectPutWithoutCorrectSlotStatusStructure());</span>
<span class="line-added">+     return JSValue::encode(result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static EncodedJSValue JSC_HOST_CALL functionSetImpureGetterDelegate(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue base = callFrame-&gt;argument(0);</span>
      if (!base.isObject())
          return JSValue::encode(jsUndefined());
<span class="line-modified">!     JSValue delegate = callFrame-&gt;argument(1);</span>
      if (!delegate.isObject())
          return JSValue::encode(jsUndefined());
      ImpureGetter* impureGetter = jsDynamicCast&lt;ImpureGetter*&gt;(vm, asObject(base.asCell()));
      if (UNLIKELY(!impureGetter)) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;argument is not an ImpureGetter&quot;_s);</span>
          return encodedJSValue();
      }
      impureGetter-&gt;setDelegate(vm, asObject(delegate.asCell()));
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateBuiltin(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 1 || !callFrame-&gt;argument(0).isString())</span>
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     String functionText = asString(callFrame-&gt;argument(0))-&gt;value(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, encodedJSValue());
  
<span class="line-modified">!     SourceCode source = makeSource(functionText, { });</span>
<span class="line-modified">!     JSFunction* func = JSFunction::create(vm, createBuiltinExecutable(vm, source, Identifier::fromString(vm, &quot;foo&quot;), ConstructorKind::None, ConstructAbility::CannotConstruct)-&gt;link(vm, nullptr, source), globalObject);</span>
  
      return JSValue::encode(func);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGetPrivateProperty(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     if (callFrame-&gt;argumentCount() &lt; 2 || !callFrame-&gt;argument(1).isString())</span>
          return encodedJSUndefined();
  
<span class="line-modified">!     String str = asString(callFrame-&gt;argument(1))-&gt;value(globalObject);</span>
  
      SymbolImpl* symbol = vm.propertyNames-&gt;lookUpPrivateName(Identifier::fromString(vm, str));
      if (!symbol)
<span class="line-modified">!         return throwVMError(globalObject, scope, &quot;Unknown private name.&quot;);</span>
  
<span class="line-modified">!     RELEASE_AND_RETURN(scope, JSValue::encode(callFrame-&gt;argument(0).get(globalObject, symbol)));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateRoot(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     return JSValue::encode(Root::create(vm, globalObject));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateElement(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     Root* root = jsDynamicCast&lt;Root*&gt;(vm, callFrame-&gt;argument(0));</span>
      if (!root)
<span class="line-modified">!         return JSValue::encode(throwException(globalObject, scope, createError(globalObject, &quot;Cannot create Element without a Root.&quot;_s)));</span>
<span class="line-modified">!     return JSValue::encode(Element::create(vm, globalObject, root));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGetElement(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     Root* root = jsDynamicCast&lt;Root*&gt;(vm, callFrame-&gt;argument(0));</span>
      if (!root)
          return JSValue::encode(jsUndefined());
      Element* result = root-&gt;element();
      return JSValue::encode(result ? result : jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateSimpleObject(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
<span class="line-modified">!     return JSValue::encode(SimpleObject::create(vm, globalObject));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGetHiddenValue(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     SimpleObject* simpleObject = jsDynamicCast&lt;SimpleObject*&gt;(vm, callFrame-&gt;argument(0));</span>
      if (UNLIKELY(!simpleObject)) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Invalid use of getHiddenValue test function&quot;_s);</span>
          return encodedJSValue();
      }
      return JSValue::encode(simpleObject-&gt;hiddenValue());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionSetHiddenValue(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      JSLockHolder lock(vm);
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     SimpleObject* simpleObject = jsDynamicCast&lt;SimpleObject*&gt;(vm, callFrame-&gt;argument(0));</span>
      if (UNLIKELY(!simpleObject)) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Invalid use of setHiddenValue test function&quot;_s);</span>
          return encodedJSValue();
      }
<span class="line-modified">!     JSValue value = callFrame-&gt;argument(1);</span>
      simpleObject-&gt;setHiddenValue(vm, value);
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionShadowChickenFunctionsOnStack(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
      if (auto* shadowChicken = vm.shadowChicken()) {
          scope.release();
<span class="line-modified">!         return JSValue::encode(shadowChicken-&gt;functionsOnStack(globalObject, callFrame));</span>
      }
  
<span class="line-modified">!     JSArray* result = constructEmptyArray(globalObject, 0);</span>
      RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">!     StackVisitor::visit(callFrame, vm, [&amp;] (StackVisitor&amp; visitor) -&gt; StackVisitor::Status {</span>
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          if (visitor-&gt;isInlinedFrame())
              return StackVisitor::Continue;
          if (visitor-&gt;isWasmFrame())
              return StackVisitor::Continue;
<span class="line-modified">!         result-&gt;push(globalObject, jsCast&lt;JSObject*&gt;(visitor-&gt;callee().asCell()));</span>
          scope.releaseAssertNoException(); // This function is only called from tests.
          return StackVisitor::Continue;
      });
      RETURN_IF_EXCEPTION(scope, { });
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionSetGlobalConstRedeclarationShouldNotThrow(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      vm.setGlobalConstRedeclarationShouldThrow(false);
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionFindTypeForExpression(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      RELEASE_ASSERT(vm.typeProfiler());
      vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;jsc Testing API: functionFindTypeForExpression&quot;_s);
  
<span class="line-modified">!     JSValue functionValue = callFrame-&gt;argument(0);</span>
      RELEASE_ASSERT(functionValue.isFunction(vm));
      FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
  
<span class="line-modified">!     RELEASE_ASSERT(callFrame-&gt;argument(1).isString());</span>
<span class="line-modified">!     String substring = asString(callFrame-&gt;argument(1))-&gt;value(globalObject);</span>
      String sourceCodeText = executable-&gt;source().view().toString();
      unsigned offset = static_cast&lt;unsigned&gt;(sourceCodeText.find(substring) + executable-&gt;source().startOffset());
  
      String jsonString = vm.typeProfiler()-&gt;typeInformationForExpressionAtOffset(TypeProfilerSearchDescriptorNormal, offset, executable-&gt;sourceID(), vm);
<span class="line-modified">!     return JSValue::encode(JSONParse(globalObject, jsonString));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionReturnTypeFor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      RELEASE_ASSERT(vm.typeProfiler());
      vm.typeProfilerLog()-&gt;processLogEntries(vm, &quot;jsc Testing API: functionReturnTypeFor&quot;_s);
  
<span class="line-modified">!     JSValue functionValue = callFrame-&gt;argument(0);</span>
      RELEASE_ASSERT(functionValue.isFunction(vm));
      FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
  
      unsigned offset = executable-&gt;typeProfilingStartOffset(vm);
      String jsonString = vm.typeProfiler()-&gt;typeInformationForExpressionAtOffset(TypeProfilerSearchDescriptorFunctionReturn, offset, executable-&gt;sourceID(), vm);
<span class="line-modified">!     return JSValue::encode(JSONParse(globalObject, jsonString));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionFlattenDictionaryObject(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     JSValue value = callFrame-&gt;argument(0);</span>
      RELEASE_ASSERT(value.isObject() &amp;&amp; value.getObject()-&gt;structure()-&gt;isDictionary());
      value.getObject()-&gt;flattenDictionaryObject(vm);
      return encodedJSUndefined();
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDumpBasicBlockExecutionRanges(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      RELEASE_ASSERT(vm.controlFlowProfiler());
      vm.controlFlowProfiler()-&gt;dumpData();
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionHasBasicBlockExecuted(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      RELEASE_ASSERT(vm.controlFlowProfiler());
  
<span class="line-modified">!     JSValue functionValue = callFrame-&gt;argument(0);</span>
      RELEASE_ASSERT(functionValue.isFunction(vm));
      FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
  
<span class="line-modified">!     RELEASE_ASSERT(callFrame-&gt;argument(1).isString());</span>
<span class="line-modified">!     String substring = asString(callFrame-&gt;argument(1))-&gt;value(globalObject);</span>
      String sourceCodeText = executable-&gt;source().view().toString();
      RELEASE_ASSERT(sourceCodeText.contains(substring));
      int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
  
      bool hasExecuted = vm.controlFlowProfiler()-&gt;hasBasicBlockAtTextOffsetBeenExecuted(offset, executable-&gt;sourceID(), vm);
      return JSValue::encode(jsBoolean(hasExecuted));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionBasicBlockExecutionCount(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      RELEASE_ASSERT(vm.controlFlowProfiler());
  
<span class="line-modified">!     JSValue functionValue = callFrame-&gt;argument(0);</span>
      RELEASE_ASSERT(functionValue.isFunction(vm));
      FunctionExecutable* executable = (jsDynamicCast&lt;JSFunction*&gt;(vm, functionValue.asCell()-&gt;getObject()))-&gt;jsExecutable();
  
<span class="line-modified">!     RELEASE_ASSERT(callFrame-&gt;argument(1).isString());</span>
<span class="line-modified">!     String substring = asString(callFrame-&gt;argument(1))-&gt;value(globalObject);</span>
      String sourceCodeText = executable-&gt;source().view().toString();
      RELEASE_ASSERT(sourceCodeText.contains(substring));
      int offset = sourceCodeText.find(substring) + executable-&gt;source().startOffset();
  
      size_t executionCount = vm.controlFlowProfiler()-&gt;basicBlockExecutionCountAtTextOffset(offset, executable-&gt;sourceID(), vm);
      return JSValue::encode(JSValue(executionCount));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionEnableExceptionFuzz(JSGlobalObject*, CallFrame*)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      Options::useExceptionFuzz() = true;
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! class DoNothingDebugger final : public Debugger {</span>
<span class="line-added">+     WTF_MAKE_NONCOPYABLE(DoNothingDebugger);</span>
<span class="line-added">+     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     DoNothingDebugger(VM&amp; vm)</span>
<span class="line-added">+         : Debugger(vm)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
<span class="line-added">+         setSuppressAllPauses(true);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
<span class="line-added">+     void sourceParsed(JSGlobalObject*, SourceProvider*, int, const WTF::String&amp;) override</span>
<span class="line-added">+     {</span>
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ static EncodedJSValue changeDebuggerModeWhenIdle(JSGlobalObject* globalObject, OptionSet&lt;CodeGenerationMode&gt; codeGenerationMode)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-modified">! </span>
<span class="line-added">+     bool debuggerRequested = codeGenerationMode.contains(CodeGenerationMode::Debugger);</span>
<span class="line-added">+     if (debuggerRequested == globalObject-&gt;hasDebugger())</span>
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     VM* vm = &amp;globalObject-&gt;vm();</span>
      vm-&gt;whenIdle([=] () {
<span class="line-modified">!         DollarVMAssertScope assertScope;</span>
<span class="line-modified">!         if (debuggerRequested) {</span>
<span class="line-modified">!             Debugger* debugger = new DoNothingDebugger(globalObject-&gt;vm());</span>
<span class="line-modified">!             globalObject-&gt;setDebugger(debugger);</span>
<span class="line-added">+             debugger-&gt;activateBreakpoints(); // Also deletes all code.</span>
<span class="line-added">+         } else {</span>
<span class="line-added">+             Debugger* debugger = globalObject-&gt;debugger();</span>
<span class="line-added">+             debugger-&gt;deactivateBreakpoints(); // Also deletes all code.</span>
<span class="line-added">+             globalObject-&gt;setDebugger(nullptr);</span>
<span class="line-added">+             delete debugger;</span>
<span class="line-added">+         }</span>
      });
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionEnableDebuggerModeWhenIdle(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     return changeDebuggerModeWhenIdle(globalObject, { CodeGenerationMode::Debugger });</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDisableDebuggerModeWhenIdle(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     return changeDebuggerModeWhenIdle(globalObject, { });</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDeleteAllCodeWhenIdle(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM* vm = &amp;globalObject-&gt;vm();</span>
      vm-&gt;whenIdle([=] () {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          vm-&gt;deleteAllCode(PreventCollectionAndDeleteAllCode);
      });
      return JSValue::encode(jsUndefined());
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGlobalObjectCount(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     return JSValue::encode(jsNumber(globalObject-&gt;vm().heap.globalObjectCount()));</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGlobalObjectForObject(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     JSValue value = callFrame-&gt;argument(0);</span>
      RELEASE_ASSERT(value.isObject());
<span class="line-modified">!     JSGlobalObject* result = jsCast&lt;JSObject*&gt;(value)-&gt;globalObject(globalObject-&gt;vm());</span>
<span class="line-modified">!     RELEASE_ASSERT(result);</span>
<span class="line-modified">!     return JSValue::encode(result);</span>
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionGetGetterSetter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     JSValue value = callFrame-&gt;argument(0);</span>
      if (!value.isObject())
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     JSValue property = callFrame-&gt;argument(1);</span>
      if (!property.isString())
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     auto propertyName = asString(property)-&gt;toIdentifier(globalObject);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      PropertySlot slot(value, PropertySlot::InternalMethodType::VMInquiry);
<span class="line-modified">!     value.getPropertySlot(globalObject, propertyName, slot);</span>
      RETURN_IF_EXCEPTION(scope, { });
  
      JSValue result;
      if (slot.isCacheableGetter())
          result = slot.getterSetter();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2152,38 ***</span>
          result = jsNull();
  
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionLoadGetterFromGetterSetter(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(vm, exec-&gt;argument(0));</span>
      if (UNLIKELY(!getterSetter)) {
<span class="line-modified">!         throwTypeError(exec, scope, &quot;Invalid use of loadGetterFromGetterSetter test function: argument is not a GetterSetter&quot;_s);</span>
          return encodedJSValue();
      }
  
      JSObject* getter = getterSetter-&gt;getter();
      RELEASE_ASSERT(getter);
      return JSValue::encode(getter);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateCustomTestGetterSetter(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSGlobalObject* globalObject = exec-&gt;lexicalGlobalObject();</span>
      return JSValue::encode(JSTestCustomGetterSetter::create(vm, globalObject, JSTestCustomGetterSetter::createStructure(vm, globalObject)));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDeltaBetweenButterflies(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">!     JSObject* a = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(0));</span>
<span class="line-modified">!     JSObject* b = jsDynamicCast&lt;JSObject*&gt;(vm, exec-&gt;argument(1));</span>
      if (!a || !b)
          return JSValue::encode(jsNumber(PNaN));
  
      ptrdiff_t delta = bitwise_cast&lt;char*&gt;(a-&gt;butterfly()) - bitwise_cast&lt;char*&gt;(b-&gt;butterfly());
      if (delta &lt; 0)
<span class="line-new-header">--- 2684,40 ---</span>
          result = jsNull();
  
      return JSValue::encode(result);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionLoadGetterFromGetterSetter(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="line-modified">!     GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(vm, callFrame-&gt;argument(0));</span>
      if (UNLIKELY(!getterSetter)) {
<span class="line-modified">!         throwTypeError(globalObject, scope, &quot;Invalid use of loadGetterFromGetterSetter test function: argument is not a GetterSetter&quot;_s);</span>
          return encodedJSValue();
      }
  
      JSObject* getter = getterSetter-&gt;getter();
      RELEASE_ASSERT(getter);
      return JSValue::encode(getter);
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCreateCustomTestGetterSetter(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
      return JSValue::encode(JSTestCustomGetterSetter::create(vm, globalObject, JSTestCustomGetterSetter::createStructure(vm, globalObject)));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionDeltaBetweenButterflies(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-modified">!     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">!     JSObject* a = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(0));</span>
<span class="line-added">+     JSObject* b = jsDynamicCast&lt;JSObject*&gt;(vm, callFrame-&gt;argument(1));</span>
      if (!a || !b)
          return JSValue::encode(jsNumber(PNaN));
  
      ptrdiff_t delta = bitwise_cast&lt;char*&gt;(a-&gt;butterfly()) - bitwise_cast&lt;char*&gt;(b-&gt;butterfly());
      if (delta &lt; 0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2191,40 ***</span>
      if (delta &gt; std::numeric_limits&lt;int32_t&gt;::max())
          return JSValue::encode(jsNumber(PNaN));
      return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(delta)));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionTotalGCTime(ExecState* exec)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      return JSValue::encode(jsNumber(vm.heap.totalGCTime().seconds()));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionParseCount(ExecState*)</span>
  {
      return JSValue::encode(jsNumber(globalParseCount.load()));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionIsWasmSupported(ExecState*)</span>
  {
  #if ENABLE(WEBASSEMBLY)
      return JSValue::encode(jsBoolean(Wasm::isSupported()));
  #else
      return JSValue::encode(jsBoolean(false));
  #endif
  }
  
  void JSDollarVM::finishCreation(VM&amp; vm)
  {
      Base::finishCreation(vm);
  
      JSGlobalObject* globalObject = this-&gt;globalObject(vm);
  
      auto addFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
          JSDollarVM::addFunction(vm, globalObject, name, function, arguments);
      };
      auto addConstructibleFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
          JSDollarVM::addConstructibleFunction(vm, globalObject, name, function, arguments);
      };
  
      addFunction(vm, &quot;abort&quot;, functionCrash, 0);
      addFunction(vm, &quot;crash&quot;, functionCrash, 0);
<span class="line-new-header">--- 2725,124 ---</span>
      if (delta &gt; std::numeric_limits&lt;int32_t&gt;::max())
          return JSValue::encode(jsNumber(PNaN));
      return JSValue::encode(jsNumber(static_cast&lt;int32_t&gt;(delta)));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionCurrentCPUTime(JSGlobalObject*, CallFrame*)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     return JSValue::encode(jsNumber(CPUTime::forCurrentThread().value()));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static EncodedJSValue JSC_HOST_CALL functionTotalGCTime(JSGlobalObject* globalObject, CallFrame*)</span>
  {
<span class="line-modified">!     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      return JSValue::encode(jsNumber(vm.heap.totalGCTime().seconds()));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionParseCount(JSGlobalObject*, CallFrame*)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      return JSValue::encode(jsNumber(globalParseCount.load()));
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL functionIsWasmSupported(JSGlobalObject*, CallFrame*)</span>
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
  #if ENABLE(WEBASSEMBLY)
      return JSValue::encode(jsBoolean(Wasm::isSupported()));
  #else
      return JSValue::encode(jsBoolean(false));
  #endif
  }
  
<span class="line-added">+ static EncodedJSValue JSC_HOST_CALL functionMake16BitStringIfPossible(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+     String string = callFrame-&gt;argument(0).toWTFString(globalObject);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+     if (!string.is8Bit())</span>
<span class="line-added">+         return JSValue::encode(jsString(vm, WTFMove(string)));</span>
<span class="line-added">+     Vector&lt;UChar&gt; buffer;</span>
<span class="line-added">+     buffer.resize(string.length());</span>
<span class="line-added">+     StringImpl::copyCharacters(buffer.data(), string.characters8(), string.length());</span>
<span class="line-added">+     return JSValue::encode(jsString(vm, String::adopt(WTFMove(buffer))));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ EncodedJSValue JSC_HOST_CALL JSDollarVMHelper::functionGetStructureTransitionList(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+     JSObject* obj = callFrame-&gt;argument(0).toObject(globalObject);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+     if (!obj)</span>
<span class="line-added">+         return JSValue::encode(jsNull());</span>
<span class="line-added">+     Vector&lt;Structure*, 8&gt; structures;</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (auto* structure = obj-&gt;structure(); structure; structure = structure-&gt;previousID())</span>
<span class="line-added">+         structures.append(structure);</span>
<span class="line-added">+ </span>
<span class="line-added">+     JSArray* result = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), 0);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+ </span>
<span class="line-added">+     for (size_t i = 0; i &lt; structures.size(); ++i) {</span>
<span class="line-added">+         auto* structure = structures[structures.size() - i - 1];</span>
<span class="line-added">+         result-&gt;push(globalObject, JSValue(structure-&gt;id()));</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+         result-&gt;push(globalObject, JSValue(structure-&gt;transitionOffset()));</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+         result-&gt;push(globalObject, JSValue(structure-&gt;maxOffset()));</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+         if (structure-&gt;m_transitionPropertyName)</span>
<span class="line-added">+             result-&gt;push(globalObject, jsString(vm, String(*structure-&gt;m_transitionPropertyName)));</span>
<span class="line-added">+         else</span>
<span class="line-added">+             result-&gt;push(globalObject, jsNull());</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+         result-&gt;push(globalObject, JSValue(structure-&gt;isPropertyDeletionTransition()));</span>
<span class="line-added">+         RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return JSValue::encode(result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static EncodedJSValue JSC_HOST_CALL functionGetConcurrently(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
<span class="line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added">+     JSObject* obj = callFrame-&gt;argument(0).toObject(globalObject);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+     if (!obj)</span>
<span class="line-added">+         return JSValue::encode(jsNull());</span>
<span class="line-added">+     String property = callFrame-&gt;argument(1).toWTFString(globalObject);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+     auto name = PropertyName(Identifier::fromString(vm, property));</span>
<span class="line-added">+     auto offset = obj-&gt;structure()-&gt;getConcurrently(name.uid());</span>
<span class="line-added">+     if (offset != invalidOffset)</span>
<span class="line-added">+         ASSERT(JSValue::encode(obj-&gt;getDirect(offset)));</span>
<span class="line-added">+     JSValue result = JSValue(offset != invalidOffset);</span>
<span class="line-added">+     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="line-added">+     return JSValue::encode(result);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void JSDollarVM::finishCreation(VM&amp; vm)
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      Base::finishCreation(vm);
  
      JSGlobalObject* globalObject = this-&gt;globalObject(vm);
  
      auto addFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          JSDollarVM::addFunction(vm, globalObject, name, function, arguments);
      };
      auto addConstructibleFunction = [&amp;] (VM&amp; vm, const char* name, NativeFunction function, unsigned arguments) {
<span class="line-added">+         DollarVMAssertScope assertScope;</span>
          JSDollarVM::addConstructibleFunction(vm, globalObject, name, function, arguments);
      };
  
      addFunction(vm, &quot;abort&quot;, functionCrash, 0);
      addFunction(vm, &quot;crash&quot;, functionCrash, 0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2268,10 ***</span>
<span class="line-new-header">--- 2886,12 ---</span>
      addFunction(vm, &quot;getpid&quot;, functionGetPID, 0);
  
      addFunction(vm, &quot;haveABadTime&quot;, functionHaveABadTime, 1);
      addFunction(vm, &quot;isHavingABadTime&quot;, functionIsHavingABadTime, 1);
  
<span class="line-added">+     addFunction(vm, &quot;callWithStackSize&quot;, functionCallWithStackSize, 2);</span>
<span class="line-added">+ </span>
      addFunction(vm, &quot;createGlobalObject&quot;, functionCreateGlobalObject, 0);
      addFunction(vm, &quot;createProxy&quot;, functionCreateProxy, 1);
      addFunction(vm, &quot;createRuntimeArray&quot;, functionCreateRuntimeArray, 0);
      addFunction(vm, &quot;createNullRopeString&quot;, functionCreateNullRopeString, 0);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2285,10 ***</span>
<span class="line-new-header">--- 2905,12 ---</span>
      addFunction(vm, &quot;createDOMJITGetterBaseJSObject&quot;, functionCreateDOMJITGetterBaseJSObject, 0);
      addFunction(vm, &quot;createBuiltin&quot;, functionCreateBuiltin, 2);
  #if ENABLE(WEBASSEMBLY)
      addFunction(vm, &quot;createWasmStreamingParser&quot;, functionCreateWasmStreamingParser, 0);
  #endif
<span class="line-added">+     addFunction(vm, &quot;createStaticCustomAccessor&quot;, functionCreateStaticCustomAccessor, 0);</span>
<span class="line-added">+     addFunction(vm, &quot;createObjectDoingSideEffectPutWithoutCorrectSlotStatus&quot;, functionCreateObjectDoingSideEffectPutWithoutCorrectSlotStatus, 0);</span>
      addFunction(vm, &quot;getPrivateProperty&quot;, functionGetPrivateProperty, 2);
      addFunction(vm, &quot;setImpureGetterDelegate&quot;, functionSetImpureGetterDelegate, 2);
  
      addConstructibleFunction(vm, &quot;Root&quot;, functionCreateRoot, 0);
      addConstructibleFunction(vm, &quot;Element&quot;, functionCreateElement, 1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2324,25 ***</span>
<span class="line-new-header">--- 2946,43 ---</span>
      addFunction(vm, &quot;loadGetterFromGetterSetter&quot;, functionLoadGetterFromGetterSetter, 1);
      addFunction(vm, &quot;createCustomTestGetterSetter&quot;, functionCreateCustomTestGetterSetter, 1);
  
      addFunction(vm, &quot;deltaBetweenButterflies&quot;, functionDeltaBetweenButterflies, 2);
  
<span class="line-added">+     addFunction(vm, &quot;currentCPUTime&quot;, functionCurrentCPUTime, 0);</span>
      addFunction(vm, &quot;totalGCTime&quot;, functionTotalGCTime, 0);
  
      addFunction(vm, &quot;parseCount&quot;, functionParseCount, 0);
  
      addFunction(vm, &quot;isWasmSupported&quot;, functionIsWasmSupported, 0);
<span class="line-added">+     addFunction(vm, &quot;make16BitStringIfPossible&quot;, functionMake16BitStringIfPossible, 1);</span>
<span class="line-added">+ </span>
<span class="line-added">+     addFunction(vm, &quot;getStructureTransitionList&quot;, JSDollarVMHelper::functionGetStructureTransitionList, 1);</span>
<span class="line-added">+     addFunction(vm, &quot;getConcurrently&quot;, functionGetConcurrently, 2);</span>
<span class="line-added">+ </span>
<span class="line-added">+     m_objectDoingSideEffectPutWithoutCorrectSlotStatusStructure.set(vm, this, ObjectDoingSideEffectPutWithoutCorrectSlotStatus::createStructure(vm, globalObject, jsNull()));</span>
  }
  
  void JSDollarVM::addFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      Identifier identifier = Identifier::fromString(vm, name);
      putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function));
  }
  
  void JSDollarVM::addConstructibleFunction(VM&amp; vm, JSGlobalObject* globalObject, const char* name, NativeFunction function, unsigned arguments)
  {
<span class="line-added">+     DollarVMAssertScope assertScope;</span>
      Identifier identifier = Identifier::fromString(vm, name);
      putDirect(vm, identifier, JSFunction::create(vm, globalObject, arguments, identifier.string(), function, NoIntrinsic, function));
  }
  
<span class="line-added">+ void JSDollarVM::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     JSDollarVM* thisObject = jsCast&lt;JSDollarVM*&gt;(cell);</span>
<span class="line-added">+     Base::visitChildren(thisObject, visitor);</span>
<span class="line-added">+     visitor.append(thisObject-&gt;m_objectDoingSideEffectPutWithoutCorrectSlotStatusStructure);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } // namespace JSC
<span class="line-added">+ </span>
<span class="line-added">+ IGNORE_WARNINGS_END</span>
</pre>
<center><a href="HeapVerifier.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSDollarVM.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
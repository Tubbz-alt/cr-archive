<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/NakedRef.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2020 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/DumbPtrTraits.h&gt;
 29 #include &lt;wtf/FastMalloc.h&gt;
 30 
 31 namespace WTF {
 32 
 33 // The purpose of this class is to ensure that the wrapped pointer will never be
 34 // used uninitialized.
 35 
 36 template &lt;typename T&gt; class NakedRef {
 37     WTF_MAKE_FAST_ALLOCATED;
 38 public:
 39     ALWAYS_INLINE NakedRef(T&amp; ref) : m_ptr(&amp;ref) { }
 40     ALWAYS_INLINE NakedRef(const NakedRef&amp;) = delete;
 41     template&lt;typename U&gt; NakedRef(const NakedRef&lt;U&gt;&amp;) = delete;
 42 
 43     ALWAYS_INLINE NakedRef(NakedRef&amp;&amp; other)
 44         : m_ptr(&amp;other.leakRef())
 45     {
 46         ASSERT(m_ptr);
 47     }
 48 
 49     template&lt;typename U&gt;
 50     NakedRef(NakedRef&lt;U&gt;&amp;&amp; other)
 51         : m_ptr(&amp;other.leakRef())
 52     {
 53         ASSERT(m_ptr);
 54     }
 55 
 56     ALWAYS_INLINE T* operator-&gt;() const { ASSERT(m_ptr); return m_ptr; }
 57     T* ptr() const RETURNS_NONNULL { ASSERT(m_ptr); return m_ptr; }
 58     T&amp; get() const { return *m_ptr; }
 59     operator T&amp;() const { ASSERT(m_ptr); return *m_ptr; }
 60     bool operator!() const { ASSERT(m_ptr); return !*m_ptr; }
 61 
 62     NakedRef copyRef() &amp;&amp; = delete;
 63     NakedRef copyRef() const &amp; WARN_UNUSED_RETURN { return NakedRef(*m_ptr); }
 64 
 65     NakedRef&amp; operator=(T&amp;);
 66     NakedRef&amp; operator=(NakedRef&amp;&amp;);
 67     template&lt;typename U&gt; NakedRef&amp; operator=(NakedRef&lt;U&gt;&amp;&amp;);
 68 
 69     // Use copyRef() and the move assignment operators instead.
 70     NakedRef&amp; operator=(const NakedRef&amp;) = delete;
 71     template&lt;typename X&gt; NakedRef&amp; operator=(const NakedRef&lt;X&gt;&amp;) = delete;
 72 
 73     template&lt;typename U&gt; void swap(NakedRef&lt;U&gt;&amp;);
 74 
 75     T&amp; leakRef() WARN_UNUSED_RETURN
 76     {
 77         ASSERT(m_ptr);
 78         T&amp; result = *DumbPtrTraits&lt;T&gt;::exchange(m_ptr, nullptr);
 79         return result;
 80     }
 81 
 82 private:
 83     T* m_ptr;
 84 };
 85 
 86 template&lt;typename T&gt; inline NakedRef&lt;T&gt;&amp; NakedRef&lt;T&gt;::operator=(NakedRef&amp;&amp; reference)
 87 {
 88     NakedRef movedReference = WTFMove(reference);
 89     swap(movedReference);
 90     return *this;
 91 }
 92 
 93 template&lt;typename T&gt; inline NakedRef&lt;T&gt;&amp; NakedRef&lt;T&gt;::operator=(T&amp; ref)
 94 {
 95     NakedRef copiedReference = ref;
 96     swap(copiedReference);
 97     return *this;
 98 }
 99 
100 template&lt;typename T&gt; template&lt;typename U&gt; inline NakedRef&lt;T&gt;&amp; NakedRef&lt;T&gt;::operator=(NakedRef&lt;U&gt;&amp;&amp; other)
101 {
102     NakedRef ref = WTFMove(other);
103     swap(ref);
104     return *this;
105 }
106 
107 template&lt;class T&gt;
108 template&lt;class U&gt;
109 inline void NakedRef&lt;T&gt;::swap(NakedRef&lt;U&gt;&amp; other)
110 {
111     std::swap(m_ptr, other.m_ptr);
112 }
113 
114 template&lt;class T, class U&gt; inline void swap(NakedRef&lt;T&gt;&amp; a, NakedRef&lt;U&gt;&amp; b)
115 {
116     a.swap(b);
117 }
118 
119 } // namespace WTF
120 
121 using WTF::NakedRef;
    </pre>
  </body>
</html>
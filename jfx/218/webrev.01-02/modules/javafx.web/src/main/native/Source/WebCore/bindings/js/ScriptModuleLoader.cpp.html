<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptModuleLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ScriptModuleLoader.h&quot;
 28 
 29 #include &quot;CachedModuleScriptLoader.h&quot;
 30 #include &quot;CachedScript.h&quot;
 31 #include &quot;CachedScriptFetcher.h&quot;
 32 #include &quot;Document.h&quot;
 33 #include &quot;Frame.h&quot;
 34 #include &quot;JSDOMBinding.h&quot;
 35 #include &quot;JSDOMPromiseDeferred.h&quot;
 36 #include &quot;LoadableModuleScript.h&quot;
 37 #include &quot;MIMETypeRegistry.h&quot;
 38 #include &quot;ModuleFetchFailureKind.h&quot;
 39 #include &quot;ModuleFetchParameters.h&quot;
 40 #include &quot;ScriptController.h&quot;
 41 #include &quot;ScriptSourceCode.h&quot;
 42 #include &quot;SubresourceIntegrity.h&quot;
 43 #include &quot;WebCoreJSClientData.h&quot;
 44 #include &lt;JavaScriptCore/Completion.h&gt;
 45 #include &lt;JavaScriptCore/JSInternalPromise.h&gt;
 46 #include &lt;JavaScriptCore/JSModuleRecord.h&gt;
 47 #include &lt;JavaScriptCore/JSScriptFetchParameters.h&gt;
 48 #include &lt;JavaScriptCore/JSScriptFetcher.h&gt;
 49 #include &lt;JavaScriptCore/JSSourceCode.h&gt;
 50 #include &lt;JavaScriptCore/JSString.h&gt;
 51 #include &lt;JavaScriptCore/Symbol.h&gt;
 52 
 53 namespace WebCore {
 54 
 55 ScriptModuleLoader::ScriptModuleLoader(Document&amp; document)
 56     : m_document(document)
 57 {
 58 }
 59 
 60 ScriptModuleLoader::~ScriptModuleLoader()
 61 {
 62     for (auto&amp; loader : m_loaders)
 63         loader-&gt;clearClient();
 64 }
 65 
 66 static bool isRootModule(JSC::JSValue importerModuleKey)
 67 {
 68     return importerModuleKey.isSymbol() || importerModuleKey.isUndefined();
 69 }
 70 
 71 static Expected&lt;URL, ASCIILiteral&gt; resolveModuleSpecifier(Document&amp; document, const String&amp; specifier, const URL&amp; baseURL)
 72 {
 73     // https://html.spec.whatwg.org/multipage/webappapis.html#resolve-a-module-specifier
 74 
 75     URL absoluteURL(URL(), specifier);
 76     if (absoluteURL.isValid())
 77         return absoluteURL;
 78 
 79     if (!specifier.startsWith(&#39;/&#39;) &amp;&amp; !specifier.startsWith(&quot;./&quot;) &amp;&amp; !specifier.startsWith(&quot;../&quot;))
 80         return makeUnexpected(&quot;Module specifier does not start with \&quot;/\&quot;, \&quot;./\&quot;, or \&quot;../\&quot;.&quot;_s);
 81 
 82     auto result = document.completeURL(specifier, baseURL);
 83     if (!result.isValid())
 84         return makeUnexpected(&quot;Module name does not resolve to a valid URL.&quot;_s);
 85     return result;
 86 }
 87 
 88 JSC::Identifier ScriptModuleLoader::resolve(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSValue moduleNameValue, JSC::JSValue importerModuleKey, JSC::JSValue)
 89 {
 90     JSC::VM&amp; vm = jsGlobalObject-&gt;vm();
 91     auto scope = DECLARE_THROW_SCOPE(vm);
 92 
 93     // We use a Symbol as a special purpose; It means this module is an inline module.
 94     // So there is no correct URL to retrieve the module source code. If the module name
 95     // value is a Symbol, it is used directly as a module key.
 96     if (moduleNameValue.isSymbol())
 97         return JSC::Identifier::fromUid(asSymbol(moduleNameValue)-&gt;privateName());
 98 
 99     if (!moduleNameValue.isString()) {
100         JSC::throwTypeError(jsGlobalObject, scope, &quot;Importer module key is not a Symbol or a String.&quot;_s);
101         return { };
102     }
103 
104     String specifier = asString(moduleNameValue)-&gt;value(jsGlobalObject);
105     RETURN_IF_EXCEPTION(scope, { });
106 
107     URL baseURL;
108     if (isRootModule(importerModuleKey))
109         baseURL = m_document.baseURL();
110     else {
111         ASSERT(importerModuleKey.isString());
112         URL importerModuleRequestURL(URL(), asString(importerModuleKey)-&gt;value(jsGlobalObject));
113         ASSERT_WITH_MESSAGE(importerModuleRequestURL.isValid(), &quot;Invalid module referrer never starts importing dependent modules.&quot;);
114 
115         auto iterator = m_requestURLToResponseURLMap.find(importerModuleRequestURL);
116         ASSERT_WITH_MESSAGE(iterator != m_requestURLToResponseURLMap.end(), &quot;Module referrer must register itself to the map before starting importing dependent modules.&quot;);
117         baseURL = iterator-&gt;value;
118     }
119 
120     auto result = resolveModuleSpecifier(m_document, specifier, baseURL);
121     if (!result) {
122         JSC::throwTypeError(jsGlobalObject, scope, result.error());
123         return { };
124     }
125 
126     return JSC::Identifier::fromString(vm, result-&gt;string());
127 }
128 
129 static void rejectToPropagateNetworkError(DeferredPromise&amp; deferred, ModuleFetchFailureKind failureKind, ASCIILiteral message)
130 {
131     deferred.rejectWithCallback([&amp;] (JSDOMGlobalObject&amp; jsGlobalObject) {
132         // We annotate exception with special private symbol. It allows us to distinguish these errors from the user thrown ones.
133         JSC::VM&amp; vm = jsGlobalObject.vm();
134         // FIXME: Propagate more descriptive error.
135         // https://bugs.webkit.org/show_bug.cgi?id=167553
136         auto* error = JSC::createTypeError(&amp;jsGlobalObject, message);
137         ASSERT(error);
138         error-&gt;putDirect(vm, static_cast&lt;JSVMClientData&amp;&gt;(*vm.clientData).builtinNames().failureKindPrivateName(), JSC::jsNumber(static_cast&lt;int32_t&gt;(failureKind)));
139         return error;
140     });
141 }
142 
143 JSC::JSInternalPromise* ScriptModuleLoader::fetch(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSValue parameters, JSC::JSValue scriptFetcher)
144 {
145     JSC::VM&amp; vm = jsGlobalObject-&gt;vm();
146     ASSERT(JSC::jsDynamicCast&lt;JSC::JSScriptFetcher*&gt;(vm, scriptFetcher));
147 
148     auto&amp; globalObject = *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(jsGlobalObject);
149     auto* jsPromise = JSC::JSInternalPromise::create(vm, globalObject.internalPromiseStructure());
150     RELEASE_ASSERT(jsPromise);
151     auto deferred = DeferredPromise::create(globalObject, *jsPromise);
152     if (moduleKeyValue.isSymbol()) {
153         deferred-&gt;reject(TypeError, &quot;Symbol module key should be already fulfilled with the inlined resource.&quot;_s);
154         return jsPromise;
155     }
156 
157     if (!moduleKeyValue.isString()) {
158         deferred-&gt;reject(TypeError, &quot;Module key is not Symbol or String.&quot;_s);
159         return jsPromise;
160     }
161 
162     // https://html.spec.whatwg.org/multipage/webappapis.html#fetch-a-single-module-script
163 
164     URL completedURL(URL(), asString(moduleKeyValue)-&gt;value(jsGlobalObject));
165     if (!completedURL.isValid()) {
166         deferred-&gt;reject(TypeError, &quot;Module key is a valid URL.&quot;_s);
167         return jsPromise;
168     }
169 
170     RefPtr&lt;ModuleFetchParameters&gt; topLevelFetchParameters;
171     if (auto* scriptFetchParameters = JSC::jsDynamicCast&lt;JSC::JSScriptFetchParameters*&gt;(vm, parameters))
172         topLevelFetchParameters = static_cast&lt;ModuleFetchParameters*&gt;(&amp;scriptFetchParameters-&gt;parameters());
173 
174     auto loader = CachedModuleScriptLoader::create(*this, deferred.get(), *static_cast&lt;CachedScriptFetcher*&gt;(JSC::jsCast&lt;JSC::JSScriptFetcher*&gt;(scriptFetcher)-&gt;fetcher()), WTFMove(topLevelFetchParameters));
175     m_loaders.add(loader.copyRef());
176     if (!loader-&gt;load(m_document, completedURL)) {
177         loader-&gt;clearClient();
178         m_loaders.remove(WTFMove(loader));
179         rejectToPropagateNetworkError(deferred.get(), ModuleFetchFailureKind::WasErrored, &quot;Importing a module script failed.&quot;_s);
180         return jsPromise;
181     }
182 
183     return jsPromise;
184 }
185 
186 URL ScriptModuleLoader::moduleURL(JSC::JSGlobalObject&amp; jsGlobalObject, JSC::JSValue moduleKeyValue)
187 {
188     if (moduleKeyValue.isSymbol())
189         return m_document.url();
190 
191     ASSERT(moduleKeyValue.isString());
192     return URL(URL(), asString(moduleKeyValue)-&gt;value(&amp;jsGlobalObject));
193 }
194 
195 JSC::JSValue ScriptModuleLoader::evaluate(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSValue moduleRecordValue, JSC::JSValue)
196 {
197     JSC::VM&amp; vm = jsGlobalObject-&gt;vm();
198     auto scope = DECLARE_THROW_SCOPE(vm);
199 
200     // FIXME: Currently, we only support JSModuleRecord.
201     // Once the reflective part of the module loader is supported, we will handle arbitrary values.
202     // https://whatwg.github.io/loader/#registry-prototype-provide
203     auto* moduleRecord = JSC::jsDynamicCast&lt;JSC::JSModuleRecord*&gt;(vm, moduleRecordValue);
204     if (!moduleRecord)
205         return JSC::jsUndefined();
206 
207     URL sourceURL = moduleURL(*jsGlobalObject, moduleKeyValue);
208     if (!sourceURL.isValid())
209         return JSC::throwTypeError(jsGlobalObject, scope, &quot;Module key is an invalid URL.&quot;_s);
210 
211     if (auto* frame = m_document.frame())
212         return frame-&gt;script().evaluateModule(sourceURL, *moduleRecord);
213     return JSC::jsUndefined();
214 }
215 
216 static JSC::JSInternalPromise* rejectPromise(JSDOMGlobalObject&amp; globalObject, ExceptionCode ec, ASCIILiteral message)
217 {
218     auto* jsPromise = JSC::JSInternalPromise::create(globalObject.vm(), globalObject.internalPromiseStructure());
219     RELEASE_ASSERT(jsPromise);
220     auto deferred = DeferredPromise::create(globalObject, *jsPromise);
221     deferred-&gt;reject(ec, WTFMove(message));
222     return jsPromise;
223 }
224 
225 JSC::JSInternalPromise* ScriptModuleLoader::importModule(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSString* moduleName, JSC::JSValue parameters, const JSC::SourceOrigin&amp; sourceOrigin)
226 {
227     JSC::VM&amp; vm = jsGlobalObject-&gt;vm();
228     auto&amp; globalObject = *JSC::jsCast&lt;JSDOMGlobalObject*&gt;(jsGlobalObject);
229 
230     // If SourceOrigin and/or CachedScriptFetcher is null, we import the module with the default fetcher.
231     // SourceOrigin can be null if the source code is not coupled with the script file.
232     // The examples,
233     //     1. The code evaluated by the inspector.
234     //     2. The other unusual code execution like the evaluation through the NPAPI.
235     //     3. The code from injected bundle&#39;s script.
236     //     4. The code from extension script.
237     URL baseURL;
238     RefPtr&lt;JSC::ScriptFetcher&gt; scriptFetcher;
239     if (sourceOrigin.isNull()) {
240         baseURL = m_document.baseURL();
241         scriptFetcher = CachedScriptFetcher::create(m_document.charset());
242     } else {
243         baseURL = URL(URL(), sourceOrigin.string());
244         if (!baseURL.isValid())
245             return rejectPromise(globalObject, TypeError, &quot;Importer module key is not a Symbol or a String.&quot;_s);
246 
247         if (sourceOrigin.fetcher())
248             scriptFetcher = sourceOrigin.fetcher();
249         else
250             scriptFetcher = CachedScriptFetcher::create(m_document.charset());
251     }
252     ASSERT(baseURL.isValid());
253     ASSERT(scriptFetcher);
254 
255     auto specifier = moduleName-&gt;value(jsGlobalObject);
256     auto result = resolveModuleSpecifier(m_document, specifier, baseURL);
257     if (!result)
258         return rejectPromise(globalObject, TypeError, result.error());
259 
260     return JSC::importModule(jsGlobalObject, JSC::Identifier::fromString(vm, result-&gt;string()), parameters, JSC::JSScriptFetcher::create(vm, WTFMove(scriptFetcher) ));
261 }
262 
263 JSC::JSObject* ScriptModuleLoader::createImportMetaProperties(JSC::JSGlobalObject* jsGlobalObject, JSC::JSModuleLoader*, JSC::JSValue moduleKeyValue, JSC::JSModuleRecord*, JSC::JSValue)
264 {
265     auto&amp; vm = jsGlobalObject-&gt;vm();
266     auto scope = DECLARE_THROW_SCOPE(vm);
267 
268     URL sourceURL = moduleURL(*jsGlobalObject, moduleKeyValue);
269     ASSERT(sourceURL.isValid());
270 
271     auto* metaProperties = JSC::constructEmptyObject(vm, jsGlobalObject-&gt;nullPrototypeObjectStructure());
272     RETURN_IF_EXCEPTION(scope, nullptr);
273 
274     metaProperties-&gt;putDirect(vm, JSC::Identifier::fromString(vm, &quot;url&quot;), JSC::jsString(vm, sourceURL.string()));
275     RETURN_IF_EXCEPTION(scope, nullptr);
276 
277     return metaProperties;
278 }
279 
280 void ScriptModuleLoader::notifyFinished(CachedModuleScriptLoader&amp; loader, RefPtr&lt;DeferredPromise&gt; promise)
281 {
282     // https://html.spec.whatwg.org/multipage/webappapis.html#fetch-a-single-module-script
283 
284     URL sourceURL = loader.sourceURL();
285     if (!m_loaders.remove(&amp;loader))
286         return;
287     loader.clearClient();
288 
289     auto&amp; cachedScript = *loader.cachedScript();
290 
291     if (cachedScript.resourceError().isAccessControl()) {
292         promise-&gt;reject(TypeError, &quot;Cross-origin script load denied by Cross-Origin Resource Sharing policy.&quot;_s);
293         return;
294     }
295 
296     if (cachedScript.errorOccurred()) {
297         rejectToPropagateNetworkError(*promise, ModuleFetchFailureKind::WasErrored, &quot;Importing a module script failed.&quot;_s);
298         return;
299     }
300 
301     if (cachedScript.wasCanceled()) {
302         rejectToPropagateNetworkError(*promise, ModuleFetchFailureKind::WasCanceled, &quot;Importing a module script is canceled.&quot;_s);
303         return;
304     }
305 
306     if (!MIMETypeRegistry::isSupportedJavaScriptMIMEType(cachedScript.response().mimeType())) {
307         // https://html.spec.whatwg.org/multipage/webappapis.html#fetch-a-single-module-script
308         // The result of extracting a MIME type from response&#39;s header list (ignoring parameters) is not a JavaScript MIME type.
309         // For historical reasons, fetching a classic script does not include MIME type checking. In contrast, module scripts will fail to load if they are not of a correct MIME type.
310         promise-&gt;reject(TypeError, makeString(&quot;&#39;&quot;, cachedScript.response().mimeType(), &quot;&#39; is not a valid JavaScript MIME type.&quot;));
311         return;
312     }
313 
314     if (auto* parameters = loader.parameters()) {
315         if (!matchIntegrityMetadata(cachedScript, parameters-&gt;integrity())) {
316             promise-&gt;reject(TypeError, makeString(&quot;Cannot load script &quot;, integrityMismatchDescription(cachedScript, parameters-&gt;integrity())));
317             return;
318         }
319     }
320 
321     m_requestURLToResponseURLMap.add(WTFMove(sourceURL), cachedScript.response().url());
322     promise-&gt;resolveWithCallback([&amp;] (JSDOMGlobalObject&amp; jsGlobalObject) {
323         return JSC::JSSourceCode::create(jsGlobalObject.vm(),
324             JSC::SourceCode { ScriptSourceCode { &amp;cachedScript, JSC::SourceProviderSourceType::Module, loader.scriptFetcher() }.jsSourceCode() });
325     });
326 }
327 
328 }
    </pre>
  </body>
</html>
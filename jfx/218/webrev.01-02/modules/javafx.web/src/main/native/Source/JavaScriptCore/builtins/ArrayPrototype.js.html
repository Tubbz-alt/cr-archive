<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/ArrayPrototype.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2014-2017 Apple Inc. All rights reserved.
  3  * Copyright (C) 2015 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 function reduce(callback /*, initialValue */)
 28 {
 29     &quot;use strict&quot;;
 30 
 31     var array = @toObject(this, &quot;Array.prototype.reduce requires that |this| not be null or undefined&quot;);
 32     var length = @toLength(array.length);
 33 
 34     if (typeof callback !== &quot;function&quot;)
 35         @throwTypeError(&quot;Array.prototype.reduce callback must be a function&quot;);
 36 
 37     var argumentCount = @argumentCount();
 38     if (length === 0 &amp;&amp; argumentCount &lt; 2)
 39         @throwTypeError(&quot;reduce of empty array with no initial value&quot;);
 40 
 41     var accumulator, k = 0;
 42     if (argumentCount &gt; 1)
 43         accumulator = @argument(1);
 44     else {
 45         while (k &lt; length &amp;&amp; !(k in array))
 46             k += 1;
 47         if (k &gt;= length)
 48             @throwTypeError(&quot;reduce of empty array with no initial value&quot;);
 49         accumulator = array[k++];
 50     }
 51 
 52     while (k &lt; length) {
 53         if (k in array)
 54             accumulator = callback.@call(@undefined, accumulator, array[k], k, array);
 55         k += 1;
 56     }
 57     return accumulator;
 58 }
 59 
 60 function reduceRight(callback /*, initialValue */)
 61 {
 62     &quot;use strict&quot;;
 63 
 64     var array = @toObject(this, &quot;Array.prototype.reduceRight requires that |this| not be null or undefined&quot;);
 65     var length = @toLength(array.length);
 66 
 67     if (typeof callback !== &quot;function&quot;)
 68         @throwTypeError(&quot;Array.prototype.reduceRight callback must be a function&quot;);
 69 
 70     var argumentCount = @argumentCount();
 71     if (length === 0 &amp;&amp; argumentCount &lt; 2)
 72         @throwTypeError(&quot;reduceRight of empty array with no initial value&quot;);
 73 
 74     var accumulator, k = length - 1;
 75     if (argumentCount &gt; 1)
 76         accumulator = @argument(1);
 77     else {
 78         while (k &gt;= 0 &amp;&amp; !(k in array))
 79             k -= 1;
 80         if (k &lt; 0)
 81             @throwTypeError(&quot;reduceRight of empty array with no initial value&quot;);
 82         accumulator = array[k--];
 83     }
 84 
 85     while (k &gt;= 0) {
 86         if (k in array)
 87             accumulator = callback.@call(@undefined, accumulator, array[k], k, array);
 88         k -= 1;
 89     }
 90     return accumulator;
 91 }
 92 
 93 function every(callback /*, thisArg */)
 94 {
 95     &quot;use strict&quot;;
 96 
 97     var array = @toObject(this, &quot;Array.prototype.every requires that |this| not be null or undefined&quot;);
 98     var length = @toLength(array.length);
 99 
100     if (typeof callback !== &quot;function&quot;)
101         @throwTypeError(&quot;Array.prototype.every callback must be a function&quot;);
102     
103     var thisArg = @argument(1);
104     
105     for (var i = 0; i &lt; length; i++) {
106         if (!(i in array))
107             continue;
108         if (!callback.@call(thisArg, array[i], i, array))
109             return false;
110     }
111     
112     return true;
113 }
114 
115 function forEach(callback /*, thisArg */)
116 {
117     &quot;use strict&quot;;
118 
119     var array = @toObject(this, &quot;Array.prototype.forEach requires that |this| not be null or undefined&quot;);
120     var length = @toLength(array.length);
121 
122     if (typeof callback !== &quot;function&quot;)
123         @throwTypeError(&quot;Array.prototype.forEach callback must be a function&quot;);
124     
125     var thisArg = @argument(1);
126     
127     for (var i = 0; i &lt; length; i++) {
128         if (i in array)
129             callback.@call(thisArg, array[i], i, array);
130     }
131 }
132 
133 function filter(callback /*, thisArg */)
134 {
135     &quot;use strict&quot;;
136 
137     var array = @toObject(this, &quot;Array.prototype.filter requires that |this| not be null or undefined&quot;);
138     var length = @toLength(array.length);
139 
140     if (typeof callback !== &quot;function&quot;)
141         @throwTypeError(&quot;Array.prototype.filter callback must be a function&quot;);
142     
143     var thisArg = @argument(1);
144     var result = @arraySpeciesCreate(array, 0);
145 
146     var nextIndex = 0;
147     for (var i = 0; i &lt; length; i++) {
148         if (!(i in array))
149             continue;
150         var current = array[i]
151         if (callback.@call(thisArg, current, i, array)) {
152             @putByValDirect(result, nextIndex, current);
153             ++nextIndex;
154         }
155     }
156     return result;
157 }
158 
159 function map(callback /*, thisArg */)
160 {
161     &quot;use strict&quot;;
162 
163     var array = @toObject(this, &quot;Array.prototype.map requires that |this| not be null or undefined&quot;);
164     var length = @toLength(array.length);
165 
166     if (typeof callback !== &quot;function&quot;)
167         @throwTypeError(&quot;Array.prototype.map callback must be a function&quot;);
168     
169     var thisArg = @argument(1);
170     var result = @arraySpeciesCreate(array, length);
171 
172     for (var i = 0; i &lt; length; i++) {
173         if (!(i in array))
174             continue;
175         var mappedValue = callback.@call(thisArg, array[i], i, array);
176         @putByValDirect(result, i, mappedValue);
177     }
178     return result;
179 }
180 
181 function some(callback /*, thisArg */)
182 {
183     &quot;use strict&quot;;
184 
185     var array = @toObject(this, &quot;Array.prototype.some requires that |this| not be null or undefined&quot;);
186     var length = @toLength(array.length);
187 
188     if (typeof callback !== &quot;function&quot;)
189         @throwTypeError(&quot;Array.prototype.some callback must be a function&quot;);
190     
191     var thisArg = @argument(1);
192     for (var i = 0; i &lt; length; i++) {
193         if (!(i in array))
194             continue;
195         if (callback.@call(thisArg, array[i], i, array))
196             return true;
197     }
198     return false;
199 }
200 
201 function fill(value /* [, start [, end]] */)
202 {
203     &quot;use strict&quot;;
204 
205     var array = @toObject(this, &quot;Array.prototype.fill requires that |this| not be null or undefined&quot;);
206     var length = @toLength(array.length);
207 
208     var relativeStart = @toInteger(@argument(1));
209     var k = 0;
210     if (relativeStart &lt; 0) {
211         k = length + relativeStart;
212         if (k &lt; 0)
213             k = 0;
214     } else {
215         k = relativeStart;
216         if (k &gt; length)
217             k = length;
218     }
219     var relativeEnd = length;
220     var end = @argument(2);
221     if (end !== @undefined)
222         relativeEnd = @toInteger(end);
223     var final = 0;
224     if (relativeEnd &lt; 0) {
225         final = length + relativeEnd;
226         if (final &lt; 0)
227             final = 0;
228     } else {
229         final = relativeEnd;
230         if (final &gt; length)
231             final = length;
232     }
233     for (; k &lt; final; k++)
234         array[k] = value;
235     return array;
236 }
237 
238 function find(callback /*, thisArg */)
239 {
240     &quot;use strict&quot;;
241 
242     var array = @toObject(this, &quot;Array.prototype.find requires that |this| not be null or undefined&quot;);
243     var length = @toLength(array.length);
244 
245     if (typeof callback !== &quot;function&quot;)
246         @throwTypeError(&quot;Array.prototype.find callback must be a function&quot;);
247     
248     var thisArg = @argument(1);
249     for (var i = 0; i &lt; length; i++) {
250         var kValue = array[i];
251         if (callback.@call(thisArg, kValue, i, array))
252             return kValue;
253     }
254     return @undefined;
255 }
256 
257 function findIndex(callback /*, thisArg */)
258 {
259     &quot;use strict&quot;;
260 
261     var array = @toObject(this, &quot;Array.prototype.findIndex requires that |this| not be null or undefined&quot;);
262     var length = @toLength(array.length);
263 
264     if (typeof callback !== &quot;function&quot;)
265         @throwTypeError(&quot;Array.prototype.findIndex callback must be a function&quot;);
266     
267     var thisArg = @argument(1);
268     for (var i = 0; i &lt; length; i++) {
269         if (callback.@call(thisArg, array[i], i, array))
270             return i;
271     }
272     return -1;
273 }
274 
275 function includes(searchElement /*, fromIndex*/)
276 {
277     &quot;use strict&quot;;
278 
279     var array = @toObject(this, &quot;Array.prototype.includes requires that |this| not be null or undefined&quot;);
280     var length = @toLength(array.length);
281 
282     if (length === 0)
283         return false;
284 
285     var fromIndex = 0;
286     var from = @argument(1);
287     if (from !== @undefined)
288         fromIndex = @toInteger(from);
289 
290     var index;
291     if (fromIndex &gt;= 0)
292         index = fromIndex;
293     else
294         index = length + fromIndex;
295 
296     if (index &lt; 0)
297         index = 0;
298 
299     var currentElement;
300     for (; index &lt; length; ++index) {
301         currentElement = array[index];
302         // Use SameValueZero comparison, rather than just StrictEquals.
303         if (searchElement === currentElement || (searchElement !== searchElement &amp;&amp; currentElement !== currentElement))
304             return true;
305     }
306     return false;
307 }
308 
309 function sort(comparator)
310 {
311     &quot;use strict&quot;;
312 
313     function min(a, b)
314     {
315         return a &lt; b ? a : b;
316     }
317 
318     function stringComparator(a, b)
319     {
320         var aString = a.string;
321         var bString = b.string;
322 
323         var aLength = aString.length;
324         var bLength = bString.length;
325         var length = min(aLength, bLength);
326 
327         for (var i = 0; i &lt; length; ++i) {
328             var aCharCode = aString.@charCodeAt(i);
329             var bCharCode = bString.@charCodeAt(i);
330 
331             if (aCharCode == bCharCode)
332                 continue;
333 
334             return aCharCode - bCharCode;
335         }
336 
337         return aLength - bLength;
338     }
339 
340     // Move undefineds and holes to the end of a sparse array. Result is [values..., undefineds..., holes...].
341     function compactSparse(array, dst, src, length)
342     {
343         var values = [ ];
344         var seen = { };
345         var valueCount = 0;
346         var undefinedCount = 0;
347 
348         // Clean up after the in-progress non-sparse compaction that failed.
349         for (var i = dst; i &lt; src; ++i)
350             delete array[i];
351 
352         for (var object = array; object; object = @Object.@getPrototypeOf(object)) {
353             var propertyNames = @Object.@getOwnPropertyNames(object);
354             for (var i = 0; i &lt; propertyNames.length; ++i) {
355                 var index = propertyNames[i];
356                 if (index &lt; length) { // Exclude non-numeric properties and properties past length.
357                     if (seen[index]) // Exclude duplicates.
358                         continue;
359                     seen[index] = 1;
360 
361                     var value = array[index];
362                     delete array[index];
363 
364                     if (value === @undefined) {
365                         ++undefinedCount;
366                         continue;
367                     }
368 
369                     array[valueCount++] = value;
370                 }
371             }
372         }
373 
374         for (var i = valueCount; i &lt; valueCount + undefinedCount; ++i)
375             array[i] = @undefined;
376 
377         return valueCount;
378     }
379 
380     function compactSlow(array, length)
381     {
382         var holeCount = 0;
383 
384         var dst = 0;
385         var src = 0;
386         for (; src &lt; length; ++src) {
387             if (!(src in array)) {
388                 ++holeCount;
389                 if (holeCount &lt; 256)
390                     continue;
391                 return compactSparse(array, dst, src, length);
392             }
393 
394             var value = array[src];
395             if (value === @undefined)
396                 continue;
397 
398             array[dst++] = value;
399         }
400 
401         var valueCount = dst;
402         var undefinedCount = length - valueCount - holeCount;
403 
404         for (var i = valueCount; i &lt; valueCount + undefinedCount; ++i)
405             array[i] = @undefined;
406 
407         for (var i = valueCount + undefinedCount; i &lt; length; ++i)
408             delete array[i];
409 
410         return valueCount;
411     }
412 
413     // Move undefineds and holes to the end of an array. Result is [values..., undefineds..., holes...].
414     function compact(array, length)
415     {
416         for (var i = 0; i &lt; array.length; ++i) {
417             if (array[i] === @undefined)
418                 return compactSlow(array, length);
419         }
420 
421         return length;
422     }
423 
424     function merge(dst, src, srcIndex, srcEnd, width, comparator)
425     {
426         var left = srcIndex;
427         var leftEnd = min(left + width, srcEnd);
428         var right = leftEnd;
429         var rightEnd = min(right + width, srcEnd);
430 
431         for (var dstIndex = left; dstIndex &lt; rightEnd; ++dstIndex) {
432             if (right &lt; rightEnd) {
433                 if (left &gt;= leftEnd) {
434                     dst[dstIndex] = src[right++];
435                     continue;
436                 }
437 
438                 var comparisonResult = comparator(src[right], src[left]);
439                 if ((typeof comparisonResult === &quot;boolean&quot; &amp;&amp; !comparisonResult) || comparisonResult &lt; 0) {
440                     dst[dstIndex] = src[right++];
441                     continue;
442                 }
443 
444             }
445 
446             dst[dstIndex] = src[left++];
447         }
448     }
449 
450     function mergeSort(array, valueCount, comparator)
451     {
452         var buffer = [ ];
453         buffer.length = valueCount;
454 
455         var dst = buffer;
456         var src = array;
457         for (var width = 1; width &lt; valueCount; width *= 2) {
458             for (var srcIndex = 0; srcIndex &lt; valueCount; srcIndex += 2 * width)
459                 merge(dst, src, srcIndex, valueCount, width, comparator);
460 
461             var tmp = src;
462             src = dst;
463             dst = tmp;
464         }
465 
466         if (src != array) {
467             for(var i = 0; i &lt; valueCount; i++)
468                 array[i] = src[i];
469         }
470     }
471 
472     function bucketSort(array, dst, bucket, depth)
473     {
474         if (bucket.length &lt; 32 || depth &gt; 32) {
475             mergeSort(bucket, bucket.length, stringComparator);
476             for (var i = 0; i &lt; bucket.length; ++i)
477                 array[dst++] = bucket[i].value;
478             return dst;
479         }
480 
481         var buckets = [ ];
482         for (var i = 0; i &lt; bucket.length; ++i) {
483             var entry = bucket[i];
484             var string = entry.string;
485             if (string.length == depth) {
486                 array[dst++] = entry.value;
487                 continue;
488             }
489 
490             var c = string.@charCodeAt(depth);
491             if (!buckets[c])
492                 buckets[c] = [ ];
493             buckets[c][buckets[c].length] = entry;
494         }
495 
496         for (var i = 0; i &lt; buckets.length; ++i) {
497             if (!buckets[i])
498                 continue;
499             dst = bucketSort(array, dst, buckets[i], depth + 1);
500         }
501 
502         return dst;
503     }
504 
505     function comparatorSort(array, length, comparator)
506     {
507         var valueCount = compact(array, length);
508         mergeSort(array, valueCount, comparator);
509     }
510 
511     function stringSort(array, length)
512     {
513         var valueCount = compact(array, length);
514 
515         var strings = @newArrayWithSize(valueCount);
516         for (var i = 0; i &lt; valueCount; ++i)
517             strings[i] = { string: @toString(array[i]), value: array[i] };
518 
519         bucketSort(array, 0, strings, 0);
520     }
521 
522     var sortFunction;
523     if (typeof comparator == &quot;function&quot;)
524         sortFunction = comparatorSort;
525     else if (comparator === @undefined)
526         sortFunction = stringSort;
527     else
528         @throwTypeError(&quot;Array.prototype.sort requires the comparsion function be a function or undefined&quot;);
529 
530     var array = @toObject(this, &quot;Array.prototype.sort requires that |this| not be null or undefined&quot;);
531 
532     var length = @toLength(array.length);
533 
534     // For compatibility with Firefox and Chrome, do nothing observable
535     // to the target array if it has 0 or 1 sortable properties.
536     if (length &lt; 2)
537         return array;
538 
539     sortFunction(array, length, comparator);
540     return array;
541 }
542 
543 @globalPrivate
544 function concatSlowPath()
545 {
546     &quot;use strict&quot;;
547 
548     var currentElement = @toObject(this, &quot;Array.prototype.concat requires that |this| not be null or undefined&quot;);
549     var argCount = arguments.length;
550 
551     var result = @arraySpeciesCreate(currentElement, 0);
552     var resultIsArray = @isJSArray(result);
553 
554     var resultIndex = 0;
555     var argIndex = 0;
556 
557     do {
558         var spreadable = @isObject(currentElement) &amp;&amp; currentElement.@isConcatSpreadableSymbol;
559         if ((spreadable === @undefined &amp;&amp; @isArray(currentElement)) || spreadable) {
560             var length = @toLength(currentElement.length);
561             if (length + resultIndex &gt; @MAX_ARRAY_INDEX)
562                 @throwRangeError(&quot;Length exceeded the maximum array length&quot;);
563             if (resultIsArray &amp;&amp; @isJSArray(currentElement)) {
564                 @appendMemcpy(result, currentElement, resultIndex);
565                 resultIndex += length;
566             } else {
567                 for (var i = 0; i &lt; length; i++) {
568                     if (i in currentElement)
569                         @putByValDirect(result, resultIndex, currentElement[i]);
570                     resultIndex++;
571                 }
572             }
573         } else {
574             if (resultIndex &gt;= @MAX_ARRAY_INDEX)
575                 @throwRangeError(&quot;Length exceeded the maximum array length&quot;);
576             @putByValDirect(result, resultIndex++, currentElement);
577         }
578         currentElement = arguments[argIndex];
579     } while (argIndex++ &lt; argCount);
580 
581     result.length = resultIndex;
582     return result;
583 }
584 
585 function concat(first)
586 {
587     &quot;use strict&quot;;
588 
589     if (@argumentCount() === 1
590         &amp;&amp; @isJSArray(this)
591         &amp;&amp; this.@isConcatSpreadableSymbol === @undefined
592         &amp;&amp; (!@isObject(first) || (!@isProxyObject(first) &amp;&amp; first.@isConcatSpreadableSymbol === @undefined))) {
593 
594         var result = @concatMemcpy(this, first);
595         if (result !== null)
596             return result;
597     }
598 
599     return @tailCallForwardArguments(@concatSlowPath, this);
600 }
601 
602 function copyWithin(target, start /*, end */)
603 {
604     &quot;use strict&quot;;
605 
606     function maxWithPositives(a, b)
607     {
608         return (a &lt; b) ? b : a;
609     }
610 
611     function minWithMaybeNegativeZeroAndPositive(maybeNegativeZero, positive)
612     {
613         return (maybeNegativeZero &lt; positive) ? maybeNegativeZero : positive;
614     }
615 
616     var array = @toObject(this, &quot;Array.prototype.copyWithin requires that |this| not be null or undefined&quot;);
617     var length = @toLength(array.length);
618 
619     var relativeTarget = @toInteger(target);
620     var to = (relativeTarget &lt; 0) ? maxWithPositives(length + relativeTarget, 0) : minWithMaybeNegativeZeroAndPositive(relativeTarget, length);
621 
622     var relativeStart = @toInteger(start);
623     var from = (relativeStart &lt; 0) ? maxWithPositives(length + relativeStart, 0) : minWithMaybeNegativeZeroAndPositive(relativeStart, length);
624 
625     var relativeEnd;
626     var end = @argument(2);
627     if (end === @undefined)
628         relativeEnd = length;
629     else
630         relativeEnd = @toInteger(end);
631 
632     var finalValue = (relativeEnd &lt; 0) ? maxWithPositives(length + relativeEnd, 0) : minWithMaybeNegativeZeroAndPositive(relativeEnd, length);
633 
634     var count = minWithMaybeNegativeZeroAndPositive(finalValue - from, length - to);
635 
636     var direction = 1;
637     if (from &lt; to &amp;&amp; to &lt; from + count) {
638         direction = -1;
639         from = from + count - 1;
640         to = to + count - 1;
641     }
642 
643     for (var i = 0; i &lt; count; ++i, from += direction, to += direction) {
644         if (from in array)
645             array[to] = array[from];
646         else
647             delete array[to];
648     }
649 
650     return array;
651 }
652 
653 @globalPrivate
654 function flatIntoArray(target, source, sourceLength, targetIndex, depth)
655 {
656     &quot;use strict&quot;;
657 
658     for (var sourceIndex = 0; sourceIndex &lt; sourceLength; ++sourceIndex) {
659         if (sourceIndex in source) {
660             var element = source[sourceIndex];
661             if (depth &gt; 0 &amp;&amp; @isArray(element))
662                 targetIndex = @flatIntoArray(target, element, @toLength(element.length), targetIndex, depth - 1);
663             else {
664                 if (targetIndex &gt;= @MAX_SAFE_INTEGER)
665                     @throwTypeError(&quot;flatten array exceeds 2**53 - 1&quot;);
666                 @putByValDirect(target, targetIndex, element);
667                 ++targetIndex;
668             }
669         }
670     }
671     return targetIndex;
672 }
673 
674 function flat()
675 {
676     &quot;use strict&quot;;
677 
678     var array = @toObject(this, &quot;Array.prototype.flat requires that |this| not be null or undefined&quot;);
679     var length = @toLength(array.length);
680 
681     var depthNum = 1;
682     var depth = @argument(0);
683     if (depth !== @undefined)
684         depthNum = @toInteger(depth);
685 
686     var result = @arraySpeciesCreate(array, 0);
687 
688     @flatIntoArray(result, array, length, 0, depthNum);
689     return result;
690 }
691 
692 @globalPrivate
693 function flatIntoArrayWithCallback(target, source, sourceLength, targetIndex, callback, thisArg)
694 {
695     &quot;use strict&quot;;
696 
697     for (var sourceIndex = 0; sourceIndex &lt; sourceLength; ++sourceIndex) {
698         if (sourceIndex in source) {
699             var element = callback.@call(thisArg, source[sourceIndex], sourceIndex, source);
700             if (@isArray(element))
701                 targetIndex = @flatIntoArray(target, element, @toLength(element.length), targetIndex, 0);
702             else {
703                 if (targetIndex &gt;= @MAX_SAFE_INTEGER)
704                     @throwTypeError(&quot;flatten array exceeds 2**53 - 1&quot;);
705                 @putByValDirect(target, targetIndex, element);
706                 ++targetIndex;
707             }
708         }
709     }
710     return target;
711 }
712 
713 function flatMap(callback)
714 {
715     &quot;use strict&quot;;
716 
717     var array = @toObject(this, &quot;Array.prototype.flatMap requires that |this| not be null or undefined&quot;);
718     var length = @toLength(array.length);
719 
720     if (typeof callback !== &quot;function&quot;)
721         @throwTypeError(&quot;Array.prototype.flatMap callback must be a function&quot;);
722 
723     var thisArg = @argument(1);
724 
725     var result = @arraySpeciesCreate(array, 0);
726 
727     return @flatIntoArrayWithCallback(result, array, length, 0, callback, thisArg);
728 }
    </pre>
  </body>
</html>
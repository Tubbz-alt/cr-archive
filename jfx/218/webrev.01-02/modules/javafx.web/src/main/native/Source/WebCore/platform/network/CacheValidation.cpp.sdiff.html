<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/network/CacheValidation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BlobRegistryImpl.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CacheValidation.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/network/CacheValidation.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
296                 }
297                 bool ok;
298                 double maxAge = directives[i].second.toDouble(&amp;ok);
299                 if (ok)
300                     result.maxAge = Seconds { maxAge };
301             } else if (equalLettersIgnoringASCIICase(directives[i].first, &quot;max-stale&quot;)) {
302                 // https://tools.ietf.org/html/rfc7234#section-5.2.1.2
303                 if (result.maxStale) {
304                     // First max-stale directive wins if there are multiple ones.
305                     continue;
306                 }
307                 if (directives[i].second.isEmpty()) {
308                     // if no value is assigned to max-stale, then the client is willing to accept a stale response of any age.
309                     result.maxStale = Seconds::infinity();
310                     continue;
311                 }
312                 bool ok;
313                 double maxStale = directives[i].second.toDouble(&amp;ok);
314                 if (ok)
315                     result.maxStale = Seconds { maxStale };
<span class="line-modified">316             } else if (equalLettersIgnoringASCIICase(directives[i].first, &quot;immutable&quot;))</span>
317                 result.immutable = true;










318         }
319     }
320 
321     if (!result.noCache) {
322         // Handle Pragma: no-cache
323         // This is deprecated and equivalent to Cache-control: no-cache
324         // Don&#39;t bother tokenizing the value; handling that exactly right is not important.
325         result.noCache = headers.get(HTTPHeaderName::Pragma).containsIgnoringASCIICase(&quot;no-cache&quot;);
326     }
327 
328     return result;
329 }
330 
331 static String cookieRequestHeaderFieldValue(const NetworkStorageSession&amp; session, const ResourceRequest&amp; request)
332 {
<span class="line-modified">333     return session.cookieRequestHeaderFieldValue(request.firstPartyForCookies(), SameSiteInfo::create(request), request.url(), WTF::nullopt, WTF::nullopt, request.url().protocolIs(&quot;https&quot;) ? IncludeSecureCookies::Yes : IncludeSecureCookies::No).first;</span>
334 }
335 
<span class="line-modified">336 static String cookieRequestHeaderFieldValue(const CookieJar* cookieJar, const PAL::SessionID&amp; sessionID, const ResourceRequest&amp; request)</span>
337 {
338     if (!cookieJar)
339         return { };
340 
<span class="line-modified">341     return cookieJar-&gt;cookieRequestHeaderFieldValue(sessionID, request.firstPartyForCookies(), SameSiteInfo::create(request), request.url(), WTF::nullopt, WTF::nullopt, request.url().protocolIs(&quot;https&quot;) ? IncludeSecureCookies::Yes : IncludeSecureCookies::No).first;</span>
342 }
343 
344 static String headerValueForVary(const ResourceRequest&amp; request, const String&amp; headerName, Function&lt;String()&gt;&amp;&amp; cookieRequestHeaderFieldValueFunction)
345 {
346     // Explicit handling for cookies is needed because they are added magically by the networking layer.
347     // FIXME: The value might have changed between making the request and retrieving the cookie here.
348     // We could fetch the cookie when making the request but that seems overkill as the case is very rare and it
349     // is a blocking operation. This should be sufficient to cover reasonable cases.
350     if (headerName == httpHeaderNameString(HTTPHeaderName::Cookie))
351         return cookieRequestHeaderFieldValueFunction();
352     return request.httpHeaderField(headerName);
353 }
354 
355 static Vector&lt;std::pair&lt;String, String&gt;&gt; collectVaryingRequestHeadersInternal(const ResourceResponse&amp; response, Function&lt;String(const String&amp; headerName)&gt;&amp;&amp; headerValueForVaryFunction)
356 {
357     String varyValue = response.httpHeaderField(HTTPHeaderName::Vary);
358     if (varyValue.isEmpty())
359         return { };
360     Vector&lt;String&gt; varyingHeaderNames = varyValue.split(&#39;,&#39;);
361     Vector&lt;std::pair&lt;String, String&gt;&gt; varyingRequestHeaders;
362     varyingRequestHeaders.reserveCapacity(varyingHeaderNames.size());
363     for (auto&amp; varyHeaderName : varyingHeaderNames) {
364         String headerName = varyHeaderName.stripWhiteSpace();
365         String headerValue = headerValueForVaryFunction(headerName);
366         varyingRequestHeaders.append(std::make_pair(headerName, headerValue));
367     }
368     return varyingRequestHeaders;
369 }
370 
<span class="line-modified">371 Vector&lt;std::pair&lt;String, String&gt;&gt; collectVaryingRequestHeaders(NetworkStorageSession&amp; storageSession, const ResourceRequest&amp; request, const ResourceResponse&amp; response)</span>
372 {


373     return collectVaryingRequestHeadersInternal(response, [&amp;] (const String&amp; headerName) {
374         return headerValueForVary(request, headerName, [&amp;] {
<span class="line-modified">375             return cookieRequestHeaderFieldValue(storageSession, request);</span>
376         });
377     });
378 }
379 
<span class="line-modified">380 Vector&lt;std::pair&lt;String, String&gt;&gt; collectVaryingRequestHeaders(const CookieJar* cookieJar, const ResourceRequest&amp; request, const ResourceResponse&amp; response, const PAL::SessionID&amp; sessionID)</span>
381 {
382     return collectVaryingRequestHeadersInternal(response, [&amp;] (const String&amp; headerName) {
383         return headerValueForVary(request, headerName, [&amp;] {
<span class="line-modified">384             return cookieRequestHeaderFieldValue(cookieJar, sessionID, request);</span>
385         });
386     });
387 }
388 
389 static bool verifyVaryingRequestHeadersInternal(const Vector&lt;std::pair&lt;String, String&gt;&gt;&amp; varyingRequestHeaders, Function&lt;String(const String&amp;)&gt;&amp;&amp; headerValueForVary)
390 {
391     for (auto&amp; varyingRequestHeader : varyingRequestHeaders) {
392         // FIXME: Vary: * in response would ideally trigger a cache delete instead of a store.
393         if (varyingRequestHeader.first == &quot;*&quot;)
394             return false;
395         if (headerValueForVary(varyingRequestHeader.first) != varyingRequestHeader.second)
396             return false;
397     }
398     return true;
399 }
400 
<span class="line-modified">401 bool verifyVaryingRequestHeaders(NetworkStorageSession&amp; storageSession, const Vector&lt;std::pair&lt;String, String&gt;&gt;&amp; varyingRequestHeaders, const ResourceRequest&amp; request)</span>
402 {


403     return verifyVaryingRequestHeadersInternal(varyingRequestHeaders, [&amp;] (const String&amp; headerName) {
404         return headerValueForVary(request, headerName, [&amp;] {
<span class="line-modified">405             return cookieRequestHeaderFieldValue(storageSession, request);</span>
406         });
407     });
408 }
409 
<span class="line-modified">410 bool verifyVaryingRequestHeaders(const CookieJar* cookieJar, const Vector&lt;std::pair&lt;String, String&gt;&gt;&amp; varyingRequestHeaders, const ResourceRequest&amp; request, const PAL::SessionID&amp; sessionID)</span>
411 {
412     return verifyVaryingRequestHeadersInternal(varyingRequestHeaders, [&amp;] (const String&amp; headerName) {
413         return headerValueForVary(request, headerName, [&amp;] {
<span class="line-modified">414             return cookieRequestHeaderFieldValue(cookieJar, sessionID, request);</span>
415         });
416     });
417 }
418 
419 // http://tools.ietf.org/html/rfc7231#page-48
420 bool isStatusCodeCacheableByDefault(int statusCode)
421 {
422     switch (statusCode) {
423     case 200: // OK
424     case 203: // Non-Authoritative Information
425     case 204: // No Content
426     case 206: // Partial Content
427     case 300: // Multiple Choices
428     case 301: // Moved Permanently
429     case 404: // Not Found
430     case 405: // Method Not Allowed
431     case 410: // Gone
432     case 414: // URI Too Long
433     case 501: // Not Implemented
434         return true;
</pre>
</td>
<td>
<hr />
<pre>
296                 }
297                 bool ok;
298                 double maxAge = directives[i].second.toDouble(&amp;ok);
299                 if (ok)
300                     result.maxAge = Seconds { maxAge };
301             } else if (equalLettersIgnoringASCIICase(directives[i].first, &quot;max-stale&quot;)) {
302                 // https://tools.ietf.org/html/rfc7234#section-5.2.1.2
303                 if (result.maxStale) {
304                     // First max-stale directive wins if there are multiple ones.
305                     continue;
306                 }
307                 if (directives[i].second.isEmpty()) {
308                     // if no value is assigned to max-stale, then the client is willing to accept a stale response of any age.
309                     result.maxStale = Seconds::infinity();
310                     continue;
311                 }
312                 bool ok;
313                 double maxStale = directives[i].second.toDouble(&amp;ok);
314                 if (ok)
315                     result.maxStale = Seconds { maxStale };
<span class="line-modified">316             } else if (equalLettersIgnoringASCIICase(directives[i].first, &quot;immutable&quot;)) {</span>
317                 result.immutable = true;
<span class="line-added">318             } else if (equalLettersIgnoringASCIICase(directives[i].first, &quot;stale-while-revalidate&quot;)) {</span>
<span class="line-added">319                 if (result.staleWhileRevalidate) {</span>
<span class="line-added">320                     // First stale-while-revalidate directive wins if there are multiple ones.</span>
<span class="line-added">321                     continue;</span>
<span class="line-added">322                 }</span>
<span class="line-added">323                 bool ok;</span>
<span class="line-added">324                 double staleWhileRevalidate = directives[i].second.toDouble(&amp;ok);</span>
<span class="line-added">325                 if (ok)</span>
<span class="line-added">326                     result.staleWhileRevalidate = Seconds { staleWhileRevalidate };</span>
<span class="line-added">327             }</span>
328         }
329     }
330 
331     if (!result.noCache) {
332         // Handle Pragma: no-cache
333         // This is deprecated and equivalent to Cache-control: no-cache
334         // Don&#39;t bother tokenizing the value; handling that exactly right is not important.
335         result.noCache = headers.get(HTTPHeaderName::Pragma).containsIgnoringASCIICase(&quot;no-cache&quot;);
336     }
337 
338     return result;
339 }
340 
341 static String cookieRequestHeaderFieldValue(const NetworkStorageSession&amp; session, const ResourceRequest&amp; request)
342 {
<span class="line-modified">343     return session.cookieRequestHeaderFieldValue(request.firstPartyForCookies(), SameSiteInfo::create(request), request.url(), WTF::nullopt, WTF::nullopt, request.url().protocolIs(&quot;https&quot;) ? IncludeSecureCookies::Yes : IncludeSecureCookies::No, ShouldAskITP::Yes).first;</span>
344 }
345 
<span class="line-modified">346 static String cookieRequestHeaderFieldValue(const CookieJar* cookieJar, const ResourceRequest&amp; request)</span>
347 {
348     if (!cookieJar)
349         return { };
350 
<span class="line-modified">351     return cookieJar-&gt;cookieRequestHeaderFieldValue(request.firstPartyForCookies(), SameSiteInfo::create(request), request.url(), WTF::nullopt, WTF::nullopt, request.url().protocolIs(&quot;https&quot;) ? IncludeSecureCookies::Yes : IncludeSecureCookies::No).first;</span>
352 }
353 
354 static String headerValueForVary(const ResourceRequest&amp; request, const String&amp; headerName, Function&lt;String()&gt;&amp;&amp; cookieRequestHeaderFieldValueFunction)
355 {
356     // Explicit handling for cookies is needed because they are added magically by the networking layer.
357     // FIXME: The value might have changed between making the request and retrieving the cookie here.
358     // We could fetch the cookie when making the request but that seems overkill as the case is very rare and it
359     // is a blocking operation. This should be sufficient to cover reasonable cases.
360     if (headerName == httpHeaderNameString(HTTPHeaderName::Cookie))
361         return cookieRequestHeaderFieldValueFunction();
362     return request.httpHeaderField(headerName);
363 }
364 
365 static Vector&lt;std::pair&lt;String, String&gt;&gt; collectVaryingRequestHeadersInternal(const ResourceResponse&amp; response, Function&lt;String(const String&amp; headerName)&gt;&amp;&amp; headerValueForVaryFunction)
366 {
367     String varyValue = response.httpHeaderField(HTTPHeaderName::Vary);
368     if (varyValue.isEmpty())
369         return { };
370     Vector&lt;String&gt; varyingHeaderNames = varyValue.split(&#39;,&#39;);
371     Vector&lt;std::pair&lt;String, String&gt;&gt; varyingRequestHeaders;
372     varyingRequestHeaders.reserveCapacity(varyingHeaderNames.size());
373     for (auto&amp; varyHeaderName : varyingHeaderNames) {
374         String headerName = varyHeaderName.stripWhiteSpace();
375         String headerValue = headerValueForVaryFunction(headerName);
376         varyingRequestHeaders.append(std::make_pair(headerName, headerValue));
377     }
378     return varyingRequestHeaders;
379 }
380 
<span class="line-modified">381 Vector&lt;std::pair&lt;String, String&gt;&gt; collectVaryingRequestHeaders(NetworkStorageSession* storageSession, const ResourceRequest&amp; request, const ResourceResponse&amp; response)</span>
382 {
<span class="line-added">383     if (!storageSession)</span>
<span class="line-added">384         return { };</span>
385     return collectVaryingRequestHeadersInternal(response, [&amp;] (const String&amp; headerName) {
386         return headerValueForVary(request, headerName, [&amp;] {
<span class="line-modified">387             return cookieRequestHeaderFieldValue(*storageSession, request);</span>
388         });
389     });
390 }
391 
<span class="line-modified">392 Vector&lt;std::pair&lt;String, String&gt;&gt; collectVaryingRequestHeaders(const CookieJar* cookieJar, const ResourceRequest&amp; request, const ResourceResponse&amp; response)</span>
393 {
394     return collectVaryingRequestHeadersInternal(response, [&amp;] (const String&amp; headerName) {
395         return headerValueForVary(request, headerName, [&amp;] {
<span class="line-modified">396             return cookieRequestHeaderFieldValue(cookieJar, request);</span>
397         });
398     });
399 }
400 
401 static bool verifyVaryingRequestHeadersInternal(const Vector&lt;std::pair&lt;String, String&gt;&gt;&amp; varyingRequestHeaders, Function&lt;String(const String&amp;)&gt;&amp;&amp; headerValueForVary)
402 {
403     for (auto&amp; varyingRequestHeader : varyingRequestHeaders) {
404         // FIXME: Vary: * in response would ideally trigger a cache delete instead of a store.
405         if (varyingRequestHeader.first == &quot;*&quot;)
406             return false;
407         if (headerValueForVary(varyingRequestHeader.first) != varyingRequestHeader.second)
408             return false;
409     }
410     return true;
411 }
412 
<span class="line-modified">413 bool verifyVaryingRequestHeaders(NetworkStorageSession* storageSession, const Vector&lt;std::pair&lt;String, String&gt;&gt;&amp; varyingRequestHeaders, const ResourceRequest&amp; request)</span>
414 {
<span class="line-added">415     if (!storageSession)</span>
<span class="line-added">416         return false;</span>
417     return verifyVaryingRequestHeadersInternal(varyingRequestHeaders, [&amp;] (const String&amp; headerName) {
418         return headerValueForVary(request, headerName, [&amp;] {
<span class="line-modified">419             return cookieRequestHeaderFieldValue(*storageSession, request);</span>
420         });
421     });
422 }
423 
<span class="line-modified">424 bool verifyVaryingRequestHeaders(const CookieJar* cookieJar, const Vector&lt;std::pair&lt;String, String&gt;&gt;&amp; varyingRequestHeaders, const ResourceRequest&amp; request)</span>
425 {
426     return verifyVaryingRequestHeadersInternal(varyingRequestHeaders, [&amp;] (const String&amp; headerName) {
427         return headerValueForVary(request, headerName, [&amp;] {
<span class="line-modified">428             return cookieRequestHeaderFieldValue(cookieJar, request);</span>
429         });
430     });
431 }
432 
433 // http://tools.ietf.org/html/rfc7231#page-48
434 bool isStatusCodeCacheableByDefault(int statusCode)
435 {
436     switch (statusCode) {
437     case 200: // OK
438     case 203: // Non-Authoritative Information
439     case 204: // No Content
440     case 206: // Partial Content
441     case 300: // Multiple Choices
442     case 301: // Moved Permanently
443     case 404: // Not Found
444     case 405: // Method Not Allowed
445     case 410: // Gone
446     case 414: // URI Too Long
447     case 501: // Not Implemented
448         return true;
</pre>
</td>
</tr>
</table>
<center><a href="BlobRegistryImpl.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CacheValidation.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
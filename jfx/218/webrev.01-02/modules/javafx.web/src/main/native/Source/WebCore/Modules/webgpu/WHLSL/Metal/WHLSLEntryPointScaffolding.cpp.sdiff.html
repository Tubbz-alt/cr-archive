<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLEntryPointScaffolding.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../AST/WHLSLType.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLEntryPointScaffolding.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLEntryPointScaffolding.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
122             }), m_layout[i].bindings[j].binding);
123             namedBindGroup.namedBindings.uncheckedAppend(WTFMove(namedBinding));
124         }
125         m_namedBindGroups.uncheckedAppend(WTFMove(namedBindGroup));
126     }
127 
128     for (size_t i = 0; i &lt; m_entryPointItems.inputs.size(); ++i) {
129         if (!WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(*m_entryPointItems.inputs[i].semantic))
130             continue;
131         NamedBuiltIn namedBuiltIn;
132         namedBuiltIn.indexInEntryPointItems = i;
133         namedBuiltIn.variableName = m_generateNextVariableName();
134         m_namedBuiltIns.append(WTFMove(namedBuiltIn));
135     }
136 
137     m_parameterVariables.reserveInitialCapacity(m_functionDefinition.parameters().size());
138     for (size_t i = 0; i &lt; m_functionDefinition.parameters().size(); ++i)
139         m_parameterVariables.uncheckedAppend(m_generateNextVariableName());
140 }
141 
<span class="line-modified">142 void EntryPointScaffolding::emitResourceHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
143 {
144     for (size_t i = 0; i &lt; m_layout.size(); ++i) {
145         stringBuilder.append(indent, &quot;struct &quot;, m_namedBindGroups[i].structName, &quot; {\n&quot;);
146         {
147             IndentationScope scope(indent);
148             Vector&lt;std::pair&lt;unsigned, String&gt;&gt; structItems;
149             for (size_t j = 0; j &lt; m_layout[i].bindings.size(); ++j) {
<span class="line-modified">150                 auto iterator = m_resourceMap.find(&amp;m_layout[i].bindings[j]);</span>
<span class="line-modified">151                 if (iterator == m_resourceMap.end())</span>
152                     continue;
<span class="line-modified">153                 auto&amp; type = m_entryPointItems.inputs[iterator-&gt;value].unnamedType-&gt;unifyNode();</span>
<span class="line-modified">154                 if (is&lt;AST::UnnamedType&gt;(type) &amp;&amp; is&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(type))) {</span>
<span class="line-modified">155                     auto&amp; referenceType = downcast&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(type));</span>
<span class="line-modified">156                     auto mangledTypeName = m_typeNamer.mangledNameForType(referenceType.elementType());</span>
<span class="line-modified">157                     auto addressSpace = toString(referenceType.addressSpace());</span>
<span class="line-modified">158                     auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;</span>
<span class="line-modified">159                     auto index = m_namedBindGroups[i].namedBindings[j].index;</span>
<span class="line-modified">160                     structItems.append(std::make_pair(index, makeString(addressSpace, &quot; &quot;, mangledTypeName, &quot;* &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-modified">161                     if (auto lengthInformation = m_namedBindGroups[i].namedBindings[j].lengthInformation)</span>
<span class="line-modified">162                         structItems.append(std::make_pair(lengthInformation-&gt;index, makeString(&quot;uint2 &quot;, lengthInformation-&gt;elementName, &quot; [[id(&quot;, lengthInformation-&gt;index, &quot;)]];&quot;)));</span>
<span class="line-modified">163                 } else if (is&lt;AST::NamedType&gt;(type) &amp;&amp; is&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(type))) {</span>
<span class="line-modified">164                     auto&amp; namedType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(type));</span>
<span class="line-modified">165                     auto mangledTypeName = m_typeNamer.mangledNameForType(namedType);</span>
<span class="line-modified">166                     auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;</span>
<span class="line-modified">167                     auto index = m_namedBindGroups[i].namedBindings[j].index;</span>
<span class="line-modified">168                     structItems.append(std::make_pair(index, makeString(mangledTypeName, &#39; &#39;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>


















169                 }
170             }
171             std::sort(structItems.begin(), structItems.end(), [](const std::pair&lt;unsigned, String&gt;&amp; left, const std::pair&lt;unsigned, String&gt;&amp; right) {
172                 return left.first &lt; right.first;
173             });
174             for (const auto&amp; structItem : structItems)
175                 stringBuilder.append(indent, structItem.second, &#39;\n&#39;);
176         }
177         stringBuilder.append(indent, &quot;};\n\n&quot;);
178     }
179 }
180 
181 bool EntryPointScaffolding::emitResourceSignature(StringBuilder&amp; stringBuilder, IncludePrecedingComma includePrecedingComma)
182 {
183     if (!m_layout.size())
184         return false;
185 
186     if (includePrecedingComma == IncludePrecedingComma::Yes)
187         stringBuilder.append(&quot;, &quot;);
188 
</pre>
<hr />
<pre>
408             auto attributeIndex = namedStageIn.attributeIndex;
409             stringBuilder.append(indent, mangledTypeName, &#39; &#39;, elementName, &quot; [[attribute(&quot;, attributeIndex, &quot;)]];\n&quot;);
410         }
411     }
412     stringBuilder.append(
413         indent, &quot;};\n\n&quot;,
414         indent, &quot;struct &quot;, m_returnStructName, &quot; {\n&quot;
415     );
416     {
417         IndentationScope scope(indent);
418         for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {
419             auto&amp; outputItem = m_entryPointItems.outputs[i];
420             auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;
421             auto elementName = m_namedOutputs[i].elementName;
422             auto attribute = attributeForSemantic(*outputItem.semantic);
423             stringBuilder.append(indent, internalTypeName, &#39; &#39;, elementName, &#39; &#39;, attribute, &quot;;\n&quot;);
424         }
425     }
426     stringBuilder.append(indent, &quot;};\n\n&quot;);
427 
<span class="line-modified">428     emitResourceHelperTypes(stringBuilder, indent);</span>
429 }
430 
431 void VertexEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)
432 {
433     stringBuilder.append(indent, &quot;vertex &quot;, m_returnStructName, &#39; &#39;, functionName, &#39;(&#39;, m_stageInStructName, &#39; &#39;, m_stageInParameterName, &quot; [[stage_in]]&quot;);
434     emitResourceSignature(stringBuilder, IncludePrecedingComma::Yes);
435     emitBuiltInsSignature(stringBuilder, IncludePrecedingComma::Yes);
436     stringBuilder.append(&quot;)\n&quot;);
437 }
438 
439 void VertexEntryPointScaffolding::emitUnpack(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)
440 {
441     emitUnpackResourcesAndNamedBuiltIns(stringBuilder, indent);
442 
443     for (auto&amp; namedStageIn : m_namedStageIns) {
444         auto&amp; path = m_entryPointItems.inputs[namedStageIn.indexInEntryPointItems].path;
445         auto&amp; elementName = namedStageIn.elementName;
446 
447         stringBuilder.append(indent);
448         emitMangledInputPath(stringBuilder, path);
</pre>
<hr />
<pre>
513             auto attributeIndex = namedStageIn.attributeIndex;
514             stringBuilder.append(indent, mangledTypeName, &#39; &#39;, elementName, &quot; [[user(user&quot;, attributeIndex, &quot;)]];\n&quot;);
515         }
516     }
517     stringBuilder.append(
518         indent, &quot;};\n\n&quot;,
519         indent, &quot;struct &quot;, m_returnStructName, &quot; {\n&quot;
520     );
521     {
522         IndentationScope scope(indent);
523         for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {
524             auto&amp; outputItem = m_entryPointItems.outputs[i];
525             auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;
526             auto elementName = m_namedOutputs[i].elementName;
527             auto attribute = attributeForSemantic(*outputItem.semantic);
528             stringBuilder.append(indent, internalTypeName, &#39; &#39;, elementName, &#39; &#39;, attribute, &quot;;\n&quot;);
529         }
530     }
531     stringBuilder.append(indent, &quot;};\n\n&quot;);
532 
<span class="line-modified">533     emitResourceHelperTypes(stringBuilder, indent);</span>
534 }
535 
536 void FragmentEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)
537 {
538     stringBuilder.append(indent, &quot;fragment &quot;, m_returnStructName, &#39; &#39;, functionName, &#39;(&#39;, m_stageInStructName, &#39; &#39;, m_stageInParameterName, &quot; [[stage_in]]&quot;);
539     emitResourceSignature(stringBuilder, IncludePrecedingComma::Yes);
540     emitBuiltInsSignature(stringBuilder, IncludePrecedingComma::Yes);
541     stringBuilder.append(&quot;)\n&quot;);
542 }
543 
544 void FragmentEntryPointScaffolding::emitUnpack(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)
545 {
546     emitUnpackResourcesAndNamedBuiltIns(stringBuilder, indent);
547 
548     for (auto&amp; namedStageIn : m_namedStageIns) {
549         auto&amp; path = m_entryPointItems.inputs[namedStageIn.indexInEntryPointItems].path;
550         auto&amp; elementName = namedStageIn.elementName;
551 
552         stringBuilder.append(indent);
553         emitMangledInputPath(stringBuilder, path);
</pre>
<hr />
<pre>
563         stringBuilder.append(indent, outputVariableName, &#39;.&#39;, elementName, &quot; = &quot;, inputVariableName, &quot;;\n&quot;);
564         return;
565     }
566     for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {
567         auto&amp; elementName = m_namedOutputs[i].elementName;
568         auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;
569         auto&amp; path = m_entryPointItems.outputs[i].path;
570         stringBuilder.append(indent, outputVariableName, &#39;.&#39;, elementName, &quot; = &quot;, internalTypeName, &#39;(&#39;, inputVariableName);
571         emitMangledOutputPath(stringBuilder, path);
572         stringBuilder.append(&quot;);\n&quot;);
573     }
574 }
575 
576 ComputeEntryPointScaffolding::ComputeEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, EntryPointItems&amp; entryPointItems, HashMap&lt;Binding*, size_t&gt;&amp; resourceMap, Layout&amp; layout, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName)
577     : EntryPointScaffolding(functionDefinition, intrinsics, typeNamer, entryPointItems, resourceMap, layout, WTFMove(generateNextVariableName))
578 {
579 }
580 
581 void ComputeEntryPointScaffolding::emitHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)
582 {
<span class="line-modified">583     emitResourceHelperTypes(stringBuilder, indent);</span>
584 }
585 
586 void ComputeEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)
587 {
588     stringBuilder.append(indent, &quot;kernel void &quot;, functionName, &#39;(&#39;);
589     bool addedToSignature = emitResourceSignature(stringBuilder, IncludePrecedingComma::No);
590     emitBuiltInsSignature(stringBuilder, addedToSignature ? IncludePrecedingComma::Yes : IncludePrecedingComma::No);
591     stringBuilder.append(&quot;)\n&quot;);
592 }
593 
594 void ComputeEntryPointScaffolding::emitUnpack(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)
595 {
596     emitUnpackResourcesAndNamedBuiltIns(stringBuilder, indent);
597 }
598 
599 void ComputeEntryPointScaffolding::emitPack(StringBuilder&amp;, MangledVariableName, MangledVariableName, Indentation&lt;4&gt;)
600 {
601     ASSERT_NOT_REACHED();
602 }
603 
</pre>
</td>
<td>
<hr />
<pre>
122             }), m_layout[i].bindings[j].binding);
123             namedBindGroup.namedBindings.uncheckedAppend(WTFMove(namedBinding));
124         }
125         m_namedBindGroups.uncheckedAppend(WTFMove(namedBindGroup));
126     }
127 
128     for (size_t i = 0; i &lt; m_entryPointItems.inputs.size(); ++i) {
129         if (!WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(*m_entryPointItems.inputs[i].semantic))
130             continue;
131         NamedBuiltIn namedBuiltIn;
132         namedBuiltIn.indexInEntryPointItems = i;
133         namedBuiltIn.variableName = m_generateNextVariableName();
134         m_namedBuiltIns.append(WTFMove(namedBuiltIn));
135     }
136 
137     m_parameterVariables.reserveInitialCapacity(m_functionDefinition.parameters().size());
138     for (size_t i = 0; i &lt; m_functionDefinition.parameters().size(); ++i)
139         m_parameterVariables.uncheckedAppend(m_generateNextVariableName());
140 }
141 
<span class="line-modified">142 void EntryPointScaffolding::emitResourceHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent, ShaderStage shaderStage)</span>
143 {
144     for (size_t i = 0; i &lt; m_layout.size(); ++i) {
145         stringBuilder.append(indent, &quot;struct &quot;, m_namedBindGroups[i].structName, &quot; {\n&quot;);
146         {
147             IndentationScope scope(indent);
148             Vector&lt;std::pair&lt;unsigned, String&gt;&gt; structItems;
149             for (size_t j = 0; j &lt; m_layout[i].bindings.size(); ++j) {
<span class="line-modified">150                 auto&amp; binding = m_layout[i].bindings[j];</span>
<span class="line-modified">151                 if (!binding.visibility.contains(shaderStage))</span>
152                     continue;
<span class="line-modified">153 </span>
<span class="line-modified">154                 auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;</span>
<span class="line-modified">155                 auto index = m_namedBindGroups[i].namedBindings[j].index;</span>
<span class="line-modified">156                 if (auto lengthInformation = m_namedBindGroups[i].namedBindings[j].lengthInformation)</span>
<span class="line-modified">157                     structItems.append(std::make_pair(lengthInformation-&gt;index, makeString(&quot;uint2 &quot;, lengthInformation-&gt;elementName, &quot; [[id(&quot;, lengthInformation-&gt;index, &quot;)]];&quot;)));</span>
<span class="line-modified">158 </span>
<span class="line-modified">159                 auto iterator = m_resourceMap.find(&amp;m_layout[i].bindings[j]);</span>
<span class="line-modified">160                 if (iterator != m_resourceMap.end()) {</span>
<span class="line-modified">161                     auto&amp; type = m_entryPointItems.inputs[iterator-&gt;value].unnamedType-&gt;unifyNode();</span>
<span class="line-modified">162                     if (is&lt;AST::UnnamedType&gt;(type) &amp;&amp; is&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(type))) {</span>
<span class="line-modified">163                         auto&amp; referenceType = downcast&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(type));</span>
<span class="line-modified">164                         auto mangledTypeName = m_typeNamer.mangledNameForType(referenceType.elementType());</span>
<span class="line-modified">165                         auto addressSpace = toString(referenceType.addressSpace());</span>
<span class="line-modified">166                         structItems.append(std::make_pair(index, makeString(addressSpace, &quot; &quot;, mangledTypeName, &quot;* &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-modified">167                     } else if (is&lt;AST::NamedType&gt;(type) &amp;&amp; is&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(type))) {</span>
<span class="line-modified">168                         auto&amp; namedType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(type));</span>
<span class="line-added">169                         auto mangledTypeName = m_typeNamer.mangledNameForType(namedType);</span>
<span class="line-added">170                         structItems.append(std::make_pair(index, makeString(mangledTypeName, &#39; &#39;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-added">171                     }</span>
<span class="line-added">172                 } else {</span>
<span class="line-added">173                     // The binding doesn&#39;t appear in the shader source.</span>
<span class="line-added">174                     // However, we must still emit a placeholder, so successive items in the argument buffer struct have the correct offset.</span>
<span class="line-added">175                     // Because the binding doesn&#39;t appear in the shader source, we don&#39;t know which exact type the bind point should have.</span>
<span class="line-added">176                     // Therefore, we must synthesize a type out of thin air.</span>
<span class="line-added">177                     WTF::visit(WTF::makeVisitor([&amp;](UniformBufferBinding) {</span>
<span class="line-added">178                         structItems.append(std::make_pair(index, makeString(&quot;constant void* &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-added">179                     }, [&amp;](SamplerBinding) {</span>
<span class="line-added">180                         structItems.append(std::make_pair(index, makeString(&quot;sampler &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-added">181                     }, [&amp;](TextureBinding) {</span>
<span class="line-added">182                         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=201384 We don&#39;t know which texture type the binding represents. This is no good very bad.</span>
<span class="line-added">183                         structItems.append(std::make_pair(index, makeString(&quot;texture2d&lt;float&gt; &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-added">184                     }, [&amp;](StorageBufferBinding) {</span>
<span class="line-added">185                         structItems.append(std::make_pair(index, makeString(&quot;device void* &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-added">186                     }), binding.binding);</span>
187                 }
188             }
189             std::sort(structItems.begin(), structItems.end(), [](const std::pair&lt;unsigned, String&gt;&amp; left, const std::pair&lt;unsigned, String&gt;&amp; right) {
190                 return left.first &lt; right.first;
191             });
192             for (const auto&amp; structItem : structItems)
193                 stringBuilder.append(indent, structItem.second, &#39;\n&#39;);
194         }
195         stringBuilder.append(indent, &quot;};\n\n&quot;);
196     }
197 }
198 
199 bool EntryPointScaffolding::emitResourceSignature(StringBuilder&amp; stringBuilder, IncludePrecedingComma includePrecedingComma)
200 {
201     if (!m_layout.size())
202         return false;
203 
204     if (includePrecedingComma == IncludePrecedingComma::Yes)
205         stringBuilder.append(&quot;, &quot;);
206 
</pre>
<hr />
<pre>
426             auto attributeIndex = namedStageIn.attributeIndex;
427             stringBuilder.append(indent, mangledTypeName, &#39; &#39;, elementName, &quot; [[attribute(&quot;, attributeIndex, &quot;)]];\n&quot;);
428         }
429     }
430     stringBuilder.append(
431         indent, &quot;};\n\n&quot;,
432         indent, &quot;struct &quot;, m_returnStructName, &quot; {\n&quot;
433     );
434     {
435         IndentationScope scope(indent);
436         for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {
437             auto&amp; outputItem = m_entryPointItems.outputs[i];
438             auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;
439             auto elementName = m_namedOutputs[i].elementName;
440             auto attribute = attributeForSemantic(*outputItem.semantic);
441             stringBuilder.append(indent, internalTypeName, &#39; &#39;, elementName, &#39; &#39;, attribute, &quot;;\n&quot;);
442         }
443     }
444     stringBuilder.append(indent, &quot;};\n\n&quot;);
445 
<span class="line-modified">446     emitResourceHelperTypes(stringBuilder, indent, ShaderStage::Vertex);</span>
447 }
448 
449 void VertexEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)
450 {
451     stringBuilder.append(indent, &quot;vertex &quot;, m_returnStructName, &#39; &#39;, functionName, &#39;(&#39;, m_stageInStructName, &#39; &#39;, m_stageInParameterName, &quot; [[stage_in]]&quot;);
452     emitResourceSignature(stringBuilder, IncludePrecedingComma::Yes);
453     emitBuiltInsSignature(stringBuilder, IncludePrecedingComma::Yes);
454     stringBuilder.append(&quot;)\n&quot;);
455 }
456 
457 void VertexEntryPointScaffolding::emitUnpack(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)
458 {
459     emitUnpackResourcesAndNamedBuiltIns(stringBuilder, indent);
460 
461     for (auto&amp; namedStageIn : m_namedStageIns) {
462         auto&amp; path = m_entryPointItems.inputs[namedStageIn.indexInEntryPointItems].path;
463         auto&amp; elementName = namedStageIn.elementName;
464 
465         stringBuilder.append(indent);
466         emitMangledInputPath(stringBuilder, path);
</pre>
<hr />
<pre>
531             auto attributeIndex = namedStageIn.attributeIndex;
532             stringBuilder.append(indent, mangledTypeName, &#39; &#39;, elementName, &quot; [[user(user&quot;, attributeIndex, &quot;)]];\n&quot;);
533         }
534     }
535     stringBuilder.append(
536         indent, &quot;};\n\n&quot;,
537         indent, &quot;struct &quot;, m_returnStructName, &quot; {\n&quot;
538     );
539     {
540         IndentationScope scope(indent);
541         for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {
542             auto&amp; outputItem = m_entryPointItems.outputs[i];
543             auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;
544             auto elementName = m_namedOutputs[i].elementName;
545             auto attribute = attributeForSemantic(*outputItem.semantic);
546             stringBuilder.append(indent, internalTypeName, &#39; &#39;, elementName, &#39; &#39;, attribute, &quot;;\n&quot;);
547         }
548     }
549     stringBuilder.append(indent, &quot;};\n\n&quot;);
550 
<span class="line-modified">551     emitResourceHelperTypes(stringBuilder, indent, ShaderStage::Fragment);</span>
552 }
553 
554 void FragmentEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)
555 {
556     stringBuilder.append(indent, &quot;fragment &quot;, m_returnStructName, &#39; &#39;, functionName, &#39;(&#39;, m_stageInStructName, &#39; &#39;, m_stageInParameterName, &quot; [[stage_in]]&quot;);
557     emitResourceSignature(stringBuilder, IncludePrecedingComma::Yes);
558     emitBuiltInsSignature(stringBuilder, IncludePrecedingComma::Yes);
559     stringBuilder.append(&quot;)\n&quot;);
560 }
561 
562 void FragmentEntryPointScaffolding::emitUnpack(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)
563 {
564     emitUnpackResourcesAndNamedBuiltIns(stringBuilder, indent);
565 
566     for (auto&amp; namedStageIn : m_namedStageIns) {
567         auto&amp; path = m_entryPointItems.inputs[namedStageIn.indexInEntryPointItems].path;
568         auto&amp; elementName = namedStageIn.elementName;
569 
570         stringBuilder.append(indent);
571         emitMangledInputPath(stringBuilder, path);
</pre>
<hr />
<pre>
581         stringBuilder.append(indent, outputVariableName, &#39;.&#39;, elementName, &quot; = &quot;, inputVariableName, &quot;;\n&quot;);
582         return;
583     }
584     for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {
585         auto&amp; elementName = m_namedOutputs[i].elementName;
586         auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;
587         auto&amp; path = m_entryPointItems.outputs[i].path;
588         stringBuilder.append(indent, outputVariableName, &#39;.&#39;, elementName, &quot; = &quot;, internalTypeName, &#39;(&#39;, inputVariableName);
589         emitMangledOutputPath(stringBuilder, path);
590         stringBuilder.append(&quot;);\n&quot;);
591     }
592 }
593 
594 ComputeEntryPointScaffolding::ComputeEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, EntryPointItems&amp; entryPointItems, HashMap&lt;Binding*, size_t&gt;&amp; resourceMap, Layout&amp; layout, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName)
595     : EntryPointScaffolding(functionDefinition, intrinsics, typeNamer, entryPointItems, resourceMap, layout, WTFMove(generateNextVariableName))
596 {
597 }
598 
599 void ComputeEntryPointScaffolding::emitHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)
600 {
<span class="line-modified">601     emitResourceHelperTypes(stringBuilder, indent, ShaderStage::Compute);</span>
602 }
603 
604 void ComputeEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)
605 {
606     stringBuilder.append(indent, &quot;kernel void &quot;, functionName, &#39;(&#39;);
607     bool addedToSignature = emitResourceSignature(stringBuilder, IncludePrecedingComma::No);
608     emitBuiltInsSignature(stringBuilder, addedToSignature ? IncludePrecedingComma::Yes : IncludePrecedingComma::No);
609     stringBuilder.append(&quot;)\n&quot;);
610 }
611 
612 void ComputeEntryPointScaffolding::emitUnpack(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)
613 {
614     emitUnpackResourcesAndNamedBuiltIns(stringBuilder, indent);
615 }
616 
617 void ComputeEntryPointScaffolding::emitPack(StringBuilder&amp;, MangledVariableName, MangledVariableName, Indentation&lt;4&gt;)
618 {
619     ASSERT_NOT_REACHED();
620 }
621 
</pre>
</td>
</tr>
</table>
<center><a href="../AST/WHLSLType.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLEntryPointScaffolding.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
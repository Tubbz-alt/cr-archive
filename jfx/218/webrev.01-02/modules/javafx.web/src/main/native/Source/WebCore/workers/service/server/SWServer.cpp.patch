diff a/modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServer.cpp b/modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServer.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServer.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/SWServer.cpp
@@ -41,20 +41,21 @@
 #include "ServiceWorkerClientType.h"
 #include "ServiceWorkerContextData.h"
 #include "ServiceWorkerFetchResult.h"
 #include "ServiceWorkerJobData.h"
 #include <wtf/CompletionHandler.h>
+#include <wtf/MemoryPressureHandler.h>
 #include <wtf/NeverDestroyed.h>
 #include <wtf/text/WTFString.h>
 
 namespace WebCore {
 
 static Seconds terminationDelay { 10_s };
 
-SWServer::Connection::Connection(SWServer& server)
+SWServer::Connection::Connection(SWServer& server, Identifier identifier)
     : m_server(server)
-    , m_identifier(SWServerConnectionIdentifier::generate())
+    , m_identifier(identifier)
 {
 }
 
 HashSet<SWServer*>& SWServer::allServers()
 {
@@ -67,10 +68,13 @@
     // Destroy the remaining connections before the SWServer gets destroyed since they have a raw pointer
     // to the server and since they try to unregister clients from the server in their destructor.
     auto connections = WTFMove(m_connections);
     connections.clear();
 
+    for (auto& callback : std::exchange(m_importCompletedCallbacks, { }))
+        callback();
+
     Vector<SWServerWorker*> runningWorkers;
     for (auto& worker : m_runningOrTerminatingWorkers.values()) {
         if (worker->isRunning())
             runningWorkers.append(worker.ptr());
     }
@@ -109,17 +113,17 @@
     return iterator->value.userAgent;
 }
 
 SWServerWorker* SWServer::activeWorkerFromRegistrationID(ServiceWorkerRegistrationIdentifier identifier)
 {
-    auto* registration = m_registrationsByID.get(identifier);
+    auto* registration = m_registrations.get(identifier);
     return registration ? registration->activeWorker() : nullptr;
 }
 
 SWServerRegistration* SWServer::getRegistration(const ServiceWorkerRegistrationKey& registrationKey)
 {
-    return m_registrations.get(registrationKey);
+    return m_scopeToRegistrationMap.get(registrationKey).get();
 }
 
 void SWServer::registrationStoreImportComplete()
 {
     ASSERT(!m_importCompleted);
@@ -129,22 +133,32 @@
     auto clearCallbacks = WTFMove(m_clearCompletionCallbacks);
     for (auto& callback : clearCallbacks)
         callback();
 
     performGetOriginsWithRegistrationsCallbacks();
+
+    for (auto& callback : std::exchange(m_importCompletedCallbacks, { }))
+        callback();
 }
 
+void SWServer::whenImportIsCompleted(CompletionHandler<void()>&& callback)
+{
+    ASSERT(!m_importCompleted);
+    m_importCompletedCallbacks.append(WTFMove(callback));
+}
+
+
 void SWServer::registrationStoreDatabaseFailedToOpen()
 {
     if (!m_importCompleted)
         registrationStoreImportComplete();
 }
 
 void SWServer::addRegistrationFromStore(ServiceWorkerContextData&& data)
 {
     // Pages should not have been able to make a new registration to this key while the import was still taking place.
-    ASSERT(!m_registrations.contains(data.registration.key));
+    ASSERT(!m_scopeToRegistrationMap.contains(data.registration.key));
 
     auto registration = makeUnique<SWServerRegistration>(*this, data.registration.key, data.registration.updateViaCache, data.registration.scopeURL, data.scriptURL);
     registration->setLastUpdateTime(data.registration.lastUpdateTime);
     auto registrationPtr = registration.get();
     addRegistration(WTFMove(registration));
@@ -154,40 +168,42 @@
     worker->setState(ServiceWorkerState::Activated);
 }
 
 void SWServer::addRegistration(std::unique_ptr<SWServerRegistration>&& registration)
 {
-    auto key = registration->key();
-    auto* registrationPtr = registration.get();
-    auto addResult1 = m_registrations.add(key, WTFMove(registration));
+    m_originStore->add(registration->key().topOrigin());
+    auto registrationID = registration->identifier();
+    ASSERT(!m_scopeToRegistrationMap.contains(registration->key()));
+    m_scopeToRegistrationMap.set(registration->key(), makeWeakPtr(*registration));
+    auto addResult1 = m_registrations.add(registrationID, WTFMove(registration));
     ASSERT_UNUSED(addResult1, addResult1.isNewEntry);
-
-    auto addResult2 = m_registrationsByID.add(registrationPtr->identifier(), registrationPtr);
-    ASSERT_UNUSED(addResult2, addResult2.isNewEntry);
-
-    m_originStore->add(key.topOrigin());
 }
 
-void SWServer::removeRegistration(const ServiceWorkerRegistrationKey& key)
+void SWServer::removeRegistration(ServiceWorkerRegistrationIdentifier registrationID)
 {
-    auto topOrigin = key.topOrigin();
-    auto registration = m_registrations.take(key);
+    auto registration = m_registrations.take(registrationID);
     ASSERT(registration);
-    bool wasRemoved = m_registrationsByID.remove(registration->identifier());
-    ASSERT_UNUSED(wasRemoved, wasRemoved);
 
-    m_originStore->remove(topOrigin);
+    auto it = m_scopeToRegistrationMap.find(registration->key());
+    if (it != m_scopeToRegistrationMap.end() && it->value == registration.get())
+        m_scopeToRegistrationMap.remove(it);
+
+    m_originStore->remove(registration->key().topOrigin());
     if (m_registrationStore)
-        m_registrationStore->removeRegistration(key);
+        m_registrationStore->removeRegistration(registration->key());
 }
 
 Vector<ServiceWorkerRegistrationData> SWServer::getRegistrations(const SecurityOriginData& topOrigin, const URL& clientURL)
 {
     Vector<SWServerRegistration*> matchingRegistrations;
-    for (auto& item : m_registrations) {
-        if (!item.value->isUninstalling() && item.key.originIsMatching(topOrigin, clientURL))
-            matchingRegistrations.append(item.value.get());
+    for (auto& item : m_scopeToRegistrationMap) {
+        if (item.key.originIsMatching(topOrigin, clientURL)) {
+            auto* registration = item.value.get();
+            ASSERT(registration);
+            if (registration)
+                matchingRegistrations.append(registration);
+        }
     }
     // The specification mandates that registrations are returned in the insertion order.
     std::sort(matchingRegistrations.begin(), matchingRegistrations.end(), [](auto& a, auto& b) {
         return a->creationTime() < b->creationTime();
     });
@@ -209,11 +225,10 @@
     }
 
     m_jobQueues.clear();
     while (!m_registrations.isEmpty())
         m_registrations.begin()->value->clear();
-    ASSERT(m_registrationsByID.isEmpty());
     m_pendingContextDatas.clear();
     m_originStore->clearAll();
     if (m_registrationStore)
         m_registrationStore->clearAll(WTFMove(completionHandler));
 }
@@ -246,13 +261,13 @@
     m_jobQueues.removeIf([&](auto& keyAndValue) {
         return keyAndValue.key.relatesToOrigin(securityOrigin);
     });
 
     Vector<SWServerRegistration*> registrationsToRemove;
-    for (auto& keyAndValue : m_registrations) {
-        if (keyAndValue.key.relatesToOrigin(securityOrigin))
-            registrationsToRemove.append(keyAndValue.value.get());
+    for (auto& registration : m_registrations.values()) {
+        if (registration->key().relatesToOrigin(securityOrigin))
+            registrationsToRemove.append(registration.get());
     }
 
     for (auto& contextDatas : m_pendingContextDatas.values()) {
         contextDatas.removeAllMatching([&](auto& contextData) {
             return contextData.registration.key.relatesToOrigin(securityOrigin);
@@ -272,16 +287,16 @@
         m_registrationStore->flushChanges(WTFMove(completionHandler));
 }
 
 void SWServer::Connection::finishFetchingScriptInServer(const ServiceWorkerFetchResult& result)
 {
-    m_server.scriptFetchFinished(*this, result);
+    m_server.scriptFetchFinished(result);
 }
 
 void SWServer::Connection::didResolveRegistrationPromise(const ServiceWorkerRegistrationKey& key)
 {
-    m_server.didResolveRegistrationPromise(*this, key);
+    m_server.didResolveRegistrationPromise(this, key);
 }
 
 void SWServer::Connection::addServiceWorkerRegistrationInServer(ServiceWorkerRegistrationIdentifier identifier)
 {
     m_server.addClientServiceWorkerRegistration(*this, identifier);
@@ -296,15 +311,18 @@
 {
     if (auto* worker = m_server.workerByID(identifier))
         m_server.syncTerminateWorker(*worker);
 }
 
-SWServer::SWServer(UniqueRef<SWOriginStore>&& originStore, String&& registrationDatabaseDirectory, PAL::SessionID sessionID)
+SWServer::SWServer(UniqueRef<SWOriginStore>&& originStore, bool processTerminationDelayEnabled, String&& registrationDatabaseDirectory, PAL::SessionID sessionID, SoftUpdateCallback&& softUpdateCallback, CreateContextConnectionCallback&& callback)
     : m_originStore(WTFMove(originStore))
     , m_sessionID(sessionID)
+    , m_isProcessTerminationDelayEnabled(processTerminationDelayEnabled)
+    , m_createContextConnectionCallback(WTFMove(callback))
+    , m_softUpdateCallback(WTFMove(softUpdateCallback))
 {
-    ASSERT(!registrationDatabaseDirectory.isEmpty() || m_sessionID.isEphemeral());
+    RELEASE_LOG_IF(registrationDatabaseDirectory.isEmpty() && !m_sessionID.isEphemeral(), ServiceWorker, "No path to store the service worker registrations");
     if (!m_sessionID.isEphemeral())
         m_registrationStore = makeUnique<RegistrationStore>(*this, WTFMove(registrationDatabaseDirectory));
     else
         registrationStoreImportComplete();
 
@@ -313,20 +331,30 @@
 }
 
 // https://w3c.github.io/ServiceWorker/#schedule-job-algorithm
 void SWServer::scheduleJob(ServiceWorkerJobData&& jobData)
 {
-    ASSERT(m_connections.contains(jobData.connectionIdentifier()));
-
-    // FIXME: Per the spec, check if this job is equivalent to the last job on the queue.
-    // If it is, stack it along with that job.
+    ASSERT(m_connections.contains(jobData.connectionIdentifier()) || jobData.connectionIdentifier() == Process::identifier());
 
     auto& jobQueue = *m_jobQueues.ensure(jobData.registrationKey(), [this, &jobData] {
         return makeUnique<SWServerJobQueue>(*this, jobData.registrationKey());
     }).iterator->value;
 
-    jobQueue.enqueueJob(jobData);
+    if (!jobQueue.size()) {
+        jobQueue.enqueueJob(WTFMove(jobData));
+        jobQueue.runNextJob();
+        return;
+    }
+    auto& lastJob = jobQueue.lastJob();
+    if (jobData.isEquivalent(lastJob)) {
+        // FIXME: Per the spec, check if this job is equivalent to the last job on the queue.
+        // If it is, stack it along with that job. For now, we just make sure to not call soft-update too often.
+        if (jobData.type == ServiceWorkerJobType::Update && jobData.connectionIdentifier() == Process::identifier())
+            return;
+    }
+
+    jobQueue.enqueueJob(WTFMove(jobData));
     if (jobQueue.size() == 1)
         jobQueue.runNextJob();
 }
 
 void SWServer::rejectJob(const ServiceWorkerJobData& jobData, const ExceptionData& exceptionData)
@@ -341,12 +369,15 @@
 
 void SWServer::resolveRegistrationJob(const ServiceWorkerJobData& jobData, const ServiceWorkerRegistrationData& registrationData, ShouldNotifyWhenResolved shouldNotifyWhenResolved)
 {
     LOG(ServiceWorker, "Resolved ServiceWorker job %s in server with registration %s", jobData.identifier().loggingString().utf8().data(), registrationData.identifier.loggingString().utf8().data());
     auto* connection = m_connections.get(jobData.connectionIdentifier());
-    if (!connection)
+    if (!connection) {
+        if (shouldNotifyWhenResolved == ShouldNotifyWhenResolved::Yes && jobData.connectionIdentifier() == Process::identifier())
+            didResolveRegistrationPromise(nullptr, registrationData.key);
         return;
+    }
 
     connection->resolveRegistrationJobInClient(jobData.identifier().jobIdentifier, registrationData, shouldNotifyWhenResolved);
 }
 
 void SWServer::resolveUnregistrationJob(const ServiceWorkerJobData& jobData, const ServiceWorkerRegistrationKey& registrationKey, bool unregistrationResult)
@@ -356,30 +387,67 @@
         return;
 
     connection->resolveUnregistrationJobInClient(jobData.identifier().jobIdentifier, registrationKey, unregistrationResult);
 }
 
-void SWServer::startScriptFetch(const ServiceWorkerJobData& jobData, FetchOptions::Cache cachePolicy)
+URL static inline originURL(const SecurityOrigin& origin)
+{
+    URL url;
+    url.setProtocol(origin.protocol());
+    url.setHost(origin.host());
+    if (origin.port())
+        url.setPort(*origin.port());
+    return url;
+}
+
+void SWServer::startScriptFetch(const ServiceWorkerJobData& jobData, bool shouldRefreshCache)
 {
     LOG(ServiceWorker, "Server issuing startScriptFetch for current job %s in client", jobData.identifier().loggingString().utf8().data());
     auto* connection = m_connections.get(jobData.connectionIdentifier());
+    if (connection) {
+        connection->startScriptFetchInClient(jobData.identifier().jobIdentifier, jobData.registrationKey(), shouldRefreshCache ? FetchOptions::Cache::NoCache : FetchOptions::Cache::Default);
+        return;
+    }
+    if (jobData.connectionIdentifier() == Process::identifier()) {
+        ASSERT(jobData.type == ServiceWorkerJobType::Update);
+        // This is a soft-update job, create directly a network load to fetch the script.
+        ResourceRequest request { jobData.scriptURL };
+
+        auto topOrigin = jobData.topOrigin.securityOrigin();
+        auto origin = SecurityOrigin::create(jobData.scriptURL);
+
+        request.setDomainForCachePartition(topOrigin->domainForCachePartition());
+        request.setAllowCookies(true);
+        request.setFirstPartyForCookies(originURL(topOrigin));
+
+        request.setHTTPHeaderField(HTTPHeaderName::Origin, origin->toString());
+        request.setHTTPHeaderField(HTTPHeaderName::ServiceWorker, "script"_s);
+        request.setHTTPReferrer(originURL(origin));
+        request.setHTTPUserAgent(serviceWorkerClientUserAgent(ClientOrigin { jobData.topOrigin, SecurityOrigin::create(jobData.scriptURL)->data() }));
+        request.setPriority(ResourceLoadPriority::Low);
+
+        m_softUpdateCallback(ServiceWorkerJobData { jobData }, shouldRefreshCache, WTFMove(request), [this, weakThis = makeWeakPtr(this)](auto& result) {
+            if (!weakThis)
+                return;
+            scriptFetchFinished(result);
+        });
+        return;
+    }
     ASSERT_WITH_MESSAGE(connection, "If the connection was lost, this job should have been cancelled");
-    if (connection)
-        connection->startScriptFetchInClient(jobData.identifier().jobIdentifier, jobData.registrationKey(), cachePolicy);
 }
 
-void SWServer::scriptFetchFinished(Connection& connection, const ServiceWorkerFetchResult& result)
+void SWServer::scriptFetchFinished(const ServiceWorkerFetchResult& result)
 {
     LOG(ServiceWorker, "Server handling scriptFetchFinished for current job %s in client", result.jobDataIdentifier.loggingString().utf8().data());
 
-    ASSERT(m_connections.contains(result.jobDataIdentifier.connectionIdentifier));
+    ASSERT(m_connections.contains(result.jobDataIdentifier.connectionIdentifier) || result.jobDataIdentifier.connectionIdentifier == Process::identifier());
 
     auto jobQueue = m_jobQueues.get(result.registrationKey);
     if (!jobQueue)
         return;
 
-    jobQueue->scriptFetchFinished(connection, result);
+    jobQueue->scriptFetchFinished(result);
 }
 
 void SWServer::scriptContextFailedToStart(const Optional<ServiceWorkerJobDataIdentifier>& jobDataIdentifier, SWServerWorker& worker, const String& message)
 {
     if (!jobDataIdentifier)
@@ -411,11 +479,11 @@
 }
 
 void SWServer::terminatePreinstallationWorker(SWServerWorker& worker)
 {
     worker.terminate();
-    auto* registration = getRegistration(worker.registrationKey());
+    auto* registration = worker.registration();
     if (registration && registration->preInstallationWorker() == &worker)
         registration->setPreInstallationWorker(nullptr);
 }
 
 void SWServer::didFinishInstall(const Optional<ServiceWorkerJobDataIdentifier>& jobDataIdentifier, SWServerWorker& worker, bool wasSuccessful)
@@ -427,18 +495,18 @@
         RELEASE_LOG(ServiceWorker, "%p - SWServer::didFinishInstall: Successfuly finished SW install for job %s", this, jobDataIdentifier->loggingString().utf8().data());
     else
         RELEASE_LOG_ERROR(ServiceWorker, "%p - SWServer::didFinishInstall: Failed SW install for job %s", this, jobDataIdentifier->loggingString().utf8().data());
 
     if (auto* jobQueue = m_jobQueues.get(worker.registrationKey()))
-        jobQueue->didFinishInstall(*jobDataIdentifier, worker.identifier(), wasSuccessful);
+        jobQueue->didFinishInstall(*jobDataIdentifier, worker, wasSuccessful);
 }
 
 void SWServer::didFinishActivation(SWServerWorker& worker)
 {
     RELEASE_LOG(ServiceWorker, "%p - SWServer::didFinishActivation: Finished activation for service worker %llu", this, worker.identifier().toUInt64());
 
-    auto* registration = getRegistration(worker.registrationKey());
+    auto* registration = worker.registration();
     if (!registration)
         return;
 
     if (m_registrationStore)
         m_registrationStore->updateRegistration(worker.contextData());
@@ -492,65 +560,67 @@
         if (!result.isNewEntry) {
             auto previousIdentifier = result.iterator->value;
             if (previousIdentifier == registration->identifier())
                 return;
             result.iterator->value = registration->identifier();
-            if (auto* controllingRegistration = m_registrationsByID.get(previousIdentifier))
+            if (auto* controllingRegistration = m_registrations.get(previousIdentifier))
                 controllingRegistration->removeClientUsingRegistration(clientData.identifier);
         }
         registration->controlClient(clientData.identifier);
     });
 }
 
-void SWServer::didResolveRegistrationPromise(Connection& connection, const ServiceWorkerRegistrationKey& registrationKey)
+void SWServer::didResolveRegistrationPromise(Connection* connection, const ServiceWorkerRegistrationKey& registrationKey)
 {
-    ASSERT_UNUSED(connection, m_connections.contains(connection.identifier()));
+    ASSERT_UNUSED(connection, !connection || m_connections.contains(connection->identifier()));
 
     if (auto* jobQueue = m_jobQueues.get(registrationKey))
         jobQueue->didResolveRegistrationPromise();
 }
 
 void SWServer::addClientServiceWorkerRegistration(Connection& connection, ServiceWorkerRegistrationIdentifier identifier)
 {
-    auto* registration = m_registrationsByID.get(identifier);
+    auto* registration = m_registrations.get(identifier);
     if (!registration) {
         LOG_ERROR("Request to add client-side ServiceWorkerRegistration to non-existent server-side registration");
         return;
     }
 
     registration->addClientServiceWorkerRegistration(connection.identifier());
 }
 
 void SWServer::removeClientServiceWorkerRegistration(Connection& connection, ServiceWorkerRegistrationIdentifier identifier)
 {
-    if (auto* registration = m_registrationsByID.get(identifier))
+    if (auto* registration = m_registrations.get(identifier))
         registration->removeClientServiceWorkerRegistration(connection.identifier());
 }
 
-void SWServer::updateWorker(Connection&, const ServiceWorkerJobDataIdentifier& jobDataIdentifier, SWServerRegistration& registration, const URL& url, const String& script, const ContentSecurityPolicyResponseHeaders& contentSecurityPolicy, const String& referrerPolicy, WorkerType type, HashMap<URL, ServiceWorkerContextData::ImportedScript>&& scriptResourceMap)
+void SWServer::updateWorker(const ServiceWorkerJobDataIdentifier& jobDataIdentifier, SWServerRegistration& registration, const URL& url, const String& script, const ContentSecurityPolicyResponseHeaders& contentSecurityPolicy, const String& referrerPolicy, WorkerType type, HashMap<URL, ServiceWorkerContextData::ImportedScript>&& scriptResourceMap)
 {
-    tryInstallContextData({ jobDataIdentifier, registration.data(), ServiceWorkerIdentifier::generate(), script, contentSecurityPolicy, referrerPolicy, url, type, sessionID(), false, WTFMove(scriptResourceMap) });
+    tryInstallContextData({ jobDataIdentifier, registration.data(), ServiceWorkerIdentifier::generate(), script, contentSecurityPolicy, referrerPolicy, url, type, false, WTFMove(scriptResourceMap) });
 }
 
 void SWServer::tryInstallContextData(ServiceWorkerContextData&& data)
 {
     RegistrableDomain registrableDomain(data.scriptURL);
-    auto* connection = SWServerToContextConnection::connectionForRegistrableDomain(registrableDomain);
+    auto* connection = contextConnectionForRegistrableDomain(registrableDomain);
     if (!connection) {
-        m_pendingContextDatas.ensure(WTFMove(registrableDomain), [] {
+        m_pendingContextDatas.ensure(registrableDomain, [] {
             return Vector<ServiceWorkerContextData> { };
         }).iterator->value.append(WTFMove(data));
+
+        createContextConnection(registrableDomain);
         return;
     }
 
     installContextData(data);
 }
 
-void SWServer::serverToContextConnectionCreated(SWServerToContextConnection& contextConnection)
+void SWServer::contextConnectionCreated(SWServerToContextConnection& contextConnection)
 {
     for (auto& connection : m_connections.values())
-        connection->serverToContextConnectionCreated(contextConnection);
+        connection->contextConnectionCreated(contextConnection);
 
     auto pendingContextDatas = m_pendingContextDatas.take(contextConnection.registrableDomain());
     for (auto& data : pendingContextDatas)
         installContextData(data);
 
@@ -571,13 +641,11 @@
         auto* jobQueue = m_jobQueues.get(data.registration.key);
         if (!jobQueue || !jobQueue->isCurrentlyProcessingJob(*data.jobDataIdentifier))
             return;
     }
 
-    auto* registration = m_registrations.get(data.registration.key);
-    RELEASE_ASSERT(registration);
-
+    auto* registration = m_scopeToRegistrationMap.get(data.registration.key).get();
     auto worker = SWServerWorker::create(*this, *registration, data.scriptURL, data.script, data.contentSecurityPolicy, String { data.referrerPolicy }, data.workerType, data.serviceWorkerIdentifier, HashMap<URL, ServiceWorkerContextData::ImportedScript> { data.scriptResourceMap });
 
     auto* connection = worker->contextConnection();
     ASSERT(connection);
 
@@ -585,11 +653,11 @@
     worker->setState(SWServerWorker::State::Running);
     auto userAgent = worker->userAgent();
     auto result = m_runningOrTerminatingWorkers.add(data.serviceWorkerIdentifier, WTFMove(worker));
     ASSERT_UNUSED(result, result.isNewEntry);
 
-    connection->installServiceWorkerContext(data, m_sessionID, userAgent);
+    connection->installServiceWorkerContext(data, userAgent);
 }
 
 void SWServer::runServiceWorkerIfNecessary(ServiceWorkerIdentifier identifier, RunServiceWorkerCallback&& callback)
 {
     auto* worker = workerByID(identifier);
@@ -603,17 +671,24 @@
         ASSERT(contextConnection);
         callback(contextConnection);
         return;
     }
 
+    if (worker->state() == ServiceWorkerState::Redundant) {
+        callback(nullptr);
+        return;
+    }
+
     if (!contextConnection) {
         auto& serviceWorkerRunRequestsForOrigin = m_serviceWorkerRunRequests.ensure(worker->registrableDomain(), [] {
             return HashMap<ServiceWorkerIdentifier, Vector<RunServiceWorkerCallback>> { };
         }).iterator->value;
         serviceWorkerRunRequestsForOrigin.ensure(identifier, [&] {
             return Vector<RunServiceWorkerCallback> { };
         }).iterator->value.append(WTFMove(callback));
+
+        createContextConnection(worker->registrableDomain());
         return;
     }
 
     bool success = runServiceWorker(identifier);
     callback(success ? contextConnection : nullptr);
@@ -623,24 +698,24 @@
 {
     auto* worker = workerByID(identifier);
     if (!worker)
         return false;
 
-    // If the registration for a working has been removed then the request to run
+    // If the registration for a worker has been removed then the request to run
     // the worker is moot.
-    if (!getRegistration(worker->registrationKey()))
+    if (!worker->registration())
         return false;
 
     auto addResult = m_runningOrTerminatingWorkers.add(identifier, *worker);
     ASSERT_UNUSED(addResult, addResult.isNewEntry || worker->isTerminating());
 
     worker->setState(SWServerWorker::State::Running);
 
     auto* contextConnection = worker->contextConnection();
     ASSERT(contextConnection);
 
-    contextConnection->installServiceWorkerContext(worker->contextData(), m_sessionID, worker->userAgent());
+    contextConnection->installServiceWorkerContext(worker->contextData(), worker->userAgent());
 
     return true;
 }
 
 void SWServer::terminateWorker(SWServerWorker& worker)
@@ -745,28 +820,28 @@
         jobQueue->cancelJobsFromConnection(connectionIdentifier);
 }
 
 SWServerRegistration* SWServer::doRegistrationMatching(const SecurityOriginData& topOrigin, const URL& clientURL)
 {
+    ASSERT(isImportCompleted());
     SWServerRegistration* selectedRegistration = nullptr;
-    for (auto& registration : m_registrations.values()) {
-        if (!registration->key().isMatching(topOrigin, clientURL))
+    for (auto& pair : m_scopeToRegistrationMap) {
+        if (!pair.key.isMatching(topOrigin, clientURL))
             continue;
-        if (!selectedRegistration || selectedRegistration->key().scopeLength() < registration->key().scopeLength())
-            selectedRegistration = registration.get();
+        if (!selectedRegistration || selectedRegistration->key().scopeLength() < pair.key.scopeLength())
+            selectedRegistration = pair.value.get();
     }
 
-    return (selectedRegistration && !selectedRegistration->isUninstalling()) ? selectedRegistration : nullptr;
+    return selectedRegistration;
 }
 
 SWServerRegistration* SWServer::registrationFromServiceWorkerIdentifier(ServiceWorkerIdentifier identifier)
 {
     auto iterator = m_runningOrTerminatingWorkers.find(identifier);
     if (iterator == m_runningOrTerminatingWorkers.end())
         return nullptr;
-
-    return m_registrations.get(iterator->value->registrationKey());
+    return iterator->value->registration();
 }
 
 void SWServer::registerServiceWorkerClient(ClientOrigin&& clientOrigin, ServiceWorkerClientData&& data, const Optional<ServiceWorkerRegistrationIdentifier>& controllingServiceWorkerRegistrationIdentifier, String&& userAgent)
 {
     auto clientIdentifier = data.identifier;
@@ -792,11 +867,11 @@
     }).iterator->value.add(clientIdentifier);
 
     if (!controllingServiceWorkerRegistrationIdentifier)
         return;
 
-    auto* controllingRegistration = m_registrationsByID.get(*controllingServiceWorkerRegistrationIdentifier);
+    auto* controllingRegistration = m_registrations.get(*controllingServiceWorkerRegistrationIdentifier);
     if (!controllingRegistration || !controllingRegistration->activeWorker())
         return;
 
     controllingRegistration->addClientUsingRegistration(clientIdentifier);
     ASSERT(!m_clientToControllingRegistration.contains(clientIdentifier));
@@ -828,17 +903,19 @@
             }
             for (auto* worker : workersToTerminate)
                 terminateWorker(*worker);
 
             if (!m_clientsByRegistrableDomain.contains(clientRegistrableDomain)) {
-                if (auto* connection = SWServerToContextConnection::connectionForRegistrableDomain(clientRegistrableDomain))
-                    connection->connectionMayNoLongerBeNeeded();
+                if (auto* connection = contextConnectionForRegistrableDomain(clientRegistrableDomain)) {
+                    removeContextConnection(*connection);
+                    connection->connectionIsNoLongerNeeded();
+                }
             }
 
             m_clientIdentifiersPerOrigin.remove(clientOrigin);
         });
-        iterator->value.terminateServiceWorkersTimer->startOneShot(m_shouldDisableServiceWorkerProcessTerminationDelay ? 0_s : terminationDelay);
+        iterator->value.terminateServiceWorkersTimer->startOneShot(m_isProcessTerminationDelayEnabled && !MemoryPressureHandler::singleton().isUnderMemoryPressure() ? terminationDelay : 0_s);
     }
 
     auto clientsByRegistrableDomainIterator = m_clientsByRegistrableDomain.find(clientRegistrableDomain);
     ASSERT(clientsByRegistrableDomainIterator != m_clientsByRegistrableDomain.end());
     auto& clientsForRegistrableDomain = clientsByRegistrableDomainIterator->value;
@@ -848,17 +925,33 @@
 
     auto registrationIterator = m_clientToControllingRegistration.find(clientIdentifier);
     if (registrationIterator == m_clientToControllingRegistration.end())
         return;
 
-    if (auto* registration = m_registrationsByID.get(registrationIterator->value))
+    if (auto* registration = m_registrations.get(registrationIterator->value))
         registration->removeClientUsingRegistration(clientIdentifier);
 
     m_clientToControllingRegistration.remove(registrationIterator);
 }
 
-bool SWServer::needsServerToContextConnectionForRegistrableDomain(const RegistrableDomain& registrableDomain) const
+void SWServer::handleLowMemoryWarning()
+{
+    // Accelerating the delayed termination of unused service workers due to memory pressure.
+    if (m_isProcessTerminationDelayEnabled) {
+        for (auto& clients : m_clientIdentifiersPerOrigin.values()) {
+            if (clients.terminateServiceWorkersTimer)
+                clients.terminateServiceWorkersTimer->startOneShot(0_s);
+        }
+    }
+}
+
+void SWServer::removeFromScopeToRegistrationMap(const ServiceWorkerRegistrationKey& key)
+{
+    m_scopeToRegistrationMap.remove(key);
+}
+
+bool SWServer::needsContextConnectionForRegistrableDomain(const RegistrableDomain& registrableDomain) const
 {
     return m_clientsByRegistrableDomain.contains(registrableDomain);
 }
 
 void SWServer::resolveRegistrationReadyRequests(SWServerRegistration& registration)
@@ -913,18 +1006,91 @@
 
     if (m_getOriginsWithRegistrationsCallbacks.isEmpty())
         return;
 
     HashSet<SecurityOriginData> originsWithRegistrations;
-    for (auto& key : m_registrations.keys()) {
+    for (auto& key : m_scopeToRegistrationMap.keys()) {
         originsWithRegistrations.add(key.topOrigin());
         originsWithRegistrations.add(SecurityOriginData { key.scope().protocol().toString(), key.scope().host().toString(), key.scope().port() });
     }
 
     auto callbacks = WTFMove(m_getOriginsWithRegistrationsCallbacks);
     for (auto& callback : callbacks)
         callback(originsWithRegistrations);
 }
 
+void SWServer::addContextConnection(SWServerToContextConnection& connection)
+{
+    RELEASE_LOG(ServiceWorker, "SWServer::addContextConnection");
+
+    ASSERT(!m_contextConnections.contains(connection.registrableDomain()));
+
+    m_contextConnections.add(connection.registrableDomain(), &connection);
+
+    contextConnectionCreated(connection);
+}
+
+void SWServer::removeContextConnection(SWServerToContextConnection& connection)
+{
+    RELEASE_LOG(ServiceWorker, "SWServer::removeContextConnection");
+
+    auto& registrableDomain = connection.registrableDomain();
+
+    ASSERT(m_contextConnections.get(registrableDomain) == &connection);
+
+    m_contextConnections.remove(registrableDomain);
+    markAllWorkersForRegistrableDomainAsTerminated(registrableDomain);
+    if (needsContextConnectionForRegistrableDomain(registrableDomain))
+        createContextConnection(registrableDomain);
+}
+
+void SWServer::createContextConnection(const RegistrableDomain& registrableDomain)
+{
+    ASSERT(!m_contextConnections.contains(registrableDomain));
+    if (m_pendingConnectionDomains.contains(registrableDomain))
+        return;
+
+    RELEASE_LOG(ServiceWorker, "SWServer::createContextConnection will create a connection");
+
+    m_pendingConnectionDomains.add(registrableDomain);
+    m_createContextConnectionCallback(registrableDomain, [this, weakThis = makeWeakPtr(this), registrableDomain] {
+        if (!weakThis)
+            return;
+
+        RELEASE_LOG(ServiceWorker, "SWServer::createContextConnection should now have created a connection");
+
+        ASSERT(m_pendingConnectionDomains.contains(registrableDomain));
+        m_pendingConnectionDomains.remove(registrableDomain);
+
+        if (m_contextConnections.contains(registrableDomain))
+            return;
+
+        if (needsContextConnectionForRegistrableDomain(registrableDomain))
+            createContextConnection(registrableDomain);
+    });
+}
+
+bool SWServer::canHandleScheme(StringView scheme) const
+{
+    if (scheme.isNull())
+        return false;
+    if (!equalLettersIgnoringASCIICase(scheme.substring(0, 4), "http"))
+        return false;
+    if (scheme.length() == 5 && isASCIIAlphaCaselessEqual(scheme[4], 's'))
+        return true;
+    return scheme.length() == 4;
+}
+
+// https://w3c.github.io/ServiceWorker/#soft-update
+void SWServer::softUpdate(SWServerRegistration& registration)
+{
+    ServiceWorkerJobData jobData(Process::identifier(), ServiceWorkerIdentifier::generate());
+    jobData.scriptURL = registration.scriptURL();
+    jobData.topOrigin = registration.key().topOrigin();
+    jobData.scopeURL = registration.scopeURLWithoutFragment();
+    jobData.type = ServiceWorkerJobType::Update;
+    scheduleJob(WTFMove(jobData));
+}
+
 } // namespace WebCore
 
 #endif // ENABLE(SERVICE_WORKER)

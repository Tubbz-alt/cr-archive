diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolyProtoAccessChain.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolyProtoAccessChain.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolyProtoAccessChain.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolyProtoAccessChain.cpp
@@ -29,78 +29,66 @@
 #include "JSCInlines.h"
 #include "JSObject.h"
 
 namespace JSC {
 
-std::unique_ptr<PolyProtoAccessChain> PolyProtoAccessChain::create(JSGlobalObject* globalObject, JSCell* base, const PropertySlot& slot, bool& usesPolyProto)
+std::unique_ptr<PolyProtoAccessChain> PolyProtoAccessChain::create(JSGlobalObject* globalObject, JSCell* base, const PropertySlot& slot)
 {
     JSObject* target = slot.isUnset() ? nullptr : slot.slotBase();
-    return create(globalObject, base, target, usesPolyProto);
+    return create(globalObject, base, target);
 }
 
-std::unique_ptr<PolyProtoAccessChain> PolyProtoAccessChain::create(JSGlobalObject* globalObject, JSCell* base, JSObject* target, bool& usesPolyProto)
+std::unique_ptr<PolyProtoAccessChain> PolyProtoAccessChain::create(JSGlobalObject* globalObject, JSCell* base, JSObject* target)
 {
     JSCell* current = base;
     VM& vm = base->vm();
 
     bool found = false;
 
-    usesPolyProto = false;
-
     std::unique_ptr<PolyProtoAccessChain> result(new PolyProtoAccessChain());
 
     for (unsigned iterationNumber = 0; true; ++iterationNumber) {
         Structure* structure = current->structure(vm);
 
+        if (structure->isDictionary())
+            return nullptr;
+
         if (!structure->propertyAccessesAreCacheable())
             return nullptr;
 
         if (structure->isProxy())
             return nullptr;
 
-        if (structure->isDictionary()) {
-            ASSERT(structure->isObject());
-            if (structure->hasBeenFlattenedBefore())
-                return nullptr;
-
-            structure->flattenDictionaryStructure(vm, asObject(current));
-        }
-
         // To save memory, we don't include the base in the chain. We let
         // AccessCase provide the base to us as needed.
         if (iterationNumber)
-            result->m_chain.append(structure);
+            result->m_chain.append(structure->id());
         else
             RELEASE_ASSERT(current == base);
 
         if (current == target) {
             found = true;
             break;
         }
 
-        // We only have poly proto if we need to access our prototype via
-        // the poly proto protocol. If the slot base is the only poly proto
-        // thing in the chain, and we have a cache hit on it, then we're not
-        // poly proto.
-        usesPolyProto |= structure->hasPolyProto();
-
         JSValue prototype = structure->prototypeForLookup(globalObject, current);
         if (prototype.isNull())
             break;
         current = asObject(prototype);
     }
 
     if (!found && !!target)
         return nullptr;
 
+    result->m_chain.shrinkToFit();
     return result;
 }
 
-bool PolyProtoAccessChain::needImpurePropertyWatchpoint() const
+bool PolyProtoAccessChain::needImpurePropertyWatchpoint(VM& vm) const
 {
-    for (Structure* structure : m_chain) {
-        if (structure->needImpurePropertyWatchpoint())
+    for (StructureID structureID : m_chain) {
+        if (vm.getStructure(structureID)->needImpurePropertyWatchpoint())
             return true;
     }
     return false;
 }
 
@@ -110,11 +98,11 @@
 }
 
 void PolyProtoAccessChain::dump(Structure* baseStructure, PrintStream& out) const
 {
     out.print("PolyPolyProtoAccessChain: [\n");
-    forEach(baseStructure, [&] (Structure* structure, bool) {
+    forEach(baseStructure->vm(), baseStructure, [&] (Structure* structure, bool) {
         out.print("\t");
         structure->dump(out);
         out.print("\n");
     });
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/PointerLockController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012 Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1.  Redistributions of source code must retain the above copyright
  8  *     notice, this list of conditions and the following disclaimer.
  9  * 2.  Redistributions in binary form must reproduce the above copyright
 10  *     notice, this list of conditions and the following disclaimer in the
 11  *     documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;PointerLockController.h&quot;
 27 
 28 #if ENABLE(POINTER_LOCK)
 29 
 30 #include &quot;Chrome.h&quot;
 31 #include &quot;ChromeClient.h&quot;
 32 #include &quot;Element.h&quot;
 33 #include &quot;Event.h&quot;
 34 #include &quot;EventNames.h&quot;
 35 #include &quot;Page.h&quot;
 36 #include &quot;PlatformMouseEvent.h&quot;
<a name="1" id="anc1"></a>
 37 #include &quot;UserGestureIndicator.h&quot;
 38 #include &quot;VoidCallback.h&quot;
 39 
 40 #if ENABLE(POINTER_EVENTS)
 41 #include &quot;PointerCaptureController.h&quot;
 42 #endif
 43 
 44 namespace WebCore {
 45 
 46 PointerLockController::PointerLockController(Page&amp; page)
 47     : m_page(page)
 48 {
 49 }
 50 
 51 void PointerLockController::requestPointerLock(Element* target)
 52 {
 53     if (!target || !target-&gt;isConnected() || m_documentOfRemovedElementWhileWaitingForUnlock) {
 54         enqueueEvent(eventNames().pointerlockerrorEvent, target);
 55         return;
 56     }
 57 
 58     if (m_documentAllowedToRelockWithoutUserGesture != &amp;target-&gt;document() &amp;&amp; !UserGestureIndicator::processingUserGesture()) {
 59         enqueueEvent(eventNames().pointerlockerrorEvent, target);
 60         return;
 61     }
 62 
 63     if (target-&gt;document().isSandboxed(SandboxPointerLock)) {
 64         // FIXME: This message should be moved off the console once a solution to https://bugs.webkit.org/show_bug.cgi?id=103274 exists.
 65         target-&gt;document().addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked pointer lock on an element because the element&#39;s frame is sandboxed and the &#39;allow-pointer-lock&#39; permission is not set.&quot;_s);
 66         enqueueEvent(eventNames().pointerlockerrorEvent, target);
 67         return;
 68     }
 69 
 70     if (m_element) {
 71         if (&amp;m_element-&gt;document() != &amp;target-&gt;document()) {
 72             enqueueEvent(eventNames().pointerlockerrorEvent, target);
 73             return;
 74         }
 75         m_element = target;
 76         enqueueEvent(eventNames().pointerlockchangeEvent, target);
 77 #if ENABLE(POINTER_EVENTS)
 78         m_page.pointerCaptureController().pointerLockWasApplied();
 79 #endif
 80     } else {
 81         m_lockPending = true;
 82         m_element = target;
 83         if (!m_page.chrome().client().requestPointerLock()) {
 84             clearElement();
 85             enqueueEvent(eventNames().pointerlockerrorEvent, target);
 86         }
 87     }
 88 }
 89 
 90 void PointerLockController::requestPointerUnlock()
 91 {
 92     if (!m_element)
 93         return;
 94 
 95     m_unlockPending = true;
 96     m_page.chrome().client().requestPointerUnlock();
 97 }
 98 
 99 void PointerLockController::requestPointerUnlockAndForceCursorVisible()
100 {
101     m_documentAllowedToRelockWithoutUserGesture = nullptr;
102 
103     if (!m_element)
104         return;
105 
106     m_unlockPending = true;
107     m_page.chrome().client().requestPointerUnlock();
108     m_forceCursorVisibleUponUnlock = true;
109 }
110 
111 void PointerLockController::elementRemoved(Element&amp; element)
112 {
113     if (m_element == &amp;element) {
114         m_documentOfRemovedElementWhileWaitingForUnlock = makeWeakPtr(m_element-&gt;document());
115         // Set element null immediately to block any future interaction with it
116         // including mouse events received before the unlock completes.
117         requestPointerUnlock();
118         clearElement();
119     }
120 }
121 
122 void PointerLockController::documentDetached(Document&amp; document)
123 {
124     if (m_documentAllowedToRelockWithoutUserGesture == &amp;document)
125         m_documentAllowedToRelockWithoutUserGesture = nullptr;
126 
127     if (m_element &amp;&amp; &amp;m_element-&gt;document() == &amp;document) {
128         m_documentOfRemovedElementWhileWaitingForUnlock = makeWeakPtr(m_element-&gt;document());
129         requestPointerUnlock();
130         clearElement();
131     }
132 }
133 
134 bool PointerLockController::isLocked() const
135 {
136     return m_element &amp;&amp; !m_lockPending;
137 }
138 
139 bool PointerLockController::lockPending() const
140 {
141     return m_lockPending;
142 }
143 
144 Element* PointerLockController::element() const
145 {
146     return m_element.get();
147 }
148 
149 void PointerLockController::didAcquirePointerLock()
150 {
151     if (!m_lockPending)
152         return;
153 
154     ASSERT(m_element);
155 
156     enqueueEvent(eventNames().pointerlockchangeEvent, m_element.get());
157     m_lockPending = false;
158     m_forceCursorVisibleUponUnlock = false;
159     m_documentAllowedToRelockWithoutUserGesture = makeWeakPtr(m_element-&gt;document());
160 }
161 
162 void PointerLockController::didNotAcquirePointerLock()
163 {
164     enqueueEvent(eventNames().pointerlockerrorEvent, m_element.get());
165     clearElement();
166     m_unlockPending = false;
167 }
168 
169 void PointerLockController::didLosePointerLock()
170 {
171     if (!m_unlockPending)
172         m_documentAllowedToRelockWithoutUserGesture = nullptr;
173 
174     enqueueEvent(eventNames().pointerlockchangeEvent, m_element ? &amp;m_element-&gt;document() : m_documentOfRemovedElementWhileWaitingForUnlock.get());
175     clearElement();
176     m_unlockPending = false;
177     m_documentOfRemovedElementWhileWaitingForUnlock = nullptr;
178     if (m_forceCursorVisibleUponUnlock) {
179         m_forceCursorVisibleUponUnlock = false;
180         m_page.chrome().client().setCursorHiddenUntilMouseMoves(false);
181     }
182 }
183 
184 void PointerLockController::dispatchLockedMouseEvent(const PlatformMouseEvent&amp; event, const AtomString&amp; eventType)
185 {
186     if (!m_element || !m_element-&gt;document().frame())
187         return;
188 
189     m_element-&gt;dispatchMouseEvent(event, eventType, event.clickCount());
190 
191     // Create click events
192     if (eventType == eventNames().mouseupEvent)
193         m_element-&gt;dispatchMouseEvent(event, eventNames().clickEvent, event.clickCount());
194 }
195 
196 void PointerLockController::dispatchLockedWheelEvent(const PlatformWheelEvent&amp; event)
197 {
198     if (!m_element || !m_element-&gt;document().frame())
199         return;
200 
201     m_element-&gt;dispatchWheelEvent(event);
202 }
203 
204 void PointerLockController::clearElement()
205 {
206     m_lockPending = false;
207     m_element = nullptr;
208 }
209 
210 void PointerLockController::enqueueEvent(const AtomString&amp; type, Element* element)
211 {
212     if (element)
213         enqueueEvent(type, &amp;element-&gt;document());
214 }
215 
216 void PointerLockController::enqueueEvent(const AtomString&amp; type, Document* document)
217 {
<a name="2" id="anc2"></a><span class="line-modified">218     // FIXME: Spec doesn&#39;t specify which task source use.</span>
<span class="line-modified">219     if (auto protectedDocument = makeRefPtr(document))</span>
<span class="line-added">220         protectedDocument-&gt;queueTaskToDispatchEvent(TaskSource::UserInteraction, Event::create(type, Event::CanBubble::Yes, Event::IsCancelable::No));</span>
221 }
222 
223 } // namespace WebCore
224 
225 #endif // ENABLE(POINTER_LOCK)
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
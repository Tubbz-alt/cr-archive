<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/editing/ApplyStyleCommand.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2005, 2006, 2008, 2009 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;ApplyStyleCommand.h&quot;
  28 
  29 #include &quot;CSSComputedStyleDeclaration.h&quot;
  30 #include &quot;CSSParser.h&quot;
  31 #include &quot;CSSValuePool.h&quot;
  32 #include &quot;Document.h&quot;
  33 #include &quot;Editing.h&quot;
  34 #include &quot;Editor.h&quot;
  35 #include &quot;ElementIterator.h&quot;
  36 #include &quot;Frame.h&quot;
  37 #include &quot;HTMLFontElement.h&quot;
  38 #include &quot;HTMLIFrameElement.h&quot;
  39 #include &quot;HTMLInterchange.h&quot;
  40 #include &quot;HTMLNames.h&quot;
  41 #include &quot;HTMLSpanElement.h&quot;
  42 #include &quot;NodeList.h&quot;
  43 #include &quot;NodeTraversal.h&quot;
  44 #include &quot;RenderObject.h&quot;
  45 #include &quot;RenderText.h&quot;
  46 #include &quot;StyleProperties.h&quot;
  47 #include &quot;StyleResolver.h&quot;
  48 #include &quot;Text.h&quot;
  49 #include &quot;TextIterator.h&quot;
  50 #include &quot;TextNodeTraversal.h&quot;
  51 #include &quot;VisibleUnits.h&quot;
  52 #include &lt;wtf/NeverDestroyed.h&gt;
  53 #include &lt;wtf/StdLibExtras.h&gt;
  54 #include &lt;wtf/text/StringBuilder.h&gt;
  55 
  56 namespace WebCore {
  57 
  58 using namespace HTMLNames;
  59 
  60 static int toIdentifier(RefPtr&lt;CSSValue&gt;&amp;&amp; value)
  61 {
  62     return is&lt;CSSPrimitiveValue&gt;(value) ? downcast&lt;CSSPrimitiveValue&gt;(*value).valueID() : 0;
  63 }
  64 
  65 static String&amp; styleSpanClassString()
  66 {
  67     static NeverDestroyed&lt;String&gt; styleSpanClassString(AppleStyleSpanClass);
  68     return styleSpanClassString;
  69 }
  70 
  71 bool isLegacyAppleStyleSpan(const Node* node)
  72 {
  73     if (!is&lt;HTMLSpanElement&gt;(node))
  74         return false;
  75 
  76     return downcast&lt;HTMLSpanElement&gt;(*node).attributeWithoutSynchronization(classAttr) == styleSpanClassString();
  77 }
  78 
  79 static bool hasNoAttributeOrOnlyStyleAttribute(const StyledElement&amp; element, ShouldStyleAttributeBeEmpty shouldStyleAttributeBeEmpty)
  80 {
  81     if (!element.hasAttributes())
  82         return true;
  83 
  84     unsigned matchedAttributes = 0;
  85     if (element.attributeWithoutSynchronization(classAttr) == styleSpanClassString())
  86         matchedAttributes++;
  87     if (element.hasAttribute(styleAttr) &amp;&amp; (shouldStyleAttributeBeEmpty == AllowNonEmptyStyleAttribute
  88         || !element.inlineStyle() || element.inlineStyle()-&gt;isEmpty()))
  89         matchedAttributes++;
  90 
  91     ASSERT(matchedAttributes &lt;= element.attributeCount());
  92     return matchedAttributes == element.attributeCount();
  93 }
  94 
  95 bool isStyleSpanOrSpanWithOnlyStyleAttribute(const Element&amp; element)
  96 {
  97     if (!is&lt;HTMLSpanElement&gt;(element))
  98         return false;
  99     return hasNoAttributeOrOnlyStyleAttribute(downcast&lt;HTMLSpanElement&gt;(element), AllowNonEmptyStyleAttribute);
 100 }
 101 
 102 static inline bool isSpanWithoutAttributesOrUnstyledStyleSpan(const Element&amp; element)
 103 {
 104     if (!is&lt;HTMLSpanElement&gt;(element))
 105         return false;
 106     return hasNoAttributeOrOnlyStyleAttribute(downcast&lt;HTMLSpanElement&gt;(element), StyleAttributeShouldBeEmpty);
 107 }
 108 
 109 bool isEmptyFontTag(const Element* element, ShouldStyleAttributeBeEmpty shouldStyleAttributeBeEmpty)
 110 {
 111     if (!is&lt;HTMLFontElement&gt;(element))
 112         return false;
 113 
 114     return hasNoAttributeOrOnlyStyleAttribute(downcast&lt;HTMLFontElement&gt;(*element), shouldStyleAttributeBeEmpty);
 115 }
 116 
 117 static Ref&lt;HTMLElement&gt; createFontElement(Document&amp; document)
 118 {
 119     return createHTMLElement(document, fontTag);
 120 }
 121 
 122 Ref&lt;HTMLElement&gt; createStyleSpanElement(Document&amp; document)
 123 {
 124     return createHTMLElement(document, spanTag);
 125 }
 126 
 127 ApplyStyleCommand::ApplyStyleCommand(Document&amp; document, const EditingStyle* style, EditAction editingAction, EPropertyLevel propertyLevel)
 128     : CompositeEditCommand(document, editingAction)
 129     , m_style(style-&gt;copy())
 130     , m_propertyLevel(propertyLevel)
 131     , m_start(endingSelection().start().downstream())
 132     , m_end(endingSelection().end().upstream())
 133     , m_useEndingSelection(true)
 134     , m_removeOnly(false)
 135 {
 136 }
 137 
 138 ApplyStyleCommand::ApplyStyleCommand(Document&amp; document, const EditingStyle* style, const Position&amp; start, const Position&amp; end, EditAction editingAction, EPropertyLevel propertyLevel)
 139     : CompositeEditCommand(document, editingAction)
 140     , m_style(style-&gt;copy())
 141     , m_propertyLevel(propertyLevel)
 142     , m_start(start)
 143     , m_end(end)
 144     , m_useEndingSelection(false)
 145     , m_removeOnly(false)
 146 {
 147 }
 148 
 149 ApplyStyleCommand::ApplyStyleCommand(Ref&lt;Element&gt;&amp;&amp; element, bool removeOnly, EditAction editingAction)
 150     : CompositeEditCommand(element-&gt;document(), editingAction)
 151     , m_style(EditingStyle::create())
 152     , m_propertyLevel(PropertyDefault)
 153     , m_start(endingSelection().start().downstream())
 154     , m_end(endingSelection().end().upstream())
 155     , m_useEndingSelection(true)
 156     , m_styledInlineElement(WTFMove(element))
 157     , m_removeOnly(removeOnly)
 158 {
 159 }
 160 
 161 ApplyStyleCommand::ApplyStyleCommand(Document&amp; document, const EditingStyle* style, IsInlineElementToRemoveFunction isInlineElementToRemoveFunction, EditAction editingAction)
 162     : CompositeEditCommand(document, editingAction)
 163     , m_style(style-&gt;copy())
 164     , m_propertyLevel(PropertyDefault)
 165     , m_start(endingSelection().start().downstream())
 166     , m_end(endingSelection().end().upstream())
 167     , m_useEndingSelection(true)
 168     , m_removeOnly(true)
 169     , m_isInlineElementToRemoveFunction(isInlineElementToRemoveFunction)
 170 {
 171 }
 172 
 173 void ApplyStyleCommand::updateStartEnd(const Position&amp; newStart, const Position&amp; newEnd)
 174 {
 175     ASSERT(comparePositions(newEnd, newStart) &gt;= 0);
 176 
 177     if (!m_useEndingSelection &amp;&amp; (newStart != m_start || newEnd != m_end))
 178         m_useEndingSelection = true;
 179 
 180     bool wasBaseFirst = startingSelection().isBaseFirst() || !startingSelection().isDirectional();
 181     setEndingSelection(VisibleSelection(wasBaseFirst ? newStart : newEnd, wasBaseFirst ? newEnd : newStart, VP_DEFAULT_AFFINITY, endingSelection().isDirectional()));
 182     m_start = newStart;
 183     m_end = newEnd;
 184 }
 185 
 186 Position ApplyStyleCommand::startPosition()
 187 {
 188     if (m_useEndingSelection)
 189         return endingSelection().start();
 190 
 191     return m_start;
 192 }
 193 
 194 Position ApplyStyleCommand::endPosition()
 195 {
 196     if (m_useEndingSelection)
 197         return endingSelection().end();
 198 
 199     return m_end;
 200 }
 201 
 202 void ApplyStyleCommand::doApply()
 203 {
 204     switch (m_propertyLevel) {
 205     case PropertyDefault: {
 206         // Apply the block-centric properties of the style.
 207         auto blockStyle = m_style-&gt;extractAndRemoveBlockProperties();
 208         if (!blockStyle-&gt;isEmpty())
 209             applyBlockStyle(blockStyle);
 210         // Apply any remaining styles to the inline elements.
 211         if (!m_style-&gt;isEmpty() || m_styledInlineElement || m_isInlineElementToRemoveFunction) {
 212             applyRelativeFontStyleChange(m_style.get());
 213             applyInlineStyle(*m_style);
 214         }
 215         break;
 216     }
 217     case ForceBlockProperties:
 218         // Force all properties to be applied as block styles.
 219         applyBlockStyle(*m_style);
 220         break;
 221     }
 222 }
 223 
 224 void ApplyStyleCommand::applyBlockStyle(EditingStyle&amp; style)
 225 {
 226     // update document layout once before removing styles
 227     // so that we avoid the expense of updating before each and every call
 228     // to check a computed style
 229     document().updateLayoutIgnorePendingStylesheets();
 230 
 231     // get positions we want to use for applying style
 232     Position start = startPosition();
 233     Position end = endPosition();
 234     if (comparePositions(end, start) &lt; 0) {
 235         Position swap = start;
 236         start = end;
 237         end = swap;
 238     }
 239 
 240     VisiblePosition visibleStart(start);
 241     VisiblePosition visibleEnd(end);
 242 
 243     if (visibleStart.isNull() || visibleStart.isOrphan() || visibleEnd.isNull() || visibleEnd.isOrphan())
 244         return;
 245 
 246     // Save and restore the selection endpoints using their indices in the editable root, since
 247     // addBlockStyleIfNeeded may moveParagraphs, which can remove these endpoints.
 248     // Calculate start and end indices from the start of the tree that they&#39;re in.
 249     auto* scope = highestEditableRoot(visibleStart.deepEquivalent());
 250     if (!scope)
 251         return;
 252 
 253     auto startRange = Range::create(document(), firstPositionInNode(scope), visibleStart.deepEquivalent().parentAnchoredEquivalent());
 254     auto endRange = Range::create(document(), firstPositionInNode(scope), visibleEnd.deepEquivalent().parentAnchoredEquivalent());
 255     int startIndex = TextIterator::rangeLength(startRange.ptr(), true);
 256     int endIndex = TextIterator::rangeLength(endRange.ptr(), true);
 257 
 258     VisiblePosition paragraphStart(startOfParagraph(visibleStart));
 259     VisiblePosition nextParagraphStart(endOfParagraph(paragraphStart).next());
 260     if (visibleEnd != visibleStart &amp;&amp; isStartOfParagraph(visibleEnd))
 261         visibleEnd = visibleEnd.previous(CannotCrossEditingBoundary);
 262     VisiblePosition beyondEnd(endOfParagraph(visibleEnd).next());
 263     while (paragraphStart.isNotNull() &amp;&amp; paragraphStart != beyondEnd) {
 264         StyleChange styleChange(&amp;style, paragraphStart.deepEquivalent());
 265         if (styleChange.cssStyle() || m_removeOnly) {
 266             RefPtr&lt;Node&gt; block = enclosingBlock(paragraphStart.deepEquivalent().deprecatedNode());
 267             if (!m_removeOnly) {
 268                 RefPtr&lt;Node&gt; newBlock = moveParagraphContentsToNewBlockIfNecessary(paragraphStart.deepEquivalent());
 269                 if (newBlock)
 270                     block = newBlock;
 271             }
 272             ASSERT(!block || is&lt;HTMLElement&gt;(*block));
 273             if (is&lt;HTMLElement&gt;(block)) {
 274                 removeCSSStyle(style, downcast&lt;HTMLElement&gt;(*block));
 275                 if (!m_removeOnly)
 276                     addBlockStyle(styleChange, downcast&lt;HTMLElement&gt;(*block));
 277             }
 278 
 279             if (nextParagraphStart.isOrphan())
 280                 nextParagraphStart = endOfParagraph(paragraphStart).next();
 281         }
 282 
 283         paragraphStart = nextParagraphStart;
 284         nextParagraphStart = endOfParagraph(paragraphStart).next();
 285     }
 286 
 287     {
 288         auto startRange = TextIterator::rangeFromLocationAndLength(scope, startIndex, 0, true);
 289         auto endRange = TextIterator::rangeFromLocationAndLength(scope, endIndex, 0, true);
 290         if (startRange &amp;&amp; endRange)
 291             updateStartEnd(startRange-&gt;startPosition(), endRange-&gt;startPosition());
 292     }
 293 }
 294 
 295 static Ref&lt;MutableStyleProperties&gt; copyStyleOrCreateEmpty(const StyleProperties* style)
 296 {
 297     if (!style)
 298         return MutableStyleProperties::create();
 299     return style-&gt;mutableCopy();
 300 }
 301 
 302 void ApplyStyleCommand::applyRelativeFontStyleChange(EditingStyle* style)
 303 {
 304     static const float MinimumFontSize = 0.1f;
 305 
 306     if (!style || !style-&gt;hasFontSizeDelta())
 307         return;
 308 
 309     Position start = startPosition();
 310     Position end = endPosition();
 311     if (comparePositions(end, start) &lt; 0) {
 312         Position swap = start;
 313         start = end;
 314         end = swap;
 315     }
 316 
 317     // Join up any adjacent text nodes.
 318     if (is&lt;Text&gt;(*start.deprecatedNode())) {
 319         joinChildTextNodes(start.deprecatedNode()-&gt;parentNode(), start, end);
 320         start = startPosition();
 321         end = endPosition();
 322     }
 323 
 324     if (start.isNull() || end.isNull())
 325         return;
 326 
 327     if (is&lt;Text&gt;(*end.deprecatedNode()) &amp;&amp; start.deprecatedNode()-&gt;parentNode() != end.deprecatedNode()-&gt;parentNode()) {
 328         joinChildTextNodes(end.deprecatedNode()-&gt;parentNode(), start, end);
 329         start = startPosition();
 330         end = endPosition();
 331     }
 332 
 333     if (start.isNull() || end.isNull())
 334         return;
 335 
 336     // Split the start text nodes if needed to apply style.
 337     if (isValidCaretPositionInTextNode(start)) {
 338         splitTextAtStart(start, end);
 339         start = startPosition();
 340         end = endPosition();
 341     }
 342 
 343     if (start.isNull() || end.isNull())
 344         return;
 345 
 346     if (isValidCaretPositionInTextNode(end)) {
 347         splitTextAtEnd(start, end);
 348         start = startPosition();
 349         end = endPosition();
 350     }
 351 
 352     if (start.isNull() || end.isNull())
 353         return;
 354 
 355     // Calculate loop end point.
 356     // If the end node is before the start node (can only happen if the end node is
 357     // an ancestor of the start node), we gather nodes up to the next sibling of the end node
 358     Node* beyondEnd;
 359     ASSERT(start.deprecatedNode());
 360     ASSERT(end.deprecatedNode());
 361     if (start.deprecatedNode()-&gt;isDescendantOf(*end.deprecatedNode()))
 362         beyondEnd = NodeTraversal::nextSkippingChildren(*end.deprecatedNode());
 363     else
 364         beyondEnd = NodeTraversal::next(*end.deprecatedNode());
 365 
 366     start = start.upstream(); // Move upstream to ensure we do not add redundant spans.
 367     Node* startNode = start.deprecatedNode();
 368 
 369     // Make sure we&#39;re not already at the end or the next NodeTraversal::next() will traverse past it.
 370     if (startNode == beyondEnd)
 371         return;
 372 
 373     if (is&lt;Text&gt;(*startNode) &amp;&amp; start.deprecatedEditingOffset() &gt;= caretMaxOffset(*startNode)) {
 374         // Move out of text node if range does not include its characters.
 375         startNode = NodeTraversal::next(*startNode);
 376         if (!startNode)
 377             return;
 378     }
 379 
 380     // Store away font size before making any changes to the document.
 381     // This ensures that changes to one node won&#39;t effect another.
 382     HashMap&lt;Node*, float&gt; startingFontSizes;
 383     for (Node* node = startNode; node != beyondEnd; node = NodeTraversal::next(*node)) {
 384         ASSERT(node);
 385         startingFontSizes.set(node, computedFontSize(node));
 386     }
 387 
 388     // These spans were added by us. If empty after font size changes, they can be removed.
 389     Vector&lt;Ref&lt;HTMLElement&gt;&gt; unstyledSpans;
 390 
 391     Node* lastStyledNode = nullptr;
 392     for (Node* node = startNode; node != beyondEnd; node = NodeTraversal::next(*node)) {
 393         ASSERT(node);
 394         RefPtr&lt;HTMLElement&gt; element;
 395         if (is&lt;HTMLElement&gt;(*node)) {
 396             // Only work on fully selected nodes.
 397             if (!nodeFullySelected(downcast&lt;HTMLElement&gt;(*node), start, end))
 398                 continue;
 399             element = &amp;downcast&lt;HTMLElement&gt;(*node);
 400         } else if (is&lt;Text&gt;(*node) &amp;&amp; node-&gt;renderer() &amp;&amp; node-&gt;parentNode() != lastStyledNode) {
 401             // Last styled node was not parent node of this text node, but we wish to style this
 402             // text node. To make this possible, add a style span to surround this text node.
 403             auto span = createStyleSpanElement(document());
 404             surroundNodeRangeWithElement(*node, *node, span.copyRef());
 405             element = WTFMove(span);
 406         }  else {
 407             // Only handle HTML elements and text nodes.
 408             continue;
 409         }
 410         lastStyledNode = node;
 411 
 412         RefPtr&lt;MutableStyleProperties&gt; inlineStyle = copyStyleOrCreateEmpty(element-&gt;inlineStyle());
 413         float currentFontSize = computedFontSize(node);
 414         float desiredFontSize = std::max(MinimumFontSize, startingFontSizes.get(node) + style-&gt;fontSizeDelta());
 415         RefPtr&lt;CSSValue&gt; value = inlineStyle-&gt;getPropertyCSSValue(CSSPropertyFontSize);
 416         if (value) {
 417             element-&gt;removeInlineStyleProperty(CSSPropertyFontSize);
 418             currentFontSize = computedFontSize(node);
 419         }
 420         if (currentFontSize != desiredFontSize) {
<a name="1" id="anc1"></a><span class="line-modified"> 421             inlineStyle-&gt;setProperty(CSSPropertyFontSize, CSSValuePool::singleton().createValue(desiredFontSize, CSSUnitType::CSS_PX), false);</span>
 422             setNodeAttribute(*element, styleAttr, inlineStyle-&gt;asText());
 423         }
 424         if (inlineStyle-&gt;isEmpty()) {
 425             removeNodeAttribute(*element, styleAttr);
 426             if (isSpanWithoutAttributesOrUnstyledStyleSpan(*element))
 427                 unstyledSpans.append(element.releaseNonNull());
 428         }
 429     }
 430 
 431     for (auto&amp; unstyledSpan : unstyledSpans)
 432         removeNodePreservingChildren(unstyledSpan);
 433 }
 434 
 435 static ContainerNode* dummySpanAncestorForNode(const Node* node)
 436 {
 437     while (node &amp;&amp; (!is&lt;Element&gt;(*node) || !isStyleSpanOrSpanWithOnlyStyleAttribute(downcast&lt;Element&gt;(*node))))
 438         node = node-&gt;parentNode();
 439 
 440     return node ? node-&gt;parentNode() : nullptr;
 441 }
 442 
 443 void ApplyStyleCommand::cleanupUnstyledAppleStyleSpans(ContainerNode* dummySpanAncestor)
 444 {
 445     if (!dummySpanAncestor)
 446         return;
 447 
 448     // Dummy spans are created when text node is split, so that style information
 449     // can be propagated, which can result in more splitting. If a dummy span gets
 450     // cloned/split, the new node is always a sibling of it. Therefore, we scan
 451     // all the children of the dummy&#39;s parent
 452 
 453     Vector&lt;Element*&gt; toRemove;
 454     for (auto&amp; child : childrenOfType&lt;Element&gt;(*dummySpanAncestor)) {
 455         if (isSpanWithoutAttributesOrUnstyledStyleSpan(child))
 456             toRemove.append(&amp;child);
 457     }
 458 
 459     for (auto&amp; element : toRemove)
 460         removeNodePreservingChildren(*element);
 461 }
 462 
 463 HTMLElement* ApplyStyleCommand::splitAncestorsWithUnicodeBidi(Node* node, bool before, WritingDirection allowedDirection)
 464 {
 465     // We are allowed to leave the highest ancestor with unicode-bidi unsplit if it is unicode-bidi: embed and direction: allowedDirection.
 466     // In that case, we return the unsplit ancestor. Otherwise, we return 0.
 467     Element* block = enclosingBlock(node);
 468     if (!block || block == node)
 469         return 0;
 470 
 471     Node* highestAncestorWithUnicodeBidi = nullptr;
 472     Node* nextHighestAncestorWithUnicodeBidi = nullptr;
 473     int highestAncestorUnicodeBidi = 0;
 474     for (Node* n = node-&gt;parentNode(); n != block; n = n-&gt;parentNode()) {
 475         int unicodeBidi = toIdentifier(ComputedStyleExtractor(n).propertyValue(CSSPropertyUnicodeBidi));
 476         if (unicodeBidi &amp;&amp; unicodeBidi != CSSValueNormal) {
 477             highestAncestorUnicodeBidi = unicodeBidi;
 478             nextHighestAncestorWithUnicodeBidi = highestAncestorWithUnicodeBidi;
 479             highestAncestorWithUnicodeBidi = n;
 480         }
 481     }
 482 
 483     if (!highestAncestorWithUnicodeBidi)
 484         return 0;
 485 
 486     HTMLElement* unsplitAncestor = nullptr;
 487 
 488     if (allowedDirection != WritingDirection::Natural &amp;&amp; highestAncestorUnicodeBidi != CSSValueBidiOverride &amp;&amp; is&lt;HTMLElement&gt;(*highestAncestorWithUnicodeBidi)) {
 489         auto highestAncestorDirection = EditingStyle::create(highestAncestorWithUnicodeBidi, EditingStyle::AllProperties)-&gt;textDirection();
 490         if (highestAncestorDirection &amp;&amp; *highestAncestorDirection == allowedDirection) {
 491             if (!nextHighestAncestorWithUnicodeBidi)
 492                 return downcast&lt;HTMLElement&gt;(highestAncestorWithUnicodeBidi);
 493 
 494             unsplitAncestor = downcast&lt;HTMLElement&gt;(highestAncestorWithUnicodeBidi);
 495             highestAncestorWithUnicodeBidi = nextHighestAncestorWithUnicodeBidi;
 496         }
 497     }
 498 
 499     // Split every ancestor through highest ancestor with embedding.
 500     RefPtr&lt;Node&gt; currentNode = node;
 501     while (currentNode) {
 502         RefPtr&lt;Element&gt; parent = downcast&lt;Element&gt;(currentNode-&gt;parentNode());
 503         if (before ? currentNode-&gt;previousSibling() : currentNode-&gt;nextSibling())
 504             splitElement(*parent, before ? *currentNode : *currentNode-&gt;nextSibling());
 505         if (parent == highestAncestorWithUnicodeBidi)
 506             break;
 507         currentNode = parent;
 508     }
 509     return unsplitAncestor;
 510 }
 511 
 512 void ApplyStyleCommand::removeEmbeddingUpToEnclosingBlock(Node* node, Node* unsplitAncestor)
 513 {
 514     Element* block = enclosingBlock(node);
 515     if (!block || block == node)
 516         return;
 517 
 518     Node* parent = nullptr;
 519     for (Node* ancestor = node-&gt;parentNode(); ancestor != block &amp;&amp; ancestor != unsplitAncestor; ancestor = parent) {
 520         parent = ancestor-&gt;parentNode();
 521         if (!is&lt;StyledElement&gt;(*ancestor))
 522             continue;
 523 
 524         StyledElement&amp; element = downcast&lt;StyledElement&gt;(*ancestor);
 525         int unicodeBidi = toIdentifier(ComputedStyleExtractor(&amp;element).propertyValue(CSSPropertyUnicodeBidi));
 526         if (!unicodeBidi || unicodeBidi == CSSValueNormal)
 527             continue;
 528 
 529         // FIXME: This code should really consider the mapped attribute &#39;dir&#39;, the inline style declaration,
 530         // and all matching style rules in order to determine how to best set the unicode-bidi property to &#39;normal&#39;.
 531         // For now, it assumes that if the &#39;dir&#39; attribute is present, then removing it will suffice, and
 532         // otherwise it sets the property in the inline style declaration.
 533         if (element.hasAttributeWithoutSynchronization(dirAttr)) {
 534             // FIXME: If this is a BDO element, we should probably just remove it if it has no
 535             // other attributes, like we (should) do with B and I elements.
 536             removeNodeAttribute(element, dirAttr);
 537         } else {
 538             RefPtr&lt;MutableStyleProperties&gt; inlineStyle = copyStyleOrCreateEmpty(element.inlineStyle());
 539             inlineStyle-&gt;setProperty(CSSPropertyUnicodeBidi, CSSValueNormal);
 540             inlineStyle-&gt;removeProperty(CSSPropertyDirection);
 541             setNodeAttribute(element, styleAttr, inlineStyle-&gt;asText());
 542             if (isSpanWithoutAttributesOrUnstyledStyleSpan(element))
 543                 removeNodePreservingChildren(element);
 544         }
 545     }
 546 }
 547 
 548 static Node* highestEmbeddingAncestor(Node* startNode, Node* enclosingNode)
 549 {
 550     for (Node* n = startNode; n &amp;&amp; n != enclosingNode; n = n-&gt;parentNode()) {
 551         if (n-&gt;isHTMLElement() &amp;&amp; toIdentifier(ComputedStyleExtractor(n).propertyValue(CSSPropertyUnicodeBidi)) == CSSValueEmbed)
 552             return n;
 553     }
 554 
 555     return 0;
 556 }
 557 
 558 void ApplyStyleCommand::applyInlineStyle(EditingStyle&amp; style)
 559 {
 560     RefPtr&lt;ContainerNode&gt; startDummySpanAncestor;
 561     RefPtr&lt;ContainerNode&gt; endDummySpanAncestor;
 562 
 563     // update document layout once before removing styles
 564     // so that we avoid the expense of updating before each and every call
 565     // to check a computed style
 566     document().updateLayoutIgnorePendingStylesheets();
 567 
 568     // adjust to the positions we want to use for applying style
 569     Position start = startPosition();
 570     Position end = endPosition();
 571 
 572     if (start.isNull() || end.isNull())
 573         return;
 574 
 575     if (comparePositions(end, start) &lt; 0) {
 576         Position swap = start;
 577         start = end;
 578         end = swap;
 579     }
 580 
 581     // split the start node and containing element if the selection starts inside of it
 582     bool splitStart = isValidCaretPositionInTextNode(start);
 583     if (splitStart) {
 584         if (shouldSplitTextElement(start.deprecatedNode()-&gt;parentElement(), style))
 585             splitTextElementAtStart(start, end);
 586         else
 587             splitTextAtStart(start, end);
 588         start = startPosition();
 589         end = endPosition();
 590         startDummySpanAncestor = dummySpanAncestorForNode(start.deprecatedNode());
 591     }
 592 
 593     if (start.isNull() || end.isNull())
 594         return;
 595 
 596     // split the end node and containing element if the selection ends inside of it
 597     bool splitEnd = isValidCaretPositionInTextNode(end);
 598     if (splitEnd) {
 599         if (shouldSplitTextElement(end.deprecatedNode()-&gt;parentElement(), style))
 600             splitTextElementAtEnd(start, end);
 601         else
 602             splitTextAtEnd(start, end);
 603         start = startPosition();
 604         end = endPosition();
 605         endDummySpanAncestor = dummySpanAncestorForNode(end.deprecatedNode());
 606     }
 607 
 608     if (start.isNull() || end.isNull())
 609         return;
 610 
 611     // Remove style from the selection.
 612     // Use the upstream position of the start for removing style.
 613     // This will ensure we remove all traces of the relevant styles from the selection
 614     // and prevent us from adding redundant ones, as described in:
 615     // &lt;rdar://problem/3724344&gt; Bolding and unbolding creates extraneous tags
 616     Position removeStart = start.upstream();
 617     auto textDirection = style.textDirection();
 618     RefPtr&lt;EditingStyle&gt; styleWithoutEmbedding;
 619     RefPtr&lt;EditingStyle&gt; embeddingStyle;
 620     if (textDirection.hasValue()) {
 621         // Leave alone an ancestor that provides the desired single level embedding, if there is one.
 622         auto* startUnsplitAncestor = splitAncestorsWithUnicodeBidi(start.deprecatedNode(), true, *textDirection);
 623         auto* endUnsplitAncestor = splitAncestorsWithUnicodeBidi(end.deprecatedNode(), false, *textDirection);
 624         removeEmbeddingUpToEnclosingBlock(start.deprecatedNode(), startUnsplitAncestor);
 625         removeEmbeddingUpToEnclosingBlock(end.deprecatedNode(), endUnsplitAncestor);
 626 
 627         // Avoid removing the dir attribute and the unicode-bidi and direction properties from the unsplit ancestors.
 628         Position embeddingRemoveStart = removeStart;
 629         if (startUnsplitAncestor &amp;&amp; nodeFullySelected(*startUnsplitAncestor, removeStart, end))
 630             embeddingRemoveStart = positionInParentAfterNode(startUnsplitAncestor);
 631 
 632         Position embeddingRemoveEnd = end;
 633         if (endUnsplitAncestor &amp;&amp; nodeFullySelected(*endUnsplitAncestor, removeStart, end))
 634             embeddingRemoveEnd = positionInParentBeforeNode(endUnsplitAncestor).downstream();
 635 
 636         if (embeddingRemoveEnd != removeStart || embeddingRemoveEnd != end) {
 637             styleWithoutEmbedding = style.copy();
 638             embeddingStyle = styleWithoutEmbedding-&gt;extractAndRemoveTextDirection();
 639 
 640             if (comparePositions(embeddingRemoveStart, embeddingRemoveEnd) &lt;= 0)
 641                 removeInlineStyle(*embeddingStyle, embeddingRemoveStart, embeddingRemoveEnd);
 642         }
 643     }
 644 
 645     removeInlineStyle(styleWithoutEmbedding ? *styleWithoutEmbedding : style, removeStart, end);
 646     start = startPosition();
 647     end = endPosition();
 648     if (start.isNull() || start.isOrphan() || end.isNull() || end.isOrphan())
 649         return;
 650 
 651     if (splitStart &amp;&amp; mergeStartWithPreviousIfIdentical(start, end)) {
 652         start = startPosition();
 653         end = endPosition();
 654     }
 655 
 656     if (splitEnd) {
 657         mergeEndWithNextIfIdentical(start, end);
 658         start = startPosition();
 659         end = endPosition();
 660     }
 661 
 662     if (start.isNull() || end.isNull())
 663         return;
 664 
 665     // update document layout once before running the rest of the function
 666     // so that we avoid the expense of updating before each and every call
 667     // to check a computed style
 668     document().updateLayoutIgnorePendingStylesheets();
 669 
 670     RefPtr&lt;EditingStyle&gt; styleToApply = &amp;style;
 671     if (textDirection.hasValue()) {
 672         // Avoid applying the unicode-bidi and direction properties beneath ancestors that already have them.
 673         Node* embeddingStartNode = highestEmbeddingAncestor(start.deprecatedNode(), enclosingBlock(start.deprecatedNode()));
 674         Node* embeddingEndNode = highestEmbeddingAncestor(end.deprecatedNode(), enclosingBlock(end.deprecatedNode()));
 675 
 676         if (embeddingStartNode || embeddingEndNode) {
 677             Position embeddingApplyStart = embeddingStartNode ? positionInParentAfterNode(embeddingStartNode) : start;
 678             Position embeddingApplyEnd = embeddingEndNode ? positionInParentBeforeNode(embeddingEndNode) : end;
 679             ASSERT(embeddingApplyStart.isNotNull() &amp;&amp; embeddingApplyEnd.isNotNull());
 680 
 681             if (!embeddingStyle) {
 682                 styleWithoutEmbedding = style.copy();
 683                 embeddingStyle = styleWithoutEmbedding-&gt;extractAndRemoveTextDirection();
 684             }
 685             fixRangeAndApplyInlineStyle(*embeddingStyle, embeddingApplyStart, embeddingApplyEnd);
 686 
 687             styleToApply = styleWithoutEmbedding;
 688         }
 689     }
 690 
 691     fixRangeAndApplyInlineStyle(*styleToApply, start, end);
 692 
 693     // Remove dummy style spans created by splitting text elements.
 694     cleanupUnstyledAppleStyleSpans(startDummySpanAncestor.get());
 695     if (endDummySpanAncestor != startDummySpanAncestor)
 696         cleanupUnstyledAppleStyleSpans(endDummySpanAncestor.get());
 697 }
 698 
 699 void ApplyStyleCommand::fixRangeAndApplyInlineStyle(EditingStyle&amp; style, const Position&amp; start, const Position&amp; end)
 700 {
 701     Node* startNode = start.deprecatedNode();
 702 
 703     if (start.deprecatedEditingOffset() &gt;= caretMaxOffset(*startNode)) {
 704         startNode = NodeTraversal::next(*startNode);
 705         if (!startNode || comparePositions(end, firstPositionInOrBeforeNode(startNode)) &lt; 0)
 706             return;
 707     }
 708 
 709     Node* pastEndNode = end.deprecatedNode();
 710     if (end.deprecatedEditingOffset() &gt;= caretMaxOffset(*pastEndNode))
 711         pastEndNode = NodeTraversal::nextSkippingChildren(*pastEndNode);
 712 
 713     // FIXME: Callers should perform this operation on a Range that includes the br
 714     // if they want style applied to the empty line.
 715     // FIXME: Should this be using startNode instead of start.deprecatedNode()?
 716     if (start == end &amp;&amp; start.deprecatedNode()-&gt;hasTagName(brTag))
 717         pastEndNode = NodeTraversal::next(*start.deprecatedNode());
 718 
 719     // Start from the highest fully selected ancestor so that we can modify the fully selected node.
 720     // e.g. When applying font-size: large on &lt;font color=&quot;blue&quot;&gt;hello&lt;/font&gt;, we need to include the font element in our run
 721     // to generate &lt;font color=&quot;blue&quot; size=&quot;4&quot;&gt;hello&lt;/font&gt; instead of &lt;font color=&quot;blue&quot;&gt;&lt;font size=&quot;4&quot;&gt;hello&lt;/font&gt;&lt;/font&gt;
 722     auto range = Range::create(startNode-&gt;document(), start, end);
 723     auto* editableRoot = startNode-&gt;rootEditableElement();
 724     if (startNode != editableRoot) {
 725         while (editableRoot &amp;&amp; startNode-&gt;parentNode() != editableRoot &amp;&amp; isNodeVisiblyContainedWithin(*startNode-&gt;parentNode(), range))
 726             startNode = startNode-&gt;parentNode();
 727     }
 728 
 729     applyInlineStyleToNodeRange(style, *startNode, pastEndNode);
 730 }
 731 
 732 static bool containsNonEditableRegion(Node&amp; node)
 733 {
 734     if (!node.hasEditableStyle())
 735         return true;
 736 
 737     Node* sibling = NodeTraversal::nextSkippingChildren(node);
 738     for (Node* descendant = node.firstChild(); descendant &amp;&amp; descendant != sibling; descendant = NodeTraversal::next(*descendant)) {
 739         if (!descendant-&gt;hasEditableStyle())
 740             return true;
 741     }
 742 
 743     return false;
 744 }
 745 
 746 struct InlineRunToApplyStyle {
 747     InlineRunToApplyStyle(Node* start, Node* end, Node* pastEndNode)
 748         : start(start)
 749         , end(end)
 750         , pastEndNode(pastEndNode)
 751     {
 752         ASSERT(start-&gt;parentNode() == end-&gt;parentNode());
 753     }
 754 
 755     bool startAndEndAreStillInDocument()
 756     {
 757         return start &amp;&amp; end &amp;&amp; start-&gt;isConnected() &amp;&amp; end-&gt;isConnected();
 758     }
 759 
 760     RefPtr&lt;Node&gt; start;
 761     RefPtr&lt;Node&gt; end;
 762     RefPtr&lt;Node&gt; pastEndNode;
 763     Position positionForStyleComputation;
 764     RefPtr&lt;Node&gt; dummyElement;
 765     StyleChange change;
 766 };
 767 
 768 void ApplyStyleCommand::applyInlineStyleToNodeRange(EditingStyle&amp; style, Node&amp; startNode, Node* pastEndNode)
 769 {
 770     if (m_removeOnly)
 771         return;
 772 
 773     document().updateLayoutIgnorePendingStylesheets();
 774 
 775     Vector&lt;InlineRunToApplyStyle&gt; runs;
 776     RefPtr&lt;Node&gt; node = &amp;startNode;
 777     for (RefPtr&lt;Node&gt; next; node &amp;&amp; node != pastEndNode; node = next) {
 778         next = NodeTraversal::next(*node);
 779 
 780         if (!node-&gt;renderer() || !node-&gt;hasEditableStyle())
 781             continue;
 782 
 783         if (!node-&gt;hasRichlyEditableStyle() &amp;&amp; is&lt;HTMLElement&gt;(*node)) {
 784             // This is a plaintext-only region. Only proceed if it&#39;s fully selected.
 785             // pastEndNode is the node after the last fully selected node, so if it&#39;s inside node then
 786             // node isn&#39;t fully selected.
 787             if (pastEndNode &amp;&amp; pastEndNode-&gt;isDescendantOf(*node))
 788                 break;
 789             // Add to this element&#39;s inline style and skip over its contents.
 790             HTMLElement&amp; element = downcast&lt;HTMLElement&gt;(*node);
 791             RefPtr&lt;MutableStyleProperties&gt; inlineStyle = copyStyleOrCreateEmpty(element.inlineStyle());
 792             if (MutableStyleProperties* otherStyle = style.style())
 793                 inlineStyle-&gt;mergeAndOverrideOnConflict(*otherStyle);
 794             setNodeAttribute(element, styleAttr, inlineStyle-&gt;asText());
 795             next = NodeTraversal::nextSkippingChildren(*node);
 796             continue;
 797         }
 798 
 799         if (isBlock(node.get()))
 800             continue;
 801 
 802         if (node-&gt;hasChildNodes()) {
 803             if (node-&gt;contains(pastEndNode) || containsNonEditableRegion(*node) || !node-&gt;parentNode()-&gt;hasEditableStyle())
 804                 continue;
 805             if (editingIgnoresContent(*node)) {
 806                 next = NodeTraversal::nextSkippingChildren(*node);
 807                 continue;
 808             }
 809         }
 810 
 811         Node* runStart = node.get();
 812         Node* runEnd = node.get();
 813         Node* sibling = node-&gt;nextSibling();
 814         while (sibling &amp;&amp; sibling != pastEndNode &amp;&amp; !sibling-&gt;contains(pastEndNode) &amp;&amp; (!isBlock(sibling) || sibling-&gt;hasTagName(brTag)) &amp;&amp; !containsNonEditableRegion(*sibling)) {
 815             runEnd = sibling;
 816             sibling = runEnd-&gt;nextSibling();
 817         }
 818         next = NodeTraversal::nextSkippingChildren(*runEnd);
 819 
 820         Node* pastEndNode = NodeTraversal::nextSkippingChildren(*runEnd);
 821         if (!shouldApplyInlineStyleToRun(style, runStart, pastEndNode))
 822             continue;
 823 
 824         runs.append(InlineRunToApplyStyle(runStart, runEnd, pastEndNode));
 825     }
 826 
 827     for (auto&amp; run : runs) {
 828         removeConflictingInlineStyleFromRun(style, run.start, run.end, run.pastEndNode.get());
 829         if (run.startAndEndAreStillInDocument())
 830             run.positionForStyleComputation = positionToComputeInlineStyleChange(*run.start, run.dummyElement);
 831     }
 832 
 833     document().updateLayoutIgnorePendingStylesheets();
 834 
 835     for (auto&amp; run : runs)
 836         run.change = StyleChange(&amp;style, run.positionForStyleComputation);
 837 
 838     for (auto&amp; run : runs) {
 839         if (run.dummyElement)
 840             removeNode(*run.dummyElement);
 841         if (run.startAndEndAreStillInDocument())
 842             applyInlineStyleChange(run.start.releaseNonNull(), run.end.releaseNonNull(), run.change, AddStyledElement);
 843     }
 844 }
 845 
 846 bool ApplyStyleCommand::isStyledInlineElementToRemove(Element* element) const
 847 {
 848     return (m_styledInlineElement &amp;&amp; element-&gt;hasTagName(m_styledInlineElement-&gt;tagQName()))
 849         || (m_isInlineElementToRemoveFunction &amp;&amp; m_isInlineElementToRemoveFunction(element));
 850 }
 851 
 852 bool ApplyStyleCommand::shouldApplyInlineStyleToRun(EditingStyle&amp; style, Node* runStart, Node* pastEndNode)
 853 {
 854     ASSERT(runStart);
 855 
 856     for (Node* node = runStart; node &amp;&amp; node != pastEndNode; node = NodeTraversal::next(*node)) {
 857         if (node-&gt;hasChildNodes())
 858             continue;
 859         // We don&#39;t consider m_isInlineElementToRemoveFunction here because we never apply style when m_isInlineElementToRemoveFunction is specified
 860         if (!style.styleIsPresentInComputedStyleOfNode(*node))
 861             return true;
 862         if (m_styledInlineElement &amp;&amp; !enclosingElementWithTag(positionBeforeNode(node), m_styledInlineElement-&gt;tagQName()))
 863             return true;
 864     }
 865     return false;
 866 }
 867 
 868 void ApplyStyleCommand::removeConflictingInlineStyleFromRun(EditingStyle&amp; style, RefPtr&lt;Node&gt;&amp; runStart, RefPtr&lt;Node&gt;&amp; runEnd, Node* pastEndNode)
 869 {
 870     ASSERT(runStart &amp;&amp; runEnd);
 871     RefPtr&lt;Node&gt; next = runStart;
 872     for (RefPtr&lt;Node&gt; node = next; node &amp;&amp; node-&gt;isConnected() &amp;&amp; node != pastEndNode; node = next) {
 873         if (editingIgnoresContent(*node)) {
 874             ASSERT(!node-&gt;contains(pastEndNode));
 875             next = NodeTraversal::nextSkippingChildren(*node);
 876         } else
 877             next = NodeTraversal::next(*node);
 878 
 879         if (!is&lt;HTMLElement&gt;(*node))
 880             continue;
 881 
 882         RefPtr&lt;Node&gt; previousSibling = node-&gt;previousSibling();
 883         RefPtr&lt;Node&gt; nextSibling = node-&gt;nextSibling();
 884         RefPtr&lt;ContainerNode&gt; parent = node-&gt;parentNode();
 885         removeInlineStyleFromElement(style, downcast&lt;HTMLElement&gt;(*node), RemoveAlways);
 886         if (!node-&gt;isConnected()) {
 887             // FIXME: We might need to update the start and the end of current selection here but need a test.
 888             if (runStart == node)
 889                 runStart = previousSibling ? previousSibling-&gt;nextSibling() : parent-&gt;firstChild();
 890             if (runEnd == node)
 891                 runEnd = nextSibling ? nextSibling-&gt;previousSibling() : parent-&gt;lastChild();
 892         }
 893     }
 894 }
 895 
 896 bool ApplyStyleCommand::removeInlineStyleFromElement(EditingStyle&amp; style, HTMLElement&amp; element, InlineStyleRemovalMode mode, EditingStyle* extractedStyle)
 897 {
 898     if (!element.parentNode() || !isEditableNode(*element.parentNode()))
 899         return false;
 900 
 901     if (isStyledInlineElementToRemove(&amp;element)) {
 902         if (mode == RemoveNone)
 903             return true;
 904         if (extractedStyle)
 905             extractedStyle-&gt;mergeInlineStyleOfElement(element, EditingStyle::OverrideValues);
 906         removeNodePreservingChildren(element);
 907         return true;
 908     }
 909 
 910     bool removed = false;
 911     if (removeImplicitlyStyledElement(style, element, mode, extractedStyle))
 912         removed = true;
 913 
 914     if (!element.isConnected())
 915         return removed;
 916 
 917     // If the node was converted to a span, the span may still contain relevant
 918     // styles which must be removed (e.g. &lt;b style=&#39;font-weight: bold&#39;&gt;)
 919     if (removeCSSStyle(style, element, mode, extractedStyle))
 920         removed = true;
 921 
 922     return removed;
 923 }
 924 
 925 void ApplyStyleCommand::replaceWithSpanOrRemoveIfWithoutAttributes(HTMLElement&amp; element)
 926 {
 927     if (hasNoAttributeOrOnlyStyleAttribute(element, StyleAttributeShouldBeEmpty))
 928         removeNodePreservingChildren(element);
 929     else {
 930         HTMLElement* newSpanElement = replaceElementWithSpanPreservingChildrenAndAttributes(element);
 931         ASSERT_UNUSED(newSpanElement, newSpanElement &amp;&amp; newSpanElement-&gt;isConnected());
 932     }
 933 }
 934 
 935 bool ApplyStyleCommand::removeImplicitlyStyledElement(EditingStyle&amp; style, HTMLElement&amp; element, InlineStyleRemovalMode mode, EditingStyle* extractedStyle)
 936 {
 937     if (mode == RemoveNone) {
 938         ASSERT(!extractedStyle);
 939         return style.conflictsWithImplicitStyleOfElement(element) || style.conflictsWithImplicitStyleOfAttributes(element);
 940     }
 941 
 942     ASSERT(mode == RemoveIfNeeded || mode == RemoveAlways);
 943     if (style.conflictsWithImplicitStyleOfElement(element, extractedStyle, mode == RemoveAlways ? EditingStyle::ExtractMatchingStyle : EditingStyle::DoNotExtractMatchingStyle)) {
 944         replaceWithSpanOrRemoveIfWithoutAttributes(element);
 945         return true;
 946     }
 947 
 948     // unicode-bidi and direction are pushed down separately so don&#39;t push down with other styles
 949     Vector&lt;QualifiedName&gt; attributes;
 950     if (!style.extractConflictingImplicitStyleOfAttributes(element, extractedStyle ? EditingStyle::PreserveWritingDirection : EditingStyle::DoNotPreserveWritingDirection, extractedStyle, attributes, mode == RemoveAlways ? EditingStyle::ExtractMatchingStyle : EditingStyle::DoNotExtractMatchingStyle))
 951         return false;
 952 
 953     for (auto&amp; attribute : attributes)
 954         removeNodeAttribute(element, attribute);
 955 
 956     if (isEmptyFontTag(&amp;element) || isSpanWithoutAttributesOrUnstyledStyleSpan(element))
 957         removeNodePreservingChildren(element);
 958 
 959     return true;
 960 }
 961 
 962 bool ApplyStyleCommand::removeCSSStyle(EditingStyle&amp; style, HTMLElement&amp; element, InlineStyleRemovalMode mode, EditingStyle* extractedStyle)
 963 {
 964     if (mode == RemoveNone)
 965         return style.conflictsWithInlineStyleOfElement(element);
 966 
 967     RefPtr&lt;MutableStyleProperties&gt; newInlineStyle;
 968     if (!style.conflictsWithInlineStyleOfElement(element, newInlineStyle, extractedStyle))
 969         return false;
 970 
 971     if (newInlineStyle-&gt;isEmpty())
 972         removeNodeAttribute(element, styleAttr);
 973     else
 974         setNodeAttribute(element, styleAttr, newInlineStyle-&gt;asText());
 975 
 976     if (isSpanWithoutAttributesOrUnstyledStyleSpan(element))
 977         removeNodePreservingChildren(element);
 978 
 979     return true;
 980 }
 981 
 982 HTMLElement* ApplyStyleCommand::highestAncestorWithConflictingInlineStyle(EditingStyle&amp; style, Node* node)
 983 {
 984     if (!node)
 985         return nullptr;
 986 
 987     HTMLElement* result = nullptr;
 988     Node* unsplittableElement = unsplittableElementForPosition(firstPositionInOrBeforeNode(node));
 989 
 990     for (Node* ancestor = node; ancestor; ancestor = ancestor-&gt;parentNode()) {
 991         if (is&lt;HTMLElement&gt;(*ancestor) &amp;&amp; shouldRemoveInlineStyleFromElement(style, downcast&lt;HTMLElement&gt;(*ancestor)))
 992             result = downcast&lt;HTMLElement&gt;(ancestor);
 993         // Should stop at the editable root (cannot cross editing boundary) and
 994         // also stop at the unsplittable element to be consistent with other UAs
 995         if (ancestor == unsplittableElement)
 996             break;
 997     }
 998 
 999     return result;
1000 }
1001 
1002 void ApplyStyleCommand::applyInlineStyleToPushDown(Node&amp; node, EditingStyle* style)
1003 {
1004     node.document().updateStyleIfNeeded();
1005 
1006     if (!style || style-&gt;isEmpty() || !node.renderer() || is&lt;HTMLIFrameElement&gt;(node))
1007         return;
1008 
1009     RefPtr&lt;EditingStyle&gt; newInlineStyle = style;
1010     if (is&lt;HTMLElement&gt;(node) &amp;&amp; downcast&lt;HTMLElement&gt;(node).inlineStyle()) {
1011         newInlineStyle = style-&gt;copy();
1012         newInlineStyle-&gt;mergeInlineStyleOfElement(downcast&lt;HTMLElement&gt;(node), EditingStyle::OverrideValues);
1013     }
1014 
1015     // Since addInlineStyleIfNeeded can&#39;t add styles to block-flow render objects, add style attribute instead.
1016     // FIXME: applyInlineStyleToRange should be used here instead.
1017     if ((node.renderer()-&gt;isRenderBlockFlow() || node.hasChildNodes()) &amp;&amp; is&lt;HTMLElement&gt;(node)) {
1018         setNodeAttribute(downcast&lt;HTMLElement&gt;(node), styleAttr, newInlineStyle-&gt;style()-&gt;asText());
1019         return;
1020     }
1021 
1022     if (node.renderer()-&gt;isText() &amp;&amp; static_cast&lt;RenderText*&gt;(node.renderer())-&gt;isAllCollapsibleWhitespace())
1023         return;
1024     if (node.renderer()-&gt;isBR() &amp;&amp; !node.renderer()-&gt;style().preserveNewline())
1025         return;
1026 
1027     // We can&#39;t wrap node with the styled element here because new styled element will never be removed if we did.
1028     // If we modified the child pointer in pushDownInlineStyleAroundNode to point to new style element
1029     // then we fall into an infinite loop where we keep removing and adding styled element wrapping node.
1030     addInlineStyleIfNeeded(newInlineStyle.get(), node, node, DoNotAddStyledElement);
1031 }
1032 
1033 void ApplyStyleCommand::pushDownInlineStyleAroundNode(EditingStyle&amp; style, Node* targetNode)
1034 {
1035     HTMLElement* highestAncestor = highestAncestorWithConflictingInlineStyle(style, targetNode);
1036     if (!highestAncestor)
1037         return;
1038 
1039     // The outer loop is traversing the tree vertically from highestAncestor to targetNode
1040     RefPtr&lt;Node&gt; current = highestAncestor;
1041     // Along the way, styled elements that contain targetNode are removed and accumulated into elementsToPushDown.
1042     // Each child of the removed element, exclusing ancestors of targetNode, is then wrapped by clones of elements in elementsToPushDown.
1043     Vector&lt;Ref&lt;Element&gt;&gt; elementsToPushDown;
1044     while (current &amp;&amp; current != targetNode &amp;&amp; current-&gt;contains(targetNode)) {
1045         auto currentChildren = collectChildNodes(*current);
1046 
1047         RefPtr&lt;StyledElement&gt; styledElement;
1048         if (is&lt;StyledElement&gt;(*current) &amp;&amp; isStyledInlineElementToRemove(downcast&lt;Element&gt;(current.get()))) {
1049             styledElement = downcast&lt;StyledElement&gt;(current.get());
1050             elementsToPushDown.append(*styledElement);
1051         }
1052 
1053         auto styleToPushDown = EditingStyle::create();
1054         if (is&lt;HTMLElement&gt;(*current))
1055             removeInlineStyleFromElement(style, downcast&lt;HTMLElement&gt;(*current), RemoveIfNeeded, styleToPushDown.ptr());
1056 
1057         // The inner loop will go through children on each level
1058         // FIXME: we should aggregate inline child elements together so that we don&#39;t wrap each child separately.
1059         for (Ref&lt;Node&gt;&amp; childRef : currentChildren) {
1060             Node&amp; child = childRef;
1061             if (!child.parentNode())
1062                 continue;
1063             if (!child.contains(targetNode) &amp;&amp; elementsToPushDown.size()) {
1064                 for (auto&amp; element : elementsToPushDown) {
1065                     auto wrapper = element-&gt;cloneElementWithoutChildren(document());
1066                     wrapper-&gt;removeAttribute(styleAttr);
1067                     surroundNodeRangeWithElement(child, child, WTFMove(wrapper));
1068                 }
1069             }
1070 
1071             // Apply style to all nodes containing targetNode and their siblings but NOT to targetNode
1072             // But if we&#39;ve removed styledElement then always apply the style.
1073             if (&amp;child != targetNode || styledElement)
1074                 applyInlineStyleToPushDown(child, styleToPushDown.ptr());
1075 
1076             // We found the next node for the outer loop (contains targetNode)
1077             // When reached targetNode, stop the outer loop upon the completion of the current inner loop
1078             if (&amp;child == targetNode || child.contains(targetNode))
1079                 current = &amp;child;
1080         }
1081     }
1082 }
1083 
1084 void ApplyStyleCommand::removeInlineStyle(EditingStyle&amp; style, const Position&amp; start, const Position&amp; end)
1085 {
1086     ASSERT(start.isNotNull());
1087     ASSERT(end.isNotNull());
1088     ASSERT(start.anchorNode()-&gt;isConnected());
1089     ASSERT(end.anchorNode()-&gt;isConnected());
1090     ASSERT(comparePositions(start, end) &lt;= 0);
1091     // FIXME: We should assert that start/end are not in the middle of a text node.
1092 
1093     Position pushDownStart = start.downstream();
1094     // If the pushDownStart is at the end of a text node, then this node is not fully selected.
1095     // Move it to the next deep quivalent position to avoid removing the style from this node.
1096     // e.g. if pushDownStart was at Position(&quot;hello&quot;, 5) in &lt;b&gt;hello&lt;div&gt;world&lt;/div&gt;&lt;/b&gt;, we want Position(&quot;world&quot;, 0) instead.
1097     auto* pushDownStartContainer = pushDownStart.containerNode();
1098     if (is&lt;Text&gt;(pushDownStartContainer) &amp;&amp; pushDownStart.computeOffsetInContainerNode() == pushDownStartContainer-&gt;maxCharacterOffset())
1099         pushDownStart = nextVisuallyDistinctCandidate(pushDownStart);
1100     // If pushDownEnd is at the start of a text node, then this node is not fully selected.
1101     // Move it to the previous deep equivalent position to avoid removing the style from this node.
1102     Position pushDownEnd = end.upstream();
1103     auto* pushDownEndContainer = pushDownEnd.containerNode();
1104     if (is&lt;Text&gt;(pushDownEndContainer) &amp;&amp; !pushDownEnd.computeOffsetInContainerNode())
1105         pushDownEnd = previousVisuallyDistinctCandidate(pushDownEnd);
1106 
1107     pushDownInlineStyleAroundNode(style, pushDownStart.deprecatedNode());
1108     pushDownInlineStyleAroundNode(style, pushDownEnd.deprecatedNode());
1109 
1110     // The s and e variables store the positions used to set the ending selection after style removal
1111     // takes place. This will help callers to recognize when either the start node or the end node
1112     // are removed from the document during the work of this function.
1113     // If pushDownInlineStyleAroundNode has pruned start.deprecatedNode() or end.deprecatedNode(),
1114     // use pushDownStart or pushDownEnd instead, which pushDownInlineStyleAroundNode won&#39;t prune.
1115     Position s = start.isNull() || start.isOrphan() ? pushDownStart : start;
1116     Position e = end.isNull() || end.isOrphan() ? pushDownEnd : end;
1117 
1118     RefPtr&lt;Node&gt; node = start.deprecatedNode();
1119     while (node) {
1120         RefPtr&lt;Node&gt; next;
1121         if (editingIgnoresContent(*node)) {
1122             ASSERT(node == end.deprecatedNode() || !node-&gt;contains(end.deprecatedNode()));
1123             next = NodeTraversal::nextSkippingChildren(*node);
1124         } else
1125             next = NodeTraversal::next(*node);
1126 
1127         if (is&lt;HTMLElement&gt;(*node) &amp;&amp; nodeFullySelected(downcast&lt;HTMLElement&gt;(*node), start, end)) {
1128             Ref&lt;HTMLElement&gt; element = downcast&lt;HTMLElement&gt;(*node);
1129             RefPtr&lt;Node&gt; prev = NodeTraversal::previousPostOrder(element);
1130             RefPtr&lt;Node&gt; next = NodeTraversal::next(element);
1131             RefPtr&lt;EditingStyle&gt; styleToPushDown;
1132             RefPtr&lt;Node&gt; childNode;
1133             if (isStyledInlineElementToRemove(element.ptr())) {
1134                 styleToPushDown = EditingStyle::create();
1135                 childNode = element-&gt;firstChild();
1136             }
1137 
1138             removeInlineStyleFromElement(style, element, RemoveIfNeeded, styleToPushDown.get());
1139             if (!element-&gt;isConnected()) {
1140                 if (s.deprecatedNode() == element.ptr()) {
1141                     // Since elem must have been fully selected, and it is at the start
1142                     // of the selection, it is clear we can set the new s offset to 0.
1143                     ASSERT(s.anchorType() == Position::PositionIsBeforeAnchor || s.offsetInContainerNode() &lt;= 0);
1144                     s = firstPositionInOrBeforeNode(next.get());
1145                 }
1146                 if (e.deprecatedNode() == element.ptr()) {
1147                     // Since elem must have been fully selected, and it is at the end
1148                     // of the selection, it is clear we can set the new e offset to
1149                     // the max range offset of prev.
1150                     ASSERT(s.anchorType() == Position::PositionIsAfterAnchor || !offsetIsBeforeLastNodeOffset(s.offsetInContainerNode(), s.containerNode()));
1151                     e = lastPositionInOrAfterNode(prev.get());
1152                 }
1153             }
1154 
1155             if (styleToPushDown) {
1156                 for (; childNode; childNode = childNode-&gt;nextSibling())
1157                     applyInlineStyleToPushDown(*childNode, styleToPushDown.get());
1158             }
1159         }
1160         if (node == end.deprecatedNode())
1161             break;
1162         node = next.get();
1163     }
1164 
1165     updateStartEnd(s, e);
1166 }
1167 
1168 bool ApplyStyleCommand::nodeFullySelected(Element&amp; element, const Position&amp; start, const Position&amp; end) const
1169 {
1170     // The tree may have changed and Position::upstream() relies on an up-to-date layout.
1171     element.document().updateLayoutIgnorePendingStylesheets();
1172 
1173     return comparePositions(firstPositionInOrBeforeNode(&amp;element), start) &gt;= 0
1174         &amp;&amp; comparePositions(lastPositionInOrAfterNode(&amp;element).upstream(), end) &lt;= 0;
1175 }
1176 
1177 bool ApplyStyleCommand::nodeFullyUnselected(Element&amp; element, const Position&amp; start, const Position&amp; end) const
1178 {
1179     // The tree may have changed and Position::upstream() relies on an up-to-date layout.
1180     element.document().updateLayoutIgnorePendingStylesheets();
1181 
1182     return comparePositions(lastPositionInOrAfterNode(&amp;element).upstream(), start) &lt; 0
1183         || comparePositions(firstPositionInOrBeforeNode(&amp;element), end) &gt; 0;
1184 }
1185 
1186 void ApplyStyleCommand::splitTextAtStart(const Position&amp; start, const Position&amp; end)
1187 {
1188     ASSERT(is&lt;Text&gt;(start.containerNode()));
1189 
1190     Position newEnd;
1191     if (end.anchorType() == Position::PositionIsOffsetInAnchor &amp;&amp; start.containerNode() == end.containerNode())
1192         newEnd = Position(end.containerText(), end.offsetInContainerNode() - start.offsetInContainerNode());
1193     else
1194         newEnd = end;
1195 
1196     RefPtr&lt;Text&gt; text = start.containerText();
1197     splitTextNode(*text, start.offsetInContainerNode());
1198     updateStartEnd(firstPositionInNode(text.get()), newEnd);
1199 }
1200 
1201 void ApplyStyleCommand::splitTextAtEnd(const Position&amp; start, const Position&amp; end)
1202 {
1203     ASSERT(is&lt;Text&gt;(end.containerNode()));
1204 
1205     bool shouldUpdateStart = start.anchorType() == Position::PositionIsOffsetInAnchor &amp;&amp; start.containerNode() == end.containerNode();
1206     Text&amp; text = downcast&lt;Text&gt;(*end.deprecatedNode());
1207     splitTextNode(text, end.offsetInContainerNode());
1208 
1209     Node* prevNode = text.previousSibling();
1210     if (!is&lt;Text&gt;(prevNode))
1211         return;
1212 
1213     Position newStart = shouldUpdateStart ? Position(downcast&lt;Text&gt;(prevNode), start.offsetInContainerNode()) : start;
1214     updateStartEnd(newStart, lastPositionInNode(prevNode));
1215 }
1216 
1217 void ApplyStyleCommand::splitTextElementAtStart(const Position&amp; start, const Position&amp; end)
1218 {
1219     ASSERT(is&lt;Text&gt;(start.containerNode()));
1220 
1221     Position newEnd;
1222     if (start.containerNode() == end.containerNode())
1223         newEnd = Position(end.containerText(), end.offsetInContainerNode() - start.offsetInContainerNode());
1224     else
1225         newEnd = end;
1226 
1227     splitTextNodeContainingElement(*start.containerText(), start.offsetInContainerNode());
1228     updateStartEnd(positionBeforeNode(start.containerNode()), newEnd);
1229 }
1230 
1231 void ApplyStyleCommand::splitTextElementAtEnd(const Position&amp; start, const Position&amp; end)
1232 {
1233     ASSERT(is&lt;Text&gt;(end.containerNode()));
1234 
1235     bool shouldUpdateStart = start.containerNode() == end.containerNode();
1236     splitTextNodeContainingElement(*end.containerText(), end.offsetInContainerNode());
1237 
1238     Node* parentElement = end.containerNode()-&gt;parentNode();
1239     if (!parentElement || !parentElement-&gt;previousSibling())
1240         return;
1241     Node* firstTextNode = parentElement-&gt;previousSibling()-&gt;lastChild();
1242     if (!is&lt;Text&gt;(firstTextNode))
1243         return;
1244 
1245     Position newStart = shouldUpdateStart ? Position(downcast&lt;Text&gt;(firstTextNode), start.offsetInContainerNode()) : start;
1246     updateStartEnd(newStart, positionAfterNode(firstTextNode));
1247 }
1248 
1249 bool ApplyStyleCommand::shouldSplitTextElement(Element* element, EditingStyle&amp; style)
1250 {
1251     if (!is&lt;HTMLElement&gt;(element))
1252         return false;
1253 
1254     return shouldRemoveInlineStyleFromElement(style, downcast&lt;HTMLElement&gt;(*element));
1255 }
1256 
1257 bool ApplyStyleCommand::isValidCaretPositionInTextNode(const Position&amp; position)
1258 {
1259     Node* node = position.containerNode();
1260     if (position.anchorType() != Position::PositionIsOffsetInAnchor || !is&lt;Text&gt;(node))
1261         return false;
1262     int offsetInText = position.offsetInContainerNode();
1263     return offsetInText &gt; caretMinOffset(*node) &amp;&amp; offsetInText &lt; caretMaxOffset(*node);
1264 }
1265 
1266 bool ApplyStyleCommand::mergeStartWithPreviousIfIdentical(const Position&amp; start, const Position&amp; end)
1267 {
1268     auto* startNode = start.containerNode();
1269     int startOffset = start.computeOffsetInContainerNode();
1270     if (startOffset)
1271         return false;
1272 
1273     if (isAtomicNode(startNode)) {
1274         // note: prior siblings could be unrendered elements. it&#39;s silly to miss the
1275         // merge opportunity just for that.
1276         if (startNode-&gt;previousSibling())
1277             return false;
1278 
1279         startNode = startNode-&gt;parentNode();
1280     }
1281 
1282     auto* previousSibling = startNode-&gt;previousSibling();
1283     if (!previousSibling || !areIdenticalElements(*startNode, *previousSibling))
1284         return false;
1285 
1286     auto&amp; previousElement = downcast&lt;Element&gt;(*previousSibling);
1287     auto&amp; element = downcast&lt;Element&gt;(*startNode);
1288     auto* startChild = element.firstChild();
1289     ASSERT(startChild);
1290     mergeIdenticalElements(previousElement, element);
1291 
1292     int startOffsetAdjustment = startChild-&gt;computeNodeIndex();
1293     int endOffsetAdjustment = startNode == end.deprecatedNode() ? startOffsetAdjustment : 0;
1294     updateStartEnd({ startNode, startOffsetAdjustment, Position::PositionIsOffsetInAnchor},
1295         { end.deprecatedNode(), end.deprecatedEditingOffset() + endOffsetAdjustment, Position::PositionIsOffsetInAnchor });
1296     return true;
1297 }
1298 
1299 bool ApplyStyleCommand::mergeEndWithNextIfIdentical(const Position&amp; start, const Position&amp; end)
1300 {
1301     Node* endNode = end.containerNode();
1302 
1303     if (isAtomicNode(endNode)) {
1304         int endOffset = end.computeOffsetInContainerNode();
1305         if (offsetIsBeforeLastNodeOffset(endOffset, endNode) || end.deprecatedNode()-&gt;nextSibling())
1306             return false;
1307 
1308         endNode = end.deprecatedNode()-&gt;parentNode();
1309     }
1310 
1311     if (endNode-&gt;hasTagName(brTag))
1312         return false;
1313 
1314     Node* nextSibling = endNode-&gt;nextSibling();
1315     if (!nextSibling || !areIdenticalElements(*endNode, *nextSibling))
1316         return false;
1317 
1318     auto&amp; nextElement = downcast&lt;Element&gt;(*nextSibling);
1319     auto&amp; element = downcast&lt;Element&gt;(*endNode);
1320     Node* nextChild = nextElement.firstChild();
1321 
1322     mergeIdenticalElements(element, nextElement);
1323 
1324     bool shouldUpdateStart = start.containerNode() == endNode;
1325     int endOffset = nextChild ? nextChild-&gt;computeNodeIndex() : nextElement.countChildNodes();
1326     updateStartEnd(shouldUpdateStart ? Position(&amp;nextElement, start.offsetInContainerNode(), Position::PositionIsOffsetInAnchor) : start,
1327         { &amp;nextElement, endOffset, Position::PositionIsOffsetInAnchor });
1328     return true;
1329 }
1330 
1331 void ApplyStyleCommand::surroundNodeRangeWithElement(Node&amp; startNode, Node&amp; endNode, Ref&lt;Element&gt;&amp;&amp; elementToInsert)
1332 {
1333     Ref&lt;Node&gt; protectedStartNode = startNode;
1334     Ref&lt;Element&gt; element = WTFMove(elementToInsert);
1335 
1336     insertNodeBefore(element.copyRef(), startNode);
1337 
1338     RefPtr&lt;Node&gt; node = &amp;startNode;
1339     while (node) {
1340         RefPtr&lt;Node&gt; next = node-&gt;nextSibling();
1341         if (isEditableNode(*node)) {
1342             removeNode(*node);
1343             appendNode(*node, element.copyRef());
1344         }
1345         if (node == &amp;endNode)
1346             break;
1347         node = next;
1348     }
1349 
1350     RefPtr&lt;Node&gt; nextSibling = element-&gt;nextSibling();
1351     RefPtr&lt;Node&gt; previousSibling = element-&gt;previousSibling();
1352 
1353     if (nextSibling &amp;&amp; nextSibling-&gt;hasEditableStyle() &amp;&amp; areIdenticalElements(element, *nextSibling))
1354         mergeIdenticalElements(element, downcast&lt;Element&gt;(*nextSibling));
1355 
1356     if (is&lt;Element&gt;(previousSibling) &amp;&amp; previousSibling-&gt;hasEditableStyle()) {
1357         auto* mergedElement = previousSibling-&gt;nextSibling();
1358         ASSERT(mergedElement);
1359         if (mergedElement-&gt;hasEditableStyle() &amp;&amp; areIdenticalElements(*previousSibling, *mergedElement))
1360             mergeIdenticalElements(downcast&lt;Element&gt;(*previousSibling), downcast&lt;Element&gt;(*mergedElement));
1361     }
1362 
1363     // FIXME: We should probably call updateStartEnd if the start or end was in the node
1364     // range so that the endingSelection() is canonicalized.  See the comments at the end of
1365     // VisibleSelection::validate().
1366 }
1367 
1368 void ApplyStyleCommand::addBlockStyle(const StyleChange&amp; styleChange, HTMLElement&amp; block)
1369 {
1370     ASSERT(styleChange.cssStyle());
1371     // Do not check for legacy styles here. Those styles, like &lt;B&gt; and &lt;I&gt;, only apply for
1372     // inline content.
1373 
1374     String cssStyle = styleChange.cssStyle()-&gt;asText();
1375     StringBuilder cssText;
1376     cssText.append(cssStyle);
1377     if (const StyleProperties* decl = block.inlineStyle()) {
1378         if (!cssStyle.isEmpty())
1379             cssText.append(&#39; &#39;);
1380         cssText.append(decl-&gt;asText());
1381     }
1382     setNodeAttribute(block, styleAttr, cssText.toString());
1383 }
1384 
1385 void ApplyStyleCommand::addInlineStyleIfNeeded(EditingStyle* style, Node&amp; start, Node&amp; end, EAddStyledElement addStyledElement)
1386 {
1387     if (!start.isConnected() || !end.isConnected())
1388         return;
1389 
1390     Ref&lt;Node&gt; protectedStart = start;
1391     RefPtr&lt;Node&gt; dummyElement;
1392     StyleChange styleChange(style, positionToComputeInlineStyleChange(start, dummyElement));
1393 
1394     if (dummyElement)
1395         removeNode(*dummyElement);
1396 
1397     applyInlineStyleChange(start, end, styleChange, addStyledElement);
1398 }
1399 
1400 Position ApplyStyleCommand::positionToComputeInlineStyleChange(Node&amp; startNode, RefPtr&lt;Node&gt;&amp; dummyElement)
1401 {
1402     // It&#39;s okay to obtain the style at the startNode because we&#39;ve removed all relevant styles from the current run.
1403     if (!is&lt;Element&gt;(startNode)) {
1404         dummyElement = createStyleSpanElement(document());
1405         insertNodeAt(*dummyElement, positionBeforeNode(&amp;startNode));
1406         return firstPositionInOrBeforeNode(dummyElement.get());
1407     }
1408 
1409     return firstPositionInOrBeforeNode(&amp;startNode);
1410 }
1411 
1412 void ApplyStyleCommand::applyInlineStyleChange(Node&amp; passedStart, Node&amp; passedEnd, StyleChange&amp; styleChange, EAddStyledElement addStyledElement)
1413 {
1414     RefPtr&lt;Node&gt; startNode = &amp;passedStart;
1415     RefPtr&lt;Node&gt; endNode = &amp;passedEnd;
1416     ASSERT(startNode-&gt;isConnected());
1417     ASSERT(endNode-&gt;isConnected());
1418 
1419     // Find appropriate font and span elements top-down.
1420     HTMLFontElement* fontContainer = nullptr;
1421     HTMLElement* styleContainer = nullptr;
1422     while (startNode == endNode) {
1423         if (is&lt;HTMLElement&gt;(*startNode)) {
1424             auto&amp; container = downcast&lt;HTMLElement&gt;(*startNode);
1425             if (is&lt;HTMLFontElement&gt;(container))
1426                 fontContainer = &amp;downcast&lt;HTMLFontElement&gt;(container);
1427             if (is&lt;HTMLSpanElement&gt;(container) || (!is&lt;HTMLSpanElement&gt;(styleContainer) &amp;&amp; container.hasChildNodes()))
1428                 styleContainer = &amp;container;
1429         }
1430         auto* startNodeFirstChild = startNode-&gt;firstChild();
1431         if (!startNodeFirstChild)
1432             break;
1433         endNode = startNode-&gt;lastChild();
1434         startNode = startNodeFirstChild;
1435     }
1436 
1437     // Font tags need to go outside of CSS so that CSS font sizes override leagcy font sizes.
1438     if (styleChange.applyFontColor() || styleChange.applyFontFace() || styleChange.applyFontSize()) {
1439         if (fontContainer) {
1440             if (styleChange.applyFontColor())
1441                 setNodeAttribute(*fontContainer, colorAttr, styleChange.fontColor());
1442             if (styleChange.applyFontFace())
1443                 setNodeAttribute(*fontContainer, faceAttr, styleChange.fontFace());
1444             if (styleChange.applyFontSize())
1445                 setNodeAttribute(*fontContainer, sizeAttr, styleChange.fontSize());
1446         } else {
1447             auto fontElement = createFontElement(document());
1448             if (styleChange.applyFontColor())
1449                 fontElement-&gt;setAttributeWithoutSynchronization(colorAttr, styleChange.fontColor());
1450             if (styleChange.applyFontFace())
1451                 fontElement-&gt;setAttributeWithoutSynchronization(faceAttr, styleChange.fontFace());
1452             if (styleChange.applyFontSize())
1453                 fontElement-&gt;setAttributeWithoutSynchronization(sizeAttr, styleChange.fontSize());
1454             surroundNodeRangeWithElement(*startNode, *endNode, WTFMove(fontElement));
1455         }
1456     }
1457 
1458     if (auto styleToMerge = styleChange.cssStyle()) {
1459         if (styleContainer) {
1460             if (auto existingStyle = styleContainer-&gt;inlineStyle()) {
1461                 auto inlineStyle = EditingStyle::create(existingStyle);
1462                 inlineStyle-&gt;overrideWithStyle(*styleToMerge);
1463                 setNodeAttribute(*styleContainer, styleAttr, inlineStyle-&gt;style()-&gt;asText());
1464             } else
1465                 setNodeAttribute(*styleContainer, styleAttr, styleToMerge-&gt;asText());
1466         } else {
1467             auto styleElement = createStyleSpanElement(document());
1468             styleElement-&gt;setAttribute(styleAttr, styleToMerge-&gt;asText());
1469             surroundNodeRangeWithElement(*startNode, *endNode, WTFMove(styleElement));
1470         }
1471     }
1472 
1473     if (styleChange.applyBold())
1474         surroundNodeRangeWithElement(*startNode, *endNode, createHTMLElement(document(), bTag));
1475 
1476     if (styleChange.applyItalic())
1477         surroundNodeRangeWithElement(*startNode, *endNode, createHTMLElement(document(), iTag));
1478 
1479     if (styleChange.applyUnderline())
1480         surroundNodeRangeWithElement(*startNode, *endNode, createHTMLElement(document(), uTag));
1481 
1482     if (styleChange.applyLineThrough())
1483         surroundNodeRangeWithElement(*startNode, *endNode, createHTMLElement(document(), strikeTag));
1484 
1485     if (styleChange.applySubscript())
1486         surroundNodeRangeWithElement(*startNode, *endNode, createHTMLElement(document(), subTag));
1487     else if (styleChange.applySuperscript())
1488         surroundNodeRangeWithElement(*startNode, *endNode, createHTMLElement(document(), supTag));
1489 
1490     if (m_styledInlineElement &amp;&amp; addStyledElement == AddStyledElement)
1491         surroundNodeRangeWithElement(*startNode, *endNode, m_styledInlineElement-&gt;cloneElementWithoutChildren(document()));
1492 }
1493 
1494 float ApplyStyleCommand::computedFontSize(Node* node)
1495 {
1496     if (!node)
1497         return 0;
1498 
1499     auto value = ComputedStyleExtractor(node).propertyValue(CSSPropertyFontSize);
<a name="2" id="anc2"></a><span class="line-modified">1500     return downcast&lt;CSSPrimitiveValue&gt;(*value).floatValue(CSSUnitType::CSS_PX);</span>
1501 }
1502 
1503 void ApplyStyleCommand::joinChildTextNodes(Node* node, const Position&amp; start, const Position&amp; end)
1504 {
1505     if (!node)
1506         return;
1507 
1508     Position newStart = start;
1509     Position newEnd = end;
1510 
1511     Vector&lt;Ref&lt;Text&gt;&gt; textNodes;
1512     for (Text* textNode = TextNodeTraversal::firstChild(*node); textNode; textNode = TextNodeTraversal::nextSibling(*textNode))
1513         textNodes.append(*textNode);
1514 
1515     for (auto&amp; childText : textNodes) {
1516         Node* next = childText-&gt;nextSibling();
1517         if (!is&lt;Text&gt;(next))
1518             continue;
1519 
1520         Text&amp; nextText = downcast&lt;Text&gt;(*next);
1521         if (start.anchorType() == Position::PositionIsOffsetInAnchor &amp;&amp; next == start.containerNode())
1522             newStart = Position(childText.ptr(), childText-&gt;length() + start.offsetInContainerNode());
1523         if (end.anchorType() == Position::PositionIsOffsetInAnchor &amp;&amp; next == end.containerNode())
1524             newEnd = Position(childText.ptr(), childText-&gt;length() + end.offsetInContainerNode());
1525         String textToMove = nextText.data();
1526         insertTextIntoNode(childText, childText-&gt;length(), textToMove);
1527         removeNode(*next);
1528         // don&#39;t move child node pointer. it may want to merge with more text nodes.
1529     }
1530 
1531     updateStartEnd(newStart, newEnd);
1532 }
1533 
1534 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
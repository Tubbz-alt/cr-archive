<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTableSection.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderTableCell.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderText.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTableSection.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 630 
 631     setLogicalHeight(m_rowPos[totalRows]);
 632 
 633     computeOverflowFromCells(totalRows, nEffCols);
 634 }
 635 
 636 void RenderTableSection::computeOverflowFromCells()
 637 {
 638     unsigned totalRows = m_grid.size();
 639     unsigned nEffCols = table()-&gt;numEffCols();
 640     computeOverflowFromCells(totalRows, nEffCols);
 641 }
 642 
 643 void RenderTableSection::computeOverflowFromCells(unsigned totalRows, unsigned nEffCols)
 644 {
 645     clearOverflow();
 646     m_overflowingCells.clear();
 647     unsigned totalCellsCount = nEffCols * totalRows;
 648     unsigned maxAllowedOverflowingCellsCount = totalCellsCount &lt; gMinTableSizeToUseFastPaintPathWithOverflowingCell ? 0 : gMaxAllowedOverflowingCellRatioForFastPaintPath * totalCellsCount;
 649 
<span class="line-modified"> 650 #ifndef NDEBUG</span>
 651     bool hasOverflowingCell = false;
 652 #endif
 653     // Now that our height has been determined, add in overflow from cells.
 654     for (unsigned r = 0; r &lt; totalRows; r++) {
 655         for (unsigned c = 0; c &lt; nEffCols; c++) {
 656             CellStruct&amp; cs = cellAt(r, c);
 657             RenderTableCell* cell = cs.primaryCell();
 658             if (!cell || cs.inColSpan)
 659                 continue;
 660             if (r &lt; totalRows - 1 &amp;&amp; cell == primaryCellAt(r + 1, c))
 661                 continue;
 662             addOverflowFromChild(cell);
<span class="line-modified"> 663 #ifndef NDEBUG</span>
 664             hasOverflowingCell |= cell-&gt;hasVisualOverflow();
 665 #endif
 666             if (cell-&gt;hasVisualOverflow() &amp;&amp; !m_forceSlowPaintPathWithOverflowingCell) {
 667                 m_overflowingCells.add(cell);
 668                 if (m_overflowingCells.size() &gt; maxAllowedOverflowingCellsCount) {
 669                     // We need to set m_forcesSlowPaintPath only if there is a least one overflowing cells as the hit testing code rely on this information.
 670                     m_forceSlowPaintPathWithOverflowingCell = true;
 671                     // The slow path does not make any use of the overflowing cells info, don&#39;t hold on to the memory.
 672                     m_overflowingCells.clear();
 673                 }
 674             }
 675         }
 676     }
 677     ASSERT(hasOverflowingCell == this-&gt;hasOverflowingCell());
 678 }
 679 
 680 LayoutUnit RenderTableSection::calcOuterBorderBefore() const
 681 {
 682     unsigned totalCols = table()-&gt;numEffCols();
 683     if (!m_grid.size() || !totalCols)
</pre>
</td>
<td>
<hr />
<pre>
 630 
 631     setLogicalHeight(m_rowPos[totalRows]);
 632 
 633     computeOverflowFromCells(totalRows, nEffCols);
 634 }
 635 
 636 void RenderTableSection::computeOverflowFromCells()
 637 {
 638     unsigned totalRows = m_grid.size();
 639     unsigned nEffCols = table()-&gt;numEffCols();
 640     computeOverflowFromCells(totalRows, nEffCols);
 641 }
 642 
 643 void RenderTableSection::computeOverflowFromCells(unsigned totalRows, unsigned nEffCols)
 644 {
 645     clearOverflow();
 646     m_overflowingCells.clear();
 647     unsigned totalCellsCount = nEffCols * totalRows;
 648     unsigned maxAllowedOverflowingCellsCount = totalCellsCount &lt; gMinTableSizeToUseFastPaintPathWithOverflowingCell ? 0 : gMaxAllowedOverflowingCellRatioForFastPaintPath * totalCellsCount;
 649 
<span class="line-modified"> 650 #if ASSERT_ENABLED</span>
 651     bool hasOverflowingCell = false;
 652 #endif
 653     // Now that our height has been determined, add in overflow from cells.
 654     for (unsigned r = 0; r &lt; totalRows; r++) {
 655         for (unsigned c = 0; c &lt; nEffCols; c++) {
 656             CellStruct&amp; cs = cellAt(r, c);
 657             RenderTableCell* cell = cs.primaryCell();
 658             if (!cell || cs.inColSpan)
 659                 continue;
 660             if (r &lt; totalRows - 1 &amp;&amp; cell == primaryCellAt(r + 1, c))
 661                 continue;
 662             addOverflowFromChild(cell);
<span class="line-modified"> 663 #if ASSERT_ENABLED</span>
 664             hasOverflowingCell |= cell-&gt;hasVisualOverflow();
 665 #endif
 666             if (cell-&gt;hasVisualOverflow() &amp;&amp; !m_forceSlowPaintPathWithOverflowingCell) {
 667                 m_overflowingCells.add(cell);
 668                 if (m_overflowingCells.size() &gt; maxAllowedOverflowingCellsCount) {
 669                     // We need to set m_forcesSlowPaintPath only if there is a least one overflowing cells as the hit testing code rely on this information.
 670                     m_forceSlowPaintPathWithOverflowingCell = true;
 671                     // The slow path does not make any use of the overflowing cells info, don&#39;t hold on to the memory.
 672                     m_overflowingCells.clear();
 673                 }
 674             }
 675         }
 676     }
 677     ASSERT(hasOverflowingCell == this-&gt;hasOverflowingCell());
 678 }
 679 
 680 LayoutUnit RenderTableSection::calcOuterBorderBefore() const
 681 {
 682     unsigned totalCols = table()-&gt;numEffCols();
 683     if (!m_grid.size() || !totalCols)
</pre>
</td>
</tr>
</table>
<center><a href="RenderTableCell.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderText.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
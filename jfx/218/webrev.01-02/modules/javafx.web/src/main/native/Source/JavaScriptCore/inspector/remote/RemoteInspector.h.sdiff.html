<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/remote/RemoteInspector.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RemoteInspectionTarget.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RemoteInspectorConstants.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/remote/RemoteInspector.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 30 #include &quot;RemoteControllableTarget.h&quot;
 31 
 32 #include &lt;utility&gt;
 33 #include &lt;wtf/Forward.h&gt;
 34 #include &lt;wtf/HashMap.h&gt;
 35 #include &lt;wtf/Lock.h&gt;
 36 #include &lt;wtf/ProcessID.h&gt;
 37 #include &lt;wtf/text/WTFString.h&gt;
 38 
 39 #if PLATFORM(COCOA)
 40 #include &quot;RemoteInspectorXPCConnection.h&quot;
 41 #include &lt;wtf/RetainPtr.h&gt;
 42 
 43 OBJC_CLASS NSDictionary;
 44 OBJC_CLASS NSString;
 45 typedef RetainPtr&lt;NSDictionary&gt; TargetListing;
 46 #endif
 47 
 48 #if USE(GLIB)
 49 #include &lt;wtf/glib/GRefPtr.h&gt;

 50 typedef GRefPtr&lt;GVariant&gt; TargetListing;
 51 typedef struct _GCancellable GCancellable;
<span class="line-removed"> 52 typedef struct _GDBusConnection GDBusConnection;</span>
<span class="line-removed"> 53 typedef struct _GDBusInterfaceVTable GDBusInterfaceVTable;</span>
 54 #endif
 55 
 56 #if USE(INSPECTOR_SOCKET_SERVER)
 57 #include &quot;RemoteConnectionToTarget.h&quot;
 58 #include &quot;RemoteInspectorConnectionClient.h&quot;
 59 #include &lt;wtf/JSONValues.h&gt;
<span class="line-removed"> 60 #include &lt;wtf/RefCounted.h&gt;</span>
 61 #include &lt;wtf/RefPtr.h&gt;
 62 
 63 namespace Inspector {
 64 using TargetListing = RefPtr&lt;JSON::Object&gt;;
 65 }
 66 #endif
 67 
 68 namespace Inspector {
 69 
 70 class RemoteAutomationTarget;
 71 class RemoteConnectionToTarget;
 72 class RemoteControllableTarget;
 73 class RemoteInspectionTarget;
 74 class RemoteInspectorClient;
 75 
 76 class JS_EXPORT_PRIVATE RemoteInspector final
 77 #if PLATFORM(COCOA)
 78     : public RemoteInspectorXPCConnection::Client
 79 #elif USE(INSPECTOR_SOCKET_SERVER)
 80     : public RemoteInspectorConnectionClient
 81 #endif
 82 {
 83 public:
 84     class Client {
 85     public:
 86         struct Capabilities {
 87             bool remoteAutomationAllowed : 1;
 88             String browserName;
 89             String browserVersion;
 90         };
 91 
 92         struct SessionCapabilities {
 93             bool acceptInsecureCertificates { false };
 94 #if USE(GLIB)
 95             Vector&lt;std::pair&lt;String, String&gt;&gt; certificates;









 96 #endif
 97 #if PLATFORM(COCOA)
 98             Optional&lt;bool&gt; allowInsecureMediaCapture;
 99             Optional&lt;bool&gt; suppressICECandidateFiltering;
100 #endif
101         };
102 
103         virtual ~Client();
104         virtual bool remoteAutomationAllowed() const = 0;
105         virtual String browserName() const { return { }; }
106         virtual String browserVersion() const { return { }; }
107         virtual void requestAutomationSession(const String&amp; sessionIdentifier, const SessionCapabilities&amp;) = 0;
108     };
109 
110     static void startDisabled();
111     static RemoteInspector&amp; singleton();
112     friend class NeverDestroyed&lt;RemoteInspector&gt;;
113 
114     void registerTarget(RemoteControllableTarget*);
115     void unregisterTarget(RemoteControllableTarget*);
</pre>
<hr />
<pre>
133     void stop();
134 
135 #if PLATFORM(COCOA)
136     bool hasParentProcessInformation() const { return m_parentProcessIdentifier != 0; }
137     ProcessID parentProcessIdentifier() const { return m_parentProcessIdentifier; }
138     RetainPtr&lt;CFDataRef&gt; parentProcessAuditData() const { return m_parentProcessAuditData; }
139     void setParentProcessInformation(ProcessID, RetainPtr&lt;CFDataRef&gt; auditData);
140     void setParentProcessInfomationIsDelayed();
141 #endif
142 
143     void updateTargetListing(TargetID);
144 
145 #if USE(GLIB)
146     void requestAutomationSession(const char* sessionID, const Client::SessionCapabilities&amp;);
147 #endif
148 #if USE(GLIB) || USE(INSPECTOR_SOCKET_SERVER)
149     void setup(TargetID);
150     void sendMessageToTarget(TargetID, const char* message);
151 #endif
152 #if USE(INSPECTOR_SOCKET_SERVER)
<span class="line-modified">153     static void setConnectionIdentifier(PlatformSocketType);</span>
<span class="line-modified">154     static void setServerPort(uint16_t);</span>




155 #endif
156 
157 private:
158     RemoteInspector();
159 
160     TargetID nextAvailableTargetIdentifier();
161 
162     enum class StopSource { API, XPCMessage };
163     void stopInternal(StopSource);
164 
165 #if PLATFORM(COCOA)
166     void setupXPCConnectionIfNeeded();
167 #endif
168 #if USE(GLIB)
<span class="line-modified">169     void setupConnection(GRefPtr&lt;GDBusConnection&gt;&amp;&amp;);</span>
<span class="line-modified">170     static const GDBusInterfaceVTable s_interfaceVTable;</span>
171 
172     void receivedGetTargetListMessage();
173     void receivedSetupMessage(TargetID);
174     void receivedDataMessage(TargetID, const char* message);
175     void receivedCloseMessage(TargetID);
176     void receivedAutomationSessionRequestMessage(const char* sessionID);
177 #endif
178 
179     TargetListing listingForTarget(const RemoteControllableTarget&amp;) const;
180     TargetListing listingForInspectionTarget(const RemoteInspectionTarget&amp;) const;
181     TargetListing listingForAutomationTarget(const RemoteAutomationTarget&amp;) const;
182 
183     bool updateTargetMap(RemoteControllableTarget*);
184 
185     void pushListingsNow();
186     void pushListingsSoon();
187 
188     void updateTargetListing(const RemoteControllableTarget&amp;);
189 
190     void updateHasActiveDebugSession();
</pre>
<hr />
<pre>
197     void xpcConnectionFailed(RemoteInspectorXPCConnection*) override;
198     void xpcConnectionUnhandledMessage(RemoteInspectorXPCConnection*, xpc_object_t) override;
199 
200     void receivedSetupMessage(NSDictionary *userInfo);
201     void receivedDataMessage(NSDictionary *userInfo);
202     void receivedDidCloseMessage(NSDictionary *userInfo);
203     void receivedGetListingMessage(NSDictionary *userInfo);
204     void receivedIndicateMessage(NSDictionary *userInfo);
205     void receivedProxyApplicationSetupMessage(NSDictionary *userInfo);
206     void receivedConnectionDiedMessage(NSDictionary *userInfo);
207     void receivedAutomaticInspectionConfigurationMessage(NSDictionary *userInfo);
208     void receivedAutomaticInspectionRejectMessage(NSDictionary *userInfo);
209     void receivedAutomationSessionRequestMessage(NSDictionary *userInfo);
210 #endif
211 #if USE(INSPECTOR_SOCKET_SERVER)
212     HashMap&lt;String, CallHandler&gt;&amp; dispatchMap() override;
213     void didClose(ConnectionID) override;
214 
215     void sendWebInspectorEvent(const String&amp;);
216 
<span class="line-modified">217     void receivedGetTargetListMessage(const Event&amp;);</span>
<span class="line-modified">218     void receivedSetupMessage(const Event&amp;);</span>
<span class="line-modified">219     void receivedDataMessage(const Event&amp;);</span>
<span class="line-modified">220     void receivedCloseMessage(const Event&amp;);</span>





221 #endif
222     static bool startEnabled;
223 
224     // Targets can be registered from any thread at any time.
225     // Any target can send messages over the XPC connection.
226     // So lock access to all maps and state as they can change
227     // from any thread.
228     Lock m_mutex;
229 
230     HashMap&lt;TargetID, RemoteControllableTarget*&gt; m_targetMap;
231     HashMap&lt;TargetID, RefPtr&lt;RemoteConnectionToTarget&gt;&gt; m_targetConnectionMap;
232     HashMap&lt;TargetID, TargetListing&gt; m_targetListingMap;
233 
234 #if PLATFORM(COCOA)
235     RefPtr&lt;RemoteInspectorXPCConnection&gt; m_relayConnection;
236 #endif
237 #if USE(GLIB)
<span class="line-modified">238     GRefPtr&lt;GDBusConnection&gt; m_dbusConnection;</span>
239     GRefPtr&lt;GCancellable&gt; m_cancellable;
240 #endif
241 
242 #if USE(INSPECTOR_SOCKET_SERVER)
<span class="line-modified">243     static PlatformSocketType s_connectionIdentifier;</span>
<span class="line-modified">244     static uint16_t s_serverPort;</span>
<span class="line-modified">245     Optional&lt;ConnectionID&gt; m_clientID;</span>


246 #endif
247 
248     RemoteInspector::Client* m_client { nullptr };
249     Optional&lt;RemoteInspector::Client::Capabilities&gt; m_clientCapabilities;
250 
251 #if PLATFORM(COCOA)
252     dispatch_queue_t m_xpcQueue;
253 #endif
254     TargetID m_nextAvailableTargetIdentifier { 1 };
255     int m_notifyToken { 0 };
256     bool m_enabled { false };
257     bool m_hasActiveDebugSession { false };
258     bool m_pushScheduled { false };
259 
260     ProcessID m_parentProcessIdentifier { 0 };
261 #if PLATFORM(COCOA)
262     RetainPtr&lt;CFDataRef&gt; m_parentProcessAuditData;
263 #endif
264     bool m_shouldSendParentProcessInformation { false };
265     bool m_automaticInspectionEnabled { false };
</pre>
</td>
<td>
<hr />
<pre>
 30 #include &quot;RemoteControllableTarget.h&quot;
 31 
 32 #include &lt;utility&gt;
 33 #include &lt;wtf/Forward.h&gt;
 34 #include &lt;wtf/HashMap.h&gt;
 35 #include &lt;wtf/Lock.h&gt;
 36 #include &lt;wtf/ProcessID.h&gt;
 37 #include &lt;wtf/text/WTFString.h&gt;
 38 
 39 #if PLATFORM(COCOA)
 40 #include &quot;RemoteInspectorXPCConnection.h&quot;
 41 #include &lt;wtf/RetainPtr.h&gt;
 42 
 43 OBJC_CLASS NSDictionary;
 44 OBJC_CLASS NSString;
 45 typedef RetainPtr&lt;NSDictionary&gt; TargetListing;
 46 #endif
 47 
 48 #if USE(GLIB)
 49 #include &lt;wtf/glib/GRefPtr.h&gt;
<span class="line-added"> 50 #include &lt;wtf/glib/SocketConnection.h&gt;</span>
 51 typedef GRefPtr&lt;GVariant&gt; TargetListing;
 52 typedef struct _GCancellable GCancellable;


 53 #endif
 54 
 55 #if USE(INSPECTOR_SOCKET_SERVER)
 56 #include &quot;RemoteConnectionToTarget.h&quot;
 57 #include &quot;RemoteInspectorConnectionClient.h&quot;
 58 #include &lt;wtf/JSONValues.h&gt;

 59 #include &lt;wtf/RefPtr.h&gt;
 60 
 61 namespace Inspector {
 62 using TargetListing = RefPtr&lt;JSON::Object&gt;;
 63 }
 64 #endif
 65 
 66 namespace Inspector {
 67 
 68 class RemoteAutomationTarget;
 69 class RemoteConnectionToTarget;
 70 class RemoteControllableTarget;
 71 class RemoteInspectionTarget;
 72 class RemoteInspectorClient;
 73 
 74 class JS_EXPORT_PRIVATE RemoteInspector final
 75 #if PLATFORM(COCOA)
 76     : public RemoteInspectorXPCConnection::Client
 77 #elif USE(INSPECTOR_SOCKET_SERVER)
 78     : public RemoteInspectorConnectionClient
 79 #endif
 80 {
 81 public:
 82     class Client {
 83     public:
 84         struct Capabilities {
 85             bool remoteAutomationAllowed : 1;
 86             String browserName;
 87             String browserVersion;
 88         };
 89 
 90         struct SessionCapabilities {
 91             bool acceptInsecureCertificates { false };
 92 #if USE(GLIB)
 93             Vector&lt;std::pair&lt;String, String&gt;&gt; certificates;
<span class="line-added"> 94             struct Proxy {</span>
<span class="line-added"> 95                 String type;</span>
<span class="line-added"> 96                 Optional&lt;String&gt; ftpURL;</span>
<span class="line-added"> 97                 Optional&lt;String&gt; httpURL;</span>
<span class="line-added"> 98                 Optional&lt;String&gt; httpsURL;</span>
<span class="line-added"> 99                 Optional&lt;String&gt; socksURL;</span>
<span class="line-added">100                 Vector&lt;String&gt; ignoreAddressList;</span>
<span class="line-added">101             };</span>
<span class="line-added">102             Optional&lt;Proxy&gt; proxy;</span>
103 #endif
104 #if PLATFORM(COCOA)
105             Optional&lt;bool&gt; allowInsecureMediaCapture;
106             Optional&lt;bool&gt; suppressICECandidateFiltering;
107 #endif
108         };
109 
110         virtual ~Client();
111         virtual bool remoteAutomationAllowed() const = 0;
112         virtual String browserName() const { return { }; }
113         virtual String browserVersion() const { return { }; }
114         virtual void requestAutomationSession(const String&amp; sessionIdentifier, const SessionCapabilities&amp;) = 0;
115     };
116 
117     static void startDisabled();
118     static RemoteInspector&amp; singleton();
119     friend class NeverDestroyed&lt;RemoteInspector&gt;;
120 
121     void registerTarget(RemoteControllableTarget*);
122     void unregisterTarget(RemoteControllableTarget*);
</pre>
<hr />
<pre>
140     void stop();
141 
142 #if PLATFORM(COCOA)
143     bool hasParentProcessInformation() const { return m_parentProcessIdentifier != 0; }
144     ProcessID parentProcessIdentifier() const { return m_parentProcessIdentifier; }
145     RetainPtr&lt;CFDataRef&gt; parentProcessAuditData() const { return m_parentProcessAuditData; }
146     void setParentProcessInformation(ProcessID, RetainPtr&lt;CFDataRef&gt; auditData);
147     void setParentProcessInfomationIsDelayed();
148 #endif
149 
150     void updateTargetListing(TargetID);
151 
152 #if USE(GLIB)
153     void requestAutomationSession(const char* sessionID, const Client::SessionCapabilities&amp;);
154 #endif
155 #if USE(GLIB) || USE(INSPECTOR_SOCKET_SERVER)
156     void setup(TargetID);
157     void sendMessageToTarget(TargetID, const char* message);
158 #endif
159 #if USE(INSPECTOR_SOCKET_SERVER)
<span class="line-modified">160     void requestAutomationSession(const String&amp; sessionID, const Client::SessionCapabilities&amp;);</span>
<span class="line-modified">161 </span>
<span class="line-added">162     bool isConnected() const { return !!m_clientConnection; }</span>
<span class="line-added">163     void connect(ConnectionID);</span>
<span class="line-added">164 </span>
<span class="line-added">165     void setBackendCommandsPath(const String&amp; backendCommandsPath) { m_backendCommandsPath = backendCommandsPath; }</span>
166 #endif
167 
168 private:
169     RemoteInspector();
170 
171     TargetID nextAvailableTargetIdentifier();
172 
173     enum class StopSource { API, XPCMessage };
174     void stopInternal(StopSource);
175 
176 #if PLATFORM(COCOA)
177     void setupXPCConnectionIfNeeded();
178 #endif
179 #if USE(GLIB)
<span class="line-modified">180     void setupConnection(Ref&lt;SocketConnection&gt;&amp;&amp;);</span>
<span class="line-modified">181     static const SocketConnection::MessageHandlers&amp; messageHandlers();</span>
182 
183     void receivedGetTargetListMessage();
184     void receivedSetupMessage(TargetID);
185     void receivedDataMessage(TargetID, const char* message);
186     void receivedCloseMessage(TargetID);
187     void receivedAutomationSessionRequestMessage(const char* sessionID);
188 #endif
189 
190     TargetListing listingForTarget(const RemoteControllableTarget&amp;) const;
191     TargetListing listingForInspectionTarget(const RemoteInspectionTarget&amp;) const;
192     TargetListing listingForAutomationTarget(const RemoteAutomationTarget&amp;) const;
193 
194     bool updateTargetMap(RemoteControllableTarget*);
195 
196     void pushListingsNow();
197     void pushListingsSoon();
198 
199     void updateTargetListing(const RemoteControllableTarget&amp;);
200 
201     void updateHasActiveDebugSession();
</pre>
<hr />
<pre>
208     void xpcConnectionFailed(RemoteInspectorXPCConnection*) override;
209     void xpcConnectionUnhandledMessage(RemoteInspectorXPCConnection*, xpc_object_t) override;
210 
211     void receivedSetupMessage(NSDictionary *userInfo);
212     void receivedDataMessage(NSDictionary *userInfo);
213     void receivedDidCloseMessage(NSDictionary *userInfo);
214     void receivedGetListingMessage(NSDictionary *userInfo);
215     void receivedIndicateMessage(NSDictionary *userInfo);
216     void receivedProxyApplicationSetupMessage(NSDictionary *userInfo);
217     void receivedConnectionDiedMessage(NSDictionary *userInfo);
218     void receivedAutomaticInspectionConfigurationMessage(NSDictionary *userInfo);
219     void receivedAutomaticInspectionRejectMessage(NSDictionary *userInfo);
220     void receivedAutomationSessionRequestMessage(NSDictionary *userInfo);
221 #endif
222 #if USE(INSPECTOR_SOCKET_SERVER)
223     HashMap&lt;String, CallHandler&gt;&amp; dispatchMap() override;
224     void didClose(ConnectionID) override;
225 
226     void sendWebInspectorEvent(const String&amp;);
227 
<span class="line-modified">228     void setupInspectorClient(const Event&amp;);</span>
<span class="line-modified">229     void setupTarget(const Event&amp;);</span>
<span class="line-modified">230     void frontendDidClose(const Event&amp;);</span>
<span class="line-modified">231     void sendMessageToBackend(const Event&amp;);</span>
<span class="line-added">232     void startAutomationSession(const Event&amp;);</span>
<span class="line-added">233 </span>
<span class="line-added">234     void receivedAutomationSessionRequestMessage(const Event&amp;);</span>
<span class="line-added">235 </span>
<span class="line-added">236     String backendCommands() const;</span>
237 #endif
238     static bool startEnabled;
239 
240     // Targets can be registered from any thread at any time.
241     // Any target can send messages over the XPC connection.
242     // So lock access to all maps and state as they can change
243     // from any thread.
244     Lock m_mutex;
245 
246     HashMap&lt;TargetID, RemoteControllableTarget*&gt; m_targetMap;
247     HashMap&lt;TargetID, RefPtr&lt;RemoteConnectionToTarget&gt;&gt; m_targetConnectionMap;
248     HashMap&lt;TargetID, TargetListing&gt; m_targetListingMap;
249 
250 #if PLATFORM(COCOA)
251     RefPtr&lt;RemoteInspectorXPCConnection&gt; m_relayConnection;
252 #endif
253 #if USE(GLIB)
<span class="line-modified">254     RefPtr&lt;SocketConnection&gt; m_socketConnection;</span>
255     GRefPtr&lt;GCancellable&gt; m_cancellable;
256 #endif
257 
258 #if USE(INSPECTOR_SOCKET_SERVER)
<span class="line-modified">259     // Connection from RemoteInspectorClient or WebDriver.</span>
<span class="line-modified">260     Optional&lt;ConnectionID&gt; m_clientConnection;</span>
<span class="line-modified">261     bool m_readyToPushListings { false };</span>
<span class="line-added">262 </span>
<span class="line-added">263     String m_backendCommandsPath;</span>
264 #endif
265 
266     RemoteInspector::Client* m_client { nullptr };
267     Optional&lt;RemoteInspector::Client::Capabilities&gt; m_clientCapabilities;
268 
269 #if PLATFORM(COCOA)
270     dispatch_queue_t m_xpcQueue;
271 #endif
272     TargetID m_nextAvailableTargetIdentifier { 1 };
273     int m_notifyToken { 0 };
274     bool m_enabled { false };
275     bool m_hasActiveDebugSession { false };
276     bool m_pushScheduled { false };
277 
278     ProcessID m_parentProcessIdentifier { 0 };
279 #if PLATFORM(COCOA)
280     RetainPtr&lt;CFDataRef&gt; m_parentProcessAuditData;
281 #endif
282     bool m_shouldSendParentProcessInformation { false };
283     bool m_automaticInspectionEnabled { false };
</pre>
</td>
</tr>
</table>
<center><a href="RemoteInspectionTarget.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RemoteInspectorConstants.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WebGPUDevice.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGPUDevice.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 #include &quot;DOMWindow.h&quot;
 32 #include &quot;Document.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;Exception.h&quot;
 35 #include &quot;GPUBindGroup.h&quot;
 36 #include &quot;GPUBindGroupBinding.h&quot;
 37 #include &quot;GPUBindGroupDescriptor.h&quot;
 38 #include &quot;GPUBindGroupLayoutDescriptor.h&quot;
 39 #include &quot;GPUBufferBinding.h&quot;
 40 #include &quot;GPUBufferDescriptor.h&quot;
 41 #include &quot;GPUCommandBuffer.h&quot;
 42 #include &quot;GPUComputePipeline.h&quot;
 43 #include &quot;GPUComputePipelineDescriptor.h&quot;
 44 #include &quot;GPUProgrammableStageDescriptor.h&quot;
 45 #include &quot;GPURenderPipeline.h&quot;
 46 #include &quot;GPURenderPipelineDescriptor.h&quot;
 47 #include &quot;GPUSampler.h&quot;
 48 #include &quot;GPUSamplerDescriptor.h&quot;
 49 #include &quot;GPUShaderModuleDescriptor.h&quot;
 50 #include &quot;GPUTextureDescriptor.h&quot;
 51 #include &quot;GPUUncapturedErrorEvent.h&quot;
 52 #include &quot;InspectorInstrumentation.h&quot;
 53 #include &quot;JSDOMConvertBufferSource.h&quot;
 54 #include &quot;JSDOMPromiseDeferred.h&quot;
 55 #include &quot;JSGPUOutOfMemoryError.h&quot;
 56 #include &quot;JSGPUValidationError.h&quot;
 57 #include &quot;JSWebGPUBuffer.h&quot;
 58 #include &quot;Logging.h&quot;
 59 #include &quot;WebGPUBindGroup.h&quot;
 60 #include &quot;WebGPUBindGroupBinding.h&quot;
 61 #include &quot;WebGPUBindGroupDescriptor.h&quot;
 62 #include &quot;WebGPUBindGroupLayout.h&quot;
 63 #include &quot;WebGPUBufferBinding.h&quot;
 64 #include &quot;WebGPUCommandEncoder.h&quot;
 65 #include &quot;WebGPUComputePipeline.h&quot;
 66 #include &quot;WebGPUComputePipelineDescriptor.h&quot;
 67 #include &quot;WebGPUPipeline.h&quot;
 68 #include &quot;WebGPUPipelineLayout.h&quot;
 69 #include &quot;WebGPUPipelineLayoutDescriptor.h&quot;
 70 #include &quot;WebGPUProgrammableStageDescriptor.h&quot;
 71 #include &quot;WebGPUQueue.h&quot;
 72 #include &quot;WebGPURenderPipeline.h&quot;
 73 #include &quot;WebGPURenderPipelineDescriptor.h&quot;
 74 #include &quot;WebGPUSampler.h&quot;
 75 #include &quot;WebGPUShaderModule.h&quot;
 76 #include &quot;WebGPUShaderModuleDescriptor.h&quot;
 77 #include &quot;WebGPUSwapChain.h&quot;
 78 #include &quot;WebGPUTexture.h&quot;
 79 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
 80 #include &lt;memory&gt;
 81 #include &lt;wtf/HashSet.h&gt;
 82 #include &lt;wtf/IsoMallocInlines.h&gt;
 83 #include &lt;wtf/Lock.h&gt;
 84 #include &lt;wtf/MainThread.h&gt;
 85 #include &lt;wtf/NeverDestroyed.h&gt;
 86 #include &lt;wtf/Optional.h&gt;
 87 #include &lt;wtf/Ref.h&gt;
 88 #include &lt;wtf/RefPtr.h&gt;
 89 #include &lt;wtf/Variant.h&gt;
 90 #include &lt;wtf/Vector.h&gt;
 91 #include &lt;wtf/text/WTFString.h&gt;
 92 
 93 namespace WebCore {
 94 
 95 WTF_MAKE_ISO_ALLOCATED_IMPL(WebGPUDevice);
 96 
 97 RefPtr&lt;WebGPUDevice&gt; WebGPUDevice::tryCreate(ScriptExecutionContext&amp; context, Ref&lt;const WebGPUAdapter&gt;&amp;&amp; adapter)
 98 {
 99     if (auto device = GPUDevice::tryCreate(adapter-&gt;options()))
100         return adoptRef(new WebGPUDevice(context, WTFMove(adapter), device.releaseNonNull()));
101     return nullptr;
102 }
103 
104 HashSet&lt;WebGPUDevice*&gt;&amp; WebGPUDevice::instances(const LockHolder&amp;)
105 {
106     static NeverDestroyed&lt;HashSet&lt;WebGPUDevice*&gt;&gt; instances;
107     return instances;
108 }
109 
110 Lock&amp; WebGPUDevice::instancesMutex()
111 {
112     static LazyNeverDestroyed&lt;Lock&gt; mutex;
113     static std::once_flag initializeMutex;
114     std::call_once(initializeMutex, [] {
115         mutex.construct();
116     });
117     return mutex.get();
118 }
119 
120 WebGPUDevice::WebGPUDevice(ScriptExecutionContext&amp; context, Ref&lt;const WebGPUAdapter&gt;&amp;&amp; adapter, Ref&lt;GPUDevice&gt;&amp;&amp; device)
121     : m_scriptExecutionContext(context)
122     , m_adapter(WTFMove(adapter))
123     , m_device(WTFMove(device))
124     , m_errorScopes(GPUErrorScopes::create([this, weakThis = makeWeakPtr(this)] (GPUError&amp;&amp; error) {
125         if (weakThis)
126             dispatchUncapturedError(WTFMove(error));
127     }))
128 {
129     ASSERT(m_scriptExecutionContext.isDocument());
130 
131     {
132         LockHolder lock(instancesMutex());
133         instances(lock).add(this);
134     }
135 }
136 
137 WebGPUDevice::~WebGPUDevice()
138 {
139     InspectorInstrumentation::willDestroyWebGPUDevice(*this);
140 
141     {
142         LockHolder lock(WebGPUPipeline::instancesMutex());
143         for (auto&amp; entry : WebGPUPipeline::instances(lock)) {
144             if (entry.value == this) {
145                 // Don&#39;t remove any WebGPUPipeline from the instances list, as they may still exist.
146                 // Only remove the association with a WebGPU device.
147                 entry.value = nullptr;
148             }
149         }
150     }
151 
152     {
153         LockHolder lock(instancesMutex());
154         ASSERT(instances(lock).contains(this));
155         instances(lock).remove(this);
156     }
157 }
158 
159 Ref&lt;WebGPUBuffer&gt; WebGPUDevice::createBuffer(const GPUBufferDescriptor&amp; descriptor) const
160 {
161     m_errorScopes-&gt;setErrorPrefix(&quot;GPUDevice.createBuffer(): &quot;);
162 
163     auto buffer = m_device-&gt;tryCreateBuffer(descriptor, GPUBufferMappedOption::NotMapped, m_errorScopes);
164     return WebGPUBuffer::create(WTFMove(buffer), m_errorScopes);
165 }
166 
167 Vector&lt;JSC::JSValue&gt; WebGPUDevice::createBufferMapped(JSC::JSGlobalObject&amp; lexicalGlobalObject, const GPUBufferDescriptor&amp; descriptor) const
168 {
169     m_errorScopes-&gt;setErrorPrefix(&quot;GPUDevice.createBufferMapped(): &quot;);
170 
171     JSC::JSValue wrappedArrayBuffer = JSC::jsNull();
172 
173     auto buffer = m_device-&gt;tryCreateBuffer(descriptor, GPUBufferMappedOption::IsMapped, m_errorScopes);
174     if (buffer) {
175         auto arrayBuffer = buffer-&gt;mapOnCreation();
176         wrappedArrayBuffer = toJS(&amp;lexicalGlobalObject, JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject), arrayBuffer);
177     }
178 
179     auto webBuffer = WebGPUBuffer::create(WTFMove(buffer), m_errorScopes);
180     auto wrappedWebBuffer = toJS(&amp;lexicalGlobalObject, JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject), webBuffer);
181 
182     return { wrappedWebBuffer, wrappedArrayBuffer };
183 }
184 
185 Ref&lt;WebGPUTexture&gt; WebGPUDevice::createTexture(const GPUTextureDescriptor&amp; descriptor) const
186 {
187     auto texture = m_device-&gt;tryCreateTexture(descriptor);
188     return WebGPUTexture::create(WTFMove(texture));
189 }
190 
191 Ref&lt;WebGPUSampler&gt; WebGPUDevice::createSampler(const GPUSamplerDescriptor&amp; descriptor) const
192 {
193     auto sampler = m_device-&gt;tryCreateSampler(descriptor);
194     return WebGPUSampler::create(WTFMove(sampler));
195 }
196 
197 Ref&lt;WebGPUBindGroupLayout&gt; WebGPUDevice::createBindGroupLayout(const GPUBindGroupLayoutDescriptor&amp; descriptor) const
198 {
199     auto layout = m_device-&gt;tryCreateBindGroupLayout(descriptor);
200     return WebGPUBindGroupLayout::create(WTFMove(layout));
201 }
202 
203 Ref&lt;WebGPUPipelineLayout&gt; WebGPUDevice::createPipelineLayout(const WebGPUPipelineLayoutDescriptor&amp; descriptor) const
204 {
205     auto gpuDescriptor = descriptor.tryCreateGPUPipelineLayoutDescriptor();
206     if (!gpuDescriptor)
207         return WebGPUPipelineLayout::create(nullptr);
208 
209     auto layout = m_device-&gt;createPipelineLayout(WTFMove(*gpuDescriptor));
210     return WebGPUPipelineLayout::create(WTFMove(layout));
211 }
212 
213 Ref&lt;WebGPUBindGroup&gt; WebGPUDevice::createBindGroup(const WebGPUBindGroupDescriptor&amp; descriptor) const
214 {
215     auto gpuDescriptor = descriptor.tryCreateGPUBindGroupDescriptor();
216     if (!gpuDescriptor)
217         return WebGPUBindGroup::create(nullptr);
218 
219     auto bindGroup = m_device-&gt;tryCreateBindGroup(*gpuDescriptor, m_errorScopes);
220     return WebGPUBindGroup::create(WTFMove(bindGroup));
221 }
222 
223 Ref&lt;WebGPUShaderModule&gt; WebGPUDevice::createShaderModule(const WebGPUShaderModuleDescriptor&amp; descriptor) const
224 {
225     // FIXME: What can be validated here?
226     auto module = m_device-&gt;tryCreateShaderModule(GPUShaderModuleDescriptor { descriptor.code });
227     return WebGPUShaderModule::create(WTFMove(module), descriptor.code);
228 }
229 
230 Ref&lt;WebGPURenderPipeline&gt; WebGPUDevice::createRenderPipeline(const WebGPURenderPipelineDescriptor&amp; descriptor)
231 {
232     m_errorScopes-&gt;setErrorPrefix(&quot;GPUDevice.createRenderPipeline(): &quot;);
233 
234     auto gpuDescriptor = descriptor.tryCreateGPURenderPipelineDescriptor(m_errorScopes);
235     if (!gpuDescriptor)
236         return WebGPURenderPipeline::create(*this, nullptr, m_errorScopes, { }, { });
237 
238     auto gpuPipeline = m_device-&gt;tryCreateRenderPipeline(*gpuDescriptor, m_errorScopes);
239 
240     WebGPUPipeline::ShaderData vertexShader = { descriptor.vertexStage.module, descriptor.vertexStage.entryPoint };
241 
242     WebGPUPipeline::ShaderData fragmentShader;
243     if (descriptor.fragmentStage)
244         fragmentShader = { descriptor.fragmentStage.value().module, descriptor.fragmentStage.value().entryPoint };
245 
246     auto webGPUPipeline = WebGPURenderPipeline::create(*this, WTFMove(gpuPipeline), m_errorScopes, WTFMove(vertexShader), WTFMove(fragmentShader));
247     if (webGPUPipeline-&gt;isValid())
248         InspectorInstrumentation::didCreateWebGPUPipeline(*this, webGPUPipeline.get());
249     return webGPUPipeline;
250 }
251 
252 Ref&lt;WebGPUComputePipeline&gt; WebGPUDevice::createComputePipeline(const WebGPUComputePipelineDescriptor&amp; descriptor)
253 {
254     m_errorScopes-&gt;setErrorPrefix(&quot;GPUDevice.createComputePipeline(): &quot;);
255 
256     auto gpuDescriptor = descriptor.tryCreateGPUComputePipelineDescriptor(m_errorScopes);
257     if (!gpuDescriptor)
258         return WebGPUComputePipeline::create(*this, nullptr, m_errorScopes, { });
259 
260     auto gpuPipeline = m_device-&gt;tryCreateComputePipeline(*gpuDescriptor, m_errorScopes);
261 
262     WebGPUPipeline::ShaderData computeShader = { descriptor.computeStage.module, descriptor.computeStage.entryPoint };
263 
264     auto webGPUPipeline = WebGPUComputePipeline::create(*this, WTFMove(gpuPipeline), m_errorScopes, WTFMove(computeShader));
265     if (webGPUPipeline-&gt;isValid())
266         InspectorInstrumentation::didCreateWebGPUPipeline(*this, webGPUPipeline.get());
267     return webGPUPipeline;
268 }
269 
270 Ref&lt;WebGPUCommandEncoder&gt; WebGPUDevice::createCommandEncoder() const
271 {
272     auto commandBuffer = m_device-&gt;tryCreateCommandBuffer();
273     return WebGPUCommandEncoder::create(WTFMove(commandBuffer));
274 }
275 
276 Ref&lt;WebGPUQueue&gt; WebGPUDevice::getQueue() const
277 {
278     if (!m_queue)
279         m_queue = WebGPUQueue::create(m_device-&gt;tryGetQueue());
280 
281     return makeRef(*m_queue.get());
282 }
283 
284 void WebGPUDevice::popErrorScope(ErrorPromise&amp;&amp; promise)
285 {
286     String failMessage;
287     Optional&lt;GPUError&gt; error = m_errorScopes-&gt;popErrorScope(failMessage);
288     if (failMessage.isEmpty())
289         promise.resolve(error);
290     else
291         promise.reject(Exception { OperationError, &quot;GPUDevice::popErrorScope(): &quot; + failMessage });
292 }
293 
294 // Errors reported via the validation error event should also appear in the console as warnings.
295 static void printValidationErrorToConsole(GPUError&amp; error, ScriptExecutionContext&amp; context)
296 {
297     if (!WTF::holds_alternative&lt;RefPtr&lt;GPUValidationError&gt;&gt;(error))
298         return;
299 
300     auto validationError = WTF::get&lt;RefPtr&lt;GPUValidationError&gt;&gt;(error);
301     if (!validationError)
302         return;
303 
304     auto message = validationError-&gt;message();
305     auto consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, MessageLevel::Warning, message);
306 
307     downcast&lt;Document&gt;(context).addConsoleMessage(WTFMove(consoleMessage));
308 }
309 
310 void WebGPUDevice::dispatchUncapturedError(GPUError&amp;&amp; error)
311 {
312     printValidationErrorToConsole(error, m_scriptExecutionContext);
313 
314     callOnMainThread([error = WTFMove(error), this, protectedThis = makeRef(*this)] () mutable {
315         dispatchEvent(GPUUncapturedErrorEvent::create(eventNames().uncapturederrorEvent, WTFMove(error)));
316     });
317 }
318 
319 } // namespace WebCore
320 
321 #endif // ENABLE(WEBGPU)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/Vector.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  *  Copyright (C) 2005-2019 Apple Inc. All rights reserved.
   3  *
   4  *  This library is free software; you can redistribute it and/or
   5  *  modify it under the terms of the GNU Library General Public
   6  *  License as published by the Free Software Foundation; either
   7  *  version 2 of the License, or (at your option) any later version.
   8  *
   9  *  This library is distributed in the hope that it will be useful,
  10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  *  Library General Public License for more details.
  13  *
  14  *  You should have received a copy of the GNU Library General Public License
  15  *  along with this library; see the file COPYING.LIB.  If not, write to
  16  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  17  *  Boston, MA 02110-1301, USA.
  18  *
  19  */
  20 
  21 #pragma once
  22 
  23 #include &lt;initializer_list&gt;
  24 #include &lt;limits&gt;
  25 #include &lt;string.h&gt;
  26 #include &lt;type_traits&gt;
  27 #include &lt;utility&gt;
  28 #include &lt;wtf/CheckedArithmetic.h&gt;
  29 #include &lt;wtf/FastMalloc.h&gt;
  30 #include &lt;wtf/Forward.h&gt;
  31 #include &lt;wtf/MallocPtr.h&gt;
  32 #include &lt;wtf/MathExtras.h&gt;
  33 #include &lt;wtf/Noncopyable.h&gt;
  34 #include &lt;wtf/NotFound.h&gt;
  35 #include &lt;wtf/StdLibExtras.h&gt;
  36 #include &lt;wtf/ValueCheck.h&gt;
  37 #include &lt;wtf/VectorTraits.h&gt;
  38 
  39 #if ASAN_ENABLED
  40 extern &quot;C&quot; void __sanitizer_annotate_contiguous_container(const void* begin, const void* end, const void* old_mid, const void* new_mid);
  41 #endif
  42 
  43 namespace JSC {
  44 class LLIntOffsetsExtractor;
  45 }
  46 
  47 namespace WTF {
  48 
  49 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(Vector);
  50 
  51 template &lt;bool needsDestruction, typename T&gt;
  52 struct VectorDestructor;
  53 
  54 template&lt;typename T&gt;
  55 struct VectorDestructor&lt;false, T&gt;
  56 {
  57     static void destruct(T*, T*) {}
  58 };
  59 
  60 template&lt;typename T&gt;
  61 struct VectorDestructor&lt;true, T&gt;
  62 {
  63     static void destruct(T* begin, T* end)
  64     {
  65         for (T* cur = begin; cur != end; ++cur)
  66             cur-&gt;~T();
  67     }
  68 };
  69 
  70 template &lt;bool needsInitialization, bool canInitializeWithMemset, typename T&gt;
  71 struct VectorInitializer;
  72 
  73 template&lt;bool canInitializeWithMemset, typename T&gt;
  74 struct VectorInitializer&lt;false, canInitializeWithMemset, T&gt;
  75 {
  76     static void initializeIfNonPOD(T*, T*) { }
  77 
  78     static void initialize(T* begin, T* end)
  79     {
  80         VectorInitializer&lt;true, canInitializeWithMemset, T&gt;::initialize(begin, end);
  81     }
  82 };
  83 
  84 template&lt;typename T&gt;
  85 struct VectorInitializer&lt;true, false, T&gt;
  86 {
  87     static void initializeIfNonPOD(T* begin, T* end)
  88     {
  89         for (T* cur = begin; cur != end; ++cur)
  90             new (NotNull, cur) T();
  91     }
  92 
  93     static void initialize(T* begin, T* end)
  94     {
  95         initializeIfNonPOD(begin, end);
  96     }
  97 };
  98 
  99 template&lt;typename T&gt;
 100 struct VectorInitializer&lt;true, true, T&gt;
 101 {
 102     static void initializeIfNonPOD(T* begin, T* end)
 103     {
 104         memset(static_cast&lt;void*&gt;(begin), 0, reinterpret_cast&lt;char*&gt;(end) - reinterpret_cast&lt;char*&gt;(begin));
 105     }
 106 
 107     static void initialize(T* begin, T* end)
 108     {
 109         initializeIfNonPOD(begin, end);
 110     }
 111 };
 112 
 113 template &lt;bool canMoveWithMemcpy, typename T&gt;
 114 struct VectorMover;
 115 
 116 template&lt;typename T&gt;
 117 struct VectorMover&lt;false, T&gt;
 118 {
 119     static void move(T* src, T* srcEnd, T* dst)
 120     {
 121         while (src != srcEnd) {
 122             new (NotNull, dst) T(WTFMove(*src));
 123             src-&gt;~T();
 124             ++dst;
 125             ++src;
 126         }
 127     }
 128     static void moveOverlapping(T* src, T* srcEnd, T* dst)
 129     {
 130         if (src &gt; dst)
 131             move(src, srcEnd, dst);
 132         else {
 133             T* dstEnd = dst + (srcEnd - src);
 134             while (src != srcEnd) {
 135                 --srcEnd;
 136                 --dstEnd;
 137                 new (NotNull, dstEnd) T(WTFMove(*srcEnd));
 138                 srcEnd-&gt;~T();
 139             }
 140         }
 141     }
 142 };
 143 
 144 template&lt;typename T&gt;
 145 struct VectorMover&lt;true, T&gt;
 146 {
 147     static void move(const T* src, const T* srcEnd, T* dst)
 148     {
 149         memcpy(static_cast&lt;void*&gt;(dst), static_cast&lt;void*&gt;(const_cast&lt;T*&gt;(src)), reinterpret_cast&lt;const char*&gt;(srcEnd) - reinterpret_cast&lt;const char*&gt;(src));
 150     }
 151     static void moveOverlapping(const T* src, const T* srcEnd, T* dst)
 152     {
 153         memmove(static_cast&lt;void*&gt;(dst), static_cast&lt;void*&gt;(const_cast&lt;T*&gt;(src)), reinterpret_cast&lt;const char*&gt;(srcEnd) - reinterpret_cast&lt;const char*&gt;(src));
 154     }
 155 };
 156 
 157 template &lt;bool canCopyWithMemcpy, typename T&gt;
 158 struct VectorCopier;
 159 
 160 template&lt;typename T&gt;
 161 struct VectorCopier&lt;false, T&gt;
 162 {
 163     template&lt;typename U&gt;
 164     static void uninitializedCopy(const T* src, const T* srcEnd, U* dst)
 165     {
 166         while (src != srcEnd) {
 167             new (NotNull, dst) U(*src);
 168             ++dst;
 169             ++src;
 170         }
 171     }
 172 };
 173 
 174 template&lt;typename T&gt;
 175 struct VectorCopier&lt;true, T&gt;
 176 {
 177     static void uninitializedCopy(const T* src, const T* srcEnd, T* dst)
 178     {
 179         memcpy(static_cast&lt;void*&gt;(dst), static_cast&lt;void*&gt;(const_cast&lt;T*&gt;(src)), reinterpret_cast&lt;const char*&gt;(srcEnd) - reinterpret_cast&lt;const char*&gt;(src));
 180     }
 181     template&lt;typename U&gt;
 182     static void uninitializedCopy(const T* src, const T* srcEnd, U* dst)
 183     {
 184         VectorCopier&lt;false, T&gt;::uninitializedCopy(src, srcEnd, dst);
 185     }
 186 };
 187 
 188 template &lt;bool canFillWithMemset, typename T&gt;
 189 struct VectorFiller;
 190 
 191 template&lt;typename T&gt;
 192 struct VectorFiller&lt;false, T&gt;
 193 {
 194     static void uninitializedFill(T* dst, T* dstEnd, const T&amp; val)
 195     {
 196         while (dst != dstEnd) {
 197             new (NotNull, dst) T(val);
 198             ++dst;
 199         }
 200     }
 201 };
 202 
 203 template&lt;typename T&gt;
 204 struct VectorFiller&lt;true, T&gt;
 205 {
 206     static void uninitializedFill(T* dst, T* dstEnd, const T&amp; val)
 207     {
 208         static_assert(sizeof(T) == 1, &quot;Size of type T should be equal to one!&quot;);
 209         memset(dst, val, dstEnd - dst);
 210     }
 211 };
 212 
 213 template&lt;bool canCompareWithMemcmp, typename T&gt;
 214 struct VectorComparer;
 215 
 216 template&lt;typename T&gt;
 217 struct VectorComparer&lt;false, T&gt;
 218 {
 219     static bool compare(const T* a, const T* b, size_t size)
 220     {
 221         for (size_t i = 0; i &lt; size; ++i)
 222             if (!(a[i] == b[i]))
 223                 return false;
 224         return true;
 225     }
 226 };
 227 
 228 template&lt;typename T&gt;
 229 struct VectorComparer&lt;true, T&gt;
 230 {
 231     static bool compare(const T* a, const T* b, size_t size)
 232     {
 233         return memcmp(a, b, sizeof(T) * size) == 0;
 234     }
 235 };
 236 
 237 template&lt;typename T&gt;
 238 struct VectorTypeOperations
 239 {
 240     static void destruct(T* begin, T* end)
 241     {
 242         VectorDestructor&lt;!std::is_trivially_destructible&lt;T&gt;::value, T&gt;::destruct(begin, end);
 243     }
 244 
 245     static void initializeIfNonPOD(T* begin, T* end)
 246     {
 247         VectorInitializer&lt;VectorTraits&lt;T&gt;::needsInitialization, VectorTraits&lt;T&gt;::canInitializeWithMemset, T&gt;::initializeIfNonPOD(begin, end);
 248     }
 249 
 250     static void initialize(T* begin, T* end)
 251     {
 252         VectorInitializer&lt;VectorTraits&lt;T&gt;::needsInitialization, VectorTraits&lt;T&gt;::canInitializeWithMemset, T&gt;::initialize(begin, end);
 253     }
 254 
 255     static void move(T* src, T* srcEnd, T* dst)
 256     {
 257         VectorMover&lt;VectorTraits&lt;T&gt;::canMoveWithMemcpy, T&gt;::move(src, srcEnd, dst);
 258     }
 259 
 260     static void moveOverlapping(T* src, T* srcEnd, T* dst)
 261     {
 262         VectorMover&lt;VectorTraits&lt;T&gt;::canMoveWithMemcpy, T&gt;::moveOverlapping(src, srcEnd, dst);
 263     }
 264 
 265     static void uninitializedCopy(const T* src, const T* srcEnd, T* dst)
 266     {
 267         VectorCopier&lt;VectorTraits&lt;T&gt;::canCopyWithMemcpy, T&gt;::uninitializedCopy(src, srcEnd, dst);
 268     }
 269 
 270     static void uninitializedFill(T* dst, T* dstEnd, const T&amp; val)
 271     {
 272         VectorFiller&lt;VectorTraits&lt;T&gt;::canFillWithMemset, T&gt;::uninitializedFill(dst, dstEnd, val);
 273     }
 274 
 275     static bool compare(const T* a, const T* b, size_t size)
 276     {
 277         return VectorComparer&lt;VectorTraits&lt;T&gt;::canCompareWithMemcmp, T&gt;::compare(a, b, size);
 278     }
 279 };
 280 
 281 template&lt;typename T, typename Malloc&gt;
 282 class VectorBufferBase {
 283     WTF_MAKE_NONCOPYABLE(VectorBufferBase);
 284 public:
 285     void allocateBuffer(size_t newCapacity)
 286     {
 287         ASSERT(newCapacity);
 288         if (newCapacity &gt; std::numeric_limits&lt;unsigned&gt;::max() / sizeof(T))
 289             CRASH();
 290         size_t sizeToAllocate = newCapacity * sizeof(T);
 291         m_capacity = sizeToAllocate / sizeof(T);
 292         m_buffer = static_cast&lt;T*&gt;(Malloc::malloc(sizeToAllocate));
 293     }
 294 
 295     bool tryAllocateBuffer(size_t newCapacity)
 296     {
 297         ASSERT(newCapacity);
 298         if (newCapacity &gt; std::numeric_limits&lt;unsigned&gt;::max() / sizeof(T))
 299             return false;
 300 
 301         size_t sizeToAllocate = newCapacity * sizeof(T);
 302         T* newBuffer = static_cast&lt;T*&gt;(Malloc::tryMalloc(sizeToAllocate));
 303         if (!newBuffer)
 304             return false;
 305         m_capacity = sizeToAllocate / sizeof(T);
 306         m_buffer = newBuffer;
 307         return true;
 308     }
 309 
 310     bool shouldReallocateBuffer(size_t newCapacity) const
 311     {
 312         return VectorTraits&lt;T&gt;::canMoveWithMemcpy &amp;&amp; m_capacity &amp;&amp; newCapacity;
 313     }
 314 
 315     void reallocateBuffer(size_t newCapacity)
 316     {
 317         ASSERT(shouldReallocateBuffer(newCapacity));
 318         if (newCapacity &gt; std::numeric_limits&lt;size_t&gt;::max() / sizeof(T))
 319             CRASH();
 320         size_t sizeToAllocate = newCapacity * sizeof(T);
 321         m_capacity = sizeToAllocate / sizeof(T);
 322         m_buffer = static_cast&lt;T*&gt;(Malloc::realloc(m_buffer, sizeToAllocate));
 323     }
 324 
 325     void deallocateBuffer(T* bufferToDeallocate)
 326     {
 327         if (!bufferToDeallocate)
 328             return;
 329 
 330         if (m_buffer == bufferToDeallocate) {
 331             m_buffer = 0;
 332             m_capacity = 0;
 333         }
 334 
 335         Malloc::free(bufferToDeallocate);
 336     }
 337 
 338     T* buffer() { return m_buffer; }
 339     const T* buffer() const { return m_buffer; }
 340     static ptrdiff_t bufferMemoryOffset() { return OBJECT_OFFSETOF(VectorBufferBase, m_buffer); }
 341     size_t capacity() const { return m_capacity; }
 342 
 343     MallocPtr&lt;T, Malloc&gt; releaseBuffer()
 344     {
 345         T* buffer = m_buffer;
 346         m_buffer = 0;
 347         m_capacity = 0;
 348         return adoptMallocPtr&lt;T, Malloc&gt;(buffer);
 349     }
 350 
 351 protected:
 352     VectorBufferBase()
 353         : m_buffer(0)
 354         , m_capacity(0)
 355         , m_size(0)
 356     {
 357     }
 358 
 359     VectorBufferBase(T* buffer, size_t capacity, size_t size)
 360         : m_buffer(buffer)
 361         , m_capacity(capacity)
 362         , m_size(size)
 363     {
 364     }
 365 
 366     ~VectorBufferBase()
 367     {
 368         // FIXME: It would be nice to find a way to ASSERT that m_buffer hasn&#39;t leaked here.
 369     }
 370 
 371     T* m_buffer;
 372     unsigned m_capacity;
 373     unsigned m_size; // Only used by the Vector subclass, but placed here to avoid padding the struct.
 374 };
 375 
 376 template&lt;typename T, size_t inlineCapacity, typename Malloc = VectorMalloc&gt; class VectorBuffer;
 377 
 378 template&lt;typename T, typename Malloc&gt;
 379 class VectorBuffer&lt;T, 0, Malloc&gt; : private VectorBufferBase&lt;T, Malloc&gt; {
 380 private:
 381     typedef VectorBufferBase&lt;T, Malloc&gt; Base;
 382 public:
 383     VectorBuffer()
 384     {
 385     }
 386 
 387     VectorBuffer(size_t capacity, size_t size = 0)
 388     {
 389         m_size = size;
 390         // Calling malloc(0) might take a lock and may actually do an
 391         // allocation on some systems.
 392         if (capacity)
 393             allocateBuffer(capacity);
 394     }
 395 
 396     ~VectorBuffer()
 397     {
 398         deallocateBuffer(buffer());
 399     }
 400 
 401     void swap(VectorBuffer&lt;T, 0, Malloc&gt;&amp; other, size_t, size_t)
 402     {
 403         std::swap(m_buffer, other.m_buffer);
 404         std::swap(m_capacity, other.m_capacity);
 405     }
 406 
 407     void restoreInlineBufferIfNeeded() { }
 408 
 409 #if ASAN_ENABLED
 410     void* endOfBuffer()
 411     {
 412         return buffer() + capacity();
 413     }
 414 #endif
 415 
 416     using Base::allocateBuffer;
 417     using Base::tryAllocateBuffer;
 418     using Base::shouldReallocateBuffer;
 419     using Base::reallocateBuffer;
 420     using Base::deallocateBuffer;
 421 
 422     using Base::buffer;
 423     using Base::capacity;
 424     using Base::bufferMemoryOffset;
 425 
 426     using Base::releaseBuffer;
 427 
 428 protected:
 429     using Base::m_size;
 430 
 431 private:
 432     friend class JSC::LLIntOffsetsExtractor;
 433     using Base::m_buffer;
 434     using Base::m_capacity;
 435 };
 436 
 437 template&lt;typename T, size_t inlineCapacity, typename Malloc&gt;
 438 class VectorBuffer : private VectorBufferBase&lt;T, Malloc&gt; {
 439     WTF_MAKE_NONCOPYABLE(VectorBuffer);
 440 private:
 441     typedef VectorBufferBase&lt;T, Malloc&gt; Base;
 442 public:
 443     VectorBuffer()
 444         : Base(inlineBuffer(), inlineCapacity, 0)
 445     {
 446     }
 447 
 448     VectorBuffer(size_t capacity, size_t size = 0)
 449         : Base(inlineBuffer(), inlineCapacity, size)
 450     {
 451         if (capacity &gt; inlineCapacity)
 452             Base::allocateBuffer(capacity);
 453     }
 454 
 455     ~VectorBuffer()
 456     {
 457         deallocateBuffer(buffer());
 458     }
 459 
 460     void allocateBuffer(size_t newCapacity)
 461     {
 462         // FIXME: This should ASSERT(!m_buffer) to catch misuse/leaks.
 463         if (newCapacity &gt; inlineCapacity)
 464             Base::allocateBuffer(newCapacity);
 465         else {
 466             m_buffer = inlineBuffer();
 467             m_capacity = inlineCapacity;
 468         }
 469     }
 470 
 471     bool tryAllocateBuffer(size_t newCapacity)
 472     {
 473         if (newCapacity &gt; inlineCapacity)
 474             return Base::tryAllocateBuffer(newCapacity);
 475         m_buffer = inlineBuffer();
 476         m_capacity = inlineCapacity;
 477         return true;
 478     }
 479 
 480     void deallocateBuffer(T* bufferToDeallocate)
 481     {
 482         if (bufferToDeallocate == inlineBuffer())
 483             return;
 484         Base::deallocateBuffer(bufferToDeallocate);
 485     }
 486 
 487     bool shouldReallocateBuffer(size_t newCapacity) const
 488     {
 489         // We cannot reallocate the inline buffer.
 490         return Base::shouldReallocateBuffer(newCapacity) &amp;&amp; std::min(static_cast&lt;size_t&gt;(m_capacity), newCapacity) &gt; inlineCapacity;
 491     }
 492 
 493     void reallocateBuffer(size_t newCapacity)
 494     {
 495         ASSERT(shouldReallocateBuffer(newCapacity));
 496         Base::reallocateBuffer(newCapacity);
 497     }
 498 
 499     void swap(VectorBuffer&amp; other, size_t mySize, size_t otherSize)
 500     {
 501         if (buffer() == inlineBuffer() &amp;&amp; other.buffer() == other.inlineBuffer()) {
 502             swapInlineBuffer(other, mySize, otherSize);
 503             std::swap(m_capacity, other.m_capacity);
 504         } else if (buffer() == inlineBuffer()) {
 505             m_buffer = other.m_buffer;
 506             other.m_buffer = other.inlineBuffer();
 507             swapInlineBuffer(other, mySize, 0);
 508             std::swap(m_capacity, other.m_capacity);
 509         } else if (other.buffer() == other.inlineBuffer()) {
 510             other.m_buffer = m_buffer;
 511             m_buffer = inlineBuffer();
 512             swapInlineBuffer(other, 0, otherSize);
 513             std::swap(m_capacity, other.m_capacity);
 514         } else {
 515             std::swap(m_buffer, other.m_buffer);
 516             std::swap(m_capacity, other.m_capacity);
 517         }
 518     }
 519 
 520     void restoreInlineBufferIfNeeded()
 521     {
 522         if (m_buffer)
 523             return;
 524         m_buffer = inlineBuffer();
 525         m_capacity = inlineCapacity;
 526     }
 527 
 528 #if ASAN_ENABLED
 529     void* endOfBuffer()
 530     {
 531         ASSERT(buffer());
 532 
 533         IGNORE_GCC_WARNINGS_BEGIN(&quot;invalid-offsetof&quot;)
 534         static_assert((offsetof(VectorBuffer, m_inlineBuffer) + sizeof(m_inlineBuffer)) % 8 == 0, &quot;Inline buffer end needs to be on 8 byte boundary for ASan annotations to work.&quot;);
 535         IGNORE_GCC_WARNINGS_END
 536 
 537         if (buffer() == inlineBuffer())
 538             return reinterpret_cast&lt;char*&gt;(m_inlineBuffer) + sizeof(m_inlineBuffer);
 539 
 540         return buffer() + capacity();
 541     }
 542 #endif
 543 
 544     using Base::buffer;
 545     using Base::capacity;
 546     using Base::bufferMemoryOffset;
 547 
 548     MallocPtr&lt;T, Malloc&gt; releaseBuffer()
 549     {
 550         if (buffer() == inlineBuffer())
 551             return { };
 552         return Base::releaseBuffer();
 553     }
 554 
 555 protected:
 556     using Base::m_size;
 557 
 558 private:
 559     using Base::m_buffer;
 560     using Base::m_capacity;
 561 
 562     void swapInlineBuffer(VectorBuffer&amp; other, size_t mySize, size_t otherSize)
 563     {
 564         // FIXME: We could make swap part of VectorTypeOperations
 565         // https://bugs.webkit.org/show_bug.cgi?id=128863
 566         swapInlineBuffers(inlineBuffer(), other.inlineBuffer(), mySize, otherSize);
 567     }
 568 
 569     static void swapInlineBuffers(T* left, T* right, size_t leftSize, size_t rightSize)
 570     {
 571         if (left == right)
 572             return;
 573 
 574         ASSERT(leftSize &lt;= inlineCapacity);
 575         ASSERT(rightSize &lt;= inlineCapacity);
 576 
 577         size_t swapBound = std::min(leftSize, rightSize);
 578         for (unsigned i = 0; i &lt; swapBound; ++i)
 579             std::swap(left[i], right[i]);
 580         VectorTypeOperations&lt;T&gt;::move(left + swapBound, left + leftSize, right + swapBound);
 581         VectorTypeOperations&lt;T&gt;::move(right + swapBound, right + rightSize, left + swapBound);
 582     }
 583 
 584     T* inlineBuffer() { return reinterpret_cast_ptr&lt;T*&gt;(m_inlineBuffer); }
 585     const T* inlineBuffer() const { return reinterpret_cast_ptr&lt;const T*&gt;(m_inlineBuffer); }
 586 
 587 #if ASAN_ENABLED
 588     // ASan needs the buffer to begin and end on 8-byte boundaries for annotations to work.
 589     // FIXME: Add a redzone before the buffer to catch off by one accesses. We don&#39;t need a guard after, because the buffer is the last member variable.
 590     static constexpr size_t asanInlineBufferAlignment = std::alignment_of&lt;T&gt;::value &gt;= 8 ? std::alignment_of&lt;T&gt;::value : 8;
 591     static constexpr size_t asanAdjustedInlineCapacity = ((sizeof(T) * inlineCapacity + 7) &amp; ~7) / sizeof(T);
 592     typename std::aligned_storage&lt;sizeof(T), asanInlineBufferAlignment&gt;::type m_inlineBuffer[asanAdjustedInlineCapacity];
 593 #else
 594     typename std::aligned_storage&lt;sizeof(T), std::alignment_of&lt;T&gt;::value&gt;::type m_inlineBuffer[inlineCapacity];
 595 #endif
 596 };
 597 
 598 struct UnsafeVectorOverflow {
 599     static NO_RETURN_DUE_TO_ASSERT void overflowed()
 600     {
 601         ASSERT_NOT_REACHED();
 602     }
 603 };
 604 
 605 // Template default values are in Forward.h.
 606 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
 607 class Vector : private VectorBuffer&lt;T, inlineCapacity, Malloc&gt; {
 608     WTF_MAKE_FAST_ALLOCATED;
 609 private:
 610     typedef VectorBuffer&lt;T, inlineCapacity, Malloc&gt; Base;
 611     typedef VectorTypeOperations&lt;T&gt; TypeOperations;
 612     friend class JSC::LLIntOffsetsExtractor;
 613 
 614 public:
 615     typedef T ValueType;
 616 
 617     typedef T* iterator;
 618     typedef const T* const_iterator;
 619     typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator;
 620     typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
 621 
 622     Vector()
 623     {
 624     }
 625 
 626     // Unlike in std::vector, this constructor does not initialize POD types.
 627     explicit Vector(size_t size)
 628         : Base(size, size)
 629     {
 630         asanSetInitialBufferSizeTo(size);
 631 
 632         if (begin())
 633             TypeOperations::initializeIfNonPOD(begin(), end());
 634     }
 635 
 636     Vector(size_t size, const T&amp; val)
 637         : Base(size, size)
 638     {
 639         asanSetInitialBufferSizeTo(size);
 640 
 641         if (begin())
 642             TypeOperations::uninitializedFill(begin(), end(), val);
 643     }
 644 
 645     Vector(std::initializer_list&lt;T&gt; initializerList)
 646     {
 647         reserveInitialCapacity(initializerList.size());
 648 
 649         asanSetInitialBufferSizeTo(initializerList.size());
 650 
 651         for (const auto&amp; element : initializerList)
 652             uncheckedAppend(element);
 653     }
 654 
 655     template&lt;typename... Items&gt;
 656     static Vector from(Items&amp;&amp;... items)
 657     {
 658         Vector result;
 659         auto size = sizeof...(items);
 660 
 661         result.reserveInitialCapacity(size);
 662         result.asanSetInitialBufferSizeTo(size);
 663         result.m_size = size;
 664 
 665         result.uncheckedInitialize&lt;0&gt;(std::forward&lt;Items&gt;(items)...);
 666         return result;
 667     }
 668 
 669     Vector(WTF::HashTableDeletedValueType)
 670         : Base(0, std::numeric_limits&lt;decltype(m_size)&gt;::max())
 671     {
 672     }
 673 
 674     ~Vector()
 675     {
 676         if (m_size)
 677             TypeOperations::destruct(begin(), end());
 678 
 679         asanSetBufferSizeToFullCapacity(0);
 680     }
 681 
 682     Vector(const Vector&amp;);
 683     template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;
 684     explicit Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);
 685 
 686     Vector&amp; operator=(const Vector&amp;);
 687     template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;
 688     Vector&amp; operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp;);
 689 
 690     Vector(Vector&amp;&amp;);
 691     Vector&amp; operator=(Vector&amp;&amp;);
 692 
 693     size_t size() const { return m_size; }
 694     static ptrdiff_t sizeMemoryOffset() { return OBJECT_OFFSETOF(Vector, m_size); }
 695     size_t capacity() const { return Base::capacity(); }
 696     bool isEmpty() const { return !size(); }
 697 
 698     T&amp; at(size_t i)
 699     {
 700         if (UNLIKELY(i &gt;= size()))
 701             OverflowHandler::overflowed();
 702         return Base::buffer()[i];
 703     }
 704     const T&amp; at(size_t i) const
 705     {
 706         if (UNLIKELY(i &gt;= size()))
 707             OverflowHandler::overflowed();
 708         return Base::buffer()[i];
 709     }
 710     T&amp; at(Checked&lt;size_t&gt; i)
 711     {
 712         RELEASE_ASSERT(i &lt; size());
 713         return Base::buffer()[i];
 714     }
 715     const T&amp; at(Checked&lt;size_t&gt; i) const
 716     {
 717         RELEASE_ASSERT(i &lt; size());
 718         return Base::buffer()[i];
 719     }
 720 
 721     T&amp; operator[](size_t i) { return at(i); }
 722     const T&amp; operator[](size_t i) const { return at(i); }
 723     T&amp; operator[](Checked&lt;size_t&gt; i) { return at(i); }
 724     const T&amp; operator[](Checked&lt;size_t&gt; i) const { return at(i); }
 725 
 726     T* data() { return Base::buffer(); }
 727     const T* data() const { return Base::buffer(); }
 728     static ptrdiff_t dataMemoryOffset() { return Base::bufferMemoryOffset(); }
 729 
 730     iterator begin() { return data(); }
 731     iterator end() { return begin() + m_size; }
 732     const_iterator begin() const { return data(); }
 733     const_iterator end() const { return begin() + m_size; }
 734 
 735     reverse_iterator rbegin() { return reverse_iterator(end()); }
 736     reverse_iterator rend() { return reverse_iterator(begin()); }
 737     const_reverse_iterator rbegin() const { return const_reverse_iterator(end()); }
 738     const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
 739 
 740     T&amp; first() { return at(0); }
 741     const T&amp; first() const { return at(0); }
 742     T&amp; last() { return at(size() - 1); }
 743     const T&amp; last() const { return at(size() - 1); }
 744 
 745     T takeLast()
 746     {
 747         T result = WTFMove(last());
 748         removeLast();
 749         return result;
 750     }
 751 
 752     template&lt;typename U&gt; bool contains(const U&amp;) const;
 753     template&lt;typename U&gt; size_t find(const U&amp;) const;
 754     template&lt;typename MatchFunction&gt; size_t findMatching(const MatchFunction&amp;) const;
 755     template&lt;typename U&gt; size_t reverseFind(const U&amp;) const;
 756 
 757     template&lt;typename U&gt; bool appendIfNotContains(const U&amp;);
 758 
 759     void shrink(size_t size);
 760     void grow(size_t size);
 761     void resize(size_t size);
 762     void resizeToFit(size_t size);
 763     void reserveCapacity(size_t newCapacity);
 764     bool tryReserveCapacity(size_t newCapacity);
 765     void reserveInitialCapacity(size_t initialCapacity);
 766     void shrinkCapacity(size_t newCapacity);
 767     void shrinkToFit() { shrinkCapacity(size()); }
 768 
 769     void clear() { shrinkCapacity(0); }
 770 
 771     template&lt;typename U = T&gt; Vector&lt;U&gt; isolatedCopy() const;
 772 
 773     ALWAYS_INLINE void append(ValueType&amp;&amp; value) { append&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); }
 774     template&lt;typename U&gt; void append(U&amp;&amp;);
 775     template&lt;typename... Args&gt; void constructAndAppend(Args&amp;&amp;...);
 776     template&lt;typename... Args&gt; bool tryConstructAndAppend(Args&amp;&amp;...);
 777 
 778     void uncheckedAppend(ValueType&amp;&amp; value) { uncheckedAppend&lt;ValueType&gt;(std::forward&lt;ValueType&gt;(value)); }
 779     template&lt;typename U&gt; void uncheckedAppend(U&amp;&amp;);
 780     template&lt;typename... Args&gt; void uncheckedConstructAndAppend(Args&amp;&amp;...);
 781 
 782     template&lt;typename U&gt; void append(const U*, size_t);
 783     template&lt;typename U, size_t otherCapacity&gt; void appendVector(const Vector&lt;U, otherCapacity&gt;&amp;);
 784     template&lt;typename U, size_t otherCapacity&gt; void appendVector(Vector&lt;U, otherCapacity&gt;&amp;&amp;);
 785     template&lt;typename U&gt; bool tryAppend(const U*, size_t);
 786 
 787     template&lt;typename U&gt; void insert(size_t position, const U*, size_t);
 788     template&lt;typename U&gt; void insert(size_t position, U&amp;&amp;);
 789     template&lt;typename U, size_t c, typename OH, size_t m, typename M&gt; void insertVector(size_t position, const Vector&lt;U, c, OH, m, M&gt;&amp;);
 790 
 791     void remove(size_t position);
 792     void remove(size_t position, size_t length);
 793     template&lt;typename U&gt; bool removeFirst(const U&amp;);
 794     template&lt;typename MatchFunction&gt; bool removeFirstMatching(const MatchFunction&amp;, size_t startIndex = 0);
 795     template&lt;typename U&gt; unsigned removeAll(const U&amp;);
 796     template&lt;typename MatchFunction&gt; unsigned removeAllMatching(const MatchFunction&amp;, size_t startIndex = 0);
 797 
 798     void removeLast()
 799     {
 800         if (UNLIKELY(isEmpty()))
 801             OverflowHandler::overflowed();
 802         shrink(size() - 1);
 803     }
 804 
 805     void fill(const T&amp;, size_t);
 806     void fill(const T&amp; val) { fill(val, size()); }
 807 
 808     template&lt;typename Iterator&gt; void appendRange(Iterator start, Iterator end);
 809 
 810     MallocPtr&lt;T, Malloc&gt; releaseBuffer();
 811 
 812     void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; other)
 813     {
 814 #if ASAN_ENABLED
 815         if (this == std::addressof(other)) // ASan will crash if we try to restrict access to the same buffer twice.
 816             return;
 817 #endif
 818 
 819         // Make it possible to copy inline buffers.
 820         asanSetBufferSizeToFullCapacity();
 821         other.asanSetBufferSizeToFullCapacity();
 822 
 823         Base::swap(other, m_size, other.m_size);
 824         std::swap(m_size, other.m_size);
 825 
 826         asanSetInitialBufferSizeTo(m_size);
 827         other.asanSetInitialBufferSizeTo(other.m_size);
 828     }
 829 
 830     void reverse();
 831 
 832     void checkConsistency();
 833 
 834     template&lt;typename MapFunction, typename R = typename std::result_of&lt;MapFunction(const T&amp;)&gt;::type&gt; Vector&lt;R&gt; map(MapFunction) const;
 835 
 836     bool isHashTableDeletedValue() const { return m_size == std::numeric_limits&lt;decltype(m_size)&gt;::max(); }
 837 
 838 private:
 839     void expandCapacity(size_t newMinCapacity);
 840     T* expandCapacity(size_t newMinCapacity, T*);
 841     bool tryExpandCapacity(size_t newMinCapacity);
 842     const T* tryExpandCapacity(size_t newMinCapacity, const T*);
 843     template&lt;typename U&gt; U* expandCapacity(size_t newMinCapacity, U*);
 844     template&lt;typename U&gt; void appendSlowCase(U&amp;&amp;);
 845     template&lt;typename... Args&gt; void constructAndAppendSlowCase(Args&amp;&amp;...);
 846     template&lt;typename... Args&gt; bool tryConstructAndAppendSlowCase(Args&amp;&amp;...);
 847 
 848     template&lt;size_t position, typename U, typename... Items&gt;
 849     void uncheckedInitialize(U&amp;&amp; item, Items&amp;&amp;... items)
 850     {
 851         uncheckedInitialize&lt;position&gt;(std::forward&lt;U&gt;(item));
 852         uncheckedInitialize&lt;position + 1&gt;(std::forward&lt;Items&gt;(items)...);
 853     }
 854     template&lt;size_t position, typename U&gt;
 855     void uncheckedInitialize(U&amp;&amp; value)
 856     {
 857         ASSERT(position &lt; size());
 858         ASSERT(position &lt; capacity());
 859         new (NotNull, begin() + position) T(std::forward&lt;U&gt;(value));
 860     }
 861 
 862     void asanSetInitialBufferSizeTo(size_t);
 863     void asanSetBufferSizeToFullCapacity(size_t);
 864     void asanSetBufferSizeToFullCapacity() { asanSetBufferSizeToFullCapacity(size()); }
 865 
 866     void asanBufferSizeWillChangeTo(size_t);
 867 
 868     using Base::m_size;
 869     using Base::buffer;
 870     using Base::capacity;
 871     using Base::swap;
 872     using Base::allocateBuffer;
 873     using Base::deallocateBuffer;
 874     using Base::tryAllocateBuffer;
 875     using Base::shouldReallocateBuffer;
 876     using Base::reallocateBuffer;
 877     using Base::restoreInlineBufferIfNeeded;
 878     using Base::releaseBuffer;
 879 #if ASAN_ENABLED
 880     using Base::endOfBuffer;
 881 #endif
 882 };
 883 
 884 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
 885 Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::Vector(const Vector&amp; other)
 886     : Base(other.capacity(), other.size())
 887 {
 888     asanSetInitialBufferSizeTo(other.size());
 889 
 890     if (begin())
 891         TypeOperations::uninitializedCopy(other.begin(), other.end(), begin());
 892 }
 893 
 894 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
 895 template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;
 896 Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::Vector(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp; other)
 897     : Base(other.capacity(), other.size())
 898 {
 899     asanSetInitialBufferSizeTo(other.size());
 900 
 901     if (begin())
 902         TypeOperations::uninitializedCopy(other.begin(), other.end(), begin());
 903 }
 904 
 905 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
 906 Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::operator=(const Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; other)
 907 {
 908     if (&amp;other == this)
 909         return *this;
 910 
 911     if (size() &gt; other.size())
 912         shrink(other.size());
 913     else if (other.size() &gt; capacity()) {
 914         clear();
 915         reserveCapacity(other.size());
 916         ASSERT(begin());
 917     }
 918 
 919     asanBufferSizeWillChangeTo(other.size());
 920 
 921     std::copy(other.begin(), other.begin() + size(), begin());
 922     TypeOperations::uninitializedCopy(other.begin() + size(), other.end(), end());
 923     m_size = other.size();
 924 
 925     return *this;
 926 }
 927 
 928 inline bool typelessPointersAreEqual(const void* a, const void* b) { return a == b; }
 929 
 930 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
 931 template&lt;size_t otherCapacity, typename otherOverflowBehaviour, size_t otherMinimumCapacity, typename OtherMalloc&gt;
 932 Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::operator=(const Vector&lt;T, otherCapacity, otherOverflowBehaviour, otherMinimumCapacity, OtherMalloc&gt;&amp; other)
 933 {
 934     // If the inline capacities match, we should call the more specific
 935     // template.  If the inline capacities don&#39;t match, the two objects
 936     // shouldn&#39;t be allocated the same address.
 937     ASSERT(!typelessPointersAreEqual(&amp;other, this));
 938 
 939     if (size() &gt; other.size())
 940         shrink(other.size());
 941     else if (other.size() &gt; capacity()) {
 942         clear();
 943         reserveCapacity(other.size());
 944         ASSERT(begin());
 945     }
 946 
 947     asanBufferSizeWillChangeTo(other.size());
 948 
 949     std::copy(other.begin(), other.begin() + size(), begin());
 950     TypeOperations::uninitializedCopy(other.begin() + size(), other.end(), end());
 951     m_size = other.size();
 952 
 953     return *this;
 954 }
 955 
 956 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
 957 inline Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::Vector(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp;&amp; other)
 958 {
 959     swap(other);
 960 }
 961 
 962 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
 963 inline Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::operator=(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp;&amp; other)
 964 {
 965     swap(other);
 966     return *this;
 967 }
 968 
 969 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
 970 template&lt;typename U&gt;
 971 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::contains(const U&amp; value) const
 972 {
 973     return find(value) != notFound;
 974 }
 975 
 976 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
 977 template&lt;typename MatchFunction&gt;
 978 size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::findMatching(const MatchFunction&amp; matches) const
 979 {
 980     for (size_t i = 0; i &lt; size(); ++i) {
 981         if (matches(at(i)))
 982             return i;
 983     }
 984     return notFound;
 985 }
 986 
 987 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
 988 template&lt;typename U&gt;
 989 size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::find(const U&amp; value) const
 990 {
 991     return findMatching([&amp;](auto&amp; item) {
 992         return item == value;
 993     });
 994 }
 995 
 996 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
 997 template&lt;typename U&gt;
 998 size_t Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::reverseFind(const U&amp; value) const
 999 {
1000     for (size_t i = 1; i &lt;= size(); ++i) {
1001         const size_t index = size() - i;
1002         if (at(index) == value)
1003             return index;
1004     }
1005     return notFound;
1006 }
1007 
1008 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1009 template&lt;typename U&gt;
1010 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendIfNotContains(const U&amp; value)
1011 {
1012     if (contains(value))
1013         return false;
1014     append(value);
1015     return true;
1016 }
1017 
1018 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1019 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::fill(const T&amp; val, size_t newSize)
1020 {
1021     if (size() &gt; newSize)
1022         shrink(newSize);
1023     else if (newSize &gt; capacity()) {
1024         clear();
1025         reserveCapacity(newSize);
1026         ASSERT(begin());
1027     }
1028 
1029     asanBufferSizeWillChangeTo(newSize);
1030 
1031     std::fill(begin(), end(), val);
1032     TypeOperations::uninitializedFill(end(), begin() + newSize, val);
1033     m_size = newSize;
1034 }
1035 
1036 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1037 template&lt;typename Iterator&gt;
1038 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendRange(Iterator start, Iterator end)
1039 {
1040     for (Iterator it = start; it != end; ++it)
1041         append(*it);
1042 }
1043 
1044 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1045 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::expandCapacity(size_t newMinCapacity)
1046 {
1047     reserveCapacity(std::max(newMinCapacity, std::max(static_cast&lt;size_t&gt;(minCapacity), capacity() + capacity() / 4 + 1)));
1048 }
1049 
1050 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1051 NEVER_INLINE T* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::expandCapacity(size_t newMinCapacity, T* ptr)
1052 {
1053     if (ptr &lt; begin() || ptr &gt;= end()) {
1054         expandCapacity(newMinCapacity);
1055         return ptr;
1056     }
1057     size_t index = ptr - begin();
1058     expandCapacity(newMinCapacity);
1059     return begin() + index;
1060 }
1061 
1062 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1063 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryExpandCapacity(size_t newMinCapacity)
1064 {
1065     return tryReserveCapacity(std::max(newMinCapacity, std::max(static_cast&lt;size_t&gt;(minCapacity), capacity() + capacity() / 4 + 1)));
1066 }
1067 
1068 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1069 const T* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryExpandCapacity(size_t newMinCapacity, const T* ptr)
1070 {
1071     if (ptr &lt; begin() || ptr &gt;= end()) {
1072         if (!tryExpandCapacity(newMinCapacity))
1073             return 0;
1074         return ptr;
1075     }
1076     size_t index = ptr - begin();
1077     if (!tryExpandCapacity(newMinCapacity))
1078         return 0;
1079     return begin() + index;
1080 }
1081 
1082 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1083 template&lt;typename U&gt;
1084 inline U* Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::expandCapacity(size_t newMinCapacity, U* ptr)
1085 {
1086     expandCapacity(newMinCapacity);
1087     return ptr;
1088 }
1089 
1090 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1091 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::resize(size_t size)
1092 {
1093     if (size &lt;= m_size) {
1094         TypeOperations::destruct(begin() + size, end());
1095         asanBufferSizeWillChangeTo(size);
1096     } else {
1097         if (size &gt; capacity())
1098             expandCapacity(size);
1099         asanBufferSizeWillChangeTo(size);
1100         if (begin())
1101             TypeOperations::initializeIfNonPOD(end(), begin() + size);
1102     }
1103 
1104     m_size = size;
1105 }
1106 
1107 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1108 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::resizeToFit(size_t size)
1109 {
1110     reserveCapacity(size);
1111     resize(size);
1112 }
1113 
1114 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1115 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::shrink(size_t size)
1116 {
1117     ASSERT(size &lt;= m_size);
1118     TypeOperations::destruct(begin() + size, end());
1119     asanBufferSizeWillChangeTo(size);
1120     m_size = size;
1121 }
1122 
1123 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1124 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::grow(size_t size)
1125 {
1126     ASSERT(size &gt;= m_size);
1127     if (size &gt; capacity())
1128         expandCapacity(size);
1129     asanBufferSizeWillChangeTo(size);
1130     if (begin())
1131         TypeOperations::initializeIfNonPOD(end(), begin() + size);
1132     m_size = size;
1133 }
1134 
1135 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1136 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::asanSetInitialBufferSizeTo(size_t size)
1137 {
1138 #if ASAN_ENABLED
1139     if (!buffer())
1140         return;
1141 
1142     // This function resticts buffer access to only elements in [begin(), end()) range, making ASan detect an error
1143     // when accessing elements in [end(), endOfBuffer()) range.
1144     // A newly allocated buffer can be accessed without restrictions, so &quot;old_mid&quot; argument equals &quot;end&quot; argument.
1145     __sanitizer_annotate_contiguous_container(buffer(), endOfBuffer(), endOfBuffer(), buffer() + size);
1146 #else
1147     UNUSED_PARAM(size);
1148 #endif
1149 }
1150 
1151 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1152 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::asanSetBufferSizeToFullCapacity(size_t size)
1153 {
1154 #if ASAN_ENABLED
1155     if (!buffer())
1156         return;
1157 
1158     // ASan requires that the annotation is returned to its initial state before deallocation.
1159     __sanitizer_annotate_contiguous_container(buffer(), endOfBuffer(), buffer() + size, endOfBuffer());
1160 #else
1161     UNUSED_PARAM(size);
1162 #endif
1163 }
1164 
1165 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1166 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::asanBufferSizeWillChangeTo(size_t newSize)
1167 {
1168 #if ASAN_ENABLED
1169     if (!buffer())
1170         return;
1171 
1172     // Change allowed range.
1173     __sanitizer_annotate_contiguous_container(buffer(), endOfBuffer(), buffer() + size(), buffer() + newSize);
1174 #else
1175     UNUSED_PARAM(newSize);
1176 #endif
1177 }
1178 
1179 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1180 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::reserveCapacity(size_t newCapacity)
1181 {
1182     if (newCapacity &lt;= capacity())
1183         return;
1184     T* oldBuffer = begin();
1185     T* oldEnd = end();
1186 
1187     asanSetBufferSizeToFullCapacity();
1188 
1189     Base::allocateBuffer(newCapacity);
1190     ASSERT(begin());
1191 
1192     asanSetInitialBufferSizeTo(size());
1193 
1194     TypeOperations::move(oldBuffer, oldEnd, begin());
1195     Base::deallocateBuffer(oldBuffer);
1196 }
1197 
1198 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1199 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryReserveCapacity(size_t newCapacity)
1200 {
1201     if (newCapacity &lt;= capacity())
1202         return true;
1203     T* oldBuffer = begin();
1204     T* oldEnd = end();
1205 
1206     asanSetBufferSizeToFullCapacity();
1207 
1208     if (!Base::tryAllocateBuffer(newCapacity)) {
1209         asanSetInitialBufferSizeTo(size());
1210         return false;
1211     }
1212     ASSERT(begin());
1213 
1214     asanSetInitialBufferSizeTo(size());
1215 
1216     TypeOperations::move(oldBuffer, oldEnd, begin());
1217     Base::deallocateBuffer(oldBuffer);
1218     return true;
1219 }
1220 
1221 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1222 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::reserveInitialCapacity(size_t initialCapacity)
1223 {
1224     ASSERT(!m_size);
1225     ASSERT(capacity() == inlineCapacity);
1226     if (initialCapacity &gt; inlineCapacity)
1227         Base::allocateBuffer(initialCapacity);
1228 }
1229 
1230 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1231 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::shrinkCapacity(size_t newCapacity)
1232 {
1233     if (newCapacity &gt;= capacity())
1234         return;
1235 
1236     if (newCapacity &lt; size())
1237         shrink(newCapacity);
1238 
1239     asanSetBufferSizeToFullCapacity();
1240 
1241     T* oldBuffer = begin();
1242     if (newCapacity &gt; 0) {
1243         if (Base::shouldReallocateBuffer(newCapacity)) {
1244             Base::reallocateBuffer(newCapacity);
1245             asanSetInitialBufferSizeTo(size());
1246             return;
1247         }
1248 
1249         T* oldEnd = end();
1250         Base::allocateBuffer(newCapacity);
1251         if (begin() != oldBuffer)
1252             TypeOperations::move(oldBuffer, oldEnd, begin());
1253     }
1254 
1255     Base::deallocateBuffer(oldBuffer);
1256     Base::restoreInlineBufferIfNeeded();
1257 
1258     asanSetInitialBufferSizeTo(size());
1259 }
1260 
1261 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1262 template&lt;typename U&gt;
1263 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::append(const U* data, size_t dataSize)
1264 {
1265     size_t newSize = m_size + dataSize;
1266     if (newSize &gt; capacity()) {
1267         data = expandCapacity(newSize, data);
1268         ASSERT(begin());
1269     }
1270     if (newSize &lt; m_size)
1271         CRASH();
1272     asanBufferSizeWillChangeTo(newSize);
1273     T* dest = end();
1274     VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), dest);
1275     m_size = newSize;
1276 }
1277 
1278 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1279 template&lt;typename U&gt;
1280 ALWAYS_INLINE bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryAppend(const U* data, size_t dataSize)
1281 {
1282     size_t newSize = m_size + dataSize;
1283     if (newSize &gt; capacity()) {
1284         data = tryExpandCapacity(newSize, data);
1285         if (!data)
1286             return false;
1287         ASSERT(begin());
1288     }
1289     if (newSize &lt; m_size)
1290         return false;
1291     asanBufferSizeWillChangeTo(newSize);
1292     T* dest = end();
1293     VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), dest);
1294     m_size = newSize;
1295     return true;
1296 }
1297 
1298 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1299 template&lt;typename U&gt;
1300 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::append(U&amp;&amp; value)
1301 {
1302     if (size() != capacity()) {
1303         asanBufferSizeWillChangeTo(m_size + 1);
1304         new (NotNull, end()) T(std::forward&lt;U&gt;(value));
1305         ++m_size;
1306         return;
1307     }
1308 
1309     appendSlowCase(std::forward&lt;U&gt;(value));
1310 }
1311 
1312 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1313 template&lt;typename... Args&gt;
1314 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::constructAndAppend(Args&amp;&amp;... args)
1315 {
1316     if (size() != capacity()) {
1317         asanBufferSizeWillChangeTo(m_size + 1);
1318         new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1319         ++m_size;
1320         return;
1321     }
1322 
1323     constructAndAppendSlowCase(std::forward&lt;Args&gt;(args)...);
1324 }
1325 
1326 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1327 template&lt;typename... Args&gt;
1328 ALWAYS_INLINE bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryConstructAndAppend(Args&amp;&amp;... args)
1329 {
1330     if (size() != capacity()) {
1331         asanBufferSizeWillChangeTo(m_size + 1);
1332         new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1333         ++m_size;
1334         return true;
1335     }
1336 
1337     return tryConstructAndAppendSlowCase(std::forward&lt;Args&gt;(args)...);
1338 }
1339 
1340 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1341 template&lt;typename U&gt;
1342 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendSlowCase(U&amp;&amp; value)
1343 {
1344     ASSERT(size() == capacity());
1345 
1346     auto ptr = const_cast&lt;typename std::remove_const&lt;typename std::remove_reference&lt;U&gt;::type&gt;::type*&gt;(std::addressof(value));
1347     ptr = expandCapacity(size() + 1, ptr);
1348     ASSERT(begin());
1349 
1350     asanBufferSizeWillChangeTo(m_size + 1);
1351     new (NotNull, end()) T(std::forward&lt;U&gt;(*ptr));
1352     ++m_size;
1353 }
1354 
1355 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1356 template&lt;typename... Args&gt;
1357 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::constructAndAppendSlowCase(Args&amp;&amp;... args)
1358 {
1359     ASSERT(size() == capacity());
1360 
1361     expandCapacity(size() + 1);
1362     ASSERT(begin());
1363 
1364     asanBufferSizeWillChangeTo(m_size + 1);
1365     new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1366     ++m_size;
1367 }
1368 
1369 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1370 template&lt;typename... Args&gt;
1371 bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::tryConstructAndAppendSlowCase(Args&amp;&amp;... args)
1372 {
1373     ASSERT(size() == capacity());
1374 
1375     if (UNLIKELY(!tryExpandCapacity(size() + 1)))
1376         return false;
1377     ASSERT(begin());
1378 
1379     asanBufferSizeWillChangeTo(m_size + 1);
1380     new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1381     ++m_size;
1382     return true;
1383 }
1384 
1385 // This version of append saves a branch in the case where you know that the
1386 // vector&#39;s capacity is large enough for the append to succeed.
1387 
1388 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1389 template&lt;typename U&gt;
1390 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::uncheckedAppend(U&amp;&amp; value)
1391 {
1392     ASSERT(size() &lt; capacity());
1393 
1394     asanBufferSizeWillChangeTo(m_size + 1);
1395 
1396     new (NotNull, end()) T(std::forward&lt;U&gt;(value));
1397     ++m_size;
1398 }
1399 
1400 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1401 template&lt;typename... Args&gt;
1402 ALWAYS_INLINE void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::uncheckedConstructAndAppend(Args&amp;&amp;... args)
1403 {
1404     ASSERT(size() &lt; capacity());
1405 
1406     asanBufferSizeWillChangeTo(m_size + 1);
1407 
1408     new (NotNull, end()) T(std::forward&lt;Args&gt;(args)...);
1409     ++m_size;
1410 }
1411 
1412 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1413 template&lt;typename U, size_t otherCapacity&gt;
1414 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendVector(const Vector&lt;U, otherCapacity&gt;&amp; val)
1415 {
1416     append(val.begin(), val.size());
1417 }
1418 
1419 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1420 template&lt;typename U, size_t otherCapacity&gt;
1421 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::appendVector(Vector&lt;U, otherCapacity&gt;&amp;&amp; val)
1422 {
1423     size_t newSize = m_size + val.size();
1424     if (newSize &gt; capacity())
1425         expandCapacity(newSize);
1426     for (auto&amp; item : val)
1427         uncheckedAppend(WTFMove(item));
1428 }
1429 
1430 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1431 template&lt;typename U&gt;
1432 void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::insert(size_t position, const U* data, size_t dataSize)
1433 {
1434     ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
1435     size_t newSize = m_size + dataSize;
1436     if (newSize &gt; capacity()) {
1437         data = expandCapacity(newSize, data);
1438         ASSERT(begin());
1439     }
1440     if (newSize &lt; m_size)
1441         CRASH();
1442     asanBufferSizeWillChangeTo(newSize);
1443     T* spot = begin() + position;
1444     TypeOperations::moveOverlapping(spot, end(), spot + dataSize);
1445     VectorCopier&lt;std::is_trivial&lt;T&gt;::value, U&gt;::uninitializedCopy(data, std::addressof(data[dataSize]), spot);
1446     m_size = newSize;
1447 }
1448 
1449 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1450 template&lt;typename U&gt;
1451 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::insert(size_t position, U&amp;&amp; value)
1452 {
1453     ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
1454 
1455     auto ptr = const_cast&lt;typename std::remove_const&lt;typename std::remove_reference&lt;U&gt;::type&gt;::type*&gt;(std::addressof(value));
1456     if (size() == capacity()) {
1457         ptr = expandCapacity(size() + 1, ptr);
1458         ASSERT(begin());
1459     }
1460 
1461     asanBufferSizeWillChangeTo(m_size + 1);
1462 
1463     T* spot = begin() + position;
1464     TypeOperations::moveOverlapping(spot, end(), spot + 1);
1465     new (NotNull, spot) T(std::forward&lt;U&gt;(*ptr));
1466     ++m_size;
1467 }
1468 
1469 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1470 template&lt;typename U, size_t c, typename OH, size_t m, typename M&gt;
1471 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::insertVector(size_t position, const Vector&lt;U, c, OH, m, M&gt;&amp; val)
1472 {
1473     insert(position, val.begin(), val.size());
1474 }
1475 
1476 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1477 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::remove(size_t position)
1478 {
1479     ASSERT_WITH_SECURITY_IMPLICATION(position &lt; size());
1480     T* spot = begin() + position;
1481     spot-&gt;~T();
1482     TypeOperations::moveOverlapping(spot + 1, end(), spot);
1483     asanBufferSizeWillChangeTo(m_size - 1);
1484     --m_size;
1485 }
1486 
1487 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1488 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::remove(size_t position, size_t length)
1489 {
1490     ASSERT_WITH_SECURITY_IMPLICATION(position &lt;= size());
1491     ASSERT_WITH_SECURITY_IMPLICATION(position + length &lt;= size());
1492     T* beginSpot = begin() + position;
1493     T* endSpot = beginSpot + length;
1494     TypeOperations::destruct(beginSpot, endSpot);
1495     TypeOperations::moveOverlapping(endSpot, end(), beginSpot);
1496     asanBufferSizeWillChangeTo(m_size - length);
1497     m_size -= length;
1498 }
1499 
1500 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1501 template&lt;typename U&gt;
1502 inline bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::removeFirst(const U&amp; value)
1503 {
1504     return removeFirstMatching([&amp;value] (const T&amp; current) {
1505         return current == value;
1506     });
1507 }
1508 
1509 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1510 template&lt;typename MatchFunction&gt;
1511 inline bool Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::removeFirstMatching(const MatchFunction&amp; matches, size_t startIndex)
1512 {
1513     for (size_t i = startIndex; i &lt; size(); ++i) {
1514         if (matches(at(i))) {
1515             remove(i);
1516             return true;
1517         }
1518     }
1519     return false;
1520 }
1521 
1522 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1523 template&lt;typename U&gt;
1524 inline unsigned Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::removeAll(const U&amp; value)
1525 {
1526     return removeAllMatching([&amp;value] (const T&amp; current) {
1527         return current == value;
1528     });
1529 }
1530 
1531 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1532 template&lt;typename MatchFunction&gt;
1533 inline unsigned Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::removeAllMatching(const MatchFunction&amp; matches, size_t startIndex)
1534 {
1535     iterator holeBegin = end();
1536     iterator holeEnd = end();
1537     unsigned matchCount = 0;
1538     for (auto it = begin() + startIndex, itEnd = end(); it &lt; itEnd; ++it) {
1539         if (matches(*it)) {
1540             if (holeBegin == end())
1541                 holeBegin = it;
1542             else if (holeEnd != it) {
1543                 TypeOperations::moveOverlapping(holeEnd, it, holeBegin);
1544                 holeBegin += it - holeEnd;
1545             }
1546             holeEnd = it + 1;
1547             it-&gt;~T();
1548             ++matchCount;
1549         }
1550     }
1551     if (holeEnd != end())
1552         TypeOperations::moveOverlapping(holeEnd, end(), holeBegin);
1553     asanBufferSizeWillChangeTo(m_size - matchCount);
1554     m_size -= matchCount;
1555     return matchCount;
1556 }
1557 
1558 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1559 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::reverse()
1560 {
1561     for (size_t i = 0; i &lt; m_size / 2; ++i)
1562         std::swap(at(i), at(m_size - 1 - i));
1563 }
1564 
1565 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1566 template&lt;typename MapFunction, typename R&gt;
1567 inline Vector&lt;R&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::map(MapFunction mapFunction) const
1568 {
1569     Vector&lt;R&gt; result;
1570     result.reserveInitialCapacity(size());
1571     for (size_t i = 0; i &lt; size(); ++i)
1572         result.uncheckedAppend(mapFunction(at(i)));
1573     return result;
1574 }
1575 
1576 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1577 inline MallocPtr&lt;T, Malloc&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::releaseBuffer()
1578 {
1579     // FIXME: Find a way to preserve annotations on the returned buffer.
1580     // ASan requires that all annotations are removed before deallocation,
1581     // and MallocPtr doesn&#39;t implement that.
1582     asanSetBufferSizeToFullCapacity();
1583 
1584     auto buffer = Base::releaseBuffer();
1585     if (inlineCapacity &amp;&amp; !buffer &amp;&amp; m_size) {
1586         // If the vector had some data, but no buffer to release,
1587         // that means it was using the inline buffer. In that case,
1588         // we create a brand new buffer so the caller always gets one.
1589         size_t bytes = m_size * sizeof(T);
1590         buffer = adoptMallocPtr&lt;T, Malloc&gt;(static_cast&lt;T*&gt;(Malloc::malloc(bytes)));
1591         memcpy(buffer.get(), data(), bytes);
1592     }
1593     m_size = 0;
1594     // FIXME: Should we call Base::restoreInlineBufferIfNeeded() here?
1595     return buffer;
1596 }
1597 
1598 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1599 inline void Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::checkConsistency()
1600 {
1601 #if ASSERT_ENABLED
1602     for (size_t i = 0; i &lt; size(); ++i)
1603         ValueCheck&lt;T&gt;::checkConsistency(at(i));
1604 #endif
1605 }
1606 
1607 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1608 inline void swap(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; a, Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; b)
1609 {
1610     a.swap(b);
1611 }
1612 
1613 template&lt;typename T, size_t inlineCapacityA, typename OverflowHandlerA, size_t minCapacityA, typename MallocA, size_t inlineCapacityB, typename OverflowHandlerB, size_t minCapacityB, typename MallocB&gt;
1614 bool operator==(const Vector&lt;T, inlineCapacityA, OverflowHandlerA, minCapacityA, MallocA&gt;&amp; a, const Vector&lt;T, inlineCapacityB, OverflowHandlerB, minCapacityB, MallocB&gt;&amp; b)
1615 {
1616     if (a.size() != b.size())
1617         return false;
1618 
1619     return VectorTypeOperations&lt;T&gt;::compare(a.data(), b.data(), a.size());
1620 }
1621 
1622 template&lt;typename T, size_t inlineCapacityA, typename OverflowHandlerA, size_t minCapacityA, typename MallocA, size_t inlineCapacityB, typename OverflowHandlerB, size_t minCapacityB, typename MallocB&gt;
1623 inline bool operator!=(const Vector&lt;T, inlineCapacityA, OverflowHandlerA, minCapacityA, MallocA&gt;&amp; a, const Vector&lt;T, inlineCapacityB, OverflowHandlerB, minCapacityB, MallocB&gt;&amp; b)
1624 {
1625     return !(a == b);
1626 }
1627 
1628 #if ASSERT_ENABLED
1629 template&lt;typename T&gt; struct ValueCheck&lt;Vector&lt;T&gt;&gt; {
1630     typedef Vector&lt;T&gt; TraitType;
1631     static void checkConsistency(const Vector&lt;T&gt;&amp; v)
1632     {
1633         v.checkConsistency();
1634     }
1635 };
1636 #endif // ASSERT_ENABLED
1637 
1638 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1639 template&lt;typename U&gt;
1640 inline Vector&lt;U&gt; Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;::isolatedCopy() const
1641 {
1642     Vector&lt;U&gt; copy;
1643     copy.reserveInitialCapacity(size());
1644     for (const auto&amp; element : *this)
1645         copy.uncheckedAppend(element.isolatedCopy());
1646     return copy;
1647 }
1648 
1649 template&lt;typename VectorType, typename Func&gt;
1650 size_t removeRepeatedElements(VectorType&amp; vector, const Func&amp; func)
1651 {
1652     auto end = std::unique(vector.begin(), vector.end(), func);
1653     size_t newSize = end - vector.begin();
1654     vector.shrink(newSize);
1655     return newSize;
1656 }
1657 
1658 template&lt;typename T, size_t inlineCapacity, typename OverflowHandler, size_t minCapacity, typename Malloc&gt;
1659 size_t removeRepeatedElements(Vector&lt;T, inlineCapacity, OverflowHandler, minCapacity, Malloc&gt;&amp; vector)
1660 {
1661     return removeRepeatedElements(vector, [] (T&amp; a, T&amp; b) { return a == b; });
1662 }
1663 
1664 template&lt;typename SourceType&gt;
1665 struct CollectionInspector {
1666     using RealSourceType = typename std::remove_reference&lt;SourceType&gt;::type;
1667     using IteratorType = decltype(std::begin(std::declval&lt;RealSourceType&gt;()));
1668     using SourceItemType = typename std::iterator_traits&lt;IteratorType&gt;::value_type;
1669 };
1670 
1671 template&lt;typename MapFunction, typename SourceType, typename Enable = void&gt;
1672 struct Mapper {
1673     using SourceItemType = typename CollectionInspector&lt;SourceType&gt;::SourceItemType;
1674     using DestinationItemType = typename std::result_of&lt;MapFunction(SourceItemType&amp;)&gt;::type;
1675 
1676     static Vector&lt;DestinationItemType&gt; map(SourceType source, const MapFunction&amp; mapFunction)
1677     {
1678         Vector&lt;DestinationItemType&gt; result;
1679         // FIXME: Use std::size when available on all compilers.
1680         result.reserveInitialCapacity(source.size());
1681         for (auto&amp; item : source)
1682             result.uncheckedAppend(mapFunction(item));
1683         return result;
1684     }
1685 };
1686 
1687 template&lt;typename MapFunction, typename SourceType&gt;
1688 struct Mapper&lt;MapFunction, SourceType, typename std::enable_if&lt;std::is_rvalue_reference&lt;SourceType&amp;&amp;&gt;::value&gt;::type&gt; {
1689     using SourceItemType = typename CollectionInspector&lt;SourceType&gt;::SourceItemType;
1690     using DestinationItemType = typename std::result_of&lt;MapFunction(SourceItemType&amp;&amp;)&gt;::type;
1691 
1692     static Vector&lt;DestinationItemType&gt; map(SourceType&amp;&amp; source, const MapFunction&amp; mapFunction)
1693     {
1694         Vector&lt;DestinationItemType&gt; result;
1695         // FIXME: Use std::size when available on all compilers.
1696         result.reserveInitialCapacity(source.size());
1697         for (auto&amp; item : source)
1698             result.uncheckedAppend(mapFunction(WTFMove(item)));
1699         return result;
1700     }
1701 };
1702 
1703 template&lt;typename MapFunction, typename SourceType&gt;
1704 Vector&lt;typename Mapper&lt;MapFunction, SourceType&gt;::DestinationItemType&gt; map(SourceType&amp;&amp; source, MapFunction&amp;&amp; mapFunction)
1705 {
1706     return Mapper&lt;MapFunction, SourceType&gt;::map(std::forward&lt;SourceType&gt;(source), std::forward&lt;MapFunction&gt;(mapFunction));
1707 }
1708 
1709 template&lt;typename DestinationVector, typename Collection&gt;
1710 inline auto copyToVectorSpecialization(const Collection&amp; collection) -&gt; DestinationVector
1711 {
1712     DestinationVector result;
1713     // FIXME: Use std::size when available on all compilers.
1714     result.reserveInitialCapacity(collection.size());
1715     for (auto&amp; item : collection)
1716         result.uncheckedAppend(item);
1717     return result;
1718 }
1719 
1720 template&lt;typename DestinationItemType, typename Collection&gt;
1721 inline auto copyToVectorOf(const Collection&amp; collection) -&gt; Vector&lt;DestinationItemType&gt;
1722 {
1723     return WTF::map(collection, [] (const auto&amp; v) -&gt; DestinationItemType { return v; });
1724 }
1725 
1726 template&lt;typename Collection&gt;
1727 struct CopyToVectorResult {
1728     using Type = typename std::remove_cv&lt;typename CollectionInspector&lt;Collection&gt;::SourceItemType&gt;::type;
1729 };
1730 
1731 template&lt;typename Collection&gt;
1732 inline auto copyToVector(const Collection&amp; collection) -&gt; Vector&lt;typename CopyToVectorResult&lt;Collection&gt;::Type&gt;
1733 {
1734     return copyToVectorOf&lt;typename CopyToVectorResult&lt;Collection&gt;::Type&gt;(collection);
1735 }
1736 
1737 } // namespace WTF
1738 
1739 using WTF::UnsafeVectorOverflow;
1740 using WTF::Vector;
1741 using WTF::copyToVector;
1742 using WTF::copyToVectorOf;
1743 using WTF::copyToVectorSpecialization;
1744 using WTF::removeRepeatedElements;
    </pre>
  </body>
</html>
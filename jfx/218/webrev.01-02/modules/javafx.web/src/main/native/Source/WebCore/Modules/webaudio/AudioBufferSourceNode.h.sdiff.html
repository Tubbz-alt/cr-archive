<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webaudio/AudioBufferSourceNode.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AudioBufferSourceNode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AudioBufferSourceNode.idl.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webaudio/AudioBufferSourceNode.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 40     WTF_MAKE_ISO_ALLOCATED(AudioBufferSourceNode);
 41 public:
 42     static Ref&lt;AudioBufferSourceNode&gt; create(AudioContext&amp;, float sampleRate);
 43 
 44     virtual ~AudioBufferSourceNode();
 45 
 46     // AudioNode
 47     void process(size_t framesToProcess) final;
 48     void reset() final;
 49 
 50     // setBuffer() is called on the main thread.  This is the buffer we use for playback.
 51     // returns true on success.
 52     void setBuffer(RefPtr&lt;AudioBuffer&gt;&amp;&amp;);
 53     AudioBuffer* buffer() { return m_buffer.get(); }
 54 
 55     // numberOfChannels() returns the number of output channels.  This value equals the number of channels from the buffer.
 56     // If a new buffer is set with a different number of channels, then this value will dynamically change.
 57     unsigned numberOfChannels();
 58 
 59     // Play-state
<span class="line-modified"> 60     ExceptionOr&lt;void&gt; start(double when, double grainOffset, Optional&lt;double&gt; grainDuration);</span>
 61 
 62     // Note: the attribute was originally exposed as .looping, but to be more consistent in naming with &lt;audio&gt;
 63     // and with how it&#39;s described in the specification, the proper attribute name is .loop
 64     // The old attribute is kept for backwards compatibility.
 65     bool loop() const { return m_isLooping; }
 66     void setLoop(bool looping) { m_isLooping = looping; }
 67 
 68     // Loop times in seconds.
 69     double loopStart() const { return m_loopStart; }
 70     double loopEnd() const { return m_loopEnd; }
 71     void setLoopStart(double loopStart) { m_loopStart = loopStart; }
 72     void setLoopEnd(double loopEnd) { m_loopEnd = loopEnd; }
 73 
 74     // Deprecated.
 75     bool looping();
 76     void setLooping(bool);
 77 
 78     AudioParam* gain() { return m_gain.get(); }
 79     AudioParam* playbackRate() { return m_playbackRate.get(); }
 80 
 81     // If a panner node is set, then we can incorporate doppler shift into the playback pitch rate.
 82     void setPannerNode(PannerNode*);
 83     void clearPannerNode();
 84 
 85     // If we are no longer playing, propogate silence ahead to downstream nodes.
 86     bool propagatesSilence() const final;
 87 
 88     // AudioScheduledSourceNode
 89     void finish() final;
 90 


 91 private:
 92     AudioBufferSourceNode(AudioContext&amp;, float sampleRate);
 93 
 94     double tailTime() const final { return 0; }
 95     double latencyTime() const final { return 0; }
 96 
 97     enum BufferPlaybackMode {
 98         Entire,
 99         Partial
100     };
101 
102     ExceptionOr&lt;void&gt; startPlaying(BufferPlaybackMode, double when, double grainOffset, double grainDuration);
103 
104     // Returns true on success.
105     bool renderFromBuffer(AudioBus*, unsigned destinationFrameOffset, size_t numberOfFrames);
106 
107     // Render silence starting from &quot;index&quot; frame in AudioBus.
108     inline bool renderSilenceAndFinishIfNotLooping(AudioBus*, unsigned index, size_t framesToProcess);
109 
110     // m_buffer holds the sample data which this node outputs.
</pre>
</td>
<td>
<hr />
<pre>
 40     WTF_MAKE_ISO_ALLOCATED(AudioBufferSourceNode);
 41 public:
 42     static Ref&lt;AudioBufferSourceNode&gt; create(AudioContext&amp;, float sampleRate);
 43 
 44     virtual ~AudioBufferSourceNode();
 45 
 46     // AudioNode
 47     void process(size_t framesToProcess) final;
 48     void reset() final;
 49 
 50     // setBuffer() is called on the main thread.  This is the buffer we use for playback.
 51     // returns true on success.
 52     void setBuffer(RefPtr&lt;AudioBuffer&gt;&amp;&amp;);
 53     AudioBuffer* buffer() { return m_buffer.get(); }
 54 
 55     // numberOfChannels() returns the number of output channels.  This value equals the number of channels from the buffer.
 56     // If a new buffer is set with a different number of channels, then this value will dynamically change.
 57     unsigned numberOfChannels();
 58 
 59     // Play-state
<span class="line-modified"> 60     ExceptionOr&lt;void&gt; startLater(double when, double grainOffset, Optional&lt;double&gt; grainDuration);</span>
 61 
 62     // Note: the attribute was originally exposed as .looping, but to be more consistent in naming with &lt;audio&gt;
 63     // and with how it&#39;s described in the specification, the proper attribute name is .loop
 64     // The old attribute is kept for backwards compatibility.
 65     bool loop() const { return m_isLooping; }
 66     void setLoop(bool looping) { m_isLooping = looping; }
 67 
 68     // Loop times in seconds.
 69     double loopStart() const { return m_loopStart; }
 70     double loopEnd() const { return m_loopEnd; }
 71     void setLoopStart(double loopStart) { m_loopStart = loopStart; }
 72     void setLoopEnd(double loopEnd) { m_loopEnd = loopEnd; }
 73 
 74     // Deprecated.
 75     bool looping();
 76     void setLooping(bool);
 77 
 78     AudioParam* gain() { return m_gain.get(); }
 79     AudioParam* playbackRate() { return m_playbackRate.get(); }
 80 
 81     // If a panner node is set, then we can incorporate doppler shift into the playback pitch rate.
 82     void setPannerNode(PannerNode*);
 83     void clearPannerNode();
 84 
 85     // If we are no longer playing, propogate silence ahead to downstream nodes.
 86     bool propagatesSilence() const final;
 87 
 88     // AudioScheduledSourceNode
 89     void finish() final;
 90 
<span class="line-added"> 91     const char* activeDOMObjectName() const override { return &quot;AudioBufferSourceNode&quot;; }</span>
<span class="line-added"> 92 </span>
 93 private:
 94     AudioBufferSourceNode(AudioContext&amp;, float sampleRate);
 95 
 96     double tailTime() const final { return 0; }
 97     double latencyTime() const final { return 0; }
 98 
 99     enum BufferPlaybackMode {
100         Entire,
101         Partial
102     };
103 
104     ExceptionOr&lt;void&gt; startPlaying(BufferPlaybackMode, double when, double grainOffset, double grainDuration);
105 
106     // Returns true on success.
107     bool renderFromBuffer(AudioBus*, unsigned destinationFrameOffset, size_t numberOfFrames);
108 
109     // Render silence starting from &quot;index&quot; frame in AudioBus.
110     inline bool renderSilenceAndFinishIfNotLooping(AudioBus*, unsigned index, size_t framesToProcess);
111 
112     // m_buffer holds the sample data which this node outputs.
</pre>
</td>
</tr>
</table>
<center><a href="AudioBufferSourceNode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="AudioBufferSourceNode.idl.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSignature.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmSignature.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmSignatureInlines.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmSignature.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 50,84 ***</span>
  using SignatureArgCount = uint32_t;
  using SignatureIndex = uint64_t;
  
  class Signature : public ThreadSafeRefCounted&lt;Signature&gt; {
      WTF_MAKE_FAST_ALLOCATED;
<span class="line-removed">-     static const constexpr SignatureArgCount s_retCount = 1;</span>
  
      Signature() = delete;
      Signature(const Signature&amp;) = delete;
<span class="line-modified">!     Signature(SignatureArgCount argCount)</span>
<span class="line-modified">!         : m_argCount(argCount)</span>
      {
      }
  
      Type* storage(SignatureArgCount i)
      {
          return i + reinterpret_cast&lt;Type*&gt;(reinterpret_cast&lt;char*&gt;(this) + sizeof(Signature));
      }
      Type* storage(SignatureArgCount i) const { return const_cast&lt;Signature*&gt;(this)-&gt;storage(i); }
<span class="line-modified">!     static size_t allocatedSize(Checked&lt;SignatureArgCount&gt; argCount)</span>
      {
<span class="line-modified">!         return (sizeof(Signature) + (s_retCount + argCount) * sizeof(Type)).unsafeGet();</span>
      }
  
  public:
<span class="line-modified">!     Type&amp; returnType() { return *storage(0); }</span>
<span class="line-removed">-     Type returnType() const { return *storage(0); }</span>
<span class="line-removed">-     SignatureArgCount returnCount() const { return s_retCount; }</span>
      SignatureArgCount argumentCount() const { return m_argCount; }
<span class="line-modified">!     Type&amp; argument(SignatureArgCount i)</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         ASSERT(i &lt; argumentCount());</span>
<span class="line-modified">!         return *storage(returnCount() + i);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     Type argument(SignatureArgCount i) const { return const_cast&lt;Signature*&gt;(this)-&gt;argument(i); }</span>
      SignatureIndex index() const { return bitwise_cast&lt;SignatureIndex&gt;(this); }
  
      WTF::String toString() const;
      void dump(WTF::PrintStream&amp; out) const;
<span class="line-modified">!     bool operator==(const Signature&amp; rhs) const</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         if (argumentCount() != rhs.argumentCount())</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         if (returnType() != rhs.returnType())</span>
<span class="line-removed">-             return false;</span>
<span class="line-removed">-         for (unsigned i = 0; i &lt; argumentCount(); ++i) {</span>
<span class="line-removed">-             if (argument(i) != rhs.argument(i))</span>
<span class="line-removed">-                 return false;</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         return true;</span>
<span class="line-removed">-     }</span>
      unsigned hash() const;
  
<span class="line-removed">-     static RefPtr&lt;Signature&gt; tryCreate(SignatureArgCount);</span>
<span class="line-removed">- </span>
      // Signatures are uniqued and, for call_indirect, validated at runtime. Tables can create invalid SignatureIndex values which cause call_indirect to fail. We use 0 as the invalidIndex so that the codegen can easily test for it and trap, and we add a token invalid entry in SignatureInformation.
      static const constexpr SignatureIndex invalidIndex = 0;
  
  private:
      friend class SignatureInformation;
      SignatureArgCount m_argCount;
      // Return Type and arguments are stored here.
  };
  
  struct SignatureHash {
      RefPtr&lt;Signature&gt; key { nullptr };
      SignatureHash() = default;
      explicit SignatureHash(Ref&lt;Signature&gt;&amp;&amp; key)
          : key(WTFMove(key))
<span class="line-modified">!     {</span>
<span class="line-removed">-     }</span>
      explicit SignatureHash(WTF::HashTableDeletedValueType)
          : key(WTF::HashTableDeletedValue)
<span class="line-modified">!     {</span>
<span class="line-removed">-     }</span>
      bool operator==(const SignatureHash&amp; rhs) const { return equal(*this, rhs); }
<span class="line-modified">!     static bool equal(const SignatureHash&amp; lhs, const SignatureHash&amp; rhs) { return lhs.key == rhs.key || (lhs.key &amp;&amp; rhs.key &amp;&amp; *lhs.key == *rhs.key); }</span>
      static unsigned hash(const SignatureHash&amp; signature) { return signature.key ? signature.key-&gt;hash() : 0; }
<span class="line-modified">!     static const bool safeToCompareToEmptyOrDeleted = false;</span>
      bool isHashTableDeletedValue() const { return key.isHashTableDeletedValue(); }
  };
  
  } } // namespace JSC::Wasm
  
<span class="line-new-header">--- 50,72 ---</span>
  using SignatureArgCount = uint32_t;
  using SignatureIndex = uint64_t;
  
  class Signature : public ThreadSafeRefCounted&lt;Signature&gt; {
      WTF_MAKE_FAST_ALLOCATED;
  
      Signature() = delete;
      Signature(const Signature&amp;) = delete;
<span class="line-modified">!     Signature(SignatureArgCount retCount, SignatureArgCount argCount)</span>
<span class="line-modified">!         : m_retCount(retCount)</span>
<span class="line-added">+         , m_argCount(argCount)</span>
      {
      }
  
      Type* storage(SignatureArgCount i)
      {
          return i + reinterpret_cast&lt;Type*&gt;(reinterpret_cast&lt;char*&gt;(this) + sizeof(Signature));
      }
      Type* storage(SignatureArgCount i) const { return const_cast&lt;Signature*&gt;(this)-&gt;storage(i); }
<span class="line-modified">!     static size_t allocatedSize(Checked&lt;SignatureArgCount&gt; retCount, Checked&lt;SignatureArgCount&gt; argCount)</span>
      {
<span class="line-modified">!         return (sizeof(Signature) + (retCount + argCount) * sizeof(Type)).unsafeGet();</span>
      }
  
  public:
<span class="line-modified">!     SignatureArgCount returnCount() const { return m_retCount; }</span>
      SignatureArgCount argumentCount() const { return m_argCount; }
<span class="line-modified">! </span>
<span class="line-modified">!     Type returnType(SignatureArgCount i) const { ASSERT(i &lt; returnCount()); return const_cast&lt;Signature*&gt;(this)-&gt;getReturnType(i); }</span>
<span class="line-modified">!     bool returnsVoid() const { return !returnCount(); }</span>
<span class="line-modified">!     Type argument(SignatureArgCount i) const { return const_cast&lt;Signature*&gt;(this)-&gt;getArgument(i); }</span>
      SignatureIndex index() const { return bitwise_cast&lt;SignatureIndex&gt;(this); }
  
      WTF::String toString() const;
      void dump(WTF::PrintStream&amp; out) const;
<span class="line-modified">!     bool operator==(const Signature&amp; rhs) const { return this == &amp;rhs; }</span>
      unsigned hash() const;
  
      // Signatures are uniqued and, for call_indirect, validated at runtime. Tables can create invalid SignatureIndex values which cause call_indirect to fail. We use 0 as the invalidIndex so that the codegen can easily test for it and trap, and we add a token invalid entry in SignatureInformation.
      static const constexpr SignatureIndex invalidIndex = 0;
  
  private:
      friend class SignatureInformation;
<span class="line-added">+     friend struct ParameterTypes;</span>
<span class="line-added">+ </span>
<span class="line-added">+     static RefPtr&lt;Signature&gt; tryCreate(SignatureArgCount returnCount, SignatureArgCount argumentCount);</span>
<span class="line-added">+     Type&amp; getReturnType(SignatureArgCount i) { ASSERT(i &lt; returnCount()); return *storage(i); }</span>
<span class="line-added">+     Type&amp; getArgument(SignatureArgCount i) { ASSERT(i &lt; argumentCount()); return *storage(returnCount() + i); }</span>
<span class="line-added">+ </span>
<span class="line-added">+     SignatureArgCount m_retCount;</span>
      SignatureArgCount m_argCount;
      // Return Type and arguments are stored here.
  };
  
  struct SignatureHash {
      RefPtr&lt;Signature&gt; key { nullptr };
      SignatureHash() = default;
      explicit SignatureHash(Ref&lt;Signature&gt;&amp;&amp; key)
          : key(WTFMove(key))
<span class="line-modified">!     { }</span>
      explicit SignatureHash(WTF::HashTableDeletedValueType)
          : key(WTF::HashTableDeletedValue)
<span class="line-modified">!     { }</span>
      bool operator==(const SignatureHash&amp; rhs) const { return equal(*this, rhs); }
<span class="line-modified">!     static bool equal(const SignatureHash&amp; lhs, const SignatureHash&amp; rhs) { return lhs.key == rhs.key; }</span>
      static unsigned hash(const SignatureHash&amp; signature) { return signature.key ? signature.key-&gt;hash() : 0; }
<span class="line-modified">!     static constexpr bool safeToCompareToEmptyOrDeleted = false;</span>
      bool isHashTableDeletedValue() const { return key.isHashTableDeletedValue(); }
  };
  
  } } // namespace JSC::Wasm
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 139,36 ***</span>
      typedef JSC::Wasm::SignatureHash Hash;
  };
  
  template&lt;typename T&gt; struct HashTraits;
  template&lt;&gt; struct HashTraits&lt;JSC::Wasm::SignatureHash&gt; : SimpleClassHashTraits&lt;JSC::Wasm::SignatureHash&gt; {
<span class="line-modified">!     static const bool emptyValueIsZero = true;</span>
  };
  
  } // namespace WTF
  
  
  namespace JSC { namespace Wasm {
  
  // Signature information is held globally and shared by the entire process to allow all signatures to be unique. This is required when wasm calls another wasm instance, and must work when modules are shared between multiple VMs.
<span class="line-removed">- // Note: signatures are never removed because that would require accounting for all WebAssembly.Module and which signatures they use. The maximum number of signatures is bounded, and isn&#39;t worth the counting overhead. We could clear everything when we reach zero outstanding WebAssembly.Module. https://bugs.webkit.org/show_bug.cgi?id=166037</span>
  class SignatureInformation {
      WTF_MAKE_NONCOPYABLE(SignatureInformation);
      WTF_MAKE_FAST_ALLOCATED;
  
      SignatureInformation();
  
  public:
      static SignatureInformation&amp; singleton();
  
<span class="line-modified">!     static Ref&lt;Signature&gt; WARN_UNUSED_RETURN adopt(Ref&lt;Signature&gt;&amp;&amp;);</span>
<span class="line-modified">!     static const Signature&amp; WARN_UNUSED_RETURN get(SignatureIndex);</span>
<span class="line-modified">!     static SignatureIndex WARN_UNUSED_RETURN get(const Signature&amp;);</span>
      static void tryCleanup();
  
  private:
      HashSet&lt;Wasm::SignatureHash&gt; m_signatureSet;
      Lock m_lock;
  
      JS_EXPORT_PRIVATE static SignatureInformation* theOne;
      JS_EXPORT_PRIVATE static std::once_flag signatureInformationFlag;
  };
<span class="line-new-header">--- 127,38 ---</span>
      typedef JSC::Wasm::SignatureHash Hash;
  };
  
  template&lt;typename T&gt; struct HashTraits;
  template&lt;&gt; struct HashTraits&lt;JSC::Wasm::SignatureHash&gt; : SimpleClassHashTraits&lt;JSC::Wasm::SignatureHash&gt; {
<span class="line-modified">!     static constexpr bool emptyValueIsZero = true;</span>
  };
  
  } // namespace WTF
  
  
  namespace JSC { namespace Wasm {
  
  // Signature information is held globally and shared by the entire process to allow all signatures to be unique. This is required when wasm calls another wasm instance, and must work when modules are shared between multiple VMs.
  class SignatureInformation {
      WTF_MAKE_NONCOPYABLE(SignatureInformation);
      WTF_MAKE_FAST_ALLOCATED;
  
      SignatureInformation();
  
  public:
      static SignatureInformation&amp; singleton();
  
<span class="line-modified">!     static RefPtr&lt;Signature&gt; signatureFor(const Vector&lt;Type, 1&gt;&amp; returnTypes, const Vector&lt;Type&gt;&amp; argumentTypes);</span>
<span class="line-modified">!     ALWAYS_INLINE const Signature* thunkFor(Type type) const { return thunkSignatures[linearizeType(type)]; }</span>
<span class="line-modified">! </span>
<span class="line-added">+     static const Signature&amp; get(SignatureIndex);</span>
<span class="line-added">+     static SignatureIndex get(const Signature&amp;);</span>
      static void tryCleanup();
  
  private:
      HashSet&lt;Wasm::SignatureHash&gt; m_signatureSet;
<span class="line-added">+     const Signature* thunkSignatures[numTypes];</span>
      Lock m_lock;
  
      JS_EXPORT_PRIVATE static SignatureInformation* theOne;
      JS_EXPORT_PRIVATE static std::once_flag signatureInformationFlag;
  };
</pre>
<center><a href="WasmSignature.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmSignatureInlines.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
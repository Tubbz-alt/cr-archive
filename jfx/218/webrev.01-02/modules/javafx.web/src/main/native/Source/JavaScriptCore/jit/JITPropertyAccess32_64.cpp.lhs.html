<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITPropertyAccess32_64.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 
  28 #if ENABLE(JIT)
  29 #if USE(JSVALUE32_64)
  30 #include &quot;JIT.h&quot;
  31 
  32 #include &quot;CodeBlock.h&quot;
  33 #include &quot;DirectArguments.h&quot;
  34 #include &quot;GCAwareJITStubRoutine.h&quot;
  35 #include &quot;InterpreterInlines.h&quot;
  36 #include &quot;JITInlines.h&quot;
  37 #include &quot;JSArray.h&quot;
  38 #include &quot;JSFunction.h&quot;
  39 #include &quot;JSLexicalEnvironment.h&quot;
  40 #include &quot;LinkBuffer.h&quot;
  41 #include &quot;OpcodeInlines.h&quot;
  42 #include &quot;ResultType.h&quot;
  43 #include &quot;SlowPathCall.h&quot;
  44 #include &quot;StructureStubInfo.h&quot;
  45 #include &lt;wtf/StringPrintStream.h&gt;
  46 
  47 
  48 namespace JSC {
  49 
  50 void JIT::emit_op_put_getter_by_id(const Instruction* currentInstruction)
  51 {
  52     auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterById&gt;();
<a name="1" id="anc1"></a><span class="line-modified">  53     int base = bytecode.m_base.offset();</span>
  54     int property = bytecode.m_property;
  55     int options = bytecode.m_attributes;
<a name="2" id="anc2"></a><span class="line-modified">  56     int getter = bytecode.m_accessor.offset();</span>
  57 
  58     emitLoadPayload(base, regT1);
  59     emitLoadPayload(getter, regT3);
<a name="3" id="anc3"></a><span class="line-modified">  60     callOperation(operationPutGetterById, regT1, m_codeBlock-&gt;identifier(property).impl(), options, regT3);</span>
  61 }
  62 
  63 void JIT::emit_op_put_setter_by_id(const Instruction* currentInstruction)
  64 {
  65     auto bytecode = currentInstruction-&gt;as&lt;OpPutSetterById&gt;();
<a name="4" id="anc4"></a><span class="line-modified">  66     int base = bytecode.m_base.offset();</span>
  67     int property = bytecode.m_property;
  68     int options = bytecode.m_attributes;
<a name="5" id="anc5"></a><span class="line-modified">  69     int setter = bytecode.m_accessor.offset();</span>
  70 
  71     emitLoadPayload(base, regT1);
  72     emitLoadPayload(setter, regT3);
<a name="6" id="anc6"></a><span class="line-modified">  73     callOperation(operationPutSetterById, regT1, m_codeBlock-&gt;identifier(property).impl(), options, regT3);</span>
  74 }
  75 
  76 void JIT::emit_op_put_getter_setter_by_id(const Instruction* currentInstruction)
  77 {
  78     auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterSetterById&gt;();
<a name="7" id="anc7"></a><span class="line-modified">  79     int base = bytecode.m_base.offset();</span>
  80     int property = bytecode.m_property;
  81     int attributes = bytecode.m_attributes;
<a name="8" id="anc8"></a><span class="line-modified">  82     int getter = bytecode.m_getter.offset();</span>
<span class="line-modified">  83     int setter = bytecode.m_setter.offset();</span>
  84 
  85     emitLoadPayload(base, regT1);
  86     emitLoadPayload(getter, regT3);
  87     emitLoadPayload(setter, regT4);
<a name="9" id="anc9"></a><span class="line-modified">  88     callOperation(operationPutGetterSetter, regT1, m_codeBlock-&gt;identifier(property).impl(), attributes, regT3, regT4);</span>
  89 }
  90 
  91 void JIT::emit_op_put_getter_by_val(const Instruction* currentInstruction)
  92 {
  93     auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterByVal&gt;();
<a name="10" id="anc10"></a><span class="line-modified">  94     int base = bytecode.m_base.offset();</span>
<span class="line-modified">  95     int property = bytecode.m_property.offset();</span>
  96     int32_t attributes = bytecode.m_attributes;
<a name="11" id="anc11"></a><span class="line-modified">  97     int getter = bytecode.m_accessor.offset();</span>
  98 
  99     emitLoadPayload(base, regT2);
 100     emitLoad(property, regT1, regT0);
 101     emitLoadPayload(getter, regT3);
<a name="12" id="anc12"></a><span class="line-modified"> 102     callOperation(operationPutGetterByVal, regT2, JSValueRegs(regT1, regT0), attributes, regT3);</span>
 103 }
 104 
 105 void JIT::emit_op_put_setter_by_val(const Instruction* currentInstruction)
 106 {
 107     auto bytecode = currentInstruction-&gt;as&lt;OpPutSetterByVal&gt;();
<a name="13" id="anc13"></a><span class="line-modified"> 108     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 109     int property = bytecode.m_property.offset();</span>
 110     int32_t attributes = bytecode.m_attributes;
<a name="14" id="anc14"></a><span class="line-modified"> 111     int setter = bytecode.m_accessor.offset();</span>
 112 
 113     emitLoadPayload(base, regT2);
 114     emitLoad(property, regT1, regT0);
 115     emitLoadPayload(setter, regT3);
<a name="15" id="anc15"></a><span class="line-modified"> 116     callOperation(operationPutSetterByVal, regT2, JSValueRegs(regT1, regT0), attributes, regT3);</span>
 117 }
 118 
 119 void JIT::emit_op_del_by_id(const Instruction* currentInstruction)
 120 {
 121     auto bytecode = currentInstruction-&gt;as&lt;OpDelById&gt;();
<a name="16" id="anc16"></a><span class="line-modified"> 122     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 123     int base = bytecode.m_base.offset();</span>
 124     int property = bytecode.m_property;
 125     emitLoad(base, regT1, regT0);
<a name="17" id="anc17"></a><span class="line-modified"> 126     callOperation(operationDeleteByIdJSResult, dst, JSValueRegs(regT1, regT0), m_codeBlock-&gt;identifier(property).impl());</span>
 127 }
 128 
 129 void JIT::emit_op_del_by_val(const Instruction* currentInstruction)
 130 {
 131     auto bytecode = currentInstruction-&gt;as&lt;OpDelByVal&gt;();
<a name="18" id="anc18"></a><span class="line-modified"> 132     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 133     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 134     int property = bytecode.m_property.offset();</span>
 135     emitLoad2(base, regT1, regT0, property, regT3, regT2);
<a name="19" id="anc19"></a><span class="line-modified"> 136     callOperation(operationDeleteByValJSResult, dst, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2));</span>
 137 }
 138 
 139 void JIT::emit_op_get_by_val(const Instruction* currentInstruction)
 140 {
 141     auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();
 142     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<a name="20" id="anc20"></a><span class="line-modified"> 143     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 144     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 145     int property = bytecode.m_property.offset();</span>
 146     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
<a name="21" id="anc21"></a><span class="line-removed"> 147     ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();</span>
 148 
 149     emitLoad2(base, regT1, regT0, property, regT3, regT2);
 150 
<a name="22" id="anc22"></a><span class="line-modified"> 151     emitJumpSlowCaseIfNotJSCell(base, regT1);</span>
<span class="line-modified"> 152     PatchableJump notIndex = patchableBranch32(NotEqual, regT3, TrustedImm32(JSValue::Int32Tag));</span>
<span class="line-modified"> 153     addSlowCase(notIndex);</span>
<span class="line-modified"> 154     emitArrayProfilingSiteWithCell(regT0, regT1, profile);</span>
<span class="line-modified"> 155     and32(TrustedImm32(IndexingShapeMask), regT1);</span>
<span class="line-modified"> 156 </span>
<span class="line-modified"> 157     PatchableJump badType;</span>
<span class="line-modified"> 158     JumpList slowCases;</span>
<span class="line-modified"> 159 </span>
<span class="line-modified"> 160     JITArrayMode mode = chooseArrayMode(profile);</span>
<span class="line-modified"> 161     switch (mode) {</span>
<span class="line-modified"> 162     case JITInt32:</span>
<span class="line-modified"> 163         slowCases = emitInt32GetByVal(currentInstruction, badType);</span>
<span class="line-modified"> 164         break;</span>
<span class="line-modified"> 165     case JITDouble:</span>
<span class="line-modified"> 166         slowCases = emitDoubleGetByVal(currentInstruction, badType);</span>
<span class="line-modified"> 167         break;</span>
<span class="line-modified"> 168     case JITContiguous:</span>
<span class="line-modified"> 169         slowCases = emitContiguousGetByVal(currentInstruction, badType);</span>
<span class="line-modified"> 170         break;</span>
<span class="line-removed"> 171     case JITArrayStorage:</span>
<span class="line-removed"> 172         slowCases = emitArrayStorageGetByVal(currentInstruction, badType);</span>
<span class="line-removed"> 173         break;</span>
<span class="line-removed"> 174     default:</span>
<span class="line-removed"> 175         CRASH();</span>
<span class="line-removed"> 176     }</span>
<span class="line-removed"> 177 </span>
<span class="line-removed"> 178     addSlowCase(badType);</span>
<span class="line-removed"> 179     addSlowCase(slowCases);</span>
<span class="line-removed"> 180 </span>
<span class="line-removed"> 181     Label done = label();</span>
<span class="line-removed"> 182 </span>
<span class="line-removed"> 183     if (!ASSERT_DISABLED) {</span>
<span class="line-removed"> 184         Jump resultOK = branchIfNotEmpty(regT1);</span>
<span class="line-removed"> 185         abortWithReason(JITGetByValResultIsNotEmpty);</span>
<span class="line-removed"> 186         resultOK.link(this);</span>
 187     }
<a name="23" id="anc23"></a><span class="line-removed"> 188 </span>
<span class="line-removed"> 189     emitValueProfilingSite(bytecode.metadata(m_codeBlock));</span>
<span class="line-removed"> 190     emitStore(dst, regT1, regT0);</span>
<span class="line-removed"> 191 </span>
<span class="line-removed"> 192     Label nextHotPath = label();</span>
<span class="line-removed"> 193 </span>
<span class="line-removed"> 194     m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeOffset, notIndex, badType, mode, profile, done, nextHotPath));</span>
<span class="line-removed"> 195 }</span>
<span class="line-removed"> 196 </span>
<span class="line-removed"> 197 JITGetByIdGenerator JIT::emitGetByValWithCachedId(ByValInfo* byValInfo, OpGetByVal bytecode, const Identifier&amp; propertyName, Jump&amp; fastDoneCase, Jump&amp; slowDoneCase, JumpList&amp; slowCases)</span>
<span class="line-removed"> 198 {</span>
<span class="line-removed"> 199     // base: tag(regT1), payload(regT0)</span>
<span class="line-removed"> 200     // property: tag(regT3), payload(regT2)</span>
<span class="line-removed"> 201     // scratch: regT4</span>
<span class="line-removed"> 202 </span>
<span class="line-removed"> 203     int dst = bytecode.m_dst.offset();</span>
<span class="line-removed"> 204 </span>
<span class="line-removed"> 205     slowCases.append(branchIfNotCell(regT3));</span>
<span class="line-removed"> 206     emitByValIdentifierCheck(byValInfo, regT2, regT4, propertyName, slowCases);</span>
<span class="line-removed"> 207 </span>
<span class="line-removed"> 208     const Instruction* currentInstruction = m_codeBlock-&gt;instructions().at(byValInfo-&gt;bytecodeIndex).ptr();</span>
<span class="line-removed"> 209     JITGetByIdGenerator gen(</span>
<span class="line-removed"> 210         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-removed"> 211         propertyName.impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::Get);</span>
<span class="line-removed"> 212     gen.generateFastPath(*this);</span>
<span class="line-removed"> 213 </span>
<span class="line-removed"> 214     fastDoneCase = jump();</span>
<span class="line-removed"> 215 </span>
<span class="line-removed"> 216     Label coldPathBegin = label();</span>
<span class="line-removed"> 217     gen.slowPathJump().link(this);</span>
<span class="line-removed"> 218 </span>
<span class="line-removed"> 219     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdOptimize, dst, gen.stubInfo(), JSValueRegs(regT1, regT0), propertyName.impl());</span>
<span class="line-removed"> 220     gen.reportSlowPathCall(coldPathBegin, call);</span>
<span class="line-removed"> 221     slowDoneCase = jump();</span>
<span class="line-removed"> 222 </span>
<span class="line-removed"> 223     return gen;</span>
 224 }
 225 
 226 void JIT::emitSlow_op_get_by_val(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 227 {
<a name="24" id="anc24"></a><span class="line-modified"> 228     auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();</span>
<span class="line-modified"> 229     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 230     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 231     int property = bytecode.m_property.offset();</span>
<span class="line-modified"> 232     ByValInfo* byValInfo = m_byValCompilationInfo[m_byValInstructionIndex].byValInfo;</span>
<span class="line-removed"> 233 </span>
<span class="line-removed"> 234     linkSlowCaseIfNotJSCell(iter, base); // base cell check</span>
<span class="line-removed"> 235     linkSlowCase(iter); // property int32 check</span>
<span class="line-removed"> 236 </span>
<span class="line-removed"> 237     Jump nonCell = jump();</span>
<span class="line-removed"> 238     linkSlowCase(iter); // base array check</span>
<span class="line-removed"> 239     Jump notString = branchIfNotString(regT0);</span>
<span class="line-removed"> 240     emitNakedCall(CodeLocationLabel&lt;NoPtrTag&gt;(m_vm-&gt;getCTIStub(stringGetByValGenerator).retaggedCode&lt;NoPtrTag&gt;()));</span>
<span class="line-removed"> 241     Jump failed = branchTestPtr(Zero, regT0);</span>
<span class="line-removed"> 242     emitStoreCell(dst, regT0);</span>
<span class="line-removed"> 243     emitJumpSlowToHot(jump(), currentInstruction-&gt;size());</span>
<span class="line-removed"> 244     failed.link(this);</span>
<span class="line-removed"> 245     notString.link(this);</span>
<span class="line-removed"> 246     nonCell.link(this);</span>
<span class="line-removed"> 247 </span>
<span class="line-removed"> 248     linkSlowCase(iter); // vector length check</span>
<span class="line-removed"> 249     linkSlowCase(iter); // empty value</span>
<span class="line-removed"> 250 </span>
<span class="line-removed"> 251     Label slowPath = label();</span>
 252 
<a name="25" id="anc25"></a><span class="line-modified"> 253     emitLoad(base, regT1, regT0);</span>
<span class="line-modified"> 254     emitLoad(property, regT3, regT2);</span>
<span class="line-removed"> 255     Call call = callOperation(operationGetByValOptimize, dst, JSValueRegs(regT1, regT0), JSValueRegs(regT3, regT2), byValInfo);</span>
 256 
<a name="26" id="anc26"></a><span class="line-modified"> 257     m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;</span>
<span class="line-removed"> 258     m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;</span>
<span class="line-removed"> 259     m_byValInstructionIndex++;</span>
 260 
<a name="27" id="anc27"></a><span class="line-modified"> 261     emitValueProfilingSite(bytecode.metadata(m_codeBlock));</span>



 262 }
 263 
 264 void JIT::emit_op_put_by_val_direct(const Instruction* currentInstruction)
 265 {
 266     emit_op_put_by_val&lt;OpPutByValDirect&gt;(currentInstruction);
 267 }
 268 
 269 template&lt;typename Op&gt;
 270 void JIT::emit_op_put_by_val(const Instruction* currentInstruction)
 271 {
 272     auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
 273     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<a name="28" id="anc28"></a><span class="line-modified"> 274     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 275     int property = bytecode.m_property.offset();</span>
 276     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
 277     ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
 278 
 279     emitLoad2(base, regT1, regT0, property, regT3, regT2);
 280 
 281     emitJumpSlowCaseIfNotJSCell(base, regT1);
 282     PatchableJump notIndex = patchableBranch32(NotEqual, regT3, TrustedImm32(JSValue::Int32Tag));
 283     addSlowCase(notIndex);
 284     emitArrayProfilingSiteWithCell(regT0, regT1, profile);
 285 
 286     PatchableJump badType;
 287     JumpList slowCases;
 288 
 289     // FIXME: Maybe we should do this inline?
 290     addSlowCase(branchTest32(NonZero, regT1, TrustedImm32(CopyOnWrite)));
 291     and32(TrustedImm32(IndexingShapeMask), regT1);
 292 
 293     JITArrayMode mode = chooseArrayMode(profile);
 294     switch (mode) {
 295     case JITInt32:
 296         slowCases = emitInt32PutByVal(bytecode, badType);
 297         break;
 298     case JITDouble:
 299         slowCases = emitDoublePutByVal(bytecode, badType);
 300         break;
 301     case JITContiguous:
 302         slowCases = emitContiguousPutByVal(bytecode, badType);
 303         break;
 304     case JITArrayStorage:
 305         slowCases = emitArrayStoragePutByVal(bytecode, badType);
 306         break;
 307     default:
 308         CRASH();
 309         break;
 310     }
 311 
 312     addSlowCase(badType);
 313     addSlowCase(slowCases);
 314 
 315     Label done = label();
 316 
<a name="29" id="anc29"></a><span class="line-modified"> 317     m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeOffset, notIndex, badType, mode, profile, done, done));</span>
 318 }
 319 
 320 template &lt;typename Op&gt;
 321 JIT::JumpList JIT::emitGenericContiguousPutByVal(Op bytecode, PatchableJump&amp; badType, IndexingType indexingShape)
 322 {
 323     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<a name="30" id="anc30"></a><span class="line-modified"> 324     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 325     int value = bytecode.m_value.offset();</span>
 326     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
 327 
 328     JumpList slowCases;
 329 
 330     badType = patchableBranch32(NotEqual, regT1, TrustedImm32(ContiguousShape));
 331 
 332     loadPtr(Address(regT0, JSObject::butterflyOffset()), regT3);
 333     Jump outOfBounds = branch32(AboveOrEqual, regT2, Address(regT3, Butterfly::offsetOfPublicLength()));
 334 
 335     Label storeResult = label();
 336     emitLoad(value, regT1, regT0);
 337     switch (indexingShape) {
 338     case Int32Shape:
 339         slowCases.append(branchIfNotInt32(regT1));
 340         store32(regT0, BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
 341         store32(regT1, BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
 342         break;
 343     case ContiguousShape:
 344         store32(regT0, BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload)));
 345         store32(regT1, BaseIndex(regT3, regT2, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag)));
 346         emitLoad(base, regT2, regT3);
 347         emitWriteBarrier(base, value, ShouldFilterValue);
 348         break;
 349     case DoubleShape: {
 350         Jump notInt = branchIfNotInt32(regT1);
 351         convertInt32ToDouble(regT0, fpRegT0);
 352         Jump ready = jump();
 353         notInt.link(this);
 354         moveIntsToDouble(regT0, regT1, fpRegT0, fpRegT1);
 355         slowCases.append(branchIfNaN(fpRegT0));
 356         ready.link(this);
 357         storeDouble(fpRegT0, BaseIndex(regT3, regT2, TimesEight));
 358         break;
 359     }
 360     default:
 361         CRASH();
 362         break;
 363     }
 364 
 365     Jump done = jump();
 366 
 367     outOfBounds.link(this);
 368     slowCases.append(branch32(AboveOrEqual, regT2, Address(regT3, Butterfly::offsetOfVectorLength())));
 369 
 370     emitArrayProfileStoreToHoleSpecialCase(profile);
 371 
 372     add32(TrustedImm32(1), regT2, regT1);
 373     store32(regT1, Address(regT3, Butterfly::offsetOfPublicLength()));
 374     jump().linkTo(storeResult, this);
 375 
 376     done.link(this);
 377 
 378     return slowCases;
 379 }
 380 
 381 template &lt;typename Op&gt;
 382 JIT::JumpList JIT::emitArrayStoragePutByVal(Op bytecode, PatchableJump&amp; badType)
 383 {
 384     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<a name="31" id="anc31"></a><span class="line-modified"> 385     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 386     int value = bytecode.m_value.offset();</span>
 387     ArrayProfile* profile = &amp;metadata.m_arrayProfile;
 388 
 389     JumpList slowCases;
 390 
 391     badType = patchableBranch32(NotEqual, regT1, TrustedImm32(ArrayStorageShape));
 392 
 393     loadPtr(Address(regT0, JSObject::butterflyOffset()), regT3);
 394     slowCases.append(branch32(AboveOrEqual, regT2, Address(regT3, ArrayStorage::vectorLengthOffset())));
 395 
 396     Jump empty = branch32(Equal, BaseIndex(regT3, regT2, TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag)), TrustedImm32(JSValue::EmptyValueTag));
 397 
 398     Label storeResult(this);
 399     emitLoad(value, regT1, regT0);
 400     store32(regT0, BaseIndex(regT3, regT2, TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.payload))); // payload
 401     store32(regT1, BaseIndex(regT3, regT2, TimesEight, ArrayStorage::vectorOffset() + OBJECT_OFFSETOF(JSValue, u.asBits.tag))); // tag
 402     Jump end = jump();
 403 
 404     empty.link(this);
 405     emitArrayProfileStoreToHoleSpecialCase(profile);
 406     add32(TrustedImm32(1), Address(regT3, OBJECT_OFFSETOF(ArrayStorage, m_numValuesInVector)));
 407     branch32(Below, regT2, Address(regT3, ArrayStorage::lengthOffset())).linkTo(storeResult, this);
 408 
 409     add32(TrustedImm32(1), regT2, regT0);
 410     store32(regT0, Address(regT3, ArrayStorage::lengthOffset()));
 411     jump().linkTo(storeResult, this);
 412 
 413     end.link(this);
 414 
 415     emitWriteBarrier(base, value, ShouldFilterValue);
 416 
 417     return slowCases;
 418 }
 419 
 420 template &lt;typename Op&gt;
 421 JITPutByIdGenerator JIT::emitPutByValWithCachedId(ByValInfo* byValInfo, Op bytecode, PutKind putKind, const Identifier&amp; propertyName, JumpList&amp; doneCases, JumpList&amp; slowCases)
 422 {
 423     // base: tag(regT1), payload(regT0)
 424     // property: tag(regT3), payload(regT2)
 425 
<a name="32" id="anc32"></a><span class="line-modified"> 426     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 427     int value = bytecode.m_value.offset();</span>
 428 
 429     slowCases.append(branchIfNotCell(regT3));
 430     emitByValIdentifierCheck(byValInfo, regT2, regT2, propertyName, slowCases);
 431 
 432     // Write barrier breaks the registers. So after issuing the write barrier,
 433     // reload the registers.
 434     emitWriteBarrier(base, value, ShouldFilterBase);
 435     emitLoadPayload(base, regT0);
 436     emitLoad(value, regT3, regT2);
 437 
<a name="33" id="anc33"></a><span class="line-removed"> 438     const Instruction* currentInstruction = m_codeBlock-&gt;instructions().at(byValInfo-&gt;bytecodeIndex).ptr();</span>
 439     JITPutByIdGenerator gen(
<a name="34" id="anc34"></a><span class="line-modified"> 440         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
 441         JSValueRegs::payloadOnly(regT0), JSValueRegs(regT3, regT2), regT1, m_codeBlock-&gt;ecmaMode(), putKind);
 442     gen.generateFastPath(*this);
 443     doneCases.append(jump());
 444 
 445     Label coldPathBegin = label();
 446     gen.slowPathJump().link(this);
 447 
 448     // JITPutByIdGenerator only preserve the value and the base&#39;s payload, we have to reload the tag.
 449     emitLoadTag(base, regT1);
 450 
<a name="35" id="anc35"></a><span class="line-modified"> 451     Call call = callOperation(gen.slowPathFunction(), gen.stubInfo(), JSValueRegs(regT3, regT2), JSValueRegs(regT1, regT0), propertyName.impl());</span>
 452     gen.reportSlowPathCall(coldPathBegin, call);
 453     doneCases.append(jump());
 454 
 455     return gen;
 456 }
 457 
 458 void JIT::emitSlow_op_put_by_val(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 459 {
 460     bool isDirect = currentInstruction-&gt;opcodeID() == op_put_by_val_direct;
<a name="36" id="anc36"></a><span class="line-modified"> 461     int base;</span>
<span class="line-modified"> 462     int property;</span>
<span class="line-modified"> 463     int value;</span>
 464 
 465     auto load = [&amp;](auto bytecode) {
<a name="37" id="anc37"></a><span class="line-modified"> 466         base = bytecode.m_base.offset();</span>
<span class="line-modified"> 467         property = bytecode.m_property.offset();</span>
<span class="line-modified"> 468         value = bytecode.m_value.offset();</span>
 469     };
 470 
 471     if (isDirect)
 472         load(currentInstruction-&gt;as&lt;OpPutByValDirect&gt;());
 473     else
 474         load(currentInstruction-&gt;as&lt;OpPutByVal&gt;());
 475 
 476     ByValInfo* byValInfo = m_byValCompilationInfo[m_byValInstructionIndex].byValInfo;
 477 
 478     linkAllSlowCases(iter);
 479     Label slowPath = label();
 480 
 481     // The register selection below is chosen to reduce register swapping on ARM.
 482     // Swapping shouldn&#39;t happen on other platforms.
 483     emitLoad(base, regT2, regT1);
 484     emitLoad(property, regT3, regT0);
 485     emitLoad(value, regT5, regT4);
<a name="38" id="anc38"></a><span class="line-modified"> 486     Call call = callOperation(isDirect ? operationDirectPutByValOptimize : operationPutByValOptimize, JSValueRegs(regT2, regT1), JSValueRegs(regT3, regT0), JSValueRegs(regT5, regT4), byValInfo);</span>
 487 
 488     m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;
 489     m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;
 490     m_byValInstructionIndex++;
 491 }
 492 
 493 void JIT::emit_op_try_get_by_id(const Instruction* currentInstruction)
 494 {
 495     auto bytecode = currentInstruction-&gt;as&lt;OpTryGetById&gt;();
<a name="39" id="anc39"></a><span class="line-modified"> 496     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 497     int base = bytecode.m_base.offset();</span>
 498     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 499 
 500     emitLoad(base, regT1, regT0);
 501     emitJumpSlowCaseIfNotJSCell(base, regT1);
 502 
 503     JITGetByIdGenerator gen(
<a name="40" id="anc40"></a><span class="line-modified"> 504         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified"> 505         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::TryGet);</span>
 506     gen.generateFastPath(*this);
 507     addSlowCase(gen.slowPathJump());
 508     m_getByIds.append(gen);
 509 
 510     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 511     emitStore(dst, regT1, regT0);
 512 }
 513 
 514 void JIT::emitSlow_op_try_get_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 515 {
 516     linkAllSlowCases(iter);
 517 
 518     auto bytecode = currentInstruction-&gt;as&lt;OpTryGetById&gt;();
<a name="41" id="anc41"></a><span class="line-modified"> 519     int resultVReg = bytecode.m_dst.offset();</span>
 520     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 521 
 522     JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
 523 
 524     Label coldPathBegin = label();
 525 
<a name="42" id="anc42"></a><span class="line-modified"> 526     Call call = callOperation(operationTryGetByIdOptimize, resultVReg, gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
 527 
 528     gen.reportSlowPathCall(coldPathBegin, call);
 529 }
 530 
 531 
 532 void JIT::emit_op_get_by_id_direct(const Instruction* currentInstruction)
 533 {
 534     auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdDirect&gt;();
<a name="43" id="anc43"></a><span class="line-modified"> 535     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 536     int base = bytecode.m_base.offset();</span>
 537     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 538 
 539     emitLoad(base, regT1, regT0);
 540     emitJumpSlowCaseIfNotJSCell(base, regT1);
 541 
 542     JITGetByIdGenerator gen(
<a name="44" id="anc44"></a><span class="line-modified"> 543         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified"> 544         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::GetDirect);</span>
 545     gen.generateFastPath(*this);
 546     addSlowCase(gen.slowPathJump());
 547     m_getByIds.append(gen);
 548 
 549     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 550     emitStore(dst, regT1, regT0);
 551 }
 552 
 553 void JIT::emitSlow_op_get_by_id_direct(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 554 {
 555     linkAllSlowCases(iter);
 556 
 557     auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdDirect&gt;();
<a name="45" id="anc45"></a><span class="line-modified"> 558     int resultVReg = bytecode.m_dst.offset();</span>
 559     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 560 
 561     JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
 562 
 563     Label coldPathBegin = label();
 564 
<a name="46" id="anc46"></a><span class="line-modified"> 565     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdDirectOptimize, resultVReg, gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
 566 
 567     gen.reportSlowPathCall(coldPathBegin, call);
 568 }
 569 
 570 
 571 void JIT::emit_op_get_by_id(const Instruction* currentInstruction)
 572 {
 573     auto bytecode = currentInstruction-&gt;as&lt;OpGetById&gt;();
 574     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<a name="47" id="anc47"></a><span class="line-modified"> 575     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 576     int base = bytecode.m_base.offset();</span>
 577     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 578 
 579     emitLoad(base, regT1, regT0);
 580     emitJumpSlowCaseIfNotJSCell(base, regT1);
 581 
 582     if (*ident == m_vm-&gt;propertyNames-&gt;length &amp;&amp; shouldEmitProfiling()) {
 583         Jump notArrayLengthMode = branch8(NotEqual, AbsoluteAddress(&amp;metadata.m_modeMetadata.mode), TrustedImm32(static_cast&lt;uint8_t&gt;(GetByIdMode::ArrayLength)));
 584         emitArrayProfilingSiteWithCell(regT0, regT2, &amp;metadata.m_modeMetadata.arrayLengthMode.arrayProfile);
 585         notArrayLengthMode.link(this);
 586     }
 587 
 588     JITGetByIdGenerator gen(
<a name="48" id="anc48"></a><span class="line-modified"> 589         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified"> 590         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0), AccessType::Get);</span>
 591     gen.generateFastPath(*this);
 592     addSlowCase(gen.slowPathJump());
 593     m_getByIds.append(gen);
 594 
 595     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 596     emitStore(dst, regT1, regT0);
 597 }
 598 
 599 void JIT::emitSlow_op_get_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 600 {
 601     linkAllSlowCases(iter);
 602 
 603     auto bytecode = currentInstruction-&gt;as&lt;OpGetById&gt;();
<a name="49" id="anc49"></a><span class="line-modified"> 604     int resultVReg = bytecode.m_dst.offset();</span>
 605     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 606 
 607     JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
 608 
 609     Label coldPathBegin = label();
 610 
<a name="50" id="anc50"></a><span class="line-modified"> 611     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdOptimize, resultVReg, gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
 612 
 613     gen.reportSlowPathCall(coldPathBegin, call);
 614 }
 615 
 616 void JIT::emit_op_get_by_id_with_this(const Instruction* currentInstruction)
 617 {
 618     auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdWithThis&gt;();
<a name="51" id="anc51"></a><span class="line-modified"> 619     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 620     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 621     int thisVReg = bytecode.m_thisValue.offset();</span>
 622     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 623 
 624     emitLoad(base, regT1, regT0);
 625     emitLoad(thisVReg, regT4, regT3);
 626     emitJumpSlowCaseIfNotJSCell(base, regT1);
 627     emitJumpSlowCaseIfNotJSCell(thisVReg, regT4);
 628 
 629     JITGetByIdWithThisGenerator gen(
<a name="52" id="anc52"></a><span class="line-modified"> 630         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified"> 631         ident-&gt;impl(), JSValueRegs(regT1, regT0), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT4, regT3), AccessType::GetWithThis);</span>
 632     gen.generateFastPath(*this);
 633     addSlowCase(gen.slowPathJump());
 634     m_getByIdsWithThis.append(gen);
 635 
 636     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
 637     emitStore(dst, regT1, regT0);
 638 }
 639 
 640 void JIT::emitSlow_op_get_by_id_with_this(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 641 {
 642     linkAllSlowCases(iter);
 643 
 644     auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdWithThis&gt;();
<a name="53" id="anc53"></a><span class="line-modified"> 645     int resultVReg = bytecode.m_dst.offset();</span>
 646     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 647 
 648     JITGetByIdWithThisGenerator&amp; gen = m_getByIdsWithThis[m_getByIdWithThisIndex++];
 649 
 650     Label coldPathBegin = label();
 651 
<a name="54" id="anc54"></a><span class="line-modified"> 652     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdWithThisOptimize, resultVReg, gen.stubInfo(), JSValueRegs(regT1, regT0), JSValueRegs(regT4, regT3), ident-&gt;impl());</span>
 653 
 654     gen.reportSlowPathCall(coldPathBegin, call);
 655 }
 656 
 657 void JIT::emit_op_put_by_id(const Instruction* currentInstruction)
 658 {
 659     // In order to be able to patch both the Structure, and the object offset, we store one pointer,
 660     // to just after the arguments have been loaded into registers &#39;hotPathBegin&#39;, and we generate code
 661     // such that the Structure &amp; offset are always at the same distance from this.
 662 
 663     auto bytecode = currentInstruction-&gt;as&lt;OpPutById&gt;();
<a name="55" id="anc55"></a><span class="line-modified"> 664     int base = bytecode.m_base.offset();</span>
<span class="line-modified"> 665     int value = bytecode.m_value.offset();</span>
 666     bool direct = !!(bytecode.m_flags &amp; PutByIdIsDirect);
 667 
 668     emitLoad2(base, regT1, regT0, value, regT3, regT2);
 669 
 670     emitJumpSlowCaseIfNotJSCell(base, regT1);
 671 
 672     JITPutByIdGenerator gen(
<a name="56" id="anc56"></a><span class="line-modified"> 673         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
 674         JSValueRegs::payloadOnly(regT0), JSValueRegs(regT3, regT2),
 675         regT1, m_codeBlock-&gt;ecmaMode(), direct ? Direct : NotDirect);
 676 
 677     gen.generateFastPath(*this);
 678     addSlowCase(gen.slowPathJump());
 679 
 680     emitWriteBarrier(base, value, ShouldFilterBase);
 681 
 682     m_putByIds.append(gen);
 683 }
 684 
 685 void JIT::emitSlow_op_put_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 686 {
 687     linkAllSlowCases(iter);
 688 
 689     auto bytecode = currentInstruction-&gt;as&lt;OpPutById&gt;();
<a name="57" id="anc57"></a><span class="line-modified"> 690     int base = bytecode.m_base.offset();</span>
 691     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 692 
 693     Label coldPathBegin(this);
 694 
 695     // JITPutByIdGenerator only preserve the value and the base&#39;s payload, we have to reload the tag.
 696     emitLoadTag(base, regT1);
 697 
 698     JITPutByIdGenerator&amp; gen = m_putByIds[m_putByIdIndex++];
 699 
 700     Call call = callOperation(
<a name="58" id="anc58"></a><span class="line-modified"> 701         gen.slowPathFunction(), gen.stubInfo(), JSValueRegs(regT3, regT2), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
 702 
 703     gen.reportSlowPathCall(coldPathBegin, call);
 704 }
 705 
 706 void JIT::emit_op_in_by_id(const Instruction* currentInstruction)
 707 {
 708     auto bytecode = currentInstruction-&gt;as&lt;OpInById&gt;();
<a name="59" id="anc59"></a><span class="line-modified"> 709     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 710     int base = bytecode.m_base.offset();</span>
 711     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 712 
 713     emitLoad(base, regT1, regT0);
 714     emitJumpSlowCaseIfNotJSCell(base, regT1);
 715 
 716     JITInByIdGenerator gen(
<a name="60" id="anc60"></a><span class="line-modified"> 717         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(currentInstruction), RegisterSet::stubUnavailableRegisters(),</span>
 718         ident-&gt;impl(), JSValueRegs::payloadOnly(regT0), JSValueRegs(regT1, regT0));
 719     gen.generateFastPath(*this);
 720     addSlowCase(gen.slowPathJump());
 721     m_inByIds.append(gen);
 722 
 723     emitStore(dst, regT1, regT0);
 724 }
 725 
 726 void JIT::emitSlow_op_in_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
 727 {
 728     linkAllSlowCases(iter);
 729 
 730     auto bytecode = currentInstruction-&gt;as&lt;OpInById&gt;();
<a name="61" id="anc61"></a><span class="line-modified"> 731     int resultVReg = bytecode.m_dst.offset();</span>
 732     const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
 733 
 734     JITInByIdGenerator&amp; gen = m_inByIds[m_inByIdIndex++];
 735 
 736     Label coldPathBegin = label();
 737 
<a name="62" id="anc62"></a><span class="line-modified"> 738     Call call = callOperation(operationInByIdOptimize, resultVReg, gen.stubInfo(), JSValueRegs(regT1, regT0), ident-&gt;impl());</span>
 739 
 740     gen.reportSlowPathCall(coldPathBegin, call);
 741 }
 742 
 743 void JIT::emitVarInjectionCheck(bool needsVarInjectionChecks)
 744 {
 745     if (!needsVarInjectionChecks)
 746         return;
 747     addSlowCase(branch8(Equal, AbsoluteAddress(m_codeBlock-&gt;globalObject()-&gt;varInjectionWatchpoint()-&gt;addressOfState()), TrustedImm32(IsInvalidated)));
 748 }
 749 
<a name="63" id="anc63"></a><span class="line-modified"> 750 void JIT::emitResolveClosure(int dst, int scope, bool needsVarInjectionChecks, unsigned depth)</span>
 751 {
 752     emitVarInjectionCheck(needsVarInjectionChecks);
 753     move(TrustedImm32(JSValue::CellTag), regT1);
 754     emitLoadPayload(scope, regT0);
 755     for (unsigned i = 0; i &lt; depth; ++i)
 756         loadPtr(Address(regT0, JSScope::offsetOfNext()), regT0);
 757     emitStore(dst, regT1, regT0);
 758 }
 759 
 760 void JIT::emit_op_resolve_scope(const Instruction* currentInstruction)
 761 {
 762     auto bytecode = currentInstruction-&gt;as&lt;OpResolveScope&gt;();
 763     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<a name="64" id="anc64"></a><span class="line-modified"> 764     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 765     int scope = bytecode.m_scope.offset();</span>
 766     ResolveType resolveType = metadata.m_resolveType;
 767     unsigned depth = metadata.m_localScopeDepth;
 768 
 769     auto emitCode = [&amp;] (ResolveType resolveType) {
 770         switch (resolveType) {
 771         case GlobalProperty:
 772         case GlobalPropertyWithVarInjectionChecks: {
 773             JSScope* constantScope = JSScope::constantScopeForCodeBlock(resolveType, m_codeBlock);
 774             RELEASE_ASSERT(constantScope);
 775             emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
 776             load32(&amp;metadata.m_globalLexicalBindingEpoch, regT1);
 777             addSlowCase(branch32(NotEqual, AbsoluteAddress(m_codeBlock-&gt;globalObject()-&gt;addressOfGlobalLexicalBindingEpoch()), regT1));
 778             move(TrustedImm32(JSValue::CellTag), regT1);
 779             move(TrustedImmPtr(constantScope), regT0);
 780             emitStore(dst, regT1, regT0);
 781             break;
 782         }
 783 
 784         case GlobalVar:
 785         case GlobalVarWithVarInjectionChecks:
 786         case GlobalLexicalVar:
 787         case GlobalLexicalVarWithVarInjectionChecks: {
 788             JSScope* constantScope = JSScope::constantScopeForCodeBlock(resolveType, m_codeBlock);
 789             RELEASE_ASSERT(constantScope);
 790             emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
 791             move(TrustedImm32(JSValue::CellTag), regT1);
 792             move(TrustedImmPtr(constantScope), regT0);
 793             emitStore(dst, regT1, regT0);
 794             break;
 795         }
 796         case ClosureVar:
 797         case ClosureVarWithVarInjectionChecks:
 798             emitResolveClosure(dst, scope, needsVarInjectionChecks(resolveType), depth);
 799             break;
 800         case ModuleVar:
 801             move(TrustedImm32(JSValue::CellTag), regT1);
 802             move(TrustedImmPtr(metadata.m_lexicalEnvironment.get()), regT0);
 803             emitStore(dst, regT1, regT0);
 804             break;
 805         case Dynamic:
 806             addSlowCase(jump());
 807             break;
 808         case LocalClosureVar:
 809         case UnresolvedProperty:
 810         case UnresolvedPropertyWithVarInjectionChecks:
 811             RELEASE_ASSERT_NOT_REACHED();
 812         }
 813     };
 814     switch (resolveType) {
 815     case GlobalProperty:
 816     case GlobalPropertyWithVarInjectionChecks: {
 817         JumpList skipToEnd;
 818         load32(&amp;metadata.m_resolveType, regT0);
 819 
 820         Jump notGlobalProperty = branch32(NotEqual, regT0, TrustedImm32(resolveType));
 821         emitCode(resolveType);
 822         skipToEnd.append(jump());
 823 
 824         notGlobalProperty.link(this);
 825         emitCode(needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar);
 826 
 827         skipToEnd.link(this);
 828         break;
 829     }
 830     case UnresolvedProperty:
 831     case UnresolvedPropertyWithVarInjectionChecks: {
 832         JumpList skipToEnd;
 833         load32(&amp;metadata.m_resolveType, regT0);
 834 
 835         Jump notGlobalProperty = branch32(NotEqual, regT0, TrustedImm32(GlobalProperty));
 836         emitCode(GlobalProperty);
 837         skipToEnd.append(jump());
 838         notGlobalProperty.link(this);
 839 
 840         Jump notGlobalPropertyWithVarInjections = branch32(NotEqual, regT0, TrustedImm32(GlobalPropertyWithVarInjectionChecks));
 841         emitCode(GlobalPropertyWithVarInjectionChecks);
 842         skipToEnd.append(jump());
 843         notGlobalPropertyWithVarInjections.link(this);
 844 
 845         Jump notGlobalLexicalVar = branch32(NotEqual, regT0, TrustedImm32(GlobalLexicalVar));
 846         emitCode(GlobalLexicalVar);
 847         skipToEnd.append(jump());
 848         notGlobalLexicalVar.link(this);
 849 
 850         Jump notGlobalLexicalVarWithVarInjections = branch32(NotEqual, regT0, TrustedImm32(GlobalLexicalVarWithVarInjectionChecks));
 851         emitCode(GlobalLexicalVarWithVarInjectionChecks);
 852         skipToEnd.append(jump());
 853         notGlobalLexicalVarWithVarInjections.link(this);
 854 
 855         addSlowCase(jump());
 856         skipToEnd.link(this);
 857         break;
 858     }
 859 
 860     default:
 861         emitCode(resolveType);
 862         break;
 863     }
 864 }
 865 
<a name="65" id="anc65"></a><span class="line-modified"> 866 void JIT::emitLoadWithStructureCheck(int scope, Structure** structureSlot)</span>
 867 {
 868     emitLoad(scope, regT1, regT0);
 869     loadPtr(structureSlot, regT2);
 870     addSlowCase(branchPtr(NotEqual, Address(regT0, JSCell::structureIDOffset()), regT2));
 871 }
 872 
 873 void JIT::emitGetVarFromPointer(JSValue* operand, GPRReg tag, GPRReg payload)
 874 {
 875     uintptr_t rawAddress = bitwise_cast&lt;uintptr_t&gt;(operand);
 876     load32(bitwise_cast&lt;void*&gt;(rawAddress + TagOffset), tag);
 877     load32(bitwise_cast&lt;void*&gt;(rawAddress + PayloadOffset), payload);
 878 }
 879 void JIT::emitGetVarFromIndirectPointer(JSValue** operand, GPRReg tag, GPRReg payload)
 880 {
 881     loadPtr(operand, payload);
 882     load32(Address(payload, TagOffset), tag);
 883     load32(Address(payload, PayloadOffset), payload);
 884 }
 885 
<a name="66" id="anc66"></a><span class="line-modified"> 886 void JIT::emitGetClosureVar(int scope, uintptr_t operand)</span>
 887 {
 888     emitLoad(scope, regT1, regT0);
 889     load32(Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + TagOffset), regT1);
 890     load32(Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + PayloadOffset), regT0);
 891 }
 892 
 893 void JIT::emit_op_get_from_scope(const Instruction* currentInstruction)
 894 {
 895     auto bytecode = currentInstruction-&gt;as&lt;OpGetFromScope&gt;();
 896     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<a name="67" id="anc67"></a><span class="line-modified"> 897     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified"> 898     int scope = bytecode.m_scope.offset();</span>
 899     ResolveType resolveType = metadata.m_getPutInfo.resolveType();
 900     Structure** structureSlot = metadata.m_structure.slot();
 901     uintptr_t* operandSlot = reinterpret_cast&lt;uintptr_t*&gt;(&amp;metadata.m_operand);
 902 
 903     auto emitCode = [&amp;] (ResolveType resolveType, bool indirectLoadForOperand) {
 904         switch (resolveType) {
 905         case GlobalProperty:
 906         case GlobalPropertyWithVarInjectionChecks: {
 907             emitLoadWithStructureCheck(scope, structureSlot); // Structure check covers var injection.
 908             GPRReg base = regT2;
 909             GPRReg resultTag = regT1;
 910             GPRReg resultPayload = regT0;
 911             GPRReg offset = regT3;
 912 
 913             move(regT0, base);
 914             load32(operandSlot, offset);
<a name="68" id="anc68"></a><span class="line-modified"> 915             if (!ASSERT_DISABLED) {</span>
 916                 Jump isOutOfLine = branch32(GreaterThanOrEqual, offset, TrustedImm32(firstOutOfLineOffset));
 917                 abortWithReason(JITOffsetIsNotOutOfLine);
 918                 isOutOfLine.link(this);
 919             }
 920             loadPtr(Address(base, JSObject::butterflyOffset()), base);
 921             neg32(offset);
 922             load32(BaseIndex(base, offset, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.payload) + (firstOutOfLineOffset - 2) * sizeof(EncodedJSValue)), resultPayload);
 923             load32(BaseIndex(base, offset, TimesEight, OBJECT_OFFSETOF(JSValue, u.asBits.tag) + (firstOutOfLineOffset - 2) * sizeof(EncodedJSValue)), resultTag);
 924             break;
 925         }
 926         case GlobalVar:
 927         case GlobalVarWithVarInjectionChecks:
 928         case GlobalLexicalVar:
 929         case GlobalLexicalVarWithVarInjectionChecks:
 930             emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
 931             if (indirectLoadForOperand)
 932                 emitGetVarFromIndirectPointer(bitwise_cast&lt;JSValue**&gt;(operandSlot), regT1, regT0);
 933             else
 934                 emitGetVarFromPointer(bitwise_cast&lt;JSValue*&gt;(*operandSlot), regT1, regT0);
 935             if (resolveType == GlobalLexicalVar || resolveType == GlobalLexicalVarWithVarInjectionChecks) // TDZ check.
 936                 addSlowCase(branchIfEmpty(regT1));
 937             break;
 938         case ClosureVar:
 939         case ClosureVarWithVarInjectionChecks:
 940             emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
 941             emitGetClosureVar(scope, *operandSlot);
 942             break;
 943         case Dynamic:
 944             addSlowCase(jump());
 945             break;
 946         case ModuleVar:
 947         case LocalClosureVar:
 948         case UnresolvedProperty:
 949         case UnresolvedPropertyWithVarInjectionChecks:
 950             RELEASE_ASSERT_NOT_REACHED();
 951         }
 952     };
 953 
 954     switch (resolveType) {
 955     case GlobalProperty:
 956     case GlobalPropertyWithVarInjectionChecks: {
 957         JumpList skipToEnd;
 958         load32(&amp;metadata.m_getPutInfo, regT0);
 959         and32(TrustedImm32(GetPutInfo::typeBits), regT0); // Load ResolveType into T0
 960 
 961         Jump isNotGlobalProperty = branch32(NotEqual, regT0, TrustedImm32(resolveType));
 962         emitCode(resolveType, false);
 963         skipToEnd.append(jump());
 964 
 965         isNotGlobalProperty.link(this);
 966         emitCode(needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar, true);
 967         skipToEnd.link(this);
 968         break;
 969     }
 970     case UnresolvedProperty:
 971     case UnresolvedPropertyWithVarInjectionChecks: {
 972         JumpList skipToEnd;
 973         load32(&amp;metadata.m_getPutInfo, regT0);
 974         and32(TrustedImm32(GetPutInfo::typeBits), regT0); // Load ResolveType into T0
 975 
 976         Jump isGlobalProperty = branch32(Equal, regT0, TrustedImm32(GlobalProperty));
 977         Jump notGlobalPropertyWithVarInjections = branch32(NotEqual, regT0, TrustedImm32(GlobalPropertyWithVarInjectionChecks));
 978         isGlobalProperty.link(this);
 979         emitCode(GlobalProperty, false);
 980         skipToEnd.append(jump());
 981         notGlobalPropertyWithVarInjections.link(this);
 982 
 983         Jump notGlobalLexicalVar = branch32(NotEqual, regT0, TrustedImm32(GlobalLexicalVar));
 984         emitCode(GlobalLexicalVar, true);
 985         skipToEnd.append(jump());
 986         notGlobalLexicalVar.link(this);
 987 
 988         Jump notGlobalLexicalVarWithVarInjections = branch32(NotEqual, regT0, TrustedImm32(GlobalLexicalVarWithVarInjectionChecks));
 989         emitCode(GlobalLexicalVarWithVarInjectionChecks, true);
 990         skipToEnd.append(jump());
 991         notGlobalLexicalVarWithVarInjections.link(this);
 992 
 993         addSlowCase(jump());
 994 
 995         skipToEnd.link(this);
 996         break;
 997     }
 998 
 999     default:
1000         emitCode(resolveType, false);
1001         break;
1002     }
1003     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
1004     emitStore(dst, regT1, regT0);
1005 }
1006 
1007 void JIT::emitSlow_op_get_from_scope(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
1008 {
1009     linkAllSlowCases(iter);
1010 
1011     auto bytecode = currentInstruction-&gt;as&lt;OpGetFromScope&gt;();
<a name="69" id="anc69"></a><span class="line-modified">1012     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">1013     callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetFromScope, dst, currentInstruction);</span>
1014 }
1015 
<a name="70" id="anc70"></a><span class="line-modified">1016 void JIT::emitPutGlobalVariable(JSValue* operand, int value, WatchpointSet* set)</span>
1017 {
1018     emitLoad(value, regT1, regT0);
1019     emitNotifyWrite(set);
1020     uintptr_t rawAddress = bitwise_cast&lt;uintptr_t&gt;(operand);
1021     store32(regT1, bitwise_cast&lt;void*&gt;(rawAddress + TagOffset));
1022     store32(regT0, bitwise_cast&lt;void*&gt;(rawAddress + PayloadOffset));
1023 }
1024 
<a name="71" id="anc71"></a><span class="line-modified">1025 void JIT::emitPutGlobalVariableIndirect(JSValue** addressOfOperand, int value, WatchpointSet** indirectWatchpointSet)</span>
1026 {
1027     emitLoad(value, regT1, regT0);
1028     loadPtr(indirectWatchpointSet, regT2);
1029     emitNotifyWrite(regT2);
1030     loadPtr(addressOfOperand, regT2);
1031     store32(regT1, Address(regT2, TagOffset));
1032     store32(regT0, Address(regT2, PayloadOffset));
1033 }
1034 
<a name="72" id="anc72"></a><span class="line-modified">1035 void JIT::emitPutClosureVar(int scope, uintptr_t operand, int value, WatchpointSet* set)</span>
1036 {
1037     emitLoad(value, regT3, regT2);
1038     emitLoad(scope, regT1, regT0);
1039     emitNotifyWrite(set);
1040     store32(regT3, Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + TagOffset));
1041     store32(regT2, Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register) + PayloadOffset));
1042 }
1043 
1044 void JIT::emit_op_put_to_scope(const Instruction* currentInstruction)
1045 {
1046     auto bytecode = currentInstruction-&gt;as&lt;OpPutToScope&gt;();
1047     auto&amp; metadata = bytecode.metadata(m_codeBlock);
<a name="73" id="anc73"></a><span class="line-modified">1048     int scope = bytecode.m_scope.offset();</span>
<span class="line-modified">1049     int value = bytecode.m_value.offset();</span>
1050     GetPutInfo getPutInfo = copiedGetPutInfo(bytecode);
1051     ResolveType resolveType = getPutInfo.resolveType();
1052     Structure** structureSlot = metadata.m_structure.slot();
1053     uintptr_t* operandSlot = reinterpret_cast&lt;uintptr_t*&gt;(&amp;metadata.m_operand);
1054 
1055     auto emitCode = [&amp;] (ResolveType resolveType, bool indirectLoadForOperand) {
1056         switch (resolveType) {
1057         case GlobalProperty:
1058         case GlobalPropertyWithVarInjectionChecks: {
1059             emitWriteBarrier(m_codeBlock-&gt;globalObject(), value, ShouldFilterValue);
1060             emitLoadWithStructureCheck(scope, structureSlot); // Structure check covers var injection.
1061             emitLoad(value, regT3, regT2);
1062 
1063             loadPtr(Address(regT0, JSObject::butterflyOffset()), regT0);
1064             loadPtr(operandSlot, regT1);
1065             negPtr(regT1);
1066             store32(regT3, BaseIndex(regT0, regT1, TimesEight, (firstOutOfLineOffset - 2) * sizeof(EncodedJSValue) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.tag)));
1067             store32(regT2, BaseIndex(regT0, regT1, TimesEight, (firstOutOfLineOffset - 2) * sizeof(EncodedJSValue) + OBJECT_OFFSETOF(EncodedValueDescriptor, asBits.payload)));
1068             break;
1069         }
1070         case GlobalVar:
1071         case GlobalVarWithVarInjectionChecks:
1072         case GlobalLexicalVar:
1073         case GlobalLexicalVarWithVarInjectionChecks: {
1074             JSScope* constantScope = JSScope::constantScopeForCodeBlock(resolveType, m_codeBlock);
1075             RELEASE_ASSERT(constantScope);
1076             emitWriteBarrier(constantScope, value, ShouldFilterValue);
1077             emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
1078             if (!isInitialization(getPutInfo.initializationMode()) &amp;&amp; (resolveType == GlobalLexicalVar || resolveType == GlobalLexicalVarWithVarInjectionChecks)) {
1079                 // We need to do a TDZ check here because we can&#39;t always prove we need to emit TDZ checks statically.
1080                 if (indirectLoadForOperand)
1081                     emitGetVarFromIndirectPointer(bitwise_cast&lt;JSValue**&gt;(operandSlot), regT1, regT0);
1082                 else
1083                     emitGetVarFromPointer(bitwise_cast&lt;JSValue*&gt;(*operandSlot), regT1, regT0);
1084                 addSlowCase(branchIfEmpty(regT1));
1085             }
1086             if (indirectLoadForOperand)
1087                 emitPutGlobalVariableIndirect(bitwise_cast&lt;JSValue**&gt;(operandSlot), value, &amp;metadata.m_watchpointSet);
1088             else
1089                 emitPutGlobalVariable(bitwise_cast&lt;JSValue*&gt;(*operandSlot), value, metadata.m_watchpointSet);
1090             break;
1091         }
1092         case LocalClosureVar:
1093         case ClosureVar:
1094         case ClosureVarWithVarInjectionChecks:
1095             emitWriteBarrier(scope, value, ShouldFilterValue);
1096             emitVarInjectionCheck(needsVarInjectionChecks(resolveType));
1097             emitPutClosureVar(scope, *operandSlot, value, metadata.m_watchpointSet);
1098             break;
1099         case ModuleVar:
1100         case Dynamic:
1101             addSlowCase(jump());
1102             break;
1103         case UnresolvedProperty:
1104         case UnresolvedPropertyWithVarInjectionChecks:
1105             RELEASE_ASSERT_NOT_REACHED();
1106         }
1107     };
1108 
1109     switch (resolveType) {
1110     case GlobalProperty:
1111     case GlobalPropertyWithVarInjectionChecks: {
1112         JumpList skipToEnd;
1113         load32(&amp;metadata.m_getPutInfo, regT0);
1114         and32(TrustedImm32(GetPutInfo::typeBits), regT0); // Load ResolveType into T0
1115 
1116         Jump isGlobalProperty = branch32(Equal, regT0, TrustedImm32(resolveType));
1117         Jump isGlobalLexicalVar = branch32(Equal, regT0, TrustedImm32(needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar));
1118         addSlowCase(jump()); // Dynamic, it can happen if we attempt to put a value to already-initialized const binding.
1119 
1120         isGlobalLexicalVar.link(this);
1121         emitCode(needsVarInjectionChecks(resolveType) ? GlobalLexicalVarWithVarInjectionChecks : GlobalLexicalVar, true);
1122         skipToEnd.append(jump());
1123 
1124         isGlobalProperty.link(this);
1125         emitCode(resolveType, false);
1126         skipToEnd.link(this);
1127         break;
1128     }
1129     case UnresolvedProperty:
1130     case UnresolvedPropertyWithVarInjectionChecks: {
1131         JumpList skipToEnd;
1132         load32(&amp;metadata.m_getPutInfo, regT0);
1133         and32(TrustedImm32(GetPutInfo::typeBits), regT0); // Load ResolveType into T0
1134 
1135         Jump isGlobalProperty = branch32(Equal, regT0, TrustedImm32(GlobalProperty));
1136         Jump notGlobalPropertyWithVarInjections = branch32(NotEqual, regT0, TrustedImm32(GlobalPropertyWithVarInjectionChecks));
1137         isGlobalProperty.link(this);
1138         emitCode(GlobalProperty, false);
1139         skipToEnd.append(jump());
1140         notGlobalPropertyWithVarInjections.link(this);
1141 
1142         Jump notGlobalLexicalVar = branch32(NotEqual, regT0, TrustedImm32(GlobalLexicalVar));
1143         emitCode(GlobalLexicalVar, true);
1144         skipToEnd.append(jump());
1145         notGlobalLexicalVar.link(this);
1146 
1147         Jump notGlobalLexicalVarWithVarInjections = branch32(NotEqual, regT0, TrustedImm32(GlobalLexicalVarWithVarInjectionChecks));
1148         emitCode(GlobalLexicalVarWithVarInjectionChecks, true);
1149         skipToEnd.append(jump());
1150         notGlobalLexicalVarWithVarInjections.link(this);
1151 
1152         addSlowCase(jump());
1153 
1154         skipToEnd.link(this);
1155         break;
1156     }
1157 
1158     default:
1159         emitCode(resolveType, false);
1160         break;
1161     }
1162 }
1163 
1164 void JIT::emitSlow_op_put_to_scope(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
1165 {
1166     linkAllSlowCases(iter);
1167 
1168     auto bytecode = currentInstruction-&gt;as&lt;OpPutToScope&gt;();
1169     ResolveType resolveType = copiedGetPutInfo(bytecode).resolveType();
1170     if (resolveType == ModuleVar) {
1171         JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_throw_strict_mode_readonly_property_write_error);
1172         slowPathCall.call();
1173     } else
<a name="74" id="anc74"></a><span class="line-modified">1174         callOperation(operationPutToScope, currentInstruction);</span>
1175 }
1176 
1177 void JIT::emit_op_get_from_arguments(const Instruction* currentInstruction)
1178 {
1179     auto bytecode = currentInstruction-&gt;as&lt;OpGetFromArguments&gt;();
<a name="75" id="anc75"></a><span class="line-modified">1180     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">1181     int arguments = bytecode.m_arguments.offset();</span>
1182     int index = bytecode.m_index;
1183 
1184     emitLoadPayload(arguments, regT0);
1185     load32(Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + TagOffset), regT1);
1186     load32(Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + PayloadOffset), regT0);
1187     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
1188     emitStore(dst, regT1, regT0);
1189 }
1190 
1191 void JIT::emit_op_put_to_arguments(const Instruction* currentInstruction)
1192 {
1193     auto bytecode = currentInstruction-&gt;as&lt;OpPutToArguments&gt;();
<a name="76" id="anc76"></a><span class="line-modified">1194     int arguments = bytecode.m_arguments.offset();</span>
1195     int index = bytecode.m_index;
<a name="77" id="anc77"></a><span class="line-modified">1196     int value = bytecode.m_value.offset();</span>
1197 
1198     emitWriteBarrier(arguments, value, ShouldFilterValue);
1199 
1200     emitLoadPayload(arguments, regT0);
1201     emitLoad(value, regT1, regT2);
1202     store32(regT1, Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + TagOffset));
1203     store32(regT2, Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;) + PayloadOffset));
1204 }
1205 
<a name="78" id="anc78"></a>




























1206 } // namespace JSC
1207 
1208 #endif // USE(JSVALUE32_64)
1209 #endif // ENABLE(JIT)
<a name="79" id="anc79"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="79" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/workers/service/server/RegistrationDatabase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RegistrationDatabase.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;Logging.h&quot;
 32 #include &quot;RegistrationStore.h&quot;
 33 #include &quot;SQLiteDatabase.h&quot;
 34 #include &quot;SQLiteFileSystem.h&quot;
 35 #include &quot;SQLiteStatement.h&quot;
 36 #include &quot;SQLiteTransaction.h&quot;
 37 #include &quot;SWServer.h&quot;
 38 #include &quot;SecurityOrigin.h&quot;
 39 #include &lt;wtf/CompletionHandler.h&gt;
 40 #include &lt;wtf/CrossThreadCopier.h&gt;
 41 #include &lt;wtf/FileSystem.h&gt;
 42 #include &lt;wtf/MainThread.h&gt;
 43 #include &lt;wtf/NeverDestroyed.h&gt;
 44 #include &lt;wtf/Scope.h&gt;
 45 #include &lt;wtf/persistence/PersistentCoders.h&gt;
 46 #include &lt;wtf/persistence/PersistentDecoder.h&gt;
 47 #include &lt;wtf/persistence/PersistentEncoder.h&gt;
 48 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 49 
 50 namespace WebCore {
 51 
 52 static const uint64_t schemaVersion = 4;
 53 
 54 static const String recordsTableSchema(const String&amp; tableName)
 55 {
 56     return makeString(&quot;CREATE TABLE &quot;, tableName, &quot; (key TEXT NOT NULL ON CONFLICT FAIL UNIQUE ON CONFLICT REPLACE, origin TEXT NOT NULL ON CONFLICT FAIL, scopeURL TEXT NOT NULL ON CONFLICT FAIL, topOrigin TEXT NOT NULL ON CONFLICT FAIL, lastUpdateCheckTime DOUBLE NOT NULL ON CONFLICT FAIL, updateViaCache TEXT NOT NULL ON CONFLICT FAIL, scriptURL TEXT NOT NULL ON CONFLICT FAIL, script TEXT NOT NULL ON CONFLICT FAIL, workerType TEXT NOT NULL ON CONFLICT FAIL, contentSecurityPolicy BLOB NOT NULL ON CONFLICT FAIL, referrerPolicy TEXT NOT NULL ON CONFLICT FAIL, scriptResourceMap BLOB NOT NULL ON CONFLICT FAIL)&quot;);
 57 }
 58 
 59 static const String recordsTableSchema()
 60 {
 61     ASSERT(!isMainThread());
 62     static NeverDestroyed&lt;String&gt; schema(recordsTableSchema(&quot;Records&quot;));
 63     return schema;
 64 }
 65 
 66 static const String recordsTableSchemaAlternate()
 67 {
 68     ASSERT(!isMainThread());
 69     static NeverDestroyed&lt;String&gt; schema(recordsTableSchema(&quot;\&quot;Records\&quot;&quot;));
 70     return schema;
 71 }
 72 
 73 static inline String databaseFilenameFromVersion(uint64_t version)
 74 {
 75     return makeString(&quot;ServiceWorkerRegistrations-&quot;, version, &quot;.sqlite3&quot;);
 76 }
 77 
 78 static const String&amp; databaseFilename()
 79 {
 80     ASSERT(isMainThread());
 81     static NeverDestroyed&lt;String&gt; filename = databaseFilenameFromVersion(schemaVersion);
 82     return filename;
 83 }
 84 
 85 String serviceWorkerRegistrationDatabaseFilename(const String&amp; databaseDirectory)
 86 {
 87     return FileSystem::pathByAppendingComponent(databaseDirectory, databaseFilename());
 88 }
 89 
 90 static inline void cleanOldDatabases(const String&amp; databaseDirectory)
 91 {
 92     for (uint64_t version = 1; version &lt; schemaVersion; ++version)
 93         SQLiteFileSystem::deleteDatabaseFile(FileSystem::pathByAppendingComponent(databaseDirectory, databaseFilenameFromVersion(version)));
 94 }
 95 
 96 RegistrationDatabase::RegistrationDatabase(RegistrationStore&amp; store, String&amp;&amp; databaseDirectory)
 97     : m_workQueue(WorkQueue::create(&quot;ServiceWorker I/O Thread&quot;, WorkQueue::Type::Serial))
 98     , m_store(makeWeakPtr(store))
<a name="1" id="anc1"></a>
 99     , m_databaseDirectory(WTFMove(databaseDirectory))
100     , m_databaseFilePath(FileSystem::pathByAppendingComponent(m_databaseDirectory, databaseFilename()))
101 {
102     ASSERT(isMainThread());
103 
104     postTaskToWorkQueue([this] {
105         importRecordsIfNecessary();
106     });
107 }
108 
109 RegistrationDatabase::~RegistrationDatabase()
110 {
111     ASSERT(isMainThread());
112 
113     // The database needs to be destroyed on the background thread.
114     if (m_database)
115         m_workQueue-&gt;dispatch([database = WTFMove(m_database)] { });
116 }
117 
118 void RegistrationDatabase::postTaskToWorkQueue(Function&lt;void()&gt;&amp;&amp; task)
119 {
120     ASSERT(isMainThread());
121 
122     m_workQueue-&gt;dispatch([protectedThis = makeRef(*this), task = WTFMove(task)]() mutable {
123         task();
124     });
125 }
126 
127 void RegistrationDatabase::openSQLiteDatabase(const String&amp; fullFilename)
128 {
129     ASSERT(!isMainThread());
130     ASSERT(!m_database);
131 
132     auto databaseDirectory = this-&gt;databaseDirectoryIsolatedCopy();
133     cleanOldDatabases(databaseDirectory);
134 
135     LOG(ServiceWorker, &quot;ServiceWorker RegistrationDatabase opening file %s&quot;, fullFilename.utf8().data());
136 
137     SQLiteFileSystem::ensureDatabaseDirectoryExists(databaseDirectory);
138 
139     m_database = makeUnique&lt;SQLiteDatabase&gt;();
140     if (!m_database-&gt;open(fullFilename)) {
141         RELEASE_LOG_ERROR(ServiceWorker, &quot;Failed to open Service Worker registration database&quot;);
142         m_database = nullptr;
143         callOnMainThread([this, protectedThis = makeRef(*this)] {
144             databaseFailedToOpen();
145         });
146         return;
147     }
148 
149     // Disable threading checks. We always access the database from our serial WorkQueue. Such accesses
150     // are safe since work queue tasks are guaranteed to run one after another. However, tasks will not
151     // necessary run on the same thread every time (as per GCD documentation).
152     m_database-&gt;disableThreadingChecks();
153 
154     auto doRecoveryAttempt = [&amp;] {
155         // Delete the database and re-create it.
156         m_database = nullptr;
157         SQLiteFileSystem::deleteDatabaseFile(fullFilename);
158         openSQLiteDatabase(fullFilename);
159     };
160 
161     String errorMessage = ensureValidRecordsTable();
162     if (!errorMessage.isNull()) {
163         RELEASE_LOG_ERROR(ServiceWorker, &quot;ensureValidRecordsTable failed, reason: %{public}s&quot;, errorMessage.utf8().data());
164         doRecoveryAttempt();
165         return;
166     }
167 
168     errorMessage = importRecords();
169     if (!errorMessage.isNull()) {
170         RELEASE_LOG_ERROR(ServiceWorker, &quot;importRecords failed, reason: %{public}s&quot;, errorMessage.utf8().data());
171         doRecoveryAttempt();
172         return;
173     }
174 }
175 
176 void RegistrationDatabase::importRecordsIfNecessary()
177 {
178     ASSERT(!isMainThread());
179 
180     if (FileSystem::fileExists(m_databaseFilePath))
181         openSQLiteDatabase(m_databaseFilePath);
182 
183     callOnMainThread([protectedThis = makeRef(*this)] {
184         protectedThis-&gt;databaseOpenedAndRecordsImported();
185     });
186 }
187 
188 String RegistrationDatabase::ensureValidRecordsTable()
189 {
190     ASSERT(!isMainThread());
191     ASSERT(m_database);
192     ASSERT(m_database-&gt;isOpen());
193 
194     String currentSchema;
195     {
196         // Fetch the schema for an existing records table.
197         SQLiteStatement statement(*m_database, &quot;SELECT type, sql FROM sqlite_master WHERE tbl_name=&#39;Records&#39;&quot;);
198         if (statement.prepare() != SQLITE_OK)
199             return &quot;Unable to prepare statement to fetch schema for the Records table.&quot;;
200 
201         int sqliteResult = statement.step();
202 
203         // If there is no Records table at all, create it and then bail.
204         if (sqliteResult == SQLITE_DONE) {
205             if (!m_database-&gt;executeCommand(recordsTableSchema()))
206                 return makeString(&quot;Could not create Records table in database (&quot;, m_database-&gt;lastError(), &quot;) - &quot;, m_database-&gt;lastErrorMsg());
207             return { };
208         }
209 
210         if (sqliteResult != SQLITE_ROW)
211             return &quot;Error executing statement to fetch schema for the Records table.&quot;;
212 
213         currentSchema = statement.getColumnText(1);
214     }
215 
216     ASSERT(!currentSchema.isEmpty());
217 
218     if (currentSchema == recordsTableSchema() || currentSchema == recordsTableSchemaAlternate())
219         return { };
220 
221     return makeString(&quot;Unexpected schema: &quot;, currentSchema);
222 }
223 
224 static String updateViaCacheToString(ServiceWorkerUpdateViaCache update)
225 {
226     switch (update) {
227     case ServiceWorkerUpdateViaCache::Imports:
228         return &quot;Imports&quot;;
229     case ServiceWorkerUpdateViaCache::All:
230         return &quot;All&quot;;
231     case ServiceWorkerUpdateViaCache::None:
232         return &quot;None&quot;;
233     }
234 
235     RELEASE_ASSERT_NOT_REACHED();
236 }
237 
238 static Optional&lt;ServiceWorkerUpdateViaCache&gt; stringToUpdateViaCache(const String&amp; update)
239 {
240     if (update == &quot;Imports&quot;)
241         return ServiceWorkerUpdateViaCache::Imports;
242     if (update == &quot;All&quot;)
243         return ServiceWorkerUpdateViaCache::All;
244     if (update == &quot;None&quot;)
245         return ServiceWorkerUpdateViaCache::None;
246 
247     return WTF::nullopt;
248 }
249 
250 static String workerTypeToString(WorkerType workerType)
251 {
252     switch (workerType) {
253     case WorkerType::Classic:
254         return &quot;Classic&quot;;
255     case WorkerType::Module:
256         return &quot;Module&quot;;
257     }
258 
259     RELEASE_ASSERT_NOT_REACHED();
260 }
261 
262 static Optional&lt;WorkerType&gt; stringToWorkerType(const String&amp; type)
263 {
264     if (type == &quot;Classic&quot;)
265         return WorkerType::Classic;
266     if (type == &quot;Module&quot;)
267         return WorkerType::Module;
268 
269     return WTF::nullopt;
270 }
271 
272 void RegistrationDatabase::pushChanges(const HashMap&lt;ServiceWorkerRegistrationKey, Optional&lt;ServiceWorkerContextData&gt;&gt;&amp; changedRegistrations, CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
273 {
274     Vector&lt;ServiceWorkerContextData&gt; updatedRegistrations;
275     Vector&lt;ServiceWorkerRegistrationKey&gt; removedRegistrations;
276     for (auto&amp; keyValue : changedRegistrations) {
277         if (keyValue.value)
278             updatedRegistrations.append(keyValue.value-&gt;isolatedCopy());
279         else
280             removedRegistrations.append(keyValue.key.isolatedCopy());
281     }
282 
283     postTaskToWorkQueue([this, updatedRegistrations = WTFMove(updatedRegistrations), removedRegistrations = WTFMove(removedRegistrations), completionHandler = WTFMove(completionHandler)]() mutable {
284         doPushChanges(updatedRegistrations, removedRegistrations);
285 
286         if (!completionHandler)
287             return;
288 
289         callOnMainThread(WTFMove(completionHandler));
290     });
291 }
292 
293 void RegistrationDatabase::close(CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
294 {
295     postTaskToWorkQueue([this, completionHandler = WTFMove(completionHandler)]() mutable {
296         m_database = nullptr;
297         callOnMainThread(WTFMove(completionHandler));
298     });
299 }
300 
301 void RegistrationDatabase::clearAll(CompletionHandler&lt;void()&gt;&amp;&amp; completionHandler)
302 {
303     postTaskToWorkQueue([this, completionHandler = WTFMove(completionHandler)]() mutable {
304         m_database = nullptr;
305 
306         SQLiteFileSystem::deleteDatabaseFile(m_databaseFilePath);
307         SQLiteFileSystem::deleteEmptyDatabaseDirectory(databaseDirectoryIsolatedCopy());
308 
309         callOnMainThread(WTFMove(completionHandler));
310     });
311 }
312 
313 void RegistrationDatabase::doPushChanges(const Vector&lt;ServiceWorkerContextData&gt;&amp; updatedRegistrations, const Vector&lt;ServiceWorkerRegistrationKey&gt;&amp; removedRegistrations)
314 {
315     if (!m_database) {
316         openSQLiteDatabase(m_databaseFilePath);
317         if (!m_database)
318             return;
319     }
320 
321     SQLiteTransaction transaction(*m_database);
322     transaction.begin();
323 
324     SQLiteStatement sql(*m_database, &quot;INSERT INTO Records VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)&quot;_s);
325     if (sql.prepare() != SQLITE_OK) {
326         RELEASE_LOG_ERROR(ServiceWorker, &quot;Failed to prepare statement to store registration data into records table (%i) - %s&quot;, m_database-&gt;lastError(), m_database-&gt;lastErrorMsg());
327         return;
328     }
329 
330     for (auto&amp; registration : removedRegistrations) {
331         SQLiteStatement sql(*m_database, &quot;DELETE FROM Records WHERE key = ?&quot;);
332         if (sql.prepare() != SQLITE_OK
333             || sql.bindText(1, registration.toDatabaseKey()) != SQLITE_OK
334             || sql.step() != SQLITE_DONE) {
335             RELEASE_LOG_ERROR(ServiceWorker, &quot;Failed to remove registration data from records table (%i) - %s&quot;, m_database-&gt;lastError(), m_database-&gt;lastErrorMsg());
336             return;
337         }
338     }
339 
340     for (auto&amp; data : updatedRegistrations) {
341         WTF::Persistence::Encoder cspEncoder;
342         data.contentSecurityPolicy.encode(cspEncoder);
343 
344         WTF::Persistence::Encoder scriptResourceMapEncoder;
345         scriptResourceMapEncoder.encode(data.scriptResourceMap);
346 
347         if (sql.bindText(1, data.registration.key.toDatabaseKey()) != SQLITE_OK
348             || sql.bindText(2, data.registration.scopeURL.protocolHostAndPort()) != SQLITE_OK
349             || sql.bindText(3, data.registration.scopeURL.path()) != SQLITE_OK
350             || sql.bindText(4, data.registration.key.topOrigin().databaseIdentifier()) != SQLITE_OK
351             || sql.bindDouble(5, data.registration.lastUpdateTime.secondsSinceEpoch().value()) != SQLITE_OK
352             || sql.bindText(6, updateViaCacheToString(data.registration.updateViaCache)) != SQLITE_OK
353             || sql.bindText(7, data.scriptURL.string()) != SQLITE_OK
354             || sql.bindText(8, data.script) != SQLITE_OK
355             || sql.bindText(9, workerTypeToString(data.workerType)) != SQLITE_OK
356             || sql.bindBlob(10, cspEncoder.buffer(), cspEncoder.bufferSize()) != SQLITE_OK
357             || sql.bindText(11, data.referrerPolicy) != SQLITE_OK
358             || sql.bindBlob(12, scriptResourceMapEncoder.buffer(), scriptResourceMapEncoder.bufferSize()) != SQLITE_OK
359             || sql.step() != SQLITE_DONE) {
360             RELEASE_LOG_ERROR(ServiceWorker, &quot;Failed to store registration data into records table (%i) - %s&quot;, m_database-&gt;lastError(), m_database-&gt;lastErrorMsg());
361             return;
362         }
363     }
364 
365     transaction.commit();
366 
367     LOG(ServiceWorker, &quot;Updated ServiceWorker registration database (%zu added/updated registrations and %zu removed registrations&quot;, updatedRegistrations.size(), removedRegistrations.size());
368 }
369 
370 String RegistrationDatabase::importRecords()
371 {
372     ASSERT(!isMainThread());
373 
374     SQLiteStatement sql(*m_database, &quot;SELECT * FROM Records;&quot;_s);
375     if (sql.prepare() != SQLITE_OK)
376         return makeString(&quot;Failed to prepare statement to retrieve registrations from records table (&quot;, m_database-&gt;lastError(), &quot;) - &quot;, m_database-&gt;lastErrorMsg());
377 
378     int result = sql.step();
379 
380     for (; result == SQLITE_ROW; result = sql.step()) {
381         auto key = ServiceWorkerRegistrationKey::fromDatabaseKey(sql.getColumnText(0));
382         auto originURL = URL { URL(), sql.getColumnText(1) };
383         auto scopePath = sql.getColumnText(2);
384         auto topOrigin = SecurityOriginData::fromDatabaseIdentifier(sql.getColumnText(3));
385         auto lastUpdateCheckTime = WallTime::fromRawSeconds(sql.getColumnDouble(4));
386         auto updateViaCache = stringToUpdateViaCache(sql.getColumnText(5));
387         auto scriptURL = URL { URL(), sql.getColumnText(6) };
388         auto script = sql.getColumnText(7);
389         auto workerType = stringToWorkerType(sql.getColumnText(8));
390 
391         Vector&lt;uint8_t&gt; contentSecurityPolicyData;
392         sql.getColumnBlobAsVector(9, contentSecurityPolicyData);
393         WTF::Persistence::Decoder cspDecoder(contentSecurityPolicyData.data(), contentSecurityPolicyData.size());
394         ContentSecurityPolicyResponseHeaders contentSecurityPolicy;
395         if (contentSecurityPolicyData.size() &amp;&amp; !ContentSecurityPolicyResponseHeaders::decode(cspDecoder, contentSecurityPolicy))
396             continue;
397 
398         auto referrerPolicy = sql.getColumnText(10);
399 
400         Vector&lt;uint8_t&gt; scriptResourceMapData;
401         sql.getColumnBlobAsVector(11, scriptResourceMapData);
402         HashMap&lt;URL, ServiceWorkerContextData::ImportedScript&gt; scriptResourceMap;
403 
404         WTF::Persistence::Decoder scriptResourceMapDecoder(scriptResourceMapData.data(), scriptResourceMapData.size());
405         if (scriptResourceMapData.size()) {
406             if (!scriptResourceMapDecoder.decode(scriptResourceMap))
407                 continue;
408         }
409 
410         // Validate the input for this registration.
411         // If any part of this input is invalid, let&#39;s skip this registration.
412         // FIXME: Should we return an error skipping *all* registrations?
413         if (!key || !originURL.isValid() || !topOrigin || !updateViaCache || !scriptURL.isValid() || !workerType)
414             continue;
415 
416         auto workerIdentifier = ServiceWorkerIdentifier::generate();
417         auto registrationIdentifier = ServiceWorkerRegistrationIdentifier::generate();
418         auto serviceWorkerData = ServiceWorkerData { workerIdentifier, scriptURL, ServiceWorkerState::Activated, *workerType, registrationIdentifier };
419         auto registration = ServiceWorkerRegistrationData { WTFMove(*key), registrationIdentifier, URL(originURL, scopePath), *updateViaCache, lastUpdateCheckTime, WTF::nullopt, WTF::nullopt, WTFMove(serviceWorkerData) };
<a name="2" id="anc2"></a><span class="line-modified">420         auto contextData = ServiceWorkerContextData { WTF::nullopt, WTFMove(registration), workerIdentifier, WTFMove(script), WTFMove(contentSecurityPolicy), WTFMove(referrerPolicy), WTFMove(scriptURL), *workerType, true, WTFMove(scriptResourceMap) };</span>
421 
422         callOnMainThread([protectedThis = makeRef(*this), contextData = contextData.isolatedCopy()]() mutable {
423             protectedThis-&gt;addRegistrationToStore(WTFMove(contextData));
424         });
425     }
426 
427     if (result != SQLITE_DONE)
428         return makeString(&quot;Failed to import at least one registration from records table (&quot;, m_database-&gt;lastError(), &quot;) - &quot;, m_database-&gt;lastErrorMsg());
429 
430     return { };
431 }
432 
433 void RegistrationDatabase::addRegistrationToStore(ServiceWorkerContextData&amp;&amp; context)
434 {
435     if (m_store)
436         m_store-&gt;addRegistrationFromDatabase(WTFMove(context));
437 }
438 
439 void RegistrationDatabase::databaseFailedToOpen()
440 {
441     if (m_store)
442         m_store-&gt;databaseFailedToOpen();
443 }
444 
445 void RegistrationDatabase::databaseOpenedAndRecordsImported()
446 {
447     if (m_store)
448         m_store-&gt;databaseOpenedAndRecordsImported();
449 }
450 
451 } // namespace WebCore
452 
453 #endif // ENABLE(SERVICE_WORKER)
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
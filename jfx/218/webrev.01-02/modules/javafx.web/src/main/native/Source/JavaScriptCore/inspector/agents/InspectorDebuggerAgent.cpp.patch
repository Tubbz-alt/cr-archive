diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorDebuggerAgent.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorDebuggerAgent.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorDebuggerAgent.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorDebuggerAgent.cpp
@@ -39,10 +39,11 @@
 #include "RegularExpression.h"
 #include "ScriptCallStack.h"
 #include "ScriptCallStackFactory.h"
 #include "ScriptDebugServer.h"
 #include "ScriptObject.h"
+#include <wtf/Function.h>
 #include <wtf/JSONValues.h>
 #include <wtf/NeverDestroyed.h>
 #include <wtf/Stopwatch.h>
 #include <wtf/text/StringConcatenateNumbers.h>
 #include <wtf/text/WTFString.h>
@@ -58,50 +59,60 @@
 static String objectGroupForBreakpointAction(const ScriptBreakpointAction& action)
 {
     return makeString("breakpoint-action-", action.identifier);
 }
 
+static bool isWebKitInjectedScript(const String& sourceURL)
+{
+    return sourceURL.startsWith("__InjectedScript_") && sourceURL.endsWith(".js");
+}
+
 InspectorDebuggerAgent::InspectorDebuggerAgent(AgentContext& context)
     : InspectorAgentBase("Debugger"_s)
     , m_frontendDispatcher(makeUnique<DebuggerFrontendDispatcher>(context.frontendRouter))
     , m_backendDispatcher(DebuggerBackendDispatcher::create(context.backendDispatcher, this))
     , m_scriptDebugServer(context.environment.scriptDebugServer())
     , m_injectedScriptManager(context.injectedScriptManager)
 {
-    // FIXME: make breakReason optional so that there was no need to init it with "other".
-    clearBreakDetails();
+    // FIXME: make pauseReason optional so that there was no need to init it with "other".
+    clearPauseDetails();
 }
 
 InspectorDebuggerAgent::~InspectorDebuggerAgent() = default;
 
 void InspectorDebuggerAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
 {
 }
 
 void InspectorDebuggerAgent::willDestroyFrontendAndBackend(DisconnectReason reason)
 {
-    disable(reason == DisconnectReason::InspectedTargetDestroyed);
+    if (enabled())
+        disable(reason == DisconnectReason::InspectedTargetDestroyed);
 }
 
 void InspectorDebuggerAgent::enable()
 {
-    if (m_enabled)
-        return;
-
     m_enabled = true;
 
     m_scriptDebugServer.addListener(this);
 
     for (auto* listener : copyToVector(m_listeners))
         listener->debuggerWasEnabled();
+
+    for (auto& [sourceID, script] : m_scripts) {
+        Optional<JSC::Debugger::BlackboxType> blackboxType;
+        if (isWebKitInjectedScript(script.sourceURL)) {
+            if (!m_pauseForInternalScripts)
+                blackboxType = JSC::Debugger::BlackboxType::Ignored;
+        } else if (shouldBlackboxURL(script.sourceURL) || shouldBlackboxURL(script.url))
+            blackboxType = JSC::Debugger::BlackboxType::Deferred;
+        m_scriptDebugServer.setBlackboxType(sourceID, blackboxType);
+    }
 }
 
 void InspectorDebuggerAgent::disable(bool isBeingDestroyed)
 {
-    if (!m_enabled)
-        return;
-
     for (auto* listener : copyToVector(m_listeners))
         listener->debuggerWasDisabled();
 
     m_scriptDebugServer.removeListener(this, isBeingDestroyed);
 
@@ -118,12 +129,17 @@
     m_pauseOnMicrotasks = false;
 
     m_enabled = false;
 }
 
-void InspectorDebuggerAgent::enable(ErrorString&)
+void InspectorDebuggerAgent::enable(ErrorString& errorString)
 {
+    if (enabled()) {
+        errorString = "Debugger domain already enabled"_s;
+        return;
+    }
+
     enable();
 }
 
 void InspectorDebuggerAgent::disable(ErrorString&)
 {
@@ -167,10 +183,21 @@
 void InspectorDebuggerAgent::setSuppressAllPauses(bool suppress)
 {
     m_scriptDebugServer.setSuppressAllPauses(suppress);
 }
 
+void InspectorDebuggerAgent::updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason reason, RefPtr<JSON::Object>&& data)
+{
+    if (m_pauseReason != DebuggerFrontendDispatcher::Reason::BlackboxedScript) {
+        m_preBlackboxPauseReason = m_pauseReason;
+        m_preBlackboxPauseData = WTFMove(m_pauseData);
+    }
+
+    m_pauseReason = reason;
+    m_pauseData = WTFMove(data);
+}
+
 static RefPtr<JSON::Object> buildAssertPauseReason(const String& message)
 {
     auto reason = Protocol::Debugger::AssertPauseReason::create().release();
     if (!message.isNull())
         reason->setMessage(message);
@@ -223,19 +250,19 @@
 InspectorDebuggerAgent::AsyncCallIdentifier InspectorDebuggerAgent::asyncCallIdentifier(AsyncCallType asyncCallType, int callbackId)
 {
     return std::make_pair(static_cast<unsigned>(asyncCallType), callbackId);
 }
 
-void InspectorDebuggerAgent::didScheduleAsyncCall(JSC::ExecState* exec, AsyncCallType asyncCallType, int callbackId, bool singleShot)
+void InspectorDebuggerAgent::didScheduleAsyncCall(JSC::JSGlobalObject* globalObject, AsyncCallType asyncCallType, int callbackId, bool singleShot)
 {
     if (!m_asyncStackTraceDepth)
         return;
 
     if (!m_scriptDebugServer.breakpointsActive())
         return;
 
-    Ref<ScriptCallStack> callStack = createScriptCallStack(exec, m_asyncStackTraceDepth);
+    Ref<ScriptCallStack> callStack = createScriptCallStack(globalObject, m_asyncStackTraceDepth);
     ASSERT(callStack->size());
     if (!callStack->size())
         return;
 
     RefPtr<AsyncStackTrace> parentStackTrace;
@@ -696,19 +723,18 @@
     }
 
     injectedScript.getFunctionDetails(errorString, functionId, details);
 }
 
-void InspectorDebuggerAgent::schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason breakReason, RefPtr<JSON::Object>&& data)
+void InspectorDebuggerAgent::schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason reason, RefPtr<JSON::Object>&& data)
 {
     if (m_javaScriptPauseScheduled)
         return;
 
     m_javaScriptPauseScheduled = true;
 
-    m_breakReason = breakReason;
-    m_breakData = WTFMove(data);
+    updatePauseReasonAndData(reason, WTFMove(data));
 
     JSC::JSLockHolder locker(m_scriptDebugServer.vm());
     m_scriptDebugServer.setPauseOnNextStatement(true);
 }
 
@@ -717,11 +743,11 @@
     if (!m_javaScriptPauseScheduled)
         return;
 
     m_javaScriptPauseScheduled = false;
 
-    clearBreakDetails();
+    clearPauseDetails();
     m_scriptDebugServer.setPauseOnNextStatement(false);
     m_enablePauseWhenIdle = false;
 }
 
 void InspectorDebuggerAgent::pause(ErrorString&)
@@ -729,11 +755,11 @@
     schedulePauseOnNextStatement(DebuggerFrontendDispatcher::Reason::PauseOnNextStatement, nullptr);
 }
 
 void InspectorDebuggerAgent::resume(ErrorString& errorString)
 {
-    if (!m_pausedScriptState && !m_javaScriptPauseScheduled) {
+    if (!m_pausedGlobalObject && !m_javaScriptPauseScheduled) {
         errorString = "Must be paused or waiting to pause"_s;
         return;
     }
 
     cancelPauseOnNextStatement();
@@ -804,10 +830,15 @@
         ErrorString ignored;
         pause(ignored);
     }
 }
 
+void InspectorDebuggerAgent::setPauseOnDebuggerStatements(ErrorString&, bool enabled)
+{
+    m_scriptDebugServer.setPauseOnDebuggerStatements(enabled);
+}
+
 void InspectorDebuggerAgent::setPauseOnExceptions(ErrorString& errorString, const String& stringPauseState)
 {
     JSC::Debugger::PauseOnExceptionsState pauseState;
     if (stringPauseState == "none")
         pauseState = JSC::Debugger::DontPauseOnExceptions;
@@ -862,10 +893,55 @@
         unmuteConsole();
         m_scriptDebugServer.setPauseOnExceptionsState(pauseState);
     }
 }
 
+void InspectorDebuggerAgent::setShouldBlackboxURL(ErrorString& errorString, const String& url, bool shouldBlackbox, const bool* optionalCaseSensitive, const bool* optionalIsRegex)
+{
+    if (url.isEmpty()) {
+        errorString = "URL must not be empty"_s;
+        return;
+    }
+
+    bool caseSensitive = optionalCaseSensitive && *optionalCaseSensitive;
+    bool isRegex = optionalIsRegex && *optionalIsRegex;
+
+    if (!caseSensitive && !isRegex && isWebKitInjectedScript(url)) {
+        errorString = "Blackboxing of internal scripts is controlled by 'Debugger.setPauseForInternalScripts'"_s;
+        return;
+    }
+
+    BlackboxConfig config { url, caseSensitive, isRegex };
+    if (shouldBlackbox)
+        m_blackboxedURLs.appendIfNotContains(config);
+    else
+        m_blackboxedURLs.removeAll(config);
+
+    for (auto& [sourceID, script] : m_scripts) {
+        if (isWebKitInjectedScript(script.sourceURL))
+            continue;
+
+        Optional<JSC::Debugger::BlackboxType> blackboxType;
+        if (shouldBlackboxURL(script.sourceURL) || shouldBlackboxURL(script.url))
+            blackboxType = JSC::Debugger::BlackboxType::Deferred;
+        m_scriptDebugServer.setBlackboxType(sourceID, blackboxType);
+    }
+}
+
+bool InspectorDebuggerAgent::shouldBlackboxURL(const String& url) const
+{
+    if (!url.isEmpty()) {
+        for (const auto& blackboxConfig : m_blackboxedURLs) {
+            auto searchStringType = blackboxConfig.isRegex ? ContentSearchUtilities::SearchStringType::Regex : ContentSearchUtilities::SearchStringType::ExactString;
+            auto regex = ContentSearchUtilities::createRegularExpressionForSearchString(blackboxConfig.url, blackboxConfig.caseSensitive, searchStringType);
+            if (regex.match(url) != -1)
+                return true;
+        }
+    }
+    return false;
+}
+
 void InspectorDebuggerAgent::scriptExecutionBlockedByCSP(const String& directiveText)
 {
     if (m_scriptDebugServer.pauseOnExceptionsState() != JSC::Debugger::DontPauseOnExceptions)
         breakProgram(DebuggerFrontendDispatcher::Reason::CSPViolation, buildCSPViolationPauseReason(directiveText));
 }
@@ -889,17 +965,16 @@
     if (shouldPause == m_pauseForInternalScripts)
         return;
 
     m_pauseForInternalScripts = shouldPause;
 
-    if (m_pauseForInternalScripts)
-        m_scriptDebugServer.clearBlacklist();
-}
-
-static bool isWebKitInjectedScript(const String& sourceURL)
-{
-    return sourceURL.startsWith("__InjectedScript_") && sourceURL.endsWith(".js");
+    auto blackboxType = !m_pauseForInternalScripts ? Optional<JSC::Debugger::BlackboxType>(JSC::Debugger::BlackboxType::Ignored) : WTF::nullopt;
+    for (auto& [sourceID, script] : m_scripts) {
+        if (!isWebKitInjectedScript(script.sourceURL))
+            continue;
+        m_scriptDebugServer.setBlackboxType(sourceID, blackboxType);
+    }
 }
 
 void InspectorDebuggerAgent::didParseSource(JSC::SourceID sourceID, const Script& script)
 {
     String scriptIDStr = String::number(sourceID);
@@ -914,12 +989,15 @@
 
     m_frontendDispatcher->scriptParsed(scriptIDStr, script.url, script.startLine, script.startColumn, script.endLine, script.endColumn, isContentScript, sourceURLParam, sourceMapURLParam, isModule ? &isModule : nullptr);
 
     m_scripts.set(sourceID, script);
 
-    if (hasSourceURL && isWebKitInjectedScript(sourceURL) && !m_pauseForInternalScripts)
-        m_scriptDebugServer.addToBlacklist(sourceID);
+    if (isWebKitInjectedScript(sourceURL)) {
+        if (!m_pauseForInternalScripts)
+            m_scriptDebugServer.setBlackboxType(sourceID, JSC::Debugger::BlackboxType::Ignored);
+    } else if (shouldBlackboxURL(sourceURL) || shouldBlackboxURL(script.url))
+        m_scriptDebugServer.setBlackboxType(sourceID, JSC::Debugger::BlackboxType::Deferred);
 
     String scriptURLForBreakpoints = hasSourceURL ? script.sourceURL : script.url;
     if (scriptURLForBreakpoints.isEmpty())
         return;
 
@@ -985,37 +1063,43 @@
 
     if (m_pauseOnMicrotasks)
         cancelPauseOnNextStatement();
 }
 
-void InspectorDebuggerAgent::didPause(JSC::ExecState& scriptState, JSC::JSValue callFrames, JSC::JSValue exceptionOrCaughtValue)
+void InspectorDebuggerAgent::didPause(JSC::JSGlobalObject* globalObject, JSC::JSValue callFrames, JSC::JSValue exceptionOrCaughtValue)
 {
-    ASSERT(!m_pausedScriptState);
-    m_pausedScriptState = &scriptState;
-    m_currentCallStack = { scriptState.vm(), callFrames };
+    ASSERT(!m_pausedGlobalObject);
+    m_pausedGlobalObject = globalObject;
+    m_currentCallStack = { globalObject->vm(), callFrames };
 
-    InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(&scriptState);
+    InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(globalObject);
 
     // If a high level pause pause reason is not already set, try to infer a reason from the debugger.
-    if (m_breakReason == DebuggerFrontendDispatcher::Reason::Other) {
+    if (m_pauseReason == DebuggerFrontendDispatcher::Reason::Other) {
         switch (m_scriptDebugServer.reasonForPause()) {
         case JSC::Debugger::PausedForBreakpoint: {
-            JSC::BreakpointID debuggerBreakpointId = m_scriptDebugServer.pausingBreakpointID();
-            if (debuggerBreakpointId != m_continueToLocationBreakpointID) {
-                m_breakReason = DebuggerFrontendDispatcher::Reason::Breakpoint;
-                m_breakData = buildBreakpointPauseReason(debuggerBreakpointId);
-            }
+            auto debuggerBreakpointId = m_scriptDebugServer.pausingBreakpointID();
+            if (debuggerBreakpointId != m_continueToLocationBreakpointID)
+                updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason::Breakpoint, buildBreakpointPauseReason(debuggerBreakpointId));
             break;
         }
         case JSC::Debugger::PausedForDebuggerStatement:
-            m_breakReason = DebuggerFrontendDispatcher::Reason::DebuggerStatement;
-            m_breakData = nullptr;
+            updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason::DebuggerStatement, nullptr);
             break;
         case JSC::Debugger::PausedForException:
-            m_breakReason = DebuggerFrontendDispatcher::Reason::Exception;
-            m_breakData = buildExceptionPauseReason(exceptionOrCaughtValue, injectedScript);
+            updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason::Exception, buildExceptionPauseReason(exceptionOrCaughtValue, injectedScript));
+            break;
+        case JSC::Debugger::PausedAfterBlackboxedScript: {
+            // There should be no break data, as we would've already continued past the breakpoint.
+            ASSERT(!m_pauseData);
+
+            // Don't call `updatePauseReasonAndData` so as to not override `m_preBlackboxPauseData`.
+            if (m_pauseReason != DebuggerFrontendDispatcher::Reason::BlackboxedScript)
+                m_preBlackboxPauseReason = m_pauseReason;
+            m_pauseReason = DebuggerFrontendDispatcher::Reason::BlackboxedScript;
             break;
+        }
         case JSC::Debugger::PausedAtStatement:
         case JSC::Debugger::PausedAtExpression:
         case JSC::Debugger::PausedBeforeReturn:
         case JSC::Debugger::PausedAtEndOfProgram:
             // Pause was just stepping. Nothing to report.
@@ -1024,10 +1108,28 @@
             ASSERT_NOT_REACHED();
             break;
         }
     }
 
+    if (m_scriptDebugServer.reasonForPause() == JSC::Debugger::PausedAfterBlackboxedScript) {
+        // Ensure that `m_preBlackboxPauseReason` is populated with the most recent data.
+        updatePauseReasonAndData(m_pauseReason, nullptr);
+
+        RefPtr<JSON::Object> data;
+        if (auto debuggerBreakpointId = m_scriptDebugServer.pausingBreakpointID()) {
+            ASSERT(debuggerBreakpointId != m_continueToLocationBreakpointID);
+            data = JSON::Object::create();
+            data->setString("originalReason"_s, Protocol::InspectorHelpers::getEnumConstantValue(DebuggerFrontendDispatcher::Reason::Breakpoint));
+            data->setValue("originalData"_s, buildBreakpointPauseReason(debuggerBreakpointId));
+        } else if (m_preBlackboxPauseData) {
+            data = JSON::Object::create();
+            data->setString("originalReason"_s, Protocol::InspectorHelpers::getEnumConstantValue(m_preBlackboxPauseReason));
+            data->setValue("originalData"_s, m_preBlackboxPauseData);
+        }
+        updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason::BlackboxedScript, WTFMove(data));
+    }
+
     // Set $exception to the exception or caught value.
     if (exceptionOrCaughtValue && !injectedScript.hasNoValue()) {
         injectedScript.setExceptionValue(exceptionOrCaughtValue);
         m_hasExceptionValue = true;
     }
@@ -1040,11 +1142,11 @@
         auto it = m_pendingAsyncCalls.find(m_currentAsyncCallIdentifier.value());
         if (it != m_pendingAsyncCalls.end())
             asyncStackTrace = it->value->buildInspectorObject();
     }
 
-    m_frontendDispatcher->paused(currentCallFrames(injectedScript), m_breakReason, m_breakData, asyncStackTrace);
+    m_frontendDispatcher->paused(currentCallFrames(injectedScript), m_pauseReason, m_pauseData, asyncStackTrace);
 
     m_javaScriptPauseScheduled = false;
 
     if (m_continueToLocationBreakpointID != JSC::noBreakpointID) {
         m_scriptDebugServer.removeBreakpoint(m_continueToLocationBreakpointID);
@@ -1061,13 +1163,13 @@
 void InspectorDebuggerAgent::breakpointActionSound(int breakpointActionIdentifier)
 {
     m_frontendDispatcher->playBreakpointActionSound(breakpointActionIdentifier);
 }
 
-void InspectorDebuggerAgent::breakpointActionProbe(JSC::ExecState& scriptState, const ScriptBreakpointAction& action, unsigned batchId, unsigned sampleId, JSC::JSValue sample)
+void InspectorDebuggerAgent::breakpointActionProbe(JSC::JSGlobalObject* globalObject, const ScriptBreakpointAction& action, unsigned batchId, unsigned sampleId, JSC::JSValue sample)
 {
-    InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(&scriptState);
+    InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(globalObject);
     auto payload = injectedScript.wrapObject(sample, objectGroupForBreakpointAction(action), true);
     auto result = Protocol::Debugger::ProbeSample::create()
         .setProbeId(action.identifier)
         .setBatchId(batchId)
         .setSampleId(sampleId)
@@ -1082,24 +1184,24 @@
     if (m_didPauseStopwatch) {
         m_didPauseStopwatch = false;
         m_injectedScriptManager.inspectorEnvironment().executionStopwatch()->start();
     }
 
-    m_pausedScriptState = nullptr;
+    m_pausedGlobalObject = nullptr;
     m_currentCallStack = { };
     m_injectedScriptManager.releaseObjectGroup(InspectorDebuggerAgent::backtraceObjectGroup);
-    clearBreakDetails();
+    clearPauseDetails();
     clearExceptionValue();
 
     if (m_conditionToDispatchResumed == ShouldDispatchResumed::WhenContinued)
         m_frontendDispatcher->resumed();
 }
 
-void InspectorDebuggerAgent::breakProgram(DebuggerFrontendDispatcher::Reason breakReason, RefPtr<JSON::Object>&& data)
+void InspectorDebuggerAgent::breakProgram(DebuggerFrontendDispatcher::Reason reason, RefPtr<JSON::Object>&& data)
 {
-    m_breakReason = breakReason;
-    m_breakData = WTFMove(data);
+    updatePauseReasonAndData(reason, WTFMove(data));
+
     m_scriptDebugServer.breakProgram();
 }
 
 void InspectorDebuggerAgent::clearInspectorBreakpointState()
 {
@@ -1116,20 +1218,20 @@
 {
     {
         JSC::JSLockHolder holder(m_scriptDebugServer.vm());
         m_scriptDebugServer.clearBreakpointActions();
         m_scriptDebugServer.clearBreakpoints();
-        m_scriptDebugServer.clearBlacklist();
+        m_scriptDebugServer.clearBlackbox();
     }
 
-    m_pausedScriptState = nullptr;
+    m_pausedGlobalObject = nullptr;
     m_currentCallStack = { };
     m_scripts.clear();
     m_breakpointIdentifierToDebugServerBreakpointIDs.clear();
     m_debuggerBreakpointIdentifierToInspectorBreakpointIdentifier.clear();
     m_continueToLocationBreakpointID = JSC::noBreakpointID;
-    clearBreakDetails();
+    clearPauseDetails();
     m_javaScriptPauseScheduled = false;
     m_hasExceptionValue = false;
 
     if (isPaused()) {
         m_scriptDebugServer.continueProgram();
@@ -1148,22 +1250,21 @@
     m_frontendDispatcher->globalObjectCleared();
 }
 
 bool InspectorDebuggerAgent::assertPaused(ErrorString& errorString)
 {
-    if (!m_pausedScriptState) {
+    if (!m_pausedGlobalObject) {
         errorString = "Must be paused"_s;
         return false;
     }
 
     return true;
 }
 
-void InspectorDebuggerAgent::clearBreakDetails()
+void InspectorDebuggerAgent::clearPauseDetails()
 {
-    m_breakReason = DebuggerFrontendDispatcher::Reason::Other;
-    m_breakData = nullptr;
+    updatePauseReasonAndData(DebuggerFrontendDispatcher::Reason::Other, nullptr);
 }
 
 void InspectorDebuggerAgent::clearExceptionValue()
 {
     if (m_hasExceptionValue) {

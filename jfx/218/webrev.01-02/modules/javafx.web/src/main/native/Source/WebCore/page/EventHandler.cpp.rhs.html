<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/EventHandler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (C) 2006-2020 Apple Inc. All rights reserved.</span>
   3  * Copyright (C) 2006 Alexey Proskuryakov (ap@webkit.org)
   4  * Copyright (C) 2012 Digia Plc. and/or its subsidiary(-ies)
   5  *
   6  * Redistribution and use in source and binary forms, with or without
   7  * modification, are permitted provided that the following conditions
   8  * are met:
   9  * 1. Redistributions of source code must retain the above copyright
  10  *    notice, this list of conditions and the following disclaimer.
  11  * 2. Redistributions in binary form must reproduce the above copyright
  12  *    notice, this list of conditions and the following disclaimer in the
  13  *    documentation and/or other materials provided with the distribution.
  14  *
  15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  26  */
  27 
  28 #include &quot;config.h&quot;
  29 #include &quot;EventHandler.h&quot;
  30 
  31 #include &quot;AutoscrollController.h&quot;
  32 #include &quot;BackForwardController.h&quot;
  33 #include &quot;CachedImage.h&quot;
  34 #include &quot;Chrome.h&quot;
  35 #include &quot;ChromeClient.h&quot;
  36 #include &quot;ComposedTreeAncestorIterator.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  37 #include &quot;ComposedTreeIterator.h&quot;</span>
  38 #include &quot;CursorList.h&quot;
  39 #include &quot;DocumentMarkerController.h&quot;
  40 #include &quot;DragController.h&quot;
<a name="3" id="anc3"></a><span class="line-added">  41 #include &quot;DragEvent.h&quot;</span>
  42 #include &quot;DragState.h&quot;
  43 #include &quot;Editing.h&quot;
  44 #include &quot;Editor.h&quot;
  45 #include &quot;EditorClient.h&quot;
  46 #include &quot;EventNames.h&quot;
  47 #include &quot;FileList.h&quot;
  48 #include &quot;FloatPoint.h&quot;
  49 #include &quot;FloatRect.h&quot;
  50 #include &quot;FocusController.h&quot;
  51 #include &quot;Frame.h&quot;
  52 #include &quot;FrameLoader.h&quot;
  53 #include &quot;FrameSelection.h&quot;
  54 #include &quot;FrameTree.h&quot;
  55 #include &quot;FrameView.h&quot;
  56 #include &quot;FullscreenManager.h&quot;
  57 #include &quot;HTMLDocument.h&quot;
  58 #include &quot;HTMLFrameElement.h&quot;
  59 #include &quot;HTMLFrameSetElement.h&quot;
  60 #include &quot;HTMLHtmlElement.h&quot;
  61 #include &quot;HTMLIFrameElement.h&quot;
  62 #include &quot;HTMLInputElement.h&quot;
  63 #include &quot;HTMLNames.h&quot;
  64 #include &quot;HitTestRequest.h&quot;
  65 #include &quot;HitTestResult.h&quot;
  66 #include &quot;Image.h&quot;
  67 #include &quot;InspectorInstrumentation.h&quot;
  68 #include &quot;KeyboardEvent.h&quot;
  69 #include &quot;Logging.h&quot;
  70 #include &quot;MouseEvent.h&quot;
  71 #include &quot;MouseEventWithHitTestResults.h&quot;
  72 #include &quot;NotImplemented.h&quot;
  73 #include &quot;Page.h&quot;
  74 #include &quot;PageOverlayController.h&quot;
  75 #include &quot;Pasteboard.h&quot;
  76 #include &quot;PlatformEvent.h&quot;
  77 #include &quot;PlatformKeyboardEvent.h&quot;
  78 #include &quot;PlatformWheelEvent.h&quot;
  79 #include &quot;PluginDocument.h&quot;
  80 #include &quot;Range.h&quot;
  81 #include &quot;RenderFrameSet.h&quot;
  82 #include &quot;RenderLayer.h&quot;
  83 #include &quot;RenderListBox.h&quot;
  84 #include &quot;RenderTextControlSingleLine.h&quot;
  85 #include &quot;RenderView.h&quot;
  86 #include &quot;RenderWidget.h&quot;
  87 #include &quot;ResourceLoadObserver.h&quot;
  88 #include &quot;RuntimeApplicationChecks.h&quot;
  89 #include &quot;SVGDocument.h&quot;
  90 #include &quot;SVGNames.h&quot;
  91 #include &quot;ScrollLatchingState.h&quot;
  92 #include &quot;Scrollbar.h&quot;
  93 #include &quot;Settings.h&quot;
  94 #include &quot;ShadowRoot.h&quot;
  95 #include &quot;SpatialNavigation.h&quot;
  96 #include &quot;StaticPasteboard.h&quot;
  97 #include &quot;StyleCachedImage.h&quot;
  98 #include &quot;TextEvent.h&quot;
  99 #include &quot;TextIterator.h&quot;
 100 #include &quot;UserGestureIndicator.h&quot;
 101 #include &quot;UserTypingGestureIndicator.h&quot;
 102 #include &quot;ValidationMessageClient.h&quot;
 103 #include &quot;VisibleUnits.h&quot;
 104 #include &quot;WheelEvent.h&quot;
 105 #include &quot;WheelEventDeltaFilter.h&quot;
 106 #include &quot;WindowsKeyboardCodes.h&quot;
 107 #include &lt;wtf/Assertions.h&gt;
 108 #include &lt;wtf/NeverDestroyed.h&gt;
 109 #include &lt;wtf/StdLibExtras.h&gt;
 110 
 111 #if ENABLE(IOS_TOUCH_EVENTS)
 112 #include &quot;PlatformTouchEventIOS.h&quot;
 113 #endif
 114 
 115 #if ENABLE(TOUCH_EVENTS)
 116 #include &quot;TouchEvent.h&quot;
 117 #include &quot;TouchList.h&quot;
 118 #endif
 119 
 120 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 121 #include &quot;PlatformTouchEvent.h&quot;
 122 #endif
 123 
 124 #if ENABLE(MAC_GESTURE_EVENTS)
 125 #include &quot;PlatformGestureEventMac.h&quot;
 126 #endif
 127 
 128 #if ENABLE(POINTER_LOCK)
 129 #include &quot;PointerLockController.h&quot;
 130 #endif
 131 
<a name="4" id="anc4"></a>



 132 #if PLATFORM(IOS_FAMILY)
 133 #include &quot;DOMTimerHoldingTank.h&quot;
 134 #endif
 135 
 136 namespace WebCore {
 137 
 138 using namespace HTMLNames;
 139 
 140 #if ENABLE(DRAG_SUPPORT)
 141 // The link drag hysteresis is much larger than the others because there
 142 // needs to be enough space to cancel the link press without starting a link drag,
 143 // and because dragging links is rare.
 144 const int LinkDragHysteresis = 40;
 145 const int ImageDragHysteresis = 5;
 146 const int TextDragHysteresis = 3;
 147 const int ColorDragHystersis = 3;
 148 const int GeneralDragHysteresis = 3;
 149 #if PLATFORM(MAC)
 150 const Seconds EventHandler::TextDragDelay { 150_ms };
 151 #else
 152 const Seconds EventHandler::TextDragDelay { 0_s };
 153 #endif
 154 #endif // ENABLE(DRAG_SUPPORT)
 155 
 156 #if ENABLE(IOS_GESTURE_EVENTS) || ENABLE(MAC_GESTURE_EVENTS)
 157 const float GestureUnknown = 0;
 158 #endif
 159 
 160 #if ENABLE(IOS_TOUCH_EVENTS)
 161 // FIXME: Share this constant with EventHandler and SliderThumbElement.
 162 const unsigned InvalidTouchIdentifier = 0;
 163 #endif
 164 
 165 // Match key code of composition keydown event on windows.
 166 // IE sends VK_PROCESSKEY which has value 229;
 167 const int CompositionEventKeyCode = 229;
 168 
 169 using namespace SVGNames;
 170 
 171 #if !ENABLE(IOS_TOUCH_EVENTS)
 172 // The amount of time to wait before sending a fake mouse event, triggered
 173 // during a scroll. The short interval is used if the content responds to the mouse events
 174 // in fakeMouseMoveDurationThreshold or less, otherwise the long interval is used.
 175 const double fakeMouseMoveDurationThreshold = 0.01;
 176 const Seconds fakeMouseMoveShortInterval = { 100_ms };
 177 const Seconds fakeMouseMoveLongInterval = { 250_ms };
 178 #endif
 179 
<a name="5" id="anc5"></a>
 180 // The amount of time to wait for a cursor update on style and layout changes
 181 // Set to 50Hz, no need to be faster than common screen refresh rate
 182 static const Seconds cursorUpdateInterval { 20_ms };
 183 
 184 const int maximumCursorSize = 128;
<a name="6" id="anc6"></a>
 185 
 186 #if ENABLE(MOUSE_CURSOR_SCALE)
 187 // It&#39;s pretty unlikely that a scale of less than one would ever be used. But all we really
 188 // need to ensure here is that the scale isn&#39;t so small that integer overflow can occur when
 189 // dividing cursor sizes (limited above) by the scale.
 190 const double minimumCursorScale = 0.001;
 191 #endif
 192 
 193 class MaximumDurationTracker {
 194 public:
 195     explicit MaximumDurationTracker(double *maxDuration)
 196         : m_maxDuration(maxDuration)
 197         , m_start(MonotonicTime::now())
 198     {
 199     }
 200 
 201     ~MaximumDurationTracker()
 202     {
 203         *m_maxDuration = std::max(*m_maxDuration, (MonotonicTime::now() - m_start).seconds());
 204     }
 205 
 206 private:
 207     double* m_maxDuration;
 208     MonotonicTime m_start;
 209 };
 210 
 211 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 212 class SyntheticTouchPoint : public PlatformTouchPoint {
 213 public:
 214 
 215     // The default values are based on http://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
 216     explicit SyntheticTouchPoint(const PlatformMouseEvent&amp; event)
 217     {
<a name="7" id="anc7"></a><span class="line-modified"> 218         static constexpr int idDefaultValue = 0;</span>
<span class="line-modified"> 219         static constexpr int radiusYDefaultValue = 1;</span>
<span class="line-modified"> 220         static constexpr int radiusXDefaultValue = 1;</span>
<span class="line-modified"> 221         static constexpr float rotationAngleDefaultValue = 0.0f;</span>
<span class="line-modified"> 222         static constexpr float forceDefaultValue = 1.0f;</span>
 223 
 224         m_id = idDefaultValue; // There is only one active TouchPoint.
 225         m_screenPos = event.globalPosition();
 226         m_pos = event.position();
 227         m_radiusY = radiusYDefaultValue;
 228         m_radiusX = radiusXDefaultValue;
 229         m_rotationAngle = rotationAngleDefaultValue;
 230         m_force = forceDefaultValue;
 231 
 232         PlatformEvent::Type type = event.type();
 233         ASSERT(type == PlatformEvent::MouseMoved || type == PlatformEvent::MousePressed || type == PlatformEvent::MouseReleased);
 234 
 235         switch (type) {
 236         case PlatformEvent::MouseMoved:
 237             m_state = TouchMoved;
 238             break;
 239         case PlatformEvent::MousePressed:
 240             m_state = TouchPressed;
 241             break;
 242         case PlatformEvent::MouseReleased:
 243             m_state = TouchReleased;
 244             break;
 245         default:
 246             ASSERT_NOT_REACHED();
 247             break;
 248         }
 249     }
 250 };
 251 
 252 class SyntheticSingleTouchEvent : public PlatformTouchEvent {
 253 public:
 254     explicit SyntheticSingleTouchEvent(const PlatformMouseEvent&amp; event)
 255     {
 256         switch (event.type()) {
 257         case PlatformEvent::MouseMoved:
 258             m_type = TouchMove;
 259             break;
 260         case PlatformEvent::MousePressed:
 261             m_type = TouchStart;
 262             break;
 263         case PlatformEvent::MouseReleased:
 264             m_type = TouchEnd;
 265             break;
 266         default:
 267             ASSERT_NOT_REACHED();
 268             m_type = NoType;
 269             break;
 270         }
 271         m_timestamp = event.timestamp();
 272         m_modifiers = event.modifiers();
 273         m_touchPoints.append(SyntheticTouchPoint(event));
 274     }
 275 };
 276 #endif // ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 277 
 278 static inline ScrollGranularity wheelGranularityToScrollGranularity(unsigned deltaMode)
 279 {
 280     switch (deltaMode) {
 281     case WheelEvent::DOM_DELTA_PAGE:
 282         return ScrollByPage;
 283     case WheelEvent::DOM_DELTA_LINE:
 284         return ScrollByLine;
 285     case WheelEvent::DOM_DELTA_PIXEL:
 286         return ScrollByPixel;
 287     default:
 288         return ScrollByPixel;
 289     }
 290 }
 291 
 292 static inline bool didScrollInScrollableArea(ScrollableArea* scrollableArea, WheelEvent&amp; wheelEvent)
 293 {
 294     ScrollGranularity scrollGranularity = wheelGranularityToScrollGranularity(wheelEvent.deltaMode());
 295     bool didHandleWheelEvent = false;
 296     if (float absoluteDelta = std::abs(wheelEvent.deltaX()))
 297         didHandleWheelEvent |= scrollableArea-&gt;scroll(wheelEvent.deltaX() &gt; 0 ? ScrollRight : ScrollLeft, scrollGranularity, absoluteDelta);
 298 
 299     if (float absoluteDelta = std::abs(wheelEvent.deltaY()))
 300         didHandleWheelEvent |= scrollableArea-&gt;scroll(wheelEvent.deltaY() &gt; 0 ? ScrollDown : ScrollUp, scrollGranularity, absoluteDelta);
 301 
 302     return didHandleWheelEvent;
 303 }
 304 
<a name="8" id="anc8"></a><span class="line-modified"> 305 static inline bool handleWheelEventInAppropriateEnclosingBox(Node* startNode, WheelEvent&amp; wheelEvent, RefPtr&lt;Element&gt;&amp; stopElement, const FloatSize&amp; filteredPlatformDelta, const FloatSize&amp; filteredVelocity)</span>
 306 {
 307     bool shouldHandleEvent = wheelEvent.deltaX() || wheelEvent.deltaY();
 308 #if PLATFORM(MAC)
 309     shouldHandleEvent |= wheelEvent.phase() == PlatformWheelEventPhaseEnded;
 310 #if ENABLE(CSS_SCROLL_SNAP)
 311     shouldHandleEvent |= wheelEvent.momentumPhase() == PlatformWheelEventPhaseEnded;
 312 #endif
 313 #endif
 314     if (!startNode-&gt;renderer() || !shouldHandleEvent)
 315         return false;
 316 
 317     RenderBox&amp; initialEnclosingBox = startNode-&gt;renderer()-&gt;enclosingBox();
 318     if (initialEnclosingBox.isListBox())
 319         return didScrollInScrollableArea(static_cast&lt;RenderListBox*&gt;(&amp;initialEnclosingBox), wheelEvent);
 320 
 321     RenderBox* currentEnclosingBox = &amp;initialEnclosingBox;
 322     while (currentEnclosingBox) {
 323         if (RenderLayer* boxLayer = currentEnclosingBox-&gt;layer()) {
 324             auto platformEvent = wheelEvent.underlyingPlatformEvent();
 325             bool scrollingWasHandled;
 326             if (platformEvent) {
 327                 auto copiedEvent = platformEvent-&gt;copyWithDeltasAndVelocity(filteredPlatformDelta.width(), filteredPlatformDelta.height(), filteredVelocity);
 328                 scrollingWasHandled = boxLayer-&gt;handleWheelEvent(copiedEvent);
 329             } else
 330                 scrollingWasHandled = didScrollInScrollableArea(boxLayer, wheelEvent);
 331 
 332             if (scrollingWasHandled) {
<a name="9" id="anc9"></a><span class="line-modified"> 333                 stopElement = currentEnclosingBox-&gt;element();</span>

 334                 return true;
 335             }
 336         }
 337 
<a name="10" id="anc10"></a><span class="line-modified"> 338         if (stopElement.get() &amp;&amp; stopElement.get() == currentEnclosingBox-&gt;element())</span>
 339             return true;
 340 
 341         currentEnclosingBox = currentEnclosingBox-&gt;containingBlock();
 342         if (!currentEnclosingBox || currentEnclosingBox-&gt;isRenderView())
 343             return false;
 344     }
 345     return false;
 346 }
 347 
 348 #if (ENABLE(TOUCH_EVENTS) &amp;&amp; !PLATFORM(IOS_FAMILY))
 349 static inline bool shouldGesturesTriggerActive()
 350 {
 351     // If the platform we&#39;re on supports GestureTapDown and GestureTapCancel then we&#39;ll
 352     // rely on them to set the active state. Unfortunately there&#39;s no generic way to
 353     // know in advance what event types are supported.
 354     return false;
 355 }
 356 #endif
 357 
 358 #if !PLATFORM(COCOA)
 359 
 360 inline bool EventHandler::eventLoopHandleMouseUp(const MouseEventWithHitTestResults&amp;)
 361 {
 362     return false;
 363 }
 364 
 365 #if ENABLE(DRAG_SUPPORT)
 366 inline bool EventHandler::eventLoopHandleMouseDragged(const MouseEventWithHitTestResults&amp;)
 367 {
 368     return false;
 369 }
 370 #endif
 371 
 372 #endif
 373 
 374 EventHandler::EventHandler(Frame&amp; frame)
 375     : m_frame(frame)
 376     , m_hoverTimer(*this, &amp;EventHandler::hoverTimerFired)
<a name="11" id="anc11"></a>
 377     , m_cursorUpdateTimer(*this, &amp;EventHandler::cursorUpdateTimerFired)
<a name="12" id="anc12"></a>
 378 #if PLATFORM(MAC)
 379     , m_pendingMomentumWheelEventsTimer(*this, &amp;EventHandler::clearLatchedState)
 380 #endif
 381     , m_autoscrollController(makeUnique&lt;AutoscrollController&gt;())
 382 #if !ENABLE(IOS_TOUCH_EVENTS)
 383     , m_fakeMouseMoveEventTimer(*this, &amp;EventHandler::fakeMouseMoveEventTimerFired)
 384 #endif
 385 #if ENABLE(CURSOR_VISIBILITY)
 386     , m_autoHideCursorTimer(*this, &amp;EventHandler::autoHideCursorTimerFired)
 387 #endif
 388 {
 389 }
 390 
 391 EventHandler::~EventHandler()
 392 {
 393 #if !ENABLE(IOS_TOUCH_EVENTS)
 394     ASSERT(!m_fakeMouseMoveEventTimer.isActive());
 395 #endif
 396 #if ENABLE(CURSOR_VISIBILITY)
 397     ASSERT(!m_autoHideCursorTimer.isActive());
 398 #endif
 399 }
 400 
 401 #if ENABLE(DRAG_SUPPORT)
 402 
 403 DragState&amp; EventHandler::dragState()
 404 {
 405     static NeverDestroyed&lt;DragState&gt; state;
 406     return state;
 407 }
 408 
 409 #endif
 410 
 411 void EventHandler::clear()
 412 {
 413     m_hoverTimer.stop();
<a name="13" id="anc13"></a>
 414     m_cursorUpdateTimer.stop();
<a name="14" id="anc14"></a>
 415 #if !ENABLE(IOS_TOUCH_EVENTS)
 416     m_fakeMouseMoveEventTimer.stop();
 417 #endif
 418 #if ENABLE(CURSOR_VISIBILITY)
 419     cancelAutoHideCursorTimer();
 420 #endif
 421     m_resizeLayer = nullptr;
 422     m_elementUnderMouse = nullptr;
 423     m_lastElementUnderMouse = nullptr;
 424     m_lastMouseMoveEventSubframe = nullptr;
 425     m_lastScrollbarUnderMouse = nullptr;
 426     m_clickCount = 0;
 427     m_clickNode = nullptr;
 428 #if ENABLE(IOS_GESTURE_EVENTS)
 429     m_gestureInitialDiameter = GestureUnknown;
 430     m_gestureInitialRotation = GestureUnknown;
 431 #endif
 432 #if ENABLE(IOS_GESTURE_EVENTS) || ENABLE(MAC_GESTURE_EVENTS)
 433     m_gestureLastDiameter = GestureUnknown;
 434     m_gestureLastRotation = GestureUnknown;
 435     m_gestureTargets.clear();
 436 #endif
 437 #if ENABLE(IOS_TOUCH_EVENTS)
 438     m_touches.clear();
 439     m_firstTouchID = InvalidTouchIdentifier;
 440     m_touchEventTargetSubframe = nullptr;
 441 #endif
 442     m_frameSetBeingResized = nullptr;
 443 #if ENABLE(DRAG_SUPPORT)
 444     m_dragTarget = nullptr;
 445     m_shouldOnlyFireDragOverEvent = false;
 446 #endif
 447     m_mousePositionIsUnknown = true;
 448     m_lastKnownMousePosition = IntPoint();
 449     m_lastKnownMouseGlobalPosition = IntPoint();
 450     m_mousePressNode = nullptr;
 451     m_mousePressed = false;
 452     m_capturesDragging = false;
 453     m_capturingMouseEventsElement = nullptr;
 454     clearLatchedState();
 455 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
 456     m_originatingTouchPointTargets.clear();
 457     m_originatingTouchPointDocument = nullptr;
 458     m_originatingTouchPointTargetKey = 0;
 459 #endif
 460     m_maxMouseMovedDuration = 0;
 461     m_didStartDrag = false;
 462 }
 463 
 464 void EventHandler::nodeWillBeRemoved(Node&amp; nodeToBeRemoved)
 465 {
 466     if (nodeToBeRemoved.contains(m_clickNode.get()))
 467         m_clickNode = nullptr;
 468 }
 469 
 470 static void setSelectionIfNeeded(FrameSelection&amp; selection, const VisibleSelection&amp; newSelection)
 471 {
 472     if (selection.selection() != newSelection &amp;&amp; selection.shouldChangeSelection(newSelection))
 473         selection.setSelection(newSelection);
 474 }
 475 
 476 static inline bool dispatchSelectStart(Node* node)
 477 {
 478     if (!node || !node-&gt;renderer())
 479         return true;
 480 
 481     auto event = Event::create(eventNames().selectstartEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes);
 482     node-&gt;dispatchEvent(event);
 483     return !event-&gt;defaultPrevented();
 484 }
 485 
 486 static Node* nodeToSelectOnMouseDownForNode(Node&amp; targetNode)
 487 {
 488 #if ENABLE(USERSELECT_ALL)
 489     if (Node* rootUserSelectAll = Position::rootUserSelectAllForNode(&amp;targetNode))
 490         return rootUserSelectAll;
 491 #endif
 492 
 493     if (targetNode.shouldSelectOnMouseDown())
 494         return &amp;targetNode;
 495 
 496     return nullptr;
 497 }
 498 
 499 static VisibleSelection expandSelectionToRespectSelectOnMouseDown(Node&amp; targetNode, const VisibleSelection&amp; selection)
 500 {
 501     Node* nodeToSelect = nodeToSelectOnMouseDownForNode(targetNode);
 502     if (!nodeToSelect)
 503         return selection;
 504 
 505     VisibleSelection newSelection(selection);
 506     newSelection.setBase(positionBeforeNode(nodeToSelect).upstream(CanCrossEditingBoundary));
 507     newSelection.setExtent(positionAfterNode(nodeToSelect).downstream(CanCrossEditingBoundary));
 508 
 509     return newSelection;
 510 }
 511 
 512 bool EventHandler::updateSelectionForMouseDownDispatchingSelectStart(Node* targetNode, const VisibleSelection&amp; selection, TextGranularity granularity)
 513 {
 514     if (Position::nodeIsUserSelectNone(targetNode))
 515         return false;
 516 
 517     if (!dispatchSelectStart(targetNode)) {
 518         m_mouseDownMayStartSelect = false;
 519         return false;
 520     }
 521 
 522     if (selection.isRange())
 523         m_selectionInitiationState = ExtendedSelection;
 524     else {
 525         granularity = CharacterGranularity;
 526         m_selectionInitiationState = PlacedCaret;
 527     }
 528 
 529     m_frame.selection().setSelectionByMouseIfDifferent(selection, granularity);
 530 
 531     return true;
 532 }
 533 
 534 void EventHandler::selectClosestWordFromHitTestResult(const HitTestResult&amp; result, AppendTrailingWhitespace appendTrailingWhitespace)
 535 {
 536     Node* targetNode = result.targetNode();
 537     VisibleSelection newSelection;
 538 
 539     if (targetNode &amp;&amp; targetNode-&gt;renderer()) {
 540         VisiblePosition pos(targetNode-&gt;renderer()-&gt;positionForPoint(result.localPoint(), nullptr));
 541         if (pos.isNotNull()) {
 542             newSelection = VisibleSelection(pos);
 543             newSelection.expandUsingGranularity(WordGranularity);
 544         }
 545 
 546         if (appendTrailingWhitespace == ShouldAppendTrailingWhitespace &amp;&amp; newSelection.isRange())
 547             newSelection.appendTrailingWhitespace();
 548 
 549         updateSelectionForMouseDownDispatchingSelectStart(targetNode, expandSelectionToRespectSelectOnMouseDown(*targetNode, newSelection), WordGranularity);
 550     }
 551 }
 552 
 553 static AppendTrailingWhitespace shouldAppendTrailingWhitespace(const MouseEventWithHitTestResults&amp; result, const Frame&amp; frame)
 554 {
 555     return (result.event().clickCount() == 2 &amp;&amp; frame.editor().isSelectTrailingWhitespaceEnabled()) ? ShouldAppendTrailingWhitespace : DontAppendTrailingWhitespace;
 556 }
 557 
 558 void EventHandler::selectClosestWordFromMouseEvent(const MouseEventWithHitTestResults&amp; result)
 559 {
 560     if (m_mouseDownMayStartSelect)
 561         selectClosestWordFromHitTestResult(result.hitTestResult(), shouldAppendTrailingWhitespace(result, m_frame));
 562 }
 563 
 564 #if !PLATFORM(MAC)
 565 VisibleSelection EventHandler::selectClosestWordFromHitTestResultBasedOnLookup(const HitTestResult&amp;)
 566 {
 567     return VisibleSelection();
 568 }
 569 #endif
 570 
 571 void EventHandler::selectClosestContextualWordFromMouseEvent(const MouseEventWithHitTestResults&amp; mouseEvent)
 572 {
 573     Node* targetNode = mouseEvent.targetNode();
 574     const HitTestResult&amp; result = mouseEvent.hitTestResult();
 575     VisibleSelection newSelection;
 576     bool appendTrailingWhitespace = shouldAppendTrailingWhitespace(mouseEvent, m_frame);
 577 
 578     if (targetNode &amp;&amp; targetNode-&gt;renderer()) {
 579         newSelection = selectClosestWordFromHitTestResultBasedOnLookup(result);
 580         if (newSelection.isNone()) {
 581             VisiblePosition pos(targetNode-&gt;renderer()-&gt;positionForPoint(result.localPoint(), nullptr));
 582             if (pos.isNotNull()) {
 583                 newSelection = VisibleSelection(pos);
 584                 newSelection.expandUsingGranularity(WordGranularity);
 585             }
 586         }
 587 
 588         if (appendTrailingWhitespace == ShouldAppendTrailingWhitespace &amp;&amp; newSelection.isRange())
 589             newSelection.appendTrailingWhitespace();
 590 
 591         updateSelectionForMouseDownDispatchingSelectStart(targetNode, expandSelectionToRespectSelectOnMouseDown(*targetNode, newSelection), WordGranularity);
 592     }
 593 }
 594 
 595 void EventHandler::selectClosestContextualWordOrLinkFromMouseEvent(const MouseEventWithHitTestResults&amp; result)
 596 {
 597     Element* urlElement = result.hitTestResult().URLElement();
 598     if (!urlElement || !isDraggableLink(*urlElement)) {
 599         if (Node* targetNode = result.targetNode()) {
 600             if (isEditableNode(*targetNode))
 601                 return selectClosestWordFromMouseEvent(result);
 602         }
 603 
 604         return selectClosestContextualWordFromMouseEvent(result);
 605     }
 606 
 607     Node* targetNode = result.targetNode();
 608 
 609     if (targetNode &amp;&amp; targetNode-&gt;renderer() &amp;&amp; m_mouseDownMayStartSelect) {
 610         VisibleSelection newSelection;
 611         VisiblePosition pos(targetNode-&gt;renderer()-&gt;positionForPoint(result.localPoint(), nullptr));
 612         if (pos.isNotNull() &amp;&amp; pos.deepEquivalent().deprecatedNode()-&gt;isDescendantOf(*urlElement))
 613             newSelection = VisibleSelection::selectionFromContentsOfNode(urlElement);
 614 
 615         updateSelectionForMouseDownDispatchingSelectStart(targetNode, expandSelectionToRespectSelectOnMouseDown(*targetNode, newSelection), WordGranularity);
 616     }
 617 }
 618 
 619 bool EventHandler::handleMousePressEventDoubleClick(const MouseEventWithHitTestResults&amp; event)
 620 {
 621     if (event.event().button() != LeftButton)
 622         return false;
 623 
 624     if (m_frame.selection().isRange())
 625         // A double-click when range is already selected
 626         // should not change the selection.  So, do not call
 627         // selectClosestWordFromMouseEvent, but do set
 628         // m_beganSelectingText to prevent handleMouseReleaseEvent
 629         // from setting caret selection.
 630         m_selectionInitiationState = ExtendedSelection;
 631     else
 632         selectClosestWordFromMouseEvent(event);
 633 
 634     return true;
 635 }
 636 
 637 bool EventHandler::handleMousePressEventTripleClick(const MouseEventWithHitTestResults&amp; event)
 638 {
 639     if (event.event().button() != LeftButton)
 640         return false;
 641 
 642     Node* targetNode = event.targetNode();
 643     if (!(targetNode &amp;&amp; targetNode-&gt;renderer() &amp;&amp; m_mouseDownMayStartSelect))
 644         return false;
 645 
 646     VisibleSelection newSelection;
 647     VisiblePosition pos(targetNode-&gt;renderer()-&gt;positionForPoint(event.localPoint(), nullptr));
 648     if (pos.isNotNull()) {
 649         newSelection = VisibleSelection(pos);
 650         newSelection.expandUsingGranularity(ParagraphGranularity);
 651     }
 652 
 653     return updateSelectionForMouseDownDispatchingSelectStart(targetNode, expandSelectionToRespectSelectOnMouseDown(*targetNode, newSelection), ParagraphGranularity);
 654 }
 655 
 656 static int textDistance(const Position&amp; start, const Position&amp; end)
 657 {
 658     auto range = Range::create(start.anchorNode()-&gt;document(), start, end);
 659     return TextIterator::rangeLength(range.ptr(), true);
 660 }
 661 
 662 bool EventHandler::handleMousePressEventSingleClick(const MouseEventWithHitTestResults&amp; event)
 663 {
 664     Ref&lt;Frame&gt; protectedFrame(m_frame);
 665 
 666     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
 667     Node* targetNode = event.targetNode();
 668     if (!(targetNode &amp;&amp; targetNode-&gt;renderer() &amp;&amp; m_mouseDownMayStartSelect))
 669         return false;
 670 
 671     // Extend the selection if the Shift key is down, unless the click is in a link.
 672     bool extendSelection = event.event().shiftKey() &amp;&amp; !event.isOverLink();
 673 
 674     // Don&#39;t restart the selection when the mouse is pressed on an
 675     // existing selection so we can allow for text dragging.
 676     if (FrameView* view = m_frame.view()) {
 677         LayoutPoint vPoint = view-&gt;windowToContents(event.event().position());
 678         if (!extendSelection &amp;&amp; m_frame.selection().contains(vPoint)) {
 679             m_mouseDownWasSingleClickInSelection = true;
 680             return false;
 681         }
 682     }
 683 
 684     VisiblePosition visiblePos(targetNode-&gt;renderer()-&gt;positionForPoint(event.localPoint(), nullptr));
 685     if (visiblePos.isNull())
 686         visiblePos = VisiblePosition(firstPositionInOrBeforeNode(targetNode), DOWNSTREAM);
 687     Position pos = visiblePos.deepEquivalent();
 688 
 689     VisibleSelection newSelection = m_frame.selection().selection();
 690     TextGranularity granularity = CharacterGranularity;
 691 
 692     if (!m_frame.editor().client()-&gt;shouldAllowSingleClickToChangeSelection(*targetNode, newSelection))
 693         return true;
 694 
 695     if (extendSelection &amp;&amp; newSelection.isCaretOrRange()) {
 696         VisibleSelection selectionInUserSelectAll = expandSelectionToRespectSelectOnMouseDown(*targetNode, VisibleSelection(pos));
 697         if (selectionInUserSelectAll.isRange()) {
 698             if (comparePositions(selectionInUserSelectAll.start(), newSelection.start()) &lt; 0)
 699                 pos = selectionInUserSelectAll.start();
 700             else if (comparePositions(newSelection.end(), selectionInUserSelectAll.end()) &lt; 0)
 701                 pos = selectionInUserSelectAll.end();
 702         }
 703 
 704         if (!m_frame.editor().behavior().shouldConsiderSelectionAsDirectional() &amp;&amp; pos.isNotNull()) {
 705             // See &lt;rdar://problem/3668157&gt; REGRESSION (Mail): shift-click deselects when selection
 706             // was created right-to-left
 707             Position start = newSelection.start();
 708             Position end = newSelection.end();
 709             int distanceToStart = textDistance(start, pos);
 710             int distanceToEnd = textDistance(pos, end);
 711             if (distanceToStart &lt;= distanceToEnd)
 712                 newSelection = VisibleSelection(end, pos);
 713             else
 714                 newSelection = VisibleSelection(start, pos);
 715         } else
 716             newSelection.setExtent(pos);
 717 
 718         if (m_frame.selection().granularity() != CharacterGranularity) {
 719             granularity = m_frame.selection().granularity();
 720             newSelection.expandUsingGranularity(m_frame.selection().granularity());
 721         }
 722     } else
 723         newSelection = expandSelectionToRespectSelectOnMouseDown(*targetNode, visiblePos);
 724 
 725     bool handled = updateSelectionForMouseDownDispatchingSelectStart(targetNode, newSelection, granularity);
 726 
 727     if (event.event().button() == MiddleButton) {
 728         // Ignore handled, since we want to paste to where the caret was placed anyway.
 729         handled = handlePasteGlobalSelection(event.event()) || handled;
 730     }
 731     return handled;
 732 }
 733 
<a name="15" id="anc15"></a><span class="line-modified"> 734 bool EventHandler::canMouseDownStartSelect(const MouseEventWithHitTestResults&amp; event)</span>
 735 {
<a name="16" id="anc16"></a><span class="line-added"> 736     auto* node = event.targetNode();</span>
<span class="line-added"> 737 </span>
<span class="line-added"> 738     if (Page* page = m_frame.page()) {</span>
<span class="line-added"> 739         if (!page-&gt;chrome().client().shouldUseMouseEventForSelection(event.event()))</span>
<span class="line-added"> 740             return false;</span>
<span class="line-added"> 741     }</span>
<span class="line-added"> 742 </span>
 743     if (!node || !node-&gt;renderer())
 744         return true;
 745 
 746     return node-&gt;canStartSelection() || Position::nodeIsUserSelectAll(node);
 747 }
 748 
 749 bool EventHandler::handleMousePressEvent(const MouseEventWithHitTestResults&amp; event)
 750 {
 751     Ref&lt;Frame&gt; protectedFrame(m_frame);
 752 
 753 #if ENABLE(DRAG_SUPPORT)
 754     // Reset drag state.
 755     dragState().source = nullptr;
 756 #endif
 757 
 758 #if !ENABLE(IOS_TOUCH_EVENTS)
 759     cancelFakeMouseMoveEvent();
 760 #endif
 761 
 762     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
 763 
 764     if (ScrollView* scrollView = m_frame.view()) {
 765         if (scrollView-&gt;isPointInScrollbarCorner(event.event().position()))
 766             return false;
 767     }
 768 
 769     bool singleClick = event.event().clickCount() &lt;= 1;
 770 
 771     // If we got the event back, that must mean it wasn&#39;t prevented,
 772     // so it&#39;s allowed to start a drag or selection if it wasn&#39;t in a scrollbar.
<a name="17" id="anc17"></a><span class="line-modified"> 773     m_mouseDownMayStartSelect = canMouseDownStartSelect(event) &amp;&amp; !event.scrollbar();</span>
 774 
 775 #if ENABLE(DRAG_SUPPORT)
 776     // Careful that the drag starting logic stays in sync with eventMayStartDrag()
 777     // FIXME: eventMayStartDrag() does not check for shift key press, link or image event targets.
 778     // Bug: https://bugs.webkit.org/show_bug.cgi?id=155390
 779 
 780     // Single mouse down on links or images can always trigger drag-n-drop.
 781     bool isMouseDownOnLinkOrImage = event.isOverLink() || event.hitTestResult().image();
 782     m_mouseDownMayStartDrag = singleClick &amp;&amp; (!event.event().shiftKey() || isMouseDownOnLinkOrImage) &amp;&amp; shouldAllowMouseDownToStartDrag();
 783 #endif
 784 
 785     m_mouseDownWasSingleClickInSelection = false;
 786 
 787     m_mouseDown = event.event();
 788 
 789     if (m_immediateActionStage != ImmediateActionStage::PerformedHitTest)
 790         m_immediateActionStage = ImmediateActionStage::None;
 791 
 792     if (event.isOverWidget() &amp;&amp; passWidgetMouseDownEventToWidget(event))
 793         return true;
 794 
 795     if (is&lt;SVGDocument&gt;(*m_frame.document()) &amp;&amp; downcast&lt;SVGDocument&gt;(*m_frame.document()).zoomAndPanEnabled()) {
 796         if (event.event().shiftKey() &amp;&amp; singleClick) {
 797             m_svgPan = true;
 798             downcast&lt;SVGDocument&gt;(*m_frame.document()).startPan(m_frame.view()-&gt;windowToContents(event.event().position()));
 799             return true;
 800         }
 801     }
 802 
 803     // We don&#39;t do this at the start of mouse down handling,
 804     // because we don&#39;t want to do it until we know we didn&#39;t hit a widget.
 805     if (singleClick)
 806         focusDocumentView();
 807 
 808     m_mousePressNode = event.targetNode();
 809     m_frame.document()-&gt;setFocusNavigationStartingNode(event.targetNode());
 810 
 811 #if ENABLE(DRAG_SUPPORT)
 812     m_dragStartPosition = event.event().position();
 813 #endif
 814 
 815     m_mousePressed = true;
 816     m_selectionInitiationState = HaveNotStartedSelection;
 817 
 818     bool swallowEvent = false;
 819     if (event.event().clickCount() == 2)
 820         swallowEvent = handleMousePressEventDoubleClick(event);
 821     else if (event.event().clickCount() &gt;= 3)
 822         swallowEvent = handleMousePressEventTripleClick(event);
 823     else
 824         swallowEvent = handleMousePressEventSingleClick(event);
 825 
 826     m_mouseDownMayStartAutoscroll = m_mouseDownMayStartSelect
 827         || (m_mousePressNode &amp;&amp; m_mousePressNode-&gt;renderBox() &amp;&amp; m_mousePressNode-&gt;renderBox()-&gt;canBeProgramaticallyScrolled());
 828 
 829     return swallowEvent;
 830 }
 831 
 832 VisiblePosition EventHandler::selectionExtentRespectingEditingBoundary(const VisibleSelection&amp; selection, const LayoutPoint&amp; localPoint, Node* targetNode)
 833 {
 834     FloatPoint selectionEndPoint = localPoint;
 835     Element* editableElement = selection.rootEditableElement();
 836 
 837     if (!targetNode || !targetNode-&gt;renderer())
 838         return VisiblePosition();
 839 
 840     if (editableElement &amp;&amp; !editableElement-&gt;contains(targetNode)) {
 841         if (!editableElement-&gt;renderer())
 842             return VisiblePosition();
 843 
 844         FloatPoint absolutePoint = targetNode-&gt;renderer()-&gt;localToAbsolute(FloatPoint(selectionEndPoint));
 845         selectionEndPoint = editableElement-&gt;renderer()-&gt;absoluteToLocal(absolutePoint);
 846         targetNode = editableElement;
 847     }
 848 
 849     return targetNode-&gt;renderer()-&gt;positionForPoint(LayoutPoint(selectionEndPoint), nullptr);
 850 }
 851 
 852 #if ENABLE(DRAG_SUPPORT)
 853 
 854 #if !PLATFORM(IOS_FAMILY)
 855 
 856 bool EventHandler::supportsSelectionUpdatesOnMouseDrag() const
 857 {
 858     return true;
 859 }
 860 
 861 bool EventHandler::shouldAllowMouseDownToStartDrag() const
 862 {
 863     return true;
 864 }
 865 
 866 #endif
 867 
 868 bool EventHandler::handleMouseDraggedEvent(const MouseEventWithHitTestResults&amp; event, CheckDragHysteresis checkDragHysteresis)
 869 {
 870     if (!m_mousePressed)
 871         return false;
 872 
 873     Ref&lt;Frame&gt; protectedFrame(m_frame);
 874 
 875     if (handleDrag(event, checkDragHysteresis))
 876         return true;
 877 
 878     Node* targetNode = event.targetNode();
 879     if (event.event().button() != LeftButton || !targetNode)
 880         return false;
 881 
 882     RenderObject* renderer = targetNode-&gt;renderer();
 883     if (!renderer) {
 884         Element* parent = targetNode-&gt;parentOrShadowHostElement();
 885         if (!parent)
 886             return false;
 887 
 888         renderer = parent-&gt;renderer();
 889         if (!renderer || !renderer-&gt;isListBox())
 890             return false;
 891     }
 892 
 893 #if PLATFORM(COCOA) // FIXME: Why does this assertion fire on other platforms?
 894     ASSERT(m_mouseDownMayStartSelect || m_mouseDownMayStartAutoscroll);
 895 #endif
 896 
 897     m_mouseDownMayStartDrag = false;
 898 
 899     if (m_mouseDownMayStartAutoscroll &amp;&amp; !panScrollInProgress()) {
 900         m_autoscrollController-&gt;startAutoscrollForSelection(renderer);
 901         m_mouseDownMayStartAutoscroll = false;
 902     }
 903 
 904     if (m_selectionInitiationState != ExtendedSelection) {
 905         HitTestResult result(m_mouseDownPos);
 906         m_frame.document()-&gt;hitTest(HitTestRequest(), result);
 907 
 908         updateSelectionForMouseDrag(result);
 909     }
 910     updateSelectionForMouseDrag(event.hitTestResult());
 911     return true;
 912 }
 913 
 914 bool EventHandler::eventMayStartDrag(const PlatformMouseEvent&amp; event) const
 915 {
 916     // This is a pre-flight check of whether the event might lead to a drag being started.  Be careful
 917     // that its logic needs to stay in sync with handleMouseMoveEvent() and the way we setMouseDownMayStartDrag
 918     // in handleMousePressEvent
 919     auto* document = m_frame.document();
 920     if (!document)
 921         return false;
 922 
 923     if (event.button() != LeftButton || event.clickCount() != 1)
 924         return false;
 925 
 926     FrameView* view = m_frame.view();
 927     if (!view)
 928         return false;
 929 
 930     Page* page = m_frame.page();
 931     if (!page)
 932         return false;
 933 
 934     Ref&lt;Frame&gt; protectedFrame(m_frame);
 935 
 936     updateDragSourceActionsAllowed();
 937     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::DisallowUserAgentShadowContent);
 938     HitTestResult result(view-&gt;windowToContents(event.position()));
 939     document-&gt;hitTest(request, result);
 940     DragState state;
 941     Element* targetElement = result.targetElement();
 942     return targetElement &amp;&amp; page-&gt;dragController().draggableElement(&amp;m_frame, targetElement, result.roundedPointInInnerNodeFrame(), state);
 943 }
 944 
 945 void EventHandler::updateSelectionForMouseDrag()
 946 {
 947     if (!supportsSelectionUpdatesOnMouseDrag())
 948         return;
 949 
 950     FrameView* view = m_frame.view();
 951     if (!view)
 952         return;
 953     auto* document = m_frame.document();
 954     if (!document)
 955         return;
 956 
 957     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::Move | HitTestRequest::DisallowUserAgentShadowContent);
 958     HitTestResult result(view-&gt;windowToContents(m_lastKnownMousePosition));
 959     document-&gt;hitTest(request, result);
 960     updateSelectionForMouseDrag(result);
 961 }
 962 
 963 void EventHandler::updateSelectionForMouseDrag(const HitTestResult&amp; hitTestResult)
 964 {
 965     if (!supportsSelectionUpdatesOnMouseDrag())
 966         return;
 967 
 968     if (!m_mouseDownMayStartSelect)
 969         return;
 970 
 971     Node* target = hitTestResult.targetNode();
 972     if (!target)
 973         return;
 974 
 975     VisiblePosition targetPosition = selectionExtentRespectingEditingBoundary(m_frame.selection().selection(), hitTestResult.localPoint(), target);
 976 
 977     // Don&#39;t modify the selection if we&#39;re not on a node.
 978     if (targetPosition.isNull())
 979         return;
 980 
 981     // Restart the selection if this is the first mouse move. This work is usually
 982     // done in handleMousePressEvent, but not if the mouse press was on an existing selection.
 983     VisibleSelection newSelection = m_frame.selection().selection();
 984 
 985     // Special case to limit selection to the containing block for SVG text.
 986     // FIXME: Isn&#39;t there a better non-SVG-specific way to do this?
 987     if (Node* selectionBaseNode = newSelection.base().deprecatedNode()) {
 988         if (RenderObject* selectionBaseRenderer = selectionBaseNode-&gt;renderer()) {
 989             if (selectionBaseRenderer-&gt;isSVGText()) {
 990                 if (target-&gt;renderer()-&gt;containingBlock() != selectionBaseRenderer-&gt;containingBlock())
 991                     return;
 992             }
 993         }
 994     }
 995 
 996 
 997     if (m_selectionInitiationState == HaveNotStartedSelection &amp;&amp; !dispatchSelectStart(target)) {
 998         m_mouseDownMayStartSelect = false;
 999         return;
1000     }
1001 
1002     if (m_selectionInitiationState != ExtendedSelection) {
1003         // Always extend selection here because it&#39;s caused by a mouse drag
1004         m_selectionInitiationState = ExtendedSelection;
1005         newSelection = VisibleSelection(targetPosition);
1006     }
1007 
1008 #if ENABLE(USERSELECT_ALL)
1009     Node* rootUserSelectAllForMousePressNode = Position::rootUserSelectAllForNode(m_mousePressNode.get());
1010     if (rootUserSelectAllForMousePressNode &amp;&amp; rootUserSelectAllForMousePressNode == Position::rootUserSelectAllForNode(target)) {
1011         newSelection.setBase(positionBeforeNode(rootUserSelectAllForMousePressNode).upstream(CanCrossEditingBoundary));
1012         newSelection.setExtent(positionAfterNode(rootUserSelectAllForMousePressNode).downstream(CanCrossEditingBoundary));
1013     } else {
1014         // Reset base for user select all when base is inside user-select-all area and extent &lt; base.
1015         if (rootUserSelectAllForMousePressNode &amp;&amp; comparePositions(target-&gt;renderer()-&gt;positionForPoint(hitTestResult.localPoint(), nullptr), m_mousePressNode-&gt;renderer()-&gt;positionForPoint(m_dragStartPosition, nullptr)) &lt; 0)
1016             newSelection.setBase(positionAfterNode(rootUserSelectAllForMousePressNode).downstream(CanCrossEditingBoundary));
1017 
1018         Node* rootUserSelectAllForTarget = Position::rootUserSelectAllForNode(target);
1019         if (rootUserSelectAllForTarget &amp;&amp; m_mousePressNode-&gt;renderer() &amp;&amp; comparePositions(target-&gt;renderer()-&gt;positionForPoint(hitTestResult.localPoint(), nullptr), m_mousePressNode-&gt;renderer()-&gt;positionForPoint(m_dragStartPosition, nullptr)) &lt; 0)
1020             newSelection.setExtent(positionBeforeNode(rootUserSelectAllForTarget).upstream(CanCrossEditingBoundary));
1021         else if (rootUserSelectAllForTarget &amp;&amp; m_mousePressNode-&gt;renderer())
1022             newSelection.setExtent(positionAfterNode(rootUserSelectAllForTarget).downstream(CanCrossEditingBoundary));
1023         else
1024             newSelection.setExtent(targetPosition);
1025     }
1026 #else
1027     newSelection.setExtent(targetPosition);
1028 #endif
1029 
1030     if (m_frame.selection().granularity() != CharacterGranularity)
1031         newSelection.expandUsingGranularity(m_frame.selection().granularity());
1032 
1033     m_frame.selection().setSelectionByMouseIfDifferent(newSelection, m_frame.selection().granularity(),
1034         FrameSelection::AdjustEndpointsAtBidiBoundary);
1035 }
1036 #endif // ENABLE(DRAG_SUPPORT)
1037 
1038 void EventHandler::lostMouseCapture()
1039 {
1040     m_frame.selection().setCaretBlinkingSuspended(false);
1041 }
1042 
1043 bool EventHandler::handleMouseUp(const MouseEventWithHitTestResults&amp; event)
1044 {
1045     if (eventLoopHandleMouseUp(event))
1046         return true;
1047 
1048     // If this was the first click in the window, we don&#39;t even want to clear the selection.
1049     // This case occurs when the user clicks on a draggable element, since we have to process
1050     // the mouse down and drag events to see if we might start a drag.  For other first clicks
1051     // in a window, we just don&#39;t acceptFirstMouse, and the whole down-drag-up sequence gets
1052     // ignored upstream of this layer.
1053     return eventActivatedView(event.event());
1054 }
1055 
1056 bool EventHandler::handleMouseReleaseEvent(const MouseEventWithHitTestResults&amp; event)
1057 {
1058     if (autoscrollInProgress())
1059         stopAutoscrollTimer();
1060 
1061     Ref&lt;Frame&gt; protectedFrame(m_frame);
1062 
1063     if (handleMouseUp(event))
1064         return true;
1065 
1066     // Used to prevent mouseMoveEvent from initiating a drag before
1067     // the mouse is pressed again.
1068     m_mousePressed = false;
1069     m_capturesDragging = false;
1070 #if ENABLE(DRAG_SUPPORT)
1071     m_mouseDownMayStartDrag = false;
1072 #endif
1073     m_mouseDownMayStartSelect = false;
1074     m_mouseDownMayStartAutoscroll = false;
1075     m_mouseDownWasInSubframe = false;
1076 
1077     bool handled = false;
1078 
1079     // Clear the selection if the mouse didn&#39;t move after the last mouse
1080     // press and it&#39;s not a context menu click.  We do this so when clicking
1081     // on the selection, the selection goes away.  However, if we are
1082     // editing, place the caret.
1083     if (m_mouseDownWasSingleClickInSelection &amp;&amp; m_selectionInitiationState != ExtendedSelection
1084 #if ENABLE(DRAG_SUPPORT)
1085             &amp;&amp; m_dragStartPosition == event.event().position()
1086 #endif
1087             &amp;&amp; m_frame.selection().isRange()
1088             &amp;&amp; event.event().button() != RightButton) {
1089         VisibleSelection newSelection;
1090         Node* node = event.targetNode();
1091         bool caretBrowsing = m_frame.settings().caretBrowsingEnabled();
1092         bool allowSelectionChanges = true;
1093         if (node &amp;&amp; node-&gt;renderer() &amp;&amp; (caretBrowsing || node-&gt;hasEditableStyle())) {
1094             VisiblePosition pos = node-&gt;renderer()-&gt;positionForPoint(event.localPoint(), nullptr);
1095             newSelection = VisibleSelection(pos);
1096 #if PLATFORM(IOS_FAMILY)
1097             // On iOS, selection changes are triggered using platform-specific text interaction gestures rather than
1098             // default behavior on click or mouseup. As such, the only time we should allow click events to change the
1099             // selection on iOS is when we focus a different editable element, in which case the text interaction
1100             // gestures will fail.
1101             allowSelectionChanges = m_frame.selection().selection().rootEditableElement() != newSelection.rootEditableElement();
1102 #endif
1103         }
1104 
1105         if (allowSelectionChanges)
1106             setSelectionIfNeeded(m_frame.selection(), newSelection);
1107 
1108         handled = true;
1109     }
1110 
1111     if (event.event().button() == MiddleButton) {
1112         // Ignore handled, since we want to paste to where the caret was placed anyway.
1113         handled = handlePasteGlobalSelection(event.event()) || handled;
1114     }
1115 
1116     return handled;
1117 }
1118 
1119 #if ENABLE(PAN_SCROLLING)
1120 
1121 void EventHandler::didPanScrollStart()
1122 {
1123     m_autoscrollController-&gt;didPanScrollStart();
1124 }
1125 
1126 void EventHandler::didPanScrollStop()
1127 {
1128     m_autoscrollController-&gt;didPanScrollStop();
1129 }
1130 
1131 void EventHandler::startPanScrolling(RenderElement&amp; renderer)
1132 {
1133 #if !PLATFORM(IOS_FAMILY)
1134     if (!is&lt;RenderBox&gt;(renderer))
1135         return;
1136     m_autoscrollController-&gt;startPanScrolling(&amp;downcast&lt;RenderBox&gt;(renderer), lastKnownMousePosition());
1137     invalidateClick();
1138 #endif
1139 }
1140 
1141 #endif // ENABLE(PAN_SCROLLING)
1142 
1143 RenderBox* EventHandler::autoscrollRenderer() const
1144 {
1145     return m_autoscrollController-&gt;autoscrollRenderer();
1146 }
1147 
1148 void EventHandler::updateAutoscrollRenderer()
1149 {
1150     m_autoscrollController-&gt;updateAutoscrollRenderer();
1151 }
1152 
1153 bool EventHandler::autoscrollInProgress() const
1154 {
1155     return m_autoscrollController-&gt;autoscrollInProgress();
1156 }
1157 
1158 bool EventHandler::panScrollInProgress() const
1159 {
1160     return m_autoscrollController-&gt;panScrollInProgress();
1161 }
1162 
1163 #if ENABLE(DRAG_SUPPORT)
1164 DragSourceAction EventHandler::updateDragSourceActionsAllowed() const
1165 {
1166     Page* page = m_frame.page();
1167     if (!page)
1168         return DragSourceActionNone;
1169 
1170     FrameView* view = m_frame.view();
1171     if (!view)
1172         return DragSourceActionNone;
1173 
1174     return page-&gt;dragController().delegateDragSourceAction(view-&gt;contentsToRootView(m_mouseDownPos));
1175 }
1176 #endif // ENABLE(DRAG_SUPPORT)
1177 
1178 HitTestResult EventHandler::hitTestResultAtPoint(const LayoutPoint&amp; point, HitTestRequest::HitTestRequestType hitType, const LayoutSize&amp; padding) const
1179 {
1180     ASSERT((hitType &amp; HitTestRequest::CollectMultipleElements) || padding.isEmpty());
1181 
1182     Ref&lt;Frame&gt; protectedFrame(m_frame);
1183 
1184     // We always send hitTestResultAtPoint to the main frame if we have one,
1185     // otherwise we might hit areas that are obscured by higher frames.
1186     if (!m_frame.isMainFrame()) {
1187         Frame&amp; mainFrame = m_frame.mainFrame();
1188         FrameView* frameView = m_frame.view();
1189         FrameView* mainView = mainFrame.view();
1190         if (frameView &amp;&amp; mainView) {
1191             IntPoint mainFramePoint = mainView-&gt;rootViewToContents(frameView-&gt;contentsToRootView(roundedIntPoint(point)));
1192             return mainFrame.eventHandler().hitTestResultAtPoint(mainFramePoint, hitType, padding);
1193         }
1194     }
1195 
1196     unsigned nonNegativePaddingWidth = std::max&lt;LayoutUnit&gt;(0, padding.width()).toUnsigned();
1197     unsigned nonNegativePaddingHeight = std::max&lt;LayoutUnit&gt;(0, padding.height()).toUnsigned();
1198 
1199     // We should always start hit testing a clean tree.
1200     if (auto* frameView = m_frame.view())
1201         frameView-&gt;updateLayoutAndStyleIfNeededRecursive();
1202 
1203     HitTestResult result(point, nonNegativePaddingHeight, nonNegativePaddingWidth, nonNegativePaddingHeight, nonNegativePaddingWidth);
1204     auto* document = m_frame.document();
1205     if (!document)
1206         return result;
1207 
1208     HitTestRequest request(hitType);
1209     document-&gt;hitTest(request, result);
1210     if (!request.readOnly())
1211         m_frame.document()-&gt;updateHoverActiveState(request, result.targetElement());
1212 
1213     if (request.disallowsUserAgentShadowContent())
1214         result.setToNonUserAgentShadowAncestor();
1215 
1216     return result;
1217 }
1218 
1219 void EventHandler::stopAutoscrollTimer(bool rendererIsBeingDestroyed)
1220 {
1221     m_autoscrollController-&gt;stopAutoscrollTimer(rendererIsBeingDestroyed);
1222 }
1223 
1224 bool EventHandler::scrollOverflow(ScrollDirection direction, ScrollGranularity granularity, Node* startingNode)
1225 {
1226     Node* node = startingNode;
1227 
1228     if (!node)
1229         node = m_frame.document()-&gt;focusedElement();
1230 
1231     if (!node)
1232         node = m_mousePressNode.get();
1233 
1234     if (node) {
1235         auto r = node-&gt;renderer();
1236         if (r &amp;&amp; !r-&gt;isListBox() &amp;&amp; r-&gt;enclosingBox().scroll(direction, granularity)) {
1237             setFrameWasScrolledByUser();
1238             return true;
1239         }
1240     }
1241 
1242     return false;
1243 }
1244 
1245 bool EventHandler::logicalScrollOverflow(ScrollLogicalDirection direction, ScrollGranularity granularity, Node* startingNode)
1246 {
1247     Node* node = startingNode;
1248 
1249     if (!node)
1250         node = m_frame.document()-&gt;focusedElement();
1251 
1252     if (!node)
1253         node = m_mousePressNode.get();
1254 
1255     if (node) {
1256         auto r = node-&gt;renderer();
1257         if (r &amp;&amp; !r-&gt;isListBox() &amp;&amp; r-&gt;enclosingBox().logicalScroll(direction, granularity)) {
1258             setFrameWasScrolledByUser();
1259             return true;
1260         }
1261     }
1262 
1263     return false;
1264 }
1265 
1266 bool EventHandler::scrollRecursively(ScrollDirection direction, ScrollGranularity granularity, Node* startingNode)
1267 {
1268     Ref&lt;Frame&gt; protectedFrame(m_frame);
1269 
1270     // The layout needs to be up to date to determine if we can scroll. We may be
1271     // here because of an onLoad event, in which case the final layout hasn&#39;t been performed yet.
1272     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
1273     if (scrollOverflow(direction, granularity, startingNode))
1274         return true;
1275     Frame* frame = &amp;m_frame;
1276     FrameView* view = frame-&gt;view();
1277     if (view &amp;&amp; view-&gt;scroll(direction, granularity))
1278         return true;
1279     frame = frame-&gt;tree().parent();
1280     if (!frame)
1281         return false;
1282     return frame-&gt;eventHandler().scrollRecursively(direction, granularity, m_frame.ownerElement());
1283 }
1284 
1285 bool EventHandler::logicalScrollRecursively(ScrollLogicalDirection direction, ScrollGranularity granularity, Node* startingNode)
1286 {
1287     Ref&lt;Frame&gt; protectedFrame(m_frame);
1288 
1289     // The layout needs to be up to date to determine if we can scroll. We may be
1290     // here because of an onLoad event, in which case the final layout hasn&#39;t been performed yet.
1291     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
1292     if (logicalScrollOverflow(direction, granularity, startingNode))
1293         return true;
1294     Frame* frame = &amp;m_frame;
1295     FrameView* view = frame-&gt;view();
1296 
1297     bool scrolled = false;
1298 #if PLATFORM(COCOA)
1299     // Mac also resets the scroll position in the inline direction.
1300     if (granularity == ScrollByDocument &amp;&amp; view &amp;&amp; view-&gt;logicalScroll(ScrollInlineDirectionBackward, ScrollByDocument))
1301         scrolled = true;
1302 #endif
1303     if (view &amp;&amp; view-&gt;logicalScroll(direction, granularity))
1304         scrolled = true;
1305 
1306     if (scrolled)
1307         return true;
1308 
1309     frame = frame-&gt;tree().parent();
1310     if (!frame)
1311         return false;
1312 
1313     return frame-&gt;eventHandler().logicalScrollRecursively(direction, granularity, m_frame.ownerElement());
1314 }
1315 
1316 IntPoint EventHandler::lastKnownMousePosition() const
1317 {
1318     return m_lastKnownMousePosition;
1319 }
1320 
1321 Frame* EventHandler::subframeForHitTestResult(const MouseEventWithHitTestResults&amp; hitTestResult)
1322 {
1323     if (!hitTestResult.isOverWidget())
1324         return 0;
1325     return subframeForTargetNode(hitTestResult.targetNode());
1326 }
1327 
1328 Frame* EventHandler::subframeForTargetNode(Node* node)
1329 {
1330     if (!node)
1331         return nullptr;
1332 
1333     auto renderer = node-&gt;renderer();
1334     if (!is&lt;RenderWidget&gt;(renderer))
1335         return nullptr;
1336 
1337     Widget* widget = downcast&lt;RenderWidget&gt;(*renderer).widget();
1338     if (!is&lt;FrameView&gt;(widget))
1339         return nullptr;
1340 
1341     return &amp;downcast&lt;FrameView&gt;(*widget).frame();
1342 }
1343 
<a name="18" id="anc18"></a>
1344 static bool isSubmitImage(Node* node)
1345 {
1346     return is&lt;HTMLInputElement&gt;(node) &amp;&amp; downcast&lt;HTMLInputElement&gt;(*node).isImageButton();
1347 }
1348 
1349 // Returns true if the node&#39;s editable block is not current focused for editing
1350 static bool nodeIsNotBeingEdited(const Node&amp; node, const Frame&amp; frame)
1351 {
1352     return frame.selection().selection().rootEditableElement() != node.rootEditableElement();
1353 }
1354 
1355 bool EventHandler::useHandCursor(Node* node, bool isOverLink, bool shiftKey)
1356 {
1357     if (!node)
1358         return false;
1359 
1360     bool editable = node-&gt;hasEditableStyle();
1361     bool editableLinkEnabled = false;
1362 
1363     // If the link is editable, then we need to check the settings to see whether or not the link should be followed
1364     if (editable) {
1365         switch (m_frame.settings().editableLinkBehavior()) {
1366         default:
1367         case EditableLinkDefaultBehavior:
1368         case EditableLinkAlwaysLive:
1369             editableLinkEnabled = true;
1370             break;
1371 
1372         case EditableLinkNeverLive:
1373             editableLinkEnabled = false;
1374             break;
1375 
1376         case EditableLinkLiveWhenNotFocused:
1377             editableLinkEnabled = nodeIsNotBeingEdited(*node, m_frame) || shiftKey;
1378             break;
1379 
1380         case EditableLinkOnlyLiveWithShiftKey:
1381             editableLinkEnabled = shiftKey;
1382             break;
1383         }
1384     }
1385 
1386     return ((isOverLink || isSubmitImage(node)) &amp;&amp; (!editable || editableLinkEnabled));
1387 }
1388 
1389 void EventHandler::cursorUpdateTimerFired()
1390 {
1391     ASSERT(m_frame.document());
1392     updateCursor();
1393 }
1394 
1395 void EventHandler::updateCursor()
1396 {
1397     if (m_mousePositionIsUnknown)
1398         return;
1399 
<a name="19" id="anc19"></a><span class="line-added">1400     if (Page* page = m_frame.page()) {</span>
<span class="line-added">1401         if (!page-&gt;chrome().client().supportsSettingCursor())</span>
<span class="line-added">1402             return;</span>
<span class="line-added">1403     }</span>
<span class="line-added">1404 </span>
1405     FrameView* view = m_frame.view();
1406     if (!view)
1407         return;
1408 
1409     auto* document = m_frame.document();
1410     if (!document)
1411         return;
1412 
1413     if (!view-&gt;shouldSetCursor())
1414         return;
1415 
1416     bool shiftKey;
1417     bool ctrlKey;
1418     bool altKey;
1419     bool metaKey;
1420     PlatformKeyboardEvent::getCurrentModifierState(shiftKey, ctrlKey, altKey, metaKey);
1421 
1422     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::AllowFrameScrollbars);
1423     HitTestResult result(view-&gt;windowToContents(m_lastKnownMousePosition));
1424     document-&gt;hitTest(request, result);
1425 
1426     updateCursor(*view, result, shiftKey);
1427 }
1428 
1429 void EventHandler::updateCursor(FrameView&amp; view, const HitTestResult&amp; result, bool shiftKey)
1430 {
1431     if (auto optionalCursor = selectCursor(result, shiftKey)) {
1432         m_currentMouseCursor = WTFMove(optionalCursor.value());
1433         view.setCursor(m_currentMouseCursor);
1434     }
1435 }
1436 
1437 Optional&lt;Cursor&gt; EventHandler::selectCursor(const HitTestResult&amp; result, bool shiftKey)
1438 {
1439     if (m_resizeLayer &amp;&amp; m_resizeLayer-&gt;inResizeMode())
1440         return WTF::nullopt;
1441 
1442     if (!m_frame.page())
1443         return WTF::nullopt;
1444 
1445 #if ENABLE(PAN_SCROLLING)
1446     if (m_frame.mainFrame().eventHandler().panScrollInProgress())
1447         return WTF::nullopt;
1448 #endif
1449 
1450     Ref&lt;Frame&gt; protectedFrame(m_frame);
1451 
1452     // Use always pointer cursor for scrollbars.
1453     if (result.scrollbar()) {
1454 #if ENABLE(CURSOR_VISIBILITY)
1455         cancelAutoHideCursorTimer();
1456 #endif
1457         return pointerCursor();
1458     }
1459 
1460     Node* node = result.targetNode();
1461     if (!node)
1462         return WTF::nullopt;
1463 
1464     auto renderer = node-&gt;renderer();
1465     auto* style = renderer ? &amp;renderer-&gt;style() : nullptr;
1466     bool horizontalText = !style || style-&gt;isHorizontalWritingMode();
1467     const Cursor&amp; iBeam = horizontalText ? iBeamCursor() : verticalTextCursor();
1468 
1469 #if ENABLE(CURSOR_VISIBILITY)
1470     if (style &amp;&amp; style-&gt;cursorVisibility() == CursorVisibility::AutoHide)
1471         startAutoHideCursorTimer();
1472     else
1473         cancelAutoHideCursorTimer();
1474 #endif
1475 
1476     if (renderer) {
1477         Cursor overrideCursor;
1478         switch (renderer-&gt;getCursor(roundedIntPoint(result.localPoint()), overrideCursor)) {
1479         case SetCursorBasedOnStyle:
1480             break;
1481         case SetCursor:
1482             return overrideCursor;
1483         case DoNotSetCursor:
1484             return WTF::nullopt;
1485         }
1486     }
1487 
1488     if (style &amp;&amp; style-&gt;cursors()) {
1489         const CursorList* cursors = style-&gt;cursors();
1490         for (unsigned i = 0; i &lt; cursors-&gt;size(); ++i) {
1491             StyleImage* styleImage = (*cursors)[i].image();
1492             if (!styleImage)
1493                 continue;
1494             CachedImage* cachedImage = styleImage-&gt;cachedImage();
1495             if (!cachedImage)
1496                 continue;
1497             float scale = styleImage-&gt;imageScaleFactor();
1498             // Get hotspot and convert from logical pixels to physical pixels.
1499             IntPoint hotSpot = (*cursors)[i].hotSpot();
1500             FloatSize size = cachedImage-&gt;imageForRenderer(renderer)-&gt;size();
1501             if (cachedImage-&gt;errorOccurred())
1502                 continue;
1503             // Limit the size of cursors (in UI pixels) so that they cannot be
1504             // used to cover UI elements in chrome.
1505             size.scale(1 / scale);
1506             if (size.width() &gt; maximumCursorSize || size.height() &gt; maximumCursorSize)
1507                 continue;
1508 
1509             Image* image = cachedImage-&gt;imageForRenderer(renderer);
1510 #if ENABLE(MOUSE_CURSOR_SCALE)
1511             // Ensure no overflow possible in calculations above.
1512             if (scale &lt; minimumCursorScale)
1513                 continue;
1514             return Cursor(image, hotSpot, scale);
1515 #else
1516             ASSERT(scale == 1);
1517             return Cursor(image, hotSpot);
1518 #endif // ENABLE(MOUSE_CURSOR_SCALE)
1519         }
1520     }
1521 
1522     // During selection, use an I-beam regardless of the content beneath the cursor.
1523     // If a drag may be starting or we&#39;re capturing mouse events for a particular node, don&#39;t treat this as a selection.
1524     if (m_mousePressed
1525         &amp;&amp; m_mouseDownMayStartSelect
1526 #if ENABLE(DRAG_SUPPORT)
1527         &amp;&amp; !m_mouseDownMayStartDrag
1528 #endif
1529         &amp;&amp; m_frame.selection().isCaretOrRange()
1530         &amp;&amp; !m_capturingMouseEventsElement)
1531         return iBeam;
1532 
1533     switch (style ? style-&gt;cursor() : CursorType::Auto) {
1534     case CursorType::Auto: {
1535         bool editable = node-&gt;hasEditableStyle();
1536 
1537         if (useHandCursor(node, result.isOverLink(), shiftKey))
1538             return handCursor();
1539 
1540         bool inResizer = false;
1541         if (renderer) {
1542             if (RenderLayer* layer = renderer-&gt;enclosingLayer()) {
1543                 if (FrameView* view = m_frame.view())
1544                     inResizer = layer-&gt;isPointInResizeControl(view-&gt;windowToContents(roundedIntPoint(result.localPoint())));
1545             }
1546         }
1547 
1548         if ((editable || (renderer &amp;&amp; renderer-&gt;isText() &amp;&amp; node-&gt;canStartSelection())) &amp;&amp; !inResizer &amp;&amp; !result.scrollbar())
1549             return iBeam;
1550         return pointerCursor();
1551     }
1552     case CursorType::Default:
1553         return pointerCursor();
1554     case CursorType::None:
1555         return noneCursor();
1556     case CursorType::ContextMenu:
1557         return contextMenuCursor();
1558     case CursorType::Help:
1559         return helpCursor();
1560     case CursorType::Pointer:
1561         return handCursor();
1562     case CursorType::Progress:
1563         return progressCursor();
1564     case CursorType::Wait:
1565         return waitCursor();
1566     case CursorType::Cell:
1567         return cellCursor();
1568     case CursorType::Crosshair:
1569         return crossCursor();
1570     case CursorType::Text:
1571         return iBeamCursor();
1572     case CursorType::VerticalText:
1573         return verticalTextCursor();
1574     case CursorType::Alias:
1575         return aliasCursor();
1576     case CursorType::Copy:
1577         return copyCursor();
1578     case CursorType::Move:
1579         return moveCursor();
1580     case CursorType::NoDrop:
1581         return noDropCursor();
1582     case CursorType::NotAllowed:
1583         return notAllowedCursor();
1584     case CursorType::Grab:
1585         return grabCursor();
1586     case CursorType::Grabbing:
1587         return grabbingCursor();
1588     case CursorType::EResize:
1589         return eastResizeCursor();
1590     case CursorType::NResize:
1591         return northResizeCursor();
1592     case CursorType::NEResize:
1593         return northEastResizeCursor();
1594     case CursorType::NWResize:
1595         return northWestResizeCursor();
1596     case CursorType::SResize:
1597         return southResizeCursor();
1598     case CursorType::SEResize:
1599         return southEastResizeCursor();
1600     case CursorType::SWResize:
1601         return southWestResizeCursor();
1602     case CursorType::WResize:
1603         return westResizeCursor();
1604     case CursorType::EWResize:
1605         return eastWestResizeCursor();
1606     case CursorType::NSResize:
1607         return northSouthResizeCursor();
1608     case CursorType::NESWResize:
1609         return northEastSouthWestResizeCursor();
1610     case CursorType::NWSEResize:
1611         return northWestSouthEastResizeCursor();
1612     case CursorType::ColumnResize:
1613         return columnResizeCursor();
1614     case CursorType::RowResize:
1615         return rowResizeCursor();
1616     case CursorType::AllScroll:
1617         return moveCursor();
1618     case CursorType::ZoomIn:
1619         return zoomInCursor();
1620     case CursorType::ZoomOut:
1621         return zoomOutCursor();
1622     }
1623     return pointerCursor();
1624 }
<a name="20" id="anc20"></a>
1625 
1626 #if ENABLE(CURSOR_VISIBILITY)
1627 void EventHandler::startAutoHideCursorTimer()
1628 {
1629     Page* page = m_frame.page();
1630     if (!page)
1631         return;
1632 
1633     m_autoHideCursorTimer.startOneShot(page-&gt;settings().timeWithoutMouseMovementBeforeHidingControls());
1634 
1635 #if !ENABLE(IOS_TOUCH_EVENTS)
1636     // The fake mouse move event screws up the auto-hide feature (by resetting the auto-hide timer)
1637     // so cancel any pending fake mouse moves.
1638     if (m_fakeMouseMoveEventTimer.isActive())
1639         m_fakeMouseMoveEventTimer.stop();
1640 #endif
1641 }
1642 
1643 void EventHandler::cancelAutoHideCursorTimer()
1644 {
1645     if (m_autoHideCursorTimer.isActive())
1646         m_autoHideCursorTimer.stop();
1647 }
1648 
1649 void EventHandler::autoHideCursorTimerFired()
1650 {
1651     FrameView* view = m_frame.view();
1652     if (!view || !view-&gt;isActive())
1653         return;
1654 
1655     if (auto page = m_frame.page())
1656         page-&gt;chrome().setCursorHiddenUntilMouseMoves(true);
1657 }
1658 #endif
1659 
1660 static LayoutPoint documentPointForWindowPoint(Frame&amp; frame, const IntPoint&amp; windowPoint)
1661 {
1662     FrameView* view = frame.view();
1663     // FIXME: Is it really OK to use the wrong coordinates here when view is 0?
1664     // Historically the code would just crash; this is clearly no worse than that.
1665     return view ? view-&gt;windowToContents(windowPoint) : windowPoint;
1666 }
1667 
1668 static Scrollbar* scrollbarForMouseEvent(const MouseEventWithHitTestResults&amp; mouseEvent, FrameView* view)
1669 {
1670     if (view) {
1671         if (auto* scrollbar = view-&gt;scrollbarAtPoint(mouseEvent.event().position()))
1672             return scrollbar;
1673     }
1674     return mouseEvent.scrollbar();
1675 
1676 }
1677 
1678 bool EventHandler::handleMousePressEvent(const PlatformMouseEvent&amp; platformMouseEvent)
1679 {
1680     Ref&lt;Frame&gt; protectedFrame(m_frame);
1681     RefPtr&lt;FrameView&gt; protector(m_frame.view());
1682 
1683     if (InspectorInstrumentation::handleMousePress(m_frame)) {
1684         invalidateClick();
1685         return true;
1686     }
1687 
1688 #if ENABLE(POINTER_LOCK)
1689     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
1690         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(platformMouseEvent, eventNames().mousedownEvent);
1691         return true;
1692     }
1693 #endif
1694 
1695     if (m_frame.page()-&gt;pageOverlayController().handleMouseEvent(platformMouseEvent))
1696         return true;
1697 
1698 #if ENABLE(TOUCH_EVENTS)
1699     bool defaultPrevented = dispatchSyntheticTouchEventIfEnabled(platformMouseEvent);
1700     if (defaultPrevented)
1701         return true;
1702 #endif
1703 
1704     UserGestureIndicator gestureIndicator(ProcessingUserGesture, m_frame.document());
1705 
1706     // FIXME (bug 68185): this call should be made at another abstraction layer
1707     m_frame.loader().resetMultipleFormSubmissionProtection();
1708 
1709 #if !ENABLE(IOS_TOUCH_EVENTS)
1710     cancelFakeMouseMoveEvent();
1711 #endif
1712     m_mousePressed = true;
1713     m_capturesDragging = true;
1714     setLastKnownMousePosition(platformMouseEvent);
1715     m_mouseDownTimestamp = platformMouseEvent.timestamp();
1716 #if ENABLE(DRAG_SUPPORT)
1717     m_mouseDownMayStartDrag = false;
1718 #endif
1719     m_mouseDownMayStartSelect = false;
1720     m_mouseDownMayStartAutoscroll = false;
1721     if (FrameView* view = m_frame.view())
1722         m_mouseDownPos = view-&gt;windowToContents(platformMouseEvent.position());
1723     else {
1724         invalidateClick();
1725         return false;
1726     }
1727     m_mouseDownWasInSubframe = false;
1728 
1729     HitTestRequest request(HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent);
1730     // Save the document point we generate in case the window coordinate is invalidated by what happens
1731     // when we dispatch the event.
1732     LayoutPoint documentPoint = documentPointForWindowPoint(m_frame, platformMouseEvent.position());
1733     MouseEventWithHitTestResults mouseEvent = m_frame.document()-&gt;prepareMouseEvent(request, documentPoint, platformMouseEvent);
1734 
1735     if (!mouseEvent.targetNode()) {
1736         invalidateClick();
1737         return false;
1738     }
1739 
1740     m_mousePressNode = mouseEvent.targetNode();
1741     m_frame.document()-&gt;setFocusNavigationStartingNode(mouseEvent.targetNode());
1742 
1743     Scrollbar* scrollbar = scrollbarForMouseEvent(mouseEvent, m_frame.view());
1744     updateLastScrollbarUnderMouse(scrollbar, SetOrClearLastScrollbar::Set);
1745     bool passedToScrollbar = scrollbar &amp;&amp; passMousePressEventToScrollbar(mouseEvent, scrollbar);
1746 
1747     if (!passedToScrollbar) {
1748         RefPtr&lt;Frame&gt; subframe = subframeForHitTestResult(mouseEvent);
1749         if (subframe &amp;&amp; passMousePressEventToSubframe(mouseEvent, subframe.get())) {
1750             // Start capturing future events for this frame. We only do this if we didn&#39;t clear
1751             // the m_mousePressed flag, which may happen if an AppKit widget entered a modal event loop.
1752             m_capturesDragging = subframe-&gt;eventHandler().capturesDragging();
1753             if (m_mousePressed &amp;&amp; m_capturesDragging) {
1754                 m_capturingMouseEventsElement = subframe-&gt;ownerElement();
1755                 m_eventHandlerWillResetCapturingMouseEventsElement = true;
1756             }
1757             invalidateClick();
1758             return true;
1759         }
1760     }
1761 
1762 #if ENABLE(PAN_SCROLLING)
1763     // We store whether pan scrolling is in progress before calling stopAutoscrollTimer()
1764     // because it will set m_autoscrollType to NoAutoscroll on return.
1765     bool isPanScrollInProgress = m_frame.mainFrame().eventHandler().panScrollInProgress();
1766     stopAutoscrollTimer();
1767     if (isPanScrollInProgress) {
1768         // We invalidate the click when exiting pan scrolling so that we don&#39;t inadvertently navigate
1769         // away from the current page (e.g. the click was on a hyperlink). See &lt;rdar://problem/6095023&gt;.
1770         invalidateClick();
1771         return true;
1772     }
1773 #endif
1774 
1775     m_clickCount = platformMouseEvent.clickCount();
1776     m_clickNode = mouseEvent.targetNode();
1777 
1778     if (!m_clickNode) {
1779         invalidateClick();
1780         return false;
1781     }
1782 
1783     if (FrameView* view = m_frame.view()) {
1784         RenderLayer* layer = m_clickNode-&gt;renderer() ? m_clickNode-&gt;renderer()-&gt;enclosingLayer() : 0;
1785         IntPoint p = view-&gt;windowToContents(platformMouseEvent.position());
1786         if (layer &amp;&amp; layer-&gt;isPointInResizeControl(p)) {
1787             layer-&gt;setInResizeMode(true);
1788             m_resizeLayer = layer;
1789             m_offsetFromResizeCorner = layer-&gt;offsetFromResizeCorner(p);
1790             invalidateClick();
1791             return true;
1792         }
1793     }
1794 
1795     m_frame.selection().setCaretBlinkingSuspended(true);
1796 
1797     bool swallowEvent = !dispatchMouseEvent(eventNames().mousedownEvent, mouseEvent.targetNode(), true, m_clickCount, platformMouseEvent, true);
1798     m_capturesDragging = !swallowEvent || mouseEvent.scrollbar();
1799 
1800     // If the hit testing originally determined the event was in a scrollbar, refetch the MouseEventWithHitTestResults
1801     // in case the scrollbar widget was destroyed when the mouse event was handled.
1802     if (mouseEvent.scrollbar()) {
1803         const bool wasLastScrollBar = mouseEvent.scrollbar() == m_lastScrollbarUnderMouse;
1804         mouseEvent = m_frame.document()-&gt;prepareMouseEvent(HitTestRequest(), documentPoint, platformMouseEvent);
1805         if (wasLastScrollBar &amp;&amp; mouseEvent.scrollbar() != m_lastScrollbarUnderMouse)
1806             m_lastScrollbarUnderMouse = nullptr;
1807     }
1808 
1809     if (!swallowEvent) {
1810         // Refetch the event target node if it currently is the shadow node inside an &lt;input&gt; element.
1811         // If a mouse event handler changes the input element type to one that has a widget associated,
1812         // we&#39;d like to EventHandler::handleMousePressEvent to pass the event to the widget and thus the
1813         // event target node can&#39;t still be the shadow node.
1814         if (is&lt;ShadowRoot&gt;(*mouseEvent.targetNode()) &amp;&amp; is&lt;HTMLInputElement&gt;(*downcast&lt;ShadowRoot&gt;(*mouseEvent.targetNode()).host()))
1815             mouseEvent = m_frame.document()-&gt;prepareMouseEvent(HitTestRequest(), documentPoint, platformMouseEvent);
1816     }
1817 
1818     if (!swallowEvent) {
1819         if (passedToScrollbar)
1820             swallowEvent = true;
1821         else
1822             swallowEvent = handleMousePressEvent(mouseEvent);
1823     }
1824     return swallowEvent;
1825 }
1826 
1827 // This method only exists for platforms that don&#39;t know how to deliver
1828 bool EventHandler::handleMouseDoubleClickEvent(const PlatformMouseEvent&amp; platformMouseEvent)
1829 {
1830     Ref&lt;Frame&gt; protectedFrame(m_frame);
1831     RefPtr&lt;FrameView&gt; protector(m_frame.view());
1832 
1833     m_frame.selection().setCaretBlinkingSuspended(false);
1834 
1835     UserGestureIndicator gestureIndicator(ProcessingUserGesture, m_frame.document());
1836 
1837 #if ENABLE(POINTER_LOCK)
1838     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
1839         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(platformMouseEvent, eventNames().mouseupEvent);
1840         return true;
1841     }
1842 #endif
1843 
1844     // We get this instead of a second mouse-up
1845     m_mousePressed = false;
1846     setLastKnownMousePosition(platformMouseEvent);
1847 
1848     HitTestRequest request(HitTestRequest::Release | HitTestRequest::DisallowUserAgentShadowContent);
1849     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, platformMouseEvent);
1850     Frame* subframe = subframeForHitTestResult(mouseEvent);
1851     if (m_eventHandlerWillResetCapturingMouseEventsElement)
1852         m_capturingMouseEventsElement = nullptr;
1853     if (subframe &amp;&amp; passMousePressEventToSubframe(mouseEvent, subframe))
1854         return true;
1855 
1856     m_clickCount = platformMouseEvent.clickCount();
1857     bool swallowMouseUpEvent = !dispatchMouseEvent(eventNames().mouseupEvent, mouseEvent.targetNode(), true, m_clickCount, platformMouseEvent, false);
1858 
1859     bool swallowClickEvent = platformMouseEvent.button() != RightButton &amp;&amp; mouseEvent.targetNode() == m_clickNode &amp;&amp; !dispatchMouseEvent(eventNames().clickEvent, mouseEvent.targetNode(), true, m_clickCount, platformMouseEvent, true);
1860 
1861     if (m_lastScrollbarUnderMouse)
1862         swallowMouseUpEvent = m_lastScrollbarUnderMouse-&gt;mouseUp(platformMouseEvent);
1863 
1864     bool swallowMouseReleaseEvent = !swallowMouseUpEvent &amp;&amp; handleMouseReleaseEvent(mouseEvent);
1865 
1866     invalidateClick();
1867 
1868     return swallowMouseUpEvent || swallowClickEvent || swallowMouseReleaseEvent;
1869 }
1870 
1871 static ScrollableArea* enclosingScrollableArea(Node* node)
1872 {
1873     for (auto ancestor = node; ancestor; ancestor = ancestor-&gt;parentOrShadowHostNode()) {
1874         if (is&lt;HTMLIFrameElement&gt;(*ancestor) || is&lt;HTMLHtmlElement&gt;(*ancestor) || is&lt;HTMLDocument&gt;(*ancestor))
1875             return nullptr;
1876 
1877         auto renderer = ancestor-&gt;renderer();
1878         if (!renderer)
1879             continue;
1880 
1881         if (is&lt;RenderListBox&gt;(*renderer))
1882             return downcast&lt;RenderListBox&gt;(renderer);
1883 
1884         return renderer-&gt;enclosingLayer();
1885     }
1886 
1887     return nullptr;
1888 }
1889 
1890 bool EventHandler::mouseMoved(const PlatformMouseEvent&amp; event)
1891 {
1892     Ref&lt;Frame&gt; protectedFrame(m_frame);
1893     RefPtr&lt;FrameView&gt; protector(m_frame.view());
1894     MaximumDurationTracker maxDurationTracker(&amp;m_maxMouseMovedDuration);
1895 
1896     if (m_frame.page() &amp;&amp; m_frame.page()-&gt;pageOverlayController().handleMouseEvent(event))
1897         return true;
1898 
1899     HitTestResult hoveredNode = HitTestResult(LayoutPoint());
1900     bool result = handleMouseMoveEvent(event, &amp;hoveredNode);
1901 
1902     Page* page = m_frame.page();
1903     if (!page)
1904         return result;
1905 
1906     if (auto scrolledArea = enclosingScrollableArea(hoveredNode.innerNode())) {
1907         if (FrameView* frameView = m_frame.view()) {
1908             if (frameView-&gt;containsScrollableArea(scrolledArea))
1909                 scrolledArea-&gt;mouseMovedInContentArea();
1910         }
1911     }
1912 
1913     if (FrameView* frameView = m_frame.view())
1914         frameView-&gt;mouseMovedInContentArea();
1915 
1916     hoveredNode.setToNonUserAgentShadowAncestor();
1917     page-&gt;chrome().mouseDidMoveOverElement(hoveredNode, event.modifierFlags());
<a name="21" id="anc21"></a>
1918     return result;
1919 }
1920 
1921 bool EventHandler::passMouseMovedEventToScrollbars(const PlatformMouseEvent&amp; event)
1922 {
1923     HitTestResult hoveredNode;
1924     return handleMouseMoveEvent(event, &amp;hoveredNode, true);
1925 }
1926 
1927 bool EventHandler::handleMouseMoveEvent(const PlatformMouseEvent&amp; platformMouseEvent, HitTestResult* hoveredNode, bool onlyUpdateScrollbars)
1928 {
1929 #if ENABLE(TOUCH_EVENTS)
1930     bool defaultPrevented = dispatchSyntheticTouchEventIfEnabled(platformMouseEvent);
1931     if (defaultPrevented)
1932         return true;
1933 #endif
1934 
1935     Ref&lt;Frame&gt; protectedFrame(m_frame);
1936     RefPtr&lt;FrameView&gt; protector(m_frame.view());
1937 
1938 #if ENABLE(POINTER_LOCK)
1939     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
1940         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(platformMouseEvent, eventNames().mousemoveEvent);
1941         return true;
1942     }
1943 #endif
1944 
1945     setLastKnownMousePosition(platformMouseEvent);
1946 
1947     if (m_hoverTimer.isActive())
1948         m_hoverTimer.stop();
1949 
<a name="22" id="anc22"></a>
1950     m_cursorUpdateTimer.stop();
<a name="23" id="anc23"></a>
1951 
1952 #if !ENABLE(IOS_TOUCH_EVENTS)
1953     cancelFakeMouseMoveEvent();
1954 #endif
1955 
1956     if (m_svgPan) {
1957         downcast&lt;SVGDocument&gt;(*m_frame.document()).updatePan(m_frame.view()-&gt;windowToContents(m_lastKnownMousePosition));
1958         return true;
1959     }
1960 
1961     if (m_frameSetBeingResized)
1962         return !dispatchMouseEvent(eventNames().mousemoveEvent, m_frameSetBeingResized.get(), false, 0, platformMouseEvent, false);
1963 
1964     // On iOS, our scrollbars are managed by UIKit.
1965 #if !PLATFORM(IOS_FAMILY)
1966     // Send events right to a scrollbar if the mouse is pressed.
1967     if (m_lastScrollbarUnderMouse &amp;&amp; m_mousePressed)
1968         return m_lastScrollbarUnderMouse-&gt;mouseMoved(platformMouseEvent);
1969 #endif
1970 
1971     HitTestRequest::HitTestRequestType hitType = HitTestRequest::Move | HitTestRequest::DisallowUserAgentShadowContent | HitTestRequest::AllowFrameScrollbars;
1972     if (m_mousePressed)
1973         hitType |= HitTestRequest::Active;
1974     else if (onlyUpdateScrollbars) {
1975         // Mouse events should be treated as &quot;read-only&quot; if we&#39;re updating only scrollbars. This
1976         // means that :hover and :active freeze in the state they were in, rather than updating
1977         // for nodes the mouse moves while the window is not key (which will be the case if
1978         // onlyUpdateScrollbars is true).
1979         hitType |= HitTestRequest::ReadOnly;
1980     }
1981 
1982 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
1983     // Treat any mouse move events as readonly if the user is currently touching the screen.
1984     if (m_touchPressed)
1985         hitType |= HitTestRequest::Active | HitTestRequest::ReadOnly;
1986 #endif
1987     HitTestRequest request(hitType);
1988     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, platformMouseEvent);
1989     if (hoveredNode)
1990         *hoveredNode = mouseEvent.hitTestResult();
1991 
1992     if (m_resizeLayer &amp;&amp; m_resizeLayer-&gt;inResizeMode())
1993         m_resizeLayer-&gt;resize(platformMouseEvent, m_offsetFromResizeCorner);
1994     else {
1995         Scrollbar* scrollbar = mouseEvent.scrollbar();
1996         updateLastScrollbarUnderMouse(scrollbar, m_mousePressed ? SetOrClearLastScrollbar::Clear : SetOrClearLastScrollbar::Set);
1997 
1998         // On iOS, our scrollbars are managed by UIKit.
1999 #if !PLATFORM(IOS_FAMILY)
2000         if (!m_mousePressed &amp;&amp; scrollbar)
2001             scrollbar-&gt;mouseMoved(platformMouseEvent); // Handle hover effects on platforms that support visual feedback on scrollbar hovering.
2002 #endif
2003         if (onlyUpdateScrollbars) {
2004             if (shouldSendMouseEventsToInactiveWindows())
2005                 updateMouseEventTargetNode(mouseEvent.targetNode(), platformMouseEvent, FireMouseOverOut::Yes);
2006 
2007             return true;
2008         }
2009     }
2010 
2011     bool swallowEvent = false;
2012     RefPtr&lt;Frame&gt; newSubframe = m_capturingMouseEventsElement.get() ? subframeForTargetNode(m_capturingMouseEventsElement.get()) : subframeForHitTestResult(mouseEvent);
2013 
2014     // We want mouseouts to happen first, from the inside out.  First send a move event to the last subframe so that it will fire mouseouts.
2015     if (m_lastMouseMoveEventSubframe &amp;&amp; m_lastMouseMoveEventSubframe-&gt;tree().isDescendantOf(&amp;m_frame) &amp;&amp; m_lastMouseMoveEventSubframe != newSubframe)
2016         passMouseMoveEventToSubframe(mouseEvent, m_lastMouseMoveEventSubframe.get());
2017 
2018     if (newSubframe) {
2019         // Update over/out state before passing the event to the subframe.
2020         updateMouseEventTargetNode(mouseEvent.targetNode(), platformMouseEvent, FireMouseOverOut::Yes);
2021 
2022         // Event dispatch in updateMouseEventTargetNode may have caused the subframe of the target
2023         // node to be detached from its FrameView, in which case the event should not be passed.
2024         if (newSubframe-&gt;view())
2025             swallowEvent |= passMouseMoveEventToSubframe(mouseEvent, newSubframe.get(), hoveredNode);
2026     }
2027 
2028     if (!newSubframe || mouseEvent.scrollbar()) {
<a name="24" id="anc24"></a>
2029         if (auto* view = m_frame.view())
2030             updateCursor(*view, mouseEvent.hitTestResult(), platformMouseEvent.shiftKey());
<a name="25" id="anc25"></a>
2031     }
2032 
2033     m_lastMouseMoveEventSubframe = newSubframe;
2034 
2035     if (swallowEvent)
2036         return true;
2037 
2038     swallowEvent = !dispatchMouseEvent(eventNames().mousemoveEvent, mouseEvent.targetNode(), false, 0, platformMouseEvent, true);
2039 #if ENABLE(DRAG_SUPPORT)
2040     if (!swallowEvent)
2041         swallowEvent = handleMouseDraggedEvent(mouseEvent);
2042 #endif
2043 
2044     return swallowEvent;
2045 }
2046 
2047 bool EventHandler::shouldSendMouseEventsToInactiveWindows() const
2048 {
2049 #if PLATFORM(GTK)
2050     return true;
2051 #endif
2052     return false;
2053 }
2054 
2055 void EventHandler::invalidateClick()
2056 {
2057     m_clickCount = 0;
2058     m_clickNode = nullptr;
2059 }
2060 
2061 static Node* targetNodeForClickEvent(Node* mousePressNode, Node* mouseReleaseNode)
2062 {
2063     if (!mousePressNode || !mouseReleaseNode)
2064         return nullptr;
2065 
2066     if (mousePressNode == mouseReleaseNode)
2067         return mouseReleaseNode;
2068 
2069     // If mousePressNode and mouseReleaseNode differ, we should fire the event at their common ancestor if there is one.
2070     if (&amp;mousePressNode-&gt;document() == &amp;mouseReleaseNode-&gt;document()) {
2071         if (auto* commonAncestor = Range::commonAncestorContainer(mousePressNode, mouseReleaseNode))
2072             return commonAncestor;
2073     }
2074 
2075     Element* mouseReleaseShadowHost = mouseReleaseNode-&gt;shadowHost();
2076     if (mouseReleaseShadowHost &amp;&amp; mouseReleaseShadowHost == mousePressNode-&gt;shadowHost()) {
2077         // We want to dispatch the click to the shadow tree host element to give listeners the illusion that the
2078         // shadom tree is a single element. For example, we want to give the illusion that &lt;input type=&quot;range&quot;&gt;
2079         // is a single element even though it is a composition of multiple shadom tree elements.
2080         return mouseReleaseShadowHost;
2081     }
2082     return nullptr;
2083 }
2084 
2085 bool EventHandler::handleMouseReleaseEvent(const PlatformMouseEvent&amp; platformMouseEvent)
2086 {
2087     Ref&lt;Frame&gt; protectedFrame(m_frame);
2088     RefPtr&lt;FrameView&gt; protector(m_frame.view());
2089 
2090     m_frame.selection().setCaretBlinkingSuspended(false);
2091 
2092 #if ENABLE(POINTER_LOCK)
2093     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
2094         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(platformMouseEvent, eventNames().mouseupEvent);
2095         return true;
2096     }
2097 #endif
2098 
2099     if (m_frame.page()-&gt;pageOverlayController().handleMouseEvent(platformMouseEvent))
2100         return true;
2101 
2102 #if ENABLE(TOUCH_EVENTS)
2103     bool defaultPrevented = dispatchSyntheticTouchEventIfEnabled(platformMouseEvent);
2104     if (defaultPrevented)
2105         return true;
2106 #endif
2107 
2108     UserGestureIndicator gestureIndicator(ProcessingUserGesture, m_frame.document());
2109 
2110 #if ENABLE(PAN_SCROLLING)
2111     m_autoscrollController-&gt;handleMouseReleaseEvent(platformMouseEvent);
2112 #endif
2113 
2114     m_mousePressed = false;
2115     setLastKnownMousePosition(platformMouseEvent);
2116 
2117     if (m_svgPan) {
2118         m_svgPan = false;
2119         downcast&lt;SVGDocument&gt;(*m_frame.document()).updatePan(m_frame.view()-&gt;windowToContents(m_lastKnownMousePosition));
2120         return true;
2121     }
2122 
2123     if (m_frameSetBeingResized)
2124         return !dispatchMouseEvent(eventNames().mouseupEvent, m_frameSetBeingResized.get(), true, m_clickCount, platformMouseEvent, false);
2125 
2126     // If an immediate action began or was completed using this series of mouse events, then we should send mouseup to
2127     // the DOM and return now so that we don&#39;t perform our own default behaviors.
2128     if (m_immediateActionStage == ImmediateActionStage::ActionCompleted || m_immediateActionStage == ImmediateActionStage::ActionUpdated || m_immediateActionStage == ImmediateActionStage::ActionCancelledAfterUpdate) {
2129         m_immediateActionStage = ImmediateActionStage::None;
2130         return !dispatchMouseEvent(eventNames().mouseupEvent, m_lastElementUnderMouse.get(), true, m_clickCount, platformMouseEvent, false);
2131     }
2132     m_immediateActionStage = ImmediateActionStage::None;
2133 
2134     if (m_lastScrollbarUnderMouse) {
2135         invalidateClick();
2136         m_lastScrollbarUnderMouse-&gt;mouseUp(platformMouseEvent);
2137         bool cancelable = true;
2138         bool setUnder = false;
2139         return !dispatchMouseEvent(eventNames().mouseupEvent, m_lastElementUnderMouse.get(), cancelable, m_clickCount, platformMouseEvent, setUnder);
2140     }
2141 
2142     HitTestRequest request(HitTestRequest::Release | HitTestRequest::DisallowUserAgentShadowContent);
2143     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, platformMouseEvent);
2144     Frame* subframe = m_capturingMouseEventsElement.get() ? subframeForTargetNode(m_capturingMouseEventsElement.get()) : subframeForHitTestResult(mouseEvent);
2145     if (m_eventHandlerWillResetCapturingMouseEventsElement)
2146         m_capturingMouseEventsElement = nullptr;
2147     if (subframe &amp;&amp; passMouseReleaseEventToSubframe(mouseEvent, subframe))
2148         return true;
2149 
2150     bool swallowMouseUpEvent = !dispatchMouseEvent(eventNames().mouseupEvent, mouseEvent.targetNode(), true, m_clickCount, platformMouseEvent, false);
2151 
2152     bool contextMenuEvent = platformMouseEvent.button() == RightButton;
2153 
2154     Node* nodeToClick = targetNodeForClickEvent(m_clickNode.get(), mouseEvent.targetNode());
2155     bool swallowClickEvent = m_clickCount &gt; 0 &amp;&amp; !contextMenuEvent &amp;&amp; nodeToClick &amp;&amp; !dispatchMouseEvent(eventNames().clickEvent, nodeToClick, true, m_clickCount, platformMouseEvent, true);
2156 
2157     if (m_resizeLayer) {
2158         m_resizeLayer-&gt;setInResizeMode(false);
2159         m_resizeLayer = nullptr;
2160     }
2161 
2162     bool swallowMouseReleaseEvent = false;
2163     if (!swallowMouseUpEvent)
2164         swallowMouseReleaseEvent = handleMouseReleaseEvent(mouseEvent);
2165 
2166     invalidateClick();
2167 
2168     return swallowMouseUpEvent || swallowClickEvent || swallowMouseReleaseEvent;
2169 }
2170 
2171 #if ENABLE(MOUSE_FORCE_EVENTS)
2172 bool EventHandler::handleMouseForceEvent(const PlatformMouseEvent&amp; event)
2173 {
2174     Ref&lt;Frame&gt; protectedFrame(m_frame);
2175     RefPtr&lt;FrameView&gt; protector(m_frame.view());
2176 
2177 #if ENABLE(POINTER_LOCK)
2178     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
2179         m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(event, eventNames().webkitmouseforcechangedEvent);
2180         if (event.type() == PlatformEvent::MouseForceDown)
2181             m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(event, eventNames().webkitmouseforcedownEvent);
2182         if (event.type() == PlatformEvent::MouseForceUp)
2183             m_frame.page()-&gt;pointerLockController().dispatchLockedMouseEvent(event, eventNames().webkitmouseforceupEvent);
2184         return true;
2185     }
2186 #endif
2187 
2188     setLastKnownMousePosition(event);
2189 
2190     HitTestRequest::HitTestRequestType hitType = HitTestRequest::DisallowUserAgentShadowContent;
2191 
2192     if (event.force())
2193         hitType |= HitTestRequest::Active;
2194 
2195     HitTestRequest request(hitType);
2196     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, event);
2197 
2198     bool swallowedEvent = !dispatchMouseEvent(eventNames().webkitmouseforcechangedEvent, mouseEvent.targetNode(), false, 0, event, false);
2199     if (event.type() == PlatformEvent::MouseForceDown)
2200         swallowedEvent |= !dispatchMouseEvent(eventNames().webkitmouseforcedownEvent, mouseEvent.targetNode(), false, 0, event, false);
2201     if (event.type() == PlatformEvent::MouseForceUp)
2202         swallowedEvent |= !dispatchMouseEvent(eventNames().webkitmouseforceupEvent, mouseEvent.targetNode(), false, 0, event, false);
2203 
2204     return swallowedEvent;
2205 }
2206 #else
2207 bool EventHandler::handleMouseForceEvent(const PlatformMouseEvent&amp; )
2208 {
2209     return false;
2210 }
2211 #endif // #if ENABLE(MOUSE_FORCE_EVENTS)
2212 
2213 bool EventHandler::handlePasteGlobalSelection(const PlatformMouseEvent&amp; platformMouseEvent)
2214 {
2215     // If the event was a middle click, attempt to copy global selection in after
2216     // the newly set caret position.
2217     //
2218     // This code is called from either the mouse up or mouse down handling. There
2219     // is some debate about when the global selection is pasted:
2220     //   xterm: pastes on up.
2221     //   GTK: pastes on down.
2222     //   Qt: pastes on up.
2223     //   Firefox: pastes on up.
2224     //   Chromium: pastes on up.
2225     //
2226     // There is something of a webcompat angle to this well, as highlighted by
2227     // crbug.com/14608. Pages can clear text boxes &#39;onclick&#39; and, if we paste on
2228     // down then the text is pasted just before the onclick handler runs and
2229     // clears the text box. So it&#39;s important this happens after the event
2230     // handlers have been fired.
2231 #if PLATFORM(GTK)
2232     if (platformMouseEvent.type() != PlatformEvent::MousePressed)
2233         return false;
2234 #else
2235     if (platformMouseEvent.type() != PlatformEvent::MouseReleased)
2236         return false;
2237 #endif
2238 
2239     if (!m_frame.page())
2240         return false;
2241     Frame&amp; focusFrame = m_frame.page()-&gt;focusController().focusedOrMainFrame();
2242     // Do not paste here if the focus was moved somewhere else.
2243     if (&amp;m_frame == &amp;focusFrame &amp;&amp; m_frame.editor().client()-&gt;supportsGlobalSelection())
2244         return m_frame.editor().command(&quot;PasteGlobalSelection&quot;_s).execute();
2245 
2246     return false;
2247 }
2248 
2249 #if ENABLE(DRAG_SUPPORT)
2250 
2251 bool EventHandler::dispatchDragEvent(const AtomString&amp; eventType, Element&amp; dragTarget, const PlatformMouseEvent&amp; event, DataTransfer&amp; dataTransfer)
2252 {
2253     Ref&lt;Frame&gt; protectedFrame(m_frame);
2254     FrameView* view = m_frame.view();
2255 
2256     // FIXME: We might want to dispatch a dragleave even if the view is gone.
2257     if (!view)
2258         return false;
2259 
2260     view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
<a name="26" id="anc26"></a><span class="line-modified">2261 </span>
<span class="line-modified">2262     auto dragEvent = DragEvent::create(eventType, Event::CanBubble::Yes, Event::IsCancelable::Yes, Event::IsComposed::Yes,</span>
2263         event.timestamp().approximateMonotonicTime(), &amp;m_frame.windowProxy(), 0,
2264         event.globalPosition(), event.position(),
2265 #if ENABLE(POINTER_LOCK)
2266         event.movementDelta(),
2267 #else
2268         { },
2269 #endif
2270         event.modifiers(), 0, 0, nullptr, event.force(), NoTap, &amp;dataTransfer);
2271 
<a name="27" id="anc27"></a><span class="line-modified">2272     dragTarget.dispatchEvent(dragEvent);</span>
<span class="line-modified">2273     return dragEvent-&gt;defaultPrevented();</span>
2274 }
2275 
2276 static bool targetIsFrame(Node* target, Frame*&amp; frame)
2277 {
2278     if (!is&lt;HTMLFrameElementBase&gt;(target))
2279         return false;
2280 
2281     frame = downcast&lt;HTMLFrameElementBase&gt;(*target).contentFrame();
2282     return true;
2283 }
2284 
2285 static DragOperation convertDropZoneOperationToDragOperation(const String&amp; dragOperation)
2286 {
2287     if (dragOperation == &quot;copy&quot;)
2288         return DragOperationCopy;
2289     if (dragOperation == &quot;move&quot;)
2290         return DragOperationMove;
2291     if (dragOperation == &quot;link&quot;)
2292         return DragOperationLink;
2293     return DragOperationNone;
2294 }
2295 
2296 static String convertDragOperationToDropZoneOperation(DragOperation operation)
2297 {
2298     switch (operation) {
2299     case DragOperationCopy:
2300         return &quot;copy&quot;_s;
2301     case DragOperationMove:
2302         return &quot;move&quot;_s;
2303     case DragOperationLink:
2304         return &quot;link&quot;_s;
2305     default:
2306         return &quot;copy&quot;_s;
2307     }
2308 }
2309 
2310 static bool hasDropZoneType(DataTransfer&amp; dataTransfer, const String&amp; keyword)
2311 {
2312     if (keyword.startsWith(&quot;file:&quot;))
2313         return dataTransfer.hasFileOfType(keyword.substring(5));
2314 
2315     if (keyword.startsWith(&quot;string:&quot;))
2316         return dataTransfer.hasStringOfType(keyword.substring(7));
2317 
2318     return false;
2319 }
2320 
2321 static bool findDropZone(Node&amp; target, DataTransfer&amp; dataTransfer)
2322 {
2323     RefPtr&lt;Element&gt; element = is&lt;Element&gt;(target) ? &amp;downcast&lt;Element&gt;(target) : target.parentElement();
2324     for (; element; element = element-&gt;parentElement()) {
2325         SpaceSplitString keywords(element-&gt;attributeWithoutSynchronization(webkitdropzoneAttr), true);
2326         bool matched = false;
2327         DragOperation dragOperation = DragOperationNone;
2328         for (unsigned i = 0, size = keywords.size(); i &lt; size; ++i) {
2329             DragOperation op = convertDropZoneOperationToDragOperation(keywords[i]);
2330             if (op != DragOperationNone) {
2331                 if (dragOperation == DragOperationNone)
2332                     dragOperation = op;
2333             } else
2334                 matched = matched || hasDropZoneType(dataTransfer, keywords[i].string());
2335             if (matched &amp;&amp; dragOperation != DragOperationNone)
2336                 break;
2337         }
2338         if (matched) {
2339             dataTransfer.setDropEffect(convertDragOperationToDropZoneOperation(dragOperation));
2340             return true;
2341         }
2342     }
2343     return false;
2344 }
2345 
2346 EventHandler::DragTargetResponse EventHandler::dispatchDragEnterOrDragOverEvent(const AtomString&amp; eventType, Element&amp; target, const PlatformMouseEvent&amp; event,
2347     std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
2348 {
2349     auto dataTransfer = DataTransfer::createForUpdatingDropTarget(target.document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
2350     bool accept = dispatchDragEvent(eventType, target, event, dataTransfer.get());
2351     if (!accept)
2352         accept = findDropZone(target, dataTransfer);
2353     dataTransfer-&gt;makeInvalidForSecurity();
2354     if (accept &amp;&amp; !dataTransfer-&gt;dropEffectIsUninitialized())
2355         return { true, dataTransfer-&gt;destinationOperation() };
2356     return { accept, WTF::nullopt };
2357 }
2358 
2359 EventHandler::DragTargetResponse EventHandler::updateDragAndDrop(const PlatformMouseEvent&amp; event, const std::function&lt;std::unique_ptr&lt;Pasteboard&gt;()&gt;&amp; makePasteboard, DragOperation sourceOperation, bool draggingFiles)
2360 {
2361     Ref&lt;Frame&gt; protectedFrame(m_frame);
2362     if (!m_frame.view())
2363         return { };
2364 
2365     HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::DisallowUserAgentShadowContent);
2366     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, event);
2367 
2368     RefPtr&lt;Element&gt; newTarget;
2369     if (Node* targetNode = mouseEvent.targetNode()) {
2370         // Drag events should never go to non-element nodes (following IE, and proper mouseover/out dispatch)
2371         if (!is&lt;Element&gt;(*targetNode))
2372             newTarget = targetNode-&gt;parentOrShadowHostElement();
2373         else
2374             newTarget = downcast&lt;Element&gt;(targetNode);
2375     }
2376 
2377     m_autoscrollController-&gt;updateDragAndDrop(newTarget.get(), event.position(), event.timestamp());
2378 
2379     DragTargetResponse response;
2380     if (m_dragTarget != newTarget) {
2381         // FIXME: this ordering was explicitly chosen to match WinIE. However,
2382         // it is sometimes incorrect when dragging within subframes, as seen with
2383         // LayoutTests/fast/events/drag-in-frames.html.
2384         //
2385         // Moreover, this ordering conforms to section 7.9.4 of the HTML 5 spec. &lt;http://dev.w3.org/html5/spec/Overview.html#drag-and-drop-processing-model&gt;.
2386         Frame* targetFrame;
2387         if (targetIsFrame(newTarget.get(), targetFrame)) {
2388             if (targetFrame)
2389                 response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
2390         } else if (newTarget) {
2391             // As per section 7.9.4 of the HTML 5 spec., we must always fire a drag event before firing a dragenter, dragleave, or dragover event.
<a name="28" id="anc28"></a><span class="line-modified">2392             dispatchEventToDragSourceElement(eventNames().dragEvent, event);</span>

2393             response = dispatchDragEnterOrDragOverEvent(eventNames().dragenterEvent, *newTarget, event, makePasteboard(), sourceOperation, draggingFiles);
2394         }
2395 
2396         if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
2397             // FIXME: Recursing again here doesn&#39;t make sense if the newTarget and m_dragTarget were in the same frame.
2398             if (targetFrame)
2399                 response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
2400         } else if (m_dragTarget) {
2401             auto dataTransfer = DataTransfer::createForUpdatingDropTarget(m_dragTarget-&gt;document(), makePasteboard(), sourceOperation, draggingFiles);
2402             dispatchDragEvent(eventNames().dragleaveEvent, *m_dragTarget, event, dataTransfer.get());
2403             dataTransfer-&gt;makeInvalidForSecurity();
2404         }
2405 
2406         if (newTarget) {
2407             // We do not explicitly call dispatchDragEvent here because it could ultimately result in the appearance that
2408             // two dragover events fired. So, we mark that we should only fire a dragover event on the next call to this function.
2409             m_shouldOnlyFireDragOverEvent = true;
2410         }
2411     } else {
2412         Frame* targetFrame;
2413         if (targetIsFrame(newTarget.get(), targetFrame)) {
2414             if (targetFrame)
2415                 response = targetFrame-&gt;eventHandler().updateDragAndDrop(event, makePasteboard, sourceOperation, draggingFiles);
2416         } else if (newTarget) {
2417             // Note, when dealing with sub-frames, we may need to fire only a dragover event as a drag event may have been fired earlier.
<a name="29" id="anc29"></a><span class="line-modified">2418             if (!m_shouldOnlyFireDragOverEvent)</span>
<span class="line-modified">2419                 dispatchEventToDragSourceElement(eventNames().dragEvent, event);</span>
2420             response = dispatchDragEnterOrDragOverEvent(eventNames().dragoverEvent, *newTarget, event, makePasteboard(), sourceOperation, draggingFiles);
2421             m_shouldOnlyFireDragOverEvent = false;
2422         }
2423     }
2424     m_dragTarget = WTFMove(newTarget);
2425     return response;
2426 }
2427 
2428 void EventHandler::cancelDragAndDrop(const PlatformMouseEvent&amp; event, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
2429 {
2430     Ref&lt;Frame&gt; protectedFrame(m_frame);
2431 
2432     Frame* targetFrame;
2433     if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
2434         if (targetFrame)
2435             targetFrame-&gt;eventHandler().cancelDragAndDrop(event, WTFMove(pasteboard), sourceOperation, draggingFiles);
2436     } else if (m_dragTarget) {
<a name="30" id="anc30"></a><span class="line-modified">2437         dispatchEventToDragSourceElement(eventNames().dragEvent, event);</span>

2438 
2439         auto dataTransfer = DataTransfer::createForUpdatingDropTarget(m_dragTarget-&gt;document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
2440         dispatchDragEvent(eventNames().dragleaveEvent, *m_dragTarget, event, dataTransfer.get());
2441         dataTransfer-&gt;makeInvalidForSecurity();
2442     }
2443     clearDragState();
2444 }
2445 
2446 bool EventHandler::performDragAndDrop(const PlatformMouseEvent&amp; event, std::unique_ptr&lt;Pasteboard&gt;&amp;&amp; pasteboard, DragOperation sourceOperation, bool draggingFiles)
2447 {
2448     Ref&lt;Frame&gt; protectedFrame(m_frame);
2449 
2450     Frame* targetFrame;
2451     bool preventedDefault = false;
2452     if (targetIsFrame(m_dragTarget.get(), targetFrame)) {
2453         if (targetFrame)
2454             preventedDefault = targetFrame-&gt;eventHandler().performDragAndDrop(event, WTFMove(pasteboard), sourceOperation, draggingFiles);
2455     } else if (m_dragTarget) {
2456         auto dataTransfer = DataTransfer::createForDrop(m_dragTarget-&gt;document(), WTFMove(pasteboard), sourceOperation, draggingFiles);
2457         preventedDefault = dispatchDragEvent(eventNames().dropEvent, *m_dragTarget, event, dataTransfer);
2458         dataTransfer-&gt;makeInvalidForSecurity();
2459     }
2460     clearDragState();
2461     return preventedDefault;
2462 }
2463 
2464 void EventHandler::clearDragState()
2465 {
2466     stopAutoscrollTimer();
2467     m_dragTarget = nullptr;
2468     m_capturingMouseEventsElement = nullptr;
2469     m_shouldOnlyFireDragOverEvent = false;
2470 #if PLATFORM(COCOA)
2471     m_sendingEventToSubview = false;
2472 #endif
2473 }
2474 
2475 #endif // ENABLE(DRAG_SUPPORT)
2476 
2477 void EventHandler::setCapturingMouseEventsElement(Element* element)
2478 {
2479     m_capturingMouseEventsElement = element;
2480     m_eventHandlerWillResetCapturingMouseEventsElement = false;
2481 }
2482 
2483 #if ENABLE(POINTER_EVENTS)
2484 void EventHandler::pointerCaptureElementDidChange(Element* element)
2485 {
2486     if (m_capturingMouseEventsElement == element)
2487         return;
2488 
2489     setCapturingMouseEventsElement(element);
2490 
2491     // Now that we have a new capture element, we need to dispatch boundary mouse events.
2492     updateMouseEventTargetNode(element, m_lastPlatformMouseEvent, FireMouseOverOut::Yes);
2493 }
2494 #endif
2495 
2496 MouseEventWithHitTestResults EventHandler::prepareMouseEvent(const HitTestRequest&amp; request, const PlatformMouseEvent&amp; mouseEvent)
2497 {
2498 #if ENABLE(POINTER_EVENTS)
2499     m_lastPlatformMouseEvent = mouseEvent;
2500 #endif
2501     Ref&lt;Frame&gt; protectedFrame(m_frame);
2502     ASSERT(m_frame.document());
2503     return m_frame.document()-&gt;prepareMouseEvent(request, documentPointForWindowPoint(m_frame, mouseEvent.position()), mouseEvent);
2504 }
2505 
2506 static bool hierarchyHasCapturingEventListeners(Element* element, const AtomString&amp; pointerEventName, const AtomString&amp; compatibilityMouseEventName)
2507 {
2508     for (ContainerNode* curr = element; curr; curr = curr-&gt;parentInComposedTree()) {
2509         if (curr-&gt;hasCapturingEventListeners(pointerEventName) || curr-&gt;hasCapturingEventListeners(compatibilityMouseEventName))
2510             return true;
2511     }
2512     return false;
2513 }
2514 
2515 void EventHandler::updateMouseEventTargetNode(Node* targetNode, const PlatformMouseEvent&amp; platformMouseEvent, FireMouseOverOut fireMouseOverOut)
2516 {
2517     Ref&lt;Frame&gt; protectedFrame(m_frame);
2518     Element* targetElement = nullptr;
2519 
2520     // If we&#39;re capturing, we always go right to that element.
2521     if (m_capturingMouseEventsElement)
2522         targetElement = m_capturingMouseEventsElement.get();
2523     else if (targetNode) {
2524         // If the target node is a non-element, dispatch on the parent. &lt;rdar://problem/4196646&gt;
2525         while (targetNode &amp;&amp; !is&lt;Element&gt;(*targetNode))
2526             targetNode = targetNode-&gt;parentInComposedTree();
2527         targetElement = downcast&lt;Element&gt;(targetNode);
2528     }
2529 
2530     m_elementUnderMouse = targetElement;
2531 
2532     // Fire mouseout/mouseover if the mouse has shifted to a different node.
2533     if (fireMouseOverOut == FireMouseOverOut::Yes) {
2534         auto scrollableAreaForLastNode = enclosingScrollableArea(m_lastElementUnderMouse.get());
2535         auto scrollableAreaForNodeUnderMouse = enclosingScrollableArea(m_elementUnderMouse.get());
2536         Page* page = m_frame.page();
2537 
2538         if (m_lastElementUnderMouse &amp;&amp; (!m_elementUnderMouse || &amp;m_elementUnderMouse-&gt;document() != m_frame.document())) {
2539             // The mouse has moved between frames.
2540             if (Frame* frame = m_lastElementUnderMouse-&gt;document().frame()) {
2541                 if (FrameView* frameView = frame-&gt;view())
2542                     frameView-&gt;mouseExitedContentArea();
2543             }
2544         } else if (page &amp;&amp; (scrollableAreaForLastNode &amp;&amp; (!scrollableAreaForNodeUnderMouse || scrollableAreaForNodeUnderMouse != scrollableAreaForLastNode))) {
2545             // The mouse has moved between layers.
2546             if (Frame* frame = m_lastElementUnderMouse-&gt;document().frame()) {
2547                 if (FrameView* frameView = frame-&gt;view()) {
2548                     if (frameView-&gt;containsScrollableArea(scrollableAreaForLastNode))
2549                         scrollableAreaForLastNode-&gt;mouseExitedContentArea();
2550                 }
2551             }
2552         }
2553 
2554         if (m_elementUnderMouse &amp;&amp; (!m_lastElementUnderMouse || &amp;m_lastElementUnderMouse-&gt;document() != m_frame.document())) {
2555             // The mouse has moved between frames.
2556             if (Frame* frame = m_elementUnderMouse-&gt;document().frame()) {
2557                 if (FrameView* frameView = frame-&gt;view())
2558                     frameView-&gt;mouseEnteredContentArea();
2559             }
2560         } else if (page &amp;&amp; (scrollableAreaForNodeUnderMouse &amp;&amp; (!scrollableAreaForLastNode || scrollableAreaForNodeUnderMouse != scrollableAreaForLastNode))) {
2561             // The mouse has moved between layers.
2562             if (Frame* frame = m_elementUnderMouse-&gt;document().frame()) {
2563                 if (FrameView* frameView = frame-&gt;view()) {
2564                     if (frameView-&gt;containsScrollableArea(scrollableAreaForNodeUnderMouse))
2565                         scrollableAreaForNodeUnderMouse-&gt;mouseEnteredContentArea();
2566                 }
2567             }
2568         }
2569 
2570         if (m_lastElementUnderMouse &amp;&amp; &amp;m_lastElementUnderMouse-&gt;document() != m_frame.document()) {
2571             m_lastElementUnderMouse = nullptr;
2572             m_lastScrollbarUnderMouse = nullptr;
2573         }
2574 
2575         if (m_lastElementUnderMouse != m_elementUnderMouse) {
2576             // mouseenter and mouseleave events are only dispatched if there is a capturing eventhandler on an ancestor
2577             // or a normal eventhandler on the element itself (they don&#39;t bubble).
2578             // This optimization is necessary since these events can cause O(n^2) capturing event-handler checks.
2579             bool hasCapturingMouseEnterListener = hierarchyHasCapturingEventListeners(m_elementUnderMouse.get(), eventNames().pointerenterEvent, eventNames().mouseenterEvent);
2580             bool hasCapturingMouseLeaveListener = hierarchyHasCapturingEventListeners(m_lastElementUnderMouse.get(), eventNames().pointerleaveEvent, eventNames().mouseleaveEvent);
2581 
2582             Vector&lt;Ref&lt;Element&gt;, 32&gt; leftElementsChain;
2583             for (Element* element = m_lastElementUnderMouse.get(); element; element = element-&gt;parentElementInComposedTree())
2584                 leftElementsChain.append(*element);
2585             Vector&lt;Ref&lt;Element&gt;, 32&gt; enteredElementsChain;
2586             for (Element* element = m_elementUnderMouse.get(); element; element = element-&gt;parentElementInComposedTree())
2587                 enteredElementsChain.append(*element);
2588 
2589             if (!leftElementsChain.isEmpty() &amp;&amp; !enteredElementsChain.isEmpty() &amp;&amp; leftElementsChain.last().ptr() == enteredElementsChain.last().ptr()) {
2590                 size_t minHeight = std::min(leftElementsChain.size(), enteredElementsChain.size());
2591                 size_t i;
2592                 for (i = 0; i &lt; minHeight; ++i) {
2593                     if (leftElementsChain[leftElementsChain.size() - i - 1].ptr() != enteredElementsChain[enteredElementsChain.size() - i - 1].ptr())
2594                         break;
2595                 }
2596                 leftElementsChain.shrink(leftElementsChain.size() - i);
2597                 enteredElementsChain.shrink(enteredElementsChain.size() - i);
2598             }
2599 
2600             if (m_lastElementUnderMouse)
2601                 m_lastElementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseoutEvent, 0, m_elementUnderMouse.get());
2602 
2603             for (auto&amp; chain : leftElementsChain) {
2604                 if (hasCapturingMouseLeaveListener || chain-&gt;hasEventListeners(eventNames().pointerleaveEvent) || chain-&gt;hasEventListeners(eventNames().mouseleaveEvent))
2605                     chain-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseleaveEvent, 0, m_elementUnderMouse.get());
2606             }
2607 
2608             if (m_elementUnderMouse)
2609                 m_elementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseoverEvent, 0, m_lastElementUnderMouse.get());
2610 
2611             for (auto&amp; chain : WTF::makeReversedRange(enteredElementsChain)) {
2612                 if (hasCapturingMouseEnterListener || chain-&gt;hasEventListeners(eventNames().pointerenterEvent) || chain-&gt;hasEventListeners(eventNames().mouseenterEvent))
2613                     chain-&gt;dispatchMouseEvent(platformMouseEvent, eventNames().mouseenterEvent, 0, m_lastElementUnderMouse.get());
2614             }
2615         }
2616         m_lastElementUnderMouse = m_elementUnderMouse;
2617     }
2618 }
2619 
<a name="31" id="anc31"></a><span class="line-added">2620 static RefPtr&lt;Element&gt; findFirstMouseFocusableElementInComposedTree(Element&amp; host)</span>
<span class="line-added">2621 {</span>
<span class="line-added">2622     ASSERT(host.shadowRoot());</span>
<span class="line-added">2623     for (auto&amp; node : composedTreeDescendants(host)) {</span>
<span class="line-added">2624         if (!is&lt;Element&gt;(node))</span>
<span class="line-added">2625             continue;</span>
<span class="line-added">2626         auto&amp; element = downcast&lt;Element&gt;(node);</span>
<span class="line-added">2627         if (element.isMouseFocusable())</span>
<span class="line-added">2628             return &amp;element;</span>
<span class="line-added">2629     }</span>
<span class="line-added">2630     return nullptr;</span>
<span class="line-added">2631 }</span>
<span class="line-added">2632 </span>
2633 bool EventHandler::dispatchMouseEvent(const AtomString&amp; eventType, Node* targetNode, bool /*cancelable*/, int clickCount, const PlatformMouseEvent&amp; platformMouseEvent, bool setUnder)
2634 {
2635     Ref&lt;Frame&gt; protectedFrame(m_frame);
2636 
2637     if (auto* view = m_frame.view())
2638         view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
2639 
2640     updateMouseEventTargetNode(targetNode, platformMouseEvent, setUnder ? FireMouseOverOut::Yes : FireMouseOverOut::No);
2641 
2642     if (m_elementUnderMouse &amp;&amp; !m_elementUnderMouse-&gt;dispatchMouseEvent(platformMouseEvent, eventType, clickCount))
2643         return false;
2644 
2645     if (eventType != eventNames().mousedownEvent)
2646         return true;
2647 
2648     // If clicking on a frame scrollbar, do not make any change to which element is focused.
2649     auto* view = m_frame.view();
2650     if (view &amp;&amp; view-&gt;scrollbarAtPoint(platformMouseEvent.position()))
2651         return true;
2652 
2653     // The layout needs to be up to date to determine if an element is focusable.
2654     m_frame.document()-&gt;updateLayoutIgnorePendingStylesheets();
2655 
2656     // Remove focus from the currently focused element when a link or button is clicked.
2657     // This is expected by some sites that rely on change event handlers running
2658     // from form fields before the button click is processed, behavior that was inherited
2659     // from the user interface of Windows, where pushing a button moves focus to the button.
2660 
2661     // Walk up the DOM tree to search for an element to focus.
2662     RefPtr&lt;Element&gt; element;
2663     for (element = m_elementUnderMouse.get(); element; element = element-&gt;parentElementInComposedTree()) {
<a name="32" id="anc32"></a><span class="line-added">2664         if (auto* shadowRoot = element-&gt;shadowRoot()) {</span>
<span class="line-added">2665             if (shadowRoot-&gt;delegatesFocus()) {</span>
<span class="line-added">2666                 element = findFirstMouseFocusableElementInComposedTree(*element);</span>
<span class="line-added">2667                 break;</span>
<span class="line-added">2668             }</span>
<span class="line-added">2669         }</span>
2670         if (element-&gt;isMouseFocusable())
2671             break;
2672     }
2673 
2674     // To fix &lt;rdar://problem/4895428&gt; Can&#39;t drag selected ToDo, we don&#39;t focus an
2675     // element on mouse down if it&#39;s selected and inside a focused element. It will be
2676     // focused if the user does a mouseup over it, however, because the mouseup
2677     // will set a selection inside it, which will also set the focused element.
2678     if (element &amp;&amp; m_frame.selection().isRange()) {
2679         if (auto range = m_frame.selection().toNormalizedRange()) {
2680             auto result = range-&gt;compareNode(*element);
2681             if (!result.hasException() &amp;&amp; result.releaseReturnValue() == Range::NODE_INSIDE &amp;&amp; element-&gt;isDescendantOf(m_frame.document()-&gt;focusedElement()))
2682                 return true;
2683         }
2684     }
2685 
2686     // Only change the focus when clicking scrollbars if it can be transferred to a mouse focusable node.
2687     if (!element &amp;&amp; isInsideScrollbar(platformMouseEvent.position()))
2688         return false;
2689 
2690     // If focus shift is blocked, we eat the event.
2691     auto* page = m_frame.page();
2692     if (page &amp;&amp; !page-&gt;focusController().setFocusedElement(element.get(), m_frame))
2693         return false;
2694 
2695     return true;
2696 }
2697 
2698 bool EventHandler::isInsideScrollbar(const IntPoint&amp; windowPoint) const
2699 {
2700     if (auto* document = m_frame.document()) {
2701         HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::DisallowUserAgentShadowContent);
2702         HitTestResult result(windowPoint);
2703         document-&gt;hitTest(request, result);
2704         return result.scrollbar();
2705     }
2706 
2707     return false;
2708 }
2709 
2710 #if !USE(GLIB)
2711 
2712 bool EventHandler::shouldSwapScrollDirection(const HitTestResult&amp;, const PlatformWheelEvent&amp;) const
2713 {
2714     return false;
2715 }
2716 
2717 #endif
2718 
2719 #if !PLATFORM(MAC)
2720 
2721 void EventHandler::platformPrepareForWheelEvents(const PlatformWheelEvent&amp;, const HitTestResult&amp;, RefPtr&lt;Element&gt;&amp;, RefPtr&lt;ContainerNode&gt;&amp;, WeakPtr&lt;ScrollableArea&gt;&amp;, bool&amp;)
2722 {
2723 }
2724 
2725 void EventHandler::platformRecordWheelEvent(const PlatformWheelEvent&amp; event)
2726 {
2727     if (auto* page = m_frame.page())
2728         page-&gt;wheelEventDeltaFilter()-&gt;updateFromDelta(FloatSize(event.deltaX(), event.deltaY()));
2729 }
2730 
2731 bool EventHandler::platformCompleteWheelEvent(const PlatformWheelEvent&amp; event, ContainerNode*, const WeakPtr&lt;ScrollableArea&gt;&amp;)
2732 {
2733     Ref&lt;Frame&gt; protectedFrame(m_frame);
2734 
2735     // We do another check on the frame view because the event handler can run JS which results in the frame getting destroyed.
2736     FrameView* view = m_frame.view();
2737 
2738     bool didHandleEvent = view ? view-&gt;wheelEvent(event) : false;
2739     m_isHandlingWheelEvent = false;
2740     return didHandleEvent;
2741 }
2742 
2743 bool EventHandler::platformCompletePlatformWidgetWheelEvent(const PlatformWheelEvent&amp;, const Widget&amp;, ContainerNode*)
2744 {
2745     return true;
2746 }
2747 
2748 void EventHandler::platformNotifyIfEndGesture(const PlatformWheelEvent&amp;, const WeakPtr&lt;ScrollableArea&gt;&amp;)
2749 {
2750 }
2751 
2752 void EventHandler::clearOrScheduleClearingLatchedStateIfNeeded(const PlatformWheelEvent&amp;)
2753 {
2754     clearLatchedState();
2755 }
2756 
2757 #if !PLATFORM(IOS_FAMILY)
2758 
2759 IntPoint EventHandler::targetPositionInWindowForSelectionAutoscroll() const
2760 {
2761     return m_lastKnownMousePosition;
2762 }
2763 
2764 #endif // !PLATFORM(IOS_FAMILY)
2765 
2766 #endif // !PLATFORM(MAC)
2767 
2768 #if !PLATFORM(IOS_FAMILY)
2769 
2770 bool EventHandler::shouldUpdateAutoscroll()
2771 {
2772     return mousePressed();
2773 }
2774 
2775 #endif // !PLATFORM(IOS_FAMILY)
2776 
2777 Widget* EventHandler::widgetForEventTarget(Element* eventTarget)
2778 {
2779     if (!eventTarget)
2780         return nullptr;
2781 
2782     auto* target = eventTarget-&gt;renderer();
2783     if (!is&lt;RenderWidget&gt;(target))
2784         return nullptr;
2785 
2786     return downcast&lt;RenderWidget&gt;(*target).widget();
2787 }
2788 
2789 static WeakPtr&lt;Widget&gt; widgetForElement(const Element&amp; element)
2790 {
2791     auto target = element.renderer();
2792     if (!is&lt;RenderWidget&gt;(target) || !downcast&lt;RenderWidget&gt;(*target).widget())
2793         return { };
2794 
2795     return makeWeakPtr(*downcast&lt;RenderWidget&gt;(*target).widget());
2796 }
2797 
2798 bool EventHandler::completeWidgetWheelEvent(const PlatformWheelEvent&amp; event, const WeakPtr&lt;Widget&gt;&amp; widget, const WeakPtr&lt;ScrollableArea&gt;&amp; scrollableArea, ContainerNode* scrollableContainer)
2799 {
2800     m_isHandlingWheelEvent = false;
2801 
2802     // We do another check on the widget because the event handler can run JS which results in the frame getting destroyed.
2803     if (!widget)
2804         return false;
2805 
2806     if (scrollableArea)
2807         scrollableArea-&gt;setScrollShouldClearLatchedState(false);
2808 
2809     platformNotifyIfEndGesture(event, scrollableArea);
2810 
2811     if (!widget-&gt;platformWidget())
2812         return true;
2813 
2814     return platformCompletePlatformWidgetWheelEvent(event, *widget.get(), scrollableContainer);
2815 }
2816 
2817 bool EventHandler::handleWheelEvent(const PlatformWheelEvent&amp; event)
2818 {
2819     auto* document = m_frame.document();
2820     if (!document)
2821         return false;
2822 
2823     Ref&lt;Frame&gt; protectedFrame(m_frame);
2824     RefPtr&lt;FrameView&gt; protector(m_frame.view());
2825 
2826     FrameView* view = m_frame.view();
2827     if (!view)
2828         return false;
2829 
2830 #if ENABLE(POINTER_LOCK)
2831     if (m_frame.page()-&gt;pointerLockController().isLocked()) {
2832         m_frame.page()-&gt;pointerLockController().dispatchLockedWheelEvent(event);
2833         return true;
2834     }
2835 #endif
2836 
2837     m_isHandlingWheelEvent = true;
2838     setFrameWasScrolledByUser();
2839 
2840     HitTestRequest request;
2841     HitTestResult result(view-&gt;windowToContents(event.position()));
2842     document-&gt;hitTest(request, result);
2843 
2844     RefPtr&lt;Element&gt; element = result.targetElement();
2845     RefPtr&lt;ContainerNode&gt; scrollableContainer;
2846     WeakPtr&lt;ScrollableArea&gt; scrollableArea;
2847     bool isOverWidget = result.isOverWidget();
2848     platformPrepareForWheelEvents(event, result, element, scrollableContainer, scrollableArea, isOverWidget);
2849 
2850 #if PLATFORM(MAC)
2851     if (event.phase() == PlatformWheelEventPhaseNone &amp;&amp; event.momentumPhase() == PlatformWheelEventPhaseNone &amp;&amp; m_frame.page())
2852         m_frame.page()-&gt;resetLatchingState();
2853 #endif
2854 
2855     // FIXME: It should not be necessary to do this mutation here.
2856     // Instead, the handlers should know convert vertical scrolls appropriately.
2857     PlatformWheelEvent adjustedEvent = shouldSwapScrollDirection(result, event) ? event.copySwappingDirection() : event;
2858     platformRecordWheelEvent(adjustedEvent);
2859 
2860     if (element) {
2861         if (isOverWidget) {
2862             if (WeakPtr&lt;Widget&gt; widget = widgetForElement(*element)) {
2863                 if (widgetDidHandleWheelEvent(event, *widget.get()))
2864                     return completeWidgetWheelEvent(adjustedEvent, widget, scrollableArea, scrollableContainer.get());
2865             }
2866         }
2867 
2868         if (!element-&gt;dispatchWheelEvent(adjustedEvent)) {
2869             m_isHandlingWheelEvent = false;
2870             if (scrollableArea &amp;&amp; scrollableArea-&gt;scrollShouldClearLatchedState()) {
2871                 // Web developer is controlling scrolling, so don&#39;t attempt to latch.
2872                 clearLatchedState();
2873                 scrollableArea-&gt;setScrollShouldClearLatchedState(false);
2874             }
2875 
2876             platformNotifyIfEndGesture(adjustedEvent, scrollableArea);
2877             return true;
2878         }
2879     }
2880 
2881     if (scrollableArea)
2882         scrollableArea-&gt;setScrollShouldClearLatchedState(false);
2883 
2884     bool handledEvent = platformCompleteWheelEvent(adjustedEvent, scrollableContainer.get(), scrollableArea);
2885     platformNotifyIfEndGesture(adjustedEvent, scrollableArea);
2886     return handledEvent;
2887 }
2888 
2889 void EventHandler::clearLatchedState()
2890 {
2891     auto* page = m_frame.page();
2892     if (!page)
2893         return;
2894 
2895 #if PLATFORM(MAC)
2896     page-&gt;resetLatchingState();
2897 #endif
2898     if (auto filter = page-&gt;wheelEventDeltaFilter())
2899         filter-&gt;endFilteringDeltas();
2900 }
2901 
2902 void EventHandler::defaultWheelEventHandler(Node* startNode, WheelEvent&amp; wheelEvent)
2903 {
2904     if (!startNode)
2905         return;
2906 
2907     auto protectedFrame = makeRef(m_frame);
2908 
2909     FloatSize filteredPlatformDelta(wheelEvent.deltaX(), wheelEvent.deltaY());
2910     FloatSize filteredVelocity;
2911     if (auto platformWheelEvent = wheelEvent.underlyingPlatformEvent()) {
2912         filteredPlatformDelta.setWidth(platformWheelEvent-&gt;deltaX());
2913         filteredPlatformDelta.setHeight(platformWheelEvent-&gt;deltaY());
2914     }
2915 
2916 #if PLATFORM(MAC)
2917     ScrollLatchingState* latchedState = m_frame.page() ? m_frame.page()-&gt;latchingState() : nullptr;
<a name="33" id="anc33"></a><span class="line-modified">2918     RefPtr&lt;Element&gt; stopElement = latchedState ? latchedState-&gt;previousWheelScrolledElement() : nullptr;</span>
2919 
2920     if (m_frame.page() &amp;&amp; m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;isFilteringDeltas()) {
2921         filteredPlatformDelta = m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;filteredDelta();
2922         filteredVelocity = m_frame.page()-&gt;wheelEventDeltaFilter()-&gt;filteredVelocity();
2923     }
2924 #else
<a name="34" id="anc34"></a><span class="line-modified">2925     RefPtr&lt;Element&gt; stopElement;</span>
2926 #endif
2927 
<a name="35" id="anc35"></a><span class="line-modified">2928     if (handleWheelEventInAppropriateEnclosingBox(startNode, wheelEvent, stopElement, filteredPlatformDelta, filteredVelocity))</span>
2929         wheelEvent.setDefaultHandled();
2930 
2931 #if PLATFORM(MAC)
2932     if (latchedState &amp;&amp; !latchedState-&gt;wheelEventElement())
<a name="36" id="anc36"></a><span class="line-modified">2933         latchedState-&gt;setPreviousWheelScrolledElement(WTFMove(stopElement));</span>
2934 #endif
2935 }
2936 
<a name="37" id="anc37"></a><span class="line-modified">2937 #if ENABLE(CONTEXT_MENU_EVENT)</span>
2938 bool EventHandler::sendContextMenuEvent(const PlatformMouseEvent&amp; event)
2939 {
2940     Ref&lt;Frame&gt; protectedFrame(m_frame);
2941 
2942     Document* doc = m_frame.document();
2943     FrameView* view = m_frame.view();
2944     if (!view)
2945         return false;
2946 
2947     // Caret blinking is normally un-suspended in handleMouseReleaseEvent, but we
2948     // won&#39;t receive that event once the context menu is up.
2949     m_frame.selection().setCaretBlinkingSuspended(false);
2950     // Clear mouse press state to avoid initiating a drag while context menu is up.
2951     m_mousePressed = false;
2952     bool swallowEvent;
2953     LayoutPoint viewportPos = view-&gt;windowToContents(event.position());
2954     HitTestRequest request(HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent);
2955     MouseEventWithHitTestResults mouseEvent = doc-&gt;prepareMouseEvent(request, viewportPos, event);
2956 
2957     // Do not show context menus when clicking on scrollbars.
2958     if (mouseEvent.scrollbar() || view-&gt;scrollbarAtPoint(event.position()))
2959         return false;
2960 
2961     if (m_frame.editor().behavior().shouldSelectOnContextualMenuClick()
2962         &amp;&amp; !m_frame.selection().contains(viewportPos)
2963         // FIXME: In the editable case, word selection sometimes selects content that isn&#39;t underneath the mouse.
2964         // If the selection is non-editable, we do word selection to make it easier to use the contextual menu items
2965         // available for text selections.  But only if we&#39;re above text.
2966         &amp;&amp; (m_frame.selection().selection().isContentEditable() || (mouseEvent.targetNode() &amp;&amp; mouseEvent.targetNode()-&gt;isTextNode()))) {
2967         m_mouseDownMayStartSelect = true; // context menu events are always allowed to perform a selection
2968         selectClosestContextualWordOrLinkFromMouseEvent(mouseEvent);
2969     }
2970 
2971     swallowEvent = !dispatchMouseEvent(eventNames().contextmenuEvent, mouseEvent.targetNode(), true, 0, event, false);
2972 
2973     return swallowEvent;
2974 }
2975 
2976 bool EventHandler::sendContextMenuEventForKey()
2977 {
2978     Ref&lt;Frame&gt; protectedFrame(m_frame);
2979 
2980     FrameView* view = m_frame.view();
2981     if (!view)
2982         return false;
2983 
2984     Document* doc = m_frame.document();
2985     if (!doc)
2986         return false;
2987 
2988     // Clear mouse press state to avoid initiating a drag while context menu is up.
2989     m_mousePressed = false;
2990 
2991     static const int kContextMenuMargin = 1;
2992 
2993 #if OS(WINDOWS) &amp;&amp; !PLATFORM(JAVA)
2994     int rightAligned = ::GetSystemMetrics(SM_MENUDROPALIGNMENT);
2995 #else
2996     int rightAligned = 0;
2997 #endif
2998     IntPoint location;
2999 
3000     Element* focusedElement = doc-&gt;focusedElement();
3001     const VisibleSelection&amp; selection = m_frame.selection().selection();
3002     Position start = selection.start();
3003 
3004     if (start.deprecatedNode() &amp;&amp; (selection.rootEditableElement() || selection.isRange())) {
3005         RefPtr&lt;Range&gt; selectionRange = selection.toNormalizedRange();
3006         IntRect firstRect = m_frame.editor().firstRectForRange(selectionRange.get());
3007 
3008         int x = rightAligned ? firstRect.maxX() : firstRect.x();
3009         // In a multiline edit, firstRect.maxY() would endup on the next line, so -1.
3010         int y = firstRect.maxY() ? firstRect.maxY() - 1 : 0;
3011         location = IntPoint(x, y);
3012     } else if (focusedElement) {
3013         RenderBoxModelObject* box = focusedElement-&gt;renderBoxModelObject();
3014         if (!box)
3015             return false;
3016 
3017         IntRect boundingBoxRect = box-&gt;absoluteBoundingBoxRect(true);
3018         location = IntPoint(boundingBoxRect.x(), boundingBoxRect.maxY() - 1);
3019     } else {
3020         location = IntPoint(
3021             rightAligned ? view-&gt;contentsWidth() - kContextMenuMargin : kContextMenuMargin,
3022             kContextMenuMargin);
3023     }
3024 
3025     m_frame.view()-&gt;setCursor(pointerCursor());
3026 
3027     IntPoint position = view-&gt;contentsToRootView(location);
3028     IntPoint globalPosition = view-&gt;hostWindow()-&gt;rootViewToScreen(IntRect(position, IntSize())).location();
3029 
3030     Node* targetNode = doc-&gt;focusedElement();
3031     if (!targetNode)
3032         targetNode = doc;
3033 
3034     // Use the focused node as the target for hover and active.
3035     HitTestResult result(position);
3036     result.setInnerNode(targetNode);
3037     doc-&gt;updateHoverActiveState(HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent, result.targetElement());
3038 
3039     // The contextmenu event is a mouse event even when invoked using the keyboard.
3040     // This is required for web compatibility.
3041 
3042 #if OS(WINDOWS)
3043     PlatformEvent::Type eventType = PlatformEvent::MouseReleased;
3044 #else
3045     PlatformEvent::Type eventType = PlatformEvent::MousePressed;
3046 #endif
3047 
3048     PlatformMouseEvent platformMouseEvent(position, globalPosition, RightButton, eventType, 1, false, false, false, false, WallTime::now(), ForceAtClick, NoTap);
3049 
3050     return sendContextMenuEvent(platformMouseEvent);
3051 }
<a name="38" id="anc38"></a><span class="line-modified">3052 #endif // ENABLE(CONTEXT_MENU_EVENT)</span>
3053 
3054 void EventHandler::scheduleHoverStateUpdate()
3055 {
3056     if (!m_hoverTimer.isActive())
3057         m_hoverTimer.startOneShot(0_s);
3058 }
3059 
<a name="39" id="anc39"></a>
3060 void EventHandler::scheduleCursorUpdate()
3061 {
<a name="40" id="anc40"></a><span class="line-added">3062     if (Page* page = m_frame.page()) {</span>
<span class="line-added">3063         if (!page-&gt;chrome().client().supportsSettingCursor())</span>
<span class="line-added">3064             return;</span>
<span class="line-added">3065     }</span>
<span class="line-added">3066 </span>
3067     if (!m_cursorUpdateTimer.isActive())
3068         m_cursorUpdateTimer.startOneShot(cursorUpdateInterval);
3069 }
<a name="41" id="anc41"></a>
3070 
3071 void EventHandler::dispatchFakeMouseMoveEventSoon()
3072 {
3073 #if !ENABLE(IOS_TOUCH_EVENTS)
3074     if (m_mousePressed)
3075         return;
3076 
3077     if (m_mousePositionIsUnknown)
3078         return;
3079 
3080     if (Page* page = m_frame.page()) {
3081         if (!page-&gt;chrome().client().shouldDispatchFakeMouseMoveEvents())
3082             return;
3083     }
3084 
3085     // If the content has ever taken longer than fakeMouseMoveShortInterval we
3086     // reschedule the timer and use a longer time. This will cause the content
3087     // to receive these moves only after the user is done scrolling, reducing
3088     // pauses during the scroll.
3089     if (m_fakeMouseMoveEventTimer.isActive())
3090         m_fakeMouseMoveEventTimer.stop();
3091     m_fakeMouseMoveEventTimer.startOneShot(m_maxMouseMovedDuration &gt; fakeMouseMoveDurationThreshold ? fakeMouseMoveLongInterval : fakeMouseMoveShortInterval);
3092 #endif
3093 }
3094 
3095 void EventHandler::dispatchFakeMouseMoveEventSoonInQuad(const FloatQuad&amp; quad)
3096 {
3097 #if ENABLE(IOS_TOUCH_EVENTS)
3098     UNUSED_PARAM(quad);
3099 #else
3100     FrameView* view = m_frame.view();
3101     if (!view)
3102         return;
3103 
3104     if (!quad.containsPoint(view-&gt;windowToContents(m_lastKnownMousePosition)))
3105         return;
3106 
3107     dispatchFakeMouseMoveEventSoon();
3108 #endif
3109 }
3110 
3111 #if !ENABLE(IOS_TOUCH_EVENTS)
3112 void EventHandler::cancelFakeMouseMoveEvent()
3113 {
3114     m_fakeMouseMoveEventTimer.stop();
3115 }
3116 
3117 void EventHandler::fakeMouseMoveEventTimerFired()
3118 {
3119     ASSERT(!m_mousePressed);
3120 
3121     FrameView* view = m_frame.view();
3122     if (!view)
3123         return;
3124 
3125     if (!m_frame.page() || !m_frame.page()-&gt;isVisible() || !m_frame.page()-&gt;focusController().isActive())
3126         return;
3127 
3128     bool shiftKey;
3129     bool ctrlKey;
3130     bool altKey;
3131     bool metaKey;
3132     PlatformKeyboardEvent::getCurrentModifierState(shiftKey, ctrlKey, altKey, metaKey);
3133     PlatformMouseEvent fakeMouseMoveEvent(m_lastKnownMousePosition, m_lastKnownMouseGlobalPosition, NoButton, PlatformEvent::MouseMoved, 0, shiftKey, ctrlKey, altKey, metaKey, WallTime::now(), 0, NoTap);
3134     mouseMoved(fakeMouseMoveEvent);
3135 }
3136 #endif // !ENABLE(IOS_TOUCH_EVENTS)
3137 
3138 void EventHandler::setResizingFrameSet(HTMLFrameSetElement* frameSet)
3139 {
3140     m_frameSetBeingResized = frameSet;
3141 }
3142 
3143 void EventHandler::resizeLayerDestroyed()
3144 {
3145     ASSERT(m_resizeLayer);
3146     m_resizeLayer = nullptr;
3147 }
3148 
3149 void EventHandler::hoverTimerFired()
3150 {
3151     m_hoverTimer.stop();
3152 
3153     ASSERT(m_frame.document());
3154 
3155     Ref&lt;Frame&gt; protectedFrame(m_frame);
3156 
3157     if (auto* document = m_frame.document()) {
3158         if (FrameView* view = m_frame.view()) {
3159             HitTestRequest request(HitTestRequest::Move | HitTestRequest::DisallowUserAgentShadowContent);
3160             HitTestResult result(view-&gt;windowToContents(m_lastKnownMousePosition));
3161             document-&gt;hitTest(request, result);
3162             document-&gt;updateHoverActiveState(request, result.targetElement());
3163         }
3164     }
3165 }
3166 
3167 bool EventHandler::handleAccessKey(const PlatformKeyboardEvent&amp; event)
3168 {
3169     // FIXME: Ignoring the state of Shift key is what neither IE nor Firefox do.
3170     // IE matches lower and upper case access keys regardless of Shift key state - but if both upper and
3171     // lower case variants are present in a document, the correct element is matched based on Shift key state.
3172     // Firefox only matches an access key if Shift is not pressed, and does that case-insensitively.
3173     ASSERT(!accessKeyModifiers().contains(PlatformEvent::Modifier::ShiftKey));
3174 
3175     if ((event.modifiers() - PlatformEvent::Modifier::ShiftKey) != accessKeyModifiers())
3176         return false;
3177     auto* element = m_frame.document()-&gt;elementForAccessKey(event.unmodifiedText());
3178     if (!element)
3179         return false;
3180     element-&gt;accessKeyAction(false);
3181     return true;
3182 }
3183 
3184 #if !PLATFORM(MAC)
3185 bool EventHandler::needsKeyboardEventDisambiguationQuirks() const
3186 {
3187     return false;
3188 }
3189 #endif
3190 
3191 #if ENABLE(FULLSCREEN_API)
3192 bool EventHandler::isKeyEventAllowedInFullScreen(const PlatformKeyboardEvent&amp; keyEvent) const
3193 {
3194     Document* document = m_frame.document();
3195     if (document-&gt;fullscreenManager().isFullscreenKeyboardInputAllowed())
3196         return true;
3197 
3198     if (keyEvent.type() == PlatformKeyboardEvent::Char) {
3199         if (keyEvent.text().length() != 1)
3200             return false;
3201         UChar character = keyEvent.text()[0];
3202         return character == &#39; &#39;;
3203     }
3204 
3205     int keyCode = keyEvent.windowsVirtualKeyCode();
3206     return (keyCode &gt;= VK_BACK &amp;&amp; keyCode &lt;= VK_CAPITAL)
3207         || (keyCode &gt;= VK_SPACE &amp;&amp; keyCode &lt;= VK_DELETE)
3208         || (keyCode &gt;= VK_OEM_1 &amp;&amp; keyCode &lt;= VK_OEM_PLUS)
3209         || (keyCode &gt;= VK_MULTIPLY &amp;&amp; keyCode &lt;= VK_OEM_8);
3210 }
3211 #endif
3212 
3213 bool EventHandler::keyEvent(const PlatformKeyboardEvent&amp; keyEvent)
3214 {
3215     Document* topDocument = m_frame.document() ? &amp;m_frame.document()-&gt;topDocument() : nullptr;
3216     MonotonicTime savedLastHandledUserGestureTimestamp;
3217     bool savedUserDidInteractWithPage = topDocument ? topDocument-&gt;userDidInteractWithPage() : false;
3218 
3219     if (m_frame.document())
3220         savedLastHandledUserGestureTimestamp = m_frame.document()-&gt;lastHandledUserGestureTimestamp();
3221 
3222     bool wasHandled = internalKeyEvent(keyEvent);
3223 
3224     // If the key event was not handled, do not treat it as user interaction with the page.
3225     if (topDocument) {
3226         if (!wasHandled)
3227             topDocument-&gt;setUserDidInteractWithPage(savedUserDidInteractWithPage);
3228         else
3229             ResourceLoadObserver::shared().logUserInteractionWithReducedTimeResolution(*topDocument);
3230     }
3231 
3232     if (!wasHandled &amp;&amp; m_frame.document())
3233         m_frame.document()-&gt;updateLastHandledUserGestureTimestamp(savedLastHandledUserGestureTimestamp);
3234 
3235     return wasHandled;
3236 }
3237 
3238 void EventHandler::capsLockStateMayHaveChanged() const
3239 {
3240     auto* focusedElement = m_frame.document()-&gt;focusedElement();
3241     if (!is&lt;HTMLInputElement&gt;(focusedElement))
3242         return;
3243     downcast&lt;HTMLInputElement&gt;(*focusedElement).capsLockStateMayHaveChanged();
3244 }
3245 
3246 bool EventHandler::internalKeyEvent(const PlatformKeyboardEvent&amp; initialKeyEvent)
3247 {
3248     Ref&lt;Frame&gt; protectedFrame(m_frame);
3249     RefPtr&lt;FrameView&gt; protector(m_frame.view());
3250 
3251     LOG(Editing, &quot;EventHandler %p keyEvent (text %s keyIdentifier %s)&quot;, this, initialKeyEvent.text().utf8().data(), initialKeyEvent.keyIdentifier().utf8().data());
3252 
3253 #if ENABLE(POINTER_LOCK)
3254     if (initialKeyEvent.type() == PlatformEvent::KeyDown &amp;&amp; initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE &amp;&amp; m_frame.page()-&gt;pointerLockController().element()) {
3255         m_frame.page()-&gt;pointerLockController().requestPointerUnlockAndForceCursorVisible();
3256     }
3257 #endif
3258 
3259     if (initialKeyEvent.type() == PlatformEvent::KeyDown &amp;&amp; initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE) {
3260         if (auto* page = m_frame.page()) {
3261             if (auto* validationMessageClient = page-&gt;validationMessageClient())
3262                 validationMessageClient-&gt;hideAnyValidationMessage();
3263         }
3264     }
3265 
3266 #if ENABLE(FULLSCREEN_API)
3267     if (m_frame.document()-&gt;fullscreenManager().isFullscreen()) {
3268         if (initialKeyEvent.type() == PlatformEvent::KeyDown &amp;&amp; initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE) {
3269             m_frame.document()-&gt;fullscreenManager().cancelFullscreen();
3270             return true;
3271         }
3272 
3273         if (!isKeyEventAllowedInFullScreen(initialKeyEvent))
3274             return false;
3275     }
3276 #endif
3277 
3278     if (initialKeyEvent.windowsVirtualKeyCode() == VK_CAPITAL)
3279         capsLockStateMayHaveChanged();
3280 
3281 #if ENABLE(PAN_SCROLLING)
3282     if (m_frame.mainFrame().eventHandler().panScrollInProgress()) {
3283         // If a key is pressed while the panScroll is in progress then we want to stop
3284         if (initialKeyEvent.type() == PlatformEvent::KeyDown || initialKeyEvent.type() == PlatformEvent::RawKeyDown)
3285             stopAutoscrollTimer();
3286 
3287         // If we were in panscroll mode, we swallow the key event
3288         return true;
3289     }
3290 #endif
3291 
3292     // Check for cases where we are too early for events -- possible unmatched key up
3293     // from pressing return in the location bar.
3294     RefPtr&lt;Element&gt; element = eventTargetElementForDocument(m_frame.document());
3295     if (!element)
3296         return false;
3297 
3298     UserGestureType gestureType = UserGestureType::Other;
3299     if (initialKeyEvent.windowsVirtualKeyCode() == VK_ESCAPE)
3300         gestureType = UserGestureType::EscapeKey;
3301 
3302     UserGestureIndicator gestureIndicator(ProcessingUserGesture, m_frame.document(), gestureType, UserGestureIndicator::ProcessInteractionStyle::Delayed);
3303     UserTypingGestureIndicator typingGestureIndicator(m_frame);
3304 
3305     if (FrameView* view = m_frame.view())
3306         view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
3307 
3308     // FIXME (bug 68185): this call should be made at another abstraction layer
3309     m_frame.loader().resetMultipleFormSubmissionProtection();
3310 
3311     // In IE, access keys are special, they are handled after default keydown processing, but cannot be canceled - this is hard to match.
3312     // On Mac OS X, we process them before dispatching keydown, as the default keydown handler implements Emacs key bindings, which may conflict
3313     // with access keys. Then we dispatch keydown, but suppress its default handling.
3314     // On Windows, WebKit explicitly calls handleAccessKey() instead of dispatching a keypress event for WM_SYSCHAR messages.
3315     // Other platforms currently match either Mac or Windows behavior, depending on whether they send combined KeyDown events.
3316     bool matchedAnAccessKey = false;
3317     if (initialKeyEvent.type() == PlatformEvent::KeyDown)
3318         matchedAnAccessKey = handleAccessKey(initialKeyEvent);
3319 
3320     // FIXME: it would be fair to let an input method handle KeyUp events before DOM dispatch.
3321     if (initialKeyEvent.type() == PlatformEvent::KeyUp || initialKeyEvent.type() == PlatformEvent::Char)
3322         return !element-&gt;dispatchKeyEvent(initialKeyEvent);
3323 
3324     bool backwardCompatibilityMode = needsKeyboardEventDisambiguationQuirks();
3325 
3326     PlatformKeyboardEvent keyDownEvent = initialKeyEvent;
3327     if (keyDownEvent.type() != PlatformEvent::RawKeyDown)
3328         keyDownEvent.disambiguateKeyDownEvent(PlatformEvent::RawKeyDown, backwardCompatibilityMode);
3329     auto keydown = KeyboardEvent::create(keyDownEvent, &amp;m_frame.windowProxy());
3330     if (matchedAnAccessKey)
3331         keydown-&gt;preventDefault();
3332     keydown-&gt;setTarget(element);
3333 
3334     if (initialKeyEvent.type() == PlatformEvent::RawKeyDown) {
3335         element-&gt;dispatchEvent(keydown);
3336         // If frame changed as a result of keydown dispatch, then return true to avoid sending a subsequent keypress message to the new frame.
3337         bool changedFocusedFrame = m_frame.page() &amp;&amp; &amp;m_frame != &amp;m_frame.page()-&gt;focusController().focusedOrMainFrame();
3338         return keydown-&gt;defaultHandled() || keydown-&gt;defaultPrevented() || changedFocusedFrame;
3339     }
3340 
3341     // Run input method in advance of DOM event handling.  This may result in the IM
3342     // modifying the page prior the keydown event, but this behaviour is necessary
3343     // in order to match IE:
3344     // 1. preventing default handling of keydown and keypress events has no effect on IM input;
3345     // 2. if an input method handles the event, its keyCode is set to 229 in keydown event.
3346     m_frame.editor().handleInputMethodKeydown(keydown.get());
3347 
3348     bool handledByInputMethod = keydown-&gt;defaultHandled();
3349 
3350     if (handledByInputMethod) {
3351         keyDownEvent.setWindowsVirtualKeyCode(CompositionEventKeyCode);
3352         keydown = KeyboardEvent::create(keyDownEvent, &amp;m_frame.windowProxy());
3353         keydown-&gt;setTarget(element);
3354         keydown-&gt;setIsDefaultEventHandlerIgnored();
3355     }
3356 
3357     if (accessibilityPreventsEventPropagation(keydown))
3358         keydown-&gt;stopPropagation();
3359 
3360 #if PLATFORM(IOS_FAMILY)
3361     DeferDOMTimersForScope deferralScope { m_frame.document()-&gt;quirks().needsDeferKeyDownAndKeyPressTimersUntilNextEditingCommand() };
3362 #endif
3363 
3364     element-&gt;dispatchEvent(keydown);
<a name="42" id="anc42"></a><span class="line-modified">3365     if (handledByInputMethod) {</span>
<span class="line-added">3366         m_frame.editor().didDispatchInputMethodKeydown(keydown.get());</span>
3367         return true;
<a name="43" id="anc43"></a><span class="line-added">3368     }</span>
3369 
3370     // If frame changed as a result of keydown dispatch, then return early to avoid sending a subsequent keypress message to the new frame.
3371     bool changedFocusedFrame = m_frame.page() &amp;&amp; &amp;m_frame != &amp;m_frame.page()-&gt;focusController().focusedOrMainFrame();
3372     bool keydownResult = keydown-&gt;defaultHandled() || keydown-&gt;defaultPrevented() || changedFocusedFrame;
3373     if (keydownResult &amp;&amp; !backwardCompatibilityMode)
3374         return keydownResult;
3375 
3376     // Focus may have changed during keydown handling, so refetch element.
3377     // But if we are dispatching a fake backward compatibility keypress, then we pretend that the keypress happened on the original element.
3378     if (!keydownResult) {
3379         element = eventTargetElementForDocument(m_frame.document());
3380         if (!element)
3381             return false;
3382     }
3383 
3384     PlatformKeyboardEvent keyPressEvent = initialKeyEvent;
3385     keyPressEvent.disambiguateKeyDownEvent(PlatformEvent::Char, backwardCompatibilityMode);
3386     if (keyPressEvent.text().isEmpty())
3387         return keydownResult;
3388     auto keypress = KeyboardEvent::create(keyPressEvent, &amp;m_frame.windowProxy());
3389     keypress-&gt;setTarget(element);
3390     if (keydownResult)
3391         keypress-&gt;preventDefault();
3392 #if PLATFORM(COCOA)
3393     keypress-&gt;keypressCommands() = keydown-&gt;keypressCommands();
3394 #endif
3395     element-&gt;dispatchEvent(keypress);
3396 
3397     return keydownResult || keypress-&gt;defaultPrevented() || keypress-&gt;defaultHandled();
3398 }
3399 
3400 static FocusDirection focusDirectionForKey(const AtomString&amp; keyIdentifier)
3401 {
3402     static NeverDestroyed&lt;AtomString&gt; Down(&quot;Down&quot;, AtomString::ConstructFromLiteral);
3403     static NeverDestroyed&lt;AtomString&gt; Up(&quot;Up&quot;, AtomString::ConstructFromLiteral);
3404     static NeverDestroyed&lt;AtomString&gt; Left(&quot;Left&quot;, AtomString::ConstructFromLiteral);
3405     static NeverDestroyed&lt;AtomString&gt; Right(&quot;Right&quot;, AtomString::ConstructFromLiteral);
3406 
3407     FocusDirection retVal = FocusDirectionNone;
3408 
3409     if (keyIdentifier == Down)
3410         retVal = FocusDirectionDown;
3411     else if (keyIdentifier == Up)
3412         retVal = FocusDirectionUp;
3413     else if (keyIdentifier == Left)
3414         retVal = FocusDirectionLeft;
3415     else if (keyIdentifier == Right)
3416         retVal = FocusDirectionRight;
3417 
3418     return retVal;
3419 }
3420 
3421 static void setInitialKeyboardSelection(Frame&amp; frame, SelectionDirection direction)
3422 {
3423     Document* document = frame.document();
3424     if (!document)
3425         return;
3426 
3427     FrameSelection&amp; selection = frame.selection();
3428 
3429     if (!selection.isNone())
3430         return;
3431 
3432     Element* focusedElement = document-&gt;focusedElement();
3433     VisiblePosition visiblePosition;
3434 
3435     switch (direction) {
3436     case DirectionBackward:
3437     case DirectionLeft:
3438         if (focusedElement)
3439             visiblePosition = VisiblePosition(positionBeforeNode(focusedElement));
3440         else
3441             visiblePosition = endOfDocument(document);
3442         break;
3443     case DirectionForward:
3444     case DirectionRight:
3445         if (focusedElement)
3446             visiblePosition = VisiblePosition(positionAfterNode(focusedElement));
3447         else
3448             visiblePosition = startOfDocument(document);
3449         break;
3450     }
3451 
3452     AXTextStateChangeIntent intent(AXTextStateChangeTypeSelectionMove, AXTextSelection { AXTextSelectionDirectionDiscontiguous, AXTextSelectionGranularityUnknown, false });
3453     selection.setSelection(visiblePosition, FrameSelection::defaultSetSelectionOptions(UserTriggered), intent);
3454 }
3455 
3456 static void handleKeyboardSelectionMovement(Frame&amp; frame, KeyboardEvent&amp; event)
3457 {
3458     FrameSelection&amp; selection = frame.selection();
3459 
3460     bool isCommanded = event.getModifierState(&quot;Meta&quot;);
3461     bool isOptioned = event.getModifierState(&quot;Alt&quot;);
3462     bool isSelection = !selection.isNone();
3463 
3464     FrameSelection::EAlteration alternation = event.getModifierState(&quot;Shift&quot;) ? FrameSelection::AlterationExtend : FrameSelection::AlterationMove;
3465     SelectionDirection direction = DirectionForward;
3466     TextGranularity granularity = CharacterGranularity;
3467 
3468     switch (focusDirectionForKey(event.keyIdentifier())) {
3469     case FocusDirectionNone:
3470         return;
3471     case FocusDirectionForward:
3472     case FocusDirectionBackward:
3473         ASSERT_NOT_REACHED();
3474         return;
3475     case FocusDirectionUp:
3476         direction = DirectionBackward;
3477         granularity = isCommanded ? DocumentBoundary : LineGranularity;
3478         break;
3479     case FocusDirectionDown:
3480         direction = DirectionForward;
3481         granularity = isCommanded ? DocumentBoundary : LineGranularity;
3482         break;
3483     case FocusDirectionLeft:
3484         direction = DirectionLeft;
3485         granularity = (isCommanded) ? LineBoundary : (isOptioned) ? WordGranularity : CharacterGranularity;
3486         break;
3487     case FocusDirectionRight:
3488         direction = DirectionRight;
3489         granularity = (isCommanded) ? LineBoundary : (isOptioned) ? WordGranularity : CharacterGranularity;
3490         break;
3491     }
3492 
3493     if (isSelection)
3494         selection.modify(alternation, direction, granularity, UserTriggered);
3495     else
3496         setInitialKeyboardSelection(frame, direction);
3497 
3498     event.setDefaultHandled();
3499 }
3500 
3501 void EventHandler::handleKeyboardSelectionMovementForAccessibility(KeyboardEvent&amp; event)
3502 {
3503     if (event.type() == eventNames().keydownEvent) {
3504         if (AXObjectCache::accessibilityEnhancedUserInterfaceEnabled())
3505             handleKeyboardSelectionMovement(m_frame, event);
3506     }
3507 }
3508 
3509 bool EventHandler::accessibilityPreventsEventPropagation(KeyboardEvent&amp; event)
3510 {
3511 #if PLATFORM(COCOA)
3512     if (!AXObjectCache::accessibilityEnhancedUserInterfaceEnabled())
3513         return false;
3514 
3515     if (!m_frame.settings().preventKeyboardDOMEventDispatch())
3516         return false;
3517 
3518     // Check for key events that are relevant to accessibility: tab and arrows keys that change focus
3519     if (event.keyIdentifier() == &quot;U+0009&quot;)
3520         return true;
3521     FocusDirection direction = focusDirectionForKey(event.keyIdentifier());
3522     if (direction != FocusDirectionNone)
3523         return true;
3524 #else
3525     UNUSED_PARAM(event);
3526 #endif
3527     return false;
3528 }
3529 
3530 void EventHandler::defaultKeyboardEventHandler(KeyboardEvent&amp; event)
3531 {
3532     Ref&lt;Frame&gt; protectedFrame(m_frame);
3533 
3534     if (event.type() == eventNames().keydownEvent) {
3535         m_frame.editor().handleKeyboardEvent(event);
3536         if (event.defaultHandled())
3537             return;
3538         if (event.keyIdentifier() == &quot;U+0009&quot;)
3539             defaultTabEventHandler(event);
3540         else if (event.keyIdentifier() == &quot;U+0008&quot;)
3541             defaultBackspaceEventHandler(event);
3542         else {
3543             FocusDirection direction = focusDirectionForKey(event.keyIdentifier());
3544             if (direction != FocusDirectionNone)
3545                 defaultArrowEventHandler(direction, event);
3546         }
3547 
3548         handleKeyboardSelectionMovementForAccessibility(event);
3549     }
3550     if (event.type() == eventNames().keypressEvent) {
3551         m_frame.editor().handleKeyboardEvent(event);
3552         if (event.defaultHandled())
3553             return;
3554         if (event.charCode() == &#39; &#39;)
3555             defaultSpaceEventHandler(event);
3556     }
3557 }
3558 
3559 #if ENABLE(DRAG_SUPPORT)
3560 bool EventHandler::dragHysteresisExceeded(const IntPoint&amp; floatDragViewportLocation) const
3561 {
3562     FloatPoint dragViewportLocation(floatDragViewportLocation.x(), floatDragViewportLocation.y());
3563     return dragHysteresisExceeded(dragViewportLocation);
3564 }
3565 
3566 bool EventHandler::dragHysteresisExceeded(const FloatPoint&amp; dragViewportLocation) const
3567 {
3568     int threshold = GeneralDragHysteresis;
3569     switch (dragState().type) {
3570     case DragSourceActionSelection:
3571         threshold = TextDragHysteresis;
3572         break;
3573     case DragSourceActionImage:
3574 #if ENABLE(ATTACHMENT_ELEMENT)
3575     case DragSourceActionAttachment:
3576 #endif
3577         threshold = ImageDragHysteresis;
3578         break;
3579     case DragSourceActionLink:
3580         threshold = LinkDragHysteresis;
3581         break;
3582 #if ENABLE(INPUT_TYPE_COLOR)
3583     case DragSourceActionColor:
3584         threshold = ColorDragHystersis;
3585         break;
3586 #endif
3587     case DragSourceActionDHTML:
3588         break;
3589     case DragSourceActionNone:
3590     case DragSourceActionAny:
3591         ASSERT_NOT_REACHED();
3592     }
3593 
3594     return mouseMovementExceedsThreshold(dragViewportLocation, threshold);
3595 }
3596 
3597 void EventHandler::invalidateDataTransfer()
3598 {
3599     if (!dragState().dataTransfer)
3600         return;
3601     dragState().dataTransfer-&gt;makeInvalidForSecurity();
3602     dragState().dataTransfer = nullptr;
3603 }
3604 
3605 static void removeDraggedContentDocumentMarkersFromAllFramesInPage(Page&amp; page)
3606 {
3607     for (Frame* frame = &amp;page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
3608         if (auto* document = frame-&gt;document())
3609             document-&gt;markers().removeMarkers(DocumentMarker::DraggedContent);
3610     }
3611 
3612     if (auto* mainFrameRenderer = page.mainFrame().contentRenderer())
3613         mainFrameRenderer-&gt;repaintRootContents();
3614 }
3615 
3616 void EventHandler::dragCancelled()
3617 {
3618 #if ENABLE(DATA_INTERACTION)
3619     if (auto* page = m_frame.page())
3620         removeDraggedContentDocumentMarkersFromAllFramesInPage(*page);
3621 #endif
3622 }
3623 
3624 void EventHandler::didStartDrag()
3625 {
3626 #if ENABLE(DATA_INTERACTION)
3627     auto dragSource = dragState().source;
3628     if (!dragSource)
3629         return;
3630 
3631     auto* renderer = dragSource-&gt;renderer();
3632     if (!renderer)
3633         return;
3634 
3635     RefPtr&lt;Range&gt; draggedContentRange;
3636     if (dragState().type &amp; DragSourceActionSelection)
3637         draggedContentRange = m_frame.selection().selection().toNormalizedRange();
3638     else {
3639         Position startPosition(dragSource.get(), Position::PositionIsBeforeAnchor);
3640         Position endPosition(dragSource.get(), Position::PositionIsAfterAnchor);
3641         draggedContentRange = Range::create(dragSource-&gt;document(), startPosition, endPosition);
3642     }
3643 
3644     if (draggedContentRange) {
3645         draggedContentRange-&gt;ownerDocument().markers().addDraggedContentMarker(*draggedContentRange);
3646         if (auto* renderer = m_frame.contentRenderer())
3647             renderer-&gt;repaintRootContents();
3648     }
3649 #endif
3650 }
3651 
3652 void EventHandler::dragSourceEndedAt(const PlatformMouseEvent&amp; event, DragOperation operation, MayExtendDragSession mayExtendDragSession)
3653 {
3654     // Send a hit test request so that RenderLayer gets a chance to update the :hover and :active pseudoclasses.
3655     HitTestRequest request(HitTestRequest::Release | HitTestRequest::DisallowUserAgentShadowContent);
3656     prepareMouseEvent(request, event);
3657 
<a name="44" id="anc44"></a><span class="line-modified">3658     if (shouldDispatchEventsToDragSourceElement()) {</span>
3659         dragState().dataTransfer-&gt;setDestinationOperation(operation);
<a name="45" id="anc45"></a><span class="line-modified">3660         dispatchEventToDragSourceElement(eventNames().dragendEvent, event);</span>
3661     }
3662     invalidateDataTransfer();
3663 
3664     if (mayExtendDragSession == MayExtendDragSession::No) {
3665         if (auto* page = m_frame.page())
3666             removeDraggedContentDocumentMarkersFromAllFramesInPage(*page);
3667     }
3668 
3669     dragState().source = nullptr;
3670     // In case the drag was ended due to an escape key press we need to ensure
3671     // that consecutive mousemove events don&#39;t reinitiate the drag and drop.
3672     m_mouseDownMayStartDrag = false;
3673 }
3674 
3675 void EventHandler::updateDragStateAfterEditDragIfNeeded(Element&amp; rootEditableElement)
3676 {
3677     // If inserting the dragged contents removed the drag source, we still want to fire dragend at the root editable element.
3678     if (dragState().source &amp;&amp; !dragState().source-&gt;isConnected())
3679         dragState().source = &amp;rootEditableElement;
3680 }
3681 
<a name="46" id="anc46"></a><span class="line-modified">3682 bool EventHandler::shouldDispatchEventsToDragSourceElement()</span>
<span class="line-added">3683 {</span>
<span class="line-added">3684     return dragState().source &amp;&amp; dragState().dataTransfer &amp;&amp; dragState().shouldDispatchEvents;</span>
<span class="line-added">3685 }</span>
<span class="line-added">3686 </span>
<span class="line-added">3687 void EventHandler::dispatchEventToDragSourceElement(const AtomString&amp; eventType, const PlatformMouseEvent&amp; event)</span>
3688 {
<a name="47" id="anc47"></a><span class="line-modified">3689     if (shouldDispatchEventsToDragSourceElement())</span>
<span class="line-modified">3690         dispatchDragEvent(eventType, *dragState().source, event, *dragState().dataTransfer);</span>
3691 }
3692 
3693 bool EventHandler::dispatchDragStartEventOnSourceElement(DataTransfer&amp; dataTransfer)
3694 {
3695     return !dispatchDragEvent(eventNames().dragstartEvent, *dragState().source, m_mouseDown, dataTransfer) &amp;&amp; !m_frame.selection().selection().isInPasswordField();
3696 }
3697 
3698 static bool ExactlyOneBitSet(DragSourceAction n)
3699 {
3700     return n &amp;&amp; !(n &amp; (n - 1));
3701 }
3702 
3703 RefPtr&lt;Element&gt; EventHandler::draggedElement() const
3704 {
3705     return dragState().source;
3706 }
3707 
3708 bool EventHandler::handleDrag(const MouseEventWithHitTestResults&amp; event, CheckDragHysteresis checkDragHysteresis)
3709 {
3710     if (event.event().button() != LeftButton || event.event().type() != PlatformEvent::MouseMoved) {
3711         // If we allowed the other side of the bridge to handle a drag
3712         // last time, then m_mousePressed might still be set. So we
3713         // clear it now to make sure the next move after a drag
3714         // doesn&#39;t look like a drag.
3715         m_mousePressed = false;
3716         return false;
3717     }
3718 
3719     Ref&lt;Frame&gt; protectedFrame(m_frame);
3720 
3721     if (eventLoopHandleMouseDragged(event))
3722         return true;
3723 
3724     // Careful that the drag starting logic stays in sync with eventMayStartDrag()
3725 
3726     if (m_mouseDownMayStartDrag &amp;&amp; !dragState().source) {
3727         dragState().shouldDispatchEvents = (updateDragSourceActionsAllowed() &amp; DragSourceActionDHTML);
3728 
3729         // try to find an element that wants to be dragged
3730         HitTestRequest request(HitTestRequest::ReadOnly | HitTestRequest::DisallowUserAgentShadowContent);
3731         HitTestResult result(m_mouseDownPos);
3732         m_frame.document()-&gt;hitTest(request, result);
3733         if (m_frame.page())
3734             dragState().source = m_frame.page()-&gt;dragController().draggableElement(&amp;m_frame, result.targetElement(), m_mouseDownPos, dragState());
3735 
3736         if (!dragState().source)
3737             m_mouseDownMayStartDrag = false; // no element is draggable
3738         else
3739             m_dragMayStartSelectionInstead = (dragState().type &amp; DragSourceActionSelection);
3740     }
3741 
3742     // For drags starting in the selection, the user must wait between the mousedown and mousedrag,
3743     // or else we bail on the dragging stuff and allow selection to occur
3744     if (m_mouseDownMayStartDrag &amp;&amp; m_dragMayStartSelectionInstead &amp;&amp; (dragState().type &amp; DragSourceActionSelection) &amp;&amp; event.event().timestamp() - m_mouseDownTimestamp &lt; TextDragDelay) {
3745         ASSERT(event.event().type() == PlatformEvent::MouseMoved);
3746         if ((dragState().type &amp; DragSourceActionImage)) {
3747             // ... unless the mouse is over an image, then we start dragging just the image
3748             dragState().type = DragSourceActionImage;
3749         } else if (!(dragState().type &amp; (DragSourceActionDHTML | DragSourceActionLink))) {
3750             // ... but only bail if we&#39;re not over an unselectable element.
3751             m_mouseDownMayStartDrag = false;
3752             dragState().source = nullptr;
3753             // ... but if this was the first click in the window, we don&#39;t even want to start selection
3754             if (eventActivatedView(event.event()))
3755                 m_mouseDownMayStartSelect = false;
3756         } else {
3757             // Prevent the following case from occuring:
3758             // 1. User starts a drag immediately after mouse down over an unselectable element.
3759             // 2. We enter this block and decided that since we&#39;re over an unselectable element, don&#39;t cancel the drag.
3760             // 3. The drag gets resolved as a potential selection drag below /but/ we haven&#39;t exceeded the drag hysteresis yet.
3761             // 4. We enter this block again, and since it&#39;s now marked as a selection drag, we cancel the drag.
3762             m_dragMayStartSelectionInstead = false;
3763         }
3764     }
3765 
3766     if (!m_mouseDownMayStartDrag)
3767         return !mouseDownMayStartSelect() &amp;&amp; !m_mouseDownMayStartAutoscroll;
3768     ASSERT(dragState().source);
3769 
3770     if (!ExactlyOneBitSet(dragState().type)) {
3771         ASSERT(dragState().type &amp; DragSourceActionSelection);
3772         ASSERT(ExactlyOneBitSet(static_cast&lt;DragSourceAction&gt;(dragState().type &amp; ~DragSourceActionSelection)));
3773 
3774         dragState().type = DragSourceActionSelection;
3775     }
3776 
3777     // We are starting a text/image/url drag, so the cursor should be an arrow
3778     if (FrameView* view = m_frame.view()) {
3779         // FIXME &lt;rdar://7577595&gt;: Custom cursors aren&#39;t supported during drag and drop (default to pointer).
3780         view-&gt;setCursor(pointerCursor());
3781     }
3782 
3783     if (checkDragHysteresis == ShouldCheckDragHysteresis &amp;&amp; !dragHysteresisExceeded(event.event().position()))
3784         return true;
3785 
3786     // Once we&#39;re past the hysteresis point, we don&#39;t want to treat this gesture as a click
3787     invalidateClick();
3788 
3789     DragOperation srcOp = DragOperationNone;
3790 
3791     // This does work only if we missed a dragEnd. Do it anyway, just to make sure the old dataTransfer gets numbed.
<a name="48" id="anc48"></a><span class="line-added">3792     // FIXME: Consider doing this earlier in this function as the earliest point we&#39;re sure it would be safe to drop an old drag.</span>
3793     invalidateDataTransfer();
3794 
<a name="49" id="anc49"></a><span class="line-modified">3795     dragState().dataTransfer = DataTransfer::createForDrag();</span>
3796     HasNonDefaultPasteboardData hasNonDefaultPasteboardData = HasNonDefaultPasteboardData::No;
3797 
3798     if (dragState().shouldDispatchEvents) {
3799         ASSERT(dragState().source);
3800         auto dragStartDataTransfer = DataTransfer::createForDragStartEvent(dragState().source-&gt;document());
3801         m_mouseDownMayStartDrag = dispatchDragStartEventOnSourceElement(dragStartDataTransfer);
3802         hasNonDefaultPasteboardData = dragStartDataTransfer-&gt;pasteboard().hasData() ? HasNonDefaultPasteboardData::Yes : HasNonDefaultPasteboardData::No;
3803         dragState().dataTransfer-&gt;moveDragState(WTFMove(dragStartDataTransfer));
3804 
3805         if (dragState().source &amp;&amp; dragState().type == DragSourceActionDHTML &amp;&amp; !dragState().dataTransfer-&gt;hasDragImage()) {
3806             dragState().source-&gt;document().updateStyleIfNeeded();
3807             if (auto* renderer = dragState().source-&gt;renderer()) {
3808                 auto absolutePosition = renderer-&gt;localToAbsolute();
3809                 auto delta = m_mouseDownPos - roundedIntPoint(absolutePosition);
3810                 dragState().dataTransfer-&gt;setDragImage(dragState().source.get(), delta.width(), delta.height());
3811             } else {
<a name="50" id="anc50"></a><span class="line-modified">3812                 dispatchEventToDragSourceElement(eventNames().dragendEvent, event.event());</span>
3813                 m_mouseDownMayStartDrag = false;
3814                 invalidateDataTransfer();
3815                 dragState().source = nullptr;
3816                 return true;
3817             }
3818         }
3819 
3820         dragState().dataTransfer-&gt;makeInvalidForSecurity();
3821 
3822         if (m_mouseDownMayStartDrag) {
3823             // Gather values from DHTML element, if it set any.
3824             srcOp = dragState().dataTransfer-&gt;sourceOperation();
3825 
3826             // Yuck, a draggedImage:moveTo: message can be fired as a result of kicking off the
3827             // drag with dragImage! Because of that dumb reentrancy, we may think we&#39;ve not
3828             // started the drag when that happens. So we have to assume it&#39;s started before we kick it off.
3829             dragState().dataTransfer-&gt;setDragHasStarted();
3830         }
3831     }
3832 
3833     if (m_mouseDownMayStartDrag) {
3834         Page* page = m_frame.page();
3835         m_didStartDrag = page &amp;&amp; page-&gt;dragController().startDrag(m_frame, dragState(), srcOp, event.event(), m_mouseDownPos, hasNonDefaultPasteboardData);
3836         // In WebKit2 we could re-enter this code and start another drag.
3837         // On OS X this causes problems with the ownership of the pasteboard and the promised types.
3838         if (m_didStartDrag) {
3839             m_mouseDownMayStartDrag = false;
3840             return true;
3841         }
<a name="51" id="anc51"></a><span class="line-modified">3842         if (shouldDispatchEventsToDragSourceElement()) {</span>
3843             // Drag was canned at the last minute. We owe dragSource a dragend event.
<a name="52" id="anc52"></a><span class="line-modified">3844             dispatchEventToDragSourceElement(eventNames().dragendEvent, event.event());</span>
3845             m_mouseDownMayStartDrag = false;
3846         }
3847     }
3848 
3849     if (!m_mouseDownMayStartDrag) {
3850         // Something failed to start the drag, clean up.
3851         invalidateDataTransfer();
3852         dragState().source = nullptr;
3853     }
3854 
3855     // No more default handling (like selection), whether we&#39;re past the hysteresis bounds or not
3856     return true;
3857 }
3858 #endif // ENABLE(DRAG_SUPPORT)
3859 
3860 bool EventHandler::mouseMovementExceedsThreshold(const FloatPoint&amp; viewportLocation, int pointsThreshold) const
3861 {
3862     FrameView* view = m_frame.view();
3863     if (!view)
3864         return false;
3865     IntPoint location = view-&gt;windowToContents(flooredIntPoint(viewportLocation));
3866     IntSize delta = location - m_mouseDownPos;
3867 
3868     return abs(delta.width()) &gt;= pointsThreshold || abs(delta.height()) &gt;= pointsThreshold;
3869 }
3870 
3871 bool EventHandler::handleTextInputEvent(const String&amp; text, Event* underlyingEvent, TextEventInputType inputType)
3872 {
3873     LOG(Editing, &quot;EventHandler %p handleTextInputEvent (text %s)&quot;, this, text.utf8().data());
3874 
3875     // Platforms should differentiate real commands like selectAll from text input in disguise (like insertNewline),
3876     // and avoid dispatching text input events from keydown default handlers.
3877     ASSERT(!is&lt;KeyboardEvent&gt;(underlyingEvent) || downcast&lt;KeyboardEvent&gt;(*underlyingEvent).type() == eventNames().keypressEvent);
3878 
3879     Ref&lt;Frame&gt; protectedFrame(m_frame);
3880 
3881     EventTarget* target;
3882     if (underlyingEvent)
3883         target = underlyingEvent-&gt;target();
3884     else
3885         target = eventTargetElementForDocument(m_frame.document());
3886     if (!target)
3887         return false;
3888 
3889     if (FrameView* view = m_frame.view())
3890         view-&gt;disableLayerFlushThrottlingTemporarilyForInteraction();
3891 
3892     auto event = TextEvent::create(&amp;m_frame.windowProxy(), text, inputType);
3893     event-&gt;setUnderlyingEvent(underlyingEvent);
3894 
3895     target-&gt;dispatchEvent(event);
3896     return event-&gt;defaultHandled();
3897 }
3898 
3899 bool EventHandler::isKeyboardOptionTab(KeyboardEvent&amp; event)
3900 {
3901     return (event.type() == eventNames().keydownEvent || event.type() == eventNames().keypressEvent)
3902         &amp;&amp; event.altKey()
3903         &amp;&amp; event.keyIdentifier() == &quot;U+0009&quot;;
3904 }
3905 
3906 bool EventHandler::eventInvertsTabsToLinksClientCallResult(KeyboardEvent&amp; event)
3907 {
3908 #if PLATFORM(COCOA)
3909     return isKeyboardOptionTab(event);
3910 #else
3911     UNUSED_PARAM(event);
3912     return false;
3913 #endif
3914 }
3915 
3916 bool EventHandler::tabsToLinks(KeyboardEvent* event) const
3917 {
3918     // FIXME: This function needs a better name. It can be called for keypresses other than Tab when spatial navigation is enabled.
3919 
3920     Page* page = m_frame.page();
3921     if (!page)
3922         return false;
3923 
3924     bool tabsToLinksClientCallResult = page-&gt;chrome().client().keyboardUIMode() &amp; KeyboardAccessTabsToLinks;
3925     return (event &amp;&amp; eventInvertsTabsToLinksClientCallResult(*event)) ? !tabsToLinksClientCallResult : tabsToLinksClientCallResult;
3926 }
3927 
3928 void EventHandler::defaultTextInputEventHandler(TextEvent&amp; event)
3929 {
3930     if (m_frame.editor().handleTextEvent(event))
3931         event.setDefaultHandled();
3932 }
3933 
3934 
3935 void EventHandler::defaultSpaceEventHandler(KeyboardEvent&amp; event)
3936 {
3937     Ref&lt;Frame&gt; protectedFrame(m_frame);
3938 
3939     ASSERT(event.type() == eventNames().keypressEvent);
3940 
3941     if (event.ctrlKey() || event.metaKey() || event.altKey() || event.altGraphKey())
3942         return;
3943 
3944     ScrollLogicalDirection direction = event.shiftKey() ? ScrollBlockDirectionBackward : ScrollBlockDirectionForward;
3945     if (logicalScrollOverflow(direction, ScrollByPage)) {
3946         event.setDefaultHandled();
3947         return;
3948     }
3949 
3950     FrameView* view = m_frame.view();
3951     if (!view)
3952         return;
3953 
3954     if (view-&gt;logicalScroll(direction, ScrollByPage))
3955         event.setDefaultHandled();
3956 }
3957 
3958 void EventHandler::defaultBackspaceEventHandler(KeyboardEvent&amp; event)
3959 {
3960     ASSERT(event.type() == eventNames().keydownEvent);
3961 
3962     if (event.ctrlKey() || event.metaKey() || event.altKey() || event.altGraphKey())
3963         return;
3964 
3965     if (!m_frame.editor().behavior().shouldNavigateBackOnBackspace())
3966         return;
3967 
3968     Page* page = m_frame.page();
3969     if (!page)
3970         return;
3971 
3972     if (!m_frame.settings().backspaceKeyNavigationEnabled())
3973         return;
3974 
3975     bool handledEvent = false;
3976 
3977     if (event.shiftKey())
3978         handledEvent = page-&gt;backForward().goForward();
3979     else
3980         handledEvent = page-&gt;backForward().goBack();
3981 
3982     if (handledEvent)
3983         event.setDefaultHandled();
3984 }
3985 
3986 
3987 void EventHandler::defaultArrowEventHandler(FocusDirection focusDirection, KeyboardEvent&amp; event)
3988 {
3989     ASSERT(event.type() == eventNames().keydownEvent);
3990 
3991     if (event.ctrlKey() || event.metaKey() || event.altGraphKey() || event.shiftKey())
3992         return;
3993 
3994     Page* page = m_frame.page();
3995     if (!page)
3996         return;
3997 
3998     if (!isSpatialNavigationEnabled(&amp;m_frame))
3999         return;
4000 
4001     // Arrows and other possible directional navigation keys can be used in design
4002     // mode editing.
4003     if (m_frame.document()-&gt;inDesignMode())
4004         return;
4005 
4006     if (page-&gt;focusController().advanceFocus(focusDirection, &amp;event))
4007         event.setDefaultHandled();
4008 }
4009 
4010 void EventHandler::defaultTabEventHandler(KeyboardEvent&amp; event)
4011 {
4012     Ref&lt;Frame&gt; protectedFrame(m_frame);
4013 
4014     ASSERT(event.type() == eventNames().keydownEvent);
4015 
4016     // We should only advance focus on tabs if no special modifier keys are held down.
4017     if (event.ctrlKey() || event.metaKey() || event.altGraphKey())
4018         return;
4019 
4020     Page* page = m_frame.page();
4021     if (!page)
4022         return;
4023     if (!page-&gt;tabKeyCyclesThroughElements())
4024         return;
4025 
4026     FocusDirection focusDirection = event.shiftKey() ? FocusDirectionBackward : FocusDirectionForward;
4027 
4028     // Tabs can be used in design mode editing.
4029     if (m_frame.document()-&gt;inDesignMode())
4030         return;
4031 
4032     if (page-&gt;focusController().advanceFocus(focusDirection, &amp;event))
4033         event.setDefaultHandled();
4034 }
4035 
4036 void EventHandler::sendScrollEvent()
4037 {
4038     Ref&lt;Frame&gt; protectedFrame(m_frame);
4039     setFrameWasScrolledByUser();
<a name="53" id="anc53"></a><span class="line-modified">4040     if (!m_frame.view())</span>
<span class="line-modified">4041         return;</span>
<span class="line-added">4042     auto document = makeRefPtr(m_frame.document());</span>
<span class="line-added">4043     if (!document)</span>
<span class="line-added">4044         return;</span>
<span class="line-added">4045     document-&gt;addPendingScrollEventTarget(*document);</span>
4046 }
4047 
4048 void EventHandler::setFrameWasScrolledByUser()
4049 {
4050     FrameView* v = m_frame.view();
4051     if (v)
4052         v-&gt;setWasScrolledByUser(true);
4053 }
4054 
4055 bool EventHandler::passMousePressEventToScrollbar(MouseEventWithHitTestResults&amp; mouseEvent, Scrollbar* scrollbar)
4056 {
4057     if (!scrollbar || !scrollbar-&gt;enabled())
4058         return false;
4059     setFrameWasScrolledByUser();
4060     return scrollbar-&gt;mouseDown(mouseEvent.event());
4061 }
4062 
4063 // If scrollbar (under mouse) is different from last, send a mouse exited.
4064 void EventHandler::updateLastScrollbarUnderMouse(Scrollbar* scrollbar, SetOrClearLastScrollbar setOrClear)
4065 {
4066     if (m_lastScrollbarUnderMouse != scrollbar) {
4067         // Send mouse exited to the old scrollbar.
4068         if (m_lastScrollbarUnderMouse)
4069             m_lastScrollbarUnderMouse-&gt;mouseExited();
4070 
4071         // Send mouse entered if we&#39;re setting a new scrollbar.
4072         if (scrollbar &amp;&amp; setOrClear == SetOrClearLastScrollbar::Set) {
4073             scrollbar-&gt;mouseEntered();
4074             m_lastScrollbarUnderMouse = makeWeakPtr(*scrollbar);
4075         } else
4076             m_lastScrollbarUnderMouse = nullptr;
4077     }
4078 }
4079 
4080 #if ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
4081 static const AtomString&amp; eventNameForTouchPointState(PlatformTouchPoint::State state)
4082 {
4083     switch (state) {
4084     case PlatformTouchPoint::TouchReleased:
4085         return eventNames().touchendEvent;
4086     case PlatformTouchPoint::TouchCancelled:
4087         return eventNames().touchcancelEvent;
4088     case PlatformTouchPoint::TouchPressed:
4089         return eventNames().touchstartEvent;
4090     case PlatformTouchPoint::TouchMoved:
4091         return eventNames().touchmoveEvent;
4092     case PlatformTouchPoint::TouchStationary:
4093         // TouchStationary state is not converted to touch events, so fall through to assert.
4094     default:
4095         ASSERT_NOT_REACHED();
4096         return emptyAtom();
4097     }
4098 }
4099 
4100 static HitTestResult hitTestResultInFrame(Frame* frame, const LayoutPoint&amp; point, HitTestRequest::HitTestRequestType hitType)
4101 {
4102     HitTestResult result(point);
4103 
4104     if (!frame || !frame-&gt;contentRenderer())
4105         return result;
4106 
4107     if (frame-&gt;view()) {
4108         IntRect rect = frame-&gt;view()-&gt;visibleContentRect();
4109         if (!rect.contains(roundedIntPoint(point)))
4110             return result;
4111     }
4112     frame-&gt;document()-&gt;hitTest(HitTestRequest(hitType), result);
4113     return result;
4114 }
4115 
4116 bool EventHandler::handleTouchEvent(const PlatformTouchEvent&amp; event)
4117 {
4118     Ref&lt;Frame&gt; protectedFrame(m_frame);
4119 
4120     // First build up the lists to use for the &#39;touches&#39;, &#39;targetTouches&#39; and &#39;changedTouches&#39; attributes
4121     // in the JS event. See http://www.sitepen.com/blog/2008/07/10/touching-and-gesturing-on-the-iphone/
4122     // for an overview of how these lists fit together.
4123 
4124     // Holds the complete set of touches on the screen and will be used as the &#39;touches&#39; list in the JS event.
4125     RefPtr&lt;TouchList&gt; touches = TouchList::create();
4126 
4127     // A different view on the &#39;touches&#39; list above, filtered and grouped by event target. Used for the
4128     // &#39;targetTouches&#39; list in the JS event.
4129     typedef HashMap&lt;EventTarget*, RefPtr&lt;TouchList&gt;&gt; TargetTouchesMap;
4130     TargetTouchesMap touchesByTarget;
4131 
4132     // Array of touches per state, used to assemble the &#39;changedTouches&#39; list in the JS event.
4133     typedef HashSet&lt;RefPtr&lt;EventTarget&gt;&gt; EventTargetSet;
4134     struct {
4135         // The touches corresponding to the particular change state this struct instance represents.
4136         RefPtr&lt;TouchList&gt; m_touches;
4137         // Set of targets involved in m_touches.
4138         EventTargetSet m_targets;
4139     } changedTouches[PlatformTouchPoint::TouchStateEnd];
4140 
4141     const Vector&lt;PlatformTouchPoint&gt;&amp; points = event.touchPoints();
4142 
4143     UserGestureIndicator gestureIndicator(ProcessingUserGesture, m_frame.document());
4144 
4145     bool freshTouchEvents = true;
4146     bool allTouchReleased = true;
4147     for (auto&amp; point : points) {
4148         if (point.state() != PlatformTouchPoint::TouchPressed)
4149             freshTouchEvents = false;
4150         if (point.state() != PlatformTouchPoint::TouchReleased &amp;&amp; point.state() != PlatformTouchPoint::TouchCancelled)
4151             allTouchReleased = false;
4152     }
4153 
4154     for (auto&amp; point : points) {
4155         PlatformTouchPoint::State pointState = point.state();
4156         LayoutPoint pagePoint = documentPointForWindowPoint(m_frame, point.pos());
4157 
4158         HitTestRequest::HitTestRequestType hitType = HitTestRequest::TouchEvent;
4159         // The HitTestRequest types used for mouse events map quite adequately
4160         // to touch events. Note that in addition to meaning that the hit test
4161         // should affect the active state of the current node if necessary,
4162         // HitTestRequest::Active signifies that the hit test is taking place
4163         // with the mouse (or finger in this case) being pressed.
4164         switch (pointState) {
4165         case PlatformTouchPoint::TouchPressed:
4166             hitType |= HitTestRequest::Active;
4167             break;
4168         case PlatformTouchPoint::TouchMoved:
4169             hitType |= HitTestRequest::Active | HitTestRequest::Move | HitTestRequest::ReadOnly;
4170             break;
4171         case PlatformTouchPoint::TouchReleased:
4172         case PlatformTouchPoint::TouchCancelled:
4173             hitType |= HitTestRequest::Release;
4174             break;
4175         case PlatformTouchPoint::TouchStationary:
4176             hitType |= HitTestRequest::Active | HitTestRequest::ReadOnly;
4177             break;
4178         default:
4179             ASSERT_NOT_REACHED();
4180             break;
4181         }
4182 
4183         if (shouldGesturesTriggerActive())
4184             hitType |= HitTestRequest::ReadOnly;
4185 
4186         // Increment the platform touch id by 1 to avoid storing a key of 0 in the hashmap.
4187         unsigned touchPointTargetKey = point.id() + 1;
4188         RefPtr&lt;EventTarget&gt; touchTarget;
4189         if (pointState == PlatformTouchPoint::TouchPressed) {
4190             HitTestResult result;
4191             if (freshTouchEvents) {
4192                 result = hitTestResultAtPoint(pagePoint, hitType | HitTestRequest::AllowChildFrameContent);
4193                 m_originatingTouchPointTargetKey = touchPointTargetKey;
4194             } else if (m_originatingTouchPointDocument.get() &amp;&amp; m_originatingTouchPointDocument-&gt;frame()) {
4195                 LayoutPoint pagePointInOriginatingDocument = documentPointForWindowPoint(*m_originatingTouchPointDocument-&gt;frame(), point.pos());
4196                 result = hitTestResultInFrame(m_originatingTouchPointDocument-&gt;frame(), pagePointInOriginatingDocument, hitType);
4197                 if (!result.innerNode())
4198                     continue;
4199             } else
4200                 continue;
4201 
4202             Element* element = result.targetElement();
4203             ASSERT(element);
4204 
4205             if (element &amp;&amp; InspectorInstrumentation::handleTouchEvent(m_frame, *element))
4206                 return true;
4207 
4208             Document&amp; doc = element-&gt;document();
4209             // Record the originating touch document even if it does not have a touch listener.
4210             if (freshTouchEvents) {
4211                 m_originatingTouchPointDocument = &amp;doc;
4212                 freshTouchEvents = false;
4213             }
4214             if (!doc.hasTouchEventHandlers())
4215                 continue;
4216             m_originatingTouchPointTargets.set(touchPointTargetKey, element);
4217             touchTarget = element;
4218         } else if (pointState == PlatformTouchPoint::TouchReleased || pointState == PlatformTouchPoint::TouchCancelled) {
4219             // No need to perform a hit-test since we only need to unset :hover and :active states.
4220             if (!shouldGesturesTriggerActive() &amp;&amp; allTouchReleased)
4221                 m_frame.document()-&gt;updateHoverActiveState(hitType, 0);
4222             if (touchPointTargetKey == m_originatingTouchPointTargetKey)
4223                 m_originatingTouchPointTargetKey = 0;
4224 
4225             // The target should be the original target for this touch, so get it from the hashmap. As it&#39;s a release or cancel
4226             // we also remove it from the map.
4227             touchTarget = m_originatingTouchPointTargets.take(touchPointTargetKey);
4228         } else
4229             // No hittest is performed on move or stationary, since the target is not allowed to change anyway.
4230             touchTarget = m_originatingTouchPointTargets.get(touchPointTargetKey);
4231 
4232         if (!is&lt;Node&gt;(touchTarget))
4233             continue;
4234         auto&amp; document = downcast&lt;Node&gt;(*touchTarget).document();
4235         if (!document.hasTouchEventHandlers())
4236             continue;
4237         auto* targetFrame = document.frame();
4238         if (!targetFrame)
4239             continue;
4240 
4241         if (&amp;m_frame != targetFrame) {
4242             // pagePoint should always be relative to the target elements containing frame.
4243             pagePoint = documentPointForWindowPoint(*targetFrame, point.pos());
4244         }
4245 
4246         float scaleFactor = targetFrame-&gt;pageZoomFactor() * targetFrame-&gt;frameScaleFactor();
4247 
4248         int adjustedPageX = lroundf(pagePoint.x() / scaleFactor);
4249         int adjustedPageY = lroundf(pagePoint.y() / scaleFactor);
4250 
4251         auto touch = Touch::create(targetFrame, touchTarget.get(), point.id(),
4252             point.screenPos().x(), point.screenPos().y(), adjustedPageX, adjustedPageY,
4253             point.radiusX(), point.radiusY(), point.rotationAngle(), point.force());
4254 
4255         // Ensure this target&#39;s touch list exists, even if it ends up empty, so it can always be passed to TouchEvent::Create below.
4256         TargetTouchesMap::iterator targetTouchesIterator = touchesByTarget.find(touchTarget.get());
4257         if (targetTouchesIterator == touchesByTarget.end())
4258             targetTouchesIterator = touchesByTarget.set(touchTarget.get(), TouchList::create()).iterator;
4259 
4260         // touches and targetTouches should only contain information about touches still on the screen, so if this point is
4261         // released or cancelled it will only appear in the changedTouches list.
4262         if (pointState != PlatformTouchPoint::TouchReleased &amp;&amp; pointState != PlatformTouchPoint::TouchCancelled) {
4263             touches-&gt;append(touch.copyRef());
4264             targetTouchesIterator-&gt;value-&gt;append(touch.copyRef());
4265         }
4266 
4267         // Now build up the correct list for changedTouches.
4268         // Note that  any touches that are in the TouchStationary state (e.g. if
4269         // the user had several points touched but did not move them all) should
4270         // never be in the changedTouches list so we do not handle them explicitly here.
4271         // See https://bugs.webkit.org/show_bug.cgi?id=37609 for further discussion
4272         // about the TouchStationary state.
4273         if (pointState != PlatformTouchPoint::TouchStationary) {
4274             ASSERT(pointState &lt; PlatformTouchPoint::TouchStateEnd);
4275             if (!changedTouches[pointState].m_touches)
4276                 changedTouches[pointState].m_touches = TouchList::create();
4277             changedTouches[pointState].m_touches-&gt;append(WTFMove(touch));
4278             changedTouches[pointState].m_targets.add(touchTarget);
4279         }
4280     }
4281     m_touchPressed = touches-&gt;length() &gt; 0;
4282     if (allTouchReleased)
4283         m_originatingTouchPointDocument = nullptr;
4284 
4285     // Now iterate the changedTouches list and m_targets within it, sending events to the targets as required.
4286     bool swallowedEvent = false;
4287     RefPtr&lt;TouchList&gt; emptyList = TouchList::create();
4288     for (unsigned state = 0; state != PlatformTouchPoint::TouchStateEnd; ++state) {
4289         if (!changedTouches[state].m_touches)
4290             continue;
4291 
4292         // When sending a touch cancel event, use empty touches and targetTouches lists.
4293         bool isTouchCancelEvent = (state == PlatformTouchPoint::TouchCancelled);
4294         RefPtr&lt;TouchList&gt;&amp; effectiveTouches(isTouchCancelEvent ? emptyList : touches);
4295         const AtomString&amp; stateName(eventNameForTouchPointState(static_cast&lt;PlatformTouchPoint::State&gt;(state)));
4296 
4297         for (auto&amp; target : changedTouches[state].m_targets) {
4298             ASSERT(is&lt;Node&gt;(target));
4299 
4300             RefPtr&lt;TouchList&gt; targetTouches(isTouchCancelEvent ? emptyList : touchesByTarget.get(target.get()));
4301             ASSERT(targetTouches);
4302 
4303             Ref&lt;TouchEvent&gt; touchEvent = TouchEvent::create(effectiveTouches.get(), targetTouches.get(), changedTouches[state].m_touches.get(),
4304                 stateName, downcast&lt;Node&gt;(*target).document().windowProxy(), { }, event.modifiers());
4305             target-&gt;dispatchEvent(touchEvent);
4306             swallowedEvent = swallowedEvent || touchEvent-&gt;defaultPrevented() || touchEvent-&gt;defaultHandled();
4307         }
4308     }
4309 
4310     return swallowedEvent;
4311 }
4312 #endif // ENABLE(TOUCH_EVENTS) &amp;&amp; !ENABLE(IOS_TOUCH_EVENTS)
4313 
4314 #if ENABLE(TOUCH_EVENTS)
4315 bool EventHandler::dispatchSyntheticTouchEventIfEnabled(const PlatformMouseEvent&amp; platformMouseEvent)
4316 {
4317 #if ENABLE(IOS_TOUCH_EVENTS)
4318     UNUSED_PARAM(platformMouseEvent);
4319     return false;
4320 #else
4321     if (!m_frame.settings().isTouchEventEmulationEnabled())
4322         return false;
4323 
4324     PlatformEvent::Type eventType = platformMouseEvent.type();
4325     if (eventType != PlatformEvent::MouseMoved &amp;&amp; eventType != PlatformEvent::MousePressed &amp;&amp; eventType != PlatformEvent::MouseReleased)
4326         return false;
4327 
4328     HitTestRequest request(HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent);
4329     MouseEventWithHitTestResults mouseEvent = prepareMouseEvent(request, platformMouseEvent);
4330     if (mouseEvent.scrollbar() || subframeForHitTestResult(mouseEvent))
4331         return false;
4332 
4333     // The order is important. This check should follow the subframe test: http://webkit.org/b/111292.
4334     if (eventType == PlatformEvent::MouseMoved &amp;&amp; !m_touchPressed)
4335         return true;
4336 
4337     SyntheticSingleTouchEvent touchEvent(platformMouseEvent);
4338     return handleTouchEvent(touchEvent);
4339 #endif
4340 }
4341 #endif // ENABLE(TOUCH_EVENTS)
4342 
4343 void EventHandler::setLastKnownMousePosition(const PlatformMouseEvent&amp; event)
4344 {
4345     m_mousePositionIsUnknown = false;
4346     m_lastKnownMousePosition = event.position();
4347     m_lastKnownMouseGlobalPosition = event.globalPosition();
4348 }
4349 
4350 void EventHandler::setImmediateActionStage(ImmediateActionStage stage)
4351 {
4352     m_immediateActionStage = stage;
4353 }
4354 
4355 #if !PLATFORM(COCOA)
4356 OptionSet&lt;PlatformEvent::Modifier&gt; EventHandler::accessKeyModifiers()
4357 {
4358     return PlatformEvent::Modifier::AltKey;
4359 }
4360 
4361 bool EventHandler::passMousePressEventToSubframe(MouseEventWithHitTestResults&amp; mev, Frame* subframe)
4362 {
4363     subframe-&gt;eventHandler().handleMousePressEvent(mev.event());
4364     return true;
4365 }
4366 
4367 bool EventHandler::passMouseReleaseEventToSubframe(MouseEventWithHitTestResults&amp; mev, Frame* subframe)
4368 {
4369     subframe-&gt;eventHandler().handleMouseReleaseEvent(mev.event());
4370     return true;
4371 }
4372 
4373 bool EventHandler::widgetDidHandleWheelEvent(const PlatformWheelEvent&amp; event, Widget&amp; widget)
4374 {
4375     if (!is&lt;FrameView&gt;(widget))
4376         return false;
4377 
4378     return downcast&lt;FrameView&gt;(widget).frame().eventHandler().handleWheelEvent(event);
4379 }
4380 
4381 bool EventHandler::tabsToAllFormControls(KeyboardEvent*) const
4382 {
4383     // We always allow tabs to all controls
4384     return true;
4385 }
4386 
4387 bool EventHandler::passWidgetMouseDownEventToWidget(RenderWidget* renderWidget)
4388 {
4389     return passMouseDownEventToWidget(renderWidget-&gt;widget());
4390 }
4391 
4392 bool EventHandler::passWidgetMouseDownEventToWidget(const MouseEventWithHitTestResults&amp; event)
4393 {
4394     // Figure out which view to send the event to.
4395     RenderObject* target = event.targetNode() ? event.targetNode()-&gt;renderer() : nullptr;
4396     if (!is&lt;RenderWidget&gt;(target))
4397         return false;
4398     return passMouseDownEventToWidget(downcast&lt;RenderWidget&gt;(*target).widget());
4399 }
4400 
4401 bool EventHandler::passMouseDownEventToWidget(Widget*)
4402 {
4403     notImplemented();
4404     return false;
4405 }
4406 
4407 void EventHandler::focusDocumentView()
4408 {
4409     if (Page* page = m_frame.page())
4410         page-&gt;focusController().setFocusedFrame(&amp;m_frame);
4411 }
4412 #endif // !PLATFORM(COCOA)
4413 
4414 #if !PLATFORM(COCOA) &amp;&amp; !PLATFORM(WIN) &amp;&amp; !PLATFORM(JAVA)
4415 bool EventHandler::eventActivatedView(const PlatformMouseEvent&amp;) const
4416 {
4417     notImplemented();
4418     return false;
4419 }
4420 
4421 bool EventHandler::passMouseMoveEventToSubframe(MouseEventWithHitTestResults&amp; mev, Frame* subframe, HitTestResult* hoveredNode)
4422 {
4423     subframe-&gt;eventHandler().handleMouseMoveEvent(mev.event(), hoveredNode);
4424     return true;
4425 }
4426 #endif // !PLATFORM(COCOA) &amp;&amp; !PLATFORM(WIN)
4427 
4428 } // namespace WebCore
<a name="54" id="anc54"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="54" type="hidden" />
</body>
</html>
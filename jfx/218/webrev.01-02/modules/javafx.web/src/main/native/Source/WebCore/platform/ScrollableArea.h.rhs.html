<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollableArea.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2008-2016 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ScrollSnapOffsetsInfo.h&quot;
 29 #include &quot;ScrollTypes.h&quot;
 30 #include &quot;Scrollbar.h&quot;
 31 #include &lt;wtf/Forward.h&gt;
 32 #include &lt;wtf/WeakPtr.h&gt;
 33 
 34 namespace WebCore {
 35 
 36 class FloatPoint;
 37 class GraphicsContext;
 38 class LayoutPoint;
 39 class LayoutSize;
 40 class PlatformTouchEvent;
 41 class PlatformWheelEvent;
 42 class ScrollAnimator;
 43 class GraphicsLayer;
 44 class TiledBacking;
 45 
 46 // scrollPosition is in content coordinates (0,0 is at scrollOrigin), so may have negative components.
 47 typedef IntPoint ScrollPosition;
 48 // scrollOffset() is the value used by scrollbars (min is 0,0), and should never have negative components.
 49 typedef IntPoint ScrollOffset;
 50 
 51 
 52 inline int offsetForOrientation(ScrollOffset offset, ScrollbarOrientation orientation)
 53 {
 54     switch (orientation) {
 55     case HorizontalScrollbar: return offset.x();
 56     case VerticalScrollbar: return offset.y();
 57     }
 58     ASSERT_NOT_REACHED();
 59     return 0;
 60 }
 61 
 62 
 63 class ScrollableArea : public CanMakeWeakPtr&lt;ScrollableArea&gt; {
 64 public:
 65     WEBCORE_EXPORT bool scroll(ScrollDirection, ScrollGranularity, float multiplier = 1);
 66     WEBCORE_EXPORT void scrollToOffsetWithoutAnimation(const FloatPoint&amp;, ScrollClamping = ScrollClamping::Clamped);
 67     void scrollToOffsetWithoutAnimation(ScrollbarOrientation, float offset);
 68 
 69     // Should be called when the scroll position changes externally, for example if the scroll layer position
 70     // is updated on the scrolling thread and we need to notify the main thread.
 71     WEBCORE_EXPORT void notifyScrollPositionChanged(const ScrollPosition&amp;);
 72 
 73     // Allows subclasses to handle scroll position updates themselves. If this member function
 74     // returns true, the scrollable area won&#39;t actually update the scroll position and instead
 75     // expect it to happen sometime in the future.
<a name="1" id="anc1"></a><span class="line-modified"> 76     virtual bool requestScrollPositionUpdate(const ScrollPosition&amp;, ScrollType = ScrollType::User, ScrollClamping = ScrollClamping::Clamped) { return false; }</span>
 77 
 78     WEBCORE_EXPORT bool handleWheelEvent(const PlatformWheelEvent&amp;);
 79 
 80 #if ENABLE(CSS_SCROLL_SNAP)
 81     WEBCORE_EXPORT const Vector&lt;LayoutUnit&gt;* horizontalSnapOffsets() const;
 82     WEBCORE_EXPORT const Vector&lt;LayoutUnit&gt;* verticalSnapOffsets() const;
 83     WEBCORE_EXPORT const Vector&lt;ScrollOffsetRange&lt;LayoutUnit&gt;&gt;* horizontalSnapOffsetRanges() const;
 84     WEBCORE_EXPORT const Vector&lt;ScrollOffsetRange&lt;LayoutUnit&gt;&gt;* verticalSnapOffsetRanges() const;
 85     virtual void updateSnapOffsets() { };
 86     void setHorizontalSnapOffsets(const Vector&lt;LayoutUnit&gt;&amp;);
 87     void setVerticalSnapOffsets(const Vector&lt;LayoutUnit&gt;&amp;);
 88     void setHorizontalSnapOffsetRanges(const Vector&lt;ScrollOffsetRange&lt;LayoutUnit&gt;&gt;&amp;);
 89     void setVerticalSnapOffsetRanges(const Vector&lt;ScrollOffsetRange&lt;LayoutUnit&gt;&gt;&amp;);
 90     void clearHorizontalSnapOffsets();
 91     void clearVerticalSnapOffsets();
 92     unsigned currentHorizontalSnapPointIndex() const { return m_currentHorizontalSnapPointIndex; }
 93     void setCurrentHorizontalSnapPointIndex(unsigned index) { m_currentHorizontalSnapPointIndex = index; }
 94     unsigned currentVerticalSnapPointIndex() const { return m_currentVerticalSnapPointIndex; }
 95     void setCurrentVerticalSnapPointIndex(unsigned index) { m_currentVerticalSnapPointIndex = index; }
 96     IntPoint nearestActiveSnapPoint(const IntPoint&amp;);
 97 #endif
 98 
 99     void updateScrollSnapState();
100 
101 #if ENABLE(TOUCH_EVENTS)
102     virtual bool handleTouchEvent(const PlatformTouchEvent&amp;);
103 #endif
104 
105 #if PLATFORM(IOS_FAMILY)
106     virtual void didStartScroll() { }
107     virtual void didEndScroll() { }
108     virtual void didUpdateScroll() { }
109 #endif
110 
111     // Functions for controlling if you can scroll past the end of the document.
112     bool constrainsScrollingToContentEdge() const { return m_constrainsScrollingToContentEdge; }
113     void setConstrainsScrollingToContentEdge(bool constrainsScrollingToContentEdge) { m_constrainsScrollingToContentEdge = constrainsScrollingToContentEdge; }
114 
115     void setVerticalScrollElasticity(ScrollElasticity scrollElasticity) { m_verticalScrollElasticity = scrollElasticity; }
116     ScrollElasticity verticalScrollElasticity() const { return static_cast&lt;ScrollElasticity&gt;(m_verticalScrollElasticity); }
117 
118     void setHorizontalScrollElasticity(ScrollElasticity scrollElasticity) { m_horizontalScrollElasticity = scrollElasticity; }
119     ScrollElasticity horizontalScrollElasticity() const { return static_cast&lt;ScrollElasticity&gt;(m_horizontalScrollElasticity); }
120 
121     virtual ScrollbarMode horizontalScrollbarMode() const { return ScrollbarAuto; }
122     virtual ScrollbarMode verticalScrollbarMode() const { return ScrollbarAuto; }
<a name="2" id="anc2"></a><span class="line-added">123     bool canHaveScrollbars() const { return horizontalScrollbarMode() != ScrollbarAlwaysOff || verticalScrollbarMode() != ScrollbarAlwaysOff; }</span>
124 
125     virtual bool horizontalScrollbarHiddenByStyle() const { return false; }
126     virtual bool verticalScrollbarHiddenByStyle() const { return false; }
127 
128     bool inLiveResize() const { return m_inLiveResize; }
129     WEBCORE_EXPORT virtual void willStartLiveResize();
130     WEBCORE_EXPORT virtual void willEndLiveResize();
131 
132     WEBCORE_EXPORT void contentAreaWillPaint() const;
133     WEBCORE_EXPORT void mouseEnteredContentArea() const;
134     WEBCORE_EXPORT void mouseExitedContentArea() const;
135     WEBCORE_EXPORT void mouseMovedInContentArea() const;
136     WEBCORE_EXPORT void mouseEnteredScrollbar(Scrollbar*) const;
137     void mouseExitedScrollbar(Scrollbar*) const;
138     void mouseIsDownInScrollbar(Scrollbar*, bool) const;
139     void contentAreaDidShow() const;
140     void contentAreaDidHide() const;
141 
142     void lockOverlayScrollbarStateToHidden(bool shouldLockState) const;
143     WEBCORE_EXPORT bool scrollbarsCanBeActive() const;
144 
145     WEBCORE_EXPORT virtual void didAddScrollbar(Scrollbar*, ScrollbarOrientation);
146     WEBCORE_EXPORT virtual void willRemoveScrollbar(Scrollbar*, ScrollbarOrientation);
147 
148     WEBCORE_EXPORT virtual void contentsResized();
149 
150     // Force the contents to recompute their size (i.e. do layout).
151     virtual void updateContentsSize() { }
152 
153     enum class AvailableSizeChangeReason {
154         ScrollbarsChanged,
155         AreaSizeChanged
156     };
157     WEBCORE_EXPORT virtual void availableContentSizeChanged(AvailableSizeChangeReason);
158 
159     bool hasOverlayScrollbars() const;
160     WEBCORE_EXPORT virtual void setScrollbarOverlayStyle(ScrollbarOverlayStyle);
161     ScrollbarOverlayStyle scrollbarOverlayStyle() const { return static_cast&lt;ScrollbarOverlayStyle&gt;(m_scrollbarOverlayStyle); }
162     bool useDarkAppearanceForScrollbars() const;
163 
164     virtual ScrollingNodeID scrollingNodeID() const { return 0; }
165 
166     // This getter will create a ScrollAnimator if it doesn&#39;t already exist.
167     WEBCORE_EXPORT ScrollAnimator&amp; scrollAnimator() const;
168 
169     // This getter will return null if the ScrollAnimator hasn&#39;t been created yet.
170     ScrollAnimator* existingScrollAnimator() const { return m_scrollAnimator.get(); }
171 
172     virtual bool isActive() const = 0;
173     WEBCORE_EXPORT virtual void invalidateScrollbar(Scrollbar&amp;, const IntRect&amp;);
174     virtual bool isScrollCornerVisible() const = 0;
175     virtual IntRect scrollCornerRect() const = 0;
176     WEBCORE_EXPORT virtual void invalidateScrollCorner(const IntRect&amp;);
177 
178     virtual bool forceUpdateScrollbarsOnMainThreadForPerformanceTesting() const = 0;
179 
180     // Convert points and rects between the scrollbar and its containing view.
181     // The client needs to implement these in order to be aware of layout effects
182     // like CSS transforms.
183     virtual IntRect convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntRect&amp; scrollbarRect) const
184     {
185         return scrollbar.Widget::convertToContainingView(scrollbarRect);
186     }
187     virtual IntRect convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntRect&amp; parentRect) const
188     {
189         return scrollbar.Widget::convertFromContainingView(parentRect);
190     }
191     virtual IntPoint convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntPoint&amp; scrollbarPoint) const
192     {
193         return scrollbar.Widget::convertToContainingView(scrollbarPoint);
194     }
195     virtual IntPoint convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntPoint&amp; parentPoint) const
196     {
197         return scrollbar.Widget::convertFromContainingView(parentPoint);
198     }
199 
200     int horizontalScrollbarIntrusion() const;
201     int verticalScrollbarIntrusion() const;
202     WEBCORE_EXPORT IntSize scrollbarIntrusion() const;
203 
204     virtual Scrollbar* horizontalScrollbar() const { return nullptr; }
205     virtual Scrollbar* verticalScrollbar() const { return nullptr; }
206 
207     const IntPoint&amp; scrollOrigin() const { return m_scrollOrigin; }
208     bool scrollOriginChanged() const { return m_scrollOriginChanged; }
209 
210     virtual ScrollPosition scrollPosition() const = 0;
211     virtual ScrollPosition minimumScrollPosition() const;
212     virtual ScrollPosition maximumScrollPosition() const;
213 
214     ScrollPosition constrainScrollPosition(const ScrollPosition&amp; position) const
215     {
216         return position.constrainedBetween(minimumScrollPosition(), maximumScrollPosition());
217     }
218 
219     WEBCORE_EXPORT ScrollOffset scrollOffset() const;
220 
221     ScrollOffset maximumScrollOffset() const;
222 
223     WEBCORE_EXPORT ScrollPosition scrollPositionFromOffset(ScrollOffset) const;
224     WEBCORE_EXPORT ScrollOffset scrollOffsetFromPosition(ScrollPosition) const;
225 
226     template&lt;typename PositionType, typename SizeType&gt;
227     static PositionType scrollPositionFromOffset(PositionType offset, SizeType scrollOrigin)
228     {
229         return offset - scrollOrigin;
230     }
231 
232     template&lt;typename PositionType, typename SizeType&gt;
233     static PositionType scrollOffsetFromPosition(PositionType position, SizeType scrollOrigin)
234     {
235         return position + scrollOrigin;
236     }
237 
238     WEBCORE_EXPORT virtual bool scrolledToTop() const;
239     WEBCORE_EXPORT virtual bool scrolledToBottom() const;
240     WEBCORE_EXPORT virtual bool scrolledToLeft() const;
241     WEBCORE_EXPORT virtual bool scrolledToRight() const;
242 
243     ScrollType currentScrollType() const { return static_cast&lt;ScrollType&gt;(m_currentScrollType); }
244     void setCurrentScrollType(ScrollType scrollType) { m_currentScrollType = static_cast&lt;unsigned&gt;(scrollType); }
245 
246     bool scrollShouldClearLatchedState() const { return m_scrollShouldClearLatchedState; }
247     void setScrollShouldClearLatchedState(bool shouldClear) { m_scrollShouldClearLatchedState = shouldClear; }
248 
249     enum VisibleContentRectIncludesScrollbars { ExcludeScrollbars, IncludeScrollbars };
250     enum VisibleContentRectBehavior {
251         ContentsVisibleRect,
252 #if PLATFORM(IOS_FAMILY)
253         LegacyIOSDocumentViewRect,
254         LegacyIOSDocumentVisibleRect = LegacyIOSDocumentViewRect
255 #else
256         LegacyIOSDocumentVisibleRect = ContentsVisibleRect
257 #endif
258     };
259 
260     WEBCORE_EXPORT IntRect visibleContentRect(VisibleContentRectBehavior = ContentsVisibleRect) const;
261     WEBCORE_EXPORT IntRect visibleContentRectIncludingScrollbars(VisibleContentRectBehavior = ContentsVisibleRect) const;
262 
263     int visibleWidth() const { return visibleSize().width(); }
264     int visibleHeight() const { return visibleSize().height(); }
265     virtual IntSize visibleSize() const = 0;
266 
267     virtual IntSize contentsSize() const = 0;
268     virtual IntSize overhangAmount() const { return IntSize(); }
269     virtual IntPoint lastKnownMousePosition() const { return IntPoint(); }
270     virtual bool isHandlingWheelEvent() const { return false; }
271 
272     virtual int headerHeight() const { return 0; }
273     virtual int footerHeight() const { return 0; }
274 
275     // The totalContentsSize() is equivalent to the contentsSize() plus the header and footer heights.
276     WEBCORE_EXPORT IntSize totalContentsSize() const;
277     WEBCORE_EXPORT virtual IntSize reachableTotalContentsSize() const;
278 
279     virtual bool useDarkAppearance() const { return false; }
280 
281     virtual bool shouldSuspendScrollAnimations() const { return true; }
282     WEBCORE_EXPORT virtual void scrollbarStyleChanged(ScrollbarStyle /*newStyle*/, bool /*forceUpdate*/);
283     virtual void setVisibleScrollerThumbRect(const IntRect&amp;) { }
284 
285     // Note that this only returns scrollable areas that can actually be scrolled.
286     virtual ScrollableArea* enclosingScrollableArea() const = 0;
287 
288     virtual bool isScrollableOrRubberbandable() = 0;
289     virtual bool hasScrollableOrRubberbandableAncestor() = 0;
290 
291     // Returns the bounding box of this scrollable area, in the coordinate system of the enclosing scroll view.
292     virtual IntRect scrollableAreaBoundingBox(bool* = nullptr) const = 0;
293 
294     virtual bool isRubberBandInProgress() const { return false; }
295     virtual bool isScrollSnapInProgress() const { return false; }
296 
297     virtual bool scrollAnimatorEnabled() const { return false; }
298 
299     // NOTE: Only called from Internals for testing.
300     WEBCORE_EXPORT void setScrollOffsetFromInternals(const ScrollOffset&amp;);
301 
302     WEBCORE_EXPORT static LayoutPoint constrainScrollPositionForOverhang(const LayoutRect&amp; visibleContentRect, const LayoutSize&amp; totalContentsSize, const LayoutPoint&amp; scrollPosition, const LayoutPoint&amp; scrollOrigin, int headerHeight, int footetHeight);
303     LayoutPoint constrainScrollPositionForOverhang(const LayoutPoint&amp; scrollPosition);
304 
305     // Computes the double value for the scrollbar&#39;s current position and the current overhang amount.
306     // This function is static so that it can be called from the main thread or the scrolling thread.
307     WEBCORE_EXPORT static void computeScrollbarValueAndOverhang(float currentPosition, float totalSize, float visibleSize, float&amp; doubleValue, float&amp; overhangAmount);
308 
309     // Let subclasses provide a way of asking for and servicing scroll
310     // animations.
311     virtual bool scheduleAnimation() { return false; }
312     void serviceScrollAnimations();
313 
314     bool isHorizontalScrollerPinnedToMinimumPosition() const { return !horizontalScrollbar() || scrollOffset().x() &lt;= 0; }
315     bool isHorizontalScrollerPinnedToMaximumPosition() const { return !horizontalScrollbar() || scrollOffset().x() &gt;= maximumScrollOffset().x(); }
316     bool isVerticalScrollerPinnedToMinimumPosition() const { return !verticalScrollbar() || scrollOffset().y() &lt;= 0; }
317     bool isVerticalScrollerPinnedToMaximumPosition() const { return !verticalScrollbar() || scrollOffset().y() &gt;= maximumScrollOffset().y(); }
318 
319     bool isPinnedInBothDirections(const IntSize&amp;) const;
320     bool isPinnedHorizontallyInDirection(int horizontalScrollDelta) const;
321     bool isPinnedVerticallyInDirection(int verticalScrollDelta) const;
322 
323     // True if scrolling happens by moving compositing layers.
324     virtual bool usesCompositedScrolling() const { return false; }
325     // True if the contents can be scrolled asynchronously (i.e. by a ScrollingCoordinator).
326     virtual bool usesAsyncScrolling() const { return false; }
327 
328     virtual GraphicsLayer* layerForHorizontalScrollbar() const { return nullptr; }
329     virtual GraphicsLayer* layerForVerticalScrollbar() const { return nullptr; }
330 
331     bool hasLayerForHorizontalScrollbar() const;
332     bool hasLayerForVerticalScrollbar() const;
333 
334     void verticalScrollbarLayerDidChange();
335     void horizontalScrollbarLayerDidChange();
336 
337     virtual bool usesMockScrollAnimator() const { return false; }
338     virtual void logMockScrollAnimatorMessage(const String&amp;) const { };
339 
340     virtual bool shouldPlaceBlockDirectionScrollbarOnLeft() const = 0;
341 
342 protected:
343     WEBCORE_EXPORT ScrollableArea();
344     WEBCORE_EXPORT virtual ~ScrollableArea();
345 
346     void setScrollOrigin(const IntPoint&amp;);
347     void resetScrollOriginChanged() { m_scrollOriginChanged = false; }
348 
349     WEBCORE_EXPORT virtual float adjustScrollStepForFixedContent(float step, ScrollbarOrientation, ScrollGranularity);
350     virtual void invalidateScrollbarRect(Scrollbar&amp;, const IntRect&amp;) = 0;
351     virtual void invalidateScrollCornerRect(const IntRect&amp;) = 0;
352 
353     friend class ScrollingCoordinator;
354     virtual GraphicsLayer* layerForScrollCorner() const { return nullptr; }
355 #if ENABLE(RUBBER_BANDING)
356     virtual GraphicsLayer* layerForOverhangAreas() const { return nullptr; }
357 #endif
358 
359     bool hasLayerForScrollCorner() const;
360 
361 private:
362     WEBCORE_EXPORT virtual IntRect visibleContentRectInternal(VisibleContentRectIncludesScrollbars, VisibleContentRectBehavior) const;
363     void scrollPositionChanged(const ScrollPosition&amp;);
364 
365     // NOTE: Only called from the ScrollAnimator.
366     friend class ScrollAnimator;
367     void setScrollOffsetFromAnimation(const ScrollOffset&amp;);
368 
369     // This function should be overridden by subclasses to perform the actual
370     // scroll of the content.
371     virtual void setScrollOffset(const ScrollOffset&amp;) = 0;
372     ScrollSnapOffsetsInfo&lt;LayoutUnit&gt;&amp; ensureSnapOffsetsInfo();
373 
374     mutable std::unique_ptr&lt;ScrollAnimator&gt; m_scrollAnimator;
375 
376 #if ENABLE(CSS_SCROLL_SNAP)
377     std::unique_ptr&lt;ScrollSnapOffsetsInfo&lt;LayoutUnit&gt;&gt; m_snapOffsetsInfo;
378     unsigned m_currentHorizontalSnapPointIndex { 0 };
379     unsigned m_currentVerticalSnapPointIndex { 0 };
380 #endif
381 
382     // There are 8 possible combinations of writing mode and direction. Scroll origin will be non-zero in the x or y axis
383     // if there is any reversed direction or writing-mode. The combinations are:
384     // writing-mode / direction     scrollOrigin.x() set    scrollOrigin.y() set
385     // horizontal-tb / ltr          NO                      NO
386     // horizontal-tb / rtl          YES                     NO
387     // horizontal-bt / ltr          NO                      YES
388     // horizontal-bt / rtl          YES                     YES
389     // vertical-lr / ltr            NO                      NO
390     // vertical-lr / rtl            NO                      YES
391     // vertical-rl / ltr            YES                     NO
392     // vertical-rl / rtl            YES                     YES
393     IntPoint m_scrollOrigin;
394 
395     unsigned m_constrainsScrollingToContentEdge : 1;
396 
397     unsigned m_inLiveResize : 1;
398 
399     unsigned m_verticalScrollElasticity : 2; // ScrollElasticity
400     unsigned m_horizontalScrollElasticity : 2; // ScrollElasticity
401 
402     unsigned m_scrollbarOverlayStyle : 2; // ScrollbarOverlayStyle
403 
404     unsigned m_scrollOriginChanged : 1;
405     unsigned m_currentScrollType : 1; // ScrollType
406     unsigned m_scrollShouldClearLatchedState : 1;
407 };
408 
409 } // namespace WebCore
410 
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
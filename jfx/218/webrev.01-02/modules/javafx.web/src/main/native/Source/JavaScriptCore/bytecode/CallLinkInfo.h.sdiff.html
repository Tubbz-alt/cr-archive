<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CallLinkInfo.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CallLinkInfo.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallLinkStatus.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CallLinkInfo.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
117         case CallVarargs:
118         case TailCall:
119         case TailCallVarargs:
120         case Construct:
121         case ConstructVarargs:
122             return false;
123         case None:
124             RELEASE_ASSERT_NOT_REACHED();
125             return false;
126         }
127 
128         RELEASE_ASSERT_NOT_REACHED();
129         return false;
130     }
131 
132     CallMode callMode() const
133     {
134         return callModeFor(static_cast&lt;CallType&gt;(m_callType));
135     }
136 
<span class="line-modified">137     bool isDirect()</span>
138     {
139         return isDirect(static_cast&lt;CallType&gt;(m_callType));
140     }
141 
142     bool isTailCall() const
143     {
144         return callMode() == CallMode::Tail;
145     }
146 
147     NearCallMode nearCallMode() const
148     {
149         return isTailCall() ? NearCallMode::Tail : NearCallMode::Regular;
150     }
151 
152     bool isVarargs() const
153     {
154         return isVarargsCallType(static_cast&lt;CallType&gt;(m_callType));
155     }
156 
<span class="line-modified">157     bool isLinked() { return m_stub || m_calleeOrCodeBlock; }</span>
158     void unlink(VM&amp;);
159 
160     void setUpCall(CallType callType, CodeOrigin codeOrigin, GPRReg calleeGPR)
161     {
162         m_callType = callType;
163         m_codeOrigin = codeOrigin;
164         m_calleeGPR = calleeGPR;
165     }
166 
167     void setCallLocations(
168         CodeLocationLabel&lt;JSInternalPtrTag&gt; callReturnLocationOrPatchableJump,
169         CodeLocationLabel&lt;JSInternalPtrTag&gt; hotPathBeginOrSlowPathStart,
170         CodeLocationNearCall&lt;JSInternalPtrTag&gt; hotPathOther)
171     {
172         m_callReturnLocationOrPatchableJump = callReturnLocationOrPatchableJump;
173         m_hotPathBeginOrSlowPathStart = hotPathBeginOrSlowPathStart;
174         m_hotPathOther = hotPathOther;
175     }
176 
177     bool allowStubs() const { return m_allowStubs; }
</pre>
<hr />
<pre>
184     CodeLocationNearCall&lt;JSInternalPtrTag&gt; callReturnLocation();
185     CodeLocationJump&lt;JSInternalPtrTag&gt; patchableJump();
186     CodeLocationDataLabelPtr&lt;JSInternalPtrTag&gt; hotPathBegin();
187     CodeLocationLabel&lt;JSInternalPtrTag&gt; slowPathStart();
188 
189     CodeLocationNearCall&lt;JSInternalPtrTag&gt; hotPathOther()
190     {
191         return m_hotPathOther;
192     }
193 
194     void setCallee(VM&amp;, JSCell*, JSObject* callee);
195     void clearCallee();
196     JSObject* callee();
197 
198     void setCodeBlock(VM&amp;, JSCell*, FunctionCodeBlock*);
199     void clearCodeBlock();
200     FunctionCodeBlock* codeBlock();
201 
202     void setLastSeenCallee(VM&amp;, const JSCell* owner, JSObject* callee);
203     void clearLastSeenCallee();
<span class="line-modified">204     JSObject* lastSeenCallee();</span>
<span class="line-modified">205     bool haveLastSeenCallee();</span>
206 
207     void setExecutableDuringCompilation(ExecutableBase*);
208     ExecutableBase* executable();
209 
210     void setStub(Ref&lt;PolymorphicCallStubRoutine&gt;&amp;&amp; newStub)
211     {
212         clearStub();
213         m_stub = WTFMove(newStub);
214     }
215 
216     void clearStub();
217 
<span class="line-modified">218     PolymorphicCallStubRoutine* stub()</span>
219     {
220         return m_stub.get();
221     }
222 
223     void setSlowStub(Ref&lt;JITStubRoutine&gt;&amp;&amp; newSlowStub)
224     {
225         m_slowStub = WTFMove(newSlowStub);
226     }
227 
228     void clearSlowStub()
229     {
230         m_slowStub = nullptr;
231     }
232 
233     JITStubRoutine* slowStub()
234     {
235         return m_slowStub.get();
236     }
237 
238     bool seenOnce()
</pre>
<hr />
<pre>
278     void setClearedByVirtual()
279     {
280         m_clearedByVirtual = true;
281     }
282 
283     void setClearedByJettison()
284     {
285         m_clearedByJettison = true;
286     }
287 
288     void setCallType(CallType callType)
289     {
290         m_callType = callType;
291     }
292 
293     CallType callType()
294     {
295         return static_cast&lt;CallType&gt;(m_callType);
296     }
297 
<span class="line-modified">298     uint32_t* addressOfMaxNumArguments()</span>
299     {
<span class="line-modified">300         return &amp;m_maxNumArguments;</span>
301     }
302 
<span class="line-modified">303     uint32_t maxNumArguments()</span>
304     {
<span class="line-modified">305         return m_maxNumArguments;</span>
306     }
307 
<span class="line-modified">308     void setMaxNumArguments(unsigned);</span>
309 
310     static ptrdiff_t offsetOfSlowPathCount()
311     {
312         return OBJECT_OFFSETOF(CallLinkInfo, m_slowPathCount);
313     }
314 
315     GPRReg calleeGPR()
316     {
317         return m_calleeGPR;
318     }
319 
320     uint32_t slowPathCount()
321     {
322         return m_slowPathCount;
323     }
324 
325     void setCodeOrigin(CodeOrigin codeOrigin)
326     {
327         m_codeOrigin = codeOrigin;
328     }
329 
330     CodeOrigin codeOrigin()
331     {
332         return m_codeOrigin;
333     }
334 
















335     void visitWeak(VM&amp;);
336 
337     void setFrameShuffleData(const CallFrameShuffleData&amp;);
338 
339     const CallFrameShuffleData* frameShuffleData()
340     {
341         return m_frameShuffleData.get();
342     }
343 
344 private:
<span class="line-modified">345     uint32_t m_maxNumArguments { 0 }; // For varargs: the profiled maximum number of arguments. For direct: the number of stack slots allocated for arguments.</span>
346     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_callReturnLocationOrPatchableJump;
347     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_hotPathBeginOrSlowPathStart;
348     CodeLocationNearCall&lt;JSInternalPtrTag&gt; m_hotPathOther;
349     WriteBarrier&lt;JSCell&gt; m_calleeOrCodeBlock;
350     WriteBarrier&lt;JSCell&gt; m_lastSeenCalleeOrExecutable;
351     RefPtr&lt;PolymorphicCallStubRoutine&gt; m_stub;
352     RefPtr&lt;JITStubRoutine&gt; m_slowStub;
353     std::unique_ptr&lt;CallFrameShuffleData&gt; m_frameShuffleData;
354     CodeOrigin m_codeOrigin;
355     bool m_hasSeenShouldRepatch : 1;
356     bool m_hasSeenClosure : 1;
357     bool m_clearedByGC : 1;
358     bool m_clearedByVirtual : 1;
359     bool m_allowStubs : 1;
360     bool m_clearedByJettison : 1;
361     unsigned m_callType : 4; // CallType
362     GPRReg m_calleeGPR { InvalidGPRReg };
363     uint32_t m_slowPathCount { 0 };
364 };
365 
</pre>
</td>
<td>
<hr />
<pre>
117         case CallVarargs:
118         case TailCall:
119         case TailCallVarargs:
120         case Construct:
121         case ConstructVarargs:
122             return false;
123         case None:
124             RELEASE_ASSERT_NOT_REACHED();
125             return false;
126         }
127 
128         RELEASE_ASSERT_NOT_REACHED();
129         return false;
130     }
131 
132     CallMode callMode() const
133     {
134         return callModeFor(static_cast&lt;CallType&gt;(m_callType));
135     }
136 
<span class="line-modified">137     bool isDirect() const</span>
138     {
139         return isDirect(static_cast&lt;CallType&gt;(m_callType));
140     }
141 
142     bool isTailCall() const
143     {
144         return callMode() == CallMode::Tail;
145     }
146 
147     NearCallMode nearCallMode() const
148     {
149         return isTailCall() ? NearCallMode::Tail : NearCallMode::Regular;
150     }
151 
152     bool isVarargs() const
153     {
154         return isVarargsCallType(static_cast&lt;CallType&gt;(m_callType));
155     }
156 
<span class="line-modified">157     bool isLinked() const { return m_stub || m_calleeOrCodeBlock; }</span>
158     void unlink(VM&amp;);
159 
160     void setUpCall(CallType callType, CodeOrigin codeOrigin, GPRReg calleeGPR)
161     {
162         m_callType = callType;
163         m_codeOrigin = codeOrigin;
164         m_calleeGPR = calleeGPR;
165     }
166 
167     void setCallLocations(
168         CodeLocationLabel&lt;JSInternalPtrTag&gt; callReturnLocationOrPatchableJump,
169         CodeLocationLabel&lt;JSInternalPtrTag&gt; hotPathBeginOrSlowPathStart,
170         CodeLocationNearCall&lt;JSInternalPtrTag&gt; hotPathOther)
171     {
172         m_callReturnLocationOrPatchableJump = callReturnLocationOrPatchableJump;
173         m_hotPathBeginOrSlowPathStart = hotPathBeginOrSlowPathStart;
174         m_hotPathOther = hotPathOther;
175     }
176 
177     bool allowStubs() const { return m_allowStubs; }
</pre>
<hr />
<pre>
184     CodeLocationNearCall&lt;JSInternalPtrTag&gt; callReturnLocation();
185     CodeLocationJump&lt;JSInternalPtrTag&gt; patchableJump();
186     CodeLocationDataLabelPtr&lt;JSInternalPtrTag&gt; hotPathBegin();
187     CodeLocationLabel&lt;JSInternalPtrTag&gt; slowPathStart();
188 
189     CodeLocationNearCall&lt;JSInternalPtrTag&gt; hotPathOther()
190     {
191         return m_hotPathOther;
192     }
193 
194     void setCallee(VM&amp;, JSCell*, JSObject* callee);
195     void clearCallee();
196     JSObject* callee();
197 
198     void setCodeBlock(VM&amp;, JSCell*, FunctionCodeBlock*);
199     void clearCodeBlock();
200     FunctionCodeBlock* codeBlock();
201 
202     void setLastSeenCallee(VM&amp;, const JSCell* owner, JSObject* callee);
203     void clearLastSeenCallee();
<span class="line-modified">204     JSObject* lastSeenCallee() const;</span>
<span class="line-modified">205     bool haveLastSeenCallee() const;</span>
206 
207     void setExecutableDuringCompilation(ExecutableBase*);
208     ExecutableBase* executable();
209 
210     void setStub(Ref&lt;PolymorphicCallStubRoutine&gt;&amp;&amp; newStub)
211     {
212         clearStub();
213         m_stub = WTFMove(newStub);
214     }
215 
216     void clearStub();
217 
<span class="line-modified">218     PolymorphicCallStubRoutine* stub() const</span>
219     {
220         return m_stub.get();
221     }
222 
223     void setSlowStub(Ref&lt;JITStubRoutine&gt;&amp;&amp; newSlowStub)
224     {
225         m_slowStub = WTFMove(newSlowStub);
226     }
227 
228     void clearSlowStub()
229     {
230         m_slowStub = nullptr;
231     }
232 
233     JITStubRoutine* slowStub()
234     {
235         return m_slowStub.get();
236     }
237 
238     bool seenOnce()
</pre>
<hr />
<pre>
278     void setClearedByVirtual()
279     {
280         m_clearedByVirtual = true;
281     }
282 
283     void setClearedByJettison()
284     {
285         m_clearedByJettison = true;
286     }
287 
288     void setCallType(CallType callType)
289     {
290         m_callType = callType;
291     }
292 
293     CallType callType()
294     {
295         return static_cast&lt;CallType&gt;(m_callType);
296     }
297 
<span class="line-modified">298     uint32_t* addressOfMaxArgumentCountIncludingThis()</span>
299     {
<span class="line-modified">300         return &amp;m_maxArgumentCountIncludingThis;</span>
301     }
302 
<span class="line-modified">303     uint32_t maxArgumentCountIncludingThis()</span>
304     {
<span class="line-modified">305         return m_maxArgumentCountIncludingThis;</span>
306     }
307 
<span class="line-modified">308     void setMaxArgumentCountIncludingThis(unsigned);</span>
309 
310     static ptrdiff_t offsetOfSlowPathCount()
311     {
312         return OBJECT_OFFSETOF(CallLinkInfo, m_slowPathCount);
313     }
314 
315     GPRReg calleeGPR()
316     {
317         return m_calleeGPR;
318     }
319 
320     uint32_t slowPathCount()
321     {
322         return m_slowPathCount;
323     }
324 
325     void setCodeOrigin(CodeOrigin codeOrigin)
326     {
327         m_codeOrigin = codeOrigin;
328     }
329 
330     CodeOrigin codeOrigin()
331     {
332         return m_codeOrigin;
333     }
334 
<span class="line-added">335     template&lt;typename Functor&gt;</span>
<span class="line-added">336     void forEachDependentCell(const Functor&amp; functor) const</span>
<span class="line-added">337     {</span>
<span class="line-added">338         if (isLinked()) {</span>
<span class="line-added">339             if (stub())</span>
<span class="line-added">340                 stub()-&gt;forEachDependentCell(functor);</span>
<span class="line-added">341             else {</span>
<span class="line-added">342                 functor(m_calleeOrCodeBlock.get());</span>
<span class="line-added">343                 if (isDirect())</span>
<span class="line-added">344                     functor(m_lastSeenCalleeOrExecutable.get());</span>
<span class="line-added">345             }</span>
<span class="line-added">346         }</span>
<span class="line-added">347         if (!isDirect() &amp;&amp; haveLastSeenCallee())</span>
<span class="line-added">348             functor(lastSeenCallee());</span>
<span class="line-added">349     }</span>
<span class="line-added">350 </span>
351     void visitWeak(VM&amp;);
352 
353     void setFrameShuffleData(const CallFrameShuffleData&amp;);
354 
355     const CallFrameShuffleData* frameShuffleData()
356     {
357         return m_frameShuffleData.get();
358     }
359 
360 private:
<span class="line-modified">361     uint32_t m_maxArgumentCountIncludingThis { 0 }; // For varargs: the profiled maximum number of arguments. For direct: the number of stack slots allocated for arguments.</span>
362     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_callReturnLocationOrPatchableJump;
363     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_hotPathBeginOrSlowPathStart;
364     CodeLocationNearCall&lt;JSInternalPtrTag&gt; m_hotPathOther;
365     WriteBarrier&lt;JSCell&gt; m_calleeOrCodeBlock;
366     WriteBarrier&lt;JSCell&gt; m_lastSeenCalleeOrExecutable;
367     RefPtr&lt;PolymorphicCallStubRoutine&gt; m_stub;
368     RefPtr&lt;JITStubRoutine&gt; m_slowStub;
369     std::unique_ptr&lt;CallFrameShuffleData&gt; m_frameShuffleData;
370     CodeOrigin m_codeOrigin;
371     bool m_hasSeenShouldRepatch : 1;
372     bool m_hasSeenClosure : 1;
373     bool m_clearedByGC : 1;
374     bool m_clearedByVirtual : 1;
375     bool m_allowStubs : 1;
376     bool m_clearedByJettison : 1;
377     unsigned m_callType : 4; // CallType
378     GPRReg m_calleeGPR { InvalidGPRReg };
379     uint32_t m_slowPathCount { 0 };
380 };
381 
</pre>
</td>
</tr>
</table>
<center><a href="CallLinkInfo.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallLinkStatus.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
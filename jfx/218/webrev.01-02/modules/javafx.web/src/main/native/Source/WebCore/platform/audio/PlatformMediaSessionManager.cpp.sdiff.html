<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/audio/PlatformMediaSessionManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PlatformMediaSession.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PlatformMediaSessionManager.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/audio/PlatformMediaSessionManager.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
149     m_logger-&gt;addLogger(session.logger());
150 #endif
151 
152     updateSessionState();
153 }
154 
155 void PlatformMediaSessionManager::removeSession(PlatformMediaSession&amp; session)
156 {
157     ALWAYS_LOG(LOGIDENTIFIER, session.logIdentifier());
158 
159     size_t index = m_sessions.find(&amp;session);
160     if (index == notFound)
161         return;
162 
163     m_sessions.remove(index);
164 
165     if (m_sessions.isEmpty() || std::all_of(m_sessions.begin(), m_sessions.end(), std::logical_not&lt;void&gt;())) {
166         m_remoteCommandListener = nullptr;
167         m_audioHardwareListener = nullptr;
168 #if USE(AUDIO_SESSION)
<span class="line-modified">169         if (m_becameActive &amp;&amp; shouldDeactivateAudioSession()) {</span>
<span class="line-removed">170             AudioSession::sharedSession().tryToSetActive(false);</span>
<span class="line-removed">171             m_becameActive = false;</span>
<span class="line-removed">172         }</span>
173 #endif
174     }
175 
176 #if !RELEASE_LOG_DISABLED
177     m_logger-&gt;removeLogger(session.logger());
178 #endif
179 
180     updateSessionState();
181 }
182 
183 void PlatformMediaSessionManager::addRestriction(PlatformMediaSession::MediaType type, SessionRestrictions restriction)
184 {
185     ASSERT(type &gt; PlatformMediaSession::None &amp;&amp; type &lt;= PlatformMediaSession::MediaStreamCapturingAudio);
186     m_restrictions[type] |= restriction;
187 }
188 
189 void PlatformMediaSessionManager::removeRestriction(PlatformMediaSession::MediaType type, SessionRestrictions restriction)
190 {
191     ASSERT(type &gt; PlatformMediaSession::None &amp;&amp; type &lt;= PlatformMediaSession::MediaStreamCapturingAudio);
192     m_restrictions[type] &amp;= ~restriction;
</pre>
<hr />
<pre>
221     }
222 #endif
223 
224     if (m_interrupted)
225         endInterruption(PlatformMediaSession::NoFlags);
226 
227     if (restrictions &amp; ConcurrentPlaybackNotPermitted) {
228         forEachMatchingSession([&amp;session, sessionType](auto&amp; oneSession) {
229             return &amp;oneSession != &amp;session
230                 &amp;&amp; oneSession.mediaType() == sessionType
231                 &amp;&amp; oneSession.state() == PlatformMediaSession::Playing
232                 &amp;&amp; !oneSession.canPlayConcurrently(session);
233         }, [](auto&amp; oneSession) {
234             oneSession.pauseSession();
235         });
236     }
237     ALWAYS_LOG(LOGIDENTIFIER, session.logIdentifier(), &quot; returning true&quot;);
238     return true;
239 }
240 
<span class="line-modified">241 void PlatformMediaSessionManager::sessionWillEndPlayback(PlatformMediaSession&amp; session)</span>
242 {
243     ALWAYS_LOG(LOGIDENTIFIER, session.logIdentifier());
244 
245     if (m_sessions.size() &lt; 2)
246         return;
247 
248     size_t pausingSessionIndex = notFound;
249     size_t lastPlayingSessionIndex = notFound;
250     for (size_t i = 0, size = m_sessions.size(); i &lt; size; ++i) {
251         const auto&amp; oneSession = *m_sessions[i];
252         if (&amp;oneSession == &amp;session)
253             pausingSessionIndex = i;
254         else if (oneSession.state() == PlatformMediaSession::Playing)
255             lastPlayingSessionIndex = i;
256         else
257             break;
258     }
259 
260     if (lastPlayingSessionIndex == notFound || pausingSessionIndex == notFound)
261         return;
</pre>
<hr />
<pre>
346     ALWAYS_LOG(LOGIDENTIFIER, &quot;suspendedUnderLock: &quot;, suspendedUnderLock);
347 
348     if (!m_isApplicationInBackground)
349         return;
350 
351     m_isApplicationInBackground = false;
352 
353     forEachMatchingSession([&amp;](auto&amp; session) {
354         return (suspendedUnderLock &amp;&amp; m_restrictions[session.mediaType()] &amp; SuspendedUnderLockPlaybackRestricted) || m_restrictions[session.mediaType()] &amp; BackgroundProcessPlaybackRestricted;
355     }, [](auto&amp; session) {
356         session.endInterruption(PlatformMediaSession::MayResumePlaying);
357     });
358 }
359 
360 void PlatformMediaSessionManager::processWillSuspend()
361 {
362     if (m_processIsSuspended)
363         return;
364     m_processIsSuspended = true;
365 


366     forEachSession([&amp;] (auto&amp; session) {
367         session.client().processIsSuspendedChanged();
368     });
369 
370 #if USE(AUDIO_SESSION)
<span class="line-modified">371     if (m_becameActive &amp;&amp; shouldDeactivateAudioSession()) {</span>
<span class="line-removed">372         AudioSession::sharedSession().tryToSetActive(false);</span>
<span class="line-removed">373         ALWAYS_LOG(LOGIDENTIFIER, &quot;tried to set inactive AudioSession&quot;);</span>
<span class="line-removed">374         m_becameActive = false;</span>
<span class="line-removed">375     }</span>
376 #endif
377 }
378 
379 void PlatformMediaSessionManager::processDidResume()
380 {
381     if (!m_processIsSuspended)
382         return;
383     m_processIsSuspended = false;
384 
385     forEachSession([&amp;] (auto&amp; session) {
386         session.client().processIsSuspendedChanged();
387     });
388 
389 #if USE(AUDIO_SESSION)
390     if (!m_becameActive &amp;&amp; activeAudioSessionRequired()) {
391         m_becameActive = AudioSession::sharedSession().tryToSetActive(true);
392         ALWAYS_LOG(LOGIDENTIFIER, &quot;tried to set active AudioSession, &quot;, m_becameActive ? &quot;succeeded&quot; : &quot;failed&quot;);
393     }
394 #endif
395 }
396 
397 void PlatformMediaSessionManager::setIsPlayingToAutomotiveHeadUnit(bool isPlayingToAutomotiveHeadUnit)
398 {
399     if (isPlayingToAutomotiveHeadUnit == m_isPlayingToAutomotiveHeadUnit)
400         return;
401 
402     ALWAYS_LOG(LOGIDENTIFIER, isPlayingToAutomotiveHeadUnit);
403     m_isPlayingToAutomotiveHeadUnit = isPlayingToAutomotiveHeadUnit;
404 }
405 
406 void PlatformMediaSessionManager::sessionIsPlayingToWirelessPlaybackTargetChanged(PlatformMediaSession&amp; session)
407 {
408     if (!m_isApplicationInBackground || !(m_restrictions[session.mediaType()] &amp; BackgroundProcessPlaybackRestricted))
409         return;
410 
411     if (session.state() != PlatformMediaSession::Interrupted)
412         session.beginInterruption(PlatformMediaSession::EnteringBackground);
413 }
414 
<span class="line-modified">415 void PlatformMediaSessionManager::sessionCanProduceAudioChanged(PlatformMediaSession&amp;)</span>
416 {
417     updateSessionState();
418 }
419 
420 void PlatformMediaSessionManager::didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType command, const PlatformMediaSession::RemoteCommandArgument* argument)
421 {
422     PlatformMediaSession* activeSession = currentSession();
423     if (!activeSession || !activeSession-&gt;canReceiveRemoteControlCommands())
424         return;
425     activeSession-&gt;didReceiveRemoteControlCommand(command, argument);
426 }
427 
428 bool PlatformMediaSessionManager::supportsSeeking() const
429 {
430     PlatformMediaSession* activeSession = currentSession();
431     if (!activeSession)
432         return false;
433     return activeSession-&gt;supportsSeeking();
434 }
435 
</pre>
<hr />
<pre>
528     });
529 }
530 
531 void PlatformMediaSessionManager::forEachSession(const Function&lt;void(PlatformMediaSession&amp;)&gt;&amp; callback)
532 {
533     auto sessions = m_sessions;
534     for (auto&amp; session : sessions) {
535         ASSERT(session);
536         if (session)
537             callback(*session);
538     }
539 }
540 
541 bool PlatformMediaSessionManager::anyOfSessions(const Function&lt;bool(const PlatformMediaSession&amp;)&gt;&amp; predicate) const
542 {
543     return WTF::anyOf(m_sessions, [&amp;predicate](const auto&amp; session) {
544         return predicate(*session);
545     });
546 }
547 












548 static bool&amp; deactivateAudioSession()
549 {
550     static bool deactivate;
551     return deactivate;
552 }
553 
554 bool PlatformMediaSessionManager::shouldDeactivateAudioSession()
555 {
556     return deactivateAudioSession();
557 }
558 
559 void PlatformMediaSessionManager::setShouldDeactivateAudioSession(bool deactivate)
560 {
561     deactivateAudioSession() = deactivate;
562 }
563 
564 #else // ENABLE(VIDEO) || ENABLE(WEB_AUDIO)
565 
566 void PlatformMediaSessionManager::updateNowPlayingInfoIfNecessary()
567 {
</pre>
</td>
<td>
<hr />
<pre>
149     m_logger-&gt;addLogger(session.logger());
150 #endif
151 
152     updateSessionState();
153 }
154 
155 void PlatformMediaSessionManager::removeSession(PlatformMediaSession&amp; session)
156 {
157     ALWAYS_LOG(LOGIDENTIFIER, session.logIdentifier());
158 
159     size_t index = m_sessions.find(&amp;session);
160     if (index == notFound)
161         return;
162 
163     m_sessions.remove(index);
164 
165     if (m_sessions.isEmpty() || std::all_of(m_sessions.begin(), m_sessions.end(), std::logical_not&lt;void&gt;())) {
166         m_remoteCommandListener = nullptr;
167         m_audioHardwareListener = nullptr;
168 #if USE(AUDIO_SESSION)
<span class="line-modified">169         maybeDeactivateAudioSession();</span>



170 #endif
171     }
172 
173 #if !RELEASE_LOG_DISABLED
174     m_logger-&gt;removeLogger(session.logger());
175 #endif
176 
177     updateSessionState();
178 }
179 
180 void PlatformMediaSessionManager::addRestriction(PlatformMediaSession::MediaType type, SessionRestrictions restriction)
181 {
182     ASSERT(type &gt; PlatformMediaSession::None &amp;&amp; type &lt;= PlatformMediaSession::MediaStreamCapturingAudio);
183     m_restrictions[type] |= restriction;
184 }
185 
186 void PlatformMediaSessionManager::removeRestriction(PlatformMediaSession::MediaType type, SessionRestrictions restriction)
187 {
188     ASSERT(type &gt; PlatformMediaSession::None &amp;&amp; type &lt;= PlatformMediaSession::MediaStreamCapturingAudio);
189     m_restrictions[type] &amp;= ~restriction;
</pre>
<hr />
<pre>
218     }
219 #endif
220 
221     if (m_interrupted)
222         endInterruption(PlatformMediaSession::NoFlags);
223 
224     if (restrictions &amp; ConcurrentPlaybackNotPermitted) {
225         forEachMatchingSession([&amp;session, sessionType](auto&amp; oneSession) {
226             return &amp;oneSession != &amp;session
227                 &amp;&amp; oneSession.mediaType() == sessionType
228                 &amp;&amp; oneSession.state() == PlatformMediaSession::Playing
229                 &amp;&amp; !oneSession.canPlayConcurrently(session);
230         }, [](auto&amp; oneSession) {
231             oneSession.pauseSession();
232         });
233     }
234     ALWAYS_LOG(LOGIDENTIFIER, session.logIdentifier(), &quot; returning true&quot;);
235     return true;
236 }
237 
<span class="line-modified">238 void PlatformMediaSessionManager::sessionWillEndPlayback(PlatformMediaSession&amp; session, DelayCallingUpdateNowPlaying)</span>
239 {
240     ALWAYS_LOG(LOGIDENTIFIER, session.logIdentifier());
241 
242     if (m_sessions.size() &lt; 2)
243         return;
244 
245     size_t pausingSessionIndex = notFound;
246     size_t lastPlayingSessionIndex = notFound;
247     for (size_t i = 0, size = m_sessions.size(); i &lt; size; ++i) {
248         const auto&amp; oneSession = *m_sessions[i];
249         if (&amp;oneSession == &amp;session)
250             pausingSessionIndex = i;
251         else if (oneSession.state() == PlatformMediaSession::Playing)
252             lastPlayingSessionIndex = i;
253         else
254             break;
255     }
256 
257     if (lastPlayingSessionIndex == notFound || pausingSessionIndex == notFound)
258         return;
</pre>
<hr />
<pre>
343     ALWAYS_LOG(LOGIDENTIFIER, &quot;suspendedUnderLock: &quot;, suspendedUnderLock);
344 
345     if (!m_isApplicationInBackground)
346         return;
347 
348     m_isApplicationInBackground = false;
349 
350     forEachMatchingSession([&amp;](auto&amp; session) {
351         return (suspendedUnderLock &amp;&amp; m_restrictions[session.mediaType()] &amp; SuspendedUnderLockPlaybackRestricted) || m_restrictions[session.mediaType()] &amp; BackgroundProcessPlaybackRestricted;
352     }, [](auto&amp; session) {
353         session.endInterruption(PlatformMediaSession::MayResumePlaying);
354     });
355 }
356 
357 void PlatformMediaSessionManager::processWillSuspend()
358 {
359     if (m_processIsSuspended)
360         return;
361     m_processIsSuspended = true;
362 
<span class="line-added">363     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">364 </span>
365     forEachSession([&amp;] (auto&amp; session) {
366         session.client().processIsSuspendedChanged();
367     });
368 
369 #if USE(AUDIO_SESSION)
<span class="line-modified">370     maybeDeactivateAudioSession();</span>




371 #endif
372 }
373 
374 void PlatformMediaSessionManager::processDidResume()
375 {
376     if (!m_processIsSuspended)
377         return;
378     m_processIsSuspended = false;
379 
380     forEachSession([&amp;] (auto&amp; session) {
381         session.client().processIsSuspendedChanged();
382     });
383 
384 #if USE(AUDIO_SESSION)
385     if (!m_becameActive &amp;&amp; activeAudioSessionRequired()) {
386         m_becameActive = AudioSession::sharedSession().tryToSetActive(true);
387         ALWAYS_LOG(LOGIDENTIFIER, &quot;tried to set active AudioSession, &quot;, m_becameActive ? &quot;succeeded&quot; : &quot;failed&quot;);
388     }
389 #endif
390 }
391 
392 void PlatformMediaSessionManager::setIsPlayingToAutomotiveHeadUnit(bool isPlayingToAutomotiveHeadUnit)
393 {
394     if (isPlayingToAutomotiveHeadUnit == m_isPlayingToAutomotiveHeadUnit)
395         return;
396 
397     ALWAYS_LOG(LOGIDENTIFIER, isPlayingToAutomotiveHeadUnit);
398     m_isPlayingToAutomotiveHeadUnit = isPlayingToAutomotiveHeadUnit;
399 }
400 
401 void PlatformMediaSessionManager::sessionIsPlayingToWirelessPlaybackTargetChanged(PlatformMediaSession&amp; session)
402 {
403     if (!m_isApplicationInBackground || !(m_restrictions[session.mediaType()] &amp; BackgroundProcessPlaybackRestricted))
404         return;
405 
406     if (session.state() != PlatformMediaSession::Interrupted)
407         session.beginInterruption(PlatformMediaSession::EnteringBackground);
408 }
409 
<span class="line-modified">410 void PlatformMediaSessionManager::sessionCanProduceAudioChanged()</span>
411 {
412     updateSessionState();
413 }
414 
415 void PlatformMediaSessionManager::didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType command, const PlatformMediaSession::RemoteCommandArgument* argument)
416 {
417     PlatformMediaSession* activeSession = currentSession();
418     if (!activeSession || !activeSession-&gt;canReceiveRemoteControlCommands())
419         return;
420     activeSession-&gt;didReceiveRemoteControlCommand(command, argument);
421 }
422 
423 bool PlatformMediaSessionManager::supportsSeeking() const
424 {
425     PlatformMediaSession* activeSession = currentSession();
426     if (!activeSession)
427         return false;
428     return activeSession-&gt;supportsSeeking();
429 }
430 
</pre>
<hr />
<pre>
523     });
524 }
525 
526 void PlatformMediaSessionManager::forEachSession(const Function&lt;void(PlatformMediaSession&amp;)&gt;&amp; callback)
527 {
528     auto sessions = m_sessions;
529     for (auto&amp; session : sessions) {
530         ASSERT(session);
531         if (session)
532             callback(*session);
533     }
534 }
535 
536 bool PlatformMediaSessionManager::anyOfSessions(const Function&lt;bool(const PlatformMediaSession&amp;)&gt;&amp; predicate) const
537 {
538     return WTF::anyOf(m_sessions, [&amp;predicate](const auto&amp; session) {
539         return predicate(*session);
540     });
541 }
542 
<span class="line-added">543 #if USE(AUDIO_SESSION)</span>
<span class="line-added">544 void PlatformMediaSessionManager::maybeDeactivateAudioSession()</span>
<span class="line-added">545 {</span>
<span class="line-added">546     if (!m_becameActive || !shouldDeactivateAudioSession())</span>
<span class="line-added">547         return;</span>
<span class="line-added">548 </span>
<span class="line-added">549     ALWAYS_LOG(LOGIDENTIFIER, &quot;tried to set inactive AudioSession&quot;);</span>
<span class="line-added">550     AudioSession::sharedSession().tryToSetActive(false);</span>
<span class="line-added">551     m_becameActive = false;</span>
<span class="line-added">552 }</span>
<span class="line-added">553 #endif</span>
<span class="line-added">554 </span>
555 static bool&amp; deactivateAudioSession()
556 {
557     static bool deactivate;
558     return deactivate;
559 }
560 
561 bool PlatformMediaSessionManager::shouldDeactivateAudioSession()
562 {
563     return deactivateAudioSession();
564 }
565 
566 void PlatformMediaSessionManager::setShouldDeactivateAudioSession(bool deactivate)
567 {
568     deactivateAudioSession() = deactivate;
569 }
570 
571 #else // ENABLE(VIDEO) || ENABLE(WEB_AUDIO)
572 
573 void PlatformMediaSessionManager::updateNowPlayingInfoIfNecessary()
574 {
</pre>
</td>
</tr>
</table>
<center><a href="PlatformMediaSession.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PlatformMediaSessionManager.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
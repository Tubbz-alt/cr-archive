<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/Watchpoint.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2012-2015 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;Watchpoint.h&quot;
 28 
 29 #include &quot;AdaptiveInferredPropertyValueWatchpointBase.h&quot;
 30 #include &quot;CodeBlockJettisoningWatchpoint.h&quot;
 31 #include &quot;DFGAdaptiveStructureWatchpoint.h&quot;
 32 #include &quot;FunctionRareData.h&quot;
 33 #include &quot;HeapInlines.h&quot;
 34 #include &quot;LLIntPrototypeLoadAdaptiveStructureWatchpoint.h&quot;
 35 #include &quot;ObjectToStringAdaptiveStructureWatchpoint.h&quot;
 36 #include &quot;StructureStubClearingWatchpoint.h&quot;
 37 #include &quot;VM.h&quot;
 38 #include &lt;wtf/CompilationThread.h&gt;
 39 
 40 namespace JSC {
 41 
 42 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(Watchpoint);
 43 DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(WatchpointSet);
 44 
 45 void StringFireDetail::dump(PrintStream&amp; out) const
 46 {
 47     out.print(m_string);
 48 }
 49 
 50 Watchpoint::~Watchpoint()
 51 {
 52     if (isOnList()) {
 53         // This will happen if we get destroyed before the set fires. That&#39;s totally a valid
 54         // possibility. For example:
 55         //
 56         // CodeBlock has a Watchpoint on transition from structure S1. The transition never
 57         // happens, but the CodeBlock gets destroyed because of GC.
 58         remove();
 59     }
 60 }
 61 
 62 void Watchpoint::fire(VM&amp; vm, const FireDetail&amp; detail)
 63 {
 64     RELEASE_ASSERT(!isOnList());
 65     switch (m_type) {
 66 #define JSC_DEFINE_WATCHPOINT_DISPATCH(type, cast) \
 67     case Type::type: \
 68         static_cast&lt;cast*&gt;(this)-&gt;fireInternal(vm, detail); \
 69         break;
 70     JSC_WATCHPOINT_TYPES(JSC_DEFINE_WATCHPOINT_DISPATCH)
 71 #undef JSC_DEFINE_WATCHPOINT_DISPATCH
 72     }
 73 }
 74 
 75 WatchpointSet::WatchpointSet(WatchpointState state)
 76     : m_state(state)
 77     , m_setIsNotEmpty(false)
 78 {
 79 }
 80 
 81 WatchpointSet::~WatchpointSet()
 82 {
 83     // Remove all watchpoints, so that they don&#39;t try to remove themselves. Note that we
 84     // don&#39;t fire watchpoints on deletion. We assume that any code that is interested in
 85     // watchpoints already also separately has a mechanism to make sure that the code is
 86     // either keeping the watchpoint set&#39;s owner alive, or does some weak reference thing.
 87     while (!m_set.isEmpty())
 88         m_set.begin()-&gt;remove();
 89 }
 90 
 91 void WatchpointSet::add(Watchpoint* watchpoint)
 92 {
 93     ASSERT(!isCompilationThread());
 94     ASSERT(state() != IsInvalidated);
 95     if (!watchpoint)
 96         return;
 97     m_set.push(watchpoint);
 98     m_setIsNotEmpty = true;
 99     m_state = IsWatched;
100 }
101 
102 void WatchpointSet::fireAllSlow(VM&amp; vm, const FireDetail&amp; detail)
103 {
104     ASSERT(state() == IsWatched);
105 
106     WTF::storeStoreFence();
107     m_state = IsInvalidated; // Do this first. Needed for adaptive watchpoints.
108     fireAllWatchpoints(vm, detail);
109     WTF::storeStoreFence();
110 }
111 
112 void WatchpointSet::fireAllSlow(VM&amp;, DeferredWatchpointFire* deferredWatchpoints)
113 {
114     ASSERT(state() == IsWatched);
115 
116     WTF::storeStoreFence();
117     deferredWatchpoints-&gt;takeWatchpointsToFire(this);
118     m_state = IsInvalidated; // Do after moving watchpoints to deferredWatchpoints so deferredWatchpoints gets our current state.
119     WTF::storeStoreFence();
120 }
121 
122 void WatchpointSet::fireAllSlow(VM&amp; vm, const char* reason)
123 {
124     fireAllSlow(vm, StringFireDetail(reason));
125 }
126 
127 void WatchpointSet::fireAllWatchpoints(VM&amp; vm, const FireDetail&amp; detail)
128 {
129     // In case there are any adaptive watchpoints, we need to make sure that they see that this
130     // watchpoint has been already invalidated.
131     RELEASE_ASSERT(hasBeenInvalidated());
132 
133     // Firing a watchpoint may cause a GC to happen. This GC could destroy various
134     // Watchpoints themselves while they&#39;re in the process of firing. It&#39;s not safe
135     // for most Watchpoints to be destructed while they&#39;re in the middle of firing.
136     // This GC could also destroy us, and we&#39;re not in a safe state to be destroyed.
137     // The safest thing to do is to DeferGCForAWhile to prevent this GC from happening.
138     DeferGCForAWhile deferGC(vm.heap);
139 
140     while (!m_set.isEmpty()) {
141         Watchpoint* watchpoint = m_set.begin();
142         ASSERT(watchpoint-&gt;isOnList());
143 
144         // Removing the Watchpoint before firing it makes it possible to implement watchpoints
145         // that add themselves to a different set when they fire. This kind of &quot;adaptive&quot;
146         // watchpoint can be used to track some semantic property that is more fine-graiend than
147         // what the set can convey. For example, we might care if a singleton object ever has a
148         // property called &quot;foo&quot;. We can watch for this by checking if its Structure has &quot;foo&quot; and
149         // then watching its transitions. But then the watchpoint fires if any property is added.
150         // So, before the watchpoint decides to invalidate any code, it can check if it is
151         // possible to add itself to the transition watchpoint set of the singleton object&#39;s new
152         // Structure.
153         watchpoint-&gt;remove();
154         ASSERT(m_set.begin() != watchpoint);
155         ASSERT(!watchpoint-&gt;isOnList());
156 
157         watchpoint-&gt;fire(vm, detail);
158         // After we fire the watchpoint, the watchpoint pointer may be a dangling pointer. That&#39;s
159         // fine, because we have no use for the pointer anymore.
160     }
161 }
162 
163 void WatchpointSet::take(WatchpointSet* other)
164 {
165     ASSERT(state() == ClearWatchpoint);
166     m_set.takeFrom(other-&gt;m_set);
167     m_setIsNotEmpty = other-&gt;m_setIsNotEmpty;
168     m_state = other-&gt;m_state;
169     other-&gt;m_setIsNotEmpty = false;
170 }
171 
172 void InlineWatchpointSet::add(Watchpoint* watchpoint)
173 {
174     inflate()-&gt;add(watchpoint);
175 }
176 
177 void InlineWatchpointSet::fireAll(VM&amp; vm, const char* reason)
178 {
179     fireAll(vm, StringFireDetail(reason));
180 }
181 
182 WatchpointSet* InlineWatchpointSet::inflateSlow()
183 {
184     ASSERT(isThin());
185     ASSERT(!isCompilationThread());
186     WatchpointSet* fat = adoptRef(new WatchpointSet(decodeState(m_data))).leakRef();
187     WTF::storeStoreFence();
188     m_data = bitwise_cast&lt;uintptr_t&gt;(fat);
189     return fat;
190 }
191 
192 void InlineWatchpointSet::freeFat()
193 {
194     ASSERT(isFat());
195     fat()-&gt;deref();
196 }
197 
198 DeferredWatchpointFire::DeferredWatchpointFire(VM&amp; vm)
199     : m_vm(vm)
200     , m_watchpointsToFire(ClearWatchpoint)
201 {
202 }
203 
204 DeferredWatchpointFire::~DeferredWatchpointFire()
205 {
206 }
207 
208 void DeferredWatchpointFire::fireAll()
209 {
210     if (m_watchpointsToFire.state() == IsWatched)
211         m_watchpointsToFire.fireAll(m_vm, *this);
212 }
213 
214 void DeferredWatchpointFire::takeWatchpointsToFire(WatchpointSet* watchpointsToFire)
215 {
216     ASSERT(m_watchpointsToFire.state() == ClearWatchpoint);
217     ASSERT(watchpointsToFire-&gt;state() == IsWatched);
218     m_watchpointsToFire.take(watchpointsToFire);
219 }
220 
221 } // namespace JSC
222 
223 namespace WTF {
224 
225 void printInternal(PrintStream&amp; out, JSC::WatchpointState state)
226 {
227     switch (state) {
228     case JSC::ClearWatchpoint:
229         out.print(&quot;ClearWatchpoint&quot;);
230         return;
231     case JSC::IsWatched:
232         out.print(&quot;IsWatched&quot;);
233         return;
234     case JSC::IsInvalidated:
235         out.print(&quot;IsInvalidated&quot;);
236         return;
237     }
238     RELEASE_ASSERT_NOT_REACHED();
239 }
240 
241 } // namespace WTF
242 
    </pre>
  </body>
</html>
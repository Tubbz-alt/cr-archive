<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGRect.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderSVGImage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGResourceClipper.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/svg/RenderSVGRect.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 41 }
 42 
 43 RenderSVGRect::~RenderSVGRect() = default;
 44 
 45 SVGRectElement&amp; RenderSVGRect::rectElement() const
 46 {
 47     return downcast&lt;SVGRectElement&gt;(RenderSVGShape::graphicsElement());
 48 }
 49 
 50 void RenderSVGRect::updateShapeFromElement()
 51 {
 52     // Before creating a new object we need to clear the cached bounding box
 53     // to avoid using garbage.
 54     m_fillBoundingBox = FloatRect();
 55     m_innerStrokeRect = FloatRect();
 56     m_outerStrokeRect = FloatRect();
 57     clearPath();
 58     m_usePathFallback = false;
 59 
 60     SVGLengthContext lengthContext(&amp;rectElement());
<span class="line-modified"> 61     FloatSize boundingBoxSize(lengthContext.valueForLength(style().width(), LengthModeWidth), lengthContext.valueForLength(style().height(), LengthModeHeight));</span>
 62 
<span class="line-modified"> 63     // Element is invalid if either dimension is negative.</span>
<span class="line-modified"> 64     if (boundingBoxSize.width() &lt; 0 || boundingBoxSize.height() &lt; 0)</span>
 65         return;
 66 
<span class="line-modified"> 67     // Rendering enabled? Spec: &quot;A value of zero disables rendering of the element.&quot;</span>
<span class="line-modified"> 68     if (!boundingBoxSize.isEmpty()) {</span>
<span class="line-modified"> 69         if (rectElement().rx().value(lengthContext) &gt; 0 || rectElement().ry().value(lengthContext) &gt; 0 || hasNonScalingStroke()) {</span>
<span class="line-modified"> 70             // Fall back to RenderSVGShape</span>
<span class="line-modified"> 71             RenderSVGShape::updateShapeFromElement();</span>
<span class="line-removed"> 72             m_usePathFallback = true;</span>
<span class="line-removed"> 73             return;</span>
<span class="line-removed"> 74         }</span>
 75     }
 76 
<span class="line-modified"> 77     m_fillBoundingBox = FloatRect(FloatPoint(lengthContext.valueForLength(style().svgStyle().x(), LengthModeWidth),</span>
<span class="line-modified"> 78         lengthContext.valueForLength(style().svgStyle().y(), LengthModeHeight)),</span>
 79         boundingBoxSize);
 80 
 81     // To decide if the stroke contains a point we create two rects which represent the inner and
 82     // the outer stroke borders. A stroke contains the point, if the point is between them.
 83     m_innerStrokeRect = m_fillBoundingBox;
 84     m_outerStrokeRect = m_fillBoundingBox;
 85 
 86     if (style().svgStyle().hasStroke()) {
 87         float strokeWidth = this-&gt;strokeWidth();
 88         m_innerStrokeRect.inflate(-strokeWidth / 2);
 89         m_outerStrokeRect.inflate(strokeWidth / 2);
 90     }
 91 
 92     m_strokeBoundingBox = m_outerStrokeRect;
 93 
 94 #if USE(CG)
 95     // CoreGraphics can inflate the stroke by 1px when drawing a rectangle with antialiasing disabled at non-integer coordinates, we need to compensate.
 96     if (style().svgStyle().shapeRendering() == ShapeRendering::CrispEdges)
 97         m_strokeBoundingBox.inflate(1);
 98 #endif
</pre>
</td>
<td>
<hr />
<pre>
 41 }
 42 
 43 RenderSVGRect::~RenderSVGRect() = default;
 44 
 45 SVGRectElement&amp; RenderSVGRect::rectElement() const
 46 {
 47     return downcast&lt;SVGRectElement&gt;(RenderSVGShape::graphicsElement());
 48 }
 49 
 50 void RenderSVGRect::updateShapeFromElement()
 51 {
 52     // Before creating a new object we need to clear the cached bounding box
 53     // to avoid using garbage.
 54     m_fillBoundingBox = FloatRect();
 55     m_innerStrokeRect = FloatRect();
 56     m_outerStrokeRect = FloatRect();
 57     clearPath();
 58     m_usePathFallback = false;
 59 
 60     SVGLengthContext lengthContext(&amp;rectElement());
<span class="line-modified"> 61     FloatSize boundingBoxSize(lengthContext.valueForLength(style().width(), SVGLengthMode::Width), lengthContext.valueForLength(style().height(), SVGLengthMode::Height));</span>
 62 
<span class="line-modified"> 63     // Spec: &quot;A negative value is illegal. A value of zero disables rendering of the element.&quot;</span>
<span class="line-modified"> 64     if (boundingBoxSize.isEmpty())</span>
 65         return;
 66 
<span class="line-modified"> 67     if (rectElement().rx().value(lengthContext) &gt; 0 || rectElement().ry().value(lengthContext) &gt; 0 || hasNonScalingStroke()) {</span>
<span class="line-modified"> 68         // Fall back to RenderSVGShape</span>
<span class="line-modified"> 69         RenderSVGShape::updateShapeFromElement();</span>
<span class="line-modified"> 70         m_usePathFallback = true;</span>
<span class="line-modified"> 71         return;</span>



 72     }
 73 
<span class="line-modified"> 74     m_fillBoundingBox = FloatRect(FloatPoint(lengthContext.valueForLength(style().svgStyle().x(), SVGLengthMode::Width),</span>
<span class="line-modified"> 75         lengthContext.valueForLength(style().svgStyle().y(), SVGLengthMode::Height)),</span>
 76         boundingBoxSize);
 77 
 78     // To decide if the stroke contains a point we create two rects which represent the inner and
 79     // the outer stroke borders. A stroke contains the point, if the point is between them.
 80     m_innerStrokeRect = m_fillBoundingBox;
 81     m_outerStrokeRect = m_fillBoundingBox;
 82 
 83     if (style().svgStyle().hasStroke()) {
 84         float strokeWidth = this-&gt;strokeWidth();
 85         m_innerStrokeRect.inflate(-strokeWidth / 2);
 86         m_outerStrokeRect.inflate(strokeWidth / 2);
 87     }
 88 
 89     m_strokeBoundingBox = m_outerStrokeRect;
 90 
 91 #if USE(CG)
 92     // CoreGraphics can inflate the stroke by 1px when drawing a rectangle with antialiasing disabled at non-integer coordinates, we need to compensate.
 93     if (style().svgStyle().shapeRendering() == ShapeRendering::CrispEdges)
 94         m_strokeBoundingBox.inflate(1);
 95 #endif
</pre>
</td>
</tr>
</table>
<center><a href="RenderSVGImage.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderSVGResourceClipper.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
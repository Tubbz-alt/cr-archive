<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/cloop.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 # Copyright (C) 2012-2019 Apple Inc. All rights reserved.
   2 #
   3 # Redistribution and use in source and binary forms, with or without
   4 # modification, are permitted provided that the following conditions
   5 # are met:
   6 # 1. Redistributions of source code must retain the above copyright
   7 #    notice, this list of conditions and the following disclaimer.
   8 # 2. Redistributions in binary form must reproduce the above copyright
   9 #    notice, this list of conditions and the following disclaimer in the
  10 #    documentation and/or other materials provided with the distribution.
  11 #
  12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  22 # THE POSSIBILITY OF SUCH DAMAGE.
  23 
  24 require &quot;config&quot;
  25 require &quot;ast&quot;
  26 require &quot;opt&quot;
  27 
  28 # The CLoop llint backend is initially based on the ARMv7 backend, and
  29 # then further enhanced with a few instructions from the x86 backend to
  30 # support building for X64 targets.  Hence, the shape of the generated
  31 # code and the usage convention of registers will look a lot like the
  32 # ARMv7 backend&#39;s.
  33 
  34 def cloopMapType(type)
  35     case type
  36     when :intptr;         &quot;.i()&quot;
  37     when :uintptr;        &quot;.u()&quot;
  38     when :int32;          &quot;.i32()&quot;
  39     when :uint32;         &quot;.u32()&quot;
  40     when :int64;          &quot;.i64()&quot;
  41     when :uint64;         &quot;.u64()&quot;
  42     when :int8;           &quot;.i8()&quot;
  43     when :uint8;          &quot;.u8()&quot;
  44     when :int8Ptr;        &quot;.i8p()&quot;
  45     when :voidPtr;        &quot;.vp()&quot;
  46     when :nativeFunc;     &quot;.nativeFunc()&quot;
  47     when :double;         &quot;.d()&quot;
  48     when :bitsAsDouble;   &quot;.bitsAsDouble()&quot;
  49     when :bitsAsInt64;    &quot;.bitsAsInt64()&quot;
  50     when :opcode;         &quot;.opcode()&quot;
  51     else;
  52         raise &quot;Unsupported type&quot;
  53     end
  54 end
  55 
  56 
  57 class SpecialRegister &lt; NoChildren
  58     def clLValue(type=:intptr)
  59         clDump
  60     end
  61     def clDump
  62         @name
  63     end
  64     def clValue(type=:intptr)
  65         @name + cloopMapType(type)
  66     end
  67 end
  68 
  69 C_LOOP_SCRATCH_FPR = SpecialRegister.new(&quot;d6&quot;)
  70 
  71 class RegisterID
  72     def clDump
  73         case name
  74         # The cloop is modelled on the ARM implementation. Hence, the a0-a3
  75         # registers are aliases for r0-r3 i.e. t0-t3 in our case.
  76         when &quot;t0&quot;, &quot;a0&quot;, &quot;r0&quot;
  77             &quot;t0&quot;
  78         when &quot;t1&quot;, &quot;a1&quot;, &quot;r1&quot;
  79             &quot;t1&quot;
  80         when &quot;t2&quot;, &quot;a2&quot;
  81             &quot;t2&quot;
  82         when &quot;t3&quot;, &quot;a3&quot;
  83             &quot;t3&quot;
  84         when &quot;t4&quot;
  85             &quot;pc&quot;
  86         when &quot;t5&quot;
  87             &quot;t5&quot;
  88         when &quot;csr0&quot;
  89             &quot;pcBase&quot;
  90         when &quot;csr1&quot;
  91             &quot;numberTag&quot;
  92         when &quot;csr2&quot;
  93             &quot;notCellMask&quot;
  94         when &quot;csr3&quot;
  95             &quot;metadataTable&quot;
  96         when &quot;cfr&quot;
  97             &quot;cfr&quot;
  98         when &quot;lr&quot;
  99             &quot;lr&quot;
 100         when &quot;sp&quot;
 101             &quot;sp&quot;
 102         else
 103             raise &quot;Bad register #{name} for C_LOOP at #{codeOriginString}&quot;
 104         end
 105     end
 106     def clLValue(type=:intptr)
 107         clDump
 108     end
 109     def clValue(type=:intptr)
 110         clDump + cloopMapType(type)
 111     end
 112 end
 113 
 114 class FPRegisterID
 115     def clDump
 116         case name
 117         when &quot;ft0&quot;, &quot;fr&quot;
 118             &quot;d0&quot;
 119         when &quot;ft1&quot;
 120             &quot;d1&quot;
 121         when &quot;ft2&quot;
 122             &quot;d2&quot;
 123         when &quot;ft3&quot;
 124             &quot;d3&quot;
 125         when &quot;ft4&quot;
 126             &quot;d4&quot;
 127         when &quot;ft5&quot;
 128             &quot;d5&quot;
 129         else
 130             raise &quot;Bad register #{name} for C_LOOP at #{codeOriginString}&quot;
 131         end
 132     end
 133     def clLValue(type=:intptr)
 134         clDump
 135     end
 136     def clValue(type=:intptr)
 137         clDump + cloopMapType(type)
 138     end
 139 end
 140 
 141 class Immediate
 142     def clDump
 143         &quot;#{value}&quot;
 144     end
 145     def clLValue(type=:intptr)
 146         raise &quot;Immediate cannot be used as an LValue&quot;
 147     end
 148     def clValue(type=:intptr)
 149         # There is a case of a very large unsigned number (0x8000000000000000)
 150         # which we wish to encode.  Unfortunately, the C/C++ compiler
 151         # complains if we express that number as a positive decimal integer.
 152         # Hence, for positive values, we just convert the number into hex form
 153         # to keep the compiler happy.
 154         #
 155         # However, for negative values, the to_s(16) hex conversion method does
 156         # not strip the &quot;-&quot; sign resulting in a meaningless &quot;0x-...&quot; valueStr.
 157         # To workaround this, we simply don&#39;t encode negative numbers as hex.
 158 
 159         valueStr = (value &lt; 0) ? &quot;#{value}&quot; : &quot;0x#{value.to_s(16)}&quot;
 160 
 161         case type
 162         when :int8;    &quot;int8_t(#{valueStr})&quot;
 163         when :int16;   &quot;int16_t(#{valueStr})&quot;
 164         when :int32;   &quot;int32_t(#{valueStr})&quot;
 165         when :int64;   &quot;int64_t(#{valueStr})&quot;
 166         when :intptr;  &quot;intptr_t(#{valueStr})&quot;
 167         when :uint8;   &quot;uint8_t(#{valueStr})&quot;
 168         when :uint32;  &quot;uint32_t(#{valueStr})&quot;
 169         when :uint64;  &quot;uint64_t(#{valueStr})&quot;
 170         when :uintptr; &quot;uintptr_t(#{valueStr})&quot;
 171         else
 172             raise &quot;Not implemented immediate of type: #{type}&quot; 
 173         end
 174     end
 175 end
 176 
 177 class Address
 178     def clDump
 179         &quot;[#{base.clDump}, #{offset.value}]&quot;
 180     end
 181     def clLValue(type=:intptr)
 182         clValue(type)
 183     end
 184     def clValue(type=:intptr)
 185         case type
 186         when :int8;         int8MemRef
 187         when :int16;        int16MemRef
 188         when :int32;        int32MemRef
 189         when :int64;        int64MemRef
 190         when :intptr;       intptrMemRef
 191         when :uint8;        uint8MemRef
 192         when :uint32;       uint32MemRef
 193         when :uint64;       uint64MemRef
 194         when :uintptr;      uintptrMemRef
 195         when :opcode;       opcodeMemRef
 196         when :nativeFunc;   nativeFuncMemRef
 197         else
 198             raise &quot;Unexpected Address type: #{type}&quot;
 199         end
 200     end
 201     def pointerExpr
 202         if  offset.value == 0
 203             &quot;#{base.clValue(:int8Ptr)}&quot;
 204         elsif offset.value &gt; 0
 205             &quot;#{base.clValue(:int8Ptr)} + #{offset.value}&quot;
 206         else
 207             &quot;#{base.clValue(:int8Ptr)} - #{-offset.value}&quot;
 208         end
 209     end
 210     def int8MemRef
 211         &quot;*CAST&lt;int8_t*&gt;(#{pointerExpr})&quot;
 212     end
 213     def int16MemRef
 214         &quot;*CAST&lt;int16_t*&gt;(#{pointerExpr})&quot;
 215     end
 216     def int32MemRef
 217         &quot;*CAST&lt;int32_t*&gt;(#{pointerExpr})&quot;
 218     end
 219     def int64MemRef
 220         &quot;*CAST&lt;int64_t*&gt;(#{pointerExpr})&quot;
 221     end
 222     def intptrMemRef
 223         &quot;*CAST&lt;intptr_t*&gt;(#{pointerExpr})&quot;
 224     end
 225     def uint8MemRef
 226         &quot;*CAST&lt;uint8_t*&gt;(#{pointerExpr})&quot;
 227     end
 228     def uint16MemRef
 229         &quot;*CAST&lt;uint16_t*&gt;(#{pointerExpr})&quot;
 230     end
 231     def uint32MemRef
 232         &quot;*CAST&lt;uint32_t*&gt;(#{pointerExpr})&quot;
 233     end
 234     def uint64MemRef
 235         &quot;*CAST&lt;uint64_t*&gt;(#{pointerExpr})&quot;
 236     end
 237     def uintptrMemRef
 238         &quot;*CAST&lt;uintptr_t*&gt;(#{pointerExpr})&quot;
 239     end
 240     def nativeFuncMemRef
 241         &quot;*CAST&lt;NativeFunction*&gt;(#{pointerExpr})&quot;
 242     end
 243     def opcodeMemRef
 244         &quot;*CAST&lt;Opcode*&gt;(#{pointerExpr})&quot;
 245     end
 246     def dblMemRef
 247         &quot;*CAST&lt;double*&gt;(#{pointerExpr})&quot;
 248     end
 249 end
 250 
 251 class BaseIndex
 252     def clDump
 253         &quot;[#{base.clDump}, #{offset.clDump}, #{index.clDump} &lt;&lt; #{scaleShift}]&quot;
 254     end
 255     def clLValue(type=:intptr)
 256         clValue(type)
 257     end
 258     def clValue(type=:intptr)
 259         case type
 260         when :int8;       int8MemRef
 261         when :int32;      int32MemRef
 262         when :int64;      int64MemRef
 263         when :intptr;     intptrMemRef
 264         when :uint8;      uint8MemRef
 265         when :uint32;     uint32MemRef
 266         when :uint64;     uint64MemRef
 267         when :uintptr;    uintptrMemRef
 268         when :opcode;     opcodeMemRef
 269         else
 270             raise &quot;Unexpected BaseIndex type: #{type}&quot;
 271         end
 272     end
 273     def pointerExpr
 274         if offset.value == 0
 275             &quot;#{base.clValue(:int8Ptr)} + (#{index.clValue} &lt;&lt; #{scaleShift})&quot;
 276         else
 277             &quot;#{base.clValue(:int8Ptr)} + (#{index.clValue} &lt;&lt; #{scaleShift}) + #{offset.clValue}&quot;
 278         end
 279     end
 280     def int8MemRef
 281         &quot;*CAST&lt;int8_t*&gt;(#{pointerExpr})&quot;
 282     end
 283     def int16MemRef
 284         &quot;*CAST&lt;int16_t*&gt;(#{pointerExpr})&quot;
 285     end
 286     def int32MemRef
 287         &quot;*CAST&lt;int32_t*&gt;(#{pointerExpr})&quot;
 288     end
 289     def int64MemRef
 290         &quot;*CAST&lt;int64_t*&gt;(#{pointerExpr})&quot;
 291     end
 292     def intptrMemRef
 293         &quot;*CAST&lt;intptr_t*&gt;(#{pointerExpr})&quot;
 294     end
 295     def uint8MemRef
 296         &quot;*CAST&lt;uint8_t*&gt;(#{pointerExpr})&quot;
 297     end
 298     def uint16MemRef
 299         &quot;*CAST&lt;uint16_t*&gt;(#{pointerExpr})&quot;
 300     end
 301     def uint32MemRef
 302         &quot;*CAST&lt;uint32_t*&gt;(#{pointerExpr})&quot;
 303     end
 304     def uint64MemRef
 305         &quot;*CAST&lt;uint64_t*&gt;(#{pointerExpr})&quot;
 306     end
 307     def uintptrMemRef
 308         &quot;*CAST&lt;uintptr_t*&gt;(#{pointerExpr})&quot;
 309     end
 310     def opcodeMemRef
 311         &quot;*CAST&lt;Opcode*&gt;(#{pointerExpr})&quot;
 312     end
 313     def dblMemRef
 314         &quot;*CAST&lt;double*&gt;(#{pointerExpr})&quot;
 315     end
 316 end
 317 
 318 class AbsoluteAddress
 319     def clDump
 320         &quot;#{codeOriginString}&quot;
 321     end
 322     def clLValue(type=:intptr)
 323         clValue(type)
 324     end
 325     def clValue
 326         clDump
 327     end
 328 end
 329 
 330 class LabelReference
 331     def intptrMemRef
 332         &quot;*CAST&lt;intptr_t*&gt;(&amp;#{cLabel})&quot;
 333     end
 334     def cloopEmitLea(destination, type)
 335         $asm.putc &quot;#{destination.clLValue(:voidPtr)} = CAST&lt;void*&gt;(&amp;#{cLabel});&quot;
 336     end
 337 end
 338 
 339 
 340 #
 341 # Lea support.
 342 #
 343 
 344 class Address
 345     def cloopEmitLea(destination, type)
 346         if destination == base
 347             $asm.putc &quot;#{destination.clLValue(:int8Ptr)} += #{offset.clValue(type)};&quot;
 348         else
 349             $asm.putc &quot;#{destination.clLValue(:int8Ptr)} = #{base.clValue(:int8Ptr)} + #{offset.clValue(type)};&quot;
 350         end
 351     end
 352 end
 353 
 354 class BaseIndex
 355     def cloopEmitLea(destination, type)
 356         raise &quot;Malformed BaseIndex, offset should be zero at #{codeOriginString}&quot; unless offset.value == 0
 357         $asm.putc &quot;#{destination.clLValue(:int8Ptr)} = #{base.clValue(:int8Ptr)} + (#{index.clValue} &lt;&lt; #{scaleShift});&quot;
 358     end
 359 end
 360 
 361 #
 362 # Actual lowering code follows.
 363 #
 364 
 365 class Sequence
 366     def getModifiedListC_LOOP
 367         myList = @list
 368         
 369         # Verify that we will only see instructions and labels.
 370         myList.each {
 371             | node |
 372             unless node.is_a? Instruction or
 373                     node.is_a? Label or
 374                     node.is_a? LocalLabel or
 375                     node.is_a? Skip
 376                 raise &quot;Unexpected #{node.inspect} at #{node.codeOrigin}&quot; 
 377             end
 378         }
 379         
 380         return myList
 381     end
 382 end
 383 
 384 def clOperands(operands)
 385     operands.map{|v| v.clDump}.join(&quot;, &quot;)
 386 end
 387 
 388 
 389 def cloopEmitOperation(operands, type, operator)
 390     raise unless type == :intptr || type == :uintptr || type == :int32 || type == :uint32 || \
 391         type == :int64 || type == :uint64 || type == :double || type == :int16
 392     if operands.size == 3
 393         op1 = operands[0]
 394         op2 = operands[1]
 395         dst = operands[2]
 396     else
 397         raise unless operands.size == 2
 398         op1 = operands[1]
 399         op2 = operands[0]
 400         dst = operands[1]
 401     end
 402     raise unless not dst.is_a? Immediate
 403     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 404         truncationHeader = &quot;(uint32_t)(&quot;
 405         truncationFooter = &quot;)&quot;
 406     elsif dst.is_a? RegisterID and (type == :int16)
 407         truncationHeader = &quot;(uint16_t)(&quot;
 408         truncationFooter = &quot;)&quot;
 409     else
 410         truncationHeader = &quot;&quot;
 411         truncationFooter = &quot;&quot;
 412     end
 413     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{op1.clValue(type)} #{operator} #{op2.clValue(type)}#{truncationFooter};&quot;
 414 end
 415 
 416 def cloopEmitShiftOperation(operands, type, operator)
 417     raise unless type == :intptr || type == :uintptr || type == :int32 || type == :uint32 || type == :int64 || type == :uint64
 418     if operands.size == 3
 419         op1 = operands[0]
 420         op2 = operands[1]
 421         dst = operands[2]
 422     else
 423         op1 = operands[1]
 424         op2 = operands[0]
 425         dst = operands[1]
 426     end
 427     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 428         truncationHeader = &quot;(uint32_t)(&quot;
 429         truncationFooter = &quot;)&quot;
 430     else
 431         truncationHeader = &quot;&quot;
 432         truncationFooter = &quot;&quot;
 433     end
 434     shiftMask = &quot;((sizeof(uintptr_t) == 8) ? 0x3f : 0x1f)&quot; if type == :intptr || type == :uintptr
 435     shiftMask = &quot;0x3f&quot; if type == :int64 || type == :uint64
 436     shiftMask = &quot;0x1f&quot; if type == :int32 || type == :uint32
 437     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{operands[1].clValue(type)} #{operator} (#{operands[0].clValue(:intptr)} &amp; #{shiftMask})#{truncationFooter};&quot;
 438 end
 439 
 440 def cloopEmitUnaryOperation(operands, type, operator)
 441     raise unless type == :intptr || type == :uintptr || type == :int32 || type == :uint32 || type == :int64 || type == :uint64
 442     raise unless operands.size == 1
 443     raise unless not operands[0].is_a? Immediate
 444     op = operands[0]
 445     dst = operands[0]
 446     if dst.is_a? RegisterID and (type == :int32 or type == :uint32)
 447         truncationHeader = &quot;(uint32_t)(&quot;
 448         truncationFooter = &quot;)&quot;
 449     else
 450         truncationHeader = &quot;&quot;
 451         truncationFooter = &quot;&quot;
 452     end
 453     $asm.putc &quot;#{dst.clLValue(type)} = #{truncationHeader}#{operator}#{op.clValue(type)}#{truncationFooter};&quot;
 454 end
 455 
 456 def cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, condition)
 457     $asm.putc &quot;if (std::isnan(#{operands[0].clValue(:double)}) || std::isnan(#{operands[1].clValue(:double)})&quot;
 458     $asm.putc &quot;    || (#{operands[0].clValue(:double)} #{condition} #{operands[1].clValue(:double)}))&quot;
 459     $asm.putc &quot;    goto #{operands[2].cLabel};&quot;
 460 end
 461 
 462 
 463 def cloopEmitCompareAndSet(operands, type, comparator)
 464     # The result is a boolean.  Hence, it doesn&#39;t need to be based on the type
 465     # of the arguments being compared.
 466     $asm.putc &quot;#{operands[2].clLValue(type)} = (#{operands[0].clValue(type)} #{comparator} #{operands[1].clValue(type)});&quot;
 467 end
 468 
 469 
 470 def cloopEmitCompareAndBranch(operands, type, comparator)
 471     $asm.putc &quot;if (#{operands[0].clValue(type)} #{comparator} #{operands[1].clValue(type)})&quot;
 472     $asm.putc &quot;    goto #{operands[2].cLabel};&quot;
 473 end
 474 
 475 
 476 # conditionTest should contain a string that provides a comparator and a RHS
 477 # value e.g. &quot;&lt; 0&quot;.
 478 def cloopGenerateConditionExpression(operands, type, conditionTest)
 479     op1 = operands[0].clValue(type)
 480 
 481     # The operands must consist of 2 or 3 values.
 482     case operands.size
 483     when 2 # Just test op1 against the conditionTest.
 484         lhs = op1
 485     when 3 # Mask op1 with op2 before testing against the conditionTest.
 486         lhs = &quot;(#{op1} &amp; #{operands[1].clValue(type)})&quot;
 487     else
 488         raise &quot;Expected 2 or 3 operands but got #{operands.size} at #{codeOriginString}&quot;
 489     end
 490     
 491     &quot;#{lhs} #{conditionTest}&quot;
 492 end
 493 
 494 # conditionTest should contain a string that provides a comparator and a RHS
 495 # value e.g. &quot;&lt; 0&quot;.
 496 def cloopEmitTestAndBranchIf(operands, type, conditionTest, branchTarget)
 497     conditionExpr = cloopGenerateConditionExpression(operands, type, conditionTest)
 498     $asm.putc &quot;if (#{conditionExpr})&quot;
 499     $asm.putc &quot;    goto #{branchTarget};&quot;
 500 end
 501 
 502 def cloopEmitTestSet(operands, type, conditionTest)
 503     # The result is a boolean condition.  Hence, the result type is always an
 504     # int.  The passed in type is only used for the values being tested in
 505     # the condition test.
 506     conditionExpr = cloopGenerateConditionExpression(operands, type, conditionTest)
 507     $asm.putc &quot;#{operands[-1].clLValue} = (#{conditionExpr});&quot;
 508 end
 509 
 510 def cloopEmitOpAndBranch(operands, operator, type, conditionTest)
 511     case type
 512     when :intptr; tempType = &quot;intptr_t&quot;
 513     when :int32; tempType = &quot;int32_t&quot;
 514     when :int64; tempType = &quot;int64_t&quot;
 515     else
 516         raise &quot;Unimplemented type&quot;
 517     end
 518 
 519     $asm.putc &quot;{&quot;
 520     $asm.putc &quot;    #{tempType} temp = #{operands[1].clValue(type)} #{operator} #{operands[0].clValue(type)};&quot;
 521     $asm.putc &quot;    #{operands[1].clLValue(type)} = temp;&quot;
 522     $asm.putc &quot;    if (temp #{conditionTest})&quot;
 523     $asm.putc &quot;        goto  #{operands[2].cLabel};&quot;
 524     $asm.putc &quot;}&quot;
 525 end
 526 
 527 def cloopEmitOpAndBranchIfOverflow(operands, operator, type)
 528     case type
 529     when :int32
 530         tempType = &quot;int32_t&quot;
 531         truncationHeader = &quot;(uint32_t)(&quot;
 532         truncationFooter = &quot;)&quot;
 533     else
 534         raise &quot;Unimplemented type&quot;
 535     end
 536 
 537     $asm.putc &quot;{&quot;
 538 
 539     # Emit the overflow test based on the operands and the type:
 540     case operator
 541     when &quot;+&quot;; operation = &quot;add&quot;
 542     when &quot;-&quot;; operation = &quot;sub&quot;
 543     when &quot;*&quot;; operation = &quot;multiply&quot;
 544     else
 545         raise &quot;Unimplemented opeartor&quot;
 546     end
 547 
 548     $asm.putc &quot;    #{tempType} result;&quot;
 549     $asm.putc &quot;    bool success = WTF::ArithmeticOperations&lt;#{tempType}, #{tempType}, #{tempType}&gt;::#{operation}(#{operands[1].clValue(type)}, #{operands[0].clValue(type)}, result);&quot;
 550     $asm.putc &quot;    #{operands[1].clLValue(type)} = #{truncationHeader}result#{truncationFooter};&quot;
 551     $asm.putc &quot;    if (!success)&quot;
 552     $asm.putc &quot;        goto #{operands[2].cLabel};&quot;
 553     $asm.putc &quot;}&quot;
 554 end
 555 
 556 # operands: callTarget, currentFrame, currentPC
 557 def cloopEmitCallSlowPath(operands)
 558     $asm.putc &quot;{&quot;
 559     $asm.putc &quot;    cloopStack.setCurrentStackPointer(sp.vp());&quot;
 560     $asm.putc &quot;    SlowPathReturnType result = #{operands[0].cLabel}(#{operands[1].clDump}, #{operands[2].clDump});&quot;
 561     $asm.putc &quot;    decodeResult(result, t0, t1);&quot;
 562     $asm.putc &quot;}&quot;
 563 end
 564 
 565 def cloopEmitCallSlowPathVoid(operands)
 566     $asm.putc &quot;cloopStack.setCurrentStackPointer(sp.vp());&quot;
 567     $asm.putc &quot;#{operands[0].cLabel}(#{operands[1].clDump}, #{operands[2].clDump});&quot;
 568 end
 569 
 570 class Instruction
 571     def lowerC_LOOP
 572         case opcode
 573         when &quot;addi&quot;
 574             cloopEmitOperation(operands, :int32, &quot;+&quot;)
 575         when &quot;addq&quot;
 576             cloopEmitOperation(operands, :int64, &quot;+&quot;)
 577         when &quot;addp&quot;
 578             cloopEmitOperation(operands, :intptr, &quot;+&quot;)
 579 
 580         when &quot;andi&quot;
 581             cloopEmitOperation(operands, :int32, &quot;&amp;&quot;)
 582         when &quot;andq&quot;
 583             cloopEmitOperation(operands, :int64, &quot;&amp;&quot;)
 584         when &quot;andp&quot;
 585             cloopEmitOperation(operands, :intptr, &quot;&amp;&quot;)
 586 
 587         when &quot;ori&quot;
 588             cloopEmitOperation(operands, :int32, &quot;|&quot;)
 589         when &quot;orq&quot;
 590             cloopEmitOperation(operands, :int64, &quot;|&quot;)
 591         when &quot;orp&quot;
 592             cloopEmitOperation(operands, :intptr, &quot;|&quot;)
 593         when &quot;orh&quot;
 594             cloopEmitOperation(operands, :int16, &quot;|&quot;)
 595 
 596         when &quot;xori&quot;
 597             cloopEmitOperation(operands, :int32, &quot;^&quot;)
 598         when &quot;xorq&quot;
 599             cloopEmitOperation(operands, :int64, &quot;^&quot;)
 600         when &quot;xorp&quot;
 601             cloopEmitOperation(operands, :intptr, &quot;^&quot;)
 602 
 603         when &quot;lshifti&quot;
 604             cloopEmitShiftOperation(operands, :int32, &quot;&lt;&lt;&quot;)
 605         when &quot;lshiftq&quot;
 606             cloopEmitShiftOperation(operands, :int64, &quot;&lt;&lt;&quot;)
 607         when &quot;lshiftp&quot;
 608             cloopEmitShiftOperation(operands, :intptr, &quot;&lt;&lt;&quot;)
 609 
 610         when &quot;rshifti&quot;
 611             cloopEmitShiftOperation(operands, :int32, &quot;&gt;&gt;&quot;)
 612         when &quot;rshiftq&quot;
 613             cloopEmitShiftOperation(operands, :int64, &quot;&gt;&gt;&quot;)
 614         when &quot;rshiftp&quot;
 615             cloopEmitShiftOperation(operands, :intptr, &quot;&gt;&gt;&quot;)
 616 
 617         when &quot;urshifti&quot;
 618             cloopEmitShiftOperation(operands, :uint32, &quot;&gt;&gt;&quot;)
 619         when &quot;urshiftq&quot;
 620             cloopEmitShiftOperation(operands, :uint64, &quot;&gt;&gt;&quot;)
 621         when &quot;urshiftp&quot;
 622             cloopEmitShiftOperation(operands, :uintptr, &quot;&gt;&gt;&quot;)
 623 
 624         when &quot;muli&quot;
 625             cloopEmitOperation(operands, :int32, &quot;*&quot;)
 626         when &quot;mulq&quot;
 627             cloopEmitOperation(operands, :int64, &quot;*&quot;)
 628         when &quot;mulp&quot;
 629             cloopEmitOperation(operands, :intptr, &quot;*&quot;)
 630 
 631         when &quot;subi&quot;
 632             cloopEmitOperation(operands, :int32, &quot;-&quot;)
 633         when &quot;subq&quot;
 634             cloopEmitOperation(operands, :int64, &quot;-&quot;)
 635         when &quot;subp&quot;
 636             cloopEmitOperation(operands, :intptr, &quot;-&quot;)
 637 
 638         when &quot;negi&quot;
 639             cloopEmitUnaryOperation(operands, :int32, &quot;-&quot;)
 640         when &quot;negq&quot;
 641             cloopEmitUnaryOperation(operands, :int64, &quot;-&quot;)
 642         when &quot;negp&quot;
 643             cloopEmitUnaryOperation(operands, :intptr, &quot;-&quot;)
 644 
 645         when &quot;noti&quot;
 646             cloopEmitUnaryOperation(operands, :int32, &quot;~&quot;)
 647 
 648         when &quot;loadi&quot;
 649             $asm.putc &quot;#{operands[1].clLValue(:uint32)} = #{operands[0].uint32MemRef};&quot;
 650             # There&#39;s no need to call clearHighWord() here because the above will
 651             # automatically take care of 0 extension.
 652         when &quot;loadis&quot;
 653             $asm.putc &quot;#{operands[1].clLValue(:int32)} = #{operands[0].int32MemRef};&quot;
 654         when &quot;loadq&quot;
 655             $asm.putc &quot;#{operands[1].clLValue(:int64)} = #{operands[0].int64MemRef};&quot;
 656         when &quot;loadp&quot;
 657             $asm.putc &quot;#{operands[1].clLValue} = #{operands[0].intptrMemRef};&quot;
 658         when &quot;storei&quot;
 659             $asm.putc &quot;#{operands[1].int32MemRef} = #{operands[0].clValue(:int32)};&quot;
 660         when &quot;storeq&quot;
 661             $asm.putc &quot;#{operands[1].int64MemRef} = #{operands[0].clValue(:int64)};&quot;
 662         when &quot;storep&quot;
 663             $asm.putc &quot;#{operands[1].intptrMemRef} = #{operands[0].clValue(:intptr)};&quot;
 664         when &quot;loadb&quot;
 665             $asm.putc &quot;#{operands[1].clLValue(:intptr)} = #{operands[0].uint8MemRef};&quot;
 666         when &quot;loadbsi&quot;
 667             $asm.putc &quot;#{operands[1].clLValue(:uint32)} = (uint32_t)((int32_t)#{operands[0].int8MemRef});&quot;
 668         when &quot;loadbsq&quot;
 669             $asm.putc &quot;#{operands[1].clLValue(:uint64)} = (int64_t)#{operands[0].int8MemRef};&quot;
 670         when &quot;storeb&quot;
 671             $asm.putc &quot;#{operands[1].uint8MemRef} = #{operands[0].clValue(:int8)};&quot;
 672         when &quot;loadh&quot;
 673             $asm.putc &quot;#{operands[1].clLValue(:intptr)} = #{operands[0].uint16MemRef};&quot;
 674         when &quot;loadhsi&quot;
 675             $asm.putc &quot;#{operands[1].clLValue(:uint32)} = (uint32_t)((int32_t)#{operands[0].int16MemRef});&quot;
 676         when &quot;loadhsq&quot;
 677             $asm.putc &quot;#{operands[1].clLValue(:uint64)} = (int64_t)#{operands[0].int16MemRef};&quot;
 678         when &quot;storeh&quot;
 679             $asm.putc &quot;*#{operands[1].uint16MemRef} = #{operands[0].clValue(:int16)};&quot;
 680         when &quot;loadd&quot;
 681             $asm.putc &quot;#{operands[1].clLValue(:double)} = #{operands[0].dblMemRef};&quot;
 682         when &quot;stored&quot;
 683             $asm.putc &quot;#{operands[1].dblMemRef} = #{operands[0].clValue(:double)};&quot;
 684 
 685         when &quot;addd&quot;
 686             cloopEmitOperation(operands, :double, &quot;+&quot;)
 687         when &quot;divd&quot;
 688             cloopEmitOperation(operands, :double, &quot;/&quot;)
 689         when &quot;subd&quot;
 690             cloopEmitOperation(operands, :double, &quot;-&quot;)
 691         when &quot;muld&quot;
 692             cloopEmitOperation(operands, :double, &quot;*&quot;)
 693 
 694         # Convert an int value to its double equivalent, and store it in a double register.
 695         when &quot;ci2ds&quot;
 696             $asm.putc &quot;#{operands[1].clLValue(:double)} = (double)#{operands[0].clValue(:int32)}; // ci2ds&quot;
 697 
 698         when &quot;bdeq&quot;
 699             cloopEmitCompareAndBranch(operands, :double, &quot;==&quot;)
 700         when &quot;bdneq&quot;
 701             cloopEmitCompareAndBranch(operands, :double, &quot;!=&quot;)
 702         when &quot;bdgt&quot;
 703             cloopEmitCompareAndBranch(operands, :double, &quot;&gt;&quot;);
 704         when &quot;bdgteq&quot;
 705             cloopEmitCompareAndBranch(operands, :double, &quot;&gt;=&quot;);
 706         when &quot;bdlt&quot;
 707             cloopEmitCompareAndBranch(operands, :double, &quot;&lt;&quot;);
 708         when &quot;bdlteq&quot;
 709             cloopEmitCompareAndBranch(operands, :double, &quot;&lt;=&quot;);
 710 
 711         when &quot;bdequn&quot;
 712             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;==&quot;)
 713         when &quot;bdnequn&quot;
 714             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;!=&quot;)
 715         when &quot;bdgtun&quot;
 716             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&gt;&quot;)
 717         when &quot;bdgtequn&quot;
 718             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&gt;=&quot;)
 719         when &quot;bdltun&quot;
 720             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&lt;&quot;)
 721         when &quot;bdltequn&quot;
 722             cloopEmitCompareDoubleWithNaNCheckAndBranch(operands, &quot;&lt;=&quot;)
 723 
 724         when &quot;td2i&quot;
 725             $asm.putc &quot;#{operands[1].clLValue(:intptr)} = (uint32_t)(intptr_t)#{operands[0].clValue(:double)}; // td2i&quot;
 726 
 727         when &quot;bcd2i&quot;  # operands: srcDbl dstInt slowPath
 728             $asm.putc &quot;{ // bcd2i&quot;
 729             $asm.putc &quot;    double d = #{operands[0].clValue(:double)};&quot;
 730             $asm.putc &quot;    const int32_t asInt32 = int32_t(d);&quot;
 731             $asm.putc &quot;    if (asInt32 != d || (!asInt32 &amp;&amp; std::signbit(d))) // true for -0.0&quot;
 732             $asm.putc &quot;        goto  #{operands[2].cLabel};&quot;
 733             $asm.putc &quot;    #{operands[1].clLValue} = (uint32_t)asInt32;&quot;
 734             $asm.putc &quot;}&quot;
 735 
 736         when &quot;move&quot;
 737             $asm.putc &quot;#{operands[1].clLValue(:intptr)} = #{operands[0].clValue(:intptr)};&quot;
 738         when &quot;sxi2q&quot;
 739             $asm.putc &quot;#{operands[1].clLValue(:int64)} = #{operands[0].clValue(:int32)};&quot;
 740         when &quot;zxi2q&quot;
 741             $asm.putc &quot;#{operands[1].clLValue(:uint64)} = #{operands[0].clValue(:uint32)};&quot;
 742         when &quot;nop&quot;
 743             $asm.putc &quot;// nop&quot;
 744         when &quot;bbeq&quot;
 745             cloopEmitCompareAndBranch(operands, :int8, &quot;==&quot;)
 746         when &quot;bieq&quot;
 747             cloopEmitCompareAndBranch(operands, :int32, &quot;==&quot;)
 748         when &quot;bqeq&quot;
 749             cloopEmitCompareAndBranch(operands, :int64, &quot;==&quot;)
 750         when &quot;bpeq&quot;
 751             cloopEmitCompareAndBranch(operands, :intptr, &quot;==&quot;)
 752 
 753         when &quot;bbneq&quot;
 754             cloopEmitCompareAndBranch(operands, :int8, &quot;!=&quot;)
 755         when &quot;bineq&quot;
 756             cloopEmitCompareAndBranch(operands, :int32, &quot;!=&quot;)
 757         when &quot;bqneq&quot;
 758             cloopEmitCompareAndBranch(operands, :int64, &quot;!=&quot;)
 759         when &quot;bpneq&quot;
 760             cloopEmitCompareAndBranch(operands, :intptr, &quot;!=&quot;)
 761 
 762         when &quot;bba&quot;
 763             cloopEmitCompareAndBranch(operands, :uint8, &quot;&gt;&quot;)
 764         when &quot;bia&quot;
 765             cloopEmitCompareAndBranch(operands, :uint32, &quot;&gt;&quot;)
 766         when &quot;bqa&quot;
 767             cloopEmitCompareAndBranch(operands, :uint64, &quot;&gt;&quot;)
 768         when &quot;bpa&quot;
 769             cloopEmitCompareAndBranch(operands, :uintptr, &quot;&gt;&quot;)
 770 
 771         when &quot;bbaeq&quot;
 772             cloopEmitCompareAndBranch(operands, :uint8, &quot;&gt;=&quot;)
 773         when &quot;biaeq&quot;
 774             cloopEmitCompareAndBranch(operands, :uint32, &quot;&gt;=&quot;)
 775         when &quot;bqaeq&quot;
 776             cloopEmitCompareAndBranch(operands, :uint64, &quot;&gt;=&quot;)
 777         when &quot;bpaeq&quot;
 778             cloopEmitCompareAndBranch(operands, :uintptr, &quot;&gt;=&quot;)
 779 
 780         when &quot;bbb&quot;
 781             cloopEmitCompareAndBranch(operands, :uint8, &quot;&lt;&quot;)
 782         when &quot;bib&quot;
 783             cloopEmitCompareAndBranch(operands, :uint32, &quot;&lt;&quot;)
 784         when &quot;bqb&quot;
 785             cloopEmitCompareAndBranch(operands, :uint64, &quot;&lt;&quot;)
 786         when &quot;bpb&quot;
 787             cloopEmitCompareAndBranch(operands, :uintptr, &quot;&lt;&quot;)
 788 
 789         when &quot;bbbeq&quot;
 790             cloopEmitCompareAndBranch(operands, :uint8, &quot;&lt;=&quot;)
 791         when &quot;bibeq&quot;
 792             cloopEmitCompareAndBranch(operands, :uint32, &quot;&lt;=&quot;)
 793         when &quot;bqbeq&quot;
 794             cloopEmitCompareAndBranch(operands, :uint64, &quot;&lt;=&quot;)
 795         when &quot;bpbeq&quot;
 796             cloopEmitCompareAndBranch(operands, :uintptr, &quot;&lt;=&quot;)
 797 
 798         when &quot;bbgt&quot;
 799             cloopEmitCompareAndBranch(operands, :int8, &quot;&gt;&quot;)
 800         when &quot;bigt&quot;
 801             cloopEmitCompareAndBranch(operands, :int32, &quot;&gt;&quot;)
 802         when &quot;bqgt&quot;
 803             cloopEmitCompareAndBranch(operands, :int64, &quot;&gt;&quot;)
 804         when &quot;bpgt&quot;
 805             cloopEmitCompareAndBranch(operands, :intptr, &quot;&gt;&quot;)
 806 
 807         when &quot;bbgteq&quot;
 808             cloopEmitCompareAndBranch(operands, :int8, &quot;&gt;=&quot;)
 809         when &quot;bigteq&quot;
 810             cloopEmitCompareAndBranch(operands, :int32, &quot;&gt;=&quot;)
 811         when &quot;bqgteq&quot;
 812             cloopEmitCompareAndBranch(operands, :int64, &quot;&gt;=&quot;)
 813         when &quot;bpgteq&quot;
 814             cloopEmitCompareAndBranch(operands, :intptr, &quot;&gt;=&quot;)
 815 
 816         when &quot;bblt&quot;
 817             cloopEmitCompareAndBranch(operands, :int8, &quot;&lt;&quot;)
 818         when &quot;bilt&quot;
 819             cloopEmitCompareAndBranch(operands, :int32, &quot;&lt;&quot;)
 820         when &quot;bqlt&quot;
 821             cloopEmitCompareAndBranch(operands, :int64, &quot;&lt;&quot;)
 822         when &quot;bplt&quot;
 823             cloopEmitCompareAndBranch(operands, :intptr, &quot;&lt;&quot;)
 824 
 825         when &quot;bblteq&quot;
 826             cloopEmitCompareAndBranch(operands, :int8, &quot;&lt;=&quot;)
 827         when &quot;bilteq&quot;
 828             cloopEmitCompareAndBranch(operands, :int32, &quot;&lt;=&quot;)
 829         when &quot;bqlteq&quot;
 830             cloopEmitCompareAndBranch(operands, :int64, &quot;&lt;=&quot;)
 831         when &quot;bplteq&quot;
 832             cloopEmitCompareAndBranch(operands, :intptr, &quot;&lt;=&quot;)
 833 
 834         when &quot;btbz&quot;
 835             cloopEmitTestAndBranchIf(operands, :int8, &quot;== 0&quot;, operands[-1].cLabel)
 836         when &quot;btiz&quot;
 837             cloopEmitTestAndBranchIf(operands, :int32, &quot;== 0&quot;, operands[-1].cLabel)
 838         when &quot;btqz&quot;
 839             cloopEmitTestAndBranchIf(operands, :int64, &quot;== 0&quot;, operands[-1].cLabel)
 840         when &quot;btpz&quot;
 841             cloopEmitTestAndBranchIf(operands, :intptr, &quot;== 0&quot;, operands[-1].cLabel)
 842 
 843         when &quot;btbnz&quot;
 844             cloopEmitTestAndBranchIf(operands, :int8, &quot;!= 0&quot;, operands[-1].cLabel)
 845         when &quot;btinz&quot;
 846             cloopEmitTestAndBranchIf(operands, :int32, &quot;!= 0&quot;, operands[-1].cLabel)
 847         when &quot;btqnz&quot;
 848             cloopEmitTestAndBranchIf(operands, :int64, &quot;!= 0&quot;, operands[-1].cLabel)
 849         when &quot;btpnz&quot;
 850             cloopEmitTestAndBranchIf(operands, :intptr, &quot;!= 0&quot;, operands[-1].cLabel)
 851 
 852         when &quot;btbs&quot;
 853             cloopEmitTestAndBranchIf(operands, :int8, &quot;&lt; 0&quot;, operands[-1].cLabel)
 854         when &quot;btis&quot;
 855             cloopEmitTestAndBranchIf(operands, :int32, &quot;&lt; 0&quot;, operands[-1].cLabel)
 856         when &quot;btqs&quot;
 857             cloopEmitTestAndBranchIf(operands, :int64, &quot;&lt; 0&quot;, operands[-1].cLabel)
 858         when &quot;btps&quot;
 859             cloopEmitTestAndBranchIf(operands, :intptr, &quot;&lt; 0&quot;, operands[-1].cLabel)
 860 
 861         # For jmp, we do not want to assume that we have COMPUTED_GOTO support.
 862         # Fortunately, the only times we should ever encounter indirect jmps is
 863         # when the jmp target is a CLoop opcode (by design).
 864         #
 865         # Hence, we check if the jmp target is a known label reference. If so,
 866         # we can emit a goto directly. If it is not a known target, then we set
 867         # the target in the opcode, and dispatch to it via whatever dispatch
 868         # mechanism is in used.
 869         when &quot;jmp&quot;
 870             if operands[0].is_a? LocalLabelReference or operands[0].is_a? LabelReference
 871                 # Handles jumps local or global labels.
 872                 $asm.putc &quot;goto #{operands[0].cLabel};&quot;
 873             else
 874                 # Handles jumps to some computed target.
 875                 # NOTE: must be an opcode handler or a llint glue helper.
 876                 $asm.putc &quot;opcode = #{operands[0].clValue(:opcode)};&quot;
 877                 $asm.putc &quot;DISPATCH_OPCODE();&quot;
 878             end
 879 
 880         when &quot;call&quot;
 881             $asm.putc &quot;CRASH(); // generic call instruction not supported by design!&quot;
 882         when &quot;break&quot;
 883             $asm.putc &quot;CRASH(); // break instruction not implemented.&quot;
 884         when &quot;ret&quot;
 885             $asm.putc &quot;opcode = lr.opcode();&quot;
 886             $asm.putc &quot;DISPATCH_OPCODE();&quot;
 887 
 888         when &quot;cbeq&quot;
 889             cloopEmitCompareAndSet(operands, :uint8, &quot;==&quot;)
 890         when &quot;cieq&quot;
 891             cloopEmitCompareAndSet(operands, :uint32, &quot;==&quot;)
 892         when &quot;cqeq&quot;
 893             cloopEmitCompareAndSet(operands, :uint64, &quot;==&quot;)
 894         when &quot;cpeq&quot;
 895             cloopEmitCompareAndSet(operands, :uintptr, &quot;==&quot;)
 896 
 897         when &quot;cbneq&quot;
 898             cloopEmitCompareAndSet(operands, :uint8, &quot;!=&quot;)
 899         when &quot;cineq&quot;
 900             cloopEmitCompareAndSet(operands, :uint32, &quot;!=&quot;)
 901         when &quot;cqneq&quot;
 902             cloopEmitCompareAndSet(operands, :uint64, &quot;!=&quot;)
 903         when &quot;cpneq&quot;
 904             cloopEmitCompareAndSet(operands, :uintptr, &quot;!=&quot;)
 905 
 906         when &quot;cba&quot;
 907             cloopEmitCompareAndSet(operands, :uint8, &quot;&gt;&quot;)
 908         when &quot;cia&quot;
 909             cloopEmitCompareAndSet(operands, :uint32, &quot;&gt;&quot;)
 910         when &quot;cqa&quot;
 911             cloopEmitCompareAndSet(operands, :uint64, &quot;&gt;&quot;)
 912         when &quot;cpa&quot;
 913             cloopEmitCompareAndSet(operands, :uintptr, &quot;&gt;&quot;)
 914 
 915         when &quot;cbaeq&quot;
 916             cloopEmitCompareAndSet(operands, :uint8, &quot;&gt;=&quot;)
 917         when &quot;ciaeq&quot;
 918             cloopEmitCompareAndSet(operands, :uint32, &quot;&gt;=&quot;)
 919         when &quot;cqaeq&quot;
 920             cloopEmitCompareAndSet(operands, :uint64, &quot;&gt;=&quot;)
 921         when &quot;cpaeq&quot;
 922             cloopEmitCompareAndSet(operands, :uintptr, &quot;&gt;=&quot;)
 923 
 924         when &quot;cbb&quot;
 925             cloopEmitCompareAndSet(operands, :uint8, &quot;&lt;&quot;)
 926         when &quot;cib&quot;
 927             cloopEmitCompareAndSet(operands, :uint32, &quot;&lt;&quot;)
 928         when &quot;cqb&quot;
 929             cloopEmitCompareAndSet(operands, :uint64, &quot;&lt;&quot;)
 930         when &quot;cpb&quot;
 931             cloopEmitCompareAndSet(operands, :uintptr, &quot;&lt;&quot;)
 932 
 933         when &quot;cbbeq&quot;
 934             cloopEmitCompareAndSet(operands, :uint8, &quot;&lt;=&quot;)
 935         when &quot;cibeq&quot;
 936             cloopEmitCompareAndSet(operands, :uint32, &quot;&lt;=&quot;)
 937         when &quot;cqbeq&quot;
 938             cloopEmitCompareAndSet(operands, :uint64, &quot;&lt;=&quot;)
 939         when &quot;cpbeq&quot;
 940             cloopEmitCompareAndSet(operands, :uintptr, &quot;&lt;=&quot;)
 941 
 942         when &quot;cbgt&quot;
 943             cloopEmitCompareAndSet(operands, :int8, &quot;&gt;&quot;)
 944         when &quot;cigt&quot;
 945             cloopEmitCompareAndSet(operands, :int32, &quot;&gt;&quot;)
 946         when &quot;cqgt&quot;
 947             cloopEmitCompareAndSet(operands, :int64, &quot;&gt;&quot;)
 948         when &quot;cpgt&quot;
 949             cloopEmitCompareAndSet(operands, :intptr, &quot;&gt;&quot;)
 950 
 951         when &quot;cbgteq&quot;
 952             cloopEmitCompareAndSet(operands, :int8, &quot;&gt;=&quot;)
 953         when &quot;cigteq&quot;
 954             cloopEmitCompareAndSet(operands, :int32, &quot;&gt;=&quot;)
 955         when &quot;cqgteq&quot;
 956             cloopEmitCompareAndSet(operands, :int64, &quot;&gt;=&quot;)
 957         when &quot;cpgteq&quot;
 958             cloopEmitCompareAndSet(operands, :intptr, &quot;&gt;=&quot;)
 959 
 960         when &quot;cblt&quot;
 961             cloopEmitCompareAndSet(operands, :int8, &quot;&lt;&quot;)
 962         when &quot;cilt&quot;
 963             cloopEmitCompareAndSet(operands, :int32, &quot;&lt;&quot;)
 964         when &quot;cqlt&quot;
 965             cloopEmitCompareAndSet(operands, :int64, &quot;&lt;&quot;)
 966         when &quot;cplt&quot;
 967             cloopEmitCompareAndSet(operands, :intptr, &quot;&lt;&quot;)
 968 
 969         when &quot;cblteq&quot;
 970             cloopEmitCompareAndSet(operands, :int8, &quot;&lt;=&quot;)
 971         when &quot;cilteq&quot;
 972             cloopEmitCompareAndSet(operands, :int32, &quot;&lt;=&quot;)
 973         when &quot;cqlteq&quot;
 974             cloopEmitCompareAndSet(operands, :int64, &quot;&lt;=&quot;)
 975         when &quot;cplteq&quot;
 976             cloopEmitCompareAndSet(operands, :intptr, &quot;&lt;=&quot;)
 977 
 978         when &quot;tbs&quot;
 979             cloopEmitTestSet(operands, :int8, &quot;&lt; 0&quot;)
 980         when &quot;tis&quot;
 981             cloopEmitTestSet(operands, :int32, &quot;&lt; 0&quot;)
 982         when &quot;tqs&quot;
 983             cloopEmitTestSet(operands, :int64, &quot;&lt; 0&quot;)
 984         when &quot;tps&quot;
 985             cloopEmitTestSet(operands, :intptr, &quot;&lt; 0&quot;)
 986 
 987         when &quot;tbz&quot;
 988             cloopEmitTestSet(operands, :int8, &quot;== 0&quot;)
 989         when &quot;tiz&quot;
 990             cloopEmitTestSet(operands, :int32, &quot;== 0&quot;)
 991         when &quot;tqz&quot;
 992             cloopEmitTestSet(operands, :int64, &quot;== 0&quot;)
 993         when &quot;tpz&quot;
 994             cloopEmitTestSet(operands, :intptr, &quot;== 0&quot;)
 995 
 996         when &quot;tbnz&quot;
 997             cloopEmitTestSet(operands, :int8, &quot;!= 0&quot;)
 998         when &quot;tinz&quot;
 999             cloopEmitTestSet(operands, :int32, &quot;!= 0&quot;)
1000         when &quot;tqnz&quot;
1001             cloopEmitTestSet(operands, :int64, &quot;!= 0&quot;)
1002         when &quot;tpnz&quot;
1003             cloopEmitTestSet(operands, :intptr, &quot;!= 0&quot;)
1004 
1005         # 64-bit instruction: cdqi (based on X64)
1006         # Sign extends the lower 32 bits of t0, but put the sign extension into
1007         # the lower 32 bits of t1. Leave the upper 32 bits of t0 and t1 unchanged.
1008         when &quot;cdqi&quot;
1009             $asm.putc &quot;{ // cdqi&quot;
1010             $asm.putc &quot;    int64_t temp = t0.i32(); // sign extend the low 32bit&quot;
1011             $asm.putc &quot;    t0 = (uint32_t)temp; // low word&quot;
1012             $asm.putc &quot;    t1 = (uint32_t)(temp &gt;&gt; 32); // high word&quot;
1013             $asm.putc &quot;}&quot;
1014 
1015         # 64-bit instruction: idivi op1 (based on X64)
1016         # Divide a 64-bit integer numerator by the specified denominator.
1017         # The numerator is specified in t0 and t1 as follows:
1018         #     1. low 32 bits of the numerator is in the low 32 bits of t0.
1019         #     2. high 32 bits of the numerator is in the low 32 bits of t1.
1020         #
1021         # The resultant quotient is a signed 32-bit int, and is to be stored
1022         # in the lower 32 bits of t0.
1023         # The resultant remainder is a signed 32-bit int, and is to be stored
1024         # in the lower 32 bits of t1.
1025         when &quot;idivi&quot;
1026             # Divide t1,t0 (EDX,EAX) by the specified arg, and store the remainder in t1,
1027             # and quotient in t0:
1028             $asm.putc &quot;{ // idivi&quot;
1029             $asm.putc &quot;    int64_t dividend = (int64_t(t1.u32()) &lt;&lt; 32) | t0.u32();&quot;
1030             $asm.putc &quot;    int64_t divisor = #{operands[0].clValue(:intptr)};&quot;
1031             $asm.putc &quot;    t1 = (uint32_t)(dividend % divisor); // remainder&quot;
1032             $asm.putc &quot;    t0 = (uint32_t)(dividend / divisor); // quotient&quot;
1033             $asm.putc &quot;}&quot;
1034 
1035         # 32-bit instruction: fii2d int32LoOp int32HiOp dblOp (based on ARMv7)
1036         # Decode 2 32-bit ints (low and high) into a 64-bit double.
1037         when &quot;fii2d&quot;
1038             $asm.putc &quot;#{operands[2].clLValue(:double)} = ints2Double(#{operands[0].clValue(:uint32)}, #{operands[1].clValue(:uint32)}); // fii2d&quot;
1039 
1040         # 32-bit instruction: f2dii dblOp int32LoOp int32HiOp (based on ARMv7)
1041         # Encode a 64-bit double into 2 32-bit ints (low and high).
1042         when &quot;fd2ii&quot;
1043             $asm.putc &quot;double2Ints(#{operands[0].clValue(:double)}, #{operands[1].clDump}, #{operands[2].clDump}); // fd2ii&quot;
1044 
1045         # 64-bit instruction: fq2d int64Op dblOp (based on X64)
1046         # Copy a bit-encoded double in a 64-bit int register to a double register.
1047         when &quot;fq2d&quot;
1048             $asm.putc &quot;#{operands[1].clLValue(:double)} = #{operands[0].clValue(:bitsAsDouble)}; // fq2d&quot;
1049 
1050         # 64-bit instruction: fd2q dblOp int64Op (based on X64 instruction set)
1051         # Copy a double as a bit-encoded double into a 64-bit int register.
1052         when &quot;fd2q&quot;
1053             $asm.putc &quot;#{operands[1].clLValue(:int64)} = #{operands[0].clValue(:bitsAsInt64)}; // fd2q&quot;
1054 
1055         when &quot;leai&quot;
1056             operands[0].cloopEmitLea(operands[1], :int32)
1057         when &quot;leap&quot;
1058             operands[0].cloopEmitLea(operands[1], :intptr)
1059 
1060         when &quot;baddio&quot;
1061             cloopEmitOpAndBranchIfOverflow(operands, &quot;+&quot;, :int32)
1062         when &quot;bsubio&quot;
1063             cloopEmitOpAndBranchIfOverflow(operands, &quot;-&quot;, :int32)
1064         when &quot;bmulio&quot;
1065             cloopEmitOpAndBranchIfOverflow(operands, &quot;*&quot;, :int32)
1066 
1067         when &quot;baddis&quot;
1068             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int32, &quot;&lt; 0&quot;)
1069         when &quot;baddiz&quot;
1070             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int32, &quot;== 0&quot;)
1071         when &quot;baddinz&quot;
1072             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int32, &quot;!= 0&quot;)
1073 
1074         when &quot;baddqs&quot;
1075             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int64, &quot;&lt; 0&quot;)
1076         when &quot;baddqz&quot;
1077             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int64, &quot;== 0&quot;)
1078         when &quot;baddqnz&quot;
1079             cloopEmitOpAndBranch(operands, &quot;+&quot;, :int64, &quot;!= 0&quot;)
1080 
1081         when &quot;baddps&quot;
1082             cloopEmitOpAndBranch(operands, &quot;+&quot;, :intptr, &quot;&lt; 0&quot;)
1083         when &quot;baddpz&quot;
1084             cloopEmitOpAndBranch(operands, &quot;+&quot;, :intptr, &quot;== 0&quot;)
1085         when &quot;baddpnz&quot;
1086             cloopEmitOpAndBranch(operands, &quot;+&quot;, :intptr, &quot;!= 0&quot;)
1087 
1088         when &quot;bsubis&quot;
1089             cloopEmitOpAndBranch(operands, &quot;-&quot;, :int32, &quot;&lt; 0&quot;)
1090         when &quot;bsubiz&quot;
1091             cloopEmitOpAndBranch(operands, &quot;-&quot;, :int32, &quot;== 0&quot;)
1092         when &quot;bsubinz&quot;
1093             cloopEmitOpAndBranch(operands, &quot;-&quot;, :int32, &quot;!= 0&quot;)
1094 
1095         when &quot;borris&quot;
1096             cloopEmitOpAndBranch(operands, &quot;|&quot;, :int32, &quot;&lt; 0&quot;)
1097         when &quot;borriz&quot;
1098             cloopEmitOpAndBranch(operands, &quot;|&quot;, :int32, &quot;== 0&quot;)
1099         when &quot;borrinz&quot;
1100             cloopEmitOpAndBranch(operands, &quot;|&quot;, :int32, &quot;!= 0&quot;)
1101             
1102         when &quot;memfence&quot;
1103 
1104         when &quot;push&quot;
1105             operands.each {
1106                 | op |
1107                 $asm.putc &quot;PUSH(#{op.clDump});&quot;
1108             }
1109         when &quot;pop&quot;
1110             operands.each {
1111                 | op |
1112                 $asm.putc &quot;POP(#{op.clDump});&quot;
1113             }
1114 
1115 
1116         # A convenience and compact call to crash because we don&#39;t want to use
1117         # the generic llint crash mechanism which relies on the availability
1118         # of the call instruction (which cannot be implemented in a generic
1119         # way, and can be abused if we made it just work for this special case).
1120         # Using a special cloopCrash instruction is cleaner.
1121         when &quot;cloopCrash&quot;
1122             $asm.putc &quot;CRASH();&quot;
1123 
1124         # We can&#39;t rely on the llint JS call mechanism which actually makes
1125         # use of the call instruction. Instead, we just implement JS calls
1126         # as an opcode dispatch.
1127         when &quot;cloopCallJSFunction&quot;
1128             uid = $asm.newUID
1129             $asm.putc &quot;lr = getOpcode(llint_cloop_did_return_from_js_#{uid});&quot;
1130             $asm.putc &quot;opcode = #{operands[0].clValue(:opcode)};&quot;
1131             $asm.putc &quot;DISPATCH_OPCODE();&quot;
1132             $asm.putsLabel(&quot;llint_cloop_did_return_from_js_#{uid}&quot;, false)
1133 
1134         # We can&#39;t do generic function calls with an arbitrary set of args, but
1135         # fortunately we don&#39;t have to here. All native function calls always
1136         # have a fixed prototype of 2 args: the passed JSGlobalObject* and CallFrame*.
1137         when &quot;cloopCallNative&quot;
1138             $asm.putc &quot;cloopStack.setCurrentStackPointer(sp.vp());&quot;
1139             $asm.putc &quot;nativeFunc = #{operands[0].clValue(:nativeFunc)};&quot;
1140             $asm.putc &quot;functionReturnValue = JSValue::decode(nativeFunc(jsCast&lt;JSGlobalObject*&gt;(t0.cell()), t1.callFrame()));&quot;
1141             $asm.putc &quot;#if USE(JSVALUE32_64)&quot;
1142             $asm.putc &quot;    t1 = functionReturnValue.tag();&quot;
1143             $asm.putc &quot;    t0 = functionReturnValue.payload();&quot;
1144             $asm.putc &quot;#else // USE_JSVALUE64)&quot;
1145             $asm.putc &quot;    t0 = JSValue::encode(functionReturnValue);&quot;
1146             $asm.putc &quot;#endif // USE_JSVALUE64)&quot;
1147 
1148         # We can&#39;t do generic function calls with an arbitrary set of args, but
1149         # fortunately we don&#39;t have to here. All slow path function calls always
1150         # have a fixed prototype too. See cloopEmitCallSlowPath() for details.
1151         when &quot;cloopCallSlowPath&quot;
1152             cloopEmitCallSlowPath(operands)
1153 
1154         when &quot;cloopCallSlowPathVoid&quot;
1155             cloopEmitCallSlowPathVoid(operands)
1156 
1157         # For debugging only. This is used to insert instrumentation into the
1158         # generated LLIntAssembly.h during llint development only. Do not use
1159         # for production code.
1160         when &quot;cloopDo&quot;
1161             $asm.putc &quot;#{annotation}&quot;
1162 
1163         else
1164             lowerDefault
1165         end
1166     end
1167 
1168     def lowerC_LOOP_WIN
1169         lowerC_LOOP
1170     end
1171 
1172     def recordMetaDataC_LOOP
1173         $asm.codeOrigin codeOriginString if $enableCodeOriginComments
1174         $asm.annotation annotation if $enableInstrAnnotations &amp;&amp; (opcode != &quot;cloopDo&quot;)
1175         $asm.debugAnnotation codeOrigin.debugDirective if $enableDebugAnnotations
1176     end
1177 end
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerARM64E.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MacroAssemblerARM64.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MacroAssemblerARMv7.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/MacroAssemblerARM64E.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 90         m_assembler.pacdb(target, length);
 91     }
 92 
 93     ALWAYS_INLINE void untagArrayPtr(RegisterID length, RegisterID target)
 94     {
 95         m_assembler.autdb(target, length);
 96     }
 97 
 98     ALWAYS_INLINE void untagArrayPtr(Address length, RegisterID target)
 99     {
100         auto lengthGPR = getCachedDataTempRegisterIDAndInvalidate();
101         load32(length, lengthGPR);
102         m_assembler.autdb(target, lengthGPR);
103     }
104 
105     ALWAYS_INLINE void removeArrayPtrTag(RegisterID target)
106     {
107         m_assembler.xpacd(target);
108     }
109 
<span class="line-modified">110     static const RegisterID InvalidGPR  = static_cast&lt;RegisterID&gt;(-1);</span>
111 
112     enum class CallSignatureType {
113         CFunctionCall,
114         OtherCall
115     };
116 
117     template&lt;CallSignatureType type&gt;
118     ALWAYS_INLINE Call callTrustedPtr(RegisterID tagGPR = InvalidGPR)
119     {
120         ASSERT(tagGPR != dataTempRegister);
121         AssemblerLabel pointerLabel = m_assembler.label();
122         moveWithFixedWidth(TrustedImmPtr(nullptr), getCachedDataTempRegisterIDAndInvalidate());
123         invalidateAllTempRegisters();
124         if (type == CallSignatureType::CFunctionCall)
125             m_assembler.blraaz(dataTempRegister);
126         else
127             m_assembler.blrab(dataTempRegister, tagGPR);
128         AssemblerLabel callLabel = m_assembler.label();
129         ASSERT_UNUSED(pointerLabel, ARM64Assembler::getDifferenceBetweenLabels(callLabel, pointerLabel) == REPATCH_OFFSET_CALL_TO_POINTER);
130         return Call(callLabel, Call::Linkable);
</pre>
<hr />
<pre>
171     {
172         return callRegister&lt;CallSignatureType::OtherCall&gt;(targetGPR, tagGPR);
173     }
174 
175     ALWAYS_INLINE Call call(Address address, PtrTag tag)
176     {
177         if (tag == NoPtrTag)
178             return MacroAssemblerARM64::call(address, tag);
179 
180         load64(address, getCachedDataTempRegisterIDAndInvalidate());
181         return call(dataTempRegister, tag);
182     }
183 
184     ALWAYS_INLINE Call call(Address address, RegisterID tag)
185     {
186         ASSERT(tag != dataTempRegister);
187         load64(address, getCachedDataTempRegisterIDAndInvalidate());
188         return call(dataTempRegister, tag);
189     }
190 







191     ALWAYS_INLINE Jump jump() { return MacroAssemblerARM64::jump(); }
192 
193     void farJump(RegisterID target, PtrTag tag)
194     {
195         if (tag == NoPtrTag)
196             return MacroAssemblerARM64::farJump(target, tag);
197 
198         ASSERT(tag != CFunctionPtrTag);
199         RegisterID diversityGPR = getCachedDataTempRegisterIDAndInvalidate();
200         move(TrustedImm64(tag), diversityGPR);
201         farJump(target, diversityGPR);
202     }
203 
204     void farJump(RegisterID target, RegisterID tag)
205     {
206         ASSERT(tag != target);
207         m_assembler.brab(target, tag);
208     }
209 
210     void farJump(Address address, PtrTag tag)
</pre>
</td>
<td>
<hr />
<pre>
 90         m_assembler.pacdb(target, length);
 91     }
 92 
 93     ALWAYS_INLINE void untagArrayPtr(RegisterID length, RegisterID target)
 94     {
 95         m_assembler.autdb(target, length);
 96     }
 97 
 98     ALWAYS_INLINE void untagArrayPtr(Address length, RegisterID target)
 99     {
100         auto lengthGPR = getCachedDataTempRegisterIDAndInvalidate();
101         load32(length, lengthGPR);
102         m_assembler.autdb(target, lengthGPR);
103     }
104 
105     ALWAYS_INLINE void removeArrayPtrTag(RegisterID target)
106     {
107         m_assembler.xpacd(target);
108     }
109 
<span class="line-modified">110     static constexpr RegisterID InvalidGPR  = static_cast&lt;RegisterID&gt;(-1);</span>
111 
112     enum class CallSignatureType {
113         CFunctionCall,
114         OtherCall
115     };
116 
117     template&lt;CallSignatureType type&gt;
118     ALWAYS_INLINE Call callTrustedPtr(RegisterID tagGPR = InvalidGPR)
119     {
120         ASSERT(tagGPR != dataTempRegister);
121         AssemblerLabel pointerLabel = m_assembler.label();
122         moveWithFixedWidth(TrustedImmPtr(nullptr), getCachedDataTempRegisterIDAndInvalidate());
123         invalidateAllTempRegisters();
124         if (type == CallSignatureType::CFunctionCall)
125             m_assembler.blraaz(dataTempRegister);
126         else
127             m_assembler.blrab(dataTempRegister, tagGPR);
128         AssemblerLabel callLabel = m_assembler.label();
129         ASSERT_UNUSED(pointerLabel, ARM64Assembler::getDifferenceBetweenLabels(callLabel, pointerLabel) == REPATCH_OFFSET_CALL_TO_POINTER);
130         return Call(callLabel, Call::Linkable);
</pre>
<hr />
<pre>
171     {
172         return callRegister&lt;CallSignatureType::OtherCall&gt;(targetGPR, tagGPR);
173     }
174 
175     ALWAYS_INLINE Call call(Address address, PtrTag tag)
176     {
177         if (tag == NoPtrTag)
178             return MacroAssemblerARM64::call(address, tag);
179 
180         load64(address, getCachedDataTempRegisterIDAndInvalidate());
181         return call(dataTempRegister, tag);
182     }
183 
184     ALWAYS_INLINE Call call(Address address, RegisterID tag)
185     {
186         ASSERT(tag != dataTempRegister);
187         load64(address, getCachedDataTempRegisterIDAndInvalidate());
188         return call(dataTempRegister, tag);
189     }
190 
<span class="line-added">191     ALWAYS_INLINE void callOperation(const FunctionPtr&lt;OperationPtrTag&gt; operation)</span>
<span class="line-added">192     {</span>
<span class="line-added">193         auto tmp = getCachedDataTempRegisterIDAndInvalidate();</span>
<span class="line-added">194         move(TrustedImmPtr(operation.executableAddress()), tmp);</span>
<span class="line-added">195         call(tmp, OperationPtrTag);</span>
<span class="line-added">196     }</span>
<span class="line-added">197 </span>
198     ALWAYS_INLINE Jump jump() { return MacroAssemblerARM64::jump(); }
199 
200     void farJump(RegisterID target, PtrTag tag)
201     {
202         if (tag == NoPtrTag)
203             return MacroAssemblerARM64::farJump(target, tag);
204 
205         ASSERT(tag != CFunctionPtrTag);
206         RegisterID diversityGPR = getCachedDataTempRegisterIDAndInvalidate();
207         move(TrustedImm64(tag), diversityGPR);
208         farJump(target, diversityGPR);
209     }
210 
211     void farJump(RegisterID target, RegisterID tag)
212     {
213         ASSERT(tag != target);
214         m_assembler.brab(target, tag);
215     }
216 
217     void farJump(Address address, PtrTag tag)
</pre>
</td>
</tr>
</table>
<center><a href="MacroAssemblerARM64.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MacroAssemblerARMv7.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
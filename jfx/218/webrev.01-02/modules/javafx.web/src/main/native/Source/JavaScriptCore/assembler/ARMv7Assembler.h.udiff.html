<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/ARMv7Assembler.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ARM64Registers.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ARMv7Registers.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/assembler/ARMv7Assembler.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  /*
<span class="udiff-line-modified-removed">-  * Copyright (C) 2009-2017 Apple Inc. All rights reserved.</span>
<span class="udiff-line-modified-added">+  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2010 University of Szeged
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -101,13 +101,13 @@</span>
  class ARMv7Assembler;
  class ARMThumbImmediate {
      friend class ARMv7Assembler;
  
      typedef uint8_t ThumbImmediateType;
<span class="udiff-line-modified-removed">-     static const ThumbImmediateType TypeInvalid = 0;</span>
<span class="udiff-line-modified-removed">-     static const ThumbImmediateType TypeEncoded = 1;</span>
<span class="udiff-line-modified-removed">-     static const ThumbImmediateType TypeUInt16 = 2;</span>
<span class="udiff-line-modified-added">+     static constexpr ThumbImmediateType TypeInvalid = 0;</span>
<span class="udiff-line-modified-added">+     static constexpr ThumbImmediateType TypeEncoded = 1;</span>
<span class="udiff-line-modified-added">+     static constexpr ThumbImmediateType TypeUInt16 = 2;</span>
  
      typedef union {
          int16_t asInt;
          struct {
              unsigned imm8 : 8;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1027,13 +1027,17 @@</span>
      ALWAYS_INLINE void ldr(RegisterID rt, RegisterID rn, ARMThumbImmediate imm)
      {
          ASSERT(rn != ARMRegisters::pc); // LDR (literal)
          ASSERT(imm.isUInt12());
  
<span class="udiff-line-modified-removed">-         if (!((rt | rn) &amp; 8) &amp;&amp; imm.isUInt7())</span>
<span class="udiff-line-modified-added">+         if (!((rt | rn) &amp; 8) &amp;&amp; imm.isUInt7() &amp;&amp; !(imm.getUInt7() % 4)) {</span>
<span class="udiff-line-added">+             // We can only use Encoding T1 when imm is a multiple of 4.</span>
<span class="udiff-line-added">+             // For details see A8.8.63 on ARM Architecture Reference</span>
<span class="udiff-line-added">+             // Manual ARMv7-A and ARMv7-R edition available on</span>
<span class="udiff-line-added">+             // https://static.docs.arm.com/ddi0406/cd/DDI0406C_d_armv7ar_arm.pdf</span>
              m_formatter.oneWordOp5Imm5Reg3Reg3(OP_LDR_imm_T1, imm.getUInt7() &gt;&gt; 2, rn, rt);
<span class="udiff-line-modified-removed">-         else if ((rn == ARMRegisters::sp) &amp;&amp; !(rt &amp; 8) &amp;&amp; imm.isUInt10())</span>
<span class="udiff-line-modified-added">+         } else if ((rn == ARMRegisters::sp) &amp;&amp; !(rt &amp; 8) &amp;&amp; imm.isUInt10())</span>
              m_formatter.oneWordOp5Reg3Imm8(OP_LDR_imm_T2, rt, static_cast&lt;uint8_t&gt;(imm.getUInt10() &gt;&gt; 2));
          else
              m_formatter.twoWordOp12Reg4Reg4Imm12(OP_LDR_imm_T3, rn, rt, imm.getUInt12());
      }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1967,12 +1971,14 @@</span>
      static constexpr int32_t nopPseudo32()
      {
          return OP_NOP_T2a | (OP_NOP_T2b &lt;&lt; 16);
      }
  
<span class="udiff-line-modified-removed">-     template &lt;typename CopyFunction&gt;</span>
<span class="udiff-line-modified-removed">-     static void fillNops(void* base, size_t size, CopyFunction copy)</span>
<span class="udiff-line-modified-added">+     using CopyFunction = void*(&amp;)(void*, const void*, size_t);</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-added">+     template &lt;CopyFunction copy&gt;</span>
<span class="udiff-line-added">+     static void fillNops(void* base, size_t size)</span>
      {
          RELEASE_ASSERT(!(size % sizeof(int16_t)));
  
          char* ptr = static_cast&lt;char*&gt;(base);
          const size_t num32s = size / sizeof(int32_t);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2121,36 +2127,35 @@</span>
      {
          std::sort(m_jumpsToLink.begin(), m_jumpsToLink.end(), linkRecordSourceComparator);
          return m_jumpsToLink;
      }
  
<span class="udiff-line-modified-removed">-     typedef void* (*CopyFunction)(void*, const void*, size_t);</span>
<span class="udiff-line-modified-removed">- </span>
<span class="udiff-line-removed">-     static void ALWAYS_INLINE link(LinkRecord&amp; record, uint8_t* from, const uint8_t* fromInstruction8, uint8_t* to, CopyFunction copy)</span>
<span class="udiff-line-modified-added">+     template&lt;CopyFunction copy&gt;</span>
<span class="udiff-line-modified-added">+     static void ALWAYS_INLINE link(LinkRecord&amp; record, uint8_t* from, const uint8_t* fromInstruction8, uint8_t* to)</span>
      {
          const uint16_t* fromInstruction = reinterpret_cast_ptr&lt;const uint16_t*&gt;(fromInstruction8);
          switch (record.linkType()) {
          case LinkJumpT1:
<span class="udiff-line-modified-removed">-             linkJumpT1(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);</span>
<span class="udiff-line-modified-added">+             linkJumpT1&lt;copy&gt;(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to);</span>
              break;
          case LinkJumpT2:
<span class="udiff-line-modified-removed">-             linkJumpT2(reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);</span>
<span class="udiff-line-modified-added">+             linkJumpT2&lt;copy&gt;(reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to);</span>
              break;
          case LinkJumpT3:
<span class="udiff-line-modified-removed">-             linkJumpT3(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);</span>
<span class="udiff-line-modified-added">+             linkJumpT3&lt;copy&gt;(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to);</span>
              break;
          case LinkJumpT4:
<span class="udiff-line-modified-removed">-             linkJumpT4(reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);</span>
<span class="udiff-line-modified-added">+             linkJumpT4&lt;copy&gt;(reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to);</span>
              break;
          case LinkConditionalJumpT4:
<span class="udiff-line-modified-removed">-             linkConditionalJumpT4(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);</span>
<span class="udiff-line-modified-added">+             linkConditionalJumpT4&lt;copy&gt;(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to);</span>
              break;
          case LinkConditionalBX:
<span class="udiff-line-modified-removed">-             linkConditionalBX(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);</span>
<span class="udiff-line-modified-added">+             linkConditionalBX&lt;copy&gt;(record.condition(), reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to);</span>
              break;
          case LinkBX:
<span class="udiff-line-modified-removed">-             linkBX(reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to, copy);</span>
<span class="udiff-line-modified-added">+             linkBX&lt;copy&gt;(reinterpret_cast_ptr&lt;uint16_t*&gt;(from), fromInstruction, to);</span>
              break;
          default:
              RELEASE_ASSERT_NOT_REACHED();
              break;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2373,11 +2378,11 @@</span>
      }
  #endif
  
      static void cacheFlush(void* code, size_t size)
      {
<span class="udiff-line-modified-removed">- #if OS(IOS_FAMILY)</span>
<span class="udiff-line-modified-added">+ #if OS(DARWIN)</span>
          sys_cache_control(kCacheFunctionPrepareForExecution, code, size);
  #elif OS(LINUX)
          size_t page = pageSize();
          uintptr_t current = reinterpret_cast&lt;uintptr_t&gt;(code);
          uintptr_t end = current + size;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2597,11 +2602,12 @@</span>
  
          intptr_t relative = reinterpret_cast&lt;intptr_t&gt;(target) - (reinterpret_cast&lt;intptr_t&gt;(instruction));
          return ((relative &lt;&lt; 7) &gt;&gt; 7) == relative;
      }
  
<span class="udiff-line-modified-removed">-     static void linkJumpT1(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)</span>
<span class="udiff-line-modified-added">+     template&lt;CopyFunction copy = performJITMemcpy&gt;</span>
<span class="udiff-line-added">+     static void linkJumpT1(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
          ASSERT(canBeJumpT1(instruction, target));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2616,11 +2622,12 @@</span>
          ASSERT(!(relative &amp; 1));
          uint16_t newInstruction = OP_B_T1 | ((cond &amp; 0xf) &lt;&lt; 8) | ((relative &amp; 0x1fe) &gt;&gt; 1);
          copy(writeTarget - 1, &amp;newInstruction, sizeof(uint16_t));
      }
  
<span class="udiff-line-modified-removed">-     static void linkJumpT2(uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)</span>
<span class="udiff-line-modified-added">+     template&lt;CopyFunction copy = performJITMemcpy&gt;</span>
<span class="udiff-line-added">+     static void linkJumpT2(uint16_t* writeTarget, const uint16_t* instruction, void* target)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
          ASSERT(canBeJumpT2(instruction, target));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2635,11 +2642,12 @@</span>
          ASSERT(!(relative &amp; 1));
          uint16_t newInstruction = OP_B_T2 | ((relative &amp; 0xffe) &gt;&gt; 1);
          copy(writeTarget - 1, &amp;newInstruction, sizeof(uint16_t));
      }
  
<span class="udiff-line-modified-removed">-     static void linkJumpT3(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)</span>
<span class="udiff-line-modified-added">+     template&lt;CopyFunction copy = performJITMemcpy&gt;</span>
<span class="udiff-line-added">+     static void linkJumpT3(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
          ASSERT(canBeJumpT3(instruction, target));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2652,11 +2660,12 @@</span>
          instructions[0] = OP_B_T3a | ((relative &amp; 0x100000) &gt;&gt; 10) | ((cond &amp; 0xf) &lt;&lt; 6) | ((relative &amp; 0x3f000) &gt;&gt; 12);
          instructions[1] = OP_B_T3b | ((relative &amp; 0x80000) &gt;&gt; 8) | ((relative &amp; 0x40000) &gt;&gt; 5) | ((relative &amp; 0xffe) &gt;&gt; 1);
          copy(writeTarget - 2, instructions, 2 * sizeof(uint16_t));
      }
  
<span class="udiff-line-modified-removed">-     static void linkJumpT4(uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)</span>
<span class="udiff-line-modified-added">+     template&lt;CopyFunction copy = performJITMemcpy&gt;</span>
<span class="udiff-line-added">+     static void linkJumpT4(uint16_t* writeTarget, const uint16_t* instruction, void* target)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
          ASSERT(canBeJumpT4(instruction, target));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2672,22 +2681,24 @@</span>
          instructions[0] = OP_B_T4a | ((relative &amp; 0x1000000) &gt;&gt; 14) | ((relative &amp; 0x3ff000) &gt;&gt; 12);
          instructions[1] = OP_B_T4b | ((relative &amp; 0x800000) &gt;&gt; 10) | ((relative &amp; 0x400000) &gt;&gt; 11) | ((relative &amp; 0xffe) &gt;&gt; 1);
          copy(writeTarget - 2, instructions, 2 * sizeof(uint16_t));
      }
  
<span class="udiff-line-modified-removed">-     static void linkConditionalJumpT4(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)</span>
<span class="udiff-line-modified-added">+     template&lt;CopyFunction copy = performJITMemcpy&gt;</span>
<span class="udiff-line-added">+     static void linkConditionalJumpT4(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
  
          uint16_t newInstruction = ifThenElse(cond) | OP_IT;
          copy(writeTarget - 3, &amp;newInstruction, sizeof(uint16_t));
<span class="udiff-line-modified-removed">-         linkJumpT4(writeTarget, instruction, target, copy);</span>
<span class="udiff-line-modified-added">+         linkJumpT4&lt;copy&gt;(writeTarget, instruction, target);</span>
      }
  
<span class="udiff-line-modified-removed">-     static void linkBX(uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)</span>
<span class="udiff-line-modified-added">+     template&lt;CopyFunction copy = performJITMemcpy&gt;</span>
<span class="udiff-line-added">+     static void linkBX(uint16_t* writeTarget, const uint16_t* instruction, void* target)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT_UNUSED(instruction, !(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(writeTarget) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2703,11 +2714,12 @@</span>
          instructions[4] = OP_BX | (JUMP_TEMPORARY_REGISTER &lt;&lt; 3);
  
          copy(writeTarget - 5, instructions, 5 * sizeof(uint16_t));
      }
  
<span class="udiff-line-modified-removed">-     static void linkConditionalBX(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target, CopyFunction copy = performJITMemcpy)</span>
<span class="udiff-line-modified-added">+     template&lt;CopyFunction copy = performJITMemcpy&gt;</span>
<span class="udiff-line-added">+     static void linkConditionalBX(Condition cond, uint16_t* writeTarget, const uint16_t* instruction, void* target)</span>
      {
          // FIMXE: this should be up in the MacroAssembler layer. :-(
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(instruction) &amp; 1));
          ASSERT(!(reinterpret_cast&lt;intptr_t&gt;(target) &amp; 1));
  
</pre>
<center><a href="ARM64Registers.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ARMv7Registers.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
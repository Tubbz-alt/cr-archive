<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/svg/SVGElement.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2004, 2005, 2006, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3  * Copyright (C) 2004, 2005, 2006, 2007 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2009-2019 Apple Inc. All rights reserved.
  5  * Copyright (C) 2013 Samsung Electronics. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;SVGAnimatedPropertyImpl.h&quot;
 26 #include &quot;SVGLocatable.h&quot;
 27 #include &quot;SVGNames.h&quot;
 28 #include &quot;SVGParsingError.h&quot;
 29 #include &quot;SVGPropertyOwnerRegistry.h&quot;
 30 #include &quot;StyledElement.h&quot;
 31 #include &lt;wtf/HashMap.h&gt;
 32 #include &lt;wtf/HashSet.h&gt;
 33 #include &lt;wtf/WeakPtr.h&gt;
 34 
 35 namespace WebCore {
 36 
 37 class AffineTransform;
 38 class CSSStyleDeclaration;
 39 class DeprecatedCSSOMValue;
 40 class Document;
 41 class SVGDocumentExtensions;
 42 class SVGElementRareData;
 43 class SVGPropertyAnimatorFactory;
 44 class SVGSVGElement;
 45 class SVGUseElement;
 46 
 47 void mapAttributeToCSSProperty(HashMap&lt;AtomStringImpl*, CSSPropertyID&gt;* propertyNameToIdMap, const QualifiedName&amp; attrName);
 48 
 49 class SVGElement : public StyledElement, public SVGPropertyOwner {
 50     WTF_MAKE_ISO_ALLOCATED(SVGElement);
 51 public:
 52     bool isOutermostSVGSVGElement() const;
 53 
 54     SVGSVGElement* ownerSVGElement() const;
 55     SVGElement* viewportElement() const;
 56 
 57     String title() const override;
 58     virtual bool supportsMarkers() const { return false; }
 59     bool hasRelativeLengths() const { return !m_elementsWithRelativeLengths.isEmpty(); }
 60     virtual bool needsPendingResourceHandling() const { return true; }
 61     bool instanceUpdatesBlocked() const;
 62     void setInstanceUpdatesBlocked(bool);
 63     virtual AffineTransform localCoordinateSpaceTransform(SVGLocatable::CTMScope) const;
 64 
 65     virtual bool isSVGGraphicsElement() const { return false; }
 66     virtual bool isSVGGeometryElement() const { return false; }
 67     virtual bool isFilterEffect() const { return false; }
 68     virtual bool isGradientStop() const { return false; }
 69     virtual bool isTextContent() const { return false; }
 70     virtual bool isSMILElement() const { return false; }
 71 
 72     // For SVGTests
 73     virtual bool isValid() const { return true; }
 74 
 75     virtual void svgAttributeChanged(const QualifiedName&amp;);
 76 
 77     void sendLoadEventIfPossible();
 78     void loadEventTimerFired();
 79     virtual Timer* loadEventTimer();
 80 
 81     virtual AffineTransform* supplementalTransform() { return nullptr; }
 82 
 83     void invalidateSVGAttributes() { ensureUniqueElementData().setAnimatedSVGAttributesAreDirty(true); }
 84     void invalidateSVGPresentationAttributeStyle()
 85     {
 86         ensureUniqueElementData().setPresentationAttributeStyleIsDirty(true);
 87         // Trigger style recalculation for &quot;elements as resource&quot; (e.g. referenced by feImage).
 88         invalidateStyle();
 89     }
 90 
 91     // The instances of an element are clones made in shadow trees to implement &lt;use&gt;.
 92     const HashSet&lt;SVGElement*&gt;&amp; instances() const;
 93 
 94     bool getBoundingBox(FloatRect&amp;, SVGLocatable::StyleUpdateStrategy = SVGLocatable::AllowStyleUpdate);
 95 
 96     SVGElement* correspondingElement() const;
 97     RefPtr&lt;SVGUseElement&gt; correspondingUseElement() const;
 98 
 99     void setCorrespondingElement(SVGElement*);
100 
101     Optional&lt;Style::ElementStyle&gt; resolveCustomStyle(const RenderStyle&amp; parentStyle, const RenderStyle* shadowHostStyle) override;
102 
103     static QualifiedName animatableAttributeForName(const AtomString&amp;);
104 #ifndef NDEBUG
105     bool isAnimatableAttribute(const QualifiedName&amp;) const;
106 #endif
107 
108     MutableStyleProperties* animatedSMILStyleProperties() const;
109     MutableStyleProperties&amp; ensureAnimatedSMILStyleProperties();
110     void setUseOverrideComputedStyle(bool);
111 
112     virtual bool haveLoadedRequiredResources();
113 
114     bool addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp;, const AddEventListenerOptions&amp;) override;
115     bool removeEventListener(const AtomString&amp; eventType, EventListener&amp;, const ListenerOptions&amp;) override;
116 
117     bool hasTagName(const SVGQualifiedName&amp; name) const { return hasLocalName(name.localName()); }
118 
119     void callClearTarget() { clearTarget(); }
120 
121     class InstanceUpdateBlocker;
122     class InstanceInvalidationGuard;
123 
124     using PropertyRegistry = SVGPropertyOwnerRegistry&lt;SVGElement&gt;;
125     virtual const SVGPropertyRegistry&amp; propertyRegistry() const { return m_propertyRegistry; }
126     void detachAllProperties() { propertyRegistry().detachAllProperties(); }
127 
128     bool isAnimatedPropertyAttribute(const QualifiedName&amp;) const;
129     bool isAnimatedAttribute(const QualifiedName&amp;) const;
130     bool isAnimatedStyleAttribute(const QualifiedName&amp;) const;
131 
132     void synchronizeAttribute(const QualifiedName&amp;);
133     void synchronizeAllAttributes();
134     static void synchronizeAllAnimatedSVGAttribute(SVGElement&amp;);
135 
136     void commitPropertyChange(SVGProperty*) override;
137     void commitPropertyChange(SVGAnimatedProperty&amp;);
138 
139     const SVGElement* attributeContextElement() const override { return this; }
140     SVGPropertyAnimatorFactory&amp; propertyAnimatorFactory() { return *m_propertyAnimatorFactory; }
141     RefPtr&lt;SVGAttributeAnimator&gt; createAnimator(const QualifiedName&amp;, AnimationMode, CalcMode, bool isAccumulated, bool isAdditive);
142     void animatorWillBeDeleted(const QualifiedName&amp;);
143 
144     // These are needed for the RenderTree, animation and DOM.
145     String className() const { return m_className-&gt;currentValue(); }
146     SVGAnimatedString&amp; classNameAnimated() { return m_className; }
147 
148 protected:
149     SVGElement(const QualifiedName&amp;, Document&amp;);
150     virtual ~SVGElement();
151 
152     bool rendererIsNeeded(const RenderStyle&amp;) override;
153     void parseAttribute(const QualifiedName&amp;, const AtomString&amp;) override;
154 
155     void finishParsingChildren() override;
156     void attributeChanged(const QualifiedName&amp;, const AtomString&amp; oldValue, const AtomString&amp; newValue, AttributeModificationReason = ModifiedDirectly) override;
157     bool childShouldCreateRenderer(const Node&amp;) const override;
158 
159     SVGElementRareData&amp; ensureSVGRareData();
160 
161     void reportAttributeParsingError(SVGParsingError, const QualifiedName&amp;, const AtomString&amp;);
162     static CSSPropertyID cssPropertyIdForSVGAttributeName(const QualifiedName&amp;);
163 
164     bool isPresentationAttribute(const QualifiedName&amp;) const override;
165     void collectStyleForPresentationAttribute(const QualifiedName&amp;, const AtomString&amp;, MutableStyleProperties&amp;) override;
166     InsertedIntoAncestorResult insertedIntoAncestor(InsertionType, ContainerNode&amp;) override;
167     void removedFromAncestor(RemovalType, ContainerNode&amp;) override;
168     void childrenChanged(const ChildChange&amp;) override;
169     virtual bool selfHasRelativeLengths() const { return false; }
170     void updateRelativeLengthsInformation() { updateRelativeLengthsInformation(selfHasRelativeLengths(), this); }
171     void updateRelativeLengthsInformation(bool hasRelativeLengths, SVGElement*);
172 
173     void willRecalcStyle(Style::Change) override;
174 
175 private:
176     const RenderStyle* computedStyle(PseudoId = PseudoId::None) final;
177 
178     virtual void clearTarget() { }
179 
180     void buildPendingResourcesIfNeeded();
181     void accessKeyAction(bool sendMouseEvents) override;
182 
183 #ifndef NDEBUG
184     virtual bool filterOutAnimatableAttribute(const QualifiedName&amp;) const;
185 #endif
186 
187     void invalidateInstances();
188 
189     std::unique_ptr&lt;SVGElementRareData&gt; m_svgRareData;
190 
191     HashSet&lt;SVGElement*&gt; m_elementsWithRelativeLengths;
192 
193     std::unique_ptr&lt;SVGPropertyAnimatorFactory&gt; m_propertyAnimatorFactory;
194 
195     PropertyRegistry m_propertyRegistry { *this };
196     Ref&lt;SVGAnimatedString&gt; m_className { SVGAnimatedString::create(this) };
197 };
198 
199 class SVGElement::InstanceInvalidationGuard {
200 public:
201     InstanceInvalidationGuard(SVGElement&amp;);
202     ~InstanceInvalidationGuard();
203 private:
204     SVGElement&amp; m_element;
205 };
206 
207 class SVGElement::InstanceUpdateBlocker {
208 public:
209     InstanceUpdateBlocker(SVGElement&amp;);
210     ~InstanceUpdateBlocker();
211 private:
212     SVGElement&amp; m_element;
213 };
214 
215 struct SVGAttributeHashTranslator {
216     static unsigned hash(const QualifiedName&amp; key)
217     {
218         if (key.hasPrefix()) {
219             QualifiedNameComponents components = { nullAtom().impl(), key.localName().impl(), key.namespaceURI().impl() };
220             return hashComponents(components);
221         }
222         return DefaultHash&lt;QualifiedName&gt;::Hash::hash(key);
223     }
224     static bool equal(const QualifiedName&amp; a, const QualifiedName&amp; b) { return a.matches(b); }
225 };
226 
227 inline SVGElement::InstanceInvalidationGuard::InstanceInvalidationGuard(SVGElement&amp; element)
228     : m_element(element)
229 {
230 }
231 
232 inline SVGElement::InstanceInvalidationGuard::~InstanceInvalidationGuard()
233 {
234     m_element.invalidateInstances();
235 }
236 
237 inline SVGElement::InstanceUpdateBlocker::InstanceUpdateBlocker(SVGElement&amp; element)
238     : m_element(element)
239 {
240     m_element.setInstanceUpdatesBlocked(true);
241 }
242 
243 inline SVGElement::InstanceUpdateBlocker::~InstanceUpdateBlocker()
244 {
245     m_element.setInstanceUpdatesBlocked(false);
246 }
247 
248 inline bool Node::hasTagName(const SVGQualifiedName&amp; name) const
249 {
250     return isSVGElement() &amp;&amp; downcast&lt;SVGElement&gt;(*this).hasTagName(name);
251 }
252 
253 } // namespace WebCore
254 
255 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::SVGElement)
256     static bool isType(const WebCore::Node&amp; node) { return node.isSVGElement(); }
257 SPECIALIZE_TYPE_TRAITS_END()
258 
259 #include &quot;SVGElementTypeHelpers.h&quot;
    </pre>
  </body>
</html>
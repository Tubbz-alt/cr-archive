<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/layout/tableformatting/TableFormattingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;TableFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
<a name="1" id="anc1"></a><span class="line-added"> 31 #include &quot;DisplayBox.h&quot;</span>
<span class="line-added"> 32 #include &quot;InvalidationState.h&quot;</span>
 33 #include &quot;LayoutBox.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 34 #include &quot;LayoutChildIterator.h&quot;</span>
<span class="line-added"> 35 #include &quot;LayoutContext.h&quot;</span>
 36 #include &quot;TableFormattingState.h&quot;
 37 #include &lt;wtf/IsoMallocInlines.h&gt;
 38 
 39 namespace WebCore {
 40 namespace Layout {
 41 
 42 WTF_MAKE_ISO_ALLOCATED_IMPL(TableFormattingContext);
 43 
<a name="3" id="anc3"></a><span class="line-added"> 44 // FIXME: This is temporary. Remove this function when table formatting is complete.</span>
<span class="line-added"> 45 void TableFormattingContext::initializeDisplayBoxToBlank(Display::Box&amp; displayBox) const</span>
<span class="line-added"> 46 {</span>
<span class="line-added"> 47     displayBox.setBorder({ });</span>
<span class="line-added"> 48     displayBox.setPadding({ });</span>
<span class="line-added"> 49     displayBox.setHorizontalMargin({ });</span>
<span class="line-added"> 50     displayBox.setHorizontalComputedMargin({ });</span>
<span class="line-added"> 51     displayBox.setVerticalMargin({ { }, { } });</span>
<span class="line-added"> 52     displayBox.setTopLeft({ });</span>
<span class="line-added"> 53     displayBox.setContentBoxWidth({ });</span>
<span class="line-added"> 54     displayBox.setContentBoxHeight({ });</span>
<span class="line-added"> 55 }</span>
<span class="line-added"> 56 </span>
 57 // https://www.w3.org/TR/css-tables-3/#table-layout-algorithm
<a name="4" id="anc4"></a><span class="line-modified"> 58 TableFormattingContext::TableFormattingContext(const Container&amp; formattingContextRoot, TableFormattingState&amp; formattingState)</span>
 59     : FormattingContext(formattingContextRoot, formattingState)
 60 {
 61 }
 62 
<a name="5" id="anc5"></a><span class="line-modified"> 63 void TableFormattingContext::layoutInFlowContent(InvalidationState&amp; invalidationState, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp;)</span>
 64 {
 65     auto&amp; grid = formattingState().tableGrid();
<a name="6" id="anc6"></a><span class="line-added"> 66     auto&amp; columnsContext = grid.columnsContext();</span>
<span class="line-added"> 67 </span>
<span class="line-added"> 68     computeAndDistributeExtraHorizontalSpace();</span>
<span class="line-added"> 69     // 1. Position each column.</span>
<span class="line-added"> 70     // FIXME: This should also deal with collapsing borders etc.</span>
<span class="line-added"> 71     auto horizontalSpacing = grid.horizontalSpacing();</span>
<span class="line-added"> 72     auto columnLogicalLeft = horizontalSpacing;</span>
<span class="line-added"> 73     for (auto&amp; column : columnsContext.columns()) {</span>
<span class="line-added"> 74         column.setLogicalLeft(columnLogicalLeft);</span>
<span class="line-added"> 75         columnLogicalLeft += (column.logicalWidth() + horizontalSpacing);</span>
<span class="line-added"> 76     }</span>
<span class="line-added"> 77 </span>
<span class="line-added"> 78     // 2. Layout each table cell (and compute row height as well).</span>
<span class="line-added"> 79     auto&amp; columnList = columnsContext.columns();</span>
 80     auto&amp; cellList = grid.cells();
 81     ASSERT(!cellList.isEmpty());
<a name="7" id="anc7"></a>



 82     for (auto&amp; cell : cellList) {
 83         auto&amp; cellLayoutBox = cell-&gt;tableCellBox;
<a name="8" id="anc8"></a><span class="line-modified"> 84         layoutTableCellBox(cellLayoutBox, columnList.at(cell-&gt;position.x()), invalidationState, horizontalConstraints);</span>
<span class="line-modified"> 85         // FIXME: Add support for column and row spanning and this requires a 2 pass layout.</span>
<span class="line-modified"> 86         auto&amp; row = grid.rows().at(cell-&gt;position.y());</span>
<span class="line-modified"> 87         row.setLogicalHeight(std::max(row.logicalHeight(), geometryForBox(cellLayoutBox).marginBoxHeight()));</span>
<span class="line-modified"> 88     }</span>
<span class="line-modified"> 89     // This is after the second pass when cell heights are fully computed.</span>
<span class="line-modified"> 90     auto rowLogicalTop = grid.verticalSpacing();</span>
<span class="line-modified"> 91     for (auto&amp; row : grid.rows()) {</span>
<span class="line-modified"> 92         row.setLogicalTop(rowLogicalTop);</span>
<span class="line-modified"> 93         rowLogicalTop += (row.logicalHeight() + grid.verticalSpacing());</span>
<span class="line-modified"> 94     }</span>
<span class="line-modified"> 95 </span>
<span class="line-modified"> 96     // 3. Finalize size and position.</span>
<span class="line-modified"> 97     positionTableCells();</span>
<span class="line-modified"> 98     setComputedGeometryForSections();</span>
<span class="line-modified"> 99     setComputedGeometryForRows();</span>
<span class="line-modified">100 }</span>
<span class="line-modified">101 </span>
<span class="line-modified">102 void TableFormattingContext::layoutTableCellBox(const Box&amp; cellLayoutBox, const TableGrid::Column&amp; column, InvalidationState&amp; invalidationState, const HorizontalConstraints&amp; horizontalConstraints)</span>
<span class="line-modified">103 {</span>
<span class="line-modified">104     computeBorderAndPadding(cellLayoutBox, horizontalConstraints);</span>
<span class="line-modified">105     // Margins do not apply to internal table elements.</span>
<span class="line-modified">106     auto&amp; cellDisplayBox = formattingState().displayBox(cellLayoutBox);</span>
<span class="line-modified">107     cellDisplayBox.setHorizontalMargin({ });</span>
<span class="line-modified">108     cellDisplayBox.setHorizontalComputedMargin({ });</span>
<span class="line-modified">109     // Don&#39;t know the actual position yet.</span>
<span class="line-modified">110     cellDisplayBox.setTopLeft({ });</span>
<span class="line-modified">111     cellDisplayBox.setContentBoxWidth(column.logicalWidth() - cellDisplayBox.horizontalMarginBorderAndPadding());</span>
<span class="line-modified">112 </span>
<span class="line-added">113     ASSERT(cellLayoutBox.establishesBlockFormattingContext());</span>
<span class="line-added">114     if (is&lt;Container&gt;(cellLayoutBox) &amp;&amp; downcast&lt;Container&gt;(cellLayoutBox).hasInFlowOrFloatingChild())</span>
<span class="line-added">115         LayoutContext::createFormattingContext(downcast&lt;Container&gt;(cellLayoutBox), layoutState())-&gt;layoutInFlowContent(invalidationState, Geometry::horizontalConstraintsForInFlow(cellDisplayBox), Geometry::verticalConstraintsForInFlow(cellDisplayBox));</span>
<span class="line-added">116     cellDisplayBox.setVerticalMargin({ { }, { } });</span>
<span class="line-added">117     cellDisplayBox.setContentBoxHeight(geometry().tableCellHeightAndMargin(cellLayoutBox).contentHeight);</span>
<span class="line-added">118     // FIXME: Check what to do with out-of-flow content.</span>
<span class="line-added">119 }</span>
<span class="line-added">120 </span>
<span class="line-added">121 void TableFormattingContext::positionTableCells()</span>
<span class="line-added">122 {</span>
<span class="line-added">123     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-added">124     auto&amp; rowList = grid.rows();</span>
<span class="line-added">125     auto&amp; columnList = grid.columnsContext().columns();</span>
<span class="line-added">126     for (auto&amp; cell : grid.cells()) {</span>
<span class="line-added">127         auto&amp; cellDisplayBox = formattingState().displayBox(cell-&gt;tableCellBox);</span>
<span class="line-added">128         cellDisplayBox.setTop(rowList.at(cell-&gt;position.y()).logicalTop());</span>
<span class="line-added">129         cellDisplayBox.setLeft(columnList.at(cell-&gt;position.x()).logicalLeft());</span>
130     }
131 }
132 
<a name="9" id="anc9"></a><span class="line-modified">133 void TableFormattingContext::setComputedGeometryForRows()</span>
<span class="line-added">134 {</span>
<span class="line-added">135     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-added">136     auto rowWidth = grid.columnsContext().logicalWidth() + 2 * grid.horizontalSpacing();</span>
<span class="line-added">137 </span>
<span class="line-added">138     auto&amp; rowList = grid.rows();</span>
<span class="line-added">139     for (auto&amp; row : rowList) {</span>
<span class="line-added">140         auto&amp; rowDisplayBox = formattingState().displayBox(row.box());</span>
<span class="line-added">141         initializeDisplayBoxToBlank(rowDisplayBox);</span>
<span class="line-added">142         rowDisplayBox.setContentBoxHeight(row.logicalHeight());</span>
<span class="line-added">143         rowDisplayBox.setContentBoxWidth(rowWidth);</span>
<span class="line-added">144         rowDisplayBox.setTop(row.logicalTop());</span>
<span class="line-added">145     }</span>
<span class="line-added">146 }</span>
<span class="line-added">147 </span>
<span class="line-added">148 void TableFormattingContext::setComputedGeometryForSections()</span>
<span class="line-added">149 {</span>
<span class="line-added">150     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-added">151     auto sectionWidth = grid.columnsContext().logicalWidth() + 2 * grid.horizontalSpacing();</span>
<span class="line-added">152 </span>
<span class="line-added">153     for (auto&amp; section : childrenOfType&lt;Box&gt;(root())) {</span>
<span class="line-added">154         auto&amp; sectionDisplayBox = formattingState().displayBox(section);</span>
<span class="line-added">155         initializeDisplayBoxToBlank(sectionDisplayBox);</span>
<span class="line-added">156         // FIXME: Size table sections properly.</span>
<span class="line-added">157         sectionDisplayBox.setContentBoxWidth(sectionWidth);</span>
<span class="line-added">158         sectionDisplayBox.setContentBoxHeight(grid.rows().last().logicalBottom() + grid.verticalSpacing());</span>
<span class="line-added">159     }</span>
<span class="line-added">160 }</span>
<span class="line-added">161 </span>
<span class="line-added">162 FormattingContext::IntrinsicWidthConstraints TableFormattingContext::computedIntrinsicWidthConstraints()</span>
163 {
164     // Tables have a slighty different concept of shrink to fit. It&#39;s really only different with non-auto &quot;width&quot; values, where
165     // a generic shrink-to fit block level box like a float box would be just sized to the computed value of &quot;width&quot;, tables
166     // can actually be streched way over.
<a name="10" id="anc10"></a><span class="line-modified">167     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-modified">168     if (!grid.hasComputedWidthConstraints()) {</span>
<span class="line-modified">169         // 1. Ensure each cell slot is occupied by at least one cell.</span>
<span class="line-modified">170         ensureTableGrid();</span>
<span class="line-modified">171         // 2. Compute the minimum/maximum width of each column.</span>
<span class="line-modified">172         computePreferredWidthForColumns();</span>
<span class="line-modified">173     }</span>
<span class="line-modified">174     return grid.widthConstraints();</span>

175 }
176 
<a name="11" id="anc11"></a><span class="line-modified">177 void TableFormattingContext::ensureTableGrid()</span>
178 {
<a name="12" id="anc12"></a><span class="line-modified">179     auto&amp; tableBox = root();</span>
180     auto&amp; tableGrid = formattingState().tableGrid();
<a name="13" id="anc13"></a><span class="line-added">181     tableGrid.setHorizontalSpacing(LayoutUnit { tableBox.style().horizontalBorderSpacing() });</span>
<span class="line-added">182     tableGrid.setVerticalSpacing(LayoutUnit { tableBox.style().verticalBorderSpacing() });</span>
<span class="line-added">183 </span>
<span class="line-added">184     auto* firstChild = tableBox.firstChild();</span>
<span class="line-added">185     const Box* tableCaption = nullptr;</span>
<span class="line-added">186     const Box* colgroup = nullptr;</span>
<span class="line-added">187     // Table caption is an optional element; if used, it is always the first child of a &lt;table&gt;.</span>
<span class="line-added">188     if (firstChild-&gt;isTableCaption())</span>
<span class="line-added">189         tableCaption = firstChild;</span>
<span class="line-added">190     // The &lt;colgroup&gt; must appear after any optional &lt;caption&gt; element but before any &lt;thead&gt;, &lt;th&gt;, &lt;tbody&gt;, &lt;tfoot&gt; and &lt;tr&gt; element.</span>
<span class="line-added">191     auto* colgroupCandidate = firstChild;</span>
<span class="line-added">192     if (tableCaption)</span>
<span class="line-added">193         colgroupCandidate = tableCaption-&gt;nextSibling();</span>
<span class="line-added">194     if (colgroupCandidate-&gt;isTableColumnGroup())</span>
<span class="line-added">195         colgroup = colgroupCandidate;</span>
<span class="line-added">196 </span>
<span class="line-added">197     if (colgroup) {</span>
<span class="line-added">198         auto&amp; columnsContext = tableGrid.columnsContext();</span>
<span class="line-added">199         for (auto* column = downcast&lt;Container&gt;(*colgroup).firstChild(); column; column = column-&gt;nextSibling()) {</span>
<span class="line-added">200             ASSERT(column-&gt;isTableColumn());</span>
<span class="line-added">201             auto columnSpanCount = column-&gt;columnSpan();</span>
<span class="line-added">202             ASSERT(columnSpanCount &gt; 0);</span>
<span class="line-added">203             while (columnSpanCount--)</span>
<span class="line-added">204                 columnsContext.addColumn(column);</span>
<span class="line-added">205         }</span>
<span class="line-added">206     }</span>
207 
<a name="14" id="anc14"></a><span class="line-modified">208     auto* firstSection = colgroup ? colgroup-&gt;nextSibling() : tableCaption ? tableCaption-&gt;nextSibling() : firstChild;</span>
<span class="line-added">209     for (auto* section = firstSection; section; section = section-&gt;nextSibling()) {</span>
210         ASSERT(section-&gt;isTableHeader() || section-&gt;isTableBody() || section-&gt;isTableFooter());
211         for (auto* row = downcast&lt;Container&gt;(*section).firstChild(); row; row = row-&gt;nextSibling()) {
212             ASSERT(row-&gt;isTableRow());
213             for (auto* cell = downcast&lt;Container&gt;(*row).firstChild(); cell; cell = cell-&gt;nextSibling()) {
214                 ASSERT(cell-&gt;isTableCell());
215                 tableGrid.appendCell(*cell);
216             }
217         }
218     }
219 }
220 
<a name="15" id="anc15"></a><span class="line-modified">221 void TableFormattingContext::computePreferredWidthForColumns()</span>
222 {
223     auto&amp; formattingState = this-&gt;formattingState();
224     auto&amp; grid = formattingState.tableGrid();
<a name="16" id="anc16"></a><span class="line-added">225     ASSERT(!grid.hasComputedWidthConstraints());</span>
226 
227     // 1. Calculate the minimum content width (MCW) of each cell: the formatted content may span any number of lines but may not overflow the cell box.
228     //    If the specified &#39;width&#39; (W) of the cell is greater than MCW, W is the minimum cell width. A value of &#39;auto&#39; means that MCW is the minimum cell width.
229     //    Also, calculate the &quot;maximum&quot; cell width of each cell: formatting the content without breaking lines other than where explicit line breaks occur.
230     for (auto&amp; cell : grid.cells()) {
<a name="17" id="anc17"></a><span class="line-modified">231         auto&amp; tableCellBox = cell-&gt;tableCellBox;</span>
<span class="line-added">232         ASSERT(tableCellBox.establishesFormattingContext());</span>
233 
<a name="18" id="anc18"></a><span class="line-modified">234         auto intrinsicWidth = formattingState.intrinsicWidthConstraintsForBox(tableCellBox);</span>
<span class="line-modified">235         if (!intrinsicWidth) {</span>
<span class="line-modified">236             intrinsicWidth = IntrinsicWidthConstraints { };</span>
<span class="line-added">237             if (is&lt;Container&gt;(tableCellBox))</span>
<span class="line-added">238                 intrinsicWidth = LayoutContext::createFormattingContext(downcast&lt;Container&gt;(tableCellBox), layoutState())-&gt;computedIntrinsicWidthConstraints();</span>
<span class="line-added">239             intrinsicWidth = geometry().constrainByMinMaxWidth(tableCellBox, *intrinsicWidth);</span>
<span class="line-added">240             auto border = geometry().computedBorder(tableCellBox);</span>
<span class="line-added">241             auto padding = *geometry().computedPadding(tableCellBox, { });</span>
<span class="line-added">242 </span>
<span class="line-added">243             intrinsicWidth-&gt;expand(border.horizontal.width() + padding.horizontal.width());</span>
<span class="line-added">244             formattingState.setIntrinsicWidthConstraintsForBox(tableCellBox, *intrinsicWidth);</span>
<span class="line-added">245         }</span>
246 
247         auto columnSpan = cell-&gt;size.width();
<a name="19" id="anc19"></a><span class="line-modified">248         auto slotIntrinsicWidth = FormattingContext::IntrinsicWidthConstraints { intrinsicWidth-&gt;minimum / columnSpan, intrinsicWidth-&gt;maximum / columnSpan };</span>
249         auto initialPosition = cell-&gt;position;
250         for (auto i = 0; i &lt; columnSpan; ++i)
251             grid.slot({ initialPosition.x() + i, initialPosition.y() })-&gt;widthConstraints = slotIntrinsicWidth;
252     }
253     // 2. For each column, determine a maximum and minimum column width from the cells that span only that column.
254     //    The minimum is that required by the cell with the largest minimum cell width (or the column &#39;width&#39;, whichever is larger).
255     //    The maximum is that required by the cell with the largest maximum cell width (or the column &#39;width&#39;, whichever is larger).
256     auto&amp; columns = grid.columnsContext().columns();
257     int numberOfRows = grid.rows().size();
258     int numberOfColumns = columns.size();
259     for (int columnIndex = 0; columnIndex &lt; numberOfColumns; ++columnIndex) {
260         auto columnIntrinsicWidths = FormattingContext::IntrinsicWidthConstraints { };
261         for (int rowIndex = 0; rowIndex &lt; numberOfRows; ++rowIndex) {
262             auto* slot = grid.slot({ columnIndex, rowIndex });
263             columnIntrinsicWidths.minimum = std::max(slot-&gt;widthConstraints.minimum, columnIntrinsicWidths.minimum);
264             columnIntrinsicWidths.maximum = std::max(slot-&gt;widthConstraints.maximum, columnIntrinsicWidths.maximum);
265         }
<a name="20" id="anc20"></a><span class="line-added">266         // Now that we have the content driven min/max widths, check if &lt;col&gt; sets a preferred width on this column.</span>
<span class="line-added">267         if (auto* columnBox = columns[columnIndex].columnBox()) {</span>
<span class="line-added">268             if (auto columnPreferredWidth = geometry().computedColumnWidth(*columnBox)) {</span>
<span class="line-added">269                 // Let&#39;s stay at least as wide as the preferred width.</span>
<span class="line-added">270                 columnIntrinsicWidths.minimum = std::max(columnIntrinsicWidths.minimum, *columnPreferredWidth);</span>
<span class="line-added">271             }</span>
<span class="line-added">272         }</span>
273         columns[columnIndex].setWidthConstraints(columnIntrinsicWidths);
274     }
<a name="21" id="anc21"></a>
275 }
276 
<a name="22" id="anc22"></a><span class="line-modified">277 void TableFormattingContext::computeAndDistributeExtraHorizontalSpace()</span>
278 {
<a name="23" id="anc23"></a><span class="line-added">279     auto&amp; grid = formattingState().tableGrid();</span>
<span class="line-added">280     ASSERT(grid.hasComputedWidthConstraints());</span>
<span class="line-added">281     auto tableWidthConstraints = grid.widthConstraints();</span>
<span class="line-added">282 </span>
283     // Column and caption widths influence the final table width as follows:
284     // If the &#39;table&#39; or &#39;inline-table&#39; element&#39;s &#39;width&#39; property has a computed value (W) other than &#39;auto&#39;, the used width is the greater of
285     // W, CAPMIN, and the minimum width required by all the columns plus cell spacing or borders (MIN).
286     // If the used width is greater than MIN, the extra width should be distributed over the columns.
287     // If the &#39;table&#39; or &#39;inline-table&#39; element has &#39;width: auto&#39;, the used width is the greater of the table&#39;s containing block width,
288     // CAPMIN, and MIN. However, if either CAPMIN or the maximum width required by the columns plus cell spacing or borders (MAX) is
289     // less than that of the containing block, use max(MAX, CAPMIN).
<a name="24" id="anc24"></a><span class="line-added">290     auto distributeExtraHorizontalSpace = [&amp;](auto extraHorizontalSpace) {</span>
<span class="line-added">291         auto&amp; columns = grid.columnsContext().columns();</span>
<span class="line-added">292         ASSERT(!columns.isEmpty());</span>
293 
<a name="25" id="anc25"></a><span class="line-modified">294         auto tableMinimumContentWidth = tableWidthConstraints.minimum - grid.totalHorizontalSpacing();</span>
<span class="line-modified">295         auto adjustabledHorizontalSpace = tableMinimumContentWidth;</span>
<span class="line-modified">296         auto numberOfColumns = columns.size();</span>
<span class="line-modified">297         // Fixed width columns don&#39;t participate in available space distribution.</span>
<span class="line-modified">298         for (auto&amp; column : columns) {</span>
<span class="line-modified">299             if (!column.hasFixedWidth())</span>
<span class="line-added">300                 continue;</span>
<span class="line-added">301             auto columnFixedWidth = *column.columnBox()-&gt;columnWidth();</span>
<span class="line-added">302             column.setLogicalWidth(columnFixedWidth);</span>
303 
<a name="26" id="anc26"></a><span class="line-modified">304             --numberOfColumns;</span>
<span class="line-modified">305             adjustabledHorizontalSpace -= columnFixedWidth;</span>











306         }
<a name="27" id="anc27"></a><span class="line-modified">307         if (!numberOfColumns || !adjustabledHorizontalSpace)</span>
<span class="line-modified">308             return;</span>
<span class="line-modified">309         // FIXME: Right now just distribute the extra space equaly among the columns using the minimum width.</span>
<span class="line-modified">310         ASSERT(adjustabledHorizontalSpace &gt; 0);</span>
<span class="line-modified">311         for (auto&amp; column : columns) {</span>
<span class="line-modified">312             if (column.hasFixedWidth())</span>
<span class="line-modified">313                 continue;</span>
<span class="line-modified">314             auto columnExtraSpace = extraHorizontalSpace / adjustabledHorizontalSpace * column.widthConstraints().minimum;</span>
<span class="line-modified">315             column.setLogicalWidth(column.widthConstraints().minimum + columnExtraSpace);</span>

316         }
<a name="28" id="anc28"></a><span class="line-added">317     };</span>
<span class="line-added">318 </span>
<span class="line-added">319     auto&amp; tableBox = root();</span>
<span class="line-added">320     auto containingBlockWidth = geometryForBox(*tableBox.containingBlock(), EscapeReason::TableNeedsAccessToTableWrapper).contentBoxWidth();</span>
<span class="line-added">321     auto contentWidth = geometry().computedContentWidth(tableBox, containingBlockWidth);</span>
<span class="line-added">322     if (contentWidth) {</span>
<span class="line-added">323         if (*contentWidth &gt; tableWidthConstraints.minimum)</span>
<span class="line-added">324             distributeExtraHorizontalSpace(*contentWidth - tableWidthConstraints.minimum);</span>
<span class="line-added">325         else</span>
<span class="line-added">326             useAsContentLogicalWidth(WidthConstraintsType::Minimum);</span>
<span class="line-added">327     } else {</span>
<span class="line-added">328         if (tableWidthConstraints.minimum &gt; containingBlockWidth)</span>
<span class="line-added">329             useAsContentLogicalWidth(WidthConstraintsType::Minimum);</span>
<span class="line-added">330         else if (tableWidthConstraints.maximum &lt; containingBlockWidth)</span>
<span class="line-added">331             useAsContentLogicalWidth(WidthConstraintsType::Maximum);</span>
<span class="line-added">332         else</span>
<span class="line-added">333             distributeExtraHorizontalSpace(containingBlockWidth - tableWidthConstraints.minimum);</span>
334     }
<a name="29" id="anc29"></a>







335 }
336 
<a name="30" id="anc30"></a><span class="line-modified">337 void TableFormattingContext::useAsContentLogicalWidth(WidthConstraintsType type)</span>
338 {
<a name="31" id="anc31"></a>
339     auto&amp; columns = formattingState().tableGrid().columnsContext().columns();
340     ASSERT(!columns.isEmpty());
341 
<a name="32" id="anc32"></a>
342     for (auto&amp; column : columns)
<a name="33" id="anc33"></a><span class="line-modified">343         column.setLogicalWidth(type == WidthConstraintsType::Minimum ? column.widthConstraints().minimum : column.widthConstraints().maximum);</span>
344 }
345 
346 }
347 }
348 
349 #endif
<a name="34" id="anc34"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="34" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLTexture.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2009 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 
 28 #if ENABLE(WEBGL)
 29 
 30 #include &quot;WebGLTexture.h&quot;
 31 
 32 #include &quot;WebGLContextGroup.h&quot;
 33 #include &quot;WebGLFramebuffer.h&quot;
 34 #include &quot;WebGLRenderingContextBase.h&quot;
 35 
 36 namespace WebCore {
 37 
 38 Ref&lt;WebGLTexture&gt; WebGLTexture::create(WebGLRenderingContextBase&amp; ctx)
 39 {
 40     return adoptRef(*new WebGLTexture(ctx));
 41 }
 42 
 43 WebGLTexture::WebGLTexture(WebGLRenderingContextBase&amp; ctx)
 44     : WebGLSharedObject(ctx)
 45     , m_target(0)
<a name="1" id="anc1"></a><span class="line-modified"> 46     , m_minFilter(GraphicsContextGL::NEAREST_MIPMAP_LINEAR)</span>
<span class="line-modified"> 47     , m_magFilter(GraphicsContextGL::LINEAR)</span>
<span class="line-modified"> 48     , m_wrapS(GraphicsContextGL::REPEAT)</span>
<span class="line-modified"> 49     , m_wrapT(GraphicsContextGL::REPEAT)</span>
 50     , m_isNPOT(false)
 51     , m_isComplete(false)
 52     , m_needToUseBlackTexture(false)
 53     , m_isCompressed(false)
 54     , m_isFloatType(false)
 55     , m_isHalfFloatType(false)
 56     , m_isForWebGL1(ctx.isWebGL1())
 57 {
<a name="2" id="anc2"></a><span class="line-modified"> 58     setObject(ctx.graphicsContextGL()-&gt;createTexture());</span>
 59 }
 60 
 61 WebGLTexture::~WebGLTexture()
 62 {
 63     deleteObject(0);
 64 }
 65 
<a name="3" id="anc3"></a><span class="line-modified"> 66 void WebGLTexture::setTarget(GCGLenum target, GCGLint maxLevel)</span>
 67 {
 68     if (!object())
 69         return;
 70     // Target is finalized the first time bindTexture() is called.
 71     if (m_target)
 72         return;
 73     switch (target) {
<a name="4" id="anc4"></a><span class="line-modified"> 74     case GraphicsContextGL::TEXTURE_2D:</span>
 75         m_target = target;
 76         m_info.resize(1);
 77         m_info[0].resize(maxLevel);
 78         break;
<a name="5" id="anc5"></a><span class="line-modified"> 79     case GraphicsContextGL::TEXTURE_CUBE_MAP:</span>
 80         m_target = target;
 81         m_info.resize(6);
 82         for (int ii = 0; ii &lt; 6; ++ii)
 83             m_info[ii].resize(maxLevel);
 84         break;
 85     }
 86 }
 87 
<a name="6" id="anc6"></a><span class="line-modified"> 88 void WebGLTexture::setParameteri(GCGLenum pname, GCGLint param)</span>
 89 {
 90     if (!object() || !m_target)
 91         return;
 92     switch (pname) {
<a name="7" id="anc7"></a><span class="line-modified"> 93     case GraphicsContextGL::TEXTURE_MIN_FILTER:</span>
 94         switch (param) {
<a name="8" id="anc8"></a><span class="line-modified"> 95         case GraphicsContextGL::NEAREST:</span>
<span class="line-modified"> 96         case GraphicsContextGL::LINEAR:</span>
<span class="line-modified"> 97         case GraphicsContextGL::NEAREST_MIPMAP_NEAREST:</span>
<span class="line-modified"> 98         case GraphicsContextGL::LINEAR_MIPMAP_NEAREST:</span>
<span class="line-modified"> 99         case GraphicsContextGL::NEAREST_MIPMAP_LINEAR:</span>
<span class="line-modified">100         case GraphicsContextGL::LINEAR_MIPMAP_LINEAR:</span>
101             m_minFilter = param;
102             break;
103         }
104         break;
<a name="9" id="anc9"></a><span class="line-modified">105     case GraphicsContextGL::TEXTURE_MAG_FILTER:</span>
106         switch (param) {
<a name="10" id="anc10"></a><span class="line-modified">107         case GraphicsContextGL::NEAREST:</span>
<span class="line-modified">108         case GraphicsContextGL::LINEAR:</span>
109             m_magFilter = param;
110             break;
111         }
112         break;
<a name="11" id="anc11"></a><span class="line-modified">113     case GraphicsContextGL::TEXTURE_WRAP_S:</span>
114         switch (param) {
<a name="12" id="anc12"></a><span class="line-modified">115         case GraphicsContextGL::CLAMP_TO_EDGE:</span>
<span class="line-modified">116         case GraphicsContextGL::MIRRORED_REPEAT:</span>
<span class="line-modified">117         case GraphicsContextGL::REPEAT:</span>
118             m_wrapS = param;
119             break;
120         }
121         break;
<a name="13" id="anc13"></a><span class="line-modified">122     case GraphicsContextGL::TEXTURE_WRAP_T:</span>
123         switch (param) {
<a name="14" id="anc14"></a><span class="line-modified">124         case GraphicsContextGL::CLAMP_TO_EDGE:</span>
<span class="line-modified">125         case GraphicsContextGL::MIRRORED_REPEAT:</span>
<span class="line-modified">126         case GraphicsContextGL::REPEAT:</span>
127             m_wrapT = param;
128             break;
129         }
130         break;
131     default:
132         return;
133     }
134     update();
135 }
136 
<a name="15" id="anc15"></a><span class="line-modified">137 void WebGLTexture::setParameterf(GCGLenum pname, GCGLfloat param)</span>
138 {
139     if (!object() || !m_target)
140         return;
<a name="16" id="anc16"></a><span class="line-modified">141     GCGLint iparam = static_cast&lt;GCGLint&gt;(param);</span>
142     setParameteri(pname, iparam);
143 }
144 
<a name="17" id="anc17"></a><span class="line-modified">145 void WebGLTexture::setLevelInfo(GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLsizei width, GCGLsizei height, GCGLenum type)</span>
146 {
147     if (!object() || !m_target)
148         return;
149     // We assume level, internalFormat, width, height, and type have all been
150     // validated already.
151     int index = mapTargetToIndex(target);
152     if (index &lt; 0)
153         return;
154     m_info[index][level].setInfo(internalFormat, width, height, type);
155     update();
156 }
157 
158 void WebGLTexture::generateMipmapLevelInfo()
159 {
160     if (!object() || !m_target)
161         return;
162     if (!canGenerateMipmaps())
163         return;
164     if (!m_isComplete) {
165         for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
166             const LevelInfo&amp; info0 = m_info[ii][0];
<a name="18" id="anc18"></a><span class="line-modified">167             GCGLsizei width = info0.width;</span>
<span class="line-modified">168             GCGLsizei height = info0.height;</span>
<span class="line-modified">169             GCGLint levelCount = computeLevelCount(width, height);</span>
<span class="line-modified">170             for (GCGLint level = 1; level &lt; levelCount; ++level) {</span>
171                 width = std::max(1, width &gt;&gt; 1);
172                 height = std::max(1, height &gt;&gt; 1);
173                 LevelInfo&amp; info = m_info[ii][level];
174                 info.setInfo(info0.internalFormat, width, height, info0.type);
175             }
176         }
177         m_isComplete = true;
178     }
179     m_needToUseBlackTexture = false;
180 }
181 
<a name="19" id="anc19"></a><span class="line-modified">182 GCGLenum WebGLTexture::getInternalFormat(GCGLenum target, GCGLint level) const</span>
183 {
184     const LevelInfo* info = getLevelInfo(target, level);
185     if (!info)
186         return 0;
187     return info-&gt;internalFormat;
188 }
189 
<a name="20" id="anc20"></a><span class="line-modified">190 GCGLenum WebGLTexture::getType(GCGLenum target, GCGLint level) const</span>
191 {
192     ASSERT(m_isForWebGL1);
193     const LevelInfo* info = getLevelInfo(target, level);
194     if (!info)
195         return 0;
196     return info-&gt;type;
197 }
198 
<a name="21" id="anc21"></a><span class="line-modified">199 GCGLsizei WebGLTexture::getWidth(GCGLenum target, GCGLint level) const</span>
200 {
201     const LevelInfo* info = getLevelInfo(target, level);
202     if (!info)
203         return 0;
204     return info-&gt;width;
205 }
206 
<a name="22" id="anc22"></a><span class="line-modified">207 GCGLsizei WebGLTexture::getHeight(GCGLenum target, GCGLint level) const</span>
208 {
209     const LevelInfo* info = getLevelInfo(target, level);
210     if (!info)
211         return 0;
212     return info-&gt;height;
213 }
214 
<a name="23" id="anc23"></a><span class="line-modified">215 bool WebGLTexture::isValid(GCGLenum target, GCGLint level) const</span>
216 {
217     const LevelInfo* info = getLevelInfo(target, level);
218     if (!info)
219         return 0;
220     return info-&gt;valid;
221 }
222 
<a name="24" id="anc24"></a><span class="line-modified">223 void WebGLTexture::markInvalid(GCGLenum target, GCGLint level)</span>
224 {
225     int index = mapTargetToIndex(target);
226     if (index &lt; 0)
227         return;
228     m_info[index][level].valid = false;
229     update();
230 }
231 
<a name="25" id="anc25"></a><span class="line-modified">232 bool WebGLTexture::isNPOT(GCGLsizei width, GCGLsizei height)</span>
233 {
234     ASSERT(width &gt;= 0 &amp;&amp; height &gt;= 0);
235     if (!width || !height)
236         return false;
237     if ((width &amp; (width - 1)) || (height &amp; (height - 1)))
238         return true;
239     return false;
240 }
241 
242 bool WebGLTexture::isNPOT() const
243 {
244     if (!object())
245         return false;
246     return m_isNPOT;
247 }
248 
249 bool WebGLTexture::needToUseBlackTexture(TextureExtensionFlag extensions) const
250 {
251     if (!object())
252         return false;
253     if (m_needToUseBlackTexture)
254         return true;
<a name="26" id="anc26"></a><span class="line-modified">255     if (m_magFilter == GraphicsContextGL::NEAREST &amp;&amp; (m_minFilter == GraphicsContextGL::NEAREST || m_minFilter == GraphicsContextGL::NEAREST_MIPMAP_NEAREST))</span>
256         return false;
257     if (m_isForWebGL1 &amp;&amp; m_isHalfFloatType &amp;&amp; !(extensions &amp; TextureExtensionHalfFloatLinearEnabled))
258         return true;
259     if (m_isFloatType &amp;&amp; !(extensions &amp; TextureExtensionFloatLinearEnabled))
260         return true;
261     return false;
262 }
263 
264 bool WebGLTexture::isCompressed() const
265 {
266     if (!object())
267         return false;
268     return m_isCompressed;
269 }
270 
271 void WebGLTexture::setCompressed()
272 {
273     ASSERT(object());
274     m_isCompressed = true;
275 }
276 
<a name="27" id="anc27"></a><span class="line-modified">277 void WebGLTexture::deleteObjectImpl(GraphicsContextGLOpenGL* context3d, PlatformGLObject object)</span>
278 {
279     context3d-&gt;deleteTexture(object);
280 }
281 
<a name="28" id="anc28"></a><span class="line-modified">282 int WebGLTexture::mapTargetToIndex(GCGLenum target) const</span>
283 {
<a name="29" id="anc29"></a><span class="line-modified">284     if (m_target == GraphicsContextGL::TEXTURE_2D) {</span>
<span class="line-modified">285         if (target == GraphicsContextGL::TEXTURE_2D)</span>
286             return 0;
<a name="30" id="anc30"></a><span class="line-modified">287     } else if (m_target == GraphicsContextGL::TEXTURE_CUBE_MAP) {</span>
288         switch (target) {
<a name="31" id="anc31"></a><span class="line-modified">289         case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_X:</span>
290             return 0;
<a name="32" id="anc32"></a><span class="line-modified">291         case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_X:</span>
292             return 1;
<a name="33" id="anc33"></a><span class="line-modified">293         case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Y:</span>
294             return 2;
<a name="34" id="anc34"></a><span class="line-modified">295         case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Y:</span>
296             return 3;
<a name="35" id="anc35"></a><span class="line-modified">297         case GraphicsContextGL::TEXTURE_CUBE_MAP_POSITIVE_Z:</span>
298             return 4;
<a name="36" id="anc36"></a><span class="line-modified">299         case GraphicsContextGL::TEXTURE_CUBE_MAP_NEGATIVE_Z:</span>
300             return 5;
301         }
302     }
303     return -1;
304 }
305 
306 bool WebGLTexture::canGenerateMipmaps()
307 {
308     if (isNPOT())
309         return false;
310     const LevelInfo&amp; first = m_info[0][0];
311     for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
312         const LevelInfo&amp; info = m_info[ii][0];
313         if (!info.valid
314             || info.width != first.width || info.height != first.height
315             || info.internalFormat != first.internalFormat || (m_isForWebGL1 &amp;&amp; info.type != first.type))
316             return false;
317     }
318     return true;
319 }
320 
<a name="37" id="anc37"></a><span class="line-modified">321 GCGLint WebGLTexture::computeLevelCount(GCGLsizei width, GCGLsizei height)</span>
322 {
323     // return 1 + log2Floor(std::max(width, height));
<a name="38" id="anc38"></a><span class="line-modified">324     GCGLsizei n = std::max(width, height);</span>
325     if (n &lt;= 0)
326         return 0;
<a name="39" id="anc39"></a><span class="line-modified">327     GCGLint log = 0;</span>
<span class="line-modified">328     GCGLsizei value = n;</span>
329     for (int ii = 4; ii &gt;= 0; --ii) {
330         int shift = (1 &lt;&lt; ii);
<a name="40" id="anc40"></a><span class="line-modified">331         GCGLsizei x = (value &gt;&gt; shift);</span>
332         if (x) {
333             value = x;
334             log += shift;
335         }
336     }
337     ASSERT(value == 1);
338     return log + 1;
339 }
340 
<a name="41" id="anc41"></a><span class="line-modified">341 static bool internalFormatIsFloatType(GCGLenum internalFormat)</span>
342 {
343     switch (internalFormat) {
<a name="42" id="anc42"></a><span class="line-modified">344     case GraphicsContextGL::R32F:</span>
<span class="line-modified">345     case GraphicsContextGL::RG32F:</span>
<span class="line-modified">346     case GraphicsContextGL::RGB32F:</span>
<span class="line-modified">347     case GraphicsContextGL::RGBA32F:</span>
<span class="line-modified">348     case GraphicsContextGL::DEPTH_COMPONENT32F:</span>
<span class="line-modified">349     case GraphicsContextGL::DEPTH32F_STENCIL8:</span>
350         return true;
351     default:
352         return false;
353     }
354 }
355 
<a name="43" id="anc43"></a><span class="line-modified">356 static bool internalFormatIsHalfFloatType(GCGLenum internalFormat)</span>
357 {
358     switch (internalFormat) {
<a name="44" id="anc44"></a><span class="line-modified">359     case GraphicsContextGL::R16F:</span>
<span class="line-modified">360     case GraphicsContextGL::RG16F:</span>
<span class="line-modified">361     case GraphicsContextGL::R11F_G11F_B10F:</span>
<span class="line-modified">362     case GraphicsContextGL::RGB9_E5:</span>
<span class="line-modified">363     case GraphicsContextGL::RGB16F:</span>
<span class="line-modified">364     case GraphicsContextGL::RGBA16F:</span>
365         return true;
366     default:
367         return false;
368     }
369 }
370 
371 void WebGLTexture::update()
372 {
373     m_isNPOT = false;
374     for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
375         if (isNPOT(m_info[ii][0].width, m_info[ii][0].height)) {
376             m_isNPOT = true;
377             break;
378         }
379     }
380     m_isComplete = true;
381     const LevelInfo&amp; first = m_info[0][0];
<a name="45" id="anc45"></a><span class="line-modified">382     GCGLint levelCount = computeLevelCount(first.width, first.height);</span>
383     if (levelCount &lt; 1)
384         m_isComplete = false;
385     else {
386         for (size_t ii = 0; ii &lt; m_info.size() &amp;&amp; m_isComplete; ++ii) {
387             const LevelInfo&amp; info0 = m_info[ii][0];
388             if (!info0.valid
389                 || info0.width != first.width || info0.height != first.height
390                 || info0.internalFormat != first.internalFormat || (m_isForWebGL1 &amp;&amp; info0.type != first.type)) {
391                 m_isComplete = false;
392                 break;
393             }
<a name="46" id="anc46"></a><span class="line-modified">394             GCGLsizei width = info0.width;</span>
<span class="line-modified">395             GCGLsizei height = info0.height;</span>
<span class="line-modified">396             for (GCGLint level = 1; level &lt; levelCount; ++level) {</span>
397                 width = std::max(1, width &gt;&gt; 1);
398                 height = std::max(1, height &gt;&gt; 1);
399                 const LevelInfo&amp; info = m_info[ii][level];
400                 if (!info.valid
401                     || info.width != width || info.height != height
402                     || info.internalFormat != info0.internalFormat || (m_isForWebGL1 &amp;&amp; info.type != info0.type)) {
403                     m_isComplete = false;
404                     break;
405                 }
406 
407             }
408         }
409     }
410 
411     m_isFloatType = false;
412     if (m_isForWebGL1) {
413         if (m_isComplete) {
414             if (m_isForWebGL1)
<a name="47" id="anc47"></a><span class="line-modified">415                 m_isFloatType = m_info[0][0].type == GraphicsContextGL::FLOAT;</span>
416             else
417                 m_isFloatType = internalFormatIsFloatType(m_info[0][0].internalFormat);
418         } else {
419             for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
<a name="48" id="anc48"></a><span class="line-modified">420                 if ((m_isForWebGL1 &amp;&amp; m_info[ii][0].type == GraphicsContextGL::FLOAT)</span>
421                     || (!m_isForWebGL1 &amp;&amp; internalFormatIsFloatType(m_info[ii][0].internalFormat))) {
422                     m_isFloatType = true;
423                     break;
424                 }
425             }
426         }
427     }
428 
429     m_isHalfFloatType = false;
430     if (m_isForWebGL1) {
431         if (m_isComplete) {
432             if (m_isForWebGL1)
433                 m_isHalfFloatType = internalFormatIsHalfFloatType(m_info[0][0].internalFormat);
434             else
<a name="49" id="anc49"></a><span class="line-modified">435                 m_isHalfFloatType = m_info[0][0].type == GraphicsContextGL::HALF_FLOAT_OES;</span>
436         } else {
437             for (size_t ii = 0; ii &lt; m_info.size(); ++ii) {
<a name="50" id="anc50"></a><span class="line-modified">438                 if ((m_isForWebGL1 &amp;&amp; m_info[ii][0].type == GraphicsContextGL::HALF_FLOAT_OES)</span>
439                     || (!m_isForWebGL1 &amp;&amp; internalFormatIsHalfFloatType(m_info[ii][0].internalFormat))) {
440                     m_isHalfFloatType = true;
441                     break;
442                 }
443             }
444         }
445     }
446 
447     m_needToUseBlackTexture = false;
448     // NPOT
<a name="51" id="anc51"></a><span class="line-modified">449     if (m_isNPOT &amp;&amp; ((m_minFilter != GraphicsContextGL::NEAREST &amp;&amp; m_minFilter != GraphicsContextGL::LINEAR)</span>
<span class="line-modified">450         || m_wrapS != GraphicsContextGL::CLAMP_TO_EDGE || m_wrapT != GraphicsContextGL::CLAMP_TO_EDGE))</span>
451         m_needToUseBlackTexture = true;
452     // Completeness
<a name="52" id="anc52"></a><span class="line-modified">453     if (!m_isComplete &amp;&amp; m_minFilter != GraphicsContextGL::NEAREST &amp;&amp; m_minFilter != GraphicsContextGL::LINEAR)</span>
454         m_needToUseBlackTexture = true;
455 }
456 
<a name="53" id="anc53"></a><span class="line-modified">457 const WebGLTexture::LevelInfo* WebGLTexture::getLevelInfo(GCGLenum target, GCGLint level) const</span>
458 {
459     if (!object() || !m_target)
460         return 0;
461     int targetIndex = mapTargetToIndex(target);
462     if (targetIndex &lt; 0 || targetIndex &gt;= static_cast&lt;int&gt;(m_info.size()))
463         return 0;
<a name="54" id="anc54"></a><span class="line-modified">464     if (level &lt; 0 || level &gt;= static_cast&lt;GCGLint&gt;(m_info[targetIndex].size()))</span>
465         return 0;
466     return &amp;(m_info[targetIndex][level]);
467 }
468 
469 }
470 
471 #endif // ENABLE(WEBGL)
<a name="55" id="anc55"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="55" type="hidden" />
</body>
</html>
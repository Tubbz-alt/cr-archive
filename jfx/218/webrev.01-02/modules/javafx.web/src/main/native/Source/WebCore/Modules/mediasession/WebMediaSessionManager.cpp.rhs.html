<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasession/WebMediaSessionManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2015-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebMediaSessionManager.h&quot;
 28 
 29 #if ENABLE(WIRELESS_PLAYBACK_TARGET) &amp;&amp; !PLATFORM(IOS_FAMILY)
 30 
 31 #include &quot;FloatRect.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &quot;MediaPlaybackTargetPickerMock.h&quot;
 34 #include &quot;WebMediaSessionManagerClient.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 35 #include &lt;wtf/Algorithms.h&gt;</span>
<span class="line-added"> 36 #include &lt;wtf/Logger.h&gt;</span>
 37 #include &lt;wtf/text/StringBuilder.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 static const Seconds taskDelayInterval { 100_ms };
 42 
<a name="3" id="anc3"></a><span class="line-added"> 43 #undef LOGIDENTIFIER</span>
<span class="line-added"> 44 #define LOGIDENTIFIER __func__</span>
<span class="line-added"> 45 </span>
<span class="line-added"> 46 #undef ALWAYS_LOG</span>
<span class="line-added"> 47 #define ALWAYS_LOG logger().logAlways</span>
<span class="line-added"> 48 </span>
 49 struct ClientState {
 50     WTF_MAKE_STRUCT_FAST_ALLOCATED;
 51 
 52     explicit ClientState(WebMediaSessionManagerClient&amp; client, uint64_t contextId)
 53         : client(client)
 54         , contextId(contextId)
 55     {
 56     }
 57 
 58     bool operator == (ClientState const&amp; other) const
 59     {
 60         return contextId == other.contextId &amp;&amp; &amp;client == &amp;other.client;
 61     }
 62 
 63     WebMediaSessionManagerClient&amp; client;
 64     uint64_t contextId { 0 };
 65     WebCore::MediaProducer::MediaStateFlags flags { WebCore::MediaProducer::IsNotPlaying };
 66     bool requestedPicker { false };
 67     bool previouslyRequestedPicker { false };
 68     bool configurationRequired { true };
 69     bool playedToEnd { false };
 70 };
 71 
 72 static bool flagsAreSet(MediaProducer::MediaStateFlags value, unsigned flags)
 73 {
 74     return value &amp; flags;
 75 }
 76 
<a name="4" id="anc4"></a><span class="line-modified"> 77 String mediaProducerStateString(MediaProducer::MediaStateFlags flags)</span>

 78 {
 79     StringBuilder string;
 80     if (flags &amp; MediaProducer::IsPlayingAudio)
<a name="5" id="anc5"></a><span class="line-modified"> 81         string.append(&quot;IsPlayingAudio+&quot;);</span>
 82     if (flags &amp; MediaProducer::IsPlayingVideo)
<a name="6" id="anc6"></a><span class="line-modified"> 83         string.append(&quot;IsPlayingVideo+&quot;);</span>
 84     if (flags &amp; MediaProducer::IsPlayingToExternalDevice)
<a name="7" id="anc7"></a><span class="line-modified"> 85         string.append(&quot;IsPlayingToExternalDevice+&quot;);</span>
 86     if (flags &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
<a name="8" id="anc8"></a><span class="line-modified"> 87         string.append(&quot;HasTargetAvailabilityListener+&quot;);</span>
 88     if (flags &amp; MediaProducer::RequiresPlaybackTargetMonitoring)
<a name="9" id="anc9"></a><span class="line-modified"> 89         string.append(&quot;RequiresTargetMonitoring+&quot;);</span>
 90     if (flags &amp; MediaProducer::ExternalDeviceAutoPlayCandidate)
<a name="10" id="anc10"></a><span class="line-modified"> 91         string.append(&quot;ExternalDeviceAutoPlayCandidate+&quot;);</span>
 92     if (flags &amp; MediaProducer::DidPlayToEnd)
<a name="11" id="anc11"></a><span class="line-modified"> 93         string.append(&quot;DidPlayToEnd+&quot;);</span>
 94     if (flags &amp; MediaProducer::HasAudioOrVideo)
<a name="12" id="anc12"></a><span class="line-modified"> 95         string.append(&quot;HasAudioOrVideo+&quot;);</span>
 96     if (string.isEmpty())
 97         string.append(&quot;IsNotPlaying&quot;);
 98     else
<a name="13" id="anc13"></a><span class="line-modified"> 99         string.resize(string.length() - 1);</span>
100 
<a name="14" id="anc14"></a><span class="line-modified">101     return makeString(&quot; { &quot;, string.toString(), &quot; }&quot;);</span>
102 }
<a name="15" id="anc15"></a>
103 
<a name="16" id="anc16"></a><span class="line-modified">104 class WebMediaSessionLogger {</span>
<span class="line-added">105     WTF_MAKE_NONCOPYABLE(WebMediaSessionLogger);</span>
<span class="line-added">106     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-added">107 public:</span>
<span class="line-added">108 </span>
<span class="line-added">109     static std::unique_ptr&lt;WebMediaSessionLogger&gt; create(WebMediaSessionManager&amp; manager)</span>
<span class="line-added">110     {</span>
<span class="line-added">111         return makeUnique&lt;WebMediaSessionLogger&gt;(manager);</span>
<span class="line-added">112     }</span>
<span class="line-added">113 </span>
<span class="line-added">114     template&lt;typename... Arguments&gt;</span>
<span class="line-added">115     inline void logAlways(const char* methodName, ClientState* state, const Arguments&amp;... arguments) const</span>
<span class="line-added">116     {</span>
<span class="line-added">117         if (!state-&gt;client.alwaysOnLoggingAllowed())</span>
<span class="line-added">118             return;</span>
<span class="line-added">119 </span>
<span class="line-added">120         m_logger-&gt;logAlways(LogMedia, makeString(&quot;WebMediaSessionManager::&quot;, methodName, &#39; &#39;), state-&gt;contextId, state-&gt;flags, arguments...);</span>
<span class="line-added">121     }</span>
<span class="line-added">122 </span>
<span class="line-added">123     template&lt;typename... Arguments&gt;</span>
<span class="line-added">124     inline void logAlways(const char* methodName, const Arguments&amp;... arguments) const</span>
<span class="line-added">125     {</span>
<span class="line-added">126         if (!m_manager.alwaysOnLoggingAllowed())</span>
<span class="line-added">127             return;</span>
<span class="line-added">128 </span>
<span class="line-added">129         m_logger-&gt;logAlways(LogMedia, makeString(&quot;WebMediaSessionManager::&quot;, methodName, &#39; &#39;), arguments...);</span>
<span class="line-added">130     }</span>
<span class="line-added">131 </span>
<span class="line-added">132 private:</span>
<span class="line-added">133     friend std::unique_ptr&lt;WebMediaSessionLogger&gt; std::make_unique&lt;WebMediaSessionLogger&gt;(WebMediaSessionManager&amp;);</span>
<span class="line-added">134     WebMediaSessionLogger(WebMediaSessionManager&amp; manager)</span>
<span class="line-added">135         : m_manager(manager)</span>
<span class="line-added">136         , m_logger(Logger::create(this))</span>
<span class="line-added">137     {</span>
<span class="line-added">138     }</span>
<span class="line-added">139 </span>
<span class="line-added">140     WebMediaSessionManager&amp; m_manager;</span>
<span class="line-added">141     Ref&lt;Logger&gt; m_logger;</span>
<span class="line-added">142 };</span>
<span class="line-added">143 </span>
<span class="line-added">144 WebMediaSessionLogger&amp; WebMediaSessionManager::logger()</span>
145 {
<a name="17" id="anc17"></a><span class="line-modified">146     if (!m_logger)</span>
<span class="line-added">147         m_logger = WebMediaSessionLogger::create(*this);</span>
148 
<a name="18" id="anc18"></a><span class="line-added">149     return *m_logger;</span>
<span class="line-added">150 }</span>
<span class="line-added">151 </span>
<span class="line-added">152 bool WebMediaSessionManager::alwaysOnLoggingAllowed() const</span>
<span class="line-added">153 {</span>
<span class="line-added">154     return allOf(m_clientState, [] (auto&amp; state) {</span>
<span class="line-added">155         return state-&gt;client.alwaysOnLoggingAllowed();</span>
<span class="line-added">156     });</span>
<span class="line-added">157 }</span>
<span class="line-added">158 </span>
<span class="line-added">159 void WebMediaSessionManager::setMockMediaPlaybackTargetPickerEnabled(bool enabled)</span>
<span class="line-added">160 {</span>
161     if (m_mockPickerEnabled == enabled)
162         return;
163 
<a name="19" id="anc19"></a><span class="line-added">164     ALWAYS_LOG(LOGIDENTIFIER);</span>
165     m_mockPickerEnabled = enabled;
166 }
167 
168 void WebMediaSessionManager::setMockMediaPlaybackTargetPickerState(const String&amp; name, MediaPlaybackTargetContext::State state)
169 {
<a name="20" id="anc20"></a><span class="line-modified">170     ALWAYS_LOG(LOGIDENTIFIER);</span>

171     mockPicker().setState(name, state);
172 }
173 
<a name="21" id="anc21"></a><span class="line-added">174 void WebMediaSessionManager::mockMediaPlaybackTargetPickerDismissPopup()</span>
<span class="line-added">175 {</span>
<span class="line-added">176     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">177     mockPicker().dismissPopup();</span>
<span class="line-added">178 }</span>
<span class="line-added">179 </span>
180 MediaPlaybackTargetPickerMock&amp; WebMediaSessionManager::mockPicker()
181 {
182     if (!m_pickerOverride)
183         m_pickerOverride = makeUnique&lt;MediaPlaybackTargetPickerMock&gt;(*this);
184 
185     return *m_pickerOverride.get();
186 }
187 
188 WebCore::MediaPlaybackTargetPicker&amp; WebMediaSessionManager::targetPicker()
189 {
190     if (m_mockPickerEnabled)
191         return mockPicker();
192 
193     return platformPicker();
194 }
195 
196 WebMediaSessionManager::WebMediaSessionManager()
197     : m_taskTimer(RunLoop::current(), this, &amp;WebMediaSessionManager::taskTimerFired)
198     , m_watchdogTimer(RunLoop::current(), this, &amp;WebMediaSessionManager::watchdogTimerFired)
199 {
200 }
201 
202 WebMediaSessionManager::~WebMediaSessionManager() = default;
203 
204 uint64_t WebMediaSessionManager::addPlaybackTargetPickerClient(WebMediaSessionManagerClient&amp; client, uint64_t contextId)
205 {
206     size_t index = find(&amp;client, contextId);
207     ASSERT(index == notFound);
208     if (index != notFound)
209         return 0;
210 
<a name="22" id="anc22"></a><span class="line-modified">211     ALWAYS_LOG(LOGIDENTIFIER, contextId);</span>

212     m_clientState.append(makeUnique&lt;ClientState&gt;(client, contextId));
213 
214     if (m_externalOutputDeviceAvailable || m_playbackTarget)
215         scheduleDelayedTask(InitialConfigurationTask | TargetClientsConfigurationTask);
216 
217     return contextId;
218 }
219 
220 void WebMediaSessionManager::removePlaybackTargetPickerClient(WebMediaSessionManagerClient&amp; client, uint64_t contextId)
221 {
222     size_t index = find(&amp;client, contextId);
223     ASSERT(index != notFound);
224     if (index == notFound)
225         return;
226 
<a name="23" id="anc23"></a><span class="line-modified">227     ALWAYS_LOG(LOGIDENTIFIER, m_clientState[index].get());</span>
228 
229     m_clientState.remove(index);
230     scheduleDelayedTask(TargetMonitoringConfigurationTask | TargetClientsConfigurationTask);
231 }
232 
233 void WebMediaSessionManager::removeAllPlaybackTargetPickerClients(WebMediaSessionManagerClient&amp; client)
234 {
235     if (m_clientState.isEmpty())
236         return;
237 
<a name="24" id="anc24"></a>

238     for (size_t i = m_clientState.size(); i &gt; 0; --i) {
<a name="25" id="anc25"></a><span class="line-modified">239         if (&amp;m_clientState[i - 1]-&gt;client == &amp;client) {</span>
<span class="line-added">240             ALWAYS_LOG(LOGIDENTIFIER, m_clientState[i - 1].get());</span>
241             m_clientState.remove(i - 1);
<a name="26" id="anc26"></a><span class="line-added">242         }</span>
243     }
244     scheduleDelayedTask(TargetMonitoringConfigurationTask | TargetClientsConfigurationTask);
245 }
246 
247 void WebMediaSessionManager::showPlaybackTargetPicker(WebMediaSessionManagerClient&amp; client, uint64_t contextId, const IntRect&amp; rect, bool, bool useDarkAppearance)
248 {
249     size_t index = find(&amp;client, contextId);
250     ASSERT(index != notFound);
251     if (index == notFound)
252         return;
253 
254     auto&amp; clientRequestingPicker = m_clientState[index];
255     for (auto&amp; state : m_clientState) {
256         state-&gt;requestedPicker = state == clientRequestingPicker;
257         state-&gt;previouslyRequestedPicker = state == clientRequestingPicker;
258     }
259 
<a name="27" id="anc27"></a><span class="line-added">260     ALWAYS_LOG(LOGIDENTIFIER, m_clientState[index].get());</span>
<span class="line-added">261 </span>
262     bool hasActiveRoute = flagsAreSet(m_clientState[index]-&gt;flags, MediaProducer::IsPlayingToExternalDevice);
<a name="28" id="anc28"></a>
263     targetPicker().showPlaybackTargetPicker(FloatRect(rect), hasActiveRoute, useDarkAppearance);
264 }
265 
266 void WebMediaSessionManager::clientStateDidChange(WebMediaSessionManagerClient&amp; client, uint64_t contextId, MediaProducer::MediaStateFlags newFlags)
267 {
268     size_t index = find(&amp;client, contextId);
269     ASSERT(index != notFound);
270     if (index == notFound)
271         return;
272 
273     auto&amp; changedClientState = m_clientState[index];
274     MediaProducer::MediaStateFlags oldFlags = changedClientState-&gt;flags;
275     if (newFlags == oldFlags)
276         return;
277 
<a name="29" id="anc29"></a><span class="line-modified">278     ALWAYS_LOG(LOGIDENTIFIER, m_clientState[index].get(), &quot;new flags = &quot;, newFlags);</span>
279 
280     changedClientState-&gt;flags = newFlags;
281 
282     MediaProducer::MediaStateFlags updateConfigurationFlags = MediaProducer::RequiresPlaybackTargetMonitoring | MediaProducer::HasPlaybackTargetAvailabilityListener | MediaProducer::HasAudioOrVideo;
283     if ((oldFlags &amp; updateConfigurationFlags) != (newFlags &amp; updateConfigurationFlags))
284         scheduleDelayedTask(TargetMonitoringConfigurationTask);
285 
286     MediaProducer::MediaStateFlags playingToTargetFlags = MediaProducer::IsPlayingToExternalDevice | MediaProducer::IsPlayingVideo;
287     if ((oldFlags &amp; playingToTargetFlags) != (newFlags &amp; playingToTargetFlags)) {
288         if (flagsAreSet(oldFlags, MediaProducer::IsPlayingVideo) &amp;&amp; !flagsAreSet(newFlags, MediaProducer::IsPlayingVideo) &amp;&amp; flagsAreSet(newFlags, MediaProducer::DidPlayToEnd))
289             changedClientState-&gt;playedToEnd = true;
290         scheduleDelayedTask(WatchdogTimerConfigurationTask);
291     }
292 
293     if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute() || !flagsAreSet(newFlags, MediaProducer::ExternalDeviceAutoPlayCandidate))
294         return;
295 
296     // Do not interrupt another element already playing to a device.
297     for (auto&amp; state : m_clientState) {
298         if (state == changedClientState)
299             continue;
300 
<a name="30" id="anc30"></a><span class="line-modified">301         if (flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice) &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingVideo)) {</span>
<span class="line-added">302             ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; returning early&quot;);</span>
303             return;
<a name="31" id="anc31"></a><span class="line-added">304         }</span>
305     }
306 
307     // Do not begin playing to the device unless playback has just started.
<a name="32" id="anc32"></a><span class="line-modified">308     if (!flagsAreSet(newFlags, MediaProducer::IsPlayingVideo) || flagsAreSet(oldFlags, MediaProducer::IsPlayingVideo)) {</span>
<span class="line-added">309         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning early, playback didn&#39;t just start&quot;);</span>
310         return;
<a name="33" id="anc33"></a><span class="line-added">311     }</span>
312 
313     for (auto&amp; state : m_clientState) {
314         if (state == changedClientState)
315             continue;
<a name="34" id="anc34"></a><span class="line-added">316         ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; calling setShouldPlayToPlaybackTarget(false)&quot;);</span>
317         state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, false);
318     }
319 
<a name="35" id="anc35"></a><span class="line-added">320     ALWAYS_LOG(LOGIDENTIFIER, changedClientState.get(), &quot; calling setShouldPlayToPlaybackTarget(true)&quot;);</span>
321     changedClientState-&gt;client.setShouldPlayToPlaybackTarget(changedClientState-&gt;contextId, true);
322 
323     if (index &amp;&amp; m_clientState.size() &gt; 1)
324         std::swap(m_clientState.at(index), m_clientState.at(0));
325 }
326 
327 void WebMediaSessionManager::setPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
328 {
<a name="36" id="anc36"></a><span class="line-added">329     ALWAYS_LOG(LOGIDENTIFIER, &quot;has active route = &quot;, target-&gt;hasActiveRoute());</span>
330     m_playbackTarget = WTFMove(target);
331     m_targetChanged = true;
332     scheduleDelayedTask(TargetClientsConfigurationTask);
333 }
334 
335 void WebMediaSessionManager::externalOutputDeviceAvailableDidChange(bool available)
336 {
<a name="37" id="anc37"></a><span class="line-modified">337     ALWAYS_LOG(LOGIDENTIFIER, available);</span>

338     m_externalOutputDeviceAvailable = available;
339     for (auto&amp; state : m_clientState)
340         state-&gt;client.externalOutputDeviceAvailableDidChange(state-&gt;contextId, available);
341 }
342 
<a name="38" id="anc38"></a><span class="line-added">343 void WebMediaSessionManager::playbackTargetPickerWasDismissed()</span>
<span class="line-added">344 {</span>
<span class="line-added">345     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">346     m_playbackTargetPickerDismissed = true;</span>
<span class="line-added">347     scheduleDelayedTask(TargetClientsConfigurationTask);</span>
<span class="line-added">348 }</span>
<span class="line-added">349 </span>
350 void WebMediaSessionManager::configureNewClients()
351 {
352     for (auto&amp; state : m_clientState) {
353         if (!state-&gt;configurationRequired)
354             continue;
355 
356         state-&gt;configurationRequired = false;
357         if (m_externalOutputDeviceAvailable)
358             state-&gt;client.externalOutputDeviceAvailableDidChange(state-&gt;contextId, true);
359 
360         if (m_playbackTarget)
361             state-&gt;client.setPlaybackTarget(state-&gt;contextId, *m_playbackTarget.copyRef());
362     }
363 }
364 
365 void WebMediaSessionManager::configurePlaybackTargetClients()
366 {
367     if (m_clientState.isEmpty())
368         return;
369 
370     size_t indexOfClientThatRequestedPicker = notFound;
371     size_t indexOfLastClientToRequestPicker = notFound;
372     size_t indexOfClientWillPlayToTarget = notFound;
373     bool haveActiveRoute = m_playbackTarget &amp;&amp; m_playbackTarget-&gt;hasActiveRoute();
374 
375     for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
376         auto&amp; state = m_clientState[i];
377 
<a name="39" id="anc39"></a><span class="line-modified">378         ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot;, requestedPicker = &quot;, state-&gt;requestedPicker);</span>
379 
<a name="40" id="anc40"></a><span class="line-modified">380         if ((m_targetChanged || m_playbackTargetPickerDismissed) &amp;&amp; state-&gt;requestedPicker)</span>
381             indexOfClientThatRequestedPicker = i;
382 
383         if (indexOfClientWillPlayToTarget == notFound &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice))
384             indexOfClientWillPlayToTarget = i;
385 
386         if (indexOfClientWillPlayToTarget == notFound &amp;&amp; haveActiveRoute &amp;&amp; state-&gt;previouslyRequestedPicker)
387             indexOfLastClientToRequestPicker = i;
388     }
389 
390     if (indexOfClientThatRequestedPicker != notFound)
391         indexOfClientWillPlayToTarget = indexOfClientThatRequestedPicker;
392     if (indexOfClientWillPlayToTarget == notFound &amp;&amp; indexOfLastClientToRequestPicker != notFound)
393         indexOfClientWillPlayToTarget = indexOfLastClientToRequestPicker;
394     if (indexOfClientWillPlayToTarget == notFound &amp;&amp; haveActiveRoute &amp;&amp; flagsAreSet(m_clientState[0]-&gt;flags, MediaProducer::ExternalDeviceAutoPlayCandidate) &amp;&amp; !flagsAreSet(m_clientState[0]-&gt;flags, MediaProducer::IsPlayingVideo))
395         indexOfClientWillPlayToTarget = 0;
396 
<a name="41" id="anc41"></a>

397     for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
398         auto&amp; state = m_clientState[i];
399 
400         if (m_playbackTarget)
401             state-&gt;client.setPlaybackTarget(state-&gt;contextId, *m_playbackTarget.copyRef());
402 
<a name="42" id="anc42"></a><span class="line-modified">403         if (i != indexOfClientWillPlayToTarget || !haveActiveRoute) {</span>
<span class="line-added">404             ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; calling setShouldPlayToPlaybackTarget(false)&quot;);</span>
405             state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, false);
<a name="43" id="anc43"></a><span class="line-added">406         }</span>
<span class="line-added">407 </span>
<span class="line-added">408         if (state-&gt;requestedPicker &amp;&amp; m_playbackTargetPickerDismissed) {</span>
<span class="line-added">409             ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; calling playbackTargetPickerWasDismissed&quot;);</span>
<span class="line-added">410             state-&gt;client.playbackTargetPickerWasDismissed(state-&gt;contextId);</span>
<span class="line-added">411         }</span>
412 
413         state-&gt;configurationRequired = false;
<a name="44" id="anc44"></a><span class="line-modified">414         if (m_targetChanged || m_playbackTargetPickerDismissed)</span>
415             state-&gt;requestedPicker = false;
416     }
417 
418     if (haveActiveRoute &amp;&amp; indexOfClientWillPlayToTarget != notFound) {
419         auto&amp; state = m_clientState[indexOfClientWillPlayToTarget];
<a name="45" id="anc45"></a><span class="line-modified">420         if (!flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice)) {</span>
<span class="line-added">421             ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; calling setShouldPlayToPlaybackTarget(true)&quot;);</span>
422             state-&gt;client.setShouldPlayToPlaybackTarget(state-&gt;contextId, true);
<a name="46" id="anc46"></a><span class="line-added">423         }</span>
424     }
425 
426     m_targetChanged = false;
427     configureWatchdogTimer();
428 }
429 
430 void WebMediaSessionManager::configurePlaybackTargetMonitoring()
431 {
432     bool monitoringRequired = false;
433     bool hasAvailabilityListener = false;
434     bool haveClientWithMedia = false;
435     for (auto&amp; state : m_clientState) {
<a name="47" id="anc47"></a><span class="line-added">436         ALWAYS_LOG(LOGIDENTIFIER, state.get());</span>
437         if (state-&gt;flags &amp; MediaProducer::RequiresPlaybackTargetMonitoring) {
438             monitoringRequired = true;
439             break;
440         }
441         if (state-&gt;flags &amp; MediaProducer::HasPlaybackTargetAvailabilityListener)
442             hasAvailabilityListener = true;
443         if (state-&gt;flags &amp; MediaProducer::HasAudioOrVideo)
444             haveClientWithMedia = true;
445     }
446 
<a name="48" id="anc48"></a><span class="line-modified">447     if (monitoringRequired || (hasAvailabilityListener &amp;&amp; haveClientWithMedia)) {</span>
<span class="line-modified">448         ALWAYS_LOG(LOGIDENTIFIER, &quot;starting monitoring&quot;);</span>

449         targetPicker().startingMonitoringPlaybackTargets();
<a name="49" id="anc49"></a><span class="line-modified">450     } else {</span>
<span class="line-added">451         ALWAYS_LOG(LOGIDENTIFIER, &quot;stopping monitoring&quot;);</span>
452         targetPicker().stopMonitoringPlaybackTargets();
<a name="50" id="anc50"></a><span class="line-added">453     }</span>
454 }
455 
<a name="51" id="anc51"></a>




















456 void WebMediaSessionManager::scheduleDelayedTask(ConfigurationTasks tasks)
457 {
<a name="52" id="anc52"></a>

458     m_taskFlags |= tasks;
459     m_taskTimer.startOneShot(taskDelayInterval);
460 }
461 
462 void WebMediaSessionManager::taskTimerFired()
463 {
<a name="53" id="anc53"></a>

464     if (m_taskFlags &amp; InitialConfigurationTask)
465         configureNewClients();
466     if (m_taskFlags &amp; TargetClientsConfigurationTask)
467         configurePlaybackTargetClients();
468     if (m_taskFlags &amp; TargetMonitoringConfigurationTask)
469         configurePlaybackTargetMonitoring();
470     if (m_taskFlags &amp; WatchdogTimerConfigurationTask)
471         configureWatchdogTimer();
472 
473     m_taskFlags = NoTask;
474 }
475 
476 size_t WebMediaSessionManager::find(WebMediaSessionManagerClient* client, uint64_t contextId)
477 {
478     for (size_t i = 0; i &lt; m_clientState.size(); ++i) {
479         if (m_clientState[i]-&gt;contextId == contextId &amp;&amp; &amp;m_clientState[i]-&gt;client == client)
480             return i;
481     }
482 
483     return notFound;
484 }
485 
486 void WebMediaSessionManager::configureWatchdogTimer()
487 {
488     static const Seconds watchdogTimerIntervalAfterPausing { 1_h };
489     static const Seconds watchdogTimerIntervalAfterPlayingToEnd { 8_min };
490 
491     if (!m_playbackTarget || !m_playbackTarget-&gt;hasActiveRoute()) {
<a name="54" id="anc54"></a><span class="line-modified">492         if (m_watchdogTimer.isActive()) {</span>
<span class="line-added">493             ALWAYS_LOG(LOGIDENTIFIER, &quot;stopping timer&quot;);</span>
<span class="line-added">494             m_currentWatchdogInterval = { };</span>
<span class="line-added">495             m_watchdogTimer.stop();</span>
<span class="line-added">496         }</span>
<span class="line-added">497 </span>
498         return;
499     }
500 
501     bool stopTimer = false;
502     bool didPlayToEnd = false;
503     for (auto&amp; state : m_clientState) {
<a name="55" id="anc55"></a><span class="line-added">504 </span>
<span class="line-added">505         ALWAYS_LOG(LOGIDENTIFIER, state.get(), &quot; playedToEnd = &quot;, state-&gt;playedToEnd);</span>
<span class="line-added">506 </span>
507         if (flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingToExternalDevice) &amp;&amp; flagsAreSet(state-&gt;flags, MediaProducer::IsPlayingVideo))
508             stopTimer = true;
509         if (state-&gt;playedToEnd)
510             didPlayToEnd = true;
511         state-&gt;playedToEnd = false;
512     }
513 
514     if (stopTimer) {
<a name="56" id="anc56"></a><span class="line-added">515         ALWAYS_LOG(LOGIDENTIFIER, &quot;stopping timer&quot;);</span>
516         m_currentWatchdogInterval = { };
517         m_watchdogTimer.stop();
<a name="57" id="anc57"></a>
518     } else {
519         Seconds interval = didPlayToEnd ? watchdogTimerIntervalAfterPlayingToEnd : watchdogTimerIntervalAfterPausing;
520         if (interval != m_currentWatchdogInterval || !m_watchdogTimer.isActive()) {
521             m_watchdogTimer.startOneShot(interval);
<a name="58" id="anc58"></a>
522         }
<a name="59" id="anc59"></a><span class="line-added">523         ALWAYS_LOG(LOGIDENTIFIER, &quot;timer scheduled for &quot;, interval.value(), &quot; seconds&quot;);</span>
524         m_currentWatchdogInterval = interval;
525     }
526 }
527 
528 void WebMediaSessionManager::watchdogTimerFired()
529 {
<a name="60" id="anc60"></a>
530     if (!m_playbackTarget)
531         return;
532 
<a name="61" id="anc61"></a><span class="line-added">533     ALWAYS_LOG(LOGIDENTIFIER);</span>
534     targetPicker().invalidatePlaybackTargets();
535 }
536 
537 } // namespace WebCore
538 
539 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET) &amp;&amp; !PLATFORM(IOS_FAMILY)
<a name="62" id="anc62"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="62" type="hidden" />
</body>
</html>
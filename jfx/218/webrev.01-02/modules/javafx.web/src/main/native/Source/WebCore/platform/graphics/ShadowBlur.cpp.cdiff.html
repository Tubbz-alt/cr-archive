<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ShadowBlur.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RoundedRect.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TrackPrivateBase.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ShadowBlur.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 59,20 ***</span>
      WTF_MAKE_FAST_ALLOCATED;
  public:
      ScratchBuffer()
          : m_purgeTimer(*this, &amp;ScratchBuffer::clearScratchBuffer)
          , m_lastWasInset(false)
<span class="line-modified">! #if !ASSERT_DISABLED</span>
          , m_bufferInUse(false)
  #endif
      {
      }
  
      ImageBuffer* getScratchBuffer(const IntSize&amp; size)
      {
          ASSERT(!m_bufferInUse);
<span class="line-modified">! #if !ASSERT_DISABLED</span>
          m_bufferInUse = true;
  #endif
          // We do not need to recreate the buffer if the current buffer is large enough.
          if (m_imageBuffer &amp;&amp; m_imageBuffer-&gt;logicalSize().width() &gt;= size.width() &amp;&amp; m_imageBuffer-&gt;logicalSize().height() &gt;= size.height())
              return m_imageBuffer.get();
<span class="line-new-header">--- 59,20 ---</span>
      WTF_MAKE_FAST_ALLOCATED;
  public:
      ScratchBuffer()
          : m_purgeTimer(*this, &amp;ScratchBuffer::clearScratchBuffer)
          , m_lastWasInset(false)
<span class="line-modified">! #if ASSERT_ENABLED</span>
          , m_bufferInUse(false)
  #endif
      {
      }
  
      ImageBuffer* getScratchBuffer(const IntSize&amp; size)
      {
          ASSERT(!m_bufferInUse);
<span class="line-modified">! #if ASSERT_ENABLED</span>
          m_bufferInUse = true;
  #endif
          // We do not need to recreate the buffer if the current buffer is large enough.
          if (m_imageBuffer &amp;&amp; m_imageBuffer-&gt;logicalSize().width() &gt;= size.width() &amp;&amp; m_imageBuffer-&gt;logicalSize().height() &gt;= size.height())
              return m_imageBuffer.get();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 81,11 ***</span>
          IntSize roundedSize(roundUpToMultipleOf32(size.width()), roundUpToMultipleOf32(size.height()));
  
          clearScratchBuffer();
  
          // ShadowBlur is not used with accelerated drawing, so it&#39;s OK to make an unconditionally unaccelerated buffer.
<span class="line-modified">!         m_imageBuffer = ImageBuffer::create(roundedSize, Unaccelerated, 1);</span>
          return m_imageBuffer.get();
      }
  
      bool setCachedShadowValues(const FloatSize&amp; radius, const Color&amp; color, const FloatRect&amp; shadowRect, const FloatRoundedRect::Radii&amp; radii, const FloatSize&amp; layerSize)
      {
<span class="line-new-header">--- 81,11 ---</span>
          IntSize roundedSize(roundUpToMultipleOf32(size.width()), roundUpToMultipleOf32(size.height()));
  
          clearScratchBuffer();
  
          // ShadowBlur is not used with accelerated drawing, so it&#39;s OK to make an unconditionally unaccelerated buffer.
<span class="line-modified">!         m_imageBuffer = ImageBuffer::create(roundedSize, RenderingMode::Unaccelerated, 1);</span>
          return m_imageBuffer.get();
      }
  
      bool setCachedShadowValues(const FloatSize&amp; radius, const Color&amp; color, const FloatRect&amp; shadowRect, const FloatRoundedRect::Radii&amp; radii, const FloatSize&amp; layerSize)
      {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 117,11 ***</span>
          return true;
      }
  
      void scheduleScratchBufferPurge()
      {
<span class="line-modified">! #if !ASSERT_DISABLED</span>
          m_bufferInUse = false;
  #endif
          if (m_purgeTimer.isActive())
              m_purgeTimer.stop();
  
<span class="line-new-header">--- 117,11 ---</span>
          return true;
      }
  
      void scheduleScratchBufferPurge()
      {
<span class="line-modified">! #if ASSERT_ENABLED</span>
          m_bufferInUse = false;
  #endif
          if (m_purgeTimer.isActive())
              m_purgeTimer.stop();
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 148,11 ***</span>
      Color m_lastColor;
      FloatSize m_lastRadius;
      bool m_lastWasInset;
      FloatSize m_lastLayerSize;
  
<span class="line-modified">! #if !ASSERT_DISABLED</span>
      bool m_bufferInUse;
  #endif
  };
  
  ScratchBuffer&amp; ScratchBuffer::singleton()
<span class="line-new-header">--- 148,11 ---</span>
      Color m_lastColor;
      FloatSize m_lastRadius;
      bool m_lastWasInset;
      FloatSize m_lastLayerSize;
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
      bool m_bufferInUse;
  #endif
  };
  
  ScratchBuffer&amp; ScratchBuffer::singleton()
</pre>
<hr />
<pre>
<span class="line-old-header">*** 591,11 ***</span>
          drawInsetShadowWithoutTiling(transform, fullRect, holeRect, *layerImageProperties, drawBuffer);
  }
  
  void ShadowBlur::drawRectShadowWithoutTiling(const AffineTransform&amp;, const FloatRoundedRect&amp; shadowedRect, const LayerImageProperties&amp; layerImageProperties, const DrawBufferCallback&amp; drawBuffer)
  {
<span class="line-modified">!     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties.layerSize), Unaccelerated, 1);</span>
      if (!layerImage)
          return;
  
      GraphicsContext&amp; shadowContext = layerImage-&gt;context();
      GraphicsContextStateSaver stateSaver(shadowContext);
<span class="line-new-header">--- 591,11 ---</span>
          drawInsetShadowWithoutTiling(transform, fullRect, holeRect, *layerImageProperties, drawBuffer);
  }
  
  void ShadowBlur::drawRectShadowWithoutTiling(const AffineTransform&amp;, const FloatRoundedRect&amp; shadowedRect, const LayerImageProperties&amp; layerImageProperties, const DrawBufferCallback&amp; drawBuffer)
  {
<span class="line-modified">!     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties.layerSize), RenderingMode::Unaccelerated, 1);</span>
      if (!layerImage)
          return;
  
      GraphicsContext&amp; shadowContext = layerImage-&gt;context();
      GraphicsContextStateSaver stateSaver(shadowContext);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 619,11 ***</span>
      drawBuffer(*layerImage, layerImageProperties.layerOrigin, layerImageProperties.layerSize);
  }
  
  void ShadowBlur::drawInsetShadowWithoutTiling(const AffineTransform&amp;, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const LayerImageProperties&amp; layerImageProperties, const DrawBufferCallback&amp; drawBuffer)
  {
<span class="line-modified">!     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties.layerSize), Unaccelerated, 1);</span>
      if (!layerImage)
          return;
  
      {
          GraphicsContext&amp; shadowContext = layerImage-&gt;context();
<span class="line-new-header">--- 619,11 ---</span>
      drawBuffer(*layerImage, layerImageProperties.layerOrigin, layerImageProperties.layerSize);
  }
  
  void ShadowBlur::drawInsetShadowWithoutTiling(const AffineTransform&amp;, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const LayerImageProperties&amp; layerImageProperties, const DrawBufferCallback&amp; drawBuffer)
  {
<span class="line-modified">!     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties.layerSize), RenderingMode::Unaccelerated, 1);</span>
      if (!layerImage)
          return;
  
      {
          GraphicsContext&amp; shadowContext = layerImage-&gt;context();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 683,11 ***</span>
  {
  #if USE(CG)
      auto* layerImage = ScratchBuffer::singleton().getScratchBuffer(templateSize);
  #else
      UNUSED_PARAM(layerImageProperties);
<span class="line-modified">!     auto layerImageBuffer = ImageBuffer::create(templateSize, Unaccelerated, 1);</span>
      auto* layerImage = layerImageBuffer.get();
  #endif
  
      if (!layerImage)
          return;
<span class="line-new-header">--- 683,11 ---</span>
  {
  #if USE(CG)
      auto* layerImage = ScratchBuffer::singleton().getScratchBuffer(templateSize);
  #else
      UNUSED_PARAM(layerImageProperties);
<span class="line-modified">!     auto layerImageBuffer = ImageBuffer::create(templateSize, RenderingMode::Unaccelerated, 1);</span>
      auto* layerImage = layerImageBuffer.get();
  #endif
  
      if (!layerImage)
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 737,11 ***</span>
  void ShadowBlur::drawInsetShadowWithTiling(const AffineTransform&amp; transform, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const IntSize&amp; templateSize, const IntSize&amp; edgeSize, const DrawImageCallback&amp; drawImage, const FillRectWithHoleCallback&amp; fillRectWithHole)
  {
  #if USE(CG)
      auto* layerImage = ScratchBuffer::singleton().getScratchBuffer(templateSize);
  #else
<span class="line-modified">!     auto layerImageBuffer = ImageBuffer::create(templateSize, Unaccelerated, 1);</span>
      auto* layerImage = layerImageBuffer.get();
  #endif
  
      if (!layerImage)
          return;
<span class="line-new-header">--- 737,11 ---</span>
  void ShadowBlur::drawInsetShadowWithTiling(const AffineTransform&amp; transform, const FloatRect&amp; fullRect, const FloatRoundedRect&amp; holeRect, const IntSize&amp; templateSize, const IntSize&amp; edgeSize, const DrawImageCallback&amp; drawImage, const FillRectWithHoleCallback&amp; fillRectWithHole)
  {
  #if USE(CG)
      auto* layerImage = ScratchBuffer::singleton().getScratchBuffer(templateSize);
  #else
<span class="line-modified">!     auto layerImageBuffer = ImageBuffer::create(templateSize, RenderingMode::Unaccelerated, 1);</span>
      auto* layerImage = layerImageBuffer.get();
  #endif
  
      if (!layerImage)
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 897,11 ***</span>
      blurShadowBuffer(layerImage, templateSize);
  
      // Mask the image with the shadow color.
      GraphicsContext&amp; shadowContext = layerImage.context();
      GraphicsContextStateSaver stateSaver(shadowContext);
<span class="line-modified">!     shadowContext.setCompositeOperation(CompositeSourceIn);</span>
      shadowContext.setFillColor(m_color);
      shadowContext.fillRect(FloatRect(0, 0, templateSize.width(), templateSize.height()));
  }
  
  void ShadowBlur::drawShadowLayer(const AffineTransform&amp; transform, const IntRect&amp; clipBounds, const FloatRect&amp; layerArea, const DrawShadowCallback&amp; drawShadow, const DrawBufferCallback&amp; drawBuffer)
<span class="line-new-header">--- 897,11 ---</span>
      blurShadowBuffer(layerImage, templateSize);
  
      // Mask the image with the shadow color.
      GraphicsContext&amp; shadowContext = layerImage.context();
      GraphicsContextStateSaver stateSaver(shadowContext);
<span class="line-modified">!     shadowContext.setCompositeOperation(CompositeOperator::SourceIn);</span>
      shadowContext.setFillColor(m_color);
      shadowContext.fillRect(FloatRect(0, 0, templateSize.width(), templateSize.height()));
  }
  
  void ShadowBlur::drawShadowLayer(const AffineTransform&amp; transform, const IntRect&amp; clipBounds, const FloatRect&amp; layerArea, const DrawShadowCallback&amp; drawShadow, const DrawBufferCallback&amp; drawBuffer)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 910,11 ***</span>
      if (!layerImageProperties)
          return;
  
      adjustBlurRadius(transform);
  
<span class="line-modified">!     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties-&gt;layerSize), Unaccelerated, 1);</span>
      if (!layerImage)
          return;
  
      {
          GraphicsContext&amp; shadowContext = layerImage-&gt;context();
<span class="line-new-header">--- 910,11 ---</span>
      if (!layerImageProperties)
          return;
  
      adjustBlurRadius(transform);
  
<span class="line-modified">!     auto layerImage = ImageBuffer::create(expandedIntSize(layerImageProperties-&gt;layerSize), RenderingMode::Unaccelerated, 1);</span>
      if (!layerImage)
          return;
  
      {
          GraphicsContext&amp; shadowContext = layerImage-&gt;context();
</pre>
<center><a href="RoundedRect.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TrackPrivateBase.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
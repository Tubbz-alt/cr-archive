<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedRawResource.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2     Copyright (C) 1998 Lars Knoll (knoll@mpi-hd.mpg.de)
  3     Copyright (C) 2001 Dirk Mueller &lt;mueller@kde.org&gt;
  4     Copyright (C) 2006 Samuel Weinig (sam.weinig@gmail.com)
  5     Copyright (C) 2004, 2005, 2006, 2007 Apple Inc. All rights reserved.
  6 
  7     This library is free software; you can redistribute it and/or
  8     modify it under the terms of the GNU Library General Public
  9     License as published by the Free Software Foundation; either
 10     version 2 of the License, or (at your option) any later version.
 11 
 12     This library is distributed in the hope that it will be useful,
 13     but WITHOUT ANY WARRANTY; without even the implied warranty of
 14     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15     Library General Public License for more details.
 16 
 17     You should have received a copy of the GNU Library General Public License
 18     along with this library; see the file COPYING.LIB.  If not, write to
 19     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20     Boston, MA 02110-1301, USA.
 21 */
 22 
 23 #pragma once
 24 
 25 #include &quot;CachedResource.h&quot;
 26 
 27 namespace WebCore {
 28 
 29 class CachedResourceClient;
 30 class ResourceTiming;
 31 class SharedBufferDataView;
 32 
 33 class CachedRawResource final : public CachedResource {
 34 public:
 35     CachedRawResource(CachedResourceRequest&amp;&amp;, Type, const PAL::SessionID&amp;, const CookieJar*);
 36 
 37     void setDefersLoading(bool);
 38 
 39     void setDataBufferingPolicy(DataBufferingPolicy);
 40 
 41     // FIXME: This is exposed for the InspectorInstrumentation for preflights in DocumentThreadableLoader. It&#39;s also really lame.
 42     unsigned long identifier() const { return m_identifier; }
 43 
 44     void clear();
 45 
 46     bool canReuse(const ResourceRequest&amp;) const;
 47 
 48     bool wasRedirected() const { return !m_redirectChain.isEmpty(); };
 49 
 50     void finishedTimingForWorkerLoad(ResourceTiming&amp;&amp;);
 51 
 52 private:
 53     void didAddClient(CachedResourceClient&amp;) final;
 54     void updateBuffer(SharedBuffer&amp;) final;
 55     void updateData(const char* data, unsigned length) final;
 56     void finishLoading(SharedBuffer*) final;
 57 
 58     bool shouldIgnoreHTTPStatusCodeErrors() const override { return true; }
 59     void allClientsRemoved() override;
 60 
 61     void redirectReceived(ResourceRequest&amp;&amp;, const ResourceResponse&amp;, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp;) override;
 62     void responseReceived(const ResourceResponse&amp;) override;
 63     bool shouldCacheResponse(const ResourceResponse&amp;) override;
 64     void didSendData(unsigned long long bytesSent, unsigned long long totalBytesToBeSent) override;
 65 
 66     void switchClientsToRevalidatedResource() override;
 67     bool mayTryReplaceEncodedData() const override { return m_allowEncodedDataReplacement; }
 68 
 69     Optional&lt;SharedBufferDataView&gt; calculateIncrementalDataChunk(const SharedBuffer*) const;
 70     void notifyClientsDataWasReceived(const char* data, unsigned length);
 71 
 72     unsigned long m_identifier;
 73     bool m_allowEncodedDataReplacement;
 74     bool m_inIncrementalDataNotify { false };
 75 
 76     struct RedirectPair {
 77     public:
 78         explicit RedirectPair(const ResourceRequest&amp; request, const ResourceResponse&amp; redirectResponse)
 79             : m_request(request)
 80             , m_redirectResponse(redirectResponse)
 81         {
 82         }
 83 
 84         const ResourceRequest m_request;
 85         const ResourceResponse m_redirectResponse;
 86     };
 87 
 88     Vector&lt;RedirectPair, 0, CrashOnOverflow, 0&gt; m_redirectChain;
 89 
 90     struct DelayedFinishLoading {
 91         RefPtr&lt;SharedBuffer&gt; buffer;
 92     };
 93     Optional&lt;DelayedFinishLoading&gt; m_delayedFinishLoading;
 94 };
 95 
 96 } // namespace WebCore
 97 
 98 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::CachedRawResource)
 99     static bool isType(const WebCore::CachedResource&amp; resource) { return resource.isMainOrMediaOrIconOrRawResource(); }
100 SPECIALIZE_TYPE_TRAITS_END()
    </pre>
  </body>
</html>
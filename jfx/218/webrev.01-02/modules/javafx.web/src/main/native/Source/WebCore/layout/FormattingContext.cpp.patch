diff a/modules/javafx.web/src/main/native/Source/WebCore/layout/FormattingContext.cpp b/modules/javafx.web/src/main/native/Source/WebCore/layout/FormattingContext.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/layout/FormattingContext.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/layout/FormattingContext.cpp
@@ -28,12 +28,14 @@
 
 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 
 #include "DisplayBox.h"
 #include "FormattingState.h"
+#include "InvalidationState.h"
 #include "LayoutBox.h"
 #include "LayoutContainer.h"
+#include "LayoutContext.h"
 #include "LayoutDescendantIterator.h"
 #include "LayoutState.h"
 #include "Logging.h"
 #include <wtf/IsoMallocInlines.h>
 #include <wtf/text/TextStream.h>
@@ -41,14 +43,15 @@
 namespace WebCore {
 namespace Layout {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(FormattingContext);
 
-FormattingContext::FormattingContext(const Box& formattingContextRoot, FormattingState& formattingState)
+FormattingContext::FormattingContext(const Container& formattingContextRoot, FormattingState& formattingState)
     : m_root(makeWeakPtr(formattingContextRoot))
     , m_formattingState(formattingState)
 {
+    ASSERT(formattingContextRoot.hasChild());
 #ifndef NDEBUG
     layoutState().registerFormattingContext(*this);
 #endif
 }
 
@@ -62,194 +65,279 @@
 LayoutState& FormattingContext::layoutState() const
 {
     return m_formattingState.layoutState();
 }
 
-void FormattingContext::computeOutOfFlowHorizontalGeometry(const Box& layoutBox) const
+void FormattingContext::computeOutOfFlowHorizontalGeometry(const Box& layoutBox, const HorizontalConstraints& horizontalConstraints)
 {
-    auto& layoutState = this->layoutState();
-    auto containingBlockWidth = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).paddingBoxWidth();
-
+    ASSERT(layoutBox.isOutOfFlowPositioned());
     auto compute = [&](Optional<LayoutUnit> usedWidth) {
-        auto usedValues = UsedHorizontalValues { containingBlockWidth, usedWidth, { } };
-        return Geometry::outOfFlowHorizontalGeometry(layoutState, layoutBox, usedValues);
+        return geometry().outOfFlowHorizontalGeometry(layoutBox, horizontalConstraints, { usedWidth, { } });
     };
 
+    auto containingBlockWidth = horizontalConstraints.logicalWidth;
     auto horizontalGeometry = compute({ });
-    if (auto maxWidth = Geometry::computedValueIfNotAuto(layoutBox.style().logicalMaxWidth(), containingBlockWidth)) {
+    if (auto maxWidth = geometry().computedMaxWidth(layoutBox, containingBlockWidth)) {
         auto maxHorizontalGeometry = compute(maxWidth);
-        if (horizontalGeometry.widthAndMargin.width > maxHorizontalGeometry.widthAndMargin.width)
+        if (horizontalGeometry.contentWidthAndMargin.contentWidth > maxHorizontalGeometry.contentWidthAndMargin.contentWidth)
             horizontalGeometry = maxHorizontalGeometry;
     }
 
-    if (auto minWidth = Geometry::computedValueIfNotAuto(layoutBox.style().logicalMinWidth(), containingBlockWidth)) {
+    if (auto minWidth = geometry().computedMinWidth(layoutBox, containingBlockWidth)) {
         auto minHorizontalGeometry = compute(minWidth);
-        if (horizontalGeometry.widthAndMargin.width < minHorizontalGeometry.widthAndMargin.width)
+        if (horizontalGeometry.contentWidthAndMargin.contentWidth < minHorizontalGeometry.contentWidthAndMargin.contentWidth)
             horizontalGeometry = minHorizontalGeometry;
     }
 
-    auto& displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
-    displayBox.setLeft(horizontalGeometry.left + horizontalGeometry.widthAndMargin.usedMargin.start);
-    displayBox.setContentBoxWidth(horizontalGeometry.widthAndMargin.width);
-    displayBox.setHorizontalMargin(horizontalGeometry.widthAndMargin.usedMargin);
-    displayBox.setHorizontalComputedMargin(horizontalGeometry.widthAndMargin.computedMargin);
+    auto& displayBox = formattingState().displayBox(layoutBox);
+    displayBox.setLeft(horizontalGeometry.left + horizontalGeometry.contentWidthAndMargin.usedMargin.start);
+    displayBox.setContentBoxWidth(horizontalGeometry.contentWidthAndMargin.contentWidth);
+    displayBox.setHorizontalMargin(horizontalGeometry.contentWidthAndMargin.usedMargin);
+    displayBox.setHorizontalComputedMargin(horizontalGeometry.contentWidthAndMargin.computedMargin);
 }
 
-void FormattingContext::computeOutOfFlowVerticalGeometry(const Box& layoutBox) const
+void FormattingContext::computeOutOfFlowVerticalGeometry(const Box& layoutBox, const HorizontalConstraints& horizontalConstraints, const VerticalConstraints& verticalConstraints)
 {
-    auto& layoutState = this->layoutState();
-
-    auto compute = [&](UsedVerticalValues usedValues) {
-        return Geometry::outOfFlowVerticalGeometry(layoutState, layoutBox, usedValues);
+    ASSERT(layoutBox.isOutOfFlowPositioned());
+    auto compute = [&](Optional<LayoutUnit> usedHeight) {
+        return geometry().outOfFlowVerticalGeometry(layoutBox, horizontalConstraints, verticalConstraints, { usedHeight });
     };
 
+    auto containingBlockHeight = *verticalConstraints.logicalHeight;
     auto verticalGeometry = compute({ });
-    if (auto maxHeight = Geometry::computedMaxHeight(layoutState, layoutBox)) {
-        auto maxVerticalGeometry = compute({ *maxHeight });
-        if (verticalGeometry.heightAndMargin.height > maxVerticalGeometry.heightAndMargin.height)
+    if (auto maxHeight = geometry().computedMaxHeight(layoutBox, containingBlockHeight)) {
+        auto maxVerticalGeometry = compute(maxHeight);
+        if (verticalGeometry.contentHeightAndMargin.contentHeight > maxVerticalGeometry.contentHeightAndMargin.contentHeight)
             verticalGeometry = maxVerticalGeometry;
     }
 
-    if (auto minHeight = Geometry::computedMinHeight(layoutState, layoutBox)) {
-        auto minVerticalGeometry = compute({ *minHeight });
-        if (verticalGeometry.heightAndMargin.height < minVerticalGeometry.heightAndMargin.height)
+    if (auto minHeight = geometry().computedMinHeight(layoutBox, containingBlockHeight)) {
+        auto minVerticalGeometry = compute(minHeight);
+        if (verticalGeometry.contentHeightAndMargin.contentHeight < minVerticalGeometry.contentHeightAndMargin.contentHeight)
             verticalGeometry = minVerticalGeometry;
     }
 
-    auto& displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
-    auto nonCollapsedVerticalMargin = verticalGeometry.heightAndMargin.nonCollapsedMargin;
+    auto& displayBox = formattingState().displayBox(layoutBox);
+    auto nonCollapsedVerticalMargin = verticalGeometry.contentHeightAndMargin.nonCollapsedMargin;
     displayBox.setTop(verticalGeometry.top + nonCollapsedVerticalMargin.before);
-    displayBox.setContentBoxHeight(verticalGeometry.heightAndMargin.height);
+    displayBox.setContentBoxHeight(verticalGeometry.contentHeightAndMargin.contentHeight);
     // Margins of absolutely positioned boxes do not collapse
     displayBox.setVerticalMargin({ nonCollapsedVerticalMargin, { } });
 }
 
-void FormattingContext::computeBorderAndPadding(const Box& layoutBox, Optional<UsedHorizontalValues> usedValues) const
+void FormattingContext::computeBorderAndPadding(const Box& layoutBox, const HorizontalConstraints& horizontalConstraint)
 {
-    auto& layoutState = this->layoutState();
-    if (!usedValues)
-        usedValues = UsedHorizontalValues { layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth() };
-    auto& displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
-    displayBox.setBorder(Geometry::computedBorder(layoutBox));
-    displayBox.setPadding(Geometry::computedPadding(layoutBox, *usedValues));
+    auto& displayBox = formattingState().displayBox(layoutBox);
+    displayBox.setBorder(geometry().computedBorder(layoutBox));
+    displayBox.setPadding(geometry().computedPadding(layoutBox, horizontalConstraint));
 }
 
-void FormattingContext::layoutOutOfFlowContent() const
+void FormattingContext::layoutOutOfFlowContent(InvalidationState& invalidationState, const HorizontalConstraints& rootHorizontalConstraints, const VerticalConstraints& rootVerticalConstraints)
 {
     LOG_WITH_STREAM(FormattingContextLayout, stream << "Start: layout out-of-flow content -> context: " << &layoutState() << " root: " << &root());
 
+    collectOutOfFlowDescendantsIfNeeded();
+
+    auto horizontalConstraintsForOutOfFlowBox = [&] (const auto& outOfFlowBox) {
+        auto* containingBlock = outOfFlowBox.containingBlock();
+        ASSERT(containingBlock);
+        if (containingBlock == &root())
+            return rootHorizontalConstraints;
+        return Geometry::horizontalConstraintsForOutOfFlow(geometryForBox(*containingBlock));
+    };
+
+    auto verticalConstraintsForOutOfFlowBox = [&] (const auto& outOfFlowBox) {
+        auto* containingBlock = outOfFlowBox.containingBlock();
+        ASSERT(containingBlock);
+        if (containingBlock == &root())
+            return rootVerticalConstraints;
+        return Geometry::verticalConstraintsForOutOfFlow(geometryForBox(*containingBlock));
+    };
+
     for (auto& outOfFlowBox : formattingState().outOfFlowBoxes()) {
         ASSERT(outOfFlowBox->establishesFormattingContext());
+        if (!invalidationState.needsLayout(*outOfFlowBox))
+            continue;
 
-        computeBorderAndPadding(*outOfFlowBox);
-        computeOutOfFlowHorizontalGeometry(*outOfFlowBox);
-
-        auto formattingContext = layoutState().createFormattingContext(*outOfFlowBox);
-        formattingContext->layout();
+        auto horizontalConstraints = horizontalConstraintsForOutOfFlowBox(*outOfFlowBox);
+        auto verticalConstraints = verticalConstraintsForOutOfFlowBox(*outOfFlowBox);
+        // Borders and paddings are resolved against the containing block's content box like if this box was an in-flow box.
+        auto& outOfFlowRootDisplayBox = geometryForBox(*outOfFlowBox);
+        computeBorderAndPadding(*outOfFlowBox, Geometry::horizontalConstraintsForInFlow(outOfFlowRootDisplayBox));
+        computeOutOfFlowHorizontalGeometry(*outOfFlowBox, horizontalConstraints);
+        if (!is<Container>(*outOfFlowBox) || !downcast<Container>(*outOfFlowBox).hasChild()) {
+            computeOutOfFlowVerticalGeometry(*outOfFlowBox, horizontalConstraints, verticalConstraints);
+            continue;
+        }
 
-        computeOutOfFlowVerticalGeometry(*outOfFlowBox);
-        formattingContext->layoutOutOfFlowContent();
+        auto& outOfFlowRootContainer = downcast<Container>(*outOfFlowBox);
+        auto formattingContext = LayoutContext::createFormattingContext(outOfFlowRootContainer, layoutState());
+        if (outOfFlowRootContainer.hasInFlowOrFloatingChild())
+            formattingContext->layoutInFlowContent(invalidationState, Geometry::horizontalConstraintsForInFlow(outOfFlowRootDisplayBox), Geometry::verticalConstraintsForInFlow(outOfFlowRootDisplayBox));
+        computeOutOfFlowVerticalGeometry(outOfFlowRootContainer, horizontalConstraints, verticalConstraints);
+        formattingContext->layoutOutOfFlowContent(invalidationState, Geometry::horizontalConstraintsForInFlow(outOfFlowRootDisplayBox), Geometry::verticalConstraintsForInFlow(outOfFlowRootDisplayBox));
     }
     LOG_WITH_STREAM(FormattingContextLayout, stream << "End: layout out-of-flow content -> context: " << &layoutState() << " root: " << &root());
 }
 
-static LayoutUnit mapHorizontalPositionToAncestor(const LayoutState& layoutState, LayoutUnit horizontalPosition, const Container& containingBlock, const Container& ancestor)
+static LayoutUnit mapHorizontalPositionToAncestor(const FormattingContext& formattingContext, LayoutUnit horizontalPosition, const Container& containingBlock, const Container& ancestor)
 {
     // "horizontalPosition" is in the coordinate system of the "containingBlock". -> map from containingBlock to ancestor.
     if (&containingBlock == &ancestor)
         return horizontalPosition;
     ASSERT(containingBlock.isContainingBlockDescendantOf(ancestor));
     for (auto* container = &containingBlock; container && container != &ancestor; container = container->containingBlock())
-        horizontalPosition += layoutState.displayBoxForLayoutBox(*container).left();
+        horizontalPosition += formattingContext.geometryForBox(*container).left();
     return horizontalPosition;
 }
 
 // FIXME: turn these into templates.
-LayoutUnit FormattingContext::mapLeftToAncestor(const LayoutState& layoutState, const Box& layoutBox, const Container& ancestor)
+LayoutUnit FormattingContext::mapTopToFormattingContextRoot(const Box& layoutBox) const
 {
     ASSERT(layoutBox.containingBlock());
-    return mapHorizontalPositionToAncestor(layoutState, layoutState.displayBoxForLayoutBox(layoutBox).left(), *layoutBox.containingBlock(), ancestor);
+    auto& formattingContextRoot = root();
+    ASSERT(layoutBox.isContainingBlockDescendantOf(formattingContextRoot));
+    auto top = geometryForBox(layoutBox).top();
+    for (auto* container = layoutBox.containingBlock(); container && container != &formattingContextRoot; container = container->containingBlock())
+        top += geometryForBox(*container).top();
+    return top;
 }
 
-LayoutUnit FormattingContext::mapRightToAncestor(const LayoutState& layoutState, const Box& layoutBox, const Container& ancestor)
+LayoutUnit FormattingContext::mapLeftToFormattingContextRoot(const Box& layoutBox) const
 {
     ASSERT(layoutBox.containingBlock());
-    return mapHorizontalPositionToAncestor(layoutState, layoutState.displayBoxForLayoutBox(layoutBox).right(), *layoutBox.containingBlock(), ancestor);
+    return mapHorizontalPositionToAncestor(*this, geometryForBox(layoutBox).left(), *layoutBox.containingBlock(), root());
 }
 
-Display::Box FormattingContext::mapBoxToAncestor(const LayoutState& layoutState, const Box& layoutBox, const Container& ancestor)
+LayoutUnit FormattingContext::mapRightToFormattingContextRoot(const Box& layoutBox) const
 {
-    ASSERT(layoutBox.isContainingBlockDescendantOf(ancestor));
-    auto& displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
-    auto topLeft = displayBox.topLeft();
-    for (auto* containingBlock = layoutBox.containingBlock(); containingBlock && containingBlock != &ancestor; containingBlock = containingBlock->containingBlock())
-        topLeft.moveBy(layoutState.displayBoxForLayoutBox(*containingBlock).topLeft());
-
-    auto mappedDisplayBox = Display::Box(displayBox);
-    mappedDisplayBox.setTopLeft(topLeft);
-    return mappedDisplayBox;
+    ASSERT(layoutBox.containingBlock());
+    return mapHorizontalPositionToAncestor(*this, geometryForBox(layoutBox).right(), *layoutBox.containingBlock(), root());
 }
 
-LayoutUnit FormattingContext::mapTopToAncestor(const LayoutState& layoutState, const Box& layoutBox, const Container& ancestor)
+const Display::Box& FormattingContext::geometryForBox(const Box& layoutBox, Optional<EscapeReason> escapeReason) const
 {
-    ASSERT(layoutBox.isContainingBlockDescendantOf(ancestor));
-    auto top = layoutState.displayBoxForLayoutBox(layoutBox).top();
-    for (auto* container = layoutBox.containingBlock(); container && container != &ancestor; container = container->containingBlock())
-        top += layoutState.displayBoxForLayoutBox(*container).top();
-    return top;
-}
+    UNUSED_PARAM(escapeReason);
+#if ASSERT_ENABLED
+    auto isOkToAccessDisplayBox = [&] {
+        if (!layoutBox.isInitialContainingBlock() && &layoutBox.formattingContextRoot() == &root()) {
+            // This is the non-escape case of accessing a box's geometry information within the same formatting context.
+            return true;
+        }
 
-Point FormattingContext::mapPointToAncestor(const LayoutState& layoutState, Point position, const Container& from, const Container& to)
-{
-    if (&from == &to)
-        return position;
-    ASSERT(from.isContainingBlockDescendantOf(to));
-    auto mappedPosition = position;
-    for (auto* container = &from; container && container != &to; container = container->containingBlock())
-        mappedPosition.moveBy(layoutState.displayBoxForLayoutBox(*container).topLeft());
-    return mappedPosition;
+        if (!escapeReason) {
+            // Any geometry access outside of the formatting context without a valid reason is considered an escape.
+            return false;
+        }
+
+        if (*escapeReason == EscapeReason::BodyStrechesToViewportQuirk) {
+            ASSERT(layoutState().inQuirksMode());
+            return layoutBox.isInitialContainingBlock();
+        }
+
+        if (*escapeReason == EscapeReason::StrokeOverflowNeedsViewportGeometry)
+            return layoutBox.isInitialContainingBlock();
+
+        if (*escapeReason == EscapeReason::NeedsGeometryFromEstablishedFormattingContext) {
+            // This is the case when a formatting root collects geometry information from the established
+            // formatting context to be able to determine width/height.
+            // e.g <div>text content</div>. The <div> is a formatting root of the IFC.
+            // In order to compute the height of the <div>, we need to look inside the IFC and gather geometry information.
+            return &layoutBox.formattingContextRoot().formattingContextRoot() == &root();
+        }
+
+        if (*escapeReason == EscapeReason::OutOfFlowBoxNeedsInFlowGeometry) {
+            // When computing the static position of an out-of-flow box, we need to gather sibling/parent geometry information
+            // as if the out-of-flow box was a simple inflow box.
+            // Now since the out-of-flow and the sibling/parent boxes could very well be in different containing block subtrees
+            // the formatting context they live in could also be very different.
+            return true;
+        }
+
+        if (*escapeReason == EscapeReason::FloatBoxNeedsToBeInAbsoluteCoordinates) {
+            // Float box top/left values are mapped relative to the FloatState's root. Inline formatting contexts(A) inherit floats from parent
+            // block formatting contexts(B). Floats in these inline formatting contexts(A) need to be mapped to the parent, block formatting context(B).
+            auto& formattingContextRoot = layoutBox.formattingContextRoot();
+            return &formattingContextRoot == &root() || &formattingContextRoot == &root().formattingContextRoot();
+        }
+
+        if (*escapeReason == EscapeReason::FindFixedHeightAncestorQuirk) {
+            ASSERT(layoutState().inQuirksMode());
+            // Find the first containing block with fixed height quirk. See Quirks::heightValueOfNearestContainingBlockWithFixedHeight
+            auto& targetFormattingRoot = layoutBox.formattingContextRoot();
+            auto* ancestorFormattingContextRoot = &root().formattingContextRoot();
+            while (true) {
+                if (&targetFormattingRoot == ancestorFormattingContextRoot)
+                    return true;
+                if (ancestorFormattingContextRoot->isInitialContainingBlock())
+                    return false;
+                ancestorFormattingContextRoot = &ancestorFormattingContextRoot->formattingContextRoot();
+            }
+            return false;
+        }
+
+        if (*escapeReason == EscapeReason::TableNeedsAccessToTableWrapper) {
+            // Tables are wrapped in a 2 level formatting context structure. A <table> element initiates a block formatting context for its principal table box
+            // where the caption and the table content live. It also initiates a table wrapper box which establishes the table formatting context.
+            // In many cases the TFC needs access to the parent (generated) BFC.
+            return &layoutBox == &root().formattingContextRoot();
+        }
+
+        ASSERT_NOT_REACHED();
+        return false;
+    };
+#endif
+    ASSERT(isOkToAccessDisplayBox());
+    ASSERT(layoutState().hasDisplayBox(layoutBox));
+    return layoutState().displayBoxForLayoutBox(layoutBox);
 }
 
-Point FormattingContext::mapPointToDescendent(const LayoutState& layoutState, Point point, const Container& from, const Container& to)
+void FormattingContext::collectOutOfFlowDescendantsIfNeeded()
 {
-    // "point" is in the coordinate system of the "from" container.
-    if (&from == &to)
-        return point;
-    ASSERT(to.isContainingBlockDescendantOf(from));
-    for (auto* container = &to; container && container != &from; container = container->containingBlock())
-        point.moveBy(-layoutState.displayBoxForLayoutBox(*container).topLeft());
-    return point;
+    if (!formattingState().outOfFlowBoxes().isEmpty())
+        return;
+    auto& root = this->root();
+    if (!root.hasChild())
+        return;
+    if (!root.isPositioned() && !root.isInitialContainingBlock())
+        return;
+    // Collect the out-of-flow descendants at the formatting root level (as opposed to at the containing block level, though they might be the same).
+    // FIXME: Turn this into a register-self as boxes are being inserted.
+    for (auto& descendant : descendantsOfType<Box>(root)) {
+        if (!descendant.isOutOfFlowPositioned())
+            continue;
+        if (&descendant.formattingContextRoot() != &root)
+            continue;
+        formattingState().addOutOfFlowBox(descendant);
+    }
 }
 
 #ifndef NDEBUG
 void FormattingContext::validateGeometryConstraintsAfterLayout() const
 {
-    if (!is<Container>(root()))
-        return;
-    auto& formattingContextRoot = downcast<Container>(root());
-    auto& layoutState = this->layoutState();
+    auto& formattingContextRoot = root();
     // FIXME: add a descendantsOfType<> flavor that stops at nested formatting contexts
     for (auto& layoutBox : descendantsOfType<Box>(formattingContextRoot)) {
         if (&layoutBox.formattingContextRoot() != &formattingContextRoot)
             continue;
-        auto& containingBlockDisplayBox = layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock());
-        auto& displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
+        auto& containingBlockGeometry = geometryForBox(*layoutBox.containingBlock());
+        auto& boxGeometry = geometryForBox(layoutBox);
 
         // 10.3.3 Block-level, non-replaced elements in normal flow
         // 10.3.7 Absolutely positioned, non-replaced elements
         if ((layoutBox.isBlockLevelBox() || layoutBox.isOutOfFlowPositioned()) && !layoutBox.replaced()) {
             // margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right = width of containing block
-            auto containingBlockWidth = containingBlockDisplayBox.contentBoxWidth();
-            ASSERT(displayBox.horizontalMarginBorderAndPadding() + displayBox.contentBoxWidth() == containingBlockWidth);
+            auto containingBlockWidth = containingBlockGeometry.contentBoxWidth();
+            ASSERT(boxGeometry.horizontalMarginBorderAndPadding() + boxGeometry.contentBoxWidth() == containingBlockWidth);
         }
 
         // 10.6.4 Absolutely positioned, non-replaced elements
         if (layoutBox.isOutOfFlowPositioned() && !layoutBox.replaced()) {
             // top + margin-top + border-top-width + padding-top + height + padding-bottom + border-bottom-width + margin-bottom + bottom = height of containing block
-            auto containingBlockHeight = containingBlockDisplayBox.contentBoxHeight();
-            ASSERT(displayBox.top() + displayBox.marginBefore() + displayBox.borderTop() + displayBox.paddingTop().valueOr(0) + displayBox.contentBoxHeight()
-                + displayBox.paddingBottom().valueOr(0) + displayBox.borderBottom() + displayBox.marginAfter() == containingBlockHeight);
+            auto containingBlockHeight = containingBlockGeometry.contentBoxHeight();
+            ASSERT(boxGeometry.top() + boxGeometry.marginBefore() + boxGeometry.borderTop() + boxGeometry.paddingTop().valueOr(0) + boxGeometry.contentBoxHeight()
+                + boxGeometry.paddingBottom().valueOr(0) + boxGeometry.borderBottom() + boxGeometry.marginAfter() == containingBlockHeight);
         }
     }
 }
 #endif
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/css/SelectorChecker.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SelectorChecker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorCheckerTestFunctions.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/SelectorChecker.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  *
 22  * You should have received a copy of the GNU Library General Public License
 23  * along with this library; see the file COPYING.LIB.  If not, write to
 24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 25  * Boston, MA 02110-1301, USA.
 26  */
 27 
 28 #pragma once
 29 
 30 #include &quot;CSSSelector.h&quot;
 31 #include &quot;Element.h&quot;
 32 #include &quot;StyleRelations.h&quot;
 33 
 34 namespace WebCore {
 35 
 36 class CSSSelector;
 37 class Element;
 38 class RenderScrollbar;
 39 class RenderStyle;
 40 










 41 class SelectorChecker {
 42     WTF_MAKE_NONCOPYABLE(SelectorChecker);
 43     enum class Match { SelectorMatches, SelectorFailsLocally, SelectorFailsAllSiblings, SelectorFailsCompletely };
 44 
 45     enum class MatchType { VirtualPseudoElementOnly, Element };
 46 
 47     struct MatchResult {
 48         Match match;
 49         MatchType matchType;
 50 
 51         static MatchResult matches(MatchType matchType)
 52         {
 53             return { Match::SelectorMatches, matchType };
 54         }
 55 
 56         static MatchResult updateWithMatchType(MatchResult result, MatchType matchType)
 57         {
 58             if (matchType == MatchType::VirtualPseudoElementOnly)
 59                 result.matchType = MatchType::VirtualPseudoElementOnly;
 60             return result;
</pre>
<hr />
<pre>
 63         static MatchResult fails(Match match)
 64         {
 65             return { match, MatchType::Element };
 66         }
 67     };
 68 
 69 public:
 70     enum class Mode : unsigned char {
 71         ResolvingStyle = 0, CollectingRules, CollectingRulesIgnoringVirtualPseudoElements, QueryingRules
 72     };
 73 
 74     SelectorChecker(Document&amp;);
 75 
 76     struct CheckingContext {
 77         CheckingContext(SelectorChecker::Mode resolvingMode)
 78             : resolvingMode(resolvingMode)
 79         { }
 80 
 81         const SelectorChecker::Mode resolvingMode;
 82         PseudoId pseudoId { PseudoId::None };
<span class="line-modified"> 83         RenderScrollbar* scrollbar { nullptr };</span>
<span class="line-modified"> 84         ScrollbarPart scrollbarPart { NoPart };</span>
 85         const ContainerNode* scope { nullptr };
 86         bool isMatchingHostPseudoClass { false };

 87 
 88         // FIXME: It would be nicer to have a separate object for return values. This requires some more work in the selector compiler.
 89         Style::Relations styleRelations;
 90         PseudoIdSet pseudoIDSet;
 91     };
 92 
 93     bool match(const CSSSelector&amp;, const Element&amp;, CheckingContext&amp;, unsigned&amp; specificity) const;
 94 
 95     bool matchHostPseudoClass(const CSSSelector&amp;, const Element&amp;, CheckingContext&amp;, unsigned&amp; specificity) const;
 96 
 97     static bool isCommonPseudoClassSelector(const CSSSelector*);
 98     static bool matchesFocusPseudoClass(const Element&amp;);

 99     static bool attributeSelectorMatches(const Element&amp;, const QualifiedName&amp;, const AtomString&amp; attributeValue, const CSSSelector&amp;);
100 
101     enum LinkMatchMask { MatchDefault = 0, MatchLink = 1, MatchVisited = 2, MatchAll = MatchLink | MatchVisited };
102     static unsigned determineLinkMatchType(const CSSSelector*);
103 
104     struct LocalContext;
105 
106 private:
107     MatchResult matchRecursively(CheckingContext&amp;, const LocalContext&amp;, PseudoIdSet&amp;, unsigned&amp; specificity) const;
<span class="line-modified">108     bool checkOne(CheckingContext&amp;, const LocalContext&amp;, PseudoIdSet&amp;, MatchType&amp;, unsigned&amp; specificity) const;</span>
109     bool matchSelectorList(CheckingContext&amp;, const LocalContext&amp;, const Element&amp;, const CSSSelectorList&amp;, unsigned&amp; specificity) const;
110 
111     bool checkScrollbarPseudoClass(const CheckingContext&amp;, const Element&amp;, const CSSSelector&amp;) const;
112 
113     bool m_strictParsing;
114     bool m_documentIsHTML;
115 };
116 
117 inline bool SelectorChecker::isCommonPseudoClassSelector(const CSSSelector* selector)
118 {
119     if (selector-&gt;match() != CSSSelector::PseudoClass)
120         return false;
121     CSSSelector::PseudoClassType pseudoType = selector-&gt;pseudoClassType();
122     return pseudoType == CSSSelector::PseudoClassLink
123         || pseudoType == CSSSelector::PseudoClassAnyLink
124         || pseudoType == CSSSelector::PseudoClassAnyLinkDeprecated
125         || pseudoType == CSSSelector::PseudoClassVisited
126         || pseudoType == CSSSelector::PseudoClassFocus;
127 }
128 
</pre>
</td>
<td>
<hr />
<pre>
 21  *
 22  * You should have received a copy of the GNU Library General Public License
 23  * along with this library; see the file COPYING.LIB.  If not, write to
 24  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 25  * Boston, MA 02110-1301, USA.
 26  */
 27 
 28 #pragma once
 29 
 30 #include &quot;CSSSelector.h&quot;
 31 #include &quot;Element.h&quot;
 32 #include &quot;StyleRelations.h&quot;
 33 
 34 namespace WebCore {
 35 
 36 class CSSSelector;
 37 class Element;
 38 class RenderScrollbar;
 39 class RenderStyle;
 40 
<span class="line-added"> 41 struct StyleScrollbarState {</span>
<span class="line-added"> 42     ScrollbarPart scrollbarPart { NoPart };</span>
<span class="line-added"> 43     ScrollbarPart hoveredPart { NoPart };</span>
<span class="line-added"> 44     ScrollbarPart pressedPart { NoPart };</span>
<span class="line-added"> 45     ScrollbarOrientation orientation { VerticalScrollbar };</span>
<span class="line-added"> 46     ScrollbarButtonsPlacement buttonsPlacement { ScrollbarButtonsNone };</span>
<span class="line-added"> 47     bool enabled { false };</span>
<span class="line-added"> 48     bool scrollCornerIsVisible { false };</span>
<span class="line-added"> 49 };</span>
<span class="line-added"> 50 </span>
 51 class SelectorChecker {
 52     WTF_MAKE_NONCOPYABLE(SelectorChecker);
 53     enum class Match { SelectorMatches, SelectorFailsLocally, SelectorFailsAllSiblings, SelectorFailsCompletely };
 54 
 55     enum class MatchType { VirtualPseudoElementOnly, Element };
 56 
 57     struct MatchResult {
 58         Match match;
 59         MatchType matchType;
 60 
 61         static MatchResult matches(MatchType matchType)
 62         {
 63             return { Match::SelectorMatches, matchType };
 64         }
 65 
 66         static MatchResult updateWithMatchType(MatchResult result, MatchType matchType)
 67         {
 68             if (matchType == MatchType::VirtualPseudoElementOnly)
 69                 result.matchType = MatchType::VirtualPseudoElementOnly;
 70             return result;
</pre>
<hr />
<pre>
 73         static MatchResult fails(Match match)
 74         {
 75             return { match, MatchType::Element };
 76         }
 77     };
 78 
 79 public:
 80     enum class Mode : unsigned char {
 81         ResolvingStyle = 0, CollectingRules, CollectingRulesIgnoringVirtualPseudoElements, QueryingRules
 82     };
 83 
 84     SelectorChecker(Document&amp;);
 85 
 86     struct CheckingContext {
 87         CheckingContext(SelectorChecker::Mode resolvingMode)
 88             : resolvingMode(resolvingMode)
 89         { }
 90 
 91         const SelectorChecker::Mode resolvingMode;
 92         PseudoId pseudoId { PseudoId::None };
<span class="line-modified"> 93         Optional&lt;StyleScrollbarState&gt; scrollbarState;</span>
<span class="line-modified"> 94         AtomString nameForHightlightPseudoElement;</span>
 95         const ContainerNode* scope { nullptr };
 96         bool isMatchingHostPseudoClass { false };
<span class="line-added"> 97         const Element* shadowHostInPartRuleScope { nullptr };</span>
 98 
 99         // FIXME: It would be nicer to have a separate object for return values. This requires some more work in the selector compiler.
100         Style::Relations styleRelations;
101         PseudoIdSet pseudoIDSet;
102     };
103 
104     bool match(const CSSSelector&amp;, const Element&amp;, CheckingContext&amp;, unsigned&amp; specificity) const;
105 
106     bool matchHostPseudoClass(const CSSSelector&amp;, const Element&amp;, CheckingContext&amp;, unsigned&amp; specificity) const;
107 
108     static bool isCommonPseudoClassSelector(const CSSSelector*);
109     static bool matchesFocusPseudoClass(const Element&amp;);
<span class="line-added">110     static bool matchesDirectFocusPseudoClass(const Element&amp;);</span>
111     static bool attributeSelectorMatches(const Element&amp;, const QualifiedName&amp;, const AtomString&amp; attributeValue, const CSSSelector&amp;);
112 
113     enum LinkMatchMask { MatchDefault = 0, MatchLink = 1, MatchVisited = 2, MatchAll = MatchLink | MatchVisited };
114     static unsigned determineLinkMatchType(const CSSSelector*);
115 
116     struct LocalContext;
117 
118 private:
119     MatchResult matchRecursively(CheckingContext&amp;, const LocalContext&amp;, PseudoIdSet&amp;, unsigned&amp; specificity) const;
<span class="line-modified">120     bool checkOne(CheckingContext&amp;, const LocalContext&amp;, MatchType&amp;, unsigned&amp; specificity) const;</span>
121     bool matchSelectorList(CheckingContext&amp;, const LocalContext&amp;, const Element&amp;, const CSSSelectorList&amp;, unsigned&amp; specificity) const;
122 
123     bool checkScrollbarPseudoClass(const CheckingContext&amp;, const Element&amp;, const CSSSelector&amp;) const;
124 
125     bool m_strictParsing;
126     bool m_documentIsHTML;
127 };
128 
129 inline bool SelectorChecker::isCommonPseudoClassSelector(const CSSSelector* selector)
130 {
131     if (selector-&gt;match() != CSSSelector::PseudoClass)
132         return false;
133     CSSSelector::PseudoClassType pseudoType = selector-&gt;pseudoClassType();
134     return pseudoType == CSSSelector::PseudoClassLink
135         || pseudoType == CSSSelector::PseudoClassAnyLink
136         || pseudoType == CSSSelector::PseudoClassAnyLinkDeprecated
137         || pseudoType == CSSSelector::PseudoClassVisited
138         || pseudoType == CSSSelector::PseudoClassFocus;
139 }
140 
</pre>
</td>
</tr>
</table>
<center><a href="SelectorChecker.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorCheckerTestFunctions.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
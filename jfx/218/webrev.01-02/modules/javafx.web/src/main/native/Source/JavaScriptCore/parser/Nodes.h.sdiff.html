<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Nodes.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Nodes.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Parser.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/parser/Nodes.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">   4  *  Copyright (C) 2003-2018 Apple Inc. All rights reserved.</span>
   5  *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   6  *  Copyright (C) 2007 Maks Orlovich
   7  *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   8  *
   9  *  This library is free software; you can redistribute it and/or
  10  *  modify it under the terms of the GNU Library General Public
  11  *  License as published by the Free Software Foundation; either
  12  *  version 2 of the License, or (at your option) any later version.
  13  *
  14  *  This library is distributed in the hope that it will be useful,
  15  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  *  Library General Public License for more details.
  18  *
  19  *  You should have received a copy of the GNU Library General Public License
  20  *  along with this library; see the file COPYING.LIB.  If not, write to
  21  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  *  Boston, MA 02110-1301, USA.
  23  *
  24  */
  25 
  26 #pragma once
  27 
  28 #include &quot;BytecodeIntrinsicRegistry.h&quot;
  29 #include &quot;JITCode.h&quot;

  30 #include &quot;ParserArena.h&quot;
  31 #include &quot;ParserModes.h&quot;
  32 #include &quot;ParserTokens.h&quot;
  33 #include &quot;ResultType.h&quot;
  34 #include &quot;SourceCode.h&quot;
  35 #include &quot;SymbolTable.h&quot;
  36 #include &quot;VariableEnvironment.h&quot;
  37 #include &lt;wtf/MathExtras.h&gt;
  38 #include &lt;wtf/SmallPtrSet.h&gt;
  39 
  40 namespace JSC {
  41 
  42     enum OpcodeID : unsigned;
  43 
  44     class ArgumentListNode;
  45     class BytecodeGenerator;
  46     class FunctionMetadataNode;
  47     class FunctionParameters;
<span class="line-removed">  48     class Label;</span>
  49     class ModuleAnalyzer;
  50     class ModuleScopeData;
  51     class PropertyListNode;
  52     class ReadModifyResolveNode;
  53     class RegisterID;
  54     class ScopeNode;
  55 
  56     typedef SmallPtrSet&lt;UniquedStringImpl*&gt; UniquedStringImplPtrSet;
  57 
  58     enum Operator : uint8_t {
  59         OpEqual,
  60         OpPlusEq,
  61         OpMinusEq,
  62         OpMultEq,
  63         OpDivEq,
  64         OpPlusPlus,
  65         OpMinusMinus,
  66         OpAndEq,
  67         OpXOrEq,
  68         OpOrEq,
</pre>
<hr />
<pre>
 111     public:
 112         virtual ~ParserArenaDeletable() { }
 113 
 114         // ParserArenaDeletable objects are deleted when the arena is deleted.
 115         // Clients must not call delete directly on such objects.
 116         template&lt;typename T&gt; void* operator new(size_t, ParserArena&amp;);
 117     };
 118 
 119 #define JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED_IMPL(__classToNew) \
 120         void* operator new(size_t size, ParserArena&amp; parserArena) \
 121         { \
 122             return ParserArenaDeletable::operator new&lt;__classToNew&gt;(size, parserArena); \
 123         }
 124 
 125 #define JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(__classToNew) \
 126     public: \
 127         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED_IMPL(__classToNew) \
 128     private: \
 129         typedef int __thisIsHereToForceASemicolonAfterThisMacro
 130 

 131     class ParserArenaRoot {
<span class="line-modified"> 132         WTF_MAKE_FAST_ALLOCATED;</span>
 133     protected:
 134         ParserArenaRoot(ParserArena&amp;);
 135 
 136     public:
 137         ParserArena&amp; parserArena() { return m_arena; }
 138         virtual ~ParserArenaRoot() { }
 139 
 140     protected:
 141         ParserArena m_arena;
 142     };
 143 
 144     class Node : public ParserArenaFreeable {
 145     protected:
 146         Node(const JSTokenLocation&amp;);
 147 
 148     public:
 149         virtual ~Node() { }
 150 
 151         int firstLine() const { return m_position.line; }
 152         int startOffset() const { return m_position.offset; }
</pre>
<hr />
<pre>
 233         unsigned lastLine() const { return m_lastLine; }
 234 
 235         StatementNode* next() const { return m_next; }
 236         void setNext(StatementNode* next) { m_next = next; }
 237 
 238         virtual bool hasCompletionValue() const { return true; }
 239         virtual bool hasEarlyBreakOrContinue() const { return false; }
 240 
 241         virtual bool isEmptyStatement() const { return false; }
 242         virtual bool isDebuggerStatement() const { return false; }
 243         virtual bool isFunctionNode() const { return false; }
 244         virtual bool isReturnNode() const { return false; }
 245         virtual bool isExprStatement() const { return false; }
 246         virtual bool isBreak() const { return false; }
 247         virtual bool isContinue() const { return false; }
 248         virtual bool isLabel() const { return false; }
 249         virtual bool isBlock() const { return false; }
 250         virtual bool isFuncDeclNode() const { return false; }
 251         virtual bool isModuleDeclarationNode() const { return false; }
 252         virtual bool isForOfNode() const { return false; }

 253 
 254     protected:
 255         int m_lastLine { -1 };
 256         StatementNode* m_next { nullptr };
 257     };
 258 
 259     class VariableEnvironmentNode : public ParserArenaDeletable {
 260         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(VariableEnvironmentNode);
 261     public:
 262         typedef DeclarationStacks::FunctionStack FunctionStack;
 263 
 264         VariableEnvironmentNode()
 265         {
 266         }
 267 
 268         VariableEnvironmentNode(VariableEnvironment&amp; lexicalDeclaredVariables);
 269         VariableEnvironmentNode(VariableEnvironment&amp; lexicalDeclaredVariables, FunctionStack&amp;&amp;);
 270 
 271         VariableEnvironment&amp; lexicalVariables() { return m_lexicalVariables; }
 272         FunctionStack&amp; functionStack() { return m_functionStack; }
</pre>
<hr />
<pre>
 353     public:
 354         BigIntNode(const JSTokenLocation&amp;, const Identifier&amp;, uint8_t radix);
 355         BigIntNode(const JSTokenLocation&amp;, const Identifier&amp;, uint8_t radix, bool sign);
 356         const Identifier&amp; value() { return m_value; }
 357 
 358         const Identifier&amp; identifier() const { return m_value; }
 359         uint8_t radix() const { return m_radix; }
 360         bool sign() const { return m_sign; }
 361 
 362     private:
 363         bool isBigInt() const final { return true; }
 364         JSValue jsValue(BytecodeGenerator&amp;) const final;
 365 
 366         const Identifier&amp; m_value;
 367         const uint8_t m_radix;
 368         const bool m_sign;
 369     };
 370 
 371     class ThrowableExpressionData {
 372     public:
<span class="line-modified"> 373         ThrowableExpressionData()</span>
<span class="line-removed"> 374             : m_divot(-1, -1, -1)</span>
<span class="line-removed"> 375             , m_divotStart(-1, -1, -1)</span>
<span class="line-removed"> 376             , m_divotEnd(-1, -1, -1)</span>
<span class="line-removed"> 377         {</span>
<span class="line-removed"> 378         }</span>
 379 
 380         ThrowableExpressionData(const JSTextPosition&amp; divot, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 381             : m_divot(divot)
 382             , m_divotStart(start)
 383             , m_divotEnd(end)
 384         {
<span class="line-modified"> 385             ASSERT(m_divot.offset &gt;= m_divot.lineStartOffset);</span>
<span class="line-removed"> 386             ASSERT(m_divotStart.offset &gt;= m_divotStart.lineStartOffset);</span>
<span class="line-removed"> 387             ASSERT(m_divotEnd.offset &gt;= m_divotEnd.lineStartOffset);</span>
 388         }
 389 
 390         void setExceptionSourceCode(const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
 391         {
<span class="line-removed"> 392             ASSERT(divot.offset &gt;= divot.lineStartOffset);</span>
<span class="line-removed"> 393             ASSERT(divotStart.offset &gt;= divotStart.lineStartOffset);</span>
<span class="line-removed"> 394             ASSERT(divotEnd.offset &gt;= divotEnd.lineStartOffset);</span>
 395             m_divot = divot;
 396             m_divotStart = divotStart;
 397             m_divotEnd = divotEnd;

 398         }
 399 
 400         const JSTextPosition&amp; divot() const { return m_divot; }
 401         const JSTextPosition&amp; divotStart() const { return m_divotStart; }
 402         const JSTextPosition&amp; divotEnd() const { return m_divotEnd; }
 403 








 404     protected:
 405         RegisterID* emitThrowReferenceError(BytecodeGenerator&amp;, const String&amp; message);
 406 
 407     private:
 408         JSTextPosition m_divot;
 409         JSTextPosition m_divotStart;
 410         JSTextPosition m_divotEnd;
 411     };
 412 
 413     class ThrowableSubExpressionData : public ThrowableExpressionData {
 414     public:
 415         ThrowableSubExpressionData()
 416             : m_subexpressionDivotOffset(0)
 417             , m_subexpressionEndOffset(0)
 418             , m_subexpressionLineOffset(0)
 419             , m_subexpressionLineStartOffset(0)
 420         {
 421         }
 422 
 423         ThrowableSubExpressionData(const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
</pre>
<hr />
<pre>
 700         ElementNode* elements() const { return m_element; }
 701     private:
 702         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 703 
 704         bool isSimpleArray() const override;
 705 
 706         ElementNode* m_element;
 707         int m_elision;
 708         bool m_optional;
 709     };
 710 
 711     enum class ClassElementTag : uint8_t { No, Instance, Static, LastTag };
 712     class PropertyNode final : public ParserArenaFreeable {
 713     public:
 714         enum Type : uint8_t { Constant = 1, Getter = 2, Setter = 4, Computed = 8, Shorthand = 16, Spread = 32 };
 715         enum PutType : uint8_t { Unknown, KnownDirect };
 716 
 717         PropertyNode(const Identifier&amp;, ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);
 718         PropertyNode(ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);
 719         PropertyNode(ExpressionNode* propertyName, ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);

 720 
 721         ExpressionNode* expressionName() const { return m_expression; }
 722         const Identifier* name() const { return m_name; }
 723 
 724         Type type() const { return static_cast&lt;Type&gt;(m_type); }
 725         bool needsSuperBinding() const { return m_needsSuperBinding; }
 726         bool isClassProperty() const { return static_cast&lt;ClassElementTag&gt;(m_classElementTag) != ClassElementTag::No; }
 727         bool isStaticClassProperty() const { return static_cast&lt;ClassElementTag&gt;(m_classElementTag) == ClassElementTag::Static; }
 728         bool isInstanceClassProperty() const { return static_cast&lt;ClassElementTag&gt;(m_classElementTag) == ClassElementTag::Instance; }


 729         bool isOverriddenByDuplicate() const { return m_isOverriddenByDuplicate; }


 730         void setIsOverriddenByDuplicate() { m_isOverriddenByDuplicate = true; }
 731         PutType putType() const { return static_cast&lt;PutType&gt;(m_putType); }
 732 
 733     private:
 734         friend class PropertyListNode;
 735         const Identifier* m_name;
 736         ExpressionNode* m_expression;
 737         ExpressionNode* m_assign;
 738         unsigned m_type : 6;
 739         unsigned m_needsSuperBinding : 1;
 740         unsigned m_putType : 1;
 741         static_assert(1 &lt;&lt; 2 &gt; static_cast&lt;unsigned&gt;(ClassElementTag::LastTag), &quot;ClassElementTag shouldn&#39;t use more than two bits&quot;);
 742         unsigned m_classElementTag : 2;
<span class="line-modified"> 743         unsigned m_isOverriddenByDuplicate: 1;</span>
 744     };
 745 
 746     class PropertyListNode final : public ExpressionNode {
 747     public:
 748         PropertyListNode(const JSTokenLocation&amp;, PropertyNode*);
 749         PropertyListNode(const JSTokenLocation&amp;, PropertyNode*, PropertyListNode*);
 750 
 751         bool hasStaticallyNamedProperty(const Identifier&amp; propName);









 752 
<span class="line-modified"> 753         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID*, RegisterID*);</span>


 754 
 755     private:
 756         RegisterID* emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst = nullptr) override
 757         {
<span class="line-modified"> 758             return emitBytecode(generator, dst, nullptr);</span>
 759         }
 760         void emitPutConstantProperty(BytecodeGenerator&amp;, RegisterID*, PropertyNode&amp;);

 761 
 762         PropertyNode* m_node;
 763         PropertyListNode* m_next { nullptr };
 764     };
 765 
 766     class ObjectLiteralNode final : public ExpressionNode {
 767     public:
 768         ObjectLiteralNode(const JSTokenLocation&amp;);
 769         ObjectLiteralNode(const JSTokenLocation&amp;, PropertyListNode*);
 770         bool isObjectLiteral() const override { return true; }
 771 
 772     private:
 773         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 774 
 775         PropertyListNode* m_list;
 776     };
 777 
 778     class BracketAccessorNode final : public ExpressionNode, public ThrowableExpressionData {
 779     public:
 780         BracketAccessorNode(const JSTokenLocation&amp;, ExpressionNode* base, ExpressionNode* subscript, bool subscriptHasAssignments);
</pre>
<hr />
<pre>
 927         FunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 928 
 929     private:
 930         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 931 
 932     protected:
 933         bool isFunctionCall() const override { return true; }
 934 
 935         ExpressionNode* m_base;
 936         const Identifier&amp; m_ident;
 937         ArgumentsNode* m_args;
 938     };
 939 
 940     class BytecodeIntrinsicNode final : public ExpressionNode, public ThrowableExpressionData {
 941     public:
 942         enum class Type : uint8_t {
 943             Constant,
 944             Function
 945         };
 946 
<span class="line-modified"> 947         typedef RegisterID* (BytecodeIntrinsicNode::* EmitterType)(BytecodeGenerator&amp;, RegisterID*);</span>
<span class="line-removed"> 948 </span>
<span class="line-removed"> 949         BytecodeIntrinsicNode(Type, const JSTokenLocation&amp;, EmitterType, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);</span>
 950 
 951         bool isBytecodeIntrinsicNode() const override { return true; }
 952 
 953         Type type() const { return m_type; }
<span class="line-modified"> 954         EmitterType emitter() const { return m_emitter; }</span>
 955         const Identifier&amp; identifier() const { return m_ident; }
 956 
 957 #define JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS(name) RegisterID* emit_intrinsic_##name(BytecodeGenerator&amp;, RegisterID*);
 958         JSC_COMMON_BYTECODE_INTRINSIC_FUNCTIONS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS)
 959         JSC_COMMON_BYTECODE_INTRINSIC_CONSTANTS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS)
 960 #undef JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS
 961 
 962     private:
 963         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 964 
 965         bool isFunctionCall() const override { return m_type == Type::Function; }
 966 
<span class="line-modified"> 967         EmitterType m_emitter;</span>
 968         const Identifier&amp; m_ident;
 969         ArgumentsNode* m_args;
 970         Type m_type;
 971     };
 972 
 973     class CallFunctionCallDotNode final : public FunctionCallDotNode {
 974     public:
 975         CallFunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, size_t distanceToInnermostCallOrApply);
 976 
 977     private:
 978         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 979         size_t m_distanceToInnermostCallOrApply;
 980     };
 981 
 982     class ApplyFunctionCallDotNode final : public FunctionCallDotNode {
 983     public:
 984         ApplyFunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, size_t distanceToInnermostCallOrApply);
 985 
 986     private:
 987         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
</pre>
<hr />
<pre>
1827         unsigned m_startStartOffset;
1828         unsigned m_startLineStartOffset;
1829 
1830     private:
1831         CodeFeatures m_features;
1832         InnerArrowFunctionCodeFeatures m_innerArrowFunctionCodeFeatures;
1833         SourceCode m_source;
1834         VariableEnvironment m_varDeclarations;
1835         UniquedStringImplPtrSet m_sloppyModeHoistedFunctions;
1836         int m_numConstants;
1837         SourceElements* m_statements;
1838     };
1839 
1840     class ProgramNode final : public ScopeNode {
1841     public:
1842         ProgramNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
1843 
1844         unsigned startColumn() const { return m_startColumn; }
1845         unsigned endColumn() const { return m_endColumn; }
1846 
<span class="line-modified">1847         static const bool scopeIsFunction = false;</span>
1848 
1849     private:
1850         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1851         unsigned m_startColumn;
1852         unsigned m_endColumn;
1853     };
1854 
1855     class EvalNode final : public ScopeNode {
1856     public:
1857         EvalNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
1858 
1859         ALWAYS_INLINE unsigned startColumn() const { return 0; }
1860         unsigned endColumn() const { return m_endColumn; }
1861 
<span class="line-modified">1862         static const bool scopeIsFunction = false;</span>
1863 
1864     private:
1865         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1866 
1867         unsigned m_endColumn;
1868     };
1869 
1870     class ModuleProgramNode final : public ScopeNode {
1871     public:
1872         ModuleProgramNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
1873 
1874         unsigned startColumn() const { return m_startColumn; }
1875         unsigned endColumn() const { return m_endColumn; }
1876 
<span class="line-modified">1877         static const bool scopeIsFunction = false;</span>
1878 
1879         ModuleScopeData&amp; moduleScopeData()
1880         {
1881             return m_moduleScopeData;
1882         }
1883 
1884     private:
1885         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1886         unsigned m_startColumn;
1887         unsigned m_endColumn;
1888         Ref&lt;ModuleScopeData&gt; m_moduleScopeData;
1889     };
1890 
1891     class ModuleNameNode final : public Node {
1892     public:
1893         ModuleNameNode(const JSTokenLocation&amp;, const Identifier&amp; moduleName);
1894 
1895         const Identifier&amp; moduleName() { return m_moduleName; }
1896 
1897     private:
</pre>
<hr />
<pre>
2058         FunctionMode functionMode() { return m_functionMode; }
2059 
2060         int functionNameStart() const { return m_functionNameStart; }
2061         int functionKeywordStart() const { return m_functionKeywordStart; }
2062         int parametersStart() const { return m_parametersStart; }
2063         unsigned startColumn() const { return m_startColumn; }
2064         unsigned endColumn() const { return m_endColumn; }
2065         unsigned parameterCount() const { return m_parameterCount; }
2066         SourceParseMode parseMode() const { return m_parseMode; }
2067 
2068         void setEndPosition(JSTextPosition);
2069 
2070         const SourceCode&amp; source() const { return m_source; }
2071         const SourceCode&amp; classSource() const { return m_classSource; }
2072         void setClassSource(const SourceCode&amp; source) { m_classSource = source; }
2073 
2074         int startStartOffset() const { return m_startStartOffset; }
2075         bool isInStrictContext() const { return m_isInStrictContext; }
2076         SuperBinding superBinding() { return static_cast&lt;SuperBinding&gt;(m_superBinding); }
2077         ConstructorKind constructorKind() { return static_cast&lt;ConstructorKind&gt;(m_constructorKind); }






2078         bool isArrowFunctionBodyExpression() const { return m_isArrowFunctionBodyExpression; }
2079 
2080         void setLoc(unsigned firstLine, unsigned lastLine, int startOffset, int lineStartOffset)
2081         {
2082             m_lastLine = lastLine;
2083             m_position = JSTextPosition(firstLine, startOffset, lineStartOffset);
2084             ASSERT(m_position.offset &gt;= m_position.lineStartOffset);
2085         }
2086         unsigned lastLine() const { return m_lastLine; }
2087 
2088         bool operator==(const FunctionMetadataNode&amp;) const;
2089         bool operator!=(const FunctionMetadataNode&amp; other) const
2090         {
2091             return !(*this == other);
2092         }
2093 
2094     public:
2095         unsigned m_isInStrictContext : 1;
2096         unsigned m_superBinding : 1;
2097         unsigned m_constructorKind : 2;

2098         unsigned m_isArrowFunctionBodyExpression : 1;
2099         SourceParseMode m_parseMode;
2100         FunctionMode m_functionMode;
2101         Identifier m_ident;
2102         Identifier m_ecmaName;
2103         unsigned m_startColumn;
2104         unsigned m_endColumn;
2105         int m_functionKeywordStart;
2106         int m_functionNameStart;
2107         int m_parametersStart;
2108         SourceCode m_source;
2109         SourceCode m_classSource;
2110         int m_startStartOffset;
2111         unsigned m_parameterCount;
<span class="line-modified">2112         int m_lastLine;</span>
2113     };
2114 
2115     class FunctionNode final : public ScopeNode {
2116     public:
2117         FunctionNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
2118 
2119         FunctionParameters* parameters() const { return m_parameters; }
2120 
2121         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2122 
2123         bool isFunctionNode() const override { return true; }
2124 
2125         void finishParsing(const Identifier&amp;, FunctionMode);
2126 
2127         const Identifier&amp; ident() { return m_ident; }
2128 
2129         FunctionMode functionMode() const { return m_functionMode; }
2130 
2131         unsigned startColumn() const { return m_startColumn; }
2132         unsigned endColumn() const { return m_endColumn; }
2133 
<span class="line-modified">2134         static const bool scopeIsFunction = true;</span>
2135 
2136     private:
2137         Identifier m_ident;
2138         FunctionMode m_functionMode;
2139         FunctionParameters* m_parameters;
2140         unsigned m_startColumn;
2141         unsigned m_endColumn;
2142     };
2143 
2144     class BaseFuncExprNode : public ExpressionNode {
2145     public:
2146         FunctionMetadataNode* metadata() { return m_metadata; }
2147 
2148         bool isBaseFuncExprNode() const override { return true; }
2149 
2150     protected:
2151         BaseFuncExprNode(const JSTokenLocation&amp;, const Identifier&amp;, FunctionMetadataNode*, const SourceCode&amp;, FunctionMode);
2152 
2153         FunctionMetadataNode* m_metadata;
2154     };
</pre>
<hr />
<pre>
2194 
2195     private:
2196         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2197 
2198         ExpressionNode* m_argument;
2199         bool m_delegate;
2200     };
2201 
2202     class AwaitExprNode final : public ExpressionNode, public ThrowableExpressionData {
2203     public:
2204         AwaitExprNode(const JSTokenLocation&amp;, ExpressionNode* argument);
2205 
2206         ExpressionNode* argument() const { return m_argument; }
2207 
2208     private:
2209         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2210 
2211         ExpressionNode* m_argument;
2212     };
2213 















2214     class ClassExprNode final : public ExpressionNode, public VariableEnvironmentNode {
2215         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ClassExprNode);
2216     public:
2217         ClassExprNode(const JSTokenLocation&amp;, const Identifier&amp;, const SourceCode&amp; classSource,
2218             VariableEnvironment&amp; classEnvironment, ExpressionNode* constructorExpresssion,
2219             ExpressionNode* parentClass, PropertyListNode* classElements);
2220 
2221         const Identifier&amp; name() { return m_name; }
2222         const Identifier&amp; ecmaName() { return m_ecmaName ? *m_ecmaName : m_name; }
2223         void setEcmaName(const Identifier&amp; name) { m_ecmaName = m_name.isNull() ? &amp;name : &amp;m_name; }
2224 
2225         bool hasStaticProperty(const Identifier&amp; propName) { return m_classElements ? m_classElements-&gt;hasStaticallyNamedProperty(propName) : false; }

2226 
2227     private:
2228         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2229 
2230         bool isClassExprNode() const override { return true; }
2231 
2232         SourceCode m_classSource;
2233         const Identifier&amp; m_name;
2234         const Identifier* m_ecmaName;
2235         ExpressionNode* m_constructorExpression;
2236         ExpressionNode* m_classHeritage;
2237         PropertyListNode* m_classElements;

2238     };
2239 
2240     class DestructuringPatternNode : public ParserArenaFreeable {
2241     public:
2242         virtual ~DestructuringPatternNode() { }
2243         virtual void collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const = 0;
2244         virtual void bindValue(BytecodeGenerator&amp;, RegisterID* source) const = 0;
2245         virtual void toString(StringBuilder&amp;) const = 0;
2246 
2247         virtual bool isBindingNode() const { return false; }
2248         virtual bool isAssignmentElementNode() const { return false; }
2249         virtual bool isRestParameter() const { return false; }
2250         virtual RegisterID* emitDirectBinding(BytecodeGenerator&amp;, RegisterID*, ExpressionNode*) { return 0; }
2251 
2252     protected:
2253         DestructuringPatternNode();
2254     };
2255 
2256     class ArrayPatternNode final : public DestructuringPatternNode, public ParserArenaDeletable, public ThrowableExpressionData {
2257         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ArrayPatternNode);
</pre>
<hr />
<pre>
2475     public:
2476         ClauseListNode(CaseClauseNode*);
2477         ClauseListNode(ClauseListNode*, CaseClauseNode*);
2478 
2479         CaseClauseNode* getClause() const { return m_clause; }
2480         ClauseListNode* getNext() const { return m_next; }
2481 
2482     private:
2483         CaseClauseNode* m_clause;
2484         ClauseListNode* m_next { nullptr };
2485     };
2486 
2487     class CaseBlockNode final : public ParserArenaFreeable {
2488     public:
2489         CaseBlockNode(ClauseListNode* list1, CaseClauseNode* defaultClause, ClauseListNode* list2);
2490 
2491         void emitBytecodeForBlock(BytecodeGenerator&amp;, RegisterID* input, RegisterID* destination);
2492 
2493     private:
2494         SwitchInfo::SwitchType tryTableSwitch(Vector&lt;ExpressionNode*, 8&gt;&amp; literalVector, int32_t&amp; min_num, int32_t&amp; max_num);
<span class="line-modified">2495         static const size_t s_tableSwitchMinimum = 3;</span>
2496         ClauseListNode* m_list1;
2497         CaseClauseNode* m_defaultClause;
2498         ClauseListNode* m_list2;
2499     };
2500 
2501     class SwitchNode final : public StatementNode, public VariableEnvironmentNode {
2502         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(SwitchNode);
2503     public:
2504         SwitchNode(const JSTokenLocation&amp;, ExpressionNode*, CaseBlockNode*, VariableEnvironment&amp;, FunctionStack&amp;&amp;);
2505 
2506     private:
2507         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2508 
2509         ExpressionNode* m_expr;
2510         CaseBlockNode* m_block;
2511     };
2512 
2513     struct ElementList {
2514         ElementNode* head;
2515         ElementNode* tail;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">   4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   5  *  Copyright (C) 2007 Cameron Zwarich (cwzwarich@uwaterloo.ca)
   6  *  Copyright (C) 2007 Maks Orlovich
   7  *  Copyright (C) 2007 Eric Seidel &lt;eric@webkit.org&gt;
   8  *
   9  *  This library is free software; you can redistribute it and/or
  10  *  modify it under the terms of the GNU Library General Public
  11  *  License as published by the Free Software Foundation; either
  12  *  version 2 of the License, or (at your option) any later version.
  13  *
  14  *  This library is distributed in the hope that it will be useful,
  15  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  17  *  Library General Public License for more details.
  18  *
  19  *  You should have received a copy of the GNU Library General Public License
  20  *  along with this library; see the file COPYING.LIB.  If not, write to
  21  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  22  *  Boston, MA 02110-1301, USA.
  23  *
  24  */
  25 
  26 #pragma once
  27 
  28 #include &quot;BytecodeIntrinsicRegistry.h&quot;
  29 #include &quot;JITCode.h&quot;
<span class="line-added">  30 #include &quot;Label.h&quot;</span>
  31 #include &quot;ParserArena.h&quot;
  32 #include &quot;ParserModes.h&quot;
  33 #include &quot;ParserTokens.h&quot;
  34 #include &quot;ResultType.h&quot;
  35 #include &quot;SourceCode.h&quot;
  36 #include &quot;SymbolTable.h&quot;
  37 #include &quot;VariableEnvironment.h&quot;
  38 #include &lt;wtf/MathExtras.h&gt;
  39 #include &lt;wtf/SmallPtrSet.h&gt;
  40 
  41 namespace JSC {
  42 
  43     enum OpcodeID : unsigned;
  44 
  45     class ArgumentListNode;
  46     class BytecodeGenerator;
  47     class FunctionMetadataNode;
  48     class FunctionParameters;

  49     class ModuleAnalyzer;
  50     class ModuleScopeData;
  51     class PropertyListNode;
  52     class ReadModifyResolveNode;
  53     class RegisterID;
  54     class ScopeNode;
  55 
  56     typedef SmallPtrSet&lt;UniquedStringImpl*&gt; UniquedStringImplPtrSet;
  57 
  58     enum Operator : uint8_t {
  59         OpEqual,
  60         OpPlusEq,
  61         OpMinusEq,
  62         OpMultEq,
  63         OpDivEq,
  64         OpPlusPlus,
  65         OpMinusMinus,
  66         OpAndEq,
  67         OpXOrEq,
  68         OpOrEq,
</pre>
<hr />
<pre>
 111     public:
 112         virtual ~ParserArenaDeletable() { }
 113 
 114         // ParserArenaDeletable objects are deleted when the arena is deleted.
 115         // Clients must not call delete directly on such objects.
 116         template&lt;typename T&gt; void* operator new(size_t, ParserArena&amp;);
 117     };
 118 
 119 #define JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED_IMPL(__classToNew) \
 120         void* operator new(size_t size, ParserArena&amp; parserArena) \
 121         { \
 122             return ParserArenaDeletable::operator new&lt;__classToNew&gt;(size, parserArena); \
 123         }
 124 
 125 #define JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(__classToNew) \
 126     public: \
 127         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED_IMPL(__classToNew) \
 128     private: \
 129         typedef int __thisIsHereToForceASemicolonAfterThisMacro
 130 
<span class="line-added"> 131     DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ParserArenaRoot);</span>
 132     class ParserArenaRoot {
<span class="line-modified"> 133         WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(ParserArenaRoot);</span>
 134     protected:
 135         ParserArenaRoot(ParserArena&amp;);
 136 
 137     public:
 138         ParserArena&amp; parserArena() { return m_arena; }
 139         virtual ~ParserArenaRoot() { }
 140 
 141     protected:
 142         ParserArena m_arena;
 143     };
 144 
 145     class Node : public ParserArenaFreeable {
 146     protected:
 147         Node(const JSTokenLocation&amp;);
 148 
 149     public:
 150         virtual ~Node() { }
 151 
 152         int firstLine() const { return m_position.line; }
 153         int startOffset() const { return m_position.offset; }
</pre>
<hr />
<pre>
 234         unsigned lastLine() const { return m_lastLine; }
 235 
 236         StatementNode* next() const { return m_next; }
 237         void setNext(StatementNode* next) { m_next = next; }
 238 
 239         virtual bool hasCompletionValue() const { return true; }
 240         virtual bool hasEarlyBreakOrContinue() const { return false; }
 241 
 242         virtual bool isEmptyStatement() const { return false; }
 243         virtual bool isDebuggerStatement() const { return false; }
 244         virtual bool isFunctionNode() const { return false; }
 245         virtual bool isReturnNode() const { return false; }
 246         virtual bool isExprStatement() const { return false; }
 247         virtual bool isBreak() const { return false; }
 248         virtual bool isContinue() const { return false; }
 249         virtual bool isLabel() const { return false; }
 250         virtual bool isBlock() const { return false; }
 251         virtual bool isFuncDeclNode() const { return false; }
 252         virtual bool isModuleDeclarationNode() const { return false; }
 253         virtual bool isForOfNode() const { return false; }
<span class="line-added"> 254         virtual bool isDefineFieldNode() const { return false; }</span>
 255 
 256     protected:
 257         int m_lastLine { -1 };
 258         StatementNode* m_next { nullptr };
 259     };
 260 
 261     class VariableEnvironmentNode : public ParserArenaDeletable {
 262         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(VariableEnvironmentNode);
 263     public:
 264         typedef DeclarationStacks::FunctionStack FunctionStack;
 265 
 266         VariableEnvironmentNode()
 267         {
 268         }
 269 
 270         VariableEnvironmentNode(VariableEnvironment&amp; lexicalDeclaredVariables);
 271         VariableEnvironmentNode(VariableEnvironment&amp; lexicalDeclaredVariables, FunctionStack&amp;&amp;);
 272 
 273         VariableEnvironment&amp; lexicalVariables() { return m_lexicalVariables; }
 274         FunctionStack&amp; functionStack() { return m_functionStack; }
</pre>
<hr />
<pre>
 355     public:
 356         BigIntNode(const JSTokenLocation&amp;, const Identifier&amp;, uint8_t radix);
 357         BigIntNode(const JSTokenLocation&amp;, const Identifier&amp;, uint8_t radix, bool sign);
 358         const Identifier&amp; value() { return m_value; }
 359 
 360         const Identifier&amp; identifier() const { return m_value; }
 361         uint8_t radix() const { return m_radix; }
 362         bool sign() const { return m_sign; }
 363 
 364     private:
 365         bool isBigInt() const final { return true; }
 366         JSValue jsValue(BytecodeGenerator&amp;) const final;
 367 
 368         const Identifier&amp; m_value;
 369         const uint8_t m_radix;
 370         const bool m_sign;
 371     };
 372 
 373     class ThrowableExpressionData {
 374     public:
<span class="line-modified"> 375         ThrowableExpressionData() = default;</span>





 376 
 377         ThrowableExpressionData(const JSTextPosition&amp; divot, const JSTextPosition&amp; start, const JSTextPosition&amp; end)
 378             : m_divot(divot)
 379             , m_divotStart(start)
 380             , m_divotEnd(end)
 381         {
<span class="line-modified"> 382             checkConsistency();</span>


 383         }
 384 
 385         void setExceptionSourceCode(const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
 386         {



 387             m_divot = divot;
 388             m_divotStart = divotStart;
 389             m_divotEnd = divotEnd;
<span class="line-added"> 390             checkConsistency();</span>
 391         }
 392 
 393         const JSTextPosition&amp; divot() const { return m_divot; }
 394         const JSTextPosition&amp; divotStart() const { return m_divotStart; }
 395         const JSTextPosition&amp; divotEnd() const { return m_divotEnd; }
 396 
<span class="line-added"> 397         void checkConsistency() const</span>
<span class="line-added"> 398         {</span>
<span class="line-added"> 399             ASSERT(m_divot.offset &gt;= m_divot.lineStartOffset);</span>
<span class="line-added"> 400             ASSERT(m_divotStart.offset &gt;= m_divotStart.lineStartOffset);</span>
<span class="line-added"> 401             ASSERT(m_divotEnd.offset &gt;= m_divotEnd.lineStartOffset);</span>
<span class="line-added"> 402             ASSERT(m_divot.offset &gt;= m_divotStart.offset);</span>
<span class="line-added"> 403             ASSERT(m_divotEnd.offset &gt;= m_divot.offset);</span>
<span class="line-added"> 404         }</span>
 405     protected:
 406         RegisterID* emitThrowReferenceError(BytecodeGenerator&amp;, const String&amp; message);
 407 
 408     private:
 409         JSTextPosition m_divot;
 410         JSTextPosition m_divotStart;
 411         JSTextPosition m_divotEnd;
 412     };
 413 
 414     class ThrowableSubExpressionData : public ThrowableExpressionData {
 415     public:
 416         ThrowableSubExpressionData()
 417             : m_subexpressionDivotOffset(0)
 418             , m_subexpressionEndOffset(0)
 419             , m_subexpressionLineOffset(0)
 420             , m_subexpressionLineStartOffset(0)
 421         {
 422         }
 423 
 424         ThrowableSubExpressionData(const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd)
</pre>
<hr />
<pre>
 701         ElementNode* elements() const { return m_element; }
 702     private:
 703         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 704 
 705         bool isSimpleArray() const override;
 706 
 707         ElementNode* m_element;
 708         int m_elision;
 709         bool m_optional;
 710     };
 711 
 712     enum class ClassElementTag : uint8_t { No, Instance, Static, LastTag };
 713     class PropertyNode final : public ParserArenaFreeable {
 714     public:
 715         enum Type : uint8_t { Constant = 1, Getter = 2, Setter = 4, Computed = 8, Shorthand = 16, Spread = 32 };
 716         enum PutType : uint8_t { Unknown, KnownDirect };
 717 
 718         PropertyNode(const Identifier&amp;, ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);
 719         PropertyNode(ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);
 720         PropertyNode(ExpressionNode* propertyName, ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);
<span class="line-added"> 721         PropertyNode(const Identifier&amp;, ExpressionNode* propertyName, ExpressionNode*, Type, PutType, SuperBinding, ClassElementTag);</span>
 722 
 723         ExpressionNode* expressionName() const { return m_expression; }
 724         const Identifier* name() const { return m_name; }
 725 
 726         Type type() const { return static_cast&lt;Type&gt;(m_type); }
 727         bool needsSuperBinding() const { return m_needsSuperBinding; }
 728         bool isClassProperty() const { return static_cast&lt;ClassElementTag&gt;(m_classElementTag) != ClassElementTag::No; }
 729         bool isStaticClassProperty() const { return static_cast&lt;ClassElementTag&gt;(m_classElementTag) == ClassElementTag::Static; }
 730         bool isInstanceClassProperty() const { return static_cast&lt;ClassElementTag&gt;(m_classElementTag) == ClassElementTag::Instance; }
<span class="line-added"> 731         bool isClassField() const { return isClassProperty() &amp;&amp; !needsSuperBinding(); }</span>
<span class="line-added"> 732         bool isInstanceClassField() const { return isInstanceClassProperty() &amp;&amp; !needsSuperBinding(); }</span>
 733         bool isOverriddenByDuplicate() const { return m_isOverriddenByDuplicate; }
<span class="line-added"> 734         bool hasComputedName() const { return m_expression; }</span>
<span class="line-added"> 735         bool isComputedClassField() const { return isClassField() &amp;&amp; hasComputedName(); }</span>
 736         void setIsOverriddenByDuplicate() { m_isOverriddenByDuplicate = true; }
 737         PutType putType() const { return static_cast&lt;PutType&gt;(m_putType); }
 738 
 739     private:
 740         friend class PropertyListNode;
 741         const Identifier* m_name;
 742         ExpressionNode* m_expression;
 743         ExpressionNode* m_assign;
 744         unsigned m_type : 6;
 745         unsigned m_needsSuperBinding : 1;
 746         unsigned m_putType : 1;
 747         static_assert(1 &lt;&lt; 2 &gt; static_cast&lt;unsigned&gt;(ClassElementTag::LastTag), &quot;ClassElementTag shouldn&#39;t use more than two bits&quot;);
 748         unsigned m_classElementTag : 2;
<span class="line-modified"> 749         unsigned m_isOverriddenByDuplicate : 1;</span>
 750     };
 751 
 752     class PropertyListNode final : public ExpressionNode {
 753     public:
 754         PropertyListNode(const JSTokenLocation&amp;, PropertyNode*);
 755         PropertyListNode(const JSTokenLocation&amp;, PropertyNode*, PropertyListNode*);
 756 
 757         bool hasStaticallyNamedProperty(const Identifier&amp; propName);
<span class="line-added"> 758         bool isComputedClassField() const</span>
<span class="line-added"> 759         {</span>
<span class="line-added"> 760             return m_node-&gt;isComputedClassField();</span>
<span class="line-added"> 761         }</span>
<span class="line-added"> 762         bool isInstanceClassField() const</span>
<span class="line-added"> 763         {</span>
<span class="line-added"> 764             return m_node-&gt;isInstanceClassField();</span>
<span class="line-added"> 765         }</span>
<span class="line-added"> 766         bool hasInstanceFields() const;</span>
 767 
<span class="line-modified"> 768         static bool shouldCreateLexicalScopeForClass(PropertyListNode*);</span>
<span class="line-added"> 769 </span>
<span class="line-added"> 770         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID*, RegisterID*, Vector&lt;JSTextPosition&gt;*);</span>
 771 
 772     private:
 773         RegisterID* emitBytecode(BytecodeGenerator&amp; generator, RegisterID* dst = nullptr) override
 774         {
<span class="line-modified"> 775             return emitBytecode(generator, dst, nullptr, nullptr);</span>
 776         }
 777         void emitPutConstantProperty(BytecodeGenerator&amp;, RegisterID*, PropertyNode&amp;);
<span class="line-added"> 778         void emitSaveComputedFieldName(BytecodeGenerator&amp;, PropertyNode&amp;);</span>
 779 
 780         PropertyNode* m_node;
 781         PropertyListNode* m_next { nullptr };
 782     };
 783 
 784     class ObjectLiteralNode final : public ExpressionNode {
 785     public:
 786         ObjectLiteralNode(const JSTokenLocation&amp;);
 787         ObjectLiteralNode(const JSTokenLocation&amp;, PropertyListNode*);
 788         bool isObjectLiteral() const override { return true; }
 789 
 790     private:
 791         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 792 
 793         PropertyListNode* m_list;
 794     };
 795 
 796     class BracketAccessorNode final : public ExpressionNode, public ThrowableExpressionData {
 797     public:
 798         BracketAccessorNode(const JSTokenLocation&amp;, ExpressionNode* base, ExpressionNode* subscript, bool subscriptHasAssignments);
</pre>
<hr />
<pre>
 945         FunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);
 946 
 947     private:
 948         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 949 
 950     protected:
 951         bool isFunctionCall() const override { return true; }
 952 
 953         ExpressionNode* m_base;
 954         const Identifier&amp; m_ident;
 955         ArgumentsNode* m_args;
 956     };
 957 
 958     class BytecodeIntrinsicNode final : public ExpressionNode, public ThrowableExpressionData {
 959     public:
 960         enum class Type : uint8_t {
 961             Constant,
 962             Function
 963         };
 964 
<span class="line-modified"> 965         BytecodeIntrinsicNode(Type, const JSTokenLocation&amp;, BytecodeIntrinsicRegistry::Entry, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd);</span>


 966 
 967         bool isBytecodeIntrinsicNode() const override { return true; }
 968 
 969         Type type() const { return m_type; }
<span class="line-modified"> 970         BytecodeIntrinsicRegistry::Entry entry() const { return m_entry; }</span>
 971         const Identifier&amp; identifier() const { return m_ident; }
 972 
 973 #define JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS(name) RegisterID* emit_intrinsic_##name(BytecodeGenerator&amp;, RegisterID*);
 974         JSC_COMMON_BYTECODE_INTRINSIC_FUNCTIONS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS)
 975         JSC_COMMON_BYTECODE_INTRINSIC_CONSTANTS_EACH_NAME(JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS)
 976 #undef JSC_DECLARE_BYTECODE_INTRINSIC_FUNCTIONS
 977 
 978     private:
 979         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 980 
 981         bool isFunctionCall() const override { return m_type == Type::Function; }
 982 
<span class="line-modified"> 983         BytecodeIntrinsicRegistry::Entry m_entry;</span>
 984         const Identifier&amp; m_ident;
 985         ArgumentsNode* m_args;
 986         Type m_type;
 987     };
 988 
 989     class CallFunctionCallDotNode final : public FunctionCallDotNode {
 990     public:
 991         CallFunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, size_t distanceToInnermostCallOrApply);
 992 
 993     private:
 994         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
 995         size_t m_distanceToInnermostCallOrApply;
 996     };
 997 
 998     class ApplyFunctionCallDotNode final : public FunctionCallDotNode {
 999     public:
1000         ApplyFunctionCallDotNode(const JSTokenLocation&amp;, ExpressionNode* base, const Identifier&amp;, ArgumentsNode*, const JSTextPosition&amp; divot, const JSTextPosition&amp; divotStart, const JSTextPosition&amp; divotEnd, size_t distanceToInnermostCallOrApply);
1001 
1002     private:
1003         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
</pre>
<hr />
<pre>
1843         unsigned m_startStartOffset;
1844         unsigned m_startLineStartOffset;
1845 
1846     private:
1847         CodeFeatures m_features;
1848         InnerArrowFunctionCodeFeatures m_innerArrowFunctionCodeFeatures;
1849         SourceCode m_source;
1850         VariableEnvironment m_varDeclarations;
1851         UniquedStringImplPtrSet m_sloppyModeHoistedFunctions;
1852         int m_numConstants;
1853         SourceElements* m_statements;
1854     };
1855 
1856     class ProgramNode final : public ScopeNode {
1857     public:
1858         ProgramNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
1859 
1860         unsigned startColumn() const { return m_startColumn; }
1861         unsigned endColumn() const { return m_endColumn; }
1862 
<span class="line-modified">1863         static constexpr bool scopeIsFunction = false;</span>
1864 
1865     private:
1866         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1867         unsigned m_startColumn;
1868         unsigned m_endColumn;
1869     };
1870 
1871     class EvalNode final : public ScopeNode {
1872     public:
1873         EvalNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
1874 
1875         ALWAYS_INLINE unsigned startColumn() const { return 0; }
1876         unsigned endColumn() const { return m_endColumn; }
1877 
<span class="line-modified">1878         static constexpr bool scopeIsFunction = false;</span>
1879 
1880     private:
1881         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1882 
1883         unsigned m_endColumn;
1884     };
1885 
1886     class ModuleProgramNode final : public ScopeNode {
1887     public:
1888         ModuleProgramNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
1889 
1890         unsigned startColumn() const { return m_startColumn; }
1891         unsigned endColumn() const { return m_endColumn; }
1892 
<span class="line-modified">1893         static constexpr bool scopeIsFunction = false;</span>
1894 
1895         ModuleScopeData&amp; moduleScopeData()
1896         {
1897             return m_moduleScopeData;
1898         }
1899 
1900     private:
1901         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
1902         unsigned m_startColumn;
1903         unsigned m_endColumn;
1904         Ref&lt;ModuleScopeData&gt; m_moduleScopeData;
1905     };
1906 
1907     class ModuleNameNode final : public Node {
1908     public:
1909         ModuleNameNode(const JSTokenLocation&amp;, const Identifier&amp; moduleName);
1910 
1911         const Identifier&amp; moduleName() { return m_moduleName; }
1912 
1913     private:
</pre>
<hr />
<pre>
2074         FunctionMode functionMode() { return m_functionMode; }
2075 
2076         int functionNameStart() const { return m_functionNameStart; }
2077         int functionKeywordStart() const { return m_functionKeywordStart; }
2078         int parametersStart() const { return m_parametersStart; }
2079         unsigned startColumn() const { return m_startColumn; }
2080         unsigned endColumn() const { return m_endColumn; }
2081         unsigned parameterCount() const { return m_parameterCount; }
2082         SourceParseMode parseMode() const { return m_parseMode; }
2083 
2084         void setEndPosition(JSTextPosition);
2085 
2086         const SourceCode&amp; source() const { return m_source; }
2087         const SourceCode&amp; classSource() const { return m_classSource; }
2088         void setClassSource(const SourceCode&amp; source) { m_classSource = source; }
2089 
2090         int startStartOffset() const { return m_startStartOffset; }
2091         bool isInStrictContext() const { return m_isInStrictContext; }
2092         SuperBinding superBinding() { return static_cast&lt;SuperBinding&gt;(m_superBinding); }
2093         ConstructorKind constructorKind() { return static_cast&lt;ConstructorKind&gt;(m_constructorKind); }
<span class="line-added">2094         bool isConstructorAndNeedsClassFieldInitializer() const { return m_needsClassFieldInitializer; }</span>
<span class="line-added">2095         void setNeedsClassFieldInitializer(bool value)</span>
<span class="line-added">2096         {</span>
<span class="line-added">2097             ASSERT(!value || constructorKind() != ConstructorKind::None);</span>
<span class="line-added">2098             m_needsClassFieldInitializer = value;</span>
<span class="line-added">2099         }</span>
2100         bool isArrowFunctionBodyExpression() const { return m_isArrowFunctionBodyExpression; }
2101 
2102         void setLoc(unsigned firstLine, unsigned lastLine, int startOffset, int lineStartOffset)
2103         {
2104             m_lastLine = lastLine;
2105             m_position = JSTextPosition(firstLine, startOffset, lineStartOffset);
2106             ASSERT(m_position.offset &gt;= m_position.lineStartOffset);
2107         }
2108         unsigned lastLine() const { return m_lastLine; }
2109 
2110         bool operator==(const FunctionMetadataNode&amp;) const;
2111         bool operator!=(const FunctionMetadataNode&amp; other) const
2112         {
2113             return !(*this == other);
2114         }
2115 
2116     public:
2117         unsigned m_isInStrictContext : 1;
2118         unsigned m_superBinding : 1;
2119         unsigned m_constructorKind : 2;
<span class="line-added">2120         unsigned m_needsClassFieldInitializer : 1;</span>
2121         unsigned m_isArrowFunctionBodyExpression : 1;
2122         SourceParseMode m_parseMode;
2123         FunctionMode m_functionMode;
2124         Identifier m_ident;
2125         Identifier m_ecmaName;
2126         unsigned m_startColumn;
2127         unsigned m_endColumn;
2128         int m_functionKeywordStart;
2129         int m_functionNameStart;
2130         int m_parametersStart;
2131         SourceCode m_source;
2132         SourceCode m_classSource;
2133         int m_startStartOffset;
2134         unsigned m_parameterCount;
<span class="line-modified">2135         int m_lastLine { 0 };</span>
2136     };
2137 
2138     class FunctionNode final : public ScopeNode {
2139     public:
2140         FunctionNode(ParserArena&amp;, const JSTokenLocation&amp; start, const JSTokenLocation&amp; end, unsigned startColumn, unsigned endColumn, SourceElements*, VariableEnvironment&amp;, FunctionStack&amp;&amp;, VariableEnvironment&amp;, UniquedStringImplPtrSet&amp;&amp;, FunctionParameters*, const SourceCode&amp;, CodeFeatures, InnerArrowFunctionCodeFeatures, int numConstants, RefPtr&lt;ModuleScopeData&gt;&amp;&amp;);
2141 
2142         FunctionParameters* parameters() const { return m_parameters; }
2143 
2144         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2145 
2146         bool isFunctionNode() const override { return true; }
2147 
2148         void finishParsing(const Identifier&amp;, FunctionMode);
2149 
2150         const Identifier&amp; ident() { return m_ident; }
2151 
2152         FunctionMode functionMode() const { return m_functionMode; }
2153 
2154         unsigned startColumn() const { return m_startColumn; }
2155         unsigned endColumn() const { return m_endColumn; }
2156 
<span class="line-modified">2157         static constexpr bool scopeIsFunction = true;</span>
2158 
2159     private:
2160         Identifier m_ident;
2161         FunctionMode m_functionMode;
2162         FunctionParameters* m_parameters;
2163         unsigned m_startColumn;
2164         unsigned m_endColumn;
2165     };
2166 
2167     class BaseFuncExprNode : public ExpressionNode {
2168     public:
2169         FunctionMetadataNode* metadata() { return m_metadata; }
2170 
2171         bool isBaseFuncExprNode() const override { return true; }
2172 
2173     protected:
2174         BaseFuncExprNode(const JSTokenLocation&amp;, const Identifier&amp;, FunctionMetadataNode*, const SourceCode&amp;, FunctionMode);
2175 
2176         FunctionMetadataNode* m_metadata;
2177     };
</pre>
<hr />
<pre>
2217 
2218     private:
2219         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2220 
2221         ExpressionNode* m_argument;
2222         bool m_delegate;
2223     };
2224 
2225     class AwaitExprNode final : public ExpressionNode, public ThrowableExpressionData {
2226     public:
2227         AwaitExprNode(const JSTokenLocation&amp;, ExpressionNode* argument);
2228 
2229         ExpressionNode* argument() const { return m_argument; }
2230 
2231     private:
2232         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2233 
2234         ExpressionNode* m_argument;
2235     };
2236 
<span class="line-added">2237     class DefineFieldNode final : public StatementNode {</span>
<span class="line-added">2238     public:</span>
<span class="line-added">2239         enum class Type { Name, ComputedName };</span>
<span class="line-added">2240         DefineFieldNode(const JSTokenLocation&amp;, const Identifier*, ExpressionNode*, Type);</span>
<span class="line-added">2241 </span>
<span class="line-added">2242     private:</span>
<span class="line-added">2243         void emitBytecode(BytecodeGenerator&amp;, RegisterID* destination = nullptr) override;</span>
<span class="line-added">2244 </span>
<span class="line-added">2245         bool isDefineFieldNode() const override { return true; }</span>
<span class="line-added">2246 </span>
<span class="line-added">2247         const Identifier* m_ident;</span>
<span class="line-added">2248         ExpressionNode* m_assign;</span>
<span class="line-added">2249         Type m_type;</span>
<span class="line-added">2250     };</span>
<span class="line-added">2251 </span>
2252     class ClassExprNode final : public ExpressionNode, public VariableEnvironmentNode {
2253         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ClassExprNode);
2254     public:
2255         ClassExprNode(const JSTokenLocation&amp;, const Identifier&amp;, const SourceCode&amp; classSource,
2256             VariableEnvironment&amp; classEnvironment, ExpressionNode* constructorExpresssion,
2257             ExpressionNode* parentClass, PropertyListNode* classElements);
2258 
2259         const Identifier&amp; name() { return m_name; }
2260         const Identifier&amp; ecmaName() { return m_ecmaName ? *m_ecmaName : m_name; }
2261         void setEcmaName(const Identifier&amp; name) { m_ecmaName = m_name.isNull() ? &amp;name : &amp;m_name; }
2262 
2263         bool hasStaticProperty(const Identifier&amp; propName) { return m_classElements ? m_classElements-&gt;hasStaticallyNamedProperty(propName) : false; }
<span class="line-added">2264         bool hasInstanceFields() const { return m_classElements ? m_classElements-&gt;hasInstanceFields() : false; }</span>
2265 
2266     private:
2267         RegisterID* emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2268 
2269         bool isClassExprNode() const override { return true; }
2270 
2271         SourceCode m_classSource;
2272         const Identifier&amp; m_name;
2273         const Identifier* m_ecmaName;
2274         ExpressionNode* m_constructorExpression;
2275         ExpressionNode* m_classHeritage;
2276         PropertyListNode* m_classElements;
<span class="line-added">2277         bool m_needsLexicalScope;</span>
2278     };
2279 
2280     class DestructuringPatternNode : public ParserArenaFreeable {
2281     public:
2282         virtual ~DestructuringPatternNode() { }
2283         virtual void collectBoundIdentifiers(Vector&lt;Identifier&gt;&amp;) const = 0;
2284         virtual void bindValue(BytecodeGenerator&amp;, RegisterID* source) const = 0;
2285         virtual void toString(StringBuilder&amp;) const = 0;
2286 
2287         virtual bool isBindingNode() const { return false; }
2288         virtual bool isAssignmentElementNode() const { return false; }
2289         virtual bool isRestParameter() const { return false; }
2290         virtual RegisterID* emitDirectBinding(BytecodeGenerator&amp;, RegisterID*, ExpressionNode*) { return 0; }
2291 
2292     protected:
2293         DestructuringPatternNode();
2294     };
2295 
2296     class ArrayPatternNode final : public DestructuringPatternNode, public ParserArenaDeletable, public ThrowableExpressionData {
2297         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(ArrayPatternNode);
</pre>
<hr />
<pre>
2515     public:
2516         ClauseListNode(CaseClauseNode*);
2517         ClauseListNode(ClauseListNode*, CaseClauseNode*);
2518 
2519         CaseClauseNode* getClause() const { return m_clause; }
2520         ClauseListNode* getNext() const { return m_next; }
2521 
2522     private:
2523         CaseClauseNode* m_clause;
2524         ClauseListNode* m_next { nullptr };
2525     };
2526 
2527     class CaseBlockNode final : public ParserArenaFreeable {
2528     public:
2529         CaseBlockNode(ClauseListNode* list1, CaseClauseNode* defaultClause, ClauseListNode* list2);
2530 
2531         void emitBytecodeForBlock(BytecodeGenerator&amp;, RegisterID* input, RegisterID* destination);
2532 
2533     private:
2534         SwitchInfo::SwitchType tryTableSwitch(Vector&lt;ExpressionNode*, 8&gt;&amp; literalVector, int32_t&amp; min_num, int32_t&amp; max_num);
<span class="line-modified">2535         static constexpr size_t s_tableSwitchMinimum = 3;</span>
2536         ClauseListNode* m_list1;
2537         CaseClauseNode* m_defaultClause;
2538         ClauseListNode* m_list2;
2539     };
2540 
2541     class SwitchNode final : public StatementNode, public VariableEnvironmentNode {
2542         JSC_MAKE_PARSER_ARENA_DELETABLE_ALLOCATED(SwitchNode);
2543     public:
2544         SwitchNode(const JSTokenLocation&amp;, ExpressionNode*, CaseBlockNode*, VariableEnvironment&amp;, FunctionStack&amp;&amp;);
2545 
2546     private:
2547         void emitBytecode(BytecodeGenerator&amp;, RegisterID* = 0) override;
2548 
2549         ExpressionNode* m_expr;
2550         CaseBlockNode* m_block;
2551     };
2552 
2553     struct ElementList {
2554         ElementNode* head;
2555         ElementNode* tail;
</pre>
</td>
</tr>
</table>
<center><a href="Nodes.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Parser.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
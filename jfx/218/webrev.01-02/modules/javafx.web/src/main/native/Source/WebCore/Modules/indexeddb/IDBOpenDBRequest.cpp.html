<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBOpenDBRequest.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015, 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;IDBOpenDBRequest.h&quot;
 28 
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;DOMException.h&quot;
 32 #include &quot;EventNames.h&quot;
 33 #include &quot;IDBConnectionProxy.h&quot;
 34 #include &quot;IDBConnectionToServer.h&quot;
 35 #include &quot;IDBDatabase.h&quot;
 36 #include &quot;IDBError.h&quot;
 37 #include &quot;IDBRequestCompletionEvent.h&quot;
 38 #include &quot;IDBResultData.h&quot;
 39 #include &quot;IDBTransaction.h&quot;
 40 #include &quot;IDBVersionChangeEvent.h&quot;
 41 #include &quot;Logging.h&quot;
 42 #include &quot;ScriptExecutionContext.h&quot;
 43 #include &lt;wtf/IsoMallocInlines.h&gt;
 44 
 45 namespace WebCore {
 46 
 47 WTF_MAKE_ISO_ALLOCATED_IMPL(IDBOpenDBRequest);
 48 
 49 Ref&lt;IDBOpenDBRequest&gt; IDBOpenDBRequest::createDeleteRequest(ScriptExecutionContext&amp; context, IDBClient::IDBConnectionProxy&amp; connectionProxy, const IDBDatabaseIdentifier&amp; databaseIdentifier)
 50 {
 51     return adoptRef(*new IDBOpenDBRequest(context, connectionProxy, databaseIdentifier, 0, IndexedDB::RequestType::Delete));
 52 }
 53 
 54 Ref&lt;IDBOpenDBRequest&gt; IDBOpenDBRequest::createOpenRequest(ScriptExecutionContext&amp; context, IDBClient::IDBConnectionProxy&amp; connectionProxy, const IDBDatabaseIdentifier&amp; databaseIdentifier, uint64_t version)
 55 {
 56     return adoptRef(*new IDBOpenDBRequest(context, connectionProxy, databaseIdentifier, version, IndexedDB::RequestType::Open));
 57 }
 58 
 59 IDBOpenDBRequest::IDBOpenDBRequest(ScriptExecutionContext&amp; context, IDBClient::IDBConnectionProxy&amp; connectionProxy, const IDBDatabaseIdentifier&amp; databaseIdentifier, uint64_t version, IndexedDB::RequestType requestType)
 60     : IDBRequest(context, connectionProxy)
 61     , m_databaseIdentifier(databaseIdentifier)
 62     , m_version(version)
 63 {
 64     m_requestType = requestType;
 65 }
 66 
 67 IDBOpenDBRequest::~IDBOpenDBRequest()
 68 {
 69     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
 70 }
 71 
 72 void IDBOpenDBRequest::onError(const IDBResultData&amp; data)
 73 {
 74     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
 75 
 76     m_domError = data.error().toDOMException();
 77     enqueueEvent(IDBRequestCompletionEvent::create(eventNames().errorEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes, *this));
 78 }
 79 
 80 void IDBOpenDBRequest::versionChangeTransactionDidFinish()
 81 {
 82     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
 83 
 84     // 3.3.7 &quot;versionchange&quot; transaction steps
 85     // When the transaction is finished, after firing complete/abort on the transaction, immediately set request&#39;s transaction property to null.
 86     m_shouldExposeTransactionToDOM = false;
 87 }
 88 
 89 void IDBOpenDBRequest::fireSuccessAfterVersionChangeCommit()
 90 {
 91     LOG(IndexedDB, &quot;IDBOpenDBRequest::fireSuccessAfterVersionChangeCommit() - %s&quot;, resourceIdentifier().loggingString().utf8().data());
 92 
 93     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
 94     ASSERT(hasPendingActivity());
 95     m_transaction-&gt;addRequest(*this);
 96 
 97     auto event = IDBRequestCompletionEvent::create(eventNames().successEvent, Event::CanBubble::No, Event::IsCancelable::No, *this);
 98     m_openDatabaseSuccessEvent = &amp;event.get();
 99 
100     enqueueEvent(WTFMove(event));
101 }
102 
103 void IDBOpenDBRequest::fireErrorAfterVersionChangeCompletion()
104 {
105     LOG(IndexedDB, &quot;IDBOpenDBRequest::fireErrorAfterVersionChangeCompletion() - %s&quot;, resourceIdentifier().loggingString().utf8().data());
106 
107     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
108     ASSERT(hasPendingActivity());
109 
110     IDBError idbError(AbortError);
111     m_domError = DOMException::create(AbortError);
112     setResultToUndefined();
113 
114     m_transaction-&gt;addRequest(*this);
115     enqueueEvent(IDBRequestCompletionEvent::create(eventNames().errorEvent, Event::CanBubble::Yes, Event::IsCancelable::Yes, *this));
116 }
117 
118 void IDBOpenDBRequest::cancelForStop()
119 {
120     connectionProxy().openDBRequestCancelled({ connectionProxy(), *this });
121 }
122 
123 void IDBOpenDBRequest::dispatchEvent(Event&amp; event)
124 {
125     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
126 
127     auto protectedThis = makeRef(*this);
128 
129     IDBRequest::dispatchEvent(event);
130 
131     if (m_transaction &amp;&amp; m_transaction-&gt;isVersionChange() &amp;&amp; (event.type() == eventNames().errorEvent || event.type() == eventNames().successEvent))
132         m_transaction-&gt;database().connectionProxy().didFinishHandlingVersionChangeTransaction(m_transaction-&gt;database().databaseConnectionIdentifier(), *m_transaction);
133 }
134 
135 void IDBOpenDBRequest::onSuccess(const IDBResultData&amp; resultData)
136 {
137     LOG(IndexedDB, &quot;IDBOpenDBRequest::onSuccess()&quot;);
138 
139     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
140 
141     setResult(IDBDatabase::create(*scriptExecutionContext(), connectionProxy(), resultData));
142     m_readyState = ReadyState::Done;
143 
144     enqueueEvent(IDBRequestCompletionEvent::create(eventNames().successEvent, Event::CanBubble::No, Event::IsCancelable::No, *this));
145 }
146 
147 void IDBOpenDBRequest::onUpgradeNeeded(const IDBResultData&amp; resultData)
148 {
149     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
150 
151     Ref&lt;IDBDatabase&gt; database = IDBDatabase::create(*scriptExecutionContext(), connectionProxy(), resultData);
152     Ref&lt;IDBTransaction&gt; transaction = database-&gt;startVersionChangeTransaction(resultData.transactionInfo(), *this);
153 
154     ASSERT(transaction-&gt;info().mode() == IDBTransactionMode::Versionchange);
155     ASSERT(transaction-&gt;originalDatabaseInfo());
156 
157     uint64_t oldVersion = transaction-&gt;originalDatabaseInfo()-&gt;version();
158     uint64_t newVersion = transaction-&gt;info().newVersion();
159 
160     LOG(IndexedDB, &quot;IDBOpenDBRequest::onUpgradeNeeded() - current version is %&quot; PRIu64 &quot;, new is %&quot; PRIu64, oldVersion, newVersion);
161 
162     setResult(WTFMove(database));
163     m_readyState = ReadyState::Done;
164     m_transaction = WTFMove(transaction);
165     m_transaction-&gt;addRequest(*this);
166 
167     enqueueEvent(IDBVersionChangeEvent::create(oldVersion, newVersion, eventNames().upgradeneededEvent));
168 }
169 
170 void IDBOpenDBRequest::onDeleteDatabaseSuccess(const IDBResultData&amp; resultData)
171 {
172     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
173 
174     uint64_t oldVersion = resultData.databaseInfo().version();
175 
176     LOG(IndexedDB, &quot;IDBOpenDBRequest::onDeleteDatabaseSuccess() - current version is %&quot; PRIu64, oldVersion);
177 
178     m_readyState = ReadyState::Done;
179     setResultToUndefined();
180 
181     enqueueEvent(IDBVersionChangeEvent::create(oldVersion, 0, eventNames().successEvent));
182 }
183 
184 void IDBOpenDBRequest::requestCompleted(const IDBResultData&amp; data)
185 {
186     LOG(IndexedDB, &quot;IDBOpenDBRequest::requestCompleted&quot;);
187 
188     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
189 
190     m_isBlocked = false;
191 
192     // If an Open request was completed after the page has navigated, leaving this request
193     // with a stopped script execution context, we need to message back to the server so it
194     // doesn&#39;t hang waiting on a database connection or transaction that will never exist.
195     if (m_contextStopped) {
196         switch (data.type()) {
197         case IDBResultType::OpenDatabaseSuccess:
198             connectionProxy().abortOpenAndUpgradeNeeded(data.databaseConnectionIdentifier(), IDBResourceIdentifier::emptyValue());
199             break;
200         case IDBResultType::OpenDatabaseUpgradeNeeded:
201             connectionProxy().abortOpenAndUpgradeNeeded(data.databaseConnectionIdentifier(), data.transactionInfo().identifier());
202             break;
203         default:
204             break;
205         }
206 
207         return;
208     }
209 
210     switch (data.type()) {
211     case IDBResultType::Error:
212         onError(data);
213         break;
214     case IDBResultType::OpenDatabaseSuccess:
215         onSuccess(data);
216         break;
217     case IDBResultType::OpenDatabaseUpgradeNeeded:
218         onUpgradeNeeded(data);
219         break;
220     case IDBResultType::DeleteDatabaseSuccess:
221         onDeleteDatabaseSuccess(data);
222         break;
223     default:
224         RELEASE_ASSERT_NOT_REACHED();
225     }
226 }
227 
228 void IDBOpenDBRequest::requestBlocked(uint64_t oldVersion, uint64_t newVersion)
229 {
230     ASSERT(canCurrentThreadAccessThreadLocalData(originThread()));
231     ASSERT(!m_isBlocked);
232 
233     m_isBlocked = true;
234 
235     LOG(IndexedDB, &quot;IDBOpenDBRequest::requestBlocked&quot;);
236     enqueueEvent(IDBVersionChangeEvent::create(oldVersion, newVersion, eventNames().blockedEvent));
237 }
238 
239 void IDBOpenDBRequest::setIsContextSuspended(bool isContextSuspended)
240 {
241     m_isContextSuspended = isContextSuspended;
242 
243     // If this request is blocked, it means this request is being processed on the server.
244     // The client needs to actively stop the request so it doesn&#39;t blocks the processing of subsequent requests.
245     if (m_isBlocked) {
246         IDBRequestData requestData(connectionProxy(), *this);
247         connectionProxy().openDBRequestCancelled(requestData);
248         auto result = IDBResultData::error(requestData.requestIdentifier(), IDBError { UnknownError, &quot;Blocked open request on cached page is aborted to unblock other requests&quot;_s });
249         requestCompleted(result);
250     }
251 }
252 
253 } // namespace WebCore
254 
255 #endif // ENABLE(INDEXED_DATABASE)
    </pre>
  </body>
</html>
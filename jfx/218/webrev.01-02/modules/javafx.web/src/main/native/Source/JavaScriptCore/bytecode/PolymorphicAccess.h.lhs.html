<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PolymorphicAccess.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2014-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(JIT)
 29 
 30 #include &quot;AccessCase.h&quot;
 31 #include &quot;JITStubRoutine.h&quot;
 32 #include &quot;JSFunctionInlines.h&quot;
 33 #include &quot;MacroAssembler.h&quot;
 34 #include &quot;ScratchRegisterAllocator.h&quot;
 35 #include &lt;wtf/Vector.h&gt;
 36 
 37 namespace JSC {
 38 namespace DOMJIT {
 39 class GetterSetter;
 40 }
 41 
 42 class CodeBlock;
 43 class PolymorphicAccess;
 44 class StructureStubInfo;
 45 class WatchpointsOnStructureStubInfo;
 46 class ScratchRegisterAllocator;
 47 
<a name="2" id="anc2"></a>

 48 class AccessGenerationResult {
 49 public:
 50     enum Kind {
 51         MadeNoChanges,
 52         GaveUp,
 53         Buffered,
 54         GeneratedNewCode,
 55         GeneratedFinalCode, // Generated so much code that we never want to generate code again.
 56         ResetStubAndFireWatchpoints // We found out some data that makes us want to start over fresh with this stub. Currently, this happens when we detect poly proto.
 57     };
 58 
 59 
 60     AccessGenerationResult() = default;
 61     AccessGenerationResult(AccessGenerationResult&amp;&amp;) = default;
 62     AccessGenerationResult&amp; operator=(AccessGenerationResult&amp;&amp;) = default;
 63 
 64     AccessGenerationResult(Kind kind)
 65         : m_kind(kind)
 66     {
 67         RELEASE_ASSERT(kind != GeneratedNewCode);
 68         RELEASE_ASSERT(kind != GeneratedFinalCode);
 69     }
 70 
 71     AccessGenerationResult(Kind kind, MacroAssemblerCodePtr&lt;JITStubRoutinePtrTag&gt; code)
 72         : m_kind(kind)
 73         , m_code(code)
 74     {
 75         RELEASE_ASSERT(kind == GeneratedNewCode || kind == GeneratedFinalCode);
 76         RELEASE_ASSERT(code);
 77     }
 78 
 79     bool operator==(const AccessGenerationResult&amp; other) const
 80     {
 81         return m_kind == other.m_kind &amp;&amp; m_code == other.m_code;
 82     }
 83 
 84     bool operator!=(const AccessGenerationResult&amp; other) const
 85     {
 86         return !(*this == other);
 87     }
 88 
 89     explicit operator bool() const
 90     {
 91         return *this != AccessGenerationResult();
 92     }
 93 
 94     Kind kind() const { return m_kind; }
 95 
 96     const MacroAssemblerCodePtr&lt;JITStubRoutinePtrTag&gt;&amp; code() const { return m_code; }
 97 
 98     bool madeNoChanges() const { return m_kind == MadeNoChanges; }
 99     bool gaveUp() const { return m_kind == GaveUp; }
100     bool buffered() const { return m_kind == Buffered; }
101     bool generatedNewCode() const { return m_kind == GeneratedNewCode; }
102     bool generatedFinalCode() const { return m_kind == GeneratedFinalCode; }
103     bool shouldResetStubAndFireWatchpoints() const { return m_kind == ResetStubAndFireWatchpoints; }
104 
105     // If we gave up on this attempt to generate code, or if we generated the &quot;final&quot; code, then we
106     // should give up after this.
107     bool shouldGiveUpNow() const { return gaveUp() || generatedFinalCode(); }
108 
109     bool generatedSomeCode() const { return generatedNewCode() || generatedFinalCode(); }
110 
111     void dump(PrintStream&amp;) const;
112 
113     void addWatchpointToFire(InlineWatchpointSet&amp; set, StringFireDetail detail)
114     {
115         m_watchpointsToFire.append(std::pair&lt;InlineWatchpointSet&amp;, StringFireDetail&gt;(set, detail));
116     }
117     void fireWatchpoints(VM&amp; vm)
118     {
119         ASSERT(m_kind == ResetStubAndFireWatchpoints);
120         for (auto&amp; pair : m_watchpointsToFire)
121             pair.first.invalidate(vm, pair.second);
122     }
123 
124 private:
125     Kind m_kind;
126     MacroAssemblerCodePtr&lt;JITStubRoutinePtrTag&gt; m_code;
127     Vector&lt;std::pair&lt;InlineWatchpointSet&amp;, StringFireDetail&gt;&gt; m_watchpointsToFire;
128 };
129 
130 class PolymorphicAccess {
131     WTF_MAKE_NONCOPYABLE(PolymorphicAccess);
<a name="3" id="anc3"></a><span class="line-modified">132     WTF_MAKE_FAST_ALLOCATED;</span>
133 public:
134     PolymorphicAccess();
135     ~PolymorphicAccess();
136 
137     // When this fails (returns GaveUp), this will leave the old stub intact but you should not try
138     // to call this method again for that PolymorphicAccess instance.
139     AccessGenerationResult addCases(
<a name="4" id="anc4"></a><span class="line-modified">140         const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;, const Identifier&amp;, Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt;);</span>
141 
142     AccessGenerationResult addCase(
<a name="5" id="anc5"></a><span class="line-modified">143         const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;, const Identifier&amp;, std::unique_ptr&lt;AccessCase&gt;);</span>
144 
<a name="6" id="anc6"></a><span class="line-modified">145     AccessGenerationResult regenerate(const GCSafeConcurrentJSLocker&amp;, VM&amp;, CodeBlock*, StructureStubInfo&amp;, const Identifier&amp;);</span>
146 
147     bool isEmpty() const { return m_list.isEmpty(); }
148     unsigned size() const { return m_list.size(); }
149     const AccessCase&amp; at(unsigned i) const { return *m_list[i]; }
150     const AccessCase&amp; operator[](unsigned i) const { return *m_list[i]; }
151 
<a name="7" id="anc7"></a>

152     // If this returns false then we are requesting a reset of the owning StructureStubInfo.
153     bool visitWeak(VM&amp;) const;
154 
155     // This returns true if it has marked everything it will ever marked. This can be used as an
156     // optimization to then avoid calling this method again during the fixpoint.
157     bool propagateTransitions(SlotVisitor&amp;) const;
158 
159     void aboutToDie();
160 
161     void dump(PrintStream&amp; out) const;
162     bool containsPC(void* pc) const
163     {
164         if (!m_stubRoutine)
165             return false;
166 
167         uintptr_t pcAsInt = bitwise_cast&lt;uintptr_t&gt;(pc);
168         return m_stubRoutine-&gt;startAddress() &lt;= pcAsInt &amp;&amp; pcAsInt &lt;= m_stubRoutine-&gt;endAddress();
169     }
170 
171 private:
172     friend class AccessCase;
173     friend class CodeBlock;
174     friend struct AccessGenerationState;
175 
176     typedef Vector&lt;std::unique_ptr&lt;AccessCase&gt;, 2&gt; ListType;
177 
178     void commit(
179         const GCSafeConcurrentJSLocker&amp;, VM&amp;, std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt;&amp;, CodeBlock*, StructureStubInfo&amp;,
<a name="8" id="anc8"></a><span class="line-modified">180         const Identifier&amp;, AccessCase&amp;);</span>
181 
182     ListType m_list;
183     RefPtr&lt;JITStubRoutine&gt; m_stubRoutine;
184     std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt; m_watchpoints;
185     std::unique_ptr&lt;Vector&lt;WriteBarrier&lt;JSCell&gt;&gt;&gt; m_weakReferences;
186 };
187 
188 struct AccessGenerationState {
189     AccessGenerationState(VM&amp; vm, JSGlobalObject* globalObject)
190         : m_vm(vm)
191         , m_globalObject(globalObject)
192         , m_calculatedRegistersForCallAndExceptionHandling(false)
193         , m_needsToRestoreRegistersIfException(false)
194         , m_calculatedCallSiteIndex(false)
195     {
<a name="9" id="anc9"></a>
196     }
197     VM&amp; m_vm;
198     JSGlobalObject* m_globalObject;
199     CCallHelpers* jit { nullptr };
200     ScratchRegisterAllocator* allocator;
201     ScratchRegisterAllocator::PreservedState preservedReusedRegisterState;
202     PolymorphicAccess* access { nullptr };
203     StructureStubInfo* stubInfo { nullptr };
204     MacroAssembler::JumpList success;
205     MacroAssembler::JumpList failAndRepatch;
206     MacroAssembler::JumpList failAndIgnore;
207     GPRReg baseGPR { InvalidGPRReg };
<a name="10" id="anc10"></a><span class="line-modified">208     GPRReg thisGPR { InvalidGPRReg };</span>




209     JSValueRegs valueRegs;
210     GPRReg scratchGPR { InvalidGPRReg };
<a name="11" id="anc11"></a><span class="line-modified">211     const Identifier* ident;</span>
212     std::unique_ptr&lt;WatchpointsOnStructureStubInfo&gt; watchpoints;
213     Vector&lt;WriteBarrier&lt;JSCell&gt;&gt; weakReferences;
<a name="12" id="anc12"></a>
214 
<a name="13" id="anc13"></a><span class="line-modified">215     Watchpoint* addWatchpoint(const ObjectPropertyCondition&amp; = ObjectPropertyCondition());</span>
216 
217     void restoreScratch();
218     void succeed();
219 
220     struct SpillState {
221         SpillState() = default;
222         SpillState(RegisterSet&amp;&amp; regs, unsigned usedStackBytes)
223             : spilledRegisters(WTFMove(regs))
224             , numberOfStackBytesUsedForRegisterPreservation(usedStackBytes)
225         {
226         }
227 
228         RegisterSet spilledRegisters { };
229         unsigned numberOfStackBytesUsedForRegisterPreservation { std::numeric_limits&lt;unsigned&gt;::max() };
230 
231         bool isEmpty() const { return numberOfStackBytesUsedForRegisterPreservation == std::numeric_limits&lt;unsigned&gt;::max(); }
232     };
233 
234     const RegisterSet&amp; calculateLiveRegistersForCallAndExceptionHandling();
235 
236     SpillState preserveLiveRegistersToStackForCall(const RegisterSet&amp; extra = { });
237 
238     void restoreLiveRegistersFromStackForCallWithThrownException(const SpillState&amp;);
239     void restoreLiveRegistersFromStackForCall(const SpillState&amp;, const RegisterSet&amp; dontRestore = { });
240 
241     const RegisterSet&amp; liveRegistersForCall();
242 
243     CallSiteIndex callSiteIndexForExceptionHandlingOrOriginal();
244     DisposableCallSiteIndex callSiteIndexForExceptionHandling();
245 
246     const HandlerInfo&amp; originalExceptionHandler();
247 
248     bool needsToRestoreRegistersIfException() const { return m_needsToRestoreRegistersIfException; }
249     CallSiteIndex originalCallSiteIndex() const;
250 
251     void emitExplicitExceptionHandler();
252 
253     void setSpillStateForJSGetterSetter(SpillState&amp; spillState)
254     {
255         if (!m_spillStateForJSGetterSetter.isEmpty()) {
256             ASSERT(m_spillStateForJSGetterSetter.numberOfStackBytesUsedForRegisterPreservation == spillState.numberOfStackBytesUsedForRegisterPreservation);
257             ASSERT(m_spillStateForJSGetterSetter.spilledRegisters == spillState.spilledRegisters);
258         }
259         m_spillStateForJSGetterSetter = spillState;
260     }
261     SpillState spillStateForJSGetterSetter() const { return m_spillStateForJSGetterSetter; }
262 
263 private:
264     const RegisterSet&amp; liveRegistersToPreserveAtExceptionHandlingCallSite();
265 
266     RegisterSet m_liveRegistersToPreserveAtExceptionHandlingCallSite;
267     RegisterSet m_liveRegistersForCall;
268     CallSiteIndex m_callSiteIndex;
269     SpillState m_spillStateForJSGetterSetter;
270     bool m_calculatedRegistersForCallAndExceptionHandling : 1;
271     bool m_needsToRestoreRegistersIfException : 1;
272     bool m_calculatedCallSiteIndex : 1;
273 };
274 
275 } // namespace JSC
276 
277 namespace WTF {
278 
279 void printInternal(PrintStream&amp;, JSC::AccessGenerationResult::Kind);
280 void printInternal(PrintStream&amp;, JSC::AccessCase::AccessType);
281 void printInternal(PrintStream&amp;, JSC::AccessCase::State);
282 
283 } // namespace WTF
284 
285 #endif // ENABLE(JIT)
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
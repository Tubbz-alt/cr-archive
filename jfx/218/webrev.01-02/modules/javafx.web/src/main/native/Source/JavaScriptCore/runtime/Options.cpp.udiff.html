<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Options.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Operations.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Options.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Options.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -39,10 +39,11 @@</span>
  #include &lt;string.h&gt;
  #include &lt;wtf/ASCIICType.h&gt;
  #include &lt;wtf/Compiler.h&gt;
  #include &lt;wtf/DataLog.h&gt;
  #include &lt;wtf/NumberOfCores.h&gt;
<span class="udiff-line-added">+ #include &lt;wtf/Optional.h&gt;</span>
  #include &lt;wtf/PointerPreparations.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/text/StringBuilder.h&gt;
  #include &lt;wtf/threads/Signals.h&gt;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -54,103 +55,102 @@</span>
  #include &quot;MacroAssembler.h&quot;
  #endif
  
  namespace JSC {
  
<span class="udiff-line-modified-removed">- namespace {</span>
<span class="udiff-line-modified-removed">- #ifdef NDEBUG</span>
<span class="udiff-line-removed">- bool restrictedOptionsEnabled = false;</span>
<span class="udiff-line-removed">- #else</span>
<span class="udiff-line-removed">- bool restrictedOptionsEnabled = true;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- void Options::enableRestrictedOptions(bool enableOrNot)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     restrictedOptionsEnabled = enableOrNot;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-modified-added">+ template&lt;typename T&gt;</span>
<span class="udiff-line-modified-added">+ Optional&lt;T&gt; parse(const char* string);</span>
  
<span class="udiff-line-modified-removed">- static bool parse(const char* string, bool&amp; value)</span>
<span class="udiff-line-modified-added">+ template&lt;&gt;</span>
<span class="udiff-line-added">+ Optional&lt;OptionsStorage::Bool&gt; parse(const char* string)</span>
  {
<span class="udiff-line-modified-removed">-     if (equalLettersIgnoringASCIICase(string, &quot;true&quot;) || equalLettersIgnoringASCIICase(string, &quot;yes&quot;) || !strcmp(string, &quot;1&quot;)) {</span>
<span class="udiff-line-removed">-         value = true;</span>
<span class="udiff-line-modified-added">+     if (equalLettersIgnoringASCIICase(string, &quot;true&quot;) || equalLettersIgnoringASCIICase(string, &quot;yes&quot;) || !strcmp(string, &quot;1&quot;))</span>
          return true;
<span class="udiff-line-modified-removed">-     }</span>
<span class="udiff-line-modified-removed">-     if (equalLettersIgnoringASCIICase(string, &quot;false&quot;) || equalLettersIgnoringASCIICase(string, &quot;no&quot;) || !strcmp(string, &quot;0&quot;)) {</span>
<span class="udiff-line-modified-removed">-         value = false;</span>
<span class="udiff-line-removed">-         return true;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">-     return false;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">- static bool parse(const char* string, int32_t&amp; value)</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     return sscanf(string, &quot;%d&quot;, &amp;value) == 1;</span>
<span class="udiff-line-modified-added">+     if (equalLettersIgnoringASCIICase(string, &quot;false&quot;) || equalLettersIgnoringASCIICase(string, &quot;no&quot;) || !strcmp(string, &quot;0&quot;))</span>
<span class="udiff-line-modified-added">+         return false;</span>
<span class="udiff-line-modified-added">+     return WTF::nullopt;</span>
  }
  
<span class="udiff-line-modified-removed">- static bool parse(const char* string, unsigned&amp; value)</span>
<span class="udiff-line-modified-added">+ template&lt;&gt;</span>
<span class="udiff-line-added">+ Optional&lt;OptionsStorage::Int32&gt; parse(const char* string)</span>
  {
<span class="udiff-line-modified-removed">-     return sscanf(string, &quot;%u&quot;, &amp;value) == 1;</span>
<span class="udiff-line-modified-added">+     int32_t value;</span>
<span class="udiff-line-added">+     if (sscanf(string, &quot;%d&quot;, &amp;value) == 1)</span>
<span class="udiff-line-added">+         return value;</span>
<span class="udiff-line-added">+     return WTF::nullopt;</span>
  }
  
<span class="udiff-line-modified-removed">- static bool UNUSED_FUNCTION parse(const char* string, unsigned long&amp; value)</span>
<span class="udiff-line-modified-added">+ template&lt;&gt;</span>
<span class="udiff-line-added">+ Optional&lt;OptionsStorage::Unsigned&gt; parse(const char* string)</span>
  {
<span class="udiff-line-modified-removed">-     return sscanf(string, &quot;%lu&quot;, &amp;value);</span>
<span class="udiff-line-modified-added">+     unsigned value;</span>
<span class="udiff-line-added">+     if (sscanf(string, &quot;%u&quot;, &amp;value) == 1)</span>
<span class="udiff-line-added">+         return value;</span>
<span class="udiff-line-added">+     return WTF::nullopt;</span>
  }
  
<span class="udiff-line-modified-removed">- static bool UNUSED_FUNCTION parse(const char* string, unsigned long long&amp; value)</span>
<span class="udiff-line-modified-added">+ #if CPU(ADDRESS64) || OS(DARWIN)</span>
<span class="udiff-line-added">+ template&lt;&gt;</span>
<span class="udiff-line-added">+ Optional&lt;OptionsStorage::Size&gt; parse(const char* string)</span>
  {
<span class="udiff-line-modified-removed">-     return sscanf(string, &quot;%llu&quot;, &amp;value);</span>
<span class="udiff-line-modified-added">+     size_t value;</span>
<span class="udiff-line-added">+     if (sscanf(string, &quot;%zu&quot;, &amp;value) == 1)</span>
<span class="udiff-line-added">+         return value;</span>
<span class="udiff-line-added">+     return WTF::nullopt;</span>
  }
<span class="udiff-line-added">+ #endif // CPU(ADDRESS64) || OS(DARWIN)</span>
  
<span class="udiff-line-modified-removed">- static bool parse(const char* string, double&amp; value)</span>
<span class="udiff-line-modified-added">+ template&lt;&gt;</span>
<span class="udiff-line-added">+ Optional&lt;OptionsStorage::Double&gt; parse(const char* string)</span>
  {
<span class="udiff-line-modified-removed">-     return sscanf(string, &quot;%lf&quot;, &amp;value) == 1;</span>
<span class="udiff-line-modified-added">+     double value;</span>
<span class="udiff-line-added">+     if (sscanf(string, &quot;%lf&quot;, &amp;value) == 1)</span>
<span class="udiff-line-added">+         return value;</span>
<span class="udiff-line-added">+     return WTF::nullopt;</span>
  }
  
<span class="udiff-line-modified-removed">- static bool parse(const char* string, OptionRange&amp; value)</span>
<span class="udiff-line-modified-added">+ template&lt;&gt;</span>
<span class="udiff-line-added">+ Optional&lt;OptionsStorage::OptionRange&gt; parse(const char* string)</span>
  {
<span class="udiff-line-modified-removed">-     return value.init(string);</span>
<span class="udiff-line-modified-added">+     OptionRange range;</span>
<span class="udiff-line-added">+     if (range.init(string))</span>
<span class="udiff-line-added">+         return range;</span>
<span class="udiff-line-added">+     return WTF::nullopt;</span>
  }
  
<span class="udiff-line-modified-removed">- static bool parse(const char* string, const char*&amp; value)</span>
<span class="udiff-line-modified-added">+ template&lt;&gt;</span>
<span class="udiff-line-added">+ Optional&lt;OptionsStorage::OptionString&gt; parse(const char* string)</span>
  {
<span class="udiff-line-modified-removed">-     if (!strlen(string)) {</span>
<span class="udiff-line-modified-removed">-         value = nullptr;</span>
<span class="udiff-line-modified-removed">-         return true;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     const char* value = nullptr;</span>
<span class="udiff-line-modified-added">+     if (!strlen(string))</span>
<span class="udiff-line-modified-added">+         return value;</span>
  
      // FIXME &lt;https://webkit.org/b/169057&gt;: This could leak if this option is set more than once.
      // Given that Options are typically used for testing, this isn&#39;t considered to be a problem.
      value = WTF::fastStrDup(string);
<span class="udiff-line-modified-removed">-     return true;</span>
<span class="udiff-line-modified-added">+     return value;</span>
  }
  
<span class="udiff-line-modified-removed">- static bool parse(const char* string, GCLogging::Level&amp; value)</span>
<span class="udiff-line-modified-added">+ template&lt;&gt;</span>
<span class="udiff-line-added">+ Optional&lt;OptionsStorage::GCLogLevel&gt; parse(const char* string)</span>
  {
<span class="udiff-line-modified-removed">-     if (equalLettersIgnoringASCIICase(string, &quot;none&quot;) || equalLettersIgnoringASCIICase(string, &quot;no&quot;) || equalLettersIgnoringASCIICase(string, &quot;false&quot;) || !strcmp(string, &quot;0&quot;)) {</span>
<span class="udiff-line-modified-removed">-         value = GCLogging::None;</span>
<span class="udiff-line-removed">-         return true;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     if (equalLettersIgnoringASCIICase(string, &quot;none&quot;) || equalLettersIgnoringASCIICase(string, &quot;no&quot;) || equalLettersIgnoringASCIICase(string, &quot;false&quot;) || !strcmp(string, &quot;0&quot;))</span>
<span class="udiff-line-modified-added">+         return GCLogging::None;</span>
  
<span class="udiff-line-modified-removed">-     if (equalLettersIgnoringASCIICase(string, &quot;basic&quot;) || equalLettersIgnoringASCIICase(string, &quot;yes&quot;) || equalLettersIgnoringASCIICase(string, &quot;true&quot;) || !strcmp(string, &quot;1&quot;)) {</span>
<span class="udiff-line-modified-removed">-         value = GCLogging::Basic;</span>
<span class="udiff-line-removed">-         return true;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     if (equalLettersIgnoringASCIICase(string, &quot;basic&quot;) || equalLettersIgnoringASCIICase(string, &quot;yes&quot;) || equalLettersIgnoringASCIICase(string, &quot;true&quot;) || !strcmp(string, &quot;1&quot;))</span>
<span class="udiff-line-modified-added">+         return GCLogging::Basic;</span>
  
<span class="udiff-line-modified-removed">-     if (equalLettersIgnoringASCIICase(string, &quot;verbose&quot;) || !strcmp(string, &quot;2&quot;)) {</span>
<span class="udiff-line-modified-removed">-         value = GCLogging::Verbose;</span>
<span class="udiff-line-removed">-         return true;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     if (equalLettersIgnoringASCIICase(string, &quot;verbose&quot;) || !strcmp(string, &quot;2&quot;))</span>
<span class="udiff-line-modified-added">+         return GCLogging::Verbose;</span>
  
<span class="udiff-line-modified-removed">-     return false;</span>
<span class="udiff-line-modified-added">+     return WTF::nullopt;</span>
  }
  
  bool Options::isAvailable(Options::ID id, Options::Availability availability)
  {
      if (availability == Availability::Restricted)
<span class="udiff-line-modified-removed">-         return restrictedOptionsEnabled;</span>
<span class="udiff-line-modified-added">+         return g_jscConfig.restrictedOptionsEnabled;</span>
      ASSERT(availability == Availability::Configurable);
  
      UNUSED_PARAM(id);
  #if !defined(NDEBUG)
      if (id == maxSingleAllocationSizeID)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -179,12 +179,17 @@</span>
  
      const char* stringValue = getenv(name);
      if (!stringValue)
          return false;
  
<span class="udiff-line-modified-removed">-     if (available &amp;&amp; parse(stringValue, variable))</span>
<span class="udiff-line-modified-removed">-         return true;</span>
<span class="udiff-line-modified-added">+     if (available) {</span>
<span class="udiff-line-modified-added">+         Optional&lt;T&gt; value = parse&lt;T&gt;(stringValue);</span>
<span class="udiff-line-added">+         if (value) {</span>
<span class="udiff-line-added">+             variable = value.value();</span>
<span class="udiff-line-added">+             return true;</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+     }</span>
  
      fprintf(stderr, &quot;WARNING: failed to parse %s=%s\n&quot;, name, stringValue);
      return false;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -293,51 +298,38 @@</span>
  void OptionRange::dump(PrintStream&amp; out) const
  {
      out.print(m_rangeString);
  }
  
<span class="udiff-line-removed">- Options::Entry Options::s_options[Options::numberOfOptions];</span>
<span class="udiff-line-removed">- Options::Entry Options::s_defaultOptions[Options::numberOfOptions];</span>
<span class="udiff-line-removed">- </span>
  // Realize the names for each of the options:
<span class="udiff-line-modified-removed">- const Options::EntryInfo Options::s_optionsInfo[Options::numberOfOptions] = {</span>
<span class="udiff-line-modified-removed">- #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \</span>
<span class="udiff-line-modified-removed">-     { #name_, description_, Options::Type::type_##Type, Availability::availability_ },</span>
<span class="udiff-line-modified-removed">-     JSC_OPTIONS(FOR_EACH_OPTION)</span>
<span class="udiff-line-modified-removed">- #undef FOR_EACH_OPTION</span>
<span class="udiff-line-modified-added">+ const Options::ConstMetaData Options::s_constMetaData[NumberOfOptions] = {</span>
<span class="udiff-line-modified-added">+ #define FILL_OPTION_INFO(type_, name_, defaultValue_, availability_, description_) \</span>
<span class="udiff-line-modified-added">+     { #name_, description_, Options::Type::type_, Availability::availability_, offsetof(OptionsStorage, name_), offsetof(OptionsStorage, name_##Default) },</span>
<span class="udiff-line-modified-added">+     FOR_EACH_JSC_OPTION(FILL_OPTION_INFO)</span>
<span class="udiff-line-modified-added">+ #undef FILL_OPTION_INFO</span>
  };
  
  static void scaleJITPolicy()
  {
      auto&amp; scaleFactor = Options::jitPolicyScale();
      if (scaleFactor &gt; 1.0)
          scaleFactor = 1.0;
      else if (scaleFactor &lt; 0.0)
          scaleFactor = 0.0;
  
<span class="udiff-line-modified-removed">-     struct OptionToScale {</span>
<span class="udiff-line-modified-removed">-         Options::ID id;</span>
<span class="udiff-line-modified-removed">-         int32_t minVal;</span>
<span class="udiff-line-modified-added">+     auto scaleOption = [&amp;] (int32_t&amp; optionValue, int32_t minValue) {</span>
<span class="udiff-line-modified-added">+         optionValue *= scaleFactor;</span>
<span class="udiff-line-modified-added">+         optionValue = std::max(optionValue, minValue);</span>
      };
  
<span class="udiff-line-modified-removed">-     static const OptionToScale optionsToScale[] = {</span>
<span class="udiff-line-modified-removed">-         { Options::thresholdForJITAfterWarmUpID, 0 },</span>
<span class="udiff-line-modified-removed">-         { Options::thresholdForJITSoonID, 0 },</span>
<span class="udiff-line-modified-removed">-         { Options::thresholdForOptimizeAfterWarmUpID, 1 },</span>
<span class="udiff-line-modified-removed">-         { Options::thresholdForOptimizeAfterLongWarmUpID, 1 },</span>
<span class="udiff-line-modified-removed">-         { Options::thresholdForOptimizeSoonID, 1 },</span>
<span class="udiff-line-modified-removed">-         { Options::thresholdForFTLOptimizeSoonID, 2 },</span>
<span class="udiff-line-removed">-         { Options::thresholdForFTLOptimizeAfterWarmUpID, 2 }</span>
<span class="udiff-line-removed">-     };</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     const int numberOfOptionsToScale = sizeof(optionsToScale) / sizeof(OptionToScale);</span>
<span class="udiff-line-removed">-     for (int i = 0; i &lt; numberOfOptionsToScale; i++) {</span>
<span class="udiff-line-removed">-         Option option(optionsToScale[i].id);</span>
<span class="udiff-line-removed">-         ASSERT(option.type() == Options::Type::int32Type);</span>
<span class="udiff-line-removed">-         option.int32Val() *= scaleFactor;</span>
<span class="udiff-line-removed">-         option.int32Val() = std::max(option.int32Val(), optionsToScale[i].minVal);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     scaleOption(Options::thresholdForJITAfterWarmUp(), 0);</span>
<span class="udiff-line-modified-added">+     scaleOption(Options::thresholdForJITSoon(), 0);</span>
<span class="udiff-line-modified-added">+     scaleOption(Options::thresholdForOptimizeAfterWarmUp(), 1);</span>
<span class="udiff-line-modified-added">+     scaleOption(Options::thresholdForOptimizeAfterLongWarmUp(), 1);</span>
<span class="udiff-line-modified-added">+     scaleOption(Options::thresholdForOptimizeSoon(), 1);</span>
<span class="udiff-line-modified-added">+     scaleOption(Options::thresholdForFTLOptimizeSoon(), 2);</span>
<span class="udiff-line-modified-added">+     scaleOption(Options::thresholdForFTLOptimizeAfterWarmUp(), 2);</span>
  }
  
  static void overrideDefaults()
  {
  #if !PLATFORM(IOS_FAMILY)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -352,19 +344,19 @@</span>
              Options::gcIncrementScale() = 1;
          else
              Options::gcIncrementScale() = 0;
      }
  
<span class="udiff-line-modified-removed">- #if PLATFORM(IOS_FAMILY)</span>
<span class="udiff-line-modified-removed">-     // On iOS, we control heap growth using process memory footprint. Therefore these values can be agressive.</span>
<span class="udiff-line-modified-added">+ #if USE(BMALLOC_MEMORY_FOOTPRINT_API)</span>
<span class="udiff-line-modified-added">+     // On iOS and conditionally Linux, we control heap growth using process memory footprint. Therefore these values can be agressive.</span>
      Options::smallHeapRAMFraction() = 0.8;
      Options::mediumHeapRAMFraction() = 0.9;
<span class="udiff-line-added">+ #endif</span>
  
<span class="udiff-line-modified-removed">- #if !PLATFORM(WATCHOS) &amp;&amp; defined(__LP64__)</span>
<span class="udiff-line-modified-added">+ #if PLATFORM(IOS_FAMILY) &amp;&amp; !PLATFORM(WATCHOS) &amp;&amp; defined(__LP64__)</span>
      Options::useSigillCrashAnalyzer() = true;
  #endif
<span class="udiff-line-removed">- #endif</span>
  
  #if !ENABLE(SIGNAL_BASED_VM_TRAPS)
      Options::usePollingTraps() = true;
  #endif
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -373,10 +365,15 @@</span>
  #endif
  
  #if !HAVE(MACH_EXCEPTIONS)
      Options::useMachForExceptions() = false;
  #endif
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (Options::useWasmLLInt() &amp;&amp; !Options::wasmLLIntTiersUpToBBQ()) {</span>
<span class="udiff-line-added">+         Options::thresholdForOMGOptimizeAfterWarmUp() = 1500;</span>
<span class="udiff-line-added">+         Options::thresholdForOMGOptimizeSoon() = 100;</span>
<span class="udiff-line-added">+     }</span>
  }
  
  static void correctOptions()
  {
      unsigned thresholdForGlobalLexicalBindingEpoch = Options::thresholdForGlobalLexicalBindingEpoch();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -449,17 +446,17 @@</span>
          || Options::reportFTLCompileTimes()
          || Options::logPhaseTimes()
          || Options::verboseCFA()
          || Options::verboseDFGFailure()
          || Options::verboseFTLFailure()
<span class="udiff-line-modified-removed">-         || Options::dumpRandomizingFuzzerAgentPredictions())</span>
<span class="udiff-line-modified-added">+         || Options::dumpFuzzerAgentPredictions())</span>
          Options::alwaysComputeHash() = true;
  
      if (!Options::useConcurrentGC())
          Options::collectContinuously() = false;
  
<span class="udiff-line-modified-removed">-     if (Option(Options::jitPolicyScaleID).isOverridden())</span>
<span class="udiff-line-modified-added">+     if (Options::jitPolicyScale() != Options::jitPolicyScaleDefault())</span>
          scaleJITPolicy();
  
      if (Options::forceEagerCompilation()) {
          Options::thresholdForJITAfterWarmUp() = 10;
          Options::thresholdForJITSoon() = 10;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -510,33 +507,61 @@</span>
      if (Options::reservedZoneSize() &lt; minimumReservedZoneSize)
          Options::reservedZoneSize() = minimumReservedZoneSize;
      if (Options::softReservedZoneSize() &lt; Options::reservedZoneSize() + minimumReservedZoneSize)
          Options::softReservedZoneSize() = Options::reservedZoneSize() + minimumReservedZoneSize;
  
<span class="udiff-line-removed">- #if USE(JSVALUE32_64)</span>
      // FIXME: Make probe OSR exit work on 32-bit:
      // https://bugs.webkit.org/show_bug.cgi?id=177956
      Options::useProbeOSRExit() = false;
<span class="udiff-line-removed">- #endif</span>
  
      if (!Options::useCodeCache())
          Options::diskCachePath() = nullptr;
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     if (Options::randomIntegrityAuditRate() &lt; 0)</span>
<span class="udiff-line-added">+         Options::randomIntegrityAuditRate() = 0;</span>
<span class="udiff-line-added">+     else if (Options::randomIntegrityAuditRate() &gt; 1.0)</span>
<span class="udiff-line-added">+         Options::randomIntegrityAuditRate() = 1.0;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline void* Options::addressOfOption(Options::ID id)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto offset = Options::s_constMetaData[id].offsetOfOption;</span>
<span class="udiff-line-added">+     return reinterpret_cast&lt;uint8_t*&gt;(&amp;g_jscConfig.options) + offset;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ inline void* Options::addressOfOptionDefault(Options::ID id)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     auto offset = Options::s_constMetaData[id].offsetOfOptionDefault;</span>
<span class="udiff-line-added">+     return reinterpret_cast&lt;uint8_t*&gt;(&amp;g_jscConfig.options) + offset;</span>
  }
  
  void Options::initialize()
  {
      static std::once_flag initializeOptionsOnceFlag;
  
      std::call_once(
          initializeOptionsOnceFlag,
          [] {
<span class="udiff-line-added">+             // Sanity check that options address computation is working.</span>
<span class="udiff-line-added">+             RELEASE_ASSERT(Options::addressOfOption(useKernTCSMID) ==  &amp;Options::useKernTCSM());</span>
<span class="udiff-line-added">+             RELEASE_ASSERT(Options::addressOfOptionDefault(useKernTCSMID) ==  &amp;Options::useKernTCSMDefault());</span>
<span class="udiff-line-added">+             RELEASE_ASSERT(Options::addressOfOption(gcMaxHeapSizeID) ==  &amp;Options::gcMaxHeapSize());</span>
<span class="udiff-line-added">+             RELEASE_ASSERT(Options::addressOfOptionDefault(gcMaxHeapSizeID) ==  &amp;Options::gcMaxHeapSizeDefault());</span>
<span class="udiff-line-added">+             RELEASE_ASSERT(Options::addressOfOption(forceOSRExitToLLIntID) ==  &amp;Options::forceOSRExitToLLInt());</span>
<span class="udiff-line-added">+             RELEASE_ASSERT(Options::addressOfOptionDefault(forceOSRExitToLLIntID) ==  &amp;Options::forceOSRExitToLLIntDefault());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ #ifndef NDEBUG</span>
<span class="udiff-line-added">+             Config::enableRestrictedOptions();</span>
<span class="udiff-line-added">+ #endif</span>
              // Initialize each of the options with their default values:
<span class="udiff-line-modified-removed">- #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \</span>
<span class="udiff-line-modified-removed">-             name_() = defaultValue_;                                    \</span>
<span class="udiff-line-modified-removed">-             name_##Default() = defaultValue_;</span>
<span class="udiff-line-modified-removed">-             JSC_OPTIONS(FOR_EACH_OPTION)</span>
<span class="udiff-line-modified-removed">- #undef FOR_EACH_OPTION</span>
<span class="udiff-line-modified-added">+ #define INIT_OPTION(type_, name_, defaultValue_, availability_, description_) { \</span>
<span class="udiff-line-modified-added">+                 auto value = defaultValue_; \</span>
<span class="udiff-line-modified-added">+                 name_() = value; \</span>
<span class="udiff-line-modified-added">+                 name_##Default() = value; \</span>
<span class="udiff-line-modified-added">+             }</span>
<span class="udiff-line-added">+             FOR_EACH_JSC_OPTION(INIT_OPTION)</span>
<span class="udiff-line-added">+ #undef INIT_OPTION</span>
  
              overrideDefaults();
  
              // Allow environment vars to override options if applicable.
              // The evn var should be the name of the option prefixed with
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -553,20 +578,20 @@</span>
                  }
              }
              if (hasBadOptions &amp;&amp; Options::validateOptions())
                  CRASH();
  #else // PLATFORM(COCOA)
<span class="udiff-line-modified-removed">- #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \</span>
<span class="udiff-line-modified-added">+ #define OVERRIDE_OPTION_WITH_HEURISTICS(type_, name_, defaultValue_, availability_, description_) \</span>
              overrideOptionWithHeuristic(name_(), name_##ID, &quot;JSC_&quot; #name_, Availability::availability_);
<span class="udiff-line-modified-removed">-             JSC_OPTIONS(FOR_EACH_OPTION)</span>
<span class="udiff-line-modified-removed">- #undef FOR_EACH_OPTION</span>
<span class="udiff-line-modified-added">+             FOR_EACH_JSC_OPTION(OVERRIDE_OPTION_WITH_HEURISTICS)</span>
<span class="udiff-line-modified-added">+ #undef OVERRIDE_OPTION_WITH_HEURISTICS</span>
  #endif // PLATFORM(COCOA)
  
<span class="udiff-line-modified-removed">- #define FOR_EACH_OPTION(aliasedName_, unaliasedName_, equivalence_) \</span>
<span class="udiff-line-modified-added">+ #define OVERRIDE_ALIASED_OPTION_WITH_HEURISTICS(aliasedName_, unaliasedName_, equivalence_) \</span>
              overrideAliasedOptionWithHeuristic(&quot;JSC_&quot; #aliasedName_);
<span class="udiff-line-modified-removed">-             JSC_ALIASED_OPTIONS(FOR_EACH_OPTION)</span>
<span class="udiff-line-modified-removed">- #undef FOR_EACH_OPTION</span>
<span class="udiff-line-modified-added">+             FOR_EACH_JSC_ALIASED_OPTION(OVERRIDE_ALIASED_OPTION_WITH_HEURISTICS)</span>
<span class="udiff-line-modified-added">+ #undef OVERRIDE_ALIASED_OPTION_WITH_HEURISTICS</span>
  
  #if 0
                  ; // Deconfuse editors that do auto indentation
  #endif
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -640,10 +665,11 @@</span>
      return isASCIISpace(c) || (c == &#39;,&#39;);
  }
  
  bool Options::setOptions(const char* optionsStr)
  {
<span class="udiff-line-added">+     RELEASE_ASSERT(!g_jscConfig.isPermanentlyFrozen);</span>
      Vector&lt;char*&gt; options;
  
      size_t length = strlen(optionsStr);
      char* optionsStrCopy = WTF::fastStrDup(optionsStr);
      char* end = optionsStrCopy + length;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -732,43 +758,41 @@</span>
      if (!equalStr)
          return false;
  
      const char* valueStr = equalStr + 1;
  
<span class="udiff-line-modified-removed">-     // For each option, check if the specify arg is a match. If so, set the arg</span>
<span class="udiff-line-modified-added">+     // For each option, check if the specified arg is a match. If so, set the arg</span>
      // if the value makes sense. Otherwise, move on to checking the next option.
<span class="udiff-line-modified-removed">- #define FOR_EACH_OPTION(type_, name_, defaultValue_, availability_, description_) \</span>
<span class="udiff-line-modified-added">+ #define SET_OPTION_IF_MATCH(type_, name_, defaultValue_, availability_, description_) \</span>
      if (strlen(#name_) == static_cast&lt;size_t&gt;(equalStr - arg)      \
          &amp;&amp; !strncmp(arg, #name_, equalStr - arg)) {                \
          if (Availability::availability_ != Availability::Normal     \
              &amp;&amp; !isAvailable(name_##ID, Availability::availability_)) \
              return false;                                          \
<span class="udiff-line-modified-removed">-         type_ value;                                               \</span>
<span class="udiff-line-modified-removed">-         value = (defaultValue_);                                   \</span>
<span class="udiff-line-modified-removed">-         bool success = parse(valueStr, value);                     \</span>
<span class="udiff-line-modified-removed">-         if (success) {                                             \</span>
<span class="udiff-line-removed">-             name_() = value;                                       \</span>
<span class="udiff-line-modified-added">+         Optional&lt;OptionsStorage::type_&gt; value;                     \</span>
<span class="udiff-line-modified-added">+         value = parse&lt;OptionsStorage::type_&gt;(valueStr);            \</span>
<span class="udiff-line-modified-added">+         if (value) {                                               \</span>
<span class="udiff-line-modified-added">+             name_() = value.value();                               \</span>
              correctOptions();                                      \
              recomputeDependentOptions();                           \
              return true;                                           \
          }                                                          \
          return false;                                              \
      }
  
<span class="udiff-line-modified-removed">-     JSC_OPTIONS(FOR_EACH_OPTION)</span>
<span class="udiff-line-modified-removed">- #undef FOR_EACH_OPTION</span>
<span class="udiff-line-modified-added">+     FOR_EACH_JSC_OPTION(SET_OPTION_IF_MATCH)</span>
<span class="udiff-line-modified-added">+ #undef SET_OPTION_IF_MATCH</span>
  
      return false; // No option matched.
  }
  
<span class="udiff-line-modified-removed">- static bool invertBoolOptionValue(const char* valueStr, const char*&amp; invertedValueStr)</span>
<span class="udiff-line-modified-added">+ static const char* invertBoolOptionValue(const char* valueStr)</span>
  {
<span class="udiff-line-modified-removed">-     bool boolValue;</span>
<span class="udiff-line-modified-removed">-     if (!parse(valueStr, boolValue))</span>
<span class="udiff-line-modified-removed">-         return false;</span>
<span class="udiff-line-modified-removed">-     invertedValueStr = boolValue ? &quot;false&quot; : &quot;true&quot;;</span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-modified-added">+     Optional&lt;OptionsStorage::Bool&gt; value = parse&lt;OptionsStorage::Bool&gt;(valueStr);</span>
<span class="udiff-line-modified-added">+     if (!value)</span>
<span class="udiff-line-modified-added">+         return nullptr;</span>
<span class="udiff-line-modified-added">+     return value.value() ? &quot;false&quot; : &quot;true&quot;;</span>
  }
  
  
  bool Options::setAliasedOption(const char* arg)
  {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -788,19 +812,19 @@</span>
          String unaliasedOption(#unaliasedName_);                        \
          if (equivalence == SameOption)                                  \
              unaliasedOption = unaliasedOption + equalStr;               \
          else {                                                          \
              ASSERT(equivalence == InvertedOption);                      \
<span class="udiff-line-modified-removed">-             const char* invertedValueStr = nullptr;                     \</span>
<span class="udiff-line-modified-removed">-             if (!invertBoolOptionValue(equalStr + 1, invertedValueStr)) \</span>
<span class="udiff-line-modified-added">+             auto* invertedValueStr = invertBoolOptionValue(equalStr + 1); \</span>
<span class="udiff-line-modified-added">+             if (!invertedValueStr)                                      \</span>
                  return false;                                           \
              unaliasedOption = unaliasedOption + &quot;=&quot; + invertedValueStr; \
          }                                                               \
          return setOptionWithoutAlias(unaliasedOption.utf8().data());   \
      }
  
<span class="udiff-line-modified-removed">-     JSC_ALIASED_OPTIONS(FOR_EACH_OPTION)</span>
<span class="udiff-line-modified-added">+     FOR_EACH_JSC_ALIASED_OPTION(FOR_EACH_OPTION)</span>
  #undef FOR_EACH_OPTION
  
      IGNORE_WARNINGS_END
  
      return false; // No option matched.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -821,11 +845,11 @@</span>
      if (title) {
          builder.append(title);
          builder.append(&#39;\n&#39;);
      }
  
<span class="udiff-line-modified-removed">-     for (int id = 0; id &lt; numberOfOptions; id++) {</span>
<span class="udiff-line-modified-added">+     for (size_t id = 0; id &lt; NumberOfOptions; id++) {</span>
          if (separator &amp;&amp; id)
              builder.append(separator);
          dumpOption(builder, level, static_cast&lt;ID&gt;(id), optionHeader, optionFooter, dumpDefaultsOption);
      }
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -840,17 +864,58 @@</span>
      StringBuilder builder;
      dumpAllOptions(builder, level, title, nullptr, &quot;   &quot;, &quot;\n&quot;, DumpDefaults);
      fprintf(stream, &quot;%s&quot;, builder.toString().utf8().data());
  }
  
<span class="udiff-line-added">+ struct OptionReader {</span>
<span class="udiff-line-added">+     class Option {</span>
<span class="udiff-line-added">+     public:</span>
<span class="udiff-line-added">+         void dump(StringBuilder&amp;) const;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         bool operator==(const Option&amp; other) const;</span>
<span class="udiff-line-added">+         bool operator!=(const Option&amp; other) const { return !(*this == other); }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         const char* name() const { return Options::s_constMetaData[m_id].name; }</span>
<span class="udiff-line-added">+         const char* description() const { return Options::s_constMetaData[m_id].description; }</span>
<span class="udiff-line-added">+         Options::Type type() const { return Options::s_constMetaData[m_id].type; }</span>
<span class="udiff-line-added">+         Options::Availability availability() const { return Options::s_constMetaData[m_id].availability; }</span>
<span class="udiff-line-added">+         bool isOverridden() const { return *this != OptionReader::defaultFor(m_id); }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     private:</span>
<span class="udiff-line-added">+         Option(Options::ID id, void* addressOfValue)</span>
<span class="udiff-line-added">+             : m_id(id)</span>
<span class="udiff-line-added">+         {</span>
<span class="udiff-line-added">+             initValue(addressOfValue);</span>
<span class="udiff-line-added">+         }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         void initValue(void* addressOfValue);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Options::ID m_id;</span>
<span class="udiff-line-added">+         union {</span>
<span class="udiff-line-added">+             bool m_bool;</span>
<span class="udiff-line-added">+             unsigned m_unsigned;</span>
<span class="udiff-line-added">+             double m_double;</span>
<span class="udiff-line-added">+             int32_t m_int32;</span>
<span class="udiff-line-added">+             size_t m_size;</span>
<span class="udiff-line-added">+             OptionRange m_optionRange;</span>
<span class="udiff-line-added">+             const char* m_optionString;</span>
<span class="udiff-line-added">+             GCLogging::Level m_gcLogLevel;</span>
<span class="udiff-line-added">+         };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         friend struct OptionReader;</span>
<span class="udiff-line-added">+     };</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     static const Option optionFor(Options::ID);</span>
<span class="udiff-line-added">+     static const Option defaultFor(Options::ID);</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
  void Options::dumpOption(StringBuilder&amp; builder, DumpLevel level, Options::ID id,
      const char* header, const char* footer, DumpDefaultsOption dumpDefaultsOption)
  {
<span class="udiff-line-modified-removed">-     if (id &gt;= numberOfOptions)</span>
<span class="udiff-line-removed">-         return; // Illegal option.</span>
<span class="udiff-line-modified-added">+     RELEASE_ASSERT(static_cast&lt;size_t&gt;(id) &lt; NumberOfOptions);</span>
  
<span class="udiff-line-modified-removed">-     Option option(id);</span>
<span class="udiff-line-modified-added">+     auto option = OptionReader::optionFor(id);</span>
      Availability availability = option.availability();
      if (availability != Availability::Normal &amp;&amp; !isAvailable(id, availability))
          return;
  
      bool wasOverridden = option.isOverridden();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -863,12 +928,13 @@</span>
          builder.append(header);
      builder.append(option.name(), &#39;=&#39;);
      option.dump(builder);
  
      if (wasOverridden &amp;&amp; (dumpDefaultsOption == DumpDefaults)) {
<span class="udiff-line-added">+         auto defaultOption = OptionReader::defaultFor(id);</span>
          builder.appendLiteral(&quot; (default: &quot;);
<span class="udiff-line-modified-removed">-         option.defaultOption().dump(builder);</span>
<span class="udiff-line-modified-added">+         defaultOption.dump(builder);</span>
          builder.appendLiteral(&quot;)&quot;);
      }
  
      if (needsDescription)
          builder.append(&quot;   ... &quot;, option.description());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -885,68 +951,109 @@</span>
      }
      if (!coherent)
          CRASH();
  }
  
<span class="udiff-line-modified-removed">- void Option::dump(StringBuilder&amp; builder) const</span>
<span class="udiff-line-modified-added">+ const OptionReader::Option OptionReader::optionFor(Options::ID id)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return Option(id, Options::addressOfOption(id));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ const OptionReader::Option OptionReader::defaultFor(Options::ID id)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     return Option(id, Options::addressOfOptionDefault(id));</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void OptionReader::Option::initValue(void* addressOfValue)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     Options::Type type = Options::s_constMetaData[m_id].type;</span>
<span class="udiff-line-added">+     switch (type) {</span>
<span class="udiff-line-added">+     case Options::Type::Bool:</span>
<span class="udiff-line-added">+         memcpy(&amp;m_bool, addressOfValue, sizeof(OptionsStorage::Bool));</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case Options::Type::Unsigned:</span>
<span class="udiff-line-added">+         memcpy(&amp;m_unsigned, addressOfValue, sizeof(OptionsStorage::Unsigned));</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case Options::Type::Double:</span>
<span class="udiff-line-added">+         memcpy(&amp;m_double, addressOfValue, sizeof(OptionsStorage::Double));</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case Options::Type::Int32:</span>
<span class="udiff-line-added">+         memcpy(&amp;m_int32, addressOfValue, sizeof(OptionsStorage::Int32));</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case Options::Type::Size:</span>
<span class="udiff-line-added">+         memcpy(&amp;m_size, addressOfValue, sizeof(OptionsStorage::Size));</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case Options::Type::OptionRange:</span>
<span class="udiff-line-added">+         memcpy(&amp;m_optionRange, addressOfValue, sizeof(OptionsStorage::OptionRange));</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case Options::Type::OptionString:</span>
<span class="udiff-line-added">+         memcpy(&amp;m_optionString, addressOfValue, sizeof(OptionsStorage::OptionString));</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     case Options::Type::GCLogLevel:</span>
<span class="udiff-line-added">+         memcpy(&amp;m_gcLogLevel, addressOfValue, sizeof(OptionsStorage::GCLogLevel));</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void OptionReader::Option::dump(StringBuilder&amp; builder) const</span>
  {
      switch (type()) {
<span class="udiff-line-modified-removed">-     case Options::Type::boolType:</span>
<span class="udiff-line-modified-removed">-         builder.append(m_entry.boolVal ? &quot;true&quot; : &quot;false&quot;);</span>
<span class="udiff-line-modified-added">+     case Options::Type::Bool:</span>
<span class="udiff-line-modified-added">+         builder.append(m_bool ? &quot;true&quot; : &quot;false&quot;);</span>
          break;
<span class="udiff-line-modified-removed">-     case Options::Type::unsignedType:</span>
<span class="udiff-line-modified-removed">-         builder.appendNumber(m_entry.unsignedVal);</span>
<span class="udiff-line-modified-added">+     case Options::Type::Unsigned:</span>
<span class="udiff-line-modified-added">+         builder.appendNumber(m_unsigned);</span>
          break;
<span class="udiff-line-modified-removed">-     case Options::Type::sizeType:</span>
<span class="udiff-line-modified-removed">-         builder.appendNumber(m_entry.sizeVal);</span>
<span class="udiff-line-modified-added">+     case Options::Type::Size:</span>
<span class="udiff-line-modified-added">+         builder.appendNumber(m_size);</span>
          break;
<span class="udiff-line-modified-removed">-     case Options::Type::doubleType:</span>
<span class="udiff-line-modified-removed">-         builder.appendFixedPrecisionNumber(m_entry.doubleVal);</span>
<span class="udiff-line-modified-added">+     case Options::Type::Double:</span>
<span class="udiff-line-modified-added">+         builder.append(m_double);</span>
          break;
<span class="udiff-line-modified-removed">-     case Options::Type::int32Type:</span>
<span class="udiff-line-modified-removed">-         builder.appendNumber(m_entry.int32Val);</span>
<span class="udiff-line-modified-added">+     case Options::Type::Int32:</span>
<span class="udiff-line-modified-added">+         builder.appendNumber(m_int32);</span>
          break;
<span class="udiff-line-modified-removed">-     case Options::Type::optionRangeType:</span>
<span class="udiff-line-modified-removed">-         builder.append(m_entry.optionRangeVal.rangeString());</span>
<span class="udiff-line-modified-added">+     case Options::Type::OptionRange:</span>
<span class="udiff-line-modified-added">+         builder.append(m_optionRange.rangeString());</span>
          break;
<span class="udiff-line-modified-removed">-     case Options::Type::optionStringType: {</span>
<span class="udiff-line-modified-removed">-         const char* option = m_entry.optionStringVal;</span>
<span class="udiff-line-modified-added">+     case Options::Type::OptionString: {</span>
<span class="udiff-line-modified-added">+         const char* option = m_optionString;</span>
          if (!option)
              option = &quot;&quot;;
          builder.append(&#39;&quot;&#39;);
          builder.append(option);
          builder.append(&#39;&quot;&#39;);
          break;
      }
<span class="udiff-line-modified-removed">-     case Options::Type::gcLogLevelType: {</span>
<span class="udiff-line-modified-removed">-         builder.append(GCLogging::levelAsString(m_entry.gcLogLevelVal));</span>
<span class="udiff-line-modified-added">+     case Options::Type::GCLogLevel: {</span>
<span class="udiff-line-modified-added">+         builder.append(GCLogging::levelAsString(m_gcLogLevel));</span>
          break;
      }
      }
  }
  
<span class="udiff-line-modified-removed">- bool Option::operator==(const Option&amp; other) const</span>
<span class="udiff-line-modified-added">+ bool OptionReader::Option::operator==(const Option&amp; other) const</span>
  {
<span class="udiff-line-added">+     ASSERT(type() == other.type());</span>
      switch (type()) {
<span class="udiff-line-modified-removed">-     case Options::Type::boolType:</span>
<span class="udiff-line-modified-removed">-         return m_entry.boolVal == other.m_entry.boolVal;</span>
<span class="udiff-line-modified-removed">-     case Options::Type::unsignedType:</span>
<span class="udiff-line-modified-removed">-         return m_entry.unsignedVal == other.m_entry.unsignedVal;</span>
<span class="udiff-line-modified-removed">-     case Options::Type::sizeType:</span>
<span class="udiff-line-modified-removed">-         return m_entry.sizeVal == other.m_entry.sizeVal;</span>
<span class="udiff-line-modified-removed">-     case Options::Type::doubleType:</span>
<span class="udiff-line-modified-removed">-         return (m_entry.doubleVal == other.m_entry.doubleVal) || (std::isnan(m_entry.doubleVal) &amp;&amp; std::isnan(other.m_entry.doubleVal));</span>
<span class="udiff-line-modified-removed">-     case Options::Type::int32Type:</span>
<span class="udiff-line-modified-removed">-         return m_entry.int32Val == other.m_entry.int32Val;</span>
<span class="udiff-line-modified-removed">-     case Options::Type::optionRangeType:</span>
<span class="udiff-line-modified-removed">-         return m_entry.optionRangeVal.rangeString() == other.m_entry.optionRangeVal.rangeString();</span>
<span class="udiff-line-modified-removed">-     case Options::Type::optionStringType:</span>
<span class="udiff-line-modified-removed">-         return (m_entry.optionStringVal == other.m_entry.optionStringVal)</span>
<span class="udiff-line-modified-removed">-             || (m_entry.optionStringVal &amp;&amp; other.m_entry.optionStringVal &amp;&amp; !strcmp(m_entry.optionStringVal, other.m_entry.optionStringVal));</span>
<span class="udiff-line-modified-removed">-     case Options::Type::gcLogLevelType:</span>
<span class="udiff-line-modified-removed">-         return m_entry.gcLogLevelVal == other.m_entry.gcLogLevelVal;</span>
<span class="udiff-line-modified-added">+     case Options::Type::Bool:</span>
<span class="udiff-line-modified-added">+         return m_bool == other.m_bool;</span>
<span class="udiff-line-modified-added">+     case Options::Type::Unsigned:</span>
<span class="udiff-line-modified-added">+         return m_unsigned == other.m_unsigned;</span>
<span class="udiff-line-modified-added">+     case Options::Type::Size:</span>
<span class="udiff-line-modified-added">+         return m_size == other.m_size;</span>
<span class="udiff-line-modified-added">+     case Options::Type::Double:</span>
<span class="udiff-line-modified-added">+         return (m_double == other.m_double) || (std::isnan(m_double) &amp;&amp; std::isnan(other.m_double));</span>
<span class="udiff-line-modified-added">+     case Options::Type::Int32:</span>
<span class="udiff-line-modified-added">+         return m_int32 == other.m_int32;</span>
<span class="udiff-line-modified-added">+     case Options::Type::OptionRange:</span>
<span class="udiff-line-modified-added">+         return m_optionRange.rangeString() == other.m_optionRange.rangeString();</span>
<span class="udiff-line-modified-added">+     case Options::Type::OptionString:</span>
<span class="udiff-line-modified-added">+         return (m_optionString == other.m_optionString)</span>
<span class="udiff-line-modified-added">+             || (m_optionString &amp;&amp; other.m_optionString &amp;&amp; !strcmp(m_optionString, other.m_optionString));</span>
<span class="udiff-line-modified-added">+     case Options::Type::GCLogLevel:</span>
<span class="udiff-line-modified-added">+         return m_gcLogLevel == other.m_gcLogLevel;</span>
      }
      return false;
  }
  
  } // namespace JSC
<span class="udiff-line-removed">- </span>
</pre>
<center><a href="Operations.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Options.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
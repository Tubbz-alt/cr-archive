<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bridge/runtime_object.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="runtime_method.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="runtime_object.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bridge/runtime_object.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;runtime_object.h&quot;
 28 
 29 #include &quot;JSDOMBinding.h&quot;

 30 #include &quot;runtime_method.h&quot;
 31 #include &lt;JavaScriptCore/Error.h&gt;
 32 
 33 using namespace WebCore;
 34 
 35 namespace JSC {
 36 namespace Bindings {
 37 
 38 WEBCORE_EXPORT const ClassInfo RuntimeObject::s_info = { &quot;RuntimeObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(RuntimeObject) };
 39 
 40 RuntimeObject::RuntimeObject(VM&amp; vm, Structure* structure, RefPtr&lt;Instance&gt;&amp;&amp; instance)
<span class="line-modified"> 41     : JSDestructibleObject(vm, structure)</span>
 42     , m_instance(WTFMove(instance))
 43 {
 44 }
 45 
 46 void RuntimeObject::finishCreation(VM&amp; vm)
 47 {
 48     Base::finishCreation(vm);
 49     ASSERT(inherits(vm, info()));
 50 }
 51 
 52 void RuntimeObject::destroy(JSCell* cell)
 53 {
 54     static_cast&lt;RuntimeObject*&gt;(cell)-&gt;RuntimeObject::~RuntimeObject();
 55 }
 56 
 57 void RuntimeObject::invalidate()
 58 {
 59     ASSERT(m_instance);
 60     if (m_instance)
 61         m_instance-&gt;willInvalidateRuntimeObject();
 62     m_instance = nullptr;
 63 }
 64 
<span class="line-modified"> 65 EncodedJSValue RuntimeObject::fallbackObjectGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName propertyName)</span>
 66 {
<span class="line-modified"> 67     VM&amp; vm = exec-&gt;vm();</span>
 68     auto scope = DECLARE_THROW_SCOPE(vm);
 69 
 70     RuntimeObject* thisObj = jsCast&lt;RuntimeObject*&gt;(JSValue::decode(thisValue));
 71     RefPtr&lt;Instance&gt; instance = thisObj-&gt;m_instance;
 72 
 73     if (!instance)
<span class="line-modified"> 74         return JSValue::encode(throwInvalidAccessError(exec, scope));</span>
 75 
 76     instance-&gt;begin();
 77 
 78     Class *aClass = instance-&gt;getClass();
<span class="line-modified"> 79     JSValue result = aClass-&gt;fallbackObject(exec, instance.get(), propertyName);</span>
 80 
 81     instance-&gt;end();
 82 
 83     return JSValue::encode(result);
 84 }
 85 
<span class="line-modified"> 86 EncodedJSValue RuntimeObject::fieldGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName propertyName)</span>
 87 {
<span class="line-modified"> 88     VM&amp; vm = exec-&gt;vm();</span>
 89     auto scope = DECLARE_THROW_SCOPE(vm);
 90 
 91     RuntimeObject* thisObj = jsCast&lt;RuntimeObject*&gt;(JSValue::decode(thisValue));
 92     RefPtr&lt;Instance&gt; instance = thisObj-&gt;m_instance;
 93 
 94     if (!instance)
<span class="line-modified"> 95         return JSValue::encode(throwInvalidAccessError(exec, scope));</span>
 96 
 97     instance-&gt;begin();
 98 
 99     Class *aClass = instance-&gt;getClass();
100     Field* aField = aClass-&gt;fieldNamed(propertyName, instance.get());
<span class="line-modified">101     JSValue result = aField-&gt;valueFromInstance(exec, instance.get());</span>
102 
103     instance-&gt;end();
104 
105     return JSValue::encode(result);
106 }
107 
<span class="line-modified">108 EncodedJSValue RuntimeObject::methodGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName propertyName)</span>
109 {
<span class="line-modified">110     VM&amp; vm = exec-&gt;vm();</span>
111     auto scope = DECLARE_THROW_SCOPE(vm);
112 
113     RuntimeObject* thisObj = jsCast&lt;RuntimeObject*&gt;(JSValue::decode(thisValue));
114     RefPtr&lt;Instance&gt; instance = thisObj-&gt;m_instance;
115 
116     if (!instance)
<span class="line-modified">117         return JSValue::encode(throwInvalidAccessError(exec, scope));</span>
118 
119     instance-&gt;begin();
120 
<span class="line-modified">121     JSValue method = instance-&gt;getMethod(exec, propertyName);</span>
122 
123     instance-&gt;end();
124 
125     return JSValue::encode(method);
126 }
127 
<span class="line-modified">128 bool RuntimeObject::getOwnPropertySlot(JSObject* object, ExecState *exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
129 {
<span class="line-modified">130     VM&amp; vm = exec-&gt;vm();</span>
131     auto scope = DECLARE_THROW_SCOPE(vm);
132 
133     RuntimeObject* thisObject = jsCast&lt;RuntimeObject*&gt;(object);
134     if (!thisObject-&gt;m_instance) {
<span class="line-modified">135         throwInvalidAccessError(exec, scope);</span>
136         return false;
137     }
138 
139     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
140 
141     instance-&gt;begin();
142 
143     Class *aClass = instance-&gt;getClass();
144 
145     if (aClass) {
146         // See if the instance has a field with the specified name.
147         Field *aField = aClass-&gt;fieldNamed(propertyName, instance.get());
148         if (aField) {
149             slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontDelete), thisObject-&gt;fieldGetter);
150             instance-&gt;end();
151             return true;
152         } else {
153             // Now check if a method with specified name exists, if so return a function object for
154             // that method.
155             if (aClass-&gt;methodNamed(propertyName, instance.get())) {
156                 slot.setCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, thisObject-&gt;methodGetter);
157 
158                 instance-&gt;end();
159                 return true;
160             }
161         }
162 
163         // Try a fallback object.
<span class="line-modified">164         if (!aClass-&gt;fallbackObject(exec, instance.get(), propertyName).isUndefined()) {</span>
165             slot.setCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;fallbackObjectGetter);
166             instance-&gt;end();
167             return true;
168         }
169     }
170 
171     instance-&gt;end();
172 
<span class="line-modified">173     return instance-&gt;getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
174 }
175 
<span class="line-modified">176 bool RuntimeObject::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
177 {
<span class="line-modified">178     VM&amp; vm = exec-&gt;vm();</span>
179     auto scope = DECLARE_THROW_SCOPE(vm);
180 
181     RuntimeObject* thisObject = jsCast&lt;RuntimeObject*&gt;(cell);
182     if (!thisObject-&gt;m_instance) {
<span class="line-modified">183         throwInvalidAccessError(exec, scope);</span>
184         return false;
185     }
186 
187     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
188     instance-&gt;begin();
189 
190     // Set the value of the property.
191     bool result = false;
192     Field *aField = instance-&gt;getClass()-&gt;fieldNamed(propertyName, instance.get());
193     if (aField)
<span class="line-modified">194         result = aField-&gt;setValueToInstance(exec, instance.get(), value);</span>
<span class="line-modified">195     else if (!instance-&gt;setValueOfUndefinedField(exec, propertyName, value))</span>
<span class="line-modified">196         result = instance-&gt;put(thisObject, exec, propertyName, value, slot);</span>
197 
198     instance-&gt;end();
199     return result;
200 }
201 
<span class="line-modified">202 bool RuntimeObject::deleteProperty(JSCell*, ExecState*, PropertyName)</span>
203 {
204     // Can never remove a property of a RuntimeObject.
205     return false;
206 }
207 
<span class="line-modified">208 JSValue RuntimeObject::defaultValue(const JSObject* object, ExecState* exec, PreferredPrimitiveType hint)</span>
209 {
<span class="line-modified">210     VM&amp; vm = exec-&gt;vm();</span>
211     auto scope = DECLARE_THROW_SCOPE(vm);
212 
213     const RuntimeObject* thisObject = jsCast&lt;const RuntimeObject*&gt;(object);
214     if (!thisObject-&gt;m_instance)
<span class="line-modified">215         return throwInvalidAccessError(exec, scope);</span>
216 
217     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
218 
219     instance-&gt;begin();
<span class="line-modified">220     JSValue result = instance-&gt;defaultValue(exec, hint);</span>
221     instance-&gt;end();
222     return result;
223 }
224 
<span class="line-modified">225 static EncodedJSValue JSC_HOST_CALL callRuntimeObject(ExecState* exec)</span>
226 {
<span class="line-modified">227     ASSERT(exec-&gt;jsCallee()-&gt;inherits&lt;RuntimeObject&gt;(exec-&gt;vm()));</span>
<span class="line-modified">228     RefPtr&lt;Instance&gt; instance(static_cast&lt;RuntimeObject*&gt;(exec-&gt;jsCallee())-&gt;getInternalInstance());</span>
229     instance-&gt;begin();
<span class="line-modified">230     JSValue result = instance-&gt;invokeDefaultMethod(exec);</span>
231     instance-&gt;end();
232     return JSValue::encode(result);
233 }
234 
235 CallType RuntimeObject::getCallData(JSCell* cell, CallData&amp; callData)
236 {
237     RuntimeObject* thisObject = jsCast&lt;RuntimeObject*&gt;(cell);
238     if (!thisObject-&gt;m_instance)
239         return CallType::None;
240 
241     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
242     if (!instance-&gt;supportsInvokeDefaultMethod())
243         return CallType::None;
244 
245     callData.native.function = callRuntimeObject;
246     return CallType::Host;
247 }
248 
<span class="line-modified">249 static EncodedJSValue JSC_HOST_CALL callRuntimeConstructor(ExecState* exec)</span>
250 {
<span class="line-modified">251     JSObject* constructor = exec-&gt;jsCallee();</span>
<span class="line-modified">252     ASSERT(constructor-&gt;inherits&lt;RuntimeObject&gt;(exec-&gt;vm()));</span>
<span class="line-modified">253     RefPtr&lt;Instance&gt; instance(static_cast&lt;RuntimeObject*&gt;(exec-&gt;jsCallee())-&gt;getInternalInstance());</span>
254     instance-&gt;begin();
<span class="line-modified">255     ArgList args(exec);</span>
<span class="line-modified">256     JSValue result = instance-&gt;invokeConstruct(exec, args);</span>
257     instance-&gt;end();
258 
259     ASSERT(result);
260     return JSValue::encode(result.isObject() ? jsCast&lt;JSObject*&gt;(result.asCell()) : constructor);
261 }
262 
263 ConstructType RuntimeObject::getConstructData(JSCell* cell, ConstructData&amp; constructData)
264 {
265     RuntimeObject* thisObject = jsCast&lt;RuntimeObject*&gt;(cell);
266     if (!thisObject-&gt;m_instance)
267         return ConstructType::None;
268 
269     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
270     if (!instance-&gt;supportsConstruct())
271         return ConstructType::None;
272 
273     constructData.native.function = callRuntimeConstructor;
274     return ConstructType::Host;
275 }
276 
<span class="line-modified">277 void RuntimeObject::getOwnPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNames, EnumerationMode)</span>
278 {
<span class="line-modified">279     VM&amp; vm = exec-&gt;vm();</span>
280     auto scope = DECLARE_THROW_SCOPE(vm);
281 
282     RuntimeObject* thisObject = jsCast&lt;RuntimeObject*&gt;(object);
283     if (!thisObject-&gt;m_instance) {
<span class="line-modified">284         throwInvalidAccessError(exec, scope);</span>
285         return;
286     }
287 
288     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
289 
290     instance-&gt;begin();
<span class="line-modified">291     instance-&gt;getPropertyNames(exec, propertyNames);</span>
292     instance-&gt;end();
293 }
294 
<span class="line-modified">295 Exception* RuntimeObject::throwInvalidAccessError(ExecState* exec, ThrowScope&amp; scope)</span>
296 {
<span class="line-modified">297     return throwException(exec, scope, createReferenceError(exec, &quot;Trying to access object from destroyed plug-in.&quot;));</span>





298 }
299 
300 }
301 }
</pre>
</td>
<td>
<hr />
<pre>
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;runtime_object.h&quot;
 28 
 29 #include &quot;JSDOMBinding.h&quot;
<span class="line-added"> 30 #include &quot;WebCoreJSClientData.h&quot;</span>
 31 #include &quot;runtime_method.h&quot;
 32 #include &lt;JavaScriptCore/Error.h&gt;
 33 
 34 using namespace WebCore;
 35 
 36 namespace JSC {
 37 namespace Bindings {
 38 
 39 WEBCORE_EXPORT const ClassInfo RuntimeObject::s_info = { &quot;RuntimeObject&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(RuntimeObject) };
 40 
 41 RuntimeObject::RuntimeObject(VM&amp; vm, Structure* structure, RefPtr&lt;Instance&gt;&amp;&amp; instance)
<span class="line-modified"> 42     : Base(vm, structure)</span>
 43     , m_instance(WTFMove(instance))
 44 {
 45 }
 46 
 47 void RuntimeObject::finishCreation(VM&amp; vm)
 48 {
 49     Base::finishCreation(vm);
 50     ASSERT(inherits(vm, info()));
 51 }
 52 
 53 void RuntimeObject::destroy(JSCell* cell)
 54 {
 55     static_cast&lt;RuntimeObject*&gt;(cell)-&gt;RuntimeObject::~RuntimeObject();
 56 }
 57 
 58 void RuntimeObject::invalidate()
 59 {
 60     ASSERT(m_instance);
 61     if (m_instance)
 62         m_instance-&gt;willInvalidateRuntimeObject();
 63     m_instance = nullptr;
 64 }
 65 
<span class="line-modified"> 66 EncodedJSValue RuntimeObject::fallbackObjectGetter(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName propertyName)</span>
 67 {
<span class="line-modified"> 68     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
 69     auto scope = DECLARE_THROW_SCOPE(vm);
 70 
 71     RuntimeObject* thisObj = jsCast&lt;RuntimeObject*&gt;(JSValue::decode(thisValue));
 72     RefPtr&lt;Instance&gt; instance = thisObj-&gt;m_instance;
 73 
 74     if (!instance)
<span class="line-modified"> 75         return JSValue::encode(throwInvalidAccessError(lexicalGlobalObject, scope));</span>
 76 
 77     instance-&gt;begin();
 78 
 79     Class *aClass = instance-&gt;getClass();
<span class="line-modified"> 80     JSValue result = aClass-&gt;fallbackObject(lexicalGlobalObject, instance.get(), propertyName);</span>
 81 
 82     instance-&gt;end();
 83 
 84     return JSValue::encode(result);
 85 }
 86 
<span class="line-modified"> 87 EncodedJSValue RuntimeObject::fieldGetter(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName propertyName)</span>
 88 {
<span class="line-modified"> 89     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
 90     auto scope = DECLARE_THROW_SCOPE(vm);
 91 
 92     RuntimeObject* thisObj = jsCast&lt;RuntimeObject*&gt;(JSValue::decode(thisValue));
 93     RefPtr&lt;Instance&gt; instance = thisObj-&gt;m_instance;
 94 
 95     if (!instance)
<span class="line-modified"> 96         return JSValue::encode(throwInvalidAccessError(lexicalGlobalObject, scope));</span>
 97 
 98     instance-&gt;begin();
 99 
100     Class *aClass = instance-&gt;getClass();
101     Field* aField = aClass-&gt;fieldNamed(propertyName, instance.get());
<span class="line-modified">102     JSValue result = aField-&gt;valueFromInstance(lexicalGlobalObject, instance.get());</span>
103 
104     instance-&gt;end();
105 
106     return JSValue::encode(result);
107 }
108 
<span class="line-modified">109 EncodedJSValue RuntimeObject::methodGetter(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName propertyName)</span>
110 {
<span class="line-modified">111     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
112     auto scope = DECLARE_THROW_SCOPE(vm);
113 
114     RuntimeObject* thisObj = jsCast&lt;RuntimeObject*&gt;(JSValue::decode(thisValue));
115     RefPtr&lt;Instance&gt; instance = thisObj-&gt;m_instance;
116 
117     if (!instance)
<span class="line-modified">118         return JSValue::encode(throwInvalidAccessError(lexicalGlobalObject, scope));</span>
119 
120     instance-&gt;begin();
121 
<span class="line-modified">122     JSValue method = instance-&gt;getMethod(lexicalGlobalObject, propertyName);</span>
123 
124     instance-&gt;end();
125 
126     return JSValue::encode(method);
127 }
128 
<span class="line-modified">129 bool RuntimeObject::getOwnPropertySlot(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
130 {
<span class="line-modified">131     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
132     auto scope = DECLARE_THROW_SCOPE(vm);
133 
134     RuntimeObject* thisObject = jsCast&lt;RuntimeObject*&gt;(object);
135     if (!thisObject-&gt;m_instance) {
<span class="line-modified">136         throwInvalidAccessError(lexicalGlobalObject, scope);</span>
137         return false;
138     }
139 
140     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
141 
142     instance-&gt;begin();
143 
144     Class *aClass = instance-&gt;getClass();
145 
146     if (aClass) {
147         // See if the instance has a field with the specified name.
148         Field *aField = aClass-&gt;fieldNamed(propertyName, instance.get());
149         if (aField) {
150             slot.setCustom(thisObject, static_cast&lt;unsigned&gt;(JSC::PropertyAttribute::DontDelete), thisObject-&gt;fieldGetter);
151             instance-&gt;end();
152             return true;
153         } else {
154             // Now check if a method with specified name exists, if so return a function object for
155             // that method.
156             if (aClass-&gt;methodNamed(propertyName, instance.get())) {
157                 slot.setCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, thisObject-&gt;methodGetter);
158 
159                 instance-&gt;end();
160                 return true;
161             }
162         }
163 
164         // Try a fallback object.
<span class="line-modified">165         if (!aClass-&gt;fallbackObject(lexicalGlobalObject, instance.get(), propertyName).isUndefined()) {</span>
166             slot.setCustom(thisObject, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly | PropertyAttribute::DontEnum, thisObject-&gt;fallbackObjectGetter);
167             instance-&gt;end();
168             return true;
169         }
170     }
171 
172     instance-&gt;end();
173 
<span class="line-modified">174     return instance-&gt;getOwnPropertySlot(thisObject, lexicalGlobalObject, propertyName, slot);</span>
175 }
176 
<span class="line-modified">177 bool RuntimeObject::put(JSCell* cell, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
178 {
<span class="line-modified">179     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
180     auto scope = DECLARE_THROW_SCOPE(vm);
181 
182     RuntimeObject* thisObject = jsCast&lt;RuntimeObject*&gt;(cell);
183     if (!thisObject-&gt;m_instance) {
<span class="line-modified">184         throwInvalidAccessError(lexicalGlobalObject, scope);</span>
185         return false;
186     }
187 
188     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
189     instance-&gt;begin();
190 
191     // Set the value of the property.
192     bool result = false;
193     Field *aField = instance-&gt;getClass()-&gt;fieldNamed(propertyName, instance.get());
194     if (aField)
<span class="line-modified">195         result = aField-&gt;setValueToInstance(lexicalGlobalObject, instance.get(), value);</span>
<span class="line-modified">196     else if (!instance-&gt;setValueOfUndefinedField(lexicalGlobalObject, propertyName, value))</span>
<span class="line-modified">197         result = instance-&gt;put(thisObject, lexicalGlobalObject, propertyName, value, slot);</span>
198 
199     instance-&gt;end();
200     return result;
201 }
202 
<span class="line-modified">203 bool RuntimeObject::deleteProperty(JSCell*, JSGlobalObject*, PropertyName)</span>
204 {
205     // Can never remove a property of a RuntimeObject.
206     return false;
207 }
208 
<span class="line-modified">209 JSValue RuntimeObject::defaultValue(const JSObject* object, JSGlobalObject* lexicalGlobalObject, PreferredPrimitiveType hint)</span>
210 {
<span class="line-modified">211     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
212     auto scope = DECLARE_THROW_SCOPE(vm);
213 
214     const RuntimeObject* thisObject = jsCast&lt;const RuntimeObject*&gt;(object);
215     if (!thisObject-&gt;m_instance)
<span class="line-modified">216         return throwInvalidAccessError(lexicalGlobalObject, scope);</span>
217 
218     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
219 
220     instance-&gt;begin();
<span class="line-modified">221     JSValue result = instance-&gt;defaultValue(lexicalGlobalObject, hint);</span>
222     instance-&gt;end();
223     return result;
224 }
225 
<span class="line-modified">226 static EncodedJSValue JSC_HOST_CALL callRuntimeObject(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
227 {
<span class="line-modified">228     ASSERT_UNUSED(globalObject, callFrame-&gt;jsCallee()-&gt;inherits&lt;RuntimeObject&gt;(globalObject-&gt;vm()));</span>
<span class="line-modified">229     RefPtr&lt;Instance&gt; instance(static_cast&lt;RuntimeObject*&gt;(callFrame-&gt;jsCallee())-&gt;getInternalInstance());</span>
230     instance-&gt;begin();
<span class="line-modified">231     JSValue result = instance-&gt;invokeDefaultMethod(globalObject, callFrame);</span>
232     instance-&gt;end();
233     return JSValue::encode(result);
234 }
235 
236 CallType RuntimeObject::getCallData(JSCell* cell, CallData&amp; callData)
237 {
238     RuntimeObject* thisObject = jsCast&lt;RuntimeObject*&gt;(cell);
239     if (!thisObject-&gt;m_instance)
240         return CallType::None;
241 
242     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
243     if (!instance-&gt;supportsInvokeDefaultMethod())
244         return CallType::None;
245 
246     callData.native.function = callRuntimeObject;
247     return CallType::Host;
248 }
249 
<span class="line-modified">250 static EncodedJSValue JSC_HOST_CALL callRuntimeConstructor(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
251 {
<span class="line-modified">252     JSObject* constructor = callFrame-&gt;jsCallee();</span>
<span class="line-modified">253     ASSERT_UNUSED(globalObject, constructor-&gt;inherits&lt;RuntimeObject&gt;(globalObject-&gt;vm()));</span>
<span class="line-modified">254     RefPtr&lt;Instance&gt; instance(static_cast&lt;RuntimeObject*&gt;(callFrame-&gt;jsCallee())-&gt;getInternalInstance());</span>
255     instance-&gt;begin();
<span class="line-modified">256     ArgList args(callFrame);</span>
<span class="line-modified">257     JSValue result = instance-&gt;invokeConstruct(globalObject, callFrame, args);</span>
258     instance-&gt;end();
259 
260     ASSERT(result);
261     return JSValue::encode(result.isObject() ? jsCast&lt;JSObject*&gt;(result.asCell()) : constructor);
262 }
263 
264 ConstructType RuntimeObject::getConstructData(JSCell* cell, ConstructData&amp; constructData)
265 {
266     RuntimeObject* thisObject = jsCast&lt;RuntimeObject*&gt;(cell);
267     if (!thisObject-&gt;m_instance)
268         return ConstructType::None;
269 
270     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
271     if (!instance-&gt;supportsConstruct())
272         return ConstructType::None;
273 
274     constructData.native.function = callRuntimeConstructor;
275     return ConstructType::Host;
276 }
277 
<span class="line-modified">278 void RuntimeObject::getOwnPropertyNames(JSObject* object, JSGlobalObject* lexicalGlobalObject, PropertyNameArray&amp; propertyNames, EnumerationMode)</span>
279 {
<span class="line-modified">280     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
281     auto scope = DECLARE_THROW_SCOPE(vm);
282 
283     RuntimeObject* thisObject = jsCast&lt;RuntimeObject*&gt;(object);
284     if (!thisObject-&gt;m_instance) {
<span class="line-modified">285         throwInvalidAccessError(lexicalGlobalObject, scope);</span>
286         return;
287     }
288 
289     RefPtr&lt;Instance&gt; instance = thisObject-&gt;m_instance;
290 
291     instance-&gt;begin();
<span class="line-modified">292     instance-&gt;getPropertyNames(lexicalGlobalObject, propertyNames);</span>
293     instance-&gt;end();
294 }
295 
<span class="line-modified">296 Exception* RuntimeObject::throwInvalidAccessError(JSGlobalObject* lexicalGlobalObject, ThrowScope&amp; scope)</span>
297 {
<span class="line-modified">298     return throwException(lexicalGlobalObject, scope, createReferenceError(lexicalGlobalObject, &quot;Trying to access object from destroyed plug-in.&quot;));</span>
<span class="line-added">299 }</span>
<span class="line-added">300 </span>
<span class="line-added">301 JSC::IsoSubspace* RuntimeObject::subspaceForImpl(JSC::VM&amp; vm)</span>
<span class="line-added">302 {</span>
<span class="line-added">303     return &amp;static_cast&lt;JSVMClientData*&gt;(vm.clientData)-&gt;runtimeObjectSpace();</span>
304 }
305 
306 }
307 }
</pre>
</td>
</tr>
</table>
<center><a href="runtime_method.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="runtime_object.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
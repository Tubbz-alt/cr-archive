<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CallLinkInfo.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BytecodeUseDef.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallLinkInfo.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CallLinkInfo.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
149 }
150 
151 FunctionCodeBlock* CallLinkInfo::codeBlock()
152 {
153     RELEASE_ASSERT(isDirect());
154     return jsCast&lt;FunctionCodeBlock*&gt;(m_calleeOrCodeBlock.get());
155 }
156 
157 void CallLinkInfo::setLastSeenCallee(VM&amp; vm, const JSCell* owner, JSObject* callee)
158 {
159     RELEASE_ASSERT(!isDirect());
160     m_lastSeenCalleeOrExecutable.set(vm, owner, callee);
161 }
162 
163 void CallLinkInfo::clearLastSeenCallee()
164 {
165     RELEASE_ASSERT(!isDirect());
166     m_lastSeenCalleeOrExecutable.clear();
167 }
168 
<span class="line-modified">169 JSObject* CallLinkInfo::lastSeenCallee()</span>
170 {
171     RELEASE_ASSERT(!isDirect());
172     return jsCast&lt;JSObject*&gt;(m_lastSeenCalleeOrExecutable.get());
173 }
174 
<span class="line-modified">175 bool CallLinkInfo::haveLastSeenCallee()</span>
176 {
177     RELEASE_ASSERT(!isDirect());
178     return !!m_lastSeenCalleeOrExecutable;
179 }
180 
181 void CallLinkInfo::setExecutableDuringCompilation(ExecutableBase* executable)
182 {
183     RELEASE_ASSERT(isDirect());
184     m_lastSeenCalleeOrExecutable.setWithoutWriteBarrier(executable);
185 }
186 
187 ExecutableBase* CallLinkInfo::executable()
188 {
189     RELEASE_ASSERT(isDirect());
190     return jsCast&lt;ExecutableBase*&gt;(m_lastSeenCalleeOrExecutable.get());
191 }
192 
<span class="line-modified">193 void CallLinkInfo::setMaxNumArguments(unsigned value)</span>
194 {
195     RELEASE_ASSERT(isDirect());
196     RELEASE_ASSERT(value);
<span class="line-modified">197     m_maxNumArguments = value;</span>
198 }
199 
200 void CallLinkInfo::visitWeak(VM&amp; vm)
201 {
202     auto handleSpecificCallee = [&amp;] (JSFunction* callee) {
203         if (vm.heap.isMarked(callee-&gt;executable()))
204             m_hasSeenClosure = true;
205         else
206             m_clearedByGC = true;
207     };
208 
209     if (isLinked()) {
210         if (stub()) {
211             if (!stub()-&gt;visitWeak(vm)) {
<span class="line-modified">212                 if (Options::verboseOSR()) {</span>
213                     dataLog(
214                         &quot;At &quot;, m_codeOrigin, &quot;, &quot;, RawPointer(this), &quot;: clearing call stub to &quot;,
215                         listDump(stub()-&gt;variants()), &quot;, stub routine &quot;, RawPointer(stub()),
216                         &quot;.\n&quot;);
217                 }
218                 unlink(vm);
219                 m_clearedByGC = true;
220             }
221         } else if (!vm.heap.isMarked(m_calleeOrCodeBlock.get())) {
222             if (isDirect()) {
<span class="line-modified">223                 if (Options::verboseOSR()) {</span>
224                     dataLog(
225                         &quot;Clearing call to &quot;, RawPointer(codeBlock()), &quot; (&quot;,
226                         pointerDump(codeBlock()), &quot;).\n&quot;);
227                 }
228             } else {
229                 if (callee()-&gt;type() == JSFunctionType) {
<span class="line-modified">230                     if (Options::verboseOSR()) {</span>
231                         dataLog(
232                             &quot;Clearing call to &quot;,
233                             RawPointer(callee()), &quot; (&quot;,
234                             static_cast&lt;JSFunction*&gt;(callee())-&gt;executable()-&gt;hashFor(specializationKind()),
235                             &quot;).\n&quot;);
236                     }
237                     handleSpecificCallee(static_cast&lt;JSFunction*&gt;(callee()));
238                 } else {
<span class="line-modified">239                     if (Options::verboseOSR())</span>
240                         dataLog(&quot;Clearing call to &quot;, RawPointer(callee()), &quot;.\n&quot;);
241                     m_clearedByGC = true;
242                 }
243             }
244             unlink(vm);
245         } else if (isDirect() &amp;&amp; !vm.heap.isMarked(m_lastSeenCalleeOrExecutable.get())) {
<span class="line-modified">246             if (Options::verboseOSR()) {</span>
247                 dataLog(
248                     &quot;Clearing call to &quot;, RawPointer(executable()),
249                     &quot; because the executable is dead.\n&quot;);
250             }
251             unlink(vm);
252             // We should only get here once the owning CodeBlock is dying, since the executable must
253             // already be in the owner&#39;s weak references.
254             m_lastSeenCalleeOrExecutable.clear();
255         }
256     }
257     if (!isDirect() &amp;&amp; haveLastSeenCallee() &amp;&amp; !vm.heap.isMarked(lastSeenCallee())) {
258         if (lastSeenCallee()-&gt;type() == JSFunctionType)
259             handleSpecificCallee(jsCast&lt;JSFunction*&gt;(lastSeenCallee()));
260         else
261             m_clearedByGC = true;
262         clearLastSeenCallee();
263     }
264 }
265 
266 void CallLinkInfo::setFrameShuffleData(const CallFrameShuffleData&amp; shuffleData)
</pre>
</td>
<td>
<hr />
<pre>
149 }
150 
151 FunctionCodeBlock* CallLinkInfo::codeBlock()
152 {
153     RELEASE_ASSERT(isDirect());
154     return jsCast&lt;FunctionCodeBlock*&gt;(m_calleeOrCodeBlock.get());
155 }
156 
157 void CallLinkInfo::setLastSeenCallee(VM&amp; vm, const JSCell* owner, JSObject* callee)
158 {
159     RELEASE_ASSERT(!isDirect());
160     m_lastSeenCalleeOrExecutable.set(vm, owner, callee);
161 }
162 
163 void CallLinkInfo::clearLastSeenCallee()
164 {
165     RELEASE_ASSERT(!isDirect());
166     m_lastSeenCalleeOrExecutable.clear();
167 }
168 
<span class="line-modified">169 JSObject* CallLinkInfo::lastSeenCallee() const</span>
170 {
171     RELEASE_ASSERT(!isDirect());
172     return jsCast&lt;JSObject*&gt;(m_lastSeenCalleeOrExecutable.get());
173 }
174 
<span class="line-modified">175 bool CallLinkInfo::haveLastSeenCallee() const</span>
176 {
177     RELEASE_ASSERT(!isDirect());
178     return !!m_lastSeenCalleeOrExecutable;
179 }
180 
181 void CallLinkInfo::setExecutableDuringCompilation(ExecutableBase* executable)
182 {
183     RELEASE_ASSERT(isDirect());
184     m_lastSeenCalleeOrExecutable.setWithoutWriteBarrier(executable);
185 }
186 
187 ExecutableBase* CallLinkInfo::executable()
188 {
189     RELEASE_ASSERT(isDirect());
190     return jsCast&lt;ExecutableBase*&gt;(m_lastSeenCalleeOrExecutable.get());
191 }
192 
<span class="line-modified">193 void CallLinkInfo::setMaxArgumentCountIncludingThis(unsigned value)</span>
194 {
195     RELEASE_ASSERT(isDirect());
196     RELEASE_ASSERT(value);
<span class="line-modified">197     m_maxArgumentCountIncludingThis = value;</span>
198 }
199 
200 void CallLinkInfo::visitWeak(VM&amp; vm)
201 {
202     auto handleSpecificCallee = [&amp;] (JSFunction* callee) {
203         if (vm.heap.isMarked(callee-&gt;executable()))
204             m_hasSeenClosure = true;
205         else
206             m_clearedByGC = true;
207     };
208 
209     if (isLinked()) {
210         if (stub()) {
211             if (!stub()-&gt;visitWeak(vm)) {
<span class="line-modified">212                 if (UNLIKELY(Options::verboseOSR())) {</span>
213                     dataLog(
214                         &quot;At &quot;, m_codeOrigin, &quot;, &quot;, RawPointer(this), &quot;: clearing call stub to &quot;,
215                         listDump(stub()-&gt;variants()), &quot;, stub routine &quot;, RawPointer(stub()),
216                         &quot;.\n&quot;);
217                 }
218                 unlink(vm);
219                 m_clearedByGC = true;
220             }
221         } else if (!vm.heap.isMarked(m_calleeOrCodeBlock.get())) {
222             if (isDirect()) {
<span class="line-modified">223                 if (UNLIKELY(Options::verboseOSR())) {</span>
224                     dataLog(
225                         &quot;Clearing call to &quot;, RawPointer(codeBlock()), &quot; (&quot;,
226                         pointerDump(codeBlock()), &quot;).\n&quot;);
227                 }
228             } else {
229                 if (callee()-&gt;type() == JSFunctionType) {
<span class="line-modified">230                     if (UNLIKELY(Options::verboseOSR())) {</span>
231                         dataLog(
232                             &quot;Clearing call to &quot;,
233                             RawPointer(callee()), &quot; (&quot;,
234                             static_cast&lt;JSFunction*&gt;(callee())-&gt;executable()-&gt;hashFor(specializationKind()),
235                             &quot;).\n&quot;);
236                     }
237                     handleSpecificCallee(static_cast&lt;JSFunction*&gt;(callee()));
238                 } else {
<span class="line-modified">239                     if (UNLIKELY(Options::verboseOSR()))</span>
240                         dataLog(&quot;Clearing call to &quot;, RawPointer(callee()), &quot;.\n&quot;);
241                     m_clearedByGC = true;
242                 }
243             }
244             unlink(vm);
245         } else if (isDirect() &amp;&amp; !vm.heap.isMarked(m_lastSeenCalleeOrExecutable.get())) {
<span class="line-modified">246             if (UNLIKELY(Options::verboseOSR())) {</span>
247                 dataLog(
248                     &quot;Clearing call to &quot;, RawPointer(executable()),
249                     &quot; because the executable is dead.\n&quot;);
250             }
251             unlink(vm);
252             // We should only get here once the owning CodeBlock is dying, since the executable must
253             // already be in the owner&#39;s weak references.
254             m_lastSeenCalleeOrExecutable.clear();
255         }
256     }
257     if (!isDirect() &amp;&amp; haveLastSeenCallee() &amp;&amp; !vm.heap.isMarked(lastSeenCallee())) {
258         if (lastSeenCallee()-&gt;type() == JSFunctionType)
259             handleSpecificCallee(jsCast&lt;JSFunction*&gt;(lastSeenCallee()));
260         else
261             m_clearedByGC = true;
262         clearLastSeenCallee();
263     }
264 }
265 
266 void CallLinkInfo::setFrameShuffleData(const CallFrameShuffleData&amp; shuffleData)
</pre>
</td>
</tr>
</table>
<center><a href="BytecodeUseDef.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CallLinkInfo.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGThunks.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGStructureAbstractValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGThunks.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGThunks.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGThunks.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;CCallHelpers.h&quot;
 32 #include &quot;DFGJITCode.h&quot;
 33 #include &quot;DFGOSRExit.h&quot;
 34 #include &quot;FPRInfo.h&quot;
 35 #include &quot;GPRInfo.h&quot;
 36 #include &quot;LinkBuffer.h&quot;
 37 #include &quot;MacroAssembler.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &quot;DFGOSRExitCompilerCommon.h&quot;
 40 
 41 namespace JSC { namespace DFG {
 42 
<span class="line-removed"> 43 MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; osrExitThunkGenerator(VM&amp; vm)</span>
<span class="line-removed"> 44 {</span>
<span class="line-removed"> 45     MacroAssembler jit;</span>
<span class="line-removed"> 46     jit.probe(OSRExit::executeOSRExit, &amp;vm);</span>
<span class="line-removed"> 47     LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID);</span>
<span class="line-removed"> 48     return FINALIZE_CODE(patchBuffer, JITThunkPtrTag, &quot;DFG OSR exit thunk&quot;);</span>
<span class="line-removed"> 49 }</span>
<span class="line-removed"> 50 </span>
 51 MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; osrExitGenerationThunkGenerator(VM&amp; vm)
 52 {
<span class="line-modified"> 53     MacroAssembler jit;</span>
 54 
 55     // This needs to happen before we use the scratch buffer because this function also uses the scratch buffer.
 56     adjustFrameAndStackInOSRExitCompilerThunk&lt;DFG::JITCode&gt;(jit, vm, JITType::DFGJIT);
 57 
 58     size_t scratchSize = sizeof(EncodedJSValue) * (GPRInfo::numberOfRegisters + FPRInfo::numberOfRegisters);
 59     ScratchBuffer* scratchBuffer = vm.scratchBufferForSize(scratchSize);
 60     EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
 61 
 62     for (unsigned i = 0; i &lt; GPRInfo::numberOfRegisters; ++i) {
 63 #if USE(JSVALUE64)
 64         jit.store64(GPRInfo::toRegister(i), buffer + i);
 65 #else
 66         jit.store32(GPRInfo::toRegister(i), buffer + i);
 67 #endif
 68     }
 69     for (unsigned i = 0; i &lt; FPRInfo::numberOfRegisters; ++i) {
 70         jit.move(MacroAssembler::TrustedImmPtr(buffer + GPRInfo::numberOfRegisters + i), GPRInfo::regT0);
 71         jit.storeDouble(FPRInfo::toRegister(i), MacroAssembler::Address(GPRInfo::regT0));
 72     }
 73 
 74     // Tell GC mark phase how much of the scratch buffer is active during call.
 75     jit.move(MacroAssembler::TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), GPRInfo::regT0);
 76     jit.storePtr(MacroAssembler::TrustedImmPtr(scratchSize), MacroAssembler::Address(GPRInfo::regT0));
 77 
 78     // Set up one argument.
<span class="line-removed"> 79 #if CPU(X86)</span>
<span class="line-removed"> 80     jit.poke(GPRInfo::callFrameRegister, 0);</span>
<span class="line-removed"> 81 #else</span>
 82     jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
<span class="line-modified"> 83 #endif</span>
 84 
 85     MacroAssembler::Call functionCall = jit.call(OperationPtrTag);
 86 
 87     jit.move(MacroAssembler::TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), GPRInfo::regT0);
 88     jit.storePtr(MacroAssembler::TrustedImmPtr(nullptr), MacroAssembler::Address(GPRInfo::regT0));
 89 
 90     for (unsigned i = 0; i &lt; FPRInfo::numberOfRegisters; ++i) {
 91         jit.move(MacroAssembler::TrustedImmPtr(buffer + GPRInfo::numberOfRegisters + i), GPRInfo::regT0);
 92         jit.loadDouble(MacroAssembler::Address(GPRInfo::regT0), FPRInfo::toRegister(i));
 93     }
 94     for (unsigned i = 0; i &lt; GPRInfo::numberOfRegisters; ++i) {
 95 #if USE(JSVALUE64)
 96         jit.load64(buffer + i, GPRInfo::toRegister(i));
 97 #else
 98         jit.load32(buffer + i, GPRInfo::toRegister(i));
 99 #endif
100     }
101 
102     jit.farJump(MacroAssembler::AbsoluteAddress(&amp;vm.osrExitJumpDestination), OSRExitPtrTag);
103 
104     LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID);
105 
<span class="line-modified">106     patchBuffer.link(functionCall, FunctionPtr&lt;OperationPtrTag&gt;(OSRExit::compileOSRExit));</span>
107 
108     return FINALIZE_CODE(patchBuffer, JITThunkPtrTag, &quot;DFG OSR exit generation thunk&quot;);
109 }
110 
111 MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; osrEntryThunkGenerator(VM&amp; vm)
112 {
113     AssemblyHelpers jit(nullptr);
114 
115     // We get passed the address of a scratch buffer in GPRInfo::returnValueGPR2.
116     // The first 8-byte slot of the buffer is the frame size. The second 8-byte slot
117     // is the pointer to where we are supposed to jump. The remaining bytes are
118     // the new call frame header followed by the locals.
119 
120     ptrdiff_t offsetOfFrameSize = 0; // This is the DFG frame count.
121     ptrdiff_t offsetOfTargetPC = offsetOfFrameSize + sizeof(EncodedJSValue);
122     ptrdiff_t offsetOfPayload = offsetOfTargetPC + sizeof(EncodedJSValue);
123     ptrdiff_t offsetOfLocals = offsetOfPayload + sizeof(Register) * CallFrame::headerSizeInRegisters;
124 
125     jit.move(GPRInfo::returnValueGPR2, GPRInfo::regT0);
126     jit.loadPtr(MacroAssembler::Address(GPRInfo::regT0, offsetOfFrameSize), GPRInfo::regT1); // Load the frame size.
</pre>
</td>
<td>
<hr />
<pre>
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;DFGThunks.h&quot;
 28 
 29 #if ENABLE(DFG_JIT)
 30 
 31 #include &quot;CCallHelpers.h&quot;
 32 #include &quot;DFGJITCode.h&quot;
 33 #include &quot;DFGOSRExit.h&quot;
 34 #include &quot;FPRInfo.h&quot;
 35 #include &quot;GPRInfo.h&quot;
 36 #include &quot;LinkBuffer.h&quot;
 37 #include &quot;MacroAssembler.h&quot;
 38 #include &quot;JSCInlines.h&quot;
 39 #include &quot;DFGOSRExitCompilerCommon.h&quot;
 40 
 41 namespace JSC { namespace DFG {
 42 








 43 MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; osrExitGenerationThunkGenerator(VM&amp; vm)
 44 {
<span class="line-modified"> 45     CCallHelpers jit(nullptr);</span>
 46 
 47     // This needs to happen before we use the scratch buffer because this function also uses the scratch buffer.
 48     adjustFrameAndStackInOSRExitCompilerThunk&lt;DFG::JITCode&gt;(jit, vm, JITType::DFGJIT);
 49 
 50     size_t scratchSize = sizeof(EncodedJSValue) * (GPRInfo::numberOfRegisters + FPRInfo::numberOfRegisters);
 51     ScratchBuffer* scratchBuffer = vm.scratchBufferForSize(scratchSize);
 52     EncodedJSValue* buffer = static_cast&lt;EncodedJSValue*&gt;(scratchBuffer-&gt;dataBuffer());
 53 
 54     for (unsigned i = 0; i &lt; GPRInfo::numberOfRegisters; ++i) {
 55 #if USE(JSVALUE64)
 56         jit.store64(GPRInfo::toRegister(i), buffer + i);
 57 #else
 58         jit.store32(GPRInfo::toRegister(i), buffer + i);
 59 #endif
 60     }
 61     for (unsigned i = 0; i &lt; FPRInfo::numberOfRegisters; ++i) {
 62         jit.move(MacroAssembler::TrustedImmPtr(buffer + GPRInfo::numberOfRegisters + i), GPRInfo::regT0);
 63         jit.storeDouble(FPRInfo::toRegister(i), MacroAssembler::Address(GPRInfo::regT0));
 64     }
 65 
 66     // Tell GC mark phase how much of the scratch buffer is active during call.
 67     jit.move(MacroAssembler::TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), GPRInfo::regT0);
 68     jit.storePtr(MacroAssembler::TrustedImmPtr(scratchSize), MacroAssembler::Address(GPRInfo::regT0));
 69 
 70     // Set up one argument.



 71     jit.move(GPRInfo::callFrameRegister, GPRInfo::argumentGPR0);
<span class="line-modified"> 72     jit.prepareCallOperation(vm);</span>
 73 
 74     MacroAssembler::Call functionCall = jit.call(OperationPtrTag);
 75 
 76     jit.move(MacroAssembler::TrustedImmPtr(scratchBuffer-&gt;addressOfActiveLength()), GPRInfo::regT0);
 77     jit.storePtr(MacroAssembler::TrustedImmPtr(nullptr), MacroAssembler::Address(GPRInfo::regT0));
 78 
 79     for (unsigned i = 0; i &lt; FPRInfo::numberOfRegisters; ++i) {
 80         jit.move(MacroAssembler::TrustedImmPtr(buffer + GPRInfo::numberOfRegisters + i), GPRInfo::regT0);
 81         jit.loadDouble(MacroAssembler::Address(GPRInfo::regT0), FPRInfo::toRegister(i));
 82     }
 83     for (unsigned i = 0; i &lt; GPRInfo::numberOfRegisters; ++i) {
 84 #if USE(JSVALUE64)
 85         jit.load64(buffer + i, GPRInfo::toRegister(i));
 86 #else
 87         jit.load32(buffer + i, GPRInfo::toRegister(i));
 88 #endif
 89     }
 90 
 91     jit.farJump(MacroAssembler::AbsoluteAddress(&amp;vm.osrExitJumpDestination), OSRExitPtrTag);
 92 
 93     LinkBuffer patchBuffer(jit, GLOBAL_THUNK_ID);
 94 
<span class="line-modified"> 95     patchBuffer.link(functionCall, FunctionPtr&lt;OperationPtrTag&gt;(operationCompileOSRExit));</span>
 96 
 97     return FINALIZE_CODE(patchBuffer, JITThunkPtrTag, &quot;DFG OSR exit generation thunk&quot;);
 98 }
 99 
100 MacroAssemblerCodeRef&lt;JITThunkPtrTag&gt; osrEntryThunkGenerator(VM&amp; vm)
101 {
102     AssemblyHelpers jit(nullptr);
103 
104     // We get passed the address of a scratch buffer in GPRInfo::returnValueGPR2.
105     // The first 8-byte slot of the buffer is the frame size. The second 8-byte slot
106     // is the pointer to where we are supposed to jump. The remaining bytes are
107     // the new call frame header followed by the locals.
108 
109     ptrdiff_t offsetOfFrameSize = 0; // This is the DFG frame count.
110     ptrdiff_t offsetOfTargetPC = offsetOfFrameSize + sizeof(EncodedJSValue);
111     ptrdiff_t offsetOfPayload = offsetOfTargetPC + sizeof(EncodedJSValue);
112     ptrdiff_t offsetOfLocals = offsetOfPayload + sizeof(Register) * CallFrame::headerSizeInRegisters;
113 
114     jit.move(GPRInfo::returnValueGPR2, GPRInfo::regT0);
115     jit.loadPtr(MacroAssembler::Address(GPRInfo::regT0, offsetOfFrameSize), GPRInfo::regT1); // Load the frame size.
</pre>
</td>
</tr>
</table>
<center><a href="DFGStructureAbstractValue.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGThunks.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
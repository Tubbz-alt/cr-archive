<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PlatformTimeRanges.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PlatformMediaResourceLoader.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PlatformTimeRanges.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/PlatformTimeRanges.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;PlatformTimeRanges.h&quot;
 28 
 29 #include &lt;math.h&gt;
 30 #include &lt;wtf/PrintStream.h&gt;
 31 
 32 namespace WebCore {
 33 
 34 PlatformTimeRanges::PlatformTimeRanges(const MediaTime&amp; start, const MediaTime&amp; end)
 35 {
 36     add(start, end);
 37 }
 38 





 39 void PlatformTimeRanges::invert()
 40 {
 41     PlatformTimeRanges inverted;
 42     MediaTime posInf = MediaTime::positiveInfiniteTime();
 43     MediaTime negInf = MediaTime::negativeInfiniteTime();
 44 
 45     if (!m_ranges.size())
 46         inverted.add(negInf, posInf);
 47     else {
 48         MediaTime start = m_ranges.first().m_start;
 49         if (start != negInf)
 50             inverted.add(negInf, start);
 51 
 52         for (size_t index = 0; index + 1 &lt; m_ranges.size(); ++index)
 53             inverted.add(m_ranges[index].m_end, m_ranges[index + 1].m_start);
 54 
 55         MediaTime end = m_ranges.last().m_end;
 56         if (end != posInf)
 57             inverted.add(end, posInf);
 58     }
</pre>
<hr />
<pre>
161             if (!overlappingArcIndex) {
162                 if (addedRange.isBeforeRange(m_ranges[0])) {
163                     // First index, and we are completely before that range (and not contiguous, nor overlapping).
164                     // We just need to be inserted here.
165                     break;
166                 }
167             } else {
168                 if (m_ranges[overlappingArcIndex - 1].isBeforeRange(addedRange) &amp;&amp; addedRange.isBeforeRange(m_ranges[overlappingArcIndex])) {
169                     // We are exactly after the current previous range, and before the current range, while
170                     // not overlapping with none of them. Insert here.
171                     break;
172                 }
173             }
174         }
175     }
176 
177     // Now that we are sure we don&#39;t overlap with any range, just add it.
178     m_ranges.insert(overlappingArcIndex, addedRange);
179 }
180 





181 bool PlatformTimeRanges::contain(const MediaTime&amp; time) const
182 {
183     return find(time) != notFound;
184 }
185 
186 size_t PlatformTimeRanges::find(const MediaTime&amp; time) const
187 {
188     bool ignoreInvalid;
189     for (unsigned n = 0; n &lt; length(); n++) {
190         if (time &gt;= start(n, ignoreInvalid) &amp;&amp; time &lt;= end(n, ignoreInvalid))
191             return n;
192     }
193     return notFound;
194 }
195 
196 MediaTime PlatformTimeRanges::nearest(const MediaTime&amp; time) const
197 {
198     MediaTime closestDelta = MediaTime::positiveInfiniteTime();
199     MediaTime closestTime = MediaTime::zeroTime();
200     unsigned count = length();
</pre>
</td>
<td>
<hr />
<pre>
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;PlatformTimeRanges.h&quot;
 28 
 29 #include &lt;math.h&gt;
 30 #include &lt;wtf/PrintStream.h&gt;
 31 
 32 namespace WebCore {
 33 
 34 PlatformTimeRanges::PlatformTimeRanges(const MediaTime&amp; start, const MediaTime&amp; end)
 35 {
 36     add(start, end);
 37 }
 38 
<span class="line-added"> 39 PlatformTimeRanges::PlatformTimeRanges(Vector&lt;Range&gt;&amp;&amp; ranges)</span>
<span class="line-added"> 40     : m_ranges { WTFMove(ranges) }</span>
<span class="line-added"> 41 {</span>
<span class="line-added"> 42 }</span>
<span class="line-added"> 43 </span>
 44 void PlatformTimeRanges::invert()
 45 {
 46     PlatformTimeRanges inverted;
 47     MediaTime posInf = MediaTime::positiveInfiniteTime();
 48     MediaTime negInf = MediaTime::negativeInfiniteTime();
 49 
 50     if (!m_ranges.size())
 51         inverted.add(negInf, posInf);
 52     else {
 53         MediaTime start = m_ranges.first().m_start;
 54         if (start != negInf)
 55             inverted.add(negInf, start);
 56 
 57         for (size_t index = 0; index + 1 &lt; m_ranges.size(); ++index)
 58             inverted.add(m_ranges[index].m_end, m_ranges[index + 1].m_start);
 59 
 60         MediaTime end = m_ranges.last().m_end;
 61         if (end != posInf)
 62             inverted.add(end, posInf);
 63     }
</pre>
<hr />
<pre>
166             if (!overlappingArcIndex) {
167                 if (addedRange.isBeforeRange(m_ranges[0])) {
168                     // First index, and we are completely before that range (and not contiguous, nor overlapping).
169                     // We just need to be inserted here.
170                     break;
171                 }
172             } else {
173                 if (m_ranges[overlappingArcIndex - 1].isBeforeRange(addedRange) &amp;&amp; addedRange.isBeforeRange(m_ranges[overlappingArcIndex])) {
174                     // We are exactly after the current previous range, and before the current range, while
175                     // not overlapping with none of them. Insert here.
176                     break;
177                 }
178             }
179         }
180     }
181 
182     // Now that we are sure we don&#39;t overlap with any range, just add it.
183     m_ranges.insert(overlappingArcIndex, addedRange);
184 }
185 
<span class="line-added">186 void PlatformTimeRanges::clear()</span>
<span class="line-added">187 {</span>
<span class="line-added">188     m_ranges.clear();</span>
<span class="line-added">189 }</span>
<span class="line-added">190 </span>
191 bool PlatformTimeRanges::contain(const MediaTime&amp; time) const
192 {
193     return find(time) != notFound;
194 }
195 
196 size_t PlatformTimeRanges::find(const MediaTime&amp; time) const
197 {
198     bool ignoreInvalid;
199     for (unsigned n = 0; n &lt; length(); n++) {
200         if (time &gt;= start(n, ignoreInvalid) &amp;&amp; time &lt;= end(n, ignoreInvalid))
201             return n;
202     }
203     return notFound;
204 }
205 
206 MediaTime PlatformTimeRanges::nearest(const MediaTime&amp; time) const
207 {
208     MediaTime closestDelta = MediaTime::positiveInfiniteTime();
209     MediaTime closestTime = MediaTime::zeroTime();
210     unsigned count = length();
</pre>
</td>
</tr>
</table>
<center><a href="PlatformMediaResourceLoader.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="PlatformTimeRanges.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
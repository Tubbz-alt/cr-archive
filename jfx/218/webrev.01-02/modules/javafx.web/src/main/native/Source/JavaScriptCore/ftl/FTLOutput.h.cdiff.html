<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOutput.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FTLOutput.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLSlowPathCall.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOutput.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 37,10 ***</span>
<span class="line-new-header">--- 37,11 ---</span>
  #include &quot;B3SwitchValue.h&quot;
  #include &quot;B3Width.h&quot;
  #include &quot;FTLAbbreviatedTypes.h&quot;
  #include &quot;FTLAbstractHeapRepository.h&quot;
  #include &quot;FTLCommonValues.h&quot;
<span class="line-added">+ #include &quot;FTLSelectPredictability.h&quot;</span>
  #include &quot;FTLState.h&quot;
  #include &quot;FTLSwitchCase.h&quot;
  #include &quot;FTLTypedPointer.h&quot;
  #include &quot;FTLValueFromBlock.h&quot;
  #include &quot;FTLWeight.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 102,18 ***</span>
      B3::SlotBaseValue* lockedStackSlot(size_t bytes);
  
      LValue constBool(bool value);
      LValue constInt32(int32_t value);
  
<span class="line-modified">!     LValue weakPointer(DFG::Graph&amp; graph, JSCell* cell)</span>
      {
          ASSERT(graph.m_plan.weakReferences().contains(cell));
  
          return constIntPtr(bitwise_cast&lt;intptr_t&gt;(cell));
      }
  
<span class="line-modified">!     LValue weakPointer(DFG::FrozenValue* value)</span>
      {
          RELEASE_ASSERT(value-&gt;value().isCell());
  
          return constIntPtr(bitwise_cast&lt;intptr_t&gt;(value-&gt;cell()));
      }
<span class="line-new-header">--- 103,18 ---</span>
      B3::SlotBaseValue* lockedStackSlot(size_t bytes);
  
      LValue constBool(bool value);
      LValue constInt32(int32_t value);
  
<span class="line-modified">!     LValue alreadyRegisteredWeakPointer(DFG::Graph&amp; graph, JSCell* cell)</span>
      {
          ASSERT(graph.m_plan.weakReferences().contains(cell));
  
          return constIntPtr(bitwise_cast&lt;intptr_t&gt;(cell));
      }
  
<span class="line-modified">!     LValue alreadyRegisteredFrozenPointer(DFG::FrozenValue* value)</span>
      {
          RELEASE_ASSERT(value-&gt;value().isCell());
  
          return constIntPtr(bitwise_cast&lt;intptr_t&gt;(value-&gt;cell()));
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 186,10 ***</span>
<span class="line-new-header">--- 187,11 ---</span>
      LValue doubleSqrt(LValue);
  
      LValue doubleLog(LValue);
  
      LValue doubleToInt(LValue);
<span class="line-added">+     LValue doubleToInt64(LValue);</span>
      LValue doubleToUInt(LValue);
  
      LValue signExt32To64(LValue);
      LValue signExt32ToPtr(LValue);
      LValue zeroExt(LValue, LType);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 362,11 ***</span>
      LValue testIsZero64(LValue value, LValue mask) { return isZero64(bitAnd(value, mask)); }
      LValue testNonZero64(LValue value, LValue mask) { return notZero64(bitAnd(value, mask)); }
      LValue testIsZeroPtr(LValue value, LValue mask) { return isNull(bitAnd(value, mask)); }
      LValue testNonZeroPtr(LValue value, LValue mask) { return notNull(bitAnd(value, mask)); }
  
<span class="line-modified">!     LValue select(LValue value, LValue taken, LValue notTaken);</span>
  
      // These are relaxed atomics by default. Use AbstractHeapRepository::decorateFencedAccess() with a
      // non-null heap to make them seq_cst fenced.
      LValue atomicXchgAdd(LValue operand, TypedPointer pointer, B3::Width);
      LValue atomicXchgAnd(LValue operand, TypedPointer pointer, B3::Width);
<span class="line-new-header">--- 364,11 ---</span>
      LValue testIsZero64(LValue value, LValue mask) { return isZero64(bitAnd(value, mask)); }
      LValue testNonZero64(LValue value, LValue mask) { return notZero64(bitAnd(value, mask)); }
      LValue testIsZeroPtr(LValue value, LValue mask) { return isNull(bitAnd(value, mask)); }
      LValue testNonZeroPtr(LValue value, LValue mask) { return notNull(bitAnd(value, mask)); }
  
<span class="line-modified">!     LValue select(LValue value, LValue taken, LValue notTaken, SelectPredictability = SelectPredictability::NotPredictable);</span>
  
      // These are relaxed atomics by default. Use AbstractHeapRepository::decorateFencedAccess() with a
      // non-null heap to make them seq_cst fenced.
      LValue atomicXchgAdd(LValue operand, TypedPointer pointer, B3::Width);
      LValue atomicXchgAnd(LValue operand, TypedPointer pointer, B3::Width);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 389,10 ***</span>
<span class="line-new-header">--- 391,11 ---</span>
      LValue call(LType type, LValue function, LValue arg1, Args... args) { return m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), function, arg1, args...); }
  
      template&lt;typename Function, typename... Args&gt;
      LValue callWithoutSideEffects(B3::Type type, Function function, LValue arg1, Args... args)
      {
<span class="line-added">+         static_assert(!std::is_same&lt;Function, LValue&gt;::value);</span>
          return m_block-&gt;appendNew&lt;B3::CCallValue&gt;(m_proc, type, origin(), B3::Effects::none(),
              constIntPtr(tagCFunctionPtr&lt;void*&gt;(function, B3CCallPtrTag)), arg1, args...);
      }
  
      // FIXME: Consider enhancing this to allow the client to choose the target PtrTag to use.
</pre>
<center><a href="FTLOutput.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="FTLSlowPathCall.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Options.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;Options.h&quot;
  28 
  29 #include &quot;AssemblerCommon.h&quot;
  30 #include &quot;CPU.h&quot;
  31 #include &quot;LLIntCommon.h&quot;
  32 #include &quot;MinimumReservedZoneSize.h&quot;
  33 #include &quot;SigillCrashAnalyzer.h&quot;
  34 #include &lt;algorithm&gt;
  35 #include &lt;limits&gt;
  36 #include &lt;math.h&gt;
  37 #include &lt;mutex&gt;
  38 #include &lt;stdlib.h&gt;
  39 #include &lt;string.h&gt;
  40 #include &lt;wtf/ASCIICType.h&gt;
  41 #include &lt;wtf/Compiler.h&gt;
  42 #include &lt;wtf/DataLog.h&gt;
  43 #include &lt;wtf/NumberOfCores.h&gt;
<a name="1" id="anc1"></a><span class="line-added">  44 #include &lt;wtf/Optional.h&gt;</span>
  45 #include &lt;wtf/PointerPreparations.h&gt;
  46 #include &lt;wtf/StdLibExtras.h&gt;
  47 #include &lt;wtf/text/StringBuilder.h&gt;
  48 #include &lt;wtf/threads/Signals.h&gt;
  49 
  50 #if PLATFORM(COCOA)
  51 #include &lt;crt_externs.h&gt;
  52 #endif
  53 
  54 #if ENABLE(JIT)
  55 #include &quot;MacroAssembler.h&quot;
  56 #endif
  57 
  58 namespace JSC {
  59 
<a name="2" id="anc2"></a><span class="line-modified">  60 template&lt;typename T&gt;</span>
<span class="line-modified">  61 Optional&lt;T&gt; parse(const char* string);</span>










  62 
<a name="3" id="anc3"></a><span class="line-modified">  63 template&lt;&gt;</span>
<span class="line-added">  64 Optional&lt;OptionsStorage::Bool&gt; parse(const char* string)</span>
  65 {
<a name="4" id="anc4"></a><span class="line-modified">  66     if (equalLettersIgnoringASCIICase(string, &quot;true&quot;) || equalLettersIgnoringASCIICase(string, &quot;yes&quot;) || !strcmp(string, &quot;1&quot;))</span>

  67         return true;
<a name="5" id="anc5"></a><span class="line-modified">  68     if (equalLettersIgnoringASCIICase(string, &quot;false&quot;) || equalLettersIgnoringASCIICase(string, &quot;no&quot;) || !strcmp(string, &quot;0&quot;))</span>
<span class="line-modified">  69         return false;</span>
<span class="line-modified">  70     return WTF::nullopt;</span>








  71 }
  72 
<a name="6" id="anc6"></a><span class="line-modified">  73 template&lt;&gt;</span>
<span class="line-added">  74 Optional&lt;OptionsStorage::Int32&gt; parse(const char* string)</span>
  75 {
<a name="7" id="anc7"></a><span class="line-modified">  76     int32_t value;</span>
<span class="line-added">  77     if (sscanf(string, &quot;%d&quot;, &amp;value) == 1)</span>
<span class="line-added">  78         return value;</span>
<span class="line-added">  79     return WTF::nullopt;</span>
  80 }
  81 
<a name="8" id="anc8"></a><span class="line-modified">  82 template&lt;&gt;</span>
<span class="line-added">  83 Optional&lt;OptionsStorage::Unsigned&gt; parse(const char* string)</span>
  84 {
<a name="9" id="anc9"></a><span class="line-modified">  85     unsigned value;</span>
<span class="line-added">  86     if (sscanf(string, &quot;%u&quot;, &amp;value) == 1)</span>
<span class="line-added">  87         return value;</span>
<span class="line-added">  88     return WTF::nullopt;</span>
  89 }
  90 
<a name="10" id="anc10"></a><span class="line-modified">  91 #if CPU(ADDRESS64) || OS(DARWIN)</span>
<span class="line-added">  92 template&lt;&gt;</span>
<span class="line-added">  93 Optional&lt;OptionsStorage::Size&gt; parse(const char* string)</span>
  94 {
<a name="11" id="anc11"></a><span class="line-modified">  95     size_t value;</span>
<span class="line-added">  96     if (sscanf(string, &quot;%zu&quot;, &amp;value) == 1)</span>
<span class="line-added">  97         return value;</span>
<span class="line-added">  98     return WTF::nullopt;</span>
  99 }
<a name="12" id="anc12"></a><span class="line-added"> 100 #endif // CPU(ADDRESS64) || OS(DARWIN)</span>
 101 
<a name="13" id="anc13"></a><span class="line-modified"> 102 template&lt;&gt;</span>
<span class="line-added"> 103 Optional&lt;OptionsStorage::Double&gt; parse(const char* string)</span>
 104 {
<a name="14" id="anc14"></a><span class="line-modified"> 105     double value;</span>
<span class="line-added"> 106     if (sscanf(string, &quot;%lf&quot;, &amp;value) == 1)</span>
<span class="line-added"> 107         return value;</span>
<span class="line-added"> 108     return WTF::nullopt;</span>
 109 }
 110 
<a name="15" id="anc15"></a><span class="line-modified"> 111 template&lt;&gt;</span>
<span class="line-added"> 112 Optional&lt;OptionsStorage::OptionRange&gt; parse(const char* string)</span>
 113 {
<a name="16" id="anc16"></a><span class="line-modified"> 114     OptionRange range;</span>
<span class="line-added"> 115     if (range.init(string))</span>
<span class="line-added"> 116         return range;</span>
<span class="line-added"> 117     return WTF::nullopt;</span>
 118 }
 119 
<a name="17" id="anc17"></a><span class="line-modified"> 120 template&lt;&gt;</span>
<span class="line-added"> 121 Optional&lt;OptionsStorage::OptionString&gt; parse(const char* string)</span>
 122 {
<a name="18" id="anc18"></a><span class="line-modified"> 123     const char* value = nullptr;</span>
<span class="line-modified"> 124     if (!strlen(string))</span>
<span class="line-modified"> 125         return value;</span>

 126 
 127     // FIXME &lt;https://webkit.org/b/169057&gt;: This could leak if this option is set more than once.
 128     // Given that Options are typically used for testing, this isn&#39;t considered to be a problem.
 129     value = WTF::fastStrDup(string);
<a name="19" id="anc19"></a><span class="line-modified"> 130     return value;</span>
 131 }
 132 
<a name="20" id="anc20"></a><span class="line-modified"> 133 template&lt;&gt;</span>
<span class="line-added"> 134 Optional&lt;OptionsStorage::GCLogLevel&gt; parse(const char* string)</span>
 135 {
<a name="21" id="anc21"></a><span class="line-modified"> 136     if (equalLettersIgnoringASCIICase(string, &quot;none&quot;) || equalLettersIgnoringASCIICase(string, &quot;no&quot;) || equalLettersIgnoringASCIICase(string, &quot;false&quot;) || !strcmp(string, &quot;0&quot;))</span>
<span class="line-modified"> 137         return GCLogging::None;</span>


 138 
<a name="22" id="anc22"></a><span class="line-modified"> 139     if (equalLettersIgnoringASCIICase(string, &quot;basic&quot;) || equalLettersIgnoringASCIICase(string, &quot;yes&quot;) || equalLettersIgnoringASCIICase(string, &quot;true&quot;) || !strcmp(string, &quot;1&quot;))</span>
<span class="line-modified"> 140         return GCLogging::Basic;</span>


 141 
<a name="23" id="anc23"></a><span class="line-modified"> 142     if (equalLettersIgnoringASCIICase(string, &quot;verbose&quot;) || !strcmp(string, &quot;2&quot;))</span>
<span class="line-modified"> 143         return GCLogging::Verbose;</span>


 144 
<a name="24" id="anc24"></a><span class="line-modified"> 145     return WTF::nullopt;</span>
 146 }
 147 
 148 bool Options::isAvailable(Options::ID id, Options::Availability availability)
 149 {
 150     if (availability == Availability::Restricted)
<a name="25" id="anc25"></a><span class="line-modified"> 151         return g_jscConfig.restrictedOptionsEnabled;</span>
 152     ASSERT(availability == Availability::Configurable);
 153 
 154     UNUSED_PARAM(id);
 155 #if !defined(NDEBUG)
 156     if (id == maxSingleAllocationSizeID)
 157         return true;
 158 #endif
 159 #if OS(DARWIN)
 160     if (id == useSigillCrashAnalyzerID)
 161         return true;
 162 #endif
 163 #if ENABLE(ASSEMBLER) &amp;&amp; OS(LINUX)
 164     if (id == logJITCodeForPerfID)
 165         return true;
 166 #endif
 167     if (id == traceLLIntExecutionID)
 168         return !!LLINT_TRACING;
 169     if (id == traceLLIntSlowPathID)
 170         return !!LLINT_TRACING;
 171     return false;
 172 }
 173 
 174 template&lt;typename T&gt;
 175 bool overrideOptionWithHeuristic(T&amp; variable, Options::ID id, const char* name, Options::Availability availability)
 176 {
 177     bool available = (availability == Options::Availability::Normal)
 178         || Options::isAvailable(id, availability);
 179 
 180     const char* stringValue = getenv(name);
 181     if (!stringValue)
 182         return false;
 183 
<a name="26" id="anc26"></a><span class="line-modified"> 184     if (available) {</span>
<span class="line-modified"> 185         Optional&lt;T&gt; value = parse&lt;T&gt;(stringValue);</span>
<span class="line-added"> 186         if (value) {</span>
<span class="line-added"> 187             variable = value.value();</span>
<span class="line-added"> 188             return true;</span>
<span class="line-added"> 189         }</span>
<span class="line-added"> 190     }</span>
 191 
 192     fprintf(stderr, &quot;WARNING: failed to parse %s=%s\n&quot;, name, stringValue);
 193     return false;
 194 }
 195 
 196 bool Options::overrideAliasedOptionWithHeuristic(const char* name)
 197 {
 198     const char* stringValue = getenv(name);
 199     if (!stringValue)
 200         return false;
 201 
 202     String aliasedOption;
 203     aliasedOption = String(&amp;name[4]) + &quot;=&quot; + stringValue;
 204     if (Options::setOption(aliasedOption.utf8().data()))
 205         return true;
 206 
 207     fprintf(stderr, &quot;WARNING: failed to parse %s=%s\n&quot;, name, stringValue);
 208     return false;
 209 }
 210 
 211 static unsigned computeNumberOfWorkerThreads(int maxNumberOfWorkerThreads, int minimum = 1)
 212 {
 213     int cpusToUse = std::min(kernTCSMAwareNumberOfProcessorCores(), maxNumberOfWorkerThreads);
 214 
 215     // Be paranoid, it is the OS we&#39;re dealing with, after all.
 216     ASSERT(cpusToUse &gt;= 1);
 217     return std::max(cpusToUse, minimum);
 218 }
 219 
 220 static int32_t computePriorityDeltaOfWorkerThreads(int32_t twoCorePriorityDelta, int32_t multiCorePriorityDelta)
 221 {
 222     if (kernTCSMAwareNumberOfProcessorCores() &lt;= 2)
 223         return twoCorePriorityDelta;
 224 
 225     return multiCorePriorityDelta;
 226 }
 227 
 228 static bool jitEnabledByDefault()
 229 {
 230     return is32Bit() || isAddress64Bit();
 231 }
 232 
 233 static unsigned computeNumberOfGCMarkers(unsigned maxNumberOfGCMarkers)
 234 {
 235     return computeNumberOfWorkerThreads(maxNumberOfGCMarkers);
 236 }
 237 
 238 const char* const OptionRange::s_nullRangeStr = &quot;&lt;null&gt;&quot;;
 239 
 240 bool OptionRange::init(const char* rangeString)
 241 {
 242     // rangeString should be in the form of [!]&lt;low&gt;[:&lt;high&gt;]
 243     // where low and high are unsigned
 244 
 245     bool invert = false;
 246 
 247     if (!rangeString) {
 248         m_state = InitError;
 249         return false;
 250     }
 251 
 252     if (!strcmp(rangeString, s_nullRangeStr)) {
 253         m_state = Uninitialized;
 254         return true;
 255     }
 256 
 257     const char* p = rangeString;
 258 
 259     if (*p == &#39;!&#39;) {
 260         invert = true;
 261         p++;
 262     }
 263 
 264     int scanResult = sscanf(p, &quot; %u:%u&quot;, &amp;m_lowLimit, &amp;m_highLimit);
 265 
 266     if (!scanResult || scanResult == EOF) {
 267         m_state = InitError;
 268         return false;
 269     }
 270 
 271     if (scanResult == 1)
 272         m_highLimit = m_lowLimit;
 273 
 274     if (m_lowLimit &gt; m_highLimit) {
 275         m_state = InitError;
 276         return false;
 277     }
 278 
 279     // FIXME &lt;https://webkit.org/b/169057&gt;: This could leak if this particular option is set more than once.
 280     // Given that these options are used for testing, this isn&#39;t considered to be problem.
 281     m_rangeString = WTF::fastStrDup(rangeString);
 282     m_state = invert ? Inverted : Normal;
 283 
 284     return true;
 285 }
 286 
 287 bool OptionRange::isInRange(unsigned count)
 288 {
 289     if (m_state &lt; Normal)
 290         return true;
 291 
 292     if ((m_lowLimit &lt;= count) &amp;&amp; (count &lt;= m_highLimit))
 293         return m_state == Normal ? true : false;
 294 
 295     return m_state == Normal ? false : true;
 296 }
 297 
 298 void OptionRange::dump(PrintStream&amp; out) const
 299 {
 300     out.print(m_rangeString);
 301 }
 302 
<a name="27" id="anc27"></a>


 303 // Realize the names for each of the options:
<a name="28" id="anc28"></a><span class="line-modified"> 304 const Options::ConstMetaData Options::s_constMetaData[NumberOfOptions] = {</span>
<span class="line-modified"> 305 #define FILL_OPTION_INFO(type_, name_, defaultValue_, availability_, description_) \</span>
<span class="line-modified"> 306     { #name_, description_, Options::Type::type_, Availability::availability_, offsetof(OptionsStorage, name_), offsetof(OptionsStorage, name_##Default) },</span>
<span class="line-modified"> 307     FOR_EACH_JSC_OPTION(FILL_OPTION_INFO)</span>
<span class="line-modified"> 308 #undef FILL_OPTION_INFO</span>
 309 };
 310 
 311 static void scaleJITPolicy()
 312 {
 313     auto&amp; scaleFactor = Options::jitPolicyScale();
 314     if (scaleFactor &gt; 1.0)
 315         scaleFactor = 1.0;
 316     else if (scaleFactor &lt; 0.0)
 317         scaleFactor = 0.0;
 318 
<a name="29" id="anc29"></a><span class="line-modified"> 319     auto scaleOption = [&amp;] (int32_t&amp; optionValue, int32_t minValue) {</span>
<span class="line-modified"> 320         optionValue *= scaleFactor;</span>
<span class="line-modified"> 321         optionValue = std::max(optionValue, minValue);</span>
 322     };
 323 
<a name="30" id="anc30"></a><span class="line-modified"> 324     scaleOption(Options::thresholdForJITAfterWarmUp(), 0);</span>
<span class="line-modified"> 325     scaleOption(Options::thresholdForJITSoon(), 0);</span>
<span class="line-modified"> 326     scaleOption(Options::thresholdForOptimizeAfterWarmUp(), 1);</span>
<span class="line-modified"> 327     scaleOption(Options::thresholdForOptimizeAfterLongWarmUp(), 1);</span>
<span class="line-modified"> 328     scaleOption(Options::thresholdForOptimizeSoon(), 1);</span>
<span class="line-modified"> 329     scaleOption(Options::thresholdForFTLOptimizeSoon(), 2);</span>
<span class="line-modified"> 330     scaleOption(Options::thresholdForFTLOptimizeAfterWarmUp(), 2);</span>










 331 }
 332 
 333 static void overrideDefaults()
 334 {
 335 #if !PLATFORM(IOS_FAMILY)
 336     if (WTF::numberOfProcessorCores() &lt; 4)
 337 #endif
 338     {
 339         Options::maximumMutatorUtilization() = 0.6;
 340         Options::concurrentGCMaxHeadroom() = 1.4;
 341         Options::minimumGCPauseMS() = 1;
 342         Options::useStochasticMutatorScheduler() = false;
 343         if (WTF::numberOfProcessorCores() &lt;= 1)
 344             Options::gcIncrementScale() = 1;
 345         else
 346             Options::gcIncrementScale() = 0;
 347     }
 348 
<a name="31" id="anc31"></a><span class="line-modified"> 349 #if USE(BMALLOC_MEMORY_FOOTPRINT_API)</span>
<span class="line-modified"> 350     // On iOS and conditionally Linux, we control heap growth using process memory footprint. Therefore these values can be agressive.</span>
 351     Options::smallHeapRAMFraction() = 0.8;
 352     Options::mediumHeapRAMFraction() = 0.9;
<a name="32" id="anc32"></a><span class="line-added"> 353 #endif</span>
 354 
<a name="33" id="anc33"></a><span class="line-modified"> 355 #if PLATFORM(IOS_FAMILY) &amp;&amp; !PLATFORM(WATCHOS) &amp;&amp; defined(__LP64__)</span>
 356     Options::useSigillCrashAnalyzer() = true;
 357 #endif
<a name="34" id="anc34"></a>
 358 
 359 #if !ENABLE(SIGNAL_BASED_VM_TRAPS)
 360     Options::usePollingTraps() = true;
 361 #endif
 362 
 363 #if !ENABLE(WEBASSEMBLY_FAST_MEMORY)
 364     Options::useWebAssemblyFastMemory() = false;
 365 #endif
 366 
 367 #if !HAVE(MACH_EXCEPTIONS)
 368     Options::useMachForExceptions() = false;
 369 #endif
<a name="35" id="anc35"></a><span class="line-added"> 370 </span>
<span class="line-added"> 371     if (Options::useWasmLLInt() &amp;&amp; !Options::wasmLLIntTiersUpToBBQ()) {</span>
<span class="line-added"> 372         Options::thresholdForOMGOptimizeAfterWarmUp() = 1500;</span>
<span class="line-added"> 373         Options::thresholdForOMGOptimizeSoon() = 100;</span>
<span class="line-added"> 374     }</span>
 375 }
 376 
 377 static void correctOptions()
 378 {
 379     unsigned thresholdForGlobalLexicalBindingEpoch = Options::thresholdForGlobalLexicalBindingEpoch();
 380     if (thresholdForGlobalLexicalBindingEpoch == 0 || thresholdForGlobalLexicalBindingEpoch == 1)
 381         Options::thresholdForGlobalLexicalBindingEpoch() = UINT_MAX;
 382 }
 383 
 384 static void recomputeDependentOptions()
 385 {
 386 #if !defined(NDEBUG)
 387     Options::validateDFGExceptionHandling() = true;
 388 #endif
 389 #if !ENABLE(JIT)
 390     Options::useLLInt() = true;
 391     Options::useJIT() = false;
 392     Options::useBaselineJIT() = false;
 393     Options::useDFGJIT() = false;
 394     Options::useFTLJIT() = false;
 395     Options::useDOMJIT() = false;
 396     Options::useRegExpJIT() = false;
 397 #endif
 398 #if !ENABLE(CONCURRENT_JS)
 399     Options::useConcurrentJIT() = false;
 400 #endif
 401 #if !ENABLE(YARR_JIT)
 402     Options::useRegExpJIT() = false;
 403 #endif
 404 #if !ENABLE(DFG_JIT)
 405     Options::useDFGJIT() = false;
 406     Options::useFTLJIT() = false;
 407 #endif
 408 #if !ENABLE(FTL_JIT)
 409     Options::useFTLJIT() = false;
 410 #endif
 411 
 412 #if !CPU(X86_64) &amp;&amp; !CPU(ARM64)
 413     Options::useConcurrentGC() = false;
 414 #endif
 415 
 416     if (!Options::useJIT()) {
 417         Options::useSigillCrashAnalyzer() = false;
 418         Options::useWebAssembly() = false;
 419     }
 420 
 421     if (!jitEnabledByDefault() &amp;&amp; !Options::useJIT())
 422         Options::useLLInt() = true;
 423 
 424     if (!Options::useWebAssembly())
 425         Options::useFastTLSForWasmContext() = false;
 426 
 427     if (Options::dumpDisassembly()
 428         || Options::dumpDFGDisassembly()
 429         || Options::dumpFTLDisassembly()
 430         || Options::dumpBytecodeAtDFGTime()
 431         || Options::dumpGraphAtEachPhase()
 432         || Options::dumpDFGGraphAtEachPhase()
 433         || Options::dumpDFGFTLGraphAtEachPhase()
 434         || Options::dumpB3GraphAtEachPhase()
 435         || Options::dumpAirGraphAtEachPhase()
 436         || Options::verboseCompilation()
 437         || Options::verboseFTLCompilation()
 438         || Options::logCompilationChanges()
 439         || Options::validateGraph()
 440         || Options::validateGraphAtEachPhase()
 441         || Options::verboseOSR()
 442         || Options::verboseCompilationQueue()
 443         || Options::reportCompileTimes()
 444         || Options::reportBaselineCompileTimes()
 445         || Options::reportDFGCompileTimes()
 446         || Options::reportFTLCompileTimes()
 447         || Options::logPhaseTimes()
 448         || Options::verboseCFA()
 449         || Options::verboseDFGFailure()
 450         || Options::verboseFTLFailure()
<a name="36" id="anc36"></a><span class="line-modified"> 451         || Options::dumpFuzzerAgentPredictions())</span>
 452         Options::alwaysComputeHash() = true;
 453 
 454     if (!Options::useConcurrentGC())
 455         Options::collectContinuously() = false;
 456 
<a name="37" id="anc37"></a><span class="line-modified"> 457     if (Options::jitPolicyScale() != Options::jitPolicyScaleDefault())</span>
 458         scaleJITPolicy();
 459 
 460     if (Options::forceEagerCompilation()) {
 461         Options::thresholdForJITAfterWarmUp() = 10;
 462         Options::thresholdForJITSoon() = 10;
 463         Options::thresholdForOptimizeAfterWarmUp() = 20;
 464         Options::thresholdForOptimizeAfterLongWarmUp() = 20;
 465         Options::thresholdForOptimizeSoon() = 20;
 466         Options::thresholdForFTLOptimizeAfterWarmUp() = 20;
 467         Options::thresholdForFTLOptimizeSoon() = 20;
 468         Options::maximumEvalCacheableSourceLength() = 150000;
 469         Options::useConcurrentJIT() = false;
 470     }
 471 #if ENABLE(SEPARATED_WX_HEAP)
 472     // Override globally for now. Longer term we&#39;ll just make the default
 473     // be to have this option enabled, and have platforms that don&#39;t support
 474     // it just silently use a single mapping.
 475     Options::useSeparatedWXHeap() = true;
 476 #else
 477     Options::useSeparatedWXHeap() = false;
 478 #endif
 479 
 480     if (Options::alwaysUseShadowChicken())
 481         Options::maximumInliningDepth() = 1;
 482 
 483     // Compute the maximum value of the reoptimization retry counter. This is simply
 484     // the largest value at which we don&#39;t overflow the execute counter, when using it
 485     // to left-shift the execution counter by this amount. Currently the value ends
 486     // up being 18, so this loop is not so terrible; it probably takes up ~100 cycles
 487     // total on a 32-bit processor.
 488     Options::reoptimizationRetryCounterMax() = 0;
 489     while ((static_cast&lt;int64_t&gt;(Options::thresholdForOptimizeAfterLongWarmUp()) &lt;&lt; (Options::reoptimizationRetryCounterMax() + 1)) &lt;= static_cast&lt;int64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()))
 490         Options::reoptimizationRetryCounterMax()++;
 491 
 492     ASSERT((static_cast&lt;int64_t&gt;(Options::thresholdForOptimizeAfterLongWarmUp()) &lt;&lt; Options::reoptimizationRetryCounterMax()) &gt; 0);
 493     ASSERT((static_cast&lt;int64_t&gt;(Options::thresholdForOptimizeAfterLongWarmUp()) &lt;&lt; Options::reoptimizationRetryCounterMax()) &lt;= static_cast&lt;int64_t&gt;(std::numeric_limits&lt;int32_t&gt;::max()));
 494 
 495 #if !defined(NDEBUG)
 496     if (Options::maxSingleAllocationSize())
 497         fastSetMaxSingleAllocationSize(Options::maxSingleAllocationSize());
 498     else
 499         fastSetMaxSingleAllocationSize(std::numeric_limits&lt;size_t&gt;::max());
 500 #endif
 501 
 502     if (Options::useZombieMode()) {
 503         Options::sweepSynchronously() = true;
 504         Options::scribbleFreeCells() = true;
 505     }
 506 
 507     if (Options::reservedZoneSize() &lt; minimumReservedZoneSize)
 508         Options::reservedZoneSize() = minimumReservedZoneSize;
 509     if (Options::softReservedZoneSize() &lt; Options::reservedZoneSize() + minimumReservedZoneSize)
 510         Options::softReservedZoneSize() = Options::reservedZoneSize() + minimumReservedZoneSize;
 511 
<a name="38" id="anc38"></a>
 512     // FIXME: Make probe OSR exit work on 32-bit:
 513     // https://bugs.webkit.org/show_bug.cgi?id=177956
 514     Options::useProbeOSRExit() = false;
<a name="39" id="anc39"></a>
 515 
 516     if (!Options::useCodeCache())
 517         Options::diskCachePath() = nullptr;
<a name="40" id="anc40"></a><span class="line-added"> 518 </span>
<span class="line-added"> 519     if (Options::randomIntegrityAuditRate() &lt; 0)</span>
<span class="line-added"> 520         Options::randomIntegrityAuditRate() = 0;</span>
<span class="line-added"> 521     else if (Options::randomIntegrityAuditRate() &gt; 1.0)</span>
<span class="line-added"> 522         Options::randomIntegrityAuditRate() = 1.0;</span>
<span class="line-added"> 523 }</span>
<span class="line-added"> 524 </span>
<span class="line-added"> 525 inline void* Options::addressOfOption(Options::ID id)</span>
<span class="line-added"> 526 {</span>
<span class="line-added"> 527     auto offset = Options::s_constMetaData[id].offsetOfOption;</span>
<span class="line-added"> 528     return reinterpret_cast&lt;uint8_t*&gt;(&amp;g_jscConfig.options) + offset;</span>
<span class="line-added"> 529 }</span>
<span class="line-added"> 530 </span>
<span class="line-added"> 531 inline void* Options::addressOfOptionDefault(Options::ID id)</span>
<span class="line-added"> 532 {</span>
<span class="line-added"> 533     auto offset = Options::s_constMetaData[id].offsetOfOptionDefault;</span>
<span class="line-added"> 534     return reinterpret_cast&lt;uint8_t*&gt;(&amp;g_jscConfig.options) + offset;</span>
 535 }
 536 
 537 void Options::initialize()
 538 {
 539     static std::once_flag initializeOptionsOnceFlag;
 540 
 541     std::call_once(
 542         initializeOptionsOnceFlag,
 543         [] {
<a name="41" id="anc41"></a><span class="line-added"> 544             // Sanity check that options address computation is working.</span>
<span class="line-added"> 545             RELEASE_ASSERT(Options::addressOfOption(useKernTCSMID) ==  &amp;Options::useKernTCSM());</span>
<span class="line-added"> 546             RELEASE_ASSERT(Options::addressOfOptionDefault(useKernTCSMID) ==  &amp;Options::useKernTCSMDefault());</span>
<span class="line-added"> 547             RELEASE_ASSERT(Options::addressOfOption(gcMaxHeapSizeID) ==  &amp;Options::gcMaxHeapSize());</span>
<span class="line-added"> 548             RELEASE_ASSERT(Options::addressOfOptionDefault(gcMaxHeapSizeID) ==  &amp;Options::gcMaxHeapSizeDefault());</span>
<span class="line-added"> 549             RELEASE_ASSERT(Options::addressOfOption(forceOSRExitToLLIntID) ==  &amp;Options::forceOSRExitToLLInt());</span>
<span class="line-added"> 550             RELEASE_ASSERT(Options::addressOfOptionDefault(forceOSRExitToLLIntID) ==  &amp;Options::forceOSRExitToLLIntDefault());</span>
<span class="line-added"> 551 </span>
<span class="line-added"> 552 #ifndef NDEBUG</span>
<span class="line-added"> 553             Config::enableRestrictedOptions();</span>
<span class="line-added"> 554 #endif</span>
 555             // Initialize each of the options with their default values:
<a name="42" id="anc42"></a><span class="line-modified"> 556 #define INIT_OPTION(type_, name_, defaultValue_, availability_, description_) { \</span>
<span class="line-modified"> 557                 auto value = defaultValue_; \</span>
<span class="line-modified"> 558                 name_() = value; \</span>
<span class="line-modified"> 559                 name_##Default() = value; \</span>
<span class="line-modified"> 560             }</span>
<span class="line-added"> 561             FOR_EACH_JSC_OPTION(INIT_OPTION)</span>
<span class="line-added"> 562 #undef INIT_OPTION</span>
 563 
 564             overrideDefaults();
 565 
 566             // Allow environment vars to override options if applicable.
 567             // The evn var should be the name of the option prefixed with
 568             // &quot;JSC_&quot;.
 569 #if PLATFORM(COCOA)
 570             bool hasBadOptions = false;
 571             for (char** envp = *_NSGetEnviron(); *envp; envp++) {
 572                 const char* env = *envp;
 573                 if (!strncmp(&quot;JSC_&quot;, env, 4)) {
 574                     if (!Options::setOption(&amp;env[4])) {
 575                         dataLog(&quot;ERROR: invalid option: &quot;, *envp, &quot;\n&quot;);
 576                         hasBadOptions = true;
 577                     }
 578                 }
 579             }
 580             if (hasBadOptions &amp;&amp; Options::validateOptions())
 581                 CRASH();
 582 #else // PLATFORM(COCOA)
<a name="43" id="anc43"></a><span class="line-modified"> 583 #define OVERRIDE_OPTION_WITH_HEURISTICS(type_, name_, defaultValue_, availability_, description_) \</span>
 584             overrideOptionWithHeuristic(name_(), name_##ID, &quot;JSC_&quot; #name_, Availability::availability_);
<a name="44" id="anc44"></a><span class="line-modified"> 585             FOR_EACH_JSC_OPTION(OVERRIDE_OPTION_WITH_HEURISTICS)</span>
<span class="line-modified"> 586 #undef OVERRIDE_OPTION_WITH_HEURISTICS</span>
 587 #endif // PLATFORM(COCOA)
 588 
<a name="45" id="anc45"></a><span class="line-modified"> 589 #define OVERRIDE_ALIASED_OPTION_WITH_HEURISTICS(aliasedName_, unaliasedName_, equivalence_) \</span>
 590             overrideAliasedOptionWithHeuristic(&quot;JSC_&quot; #aliasedName_);
<a name="46" id="anc46"></a><span class="line-modified"> 591             FOR_EACH_JSC_ALIASED_OPTION(OVERRIDE_ALIASED_OPTION_WITH_HEURISTICS)</span>
<span class="line-modified"> 592 #undef OVERRIDE_ALIASED_OPTION_WITH_HEURISTICS</span>
 593 
 594 #if 0
 595                 ; // Deconfuse editors that do auto indentation
 596 #endif
 597 
 598             correctOptions();
 599 
 600             recomputeDependentOptions();
 601 
 602             // Do range checks where needed and make corrections to the options:
 603             ASSERT(Options::thresholdForOptimizeAfterLongWarmUp() &gt;= Options::thresholdForOptimizeAfterWarmUp());
 604             ASSERT(Options::thresholdForOptimizeAfterWarmUp() &gt;= Options::thresholdForOptimizeSoon());
 605             ASSERT(Options::thresholdForOptimizeAfterWarmUp() &gt;= 0);
 606             ASSERT(Options::criticalGCMemoryThreshold() &gt; 0.0 &amp;&amp; Options::criticalGCMemoryThreshold() &lt; 1.0);
 607 
 608             dumpOptionsIfNeeded();
 609             ensureOptionsAreCoherent();
 610 
 611 #if HAVE(MACH_EXCEPTIONS)
 612             if (Options::useMachForExceptions())
 613                 handleSignalsWithMach();
 614 #endif
 615 
 616 #if ASAN_ENABLED &amp;&amp; OS(LINUX) &amp;&amp; ENABLE(WEBASSEMBLY_FAST_MEMORY)
 617             if (Options::useWebAssemblyFastMemory()) {
 618                 const char* asanOptions = getenv(&quot;ASAN_OPTIONS&quot;);
 619                 bool okToUseWebAssemblyFastMemory = asanOptions
 620                     &amp;&amp; (strstr(asanOptions, &quot;allow_user_segv_handler=1&quot;) || strstr(asanOptions, &quot;handle_segv=0&quot;));
 621                 if (!okToUseWebAssemblyFastMemory) {
 622                     dataLogLn(&quot;WARNING: ASAN interferes with JSC signal handlers; useWebAssemblyFastMemory will be disabled.&quot;);
 623                     Options::useWebAssemblyFastMemory() = false;
 624                 }
 625             }
 626 #endif
 627 
 628 #if CPU(X86_64) &amp;&amp; OS(DARWIN)
 629             Options::dumpZappedCellCrashData() =
 630                 (hwPhysicalCPUMax() &gt;= 4) &amp;&amp; (hwL3CacheSize() &gt;= static_cast&lt;int64_t&gt;(6 * MB));
 631 #endif
 632         });
 633 }
 634 
 635 void Options::dumpOptionsIfNeeded()
 636 {
 637     if (Options::dumpOptions()) {
 638         DumpLevel level = static_cast&lt;DumpLevel&gt;(Options::dumpOptions());
 639         if (level &gt; DumpLevel::Verbose)
 640             level = DumpLevel::Verbose;
 641 
 642         const char* title = nullptr;
 643         switch (level) {
 644         case DumpLevel::None:
 645             break;
 646         case DumpLevel::Overridden:
 647             title = &quot;Overridden JSC options:&quot;;
 648             break;
 649         case DumpLevel::All:
 650             title = &quot;All JSC options:&quot;;
 651             break;
 652         case DumpLevel::Verbose:
 653             title = &quot;All JSC options with descriptions:&quot;;
 654             break;
 655         }
 656 
 657         StringBuilder builder;
 658         dumpAllOptions(builder, level, title, nullptr, &quot;   &quot;, &quot;\n&quot;, DumpDefaults);
 659         dataLog(builder.toString());
 660     }
 661 }
 662 
 663 static bool isSeparator(char c)
 664 {
 665     return isASCIISpace(c) || (c == &#39;,&#39;);
 666 }
 667 
 668 bool Options::setOptions(const char* optionsStr)
 669 {
<a name="47" id="anc47"></a><span class="line-added"> 670     RELEASE_ASSERT(!g_jscConfig.isPermanentlyFrozen);</span>
 671     Vector&lt;char*&gt; options;
 672 
 673     size_t length = strlen(optionsStr);
 674     char* optionsStrCopy = WTF::fastStrDup(optionsStr);
 675     char* end = optionsStrCopy + length;
 676     char* p = optionsStrCopy;
 677 
 678     while (p &lt; end) {
 679         // Skip separators (white space or commas).
 680         while (p &lt; end &amp;&amp; isSeparator(*p))
 681             p++;
 682         if (p == end)
 683             break;
 684 
 685         char* optionStart = p;
 686         p = strstr(p, &quot;=&quot;);
 687         if (!p) {
 688             dataLogF(&quot;&#39;=&#39; not found in option string: %p\n&quot;, optionStart);
 689             WTF::fastFree(optionsStrCopy);
 690             return false;
 691         }
 692         p++;
 693 
 694         char* valueBegin = p;
 695         bool hasStringValue = false;
 696         const int minStringLength = 2; // The min is an empty string i.e. 2 double quotes.
 697         if ((p + minStringLength &lt; end) &amp;&amp; (*p == &#39;&quot;&#39;)) {
 698             p = strstr(p + 1, &quot;\&quot;&quot;);
 699             if (!p) {
 700                 dataLogF(&quot;Missing trailing &#39;\&quot;&#39; in option string: %p\n&quot;, optionStart);
 701                 WTF::fastFree(optionsStrCopy);
 702                 return false; // End of string not found.
 703             }
 704             hasStringValue = true;
 705         }
 706 
 707         // Find next separator (white space or commas).
 708         while (p &lt; end &amp;&amp; !isSeparator(*p))
 709             p++;
 710         if (!p)
 711             p = end; // No more &quot; &quot; separator. Hence, this is the last arg.
 712 
 713         // If we have a well-formed string value, strip the quotes.
 714         if (hasStringValue) {
 715             char* valueEnd = p;
 716             ASSERT((*valueBegin == &#39;&quot;&#39;) &amp;&amp; ((valueEnd - valueBegin) &gt;= minStringLength) &amp;&amp; (valueEnd[-1] == &#39;&quot;&#39;));
 717             memmove(valueBegin, valueBegin + 1, valueEnd - valueBegin - minStringLength);
 718             valueEnd[-minStringLength] = &#39;\0&#39;;
 719         }
 720 
 721         // Strip leading -- if present.
 722         if ((p -  optionStart &gt; 2) &amp;&amp; optionStart[0] == &#39;-&#39; &amp;&amp; optionStart[1] == &#39;-&#39;)
 723             optionStart += 2;
 724 
 725         *p++ = &#39;\0&#39;;
 726         options.append(optionStart);
 727     }
 728 
 729     bool success = true;
 730     for (auto&amp; option : options) {
 731         bool optionSuccess = setOption(option);
 732         if (!optionSuccess) {
 733             dataLogF(&quot;Failed to set option : %s\n&quot;, option);
 734             success = false;
 735         }
 736     }
 737 
 738     correctOptions();
 739 
 740     recomputeDependentOptions();
 741 
 742     dumpOptionsIfNeeded();
 743 
 744     ensureOptionsAreCoherent();
 745 
 746     WTF::fastFree(optionsStrCopy);
 747 
 748     return success;
 749 }
 750 
 751 // Parses a single command line option in the format &quot;&lt;optionName&gt;=&lt;value&gt;&quot;
 752 // (no spaces allowed) and set the specified option if appropriate.
 753 bool Options::setOptionWithoutAlias(const char* arg)
 754 {
 755     // arg should look like this:
 756     //   &lt;jscOptionName&gt;=&lt;appropriate value&gt;
 757     const char* equalStr = strchr(arg, &#39;=&#39;);
 758     if (!equalStr)
 759         return false;
 760 
 761     const char* valueStr = equalStr + 1;
 762 
<a name="48" id="anc48"></a><span class="line-modified"> 763     // For each option, check if the specified arg is a match. If so, set the arg</span>
 764     // if the value makes sense. Otherwise, move on to checking the next option.
<a name="49" id="anc49"></a><span class="line-modified"> 765 #define SET_OPTION_IF_MATCH(type_, name_, defaultValue_, availability_, description_) \</span>
 766     if (strlen(#name_) == static_cast&lt;size_t&gt;(equalStr - arg)      \
 767         &amp;&amp; !strncmp(arg, #name_, equalStr - arg)) {                \
 768         if (Availability::availability_ != Availability::Normal     \
 769             &amp;&amp; !isAvailable(name_##ID, Availability::availability_)) \
 770             return false;                                          \
<a name="50" id="anc50"></a><span class="line-modified"> 771         Optional&lt;OptionsStorage::type_&gt; value;                     \</span>
<span class="line-modified"> 772         value = parse&lt;OptionsStorage::type_&gt;(valueStr);            \</span>
<span class="line-modified"> 773         if (value) {                                               \</span>
<span class="line-modified"> 774             name_() = value.value();                               \</span>

 775             correctOptions();                                      \
 776             recomputeDependentOptions();                           \
 777             return true;                                           \
 778         }                                                          \
 779         return false;                                              \
 780     }
 781 
<a name="51" id="anc51"></a><span class="line-modified"> 782     FOR_EACH_JSC_OPTION(SET_OPTION_IF_MATCH)</span>
<span class="line-modified"> 783 #undef SET_OPTION_IF_MATCH</span>
 784 
 785     return false; // No option matched.
 786 }
 787 
<a name="52" id="anc52"></a><span class="line-modified"> 788 static const char* invertBoolOptionValue(const char* valueStr)</span>
 789 {
<a name="53" id="anc53"></a><span class="line-modified"> 790     Optional&lt;OptionsStorage::Bool&gt; value = parse&lt;OptionsStorage::Bool&gt;(valueStr);</span>
<span class="line-modified"> 791     if (!value)</span>
<span class="line-modified"> 792         return nullptr;</span>
<span class="line-modified"> 793     return value.value() ? &quot;false&quot; : &quot;true&quot;;</span>

 794 }
 795 
 796 
 797 bool Options::setAliasedOption(const char* arg)
 798 {
 799     // arg should look like this:
 800     //   &lt;jscOptionName&gt;=&lt;appropriate value&gt;
 801     const char* equalStr = strchr(arg, &#39;=&#39;);
 802     if (!equalStr)
 803         return false;
 804 
 805     IGNORE_WARNINGS_BEGIN(&quot;tautological-compare&quot;)
 806 
 807     // For each option, check if the specify arg is a match. If so, set the arg
 808     // if the value makes sense. Otherwise, move on to checking the next option.
 809 #define FOR_EACH_OPTION(aliasedName_, unaliasedName_, equivalence) \
 810     if (strlen(#aliasedName_) == static_cast&lt;size_t&gt;(equalStr - arg)    \
 811         &amp;&amp; !strncmp(arg, #aliasedName_, equalStr - arg)) {              \
 812         String unaliasedOption(#unaliasedName_);                        \
 813         if (equivalence == SameOption)                                  \
 814             unaliasedOption = unaliasedOption + equalStr;               \
 815         else {                                                          \
 816             ASSERT(equivalence == InvertedOption);                      \
<a name="54" id="anc54"></a><span class="line-modified"> 817             auto* invertedValueStr = invertBoolOptionValue(equalStr + 1); \</span>
<span class="line-modified"> 818             if (!invertedValueStr)                                      \</span>
 819                 return false;                                           \
 820             unaliasedOption = unaliasedOption + &quot;=&quot; + invertedValueStr; \
 821         }                                                               \
 822         return setOptionWithoutAlias(unaliasedOption.utf8().data());   \
 823     }
 824 
<a name="55" id="anc55"></a><span class="line-modified"> 825     FOR_EACH_JSC_ALIASED_OPTION(FOR_EACH_OPTION)</span>
 826 #undef FOR_EACH_OPTION
 827 
 828     IGNORE_WARNINGS_END
 829 
 830     return false; // No option matched.
 831 }
 832 
 833 bool Options::setOption(const char* arg)
 834 {
 835     bool success = setOptionWithoutAlias(arg);
 836     if (success)
 837         return true;
 838     return setAliasedOption(arg);
 839 }
 840 
 841 
 842 void Options::dumpAllOptions(StringBuilder&amp; builder, DumpLevel level, const char* title,
 843     const char* separator, const char* optionHeader, const char* optionFooter, DumpDefaultsOption dumpDefaultsOption)
 844 {
 845     if (title) {
 846         builder.append(title);
 847         builder.append(&#39;\n&#39;);
 848     }
 849 
<a name="56" id="anc56"></a><span class="line-modified"> 850     for (size_t id = 0; id &lt; NumberOfOptions; id++) {</span>
 851         if (separator &amp;&amp; id)
 852             builder.append(separator);
 853         dumpOption(builder, level, static_cast&lt;ID&gt;(id), optionHeader, optionFooter, dumpDefaultsOption);
 854     }
 855 }
 856 
 857 void Options::dumpAllOptionsInALine(StringBuilder&amp; builder)
 858 {
 859     dumpAllOptions(builder, DumpLevel::All, nullptr, &quot; &quot;, nullptr, nullptr, DontDumpDefaults);
 860 }
 861 
 862 void Options::dumpAllOptions(FILE* stream, DumpLevel level, const char* title)
 863 {
 864     StringBuilder builder;
 865     dumpAllOptions(builder, level, title, nullptr, &quot;   &quot;, &quot;\n&quot;, DumpDefaults);
 866     fprintf(stream, &quot;%s&quot;, builder.toString().utf8().data());
 867 }
 868 
<a name="57" id="anc57"></a><span class="line-added"> 869 struct OptionReader {</span>
<span class="line-added"> 870     class Option {</span>
<span class="line-added"> 871     public:</span>
<span class="line-added"> 872         void dump(StringBuilder&amp;) const;</span>
<span class="line-added"> 873 </span>
<span class="line-added"> 874         bool operator==(const Option&amp; other) const;</span>
<span class="line-added"> 875         bool operator!=(const Option&amp; other) const { return !(*this == other); }</span>
<span class="line-added"> 876 </span>
<span class="line-added"> 877         const char* name() const { return Options::s_constMetaData[m_id].name; }</span>
<span class="line-added"> 878         const char* description() const { return Options::s_constMetaData[m_id].description; }</span>
<span class="line-added"> 879         Options::Type type() const { return Options::s_constMetaData[m_id].type; }</span>
<span class="line-added"> 880         Options::Availability availability() const { return Options::s_constMetaData[m_id].availability; }</span>
<span class="line-added"> 881         bool isOverridden() const { return *this != OptionReader::defaultFor(m_id); }</span>
<span class="line-added"> 882 </span>
<span class="line-added"> 883     private:</span>
<span class="line-added"> 884         Option(Options::ID id, void* addressOfValue)</span>
<span class="line-added"> 885             : m_id(id)</span>
<span class="line-added"> 886         {</span>
<span class="line-added"> 887             initValue(addressOfValue);</span>
<span class="line-added"> 888         }</span>
<span class="line-added"> 889 </span>
<span class="line-added"> 890         void initValue(void* addressOfValue);</span>
<span class="line-added"> 891 </span>
<span class="line-added"> 892         Options::ID m_id;</span>
<span class="line-added"> 893         union {</span>
<span class="line-added"> 894             bool m_bool;</span>
<span class="line-added"> 895             unsigned m_unsigned;</span>
<span class="line-added"> 896             double m_double;</span>
<span class="line-added"> 897             int32_t m_int32;</span>
<span class="line-added"> 898             size_t m_size;</span>
<span class="line-added"> 899             OptionRange m_optionRange;</span>
<span class="line-added"> 900             const char* m_optionString;</span>
<span class="line-added"> 901             GCLogging::Level m_gcLogLevel;</span>
<span class="line-added"> 902         };</span>
<span class="line-added"> 903 </span>
<span class="line-added"> 904         friend struct OptionReader;</span>
<span class="line-added"> 905     };</span>
<span class="line-added"> 906 </span>
<span class="line-added"> 907     static const Option optionFor(Options::ID);</span>
<span class="line-added"> 908     static const Option defaultFor(Options::ID);</span>
<span class="line-added"> 909 };</span>
<span class="line-added"> 910 </span>
 911 void Options::dumpOption(StringBuilder&amp; builder, DumpLevel level, Options::ID id,
 912     const char* header, const char* footer, DumpDefaultsOption dumpDefaultsOption)
 913 {
<a name="58" id="anc58"></a><span class="line-modified"> 914     RELEASE_ASSERT(static_cast&lt;size_t&gt;(id) &lt; NumberOfOptions);</span>

 915 
<a name="59" id="anc59"></a><span class="line-modified"> 916     auto option = OptionReader::optionFor(id);</span>
 917     Availability availability = option.availability();
 918     if (availability != Availability::Normal &amp;&amp; !isAvailable(id, availability))
 919         return;
 920 
 921     bool wasOverridden = option.isOverridden();
 922     bool needsDescription = (level == DumpLevel::Verbose &amp;&amp; option.description());
 923 
 924     if (level == DumpLevel::Overridden &amp;&amp; !wasOverridden)
 925         return;
 926 
 927     if (header)
 928         builder.append(header);
 929     builder.append(option.name(), &#39;=&#39;);
 930     option.dump(builder);
 931 
 932     if (wasOverridden &amp;&amp; (dumpDefaultsOption == DumpDefaults)) {
<a name="60" id="anc60"></a><span class="line-added"> 933         auto defaultOption = OptionReader::defaultFor(id);</span>
 934         builder.appendLiteral(&quot; (default: &quot;);
<a name="61" id="anc61"></a><span class="line-modified"> 935         defaultOption.dump(builder);</span>
 936         builder.appendLiteral(&quot;)&quot;);
 937     }
 938 
 939     if (needsDescription)
 940         builder.append(&quot;   ... &quot;, option.description());
 941 
 942     builder.append(footer);
 943 }
 944 
 945 void Options::ensureOptionsAreCoherent()
 946 {
 947     bool coherent = true;
 948     if (!(useLLInt() || useJIT())) {
 949         coherent = false;
 950         dataLog(&quot;INCOHERENT OPTIONS: at least one of useLLInt or useJIT must be true\n&quot;);
 951     }
 952     if (!coherent)
 953         CRASH();
 954 }
 955 
<a name="62" id="anc62"></a><span class="line-modified"> 956 const OptionReader::Option OptionReader::optionFor(Options::ID id)</span>
<span class="line-added"> 957 {</span>
<span class="line-added"> 958     return Option(id, Options::addressOfOption(id));</span>
<span class="line-added"> 959 }</span>
<span class="line-added"> 960 </span>
<span class="line-added"> 961 const OptionReader::Option OptionReader::defaultFor(Options::ID id)</span>
<span class="line-added"> 962 {</span>
<span class="line-added"> 963     return Option(id, Options::addressOfOptionDefault(id));</span>
<span class="line-added"> 964 }</span>
<span class="line-added"> 965 </span>
<span class="line-added"> 966 void OptionReader::Option::initValue(void* addressOfValue)</span>
<span class="line-added"> 967 {</span>
<span class="line-added"> 968     Options::Type type = Options::s_constMetaData[m_id].type;</span>
<span class="line-added"> 969     switch (type) {</span>
<span class="line-added"> 970     case Options::Type::Bool:</span>
<span class="line-added"> 971         memcpy(&amp;m_bool, addressOfValue, sizeof(OptionsStorage::Bool));</span>
<span class="line-added"> 972         break;</span>
<span class="line-added"> 973     case Options::Type::Unsigned:</span>
<span class="line-added"> 974         memcpy(&amp;m_unsigned, addressOfValue, sizeof(OptionsStorage::Unsigned));</span>
<span class="line-added"> 975         break;</span>
<span class="line-added"> 976     case Options::Type::Double:</span>
<span class="line-added"> 977         memcpy(&amp;m_double, addressOfValue, sizeof(OptionsStorage::Double));</span>
<span class="line-added"> 978         break;</span>
<span class="line-added"> 979     case Options::Type::Int32:</span>
<span class="line-added"> 980         memcpy(&amp;m_int32, addressOfValue, sizeof(OptionsStorage::Int32));</span>
<span class="line-added"> 981         break;</span>
<span class="line-added"> 982     case Options::Type::Size:</span>
<span class="line-added"> 983         memcpy(&amp;m_size, addressOfValue, sizeof(OptionsStorage::Size));</span>
<span class="line-added"> 984         break;</span>
<span class="line-added"> 985     case Options::Type::OptionRange:</span>
<span class="line-added"> 986         memcpy(&amp;m_optionRange, addressOfValue, sizeof(OptionsStorage::OptionRange));</span>
<span class="line-added"> 987         break;</span>
<span class="line-added"> 988     case Options::Type::OptionString:</span>
<span class="line-added"> 989         memcpy(&amp;m_optionString, addressOfValue, sizeof(OptionsStorage::OptionString));</span>
<span class="line-added"> 990         break;</span>
<span class="line-added"> 991     case Options::Type::GCLogLevel:</span>
<span class="line-added"> 992         memcpy(&amp;m_gcLogLevel, addressOfValue, sizeof(OptionsStorage::GCLogLevel));</span>
<span class="line-added"> 993         break;</span>
<span class="line-added"> 994     }</span>
<span class="line-added"> 995 }</span>
<span class="line-added"> 996 </span>
<span class="line-added"> 997 void OptionReader::Option::dump(StringBuilder&amp; builder) const</span>
 998 {
 999     switch (type()) {
<a name="63" id="anc63"></a><span class="line-modified">1000     case Options::Type::Bool:</span>
<span class="line-modified">1001         builder.append(m_bool ? &quot;true&quot; : &quot;false&quot;);</span>
1002         break;
<a name="64" id="anc64"></a><span class="line-modified">1003     case Options::Type::Unsigned:</span>
<span class="line-modified">1004         builder.appendNumber(m_unsigned);</span>
1005         break;
<a name="65" id="anc65"></a><span class="line-modified">1006     case Options::Type::Size:</span>
<span class="line-modified">1007         builder.appendNumber(m_size);</span>
1008         break;
<a name="66" id="anc66"></a><span class="line-modified">1009     case Options::Type::Double:</span>
<span class="line-modified">1010         builder.append(m_double);</span>
1011         break;
<a name="67" id="anc67"></a><span class="line-modified">1012     case Options::Type::Int32:</span>
<span class="line-modified">1013         builder.appendNumber(m_int32);</span>
1014         break;
<a name="68" id="anc68"></a><span class="line-modified">1015     case Options::Type::OptionRange:</span>
<span class="line-modified">1016         builder.append(m_optionRange.rangeString());</span>
1017         break;
<a name="69" id="anc69"></a><span class="line-modified">1018     case Options::Type::OptionString: {</span>
<span class="line-modified">1019         const char* option = m_optionString;</span>
1020         if (!option)
1021             option = &quot;&quot;;
1022         builder.append(&#39;&quot;&#39;);
1023         builder.append(option);
1024         builder.append(&#39;&quot;&#39;);
1025         break;
1026     }
<a name="70" id="anc70"></a><span class="line-modified">1027     case Options::Type::GCLogLevel: {</span>
<span class="line-modified">1028         builder.append(GCLogging::levelAsString(m_gcLogLevel));</span>
1029         break;
1030     }
1031     }
1032 }
1033 
<a name="71" id="anc71"></a><span class="line-modified">1034 bool OptionReader::Option::operator==(const Option&amp; other) const</span>
1035 {
<a name="72" id="anc72"></a><span class="line-added">1036     ASSERT(type() == other.type());</span>
1037     switch (type()) {
<a name="73" id="anc73"></a><span class="line-modified">1038     case Options::Type::Bool:</span>
<span class="line-modified">1039         return m_bool == other.m_bool;</span>
<span class="line-modified">1040     case Options::Type::Unsigned:</span>
<span class="line-modified">1041         return m_unsigned == other.m_unsigned;</span>
<span class="line-modified">1042     case Options::Type::Size:</span>
<span class="line-modified">1043         return m_size == other.m_size;</span>
<span class="line-modified">1044     case Options::Type::Double:</span>
<span class="line-modified">1045         return (m_double == other.m_double) || (std::isnan(m_double) &amp;&amp; std::isnan(other.m_double));</span>
<span class="line-modified">1046     case Options::Type::Int32:</span>
<span class="line-modified">1047         return m_int32 == other.m_int32;</span>
<span class="line-modified">1048     case Options::Type::OptionRange:</span>
<span class="line-modified">1049         return m_optionRange.rangeString() == other.m_optionRange.rangeString();</span>
<span class="line-modified">1050     case Options::Type::OptionString:</span>
<span class="line-modified">1051         return (m_optionString == other.m_optionString)</span>
<span class="line-modified">1052             || (m_optionString &amp;&amp; other.m_optionString &amp;&amp; !strcmp(m_optionString, other.m_optionString));</span>
<span class="line-modified">1053     case Options::Type::GCLogLevel:</span>
<span class="line-modified">1054         return m_gcLogLevel == other.m_gcLogLevel;</span>
1055     }
1056     return false;
1057 }
1058 
1059 } // namespace JSC
<a name="74" id="anc74"></a>
<a name="75" id="anc75"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="75" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PropertyCondition.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PreciseJumpTargetsInlines.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PropertyCondition.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/PropertyCondition.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -52,10 +52,13 @@</span>
          out.print(m_header.type(), &quot; of &quot;, m_header.pointer(), &quot; with prototype &quot;, inContext(JSValue(prototype()), context));
          return;
      case Equivalence:
          out.print(m_header.type(), &quot; of &quot;, m_header.pointer(), &quot; with &quot;, inContext(requiredValue(), context));
          return;
<span class="udiff-line-added">+     case CustomFunctionEquivalence:</span>
<span class="udiff-line-added">+         out.print(m_header.type(), &quot; of &quot;, m_header.pointer());</span>
<span class="udiff-line-added">+         return;</span>
      case HasPrototype:
          out.print(m_header.type(), &quot; with prototype &quot;, inContext(JSValue(prototype()), context));
          return;
      }
      RELEASE_ASSERT_NOT_REACHED();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -84,10 +87,11 @@</span>
      switch (m_header.type()) {
      case Presence:
      case Absence:
      case AbsenceOfSetEffect:
      case Equivalence:
<span class="udiff-line-added">+     case CustomFunctionEquivalence:</span>
          if (!structure-&gt;propertyAccessesAreCacheable()) {
              if (PropertyConditionInternal::verbose)
                  dataLog(&quot;Invalid because property accesses are not cacheable.\n&quot;);
              return false;
          }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -246,11 +250,17 @@</span>
              }
              return false;
          }
  
          return true;
<span class="udiff-line-modified-removed">-     } }</span>
<span class="udiff-line-modified-added">+     }</span>
<span class="udiff-line-added">+     case CustomFunctionEquivalence: {</span>
<span class="udiff-line-added">+         if (structure-&gt;staticPropertiesReified())</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         return !!structure-&gt;findPropertyHashEntry(uid());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     }</span>
  
      RELEASE_ASSERT_NOT_REACHED();
      return false;
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -261,10 +271,11 @@</span>
  
      switch (m_header.type()) {
      case Presence:
      case Absence:
      case Equivalence:
<span class="udiff-line-added">+     case CustomFunctionEquivalence:</span>
          return structure-&gt;needImpurePropertyWatchpoint();
      case AbsenceOfSetEffect:
      case HasPrototype:
          return false;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -286,10 +297,11 @@</span>
          if (structure-&gt;typeInfo().getOwnPropertySlotIsImpure() || structure-&gt;typeInfo().getOwnPropertySlotIsImpureForPropertyAbsence())
              return false;
          break;
      case Presence:
      case Equivalence:
<span class="udiff-line-added">+     case CustomFunctionEquivalence:</span>
          if (structure-&gt;typeInfo().getOwnPropertySlotIsImpure())
              return false;
          break;
      default:
          break;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -328,10 +340,25 @@</span>
              return false;
  
          break;
      }
  
<span class="udiff-line-added">+     case CustomFunctionEquivalence: {</span>
<span class="udiff-line-added">+         // We just use the structure transition watchpoint for this. A structure S starts</span>
<span class="udiff-line-added">+         // off with a property P in the static property hash table. If S transitions to</span>
<span class="udiff-line-added">+         // S&#39;, either P remains in the static property table or not. If not, then we</span>
<span class="udiff-line-added">+         // are no longer valid. So the above check of transitionWatchpointSetHasBeenInvalidated</span>
<span class="udiff-line-added">+         // is sufficient.</span>
<span class="udiff-line-added">+         //</span>
<span class="udiff-line-added">+         // We could make this smarter in the future, since we sometimes reify static properties.</span>
<span class="udiff-line-added">+         // We could make this adapt to looking at the object&#39;s storage for such reified custom</span>
<span class="udiff-line-added">+         // functions, but we don&#39;t do that right now. We just allow this property condition to</span>
<span class="udiff-line-added">+         // invalidate and create an Equivalence watchpoint for the materialized property sometime</span>
<span class="udiff-line-added">+         // in the future.</span>
<span class="udiff-line-added">+         break;</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+ </span>
      default:
          break;
      }
  
      return true;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -349,24 +376,10 @@</span>
  {
      return isStillValid(structure, base)
          &amp;&amp; isWatchableWhenValid(structure, effort);
  }
  
<span class="udiff-line-removed">- bool PropertyCondition::isStillLive(VM&amp; vm) const</span>
<span class="udiff-line-removed">- {</span>
<span class="udiff-line-removed">-     if (hasPrototype() &amp;&amp; prototype() &amp;&amp; !vm.heap.isMarked(prototype()))</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     if (hasRequiredValue()</span>
<span class="udiff-line-removed">-         &amp;&amp; requiredValue()</span>
<span class="udiff-line-removed">-         &amp;&amp; requiredValue().isCell()</span>
<span class="udiff-line-removed">-         &amp;&amp; !vm.heap.isMarked(requiredValue().asCell()))</span>
<span class="udiff-line-removed">-         return false;</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     return true;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  void PropertyCondition::validateReferences(const TrackedReferences&amp; tracked) const
  {
      if (hasPrototype())
          tracked.check(prototype());
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -415,10 +428,13 @@</span>
          out.print(&quot;Absence&quot;);
          return;
      case JSC::PropertyCondition::Equivalence:
          out.print(&quot;Equivalence&quot;);
          return;
<span class="udiff-line-added">+     case JSC::PropertyCondition::CustomFunctionEquivalence:</span>
<span class="udiff-line-added">+         out.print(&quot;CustomFunctionEquivalence&quot;);</span>
<span class="udiff-line-added">+         return;</span>
      case JSC::PropertyCondition::HasPrototype:
          out.print(&quot;HasPrototype&quot;);
          return;
      }
      RELEASE_ASSERT_NOT_REACHED();
</pre>
<center><a href="PreciseJumpTargetsInlines.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PropertyCondition.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
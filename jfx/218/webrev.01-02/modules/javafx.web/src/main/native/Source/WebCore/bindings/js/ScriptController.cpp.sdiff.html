<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScheduledAction.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScriptController.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/ScriptController.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Lesser General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;ScriptController.h&quot;
 23 
 24 #include &quot;BridgeJSC.h&quot;
 25 #include &quot;CachedScriptFetcher.h&quot;
 26 #include &quot;CommonVM.h&quot;
 27 #include &quot;ContentSecurityPolicy.h&quot;
 28 #include &quot;CustomHeaderFields.h&quot;

 29 #include &quot;DocumentLoader.h&quot;
 30 #include &quot;Event.h&quot;
 31 #include &quot;Frame.h&quot;
 32 #include &quot;FrameLoader.h&quot;
 33 #include &quot;FrameLoaderClient.h&quot;
 34 #include &quot;HTMLPlugInElement.h&quot;
 35 #include &quot;InspectorInstrumentation.h&quot;
 36 #include &quot;JSDOMBindingSecurity.h&quot;
 37 #include &quot;JSDOMExceptionHandling.h&quot;
 38 #include &quot;JSDOMWindow.h&quot;
 39 #include &quot;JSDocument.h&quot;
 40 #include &quot;JSExecState.h&quot;
 41 #include &quot;LoadableModuleScript.h&quot;
 42 #include &quot;ModuleFetchFailureKind.h&quot;
 43 #include &quot;ModuleFetchParameters.h&quot;
 44 #include &quot;NP_jsobject.h&quot;
 45 #include &quot;Page.h&quot;
 46 #include &quot;PageConsoleClient.h&quot;
 47 #include &quot;PageGroup.h&quot;
 48 #include &quot;PaymentCoordinator.h&quot;
 49 #include &quot;PluginViewBase.h&quot;

 50 #include &quot;RuntimeApplicationChecks.h&quot;
 51 #include &quot;ScriptDisallowedScope.h&quot;
 52 #include &quot;ScriptSourceCode.h&quot;
 53 #include &quot;ScriptableDocumentParser.h&quot;
 54 #include &quot;Settings.h&quot;
 55 #include &quot;UserGestureIndicator.h&quot;
 56 #include &quot;WebCoreJSClientData.h&quot;
 57 #include &quot;npruntime_impl.h&quot;
 58 #include &quot;runtime_root.h&quot;
 59 #include &lt;JavaScriptCore/Debugger.h&gt;

 60 #include &lt;JavaScriptCore/InitializeThreading.h&gt;
 61 #include &lt;JavaScriptCore/JSFunction.h&gt;
 62 #include &lt;JavaScriptCore/JSInternalPromise.h&gt;
 63 #include &lt;JavaScriptCore/JSLock.h&gt;
 64 #include &lt;JavaScriptCore/JSModuleRecord.h&gt;
 65 #include &lt;JavaScriptCore/JSNativeStdFunction.h&gt;
 66 #include &lt;JavaScriptCore/JSScriptFetchParameters.h&gt;
 67 #include &lt;JavaScriptCore/JSScriptFetcher.h&gt;
 68 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 69 #include &lt;JavaScriptCore/StrongInlines.h&gt;

 70 #include &lt;wtf/SetForScope.h&gt;

 71 #include &lt;wtf/Threading.h&gt;
 72 #include &lt;wtf/text/TextPosition.h&gt;
 73 
 74 namespace WebCore {
 75 using namespace JSC;
 76 
 77 void ScriptController::initializeThreading()
 78 {
 79 #if !PLATFORM(IOS_FAMILY)
 80     JSC::initializeThreading();
 81     WTF::initializeMainThread();
 82 #endif
 83 }
 84 
 85 ScriptController::ScriptController(Frame&amp; frame)
 86     : m_frame(frame)
 87     , m_sourceURL(0)
 88     , m_paused(false)
 89 #if ENABLE(NETSCAPE_PLUGIN_API)
 90     , m_windowScriptNPObject(0)
 91 #endif
 92 #if PLATFORM(COCOA)
 93     , m_windowScriptObject(0)
 94 #endif
 95 {
 96 }
 97 
 98 ScriptController::~ScriptController()
 99 {
100     disconnectPlatformScriptObjects();
101 
102     if (m_cacheableBindingRootObject) {
103         JSLockHolder lock(commonVM());
104         m_cacheableBindingRootObject-&gt;invalidate();
105         m_cacheableBindingRootObject = nullptr;
106     }
107 }
108 
<span class="line-modified">109 JSValue ScriptController::evaluateInWorld(const ScriptSourceCode&amp; sourceCode, DOMWrapperWorld&amp; world, ExceptionDetails* exceptionDetails)</span>






110 {
111     JSLockHolder lock(world.vm());
112 
113     const SourceCode&amp; jsSourceCode = sourceCode.jsSourceCode();
114     String sourceURL = jsSourceCode.provider()-&gt;url();
115 
116     // evaluate code. Returns the JS return value or 0
117     // if there was none, an error occurred or the type couldn&#39;t be converted.
118 
119     // inlineCode is true for &lt;a href=&quot;javascript:doSomething()&quot;&gt;
120     // and false for &lt;script&gt;doSomething()&lt;/script&gt;. Check if it has the
121     // expected value in all cases.
122     // See smart window.open policy for where this is used.
123     auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">124     auto&amp; exec = *proxy.window()-&gt;globalExec();</span>
125     const String* savedSourceURL = m_sourceURL;
126     m_sourceURL = &amp;sourceURL;
127 
128     Ref&lt;Frame&gt; protector(m_frame);
129 
<span class="line-modified">130     InspectorInstrumentationCookie cookie = InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, sourceCode.startLine(), sourceCode.startColumn());</span>
131 
132     NakedPtr&lt;JSC::Exception&gt; evaluationException;
<span class="line-modified">133     JSValue returnValue = JSExecState::profiledEvaluate(&amp;exec, JSC::ProfilingReason::Other, jsSourceCode, &amp;proxy, evaluationException);</span>
134 
<span class="line-modified">135     InspectorInstrumentation::didEvaluateScript(cookie, m_frame);</span>
136 

137     if (evaluationException) {
<span class="line-modified">138         reportException(&amp;exec, evaluationException, sourceCode.cachedScript(), exceptionDetails);</span>
<span class="line-modified">139         m_sourceURL = savedSourceURL;</span>
<span class="line-modified">140         return { };</span>
141     }
142 
143     m_sourceURL = savedSourceURL;



144     return returnValue;
145 }
146 
<span class="line-modified">147 JSValue ScriptController::evaluate(const ScriptSourceCode&amp; sourceCode, ExceptionDetails* exceptionDetails)</span>
148 {
<span class="line-modified">149     return evaluateInWorld(sourceCode, mainThreadNormalWorld(), exceptionDetails);</span>
150 }
151 
152 void ScriptController::loadModuleScriptInWorld(LoadableModuleScript&amp; moduleScript, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp; topLevelFetchParameters, DOMWrapperWorld&amp; world)
153 {
154     JSLockHolder lock(world.vm());
155 
156     auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">157     auto&amp; state = *proxy.window()-&gt;globalExec();</span>
158 
<span class="line-modified">159     auto&amp; promise = JSExecState::loadModule(state, moduleName, JSC::JSScriptFetchParameters::create(state.vm(), WTFMove(topLevelFetchParameters)), JSC::JSScriptFetcher::create(state.vm(), { &amp;moduleScript }));</span>
160     setupModuleScriptHandlers(moduleScript, promise, world);
161 }
162 
163 void ScriptController::loadModuleScript(LoadableModuleScript&amp; moduleScript, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp; topLevelFetchParameters)
164 {
165     loadModuleScriptInWorld(moduleScript, moduleName, WTFMove(topLevelFetchParameters), mainThreadNormalWorld());
166 }
167 
168 void ScriptController::loadModuleScriptInWorld(LoadableModuleScript&amp; moduleScript, const ScriptSourceCode&amp; sourceCode, DOMWrapperWorld&amp; world)
169 {
170     JSLockHolder lock(world.vm());
171 
172     auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">173     auto&amp; state = *proxy.window()-&gt;globalExec();</span>
174 
<span class="line-modified">175     auto&amp; promise = JSExecState::loadModule(state, sourceCode.jsSourceCode(), JSC::JSScriptFetcher::create(state.vm(), { &amp;moduleScript }));</span>
176     setupModuleScriptHandlers(moduleScript, promise, world);
177 }
178 
179 void ScriptController::loadModuleScript(LoadableModuleScript&amp; moduleScript, const ScriptSourceCode&amp; sourceCode)
180 {
181     loadModuleScriptInWorld(moduleScript, sourceCode, mainThreadNormalWorld());
182 }
183 
184 JSC::JSValue ScriptController::linkAndEvaluateModuleScriptInWorld(LoadableModuleScript&amp; moduleScript, DOMWrapperWorld&amp; world)
185 {
186     JSC::VM&amp; vm = world.vm();
187     JSLockHolder lock(vm);
188 
189     auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">190     auto&amp; state = *proxy.window()-&gt;globalExec();</span>
191 
192     // FIXME: Preventing Frame from being destroyed is essentially unnecessary.
193     // https://bugs.webkit.org/show_bug.cgi?id=164763
194     Ref&lt;Frame&gt; protector(m_frame);
195 
196     NakedPtr&lt;JSC::Exception&gt; evaluationException;
<span class="line-modified">197     auto returnValue = JSExecState::linkAndEvaluateModule(state, Identifier::fromUid(vm, moduleScript.moduleKey()), jsUndefined(), evaluationException);</span>
198     if (evaluationException) {
199         // FIXME: Give a chance to dump the stack trace if the &quot;crossorigin&quot; attribute allows.
200         // https://bugs.webkit.org/show_bug.cgi?id=164539
<span class="line-modified">201         reportException(&amp;state, evaluationException, nullptr);</span>
202         return jsUndefined();
203     }
204     return returnValue;
205 }
206 
207 JSC::JSValue ScriptController::linkAndEvaluateModuleScript(LoadableModuleScript&amp; moduleScript)
208 {
209     return linkAndEvaluateModuleScriptInWorld(moduleScript, mainThreadNormalWorld());
210 }
211 
212 JSC::JSValue ScriptController::evaluateModule(const URL&amp; sourceURL, JSModuleRecord&amp; moduleRecord, DOMWrapperWorld&amp; world)
213 {
214     JSLockHolder lock(world.vm());
215 
216     const auto&amp; jsSourceCode = moduleRecord.sourceCode();
217 
218     auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">219     auto&amp; state = *proxy.window()-&gt;globalExec();</span>
220     SetForScope&lt;const String*&gt; sourceURLScope(m_sourceURL, &amp;sourceURL.string());
221 
222     Ref&lt;Frame&gt; protector(m_frame);
223 
<span class="line-modified">224     auto cookie = InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, jsSourceCode.firstLine().oneBasedInt(), jsSourceCode.startColumn().oneBasedInt());</span>
<span class="line-modified">225 </span>
<span class="line-modified">226     auto returnValue = moduleRecord.evaluate(&amp;state);</span>
<span class="line-removed">227     InspectorInstrumentation::didEvaluateScript(cookie, m_frame);</span>
228 
229     return returnValue;
230 }
231 
232 JSC::JSValue ScriptController::evaluateModule(const URL&amp; sourceURL, JSModuleRecord&amp; moduleRecord)
233 {
234     return evaluateModule(sourceURL, moduleRecord, mainThreadNormalWorld());
235 }
236 
<span class="line-modified">237 Ref&lt;DOMWrapperWorld&gt; ScriptController::createWorld()</span>
238 {
<span class="line-modified">239     return DOMWrapperWorld::create(commonVM());</span>
240 }
241 
242 void ScriptController::getAllWorlds(Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt;&amp; worlds)
243 {
244     static_cast&lt;JSVMClientData*&gt;(commonVM().clientData)-&gt;getAllWorlds(worlds);
245 }
246 
247 void ScriptController::initScriptForWindowProxy(JSWindowProxy&amp; windowProxy)
248 {
249     auto&amp; world = windowProxy.world();
250 
251     jsCast&lt;JSDOMWindow*&gt;(windowProxy.window())-&gt;updateDocument();
252 
253     if (Document* document = m_frame.document())
254         document-&gt;contentSecurityPolicy()-&gt;didCreateWindowProxy(windowProxy);
255 
256     if (Page* page = m_frame.page()) {
257         windowProxy.attachDebugger(page-&gt;debugger());
258         windowProxy.window()-&gt;setProfileGroup(page-&gt;group().identifier());
259         windowProxy.window()-&gt;setConsoleClient(&amp;page-&gt;console());
260     }
261 
262     m_frame.loader().dispatchDidClearWindowObjectInWorld(world);
263 }
264 
<span class="line-modified">265 static Identifier jsValueToModuleKey(ExecState* exec, JSValue value)</span>
266 {
267     if (value.isSymbol())
268         return Identifier::fromUid(jsCast&lt;Symbol*&gt;(value)-&gt;privateName());
269     ASSERT(value.isString());
<span class="line-modified">270     return asString(value)-&gt;toIdentifier(exec);</span>
271 }
272 
273 void ScriptController::setupModuleScriptHandlers(LoadableModuleScript&amp; moduleScriptRef, JSInternalPromise&amp; promise, DOMWrapperWorld&amp; world)
274 {
275     auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">276     auto&amp; state = *proxy.window()-&gt;globalExec();</span>
277 
278     // It is not guaranteed that either fulfillHandler or rejectHandler is eventually called.
279     // For example, if the page load is canceled, the DeferredPromise used in the module loader pipeline will stop executing JS code.
280     // Thus the promise returned from this function could remain unresolved.
281 
282     RefPtr&lt;LoadableModuleScript&gt; moduleScript(&amp;moduleScriptRef);
283 
<span class="line-modified">284     auto&amp; fulfillHandler = *JSNativeStdFunction::create(state.vm(), proxy.window(), 1, String(), [moduleScript](ExecState* exec) -&gt; JSC::EncodedJSValue {</span>
<span class="line-modified">285         VM&amp; vm = exec-&gt;vm();</span>
286         auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">287         Identifier moduleKey = jsValueToModuleKey(exec, exec-&gt;argument(0));</span>
288         RETURN_IF_EXCEPTION(scope, { });
289         moduleScript-&gt;notifyLoadCompleted(*moduleKey.impl());
290         return JSValue::encode(jsUndefined());
291     });
292 
<span class="line-modified">293     auto&amp; rejectHandler = *JSNativeStdFunction::create(state.vm(), proxy.window(), 1, String(), [moduleScript](ExecState* exec) {</span>
<span class="line-modified">294         VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">295         JSValue errorValue = exec-&gt;argument(0);</span>
296         if (errorValue.isObject()) {
297             auto* object = JSC::asObject(errorValue);
298             if (JSValue failureKindValue = object-&gt;getDirect(vm, static_cast&lt;JSVMClientData&amp;&gt;(*vm.clientData).builtinNames().failureKindPrivateName())) {
299                 // This is host propagated error in the module loader pipeline.
300                 switch (static_cast&lt;ModuleFetchFailureKind&gt;(failureKindValue.asInt32())) {
301                 case ModuleFetchFailureKind::WasErrored:
302                     moduleScript-&gt;notifyLoadFailed(LoadableScript::Error {
303                         LoadableScript::ErrorType::CachedScript,
304                         WTF::nullopt
305                     });
306                     break;
307                 case ModuleFetchFailureKind::WasCanceled:
308                     moduleScript-&gt;notifyLoadWasCanceled();
309                     break;
310                 }
311                 return JSValue::encode(jsUndefined());
312             }
313         }
314 
315         auto scope = DECLARE_CATCH_SCOPE(vm);
316         moduleScript-&gt;notifyLoadFailed(LoadableScript::Error {
317             LoadableScript::ErrorType::CachedScript,
318             LoadableScript::ConsoleMessage {
319                 MessageSource::JS,
320                 MessageLevel::Error,
<span class="line-modified">321                 retrieveErrorMessage(*exec, vm, errorValue, scope),</span>
322             }
323         });
324         return JSValue::encode(jsUndefined());
325     });
326 
<span class="line-modified">327     promise.then(&amp;state, &amp;fulfillHandler, &amp;rejectHandler);</span>
328 }
329 
330 WindowProxy&amp; ScriptController::windowProxy()
331 {
332     return m_frame.windowProxy();
333 }
334 
335 JSWindowProxy&amp; ScriptController::jsWindowProxy(DOMWrapperWorld&amp; world)
336 {
337     auto* jsWindowProxy = m_frame.windowProxy().jsWindowProxy(world);
338     ASSERT_WITH_MESSAGE(jsWindowProxy, &quot;The JSWindowProxy can only be null if the frame has been destroyed&quot;);
339     return *jsWindowProxy;
340 }
341 
342 TextPosition ScriptController::eventHandlerPosition() const
343 {
344     // FIXME: If we are not currently parsing, we should use our current location
345     // in JavaScript, to cover cases like &quot;element.setAttribute(&#39;click&#39;, ...)&quot;.
346 
347     // FIXME: This location maps to the end of the HTML tag, and not to the
</pre>
<hr />
<pre>
369 }
370 
371 void ScriptController::disableEval(const String&amp; errorMessage)
372 {
373     auto* jsWindowProxy = windowProxy().existingJSWindowProxy(mainThreadNormalWorld());
374     if (!jsWindowProxy)
375         return;
376     jsWindowProxy-&gt;window()-&gt;setEvalEnabled(false, errorMessage);
377 }
378 
379 void ScriptController::disableWebAssembly(const String&amp; errorMessage)
380 {
381     auto* jsWindowProxy = windowProxy().existingJSWindowProxy(mainThreadNormalWorld());
382     if (!jsWindowProxy)
383         return;
384     jsWindowProxy-&gt;window()-&gt;setWebAssemblyEnabled(false, errorMessage);
385 }
386 
387 bool ScriptController::canAccessFromCurrentOrigin(Frame* frame, Document&amp; accessingDocument)
388 {
<span class="line-modified">389     auto* state = JSExecState::currentState();</span>
390 
<span class="line-modified">391     // If the current state is null we should use the accessing document for the security check.</span>
<span class="line-modified">392     if (!state) {</span>
393         auto* targetDocument = frame ? frame-&gt;document() : nullptr;
394         return targetDocument &amp;&amp; accessingDocument.securityOrigin().canAccess(targetDocument-&gt;securityOrigin());
395     }
396 
<span class="line-modified">397     return BindingSecurity::shouldAllowAccessToFrame(state, frame);</span>
398 }
399 
400 void ScriptController::updateDocument()
401 {
402     for (auto&amp; jsWindowProxy : windowProxy().jsWindowProxiesAsVector()) {
403         JSLockHolder lock(jsWindowProxy-&gt;world().vm());
404         jsCast&lt;JSDOMWindow*&gt;(jsWindowProxy-&gt;window())-&gt;updateDocument();
405     }
406 }
407 
408 Bindings::RootObject* ScriptController::cacheableBindingRootObject()
409 {
410     if (!canExecuteScripts(NotAboutToExecuteScript))
411         return nullptr;
412 
413     if (!m_cacheableBindingRootObject) {
414         JSLockHolder lock(commonVM());
415         m_cacheableBindingRootObject = Bindings::RootObject::create(nullptr, globalObject(pluginWorld()));
416     }
417     return m_cacheableBindingRootObject.get();
</pre>
<hr />
<pre>
424 
425     if (!m_bindingRootObject) {
426         JSLockHolder lock(commonVM());
427         m_bindingRootObject = Bindings::RootObject::create(nullptr, globalObject(pluginWorld()));
428     }
429     return m_bindingRootObject.get();
430 }
431 
432 Ref&lt;Bindings::RootObject&gt; ScriptController::createRootObject(void* nativeHandle)
433 {
434     auto it = m_rootObjects.find(nativeHandle);
435     if (it != m_rootObjects.end())
436         return it-&gt;value.copyRef();
437 
438     auto rootObject = Bindings::RootObject::create(nativeHandle, globalObject(pluginWorld()));
439 
440     m_rootObjects.set(nativeHandle, rootObject.copyRef());
441     return rootObject;
442 }
443 
<span class="line-modified">444 void ScriptController::collectIsolatedContexts(Vector&lt;std::pair&lt;JSC::ExecState*, SecurityOrigin*&gt;&gt;&amp; result)</span>
445 {
446     for (auto&amp; jsWindowProxy : windowProxy().jsWindowProxiesAsVector()) {
<span class="line-modified">447         auto* exec = jsWindowProxy-&gt;window()-&gt;globalExec();</span>
448         auto* origin = &amp;downcast&lt;DOMWindow&gt;(jsWindowProxy-&gt;wrapped()).document()-&gt;securityOrigin();
<span class="line-modified">449         result.append(std::make_pair(exec, origin));</span>
450     }
451 }
452 
453 #if ENABLE(NETSCAPE_PLUGIN_API)
454 NPObject* ScriptController::windowScriptNPObject()
455 {
456     if (!m_windowScriptNPObject) {
457         JSLockHolder lock(commonVM());
458         if (canExecuteScripts(NotAboutToExecuteScript)) {
459             // JavaScript is enabled, so there is a JavaScript window object.
460             // Return an NPObject bound to the window object.
461             auto* window = jsWindowProxy(pluginWorld()).window();
462             ASSERT(window);
463             Bindings::RootObject* root = bindingRootObject();
464             m_windowScriptNPObject = _NPN_CreateScriptObject(0, window, root);
465         } else {
466             // JavaScript is not enabled, so we cannot bind the NPObject to the JavaScript window object.
467             // Instead, we create an NPObject of a different class, one which is not bound to a JavaScript object.
468             m_windowScriptNPObject = _NPN_CreateNoScriptObject();
469         }
</pre>
<hr />
<pre>
477 RefPtr&lt;JSC::Bindings::Instance&gt; ScriptController::createScriptInstanceForWidget(Widget* widget)
478 {
479     if (!is&lt;PluginViewBase&gt;(*widget))
480         return nullptr;
481 
482     return downcast&lt;PluginViewBase&gt;(*widget).bindingInstance();
483 }
484 #endif
485 
486 JSObject* ScriptController::jsObjectForPluginElement(HTMLPlugInElement* plugin)
487 {
488     // Can&#39;t create JSObjects when JavaScript is disabled
489     if (!canExecuteScripts(NotAboutToExecuteScript))
490         return nullptr;
491 
492     JSLockHolder lock(commonVM());
493 
494     // Create a JSObject bound to this element
495     auto* globalObj = globalObject(pluginWorld());
496     // FIXME: is normal okay? - used for NP plugins?
<span class="line-modified">497     JSValue jsElementValue = toJS(globalObj-&gt;globalExec(), globalObj, plugin);</span>
498     if (!jsElementValue || !jsElementValue.isObject())
499         return nullptr;
500 
501     return jsElementValue.getObject();
502 }
503 
504 #if !PLATFORM(COCOA)
505 
506 void ScriptController::updatePlatformScriptObjects()
507 {
508 }
509 
510 void ScriptController::disconnectPlatformScriptObjects()
511 {
512 }
513 
514 #endif
515 
516 void ScriptController::cleanupScriptObjectsForPlugin(void* nativeHandle)
517 {
</pre>
<hr />
<pre>
531         rootObject-&gt;invalidate();
532 
533     m_rootObjects.clear();
534 
535     if (m_bindingRootObject) {
536         m_bindingRootObject-&gt;invalidate();
537         m_bindingRootObject = nullptr;
538     }
539 
540 #if ENABLE(NETSCAPE_PLUGIN_API)
541     if (m_windowScriptNPObject) {
542         // Call _NPN_DeallocateObject() instead of _NPN_ReleaseObject() so that we don&#39;t leak if a plugin fails to release the window
543         // script object properly.
544         // This shouldn&#39;t cause any problems for plugins since they should have already been stopped and destroyed at this point.
545         _NPN_DeallocateObject(m_windowScriptNPObject);
546         m_windowScriptNPObject = nullptr;
547     }
548 #endif
549 }
550 
<span class="line-modified">551 JSValue ScriptController::executeScriptInWorld(DOMWrapperWorld&amp; world, const String&amp; script, bool forceUserGesture, ExceptionDetails* exceptionDetails)</span>











552 {
<span class="line-modified">553     UserGestureIndicator gestureIndicator(forceUserGesture ? Optional&lt;ProcessingUserGestureState&gt;(ProcessingUserGesture) : WTF::nullopt);</span>
<span class="line-removed">554     ScriptSourceCode sourceCode(script, URL(m_frame.document()-&gt;url()), TextPosition(), JSC::SourceProviderSourceType::Program, CachedScriptFetcher::create(m_frame.document()-&gt;charset()));</span>
555 
556     if (!canExecuteScripts(AboutToExecuteScript) || isPaused())
<span class="line-modified">557         return { };</span>




































































































558 
<span class="line-modified">559     return evaluateInWorld(sourceCode, world, exceptionDetails);</span>







560 }
561 
<span class="line-modified">562 JSValue ScriptController::executeUserAgentScriptInWorld(DOMWrapperWorld&amp; world, const String&amp; script, bool forceUserGesture, ExceptionDetails* exceptionDetails)</span>
563 {
564     auto&amp; document = *m_frame.document();
<span class="line-modified">565     if (!shouldAllowUserAgentScripts(document))</span>
<span class="line-modified">566         return { };</span>

567 
568     document.setHasEvaluatedUserAgentScripts();
<span class="line-modified">569     return executeScriptInWorld(world, script, forceUserGesture, exceptionDetails);</span>
570 }
571 
<span class="line-modified">572 bool ScriptController::shouldAllowUserAgentScripts(Document&amp; document) const</span>































































573 {
574 #if ENABLE(APPLE_PAY)
575     if (auto page = m_frame.page())
576         return page-&gt;paymentCoordinator().shouldAllowUserAgentScripts(document);
577 #else
578     UNUSED_PARAM(document);
579 #endif
<span class="line-modified">580     return true;</span>
581 }
582 
583 bool ScriptController::canExecuteScripts(ReasonForCallingCanExecuteScripts reason)
584 {
585     if (reason == AboutToExecuteScript)
586         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed() || !isInWebProcess());
587 
588     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;isSandboxed(SandboxScripts)) {
589         // FIXME: This message should be moved off the console once a solution to https://bugs.webkit.org/show_bug.cgi?id=103274 exists.
590         if (reason == AboutToExecuteScript || reason == AboutToCreateEventListener)
591             m_frame.document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked script execution in &#39;&quot; + m_frame.document()-&gt;url().stringCenterEllipsizedToLength() + &quot;&#39; because the document&#39;s frame is sandboxed and the &#39;allow-scripts&#39; permission is not set.&quot;);
592         return false;
593     }
594 
595     if (!m_frame.page())
596         return false;
597 
598     return m_frame.loader().client().allowScript(m_frame.settings().isScriptEnabled());
599 }
600 
<span class="line-modified">601 JSValue ScriptController::executeScript(const String&amp; script, bool forceUserGesture, ExceptionDetails* exceptionDetails)</span>
<span class="line-removed">602 {</span>
<span class="line-removed">603     UserGestureIndicator gestureIndicator(forceUserGesture ? Optional&lt;ProcessingUserGestureState&gt;(ProcessingUserGesture) : WTF::nullopt);</span>
<span class="line-removed">604     return executeScript(ScriptSourceCode(script, URL(m_frame.document()-&gt;url()), TextPosition(), JSC::SourceProviderSourceType::Program, CachedScriptFetcher::create(m_frame.document()-&gt;charset())), exceptionDetails);</span>
<span class="line-removed">605 }</span>
<span class="line-removed">606 </span>
<span class="line-removed">607 JSValue ScriptController::executeScript(const ScriptSourceCode&amp; sourceCode, ExceptionDetails* exceptionDetails)</span>
<span class="line-removed">608 {</span>
<span class="line-removed">609     if (!canExecuteScripts(AboutToExecuteScript) || isPaused())</span>
<span class="line-removed">610         return { }; // FIXME: Would jsNull be better?</span>
<span class="line-removed">611 </span>
<span class="line-removed">612     // FIXME: Preventing Frame from being destroyed is essentially unnecessary.</span>
<span class="line-removed">613     // https://bugs.webkit.org/show_bug.cgi?id=164763</span>
<span class="line-removed">614     Ref&lt;Frame&gt; protector(m_frame); // Script execution can destroy the frame, and thus the ScriptController.</span>
<span class="line-removed">615 </span>
<span class="line-removed">616     return evaluate(sourceCode, exceptionDetails);</span>
<span class="line-removed">617 }</span>
<span class="line-removed">618 </span>
<span class="line-removed">619 bool ScriptController::executeIfJavaScriptURL(const URL&amp; url, ShouldReplaceDocumentIfJavaScriptURL shouldReplaceDocumentIfJavaScriptURL)</span>
620 {
621     if (!WTF::protocolIsJavaScript(url))
622         return false;
623 



624     if (!m_frame.page() || !m_frame.document()-&gt;contentSecurityPolicy()-&gt;allowJavaScriptURLs(m_frame.document()-&gt;url(), eventHandlerPosition().m_line))
625         return true;
626 
627     // We need to hold onto the Frame here because executing script can
628     // destroy the frame.
629     Ref&lt;Frame&gt; protector(m_frame);
630     RefPtr&lt;Document&gt; ownerDocument(m_frame.document());
631 
632     const int javascriptSchemeLength = sizeof(&quot;javascript:&quot;) - 1;
633 
634     String decodedURL = decodeURLEscapeSequences(url.string());
<span class="line-modified">635     auto result = executeScript(decodedURL.substring(javascriptSchemeLength));</span>
636 
637     // If executing script caused this frame to be removed from the page, we
638     // don&#39;t want to try to replace its document!
639     if (!m_frame.page())
640         return true;
641 
642     String scriptResult;
<span class="line-modified">643     if (!result || !result.getString(jsWindowProxy(mainThreadNormalWorld()).window()-&gt;globalExec(), scriptResult))</span>
644         return true;
645 
646     // FIXME: We should always replace the document, but doing so
647     //        synchronously can cause crashes:
648     //        http://bugs.webkit.org/show_bug.cgi?id=16782
649     if (shouldReplaceDocumentIfJavaScriptURL == ReplaceDocumentIfJavaScriptURL) {
650         // We&#39;re still in a frame, so there should be a DocumentLoader.
651         ASSERT(m_frame.document()-&gt;loader());
652 
653         // Signal to FrameLoader to disable navigations within this frame while replacing it with the result of executing javascript
654         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=200523
655         // The only reason we do a nestable save/restore of this flag here is because we sometimes nest javascript: url loads as
656         // some will load synchronously. We&#39;d like to remove those synchronous loads and then change this.
657         SetForScope&lt;bool&gt; willBeReplaced(m_willReplaceWithResultOfExecutingJavascriptURL, true);
658 
659         // DocumentWriter::replaceDocumentWithResultOfExecutingJavascriptURL can cause the DocumentLoader to get deref&#39;ed and possible destroyed,
660         // so protect it with a RefPtr.
661         if (RefPtr&lt;DocumentLoader&gt; loader = m_frame.document()-&gt;loader())
662             loader-&gt;writer().replaceDocumentWithResultOfExecutingJavascriptURL(scriptResult, ownerDocument.get());
663     }
</pre>
</td>
<td>
<hr />
<pre>
  9  *  version 2 of the License, or (at your option) any later version.
 10  *
 11  *  This library is distributed in the hope that it will be useful,
 12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  *  Lesser General Public License for more details.
 15  *
 16  *  You should have received a copy of the GNU Lesser General Public
 17  *  License along with this library; if not, write to the Free Software
 18  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;ScriptController.h&quot;
 23 
 24 #include &quot;BridgeJSC.h&quot;
 25 #include &quot;CachedScriptFetcher.h&quot;
 26 #include &quot;CommonVM.h&quot;
 27 #include &quot;ContentSecurityPolicy.h&quot;
 28 #include &quot;CustomHeaderFields.h&quot;
<span class="line-added"> 29 #include &quot;DOMWrapperWorld.h&quot;</span>
 30 #include &quot;DocumentLoader.h&quot;
 31 #include &quot;Event.h&quot;
 32 #include &quot;Frame.h&quot;
 33 #include &quot;FrameLoader.h&quot;
 34 #include &quot;FrameLoaderClient.h&quot;
 35 #include &quot;HTMLPlugInElement.h&quot;
 36 #include &quot;InspectorInstrumentation.h&quot;
 37 #include &quot;JSDOMBindingSecurity.h&quot;
 38 #include &quot;JSDOMExceptionHandling.h&quot;
 39 #include &quot;JSDOMWindow.h&quot;
 40 #include &quot;JSDocument.h&quot;
 41 #include &quot;JSExecState.h&quot;
 42 #include &quot;LoadableModuleScript.h&quot;
 43 #include &quot;ModuleFetchFailureKind.h&quot;
 44 #include &quot;ModuleFetchParameters.h&quot;
 45 #include &quot;NP_jsobject.h&quot;
 46 #include &quot;Page.h&quot;
 47 #include &quot;PageConsoleClient.h&quot;
 48 #include &quot;PageGroup.h&quot;
 49 #include &quot;PaymentCoordinator.h&quot;
 50 #include &quot;PluginViewBase.h&quot;
<span class="line-added"> 51 #include &quot;RunJavaScriptParameters.h&quot;</span>
 52 #include &quot;RuntimeApplicationChecks.h&quot;
 53 #include &quot;ScriptDisallowedScope.h&quot;
 54 #include &quot;ScriptSourceCode.h&quot;
 55 #include &quot;ScriptableDocumentParser.h&quot;
 56 #include &quot;Settings.h&quot;
 57 #include &quot;UserGestureIndicator.h&quot;
 58 #include &quot;WebCoreJSClientData.h&quot;
 59 #include &quot;npruntime_impl.h&quot;
 60 #include &quot;runtime_root.h&quot;
 61 #include &lt;JavaScriptCore/Debugger.h&gt;
<span class="line-added"> 62 #include &lt;JavaScriptCore/Heap.h&gt;</span>
 63 #include &lt;JavaScriptCore/InitializeThreading.h&gt;
 64 #include &lt;JavaScriptCore/JSFunction.h&gt;
 65 #include &lt;JavaScriptCore/JSInternalPromise.h&gt;
 66 #include &lt;JavaScriptCore/JSLock.h&gt;
 67 #include &lt;JavaScriptCore/JSModuleRecord.h&gt;
 68 #include &lt;JavaScriptCore/JSNativeStdFunction.h&gt;
 69 #include &lt;JavaScriptCore/JSScriptFetchParameters.h&gt;
 70 #include &lt;JavaScriptCore/JSScriptFetcher.h&gt;
 71 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 72 #include &lt;JavaScriptCore/StrongInlines.h&gt;
<span class="line-added"> 73 #include &lt;JavaScriptCore/WeakGCMapInlines.h&gt;</span>
 74 #include &lt;wtf/SetForScope.h&gt;
<span class="line-added"> 75 #include &lt;wtf/SharedTask.h&gt;</span>
 76 #include &lt;wtf/Threading.h&gt;
 77 #include &lt;wtf/text/TextPosition.h&gt;
 78 
 79 namespace WebCore {
 80 using namespace JSC;
 81 
 82 void ScriptController::initializeThreading()
 83 {
 84 #if !PLATFORM(IOS_FAMILY)
 85     JSC::initializeThreading();
 86     WTF::initializeMainThread();
 87 #endif
 88 }
 89 
 90 ScriptController::ScriptController(Frame&amp; frame)
 91     : m_frame(frame)
 92     , m_sourceURL(0)
 93     , m_paused(false)
 94 #if ENABLE(NETSCAPE_PLUGIN_API)
 95     , m_windowScriptNPObject(0)
 96 #endif
 97 #if PLATFORM(COCOA)
 98     , m_windowScriptObject(0)
 99 #endif
100 {
101 }
102 
103 ScriptController::~ScriptController()
104 {
105     disconnectPlatformScriptObjects();
106 
107     if (m_cacheableBindingRootObject) {
108         JSLockHolder lock(commonVM());
109         m_cacheableBindingRootObject-&gt;invalidate();
110         m_cacheableBindingRootObject = nullptr;
111     }
112 }
113 
<span class="line-modified">114 JSC::JSValue ScriptController::evaluateInWorldIgnoringException(const ScriptSourceCode&amp; sourceCode, DOMWrapperWorld&amp; world)</span>
<span class="line-added">115 {</span>
<span class="line-added">116     auto result = evaluateInWorld(sourceCode, world);</span>
<span class="line-added">117     return result ? result.value() : JSC::JSValue { };</span>
<span class="line-added">118 }</span>
<span class="line-added">119 </span>
<span class="line-added">120 ValueOrException ScriptController::evaluateInWorld(const ScriptSourceCode&amp; sourceCode, DOMWrapperWorld&amp; world)</span>
121 {
122     JSLockHolder lock(world.vm());
123 
124     const SourceCode&amp; jsSourceCode = sourceCode.jsSourceCode();
125     String sourceURL = jsSourceCode.provider()-&gt;url();
126 
127     // evaluate code. Returns the JS return value or 0
128     // if there was none, an error occurred or the type couldn&#39;t be converted.
129 
130     // inlineCode is true for &lt;a href=&quot;javascript:doSomething()&quot;&gt;
131     // and false for &lt;script&gt;doSomething()&lt;/script&gt;. Check if it has the
132     // expected value in all cases.
133     // See smart window.open policy for where this is used.
134     auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">135     auto&amp; globalObject = *proxy.window();</span>
136     const String* savedSourceURL = m_sourceURL;
137     m_sourceURL = &amp;sourceURL;
138 
139     Ref&lt;Frame&gt; protector(m_frame);
140 
<span class="line-modified">141     InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, sourceCode.startLine(), sourceCode.startColumn());</span>
142 
143     NakedPtr&lt;JSC::Exception&gt; evaluationException;
<span class="line-modified">144     JSValue returnValue = JSExecState::profiledEvaluate(&amp;globalObject, JSC::ProfilingReason::Other, jsSourceCode, &amp;proxy, evaluationException);</span>
145 
<span class="line-modified">146     InspectorInstrumentation::didEvaluateScript(m_frame);</span>
147 
<span class="line-added">148     Optional&lt;ExceptionDetails&gt; optionalDetails;</span>
149     if (evaluationException) {
<span class="line-modified">150         ExceptionDetails details;</span>
<span class="line-modified">151         reportException(&amp;globalObject, evaluationException, sourceCode.cachedScript(), &amp;details);</span>
<span class="line-modified">152         optionalDetails = WTFMove(details);</span>
153     }
154 
155     m_sourceURL = savedSourceURL;
<span class="line-added">156     if (optionalDetails)</span>
<span class="line-added">157         return makeUnexpected(*optionalDetails);</span>
<span class="line-added">158 </span>
159     return returnValue;
160 }
161 
<span class="line-modified">162 JSC::JSValue ScriptController::evaluateIgnoringException(const ScriptSourceCode&amp; sourceCode)</span>
163 {
<span class="line-modified">164     return evaluateInWorldIgnoringException(sourceCode, mainThreadNormalWorld());</span>
165 }
166 
167 void ScriptController::loadModuleScriptInWorld(LoadableModuleScript&amp; moduleScript, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp; topLevelFetchParameters, DOMWrapperWorld&amp; world)
168 {
169     JSLockHolder lock(world.vm());
170 
171     auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">172     auto&amp; lexicalGlobalObject = *proxy.window();</span>
173 
<span class="line-modified">174     auto&amp; promise = JSExecState::loadModule(lexicalGlobalObject, moduleName, JSC::JSScriptFetchParameters::create(lexicalGlobalObject.vm(), WTFMove(topLevelFetchParameters)), JSC::JSScriptFetcher::create(lexicalGlobalObject.vm(), { &amp;moduleScript }));</span>
175     setupModuleScriptHandlers(moduleScript, promise, world);
176 }
177 
178 void ScriptController::loadModuleScript(LoadableModuleScript&amp; moduleScript, const String&amp; moduleName, Ref&lt;ModuleFetchParameters&gt;&amp;&amp; topLevelFetchParameters)
179 {
180     loadModuleScriptInWorld(moduleScript, moduleName, WTFMove(topLevelFetchParameters), mainThreadNormalWorld());
181 }
182 
183 void ScriptController::loadModuleScriptInWorld(LoadableModuleScript&amp; moduleScript, const ScriptSourceCode&amp; sourceCode, DOMWrapperWorld&amp; world)
184 {
185     JSLockHolder lock(world.vm());
186 
187     auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">188     auto&amp; lexicalGlobalObject = *proxy.window();</span>
189 
<span class="line-modified">190     auto&amp; promise = JSExecState::loadModule(lexicalGlobalObject, sourceCode.jsSourceCode(), JSC::JSScriptFetcher::create(lexicalGlobalObject.vm(), { &amp;moduleScript }));</span>
191     setupModuleScriptHandlers(moduleScript, promise, world);
192 }
193 
194 void ScriptController::loadModuleScript(LoadableModuleScript&amp; moduleScript, const ScriptSourceCode&amp; sourceCode)
195 {
196     loadModuleScriptInWorld(moduleScript, sourceCode, mainThreadNormalWorld());
197 }
198 
199 JSC::JSValue ScriptController::linkAndEvaluateModuleScriptInWorld(LoadableModuleScript&amp; moduleScript, DOMWrapperWorld&amp; world)
200 {
201     JSC::VM&amp; vm = world.vm();
202     JSLockHolder lock(vm);
203 
204     auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">205     auto&amp; lexicalGlobalObject = *proxy.window();</span>
206 
207     // FIXME: Preventing Frame from being destroyed is essentially unnecessary.
208     // https://bugs.webkit.org/show_bug.cgi?id=164763
209     Ref&lt;Frame&gt; protector(m_frame);
210 
211     NakedPtr&lt;JSC::Exception&gt; evaluationException;
<span class="line-modified">212     auto returnValue = JSExecState::linkAndEvaluateModule(lexicalGlobalObject, Identifier::fromUid(vm, moduleScript.moduleKey()), jsUndefined(), evaluationException);</span>
213     if (evaluationException) {
214         // FIXME: Give a chance to dump the stack trace if the &quot;crossorigin&quot; attribute allows.
215         // https://bugs.webkit.org/show_bug.cgi?id=164539
<span class="line-modified">216         reportException(&amp;lexicalGlobalObject, evaluationException, nullptr);</span>
217         return jsUndefined();
218     }
219     return returnValue;
220 }
221 
222 JSC::JSValue ScriptController::linkAndEvaluateModuleScript(LoadableModuleScript&amp; moduleScript)
223 {
224     return linkAndEvaluateModuleScriptInWorld(moduleScript, mainThreadNormalWorld());
225 }
226 
227 JSC::JSValue ScriptController::evaluateModule(const URL&amp; sourceURL, JSModuleRecord&amp; moduleRecord, DOMWrapperWorld&amp; world)
228 {
229     JSLockHolder lock(world.vm());
230 
231     const auto&amp; jsSourceCode = moduleRecord.sourceCode();
232 
233     auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">234     auto&amp; lexicalGlobalObject = *proxy.window();</span>
235     SetForScope&lt;const String*&gt; sourceURLScope(m_sourceURL, &amp;sourceURL.string());
236 
237     Ref&lt;Frame&gt; protector(m_frame);
238 
<span class="line-modified">239     InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, jsSourceCode.firstLine().oneBasedInt(), jsSourceCode.startColumn().oneBasedInt());</span>
<span class="line-modified">240     auto returnValue = moduleRecord.evaluate(&amp;lexicalGlobalObject);</span>
<span class="line-modified">241     InspectorInstrumentation::didEvaluateScript(m_frame);</span>

242 
243     return returnValue;
244 }
245 
246 JSC::JSValue ScriptController::evaluateModule(const URL&amp; sourceURL, JSModuleRecord&amp; moduleRecord)
247 {
248     return evaluateModule(sourceURL, moduleRecord, mainThreadNormalWorld());
249 }
250 
<span class="line-modified">251 Ref&lt;DOMWrapperWorld&gt; ScriptController::createWorld(const String&amp; name, WorldType type)</span>
252 {
<span class="line-modified">253     return DOMWrapperWorld::create(commonVM(), type == WorldType::User ? DOMWrapperWorld::Type::User : DOMWrapperWorld::Type::Internal, name);</span>
254 }
255 
256 void ScriptController::getAllWorlds(Vector&lt;Ref&lt;DOMWrapperWorld&gt;&gt;&amp; worlds)
257 {
258     static_cast&lt;JSVMClientData*&gt;(commonVM().clientData)-&gt;getAllWorlds(worlds);
259 }
260 
261 void ScriptController::initScriptForWindowProxy(JSWindowProxy&amp; windowProxy)
262 {
263     auto&amp; world = windowProxy.world();
264 
265     jsCast&lt;JSDOMWindow*&gt;(windowProxy.window())-&gt;updateDocument();
266 
267     if (Document* document = m_frame.document())
268         document-&gt;contentSecurityPolicy()-&gt;didCreateWindowProxy(windowProxy);
269 
270     if (Page* page = m_frame.page()) {
271         windowProxy.attachDebugger(page-&gt;debugger());
272         windowProxy.window()-&gt;setProfileGroup(page-&gt;group().identifier());
273         windowProxy.window()-&gt;setConsoleClient(&amp;page-&gt;console());
274     }
275 
276     m_frame.loader().dispatchDidClearWindowObjectInWorld(world);
277 }
278 
<span class="line-modified">279 static Identifier jsValueToModuleKey(JSGlobalObject* lexicalGlobalObject, JSValue value)</span>
280 {
281     if (value.isSymbol())
282         return Identifier::fromUid(jsCast&lt;Symbol*&gt;(value)-&gt;privateName());
283     ASSERT(value.isString());
<span class="line-modified">284     return asString(value)-&gt;toIdentifier(lexicalGlobalObject);</span>
285 }
286 
287 void ScriptController::setupModuleScriptHandlers(LoadableModuleScript&amp; moduleScriptRef, JSInternalPromise&amp; promise, DOMWrapperWorld&amp; world)
288 {
289     auto&amp; proxy = jsWindowProxy(world);
<span class="line-modified">290     auto&amp; lexicalGlobalObject = *proxy.window();</span>
291 
292     // It is not guaranteed that either fulfillHandler or rejectHandler is eventually called.
293     // For example, if the page load is canceled, the DeferredPromise used in the module loader pipeline will stop executing JS code.
294     // Thus the promise returned from this function could remain unresolved.
295 
296     RefPtr&lt;LoadableModuleScript&gt; moduleScript(&amp;moduleScriptRef);
297 
<span class="line-modified">298     auto&amp; fulfillHandler = *JSNativeStdFunction::create(lexicalGlobalObject.vm(), proxy.window(), 1, String(), [moduleScript](JSGlobalObject* globalObject, CallFrame* callFrame) -&gt; JSC::EncodedJSValue {</span>
<span class="line-modified">299         VM&amp; vm = globalObject-&gt;vm();</span>
300         auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">301         Identifier moduleKey = jsValueToModuleKey(globalObject, callFrame-&gt;argument(0));</span>
302         RETURN_IF_EXCEPTION(scope, { });
303         moduleScript-&gt;notifyLoadCompleted(*moduleKey.impl());
304         return JSValue::encode(jsUndefined());
305     });
306 
<span class="line-modified">307     auto&amp; rejectHandler = *JSNativeStdFunction::create(lexicalGlobalObject.vm(), proxy.window(), 1, String(), [moduleScript](JSGlobalObject* globalObject, CallFrame* callFrame) {</span>
<span class="line-modified">308         VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">309         JSValue errorValue = callFrame-&gt;argument(0);</span>
310         if (errorValue.isObject()) {
311             auto* object = JSC::asObject(errorValue);
312             if (JSValue failureKindValue = object-&gt;getDirect(vm, static_cast&lt;JSVMClientData&amp;&gt;(*vm.clientData).builtinNames().failureKindPrivateName())) {
313                 // This is host propagated error in the module loader pipeline.
314                 switch (static_cast&lt;ModuleFetchFailureKind&gt;(failureKindValue.asInt32())) {
315                 case ModuleFetchFailureKind::WasErrored:
316                     moduleScript-&gt;notifyLoadFailed(LoadableScript::Error {
317                         LoadableScript::ErrorType::CachedScript,
318                         WTF::nullopt
319                     });
320                     break;
321                 case ModuleFetchFailureKind::WasCanceled:
322                     moduleScript-&gt;notifyLoadWasCanceled();
323                     break;
324                 }
325                 return JSValue::encode(jsUndefined());
326             }
327         }
328 
329         auto scope = DECLARE_CATCH_SCOPE(vm);
330         moduleScript-&gt;notifyLoadFailed(LoadableScript::Error {
331             LoadableScript::ErrorType::CachedScript,
332             LoadableScript::ConsoleMessage {
333                 MessageSource::JS,
334                 MessageLevel::Error,
<span class="line-modified">335                 retrieveErrorMessage(*globalObject, vm, errorValue, scope),</span>
336             }
337         });
338         return JSValue::encode(jsUndefined());
339     });
340 
<span class="line-modified">341     promise.then(&amp;lexicalGlobalObject, &amp;fulfillHandler, &amp;rejectHandler);</span>
342 }
343 
344 WindowProxy&amp; ScriptController::windowProxy()
345 {
346     return m_frame.windowProxy();
347 }
348 
349 JSWindowProxy&amp; ScriptController::jsWindowProxy(DOMWrapperWorld&amp; world)
350 {
351     auto* jsWindowProxy = m_frame.windowProxy().jsWindowProxy(world);
352     ASSERT_WITH_MESSAGE(jsWindowProxy, &quot;The JSWindowProxy can only be null if the frame has been destroyed&quot;);
353     return *jsWindowProxy;
354 }
355 
356 TextPosition ScriptController::eventHandlerPosition() const
357 {
358     // FIXME: If we are not currently parsing, we should use our current location
359     // in JavaScript, to cover cases like &quot;element.setAttribute(&#39;click&#39;, ...)&quot;.
360 
361     // FIXME: This location maps to the end of the HTML tag, and not to the
</pre>
<hr />
<pre>
383 }
384 
385 void ScriptController::disableEval(const String&amp; errorMessage)
386 {
387     auto* jsWindowProxy = windowProxy().existingJSWindowProxy(mainThreadNormalWorld());
388     if (!jsWindowProxy)
389         return;
390     jsWindowProxy-&gt;window()-&gt;setEvalEnabled(false, errorMessage);
391 }
392 
393 void ScriptController::disableWebAssembly(const String&amp; errorMessage)
394 {
395     auto* jsWindowProxy = windowProxy().existingJSWindowProxy(mainThreadNormalWorld());
396     if (!jsWindowProxy)
397         return;
398     jsWindowProxy-&gt;window()-&gt;setWebAssemblyEnabled(false, errorMessage);
399 }
400 
401 bool ScriptController::canAccessFromCurrentOrigin(Frame* frame, Document&amp; accessingDocument)
402 {
<span class="line-modified">403     auto* lexicalGlobalObject = JSExecState::currentState();</span>
404 
<span class="line-modified">405     // If the current lexicalGlobalObject is null we should use the accessing document for the security check.</span>
<span class="line-modified">406     if (!lexicalGlobalObject) {</span>
407         auto* targetDocument = frame ? frame-&gt;document() : nullptr;
408         return targetDocument &amp;&amp; accessingDocument.securityOrigin().canAccess(targetDocument-&gt;securityOrigin());
409     }
410 
<span class="line-modified">411     return BindingSecurity::shouldAllowAccessToFrame(lexicalGlobalObject, frame);</span>
412 }
413 
414 void ScriptController::updateDocument()
415 {
416     for (auto&amp; jsWindowProxy : windowProxy().jsWindowProxiesAsVector()) {
417         JSLockHolder lock(jsWindowProxy-&gt;world().vm());
418         jsCast&lt;JSDOMWindow*&gt;(jsWindowProxy-&gt;window())-&gt;updateDocument();
419     }
420 }
421 
422 Bindings::RootObject* ScriptController::cacheableBindingRootObject()
423 {
424     if (!canExecuteScripts(NotAboutToExecuteScript))
425         return nullptr;
426 
427     if (!m_cacheableBindingRootObject) {
428         JSLockHolder lock(commonVM());
429         m_cacheableBindingRootObject = Bindings::RootObject::create(nullptr, globalObject(pluginWorld()));
430     }
431     return m_cacheableBindingRootObject.get();
</pre>
<hr />
<pre>
438 
439     if (!m_bindingRootObject) {
440         JSLockHolder lock(commonVM());
441         m_bindingRootObject = Bindings::RootObject::create(nullptr, globalObject(pluginWorld()));
442     }
443     return m_bindingRootObject.get();
444 }
445 
446 Ref&lt;Bindings::RootObject&gt; ScriptController::createRootObject(void* nativeHandle)
447 {
448     auto it = m_rootObjects.find(nativeHandle);
449     if (it != m_rootObjects.end())
450         return it-&gt;value.copyRef();
451 
452     auto rootObject = Bindings::RootObject::create(nativeHandle, globalObject(pluginWorld()));
453 
454     m_rootObjects.set(nativeHandle, rootObject.copyRef());
455     return rootObject;
456 }
457 
<span class="line-modified">458 void ScriptController::collectIsolatedContexts(Vector&lt;std::pair&lt;JSC::JSGlobalObject*, SecurityOrigin*&gt;&gt;&amp; result)</span>
459 {
460     for (auto&amp; jsWindowProxy : windowProxy().jsWindowProxiesAsVector()) {
<span class="line-modified">461         auto* lexicalGlobalObject = jsWindowProxy-&gt;window();</span>
462         auto* origin = &amp;downcast&lt;DOMWindow&gt;(jsWindowProxy-&gt;wrapped()).document()-&gt;securityOrigin();
<span class="line-modified">463         result.append(std::make_pair(lexicalGlobalObject, origin));</span>
464     }
465 }
466 
467 #if ENABLE(NETSCAPE_PLUGIN_API)
468 NPObject* ScriptController::windowScriptNPObject()
469 {
470     if (!m_windowScriptNPObject) {
471         JSLockHolder lock(commonVM());
472         if (canExecuteScripts(NotAboutToExecuteScript)) {
473             // JavaScript is enabled, so there is a JavaScript window object.
474             // Return an NPObject bound to the window object.
475             auto* window = jsWindowProxy(pluginWorld()).window();
476             ASSERT(window);
477             Bindings::RootObject* root = bindingRootObject();
478             m_windowScriptNPObject = _NPN_CreateScriptObject(0, window, root);
479         } else {
480             // JavaScript is not enabled, so we cannot bind the NPObject to the JavaScript window object.
481             // Instead, we create an NPObject of a different class, one which is not bound to a JavaScript object.
482             m_windowScriptNPObject = _NPN_CreateNoScriptObject();
483         }
</pre>
<hr />
<pre>
491 RefPtr&lt;JSC::Bindings::Instance&gt; ScriptController::createScriptInstanceForWidget(Widget* widget)
492 {
493     if (!is&lt;PluginViewBase&gt;(*widget))
494         return nullptr;
495 
496     return downcast&lt;PluginViewBase&gt;(*widget).bindingInstance();
497 }
498 #endif
499 
500 JSObject* ScriptController::jsObjectForPluginElement(HTMLPlugInElement* plugin)
501 {
502     // Can&#39;t create JSObjects when JavaScript is disabled
503     if (!canExecuteScripts(NotAboutToExecuteScript))
504         return nullptr;
505 
506     JSLockHolder lock(commonVM());
507 
508     // Create a JSObject bound to this element
509     auto* globalObj = globalObject(pluginWorld());
510     // FIXME: is normal okay? - used for NP plugins?
<span class="line-modified">511     JSValue jsElementValue = toJS(globalObj, globalObj, plugin);</span>
512     if (!jsElementValue || !jsElementValue.isObject())
513         return nullptr;
514 
515     return jsElementValue.getObject();
516 }
517 
518 #if !PLATFORM(COCOA)
519 
520 void ScriptController::updatePlatformScriptObjects()
521 {
522 }
523 
524 void ScriptController::disconnectPlatformScriptObjects()
525 {
526 }
527 
528 #endif
529 
530 void ScriptController::cleanupScriptObjectsForPlugin(void* nativeHandle)
531 {
</pre>
<hr />
<pre>
545         rootObject-&gt;invalidate();
546 
547     m_rootObjects.clear();
548 
549     if (m_bindingRootObject) {
550         m_bindingRootObject-&gt;invalidate();
551         m_bindingRootObject = nullptr;
552     }
553 
554 #if ENABLE(NETSCAPE_PLUGIN_API)
555     if (m_windowScriptNPObject) {
556         // Call _NPN_DeallocateObject() instead of _NPN_ReleaseObject() so that we don&#39;t leak if a plugin fails to release the window
557         // script object properly.
558         // This shouldn&#39;t cause any problems for plugins since they should have already been stopped and destroyed at this point.
559         _NPN_DeallocateObject(m_windowScriptNPObject);
560         m_windowScriptNPObject = nullptr;
561     }
562 #endif
563 }
564 
<span class="line-modified">565 JSC::JSValue ScriptController::executeScriptIgnoringException(const String&amp; script, bool forceUserGesture)</span>
<span class="line-added">566 {</span>
<span class="line-added">567     return executeScriptInWorldIgnoringException(mainThreadNormalWorld(), script, forceUserGesture);</span>
<span class="line-added">568 }</span>
<span class="line-added">569 </span>
<span class="line-added">570 JSC::JSValue ScriptController::executeScriptInWorldIgnoringException(DOMWrapperWorld&amp; world, const String&amp; script, bool forceUserGesture)</span>
<span class="line-added">571 {</span>
<span class="line-added">572     auto result = executeScriptInWorld(world, RunJavaScriptParameters { script, false, WTF::nullopt, forceUserGesture });</span>
<span class="line-added">573     return result ? result.value() : JSC::JSValue { };</span>
<span class="line-added">574 }</span>
<span class="line-added">575 </span>
<span class="line-added">576 ValueOrException ScriptController::executeScriptInWorld(DOMWrapperWorld&amp; world, RunJavaScriptParameters&amp;&amp; parameters)</span>
577 {
<span class="line-modified">578     UserGestureIndicator gestureIndicator(parameters.forceUserGesture == ForceUserGesture::Yes ? Optional&lt;ProcessingUserGestureState&gt;(ProcessingUserGesture) : WTF::nullopt);</span>

579 
580     if (!canExecuteScripts(AboutToExecuteScript) || isPaused())
<span class="line-modified">581         return makeUnexpected(ExceptionDetails { &quot;Cannot execute JavaScript in this document&quot;_s });</span>
<span class="line-added">582 </span>
<span class="line-added">583     switch (parameters.runAsAsyncFunction) {</span>
<span class="line-added">584     case RunAsAsyncFunction::No: {</span>
<span class="line-added">585         ScriptSourceCode sourceCode(parameters.source, URL(m_frame.document()-&gt;url()), TextPosition(), JSC::SourceProviderSourceType::Program, CachedScriptFetcher::create(m_frame.document()-&gt;charset()));</span>
<span class="line-added">586         return evaluateInWorld(sourceCode, world);</span>
<span class="line-added">587     }</span>
<span class="line-added">588     case RunAsAsyncFunction::Yes:</span>
<span class="line-added">589         return callInWorld(WTFMove(parameters), world);</span>
<span class="line-added">590     default:</span>
<span class="line-added">591         RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">592     }</span>
<span class="line-added">593 }</span>
<span class="line-added">594 </span>
<span class="line-added">595 ValueOrException ScriptController::callInWorld(RunJavaScriptParameters&amp;&amp; parameters, DOMWrapperWorld&amp; world)</span>
<span class="line-added">596 {</span>
<span class="line-added">597     ASSERT(parameters.runAsAsyncFunction == RunAsAsyncFunction::Yes);</span>
<span class="line-added">598     ASSERT(parameters.arguments);</span>
<span class="line-added">599 </span>
<span class="line-added">600     auto&amp; proxy = jsWindowProxy(world);</span>
<span class="line-added">601     auto&amp; globalObject = *proxy.window();</span>
<span class="line-added">602     MarkedArgumentBuffer markedArguments;</span>
<span class="line-added">603     StringBuilder functionStringBuilder;</span>
<span class="line-added">604     String errorMessage;</span>
<span class="line-added">605 </span>
<span class="line-added">606     // Build up a new script string that is an async function with arguments, and deserialize those arguments.</span>
<span class="line-added">607     functionStringBuilder.append(&quot;(async function(&quot;);</span>
<span class="line-added">608     for (auto argument = parameters.arguments-&gt;begin(); argument != parameters.arguments-&gt;end();) {</span>
<span class="line-added">609         functionStringBuilder.append(argument-&gt;key);</span>
<span class="line-added">610         auto serializedArgument = SerializedScriptValue::createFromWireBytes(WTFMove(argument-&gt;value));</span>
<span class="line-added">611 </span>
<span class="line-added">612         auto scope = DECLARE_CATCH_SCOPE(globalObject.vm());</span>
<span class="line-added">613         auto jsArgument = serializedArgument-&gt;deserialize(globalObject, &amp;globalObject);</span>
<span class="line-added">614         if (UNLIKELY(scope.exception())) {</span>
<span class="line-added">615             errorMessage = &quot;Unable to deserialize argument to execute asynchronous JavaScript function&quot;;</span>
<span class="line-added">616             break;</span>
<span class="line-added">617         }</span>
<span class="line-added">618 </span>
<span class="line-added">619         markedArguments.append(jsArgument);</span>
<span class="line-added">620 </span>
<span class="line-added">621         ++argument;</span>
<span class="line-added">622         if (argument != parameters.arguments-&gt;end())</span>
<span class="line-added">623             functionStringBuilder.append(&#39;,&#39;);</span>
<span class="line-added">624     }</span>
<span class="line-added">625 </span>
<span class="line-added">626     if (!errorMessage.isEmpty())</span>
<span class="line-added">627         return makeUnexpected(ExceptionDetails { errorMessage });</span>
<span class="line-added">628 </span>
<span class="line-added">629     functionStringBuilder.append(&quot;){&quot;, parameters.source, &quot;})&quot;);</span>
<span class="line-added">630 </span>
<span class="line-added">631     auto sourceCode = ScriptSourceCode { functionStringBuilder.toString(), URL(m_frame.document()-&gt;url()), TextPosition(), JSC::SourceProviderSourceType::Program, CachedScriptFetcher::create(m_frame.document()-&gt;charset()) };</span>
<span class="line-added">632     const auto&amp; jsSourceCode = sourceCode.jsSourceCode();</span>
<span class="line-added">633 </span>
<span class="line-added">634     String sourceURL = jsSourceCode.provider()-&gt;url();</span>
<span class="line-added">635     const String* savedSourceURL = m_sourceURL;</span>
<span class="line-added">636     m_sourceURL = &amp;sourceURL;</span>
<span class="line-added">637 </span>
<span class="line-added">638     Ref&lt;Frame&gt; protector(m_frame);</span>
<span class="line-added">639 </span>
<span class="line-added">640     InspectorInstrumentation::willEvaluateScript(m_frame, sourceURL, sourceCode.startLine(), sourceCode.startColumn());</span>
<span class="line-added">641 </span>
<span class="line-added">642     NakedPtr&lt;JSC::Exception&gt; evaluationException;</span>
<span class="line-added">643     Optional&lt;ExceptionDetails&gt; optionalDetails;</span>
<span class="line-added">644     JSValue returnValue;</span>
<span class="line-added">645     do {</span>
<span class="line-added">646         JSValue functionObject = JSExecState::profiledEvaluate(&amp;globalObject, JSC::ProfilingReason::Other, jsSourceCode, &amp;proxy, evaluationException);</span>
<span class="line-added">647 </span>
<span class="line-added">648         if (evaluationException)</span>
<span class="line-added">649             break;</span>
<span class="line-added">650 </span>
<span class="line-added">651         if (!functionObject || !functionObject.isFunction(world.vm())) {</span>
<span class="line-added">652             optionalDetails = { { &quot;Unable to create JavaScript async function to call&quot;_s } };</span>
<span class="line-added">653             break;</span>
<span class="line-added">654         }</span>
<span class="line-added">655 </span>
<span class="line-added">656         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=205562</span>
<span class="line-added">657         // Getting CallData/CallType shouldn&#39;t be required to call into JS.</span>
<span class="line-added">658         CallData callData;</span>
<span class="line-added">659         CallType callType = getCallData(world.vm(), functionObject, callData);</span>
<span class="line-added">660         if (callType == CallType::None) {</span>
<span class="line-added">661             optionalDetails = { { &quot;Unable to prepare JavaScript async function to be called&quot;_s } };</span>
<span class="line-added">662             break;</span>
<span class="line-added">663         }</span>
<span class="line-added">664 </span>
<span class="line-added">665         returnValue = JSExecState::profiledCall(&amp;globalObject, JSC::ProfilingReason::Other, functionObject, callType, callData, &amp;proxy, markedArguments, evaluationException);</span>
<span class="line-added">666     } while (false);</span>
<span class="line-added">667 </span>
<span class="line-added">668     InspectorInstrumentation::didEvaluateScript(m_frame);</span>
<span class="line-added">669 </span>
<span class="line-added">670     if (evaluationException &amp;&amp; !optionalDetails) {</span>
<span class="line-added">671         ExceptionDetails details;</span>
<span class="line-added">672         reportException(&amp;globalObject, evaluationException, sourceCode.cachedScript(), &amp;details);</span>
<span class="line-added">673         optionalDetails = WTFMove(details);</span>
<span class="line-added">674     }</span>
<span class="line-added">675 </span>
<span class="line-added">676     m_sourceURL = savedSourceURL;</span>
<span class="line-added">677 </span>
<span class="line-added">678     if (optionalDetails)</span>
<span class="line-added">679         return makeUnexpected(*optionalDetails);</span>
<span class="line-added">680     return returnValue;</span>
<span class="line-added">681 }</span>
682 
<span class="line-modified">683 JSC::JSValue ScriptController::executeUserAgentScriptInWorldIgnoringException(DOMWrapperWorld&amp; world, const String&amp; script, bool forceUserGesture)</span>
<span class="line-added">684 {</span>
<span class="line-added">685     auto result = executeUserAgentScriptInWorld(world, script, forceUserGesture);</span>
<span class="line-added">686     return result ? result.value() : JSC::JSValue { };</span>
<span class="line-added">687 }</span>
<span class="line-added">688 ValueOrException ScriptController::executeUserAgentScriptInWorld(DOMWrapperWorld&amp; world, const String&amp; script, bool forceUserGesture)</span>
<span class="line-added">689 {</span>
<span class="line-added">690     return executeUserAgentScriptInWorldInternal(world, { script, false, WTF::nullopt, forceUserGesture });</span>
691 }
692 
<span class="line-modified">693 ValueOrException ScriptController::executeUserAgentScriptInWorldInternal(DOMWrapperWorld&amp; world, RunJavaScriptParameters&amp;&amp; parameters)</span>
694 {
695     auto&amp; document = *m_frame.document();
<span class="line-modified">696     auto allowed = shouldAllowUserAgentScripts(document);</span>
<span class="line-modified">697     if (!allowed)</span>
<span class="line-added">698         return makeUnexpected(allowed.error());</span>
699 
700     document.setHasEvaluatedUserAgentScripts();
<span class="line-modified">701     return executeScriptInWorld(world, WTFMove(parameters));</span>
702 }
703 
<span class="line-modified">704 void ScriptController::executeAsynchronousUserAgentScriptInWorld(DOMWrapperWorld&amp; world, RunJavaScriptParameters&amp;&amp; parameters, ResolveFunction&amp;&amp; resolveCompletionHandler)</span>
<span class="line-added">705 {</span>
<span class="line-added">706     auto result = executeUserAgentScriptInWorldInternal(world, WTFMove(parameters));</span>
<span class="line-added">707 </span>
<span class="line-added">708     if (parameters.runAsAsyncFunction == RunAsAsyncFunction::No || !result || !result.value().isObject()) {</span>
<span class="line-added">709         resolveCompletionHandler(result);</span>
<span class="line-added">710         return;</span>
<span class="line-added">711     }</span>
<span class="line-added">712 </span>
<span class="line-added">713     // When running JavaScript as an async function, any &quot;thenable&quot; object gets promise-like behavior of deferred completion.</span>
<span class="line-added">714     auto thenIdentifier = world.vm().propertyNames-&gt;then;</span>
<span class="line-added">715     auto&amp; proxy = jsWindowProxy(world);</span>
<span class="line-added">716     auto&amp; globalObject = *proxy.window();</span>
<span class="line-added">717 </span>
<span class="line-added">718     auto thenFunction = result.value().get(&amp;globalObject, thenIdentifier);</span>
<span class="line-added">719     if (!thenFunction.isObject()) {</span>
<span class="line-added">720         resolveCompletionHandler(result);</span>
<span class="line-added">721         return;</span>
<span class="line-added">722     }</span>
<span class="line-added">723 </span>
<span class="line-added">724     CallData callData;</span>
<span class="line-added">725     CallType callType = asObject(thenFunction)-&gt;methodTable(world.vm())-&gt;getCallData(asObject(thenFunction), callData);</span>
<span class="line-added">726     if (callType == CallType::None) {</span>
<span class="line-added">727         resolveCompletionHandler(result);</span>
<span class="line-added">728         return;</span>
<span class="line-added">729     }</span>
<span class="line-added">730 </span>
<span class="line-added">731     auto sharedResolveFunction = createSharedTask&lt;void(ValueOrException)&gt;([resolveCompletionHandler = WTFMove(resolveCompletionHandler)](ValueOrException result) mutable {</span>
<span class="line-added">732         if (resolveCompletionHandler)</span>
<span class="line-added">733             resolveCompletionHandler(result);</span>
<span class="line-added">734         resolveCompletionHandler = nullptr;</span>
<span class="line-added">735     });</span>
<span class="line-added">736 </span>
<span class="line-added">737     auto* fulfillHandler = JSC::JSNativeStdFunction::create(world.vm(), &amp;globalObject, 1, String { }, [sharedResolveFunction = sharedResolveFunction.copyRef()] (JSGlobalObject*, CallFrame* callFrame) mutable {</span>
<span class="line-added">738         sharedResolveFunction-&gt;run(callFrame-&gt;argument(0));</span>
<span class="line-added">739         return JSValue::encode(jsUndefined());</span>
<span class="line-added">740     });</span>
<span class="line-added">741 </span>
<span class="line-added">742     auto* rejectHandler = JSC::JSNativeStdFunction::create(world.vm(), &amp;globalObject, 1, String { }, [sharedResolveFunction = sharedResolveFunction.copyRef()] (JSGlobalObject* globalObject, CallFrame* callFrame) mutable {</span>
<span class="line-added">743         sharedResolveFunction-&gt;run(makeUnexpected(ExceptionDetails { callFrame-&gt;argument(0).toWTFString(globalObject) }));</span>
<span class="line-added">744         return JSValue::encode(jsUndefined());</span>
<span class="line-added">745     });</span>
<span class="line-added">746 </span>
<span class="line-added">747     auto finalizeCount = makeUniqueWithoutFastMallocCheck&lt;unsigned&gt;(0);</span>
<span class="line-added">748     auto finalizeGuard = createSharedTask&lt;void()&gt;([sharedResolveFunction = WTFMove(sharedResolveFunction), finalizeCount = WTFMove(finalizeCount)]() {</span>
<span class="line-added">749         if (++(*finalizeCount) == 2)</span>
<span class="line-added">750             sharedResolveFunction-&gt;run(makeUnexpected(ExceptionDetails { &quot;Completion handler for function call is no longer reachable&quot;_s }));</span>
<span class="line-added">751     });</span>
<span class="line-added">752 </span>
<span class="line-added">753     world.vm().heap.addFinalizer(fulfillHandler, [finalizeGuard = finalizeGuard.copyRef()](JSCell*) {</span>
<span class="line-added">754         finalizeGuard-&gt;run();</span>
<span class="line-added">755     });</span>
<span class="line-added">756     world.vm().heap.addFinalizer(rejectHandler, [finalizeGuard = finalizeGuard.copyRef()](JSCell*) {</span>
<span class="line-added">757         finalizeGuard-&gt;run();</span>
<span class="line-added">758     });</span>
<span class="line-added">759 </span>
<span class="line-added">760     JSC::MarkedArgumentBuffer arguments;</span>
<span class="line-added">761     arguments.append(fulfillHandler);</span>
<span class="line-added">762     arguments.append(rejectHandler);</span>
<span class="line-added">763 </span>
<span class="line-added">764     call(&amp;globalObject, thenFunction, callType, callData, result.value(), arguments);</span>
<span class="line-added">765 }</span>
<span class="line-added">766 </span>
<span class="line-added">767 Expected&lt;void, ExceptionDetails&gt; ScriptController::shouldAllowUserAgentScripts(Document&amp; document) const</span>
768 {
769 #if ENABLE(APPLE_PAY)
770     if (auto page = m_frame.page())
771         return page-&gt;paymentCoordinator().shouldAllowUserAgentScripts(document);
772 #else
773     UNUSED_PARAM(document);
774 #endif
<span class="line-modified">775     return { };</span>
776 }
777 
778 bool ScriptController::canExecuteScripts(ReasonForCallingCanExecuteScripts reason)
779 {
780     if (reason == AboutToExecuteScript)
781         RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(ScriptDisallowedScope::InMainThread::isScriptAllowed() || !isInWebProcess());
782 
783     if (m_frame.document() &amp;&amp; m_frame.document()-&gt;isSandboxed(SandboxScripts)) {
784         // FIXME: This message should be moved off the console once a solution to https://bugs.webkit.org/show_bug.cgi?id=103274 exists.
785         if (reason == AboutToExecuteScript || reason == AboutToCreateEventListener)
786             m_frame.document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;Blocked script execution in &#39;&quot; + m_frame.document()-&gt;url().stringCenterEllipsizedToLength() + &quot;&#39; because the document&#39;s frame is sandboxed and the &#39;allow-scripts&#39; permission is not set.&quot;);
787         return false;
788     }
789 
790     if (!m_frame.page())
791         return false;
792 
793     return m_frame.loader().client().allowScript(m_frame.settings().isScriptEnabled());
794 }
795 
<span class="line-modified">796 bool ScriptController::executeIfJavaScriptURL(const URL&amp; url, RefPtr&lt;SecurityOrigin&gt; requesterSecurityOrigin, ShouldReplaceDocumentIfJavaScriptURL shouldReplaceDocumentIfJavaScriptURL)</span>


















797 {
798     if (!WTF::protocolIsJavaScript(url))
799         return false;
800 
<span class="line-added">801     if (requesterSecurityOrigin &amp;&amp; !requesterSecurityOrigin-&gt;canAccess(m_frame.document()-&gt;securityOrigin()))</span>
<span class="line-added">802         return true;</span>
<span class="line-added">803 </span>
804     if (!m_frame.page() || !m_frame.document()-&gt;contentSecurityPolicy()-&gt;allowJavaScriptURLs(m_frame.document()-&gt;url(), eventHandlerPosition().m_line))
805         return true;
806 
807     // We need to hold onto the Frame here because executing script can
808     // destroy the frame.
809     Ref&lt;Frame&gt; protector(m_frame);
810     RefPtr&lt;Document&gt; ownerDocument(m_frame.document());
811 
812     const int javascriptSchemeLength = sizeof(&quot;javascript:&quot;) - 1;
813 
814     String decodedURL = decodeURLEscapeSequences(url.string());
<span class="line-modified">815     auto result = executeScriptIgnoringException(decodedURL.substring(javascriptSchemeLength));</span>
816 
817     // If executing script caused this frame to be removed from the page, we
818     // don&#39;t want to try to replace its document!
819     if (!m_frame.page())
820         return true;
821 
822     String scriptResult;
<span class="line-modified">823     if (!result || !result.getString(jsWindowProxy(mainThreadNormalWorld()).window(), scriptResult))</span>
824         return true;
825 
826     // FIXME: We should always replace the document, but doing so
827     //        synchronously can cause crashes:
828     //        http://bugs.webkit.org/show_bug.cgi?id=16782
829     if (shouldReplaceDocumentIfJavaScriptURL == ReplaceDocumentIfJavaScriptURL) {
830         // We&#39;re still in a frame, so there should be a DocumentLoader.
831         ASSERT(m_frame.document()-&gt;loader());
832 
833         // Signal to FrameLoader to disable navigations within this frame while replacing it with the result of executing javascript
834         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=200523
835         // The only reason we do a nestable save/restore of this flag here is because we sometimes nest javascript: url loads as
836         // some will load synchronously. We&#39;d like to remove those synchronous loads and then change this.
837         SetForScope&lt;bool&gt; willBeReplaced(m_willReplaceWithResultOfExecutingJavascriptURL, true);
838 
839         // DocumentWriter::replaceDocumentWithResultOfExecutingJavascriptURL can cause the DocumentLoader to get deref&#39;ed and possible destroyed,
840         // so protect it with a RefPtr.
841         if (RefPtr&lt;DocumentLoader&gt; loader = m_frame.document()-&gt;loader())
842             loader-&gt;writer().replaceDocumentWithResultOfExecutingJavascriptURL(scriptResult, ownerDocument.get());
843     }
</pre>
</td>
</tr>
</table>
<center><a href="ScheduledAction.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ScriptController.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
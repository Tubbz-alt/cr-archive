<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/ServiceWorkerThread.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ServiceWorkerFetch.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerThread.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/ServiceWorkerThread.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerThread.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;CacheStorageProvider.h&quot;
 32 #include &quot;ContentSecurityPolicyResponseHeaders.h&quot;

 33 #include &quot;EventNames.h&quot;
 34 #include &quot;ExtendableMessageEvent.h&quot;
 35 #include &quot;JSDOMPromise.h&quot;
 36 #include &quot;LoaderStrategy.h&quot;
 37 #include &quot;PlatformStrategies.h&quot;
 38 #include &quot;SWContextManager.h&quot;
 39 #include &quot;SecurityOrigin.h&quot;
 40 #include &quot;ServiceWorkerFetch.h&quot;
 41 #include &quot;ServiceWorkerGlobalScope.h&quot;
 42 #include &quot;ServiceWorkerWindowClient.h&quot;
 43 #include &quot;WorkerDebuggerProxy.h&quot;
 44 #include &quot;WorkerLoaderProxy.h&quot;
 45 #include &quot;WorkerObjectProxy.h&quot;
 46 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 47 #include &lt;JavaScriptCore/RuntimeFlags.h&gt;
<span class="line-removed"> 48 #include &lt;pal/SessionID.h&gt;</span>
 49 #include &lt;wtf/NeverDestroyed.h&gt;
 50 
 51 using namespace PAL;
 52 
 53 namespace WebCore {
 54 
 55 class DummyServiceWorkerThreadProxy : public WorkerObjectProxy {
 56 public:
 57     static DummyServiceWorkerThreadProxy&amp; shared()
 58     {
 59         static NeverDestroyed&lt;DummyServiceWorkerThreadProxy&gt; proxy;
 60         return proxy;
 61     }
 62 
 63 private:
 64     void postExceptionToWorkerObject(const String&amp;, int, int, const String&amp;) final { };
 65     void workerGlobalScopeDestroyed() final { };
 66     void postMessageToWorkerObject(MessageWithMessagePorts&amp;&amp;) final { };
 67     void confirmMessageFromWorkerObject(bool) final { };
 68     void reportPendingActivity(bool) final { };
 69 };
 70 
 71 // FIXME: Use a valid WorkerReportingProxy
 72 // FIXME: Use a valid WorkerObjectProxy
 73 // FIXME: Use valid runtime flags
 74 
<span class="line-modified"> 75 ServiceWorkerThread::ServiceWorkerThread(const ServiceWorkerContextData&amp; data, PAL::SessionID, String&amp;&amp; userAgent, WorkerLoaderProxy&amp; loaderProxy, WorkerDebuggerProxy&amp; debuggerProxy, IDBClient::IDBConnectionProxy* idbConnectionProxy, SocketProvider* socketProvider)</span>
<span class="line-modified"> 76     : WorkerThread(data.scriptURL, emptyString(), &quot;serviceworker:&quot; + Inspector::IdentifiersFactory::createIdentifier(), WTFMove(userAgent), platformStrategies()-&gt;loaderStrategy()-&gt;isOnLine(), data.script, loaderProxy, debuggerProxy, DummyServiceWorkerThreadProxy::shared(), WorkerThreadStartMode::Normal, data.contentSecurityPolicy, false, data.registration.key.topOrigin().securityOrigin().get(), MonotonicTime::now(), idbConnectionProxy, socketProvider, JSC::RuntimeFlags::createAllEnabled(), data.sessionID)</span>
 77     , m_data(data.isolatedCopy())
 78     , m_workerObjectProxy(DummyServiceWorkerThreadProxy::shared())


 79 {
 80     AtomString::init();
 81 }
 82 
 83 ServiceWorkerThread::~ServiceWorkerThread() = default;
 84 
<span class="line-modified"> 85 Ref&lt;WorkerGlobalScope&gt; ServiceWorkerThread::createWorkerGlobalScope(const URL&amp; url, Ref&lt;SecurityOrigin&gt;&amp;&amp; origin, const String&amp; name, const String&amp; identifier, const String&amp; userAgent, bool isOnline, const ContentSecurityPolicyResponseHeaders&amp; contentSecurityPolicy, bool shouldBypassMainWorldContentSecurityPolicy, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin, MonotonicTime timeOrigin, PAL::SessionID sessionID)</span>
 86 {
<span class="line-modified"> 87     UNUSED_PARAM(name);</span>
<span class="line-removed"> 88     return ServiceWorkerGlobalScope::create(m_data, url, WTFMove(origin), identifier, userAgent, isOnline, *this, contentSecurityPolicy, shouldBypassMainWorldContentSecurityPolicy, WTFMove(topOrigin), timeOrigin, idbConnectionProxy(), socketProvider(), sessionID);</span>
 89 }
 90 
 91 void ServiceWorkerThread::runEventLoop()
 92 {
 93     // FIXME: There will be ServiceWorker specific things to do here.
 94     WorkerThread::runEventLoop();
 95 }
 96 
<span class="line-modified"> 97 void ServiceWorkerThread::postFetchTask(Ref&lt;ServiceWorkerFetch::Client&gt;&amp;&amp; client, Optional&lt;ServiceWorkerClientIdentifier&gt;&amp;&amp; clientId, ResourceRequest&amp;&amp; request, String&amp;&amp; referrer, FetchOptions&amp;&amp; options)</span>
 98 {
<span class="line-modified"> 99     // FIXME: instead of directly using runLoop(), we should be using something like WorkerGlobalScopeProxy.</span>
<span class="line-modified">100     // FIXME: request and options come straigth from IPC so are already isolated. We should be able to take benefit of that.</span>
<span class="line-modified">101     runLoop().postTaskForMode([client = WTFMove(client), clientId, request = request.isolatedCopy(), referrer = referrer.isolatedCopy(), options = options.isolatedCopy()] (ScriptExecutionContext&amp; context) mutable {</span>
<span class="line-modified">102         context.postTask([client = WTFMove(client), clientId, request = WTFMove(request), referrer = WTFMove(referrer), options = WTFMove(options)] (ScriptExecutionContext&amp; context) mutable {</span>
<span class="line-removed">103             ServiceWorkerFetch::dispatchFetchEvent(WTFMove(client), downcast&lt;ServiceWorkerGlobalScope&gt;(context), clientId, WTFMove(request), WTFMove(referrer), WTFMove(options));</span>
<span class="line-removed">104         });</span>
<span class="line-removed">105     }, WorkerRunLoop::defaultMode());</span>
106 }
107 
108 static void fireMessageEvent(ServiceWorkerGlobalScope&amp; scope, MessageWithMessagePorts&amp;&amp; message, ExtendableMessageEventSource&amp;&amp; source, const URL&amp; sourceURL)
109 {
110     auto ports = MessagePort::entanglePorts(scope, WTFMove(message.transferredPorts));
111     auto messageEvent = ExtendableMessageEvent::create(WTFMove(ports), WTFMove(message.message), SecurityOriginData::fromURL(sourceURL).toString(), { }, source);
112     scope.dispatchEvent(messageEvent);
113     scope.thread().workerObjectProxy().confirmMessageFromWorkerObject(scope.hasPendingActivity());
114     scope.updateExtendedEventsSet(messageEvent.ptr());
115 }
116 
<span class="line-modified">117 void ServiceWorkerThread::postMessageToServiceWorker(MessageWithMessagePorts&amp;&amp; message, ServiceWorkerOrClientData&amp;&amp; sourceData)</span>
118 {
<span class="line-modified">119     runLoop().postTask([message = WTFMove(message), sourceData = WTFMove(sourceData)] (auto&amp; context) mutable {</span>
<span class="line-modified">120         auto&amp; serviceWorkerGlobalScope = downcast&lt;ServiceWorkerGlobalScope&gt;(context);</span>
121         URL sourceURL;
122         ExtendableMessageEventSource source;
123         if (WTF::holds_alternative&lt;ServiceWorkerClientData&gt;(sourceData)) {
124             RefPtr&lt;ServiceWorkerClient&gt; sourceClient = ServiceWorkerClient::getOrCreate(serviceWorkerGlobalScope, WTFMove(WTF::get&lt;ServiceWorkerClientData&gt;(sourceData)));
125 
<span class="line-modified">126             RELEASE_ASSERT(!sourceClient-&gt;url().protocolIsInHTTPFamily() || !serviceWorkerGlobalScope.url().protocolIsInHTTPFamily() || protocolHostAndPortAreEqual(serviceWorkerGlobalScope.url(), sourceClient-&gt;url()));</span>
127 
128             sourceURL = sourceClient-&gt;url();
129             source = WTFMove(sourceClient);
130         } else {
131             RefPtr&lt;ServiceWorker&gt; sourceWorker = ServiceWorker::getOrCreate(serviceWorkerGlobalScope, WTFMove(WTF::get&lt;ServiceWorkerData&gt;(sourceData)));
132 
<span class="line-modified">133             RELEASE_ASSERT(!sourceWorker-&gt;scriptURL().protocolIsInHTTPFamily() || !serviceWorkerGlobalScope.url().protocolIsInHTTPFamily() || protocolHostAndPortAreEqual(serviceWorkerGlobalScope.url(), sourceWorker-&gt;scriptURL()));</span>
134 
135             sourceURL = sourceWorker-&gt;scriptURL();
136             source = WTFMove(sourceWorker);
137         }
138         fireMessageEvent(serviceWorkerGlobalScope, WTFMove(message), ExtendableMessageEventSource { source }, sourceURL);




139     });
140 }
141 
<span class="line-modified">142 void ServiceWorkerThread::fireInstallEvent()</span>
143 {
<span class="line-modified">144     ScriptExecutionContext::Task task([jobDataIdentifier = m_data.jobDataIdentifier, serviceWorkerIdentifier = this-&gt;identifier()] (ScriptExecutionContext&amp; context) mutable {</span>
<span class="line-modified">145         context.postTask([jobDataIdentifier, serviceWorkerIdentifier](ScriptExecutionContext&amp; context) {</span>
<span class="line-modified">146             auto&amp; serviceWorkerGlobalScope = downcast&lt;ServiceWorkerGlobalScope&gt;(context);</span>
<span class="line-modified">147             auto installEvent = ExtendableEvent::create(eventNames().installEvent, { }, ExtendableEvent::IsTrusted::Yes);</span>
<span class="line-removed">148             serviceWorkerGlobalScope.dispatchEvent(installEvent);</span>
149 
<span class="line-modified">150             installEvent-&gt;whenAllExtendLifetimePromisesAreSettled([jobDataIdentifier, serviceWorkerIdentifier](HashSet&lt;Ref&lt;DOMPromise&gt;&gt;&amp;&amp; extendLifetimePromises) {</span>
<span class="line-modified">151                 bool hasRejectedAnyPromise = false;</span>
<span class="line-modified">152                 for (auto&amp; promise : extendLifetimePromises) {</span>
<span class="line-modified">153                     if (promise-&gt;status() == DOMPromise::Status::Rejected) {</span>
<span class="line-modified">154                         hasRejectedAnyPromise = true;</span>
<span class="line-modified">155                         break;</span>
<span class="line-removed">156                     }</span>
157                 }
<span class="line-modified">158                 callOnMainThread([jobDataIdentifier, serviceWorkerIdentifier, hasRejectedAnyPromise] () mutable {</span>
<span class="line-modified">159                     if (auto* connection = SWContextManager::singleton().connection())</span>
<span class="line-modified">160                         connection-&gt;didFinishInstall(jobDataIdentifier, serviceWorkerIdentifier, !hasRejectedAnyPromise);</span>
<span class="line-modified">161                 });</span>
162             });
163         });
164     });
<span class="line-removed">165     runLoop().postTask(WTFMove(task));</span>
166 }
167 
<span class="line-modified">168 void ServiceWorkerThread::fireActivateEvent()</span>
169 {
<span class="line-modified">170     ScriptExecutionContext::Task task([serviceWorkerIdentifier = this-&gt;identifier()] (ScriptExecutionContext&amp; context) mutable {</span>
<span class="line-modified">171         context.postTask([serviceWorkerIdentifier](ScriptExecutionContext&amp; context) {</span>
<span class="line-modified">172             auto&amp; serviceWorkerGlobalScope = downcast&lt;ServiceWorkerGlobalScope&gt;(context);</span>
<span class="line-modified">173             auto activateEvent = ExtendableEvent::create(eventNames().activateEvent, { }, ExtendableEvent::IsTrusted::Yes);</span>
<span class="line-removed">174             serviceWorkerGlobalScope.dispatchEvent(activateEvent);</span>
175 
<span class="line-modified">176             activateEvent-&gt;whenAllExtendLifetimePromisesAreSettled([serviceWorkerIdentifier](HashSet&lt;Ref&lt;DOMPromise&gt;&gt;&amp;&amp;) {</span>
<span class="line-modified">177                 callOnMainThread([serviceWorkerIdentifier] () mutable {</span>
<span class="line-modified">178                     if (auto* connection = SWContextManager::singleton().connection())</span>
<span class="line-modified">179                         connection-&gt;didFinishActivation(serviceWorkerIdentifier);</span>
<span class="line-removed">180                 });</span>
181             });
182         });
183     });
<span class="line-modified">184     runLoop().postTask(WTFMove(task));</span>




















































































































185 }
186 
187 } // namespace WebCore
188 
189 #endif // ENABLE(SERVICE_WORKER)
</pre>
</td>
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerThread.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;CacheStorageProvider.h&quot;
 32 #include &quot;ContentSecurityPolicyResponseHeaders.h&quot;
<span class="line-added"> 33 #include &quot;EventLoop.h&quot;</span>
 34 #include &quot;EventNames.h&quot;
 35 #include &quot;ExtendableMessageEvent.h&quot;
 36 #include &quot;JSDOMPromise.h&quot;
 37 #include &quot;LoaderStrategy.h&quot;
 38 #include &quot;PlatformStrategies.h&quot;
 39 #include &quot;SWContextManager.h&quot;
 40 #include &quot;SecurityOrigin.h&quot;
 41 #include &quot;ServiceWorkerFetch.h&quot;
 42 #include &quot;ServiceWorkerGlobalScope.h&quot;
 43 #include &quot;ServiceWorkerWindowClient.h&quot;
 44 #include &quot;WorkerDebuggerProxy.h&quot;
 45 #include &quot;WorkerLoaderProxy.h&quot;
 46 #include &quot;WorkerObjectProxy.h&quot;
 47 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 48 #include &lt;JavaScriptCore/RuntimeFlags.h&gt;

 49 #include &lt;wtf/NeverDestroyed.h&gt;
 50 
 51 using namespace PAL;
 52 
 53 namespace WebCore {
 54 
 55 class DummyServiceWorkerThreadProxy : public WorkerObjectProxy {
 56 public:
 57     static DummyServiceWorkerThreadProxy&amp; shared()
 58     {
 59         static NeverDestroyed&lt;DummyServiceWorkerThreadProxy&gt; proxy;
 60         return proxy;
 61     }
 62 
 63 private:
 64     void postExceptionToWorkerObject(const String&amp;, int, int, const String&amp;) final { };
 65     void workerGlobalScopeDestroyed() final { };
 66     void postMessageToWorkerObject(MessageWithMessagePorts&amp;&amp;) final { };
 67     void confirmMessageFromWorkerObject(bool) final { };
 68     void reportPendingActivity(bool) final { };
 69 };
 70 
 71 // FIXME: Use a valid WorkerReportingProxy
 72 // FIXME: Use a valid WorkerObjectProxy
 73 // FIXME: Use valid runtime flags
 74 
<span class="line-modified"> 75 ServiceWorkerThread::ServiceWorkerThread(const ServiceWorkerContextData&amp; data, String&amp;&amp; userAgent, WorkerLoaderProxy&amp; loaderProxy, WorkerDebuggerProxy&amp; debuggerProxy, IDBClient::IDBConnectionProxy* idbConnectionProxy, SocketProvider* socketProvider)</span>
<span class="line-modified"> 76     : WorkerThread({ data.scriptURL, emptyString(), &quot;serviceworker:&quot; + Inspector::IdentifiersFactory::createIdentifier(), WTFMove(userAgent), platformStrategies()-&gt;loaderStrategy()-&gt;isOnLine(), data.contentSecurityPolicy, false, MonotonicTime::now(), { } }, data.script, loaderProxy, debuggerProxy, DummyServiceWorkerThreadProxy::shared(), WorkerThreadStartMode::Normal, data.registration.key.topOrigin().securityOrigin().get(), idbConnectionProxy, socketProvider, JSC::RuntimeFlags::createAllEnabled())</span>
 77     , m_data(data.isolatedCopy())
 78     , m_workerObjectProxy(DummyServiceWorkerThreadProxy::shared())
<span class="line-added"> 79     , m_heartBeatTimeout(SWContextManager::singleton().connection()-&gt;shouldUseShortTimeout() ? heartBeatTimeoutForTest : heartBeatTimeout)</span>
<span class="line-added"> 80     , m_heartBeatTimer { *this, &amp;ServiceWorkerThread::heartBeatTimerFired }</span>
 81 {
 82     AtomString::init();
 83 }
 84 
 85 ServiceWorkerThread::~ServiceWorkerThread() = default;
 86 
<span class="line-modified"> 87 Ref&lt;WorkerGlobalScope&gt; ServiceWorkerThread::createWorkerGlobalScope(const WorkerParameters&amp; params, Ref&lt;SecurityOrigin&gt;&amp;&amp; origin, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin)</span>
 88 {
<span class="line-modified"> 89     return ServiceWorkerGlobalScope::create(m_data, params, WTFMove(origin), *this, WTFMove(topOrigin), idbConnectionProxy(), socketProvider());</span>

 90 }
 91 
 92 void ServiceWorkerThread::runEventLoop()
 93 {
 94     // FIXME: There will be ServiceWorker specific things to do here.
 95     WorkerThread::runEventLoop();
 96 }
 97 
<span class="line-modified"> 98 void ServiceWorkerThread::queueTaskToFireFetchEvent(Ref&lt;ServiceWorkerFetch::Client&gt;&amp;&amp; client, Optional&lt;ServiceWorkerClientIdentifier&gt;&amp;&amp; clientId, ResourceRequest&amp;&amp; request, String&amp;&amp; referrer, FetchOptions&amp;&amp; options)</span>
 99 {
<span class="line-modified">100     auto serviceWorkerGlobalScope = makeRef(downcast&lt;ServiceWorkerGlobalScope&gt;(*workerGlobalScope()));</span>
<span class="line-modified">101     serviceWorkerGlobalScope-&gt;eventLoop().queueTask(TaskSource::DOMManipulation, [serviceWorkerGlobalScope = serviceWorkerGlobalScope.copyRef(), client = WTFMove(client), clientId, request = WTFMove(request), referrer = WTFMove(referrer), options = WTFMove(options)]() mutable {</span>
<span class="line-modified">102         ServiceWorkerFetch::dispatchFetchEvent(WTFMove(client), serviceWorkerGlobalScope, clientId, WTFMove(request), WTFMove(referrer), WTFMove(options));</span>
<span class="line-modified">103     });</span>



104 }
105 
106 static void fireMessageEvent(ServiceWorkerGlobalScope&amp; scope, MessageWithMessagePorts&amp;&amp; message, ExtendableMessageEventSource&amp;&amp; source, const URL&amp; sourceURL)
107 {
108     auto ports = MessagePort::entanglePorts(scope, WTFMove(message.transferredPorts));
109     auto messageEvent = ExtendableMessageEvent::create(WTFMove(ports), WTFMove(message.message), SecurityOriginData::fromURL(sourceURL).toString(), { }, source);
110     scope.dispatchEvent(messageEvent);
111     scope.thread().workerObjectProxy().confirmMessageFromWorkerObject(scope.hasPendingActivity());
112     scope.updateExtendedEventsSet(messageEvent.ptr());
113 }
114 
<span class="line-modified">115 void ServiceWorkerThread::queueTaskToPostMessage(MessageWithMessagePorts&amp;&amp; message, ServiceWorkerOrClientData&amp;&amp; sourceData)</span>
116 {
<span class="line-modified">117     auto serviceWorkerGlobalScope = makeRef(downcast&lt;ServiceWorkerGlobalScope&gt;(*workerGlobalScope()));</span>
<span class="line-modified">118     serviceWorkerGlobalScope-&gt;eventLoop().queueTask(TaskSource::DOMManipulation, [serviceWorkerGlobalScope = serviceWorkerGlobalScope.copyRef(), message = WTFMove(message), sourceData = WTFMove(sourceData), serviceWorkerIdentifier = this-&gt;identifier()]() mutable {</span>
119         URL sourceURL;
120         ExtendableMessageEventSource source;
121         if (WTF::holds_alternative&lt;ServiceWorkerClientData&gt;(sourceData)) {
122             RefPtr&lt;ServiceWorkerClient&gt; sourceClient = ServiceWorkerClient::getOrCreate(serviceWorkerGlobalScope, WTFMove(WTF::get&lt;ServiceWorkerClientData&gt;(sourceData)));
123 
<span class="line-modified">124             RELEASE_ASSERT(!sourceClient-&gt;url().protocolIsInHTTPFamily() || !serviceWorkerGlobalScope-&gt;url().protocolIsInHTTPFamily() || protocolHostAndPortAreEqual(serviceWorkerGlobalScope-&gt;url(), sourceClient-&gt;url()));</span>
125 
126             sourceURL = sourceClient-&gt;url();
127             source = WTFMove(sourceClient);
128         } else {
129             RefPtr&lt;ServiceWorker&gt; sourceWorker = ServiceWorker::getOrCreate(serviceWorkerGlobalScope, WTFMove(WTF::get&lt;ServiceWorkerData&gt;(sourceData)));
130 
<span class="line-modified">131             RELEASE_ASSERT(!sourceWorker-&gt;scriptURL().protocolIsInHTTPFamily() || !serviceWorkerGlobalScope-&gt;url().protocolIsInHTTPFamily() || protocolHostAndPortAreEqual(serviceWorkerGlobalScope-&gt;url(), sourceWorker-&gt;scriptURL()));</span>
132 
133             sourceURL = sourceWorker-&gt;scriptURL();
134             source = WTFMove(sourceWorker);
135         }
136         fireMessageEvent(serviceWorkerGlobalScope, WTFMove(message), ExtendableMessageEventSource { source }, sourceURL);
<span class="line-added">137         callOnMainThread([serviceWorkerIdentifier] {</span>
<span class="line-added">138             if (auto* serviceWorkerThreadProxy = SWContextManager::singleton().serviceWorkerThreadProxy(serviceWorkerIdentifier))</span>
<span class="line-added">139                 serviceWorkerThreadProxy-&gt;thread().finishedFiringMessageEvent();</span>
<span class="line-added">140         });</span>
141     });
142 }
143 
<span class="line-modified">144 void ServiceWorkerThread::queueTaskToFireInstallEvent()</span>
145 {
<span class="line-modified">146     auto serviceWorkerGlobalScope = makeRef(downcast&lt;ServiceWorkerGlobalScope&gt;(*workerGlobalScope()));</span>
<span class="line-modified">147     serviceWorkerGlobalScope-&gt;eventLoop().queueTask(TaskSource::DOMManipulation, [serviceWorkerGlobalScope = serviceWorkerGlobalScope.copyRef(), jobDataIdentifier = m_data.jobDataIdentifier, serviceWorkerIdentifier = this-&gt;identifier()] {</span>
<span class="line-modified">148         auto installEvent = ExtendableEvent::create(eventNames().installEvent, { }, ExtendableEvent::IsTrusted::Yes);</span>
<span class="line-modified">149         serviceWorkerGlobalScope-&gt;dispatchEvent(installEvent);</span>

150 
<span class="line-modified">151         installEvent-&gt;whenAllExtendLifetimePromisesAreSettled([jobDataIdentifier, serviceWorkerIdentifier](HashSet&lt;Ref&lt;DOMPromise&gt;&gt;&amp;&amp; extendLifetimePromises) {</span>
<span class="line-modified">152             bool hasRejectedAnyPromise = false;</span>
<span class="line-modified">153             for (auto&amp; promise : extendLifetimePromises) {</span>
<span class="line-modified">154                 if (promise-&gt;status() == DOMPromise::Status::Rejected) {</span>
<span class="line-modified">155                     hasRejectedAnyPromise = true;</span>
<span class="line-modified">156                     break;</span>

157                 }
<span class="line-modified">158             }</span>
<span class="line-modified">159             callOnMainThread([serviceWorkerIdentifier, hasRejectedAnyPromise] {</span>
<span class="line-modified">160                 if (auto* serviceWorkerThreadProxy = SWContextManager::singleton().serviceWorkerThreadProxy(serviceWorkerIdentifier))</span>
<span class="line-modified">161                     serviceWorkerThreadProxy-&gt;thread().finishedFiringInstallEvent(hasRejectedAnyPromise);</span>
162             });
163         });
164     });

165 }
166 
<span class="line-modified">167 void ServiceWorkerThread::queueTaskToFireActivateEvent()</span>
168 {
<span class="line-modified">169     auto serviceWorkerGlobalScope = makeRef(downcast&lt;ServiceWorkerGlobalScope&gt;(*workerGlobalScope()));</span>
<span class="line-modified">170     serviceWorkerGlobalScope-&gt;eventLoop().queueTask(TaskSource::DOMManipulation, [serviceWorkerGlobalScope = serviceWorkerGlobalScope.copyRef(), serviceWorkerIdentifier = this-&gt;identifier()]() mutable {</span>
<span class="line-modified">171         auto activateEvent = ExtendableEvent::create(eventNames().activateEvent, { }, ExtendableEvent::IsTrusted::Yes);</span>
<span class="line-modified">172         serviceWorkerGlobalScope-&gt;dispatchEvent(activateEvent);</span>

173 
<span class="line-modified">174         activateEvent-&gt;whenAllExtendLifetimePromisesAreSettled([serviceWorkerIdentifier](HashSet&lt;Ref&lt;DOMPromise&gt;&gt;&amp;&amp;) {</span>
<span class="line-modified">175             callOnMainThread([serviceWorkerIdentifier] {</span>
<span class="line-modified">176                 if (auto* serviceWorkerThreadProxy = SWContextManager::singleton().serviceWorkerThreadProxy(serviceWorkerIdentifier))</span>
<span class="line-modified">177                     serviceWorkerThreadProxy-&gt;thread().finishedFiringActivateEvent();</span>

178             });
179         });
180     });
<span class="line-modified">181 }</span>
<span class="line-added">182 </span>
<span class="line-added">183 void ServiceWorkerThread::finishedEvaluatingScript()</span>
<span class="line-added">184 {</span>
<span class="line-added">185     ASSERT(!isMainThread());</span>
<span class="line-added">186     m_doesHandleFetch = workerGlobalScope()-&gt;hasEventListeners(eventNames().fetchEvent);</span>
<span class="line-added">187 }</span>
<span class="line-added">188 </span>
<span class="line-added">189 void ServiceWorkerThread::start(Function&lt;void(const String&amp;, bool)&gt;&amp;&amp; callback)</span>
<span class="line-added">190 {</span>
<span class="line-added">191     m_state = State::Starting;</span>
<span class="line-added">192     startHeartBeatTimer();</span>
<span class="line-added">193 </span>
<span class="line-added">194     WorkerThread::start([callback = WTFMove(callback), serviceWorkerIdentifier = this-&gt;identifier()](auto&amp; errorMessage) mutable {</span>
<span class="line-added">195         bool doesHandleFetch = true;</span>
<span class="line-added">196         if (auto* threadProxy = SWContextManager::singleton().workerByID(serviceWorkerIdentifier)) {</span>
<span class="line-added">197             threadProxy-&gt;thread().finishedStarting();</span>
<span class="line-added">198             doesHandleFetch = threadProxy-&gt;thread().doesHandleFetch();</span>
<span class="line-added">199         }</span>
<span class="line-added">200         callback(errorMessage, doesHandleFetch);</span>
<span class="line-added">201     });</span>
<span class="line-added">202 }</span>
<span class="line-added">203 </span>
<span class="line-added">204 void ServiceWorkerThread::finishedStarting()</span>
<span class="line-added">205 {</span>
<span class="line-added">206     m_state = State::Idle;</span>
<span class="line-added">207 }</span>
<span class="line-added">208 </span>
<span class="line-added">209 void ServiceWorkerThread::startFetchEventMonitoring()</span>
<span class="line-added">210 {</span>
<span class="line-added">211     m_isHandlingFetchEvent = true;</span>
<span class="line-added">212     startHeartBeatTimer();</span>
<span class="line-added">213 }</span>
<span class="line-added">214 </span>
<span class="line-added">215 void ServiceWorkerThread::startHeartBeatTimer()</span>
<span class="line-added">216 {</span>
<span class="line-added">217     if (m_heartBeatTimer.isActive())</span>
<span class="line-added">218         return;</span>
<span class="line-added">219 </span>
<span class="line-added">220     m_ongoingHeartBeatCheck = true;</span>
<span class="line-added">221     runLoop().postTask([this, protectedThis = makeRef(*this)](auto&amp;) mutable {</span>
<span class="line-added">222         callOnMainThread([this, protectedThis = WTFMove(protectedThis)]() {</span>
<span class="line-added">223             m_ongoingHeartBeatCheck = false;</span>
<span class="line-added">224         });</span>
<span class="line-added">225     });</span>
<span class="line-added">226 </span>
<span class="line-added">227     m_heartBeatTimer.startOneShot(m_heartBeatTimeout);</span>
<span class="line-added">228 }</span>
<span class="line-added">229 </span>
<span class="line-added">230 void ServiceWorkerThread::heartBeatTimerFired()</span>
<span class="line-added">231 {</span>
<span class="line-added">232     if (!m_ongoingHeartBeatCheck) {</span>
<span class="line-added">233         if (m_state == State::Installing || m_state == State::Activating || m_isHandlingFetchEvent || m_messageEventCount)</span>
<span class="line-added">234             startHeartBeatTimer();</span>
<span class="line-added">235         return;</span>
<span class="line-added">236     }</span>
<span class="line-added">237 </span>
<span class="line-added">238     auto* serviceWorkerThreadProxy = SWContextManager::singleton().serviceWorkerThreadProxy(identifier());</span>
<span class="line-added">239     if (!serviceWorkerThreadProxy || serviceWorkerThreadProxy-&gt;isTerminatingOrTerminated())</span>
<span class="line-added">240         return;</span>
<span class="line-added">241 </span>
<span class="line-added">242     auto* connection = SWContextManager::singleton().connection();</span>
<span class="line-added">243     if (!connection)</span>
<span class="line-added">244         return;</span>
<span class="line-added">245 </span>
<span class="line-added">246     switch (m_state) {</span>
<span class="line-added">247     case State::Idle:</span>
<span class="line-added">248     case State::Activating:</span>
<span class="line-added">249         connection-&gt;didFailHeartBeatCheck(identifier());</span>
<span class="line-added">250         break;</span>
<span class="line-added">251     case State::Starting:</span>
<span class="line-added">252         connection-&gt;serviceWorkerFailedToStart(m_data.jobDataIdentifier, identifier(), &quot;Service Worker script execution timed out&quot;_s);</span>
<span class="line-added">253         break;</span>
<span class="line-added">254     case State::Installing:</span>
<span class="line-added">255         connection-&gt;didFinishInstall(m_data.jobDataIdentifier, identifier(), false);</span>
<span class="line-added">256         break;</span>
<span class="line-added">257     }</span>
<span class="line-added">258 }</span>
<span class="line-added">259 </span>
<span class="line-added">260 void ServiceWorkerThread::willPostTaskToFireInstallEvent()</span>
<span class="line-added">261 {</span>
<span class="line-added">262     m_state = State::Installing;</span>
<span class="line-added">263     startHeartBeatTimer();</span>
<span class="line-added">264 }</span>
<span class="line-added">265 </span>
<span class="line-added">266 void ServiceWorkerThread::finishedFiringInstallEvent(bool hasRejectedAnyPromise)</span>
<span class="line-added">267 {</span>
<span class="line-added">268     m_state = State::Idle;</span>
<span class="line-added">269 </span>
<span class="line-added">270     if (auto* connection = SWContextManager::singleton().connection())</span>
<span class="line-added">271         connection-&gt;didFinishInstall(m_data.jobDataIdentifier, identifier(), !hasRejectedAnyPromise);</span>
<span class="line-added">272 }</span>
<span class="line-added">273 </span>
<span class="line-added">274 void ServiceWorkerThread::willPostTaskToFireActivateEvent()</span>
<span class="line-added">275 {</span>
<span class="line-added">276     m_state = State::Activating;</span>
<span class="line-added">277     startHeartBeatTimer();</span>
<span class="line-added">278 }</span>
<span class="line-added">279 </span>
<span class="line-added">280 void ServiceWorkerThread::finishedFiringActivateEvent()</span>
<span class="line-added">281 {</span>
<span class="line-added">282     m_state = State::Idle;</span>
<span class="line-added">283 </span>
<span class="line-added">284     if (auto* connection = SWContextManager::singleton().connection())</span>
<span class="line-added">285         connection-&gt;didFinishActivation(identifier());</span>
<span class="line-added">286 }</span>
<span class="line-added">287 </span>
<span class="line-added">288 void ServiceWorkerThread::willPostTaskToFireMessageEvent()</span>
<span class="line-added">289 {</span>
<span class="line-added">290     if (!m_messageEventCount++)</span>
<span class="line-added">291         startHeartBeatTimer();</span>
<span class="line-added">292 }</span>
<span class="line-added">293 </span>
<span class="line-added">294 void ServiceWorkerThread::finishedFiringMessageEvent()</span>
<span class="line-added">295 {</span>
<span class="line-added">296     ASSERT(m_messageEventCount);</span>
<span class="line-added">297     --m_messageEventCount;</span>
298 }
299 
300 } // namespace WebCore
301 
302 #endif // ENABLE(SERVICE_WORKER)
</pre>
</td>
</tr>
</table>
<center><a href="ServiceWorkerFetch.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="ServiceWorkerThread.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
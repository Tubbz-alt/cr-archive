<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayPrototype.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ArrayIteratorPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayPrototype.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ArrayPrototype.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
  20  *  USA
  21  *
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;ArrayPrototype.h&quot;
  26 
  27 #include &quot;AdaptiveInferredPropertyValueWatchpointBase.h&quot;
  28 #include &quot;ArrayConstructor.h&quot;
  29 #include &quot;BuiltinNames.h&quot;
  30 #include &quot;ButterflyInlines.h&quot;
  31 #include &quot;CodeBlock.h&quot;
  32 #include &quot;Error.h&quot;
  33 #include &quot;GetterSetter.h&quot;
  34 #include &quot;Interpreter.h&quot;
  35 #include &quot;JIT.h&quot;
  36 #include &quot;JSArrayInlines.h&quot;

  37 #include &quot;JSCBuiltins.h&quot;
  38 #include &quot;JSCInlines.h&quot;
  39 #include &quot;JSImmutableButterfly.h&quot;
  40 #include &quot;JSStringJoiner.h&quot;
  41 #include &quot;Lookup.h&quot;
  42 #include &quot;ObjectConstructor.h&quot;
  43 #include &quot;ObjectPrototype.h&quot;
  44 #include &quot;Operations.h&quot;
  45 #include &quot;StringRecursionChecker.h&quot;
  46 #include &lt;algorithm&gt;
  47 #include &lt;wtf/Assertions.h&gt;
  48 
  49 namespace JSC {
  50 
<span class="line-modified">  51 EncodedJSValue JSC_HOST_CALL arrayProtoFuncToLocaleString(ExecState*);</span>
<span class="line-modified">  52 EncodedJSValue JSC_HOST_CALL arrayProtoFuncJoin(ExecState*);</span>
<span class="line-modified">  53 EncodedJSValue JSC_HOST_CALL arrayProtoFuncPop(ExecState*);</span>
<span class="line-modified">  54 EncodedJSValue JSC_HOST_CALL arrayProtoFuncPush(ExecState*);</span>
<span class="line-modified">  55 EncodedJSValue JSC_HOST_CALL arrayProtoFuncReverse(ExecState*);</span>
<span class="line-modified">  56 EncodedJSValue JSC_HOST_CALL arrayProtoFuncShift(ExecState*);</span>
<span class="line-modified">  57 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState*);</span>
<span class="line-modified">  58 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(ExecState*);</span>
<span class="line-modified">  59 EncodedJSValue JSC_HOST_CALL arrayProtoFuncUnShift(ExecState*);</span>
<span class="line-modified">  60 EncodedJSValue JSC_HOST_CALL arrayProtoFuncIndexOf(ExecState*);</span>
<span class="line-modified">  61 EncodedJSValue JSC_HOST_CALL arrayProtoFuncLastIndexOf(ExecState*);</span>


  62 
  63 // ------------------------------ ArrayPrototype ----------------------------
  64 
  65 const ClassInfo ArrayPrototype::s_info = {&quot;Array&quot;, &amp;JSArray::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ArrayPrototype)};
  66 
  67 ArrayPrototype* ArrayPrototype::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
  68 {
  69     ArrayPrototype* prototype = new (NotNull, allocateCell&lt;ArrayPrototype&gt;(vm.heap)) ArrayPrototype(vm, structure);
  70     prototype-&gt;finishCreation(vm, globalObject);
  71     return prototype;
  72 }
  73 
  74 // ECMA 15.4.4
  75 ArrayPrototype::ArrayPrototype(VM&amp; vm, Structure* structure)
  76     : JSArray(vm, structure, 0)
  77 {
  78 }
  79 
  80 void ArrayPrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
  81 {
</pre>
<hr />
<pre>
  94     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().pushPublicName(), arrayProtoFuncPush, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, ArrayPushIntrinsic);
  95     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().pushPrivateName(), arrayProtoFuncPush, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, 1, ArrayPushIntrinsic);
  96     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;reverse&quot;, arrayProtoFuncReverse, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
  97     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().shiftPublicName(), arrayProtoFuncShift, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
  98     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().shiftPrivateName(), arrayProtoFuncShift, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, 0);
  99     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;slice, arrayProtoFuncSlice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, ArraySliceIntrinsic);
 100     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().sortPublicName(), arrayPrototypeSortCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 101     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;splice&quot;, arrayProtoFuncSplice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 102     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;unshift&quot;, arrayProtoFuncUnShift, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 103     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().everyPublicName(), arrayPrototypeEveryCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 104     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().forEachPublicName(), arrayPrototypeForEachCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 105     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().somePublicName(), arrayPrototypeSomeCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 106     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;indexOf&quot;, arrayProtoFuncIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, ArrayIndexOfIntrinsic);
 107     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;lastIndexOf&quot;, arrayProtoFuncLastIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 108     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().filterPublicName(), arrayPrototypeFilterCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 109     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().flatPublicName(), arrayPrototypeFlatCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 110     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().flatMapPublicName(), arrayPrototypeFlatMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 111     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().reducePublicName(), arrayPrototypeReduceCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 112     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().reduceRightPublicName(), arrayPrototypeReduceRightCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 113     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().mapPublicName(), arrayPrototypeMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
<span class="line-modified"> 114     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().entriesPublicName(), arrayPrototypeEntriesCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
<span class="line-modified"> 115     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().keysPublicName(), arrayPrototypeKeysCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
 116     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().findPublicName(), arrayPrototypeFindCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 117     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().findIndexPublicName(), arrayPrototypeFindIndexCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 118     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().includesPublicName(), arrayPrototypeIncludesCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 119     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().copyWithinPublicName(), arrayPrototypeCopyWithinCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 120 
 121     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().entriesPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().entriesPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 122     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().forEachPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().forEachPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 123     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().keysPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().keysPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 124     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().valuesPrivateName(), globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 125 
<span class="line-modified"> 126     JSObject* unscopables = constructEmptyObject(globalObject-&gt;globalExec(), globalObject-&gt;nullPrototypeObjectStructure());</span>
 127     unscopables-&gt;convertToDictionary(vm);
 128     const Identifier* const unscopableNames[] = {
 129         &amp;vm.propertyNames-&gt;builtinNames().copyWithinPublicName(),
 130         &amp;vm.propertyNames-&gt;builtinNames().entriesPublicName(),
 131         &amp;vm.propertyNames-&gt;builtinNames().fillPublicName(),
 132         &amp;vm.propertyNames-&gt;builtinNames().findPublicName(),
 133         &amp;vm.propertyNames-&gt;builtinNames().findIndexPublicName(),
 134         &amp;vm.propertyNames-&gt;builtinNames().flatPublicName(),
 135         &amp;vm.propertyNames-&gt;builtinNames().flatMapPublicName(),
 136         &amp;vm.propertyNames-&gt;builtinNames().includesPublicName(),
 137         &amp;vm.propertyNames-&gt;builtinNames().keysPublicName(),
 138         &amp;vm.propertyNames-&gt;builtinNames().valuesPublicName()
 139     };
 140     for (const auto* unscopableName : unscopableNames)
 141         unscopables-&gt;putDirect(vm, *unscopableName, jsBoolean(true));
 142     putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, unscopables, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 143 }
 144 
 145 // ------------------------------ Array Functions ----------------------------
 146 
<span class="line-modified"> 147 static ALWAYS_INLINE JSValue getProperty(ExecState* exec, JSObject* object, unsigned index)</span>
 148 {
<span class="line-modified"> 149     VM&amp; vm = exec-&gt;vm();</span>
 150     auto scope = DECLARE_THROW_SCOPE(vm);
 151 
 152     if (JSValue result = object-&gt;tryGetIndexQuickly(index))
 153         return result;
 154     // We want to perform get and has in the same operation.
 155     // We can only do so when this behavior is not observable. The
 156     // only time it is observable is when we encounter an opaque objects (ProxyObject and JSModuleNamespaceObject)
 157     // somewhere in the prototype chain.
 158     PropertySlot slot(object, PropertySlot::InternalMethodType::HasProperty);
<span class="line-modified"> 159     bool hasProperty = object-&gt;getPropertySlot(exec, index, slot);</span>
 160     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
 161     if (!hasProperty)
 162         return { };
 163     if (UNLIKELY(slot.isTaintedByOpaqueObject()))
<span class="line-modified"> 164         RELEASE_AND_RETURN(scope, object-&gt;get(exec, index));</span>
 165 
<span class="line-modified"> 166     RELEASE_AND_RETURN(scope, slot.getValue(exec, index));</span>
 167 }
 168 
<span class="line-modified"> 169 static ALWAYS_INLINE bool putLength(ExecState* exec, VM&amp; vm, JSObject* obj, JSValue value)</span>
 170 {

 171     PutPropertySlot slot(obj);
<span class="line-modified"> 172     return obj-&gt;methodTable(vm)-&gt;put(obj, exec, vm.propertyNames-&gt;length, value, slot);</span>



 173 }
 174 
<span class="line-modified"> 175 static ALWAYS_INLINE void setLength(ExecState* exec, VM&amp; vm, JSObject* obj, unsigned value)</span>
 176 {
 177     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 178     static const bool throwException = true;</span>
 179     if (isJSArray(obj)) {
<span class="line-modified"> 180         jsCast&lt;JSArray*&gt;(obj)-&gt;setLength(exec, value, throwException);</span>
 181         RETURN_IF_EXCEPTION(scope, void());
 182     }
<span class="line-modified"> 183     bool success = putLength(exec, vm, obj, jsNumber(value));</span>
<span class="line-modified"> 184     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-removed"> 185     if (UNLIKELY(!success))</span>
<span class="line-removed"> 186         throwTypeError(exec, scope, ReadonlyPropertyWriteError);</span>
 187 }
 188 
 189 namespace ArrayPrototypeInternal {
 190 static bool verbose = false;
 191 }
 192 
<span class="line-modified"> 193 ALWAYS_INLINE bool speciesWatchpointIsValid(ExecState* exec, JSObject* thisObject)</span>
 194 {
<span class="line-removed"> 195     VM&amp; vm = exec-&gt;vm();</span>
 196     JSGlobalObject* globalObject = thisObject-&gt;globalObject(vm);
 197     ArrayPrototype* arrayPrototype = globalObject-&gt;arrayPrototype();
 198 
 199     if (globalObject-&gt;arraySpeciesWatchpointSet().stateOnJSThread() == ClearWatchpoint) {
 200         dataLogLnIf(ArrayPrototypeInternal::verbose, &quot;Initializing Array species watchpoints for Array.prototype: &quot;, pointerDump(arrayPrototype), &quot; with structure: &quot;, pointerDump(arrayPrototype-&gt;structure(vm)), &quot;\nand Array: &quot;, pointerDump(globalObject-&gt;arrayConstructor()), &quot; with structure: &quot;, pointerDump(globalObject-&gt;arrayConstructor()-&gt;structure(vm)));
<span class="line-modified"> 201         globalObject-&gt;tryInstallArraySpeciesWatchpoint(exec);</span>
 202         ASSERT(globalObject-&gt;arraySpeciesWatchpointSet().stateOnJSThread() != ClearWatchpoint);
 203     }
 204 
 205     return !thisObject-&gt;hasCustomProperties(vm)
 206         &amp;&amp; arrayPrototype == thisObject-&gt;getPrototypeDirect(vm)
 207         &amp;&amp; globalObject-&gt;arraySpeciesWatchpointSet().stateOnJSThread() == IsWatched;
 208 }
 209 
 210 enum class SpeciesConstructResult {
 211     FastPath,
 212     Exception,
 213     CreatedObject
 214 };
 215 
<span class="line-modified"> 216 static ALWAYS_INLINE std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesConstructArray(ExecState* exec, JSObject* thisObject, uint64_t length)</span>
 217 {
<span class="line-modified"> 218     VM&amp; vm = exec-&gt;vm();</span>
 219     auto scope = DECLARE_THROW_SCOPE(vm);
 220 
 221     auto exceptionResult = [] () {
 222         return std::make_pair(SpeciesConstructResult::Exception, nullptr);
 223     };
 224 
 225     // ECMA 9.4.2.3: https://tc39.github.io/ecma262/#sec-arrayspeciescreate
 226     JSValue constructor = jsUndefined();
<span class="line-modified"> 227     bool thisIsArray = isArray(exec, thisObject);</span>
 228     RETURN_IF_EXCEPTION(scope, exceptionResult());
 229     if (LIKELY(thisIsArray)) {
 230         // Fast path in the normal case where the user has not set an own constructor and the Array.prototype.constructor is normal.
 231         // We need prototype check for subclasses of Array, which are Array objects but have a different prototype by default.
<span class="line-modified"> 232         bool isValid = speciesWatchpointIsValid(exec, thisObject);</span>
 233         scope.assertNoException();
 234         if (LIKELY(isValid))
 235             return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 236 
<span class="line-modified"> 237         constructor = thisObject-&gt;get(exec, vm.propertyNames-&gt;constructor);</span>
 238         RETURN_IF_EXCEPTION(scope, exceptionResult());
 239         if (constructor.isConstructor(vm)) {
 240             JSObject* constructorObject = jsCast&lt;JSObject*&gt;(constructor);
<span class="line-modified"> 241             bool isArrayConstructorFromAnotherRealm = exec-&gt;lexicalGlobalObject() != constructorObject-&gt;globalObject(vm)</span>
 242                 &amp;&amp; constructorObject-&gt;inherits&lt;ArrayConstructor&gt;(vm);
 243             if (isArrayConstructorFromAnotherRealm)
 244                 return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 245         }
 246         if (constructor.isObject()) {
<span class="line-modified"> 247             constructor = constructor.get(exec, vm.propertyNames-&gt;speciesSymbol);</span>
 248             RETURN_IF_EXCEPTION(scope, exceptionResult());
 249             if (constructor.isNull())
 250                 return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 251         }
 252     } else {
 253         // If isArray is false, return ? ArrayCreate(length).
 254         return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 255     }
 256 
 257     if (constructor.isUndefined())
 258         return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 259 
 260     MarkedArgumentBuffer args;
 261     args.append(jsNumber(length));
 262     ASSERT(!args.hasOverflowed());
<span class="line-modified"> 263     JSObject* newObject = construct(exec, constructor, args, &quot;Species construction did not get a valid constructor&quot;);</span>
 264     RETURN_IF_EXCEPTION(scope, exceptionResult());
 265     return std::make_pair(SpeciesConstructResult::CreatedObject, newObject);
 266 }
 267 
<span class="line-modified"> 268 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSpeciesCreate(ExecState* exec)</span>
 269 {
<span class="line-modified"> 270     VM&amp; vm = exec-&gt;vm();</span>
 271     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 272     JSObject* object = asObject(exec-&gt;uncheckedArgument(0));</span>
<span class="line-modified"> 273     uint64_t length = static_cast&lt;uint64_t&gt;(exec-&gt;uncheckedArgument(1).asNumber());</span>
 274 
<span class="line-modified"> 275     std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(exec, object, length);</span>
 276     EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
 277     if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
 278         return { };
 279     if (speciesResult.first == SpeciesConstructResult::CreatedObject)
 280         return JSValue::encode(speciesResult.second);
 281 
 282     if (length &gt; std::numeric_limits&lt;unsigned&gt;::max()) {
<span class="line-modified"> 283         throwRangeError(exec, scope, &quot;Array size is not a small enough positive integer.&quot;_s);</span>
 284         return { };
 285     }
 286 
<span class="line-modified"> 287     RELEASE_AND_RETURN(scope, JSValue::encode(constructEmptyArray(exec, nullptr, static_cast&lt;unsigned&gt;(length))));</span>
 288 }
 289 
<span class="line-modified"> 290 static inline unsigned argumentClampedIndexFromStartOrEnd(ExecState* exec, int argument, unsigned length, unsigned undefinedValue = 0)</span>
 291 {
<span class="line-removed"> 292     JSValue value = exec-&gt;argument(argument);</span>
 293     if (value.isUndefined())
 294         return undefinedValue;
 295 
<span class="line-modified"> 296     double indexDouble = value.toInteger(exec);</span>
 297     if (indexDouble &lt; 0) {
 298         indexDouble += length;
 299         return indexDouble &lt; 0 ? 0 : static_cast&lt;unsigned&gt;(indexDouble);
 300     }
 301     return indexDouble &gt; length ? length : static_cast&lt;unsigned&gt;(indexDouble);
 302 }
 303 
 304 // The shift/unshift function implement the shift/unshift behaviour required
 305 // by the corresponding array prototype methods, and by splice. In both cases,
 306 // the methods are operating an an array or array like object.
 307 //
 308 //  header  currentCount  (remainder)
 309 // [------][------------][-----------]
 310 //  header  resultCount  (remainder)
 311 // [------][-----------][-----------]
 312 //
 313 // The set of properties in the range &#39;header&#39; must be unchanged. The set of
 314 // properties in the range &#39;remainder&#39; (where remainder = length - header -
 315 // currentCount) will be shifted to the left or right as appropriate; in the
 316 // case of shift this must be removing values, in the case of unshift this
 317 // must be introducing new values.
 318 
 319 template&lt;JSArray::ShiftCountMode shiftCountMode&gt;
<span class="line-modified"> 320 void shift(ExecState* exec, JSObject* thisObj, unsigned header, unsigned currentCount, unsigned resultCount, unsigned length)</span>
 321 {
<span class="line-modified"> 322     VM&amp; vm = exec-&gt;vm();</span>
 323     auto scope = DECLARE_THROW_SCOPE(vm);
 324 
 325     RELEASE_ASSERT(currentCount &gt; resultCount);
 326     unsigned count = currentCount - resultCount;
 327 
 328     RELEASE_ASSERT(header &lt;= length);
 329     RELEASE_ASSERT(currentCount &lt;= (length - header));
 330 
 331     if (isJSArray(thisObj)) {
 332         JSArray* array = asArray(thisObj);
<span class="line-modified"> 333         if (array-&gt;length() == length &amp;&amp; array-&gt;shiftCount&lt;shiftCountMode&gt;(exec, header, count))</span>
 334             return;
 335     }
 336 
 337     for (unsigned k = header; k &lt; length - currentCount; ++k) {
 338         unsigned from = k + currentCount;
 339         unsigned to = k + resultCount;
<span class="line-modified"> 340         JSValue value = getProperty(exec, thisObj, from);</span>
 341         RETURN_IF_EXCEPTION(scope, void());
 342         if (value) {
<span class="line-modified"> 343             thisObj-&gt;putByIndexInline(exec, to, value, true);</span>
 344             RETURN_IF_EXCEPTION(scope, void());
 345         } else {
<span class="line-modified"> 346             bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, exec, to);</span>
 347             RETURN_IF_EXCEPTION(scope, void());
 348             if (!success) {
<span class="line-modified"> 349                 throwTypeError(exec, scope, UnableToDeletePropertyError);</span>
 350                 return;
 351             }
 352         }
 353     }
 354     for (unsigned k = length; k &gt; length - count; --k) {
<span class="line-modified"> 355         bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, exec, k - 1);</span>
 356         RETURN_IF_EXCEPTION(scope, void());
 357         if (!success) {
<span class="line-modified"> 358             throwTypeError(exec, scope, UnableToDeletePropertyError);</span>
 359             return;
 360         }
 361     }
 362 }
 363 
 364 template&lt;JSArray::ShiftCountMode shiftCountMode&gt;
<span class="line-modified"> 365 void unshift(ExecState* exec, JSObject* thisObj, unsigned header, unsigned currentCount, unsigned resultCount, unsigned length)</span>
 366 {
<span class="line-modified"> 367     VM&amp; vm = exec-&gt;vm();</span>
 368     auto scope = DECLARE_THROW_SCOPE(vm);
 369 
 370     RELEASE_ASSERT(resultCount &gt; currentCount);
 371     unsigned count = resultCount - currentCount;
 372 
 373     RELEASE_ASSERT(header &lt;= length);
 374     RELEASE_ASSERT(currentCount &lt;= (length - header));
 375 
 376     // Guard against overflow.
 377     if (count &gt; UINT_MAX - length) {
<span class="line-modified"> 378         throwOutOfMemoryError(exec, scope);</span>
 379         return;
 380     }
 381 
 382     if (isJSArray(thisObj)) {
 383         JSArray* array = asArray(thisObj);
 384         if (array-&gt;length() == length) {
<span class="line-modified"> 385             bool handled = array-&gt;unshiftCount&lt;shiftCountMode&gt;(exec, header, count);</span>
 386             EXCEPTION_ASSERT(!scope.exception() || handled);
 387             if (handled)
 388                 return;
 389         }
 390     }
 391 
 392     for (unsigned k = length - currentCount; k &gt; header; --k) {
 393         unsigned from = k + currentCount - 1;
 394         unsigned to = k + resultCount - 1;
<span class="line-modified"> 395         JSValue value = getProperty(exec, thisObj, from);</span>
 396         RETURN_IF_EXCEPTION(scope, void());
 397         if (value) {
<span class="line-modified"> 398             thisObj-&gt;putByIndexInline(exec, to, value, true);</span>
 399             RETURN_IF_EXCEPTION(scope, void());
 400         } else {
<span class="line-modified"> 401             bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, exec, to);</span>
 402             RETURN_IF_EXCEPTION(scope, void());
 403             if (UNLIKELY(!success)) {
<span class="line-modified"> 404                 throwTypeError(exec, scope, UnableToDeletePropertyError);</span>
 405                 return;
 406             }
 407         }
 408     }
 409 }
 410 
 411 inline bool canUseFastJoin(const JSObject* thisObject)
 412 {
 413     switch (thisObject-&gt;indexingType()) {
 414     case ALL_CONTIGUOUS_INDEXING_TYPES:
 415     case ALL_INT32_INDEXING_TYPES:
 416     case ALL_DOUBLE_INDEXING_TYPES:
 417     case ALL_UNDECIDED_INDEXING_TYPES:
 418         return true;
 419     default:
 420         break;
 421     }
 422     return false;
 423 }
 424 
</pre>
<hr />
<pre>
 430 inline bool isHole(double value)
 431 {
 432     return std::isnan(value);
 433 }
 434 
 435 inline bool isHole(const WriteBarrier&lt;Unknown&gt;&amp; value)
 436 {
 437     return !value;
 438 }
 439 
 440 template&lt;typename T&gt;
 441 inline bool containsHole(T* data, unsigned length)
 442 {
 443     for (unsigned i = 0; i &lt; length; ++i) {
 444         if (isHole(data[i]))
 445             return true;
 446     }
 447     return false;
 448 }
 449 
<span class="line-modified"> 450 inline JSValue fastJoin(ExecState&amp; state, JSObject* thisObject, StringView separator, unsigned length, bool* sawHoles = nullptr)</span>
 451 {
<span class="line-modified"> 452     VM&amp; vm = state.vm();</span>
 453     auto scope = DECLARE_THROW_SCOPE(vm);
 454 
 455     switch (thisObject-&gt;indexingType()) {
 456     case ALL_INT32_INDEXING_TYPES: {
 457         auto&amp; butterfly = *thisObject-&gt;butterfly();
 458         if (UNLIKELY(length &gt; butterfly.publicLength()))
 459             break;
<span class="line-modified"> 460         JSStringJoiner joiner(state, separator, length);</span>
 461         RETURN_IF_EXCEPTION(scope, { });
 462         auto data = butterfly.contiguous().data();
 463         bool holesKnownToBeOK = false;
 464         for (unsigned i = 0; i &lt; length; ++i) {
 465             JSValue value = data[i].get();
 466             if (LIKELY(value))
 467                 joiner.appendNumber(vm, value.asInt32());
 468             else {
 469                 if (sawHoles)
 470                     *sawHoles = true;
 471                 if (!holesKnownToBeOK) {
 472                     if (holesMustForwardToPrototype(vm, thisObject))
 473                         goto generalCase;
 474                     holesKnownToBeOK = true;
 475                 }
 476                 joiner.appendEmptyString();
 477             }
 478         }
<span class="line-modified"> 479         RELEASE_AND_RETURN(scope, joiner.join(state));</span>
 480     }
 481     case ALL_CONTIGUOUS_INDEXING_TYPES: {
 482         auto&amp; butterfly = *thisObject-&gt;butterfly();
 483         if (UNLIKELY(length &gt; butterfly.publicLength()))
 484             break;
<span class="line-modified"> 485         JSStringJoiner joiner(state, separator, length);</span>
 486         RETURN_IF_EXCEPTION(scope, { });
 487         auto data = butterfly.contiguous().data();
 488         bool holesKnownToBeOK = false;
 489         for (unsigned i = 0; i &lt; length; ++i) {
 490             if (JSValue value = data[i].get()) {
<span class="line-modified"> 491                 if (!joiner.appendWithoutSideEffects(state, value))</span>
 492                     goto generalCase;

 493             } else {
 494                 if (sawHoles)
 495                     *sawHoles = true;
 496                 if (!holesKnownToBeOK) {
 497                     if (holesMustForwardToPrototype(vm, thisObject))
 498                         goto generalCase;
 499                     holesKnownToBeOK = true;
 500                 }
 501                 joiner.appendEmptyString();
 502             }
 503         }
<span class="line-modified"> 504         RELEASE_AND_RETURN(scope, joiner.join(state));</span>
 505     }
 506     case ALL_DOUBLE_INDEXING_TYPES: {
 507         auto&amp; butterfly = *thisObject-&gt;butterfly();
 508         if (UNLIKELY(length &gt; butterfly.publicLength()))
 509             break;
<span class="line-modified"> 510         JSStringJoiner joiner(state, separator, length);</span>
 511         RETURN_IF_EXCEPTION(scope, { });
 512         auto data = butterfly.contiguousDouble().data();
 513         bool holesKnownToBeOK = false;
 514         for (unsigned i = 0; i &lt; length; ++i) {
 515             double value = data[i];
 516             if (LIKELY(!isHole(value)))
 517                 joiner.appendNumber(vm, value);
 518             else {
 519                 if (sawHoles)
 520                     *sawHoles = true;
 521                 if (!holesKnownToBeOK) {
 522                     if (holesMustForwardToPrototype(vm, thisObject))
 523                         goto generalCase;
 524                     holesKnownToBeOK = true;
 525                 }
 526                 joiner.appendEmptyString();
 527             }
 528         }
<span class="line-modified"> 529         RELEASE_AND_RETURN(scope, joiner.join(state));</span>
 530     }
 531     case ALL_UNDECIDED_INDEXING_TYPES: {
 532         if (length &amp;&amp; holesMustForwardToPrototype(vm, thisObject))
 533             goto generalCase;
 534         switch (separator.length()) {
 535         case 0:
 536             RELEASE_AND_RETURN(scope, jsEmptyString(vm));
 537         case 1: {
 538             if (length &lt;= 1)
 539                 RELEASE_AND_RETURN(scope, jsEmptyString(vm));
 540             if (separator.is8Bit())
<span class="line-modified"> 541                 RELEASE_AND_RETURN(scope, repeatCharacter(state, separator.characters8()[0], length - 1));</span>
<span class="line-modified"> 542             RELEASE_AND_RETURN(scope, repeatCharacter(state, separator.characters16()[0], length - 1));</span>
 543         default:
 544             JSString* result = jsEmptyString(vm);
 545             if (length &lt;= 1)
 546                 return result;
 547 
 548             JSString* operand = jsString(vm, separator.toString());
 549             RETURN_IF_EXCEPTION(scope, { });
 550             unsigned count = length - 1;
 551             for (;;) {
 552                 if (count &amp; 1) {
<span class="line-modified"> 553                     result = jsString(&amp;state, result, operand);</span>
 554                     RETURN_IF_EXCEPTION(scope, { });
 555                 }
 556                 count &gt;&gt;= 1;
 557                 if (!count)
 558                     return result;
<span class="line-modified"> 559                 operand = jsString(&amp;state, operand, operand);</span>
 560                 RETURN_IF_EXCEPTION(scope, { });
 561             }
 562         }
 563         }
 564     }
 565     }
 566 
 567 generalCase:
<span class="line-modified"> 568     JSStringJoiner joiner(state, separator, length);</span>
 569     RETURN_IF_EXCEPTION(scope, { });
 570     for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified"> 571         JSValue element = thisObject-&gt;getIndex(&amp;state, i);</span>
 572         RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified"> 573         joiner.append(state, element);</span>
 574         RETURN_IF_EXCEPTION(scope, { });
 575     }
<span class="line-modified"> 576     RELEASE_AND_RETURN(scope, joiner.join(state));</span>
 577 }
 578 
 579 inline bool canUseDefaultArrayJoinForToString(VM&amp; vm, JSObject* thisObject)
 580 {
 581     JSGlobalObject* globalObject = thisObject-&gt;globalObject();
 582 
 583     if (globalObject-&gt;arrayJoinWatchpointSet().stateOnJSThread() != IsWatched)
 584         return false;
 585 
 586     Structure* structure = thisObject-&gt;structure(vm);
 587 
 588     // This is the fast case. Many arrays will be an original array.
 589     // We are doing very simple check here. If we do more complicated checks like looking into getDirect &quot;join&quot; of thisObject,
 590     // it would be possible that just looking into &quot;join&quot; function will show the same performance.
 591     return globalObject-&gt;isOriginalArrayStructure(structure);
 592 }
 593 
<span class="line-modified"> 594 EncodedJSValue JSC_HOST_CALL arrayProtoFuncToString(ExecState* exec)</span>
 595 {
<span class="line-modified"> 596     VM&amp; vm = exec-&gt;vm();</span>
 597     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 598     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);</span>
 599 
 600     // 1. Let array be the result of calling ToObject on the this value.
<span class="line-modified"> 601     JSObject* thisObject = thisValue.toObject(exec);</span>
 602     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 603 
 604     if (!canUseDefaultArrayJoinForToString(vm, thisObject)) {
 605         // 2. Let func be the result of calling the [[Get]] internal method of array with argument &quot;join&quot;.
<span class="line-modified"> 606         JSValue function = JSValue(thisObject).get(exec, vm.propertyNames-&gt;join);</span>
 607         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 608 
 609         // 3. If IsCallable(func) is false, then let func be the standard built-in method Object.prototype.toString (15.2.4.2).
 610         bool customJoinCase = false;
 611         if (!function.isCell())
 612             customJoinCase = true;
 613         CallData callData;
 614         CallType callType = getCallData(vm, function, callData);
 615         if (callType == CallType::None)
 616             customJoinCase = true;
 617 
 618         if (UNLIKELY(customJoinCase))
<span class="line-modified"> 619             RELEASE_AND_RETURN(scope, JSValue::encode(jsMakeNontrivialString(exec, &quot;[object &quot;, thisObject-&gt;methodTable(vm)-&gt;className(thisObject, vm), &quot;]&quot;)));</span>
 620 
 621         // 4. Return the result of calling the [[Call]] internal method of func providing array as the this value and an empty arguments list.
 622         if (!isJSArray(thisObject) || callType != CallType::Host || callData.native.function != arrayProtoFuncJoin)
<span class="line-modified"> 623             RELEASE_AND_RETURN(scope, JSValue::encode(call(exec, function, callType, callData, thisObject, *vm.emptyList)));</span>
 624     }
 625 
 626     ASSERT(isJSArray(thisValue));
 627     JSArray* thisArray = asArray(thisValue);
 628 
 629     unsigned length = thisArray-&gt;length();
 630 
<span class="line-modified"> 631     StringRecursionChecker checker(exec, thisArray);</span>
 632     EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
 633     if (JSValue earlyReturnValue = checker.earlyReturnValue())
 634         return JSValue::encode(earlyReturnValue);
 635 
 636     if (LIKELY(canUseFastJoin(thisArray))) {
 637         const LChar comma = &#39;,&#39;;
 638         scope.release();
 639 
 640         bool isCoW = isCopyOnWrite(thisArray-&gt;indexingMode());
 641         JSImmutableButterfly* immutableButterfly = nullptr;
 642         if (isCoW) {
 643             immutableButterfly = JSImmutableButterfly::fromButterfly(thisArray-&gt;butterfly());
 644             auto iter = vm.heap.immutableButterflyToStringCache.find(immutableButterfly);
 645             if (iter != vm.heap.immutableButterflyToStringCache.end())
 646                 return JSValue::encode(iter-&gt;value);
 647         }
 648 
 649         bool sawHoles = false;
<span class="line-modified"> 650         JSValue result = fastJoin(*exec, thisArray, { &amp;comma, 1 }, length, &amp;sawHoles);</span>
 651 
 652         if (!sawHoles &amp;&amp; result &amp;&amp; isJSString(result) &amp;&amp; isCoW) {
 653             ASSERT(JSImmutableButterfly::fromButterfly(thisArray-&gt;butterfly()) == immutableButterfly);
 654             vm.heap.immutableButterflyToStringCache.add(immutableButterfly, jsCast&lt;JSString*&gt;(result));
 655         }
 656 
 657         return JSValue::encode(result);
 658     }
 659 
<span class="line-modified"> 660     JSStringJoiner joiner(*exec, &#39;,&#39;, length);</span>
 661     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 662 
 663     for (unsigned i = 0; i &lt; length; ++i) {
 664         JSValue element = thisArray-&gt;tryGetIndexQuickly(i);
 665         if (!element) {
<span class="line-modified"> 666             element = thisArray-&gt;get(exec, i);</span>
 667             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 668         }
<span class="line-modified"> 669         joiner.append(*exec, element);</span>
 670         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 671     }
 672 
<span class="line-modified"> 673     RELEASE_AND_RETURN(scope, JSValue::encode(joiner.join(*exec)));</span>
 674 }
 675 
<span class="line-modified"> 676 EncodedJSValue JSC_HOST_CALL arrayProtoFuncToLocaleString(ExecState* exec)</span>
 677 {
<span class="line-modified"> 678     VM&amp; vm = exec-&gt;vm();</span>
 679     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 680     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);</span>
 681 
<span class="line-modified"> 682     JSObject* thisObject = thisValue.toObject(exec);</span>
 683     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified"> 684     unsigned length = toLength(exec, thisObject);</span>
 685     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 686 
<span class="line-modified"> 687     StringRecursionChecker checker(exec, thisObject);</span>
 688     EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
 689     if (JSValue earlyReturnValue = checker.earlyReturnValue())
 690         return JSValue::encode(earlyReturnValue);
 691 
<span class="line-modified"> 692     JSStringJoiner stringJoiner(*exec, &#39;,&#39;, length);</span>
 693     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 694 
 695 #if ENABLE(INTL)
<span class="line-modified"> 696     ArgList arguments(exec);</span>
 697 #endif
 698     for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified"> 699         JSValue element = thisObject-&gt;getIndex(exec, i);</span>
 700         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 701         if (element.isUndefinedOrNull())
 702             element = jsEmptyString(vm);
 703         else {
<span class="line-modified"> 704             JSValue conversionFunction = element.get(exec, vm.propertyNames-&gt;toLocaleString);</span>
 705             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 706             CallData callData;
 707             CallType callType = getCallData(vm, conversionFunction, callData);
 708             if (callType != CallType::None) {
 709 #if ENABLE(INTL)
<span class="line-modified"> 710                 element = call(exec, conversionFunction, callType, callData, element, arguments);</span>
 711 #else
<span class="line-modified"> 712                 element = call(exec, conversionFunction, callType, callData, element, *vm.emptyList);</span>
 713 #endif
 714                 RETURN_IF_EXCEPTION(scope, encodedJSValue());
 715             }
 716         }
<span class="line-modified"> 717         stringJoiner.append(*exec, element);</span>
 718         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 719     }
 720 
<span class="line-modified"> 721     RELEASE_AND_RETURN(scope, JSValue::encode(stringJoiner.join(*exec)));</span>
 722 }
 723 
<span class="line-modified"> 724 static JSValue slowJoin(ExecState&amp; exec, JSObject* thisObject, JSString* separator, uint64_t length)</span>
 725 {
<span class="line-modified"> 726     VM&amp; vm = exec.vm();</span>
 727     auto scope = DECLARE_THROW_SCOPE(vm);
 728 
 729     // 5. If len is zero, return the empty String.
 730     if (!length)
 731         return jsEmptyString(vm);
 732 
 733     // 6. Let element0 be Get(O, &quot;0&quot;).
<span class="line-modified"> 734     JSValue element0 = thisObject-&gt;getIndex(&amp;exec, 0);</span>
 735     RETURN_IF_EXCEPTION(scope, { });
 736 
 737     // 7. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).
 738     JSString* r = nullptr;
 739     if (element0.isUndefinedOrNull())
 740         r = jsEmptyString(vm);
 741     else
<span class="line-modified"> 742         r = element0.toString(&amp;exec);</span>
 743     RETURN_IF_EXCEPTION(scope, { });
 744 
 745     // 8. Let k be 1.
 746     // 9. Repeat, while k &lt; len
 747     // 9.e Increase k by 1..
 748     for (uint64_t k = 1; k &lt; length; ++k) {
 749         // b. Let element be ? Get(O, ! ToString(k)).
<span class="line-modified"> 750         JSValue element = thisObject-&gt;get(&amp;exec, Identifier::fromString(vm, AtomString::number(k)));</span>
 751         RETURN_IF_EXCEPTION(scope, { });
 752 
 753         // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).
 754         JSString* next = nullptr;
 755         if (element.isUndefinedOrNull()) {
 756             if (!separator-&gt;length())
 757                 continue;
 758             next = jsEmptyString(vm);
 759         } else
<span class="line-modified"> 760             next = element.toString(&amp;exec);</span>
 761         RETURN_IF_EXCEPTION(scope, { });
 762 
 763         // a. Let S be the String value produced by concatenating R and sep.
 764         // d. Let R be a String value produced by concatenating S and next.
<span class="line-modified"> 765         r = jsString(&amp;exec, r, separator, next);</span>
 766         RETURN_IF_EXCEPTION(scope, { });
 767     }
 768     // 10. Return R.
 769     return r;
 770 }
 771 
<span class="line-modified"> 772 EncodedJSValue JSC_HOST_CALL arrayProtoFuncJoin(ExecState* exec)</span>
 773 {
<span class="line-modified"> 774     VM&amp; vm = exec-&gt;vm();</span>
 775     auto scope = DECLARE_THROW_SCOPE(vm);
 776 
 777     // 1. Let O be ? ToObject(this value).
<span class="line-modified"> 778     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
 779     EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
 780     if (UNLIKELY(!thisObject))
 781         return encodedJSValue();
 782 
<span class="line-modified"> 783     StringRecursionChecker checker(exec, thisObject);</span>
 784     EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
 785     if (JSValue earlyReturnValue = checker.earlyReturnValue())
 786         return JSValue::encode(earlyReturnValue);
 787 
 788     // 2. Let len be ? ToLength(? Get(O, &quot;length&quot;)).
<span class="line-modified"> 789     double length = toLength(exec, thisObject);</span>
 790     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 791 
 792     // 3. If separator is undefined, let separator be the single-element String &quot;,&quot;.
<span class="line-modified"> 793     JSValue separatorValue = exec-&gt;argument(0);</span>
 794     if (separatorValue.isUndefined()) {
 795         const LChar comma = &#39;,&#39;;
 796 
 797         if (UNLIKELY(length &gt; std::numeric_limits&lt;unsigned&gt;::max() || !canUseFastJoin(thisObject))) {
 798             uint64_t length64 = static_cast&lt;uint64_t&gt;(length);
 799             ASSERT(static_cast&lt;double&gt;(length64) == length);
 800             JSString* jsSeparator = jsSingleCharacterString(vm, comma);
 801             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 802 
<span class="line-modified"> 803             RELEASE_AND_RETURN(scope, JSValue::encode(slowJoin(*exec, thisObject, jsSeparator, length64)));</span>
 804         }
 805 
 806         unsigned unsignedLength = static_cast&lt;unsigned&gt;(length);
 807         ASSERT(static_cast&lt;double&gt;(unsignedLength) == length);
 808 
<span class="line-modified"> 809         RELEASE_AND_RETURN(scope, JSValue::encode(fastJoin(*exec, thisObject, { &amp;comma, 1 }, unsignedLength)));</span>
 810     }
 811 
 812     // 4. Let sep be ? ToString(separator).
<span class="line-modified"> 813     JSString* jsSeparator = separatorValue.toString(exec);</span>
 814     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 815 
 816     if (UNLIKELY(length &gt; std::numeric_limits&lt;unsigned&gt;::max() || !canUseFastJoin(thisObject))) {
 817         uint64_t length64 = static_cast&lt;uint64_t&gt;(length);
 818         ASSERT(static_cast&lt;double&gt;(length64) == length);
 819 
<span class="line-modified"> 820         RELEASE_AND_RETURN(scope, JSValue::encode(slowJoin(*exec, thisObject, jsSeparator, length64)));</span>
 821     }
 822 
<span class="line-modified"> 823     auto viewWithString = jsSeparator-&gt;viewWithUnderlyingString(exec);</span>
 824     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 825 
<span class="line-modified"> 826     RELEASE_AND_RETURN(scope, JSValue::encode(fastJoin(*exec, thisObject, viewWithString.view, length)));</span>














 827 }
 828 
<span class="line-modified"> 829 EncodedJSValue JSC_HOST_CALL arrayProtoFuncPop(ExecState* exec)</span>
 830 {
<span class="line-modified"> 831     VM&amp; vm = exec-&gt;vm();</span>















 832     auto scope = DECLARE_THROW_SCOPE(vm);
 833 
<span class="line-modified"> 834     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);</span>
 835 
 836     if (isJSArray(thisValue))
<span class="line-modified"> 837         RELEASE_AND_RETURN(scope, JSValue::encode(asArray(thisValue)-&gt;pop(exec)));</span>
 838 
<span class="line-modified"> 839     JSObject* thisObj = thisValue.toObject(exec);</span>
 840     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
 841     if (UNLIKELY(!thisObj))
 842         return encodedJSValue();
<span class="line-modified"> 843     unsigned length = toLength(exec, thisObj);</span>
 844     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 845 
 846     if (length == 0) {
 847         scope.release();
<span class="line-modified"> 848         putLength(exec, vm, thisObj, jsNumber(length));</span>
 849         return JSValue::encode(jsUndefined());
 850     }
 851 
<span class="line-modified"> 852     JSValue result = thisObj-&gt;get(exec, length - 1);</span>
 853     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified"> 854     bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, exec, length - 1);</span>
 855     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 856     if (UNLIKELY(!success)) {
<span class="line-modified"> 857         throwTypeError(exec, scope, UnableToDeletePropertyError);</span>
 858         return encodedJSValue();
 859     }
 860     scope.release();
<span class="line-modified"> 861     putLength(exec, vm, thisObj, jsNumber(length - 1));</span>
 862     return JSValue::encode(result);
 863 }
 864 
<span class="line-modified"> 865 EncodedJSValue JSC_HOST_CALL arrayProtoFuncPush(ExecState* exec)</span>
 866 {
<span class="line-modified"> 867     VM&amp; vm = exec-&gt;vm();</span>
 868     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 869     JSValue thisValue = exec-&gt;thisValue().toThis(exec, StrictMode);</span>
 870 
<span class="line-modified"> 871     if (LIKELY(isJSArray(thisValue) &amp;&amp; exec-&gt;argumentCount() == 1)) {</span>
 872         JSArray* array = asArray(thisValue);
 873         scope.release();
<span class="line-modified"> 874         array-&gt;pushInline(exec, exec-&gt;uncheckedArgument(0));</span>
 875         return JSValue::encode(jsNumber(array-&gt;length()));
 876     }
 877 
<span class="line-modified"> 878     JSObject* thisObj = thisValue.toObject(exec);</span>
 879     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
 880     if (UNLIKELY(!thisObj))
 881         return encodedJSValue();
<span class="line-modified"> 882     unsigned length = toLength(exec, thisObj);</span>
 883     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 884 
<span class="line-modified"> 885     for (unsigned n = 0; n &lt; exec-&gt;argumentCount(); n++) {</span>
 886         // Check for integer overflow; where safe we can do a fast put by index.
 887         if (length + n &gt;= length)
<span class="line-modified"> 888             thisObj-&gt;methodTable(vm)-&gt;putByIndex(thisObj, exec, length + n, exec-&gt;uncheckedArgument(n), true);</span>
 889         else {
 890             PutPropertySlot slot(thisObj);
<span class="line-modified"> 891             Identifier propertyName = Identifier::fromString(vm, JSValue(static_cast&lt;int64_t&gt;(length) + static_cast&lt;int64_t&gt;(n)).toWTFString(exec));</span>
<span class="line-modified"> 892             thisObj-&gt;methodTable(vm)-&gt;put(thisObj, exec, propertyName, exec-&gt;uncheckedArgument(n), slot);</span>


 893         }
 894         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 895     }
 896 
<span class="line-modified"> 897     JSValue newLength(static_cast&lt;int64_t&gt;(length) + static_cast&lt;int64_t&gt;(exec-&gt;argumentCount()));</span>
 898     scope.release();
<span class="line-modified"> 899     putLength(exec, vm, thisObj, newLength);</span>
 900     return JSValue::encode(newLength);
 901 }
 902 
<span class="line-modified"> 903 EncodedJSValue JSC_HOST_CALL arrayProtoFuncReverse(ExecState* exec)</span>
 904 {
<span class="line-modified"> 905     VM&amp; vm = exec-&gt;vm();</span>
 906     auto scope = DECLARE_THROW_SCOPE(vm);
 907 
<span class="line-modified"> 908     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
 909     EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
 910     if (UNLIKELY(!thisObject))
 911         return encodedJSValue();
 912 
<span class="line-modified"> 913     unsigned length = toLength(exec, thisObject);</span>
 914     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 915 
 916     thisObject-&gt;ensureWritable(vm);
 917 
 918     switch (thisObject-&gt;indexingType()) {
 919     case ALL_CONTIGUOUS_INDEXING_TYPES:
 920     case ALL_INT32_INDEXING_TYPES: {
 921         auto&amp; butterfly = *thisObject-&gt;butterfly();
 922         if (length &gt; butterfly.publicLength())
 923             break;
 924         auto data = butterfly.contiguous().data();
 925         if (containsHole(data, length) &amp;&amp; holesMustForwardToPrototype(vm, thisObject))
 926             break;
 927         std::reverse(data, data + length);
 928         if (!hasInt32(thisObject-&gt;indexingType()))
 929             vm.heap.writeBarrier(thisObject);
 930         return JSValue::encode(thisObject);
 931     }
 932     case ALL_DOUBLE_INDEXING_TYPES: {
 933         auto&amp; butterfly = *thisObject-&gt;butterfly();
</pre>
<hr />
<pre>
 938             break;
 939         std::reverse(data, data + length);
 940         return JSValue::encode(thisObject);
 941     }
 942     case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 943         auto&amp; storage = *thisObject-&gt;butterfly()-&gt;arrayStorage();
 944         if (length &gt; storage.vectorLength())
 945             break;
 946         if (storage.hasHoles() &amp;&amp; holesMustForwardToPrototype(vm, thisObject))
 947             break;
 948         auto data = storage.vector().data();
 949         std::reverse(data, data + length);
 950         vm.heap.writeBarrier(thisObject);
 951         return JSValue::encode(thisObject);
 952     }
 953     }
 954 
 955     unsigned middle = length / 2;
 956     for (unsigned lower = 0; lower &lt; middle; lower++) {
 957         unsigned upper = length - lower - 1;
<span class="line-modified"> 958         bool lowerExists = thisObject-&gt;hasProperty(exec, lower);</span>
 959         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 960         JSValue lowerValue;
 961         if (lowerExists) {
<span class="line-modified"> 962             lowerValue = thisObject-&gt;get(exec, lower);</span>
 963             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 964         }
 965 
<span class="line-modified"> 966         bool upperExists = thisObject-&gt;hasProperty(exec, upper);</span>
 967         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 968         JSValue upperValue;
 969         if (upperExists) {
<span class="line-modified"> 970             upperValue = thisObject-&gt;get(exec, upper);</span>
 971             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 972         }
 973 
 974         if (upperExists) {
<span class="line-modified"> 975             thisObject-&gt;putByIndexInline(exec, lower, upperValue, true);</span>
 976             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 977         } else {
<span class="line-modified"> 978             bool success = thisObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObject, exec, lower);</span>
 979             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 980             if (UNLIKELY(!success)) {
<span class="line-modified"> 981                 throwTypeError(exec, scope, UnableToDeletePropertyError);</span>
 982                 return encodedJSValue();
 983             }
 984         }
 985 
 986         if (lowerExists) {
<span class="line-modified"> 987             thisObject-&gt;putByIndexInline(exec, upper, lowerValue, true);</span>
 988             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 989         } else {
<span class="line-modified"> 990             bool success = thisObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObject, exec, upper);</span>
 991             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 992             if (UNLIKELY(!success)) {
<span class="line-modified"> 993                 throwTypeError(exec, scope, UnableToDeletePropertyError);</span>
 994                 return encodedJSValue();
 995             }
 996         }
 997     }
 998     return JSValue::encode(thisObject);
 999 }
1000 
<span class="line-modified">1001 EncodedJSValue JSC_HOST_CALL arrayProtoFuncShift(ExecState* exec)</span>
1002 {
<span class="line-modified">1003     VM&amp; vm = exec-&gt;vm();</span>
1004     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1005     JSObject* thisObj = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
1006     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
1007     if (UNLIKELY(!thisObj))
1008         return encodedJSValue();
<span class="line-modified">1009     unsigned length = toLength(exec, thisObj);</span>
1010     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1011 
1012     if (length == 0) {
1013         scope.release();
<span class="line-modified">1014         putLength(exec, vm, thisObj, jsNumber(length));</span>
1015         return JSValue::encode(jsUndefined());
1016     }
1017 
<span class="line-modified">1018     JSValue result = thisObj-&gt;getIndex(exec, 0);</span>
1019     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1020     shift&lt;JSArray::ShiftCountForShift&gt;(exec, thisObj, 0, 1, 0, length);</span>
1021     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1022     scope.release();
<span class="line-modified">1023     putLength(exec, vm, thisObj, jsNumber(length - 1));</span>
1024     return JSValue::encode(result);
1025 }
1026 
<span class="line-modified">1027 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(ExecState* exec)</span>
1028 {
1029     // https://tc39.github.io/ecma262/#sec-array.prototype.slice
<span class="line-modified">1030     VM&amp; vm = exec-&gt;vm();</span>
1031     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1032     JSObject* thisObj = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
1033     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
1034     if (UNLIKELY(!thisObj))
1035         return { };
<span class="line-modified">1036     unsigned length = toLength(exec, thisObj);</span>
1037     RETURN_IF_EXCEPTION(scope, { });
1038 
<span class="line-modified">1039     unsigned begin = argumentClampedIndexFromStartOrEnd(exec, 0, length);</span>
1040     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">1041     unsigned end = argumentClampedIndexFromStartOrEnd(exec, 1, length, length);</span>
1042     RETURN_IF_EXCEPTION(scope, { });
1043     if (end &lt; begin)
1044         end = begin;
1045 
<span class="line-modified">1046     std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(exec, thisObj, end - begin);</span>
1047     // We can only get an exception if we call some user function.
1048     EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
1049     if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
1050         return { };
1051 
<span class="line-modified">1052     bool okToDoFastPath = speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp; isJSArray(thisObj) &amp;&amp; length == toLength(exec, thisObj);</span>
1053     RETURN_IF_EXCEPTION(scope, { });
1054     if (LIKELY(okToDoFastPath)) {
<span class="line-modified">1055         if (JSArray* result = asArray(thisObj)-&gt;fastSlice(*exec, begin, end - begin))</span>
1056             return JSValue::encode(result);
1057     }
1058 
1059     JSObject* result;
1060     if (speciesResult.first == SpeciesConstructResult::CreatedObject)
1061         result = speciesResult.second;
1062     else {
<span class="line-modified">1063         result = constructEmptyArray(exec, nullptr, end - begin);</span>
1064         RETURN_IF_EXCEPTION(scope, { });
1065     }
1066 
1067     // Document that we need to keep the source array alive until after anything
1068     // that can GC (e.g. allocating the result array).
1069     thisObj-&gt;use();
1070 
1071     unsigned n = 0;
1072     for (unsigned k = begin; k &lt; end; k++, n++) {
<span class="line-modified">1073         JSValue v = getProperty(exec, thisObj, k);</span>
1074         RETURN_IF_EXCEPTION(scope, { });
1075         if (v) {
<span class="line-modified">1076             result-&gt;putDirectIndex(exec, n, v, 0, PutDirectIndexShouldThrow);</span>
1077             RETURN_IF_EXCEPTION(scope, { });
1078         }
1079     }
1080     scope.release();
<span class="line-modified">1081     setLength(exec, vm, result, n);</span>
1082     return JSValue::encode(result);
1083 }
1084 
<span class="line-modified">1085 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(ExecState* exec)</span>
1086 {
1087     // 15.4.4.12
1088 
<span class="line-modified">1089     VM&amp; vm = exec-&gt;vm();</span>
1090     auto scope = DECLARE_THROW_SCOPE(vm);
1091 
<span class="line-modified">1092     JSObject* thisObj = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
1093     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
1094     if (UNLIKELY(!thisObj))
1095         return encodedJSValue();
<span class="line-modified">1096     unsigned length = toLength(exec, thisObj);</span>
1097     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1098 
<span class="line-modified">1099     if (!exec-&gt;argumentCount()) {</span>
<span class="line-modified">1100         std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(exec, thisObj, 0);</span>
1101         EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
1102         if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
1103             return encodedJSValue();
1104 
1105         JSObject* result;
1106         if (speciesResult.first == SpeciesConstructResult::CreatedObject)
1107             result = speciesResult.second;
1108         else {
<span class="line-modified">1109             result = constructEmptyArray(exec, nullptr);</span>
1110             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1111         }
1112 
<span class="line-modified">1113         setLength(exec, vm, result, 0);</span>
1114         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1115         scope.release();
<span class="line-modified">1116         setLength(exec, vm, thisObj, length);</span>
1117         return JSValue::encode(result);
1118     }
1119 
<span class="line-modified">1120     unsigned actualStart = argumentClampedIndexFromStartOrEnd(exec, 0, length);</span>
1121     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1122 
1123     unsigned actualDeleteCount = length - actualStart;
<span class="line-modified">1124     if (exec-&gt;argumentCount() &gt; 1) {</span>
<span class="line-modified">1125         double deleteCount = exec-&gt;uncheckedArgument(1).toInteger(exec);</span>
1126         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1127         if (deleteCount &lt; 0)
1128             actualDeleteCount = 0;
1129         else if (deleteCount &gt; length - actualStart)
1130             actualDeleteCount = length - actualStart;
1131         else
1132             actualDeleteCount = static_cast&lt;unsigned&gt;(deleteCount);
1133     }
1134 
<span class="line-modified">1135     std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(exec, thisObj, actualDeleteCount);</span>
1136     EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
1137     if (speciesResult.first == SpeciesConstructResult::Exception)
1138         return JSValue::encode(jsUndefined());
1139 
1140     JSObject* result = nullptr;
<span class="line-modified">1141     bool okToDoFastPath = speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp; isJSArray(thisObj) &amp;&amp; length == toLength(exec, thisObj);</span>
1142     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1143     if (LIKELY(okToDoFastPath))
<span class="line-modified">1144         result = asArray(thisObj)-&gt;fastSlice(*exec, actualStart, actualDeleteCount);</span>
1145 
1146     if (!result) {
1147         if (speciesResult.first == SpeciesConstructResult::CreatedObject)
1148             result = speciesResult.second;
1149         else {
<span class="line-modified">1150             result = JSArray::tryCreate(vm, exec-&gt;lexicalGlobalObject()-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithUndecided), actualDeleteCount);</span>
1151             if (UNLIKELY(!result)) {
<span class="line-modified">1152                 throwOutOfMemoryError(exec, scope);</span>
1153                 return encodedJSValue();
1154             }
1155         }
1156         for (unsigned k = 0; k &lt; actualDeleteCount; ++k) {
<span class="line-modified">1157             JSValue v = getProperty(exec, thisObj, k + actualStart);</span>
1158             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1159             if (UNLIKELY(!v))
1160                 continue;
<span class="line-modified">1161             result-&gt;putDirectIndex(exec, k, v, 0, PutDirectIndexShouldThrow);</span>
1162             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1163         }
1164     }
1165 
<span class="line-modified">1166     unsigned itemCount = std::max&lt;int&gt;(exec-&gt;argumentCount() - 2, 0);</span>
1167     if (itemCount &lt; actualDeleteCount) {
<span class="line-modified">1168         shift&lt;JSArray::ShiftCountForSplice&gt;(exec, thisObj, actualStart, actualDeleteCount, itemCount, length);</span>
1169         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1170     } else if (itemCount &gt; actualDeleteCount) {
<span class="line-modified">1171         unshift&lt;JSArray::ShiftCountForSplice&gt;(exec, thisObj, actualStart, actualDeleteCount, itemCount, length);</span>
1172         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1173     }
1174     for (unsigned k = 0; k &lt; itemCount; ++k) {
<span class="line-modified">1175         thisObj-&gt;putByIndexInline(exec, k + actualStart, exec-&gt;uncheckedArgument(k + 2), true);</span>
1176         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1177     }
1178 
1179     scope.release();
<span class="line-modified">1180     setLength(exec, vm, thisObj, length - actualDeleteCount + itemCount);</span>
1181     return JSValue::encode(result);
1182 }
1183 
<span class="line-modified">1184 EncodedJSValue JSC_HOST_CALL arrayProtoFuncUnShift(ExecState* exec)</span>
1185 {
<span class="line-modified">1186     VM&amp; vm = exec-&gt;vm();</span>
1187     auto scope = DECLARE_THROW_SCOPE(vm);
1188     // 15.4.4.13
1189 
<span class="line-modified">1190     JSObject* thisObj = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
1191     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
1192     if (UNLIKELY(!thisObj))
1193         return encodedJSValue();
<span class="line-modified">1194     double doubleLength = toLength(exec, thisObj);</span>
1195     unsigned length = doubleLength;
1196     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1197 
<span class="line-modified">1198     unsigned nrArgs = exec-&gt;argumentCount();</span>
1199     if (nrArgs) {
1200         if (UNLIKELY(doubleLength + static_cast&lt;double&gt;(nrArgs) &gt; maxSafeInteger()))
<span class="line-modified">1201             return throwVMTypeError(exec, scope, &quot;Cannot shift to offset greater than (2 ** 53) - 1&quot;_s);</span>
<span class="line-modified">1202         unshift&lt;JSArray::ShiftCountForShift&gt;(exec, thisObj, 0, 0, nrArgs, length);</span>
1203         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1204     }
1205     for (unsigned k = 0; k &lt; nrArgs; ++k) {
<span class="line-modified">1206         thisObj-&gt;putByIndexInline(exec, k, exec-&gt;uncheckedArgument(k), true);</span>
1207         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1208     }
1209     JSValue result = jsNumber(length + nrArgs);
1210     scope.release();
<span class="line-modified">1211     putLength(exec, vm, thisObj, result);</span>
1212     return JSValue::encode(result);
1213 }
1214 
1215 enum class IndexOfDirection { Forward, Backward };
1216 template&lt;IndexOfDirection direction&gt;
<span class="line-modified">1217 ALWAYS_INLINE JSValue fastIndexOf(ExecState* exec, VM&amp; vm, JSArray* array, unsigned length, JSValue searchElement, unsigned index)</span>
1218 {
1219     auto scope = DECLARE_THROW_SCOPE(vm);
1220 
1221     bool canDoFastPath = array-&gt;canDoFastIndexedAccess(vm)
1222         &amp;&amp; array-&gt;getArrayLength() == length; // The effects in getting `index` could have changed the length of this array.
1223     if (!canDoFastPath)
1224         return JSValue();
1225 
1226     switch (array-&gt;indexingType()) {
1227     case ALL_INT32_INDEXING_TYPES: {
1228         if (!searchElement.isNumber())
1229             return jsNumber(-1);
1230         JSValue searchInt32;
1231         if (searchElement.isInt32())
1232             searchInt32 = searchElement;
1233         else {
1234             double searchNumber = searchElement.asNumber();
1235             if (!canBeInt32(searchNumber))
1236                 return jsNumber(-1);
1237             searchInt32 = jsNumber(static_cast&lt;int32_t&gt;(searchNumber));
</pre>
<hr />
<pre>
1248         } else {
1249             do {
1250                 ASSERT(index &lt; length);
1251                 // Array#lastIndexOf uses `===` semantics (not HashMap isEqual semantics).
1252                 // And the hole never matches against Int32 value.
1253                 if (searchInt32 == data[index].get())
1254                     return jsNumber(index);
1255             } while (index--);
1256         }
1257         return jsNumber(-1);
1258     }
1259     case ALL_CONTIGUOUS_INDEXING_TYPES: {
1260         auto&amp; butterfly = *array-&gt;butterfly();
1261         auto data = butterfly.contiguous().data();
1262 
1263         if (direction == IndexOfDirection::Forward) {
1264             for (; index &lt; length; ++index) {
1265                 JSValue value = data[index].get();
1266                 if (!value)
1267                     continue;
<span class="line-modified">1268                 bool isEqual = JSValue::strictEqual(exec, searchElement, value);</span>
1269                 RETURN_IF_EXCEPTION(scope, { });
1270                 if (isEqual)
1271                     return jsNumber(index);
1272             }
1273         } else {
1274             do {
1275                 ASSERT(index &lt; length);
1276                 JSValue value = data[index].get();
1277                 if (!value)
1278                     continue;
<span class="line-modified">1279                 bool isEqual = JSValue::strictEqual(exec, searchElement, value);</span>
1280                 RETURN_IF_EXCEPTION(scope, { });
1281                 if (isEqual)
1282                     return jsNumber(index);
1283             } while (index--);
1284         }
1285         return jsNumber(-1);
1286     }
1287     case ALL_DOUBLE_INDEXING_TYPES: {
1288         if (!searchElement.isNumber())
1289             return jsNumber(-1);
1290         double searchNumber = searchElement.asNumber();
1291         auto&amp; butterfly = *array-&gt;butterfly();
1292         auto data = butterfly.contiguousDouble().data();
1293         if (direction == IndexOfDirection::Forward) {
1294             for (; index &lt; length; ++index) {
1295                 // Array#indexOf uses `===` semantics (not HashMap isEqual semantics).
1296                 // And the hole never matches since it is NaN.
1297                 if (data[index] == searchNumber)
1298                     return jsNumber(index);
1299             }
1300         } else {
1301             do {
1302                 ASSERT(index &lt; length);
1303                 // Array#lastIndexOf uses `===` semantics (not HashMap isEqual semantics).
1304                 // And the hole never matches since it is NaN.
1305                 if (data[index] == searchNumber)
1306                     return jsNumber(index);
1307             } while (index--);
1308         }
1309         return jsNumber(-1);
1310     }
1311     default:
1312         return JSValue();
1313     }
1314 }
1315 
<span class="line-modified">1316 EncodedJSValue JSC_HOST_CALL arrayProtoFuncIndexOf(ExecState* exec)</span>
1317 {
<span class="line-modified">1318     VM&amp; vm = exec-&gt;vm();</span>
1319     auto scope = DECLARE_THROW_SCOPE(vm);
1320 
1321     // 15.4.4.14
<span class="line-modified">1322     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
1323     EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
1324     if (UNLIKELY(!thisObject))
1325         return { };
<span class="line-modified">1326     unsigned length = toLength(exec, thisObject);</span>
1327     RETURN_IF_EXCEPTION(scope, { });
1328 
<span class="line-modified">1329     unsigned index = argumentClampedIndexFromStartOrEnd(exec, 1, length);</span>
1330     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">1331     JSValue searchElement = exec-&gt;argument(0);</span>
1332 
1333     if (isJSArray(thisObject)) {
<span class="line-modified">1334         JSValue result = fastIndexOf&lt;IndexOfDirection::Forward&gt;(exec, vm, asArray(thisObject), length, searchElement, index);</span>
1335         RETURN_IF_EXCEPTION(scope, { });
1336         if (result)
1337             return JSValue::encode(result);
1338     }
1339 
1340     for (; index &lt; length; ++index) {
<span class="line-modified">1341         JSValue e = getProperty(exec, thisObject, index);</span>
1342         RETURN_IF_EXCEPTION(scope, { });
1343         if (!e)
1344             continue;
<span class="line-modified">1345         bool isEqual = JSValue::strictEqual(exec, searchElement, e);</span>
1346         RETURN_IF_EXCEPTION(scope, { });
1347         if (isEqual)
1348             return JSValue::encode(jsNumber(index));
1349     }
1350 
1351     return JSValue::encode(jsNumber(-1));
1352 }
1353 
<span class="line-modified">1354 EncodedJSValue JSC_HOST_CALL arrayProtoFuncLastIndexOf(ExecState* exec)</span>
1355 {
<span class="line-modified">1356     VM&amp; vm = exec-&gt;vm();</span>
1357     auto scope = DECLARE_THROW_SCOPE(vm);
1358 
1359     // 15.4.4.15
<span class="line-modified">1360     JSObject* thisObject = exec-&gt;thisValue().toThis(exec, StrictMode).toObject(exec);</span>
1361     EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
1362     if (UNLIKELY(!thisObject))
1363         return { };
<span class="line-modified">1364     unsigned length = toLength(exec, thisObject);</span>
1365     if (UNLIKELY(scope.exception()) || !length)
1366         return JSValue::encode(jsNumber(-1));
1367 
1368     unsigned index = length - 1;
<span class="line-modified">1369     if (exec-&gt;argumentCount() &gt;= 2) {</span>
<span class="line-modified">1370         JSValue fromValue = exec-&gt;uncheckedArgument(1);</span>
<span class="line-modified">1371         double fromDouble = fromValue.toInteger(exec);</span>
1372         RETURN_IF_EXCEPTION(scope, { });
1373         if (fromDouble &lt; 0) {
1374             fromDouble += length;
1375             if (fromDouble &lt; 0)
1376                 return JSValue::encode(jsNumber(-1));
1377         }
1378         if (fromDouble &lt; length)
1379             index = static_cast&lt;unsigned&gt;(fromDouble);
1380     }
1381 
<span class="line-modified">1382     JSValue searchElement = exec-&gt;argument(0);</span>
1383 
1384     if (isJSArray(thisObject)) {
<span class="line-modified">1385         JSValue result = fastIndexOf&lt;IndexOfDirection::Backward&gt;(exec, vm, asArray(thisObject), length, searchElement, index);</span>
1386         RETURN_IF_EXCEPTION(scope, { });
1387         if (result)
1388             return JSValue::encode(result);
1389     }
1390 
1391     do {
1392         ASSERT(index &lt; length);
<span class="line-modified">1393         JSValue e = getProperty(exec, thisObject, index);</span>
1394         RETURN_IF_EXCEPTION(scope, { });
1395         if (!e)
1396             continue;
<span class="line-modified">1397         bool isEqual = JSValue::strictEqual(exec, searchElement, e);</span>
1398         RETURN_IF_EXCEPTION(scope, { });
1399         if (isEqual)
1400             return JSValue::encode(jsNumber(index));
1401     } while (index--);
1402 
1403     return JSValue::encode(jsNumber(-1));
1404 }
1405 
<span class="line-modified">1406 static bool moveElements(ExecState* exec, VM&amp; vm, JSArray* target, unsigned targetOffset, JSArray* source, unsigned sourceLength)</span>
1407 {
1408     auto scope = DECLARE_THROW_SCOPE(vm);
1409 
1410     if (LIKELY(!hasAnyArrayStorage(source-&gt;indexingType()) &amp;&amp; !holesMustForwardToPrototype(vm, source))) {
1411         for (unsigned i = 0; i &lt; sourceLength; ++i) {
1412             JSValue value = source-&gt;tryGetIndexQuickly(i);
1413             if (value) {
<span class="line-modified">1414                 target-&gt;putDirectIndex(exec, targetOffset + i, value, 0, PutDirectIndexShouldThrow);</span>
1415                 RETURN_IF_EXCEPTION(scope, false);
1416             }
1417         }
1418     } else {
1419         for (unsigned i = 0; i &lt; sourceLength; ++i) {
<span class="line-modified">1420             JSValue value = getProperty(exec, source, i);</span>
1421             RETURN_IF_EXCEPTION(scope, false);
1422             if (value) {
<span class="line-modified">1423                 target-&gt;putDirectIndex(exec, targetOffset + i, value, 0, PutDirectIndexShouldThrow);</span>
1424                 RETURN_IF_EXCEPTION(scope, false);
1425             }
1426         }
1427     }
1428     return true;
1429 }
1430 
<span class="line-modified">1431 static EncodedJSValue concatAppendOne(ExecState* exec, VM&amp; vm, JSArray* first, JSValue second)</span>
1432 {
1433     auto scope = DECLARE_THROW_SCOPE(vm);
1434 
1435     ASSERT(!isJSArray(second));
1436     ASSERT(!shouldUseSlowPut(first-&gt;indexingType()));
1437     Butterfly* firstButterfly = first-&gt;butterfly();
1438     unsigned firstArraySize = firstButterfly-&gt;publicLength();
1439 
1440     Checked&lt;unsigned, RecordOverflow&gt; checkedResultSize = firstArraySize;
1441     checkedResultSize += 1;
1442     if (UNLIKELY(checkedResultSize.hasOverflowed())) {
<span class="line-modified">1443         throwOutOfMemoryError(exec, scope);</span>
1444         return encodedJSValue();
1445     }
1446 
1447     unsigned resultSize = checkedResultSize.unsafeGet();
1448     IndexingType type = first-&gt;mergeIndexingTypeForCopying(indexingTypeForValue(second) | IsArray);
1449 
1450     if (type == NonArray)
1451         type = first-&gt;indexingType();
1452 
<span class="line-modified">1453     Structure* resultStructure = exec-&gt;lexicalGlobalObject()-&gt;arrayStructureForIndexingTypeDuringAllocation(type);</span>
1454     JSArray* result = JSArray::tryCreate(vm, resultStructure, resultSize);
1455     if (UNLIKELY(!result)) {
<span class="line-modified">1456         throwOutOfMemoryError(exec, scope);</span>
1457         return encodedJSValue();
1458     }
1459 
<span class="line-modified">1460     bool success = result-&gt;appendMemcpy(exec, vm, 0, first);</span>
1461     EXCEPTION_ASSERT(!scope.exception() || !success);
1462     if (!success) {
1463         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1464 
<span class="line-modified">1465         bool success = moveElements(exec, vm, result, 0, first, firstArraySize);</span>
1466         EXCEPTION_ASSERT(!scope.exception() == success);
1467         if (UNLIKELY(!success))
1468             return encodedJSValue();
1469     }
1470 
1471     scope.release();
<span class="line-modified">1472     result-&gt;putDirectIndex(exec, firstArraySize, second);</span>
1473     return JSValue::encode(result);
1474 
1475 }
1476 
1477 template&lt;typename T&gt;
1478 void clearElement(T&amp; element)
1479 {
1480     element.clear();
1481 }
1482 
1483 template&lt;&gt;
1484 void clearElement(double&amp; element)
1485 {
1486     element = PNaN;
1487 }
1488 
1489 template&lt;typename T&gt;
<span class="line-modified">1490 ALWAYS_INLINE void copyElements(T* buffer, unsigned offset, void* source, unsigned sourceSize, IndexingType sourceType)</span>
1491 {
1492     if (sourceType != ArrayWithUndecided) {
<span class="line-modified">1493         memcpy(buffer + offset, source, sizeof(JSValue) * sourceSize);</span>
1494         return;
1495     }
1496 
1497     for (unsigned i = sourceSize; i--;)
1498         clearElement&lt;T&gt;(buffer[i + offset]);
1499 };
1500 
<span class="line-modified">1501 EncodedJSValue JSC_HOST_CALL arrayProtoPrivateFuncConcatMemcpy(ExecState* exec)</span>
1502 {
<span class="line-modified">1503     ASSERT(exec-&gt;argumentCount() == 2);</span>
<span class="line-modified">1504     VM&amp; vm = exec-&gt;vm();</span>
1505     auto scope = DECLARE_THROW_SCOPE(vm);
1506 
<span class="line-modified">1507     JSArray* firstArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(0));</span>
1508 
1509     // This code assumes that neither array has set Symbol.isConcatSpreadable. If the first array
1510     // has indexed accessors then one of those accessors might change the value of Symbol.isConcatSpreadable
1511     // on the second argument.
1512     if (UNLIKELY(shouldUseSlowPut(firstArray-&gt;indexingType())))
1513         return JSValue::encode(jsNull());
1514 
1515     // We need to check the species constructor here since checking it in the JS wrapper is too expensive for the non-optimizing tiers.
<span class="line-modified">1516     bool isValid = speciesWatchpointIsValid(exec, firstArray);</span>
1517     scope.assertNoException();
1518     if (UNLIKELY(!isValid))
1519         return JSValue::encode(jsNull());
1520 
<span class="line-modified">1521     JSValue second = exec-&gt;uncheckedArgument(1);</span>
1522     if (!isJSArray(second))
<span class="line-modified">1523         RELEASE_AND_RETURN(scope, concatAppendOne(exec, vm, firstArray, second));</span>
1524 
1525     JSArray* secondArray = jsCast&lt;JSArray*&gt;(second);
1526 
1527     Butterfly* firstButterfly = firstArray-&gt;butterfly();
1528     Butterfly* secondButterfly = secondArray-&gt;butterfly();
1529 
1530     unsigned firstArraySize = firstButterfly-&gt;publicLength();
1531     unsigned secondArraySize = secondButterfly-&gt;publicLength();
1532 
1533     Checked&lt;unsigned, RecordOverflow&gt; checkedResultSize = firstArraySize;
1534     checkedResultSize += secondArraySize;
1535 
1536     if (UNLIKELY(checkedResultSize.hasOverflowed())) {
<span class="line-modified">1537         throwOutOfMemoryError(exec, scope);</span>
1538         return encodedJSValue();
1539     }
1540 
1541     unsigned resultSize = checkedResultSize.unsafeGet();
1542     IndexingType firstType = firstArray-&gt;indexingType();
1543     IndexingType secondType = secondArray-&gt;indexingType();
1544     IndexingType type = firstArray-&gt;mergeIndexingTypeForCopying(secondType);
1545     if (type == NonArray || !firstArray-&gt;canFastCopy(vm, secondArray) || resultSize &gt;= MIN_SPARSE_ARRAY_INDEX) {
<span class="line-modified">1546         JSArray* result = constructEmptyArray(exec, nullptr, resultSize);</span>
1547         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1548 
<span class="line-modified">1549         bool success = moveElements(exec, vm, result, 0, firstArray, firstArraySize);</span>
1550         EXCEPTION_ASSERT(!scope.exception() == success);
1551         if (UNLIKELY(!success))
1552             return encodedJSValue();
<span class="line-modified">1553         success = moveElements(exec, vm, result, firstArraySize, secondArray, secondArraySize);</span>
1554         EXCEPTION_ASSERT(!scope.exception() == success);
1555         if (UNLIKELY(!success))
1556             return encodedJSValue();
1557 
1558         return JSValue::encode(result);
1559     }
1560 
<span class="line-modified">1561     JSGlobalObject* lexicalGlobalObject = exec-&gt;lexicalGlobalObject();</span>
<span class="line-removed">1562     Structure* resultStructure = lexicalGlobalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(type);</span>
1563     if (UNLIKELY(hasAnyArrayStorage(resultStructure-&gt;indexingType())))
1564         return JSValue::encode(jsNull());
1565 
<span class="line-modified">1566     ASSERT(!lexicalGlobalObject-&gt;isHavingABadTime());</span>
1567     ObjectInitializationScope initializationScope(vm);
1568     JSArray* result = JSArray::tryCreateUninitializedRestricted(initializationScope, resultStructure, resultSize);
1569     if (UNLIKELY(!result)) {
<span class="line-modified">1570         throwOutOfMemoryError(exec, scope);</span>
1571         return encodedJSValue();
1572     }
1573 
1574     if (type == ArrayWithDouble) {
1575         double* buffer = result-&gt;butterfly()-&gt;contiguousDouble().data();
1576         copyElements(buffer, 0, firstButterfly-&gt;contiguousDouble().data(), firstArraySize, firstType);
1577         copyElements(buffer, firstArraySize, secondButterfly-&gt;contiguousDouble().data(), secondArraySize, secondType);
1578 
1579     } else if (type != ArrayWithUndecided) {
1580         WriteBarrier&lt;Unknown&gt;* buffer = result-&gt;butterfly()-&gt;contiguous().data();
1581         copyElements(buffer, 0, firstButterfly-&gt;contiguous().data(), firstArraySize, firstType);
1582         copyElements(buffer, firstArraySize, secondButterfly-&gt;contiguous().data(), secondArraySize, secondType);
1583     }
1584 
<span class="line-modified">1585     result-&gt;butterfly()-&gt;setPublicLength(resultSize);</span>
1586     return JSValue::encode(result);
1587 }
1588 
<span class="line-modified">1589 EncodedJSValue JSC_HOST_CALL arrayProtoPrivateFuncAppendMemcpy(ExecState* exec)</span>
1590 {
<span class="line-modified">1591     ASSERT(exec-&gt;argumentCount() == 3);</span>
1592 
<span class="line-modified">1593     VM&amp; vm = exec-&gt;vm();</span>
1594     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1595     JSArray* resultArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(0));</span>
<span class="line-modified">1596     JSArray* otherArray = jsCast&lt;JSArray*&gt;(exec-&gt;uncheckedArgument(1));</span>
<span class="line-modified">1597     JSValue startValue = exec-&gt;uncheckedArgument(2);</span>
1598     ASSERT(startValue.isUInt32AsAnyInt());
1599     unsigned startIndex = startValue.asUInt32AsAnyInt();
<span class="line-modified">1600     bool success = resultArray-&gt;appendMemcpy(exec, vm, startIndex, otherArray);</span>
1601     EXCEPTION_ASSERT(!scope.exception() || !success);
1602     if (success)
1603         return JSValue::encode(jsUndefined());
1604     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1605     scope.release();
<span class="line-modified">1606     moveElements(exec, vm, resultArray, startIndex, otherArray, otherArray-&gt;length());</span>
1607     return JSValue::encode(jsUndefined());
1608 }
1609 
1610 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  17  *  You should have received a copy of the GNU Lesser General Public
  18  *  License along with this library; if not, write to the Free Software
  19  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301
  20  *  USA
  21  *
  22  */
  23 
  24 #include &quot;config.h&quot;
  25 #include &quot;ArrayPrototype.h&quot;
  26 
  27 #include &quot;AdaptiveInferredPropertyValueWatchpointBase.h&quot;
  28 #include &quot;ArrayConstructor.h&quot;
  29 #include &quot;BuiltinNames.h&quot;
  30 #include &quot;ButterflyInlines.h&quot;
  31 #include &quot;CodeBlock.h&quot;
  32 #include &quot;Error.h&quot;
  33 #include &quot;GetterSetter.h&quot;
  34 #include &quot;Interpreter.h&quot;
  35 #include &quot;JIT.h&quot;
  36 #include &quot;JSArrayInlines.h&quot;
<span class="line-added">  37 #include &quot;JSArrayIterator.h&quot;</span>
  38 #include &quot;JSCBuiltins.h&quot;
  39 #include &quot;JSCInlines.h&quot;
  40 #include &quot;JSImmutableButterfly.h&quot;
  41 #include &quot;JSStringJoiner.h&quot;
  42 #include &quot;Lookup.h&quot;
  43 #include &quot;ObjectConstructor.h&quot;
  44 #include &quot;ObjectPrototype.h&quot;
  45 #include &quot;Operations.h&quot;
  46 #include &quot;StringRecursionChecker.h&quot;
  47 #include &lt;algorithm&gt;
  48 #include &lt;wtf/Assertions.h&gt;
  49 
  50 namespace JSC {
  51 
<span class="line-modified">  52 EncodedJSValue JSC_HOST_CALL arrayProtoFuncToLocaleString(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  53 EncodedJSValue JSC_HOST_CALL arrayProtoFuncJoin(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  54 EncodedJSValue JSC_HOST_CALL arrayProtoFuncKeys(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  55 EncodedJSValue JSC_HOST_CALL arrayProtoFuncEntries(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  56 EncodedJSValue JSC_HOST_CALL arrayProtoFuncPop(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  57 EncodedJSValue JSC_HOST_CALL arrayProtoFuncPush(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  58 EncodedJSValue JSC_HOST_CALL arrayProtoFuncReverse(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  59 EncodedJSValue JSC_HOST_CALL arrayProtoFuncShift(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  60 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  61 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(JSGlobalObject*, CallFrame*);</span>
<span class="line-modified">  62 EncodedJSValue JSC_HOST_CALL arrayProtoFuncUnShift(JSGlobalObject*, CallFrame*);</span>
<span class="line-added">  63 EncodedJSValue JSC_HOST_CALL arrayProtoFuncIndexOf(JSGlobalObject*, CallFrame*);</span>
<span class="line-added">  64 EncodedJSValue JSC_HOST_CALL arrayProtoFuncLastIndexOf(JSGlobalObject*, CallFrame*);</span>
  65 
  66 // ------------------------------ ArrayPrototype ----------------------------
  67 
  68 const ClassInfo ArrayPrototype::s_info = {&quot;Array&quot;, &amp;JSArray::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ArrayPrototype)};
  69 
  70 ArrayPrototype* ArrayPrototype::create(VM&amp; vm, JSGlobalObject* globalObject, Structure* structure)
  71 {
  72     ArrayPrototype* prototype = new (NotNull, allocateCell&lt;ArrayPrototype&gt;(vm.heap)) ArrayPrototype(vm, structure);
  73     prototype-&gt;finishCreation(vm, globalObject);
  74     return prototype;
  75 }
  76 
  77 // ECMA 15.4.4
  78 ArrayPrototype::ArrayPrototype(VM&amp; vm, Structure* structure)
  79     : JSArray(vm, structure, 0)
  80 {
  81 }
  82 
  83 void ArrayPrototype::finishCreation(VM&amp; vm, JSGlobalObject* globalObject)
  84 {
</pre>
<hr />
<pre>
  97     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().pushPublicName(), arrayProtoFuncPush, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, ArrayPushIntrinsic);
  98     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().pushPrivateName(), arrayProtoFuncPush, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, 1, ArrayPushIntrinsic);
  99     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;reverse&quot;, arrayProtoFuncReverse, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 100     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().shiftPublicName(), arrayProtoFuncShift, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0);
 101     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().shiftPrivateName(), arrayProtoFuncShift, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, 0);
 102     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;slice, arrayProtoFuncSlice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2, ArraySliceIntrinsic);
 103     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().sortPublicName(), arrayPrototypeSortCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 104     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;splice&quot;, arrayProtoFuncSplice, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 2);
 105     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;unshift&quot;, arrayProtoFuncUnShift, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 106     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().everyPublicName(), arrayPrototypeEveryCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 107     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().forEachPublicName(), arrayPrototypeForEachCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 108     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().somePublicName(), arrayPrototypeSomeCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 109     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(&quot;indexOf&quot;, arrayProtoFuncIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1, ArrayIndexOfIntrinsic);
 110     JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(&quot;lastIndexOf&quot;, arrayProtoFuncLastIndexOf, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 1);
 111     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().filterPublicName(), arrayPrototypeFilterCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 112     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().flatPublicName(), arrayPrototypeFlatCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 113     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().flatMapPublicName(), arrayPrototypeFlatMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 114     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().reducePublicName(), arrayPrototypeReduceCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 115     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().reduceRightPublicName(), arrayPrototypeReduceRightCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 116     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().mapPublicName(), arrayPrototypeMapCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
<span class="line-modified"> 117     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().keysPublicName(), arrayProtoFuncKeys, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, ArrayKeysIntrinsic);</span>
<span class="line-modified"> 118     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().entriesPublicName(), arrayProtoFuncEntries, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum), 0, ArrayEntriesIntrinsic);</span>
 119     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().findPublicName(), arrayPrototypeFindCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 120     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().findIndexPublicName(), arrayPrototypeFindIndexCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 121     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().includesPublicName(), arrayPrototypeIncludesCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 122     JSC_BUILTIN_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;builtinNames().copyWithinPublicName(), arrayPrototypeCopyWithinCodeGenerator, static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
 123 
 124     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().entriesPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().entriesPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 125     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().forEachPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().forEachPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 126     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().keysPrivateName(), getDirect(vm, vm.propertyNames-&gt;builtinNames().keysPublicName()), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 127     putDirectWithoutTransition(vm, vm.propertyNames-&gt;builtinNames().valuesPrivateName(), globalObject-&gt;arrayProtoValuesFunction(), static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly));
 128 
<span class="line-modified"> 129     JSObject* unscopables = constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure());</span>
 130     unscopables-&gt;convertToDictionary(vm);
 131     const Identifier* const unscopableNames[] = {
 132         &amp;vm.propertyNames-&gt;builtinNames().copyWithinPublicName(),
 133         &amp;vm.propertyNames-&gt;builtinNames().entriesPublicName(),
 134         &amp;vm.propertyNames-&gt;builtinNames().fillPublicName(),
 135         &amp;vm.propertyNames-&gt;builtinNames().findPublicName(),
 136         &amp;vm.propertyNames-&gt;builtinNames().findIndexPublicName(),
 137         &amp;vm.propertyNames-&gt;builtinNames().flatPublicName(),
 138         &amp;vm.propertyNames-&gt;builtinNames().flatMapPublicName(),
 139         &amp;vm.propertyNames-&gt;builtinNames().includesPublicName(),
 140         &amp;vm.propertyNames-&gt;builtinNames().keysPublicName(),
 141         &amp;vm.propertyNames-&gt;builtinNames().valuesPublicName()
 142     };
 143     for (const auto* unscopableName : unscopableNames)
 144         unscopables-&gt;putDirect(vm, *unscopableName, jsBoolean(true));
 145     putDirectWithoutTransition(vm, vm.propertyNames-&gt;unscopablesSymbol, unscopables, PropertyAttribute::DontEnum | PropertyAttribute::ReadOnly);
 146 }
 147 
 148 // ------------------------------ Array Functions ----------------------------
 149 
<span class="line-modified"> 150 static ALWAYS_INLINE JSValue getProperty(JSGlobalObject* globalObject, JSObject* object, unsigned index)</span>
 151 {
<span class="line-modified"> 152     VM&amp; vm = globalObject-&gt;vm();</span>
 153     auto scope = DECLARE_THROW_SCOPE(vm);
 154 
 155     if (JSValue result = object-&gt;tryGetIndexQuickly(index))
 156         return result;
 157     // We want to perform get and has in the same operation.
 158     // We can only do so when this behavior is not observable. The
 159     // only time it is observable is when we encounter an opaque objects (ProxyObject and JSModuleNamespaceObject)
 160     // somewhere in the prototype chain.
 161     PropertySlot slot(object, PropertySlot::InternalMethodType::HasProperty);
<span class="line-modified"> 162     bool hasProperty = object-&gt;getPropertySlot(globalObject, index, slot);</span>
 163     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
 164     if (!hasProperty)
 165         return { };
 166     if (UNLIKELY(slot.isTaintedByOpaqueObject()))
<span class="line-modified"> 167         RELEASE_AND_RETURN(scope, object-&gt;get(globalObject, index));</span>
 168 
<span class="line-modified"> 169     RELEASE_AND_RETURN(scope, slot.getValue(globalObject, index));</span>
 170 }
 171 
<span class="line-modified"> 172 static ALWAYS_INLINE void putLength(JSGlobalObject* globalObject, VM&amp; vm, JSObject* obj, JSValue value)</span>
 173 {
<span class="line-added"> 174     auto scope = DECLARE_THROW_SCOPE(vm);</span>
 175     PutPropertySlot slot(obj);
<span class="line-modified"> 176     bool success = obj-&gt;methodTable(vm)-&gt;put(obj, globalObject, vm.propertyNames-&gt;length, value, slot);</span>
<span class="line-added"> 177     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added"> 178     if (UNLIKELY(!success))</span>
<span class="line-added"> 179         throwTypeError(globalObject, scope, ReadonlyPropertyWriteError);</span>
 180 }
 181 
<span class="line-modified"> 182 static ALWAYS_INLINE void setLength(JSGlobalObject* globalObject, VM&amp; vm, JSObject* obj, unsigned value)</span>
 183 {
 184     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 185     static constexpr bool throwException = true;</span>
 186     if (isJSArray(obj)) {
<span class="line-modified"> 187         jsCast&lt;JSArray*&gt;(obj)-&gt;setLength(globalObject, value, throwException);</span>
 188         RETURN_IF_EXCEPTION(scope, void());
 189     }
<span class="line-modified"> 190     scope.release();</span>
<span class="line-modified"> 191     putLength(globalObject, vm, obj, jsNumber(value));</span>


 192 }
 193 
 194 namespace ArrayPrototypeInternal {
 195 static bool verbose = false;
 196 }
 197 
<span class="line-modified"> 198 ALWAYS_INLINE bool speciesWatchpointIsValid(VM&amp; vm, JSObject* thisObject)</span>
 199 {

 200     JSGlobalObject* globalObject = thisObject-&gt;globalObject(vm);
 201     ArrayPrototype* arrayPrototype = globalObject-&gt;arrayPrototype();
 202 
 203     if (globalObject-&gt;arraySpeciesWatchpointSet().stateOnJSThread() == ClearWatchpoint) {
 204         dataLogLnIf(ArrayPrototypeInternal::verbose, &quot;Initializing Array species watchpoints for Array.prototype: &quot;, pointerDump(arrayPrototype), &quot; with structure: &quot;, pointerDump(arrayPrototype-&gt;structure(vm)), &quot;\nand Array: &quot;, pointerDump(globalObject-&gt;arrayConstructor()), &quot; with structure: &quot;, pointerDump(globalObject-&gt;arrayConstructor()-&gt;structure(vm)));
<span class="line-modified"> 205         globalObject-&gt;tryInstallArraySpeciesWatchpoint();</span>
 206         ASSERT(globalObject-&gt;arraySpeciesWatchpointSet().stateOnJSThread() != ClearWatchpoint);
 207     }
 208 
 209     return !thisObject-&gt;hasCustomProperties(vm)
 210         &amp;&amp; arrayPrototype == thisObject-&gt;getPrototypeDirect(vm)
 211         &amp;&amp; globalObject-&gt;arraySpeciesWatchpointSet().stateOnJSThread() == IsWatched;
 212 }
 213 
 214 enum class SpeciesConstructResult {
 215     FastPath,
 216     Exception,
 217     CreatedObject
 218 };
 219 
<span class="line-modified"> 220 static ALWAYS_INLINE std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesConstructArray(JSGlobalObject* globalObject, JSObject* thisObject, uint64_t length)</span>
 221 {
<span class="line-modified"> 222     VM&amp; vm = globalObject-&gt;vm();</span>
 223     auto scope = DECLARE_THROW_SCOPE(vm);
 224 
 225     auto exceptionResult = [] () {
 226         return std::make_pair(SpeciesConstructResult::Exception, nullptr);
 227     };
 228 
 229     // ECMA 9.4.2.3: https://tc39.github.io/ecma262/#sec-arrayspeciescreate
 230     JSValue constructor = jsUndefined();
<span class="line-modified"> 231     bool thisIsArray = isArray(globalObject, thisObject);</span>
 232     RETURN_IF_EXCEPTION(scope, exceptionResult());
 233     if (LIKELY(thisIsArray)) {
 234         // Fast path in the normal case where the user has not set an own constructor and the Array.prototype.constructor is normal.
 235         // We need prototype check for subclasses of Array, which are Array objects but have a different prototype by default.
<span class="line-modified"> 236         bool isValid = speciesWatchpointIsValid(vm, thisObject);</span>
 237         scope.assertNoException();
 238         if (LIKELY(isValid))
 239             return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 240 
<span class="line-modified"> 241         constructor = thisObject-&gt;get(globalObject, vm.propertyNames-&gt;constructor);</span>
 242         RETURN_IF_EXCEPTION(scope, exceptionResult());
 243         if (constructor.isConstructor(vm)) {
 244             JSObject* constructorObject = jsCast&lt;JSObject*&gt;(constructor);
<span class="line-modified"> 245             bool isArrayConstructorFromAnotherRealm = globalObject != constructorObject-&gt;globalObject(vm)</span>
 246                 &amp;&amp; constructorObject-&gt;inherits&lt;ArrayConstructor&gt;(vm);
 247             if (isArrayConstructorFromAnotherRealm)
 248                 return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 249         }
 250         if (constructor.isObject()) {
<span class="line-modified"> 251             constructor = constructor.get(globalObject, vm.propertyNames-&gt;speciesSymbol);</span>
 252             RETURN_IF_EXCEPTION(scope, exceptionResult());
 253             if (constructor.isNull())
 254                 return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 255         }
 256     } else {
 257         // If isArray is false, return ? ArrayCreate(length).
 258         return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 259     }
 260 
 261     if (constructor.isUndefined())
 262         return std::make_pair(SpeciesConstructResult::FastPath, nullptr);
 263 
 264     MarkedArgumentBuffer args;
 265     args.append(jsNumber(length));
 266     ASSERT(!args.hasOverflowed());
<span class="line-modified"> 267     JSObject* newObject = construct(globalObject, constructor, args, &quot;Species construction did not get a valid constructor&quot;);</span>
 268     RETURN_IF_EXCEPTION(scope, exceptionResult());
 269     return std::make_pair(SpeciesConstructResult::CreatedObject, newObject);
 270 }
 271 
<span class="line-modified"> 272 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSpeciesCreate(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 273 {
<span class="line-modified"> 274     VM&amp; vm = globalObject-&gt;vm();</span>
 275     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 276     JSObject* object = asObject(callFrame-&gt;uncheckedArgument(0));</span>
<span class="line-modified"> 277     uint64_t length = static_cast&lt;uint64_t&gt;(callFrame-&gt;uncheckedArgument(1).asNumber());</span>
 278 
<span class="line-modified"> 279     std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(globalObject, object, length);</span>
 280     EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
 281     if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
 282         return { };
 283     if (speciesResult.first == SpeciesConstructResult::CreatedObject)
 284         return JSValue::encode(speciesResult.second);
 285 
 286     if (length &gt; std::numeric_limits&lt;unsigned&gt;::max()) {
<span class="line-modified"> 287         throwRangeError(globalObject, scope, &quot;Array size is not a small enough positive integer.&quot;_s);</span>
 288         return { };
 289     }
 290 
<span class="line-modified"> 291     RELEASE_AND_RETURN(scope, JSValue::encode(constructEmptyArray(globalObject, nullptr, static_cast&lt;unsigned&gt;(length))));</span>
 292 }
 293 
<span class="line-modified"> 294 static inline unsigned argumentClampedIndexFromStartOrEnd(JSGlobalObject* globalObject, JSValue value, unsigned length, unsigned undefinedValue = 0)</span>
 295 {

 296     if (value.isUndefined())
 297         return undefinedValue;
 298 
<span class="line-modified"> 299     double indexDouble = value.toInteger(globalObject);</span>
 300     if (indexDouble &lt; 0) {
 301         indexDouble += length;
 302         return indexDouble &lt; 0 ? 0 : static_cast&lt;unsigned&gt;(indexDouble);
 303     }
 304     return indexDouble &gt; length ? length : static_cast&lt;unsigned&gt;(indexDouble);
 305 }
 306 
 307 // The shift/unshift function implement the shift/unshift behaviour required
 308 // by the corresponding array prototype methods, and by splice. In both cases,
 309 // the methods are operating an an array or array like object.
 310 //
 311 //  header  currentCount  (remainder)
 312 // [------][------------][-----------]
 313 //  header  resultCount  (remainder)
 314 // [------][-----------][-----------]
 315 //
 316 // The set of properties in the range &#39;header&#39; must be unchanged. The set of
 317 // properties in the range &#39;remainder&#39; (where remainder = length - header -
 318 // currentCount) will be shifted to the left or right as appropriate; in the
 319 // case of shift this must be removing values, in the case of unshift this
 320 // must be introducing new values.
 321 
 322 template&lt;JSArray::ShiftCountMode shiftCountMode&gt;
<span class="line-modified"> 323 void shift(JSGlobalObject* globalObject, JSObject* thisObj, unsigned header, unsigned currentCount, unsigned resultCount, unsigned length)</span>
 324 {
<span class="line-modified"> 325     VM&amp; vm = globalObject-&gt;vm();</span>
 326     auto scope = DECLARE_THROW_SCOPE(vm);
 327 
 328     RELEASE_ASSERT(currentCount &gt; resultCount);
 329     unsigned count = currentCount - resultCount;
 330 
 331     RELEASE_ASSERT(header &lt;= length);
 332     RELEASE_ASSERT(currentCount &lt;= (length - header));
 333 
 334     if (isJSArray(thisObj)) {
 335         JSArray* array = asArray(thisObj);
<span class="line-modified"> 336         if (array-&gt;length() == length &amp;&amp; array-&gt;shiftCount&lt;shiftCountMode&gt;(globalObject, header, count))</span>
 337             return;
 338     }
 339 
 340     for (unsigned k = header; k &lt; length - currentCount; ++k) {
 341         unsigned from = k + currentCount;
 342         unsigned to = k + resultCount;
<span class="line-modified"> 343         JSValue value = getProperty(globalObject, thisObj, from);</span>
 344         RETURN_IF_EXCEPTION(scope, void());
 345         if (value) {
<span class="line-modified"> 346             thisObj-&gt;putByIndexInline(globalObject, to, value, true);</span>
 347             RETURN_IF_EXCEPTION(scope, void());
 348         } else {
<span class="line-modified"> 349             bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, globalObject, to);</span>
 350             RETURN_IF_EXCEPTION(scope, void());
 351             if (!success) {
<span class="line-modified"> 352                 throwTypeError(globalObject, scope, UnableToDeletePropertyError);</span>
 353                 return;
 354             }
 355         }
 356     }
 357     for (unsigned k = length; k &gt; length - count; --k) {
<span class="line-modified"> 358         bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, globalObject, k - 1);</span>
 359         RETURN_IF_EXCEPTION(scope, void());
 360         if (!success) {
<span class="line-modified"> 361             throwTypeError(globalObject, scope, UnableToDeletePropertyError);</span>
 362             return;
 363         }
 364     }
 365 }
 366 
 367 template&lt;JSArray::ShiftCountMode shiftCountMode&gt;
<span class="line-modified"> 368 void unshift(JSGlobalObject* globalObject, JSObject* thisObj, unsigned header, unsigned currentCount, unsigned resultCount, unsigned length)</span>
 369 {
<span class="line-modified"> 370     VM&amp; vm = globalObject-&gt;vm();</span>
 371     auto scope = DECLARE_THROW_SCOPE(vm);
 372 
 373     RELEASE_ASSERT(resultCount &gt; currentCount);
 374     unsigned count = resultCount - currentCount;
 375 
 376     RELEASE_ASSERT(header &lt;= length);
 377     RELEASE_ASSERT(currentCount &lt;= (length - header));
 378 
 379     // Guard against overflow.
 380     if (count &gt; UINT_MAX - length) {
<span class="line-modified"> 381         throwOutOfMemoryError(globalObject, scope);</span>
 382         return;
 383     }
 384 
 385     if (isJSArray(thisObj)) {
 386         JSArray* array = asArray(thisObj);
 387         if (array-&gt;length() == length) {
<span class="line-modified"> 388             bool handled = array-&gt;unshiftCount&lt;shiftCountMode&gt;(globalObject, header, count);</span>
 389             EXCEPTION_ASSERT(!scope.exception() || handled);
 390             if (handled)
 391                 return;
 392         }
 393     }
 394 
 395     for (unsigned k = length - currentCount; k &gt; header; --k) {
 396         unsigned from = k + currentCount - 1;
 397         unsigned to = k + resultCount - 1;
<span class="line-modified"> 398         JSValue value = getProperty(globalObject, thisObj, from);</span>
 399         RETURN_IF_EXCEPTION(scope, void());
 400         if (value) {
<span class="line-modified"> 401             thisObj-&gt;putByIndexInline(globalObject, to, value, true);</span>
 402             RETURN_IF_EXCEPTION(scope, void());
 403         } else {
<span class="line-modified"> 404             bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, globalObject, to);</span>
 405             RETURN_IF_EXCEPTION(scope, void());
 406             if (UNLIKELY(!success)) {
<span class="line-modified"> 407                 throwTypeError(globalObject, scope, UnableToDeletePropertyError);</span>
 408                 return;
 409             }
 410         }
 411     }
 412 }
 413 
 414 inline bool canUseFastJoin(const JSObject* thisObject)
 415 {
 416     switch (thisObject-&gt;indexingType()) {
 417     case ALL_CONTIGUOUS_INDEXING_TYPES:
 418     case ALL_INT32_INDEXING_TYPES:
 419     case ALL_DOUBLE_INDEXING_TYPES:
 420     case ALL_UNDECIDED_INDEXING_TYPES:
 421         return true;
 422     default:
 423         break;
 424     }
 425     return false;
 426 }
 427 
</pre>
<hr />
<pre>
 433 inline bool isHole(double value)
 434 {
 435     return std::isnan(value);
 436 }
 437 
 438 inline bool isHole(const WriteBarrier&lt;Unknown&gt;&amp; value)
 439 {
 440     return !value;
 441 }
 442 
 443 template&lt;typename T&gt;
 444 inline bool containsHole(T* data, unsigned length)
 445 {
 446     for (unsigned i = 0; i &lt; length; ++i) {
 447         if (isHole(data[i]))
 448             return true;
 449     }
 450     return false;
 451 }
 452 
<span class="line-modified"> 453 inline JSValue fastJoin(JSGlobalObject* globalObject, JSObject* thisObject, StringView separator, unsigned length, bool* sawHoles = nullptr)</span>
 454 {
<span class="line-modified"> 455     VM&amp; vm = globalObject-&gt;vm();</span>
 456     auto scope = DECLARE_THROW_SCOPE(vm);
 457 
 458     switch (thisObject-&gt;indexingType()) {
 459     case ALL_INT32_INDEXING_TYPES: {
 460         auto&amp; butterfly = *thisObject-&gt;butterfly();
 461         if (UNLIKELY(length &gt; butterfly.publicLength()))
 462             break;
<span class="line-modified"> 463         JSStringJoiner joiner(globalObject, separator, length);</span>
 464         RETURN_IF_EXCEPTION(scope, { });
 465         auto data = butterfly.contiguous().data();
 466         bool holesKnownToBeOK = false;
 467         for (unsigned i = 0; i &lt; length; ++i) {
 468             JSValue value = data[i].get();
 469             if (LIKELY(value))
 470                 joiner.appendNumber(vm, value.asInt32());
 471             else {
 472                 if (sawHoles)
 473                     *sawHoles = true;
 474                 if (!holesKnownToBeOK) {
 475                     if (holesMustForwardToPrototype(vm, thisObject))
 476                         goto generalCase;
 477                     holesKnownToBeOK = true;
 478                 }
 479                 joiner.appendEmptyString();
 480             }
 481         }
<span class="line-modified"> 482         RELEASE_AND_RETURN(scope, joiner.join(globalObject));</span>
 483     }
 484     case ALL_CONTIGUOUS_INDEXING_TYPES: {
 485         auto&amp; butterfly = *thisObject-&gt;butterfly();
 486         if (UNLIKELY(length &gt; butterfly.publicLength()))
 487             break;
<span class="line-modified"> 488         JSStringJoiner joiner(globalObject, separator, length);</span>
 489         RETURN_IF_EXCEPTION(scope, { });
 490         auto data = butterfly.contiguous().data();
 491         bool holesKnownToBeOK = false;
 492         for (unsigned i = 0; i &lt; length; ++i) {
 493             if (JSValue value = data[i].get()) {
<span class="line-modified"> 494                 if (!joiner.appendWithoutSideEffects(globalObject, value))</span>
 495                     goto generalCase;
<span class="line-added"> 496                 RETURN_IF_EXCEPTION(scope, { });</span>
 497             } else {
 498                 if (sawHoles)
 499                     *sawHoles = true;
 500                 if (!holesKnownToBeOK) {
 501                     if (holesMustForwardToPrototype(vm, thisObject))
 502                         goto generalCase;
 503                     holesKnownToBeOK = true;
 504                 }
 505                 joiner.appendEmptyString();
 506             }
 507         }
<span class="line-modified"> 508         RELEASE_AND_RETURN(scope, joiner.join(globalObject));</span>
 509     }
 510     case ALL_DOUBLE_INDEXING_TYPES: {
 511         auto&amp; butterfly = *thisObject-&gt;butterfly();
 512         if (UNLIKELY(length &gt; butterfly.publicLength()))
 513             break;
<span class="line-modified"> 514         JSStringJoiner joiner(globalObject, separator, length);</span>
 515         RETURN_IF_EXCEPTION(scope, { });
 516         auto data = butterfly.contiguousDouble().data();
 517         bool holesKnownToBeOK = false;
 518         for (unsigned i = 0; i &lt; length; ++i) {
 519             double value = data[i];
 520             if (LIKELY(!isHole(value)))
 521                 joiner.appendNumber(vm, value);
 522             else {
 523                 if (sawHoles)
 524                     *sawHoles = true;
 525                 if (!holesKnownToBeOK) {
 526                     if (holesMustForwardToPrototype(vm, thisObject))
 527                         goto generalCase;
 528                     holesKnownToBeOK = true;
 529                 }
 530                 joiner.appendEmptyString();
 531             }
 532         }
<span class="line-modified"> 533         RELEASE_AND_RETURN(scope, joiner.join(globalObject));</span>
 534     }
 535     case ALL_UNDECIDED_INDEXING_TYPES: {
 536         if (length &amp;&amp; holesMustForwardToPrototype(vm, thisObject))
 537             goto generalCase;
 538         switch (separator.length()) {
 539         case 0:
 540             RELEASE_AND_RETURN(scope, jsEmptyString(vm));
 541         case 1: {
 542             if (length &lt;= 1)
 543                 RELEASE_AND_RETURN(scope, jsEmptyString(vm));
 544             if (separator.is8Bit())
<span class="line-modified"> 545                 RELEASE_AND_RETURN(scope, repeatCharacter(globalObject, separator.characters8()[0], length - 1));</span>
<span class="line-modified"> 546             RELEASE_AND_RETURN(scope, repeatCharacter(globalObject, separator.characters16()[0], length - 1));</span>
 547         default:
 548             JSString* result = jsEmptyString(vm);
 549             if (length &lt;= 1)
 550                 return result;
 551 
 552             JSString* operand = jsString(vm, separator.toString());
 553             RETURN_IF_EXCEPTION(scope, { });
 554             unsigned count = length - 1;
 555             for (;;) {
 556                 if (count &amp; 1) {
<span class="line-modified"> 557                     result = jsString(globalObject, result, operand);</span>
 558                     RETURN_IF_EXCEPTION(scope, { });
 559                 }
 560                 count &gt;&gt;= 1;
 561                 if (!count)
 562                     return result;
<span class="line-modified"> 563                 operand = jsString(globalObject, operand, operand);</span>
 564                 RETURN_IF_EXCEPTION(scope, { });
 565             }
 566         }
 567         }
 568     }
 569     }
 570 
 571 generalCase:
<span class="line-modified"> 572     JSStringJoiner joiner(globalObject, separator, length);</span>
 573     RETURN_IF_EXCEPTION(scope, { });
 574     for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified"> 575         JSValue element = thisObject-&gt;getIndex(globalObject, i);</span>
 576         RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified"> 577         joiner.append(globalObject, element);</span>
 578         RETURN_IF_EXCEPTION(scope, { });
 579     }
<span class="line-modified"> 580     RELEASE_AND_RETURN(scope, joiner.join(globalObject));</span>
 581 }
 582 
 583 inline bool canUseDefaultArrayJoinForToString(VM&amp; vm, JSObject* thisObject)
 584 {
 585     JSGlobalObject* globalObject = thisObject-&gt;globalObject();
 586 
 587     if (globalObject-&gt;arrayJoinWatchpointSet().stateOnJSThread() != IsWatched)
 588         return false;
 589 
 590     Structure* structure = thisObject-&gt;structure(vm);
 591 
 592     // This is the fast case. Many arrays will be an original array.
 593     // We are doing very simple check here. If we do more complicated checks like looking into getDirect &quot;join&quot; of thisObject,
 594     // it would be possible that just looking into &quot;join&quot; function will show the same performance.
 595     return globalObject-&gt;isOriginalArrayStructure(structure);
 596 }
 597 
<span class="line-modified"> 598 EncodedJSValue JSC_HOST_CALL arrayProtoFuncToString(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 599 {
<span class="line-modified"> 600     VM&amp; vm = globalObject-&gt;vm();</span>
 601     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 602     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
 603 
 604     // 1. Let array be the result of calling ToObject on the this value.
<span class="line-modified"> 605     JSObject* thisObject = thisValue.toObject(globalObject);</span>
 606     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 607 
 608     if (!canUseDefaultArrayJoinForToString(vm, thisObject)) {
 609         // 2. Let func be the result of calling the [[Get]] internal method of array with argument &quot;join&quot;.
<span class="line-modified"> 610         JSValue function = JSValue(thisObject).get(globalObject, vm.propertyNames-&gt;join);</span>
 611         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 612 
 613         // 3. If IsCallable(func) is false, then let func be the standard built-in method Object.prototype.toString (15.2.4.2).
 614         bool customJoinCase = false;
 615         if (!function.isCell())
 616             customJoinCase = true;
 617         CallData callData;
 618         CallType callType = getCallData(vm, function, callData);
 619         if (callType == CallType::None)
 620             customJoinCase = true;
 621 
 622         if (UNLIKELY(customJoinCase))
<span class="line-modified"> 623             RELEASE_AND_RETURN(scope, JSValue::encode(jsMakeNontrivialString(globalObject, &quot;[object &quot;, thisObject-&gt;methodTable(vm)-&gt;className(thisObject, vm), &quot;]&quot;)));</span>
 624 
 625         // 4. Return the result of calling the [[Call]] internal method of func providing array as the this value and an empty arguments list.
 626         if (!isJSArray(thisObject) || callType != CallType::Host || callData.native.function != arrayProtoFuncJoin)
<span class="line-modified"> 627             RELEASE_AND_RETURN(scope, JSValue::encode(call(globalObject, function, callType, callData, thisObject, *vm.emptyList)));</span>
 628     }
 629 
 630     ASSERT(isJSArray(thisValue));
 631     JSArray* thisArray = asArray(thisValue);
 632 
 633     unsigned length = thisArray-&gt;length();
 634 
<span class="line-modified"> 635     StringRecursionChecker checker(globalObject, thisArray);</span>
 636     EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
 637     if (JSValue earlyReturnValue = checker.earlyReturnValue())
 638         return JSValue::encode(earlyReturnValue);
 639 
 640     if (LIKELY(canUseFastJoin(thisArray))) {
 641         const LChar comma = &#39;,&#39;;
 642         scope.release();
 643 
 644         bool isCoW = isCopyOnWrite(thisArray-&gt;indexingMode());
 645         JSImmutableButterfly* immutableButterfly = nullptr;
 646         if (isCoW) {
 647             immutableButterfly = JSImmutableButterfly::fromButterfly(thisArray-&gt;butterfly());
 648             auto iter = vm.heap.immutableButterflyToStringCache.find(immutableButterfly);
 649             if (iter != vm.heap.immutableButterflyToStringCache.end())
 650                 return JSValue::encode(iter-&gt;value);
 651         }
 652 
 653         bool sawHoles = false;
<span class="line-modified"> 654         JSValue result = fastJoin(globalObject, thisArray, { &amp;comma, 1 }, length, &amp;sawHoles);</span>
 655 
 656         if (!sawHoles &amp;&amp; result &amp;&amp; isJSString(result) &amp;&amp; isCoW) {
 657             ASSERT(JSImmutableButterfly::fromButterfly(thisArray-&gt;butterfly()) == immutableButterfly);
 658             vm.heap.immutableButterflyToStringCache.add(immutableButterfly, jsCast&lt;JSString*&gt;(result));
 659         }
 660 
 661         return JSValue::encode(result);
 662     }
 663 
<span class="line-modified"> 664     JSStringJoiner joiner(globalObject, &#39;,&#39;, length);</span>
 665     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 666 
 667     for (unsigned i = 0; i &lt; length; ++i) {
 668         JSValue element = thisArray-&gt;tryGetIndexQuickly(i);
 669         if (!element) {
<span class="line-modified"> 670             element = thisArray-&gt;get(globalObject, i);</span>
 671             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 672         }
<span class="line-modified"> 673         joiner.append(globalObject, element);</span>
 674         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 675     }
 676 
<span class="line-modified"> 677     RELEASE_AND_RETURN(scope, JSValue::encode(joiner.join(globalObject)));</span>
 678 }
 679 
<span class="line-modified"> 680 EncodedJSValue JSC_HOST_CALL arrayProtoFuncToLocaleString(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 681 {
<span class="line-modified"> 682     VM&amp; vm = globalObject-&gt;vm();</span>
 683     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 684     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
 685 
<span class="line-modified"> 686     JSObject* thisObject = thisValue.toObject(globalObject);</span>
 687     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified"> 688     unsigned length = toLength(globalObject, thisObject);</span>
 689     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 690 
<span class="line-modified"> 691     StringRecursionChecker checker(globalObject, thisObject);</span>
 692     EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
 693     if (JSValue earlyReturnValue = checker.earlyReturnValue())
 694         return JSValue::encode(earlyReturnValue);
 695 
<span class="line-modified"> 696     JSStringJoiner stringJoiner(globalObject, &#39;,&#39;, length);</span>
 697     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 698 
 699 #if ENABLE(INTL)
<span class="line-modified"> 700     ArgList arguments(callFrame);</span>
 701 #endif
 702     for (unsigned i = 0; i &lt; length; ++i) {
<span class="line-modified"> 703         JSValue element = thisObject-&gt;getIndex(globalObject, i);</span>
 704         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 705         if (element.isUndefinedOrNull())
 706             element = jsEmptyString(vm);
 707         else {
<span class="line-modified"> 708             JSValue conversionFunction = element.get(globalObject, vm.propertyNames-&gt;toLocaleString);</span>
 709             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 710             CallData callData;
 711             CallType callType = getCallData(vm, conversionFunction, callData);
 712             if (callType != CallType::None) {
 713 #if ENABLE(INTL)
<span class="line-modified"> 714                 element = call(globalObject, conversionFunction, callType, callData, element, arguments);</span>
 715 #else
<span class="line-modified"> 716                 element = call(globalObject, conversionFunction, callType, callData, element, *vm.emptyList);</span>
 717 #endif
 718                 RETURN_IF_EXCEPTION(scope, encodedJSValue());
 719             }
 720         }
<span class="line-modified"> 721         stringJoiner.append(globalObject, element);</span>
 722         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 723     }
 724 
<span class="line-modified"> 725     RELEASE_AND_RETURN(scope, JSValue::encode(stringJoiner.join(globalObject)));</span>
 726 }
 727 
<span class="line-modified"> 728 static JSValue slowJoin(JSGlobalObject* globalObject, JSObject* thisObject, JSString* separator, uint64_t length)</span>
 729 {
<span class="line-modified"> 730     VM&amp; vm = globalObject-&gt;vm();</span>
 731     auto scope = DECLARE_THROW_SCOPE(vm);
 732 
 733     // 5. If len is zero, return the empty String.
 734     if (!length)
 735         return jsEmptyString(vm);
 736 
 737     // 6. Let element0 be Get(O, &quot;0&quot;).
<span class="line-modified"> 738     JSValue element0 = thisObject-&gt;getIndex(globalObject, 0);</span>
 739     RETURN_IF_EXCEPTION(scope, { });
 740 
 741     // 7. If element0 is undefined or null, let R be the empty String; otherwise, let R be ? ToString(element0).
 742     JSString* r = nullptr;
 743     if (element0.isUndefinedOrNull())
 744         r = jsEmptyString(vm);
 745     else
<span class="line-modified"> 746         r = element0.toString(globalObject);</span>
 747     RETURN_IF_EXCEPTION(scope, { });
 748 
 749     // 8. Let k be 1.
 750     // 9. Repeat, while k &lt; len
 751     // 9.e Increase k by 1..
 752     for (uint64_t k = 1; k &lt; length; ++k) {
 753         // b. Let element be ? Get(O, ! ToString(k)).
<span class="line-modified"> 754         JSValue element = thisObject-&gt;get(globalObject, Identifier::fromString(vm, AtomString::number(k)));</span>
 755         RETURN_IF_EXCEPTION(scope, { });
 756 
 757         // c. If element is undefined or null, let next be the empty String; otherwise, let next be ? ToString(element).
 758         JSString* next = nullptr;
 759         if (element.isUndefinedOrNull()) {
 760             if (!separator-&gt;length())
 761                 continue;
 762             next = jsEmptyString(vm);
 763         } else
<span class="line-modified"> 764             next = element.toString(globalObject);</span>
 765         RETURN_IF_EXCEPTION(scope, { });
 766 
 767         // a. Let S be the String value produced by concatenating R and sep.
 768         // d. Let R be a String value produced by concatenating S and next.
<span class="line-modified"> 769         r = jsString(globalObject, r, separator, next);</span>
 770         RETURN_IF_EXCEPTION(scope, { });
 771     }
 772     // 10. Return R.
 773     return r;
 774 }
 775 
<span class="line-modified"> 776 EncodedJSValue JSC_HOST_CALL arrayProtoFuncJoin(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 777 {
<span class="line-modified"> 778     VM&amp; vm = globalObject-&gt;vm();</span>
 779     auto scope = DECLARE_THROW_SCOPE(vm);
 780 
 781     // 1. Let O be ? ToObject(this value).
<span class="line-modified"> 782     JSObject* thisObject = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
 783     EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
 784     if (UNLIKELY(!thisObject))
 785         return encodedJSValue();
 786 
<span class="line-modified"> 787     StringRecursionChecker checker(globalObject, thisObject);</span>
 788     EXCEPTION_ASSERT(!scope.exception() || checker.earlyReturnValue());
 789     if (JSValue earlyReturnValue = checker.earlyReturnValue())
 790         return JSValue::encode(earlyReturnValue);
 791 
 792     // 2. Let len be ? ToLength(? Get(O, &quot;length&quot;)).
<span class="line-modified"> 793     double length = toLength(globalObject, thisObject);</span>
 794     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 795 
 796     // 3. If separator is undefined, let separator be the single-element String &quot;,&quot;.
<span class="line-modified"> 797     JSValue separatorValue = callFrame-&gt;argument(0);</span>
 798     if (separatorValue.isUndefined()) {
 799         const LChar comma = &#39;,&#39;;
 800 
 801         if (UNLIKELY(length &gt; std::numeric_limits&lt;unsigned&gt;::max() || !canUseFastJoin(thisObject))) {
 802             uint64_t length64 = static_cast&lt;uint64_t&gt;(length);
 803             ASSERT(static_cast&lt;double&gt;(length64) == length);
 804             JSString* jsSeparator = jsSingleCharacterString(vm, comma);
 805             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 806 
<span class="line-modified"> 807             RELEASE_AND_RETURN(scope, JSValue::encode(slowJoin(globalObject, thisObject, jsSeparator, length64)));</span>
 808         }
 809 
 810         unsigned unsignedLength = static_cast&lt;unsigned&gt;(length);
 811         ASSERT(static_cast&lt;double&gt;(unsignedLength) == length);
 812 
<span class="line-modified"> 813         RELEASE_AND_RETURN(scope, JSValue::encode(fastJoin(globalObject, thisObject, { &amp;comma, 1 }, unsignedLength)));</span>
 814     }
 815 
 816     // 4. Let sep be ? ToString(separator).
<span class="line-modified"> 817     JSString* jsSeparator = separatorValue.toString(globalObject);</span>
 818     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 819 
 820     if (UNLIKELY(length &gt; std::numeric_limits&lt;unsigned&gt;::max() || !canUseFastJoin(thisObject))) {
 821         uint64_t length64 = static_cast&lt;uint64_t&gt;(length);
 822         ASSERT(static_cast&lt;double&gt;(length64) == length);
 823 
<span class="line-modified"> 824         RELEASE_AND_RETURN(scope, JSValue::encode(slowJoin(globalObject, thisObject, jsSeparator, length64)));</span>
 825     }
 826 
<span class="line-modified"> 827     auto viewWithString = jsSeparator-&gt;viewWithUnderlyingString(globalObject);</span>
 828     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 829 
<span class="line-modified"> 830     RELEASE_AND_RETURN(scope, JSValue::encode(fastJoin(globalObject, thisObject, viewWithString.view, length)));</span>
<span class="line-added"> 831 }</span>
<span class="line-added"> 832 </span>
<span class="line-added"> 833 inline EncodedJSValue createArrayIteratorObject(JSGlobalObject* globalObject, CallFrame* callFrame, IterationKind kind)</span>
<span class="line-added"> 834 {</span>
<span class="line-added"> 835     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added"> 836     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="line-added"> 837 </span>
<span class="line-added"> 838     JSObject* thisObject  = callFrame-&gt;thisValue().toObject(globalObject);</span>
<span class="line-added"> 839     EXCEPTION_ASSERT(!!scope.exception() == !thisObject);</span>
<span class="line-added"> 840     UNUSED_PARAM(scope);</span>
<span class="line-added"> 841     if (UNLIKELY(!thisObject))</span>
<span class="line-added"> 842         return encodedJSValue();</span>
<span class="line-added"> 843 </span>
<span class="line-added"> 844     return JSValue::encode(JSArrayIterator::create(vm, globalObject-&gt;arrayIteratorStructure(), thisObject, jsNumber(static_cast&lt;unsigned&gt;(kind))));</span>
 845 }
 846 
<span class="line-modified"> 847 EncodedJSValue JSC_HOST_CALL arrayProtoFuncValues(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 848 {
<span class="line-modified"> 849     return createArrayIteratorObject(globalObject, callFrame, IterationKind::Values);</span>
<span class="line-added"> 850 }</span>
<span class="line-added"> 851 </span>
<span class="line-added"> 852 EncodedJSValue JSC_HOST_CALL arrayProtoFuncEntries(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added"> 853 {</span>
<span class="line-added"> 854     return createArrayIteratorObject(globalObject, callFrame, IterationKind::Entries);</span>
<span class="line-added"> 855 }</span>
<span class="line-added"> 856 </span>
<span class="line-added"> 857 EncodedJSValue JSC_HOST_CALL arrayProtoFuncKeys(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added"> 858 {</span>
<span class="line-added"> 859     return createArrayIteratorObject(globalObject, callFrame, IterationKind::Keys);</span>
<span class="line-added"> 860 }</span>
<span class="line-added"> 861 </span>
<span class="line-added"> 862 EncodedJSValue JSC_HOST_CALL arrayProtoFuncPop(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
<span class="line-added"> 863 {</span>
<span class="line-added"> 864     VM&amp; vm = globalObject-&gt;vm();</span>
 865     auto scope = DECLARE_THROW_SCOPE(vm);
 866 
<span class="line-modified"> 867     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
 868 
 869     if (isJSArray(thisValue))
<span class="line-modified"> 870         RELEASE_AND_RETURN(scope, JSValue::encode(asArray(thisValue)-&gt;pop(globalObject)));</span>
 871 
<span class="line-modified"> 872     JSObject* thisObj = thisValue.toObject(globalObject);</span>
 873     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
 874     if (UNLIKELY(!thisObj))
 875         return encodedJSValue();
<span class="line-modified"> 876     unsigned length = toLength(globalObject, thisObj);</span>
 877     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 878 
 879     if (length == 0) {
 880         scope.release();
<span class="line-modified"> 881         putLength(globalObject, vm, thisObj, jsNumber(length));</span>
 882         return JSValue::encode(jsUndefined());
 883     }
 884 
<span class="line-modified"> 885     JSValue result = thisObj-&gt;get(globalObject, length - 1);</span>
 886     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified"> 887     bool success = thisObj-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObj, globalObject, length - 1);</span>
 888     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 889     if (UNLIKELY(!success)) {
<span class="line-modified"> 890         throwTypeError(globalObject, scope, UnableToDeletePropertyError);</span>
 891         return encodedJSValue();
 892     }
 893     scope.release();
<span class="line-modified"> 894     putLength(globalObject, vm, thisObj, jsNumber(length - 1));</span>
 895     return JSValue::encode(result);
 896 }
 897 
<span class="line-modified"> 898 EncodedJSValue JSC_HOST_CALL arrayProtoFuncPush(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 899 {
<span class="line-modified"> 900     VM&amp; vm = globalObject-&gt;vm();</span>
 901     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 902     JSValue thisValue = callFrame-&gt;thisValue().toThis(globalObject, StrictMode);</span>
 903 
<span class="line-modified"> 904     if (LIKELY(isJSArray(thisValue) &amp;&amp; callFrame-&gt;argumentCount() == 1)) {</span>
 905         JSArray* array = asArray(thisValue);
 906         scope.release();
<span class="line-modified"> 907         array-&gt;pushInline(globalObject, callFrame-&gt;uncheckedArgument(0));</span>
 908         return JSValue::encode(jsNumber(array-&gt;length()));
 909     }
 910 
<span class="line-modified"> 911     JSObject* thisObj = thisValue.toObject(globalObject);</span>
 912     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
 913     if (UNLIKELY(!thisObj))
 914         return encodedJSValue();
<span class="line-modified"> 915     unsigned length = toLength(globalObject, thisObj);</span>
 916     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 917 
<span class="line-modified"> 918     for (unsigned n = 0; n &lt; callFrame-&gt;argumentCount(); n++) {</span>
 919         // Check for integer overflow; where safe we can do a fast put by index.
 920         if (length + n &gt;= length)
<span class="line-modified"> 921             thisObj-&gt;methodTable(vm)-&gt;putByIndex(thisObj, globalObject, length + n, callFrame-&gt;uncheckedArgument(n), true);</span>
 922         else {
 923             PutPropertySlot slot(thisObj);
<span class="line-modified"> 924             auto string = JSValue(static_cast&lt;int64_t&gt;(length) + static_cast&lt;int64_t&gt;(n)).toWTFString(globalObject);</span>
<span class="line-modified"> 925             RETURN_IF_EXCEPTION(scope, encodedJSValue());</span>
<span class="line-added"> 926             Identifier propertyName = Identifier::fromString(vm, string);</span>
<span class="line-added"> 927             thisObj-&gt;methodTable(vm)-&gt;put(thisObj, globalObject, propertyName, callFrame-&gt;uncheckedArgument(n), slot);</span>
 928         }
 929         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 930     }
 931 
<span class="line-modified"> 932     JSValue newLength(static_cast&lt;int64_t&gt;(length) + static_cast&lt;int64_t&gt;(callFrame-&gt;argumentCount()));</span>
 933     scope.release();
<span class="line-modified"> 934     putLength(globalObject, vm, thisObj, newLength);</span>
 935     return JSValue::encode(newLength);
 936 }
 937 
<span class="line-modified"> 938 EncodedJSValue JSC_HOST_CALL arrayProtoFuncReverse(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
 939 {
<span class="line-modified"> 940     VM&amp; vm = globalObject-&gt;vm();</span>
 941     auto scope = DECLARE_THROW_SCOPE(vm);
 942 
<span class="line-modified"> 943     JSObject* thisObject = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
 944     EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
 945     if (UNLIKELY(!thisObject))
 946         return encodedJSValue();
 947 
<span class="line-modified"> 948     unsigned length = toLength(globalObject, thisObject);</span>
 949     RETURN_IF_EXCEPTION(scope, encodedJSValue());
 950 
 951     thisObject-&gt;ensureWritable(vm);
 952 
 953     switch (thisObject-&gt;indexingType()) {
 954     case ALL_CONTIGUOUS_INDEXING_TYPES:
 955     case ALL_INT32_INDEXING_TYPES: {
 956         auto&amp; butterfly = *thisObject-&gt;butterfly();
 957         if (length &gt; butterfly.publicLength())
 958             break;
 959         auto data = butterfly.contiguous().data();
 960         if (containsHole(data, length) &amp;&amp; holesMustForwardToPrototype(vm, thisObject))
 961             break;
 962         std::reverse(data, data + length);
 963         if (!hasInt32(thisObject-&gt;indexingType()))
 964             vm.heap.writeBarrier(thisObject);
 965         return JSValue::encode(thisObject);
 966     }
 967     case ALL_DOUBLE_INDEXING_TYPES: {
 968         auto&amp; butterfly = *thisObject-&gt;butterfly();
</pre>
<hr />
<pre>
 973             break;
 974         std::reverse(data, data + length);
 975         return JSValue::encode(thisObject);
 976     }
 977     case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 978         auto&amp; storage = *thisObject-&gt;butterfly()-&gt;arrayStorage();
 979         if (length &gt; storage.vectorLength())
 980             break;
 981         if (storage.hasHoles() &amp;&amp; holesMustForwardToPrototype(vm, thisObject))
 982             break;
 983         auto data = storage.vector().data();
 984         std::reverse(data, data + length);
 985         vm.heap.writeBarrier(thisObject);
 986         return JSValue::encode(thisObject);
 987     }
 988     }
 989 
 990     unsigned middle = length / 2;
 991     for (unsigned lower = 0; lower &lt; middle; lower++) {
 992         unsigned upper = length - lower - 1;
<span class="line-modified"> 993         bool lowerExists = thisObject-&gt;hasProperty(globalObject, lower);</span>
 994         RETURN_IF_EXCEPTION(scope, encodedJSValue());
 995         JSValue lowerValue;
 996         if (lowerExists) {
<span class="line-modified"> 997             lowerValue = thisObject-&gt;get(globalObject, lower);</span>
 998             RETURN_IF_EXCEPTION(scope, encodedJSValue());
 999         }
1000 
<span class="line-modified">1001         bool upperExists = thisObject-&gt;hasProperty(globalObject, upper);</span>
1002         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1003         JSValue upperValue;
1004         if (upperExists) {
<span class="line-modified">1005             upperValue = thisObject-&gt;get(globalObject, upper);</span>
1006             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1007         }
1008 
1009         if (upperExists) {
<span class="line-modified">1010             thisObject-&gt;putByIndexInline(globalObject, lower, upperValue, true);</span>
1011             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1012         } else {
<span class="line-modified">1013             bool success = thisObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObject, globalObject, lower);</span>
1014             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1015             if (UNLIKELY(!success)) {
<span class="line-modified">1016                 throwTypeError(globalObject, scope, UnableToDeletePropertyError);</span>
1017                 return encodedJSValue();
1018             }
1019         }
1020 
1021         if (lowerExists) {
<span class="line-modified">1022             thisObject-&gt;putByIndexInline(globalObject, upper, lowerValue, true);</span>
1023             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1024         } else {
<span class="line-modified">1025             bool success = thisObject-&gt;methodTable(vm)-&gt;deletePropertyByIndex(thisObject, globalObject, upper);</span>
1026             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1027             if (UNLIKELY(!success)) {
<span class="line-modified">1028                 throwTypeError(globalObject, scope, UnableToDeletePropertyError);</span>
1029                 return encodedJSValue();
1030             }
1031         }
1032     }
1033     return JSValue::encode(thisObject);
1034 }
1035 
<span class="line-modified">1036 EncodedJSValue JSC_HOST_CALL arrayProtoFuncShift(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1037 {
<span class="line-modified">1038     VM&amp; vm = globalObject-&gt;vm();</span>
1039     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1040     JSObject* thisObj = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
1041     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
1042     if (UNLIKELY(!thisObj))
1043         return encodedJSValue();
<span class="line-modified">1044     unsigned length = toLength(globalObject, thisObj);</span>
1045     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1046 
1047     if (length == 0) {
1048         scope.release();
<span class="line-modified">1049         putLength(globalObject, vm, thisObj, jsNumber(length));</span>
1050         return JSValue::encode(jsUndefined());
1051     }
1052 
<span class="line-modified">1053     JSValue result = thisObj-&gt;getIndex(globalObject, 0);</span>
1054     RETURN_IF_EXCEPTION(scope, encodedJSValue());
<span class="line-modified">1055     shift&lt;JSArray::ShiftCountForShift&gt;(globalObject, thisObj, 0, 1, 0, length);</span>
1056     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1057     scope.release();
<span class="line-modified">1058     putLength(globalObject, vm, thisObj, jsNumber(length - 1));</span>
1059     return JSValue::encode(result);
1060 }
1061 
<span class="line-modified">1062 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSlice(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1063 {
1064     // https://tc39.github.io/ecma262/#sec-array.prototype.slice
<span class="line-modified">1065     VM&amp; vm = globalObject-&gt;vm();</span>
1066     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1067     JSObject* thisObj = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
1068     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
1069     if (UNLIKELY(!thisObj))
1070         return { };
<span class="line-modified">1071     unsigned length = toLength(globalObject, thisObj);</span>
1072     RETURN_IF_EXCEPTION(scope, { });
1073 
<span class="line-modified">1074     unsigned begin = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(0), length);</span>
1075     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">1076     unsigned end = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), length, length);</span>
1077     RETURN_IF_EXCEPTION(scope, { });
1078     if (end &lt; begin)
1079         end = begin;
1080 
<span class="line-modified">1081     std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(globalObject, thisObj, end - begin);</span>
1082     // We can only get an exception if we call some user function.
1083     EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
1084     if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
1085         return { };
1086 
<span class="line-modified">1087     bool okToDoFastPath = speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp; isJSArray(thisObj) &amp;&amp; length == toLength(globalObject, thisObj);</span>
1088     RETURN_IF_EXCEPTION(scope, { });
1089     if (LIKELY(okToDoFastPath)) {
<span class="line-modified">1090         if (JSArray* result = asArray(thisObj)-&gt;fastSlice(globalObject, begin, end - begin))</span>
1091             return JSValue::encode(result);
1092     }
1093 
1094     JSObject* result;
1095     if (speciesResult.first == SpeciesConstructResult::CreatedObject)
1096         result = speciesResult.second;
1097     else {
<span class="line-modified">1098         result = constructEmptyArray(globalObject, nullptr, end - begin);</span>
1099         RETURN_IF_EXCEPTION(scope, { });
1100     }
1101 
1102     // Document that we need to keep the source array alive until after anything
1103     // that can GC (e.g. allocating the result array).
1104     thisObj-&gt;use();
1105 
1106     unsigned n = 0;
1107     for (unsigned k = begin; k &lt; end; k++, n++) {
<span class="line-modified">1108         JSValue v = getProperty(globalObject, thisObj, k);</span>
1109         RETURN_IF_EXCEPTION(scope, { });
1110         if (v) {
<span class="line-modified">1111             result-&gt;putDirectIndex(globalObject, n, v, 0, PutDirectIndexShouldThrow);</span>
1112             RETURN_IF_EXCEPTION(scope, { });
1113         }
1114     }
1115     scope.release();
<span class="line-modified">1116     setLength(globalObject, vm, result, n);</span>
1117     return JSValue::encode(result);
1118 }
1119 
<span class="line-modified">1120 EncodedJSValue JSC_HOST_CALL arrayProtoFuncSplice(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1121 {
1122     // 15.4.4.12
1123 
<span class="line-modified">1124     VM&amp; vm = globalObject-&gt;vm();</span>
1125     auto scope = DECLARE_THROW_SCOPE(vm);
1126 
<span class="line-modified">1127     JSObject* thisObj = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
1128     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
1129     if (UNLIKELY(!thisObj))
1130         return encodedJSValue();
<span class="line-modified">1131     unsigned length = toLength(globalObject, thisObj);</span>
1132     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1133 
<span class="line-modified">1134     if (!callFrame-&gt;argumentCount()) {</span>
<span class="line-modified">1135         std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(globalObject, thisObj, 0);</span>
1136         EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
1137         if (UNLIKELY(speciesResult.first == SpeciesConstructResult::Exception))
1138             return encodedJSValue();
1139 
1140         JSObject* result;
1141         if (speciesResult.first == SpeciesConstructResult::CreatedObject)
1142             result = speciesResult.second;
1143         else {
<span class="line-modified">1144             result = constructEmptyArray(globalObject, nullptr);</span>
1145             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1146         }
1147 
<span class="line-modified">1148         setLength(globalObject, vm, result, 0);</span>
1149         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1150         scope.release();
<span class="line-modified">1151         setLength(globalObject, vm, thisObj, length);</span>
1152         return JSValue::encode(result);
1153     }
1154 
<span class="line-modified">1155     unsigned actualStart = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(0), length);</span>
1156     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1157 
1158     unsigned actualDeleteCount = length - actualStart;
<span class="line-modified">1159     if (callFrame-&gt;argumentCount() &gt; 1) {</span>
<span class="line-modified">1160         double deleteCount = callFrame-&gt;uncheckedArgument(1).toInteger(globalObject);</span>
1161         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1162         if (deleteCount &lt; 0)
1163             actualDeleteCount = 0;
1164         else if (deleteCount &gt; length - actualStart)
1165             actualDeleteCount = length - actualStart;
1166         else
1167             actualDeleteCount = static_cast&lt;unsigned&gt;(deleteCount);
1168     }
1169 
<span class="line-modified">1170     std::pair&lt;SpeciesConstructResult, JSObject*&gt; speciesResult = speciesConstructArray(globalObject, thisObj, actualDeleteCount);</span>
1171     EXCEPTION_ASSERT(!!scope.exception() == (speciesResult.first == SpeciesConstructResult::Exception));
1172     if (speciesResult.first == SpeciesConstructResult::Exception)
1173         return JSValue::encode(jsUndefined());
1174 
1175     JSObject* result = nullptr;
<span class="line-modified">1176     bool okToDoFastPath = speciesResult.first == SpeciesConstructResult::FastPath &amp;&amp; isJSArray(thisObj) &amp;&amp; length == toLength(globalObject, thisObj);</span>
1177     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1178     if (LIKELY(okToDoFastPath))
<span class="line-modified">1179         result = asArray(thisObj)-&gt;fastSlice(globalObject, actualStart, actualDeleteCount);</span>
1180 
1181     if (!result) {
1182         if (speciesResult.first == SpeciesConstructResult::CreatedObject)
1183             result = speciesResult.second;
1184         else {
<span class="line-modified">1185             result = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithUndecided), actualDeleteCount);</span>
1186             if (UNLIKELY(!result)) {
<span class="line-modified">1187                 throwOutOfMemoryError(globalObject, scope);</span>
1188                 return encodedJSValue();
1189             }
1190         }
1191         for (unsigned k = 0; k &lt; actualDeleteCount; ++k) {
<span class="line-modified">1192             JSValue v = getProperty(globalObject, thisObj, k + actualStart);</span>
1193             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1194             if (UNLIKELY(!v))
1195                 continue;
<span class="line-modified">1196             result-&gt;putDirectIndex(globalObject, k, v, 0, PutDirectIndexShouldThrow);</span>
1197             RETURN_IF_EXCEPTION(scope, encodedJSValue());
1198         }
1199     }
1200 
<span class="line-modified">1201     unsigned itemCount = std::max&lt;int&gt;(callFrame-&gt;argumentCount() - 2, 0);</span>
1202     if (itemCount &lt; actualDeleteCount) {
<span class="line-modified">1203         shift&lt;JSArray::ShiftCountForSplice&gt;(globalObject, thisObj, actualStart, actualDeleteCount, itemCount, length);</span>
1204         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1205     } else if (itemCount &gt; actualDeleteCount) {
<span class="line-modified">1206         unshift&lt;JSArray::ShiftCountForSplice&gt;(globalObject, thisObj, actualStart, actualDeleteCount, itemCount, length);</span>
1207         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1208     }
1209     for (unsigned k = 0; k &lt; itemCount; ++k) {
<span class="line-modified">1210         thisObj-&gt;putByIndexInline(globalObject, k + actualStart, callFrame-&gt;uncheckedArgument(k + 2), true);</span>
1211         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1212     }
1213 
1214     scope.release();
<span class="line-modified">1215     setLength(globalObject, vm, thisObj, length - actualDeleteCount + itemCount);</span>
1216     return JSValue::encode(result);
1217 }
1218 
<span class="line-modified">1219 EncodedJSValue JSC_HOST_CALL arrayProtoFuncUnShift(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1220 {
<span class="line-modified">1221     VM&amp; vm = globalObject-&gt;vm();</span>
1222     auto scope = DECLARE_THROW_SCOPE(vm);
1223     // 15.4.4.13
1224 
<span class="line-modified">1225     JSObject* thisObj = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
1226     EXCEPTION_ASSERT(!!scope.exception() == !thisObj);
1227     if (UNLIKELY(!thisObj))
1228         return encodedJSValue();
<span class="line-modified">1229     double doubleLength = toLength(globalObject, thisObj);</span>
1230     unsigned length = doubleLength;
1231     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1232 
<span class="line-modified">1233     unsigned nrArgs = callFrame-&gt;argumentCount();</span>
1234     if (nrArgs) {
1235         if (UNLIKELY(doubleLength + static_cast&lt;double&gt;(nrArgs) &gt; maxSafeInteger()))
<span class="line-modified">1236             return throwVMTypeError(globalObject, scope, &quot;Cannot shift to offset greater than (2 ** 53) - 1&quot;_s);</span>
<span class="line-modified">1237         unshift&lt;JSArray::ShiftCountForShift&gt;(globalObject, thisObj, 0, 0, nrArgs, length);</span>
1238         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1239     }
1240     for (unsigned k = 0; k &lt; nrArgs; ++k) {
<span class="line-modified">1241         thisObj-&gt;putByIndexInline(globalObject, k, callFrame-&gt;uncheckedArgument(k), true);</span>
1242         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1243     }
1244     JSValue result = jsNumber(length + nrArgs);
1245     scope.release();
<span class="line-modified">1246     putLength(globalObject, vm, thisObj, result);</span>
1247     return JSValue::encode(result);
1248 }
1249 
1250 enum class IndexOfDirection { Forward, Backward };
1251 template&lt;IndexOfDirection direction&gt;
<span class="line-modified">1252 ALWAYS_INLINE JSValue fastIndexOf(JSGlobalObject* globalObject, VM&amp; vm, JSArray* array, unsigned length, JSValue searchElement, unsigned index)</span>
1253 {
1254     auto scope = DECLARE_THROW_SCOPE(vm);
1255 
1256     bool canDoFastPath = array-&gt;canDoFastIndexedAccess(vm)
1257         &amp;&amp; array-&gt;getArrayLength() == length; // The effects in getting `index` could have changed the length of this array.
1258     if (!canDoFastPath)
1259         return JSValue();
1260 
1261     switch (array-&gt;indexingType()) {
1262     case ALL_INT32_INDEXING_TYPES: {
1263         if (!searchElement.isNumber())
1264             return jsNumber(-1);
1265         JSValue searchInt32;
1266         if (searchElement.isInt32())
1267             searchInt32 = searchElement;
1268         else {
1269             double searchNumber = searchElement.asNumber();
1270             if (!canBeInt32(searchNumber))
1271                 return jsNumber(-1);
1272             searchInt32 = jsNumber(static_cast&lt;int32_t&gt;(searchNumber));
</pre>
<hr />
<pre>
1283         } else {
1284             do {
1285                 ASSERT(index &lt; length);
1286                 // Array#lastIndexOf uses `===` semantics (not HashMap isEqual semantics).
1287                 // And the hole never matches against Int32 value.
1288                 if (searchInt32 == data[index].get())
1289                     return jsNumber(index);
1290             } while (index--);
1291         }
1292         return jsNumber(-1);
1293     }
1294     case ALL_CONTIGUOUS_INDEXING_TYPES: {
1295         auto&amp; butterfly = *array-&gt;butterfly();
1296         auto data = butterfly.contiguous().data();
1297 
1298         if (direction == IndexOfDirection::Forward) {
1299             for (; index &lt; length; ++index) {
1300                 JSValue value = data[index].get();
1301                 if (!value)
1302                     continue;
<span class="line-modified">1303                 bool isEqual = JSValue::strictEqual(globalObject, searchElement, value);</span>
1304                 RETURN_IF_EXCEPTION(scope, { });
1305                 if (isEqual)
1306                     return jsNumber(index);
1307             }
1308         } else {
1309             do {
1310                 ASSERT(index &lt; length);
1311                 JSValue value = data[index].get();
1312                 if (!value)
1313                     continue;
<span class="line-modified">1314                 bool isEqual = JSValue::strictEqual(globalObject, searchElement, value);</span>
1315                 RETURN_IF_EXCEPTION(scope, { });
1316                 if (isEqual)
1317                     return jsNumber(index);
1318             } while (index--);
1319         }
1320         return jsNumber(-1);
1321     }
1322     case ALL_DOUBLE_INDEXING_TYPES: {
1323         if (!searchElement.isNumber())
1324             return jsNumber(-1);
1325         double searchNumber = searchElement.asNumber();
1326         auto&amp; butterfly = *array-&gt;butterfly();
1327         auto data = butterfly.contiguousDouble().data();
1328         if (direction == IndexOfDirection::Forward) {
1329             for (; index &lt; length; ++index) {
1330                 // Array#indexOf uses `===` semantics (not HashMap isEqual semantics).
1331                 // And the hole never matches since it is NaN.
1332                 if (data[index] == searchNumber)
1333                     return jsNumber(index);
1334             }
1335         } else {
1336             do {
1337                 ASSERT(index &lt; length);
1338                 // Array#lastIndexOf uses `===` semantics (not HashMap isEqual semantics).
1339                 // And the hole never matches since it is NaN.
1340                 if (data[index] == searchNumber)
1341                     return jsNumber(index);
1342             } while (index--);
1343         }
1344         return jsNumber(-1);
1345     }
1346     default:
1347         return JSValue();
1348     }
1349 }
1350 
<span class="line-modified">1351 EncodedJSValue JSC_HOST_CALL arrayProtoFuncIndexOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1352 {
<span class="line-modified">1353     VM&amp; vm = globalObject-&gt;vm();</span>
1354     auto scope = DECLARE_THROW_SCOPE(vm);
1355 
1356     // 15.4.4.14
<span class="line-modified">1357     JSObject* thisObject = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
1358     EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
1359     if (UNLIKELY(!thisObject))
1360         return { };
<span class="line-modified">1361     unsigned length = toLength(globalObject, thisObject);</span>
1362     RETURN_IF_EXCEPTION(scope, { });
1363 
<span class="line-modified">1364     unsigned index = argumentClampedIndexFromStartOrEnd(globalObject, callFrame-&gt;argument(1), length);</span>
1365     RETURN_IF_EXCEPTION(scope, { });
<span class="line-modified">1366     JSValue searchElement = callFrame-&gt;argument(0);</span>
1367 
1368     if (isJSArray(thisObject)) {
<span class="line-modified">1369         JSValue result = fastIndexOf&lt;IndexOfDirection::Forward&gt;(globalObject, vm, asArray(thisObject), length, searchElement, index);</span>
1370         RETURN_IF_EXCEPTION(scope, { });
1371         if (result)
1372             return JSValue::encode(result);
1373     }
1374 
1375     for (; index &lt; length; ++index) {
<span class="line-modified">1376         JSValue e = getProperty(globalObject, thisObject, index);</span>
1377         RETURN_IF_EXCEPTION(scope, { });
1378         if (!e)
1379             continue;
<span class="line-modified">1380         bool isEqual = JSValue::strictEqual(globalObject, searchElement, e);</span>
1381         RETURN_IF_EXCEPTION(scope, { });
1382         if (isEqual)
1383             return JSValue::encode(jsNumber(index));
1384     }
1385 
1386     return JSValue::encode(jsNumber(-1));
1387 }
1388 
<span class="line-modified">1389 EncodedJSValue JSC_HOST_CALL arrayProtoFuncLastIndexOf(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1390 {
<span class="line-modified">1391     VM&amp; vm = globalObject-&gt;vm();</span>
1392     auto scope = DECLARE_THROW_SCOPE(vm);
1393 
1394     // 15.4.4.15
<span class="line-modified">1395     JSObject* thisObject = callFrame-&gt;thisValue().toThis(globalObject, StrictMode).toObject(globalObject);</span>
1396     EXCEPTION_ASSERT(!!scope.exception() == !thisObject);
1397     if (UNLIKELY(!thisObject))
1398         return { };
<span class="line-modified">1399     unsigned length = toLength(globalObject, thisObject);</span>
1400     if (UNLIKELY(scope.exception()) || !length)
1401         return JSValue::encode(jsNumber(-1));
1402 
1403     unsigned index = length - 1;
<span class="line-modified">1404     if (callFrame-&gt;argumentCount() &gt;= 2) {</span>
<span class="line-modified">1405         JSValue fromValue = callFrame-&gt;uncheckedArgument(1);</span>
<span class="line-modified">1406         double fromDouble = fromValue.toInteger(globalObject);</span>
1407         RETURN_IF_EXCEPTION(scope, { });
1408         if (fromDouble &lt; 0) {
1409             fromDouble += length;
1410             if (fromDouble &lt; 0)
1411                 return JSValue::encode(jsNumber(-1));
1412         }
1413         if (fromDouble &lt; length)
1414             index = static_cast&lt;unsigned&gt;(fromDouble);
1415     }
1416 
<span class="line-modified">1417     JSValue searchElement = callFrame-&gt;argument(0);</span>
1418 
1419     if (isJSArray(thisObject)) {
<span class="line-modified">1420         JSValue result = fastIndexOf&lt;IndexOfDirection::Backward&gt;(globalObject, vm, asArray(thisObject), length, searchElement, index);</span>
1421         RETURN_IF_EXCEPTION(scope, { });
1422         if (result)
1423             return JSValue::encode(result);
1424     }
1425 
1426     do {
1427         ASSERT(index &lt; length);
<span class="line-modified">1428         JSValue e = getProperty(globalObject, thisObject, index);</span>
1429         RETURN_IF_EXCEPTION(scope, { });
1430         if (!e)
1431             continue;
<span class="line-modified">1432         bool isEqual = JSValue::strictEqual(globalObject, searchElement, e);</span>
1433         RETURN_IF_EXCEPTION(scope, { });
1434         if (isEqual)
1435             return JSValue::encode(jsNumber(index));
1436     } while (index--);
1437 
1438     return JSValue::encode(jsNumber(-1));
1439 }
1440 
<span class="line-modified">1441 static bool moveElements(JSGlobalObject* globalObject, VM&amp; vm, JSArray* target, unsigned targetOffset, JSArray* source, unsigned sourceLength)</span>
1442 {
1443     auto scope = DECLARE_THROW_SCOPE(vm);
1444 
1445     if (LIKELY(!hasAnyArrayStorage(source-&gt;indexingType()) &amp;&amp; !holesMustForwardToPrototype(vm, source))) {
1446         for (unsigned i = 0; i &lt; sourceLength; ++i) {
1447             JSValue value = source-&gt;tryGetIndexQuickly(i);
1448             if (value) {
<span class="line-modified">1449                 target-&gt;putDirectIndex(globalObject, targetOffset + i, value, 0, PutDirectIndexShouldThrow);</span>
1450                 RETURN_IF_EXCEPTION(scope, false);
1451             }
1452         }
1453     } else {
1454         for (unsigned i = 0; i &lt; sourceLength; ++i) {
<span class="line-modified">1455             JSValue value = getProperty(globalObject, source, i);</span>
1456             RETURN_IF_EXCEPTION(scope, false);
1457             if (value) {
<span class="line-modified">1458                 target-&gt;putDirectIndex(globalObject, targetOffset + i, value, 0, PutDirectIndexShouldThrow);</span>
1459                 RETURN_IF_EXCEPTION(scope, false);
1460             }
1461         }
1462     }
1463     return true;
1464 }
1465 
<span class="line-modified">1466 static EncodedJSValue concatAppendOne(JSGlobalObject* globalObject, VM&amp; vm, JSArray* first, JSValue second)</span>
1467 {
1468     auto scope = DECLARE_THROW_SCOPE(vm);
1469 
1470     ASSERT(!isJSArray(second));
1471     ASSERT(!shouldUseSlowPut(first-&gt;indexingType()));
1472     Butterfly* firstButterfly = first-&gt;butterfly();
1473     unsigned firstArraySize = firstButterfly-&gt;publicLength();
1474 
1475     Checked&lt;unsigned, RecordOverflow&gt; checkedResultSize = firstArraySize;
1476     checkedResultSize += 1;
1477     if (UNLIKELY(checkedResultSize.hasOverflowed())) {
<span class="line-modified">1478         throwOutOfMemoryError(globalObject, scope);</span>
1479         return encodedJSValue();
1480     }
1481 
1482     unsigned resultSize = checkedResultSize.unsafeGet();
1483     IndexingType type = first-&gt;mergeIndexingTypeForCopying(indexingTypeForValue(second) | IsArray);
1484 
1485     if (type == NonArray)
1486         type = first-&gt;indexingType();
1487 
<span class="line-modified">1488     Structure* resultStructure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(type);</span>
1489     JSArray* result = JSArray::tryCreate(vm, resultStructure, resultSize);
1490     if (UNLIKELY(!result)) {
<span class="line-modified">1491         throwOutOfMemoryError(globalObject, scope);</span>
1492         return encodedJSValue();
1493     }
1494 
<span class="line-modified">1495     bool success = result-&gt;appendMemcpy(globalObject, vm, 0, first);</span>
1496     EXCEPTION_ASSERT(!scope.exception() || !success);
1497     if (!success) {
1498         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1499 
<span class="line-modified">1500         bool success = moveElements(globalObject, vm, result, 0, first, firstArraySize);</span>
1501         EXCEPTION_ASSERT(!scope.exception() == success);
1502         if (UNLIKELY(!success))
1503             return encodedJSValue();
1504     }
1505 
1506     scope.release();
<span class="line-modified">1507     result-&gt;putDirectIndex(globalObject, firstArraySize, second);</span>
1508     return JSValue::encode(result);
1509 
1510 }
1511 
1512 template&lt;typename T&gt;
1513 void clearElement(T&amp; element)
1514 {
1515     element.clear();
1516 }
1517 
1518 template&lt;&gt;
1519 void clearElement(double&amp; element)
1520 {
1521     element = PNaN;
1522 }
1523 
1524 template&lt;typename T&gt;
<span class="line-modified">1525 ALWAYS_INLINE void copyElements(T* buffer, unsigned offset, T* source, unsigned sourceSize, IndexingType sourceType)</span>
1526 {
1527     if (sourceType != ArrayWithUndecided) {
<span class="line-modified">1528         gcSafeMemcpy(buffer + offset, source, sizeof(JSValue) * sourceSize);</span>
1529         return;
1530     }
1531 
1532     for (unsigned i = sourceSize; i--;)
1533         clearElement&lt;T&gt;(buffer[i + offset]);
1534 };
1535 
<span class="line-modified">1536 EncodedJSValue JSC_HOST_CALL arrayProtoPrivateFuncConcatMemcpy(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1537 {
<span class="line-modified">1538     ASSERT(callFrame-&gt;argumentCount() == 2);</span>
<span class="line-modified">1539     VM&amp; vm = globalObject-&gt;vm();</span>
1540     auto scope = DECLARE_THROW_SCOPE(vm);
1541 
<span class="line-modified">1542     JSArray* firstArray = jsCast&lt;JSArray*&gt;(callFrame-&gt;uncheckedArgument(0));</span>
1543 
1544     // This code assumes that neither array has set Symbol.isConcatSpreadable. If the first array
1545     // has indexed accessors then one of those accessors might change the value of Symbol.isConcatSpreadable
1546     // on the second argument.
1547     if (UNLIKELY(shouldUseSlowPut(firstArray-&gt;indexingType())))
1548         return JSValue::encode(jsNull());
1549 
1550     // We need to check the species constructor here since checking it in the JS wrapper is too expensive for the non-optimizing tiers.
<span class="line-modified">1551     bool isValid = speciesWatchpointIsValid(vm, firstArray);</span>
1552     scope.assertNoException();
1553     if (UNLIKELY(!isValid))
1554         return JSValue::encode(jsNull());
1555 
<span class="line-modified">1556     JSValue second = callFrame-&gt;uncheckedArgument(1);</span>
1557     if (!isJSArray(second))
<span class="line-modified">1558         RELEASE_AND_RETURN(scope, concatAppendOne(globalObject, vm, firstArray, second));</span>
1559 
1560     JSArray* secondArray = jsCast&lt;JSArray*&gt;(second);
1561 
1562     Butterfly* firstButterfly = firstArray-&gt;butterfly();
1563     Butterfly* secondButterfly = secondArray-&gt;butterfly();
1564 
1565     unsigned firstArraySize = firstButterfly-&gt;publicLength();
1566     unsigned secondArraySize = secondButterfly-&gt;publicLength();
1567 
1568     Checked&lt;unsigned, RecordOverflow&gt; checkedResultSize = firstArraySize;
1569     checkedResultSize += secondArraySize;
1570 
1571     if (UNLIKELY(checkedResultSize.hasOverflowed())) {
<span class="line-modified">1572         throwOutOfMemoryError(globalObject, scope);</span>
1573         return encodedJSValue();
1574     }
1575 
1576     unsigned resultSize = checkedResultSize.unsafeGet();
1577     IndexingType firstType = firstArray-&gt;indexingType();
1578     IndexingType secondType = secondArray-&gt;indexingType();
1579     IndexingType type = firstArray-&gt;mergeIndexingTypeForCopying(secondType);
1580     if (type == NonArray || !firstArray-&gt;canFastCopy(vm, secondArray) || resultSize &gt;= MIN_SPARSE_ARRAY_INDEX) {
<span class="line-modified">1581         JSArray* result = constructEmptyArray(globalObject, nullptr, resultSize);</span>
1582         RETURN_IF_EXCEPTION(scope, encodedJSValue());
1583 
<span class="line-modified">1584         bool success = moveElements(globalObject, vm, result, 0, firstArray, firstArraySize);</span>
1585         EXCEPTION_ASSERT(!scope.exception() == success);
1586         if (UNLIKELY(!success))
1587             return encodedJSValue();
<span class="line-modified">1588         success = moveElements(globalObject, vm, result, firstArraySize, secondArray, secondArraySize);</span>
1589         EXCEPTION_ASSERT(!scope.exception() == success);
1590         if (UNLIKELY(!success))
1591             return encodedJSValue();
1592 
1593         return JSValue::encode(result);
1594     }
1595 
<span class="line-modified">1596     Structure* resultStructure = globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(type);</span>

1597     if (UNLIKELY(hasAnyArrayStorage(resultStructure-&gt;indexingType())))
1598         return JSValue::encode(jsNull());
1599 
<span class="line-modified">1600     ASSERT(!globalObject-&gt;isHavingABadTime());</span>
1601     ObjectInitializationScope initializationScope(vm);
1602     JSArray* result = JSArray::tryCreateUninitializedRestricted(initializationScope, resultStructure, resultSize);
1603     if (UNLIKELY(!result)) {
<span class="line-modified">1604         throwOutOfMemoryError(globalObject, scope);</span>
1605         return encodedJSValue();
1606     }
1607 
1608     if (type == ArrayWithDouble) {
1609         double* buffer = result-&gt;butterfly()-&gt;contiguousDouble().data();
1610         copyElements(buffer, 0, firstButterfly-&gt;contiguousDouble().data(), firstArraySize, firstType);
1611         copyElements(buffer, firstArraySize, secondButterfly-&gt;contiguousDouble().data(), secondArraySize, secondType);
1612 
1613     } else if (type != ArrayWithUndecided) {
1614         WriteBarrier&lt;Unknown&gt;* buffer = result-&gt;butterfly()-&gt;contiguous().data();
1615         copyElements(buffer, 0, firstButterfly-&gt;contiguous().data(), firstArraySize, firstType);
1616         copyElements(buffer, firstArraySize, secondButterfly-&gt;contiguous().data(), secondArraySize, secondType);
1617     }
1618 
<span class="line-modified">1619     ASSERT(result-&gt;butterfly()-&gt;publicLength() == resultSize);</span>
1620     return JSValue::encode(result);
1621 }
1622 
<span class="line-modified">1623 EncodedJSValue JSC_HOST_CALL arrayProtoPrivateFuncAppendMemcpy(JSGlobalObject* globalObject, CallFrame* callFrame)</span>
1624 {
<span class="line-modified">1625     ASSERT(callFrame-&gt;argumentCount() == 3);</span>
1626 
<span class="line-modified">1627     VM&amp; vm = globalObject-&gt;vm();</span>
1628     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified">1629     JSArray* resultArray = jsCast&lt;JSArray*&gt;(callFrame-&gt;uncheckedArgument(0));</span>
<span class="line-modified">1630     JSArray* otherArray = jsCast&lt;JSArray*&gt;(callFrame-&gt;uncheckedArgument(1));</span>
<span class="line-modified">1631     JSValue startValue = callFrame-&gt;uncheckedArgument(2);</span>
1632     ASSERT(startValue.isUInt32AsAnyInt());
1633     unsigned startIndex = startValue.asUInt32AsAnyInt();
<span class="line-modified">1634     bool success = resultArray-&gt;appendMemcpy(globalObject, vm, startIndex, otherArray);</span>
1635     EXCEPTION_ASSERT(!scope.exception() || !success);
1636     if (success)
1637         return JSValue::encode(jsUndefined());
1638     RETURN_IF_EXCEPTION(scope, encodedJSValue());
1639     scope.release();
<span class="line-modified">1640     moveElements(globalObject, vm, resultArray, startIndex, otherArray, otherArray-&gt;length());</span>
1641     return JSValue::encode(jsUndefined());
1642 }
1643 
1644 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="ArrayIteratorPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ArrayPrototype.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
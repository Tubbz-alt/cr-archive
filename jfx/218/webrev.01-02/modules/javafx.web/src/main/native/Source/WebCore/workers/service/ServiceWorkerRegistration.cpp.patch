diff a/modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerRegistration.cpp b/modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerRegistration.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerRegistration.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/workers/service/ServiceWorkerRegistration.cpp
@@ -29,10 +29,11 @@
 #if ENABLE(SERVICE_WORKER)
 #include "DOMWindow.h"
 #include "Document.h"
 #include "Event.h"
 #include "EventNames.h"
+#include "JSDOMPromiseDeferred.h"
 #include "Logging.h"
 #include "ServiceWorker.h"
 #include "ServiceWorkerContainer.h"
 #include "ServiceWorkerTypes.h"
 #include "WorkerGlobalScope.h"
@@ -43,12 +44,10 @@
 
 namespace WebCore {
 
 WTF_MAKE_ISO_ALLOCATED_IMPL(ServiceWorkerRegistration);
 
-const Seconds softUpdateDelay { 1_s };
-
 Ref<ServiceWorkerRegistration> ServiceWorkerRegistration::getOrCreate(ScriptExecutionContext& context, Ref<ServiceWorkerContainer>&& container, ServiceWorkerRegistrationData&& data)
 {
     if (auto* registration = container->registration(data.identifier)) {
         ASSERT(!registration->m_isStopped);
         return *registration;
@@ -59,11 +58,10 @@
 
 ServiceWorkerRegistration::ServiceWorkerRegistration(ScriptExecutionContext& context, Ref<ServiceWorkerContainer>&& container, ServiceWorkerRegistrationData&& registrationData)
     : ActiveDOMObject(&context)
     , m_registrationData(WTFMove(registrationData))
     , m_container(WTFMove(container))
-    , m_softUpdateTimer([this] { softUpdate(); })
 {
     LOG(ServiceWorker, "Creating registration %p for registration key %s", this, m_registrationData.key.loggingString().utf8().data());
     suspendIfNeeded();
 
     if (m_registrationData.installingWorker)
@@ -76,11 +74,10 @@
     REGISTRATION_RELEASE_LOG_IF_ALLOWED("ServiceWorkerRegistration: ID %llu, installing: %llu, waiting: %llu, active: %llu", identifier().toUInt64(), m_installingWorker ? m_installingWorker->identifier().toUInt64() : 0, m_waitingWorker ? m_waitingWorker->identifier().toUInt64() : 0, m_activeWorker ? m_activeWorker->identifier().toUInt64() : 0);
 
     m_container->addRegistration(*this);
 
     relaxAdoptionRequirement();
-    updatePendingActivityForEventDispatch();
 }
 
 ServiceWorkerRegistration::~ServiceWorkerRegistration()
 {
     LOG(ServiceWorker, "Deleting registration %p for registration key %s", this, m_registrationData.key.loggingString().utf8().data());
@@ -101,11 +98,11 @@
 ServiceWorker* ServiceWorkerRegistration::active()
 {
     return m_activeWorker.get();
 }
 
-ServiceWorker* ServiceWorkerRegistration::getNewestWorker()
+ServiceWorker* ServiceWorkerRegistration::getNewestWorker() const
 {
     if (m_installingWorker)
         return m_installingWorker.get();
     if (m_waitingWorker)
         return m_waitingWorker.get();
@@ -153,32 +150,10 @@
 
     // FIXME: Support worker types.
     m_container->updateRegistration(m_registrationData.scopeURL, newestWorker->scriptURL(), WorkerType::Classic, WTFMove(promise));
 }
 
-// To avoid scheduling many updates during a single page load, we do soft updates on a 1 second delay and keep delaying
-// as long as soft update requests keep coming. This seems to match Chrome's behavior.
-void ServiceWorkerRegistration::scheduleSoftUpdate()
-{
-    if (m_softUpdateTimer.isActive())
-        m_softUpdateTimer.stop();
-    m_softUpdateTimer.startOneShot(softUpdateDelay);
-}
-
-void ServiceWorkerRegistration::softUpdate()
-{
-    if (m_isStopped)
-        return;
-
-    auto* newestWorker = getNewestWorker();
-    if (!newestWorker)
-        return;
-
-    // FIXME: Support worker types.
-    m_container->updateRegistration(m_registrationData.scopeURL, newestWorker->scriptURL(), WorkerType::Classic, nullptr);
-}
-
 void ServiceWorkerRegistration::unregister(Ref<DeferredPromise>&& promise)
 {
     if (m_isStopped) {
         promise->reject(Exception(InvalidStateError));
         return;
@@ -201,22 +176,20 @@
     case ServiceWorkerRegistrationState::Active:
         REGISTRATION_RELEASE_LOG_IF_ALLOWED("updateStateFromServer: Setting registration %llu active worker to %llu", identifier().toUInt64(), serviceWorker ? serviceWorker->identifier().toUInt64() : 0);
         m_activeWorker = WTFMove(serviceWorker);
         break;
     }
-    updatePendingActivityForEventDispatch();
 }
 
-void ServiceWorkerRegistration::fireUpdateFoundEvent()
+void ServiceWorkerRegistration::queueTaskToFireUpdateFoundEvent()
 {
     if (m_isStopped)
         return;
 
     REGISTRATION_RELEASE_LOG_IF_ALLOWED("fireUpdateFoundEvent: Firing updatefound event for registration %llu", identifier().toUInt64());
 
-    ASSERT(m_pendingActivityForEventDispatch);
-    dispatchEvent(Event::create(eventNames().updatefoundEvent, Event::CanBubble::No, Event::IsCancelable::No));
+    queueTaskToDispatchEvent(*this, TaskSource::DOMManipulation, Event::create(eventNames().updatefoundEvent, Event::CanBubble::No, Event::IsCancelable::No));
 }
 
 EventTargetInterface ServiceWorkerRegistration::eventTargetInterface() const
 {
     return ServiceWorkerRegistrationEventTargetInterfaceType;
@@ -230,33 +203,22 @@
 const char* ServiceWorkerRegistration::activeDOMObjectName() const
 {
     return "ServiceWorkerRegistration";
 }
 
-bool ServiceWorkerRegistration::canSuspendForDocumentSuspension() const
-{
-    // FIXME: We should do better as this prevents a page from entering PageCache when there is a service worker registration.
-    return !hasPendingActivity();
-}
-
 void ServiceWorkerRegistration::stop()
 {
     m_isStopped = true;
     removeAllEventListeners();
-    updatePendingActivityForEventDispatch();
 }
 
-void ServiceWorkerRegistration::updatePendingActivityForEventDispatch()
+bool ServiceWorkerRegistration::hasPendingActivity() const
 {
-    // If a registration has no ServiceWorker, then it has been cleared on server-side.
-    if (m_isStopped || !getNewestWorker()) {
-        m_pendingActivityForEventDispatch = nullptr;
-        return;
-    }
-    if (m_pendingActivityForEventDispatch)
-        return;
-    m_pendingActivityForEventDispatch = makePendingActivity(*this);
+    if (!m_isStopped && getNewestWorker() && hasEventListeners())
+        return true;
+
+    return ActiveDOMObject::hasPendingActivity();
 }
 
 } // namespace WebCore
 
 #endif // ENABLE(SERVICE_WORKER)

diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoSubspaceInlines.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoSubspaceInlines.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoSubspaceInlines.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoSubspaceInlines.h
@@ -25,15 +25,34 @@
 
 #pragma once
 
 namespace JSC {
 
-ALWAYS_INLINE void* IsoSubspace::allocateNonVirtual(VM&, size_t size, GCDeferralContext* deferralContext, AllocationFailureMode failureMode)
+ALWAYS_INLINE void* IsoSubspace::allocateNonVirtual(VM& vm, size_t size, GCDeferralContext* deferralContext, AllocationFailureMode failureMode)
 {
-    RELEASE_ASSERT(size == this->size());
+    RELEASE_ASSERT(WTF::roundUpToMultipleOf<MarkedBlock::atomSize>(size) == cellSize());
     Allocator allocator = allocatorForNonVirtual(size, AllocatorForMode::MustAlreadyHaveAllocator);
-    void* result = allocator.allocate(deferralContext, failureMode);
+    void* result = allocator.allocate(vm.heap, deferralContext, failureMode);
     return result;
 }
 
+inline void IsoSubspace::clearIsoCellSetBit(PreciseAllocation* preciseAllocation)
+{
+    unsigned lowerTierIndex = preciseAllocation->lowerTierIndex();
+    m_cellSets.forEach(
+        [&](IsoCellSet* set) {
+            set->clearLowerTierCell(lowerTierIndex);
+        });
+}
+
+inline void IsoSubspace::sweep()
+{
+    Subspace::sweepBlocks();
+    // We sweep precise-allocations eagerly, but we do not free it immediately.
+    // This part should be done by MarkedSpace::sweepPreciseAllocations.
+    m_preciseAllocations.forEach([&](PreciseAllocation* allocation) {
+        allocation->sweep();
+    });
+}
+
 } // namespace JSC
 

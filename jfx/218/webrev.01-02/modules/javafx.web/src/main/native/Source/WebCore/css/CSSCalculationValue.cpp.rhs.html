<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/css/CSSCalculationValue.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2011, 2012 Google Inc. All rights reserved.
<a name="1" id="anc1"></a><span class="line-modified">   3  * Copyright (C) 2014, 2019 Apple Inc. All rights reserved.</span>
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions are
   7  * met:
   8  *
   9  *     * Redistributions of source code must retain the above copyright
  10  * notice, this list of conditions and the following disclaimer.
  11  *     * Redistributions in binary form must reproduce the above
  12  * copyright notice, this list of conditions and the following disclaimer
  13  * in the documentation and/or other materials provided with the
  14  * distribution.
  15  *     * Neither the name of Google Inc. nor the names of its
  16  * contributors may be used to endorse or promote products derived from
  17  * this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  30  */
  31 
  32 #include &quot;config.h&quot;
  33 #include &quot;CSSCalculationValue.h&quot;
  34 
  35 #include &quot;CSSParser.h&quot;
  36 #include &quot;CSSParserTokenRange.h&quot;
  37 #include &quot;CSSPrimitiveValueMappings.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  38 #include &quot;Logging.h&quot;</span>
  39 #include &quot;StyleResolver.h&quot;
  40 #include &lt;wtf/MathExtras.h&gt;
  41 #include &lt;wtf/text/StringBuilder.h&gt;
<a name="3" id="anc3"></a><span class="line-added">  42 #include &lt;wtf/text/TextStream.h&gt;</span>
  43 
  44 static const int maxExpressionDepth = 100;
  45 
<a name="4" id="anc4"></a><span class="line-modified">  46 namespace WebCore {</span>
<span class="line-modified">  47 class CSSCalcPrimitiveValueNode;</span>
<span class="line-modified">  48 class CSSCalcOperationNode;</span>
<span class="line-modified">  49 class CSSCalcNegateNode;</span>
<span class="line-modified">  50 class CSSCalcInvertNode;</span>
<span class="line-added">  51 }</span>
<span class="line-added">  52 </span>
<span class="line-added">  53 SPECIALIZE_TYPE_TRAITS_CSSCALCEXPRESSION_NODE(CSSCalcPrimitiveValueNode, type() == WebCore::CSSCalcExpressionNode::Type::CssCalcPrimitiveValue)</span>
<span class="line-added">  54 SPECIALIZE_TYPE_TRAITS_CSSCALCEXPRESSION_NODE(CSSCalcOperationNode, type() == WebCore::CSSCalcExpressionNode::Type::CssCalcOperation)</span>
<span class="line-added">  55 SPECIALIZE_TYPE_TRAITS_CSSCALCEXPRESSION_NODE(CSSCalcNegateNode, type() == WebCore::CSSCalcExpressionNode::Type::CssCalcNegate)</span>
<span class="line-added">  56 SPECIALIZE_TYPE_TRAITS_CSSCALCEXPRESSION_NODE(CSSCalcInvertNode, type() == WebCore::CSSCalcExpressionNode::Type::CssCalcInvert)</span>
  57 
  58 namespace WebCore {
  59 
  60 static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const CalcExpressionNode&amp;, const RenderStyle&amp;);
  61 static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const Length&amp;, const RenderStyle&amp;);
  62 
<a name="5" id="anc5"></a><span class="line-modified">  63 static TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const CSSCalcExpressionNode&amp; node)</span>
<span class="line-added">  64 {</span>
<span class="line-added">  65     node.dump(ts);</span>
<span class="line-added">  66     return ts;</span>
<span class="line-added">  67 }</span>
<span class="line-added">  68 </span>
<span class="line-added">  69 static CalculationCategory calcUnitCategory(CSSUnitType type)</span>
  70 {
  71     switch (type) {
<a name="6" id="anc6"></a><span class="line-modified">  72     case CSSUnitType::CSS_NUMBER:</span>
  73         return CalculationCategory::Number;
<a name="7" id="anc7"></a><span class="line-modified">  74     case CSSUnitType::CSS_EMS:</span>
<span class="line-modified">  75     case CSSUnitType::CSS_EXS:</span>
<span class="line-modified">  76     case CSSUnitType::CSS_PX:</span>
<span class="line-modified">  77     case CSSUnitType::CSS_CM:</span>
<span class="line-modified">  78     case CSSUnitType::CSS_MM:</span>
<span class="line-modified">  79     case CSSUnitType::CSS_IN:</span>
<span class="line-modified">  80     case CSSUnitType::CSS_PT:</span>
<span class="line-modified">  81     case CSSUnitType::CSS_PC:</span>
<span class="line-modified">  82     case CSSUnitType::CSS_Q:</span>
<span class="line-modified">  83     case CSSUnitType::CSS_REMS:</span>
<span class="line-modified">  84     case CSSUnitType::CSS_CHS:</span>
<span class="line-modified">  85     case CSSUnitType::CSS_VW:</span>
<span class="line-modified">  86     case CSSUnitType::CSS_VH:</span>
<span class="line-modified">  87     case CSSUnitType::CSS_VMIN:</span>
<span class="line-added">  88     case CSSUnitType::CSS_VMAX:</span>
  89         return CalculationCategory::Length;
<a name="8" id="anc8"></a><span class="line-modified">  90     case CSSUnitType::CSS_PERCENTAGE:</span>
  91         return CalculationCategory::Percent;
<a name="9" id="anc9"></a><span class="line-modified">  92     case CSSUnitType::CSS_DEG:</span>
<span class="line-modified">  93     case CSSUnitType::CSS_RAD:</span>
<span class="line-modified">  94     case CSSUnitType::CSS_GRAD:</span>
<span class="line-modified">  95     case CSSUnitType::CSS_TURN:</span>
  96         return CalculationCategory::Angle;
<a name="10" id="anc10"></a><span class="line-modified">  97     case CSSUnitType::CSS_MS:</span>
<span class="line-modified">  98     case CSSUnitType::CSS_S:</span>
  99         return CalculationCategory::Time;
<a name="11" id="anc11"></a><span class="line-modified"> 100     case CSSUnitType::CSS_HZ:</span>
<span class="line-modified"> 101     case CSSUnitType::CSS_KHZ:</span>
 102         return CalculationCategory::Frequency;
 103     default:
 104         return CalculationCategory::Other;
 105     }
 106 }
 107 
<a name="12" id="anc12"></a><span class="line-modified"> 108 static CalculationCategory calculationCategoryForCombination(CSSUnitType type)</span>
 109 {
 110     switch (type) {
<a name="13" id="anc13"></a><span class="line-modified"> 111     case CSSUnitType::CSS_NUMBER:</span>
<span class="line-modified"> 112         return CalculationCategory::Number;</span>
<span class="line-modified"> 113     case CSSUnitType::CSS_PX:</span>
<span class="line-modified"> 114     case CSSUnitType::CSS_CM:</span>
<span class="line-modified"> 115     case CSSUnitType::CSS_MM:</span>
<span class="line-modified"> 116     case CSSUnitType::CSS_IN:</span>
<span class="line-modified"> 117     case CSSUnitType::CSS_PT:</span>
<span class="line-modified"> 118     case CSSUnitType::CSS_PC:</span>
<span class="line-modified"> 119     case CSSUnitType::CSS_Q:</span>
<span class="line-modified"> 120         return CalculationCategory::Length;</span>
<span class="line-modified"> 121     case CSSUnitType::CSS_PERCENTAGE:</span>
<span class="line-modified"> 122         return CalculationCategory::Percent;</span>
<span class="line-modified"> 123     case CSSUnitType::CSS_DEG:</span>
<span class="line-modified"> 124     case CSSUnitType::CSS_RAD:</span>
<span class="line-modified"> 125     case CSSUnitType::CSS_GRAD:</span>
<span class="line-modified"> 126     case CSSUnitType::CSS_TURN:</span>
<span class="line-modified"> 127         return CalculationCategory::Angle;</span>
<span class="line-modified"> 128     case CSSUnitType::CSS_MS:</span>
<span class="line-modified"> 129     case CSSUnitType::CSS_S:</span>
<span class="line-modified"> 130         return CalculationCategory::Time;</span>
<span class="line-modified"> 131     case CSSUnitType::CSS_HZ:</span>
<span class="line-modified"> 132     case CSSUnitType::CSS_KHZ:</span>
<span class="line-modified"> 133         return CalculationCategory::Frequency;</span>
<span class="line-modified"> 134     case CSSUnitType::CSS_EMS:</span>
<span class="line-modified"> 135     case CSSUnitType::CSS_EXS:</span>
<span class="line-modified"> 136     case CSSUnitType::CSS_REMS:</span>
<span class="line-modified"> 137     case CSSUnitType::CSS_CHS:</span>
<span class="line-modified"> 138     case CSSUnitType::CSS_VW:</span>
<span class="line-modified"> 139     case CSSUnitType::CSS_VH:</span>
<span class="line-modified"> 140     case CSSUnitType::CSS_VMIN:</span>
<span class="line-modified"> 141     case CSSUnitType::CSS_VMAX:</span>
<span class="line-modified"> 142     default:</span>
<span class="line-modified"> 143         return CalculationCategory::Other;</span>
<span class="line-modified"> 144     }</span>




















 145 }
 146 
<a name="14" id="anc14"></a><span class="line-modified"> 147 static CSSUnitType canonicalUnitTypeForCalculationCategory(CalculationCategory category)</span>
 148 {
<a name="15" id="anc15"></a><span class="line-modified"> 149     switch (category) {</span>
<span class="line-modified"> 150     case CalculationCategory::Number: return CSSUnitType::CSS_NUMBER;</span>
<span class="line-modified"> 151     case CalculationCategory::Length: return CSSUnitType::CSS_PX;</span>
<span class="line-modified"> 152     case CalculationCategory::Percent: return CSSUnitType::CSS_PERCENTAGE;</span>
<span class="line-added"> 153     case CalculationCategory::Angle: return CSSUnitType::CSS_DEG;</span>
<span class="line-added"> 154     case CalculationCategory::Time: return CSSUnitType::CSS_MS;</span>
<span class="line-added"> 155     case CalculationCategory::Frequency: return CSSUnitType::CSS_HZ;</span>
<span class="line-added"> 156     case CalculationCategory::Other:</span>
<span class="line-added"> 157     case CalculationCategory::PercentNumber:</span>
<span class="line-added"> 158     case CalculationCategory::PercentLength:</span>
<span class="line-added"> 159         ASSERT_NOT_REACHED();</span>
<span class="line-added"> 160         break;</span>
<span class="line-added"> 161     }</span>
<span class="line-added"> 162     return CSSUnitType::CSS_UNKNOWN;</span>
 163 }
 164 
<a name="16" id="anc16"></a><span class="line-modified"> 165 static bool hasDoubleValue(CSSUnitType type)</span>
 166 {
<a name="17" id="anc17"></a><span class="line-modified"> 167     switch (type) {</span>
<span class="line-added"> 168     case CSSUnitType::CSS_NUMBER:</span>
<span class="line-added"> 169     case CSSUnitType::CSS_PERCENTAGE:</span>
<span class="line-added"> 170     case CSSUnitType::CSS_EMS:</span>
<span class="line-added"> 171     case CSSUnitType::CSS_EXS:</span>
<span class="line-added"> 172     case CSSUnitType::CSS_CHS:</span>
<span class="line-added"> 173     case CSSUnitType::CSS_REMS:</span>
<span class="line-added"> 174     case CSSUnitType::CSS_PX:</span>
<span class="line-added"> 175     case CSSUnitType::CSS_CM:</span>
<span class="line-added"> 176     case CSSUnitType::CSS_MM:</span>
<span class="line-added"> 177     case CSSUnitType::CSS_IN:</span>
<span class="line-added"> 178     case CSSUnitType::CSS_PT:</span>
<span class="line-added"> 179     case CSSUnitType::CSS_PC:</span>
<span class="line-added"> 180     case CSSUnitType::CSS_DEG:</span>
<span class="line-added"> 181     case CSSUnitType::CSS_RAD:</span>
<span class="line-added"> 182     case CSSUnitType::CSS_GRAD:</span>
<span class="line-added"> 183     case CSSUnitType::CSS_TURN:</span>
<span class="line-added"> 184     case CSSUnitType::CSS_MS:</span>
<span class="line-added"> 185     case CSSUnitType::CSS_S:</span>
<span class="line-added"> 186     case CSSUnitType::CSS_HZ:</span>
<span class="line-added"> 187     case CSSUnitType::CSS_KHZ:</span>
<span class="line-added"> 188     case CSSUnitType::CSS_DIMENSION:</span>
<span class="line-added"> 189     case CSSUnitType::CSS_VW:</span>
<span class="line-added"> 190     case CSSUnitType::CSS_VH:</span>
<span class="line-added"> 191     case CSSUnitType::CSS_VMIN:</span>
<span class="line-added"> 192     case CSSUnitType::CSS_VMAX:</span>
<span class="line-added"> 193     case CSSUnitType::CSS_DPPX:</span>
<span class="line-added"> 194     case CSSUnitType::CSS_DPI:</span>
<span class="line-added"> 195     case CSSUnitType::CSS_DPCM:</span>
<span class="line-added"> 196     case CSSUnitType::CSS_FR:</span>
<span class="line-added"> 197     case CSSUnitType::CSS_Q:</span>
<span class="line-added"> 198         return true;</span>
<span class="line-added"> 199     case CSSUnitType::CSS_UNKNOWN:</span>
<span class="line-added"> 200     case CSSUnitType::CSS_STRING:</span>
<span class="line-added"> 201     case CSSUnitType::CSS_FONT_FAMILY:</span>
<span class="line-added"> 202     case CSSUnitType::CSS_URI:</span>
<span class="line-added"> 203     case CSSUnitType::CSS_IDENT:</span>
<span class="line-added"> 204     case CSSUnitType::CSS_ATTR:</span>
<span class="line-added"> 205     case CSSUnitType::CSS_COUNTER:</span>
<span class="line-added"> 206     case CSSUnitType::CSS_RECT:</span>
<span class="line-added"> 207     case CSSUnitType::CSS_RGBCOLOR:</span>
<span class="line-added"> 208     case CSSUnitType::CSS_PAIR:</span>
<span class="line-added"> 209     case CSSUnitType::CSS_UNICODE_RANGE:</span>
<span class="line-added"> 210     case CSSUnitType::CSS_COUNTER_NAME:</span>
<span class="line-added"> 211     case CSSUnitType::CSS_SHAPE:</span>
<span class="line-added"> 212     case CSSUnitType::CSS_QUAD:</span>
<span class="line-added"> 213     case CSSUnitType::CSS_QUIRKY_EMS:</span>
<span class="line-added"> 214     case CSSUnitType::CSS_CALC:</span>
<span class="line-added"> 215     case CSSUnitType::CSS_CALC_PERCENTAGE_WITH_NUMBER:</span>
<span class="line-added"> 216     case CSSUnitType::CSS_CALC_PERCENTAGE_WITH_LENGTH:</span>
<span class="line-added"> 217     case CSSUnitType::CSS_PROPERTY_ID:</span>
<span class="line-added"> 218     case CSSUnitType::CSS_VALUE_ID:</span>
<span class="line-added"> 219         return false;</span>
<span class="line-added"> 220     };</span>
<span class="line-added"> 221     ASSERT_NOT_REACHED();</span>
<span class="line-added"> 222     return false;</span>
 223 }
 224 
<a name="18" id="anc18"></a><span class="line-modified"> 225 static CSSValueID functionFromOperator(CalcOperator op)</span>
 226 {
<a name="19" id="anc19"></a><span class="line-modified"> 227     switch (op) {</span>
<span class="line-added"> 228     case CalcOperator::Add:</span>
<span class="line-added"> 229     case CalcOperator::Subtract:</span>
<span class="line-added"> 230     case CalcOperator::Multiply:</span>
<span class="line-added"> 231     case CalcOperator::Divide:</span>
<span class="line-added"> 232         return CSSValueCalc;</span>
<span class="line-added"> 233     case CalcOperator::Min:</span>
<span class="line-added"> 234         return CSSValueMin;</span>
<span class="line-added"> 235     case CalcOperator::Max:</span>
<span class="line-added"> 236         return CSSValueMax;</span>
<span class="line-added"> 237     case CalcOperator::Clamp:</span>
<span class="line-added"> 238         return CSSValueClamp;</span>
<span class="line-added"> 239     }</span>
<span class="line-added"> 240     return CSSValueCalc;</span>
 241 }
 242 
<a name="20" id="anc20"></a><span class="line-modified"> 243 #if !LOG_DISABLED</span>
<span class="line-added"> 244 static String prettyPrintNode(const CSSCalcExpressionNode&amp; node)</span>
 245 {
<a name="21" id="anc21"></a><span class="line-modified"> 246     TextStream multilineStream;</span>
<span class="line-added"> 247     multilineStream &lt;&lt; node;</span>
<span class="line-added"> 248     return multilineStream.release();</span>
 249 }
 250 
<a name="22" id="anc22"></a><span class="line-modified"> 251 static String prettyPrintNodes(const Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp; nodes)</span>
 252 {
<a name="23" id="anc23"></a><span class="line-modified"> 253     TextStream multilineStream;</span>
<span class="line-added"> 254     multilineStream &lt;&lt; nodes;</span>
<span class="line-added"> 255     return multilineStream.release();</span>
 256 }
<a name="24" id="anc24"></a><span class="line-added"> 257 #endif</span>
 258 
<a name="25" id="anc25"></a><span class="line-modified"> 259 class CSSCalcPrimitiveValueNode final : public CSSCalcExpressionNode {</span>
 260     WTF_MAKE_FAST_ALLOCATED;
 261 public:
<a name="26" id="anc26"></a><span class="line-modified"> 262     static Ref&lt;CSSCalcPrimitiveValueNode&gt; create(Ref&lt;CSSPrimitiveValue&gt;&amp;&amp; value)</span>
 263     {
<a name="27" id="anc27"></a><span class="line-modified"> 264         return adoptRef(*new CSSCalcPrimitiveValueNode(WTFMove(value)));</span>
 265     }
 266 
<a name="28" id="anc28"></a><span class="line-modified"> 267     static RefPtr&lt;CSSCalcPrimitiveValueNode&gt; create(double value, CSSUnitType type)</span>
 268     {
 269         if (!std::isfinite(value))
 270             return nullptr;
<a name="29" id="anc29"></a><span class="line-modified"> 271         return adoptRef(new CSSCalcPrimitiveValueNode(CSSPrimitiveValue::create(value, type)));</span>
<span class="line-added"> 272     }</span>
<span class="line-added"> 273 </span>
<span class="line-added"> 274     String customCSSText() const</span>
<span class="line-added"> 275     {</span>
<span class="line-added"> 276         return m_value-&gt;cssText();</span>
<span class="line-added"> 277     }</span>
<span class="line-added"> 278 </span>
<span class="line-added"> 279     CSSUnitType primitiveType() const final</span>
<span class="line-added"> 280     {</span>
<span class="line-added"> 281         return m_value-&gt;primitiveType();</span>
 282     }
 283 
<a name="30" id="anc30"></a><span class="line-added"> 284     bool isNumericValue() const;</span>
<span class="line-added"> 285     bool isNegative() const;</span>
<span class="line-added"> 286 </span>
<span class="line-added"> 287     void negate();</span>
<span class="line-added"> 288     void invert();</span>
<span class="line-added"> 289 </span>
<span class="line-added"> 290     enum class UnitConversion {</span>
<span class="line-added"> 291         Invalid,</span>
<span class="line-added"> 292         Preserve,</span>
<span class="line-added"> 293         Canonicalize</span>
<span class="line-added"> 294     };</span>
<span class="line-added"> 295     void add(const CSSCalcPrimitiveValueNode&amp;, UnitConversion = UnitConversion::Preserve);</span>
<span class="line-added"> 296     void multiply(double);</span>
<span class="line-added"> 297 </span>
<span class="line-added"> 298     void convertToUnitType(CSSUnitType);</span>
<span class="line-added"> 299     void canonicalizeUnit();</span>
<span class="line-added"> 300 </span>
<span class="line-added"> 301     const CSSPrimitiveValue&amp; value() const { return m_value.get(); }</span>
<span class="line-added"> 302 </span>
 303 private:
 304     bool isZero() const final
 305     {
 306         return !m_value-&gt;doubleValue();
 307     }
 308 
<a name="31" id="anc31"></a><span class="line-modified"> 309     bool equals(const CSSCalcExpressionNode&amp; other) const final;</span>
<span class="line-added"> 310     Type type() const final { return CssCalcPrimitiveValue; }</span>
<span class="line-added"> 311 </span>
<span class="line-added"> 312     std::unique_ptr&lt;CalcExpressionNode&gt; createCalcExpression(const CSSToLengthConversionData&amp;) const final;</span>
<span class="line-added"> 313     double doubleValue(CSSUnitType) const final;</span>
<span class="line-added"> 314 </span>
<span class="line-added"> 315     double computeLengthPx(const CSSToLengthConversionData&amp;) const final;</span>
<span class="line-added"> 316     void collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp;) const final;</span>
<span class="line-added"> 317     void collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp;) const final;</span>
<span class="line-added"> 318 </span>
<span class="line-added"> 319     void dump(TextStream&amp;) const final;</span>
<span class="line-added"> 320 </span>
<span class="line-added"> 321 private:</span>
<span class="line-added"> 322     explicit CSSCalcPrimitiveValueNode(Ref&lt;CSSPrimitiveValue&gt;&amp;&amp; value)</span>
<span class="line-added"> 323         : CSSCalcExpressionNode(calcUnitCategory(value-&gt;primitiveType()))</span>
<span class="line-added"> 324         , m_value(WTFMove(value))</span>
 325     {
<a name="32" id="anc32"></a>
 326     }
 327 
<a name="33" id="anc33"></a><span class="line-modified"> 328     Ref&lt;CSSPrimitiveValue&gt; m_value;</span>
<span class="line-modified"> 329 };</span>
<span class="line-modified"> 330 </span>
<span class="line-modified"> 331 // FIXME: Use calcUnitCategory?</span>
<span class="line-modified"> 332 bool CSSCalcPrimitiveValueNode::isNumericValue() const</span>
<span class="line-modified"> 333 {</span>
<span class="line-modified"> 334     return m_value-&gt;isLength() || m_value-&gt;isNumber() || m_value-&gt;isPercentage() || m_value-&gt;isAngle()</span>
<span class="line-modified"> 335         || m_value-&gt;isTime() || m_value-&gt;isResolution() || m_value-&gt;isFlex() || m_value-&gt;isFrequency();</span>
<span class="line-modified"> 336 }</span>
<span class="line-modified"> 337 </span>
<span class="line-modified"> 338 bool CSSCalcPrimitiveValueNode::isNegative() const</span>
<span class="line-modified"> 339 {</span>
<span class="line-modified"> 340     return isNumericValue() &amp;&amp; m_value-&gt;doubleValue() &lt; 0.0;</span>
<span class="line-modified"> 341 }</span>
<span class="line-modified"> 342 </span>
<span class="line-modified"> 343 void CSSCalcPrimitiveValueNode::negate()</span>
<span class="line-modified"> 344 {</span>
<span class="line-modified"> 345     ASSERT(isNumericValue());</span>
<span class="line-modified"> 346     m_value = CSSPrimitiveValue::create(0.0 - m_value-&gt;doubleValue(), m_value-&gt;primitiveType());</span>
<span class="line-modified"> 347 }</span>
<span class="line-added"> 348 </span>
<span class="line-added"> 349 void CSSCalcPrimitiveValueNode::invert()</span>
<span class="line-added"> 350 {</span>
<span class="line-added"> 351     ASSERT(isNumericValue());</span>
<span class="line-added"> 352     if (!m_value-&gt;doubleValue())</span>
<span class="line-added"> 353         m_value = CSSPrimitiveValue::create(std::numeric_limits&lt;double&gt;::infinity(), m_value-&gt;primitiveType());</span>
<span class="line-added"> 354 </span>
<span class="line-added"> 355     m_value = CSSPrimitiveValue::create(1.0 / m_value-&gt;doubleValue(), m_value-&gt;primitiveType());</span>
<span class="line-added"> 356 }</span>
<span class="line-added"> 357 </span>
<span class="line-added"> 358 void CSSCalcPrimitiveValueNode::add(const CSSCalcPrimitiveValueNode&amp; node, UnitConversion unitConversion)</span>
<span class="line-added"> 359 {</span>
<span class="line-added"> 360     auto valueType = m_value-&gt;primitiveType();</span>
<span class="line-added"> 361 </span>
<span class="line-added"> 362     switch (unitConversion) {</span>
<span class="line-added"> 363     case UnitConversion::Invalid:</span>
 364         ASSERT_NOT_REACHED();
<a name="34" id="anc34"></a><span class="line-modified"> 365         break;</span>
<span class="line-added"> 366     case UnitConversion::Preserve:</span>
<span class="line-added"> 367         ASSERT(node.primitiveType() == valueType);</span>
<span class="line-added"> 368         m_value = CSSPrimitiveValue::create(m_value-&gt;doubleValue() + node.doubleValue(valueType), valueType);</span>
<span class="line-added"> 369         break;</span>
<span class="line-added"> 370     case UnitConversion::Canonicalize: {</span>
<span class="line-added"> 371         auto valueCategory = unitCategory(valueType);</span>
<span class="line-added"> 372         // FIXME: It&#39;s awkward that canonicalUnitTypeForCategory() has special handling for CSSUnitCategory::Percent.</span>
<span class="line-added"> 373         auto canonicalType = valueCategory == CSSUnitCategory::Percent ? CSSUnitType::CSS_PERCENTAGE : canonicalUnitTypeForCategory(valueCategory);</span>
<span class="line-added"> 374         ASSERT(canonicalType != CSSUnitType::CSS_UNKNOWN);</span>
<span class="line-added"> 375         double leftValue = m_value-&gt;doubleValue(canonicalType);</span>
<span class="line-added"> 376         double rightValue = node.doubleValue(canonicalType);</span>
<span class="line-added"> 377         m_value = CSSPrimitiveValue::create(leftValue + rightValue, canonicalType);</span>
<span class="line-added"> 378         break;</span>
<span class="line-added"> 379     }</span>
 380     }
<a name="35" id="anc35"></a><span class="line-added"> 381 }</span>
 382 
<a name="36" id="anc36"></a><span class="line-modified"> 383 void CSSCalcPrimitiveValueNode::multiply(double multiplier)</span>
<span class="line-modified"> 384 {</span>
<span class="line-modified"> 385     auto valueType = m_value-&gt;primitiveType();</span>
<span class="line-modified"> 386     ASSERT(hasDoubleValue(valueType));</span>
<span class="line-added"> 387     m_value = CSSPrimitiveValue::create(m_value-&gt;doubleValue(valueType) * multiplier, valueType);</span>
<span class="line-added"> 388 }</span>
<span class="line-added"> 389 </span>
<span class="line-added"> 390 void CSSCalcPrimitiveValueNode::convertToUnitType(CSSUnitType unitType)</span>
<span class="line-added"> 391 {</span>
<span class="line-added"> 392     ASSERT(unitCategory(unitType) == unitCategory(m_value-&gt;primitiveType()));</span>
<span class="line-added"> 393     double newValue = m_value-&gt;doubleValue(unitType);</span>
<span class="line-added"> 394     m_value = CSSPrimitiveValue::create(newValue, unitType);</span>
<span class="line-added"> 395 }</span>
<span class="line-added"> 396 </span>
<span class="line-added"> 397 void CSSCalcPrimitiveValueNode::canonicalizeUnit()</span>
<span class="line-added"> 398 {</span>
<span class="line-added"> 399     auto category = calculationCategoryForCombination(m_value-&gt;primitiveType());</span>
<span class="line-added"> 400     if (category == CalculationCategory::Other)</span>
<span class="line-added"> 401         return;</span>
<span class="line-added"> 402 </span>
<span class="line-added"> 403     auto canonicalType = canonicalUnitTypeForCalculationCategory(category);</span>
<span class="line-added"> 404     if (canonicalType == m_value-&gt;primitiveType())</span>
<span class="line-added"> 405         return;</span>
<span class="line-added"> 406 </span>
<span class="line-added"> 407     double newValue = m_value-&gt;doubleValue(canonicalType);</span>
<span class="line-added"> 408     m_value = CSSPrimitiveValue::create(newValue, canonicalType);</span>
<span class="line-added"> 409 }</span>
<span class="line-added"> 410 </span>
<span class="line-added"> 411 std::unique_ptr&lt;CalcExpressionNode&gt; CSSCalcPrimitiveValueNode::createCalcExpression(const CSSToLengthConversionData&amp; conversionData) const</span>
<span class="line-added"> 412 {</span>
<span class="line-added"> 413     switch (category()) {</span>
<span class="line-added"> 414     case CalculationCategory::Number:</span>
<span class="line-added"> 415         return makeUnique&lt;CalcExpressionNumber&gt;(m_value-&gt;floatValue());</span>
<span class="line-added"> 416     case CalculationCategory::Length:</span>
<span class="line-added"> 417         return makeUnique&lt;CalcExpressionLength&gt;(Length(m_value-&gt;computeLength&lt;float&gt;(conversionData), WebCore::Fixed));</span>
<span class="line-added"> 418     case CalculationCategory::Percent:</span>
<span class="line-added"> 419     case CalculationCategory::PercentLength: {</span>
<span class="line-added"> 420         return makeUnique&lt;CalcExpressionLength&gt;(m_value-&gt;convertToLength&lt;FixedFloatConversion | PercentConversion&gt;(conversionData));</span>
<span class="line-added"> 421     }</span>
<span class="line-added"> 422     // Only types that could be part of a Length expression can be converted</span>
<span class="line-added"> 423     // to a CalcExpressionNode. CalculationCategory::PercentNumber makes no sense as a Length.</span>
<span class="line-added"> 424     case CalculationCategory::PercentNumber:</span>
<span class="line-added"> 425     case CalculationCategory::Angle:</span>
<span class="line-added"> 426     case CalculationCategory::Time:</span>
<span class="line-added"> 427     case CalculationCategory::Frequency:</span>
<span class="line-added"> 428     case CalculationCategory::Other:</span>
 429         ASSERT_NOT_REACHED();
<a name="37" id="anc37"></a>
 430     }
<a name="38" id="anc38"></a><span class="line-added"> 431     ASSERT_NOT_REACHED();</span>
<span class="line-added"> 432     return nullptr;</span>
<span class="line-added"> 433 }</span>
 434 
<a name="39" id="anc39"></a><span class="line-modified"> 435 double CSSCalcPrimitiveValueNode::doubleValue(CSSUnitType unitType) const</span>
<span class="line-modified"> 436 {</span>
<span class="line-modified"> 437     if (hasDoubleValue(unitType)) {</span>
<span class="line-modified"> 438         // FIXME: This should ASSERT(unitCategory(m_value-&gt;primitiveType()) == unitCategory(unitType)), but only when all callers are fixed (e.g. webkit.org/b/204826).</span>
<span class="line-modified"> 439         if (unitCategory(m_value-&gt;primitiveType()) != unitCategory(unitType)) {</span>
<span class="line-modified"> 440             LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Calling doubleValue() with unit &quot; &lt;&lt; unitType &lt;&lt; &quot; on a node of unit type &quot; &lt;&lt; m_value-&gt;primitiveType() &lt;&lt; &quot; which is incompatible&quot;);</span>
<span class="line-modified"> 441             return 0;</span>









 442         }
<a name="40" id="anc40"></a><span class="line-added"> 443 </span>
<span class="line-added"> 444         return m_value-&gt;doubleValue(unitType);</span>
<span class="line-added"> 445     }</span>
<span class="line-added"> 446     ASSERT_NOT_REACHED();</span>
<span class="line-added"> 447     return 0;</span>
<span class="line-added"> 448 }</span>
<span class="line-added"> 449 </span>
<span class="line-added"> 450 double CSSCalcPrimitiveValueNode::computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const</span>
<span class="line-added"> 451 {</span>
<span class="line-added"> 452     switch (category()) {</span>
<span class="line-added"> 453     case CalculationCategory::Length:</span>
<span class="line-added"> 454         return m_value-&gt;computeLength&lt;double&gt;(conversionData);</span>
<span class="line-added"> 455     case CalculationCategory::Percent:</span>
<span class="line-added"> 456     case CalculationCategory::Number:</span>
<span class="line-added"> 457         return m_value-&gt;doubleValue();</span>
<span class="line-added"> 458     case CalculationCategory::PercentLength:</span>
<span class="line-added"> 459     case CalculationCategory::PercentNumber:</span>
<span class="line-added"> 460     case CalculationCategory::Angle:</span>
<span class="line-added"> 461     case CalculationCategory::Time:</span>
<span class="line-added"> 462     case CalculationCategory::Frequency:</span>
<span class="line-added"> 463     case CalculationCategory::Other:</span>
 464         ASSERT_NOT_REACHED();
<a name="41" id="anc41"></a><span class="line-modified"> 465         break;</span>
 466     }
<a name="42" id="anc42"></a><span class="line-added"> 467     ASSERT_NOT_REACHED();</span>
<span class="line-added"> 468     return 0;</span>
<span class="line-added"> 469 }</span>
<span class="line-added"> 470 </span>
<span class="line-added"> 471 void CSSCalcPrimitiveValueNode::collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const</span>
<span class="line-added"> 472 {</span>
<span class="line-added"> 473     m_value-&gt;collectDirectComputationalDependencies(values);</span>
<span class="line-added"> 474 }</span>
<span class="line-added"> 475 </span>
<span class="line-added"> 476 void CSSCalcPrimitiveValueNode::collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const</span>
<span class="line-added"> 477 {</span>
<span class="line-added"> 478     m_value-&gt;collectDirectRootComputationalDependencies(values);</span>
<span class="line-added"> 479 }</span>
<span class="line-added"> 480 </span>
<span class="line-added"> 481 bool CSSCalcPrimitiveValueNode::equals(const CSSCalcExpressionNode&amp; other) const</span>
<span class="line-added"> 482 {</span>
<span class="line-added"> 483     if (type() != other.type())</span>
<span class="line-added"> 484         return false;</span>
<span class="line-added"> 485 </span>
<span class="line-added"> 486     return compareCSSValue(m_value, static_cast&lt;const CSSCalcPrimitiveValueNode&amp;&gt;(other).m_value);</span>
<span class="line-added"> 487 }</span>
<span class="line-added"> 488 </span>
<span class="line-added"> 489 void CSSCalcPrimitiveValueNode::dump(TextStream&amp; ts) const</span>
<span class="line-added"> 490 {</span>
<span class="line-added"> 491     ts &lt;&lt; &quot;value &quot; &lt;&lt; m_value-&gt;customCSSText() &lt;&lt; &quot; (category: &quot; &lt;&lt; category() &lt;&lt; &quot;, type: &quot; &lt;&lt; primitiveType() &lt;&lt; &quot;)&quot;;</span>
<span class="line-added"> 492 }</span>
 493 
<a name="43" id="anc43"></a><span class="line-modified"> 494 class CSSCalcNegateNode final : public CSSCalcExpressionNode {</span>
<span class="line-added"> 495 public:</span>
<span class="line-added"> 496     static Ref&lt;CSSCalcNegateNode&gt; create(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child)</span>
 497     {
<a name="44" id="anc44"></a><span class="line-modified"> 498         return adoptRef(*new CSSCalcNegateNode(WTFMove(child)));</span>
 499     }
 500 
<a name="45" id="anc45"></a><span class="line-modified"> 501     const CSSCalcExpressionNode&amp; child() const { return m_child.get(); }</span>
<span class="line-added"> 502     CSSCalcExpressionNode&amp; child() { return m_child.get(); }</span>
<span class="line-added"> 503 </span>
<span class="line-added"> 504     void setChild(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child) { m_child = WTFMove(child); }</span>
<span class="line-added"> 505 </span>
<span class="line-added"> 506 private:</span>
<span class="line-added"> 507     CSSCalcNegateNode(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child)</span>
<span class="line-added"> 508         : CSSCalcExpressionNode(child-&gt;category())</span>
<span class="line-added"> 509         , m_child(WTFMove(child))</span>
 510     {
<a name="46" id="anc46"></a>
 511     }
 512 
<a name="47" id="anc47"></a><span class="line-modified"> 513     std::unique_ptr&lt;CalcExpressionNode&gt; createCalcExpression(const CSSToLengthConversionData&amp;) const final;</span>



 514 
<a name="48" id="anc48"></a><span class="line-modified"> 515     bool isZero() const final { return m_child-&gt;isZero(); }</span>
<span class="line-modified"> 516     double doubleValue(CSSUnitType unitType) const final { return -m_child-&gt;doubleValue(unitType); }</span>
<span class="line-added"> 517     double computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const final { return -m_child-&gt;computeLengthPx(conversionData); }</span>
<span class="line-added"> 518     Type type() const final { return Type::CssCalcNegate; }</span>
<span class="line-added"> 519     CSSUnitType primitiveType() const final { return m_child-&gt;primitiveType(); }</span>
 520 
<a name="49" id="anc49"></a><span class="line-modified"> 521     void collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; properties) const final { m_child-&gt;collectDirectComputationalDependencies(properties); }</span>
<span class="line-modified"> 522     void collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; properties) const final { m_child-&gt;collectDirectRootComputationalDependencies(properties); }</span>
<span class="line-added"> 523 </span>
<span class="line-added"> 524     void dump(TextStream&amp;) const final;</span>
<span class="line-added"> 525 </span>
<span class="line-added"> 526     Ref&lt;CSSCalcExpressionNode&gt; m_child;</span>
<span class="line-added"> 527 };</span>
<span class="line-added"> 528 </span>
<span class="line-added"> 529 std::unique_ptr&lt;CalcExpressionNode&gt; CSSCalcNegateNode::createCalcExpression(const CSSToLengthConversionData&amp; conversionData) const</span>
<span class="line-added"> 530 {</span>
<span class="line-added"> 531     auto childNode = m_child-&gt;createCalcExpression(conversionData);</span>
<span class="line-added"> 532     return makeUnique&lt;CalcExpressionNegation&gt;(WTFMove(childNode));</span>
<span class="line-added"> 533 }</span>
<span class="line-added"> 534 </span>
<span class="line-added"> 535 void CSSCalcNegateNode::dump(TextStream&amp; ts) const</span>
<span class="line-added"> 536 {</span>
<span class="line-added"> 537     ts &lt;&lt; &quot;-&quot; &lt;&lt; m_child.get();</span>
<span class="line-added"> 538 }</span>
<span class="line-added"> 539 </span>
<span class="line-added"> 540 class CSSCalcInvertNode final : public CSSCalcExpressionNode {</span>
<span class="line-added"> 541 public:</span>
<span class="line-added"> 542     static Ref&lt;CSSCalcInvertNode&gt; create(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child)</span>
 543     {
<a name="50" id="anc50"></a><span class="line-modified"> 544         return adoptRef(*new CSSCalcInvertNode(WTFMove(child)));</span>
 545     }
 546 
<a name="51" id="anc51"></a><span class="line-added"> 547     const CSSCalcExpressionNode&amp; child() const { return m_child.get(); }</span>
<span class="line-added"> 548     CSSCalcExpressionNode&amp; child() { return m_child.get(); }</span>
<span class="line-added"> 549 </span>
<span class="line-added"> 550     void setChild(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child) { m_child = WTFMove(child); }</span>
<span class="line-added"> 551 </span>
 552 private:
<a name="52" id="anc52"></a><span class="line-modified"> 553     CSSCalcInvertNode(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; child)</span>
<span class="line-modified"> 554         : CSSCalcExpressionNode(child-&gt;category())</span>
<span class="line-modified"> 555         , m_child(WTFMove(child))</span>
 556     {
 557     }
 558 
<a name="53" id="anc53"></a><span class="line-modified"> 559     std::unique_ptr&lt;CalcExpressionNode&gt; createCalcExpression(const CSSToLengthConversionData&amp;) const final;</span>
<span class="line-added"> 560 </span>
<span class="line-added"> 561     bool isZero() const final { return m_child-&gt;isZero(); }</span>
<span class="line-added"> 562     double doubleValue(CSSUnitType) const final;</span>
<span class="line-added"> 563     double computeLengthPx(const CSSToLengthConversionData&amp;) const final;</span>
<span class="line-added"> 564     Type type() const final { return Type::CssCalcInvert; }</span>
<span class="line-added"> 565     CSSUnitType primitiveType() const final { return m_child-&gt;primitiveType(); }</span>
<span class="line-added"> 566 </span>
<span class="line-added"> 567     void collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; properties) const final { m_child-&gt;collectDirectComputationalDependencies(properties); }</span>
<span class="line-added"> 568     void collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; properties) const final { m_child-&gt;collectDirectRootComputationalDependencies(properties); }</span>
<span class="line-added"> 569 </span>
<span class="line-added"> 570     void dump(TextStream&amp;) const final;</span>
<span class="line-added"> 571 </span>
<span class="line-added"> 572     Ref&lt;CSSCalcExpressionNode&gt; m_child;</span>
 573 };
 574 
<a name="54" id="anc54"></a><span class="line-added"> 575 std::unique_ptr&lt;CalcExpressionNode&gt; CSSCalcInvertNode::createCalcExpression(const CSSToLengthConversionData&amp; conversionData) const</span>
<span class="line-added"> 576 {</span>
<span class="line-added"> 577     auto childNode = m_child-&gt;createCalcExpression(conversionData);</span>
<span class="line-added"> 578     return makeUnique&lt;CalcExpressionInversion&gt;(WTFMove(childNode));</span>
<span class="line-added"> 579 }</span>
<span class="line-added"> 580 </span>
<span class="line-added"> 581 double CSSCalcInvertNode::doubleValue(CSSUnitType unitType) const</span>
<span class="line-added"> 582 {</span>
<span class="line-added"> 583     auto childValue = m_child-&gt;doubleValue(unitType);</span>
<span class="line-added"> 584     if (!childValue)</span>
<span class="line-added"> 585         return std::numeric_limits&lt;double&gt;::infinity();</span>
<span class="line-added"> 586     return 1.0 / childValue;</span>
<span class="line-added"> 587 }</span>
<span class="line-added"> 588 </span>
<span class="line-added"> 589 double CSSCalcInvertNode::computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const</span>
<span class="line-added"> 590 {</span>
<span class="line-added"> 591     auto childValue = m_child-&gt;computeLengthPx(conversionData);</span>
<span class="line-added"> 592     if (!childValue)</span>
<span class="line-added"> 593         return std::numeric_limits&lt;double&gt;::infinity();</span>
<span class="line-added"> 594     return 1.0 / childValue;</span>
<span class="line-added"> 595 }</span>
<span class="line-added"> 596 </span>
<span class="line-added"> 597 void CSSCalcInvertNode::dump(TextStream&amp; ts) const</span>
<span class="line-added"> 598 {</span>
<span class="line-added"> 599     ts &lt;&lt; &quot;1/&quot; &lt;&lt; m_child.get();</span>
<span class="line-added"> 600 }</span>
<span class="line-added"> 601 </span>
<span class="line-added"> 602 // This is the result of the &quot;To add two types type1 and type2, perform the following steps:&quot; rules.</span>
<span class="line-added"> 603 </span>
 604 static const CalculationCategory addSubtractResult[static_cast&lt;unsigned&gt;(CalculationCategory::Angle)][static_cast&lt;unsigned&gt;(CalculationCategory::Angle)] = {
 605 //    CalculationCategory::Number         CalculationCategory::Length         CalculationCategory::Percent        CalculationCategory::PercentNumber  CalculationCategory::PercentLength
 606     { CalculationCategory::Number,        CalculationCategory::Other,         CalculationCategory::PercentNumber, CalculationCategory::PercentNumber, CalculationCategory::Other }, //         CalculationCategory::Number
 607     { CalculationCategory::Other,         CalculationCategory::Length,        CalculationCategory::PercentLength, CalculationCategory::Other,         CalculationCategory::PercentLength }, // CalculationCategory::Length
 608     { CalculationCategory::PercentNumber, CalculationCategory::PercentLength, CalculationCategory::Percent,       CalculationCategory::PercentNumber, CalculationCategory::PercentLength }, // CalculationCategory::Percent
 609     { CalculationCategory::PercentNumber, CalculationCategory::Other,         CalculationCategory::PercentNumber, CalculationCategory::PercentNumber, CalculationCategory::Other }, //         CalculationCategory::PercentNumber
 610     { CalculationCategory::Other,         CalculationCategory::PercentLength, CalculationCategory::PercentLength, CalculationCategory::Other,         CalculationCategory::PercentLength }, // CalculationCategory::PercentLength
 611 };
 612 
 613 static CalculationCategory determineCategory(const CSSCalcExpressionNode&amp; leftSide, const CSSCalcExpressionNode&amp; rightSide, CalcOperator op)
 614 {
 615     CalculationCategory leftCategory = leftSide.category();
 616     CalculationCategory rightCategory = rightSide.category();
 617     ASSERT(leftCategory &lt; CalculationCategory::Other);
 618     ASSERT(rightCategory &lt; CalculationCategory::Other);
 619 
 620     switch (op) {
 621     case CalcOperator::Add:
 622     case CalcOperator::Subtract:
 623         if (leftCategory &lt; CalculationCategory::Angle &amp;&amp; rightCategory &lt; CalculationCategory::Angle)
 624             return addSubtractResult[static_cast&lt;unsigned&gt;(leftCategory)][static_cast&lt;unsigned&gt;(rightCategory)];
 625         if (leftCategory == rightCategory)
 626             return leftCategory;
 627         return CalculationCategory::Other;
 628     case CalcOperator::Multiply:
 629         if (leftCategory != CalculationCategory::Number &amp;&amp; rightCategory != CalculationCategory::Number)
 630             return CalculationCategory::Other;
 631         return leftCategory == CalculationCategory::Number ? rightCategory : leftCategory;
 632     case CalcOperator::Divide:
 633         if (rightCategory != CalculationCategory::Number || rightSide.isZero())
 634             return CalculationCategory::Other;
 635         return leftCategory;
 636     case CalcOperator::Min:
 637     case CalcOperator::Max:
<a name="55" id="anc55"></a><span class="line-added"> 638     case CalcOperator::Clamp:</span>
 639         ASSERT_NOT_REACHED();
 640         return CalculationCategory::Other;
 641     }
 642 
 643     ASSERT_NOT_REACHED();
 644     return CalculationCategory::Other;
 645 }
 646 
<a name="56" id="anc56"></a><span class="line-modified"> 647 // FIXME: Need to implement correct category computation per:</span>
<span class="line-added"> 648 // &lt;https://drafts.css-houdini.org/css-typed-om-1/#cssnumericvalue-invert-a-type&gt;</span>
<span class="line-added"> 649 // To invert a type type, perform the following steps:</span>
<span class="line-added"> 650 // Let result be a new type with an initially empty ordered map and an initially null percent hint</span>
<span class="line-added"> 651 // For each unit → exponent of type, set result[unit] to (-1 * exponent).</span>
<span class="line-added"> 652 static CalculationCategory categoryForInvert(CalculationCategory category)</span>
<span class="line-added"> 653 {</span>
<span class="line-added"> 654     return category;</span>
<span class="line-added"> 655 }</span>
<span class="line-added"> 656 </span>
<span class="line-added"> 657 static CalculationCategory determineCategory(const Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp; nodes, CalcOperator op)</span>
<span class="line-added"> 658 {</span>
<span class="line-added"> 659     if (nodes.isEmpty())</span>
<span class="line-added"> 660         return CalculationCategory::Other;</span>
<span class="line-added"> 661 </span>
<span class="line-added"> 662     auto currentCategory = nodes[0]-&gt;category();</span>
<span class="line-added"> 663 </span>
<span class="line-added"> 664     for (unsigned i = 1; i &lt; nodes.size(); ++i) {</span>
<span class="line-added"> 665         const auto&amp; node = nodes[i].get();</span>
<span class="line-added"> 666 </span>
<span class="line-added"> 667         auto usedOperator = op;</span>
<span class="line-added"> 668         if (node.type() == CSSCalcExpressionNode::Type::CssCalcInvert)</span>
<span class="line-added"> 669             usedOperator = CalcOperator::Divide;</span>
<span class="line-added"> 670 </span>
<span class="line-added"> 671         auto nextCategory = node.category();</span>
<span class="line-added"> 672 </span>
<span class="line-added"> 673         switch (usedOperator) {</span>
<span class="line-added"> 674         case CalcOperator::Add:</span>
<span class="line-added"> 675         case CalcOperator::Subtract:</span>
<span class="line-added"> 676             // &lt;https://drafts.css-houdini.org/css-typed-om-1/#cssnumericvalue-add-two-types&gt;</span>
<span class="line-added"> 677             // At a + or - sub-expression, attempt to add the types of the left and right arguments.</span>
<span class="line-added"> 678             // If this returns failure, the entire calculation’s type is failure. Otherwise, the sub-expression’s type is the returned type.</span>
<span class="line-added"> 679             if (currentCategory &lt; CalculationCategory::Angle &amp;&amp; nextCategory &lt; CalculationCategory::Angle)</span>
<span class="line-added"> 680                 currentCategory = addSubtractResult[static_cast&lt;unsigned&gt;(currentCategory)][static_cast&lt;unsigned&gt;(nextCategory)];</span>
<span class="line-added"> 681             else if (currentCategory != nextCategory)</span>
<span class="line-added"> 682                 return CalculationCategory::Other;</span>
<span class="line-added"> 683             break;</span>
<span class="line-added"> 684 </span>
<span class="line-added"> 685         case CalcOperator::Multiply:</span>
<span class="line-added"> 686             // &lt;https://drafts.css-houdini.org/css-typed-om-1/#cssnumericvalue-multiply-two-types&gt;</span>
<span class="line-added"> 687             // At a * sub-expression, multiply the types of the left and right arguments. The sub-expression’s type is the returned result.</span>
<span class="line-added"> 688             if (currentCategory != CalculationCategory::Number &amp;&amp; nextCategory != CalculationCategory::Number)</span>
<span class="line-added"> 689                 return CalculationCategory::Other;</span>
<span class="line-added"> 690 </span>
<span class="line-added"> 691             currentCategory = currentCategory == CalculationCategory::Number ? nextCategory : currentCategory;</span>
<span class="line-added"> 692             break;</span>
<span class="line-added"> 693 </span>
<span class="line-added"> 694         case CalcOperator::Divide: {</span>
<span class="line-added"> 695             auto invertCategory = categoryForInvert(nextCategory);</span>
<span class="line-added"> 696 </span>
<span class="line-added"> 697             // At a / sub-expression, let left type be the result of finding the types of its left argument,</span>
<span class="line-added"> 698             // and right type be the result of finding the types of its right argument and then inverting it.</span>
<span class="line-added"> 699             // The sub-expression’s type is the result of multiplying the left type and right type.</span>
<span class="line-added"> 700             if (invertCategory != CalculationCategory::Number || node.isZero())</span>
<span class="line-added"> 701                 return CalculationCategory::Other;</span>
<span class="line-added"> 702             break;</span>
<span class="line-added"> 703         }</span>
<span class="line-added"> 704 </span>
<span class="line-added"> 705         case CalcOperator::Min:</span>
<span class="line-added"> 706         case CalcOperator::Max:</span>
<span class="line-added"> 707         case CalcOperator::Clamp:</span>
<span class="line-added"> 708             // The type of a min(), max(), or clamp() expression is the result of adding the types of its comma-separated calculations</span>
<span class="line-added"> 709             return CalculationCategory::Other;</span>
<span class="line-added"> 710         }</span>
<span class="line-added"> 711     }</span>
<span class="line-added"> 712 </span>
<span class="line-added"> 713     return currentCategory;</span>
<span class="line-added"> 714 }</span>
<span class="line-added"> 715 </span>
<span class="line-added"> 716 static CalculationCategory resolvedTypeForMinOrMaxOrClamp(CalculationCategory category, CalculationCategory destinationCategory)</span>
 717 {
 718     switch (category) {
 719     case CalculationCategory::Number:
 720     case CalculationCategory::Length:
 721     case CalculationCategory::PercentNumber:
 722     case CalculationCategory::PercentLength:
 723     case CalculationCategory::Angle:
 724     case CalculationCategory::Time:
 725     case CalculationCategory::Frequency:
 726     case CalculationCategory::Other:
 727         return category;
 728 
 729     case CalculationCategory::Percent:
 730         if (destinationCategory == CalculationCategory::Length)
 731             return CalculationCategory::PercentLength;
 732         if (destinationCategory == CalculationCategory::Number)
 733             return CalculationCategory::PercentNumber;
 734         return category;
 735     }
 736 
 737     return CalculationCategory::Other;
 738 }
 739 
<a name="57" id="anc57"></a>





















 740 static bool isSamePair(CalculationCategory a, CalculationCategory b, CalculationCategory x, CalculationCategory y)
 741 {
 742     return (a == x &amp;&amp; b == y) || (a == y &amp;&amp; b == x);
 743 }
 744 
<a name="58" id="anc58"></a><span class="line-modified"> 745 class CSSCalcOperationNode final : public CSSCalcExpressionNode {</span>
 746     WTF_MAKE_FAST_ALLOCATED;
 747 public:
<a name="59" id="anc59"></a><span class="line-modified"> 748     static RefPtr&lt;CSSCalcOperationNode&gt; create(CalcOperator, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; leftSide, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; rightSide);</span>
<span class="line-modified"> 749     static RefPtr&lt;CSSCalcOperationNode&gt; createSum(Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values);</span>
<span class="line-modified"> 750     static RefPtr&lt;CSSCalcOperationNode&gt; createProduct(Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values);</span>
<span class="line-modified"> 751     static RefPtr&lt;CSSCalcOperationNode&gt; createMinOrMaxOrClamp(CalcOperator, Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values, CalculationCategory destinationCategory);</span>
 752 
<a name="60" id="anc60"></a><span class="line-modified"> 753     static Ref&lt;CSSCalcExpressionNode&gt; simplify(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp;);</span>

 754 
<a name="61" id="anc61"></a><span class="line-modified"> 755     static void buildCSSText(const CSSCalcExpressionNode&amp;, StringBuilder&amp;);</span>


 756 
<a name="62" id="anc62"></a><span class="line-modified"> 757     CalcOperator calcOperator() const { return m_operator; }</span>
<span class="line-modified"> 758     bool isCalcSumNode() const { return m_operator == CalcOperator::Add; }</span>
<span class="line-added"> 759     bool isCalcProductNode() const { return m_operator == CalcOperator::Multiply; }</span>
<span class="line-added"> 760     bool isMinOrMaxNode() const { return m_operator == CalcOperator::Min || m_operator == CalcOperator::Max; }</span>
<span class="line-added"> 761     bool shouldSortChildren() const { return isCalcSumNode() || isCalcProductNode(); }</span>
 762 
<a name="63" id="anc63"></a><span class="line-modified"> 763     void hoistChildrenWithOperator(CalcOperator);</span>
<span class="line-modified"> 764     void combineChildren();</span>

 765 
<a name="64" id="anc64"></a><span class="line-modified"> 766     bool canCombineAllChildren() const;</span>


 767 
<a name="65" id="anc65"></a><span class="line-modified"> 768     const Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp; children() const { return m_children; }</span>
<span class="line-modified"> 769     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp; children() { return m_children; }</span>




 770 
<a name="66" id="anc66"></a><span class="line-modified"> 771 private:</span>
<span class="line-modified"> 772     CSSCalcOperationNode(CalculationCategory category, CalcOperator op, Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; leftSide, Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; rightSide)</span>
<span class="line-modified"> 773         : CSSCalcExpressionNode(category)</span>
<span class="line-modified"> 774         , m_operator(op)</span>
<span class="line-modified"> 775     {</span>
<span class="line-modified"> 776         m_children.reserveInitialCapacity(2);</span>
<span class="line-modified"> 777         m_children.uncheckedAppend(WTFMove(leftSide));</span>
<span class="line-modified"> 778         m_children.uncheckedAppend(WTFMove(rightSide));</span>
<span class="line-modified"> 779     }</span>
<span class="line-modified"> 780 </span>
<span class="line-modified"> 781     CSSCalcOperationNode(CalculationCategory category, CalcOperator op, Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; children)</span>
<span class="line-modified"> 782         : CSSCalcExpressionNode(category)</span>
<span class="line-added"> 783         , m_operator(op)</span>
<span class="line-added"> 784         , m_children(WTFMove(children))</span>
<span class="line-added"> 785     {</span>
<span class="line-added"> 786     }</span>
<span class="line-added"> 787 </span>
<span class="line-added"> 788     Type type() const final { return CssCalcOperation; }</span>
<span class="line-added"> 789 </span>
<span class="line-added"> 790     bool isZero() const final</span>
<span class="line-added"> 791     {</span>
<span class="line-added"> 792         return !doubleValue(primitiveType());</span>
<span class="line-added"> 793     }</span>
<span class="line-added"> 794 </span>
<span class="line-added"> 795     bool equals(const CSSCalcExpressionNode&amp;) const final;</span>
<span class="line-added"> 796 </span>
<span class="line-added"> 797     std::unique_ptr&lt;CalcExpressionNode&gt; createCalcExpression(const CSSToLengthConversionData&amp;) const final;</span>
 798 
<a name="67" id="anc67"></a><span class="line-modified"> 799     CSSUnitType primitiveType() const final;</span>
<span class="line-added"> 800     double doubleValue(CSSUnitType) const final;</span>
<span class="line-added"> 801     double computeLengthPx(const CSSToLengthConversionData&amp;) const final;</span>
<span class="line-added"> 802 </span>
<span class="line-added"> 803     void collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp;) const final;</span>
<span class="line-added"> 804     void collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp;) const final;</span>
<span class="line-added"> 805 </span>
<span class="line-added"> 806     void dump(TextStream&amp;) const final;</span>
<span class="line-added"> 807 </span>
<span class="line-added"> 808     static CSSCalcExpressionNode* getNumberSide(CSSCalcExpressionNode&amp; leftSide, CSSCalcExpressionNode&amp; rightSide)</span>
<span class="line-added"> 809     {</span>
<span class="line-added"> 810         if (leftSide.category() == CalculationCategory::Number)</span>
<span class="line-added"> 811             return &amp;leftSide;</span>
<span class="line-added"> 812         if (rightSide.category() == CalculationCategory::Number)</span>
<span class="line-added"> 813             return &amp;rightSide;</span>
<span class="line-added"> 814         return nullptr;</span>
 815     }
 816 
<a name="68" id="anc68"></a><span class="line-modified"> 817     double evaluate(const Vector&lt;double&gt;&amp; children) const</span>
 818     {
<a name="69" id="anc69"></a><span class="line-modified"> 819         return evaluateOperator(m_operator, children);</span>
<span class="line-added"> 820     }</span>
<span class="line-added"> 821 </span>
<span class="line-added"> 822     static double evaluateOperator(CalcOperator, const Vector&lt;double&gt;&amp;);</span>
<span class="line-added"> 823     static Ref&lt;CSSCalcExpressionNode&gt; simplifyNode(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp;, int depth);</span>
<span class="line-added"> 824     static Ref&lt;CSSCalcExpressionNode&gt; simplifyRecursive(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp;, int depth);</span>
<span class="line-added"> 825 </span>
<span class="line-added"> 826     enum class GroupingParens {</span>
<span class="line-added"> 827         Omit,</span>
<span class="line-added"> 828         Include</span>
<span class="line-added"> 829     };</span>
<span class="line-added"> 830     static void buildCSSTextRecursive(const CSSCalcExpressionNode&amp;, StringBuilder&amp;, GroupingParens = GroupingParens::Include);</span>
<span class="line-added"> 831 </span>
<span class="line-added"> 832     const CalcOperator m_operator;</span>
<span class="line-added"> 833     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; m_children;</span>
<span class="line-added"> 834 };</span>
<span class="line-added"> 835 </span>
<span class="line-added"> 836 RefPtr&lt;CSSCalcOperationNode&gt; CSSCalcOperationNode::create(CalcOperator op, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; leftSide, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;&amp; rightSide)</span>
<span class="line-added"> 837 {</span>
<span class="line-added"> 838     if (!leftSide || !rightSide)</span>
<span class="line-added"> 839         return nullptr;</span>
<span class="line-added"> 840 </span>
<span class="line-added"> 841     ASSERT(op == CalcOperator::Add || op == CalcOperator::Multiply);</span>
<span class="line-added"> 842 </span>
<span class="line-added"> 843     ASSERT(leftSide-&gt;category() &lt; CalculationCategory::Other);</span>
<span class="line-added"> 844     ASSERT(rightSide-&gt;category() &lt; CalculationCategory::Other);</span>
<span class="line-added"> 845 </span>
<span class="line-added"> 846     auto newCategory = determineCategory(*leftSide, *rightSide, op);</span>
<span class="line-added"> 847     if (newCategory == CalculationCategory::Other) {</span>
<span class="line-added"> 848         LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Failed to create CSSCalcOperationNode &quot; &lt;&lt; op &lt;&lt; &quot; node because unable to determine category from &quot; &lt;&lt; prettyPrintNode(*leftSide) &lt;&lt; &quot; and &quot; &lt;&lt; *rightSide);</span>
<span class="line-added"> 849         return nullptr;</span>
<span class="line-added"> 850     }</span>
<span class="line-added"> 851 </span>
<span class="line-added"> 852     return adoptRef(new CSSCalcOperationNode(newCategory, op, leftSide.releaseNonNull(), rightSide.releaseNonNull()));</span>
<span class="line-added"> 853 }</span>
<span class="line-added"> 854 </span>
<span class="line-added"> 855 RefPtr&lt;CSSCalcOperationNode&gt; CSSCalcOperationNode::createSum(Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values)</span>
<span class="line-added"> 856 {</span>
<span class="line-added"> 857     if (values.isEmpty())</span>
<span class="line-added"> 858         return nullptr;</span>
<span class="line-added"> 859 </span>
<span class="line-added"> 860     auto newCategory = determineCategory(values, CalcOperator::Add);</span>
<span class="line-added"> 861     if (newCategory == CalculationCategory::Other) {</span>
<span class="line-added"> 862         LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Failed to create sum node because unable to determine category from &quot; &lt;&lt; prettyPrintNodes(values));</span>
<span class="line-added"> 863         newCategory = determineCategory(values, CalcOperator::Add);</span>
<span class="line-added"> 864         return nullptr;</span>
<span class="line-added"> 865     }</span>
<span class="line-added"> 866 </span>
<span class="line-added"> 867     return adoptRef(new CSSCalcOperationNode(newCategory, CalcOperator::Add, WTFMove(values)));</span>
<span class="line-added"> 868 }</span>
<span class="line-added"> 869 </span>
<span class="line-added"> 870 RefPtr&lt;CSSCalcOperationNode&gt; CSSCalcOperationNode::createProduct(Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values)</span>
<span class="line-added"> 871 {</span>
<span class="line-added"> 872     if (values.isEmpty())</span>
<span class="line-added"> 873         return nullptr;</span>
<span class="line-added"> 874 </span>
<span class="line-added"> 875     auto newCategory = determineCategory(values, CalcOperator::Multiply);</span>
<span class="line-added"> 876     if (newCategory == CalculationCategory::Other) {</span>
<span class="line-added"> 877         LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Failed to create product node because unable to determine category from &quot; &lt;&lt; prettyPrintNodes(values));</span>
<span class="line-added"> 878         return nullptr;</span>
<span class="line-added"> 879     }</span>
<span class="line-added"> 880 </span>
<span class="line-added"> 881     return adoptRef(new CSSCalcOperationNode(newCategory, CalcOperator::Multiply, WTFMove(values)));</span>
<span class="line-added"> 882 }</span>
<span class="line-added"> 883 </span>
<span class="line-added"> 884 RefPtr&lt;CSSCalcOperationNode&gt; CSSCalcOperationNode::createMinOrMaxOrClamp(CalcOperator op, Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt;&amp;&amp; values, CalculationCategory destinationCategory)</span>
<span class="line-added"> 885 {</span>
<span class="line-added"> 886     ASSERT(op == CalcOperator::Min || op == CalcOperator::Max || op == CalcOperator::Clamp);</span>
<span class="line-added"> 887     ASSERT_IMPLIES(op == CalcOperator::Clamp, values.size() == 3);</span>
<span class="line-added"> 888 </span>
<span class="line-added"> 889     Optional&lt;CalculationCategory&gt; category = WTF::nullopt;</span>
<span class="line-added"> 890     for (auto&amp; value : values) {</span>
<span class="line-added"> 891         auto valueCategory = resolvedTypeForMinOrMaxOrClamp(value-&gt;category(), destinationCategory);</span>
<span class="line-added"> 892 </span>
<span class="line-added"> 893         ASSERT(valueCategory &lt; CalculationCategory::Other);</span>
<span class="line-added"> 894         if (!category) {</span>
<span class="line-added"> 895             if (valueCategory == CalculationCategory::Other) {</span>
<span class="line-added"> 896                 LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Failed to create CSSCalcOperationNode &quot; &lt;&lt; op &lt;&lt; &quot; node because unable to determine category from &quot; &lt;&lt; prettyPrintNodes(values));</span>
<span class="line-added"> 897                 return nullptr;</span>
<span class="line-added"> 898             }</span>
<span class="line-added"> 899             category = valueCategory;</span>
<span class="line-added"> 900         }</span>
<span class="line-added"> 901 </span>
<span class="line-added"> 902         if (category != valueCategory) {</span>
<span class="line-added"> 903             if (isSamePair(category.value(), valueCategory, CalculationCategory::Length, CalculationCategory::PercentLength)) {</span>
<span class="line-added"> 904                 category = CalculationCategory::PercentLength;</span>
<span class="line-added"> 905                 continue;</span>
<span class="line-added"> 906             }</span>
<span class="line-added"> 907             if (isSamePair(category.value(), valueCategory, CalculationCategory::Number, CalculationCategory::PercentNumber)) {</span>
<span class="line-added"> 908                 category = CalculationCategory::PercentNumber;</span>
<span class="line-added"> 909                 continue;</span>
<span class="line-added"> 910             }</span>
 911             return nullptr;
<a name="70" id="anc70"></a><span class="line-added"> 912         }</span>
<span class="line-added"> 913     }</span>
 914 
<a name="71" id="anc71"></a><span class="line-modified"> 915     return adoptRef(new CSSCalcOperationNode(category.value(), op, WTFMove(values)));</span>
<span class="line-modified"> 916 }</span>


 917 
<a name="72" id="anc72"></a><span class="line-modified"> 918 void CSSCalcOperationNode::hoistChildrenWithOperator(CalcOperator op)</span>
<span class="line-added"> 919 {</span>
<span class="line-added"> 920     ASSERT(op == CalcOperator::Add || op == CalcOperator::Multiply);</span>
 921 
<a name="73" id="anc73"></a><span class="line-modified"> 922     auto hasChildWithOperator = [&amp;] (CalcOperator op) {</span>
<span class="line-modified"> 923         for (auto&amp; child : m_children) {</span>
<span class="line-modified"> 924             if (is&lt;CSSCalcOperationNode&gt;(child.get()) &amp;&amp; downcast&lt;CSSCalcOperationNode&gt;(child.get()).calcOperator() == op)</span>
<span class="line-modified"> 925                 return true;</span>
 926         }
<a name="74" id="anc74"></a><span class="line-added"> 927         return false;</span>
<span class="line-added"> 928     };</span>
 929 
<a name="75" id="anc75"></a><span class="line-modified"> 930     if (!hasChildWithOperator(op))</span>
<span class="line-modified"> 931         return;</span>
<span class="line-modified"> 932 </span>
<span class="line-modified"> 933     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; newChildren;</span>
<span class="line-modified"> 934     for (auto&amp; child : m_children) {</span>
<span class="line-modified"> 935         if (is&lt;CSSCalcOperationNode&gt;(child.get()) &amp;&amp; downcast&lt;CSSCalcOperationNode&gt;(child.get()).calcOperator() == op) {</span>
<span class="line-modified"> 936             auto&amp; children = downcast&lt;CSSCalcOperationNode&gt;(child.get()).children();</span>
<span class="line-modified"> 937             for (auto&amp; childToMove : children)</span>
<span class="line-modified"> 938                 newChildren.append(WTFMove(childToMove));</span>
<span class="line-modified"> 939         } else</span>
<span class="line-modified"> 940             newChildren.append(WTFMove(child));</span>
<span class="line-modified"> 941     }</span>
<span class="line-modified"> 942 </span>
<span class="line-modified"> 943     newChildren.shrinkToFit();</span>
<span class="line-modified"> 944     m_children = WTFMove(newChildren);</span>
<span class="line-modified"> 945 }</span>
<span class="line-modified"> 946 </span>
<span class="line-modified"> 947 enum class SortingCategory {</span>
<span class="line-added"> 948     Number,</span>
<span class="line-added"> 949     Percent,</span>
<span class="line-added"> 950     Dimension,</span>
<span class="line-added"> 951     Other</span>
<span class="line-added"> 952 };</span>
<span class="line-added"> 953 </span>
<span class="line-added"> 954 static SortingCategory sortingCategoryForType(CSSUnitType unitType)</span>
<span class="line-added"> 955 {</span>
<span class="line-added"> 956     static constexpr SortingCategory sortOrder[] = {</span>
<span class="line-added"> 957         SortingCategory::Number,        // CalculationCategory::Number,</span>
<span class="line-added"> 958         SortingCategory::Dimension,     // CalculationCategory::Length,</span>
<span class="line-added"> 959         SortingCategory::Percent,       // CalculationCategory::Percent,</span>
<span class="line-added"> 960         SortingCategory::Number,        // CalculationCategory::PercentNumber,</span>
<span class="line-added"> 961         SortingCategory::Dimension,     // CalculationCategory::PercentLength,</span>
<span class="line-added"> 962         SortingCategory::Dimension,     // CalculationCategory::Angle,</span>
<span class="line-added"> 963         SortingCategory::Dimension,     // CalculationCategory::Time,</span>
<span class="line-added"> 964         SortingCategory::Dimension,     // CalculationCategory::Frequency,</span>
<span class="line-added"> 965         SortingCategory::Other,         // UOther</span>
<span class="line-added"> 966     };</span>
<span class="line-added"> 967 </span>
<span class="line-added"> 968     COMPILE_ASSERT(ARRAY_SIZE(sortOrder) == static_cast&lt;unsigned&gt;(CalculationCategory::Other) + 1, sortOrder_size_should_match_UnitCategory);</span>
<span class="line-added"> 969     return sortOrder[static_cast&lt;unsigned&gt;(calcUnitCategory(unitType))];</span>
<span class="line-added"> 970 }</span>
<span class="line-added"> 971 </span>
<span class="line-added"> 972 static SortingCategory sortingCategory(const CSSCalcExpressionNode&amp; node)</span>
<span class="line-added"> 973 {</span>
<span class="line-added"> 974     if (is&lt;CSSCalcPrimitiveValueNode&gt;(node))</span>
<span class="line-added"> 975         return sortingCategoryForType(node.primitiveType());</span>
<span class="line-added"> 976 </span>
<span class="line-added"> 977     return SortingCategory::Other;</span>
<span class="line-added"> 978 }</span>
<span class="line-added"> 979 </span>
<span class="line-added"> 980 static CSSUnitType primitiveTypeForCombination(const CSSCalcExpressionNode&amp; node)</span>
<span class="line-added"> 981 {</span>
<span class="line-added"> 982     if (is&lt;CSSCalcPrimitiveValueNode&gt;(node))</span>
<span class="line-added"> 983         return node.primitiveType();</span>
<span class="line-added"> 984 </span>
<span class="line-added"> 985     return CSSUnitType::CSS_UNKNOWN;</span>
<span class="line-added"> 986 }</span>
<span class="line-added"> 987 </span>
<span class="line-added"> 988 static CSSCalcPrimitiveValueNode::UnitConversion conversionToAddValuesWithTypes(CSSUnitType firstType, CSSUnitType secondType)</span>
<span class="line-added"> 989 {</span>
<span class="line-added"> 990     if (firstType == CSSUnitType::CSS_UNKNOWN || secondType == CSSUnitType::CSS_UNKNOWN)</span>
<span class="line-added"> 991         return CSSCalcPrimitiveValueNode::UnitConversion::Invalid;</span>
<span class="line-added"> 992 </span>
<span class="line-added"> 993     auto firstCategory = calculationCategoryForCombination(firstType);</span>
<span class="line-added"> 994 </span>
<span class="line-added"> 995     // Compatible types.</span>
<span class="line-added"> 996     if (firstCategory != CalculationCategory::Other &amp;&amp; firstCategory == calculationCategoryForCombination(secondType))</span>
<span class="line-added"> 997         return CSSCalcPrimitiveValueNode::UnitConversion::Canonicalize;</span>
<span class="line-added"> 998 </span>
<span class="line-added"> 999     // Matching types.</span>
<span class="line-added">1000     if (firstType == secondType &amp;&amp; hasDoubleValue(firstType))</span>
<span class="line-added">1001         return CSSCalcPrimitiveValueNode::UnitConversion::Preserve;</span>
<span class="line-added">1002 </span>
<span class="line-added">1003     return CSSCalcPrimitiveValueNode::UnitConversion::Invalid;</span>
<span class="line-added">1004 }</span>
<span class="line-added">1005 </span>
<span class="line-added">1006 bool CSSCalcOperationNode::canCombineAllChildren() const</span>
<span class="line-added">1007 {</span>
<span class="line-added">1008     if (m_children.size() &lt; 2)</span>
<span class="line-added">1009         return false;</span>
<span class="line-added">1010 </span>
<span class="line-added">1011     if (!is&lt;CSSCalcPrimitiveValueNode&gt;(m_children[0]))</span>
<span class="line-added">1012         return false;</span>
<span class="line-added">1013 </span>
<span class="line-added">1014     auto firstUnitType = m_children[0]-&gt;primitiveType();</span>
<span class="line-added">1015     auto firstCategory = calculationCategoryForCombination(m_children[0]-&gt;primitiveType());</span>
<span class="line-added">1016 </span>
<span class="line-added">1017     for (unsigned i = 1; i &lt; m_children.size(); ++i) {</span>
<span class="line-added">1018         auto&amp; node = m_children[i];</span>
<span class="line-added">1019 </span>
<span class="line-added">1020         if (!is&lt;CSSCalcPrimitiveValueNode&gt;(node))</span>
<span class="line-added">1021             return false;</span>
<span class="line-added">1022 </span>
<span class="line-added">1023         auto nodeUnitType = node-&gt;primitiveType();</span>
<span class="line-added">1024         auto nodeCategory = calculationCategoryForCombination(nodeUnitType);</span>
<span class="line-added">1025 </span>
<span class="line-added">1026         if (nodeCategory != firstCategory)</span>
<span class="line-added">1027             return false;</span>
<span class="line-added">1028 </span>
<span class="line-added">1029         if (nodeCategory == CalculationCategory::Other &amp;&amp; nodeUnitType != firstUnitType)</span>
<span class="line-added">1030             return false;</span>
<span class="line-added">1031 </span>
<span class="line-added">1032         if (!hasDoubleValue(nodeUnitType))</span>
<span class="line-added">1033             return false;</span>
<span class="line-added">1034     }</span>
<span class="line-added">1035 </span>
<span class="line-added">1036     return true;</span>
<span class="line-added">1037 }</span>
<span class="line-added">1038 </span>
<span class="line-added">1039 void CSSCalcOperationNode::combineChildren()</span>
<span class="line-added">1040 {</span>
<span class="line-added">1041     if (m_children.size() &lt; 2)</span>
<span class="line-added">1042         return;</span>
<span class="line-added">1043 </span>
<span class="line-added">1044     if (shouldSortChildren()) {</span>
<span class="line-added">1045         // &lt;https://drafts.csswg.org/css-values-4/#sort-a-calculations-children&gt;</span>
<span class="line-added">1046         std::stable_sort(m_children.begin(), m_children.end(), [](const auto&amp; first, const auto&amp; second) {</span>
<span class="line-added">1047             // Sort order: number, percentage, dimension, other.</span>
<span class="line-added">1048             SortingCategory firstCategory = sortingCategory(first.get());</span>
<span class="line-added">1049             SortingCategory secondCategory = sortingCategory(second.get());</span>
<span class="line-added">1050 </span>
<span class="line-added">1051             if (firstCategory == SortingCategory::Dimension &amp;&amp; secondCategory == SortingCategory::Dimension) {</span>
<span class="line-added">1052                 // If nodes contains any dimensions, remove them from nodes, sort them by their units, and append them to ret.</span>
<span class="line-added">1053                 auto firstUnitString = CSSPrimitiveValue::unitTypeString(first-&gt;primitiveType());</span>
<span class="line-added">1054                 auto secondUnitString = CSSPrimitiveValue::unitTypeString(second-&gt;primitiveType());</span>
<span class="line-added">1055                 return codePointCompareLessThan(firstUnitString, secondUnitString);</span>
1056             }
<a name="76" id="anc76"></a>








1057 
<a name="77" id="anc77"></a><span class="line-modified">1058             return static_cast&lt;unsigned&gt;(firstCategory) &lt; static_cast&lt;unsigned&gt;(secondCategory);</span>
<span class="line-modified">1059         });</span>
<span class="line-modified">1060 </span>
<span class="line-modified">1061         LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;post-sort: &quot; &lt;&lt; *this);</span>
<span class="line-modified">1062     }</span>
<span class="line-added">1063 </span>
<span class="line-added">1064     if (calcOperator() == CalcOperator::Add) {</span>
<span class="line-added">1065         // For each set of root’s children that are numeric values with identical units,</span>
<span class="line-added">1066         // remove those children and replace them with a single numeric value containing</span>
<span class="line-added">1067         // the sum of the removed nodes, and with the same unit.</span>
<span class="line-added">1068         Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; newChildren;</span>
<span class="line-added">1069         newChildren.reserveInitialCapacity(m_children.size());</span>
<span class="line-added">1070         newChildren.uncheckedAppend(m_children[0].copyRef());</span>
<span class="line-added">1071 </span>
<span class="line-added">1072         CSSUnitType previousType = primitiveTypeForCombination(newChildren[0].get());</span>
<span class="line-added">1073 </span>
<span class="line-added">1074         for (unsigned i = 1; i &lt; m_children.size(); ++i) {</span>
<span class="line-added">1075             auto&amp; currentNode = m_children[i];</span>
<span class="line-added">1076             CSSUnitType currentType = primitiveTypeForCombination(currentNode.get());</span>
1077 
<a name="78" id="anc78"></a><span class="line-modified">1078             auto conversionType = conversionToAddValuesWithTypes(previousType, currentType);</span>
<span class="line-modified">1079             if (conversionType != CSSCalcPrimitiveValueNode::UnitConversion::Invalid) {</span>
<span class="line-modified">1080                 downcast&lt;CSSCalcPrimitiveValueNode&gt;(newChildren.last().get()).add(downcast&lt;CSSCalcPrimitiveValueNode&gt;(currentNode.get()), conversionType);</span>
<span class="line-added">1081                 continue;</span>
<span class="line-added">1082             }</span>
<span class="line-added">1083 </span>
<span class="line-added">1084             previousType = primitiveTypeForCombination(currentNode);</span>
<span class="line-added">1085             newChildren.uncheckedAppend(currentNode.copyRef());</span>
1086         }
1087 
<a name="79" id="anc79"></a><span class="line-modified">1088         newChildren.shrinkToFit();</span>
<span class="line-added">1089         m_children = WTFMove(newChildren);</span>
<span class="line-added">1090         return;</span>
1091     }
1092 
<a name="80" id="anc80"></a><span class="line-modified">1093     if (calcOperator() == CalcOperator::Multiply) {</span>
<span class="line-modified">1094         // If root has multiple children that are numbers (not percentages or dimensions),</span>
<span class="line-modified">1095         // remove them and replace them with a single number containing the product of the removed nodes.</span>
<span class="line-modified">1096         double multiplier = 1;</span>
<span class="line-added">1097 </span>
<span class="line-added">1098         // Sorting will have put the number nodes first.</span>
<span class="line-added">1099         unsigned leadingNumberNodeCount = 0;</span>
<span class="line-added">1100         for (auto&amp; node : m_children) {</span>
<span class="line-added">1101             auto nodeType = primitiveTypeForCombination(node.get());</span>
<span class="line-added">1102             if (nodeType != CSSUnitType::CSS_NUMBER)</span>
<span class="line-added">1103                 break;</span>
<span class="line-added">1104 </span>
<span class="line-added">1105             multiplier *= node-&gt;doubleValue(CSSUnitType::CSS_NUMBER);</span>
<span class="line-added">1106             ++leadingNumberNodeCount;</span>
<span class="line-added">1107         }</span>
<span class="line-added">1108 </span>
<span class="line-added">1109         Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; newChildren;</span>
<span class="line-added">1110         newChildren.reserveInitialCapacity(m_children.size());</span>
<span class="line-added">1111 </span>
<span class="line-added">1112         // If root contains only two children, one of which is a number (not a percentage or dimension) and the other of</span>
<span class="line-added">1113         // which is a Sum whose children are all numeric values, multiply all of the Sum’s children by the number, then</span>
<span class="line-added">1114         // return the Sum.</span>
<span class="line-added">1115         // The Sum&#39;s children simplification will have happened already.</span>
<span class="line-added">1116         bool didMultipy = false;</span>
<span class="line-added">1117         if (leadingNumberNodeCount &amp;&amp; m_children.size() - leadingNumberNodeCount == 1) {</span>
<span class="line-added">1118             auto multiplicandCategory = calcUnitCategory(primitiveTypeForCombination(m_children.last().get()));</span>
<span class="line-added">1119             if (multiplicandCategory != CalculationCategory::Other) {</span>
<span class="line-added">1120                 newChildren.uncheckedAppend(m_children.last().copyRef());</span>
<span class="line-added">1121                 downcast&lt;CSSCalcPrimitiveValueNode&gt;(newChildren[0].get()).multiply(multiplier);</span>
<span class="line-added">1122                 didMultipy = true;</span>
<span class="line-added">1123             }</span>
<span class="line-added">1124         }</span>
<span class="line-added">1125 </span>
<span class="line-added">1126         if (!didMultipy) {</span>
<span class="line-added">1127             if (leadingNumberNodeCount) {</span>
<span class="line-added">1128                 auto multiplierNode = CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(multiplier, CSSUnitType::CSS_NUMBER));</span>
<span class="line-added">1129                 newChildren.uncheckedAppend(WTFMove(multiplierNode));</span>
<span class="line-added">1130             }</span>
<span class="line-added">1131 </span>
<span class="line-added">1132             for (unsigned i = leadingNumberNodeCount; i &lt; m_children.size(); ++i)</span>
<span class="line-added">1133                 newChildren.uncheckedAppend(m_children[i].copyRef());</span>
<span class="line-added">1134         }</span>
<span class="line-added">1135 </span>
<span class="line-added">1136         newChildren.shrinkToFit();</span>
<span class="line-added">1137         m_children = WTFMove(newChildren);</span>
1138     }
1139 
<a name="81" id="anc81"></a><span class="line-modified">1140     if (isMinOrMaxNode() &amp;&amp; canCombineAllChildren()) {</span>
<span class="line-modified">1141         auto combinedUnitType = m_children[0]-&gt;primitiveType();</span>
<span class="line-modified">1142         auto category = calculationCategoryForCombination(combinedUnitType);</span>
<span class="line-modified">1143         if (category != CalculationCategory::Other)</span>
<span class="line-added">1144             combinedUnitType = canonicalUnitTypeForCalculationCategory(category);</span>
1145 
<a name="82" id="anc82"></a><span class="line-modified">1146         double resolvedValue = doubleValue(combinedUnitType);</span>
<span class="line-modified">1147         auto newChild = CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(resolvedValue, combinedUnitType));</span>
<span class="line-modified">1148 </span>
<span class="line-modified">1149         m_children.clear();</span>
<span class="line-modified">1150         m_children.append(WTFMove(newChild));</span>
<span class="line-added">1151     }</span>
<span class="line-added">1152 }</span>
<span class="line-added">1153 </span>
<span class="line-added">1154 // https://drafts.csswg.org/css-values-4/#simplify-a-calculation-tree</span>
<span class="line-added">1155 </span>
<span class="line-added">1156 Ref&lt;CSSCalcExpressionNode&gt; CSSCalcOperationNode::simplify(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; rootNode)</span>
<span class="line-added">1157 {</span>
<span class="line-added">1158     return simplifyRecursive(WTFMove(rootNode), 0);</span>
<span class="line-added">1159 }</span>
<span class="line-added">1160 </span>
<span class="line-added">1161 Ref&lt;CSSCalcExpressionNode&gt; CSSCalcOperationNode::simplifyRecursive(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; rootNode, int depth)</span>
<span class="line-added">1162 {</span>
<span class="line-added">1163     if (is&lt;CSSCalcOperationNode&gt;(rootNode)) {</span>
<span class="line-added">1164         auto&amp; operationNode = downcast&lt;CSSCalcOperationNode&gt;(rootNode.get());</span>
<span class="line-added">1165 </span>
<span class="line-added">1166         auto&amp; children = operationNode.children();</span>
<span class="line-added">1167         for (unsigned i = 0; i &lt; children.size(); ++i) {</span>
<span class="line-added">1168             auto child = children[i].copyRef();</span>
<span class="line-added">1169             auto newNode = simplifyRecursive(WTFMove(child), depth + 1);</span>
<span class="line-added">1170             if (newNode.ptr() != children[i].ptr())</span>
<span class="line-added">1171                 children[i] = WTFMove(newNode);</span>
1172         }
<a name="83" id="anc83"></a><span class="line-modified">1173     } else if (is&lt;CSSCalcNegateNode&gt;(rootNode)) {</span>
<span class="line-added">1174         auto&amp; negateNode = downcast&lt;CSSCalcNegateNode&gt;(rootNode.get());</span>
<span class="line-added">1175         Ref&lt;CSSCalcExpressionNode&gt; child = negateNode.child();</span>
<span class="line-added">1176         auto newNode = simplifyRecursive(WTFMove(child), depth + 1);</span>
<span class="line-added">1177         if (newNode.ptr() != &amp;negateNode.child())</span>
<span class="line-added">1178             negateNode.setChild(WTFMove(newNode));</span>
<span class="line-added">1179     } else if (is&lt;CSSCalcInvertNode&gt;(rootNode)) {</span>
<span class="line-added">1180         auto&amp; invertNode = downcast&lt;CSSCalcInvertNode&gt;(rootNode.get());</span>
<span class="line-added">1181         Ref&lt;CSSCalcExpressionNode&gt; child = invertNode.child();</span>
<span class="line-added">1182         auto newNode = simplifyRecursive(WTFMove(child), depth + 1);</span>
<span class="line-added">1183         if (newNode.ptr() != &amp;invertNode.child())</span>
<span class="line-added">1184             invertNode.setChild(WTFMove(newNode));</span>
1185     }
1186 
<a name="84" id="anc84"></a><span class="line-modified">1187     return simplifyNode(WTFMove(rootNode), depth);</span>
<span class="line-modified">1188 }</span>
<span class="line-modified">1189 </span>
<span class="line-modified">1190 Ref&lt;CSSCalcExpressionNode&gt; CSSCalcOperationNode::simplifyNode(Ref&lt;CSSCalcExpressionNode&gt;&amp;&amp; rootNode, int depth)</span>
<span class="line-modified">1191 {</span>
<span class="line-modified">1192     if (is&lt;CSSCalcPrimitiveValueNode&gt;(rootNode)) {</span>
<span class="line-added">1193         // If root is a percentage that will be resolved against another value, and there is enough information</span>
<span class="line-added">1194         // available to resolve it, do so, and express the resulting numeric value in the appropriate canonical</span>
<span class="line-added">1195         // unit. Return the value.</span>
<span class="line-added">1196 </span>
<span class="line-added">1197         // If root is a dimension that is not expressed in its canonical unit, and there is enough information</span>
<span class="line-added">1198         // available to convert it to the canonical unit, do so, and return the value.</span>
<span class="line-added">1199         auto&amp; primitiveValueNode = downcast&lt;CSSCalcPrimitiveValueNode&gt;(rootNode.get());</span>
<span class="line-added">1200         primitiveValueNode.canonicalizeUnit();</span>
<span class="line-added">1201         return WTFMove(rootNode);</span>
1202     }
1203 
<a name="85" id="anc85"></a><span class="line-modified">1204     // If root is an operator node that’s not one of the calc-operator nodes, and all of its children are numeric values</span>
<span class="line-modified">1205     // with enough information to computed the operation root represents, return the result of running root’s operation</span>
<span class="line-modified">1206     // using its children, expressed in the result’s canonical unit.</span>
<span class="line-modified">1207     if (is&lt;CSSCalcOperationNode&gt;(rootNode)) {</span>
<span class="line-modified">1208         auto&amp; calcOperationNode = downcast&lt;CSSCalcOperationNode&gt;(rootNode.get());</span>
<span class="line-modified">1209         // Don&#39;t simplify at the root, otherwise we lose track of the operation for serialization.</span>
<span class="line-added">1210         if (calcOperationNode.children().size() == 1 &amp;&amp; depth)</span>
<span class="line-added">1211             return WTFMove(calcOperationNode.children()[0]);</span>
<span class="line-added">1212 </span>
<span class="line-added">1213         if (calcOperationNode.isCalcSumNode()) {</span>
<span class="line-added">1214             calcOperationNode.hoistChildrenWithOperator(CalcOperator::Add);</span>
<span class="line-added">1215             calcOperationNode.combineChildren();</span>
<span class="line-added">1216         }</span>
<span class="line-added">1217 </span>
<span class="line-added">1218         if (calcOperationNode.isCalcProductNode()) {</span>
<span class="line-added">1219             calcOperationNode.hoistChildrenWithOperator(CalcOperator::Multiply);</span>
<span class="line-added">1220             calcOperationNode.combineChildren();</span>
<span class="line-added">1221         }</span>
<span class="line-added">1222 </span>
<span class="line-added">1223         if (calcOperationNode.isMinOrMaxNode())</span>
<span class="line-added">1224             calcOperationNode.combineChildren();</span>
<span class="line-added">1225 </span>
<span class="line-added">1226         // If only one child remains, return the child (except at the root).</span>
<span class="line-added">1227         auto shouldCombineParentWithOnlyChild = [](const CSSCalcOperationNode&amp; parent, int depth)</span>
<span class="line-added">1228         {</span>
<span class="line-added">1229             if (parent.children().size() != 1)</span>
<span class="line-added">1230                 return false;</span>
<span class="line-added">1231 </span>
<span class="line-added">1232             // Always simplify below the root.</span>
<span class="line-added">1233             if (depth)</span>
<span class="line-added">1234                 return true;</span>
<span class="line-added">1235 </span>
<span class="line-added">1236             // At the root, preserve the root function by only merging nodes with the same function.</span>
<span class="line-added">1237             auto&amp; child = parent.children().first();</span>
<span class="line-added">1238             if (!is&lt;CSSCalcOperationNode&gt;(child))</span>
<span class="line-added">1239                 return false;</span>
<span class="line-added">1240 </span>
<span class="line-added">1241             auto parentFunction = functionFromOperator(parent.calcOperator());</span>
<span class="line-added">1242             auto childFunction = functionFromOperator(downcast&lt;CSSCalcOperationNode&gt;(child.get()).calcOperator());</span>
<span class="line-added">1243             return childFunction == parentFunction;</span>
<span class="line-added">1244         };</span>
<span class="line-added">1245 </span>
<span class="line-added">1246         if (shouldCombineParentWithOnlyChild(calcOperationNode, depth))</span>
<span class="line-added">1247             return WTFMove(calcOperationNode.children().first());</span>
<span class="line-added">1248 </span>
<span class="line-added">1249         return WTFMove(rootNode);</span>
1250     }
1251 
<a name="86" id="anc86"></a><span class="line-modified">1252     if (is&lt;CSSCalcNegateNode&gt;(rootNode)) {</span>
<span class="line-modified">1253         auto&amp; childNode = downcast&lt;CSSCalcNegateNode&gt;(rootNode.get()).child();</span>
<span class="line-modified">1254         // If root’s child is a numeric value, return an equivalent numeric value, but with the value negated (0 - value).</span>
<span class="line-modified">1255         if (is&lt;CSSCalcPrimitiveValueNode&gt;(childNode) &amp;&amp; downcast&lt;CSSCalcPrimitiveValueNode&gt;(childNode).isNumericValue()) {</span>
<span class="line-added">1256             downcast&lt;CSSCalcPrimitiveValueNode&gt;(childNode).negate();</span>
<span class="line-added">1257             return childNode;</span>
<span class="line-added">1258         }</span>
<span class="line-added">1259 </span>
<span class="line-added">1260         // If root’s child is a Negate node, return the child’s child.</span>
<span class="line-added">1261         if (is&lt;CSSCalcNegateNode&gt;(childNode))</span>
<span class="line-added">1262             return downcast&lt;CSSCalcNegateNode&gt;(childNode).child();</span>
<span class="line-added">1263 </span>
<span class="line-added">1264         return WTFMove(rootNode);</span>
1265     }
1266 
<a name="87" id="anc87"></a><span class="line-modified">1267     if (is&lt;CSSCalcInvertNode&gt;(rootNode)) {</span>
<span class="line-modified">1268         auto&amp; childNode = downcast&lt;CSSCalcInvertNode&gt;(rootNode.get()).child();</span>
<span class="line-added">1269         // If root’s child is a number (not a percentage or dimension) return the reciprocal of the child’s value.</span>
<span class="line-added">1270         if (is&lt;CSSCalcPrimitiveValueNode&gt;(childNode) &amp;&amp; downcast&lt;CSSCalcPrimitiveValueNode&gt;(childNode).isNumericValue()) {</span>
<span class="line-added">1271             downcast&lt;CSSCalcPrimitiveValueNode&gt;(childNode).invert();</span>
<span class="line-added">1272             return childNode;</span>
<span class="line-added">1273         }</span>
<span class="line-added">1274 </span>
<span class="line-added">1275         // If root’s child is an Invert node, return the child’s child.</span>
<span class="line-added">1276         if (is&lt;CSSCalcInvertNode&gt;(childNode))</span>
<span class="line-added">1277             return downcast&lt;CSSCalcInvertNode&gt;(childNode).child();</span>
<span class="line-added">1278 </span>
<span class="line-added">1279         return WTFMove(rootNode);</span>
<span class="line-added">1280     }</span>
<span class="line-added">1281 </span>
<span class="line-added">1282     return WTFMove(rootNode);</span>
<span class="line-added">1283 }</span>
<span class="line-added">1284 </span>
<span class="line-added">1285 CSSUnitType CSSCalcOperationNode::primitiveType() const</span>
<span class="line-added">1286 {</span>
<span class="line-added">1287     auto unitCategory = category();</span>
<span class="line-added">1288     switch (unitCategory) {</span>
<span class="line-added">1289     case CalculationCategory::Number:</span>
<span class="line-added">1290 #if ASSERT_ENABLED</span>
1291         for (auto&amp; child : m_children)
<a name="88" id="anc88"></a><span class="line-modified">1292             ASSERT(child-&gt;category() == CalculationCategory::Number);</span>
<span class="line-added">1293 #endif</span>
<span class="line-added">1294         return CSSUnitType::CSS_NUMBER;</span>
<span class="line-added">1295 </span>
<span class="line-added">1296     case CalculationCategory::Percent: {</span>
<span class="line-added">1297         if (m_children.isEmpty())</span>
<span class="line-added">1298             return CSSUnitType::CSS_UNKNOWN;</span>
<span class="line-added">1299 </span>
<span class="line-added">1300         if (m_children.size() == 2) {</span>
<span class="line-added">1301             if (m_children[0]-&gt;category() == CalculationCategory::Number)</span>
<span class="line-added">1302                 return m_children[1]-&gt;primitiveType();</span>
<span class="line-added">1303             if (m_children[1]-&gt;category() == CalculationCategory::Number)</span>
<span class="line-added">1304                 return m_children[0]-&gt;primitiveType();</span>
<span class="line-added">1305         }</span>
<span class="line-added">1306         CSSUnitType firstType = m_children[0]-&gt;primitiveType();</span>
<span class="line-added">1307         for (auto&amp; child : m_children) {</span>
<span class="line-added">1308             if (firstType != child-&gt;primitiveType())</span>
<span class="line-added">1309                 return CSSUnitType::CSS_UNKNOWN;</span>
<span class="line-added">1310         }</span>
<span class="line-added">1311         return firstType;</span>
1312     }
1313 
<a name="89" id="anc89"></a><span class="line-modified">1314     case CalculationCategory::Length:</span>
<span class="line-modified">1315     case CalculationCategory::Angle:</span>
<span class="line-modified">1316     case CalculationCategory::Time:</span>
<span class="line-modified">1317     case CalculationCategory::Frequency:</span>
<span class="line-modified">1318         if (m_children.size() == 1)</span>
<span class="line-modified">1319             return m_children.first()-&gt;primitiveType();</span>
<span class="line-modified">1320         return canonicalUnitTypeForCalculationCategory(unitCategory);</span>
<span class="line-modified">1321 </span>
<span class="line-modified">1322     case CalculationCategory::PercentLength:</span>
<span class="line-modified">1323     case CalculationCategory::PercentNumber:</span>
<span class="line-modified">1324     case CalculationCategory::Other:</span>
<span class="line-modified">1325         return CSSUnitType::CSS_UNKNOWN;</span>
<span class="line-modified">1326     }</span>
<span class="line-modified">1327     ASSERT_NOT_REACHED();</span>
<span class="line-modified">1328     return CSSUnitType::CSS_UNKNOWN;</span>
<span class="line-modified">1329 }</span>
<span class="line-modified">1330 </span>
<span class="line-modified">1331 std::unique_ptr&lt;CalcExpressionNode&gt; CSSCalcOperationNode::createCalcExpression(const CSSToLengthConversionData&amp; conversionData) const</span>
<span class="line-modified">1332 {</span>
<span class="line-modified">1333     Vector&lt;std::unique_ptr&lt;CalcExpressionNode&gt;&gt; nodes;</span>
<span class="line-modified">1334     nodes.reserveInitialCapacity(m_children.size());</span>
<span class="line-modified">1335 </span>
<span class="line-modified">1336     for (auto&amp; child : m_children) {</span>
<span class="line-modified">1337         auto node = child-&gt;createCalcExpression(conversionData);</span>
<span class="line-modified">1338         if (!node)</span>
<span class="line-modified">1339             return nullptr;</span>
<span class="line-added">1340         nodes.uncheckedAppend(WTFMove(node));</span>
<span class="line-added">1341     }</span>
<span class="line-added">1342     return makeUnique&lt;CalcExpressionOperation&gt;(WTFMove(nodes), m_operator);</span>
<span class="line-added">1343 }</span>
<span class="line-added">1344 </span>
<span class="line-added">1345 double CSSCalcOperationNode::doubleValue(CSSUnitType unitType) const</span>
<span class="line-added">1346 {</span>
<span class="line-added">1347     bool allowNumbers = calcOperator() == CalcOperator::Multiply;</span>
<span class="line-added">1348 </span>
<span class="line-added">1349     return evaluate(m_children.map([&amp;] (auto&amp; child) {</span>
<span class="line-added">1350         CSSUnitType childType = unitType;</span>
<span class="line-added">1351         if (allowNumbers &amp;&amp; unitType != CSSUnitType::CSS_NUMBER &amp;&amp; child-&gt;primitiveType() == CSSUnitType::CSS_NUMBER)</span>
<span class="line-added">1352             childType = CSSUnitType::CSS_NUMBER;</span>
<span class="line-added">1353         return child-&gt;doubleValue(childType);</span>
<span class="line-added">1354     }));</span>
<span class="line-added">1355 }</span>
<span class="line-added">1356 </span>
<span class="line-added">1357 double CSSCalcOperationNode::computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const</span>
<span class="line-added">1358 {</span>
<span class="line-added">1359     return evaluate(m_children.map([&amp;] (auto&amp; child) {</span>
<span class="line-added">1360         return child-&gt;computeLengthPx(conversionData);</span>
<span class="line-added">1361     }));</span>
<span class="line-added">1362 }</span>
<span class="line-added">1363 </span>
<span class="line-added">1364 void CSSCalcOperationNode::collectDirectComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const</span>
<span class="line-added">1365 {</span>
<span class="line-added">1366     for (auto&amp; child : m_children)</span>
<span class="line-added">1367         child-&gt;collectDirectComputationalDependencies(values);</span>
<span class="line-added">1368 }</span>
<span class="line-added">1369 </span>
<span class="line-added">1370 void CSSCalcOperationNode::collectDirectRootComputationalDependencies(HashSet&lt;CSSPropertyID&gt;&amp; values) const</span>
<span class="line-added">1371 {</span>
<span class="line-added">1372     for (auto&amp; child : m_children)</span>
<span class="line-added">1373         child-&gt;collectDirectRootComputationalDependencies(values);</span>
<span class="line-added">1374 }</span>
<span class="line-added">1375 </span>
<span class="line-added">1376 void CSSCalcOperationNode::buildCSSText(const CSSCalcExpressionNode&amp; node, StringBuilder&amp; builder)</span>
<span class="line-added">1377 {</span>
<span class="line-added">1378     auto shouldOutputEnclosingCalc = [](const CSSCalcExpressionNode&amp; rootNode) {</span>
<span class="line-added">1379         if (is&lt;CSSCalcOperationNode&gt;(rootNode)) {</span>
<span class="line-added">1380             auto&amp; operationNode = downcast&lt;CSSCalcOperationNode&gt;(rootNode);</span>
<span class="line-added">1381             return operationNode.isCalcSumNode() || operationNode.isCalcProductNode();</span>
<span class="line-added">1382         }</span>
<span class="line-added">1383         return true;</span>
<span class="line-added">1384     };</span>
<span class="line-added">1385 </span>
<span class="line-added">1386     bool outputCalc = shouldOutputEnclosingCalc(node);</span>
<span class="line-added">1387     if (outputCalc)</span>
<span class="line-added">1388         builder.append(&quot;calc(&quot;);</span>
<span class="line-added">1389 </span>
<span class="line-added">1390     buildCSSTextRecursive(node, builder, GroupingParens::Omit);</span>
<span class="line-added">1391 </span>
<span class="line-added">1392     if (outputCalc)</span>
<span class="line-added">1393         builder.append(&#39;)&#39;);</span>
<span class="line-added">1394 }</span>
<span class="line-added">1395 </span>
<span class="line-added">1396 static const char* functionPrefixForOperator(CalcOperator op)</span>
<span class="line-added">1397 {</span>
<span class="line-added">1398     switch (op) {</span>
<span class="line-added">1399     case CalcOperator::Add:</span>
<span class="line-added">1400     case CalcOperator::Subtract:</span>
<span class="line-added">1401     case CalcOperator::Multiply:</span>
<span class="line-added">1402     case CalcOperator::Divide:</span>
<span class="line-added">1403         ASSERT_NOT_REACHED();</span>
<span class="line-added">1404         return &quot;&quot;;</span>
<span class="line-added">1405     case CalcOperator::Min: return &quot;min(&quot;;</span>
<span class="line-added">1406     case CalcOperator::Max: return &quot;max(&quot;;</span>
<span class="line-added">1407     case CalcOperator::Clamp: return &quot;clamp(&quot;;</span>
<span class="line-added">1408     }</span>
<span class="line-added">1409 </span>
<span class="line-added">1410     return &quot;&quot;;</span>
<span class="line-added">1411 }</span>
<span class="line-added">1412 </span>
<span class="line-added">1413 // &lt;https://drafts.csswg.org/css-values-4/#serialize-a-calculation-tree&gt;</span>
<span class="line-added">1414 void CSSCalcOperationNode::buildCSSTextRecursive(const CSSCalcExpressionNode&amp; node, StringBuilder&amp; builder, GroupingParens parens)</span>
<span class="line-added">1415 {</span>
<span class="line-added">1416     // If root is a numeric value, or a non-math function, serialize root per the normal rules for it and return the result.</span>
<span class="line-added">1417     if (is&lt;CSSCalcPrimitiveValueNode&gt;(node)) {</span>
<span class="line-added">1418         auto&amp; valueNode = downcast&lt;CSSCalcPrimitiveValueNode&gt;(node);</span>
<span class="line-added">1419         builder.append(valueNode.customCSSText());</span>
<span class="line-added">1420         return;</span>
<span class="line-added">1421     }</span>
<span class="line-added">1422 </span>
<span class="line-added">1423     if (is&lt;CSSCalcOperationNode&gt;(node)) {</span>
<span class="line-added">1424         auto&amp; operationNode = downcast&lt;CSSCalcOperationNode&gt;(node);</span>
<span class="line-added">1425 </span>
<span class="line-added">1426         if (operationNode.isCalcSumNode()) {</span>
<span class="line-added">1427             // If root is a Sum node, let s be a string initially containing &quot;(&quot;.</span>
<span class="line-added">1428             if (parens == GroupingParens::Include)</span>
<span class="line-added">1429                 builder.append(&#39;(&#39;);</span>
<span class="line-added">1430 </span>
<span class="line-added">1431             // Simplification already sorted children.</span>
<span class="line-added">1432             auto&amp; children = operationNode.children();</span>
<span class="line-added">1433             ASSERT(children.size());</span>
<span class="line-added">1434             // Serialize root’s first child, and append it to s.</span>
<span class="line-added">1435             buildCSSTextRecursive(children.first(), builder);</span>
<span class="line-added">1436 </span>
<span class="line-added">1437             // For each child of root beyond the first:</span>
<span class="line-added">1438             // If child is a Negate node, append &quot; - &quot; to s, then serialize the Negate’s child and append the result to s.</span>
<span class="line-added">1439             // If child is a negative numeric value, append &quot; - &quot; to s, then serialize the negation of child as normal and append the result to s.</span>
<span class="line-added">1440             // Otherwise, append &quot; + &quot; to s, then serialize child and append the result to s.</span>
<span class="line-added">1441             for (unsigned i = 1; i &lt; children.size(); ++i) {</span>
<span class="line-added">1442                 auto&amp; child = children[i];</span>
<span class="line-added">1443                 if (is&lt;CSSCalcNegateNode&gt;(child)) {</span>
<span class="line-added">1444                     builder.append(&quot; - &quot;);</span>
<span class="line-added">1445                     buildCSSTextRecursive(downcast&lt;CSSCalcNegateNode&gt;(child.get()).child(), builder);</span>
<span class="line-added">1446                     continue;</span>
<span class="line-added">1447                 }</span>
<span class="line-added">1448 </span>
<span class="line-added">1449                 if (is&lt;CSSCalcPrimitiveValueNode&gt;(child)) {</span>
<span class="line-added">1450                     auto&amp; primitiveValueNode = downcast&lt;CSSCalcPrimitiveValueNode&gt;(child.get());</span>
<span class="line-added">1451                     if (primitiveValueNode.isNegative()) {</span>
<span class="line-added">1452                         builder.append(&quot; - &quot;);</span>
<span class="line-added">1453                         // Serialize the negation of child.</span>
<span class="line-added">1454                         auto unitType = primitiveValueNode.value().primitiveType();</span>
<span class="line-added">1455                         builder.append(0 - primitiveValueNode.value().doubleValue(), CSSPrimitiveValue::unitTypeString(unitType));</span>
<span class="line-added">1456                         continue;</span>
<span class="line-added">1457                     }</span>
<span class="line-added">1458                 }</span>
<span class="line-added">1459 </span>
<span class="line-added">1460                 builder.append(&quot; + &quot;);</span>
<span class="line-added">1461                 buildCSSTextRecursive(child, builder);</span>
1462             }
<a name="90" id="anc90"></a><span class="line-modified">1463 </span>
<span class="line-added">1464             if (parens == GroupingParens::Include)</span>
<span class="line-added">1465                 builder.append(&#39;)&#39;);</span>
<span class="line-added">1466             return;</span>
1467         }
<a name="91" id="anc91"></a>
1468 
<a name="92" id="anc92"></a><span class="line-modified">1469         if (operationNode.isCalcProductNode()) {</span>
<span class="line-added">1470             // If root is a Product node, let s be a string initially containing &quot;(&quot;.</span>
<span class="line-added">1471             if (parens == GroupingParens::Include)</span>
<span class="line-added">1472                 builder.append(&#39;(&#39;);</span>
<span class="line-added">1473 </span>
<span class="line-added">1474             // Simplification already sorted children.</span>
<span class="line-added">1475             auto&amp; children = operationNode.children();</span>
<span class="line-added">1476             ASSERT(children.size());</span>
<span class="line-added">1477             // Serialize root’s first child, and append it to s.</span>
<span class="line-added">1478             buildCSSTextRecursive(children.first(), builder);</span>
<span class="line-added">1479 </span>
<span class="line-added">1480             // For each child of root beyond the first:</span>
<span class="line-added">1481             // If child is an Invert node, append &quot; / &quot; to s, then serialize the Invert’s child and append the result to s.</span>
<span class="line-added">1482             // Otherwise, append &quot; * &quot; to s, then serialize child and append the result to s.</span>
<span class="line-added">1483             for (unsigned i = 1; i &lt; children.size(); ++i) {</span>
<span class="line-added">1484                 auto&amp; child = children[i];</span>
<span class="line-added">1485                 if (is&lt;CSSCalcInvertNode&gt;(child)) {</span>
<span class="line-added">1486                     builder.append(&quot; / &quot;);</span>
<span class="line-added">1487                     buildCSSTextRecursive(downcast&lt;CSSCalcInvertNode&gt;(child.get()).child(), builder);</span>
<span class="line-added">1488                     continue;</span>
<span class="line-added">1489                 }</span>
<span class="line-added">1490 </span>
<span class="line-added">1491                 builder.append(&quot; * &quot;);</span>
<span class="line-added">1492                 buildCSSTextRecursive(child, builder);</span>
<span class="line-added">1493             }</span>
<span class="line-added">1494 </span>
<span class="line-added">1495             if (parens == GroupingParens::Include)</span>
<span class="line-added">1496                 builder.append(&#39;)&#39;);</span>
<span class="line-added">1497             return;</span>
<span class="line-added">1498         }</span>
<span class="line-added">1499 </span>
<span class="line-added">1500         // If root is anything but a Sum, Negate, Product, or Invert node, serialize a math function for the</span>
<span class="line-added">1501         // function corresponding to the node type, treating the node’s children as the function’s</span>
<span class="line-added">1502         // comma-separated calculation arguments, and return the result.</span>
<span class="line-added">1503         builder.append(functionPrefixForOperator(operationNode.calcOperator()));</span>
<span class="line-added">1504 </span>
<span class="line-added">1505         auto&amp; children = operationNode.children();</span>
<span class="line-added">1506         ASSERT(children.size());</span>
<span class="line-added">1507         buildCSSTextRecursive(children.first(), builder, GroupingParens::Omit);</span>
<span class="line-added">1508 </span>
<span class="line-added">1509         for (unsigned i = 1; i &lt; children.size(); ++i) {</span>
<span class="line-added">1510             builder.append(&quot;, &quot;);</span>
<span class="line-added">1511             buildCSSTextRecursive(children[i], builder, GroupingParens::Omit);</span>
<span class="line-added">1512         }</span>
<span class="line-added">1513 </span>
<span class="line-added">1514         builder.append(&#39;)&#39;);</span>
<span class="line-added">1515         return;</span>
1516     }
1517 
<a name="93" id="anc93"></a><span class="line-modified">1518     if (is&lt;CSSCalcNegateNode&gt;(node)) {</span>
<span class="line-modified">1519         auto&amp; negateNode = downcast&lt;CSSCalcNegateNode&gt;(node);</span>
<span class="line-modified">1520         // If root is a Negate node, let s be a string initially containing &quot;(-1 * &quot;.</span>
<span class="line-modified">1521         builder.append(&quot;-1 *&quot;);</span>
<span class="line-modified">1522         buildCSSTextRecursive(negateNode.child(), builder);</span>
<span class="line-modified">1523         return;</span>
<span class="line-added">1524     }</span>
<span class="line-added">1525 </span>
<span class="line-added">1526     if (is&lt;CSSCalcInvertNode&gt;(node)) {</span>
<span class="line-added">1527         auto&amp; invertNode = downcast&lt;CSSCalcInvertNode&gt;(node);</span>
<span class="line-added">1528         // If root is an Invert node, let s be a string initially containing &quot;(1 / &quot;.</span>
<span class="line-added">1529         builder.append(&quot;1 / &quot;);</span>
<span class="line-added">1530         buildCSSTextRecursive(invertNode.child(), builder);</span>
<span class="line-added">1531         return;</span>
<span class="line-added">1532     }</span>
<span class="line-added">1533 }</span>
<span class="line-added">1534 </span>
<span class="line-added">1535 void CSSCalcOperationNode::dump(TextStream&amp; ts) const</span>
<span class="line-added">1536 {</span>
<span class="line-added">1537     ts &lt;&lt; &quot;calc operation &quot; &lt;&lt; m_operator &lt;&lt; &quot; (category: &quot; &lt;&lt; category() &lt;&lt; &quot;, type &quot; &lt;&lt; primitiveType() &lt;&lt; &quot;)&quot;;</span>
<span class="line-added">1538 </span>
<span class="line-added">1539     TextStream::GroupScope scope(ts);</span>
<span class="line-added">1540     ts &lt;&lt; m_children.size() &lt;&lt; &quot; children&quot;;</span>
<span class="line-added">1541     for (auto&amp; child : m_children)</span>
<span class="line-added">1542         ts.dumpProperty(&quot;node&quot;, child);</span>
<span class="line-added">1543 }</span>
<span class="line-added">1544 </span>
<span class="line-added">1545 bool CSSCalcOperationNode::equals(const CSSCalcExpressionNode&amp; exp) const</span>
<span class="line-added">1546 {</span>
<span class="line-added">1547     if (type() != exp.type())</span>
<span class="line-added">1548         return false;</span>
<span class="line-added">1549 </span>
<span class="line-added">1550     const CSSCalcOperationNode&amp; other = static_cast&lt;const CSSCalcOperationNode&amp;&gt;(exp);</span>
<span class="line-added">1551 </span>
<span class="line-added">1552     if (m_children.size() != other.m_children.size() || m_operator != other.m_operator)</span>
<span class="line-added">1553         return false;</span>
<span class="line-added">1554 </span>
<span class="line-added">1555     for (size_t i = 0; i &lt; m_children.size(); ++i) {</span>
<span class="line-added">1556         if (!compareCSSValue(m_children[i], other.m_children[i]))</span>
<span class="line-added">1557             return false;</span>
<span class="line-added">1558     }</span>
<span class="line-added">1559     return true;</span>
<span class="line-added">1560 }</span>
<span class="line-added">1561 </span>
<span class="line-added">1562 double CSSCalcOperationNode::evaluateOperator(CalcOperator op, const Vector&lt;double&gt;&amp; children)</span>
<span class="line-added">1563 {</span>
<span class="line-added">1564     switch (op) {</span>
<span class="line-added">1565     case CalcOperator::Add: {</span>
<span class="line-added">1566         double sum = 0;</span>
<span class="line-added">1567         for (auto&amp; child : children)</span>
<span class="line-added">1568             sum += child;</span>
<span class="line-added">1569         return sum;</span>
<span class="line-added">1570     }</span>
<span class="line-added">1571     case CalcOperator::Subtract:</span>
<span class="line-added">1572         ASSERT(children.size() == 2);</span>
<span class="line-added">1573         return children[0] - children[1];</span>
<span class="line-added">1574     case CalcOperator::Multiply: {</span>
<span class="line-added">1575         double product = 1;</span>
<span class="line-added">1576         for (auto&amp; child : children)</span>
<span class="line-added">1577             product *= child;</span>
<span class="line-added">1578         return product;</span>
<span class="line-added">1579     }</span>
<span class="line-added">1580     case CalcOperator::Divide:</span>
<span class="line-added">1581         ASSERT(children.size() == 1 || children.size() == 2);</span>
<span class="line-added">1582         if (children.size() == 1)</span>
<span class="line-added">1583             return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
<span class="line-added">1584         return children[0] / children[1];</span>
<span class="line-added">1585     case CalcOperator::Min: {</span>
<span class="line-added">1586         if (children.isEmpty())</span>
<span class="line-added">1587             return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
<span class="line-added">1588         double minimum = children[0];</span>
<span class="line-added">1589         for (auto child : children)</span>
<span class="line-added">1590             minimum = std::min(minimum, child);</span>
<span class="line-added">1591         return minimum;</span>
<span class="line-added">1592     }</span>
<span class="line-added">1593     case CalcOperator::Max: {</span>
<span class="line-added">1594         if (children.isEmpty())</span>
<span class="line-added">1595             return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
<span class="line-added">1596         double maximum = children[0];</span>
<span class="line-added">1597         for (auto child : children)</span>
<span class="line-added">1598             maximum = std::max(maximum, child);</span>
<span class="line-added">1599         return maximum;</span>
<span class="line-added">1600     }</span>
<span class="line-added">1601     case CalcOperator::Clamp: {</span>
<span class="line-added">1602         if (children.size() != 3)</span>
<span class="line-added">1603             return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
<span class="line-added">1604         double min = children[0];</span>
<span class="line-added">1605         double value = children[1];</span>
<span class="line-added">1606         double max = children[2];</span>
<span class="line-added">1607         return std::max(min, std::min(value, max));</span>
1608     }
<a name="94" id="anc94"></a><span class="line-added">1609     }</span>
<span class="line-added">1610     ASSERT_NOT_REACHED();</span>
<span class="line-added">1611     return 0;</span>
<span class="line-added">1612 }</span>
1613 
<a name="95" id="anc95"></a>



1614 
<a name="96" id="anc96"></a><span class="line-modified">1615 class CSSCalcExpressionNodeParser {</span>
<span class="line-added">1616 public:</span>
<span class="line-added">1617     explicit CSSCalcExpressionNodeParser(CalculationCategory destinationCategory)</span>
<span class="line-added">1618         : m_destinationCategory(destinationCategory)</span>
<span class="line-added">1619     { }</span>
1620 
<a name="97" id="anc97"></a><span class="line-modified">1621     RefPtr&lt;CSSCalcExpressionNode&gt; parseCalc(CSSParserTokenRange, CSSValueID function);</span>

1622 
<a name="98" id="anc98"></a><span class="line-modified">1623 private:</span>
<span class="line-modified">1624     char operatorValue(const CSSParserToken&amp; token)</span>
<span class="line-modified">1625     {</span>
<span class="line-modified">1626         if (token.type() == DelimiterToken)</span>
<span class="line-modified">1627             return token.delimiter();</span>
<span class="line-added">1628         return 0;</span>
1629     }
1630 
<a name="99" id="anc99"></a><span class="line-modified">1631     bool parseValue(CSSParserTokenRange&amp;, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);</span>
<span class="line-added">1632     bool parseValueTerm(CSSParserTokenRange&amp;, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);</span>
<span class="line-added">1633     bool parseCalcFunction(CSSParserTokenRange&amp;, CSSValueID, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);</span>
<span class="line-added">1634     bool parseCalcSum(CSSParserTokenRange&amp;, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);</span>
<span class="line-added">1635     bool parseCalcProduct(CSSParserTokenRange&amp;, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);</span>
<span class="line-added">1636     bool parseCalcValue(CSSParserTokenRange&amp;, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp;);</span>
1637 
<a name="100" id="anc100"></a><span class="line-modified">1638     CalculationCategory m_destinationCategory;</span>
<span class="line-modified">1639 };</span>






































1640 
<a name="101" id="anc101"></a><span class="line-modified">1641 // &lt;https://drafts.csswg.org/css-values-4/#calc-syntax&gt;:</span>
<span class="line-modified">1642 // &lt;calc()&gt;  = calc( &lt;calc-sum&gt; )</span>
<span class="line-modified">1643 // &lt;min()&gt;   = min( &lt;calc-sum&gt;# )</span>
<span class="line-modified">1644 // &lt;max()&gt;   = max( &lt;calc-sum&gt;# )</span>
<span class="line-modified">1645 // &lt;clamp()&gt; = clamp( &lt;calc-sum&gt;#{3} )</span>
<span class="line-modified">1646 // &lt;sin()&gt;   = sin( &lt;calc-sum&gt; )</span>
<span class="line-modified">1647 // &lt;cos()&gt;   = cos( &lt;calc-sum&gt; )</span>
<span class="line-modified">1648 // &lt;tan()&gt;   = tan( &lt;calc-sum&gt; )</span>
<span class="line-added">1649 // &lt;asin()&gt;  = asin( &lt;calc-sum&gt; )</span>
<span class="line-added">1650 // &lt;acos()&gt;  = acos( &lt;calc-sum&gt; )</span>
<span class="line-added">1651 // &lt;atan()&gt;  = atan( &lt;calc-sum&gt; )</span>
<span class="line-added">1652 // &lt;atan2()&gt; = atan2( &lt;calc-sum&gt;, &lt;calc-sum&gt; )</span>
<span class="line-added">1653 // &lt;pow()&gt;   = pow( &lt;calc-sum&gt;, &lt;calc-sum&gt; )</span>
<span class="line-added">1654 // &lt;sqrt()&gt;  = sqrt( &lt;calc-sum&gt; )</span>
<span class="line-added">1655 // &lt;hypot()&gt; = hypot( &lt;calc-sum&gt;# )</span>
<span class="line-added">1656 // &lt;calc-sum&gt; = &lt;calc-product&gt; [ [ &#39;+&#39; | &#39;-&#39; ] &lt;calc-product&gt; ]*</span>
<span class="line-added">1657 // &lt;calc-product&gt; = &lt;calc-value&gt; [ [ &#39;*&#39; | &#39;/&#39; ] &lt;calc-value&gt; ]*</span>
<span class="line-added">1658 // &lt;calc-value&gt; = &lt;number&gt; | &lt;dimension&gt; | &lt;percentage&gt; | ( &lt;calc-sum&gt; )</span>
<span class="line-added">1659 RefPtr&lt;CSSCalcExpressionNode&gt; CSSCalcExpressionNodeParser::parseCalc(CSSParserTokenRange tokens, CSSValueID function)</span>
<span class="line-added">1660 {</span>
<span class="line-added">1661     tokens.consumeWhitespace();</span>
1662 
<a name="102" id="anc102"></a><span class="line-modified">1663     RefPtr&lt;CSSCalcExpressionNode&gt; result;</span>
<span class="line-modified">1664     bool ok = parseCalcFunction(tokens, function, 0, result);</span>
<span class="line-modified">1665     if (!ok || !tokens.atEnd())</span>
<span class="line-modified">1666         return nullptr;</span>


1667 
<a name="103" id="anc103"></a><span class="line-modified">1668     if (!result)</span>





1669         return nullptr;
<a name="104" id="anc104"></a>
1670 
<a name="105" id="anc105"></a><span class="line-modified">1671     LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;CSSCalcExpressionNodeParser::parseCalc &quot; &lt;&lt; prettyPrintNode(*result));</span>



1672 
<a name="106" id="anc106"></a><span class="line-modified">1673     result = CSSCalcOperationNode::simplify(result.releaseNonNull());</span>




































1674 
<a name="107" id="anc107"></a><span class="line-modified">1675     LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;CSSCalcExpressionNodeParser::parseCalc - after simplification &quot; &lt;&lt; prettyPrintNode(*result));</span>
<span class="line-modified">1676 </span>
<span class="line-added">1677     return result;</span>
<span class="line-added">1678 }</span>
<span class="line-added">1679 </span>
<span class="line-added">1680 enum ParseState {</span>
<span class="line-added">1681     OK,</span>
<span class="line-added">1682     TooDeep,</span>
<span class="line-added">1683     NoMoreTokens</span>
1684 };
1685 
<a name="108" id="anc108"></a><span class="line-modified">1686 static ParseState checkDepthAndIndex(int depth, CSSParserTokenRange tokens)</span>
1687 {
<a name="109" id="anc109"></a>
1688     if (tokens.atEnd())
1689         return NoMoreTokens;
<a name="110" id="anc110"></a><span class="line-modified">1690     if (depth &gt; maxExpressionDepth) {</span>
<span class="line-added">1691         LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;Depth &quot; &lt;&lt; depth &lt;&lt; &quot; exceeded maxExpressionDepth &quot; &lt;&lt; maxExpressionDepth);</span>
1692         return TooDeep;
<a name="111" id="anc111"></a><span class="line-added">1693     }</span>
1694     return OK;
1695 }
1696 
<a name="112" id="anc112"></a><span class="line-modified">1697 bool CSSCalcExpressionNodeParser::parseCalcFunction(CSSParserTokenRange&amp; tokens, CSSValueID functionID, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp; result)</span>
<span class="line-modified">1698 {</span>
<span class="line-modified">1699     if (checkDepthAndIndex(depth, tokens) != OK)</span>
<span class="line-modified">1700         return false;</span>

1701 
<a name="113" id="anc113"></a><span class="line-modified">1702     // &quot;arguments&quot; refers to things between commas.</span>
<span class="line-modified">1703     unsigned minArgumentCount = 1;</span>
<span class="line-modified">1704     Optional&lt;unsigned&gt; maxArgumentCount;</span>
<span class="line-modified">1705 </span>
<span class="line-modified">1706     switch (functionID) {</span>
<span class="line-modified">1707     case CSSValueMin:</span>
<span class="line-modified">1708     case CSSValueMax:</span>
<span class="line-modified">1709         maxArgumentCount = WTF::nullopt;</span>
<span class="line-modified">1710         break;</span>
<span class="line-modified">1711     case CSSValueClamp:</span>
<span class="line-modified">1712         minArgumentCount = 3;</span>
<span class="line-modified">1713         maxArgumentCount = 3;</span>
<span class="line-added">1714         break;</span>
<span class="line-added">1715     case CSSValueCalc:</span>
<span class="line-added">1716         maxArgumentCount = 1;</span>
<span class="line-added">1717         break;</span>
<span class="line-added">1718     // TODO: clamp, sin, cos, tan, asin, acos, atan, atan2, pow, sqrt, hypot.</span>
<span class="line-added">1719     default:</span>
<span class="line-added">1720         break;</span>
1721     }
1722 
<a name="114" id="anc114"></a><span class="line-modified">1723     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; nodes;</span>



1724 
<a name="115" id="anc115"></a><span class="line-modified">1725     bool requireComma = false;</span>
<span class="line-modified">1726     unsigned argumentCount = 0;</span>
<span class="line-modified">1727     while (!tokens.atEnd()) {</span>
<span class="line-modified">1728         tokens.consumeWhitespace();</span>
<span class="line-modified">1729         if (requireComma) {</span>
<span class="line-modified">1730             if (tokens.consume().type() != CommaToken)</span>
<span class="line-added">1731                 return false;</span>
<span class="line-added">1732             tokens.consumeWhitespace();</span>
<span class="line-added">1733         }</span>
1734 
<a name="116" id="anc116"></a><span class="line-modified">1735         RefPtr&lt;CSSCalcExpressionNode&gt; node;</span>
<span class="line-modified">1736         if (!parseCalcSum(tokens, depth, node))</span>


1737             return false;
1738 
<a name="117" id="anc117"></a><span class="line-modified">1739         ++argumentCount;</span>
<span class="line-modified">1740         if (maxArgumentCount &amp;&amp; argumentCount &gt; maxArgumentCount.value())</span>
1741             return false;
1742 
<a name="118" id="anc118"></a><span class="line-modified">1743         nodes.append(node.releaseNonNull());</span>
<span class="line-modified">1744         requireComma = true;</span>
<span class="line-added">1745     }</span>
1746 
<a name="119" id="anc119"></a><span class="line-modified">1747     if (argumentCount &lt; minArgumentCount)</span>
<span class="line-added">1748         return false;</span>
<span class="line-added">1749 </span>
<span class="line-added">1750     switch (functionID) {</span>
<span class="line-added">1751     case CSSValueMin:</span>
<span class="line-added">1752         result = CSSCalcOperationNode::createMinOrMaxOrClamp(CalcOperator::Min, WTFMove(nodes), m_destinationCategory);</span>
<span class="line-added">1753         break;</span>
<span class="line-added">1754     case CSSValueMax:</span>
<span class="line-added">1755         result = CSSCalcOperationNode::createMinOrMaxOrClamp(CalcOperator::Max, WTFMove(nodes), m_destinationCategory);</span>
<span class="line-added">1756         break;</span>
<span class="line-added">1757     case CSSValueClamp:</span>
<span class="line-added">1758         result = CSSCalcOperationNode::createMinOrMaxOrClamp(CalcOperator::Clamp, WTFMove(nodes), m_destinationCategory);</span>
<span class="line-added">1759         break;</span>
<span class="line-added">1760     case CSSValueWebkitCalc:</span>
<span class="line-added">1761     case CSSValueCalc:</span>
<span class="line-added">1762         result = CSSCalcOperationNode::createSum(WTFMove(nodes));</span>
<span class="line-added">1763         break;</span>
<span class="line-added">1764     // TODO: clamp, sin, cos, tan, asin, acos, atan, atan2, pow, sqrt, hypot</span>
<span class="line-added">1765     default:</span>
<span class="line-added">1766         break;</span>
1767     }
1768 
<a name="120" id="anc120"></a><span class="line-modified">1769     return !!result;</span>
<span class="line-modified">1770 }</span>
<span class="line-modified">1771 </span>
<span class="line-modified">1772 bool CSSCalcExpressionNodeParser::parseValue(CSSParserTokenRange&amp; tokens, RefPtr&lt;CSSCalcExpressionNode&gt;&amp; result)</span>
<span class="line-added">1773 {</span>
<span class="line-added">1774     CSSParserToken token = tokens.consumeIncludingWhitespace();</span>
<span class="line-added">1775     if (!(token.type() == NumberToken || token.type() == PercentageToken || token.type() == DimensionToken))</span>
<span class="line-added">1776         return false;</span>
1777 
<a name="121" id="anc121"></a><span class="line-modified">1778     auto type = token.unitType();</span>
<span class="line-added">1779     if (calcUnitCategory(type) == CalculationCategory::Other)</span>
<span class="line-added">1780         return false;</span>
1781 
<a name="122" id="anc122"></a><span class="line-modified">1782     result = CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(token.numericValue(), type));</span>





1783 
<a name="123" id="anc123"></a><span class="line-modified">1784     return true;</span>
<span class="line-modified">1785 }</span>
<span class="line-modified">1786 </span>
<span class="line-modified">1787 bool CSSCalcExpressionNodeParser::parseCalcValue(CSSParserTokenRange&amp; tokens, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp; result)</span>
<span class="line-modified">1788 {</span>
<span class="line-added">1789     if (checkDepthAndIndex(depth, tokens) != OK)</span>
<span class="line-added">1790         return false;</span>
<span class="line-added">1791 </span>
<span class="line-added">1792     auto findFunctionId = [&amp;](CSSValueID&amp; functionId) {</span>
<span class="line-added">1793         if (tokens.peek().type() == LeftParenthesisToken) {</span>
<span class="line-added">1794             functionId = CSSValueCalc;</span>
<span class="line-added">1795             return true;</span>
1796         }
1797 
<a name="124" id="anc124"></a><span class="line-modified">1798         functionId = tokens.peek().functionId();</span>
<span class="line-added">1799         return CSSCalcValue::isCalcFunction(functionId);</span>
<span class="line-added">1800     };</span>
<span class="line-added">1801 </span>
<span class="line-added">1802     CSSValueID functionId;</span>
<span class="line-added">1803     if (findFunctionId(functionId)) {</span>
<span class="line-added">1804         CSSParserTokenRange innerRange = tokens.consumeBlock();</span>
<span class="line-added">1805         tokens.consumeWhitespace();</span>
<span class="line-added">1806         innerRange.consumeWhitespace();</span>
<span class="line-added">1807         return parseCalcFunction(innerRange, functionId, depth + 1, result);</span>
1808     }
1809 
<a name="125" id="anc125"></a><span class="line-modified">1810     return parseValue(tokens, result);</span>
<span class="line-modified">1811 }</span>


1812 
<a name="126" id="anc126"></a><span class="line-modified">1813 bool CSSCalcExpressionNodeParser::parseCalcProduct(CSSParserTokenRange&amp; tokens, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp; result)</span>
<span class="line-modified">1814 {</span>
<span class="line-added">1815     if (checkDepthAndIndex(depth, tokens) != OK)</span>
<span class="line-added">1816         return false;</span>
1817 
<a name="127" id="anc127"></a><span class="line-modified">1818     RefPtr&lt;CSSCalcExpressionNode&gt; firstValue;</span>
<span class="line-modified">1819     if (!parseCalcValue(tokens, depth, firstValue))</span>
<span class="line-modified">1820         return false;</span>


1821 
<a name="128" id="anc128"></a><span class="line-modified">1822     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; nodes;</span>
<span class="line-modified">1823 </span>
<span class="line-modified">1824     while (!tokens.atEnd()) {</span>
<span class="line-added">1825         char operatorCharacter = operatorValue(tokens.peek());</span>
<span class="line-added">1826         if (operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Multiply) &amp;&amp; operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Divide))</span>
<span class="line-added">1827             break;</span>
<span class="line-added">1828         tokens.consumeIncludingWhitespace();</span>
1829 
<a name="129" id="anc129"></a><span class="line-modified">1830         RefPtr&lt;CSSCalcExpressionNode&gt; nextValue;</span>
<span class="line-added">1831         if (!parseCalcValue(tokens, depth, nextValue) || !nextValue)</span>
<span class="line-added">1832             return false;</span>
1833 
<a name="130" id="anc130"></a><span class="line-modified">1834         if (operatorCharacter == static_cast&lt;char&gt;(CalcOperator::Divide))</span>
<span class="line-modified">1835             nextValue = CSSCalcInvertNode::create(nextValue.releaseNonNull());</span>

1836 
<a name="131" id="anc131"></a><span class="line-modified">1837         if (firstValue)</span>
<span class="line-added">1838             nodes.append(firstValue.releaseNonNull());</span>
<span class="line-added">1839 </span>
<span class="line-added">1840         nodes.append(nextValue.releaseNonNull());</span>
1841     }
1842 
<a name="132" id="anc132"></a><span class="line-modified">1843     if (nodes.isEmpty()) {</span>
<span class="line-modified">1844         result = WTFMove(firstValue);</span>
<span class="line-modified">1845         return !!result;</span>
<span class="line-modified">1846     }</span>
1847 
<a name="133" id="anc133"></a><span class="line-modified">1848     result = CSSCalcOperationNode::createProduct(WTFMove(nodes));</span>
<span class="line-modified">1849     return !!result;</span>
<span class="line-added">1850 }</span>
1851 
<a name="134" id="anc134"></a><span class="line-modified">1852 bool CSSCalcExpressionNodeParser::parseCalcSum(CSSParserTokenRange&amp; tokens, int depth, RefPtr&lt;CSSCalcExpressionNode&gt;&amp; result)</span>
<span class="line-modified">1853 {</span>
<span class="line-modified">1854     if (checkDepthAndIndex(depth, tokens) != OK)</span>
<span class="line-modified">1855         return false;</span>










1856 
<a name="135" id="anc135"></a><span class="line-modified">1857     RefPtr&lt;CSSCalcExpressionNode&gt; firstValue;</span>
<span class="line-modified">1858     if (!parseCalcProduct(tokens, depth, firstValue))</span>
<span class="line-modified">1859         return false;</span>

1860 
<a name="136" id="anc136"></a><span class="line-modified">1861     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; nodes;</span>

1862 
<a name="137" id="anc137"></a><span class="line-modified">1863     while (!tokens.atEnd()) {</span>
<span class="line-modified">1864         char operatorCharacter = operatorValue(tokens.peek());</span>
<span class="line-modified">1865         if (operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Add) &amp;&amp; operatorCharacter != static_cast&lt;char&gt;(CalcOperator::Subtract))</span>
<span class="line-modified">1866             break;</span>
1867 
<a name="138" id="anc138"></a><span class="line-modified">1868         if ((&amp;tokens.peek() - 1)-&gt;type() != WhitespaceToken)</span>
<span class="line-added">1869             return false; // calc(1px+ 2px) is invalid</span>
1870 
<a name="139" id="anc139"></a><span class="line-modified">1871         tokens.consume();</span>
<span class="line-modified">1872         if (tokens.peek().type() != WhitespaceToken)</span>
<span class="line-modified">1873             return false; // calc(1px +2px) is invalid</span>
1874 
<a name="140" id="anc140"></a><span class="line-modified">1875         tokens.consumeIncludingWhitespace();</span>

1876 
<a name="141" id="anc141"></a><span class="line-modified">1877         RefPtr&lt;CSSCalcExpressionNode&gt; nextValue;</span>
<span class="line-modified">1878         if (!parseCalcProduct(tokens, depth, nextValue) || !nextValue)</span>
<span class="line-modified">1879             return false;</span>


1880 
<a name="142" id="anc142"></a><span class="line-modified">1881         if (operatorCharacter == static_cast&lt;char&gt;(CalcOperator::Subtract))</span>
<span class="line-modified">1882             nextValue = CSSCalcNegateNode::create(nextValue.releaseNonNull());</span>
1883 
<a name="143" id="anc143"></a><span class="line-modified">1884         if (firstValue)</span>
<span class="line-modified">1885             nodes.append(firstValue.releaseNonNull());</span>
1886 
<a name="144" id="anc144"></a><span class="line-modified">1887         nodes.append(nextValue.releaseNonNull());</span>

1888     }
1889 
<a name="145" id="anc145"></a><span class="line-modified">1890     if (nodes.isEmpty()) {</span>
<span class="line-modified">1891         result = WTFMove(firstValue);</span>
<span class="line-modified">1892         return !!result;</span>
1893     }
1894 
<a name="146" id="anc146"></a><span class="line-modified">1895     result = CSSCalcOperationNode::createSum(WTFMove(nodes));</span>
<span class="line-modified">1896     return !!result;</span>
<span class="line-added">1897 }</span>
<span class="line-added">1898 </span>
<span class="line-added">1899 static inline RefPtr&lt;CSSCalcOperationNode&gt; createBlendHalf(const Length&amp; length, const RenderStyle&amp; style, float progress)</span>
<span class="line-added">1900 {</span>
<span class="line-added">1901     return CSSCalcOperationNode::create(CalcOperator::Multiply, createCSS(length, style),</span>
<span class="line-added">1902         CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(progress, CSSUnitType::CSS_NUMBER)));</span>
<span class="line-added">1903 }</span>
1904 
<a name="147" id="anc147"></a><span class="line-modified">1905 static Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; createCSS(const Vector&lt;std::unique_ptr&lt;CalcExpressionNode&gt;&gt;&amp; nodes, const RenderStyle&amp; style)</span>
1906 {
<a name="148" id="anc148"></a><span class="line-modified">1907     Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; values;</span>
<span class="line-modified">1908     values.reserveInitialCapacity(nodes.size());</span>
<span class="line-added">1909     for (auto&amp; node : nodes) {</span>
<span class="line-added">1910         auto cssNode = createCSS(*node, style);</span>
<span class="line-added">1911         if (!cssNode)</span>
<span class="line-added">1912             return { };</span>
<span class="line-added">1913         values.uncheckedAppend(cssNode.releaseNonNull());</span>
<span class="line-added">1914     }</span>
<span class="line-added">1915     return values;</span>
1916 }
1917 
1918 static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const CalcExpressionNode&amp; node, const RenderStyle&amp; style)
1919 {
1920     switch (node.type()) {
1921     case CalcExpressionNodeType::Number: {
<a name="149" id="anc149"></a><span class="line-modified">1922         float value = downcast&lt;CalcExpressionNumber&gt;(node).value(); // double?</span>
<span class="line-modified">1923         return CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(value, CSSUnitType::CSS_NUMBER));</span>
1924     }
1925     case CalcExpressionNodeType::Length:
<a name="150" id="anc150"></a><span class="line-modified">1926         return createCSS(downcast&lt;CalcExpressionLength&gt;(node).length(), style);</span>
<span class="line-added">1927 </span>
<span class="line-added">1928     case CalcExpressionNodeType::Negation: {</span>
<span class="line-added">1929         auto childNode = createCSS(*downcast&lt;CalcExpressionNegation&gt;(node).child(), style);</span>
<span class="line-added">1930         if (!childNode)</span>
<span class="line-added">1931             return nullptr;</span>
<span class="line-added">1932         return CSSCalcNegateNode::create(childNode.releaseNonNull());</span>
<span class="line-added">1933     }</span>
<span class="line-added">1934     case CalcExpressionNodeType::Inversion: {</span>
<span class="line-added">1935         auto childNode = createCSS(*downcast&lt;CalcExpressionInversion&gt;(node).child(), style);</span>
<span class="line-added">1936         if (!childNode)</span>
<span class="line-added">1937             return nullptr;</span>
<span class="line-added">1938         return CSSCalcInvertNode::create(childNode.releaseNonNull());</span>
<span class="line-added">1939     }</span>
1940     case CalcExpressionNodeType::Operation: {
<a name="151" id="anc151"></a><span class="line-modified">1941         auto&amp; operationNode = downcast&lt;CalcExpressionOperation&gt;(node);</span>
1942         auto&amp; operationChildren = operationNode.children();
1943         CalcOperator op = operationNode.getOperator();
<a name="152" id="anc152"></a><span class="line-modified">1944 </span>
<span class="line-added">1945         switch (op) {</span>
<span class="line-added">1946         case CalcOperator::Add: {</span>
<span class="line-added">1947             auto children = createCSS(operationChildren, style);</span>
<span class="line-added">1948             if (children.isEmpty())</span>
<span class="line-added">1949                 return nullptr;</span>
<span class="line-added">1950             return CSSCalcOperationNode::createSum(WTFMove(children));</span>
<span class="line-added">1951         } case CalcOperator::Subtract: {</span>
<span class="line-added">1952             ASSERT(operationChildren.size() == 2);</span>
<span class="line-added">1953 </span>
1954             Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; values;
1955             values.reserveInitialCapacity(operationChildren.size());
<a name="153" id="anc153"></a><span class="line-modified">1956 </span>
<span class="line-modified">1957             auto firstChild = createCSS(*operationChildren[0], style);</span>
<span class="line-modified">1958             if (!firstChild)</span>
<span class="line-modified">1959                 return nullptr;</span>
<span class="line-modified">1960 </span>
<span class="line-modified">1961             auto secondChild = createCSS(*operationChildren[1], style);</span>
<span class="line-modified">1962             if (!secondChild)</span>
<span class="line-added">1963                 return nullptr;</span>
<span class="line-added">1964             auto negateNode = CSSCalcNegateNode::create(secondChild.releaseNonNull());</span>
<span class="line-added">1965 </span>
<span class="line-added">1966             values.append(firstChild.releaseNonNull());</span>
<span class="line-added">1967             values.append(WTFMove(negateNode));</span>
<span class="line-added">1968 </span>
<span class="line-added">1969             return CSSCalcOperationNode::createSum(WTFMove(values));</span>
<span class="line-added">1970         }</span>
<span class="line-added">1971         case CalcOperator::Multiply: {</span>
<span class="line-added">1972             auto children = createCSS(operationChildren, style);</span>
<span class="line-added">1973             if (children.isEmpty())</span>
<span class="line-added">1974                 return nullptr;</span>
<span class="line-added">1975             return CSSCalcOperationNode::createProduct(WTFMove(children));</span>
1976         }
<a name="154" id="anc154"></a><span class="line-added">1977         case CalcOperator::Divide: {</span>
<span class="line-added">1978             ASSERT(operationChildren.size() == 2);</span>
<span class="line-added">1979 </span>
<span class="line-added">1980             Vector&lt;Ref&lt;CSSCalcExpressionNode&gt;&gt; values;</span>
<span class="line-added">1981             values.reserveInitialCapacity(operationChildren.size());</span>
<span class="line-added">1982 </span>
<span class="line-added">1983             auto firstChild = createCSS(*operationChildren[0], style);</span>
<span class="line-added">1984             if (!firstChild)</span>
<span class="line-added">1985                 return nullptr;</span>
<span class="line-added">1986 </span>
<span class="line-added">1987             auto secondChild = createCSS(*operationChildren[1], style);</span>
<span class="line-added">1988             if (!secondChild)</span>
<span class="line-added">1989                 return nullptr;</span>
<span class="line-added">1990             auto invertNode = CSSCalcInvertNode::create(secondChild.releaseNonNull());</span>
1991 
<a name="155" id="anc155"></a><span class="line-modified">1992             values.append(firstChild.releaseNonNull());</span>
<span class="line-modified">1993             values.append(WTFMove(invertNode));</span>
1994 
<a name="156" id="anc156"></a><span class="line-added">1995             return CSSCalcOperationNode::createProduct(createCSS(operationChildren, style));</span>
<span class="line-added">1996         }</span>
<span class="line-added">1997         case CalcOperator::Min:</span>
<span class="line-added">1998         case CalcOperator::Max:</span>
<span class="line-added">1999         case CalcOperator::Clamp: {</span>
<span class="line-added">2000             auto children = createCSS(operationChildren, style);</span>
<span class="line-added">2001             if (children.isEmpty())</span>
<span class="line-added">2002                 return nullptr;</span>
<span class="line-added">2003             return CSSCalcOperationNode::createMinOrMaxOrClamp(op, WTFMove(children), CalculationCategory::Other);</span>
<span class="line-added">2004         }</span>
<span class="line-added">2005         }</span>
2006         return nullptr;
2007     }
2008     case CalcExpressionNodeType::BlendLength: {
2009         // FIXME: (http://webkit.org/b/122036) Create a CSSCalcExpressionNode equivalent of CalcExpressionBlendLength.
<a name="157" id="anc157"></a><span class="line-modified">2010         auto&amp; blend = downcast&lt;CalcExpressionBlendLength&gt;(node);</span>
2011         float progress = blend.progress();
<a name="158" id="anc158"></a><span class="line-modified">2012         return CSSCalcOperationNode::create(CalcOperator::Add, createBlendHalf(blend.from(), style, 1 - progress), createBlendHalf(blend.to(), style, progress));</span>
2013     }
2014     case CalcExpressionNodeType::Undefined:
2015         ASSERT_NOT_REACHED();
2016     }
2017     return nullptr;
2018 }
2019 
2020 static RefPtr&lt;CSSCalcExpressionNode&gt; createCSS(const Length&amp; length, const RenderStyle&amp; style)
2021 {
2022     switch (length.type()) {
2023     case Percent:
2024     case Fixed:
<a name="159" id="anc159"></a><span class="line-modified">2025         return CSSCalcPrimitiveValueNode::create(CSSPrimitiveValue::create(length, style));</span>
2026     case Calculated:
2027         return createCSS(length.calculationValue().expression(), style);
2028     case Auto:
2029     case Intrinsic:
2030     case MinIntrinsic:
2031     case MinContent:
2032     case MaxContent:
2033     case FillAvailable:
2034     case FitContent:
2035     case Relative:
2036     case Undefined:
2037         ASSERT_NOT_REACHED();
2038     }
2039     return nullptr;
2040 }
2041 
<a name="160" id="anc160"></a><span class="line-added">2042 String CSSCalcValue::customCSSText() const</span>
<span class="line-added">2043 {</span>
<span class="line-added">2044     StringBuilder builder;</span>
<span class="line-added">2045     CSSCalcOperationNode::buildCSSText(m_expression.get(), builder);</span>
<span class="line-added">2046     return builder.toString();</span>
<span class="line-added">2047 }</span>
<span class="line-added">2048 </span>
<span class="line-added">2049 bool CSSCalcValue::equals(const CSSCalcValue&amp; other) const</span>
<span class="line-added">2050 {</span>
<span class="line-added">2051     return compareCSSValue(m_expression, other.m_expression);</span>
<span class="line-added">2052 }</span>
<span class="line-added">2053 </span>
<span class="line-added">2054 inline double CSSCalcValue::clampToPermittedRange(double value) const</span>
<span class="line-added">2055 {</span>
<span class="line-added">2056     return m_shouldClampToNonNegative &amp;&amp; value &lt; 0 ? 0 : value;</span>
<span class="line-added">2057 }</span>
<span class="line-added">2058 </span>
<span class="line-added">2059 double CSSCalcValue::doubleValue() const</span>
<span class="line-added">2060 {</span>
<span class="line-added">2061     return clampToPermittedRange(m_expression-&gt;doubleValue(primitiveType()));</span>
<span class="line-added">2062 }</span>
<span class="line-added">2063 </span>
<span class="line-added">2064 double CSSCalcValue::computeLengthPx(const CSSToLengthConversionData&amp; conversionData) const</span>
<span class="line-added">2065 {</span>
<span class="line-added">2066     return clampToPermittedRange(m_expression-&gt;computeLengthPx(conversionData));</span>
<span class="line-added">2067 }</span>
<span class="line-added">2068 </span>
<span class="line-added">2069 bool CSSCalcValue::isCalcFunction(CSSValueID functionId)</span>
<span class="line-added">2070 {</span>
<span class="line-added">2071     switch (functionId) {</span>
<span class="line-added">2072     case CSSValueCalc:</span>
<span class="line-added">2073     case CSSValueWebkitCalc:</span>
<span class="line-added">2074     case CSSValueMin:</span>
<span class="line-added">2075     case CSSValueMax:</span>
<span class="line-added">2076     case CSSValueClamp:</span>
<span class="line-added">2077         return true;</span>
<span class="line-added">2078     default:</span>
<span class="line-added">2079         return false;</span>
<span class="line-added">2080     }</span>
<span class="line-added">2081     return false;</span>
<span class="line-added">2082 }</span>
<span class="line-added">2083 </span>
<span class="line-added">2084 void CSSCalcValue::dump(TextStream&amp; ts) const</span>
<span class="line-added">2085 {</span>
<span class="line-added">2086     ts &lt;&lt; indent &lt;&lt; &quot;(&quot; &lt;&lt; &quot;CSSCalcValue&quot;;</span>
<span class="line-added">2087 </span>
<span class="line-added">2088     TextStream multilineStream;</span>
<span class="line-added">2089     multilineStream.setIndent(ts.indent() + 2);</span>
<span class="line-added">2090 </span>
<span class="line-added">2091     multilineStream.dumpProperty(&quot;should clamp non-negative&quot;, m_shouldClampToNonNegative);</span>
<span class="line-added">2092     multilineStream.dumpProperty(&quot;expression&quot;, m_expression.get());</span>
<span class="line-added">2093 </span>
<span class="line-added">2094     ts &lt;&lt; multilineStream.release();</span>
<span class="line-added">2095     ts &lt;&lt; &quot;)\n&quot;;</span>
<span class="line-added">2096 }</span>
<span class="line-added">2097 </span>
2098 RefPtr&lt;CSSCalcValue&gt; CSSCalcValue::create(CSSValueID function, const CSSParserTokenRange&amp; tokens, CalculationCategory destinationCategory, ValueRange range)
2099 {
2100     CSSCalcExpressionNodeParser parser(destinationCategory);
2101     auto expression = parser.parseCalc(tokens, function);
2102     if (!expression)
2103         return nullptr;
<a name="161" id="anc161"></a><span class="line-modified">2104     auto result = adoptRef(new CSSCalcValue(expression.releaseNonNull(), range != ValueRangeAll));</span>
<span class="line-added">2105     LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;CSSCalcValue::create &quot; &lt;&lt; *result);</span>
<span class="line-added">2106     return result;</span>
2107 }
2108 
2109 RefPtr&lt;CSSCalcValue&gt; CSSCalcValue::create(const CalculationValue&amp; value, const RenderStyle&amp; style)
2110 {
2111     auto expression = createCSS(value.expression(), style);
2112     if (!expression)
2113         return nullptr;
<a name="162" id="anc162"></a><span class="line-modified">2114     auto result = adoptRef(new CSSCalcValue(expression.releaseNonNull(), value.shouldClampToNonNegative()));</span>
<span class="line-added">2115     LOG_WITH_STREAM(Calc, stream &lt;&lt; &quot;CSSCalcValue::create from CalculationValue: &quot; &lt;&lt; *result);</span>
<span class="line-added">2116     return result;</span>
<span class="line-added">2117 }</span>
<span class="line-added">2118 </span>
<span class="line-added">2119 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, CalculationCategory category)</span>
<span class="line-added">2120 {</span>
<span class="line-added">2121     switch (category) {</span>
<span class="line-added">2122     case CalculationCategory::Number: ts &lt;&lt; &quot;number&quot;; break;</span>
<span class="line-added">2123     case CalculationCategory::Length: ts &lt;&lt; &quot;length&quot;; break;</span>
<span class="line-added">2124     case CalculationCategory::Percent: ts &lt;&lt; &quot;percent&quot;; break;</span>
<span class="line-added">2125     case CalculationCategory::PercentNumber: ts &lt;&lt; &quot;percent-number&quot;; break;</span>
<span class="line-added">2126     case CalculationCategory::PercentLength: ts &lt;&lt; &quot;percent-length&quot;; break;</span>
<span class="line-added">2127     case CalculationCategory::Angle: ts &lt;&lt; &quot;angle&quot;; break;</span>
<span class="line-added">2128     case CalculationCategory::Time: ts &lt;&lt; &quot;time&quot;; break;</span>
<span class="line-added">2129     case CalculationCategory::Frequency: ts &lt;&lt; &quot;frequency&quot;; break;</span>
<span class="line-added">2130     case CalculationCategory::Other: ts &lt;&lt; &quot;other&quot;; break;</span>
<span class="line-added">2131     }</span>
<span class="line-added">2132 </span>
<span class="line-added">2133     return ts;</span>
<span class="line-added">2134 }</span>
<span class="line-added">2135 </span>
<span class="line-added">2136 TextStream&amp; operator&lt;&lt;(TextStream&amp; ts, const CSSCalcValue&amp; value)</span>
<span class="line-added">2137 {</span>
<span class="line-added">2138     value.dump(ts);</span>
<span class="line-added">2139     return ts;</span>
2140 }
2141 
2142 } // namespace WebCore
<a name="163" id="anc163"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="163" type="hidden" />
</body>
</html>
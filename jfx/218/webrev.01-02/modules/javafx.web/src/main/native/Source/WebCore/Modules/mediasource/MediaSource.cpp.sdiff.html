<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/MediaSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../mediasession/WebMediaSessionManagerClient.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaSource.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/mediasource/MediaSource.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  84 
  85 URLRegistry* MediaSource::s_registry;
  86 
  87 void MediaSource::setRegistry(URLRegistry* registry)
  88 {
  89     ASSERT(!s_registry);
  90     s_registry = registry;
  91 }
  92 
  93 Ref&lt;MediaSource&gt; MediaSource::create(ScriptExecutionContext&amp; context)
  94 {
  95     auto mediaSource = adoptRef(*new MediaSource(context));
  96     mediaSource-&gt;suspendIfNeeded();
  97     return mediaSource;
  98 }
  99 
 100 MediaSource::MediaSource(ScriptExecutionContext&amp; context)
 101     : ActiveDOMObject(&amp;context)
 102     , m_duration(MediaTime::invalidTime())
 103     , m_pendingSeekTime(MediaTime::invalidTime())
<span class="line-modified"> 104     , m_asyncEventQueue(*this)</span>
 105 #if !RELEASE_LOG_DISABLED
 106     , m_logger(downcast&lt;Document&gt;(context).logger())
 107 #endif
 108 {
 109     m_sourceBuffers = SourceBufferList::create(scriptExecutionContext());
 110     m_activeSourceBuffers = SourceBufferList::create(scriptExecutionContext());
 111 }
 112 
 113 MediaSource::~MediaSource()
 114 {
 115     ALWAYS_LOG(LOGIDENTIFIER);
 116     ASSERT(isClosed());
 117 }
 118 
 119 void MediaSource::setPrivateAndOpen(Ref&lt;MediaSourcePrivate&gt;&amp;&amp; mediaSourcePrivate)
 120 {
 121     DEBUG_LOG(LOGIDENTIFIER);
 122     ASSERT(!m_private);
 123     ASSERT(m_mediaElement);
 124     m_private = WTFMove(mediaSourcePrivate);
 125 
 126     // 2.4.1 Attaching to a media element
 127     // https://rawgit.com/w3c/media-source/45627646344eea0170dd1cbc5a3d508ca751abb8/media-source-respec.html#mediasource-attach
 128 
 129     // ↳ If readyState is NOT set to &quot;closed&quot;
 130     //    Run the &quot;If the media data cannot be fetched at all, due to network errors, causing the user agent to give up trying
 131     //    to fetch the resource&quot; steps of the resource fetch algorithm&#39;s media data processing steps list.
 132     if (!isClosed()) {
<span class="line-modified"> 133         m_mediaElement-&gt;mediaLoadingFailedFatally(MediaPlayer::NetworkError);</span>
 134         return;
 135     }
 136 
 137     // ↳ Otherwise
 138     // 1. Set the media element&#39;s delaying-the-load-event-flag to false.
 139     m_mediaElement-&gt;setShouldDelayLoadEvent(false);
 140 
 141     // 2. Set the readyState attribute to &quot;open&quot;.
 142     // 3. Queue a task to fire a simple event named sourceopen at the MediaSource.
 143     setReadyState(ReadyState::Open);
 144 
 145     // 4. Continue the resource fetch algorithm by running the remaining &quot;Otherwise (mode is local)&quot; steps,
 146     // with these clarifications:
 147     // NOTE: This is handled in HTMLMediaElement.
 148 }
 149 
 150 void MediaSource::addedToRegistry()
 151 {
 152     DEBUG_LOG(LOGIDENTIFIER);
 153     setPendingActivity(*this);
</pre>
<hr />
<pre>
 226 
 227 void MediaSource::seekToTime(const MediaTime&amp; time)
 228 {
 229     if (isClosed())
 230         return;
 231 
 232     ALWAYS_LOG(LOGIDENTIFIER, time);
 233 
 234     // 2.4.3 Seeking
 235     // https://rawgit.com/w3c/media-source/45627646344eea0170dd1cbc5a3d508ca751abb8/media-source-respec.html#mediasource-seeking
 236 
 237     m_pendingSeekTime = time;
 238 
 239     // Run the following steps as part of the &quot;Wait until the user agent has established whether or not the
 240     // media data for the new playback position is available, and, if it is, until it has decoded enough data
 241     // to play back that position&quot; step of the seek algorithm:
 242     // ↳ If new playback position is not in any TimeRange of HTMLMediaElement.buffered
 243     if (!hasBufferedTime(time)) {
 244         // 1. If the HTMLMediaElement.readyState attribute is greater than HAVE_METADATA,
 245         // then set the HTMLMediaElement.readyState attribute to HAVE_METADATA.
<span class="line-modified"> 246         m_private-&gt;setReadyState(MediaPlayer::HaveMetadata);</span>
 247 
 248         // 2. The media element waits until an appendBuffer() or an appendStream() call causes the coded
 249         // frame processing algorithm to set the HTMLMediaElement.readyState attribute to a value greater
 250         // than HAVE_METADATA.
 251         m_private-&gt;waitForSeekCompleted();
 252         return;
 253     }
 254     // ↳ Otherwise
 255     // Continue
 256 
 257 // https://bugs.webkit.org/show_bug.cgi?id=125157 broke seek on MediaPlayerPrivateGStreamerMSE
 258 #if !USE(GSTREAMER)
 259     m_private-&gt;waitForSeekCompleted();
 260 #endif
 261     completeSeek();
 262 }
 263 
 264 void MediaSource::completeSeek()
 265 {
 266     if (isClosed())
</pre>
<hr />
<pre>
 409     if (found == notFound)
 410         return false;
 411 
 412     MediaTime localEnd = ranges-&gt;end(found);
 413     if (localEnd == duration)
 414         return true;
 415 
 416     return localEnd - currentTime &gt; currentTimeFudgeFactor();
 417 }
 418 
 419 void MediaSource::monitorSourceBuffers()
 420 {
 421     if (isClosed())
 422         return;
 423 
 424     // 2.4.4 SourceBuffer Monitoring
 425     // https://rawgit.com/w3c/media-source/45627646344eea0170dd1cbc5a3d508ca751abb8/media-source-respec.html#buffer-monitoring
 426 
 427     // Note, the behavior if activeSourceBuffers is empty is undefined.
 428     if (!m_activeSourceBuffers) {
<span class="line-modified"> 429         m_private-&gt;setReadyState(MediaPlayer::HaveNothing);</span>
 430         return;
 431     }
 432 
 433     // ↳ If the HTMLMediaElement.readyState attribute equals HAVE_NOTHING:
 434     if (mediaElement()-&gt;readyState() == HTMLMediaElement::HAVE_NOTHING) {
 435         // 1. Abort these steps.
 436         return;
 437     }
 438 
 439     // ↳ If HTMLMediaElement.buffered does not contain a TimeRange for the current playback position:
 440     if (!hasCurrentTime()) {
 441         // 1. Set the HTMLMediaElement.readyState attribute to HAVE_METADATA.
 442         // 2. If this is the first transition to HAVE_METADATA, then queue a task to fire a simple event
 443         // named loadedmetadata at the media element.
<span class="line-modified"> 444         m_private-&gt;setReadyState(MediaPlayer::HaveMetadata);</span>
 445 
 446         // 3. Abort these steps.
 447         return;
 448     }
 449 
 450     // ↳ If HTMLMediaElement.buffered contains a TimeRange that includes the current
 451     //  playback position and enough data to ensure uninterrupted playback:
 452     auto ranges = buffered();
 453     if (std::all_of(m_activeSourceBuffers-&gt;begin(), m_activeSourceBuffers-&gt;end(), [&amp;](auto&amp; sourceBuffer) {
 454         return sourceBuffer-&gt;canPlayThroughRange(*ranges);
 455     })) {
 456         // 1. Set the HTMLMediaElement.readyState attribute to HAVE_ENOUGH_DATA.
 457         // 2. Queue a task to fire a simple event named canplaythrough at the media element.
 458         // 3. Playback may resume at this point if it was previously suspended by a transition to HAVE_CURRENT_DATA.
<span class="line-modified"> 459         m_private-&gt;setReadyState(MediaPlayer::HaveEnoughData);</span>
 460 
 461         if (m_pendingSeekTime.isValid())
 462             completeSeek();
 463 
 464         // 4. Abort these steps.
 465         return;
 466     }
 467 
 468     // ↳ If HTMLMediaElement.buffered contains a TimeRange that includes the current playback
 469     //  position and some time beyond the current playback position, then run the following steps:
 470     if (hasFutureTime()) {
 471         // 1. Set the HTMLMediaElement.readyState attribute to HAVE_FUTURE_DATA.
 472         // 2. If the previous value of HTMLMediaElement.readyState was less than HAVE_FUTURE_DATA, then queue a task to fire a simple event named canplay at the media element.
 473         // 3. Playback may resume at this point if it was previously suspended by a transition to HAVE_CURRENT_DATA.
<span class="line-modified"> 474         m_private-&gt;setReadyState(MediaPlayer::HaveFutureData);</span>
 475 
 476         if (m_pendingSeekTime.isValid())
 477             completeSeek();
 478 
 479         // 4. Abort these steps.
 480         return;
 481     }
 482 
 483     // ↳ If HTMLMediaElement.buffered contains a TimeRange that ends at the current playback position and does not have a range covering the time immediately after the current position:
 484     // NOTE: Logically, !(all objects do not contain currentTime) == (some objects contain current time)
 485 
 486     // 1. Set the HTMLMediaElement.readyState attribute to HAVE_CURRENT_DATA.
 487     // 2. If this is the first transition to HAVE_CURRENT_DATA, then queue a task to fire a simple
 488     // event named loadeddata at the media element.
 489     // 3. Playback is suspended at this point since the media element doesn&#39;t have enough data to
 490     // advance the media timeline.
<span class="line-modified"> 491     m_private-&gt;setReadyState(MediaPlayer::HaveCurrentData);</span>
 492 
 493     if (m_pendingSeekTime.isValid())
 494         completeSeek();
 495 
 496     // 4. Abort these steps.
 497 }
 498 
 499 ExceptionOr&lt;void&gt; MediaSource::setDuration(double duration)
 500 {
 501     // 2.1 Attributes - Duration
 502     // https://www.w3.org/TR/2016/REC-media-source-20161117/#attributes
 503 
 504     ALWAYS_LOG(LOGIDENTIFIER, duration);
 505 
 506     // On setting, run the following steps:
 507     // 1. If the value being set is negative or NaN then throw a TypeError exception and abort these steps.
 508     if (duration &lt; 0.0 || std::isnan(duration))
 509         return Exception { TypeError };
 510 
 511     // 2. If the readyState attribute is not &quot;open&quot; then throw an InvalidStateError exception and abort these steps.
</pre>
<hr />
<pre>
 620         // the buffered attribute across all SourceBuffer objects in sourceBuffers.
 621         MediaTime maxEndTime;
 622         for (auto&amp; sourceBuffer : *m_sourceBuffers) {
 623             if (auto length = sourceBuffer-&gt;bufferedInternal().length())
 624                 maxEndTime = std::max(sourceBuffer-&gt;bufferedInternal().ranges().end(length - 1), maxEndTime);
 625         }
 626         setDurationInternal(maxEndTime);
 627 
 628         // 2. Notify the media element that it now has all of the media data.
 629         for (auto&amp; sourceBuffer : *m_sourceBuffers)
 630             sourceBuffer-&gt;trySignalAllSamplesEnqueued();
 631         m_private-&gt;markEndOfStream(MediaSourcePrivate::EosNoError);
 632     } else if (error == EndOfStreamError::Network) {
 633         // ↳ If error is set to &quot;network&quot;
 634         ASSERT(m_mediaElement);
 635         if (m_mediaElement-&gt;readyState() == HTMLMediaElement::HAVE_NOTHING) {
 636             //  ↳ If the HTMLMediaElement.readyState attribute equals HAVE_NOTHING
 637             //    Run the &quot;If the media data cannot be fetched at all, due to network errors, causing
 638             //    the user agent to give up trying to fetch the resource&quot; steps of the resource fetch algorithm.
 639             //    NOTE: This step is handled by HTMLMediaElement::mediaLoadingFailed().
<span class="line-modified"> 640             m_mediaElement-&gt;mediaLoadingFailed(MediaPlayer::NetworkError);</span>
 641         } else {
 642             //  ↳ If the HTMLMediaElement.readyState attribute is greater than HAVE_NOTHING
 643             //    Run the &quot;If the connection is interrupted after some media data has been received, causing the
 644             //    user agent to give up trying to fetch the resource&quot; steps of the resource fetch algorithm.
 645             //    NOTE: This step is handled by HTMLMediaElement::mediaLoadingFailedFatally().
<span class="line-modified"> 646             m_mediaElement-&gt;mediaLoadingFailedFatally(MediaPlayer::NetworkError);</span>
 647         }
 648     } else {
 649         // ↳ If error is set to &quot;decode&quot;
 650         ASSERT(error == EndOfStreamError::Decode);
 651         ASSERT(m_mediaElement);
 652         if (m_mediaElement-&gt;readyState() == HTMLMediaElement::HAVE_NOTHING) {
 653             //  ↳ If the HTMLMediaElement.readyState attribute equals HAVE_NOTHING
 654             //    Run the &quot;If the media data can be fetched but is found by inspection to be in an unsupported
 655             //    format, or can otherwise not be rendered at all&quot; steps of the resource fetch algorithm.
 656             //    NOTE: This step is handled by HTMLMediaElement::mediaLoadingFailed().
<span class="line-modified"> 657             m_mediaElement-&gt;mediaLoadingFailed(MediaPlayer::FormatError);</span>
 658         } else {
 659             //  ↳ If the HTMLMediaElement.readyState attribute is greater than HAVE_NOTHING
 660             //    Run the media data is corrupted steps of the resource fetch algorithm.
 661             //    NOTE: This step is handled by HTMLMediaElement::mediaLoadingFailedFatally().
<span class="line-modified"> 662             m_mediaElement-&gt;mediaLoadingFailedFatally(MediaPlayer::DecodeError);</span>
 663         }
 664     }
 665 }
 666 
 667 ExceptionOr&lt;Ref&lt;SourceBuffer&gt;&gt; MediaSource::addSourceBuffer(const String&amp; type)
 668 {
 669     DEBUG_LOG(LOGIDENTIFIER, type);
 670 
 671     // 2.2 http://www.w3.org/TR/media-source/#widl-MediaSource-addSourceBuffer-SourceBuffer-DOMString-type
 672     // When this method is invoked, the user agent must run the following steps:
 673 
 674     // 1. If type is an empty string then throw a TypeError exception and abort these steps.
 675     if (type.isEmpty())
 676         return Exception { TypeError };
 677 
 678     // 2. If type contains a MIME type that is not supported ..., then throw a
 679     // NotSupportedError exception and abort these steps.
 680     if (!isTypeSupported(type))
 681         return Exception { NotSupportedError };
 682 
</pre>
<hr />
<pre>
 719     return buffer;
 720 }
 721 
 722 ExceptionOr&lt;void&gt; MediaSource::removeSourceBuffer(SourceBuffer&amp; buffer)
 723 {
 724     DEBUG_LOG(LOGIDENTIFIER);
 725 
 726     Ref&lt;SourceBuffer&gt; protect(buffer);
 727 
 728     // 2. If sourceBuffer specifies an object that is not in sourceBuffers then
 729     // throw a NotFoundError exception and abort these steps.
 730     if (!m_sourceBuffers-&gt;length() || !m_sourceBuffers-&gt;contains(buffer))
 731         return Exception { NotFoundError };
 732 
 733     // 3. If the sourceBuffer.updating attribute equals true, then run the following steps: ...
 734     buffer.abortIfUpdating();
 735 
 736     ASSERT(scriptExecutionContext());
 737     if (!scriptExecutionContext()-&gt;activeDOMObjectsAreStopped()) {
 738         // 4. Let SourceBuffer audioTracks list equal the AudioTrackList object returned by sourceBuffer.audioTracks.
<span class="line-modified"> 739         auto&amp; audioTracks = buffer.audioTracks();</span>
 740 
 741         // 5. If the SourceBuffer audioTracks list is not empty, then run the following steps:
<span class="line-modified"> 742         if (audioTracks.length()) {</span>
 743             // 5.1 Let HTMLMediaElement audioTracks list equal the AudioTrackList object returned by the audioTracks
 744             // attribute on the HTMLMediaElement.
 745             // 5.2 Let the removed enabled audio track flag equal false.
 746             bool removedEnabledAudioTrack = false;
 747 
 748             // 5.3 For each AudioTrack object in the SourceBuffer audioTracks list, run the following steps:
<span class="line-modified"> 749             while (audioTracks.length()) {</span>
<span class="line-modified"> 750                 auto&amp; track = *audioTracks.lastItem();</span>
 751 
 752                 // 5.3.1 Set the sourceBuffer attribute on the AudioTrack object to null.
 753                 track.setSourceBuffer(nullptr);
 754 
 755                 // 5.3.2 If the enabled attribute on the AudioTrack object is true, then set the removed enabled
 756                 // audio track flag to true.
 757                 if (track.enabled())
 758                     removedEnabledAudioTrack = true;
 759 
 760                 // 5.3.3 Remove the AudioTrack object from the HTMLMediaElement audioTracks list.
 761                 // 5.3.4 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 762                 // cancelable, and that uses the TrackEvent interface, at the HTMLMediaElement audioTracks list.
 763                 if (mediaElement())
 764                     mediaElement()-&gt;removeAudioTrack(track);
 765 
 766                 // 5.3.5 Remove the AudioTrack object from the SourceBuffer audioTracks list.
 767                 // 5.3.6 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 768                 // cancelable, and that uses the TrackEvent interface, at the SourceBuffer audioTracks list.
<span class="line-modified"> 769                 audioTracks.remove(track);</span>
 770             }
 771 
 772             // 5.4 If the removed enabled audio track flag equals true, then queue a task to fire a simple event
 773             // named change at the HTMLMediaElement audioTracks list.
 774             if (removedEnabledAudioTrack)
 775                 mediaElement()-&gt;ensureAudioTracks().scheduleChangeEvent();
 776         }
 777 
 778         // 6. Let SourceBuffer videoTracks list equal the VideoTrackList object returned by sourceBuffer.videoTracks.
<span class="line-modified"> 779         auto&amp; videoTracks = buffer.videoTracks();</span>
 780 
 781         // 7. If the SourceBuffer videoTracks list is not empty, then run the following steps:
<span class="line-modified"> 782         if (videoTracks.length()) {</span>
 783             // 7.1 Let HTMLMediaElement videoTracks list equal the VideoTrackList object returned by the videoTracks
 784             // attribute on the HTMLMediaElement.
 785             // 7.2 Let the removed selected video track flag equal false.
 786             bool removedSelectedVideoTrack = false;
 787 
 788             // 7.3 For each VideoTrack object in the SourceBuffer videoTracks list, run the following steps:
<span class="line-modified"> 789             while (videoTracks.length()) {</span>
<span class="line-modified"> 790                 auto&amp; track = *videoTracks.lastItem();</span>
 791 
 792                 // 7.3.1 Set the sourceBuffer attribute on the VideoTrack object to null.
 793                 track.setSourceBuffer(nullptr);
 794 
 795                 // 7.3.2 If the selected attribute on the VideoTrack object is true, then set the removed selected
 796                 // video track flag to true.
 797                 if (track.selected())
 798                     removedSelectedVideoTrack = true;
 799 
 800                 // 7.3.3 Remove the VideoTrack object from the HTMLMediaElement videoTracks list.
 801                 // 7.3.4 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 802                 // cancelable, and that uses the TrackEvent interface, at the HTMLMediaElement videoTracks list.
 803                 if (mediaElement())
 804                     mediaElement()-&gt;removeVideoTrack(track);
 805 
 806                 // 7.3.5 Remove the VideoTrack object from the SourceBuffer videoTracks list.
 807                 // 7.3.6 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 808                 // cancelable, and that uses the TrackEvent interface, at the SourceBuffer videoTracks list.
<span class="line-modified"> 809                 videoTracks.remove(track);</span>
 810             }
 811 
 812             // 7.4 If the removed selected video track flag equals true, then queue a task to fire a simple event
 813             // named change at the HTMLMediaElement videoTracks list.
 814             if (removedSelectedVideoTrack)
 815                 mediaElement()-&gt;ensureVideoTracks().scheduleChangeEvent();
 816         }
 817 
 818         // 8. Let SourceBuffer textTracks list equal the TextTrackList object returned by sourceBuffer.textTracks.
<span class="line-modified"> 819         auto&amp; textTracks = buffer.textTracks();</span>
 820 
 821         // 9. If the SourceBuffer textTracks list is not empty, then run the following steps:
<span class="line-modified"> 822         if (textTracks.length()) {</span>
 823             // 9.1 Let HTMLMediaElement textTracks list equal the TextTrackList object returned by the textTracks
 824             // attribute on the HTMLMediaElement.
 825             // 9.2 Let the removed enabled text track flag equal false.
 826             bool removedEnabledTextTrack = false;
 827 
 828             // 9.3 For each TextTrack object in the SourceBuffer textTracks list, run the following steps:
<span class="line-modified"> 829             while (textTracks.length()) {</span>
<span class="line-modified"> 830                 auto&amp; track = *textTracks.lastItem();</span>
 831 
 832                 // 9.3.1 Set the sourceBuffer attribute on the TextTrack object to null.
 833                 track.setSourceBuffer(nullptr);
 834 
 835                 // 9.3.2 If the mode attribute on the TextTrack object is set to &quot;showing&quot; or &quot;hidden&quot;, then
 836                 // set the removed enabled text track flag to true.
 837                 if (track.mode() == TextTrack::Mode::Showing || track.mode() == TextTrack::Mode::Hidden)
 838                     removedEnabledTextTrack = true;
 839 
 840                 // 9.3.3 Remove the TextTrack object from the HTMLMediaElement textTracks list.
 841                 // 9.3.4 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 842                 // cancelable, and that uses the TrackEvent interface, at the HTMLMediaElement textTracks list.
 843                 if (mediaElement())
 844                     mediaElement()-&gt;removeTextTrack(track);
 845 
 846                 // 9.3.5 Remove the TextTrack object from the SourceBuffer textTracks list.
 847                 // 9.3.6 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 848                 // cancelable, and that uses the TrackEvent interface, at the SourceBuffer textTracks list.
<span class="line-modified"> 849                 textTracks.remove(track);</span>
 850             }
 851 
 852             // 9.4 If the removed enabled text track flag equals true, then queue a task to fire a simple event
 853             // named change at the HTMLMediaElement textTracks list.
 854             if (removedEnabledTextTrack)
 855                 mediaElement()-&gt;ensureTextTracks().scheduleChangeEvent();
 856         }
 857     }
 858 
 859     // 10. If sourceBuffer is in activeSourceBuffers, then remove sourceBuffer from activeSourceBuffers ...
 860     m_activeSourceBuffers-&gt;remove(buffer);
 861 
 862     // 11. Remove sourceBuffer from sourceBuffers and fire a removesourcebuffer event
 863     // on that object.
 864     m_sourceBuffers-&gt;remove(buffer);
 865 
 866     // 12. Destroy all resources for sourceBuffer.
 867     buffer.removedFromMediaSource();
 868 
 869     return { };
</pre>
<hr />
<pre>
 877     if (type.isNull() || type.isEmpty())
 878         return false;
 879 
 880     ContentType contentType(type);
 881     String codecs = contentType.parameter(&quot;codecs&quot;);
 882 
 883     // 2. If type does not contain a valid MIME type string, then return false.
 884     if (contentType.containerType().isEmpty())
 885         return false;
 886 
 887     // 3. If type contains a media type or media subtype that the MediaSource does not support, then return false.
 888     // 4. If type contains at a codec that the MediaSource does not support, then return false.
 889     // 5. If the MediaSource does not support the specified combination of media type, media subtype, and codecs then return false.
 890     // 6. Return true.
 891     MediaEngineSupportParameters parameters;
 892     parameters.type = contentType;
 893     parameters.isMediaSource = true;
 894     MediaPlayer::SupportsType supported = MediaPlayer::supportsType(parameters);
 895 
 896     if (codecs.isEmpty())
<span class="line-modified"> 897         return supported != MediaPlayer::IsNotSupported;</span>
 898 
<span class="line-modified"> 899     return supported == MediaPlayer::IsSupported;</span>
 900 }
 901 
 902 bool MediaSource::isOpen() const
 903 {
 904     return readyState() == ReadyState::Open;
 905 }
 906 
 907 bool MediaSource::isClosed() const
 908 {
 909     return readyState() == ReadyState::Closed;
 910 }
 911 
 912 bool MediaSource::isEnded() const
 913 {
 914     return readyState() == ReadyState::Ended;
 915 }
 916 
 917 void MediaSource::detachFromElement(HTMLMediaElement&amp; element)
 918 {
 919     ALWAYS_LOG(LOGIDENTIFIER);
</pre>
<hr />
<pre>
 939     // 6. Queue a task to fire a simple event named removesourcebuffer at sourceBuffers.
 940     while (m_sourceBuffers-&gt;length())
 941         removeSourceBuffer(*m_sourceBuffers-&gt;item(0));
 942 
 943     m_private = nullptr;
 944     m_mediaElement = nullptr;
 945 }
 946 
 947 void MediaSource::sourceBufferDidChangeActiveState(SourceBuffer&amp;, bool)
 948 {
 949     regenerateActiveSourceBuffers();
 950 }
 951 
 952 bool MediaSource::attachToElement(HTMLMediaElement&amp; element)
 953 {
 954     if (m_mediaElement)
 955         return false;
 956 
 957     ASSERT(isClosed());
 958 
<span class="line-modified"> 959     m_mediaElement = &amp;element;</span>
 960     return true;
 961 }
 962 
 963 void MediaSource::openIfInEndedState()
 964 {
 965     if (m_readyState != ReadyState::Ended)
 966         return;
 967 
 968     ALWAYS_LOG(LOGIDENTIFIER);
 969 
 970     setReadyState(ReadyState::Open);
 971     m_private-&gt;unmarkEndOfStream();
 972 }
 973 
 974 bool MediaSource::hasPendingActivity() const
 975 {
<span class="line-modified"> 976     return m_private || m_asyncEventQueue.hasPendingEvents()</span>
 977         || ActiveDOMObject::hasPendingActivity();
 978 }
 979 
<span class="line-removed"> 980 void MediaSource::suspend(ReasonForSuspension reason)</span>
<span class="line-removed"> 981 {</span>
<span class="line-removed"> 982     ALWAYS_LOG(LOGIDENTIFIER, static_cast&lt;int&gt;(reason));</span>
<span class="line-removed"> 983 </span>
<span class="line-removed"> 984     switch (reason) {</span>
<span class="line-removed"> 985     case ReasonForSuspension::PageCache:</span>
<span class="line-removed"> 986     case ReasonForSuspension::PageWillBeSuspended:</span>
<span class="line-removed"> 987         m_asyncEventQueue.suspend();</span>
<span class="line-removed"> 988         break;</span>
<span class="line-removed"> 989     case ReasonForSuspension::JavaScriptDebuggerPaused:</span>
<span class="line-removed"> 990     case ReasonForSuspension::WillDeferLoading:</span>
<span class="line-removed"> 991         // Do nothing, we don&#39;t pause media playback in these cases.</span>
<span class="line-removed"> 992         break;</span>
<span class="line-removed"> 993     }</span>
<span class="line-removed"> 994 }</span>
<span class="line-removed"> 995 </span>
<span class="line-removed"> 996 void MediaSource::resume()</span>
<span class="line-removed"> 997 {</span>
<span class="line-removed"> 998     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-removed"> 999 </span>
<span class="line-removed">1000     m_asyncEventQueue.resume();</span>
<span class="line-removed">1001 }</span>
<span class="line-removed">1002 </span>
1003 void MediaSource::stop()
1004 {
1005     ALWAYS_LOG(LOGIDENTIFIER);
1006 
<span class="line-removed">1007     m_asyncEventQueue.close();</span>
1008     if (m_mediaElement)
1009         m_mediaElement-&gt;detachMediaSource();
1010     m_readyState = ReadyState::Closed;
1011     m_private = nullptr;
1012 }
1013 
<span class="line-removed">1014 bool MediaSource::canSuspendForDocumentSuspension() const</span>
<span class="line-removed">1015 {</span>
<span class="line-removed">1016     return isClosed() &amp;&amp; !m_asyncEventQueue.hasPendingEvents();</span>
<span class="line-removed">1017 }</span>
<span class="line-removed">1018 </span>
1019 const char* MediaSource::activeDOMObjectName() const
1020 {
1021     return &quot;MediaSource&quot;;
1022 }
1023 
1024 void MediaSource::onReadyStateChange(ReadyState oldState, ReadyState newState)
1025 {
1026     ALWAYS_LOG(LOGIDENTIFIER, &quot;old state = &quot;, oldState, &quot;, new state = &quot;, newState);
1027 
1028     for (auto&amp; buffer : *m_sourceBuffers)
1029         buffer-&gt;readyStateChanged();
1030 
1031     if (isOpen()) {
1032         scheduleEvent(eventNames().sourceopenEvent);
1033         return;
1034     }
1035 
1036     if (oldState == ReadyState::Open &amp;&amp; newState == ReadyState::Ended) {
1037         scheduleEvent(eventNames().sourceendedEvent);
1038         return;
</pre>
<hr />
<pre>
1063         // a NotSupportedError exception and abort these steps.
1064         return Exception { NotSupportedError };
1065     case MediaSourcePrivate::ReachedIdLimit:
1066         // 2.2 https://dvcs.w3.org/hg/html-media/raw-file/default/media-source/media-source.html#widl-MediaSource-addSourceBuffer-SourceBuffer-DOMString-type
1067         // Step 3: If the user agent can&#39;t handle any more SourceBuffer objects then throw
1068         // a QuotaExceededError exception and abort these steps.
1069         return Exception { QuotaExceededError };
1070     }
1071 
1072     ASSERT_NOT_REACHED();
1073     return Exception { QuotaExceededError };
1074 }
1075 
1076 void MediaSource::scheduleEvent(const AtomString&amp; eventName)
1077 {
1078     DEBUG_LOG(LOGIDENTIFIER, &quot;scheduling &#39;&quot;, eventName, &quot;&#39;&quot;);
1079 
1080     auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::No);
1081     event-&gt;setTarget(this);
1082 
<span class="line-modified">1083     m_asyncEventQueue.enqueueEvent(WTFMove(event));</span>
1084 }
1085 
1086 ScriptExecutionContext* MediaSource::scriptExecutionContext() const
1087 {
1088     return ActiveDOMObject::scriptExecutionContext();
1089 }
1090 
1091 EventTargetInterface MediaSource::eventTargetInterface() const
1092 {
1093     return MediaSourceEventTargetInterfaceType;
1094 }
1095 
1096 URLRegistry&amp; MediaSource::registry() const
1097 {
1098     return MediaSourceRegistry::registry();
1099 }
1100 
1101 void MediaSource::regenerateActiveSourceBuffers()
1102 {
1103     Vector&lt;RefPtr&lt;SourceBuffer&gt;&gt; newList;
</pre>
</td>
<td>
<hr />
<pre>
  84 
  85 URLRegistry* MediaSource::s_registry;
  86 
  87 void MediaSource::setRegistry(URLRegistry* registry)
  88 {
  89     ASSERT(!s_registry);
  90     s_registry = registry;
  91 }
  92 
  93 Ref&lt;MediaSource&gt; MediaSource::create(ScriptExecutionContext&amp; context)
  94 {
  95     auto mediaSource = adoptRef(*new MediaSource(context));
  96     mediaSource-&gt;suspendIfNeeded();
  97     return mediaSource;
  98 }
  99 
 100 MediaSource::MediaSource(ScriptExecutionContext&amp; context)
 101     : ActiveDOMObject(&amp;context)
 102     , m_duration(MediaTime::invalidTime())
 103     , m_pendingSeekTime(MediaTime::invalidTime())
<span class="line-modified"> 104     , m_asyncEventQueue(MainThreadGenericEventQueue::create(*this))</span>
 105 #if !RELEASE_LOG_DISABLED
 106     , m_logger(downcast&lt;Document&gt;(context).logger())
 107 #endif
 108 {
 109     m_sourceBuffers = SourceBufferList::create(scriptExecutionContext());
 110     m_activeSourceBuffers = SourceBufferList::create(scriptExecutionContext());
 111 }
 112 
 113 MediaSource::~MediaSource()
 114 {
 115     ALWAYS_LOG(LOGIDENTIFIER);
 116     ASSERT(isClosed());
 117 }
 118 
 119 void MediaSource::setPrivateAndOpen(Ref&lt;MediaSourcePrivate&gt;&amp;&amp; mediaSourcePrivate)
 120 {
 121     DEBUG_LOG(LOGIDENTIFIER);
 122     ASSERT(!m_private);
 123     ASSERT(m_mediaElement);
 124     m_private = WTFMove(mediaSourcePrivate);
 125 
 126     // 2.4.1 Attaching to a media element
 127     // https://rawgit.com/w3c/media-source/45627646344eea0170dd1cbc5a3d508ca751abb8/media-source-respec.html#mediasource-attach
 128 
 129     // ↳ If readyState is NOT set to &quot;closed&quot;
 130     //    Run the &quot;If the media data cannot be fetched at all, due to network errors, causing the user agent to give up trying
 131     //    to fetch the resource&quot; steps of the resource fetch algorithm&#39;s media data processing steps list.
 132     if (!isClosed()) {
<span class="line-modified"> 133         m_mediaElement-&gt;mediaLoadingFailedFatally(MediaPlayer::NetworkState::NetworkError);</span>
 134         return;
 135     }
 136 
 137     // ↳ Otherwise
 138     // 1. Set the media element&#39;s delaying-the-load-event-flag to false.
 139     m_mediaElement-&gt;setShouldDelayLoadEvent(false);
 140 
 141     // 2. Set the readyState attribute to &quot;open&quot;.
 142     // 3. Queue a task to fire a simple event named sourceopen at the MediaSource.
 143     setReadyState(ReadyState::Open);
 144 
 145     // 4. Continue the resource fetch algorithm by running the remaining &quot;Otherwise (mode is local)&quot; steps,
 146     // with these clarifications:
 147     // NOTE: This is handled in HTMLMediaElement.
 148 }
 149 
 150 void MediaSource::addedToRegistry()
 151 {
 152     DEBUG_LOG(LOGIDENTIFIER);
 153     setPendingActivity(*this);
</pre>
<hr />
<pre>
 226 
 227 void MediaSource::seekToTime(const MediaTime&amp; time)
 228 {
 229     if (isClosed())
 230         return;
 231 
 232     ALWAYS_LOG(LOGIDENTIFIER, time);
 233 
 234     // 2.4.3 Seeking
 235     // https://rawgit.com/w3c/media-source/45627646344eea0170dd1cbc5a3d508ca751abb8/media-source-respec.html#mediasource-seeking
 236 
 237     m_pendingSeekTime = time;
 238 
 239     // Run the following steps as part of the &quot;Wait until the user agent has established whether or not the
 240     // media data for the new playback position is available, and, if it is, until it has decoded enough data
 241     // to play back that position&quot; step of the seek algorithm:
 242     // ↳ If new playback position is not in any TimeRange of HTMLMediaElement.buffered
 243     if (!hasBufferedTime(time)) {
 244         // 1. If the HTMLMediaElement.readyState attribute is greater than HAVE_METADATA,
 245         // then set the HTMLMediaElement.readyState attribute to HAVE_METADATA.
<span class="line-modified"> 246         m_private-&gt;setReadyState(MediaPlayer::ReadyState::HaveMetadata);</span>
 247 
 248         // 2. The media element waits until an appendBuffer() or an appendStream() call causes the coded
 249         // frame processing algorithm to set the HTMLMediaElement.readyState attribute to a value greater
 250         // than HAVE_METADATA.
 251         m_private-&gt;waitForSeekCompleted();
 252         return;
 253     }
 254     // ↳ Otherwise
 255     // Continue
 256 
 257 // https://bugs.webkit.org/show_bug.cgi?id=125157 broke seek on MediaPlayerPrivateGStreamerMSE
 258 #if !USE(GSTREAMER)
 259     m_private-&gt;waitForSeekCompleted();
 260 #endif
 261     completeSeek();
 262 }
 263 
 264 void MediaSource::completeSeek()
 265 {
 266     if (isClosed())
</pre>
<hr />
<pre>
 409     if (found == notFound)
 410         return false;
 411 
 412     MediaTime localEnd = ranges-&gt;end(found);
 413     if (localEnd == duration)
 414         return true;
 415 
 416     return localEnd - currentTime &gt; currentTimeFudgeFactor();
 417 }
 418 
 419 void MediaSource::monitorSourceBuffers()
 420 {
 421     if (isClosed())
 422         return;
 423 
 424     // 2.4.4 SourceBuffer Monitoring
 425     // https://rawgit.com/w3c/media-source/45627646344eea0170dd1cbc5a3d508ca751abb8/media-source-respec.html#buffer-monitoring
 426 
 427     // Note, the behavior if activeSourceBuffers is empty is undefined.
 428     if (!m_activeSourceBuffers) {
<span class="line-modified"> 429         m_private-&gt;setReadyState(MediaPlayer::ReadyState::HaveNothing);</span>
 430         return;
 431     }
 432 
 433     // ↳ If the HTMLMediaElement.readyState attribute equals HAVE_NOTHING:
 434     if (mediaElement()-&gt;readyState() == HTMLMediaElement::HAVE_NOTHING) {
 435         // 1. Abort these steps.
 436         return;
 437     }
 438 
 439     // ↳ If HTMLMediaElement.buffered does not contain a TimeRange for the current playback position:
 440     if (!hasCurrentTime()) {
 441         // 1. Set the HTMLMediaElement.readyState attribute to HAVE_METADATA.
 442         // 2. If this is the first transition to HAVE_METADATA, then queue a task to fire a simple event
 443         // named loadedmetadata at the media element.
<span class="line-modified"> 444         m_private-&gt;setReadyState(MediaPlayer::ReadyState::HaveMetadata);</span>
 445 
 446         // 3. Abort these steps.
 447         return;
 448     }
 449 
 450     // ↳ If HTMLMediaElement.buffered contains a TimeRange that includes the current
 451     //  playback position and enough data to ensure uninterrupted playback:
 452     auto ranges = buffered();
 453     if (std::all_of(m_activeSourceBuffers-&gt;begin(), m_activeSourceBuffers-&gt;end(), [&amp;](auto&amp; sourceBuffer) {
 454         return sourceBuffer-&gt;canPlayThroughRange(*ranges);
 455     })) {
 456         // 1. Set the HTMLMediaElement.readyState attribute to HAVE_ENOUGH_DATA.
 457         // 2. Queue a task to fire a simple event named canplaythrough at the media element.
 458         // 3. Playback may resume at this point if it was previously suspended by a transition to HAVE_CURRENT_DATA.
<span class="line-modified"> 459         m_private-&gt;setReadyState(MediaPlayer::ReadyState::HaveEnoughData);</span>
 460 
 461         if (m_pendingSeekTime.isValid())
 462             completeSeek();
 463 
 464         // 4. Abort these steps.
 465         return;
 466     }
 467 
 468     // ↳ If HTMLMediaElement.buffered contains a TimeRange that includes the current playback
 469     //  position and some time beyond the current playback position, then run the following steps:
 470     if (hasFutureTime()) {
 471         // 1. Set the HTMLMediaElement.readyState attribute to HAVE_FUTURE_DATA.
 472         // 2. If the previous value of HTMLMediaElement.readyState was less than HAVE_FUTURE_DATA, then queue a task to fire a simple event named canplay at the media element.
 473         // 3. Playback may resume at this point if it was previously suspended by a transition to HAVE_CURRENT_DATA.
<span class="line-modified"> 474         m_private-&gt;setReadyState(MediaPlayer::ReadyState::HaveFutureData);</span>
 475 
 476         if (m_pendingSeekTime.isValid())
 477             completeSeek();
 478 
 479         // 4. Abort these steps.
 480         return;
 481     }
 482 
 483     // ↳ If HTMLMediaElement.buffered contains a TimeRange that ends at the current playback position and does not have a range covering the time immediately after the current position:
 484     // NOTE: Logically, !(all objects do not contain currentTime) == (some objects contain current time)
 485 
 486     // 1. Set the HTMLMediaElement.readyState attribute to HAVE_CURRENT_DATA.
 487     // 2. If this is the first transition to HAVE_CURRENT_DATA, then queue a task to fire a simple
 488     // event named loadeddata at the media element.
 489     // 3. Playback is suspended at this point since the media element doesn&#39;t have enough data to
 490     // advance the media timeline.
<span class="line-modified"> 491     m_private-&gt;setReadyState(MediaPlayer::ReadyState::HaveCurrentData);</span>
 492 
 493     if (m_pendingSeekTime.isValid())
 494         completeSeek();
 495 
 496     // 4. Abort these steps.
 497 }
 498 
 499 ExceptionOr&lt;void&gt; MediaSource::setDuration(double duration)
 500 {
 501     // 2.1 Attributes - Duration
 502     // https://www.w3.org/TR/2016/REC-media-source-20161117/#attributes
 503 
 504     ALWAYS_LOG(LOGIDENTIFIER, duration);
 505 
 506     // On setting, run the following steps:
 507     // 1. If the value being set is negative or NaN then throw a TypeError exception and abort these steps.
 508     if (duration &lt; 0.0 || std::isnan(duration))
 509         return Exception { TypeError };
 510 
 511     // 2. If the readyState attribute is not &quot;open&quot; then throw an InvalidStateError exception and abort these steps.
</pre>
<hr />
<pre>
 620         // the buffered attribute across all SourceBuffer objects in sourceBuffers.
 621         MediaTime maxEndTime;
 622         for (auto&amp; sourceBuffer : *m_sourceBuffers) {
 623             if (auto length = sourceBuffer-&gt;bufferedInternal().length())
 624                 maxEndTime = std::max(sourceBuffer-&gt;bufferedInternal().ranges().end(length - 1), maxEndTime);
 625         }
 626         setDurationInternal(maxEndTime);
 627 
 628         // 2. Notify the media element that it now has all of the media data.
 629         for (auto&amp; sourceBuffer : *m_sourceBuffers)
 630             sourceBuffer-&gt;trySignalAllSamplesEnqueued();
 631         m_private-&gt;markEndOfStream(MediaSourcePrivate::EosNoError);
 632     } else if (error == EndOfStreamError::Network) {
 633         // ↳ If error is set to &quot;network&quot;
 634         ASSERT(m_mediaElement);
 635         if (m_mediaElement-&gt;readyState() == HTMLMediaElement::HAVE_NOTHING) {
 636             //  ↳ If the HTMLMediaElement.readyState attribute equals HAVE_NOTHING
 637             //    Run the &quot;If the media data cannot be fetched at all, due to network errors, causing
 638             //    the user agent to give up trying to fetch the resource&quot; steps of the resource fetch algorithm.
 639             //    NOTE: This step is handled by HTMLMediaElement::mediaLoadingFailed().
<span class="line-modified"> 640             m_mediaElement-&gt;mediaLoadingFailed(MediaPlayer::NetworkState::NetworkError);</span>
 641         } else {
 642             //  ↳ If the HTMLMediaElement.readyState attribute is greater than HAVE_NOTHING
 643             //    Run the &quot;If the connection is interrupted after some media data has been received, causing the
 644             //    user agent to give up trying to fetch the resource&quot; steps of the resource fetch algorithm.
 645             //    NOTE: This step is handled by HTMLMediaElement::mediaLoadingFailedFatally().
<span class="line-modified"> 646             m_mediaElement-&gt;mediaLoadingFailedFatally(MediaPlayer::NetworkState::NetworkError);</span>
 647         }
 648     } else {
 649         // ↳ If error is set to &quot;decode&quot;
 650         ASSERT(error == EndOfStreamError::Decode);
 651         ASSERT(m_mediaElement);
 652         if (m_mediaElement-&gt;readyState() == HTMLMediaElement::HAVE_NOTHING) {
 653             //  ↳ If the HTMLMediaElement.readyState attribute equals HAVE_NOTHING
 654             //    Run the &quot;If the media data can be fetched but is found by inspection to be in an unsupported
 655             //    format, or can otherwise not be rendered at all&quot; steps of the resource fetch algorithm.
 656             //    NOTE: This step is handled by HTMLMediaElement::mediaLoadingFailed().
<span class="line-modified"> 657             m_mediaElement-&gt;mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
 658         } else {
 659             //  ↳ If the HTMLMediaElement.readyState attribute is greater than HAVE_NOTHING
 660             //    Run the media data is corrupted steps of the resource fetch algorithm.
 661             //    NOTE: This step is handled by HTMLMediaElement::mediaLoadingFailedFatally().
<span class="line-modified"> 662             m_mediaElement-&gt;mediaLoadingFailedFatally(MediaPlayer::NetworkState::DecodeError);</span>
 663         }
 664     }
 665 }
 666 
 667 ExceptionOr&lt;Ref&lt;SourceBuffer&gt;&gt; MediaSource::addSourceBuffer(const String&amp; type)
 668 {
 669     DEBUG_LOG(LOGIDENTIFIER, type);
 670 
 671     // 2.2 http://www.w3.org/TR/media-source/#widl-MediaSource-addSourceBuffer-SourceBuffer-DOMString-type
 672     // When this method is invoked, the user agent must run the following steps:
 673 
 674     // 1. If type is an empty string then throw a TypeError exception and abort these steps.
 675     if (type.isEmpty())
 676         return Exception { TypeError };
 677 
 678     // 2. If type contains a MIME type that is not supported ..., then throw a
 679     // NotSupportedError exception and abort these steps.
 680     if (!isTypeSupported(type))
 681         return Exception { NotSupportedError };
 682 
</pre>
<hr />
<pre>
 719     return buffer;
 720 }
 721 
 722 ExceptionOr&lt;void&gt; MediaSource::removeSourceBuffer(SourceBuffer&amp; buffer)
 723 {
 724     DEBUG_LOG(LOGIDENTIFIER);
 725 
 726     Ref&lt;SourceBuffer&gt; protect(buffer);
 727 
 728     // 2. If sourceBuffer specifies an object that is not in sourceBuffers then
 729     // throw a NotFoundError exception and abort these steps.
 730     if (!m_sourceBuffers-&gt;length() || !m_sourceBuffers-&gt;contains(buffer))
 731         return Exception { NotFoundError };
 732 
 733     // 3. If the sourceBuffer.updating attribute equals true, then run the following steps: ...
 734     buffer.abortIfUpdating();
 735 
 736     ASSERT(scriptExecutionContext());
 737     if (!scriptExecutionContext()-&gt;activeDOMObjectsAreStopped()) {
 738         // 4. Let SourceBuffer audioTracks list equal the AudioTrackList object returned by sourceBuffer.audioTracks.
<span class="line-modified"> 739         auto* audioTracks = buffer.audioTracksIfExists();</span>
 740 
 741         // 5. If the SourceBuffer audioTracks list is not empty, then run the following steps:
<span class="line-modified"> 742         if (audioTracks &amp;&amp; audioTracks-&gt;length()) {</span>
 743             // 5.1 Let HTMLMediaElement audioTracks list equal the AudioTrackList object returned by the audioTracks
 744             // attribute on the HTMLMediaElement.
 745             // 5.2 Let the removed enabled audio track flag equal false.
 746             bool removedEnabledAudioTrack = false;
 747 
 748             // 5.3 For each AudioTrack object in the SourceBuffer audioTracks list, run the following steps:
<span class="line-modified"> 749             while (audioTracks-&gt;length()) {</span>
<span class="line-modified"> 750                 auto&amp; track = *audioTracks-&gt;lastItem();</span>
 751 
 752                 // 5.3.1 Set the sourceBuffer attribute on the AudioTrack object to null.
 753                 track.setSourceBuffer(nullptr);
 754 
 755                 // 5.3.2 If the enabled attribute on the AudioTrack object is true, then set the removed enabled
 756                 // audio track flag to true.
 757                 if (track.enabled())
 758                     removedEnabledAudioTrack = true;
 759 
 760                 // 5.3.3 Remove the AudioTrack object from the HTMLMediaElement audioTracks list.
 761                 // 5.3.4 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 762                 // cancelable, and that uses the TrackEvent interface, at the HTMLMediaElement audioTracks list.
 763                 if (mediaElement())
 764                     mediaElement()-&gt;removeAudioTrack(track);
 765 
 766                 // 5.3.5 Remove the AudioTrack object from the SourceBuffer audioTracks list.
 767                 // 5.3.6 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 768                 // cancelable, and that uses the TrackEvent interface, at the SourceBuffer audioTracks list.
<span class="line-modified"> 769                 audioTracks-&gt;remove(track);</span>
 770             }
 771 
 772             // 5.4 If the removed enabled audio track flag equals true, then queue a task to fire a simple event
 773             // named change at the HTMLMediaElement audioTracks list.
 774             if (removedEnabledAudioTrack)
 775                 mediaElement()-&gt;ensureAudioTracks().scheduleChangeEvent();
 776         }
 777 
 778         // 6. Let SourceBuffer videoTracks list equal the VideoTrackList object returned by sourceBuffer.videoTracks.
<span class="line-modified"> 779         auto* videoTracks = buffer.videoTracksIfExists();</span>
 780 
 781         // 7. If the SourceBuffer videoTracks list is not empty, then run the following steps:
<span class="line-modified"> 782         if (videoTracks &amp;&amp; videoTracks-&gt;length()) {</span>
 783             // 7.1 Let HTMLMediaElement videoTracks list equal the VideoTrackList object returned by the videoTracks
 784             // attribute on the HTMLMediaElement.
 785             // 7.2 Let the removed selected video track flag equal false.
 786             bool removedSelectedVideoTrack = false;
 787 
 788             // 7.3 For each VideoTrack object in the SourceBuffer videoTracks list, run the following steps:
<span class="line-modified"> 789             while (videoTracks-&gt;length()) {</span>
<span class="line-modified"> 790                 auto&amp; track = *videoTracks-&gt;lastItem();</span>
 791 
 792                 // 7.3.1 Set the sourceBuffer attribute on the VideoTrack object to null.
 793                 track.setSourceBuffer(nullptr);
 794 
 795                 // 7.3.2 If the selected attribute on the VideoTrack object is true, then set the removed selected
 796                 // video track flag to true.
 797                 if (track.selected())
 798                     removedSelectedVideoTrack = true;
 799 
 800                 // 7.3.3 Remove the VideoTrack object from the HTMLMediaElement videoTracks list.
 801                 // 7.3.4 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 802                 // cancelable, and that uses the TrackEvent interface, at the HTMLMediaElement videoTracks list.
 803                 if (mediaElement())
 804                     mediaElement()-&gt;removeVideoTrack(track);
 805 
 806                 // 7.3.5 Remove the VideoTrack object from the SourceBuffer videoTracks list.
 807                 // 7.3.6 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 808                 // cancelable, and that uses the TrackEvent interface, at the SourceBuffer videoTracks list.
<span class="line-modified"> 809                 videoTracks-&gt;remove(track);</span>
 810             }
 811 
 812             // 7.4 If the removed selected video track flag equals true, then queue a task to fire a simple event
 813             // named change at the HTMLMediaElement videoTracks list.
 814             if (removedSelectedVideoTrack)
 815                 mediaElement()-&gt;ensureVideoTracks().scheduleChangeEvent();
 816         }
 817 
 818         // 8. Let SourceBuffer textTracks list equal the TextTrackList object returned by sourceBuffer.textTracks.
<span class="line-modified"> 819         auto* textTracks = buffer.textTracksIfExists();</span>
 820 
 821         // 9. If the SourceBuffer textTracks list is not empty, then run the following steps:
<span class="line-modified"> 822         if (textTracks &amp;&amp; textTracks-&gt;length()) {</span>
 823             // 9.1 Let HTMLMediaElement textTracks list equal the TextTrackList object returned by the textTracks
 824             // attribute on the HTMLMediaElement.
 825             // 9.2 Let the removed enabled text track flag equal false.
 826             bool removedEnabledTextTrack = false;
 827 
 828             // 9.3 For each TextTrack object in the SourceBuffer textTracks list, run the following steps:
<span class="line-modified"> 829             while (textTracks-&gt;length()) {</span>
<span class="line-modified"> 830                 auto&amp; track = *textTracks-&gt;lastItem();</span>
 831 
 832                 // 9.3.1 Set the sourceBuffer attribute on the TextTrack object to null.
 833                 track.setSourceBuffer(nullptr);
 834 
 835                 // 9.3.2 If the mode attribute on the TextTrack object is set to &quot;showing&quot; or &quot;hidden&quot;, then
 836                 // set the removed enabled text track flag to true.
 837                 if (track.mode() == TextTrack::Mode::Showing || track.mode() == TextTrack::Mode::Hidden)
 838                     removedEnabledTextTrack = true;
 839 
 840                 // 9.3.3 Remove the TextTrack object from the HTMLMediaElement textTracks list.
 841                 // 9.3.4 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 842                 // cancelable, and that uses the TrackEvent interface, at the HTMLMediaElement textTracks list.
 843                 if (mediaElement())
 844                     mediaElement()-&gt;removeTextTrack(track);
 845 
 846                 // 9.3.5 Remove the TextTrack object from the SourceBuffer textTracks list.
 847                 // 9.3.6 Queue a task to fire a trusted event named removetrack, that does not bubble and is not
 848                 // cancelable, and that uses the TrackEvent interface, at the SourceBuffer textTracks list.
<span class="line-modified"> 849                 textTracks-&gt;remove(track);</span>
 850             }
 851 
 852             // 9.4 If the removed enabled text track flag equals true, then queue a task to fire a simple event
 853             // named change at the HTMLMediaElement textTracks list.
 854             if (removedEnabledTextTrack)
 855                 mediaElement()-&gt;ensureTextTracks().scheduleChangeEvent();
 856         }
 857     }
 858 
 859     // 10. If sourceBuffer is in activeSourceBuffers, then remove sourceBuffer from activeSourceBuffers ...
 860     m_activeSourceBuffers-&gt;remove(buffer);
 861 
 862     // 11. Remove sourceBuffer from sourceBuffers and fire a removesourcebuffer event
 863     // on that object.
 864     m_sourceBuffers-&gt;remove(buffer);
 865 
 866     // 12. Destroy all resources for sourceBuffer.
 867     buffer.removedFromMediaSource();
 868 
 869     return { };
</pre>
<hr />
<pre>
 877     if (type.isNull() || type.isEmpty())
 878         return false;
 879 
 880     ContentType contentType(type);
 881     String codecs = contentType.parameter(&quot;codecs&quot;);
 882 
 883     // 2. If type does not contain a valid MIME type string, then return false.
 884     if (contentType.containerType().isEmpty())
 885         return false;
 886 
 887     // 3. If type contains a media type or media subtype that the MediaSource does not support, then return false.
 888     // 4. If type contains at a codec that the MediaSource does not support, then return false.
 889     // 5. If the MediaSource does not support the specified combination of media type, media subtype, and codecs then return false.
 890     // 6. Return true.
 891     MediaEngineSupportParameters parameters;
 892     parameters.type = contentType;
 893     parameters.isMediaSource = true;
 894     MediaPlayer::SupportsType supported = MediaPlayer::supportsType(parameters);
 895 
 896     if (codecs.isEmpty())
<span class="line-modified"> 897         return supported != MediaPlayer::SupportsType::IsNotSupported;</span>
 898 
<span class="line-modified"> 899     return supported == MediaPlayer::SupportsType::IsSupported;</span>
 900 }
 901 
 902 bool MediaSource::isOpen() const
 903 {
 904     return readyState() == ReadyState::Open;
 905 }
 906 
 907 bool MediaSource::isClosed() const
 908 {
 909     return readyState() == ReadyState::Closed;
 910 }
 911 
 912 bool MediaSource::isEnded() const
 913 {
 914     return readyState() == ReadyState::Ended;
 915 }
 916 
 917 void MediaSource::detachFromElement(HTMLMediaElement&amp; element)
 918 {
 919     ALWAYS_LOG(LOGIDENTIFIER);
</pre>
<hr />
<pre>
 939     // 6. Queue a task to fire a simple event named removesourcebuffer at sourceBuffers.
 940     while (m_sourceBuffers-&gt;length())
 941         removeSourceBuffer(*m_sourceBuffers-&gt;item(0));
 942 
 943     m_private = nullptr;
 944     m_mediaElement = nullptr;
 945 }
 946 
 947 void MediaSource::sourceBufferDidChangeActiveState(SourceBuffer&amp;, bool)
 948 {
 949     regenerateActiveSourceBuffers();
 950 }
 951 
 952 bool MediaSource::attachToElement(HTMLMediaElement&amp; element)
 953 {
 954     if (m_mediaElement)
 955         return false;
 956 
 957     ASSERT(isClosed());
 958 
<span class="line-modified"> 959     m_mediaElement = makeWeakPtr(&amp;element);</span>
 960     return true;
 961 }
 962 
 963 void MediaSource::openIfInEndedState()
 964 {
 965     if (m_readyState != ReadyState::Ended)
 966         return;
 967 
 968     ALWAYS_LOG(LOGIDENTIFIER);
 969 
 970     setReadyState(ReadyState::Open);
 971     m_private-&gt;unmarkEndOfStream();
 972 }
 973 
 974 bool MediaSource::hasPendingActivity() const
 975 {
<span class="line-modified"> 976     return m_private || m_asyncEventQueue-&gt;hasPendingEvents()</span>
 977         || ActiveDOMObject::hasPendingActivity();
 978 }
 979 























 980 void MediaSource::stop()
 981 {
 982     ALWAYS_LOG(LOGIDENTIFIER);
 983 

 984     if (m_mediaElement)
 985         m_mediaElement-&gt;detachMediaSource();
 986     m_readyState = ReadyState::Closed;
 987     m_private = nullptr;
 988 }
 989 





 990 const char* MediaSource::activeDOMObjectName() const
 991 {
 992     return &quot;MediaSource&quot;;
 993 }
 994 
 995 void MediaSource::onReadyStateChange(ReadyState oldState, ReadyState newState)
 996 {
 997     ALWAYS_LOG(LOGIDENTIFIER, &quot;old state = &quot;, oldState, &quot;, new state = &quot;, newState);
 998 
 999     for (auto&amp; buffer : *m_sourceBuffers)
1000         buffer-&gt;readyStateChanged();
1001 
1002     if (isOpen()) {
1003         scheduleEvent(eventNames().sourceopenEvent);
1004         return;
1005     }
1006 
1007     if (oldState == ReadyState::Open &amp;&amp; newState == ReadyState::Ended) {
1008         scheduleEvent(eventNames().sourceendedEvent);
1009         return;
</pre>
<hr />
<pre>
1034         // a NotSupportedError exception and abort these steps.
1035         return Exception { NotSupportedError };
1036     case MediaSourcePrivate::ReachedIdLimit:
1037         // 2.2 https://dvcs.w3.org/hg/html-media/raw-file/default/media-source/media-source.html#widl-MediaSource-addSourceBuffer-SourceBuffer-DOMString-type
1038         // Step 3: If the user agent can&#39;t handle any more SourceBuffer objects then throw
1039         // a QuotaExceededError exception and abort these steps.
1040         return Exception { QuotaExceededError };
1041     }
1042 
1043     ASSERT_NOT_REACHED();
1044     return Exception { QuotaExceededError };
1045 }
1046 
1047 void MediaSource::scheduleEvent(const AtomString&amp; eventName)
1048 {
1049     DEBUG_LOG(LOGIDENTIFIER, &quot;scheduling &#39;&quot;, eventName, &quot;&#39;&quot;);
1050 
1051     auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::No);
1052     event-&gt;setTarget(this);
1053 
<span class="line-modified">1054     m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
1055 }
1056 
1057 ScriptExecutionContext* MediaSource::scriptExecutionContext() const
1058 {
1059     return ActiveDOMObject::scriptExecutionContext();
1060 }
1061 
1062 EventTargetInterface MediaSource::eventTargetInterface() const
1063 {
1064     return MediaSourceEventTargetInterfaceType;
1065 }
1066 
1067 URLRegistry&amp; MediaSource::registry() const
1068 {
1069     return MediaSourceRegistry::registry();
1070 }
1071 
1072 void MediaSource::regenerateActiveSourceBuffers()
1073 {
1074     Vector&lt;RefPtr&lt;SourceBuffer&gt;&gt; newList;
</pre>
</td>
</tr>
</table>
<center><a href="../mediasession/WebMediaSessionManagerClient.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MediaSource.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/parser/HTMLParserScheduler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLParserOptions.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="HTMLParserScheduler.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/parser/HTMLParserScheduler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 63 }
 64 
 65 PumpSession::PumpSession(unsigned&amp; nestingLevel, Document* document)
 66     : NestingLevelIncrementer(nestingLevel)
 67     , ActiveParserSession(document)
 68     // Setting processedTokens to INT_MAX causes us to check for yields
 69     // after any token during any parse where yielding is allowed.
 70     // At that time we&#39;ll initialize startTime.
 71     , processedTokens(INT_MAX)
 72     , didSeeScript(false)
 73 {
 74 }
 75 
 76 PumpSession::~PumpSession() = default;
 77 
 78 HTMLParserScheduler::HTMLParserScheduler(HTMLDocumentParser&amp; parser)
 79     : m_parser(parser)
 80     , m_parserTimeLimit(Seconds(parserTimeLimit(m_parser.document()-&gt;page())))
 81     , m_continueNextChunkTimer(*this, &amp;HTMLParserScheduler::continueNextChunkTimerFired)
 82     , m_isSuspendedWithActiveTimer(false)
<span class="line-modified"> 83 #if !ASSERT_DISABLED</span>
 84     , m_suspended(false)
 85 #endif
 86 {
 87 }
 88 
 89 HTMLParserScheduler::~HTMLParserScheduler()
 90 {
 91     m_continueNextChunkTimer.stop();
 92 }
 93 
 94 void HTMLParserScheduler::continueNextChunkTimerFired()
 95 {
 96     ASSERT(!m_suspended);
 97 
 98     // FIXME: The timer class should handle timer priorities instead of this code.
 99     // If a layout is scheduled, wait again to let the layout timer run first.
100     if (m_parser.document()-&gt;isLayoutTimerActive()) {
101         m_continueNextChunkTimer.startOneShot(0_s);
102         return;
103     }
</pre>
<hr />
<pre>
111     RefPtr&lt;Document&gt; document = m_parser.document();
112     bool needsFirstPaint = document-&gt;view() &amp;&amp; !document-&gt;view()-&gt;hasEverPainted();
113     session.didSeeScript = true;
114 
115     if (UNLIKELY(m_documentHasActiveParserYieldTokens))
116         return true;
117 
118     return needsFirstPaint &amp;&amp; document-&gt;isLayoutTimerActive();
119 }
120 
121 void HTMLParserScheduler::scheduleForResume()
122 {
123     ASSERT(!m_suspended);
124     m_continueNextChunkTimer.startOneShot(0_s);
125 }
126 
127 void HTMLParserScheduler::suspend()
128 {
129     ASSERT(!m_suspended);
130     ASSERT(!m_isSuspendedWithActiveTimer);
<span class="line-modified">131 #if !ASSERT_DISABLED</span>
132     m_suspended = true;
133 #endif
134 
135     if (!m_continueNextChunkTimer.isActive())
136         return;
137     m_isSuspendedWithActiveTimer = true;
138     m_continueNextChunkTimer.stop();
139 }
140 
141 void HTMLParserScheduler::resume()
142 {
143     ASSERT(m_suspended);
144     ASSERT(!m_continueNextChunkTimer.isActive());
<span class="line-modified">145 #if !ASSERT_DISABLED</span>
146     m_suspended = false;
147 #endif
148 
149     if (!m_isSuspendedWithActiveTimer)
150         return;
151     m_isSuspendedWithActiveTimer = false;
152     m_continueNextChunkTimer.startOneShot(0_s);
153 }
154 
155 }
</pre>
</td>
<td>
<hr />
<pre>
 63 }
 64 
 65 PumpSession::PumpSession(unsigned&amp; nestingLevel, Document* document)
 66     : NestingLevelIncrementer(nestingLevel)
 67     , ActiveParserSession(document)
 68     // Setting processedTokens to INT_MAX causes us to check for yields
 69     // after any token during any parse where yielding is allowed.
 70     // At that time we&#39;ll initialize startTime.
 71     , processedTokens(INT_MAX)
 72     , didSeeScript(false)
 73 {
 74 }
 75 
 76 PumpSession::~PumpSession() = default;
 77 
 78 HTMLParserScheduler::HTMLParserScheduler(HTMLDocumentParser&amp; parser)
 79     : m_parser(parser)
 80     , m_parserTimeLimit(Seconds(parserTimeLimit(m_parser.document()-&gt;page())))
 81     , m_continueNextChunkTimer(*this, &amp;HTMLParserScheduler::continueNextChunkTimerFired)
 82     , m_isSuspendedWithActiveTimer(false)
<span class="line-modified"> 83 #if ASSERT_ENABLED</span>
 84     , m_suspended(false)
 85 #endif
 86 {
 87 }
 88 
 89 HTMLParserScheduler::~HTMLParserScheduler()
 90 {
 91     m_continueNextChunkTimer.stop();
 92 }
 93 
 94 void HTMLParserScheduler::continueNextChunkTimerFired()
 95 {
 96     ASSERT(!m_suspended);
 97 
 98     // FIXME: The timer class should handle timer priorities instead of this code.
 99     // If a layout is scheduled, wait again to let the layout timer run first.
100     if (m_parser.document()-&gt;isLayoutTimerActive()) {
101         m_continueNextChunkTimer.startOneShot(0_s);
102         return;
103     }
</pre>
<hr />
<pre>
111     RefPtr&lt;Document&gt; document = m_parser.document();
112     bool needsFirstPaint = document-&gt;view() &amp;&amp; !document-&gt;view()-&gt;hasEverPainted();
113     session.didSeeScript = true;
114 
115     if (UNLIKELY(m_documentHasActiveParserYieldTokens))
116         return true;
117 
118     return needsFirstPaint &amp;&amp; document-&gt;isLayoutTimerActive();
119 }
120 
121 void HTMLParserScheduler::scheduleForResume()
122 {
123     ASSERT(!m_suspended);
124     m_continueNextChunkTimer.startOneShot(0_s);
125 }
126 
127 void HTMLParserScheduler::suspend()
128 {
129     ASSERT(!m_suspended);
130     ASSERT(!m_isSuspendedWithActiveTimer);
<span class="line-modified">131 #if ASSERT_ENABLED</span>
132     m_suspended = true;
133 #endif
134 
135     if (!m_continueNextChunkTimer.isActive())
136         return;
137     m_isSuspendedWithActiveTimer = true;
138     m_continueNextChunkTimer.stop();
139 }
140 
141 void HTMLParserScheduler::resume()
142 {
143     ASSERT(m_suspended);
144     ASSERT(!m_continueNextChunkTimer.isActive());
<span class="line-modified">145 #if ASSERT_ENABLED</span>
146     m_suspended = false;
147 #endif
148 
149     if (!m_isSuspendedWithActiveTimer)
150         return;
151     m_isSuspendedWithActiveTimer = false;
152     m_continueNextChunkTimer.startOneShot(0_s);
153 }
154 
155 }
</pre>
</td>
</tr>
</table>
<center><a href="HTMLParserOptions.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="HTMLParserScheduler.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
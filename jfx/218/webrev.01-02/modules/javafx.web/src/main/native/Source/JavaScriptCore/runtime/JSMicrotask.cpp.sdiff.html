<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSMicrotask.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSMapIterator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSMicrotask.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSMicrotask.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSMicrotask.h&quot;
 28 
 29 #include &quot;CatchScope.h&quot;
 30 #include &quot;Debugger.h&quot;
 31 #include &quot;Error.h&quot;
 32 #include &quot;Exception.h&quot;
 33 #include &quot;JSCInlines.h&quot;
 34 #include &quot;JSGlobalObject.h&quot;
 35 #include &quot;JSObjectInlines.h&quot;
 36 #include &quot;Microtask.h&quot;
 37 #include &quot;StrongInlines.h&quot;
 38 
 39 namespace JSC {
 40 
 41 class JSMicrotask final : public Microtask {
 42 public:
<span class="line-modified"> 43     JSMicrotask(VM&amp; vm, JSValue job, JSArray* arguments)</span>

 44     {
 45         m_job.set(vm, job);
<span class="line-modified"> 46         m_arguments.set(vm, arguments);</span>


 47     }
 48 
 49     JSMicrotask(VM&amp; vm, JSValue job)
 50     {
 51         m_job.set(vm, job);
 52     }
 53 
 54 private:
<span class="line-modified"> 55     void run(ExecState*) override;</span>
 56 
 57     Strong&lt;Unknown&gt; m_job;
<span class="line-modified"> 58     Strong&lt;JSArray&gt; m_arguments;</span>
 59 };
 60 
 61 Ref&lt;Microtask&gt; createJSMicrotask(VM&amp; vm, JSValue job)
 62 {
 63     return adoptRef(*new JSMicrotask(vm, job));
 64 }
 65 
<span class="line-modified"> 66 Ref&lt;Microtask&gt; createJSMicrotask(VM&amp; vm, JSValue job, JSArray* arguments)</span>
 67 {
<span class="line-modified"> 68     return adoptRef(*new JSMicrotask(vm, job, arguments));</span>
 69 }
 70 
<span class="line-modified"> 71 void JSMicrotask::run(ExecState* exec)</span>
 72 {
<span class="line-modified"> 73     VM&amp; vm = exec-&gt;vm();</span>
 74     auto scope = DECLARE_CATCH_SCOPE(vm);
 75 
 76     CallData handlerCallData;
 77     CallType handlerCallType = getCallData(vm, m_job.get(), handlerCallData);
 78     ASSERT(handlerCallType != CallType::None);
 79 
 80     MarkedArgumentBuffer handlerArguments;
<span class="line-modified"> 81     if (m_arguments) {</span>
<span class="line-modified"> 82         for (unsigned index = 0, length = m_arguments-&gt;length(); index &lt; length; ++index) {</span>
<span class="line-modified"> 83             JSValue arg = m_arguments-&gt;JSArray::get(exec, index);</span>
<span class="line-modified"> 84             CLEAR_AND_RETURN_IF_EXCEPTION(scope, handlerArguments.overflowCheckNotNeeded());</span>
<span class="line-modified"> 85             handlerArguments.append(arg);</span>
<span class="line-removed"> 86         }</span>
<span class="line-removed"> 87         if (UNLIKELY(handlerArguments.hasOverflowed()))</span>
<span class="line-removed"> 88             return;</span>
 89     }


 90 
<span class="line-modified"> 91     if (UNLIKELY(exec-&gt;lexicalGlobalObject()-&gt;hasDebugger()))</span>
<span class="line-modified"> 92         exec-&gt;lexicalGlobalObject()-&gt;debugger()-&gt;willRunMicrotask();</span>
 93 
<span class="line-modified"> 94     profiledCall(exec, ProfilingReason::Microtask, m_job.get(), handlerCallType, handlerCallData, jsUndefined(), handlerArguments);</span>
 95     scope.clearException();
 96 }
 97 
 98 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSMicrotask.h&quot;
 28 
 29 #include &quot;CatchScope.h&quot;
 30 #include &quot;Debugger.h&quot;
 31 #include &quot;Error.h&quot;
 32 #include &quot;Exception.h&quot;
 33 #include &quot;JSCInlines.h&quot;
 34 #include &quot;JSGlobalObject.h&quot;
 35 #include &quot;JSObjectInlines.h&quot;
 36 #include &quot;Microtask.h&quot;
 37 #include &quot;StrongInlines.h&quot;
 38 
 39 namespace JSC {
 40 
 41 class JSMicrotask final : public Microtask {
 42 public:
<span class="line-modified"> 43     static constexpr unsigned maxArguments = 3;</span>
<span class="line-added"> 44     JSMicrotask(VM&amp; vm, JSValue job, JSValue argument0, JSValue argument1, JSValue argument2)</span>
 45     {
 46         m_job.set(vm, job);
<span class="line-modified"> 47         m_arguments[0].set(vm, argument0);</span>
<span class="line-added"> 48         m_arguments[1].set(vm, argument1);</span>
<span class="line-added"> 49         m_arguments[2].set(vm, argument2);</span>
 50     }
 51 
 52     JSMicrotask(VM&amp; vm, JSValue job)
 53     {
 54         m_job.set(vm, job);
 55     }
 56 
 57 private:
<span class="line-modified"> 58     void run(JSGlobalObject*) override;</span>
 59 
 60     Strong&lt;Unknown&gt; m_job;
<span class="line-modified"> 61     Strong&lt;Unknown&gt; m_arguments[maxArguments];</span>
 62 };
 63 
 64 Ref&lt;Microtask&gt; createJSMicrotask(VM&amp; vm, JSValue job)
 65 {
 66     return adoptRef(*new JSMicrotask(vm, job));
 67 }
 68 
<span class="line-modified"> 69 Ref&lt;Microtask&gt; createJSMicrotask(VM&amp; vm, JSValue job, JSValue argument0, JSValue argument1, JSValue argument2)</span>
 70 {
<span class="line-modified"> 71     return adoptRef(*new JSMicrotask(vm, job, argument0, argument1, argument2));</span>
 72 }
 73 
<span class="line-modified"> 74 void JSMicrotask::run(JSGlobalObject* globalObject)</span>
 75 {
<span class="line-modified"> 76     VM&amp; vm = globalObject-&gt;vm();</span>
 77     auto scope = DECLARE_CATCH_SCOPE(vm);
 78 
 79     CallData handlerCallData;
 80     CallType handlerCallType = getCallData(vm, m_job.get(), handlerCallData);
 81     ASSERT(handlerCallType != CallType::None);
 82 
 83     MarkedArgumentBuffer handlerArguments;
<span class="line-modified"> 84     for (unsigned index = 0; index &lt; maxArguments; ++index) {</span>
<span class="line-modified"> 85         JSValue arg = m_arguments[index].get();</span>
<span class="line-modified"> 86         if (!arg)</span>
<span class="line-modified"> 87             break;</span>
<span class="line-modified"> 88         handlerArguments.append(arg);</span>



 89     }
<span class="line-added"> 90     if (UNLIKELY(handlerArguments.hasOverflowed()))</span>
<span class="line-added"> 91         return;</span>
 92 
<span class="line-modified"> 93     if (UNLIKELY(globalObject-&gt;hasDebugger()))</span>
<span class="line-modified"> 94         globalObject-&gt;debugger()-&gt;willRunMicrotask();</span>
 95 
<span class="line-modified"> 96     profiledCall(globalObject, ProfilingReason::Microtask, m_job.get(), handlerCallType, handlerCallData, jsUndefined(), handlerArguments);</span>
 97     scope.clearException();
 98 }
 99 
100 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSMapIterator.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSMicrotask.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
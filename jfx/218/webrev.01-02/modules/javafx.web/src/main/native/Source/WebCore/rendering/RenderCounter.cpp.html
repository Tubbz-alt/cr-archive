<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderCounter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2004 Allan Sandfeld Jensen (kde@carewolf.com)
  3  * Copyright (C) 2006-2018 Apple Inc. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;RenderCounter.h&quot;
 24 
 25 #include &quot;CounterNode.h&quot;
 26 #include &quot;Document.h&quot;
 27 #include &quot;Element.h&quot;
 28 #include &quot;ElementTraversal.h&quot;
 29 #include &quot;HTMLNames.h&quot;
 30 #include &quot;HTMLOListElement.h&quot;
 31 #include &quot;PseudoElement.h&quot;
 32 #include &quot;RenderListItem.h&quot;
 33 #include &quot;RenderListMarker.h&quot;
 34 #include &quot;RenderStyle.h&quot;
 35 #include &quot;RenderView.h&quot;
 36 #include &lt;wtf/IsoMallocInlines.h&gt;
 37 #include &lt;wtf/StdLibExtras.h&gt;
 38 
 39 #if ENABLE(TREE_DEBUGGING)
 40 #include &lt;stdio.h&gt;
 41 #endif
 42 
 43 namespace WebCore {
 44 
 45 using namespace HTMLNames;
 46 
 47 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderCounter);
 48 
 49 using CounterMap = HashMap&lt;AtomString, Ref&lt;CounterNode&gt;&gt;;
 50 using CounterMaps = HashMap&lt;const RenderElement*, std::unique_ptr&lt;CounterMap&gt;&gt;;
 51 
 52 static CounterNode* makeCounterNode(RenderElement&amp;, const AtomString&amp; identifier, bool alwaysCreateCounter);
 53 
 54 static CounterMaps&amp; counterMaps()
 55 {
 56     static NeverDestroyed&lt;CounterMaps&gt; staticCounterMaps;
 57     return staticCounterMaps;
 58 }
 59 
 60 // This function processes the renderer tree in the order of the DOM tree
 61 // including pseudo elements as defined in CSS 2.1.
 62 static RenderElement* previousInPreOrder(const RenderElement&amp; renderer)
 63 {
 64     ASSERT(renderer.element());
 65     Element* previous = ElementTraversal::previousIncludingPseudo(*renderer.element());
 66     while (previous &amp;&amp; !previous-&gt;renderer())
 67         previous = ElementTraversal::previousIncludingPseudo(*previous);
 68     return previous ? previous-&gt;renderer() : 0;
 69 }
 70 
 71 static inline Element* parentOrPseudoHostElement(const RenderElement&amp; renderer)
 72 {
 73     if (renderer.isPseudoElement())
 74         return renderer.generatingElement();
 75     return renderer.element() ? renderer.element()-&gt;parentElement() : nullptr;
 76 }
 77 
 78 static Element* previousSiblingOrParentElement(const Element&amp; element)
 79 {
 80     if (auto* previous = ElementTraversal::pseudoAwarePreviousSibling(element)) {
 81         while (previous &amp;&amp; !previous-&gt;renderer())
 82             previous = ElementTraversal::pseudoAwarePreviousSibling(*previous);
 83 
 84         if (previous)
 85             return previous;
 86     }
 87 
 88     if (is&lt;PseudoElement&gt;(element)) {
 89         auto* hostElement = downcast&lt;PseudoElement&gt;(element).hostElement();
 90         ASSERT(hostElement);
 91         if (hostElement-&gt;renderer())
 92             return hostElement;
 93         return previousSiblingOrParentElement(*hostElement);
 94     }
 95 
 96     auto* parent = element.parentElement();
 97     if (parent &amp;&amp; !parent-&gt;renderer())
 98         parent = previousSiblingOrParentElement(*parent);
 99     return parent;
100 }
101 
102 // This function processes the renderer tree in the order of the DOM tree
103 // including pseudo elements as defined in CSS 2.1.
104 static RenderElement* previousSiblingOrParent(const RenderElement&amp; renderer)
105 {
106     ASSERT(renderer.element());
107 
108     auto* previous = previousSiblingOrParentElement(*renderer.element());
109     return previous ? previous-&gt;renderer() : nullptr;
110 }
111 
112 static inline bool areRenderersElementsSiblings(const RenderElement&amp; first, const RenderElement&amp; second)
113 {
114     return parentOrPseudoHostElement(first) == parentOrPseudoHostElement(second);
115 }
116 
117 // This function processes the renderer tree in the order of the DOM tree
118 // including pseudo elements as defined in CSS 2.1.
119 static RenderElement* nextInPreOrder(const RenderElement&amp; renderer, const Element* stayWithin, bool skipDescendants = false)
120 {
121     ASSERT(renderer.element());
122     Element&amp; self = *renderer.element();
123     Element* next = skipDescendants ? ElementTraversal::nextIncludingPseudoSkippingChildren(self, stayWithin) : ElementTraversal::nextIncludingPseudo(self, stayWithin);
124     while (next &amp;&amp; !next-&gt;renderer())
125         next = skipDescendants ? ElementTraversal::nextIncludingPseudoSkippingChildren(*next, stayWithin) : ElementTraversal::nextIncludingPseudo(*next, stayWithin);
126     return next ? next-&gt;renderer() : nullptr;
127 }
128 
129 static CounterDirectives listItemCounterDirectives(RenderElement&amp; renderer)
130 {
131     if (is&lt;RenderListItem&gt;(renderer)) {
132         auto&amp; item = downcast&lt;RenderListItem&gt;(renderer);
133         if (auto explicitValue = item.explicitValue())
134             return { *explicitValue, WTF::nullopt };
135         return { WTF::nullopt, item.isInReversedOrderedList() ? -1 : 1 };
136     }
137     if (auto element = renderer.element()) {
138         if (is&lt;HTMLOListElement&gt;(*element)) {
139             auto&amp; list = downcast&lt;HTMLOListElement&gt;(*element);
140             return { list.start(), list.isReversed() ? 1 : -1 };
141         }
142         if (isHTMLListElement(*element))
143             return { 0, WTF::nullopt };
144     }
145     return { };
146 }
147 
148 struct CounterPlan {
149     bool isReset;
150     int value;
151 };
152 
153 static Optional&lt;CounterPlan&gt; planCounter(RenderElement&amp; renderer, const AtomString&amp; identifier)
154 {
155     // We must have a generating node or else we cannot have a counter.
156     Element* generatingElement = renderer.generatingElement();
157     if (!generatingElement)
158         return WTF::nullopt;
159 
160     auto&amp; style = renderer.style();
161 
162     switch (style.styleType()) {
163     case PseudoId::None:
164         // Sometimes elements have more then one renderer. Only the first one gets the counter
165         // LayoutTests/http/tests/css/counter-crash.html
166         if (generatingElement-&gt;renderer() != &amp;renderer)
167             return WTF::nullopt;
168         break;
169     case PseudoId::Before:
170     case PseudoId::After:
171         break;
172     default:
173         return WTF::nullopt; // Counters are forbidden from all other pseudo elements.
174     }
175 
176     CounterDirectives directives;
177 
178     if (auto map = style.counterDirectives())
179         directives = map-&gt;get(identifier);
180 
181     if (identifier == &quot;list-item&quot;) {
182         auto itemDirectives = listItemCounterDirectives(renderer);
183         if (!directives.resetValue)
184             directives.resetValue = itemDirectives.resetValue;
185         if (!directives.incrementValue)
186             directives.incrementValue = itemDirectives.incrementValue;
187     }
188 
189     if (directives.resetValue)
190         return CounterPlan { true, saturatedAddition(*directives.resetValue, directives.incrementValue.valueOr(0)) };
191     if (directives.incrementValue)
192         return CounterPlan { false, *directives.incrementValue };
193     return WTF::nullopt;
194 }
195 
196 // - Finds the insertion point for the counter described by counterOwner, isReset and
197 // identifier in the CounterNode tree for identifier and sets parent and
198 // previousSibling accordingly.
199 // - The function returns true if the counter whose insertion point is searched is NOT
200 // the root of the tree.
201 // - The root of the tree is a counter reference that is not in the scope of any other
202 // counter with the same identifier.
203 // - All the counter references with the same identifier as this one that are in
204 // children or subsequent siblings of the renderer that owns the root of the tree
205 // form the rest of of the nodes of the tree.
206 // - The root of the tree is always a reset type reference.
207 // - A subtree rooted at any reset node in the tree is equivalent to all counter
208 // references that are in the scope of the counter or nested counter defined by that
209 // reset node.
210 // - Non-reset CounterNodes cannot have descendants.
211 
212 struct CounterInsertionPoint {
213     RefPtr&lt;CounterNode&gt; parent;
214     RefPtr&lt;CounterNode&gt; previousSibling;
215 };
216 
217 static CounterInsertionPoint findPlaceForCounter(RenderElement&amp; counterOwner, const AtomString&amp; identifier, bool isReset)
218 {
219     // We cannot stop searching for counters with the same identifier before we also
220     // check this renderer, because it may affect the positioning in the tree of our counter.
221     RenderElement* searchEndRenderer = previousSiblingOrParent(counterOwner);
222     // We check renderers in preOrder from the renderer that our counter is attached to
223     // towards the begining of the document for counters with the same identifier as the one
224     // we are trying to find a place for. This is the next renderer to be checked.
225     RenderElement* currentRenderer = previousInPreOrder(counterOwner);
226     RefPtr&lt;CounterNode&gt; previousSibling;
227 
228     while (currentRenderer) {
229         auto currentCounter = makeCounterNode(*currentRenderer, identifier, false);
230         if (searchEndRenderer == currentRenderer) {
231             // We may be at the end of our search.
232             if (currentCounter) {
233                 // We have a suitable counter on the EndSearchRenderer.
234                 if (previousSibling) {
235                     // But we already found another counter that we come after.
236                     if (currentCounter-&gt;actsAsReset()) {
237                         // We found a reset counter that is on a renderer that is a sibling of ours or a parent.
238                         if (isReset &amp;&amp; areRenderersElementsSiblings(*currentRenderer, counterOwner)) {
239                             // We are also a reset counter and the previous reset was on a sibling renderer
240                             // hence we are the next sibling of that counter if that reset is not a root or
241                             // we are a root node if that reset is a root.
242                             auto* parent = currentCounter-&gt;parent();
243                             return { parent, parent ? currentCounter : nullptr };
244                         }
245                         // We are not a reset node or the previous reset must be on an ancestor of our owner renderer
246                         // hence we must be a child of that reset counter.
247                         // In some cases renders can be reparented (ex. nodes inside a table but not in a column or row).
248                         // In these cases the identified previousSibling will be invalid as its parent is different from
249                         // our identified parent.
250                         if (previousSibling-&gt;parent() != currentCounter)
251                             previousSibling = nullptr;
252                         return { currentCounter, WTFMove(previousSibling) };
253                     }
254                     // CurrentCounter, the counter at the EndSearchRenderer, is not reset.
255                     if (!isReset || !areRenderersElementsSiblings(*currentRenderer, counterOwner)) {
256                         // If the node we are placing is not reset or we have found a counter that is attached
257                         // to an ancestor of the placed counter&#39;s owner renderer we know we are a sibling of that node.
258                         if (currentCounter-&gt;parent() != previousSibling-&gt;parent())
259                             return { };
260                         return { currentCounter-&gt;parent(), WTFMove(previousSibling) };
261                     }
262                 } else {
263                     // We are at the potential end of the search, but we had no previous sibling candidate
264                     // In this case we follow pretty much the same logic as above but no ASSERTs about
265                     // previousSibling, and when we are a sibling of the end counter we must set previousSibling
266                     // to currentCounter.
267                     if (currentCounter-&gt;actsAsReset()) {
268                         if (isReset &amp;&amp; areRenderersElementsSiblings(*currentRenderer, counterOwner))
269                             return { currentCounter-&gt;parent(), currentCounter };
270                         return { currentCounter, WTFMove(previousSibling) };
271                     }
272                     if (!isReset || !areRenderersElementsSiblings(*currentRenderer, counterOwner))
273                         return { currentCounter-&gt;parent(), currentCounter };
274                     previousSibling = currentCounter;
275                 }
276             }
277             // We come here if the previous sibling or parent of our owner renderer had no
278             // good counter, or we are a reset node and the counter on the previous sibling
279             // of our owner renderer was not a reset counter.
280             // Set a new goal for the end of the search.
281             searchEndRenderer = previousSiblingOrParent(*currentRenderer);
282         } else {
283             // We are searching descendants of a previous sibling of the renderer that the
284             // counter being placed is attached to.
285             if (currentCounter) {
286                 // We found a suitable counter.
287                 if (previousSibling) {
288                     // Since we had a suitable previous counter before, we should only consider this one as our
289                     // previousSibling if it is a reset counter and hence the current previousSibling is its child.
290                     if (currentCounter-&gt;actsAsReset()) {
291                         previousSibling = currentCounter;
292                         // We are no longer interested in previous siblings of the currentRenderer or their children
293                         // as counters they may have attached cannot be the previous sibling of the counter we are placing.
294                         currentRenderer = parentOrPseudoHostElement(*currentRenderer)-&gt;renderer();
295                         continue;
296                     }
297                 } else
298                     previousSibling = currentCounter;
299                 currentRenderer = previousSiblingOrParent(*currentRenderer);
300                 continue;
301             }
302         }
303         // This function is designed so that the same test is not done twice in an iteration, except for this one
304         // which may be done twice in some cases. Rearranging the decision points though, to accommodate this
305         // performance improvement would create more code duplication than is worthwhile in my oppinion and may further
306         // impede the readability of this already complex algorithm.
307         if (previousSibling)
308             currentRenderer = previousSiblingOrParent(*currentRenderer);
309         else
310             currentRenderer = previousInPreOrder(*currentRenderer);
311     }
312     return { };
313 }
314 
315 static CounterNode* makeCounterNode(RenderElement&amp; renderer, const AtomString&amp; identifier, bool alwaysCreateCounter)
316 {
317     if (renderer.hasCounterNodeMap()) {
318         ASSERT(counterMaps().contains(&amp;renderer));
319         if (auto* node = counterMaps().find(&amp;renderer)-&gt;value-&gt;get(identifier))
320             return node;
321     }
322 
323     auto plan = planCounter(renderer, identifier);
324     if (!plan &amp;&amp; !alwaysCreateCounter)
325         return nullptr;
326 
327     auto&amp; maps = counterMaps();
328 
329     auto newNode = CounterNode::create(renderer, plan &amp;&amp; plan-&gt;isReset, plan ? plan-&gt;value : 0);
330 
331     auto place = findPlaceForCounter(renderer, identifier, plan &amp;&amp; plan-&gt;isReset);
332     if (place.parent)
333         place.parent-&gt;insertAfter(newNode, place.previousSibling.get(), identifier);
334 
335     maps.add(&amp;renderer, makeUnique&lt;CounterMap&gt;()).iterator-&gt;value-&gt;add(identifier, newNode.copyRef());
336     renderer.setHasCounterNodeMap(true);
337 
338     if (newNode-&gt;parent())
339         return newNode.ptr();
340 
341     // Check if some nodes that were previously root nodes should become children of this node now.
342     auto* currentRenderer = &amp;renderer;
343     auto* stayWithin = parentOrPseudoHostElement(renderer);
344     bool skipDescendants = false;
345     while ((currentRenderer = nextInPreOrder(*currentRenderer, stayWithin, skipDescendants))) {
346         skipDescendants = false;
347         if (!currentRenderer-&gt;hasCounterNodeMap())
348             continue;
349         auto* currentCounter = maps.find(currentRenderer)-&gt;value-&gt;get(identifier);
350         if (!currentCounter)
351             continue;
352         skipDescendants = true;
353         if (currentCounter-&gt;parent())
354             continue;
355         if (stayWithin == parentOrPseudoHostElement(*currentRenderer) &amp;&amp; currentCounter-&gt;hasResetType())
356             break;
357         newNode-&gt;insertAfter(*currentCounter, newNode-&gt;lastChild(), identifier);
358     }
359 
360     return newNode.ptr();
361 }
362 
363 RenderCounter::RenderCounter(Document&amp; document, const CounterContent&amp; counter)
364     : RenderText(document, emptyString())
365     , m_counter(counter)
366 {
367     view().addRenderCounter();
368 }
369 
370 RenderCounter::~RenderCounter()
371 {
372     // Do not add any code here. Add it to willBeDestroyed() instead.
373 }
374 
375 void RenderCounter::willBeDestroyed()
376 {
377     view().removeRenderCounter();
378 
379     if (m_counterNode) {
380         m_counterNode-&gt;removeRenderer(*this);
381         ASSERT(!m_counterNode);
382     }
383 
384     RenderText::willBeDestroyed();
385 }
386 
387 const char* RenderCounter::renderName() const
388 {
389     return &quot;RenderCounter&quot;;
390 }
391 
392 bool RenderCounter::isCounter() const
393 {
394     return true;
395 }
396 
397 String RenderCounter::originalText() const
398 {
399     if (!m_counterNode) {
400         RenderElement* beforeAfterContainer = parent();
401         while (true) {
402             if (!beforeAfterContainer)
403                 return String();
404             if (!beforeAfterContainer-&gt;isAnonymous() &amp;&amp; !beforeAfterContainer-&gt;isPseudoElement())
405                 return String(); // RenderCounters are restricted to before and after pseudo elements
406             PseudoId containerStyle = beforeAfterContainer-&gt;style().styleType();
407             if ((containerStyle == PseudoId::Before) || (containerStyle == PseudoId::After))
408                 break;
409             beforeAfterContainer = beforeAfterContainer-&gt;parent();
410         }
411         makeCounterNode(*beforeAfterContainer, m_counter.identifier(), true)-&gt;addRenderer(const_cast&lt;RenderCounter&amp;&gt;(*this));
412         ASSERT(m_counterNode);
413     }
414     CounterNode* child = m_counterNode;
415     int value = child-&gt;actsAsReset() ? child-&gt;value() : child-&gt;countInParent();
416 
417     String text = listMarkerText(m_counter.listStyle(), value);
418 
419     if (!m_counter.separator().isNull()) {
420         if (!child-&gt;actsAsReset())
421             child = child-&gt;parent();
422         while (CounterNode* parent = child-&gt;parent()) {
423             text = listMarkerText(m_counter.listStyle(), child-&gt;countInParent())
424                 + m_counter.separator() + text;
425             child = parent;
426         }
427     }
428 
429     return text;
430 }
431 
432 void RenderCounter::updateCounter()
433 {
434     computePreferredLogicalWidths(0);
435 }
436 
437 void RenderCounter::computePreferredLogicalWidths(float lead)
438 {
439 #ifndef NDEBUG
440     // FIXME: We shouldn&#39;t be modifying the tree in computePreferredLogicalWidths.
441     // Instead, we should properly hook the appropriate changes in the DOM and modify
442     // the render tree then. When that&#39;s done, we also won&#39;t need to override
443     // computePreferredLogicalWidths at all.
444     // https://bugs.webkit.org/show_bug.cgi?id=104829
445     SetLayoutNeededForbiddenScope layoutForbiddenScope(this, false);
446 #endif
447 
448     setRenderedText(originalText());
449 
450     RenderText::computePreferredLogicalWidths(lead);
451 }
452 
453 static void destroyCounterNodeWithoutMapRemoval(const AtomString&amp; identifier, CounterNode&amp; node)
454 {
455     RefPtr&lt;CounterNode&gt; previous;
456     for (RefPtr&lt;CounterNode&gt; child = node.lastDescendant(); child &amp;&amp; child != &amp;node; child = WTFMove(previous)) {
457         previous = child-&gt;previousInPreOrder();
458         child-&gt;parent()-&gt;removeChild(*child);
459         ASSERT(counterMaps().find(&amp;child-&gt;owner())-&gt;value-&gt;get(identifier) == child);
460         counterMaps().find(&amp;child-&gt;owner())-&gt;value-&gt;remove(identifier);
461     }
462     if (auto* parent = node.parent())
463         parent-&gt;removeChild(node);
464 }
465 
466 void RenderCounter::destroyCounterNodes(RenderElement&amp; owner)
467 {
468     ASSERT(owner.hasCounterNodeMap());
469     auto&amp; maps = counterMaps();
470     ASSERT(maps.contains(&amp;owner));
471     auto counterMap = maps.take(&amp;owner);
472     for (auto&amp; counterMapEntry : *counterMap)
473         destroyCounterNodeWithoutMapRemoval(counterMapEntry.key, counterMapEntry.value);
474     owner.setHasCounterNodeMap(false);
475 }
476 
477 void RenderCounter::destroyCounterNode(RenderElement&amp; owner, const AtomString&amp; identifier)
478 {
479     auto map = counterMaps().find(&amp;owner);
480     if (map == counterMaps().end())
481         return;
482     auto node = map-&gt;value-&gt;take(identifier);
483     if (!node)
484         return;
485     destroyCounterNodeWithoutMapRemoval(identifier, *node);
486     // We do not delete the map here even if it is now empty because we expect to
487     // reuse it. In order for a renderer to lose all its counters permanently,
488     // a style change for the renderer involving removal of all counter
489     // directives must occur, in which case, RenderCounter::destroyCounterNodes()
490     // will be called.
491 }
492 
493 void RenderCounter::rendererRemovedFromTree(RenderElement&amp; renderer)
494 {
495     if (!renderer.view().hasRenderCounters())
496         return;
497     RenderObject* currentRenderer = renderer.lastLeafChild();
498     if (!currentRenderer)
499         currentRenderer = &amp;renderer;
500     while (true) {
501         if (is&lt;RenderElement&gt;(*currentRenderer)) {
502             auto&amp; counterNodeRenderer = downcast&lt;RenderElement&gt;(*currentRenderer);
503             if (counterNodeRenderer.hasCounterNodeMap())
504                 destroyCounterNodes(counterNodeRenderer);
505         }
506         if (currentRenderer == &amp;renderer)
507             break;
508         currentRenderer = currentRenderer-&gt;previousInPreOrder();
509     }
510 }
511 
512 static void updateCounters(RenderElement&amp; renderer)
513 {
514     auto* directiveMap = renderer.style().counterDirectives();
515     if (!directiveMap)
516         return;
517     if (!renderer.hasCounterNodeMap()) {
518         for (auto&amp; key : directiveMap-&gt;keys())
519             makeCounterNode(renderer, key, false);
520         return;
521     }
522     ASSERT(counterMaps().contains(&amp;renderer));
523     auto* counterMap = counterMaps().find(&amp;renderer)-&gt;value.get();
524     for (auto&amp; key : directiveMap-&gt;keys()) {
525         RefPtr&lt;CounterNode&gt; node = counterMap-&gt;get(key);
526         if (!node) {
527             makeCounterNode(renderer, key, false);
528             continue;
529         }
530         auto place = findPlaceForCounter(renderer, key, node-&gt;hasResetType());
531         if (node != counterMap-&gt;get(key))
532             continue;
533         CounterNode* parent = node-&gt;parent();
534         if (place.parent == parent &amp;&amp; place.previousSibling == node-&gt;previousSibling())
535             continue;
536         if (parent)
537             parent-&gt;removeChild(*node);
538         if (place.parent)
539             place.parent-&gt;insertAfter(*node, place.previousSibling.get(), key);
540     }
541 }
542 
543 void RenderCounter::rendererSubtreeAttached(RenderElement&amp; renderer)
544 {
545     if (!renderer.view().hasRenderCounters())
546         return;
547     Element* element = renderer.element();
548     if (element &amp;&amp; !element-&gt;isPseudoElement())
549         element = element-&gt;parentElement();
550     else
551         element = renderer.generatingElement();
552     if (element &amp;&amp; !element-&gt;renderer())
553         return; // No need to update if the parent is not attached yet
554     for (RenderObject* descendant = &amp;renderer; descendant; descendant = descendant-&gt;nextInPreOrder(&amp;renderer)) {
555         if (is&lt;RenderElement&gt;(*descendant))
556             updateCounters(downcast&lt;RenderElement&gt;(*descendant));
557     }
558 }
559 
560 void RenderCounter::rendererStyleChanged(RenderElement&amp; renderer, const RenderStyle* oldStyle, const RenderStyle* newStyle)
561 {
562     Element* element = renderer.generatingElement();
563     if (!element || !element-&gt;renderer())
564         return; // cannot have generated content or if it can have, it will be handled during attaching
565 
566     const CounterDirectiveMap* newCounterDirectives;
567     const CounterDirectiveMap* oldCounterDirectives;
568     if (oldStyle &amp;&amp; (oldCounterDirectives = oldStyle-&gt;counterDirectives())) {
569         if (newStyle &amp;&amp; (newCounterDirectives = newStyle-&gt;counterDirectives())) {
570             for (auto&amp; keyValue : *newCounterDirectives) {
571                 auto existingEntry = oldCounterDirectives-&gt;find(keyValue.key);
572                 if (existingEntry != oldCounterDirectives-&gt;end()) {
573                     if (existingEntry-&gt;value == keyValue.value)
574                         continue;
575                     RenderCounter::destroyCounterNode(renderer, keyValue.key);
576                 }
577                 // We must create this node here, because the changed node may be a node with no display such as
578                 // as those created by the increment or reset directives and the re-layout that will happen will
579                 // not catch the change if the node had no children.
580                 makeCounterNode(renderer, keyValue.key, false);
581             }
582             // Destroying old counters that do not exist in the new counterDirective map.
583             for (auto&amp; key : oldCounterDirectives-&gt;keys()) {
584                 if (!newCounterDirectives-&gt;contains(key))
585                     RenderCounter::destroyCounterNode(renderer, key);
586             }
587         } else {
588             if (renderer.hasCounterNodeMap())
589                 RenderCounter::destroyCounterNodes(renderer);
590         }
591     } else {
592         if (newStyle &amp;&amp; (newCounterDirectives = newStyle-&gt;counterDirectives())) {
593             for (auto&amp; key : newCounterDirectives-&gt;keys()) {
594                 // We must create this node here, because the added node may be a node with no display such as
595                 // as those created by the increment or reset directives and the re-layout that will happen will
596                 // not catch the change if the node had no children.
597                 makeCounterNode(renderer, key, false);
598             }
599         }
600     }
601 }
602 
603 } // namespace WebCore
604 
605 #if ENABLE(TREE_DEBUGGING)
606 
607 void showCounterRendererTree(const WebCore::RenderObject* renderer, const char* counterName)
608 {
609     if (!renderer)
610         return;
611     auto* root = renderer;
612     while (root-&gt;parent())
613         root = root-&gt;parent();
614 
615     AtomString identifier(counterName);
616     for (auto* current = root; current; current = current-&gt;nextInPreOrder()) {
617         if (!is&lt;WebCore::RenderElement&gt;(*current))
618             continue;
619         fprintf(stderr, &quot;%c&quot;, (current == renderer) ? &#39;*&#39; : &#39; &#39;);
620         for (auto* ancestor = current; ancestor &amp;&amp; ancestor != root; ancestor = ancestor-&gt;parent())
621             fprintf(stderr, &quot;    &quot;);
622         fprintf(stderr, &quot;%p N:%p P:%p PS:%p NS:%p C:%p\n&quot;,
623             current, current-&gt;node(), current-&gt;parent(), current-&gt;previousSibling(),
624             current-&gt;nextSibling(), downcast&lt;WebCore::RenderElement&gt;(*current).hasCounterNodeMap() ?
625             counterName ? WebCore::counterMaps().find(downcast&lt;WebCore::RenderElement&gt;(current))-&gt;value-&gt;get(identifier) : (WebCore::CounterNode*)1 : (WebCore::CounterNode*)0);
626     }
627     fflush(stderr);
628 }
629 
630 #endif // NDEBUG
    </pre>
  </body>
</html>
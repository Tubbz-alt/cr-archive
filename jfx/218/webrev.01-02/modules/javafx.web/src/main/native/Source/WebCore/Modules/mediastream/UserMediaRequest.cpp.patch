diff a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/UserMediaRequest.cpp b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/UserMediaRequest.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/UserMediaRequest.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/UserMediaRequest.cpp
@@ -36,19 +36,20 @@
 
 #if ENABLE(MEDIA_STREAM)
 
 #include "Document.h"
 #include "Frame.h"
+#include "JSDOMPromiseDeferred.h"
 #include "JSMediaStream.h"
 #include "JSOverconstrainedError.h"
 #include "Logging.h"
 #include "MediaConstraints.h"
 #include "PlatformMediaSessionManager.h"
 #include "RealtimeMediaSourceCenter.h"
-#include "SchemeRegistry.h"
 #include "Settings.h"
 #include "UserMediaController.h"
+#include "WindowEventLoop.h"
 #include <wtf/Scope.h>
 
 namespace WebCore {
 
 Ref<UserMediaRequest> UserMediaRequest::create(Document& document, MediaStreamRequest&& request, DOMPromiseDeferred<IDLInterface<MediaStream>>&& promise)
@@ -58,16 +59,21 @@
     return result;
 }
 
 UserMediaRequest::UserMediaRequest(Document& document, MediaStreamRequest&& request, DOMPromiseDeferred<IDLInterface<MediaStream>>&& promise)
     : ActiveDOMObject(document)
-    , m_promise(WTFMove(promise))
+    , m_identifier(UserMediaRequestIdentifier::generate())
+    , m_promise(makeUniqueRef<DOMPromiseDeferred<IDLInterface<MediaStream>>>(WTFMove(promise)))
     , m_request(WTFMove(request))
 {
 }
 
-UserMediaRequest::~UserMediaRequest() = default;
+UserMediaRequest::~UserMediaRequest()
+{
+    if (m_allowCompletionHandler)
+        m_allowCompletionHandler();
+}
 
 SecurityOrigin* UserMediaRequest::userMediaDocumentOrigin() const
 {
     if (!m_scriptExecutionContext)
         return nullptr;
@@ -190,73 +196,95 @@
     //     or due to platform limitations, jump to the step labeled Permission Failure below.
     // ...
     // 6.10 Permission Failure: Reject p with a new DOMException object whose name attribute has
     //      the value NotAllowedError.
 
-    OptionSet<UserMediaController::CaptureType> types;
-    UserMediaController::BlockedCaller caller;
-    if (m_request.type == MediaStreamRequest::Type::DisplayMedia) {
-        types.add(UserMediaController::CaptureType::Display);
-        caller = UserMediaController::BlockedCaller::GetDisplayMedia;
-    } else {
-        if (m_request.audioConstraints.isValid)
-            types.add(UserMediaController::CaptureType::Microphone);
-        if (m_request.videoConstraints.isValid)
-            types.add(UserMediaController::CaptureType::Camera);
-        caller = UserMediaController::BlockedCaller::GetUserMedia;
-    }
-    auto access = controller->canCallGetUserMedia(document, types);
-    if (access != UserMediaController::GetUserMediaAccess::CanCall) {
-        deny(MediaAccessDenialReason::PermissionDenied);
-        controller->logGetUserMediaDenial(document, access, caller);
-        return;
+    switch (m_request.type) {
+    case MediaStreamRequest::Type::DisplayMedia:
+        if (!isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::DisplayCapture, document)) {
+            deny(MediaAccessDenialReason::PermissionDenied);
+            controller->logGetDisplayMediaDenial(document);
+            return;
+        }
+        break;
+    case MediaStreamRequest::Type::UserMedia:
+        if (m_request.audioConstraints.isValid && !isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::Microphone, document)) {
+            deny(MediaAccessDenialReason::PermissionDenied);
+            controller->logGetUserMediaDenial(document);
+            return;
+        }
+        if (m_request.videoConstraints.isValid && !isFeaturePolicyAllowedByDocumentAndAllOwners(FeaturePolicy::Type::Camera, document)) {
+            deny(MediaAccessDenialReason::PermissionDenied);
+            controller->logGetUserMediaDenial(document);
+            return;
+        }
+        break;
     }
 
     PlatformMediaSessionManager::sharedManager().prepareToSendUserMediaPermissionRequest();
     controller->requestUserMediaAccess(*this);
 }
 
+static inline bool isMediaStreamCorrectlyStarted(const MediaStream& stream)
+{
+    if (stream.getTracks().isEmpty())
+        return false;
+
+    return WTF::allOf(stream.getTracks(), [](auto& track) {
+        return !track->source().captureDidFail();
+    });
+}
+
 void UserMediaRequest::allow(CaptureDevice&& audioDevice, CaptureDevice&& videoDevice, String&& deviceIdentifierHashSalt, CompletionHandler<void()>&& completionHandler)
 {
     RELEASE_LOG(MediaStream, "UserMediaRequest::allow %s %s", audioDevice ? audioDevice.persistentId().utf8().data() : "", videoDevice ? videoDevice.persistentId().utf8().data() : "");
+    m_allowCompletionHandler = WTFMove(completionHandler);
+    queueTaskKeepingObjectAlive(*this, TaskSource::UserInteraction, [this, audioDevice = WTFMove(audioDevice), videoDevice = WTFMove(videoDevice), deviceIdentifierHashSalt = WTFMove(deviceIdentifierHashSalt)]() mutable {
+        auto callback = [this, protector = makePendingActivity(*this)](auto privateStreamOrError) mutable {
+            auto scopeExit = makeScopeExit([completionHandler = WTFMove(m_allowCompletionHandler)]() mutable {
+                completionHandler();
+            });
+            if (isContextStopped())
+                return;
+
+            if (!privateStreamOrError.has_value()) {
+                RELEASE_LOG(MediaStream, "UserMediaRequest::allow failed to create media stream!");
+                scriptExecutionContext()->addConsoleMessage(MessageSource::JS, MessageLevel::Error, privateStreamOrError.error());
+                deny(MediaAccessDenialReason::HardwareError);
+                return;
+            }
+            auto privateStream = WTFMove(privateStreamOrError).value();
+
+            auto& document = downcast<Document>(*m_scriptExecutionContext);
+            privateStream->monitorOrientation(document.orientationNotifier());
+
+            auto stream = MediaStream::create(document, WTFMove(privateStream));
+            stream->startProducingData();
+
+            if (!isMediaStreamCorrectlyStarted(stream)) {
+                deny(MediaAccessDenialReason::HardwareError);
+                return;
+            }
+
+            ASSERT(document.isCapturing());
+            stream->document()->setHasCaptureMediaStreamTrack();
+            m_promise->resolve(WTFMove(stream));
+        };
+
+        auto& document = downcast<Document>(*scriptExecutionContext());
+        document.setDeviceIDHashSalt(deviceIdentifierHashSalt);
+
+        RealtimeMediaSourceCenter::singleton().createMediaStream(document.logger(), WTFMove(callback), WTFMove(deviceIdentifierHashSalt), WTFMove(audioDevice), WTFMove(videoDevice), m_request);
 
-    auto callback = [this, protector = makePendingActivity(*this), completionHandler = WTFMove(completionHandler)](RefPtr<MediaStreamPrivate>&& privateStream) mutable {
-        auto scopeExit = makeScopeExit([&] {
-            completionHandler();
-        });
         if (!m_scriptExecutionContext)
             return;
 
-        if (!privateStream) {
-            RELEASE_LOG(MediaStream, "UserMediaRequest::allow failed to create media stream!");
-            deny(MediaAccessDenialReason::HardwareError);
-            return;
-        }
-        privateStream->monitorOrientation(downcast<Document>(m_scriptExecutionContext)->orientationNotifier());
-
-        auto stream = MediaStream::create(*downcast<Document>(m_scriptExecutionContext), privateStream.releaseNonNull());
-        if (stream->getTracks().isEmpty()) {
-            deny(MediaAccessDenialReason::HardwareError);
-            return;
-        }
-
-        scopeExit.release();
-        m_pendingActivationMediaStream = makeUnique<PendingActivationMediaStream>(WTFMove(protector), *this, WTFMove(stream), WTFMove(completionHandler));
-    };
-
-    auto& document = downcast<Document>(*scriptExecutionContext());
-    document.setDeviceIDHashSalt(deviceIdentifierHashSalt);
-
-    RealtimeMediaSourceCenter::singleton().createMediaStream(document.logger(), WTFMove(callback), WTFMove(deviceIdentifierHashSalt), WTFMove(audioDevice), WTFMove(videoDevice), m_request);
-
-    if (!m_scriptExecutionContext)
-        return;
-
 #if ENABLE(WEB_RTC)
-    if (auto* page = document.page())
-        page->rtcController().disableICECandidateFilteringForDocument(document);
+        if (auto* page = document.page())
+            page->rtcController().disableICECandidateFilteringForDocument(document);
 #endif
+    });
 }
 
 void UserMediaRequest::deny(MediaAccessDenialReason reason, const String& message)
 {
     if (!m_scriptExecutionContext)
@@ -280,11 +308,11 @@
         RELEASE_LOG(MediaStream, "UserMediaRequest::deny - no capture devices");
         code = NotFoundError;
         break;
     case MediaAccessDenialReason::InvalidConstraint:
         RELEASE_LOG(MediaStream, "UserMediaRequest::deny - invalid constraint - %s", message.utf8().data());
-        m_promise.rejectType<IDLInterface<OverconstrainedError>>(OverconstrainedError::create(message, "Invalid constraint"_s).get());
+        m_promise->rejectType<IDLInterface<OverconstrainedError>>(OverconstrainedError::create(message, "Invalid constraint"_s).get());
         return;
     case MediaAccessDenialReason::HardwareError:
         RELEASE_LOG(MediaStream, "UserMediaRequest::deny - hardware error");
         code = NotReadableError;
         break;
@@ -301,86 +329,32 @@
         code = InvalidAccessError;
         break;
     }
 
     if (!message.isEmpty())
-        m_promise.reject(code, message);
+        m_promise->reject(code, message);
     else
-        m_promise.reject(code);
+        m_promise->reject(code);
 }
 
 void UserMediaRequest::stop()
 {
-    // Protecting 'this' since nulling m_pendingActivationMediaStream might destroy it.
-    Ref<UserMediaRequest> protectedThis(*this);
-
-    m_pendingActivationMediaStream = nullptr;
-
     auto& document = downcast<Document>(*m_scriptExecutionContext);
     if (auto* controller = UserMediaController::from(document.page()))
         controller->cancelUserMediaAccessRequest(*this);
 }
 
 const char* UserMediaRequest::activeDOMObjectName() const
 {
     return "UserMediaRequest";
 }
 
-bool UserMediaRequest::canSuspendForDocumentSuspension() const
-{
-    return !hasPendingActivity();
-}
-
 Document* UserMediaRequest::document() const
 {
     return downcast<Document>(m_scriptExecutionContext);
 }
 
-UserMediaRequest::PendingActivationMediaStream::PendingActivationMediaStream(Ref<PendingActivity<UserMediaRequest>>&& protectingUserMediaRequest, UserMediaRequest& userMediaRequest, Ref<MediaStream>&& stream, CompletionHandler<void()>&& completionHandler)
-    : m_protectingUserMediaRequest(WTFMove(protectingUserMediaRequest))
-    , m_userMediaRequest(userMediaRequest)
-    , m_mediaStream(WTFMove(stream))
-    , m_completionHandler(WTFMove(completionHandler))
-{
-    m_mediaStream->privateStream().addObserver(*this);
-    m_mediaStream->startProducingData();
-}
-
-UserMediaRequest::PendingActivationMediaStream::~PendingActivationMediaStream()
-{
-    m_mediaStream->privateStream().removeObserver(*this);
-    m_completionHandler();
-    if (auto* document = m_mediaStream->document())
-        document->updateIsPlayingMedia();
-}
-
-void UserMediaRequest::PendingActivationMediaStream::characteristicsChanged()
-{
-    if (!m_userMediaRequest.m_pendingActivationMediaStream)
-        return;
-
-    for (auto& track : m_mediaStream->privateStream().tracks()) {
-        if (track->source().captureDidFail()) {
-            m_userMediaRequest.mediaStreamDidFail(track->source().type());
-            return;
-        }
-    }
-
-    if (m_mediaStream->privateStream().hasVideo() || m_mediaStream->privateStream().hasAudio()) {
-        m_userMediaRequest.mediaStreamIsReady(WTFMove(m_mediaStream));
-        return;
-    }
-}
-
-void UserMediaRequest::mediaStreamIsReady(Ref<MediaStream>&& stream)
-{
-    RELEASE_LOG(MediaStream, "UserMediaRequest::mediaStreamIsReady");
-    stream->document()->setHasCaptureMediaStreamTrack();
-    m_promise.resolve(WTFMove(stream));
-    m_pendingActivationMediaStream = nullptr;
-}
-
 void UserMediaRequest::mediaStreamDidFail(RealtimeMediaSource::Type type)
 {
     RELEASE_LOG(MediaStream, "UserMediaRequest::mediaStreamDidFail");
     const char* typeDescription = "";
     switch (type) {
@@ -392,12 +366,11 @@
         break;
     case RealtimeMediaSource::Type::None:
         typeDescription = "unknown";
         break;
     }
-    m_promise.reject(NotReadableError, makeString("Failed starting capture of a "_s, typeDescription, " track"_s));
-    m_pendingActivationMediaStream = nullptr;
+    m_promise->reject(NotReadableError, makeString("Failed starting capture of a "_s, typeDescription, " track"_s));
 }
 
 } // namespace WebCore
 
 #endif // ENABLE(MEDIA_STREAM)

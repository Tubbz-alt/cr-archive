diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGWorklist.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGWorklist.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGWorklist.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGWorklist.cpp
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
+ * Copyright (C) 2013-2020 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -103,16 +103,15 @@
             if (m_plan->stage() == Plan::Cancelled)
                 return WorkResult::Continue;
             m_plan->notifyCompiling();
         }
 
-        if (Options::verboseCompilationQueue())
-            dataLog(m_worklist, ": Compiling ", m_plan->key(), " asynchronously\n");
+        dataLogLnIf(Options::verboseCompilationQueue(), m_worklist, ": Compiling ", m_plan->key(), " asynchronously");
 
         // There's no way for the GC to be safepointing since we own rightToRun.
         if (m_plan->vm()->heap.worldIsStopped()) {
-            dataLog("Heap is stoped but here we are! (1)\n");
+            dataLog("Heap is stopped but here we are! (1)\n");
             RELEASE_ASSERT_NOT_REACHED();
         }
         m_plan->compileInThread(&m_data);
         if (m_plan->stage() != Plan::Cancelled) {
             if (m_plan->vm()->heap.worldIsStopped()) {
@@ -131,23 +130,21 @@
             if (Options::verboseCompilationQueue()) {
                 m_worklist.dump(locker, WTF::dataFile());
                 dataLog(": Compiled ", m_plan->key(), " asynchronously\n");
             }
 
-            m_worklist.m_readyPlans.append(m_plan);
-
             RELEASE_ASSERT(!m_plan->vm()->heap.worldIsStopped());
+            m_worklist.m_readyPlans.append(WTFMove(m_plan));
             m_worklist.m_planCompiled.notifyAll();
         }
 
         return WorkResult::Continue;
     }
 
     void threadDidStart() override
     {
-        if (Options::verboseCompilationQueue())
-            dataLog(m_worklist, ": Thread started\n");
+        dataLogLnIf(Options::verboseCompilationQueue(), m_worklist, ": Thread started");
 
         if (m_relativePriority)
             Thread::current().changePriority(m_relativePriority);
 
         m_compilationScope = makeUnique<CompilationScope>();
@@ -155,12 +152,11 @@
 
     void threadIsStopping(const AbstractLocker&) override
     {
         // We're holding the Worklist::m_lock, so we should be careful not to deadlock.
 
-        if (Options::verboseCompilationQueue())
-            dataLog(m_worklist, ": Thread will stop\n");
+        dataLogLnIf(Options::verboseCompilationQueue(), m_worklist, ": Thread will stop");
 
         ASSERT(!m_plan);
 
         m_compilationScope = nullptr;
         m_plan = nullptr;
@@ -335,12 +331,11 @@
 
     while (!myReadyPlans.isEmpty()) {
         RefPtr<Plan> plan = myReadyPlans.takeLast();
         CompilationKey currentKey = plan->key();
 
-        if (Options::verboseCompilationQueue())
-            dataLog(*this, ": Completing ", currentKey, "\n");
+        dataLogLnIf(Options::verboseCompilationQueue(), *this, ": Completing ", currentKey);
 
         RELEASE_ASSERT(plan->stage() == Plan::Ready);
 
         plan->finalizeAndNotifyCallback();
 

diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOpcodes.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOpcodes.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOpcodes.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITOpcodes.cpp
@@ -27,11 +27,11 @@
 #include "config.h"
 #if ENABLE(JIT)
 #include "JIT.h"
 
 #include "BasicBlockLocation.h"
-#include "BytecodeStructs.h"
+#include "BytecodeGenerator.h"
 #include "Exception.h"
 #include "Heap.h"
 #include "InterpreterInlines.h"
 #include "JITInlines.h"
 #include "JSArray.h"
@@ -54,14 +54,14 @@
 #if USE(JSVALUE64)
 
 void JIT::emit_op_mov(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpMov>();
-    int dst = bytecode.m_dst.offset();
-    int src = bytecode.m_src.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister src = bytecode.m_src;
 
-    if (m_codeBlock->isConstantRegisterIndex(src)) {
+    if (src.isConstant()) {
         JSValue value = m_codeBlock->getConstant(src);
         if (!value.isNumber())
             store64(TrustedImm64(JSValue::encode(value)), addressFor(dst));
         else
             store64(Imm64(JSValue::encode(value)), addressFor(dst));
@@ -75,11 +75,11 @@
 
 void JIT::emit_op_end(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpEnd>();
     RELEASE_ASSERT(returnValueGPR != callFrameRegister);
-    emitGetVirtualRegister(bytecode.m_value.offset(), returnValueGPR);
+    emitGetVirtualRegister(bytecode.m_value, returnValueGPR);
     emitRestoreCalleeSaves();
     emitFunctionEpilogue();
     ret();
 }
 
@@ -108,32 +108,32 @@
         JumpList slowCases;
         auto butterfly = TrustedImmPtr(nullptr);
         emitAllocateJSObject(resultReg, JITAllocator::constant(allocator), allocatorReg, TrustedImmPtr(structure), butterfly, scratchReg, slowCases);
         emitInitializeInlineStorage(resultReg, structure->inlineCapacity());
         addSlowCase(slowCases);
-        emitPutVirtualRegister(bytecode.m_dst.offset());
+        emitPutVirtualRegister(bytecode.m_dst);
     }
 }
 
 void JIT::emitSlow_op_new_object(const Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
 {
     linkAllSlowCases(iter);
 
     auto bytecode = currentInstruction->as<OpNewObject>();
     auto& metadata = bytecode.metadata(m_codeBlock);
-    int dst = bytecode.m_dst.offset();
+    VirtualRegister dst = bytecode.m_dst;
     Structure* structure = metadata.m_objectAllocationProfile.structure();
-    callOperation(operationNewObject, structure);
+    callOperation(operationNewObject, TrustedImmPtr(&vm()), structure);
     emitStoreCell(dst, returnValueGPR);
 }
 
 void JIT::emit_op_overrides_has_instance(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpOverridesHasInstance>();
-    int dst = bytecode.m_dst.offset();
-    int constructor = bytecode.m_constructor.offset();
-    int hasInstanceValue = bytecode.m_hasInstanceValue.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister constructor = bytecode.m_constructor;
+    VirtualRegister hasInstanceValue = bytecode.m_hasInstanceValue;
 
     emitGetVirtualRegister(hasInstanceValue, regT0);
 
     // We don't jump if we know what Symbol.hasInstance would do.
     Jump customhasInstanceValue = branchPtr(NotEqual, regT0, TrustedImmPtr(m_codeBlock->globalObject()->functionProtoHasInstanceSymbolFunction()));
@@ -144,22 +144,22 @@
     test8(Zero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(ImplementsDefaultHasInstance), regT0);
     boxBoolean(regT0, JSValueRegs { regT0 });
     Jump done = jump();
 
     customhasInstanceValue.link(this);
-    move(TrustedImm32(ValueTrue), regT0);
+    move(TrustedImm32(JSValue::ValueTrue), regT0);
 
     done.link(this);
     emitPutVirtualRegister(dst);
 }
 
 void JIT::emit_op_instanceof(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpInstanceof>();
-    int dst = bytecode.m_dst.offset();
-    int value = bytecode.m_value.offset();
-    int proto = bytecode.m_prototype.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister value = bytecode.m_value;
+    VirtualRegister proto = bytecode.m_prototype;
 
     // Load the operands (baseVal, proto, and value respectively) into registers.
     // We use regT0 for baseVal since we will be done with this first, and we can then use it for the result.
     emitGetVirtualRegister(value, regT2);
     emitGetVirtualRegister(proto, regT1);
@@ -167,11 +167,11 @@
     // Check that proto are cells. baseVal must be a cell - this is checked by the get_by_id for Symbol.hasInstance.
     emitJumpSlowCaseIfNotJSCell(regT2, value);
     emitJumpSlowCaseIfNotJSCell(regT1, proto);
 
     JITInstanceOfGenerator gen(
-        m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(m_bytecodeOffset),
+        m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex),
         RegisterSet::stubUnavailableRegisters(),
         regT0, // result
         regT2, // value
         regT1, // proto
         regT3, regT4); // scratch
@@ -184,16 +184,16 @@
 void JIT::emitSlow_op_instanceof(const Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
 {
     linkAllSlowCases(iter);
 
     auto bytecode = currentInstruction->as<OpInstanceof>();
-    int resultVReg = bytecode.m_dst.offset();
+    VirtualRegister resultVReg = bytecode.m_dst;
 
     JITInstanceOfGenerator& gen = m_instanceOfs[m_instanceOfIndex++];
 
     Label coldPathBegin = label();
-    Call call = callOperation(operationInstanceOfOptimize, resultVReg, gen.stubInfo(), regT2, regT1);
+    Call call = callOperation(operationInstanceOfOptimize, resultVReg, TrustedImmPtr(m_codeBlock->globalObject()), gen.stubInfo(), regT2, regT1);
     gen.reportSlowPathCall(coldPathBegin, call);
 }
 
 void JIT::emit_op_instanceof_custom(const Instruction*)
 {
@@ -202,12 +202,12 @@
 }
 
 void JIT::emit_op_is_empty(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpIsEmpty>();
-    int dst = bytecode.m_dst.offset();
-    int value = bytecode.m_operand.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister value = bytecode.m_operand;
 
     emitGetVirtualRegister(value, regT0);
     compare64(Equal, regT0, TrustedImm32(JSValue::encode(JSValue())), regT0);
 
     boxBoolean(regT0, JSValueRegs { regT0 });
@@ -215,17 +215,17 @@
 }
 
 void JIT::emit_op_is_undefined(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpIsUndefined>();
-    int dst = bytecode.m_dst.offset();
-    int value = bytecode.m_operand.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister value = bytecode.m_operand;
 
     emitGetVirtualRegister(value, regT0);
     Jump isCell = branchIfCell(regT0);
 
-    compare64(Equal, regT0, TrustedImm32(ValueUndefined), regT0);
+    compare64(Equal, regT0, TrustedImm32(JSValue::ValueUndefined), regT0);
     Jump done = jump();
 
     isCell.link(this);
     Jump isMasqueradesAsUndefined = branchTest8(NonZero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
     move(TrustedImm32(0), regT0);
@@ -244,83 +244,83 @@
 }
 
 void JIT::emit_op_is_undefined_or_null(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpIsUndefinedOrNull>();
-    int dst = bytecode.m_dst.offset();
-    int value = bytecode.m_operand.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister value = bytecode.m_operand;
 
     emitGetVirtualRegister(value, regT0);
 
-    and64(TrustedImm32(~TagBitUndefined), regT0);
-    compare64(Equal, regT0, TrustedImm32(ValueNull), regT0);
+    and64(TrustedImm32(~JSValue::UndefinedTag), regT0);
+    compare64(Equal, regT0, TrustedImm32(JSValue::ValueNull), regT0);
 
     boxBoolean(regT0, JSValueRegs { regT0 });
     emitPutVirtualRegister(dst);
 }
 
 void JIT::emit_op_is_boolean(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpIsBoolean>();
-    int dst = bytecode.m_dst.offset();
-    int value = bytecode.m_operand.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister value = bytecode.m_operand;
 
     emitGetVirtualRegister(value, regT0);
-    xor64(TrustedImm32(static_cast<int32_t>(ValueFalse)), regT0);
+    xor64(TrustedImm32(JSValue::ValueFalse), regT0);
     test64(Zero, regT0, TrustedImm32(static_cast<int32_t>(~1)), regT0);
     boxBoolean(regT0, JSValueRegs { regT0 });
     emitPutVirtualRegister(dst);
 }
 
 void JIT::emit_op_is_number(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpIsNumber>();
-    int dst = bytecode.m_dst.offset();
-    int value = bytecode.m_operand.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister value = bytecode.m_operand;
 
     emitGetVirtualRegister(value, regT0);
-    test64(NonZero, regT0, tagTypeNumberRegister, regT0);
+    test64(NonZero, regT0, numberTagRegister, regT0);
     boxBoolean(regT0, JSValueRegs { regT0 });
     emitPutVirtualRegister(dst);
 }
 
 void JIT::emit_op_is_cell_with_type(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpIsCellWithType>();
-    int dst = bytecode.m_dst.offset();
-    int value = bytecode.m_operand.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister value = bytecode.m_operand;
     int type = bytecode.m_type;
 
     emitGetVirtualRegister(value, regT0);
     Jump isNotCell = branchIfNotCell(regT0);
 
     compare8(Equal, Address(regT0, JSCell::typeInfoTypeOffset()), TrustedImm32(type), regT0);
     boxBoolean(regT0, JSValueRegs { regT0 });
     Jump done = jump();
 
     isNotCell.link(this);
-    move(TrustedImm32(ValueFalse), regT0);
+    move(TrustedImm32(JSValue::ValueFalse), regT0);
 
     done.link(this);
     emitPutVirtualRegister(dst);
 }
 
 void JIT::emit_op_is_object(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpIsObject>();
-    int dst = bytecode.m_dst.offset();
-    int value = bytecode.m_operand.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister value = bytecode.m_operand;
 
     emitGetVirtualRegister(value, regT0);
     Jump isNotCell = branchIfNotCell(regT0);
 
     compare8(AboveOrEqual, Address(regT0, JSCell::typeInfoTypeOffset()), TrustedImm32(ObjectType), regT0);
     boxBoolean(regT0, JSValueRegs { regT0 });
     Jump done = jump();
 
     isNotCell.link(this);
-    move(TrustedImm32(ValueFalse), regT0);
+    move(TrustedImm32(JSValue::ValueFalse), regT0);
 
     done.link(this);
     emitPutVirtualRegister(dst);
 }
 
@@ -330,23 +330,23 @@
     ASSERT(regT1 != returnValueGPR);
     ASSERT(returnValueGPR != callFrameRegister);
 
     // Return the result in %eax.
     auto bytecode = currentInstruction->as<OpRet>();
-    emitGetVirtualRegister(bytecode.m_value.offset(), returnValueGPR);
+    emitGetVirtualRegister(bytecode.m_value, returnValueGPR);
 
     checkStackPointerAlignment();
     emitRestoreCalleeSaves();
     emitFunctionEpilogue();
     ret();
 }
 
 void JIT::emit_op_to_primitive(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpToPrimitive>();
-    int dst = bytecode.m_dst.offset();
-    int src = bytecode.m_src.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister src = bytecode.m_src;
 
     emitGetVirtualRegister(src, regT0);
 
     Jump isImm = branchIfNotCell(regT0);
     addSlowCase(branchIfObject(regT0));
@@ -355,31 +355,48 @@
     if (dst != src)
         emitPutVirtualRegister(dst);
 
 }
 
+void JIT::emit_op_to_property_key(const Instruction* currentInstruction)
+{
+    auto bytecode = currentInstruction->as<OpToPropertyKey>();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister src = bytecode.m_src;
+
+    emitGetVirtualRegister(src, regT0);
+
+    addSlowCase(branchIfNotCell(regT0));
+    Jump done = branchIfSymbol(regT0);
+    addSlowCase(branchIfNotString(regT0));
+
+    done.link(this);
+    if (src != dst)
+        emitPutVirtualRegister(dst);
+}
+
 void JIT::emit_op_set_function_name(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpSetFunctionName>();
-    emitGetVirtualRegister(bytecode.m_function.offset(), regT0);
-    emitGetVirtualRegister(bytecode.m_name.offset(), regT1);
-    callOperation(operationSetFunctionName, regT0, regT1);
+    emitGetVirtualRegister(bytecode.m_function, regT0);
+    emitGetVirtualRegister(bytecode.m_name, regT1);
+    callOperation(operationSetFunctionName, TrustedImmPtr(m_codeBlock->globalObject()), regT0, regT1);
 }
 
 void JIT::emit_op_not(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpNot>();
-    emitGetVirtualRegister(bytecode.m_operand.offset(), regT0);
+    emitGetVirtualRegister(bytecode.m_operand, regT0);
 
     // Invert against JSValue(false); if the value was tagged as a boolean, then all bits will be
     // clear other than the low bit (which will be 0 or 1 for false or true inputs respectively).
     // Then invert against JSValue(true), which will add the tag back in, and flip the low bit.
-    xor64(TrustedImm32(static_cast<int32_t>(ValueFalse)), regT0);
+    xor64(TrustedImm32(JSValue::ValueFalse), regT0);
     addSlowCase(branchTestPtr(NonZero, regT0, TrustedImm32(static_cast<int32_t>(~1))));
-    xor64(TrustedImm32(static_cast<int32_t>(ValueTrue)), regT0);
+    xor64(TrustedImm32(JSValue::ValueTrue), regT0);
 
-    emitPutVirtualRegister(bytecode.m_dst.offset());
+    emitPutVirtualRegister(bytecode.m_dst);
 }
 
 void JIT::emit_op_jfalse(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpJfalse>();
@@ -388,18 +405,18 @@
     GPRReg value = regT0;
     GPRReg scratch1 = regT1;
     GPRReg scratch2 = regT2;
     bool shouldCheckMasqueradesAsUndefined = true;
 
-    emitGetVirtualRegister(bytecode.m_condition.offset(), value);
+    emitGetVirtualRegister(bytecode.m_condition, value);
     addJump(branchIfFalsey(vm(), JSValueRegs(value), scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock->globalObject()), target);
 }
 
 void JIT::emit_op_jeq_null(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpJeqNull>();
-    int src = bytecode.m_value.offset();
+    VirtualRegister src = bytecode.m_value;
     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
 
     emitGetVirtualRegister(src, regT0);
     Jump isImmediate = branchIfNotCell(regT0);
 
@@ -410,20 +427,20 @@
     addJump(branchPtr(Equal, Address(regT2, Structure::globalObjectOffset()), regT0), target);
     Jump masqueradesGlobalObjectIsForeign = jump();
 
     // Now handle the immediate cases - undefined & null
     isImmediate.link(this);
-    and64(TrustedImm32(~TagBitUndefined), regT0);
+    and64(TrustedImm32(~JSValue::UndefinedTag), regT0);
     addJump(branch64(Equal, regT0, TrustedImm64(JSValue::encode(jsNull()))), target);
 
     isNotMasqueradesAsUndefined.link(this);
     masqueradesGlobalObjectIsForeign.link(this);
 };
 void JIT::emit_op_jneq_null(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpJneqNull>();
-    int src = bytecode.m_value.offset();
+    VirtualRegister src = bytecode.m_value;
     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
 
     emitGetVirtualRegister(src, regT0);
     Jump isImmediate = branchIfNotCell(regT0);
 
@@ -434,70 +451,71 @@
     addJump(branchPtr(NotEqual, Address(regT2, Structure::globalObjectOffset()), regT0), target);
     Jump wasNotImmediate = jump();
 
     // Now handle the immediate cases - undefined & null
     isImmediate.link(this);
-    and64(TrustedImm32(~TagBitUndefined), regT0);
+    and64(TrustedImm32(~JSValue::UndefinedTag), regT0);
     addJump(branch64(NotEqual, regT0, TrustedImm64(JSValue::encode(jsNull()))), target);
 
     wasNotImmediate.link(this);
 }
 
 void JIT::emit_op_jundefined_or_null(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpJundefinedOrNull>();
-    int value = bytecode.m_value.offset();
+    VirtualRegister value = bytecode.m_value;
     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
 
     emitGetVirtualRegister(value, regT0);
 
-    and64(TrustedImm32(~TagBitUndefined), regT0);
+    and64(TrustedImm32(~JSValue::UndefinedTag), regT0);
     addJump(branch64(Equal, regT0, TrustedImm64(JSValue::encode(jsNull()))), target);
 }
 
 void JIT::emit_op_jnundefined_or_null(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpJnundefinedOrNull>();
-    int value = bytecode.m_value.offset();
+    VirtualRegister value = bytecode.m_value;
     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
 
     emitGetVirtualRegister(value, regT0);
 
-    and64(TrustedImm32(~TagBitUndefined), regT0);
+    and64(TrustedImm32(~JSValue::UndefinedTag), regT0);
     addJump(branch64(NotEqual, regT0, TrustedImm64(JSValue::encode(jsNull()))), target);
 }
 
 void JIT::emit_op_jneq_ptr(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpJneqPtr>();
     auto& metadata = bytecode.metadata(m_codeBlock);
-    int src = bytecode.m_value.offset();
-    Special::Pointer ptr = bytecode.m_specialPointer;
+    VirtualRegister src = bytecode.m_value;
+    JSValue specialPointer = getConstantOperand(bytecode.m_specialPointer);
+    ASSERT(specialPointer.isCell());
     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
 
     emitGetVirtualRegister(src, regT0);
-    CCallHelpers::Jump equal = branchPtr(Equal, regT0, TrustedImmPtr(actualPointerFor(m_codeBlock, ptr)));
+    CCallHelpers::Jump equal = branchPtr(Equal, regT0, TrustedImmPtr(specialPointer.asCell()));
     store8(TrustedImm32(1), &metadata.m_hasJumped);
     addJump(jump(), target);
     equal.link(this);
 }
 
 void JIT::emit_op_eq(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpEq>();
-    emitGetVirtualRegisters(bytecode.m_lhs.offset(), regT0, bytecode.m_rhs.offset(), regT1);
+    emitGetVirtualRegisters(bytecode.m_lhs, regT0, bytecode.m_rhs, regT1);
     emitJumpSlowCaseIfNotInt(regT0, regT1, regT2);
     compare32(Equal, regT1, regT0, regT0);
     boxBoolean(regT0, JSValueRegs { regT0 });
-    emitPutVirtualRegister(bytecode.m_dst.offset());
+    emitPutVirtualRegister(bytecode.m_dst);
 }
 
 void JIT::emit_op_jeq(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpJeq>();
     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
-    emitGetVirtualRegisters(bytecode.m_lhs.offset(), regT0, bytecode.m_rhs.offset(), regT1);
+    emitGetVirtualRegisters(bytecode.m_lhs, regT0, bytecode.m_rhs, regT1);
     emitJumpSlowCaseIfNotInt(regT0, regT1, regT2);
     addJump(branch32(Equal, regT0, regT1), target);
 }
 
 void JIT::emit_op_jtrue(const Instruction* currentInstruction)
@@ -507,51 +525,51 @@
 
     GPRReg value = regT0;
     GPRReg scratch1 = regT1;
     GPRReg scratch2 = regT2;
     bool shouldCheckMasqueradesAsUndefined = true;
-    emitGetVirtualRegister(bytecode.m_condition.offset(), value);
+    emitGetVirtualRegister(bytecode.m_condition, value);
     addJump(branchIfTruthy(vm(), JSValueRegs(value), scratch1, scratch2, fpRegT0, fpRegT1, shouldCheckMasqueradesAsUndefined, m_codeBlock->globalObject()), target);
 }
 
 void JIT::emit_op_neq(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpNeq>();
-    emitGetVirtualRegisters(bytecode.m_lhs.offset(), regT0, bytecode.m_rhs.offset(), regT1);
+    emitGetVirtualRegisters(bytecode.m_lhs, regT0, bytecode.m_rhs, regT1);
     emitJumpSlowCaseIfNotInt(regT0, regT1, regT2);
     compare32(NotEqual, regT1, regT0, regT0);
     boxBoolean(regT0, JSValueRegs { regT0 });
 
-    emitPutVirtualRegister(bytecode.m_dst.offset());
+    emitPutVirtualRegister(bytecode.m_dst);
 }
 
 void JIT::emit_op_jneq(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpJneq>();
     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
-    emitGetVirtualRegisters(bytecode.m_lhs.offset(), regT0, bytecode.m_rhs.offset(), regT1);
+    emitGetVirtualRegisters(bytecode.m_lhs, regT0, bytecode.m_rhs, regT1);
     emitJumpSlowCaseIfNotInt(regT0, regT1, regT2);
     addJump(branch32(NotEqual, regT0, regT1), target);
 }
 
 void JIT::emit_op_throw(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpThrow>();
     ASSERT(regT0 == returnValueGPR);
     copyCalleeSavesToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);
-    emitGetVirtualRegister(bytecode.m_value.offset(), regT0);
-    callOperationNoExceptionCheck(operationThrow, regT0);
+    emitGetVirtualRegister(bytecode.m_value, regT0);
+    callOperationNoExceptionCheck(operationThrow, TrustedImmPtr(m_codeBlock->globalObject()), regT0);
     jumpToExceptionHandler(vm());
 }
 
 template<typename Op>
 void JIT::compileOpStrictEq(const Instruction* currentInstruction, CompileOpStrictEqType type)
 {
     auto bytecode = currentInstruction->as<Op>();
-    int dst = bytecode.m_dst.offset();
-    int src1 = bytecode.m_lhs.offset();
-    int src2 = bytecode.m_rhs.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister src1 = bytecode.m_lhs;
+    VirtualRegister src2 = bytecode.m_rhs;
 
     emitGetVirtualRegisters(src1, regT0, src2, regT1);
 
     // Jump slow if both are cells (to cover strings).
     move(regT0, regT2);
@@ -589,12 +607,12 @@
 template<typename Op>
 void JIT::compileOpStrictEqJump(const Instruction* currentInstruction, CompileOpStrictEqType type)
 {
     auto bytecode = currentInstruction->as<Op>();
     int target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
-    int src1 = bytecode.m_lhs.offset();
-    int src2 = bytecode.m_rhs.offset();
+    VirtualRegister src1 = bytecode.m_lhs;
+    VirtualRegister src2 = bytecode.m_rhs;
 
     emitGetVirtualRegisters(src1, regT0, src2, regT1);
 
     // Jump slow if both are cells (to cover strings).
     move(regT0, regT2);
@@ -630,55 +648,75 @@
 {
     linkAllSlowCases(iter);
 
     auto bytecode = currentInstruction->as<OpJstricteq>();
     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
-    callOperation(operationCompareStrictEq, regT0, regT1);
+    callOperation(operationCompareStrictEq, TrustedImmPtr(m_codeBlock->globalObject()), regT0, regT1);
     emitJumpSlowToHot(branchTest32(NonZero, returnValueGPR), target);
 }
 
 void JIT::emitSlow_op_jnstricteq(const Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
 {
     linkAllSlowCases(iter);
 
     auto bytecode = currentInstruction->as<OpJnstricteq>();
     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
-    callOperation(operationCompareStrictEq, regT0, regT1);
+    callOperation(operationCompareStrictEq, TrustedImmPtr(m_codeBlock->globalObject()), regT0, regT1);
     emitJumpSlowToHot(branchTest32(Zero, returnValueGPR), target);
 }
 
 void JIT::emit_op_to_number(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpToNumber>();
-    int dstVReg = bytecode.m_dst.offset();
-    int srcVReg = bytecode.m_operand.offset();
+    VirtualRegister dstVReg = bytecode.m_dst;
+    VirtualRegister srcVReg = bytecode.m_operand;
+    emitGetVirtualRegister(srcVReg, regT0);
+
+    addSlowCase(branchIfNotNumber(regT0));
+
+    emitValueProfilingSite(bytecode.metadata(m_codeBlock));
+    if (srcVReg != dstVReg)
+        emitPutVirtualRegister(dstVReg);
+}
+
+void JIT::emit_op_to_numeric(const Instruction* currentInstruction)
+{
+    auto bytecode = currentInstruction->as<OpToNumeric>();
+    VirtualRegister dstVReg = bytecode.m_dst;
+    VirtualRegister srcVReg = bytecode.m_operand;
     emitGetVirtualRegister(srcVReg, regT0);
 
+    Jump isNotCell = branchIfNotCell(regT0);
+    addSlowCase(branchIfNotBigInt(regT0));
+    Jump isBigInt = jump();
+
+    isNotCell.link(this);
     addSlowCase(branchIfNotNumber(regT0));
+    isBigInt.link(this);
 
     emitValueProfilingSite(bytecode.metadata(m_codeBlock));
     if (srcVReg != dstVReg)
         emitPutVirtualRegister(dstVReg);
 }
 
 void JIT::emit_op_to_string(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpToString>();
-    int srcVReg = bytecode.m_operand.offset();
+    VirtualRegister srcVReg = bytecode.m_operand;
     emitGetVirtualRegister(srcVReg, regT0);
 
     addSlowCase(branchIfNotCell(regT0));
     addSlowCase(branchIfNotString(regT0));
 
-    emitPutVirtualRegister(bytecode.m_dst.offset());
+    emitPutVirtualRegister(bytecode.m_dst);
 }
 
 void JIT::emit_op_to_object(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpToObject>();
-    int dstVReg = bytecode.m_dst.offset();
-    int srcVReg = bytecode.m_operand.offset();
+    VirtualRegister dstVReg = bytecode.m_dst;
+    VirtualRegister srcVReg = bytecode.m_operand;
     emitGetVirtualRegister(srcVReg, regT0);
 
     addSlowCase(branchIfNotCell(regT0));
     addSlowCase(branchIfNotObject(regT0));
 
@@ -697,40 +735,40 @@
     load64(Address(regT3, VM::callFrameForCatchOffset()), callFrameRegister);
     storePtr(TrustedImmPtr(nullptr), Address(regT3, VM::callFrameForCatchOffset()));
 
     addPtr(TrustedImm32(stackPointerOffsetFor(codeBlock()) * sizeof(Register)), callFrameRegister, stackPointerRegister);
 
-    callOperationNoExceptionCheck(operationCheckIfExceptionIsUncatchableAndNotifyProfiler);
+    callOperationNoExceptionCheck(operationCheckIfExceptionIsUncatchableAndNotifyProfiler, TrustedImmPtr(&vm()));
     Jump isCatchableException = branchTest32(Zero, returnValueGPR);
     jumpToExceptionHandler(vm());
     isCatchableException.link(this);
 
     move(TrustedImmPtr(m_vm), regT3);
     load64(Address(regT3, VM::exceptionOffset()), regT0);
     store64(TrustedImm64(JSValue::encode(JSValue())), Address(regT3, VM::exceptionOffset()));
-    emitPutVirtualRegister(bytecode.m_exception.offset());
+    emitPutVirtualRegister(bytecode.m_exception);
 
     load64(Address(regT0, Exception::valueOffset()), regT0);
-    emitPutVirtualRegister(bytecode.m_thrownValue.offset());
+    emitPutVirtualRegister(bytecode.m_thrownValue);
 
 #if ENABLE(DFG_JIT)
     // FIXME: consider inline caching the process of doing OSR entry, including
     // argument type proofs, storing locals to the buffer, etc
     // https://bugs.webkit.org/show_bug.cgi?id=175598
 
     auto& metadata = bytecode.metadata(m_codeBlock);
-    ValueProfileAndOperandBuffer* buffer = metadata.m_buffer;
+    ValueProfileAndVirtualRegisterBuffer* buffer = metadata.m_buffer;
     if (buffer || !shouldEmitProfiling())
-        callOperation(operationTryOSREnterAtCatch, m_bytecodeOffset);
+        callOperation(operationTryOSREnterAtCatch, &vm(), m_bytecodeIndex.asBits());
     else
-        callOperation(operationTryOSREnterAtCatchAndValueProfile, m_bytecodeOffset);
+        callOperation(operationTryOSREnterAtCatchAndValueProfile, &vm(), m_bytecodeIndex.asBits());
     auto skipOSREntry = branchTestPtr(Zero, returnValueGPR);
     emitRestoreCalleeSaves();
     farJump(returnValueGPR, ExceptionHandlerPtrTag);
     skipOSREntry.link(this);
     if (buffer && shouldEmitProfiling()) {
-        buffer->forEach([&] (ValueProfileAndOperand& profile) {
+        buffer->forEach([&] (ValueProfileAndVirtualRegister& profile) {
             JSValueRegs regs(regT0);
             emitGetVirtualRegister(profile.m_operand, regs);
             emitValueProfilingSite(static_cast<ValueProfile&>(profile));
         });
     }
@@ -743,80 +781,80 @@
 }
 
 void JIT::emit_op_get_parent_scope(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpGetParentScope>();
-    int currentScope = bytecode.m_scope.offset();
+    VirtualRegister currentScope = bytecode.m_scope;
     emitGetVirtualRegister(currentScope, regT0);
     loadPtr(Address(regT0, JSScope::offsetOfNext()), regT0);
-    emitStoreCell(bytecode.m_dst.offset(), regT0);
+    emitStoreCell(bytecode.m_dst, regT0);
 }
 
 void JIT::emit_op_switch_imm(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpSwitchImm>();
     size_t tableIndex = bytecode.m_tableIndex;
     unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
-    unsigned scrutinee = bytecode.m_scrutinee.offset();
+    VirtualRegister scrutinee = bytecode.m_scrutinee;
 
     // create jump table for switch destinations, track this switch statement.
     SimpleJumpTable* jumpTable = &m_codeBlock->switchJumpTable(tableIndex);
-    m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset, SwitchRecord::Immediate));
+    m_switches.append(SwitchRecord(jumpTable, m_bytecodeIndex, defaultOffset, SwitchRecord::Immediate));
     jumpTable->ensureCTITable();
 
     emitGetVirtualRegister(scrutinee, regT0);
-    callOperation(operationSwitchImmWithUnknownKeyType, regT0, tableIndex);
+    callOperation(operationSwitchImmWithUnknownKeyType, TrustedImmPtr(&vm()), regT0, tableIndex);
     farJump(returnValueGPR, JSSwitchPtrTag);
 }
 
 void JIT::emit_op_switch_char(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpSwitchChar>();
     size_t tableIndex = bytecode.m_tableIndex;
     unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
-    unsigned scrutinee = bytecode.m_scrutinee.offset();
+    VirtualRegister scrutinee = bytecode.m_scrutinee;
 
     // create jump table for switch destinations, track this switch statement.
     SimpleJumpTable* jumpTable = &m_codeBlock->switchJumpTable(tableIndex);
-    m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset, SwitchRecord::Character));
+    m_switches.append(SwitchRecord(jumpTable, m_bytecodeIndex, defaultOffset, SwitchRecord::Character));
     jumpTable->ensureCTITable();
 
     emitGetVirtualRegister(scrutinee, regT0);
-    callOperation(operationSwitchCharWithUnknownKeyType, regT0, tableIndex);
+    callOperation(operationSwitchCharWithUnknownKeyType, TrustedImmPtr(m_codeBlock->globalObject()), regT0, tableIndex);
     farJump(returnValueGPR, JSSwitchPtrTag);
 }
 
 void JIT::emit_op_switch_string(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpSwitchString>();
     size_t tableIndex = bytecode.m_tableIndex;
     unsigned defaultOffset = jumpTarget(currentInstruction, bytecode.m_defaultOffset);
-    unsigned scrutinee = bytecode.m_scrutinee.offset();
+    VirtualRegister scrutinee = bytecode.m_scrutinee;
 
     // create jump table for switch destinations, track this switch statement.
     StringJumpTable* jumpTable = &m_codeBlock->stringSwitchJumpTable(tableIndex);
-    m_switches.append(SwitchRecord(jumpTable, m_bytecodeOffset, defaultOffset));
+    m_switches.append(SwitchRecord(jumpTable, m_bytecodeIndex, defaultOffset));
 
     emitGetVirtualRegister(scrutinee, regT0);
-    callOperation(operationSwitchStringWithUnknownKeyType, regT0, tableIndex);
+    callOperation(operationSwitchStringWithUnknownKeyType, TrustedImmPtr(m_codeBlock->globalObject()), regT0, tableIndex);
     farJump(returnValueGPR, JSSwitchPtrTag);
 }
 
 void JIT::emit_op_debug(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpDebug>();
     load32(codeBlock()->debuggerRequestsAddress(), regT0);
     Jump noDebuggerRequests = branchTest32(Zero, regT0);
-    callOperation(operationDebug, static_cast<int>(bytecode.m_debugHookType));
+    callOperation(operationDebug, &vm(), static_cast<int>(bytecode.m_debugHookType));
     noDebuggerRequests.link(this);
 }
 
 void JIT::emit_op_eq_null(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpEqNull>();
-    int dst = bytecode.m_dst.offset();
-    int src1 = bytecode.m_operand.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister src1 = bytecode.m_operand;
 
     emitGetVirtualRegister(src1, regT0);
     Jump isImmediate = branchIfNotCell(regT0);
 
     Jump isMasqueradesAsUndefined = branchTest8(NonZero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
@@ -830,12 +868,12 @@
     comparePtr(Equal, regT0, regT2, regT0);
     Jump wasNotImmediate = jump();
 
     isImmediate.link(this);
 
-    and64(TrustedImm32(~TagBitUndefined), regT0);
-    compare64(Equal, regT0, TrustedImm32(ValueNull), regT0);
+    and64(TrustedImm32(~JSValue::UndefinedTag), regT0);
+    compare64(Equal, regT0, TrustedImm32(JSValue::ValueNull), regT0);
 
     wasNotImmediate.link(this);
     wasNotMasqueradesAsUndefined.link(this);
 
     boxBoolean(regT0, JSValueRegs { regT0 });
@@ -844,12 +882,12 @@
 }
 
 void JIT::emit_op_neq_null(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpNeqNull>();
-    int dst = bytecode.m_dst.offset();
-    int src1 = bytecode.m_operand.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister src1 = bytecode.m_operand;
 
     emitGetVirtualRegister(src1, regT0);
     Jump isImmediate = branchIfNotCell(regT0);
 
     Jump isMasqueradesAsUndefined = branchTest8(NonZero, Address(regT0, JSCell::typeInfoFlagsOffset()), TrustedImm32(MasqueradesAsUndefined));
@@ -863,35 +901,49 @@
     comparePtr(NotEqual, regT0, regT2, regT0);
     Jump wasNotImmediate = jump();
 
     isImmediate.link(this);
 
-    and64(TrustedImm32(~TagBitUndefined), regT0);
-    compare64(NotEqual, regT0, TrustedImm32(ValueNull), regT0);
+    and64(TrustedImm32(~JSValue::UndefinedTag), regT0);
+    compare64(NotEqual, regT0, TrustedImm32(JSValue::ValueNull), regT0);
 
     wasNotImmediate.link(this);
     wasNotMasqueradesAsUndefined.link(this);
 
     boxBoolean(regT0, JSValueRegs { regT0 });
     emitPutVirtualRegister(dst);
 }
 
+void JIT::emit_op_enter(const Instruction*)
+{
+    // Even though CTI doesn't use them, we initialize our constant
+    // registers to zap stale pointers, to avoid unnecessarily prolonging
+    // object lifetime and increasing GC pressure.
+    size_t count = m_codeBlock->numVars();
+    for (size_t j = CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters(); j < count; ++j)
+        emitInitRegister(virtualRegisterForLocal(j));
+
+    emitWriteBarrier(m_codeBlock);
+
+    emitEnterOptimizationCheck();
+}
+
 void JIT::emit_op_get_scope(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpGetScope>();
-    int dst = bytecode.m_dst.offset();
+    VirtualRegister dst = bytecode.m_dst;
     emitGetFromCallFrameHeaderPtr(CallFrameSlot::callee, regT0);
     loadPtr(Address(regT0, JSFunction::offsetOfScopeChain()), regT0);
     emitStoreCell(dst, regT0);
 }
 
 void JIT::emit_op_to_this(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpToThis>();
     auto& metadata = bytecode.metadata(m_codeBlock);
     StructureID* cachedStructureID = &metadata.m_cachedStructureID;
-    emitGetVirtualRegister(bytecode.m_srcDst.offset(), regT1);
+    emitGetVirtualRegister(bytecode.m_srcDst, regT1);
 
     emitJumpSlowCaseIfNotJSCell(regT1);
 
     addSlowCase(branchIfNotType(regT1, FinalObjectType));
     load32(cachedStructureID, regT2);
@@ -900,11 +952,11 @@
 
 void JIT::emit_op_create_this(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpCreateThis>();
     auto& metadata = bytecode.metadata(m_codeBlock);
-    int callee = bytecode.m_callee.offset();
+    VirtualRegister callee = bytecode.m_callee;
     WriteBarrierBase<JSCell>* cachedFunction = &metadata.m_cachedCallee;
     RegisterID calleeReg = regT0;
     RegisterID rareDataReg = regT4;
     RegisterID resultReg = regT0;
     RegisterID allocatorReg = regT1;
@@ -912,14 +964,14 @@
     RegisterID cachedFunctionReg = regT4;
     RegisterID scratchReg = regT3;
 
     emitGetVirtualRegister(callee, calleeReg);
     addSlowCase(branchIfNotFunction(calleeReg));
-    loadPtr(Address(calleeReg, JSFunction::offsetOfRareData()), rareDataReg);
-    addSlowCase(branchTestPtr(Zero, rareDataReg));
-    loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator()), allocatorReg);
-    loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure()), structureReg);
+    loadPtr(Address(calleeReg, JSFunction::offsetOfExecutableOrRareData()), rareDataReg);
+    addSlowCase(branchTestPtr(Zero, rareDataReg, TrustedImm32(JSFunction::rareDataTag)));
+    loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfAllocator() - JSFunction::rareDataTag), allocatorReg);
+    loadPtr(Address(rareDataReg, FunctionRareData::offsetOfObjectAllocationProfile() + ObjectAllocationProfileWithPrototype::offsetOfStructure() - JSFunction::rareDataTag), structureReg);
 
     loadPtr(cachedFunction, cachedFunctionReg);
     Jump hasSeenMultipleCallees = branchPtr(Equal, cachedFunctionReg, TrustedImmPtr(JSCell::seenMultipleCalleeObjects()));
     addSlowCase(branchPtr(NotEqual, calleeReg, cachedFunctionReg));
     hasSeenMultipleCallees.link(this);
@@ -928,17 +980,17 @@
     auto butterfly = TrustedImmPtr(nullptr);
     emitAllocateJSObject(resultReg, JITAllocator::variable(), allocatorReg, structureReg, butterfly, scratchReg, slowCases);
     load8(Address(structureReg, Structure::inlineCapacityOffset()), scratchReg);
     emitInitializeInlineStorage(resultReg, scratchReg);
     addSlowCase(slowCases);
-    emitPutVirtualRegister(bytecode.m_dst.offset());
+    emitPutVirtualRegister(bytecode.m_dst);
 }
 
 void JIT::emit_op_check_tdz(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpCheckTdz>();
-    emitGetVirtualRegister(bytecode.m_targetVirtualRegister.offset(), regT0);
+    emitGetVirtualRegister(bytecode.m_targetVirtualRegister, regT0);
     addSlowCase(branchIfEmpty(regT0));
 }
 
 
 // Slow cases
@@ -946,105 +998,107 @@
 void JIT::emitSlow_op_eq(const Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
 {
     linkAllSlowCases(iter);
 
     auto bytecode = currentInstruction->as<OpEq>();
-    callOperation(operationCompareEq, regT0, regT1);
+    callOperation(operationCompareEq, TrustedImmPtr(m_codeBlock->globalObject()), regT0, regT1);
     boxBoolean(returnValueGPR, JSValueRegs { returnValueGPR });
-    emitPutVirtualRegister(bytecode.m_dst.offset(), returnValueGPR);
+    emitPutVirtualRegister(bytecode.m_dst, returnValueGPR);
 }
 
 void JIT::emitSlow_op_neq(const Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
 {
     linkAllSlowCases(iter);
 
     auto bytecode = currentInstruction->as<OpNeq>();
-    callOperation(operationCompareEq, regT0, regT1);
+    callOperation(operationCompareEq, TrustedImmPtr(m_codeBlock->globalObject()), regT0, regT1);
     xor32(TrustedImm32(0x1), regT0);
     boxBoolean(returnValueGPR, JSValueRegs { returnValueGPR });
-    emitPutVirtualRegister(bytecode.m_dst.offset(), returnValueGPR);
+    emitPutVirtualRegister(bytecode.m_dst, returnValueGPR);
 }
 
 void JIT::emitSlow_op_jeq(const Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
 {
     linkAllSlowCases(iter);
 
     auto bytecode = currentInstruction->as<OpJeq>();
     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
-    callOperation(operationCompareEq, regT0, regT1);
+    callOperation(operationCompareEq, TrustedImmPtr(m_codeBlock->globalObject()), regT0, regT1);
     emitJumpSlowToHot(branchTest32(NonZero, returnValueGPR), target);
 }
 
 void JIT::emitSlow_op_jneq(const Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
 {
     linkAllSlowCases(iter);
 
     auto bytecode = currentInstruction->as<OpJneq>();
     unsigned target = jumpTarget(currentInstruction, bytecode.m_targetLabel);
-    callOperation(operationCompareEq, regT0, regT1);
+    callOperation(operationCompareEq, TrustedImmPtr(m_codeBlock->globalObject()), regT0, regT1);
     emitJumpSlowToHot(branchTest32(Zero, returnValueGPR), target);
 }
 
 void JIT::emitSlow_op_instanceof_custom(const Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
 {
     linkAllSlowCases(iter);
 
     auto bytecode = currentInstruction->as<OpInstanceofCustom>();
-    int dst = bytecode.m_dst.offset();
-    int value = bytecode.m_value.offset();
-    int constructor = bytecode.m_constructor.offset();
-    int hasInstanceValue = bytecode.m_hasInstanceValue.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister value = bytecode.m_value;
+    VirtualRegister constructor = bytecode.m_constructor;
+    VirtualRegister hasInstanceValue = bytecode.m_hasInstanceValue;
 
     emitGetVirtualRegister(value, regT0);
     emitGetVirtualRegister(constructor, regT1);
     emitGetVirtualRegister(hasInstanceValue, regT2);
-    callOperation(operationInstanceOfCustom, regT0, regT1, regT2);
+    callOperation(operationInstanceOfCustom, TrustedImmPtr(m_codeBlock->globalObject()), regT0, regT1, regT2);
     boxBoolean(returnValueGPR, JSValueRegs { returnValueGPR });
     emitPutVirtualRegister(dst, returnValueGPR);
 }
 
 #endif // USE(JSVALUE64)
 
 void JIT::emit_op_loop_hint(const Instruction*)
 {
-    // Check traps.
-    addSlowCase(branchTest8(NonZero, AbsoluteAddress(m_vm->needTrapHandlingAddress())));
-#if ENABLE(DFG_JIT)
     // Emit the JIT optimization check:
     if (canBeOptimized()) {
         addSlowCase(branchAdd32(PositiveOrZero, TrustedImm32(Options::executionCounterIncrementForLoop()),
             AbsoluteAddress(m_codeBlock->addressOfJITExecuteCounter())));
     }
-#endif
 }
 
 void JIT::emitSlow_op_loop_hint(const Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
 {
-    linkSlowCase(iter);
-    callOperation(operationHandleTraps);
 #if ENABLE(DFG_JIT)
     // Emit the slow path for the JIT optimization check:
     if (canBeOptimized()) {
-        emitJumpSlowToHot(branchAdd32(Signed, TrustedImm32(Options::executionCounterIncrementForLoop()), AbsoluteAddress(m_codeBlock->addressOfJITExecuteCounter())), currentInstruction->size());
-        linkSlowCase(iter);
+        linkAllSlowCases(iter);
 
         copyCalleeSavesFromFrameOrRegisterToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);
 
-        callOperation(operationOptimize, m_bytecodeOffset);
-        emitJumpSlowToHot(branchTestPtr(Zero, returnValueGPR), currentInstruction->size());
-        if (!ASSERT_DISABLED) {
+        callOperation(operationOptimize, &vm(), m_bytecodeIndex.asBits());
+        Jump noOptimizedEntry = branchTestPtr(Zero, returnValueGPR);
+        if (ASSERT_ENABLED) {
             Jump ok = branchPtr(MacroAssembler::Above, returnValueGPR, TrustedImmPtr(bitwise_cast<void*>(static_cast<intptr_t>(1000))));
             abortWithReason(JITUnreasonableLoopHintJumpTarget);
             ok.link(this);
         }
         farJump(returnValueGPR, GPRInfo::callFrameRegister);
+        noOptimizedEntry.link(this);
+
+        emitJumpSlowToHot(jump(), currentInstruction->size());
     }
 #else
     UNUSED_PARAM(currentInstruction);
+    UNUSED_PARAM(iter);
 #endif
 }
 
+void JIT::emit_op_check_traps(const Instruction*)
+{
+    addSlowCase(branchTest8(NonZero, AbsoluteAddress(m_vm->needTrapHandlingAddress())));
+}
+
 void JIT::emit_op_nop(const Instruction*)
 {
 }
 
 void JIT::emit_op_super_sampler_begin(const Instruction*)
@@ -1055,85 +1109,50 @@
 void JIT::emit_op_super_sampler_end(const Instruction*)
 {
     sub32(TrustedImm32(1), AbsoluteAddress(bitwise_cast<void*>(&g_superSamplerCount)));
 }
 
-void JIT::emit_op_enter(const Instruction*)
+void JIT::emitSlow_op_check_traps(const Instruction*, Vector<SlowCaseEntry>::iterator& iter)
 {
-    // Even though JIT doesn't use them, we initialize our constant
-    // registers to zap stale pointers, to avoid unnecessarily prolonging
-    // object lifetime and increasing GC pressure.
-    size_t count = m_codeBlock->numVars();
-    for (size_t i = CodeBlock::llintBaselineCalleeSaveSpaceAsVirtualRegisters(); i < count; ++i)
-        emitInitRegister(virtualRegisterForLocal(i).offset());
-
-    emitWriteBarrier(m_codeBlock);
-
-    // Check traps.
-    addSlowCase(branchTest8(NonZero, AbsoluteAddress(m_vm->needTrapHandlingAddress())));
-
-#if ENABLE(DFG_JIT)
-    if (canBeOptimized())
-        addSlowCase(branchAdd32(PositiveOrZero, TrustedImm32(Options::executionCounterIncrementForEntry()), AbsoluteAddress(m_codeBlock->addressOfJITExecuteCounter())));
-#endif
-}
-
-void JIT::emitSlow_op_enter(const Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
-{
-    linkSlowCase(iter);
-    callOperation(operationHandleTraps);
-#if ENABLE(DFG_JIT)
-    if (canBeOptimized()) {
-        emitJumpSlowToHot(branchAdd32(Signed, TrustedImm32(Options::executionCounterIncrementForEntry()), AbsoluteAddress(m_codeBlock->addressOfJITExecuteCounter())), currentInstruction->size());
-        linkSlowCase(iter);
-
-        ASSERT(!m_bytecodeOffset);
-
-        copyCalleeSavesFromFrameOrRegisterToEntryFrameCalleeSavesBuffer(vm().topEntryFrame);
+    linkAllSlowCases(iter);
 
-        callOperation(operationOptimize, m_bytecodeOffset);
-        emitJumpSlowToHot(branchTestPtr(Zero, returnValueGPR), currentInstruction->size());
-        farJump(returnValueGPR, GPRInfo::callFrameRegister);
-    }
-#else
-    UNUSED_PARAM(currentInstruction);
-#endif
+    callOperation(operationHandleTraps, TrustedImmPtr(m_codeBlock->globalObject()));
 }
 
 void JIT::emit_op_new_regexp(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpNewRegexp>();
-    int dst = bytecode.m_dst.offset();
-    int regexp = bytecode.m_regexp.offset();
-    callOperation(operationNewRegexp, jsCast<RegExp*>(m_codeBlock->getConstant(regexp)));
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister regexp = bytecode.m_regexp;
+    callOperation(operationNewRegexp, TrustedImmPtr(m_codeBlock->globalObject()), jsCast<RegExp*>(m_codeBlock->getConstant(regexp)));
     emitStoreCell(dst, returnValueGPR);
 }
 
 template<typename Op>
 void JIT::emitNewFuncCommon(const Instruction* currentInstruction)
 {
     Jump lazyJump;
     auto bytecode = currentInstruction->as<Op>();
-    int dst = bytecode.m_dst.offset();
+    VirtualRegister dst = bytecode.m_dst;
 
 #if USE(JSVALUE64)
-    emitGetVirtualRegister(bytecode.m_scope.offset(), regT0);
+    emitGetVirtualRegister(bytecode.m_scope, regT0);
 #else
-    emitLoadPayload(bytecode.m_scope.offset(), regT0);
+    emitLoadPayload(bytecode.m_scope, regT0);
 #endif
     FunctionExecutable* funcExec = m_codeBlock->functionDecl(bytecode.m_functionDecl);
 
     OpcodeID opcodeID = Op::opcodeID;
     if (opcodeID == op_new_func)
-        callOperation(operationNewFunction, dst, regT0, funcExec);
+        callOperation(operationNewFunction, dst, &vm(), regT0, funcExec);
     else if (opcodeID == op_new_generator_func)
-        callOperation(operationNewGeneratorFunction, dst, regT0, funcExec);
+        callOperation(operationNewGeneratorFunction, dst, &vm(), regT0, funcExec);
     else if (opcodeID == op_new_async_func)
-        callOperation(operationNewAsyncFunction, dst, regT0, funcExec);
+        callOperation(operationNewAsyncFunction, dst, &vm(), regT0, funcExec);
     else {
         ASSERT(opcodeID == op_new_async_generator_func);
-        callOperation(operationNewAsyncGeneratorFunction, dst, regT0, funcExec);
+        callOperation(operationNewAsyncGeneratorFunction, dst, &vm(), regT0, funcExec);
     }
 }
 
 void JIT::emit_op_new_func(const Instruction* currentInstruction)
 {
@@ -1157,29 +1176,29 @@
 
 template<typename Op>
 void JIT::emitNewFuncExprCommon(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<Op>();
-    int dst = bytecode.m_dst.offset();
+    VirtualRegister dst = bytecode.m_dst;
 #if USE(JSVALUE64)
-    emitGetVirtualRegister(bytecode.m_scope.offset(), regT0);
+    emitGetVirtualRegister(bytecode.m_scope, regT0);
 #else
-    emitLoadPayload(bytecode.m_scope.offset(), regT0);
+    emitLoadPayload(bytecode.m_scope, regT0);
 #endif
 
     FunctionExecutable* function = m_codeBlock->functionExpr(bytecode.m_functionDecl);
     OpcodeID opcodeID = Op::opcodeID;
 
     if (opcodeID == op_new_func_exp)
-        callOperation(operationNewFunction, dst, regT0, function);
+        callOperation(operationNewFunction, dst, &vm(), regT0, function);
     else if (opcodeID == op_new_generator_func_exp)
-        callOperation(operationNewGeneratorFunction, dst, regT0, function);
+        callOperation(operationNewGeneratorFunction, dst, &vm(), regT0, function);
     else if (opcodeID == op_new_async_func_exp)
-        callOperation(operationNewAsyncFunction, dst, regT0, function);
+        callOperation(operationNewAsyncFunction, dst, &vm(), regT0, function);
     else {
         ASSERT(opcodeID == op_new_async_generator_func_exp);
-        callOperation(operationNewAsyncGeneratorFunction, dst, regT0, function);
+        callOperation(operationNewAsyncGeneratorFunction, dst, &vm(), regT0, function);
     }
 }
 
 void JIT::emit_op_new_func_exp(const Instruction* currentInstruction)
 {
@@ -1203,42 +1222,42 @@
 
 void JIT::emit_op_new_array(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpNewArray>();
     auto& metadata = bytecode.metadata(m_codeBlock);
-    int dst = bytecode.m_dst.offset();
-    int valuesIndex = bytecode.m_argv.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister valuesStart = bytecode.m_argv;
     int size = bytecode.m_argc;
-    addPtr(TrustedImm32(valuesIndex * sizeof(Register)), callFrameRegister, regT0);
-    callOperation(operationNewArrayWithProfile, dst,
+    addPtr(TrustedImm32(valuesStart.offset() * sizeof(Register)), callFrameRegister, regT0);
+    callOperation(operationNewArrayWithProfile, dst, TrustedImmPtr(m_codeBlock->globalObject()),
         &metadata.m_arrayAllocationProfile, regT0, size);
 }
 
 void JIT::emit_op_new_array_with_size(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpNewArrayWithSize>();
     auto& metadata = bytecode.metadata(m_codeBlock);
-    int dst = bytecode.m_dst.offset();
-    int sizeIndex = bytecode.m_length.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister sizeIndex = bytecode.m_length;
 #if USE(JSVALUE64)
     emitGetVirtualRegister(sizeIndex, regT0);
-    callOperation(operationNewArrayWithSizeAndProfile, dst,
+    callOperation(operationNewArrayWithSizeAndProfile, dst, TrustedImmPtr(m_codeBlock->globalObject()),
         &metadata.m_arrayAllocationProfile, regT0);
 #else
     emitLoad(sizeIndex, regT1, regT0);
-    callOperation(operationNewArrayWithSizeAndProfile, dst,
+    callOperation(operationNewArrayWithSizeAndProfile, dst, TrustedImmPtr(m_codeBlock->globalObject()),
         &metadata.m_arrayAllocationProfile, JSValueRegs(regT1, regT0));
 #endif
 }
 
 #if USE(JSVALUE64)
 void JIT::emit_op_has_structure_property(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpHasStructureProperty>();
-    int dst = bytecode.m_dst.offset();
-    int base = bytecode.m_base.offset();
-    int enumerator = bytecode.m_enumerator.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister base = bytecode.m_base;
+    VirtualRegister enumerator = bytecode.m_enumerator;
 
     emitGetVirtualRegister(base, regT0);
     emitGetVirtualRegister(enumerator, regT1);
     emitJumpSlowCaseIfNotJSCell(regT0, base);
 
@@ -1278,13 +1297,13 @@
 
 void JIT::emit_op_has_indexed_property(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpHasIndexedProperty>();
     auto& metadata = bytecode.metadata(m_codeBlock);
-    int dst = bytecode.m_dst.offset();
-    int base = bytecode.m_base.offset();
-    int property = bytecode.m_property.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister base = bytecode.m_base;
+    VirtualRegister property = bytecode.m_property;
     ArrayProfile* profile = &metadata.m_arrayProfile;
     ByValInfo* byValInfo = m_codeBlock->addByValInfo();
 
     emitGetVirtualRegisters(base, regT0, property, regT1);
 
@@ -1318,41 +1337,41 @@
 
     emitPutVirtualRegister(dst);
 
     Label nextHotPath = label();
 
-    m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeOffset, PatchableJump(), badType, mode, profile, done, nextHotPath));
+    m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeIndex, PatchableJump(), badType, mode, profile, done, nextHotPath));
 }
 
 void JIT::emitSlow_op_has_indexed_property(const Instruction* currentInstruction, Vector<SlowCaseEntry>::iterator& iter)
 {
     linkAllSlowCases(iter);
 
     auto bytecode = currentInstruction->as<OpHasIndexedProperty>();
-    int dst = bytecode.m_dst.offset();
-    int base = bytecode.m_base.offset();
-    int property = bytecode.m_property.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister base = bytecode.m_base;
+    VirtualRegister property = bytecode.m_property;
     ByValInfo* byValInfo = m_byValCompilationInfo[m_byValInstructionIndex].byValInfo;
 
     Label slowPath = label();
 
     emitGetVirtualRegister(base, regT0);
     emitGetVirtualRegister(property, regT1);
-    Call call = callOperation(operationHasIndexedPropertyDefault, dst, regT0, regT1, byValInfo);
+    Call call = callOperation(operationHasIndexedPropertyDefault, dst, TrustedImmPtr(m_codeBlock->globalObject()), regT0, regT1, byValInfo);
 
     m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;
     m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;
     m_byValInstructionIndex++;
 }
 
 void JIT::emit_op_get_direct_pname(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpGetDirectPname>();
-    int dst = bytecode.m_dst.offset();
-    int base = bytecode.m_base.offset();
-    int index = bytecode.m_index.offset();
-    int enumerator = bytecode.m_enumerator.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister base = bytecode.m_base;
+    VirtualRegister index = bytecode.m_index;
+    VirtualRegister enumerator = bytecode.m_enumerator;
 
     // Check that base is a cell
     emitGetVirtualRegister(base, regT0);
     emitJumpSlowCaseIfNotJSCell(regT0, base);
 
@@ -1386,13 +1405,13 @@
 }
 
 void JIT::emit_op_enumerator_structure_pname(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpEnumeratorStructurePname>();
-    int dst = bytecode.m_dst.offset();
-    int enumerator = bytecode.m_enumerator.offset();
-    int index = bytecode.m_index.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister enumerator = bytecode.m_enumerator;
+    VirtualRegister index = bytecode.m_index;
 
     emitGetVirtualRegister(index, regT0);
     emitGetVirtualRegister(enumerator, regT1);
     Jump inBounds = branch32(Below, regT0, Address(regT1, JSPropertyNameEnumerator::endStructurePropertyIndexOffset()));
 
@@ -1410,13 +1429,13 @@
 }
 
 void JIT::emit_op_enumerator_generic_pname(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpEnumeratorGenericPname>();
-    int dst = bytecode.m_dst.offset();
-    int enumerator = bytecode.m_enumerator.offset();
-    int index = bytecode.m_index.offset();
+    VirtualRegister dst = bytecode.m_dst;
+    VirtualRegister enumerator = bytecode.m_enumerator;
+    VirtualRegister index = bytecode.m_index;
 
     emitGetVirtualRegister(index, regT0);
     emitGetVirtualRegister(enumerator, regT1);
     Jump inBounds = branch32(Below, regT0, Address(regT1, JSPropertyNameEnumerator::endGenericPropertyIndexOffset()));
 
@@ -1436,11 +1455,11 @@
 void JIT::emit_op_profile_type(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpProfileType>();
     auto& metadata = bytecode.metadata(m_codeBlock);
     TypeLocation* cachedTypeLocation = metadata.m_typeLocation;
-    int valueToProfile = bytecode.m_targetVirtualRegister.offset();
+    VirtualRegister valueToProfile = bytecode.m_targetVirtualRegister;
 
     emitGetVirtualRegister(valueToProfile, regT0);
 
     JumpList jumpToEnd;
 
@@ -1489,11 +1508,11 @@
     // Increment the current log entry.
     addPtr(TrustedImm32(sizeof(TypeProfilerLog::LogEntry)), regT1);
     store64(regT1, Address(regT2, TypeProfilerLog::currentLogEntryOffset()));
     Jump skipClearLog = branchPtr(NotEqual, regT1, TrustedImmPtr(cachedTypeProfilerLog->logEndPtr()));
     // Clear the log if we're at the end of the log.
-    callOperation(operationProcessTypeProfilerLog);
+    callOperation(operationProcessTypeProfilerLog, &vm());
     skipClearLog.link(this);
 
     jumpToEnd.link(this);
 }
 
@@ -1505,11 +1524,11 @@
     auto bytecode = currentInstruction->as<OpLogShadowChickenPrologue>();
     GPRReg shadowPacketReg = regT0;
     GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
     GPRReg scratch2Reg = regT2;
     ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);
-    emitGetVirtualRegister(bytecode.m_scope.offset(), regT3);
+    emitGetVirtualRegister(bytecode.m_scope, regT3);
     logShadowChickenProloguePacket(shadowPacketReg, scratch1Reg, regT3);
 }
 
 void JIT::emit_op_log_shadow_chicken_tail(const Instruction* currentInstruction)
 {
@@ -1519,13 +1538,13 @@
     auto bytecode = currentInstruction->as<OpLogShadowChickenTail>();
     GPRReg shadowPacketReg = regT0;
     GPRReg scratch1Reg = nonArgGPR0; // This must be a non-argument register.
     GPRReg scratch2Reg = regT2;
     ensureShadowChickenPacket(vm(), shadowPacketReg, scratch1Reg, scratch2Reg);
-    emitGetVirtualRegister(bytecode.m_thisValue.offset(), regT2);
-    emitGetVirtualRegister(bytecode.m_scope.offset(), regT3);
-    logShadowChickenTailPacket(shadowPacketReg, JSValueRegs(regT2), regT3, m_codeBlock, CallSiteIndex(m_bytecodeOffset));
+    emitGetVirtualRegister(bytecode.m_thisValue, regT2);
+    emitGetVirtualRegister(bytecode.m_scope, regT3);
+    logShadowChickenTailPacket(shadowPacketReg, JSValueRegs(regT2), regT3, m_codeBlock, CallSiteIndex(m_bytecodeIndex));
 }
 
 #endif // USE(JSVALUE64)
 
 void JIT::emit_op_profile_control_flow(const Instruction* currentInstruction)
@@ -1541,24 +1560,24 @@
 }
 
 void JIT::emit_op_argument_count(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpArgumentCount>();
-    int dst = bytecode.m_dst.offset();
-    load32(payloadFor(CallFrameSlot::argumentCount), regT0);
+    VirtualRegister dst = bytecode.m_dst;
+    load32(payloadFor(CallFrameSlot::argumentCountIncludingThis), regT0);
     sub32(TrustedImm32(1), regT0);
     JSValueRegs result = JSValueRegs::withTwoAvailableRegs(regT0, regT1);
     boxInt32(regT0, result);
     emitPutVirtualRegister(dst, result);
 }
 
 void JIT::emit_op_get_rest_length(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpGetRestLength>();
-    int dst = bytecode.m_dst.offset();
+    VirtualRegister dst = bytecode.m_dst;
     unsigned numParamsToSkip = bytecode.m_numParametersToSkip;
-    load32(payloadFor(CallFrameSlot::argumentCount), regT0);
+    load32(payloadFor(CallFrameSlot::argumentCountIncludingThis), regT0);
     sub32(TrustedImm32(1), regT0);
     Jump zeroLength = branch32(LessThanOrEqual, regT0, Imm32(numParamsToSkip));
     sub32(Imm32(numParamsToSkip), regT0);
 #if USE(JSVALUE64)
     boxInt32(regT0, JSValueRegs(regT0));
@@ -1582,21 +1601,21 @@
 }
 
 void JIT::emit_op_get_argument(const Instruction* currentInstruction)
 {
     auto bytecode = currentInstruction->as<OpGetArgument>();
-    int dst = bytecode.m_dst.offset();
+    VirtualRegister dst = bytecode.m_dst;
     int index = bytecode.m_index;
 #if USE(JSVALUE64)
     JSValueRegs resultRegs(regT0);
 #else
     JSValueRegs resultRegs(regT1, regT0);
 #endif
 
-    load32(payloadFor(CallFrameSlot::argumentCount), regT2);
+    load32(payloadFor(CallFrameSlot::argumentCountIncludingThis), regT2);
     Jump argumentOutOfBounds = branch32(LessThanOrEqual, regT2, TrustedImm32(index));
-    loadValue(addressFor(CallFrameSlot::thisArgument + index), resultRegs);
+    loadValue(addressFor(VirtualRegister(CallFrameSlot::thisArgument + index)), resultRegs);
     Jump done = jump();
 
     argumentOutOfBounds.link(this);
     moveValue(jsUndefined(), resultRegs);
 

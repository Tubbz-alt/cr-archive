diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/StructureStubInfo.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/StructureStubInfo.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/StructureStubInfo.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/StructureStubInfo.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2008-2018 Apple Inc. All rights reserved.
+ * Copyright (C) 2008-2020 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -23,10 +23,11 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #pragma once
 
+#include "CacheableIdentifier.h"
 #include "CodeBlock.h"
 #include "CodeOrigin.h"
 #include "Instruction.h"
 #include "JITStubRoutine.h"
 #include "MacroAssembler.h"
@@ -34,24 +35,26 @@
 #include "RegisterSet.h"
 #include "Structure.h"
 #include "StructureSet.h"
 #include "StructureStubClearingWatchpoint.h"
 #include "StubInfoSummary.h"
+#include <wtf/Box.h>
 
 namespace JSC {
 
 #if ENABLE(JIT)
 
 class AccessCase;
 class AccessGenerationResult;
 class PolymorphicAccess;
 
 enum class AccessType : int8_t {
-    Get,
-    GetWithThis,
-    GetDirect,
-    TryGet,
+    GetById,
+    GetByIdWithThis,
+    GetByIdDirect,
+    TryGetById,
+    GetByVal,
     Put,
     In,
     InstanceOf
 };
 
@@ -70,31 +73,33 @@
     WTF_MAKE_FAST_ALLOCATED;
 public:
     StructureStubInfo(AccessType);
     ~StructureStubInfo();
 
-    void initGetByIdSelf(CodeBlock*, Structure* baseObjectStructure, PropertyOffset);
+    void initGetByIdSelf(CodeBlock*, Structure* baseObjectStructure, PropertyOffset, CacheableIdentifier);
     void initArrayLength();
     void initStringLength();
     void initPutByIdReplace(CodeBlock*, Structure* baseObjectStructure, PropertyOffset);
     void initInByIdSelf(CodeBlock*, Structure* baseObjectStructure, PropertyOffset);
 
-    AccessGenerationResult addAccessCase(const GCSafeConcurrentJSLocker&, CodeBlock*, const Identifier&, std::unique_ptr<AccessCase>);
+    AccessGenerationResult addAccessCase(const GCSafeConcurrentJSLocker&, CodeBlock*, CacheableIdentifier, std::unique_ptr<AccessCase>);
 
     void reset(CodeBlock*);
 
     void deref();
     void aboutToDie();
 
+    void visitAggregate(SlotVisitor&);
+
     // Check if the stub has weak references that are dead. If it does, then it resets itself,
     // either entirely or just enough to ensure that those dead pointers don't get used anymore.
     void visitWeakReferences(CodeBlock*);
 
     // This returns true if it has marked everything that it will ever mark.
     bool propagateTransitions(SlotVisitor&);
 
-    ALWAYS_INLINE bool considerCaching(VM& vm, CodeBlock* codeBlock, Structure* structure)
+    ALWAYS_INLINE bool considerCaching(VM& vm, CodeBlock* codeBlock, Structure* structure, UniquedStringImpl* impl = nullptr)
     {
         DisallowGC disallowGC;
 
         // We never cache non-cells.
         if (!structure) {
@@ -150,136 +155,180 @@
             // immediately generating code for it.
             //
             // NOTE: This will behave oddly for InstanceOf if the user varies the prototype but not
             // the base's structure. That seems unlikely for the canonical use of instanceof, where
             // the prototype is fixed.
-            bool isNewlyAdded = bufferedStructures.add(structure);
+            bool isNewlyAdded = bufferedStructures.add({ structure, impl }).isNewEntry;
             if (isNewlyAdded)
                 vm.heap.writeBarrier(codeBlock);
             return isNewlyAdded;
         }
         countdown--;
         return false;
     }
 
-    StubInfoSummary summary() const;
+    StubInfoSummary summary(VM&) const;
 
-    static StubInfoSummary summary(const StructureStubInfo*);
+    static StubInfoSummary summary(VM&, const StructureStubInfo*);
 
     bool containsPC(void* pc) const;
 
     CodeOrigin codeOrigin;
-    CallSiteIndex callSiteIndex;
+private:
+    CacheableIdentifier m_getByIdSelfIdentifier;
+public:
 
     union {
         struct {
             WriteBarrierBase<Structure> baseObjectStructure;
             PropertyOffset offset;
         } byIdSelf;
         PolymorphicAccess* stub;
     } u;
 
+    CacheableIdentifier getByIdSelfIdentifier()
+    {
+        RELEASE_ASSERT(m_cacheType == CacheType::GetByIdSelf);
+        return m_getByIdSelfIdentifier;
+    }
+
+private:
     // Represents those structures that already have buffered AccessCases in the PolymorphicAccess.
     // Note that it's always safe to clear this. If we clear it prematurely, then if we see the same
     // structure again during this buffering countdown, we will create an AccessCase object for it.
     // That's not so bad - we'll get rid of the redundant ones once we regenerate.
-    StructureSet bufferedStructures;
+    HashSet<std::pair<Structure*, RefPtr<UniquedStringImpl>>> bufferedStructures;
+public:
 
-    struct {
-        CodeLocationLabel<JITStubRoutinePtrTag> start; // This is either the start of the inline IC for *byId caches. or the location of patchable jump for 'instanceof' caches.
-        CodeLocationLabel<JSInternalPtrTag> doneLocation;
-        CodeLocationCall<JSInternalPtrTag> slowPathCallLocation;
-        CodeLocationLabel<JITStubRoutinePtrTag> slowPathStartLocation;
+    CodeLocationLabel<JITStubRoutinePtrTag> start; // This is either the start of the inline IC for *byId caches. or the location of patchable jump for 'instanceof' caches.
+    CodeLocationLabel<JSInternalPtrTag> doneLocation;
+    CodeLocationCall<JSInternalPtrTag> slowPathCallLocation;
+    CodeLocationLabel<JITStubRoutinePtrTag> slowPathStartLocation;
 
-        RegisterSet usedRegisters;
+    RegisterSet usedRegisters;
 
-        uint32_t inlineSize() const
-        {
-            int32_t inlineSize = MacroAssembler::differenceBetweenCodePtr(start, doneLocation);
-            ASSERT(inlineSize >= 0);
-            return inlineSize;
-        }
+    uint32_t inlineSize() const
+    {
+        int32_t inlineSize = MacroAssembler::differenceBetweenCodePtr(start, doneLocation);
+        ASSERT(inlineSize >= 0);
+        return inlineSize;
+    }
 
-        GPRReg baseGPR;
-        GPRReg valueGPR;
+    GPRReg baseGPR;
+    GPRReg valueGPR;
+    union {
         GPRReg thisGPR;
+        GPRReg prototypeGPR;
+        GPRReg propertyGPR;
+    } regs;
 #if USE(JSVALUE32_64)
-        GPRReg valueTagGPR;
-        GPRReg baseTagGPR;
+    GPRReg valueTagGPR;
+    // FIXME: [32-bits] Check if StructureStubInfo::baseTagGPR is used somewhere.
+    // https://bugs.webkit.org/show_bug.cgi?id=204726
+    GPRReg baseTagGPR;
+    union {
         GPRReg thisTagGPR;
+        GPRReg propertyTagGPR;
+    } v;
 #endif
-    } patch;
 
-    GPRReg baseGPR() const
+    CodeLocationJump<JSInternalPtrTag> patchableJump()
     {
-        return patch.baseGPR;
+        ASSERT(accessType == AccessType::InstanceOf);
+        return start.jumpAtOffset<JSInternalPtrTag>(0);
     }
 
-    CodeLocationCall<JSInternalPtrTag> slowPathCallLocation() { return patch.slowPathCallLocation; }
-    CodeLocationLabel<JSInternalPtrTag> doneLocation() { return patch.doneLocation; }
-    CodeLocationLabel<JITStubRoutinePtrTag> slowPathStartLocation() { return patch.slowPathStartLocation; }
+    JSValueRegs valueRegs() const
+    {
+        return JSValueRegs(
+#if USE(JSVALUE32_64)
+            valueTagGPR,
+#endif
+            valueGPR);
+    }
 
-    CodeLocationJump<JSInternalPtrTag> patchableJump()
+    JSValueRegs propertyRegs() const
     {
-        ASSERT(accessType == AccessType::InstanceOf);
-        return patch.start.jumpAtOffset<JSInternalPtrTag>(0);
+        return JSValueRegs(
+#if USE(JSVALUE32_64)
+            v.propertyTagGPR,
+#endif
+            regs.propertyGPR);
     }
 
-    JSValueRegs valueRegs() const
+    JSValueRegs baseRegs() const
     {
         return JSValueRegs(
 #if USE(JSVALUE32_64)
-            patch.valueTagGPR,
+            baseTagGPR,
 #endif
-            patch.valueGPR);
+            baseGPR);
     }
 
+    bool thisValueIsInThisGPR() const { return accessType == AccessType::GetByIdWithThis; }
+
+#if ASSERT_ENABLED
+    void checkConsistency();
+#else
+    ALWAYS_INLINE void checkConsistency() { }
+#endif
 
     AccessType accessType;
-    CacheType cacheType;
+private:
+    CacheType m_cacheType;
+    void setCacheType(CacheType);
+public:
+    CacheType cacheType() const { return m_cacheType; }
     uint8_t countdown; // We repatch only when this is zero. If not zero, we decrement.
     uint8_t repatchCount;
     uint8_t numberOfCoolDowns;
+
+    CallSiteIndex callSiteIndex;
+
     uint8_t bufferingCountdown;
     bool resetByGC : 1;
     bool tookSlowPath : 1;
     bool everConsidered : 1;
     bool prototypeIsKnownObject : 1; // Only relevant for InstanceOf.
     bool sawNonCell : 1;
+    bool hasConstantIdentifier : 1;
+    bool propertyIsString : 1;
+    bool propertyIsInt32 : 1;
+    bool propertyIsSymbol : 1;
 };
 
 inline CodeOrigin getStructureStubInfoCodeOrigin(StructureStubInfo& structureStubInfo)
 {
     return structureStubInfo.codeOrigin;
 }
 
-inline J_JITOperation_ESsiJI appropriateOptimizingGetByIdFunction(AccessType type)
+inline auto appropriateOptimizingGetByIdFunction(AccessType type) -> decltype(&operationGetByIdOptimize)
 {
     switch (type) {
-    case AccessType::Get:
+    case AccessType::GetById:
         return operationGetByIdOptimize;
-    case AccessType::TryGet:
+    case AccessType::TryGetById:
         return operationTryGetByIdOptimize;
-    case AccessType::GetDirect:
+    case AccessType::GetByIdDirect:
         return operationGetByIdDirectOptimize;
-    case AccessType::GetWithThis:
+    case AccessType::GetByIdWithThis:
     default:
         ASSERT_NOT_REACHED();
         return nullptr;
     }
 }
 
-inline J_JITOperation_EJI appropriateGenericGetByIdFunction(AccessType type)
+inline auto appropriateGenericGetByIdFunction(AccessType type) -> decltype(&operationGetByIdGeneric)
 {
     switch (type) {
-    case AccessType::Get:
+    case AccessType::GetById:
         return operationGetByIdGeneric;
-    case AccessType::TryGet:
+    case AccessType::TryGetById:
         return operationTryGetByIdGeneric;
-    case AccessType::GetDirect:
+    case AccessType::GetByIdDirect:
         return operationGetByIdDirectGeneric;
-    case AccessType::GetWithThis:
+    case AccessType::GetByIdWithThis:
     default:
         ASSERT_NOT_REACHED();
         return nullptr;
     }
 }

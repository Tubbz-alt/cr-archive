<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webaudio/RealtimeAnalyser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2010, Google Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1.  Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2.  Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 
 27 #if ENABLE(WEB_AUDIO)
 28 
 29 #include &quot;RealtimeAnalyser.h&quot;
 30 
 31 #include &quot;AudioBus.h&quot;
 32 #include &quot;AudioUtilities.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 33 #include &quot;FFTFrame.h&quot;</span>
 34 #include &quot;VectorMath.h&quot;
 35 #include &lt;JavaScriptCore/Float32Array.h&gt;
 36 #include &lt;JavaScriptCore/Uint8Array.h&gt;
 37 #include &lt;algorithm&gt;
 38 #include &lt;complex&gt;
 39 #include &lt;wtf/MainThread.h&gt;
 40 #include &lt;wtf/MathExtras.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 const double RealtimeAnalyser::DefaultSmoothingTimeConstant  = 0.8;
 45 const double RealtimeAnalyser::DefaultMinDecibels = -100;
 46 const double RealtimeAnalyser::DefaultMaxDecibels = -30;
 47 
 48 const unsigned RealtimeAnalyser::DefaultFFTSize = 2048;
 49 // All FFT implementations are expected to handle power-of-two sizes MinFFTSize &lt;= size &lt;= MaxFFTSize.
 50 const unsigned RealtimeAnalyser::MinFFTSize = 32;
 51 const unsigned RealtimeAnalyser::MaxFFTSize = 32768;
 52 const unsigned RealtimeAnalyser::InputBufferSize = RealtimeAnalyser::MaxFFTSize * 2;
 53 
 54 RealtimeAnalyser::RealtimeAnalyser()
 55     : m_inputBuffer(InputBufferSize)
 56     , m_writeIndex(0)
 57     , m_fftSize(DefaultFFTSize)
 58     , m_magnitudeBuffer(DefaultFFTSize / 2)
 59     , m_smoothingTimeConstant(DefaultSmoothingTimeConstant)
 60     , m_minDecibels(DefaultMinDecibels)
 61     , m_maxDecibels(DefaultMaxDecibels)
 62 {
 63     m_analysisFrame = makeUnique&lt;FFTFrame&gt;(DefaultFFTSize);
 64 }
 65 
 66 RealtimeAnalyser::~RealtimeAnalyser() = default;
 67 
 68 void RealtimeAnalyser::reset()
 69 {
 70     m_writeIndex = 0;
 71     m_inputBuffer.zero();
 72     m_magnitudeBuffer.zero();
 73 }
 74 
 75 bool RealtimeAnalyser::setFftSize(size_t size)
 76 {
 77     ASSERT(isMainThread());
 78 
 79     // Only allow powers of two.
 80     unsigned log2size = static_cast&lt;unsigned&gt;(log2(size));
 81     bool isPOT(1UL &lt;&lt; log2size == size);
 82 
 83     if (!isPOT || size &gt; MaxFFTSize || size &lt; MinFFTSize)
 84         return false;
 85 
 86     if (m_fftSize != size) {
 87         m_analysisFrame = makeUnique&lt;FFTFrame&gt;(size);
 88         // m_magnitudeBuffer has size = fftSize / 2 because it contains floats reduced from complex values in m_analysisFrame.
 89         m_magnitudeBuffer.allocate(size / 2);
 90         m_fftSize = size;
 91     }
 92 
 93     return true;
 94 }
 95 
 96 void RealtimeAnalyser::writeInput(AudioBus* bus, size_t framesToProcess)
 97 {
 98     bool isBusGood = bus &amp;&amp; bus-&gt;numberOfChannels() &gt; 0 &amp;&amp; bus-&gt;channel(0)-&gt;length() &gt;= framesToProcess;
 99     ASSERT(isBusGood);
100     if (!isBusGood)
101         return;
102 
103     // FIXME : allow to work with non-FFTSize divisible chunking
104     bool isDestinationGood = m_writeIndex &lt; m_inputBuffer.size() &amp;&amp; m_writeIndex + framesToProcess &lt;= m_inputBuffer.size();
105     ASSERT(isDestinationGood);
106     if (!isDestinationGood)
107         return;
108 
109     // Perform real-time analysis
110     const float* source = bus-&gt;channel(0)-&gt;data();
111     float* dest = m_inputBuffer.data() + m_writeIndex;
112 
113     // The source has already been sanity checked with isBusGood above.
114     memcpy(dest, source, sizeof(float) * framesToProcess);
115 
116     // Sum all channels in one if numberOfChannels &gt; 1.
117     unsigned numberOfChannels = bus-&gt;numberOfChannels();
118     if (numberOfChannels &gt; 1) {
119         for (unsigned i = 1; i &lt; numberOfChannels; i++) {
120             source = bus-&gt;channel(i)-&gt;data();
121             VectorMath::vadd(dest, 1, source, 1, dest, 1, framesToProcess);
122         }
123         const float scale =  1.0 / numberOfChannels;
124         VectorMath::vsmul(dest, 1, &amp;scale, dest, 1, framesToProcess);
125     }
126 
127     m_writeIndex += framesToProcess;
128     if (m_writeIndex &gt;= InputBufferSize)
129         m_writeIndex = 0;
130 }
131 
132 namespace {
133 
134 void applyWindow(float* p, size_t n)
135 {
136     ASSERT(isMainThread());
137 
138     // Blackman window
139     double alpha = 0.16;
140     double a0 = 0.5 * (1 - alpha);
141     double a1 = 0.5;
142     double a2 = 0.5 * alpha;
143 
144     for (unsigned i = 0; i &lt; n; ++i) {
145         double x = static_cast&lt;double&gt;(i) / static_cast&lt;double&gt;(n);
146         double window = a0 - a1 * cos(2 * piDouble * x) + a2 * cos(4 * piDouble * x);
147         p[i] *= float(window);
148     }
149 }
150 
151 } // namespace
152 
153 void RealtimeAnalyser::doFFTAnalysis()
154 {
155     ASSERT(isMainThread());
156 
157     // Unroll the input buffer into a temporary buffer, where we&#39;ll apply an analysis window followed by an FFT.
158     size_t fftSize = this-&gt;fftSize();
159 
160     AudioFloatArray temporaryBuffer(fftSize);
161     float* inputBuffer = m_inputBuffer.data();
162     float* tempP = temporaryBuffer.data();
163 
164     // Take the previous fftSize values from the input buffer and copy into the temporary buffer.
165     unsigned writeIndex = m_writeIndex;
166     if (writeIndex &lt; fftSize) {
167         memcpy(tempP, inputBuffer + writeIndex - fftSize + InputBufferSize, sizeof(*tempP) * (fftSize - writeIndex));
168         memcpy(tempP + fftSize - writeIndex, inputBuffer, sizeof(*tempP) * writeIndex);
169     } else
170         memcpy(tempP, inputBuffer + writeIndex - fftSize, sizeof(*tempP) * fftSize);
171 
172 
173     // Window the input samples.
174     applyWindow(tempP, fftSize);
175 
176     // Do the analysis.
177     m_analysisFrame-&gt;doFFT(tempP);
178 
179     float* realP = m_analysisFrame-&gt;realData();
180     float* imagP = m_analysisFrame-&gt;imagData();
181 
182     // Blow away the packed nyquist component.
183     imagP[0] = 0;
184 
185     // Normalize so than an input sine wave at 0dBfs registers as 0dBfs (undo FFT scaling factor).
186     const double magnitudeScale = 1.0 / fftSize;
187 
188     // A value of 0 does no averaging with the previous result.  Larger values produce slower, but smoother changes.
189     double k = m_smoothingTimeConstant;
190     k = std::max(0.0, k);
191     k = std::min(1.0, k);
192 
193     // Convert the analysis data from complex to magnitude and average with the previous result.
194     float* destination = magnitudeBuffer().data();
195     size_t n = magnitudeBuffer().size();
196     for (size_t i = 0; i &lt; n; ++i) {
197         std::complex&lt;double&gt; c(realP[i], imagP[i]);
198         double scalarMagnitude = abs(c) * magnitudeScale;
199         destination[i] = static_cast&lt;float&gt;(k * destination[i] + (1 - k) * scalarMagnitude);
200     }
201 }
202 
203 void RealtimeAnalyser::getFloatFrequencyData(Float32Array* destinationArray)
204 {
205     ASSERT(isMainThread());
206 
207     if (!destinationArray)
208         return;
209 
210     doFFTAnalysis();
211 
212     // Convert from linear magnitude to floating-point decibels.
213     const double minDecibels = m_minDecibels;
214     unsigned sourceLength = magnitudeBuffer().size();
215     size_t len = std::min(sourceLength, destinationArray-&gt;length());
216     if (len &gt; 0) {
217         const float* source = magnitudeBuffer().data();
218         float* destination = destinationArray-&gt;data();
219 
220         for (unsigned i = 0; i &lt; len; ++i) {
221             float linearValue = source[i];
222             double dbMag = !linearValue ? minDecibels : AudioUtilities::linearToDecibels(linearValue);
223             destination[i] = static_cast&lt;float&gt;(dbMag);
224         }
225     }
226 }
227 
228 void RealtimeAnalyser::getByteFrequencyData(Uint8Array* destinationArray)
229 {
230     ASSERT(isMainThread());
231 
232     if (!destinationArray)
233         return;
234 
235     doFFTAnalysis();
236 
237     // Convert from linear magnitude to unsigned-byte decibels.
238     unsigned sourceLength = magnitudeBuffer().size();
239     size_t len = std::min(sourceLength, destinationArray-&gt;length());
240     if (len &gt; 0) {
241         const double rangeScaleFactor = m_maxDecibels == m_minDecibels ? 1 : 1 / (m_maxDecibels - m_minDecibels);
242         const double minDecibels = m_minDecibels;
243 
244         const float* source = magnitudeBuffer().data();
245         unsigned char* destination = destinationArray-&gt;data();
246 
247         for (unsigned i = 0; i &lt; len; ++i) {
248             float linearValue = source[i];
249             double dbMag = !linearValue ? minDecibels : AudioUtilities::linearToDecibels(linearValue);
250 
251             // The range m_minDecibels to m_maxDecibels will be scaled to byte values from 0 to UCHAR_MAX.
252             double scaledValue = UCHAR_MAX * (dbMag - minDecibels) * rangeScaleFactor;
253 
254             // Clip to valid range.
255             if (scaledValue &lt; 0)
256                 scaledValue = 0;
257             if (scaledValue &gt; UCHAR_MAX)
258                 scaledValue = UCHAR_MAX;
259 
260             destination[i] = static_cast&lt;unsigned char&gt;(scaledValue);
261         }
262     }
263 }
264 
265 void RealtimeAnalyser::getByteTimeDomainData(Uint8Array* destinationArray)
266 {
267     ASSERT(isMainThread());
268 
269     if (!destinationArray)
270         return;
271 
272     unsigned fftSize = this-&gt;fftSize();
273     size_t len = std::min(fftSize, destinationArray-&gt;length());
274     if (len &gt; 0) {
275         bool isInputBufferGood = m_inputBuffer.size() == InputBufferSize &amp;&amp; m_inputBuffer.size() &gt; fftSize;
276         ASSERT(isInputBufferGood);
277         if (!isInputBufferGood)
278             return;
279 
280         float* inputBuffer = m_inputBuffer.data();
281         unsigned char* destination = destinationArray-&gt;data();
282 
283         unsigned writeIndex = m_writeIndex;
284 
285         for (unsigned i = 0; i &lt; len; ++i) {
286             // Buffer access is protected due to modulo operation.
287             float value = inputBuffer[(i + writeIndex - fftSize + InputBufferSize) % InputBufferSize];
288 
289             // Scale from nominal -1 -&gt; +1 to unsigned byte.
290             double scaledValue = 128 * (value + 1);
291 
292             // Clip to valid range.
293             if (scaledValue &lt; 0)
294                 scaledValue = 0;
295             if (scaledValue &gt; UCHAR_MAX)
296                 scaledValue = UCHAR_MAX;
297 
298             destination[i] = static_cast&lt;unsigned char&gt;(scaledValue);
299         }
300     }
301 }
302 
303 } // namespace WebCore
304 
305 #endif // ENABLE(WEB_AUDIO)
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
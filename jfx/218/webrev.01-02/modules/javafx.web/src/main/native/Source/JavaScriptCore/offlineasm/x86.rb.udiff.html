<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/x86.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="transform.rb.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../parser/ASTBuilder.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/offlineasm/x86.rb</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -49,13 +49,13 @@</span>
  # rdx =&gt; t2, a2, r1
  # rcx =&gt; t3, a3
  #  r8 =&gt; t4
  #  r9 =&gt; t5
  # r10 =&gt; t6
<span class="udiff-line-modified-removed">- # rbx =&gt;             csr0 (callee-save, PB, unused in baseline)</span>
<span class="udiff-line-modified-removed">- # r12 =&gt;             csr1 (callee-save)</span>
<span class="udiff-line-modified-removed">- # r13 =&gt;             csr2 (callee-save)</span>
<span class="udiff-line-modified-added">+ # rbx =&gt;             csr0 (callee-save, wasmInstance)</span>
<span class="udiff-line-modified-added">+ # r12 =&gt;             csr1 (callee-save, metadataTable)</span>
<span class="udiff-line-modified-added">+ # r13 =&gt;             csr2 (callee-save, PB)</span>
  # r14 =&gt;             csr3 (callee-save, tagTypeNumber)
  # r15 =&gt;             csr4 (callee-save, tagMask)
  # rsp =&gt; sp
  # rbp =&gt; cfr
  # r11 =&gt;                  (scratch)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -73,12 +73,12 @@</span>
  # rbx =&gt;             csr0 (callee-save, PB, unused in baseline)
  # rsi =&gt;             csr1 (callee-save)
  # rdi =&gt;             csr2 (callee-save)
  # r12 =&gt;             csr3 (callee-save)
  # r13 =&gt;             csr4 (callee-save)
<span class="udiff-line-modified-removed">- # r14 =&gt;             csr5 (callee-save, tagTypeNumber)</span>
<span class="udiff-line-modified-removed">- # r15 =&gt;             csr6 (callee-save, tagMask)</span>
<span class="udiff-line-modified-added">+ # r14 =&gt;             csr5 (callee-save, numberTag)</span>
<span class="udiff-line-modified-added">+ # r15 =&gt;             csr6 (callee-save, notCellMask)</span>
  # rsp =&gt; sp
  # rbp =&gt; cfr
  # r11 =&gt;                  (scratch)
  
  def isX64
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -129,12 +129,12 @@</span>
  
  def callPrefix
      isIntelSyntax ? &quot;&quot; : &quot;*&quot;
  end
  
<span class="udiff-line-modified-removed">- def orderOperands(opA, opB)</span>
<span class="udiff-line-modified-removed">-     isIntelSyntax ? &quot;#{opB}, #{opA}&quot; : &quot;#{opA}, #{opB}&quot;</span>
<span class="udiff-line-modified-added">+ def orderOperands(*operands)</span>
<span class="udiff-line-modified-added">+     (isIntelSyntax ? operands.reverse : operands).join(&quot;, &quot;)</span>
  end
  
  def const(c)
      isIntelSyntax ? &quot;#{c}&quot; : &quot;$#{c}&quot;
  end
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -152,10 +152,12 @@</span>
          size = &quot;word&quot;
      when :int
          size = &quot;dword&quot;
      when :ptr
          size =  isX64 ? &quot;qword&quot; : &quot;dword&quot;
<span class="udiff-line-added">+     when :float</span>
<span class="udiff-line-added">+         size = &quot;dword&quot;</span>
      when :double
          size = &quot;qword&quot;
      when :quad
          size = &quot;qword&quot;
      else
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -177,11 +179,11 @@</span>
          when :ptr
              register(@name)
          when :quad
              register(@name)
          else
<span class="udiff-line-modified-removed">-             raise</span>
<span class="udiff-line-modified-added">+             raise codeOriginString</span>
          end
      end
      def x86CallOperand(kind)
          # Call operands are not allowed to be partial registers.
          &quot;#{callPrefix}#{x86Operand(:quad)}&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -252,26 +254,29 @@</span>
      end
  
      def x86GPR
          if isX64
              case name
<span class="udiff-line-modified-removed">-             when &quot;t0&quot;, &quot;r0&quot;</span>
<span class="udiff-line-modified-added">+             when &quot;t0&quot;, &quot;r0&quot;, &quot;ws0&quot;</span>
                  &quot;eax&quot;
              when &quot;r1&quot;
                  &quot;edx&quot; # t1 = a1 when isWin, t2 = a2 otherwise
<span class="udiff-line-modified-removed">-             when &quot;a0&quot;</span>
<span class="udiff-line-modified-added">+             when &quot;a0&quot;, &quot;wa0&quot;</span>
                  isWin ? &quot;ecx&quot; : &quot;edi&quot;
<span class="udiff-line-modified-removed">-             when &quot;t1&quot;, &quot;a1&quot;</span>
<span class="udiff-line-modified-added">+             when &quot;t1&quot;, &quot;a1&quot;, &quot;wa1&quot;</span>
                  isWin ? &quot;edx&quot; : &quot;esi&quot;
<span class="udiff-line-modified-removed">-             when &quot;t2&quot;, &quot;a2&quot;</span>
<span class="udiff-line-modified-added">+             when &quot;t2&quot;, &quot;a2&quot;, &quot;wa2&quot;</span>
                  isWin ? &quot;r8&quot; : &quot;edx&quot;
<span class="udiff-line-modified-removed">-             when &quot;t3&quot;, &quot;a3&quot;</span>
<span class="udiff-line-modified-added">+             when &quot;t3&quot;, &quot;a3&quot;, &quot;wa3&quot;</span>
                  isWin ? &quot;r9&quot; : &quot;ecx&quot;
<span class="udiff-line-modified-removed">-             when &quot;t4&quot;</span>
<span class="udiff-line-modified-added">+             when &quot;t4&quot;, &quot;wa4&quot;</span>
                  isWin ? &quot;r10&quot; : &quot;r8&quot;
<span class="udiff-line-modified-removed">-             when &quot;t5&quot;</span>
<span class="udiff-line-modified-removed">-                 isWin ? &quot;ecx&quot; : &quot;r10&quot;</span>
<span class="udiff-line-modified-added">+             when &quot;t5&quot;, &quot;wa5&quot;</span>
<span class="udiff-line-modified-added">+                 isWin ? &quot;ecx&quot; : &quot;r9&quot;</span>
<span class="udiff-line-added">+             when &quot;t6&quot;, &quot;ws1&quot;</span>
<span class="udiff-line-added">+                 raise &quot;cannot use register #{name} on X86-64 Windows&quot; if isWin</span>
<span class="udiff-line-added">+                 &quot;r10&quot;</span>
              when &quot;csr0&quot;
                  &quot;ebx&quot;
              when &quot;csr1&quot;
                  isWin ? &quot;esi&quot; : &quot;r12&quot;
              when &quot;csr2&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -324,24 +329,28 @@</span>
      end
  end
  
  class FPRegisterID
      def x86Operand(kind)
<span class="udiff-line-modified-removed">-         raise unless kind == :double</span>
<span class="udiff-line-modified-added">+         raise unless [:float, :double].include? kind</span>
          case name
<span class="udiff-line-modified-removed">-         when &quot;ft0&quot;, &quot;fa0&quot;, &quot;fr&quot;</span>
<span class="udiff-line-modified-added">+         when &quot;ft0&quot;, &quot;fa0&quot;, &quot;fr&quot;, &quot;wfa0&quot;</span>
              register(&quot;xmm0&quot;)
<span class="udiff-line-modified-removed">-         when &quot;ft1&quot;, &quot;fa1&quot;</span>
<span class="udiff-line-modified-added">+         when &quot;ft1&quot;, &quot;fa1&quot;, &quot;wfa1&quot;</span>
              register(&quot;xmm1&quot;)
<span class="udiff-line-modified-removed">-         when &quot;ft2&quot;, &quot;fa2&quot;</span>
<span class="udiff-line-modified-added">+         when &quot;ft2&quot;, &quot;fa2&quot;, &quot;wfa2&quot;</span>
              register(&quot;xmm2&quot;)
<span class="udiff-line-modified-removed">-         when &quot;ft3&quot;, &quot;fa3&quot;</span>
<span class="udiff-line-modified-added">+         when &quot;ft3&quot;, &quot;fa3&quot;, &quot;wfa3&quot;</span>
              register(&quot;xmm3&quot;)
<span class="udiff-line-modified-removed">-         when &quot;ft4&quot;</span>
<span class="udiff-line-modified-added">+         when &quot;ft4&quot;, &quot;wfa4&quot;</span>
              register(&quot;xmm4&quot;)
<span class="udiff-line-modified-removed">-         when &quot;ft5&quot;</span>
<span class="udiff-line-modified-added">+         when &quot;ft5&quot;, &quot;wfa5&quot;</span>
              register(&quot;xmm5&quot;)
<span class="udiff-line-added">+         when &quot;wfa6&quot;</span>
<span class="udiff-line-added">+             register(&quot;xmm6&quot;)</span>
<span class="udiff-line-added">+         when &quot;wfa7&quot;</span>
<span class="udiff-line-added">+             register(&quot;xmm7&quot;)</span>
          else
              raise &quot;Bad register #{name} for X86 at #{codeOriginString}&quot;
          end
      end
      def x86CallOperand(kind)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -496,11 +505,11 @@</span>
  end
  
  class Instruction
      
      def x86Operands(*kinds)
<span class="udiff-line-modified-removed">-         raise unless kinds.size == operands.size</span>
<span class="udiff-line-modified-added">+         raise &quot;Expected size of kinds to be #{operands.size}, but it was #{kinds.size}&quot; unless kinds.size == operands.size</span>
          result = []
          kinds.size.times {
              | idx |
              i = isIntelSyntax ? (kinds.size - idx - 1) : idx
              result &lt;&lt; operands[i].x86Operand(kinds[i])
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -511,11 +520,11 @@</span>
      def x86LoadOperands(srcKind, dstKind)
          orderOperands(operands[0].x86LoadOperand(srcKind, operands[1]), operands[1].x86Operand(dstKind))
      end
  
      def x86Suffix(kind)
<span class="udiff-line-modified-removed">-         if isIntelSyntax</span>
<span class="udiff-line-modified-added">+         if isIntelSyntax and not [:float, :double].include? kind</span>
              return &quot;&quot;
          end
  
          case kind
          when :byte
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -526,10 +535,12 @@</span>
              &quot;l&quot;
          when :ptr
              isX64 ? &quot;q&quot; : &quot;l&quot;
          when :quad
              isX64 ? &quot;q&quot; : raise
<span class="udiff-line-added">+         when :float</span>
<span class="udiff-line-added">+             &quot;ss&quot;</span>
          when :double
              &quot;sd&quot;
          else
              raise
          end
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -545,10 +556,12 @@</span>
              4
          when :ptr
              isX64 ? 8 : 4
          when :quad
              isX64 ? 8 : raise
<span class="udiff-line-added">+         when :float</span>
<span class="udiff-line-added">+             4</span>
          when :double
              8
          else
              raise
          end
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -598,16 +611,16 @@</span>
              $asm.puts &quot;#{opcode} #{orderOperands(register(&quot;cl&quot;), operands[1].x86Operand(kind))}&quot;
              $asm.puts &quot;xchg#{x86Suffix(:ptr)} #{operands[0].x86Operand(:ptr)}, #{x86GPRName(&quot;ecx&quot;, :ptr)}&quot;
          end
      end
      
<span class="udiff-line-modified-removed">-     def handleX86DoubleBranch(branchOpcode, mode)</span>
<span class="udiff-line-modified-added">+     def handleX86FPBranch(kind, branchOpcode, mode)</span>
          case mode
          when :normal
<span class="udiff-line-modified-removed">-             $asm.puts &quot;ucomisd #{orderOperands(operands[1].x86Operand(:double), operands[0].x86Operand(:double))}&quot;</span>
<span class="udiff-line-modified-added">+             $asm.puts &quot;ucomi#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(:double), operands[0].x86Operand(:double))}&quot;</span>
          when :reverse
<span class="udiff-line-modified-removed">-             $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;</span>
<span class="udiff-line-modified-added">+             $asm.puts &quot;ucomi#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;</span>
          else
              raise mode.inspect
          end
          $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
      end
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -620,10 +633,20 @@</span>
          else
              $asm.puts &quot;cmp#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind))}&quot;
          end
      end
      
<span class="udiff-line-added">+     def handleX86IntCompare(opcodeSuffix, kind)</span>
<span class="udiff-line-added">+         if operands[0].is_a? Immediate and operands[0].value == 0 and operands[1].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)</span>
<span class="udiff-line-added">+             $asm.puts &quot;test#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[1].x86Operand(kind))}&quot;</span>
<span class="udiff-line-added">+         elsif operands[1].is_a? Immediate and operands[1].value == 0 and operands[0].is_a? RegisterID and (opcodeSuffix == &quot;e&quot; or opcodeSuffix == &quot;ne&quot;)</span>
<span class="udiff-line-added">+             $asm.puts &quot;test#{x86Suffix(kind)}  #{orderOperands(operands[0].x86Operand(kind), operands[0].x86Operand(kind))}&quot;</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             $asm.puts &quot;cmp#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind))}&quot;</span>
<span class="udiff-line-added">+         end</span>
<span class="udiff-line-added">+     end</span>
<span class="udiff-line-added">+ </span>
      def handleX86IntBranch(branchOpcode, kind)
          handleX86IntCompare(branchOpcode[1..-1], kind)
          $asm.puts &quot;#{branchOpcode} #{operands[2].asmLabel}&quot;
      end
      
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -650,10 +673,63 @@</span>
      
      def handleX86IntCompareSet(setOpcode, kind)
          handleX86IntCompare(setOpcode[3..-1], kind)
          handleX86Set(setOpcode, operands[2])
      end
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     def handleX86FPCompareSet(kind, setOpcode, order = :normal)</span>
<span class="udiff-line-added">+         is_special = setOpcode.is_a? Symbol</span>
<span class="udiff-line-added">+         left = operands[0]</span>
<span class="udiff-line-added">+         right = operands[1]</span>
<span class="udiff-line-added">+         target = operands[2]</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         compare = lambda do |lhs, rhs|</span>
<span class="udiff-line-added">+             $asm.puts &quot;ucomi#{x86Suffix(kind)} #{orderOperands(lhs.x86Operand(:double), rhs.x86Operand(:double))}&quot;</span>
<span class="udiff-line-added">+         end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if is_special</span>
<span class="udiff-line-added">+             case setOpcode</span>
<span class="udiff-line-added">+             when :eq</span>
<span class="udiff-line-added">+                 if left == right</span>
<span class="udiff-line-added">+                     compare.call(right, left)</span>
<span class="udiff-line-added">+                     handleX86Set(&quot;setnp&quot;, operands[2])</span>
<span class="udiff-line-added">+                     return</span>
<span class="udiff-line-added">+                 end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 isUnordered = LocalLabel.unique(&quot;isUnordered&quot;)</span>
<span class="udiff-line-added">+                 $asm.puts &quot;movq $0, #{target.x86Operand(:quad)}&quot;</span>
<span class="udiff-line-added">+                 compare.call(right, left)</span>
<span class="udiff-line-added">+                 $asm.puts &quot;jp #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="udiff-line-added">+                 handleX86Set(&quot;sete&quot;, target)</span>
<span class="udiff-line-added">+                 isUnordered.lower($activeBackend)</span>
<span class="udiff-line-added">+                 return</span>
<span class="udiff-line-added">+             when :nequn</span>
<span class="udiff-line-added">+                 if left == right</span>
<span class="udiff-line-added">+                     compare.call(right, left)</span>
<span class="udiff-line-added">+                     handleX86Set(&quot;setp&quot;, target)</span>
<span class="udiff-line-added">+                     return</span>
<span class="udiff-line-added">+                 end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+                 isUnordered = LocalLabel.unique(&quot;isUnordered&quot;)</span>
<span class="udiff-line-added">+                 $asm.puts &quot;movq $1, #{target.x86Operand(:quad)}&quot;</span>
<span class="udiff-line-added">+                 compare.call(right, left);</span>
<span class="udiff-line-added">+                 $asm.puts &quot;jp #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="udiff-line-added">+                 handleX86Set(&quot;setne&quot;, target)</span>
<span class="udiff-line-added">+                 isUnordered.lower($activeBackend)</span>
<span class="udiff-line-added">+                 return</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 raise &quot;Uhandled special opcode: #{setOpcode}&quot;</span>
<span class="udiff-line-added">+             end</span>
<span class="udiff-line-added">+         end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         if order == :normal</span>
<span class="udiff-line-added">+             compare.call(right, left)</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             compare.call(left, right)</span>
<span class="udiff-line-added">+         end</span>
<span class="udiff-line-added">+         handleX86Set(setOpcode, target)</span>
<span class="udiff-line-added">+     end</span>
      
      def handleX86Test(kind)
          value = operands[0]
          case operands.size
          when 2
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -747,11 +823,11 @@</span>
              unless Immediate.new(nil, 0) == operands[0]
                  $asm.puts &quot;add#{x86Suffix(kind)} #{x86Operands(kind, kind)}&quot;
              end
          end
      end
<span class="udiff-line-modified-removed">-     </span>
<span class="udiff-line-modified-added">+ </span>
      def handleX86Sub(kind)
          if operands.size == 3
              if Immediate.new(nil, 0) == operands[1]
                  raise unless operands[0].is_a? RegisterID
                  raise unless operands[2].is_a? RegisterID
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -793,10 +869,50 @@</span>
          end
  
          handleX86Op(&quot;imul#{x86Suffix(kind)}&quot;, kind)
      end
      
<span class="udiff-line-added">+     def handleX86AddFP(kind)</span>
<span class="udiff-line-added">+         if operands.size == 2</span>
<span class="udiff-line-added">+             $asm.puts &quot;add#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;</span>
<span class="udiff-line-added">+         elsif operands.size == 3</span>
<span class="udiff-line-added">+             $asm.puts &quot;vadd#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             raise &quot;Unexpected number of operands for floating point addition: #{operands.size}&quot;</span>
<span class="udiff-line-added">+         end</span>
<span class="udiff-line-added">+     end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     def handleX86SubFP(kind)</span>
<span class="udiff-line-added">+         if operands.size == 2</span>
<span class="udiff-line-added">+             $asm.puts &quot;sub#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;</span>
<span class="udiff-line-added">+         elsif operands.size == 3</span>
<span class="udiff-line-added">+             $asm.puts &quot;vsub#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             raise &quot;Unexpected number of operands for floating point addition: #{operands.size}&quot;</span>
<span class="udiff-line-added">+         end</span>
<span class="udiff-line-added">+     end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     def handleX86MulFP(kind)</span>
<span class="udiff-line-added">+         if operands.size == 2</span>
<span class="udiff-line-added">+             $asm.puts &quot;mul#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;</span>
<span class="udiff-line-added">+         elsif operands.size == 3</span>
<span class="udiff-line-added">+             $asm.puts &quot;vmul#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             raise &quot;Unexpected number of operands for floating point addition: #{operands.size}&quot;</span>
<span class="udiff-line-added">+         end</span>
<span class="udiff-line-added">+     end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     def handleX86DivFP(kind)</span>
<span class="udiff-line-added">+         if operands.size == 2</span>
<span class="udiff-line-added">+             $asm.puts &quot;div#{x86Suffix(kind)} #{orderOperands(operands[0].x86Operand(kind), operands[1].x86Operand(kind))}&quot;</span>
<span class="udiff-line-added">+         elsif operands.size == 3</span>
<span class="udiff-line-added">+             $asm.puts &quot;vdiv#{x86Suffix(kind)} #{orderOperands(operands[1].x86Operand(kind), operands[0].x86Operand(kind), operands[2].x86Operand(kind))}&quot;</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             raise &quot;Unexpected number of operands for floating point addition: #{operands.size}&quot;</span>
<span class="udiff-line-added">+         end</span>
<span class="udiff-line-added">+     end</span>
<span class="udiff-line-added">+ </span>
      def handleX86Peek()
          sp = RegisterID.new(nil, &quot;sp&quot;)
          opA = offsetRegister(operands[0].value * x86Bytes(:ptr), sp.x86Operand(:ptr))
          opB = operands[1].x86Operand(:ptr)
          $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(opA, opB)}&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -823,10 +939,124 @@</span>
                  $asm.puts &quot;mov#{x86Suffix(:ptr)} #{x86Operands(:ptr, :ptr)}&quot;
              end
          end
      end
  
<span class="udiff-line-added">+     def countLeadingZeros(kind)</span>
<span class="udiff-line-added">+         target = operands[1]</span>
<span class="udiff-line-added">+         srcIsNonZero = LocalLabel.unique(&quot;srcIsNonZero&quot;)</span>
<span class="udiff-line-added">+         skipNonZeroCase = LocalLabel.unique(&quot;skipNonZeroCase&quot;)</span>
<span class="udiff-line-added">+         zeroValue = Immediate.new(codeOrigin, x86Bytes(kind) * 8)</span>
<span class="udiff-line-added">+         xorValue = Immediate.new(codeOrigin, kind == :quad ? 0x3f : 0x1f)</span>
<span class="udiff-line-added">+         xor = kind == :quad ? &quot;xorq&quot; : &quot;xori&quot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         $asm.puts &quot;bsr#{x86Suffix(kind)} #{x86Operands(kind, kind)}&quot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Sequence.new(codeOrigin, [</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;bnz&quot;, [LocalLabelReference.new(codeOrigin, srcIsNonZero)]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;move&quot;, [zeroValue, target]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;jmp&quot;, [LocalLabelReference.new(codeOrigin, skipNonZeroCase)]),</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             srcIsNonZero,</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, xor, [xorValue, target]),</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             skipNonZeroCase,</span>
<span class="udiff-line-added">+         ]).lower($activeBackend)</span>
<span class="udiff-line-added">+     end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     def countTrailingZeros(kind)</span>
<span class="udiff-line-added">+         target = operands[1]</span>
<span class="udiff-line-added">+         srcIsNonZero = LocalLabel.unique(&quot;srcIsNonZero&quot;)</span>
<span class="udiff-line-added">+         zeroValue = Immediate.new(codeOrigin, x86Bytes(kind) * 8)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         $asm.puts &quot;bsf#{x86Suffix(kind)} #{x86Operands(kind, kind)}&quot;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Sequence.new(codeOrigin, [</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;bnz&quot;, [LocalLabelReference.new(codeOrigin, srcIsNonZero)]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;move&quot;, [zeroValue, target]),</span>
<span class="udiff-line-added">+             srcIsNonZero,</span>
<span class="udiff-line-added">+         ]).lower($activeBackend)</span>
<span class="udiff-line-added">+     end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     def truncateFloatingPointToQuad(kind)</span>
<span class="udiff-line-added">+         src = operands[0]</span>
<span class="udiff-line-added">+         dst = operands[1]</span>
<span class="udiff-line-added">+         slow = LocalLabel.unique(&quot;slow&quot;)</span>
<span class="udiff-line-added">+         done = LocalLabel.unique(&quot;done&quot;)</span>
<span class="udiff-line-added">+         gprScratch = X64_SCRATCH_REGISTER</span>
<span class="udiff-line-added">+         fprScratch = FPRegisterID.forName(codeOrigin, &quot;wfa7&quot;)</span>
<span class="udiff-line-added">+         int64SignBit = Immediate.new(codeOrigin, 0x8000000000000000)</span>
<span class="udiff-line-added">+         case kind</span>
<span class="udiff-line-added">+         when :float</span>
<span class="udiff-line-added">+             int64Min = Immediate.new(codeOrigin, 0xdf000000)</span>
<span class="udiff-line-added">+             negInt64Min = Immediate.new(codeOrigin, 0x5f000000)</span>
<span class="udiff-line-added">+             integerSuffix = &quot;i&quot;</span>
<span class="udiff-line-added">+             floatingSuffix = &quot;f&quot;</span>
<span class="udiff-line-added">+         when :double</span>
<span class="udiff-line-added">+             int64Min = Immediate.new(codeOrigin, 0xc3e0000000000000)</span>
<span class="udiff-line-added">+             negInt64Min = Immediate.new(codeOrigin, 0x43e0000000000000)</span>
<span class="udiff-line-added">+             integerSuffix = &quot;q&quot;</span>
<span class="udiff-line-added">+             floatingSuffix = &quot;d&quot;</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             raise</span>
<span class="udiff-line-added">+         end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Sequence.new(codeOrigin, [</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;move&quot;, [negInt64Min, gprScratch]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;f#{integerSuffix}2#{floatingSuffix}&quot;, [gprScratch, fprScratch]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;b#{floatingSuffix}gteq&quot;, [src, fprScratch, LocalLabelReference.new(codeOrigin, slow)]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;truncate#{floatingSuffix}2qs&quot;, [src, dst]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;jmp&quot;, [LocalLabelReference.new(codeOrigin, done)]),</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             slow,</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;move&quot;, [int64Min, gprScratch]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;f#{integerSuffix}2#{floatingSuffix}&quot;, [gprScratch, fprScratch]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;add#{floatingSuffix}&quot;, [src, fprScratch]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;truncate#{floatingSuffix}2qs&quot;, [fprScratch, dst]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;move&quot;, [int64SignBit, gprScratch]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;orq&quot;, [gprScratch, dst]),</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             done,</span>
<span class="udiff-line-added">+         ]).lower($activeBackend)</span>
<span class="udiff-line-added">+     end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     def convertQuadToFloatingPoint(kind)</span>
<span class="udiff-line-added">+         src = operands[0]</span>
<span class="udiff-line-added">+         scratch1 = operands[1]</span>
<span class="udiff-line-added">+         dst = operands[2]</span>
<span class="udiff-line-added">+         slow = LocalLabel.unique(&quot;slow&quot;)</span>
<span class="udiff-line-added">+         done = LocalLabel.unique(&quot;done&quot;)</span>
<span class="udiff-line-added">+         scratch2 = X64_SCRATCH_REGISTER</span>
<span class="udiff-line-added">+         one = Immediate.new(codeOrigin, 0x1)</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         case kind</span>
<span class="udiff-line-added">+         when :float</span>
<span class="udiff-line-added">+             floatingSuffix = &quot;f&quot;</span>
<span class="udiff-line-added">+         when :double</span>
<span class="udiff-line-added">+             floatingSuffix = &quot;d&quot;</span>
<span class="udiff-line-added">+         else</span>
<span class="udiff-line-added">+             raise</span>
<span class="udiff-line-added">+         end</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+         Sequence.new(codeOrigin, [</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;btqs&quot;, [src, LocalLabelReference.new(codeOrigin, slow)]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;cq2#{floatingSuffix}s&quot;, [src, dst]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;jmp&quot;, [LocalLabelReference.new(codeOrigin, done)]),</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             slow,</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;move&quot;, [src, scratch1]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;move&quot;, [src, scratch2]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;urshiftq&quot;, [one, scratch1]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;andq&quot;, [one, scratch2]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;orq&quot;, [scratch1, scratch2]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;cq2#{floatingSuffix}s&quot;, [scratch2, dst]),</span>
<span class="udiff-line-added">+             Instruction.new(codeOrigin, &quot;add#{floatingSuffix}&quot;, [dst, dst]),</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+             done,</span>
<span class="udiff-line-added">+         ]).lower($activeBackend)</span>
<span class="udiff-line-added">+     end</span>
<span class="udiff-line-added">+ </span>
      def lowerX86
          raise unless $activeBackend == &quot;X86&quot;
          lowerX86Common
      end
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -857,10 +1087,14 @@</span>
              handleX86Op(&quot;and#{x86Suffix(:int)}&quot;, :int)
          when &quot;andp&quot;
              handleX86Op(&quot;and#{x86Suffix(:ptr)}&quot;, :ptr)
          when &quot;andq&quot;
              handleX86Op(&quot;and#{x86Suffix(:quad)}&quot;, :quad)
<span class="udiff-line-added">+         when &quot;andf&quot;</span>
<span class="udiff-line-added">+             handleX86Op(&quot;andps&quot;, :float)</span>
<span class="udiff-line-added">+         when &quot;andd&quot;</span>
<span class="udiff-line-added">+             handleX86Op(&quot;andpd&quot;, :double)</span>
          when &quot;lshifti&quot;
              handleX86Shift(&quot;sal#{x86Suffix(:int)}&quot;, :int)
          when &quot;lshiftp&quot;
              handleX86Shift(&quot;sal#{x86Suffix(:ptr)}&quot;, :ptr)
          when &quot;lshiftq&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -883,10 +1117,16 @@</span>
              handleX86Op(&quot;or#{x86Suffix(:int)}&quot;, :int)
          when &quot;orp&quot;
              handleX86Op(&quot;or#{x86Suffix(:ptr)}&quot;, :ptr)
          when &quot;orq&quot;
              handleX86Op(&quot;or#{x86Suffix(:quad)}&quot;, :quad)
<span class="udiff-line-added">+         when &quot;orf&quot;</span>
<span class="udiff-line-added">+             handleX86Op(&quot;orps&quot;, :float)</span>
<span class="udiff-line-added">+         when &quot;ord&quot;</span>
<span class="udiff-line-added">+             handleX86Op(&quot;orpd&quot;, :double)</span>
<span class="udiff-line-added">+         when &quot;orh&quot;</span>
<span class="udiff-line-added">+             handleX86Op(&quot;or#{x86Suffix(:half)}&quot;, :half)</span>
          when &quot;rshifti&quot;
              handleX86Shift(&quot;sar#{x86Suffix(:int)}&quot;, :int)
          when &quot;rshiftp&quot;
              handleX86Shift(&quot;sar#{x86Suffix(:ptr)}&quot;, :ptr)
          when &quot;rshiftq&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -895,10 +1135,18 @@</span>
              handleX86Shift(&quot;shr#{x86Suffix(:int)}&quot;, :int)
          when &quot;urshiftp&quot;
              handleX86Shift(&quot;shr#{x86Suffix(:ptr)}&quot;, :ptr)
          when &quot;urshiftq&quot;
              handleX86Shift(&quot;shr#{x86Suffix(:quad)}&quot;, :quad)
<span class="udiff-line-added">+         when &quot;rrotatei&quot;</span>
<span class="udiff-line-added">+             handleX86Shift(&quot;ror#{x86Suffix(:int)}&quot;, :int)</span>
<span class="udiff-line-added">+         when &quot;rrotateq&quot;</span>
<span class="udiff-line-added">+             handleX86Shift(&quot;ror#{x86Suffix(:quad)}&quot;, :quad)</span>
<span class="udiff-line-added">+         when &quot;lrotatei&quot;</span>
<span class="udiff-line-added">+             handleX86Shift(&quot;rol#{x86Suffix(:int)}&quot;, :int)</span>
<span class="udiff-line-added">+         when &quot;lrotateq&quot;</span>
<span class="udiff-line-added">+             handleX86Shift(&quot;rol#{x86Suffix(:quad)}&quot;, :quad)</span>
          when &quot;subi&quot;
              handleX86Sub(:int)
          when &quot;subp&quot;
              handleX86Sub(:ptr)
          when &quot;subq&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -969,73 +1217,164 @@</span>
              else
                  $asm.puts &quot;movsx #{x86LoadOperands(:half, :quad)}&quot;
              end
          when &quot;storeb&quot;
              $asm.puts &quot;mov#{x86Suffix(:byte)} #{x86Operands(:byte, :byte)}&quot;
<span class="udiff-line-added">+         when &quot;storeh&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;mov#{x86Suffix(:half)} #{x86Operands(:half, :half)}&quot;</span>
<span class="udiff-line-added">+         when &quot;loadf&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;movss #{x86Operands(:float, :float)}&quot;</span>
          when &quot;loadd&quot;
              $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;
          when &quot;moved&quot;
              $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;
<span class="udiff-line-added">+         when &quot;storef&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;movss #{x86Operands(:float, :float)}&quot;</span>
          when &quot;stored&quot;
              $asm.puts &quot;movsd #{x86Operands(:double, :double)}&quot;
<span class="udiff-line-added">+         when &quot;addf&quot;</span>
<span class="udiff-line-added">+             handleX86AddFP(:float)</span>
          when &quot;addd&quot;
<span class="udiff-line-modified-removed">-             $asm.puts &quot;addsd #{x86Operands(:double, :double)}&quot;</span>
<span class="udiff-line-modified-added">+             handleX86AddFP(:double)</span>
<span class="udiff-line-added">+         when &quot;mulf&quot;</span>
<span class="udiff-line-added">+             handleX86MulFP(:float)</span>
          when &quot;muld&quot;
<span class="udiff-line-modified-removed">-             $asm.puts &quot;mulsd #{x86Operands(:double, :double)}&quot;</span>
<span class="udiff-line-modified-added">+             handleX86MulFP(:double)</span>
<span class="udiff-line-added">+         when &quot;subf&quot;</span>
<span class="udiff-line-added">+             handleX86SubFP(:float)</span>
          when &quot;subd&quot;
<span class="udiff-line-modified-removed">-             $asm.puts &quot;subsd #{x86Operands(:double, :double)}&quot;</span>
<span class="udiff-line-modified-added">+             handleX86SubFP(:double)</span>
<span class="udiff-line-added">+         when &quot;divf&quot;</span>
<span class="udiff-line-added">+             handleX86DivFP(:float)</span>
          when &quot;divd&quot;
<span class="udiff-line-modified-removed">-             $asm.puts &quot;divsd #{x86Operands(:double, :double)}&quot;</span>
<span class="udiff-line-modified-added">+             handleX86DivFP(:double)</span>
<span class="udiff-line-added">+         when &quot;sqrtf&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;sqrtss #{operands[0].x86Operand(:float)}, #{operands[1].x86Operand(:float)}&quot;</span>
          when &quot;sqrtd&quot;
              $asm.puts &quot;sqrtsd #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;
<span class="udiff-line-added">+         when &quot;roundf&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;roundss $0, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="udiff-line-added">+         when &quot;roundd&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;roundsd $0, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="udiff-line-added">+         when &quot;floorf&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;roundss $1, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="udiff-line-added">+         when &quot;floord&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;roundsd $1, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="udiff-line-added">+         when &quot;ceilf&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;roundss $2, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="udiff-line-added">+         when &quot;ceild&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;roundsd $2, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="udiff-line-added">+         when &quot;truncatef&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;roundss $3, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="udiff-line-added">+         when &quot;truncated&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;roundsd $3, #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:double)}&quot;</span>
<span class="udiff-line-added">+         when &quot;truncatef2i&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;cvttss2si #{operands[0].x86Operand(:float)}, #{operands[1].x86Operand(:quad)}&quot;</span>
<span class="udiff-line-added">+         when &quot;truncated2i&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:quad)}&quot;</span>
<span class="udiff-line-added">+         when &quot;truncatef2q&quot;</span>
<span class="udiff-line-added">+             truncateFloatingPointToQuad(:float)</span>
<span class="udiff-line-added">+         when &quot;truncated2q&quot;</span>
<span class="udiff-line-added">+             truncateFloatingPointToQuad(:double)</span>
<span class="udiff-line-added">+         when &quot;truncatef2is&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;cvttss2si #{operands[0].x86Operand(:float)}, #{operands[1].x86Operand(:int)}&quot;</span>
<span class="udiff-line-added">+         when &quot;truncatef2qs&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;cvttss2si #{operands[0].x86Operand(:float)}, #{operands[1].x86Operand(:quad)}&quot;</span>
<span class="udiff-line-added">+         when &quot;truncated2is&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;</span>
<span class="udiff-line-added">+         when &quot;truncated2qs&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:quad)}&quot;</span>
          when &quot;ci2d&quot;
<span class="udiff-line-added">+             $asm.puts &quot;cvtsi2sd #{orderOperands(operands[0].x86Operand(:quad), operands[1].x86Operand(:double))}&quot;</span>
<span class="udiff-line-added">+         when &quot;ci2ds&quot;</span>
              $asm.puts &quot;cvtsi2sd #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:double))}&quot;
<span class="udiff-line-added">+         when &quot;ci2fs&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;cvtsi2ss #{orderOperands(operands[0].x86Operand(:int), operands[1].x86Operand(:float))}&quot;</span>
<span class="udiff-line-added">+         when &quot;ci2f&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;cvtsi2ss #{orderOperands(operands[0].x86Operand(:quad), operands[1].x86Operand(:float))}&quot;</span>
<span class="udiff-line-added">+         when &quot;cq2f&quot;</span>
<span class="udiff-line-added">+             convertQuadToFloatingPoint(:float)</span>
<span class="udiff-line-added">+         when &quot;cq2d&quot;</span>
<span class="udiff-line-added">+             convertQuadToFloatingPoint(:double)</span>
<span class="udiff-line-added">+         when &quot;cq2fs&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;cvtsi2ssq #{orderOperands(operands[0].x86Operand(:quad), operands[1].x86Operand(:float))}&quot;</span>
<span class="udiff-line-added">+         when &quot;cq2ds&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;cvtsi2sdq #{orderOperands(operands[0].x86Operand(:quad), operands[1].x86Operand(:double))}&quot;</span>
<span class="udiff-line-added">+         when &quot;cd2f&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;cvtsd2ss #{x86Operands(:double, :float)}&quot;</span>
<span class="udiff-line-added">+         when &quot;cf2d&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;cvtss2sd #{x86Operands(:float, :double)}&quot;</span>
          when &quot;bdeq&quot;
              $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
              if operands[0] == operands[1]
                  # This is just a jump ordered, which is a jnp.
                  $asm.puts &quot;jnp #{operands[2].asmLabel}&quot;
              else
                  isUnordered = LocalLabel.unique(&quot;bdeq&quot;)
<span class="udiff-line-modified-removed">-                 $asm.puts &quot;jp #{LabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="udiff-line-modified-removed">-                 $asm.puts &quot;je #{LabelReference.new(codeOrigin, operands[2]).asmLabel}&quot;</span>
<span class="udiff-line-modified-removed">-                 isUnordered.lower(&quot;X86&quot;)</span>
<span class="udiff-line-modified-added">+                 $asm.puts &quot;jp #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="udiff-line-modified-added">+                 $asm.puts &quot;je #{LocalLabelReference.new(codeOrigin, operands[2]).asmLabel}&quot;</span>
<span class="udiff-line-modified-added">+                 isUnordered.lower($activeBackend)</span>
              end
          when &quot;bdneq&quot;
<span class="udiff-line-modified-removed">-             handleX86DoubleBranch(&quot;jne&quot;, :normal)</span>
<span class="udiff-line-modified-added">+             handleX86FPBranch(:double, &quot;jne&quot;, :normal)</span>
          when &quot;bdgt&quot;
<span class="udiff-line-modified-removed">-             handleX86DoubleBranch(&quot;ja&quot;, :normal)</span>
<span class="udiff-line-modified-added">+             handleX86FPBranch(:double, &quot;ja&quot;, :normal)</span>
          when &quot;bdgteq&quot;
<span class="udiff-line-modified-removed">-             handleX86DoubleBranch(&quot;jae&quot;, :normal)</span>
<span class="udiff-line-modified-added">+             handleX86FPBranch(:double, &quot;jae&quot;, :normal)</span>
          when &quot;bdlt&quot;
<span class="udiff-line-modified-removed">-             handleX86DoubleBranch(&quot;ja&quot;, :reverse)</span>
<span class="udiff-line-modified-added">+             handleX86FPBranch(:double, &quot;ja&quot;, :reverse)</span>
          when &quot;bdlteq&quot;
<span class="udiff-line-modified-removed">-             handleX86DoubleBranch(&quot;jae&quot;, :reverse)</span>
<span class="udiff-line-modified-added">+             handleX86FPBranch(:double, &quot;jae&quot;, :reverse)</span>
          when &quot;bdequn&quot;
<span class="udiff-line-modified-removed">-             handleX86DoubleBranch(&quot;je&quot;, :normal)</span>
<span class="udiff-line-modified-added">+             handleX86FPBranch(:double, &quot;je&quot;, :normal)</span>
          when &quot;bdnequn&quot;
              $asm.puts &quot;ucomisd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;
              if operands[0] == operands[1]
                  # This is just a jump unordered, which is a jp.
                  $asm.puts &quot;jp #{operands[2].asmLabel}&quot;
              else
                  isUnordered = LocalLabel.unique(&quot;bdnequn&quot;)
                  isEqual = LocalLabel.unique(&quot;bdnequn&quot;)
<span class="udiff-line-modified-removed">-                 $asm.puts &quot;jp #{LabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="udiff-line-modified-removed">-                 $asm.puts &quot;je #{LabelReference.new(codeOrigin, isEqual).asmLabel}&quot;</span>
<span class="udiff-line-modified-removed">-                 isUnordered.lower(&quot;X86&quot;)</span>
<span class="udiff-line-modified-added">+                 $asm.puts &quot;jp #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="udiff-line-modified-added">+                 $asm.puts &quot;je #{LocalLabelReference.new(codeOrigin, isEqual).asmLabel}&quot;</span>
<span class="udiff-line-modified-added">+                 isUnordered.lower($activeBackend)</span>
                  $asm.puts &quot;jmp #{operands[2].asmLabel}&quot;
<span class="udiff-line-modified-removed">-                 isEqual.lower(&quot;X86&quot;)</span>
<span class="udiff-line-modified-added">+                 isEqual.lower($activeBackend)</span>
              end
          when &quot;bdgtun&quot;
<span class="udiff-line-modified-removed">-             handleX86DoubleBranch(&quot;jb&quot;, :reverse)</span>
<span class="udiff-line-modified-added">+             handleX86FPBranch(:double, &quot;jb&quot;, :reverse)</span>
          when &quot;bdgtequn&quot;
<span class="udiff-line-modified-removed">-             handleX86DoubleBranch(&quot;jbe&quot;, :reverse)</span>
<span class="udiff-line-modified-added">+             handleX86FPBranch(:double, &quot;jbe&quot;, :reverse)</span>
          when &quot;bdltun&quot;
<span class="udiff-line-modified-removed">-             handleX86DoubleBranch(&quot;jb&quot;, :normal)</span>
<span class="udiff-line-modified-added">+             handleX86FPBranch(:double, &quot;jb&quot;, :normal)</span>
          when &quot;bdltequn&quot;
<span class="udiff-line-modified-removed">-             handleX86DoubleBranch(&quot;jbe&quot;, :normal)</span>
<span class="udiff-line-modified-added">+             handleX86FPBranch(:double, &quot;jbe&quot;, :normal)</span>
<span class="udiff-line-added">+         when &quot;bfeq&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;ucomiss #{orderOperands(operands[0].x86Operand(:float), operands[1].x86Operand(:float))}&quot;</span>
<span class="udiff-line-added">+             if operands[0] == operands[1]</span>
<span class="udiff-line-added">+                 # This is just a jump ordered, which is a jnp.</span>
<span class="udiff-line-added">+                 $asm.puts &quot;jnp #{operands[2].asmLabel}&quot;</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 isUnordered = LocalLabel.unique(&quot;bfeq&quot;)</span>
<span class="udiff-line-added">+                 $asm.puts &quot;jp #{LocalLabelReference.new(codeOrigin, isUnordered).asmLabel}&quot;</span>
<span class="udiff-line-added">+                 $asm.puts &quot;je #{LocalLabelReference.new(codeOrigin, operands[2]).asmLabel}&quot;</span>
<span class="udiff-line-added">+                 isUnordered.lower($activeBackend)</span>
<span class="udiff-line-added">+             end</span>
<span class="udiff-line-added">+         when &quot;bfgt&quot;</span>
<span class="udiff-line-added">+             handleX86FPBranch(:float, &quot;ja&quot;, :normal)</span>
<span class="udiff-line-added">+         when &quot;bfgteq&quot;</span>
<span class="udiff-line-added">+             handleX86FPBranch(:float, &quot;jae&quot;, :normal)</span>
<span class="udiff-line-added">+         when &quot;bflt&quot;</span>
<span class="udiff-line-added">+             handleX86FPBranch(:float, &quot;ja&quot;, :reverse)</span>
<span class="udiff-line-added">+         when &quot;bfgtun&quot;</span>
<span class="udiff-line-added">+             handleX86FPBranch(:float, &quot;jb&quot;, :reverse)</span>
<span class="udiff-line-added">+         when &quot;bfgtequn&quot;</span>
<span class="udiff-line-added">+             handleX86FPBranch(:float, &quot;jbe&quot;, :reverse)</span>
<span class="udiff-line-added">+         when &quot;bfltun&quot;</span>
<span class="udiff-line-added">+             handleX86FPBranch(:float, &quot;jb&quot;, :normal)</span>
<span class="udiff-line-added">+         when &quot;bfltequn&quot;</span>
<span class="udiff-line-added">+             handleX86FPBranch(:float, &quot;jbe&quot;, :normal)</span>
          when &quot;btd2i&quot;
              $asm.puts &quot;cvttsd2si #{operands[0].x86Operand(:double)}, #{operands[1].x86Operand(:int)}&quot;
              $asm.puts &quot;cmpl $0x80000000 #{operands[1].x86Operand(:int)}&quot;
              $asm.puts &quot;je #{operands[2].asmLabel}&quot;
          when &quot;td2i&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1314,10 +1653,38 @@</span>
              handleX86IntCompareSet(&quot;setle&quot;, :byte)
          when &quot;cplteq&quot;
              handleX86IntCompareSet(&quot;setle&quot;, :ptr)
          when &quot;cqlteq&quot;
              handleX86IntCompareSet(&quot;setle&quot;, :quad)
<span class="udiff-line-added">+         when &quot;cfeq&quot;</span>
<span class="udiff-line-added">+             handleX86FPCompareSet(:float, :eq)</span>
<span class="udiff-line-added">+         when &quot;cdeq&quot;</span>
<span class="udiff-line-added">+             handleX86FPCompareSet(:double, :eq)</span>
<span class="udiff-line-added">+         when &quot;cfneq&quot;</span>
<span class="udiff-line-added">+             handleX86FPCompareSet(:float, &quot;setne&quot;)</span>
<span class="udiff-line-added">+         when &quot;cdneq&quot;</span>
<span class="udiff-line-added">+             handleX86FPCompareSet(:double, &quot;setne&quot;)</span>
<span class="udiff-line-added">+         when &quot;cfnequn&quot;</span>
<span class="udiff-line-added">+             handleX86FPCompareSet(:float, :nequn)</span>
<span class="udiff-line-added">+         when &quot;cdnequn&quot;</span>
<span class="udiff-line-added">+             handleX86FPCompareSet(:double, :nequn)</span>
<span class="udiff-line-added">+         when &quot;cfgt&quot;</span>
<span class="udiff-line-added">+             handleX86FPCompareSet(:float, &quot;seta&quot;)</span>
<span class="udiff-line-added">+         when &quot;cdgt&quot;</span>
<span class="udiff-line-added">+             handleX86FPCompareSet(:double, &quot;seta&quot;)</span>
<span class="udiff-line-added">+         when &quot;cfgteq&quot;</span>
<span class="udiff-line-added">+             handleX86FPCompareSet(:float, &quot;setae&quot;)</span>
<span class="udiff-line-added">+         when &quot;cdgteq&quot;</span>
<span class="udiff-line-added">+             handleX86FPCompareSet(:double, &quot;setae&quot;)</span>
<span class="udiff-line-added">+         when &quot;cflt&quot;</span>
<span class="udiff-line-added">+             handleX86FPCompareSet(:float, &quot;seta&quot;, :reverse)</span>
<span class="udiff-line-added">+         when &quot;cdlt&quot;</span>
<span class="udiff-line-added">+             handleX86FPCompareSet(:double, &quot;seta&quot;, :reverse)</span>
<span class="udiff-line-added">+         when &quot;cflteq&quot;</span>
<span class="udiff-line-added">+             handleX86FPCompareSet(:float, &quot;setae&quot;, :reverse)</span>
<span class="udiff-line-added">+         when &quot;cdlteq&quot;</span>
<span class="udiff-line-added">+             handleX86FPCompareSet(:double, &quot;setae&quot;, :reverse)</span>
          when &quot;tis&quot;
              handleX86SetTest(&quot;sets&quot;, :int)
          when &quot;tiz&quot;
              handleX86SetTest(&quot;setz&quot;, :int)
          when &quot;tinz&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1344,12 +1711,32 @@</span>
              handleX86Peek()
          when &quot;poke&quot;
              handleX86Poke()
          when &quot;cdqi&quot;
              $asm.puts &quot;cdq&quot;
<span class="udiff-line-added">+         when &quot;cqoq&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;cqo&quot;</span>
          when &quot;idivi&quot;
              $asm.puts &quot;idiv#{x86Suffix(:int)} #{operands[0].x86Operand(:int)}&quot;
<span class="udiff-line-added">+         when &quot;udivi&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;div#{x86Suffix(:int)} #{operands[0].x86Operand(:int)}&quot;</span>
<span class="udiff-line-added">+         when &quot;idivq&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;idiv#{x86Suffix(:quad)} #{operands[0].x86Operand(:quad)}&quot;</span>
<span class="udiff-line-added">+         when &quot;udivq&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;div#{x86Suffix(:quad)} #{operands[0].x86Operand(:quad)}&quot;</span>
<span class="udiff-line-added">+         when &quot;popcnti&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;popcnt#{x86Suffix(:int)} #{x86Operands(:int, :int)}&quot;</span>
<span class="udiff-line-added">+         when &quot;popcntq&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;popcnt#{x86Suffix(:quad)} #{x86Operands(:quad, :quad)}&quot;</span>
<span class="udiff-line-added">+         when &quot;tzcnti&quot;</span>
<span class="udiff-line-added">+             countTrailingZeros(:int)</span>
<span class="udiff-line-added">+         when &quot;tzcntq&quot;</span>
<span class="udiff-line-added">+             countTrailingZeros(:quad)</span>
<span class="udiff-line-added">+         when &quot;lzcnti&quot;</span>
<span class="udiff-line-added">+             countLeadingZeros(:int)</span>
<span class="udiff-line-added">+         when &quot;lzcntq&quot;</span>
<span class="udiff-line-added">+             countLeadingZeros(:quad)</span>
          when &quot;fii2d&quot;
              $asm.puts &quot;movd #{operands[0].x86Operand(:int)}, #{operands[2].x86Operand(:double)}&quot;
              $asm.puts &quot;movd #{operands[1].x86Operand(:int)}, %xmm7&quot;
              $asm.puts &quot;psllq $32, %xmm7&quot;
              $asm.puts &quot;por %xmm7, #{operands[2].x86Operand(:double)}&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1372,10 +1759,14 @@</span>
              else
                  # MASM does not accept register operands with movq.
                  # Debugging shows that movd actually moves a qword when using MASM.
                  $asm.puts &quot;movd #{operands[1].x86Operand(:quad)}, #{operands[0].x86Operand(:double)}&quot;
              end
<span class="udiff-line-added">+         when &quot;fi2f&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;movd #{x86Operands(:int, :float)}&quot;</span>
<span class="udiff-line-added">+         when &quot;ff2i&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;movd #{x86Operands(:float, :int)}&quot;</span>
          when &quot;bo&quot;
              $asm.puts &quot;jo #{operands[0].asmLabel}&quot;
          when &quot;bs&quot;
              $asm.puts &quot;js #{operands[0].asmLabel}&quot;
          when &quot;bz&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1391,10 +1782,50 @@</span>
              if isIntelSyntax
                  $asm.puts &quot;mfence&quot;
              else
                  $asm.puts &quot;lock; orl $0, (#{sp.x86Operand(:ptr)})&quot;
              end
<span class="udiff-line-added">+         when &quot;absf&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;movl #{orderOperands(&quot;$0x80000000&quot;, X64_SCRATCH_REGISTER.x86Operand(:int))}&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;movd #{orderOperands(X64_SCRATCH_REGISTER.x86Operand(:int), operands[1].x86Operand(:float))}&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;andnps #{orderOperands(operands[0].x86Operand(:float), operands[1].x86Operand(:float))}&quot;</span>
<span class="udiff-line-added">+         when &quot;absd&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;movq #{orderOperands(&quot;$0x8000000000000000&quot;, X64_SCRATCH_REGISTER.x86Operand(:quad))}&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;movd #{orderOperands(X64_SCRATCH_REGISTER.x86Operand(:quad), operands[1].x86Operand(:double))}&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;andnps #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;</span>
<span class="udiff-line-added">+         when &quot;negf&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;movl #{orderOperands(&quot;$0x80000000&quot;, X64_SCRATCH_REGISTER.x86Operand(:int))}&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;movd #{orderOperands(X64_SCRATCH_REGISTER.x86Operand(:int), operands[1].x86Operand(:float))}&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;xorps #{orderOperands(operands[0].x86Operand(:float), operands[1].x86Operand(:float))}&quot;</span>
<span class="udiff-line-added">+         when &quot;negd&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;movq #{orderOperands(&quot;$0x8000000000000000&quot;, X64_SCRATCH_REGISTER.x86Operand(:quad))}&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;movd #{orderOperands(X64_SCRATCH_REGISTER.x86Operand(:quad), operands[1].x86Operand(:double))}&quot;</span>
<span class="udiff-line-added">+             $asm.puts &quot;xorpd #{orderOperands(operands[0].x86Operand(:double), operands[1].x86Operand(:double))}&quot;</span>
<span class="udiff-line-added">+         when &quot;tls_loadp&quot;</span>
<span class="udiff-line-added">+             raise &quot;tls_loadp is only supported on x64&quot; unless isX64</span>
<span class="udiff-line-added">+             if operands[0].immediate?</span>
<span class="udiff-line-added">+                 mem = &quot;%gs:#{operands[0].value * 8}&quot;</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 mem = BaseIndex.new(codeOrigin, nil, operands[0], 8, &quot;%gs:&quot;).x86AddressOperand(:quad)</span>
<span class="udiff-line-added">+             end</span>
<span class="udiff-line-added">+             $asm.puts &quot;movq #{orderOperands(mem, operands[1].x86Operand(:quad))}&quot;</span>
<span class="udiff-line-added">+         when &quot;tls_loadp&quot;</span>
<span class="udiff-line-added">+             raise &quot;tls_loadp is only supported on x64&quot; unless isX64</span>
<span class="udiff-line-added">+             if operands[0].immediate?</span>
<span class="udiff-line-added">+                 mem = &quot;%gs:#{operands[0].value * x86Bytes(:ptr)}&quot;</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 mem = BaseIndex.new(codeOrigin, nil, operands[0], x86Bytes(:ptr), &quot;%gs:&quot;).x86AddressOperand(:quad)</span>
<span class="udiff-line-added">+             end</span>
<span class="udiff-line-added">+             $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(mem, operands[1].x86Operand(:quad))}&quot;</span>
<span class="udiff-line-added">+         when &quot;tls_storep&quot;</span>
<span class="udiff-line-added">+             raise &quot;tls_loadp is only supported on x64&quot; unless isX64</span>
<span class="udiff-line-added">+             if operands[1].immediate?</span>
<span class="udiff-line-added">+                 mem = &quot;%gs:#{operands[1].value * x86Bytes(:ptr)}&quot;</span>
<span class="udiff-line-added">+             else</span>
<span class="udiff-line-added">+                 mem = BaseIndex.new(codeOrigin, nil, operands[1], x86Bytes(:ptr), &quot;%gs:&quot;).x86AddressOperand(:ptr)</span>
<span class="udiff-line-added">+             end</span>
<span class="udiff-line-added">+             $asm.puts &quot;mov#{x86Suffix(:ptr)} #{orderOperands(operands[0].x86Operand(:ptr), mem)}&quot;</span>
          else
              lowerDefault
          end
      end
  end
</pre>
<center><a href="transform.rb.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="../parser/ASTBuilder.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
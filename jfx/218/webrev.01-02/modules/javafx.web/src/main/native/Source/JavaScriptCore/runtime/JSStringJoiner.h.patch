diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSStringJoiner.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSStringJoiner.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSStringJoiner.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSStringJoiner.h
@@ -25,58 +25,59 @@
 
 #pragma once
 
 #include "ExceptionHelpers.h"
 #include "JSCJSValue.h"
+#include "JSGlobalObject.h"
 
 namespace JSC {
 
 class JSStringJoiner {
 public:
-    JSStringJoiner(ExecState&, LChar separator, unsigned stringCount);
-    JSStringJoiner(ExecState&, StringView separator, unsigned stringCount);
+    JSStringJoiner(JSGlobalObject*, LChar separator, unsigned stringCount);
+    JSStringJoiner(JSGlobalObject*, StringView separator, unsigned stringCount);
     ~JSStringJoiner();
 
-    void append(ExecState&, JSValue);
+    void append(JSGlobalObject*, JSValue);
     void appendNumber(VM&, int32_t);
     void appendNumber(VM&, double);
-    bool appendWithoutSideEffects(ExecState&, JSValue);
+    bool appendWithoutSideEffects(JSGlobalObject*, JSValue);
     void appendEmptyString();
 
-    JSValue join(ExecState&);
+    JSValue join(JSGlobalObject*);
 
 private:
     void append(StringViewWithUnderlyingString&&);
     void append8Bit(const String&);
     void appendLiteral(const Identifier&);
-    unsigned joinedLength(ExecState&) const;
+    unsigned joinedLength(JSGlobalObject*) const;
 
     LChar m_singleCharacterSeparator;
     StringView m_separator;
     Vector<StringViewWithUnderlyingString> m_strings;
     Checked<unsigned, RecordOverflow> m_accumulatedStringsLength;
     bool m_isAll8Bit { true };
 };
 
-inline JSStringJoiner::JSStringJoiner(ExecState& state, StringView separator, unsigned stringCount)
+inline JSStringJoiner::JSStringJoiner(JSGlobalObject* globalObject, StringView separator, unsigned stringCount)
     : m_separator(separator)
     , m_isAll8Bit(m_separator.is8Bit())
 {
-    VM& vm = state.vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     if (UNLIKELY(!m_strings.tryReserveCapacity(stringCount)))
-        throwOutOfMemoryError(&state, scope);
+        throwOutOfMemoryError(globalObject, scope);
 }
 
-inline JSStringJoiner::JSStringJoiner(ExecState& state, LChar separator, unsigned stringCount)
+inline JSStringJoiner::JSStringJoiner(JSGlobalObject* globalObject, LChar separator, unsigned stringCount)
     : m_singleCharacterSeparator(separator)
     , m_separator { &m_singleCharacterSeparator, 1 }
 {
-    VM& vm = state.vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     if (UNLIKELY(!m_strings.tryReserveCapacity(stringCount)))
-        throwOutOfMemoryError(&state, scope);
+        throwOutOfMemoryError(globalObject, scope);
 }
 
 ALWAYS_INLINE void JSStringJoiner::append(StringViewWithUnderlyingString&& string)
 {
     m_accumulatedStringsLength += string.view.length();
@@ -101,11 +102,11 @@
 ALWAYS_INLINE void JSStringJoiner::appendEmptyString()
 {
     m_strings.uncheckedAppend({ { }, { } });
 }
 
-ALWAYS_INLINE bool JSStringJoiner::appendWithoutSideEffects(ExecState& state, JSValue value)
+ALWAYS_INLINE bool JSStringJoiner::appendWithoutSideEffects(JSGlobalObject* globalObject, JSValue value)
 {
     // The following code differs from using the result of JSValue::toString in the following ways:
     // 1) It's inlined more than JSValue::toString is.
     // 2) It includes conversion to WTF::String in a way that avoids allocating copies of substrings.
     // 3) It doesn't create a JSString for numbers, true, or false.
@@ -116,40 +117,40 @@
     if (value.isCell()) {
         JSString* jsString;
         if (!value.asCell()->isString())
             return false;
         jsString = asString(value);
-        append(jsString->viewWithUnderlyingString(&state));
+        append(jsString->viewWithUnderlyingString(globalObject));
         return true;
     }
 
     if (value.isInt32()) {
-        appendNumber(state.vm(), value.asInt32());
+        appendNumber(globalObject->vm(), value.asInt32());
         return true;
     }
     if (value.isDouble()) {
-        appendNumber(state.vm(), value.asDouble());
+        appendNumber(globalObject->vm(), value.asDouble());
         return true;
     }
     if (value.isTrue()) {
-        append8Bit(state.vm().propertyNames->trueKeyword.string());
+        append8Bit(globalObject->vm().propertyNames->trueKeyword.string());
         return true;
     }
     if (value.isFalse()) {
-        append8Bit(state.vm().propertyNames->falseKeyword.string());
+        append8Bit(globalObject->vm().propertyNames->falseKeyword.string());
         return true;
     }
     ASSERT(value.isUndefinedOrNull());
     appendEmptyString();
     return true;
 }
 
-ALWAYS_INLINE void JSStringJoiner::append(ExecState& state, JSValue value)
+ALWAYS_INLINE void JSStringJoiner::append(JSGlobalObject* globalObject, JSValue value)
 {
-    if (!appendWithoutSideEffects(state, value)) {
-        JSString* jsString = value.toString(&state);
-        append(jsString->viewWithUnderlyingString(&state));
+    if (!appendWithoutSideEffects(globalObject, value)) {
+        JSString* jsString = value.toString(globalObject);
+        append(jsString->viewWithUnderlyingString(globalObject));
     }
 }
 
 ALWAYS_INLINE void JSStringJoiner::appendNumber(VM& vm, int32_t value)
 {

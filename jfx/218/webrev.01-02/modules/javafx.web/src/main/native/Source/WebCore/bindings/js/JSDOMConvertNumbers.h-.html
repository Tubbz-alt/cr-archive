<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMConvertNumbers.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;IDLTypes.h&quot;
 29 #include &quot;JSDOMConvertBase.h&quot;
 30 #include &quot;JSDOMExceptionHandling.h&quot;
 31 #include &lt;JavaScriptCore/JSCJSValueInlines.h&gt;
 32 #include &lt;JavaScriptCore/PureNaN.h&gt;
 33 
 34 namespace WebCore {
 35 
 36 // The following functions convert values to integers as per the WebIDL specification.
 37 // The conversion fails if the value cannot be converted to a number or, if EnforceRange is specified,
 38 // the value is outside the range of the destination integer type.
 39 
 40 template&lt;typename T&gt; T convertToInteger(JSC::ExecState&amp;, JSC::JSValue);
 41 template&lt;&gt; WEBCORE_EXPORT int8_t convertToInteger&lt;int8_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 42 template&lt;&gt; WEBCORE_EXPORT uint8_t convertToInteger&lt;uint8_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 43 template&lt;&gt; WEBCORE_EXPORT int16_t convertToInteger&lt;int16_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 44 template&lt;&gt; WEBCORE_EXPORT uint16_t convertToInteger&lt;uint16_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 45 template&lt;&gt; WEBCORE_EXPORT int32_t convertToInteger&lt;int32_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 46 template&lt;&gt; WEBCORE_EXPORT uint32_t convertToInteger&lt;uint32_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 47 template&lt;&gt; WEBCORE_EXPORT int64_t convertToInteger&lt;int64_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 48 template&lt;&gt; WEBCORE_EXPORT uint64_t convertToInteger&lt;uint64_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 49 
 50 template&lt;typename T&gt; T convertToIntegerEnforceRange(JSC::ExecState&amp;, JSC::JSValue);
 51 template&lt;&gt; WEBCORE_EXPORT int8_t convertToIntegerEnforceRange&lt;int8_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 52 template&lt;&gt; WEBCORE_EXPORT uint8_t convertToIntegerEnforceRange&lt;uint8_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 53 template&lt;&gt; WEBCORE_EXPORT int16_t convertToIntegerEnforceRange&lt;int16_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 54 template&lt;&gt; WEBCORE_EXPORT uint16_t convertToIntegerEnforceRange&lt;uint16_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 55 template&lt;&gt; WEBCORE_EXPORT int32_t convertToIntegerEnforceRange&lt;int32_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 56 template&lt;&gt; WEBCORE_EXPORT uint32_t convertToIntegerEnforceRange&lt;uint32_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 57 template&lt;&gt; WEBCORE_EXPORT int64_t convertToIntegerEnforceRange&lt;int64_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 58 template&lt;&gt; WEBCORE_EXPORT uint64_t convertToIntegerEnforceRange&lt;uint64_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 59 
 60 template&lt;typename T&gt; T convertToIntegerClamp(JSC::ExecState&amp;, JSC::JSValue);
 61 template&lt;&gt; WEBCORE_EXPORT int8_t convertToIntegerClamp&lt;int8_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 62 template&lt;&gt; WEBCORE_EXPORT uint8_t convertToIntegerClamp&lt;uint8_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 63 template&lt;&gt; WEBCORE_EXPORT int16_t convertToIntegerClamp&lt;int16_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 64 template&lt;&gt; WEBCORE_EXPORT uint16_t convertToIntegerClamp&lt;uint16_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 65 template&lt;&gt; WEBCORE_EXPORT int32_t convertToIntegerClamp&lt;int32_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 66 template&lt;&gt; WEBCORE_EXPORT uint32_t convertToIntegerClamp&lt;uint32_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 67 template&lt;&gt; WEBCORE_EXPORT int64_t convertToIntegerClamp&lt;int64_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 68 template&lt;&gt; WEBCORE_EXPORT uint64_t convertToIntegerClamp&lt;uint64_t&gt;(JSC::ExecState&amp;, JSC::JSValue);
 69 
 70 // MARK: -
 71 // MARK: Integer types
 72 
 73 template&lt;&gt; struct Converter&lt;IDLByte&gt; : DefaultConverter&lt;IDLByte&gt; {
 74     static int8_t convert(JSC::ExecState&amp; state, JSC::JSValue value)
 75     {
 76         return convertToInteger&lt;int8_t&gt;(state, value);
 77     }
 78 };
 79 
 80 template&lt;&gt; struct JSConverter&lt;IDLByte&gt; {
 81     using Type = typename IDLByte::ImplementationType;
 82 
 83     static constexpr bool needsState = false;
 84     static constexpr bool needsGlobalObject = false;
 85 
 86     static JSC::JSValue convert(Type value)
 87     {
 88         return JSC::jsNumber(value);
 89     }
 90 };
 91 
 92 template&lt;&gt; struct Converter&lt;IDLOctet&gt; : DefaultConverter&lt;IDLOctet&gt; {
 93     static uint8_t convert(JSC::ExecState&amp; state, JSC::JSValue value)
 94     {
 95         return convertToInteger&lt;uint8_t&gt;(state, value);
 96     }
 97 };
 98 
 99 template&lt;&gt; struct JSConverter&lt;IDLOctet&gt; {
100     using Type = typename IDLOctet::ImplementationType;
101 
102     static constexpr bool needsState = false;
103     static constexpr bool needsGlobalObject = false;
104 
105     static JSC::JSValue convert(Type value)
106     {
107         return JSC::jsNumber(value);
108     }
109 };
110 
111 template&lt;&gt; struct Converter&lt;IDLShort&gt; : DefaultConverter&lt;IDLShort&gt; {
112     static int16_t convert(JSC::ExecState&amp; state, JSC::JSValue value)
113     {
114         return convertToInteger&lt;int16_t&gt;(state, value);
115     }
116 };
117 
118 template&lt;&gt; struct JSConverter&lt;IDLShort&gt; {
119     using Type = typename IDLShort::ImplementationType;
120 
121     static constexpr bool needsState = false;
122     static constexpr bool needsGlobalObject = false;
123 
124     static JSC::JSValue convert(Type value)
125     {
126         return JSC::jsNumber(value);
127     }
128 };
129 
130 template&lt;&gt; struct Converter&lt;IDLUnsignedShort&gt; : DefaultConverter&lt;IDLUnsignedShort&gt; {
131     static uint16_t convert(JSC::ExecState&amp; state, JSC::JSValue value)
132     {
133         return convertToInteger&lt;uint16_t&gt;(state, value);
134     }
135 };
136 
137 template&lt;&gt; struct JSConverter&lt;IDLUnsignedShort&gt; {
138     using Type = typename IDLUnsignedShort::ImplementationType;
139 
140     static constexpr bool needsState = false;
141     static constexpr bool needsGlobalObject = false;
142 
143     static JSC::JSValue convert(Type value)
144     {
145         return JSC::jsNumber(value);
146     }
147 };
148 
149 template&lt;&gt; struct Converter&lt;IDLLong&gt; : DefaultConverter&lt;IDLLong&gt; {
150     static inline int32_t convert(JSC::ExecState&amp;, JSC::ThrowScope&amp;, double number)
151     {
152         return JSC::toInt32(number);
153     }
154 
155     static int32_t convert(JSC::ExecState&amp; state, JSC::JSValue value)
156     {
157         return convertToInteger&lt;int32_t&gt;(state, value);
158     }
159 };
160 
161 template&lt;&gt; struct JSConverter&lt;IDLLong&gt; {
162     using Type = typename IDLLong::ImplementationType;
163 
164     static constexpr bool needsState = false;
165     static constexpr bool needsGlobalObject = false;
166 
167     static JSC::JSValue convert(Type value)
168     {
169         return JSC::jsNumber(value);
170     }
171 };
172 
173 template&lt;&gt; struct Converter&lt;IDLUnsignedLong&gt; : DefaultConverter&lt;IDLUnsignedLong&gt; {
174     static uint32_t convert(JSC::ExecState&amp; state, JSC::JSValue value)
175     {
176         return convertToInteger&lt;uint32_t&gt;(state, value);
177     }
178 };
179 
180 template&lt;&gt; struct JSConverter&lt;IDLUnsignedLong&gt; {
181     using Type = typename IDLUnsignedLong::ImplementationType;
182 
183     static constexpr bool needsState = false;
184     static constexpr bool needsGlobalObject = false;
185 
186     static JSC::JSValue convert(Type value)
187     {
188         return JSC::jsNumber(value);
189     }
190 };
191 
192 template&lt;&gt; struct Converter&lt;IDLLongLong&gt; : DefaultConverter&lt;IDLLongLong&gt; {
193     static int64_t convert(JSC::ExecState&amp; state, JSC::JSValue value)
194     {
195         return convertToInteger&lt;int64_t&gt;(state, value);
196     }
197 };
198 
199 template&lt;&gt; struct JSConverter&lt;IDLLongLong&gt; {
200     using Type = typename IDLLongLong::ImplementationType;
201 
202     static constexpr bool needsState = false;
203     static constexpr bool needsGlobalObject = false;
204 
205     static JSC::JSValue convert(Type value)
206     {
207         return JSC::jsNumber(value);
208     }
209 };
210 
211 template&lt;&gt; struct Converter&lt;IDLUnsignedLongLong&gt; : DefaultConverter&lt;IDLUnsignedLongLong&gt; {
212     static uint64_t convert(JSC::ExecState&amp; state, JSC::JSValue value)
213     {
214         return convertToInteger&lt;uint64_t&gt;(state, value);
215     }
216 };
217 
218 template&lt;&gt; struct JSConverter&lt;IDLUnsignedLongLong&gt; {
219     using Type = typename IDLUnsignedLongLong::ImplementationType;
220 
221     static constexpr bool needsState = false;
222     static constexpr bool needsGlobalObject = false;
223 
224     static JSC::JSValue convert(Type value)
225     {
226         return JSC::jsNumber(value);
227     }
228 };
229 
230 // MARK: -
231 // MARK: Annotated Integer types
232 
233 template&lt;typename T&gt; struct Converter&lt;IDLClampAdaptor&lt;T&gt;&gt; : DefaultConverter&lt;IDLClampAdaptor&lt;T&gt;&gt; {
234     using ReturnType = typename IDLClampAdaptor&lt;T&gt;::ImplementationType;
235 
236     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)
237     {
238         return convertToIntegerClamp&lt;ReturnType&gt;(state, value);
239     }
240 };
241 
242 template&lt;typename T&gt; struct JSConverter&lt;IDLClampAdaptor&lt;T&gt;&gt; {
243     using Type = typename IDLClampAdaptor&lt;T&gt;::ImplementationType;
244 
245     static constexpr bool needsState = false;
246     static constexpr bool needsGlobalObject = false;
247 
248     static JSC::JSValue convert(Type value)
249     {
250         return JSConverter&lt;T&gt;::convert(value);
251     }
252 };
253 
254 
255 template&lt;typename T&gt; struct Converter&lt;IDLEnforceRangeAdaptor&lt;T&gt;&gt; : DefaultConverter&lt;IDLEnforceRangeAdaptor&lt;T&gt;&gt; {
256     using ReturnType = typename IDLEnforceRangeAdaptor&lt;T&gt;::ImplementationType;
257 
258     static ReturnType convert(JSC::ExecState&amp; state, JSC::JSValue value)
259     {
260         return convertToIntegerEnforceRange&lt;ReturnType&gt;(state, value);
261     }
262 };
263 
264 template&lt;typename T&gt; struct JSConverter&lt;IDLEnforceRangeAdaptor&lt;T&gt;&gt; {
265     using Type = typename IDLEnforceRangeAdaptor&lt;T&gt;::ImplementationType;
266 
267     static constexpr bool needsState = false;
268     static constexpr bool needsGlobalObject = false;
269 
270     static JSC::JSValue convert(Type value)
271     {
272         return JSConverter&lt;T&gt;::convert(value);
273     }
274 };
275 
276 
277 // MARK: -
278 // MARK: Floating point types
279 
280 template&lt;&gt; struct Converter&lt;IDLFloat&gt; : DefaultConverter&lt;IDLFloat&gt; {
281 
282     static inline float convert(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, double number)
283     {
284         if (UNLIKELY(!std::isfinite(number)))
285             throwNonFiniteTypeError(state, scope);
286         return static_cast&lt;float&gt;(number);
287     }
288 
289     static float convert(JSC::ExecState&amp; state, JSC::JSValue value)
290     {
291         JSC::VM&amp; vm = state.vm();
292         auto scope = DECLARE_THROW_SCOPE(vm);
293         double number = value.toNumber(&amp;state);
294         if (UNLIKELY(!std::isfinite(number)))
295             throwNonFiniteTypeError(state, scope);
296         return static_cast&lt;float&gt;(number);
297     }
298 };
299 
300 template&lt;&gt; struct JSConverter&lt;IDLFloat&gt; {
301     using Type = typename IDLFloat::ImplementationType;
302 
303     static constexpr bool needsState = false;
304     static constexpr bool needsGlobalObject = false;
305 
306     static JSC::JSValue convert(Type value)
307     {
308         return JSC::jsNumber(value);
309     }
310 };
311 
312 template&lt;&gt; struct Converter&lt;IDLUnrestrictedFloat&gt; : DefaultConverter&lt;IDLUnrestrictedFloat&gt; {
313     static inline float convert(JSC::ExecState&amp;, JSC::ThrowScope&amp;, double number)
314     {
315         return static_cast&lt;float&gt;(number);
316     }
317 
318     static float convert(JSC::ExecState&amp; state, JSC::JSValue value)
319     {
320         return static_cast&lt;float&gt;(value.toNumber(&amp;state));
321     }
322 };
323 
324 template&lt;&gt; struct JSConverter&lt;IDLUnrestrictedFloat&gt; {
325     using Type = typename IDLUnrestrictedFloat::ImplementationType;
326 
327     static constexpr bool needsState = false;
328     static constexpr bool needsGlobalObject = false;
329 
330     static JSC::JSValue convert(Type value)
331     {
332         return JSC::jsNumber(value);
333     }
334 };
335 
336 template&lt;&gt; struct Converter&lt;IDLDouble&gt; : DefaultConverter&lt;IDLDouble&gt; {
337     static inline double convert(JSC::ExecState&amp; state, JSC::ThrowScope&amp; scope, double number)
338     {
339         if (UNLIKELY(!std::isfinite(number)))
340             throwNonFiniteTypeError(state, scope);
341         return number;
342     }
343 
344     static double convert(JSC::ExecState&amp; state, JSC::JSValue value)
345     {
346         JSC::VM&amp; vm = state.vm();
347         auto scope = DECLARE_THROW_SCOPE(vm);
348         double number = value.toNumber(&amp;state);
349         if (UNLIKELY(!std::isfinite(number)))
350             throwNonFiniteTypeError(state, scope);
351         return number;
352     }
353 };
354 
355 template&lt;&gt; struct JSConverter&lt;IDLDouble&gt; {
356     using Type = typename IDLDouble::ImplementationType;
357 
358     static constexpr bool needsState = false;
359     static constexpr bool needsGlobalObject = false;
360 
361     static JSC::JSValue convert(Type value)
362     {
363         ASSERT(!std::isnan(value));
364         return JSC::jsNumber(value);
365     }
366 };
367 
368 template&lt;&gt; struct Converter&lt;IDLUnrestrictedDouble&gt; : DefaultConverter&lt;IDLUnrestrictedDouble&gt; {
369     static inline double convert(JSC::ExecState&amp;, JSC::ThrowScope&amp;, double number)
370     {
371         return number;
372     }
373 
374     static double convert(JSC::ExecState&amp; state, JSC::JSValue value)
375     {
376         return value.toNumber(&amp;state);
377     }
378 };
379 
380 template&lt;&gt; struct JSConverter&lt;IDLUnrestrictedDouble&gt; {
381     using Type = typename IDLUnrestrictedDouble::ImplementationType;
382 
383     static constexpr bool needsState = false;
384     static constexpr bool needsGlobalObject = false;
385 
386     static JSC::JSValue convert(Type value)
387     {
388         return JSC::jsNumber(JSC::purifyNaN(value));
389     }
390 
391     // Add overload for MediaTime.
392     static JSC::JSValue convert(const MediaTime&amp; value)
393     {
394         return JSC::jsNumber(JSC::purifyNaN(value.toDouble()));
395     }
396 };
397 
398 } // namespace WebCore
    </pre>
  </body>
</html>
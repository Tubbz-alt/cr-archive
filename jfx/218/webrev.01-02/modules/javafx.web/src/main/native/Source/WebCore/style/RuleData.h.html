<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/style/RuleData.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  * Copyright (C) 2003-2019 Apple Inc. All rights reserved.
  4  *
  5  * This library is free software; you can redistribute it and/or
  6  * modify it under the terms of the GNU Library General Public
  7  * License as published by the Free Software Foundation; either
  8  * version 2 of the License, or (at your option) any later version.
  9  *
 10  * This library is distributed in the hope that it will be useful,
 11  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  * Library General Public License for more details.
 14  *
 15  * You should have received a copy of the GNU Library General Public License
 16  * along with this library; see the file COPYING.LIB.  If not, write to
 17  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 18  * Boston, MA 02110-1301, USA.
 19  *
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;SelectorFilter.h&quot;
 25 #include &quot;StyleRule.h&quot;
 26 
 27 namespace WebCore {
 28 namespace Style {
 29 
 30 enum PropertyWhitelistType {
 31     PropertyWhitelistNone   = 0,
 32     PropertyWhitelistMarker,
 33 #if ENABLE(VIDEO_TRACK)
 34     PropertyWhitelistCue
 35 #endif
 36 };
 37 
 38 enum class MatchBasedOnRuleHash : unsigned {
 39     None,
 40     Universal,
 41     ClassA,
 42     ClassB,
 43     ClassC
 44 };
 45 
 46 class RuleData {
 47 public:
 48     static const unsigned maximumSelectorComponentCount = 8192;
 49 
 50     RuleData(const StyleRule&amp;, unsigned selectorIndex, unsigned selectorListIndex, unsigned position);
 51 
 52     unsigned position() const { return m_position; }
 53 
 54     const StyleRule&amp; styleRule() const { return *m_styleRule; }
 55 
 56     const CSSSelector* selector() const { return m_styleRule-&gt;selectorList().selectorAt(m_selectorIndex); }
 57 #if ENABLE(CSS_SELECTOR_JIT)
 58     CompiledSelector&amp; compiledSelector() const { return m_styleRule-&gt;compiledSelectorForListIndex(m_selectorListIndex); }
 59 #endif
 60 
 61     unsigned selectorIndex() const { return m_selectorIndex; }
 62     unsigned selectorListIndex() const { return m_selectorListIndex; }
 63 
 64     bool canMatchPseudoElement() const { return m_canMatchPseudoElement; }
 65     MatchBasedOnRuleHash matchBasedOnRuleHash() const { return static_cast&lt;MatchBasedOnRuleHash&gt;(m_matchBasedOnRuleHash); }
 66     bool containsUncommonAttributeSelector() const { return m_containsUncommonAttributeSelector; }
 67     unsigned linkMatchType() const { return m_linkMatchType; }
 68     PropertyWhitelistType propertyWhitelistType() const { return static_cast&lt;PropertyWhitelistType&gt;(m_propertyWhitelistType); }
 69     bool isEnabled() const { return m_isEnabled; }
 70     void setEnabled(bool value) { m_isEnabled = value; }
 71 
 72     const SelectorFilter::Hashes&amp; descendantSelectorIdentifierHashes() const { return m_descendantSelectorIdentifierHashes; }
 73 
 74     void disableSelectorFiltering() { m_descendantSelectorIdentifierHashes[0] = 0; }
 75 
 76 private:
 77     RefPtr&lt;const StyleRule&gt; m_styleRule;
 78     // Keep in sync with RuleFeature&#39;s selectorIndex and selectorListIndex size.
 79     unsigned m_selectorIndex : 16;
 80     unsigned m_selectorListIndex : 16;
 81     // If we have more rules than 2^bitcount here we&#39;ll get confused about rule order.
 82     unsigned m_position : 22;
 83     unsigned m_matchBasedOnRuleHash : 3;
 84     unsigned m_canMatchPseudoElement : 1;
 85     unsigned m_containsUncommonAttributeSelector : 1;
 86     unsigned m_linkMatchType : 2; //  SelectorChecker::LinkMatchMask
 87     unsigned m_propertyWhitelistType : 2;
 88     unsigned m_isEnabled : 1;
 89     SelectorFilter::Hashes m_descendantSelectorIdentifierHashes;
 90 };
 91 
 92 } // namespace Style
 93 } // namespace WebCore
 94 
 95 namespace WTF {
 96 
 97 // RuleData is simple enough that initializing to 0 and moving with memcpy will totally work.
 98 template&lt;&gt; struct VectorTraits&lt;WebCore::Style::RuleData&gt; : SimpleClassVectorTraits { };
 99 
100 } // namespace WTF
    </pre>
  </body>
</html>
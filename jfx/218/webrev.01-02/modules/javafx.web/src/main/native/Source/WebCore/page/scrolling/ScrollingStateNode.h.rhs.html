<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/scrolling/ScrollingStateNode.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2012 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(ASYNC_SCROLLING)
 29 
 30 #include &quot;GraphicsLayer.h&quot;
 31 #include &quot;ScrollingCoordinator.h&quot;
 32 #include &lt;stdint.h&gt;
 33 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 34 #include &lt;wtf/TypeCasts.h&gt;
 35 #include &lt;wtf/Vector.h&gt;
 36 
 37 namespace WTF {
 38 class TextStream;
 39 }
 40 
 41 namespace WebCore {
 42 
 43 class GraphicsLayer;
 44 class ScrollingStateTree;
 45 
 46 // Used to allow ScrollingStateNodes to refer to layers in various contexts:
 47 // a) Async scrolling, main thread: ScrollingStateNode holds onto a GraphicsLayer, and uses m_layerID
 48 //    to detect whether that GraphicsLayer&#39;s underlying PlatformLayer changed.
 49 // b) Threaded scrolling, commit to scrolling thread: ScrollingStateNode wraps a PlatformLayer, which
 50 //    can be passed to the Scrolling Thread
 51 // c) Remote scrolling UI process, where LayerRepresentation wraps just a PlatformLayerID.
 52 class LayerRepresentation {
 53 public:
 54     enum Type {
 55         EmptyRepresentation,
 56         GraphicsLayerRepresentation,
 57         PlatformLayerRepresentation,
 58         PlatformLayerIDRepresentation
 59     };
 60 
 61     LayerRepresentation() = default;
 62 
 63     LayerRepresentation(GraphicsLayer* graphicsLayer)
 64         : m_graphicsLayer(graphicsLayer)
 65         , m_layerID(graphicsLayer ? graphicsLayer-&gt;primaryLayerID() : 0)
 66         , m_representation(GraphicsLayerRepresentation)
 67     { }
 68 
 69     LayerRepresentation(PlatformLayer* platformLayer)
 70         : m_typelessPlatformLayer(makePlatformLayerTypeless(platformLayer))
 71         , m_representation(PlatformLayerRepresentation)
 72     {
 73         retainPlatformLayer(m_typelessPlatformLayer);
 74     }
 75 
 76     LayerRepresentation(GraphicsLayer::PlatformLayerID layerID)
 77         : m_layerID(layerID)
 78         , m_representation(PlatformLayerIDRepresentation)
 79     {
 80     }
 81 
 82     LayerRepresentation(const LayerRepresentation&amp; other)
 83         : m_typelessPlatformLayer(other.m_typelessPlatformLayer)
 84         , m_layerID(other.m_layerID)
 85         , m_representation(other.m_representation)
 86     {
 87         if (m_representation == PlatformLayerRepresentation)
 88             retainPlatformLayer(m_typelessPlatformLayer);
 89     }
 90 
 91     ~LayerRepresentation()
 92     {
 93         if (m_representation == PlatformLayerRepresentation)
 94             releasePlatformLayer(m_typelessPlatformLayer);
 95     }
 96 
<a name="1" id="anc1"></a><span class="line-modified"> 97     explicit operator GraphicsLayer*() const</span>
 98     {
 99         ASSERT(m_representation == GraphicsLayerRepresentation);
100         return m_graphicsLayer.get();
101     }
102 
<a name="2" id="anc2"></a><span class="line-modified">103     explicit operator PlatformLayer*() const</span>
104     {
105         ASSERT(m_representation == PlatformLayerRepresentation);
106         return makePlatformLayerTyped(m_typelessPlatformLayer);
107     }
108 
109     GraphicsLayer::PlatformLayerID layerID() const
110     {
111         return m_layerID;
112     }
113 
<a name="3" id="anc3"></a><span class="line-modified">114     explicit operator GraphicsLayer::PlatformLayerID() const</span>
115     {
116         ASSERT(m_representation != PlatformLayerRepresentation);
117         return m_layerID;
118     }
119 
120     LayerRepresentation&amp; operator=(const LayerRepresentation&amp; other)
121     {
122         m_graphicsLayer = other.m_graphicsLayer;
123         m_typelessPlatformLayer = other.m_typelessPlatformLayer;
124         m_layerID = other.m_layerID;
125         m_representation = other.m_representation;
126 
127         if (m_representation == PlatformLayerRepresentation)
128             retainPlatformLayer(m_typelessPlatformLayer);
129 
130         return *this;
131     }
132 
<a name="4" id="anc4"></a><span class="line-added">133     explicit operator bool() const</span>
<span class="line-added">134     {</span>
<span class="line-added">135         switch (m_representation) {</span>
<span class="line-added">136         case EmptyRepresentation:</span>
<span class="line-added">137             return false;</span>
<span class="line-added">138         case GraphicsLayerRepresentation:</span>
<span class="line-added">139             return !!m_graphicsLayer;</span>
<span class="line-added">140         case PlatformLayerRepresentation:</span>
<span class="line-added">141             return !!m_typelessPlatformLayer;</span>
<span class="line-added">142         case PlatformLayerIDRepresentation:</span>
<span class="line-added">143             return !!m_layerID;</span>
<span class="line-added">144         }</span>
<span class="line-added">145         ASSERT_NOT_REACHED();</span>
<span class="line-added">146         return false;</span>
<span class="line-added">147     }</span>
<span class="line-added">148 </span>
149     bool operator==(const LayerRepresentation&amp; other) const
150     {
151         if (m_representation != other.m_representation)
152             return false;
153         switch (m_representation) {
154         case EmptyRepresentation:
155             return true;
156         case GraphicsLayerRepresentation:
157             return m_graphicsLayer == other.m_graphicsLayer
158                 &amp;&amp; m_layerID == other.m_layerID;
159         case PlatformLayerRepresentation:
160             return m_typelessPlatformLayer == other.m_typelessPlatformLayer;
161         case PlatformLayerIDRepresentation:
162             return m_layerID == other.m_layerID;
163         }
164         ASSERT_NOT_REACHED();
165         return true;
166     }
167 
168     LayerRepresentation toRepresentation(Type representation) const
169     {
170         switch (representation) {
171         case EmptyRepresentation:
172             return LayerRepresentation();
173         case GraphicsLayerRepresentation:
174             ASSERT(m_representation == GraphicsLayerRepresentation);
175             return LayerRepresentation(m_graphicsLayer.get());
176         case PlatformLayerRepresentation:
177             return m_graphicsLayer ? m_graphicsLayer-&gt;platformLayer() : nullptr;
178         case PlatformLayerIDRepresentation:
179             return LayerRepresentation(m_layerID);
180         }
<a name="5" id="anc5"></a><span class="line-added">181         ASSERT_NOT_REACHED();</span>
182         return LayerRepresentation();
183     }
184 
185     bool representsGraphicsLayer() const { return m_representation == GraphicsLayerRepresentation; }
186     bool representsPlatformLayerID() const { return m_representation == PlatformLayerIDRepresentation; }
187 
188 private:
189     WEBCORE_EXPORT static void retainPlatformLayer(void* typelessPlatformLayer);
190     WEBCORE_EXPORT static void releasePlatformLayer(void* typelessPlatformLayer);
191     WEBCORE_EXPORT static PlatformLayer* makePlatformLayerTyped(void* typelessPlatformLayer);
192     WEBCORE_EXPORT static void* makePlatformLayerTypeless(PlatformLayer*);
193 
194     RefPtr&lt;GraphicsLayer&gt; m_graphicsLayer;
195     void* m_typelessPlatformLayer { nullptr };
196     GraphicsLayer::PlatformLayerID m_layerID { 0 };
197     Type m_representation { EmptyRepresentation };
198 };
199 
200 class ScrollingStateNode : public ThreadSafeRefCounted&lt;ScrollingStateNode&gt; {
201     WTF_MAKE_FAST_ALLOCATED;
202 public:
203     virtual ~ScrollingStateNode();
204 
205     ScrollingNodeType nodeType() const { return m_nodeType; }
206 
207     bool isFixedNode() const { return m_nodeType == ScrollingNodeType::Fixed; }
208     bool isStickyNode() const { return m_nodeType == ScrollingNodeType::Sticky; }
209     bool isPositionedNode() const { return m_nodeType == ScrollingNodeType::Positioned; }
210     bool isScrollingNode() const { return isFrameScrollingNode() || isOverflowScrollingNode(); }
211     bool isFrameScrollingNode() const { return m_nodeType == ScrollingNodeType::MainFrame || m_nodeType == ScrollingNodeType::Subframe; }
212     bool isFrameHostingNode() const { return m_nodeType == ScrollingNodeType::FrameHosting; }
213     bool isOverflowScrollingNode() const { return m_nodeType == ScrollingNodeType::Overflow; }
214     bool isOverflowScrollProxyNode() const { return m_nodeType == ScrollingNodeType::OverflowProxy; }
215 
216     virtual Ref&lt;ScrollingStateNode&gt; clone(ScrollingStateTree&amp; adoptiveTree) = 0;
217     Ref&lt;ScrollingStateNode&gt; cloneAndReset(ScrollingStateTree&amp; adoptiveTree);
218     void cloneAndResetChildren(ScrollingStateNode&amp;, ScrollingStateTree&amp; adoptiveTree);
219 
220     // FIXME: using an OptionSet&lt;&gt; for these and derived class bits would simplify code.
221     enum {
222         Layer = 0,
223         ChildNodes,
224         NumStateNodeBits // This must remain at the last position.
225     };
226     typedef uint64_t ChangedProperties;
227 
228     bool hasChangedProperties() const { return m_changedProperties; }
229     bool hasChangedProperty(unsigned propertyBit) const { return m_changedProperties &amp; (static_cast&lt;ChangedProperties&gt;(1) &lt;&lt; propertyBit); }
230     void resetChangedProperties() { m_changedProperties = 0; }
231     void setPropertyChanged(unsigned propertyBit);
232     virtual void setPropertyChangedBitsAfterReattach();
233 
234     ChangedProperties changedProperties() const { return m_changedProperties; }
235     void setChangedProperties(ChangedProperties changedProperties) { m_changedProperties = changedProperties; }
236 
237     virtual void reconcileLayerPositionForViewportRect(const LayoutRect&amp; /*viewportRect*/, ScrollingLayerPositionAction) { }
238 
239     const LayerRepresentation&amp; layer() const { return m_layer; }
240     WEBCORE_EXPORT void setLayer(const LayerRepresentation&amp;);
241 
242     ScrollingStateTree&amp; scrollingStateTree() const { return m_scrollingStateTree; }
243 
244     ScrollingNodeID scrollingNodeID() const { return m_nodeID; }
245 
246     ScrollingStateNode* parent() const { return m_parent; }
247     void setParent(ScrollingStateNode* parent) { m_parent = parent; }
248     ScrollingNodeID parentNodeID() const { return m_parent ? m_parent-&gt;scrollingNodeID() : 0; }
249 
250     Vector&lt;RefPtr&lt;ScrollingStateNode&gt;&gt;* children() const { return m_children.get(); }
251     std::unique_ptr&lt;Vector&lt;RefPtr&lt;ScrollingStateNode&gt;&gt;&gt; takeChildren() { return WTFMove(m_children); }
252 
253     void appendChild(Ref&lt;ScrollingStateNode&gt;&amp;&amp;);
254     void insertChild(Ref&lt;ScrollingStateNode&gt;&amp;&amp;, size_t index);
255 
256     // Note that node ownership is via the parent, so these functions can trigger node deletion.
257     void removeFromParent();
258     void removeChildAtIndex(size_t index);
259     void removeChild(ScrollingStateNode&amp;);
260 
261     size_t indexOfChild(ScrollingStateNode&amp;) const;
262 
263     String scrollingStateTreeAsText(ScrollingStateTreeAsTextBehavior = ScrollingStateTreeAsTextBehaviorNormal) const;
264 
265 protected:
266     ScrollingStateNode(const ScrollingStateNode&amp;, ScrollingStateTree&amp;);
267     ScrollingStateNode(ScrollingNodeType, ScrollingStateTree&amp;, ScrollingNodeID);
268 
269     virtual void dumpProperties(WTF::TextStream&amp;, ScrollingStateTreeAsTextBehavior) const;
270 
271     inline void setPropertyChangedBit(unsigned propertyBit);
272 
273 private:
274     void dump(WTF::TextStream&amp;, ScrollingStateTreeAsTextBehavior) const;
275 
276     const ScrollingNodeType m_nodeType;
277     const ScrollingNodeID m_nodeID;
278     ChangedProperties m_changedProperties { 0 };
279 
280     ScrollingStateTree&amp; m_scrollingStateTree;
281 
282     ScrollingStateNode* m_parent { nullptr };
283     std::unique_ptr&lt;Vector&lt;RefPtr&lt;ScrollingStateNode&gt;&gt;&gt; m_children;
284 
285     LayerRepresentation m_layer;
286 };
287 
288 void ScrollingStateNode::setPropertyChangedBit(unsigned propertyBit)
289 {
290     m_changedProperties |= (static_cast&lt;ChangedProperties&gt;(1) &lt;&lt; propertyBit);
291 }
292 
293 } // namespace WebCore
294 
295 #define SPECIALIZE_TYPE_TRAITS_SCROLLING_STATE_NODE(ToValueTypeName, predicate) \
296 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ToValueTypeName) \
297     static bool isType(const WebCore::ScrollingStateNode&amp; node) { return node.predicate; } \
298 SPECIALIZE_TYPE_TRAITS_END()
299 
300 #endif // ENABLE(ASYNC_SCROLLING)
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
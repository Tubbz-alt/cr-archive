<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/Operands.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2011-2018 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;CallFrame.h&quot;
 29 #include &quot;VirtualRegister.h&quot;
 30 
 31 #include &lt;wtf/PrintStream.h&gt;
 32 #include &lt;wtf/Vector.h&gt;
 33 
 34 namespace JSC {
 35 
 36 template&lt;typename T&gt; struct OperandValueTraits;
 37 
<a name="2" id="anc2"></a><span class="line-modified"> 38 enum OperandKind { ArgumentOperand, LocalOperand };</span>































































































 39 
 40 enum OperandsLikeTag { OperandsLike };
 41 
 42 template&lt;typename T&gt;
 43 class Operands {
 44 public:
<a name="3" id="anc3"></a><span class="line-modified"> 45     Operands()</span>
<span class="line-modified"> 46         : m_numArguments(0) { }</span>



 47 
<a name="4" id="anc4"></a><span class="line-modified"> 48     explicit Operands(size_t numArguments, size_t numLocals)</span>
 49         : m_numArguments(numArguments)
<a name="5" id="anc5"></a>
 50     {
<a name="6" id="anc6"></a><span class="line-modified"> 51         if (WTF::VectorTraits&lt;T&gt;::needsInitialization) {</span>
<span class="line-modified"> 52             m_values.resize(numArguments + numLocals);</span>
<span class="line-modified"> 53         } else {</span>
<span class="line-modified"> 54             m_values.fill(T(), numArguments + numLocals);</span>
<span class="line-removed"> 55         }</span>
 56     }
 57 
<a name="7" id="anc7"></a><span class="line-modified"> 58     explicit Operands(size_t numArguments, size_t numLocals, const T&amp; initialValue)</span>
 59         : m_numArguments(numArguments)
<a name="8" id="anc8"></a>
 60     {
<a name="9" id="anc9"></a><span class="line-modified"> 61         m_values.fill(initialValue, numArguments + numLocals);</span>

 62     }
 63 
 64     template&lt;typename U&gt;
<a name="10" id="anc10"></a><span class="line-modified"> 65     explicit Operands(OperandsLikeTag, const Operands&lt;U&gt;&amp; other)</span>
 66         : m_numArguments(other.numberOfArguments())
<a name="11" id="anc11"></a>
 67     {
<a name="12" id="anc12"></a><span class="line-modified"> 68         m_values.fill(T(), other.numberOfArguments() + other.numberOfLocals());</span>

 69     }
 70 
 71     size_t numberOfArguments() const { return m_numArguments; }
<a name="13" id="anc13"></a><span class="line-modified"> 72     size_t numberOfLocals() const { return m_values.size() - m_numArguments; }</span>

 73 
<a name="14" id="anc14"></a>




 74     size_t argumentIndex(size_t idx) const
 75     {
<a name="15" id="anc15"></a><span class="line-modified"> 76         ASSERT(idx &lt; m_numArguments);</span>
 77         return idx;
 78     }
 79 
 80     size_t localIndex(size_t idx) const
 81     {
<a name="16" id="anc16"></a><span class="line-modified"> 82         return m_numArguments + idx;</span>

 83     }
 84 
<a name="17" id="anc17"></a><span class="line-modified"> 85     T&amp; argument(size_t idx)</span>
<span class="line-modified"> 86     {</span>
<span class="line-modified"> 87         return m_values[argumentIndex(idx)];</span>
<span class="line-modified"> 88     }</span>
<span class="line-modified"> 89     const T&amp; argument(size_t idx) const</span>
<span class="line-removed"> 90     {</span>
<span class="line-removed"> 91         return m_values[argumentIndex(idx)];</span>
<span class="line-removed"> 92     }</span>
 93 
<a name="18" id="anc18"></a><span class="line-modified"> 94     T&amp; local(size_t idx) { return m_values[localIndex(idx)]; }</span>
<span class="line-modified"> 95     const T&amp; local(size_t idx) const { return m_values[localIndex(idx)]; }</span>
 96 
 97     template&lt;OperandKind operandKind&gt;
 98     size_t sizeFor() const
 99     {
<a name="19" id="anc19"></a><span class="line-modified">100         if (operandKind == ArgumentOperand)</span>



101             return numberOfArguments();
<a name="20" id="anc20"></a><span class="line-modified">102         return numberOfLocals();</span>




103     }
104     template&lt;OperandKind operandKind&gt;
<a name="21" id="anc21"></a><span class="line-modified">105     T&amp; atFor(size_t idx)</span>
106     {
<a name="22" id="anc22"></a><span class="line-modified">107         if (operandKind == ArgumentOperand)</span>



108             return argument(idx);
<a name="23" id="anc23"></a><span class="line-modified">109         return local(idx);</span>




110     }
111     template&lt;OperandKind operandKind&gt;
<a name="24" id="anc24"></a><span class="line-modified">112     const T&amp; atFor(size_t idx) const</span>
113     {
<a name="25" id="anc25"></a><span class="line-modified">114         if (operandKind == ArgumentOperand)</span>



115             return argument(idx);
<a name="26" id="anc26"></a><span class="line-modified">116         return local(idx);</span>




117     }
118 
<a name="27" id="anc27"></a><span class="line-modified">119     void ensureLocals(size_t size)</span>
120     {
<a name="28" id="anc28"></a><span class="line-modified">121         size_t oldSize = m_values.size();</span>
<span class="line-removed">122         size_t newSize = m_numArguments + size;</span>
<span class="line-removed">123         if (newSize &lt;= oldSize)</span>
124             return;
125 
<a name="29" id="anc29"></a>


126         m_values.grow(newSize);
<a name="30" id="anc30"></a><span class="line-modified">127         if (!WTF::VectorTraits&lt;T&gt;::needsInitialization) {</span>
<span class="line-modified">128             for (size_t i = oldSize; i &lt; m_values.size(); ++i)</span>
<span class="line-modified">129                 m_values[i] = T();</span>




130         }
131     }
132 
<a name="31" id="anc31"></a><span class="line-modified">133     void ensureLocals(size_t size, const T&amp; ensuredValue)</span>
134     {
<a name="32" id="anc32"></a><span class="line-modified">135         size_t oldSize = m_values.size();</span>
<span class="line-removed">136         size_t newSize = m_numArguments + size;</span>
<span class="line-removed">137         if (newSize &lt;= oldSize)</span>
138             return;
139 
<a name="33" id="anc33"></a>

140         m_values.grow(newSize);
<a name="34" id="anc34"></a><span class="line-modified">141         for (size_t i = oldSize; i &lt; m_values.size(); ++i)</span>
<span class="line-modified">142             m_values[i] = ensuredValue;</span>



143     }
144 
145     void setLocal(size_t idx, const T&amp; value)
146     {
147         ensureLocals(idx + 1);
148         local(idx) = value;
149     }
150 
151     T getLocal(size_t idx)
152     {
153         return idx &gt;= numberOfLocals() ? T() : local(idx);
154     }
155 
156     void setArgumentFirstTime(size_t idx, const T&amp; value)
157     {
158         ASSERT(m_values[idx] == T());
159         argument(idx) = value;
160     }
161 
162     void setLocalFirstTime(size_t idx, const T&amp; value)
163     {
164         ASSERT(idx &gt;= numberOfLocals() || local(idx) == T());
165         setLocal(idx, value);
166     }
167 
<a name="35" id="anc35"></a><span class="line-modified">168     size_t operandIndex(int operand) const</span>



169     {
<a name="36" id="anc36"></a><span class="line-modified">170         if (operandIsArgument(operand))</span>
<span class="line-modified">171             return argumentIndex(VirtualRegister(operand).toArgument());</span>
<span class="line-modified">172         return localIndex(VirtualRegister(operand).toLocal());</span>
173     }
174 
<a name="37" id="anc37"></a><span class="line-modified">175     size_t operandIndex(VirtualRegister virtualRegister) const</span>
176     {
<a name="38" id="anc38"></a><span class="line-modified">177         return operandIndex(virtualRegister.offset());</span>


178     }
179 
<a name="39" id="anc39"></a><span class="line-modified">180     T&amp; operand(int operand)</span>
181     {
<a name="40" id="anc40"></a><span class="line-modified">182         if (operandIsArgument(operand))</span>
<span class="line-modified">183             return argument(VirtualRegister(operand).toArgument());</span>
<span class="line-modified">184         return local(VirtualRegister(operand).toLocal());</span>
185     }
186 
<a name="41" id="anc41"></a><span class="line-modified">187     T&amp; operand(VirtualRegister virtualRegister)</span>
188     {
<a name="42" id="anc42"></a><span class="line-modified">189         return operand(virtualRegister.offset());</span>


190     }
191 
<a name="43" id="anc43"></a><span class="line-modified">192     const T&amp; operand(int operand) const { return const_cast&lt;const T&amp;&gt;(const_cast&lt;Operands*&gt;(this)-&gt;operand(operand)); }</span>
<span class="line-modified">193     const T&amp; operand(VirtualRegister operand) const { return const_cast&lt;const T&amp;&gt;(const_cast&lt;Operands*&gt;(this)-&gt;operand(operand)); }</span>
194 
<a name="44" id="anc44"></a><span class="line-modified">195     bool hasOperand(int operand) const</span>
196     {
<a name="45" id="anc45"></a><span class="line-modified">197         if (operandIsArgument(operand))</span>
198             return true;
<a name="46" id="anc46"></a><span class="line-modified">199         return static_cast&lt;size_t&gt;(VirtualRegister(operand).toLocal()) &lt; numberOfLocals();</span>
200     }
<a name="47" id="anc47"></a><span class="line-modified">201     bool hasOperand(VirtualRegister reg) const</span>
202     {
<a name="48" id="anc48"></a><span class="line-modified">203         return hasOperand(reg.offset());</span>




204     }
205 
<a name="49" id="anc49"></a><span class="line-modified">206     void setOperand(int operand, const T&amp; value)</span>
207     {
208         this-&gt;operand(operand) = value;
209     }
210 
<a name="50" id="anc50"></a><span class="line-removed">211     void setOperand(VirtualRegister virtualRegister, const T&amp; value)</span>
<span class="line-removed">212     {</span>
<span class="line-removed">213         setOperand(virtualRegister.offset(), value);</span>
<span class="line-removed">214     }</span>
<span class="line-removed">215 </span>
216     size_t size() const { return m_values.size(); }
<a name="51" id="anc51"></a><span class="line-modified">217     const T&amp; at(size_t index) const { return m_values[index]; }</span>
<span class="line-modified">218     T&amp; at(size_t index) { return m_values[index]; }</span>
<span class="line-modified">219     const T&amp; operator[](size_t index) const { return at(index); }</span>
<span class="line-modified">220     T&amp; operator[](size_t index) { return at(index); }</span>
<span class="line-removed">221 </span>
<span class="line-removed">222     bool isArgument(size_t index) const { return index &lt; m_numArguments; }</span>
<span class="line-removed">223     bool isLocal(size_t index) const { return !isArgument(index); }</span>
<span class="line-removed">224     int operandForIndex(size_t index) const</span>
<span class="line-removed">225     {</span>
<span class="line-removed">226         if (index &lt; numberOfArguments())</span>
<span class="line-removed">227             return virtualRegisterForArgument(index).offset();</span>
<span class="line-removed">228         return virtualRegisterForLocal(index - numberOfArguments()).offset();</span>
<span class="line-removed">229     }</span>
<span class="line-removed">230     VirtualRegister virtualRegisterForIndex(size_t index) const</span>
<span class="line-removed">231     {</span>
<span class="line-removed">232         return VirtualRegister(operandForIndex(index));</span>
<span class="line-removed">233     }</span>
234 
<a name="52" id="anc52"></a><span class="line-modified">235     void setOperandFirstTime(int operand, const T&amp; value)</span>
236     {
<a name="53" id="anc53"></a><span class="line-modified">237         if (operandIsArgument(operand)) {</span>
<span class="line-modified">238             setArgumentFirstTime(VirtualRegister(operand).toArgument(), value);</span>
<span class="line-modified">239             return;</span>
<span class="line-modified">240         }</span>
<span class="line-modified">241 </span>
<span class="line-removed">242         setLocalFirstTime(VirtualRegister(operand).toLocal(), value);</span>
243     }
244 
245     void fill(T value)
246     {
247         for (size_t i = 0; i &lt; m_values.size(); ++i)
248             m_values[i] = value;
249     }
250 
251     void clear()
252     {
253         fill(T());
254     }
255 
256     bool operator==(const Operands&amp; other) const
257     {
258         ASSERT(numberOfArguments() == other.numberOfArguments());
259         ASSERT(numberOfLocals() == other.numberOfLocals());
<a name="54" id="anc54"></a>
260 
261         return m_values == other.m_values;
262     }
263 
264     void dumpInContext(PrintStream&amp; out, DumpContext* context) const;
265     void dump(PrintStream&amp; out) const;
266 
267 private:
<a name="55" id="anc55"></a><span class="line-modified">268     // The first m_numArguments of m_values are arguments, the rest are locals.</span>
<span class="line-modified">269     Vector&lt;T, 0, UnsafeVectorOverflow&gt; m_values;</span>
<span class="line-modified">270     unsigned m_numArguments;</span>

271 };
272 
273 } // namespace JSC
<a name="56" id="anc56"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="56" type="hidden" />
</body>
</html>
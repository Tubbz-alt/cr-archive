<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollView.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2017 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;ScrollView.h&quot;
  28 
  29 #include &quot;GraphicsContext.h&quot;
  30 #include &quot;GraphicsLayer.h&quot;
  31 #include &quot;HostWindow.h&quot;
  32 #include &quot;Logging.h&quot;
  33 #include &quot;PlatformMouseEvent.h&quot;
  34 #include &quot;PlatformWheelEvent.h&quot;
  35 #include &quot;ScrollAnimator.h&quot;
  36 #include &quot;Scrollbar.h&quot;
  37 #include &quot;ScrollbarTheme.h&quot;
  38 #include &lt;wtf/StdLibExtras.h&gt;
  39 #include &lt;wtf/text/TextStream.h&gt;
  40 
  41 namespace WebCore {
  42 
  43 ScrollView::ScrollView() = default;
  44 
  45 ScrollView::~ScrollView() = default;
  46 
  47 void ScrollView::addChild(Widget&amp; child)
  48 {
  49     ASSERT(&amp;child != this);
  50     ASSERT(!child.parent());
  51     child.setParent(this);
  52     m_children.add(child);
  53     if (child.platformWidget())
  54         platformAddChild(&amp;child);
  55 }
  56 
  57 void ScrollView::removeChild(Widget&amp; child)
  58 {
  59     ASSERT(child.parent() == this);
  60     child.setParent(nullptr);
  61     m_children.remove(&amp;child);
  62     if (child.platformWidget())
  63         platformRemoveChild(&amp;child);
  64 }
  65 
  66 bool ScrollView::setHasHorizontalScrollbar(bool hasBar, bool* contentSizeAffected)
  67 {
  68     return setHasScrollbarInternal(m_horizontalScrollbar, HorizontalScrollbar, hasBar, contentSizeAffected);
  69 }
  70 
  71 bool ScrollView::setHasVerticalScrollbar(bool hasBar, bool* contentSizeAffected)
  72 {
  73     return setHasScrollbarInternal(m_verticalScrollbar, VerticalScrollbar, hasBar, contentSizeAffected);
  74 }
  75 
  76 bool ScrollView::setHasScrollbarInternal(RefPtr&lt;Scrollbar&gt;&amp; scrollbar, ScrollbarOrientation orientation, bool hasBar, bool* contentSizeAffected)
  77 {
  78     ASSERT(!hasBar || !avoidScrollbarCreation());
  79 
  80     if (hasBar &amp;&amp; !scrollbar) {
  81         scrollbar = createScrollbar(orientation);
  82         addChild(*scrollbar);
  83         didAddScrollbar(scrollbar.get(), orientation);
  84         scrollbar-&gt;styleChanged();
  85         if (contentSizeAffected)
  86             *contentSizeAffected = !scrollbar-&gt;isOverlayScrollbar();
  87         return true;
  88     }
  89 
  90     if (!hasBar &amp;&amp; scrollbar) {
  91         bool wasOverlayScrollbar = scrollbar-&gt;isOverlayScrollbar();
  92         willRemoveScrollbar(scrollbar.get(), orientation);
  93         removeChild(*scrollbar);
  94         scrollbar = nullptr;
  95         if (contentSizeAffected)
  96             *contentSizeAffected = !wasOverlayScrollbar;
  97         return true;
  98     }
  99 
 100     return false;
 101 }
 102 
 103 Ref&lt;Scrollbar&gt; ScrollView::createScrollbar(ScrollbarOrientation orientation)
 104 {
 105     return Scrollbar::createNativeScrollbar(*this, orientation, RegularScrollbar);
 106 }
 107 
 108 void ScrollView::setScrollbarModes(ScrollbarMode horizontalMode, ScrollbarMode verticalMode,
 109                                    bool horizontalLock, bool verticalLock)
 110 {
 111     bool needsUpdate = false;
 112 
 113     if (horizontalMode != horizontalScrollbarMode() &amp;&amp; !m_horizontalScrollbarLock) {
 114         m_horizontalScrollbarMode = horizontalMode;
 115         needsUpdate = true;
 116     }
 117 
 118     if (verticalMode != verticalScrollbarMode() &amp;&amp; !m_verticalScrollbarLock) {
 119         m_verticalScrollbarMode = verticalMode;
 120         needsUpdate = true;
 121     }
 122 
 123     if (horizontalLock)
 124         setHorizontalScrollbarLock();
 125 
 126     if (verticalLock)
 127         setVerticalScrollbarLock();
 128 
 129     if (!needsUpdate)
 130         return;
 131 
 132     if (platformWidget())
 133         platformSetScrollbarModes();
 134     else
 135         updateScrollbars(scrollPosition());
 136 }
 137 
 138 void ScrollView::scrollbarModes(ScrollbarMode&amp; horizontalMode, ScrollbarMode&amp; verticalMode) const
 139 {
 140     if (platformWidget()) {
 141         platformScrollbarModes(horizontalMode, verticalMode);
 142         return;
 143     }
 144     horizontalMode = m_horizontalScrollbarMode;
 145     verticalMode = m_verticalScrollbarMode;
 146 }
 147 
 148 void ScrollView::setCanHaveScrollbars(bool canScroll)
 149 {
 150     ScrollbarMode newHorizontalMode;
 151     ScrollbarMode newVerticalMode;
 152 
 153     scrollbarModes(newHorizontalMode, newVerticalMode);
 154 
 155     if (canScroll &amp;&amp; newVerticalMode == ScrollbarAlwaysOff)
 156         newVerticalMode = ScrollbarAuto;
 157     else if (!canScroll)
 158         newVerticalMode = ScrollbarAlwaysOff;
 159 
 160     if (canScroll &amp;&amp; newHorizontalMode == ScrollbarAlwaysOff)
 161         newHorizontalMode = ScrollbarAuto;
 162     else if (!canScroll)
 163         newHorizontalMode = ScrollbarAlwaysOff;
 164 
 165     setScrollbarModes(newHorizontalMode, newVerticalMode);
 166 }
 167 
 168 void ScrollView::setCanBlitOnScroll(bool b)
 169 {
 170     if (platformWidget()) {
 171         platformSetCanBlitOnScroll(b);
 172         return;
 173     }
 174 
 175     m_canBlitOnScroll = b;
 176 }
 177 
 178 bool ScrollView::canBlitOnScroll() const
 179 {
 180     if (platformWidget())
 181         return platformCanBlitOnScroll();
 182 
 183     return m_canBlitOnScroll;
 184 }
 185 
 186 void ScrollView::setPaintsEntireContents(bool paintsEntireContents)
 187 {
 188     m_paintsEntireContents = paintsEntireContents;
 189 }
 190 
 191 void ScrollView::setDelegatesScrolling(bool delegatesScrolling)
 192 {
 193     if (m_delegatesScrolling == delegatesScrolling)
 194         return;
 195 
 196     m_delegatesScrolling = delegatesScrolling;
 197     delegatesScrollingDidChange();
 198 }
 199 
 200 IntPoint ScrollView::contentsScrollPosition() const
 201 {
 202 #if PLATFORM(IOS_FAMILY)
 203     if (platformWidget())
 204         return actualScrollPosition();
 205 #endif
 206     return scrollPosition();
 207 }
 208 
 209 void ScrollView::setContentsScrollPosition(const IntPoint&amp; position, ScrollClamping clamping)
 210 {
 211 #if PLATFORM(IOS_FAMILY)
 212     if (platformWidget())
 213         setActualScrollPosition(position);
 214 #endif
 215     setScrollPosition(position, clamping);
 216 }
 217 
 218 FloatRect ScrollView::exposedContentRect() const
 219 {
 220 #if PLATFORM(IOS_FAMILY)
 221     if (platformWidget())
 222         return platformExposedContentRect();
 223 #endif
 224 
 225     const ScrollView* parent = this-&gt;parent();
 226     if (!parent)
 227         return m_delegatedScrollingGeometry ? m_delegatedScrollingGeometry-&gt;exposedContentRect : FloatRect();
 228 
 229     IntRect parentViewExtentContentRect = enclosingIntRect(parent-&gt;exposedContentRect());
 230     IntRect selfExtentContentRect = rootViewToContents(parentViewExtentContentRect);
 231     selfExtentContentRect.intersect(boundsRect());
 232     return selfExtentContentRect;
 233 }
 234 
 235 void ScrollView::setExposedContentRect(const FloatRect&amp; rect)
 236 {
 237     ASSERT(!platformWidget());
 238 
 239     if (!m_delegatedScrollingGeometry)
 240         m_delegatedScrollingGeometry = DelegatedScrollingGeometry();
 241 
 242     m_delegatedScrollingGeometry-&gt;exposedContentRect = rect;
 243 }
 244 
 245 FloatSize ScrollView::unobscuredContentSize() const
 246 {
 247     ASSERT(m_delegatedScrollingGeometry);
 248     if (m_delegatedScrollingGeometry)
 249         return m_delegatedScrollingGeometry-&gt;unobscuredContentSize;
 250     return { };
 251 }
 252 
 253 void ScrollView::setUnobscuredContentSize(const FloatSize&amp; size)
 254 {
 255     ASSERT(!platformWidget());
 256     if (m_delegatedScrollingGeometry &amp;&amp; size == m_delegatedScrollingGeometry-&gt;unobscuredContentSize)
 257         return;
 258 
 259     if (!m_delegatedScrollingGeometry)
 260         m_delegatedScrollingGeometry = DelegatedScrollingGeometry();
 261 
 262     m_delegatedScrollingGeometry-&gt;unobscuredContentSize = size;
 263     unobscuredContentSizeChanged();
 264 }
 265 
 266 IntRect ScrollView::unobscuredContentRect(VisibleContentRectIncludesScrollbars scrollbarInclusion) const
 267 {
 268     if (platformWidget())
 269         return platformUnobscuredContentRect(scrollbarInclusion);
 270 
 271     if (m_delegatedScrollingGeometry)
 272         return IntRect(m_scrollPosition, roundedIntSize(m_delegatedScrollingGeometry-&gt;unobscuredContentSize));
 273 
 274     return unobscuredContentRectInternal(scrollbarInclusion);
 275 }
 276 
 277 IntRect ScrollView::unobscuredContentRectInternal(VisibleContentRectIncludesScrollbars scrollbarInclusion) const
 278 {
 279     FloatSize visibleContentSize = sizeForUnobscuredContent(scrollbarInclusion);
 280     visibleContentSize.scale(1 / visibleContentScaleFactor());
 281     return IntRect(m_scrollPosition, expandedIntSize(visibleContentSize));
 282 }
 283 
 284 IntSize ScrollView::sizeForVisibleContent(VisibleContentRectIncludesScrollbars scrollbarInclusion) const
 285 {
 286     if (platformWidget())
 287         return platformVisibleContentSizeIncludingObscuredArea(scrollbarInclusion == IncludeScrollbars);
 288 
 289 #if USE(COORDINATED_GRAPHICS)
 290     if (m_useFixedLayout &amp;&amp; !m_fixedVisibleContentRect.isEmpty())
 291         return m_fixedVisibleContentRect.size();
 292 #endif
 293 
 294     IntSize scrollbarSpace;
 295     if (scrollbarInclusion == ExcludeScrollbars)
 296         scrollbarSpace = scrollbarIntrusion();
 297 
 298     return IntSize(width() - scrollbarSpace.width(), height() - scrollbarSpace.height()).expandedTo(IntSize());
 299 }
 300 
 301 IntSize ScrollView::sizeForUnobscuredContent(VisibleContentRectIncludesScrollbars scrollbarInclusion) const
 302 {
 303     if (platformWidget())
 304         return platformVisibleContentSize(scrollbarInclusion == IncludeScrollbars);
 305 
 306     IntSize visibleContentSize = sizeForVisibleContent(scrollbarInclusion);
 307 
 308 #if USE(COORDINATED_GRAPHICS)
 309     if (m_useFixedLayout &amp;&amp; !m_fixedVisibleContentRect.isEmpty())
 310         return visibleContentSize;
 311 #endif
 312 
 313     visibleContentSize.setHeight(visibleContentSize.height() - topContentInset());
 314     return visibleContentSize;
 315 }
 316 
 317 IntRect ScrollView::visibleContentRectInternal(VisibleContentRectIncludesScrollbars scrollbarInclusion, VisibleContentRectBehavior visibleContentRectBehavior) const
 318 {
 319 #if PLATFORM(IOS_FAMILY)
 320     if (visibleContentRectBehavior == LegacyIOSDocumentViewRect) {
 321         if (platformWidget())
 322             return platformVisibleContentRect(scrollbarInclusion == IncludeScrollbars);
 323     }
 324 
 325     if (platformWidget())
 326         return unobscuredContentRect(scrollbarInclusion);
 327 #else
 328     UNUSED_PARAM(visibleContentRectBehavior);
 329 #endif
 330 
 331     if (platformWidget())
 332         return platformVisibleContentRect(scrollbarInclusion == IncludeScrollbars);
 333 
 334 #if USE(COORDINATED_GRAPHICS)
 335     if (m_useFixedLayout &amp;&amp; !m_fixedVisibleContentRect.isEmpty())
 336         return m_fixedVisibleContentRect;
 337 #endif
 338 
 339     return unobscuredContentRect(scrollbarInclusion);
 340 }
 341 
 342 IntSize ScrollView::layoutSize() const
 343 {
 344     return m_fixedLayoutSize.isEmpty() || !m_useFixedLayout ? sizeForUnobscuredContent() : m_fixedLayoutSize;
 345 }
 346 
 347 IntSize ScrollView::fixedLayoutSize() const
 348 {
 349     return m_fixedLayoutSize;
 350 }
 351 
 352 void ScrollView::setFixedLayoutSize(const IntSize&amp; newSize)
 353 {
 354     if (fixedLayoutSize() == newSize)
 355         return;
 356 
 357     LOG_WITH_STREAM(Layout, stream &lt;&lt; &quot;ScrollView &quot; &lt;&lt; this &lt;&lt; &quot; setFixedLayoutSize &quot; &lt;&lt; newSize);
 358     m_fixedLayoutSize = newSize;
 359     if (m_useFixedLayout)
 360         availableContentSizeChanged(AvailableSizeChangeReason::AreaSizeChanged);
 361 }
 362 
 363 bool ScrollView::useFixedLayout() const
 364 {
 365     return m_useFixedLayout;
 366 }
 367 
 368 void ScrollView::setUseFixedLayout(bool enable)
 369 {
 370     if (useFixedLayout() == enable)
 371         return;
 372     m_useFixedLayout = enable;
 373     if (!m_fixedLayoutSize.isEmpty())
 374         availableContentSizeChanged(AvailableSizeChangeReason::AreaSizeChanged);
 375 }
 376 
 377 void ScrollView::availableContentSizeChanged(AvailableSizeChangeReason reason)
 378 {
 379     ScrollableArea::availableContentSizeChanged(reason);
 380 
 381     if (platformWidget())
 382         return;
 383 
 384     if (reason != AvailableSizeChangeReason::ScrollbarsChanged)
 385         updateScrollbars(scrollPosition());
 386 }
 387 
 388 IntSize ScrollView::contentsSize() const
 389 {
 390     return m_contentsSize;
 391 }
 392 
 393 void ScrollView::setContentsSize(const IntSize&amp; newSize)
 394 {
 395     if (contentsSize() == newSize)
 396         return;
 397     m_contentsSize = newSize;
 398     if (platformWidget())
 399         platformSetContentsSize();
 400     else
 401         updateScrollbars(scrollPosition());
 402     updateOverhangAreas();
 403 }
 404 
 405 ScrollPosition ScrollView::maximumScrollPosition() const
 406 {
 407     ScrollPosition maximumPosition = ScrollableArea::maximumScrollPosition();
 408     // FIXME: can this be moved into the base class?
 409     maximumPosition.clampNegativeToZero();
 410     return maximumPosition;
 411 }
 412 
 413 ScrollPosition ScrollView::adjustScrollPositionWithinRange(const ScrollPosition&amp; scrollPoint) const
 414 {
 415     if (!constrainsScrollingToContentEdge() || m_allowsUnclampedScrollPosition)
 416         return scrollPoint;
 417 
 418     return scrollPoint.constrainedBetween(minimumScrollPosition(), maximumScrollPosition());
 419 }
 420 
 421 ScrollPosition ScrollView::documentScrollPositionRelativeToViewOrigin() const
 422 {
 423     return scrollPosition() - IntSize(
 424         shouldPlaceBlockDirectionScrollbarOnLeft() &amp;&amp; m_verticalScrollbar ? m_verticalScrollbar-&gt;occupiedWidth() : 0,
 425         headerHeight() + topContentInset(TopContentInsetType::WebCoreOrPlatformContentInset));
 426 }
 427 
 428 ScrollPosition ScrollView::documentScrollPositionRelativeToScrollableAreaOrigin() const
 429 {
 430     return scrollPosition() - IntSize(0, headerHeight());
 431 }
 432 
 433 void ScrollView::notifyPageThatContentAreaWillPaint() const
 434 {
 435 }
 436 
 437 void ScrollView::setScrollOffset(const ScrollOffset&amp; offset)
 438 {
 439     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;\nScrollView::setScrollOffset &quot; &lt;&lt; offset &lt;&lt; &quot; constrains &quot; &lt;&lt; constrainsScrollingToContentEdge());
 440 
 441     IntPoint constrainedOffset = offset;
 442     if (constrainsScrollingToContentEdge())
 443         constrainedOffset = constrainedOffset.constrainedBetween(IntPoint(), maximumScrollOffset());
 444 
 445     scrollTo(scrollPositionFromOffset(constrainedOffset));
 446 }
 447 
 448 void ScrollView::scrollOffsetChangedViaPlatformWidget(const ScrollOffset&amp; oldOffset, const ScrollOffset&amp; newOffset)
 449 {
 450     // We should not attempt to actually modify (paint) platform widgets if the layout phase
 451     // is not complete. Instead, defer the scroll event until the layout finishes.
 452     if (shouldDeferScrollUpdateAfterContentSizeChange()) {
 453         // We only care about the most recent scroll position change request
 454         m_deferredScrollOffsets = std::make_pair(oldOffset, newOffset);
 455         return;
 456     }
 457 
 458     scrollOffsetChangedViaPlatformWidgetImpl(oldOffset, newOffset);
 459 }
 460 
 461 void ScrollView::handleDeferredScrollUpdateAfterContentSizeChange()
 462 {
 463     ASSERT(!shouldDeferScrollUpdateAfterContentSizeChange());
 464 
 465     if (!m_deferredScrollDelta &amp;&amp; !m_deferredScrollOffsets)
 466         return;
 467 
 468     ASSERT(static_cast&lt;bool&gt;(m_deferredScrollDelta) != static_cast&lt;bool&gt;(m_deferredScrollOffsets));
 469 
 470     if (m_deferredScrollDelta)
 471         completeUpdatesAfterScrollTo(m_deferredScrollDelta.value());
 472     else if (m_deferredScrollOffsets)
 473         scrollOffsetChangedViaPlatformWidgetImpl(m_deferredScrollOffsets.value().first, m_deferredScrollOffsets.value().second);
 474 
 475     m_deferredScrollDelta = WTF::nullopt;
 476     m_deferredScrollOffsets = WTF::nullopt;
 477 }
 478 
 479 void ScrollView::scrollTo(const ScrollPosition&amp; newPosition)
 480 {
 481     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollView::scrollTo &quot; &lt;&lt; newPosition &lt;&lt; &quot; min: &quot; &lt;&lt; minimumScrollPosition() &lt;&lt; &quot; max: &quot; &lt;&lt; maximumScrollPosition());
 482 
 483     IntSize scrollDelta = newPosition - m_scrollPosition;
 484     if (scrollDelta.isZero())
 485         return;
 486 
 487     m_scrollPosition = newPosition;
 488 
 489     if (scrollbarsSuppressed())
 490         return;
 491 
 492 #if USE(COORDINATED_GRAPHICS)
 493     if (delegatesScrolling()) {
 494         requestScrollPositionUpdate(newPosition);
 495         return;
 496     }
 497 #endif
 498     // We should not attempt to actually modify layer contents if the layout phase
 499     // is not complete. Instead, defer the scroll event until the layout finishes.
 500     if (shouldDeferScrollUpdateAfterContentSizeChange()) {
 501         ASSERT(!m_deferredScrollDelta);
 502         m_deferredScrollDelta = scrollDelta;
 503         return;
 504     }
 505 
 506     completeUpdatesAfterScrollTo(scrollDelta);
 507 }
 508 
 509 void ScrollView::completeUpdatesAfterScrollTo(const IntSize&amp; scrollDelta)
 510 {
 511     updateLayerPositionsAfterScrolling();
 512     scrollContents(scrollDelta);
 513     updateCompositingLayersAfterScrolling();
 514 }
 515 
 516 void ScrollView::setScrollPosition(const ScrollPosition&amp; scrollPosition, ScrollClamping clamping)
 517 {
 518     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollView::setScrollPosition &quot; &lt;&lt; scrollPosition);
 519 
 520     if (prohibitsScrolling())
 521         return;
 522 
 523     if (platformWidget()) {
 524         platformSetScrollPosition(scrollPosition);
 525         return;
 526     }
 527 
 528     ScrollPosition newScrollPosition = (!delegatesScrolling() &amp;&amp; clamping == ScrollClamping::Clamped) ? adjustScrollPositionWithinRange(scrollPosition) : scrollPosition;
 529 
 530     if ((!delegatesScrolling() || currentScrollType() == ScrollType::User) &amp;&amp; newScrollPosition == this-&gt;scrollPosition())
 531         return;
 532 
 533     if (requestScrollPositionUpdate(newScrollPosition, currentScrollType(), clamping))
 534         return;
 535 
 536     updateScrollbars(newScrollPosition);
 537 }
 538 
 539 bool ScrollView::scroll(ScrollDirection direction, ScrollGranularity granularity)
 540 {
 541     if (platformWidget())
 542         return platformScroll(direction, granularity);
 543 
 544     return ScrollableArea::scroll(direction, granularity);
 545 }
 546 
 547 bool ScrollView::logicalScroll(ScrollLogicalDirection direction, ScrollGranularity granularity)
 548 {
 549     return scroll(logicalToPhysical(direction, isVerticalDocument(), isFlippedDocument()), granularity);
 550 }
 551 
 552 IntSize ScrollView::overhangAmount() const
 553 {
 554     IntSize stretch;
 555 
 556     // FIXME: use maximumScrollOffset()
 557     ScrollOffset scrollOffset = this-&gt;scrollOffset();
 558     if (scrollOffset.y() &lt; 0)
 559         stretch.setHeight(scrollOffset.y());
 560     else if (totalContentsSize().height() &amp;&amp; scrollOffset.y() &gt; totalContentsSize().height() - visibleHeight())
 561         stretch.setHeight(scrollOffset.y() - (totalContentsSize().height() - visibleHeight()));
 562 
 563     if (scrollOffset.x() &lt; 0)
 564         stretch.setWidth(scrollOffset.x());
 565     else if (contentsWidth() &amp;&amp; scrollOffset.x() &gt; contentsWidth() - visibleWidth())
 566         stretch.setWidth(scrollOffset.x() - (contentsWidth() - visibleWidth()));
 567 
 568     return stretch;
 569 }
 570 
 571 bool ScrollView::managesScrollbars() const
 572 {
 573 #if PLATFORM(IOS_FAMILY)
 574     return false;
 575 #else
 576     if (platformWidget())
 577         return false;
 578     if (delegatesScrolling())
 579         return false;
 580     return true;
 581 #endif
 582 }
 583 
 584 void ScrollView::updateScrollbars(const ScrollPosition&amp; desiredPosition)
 585 {
 586     LOG_WITH_STREAM(Scrolling, stream &lt;&lt; &quot;ScrollView::updateScrollbars &quot; &lt;&lt; desiredPosition);
 587 
 588     if (m_inUpdateScrollbars || prohibitsScrolling() || platformWidget())
 589         return;
 590 
 591     if (!managesScrollbars()) {
 592         if (scrollOriginChanged()) {
 593             ScrollableArea::scrollToOffsetWithoutAnimation(scrollOffsetFromPosition(desiredPosition));
 594             resetScrollOriginChanged();
 595         }
 596         return;
 597     }
 598 
 599     bool hasOverlayScrollbars = (!m_horizontalScrollbar || m_horizontalScrollbar-&gt;isOverlayScrollbar()) &amp;&amp; (!m_verticalScrollbar || m_verticalScrollbar-&gt;isOverlayScrollbar());
 600 
 601     // If we came in here with the view already needing a layout then do that first.
 602     // (This will be the common case, e.g., when the page changes due to window resizing for example).
 603     // This layout will not re-enter updateScrollbars and does not count towards our max layout pass total.
 604     if (!m_scrollbarsSuppressed &amp;&amp; !hasOverlayScrollbars) {
 605         m_inUpdateScrollbars = true;
 606         updateContentsSize();
 607         m_inUpdateScrollbars = false;
 608     }
 609 
 610     IntRect oldScrollCornerRect = scrollCornerRect();
 611 
 612     bool hasHorizontalScrollbar = m_horizontalScrollbar;
 613     bool hasVerticalScrollbar = m_verticalScrollbar;
 614 
 615     bool newHasHorizontalScrollbar = hasHorizontalScrollbar;
 616     bool newHasVerticalScrollbar = hasVerticalScrollbar;
 617 
 618     ScrollbarMode hScroll = m_horizontalScrollbarMode;
 619     ScrollbarMode vScroll = m_verticalScrollbarMode;
 620 
 621     if (hScroll != ScrollbarAuto)
 622         newHasHorizontalScrollbar = (hScroll == ScrollbarAlwaysOn);
 623     if (vScroll != ScrollbarAuto)
 624         newHasVerticalScrollbar = (vScroll == ScrollbarAlwaysOn);
 625 
 626     bool scrollbarAddedOrRemoved = false;
 627 
 628     if (m_scrollbarsSuppressed || (hScroll != ScrollbarAuto &amp;&amp; vScroll != ScrollbarAuto)) {
 629         if (hasHorizontalScrollbar != newHasHorizontalScrollbar &amp;&amp; (hasHorizontalScrollbar || !avoidScrollbarCreation())) {
 630             if (setHasHorizontalScrollbar(newHasHorizontalScrollbar))
 631                 scrollbarAddedOrRemoved = true;
 632         }
 633 
 634         if (hasVerticalScrollbar != newHasVerticalScrollbar &amp;&amp; (hasVerticalScrollbar || !avoidScrollbarCreation())) {
 635             if (setHasVerticalScrollbar(newHasVerticalScrollbar))
 636                 scrollbarAddedOrRemoved = true;
 637         }
 638     } else {
 639         bool sendContentResizedNotification = false;
 640 
 641         IntSize docSize = totalContentsSize();
 642         IntSize fullVisibleSize = unobscuredContentRectIncludingScrollbars().size();
 643 
 644         if (hScroll == ScrollbarAuto)
 645             newHasHorizontalScrollbar = docSize.width() &gt; visibleWidth();
 646         if (vScroll == ScrollbarAuto)
 647             newHasVerticalScrollbar = docSize.height() &gt; visibleHeight();
 648 
 649         bool needAnotherPass = false;
 650         if (!hasOverlayScrollbars) {
 651             // If we ever turn one scrollbar off, do not turn the other one on. Never ever
 652             // try to both gain/lose a scrollbar in the same pass.
 653             if (!m_updateScrollbarsPass &amp;&amp; docSize.width() &lt;= fullVisibleSize.width() &amp;&amp; docSize.height() &lt;= fullVisibleSize.height()) {
 654                 if (hScroll == ScrollbarAuto)
 655                     newHasHorizontalScrollbar = false;
 656                 if (vScroll == ScrollbarAuto)
 657                     newHasVerticalScrollbar = false;
 658             }
 659             if (!newHasHorizontalScrollbar &amp;&amp; hasHorizontalScrollbar &amp;&amp; vScroll != ScrollbarAlwaysOn &amp;&amp; !hasVerticalScrollbar) {
 660                 newHasVerticalScrollbar = false;
 661                 needAnotherPass = true;
 662             }
 663             if (!newHasVerticalScrollbar &amp;&amp; hasVerticalScrollbar &amp;&amp; hScroll != ScrollbarAlwaysOn &amp;&amp; !hasHorizontalScrollbar) {
 664                 newHasHorizontalScrollbar = false;
 665                 needAnotherPass = true;
 666             }
 667         }
 668 
 669         if (hasHorizontalScrollbar != newHasHorizontalScrollbar &amp;&amp; (hasHorizontalScrollbar || !avoidScrollbarCreation())) {
 670             if (scrollOrigin().y() &amp;&amp; !newHasHorizontalScrollbar)
 671                 ScrollableArea::setScrollOrigin(IntPoint(scrollOrigin().x(), scrollOrigin().y() - m_horizontalScrollbar-&gt;occupiedHeight()));
 672             if (m_horizontalScrollbar)
 673                 m_horizontalScrollbar-&gt;invalidate();
 674 
 675             bool changeAffectsContentSize = false;
 676             if (setHasHorizontalScrollbar(newHasHorizontalScrollbar, &amp;changeAffectsContentSize)) {
 677                 scrollbarAddedOrRemoved = true;
 678                 sendContentResizedNotification |= changeAffectsContentSize;
 679             }
 680         }
 681 
 682         if (hasVerticalScrollbar != newHasVerticalScrollbar &amp;&amp; (hasVerticalScrollbar || !avoidScrollbarCreation())) {
 683             if (scrollOrigin().x() &amp;&amp; !newHasVerticalScrollbar)
 684                 ScrollableArea::setScrollOrigin(IntPoint(scrollOrigin().x() - m_verticalScrollbar-&gt;occupiedWidth(), scrollOrigin().y()));
 685             if (m_verticalScrollbar)
 686                 m_verticalScrollbar-&gt;invalidate();
 687 
 688             bool changeAffectsContentSize = false;
 689             if (setHasVerticalScrollbar(newHasVerticalScrollbar, &amp;changeAffectsContentSize)) {
 690                 scrollbarAddedOrRemoved = true;
 691                 sendContentResizedNotification |= changeAffectsContentSize;
 692             }
 693         }
 694 
 695         const unsigned cMaxUpdateScrollbarsPass = 2;
 696         if ((sendContentResizedNotification || needAnotherPass) &amp;&amp; m_updateScrollbarsPass &lt; cMaxUpdateScrollbarsPass) {
 697             m_updateScrollbarsPass++;
 698             availableContentSizeChanged(AvailableSizeChangeReason::ScrollbarsChanged);
 699             updateContentsSize();
 700             IntSize newDocSize = totalContentsSize();
 701             if (newDocSize == docSize) {
 702                 // The layout with the new scroll state had no impact on
 703                 // the document&#39;s overall size, so updateScrollbars didn&#39;t get called.
 704                 // Recur manually.
 705                 updateScrollbars(desiredPosition);
 706             }
 707             m_updateScrollbarsPass--;
 708         }
 709     }
 710 
 711     if (scrollbarAddedOrRemoved)
 712         addedOrRemovedScrollbar();
 713 
 714     // Set up the range (and page step/line step), but only do this if we&#39;re not in a nested call (to avoid
 715     // doing it multiple times).
 716     if (m_updateScrollbarsPass)
 717         return;
 718 
 719     m_inUpdateScrollbars = true;
 720 
 721     if (m_horizontalScrollbar) {
 722         int clientWidth = visibleWidth();
 723         int pageStep = Scrollbar::pageStep(clientWidth);
 724         IntRect oldRect(m_horizontalScrollbar-&gt;frameRect());
 725         IntRect hBarRect(shouldPlaceBlockDirectionScrollbarOnLeft() &amp;&amp; m_verticalScrollbar ? m_verticalScrollbar-&gt;occupiedWidth() : 0,
 726             height() - m_horizontalScrollbar-&gt;height(),
 727             width() - (m_verticalScrollbar ? m_verticalScrollbar-&gt;occupiedWidth() : 0),
 728             m_horizontalScrollbar-&gt;height());
 729         m_horizontalScrollbar-&gt;setFrameRect(hBarRect);
 730         if (!m_scrollbarsSuppressed &amp;&amp; oldRect != m_horizontalScrollbar-&gt;frameRect())
 731             m_horizontalScrollbar-&gt;invalidate();
 732 
 733         if (m_scrollbarsSuppressed)
 734             m_horizontalScrollbar-&gt;setSuppressInvalidation(true);
 735         m_horizontalScrollbar-&gt;setEnabled(contentsWidth() &gt; clientWidth);
 736         m_horizontalScrollbar-&gt;setSteps(Scrollbar::pixelsPerLineStep(), pageStep);
 737         m_horizontalScrollbar-&gt;setProportion(clientWidth, contentsWidth());
 738         if (m_scrollbarsSuppressed)
 739             m_horizontalScrollbar-&gt;setSuppressInvalidation(false);
 740     }
 741 
 742     if (m_verticalScrollbar) {
 743         int clientHeight = visibleHeight();
 744         int pageStep = Scrollbar::pageStep(clientHeight);
 745         IntRect oldRect(m_verticalScrollbar-&gt;frameRect());
 746         IntRect vBarRect(shouldPlaceBlockDirectionScrollbarOnLeft() ? 0 : width() - m_verticalScrollbar-&gt;width(),
 747             topContentInset(),
 748             m_verticalScrollbar-&gt;width(),
 749             height() - topContentInset() - (m_horizontalScrollbar ? m_horizontalScrollbar-&gt;occupiedHeight() : 0));
 750         m_verticalScrollbar-&gt;setFrameRect(vBarRect);
 751         if (!m_scrollbarsSuppressed &amp;&amp; oldRect != m_verticalScrollbar-&gt;frameRect())
 752             m_verticalScrollbar-&gt;invalidate();
 753 
 754         if (m_scrollbarsSuppressed)
 755             m_verticalScrollbar-&gt;setSuppressInvalidation(true);
 756         m_verticalScrollbar-&gt;setEnabled(totalContentsSize().height() &gt; clientHeight);
 757         m_verticalScrollbar-&gt;setSteps(Scrollbar::pixelsPerLineStep(), pageStep);
 758         m_verticalScrollbar-&gt;setProportion(clientHeight, totalContentsSize().height());
 759         if (m_scrollbarsSuppressed)
 760             m_verticalScrollbar-&gt;setSuppressInvalidation(false);
 761     }
 762 
 763     if (hasHorizontalScrollbar != newHasHorizontalScrollbar || hasVerticalScrollbar != newHasVerticalScrollbar) {
 764         // FIXME: Is frameRectsChanged really necessary here? Have any frame rects changed?
 765         frameRectsChanged();
 766         positionScrollbarLayers();
 767         updateScrollCorner();
 768         if (!m_horizontalScrollbar &amp;&amp; !m_verticalScrollbar)
 769             invalidateScrollCornerRect(oldScrollCornerRect);
 770     }
 771 
 772     IntPoint adjustedScrollPosition = desiredPosition;
 773     if (!isRubberBandInProgress())
 774         adjustedScrollPosition = adjustScrollPositionWithinRange(adjustedScrollPosition);
 775 
 776     if (adjustedScrollPosition != scrollPosition() || scrollOriginChanged()) {
 777         ScrollableArea::scrollToOffsetWithoutAnimation(scrollOffsetFromPosition(adjustedScrollPosition));
 778         resetScrollOriginChanged();
 779     }
 780 
 781     // Make sure the scrollbar offsets are up to date.
 782     if (m_horizontalScrollbar)
 783         m_horizontalScrollbar-&gt;offsetDidChange();
 784     if (m_verticalScrollbar)
 785         m_verticalScrollbar-&gt;offsetDidChange();
 786 
 787     m_inUpdateScrollbars = false;
 788 }
 789 
 790 const int panIconSizeLength = 16;
 791 
 792 IntRect ScrollView::rectToCopyOnScroll() const
 793 {
 794     IntRect scrollViewRect = convertToRootView(IntRect(0, 0, visibleWidth(), visibleHeight()));
 795     if (hasOverlayScrollbars()) {
 796         int verticalScrollbarWidth = (verticalScrollbar() &amp;&amp; !hasLayerForVerticalScrollbar()) ? verticalScrollbar()-&gt;width() : 0;
 797         int horizontalScrollbarHeight = (horizontalScrollbar() &amp;&amp; !hasLayerForHorizontalScrollbar()) ? horizontalScrollbar()-&gt;height() : 0;
 798 
 799         scrollViewRect.setWidth(scrollViewRect.width() - verticalScrollbarWidth);
 800         scrollViewRect.setHeight(scrollViewRect.height() - horizontalScrollbarHeight);
 801     }
 802     return scrollViewRect;
 803 }
 804 
 805 void ScrollView::scrollContents(const IntSize&amp; scrollDelta)
 806 {
 807     HostWindow* window = hostWindow();
 808     if (!window)
 809         return;
 810 
 811     // Since scrolling is double buffered, we will be blitting the scroll view&#39;s intersection
 812     // with the clip rect every time to keep it smooth.
 813     IntRect clipRect = windowClipRect();
 814     IntRect scrollViewRect = rectToCopyOnScroll();
 815     IntRect updateRect = clipRect;
 816     updateRect.intersect(scrollViewRect);
 817 
 818     // Invalidate the root view (not the backing store).
 819     window-&gt;invalidateRootView(updateRect);
 820 
 821     if (m_drawPanScrollIcon) {
 822         // FIXME: the pan icon is broken when accelerated compositing is on, since it will draw under the compositing layers.
 823         // https://bugs.webkit.org/show_bug.cgi?id=47837
 824         int panIconDirtySquareSizeLength = 2 * (panIconSizeLength + std::max(abs(scrollDelta.width()), abs(scrollDelta.height()))); // We only want to repaint what&#39;s necessary
 825         IntPoint panIconDirtySquareLocation = IntPoint(m_panScrollIconPoint.x() - (panIconDirtySquareSizeLength / 2), m_panScrollIconPoint.y() - (panIconDirtySquareSizeLength / 2));
 826         IntRect panScrollIconDirtyRect = IntRect(panIconDirtySquareLocation, IntSize(panIconDirtySquareSizeLength, panIconDirtySquareSizeLength));
 827         panScrollIconDirtyRect.intersect(clipRect);
 828         window-&gt;invalidateContentsAndRootView(panScrollIconDirtyRect);
 829     }
 830 
 831     if (canBlitOnScroll()) { // The main frame can just blit the WebView window
 832         // FIXME: Find a way to scroll subframes with this faster path
 833         if (!scrollContentsFastPath(-scrollDelta, scrollViewRect, clipRect))
 834             scrollContentsSlowPath(updateRect);
 835     } else {
 836         // We need to repaint the entire backing store. Do it now before moving the windowed plugins.
 837         scrollContentsSlowPath(updateRect);
 838     }
 839 
 840     // Invalidate the overhang areas if they are visible.
 841     updateOverhangAreas();
 842 
 843     // This call will move children with native widgets (plugins) and invalidate them as well.
 844     frameRectsChanged();
 845 
 846     // Now blit the backingstore into the window which should be very fast.
 847     window-&gt;invalidateRootView(IntRect());
 848 }
 849 
 850 void ScrollView::scrollContentsSlowPath(const IntRect&amp; updateRect)
 851 {
 852     hostWindow()-&gt;invalidateContentsForSlowScroll(updateRect);
 853 }
 854 
 855 IntPoint ScrollView::viewToContents(const IntPoint&amp; point) const
 856 {
 857     if (delegatesScrolling())
 858         return point;
 859 
 860     return point + toIntSize(documentScrollPositionRelativeToViewOrigin());
 861 }
 862 
 863 IntPoint ScrollView::contentsToView(const IntPoint&amp; point) const
 864 {
 865     if (delegatesScrolling())
 866         return point;
 867 
 868     return point - toIntSize(documentScrollPositionRelativeToViewOrigin());
 869 }
 870 
 871 FloatPoint ScrollView::viewToContents(const FloatPoint&amp; point) const
 872 {
 873     if (delegatesScrolling())
 874         return point;
 875 
 876     return viewToContents(IntPoint(point));
 877 }
 878 
 879 FloatPoint ScrollView::contentsToView(const FloatPoint&amp; point) const
 880 {
 881     if (delegatesScrolling())
 882         return point;
 883 
 884     return contentsToView(IntPoint(point));
 885 }
 886 
 887 IntRect ScrollView::viewToContents(IntRect rect) const
 888 {
 889     if (delegatesScrolling())
 890         return rect;
 891 
 892     rect.moveBy(documentScrollPositionRelativeToViewOrigin());
 893     return rect;
 894 }
 895 
 896 FloatRect ScrollView::viewToContents(FloatRect rect) const
 897 {
 898     if (delegatesScrolling())
 899         return rect;
 900 
 901     rect.moveBy(documentScrollPositionRelativeToViewOrigin());
 902     return rect;
 903 }
 904 
 905 IntRect ScrollView::contentsToView(IntRect rect) const
 906 {
 907     if (delegatesScrolling())
 908         return rect;
 909 
 910     rect.moveBy(-documentScrollPositionRelativeToViewOrigin());
 911     return rect;
 912 }
 913 
 914 FloatRect ScrollView::contentsToView(FloatRect rect) const
 915 {
 916     if (delegatesScrolling())
 917         return rect;
 918 
 919     rect.moveBy(-documentScrollPositionRelativeToViewOrigin());
 920     return rect;
 921 }
 922 
 923 IntPoint ScrollView::contentsToContainingViewContents(const IntPoint&amp; point) const
 924 {
 925     if (const ScrollView* parentScrollView = parent()) {
 926         IntPoint pointInContainingView = convertToContainingView(contentsToView(point));
 927         return parentScrollView-&gt;viewToContents(pointInContainingView);
 928     }
 929 
 930     return contentsToView(point);
 931 }
 932 
 933 IntRect ScrollView::contentsToContainingViewContents(IntRect rect) const
 934 {
 935     if (const ScrollView* parentScrollView = parent()) {
 936         IntRect rectInContainingView = convertToContainingView(contentsToView(rect));
 937         return parentScrollView-&gt;viewToContents(rectInContainingView);
 938     }
 939 
 940     return contentsToView(rect);
 941 }
 942 
 943 IntPoint ScrollView::rootViewToContents(const IntPoint&amp; rootViewPoint) const
 944 {
 945     return viewToContents(convertFromRootView(rootViewPoint));
 946 }
 947 
 948 IntPoint ScrollView::contentsToRootView(const IntPoint&amp; contentsPoint) const
 949 {
 950     return convertToRootView(contentsToView(contentsPoint));
 951 }
 952 
 953 FloatPoint ScrollView::contentsToRootView(const FloatPoint&amp; contentsPoint) const
 954 {
 955     return convertToRootView(contentsToView(contentsPoint));
 956 }
 957 
 958 IntRect ScrollView::rootViewToContents(const IntRect&amp; rootViewRect) const
 959 {
 960     return viewToContents(convertFromRootView(rootViewRect));
 961 }
 962 
 963 FloatRect ScrollView::rootViewToContents(const FloatRect&amp; rootViewRect) const
 964 {
 965     return viewToContents(convertFromRootView(rootViewRect));
 966 }
 967 
 968 FloatRect ScrollView::contentsToRootView(const FloatRect&amp; contentsRect) const
 969 {
 970     return convertToRootView(contentsToView(contentsRect));
 971 }
 972 
 973 IntPoint ScrollView::rootViewToTotalContents(const IntPoint&amp; rootViewPoint) const
 974 {
 975     if (delegatesScrolling())
 976         return convertFromRootView(rootViewPoint);
 977 
 978     IntPoint viewPoint = convertFromRootView(rootViewPoint);
 979     // Like rootViewToContents(), but ignores headerHeight.
 980     return viewPoint + toIntSize(scrollPosition()) - IntSize(0, topContentInset(TopContentInsetType::WebCoreOrPlatformContentInset));
 981 }
 982 
 983 IntRect ScrollView::contentsToRootView(const IntRect&amp; contentsRect) const
 984 {
 985     return convertToRootView(contentsToView(contentsRect));
 986 }
 987 
 988 IntPoint ScrollView::windowToContents(const IntPoint&amp; windowPoint) const
 989 {
 990     return viewToContents(convertFromContainingWindow(windowPoint));
 991 }
 992 
 993 IntPoint ScrollView::contentsToWindow(const IntPoint&amp; contentsPoint) const
 994 {
 995     return convertToContainingWindow(contentsToView(contentsPoint));
 996 }
 997 
 998 IntRect ScrollView::windowToContents(const IntRect&amp; windowRect) const
 999 {
1000     return viewToContents(convertFromContainingWindow(windowRect));
1001 }
1002 
1003 IntRect ScrollView::contentsToWindow(const IntRect&amp; contentsRect) const
1004 {
1005     return convertToContainingWindow(contentsToView(contentsRect));
1006 }
1007 
1008 IntRect ScrollView::contentsToScreen(const IntRect&amp; rect) const
1009 {
1010     HostWindow* window = hostWindow();
1011     if (platformWidget())
1012         return platformContentsToScreen(rect);
1013     if (!window)
1014         return IntRect();
1015     return window-&gt;rootViewToScreen(contentsToRootView(rect));
1016 }
1017 
1018 IntPoint ScrollView::screenToContents(const IntPoint&amp; point) const
1019 {
1020     HostWindow* window = hostWindow();
1021     if (platformWidget())
1022         return platformScreenToContents(point);
1023     if (!window)
1024         return IntPoint();
1025     return rootViewToContents(window-&gt;screenToRootView(point));
1026 }
1027 
1028 void ScrollView::setScrollbarsSuppressed(bool suppressed, bool repaintOnUnsuppress)
1029 {
1030     if (suppressed == m_scrollbarsSuppressed)
1031         return;
1032 
1033     m_scrollbarsSuppressed = suppressed;
1034 
1035     if (platformWidget())
1036         platformSetScrollbarsSuppressed(repaintOnUnsuppress);
1037     else if (repaintOnUnsuppress &amp;&amp; !suppressed) {
1038         if (m_horizontalScrollbar)
1039             m_horizontalScrollbar-&gt;invalidate();
1040         if (m_verticalScrollbar)
1041             m_verticalScrollbar-&gt;invalidate();
1042 
1043         // Invalidate the scroll corner too on unsuppress.
1044         invalidateRect(scrollCornerRect());
1045     }
1046 }
1047 
1048 Scrollbar* ScrollView::scrollbarAtPoint(const IntPoint&amp; windowPoint)
1049 {
1050     if (platformWidget())
1051         return 0;
1052 
1053     // convertFromContainingWindow doesn&#39;t do what it sounds like it does. We need it here just to get this
1054     // point into the right coordinates if this is the ScrollView of a sub-frame.
1055     IntPoint convertedPoint = convertFromContainingWindow(windowPoint);
1056     if (m_horizontalScrollbar &amp;&amp; m_horizontalScrollbar-&gt;shouldParticipateInHitTesting() &amp;&amp; m_horizontalScrollbar-&gt;frameRect().contains(convertedPoint))
1057         return m_horizontalScrollbar.get();
1058     if (m_verticalScrollbar &amp;&amp; m_verticalScrollbar-&gt;shouldParticipateInHitTesting() &amp;&amp; m_verticalScrollbar-&gt;frameRect().contains(convertedPoint))
1059         return m_verticalScrollbar.get();
1060     return 0;
1061 }
1062 
1063 void ScrollView::setScrollbarOverlayStyle(ScrollbarOverlayStyle overlayStyle)
1064 {
1065     ScrollableArea::setScrollbarOverlayStyle(overlayStyle);
1066     platformSetScrollbarOverlayStyle(overlayStyle);
1067 }
1068 
1069 void ScrollView::setFrameRect(const IntRect&amp; newRect)
1070 {
1071     Ref&lt;ScrollView&gt; protectedThis(*this);
1072     IntRect oldRect = frameRect();
1073 
1074     if (newRect == oldRect)
1075         return;
1076 
1077     Widget::setFrameRect(newRect);
1078     frameRectsChanged();
1079 
1080     updateScrollbars(scrollPosition());
1081 
1082     if (!m_useFixedLayout &amp;&amp; oldRect.size() != newRect.size())
1083         availableContentSizeChanged(AvailableSizeChangeReason::AreaSizeChanged);
1084 }
1085 
1086 void ScrollView::frameRectsChanged()
1087 {
1088     if (platformWidget())
1089         return;
1090     for (auto&amp; child : m_children)
1091         child-&gt;frameRectsChanged();
1092 }
1093 
1094 void ScrollView::clipRectChanged()
1095 {
1096     for (auto&amp; child : m_children)
1097         child-&gt;clipRectChanged();
1098 }
1099 
1100 static void positionScrollbarLayer(GraphicsLayer* graphicsLayer, Scrollbar* scrollbar)
1101 {
1102     if (!graphicsLayer || !scrollbar)
1103         return;
1104 
1105     IntRect scrollbarRect = scrollbar-&gt;frameRect();
1106     graphicsLayer-&gt;setPosition(scrollbarRect.location());
1107 
1108     if (scrollbarRect.size() == graphicsLayer-&gt;size())
1109         return;
1110 
1111     graphicsLayer-&gt;setSize(scrollbarRect.size());
1112 
1113     if (graphicsLayer-&gt;usesContentsLayer()) {
1114         graphicsLayer-&gt;setContentsRect(IntRect(0, 0, scrollbarRect.width(), scrollbarRect.height()));
1115         return;
1116     }
1117 
1118     graphicsLayer-&gt;setDrawsContent(true);
1119     graphicsLayer-&gt;setNeedsDisplay();
1120 }
1121 
1122 static void positionScrollCornerLayer(GraphicsLayer* graphicsLayer, const IntRect&amp; cornerRect)
1123 {
1124     if (!graphicsLayer)
1125         return;
1126     graphicsLayer-&gt;setDrawsContent(!cornerRect.isEmpty());
1127     graphicsLayer-&gt;setPosition(cornerRect.location());
1128     if (cornerRect.size() != graphicsLayer-&gt;size())
1129         graphicsLayer-&gt;setNeedsDisplay();
1130     graphicsLayer-&gt;setSize(cornerRect.size());
1131 }
1132 
1133 void ScrollView::positionScrollbarLayers()
1134 {
1135     positionScrollbarLayer(layerForHorizontalScrollbar(), horizontalScrollbar());
1136     positionScrollbarLayer(layerForVerticalScrollbar(), verticalScrollbar());
1137     positionScrollCornerLayer(layerForScrollCorner(), scrollCornerRect());
1138 }
1139 
1140 void ScrollView::repaintContentRectangle(const IntRect&amp; rect)
1141 {
1142     IntRect paintRect = rect;
1143     if (!paintsEntireContents())
1144         paintRect.intersect(visibleContentRect(LegacyIOSDocumentVisibleRect));
1145     if (paintRect.isEmpty())
1146         return;
1147 
1148     if (platformWidget()) {
1149         notifyPageThatContentAreaWillPaint();
1150         platformRepaintContentRectangle(paintRect);
1151         return;
1152     }
1153 
1154     if (HostWindow* window = hostWindow())
1155         window-&gt;invalidateContentsAndRootView(contentsToWindow(paintRect));
1156 }
1157 
1158 IntRect ScrollView::scrollCornerRect() const
1159 {
1160     IntRect cornerRect;
1161 
1162     if (hasOverlayScrollbars())
1163         return cornerRect;
1164 
1165     int heightTrackedByScrollbar = height() - topContentInset();
1166 
1167     if (m_horizontalScrollbar &amp;&amp; width() - m_horizontalScrollbar-&gt;width() &gt; 0) {
1168         cornerRect.unite(IntRect(shouldPlaceBlockDirectionScrollbarOnLeft() ? 0 : m_horizontalScrollbar-&gt;width(),
1169             height() - m_horizontalScrollbar-&gt;height(),
1170             width() - m_horizontalScrollbar-&gt;width(),
1171             m_horizontalScrollbar-&gt;height()));
1172     }
1173 
1174     if (m_verticalScrollbar &amp;&amp; heightTrackedByScrollbar - m_verticalScrollbar-&gt;height() &gt; 0) {
1175         cornerRect.unite(IntRect(shouldPlaceBlockDirectionScrollbarOnLeft() ? 0 : width() - m_verticalScrollbar-&gt;width(),
1176             m_verticalScrollbar-&gt;height() + topContentInset(),
1177             m_verticalScrollbar-&gt;width(),
1178             heightTrackedByScrollbar - m_verticalScrollbar-&gt;height()));
1179     }
1180 
1181     return cornerRect;
1182 }
1183 
1184 bool ScrollView::isScrollCornerVisible() const
1185 {
1186     return !scrollCornerRect().isEmpty();
1187 }
1188 
1189 void ScrollView::scrollbarStyleChanged(ScrollbarStyle newStyle, bool forceUpdate)
1190 {
1191     ScrollableArea::scrollbarStyleChanged(newStyle, forceUpdate);
1192     if (!forceUpdate)
1193         return;
1194 
1195     updateScrollbars(scrollPosition());
1196     positionScrollbarLayers();
1197 }
1198 
1199 void ScrollView::paintScrollCorner(GraphicsContext&amp; context, const IntRect&amp; cornerRect)
1200 {
1201     ScrollbarTheme::theme().paintScrollCorner(context, cornerRect);
1202 }
1203 
1204 void ScrollView::paintScrollbar(GraphicsContext&amp; context, Scrollbar&amp; bar, const IntRect&amp; rect)
1205 {
1206     bar.paint(context, rect);
1207 }
1208 
1209 void ScrollView::invalidateScrollCornerRect(const IntRect&amp; rect)
1210 {
1211     invalidateRect(rect);
1212 }
1213 
1214 void ScrollView::paintScrollbars(GraphicsContext&amp; context, const IntRect&amp; rect)
1215 {
1216     if (m_horizontalScrollbar &amp;&amp; !layerForHorizontalScrollbar())
1217         paintScrollbar(context, *m_horizontalScrollbar.get(), rect);
1218     if (m_verticalScrollbar &amp;&amp; !layerForVerticalScrollbar())
1219         paintScrollbar(context, *m_verticalScrollbar.get(), rect);
1220 
1221     if (layerForScrollCorner())
1222         return;
1223 
1224     paintScrollCorner(context, scrollCornerRect());
1225 }
1226 
1227 void ScrollView::paintPanScrollIcon(GraphicsContext&amp; context)
1228 {
1229     static Image&amp; panScrollIcon = Image::loadPlatformResource(&quot;panIcon&quot;).leakRef();
1230     IntPoint iconGCPoint = m_panScrollIconPoint;
1231     if (parent())
1232         iconGCPoint = parent()-&gt;windowToContents(iconGCPoint);
1233     context.drawImage(panScrollIcon, iconGCPoint);
1234 }
1235 
1236 void ScrollView::paint(GraphicsContext&amp; context, const IntRect&amp; rect, SecurityOriginPaintPolicy securityOriginPaintPolicy)
1237 {
1238     if (platformWidget()) {
1239         Widget::paint(context, rect);
1240         return;
1241     }
1242 
1243     if (context.paintingDisabled() &amp;&amp; !context.performingPaintInvalidation())
1244         return;
1245 
1246     notifyPageThatContentAreaWillPaint();
1247 
1248     IntRect documentDirtyRect = rect;
1249     if (!paintsEntireContents()) {
1250         IntRect visibleAreaWithoutScrollbars(locationOfContents(), visibleContentRect(LegacyIOSDocumentVisibleRect).size());
1251         documentDirtyRect.intersect(visibleAreaWithoutScrollbars);
1252     }
1253 
1254     if (!documentDirtyRect.isEmpty()) {
1255         GraphicsContextStateSaver stateSaver(context);
1256 
1257         IntPoint locationOfContents = this-&gt;locationOfContents();
1258         context.translate(locationOfContents.x(), locationOfContents.y());
1259         documentDirtyRect.moveBy(-locationOfContents);
1260 
1261         if (!paintsEntireContents()) {
1262             context.translate(-scrollX(), -scrollY());
1263             documentDirtyRect.moveBy(scrollPosition());
1264 
1265             context.clip(visibleContentRect(LegacyIOSDocumentVisibleRect));
1266         }
1267 
1268         paintContents(context, documentDirtyRect, securityOriginPaintPolicy);
1269     }
1270 
1271 #if ENABLE(RUBBER_BANDING)
1272     if (!layerForOverhangAreas())
1273         calculateAndPaintOverhangAreas(context, rect);
1274 #else
1275     calculateAndPaintOverhangAreas(context, rect);
1276 #endif
1277 
1278     // Now paint the scrollbars.
1279     if (!m_scrollbarsSuppressed &amp;&amp; (m_horizontalScrollbar || m_verticalScrollbar)) {
1280         GraphicsContextStateSaver stateSaver(context);
1281         IntRect scrollViewDirtyRect = rect;
1282         IntRect visibleAreaWithScrollbars(location(), unobscuredContentRectIncludingScrollbars().size());
1283         scrollViewDirtyRect.intersect(visibleAreaWithScrollbars);
1284         context.translate(x(), y());
1285         scrollViewDirtyRect.moveBy(-location());
1286         context.clip(IntRect(IntPoint(), visibleAreaWithScrollbars.size()));
1287 
1288         paintScrollbars(context, scrollViewDirtyRect);
1289     }
1290 
1291     // Paint the panScroll Icon
1292     if (m_drawPanScrollIcon)
1293         paintPanScrollIcon(context);
1294 }
1295 
1296 void ScrollView::calculateOverhangAreasForPainting(IntRect&amp; horizontalOverhangRect, IntRect&amp; verticalOverhangRect)
1297 {
1298     IntSize scrollbarSpace = scrollbarIntrusion();
1299 
1300     // FIXME: use maximumScrollOffset().
1301     ScrollOffset scrollOffset = scrollOffsetFromPosition(scrollPosition());
1302     if (scrollOffset.y() &lt; 0) {
1303         horizontalOverhangRect = frameRect();
1304         horizontalOverhangRect.setHeight(-scrollOffset.y());
1305         horizontalOverhangRect.setWidth(horizontalOverhangRect.width() - scrollbarSpace.width());
1306     } else if (totalContentsSize().height() &amp;&amp; scrollOffset.y() &gt; totalContentsSize().height() - visibleHeight()) {
1307         int height = scrollOffset.y() - (totalContentsSize().height() - visibleHeight());
1308         horizontalOverhangRect = frameRect();
1309         horizontalOverhangRect.setY(frameRect().maxY() - height - scrollbarSpace.height());
1310         horizontalOverhangRect.setHeight(height);
1311         horizontalOverhangRect.setWidth(horizontalOverhangRect.width() - scrollbarSpace.width());
1312     }
1313 
1314     if (scrollOffset.x() &lt; 0) {
1315         verticalOverhangRect.setWidth(-scrollOffset.x());
1316         verticalOverhangRect.setHeight(frameRect().height() - horizontalOverhangRect.height() - scrollbarSpace.height());
1317         verticalOverhangRect.setX(frameRect().x());
1318         if (horizontalOverhangRect.y() == frameRect().y())
1319             verticalOverhangRect.setY(frameRect().y() + horizontalOverhangRect.height());
1320         else
1321             verticalOverhangRect.setY(frameRect().y());
1322     } else if (contentsWidth() &amp;&amp; scrollOffset.x() &gt; contentsWidth() - visibleWidth()) {
1323         int width = scrollOffset.x() - (contentsWidth() - visibleWidth());
1324         verticalOverhangRect.setWidth(width);
1325         verticalOverhangRect.setHeight(frameRect().height() - horizontalOverhangRect.height() - scrollbarSpace.height());
1326         verticalOverhangRect.setX(frameRect().maxX() - width - scrollbarSpace.width());
1327         if (horizontalOverhangRect.y() == frameRect().y())
1328             verticalOverhangRect.setY(frameRect().y() + horizontalOverhangRect.height());
1329         else
1330             verticalOverhangRect.setY(frameRect().y());
1331     }
1332 }
1333 
1334 void ScrollView::updateOverhangAreas()
1335 {
1336     HostWindow* window = hostWindow();
1337     if (!window)
1338         return;
1339 
1340     IntRect horizontalOverhangRect;
1341     IntRect verticalOverhangRect;
1342     calculateOverhangAreasForPainting(horizontalOverhangRect, verticalOverhangRect);
1343     if (!horizontalOverhangRect.isEmpty())
1344         window-&gt;invalidateContentsAndRootView(horizontalOverhangRect);
1345     if (!verticalOverhangRect.isEmpty())
1346         window-&gt;invalidateContentsAndRootView(verticalOverhangRect);
1347 }
1348 
1349 void ScrollView::paintOverhangAreas(GraphicsContext&amp; context, const IntRect&amp; horizontalOverhangRect, const IntRect&amp; verticalOverhangRect, const IntRect&amp; dirtyRect)
1350 {
1351     ScrollbarTheme::theme().paintOverhangAreas(*this, context, horizontalOverhangRect, verticalOverhangRect, dirtyRect);
1352 }
1353 
1354 void ScrollView::calculateAndPaintOverhangAreas(GraphicsContext&amp; context, const IntRect&amp; dirtyRect)
1355 {
1356     IntRect horizontalOverhangRect;
1357     IntRect verticalOverhangRect;
1358     calculateOverhangAreasForPainting(horizontalOverhangRect, verticalOverhangRect);
1359 
1360     if (dirtyRect.intersects(horizontalOverhangRect) || dirtyRect.intersects(verticalOverhangRect))
1361         paintOverhangAreas(context, horizontalOverhangRect, verticalOverhangRect, dirtyRect);
1362 }
1363 
1364 bool ScrollView::isPointInScrollbarCorner(const IntPoint&amp; windowPoint)
1365 {
1366     if (!scrollbarCornerPresent())
1367         return false;
1368 
1369     IntPoint viewPoint = convertFromContainingWindow(windowPoint);
1370 
1371     if (m_horizontalScrollbar) {
1372         int horizontalScrollbarYMin = m_horizontalScrollbar-&gt;frameRect().y();
1373         int horizontalScrollbarYMax = m_horizontalScrollbar-&gt;frameRect().y() + m_horizontalScrollbar-&gt;frameRect().height();
1374         int horizontalScrollbarXMin = m_horizontalScrollbar-&gt;frameRect().x() + m_horizontalScrollbar-&gt;frameRect().width();
1375 
1376         return viewPoint.y() &gt; horizontalScrollbarYMin &amp;&amp; viewPoint.y() &lt; horizontalScrollbarYMax &amp;&amp; viewPoint.x() &gt; horizontalScrollbarXMin;
1377     }
1378 
1379     int verticalScrollbarXMin = m_verticalScrollbar-&gt;frameRect().x();
1380     int verticalScrollbarXMax = m_verticalScrollbar-&gt;frameRect().x() + m_verticalScrollbar-&gt;frameRect().width();
1381     int verticalScrollbarYMin = m_verticalScrollbar-&gt;frameRect().y() + m_verticalScrollbar-&gt;frameRect().height();
1382 
1383     return viewPoint.x() &gt; verticalScrollbarXMin &amp;&amp; viewPoint.x() &lt; verticalScrollbarXMax &amp;&amp; viewPoint.y() &gt; verticalScrollbarYMin;
1384 }
1385 
1386 bool ScrollView::scrollbarCornerPresent() const
1387 {
1388     return (m_horizontalScrollbar &amp;&amp; width() - m_horizontalScrollbar-&gt;width() &gt; 0)
1389         || (m_verticalScrollbar &amp;&amp; height() - m_verticalScrollbar-&gt;height() &gt; 0);
1390 }
1391 
1392 IntRect ScrollView::convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntRect&amp; localRect) const
1393 {
1394     // Scrollbars won&#39;t be transformed within us
1395     IntRect newRect = localRect;
1396     newRect.moveBy(scrollbar.location());
1397     return newRect;
1398 }
1399 
1400 IntRect ScrollView::convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntRect&amp; parentRect) const
1401 {
1402     IntRect newRect = parentRect;
1403     // Scrollbars won&#39;t be transformed within us
1404     newRect.moveBy(-scrollbar.location());
1405     return newRect;
1406 }
1407 
1408 // FIXME: test these on windows
1409 IntPoint ScrollView::convertFromScrollbarToContainingView(const Scrollbar&amp; scrollbar, const IntPoint&amp; localPoint) const
1410 {
1411     // Scrollbars won&#39;t be transformed within us
1412     IntPoint newPoint = localPoint;
1413     newPoint.moveBy(scrollbar.location());
1414     return newPoint;
1415 }
1416 
1417 IntPoint ScrollView::convertFromContainingViewToScrollbar(const Scrollbar&amp; scrollbar, const IntPoint&amp; parentPoint) const
1418 {
1419     IntPoint newPoint = parentPoint;
1420     // Scrollbars won&#39;t be transformed within us
1421     newPoint.moveBy(-scrollbar.location());
1422     return newPoint;
1423 }
1424 
1425 void ScrollView::setParentVisible(bool visible)
1426 {
1427     if (isParentVisible() == visible)
1428         return;
1429 
1430     Widget::setParentVisible(visible);
1431 
1432     if (!isSelfVisible())
1433         return;
1434 
1435     for (auto&amp; child : m_children)
1436         child-&gt;setParentVisible(visible);
1437 }
1438 
1439 void ScrollView::show()
1440 {
1441     if (!isSelfVisible()) {
1442         setSelfVisible(true);
1443         if (isParentVisible()) {
1444             for (auto&amp; child : m_children)
1445                 child-&gt;setParentVisible(true);
1446         }
1447     }
1448 
1449     Widget::show();
1450 }
1451 
1452 void ScrollView::hide()
1453 {
1454     if (isSelfVisible()) {
1455         if (isParentVisible()) {
1456             for (auto&amp; child : m_children)
1457                 child-&gt;setParentVisible(false);
1458         }
1459         setSelfVisible(false);
1460     }
1461 
1462     Widget::hide();
1463 }
1464 
1465 bool ScrollView::isOffscreen() const
1466 {
1467     if (platformWidget())
1468         return platformIsOffscreen();
1469 
1470     if (!isVisible())
1471         return true;
1472 
1473     // FIXME: Add a HostWindow::isOffscreen method here.  Since only Mac implements this method
1474     // currently, we can add the method when the other platforms decide to implement this concept.
1475     return false;
1476 }
1477 
1478 
1479 void ScrollView::addPanScrollIcon(const IntPoint&amp; iconPosition)
1480 {
1481     HostWindow* window = hostWindow();
1482     if (!window)
1483         return;
1484     m_drawPanScrollIcon = true;
1485     m_panScrollIconPoint = IntPoint(iconPosition.x() - panIconSizeLength / 2 , iconPosition.y() - panIconSizeLength / 2) ;
1486     window-&gt;invalidateContentsAndRootView(IntRect(m_panScrollIconPoint, IntSize(panIconSizeLength, panIconSizeLength)));
1487 }
1488 
1489 void ScrollView::removePanScrollIcon()
1490 {
1491     HostWindow* window = hostWindow();
1492     if (!window)
1493         return;
1494     m_drawPanScrollIcon = false;
1495     window-&gt;invalidateContentsAndRootView(IntRect(m_panScrollIconPoint, IntSize(panIconSizeLength, panIconSizeLength)));
1496 }
1497 
1498 void ScrollView::setScrollOrigin(const IntPoint&amp; origin, bool updatePositionAtAll, bool updatePositionSynchronously)
1499 {
1500     if (scrollOrigin() == origin)
1501         return;
1502 
1503     ScrollableArea::setScrollOrigin(origin);
1504 
1505     if (platformWidget()) {
1506         platformSetScrollOrigin(origin, updatePositionAtAll, updatePositionSynchronously);
1507         return;
1508     }
1509 
1510     // Update if the scroll origin changes, since our position will be different if the content size did not change.
1511     if (updatePositionAtAll &amp;&amp; updatePositionSynchronously)
1512         updateScrollbars(scrollPosition());
1513 }
1514 
1515 void ScrollView::styleDidChange()
1516 {
1517     if (m_horizontalScrollbar)
1518         m_horizontalScrollbar-&gt;styleChanged();
1519 
1520     if (m_verticalScrollbar)
1521         m_verticalScrollbar-&gt;styleChanged();
1522 }
1523 
1524 IntPoint ScrollView::locationOfContents() const
1525 {
1526     IntPoint result = location();
1527     if (shouldPlaceBlockDirectionScrollbarOnLeft() &amp;&amp; m_verticalScrollbar)
1528         result.move(m_verticalScrollbar-&gt;occupiedWidth(), 0);
1529     return result;
1530 }
1531 
1532 #if !PLATFORM(COCOA)
1533 
1534 void ScrollView::platformAddChild(Widget*)
1535 {
1536 }
1537 
1538 void ScrollView::platformRemoveChild(Widget*)
1539 {
1540 }
1541 
1542 #endif
1543 
1544 #if !PLATFORM(COCOA)
1545 
1546 void ScrollView::platformSetScrollbarsSuppressed(bool)
1547 {
1548 }
1549 
1550 void ScrollView::platformSetScrollOrigin(const IntPoint&amp;, bool, bool)
1551 {
1552 }
1553 
1554 void ScrollView::platformSetScrollbarOverlayStyle(ScrollbarOverlayStyle)
1555 {
1556 }
1557 
1558 #endif
1559 
1560 #if !PLATFORM(COCOA)
1561 
1562 void ScrollView::platformSetScrollbarModes()
1563 {
1564 }
1565 
1566 void ScrollView::platformScrollbarModes(ScrollbarMode&amp; horizontal, ScrollbarMode&amp; vertical) const
1567 {
1568     horizontal = ScrollbarAuto;
1569     vertical = ScrollbarAuto;
1570 }
1571 
1572 void ScrollView::platformSetCanBlitOnScroll(bool)
1573 {
1574 }
1575 
1576 bool ScrollView::platformCanBlitOnScroll() const
1577 {
1578     return false;
1579 }
1580 
1581 IntRect ScrollView::platformVisibleContentRect(bool) const
1582 {
1583     return { };
1584 }
1585 
1586 float ScrollView::platformTopContentInset() const
1587 {
1588     return 0;
1589 }
1590 
1591 void ScrollView::platformSetTopContentInset(float)
1592 {
1593 }
1594 
1595 IntSize ScrollView::platformVisibleContentSize(bool) const
1596 {
1597     return { };
1598 }
1599 
1600 IntRect ScrollView::platformVisibleContentRectIncludingObscuredArea(bool) const
1601 {
1602     return { };
1603 }
1604 
1605 IntSize ScrollView::platformVisibleContentSizeIncludingObscuredArea(bool) const
1606 {
1607     return { };
1608 }
1609 
1610 IntRect ScrollView::platformUnobscuredContentRect(VisibleContentRectIncludesScrollbars) const
1611 {
1612     return { };
1613 }
1614 
1615 FloatRect ScrollView::platformExposedContentRect() const
1616 {
1617     return { };
1618 }
1619 
1620 void ScrollView::platformSetContentsSize()
1621 {
1622 }
1623 
1624 IntRect ScrollView::platformContentsToScreen(const IntRect&amp; rect) const
1625 {
1626     return rect;
1627 }
1628 
1629 IntPoint ScrollView::platformScreenToContents(const IntPoint&amp; point) const
1630 {
1631     return point;
1632 }
1633 
1634 void ScrollView::platformSetScrollPosition(const IntPoint&amp;)
1635 {
1636 }
1637 
1638 bool ScrollView::platformScroll(ScrollDirection, ScrollGranularity)
1639 {
1640     return true;
1641 }
1642 
1643 void ScrollView::platformRepaintContentRectangle(const IntRect&amp;)
1644 {
1645 }
1646 
1647 bool ScrollView::platformIsOffscreen() const
1648 {
1649     return false;
1650 }
1651 
1652 #endif
1653 
1654 }
    </pre>
  </body>
</html>
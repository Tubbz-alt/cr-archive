<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSDateMath.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSDataViewPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSDateMath.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSDateMath.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 98,34 ***</span>
  #include &lt;sys/timeb.h&gt;
  #endif
  
  namespace JSC {
  
<span class="line-removed">- using namespace WTF;</span>
<span class="line-removed">- </span>
<span class="line-removed">- static inline double timeToMS(double hour, double min, double sec, double ms)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     return (((hour * minutesPerHour + min) * secondsPerMinute + sec) * msPerSecond + ms);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- static inline int msToSeconds(double ms)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     double result = fmod(floor(ms / msPerSecond), secondsPerMinute);</span>
<span class="line-removed">-     if (result &lt; 0)</span>
<span class="line-removed">-         result += secondsPerMinute;</span>
<span class="line-removed">-     return static_cast&lt;int&gt;(result);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // 0: Sunday, 1: Monday, etc.</span>
<span class="line-removed">- static inline int msToWeekDay(double ms)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     int wd = (static_cast&lt;int&gt;(msToDays(ms)) + 4) % 7;</span>
<span class="line-removed">-     if (wd &lt; 0)</span>
<span class="line-removed">-         wd += 7;</span>
<span class="line-removed">-     return wd;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  // Get the combined UTC + DST offset for the time passed in.
  //
  // NOTE: The implementation relies on the fact that no time zones have
  // more than one daylight savings offset change per month.
  // If this function is called with NaN it returns NaN.
<span class="line-new-header">--- 98,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 150,22 ***</span>
              if (cache.offset == endOffset) {
                  // If the offset at the end of the new interval still matches
                  // the offset in the cache, we grow the cached time interval
                  // and return the offset.
                  cache.end = newEnd;
<span class="line-modified">!                 cache.increment = msPerMonth;</span>
                  return endOffset;
              }
              LocalTimeOffset offset = calculateLocalTimeOffset(ms, inputTimeType);
              if (offset == endOffset) {
                  // The offset at the given time is equal to the offset at the
                  // new end of the interval, so that means that we&#39;ve just skipped
                  // the point in time where the DST offset change occurred. Updated
                  // the interval to reflect this and reset the increment.
                  cache.start = ms;
                  cache.end = newEnd;
<span class="line-modified">!                 cache.increment = msPerMonth;</span>
              } else {
                  // The interval contains a DST offset change and the given time is
                  // before it. Adjust the increment to avoid a linear search for
                  // the offset change point and change the end of the interval.
                  cache.increment /= 3;
<span class="line-new-header">--- 126,22 ---</span>
              if (cache.offset == endOffset) {
                  // If the offset at the end of the new interval still matches
                  // the offset in the cache, we grow the cached time interval
                  // and return the offset.
                  cache.end = newEnd;
<span class="line-modified">!                 cache.increment = WTF::msPerMonth;</span>
                  return endOffset;
              }
              LocalTimeOffset offset = calculateLocalTimeOffset(ms, inputTimeType);
              if (offset == endOffset) {
                  // The offset at the given time is equal to the offset at the
                  // new end of the interval, so that means that we&#39;ve just skipped
                  // the point in time where the DST offset change occurred. Updated
                  // the interval to reflect this and reset the increment.
                  cache.start = ms;
                  cache.end = newEnd;
<span class="line-modified">!                 cache.increment = WTF::msPerMonth;</span>
              } else {
                  // The interval contains a DST offset change and the given time is
                  // before it. Adjust the increment to avoid a linear search for
                  // the offset change point and change the end of the interval.
                  cache.increment /= 3;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 182,21 ***</span>
      // computations for the same time.
      LocalTimeOffset offset = calculateLocalTimeOffset(ms, inputTimeType);
      cache.offset = offset;
      cache.start = ms;
      cache.end = ms;
<span class="line-modified">!     cache.increment = msPerMonth;</span>
      return offset;
  }
  
  double gregorianDateTimeToMS(VM&amp; vm, const GregorianDateTime&amp; t, double milliSeconds, WTF::TimeType inputTimeType)
  {
      double day = dateToDaysFrom1970(t.year(), t.month(), t.monthDay());
      double ms = timeToMS(t.hour(), t.minute(), t.second(), milliSeconds);
      double localTimeResult = (day * WTF::msPerDay) + ms;
  
<span class="line-modified">!     double localToUTCTimeOffset = inputTimeType == LocalTime</span>
          ? localTimeOffset(vm, localTimeResult, inputTimeType).offset : 0;
  
      return localTimeResult - localToUTCTimeOffset;
  }
  
<span class="line-new-header">--- 158,26 ---</span>
      // computations for the same time.
      LocalTimeOffset offset = calculateLocalTimeOffset(ms, inputTimeType);
      cache.offset = offset;
      cache.start = ms;
      cache.end = ms;
<span class="line-modified">!     cache.increment = WTF::msPerMonth;</span>
      return offset;
  }
  
<span class="line-added">+ static inline double timeToMS(double hour, double min, double sec, double ms)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return (((hour * WTF::minutesPerHour + min) * WTF::secondsPerMinute + sec) * WTF::msPerSecond + ms);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  double gregorianDateTimeToMS(VM&amp; vm, const GregorianDateTime&amp; t, double milliSeconds, WTF::TimeType inputTimeType)
  {
      double day = dateToDaysFrom1970(t.year(), t.month(), t.monthDay());
      double ms = timeToMS(t.hour(), t.minute(), t.second(), milliSeconds);
      double localTimeResult = (day * WTF::msPerDay) + ms;
  
<span class="line-modified">!     double localToUTCTimeOffset = inputTimeType == WTF::LocalTime</span>
          ? localTimeOffset(vm, localTimeResult, inputTimeType).offset : 0;
  
      return localTimeResult - localToUTCTimeOffset;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 206,59 ***</span>
      LocalTimeOffset localTime;
      if (outputTimeType == WTF::LocalTime) {
          localTime = localTimeOffset(vm, ms);
          ms += localTime.offset;
      }
<span class="line-modified">! </span>
<span class="line-removed">-     const int year = msToYear(ms);</span>
<span class="line-removed">-     tm.setSecond(msToSeconds(ms));</span>
<span class="line-removed">-     tm.setMinute(msToMinutes(ms));</span>
<span class="line-removed">-     tm.setHour(msToHours(ms));</span>
<span class="line-removed">-     tm.setWeekDay(msToWeekDay(ms));</span>
<span class="line-removed">-     tm.setYearDay(dayInYear(ms, year));</span>
<span class="line-removed">-     tm.setMonthDay(dayInMonthFromDayInYear(tm.yearDay(), isLeapYear(year)));</span>
<span class="line-removed">-     tm.setMonth(monthFromDayInYear(tm.yearDay(), isLeapYear(year)));</span>
<span class="line-removed">-     tm.setYear(year);</span>
<span class="line-removed">-     tm.setIsDST(localTime.isDST);</span>
<span class="line-removed">-     tm.setUtcOffset(localTime.offset / WTF::msPerSecond);</span>
  }
  
<span class="line-modified">! double parseDateFromNullTerminatedCharacters(VM&amp; vm, const char* dateString)</span>
  {
<span class="line-modified">!     bool haveTZ;</span>
<span class="line-modified">!     int offset;</span>
<span class="line-modified">!     double localTimeMS = WTF::parseDateFromNullTerminatedCharacters(dateString, haveTZ, offset);</span>
<span class="line-modified">!     if (std::isnan(localTimeMS))</span>
<span class="line-removed">-         return std::numeric_limits&lt;double&gt;::quiet_NaN();</span>
  
<span class="line-modified">!     // fall back to local timezone.</span>
<span class="line-modified">!     if (!haveTZ)</span>
<span class="line-removed">-         offset = localTimeOffset(vm, localTimeMS, WTF::LocalTime).offset / WTF::msPerMinute;</span>
  
<span class="line-modified">!     return localTimeMS - (offset * WTF::msPerMinute);</span>
  }
  
<span class="line-modified">! double parseDate(ExecState* exec, VM&amp; vm, const String&amp; date)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (date == vm.cachedDateString)
          return vm.cachedDateStringValue;
      auto expectedString = date.tryGetUtf8();
      if (!expectedString) {
          if (expectedString.error() == UTF8ConversionError::OutOfMemory)
<span class="line-modified">!             throwOutOfMemoryError(exec, scope);</span>
          // https://tc39.github.io/ecma262/#sec-date-objects section 20.3.3.2 states that:
          // &quot;Unrecognizable Strings or dates containing illegal element values in the
          // format String shall cause Date.parse to return NaN.&quot;
          return std::numeric_limits&lt;double&gt;::quiet_NaN();
      }
  
      auto dateUtf8 = expectedString.value();
<span class="line-modified">!     double value = parseES5DateFromNullTerminatedCharacters(dateUtf8.data());</span>
<span class="line-removed">-     if (std::isnan(value))</span>
<span class="line-removed">-         value = parseDateFromNullTerminatedCharacters(vm, dateUtf8.data());</span>
      vm.cachedDateString = date;
      vm.cachedDateStringValue = value;
      return value;
  }
  
<span class="line-new-header">--- 187,44 ---</span>
      LocalTimeOffset localTime;
      if (outputTimeType == WTF::LocalTime) {
          localTime = localTimeOffset(vm, ms);
          ms += localTime.offset;
      }
<span class="line-modified">!     tm = GregorianDateTime(ms, localTime);</span>
  }
  
<span class="line-modified">! static double parseDate(VM&amp; vm, const char* dateString)</span>
  {
<span class="line-modified">!     bool isLocalTime;</span>
<span class="line-modified">!     double value = WTF::parseES5DateFromNullTerminatedCharacters(dateString, isLocalTime);</span>
<span class="line-modified">!     if (std::isnan(value))</span>
<span class="line-modified">!         value = WTF::parseDateFromNullTerminatedCharacters(dateString, isLocalTime);</span>
  
<span class="line-modified">!     if (isLocalTime)</span>
<span class="line-modified">!         value -= localTimeOffset(vm, value, WTF::LocalTime).offset;</span>
  
<span class="line-modified">!     return value;</span>
  }
  
<span class="line-modified">! double parseDate(JSGlobalObject* globalObject, VM&amp; vm, const String&amp; date)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      if (date == vm.cachedDateString)
          return vm.cachedDateStringValue;
      auto expectedString = date.tryGetUtf8();
      if (!expectedString) {
          if (expectedString.error() == UTF8ConversionError::OutOfMemory)
<span class="line-modified">!             throwOutOfMemoryError(globalObject, scope);</span>
          // https://tc39.github.io/ecma262/#sec-date-objects section 20.3.3.2 states that:
          // &quot;Unrecognizable Strings or dates containing illegal element values in the
          // format String shall cause Date.parse to return NaN.&quot;
          return std::numeric_limits&lt;double&gt;::quiet_NaN();
      }
  
      auto dateUtf8 = expectedString.value();
<span class="line-modified">!     double value = parseDate(vm, dateUtf8.data());</span>
      vm.cachedDateString = date;
      vm.cachedDateStringValue = value;
      return value;
  }
  
</pre>
<center><a href="JSDataViewPrototype.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSDateMath.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
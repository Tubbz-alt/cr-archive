<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/Fits.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2018-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;GetPutInfo.h&quot;
 29 #include &quot;Interpreter.h&quot;
 30 #include &quot;Label.h&quot;
 31 #include &quot;OpcodeSize.h&quot;
 32 #include &quot;ProfileTypeBytecodeFlag.h&quot;
 33 #include &quot;PutByIdFlags.h&quot;
 34 #include &quot;ResultType.h&quot;
<a name="1" id="anc1"></a>
 35 #include &quot;SymbolTableOrScopeDepth.h&quot;
 36 #include &quot;VirtualRegister.h&quot;
 37 #include &lt;type_traits&gt;
 38 
 39 namespace JSC {
 40 
 41 enum FitsAssertion {
 42     Assert,
 43     NoAssert
 44 };
 45 
 46 // Fits template
 47 template&lt;typename, OpcodeSize, typename = std::true_type&gt;
 48 struct Fits;
 49 
 50 // Implicit conversion for types of the same size
 51 template&lt;typename T, OpcodeSize size&gt;
 52 struct Fits&lt;T, size, std::enable_if_t&lt;sizeof(T) == size, std::true_type&gt;&gt; {
 53     using TargetType = typename TypeBySize&lt;size&gt;::unsignedType;
 54 
 55     static bool check(T) { return true; }
 56 
 57     static TargetType convert(T t) { return bitwise_cast&lt;TargetType&gt;(t); }
 58 
 59     template&lt;class T1 = T, OpcodeSize size1 = size, typename = std::enable_if_t&lt;!std::is_same&lt;T1, TargetType&gt;::value, std::true_type&gt;&gt;
 60     static T1 convert(TargetType t) { return bitwise_cast&lt;T1&gt;(t); }
 61 };
 62 
 63 template&lt;typename T, OpcodeSize size&gt;
 64 struct Fits&lt;T, size, std::enable_if_t&lt;std::is_integral&lt;T&gt;::value &amp;&amp; sizeof(T) != size &amp;&amp; !std::is_same&lt;bool, T&gt;::value, std::true_type&gt;&gt; {
 65     using TargetType = std::conditional_t&lt;std::is_unsigned&lt;T&gt;::value, typename TypeBySize&lt;size&gt;::unsignedType, typename TypeBySize&lt;size&gt;::signedType&gt;;
 66 
 67     static bool check(T t)
 68     {
 69         return t &gt;= std::numeric_limits&lt;TargetType&gt;::min() &amp;&amp; t &lt;= std::numeric_limits&lt;TargetType&gt;::max();
 70     }
 71 
 72     static TargetType convert(T t)
 73     {
 74         ASSERT(check(t));
 75         return static_cast&lt;TargetType&gt;(t);
 76     }
 77 
 78     template&lt;class T1 = T, OpcodeSize size1 = size, typename TargetType1 = TargetType, typename = std::enable_if_t&lt;!std::is_same&lt;T1, TargetType1&gt;::value, std::true_type&gt;&gt;
 79     static T1 convert(TargetType1 t) { return static_cast&lt;T1&gt;(t); }
 80 };
 81 
 82 template&lt;OpcodeSize size&gt;
 83 struct Fits&lt;bool, size, std::enable_if_t&lt;size != sizeof(bool), std::true_type&gt;&gt; : public Fits&lt;uint8_t, size&gt; {
 84     using Base = Fits&lt;uint8_t, size&gt;;
 85 
 86     static bool check(bool e) { return Base::check(static_cast&lt;uint8_t&gt;(e)); }
 87 
 88     static typename Base::TargetType convert(bool e)
 89     {
 90         return Base::convert(static_cast&lt;uint8_t&gt;(e));
 91     }
 92 
 93     static bool convert(typename Base::TargetType e)
 94     {
 95         return Base::convert(e);
 96     }
 97 };
 98 
 99 template&lt;OpcodeSize size&gt;
100 struct FirstConstant;
101 
102 template&lt;&gt;
103 struct FirstConstant&lt;OpcodeSize::Narrow&gt; {
104     static constexpr int index = FirstConstantRegisterIndex8;
105 };
106 
107 template&lt;&gt;
108 struct FirstConstant&lt;OpcodeSize::Wide16&gt; {
109     static constexpr int index = FirstConstantRegisterIndex16;
110 };
111 
112 template&lt;OpcodeSize size&gt;
113 struct Fits&lt;VirtualRegister, size, std::enable_if_t&lt;size != OpcodeSize::Wide32, std::true_type&gt;&gt; {
114     // Narrow:
115     // -128..-1  local variables
116     //    0..15  arguments
117     //   16..127 constants
118     //
119     // Wide16:
120     // -2**15..-1  local variables
121     //      0..64  arguments
122     //     64..2**15-1 constants
123 
124     using TargetType = typename TypeBySize&lt;size&gt;::signedType;
125 
126     static constexpr int s_firstConstantIndex = FirstConstant&lt;size&gt;::index;
127     static bool check(VirtualRegister r)
128     {
129         if (r.isConstant())
130             return (s_firstConstantIndex + r.toConstantIndex()) &lt;= std::numeric_limits&lt;TargetType&gt;::max();
131         return r.offset() &gt;= std::numeric_limits&lt;TargetType&gt;::min() &amp;&amp; r.offset() &lt; s_firstConstantIndex;
132     }
133 
134     static TargetType convert(VirtualRegister r)
135     {
136         ASSERT(check(r));
137         if (r.isConstant())
138             return static_cast&lt;TargetType&gt;(s_firstConstantIndex + r.toConstantIndex());
139         return static_cast&lt;TargetType&gt;(r.offset());
140     }
141 
142     static VirtualRegister convert(TargetType u)
143     {
144         int i = static_cast&lt;int&gt;(static_cast&lt;TargetType&gt;(u));
145         if (i &gt;= s_firstConstantIndex)
146             return VirtualRegister { (i - s_firstConstantIndex) + FirstConstantRegisterIndex };
147         return VirtualRegister { i };
148     }
149 };
150 
151 template&lt;OpcodeSize size&gt;
152 struct Fits&lt;SymbolTableOrScopeDepth, size, std::enable_if_t&lt;size != OpcodeSize::Wide32, std::true_type&gt;&gt; : public Fits&lt;unsigned, size&gt; {
153     static_assert(sizeof(SymbolTableOrScopeDepth) == sizeof(unsigned));
154     using TargetType = typename TypeBySize&lt;size&gt;::unsignedType;
155     using Base = Fits&lt;unsigned, size&gt;;
156 
157     static bool check(SymbolTableOrScopeDepth u) { return Base::check(u.raw()); }
158 
159     static TargetType convert(SymbolTableOrScopeDepth u)
160     {
161         return Base::convert(u.raw());
162     }
163 
164     static SymbolTableOrScopeDepth convert(TargetType u)
165     {
166         return SymbolTableOrScopeDepth::raw(Base::convert(u));
167     }
168 };
169 
170 template&lt;OpcodeSize size&gt;
171 struct Fits&lt;GetPutInfo, size, std::enable_if_t&lt;size != OpcodeSize::Wide32, std::true_type&gt;&gt; {
172     using TargetType = typename TypeBySize&lt;size&gt;::unsignedType;
173 
174     // 13 Resolve Types
175     // 3 Initialization Modes
176     // 2 Resolve Modes
177     //
178     // Try to encode encode as
179     //
180     //           initialization mode
181     //                    v
182     // free bit-&gt; 0|0000|00|0
183     //                 ^    ^
184     //    resolve  type   resolve mode
185     static constexpr int s_resolveTypeMax = 1 &lt;&lt; 4;
186     static constexpr int s_initializationModeMax = 1 &lt;&lt; 2;
187     static constexpr int s_resolveModeMax = 1 &lt;&lt; 1;
188 
189     static constexpr int s_resolveTypeBits = (s_resolveTypeMax - 1) &lt;&lt; 3;
190     static constexpr int s_initializationModeBits = (s_initializationModeMax - 1) &lt;&lt; 1;
191     static constexpr int s_resolveModeBits = (s_resolveModeMax - 1);
192 
193     static_assert(!(s_resolveTypeBits &amp; s_initializationModeBits &amp; s_resolveModeBits), &quot;There should be no intersection between ResolveMode, ResolveType and InitializationMode&quot;);
194 
195     static bool check(GetPutInfo gpi)
196     {
197         auto resolveType = static_cast&lt;int&gt;(gpi.resolveType());
198         auto initializationMode = static_cast&lt;int&gt;(gpi.initializationMode());
199         auto resolveMode = static_cast&lt;int&gt;(gpi.resolveMode());
200         return resolveType &lt; s_resolveTypeMax &amp;&amp; initializationMode &lt; s_initializationModeMax &amp;&amp; resolveMode &lt; s_resolveModeMax;
201     }
202 
203     static TargetType convert(GetPutInfo gpi)
204     {
205         ASSERT(check(gpi));
206         auto resolveType = static_cast&lt;uint8_t&gt;(gpi.resolveType());
207         auto initializationMode = static_cast&lt;uint8_t&gt;(gpi.initializationMode());
208         auto resolveMode = static_cast&lt;uint8_t&gt;(gpi.resolveMode());
209         return (resolveType &lt;&lt; 3) | (initializationMode &lt;&lt; 1) | resolveMode;
210     }
211 
212     static GetPutInfo convert(TargetType gpi)
213     {
214         auto resolveType = static_cast&lt;ResolveType&gt;((gpi &amp; s_resolveTypeBits) &gt;&gt; 3);
215         auto initializationMode = static_cast&lt;InitializationMode&gt;((gpi &amp; s_initializationModeBits) &gt;&gt; 1);
216         auto resolveMode = static_cast&lt;ResolveMode&gt;(gpi &amp; s_resolveModeBits);
217         return GetPutInfo(resolveMode, resolveType, initializationMode);
218     }
219 };
220 
221 template&lt;typename E, OpcodeSize size&gt;
222 struct Fits&lt;E, size, std::enable_if_t&lt;sizeof(E) != size &amp;&amp; std::is_enum&lt;E&gt;::value, std::true_type&gt;&gt; : public Fits&lt;std::underlying_type_t&lt;E&gt;, size&gt; {
223     using Base = Fits&lt;std::underlying_type_t&lt;E&gt;, size&gt;;
224 
225     static bool check(E e) { return Base::check(static_cast&lt;std::underlying_type_t&lt;E&gt;&gt;(e)); }
226 
227     static typename Base::TargetType convert(E e)
228     {
229         return Base::convert(static_cast&lt;std::underlying_type_t&lt;E&gt;&gt;(e));
230     }
231 
232     static E convert(typename Base::TargetType e)
233     {
234         return static_cast&lt;E&gt;(Base::convert(e));
235     }
236 };
237 
<a name="2" id="anc2"></a><span class="line-added">238 template&lt;OpcodeSize size&gt;</span>
<span class="line-added">239 struct Fits&lt;ResultType, size, std::enable_if_t&lt;sizeof(ResultType) != size, std::true_type&gt;&gt; : public Fits&lt;uint8_t, size&gt; {</span>
<span class="line-added">240     static_assert(sizeof(ResultType) == sizeof(uint8_t));</span>
<span class="line-added">241     using Base = Fits&lt;uint8_t, size&gt;;</span>
<span class="line-added">242 </span>
<span class="line-added">243     static bool check(ResultType type) { return Base::check(type.bits()); }</span>
<span class="line-added">244 </span>
<span class="line-added">245     static typename Base::TargetType convert(ResultType type) { return Base::convert(type.bits()); }</span>
<span class="line-added">246 </span>
<span class="line-added">247     static ResultType convert(typename Base::TargetType type) { return ResultType(Base::convert(type)); }</span>
<span class="line-added">248 };</span>
<span class="line-added">249 </span>
250 template&lt;OpcodeSize size&gt;
251 struct Fits&lt;OperandTypes, size, std::enable_if_t&lt;sizeof(OperandTypes) != size, std::true_type&gt;&gt; {
252     static_assert(sizeof(OperandTypes) == sizeof(uint16_t));
253     using TargetType = typename TypeBySize&lt;size&gt;::unsignedType;
254 
255     // a pair of (ResultType::Type, ResultType::Type) - try to fit each type into 4 bits
256     // additionally, encode unknown types as 0 rather than the | of all types
257     static constexpr unsigned typeWidth = 4;
258     static constexpr unsigned maxType = (1 &lt;&lt; typeWidth) - 1;
259 
260     static bool check(OperandTypes types)
261     {
262         if (size == OpcodeSize::Narrow) {
263             auto first = types.first().bits();
264             auto second = types.second().bits();
265             if (first == ResultType::unknownType().bits())
266                 first = 0;
267             if (second == ResultType::unknownType().bits())
268                 second = 0;
269             return first &lt;= maxType &amp;&amp; second &lt;= maxType;
270         }
271         return true;
272     }
273 
274     static TargetType convert(OperandTypes types)
275     {
276         if (size == OpcodeSize::Narrow) {
277             ASSERT(check(types));
278             auto first = types.first().bits();
279             auto second = types.second().bits();
280             if (first == ResultType::unknownType().bits())
281                 first = 0;
282             if (second == ResultType::unknownType().bits())
283                 second = 0;
284             return (first &lt;&lt; typeWidth) | second;
285         }
286         return static_cast&lt;TargetType&gt;(types.bits());
287     }
288 
289     static OperandTypes convert(TargetType types)
290     {
291         if (size == OpcodeSize::Narrow) {
292             auto first = types &gt;&gt; typeWidth;
293             auto second = types &amp; maxType;
294             if (!first)
295                 first = ResultType::unknownType().bits();
296             if (!second)
297                 second = ResultType::unknownType().bits();
298             return OperandTypes(ResultType(first), ResultType(second));
299         }
300         return OperandTypes::fromBits(static_cast&lt;uint16_t&gt;(types));
301     }
302 };
303 
<a name="3" id="anc3"></a><span class="line-modified">304 template&lt;OpcodeSize size, typename GeneratorTraits&gt;</span>
<span class="line-modified">305 struct Fits&lt;GenericBoundLabel&lt;GeneratorTraits&gt;, size&gt; : public Fits&lt;int, size&gt; {</span>
306     // This is a bit hacky: we need to delay computing jump targets, since we
307     // might have to emit `nop`s to align the instructions stream. Additionally,
308     // we have to compute the target before we start writing to the instruction
309     // stream, since the offset is computed from the start of the bytecode. We
310     // achieve this by computing the target when we `check` and saving it, then
311     // later we use the saved target when we call convert.
312 
313     using Base = Fits&lt;int, size&gt;;
<a name="4" id="anc4"></a><span class="line-modified">314     static bool check(GenericBoundLabel&lt;GeneratorTraits&gt;&amp; label)</span>
315     {
316         return Base::check(label.saveTarget());
317     }
318 
<a name="5" id="anc5"></a><span class="line-modified">319     static typename Base::TargetType convert(GenericBoundLabel&lt;GeneratorTraits&gt;&amp; label)</span>
320     {
321         return Base::convert(label.commitTarget());
322     }
323 
<a name="6" id="anc6"></a><span class="line-modified">324     static GenericBoundLabel&lt;GeneratorTraits&gt; convert(typename Base::TargetType target)</span>
325     {
<a name="7" id="anc7"></a><span class="line-modified">326         return GenericBoundLabel&lt;GeneratorTraits&gt;(Base::convert(target));</span>
327     }
328 };
329 
330 } // namespace JSC
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/MathExtras.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Markable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MediaTime.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/MathExtras.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
547 
548 // Pass ranges with the min being inclusive and the max being exclusive. For example, this should
549 // return false:
550 //
551 //     rangesOverlap(0, 8, 8, 16)
552 template&lt;typename T&gt;
553 inline bool rangesOverlap(T leftMin, T leftMax, T rightMin, T rightMax)
554 {
555     ASSERT(leftMin &lt;= leftMax);
556     ASSERT(rightMin &lt;= rightMax);
557 
558     // Empty ranges interfere with nothing.
559     if (leftMin == leftMax)
560         return false;
561     if (rightMin == rightMax)
562         return false;
563 
564     return nonEmptyRangesOverlap(leftMin, leftMax, rightMin, rightMax);
565 }
566 
<span class="line-removed">567 // This mask is not necessarily the minimal mask, specifically if size is</span>
<span class="line-removed">568 // a power of 2. It has the advantage that it&#39;s fast to compute, however.</span>
<span class="line-removed">569 inline uint32_t computeIndexingMask(uint32_t size)</span>
<span class="line-removed">570 {</span>
<span class="line-removed">571     return static_cast&lt;uint64_t&gt;(static_cast&lt;uint32_t&gt;(-1)) &gt;&gt; std::clz(size);</span>
<span class="line-removed">572 }</span>
<span class="line-removed">573 </span>
<span class="line-removed">574 constexpr unsigned preciseIndexMaskShiftForSize(unsigned size)</span>
<span class="line-removed">575 {</span>
<span class="line-removed">576     return size * 8 - 1;</span>
<span class="line-removed">577 }</span>
<span class="line-removed">578 </span>
<span class="line-removed">579 template&lt;typename T&gt;</span>
<span class="line-removed">580 constexpr unsigned preciseIndexMaskShift()</span>
<span class="line-removed">581 {</span>
<span class="line-removed">582     return preciseIndexMaskShiftForSize(sizeof(T));</span>
<span class="line-removed">583 }</span>
<span class="line-removed">584 </span>
<span class="line-removed">585 template&lt;typename T&gt;</span>
<span class="line-removed">586 T opaque(T pointer)</span>
<span class="line-removed">587 {</span>
<span class="line-removed">588 #if !OS(WINDOWS)</span>
<span class="line-removed">589     asm(&quot;&quot; : &quot;+r&quot;(pointer));</span>
<span class="line-removed">590 #endif</span>
<span class="line-removed">591     return pointer;</span>
<span class="line-removed">592 }</span>
<span class="line-removed">593 </span>
<span class="line-removed">594 // This masks the given pointer with 0xffffffffffffffff (ptrwidth) if `index &lt;</span>
<span class="line-removed">595 // length`. Otherwise, it masks the pointer with 0. Similar to Linux kernel&#39;s array_ptr.</span>
<span class="line-removed">596 template&lt;typename T&gt;</span>
<span class="line-removed">597 inline T* preciseIndexMaskPtr(uintptr_t index, uintptr_t length, T* value)</span>
<span class="line-removed">598 {</span>
<span class="line-removed">599     uintptr_t result = bitwise_cast&lt;uintptr_t&gt;(value) &amp; static_cast&lt;uintptr_t&gt;(</span>
<span class="line-removed">600         static_cast&lt;intptr_t&gt;(index - opaque(length)) &gt;&gt;</span>
<span class="line-removed">601         static_cast&lt;intptr_t&gt;(preciseIndexMaskShift&lt;T*&gt;()));</span>
<span class="line-removed">602     return bitwise_cast&lt;T*&gt;(result);</span>
<span class="line-removed">603 }</span>
<span class="line-removed">604 </span>
605 template&lt;typename VectorType, typename RandomFunc&gt;
606 void shuffleVector(VectorType&amp; vector, size_t size, const RandomFunc&amp; randomFunc)
607 {
608     for (size_t i = 0; i + 1 &lt; size; ++i)
609         std::swap(vector[i], vector[i + randomFunc(size - i)]);
610 }
611 
612 template&lt;typename VectorType, typename RandomFunc&gt;
613 void shuffleVector(VectorType&amp; vector, const RandomFunc&amp; randomFunc)
614 {
615     shuffleVector(vector, vector.size(), randomFunc);
616 }
617 
618 template &lt;typename T&gt;
619 constexpr unsigned clzConstexpr(T value)
620 {
621     constexpr unsigned bitSize = sizeof(T) * CHAR_BIT;
622 
623     using UT = typename std::make_unsigned&lt;T&gt;::type;
624     UT uValue = value;
</pre>
<hr />
<pre>
718 }
719 
720 template&lt;typename T&gt;
721 inline unsigned getMSBSet(T t)
722 {
723     constexpr unsigned bitSize = sizeof(T) * CHAR_BIT;
724     ASSERT(t);
725     return bitSize - 1 - clz(t);
726 }
727 
728 template&lt;typename T&gt;
729 constexpr unsigned getMSBSetConstexpr(T t)
730 {
731     constexpr unsigned bitSize = sizeof(T) * CHAR_BIT;
732     ASSERT_UNDER_CONSTEXPR_CONTEXT(t);
733     return bitSize - 1 - clzConstexpr(t);
734 }
735 
736 } // namespace WTF
737 
<span class="line-removed">738 using WTF::opaque;</span>
<span class="line-removed">739 using WTF::preciseIndexMaskPtr;</span>
<span class="line-removed">740 using WTF::preciseIndexMaskShift;</span>
<span class="line-removed">741 using WTF::preciseIndexMaskShiftForSize;</span>
742 using WTF::shuffleVector;
743 using WTF::clz;
744 using WTF::ctz;
745 using WTF::getLSBSet;
746 using WTF::getMSBSet;
</pre>
</td>
<td>
<hr />
<pre>
547 
548 // Pass ranges with the min being inclusive and the max being exclusive. For example, this should
549 // return false:
550 //
551 //     rangesOverlap(0, 8, 8, 16)
552 template&lt;typename T&gt;
553 inline bool rangesOverlap(T leftMin, T leftMax, T rightMin, T rightMax)
554 {
555     ASSERT(leftMin &lt;= leftMax);
556     ASSERT(rightMin &lt;= rightMax);
557 
558     // Empty ranges interfere with nothing.
559     if (leftMin == leftMax)
560         return false;
561     if (rightMin == rightMax)
562         return false;
563 
564     return nonEmptyRangesOverlap(leftMin, leftMax, rightMin, rightMax);
565 }
566 






































567 template&lt;typename VectorType, typename RandomFunc&gt;
568 void shuffleVector(VectorType&amp; vector, size_t size, const RandomFunc&amp; randomFunc)
569 {
570     for (size_t i = 0; i + 1 &lt; size; ++i)
571         std::swap(vector[i], vector[i + randomFunc(size - i)]);
572 }
573 
574 template&lt;typename VectorType, typename RandomFunc&gt;
575 void shuffleVector(VectorType&amp; vector, const RandomFunc&amp; randomFunc)
576 {
577     shuffleVector(vector, vector.size(), randomFunc);
578 }
579 
580 template &lt;typename T&gt;
581 constexpr unsigned clzConstexpr(T value)
582 {
583     constexpr unsigned bitSize = sizeof(T) * CHAR_BIT;
584 
585     using UT = typename std::make_unsigned&lt;T&gt;::type;
586     UT uValue = value;
</pre>
<hr />
<pre>
680 }
681 
682 template&lt;typename T&gt;
683 inline unsigned getMSBSet(T t)
684 {
685     constexpr unsigned bitSize = sizeof(T) * CHAR_BIT;
686     ASSERT(t);
687     return bitSize - 1 - clz(t);
688 }
689 
690 template&lt;typename T&gt;
691 constexpr unsigned getMSBSetConstexpr(T t)
692 {
693     constexpr unsigned bitSize = sizeof(T) * CHAR_BIT;
694     ASSERT_UNDER_CONSTEXPR_CONTEXT(t);
695     return bitSize - 1 - clzConstexpr(t);
696 }
697 
698 } // namespace WTF
699 




700 using WTF::shuffleVector;
701 using WTF::clz;
702 using WTF::ctz;
703 using WTF::getLSBSet;
704 using WTF::getMSBSet;
</pre>
</td>
</tr>
</table>
<center><a href="Markable.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="MediaTime.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
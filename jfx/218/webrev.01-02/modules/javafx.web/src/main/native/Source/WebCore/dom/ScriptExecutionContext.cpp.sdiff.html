<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/dom/ScriptExecutionContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ScriptElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptExecutionContext.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/dom/ScriptExecutionContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  *
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;ScriptExecutionContext.h&quot;
 30 
 31 #include &quot;CachedScript.h&quot;
 32 #include &quot;CommonVM.h&quot;
 33 #include &quot;DOMTimer.h&quot;
 34 #include &quot;DOMWindow.h&quot;
 35 #include &quot;DatabaseContext.h&quot;
 36 #include &quot;Document.h&quot;
 37 #include &quot;ErrorEvent.h&quot;
 38 #include &quot;JSDOMExceptionHandling.h&quot;
 39 #include &quot;JSDOMWindow.h&quot;

 40 #include &quot;MessagePort.h&quot;
 41 #include &quot;Navigator.h&quot;
 42 #include &quot;Page.h&quot;
 43 #include &quot;PublicURLManager.h&quot;
 44 #include &quot;RejectedPromiseTracker.h&quot;
 45 #include &quot;ResourceRequest.h&quot;
 46 #include &quot;SWClientConnection.h&quot;
 47 #include &quot;SWContextManager.h&quot;
<span class="line-removed"> 48 #include &quot;SchemeRegistry.h&quot;</span>
 49 #include &quot;ScriptController.h&quot;
 50 #include &quot;ScriptDisallowedScope.h&quot;
 51 #include &quot;ScriptState.h&quot;
 52 #include &quot;ServiceWorker.h&quot;
 53 #include &quot;ServiceWorkerGlobalScope.h&quot;
 54 #include &quot;ServiceWorkerProvider.h&quot;
 55 #include &quot;Settings.h&quot;
 56 #include &quot;WorkerGlobalScope.h&quot;
 57 #include &quot;WorkerNavigator.h&quot;
 58 #include &quot;WorkerThread.h&quot;
 59 #include &quot;WorkletGlobalScope.h&quot;
 60 #include &quot;WorkletScriptController.h&quot;
 61 #include &lt;JavaScriptCore/CatchScope.h&gt;
 62 #include &lt;JavaScriptCore/Exception.h&gt;
 63 #include &lt;JavaScriptCore/JSPromise.h&gt;
 64 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 65 #include &lt;JavaScriptCore/StrongInlines.h&gt;
 66 #include &lt;wtf/MainThread.h&gt;
 67 #include &lt;wtf/Ref.h&gt;
 68 #include &lt;wtf/SetForScope.h&gt;
</pre>
<hr />
<pre>
106     if (!m_contextIdentifier) {
107         Locker&lt;Lock&gt; locker(allScriptExecutionContextsMapLock);
108 
109         m_contextIdentifier = ScriptExecutionContextIdentifier::generate();
110 
111         ASSERT(!allScriptExecutionContextsMap().contains(m_contextIdentifier));
112         allScriptExecutionContextsMap().add(m_contextIdentifier, const_cast&lt;ScriptExecutionContext*&gt;(this));
113     }
114     return m_contextIdentifier;
115 }
116 
117 void ScriptExecutionContext::removeFromContextsMap()
118 {
119     if (m_contextIdentifier) {
120         Locker&lt;Lock&gt; locker(allScriptExecutionContextsMapLock);
121         ASSERT(allScriptExecutionContextsMap().contains(m_contextIdentifier));
122         allScriptExecutionContextsMap().remove(m_contextIdentifier);
123     }
124 }
125 
<span class="line-modified">126 #if ASSERT_DISABLED</span>
127 
128 inline void ScriptExecutionContext::checkConsistency() const
129 {
130 }
131 
<span class="line-modified">132 #else</span>
133 
134 void ScriptExecutionContext::checkConsistency() const
135 {
136     for (auto* messagePort : m_messagePorts)
137         ASSERT(messagePort-&gt;scriptExecutionContext() == this);
138 
139     for (auto* destructionObserver : m_destructionObservers)
140         ASSERT(destructionObserver-&gt;scriptExecutionContext() == this);
141 
142     for (auto* activeDOMObject : m_activeDOMObjects) {
143         ASSERT(activeDOMObject-&gt;scriptExecutionContext() == this);
144         activeDOMObject-&gt;assertSuspendIfNeededWasCalled();
145     }
146 }
147 
<span class="line-modified">148 #endif</span>
149 
150 ScriptExecutionContext::~ScriptExecutionContext()
151 {
152     checkConsistency();
153 
<span class="line-modified">154 #if !ASSERT_DISABLED</span>
155     if (m_contextIdentifier) {
156         Locker&lt;Lock&gt; locker(allScriptExecutionContextsMapLock);
157         ASSERT_WITH_MESSAGE(!allScriptExecutionContextsMap().contains(m_contextIdentifier),
158             &quot;A ScriptExecutionContext subclass instance implementing postTask should have already removed itself from the map&quot;);
159     }
160 
161     m_inScriptExecutionContextDestructor = true;
<span class="line-modified">162 #endif</span>
163 
164 #if ENABLE(SERVICE_WORKER)
165     setActiveServiceWorker(nullptr);
166 #endif
167 
168     while (auto* destructionObserver = m_destructionObservers.takeAny())
169         destructionObserver-&gt;contextDestroyed();
170 
<span class="line-modified">171 #if !ASSERT_DISABLED</span>
172     m_inScriptExecutionContextDestructor = false;
173 #endif
174 }
175 
176 void ScriptExecutionContext::processMessageWithMessagePortsSoon()
177 {
178     if (m_willprocessMessageWithMessagePortsSoon)
179         return;
180 
181     m_willprocessMessageWithMessagePortsSoon = true;
182     postTask([] (ScriptExecutionContext&amp; context) {
183         context.dispatchMessagePortEvents();
184     });
185 }
186 
187 void ScriptExecutionContext::dispatchMessagePortEvents()
188 {
189     checkConsistency();
190 
191     Ref&lt;ScriptExecutionContext&gt; protectedThis(*this);
</pre>
<hr />
<pre>
205 void ScriptExecutionContext::createdMessagePort(MessagePort&amp; messagePort)
206 {
207     ASSERT((is&lt;Document&gt;(*this) &amp;&amp; isMainThread())
208         || (is&lt;WorkerGlobalScope&gt;(*this) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*this).thread().thread() == &amp;Thread::current()));
209 
210     m_messagePorts.add(&amp;messagePort);
211 }
212 
213 void ScriptExecutionContext::destroyedMessagePort(MessagePort&amp; messagePort)
214 {
215     ASSERT((is&lt;Document&gt;(*this) &amp;&amp; isMainThread())
216         || (is&lt;WorkerGlobalScope&gt;(*this) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*this).thread().thread() == &amp;Thread::current()));
217 
218     m_messagePorts.remove(&amp;messagePort);
219 }
220 
221 void ScriptExecutionContext::didLoadResourceSynchronously()
222 {
223 }
224 
<span class="line-removed">225 bool ScriptExecutionContext::canSuspendActiveDOMObjectsForDocumentSuspension(Vector&lt;ActiveDOMObject*&gt;* unsuspendableObjects)</span>
<span class="line-removed">226 {</span>
<span class="line-removed">227     checkConsistency();</span>
<span class="line-removed">228 </span>
<span class="line-removed">229     bool canSuspend = true;</span>
<span class="line-removed">230 </span>
<span class="line-removed">231     forEachActiveDOMObject([&amp;](auto&amp; activeDOMObject) {</span>
<span class="line-removed">232         if (!activeDOMObject.canSuspendForDocumentSuspension()) {</span>
<span class="line-removed">233             canSuspend = false;</span>
<span class="line-removed">234             if (unsuspendableObjects)</span>
<span class="line-removed">235                 unsuspendableObjects-&gt;append(&amp;activeDOMObject);</span>
<span class="line-removed">236             else</span>
<span class="line-removed">237                 return ShouldContinue::No;</span>
<span class="line-removed">238         }</span>
<span class="line-removed">239         return ShouldContinue::Yes;</span>
<span class="line-removed">240     });</span>
<span class="line-removed">241 </span>
<span class="line-removed">242     if (unsuspendableObjects) {</span>
<span class="line-removed">243         // Remove activeDOMObjects that have been destroyed while we were iterating above.</span>
<span class="line-removed">244         unsuspendableObjects-&gt;removeAllMatching([&amp;](auto* activeDOMObject) {</span>
<span class="line-removed">245             return !m_activeDOMObjects.contains(activeDOMObject);</span>
<span class="line-removed">246         });</span>
<span class="line-removed">247     }</span>
<span class="line-removed">248 </span>
<span class="line-removed">249     return canSuspend;</span>
<span class="line-removed">250 }</span>
<span class="line-removed">251 </span>
252 void ScriptExecutionContext::forEachActiveDOMObject(const Function&lt;ShouldContinue(ActiveDOMObject&amp;)&gt;&amp; apply) const
253 {
254     // It is not allowed to run arbitrary script or construct new ActiveDOMObjects while we are iterating over ActiveDOMObjects.
255     // An ASSERT_WITH_SECURITY_IMPLICATION or RELEASE_ASSERT will fire if this happens, but it&#39;s important to code
<span class="line-modified">256     // canSuspendActiveDOMObjectsForDocumentSuspension() / suspend() / resume() / stop() functions so it will not happen!</span>
257     ScriptDisallowedScope scriptDisallowedScope;
258     SetForScope&lt;bool&gt; activeDOMObjectAdditionForbiddenScope(m_activeDOMObjectAdditionForbidden, true);
259 
260     // Make a frozen copy of the objects so we can iterate while new ones might be destroyed.
261     auto possibleActiveDOMObjects = copyToVector(m_activeDOMObjects);
262 
263     for (auto* activeDOMObject : possibleActiveDOMObjects) {
264         // Check if this object was deleted already. If so, just skip it.
265         // Calling contains on a possibly-already-deleted object is OK because we guarantee
266         // no new object can be added, so even if a new object ends up allocated with the
267         // same address, that will be *after* this function exits.
268         if (!m_activeDOMObjects.contains(activeDOMObject))
269             continue;
270 
271         if (apply(*activeDOMObject) == ShouldContinue::No)
272             break;
273     }
274 }
275 
276 void ScriptExecutionContext::suspendActiveDOMObjects(ReasonForSuspension why)
277 {
278     checkConsistency();
279 
280     if (m_activeDOMObjectsAreSuspended) {
<span class="line-modified">281         // A page may subsequently suspend DOM objects, say as part of entering the page cache, after the embedding</span>
282         // client requested the page be suspended. We ignore such requests so long as the embedding client requested
283         // the suspension first. See &lt;rdar://problem/13754896&gt; for more details.
284         ASSERT(m_reasonForSuspendingActiveDOMObjects == ReasonForSuspension::PageWillBeSuspended);
285         return;
286     }
287 
288     m_activeDOMObjectsAreSuspended = true;
289 
290     forEachActiveDOMObject([why](auto&amp; activeDOMObject) {
291         activeDOMObject.suspend(why);
292         return ShouldContinue::Yes;
293     });
294 
295     m_reasonForSuspendingActiveDOMObjects = why;
296 }
297 
298 void ScriptExecutionContext::resumeActiveDOMObjects(ReasonForSuspension why)
299 {
300     checkConsistency();
301 
302     if (m_reasonForSuspendingActiveDOMObjects != why)
303         return;
<span class="line-removed">304     m_activeDOMObjectsAreSuspended = false;</span>
305 
306     forEachActiveDOMObject([](auto&amp; activeDOMObject) {
307         activeDOMObject.resume();
308         return ShouldContinue::Yes;
309     });
310 
<span class="line-modified">311     // In case there were pending messages at the time the script execution context entered PageCache,</span>
<span class="line-modified">312     // make sure those get dispatched shortly after restoring from PageCache.</span>


313     processMessageWithMessagePortsSoon();
314 }
315 
316 void ScriptExecutionContext::stopActiveDOMObjects()
317 {
318     checkConsistency();
319 
320     if (m_activeDOMObjectsAreStopped)
321         return;
322     m_activeDOMObjectsAreStopped = true;
323 
324     forEachActiveDOMObject([](auto&amp; activeDOMObject) {
325         activeDOMObject.stop();
326         return ShouldContinue::Yes;
327     });
328 }
329 
330 void ScriptExecutionContext::suspendActiveDOMObjectIfNeeded(ActiveDOMObject&amp; activeDOMObject)
331 {
332     ASSERT(m_activeDOMObjects.contains(&amp;activeDOMObject));
</pre>
<hr />
<pre>
379 {
380     if (m_inDispatchErrorEvent) {
381         if (!m_pendingExceptions)
382             m_pendingExceptions = makeUnique&lt;Vector&lt;std::unique_ptr&lt;PendingException&gt;&gt;&gt;();
383         m_pendingExceptions-&gt;append(makeUnique&lt;PendingException&gt;(errorMessage, lineNumber, columnNumber, sourceURL, WTFMove(callStack)));
384         return;
385     }
386 
387     // First report the original exception and only then all the nested ones.
388     if (!dispatchErrorEvent(errorMessage, lineNumber, columnNumber, sourceURL, exception, cachedScript))
389         logExceptionToConsole(errorMessage, sourceURL, lineNumber, columnNumber, callStack.copyRef());
390 
391     if (!m_pendingExceptions)
392         return;
393 
394     auto pendingExceptions = WTFMove(m_pendingExceptions);
395     for (auto&amp; exception : *pendingExceptions)
396         logExceptionToConsole(exception-&gt;m_errorMessage, exception-&gt;m_sourceURL, exception-&gt;m_lineNumber, exception-&gt;m_columnNumber, WTFMove(exception-&gt;m_callStack));
397 }
398 
<span class="line-modified">399 void ScriptExecutionContext::reportUnhandledPromiseRejection(JSC::ExecState&amp; state, JSC::JSPromise&amp; promise, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack)</span>
400 {
401     Page* page = nullptr;
402     if (is&lt;Document&gt;(this))
403         page = downcast&lt;Document&gt;(this)-&gt;page();
404     // FIXME: allow Workers to mute unhandled promise rejection messages.
405 
406     if (page &amp;&amp; !page-&gt;settings().unhandledPromiseRejectionToConsoleEnabled())
407         return;
408 
409     JSC::VM&amp; vm = state.vm();
410     auto scope = DECLARE_CATCH_SCOPE(vm);
411 
412     JSC::JSValue result = promise.result(vm);
413     String resultMessage = retrieveErrorMessage(state, vm, result, scope);
414     String errorMessage = makeString(&quot;Unhandled Promise Rejection: &quot;, resultMessage);
415     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; message;
416     if (callStack)
417         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::JS, MessageType::Log, MessageLevel::Error, errorMessage, callStack.releaseNonNull());
418     else
419         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::JS, MessageType::Log, MessageLevel::Error, errorMessage);
420     addConsoleMessage(WTFMove(message));
421 }
422 
<span class="line-modified">423 void ScriptExecutionContext::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, JSC::ExecState* state, unsigned long requestIdentifier)</span>
424 {
425     addMessage(source, level, message, sourceURL, lineNumber, columnNumber, 0, state, requestIdentifier);
426 }
427 
428 bool ScriptExecutionContext::dispatchErrorEvent(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, JSC::Exception* exception, CachedScript* cachedScript)
429 {
430     auto* target = errorEventTarget();
431     if (!target)
432         return false;
433 
434     RefPtr&lt;ErrorEvent&gt; errorEvent;
435     if (canIncludeErrorDetails(cachedScript, sourceURL))
436         errorEvent = ErrorEvent::create(errorMessage, sourceURL, lineNumber, columnNumber, { vm(), exception ? exception-&gt;value() : JSC::jsNull() });
437     else
438         errorEvent = ErrorEvent::create(&quot;Script error.&quot;_s, { }, 0, 0, { });
439 
440     ASSERT(!m_inDispatchErrorEvent);
441     m_inDispatchErrorEvent = true;
442     target-&gt;dispatchEvent(*errorEvent);
443     m_inDispatchErrorEvent = false;
</pre>
<hr />
<pre>
518     m_rejectedPromiseTracker = nullptr;
519 }
520 
521 void ScriptExecutionContext::setDatabaseContext(DatabaseContext* databaseContext)
522 {
523     m_databaseContext = databaseContext;
524 }
525 
526 bool ScriptExecutionContext::hasPendingActivity() const
527 {
528     checkConsistency();
529 
530     for (auto* activeDOMObject : m_activeDOMObjects) {
531         if (activeDOMObject-&gt;hasPendingActivity())
532             return true;
533     }
534 
535     return false;
536 }
537 
<span class="line-modified">538 JSC::ExecState* ScriptExecutionContext::execState()</span>
539 {
540     if (is&lt;Document&gt;(*this)) {
541         Document&amp; document = downcast&lt;Document&gt;(*this);
542         auto* frame = document.frame();
<span class="line-modified">543         return frame ? frame-&gt;script().globalObject(mainThreadNormalWorld())-&gt;globalExec() : nullptr;</span>
544     }
545 
546     if (is&lt;WorkerGlobalScope&gt;(*this))
547         return execStateFromWorkerGlobalScope(downcast&lt;WorkerGlobalScope&gt;(*this));
548 #if ENABLE(CSS_PAINTING_API)
549     if (is&lt;WorkletGlobalScope&gt;(*this))
550         return execStateFromWorkletGlobalScope(downcast&lt;WorkletGlobalScope&gt;(*this));
551 #endif
552 
553     ASSERT_NOT_REACHED();
554     return nullptr;
555 }
556 
557 String ScriptExecutionContext::domainForCachePartition() const
558 {
559     return m_domainForCachePartition.isNull() ? topOrigin().domainForCachePartition() : m_domainForCachePartition;
560 }
561 
562 bool ScriptExecutionContext::allowsMediaDevices() const
563 {
564 #if ENABLE(MEDIA_STREAM)
565     if (!is&lt;Document&gt;(*this))
566         return false;
567     auto page = downcast&lt;Document&gt;(*this).page();
568     return page ? !page-&gt;settings().mediaCaptureRequiresSecureConnection() : false;
569 #else
570     return false;
571 #endif
572 }
573 
574 bool ScriptExecutionContext::hasServiceWorkerScheme() const
575 {
576     ASSERT(securityOrigin());
<span class="line-modified">577     return SchemeRegistry::isServiceWorkerContainerCustomScheme(securityOrigin()-&gt;protocol());</span>
578 }
579 
580 #if ENABLE(SERVICE_WORKER)
581 
582 ServiceWorker* ScriptExecutionContext::activeServiceWorker() const
583 {
584     return m_activeServiceWorker.get();
585 }
586 
587 void ScriptExecutionContext::setActiveServiceWorker(RefPtr&lt;ServiceWorker&gt;&amp;&amp; serviceWorker)
588 {
589     m_activeServiceWorker = WTFMove(serviceWorker);
590 }
591 
592 void ScriptExecutionContext::registerServiceWorker(ServiceWorker&amp; serviceWorker)
593 {
594     auto addResult = m_serviceWorkers.add(serviceWorker.identifier(), &amp;serviceWorker);
595     ASSERT_UNUSED(addResult, addResult.isNewEntry);
596 }
597 
598 void ScriptExecutionContext::unregisterServiceWorker(ServiceWorker&amp; serviceWorker)
599 {
600     m_serviceWorkers.remove(serviceWorker.identifier());
601 }
602 
603 ServiceWorkerContainer* ScriptExecutionContext::serviceWorkerContainer()
604 {
605     NavigatorBase* navigator = nullptr;
606     if (is&lt;Document&gt;(*this)) {
607         if (auto* window = downcast&lt;Document&gt;(*this).domWindow())
608             navigator = window-&gt;optionalNavigator();
609     } else
610         navigator = downcast&lt;WorkerGlobalScope&gt;(*this).optionalNavigator();
611 
612     return navigator ? &amp;navigator-&gt;serviceWorker() : nullptr;
613 }
614 
<span class="line-modified">615 bool ScriptExecutionContext::postTaskTo(const DocumentOrWorkerIdentifier&amp; contextIdentifier, WTF::Function&lt;void(ScriptExecutionContext&amp;)&gt;&amp;&amp; task)</span>
616 {
<span class="line-modified">617     ASSERT(isMainThread());</span>





618 
<span class="line-modified">619     bool wasPosted = false;</span>
<span class="line-removed">620     switchOn(contextIdentifier, [&amp;] (DocumentIdentifier identifier) {</span>
<span class="line-removed">621         auto* document = Document::allDocumentsMap().get(identifier);</span>
<span class="line-removed">622         if (!document)</span>
<span class="line-removed">623             return;</span>
<span class="line-removed">624         document-&gt;postTask([task = WTFMove(task)](auto&amp; scope) {</span>
<span class="line-removed">625             task(scope);</span>
<span class="line-removed">626         });</span>
<span class="line-removed">627         wasPosted= true;</span>
<span class="line-removed">628     }, [&amp;](ServiceWorkerIdentifier identifier) {</span>
<span class="line-removed">629         wasPosted = SWContextManager::singleton().postTaskToServiceWorker(identifier, [task = WTFMove(task)](auto&amp; scope) {</span>
<span class="line-removed">630             task(scope);</span>
<span class="line-removed">631         });</span>
<span class="line-removed">632     });</span>
<span class="line-removed">633     return wasPosted;</span>
634 }
635 
636 #endif
637 
638 bool ScriptExecutionContext::postTaskTo(ScriptExecutionContextIdentifier identifier, Task&amp;&amp; task)
639 {
640     Locker&lt;Lock&gt; locker(allScriptExecutionContextsMapLock);
641     auto* context = allScriptExecutionContextsMap().get(identifier);
642 
643     if (!context)
644         return false;
645 
646     context-&gt;postTask(WTFMove(task));
647     return true;
648 }
649 
650 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  *
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;ScriptExecutionContext.h&quot;
 30 
 31 #include &quot;CachedScript.h&quot;
 32 #include &quot;CommonVM.h&quot;
 33 #include &quot;DOMTimer.h&quot;
 34 #include &quot;DOMWindow.h&quot;
 35 #include &quot;DatabaseContext.h&quot;
 36 #include &quot;Document.h&quot;
 37 #include &quot;ErrorEvent.h&quot;
 38 #include &quot;JSDOMExceptionHandling.h&quot;
 39 #include &quot;JSDOMWindow.h&quot;
<span class="line-added"> 40 #include &quot;LegacySchemeRegistry.h&quot;</span>
 41 #include &quot;MessagePort.h&quot;
 42 #include &quot;Navigator.h&quot;
 43 #include &quot;Page.h&quot;
 44 #include &quot;PublicURLManager.h&quot;
 45 #include &quot;RejectedPromiseTracker.h&quot;
 46 #include &quot;ResourceRequest.h&quot;
 47 #include &quot;SWClientConnection.h&quot;
 48 #include &quot;SWContextManager.h&quot;

 49 #include &quot;ScriptController.h&quot;
 50 #include &quot;ScriptDisallowedScope.h&quot;
 51 #include &quot;ScriptState.h&quot;
 52 #include &quot;ServiceWorker.h&quot;
 53 #include &quot;ServiceWorkerGlobalScope.h&quot;
 54 #include &quot;ServiceWorkerProvider.h&quot;
 55 #include &quot;Settings.h&quot;
 56 #include &quot;WorkerGlobalScope.h&quot;
 57 #include &quot;WorkerNavigator.h&quot;
 58 #include &quot;WorkerThread.h&quot;
 59 #include &quot;WorkletGlobalScope.h&quot;
 60 #include &quot;WorkletScriptController.h&quot;
 61 #include &lt;JavaScriptCore/CatchScope.h&gt;
 62 #include &lt;JavaScriptCore/Exception.h&gt;
 63 #include &lt;JavaScriptCore/JSPromise.h&gt;
 64 #include &lt;JavaScriptCore/ScriptCallStack.h&gt;
 65 #include &lt;JavaScriptCore/StrongInlines.h&gt;
 66 #include &lt;wtf/MainThread.h&gt;
 67 #include &lt;wtf/Ref.h&gt;
 68 #include &lt;wtf/SetForScope.h&gt;
</pre>
<hr />
<pre>
106     if (!m_contextIdentifier) {
107         Locker&lt;Lock&gt; locker(allScriptExecutionContextsMapLock);
108 
109         m_contextIdentifier = ScriptExecutionContextIdentifier::generate();
110 
111         ASSERT(!allScriptExecutionContextsMap().contains(m_contextIdentifier));
112         allScriptExecutionContextsMap().add(m_contextIdentifier, const_cast&lt;ScriptExecutionContext*&gt;(this));
113     }
114     return m_contextIdentifier;
115 }
116 
117 void ScriptExecutionContext::removeFromContextsMap()
118 {
119     if (m_contextIdentifier) {
120         Locker&lt;Lock&gt; locker(allScriptExecutionContextsMapLock);
121         ASSERT(allScriptExecutionContextsMap().contains(m_contextIdentifier));
122         allScriptExecutionContextsMap().remove(m_contextIdentifier);
123     }
124 }
125 
<span class="line-modified">126 #if !ASSERT_ENABLED</span>
127 
128 inline void ScriptExecutionContext::checkConsistency() const
129 {
130 }
131 
<span class="line-modified">132 #else // ASSERT_ENABLED</span>
133 
134 void ScriptExecutionContext::checkConsistency() const
135 {
136     for (auto* messagePort : m_messagePorts)
137         ASSERT(messagePort-&gt;scriptExecutionContext() == this);
138 
139     for (auto* destructionObserver : m_destructionObservers)
140         ASSERT(destructionObserver-&gt;scriptExecutionContext() == this);
141 
142     for (auto* activeDOMObject : m_activeDOMObjects) {
143         ASSERT(activeDOMObject-&gt;scriptExecutionContext() == this);
144         activeDOMObject-&gt;assertSuspendIfNeededWasCalled();
145     }
146 }
147 
<span class="line-modified">148 #endif // ASSERT_ENABLED</span>
149 
150 ScriptExecutionContext::~ScriptExecutionContext()
151 {
152     checkConsistency();
153 
<span class="line-modified">154 #if ASSERT_ENABLED</span>
155     if (m_contextIdentifier) {
156         Locker&lt;Lock&gt; locker(allScriptExecutionContextsMapLock);
157         ASSERT_WITH_MESSAGE(!allScriptExecutionContextsMap().contains(m_contextIdentifier),
158             &quot;A ScriptExecutionContext subclass instance implementing postTask should have already removed itself from the map&quot;);
159     }
160 
161     m_inScriptExecutionContextDestructor = true;
<span class="line-modified">162 #endif // ASSERT_ENABLED</span>
163 
164 #if ENABLE(SERVICE_WORKER)
165     setActiveServiceWorker(nullptr);
166 #endif
167 
168     while (auto* destructionObserver = m_destructionObservers.takeAny())
169         destructionObserver-&gt;contextDestroyed();
170 
<span class="line-modified">171 #if ASSERT_ENABLED</span>
172     m_inScriptExecutionContextDestructor = false;
173 #endif
174 }
175 
176 void ScriptExecutionContext::processMessageWithMessagePortsSoon()
177 {
178     if (m_willprocessMessageWithMessagePortsSoon)
179         return;
180 
181     m_willprocessMessageWithMessagePortsSoon = true;
182     postTask([] (ScriptExecutionContext&amp; context) {
183         context.dispatchMessagePortEvents();
184     });
185 }
186 
187 void ScriptExecutionContext::dispatchMessagePortEvents()
188 {
189     checkConsistency();
190 
191     Ref&lt;ScriptExecutionContext&gt; protectedThis(*this);
</pre>
<hr />
<pre>
205 void ScriptExecutionContext::createdMessagePort(MessagePort&amp; messagePort)
206 {
207     ASSERT((is&lt;Document&gt;(*this) &amp;&amp; isMainThread())
208         || (is&lt;WorkerGlobalScope&gt;(*this) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*this).thread().thread() == &amp;Thread::current()));
209 
210     m_messagePorts.add(&amp;messagePort);
211 }
212 
213 void ScriptExecutionContext::destroyedMessagePort(MessagePort&amp; messagePort)
214 {
215     ASSERT((is&lt;Document&gt;(*this) &amp;&amp; isMainThread())
216         || (is&lt;WorkerGlobalScope&gt;(*this) &amp;&amp; downcast&lt;WorkerGlobalScope&gt;(*this).thread().thread() == &amp;Thread::current()));
217 
218     m_messagePorts.remove(&amp;messagePort);
219 }
220 
221 void ScriptExecutionContext::didLoadResourceSynchronously()
222 {
223 }
224 



























225 void ScriptExecutionContext::forEachActiveDOMObject(const Function&lt;ShouldContinue(ActiveDOMObject&amp;)&gt;&amp; apply) const
226 {
227     // It is not allowed to run arbitrary script or construct new ActiveDOMObjects while we are iterating over ActiveDOMObjects.
228     // An ASSERT_WITH_SECURITY_IMPLICATION or RELEASE_ASSERT will fire if this happens, but it&#39;s important to code
<span class="line-modified">229     // suspend() / resume() / stop() functions so it will not happen!</span>
230     ScriptDisallowedScope scriptDisallowedScope;
231     SetForScope&lt;bool&gt; activeDOMObjectAdditionForbiddenScope(m_activeDOMObjectAdditionForbidden, true);
232 
233     // Make a frozen copy of the objects so we can iterate while new ones might be destroyed.
234     auto possibleActiveDOMObjects = copyToVector(m_activeDOMObjects);
235 
236     for (auto* activeDOMObject : possibleActiveDOMObjects) {
237         // Check if this object was deleted already. If so, just skip it.
238         // Calling contains on a possibly-already-deleted object is OK because we guarantee
239         // no new object can be added, so even if a new object ends up allocated with the
240         // same address, that will be *after* this function exits.
241         if (!m_activeDOMObjects.contains(activeDOMObject))
242             continue;
243 
244         if (apply(*activeDOMObject) == ShouldContinue::No)
245             break;
246     }
247 }
248 
249 void ScriptExecutionContext::suspendActiveDOMObjects(ReasonForSuspension why)
250 {
251     checkConsistency();
252 
253     if (m_activeDOMObjectsAreSuspended) {
<span class="line-modified">254         // A page may subsequently suspend DOM objects, say as part of entering the back/forward cache, after the embedding</span>
255         // client requested the page be suspended. We ignore such requests so long as the embedding client requested
256         // the suspension first. See &lt;rdar://problem/13754896&gt; for more details.
257         ASSERT(m_reasonForSuspendingActiveDOMObjects == ReasonForSuspension::PageWillBeSuspended);
258         return;
259     }
260 
261     m_activeDOMObjectsAreSuspended = true;
262 
263     forEachActiveDOMObject([why](auto&amp; activeDOMObject) {
264         activeDOMObject.suspend(why);
265         return ShouldContinue::Yes;
266     });
267 
268     m_reasonForSuspendingActiveDOMObjects = why;
269 }
270 
271 void ScriptExecutionContext::resumeActiveDOMObjects(ReasonForSuspension why)
272 {
273     checkConsistency();
274 
275     if (m_reasonForSuspendingActiveDOMObjects != why)
276         return;

277 
278     forEachActiveDOMObject([](auto&amp; activeDOMObject) {
279         activeDOMObject.resume();
280         return ShouldContinue::Yes;
281     });
282 
<span class="line-modified">283     m_activeDOMObjectsAreSuspended = false;</span>
<span class="line-modified">284 </span>
<span class="line-added">285     // In case there were pending messages at the time the script execution context entered the BackForwardCache,</span>
<span class="line-added">286     // make sure those get dispatched shortly after restoring from the BackForwardCache.</span>
287     processMessageWithMessagePortsSoon();
288 }
289 
290 void ScriptExecutionContext::stopActiveDOMObjects()
291 {
292     checkConsistency();
293 
294     if (m_activeDOMObjectsAreStopped)
295         return;
296     m_activeDOMObjectsAreStopped = true;
297 
298     forEachActiveDOMObject([](auto&amp; activeDOMObject) {
299         activeDOMObject.stop();
300         return ShouldContinue::Yes;
301     });
302 }
303 
304 void ScriptExecutionContext::suspendActiveDOMObjectIfNeeded(ActiveDOMObject&amp; activeDOMObject)
305 {
306     ASSERT(m_activeDOMObjects.contains(&amp;activeDOMObject));
</pre>
<hr />
<pre>
353 {
354     if (m_inDispatchErrorEvent) {
355         if (!m_pendingExceptions)
356             m_pendingExceptions = makeUnique&lt;Vector&lt;std::unique_ptr&lt;PendingException&gt;&gt;&gt;();
357         m_pendingExceptions-&gt;append(makeUnique&lt;PendingException&gt;(errorMessage, lineNumber, columnNumber, sourceURL, WTFMove(callStack)));
358         return;
359     }
360 
361     // First report the original exception and only then all the nested ones.
362     if (!dispatchErrorEvent(errorMessage, lineNumber, columnNumber, sourceURL, exception, cachedScript))
363         logExceptionToConsole(errorMessage, sourceURL, lineNumber, columnNumber, callStack.copyRef());
364 
365     if (!m_pendingExceptions)
366         return;
367 
368     auto pendingExceptions = WTFMove(m_pendingExceptions);
369     for (auto&amp; exception : *pendingExceptions)
370         logExceptionToConsole(exception-&gt;m_errorMessage, exception-&gt;m_sourceURL, exception-&gt;m_lineNumber, exception-&gt;m_columnNumber, WTFMove(exception-&gt;m_callStack));
371 }
372 
<span class="line-modified">373 void ScriptExecutionContext::reportUnhandledPromiseRejection(JSC::JSGlobalObject&amp; state, JSC::JSPromise&amp; promise, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp; callStack)</span>
374 {
375     Page* page = nullptr;
376     if (is&lt;Document&gt;(this))
377         page = downcast&lt;Document&gt;(this)-&gt;page();
378     // FIXME: allow Workers to mute unhandled promise rejection messages.
379 
380     if (page &amp;&amp; !page-&gt;settings().unhandledPromiseRejectionToConsoleEnabled())
381         return;
382 
383     JSC::VM&amp; vm = state.vm();
384     auto scope = DECLARE_CATCH_SCOPE(vm);
385 
386     JSC::JSValue result = promise.result(vm);
387     String resultMessage = retrieveErrorMessage(state, vm, result, scope);
388     String errorMessage = makeString(&quot;Unhandled Promise Rejection: &quot;, resultMessage);
389     std::unique_ptr&lt;Inspector::ConsoleMessage&gt; message;
390     if (callStack)
391         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::JS, MessageType::Log, MessageLevel::Error, errorMessage, callStack.releaseNonNull());
392     else
393         message = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::JS, MessageType::Log, MessageLevel::Error, errorMessage);
394     addConsoleMessage(WTFMove(message));
395 }
396 
<span class="line-modified">397 void ScriptExecutionContext::addConsoleMessage(MessageSource source, MessageLevel level, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, JSC::JSGlobalObject* state, unsigned long requestIdentifier)</span>
398 {
399     addMessage(source, level, message, sourceURL, lineNumber, columnNumber, 0, state, requestIdentifier);
400 }
401 
402 bool ScriptExecutionContext::dispatchErrorEvent(const String&amp; errorMessage, int lineNumber, int columnNumber, const String&amp; sourceURL, JSC::Exception* exception, CachedScript* cachedScript)
403 {
404     auto* target = errorEventTarget();
405     if (!target)
406         return false;
407 
408     RefPtr&lt;ErrorEvent&gt; errorEvent;
409     if (canIncludeErrorDetails(cachedScript, sourceURL))
410         errorEvent = ErrorEvent::create(errorMessage, sourceURL, lineNumber, columnNumber, { vm(), exception ? exception-&gt;value() : JSC::jsNull() });
411     else
412         errorEvent = ErrorEvent::create(&quot;Script error.&quot;_s, { }, 0, 0, { });
413 
414     ASSERT(!m_inDispatchErrorEvent);
415     m_inDispatchErrorEvent = true;
416     target-&gt;dispatchEvent(*errorEvent);
417     m_inDispatchErrorEvent = false;
</pre>
<hr />
<pre>
492     m_rejectedPromiseTracker = nullptr;
493 }
494 
495 void ScriptExecutionContext::setDatabaseContext(DatabaseContext* databaseContext)
496 {
497     m_databaseContext = databaseContext;
498 }
499 
500 bool ScriptExecutionContext::hasPendingActivity() const
501 {
502     checkConsistency();
503 
504     for (auto* activeDOMObject : m_activeDOMObjects) {
505         if (activeDOMObject-&gt;hasPendingActivity())
506             return true;
507     }
508 
509     return false;
510 }
511 
<span class="line-modified">512 JSC::JSGlobalObject* ScriptExecutionContext::execState()</span>
513 {
514     if (is&lt;Document&gt;(*this)) {
515         Document&amp; document = downcast&lt;Document&gt;(*this);
516         auto* frame = document.frame();
<span class="line-modified">517         return frame ? frame-&gt;script().globalObject(mainThreadNormalWorld()) : nullptr;</span>
518     }
519 
520     if (is&lt;WorkerGlobalScope&gt;(*this))
521         return execStateFromWorkerGlobalScope(downcast&lt;WorkerGlobalScope&gt;(*this));
522 #if ENABLE(CSS_PAINTING_API)
523     if (is&lt;WorkletGlobalScope&gt;(*this))
524         return execStateFromWorkletGlobalScope(downcast&lt;WorkletGlobalScope&gt;(*this));
525 #endif
526 
527     ASSERT_NOT_REACHED();
528     return nullptr;
529 }
530 
531 String ScriptExecutionContext::domainForCachePartition() const
532 {
533     return m_domainForCachePartition.isNull() ? topOrigin().domainForCachePartition() : m_domainForCachePartition;
534 }
535 
536 bool ScriptExecutionContext::allowsMediaDevices() const
537 {
538 #if ENABLE(MEDIA_STREAM)
539     if (!is&lt;Document&gt;(*this))
540         return false;
541     auto page = downcast&lt;Document&gt;(*this).page();
542     return page ? !page-&gt;settings().mediaCaptureRequiresSecureConnection() : false;
543 #else
544     return false;
545 #endif
546 }
547 
548 bool ScriptExecutionContext::hasServiceWorkerScheme() const
549 {
550     ASSERT(securityOrigin());
<span class="line-modified">551     return LegacySchemeRegistry::isServiceWorkerContainerCustomScheme(securityOrigin()-&gt;protocol());</span>
552 }
553 
554 #if ENABLE(SERVICE_WORKER)
555 
556 ServiceWorker* ScriptExecutionContext::activeServiceWorker() const
557 {
558     return m_activeServiceWorker.get();
559 }
560 
561 void ScriptExecutionContext::setActiveServiceWorker(RefPtr&lt;ServiceWorker&gt;&amp;&amp; serviceWorker)
562 {
563     m_activeServiceWorker = WTFMove(serviceWorker);
564 }
565 
566 void ScriptExecutionContext::registerServiceWorker(ServiceWorker&amp; serviceWorker)
567 {
568     auto addResult = m_serviceWorkers.add(serviceWorker.identifier(), &amp;serviceWorker);
569     ASSERT_UNUSED(addResult, addResult.isNewEntry);
570 }
571 
572 void ScriptExecutionContext::unregisterServiceWorker(ServiceWorker&amp; serviceWorker)
573 {
574     m_serviceWorkers.remove(serviceWorker.identifier());
575 }
576 
577 ServiceWorkerContainer* ScriptExecutionContext::serviceWorkerContainer()
578 {
579     NavigatorBase* navigator = nullptr;
580     if (is&lt;Document&gt;(*this)) {
581         if (auto* window = downcast&lt;Document&gt;(*this).domWindow())
582             navigator = window-&gt;optionalNavigator();
583     } else
584         navigator = downcast&lt;WorkerGlobalScope&gt;(*this).optionalNavigator();
585 
586     return navigator ? &amp;navigator-&gt;serviceWorker() : nullptr;
587 }
588 
<span class="line-modified">589 ServiceWorkerContainer* ScriptExecutionContext::ensureServiceWorkerContainer()</span>
590 {
<span class="line-modified">591     NavigatorBase* navigator = nullptr;</span>
<span class="line-added">592     if (is&lt;Document&gt;(*this)) {</span>
<span class="line-added">593         if (auto* window = downcast&lt;Document&gt;(*this).domWindow())</span>
<span class="line-added">594             navigator = &amp;window-&gt;navigator();</span>
<span class="line-added">595     } else</span>
<span class="line-added">596         navigator = &amp;downcast&lt;WorkerGlobalScope&gt;(*this).navigator();</span>
597 
<span class="line-modified">598     return navigator ? &amp;navigator-&gt;serviceWorker() : nullptr;</span>














599 }
600 
601 #endif
602 
603 bool ScriptExecutionContext::postTaskTo(ScriptExecutionContextIdentifier identifier, Task&amp;&amp; task)
604 {
605     Locker&lt;Lock&gt; locker(allScriptExecutionContextsMapLock);
606     auto* context = allScriptExecutionContextsMap().get(identifier);
607 
608     if (!context)
609         return false;
610 
611     context-&gt;postTask(WTFMove(task));
612     return true;
613 }
614 
615 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="ScriptElement.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="ScriptExecutionContext.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeGeneratorification.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="BytecodeDumper.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeGeneratorification.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/BytecodeGeneratorification.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 26,22 ***</span>
  
  #include &quot;config.h&quot;
  #include &quot;BytecodeGeneratorification.h&quot;
  
  #include &quot;BytecodeDumper.h&quot;
  #include &quot;BytecodeLivenessAnalysisInlines.h&quot;
  #include &quot;BytecodeRewriter.h&quot;
  #include &quot;BytecodeStructs.h&quot;
  #include &quot;BytecodeUseDef.h&quot;
  #include &quot;IdentifierInlines.h&quot;
  #include &quot;InterpreterInlines.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSCJSValueInlines.h&quot;
<span class="line-modified">! #include &quot;JSGeneratorFunction.h&quot;</span>
  #include &quot;Label.h&quot;
  #include &quot;StrongInlines.h&quot;
<span class="line-modified">! #include &quot;UnlinkedCodeBlock.h&quot;</span>
  #include &quot;UnlinkedMetadataTableInlines.h&quot;
  #include &lt;wtf/Optional.h&gt;
  
  namespace JSC {
  
<span class="line-new-header">--- 26,23 ---</span>
  
  #include &quot;config.h&quot;
  #include &quot;BytecodeGeneratorification.h&quot;
  
  #include &quot;BytecodeDumper.h&quot;
<span class="line-added">+ #include &quot;BytecodeGeneratorBaseInlines.h&quot;</span>
  #include &quot;BytecodeLivenessAnalysisInlines.h&quot;
  #include &quot;BytecodeRewriter.h&quot;
  #include &quot;BytecodeStructs.h&quot;
  #include &quot;BytecodeUseDef.h&quot;
  #include &quot;IdentifierInlines.h&quot;
  #include &quot;InterpreterInlines.h&quot;
  #include &quot;JSCInlines.h&quot;
  #include &quot;JSCJSValueInlines.h&quot;
<span class="line-modified">! #include &quot;JSGenerator.h&quot;</span>
  #include &quot;Label.h&quot;
  #include &quot;StrongInlines.h&quot;
<span class="line-modified">! #include &quot;UnlinkedCodeBlockGenerator.h&quot;</span>
  #include &quot;UnlinkedMetadataTableInlines.h&quot;
  #include &lt;wtf/Optional.h&gt;
  
  namespace JSC {
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 61,53 ***</span>
          VirtualRegister m_scope;
          VirtualRegister m_symbolTable;
          VirtualRegister m_initialValue;
      };
  
<span class="line-modified">!     BytecodeGeneratorification(BytecodeGenerator&amp; bytecodeGenerator, UnlinkedCodeBlock* codeBlock, InstructionStreamWriter&amp; instructions, SymbolTable* generatorFrameSymbolTable, int generatorFrameSymbolTableIndex)</span>
          : m_bytecodeGenerator(bytecodeGenerator)
          , m_codeBlock(codeBlock)
          , m_instructions(instructions)
          , m_graph(m_codeBlock, m_instructions)
          , m_generatorFrameSymbolTable(codeBlock-&gt;vm(), generatorFrameSymbolTable)
          , m_generatorFrameSymbolTableIndex(generatorFrameSymbolTableIndex)
      {
<span class="line-modified">!         for (BytecodeBasicBlock* block : m_graph) {</span>
<span class="line-modified">!             for (const auto offset : block-&gt;offsets()) {</span>
<span class="line-modified">!                 const auto instruction = m_instructions.at(offset);</span>
<span class="line-modified">!                 switch (instruction-&gt;opcodeID()) {</span>
<span class="line-modified">!                 case op_enter: {</span>
<span class="line-modified">!                     m_enterPoint = instruction.offset();</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 case op_yield: {</span>
<span class="line-modified">!                     auto bytecode = instruction-&gt;as&lt;OpYield&gt;();</span>
<span class="line-modified">!                     unsigned liveCalleeLocalsIndex = bytecode.m_yieldPoint;</span>
<span class="line-modified">!                     if (liveCalleeLocalsIndex &gt;= m_yields.size())</span>
<span class="line-modified">!                         m_yields.resize(liveCalleeLocalsIndex + 1);</span>
<span class="line-modified">!                     YieldData&amp; data = m_yields[liveCalleeLocalsIndex];</span>
<span class="line-modified">!                     data.point = instruction.offset();</span>
<span class="line-modified">!                     data.argument = bytecode.m_argument;</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">! </span>
<span class="line-modified">!                 case op_create_generator_frame_environment: {</span>
<span class="line-modified">!                     auto bytecode = instruction-&gt;as&lt;OpCreateGeneratorFrameEnvironment&gt;();</span>
<span class="line-modified">!                     GeneratorFrameData data;</span>
<span class="line-modified">!                     data.m_point = instruction.offset();</span>
<span class="line-modified">!                     data.m_dst = bytecode.m_dst;</span>
<span class="line-modified">!                     data.m_scope = bytecode.m_scope;</span>
<span class="line-modified">!                     data.m_symbolTable = bytecode.m_symbolTable;</span>
<span class="line-modified">!                     data.m_initialValue = bytecode.m_initialValue;</span>
<span class="line-modified">!                     m_generatorFrameData = WTFMove(data);</span>
<span class="line-modified">!                     break;</span>
<span class="line-modified">!                 }</span>
<span class="line-modified">! </span>
<span class="line-removed">-                 default:</span>
<span class="line-removed">-                     break;</span>
<span class="line-removed">-                 }</span>
              }
          }
      }
  
      struct Storage {
<span class="line-new-header">--- 62,50 ---</span>
          VirtualRegister m_scope;
          VirtualRegister m_symbolTable;
          VirtualRegister m_initialValue;
      };
  
<span class="line-modified">!     BytecodeGeneratorification(BytecodeGenerator&amp; bytecodeGenerator, UnlinkedCodeBlockGenerator* codeBlock, InstructionStreamWriter&amp; instructions, SymbolTable* generatorFrameSymbolTable, int generatorFrameSymbolTableIndex)</span>
          : m_bytecodeGenerator(bytecodeGenerator)
          , m_codeBlock(codeBlock)
          , m_instructions(instructions)
          , m_graph(m_codeBlock, m_instructions)
          , m_generatorFrameSymbolTable(codeBlock-&gt;vm(), generatorFrameSymbolTable)
          , m_generatorFrameSymbolTableIndex(generatorFrameSymbolTableIndex)
      {
<span class="line-modified">!         for (const auto&amp; instruction : m_instructions) {</span>
<span class="line-modified">!             switch (instruction-&gt;opcodeID()) {</span>
<span class="line-modified">!             case op_enter: {</span>
<span class="line-modified">!                 m_enterPoint = instruction.offset();</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">! </span>
<span class="line-modified">!             case op_yield: {</span>
<span class="line-modified">!                 auto bytecode = instruction-&gt;as&lt;OpYield&gt;();</span>
<span class="line-modified">!                 unsigned liveCalleeLocalsIndex = bytecode.m_yieldPoint;</span>
<span class="line-modified">!                 if (liveCalleeLocalsIndex &gt;= m_yields.size())</span>
<span class="line-modified">!                     m_yields.resize(liveCalleeLocalsIndex + 1);</span>
<span class="line-modified">!                 YieldData&amp; data = m_yields[liveCalleeLocalsIndex];</span>
<span class="line-modified">!                 data.point = instruction.offset();</span>
<span class="line-modified">!                 data.argument = bytecode.m_argument;</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">! </span>
<span class="line-modified">!             case op_create_generator_frame_environment: {</span>
<span class="line-modified">!                 auto bytecode = instruction-&gt;as&lt;OpCreateGeneratorFrameEnvironment&gt;();</span>
<span class="line-modified">!                 GeneratorFrameData data;</span>
<span class="line-modified">!                 data.m_point = instruction.offset();</span>
<span class="line-modified">!                 data.m_dst = bytecode.m_dst;</span>
<span class="line-modified">!                 data.m_scope = bytecode.m_scope;</span>
<span class="line-modified">!                 data.m_symbolTable = bytecode.m_symbolTable;</span>
<span class="line-modified">!                 data.m_initialValue = bytecode.m_initialValue;</span>
<span class="line-modified">!                 m_generatorFrameData = WTFMove(data);</span>
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             }</span>
<span class="line-modified">! </span>
<span class="line-modified">!             default:</span>
<span class="line-modified">!                 break;</span>
              }
          }
      }
  
      struct Storage {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 174,11 ***</span>
      }
  
      BytecodeGenerator&amp; m_bytecodeGenerator;
      InstructionStream::Offset m_enterPoint;
      Optional&lt;GeneratorFrameData&gt; m_generatorFrameData;
<span class="line-modified">!     UnlinkedCodeBlock* m_codeBlock;</span>
      InstructionStreamWriter&amp; m_instructions;
      BytecodeGraph m_graph;
      Vector&lt;Optional&lt;Storage&gt;&gt; m_storages;
      Yields m_yields;
      Strong&lt;SymbolTable&gt; m_generatorFrameSymbolTable;
<span class="line-new-header">--- 172,11 ---</span>
      }
  
      BytecodeGenerator&amp; m_bytecodeGenerator;
      InstructionStream::Offset m_enterPoint;
      Optional&lt;GeneratorFrameData&gt; m_generatorFrameData;
<span class="line-modified">!     UnlinkedCodeBlockGenerator* m_codeBlock;</span>
      InstructionStreamWriter&amp; m_instructions;
      BytecodeGraph m_graph;
      Vector&lt;Optional&lt;Storage&gt;&gt; m_storages;
      Yields m_yields;
      Strong&lt;SymbolTable&gt; m_generatorFrameSymbolTable;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 190,19 ***</span>
      GeneratorLivenessAnalysis(BytecodeGeneratorification&amp; generatorification)
          : m_generatorification(generatorification)
      {
      }
  
<span class="line-modified">!     void run(UnlinkedCodeBlock* codeBlock, InstructionStreamWriter&amp; instructions)</span>
      {
          // Perform modified liveness analysis to determine which locals are live at the merge points.
          // This produces the conservative results for the question, &quot;which variables should be saved and resumed?&quot;.
  
          runLivenessFixpoint(codeBlock, instructions, m_generatorification.graph());
  
          for (YieldData&amp; data : m_generatorification.yields())
<span class="line-modified">!             data.liveness = getLivenessInfoAtBytecodeOffset(codeBlock, instructions, m_generatorification.graph(), m_generatorification.instructions().at(data.point).next().offset());</span>
      }
  
  private:
      BytecodeGeneratorification&amp; m_generatorification;
  };
<span class="line-new-header">--- 188,19 ---</span>
      GeneratorLivenessAnalysis(BytecodeGeneratorification&amp; generatorification)
          : m_generatorification(generatorification)
      {
      }
  
<span class="line-modified">!     void run(UnlinkedCodeBlockGenerator* codeBlock, InstructionStreamWriter&amp; instructions)</span>
      {
          // Perform modified liveness analysis to determine which locals are live at the merge points.
          // This produces the conservative results for the question, &quot;which variables should be saved and resumed?&quot;.
  
          runLivenessFixpoint(codeBlock, instructions, m_generatorification.graph());
  
          for (YieldData&amp; data : m_generatorification.yields())
<span class="line-modified">!             data.liveness = getLivenessInfoAtBytecodeIndex(codeBlock, instructions, m_generatorification.graph(), BytecodeIndex(m_generatorification.instructions().at(data.point).next().offset()));</span>
      }
  
  private:
      BytecodeGeneratorification&amp; m_generatorification;
  };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 221,26 ***</span>
  
      // Setup the global switch for the generator.
      {
          auto nextToEnterPoint = enterPoint().next();
          unsigned switchTableIndex = m_codeBlock-&gt;numberOfSwitchJumpTables();
<span class="line-modified">!         VirtualRegister state = virtualRegisterForArgument(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::State));</span>
          auto&amp; jumpTable = m_codeBlock-&gt;addSwitchJumpTable();
          jumpTable.min = 0;
<span class="line-modified">!         jumpTable.branchOffsets.resize(m_yields.size() + 1);</span>
<span class="line-modified">!         jumpTable.branchOffsets.fill(0);</span>
          jumpTable.add(0, nextToEnterPoint.offset());
          for (unsigned i = 0; i &lt; m_yields.size(); ++i)
              jumpTable.add(i + 1, m_yields[i].point);
  
          rewriter.insertFragmentBefore(nextToEnterPoint, [&amp;] (BytecodeRewriter::Fragment&amp; fragment) {
              fragment.appendInstruction&lt;OpSwitchImm&gt;(switchTableIndex, BoundLabel(nextToEnterPoint.offset()), state);
          });
      }
  
      for (const YieldData&amp; data : m_yields) {
<span class="line-modified">!         VirtualRegister scope = virtualRegisterForArgument(static_cast&lt;int32_t&gt;(JSGeneratorFunction::GeneratorArgument::Frame));</span>
  
          auto instruction = m_instructions.at(data.point);
          // Emit save sequence.
          rewriter.insertFragmentBefore(instruction, [&amp;] (BytecodeRewriter::Fragment&amp; fragment) {
              data.liveness.forEachSetBit([&amp;](size_t index) {
<span class="line-new-header">--- 219,26 ---</span>
  
      // Setup the global switch for the generator.
      {
          auto nextToEnterPoint = enterPoint().next();
          unsigned switchTableIndex = m_codeBlock-&gt;numberOfSwitchJumpTables();
<span class="line-modified">!         VirtualRegister state = virtualRegisterForArgumentIncludingThis(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorArgument::State));</span>
          auto&amp; jumpTable = m_codeBlock-&gt;addSwitchJumpTable();
          jumpTable.min = 0;
<span class="line-modified">!         jumpTable.branchOffsets = RefCountedArray&lt;int32_t&gt;(m_yields.size() + 1);</span>
<span class="line-modified">!         std::fill(jumpTable.branchOffsets.begin(), jumpTable.branchOffsets.end(), 0);</span>
          jumpTable.add(0, nextToEnterPoint.offset());
          for (unsigned i = 0; i &lt; m_yields.size(); ++i)
              jumpTable.add(i + 1, m_yields[i].point);
  
          rewriter.insertFragmentBefore(nextToEnterPoint, [&amp;] (BytecodeRewriter::Fragment&amp; fragment) {
              fragment.appendInstruction&lt;OpSwitchImm&gt;(switchTableIndex, BoundLabel(nextToEnterPoint.offset()), state);
          });
      }
  
      for (const YieldData&amp; data : m_yields) {
<span class="line-modified">!         VirtualRegister scope = virtualRegisterForArgumentIncludingThis(static_cast&lt;int32_t&gt;(JSGenerator::GeneratorArgument::Frame));</span>
  
          auto instruction = m_instructions.at(data.point);
          // Emit save sequence.
          rewriter.insertFragmentBefore(instruction, [&amp;] (BytecodeRewriter::Fragment&amp; fragment) {
              data.liveness.forEachSetBit([&amp;](size_t index) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 295,14 ***</span>
      }
  
      rewriter.execute();
  }
  
<span class="line-modified">! void performGeneratorification(BytecodeGenerator&amp; bytecodeGenerator, UnlinkedCodeBlock* codeBlock, InstructionStreamWriter&amp; instructions, SymbolTable* generatorFrameSymbolTable, int generatorFrameSymbolTableIndex)</span>
  {
<span class="line-modified">!     if (Options::dumpBytecodesBeforeGeneratorification())</span>
<span class="line-modified">!         BytecodeDumper&lt;UnlinkedCodeBlock&gt;::dumpBlock(codeBlock, instructions, WTF::dataFile());</span>
  
      BytecodeGeneratorification pass(bytecodeGenerator, codeBlock, instructions, generatorFrameSymbolTable, generatorFrameSymbolTableIndex);
      pass.run();
  }
  
<span class="line-new-header">--- 293,14 ---</span>
      }
  
      rewriter.execute();
  }
  
<span class="line-modified">! void performGeneratorification(BytecodeGenerator&amp; bytecodeGenerator, UnlinkedCodeBlockGenerator* codeBlock, InstructionStreamWriter&amp; instructions, SymbolTable* generatorFrameSymbolTable, int generatorFrameSymbolTableIndex)</span>
  {
<span class="line-modified">!     if (UNLIKELY(Options::dumpBytecodesBeforeGeneratorification()))</span>
<span class="line-modified">!         CodeBlockBytecodeDumper&lt;UnlinkedCodeBlockGenerator&gt;::dumpBlock(codeBlock, instructions, WTF::dataFile());</span>
  
      BytecodeGeneratorification pass(bytecodeGenerator, codeBlock, instructions, generatorFrameSymbolTable, generatorFrameSymbolTableIndex);
      pass.run();
  }
  
</pre>
<center><a href="BytecodeDumper.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="BytecodeGeneratorification.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
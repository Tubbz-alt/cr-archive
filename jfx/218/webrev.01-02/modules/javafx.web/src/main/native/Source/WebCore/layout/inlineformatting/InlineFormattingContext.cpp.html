<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InlineFormattingContext.h&quot;
 28 
 29 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 30 
 31 #include &quot;FloatingContext.h&quot;
 32 #include &quot;FontCascade.h&quot;
 33 #include &quot;InlineFormattingState.h&quot;
 34 #include &quot;InlineTextItem.h&quot;
 35 #include &quot;InvalidationState.h&quot;
 36 #include &quot;LayoutBox.h&quot;
 37 #include &quot;LayoutContainer.h&quot;
 38 #include &quot;LayoutContext.h&quot;
 39 #include &quot;LayoutState.h&quot;
 40 #include &quot;Logging.h&quot;
 41 #include &quot;RuntimeEnabledFeatures.h&quot;
 42 #include &quot;TextUtil.h&quot;
 43 #include &lt;wtf/IsoMallocInlines.h&gt;
 44 #include &lt;wtf/text/TextStream.h&gt;
 45 
 46 namespace WebCore {
 47 namespace Layout {
 48 
 49 WTF_MAKE_ISO_ALLOCATED_IMPL(InlineFormattingContext);
 50 
 51 InlineFormattingContext::InlineFormattingContext(const Container&amp; formattingContextRoot, InlineFormattingState&amp; formattingState)
 52     : FormattingContext(formattingContextRoot, formattingState)
 53 {
 54 }
 55 
 56 static inline const Box* nextInlineLevelBoxToLayout(const Box&amp; layoutBox, const Container&amp; stayWithin)
 57 {
 58     // Atomic inline-level boxes and floats are opaque boxes meaning that they are
 59     // responsible for their own content (do not need to descend into their subtrees).
 60     // Only inline boxes may have relevant descendant content.
 61     if (layoutBox.isInlineBox()) {
 62         if (is&lt;Container&gt;(layoutBox) &amp;&amp; downcast&lt;Container&gt;(layoutBox).hasInFlowOrFloatingChild()) {
 63             // Anonymous inline boxes/line breaks can&#39;t have descendant content by definition.
 64             ASSERT(!layoutBox.isAnonymous() &amp;&amp; !layoutBox.isLineBreakBox());
 65             return downcast&lt;Container&gt;(layoutBox).firstInFlowOrFloatingChild();
 66         }
 67     }
 68 
 69     for (auto* nextInPreOrder = &amp;layoutBox; nextInPreOrder &amp;&amp; nextInPreOrder != &amp;stayWithin; nextInPreOrder = nextInPreOrder-&gt;parent()) {
 70         if (auto* nextSibling = nextInPreOrder-&gt;nextInFlowOrFloatingSibling())
 71             return nextSibling;
 72     }
 73     return nullptr;
 74 }
 75 
 76 void InlineFormattingContext::layoutInFlowContent(InvalidationState&amp; invalidationState, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints)
 77 {
 78     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[Start] -&gt; inline formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root() &lt;&lt; &quot;)&quot;);
 79     ASSERT(root().hasInFlowOrFloatingChild());
 80 
 81     invalidateFormattingState(invalidationState);
 82     auto* layoutBox = root().firstInFlowOrFloatingChild();
 83     // 1. Visit each inline box and partially compute their geometry (margins, paddings and borders).
 84     // 2. Collect the inline items (flatten the the layout tree) and place them on lines in bidirectional order.
 85     while (layoutBox) {
 86         ASSERT(layoutBox-&gt;isInlineLevelBox());
 87 
 88         if (layoutBox-&gt;isAtomicInlineLevelBox()) {
 89             // Inline-blocks, inline-tables and replaced elements (img, video) can be sized but not yet positioned.
 90             computeBorderAndPadding(*layoutBox, horizontalConstraints);
 91             computeWidthAndMargin(*layoutBox, horizontalConstraints);
 92             auto createsFormattingContext = layoutBox-&gt;isInlineBlockBox() || layoutBox-&gt;isInlineTableBox();
 93             auto hasInFlowOrFloatingChild = is&lt;Container&gt;(*layoutBox) &amp;&amp; downcast&lt;Container&gt;(*layoutBox).hasInFlowOrFloatingChild();
 94             if (createsFormattingContext &amp;&amp; hasInFlowOrFloatingChild) {
 95                 auto formattingContext = LayoutContext::createFormattingContext(downcast&lt;Container&gt;(*layoutBox), layoutState());
 96                 formattingContext-&gt;layoutInFlowContent(invalidationState, horizontalConstraints, verticalConstraints);
 97             }
 98             computeHeightAndMargin(*layoutBox, horizontalConstraints);
 99             if (createsFormattingContext &amp;&amp; is&lt;Container&gt;(*layoutBox) &amp;&amp; downcast&lt;Container&gt;(*layoutBox).hasChild()) {
100                 auto&amp; displayBox = geometryForBox(*layoutBox);
101                 auto horizontalConstraintsForOutOfFlow = Geometry::horizontalConstraintsForOutOfFlow(displayBox);
102                 auto verticalConstraintsForOutOfFlow = Geometry::verticalConstraintsForOutOfFlow(displayBox);
103                 auto formattingContext = LayoutContext::createFormattingContext(downcast&lt;Container&gt;(*layoutBox), layoutState());
104                 formattingContext-&gt;layoutOutOfFlowContent(invalidationState, horizontalConstraintsForOutOfFlow, verticalConstraintsForOutOfFlow);
105             }
106         } else if (layoutBox-&gt;isInlineBox()) {
107             if (layoutBox-&gt;isAnonymous() || layoutBox-&gt;isLineBreakBox()) {
108                 // Text wrapper boxes are anonymous inline level boxes. Their computed border/padding/margins are 0.
109                 auto&amp; displayBox = formattingState().displayBox(*layoutBox);
110                 displayBox.setVerticalMargin({ { }, { } });
111                 displayBox.setHorizontalMargin({ });
112                 displayBox.setBorder({ { }, { } });
113                 displayBox.setPadding({ });
114             } else {
115                 // Inline boxes (&lt;span&gt;) can&#39;t get sized/positioned yet. At this point we can only compute their margins, borders and paddings.
116                 computeBorderAndPadding(*layoutBox, horizontalConstraints);
117                 computeHorizontalMargin(*layoutBox, horizontalConstraints);
118                 formattingState().displayBox(*layoutBox).setVerticalMargin({ { }, { } });
119             }
120         } else
121             ASSERT_NOT_REACHED();
122 
123         layoutBox = nextInlineLevelBoxToLayout(*layoutBox, root());
124     }
125 
126     collectInlineContentIfNeeded();
127 
128     auto&amp; inlineItems = formattingState().inlineItems();
129     lineLayout(inlineItems, { 0, inlineItems.size() }, horizontalConstraints, verticalConstraints);
130     LOG_WITH_STREAM(FormattingContextLayout, stream &lt;&lt; &quot;[End] -&gt; inline formatting context -&gt; formatting root(&quot; &lt;&lt; &amp;root() &lt;&lt; &quot;)&quot;);
131 }
132 
133 void InlineFormattingContext::lineLayout(InlineItems&amp; inlineItems, LineLayoutContext::InlineItemRange layoutRange, const HorizontalConstraints&amp; horizontalConstraints, const VerticalConstraints&amp; verticalConstraints)
134 {
135     auto lineLogicalTop = verticalConstraints.logicalTop;
136     Optional&lt;unsigned&gt; partialLeadingContentLength;
137     auto lineBuilder = LineBuilder { *this, root().style().textAlign(), LineBuilder::IntrinsicSizing::No };
138     auto lineLayoutContext = LineLayoutContext { *this, root(), inlineItems };
139 
140     while (!layoutRange.isEmpty()) {
141         lineBuilder.initialize(constraintsForLine(horizontalConstraints, lineLogicalTop));
142         auto lineContent = lineLayoutContext.layoutLine(lineBuilder, layoutRange, partialLeadingContentLength);
143         setDisplayBoxesForLine(lineContent, horizontalConstraints);
144 
145         partialLeadingContentLength = { };
146         if (lineContent.trailingInlineItemIndex) {
147             lineLogicalTop = lineContent.lineBox.logicalBottom();
148             // When the trailing content is partial, we need to reuse the last InlinItem.
149             if (lineContent.partialContent) {
150                 layoutRange.start = *lineContent.trailingInlineItemIndex;
151                 // Turn previous line&#39;s overflow content length into the next line&#39;s leading content partial length.
152                 // &quot;sp&lt;-&gt;litcontent&quot; -&gt; overflow length: 10 -&gt; leading partial content length: 10.
153                 partialLeadingContentLength = lineContent.partialContent-&gt;overflowContentLength;
154             } else
155                 layoutRange.start = *lineContent.trailingInlineItemIndex + 1;
156             continue;
157         }
158         // Floats prevented us placing any content on the line.
159         ASSERT(lineBuilder.hasIntrusiveFloat());
160         // Move the next line below the intrusive float.
161         auto floatingContext = FloatingContext { root(), *this, formattingState().floatingState() };
162         auto floatConstraints = floatingContext.constraints(lineLogicalTop, toLayoutUnit(lineContent.lineBox.logicalBottom()) );
163         ASSERT(floatConstraints.left || floatConstraints.right);
164         static auto inifitePoint = PointInContextRoot::max();
165         // In case of left and right constraints, we need to pick the one that&#39;s closer to the current line.
166         lineLogicalTop = std::min(floatConstraints.left.valueOr(inifitePoint).y, floatConstraints.right.valueOr(inifitePoint).y);
167         ASSERT(lineLogicalTop &lt; inifitePoint.y);
168     }
169 }
170 
171 FormattingContext::IntrinsicWidthConstraints InlineFormattingContext::computedIntrinsicWidthConstraints()
172 {
173     auto&amp; layoutState = this-&gt;layoutState();
174     ASSERT(!formattingState().intrinsicWidthConstraints());
175 
176     if (!root().hasInFlowOrFloatingChild()) {
177         auto constraints = geometry().constrainByMinMaxWidth(root(), { });
178         formattingState().setIntrinsicWidthConstraints(constraints);
179         return constraints;
180     }
181 
182     Vector&lt;const Box*&gt; formattingContextRootList;
183     auto horizontalConstraints = HorizontalConstraints { 0_lu, 0_lu };
184     auto* layoutBox = root().firstInFlowOrFloatingChild();
185     // In order to compute the max/min widths, we need to compute margins, borders and paddings for certain inline boxes first.
186     while (layoutBox) {
187         if (layoutBox-&gt;isAnonymous()) {
188             layoutBox = nextInlineLevelBoxToLayout(*layoutBox, root());
189             continue;
190         }
191         if (layoutBox-&gt;isReplaced()) {
192             computeBorderAndPadding(*layoutBox, horizontalConstraints);
193             computeWidthAndMargin(*layoutBox, horizontalConstraints);
194         } else if (layoutBox-&gt;isFloatingPositioned() || layoutBox-&gt;isAtomicInlineLevelBox()) {
195             ASSERT(layoutBox-&gt;establishesFormattingContext());
196             formattingContextRootList.append(layoutBox);
197 
198             computeBorderAndPadding(*layoutBox, horizontalConstraints);
199             computeHorizontalMargin(*layoutBox, horizontalConstraints);
200             computeIntrinsicWidthForFormattingRoot(*layoutBox);
201         } else if (layoutBox-&gt;isInlineBox()) {
202             computeBorderAndPadding(*layoutBox, horizontalConstraints);
203             computeHorizontalMargin(*layoutBox, horizontalConstraints);
204         } else
205             ASSERT_NOT_REACHED();
206         layoutBox = nextInlineLevelBoxToLayout(*layoutBox, root());
207     }
208 
209     collectInlineContentIfNeeded();
210 
211     auto maximumLineWidth = [&amp;](auto availableWidth) {
212         // Switch to the min/max formatting root width values before formatting the lines.
213         for (auto* formattingRoot : formattingContextRootList) {
214             auto intrinsicWidths = layoutState.formattingStateForBox(*formattingRoot).intrinsicWidthConstraintsForBox(*formattingRoot);
215             auto&amp; displayBox = formattingState().displayBox(*formattingRoot);
216             auto contentWidth = (availableWidth ? intrinsicWidths-&gt;maximum : intrinsicWidths-&gt;minimum) - displayBox.horizontalMarginBorderAndPadding();
217             displayBox.setContentBoxWidth(contentWidth);
218         }
219         return computedIntrinsicWidthForConstraint({ 0_lu, toLayoutUnit(availableWidth) });
220     };
221 
222     auto constraints = geometry().constrainByMinMaxWidth(root(), { toLayoutUnit(maximumLineWidth(0)), toLayoutUnit(maximumLineWidth(maxInlineLayoutUnit())) });
223     formattingState().setIntrinsicWidthConstraints(constraints);
224     return constraints;
225 }
226 
227 InlineLayoutUnit InlineFormattingContext::computedIntrinsicWidthForConstraint(const HorizontalConstraints&amp; horizontalConstraints) const
228 {
229     auto&amp; inlineItems = formattingState().inlineItems();
230     auto maximumLineWidth = InlineLayoutUnit { };
231     auto lineBuilder = LineBuilder { *this, root().style().textAlign(), LineBuilder::IntrinsicSizing::Yes };
232     auto lineLayoutContext = LineLayoutContext { *this, root(), inlineItems };
233     auto layoutRange = LineLayoutContext::InlineItemRange { 0 , inlineItems.size() };
234     while (!layoutRange.isEmpty()) {
235         // Only the horiztonal available width is constrained when computing intrinsic width.
236         lineBuilder.initialize(LineBuilder::Constraints { { }, horizontalConstraints.logicalWidth, false, { } });
237         auto lineContent = lineLayoutContext.layoutLine(lineBuilder, layoutRange , { });
238 
239         layoutRange.start = *lineContent.trailingInlineItemIndex + 1;
240         InlineLayoutUnit floatsWidth = 0;
241         for (auto&amp; floatItem : lineContent.floats)
242             floatsWidth += geometryForBox(floatItem-&gt;layoutBox()).marginBoxWidth();
243         maximumLineWidth = std::max(maximumLineWidth, floatsWidth + lineContent.lineBox.logicalWidth());
244     }
245     return maximumLineWidth;
246 }
247 
248 void InlineFormattingContext::computeIntrinsicWidthForFormattingRoot(const Box&amp; formattingRoot)
249 {
250     ASSERT(formattingRoot.establishesFormattingContext());
251     auto constraints = IntrinsicWidthConstraints { };
252     if (auto fixedWidth = geometry().fixedValue(formattingRoot.style().logicalWidth()))
253         constraints = { *fixedWidth, *fixedWidth };
254     else if (is&lt;Container&gt;(formattingRoot) &amp;&amp; downcast&lt;Container&gt;(formattingRoot).hasInFlowOrFloatingChild())
255         constraints = LayoutContext::createFormattingContext(downcast&lt;Container&gt;(formattingRoot), layoutState())-&gt;computedIntrinsicWidthConstraints();
256     constraints = geometry().constrainByMinMaxWidth(formattingRoot, constraints);
257     constraints.expand(geometryForBox(formattingRoot).horizontalMarginBorderAndPadding());
258     formattingState().setIntrinsicWidthConstraintsForBox(formattingRoot, constraints);
259 }
260 
261 void InlineFormattingContext::computeHorizontalMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints)
262 {
263     auto computedHorizontalMargin = geometry().computedHorizontalMargin(layoutBox, horizontalConstraints);
264     auto&amp; displayBox = formattingState().displayBox(layoutBox);
265     displayBox.setHorizontalComputedMargin(computedHorizontalMargin);
266     displayBox.setHorizontalMargin({ computedHorizontalMargin.start.valueOr(0), computedHorizontalMargin.end.valueOr(0) });
267 }
268 
269 void InlineFormattingContext::computeWidthAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints)
270 {
271     ContentWidthAndMargin contentWidthAndMargin;
272     // FIXME: Add support for min/max-width.
273     auto usedWidth = OverrideHorizontalValues { };
274     if (layoutBox.isFloatingPositioned())
275         contentWidthAndMargin = geometry().floatingWidthAndMargin(layoutBox, horizontalConstraints, usedWidth);
276     else if (layoutBox.isInlineBlockBox())
277         contentWidthAndMargin = geometry().inlineBlockWidthAndMargin(layoutBox, horizontalConstraints, usedWidth);
278     else if (layoutBox.replaced())
279         contentWidthAndMargin = geometry().inlineReplacedWidthAndMargin(layoutBox, horizontalConstraints, usedWidth);
280     else
281         ASSERT_NOT_REACHED();
282 
283     auto&amp; displayBox = formattingState().displayBox(layoutBox);
284     displayBox.setContentBoxWidth(contentWidthAndMargin.contentWidth);
285     displayBox.setHorizontalMargin(contentWidthAndMargin.usedMargin);
286     displayBox.setHorizontalComputedMargin(contentWidthAndMargin.computedMargin);
287 }
288 
289 void InlineFormattingContext::computeHeightAndMargin(const Box&amp; layoutBox, const HorizontalConstraints&amp; horizontalConstraints)
290 {
291     ContentHeightAndMargin contentHeightAndMargin;
292     // FIXME: Add min/max-height support.
293     auto usedHeight = OverrideVerticalValues { };
294     if (layoutBox.isFloatingPositioned())
295         contentHeightAndMargin = geometry().floatingHeightAndMargin(layoutBox, horizontalConstraints, usedHeight);
296     else if (layoutBox.isInlineBlockBox())
297         contentHeightAndMargin = geometry().inlineBlockHeightAndMargin(layoutBox, horizontalConstraints, usedHeight);
298     else if (layoutBox.replaced())
299         contentHeightAndMargin = geometry().inlineReplacedHeightAndMargin(layoutBox, horizontalConstraints, { }, usedHeight);
300     else
301         ASSERT_NOT_REACHED();
302 
303     auto&amp; displayBox = formattingState().displayBox(layoutBox);
304     displayBox.setContentBoxHeight(contentHeightAndMargin.contentHeight);
305     displayBox.setVerticalMargin({ contentHeightAndMargin.nonCollapsedMargin, { } });
306 }
307 
308 void InlineFormattingContext::collectInlineContentIfNeeded()
309 {
310     auto&amp; formattingState = this-&gt;formattingState();
311     if (!formattingState.inlineItems().isEmpty())
312         return;
313     // Traverse the tree and create inline items out of containers and leaf nodes. This essentially turns the tree inline structure into a flat one.
314     // &lt;span&gt;text&lt;span&gt;&lt;/span&gt;&lt;img&gt;&lt;/span&gt; -&gt; [ContainerStart][InlineBox][ContainerStart][ContainerEnd][InlineBox][ContainerEnd]
315     ASSERT(root().hasInFlowOrFloatingChild());
316     LayoutQueue layoutQueue;
317     layoutQueue.append(root().firstInFlowOrFloatingChild());
318     while (!layoutQueue.isEmpty()) {
319         while (true) {
320             auto&amp; layoutBox = *layoutQueue.last();
321             auto isBoxWithInlineContent = layoutBox.isInlineBox() &amp;&amp; !layoutBox.isAnonymous() &amp;&amp; !layoutBox.isLineBreakBox();
322             if (!isBoxWithInlineContent)
323                 break;
324             // This is the start of an inline box (e.g. &lt;span&gt;).
325             formattingState.addInlineItem({ layoutBox, InlineItem::Type::ContainerStart });
326             auto&amp; inlineBoxWithInlineContent = downcast&lt;Container&gt;(layoutBox);
327             if (!inlineBoxWithInlineContent.hasInFlowOrFloatingChild())
328                 break;
329             layoutQueue.append(inlineBoxWithInlineContent.firstInFlowOrFloatingChild());
330         }
331 
332         while (!layoutQueue.isEmpty()) {
333             auto&amp; layoutBox = *layoutQueue.takeLast();
334             if (layoutBox.isLineBreakBox())
335                 formattingState.addInlineItem({ layoutBox, InlineItem::Type::HardLineBreak });
336             else if (layoutBox.isFloatingPositioned())
337                 formattingState.addInlineItem({ layoutBox, InlineItem::Type::Float });
338             else if (layoutBox.isAtomicInlineLevelBox())
339                 formattingState.addInlineItem({ layoutBox, InlineItem::Type::Box });
340             else if (layoutBox.isAnonymous()) {
341                 ASSERT(layoutBox.hasTextContent());
342                 InlineTextItem::createAndAppendTextItems(formattingState.inlineItems(), layoutBox);
343             } else if (layoutBox.isInlineBox())
344                 formattingState.addInlineItem({ layoutBox, InlineItem::Type::ContainerEnd });
345             else
346                 ASSERT_NOT_REACHED();
347 
348             if (auto* nextSibling = layoutBox.nextInFlowOrFloatingSibling()) {
349                 layoutQueue.append(nextSibling);
350                 break;
351             }
352         }
353     }
354 }
355 
356 LineBuilder::Constraints InlineFormattingContext::constraintsForLine(const HorizontalConstraints&amp; horizontalConstraints, InlineLayoutUnit lineLogicalTop)
357 {
358     auto lineLogicalLeft = horizontalConstraints.logicalLeft;
359     auto lineLogicalRight = lineLogicalLeft + horizontalConstraints.logicalWidth;
360     auto lineHeightAndBaseline = quirks().lineHeightConstraints(root());
361     auto lineIsConstrainedByFloat = false;
362 
363     auto floatingContext = FloatingContext { root(), *this, formattingState().floatingState() };
364     // Check for intruding floats and adjust logical left/available width for this line accordingly.
365     if (!floatingContext.isEmpty()) {
366         // FIXME: Add support for variable line height, where the intrusive floats should be probed as the line height grows.
367         auto floatConstraints = floatingContext.constraints(toLayoutUnit(lineLogicalTop), toLayoutUnit(lineLogicalTop + lineHeightAndBaseline.height));
368         // Check if these constraints actually put limitation on the line.
369         if (floatConstraints.left &amp;&amp; floatConstraints.left-&gt;x &lt;= lineLogicalLeft)
370             floatConstraints.left = { };
371 
372         if (floatConstraints.right &amp;&amp; floatConstraints.right-&gt;x &gt;= lineLogicalRight)
373             floatConstraints.right = { };
374 
375         lineIsConstrainedByFloat = floatConstraints.left || floatConstraints.right;
376 
377         if (floatConstraints.left &amp;&amp; floatConstraints.right) {
378             ASSERT(floatConstraints.left-&gt;x &lt;= floatConstraints.right-&gt;x);
379             lineLogicalRight = floatConstraints.right-&gt;x;
380             lineLogicalLeft = floatConstraints.left-&gt;x;
381         } else if (floatConstraints.left) {
382             ASSERT(floatConstraints.left-&gt;x &gt;= lineLogicalLeft);
383             lineLogicalLeft = floatConstraints.left-&gt;x;
384         } else if (floatConstraints.right) {
385             ASSERT(floatConstraints.right-&gt;x &gt;= lineLogicalLeft);
386             lineLogicalRight = floatConstraints.right-&gt;x;
387         }
388     }
389 
390     auto computedTextIndent = [&amp;] {
391         // text-indent property specifies the indentation applied to lines of inline content in a block.
392         // The indent is treated as a margin applied to the start edge of the line box.
393         // Unless otherwise specified, only lines that are the first formatted line of an element are affected.
394         // For example, the first line of an anonymous block box is only affected if it is the first child of its parent element.
395         // FIXME: Add support for each-line.
396         // [Integration] root()-&gt;parent() would normally produce a valid layout box.
397         auto&amp; root = this-&gt;root();
398         auto isFormattingContextRootCandidateToTextIndent = !root.isAnonymous();
399         if (root.isAnonymous()) {
400             // Unless otherwise specified by the each-line and/or hanging keywords, only lines that are the first formatted line
401             // of an element are affected.
402             // For example, the first line of an anonymous block box is only affected if it is the first child of its parent element.
403             isFormattingContextRootCandidateToTextIndent = RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled()
404                 ? layoutState().isIntegratedRootBoxFirstChild()
405                 : root.parent()-&gt;firstInFlowChild() == &amp;root;
406         }
407         if (!isFormattingContextRootCandidateToTextIndent)
408             return InlineLayoutUnit { };
409         auto invertLineRange = false;
410 #if ENABLE(CSS3_TEXT)
411         invertLineRange = root.style().textIndentType() == TextIndentType::Hanging;
412 #endif
413         auto isFirstLine = formattingState().ensureDisplayInlineContent().lineBoxes.isEmpty();
414         // text-indent: hanging inverts which lines are affected.
415         // inverted line range -&gt; all the lines except the first one.
416         // !inverted line range -&gt; first line gets the indent.
417         auto shouldIndent = invertLineRange != isFirstLine;
418         if (!shouldIndent)
419             return InlineLayoutUnit { };
420         return geometry().computedTextIndent(root, horizontalConstraints).valueOr(InlineLayoutUnit { });
421     };
422     lineLogicalLeft += computedTextIndent();
423     return LineBuilder::Constraints { { lineLogicalLeft, lineLogicalTop }, lineLogicalRight - lineLogicalLeft, lineIsConstrainedByFloat, lineHeightAndBaseline };
424 }
425 
426 void InlineFormattingContext::setDisplayBoxesForLine(const LineLayoutContext::LineContent&amp; lineContent, const HorizontalConstraints&amp; horizontalConstraints)
427 {
428     auto&amp; formattingState = this-&gt;formattingState();
429     auto&amp; lineBox = lineContent.lineBox;
430 
431     if (!lineContent.floats.isEmpty()) {
432         auto floatingContext = FloatingContext { root(), *this, formattingState.floatingState() };
433         // Move floats to their final position.
434         for (const auto&amp; floatItem : lineContent.floats) {
435             auto&amp; floatBox = floatItem-&gt;layoutBox();
436             auto&amp; displayBox = formattingState.displayBox(floatBox);
437             // Set static position first.
438             displayBox.setTopLeft({ lineBox.logicalLeft(), lineBox.logicalTop() });
439             // Float it.
440             displayBox.setTopLeft(floatingContext.positionForFloat(floatBox));
441             floatingContext.append(floatBox);
442         }
443     }
444 
445     auto initialContaingBlockSize = LayoutSize { };
446     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextIntegrationEnabled()) {
447         // ICB is not the real ICB when lyoutFormattingContextIntegrationEnabled is on.
448         initialContaingBlockSize = layoutState().viewportSize();
449     } else
450         initialContaingBlockSize = geometryForBox(root().initialContainingBlock(), EscapeReason::StrokeOverflowNeedsViewportGeometry).contentBox().size();
451     auto&amp; inlineContent = formattingState.ensureDisplayInlineContent();
452     auto lineIndex = inlineContent.lineBoxes.size();
453     auto lineInkOverflow = lineBox.scrollableOverflow();
454     Optional&lt;unsigned&gt; lastTextItemIndex;
455     // Compute box final geometry.
456     auto&amp; lineRuns = lineContent.runList;
457     for (unsigned index = 0; index &lt; lineRuns.size(); ++index) {
458         auto&amp; lineRun = lineRuns.at(index);
459         auto&amp; logicalRect = lineRun.logicalRect();
460         auto&amp; layoutBox = lineRun.layoutBox();
461         auto&amp; displayBox = formattingState.displayBox(layoutBox);
462 
463         // Add final display runs to state first.
464         // Inline level containers (&lt;span&gt;) don&#39;t generate display runs and neither do completely collapsed runs.
465         auto initiatesInlineRun = !lineRun.isContainerStart() &amp;&amp; !lineRun.isContainerEnd();
466         if (initiatesInlineRun) {
467             auto computedInkOverflow = [&amp;] {
468                 // FIXME: Add support for non-text ink overflow.
469                 if (!lineRun.isText())
470                     return logicalRect;
471                 auto&amp; style = lineRun.style();
472                 auto inkOverflow = logicalRect;
473                 auto strokeOverflow = std::ceil(style.computedStrokeWidth(ceiledIntSize(initialContaingBlockSize)));
474                 inkOverflow.inflate(strokeOverflow);
475 
476                 auto letterSpacing = style.fontCascade().letterSpacing();
477                 if (letterSpacing &lt; 0) {
478                     // Last letter&#39;s negative spacing shrinks logical rect. Push it to ink overflow.
479                     inkOverflow.expandHorizontally(-letterSpacing);
480                 }
481                 return inkOverflow;
482             };
483             auto inkOverflow = computedInkOverflow();
484             lineInkOverflow.expandToContain(inkOverflow);
485             inlineContent.runs.append({ lineIndex, lineRun.layoutBox(), logicalRect, inkOverflow, lineRun.textContext() });
486         }
487 
488         if (lineRun.isLineBreak()) {
489             displayBox.setTopLeft(toLayoutPoint(logicalRect.topLeft()));
490             displayBox.setContentBoxWidth(toLayoutUnit(logicalRect.width()));
491             displayBox.setContentBoxHeight(toLayoutUnit(logicalRect.height()));
492             continue;
493         }
494 
495         // Inline level box (replaced or inline-block)
496         if (lineRun.isBox()) {
497             auto topLeft = logicalRect.topLeft();
498             if (layoutBox.isInFlowPositioned())
499                 topLeft += geometry().inFlowPositionedPositionOffset(layoutBox, horizontalConstraints);
500             displayBox.setTopLeft(toLayoutPoint(topLeft));
501             continue;
502         }
503 
504         // Inline level container start (&lt;span&gt;)
505         if (lineRun.isContainerStart()) {
506             displayBox.setTopLeft(toLayoutPoint(logicalRect.topLeft()));
507             continue;
508         }
509 
510         // Inline level container end (&lt;/span&gt;)
511         if (lineRun.isContainerEnd()) {
512             if (layoutBox.isInFlowPositioned()) {
513                 auto inflowOffset = geometry().inFlowPositionedPositionOffset(layoutBox, horizontalConstraints);
514                 displayBox.moveHorizontally(inflowOffset.width());
515                 displayBox.moveVertically(inflowOffset.height());
516             }
517             auto marginBoxWidth = logicalRect.left() - displayBox.left();
518             auto contentBoxWidth = marginBoxWidth - (displayBox.marginStart() + displayBox.borderLeft() + displayBox.paddingLeft().valueOr(0));
519             // FIXME fix it for multiline.
520             displayBox.setContentBoxWidth(toLayoutUnit(contentBoxWidth));
521             displayBox.setContentBoxHeight(toLayoutUnit(logicalRect.height()));
522             continue;
523         }
524 
525         if (lineRun.isText()) {
526             lastTextItemIndex = inlineContent.runs.size() - 1;
527             auto firstRunForLayoutBox = !index || &amp;lineRuns[index - 1].layoutBox() != &amp;layoutBox;
528             if (firstRunForLayoutBox) {
529                 // Setup display box for the associated layout box.
530                 displayBox.setTopLeft(toLayoutPoint(logicalRect.topLeft()));
531                 displayBox.setContentBoxWidth(toLayoutUnit(logicalRect.width()));
532                 displayBox.setContentBoxHeight(toLayoutUnit(logicalRect.height()));
533             } else {
534                 // FIXME fix it for multirun/multiline.
535                 displayBox.setContentBoxWidth(toLayoutUnit(displayBox.contentBoxWidth() + logicalRect.width()));
536             }
537             continue;
538         }
539         ASSERT_NOT_REACHED();
540     }
541     // Make sure the trailing text run gets a hyphen when it needs one.
542     if (lineContent.partialContent &amp;&amp; lineContent.partialContent-&gt;trailingContentNeedsHyphen)
543         inlineContent.runs[*lastTextItemIndex].textContext()-&gt;setNeedsHyphen();
544     // FIXME: This is where the logical to physical translate should happen.
545     auto&amp; baseline = lineBox.baseline();
546     inlineContent.lineBoxes.append({ lineBox.logicalRect(), lineBox.scrollableOverflow(), lineInkOverflow, { baseline.ascent(), baseline.descent() }, lineBox.baselineOffset(), lineBox.isConsideredEmpty() });
547 }
548 
549 void InlineFormattingContext::invalidateFormattingState(const InvalidationState&amp;)
550 {
551     // Find out what we need to invalidate. This is where we add some smarts to do partial line layout.
552     // For now let&#39;s just clear the runs.
553     formattingState().clearDisplayInlineContent();
554     // FIXME: This is also where we would delete inline items if their content changed.
555 }
556 
557 }
558 }
559 
560 #endif
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmBBQPlan.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WasmBBQPlan.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;B3Compilation.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 32 #include &quot;JSToWasm.h&quot;</span>
 33 #include &quot;WasmAirIRGenerator.h&quot;
 34 #include &quot;WasmB3IRGenerator.h&quot;
 35 #include &quot;WasmBinding.h&quot;
 36 #include &quot;WasmCallee.h&quot;
 37 #include &quot;WasmCallingConvention.h&quot;
 38 #include &quot;WasmFaultSignalHandler.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 39 #include &quot;WasmMachineThreads.h&quot;</span>
 40 #include &quot;WasmMemory.h&quot;
<a name="3" id="anc3"></a>
 41 #include &quot;WasmSignatureInlines.h&quot;
 42 #include &quot;WasmTierUpCount.h&quot;
<a name="4" id="anc4"></a>
 43 #include &lt;wtf/DataLog.h&gt;
 44 #include &lt;wtf/Locker.h&gt;
 45 #include &lt;wtf/MonotonicTime.h&gt;
 46 #include &lt;wtf/StdLibExtras.h&gt;
 47 #include &lt;wtf/SystemTracing.h&gt;
 48 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 49 
 50 namespace JSC { namespace Wasm {
 51 
 52 namespace WasmBBQPlanInternal {
<a name="5" id="anc5"></a><span class="line-modified"> 53 static constexpr bool verbose = false;</span>
 54 }
 55 
<a name="6" id="anc6"></a><span class="line-modified"> 56 BBQPlan::BBQPlan(Context* context, Ref&lt;ModuleInformation&gt; moduleInformation, uint32_t functionIndex, CodeBlock* codeBlock, CompletionTask&amp;&amp; completionTask)</span>
<span class="line-modified"> 57     : EntryPlan(context, WTFMove(moduleInformation), AsyncWork::FullCompile, WTFMove(completionTask))</span>
<span class="line-modified"> 58     , m_codeBlock(codeBlock)</span>
<span class="line-modified"> 59     , m_functionIndex(functionIndex)</span>
 60 {
<a name="7" id="anc7"></a><span class="line-added"> 61     setMode(m_codeBlock-&gt;mode());</span>
 62 }
 63 
<a name="8" id="anc8"></a><span class="line-modified"> 64 bool BBQPlan::prepareImpl()</span>




 65 {
<a name="9" id="anc9"></a><span class="line-modified"> 66     const auto&amp; functions = m_moduleInformation-&gt;functions;</span>
<span class="line-added"> 67     if (!tryReserveCapacity(m_wasmInternalFunctions, functions.size(), &quot; WebAssembly functions&quot;)</span>
<span class="line-added"> 68         || !tryReserveCapacity(m_compilationContexts, functions.size(), &quot; compilation contexts&quot;)</span>
<span class="line-added"> 69         || !tryReserveCapacity(m_tierUpCounts, functions.size(), &quot; tier-up counts&quot;))</span>
<span class="line-added"> 70         return false;</span>
 71 
<a name="10" id="anc10"></a><span class="line-modified"> 72     m_wasmInternalFunctions.resize(functions.size());</span>
<span class="line-modified"> 73     m_compilationContexts.resize(functions.size());</span>
<span class="line-modified"> 74     m_tierUpCounts.resize(functions.size());</span>
<span class="line-modified"> 75 </span>
<span class="line-modified"> 76     return true;</span>
 77 }
 78 
<a name="11" id="anc11"></a><span class="line-modified"> 79 void BBQPlan::work(CompilationEffort effort)</span>
 80 {
<a name="12" id="anc12"></a><span class="line-modified"> 81     if (!m_codeBlock) {</span>
<span class="line-modified"> 82         switch (m_state) {</span>
<span class="line-modified"> 83         case State::Initial:</span>
<span class="line-modified"> 84             parseAndValidateModule();</span>
<span class="line-modified"> 85             if (!hasWork()) {</span>
<span class="line-modified"> 86                 ASSERT(m_state == State::Validated);</span>
<span class="line-added"> 87                 complete(holdLock(m_lock));</span>
<span class="line-added"> 88                 break;</span>
<span class="line-added"> 89             }</span>
<span class="line-added"> 90             FALLTHROUGH;</span>
<span class="line-added"> 91         case State::Validated:</span>
<span class="line-added"> 92             prepare();</span>
<span class="line-added"> 93             break;</span>
<span class="line-added"> 94         case State::Prepared:</span>
<span class="line-added"> 95             compileFunctions(effort);</span>
<span class="line-added"> 96             break;</span>
<span class="line-added"> 97         default:</span>
<span class="line-added"> 98             break;</span>
<span class="line-added"> 99         }</span>
<span class="line-added">100         return;</span>
101     }
<a name="13" id="anc13"></a>

102 
<a name="14" id="anc14"></a><span class="line-modified">103     CompilationContext context;</span>
<span class="line-modified">104     Vector&lt;UnlinkedWasmToWasmCall&gt; unlinkedWasmToWasmCalls;</span>
<span class="line-modified">105     std::unique_ptr&lt;TierUpCount&gt; tierUp = makeUnique&lt;TierUpCount&gt;();</span>
<span class="line-modified">106     std::unique_ptr&lt;InternalFunction&gt; function = compileFunction(m_functionIndex, context, unlinkedWasmToWasmCalls, tierUp.get());</span>


107 
<a name="15" id="anc15"></a><span class="line-modified">108     LinkBuffer linkBuffer(*context.wasmEntrypointJIT, nullptr, JITCompilationCanFail);</span>
<span class="line-modified">109     if (UNLIKELY(linkBuffer.didFailToAllocate())) {</span>
<span class="line-modified">110         Base::fail(holdLock(m_lock), makeString(&quot;Out of executable memory while tiering up function at index &quot;, String::number(m_functionIndex)));</span>
<span class="line-modified">111         return;</span>
<span class="line-added">112     }</span>
113 
<a name="16" id="anc16"></a><span class="line-modified">114     size_t functionIndexSpace = m_functionIndex + m_moduleInformation-&gt;importFunctionCount();</span>
<span class="line-modified">115     SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[m_functionIndex];</span>
<span class="line-modified">116     const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-modified">117     function-&gt;entrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(</span>
<span class="line-added">118         FINALIZE_WASM_CODE_FOR_MODE(CompilationMode::BBQMode, linkBuffer, B3CompilationPtrTag, &quot;WebAssembly BBQ function[%i] %s name %s&quot;, m_functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
<span class="line-added">119         WTFMove(context.wasmEntrypointByproducts));</span>
120 
<a name="17" id="anc17"></a><span class="line-added">121     MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; entrypoint;</span>
122     {
<a name="18" id="anc18"></a><span class="line-modified">123         Ref&lt;BBQCallee&gt; callee = BBQCallee::create(WTFMove(function-&gt;entrypoint), functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace), WTFMove(tierUp), WTFMove(unlinkedWasmToWasmCalls));</span>
<span class="line-modified">124         MacroAssembler::repatchPointer(function-&gt;calleeMoveLocation, CalleeBits::boxWasm(callee.ptr()));</span>
<span class="line-modified">125         ASSERT(!m_codeBlock-&gt;m_bbqCallees[m_functionIndex]);</span>
<span class="line-modified">126         entrypoint = callee-&gt;entrypoint();</span>
<span class="line-modified">127 </span>
<span class="line-added">128         // We want to make sure we publish our callee at the same time as we link our callsites. This enables us to ensure we</span>
<span class="line-added">129         // always call the fastest code. Any function linked after us will see our new code and the new callsites, which they</span>
<span class="line-added">130         // will update. It&#39;s also ok if they publish their code before we reset the instruction caches because after we release</span>
<span class="line-added">131         // the lock our code is ready to be published too.</span>
<span class="line-added">132         LockHolder holder(m_codeBlock-&gt;m_lock);</span>
<span class="line-added">133         m_codeBlock-&gt;m_bbqCallees[m_functionIndex] = callee.copyRef();</span>
<span class="line-added">134         {</span>
<span class="line-added">135             LLIntCallee&amp; llintCallee = m_codeBlock-&gt;m_llintCallees-&gt;at(m_functionIndex).get();</span>
<span class="line-added">136             auto locker = holdLock(llintCallee.tierUpCounter().m_lock);</span>
<span class="line-added">137             llintCallee.setReplacement(callee.copyRef());</span>
<span class="line-added">138             llintCallee.tierUpCounter().m_compilationStatus = LLIntTierUpCounter::CompilationStatus::Compiled;</span>
<span class="line-added">139         }</span>
<span class="line-added">140         for (auto&amp; call : callee-&gt;wasmToWasmCallsites()) {</span>
<span class="line-added">141             MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; entrypoint;</span>
<span class="line-added">142             if (call.functionIndexSpace &lt; m_moduleInformation-&gt;importFunctionCount())</span>
<span class="line-added">143                 entrypoint = m_codeBlock-&gt;m_wasmToWasmExitStubs[call.functionIndexSpace].code();</span>
<span class="line-added">144             else</span>
<span class="line-added">145                 entrypoint = m_codeBlock-&gt;wasmEntrypointCalleeFromFunctionIndexSpace(call.functionIndexSpace).entrypoint().retagged&lt;WasmEntryPtrTag&gt;();</span>
<span class="line-added">146 </span>
<span class="line-added">147             MacroAssembler::repatchNearCall(call.callLocation, CodeLocationLabel&lt;WasmEntryPtrTag&gt;(entrypoint));</span>
148         }
149     }
150 
<a name="19" id="anc19"></a><span class="line-modified">151     // It&#39;s important to make sure we do this before we make any of the code we just compiled visible. If we didn&#39;t, we could end up</span>
<span class="line-modified">152     // where we are tiering up some function A to A&#39; and we repatch some function B to call A&#39; instead of A. Another CPU could see</span>
<span class="line-modified">153     // the updates to B but still not have reset its cache of A&#39;, which would lead to all kinds of badness.</span>
<span class="line-modified">154     resetInstructionCacheOnAllThreads();</span>
<span class="line-modified">155     WTF::storeStoreFence(); // This probably isn&#39;t necessary but it&#39;s good to be paranoid.</span>




156 
<a name="20" id="anc20"></a><span class="line-modified">157     m_codeBlock-&gt;m_wasmIndirectCallEntryPoints[m_functionIndex] = entrypoint;</span>
<span class="line-modified">158     {</span>
<span class="line-modified">159         LockHolder holder(m_codeBlock-&gt;m_lock);</span>
<span class="line-modified">160 </span>
<span class="line-modified">161         auto repatchCalls = [&amp;] (const Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; callsites) {</span>
<span class="line-modified">162             for (auto&amp; call : callsites) {</span>
<span class="line-added">163                 dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Considering repatching call at: &quot;, RawPointer(call.callLocation.dataLocation()), &quot; that targets &quot;, call.functionIndexSpace);</span>
<span class="line-added">164                 if (call.functionIndexSpace == functionIndexSpace) {</span>
<span class="line-added">165                     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Repatching call at: &quot;, RawPointer(call.callLocation.dataLocation()), &quot; to &quot;, RawPointer(entrypoint.executableAddress()));</span>
<span class="line-added">166                     MacroAssembler::repatchNearCall(call.callLocation, CodeLocationLabel&lt;WasmEntryPtrTag&gt;(entrypoint));</span>
<span class="line-added">167                 }</span>
<span class="line-added">168             }</span>
<span class="line-added">169         };</span>
<span class="line-added">170 </span>
<span class="line-added">171         for (unsigned i = 0; i &lt; m_codeBlock-&gt;m_wasmToWasmCallsites.size(); ++i) {</span>
<span class="line-added">172             repatchCalls(m_codeBlock-&gt;m_wasmToWasmCallsites[i]);</span>
<span class="line-added">173             if (m_codeBlock-&gt;m_llintCallees) {</span>
<span class="line-added">174                 LLIntCallee&amp; llintCallee = m_codeBlock-&gt;m_llintCallees-&gt;at(i).get();</span>
<span class="line-added">175                 if (JITCallee* replacementCallee = llintCallee.replacement())</span>
<span class="line-added">176                     repatchCalls(replacementCallee-&gt;wasmToWasmCallsites());</span>
<span class="line-added">177                 if (OMGForOSREntryCallee* osrEntryCallee = llintCallee.osrEntryCallee())</span>
<span class="line-added">178                     repatchCalls(osrEntryCallee-&gt;wasmToWasmCallsites());</span>
<span class="line-added">179             }</span>
<span class="line-added">180             if (BBQCallee* bbqCallee = m_codeBlock-&gt;m_bbqCallees[i].get()) {</span>
<span class="line-added">181                 if (OMGCallee* replacementCallee = bbqCallee-&gt;replacement())</span>
<span class="line-added">182                     repatchCalls(replacementCallee-&gt;wasmToWasmCallsites());</span>
<span class="line-added">183                 if (OMGForOSREntryCallee* osrEntryCallee = bbqCallee-&gt;osrEntryCallee())</span>
<span class="line-added">184                     repatchCalls(osrEntryCallee-&gt;wasmToWasmCallsites());</span>
185             }
<a name="21" id="anc21"></a>

186         }
187     }
188 
<a name="22" id="anc22"></a><span class="line-modified">189     dataLogLnIf(WasmBBQPlanInternal::verbose, &quot;Finished BBQ &quot;, m_functionIndex);</span>

190 
<a name="23" id="anc23"></a><span class="line-modified">191 </span>
<span class="line-modified">192     auto locker = holdLock(m_lock);</span>
<span class="line-modified">193     moveToState(State::Completed);</span>
<span class="line-modified">194     runCompletionTasks(locker);</span>
195 }
196 
<a name="24" id="anc24"></a><span class="line-modified">197 void BBQPlan::compileFunction(uint32_t functionIndex)</span>
198 {
<a name="25" id="anc25"></a><span class="line-modified">199     m_unlinkedWasmToWasmCalls[functionIndex] = Vector&lt;UnlinkedWasmToWasmCall&gt;();</span>









200 
<a name="26" id="anc26"></a><span class="line-modified">201     if (Options::useBBQTierUpChecks())</span>
<span class="line-modified">202         m_tierUpCounts[functionIndex] = makeUnique&lt;TierUpCount&gt;();</span>
<span class="line-modified">203     else</span>
<span class="line-modified">204         m_tierUpCounts[functionIndex] = nullptr;</span>



205 
<a name="27" id="anc27"></a><span class="line-modified">206     m_wasmInternalFunctions[functionIndex] = compileFunction(functionIndex, m_compilationContexts[functionIndex], m_unlinkedWasmToWasmCalls[functionIndex], m_tierUpCounts[functionIndex].get());</span>




















207 
<a name="28" id="anc28"></a><span class="line-modified">208     if (m_exportedFunctionIndices.contains(functionIndex) || m_moduleInformation-&gt;referencedFunctions().contains(functionIndex)) {</span>
<span class="line-modified">209         auto locker = holdLock(m_lock);</span>
<span class="line-modified">210         SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-modified">211         const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-added">212         auto result = m_embedderToWasmInternalFunctions.add(functionIndex, createJSToWasmWrapper(*m_compilationContexts[functionIndex].embedderEntrypointJIT, signature, &amp;m_unlinkedWasmToWasmCalls[functionIndex], m_moduleInformation.get(), m_mode, functionIndex));</span>
<span class="line-added">213         ASSERT_UNUSED(result, result.isNewEntry);</span>
214     }
<a name="29" id="anc29"></a><span class="line-added">215 }</span>
216 
<a name="30" id="anc30"></a><span class="line-modified">217 std::unique_ptr&lt;InternalFunction&gt; BBQPlan::compileFunction(uint32_t functionIndex, CompilationContext&amp; context, Vector&lt;UnlinkedWasmToWasmCall&gt;&amp; unlinkedWasmToWasmCalls, TierUpCount* tierUp)</span>
<span class="line-modified">218 {</span>
<span class="line-modified">219     const auto&amp; function = m_moduleInformation-&gt;functions[functionIndex];</span>
<span class="line-modified">220     SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-added">221     const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-added">222     unsigned functionIndexSpace = m_moduleInformation-&gt;importFunctionCount() + functionIndex;</span>
<span class="line-added">223     ASSERT_UNUSED(functionIndexSpace, m_moduleInformation-&gt;signatureIndexFromFunctionIndexSpace(functionIndexSpace) == signatureIndex);</span>
<span class="line-added">224     Expected&lt;std::unique_ptr&lt;InternalFunction&gt;, String&gt; parseAndCompileResult;</span>
<span class="line-added">225     unsigned osrEntryScratchBufferSize = 0;</span>
<span class="line-added">226 </span>
<span class="line-added">227     // FIXME: Some webpages use very large Wasm module, and it exhausts all executable memory in ARM64 devices since the size of executable memory region is only limited to 128MB.</span>
<span class="line-added">228     // The long term solution should be to introduce a Wasm interpreter. But as a short term solution, we introduce heuristics to switch back to BBQ B3 at the sacrifice of start-up time,</span>
<span class="line-added">229     // as BBQ Air bloats such lengthy Wasm code and will consume a large amount of executable memory.</span>
<span class="line-added">230     bool forceUsingB3 = false;</span>
<span class="line-added">231     if (Options::webAssemblyBBQAirModeThreshold() &amp;&amp; m_moduleInformation-&gt;codeSectionSize &gt;= Options::webAssemblyBBQAirModeThreshold())</span>
<span class="line-added">232         forceUsingB3 = true;</span>
<span class="line-added">233 </span>
<span class="line-added">234     if (!forceUsingB3 &amp;&amp; Options::wasmBBQUsesAir())</span>
<span class="line-added">235         parseAndCompileResult = parseAndCompileAir(context, function, signature, unlinkedWasmToWasmCalls, m_moduleInformation.get(), m_mode, functionIndex, tierUp);</span>
<span class="line-added">236     else</span>
<span class="line-added">237         parseAndCompileResult = parseAndCompile(context, function, signature, unlinkedWasmToWasmCalls, osrEntryScratchBufferSize, m_moduleInformation.get(), m_mode, CompilationMode::BBQMode, functionIndex, UINT32_MAX, tierUp);</span>
<span class="line-added">238 </span>
<span class="line-added">239     if (UNLIKELY(!parseAndCompileResult)) {</span>
<span class="line-added">240         auto locker = holdLock(m_lock);</span>
<span class="line-added">241         if (!m_errorMessage) {</span>
<span class="line-added">242             // Multiple compiles could fail simultaneously. We arbitrarily choose the first.</span>
<span class="line-added">243             fail(locker, makeString(parseAndCompileResult.error(), &quot;, in function at index &quot;, String::number(functionIndex))); // FIXME make this an Expected.</span>
244         }
<a name="31" id="anc31"></a><span class="line-added">245         m_currentIndex = m_moduleInformation-&gt;functions.size();</span>
<span class="line-added">246         return nullptr;</span>
247     }
248 
<a name="32" id="anc32"></a><span class="line-modified">249     return WTFMove(*parseAndCompileResult);</span>



250 }
251 
<a name="33" id="anc33"></a><span class="line-modified">252 void BBQPlan::didCompleteCompilation(const AbstractLocker&amp; locker)</span>






















253 {
<a name="34" id="anc34"></a><span class="line-modified">254     for (uint32_t functionIndex = 0; functionIndex &lt; m_moduleInformation-&gt;functions.size(); functionIndex++) {</span>
<span class="line-modified">255         CompilationContext&amp; context = m_compilationContexts[functionIndex];</span>
<span class="line-modified">256         SignatureIndex signatureIndex = m_moduleInformation-&gt;internalFunctionSignatureIndices[functionIndex];</span>
<span class="line-modified">257         const Signature&amp; signature = SignatureInformation::get(signatureIndex);</span>
<span class="line-modified">258         const uint32_t functionIndexSpace = functionIndex + m_moduleInformation-&gt;importFunctionCount();</span>
<span class="line-modified">259         ASSERT(functionIndexSpace &lt; m_moduleInformation-&gt;functionIndexSpaceSize());</span>












260         {
<a name="35" id="anc35"></a><span class="line-modified">261             LinkBuffer linkBuffer(*context.wasmEntrypointJIT, nullptr, JITCompilationCanFail);</span>
<span class="line-modified">262             if (UNLIKELY(linkBuffer.didFailToAllocate())) {</span>
<span class="line-modified">263                 Base::fail(locker, makeString(&quot;Out of executable memory in function at index &quot;, String::number(functionIndex)));</span>

264                 return;
265             }
<a name="36" id="anc36"></a>


266 
<a name="37" id="anc37"></a><span class="line-modified">267             m_wasmInternalFunctions[functionIndex]-&gt;entrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(</span>
<span class="line-modified">268                 FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;WebAssembly BBQ function[%i] %s name %s&quot;, functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
<span class="line-modified">269                 WTFMove(context.wasmEntrypointByproducts));</span>

































270         }
271 
<a name="38" id="anc38"></a><span class="line-modified">272         if (const auto&amp; embedderToWasmInternalFunction = m_embedderToWasmInternalFunctions.get(functionIndex)) {</span>
<span class="line-added">273             LinkBuffer linkBuffer(*context.embedderEntrypointJIT, nullptr, JITCompilationCanFail);</span>
<span class="line-added">274             if (UNLIKELY(linkBuffer.didFailToAllocate())) {</span>
<span class="line-added">275                 Base::fail(locker, makeString(&quot;Out of executable memory in function entrypoint at index &quot;, String::number(functionIndex)));</span>
<span class="line-added">276                 return;</span>
<span class="line-added">277             }</span>
278 
<a name="39" id="anc39"></a><span class="line-modified">279             embedderToWasmInternalFunction-&gt;entrypoint.compilation = makeUnique&lt;B3::Compilation&gt;(</span>
<span class="line-modified">280                 FINALIZE_CODE(linkBuffer, B3CompilationPtrTag, &quot;Embedder-&gt;WebAssembly entrypoint[%i] %s name %s&quot;, functionIndex, signature.toString().ascii().data(), makeString(IndexOrName(functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace))).ascii().data()),</span>
<span class="line-modified">281                 WTFMove(context.embedderEntrypointByproducts));</span>

282         }
<a name="40" id="anc40"></a><span class="line-added">283     }</span>
284 
<a name="41" id="anc41"></a><span class="line-modified">285     for (auto&amp; unlinked : m_unlinkedWasmToWasmCalls) {</span>
<span class="line-added">286         for (auto&amp; call : unlinked) {</span>
<span class="line-added">287             MacroAssemblerCodePtr&lt;WasmEntryPtrTag&gt; executableAddress;</span>
<span class="line-added">288             if (m_moduleInformation-&gt;isImportedFunctionFromFunctionIndexSpace(call.functionIndexSpace)) {</span>
<span class="line-added">289                 // FIXME imports could have been linked in B3, instead of generating a patchpoint. This condition should be replaced by a RELEASE_ASSERT. https://bugs.webkit.org/show_bug.cgi?id=166462</span>
<span class="line-added">290                 executableAddress = m_wasmToWasmExitStubs.at(call.functionIndexSpace).code();</span>
<span class="line-added">291             } else</span>
<span class="line-added">292                 executableAddress = m_wasmInternalFunctions.at(call.functionIndexSpace - m_moduleInformation-&gt;importFunctionCount())-&gt;entrypoint.compilation-&gt;code().retagged&lt;WasmEntryPtrTag&gt;();</span>
<span class="line-added">293             MacroAssembler::repatchNearCall(call.callLocation, CodeLocationLabel&lt;WasmEntryPtrTag&gt;(executableAddress));</span>
<span class="line-added">294         }</span>
295     }
296 }
297 
<a name="42" id="anc42"></a><span class="line-modified">298 void BBQPlan::initializeCallees(const CalleeInitializer&amp; callback)</span>
299 {
<a name="43" id="anc43"></a><span class="line-modified">300     ASSERT(!failed());</span>
<span class="line-modified">301     for (unsigned internalFunctionIndex = 0; internalFunctionIndex &lt; m_wasmInternalFunctions.size(); ++internalFunctionIndex) {</span>


























302 
<a name="44" id="anc44"></a><span class="line-modified">303         RefPtr&lt;EmbedderEntrypointCallee&gt; embedderEntrypointCallee;</span>
<span class="line-modified">304         if (auto embedderToWasmFunction = m_embedderToWasmInternalFunctions.get(internalFunctionIndex)) {</span>
<span class="line-modified">305             embedderEntrypointCallee = EmbedderEntrypointCallee::create(WTFMove(embedderToWasmFunction-&gt;entrypoint));</span>
<span class="line-modified">306             MacroAssembler::repatchPointer(embedderToWasmFunction-&gt;calleeMoveLocation, CalleeBits::boxWasm(embedderEntrypointCallee.get()));</span>
307         }
308 
<a name="45" id="anc45"></a><span class="line-modified">309         InternalFunction* function = m_wasmInternalFunctions[internalFunctionIndex].get();</span>
<span class="line-modified">310         size_t functionIndexSpace = internalFunctionIndex + m_moduleInformation-&gt;importFunctionCount();</span>
<span class="line-modified">311         Ref&lt;BBQCallee&gt; wasmEntrypointCallee = BBQCallee::create(WTFMove(function-&gt;entrypoint), functionIndexSpace, m_moduleInformation-&gt;nameSection-&gt;get(functionIndexSpace), WTFMove(m_tierUpCounts[internalFunctionIndex]), WTFMove(m_unlinkedWasmToWasmCalls[internalFunctionIndex]));</span>
<span class="line-modified">312         MacroAssembler::repatchPointer(function-&gt;calleeMoveLocation, CalleeBits::boxWasm(wasmEntrypointCallee.ptr()));</span>








313 
<a name="46" id="anc46"></a><span class="line-modified">314         callback(internalFunctionIndex, WTFMove(embedderEntrypointCallee), WTFMove(wasmEntrypointCallee));</span>


315     }
316 }
317 
<a name="47" id="anc47"></a><span class="line-modified">318 bool BBQPlan::didReceiveFunctionData(unsigned, const FunctionData&amp;)</span>
319 {
<a name="48" id="anc48"></a><span class="line-modified">320     return true;</span>

















321 }
322 
323 } } // namespace JSC::Wasm
324 
325 #endif // ENABLE(WEBASSEMBLY)
<a name="49" id="anc49"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="49" type="hidden" />
</body>
</html>
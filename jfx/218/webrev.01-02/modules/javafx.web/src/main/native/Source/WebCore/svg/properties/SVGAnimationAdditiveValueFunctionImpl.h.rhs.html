<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGAnimationAdditiveValueFunctionImpl.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2018-2019 Apple Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;Color.h&quot;
 29 #include &quot;FloatRect.h&quot;
 30 #include &quot;SVGAngleValue.h&quot;
 31 #include &quot;SVGAnimationAdditiveValueFunction.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 32 #include &quot;SVGLengthContext.h&quot;</span>
 33 #include &quot;SVGLengthValue.h&quot;
 34 #include &quot;SVGPathByteStream.h&quot;
 35 #include &quot;SVGPropertyTraits.h&quot;
 36 
<a name="2" id="anc2"></a><span class="line-added"> 37 #if PLATFORM(JAVA)</span>
<span class="line-added"> 38 #include &lt;wtf/java/JavaMath.h&gt;</span>
<span class="line-added"> 39 #endif</span>
<span class="line-added"> 40 </span>
 41 namespace WebCore {
 42 
 43 class SVGAnimationAngleFunction : public SVGAnimationAdditiveValueFunction&lt;SVGAngleValue&gt; {
 44 public:
 45     using Base = SVGAnimationAdditiveValueFunction&lt;SVGAngleValue&gt;;
 46     using Base::Base;
 47 
 48     void setFromAndToValues(SVGElement*, const String&amp;, const String&amp;) override
 49     {
 50         // Values will be set by SVGAnimatedAngleOrientAnimator.
 51         ASSERT_NOT_REACHED();
 52     }
 53 
 54     void animate(SVGElement*, float progress, unsigned repeatCount, SVGAngleValue&amp; animated)
 55     {
 56         float number = animated.value();
 57         number = Base::animate(progress, repeatCount, m_from.value(), m_to.value(), toAtEndOfDuration().value(), number);
 58         animated.setValue(number);
 59     }
 60 
 61 private:
 62     friend class SVGAnimatedAngleOrientAnimator;
 63 
 64     void addFromAndToValues(SVGElement*) override
 65     {
 66         m_to.setValue(m_to.value() + m_from.value());
 67     }
 68 };
 69 
 70 class SVGAnimationColorFunction : public SVGAnimationAdditiveValueFunction&lt;Color&gt; {
 71 public:
 72     using Base = SVGAnimationAdditiveValueFunction&lt;Color&gt;;
 73     using Base::Base;
 74 
 75     void setFromAndToValues(SVGElement* targetElement, const String&amp; from, const String&amp; to) override
 76     {
 77         m_from = colorFromString(targetElement, from);
 78         m_to = colorFromString(targetElement, to);
 79     }
 80 
 81     void setToAtEndOfDurationValue(const String&amp; toAtEndOfDuration) override
 82     {
 83         m_toAtEndOfDuration = SVGPropertyTraits&lt;Color&gt;::fromString(toAtEndOfDuration);
 84     }
 85 
 86     void animate(SVGElement*, float progress, unsigned repeatCount, Color&amp; animated)
 87     {
 88         Color from = m_animationMode == AnimationMode::To ? animated : m_from;
 89 
 90         float red = Base::animate(progress, repeatCount, from.red(), m_to.red(), toAtEndOfDuration().red(), animated.red());
 91         float green = Base::animate(progress, repeatCount, from.green(), m_to.green(), toAtEndOfDuration().green(), animated.green());
 92         float blue = Base::animate(progress, repeatCount, from.blue(), m_to.blue(), toAtEndOfDuration().blue(), animated.blue());
 93         float alpha = Base::animate(progress, repeatCount, from.alpha(), m_to.alpha(), toAtEndOfDuration().alpha(), animated.alpha());
 94 
 95         animated = { roundAndClampColorChannel(red), roundAndClampColorChannel(green), roundAndClampColorChannel(blue), roundAndClampColorChannel(alpha) };
 96     }
 97 
 98     Optional&lt;float&gt; calculateDistance(SVGElement*, const String&amp; from, const String&amp; to) const override
 99     {
100         Color fromColor = CSSParser::parseColor(from.stripWhiteSpace());
101         if (!fromColor.isValid())
102             return { };
103         Color toColor = CSSParser::parseColor(to.stripWhiteSpace());
104         if (!toColor.isValid())
105             return { };
106         float red = fromColor.red() - toColor.red();
107         float green = fromColor.green() - toColor.green();
108         float blue = fromColor.blue() - toColor.blue();
<a name="3" id="anc3"></a><span class="line-modified">109 #if PLATFORM(JAVA)</span>
<span class="line-added">110         return javamath::hypot(red, green, blue);</span>
<span class="line-added">111 #else</span>
<span class="line-added">112         return std::hypot(red, green, blue);</span>
<span class="line-added">113 #endif</span>
114     }
115 
116 private:
117     void addFromAndToValues(SVGElement*) override
118     {
119         // Ignores any alpha and sets alpha on result to 100% opaque.
120         m_to = {
121             roundAndClampColorChannel(m_to.red() + m_from.red()),
122             roundAndClampColorChannel(m_to.green() + m_from.green()),
123             roundAndClampColorChannel(m_to.blue() + m_from.blue())
124         };
125     }
126 
127     static Color colorFromString(SVGElement*, const String&amp;);
128 };
129 
130 class SVGAnimationIntegerFunction : public SVGAnimationAdditiveValueFunction&lt;int&gt; {
131     friend class SVGAnimatedIntegerPairAnimator;
132 
133 public:
134     using Base = SVGAnimationAdditiveValueFunction&lt;int&gt;;
135     using Base::Base;
136 
137     void setFromAndToValues(SVGElement*, const String&amp; from, const String&amp; to) override
138     {
139         m_from = SVGPropertyTraits&lt;int&gt;::fromString(from);
140         m_to = SVGPropertyTraits&lt;int&gt;::fromString(to);
141     }
142 
143     void setToAtEndOfDurationValue(const String&amp; toAtEndOfDuration) override
144     {
145         m_toAtEndOfDuration = SVGPropertyTraits&lt;int&gt;::fromString(toAtEndOfDuration);
146     }
147 
148     void animate(SVGElement*, float progress, unsigned repeatCount, int&amp; animated)
149     {
150         animated = static_cast&lt;int&gt;(roundf(Base::animate(progress, repeatCount, m_from, m_to, toAtEndOfDuration(), animated)));
151     }
152 
153     Optional&lt;float&gt; calculateDistance(SVGElement*, const String&amp; from, const String&amp; to) const override
154     {
155         return std::abs(to.toIntStrict() - from.toIntStrict());
156     }
157 
158 private:
159     void addFromAndToValues(SVGElement*) override
160     {
161         m_to += m_from;
162     }
163 };
164 
165 class SVGAnimationLengthFunction : public SVGAnimationAdditiveValueFunction&lt;SVGLengthValue&gt; {
166     using Base = SVGAnimationAdditiveValueFunction&lt;SVGLengthValue&gt;;
167 
168 public:
169     SVGAnimationLengthFunction(AnimationMode animationMode, CalcMode calcMode, bool isAccumulated, bool isAdditive, SVGLengthMode lengthMode)
170         : Base(animationMode, calcMode, isAccumulated, isAdditive)
171         , m_lengthMode(lengthMode)
172     {
173     }
174 
175     void setFromAndToValues(SVGElement*, const String&amp; from, const String&amp; to) override
176     {
177         m_from = SVGLengthValue(m_lengthMode, from);
178         m_to = SVGLengthValue(m_lengthMode, to);
179     }
180 
181     void setToAtEndOfDurationValue(const String&amp; toAtEndOfDuration) override
182     {
183         m_toAtEndOfDuration = SVGLengthValue(m_lengthMode, toAtEndOfDuration);
184     }
185 
186     void animate(SVGElement* targetElement, float progress, unsigned repeatCount, SVGLengthValue&amp; animated)
187     {
188         SVGLengthContext lengthContext(targetElement);
<a name="4" id="anc4"></a><span class="line-modified">189         SVGLengthType lengthType = progress &lt; 0.5 ? m_from.lengthType() : m_to.lengthType();</span>
190 
191         float from = (m_animationMode == AnimationMode::To ? animated : m_from).value(lengthContext);
192         float to = m_to.value(lengthContext);
193         float toAtEndOfDuration = this-&gt;toAtEndOfDuration().value(lengthContext);
194         float value = animated.value(lengthContext);
195 
196         value = Base::animate(progress, repeatCount, from, to, toAtEndOfDuration, value);
<a name="5" id="anc5"></a><span class="line-modified">197         animated = { lengthContext, value, lengthType, m_lengthMode };</span>
198     }
199 
200     Optional&lt;float&gt; calculateDistance(SVGElement* targetElement, const String&amp; from, const String&amp; to) const override
201     {
202         SVGLengthContext lengthContext(targetElement);
203         auto fromLength = SVGLengthValue(m_lengthMode, from);
204         auto toLength = SVGLengthValue(m_lengthMode, to);
205         return fabsf(toLength.value(lengthContext) - fromLength.value(lengthContext));
206     }
207 
208 private:
209     void addFromAndToValues(SVGElement* targetElement) override
210     {
211         SVGLengthContext lengthContext(targetElement);
<a name="6" id="anc6"></a><span class="line-modified">212         m_to.setValue(lengthContext, m_to.value(lengthContext) + m_from.value(lengthContext));</span>
213     }
214 
215     SVGLengthMode m_lengthMode;
216 };
217 
218 class SVGAnimationNumberFunction : public SVGAnimationAdditiveValueFunction&lt;float&gt; {
219     friend class SVGAnimatedNumberPairAnimator;
220 
221 public:
222     using Base = SVGAnimationAdditiveValueFunction&lt;float&gt;;
223     using Base::Base;
224 
225     void setFromAndToValues(SVGElement*, const String&amp; from, const String&amp; to) override
226     {
227         m_from = SVGPropertyTraits&lt;float&gt;::fromString(from);
228         m_to = SVGPropertyTraits&lt;float&gt;::fromString(to);
229     }
230 
231     void setToAtEndOfDurationValue(const String&amp; toAtEndOfDuration) override
232     {
233         m_toAtEndOfDuration = SVGPropertyTraits&lt;float&gt;::fromString(toAtEndOfDuration);
234     }
235 
236     void animate(SVGElement*, float progress, unsigned repeatCount, float&amp; animated)
237     {
238         float from = m_animationMode == AnimationMode::To ? animated : m_from;
239         animated = Base::animate(progress, repeatCount, from, m_to, toAtEndOfDuration(), animated);
240     }
241 
242     Optional&lt;float&gt; calculateDistance(SVGElement*, const String&amp; from, const String&amp; to) const override
243     {
244         float fromNumber = 0;
245         float toNumber = 0;
246         parseNumberFromString(from, fromNumber);
247         parseNumberFromString(to, toNumber);
248         return fabsf(toNumber - fromNumber);
249     }
250 
251 private:
252     void addFromAndToValues(SVGElement*) override
253     {
254         m_to += m_from;
255     }
256 };
257 
258 class SVGAnimationPathSegListFunction : public SVGAnimationAdditiveValueFunction&lt;SVGPathByteStream&gt; {
259 public:
260     using Base = SVGAnimationAdditiveValueFunction&lt;SVGPathByteStream&gt;;
261     using Base::Base;
262 
263     void setFromAndToValues(SVGElement*, const String&amp; from, const String&amp; to) override
264     {
265         m_from = SVGPathByteStream(from);
266         m_to = SVGPathByteStream(to);
267     }
268 
269     void setToAtEndOfDurationValue(const String&amp; toAtEndOfDuration) override
270     {
271         m_toAtEndOfDuration = SVGPathByteStream(toAtEndOfDuration);
272     }
273 
274     void animate(SVGElement*, float progress, unsigned repeatCount, SVGPathByteStream&amp; animated)
275     {
276         SVGPathByteStream underlyingPath;
277         if (m_animationMode == AnimationMode::To)
278             underlyingPath = animated;
279 
280         const SVGPathByteStream&amp; from = m_animationMode == AnimationMode::To ? underlyingPath : m_from;
281 
282         // Cache the current animated value before the buildAnimatedSVGPathByteStream() clears animatedPath.
283         SVGPathByteStream lastAnimated;
284         if (!from.size() || (m_isAdditive &amp;&amp; m_animationMode != AnimationMode::To))
285             lastAnimated = animated;
286 
287         buildAnimatedSVGPathByteStream(from, m_to, animated, progress);
288 
289         // Handle additive=&#39;sum&#39;.
290         if (!lastAnimated.isEmpty())
291             addToSVGPathByteStream(animated, lastAnimated);
292 
293         // Handle accumulate=&#39;sum&#39;.
294         if (m_isAccumulated &amp;&amp; repeatCount)
295             addToSVGPathByteStream(animated, toAtEndOfDuration(), repeatCount);
296     }
297 
298 private:
299     void addFromAndToValues(SVGElement*) override
300     {
301         if (!m_from.size() || m_from.size() != m_to.size())
302             return;
303         addToSVGPathByteStream(m_to, m_from);
304     }
305 };
306 
307 class SVGAnimationRectFunction : public SVGAnimationAdditiveValueFunction&lt;FloatRect&gt; {
308 public:
309     using Base = SVGAnimationAdditiveValueFunction&lt;FloatRect&gt;;
310     using Base::Base;
311 
312     void setFromAndToValues(SVGElement*, const String&amp; from, const String&amp; to) override
313     {
314         m_from = SVGPropertyTraits&lt;FloatRect&gt;::fromString(from);
315         m_to = SVGPropertyTraits&lt;FloatRect&gt;::fromString(to);
316     }
317 
318     void setToAtEndOfDurationValue(const String&amp; toAtEndOfDuration) override
319     {
320         m_toAtEndOfDuration = SVGPropertyTraits&lt;FloatRect&gt;::fromString(toAtEndOfDuration);
321     }
322 
323     void animate(SVGElement*, float progress, unsigned repeatCount, FloatRect&amp; animated)
324     {
325         FloatRect from = m_animationMode == AnimationMode::To ? animated : m_from;
326 
327         float x = Base::animate(progress, repeatCount, from.x(), m_to.x(), toAtEndOfDuration().x(), animated.x());
328         float y = Base::animate(progress, repeatCount, from.y(), m_to.y(), toAtEndOfDuration().y(), animated.y());
329         float width = Base::animate(progress, repeatCount, from.width(), m_to.width(), toAtEndOfDuration().width(), animated.width());
330         float height = Base::animate(progress, repeatCount, from.height(), m_to.height(), toAtEndOfDuration().height(), animated.height());
331 
332         animated = { x, y, width, height };
333     }
334 
335 private:
336     void addFromAndToValues(SVGElement*) override
337     {
338         m_to += m_from;
339     }
340 };
341 
342 }
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
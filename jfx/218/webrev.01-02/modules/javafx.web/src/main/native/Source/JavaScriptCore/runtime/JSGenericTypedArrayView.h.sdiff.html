<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayView.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSGeneratorFunction.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGenericTypedArrayViewConstructorInlines.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSGenericTypedArrayView.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013, 2016 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 76 //     typedef Int8Array ViewType;
 77 //     typedef JSInt8Array JSViewType;
 78 //     static int8_t toNativeFromInt32(int32_t);
 79 //     static int8_t toNativeFromUint32(uint32_t);
 80 //     static int8_t toNativeFromDouble(double);
 81 //     static JSValue toJSValue(int8_t);
 82 //     static double toDouble(int8_t);
 83 //     template&lt;T&gt; static T::Type convertTo(uint8_t);
 84 // };
 85 
 86 enum class CopyType {
 87     LeftToRight,
 88     Unobservable,
 89 };
 90 
 91 static const ASCIILiteral typedArrayBufferHasBeenDetachedErrorMessage { &quot;Underlying ArrayBuffer has been detached from the view&quot;_s };
 92 
 93 template&lt;typename Adaptor&gt;
 94 class JSGenericTypedArrayView final : public JSArrayBufferView {
 95 public:
<span class="line-modified"> 96     typedef JSArrayBufferView Base;</span>
 97     typedef typename Adaptor::Type ElementType;
 98 
<span class="line-modified"> 99     static const unsigned StructureFlags = Base::StructureFlags | OverridesGetPropertyNames | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero;</span>
100 
<span class="line-modified">101     static const unsigned elementSize = sizeof(typename Adaptor::Type);</span>
102 
103 protected:
104     JSGenericTypedArrayView(VM&amp;, ConstructionContext&amp;);
105 
106 public:
<span class="line-modified">107     static JSGenericTypedArrayView* create(ExecState*, Structure*, unsigned length);</span>
<span class="line-modified">108     static JSGenericTypedArrayView* createWithFastVector(ExecState*, Structure*, unsigned length, void* vector);</span>
<span class="line-modified">109     static JSGenericTypedArrayView* createUninitialized(ExecState*, Structure*, unsigned length);</span>
<span class="line-modified">110     static JSGenericTypedArrayView* create(ExecState*, Structure*, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;, unsigned byteOffset, unsigned length);</span>
111     static JSGenericTypedArrayView* create(VM&amp;, Structure*, RefPtr&lt;typename Adaptor::ViewType&gt;&amp;&amp; impl);
112     static JSGenericTypedArrayView* create(Structure*, JSGlobalObject*, RefPtr&lt;typename Adaptor::ViewType&gt;&amp;&amp; impl);
113 
114     unsigned byteLength() const { return m_length * sizeof(typename Adaptor::Type); }
115     size_t byteSize() const { return sizeOf(m_length, sizeof(typename Adaptor::Type)); }
116 
117     const typename Adaptor::Type* typedVector() const
118     {
119         return bitwise_cast&lt;const typename Adaptor::Type*&gt;(vector());
120     }
121     typename Adaptor::Type* typedVector()
122     {
123         return bitwise_cast&lt;typename Adaptor::Type*&gt;(vector());
124     }
125 
126     // These methods are meant to match indexed access methods that JSObject
127     // supports - hence the slight redundancy.
128     bool canGetIndexQuickly(unsigned i) const
129     {
130         return i &lt; m_length;
</pre>
<hr />
<pre>
150         return Adaptor::toJSValue(getIndexQuicklyAsNativeValue(i));
151     }
152 
153     void setIndexQuicklyToNativeValue(unsigned i, typename Adaptor::Type value)
154     {
155         ASSERT(i &lt; m_length);
156         typedVector()[i] = value;
157     }
158 
159     void setIndexQuicklyToDouble(unsigned i, double value)
160     {
161         setIndexQuicklyToNativeValue(i, toNativeFromValue&lt;Adaptor&gt;(jsNumber(value)));
162     }
163 
164     void setIndexQuickly(unsigned i, JSValue value)
165     {
166         ASSERT(!value.isObject());
167         setIndexQuicklyToNativeValue(i, toNativeFromValue&lt;Adaptor&gt;(value));
168     }
169 
<span class="line-modified">170     bool setIndex(ExecState* exec, unsigned i, JSValue jsValue)</span>
171     {
<span class="line-modified">172         VM&amp; vm = exec-&gt;vm();</span>
173         auto scope = DECLARE_THROW_SCOPE(vm);
174 
<span class="line-modified">175         typename Adaptor::Type value = toNativeFromValue&lt;Adaptor&gt;(exec, jsValue);</span>
176         RETURN_IF_EXCEPTION(scope, false);
177 
178         if (isNeutered()) {
<span class="line-modified">179             throwTypeError(exec, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
180             return false;
181         }
182 
183         if (i &gt;= m_length)
184             return false;
185 
186         setIndexQuicklyToNativeValue(i, value);
187         return true;
188     }
189 
<span class="line-modified">190     static ElementType toAdaptorNativeFromValue(ExecState* exec, JSValue jsValue) { return toNativeFromValue&lt;Adaptor&gt;(exec, jsValue); }</span>
191 
192     static Optional&lt;ElementType&gt; toAdaptorNativeFromValueWithoutCoercion(JSValue jsValue) { return toNativeFromValueWithoutCoercion&lt;Adaptor&gt;(jsValue); }
193 
194     void sort()
195     {
196         RELEASE_ASSERT(!isNeutered());
197         switch (Adaptor::typeValue) {
198         case TypeFloat32:
199             sortFloat&lt;int32_t&gt;();
200             break;
201         case TypeFloat64:
202             sortFloat&lt;int64_t&gt;();
203             break;
204         default: {
205             ElementType* array = typedVector();
206             std::sort(array, array + m_length);
207             break;
208         }
209         }
210     }
211 
212     bool canAccessRangeQuickly(unsigned offset, unsigned length)
213     {
214         return offset &lt;= m_length
215             &amp;&amp; offset + length &lt;= m_length
216             // check overflow
217             &amp;&amp; offset + length &gt;= offset;
218     }
219 
220     // Like canSetQuickly, except: if it returns false, it will throw the
221     // appropriate exception.
<span class="line-modified">222     bool validateRange(ExecState*, unsigned offset, unsigned length);</span>
223 
224     // Returns true if successful, and false on error; if it returns false
225     // then it will have thrown an exception.
<span class="line-modified">226     bool set(ExecState*, unsigned offset, JSObject*, unsigned objectOffset, unsigned length, CopyType type = CopyType::Unobservable);</span>
227 
228     RefPtr&lt;typename Adaptor::ViewType&gt; possiblySharedTypedImpl();
229     RefPtr&lt;typename Adaptor::ViewType&gt; unsharedTypedImpl();
230 
231     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
232     {
233         return Structure::create(vm, globalObject, prototype, TypeInfo(typeForTypedArrayType(Adaptor::typeValue), StructureFlags), info(), NonArray);
234     }
235 
236     static const ClassInfo s_info; // This is never accessed directly, since that would break linkage on some compilers.
237 
238     static const ClassInfo* info()
239     {
240         switch (Adaptor::typeValue) {
241         case TypeInt8:
242             return getInt8ArrayClassInfo();
243         case TypeInt16:
244             return getInt16ArrayClassInfo();
245         case TypeInt32:
246             return getInt32ArrayClassInfo();
247         case TypeUint8:
248             return getUint8ArrayClassInfo();
249         case TypeUint8Clamped:
250             return getUint8ClampedArrayClassInfo();
251         case TypeUint16:
252             return getUint16ArrayClassInfo();
253         case TypeUint32:
254             return getUint32ArrayClassInfo();
255         case TypeFloat32:
256             return getFloat32ArrayClassInfo();
257         case TypeFloat64:
258             return getFloat64ArrayClassInfo();
259         default:
260             RELEASE_ASSERT_NOT_REACHED();
<span class="line-modified">261             return 0;</span>




























262         }
263     }
264 
265     ArrayBuffer* existingBuffer();
266 
267     static const TypedArrayType TypedArrayStorageType = Adaptor::typeValue;
268 
269     // This is the default DOM unwrapping. It calls toUnsharedNativeTypedView().
270     static RefPtr&lt;typename Adaptor::ViewType&gt; toWrapped(VM&amp;, JSValue);
271 
272 protected:
273     friend struct TypedArrayClassInfos;
274 
<span class="line-modified">275     static EncodedJSValue throwNeuteredTypedArrayTypeError(ExecState*, EncodedJSValue, PropertyName);</span>
276 
<span class="line-modified">277     static bool getOwnPropertySlot(JSObject*, ExecState*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified">278     static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="line-modified">279     static bool defineOwnProperty(JSObject*, ExecState*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);</span>
<span class="line-modified">280     static bool deleteProperty(JSCell*, ExecState*, PropertyName);</span>
281 
<span class="line-modified">282     static bool getOwnPropertySlotByIndex(JSObject*, ExecState*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="line-modified">283     static bool putByIndex(JSCell*, ExecState*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="line-modified">284     static bool deletePropertyByIndex(JSCell*, ExecState*, unsigned propertyName);</span>
285 
<span class="line-modified">286     static void getOwnPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
287 
288     static size_t estimatedSize(JSCell*, VM&amp;);
289     static void visitChildren(JSCell*, SlotVisitor&amp;);
290 
291 private:
292     // Returns true if successful, and false on error; it will throw on error.
293     template&lt;typename OtherAdaptor&gt;
294     bool setWithSpecificType(
<span class="line-modified">295         ExecState*, unsigned offset, JSGenericTypedArrayView&lt;OtherAdaptor&gt;*,</span>
296         unsigned objectOffset, unsigned length, CopyType);
297 
298     // The ECMA 6 spec states that floating point Typed Arrays should have the following ordering:
299     //
300     // -Inifinity &lt; negative finite numbers &lt; -0.0 &lt; 0.0 &lt; positive finite numbers &lt; Infinity &lt; NaN
301     // Note: regardless of the sign or exact representation of a NaN it is greater than all other values.
302     //
303     // An interesting fact about IEEE 754 floating point numbers is that have an adjacent representation
304     // i.e. for any finite floating point x there does not exist a finite floating point y such that
305     // ((float) ((int) x + 1)) &gt; y &gt; x (where int represents a signed bit integer with the same number
306     // of bits as float). Thus, if we have an array of floating points if we view it as an
307     // array of signed bit integers it will sort in the format we desire. Note, denormal
308     // numbers fit this property as they are floating point numbers with a exponent field of all
309     // zeros so they will be closer to the signed zeros than any normalized number.
310     //
311     // All the processors we support, however, use twos complement. Fortunately, if you compare a signed
312     // bit number as if it were twos complement the result will be correct assuming both numbers are not
313     // negative. e.g.
314     //
315     //    - &lt;=&gt; - = reversed (-30 &gt; -20 = true)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 76 //     typedef Int8Array ViewType;
 77 //     typedef JSInt8Array JSViewType;
 78 //     static int8_t toNativeFromInt32(int32_t);
 79 //     static int8_t toNativeFromUint32(uint32_t);
 80 //     static int8_t toNativeFromDouble(double);
 81 //     static JSValue toJSValue(int8_t);
 82 //     static double toDouble(int8_t);
 83 //     template&lt;T&gt; static T::Type convertTo(uint8_t);
 84 // };
 85 
 86 enum class CopyType {
 87     LeftToRight,
 88     Unobservable,
 89 };
 90 
 91 static const ASCIILiteral typedArrayBufferHasBeenDetachedErrorMessage { &quot;Underlying ArrayBuffer has been detached from the view&quot;_s };
 92 
 93 template&lt;typename Adaptor&gt;
 94 class JSGenericTypedArrayView final : public JSArrayBufferView {
 95 public:
<span class="line-modified"> 96     using Base = JSArrayBufferView;</span>
 97     typedef typename Adaptor::Type ElementType;
 98 
<span class="line-modified"> 99     static constexpr unsigned StructureFlags = Base::StructureFlags | OverridesGetPropertyNames | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero;</span>
100 
<span class="line-modified">101     static constexpr unsigned elementSize = sizeof(typename Adaptor::Type);</span>
102 
103 protected:
104     JSGenericTypedArrayView(VM&amp;, ConstructionContext&amp;);
105 
106 public:
<span class="line-modified">107     static JSGenericTypedArrayView* create(JSGlobalObject*, Structure*, unsigned length);</span>
<span class="line-modified">108     static JSGenericTypedArrayView* createWithFastVector(JSGlobalObject*, Structure*, unsigned length, void* vector);</span>
<span class="line-modified">109     static JSGenericTypedArrayView* createUninitialized(JSGlobalObject*, Structure*, unsigned length);</span>
<span class="line-modified">110     static JSGenericTypedArrayView* create(JSGlobalObject*, Structure*, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;, unsigned byteOffset, unsigned length);</span>
111     static JSGenericTypedArrayView* create(VM&amp;, Structure*, RefPtr&lt;typename Adaptor::ViewType&gt;&amp;&amp; impl);
112     static JSGenericTypedArrayView* create(Structure*, JSGlobalObject*, RefPtr&lt;typename Adaptor::ViewType&gt;&amp;&amp; impl);
113 
114     unsigned byteLength() const { return m_length * sizeof(typename Adaptor::Type); }
115     size_t byteSize() const { return sizeOf(m_length, sizeof(typename Adaptor::Type)); }
116 
117     const typename Adaptor::Type* typedVector() const
118     {
119         return bitwise_cast&lt;const typename Adaptor::Type*&gt;(vector());
120     }
121     typename Adaptor::Type* typedVector()
122     {
123         return bitwise_cast&lt;typename Adaptor::Type*&gt;(vector());
124     }
125 
126     // These methods are meant to match indexed access methods that JSObject
127     // supports - hence the slight redundancy.
128     bool canGetIndexQuickly(unsigned i) const
129     {
130         return i &lt; m_length;
</pre>
<hr />
<pre>
150         return Adaptor::toJSValue(getIndexQuicklyAsNativeValue(i));
151     }
152 
153     void setIndexQuicklyToNativeValue(unsigned i, typename Adaptor::Type value)
154     {
155         ASSERT(i &lt; m_length);
156         typedVector()[i] = value;
157     }
158 
159     void setIndexQuicklyToDouble(unsigned i, double value)
160     {
161         setIndexQuicklyToNativeValue(i, toNativeFromValue&lt;Adaptor&gt;(jsNumber(value)));
162     }
163 
164     void setIndexQuickly(unsigned i, JSValue value)
165     {
166         ASSERT(!value.isObject());
167         setIndexQuicklyToNativeValue(i, toNativeFromValue&lt;Adaptor&gt;(value));
168     }
169 
<span class="line-modified">170     bool setIndex(JSGlobalObject* globalObject, unsigned i, JSValue jsValue)</span>
171     {
<span class="line-modified">172         VM&amp; vm = getVM(globalObject);</span>
173         auto scope = DECLARE_THROW_SCOPE(vm);
174 
<span class="line-modified">175         typename Adaptor::Type value = toNativeFromValue&lt;Adaptor&gt;(globalObject, jsValue);</span>
176         RETURN_IF_EXCEPTION(scope, false);
177 
178         if (isNeutered()) {
<span class="line-modified">179             throwTypeError(globalObject, scope, typedArrayBufferHasBeenDetachedErrorMessage);</span>
180             return false;
181         }
182 
183         if (i &gt;= m_length)
184             return false;
185 
186         setIndexQuicklyToNativeValue(i, value);
187         return true;
188     }
189 
<span class="line-modified">190     static ElementType toAdaptorNativeFromValue(JSGlobalObject* globalObject, JSValue jsValue) { return toNativeFromValue&lt;Adaptor&gt;(globalObject, jsValue); }</span>
191 
192     static Optional&lt;ElementType&gt; toAdaptorNativeFromValueWithoutCoercion(JSValue jsValue) { return toNativeFromValueWithoutCoercion&lt;Adaptor&gt;(jsValue); }
193 
194     void sort()
195     {
196         RELEASE_ASSERT(!isNeutered());
197         switch (Adaptor::typeValue) {
198         case TypeFloat32:
199             sortFloat&lt;int32_t&gt;();
200             break;
201         case TypeFloat64:
202             sortFloat&lt;int64_t&gt;();
203             break;
204         default: {
205             ElementType* array = typedVector();
206             std::sort(array, array + m_length);
207             break;
208         }
209         }
210     }
211 
212     bool canAccessRangeQuickly(unsigned offset, unsigned length)
213     {
214         return offset &lt;= m_length
215             &amp;&amp; offset + length &lt;= m_length
216             // check overflow
217             &amp;&amp; offset + length &gt;= offset;
218     }
219 
220     // Like canSetQuickly, except: if it returns false, it will throw the
221     // appropriate exception.
<span class="line-modified">222     bool validateRange(JSGlobalObject*, unsigned offset, unsigned length);</span>
223 
224     // Returns true if successful, and false on error; if it returns false
225     // then it will have thrown an exception.
<span class="line-modified">226     bool set(JSGlobalObject*, unsigned offset, JSObject*, unsigned objectOffset, unsigned length, CopyType type = CopyType::Unobservable);</span>
227 
228     RefPtr&lt;typename Adaptor::ViewType&gt; possiblySharedTypedImpl();
229     RefPtr&lt;typename Adaptor::ViewType&gt; unsharedTypedImpl();
230 
231     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
232     {
233         return Structure::create(vm, globalObject, prototype, TypeInfo(typeForTypedArrayType(Adaptor::typeValue), StructureFlags), info(), NonArray);
234     }
235 
236     static const ClassInfo s_info; // This is never accessed directly, since that would break linkage on some compilers.
237 
238     static const ClassInfo* info()
239     {
240         switch (Adaptor::typeValue) {
241         case TypeInt8:
242             return getInt8ArrayClassInfo();
243         case TypeInt16:
244             return getInt16ArrayClassInfo();
245         case TypeInt32:
246             return getInt32ArrayClassInfo();
247         case TypeUint8:
248             return getUint8ArrayClassInfo();
249         case TypeUint8Clamped:
250             return getUint8ClampedArrayClassInfo();
251         case TypeUint16:
252             return getUint16ArrayClassInfo();
253         case TypeUint32:
254             return getUint32ArrayClassInfo();
255         case TypeFloat32:
256             return getFloat32ArrayClassInfo();
257         case TypeFloat64:
258             return getFloat64ArrayClassInfo();
259         default:
260             RELEASE_ASSERT_NOT_REACHED();
<span class="line-modified">261             return nullptr;</span>
<span class="line-added">262         }</span>
<span class="line-added">263     }</span>
<span class="line-added">264 </span>
<span class="line-added">265     template&lt;typename CellType, SubspaceAccess mode&gt;</span>
<span class="line-added">266     static IsoSubspace* subspaceFor(VM&amp; vm)</span>
<span class="line-added">267     {</span>
<span class="line-added">268         switch (Adaptor::typeValue) {</span>
<span class="line-added">269         case TypeInt8:</span>
<span class="line-added">270             return vm.int8ArraySpace&lt;mode&gt;();</span>
<span class="line-added">271         case TypeInt16:</span>
<span class="line-added">272             return vm.int16ArraySpace&lt;mode&gt;();</span>
<span class="line-added">273         case TypeInt32:</span>
<span class="line-added">274             return vm.int32ArraySpace&lt;mode&gt;();</span>
<span class="line-added">275         case TypeUint8:</span>
<span class="line-added">276             return vm.uint8ArraySpace&lt;mode&gt;();</span>
<span class="line-added">277         case TypeUint8Clamped:</span>
<span class="line-added">278             return vm.uint8ClampedArraySpace&lt;mode&gt;();</span>
<span class="line-added">279         case TypeUint16:</span>
<span class="line-added">280             return vm.uint16ArraySpace&lt;mode&gt;();</span>
<span class="line-added">281         case TypeUint32:</span>
<span class="line-added">282             return vm.uint32ArraySpace&lt;mode&gt;();</span>
<span class="line-added">283         case TypeFloat32:</span>
<span class="line-added">284             return vm.float32ArraySpace&lt;mode&gt;();</span>
<span class="line-added">285         case TypeFloat64:</span>
<span class="line-added">286             return vm.float64ArraySpace&lt;mode&gt;();</span>
<span class="line-added">287         default:</span>
<span class="line-added">288             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-added">289             return nullptr;</span>
290         }
291     }
292 
293     ArrayBuffer* existingBuffer();
294 
295     static const TypedArrayType TypedArrayStorageType = Adaptor::typeValue;
296 
297     // This is the default DOM unwrapping. It calls toUnsharedNativeTypedView().
298     static RefPtr&lt;typename Adaptor::ViewType&gt; toWrapped(VM&amp;, JSValue);
299 
300 protected:
301     friend struct TypedArrayClassInfos;
302 
<span class="line-modified">303     static EncodedJSValue throwNeuteredTypedArrayTypeError(JSGlobalObject*, EncodedJSValue, PropertyName);</span>
304 
<span class="line-modified">305     static bool getOwnPropertySlot(JSObject*, JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified">306     static bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="line-modified">307     static bool defineOwnProperty(JSObject*, JSGlobalObject*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);</span>
<span class="line-modified">308     static bool deleteProperty(JSCell*, JSGlobalObject*, PropertyName);</span>
309 
<span class="line-modified">310     static bool getOwnPropertySlotByIndex(JSObject*, JSGlobalObject*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="line-modified">311     static bool putByIndex(JSCell*, JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="line-modified">312     static bool deletePropertyByIndex(JSCell*, JSGlobalObject*, unsigned propertyName);</span>
313 
<span class="line-modified">314     static void getOwnPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
315 
316     static size_t estimatedSize(JSCell*, VM&amp;);
317     static void visitChildren(JSCell*, SlotVisitor&amp;);
318 
319 private:
320     // Returns true if successful, and false on error; it will throw on error.
321     template&lt;typename OtherAdaptor&gt;
322     bool setWithSpecificType(
<span class="line-modified">323         JSGlobalObject*, unsigned offset, JSGenericTypedArrayView&lt;OtherAdaptor&gt;*,</span>
324         unsigned objectOffset, unsigned length, CopyType);
325 
326     // The ECMA 6 spec states that floating point Typed Arrays should have the following ordering:
327     //
328     // -Inifinity &lt; negative finite numbers &lt; -0.0 &lt; 0.0 &lt; positive finite numbers &lt; Infinity &lt; NaN
329     // Note: regardless of the sign or exact representation of a NaN it is greater than all other values.
330     //
331     // An interesting fact about IEEE 754 floating point numbers is that have an adjacent representation
332     // i.e. for any finite floating point x there does not exist a finite floating point y such that
333     // ((float) ((int) x + 1)) &gt; y &gt; x (where int represents a signed bit integer with the same number
334     // of bits as float). Thus, if we have an array of floating points if we view it as an
335     // array of signed bit integers it will sort in the format we desire. Note, denormal
336     // numbers fit this property as they are floating point numbers with a exponent field of all
337     // zeros so they will be closer to the signed zeros than any normalized number.
338     //
339     // All the processors we support, however, use twos complement. Fortunately, if you compare a signed
340     // bit number as if it were twos complement the result will be correct assuming both numbers are not
341     // negative. e.g.
342     //
343     //    - &lt;=&gt; - = reversed (-30 &gt; -20 = true)
</pre>
</td>
</tr>
</table>
<center><a href="JSGeneratorFunction.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSGenericTypedArrayViewConstructorInlines.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
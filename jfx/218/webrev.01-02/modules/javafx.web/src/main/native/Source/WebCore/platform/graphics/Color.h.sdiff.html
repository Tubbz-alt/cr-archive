<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Color.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Color.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ColorSpace.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Color.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2003-2016 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 35 #include &lt;wtf/Optional.h&gt;
 36 #include &lt;wtf/text/LChar.h&gt;
 37 
 38 #if USE(CG)
 39 typedef struct CGColor* CGColorRef;
 40 #endif
 41 
 42 #if PLATFORM(WIN)
 43 struct _D3DCOLORVALUE;
 44 typedef _D3DCOLORVALUE D3DCOLORVALUE;
 45 typedef D3DCOLORVALUE D2D_COLOR_F;
 46 typedef D2D_COLOR_F D2D1_COLOR_F;
 47 struct D2D_VECTOR_4F;
 48 typedef D2D_VECTOR_4F D2D1_VECTOR_4F;
 49 #endif
 50 
 51 #if PLATFORM(GTK)
 52 typedef struct _GdkRGBA GdkRGBA;
 53 #endif
 54 
<span class="line-removed"> 55 namespace WTF {</span>
<span class="line-removed"> 56 class TextStream;</span>
<span class="line-removed"> 57 }</span>
<span class="line-removed"> 58 </span>
 59 namespace WebCore {
 60 
<span class="line-modified"> 61 typedef unsigned RGBA32; // Deprecated: Type for an RGBA quadruplet. Use RGBA class instead.</span>




























 62 
 63 WEBCORE_EXPORT RGBA32 makeRGB(int r, int g, int b);
 64 WEBCORE_EXPORT RGBA32 makeRGBA(int r, int g, int b, int a);
 65 
 66 RGBA32 makePremultipliedRGBA(int r, int g, int b, int a, bool ceiling = true);
 67 RGBA32 makeUnPremultipliedRGBA(int r, int g, int b, int a);
 68 
 69 WEBCORE_EXPORT RGBA32 colorWithOverrideAlpha(RGBA32 color, float overrideAlpha);
 70 RGBA32 colorWithOverrideAlpha(RGBA32 color, Optional&lt;float&gt; overrideAlpha);
 71 
 72 WEBCORE_EXPORT RGBA32 makeRGBA32FromFloats(float r, float g, float b, float a);
<span class="line-modified"> 73 RGBA32 makeRGBAFromHSLA(double h, double s, double l, double a);</span>
 74 RGBA32 makeRGBAFromCMYKA(float c, float m, float y, float k, float a);
 75 
<span class="line-removed"> 76 inline int redChannel(RGBA32 color) { return (color &gt;&gt; 16) &amp; 0xFF; }</span>
<span class="line-removed"> 77 inline int greenChannel(RGBA32 color) { return (color &gt;&gt; 8) &amp; 0xFF; }</span>
<span class="line-removed"> 78 inline int blueChannel(RGBA32 color) { return color &amp; 0xFF; }</span>
<span class="line-removed"> 79 inline int alphaChannel(RGBA32 color) { return (color &gt;&gt; 24) &amp; 0xFF; }</span>
<span class="line-removed"> 80 </span>
 81 uint8_t roundAndClampColorChannel(int);
 82 uint8_t roundAndClampColorChannel(float);
 83 
<span class="line-removed"> 84 class RGBA {</span>
<span class="line-removed"> 85 public:</span>
<span class="line-removed"> 86     RGBA(); // all channels zero, including alpha</span>
<span class="line-removed"> 87     RGBA(uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha);</span>
<span class="line-removed"> 88     RGBA(uint8_t red, uint8_t green, uint8_t blue); // opaque, alpha of 1</span>
<span class="line-removed"> 89 </span>
<span class="line-removed"> 90     uint8_t red() const;</span>
<span class="line-removed"> 91     uint8_t green() const;</span>
<span class="line-removed"> 92     uint8_t blue() const;</span>
<span class="line-removed"> 93     uint8_t alpha() const;</span>
<span class="line-removed"> 94 </span>
<span class="line-removed"> 95     bool hasAlpha() const;</span>
<span class="line-removed"> 96 </span>
<span class="line-removed"> 97 private:</span>
<span class="line-removed"> 98     friend class Color;</span>
<span class="line-removed"> 99 </span>
<span class="line-removed">100     unsigned m_integer { 0 };</span>
<span class="line-removed">101 };</span>
<span class="line-removed">102 </span>
<span class="line-removed">103 bool operator==(const RGBA&amp;, const RGBA&amp;);</span>
<span class="line-removed">104 bool operator!=(const RGBA&amp;, const RGBA&amp;);</span>
<span class="line-removed">105 </span>
106 class Color {
107     WTF_MAKE_FAST_ALLOCATED;
108 public:
109     Color() { }
110 
111     // FIXME: Remove all these constructors and creation functions and replace the ones that are still needed with free functions.
112 
113     Color(RGBA32 color, bool valid = true)
114     {
115         if (valid)
116             setRGB(color);
117     }
118 
119     enum SemanticTag { Semantic };
<span class="line-removed">120 </span>
121     Color(RGBA32 color, SemanticTag)
122     {
123         setRGB(color);
124         setIsSemantic();
125     }
126 
127     Color(int r, int g, int b)
128     {
129         setRGB(r, g, b);
130     }
131 
132     Color(int r, int g, int b, int a)
133     {
134         setRGB(makeRGBA(r, g, b, a));
135     }
136 
137     Color(float r, float g, float b, float a)
138     {
139         setRGB(makeRGBA32FromFloats(r, g, b, a));
140     }
</pre>
<hr />
<pre>
158     }
159 
160     bool isHashTableDeletedValue() const
161     {
162         return m_colorData.rgbaAndFlags == deletedHashValue;
163     }
164 
165     explicit Color(WTF::HashTableEmptyValueType)
166     {
167         static_assert(emptyHashValue &amp; invalidRGBAColor, &quot;Color&#39;s empty hash value must not look like an ExtendedColor&quot;);
168         static_assert(emptyHashValue &amp; (1 &lt;&lt; 4), &quot;Color&#39;s deleted hash value must have some bits set that an RGBA32 Color wouldn&#39;t have&quot;);
169         m_colorData.rgbaAndFlags = emptyHashValue;
170         ASSERT(!isExtended());
171     }
172 
173     // This creates an ExtendedColor.
174     // FIXME: If the colorSpace is sRGB and the values can all be
175     // converted exactly to integers, we should make a normal Color.
176     WEBCORE_EXPORT Color(float r, float g, float b, float a, ColorSpace colorSpace);
177 
<span class="line-removed">178     Color(RGBA, ColorSpace);</span>
179     WEBCORE_EXPORT Color(const Color&amp;);
180     WEBCORE_EXPORT Color(Color&amp;&amp;);
181 
182     ~Color()
183     {
184         if (isExtended())
185             m_colorData.extendedColor-&gt;deref();
186     }
187 
<span class="line-removed">188     static Color createUnchecked(int r, int g, int b)</span>
<span class="line-removed">189     {</span>
<span class="line-removed">190         RGBA32 color = 0xFF000000 | r &lt;&lt; 16 | g &lt;&lt; 8 | b;</span>
<span class="line-removed">191         return Color(color);</span>
<span class="line-removed">192     }</span>
<span class="line-removed">193     static Color createUnchecked(int r, int g, int b, int a)</span>
<span class="line-removed">194     {</span>
<span class="line-removed">195         RGBA32 color = a &lt;&lt; 24 | r &lt;&lt; 16 | g &lt;&lt; 8 | b;</span>
<span class="line-removed">196         return Color(color);</span>
<span class="line-removed">197     }</span>
<span class="line-removed">198 </span>
199     // Returns the color serialized according to HTML5
200     // &lt;https://html.spec.whatwg.org/multipage/scripting.html#fill-and-stroke-styles&gt; (10 September 2015)
201     WEBCORE_EXPORT String serialized() const;
202 
203     WEBCORE_EXPORT String cssText() const;
204 
205     // Returns the color serialized as either #RRGGBB or #RRGGBBAA
206     String nameForRenderTreeAsText() const;
207 
208     bool isValid() const { return isExtended() || (m_colorData.rgbaAndFlags &amp; validRGBAColorBit); }
209 
<span class="line-modified">210     bool isOpaque() const { return isValid() &amp;&amp; (isExtended() ? asExtended().alpha() == 1.0 : alpha() == 255); }</span>
<span class="line-modified">211     bool isVisible() const { return isValid() &amp;&amp; (isExtended() ? asExtended().alpha() &gt; 0.0 : alpha() &gt; 0); }</span>
212 
<span class="line-modified">213     int red() const { return redChannel(rgb()); }</span>
<span class="line-modified">214     int green() const { return greenChannel(rgb()); }</span>
<span class="line-modified">215     int blue() const { return blueChannel(rgb()); }</span>
<span class="line-modified">216     int alpha() const { return alphaChannel(rgb()); }</span>
217 
<span class="line-modified">218     float alphaAsFloat() const { return isExtended() ? asExtended().alpha() : static_cast&lt;float&gt;(alphaChannel(rgb())) / 255; }</span>
219 
220     RGBA32 rgb() const;
221 
222     // FIXME: Like operator==, this will give different values for ExtendedColors that
223     // should be identical, since the respective pointer will be different.
224     unsigned hash() const { return WTF::intHash(m_colorData.rgbaAndFlags); }
225 
226     // FIXME: ExtendedColor - these should be renamed (to be clear about their parameter types, or
227     // replaced with alternative accessors.
228     WEBCORE_EXPORT void getRGBA(float&amp; r, float&amp; g, float&amp; b, float&amp; a) const;
229     WEBCORE_EXPORT void getRGBA(double&amp; r, double&amp; g, double&amp; b, double&amp; a) const;
230     WEBCORE_EXPORT void getHSL(double&amp; h, double&amp; s, double&amp; l) const;
231     WEBCORE_EXPORT void getHSV(double&amp; h, double&amp; s, double&amp; v) const;
232 
233     Color light() const;
234     Color dark() const;
235 
236     bool isDark() const;
237 
238     // This is an implementation of Porter-Duff&#39;s &quot;source-over&quot; equation
</pre>
<hr />
<pre>
252     Color(const GdkRGBA&amp;);
253     operator GdkRGBA() const;
254 #endif
255 
256 #if USE(CG)
257     WEBCORE_EXPORT Color(CGColorRef);
258     WEBCORE_EXPORT Color(CGColorRef, SemanticTag);
259 #endif
260 
261 #if PLATFORM(WIN)
262     WEBCORE_EXPORT Color(D2D1_COLOR_F);
263     WEBCORE_EXPORT operator D2D1_COLOR_F() const;
264     WEBCORE_EXPORT operator D2D1_VECTOR_4F() const;
265 #endif
266 
267     static bool parseHexColor(const String&amp;, RGBA32&amp;);
268     static bool parseHexColor(const StringView&amp;, RGBA32&amp;);
269     static bool parseHexColor(const LChar*, unsigned, RGBA32&amp;);
270     static bool parseHexColor(const UChar*, unsigned, RGBA32&amp;);
271 
<span class="line-modified">272     static const RGBA32 black = 0xFF000000;</span>
<span class="line-modified">273     WEBCORE_EXPORT static const RGBA32 white = 0xFFFFFFFF;</span>
<span class="line-modified">274     static const RGBA32 darkGray = 0xFF808080;</span>
<span class="line-modified">275     static const RGBA32 gray = 0xFFA0A0A0;</span>
<span class="line-modified">276     static const RGBA32 lightGray = 0xFFC0C0C0;</span>
<span class="line-modified">277     WEBCORE_EXPORT static const RGBA32 transparent = 0x00000000;</span>
<span class="line-modified">278     static const RGBA32 cyan = 0xFF00FFFF;</span>
<span class="line-modified">279     static const RGBA32 yellow = 0xFFFFFF00;</span>
280 
281 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">282     static const RGBA32 compositionFill = 0x3CAFC0E3;</span>
283 #else
<span class="line-modified">284     static const RGBA32 compositionFill = 0xFFE1DD55;</span>
285 #endif
286 
287     bool isExtended() const
288     {
289         return !(m_colorData.rgbaAndFlags &amp; invalidRGBAColor);
290     }
291     WEBCORE_EXPORT ExtendedColor&amp; asExtended() const;
292 
293     WEBCORE_EXPORT Color&amp; operator=(const Color&amp;);
294     WEBCORE_EXPORT Color&amp; operator=(Color&amp;&amp;);
295 
296     friend bool operator==(const Color&amp; a, const Color&amp; b);
297     friend bool equalIgnoringSemanticColor(const Color&amp; a, const Color&amp; b);
298 
299     static bool isBlackColor(const Color&amp;);
300     static bool isWhiteColor(const Color&amp;);
301 
302 private:
303     void setRGB(int r, int g, int b) { setRGB(makeRGB(r, g, b)); }
304     void setRGB(RGBA32);
</pre>
<hr />
<pre>
326 
327 // FIXME: These do not work for ExtendedColor because
328 // they become just pointer comparison.
329 bool operator==(const Color&amp;, const Color&amp;);
330 bool operator!=(const Color&amp;, const Color&amp;);
331 
332 Color colorFromPremultipliedARGB(RGBA32);
333 RGBA32 premultipliedARGBFromColor(const Color&amp;);
334 
335 Color blend(const Color&amp; from, const Color&amp; to, double progress, bool blendPremultiplied = true);
336 
337 int differenceSquared(const Color&amp;, const Color&amp;);
338 
339 uint16_t fastMultiplyBy255(uint16_t value);
340 uint16_t fastDivideBy255(uint16_t);
341 
342 #if USE(CG)
343 WEBCORE_EXPORT CGColorRef cachedCGColor(const Color&amp;);
344 #endif
345 
<span class="line-modified">346 inline RGBA::RGBA()</span>
<span class="line-modified">347 {</span>
<span class="line-removed">348 }</span>
<span class="line-removed">349 </span>
<span class="line-removed">350 inline RGBA::RGBA(uint8_t red, uint8_t green, uint8_t blue, uint8_t alpha)</span>
<span class="line-removed">351     : m_integer(alpha &lt;&lt; 24 | red &lt;&lt; 16 | green &lt;&lt; 8 | blue)</span>
<span class="line-removed">352 {</span>
<span class="line-removed">353 }</span>
<span class="line-removed">354 </span>
<span class="line-removed">355 inline RGBA::RGBA(uint8_t red, uint8_t green, uint8_t blue)</span>
<span class="line-removed">356     : m_integer(0xFF000000 | red &lt;&lt; 16 | green &lt;&lt; 8 | blue)</span>
<span class="line-removed">357 {</span>
<span class="line-removed">358 }</span>
<span class="line-removed">359 </span>
<span class="line-removed">360 inline uint8_t RGBA::red() const</span>
<span class="line-removed">361 {</span>
<span class="line-removed">362     return m_integer &gt;&gt; 16;</span>
<span class="line-removed">363 }</span>
<span class="line-removed">364 </span>
<span class="line-removed">365 inline uint8_t RGBA::green() const</span>
<span class="line-removed">366 {</span>
<span class="line-removed">367     return m_integer &gt;&gt; 8;</span>
<span class="line-removed">368 }</span>
<span class="line-removed">369 </span>
<span class="line-removed">370 inline uint8_t RGBA::blue() const</span>
<span class="line-removed">371 {</span>
<span class="line-removed">372     return m_integer;</span>
<span class="line-removed">373 }</span>
<span class="line-removed">374 </span>
<span class="line-removed">375 inline uint8_t RGBA::alpha() const</span>
<span class="line-removed">376 {</span>
<span class="line-removed">377     return m_integer &gt;&gt; 24;</span>
<span class="line-removed">378 }</span>
379 
<span class="line-modified">380 inline bool RGBA::hasAlpha() const</span>
381 {
<span class="line-modified">382     return (m_integer &amp; 0xFF000000) != 0xFF000000;</span>
383 }
384 
<span class="line-modified">385 inline Color::Color(RGBA color, ColorSpace space)</span>
386 {
<span class="line-modified">387     setRGB(color.m_integer);</span>
<span class="line-removed">388     ASSERT_UNUSED(space, space == ColorSpaceSRGB);</span>
389 }
390 
391 inline bool operator==(const Color&amp; a, const Color&amp; b)
392 {
393     return a.m_colorData.rgbaAndFlags == b.m_colorData.rgbaAndFlags;
394 }
395 
396 inline bool operator!=(const Color&amp; a, const Color&amp; b)
397 {
398     return !(a == b);
399 }
400 
401 inline bool equalIgnoringSemanticColor(const Color&amp; a, const Color&amp; b)
402 {
403     return (a.m_colorData.rgbaAndFlags &amp; ~Color::isSemanticRBGAColorBit) == (b.m_colorData.rgbaAndFlags &amp; ~Color::isSemanticRBGAColorBit);
404 }
405 
406 inline uint8_t roundAndClampColorChannel(int value)
407 {
408     return std::max(0, std::min(255, value));
</pre>
<hr />
<pre>
420 
421 inline uint16_t fastDivideBy255(uint16_t value)
422 {
423     // While this is an approximate algorithm for division by 255, it gives perfectly accurate results for 16-bit values.
424     // FIXME: Since this gives accurate results for 16-bit values, we should get this optimization into compilers like clang.
425     uint16_t approximation = value &gt;&gt; 8;
426     uint16_t remainder = value - (approximation * 255) + 1;
427     return approximation + (remainder &gt;&gt; 8);
428 }
429 
430 inline RGBA32 colorWithOverrideAlpha(RGBA32 color, Optional&lt;float&gt; overrideAlpha)
431 {
432     return overrideAlpha ? colorWithOverrideAlpha(color, overrideAlpha.value()) : color;
433 }
434 
435 inline RGBA32 Color::rgb() const
436 {
437     // FIXME: We should ASSERT(!isExtended()) here, or produce
438     // an RGBA32 equivalent for an ExtendedColor. Ideally the former,
439     // so we can audit all the rgb() call sites to handle extended.
<span class="line-modified">440     return static_cast&lt;RGBA32&gt;(m_colorData.rgbaAndFlags &gt;&gt; 32);</span>
441 }
442 
443 inline void Color::setRGB(RGBA32 rgb)
444 {
<span class="line-modified">445     m_colorData.rgbaAndFlags = static_cast&lt;uint64_t&gt;(rgb) &lt;&lt; 32;</span>
446     tagAsValid();
447 }
448 
449 inline bool Color::isBlackColor(const Color&amp; color)
450 {
451     if (color.isExtended()) {
452         const ExtendedColor&amp; extendedColor = color.asExtended();
453         return !extendedColor.red() &amp;&amp; !extendedColor.green() &amp;&amp; !extendedColor.blue() &amp;&amp; extendedColor.alpha() == 1;
454     }
455 
<span class="line-modified">456     return color.isValid() &amp;&amp; color.rgb() == Color::black;</span>
457 }
458 
459 inline bool Color::isWhiteColor(const Color&amp; color)
460 {
461     if (color.isExtended()) {
462         const ExtendedColor&amp; extendedColor = color.asExtended();
463         return extendedColor.red() == 1 &amp;&amp; extendedColor.green() == 1 &amp;&amp; extendedColor.blue() == 1 &amp;&amp; extendedColor.alpha() == 1;
464     }
465 
<span class="line-modified">466     return color.isValid() &amp;&amp; color.rgb() == Color::white;</span>
467 }
468 
<span class="line-removed">469 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Color&amp;);</span>
<span class="line-removed">470 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, ColorSpace);</span>
<span class="line-removed">471 </span>
472 } // namespace WebCore
473 
474 namespace WTF {
475 template&lt;&gt; struct DefaultHash&lt;WebCore::Color&gt;;
476 template&lt;&gt; struct HashTraits&lt;WebCore::Color&gt;;
477 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2003-2020 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
</pre>
<hr />
<pre>
 35 #include &lt;wtf/Optional.h&gt;
 36 #include &lt;wtf/text/LChar.h&gt;
 37 
 38 #if USE(CG)
 39 typedef struct CGColor* CGColorRef;
 40 #endif
 41 
 42 #if PLATFORM(WIN)
 43 struct _D3DCOLORVALUE;
 44 typedef _D3DCOLORVALUE D3DCOLORVALUE;
 45 typedef D3DCOLORVALUE D2D_COLOR_F;
 46 typedef D2D_COLOR_F D2D1_COLOR_F;
 47 struct D2D_VECTOR_4F;
 48 typedef D2D_VECTOR_4F D2D1_VECTOR_4F;
 49 #endif
 50 
 51 #if PLATFORM(GTK)
 52 typedef struct _GdkRGBA GdkRGBA;
 53 #endif
 54 




 55 namespace WebCore {
 56 
<span class="line-modified"> 57 // Color value with 8-bit components for red, green, blue, and alpha.</span>
<span class="line-added"> 58 // For historical reasons, stored as a 32-bit integer, with alpha in the high bits: ARGB.</span>
<span class="line-added"> 59 class SimpleColor {</span>
<span class="line-added"> 60 public:</span>
<span class="line-added"> 61     constexpr SimpleColor(uint32_t value = 0) : m_value { value } { }</span>
<span class="line-added"> 62 </span>
<span class="line-added"> 63     constexpr uint32_t value() const { return m_value; }</span>
<span class="line-added"> 64 </span>
<span class="line-added"> 65     constexpr uint8_t redComponent() const { return m_value &gt;&gt; 16; }</span>
<span class="line-added"> 66     constexpr uint8_t greenComponent() const { return m_value &gt;&gt; 8; }</span>
<span class="line-added"> 67     constexpr uint8_t blueComponent() const { return m_value; }</span>
<span class="line-added"> 68     constexpr uint8_t alphaComponent() const { return m_value &gt;&gt; 24; }</span>
<span class="line-added"> 69 </span>
<span class="line-added"> 70     constexpr bool isOpaque() const { return alphaComponent() == 0xFF; }</span>
<span class="line-added"> 71     constexpr bool isVisible() const { return alphaComponent(); }</span>
<span class="line-added"> 72 </span>
<span class="line-added"> 73     String serializationForHTML() const;</span>
<span class="line-added"> 74     String serializationForCSS() const;</span>
<span class="line-added"> 75     String serializationForRenderTreeAsText() const;</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77 private:</span>
<span class="line-added"> 78     uint32_t m_value { 0 };</span>
<span class="line-added"> 79 };</span>
<span class="line-added"> 80 </span>
<span class="line-added"> 81 bool operator==(SimpleColor, SimpleColor);</span>
<span class="line-added"> 82 bool operator!=(SimpleColor, SimpleColor);</span>
<span class="line-added"> 83 </span>
<span class="line-added"> 84 // FIXME: Remove this after migrating to the new name.</span>
<span class="line-added"> 85 using RGBA32 = SimpleColor;</span>
 86 
 87 WEBCORE_EXPORT RGBA32 makeRGB(int r, int g, int b);
 88 WEBCORE_EXPORT RGBA32 makeRGBA(int r, int g, int b, int a);
 89 
 90 RGBA32 makePremultipliedRGBA(int r, int g, int b, int a, bool ceiling = true);
 91 RGBA32 makeUnPremultipliedRGBA(int r, int g, int b, int a);
 92 
 93 WEBCORE_EXPORT RGBA32 colorWithOverrideAlpha(RGBA32 color, float overrideAlpha);
 94 RGBA32 colorWithOverrideAlpha(RGBA32 color, Optional&lt;float&gt; overrideAlpha);
 95 
 96 WEBCORE_EXPORT RGBA32 makeRGBA32FromFloats(float r, float g, float b, float a);
<span class="line-modified"> 97 RGBA32 makeRGBAFromHSLA(float h, float s, float l, float a);</span>
 98 RGBA32 makeRGBAFromCMYKA(float c, float m, float y, float k, float a);
 99 





100 uint8_t roundAndClampColorChannel(int);
101 uint8_t roundAndClampColorChannel(float);
102 






















103 class Color {
104     WTF_MAKE_FAST_ALLOCATED;
105 public:
106     Color() { }
107 
108     // FIXME: Remove all these constructors and creation functions and replace the ones that are still needed with free functions.
109 
110     Color(RGBA32 color, bool valid = true)
111     {
112         if (valid)
113             setRGB(color);
114     }
115 
116     enum SemanticTag { Semantic };

117     Color(RGBA32 color, SemanticTag)
118     {
119         setRGB(color);
120         setIsSemantic();
121     }
122 
123     Color(int r, int g, int b)
124     {
125         setRGB(r, g, b);
126     }
127 
128     Color(int r, int g, int b, int a)
129     {
130         setRGB(makeRGBA(r, g, b, a));
131     }
132 
133     Color(float r, float g, float b, float a)
134     {
135         setRGB(makeRGBA32FromFloats(r, g, b, a));
136     }
</pre>
<hr />
<pre>
154     }
155 
156     bool isHashTableDeletedValue() const
157     {
158         return m_colorData.rgbaAndFlags == deletedHashValue;
159     }
160 
161     explicit Color(WTF::HashTableEmptyValueType)
162     {
163         static_assert(emptyHashValue &amp; invalidRGBAColor, &quot;Color&#39;s empty hash value must not look like an ExtendedColor&quot;);
164         static_assert(emptyHashValue &amp; (1 &lt;&lt; 4), &quot;Color&#39;s deleted hash value must have some bits set that an RGBA32 Color wouldn&#39;t have&quot;);
165         m_colorData.rgbaAndFlags = emptyHashValue;
166         ASSERT(!isExtended());
167     }
168 
169     // This creates an ExtendedColor.
170     // FIXME: If the colorSpace is sRGB and the values can all be
171     // converted exactly to integers, we should make a normal Color.
172     WEBCORE_EXPORT Color(float r, float g, float b, float a, ColorSpace colorSpace);
173 

174     WEBCORE_EXPORT Color(const Color&amp;);
175     WEBCORE_EXPORT Color(Color&amp;&amp;);
176 
177     ~Color()
178     {
179         if (isExtended())
180             m_colorData.extendedColor-&gt;deref();
181     }
182 











183     // Returns the color serialized according to HTML5
184     // &lt;https://html.spec.whatwg.org/multipage/scripting.html#fill-and-stroke-styles&gt; (10 September 2015)
185     WEBCORE_EXPORT String serialized() const;
186 
187     WEBCORE_EXPORT String cssText() const;
188 
189     // Returns the color serialized as either #RRGGBB or #RRGGBBAA
190     String nameForRenderTreeAsText() const;
191 
192     bool isValid() const { return isExtended() || (m_colorData.rgbaAndFlags &amp; validRGBAColorBit); }
193 
<span class="line-modified">194     bool isOpaque() const { return isExtended() ? asExtended().alpha() == 1.0 : rgb().isOpaque(); }</span>
<span class="line-modified">195     bool isVisible() const { return isExtended() ? asExtended().alpha() &gt; 0.0 : rgb().isVisible(); }</span>
196 
<span class="line-modified">197     int red() const { return rgb().redComponent(); }</span>
<span class="line-modified">198     int green() const { return rgb().greenComponent(); }</span>
<span class="line-modified">199     int blue() const { return rgb().blueComponent(); }</span>
<span class="line-modified">200     int alpha() const { return rgb().alphaComponent(); }</span>
201 
<span class="line-modified">202     float alphaAsFloat() const { return isExtended() ? asExtended().alpha() : static_cast&lt;float&gt;(rgb().alphaComponent()) / 0xFF; }</span>
203 
204     RGBA32 rgb() const;
205 
206     // FIXME: Like operator==, this will give different values for ExtendedColors that
207     // should be identical, since the respective pointer will be different.
208     unsigned hash() const { return WTF::intHash(m_colorData.rgbaAndFlags); }
209 
210     // FIXME: ExtendedColor - these should be renamed (to be clear about their parameter types, or
211     // replaced with alternative accessors.
212     WEBCORE_EXPORT void getRGBA(float&amp; r, float&amp; g, float&amp; b, float&amp; a) const;
213     WEBCORE_EXPORT void getRGBA(double&amp; r, double&amp; g, double&amp; b, double&amp; a) const;
214     WEBCORE_EXPORT void getHSL(double&amp; h, double&amp; s, double&amp; l) const;
215     WEBCORE_EXPORT void getHSV(double&amp; h, double&amp; s, double&amp; v) const;
216 
217     Color light() const;
218     Color dark() const;
219 
220     bool isDark() const;
221 
222     // This is an implementation of Porter-Duff&#39;s &quot;source-over&quot; equation
</pre>
<hr />
<pre>
236     Color(const GdkRGBA&amp;);
237     operator GdkRGBA() const;
238 #endif
239 
240 #if USE(CG)
241     WEBCORE_EXPORT Color(CGColorRef);
242     WEBCORE_EXPORT Color(CGColorRef, SemanticTag);
243 #endif
244 
245 #if PLATFORM(WIN)
246     WEBCORE_EXPORT Color(D2D1_COLOR_F);
247     WEBCORE_EXPORT operator D2D1_COLOR_F() const;
248     WEBCORE_EXPORT operator D2D1_VECTOR_4F() const;
249 #endif
250 
251     static bool parseHexColor(const String&amp;, RGBA32&amp;);
252     static bool parseHexColor(const StringView&amp;, RGBA32&amp;);
253     static bool parseHexColor(const LChar*, unsigned, RGBA32&amp;);
254     static bool parseHexColor(const UChar*, unsigned, RGBA32&amp;);
255 
<span class="line-modified">256     static constexpr SimpleColor black { 0xFF000000 };</span>
<span class="line-modified">257     static constexpr SimpleColor white { 0xFFFFFFFF };</span>
<span class="line-modified">258     static constexpr SimpleColor darkGray { 0xFF808080 };</span>
<span class="line-modified">259     static constexpr SimpleColor gray { 0xFFA0A0A0 };</span>
<span class="line-modified">260     static constexpr SimpleColor lightGray { 0xFFC0C0C0 };</span>
<span class="line-modified">261     static constexpr SimpleColor transparent { 0x00000000 };</span>
<span class="line-modified">262     static constexpr SimpleColor cyan { 0xFF00FFFF };</span>
<span class="line-modified">263     static constexpr SimpleColor yellow { 0xFFFFFF00 };</span>
264 
265 #if PLATFORM(IOS_FAMILY)
<span class="line-modified">266     static constexpr SimpleColor compositionFill { 0x3CAFC0E3 };</span>
267 #else
<span class="line-modified">268     static constexpr SimpleColor compositionFill { 0xFFE1DD55 };</span>
269 #endif
270 
271     bool isExtended() const
272     {
273         return !(m_colorData.rgbaAndFlags &amp; invalidRGBAColor);
274     }
275     WEBCORE_EXPORT ExtendedColor&amp; asExtended() const;
276 
277     WEBCORE_EXPORT Color&amp; operator=(const Color&amp;);
278     WEBCORE_EXPORT Color&amp; operator=(Color&amp;&amp;);
279 
280     friend bool operator==(const Color&amp; a, const Color&amp; b);
281     friend bool equalIgnoringSemanticColor(const Color&amp; a, const Color&amp; b);
282 
283     static bool isBlackColor(const Color&amp;);
284     static bool isWhiteColor(const Color&amp;);
285 
286 private:
287     void setRGB(int r, int g, int b) { setRGB(makeRGB(r, g, b)); }
288     void setRGB(RGBA32);
</pre>
<hr />
<pre>
310 
311 // FIXME: These do not work for ExtendedColor because
312 // they become just pointer comparison.
313 bool operator==(const Color&amp;, const Color&amp;);
314 bool operator!=(const Color&amp;, const Color&amp;);
315 
316 Color colorFromPremultipliedARGB(RGBA32);
317 RGBA32 premultipliedARGBFromColor(const Color&amp;);
318 
319 Color blend(const Color&amp; from, const Color&amp; to, double progress, bool blendPremultiplied = true);
320 
321 int differenceSquared(const Color&amp;, const Color&amp;);
322 
323 uint16_t fastMultiplyBy255(uint16_t value);
324 uint16_t fastDivideBy255(uint16_t);
325 
326 #if USE(CG)
327 WEBCORE_EXPORT CGColorRef cachedCGColor(const Color&amp;);
328 #endif
329 
<span class="line-modified">330 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Color&amp;);</span>
<span class="line-modified">331 WEBCORE_EXPORT WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, ColorSpace);</span>































332 
<span class="line-modified">333 inline bool operator==(SimpleColor a, SimpleColor b)</span>
334 {
<span class="line-modified">335     return a.value() == b.value();</span>
336 }
337 
<span class="line-modified">338 inline bool operator!=(SimpleColor a, SimpleColor b)</span>
339 {
<span class="line-modified">340     return !(a == b);</span>

341 }
342 
343 inline bool operator==(const Color&amp; a, const Color&amp; b)
344 {
345     return a.m_colorData.rgbaAndFlags == b.m_colorData.rgbaAndFlags;
346 }
347 
348 inline bool operator!=(const Color&amp; a, const Color&amp; b)
349 {
350     return !(a == b);
351 }
352 
353 inline bool equalIgnoringSemanticColor(const Color&amp; a, const Color&amp; b)
354 {
355     return (a.m_colorData.rgbaAndFlags &amp; ~Color::isSemanticRBGAColorBit) == (b.m_colorData.rgbaAndFlags &amp; ~Color::isSemanticRBGAColorBit);
356 }
357 
358 inline uint8_t roundAndClampColorChannel(int value)
359 {
360     return std::max(0, std::min(255, value));
</pre>
<hr />
<pre>
372 
373 inline uint16_t fastDivideBy255(uint16_t value)
374 {
375     // While this is an approximate algorithm for division by 255, it gives perfectly accurate results for 16-bit values.
376     // FIXME: Since this gives accurate results for 16-bit values, we should get this optimization into compilers like clang.
377     uint16_t approximation = value &gt;&gt; 8;
378     uint16_t remainder = value - (approximation * 255) + 1;
379     return approximation + (remainder &gt;&gt; 8);
380 }
381 
382 inline RGBA32 colorWithOverrideAlpha(RGBA32 color, Optional&lt;float&gt; overrideAlpha)
383 {
384     return overrideAlpha ? colorWithOverrideAlpha(color, overrideAlpha.value()) : color;
385 }
386 
387 inline RGBA32 Color::rgb() const
388 {
389     // FIXME: We should ASSERT(!isExtended()) here, or produce
390     // an RGBA32 equivalent for an ExtendedColor. Ideally the former,
391     // so we can audit all the rgb() call sites to handle extended.
<span class="line-modified">392     return { static_cast&lt;uint32_t&gt;(m_colorData.rgbaAndFlags &gt;&gt; 32) };</span>
393 }
394 
395 inline void Color::setRGB(RGBA32 rgb)
396 {
<span class="line-modified">397     m_colorData.rgbaAndFlags = static_cast&lt;uint64_t&gt;(rgb.value()) &lt;&lt; 32;</span>
398     tagAsValid();
399 }
400 
401 inline bool Color::isBlackColor(const Color&amp; color)
402 {
403     if (color.isExtended()) {
404         const ExtendedColor&amp; extendedColor = color.asExtended();
405         return !extendedColor.red() &amp;&amp; !extendedColor.green() &amp;&amp; !extendedColor.blue() &amp;&amp; extendedColor.alpha() == 1;
406     }
407 
<span class="line-modified">408     return color.rgb() == Color::black;</span>
409 }
410 
411 inline bool Color::isWhiteColor(const Color&amp; color)
412 {
413     if (color.isExtended()) {
414         const ExtendedColor&amp; extendedColor = color.asExtended();
415         return extendedColor.red() == 1 &amp;&amp; extendedColor.green() == 1 &amp;&amp; extendedColor.blue() == 1 &amp;&amp; extendedColor.alpha() == 1;
416     }
417 
<span class="line-modified">418     return color.rgb() == Color::white;</span>
419 }
420 



421 } // namespace WebCore
422 
423 namespace WTF {
424 template&lt;&gt; struct DefaultHash&lt;WebCore::Color&gt;;
425 template&lt;&gt; struct HashTraits&lt;WebCore::Color&gt;;
426 }
</pre>
</td>
</tr>
</table>
<center><a href="Color.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ColorSpace.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
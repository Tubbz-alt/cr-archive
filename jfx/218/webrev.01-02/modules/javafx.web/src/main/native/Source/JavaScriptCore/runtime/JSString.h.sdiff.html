<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSString.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSString.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSStringInlines.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSString.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">   4  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.</span>
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #pragma once
  24 
  25 #include &quot;ArgList.h&quot;
  26 #include &quot;CallFrame.h&quot;
  27 #include &quot;CommonIdentifiers.h&quot;

  28 #include &quot;Identifier.h&quot;
  29 #include &quot;PropertyDescriptor.h&quot;
  30 #include &quot;PropertySlot.h&quot;
  31 #include &quot;Structure.h&quot;
  32 #include &quot;ThrowScope.h&quot;
  33 #include &lt;array&gt;
  34 #include &lt;wtf/CheckedArithmetic.h&gt;
  35 #include &lt;wtf/ForbidHeapAllocation.h&gt;
  36 #include &lt;wtf/text/StringView.h&gt;
  37 
  38 namespace JSC {
  39 
  40 class JSString;
  41 class JSRopeString;
  42 class LLIntOffsetsExtractor;
  43 
  44 JSString* jsEmptyString(VM&amp;);
  45 JSString* jsString(VM&amp;, const String&amp;); // returns empty string if passed null string
  46 
  47 JSString* jsSingleCharacterString(VM&amp;, UChar);
</pre>
<hr />
<pre>
  71 // and 3rd fibers into the following 80byte fields. One problem is that now 2nd and 3rd fibers are split. Storing and loading 2nd and 3rd fibers
  72 // are not one pointer load operation. To make concurrent collector work correctly, we must initialize 2nd and 3rd fibers at JSRopeString creation
  73 // and we must not modify these part later.
  74 //
  75 //              0                        8        10               16                       32                                     48
  76 // JSString     [   ID      ][  header  ][   String pointer      0]
  77 // JSRopeString [   ID      ][  header  ][   1st fiber         xyz][  length  ][2nd lower32][2nd upper16][3rd lower16][3rd upper32]
  78 //                                                               ^
  79 //                                            x:(is8Bit),y:(isSubstring),z:(isRope) bit flags
  80 class JSString : public JSCell {
  81 public:
  82     friend class JIT;
  83     friend class VM;
  84     friend class SpecializedThunkJIT;
  85     friend class JSRopeString;
  86     friend class MarkStack;
  87     friend class SlotVisitor;
  88     friend class SmallStrings;
  89 
  90     typedef JSCell Base;
<span class="line-modified">  91     static const unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | StructureIsImmortal | OverridesToThis;</span>
  92 
<span class="line-modified">  93     static const bool needsDestruction = true;</span>
<span class="line-modified">  94     static void destroy(JSCell*);</span>



  95 
  96     // We specialize the string subspace to get the fastest possible sweep. This wouldn&#39;t be
  97     // necessary if JSString didn&#39;t have a destructor.
  98     template&lt;typename, SubspaceAccess&gt;
<span class="line-modified">  99     static CompleteSubspace* subspaceFor(VM&amp; vm)</span>
 100     {
 101         return &amp;vm.stringSpace;
 102     }
 103 
 104     // We employ overflow checks in many places with the assumption that MaxLength
 105     // is INT_MAX. Hence, it cannot be changed into another length value without
 106     // breaking all the bounds and overflow checks that assume this.
 107     static constexpr unsigned MaxLength = std::numeric_limits&lt;int32_t&gt;::max();
 108     static_assert(MaxLength == String::MaxLength, &quot;&quot;);
 109 
 110     static constexpr uintptr_t isRopeInPointer = 0x1;
 111 
 112 private:
 113     String&amp; uninitializedValueInternal() const
 114     {
 115         return *bitwise_cast&lt;String*&gt;(&amp;m_fiber);
 116     }
 117 
 118     String&amp; valueInternal() const
 119     {
</pre>
<hr />
<pre>
 159         newString-&gt;finishCreation(vm, length, cost);
 160         return newString;
 161     }
 162     static JSString* createHasOtherOwner(VM&amp; vm, Ref&lt;StringImpl&gt;&amp;&amp; value)
 163     {
 164         unsigned length = value-&gt;length();
 165         JSString* newString = new (NotNull, allocateCell&lt;JSString&gt;(vm.heap)) JSString(vm, WTFMove(value));
 166         newString-&gt;finishCreation(vm, length);
 167         return newString;
 168     }
 169 
 170 protected:
 171     void finishCreation(VM&amp; vm)
 172     {
 173         Base::finishCreation(vm);
 174     }
 175 
 176 public:
 177     ~JSString();
 178 
<span class="line-modified"> 179     Identifier toIdentifier(ExecState*) const;</span>
<span class="line-modified"> 180     AtomString toAtomString(ExecState*) const;</span>
<span class="line-modified"> 181     RefPtr&lt;AtomStringImpl&gt; toExistingAtomString(ExecState*) const;</span>
 182 
<span class="line-modified"> 183     StringViewWithUnderlyingString viewWithUnderlyingString(ExecState*) const;</span>
 184 
<span class="line-modified"> 185     inline bool equal(ExecState*, JSString* other) const;</span>
<span class="line-modified"> 186     const String&amp; value(ExecState*) const;</span>
 187     inline const String&amp; tryGetValue(bool allocationAllowed = true) const;

 188     const StringImpl* tryGetValueImpl() const;
 189     ALWAYS_INLINE unsigned length() const;
 190 
<span class="line-modified"> 191     JSValue toPrimitive(ExecState*, PreferredPrimitiveType) const;</span>
 192     bool toBoolean() const { return !!length(); }
<span class="line-modified"> 193     bool getPrimitiveNumber(ExecState*, double&amp; number, JSValue&amp;) const;</span>
<span class="line-modified"> 194     JSObject* toObject(ExecState*, JSGlobalObject*) const;</span>
<span class="line-modified"> 195     double toNumber(ExecState*) const;</span>
 196 
<span class="line-modified"> 197     bool getStringPropertySlot(ExecState*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified"> 198     bool getStringPropertySlot(ExecState*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="line-modified"> 199     bool getStringPropertyDescriptor(ExecState*, PropertyName, PropertyDescriptor&amp;);</span>
 200 
 201     bool canGetIndex(unsigned i) { return i &lt; length(); }
<span class="line-modified"> 202     JSString* getIndex(ExecState*, unsigned);</span>
 203 
 204     static Structure* createStructure(VM&amp;, JSGlobalObject*, JSValue);
 205 
 206     static ptrdiff_t offsetOfValue() { return OBJECT_OFFSETOF(JSString, m_fiber); }
 207 
 208     DECLARE_EXPORT_INFO;
 209 
 210     static void dumpToStream(const JSCell*, PrintStream&amp;);
 211     static size_t estimatedSize(JSCell*, VM&amp;);
 212     static void visitChildren(JSCell*, SlotVisitor&amp;);
 213 
 214     ALWAYS_INLINE bool isRope() const
 215     {
 216         return m_fiber &amp; isRopeInPointer;
 217     }
 218 
 219     bool is8Bit() const;
 220 
 221 protected:
 222     friend class JSValue;
 223 
<span class="line-modified"> 224     JS_EXPORT_PRIVATE bool equalSlowCase(ExecState*, JSString* other) const;</span>
 225     bool isSubstring() const;
 226 
 227     mutable uintptr_t m_fiber;
 228 
 229 private:
 230     friend class LLIntOffsetsExtractor;
 231 
<span class="line-modified"> 232     static JSValue toThis(JSCell*, ExecState*, ECMAMode);</span>
 233 
<span class="line-modified"> 234     StringView unsafeView(ExecState*) const;</span>
 235 
 236     friend JSString* jsString(VM&amp;, const String&amp;);
<span class="line-modified"> 237     friend JSString* jsString(ExecState*, JSString*, JSString*);</span>
<span class="line-modified"> 238     friend JSString* jsString(ExecState*, const String&amp;, JSString*);</span>
<span class="line-modified"> 239     friend JSString* jsString(ExecState*, JSString*, const String&amp;);</span>
<span class="line-modified"> 240     friend JSString* jsString(ExecState*, const String&amp;, const String&amp;);</span>
<span class="line-modified"> 241     friend JSString* jsString(ExecState*, JSString*, JSString*, JSString*);</span>
<span class="line-modified"> 242     friend JSString* jsString(ExecState*, const String&amp;, const String&amp;, const String&amp;);</span>
 243     friend JSString* jsSingleCharacterString(VM&amp;, UChar);
 244     friend JSString* jsNontrivialString(VM&amp;, const String&amp;);
 245     friend JSString* jsNontrivialString(VM&amp;, String&amp;&amp;);
 246     friend JSString* jsSubstring(VM&amp;, const String&amp;, unsigned, unsigned);
<span class="line-modified"> 247     friend JSString* jsSubstring(VM&amp;, ExecState*, JSString*, unsigned, unsigned);</span>
 248     friend JSString* jsSubstringOfResolved(VM&amp;, GCDeferralContext*, JSString*, unsigned, unsigned);
 249     friend JSString* jsOwnedString(VM&amp;, const String&amp;);
 250 };
 251 
 252 // NOTE: This class cannot override JSString&#39;s destructor. JSString&#39;s destructor is called directly
 253 // from JSStringSubspace::
 254 class JSRopeString final : public JSString {
 255     friend class JSString;
 256 public:






 257     // We use lower 3bits of fiber0 for flags. These bits are usable due to alignment, and it is OK even in 32bit architecture.
 258     static constexpr uintptr_t is8BitInPointer = static_cast&lt;uintptr_t&gt;(StringImpl::flagIs8Bit());
 259     static constexpr uintptr_t isSubstringInPointer = 0x2;
 260     static_assert(is8BitInPointer == 0b100, &quot;&quot;);
 261     static_assert(isSubstringInPointer == 0b010, &quot;&quot;);
 262     static_assert(isRopeInPointer == 0b001, &quot;&quot;);
 263     static constexpr uintptr_t stringMask = ~(isRopeInPointer | is8BitInPointer | isSubstringInPointer);
 264 #if CPU(ADDRESS64)
 265     static_assert(sizeof(uintptr_t) == sizeof(uint64_t), &quot;&quot;);
 266     class CompactFibers {
 267     public:
<span class="line-modified"> 268         static constexpr uintptr_t addressMask = (1ULL &lt;&lt; WTF_CPU_EFFECTIVE_ADDRESS_WIDTH) - 1;</span>
 269         JSString* fiber1() const
 270         {
 271 #if CPU(LITTLE_ENDIAN)
 272             return bitwise_cast&lt;JSString*&gt;(WTF::unalignedLoad&lt;uintptr_t&gt;(&amp;m_fiber1Lower) &amp; addressMask);
 273 #else
 274             return bitwise_cast&lt;JSString*&gt;(static_cast&lt;uintptr_t&gt;(m_fiber1Lower) | (static_cast&lt;uintptr_t&gt;(m_fiber1Upper) &lt;&lt; 32));
 275 #endif
 276         }
 277 
 278         void initializeFiber1(JSString* fiber)
 279         {
 280             uintptr_t pointer = bitwise_cast&lt;uintptr_t&gt;(fiber);
 281             m_fiber1Lower = static_cast&lt;uint32_t&gt;(pointer);
 282             m_fiber1Upper = static_cast&lt;uint16_t&gt;(pointer &gt;&gt; 32);
 283         }
 284 
 285         JSString* fiber2() const
 286         {
 287 #if CPU(LITTLE_ENDIAN)
<span class="line-modified"> 288             // This access exceeds the sizeof(JSRopeString). But this is OK because JSRopeString is always allocated in MarkedBlock,</span>
<span class="line-removed"> 289             // and the last JSRopeString cell in the block has some subsequent bytes which are used for MarkedBlock::Footer.</span>
<span class="line-removed"> 290             // So the following access does not step over the page boundary in which the latter page does not have read permission.</span>
<span class="line-removed"> 291             return bitwise_cast&lt;JSString*&gt;(WTF::unalignedLoad&lt;uintptr_t&gt;(&amp;m_fiber2Lower) &amp; addressMask);</span>
 292 #else
 293             return bitwise_cast&lt;JSString*&gt;(static_cast&lt;uintptr_t&gt;(m_fiber2Lower) | (static_cast&lt;uintptr_t&gt;(m_fiber2Upper) &lt;&lt; 16));
 294 #endif
 295         }
 296         void initializeFiber2(JSString* fiber)
 297         {
 298             uintptr_t pointer = bitwise_cast&lt;uintptr_t&gt;(fiber);
 299             m_fiber2Lower = static_cast&lt;uint16_t&gt;(pointer);
 300             m_fiber2Upper = static_cast&lt;uint32_t&gt;(pointer &gt;&gt; 16);
 301         }
 302 
 303         unsigned length() const { return m_length; }
 304         void initializeLength(unsigned length)
 305         {
 306             m_length = length;
 307         }
 308 
 309         static ptrdiff_t offsetOfLength() { return OBJECT_OFFSETOF(CompactFibers, m_length); }
 310         static ptrdiff_t offsetOfFiber1() { return OBJECT_OFFSETOF(CompactFibers, m_length); }
 311         static ptrdiff_t offsetOfFiber2() { return OBJECT_OFFSETOF(CompactFibers, m_fiber1Upper); }
</pre>
<hr />
<pre>
 559         return newString;
 560     }
 561     static JSRopeString* create(VM&amp; vm, JSString* s1, JSString* s2, JSString* s3)
 562     {
 563         JSRopeString* newString = new (NotNull, allocateCell&lt;JSRopeString&gt;(vm.heap)) JSRopeString(vm, s1, s2, s3);
 564         newString-&gt;finishCreation(vm);
 565         ASSERT(newString-&gt;length());
 566         ASSERT(newString-&gt;isRope());
 567         return newString;
 568     }
 569 
 570     ALWAYS_INLINE static JSRopeString* createSubstringOfResolved(VM&amp; vm, GCDeferralContext* deferralContext, JSString* base, unsigned offset, unsigned length)
 571     {
 572         JSRopeString* newString = new (NotNull, allocateCell&lt;JSRopeString&gt;(vm.heap, deferralContext)) JSRopeString(vm, base, offset, length);
 573         newString-&gt;finishCreationSubstringOfResolved(vm);
 574         ASSERT(newString-&gt;length());
 575         ASSERT(newString-&gt;isRope());
 576         return newString;
 577     }
 578 
<span class="line-modified"> 579     friend JSValue jsStringFromRegisterArray(ExecState*, Register*, unsigned);</span>
<span class="line-removed"> 580     friend JSValue jsStringFromArguments(ExecState*, JSValue);</span>
 581 
 582     // If nullOrExecForOOM is null, resolveRope() will be do nothing in the event of an OOM error.
 583     // The rope value will remain a null string in that case.
<span class="line-modified"> 584     JS_EXPORT_PRIVATE const String&amp; resolveRope(ExecState* nullOrExecForOOM) const;</span>
<span class="line-modified"> 585     template&lt;typename Function&gt; const String&amp; resolveRopeWithFunction(ExecState* nullOrExecForOOM, Function&amp;&amp;) const;</span>
<span class="line-modified"> 586     JS_EXPORT_PRIVATE AtomString resolveRopeToAtomString(ExecState*) const;</span>
<span class="line-modified"> 587     JS_EXPORT_PRIVATE RefPtr&lt;AtomStringImpl&gt; resolveRopeToExistingAtomString(ExecState*) const;</span>
<span class="line-modified"> 588     void resolveRopeSlowCase8(LChar*) const;</span>
<span class="line-modified"> 589     void resolveRopeSlowCase(UChar*) const;</span>
<span class="line-modified"> 590     void outOfMemory(ExecState* nullOrExecForOOM) const;</span>
 591     void resolveRopeInternal8(LChar*) const;
<span class="line-removed"> 592     void resolveRopeInternal8NoSubstring(LChar*) const;</span>
 593     void resolveRopeInternal16(UChar*) const;
<span class="line-modified"> 594     void resolveRopeInternal16NoSubstring(UChar*) const;</span>
<span class="line-modified"> 595     StringView unsafeView(ExecState*) const;</span>
<span class="line-removed"> 596     StringViewWithUnderlyingString viewWithUnderlyingString(ExecState*) const;</span>
 597 
 598     JSString* fiber0() const
 599     {
 600         return bitwise_cast&lt;JSString*&gt;(m_fiber &amp; stringMask);
 601     }
 602 
 603     JSString* fiber1() const
 604     {
 605         return m_compactFibers.fiber1();
 606     }
 607 
 608     JSString* fiber2() const
 609     {
 610         return m_compactFibers.fiber2();
 611     }
 612 
 613     JSString* fiber(unsigned i) const
 614     {
 615         ASSERT(!isSubstring());
 616         ASSERT(i &lt; s_maxInternalRopeLength);
</pre>
<hr />
<pre>
 646     void initializeSubstringBase(JSString* fiber)
 647     {
 648         initializeFiber1(fiber);
 649     }
 650 
 651     JSString* substringBase() const { return fiber1(); }
 652 
 653     void initializeSubstringOffset(unsigned offset)
 654     {
 655         m_compactFibers.initializeFiber2(bitwise_cast&lt;JSString*&gt;(static_cast&lt;uintptr_t&gt;(offset)));
 656     }
 657 
 658     unsigned substringOffset() const
 659     {
 660         return static_cast&lt;unsigned&gt;(bitwise_cast&lt;uintptr_t&gt;(fiber2()));
 661     }
 662 
 663     static_assert(s_maxInternalRopeLength &gt;= 2, &quot;&quot;);
 664     mutable CompactFibers m_compactFibers;
 665 
<span class="line-modified"> 666     friend JSString* jsString(ExecState*, JSString*, JSString*);</span>
<span class="line-modified"> 667     friend JSString* jsString(ExecState*, const String&amp;, JSString*);</span>
<span class="line-modified"> 668     friend JSString* jsString(ExecState*, JSString*, const String&amp;);</span>
<span class="line-modified"> 669     friend JSString* jsString(ExecState*, const String&amp;, const String&amp;);</span>
<span class="line-modified"> 670     friend JSString* jsString(ExecState*, JSString*, JSString*, JSString*);</span>
<span class="line-modified"> 671     friend JSString* jsString(ExecState*, const String&amp;, const String&amp;, const String&amp;);</span>
 672     friend JSString* jsSubstringOfResolved(VM&amp;, GCDeferralContext*, JSString*, unsigned, unsigned);
<span class="line-modified"> 673     friend JSString* jsSubstring(VM&amp;, ExecState*, JSString*, unsigned, unsigned);</span>
 674 };
 675 
 676 JS_EXPORT_PRIVATE JSString* jsStringWithCacheSlowCase(VM&amp;, StringImpl&amp;);
 677 
 678 // JSString::is8Bit is safe to be called concurrently. Concurrent threads can access is8Bit even if the main thread
 679 // is in the middle of converting JSRopeString to JSString.
 680 ALWAYS_INLINE bool JSString::is8Bit() const
 681 {
 682     uintptr_t pointer = m_fiber;
 683     if (pointer &amp; isRopeInPointer) {
 684         // Do not load m_fiber twice. We should use the information in pointer.
 685         // Otherwise, JSRopeString may be converted to JSString between the first and second accesses.
 686         return pointer &amp; JSRopeString::is8BitInPointer;
 687     }
 688     return bitwise_cast&lt;StringImpl*&gt;(pointer)-&gt;is8Bit();
 689 }
 690 
 691 // JSString::length is safe to be called concurrently. Concurrent threads can access length even if the main thread
 692 // is in the middle of converting JSRopeString to JSString. This is OK because we never override the length bits
 693 // when we resolve a JSRopeString.
 694 ALWAYS_INLINE unsigned JSString::length() const
 695 {
 696     uintptr_t pointer = m_fiber;
 697     if (pointer &amp; isRopeInPointer)
 698         return jsCast&lt;const JSRopeString*&gt;(this)-&gt;length();
 699     return bitwise_cast&lt;StringImpl*&gt;(pointer)-&gt;length();
 700 }
 701 






 702 inline const StringImpl* JSString::tryGetValueImpl() const
 703 {
 704     uintptr_t pointer = m_fiber;
 705     if (pointer &amp; isRopeInPointer)
 706         return nullptr;
 707     return bitwise_cast&lt;StringImpl*&gt;(pointer);
 708 }
 709 
 710 inline JSString* asString(JSValue value)
 711 {
 712     ASSERT(value.asCell()-&gt;isString());
 713     return jsCast&lt;JSString*&gt;(value.asCell());
 714 }
 715 
 716 // This MUST NOT GC.
 717 inline JSString* jsEmptyString(VM&amp; vm)
 718 {
 719     return vm.smallStrings.emptyString();
 720 }
 721 
</pre>
<hr />
<pre>
 723 {
 724     if (validateDFGDoesGC)
 725         RELEASE_ASSERT(vm.heap.expectDoesGC());
 726     if (c &lt;= maxSingleCharacterString)
 727         return vm.smallStrings.singleCharacterString(c);
 728     return JSString::create(vm, StringImpl::create(&amp;c, 1));
 729 }
 730 
 731 inline JSString* jsNontrivialString(VM&amp; vm, const String&amp; s)
 732 {
 733     ASSERT(s.length() &gt; 1);
 734     return JSString::create(vm, *s.impl());
 735 }
 736 
 737 inline JSString* jsNontrivialString(VM&amp; vm, String&amp;&amp; s)
 738 {
 739     ASSERT(s.length() &gt; 1);
 740     return JSString::create(vm, s.releaseImpl().releaseNonNull());
 741 }
 742 
<span class="line-modified"> 743 ALWAYS_INLINE Identifier JSString::toIdentifier(ExecState* exec) const</span>
 744 {
<span class="line-modified"> 745     VM&amp; vm = exec-&gt;vm();</span>
 746     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 747     AtomString atomString = toAtomString(exec);</span>
 748     RETURN_IF_EXCEPTION(scope, { });
 749     return Identifier::fromString(vm, atomString);
 750 }
 751 
<span class="line-modified"> 752 ALWAYS_INLINE AtomString JSString::toAtomString(ExecState* exec) const</span>
 753 {
 754     if (validateDFGDoesGC)
 755         RELEASE_ASSERT(vm().heap.expectDoesGC());
 756     if (isRope())
<span class="line-modified"> 757         return static_cast&lt;const JSRopeString*&gt;(this)-&gt;resolveRopeToAtomString(exec);</span>
 758     return AtomString(valueInternal());
 759 }
 760 
<span class="line-modified"> 761 ALWAYS_INLINE RefPtr&lt;AtomStringImpl&gt; JSString::toExistingAtomString(ExecState* exec) const</span>
 762 {
 763     if (validateDFGDoesGC)
 764         RELEASE_ASSERT(vm().heap.expectDoesGC());
 765     if (isRope())
<span class="line-modified"> 766         return static_cast&lt;const JSRopeString*&gt;(this)-&gt;resolveRopeToExistingAtomString(exec);</span>
 767     if (valueInternal().impl()-&gt;isAtom())
 768         return static_cast&lt;AtomStringImpl*&gt;(valueInternal().impl());
 769     return AtomStringImpl::lookUp(valueInternal().impl());
 770 }
 771 
<span class="line-modified"> 772 inline const String&amp; JSString::value(ExecState* exec) const</span>
 773 {
 774     if (validateDFGDoesGC)
 775         RELEASE_ASSERT(vm().heap.expectDoesGC());
 776     if (isRope())
<span class="line-modified"> 777         return static_cast&lt;const JSRopeString*&gt;(this)-&gt;resolveRope(exec);</span>
 778     return valueInternal();
 779 }
 780 
 781 inline const String&amp; JSString::tryGetValue(bool allocationAllowed) const
 782 {
 783     if (allocationAllowed) {
 784         if (validateDFGDoesGC)
 785             RELEASE_ASSERT(vm().heap.expectDoesGC());
 786         if (isRope()) {
<span class="line-modified"> 787             // Pass nullptr for the ExecState so that resolveRope does not throw in the event of an OOM error.</span>
 788             return static_cast&lt;const JSRopeString*&gt;(this)-&gt;resolveRope(nullptr);
 789         }
 790     } else
 791         RELEASE_ASSERT(!isRope());
 792     return valueInternal();
 793 }
 794 
<span class="line-modified"> 795 inline JSString* JSString::getIndex(ExecState* exec, unsigned i)</span>
 796 {
<span class="line-modified"> 797     VM&amp; vm = exec-&gt;vm();</span>
 798     auto scope = DECLARE_THROW_SCOPE(vm);
 799     ASSERT(canGetIndex(i));
<span class="line-modified"> 800     StringView view = unsafeView(exec);</span>
 801     RETURN_IF_EXCEPTION(scope, nullptr);
 802     return jsSingleCharacterString(vm, view[i]);
 803 }
 804 
 805 inline JSString* jsString(VM&amp; vm, const String&amp; s)
 806 {
 807     int size = s.length();
 808     if (!size)
 809         return vm.smallStrings.emptyString();
 810     if (size == 1) {
 811         UChar c = s.characterAt(0);
 812         if (c &lt;= maxSingleCharacterString)
 813             return vm.smallStrings.singleCharacterString(c);
 814     }
 815     return JSString::create(vm, *s.impl());
 816 }
 817 
<span class="line-modified"> 818 inline JSString* jsSubstring(VM&amp; vm, ExecState* exec, JSString* base, unsigned offset, unsigned length)</span>
 819 {
 820     auto scope = DECLARE_THROW_SCOPE(vm);
 821 
 822     ASSERT(offset &lt;= base-&gt;length());
 823     ASSERT(length &lt;= base-&gt;length());
 824     ASSERT(offset + length &lt;= base-&gt;length());
 825     if (!length)
 826         return vm.smallStrings.emptyString();
 827     if (!offset &amp;&amp; length == base-&gt;length())
 828         return base;
 829 
 830     // For now, let&#39;s not allow substrings with a rope base.
 831     // Resolve non-substring rope bases so we don&#39;t have to deal with it.
 832     // FIXME: Evaluate if this would be worth adding more branches.
 833     if (base-&gt;isSubstring()) {
 834         JSRopeString* baseRope = jsCast&lt;JSRopeString*&gt;(base);
 835         base = baseRope-&gt;substringBase();
 836         offset = baseRope-&gt;substringOffset() + offset;
 837         ASSERT(!base-&gt;isRope());
 838     } else if (base-&gt;isRope()) {
<span class="line-modified"> 839         jsCast&lt;JSRopeString*&gt;(base)-&gt;resolveRope(exec);</span>
 840         RETURN_IF_EXCEPTION(scope, nullptr);
 841     }
 842     return jsSubstringOfResolved(vm, nullptr, base, offset, length);
 843 }
 844 
 845 inline JSString* jsSubstringOfResolved(VM&amp; vm, GCDeferralContext* deferralContext, JSString* s, unsigned offset, unsigned length)
 846 {
 847     ASSERT(offset &lt;= s-&gt;length());
 848     ASSERT(length &lt;= s-&gt;length());
 849     ASSERT(offset + length &lt;= s-&gt;length());
 850     ASSERT(!s-&gt;isRope());
 851     if (!length)
 852         return vm.smallStrings.emptyString();
 853     if (!offset &amp;&amp; length == s-&gt;length())
 854         return s;
 855     if (length == 1) {
 856         auto&amp; base = s-&gt;valueInternal();
 857         UChar character = base.characterAt(offset);
 858         if (character &lt;= maxSingleCharacterString)
 859             return vm.smallStrings.singleCharacterString(character);
 860     }
 861     return JSRopeString::createSubstringOfResolved(vm, deferralContext, s, offset, length);
 862 }
 863 
 864 inline JSString* jsSubstringOfResolved(VM&amp; vm, JSString* s, unsigned offset, unsigned length)
 865 {
 866     return jsSubstringOfResolved(vm, nullptr, s, offset, length);
 867 }
 868 
<span class="line-modified"> 869 inline JSString* jsSubstring(ExecState* exec, JSString* s, unsigned offset, unsigned length)</span>
 870 {
<span class="line-modified"> 871     return jsSubstring(exec-&gt;vm(), exec, s, offset, length);</span>
 872 }
 873 
 874 inline JSString* jsSubstring(VM&amp; vm, const String&amp; s, unsigned offset, unsigned length)
 875 {
 876     ASSERT(offset &lt;= s.length());
 877     ASSERT(length &lt;= s.length());
 878     ASSERT(offset + length &lt;= s.length());
 879     if (!length)
 880         return vm.smallStrings.emptyString();
 881     if (length == 1) {
 882         UChar c = s.characterAt(offset);
 883         if (c &lt;= maxSingleCharacterString)
 884             return vm.smallStrings.singleCharacterString(c);
 885     }
 886     auto impl = StringImpl::createSubstringSharingImpl(*s.impl(), offset, length);
 887     if (impl-&gt;isSubString())
 888         return JSString::createHasOtherOwner(vm, WTFMove(impl));
 889     return JSString::create(vm, WTFMove(impl));
 890 }
 891 
 892 inline JSString* jsOwnedString(VM&amp; vm, const String&amp; s)
 893 {
 894     int size = s.length();
 895     if (!size)
 896         return vm.smallStrings.emptyString();
 897     if (size == 1) {
 898         UChar c = s.characterAt(0);
 899         if (c &lt;= maxSingleCharacterString)
 900             return vm.smallStrings.singleCharacterString(c);
 901     }
 902     return JSString::createHasOtherOwner(vm, *s.impl());
 903 }
 904 
<span class="line-modified"> 905 ALWAYS_INLINE JSString* jsStringWithCache(ExecState* exec, const String&amp; s)</span>
 906 {
<span class="line-modified"> 907     VM&amp; vm = exec-&gt;vm();</span>
 908     StringImpl* stringImpl = s.impl();
 909     if (!stringImpl || !stringImpl-&gt;length())
 910         return jsEmptyString(vm);
 911 
 912     if (stringImpl-&gt;length() == 1) {
 913         UChar singleCharacter = (*stringImpl)[0u];
 914         if (singleCharacter &lt;= maxSingleCharacterString)
 915             return vm.smallStrings.singleCharacterString(static_cast&lt;unsigned char&gt;(singleCharacter));
 916     }
 917 
 918     if (JSString* lastCachedString = vm.lastCachedString.get()) {
 919         if (lastCachedString-&gt;tryGetValueImpl() == stringImpl)
 920             return lastCachedString;
 921     }
 922 
 923     return jsStringWithCacheSlowCase(vm, *stringImpl);
 924 }
 925 
<span class="line-modified"> 926 ALWAYS_INLINE bool JSString::getStringPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
 927 {
<span class="line-modified"> 928     VM&amp; vm = exec-&gt;vm();</span>
 929     auto scope = DECLARE_THROW_SCOPE(vm);
 930 
 931     if (propertyName == vm.propertyNames-&gt;length) {
 932         slot.setValue(this, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, jsNumber(length()));
 933         return true;
 934     }
 935 
 936     Optional&lt;uint32_t&gt; index = parseIndex(propertyName);
 937     if (index &amp;&amp; index.value() &lt; length()) {
<span class="line-modified"> 938         JSValue value = getIndex(exec, index.value());</span>
 939         RETURN_IF_EXCEPTION(scope, false);
 940         slot.setValue(this, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, value);
 941         return true;
 942     }
 943 
 944     return false;
 945 }
 946 
<span class="line-modified"> 947 ALWAYS_INLINE bool JSString::getStringPropertySlot(ExecState* exec, unsigned propertyName, PropertySlot&amp; slot)</span>
 948 {
<span class="line-modified"> 949     VM&amp; vm = exec-&gt;vm();</span>
 950     auto scope = DECLARE_THROW_SCOPE(vm);
 951 
 952     if (propertyName &lt; length()) {
<span class="line-modified"> 953         JSValue value = getIndex(exec, propertyName);</span>
 954         RETURN_IF_EXCEPTION(scope, false);
 955         slot.setValue(this, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, value);
 956         return true;
 957     }
 958 
 959     return false;
 960 }
 961 
 962 inline bool isJSString(JSCell* cell)
 963 {
 964     return cell-&gt;type() == StringType;
 965 }
 966 
 967 inline bool isJSString(JSValue v)
 968 {
 969     return v.isCell() &amp;&amp; isJSString(v.asCell());
 970 }
 971 
<span class="line-modified"> 972 ALWAYS_INLINE StringView JSRopeString::unsafeView(ExecState* exec) const</span>
 973 {
 974     if (validateDFGDoesGC)
 975         RELEASE_ASSERT(vm().heap.expectDoesGC());
 976     if (isSubstring()) {
 977         auto&amp; base = substringBase()-&gt;valueInternal();
 978         if (base.is8Bit())
 979             return StringView(base.characters8() + substringOffset(), length());
 980         return StringView(base.characters16() + substringOffset(), length());
 981     }
<span class="line-modified"> 982     return resolveRope(exec);</span>
 983 }
 984 
<span class="line-modified"> 985 ALWAYS_INLINE StringViewWithUnderlyingString JSRopeString::viewWithUnderlyingString(ExecState* exec) const</span>
 986 {
 987     if (validateDFGDoesGC)
 988         RELEASE_ASSERT(vm().heap.expectDoesGC());
 989     if (isSubstring()) {
 990         auto&amp; base = substringBase()-&gt;valueInternal();
 991         if (base.is8Bit())
 992             return { { base.characters8() + substringOffset(), length() }, base };
 993         return { { base.characters16() + substringOffset(), length() }, base };
 994     }
<span class="line-modified"> 995     auto&amp; string = resolveRope(exec);</span>
 996     return { string, string };
 997 }
 998 
<span class="line-modified"> 999 ALWAYS_INLINE StringView JSString::unsafeView(ExecState* exec) const</span>
1000 {
1001     if (validateDFGDoesGC)
1002         RELEASE_ASSERT(vm().heap.expectDoesGC());
1003     if (isRope())
<span class="line-modified">1004         return static_cast&lt;const JSRopeString*&gt;(this)-&gt;unsafeView(exec);</span>
1005     return valueInternal();
1006 }
1007 
<span class="line-modified">1008 ALWAYS_INLINE StringViewWithUnderlyingString JSString::viewWithUnderlyingString(ExecState* exec) const</span>
1009 {
1010     if (isRope())
<span class="line-modified">1011         return static_cast&lt;const JSRopeString&amp;&gt;(*this).viewWithUnderlyingString(exec);</span>
1012     return { valueInternal(), valueInternal() };
1013 }
1014 
1015 inline bool JSString::isSubstring() const
1016 {
1017     return m_fiber &amp; JSRopeString::isSubstringInPointer;
1018 }
1019 
1020 // --- JSValue inlines ----------------------------
1021 
<span class="line-modified">1022 inline bool JSValue::toBoolean(ExecState* exec) const</span>
1023 {
1024     if (isInt32())
1025         return asInt32();
1026     if (isDouble())
1027         return asDouble() &gt; 0.0 || asDouble() &lt; 0.0; // false for NaN
1028     if (isCell())
<span class="line-modified">1029         return asCell()-&gt;toBoolean(exec);</span>
1030     return isTrue(); // false, null, and undefined all convert to false.
1031 }
1032 
<span class="line-modified">1033 inline JSString* JSValue::toString(ExecState* exec) const</span>
1034 {
1035     if (isString())
1036         return asString(asCell());
1037     bool returnEmptyStringOnError = true;
<span class="line-modified">1038     return toStringSlowCase(exec, returnEmptyStringOnError);</span>
1039 }
1040 
<span class="line-modified">1041 inline JSString* JSValue::toStringOrNull(ExecState* exec) const</span>
1042 {
1043     if (isString())
1044         return asString(asCell());
1045     bool returnEmptyStringOnError = false;
<span class="line-modified">1046     return toStringSlowCase(exec, returnEmptyStringOnError);</span>
1047 }
1048 
<span class="line-modified">1049 inline String JSValue::toWTFString(ExecState* exec) const</span>
1050 {
1051     if (isString())
<span class="line-modified">1052         return static_cast&lt;JSString*&gt;(asCell())-&gt;value(exec);</span>
<span class="line-modified">1053     return toWTFStringSlowCase(exec);</span>
1054 }
1055 
1056 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
   2  *  Copyright (C) 1999-2001 Harri Porten (porten@kde.org)
   3  *  Copyright (C) 2001 Peter Kelly (pmk@post.com)
<span class="line-modified">   4  *  Copyright (C) 2003-2020 Apple Inc. All rights reserved.</span>
   5  *
   6  *  This library is free software; you can redistribute it and/or
   7  *  modify it under the terms of the GNU Library General Public
   8  *  License as published by the Free Software Foundation; either
   9  *  version 2 of the License, or (at your option) any later version.
  10  *
  11  *  This library is distributed in the hope that it will be useful,
  12  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  13  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14  *  Library General Public License for more details.
  15  *
  16  *  You should have received a copy of the GNU Library General Public License
  17  *  along with this library; see the file COPYING.LIB.  If not, write to
  18  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19  *  Boston, MA 02110-1301, USA.
  20  *
  21  */
  22 
  23 #pragma once
  24 
  25 #include &quot;ArgList.h&quot;
  26 #include &quot;CallFrame.h&quot;
  27 #include &quot;CommonIdentifiers.h&quot;
<span class="line-added">  28 #include &quot;GetVM.h&quot;</span>
  29 #include &quot;Identifier.h&quot;
  30 #include &quot;PropertyDescriptor.h&quot;
  31 #include &quot;PropertySlot.h&quot;
  32 #include &quot;Structure.h&quot;
  33 #include &quot;ThrowScope.h&quot;
  34 #include &lt;array&gt;
  35 #include &lt;wtf/CheckedArithmetic.h&gt;
  36 #include &lt;wtf/ForbidHeapAllocation.h&gt;
  37 #include &lt;wtf/text/StringView.h&gt;
  38 
  39 namespace JSC {
  40 
  41 class JSString;
  42 class JSRopeString;
  43 class LLIntOffsetsExtractor;
  44 
  45 JSString* jsEmptyString(VM&amp;);
  46 JSString* jsString(VM&amp;, const String&amp;); // returns empty string if passed null string
  47 
  48 JSString* jsSingleCharacterString(VM&amp;, UChar);
</pre>
<hr />
<pre>
  72 // and 3rd fibers into the following 80byte fields. One problem is that now 2nd and 3rd fibers are split. Storing and loading 2nd and 3rd fibers
  73 // are not one pointer load operation. To make concurrent collector work correctly, we must initialize 2nd and 3rd fibers at JSRopeString creation
  74 // and we must not modify these part later.
  75 //
  76 //              0                        8        10               16                       32                                     48
  77 // JSString     [   ID      ][  header  ][   String pointer      0]
  78 // JSRopeString [   ID      ][  header  ][   1st fiber         xyz][  length  ][2nd lower32][2nd upper16][3rd lower16][3rd upper32]
  79 //                                                               ^
  80 //                                            x:(is8Bit),y:(isSubstring),z:(isRope) bit flags
  81 class JSString : public JSCell {
  82 public:
  83     friend class JIT;
  84     friend class VM;
  85     friend class SpecializedThunkJIT;
  86     friend class JSRopeString;
  87     friend class MarkStack;
  88     friend class SlotVisitor;
  89     friend class SmallStrings;
  90 
  91     typedef JSCell Base;
<span class="line-modified">  92     static constexpr unsigned StructureFlags = Base::StructureFlags | OverridesGetOwnPropertySlot | InterceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero | StructureIsImmortal | OverridesToThis;</span>
  93 
<span class="line-modified">  94     static constexpr bool needsDestruction = true;</span>
<span class="line-modified">  95     static ALWAYS_INLINE void destroy(JSCell* cell)</span>
<span class="line-added">  96     {</span>
<span class="line-added">  97         static_cast&lt;JSString*&gt;(cell)-&gt;JSString::~JSString();</span>
<span class="line-added">  98     }</span>
  99 
 100     // We specialize the string subspace to get the fastest possible sweep. This wouldn&#39;t be
 101     // necessary if JSString didn&#39;t have a destructor.
 102     template&lt;typename, SubspaceAccess&gt;
<span class="line-modified"> 103     static IsoSubspace* subspaceFor(VM&amp; vm)</span>
 104     {
 105         return &amp;vm.stringSpace;
 106     }
 107 
 108     // We employ overflow checks in many places with the assumption that MaxLength
 109     // is INT_MAX. Hence, it cannot be changed into another length value without
 110     // breaking all the bounds and overflow checks that assume this.
 111     static constexpr unsigned MaxLength = std::numeric_limits&lt;int32_t&gt;::max();
 112     static_assert(MaxLength == String::MaxLength, &quot;&quot;);
 113 
 114     static constexpr uintptr_t isRopeInPointer = 0x1;
 115 
 116 private:
 117     String&amp; uninitializedValueInternal() const
 118     {
 119         return *bitwise_cast&lt;String*&gt;(&amp;m_fiber);
 120     }
 121 
 122     String&amp; valueInternal() const
 123     {
</pre>
<hr />
<pre>
 163         newString-&gt;finishCreation(vm, length, cost);
 164         return newString;
 165     }
 166     static JSString* createHasOtherOwner(VM&amp; vm, Ref&lt;StringImpl&gt;&amp;&amp; value)
 167     {
 168         unsigned length = value-&gt;length();
 169         JSString* newString = new (NotNull, allocateCell&lt;JSString&gt;(vm.heap)) JSString(vm, WTFMove(value));
 170         newString-&gt;finishCreation(vm, length);
 171         return newString;
 172     }
 173 
 174 protected:
 175     void finishCreation(VM&amp; vm)
 176     {
 177         Base::finishCreation(vm);
 178     }
 179 
 180 public:
 181     ~JSString();
 182 
<span class="line-modified"> 183     Identifier toIdentifier(JSGlobalObject*) const;</span>
<span class="line-modified"> 184     AtomString toAtomString(JSGlobalObject*) const;</span>
<span class="line-modified"> 185     RefPtr&lt;AtomStringImpl&gt; toExistingAtomString(JSGlobalObject*) const;</span>
 186 
<span class="line-modified"> 187     StringViewWithUnderlyingString viewWithUnderlyingString(JSGlobalObject*) const;</span>
 188 
<span class="line-modified"> 189     inline bool equal(JSGlobalObject*, JSString* other) const;</span>
<span class="line-modified"> 190     const String&amp; value(JSGlobalObject*) const;</span>
 191     inline const String&amp; tryGetValue(bool allocationAllowed = true) const;
<span class="line-added"> 192     const StringImpl* getValueImpl() const;</span>
 193     const StringImpl* tryGetValueImpl() const;
 194     ALWAYS_INLINE unsigned length() const;
 195 
<span class="line-modified"> 196     JSValue toPrimitive(JSGlobalObject*, PreferredPrimitiveType) const;</span>
 197     bool toBoolean() const { return !!length(); }
<span class="line-modified"> 198     bool getPrimitiveNumber(JSGlobalObject*, double&amp; number, JSValue&amp;) const;</span>
<span class="line-modified"> 199     JSObject* toObject(JSGlobalObject*) const;</span>
<span class="line-modified"> 200     double toNumber(JSGlobalObject*) const;</span>
 201 
<span class="line-modified"> 202     bool getStringPropertySlot(JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified"> 203     bool getStringPropertySlot(JSGlobalObject*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="line-modified"> 204     bool getStringPropertyDescriptor(JSGlobalObject*, PropertyName, PropertyDescriptor&amp;);</span>
 205 
 206     bool canGetIndex(unsigned i) { return i &lt; length(); }
<span class="line-modified"> 207     JSString* getIndex(JSGlobalObject*, unsigned);</span>
 208 
 209     static Structure* createStructure(VM&amp;, JSGlobalObject*, JSValue);
 210 
 211     static ptrdiff_t offsetOfValue() { return OBJECT_OFFSETOF(JSString, m_fiber); }
 212 
 213     DECLARE_EXPORT_INFO;
 214 
 215     static void dumpToStream(const JSCell*, PrintStream&amp;);
 216     static size_t estimatedSize(JSCell*, VM&amp;);
 217     static void visitChildren(JSCell*, SlotVisitor&amp;);
 218 
 219     ALWAYS_INLINE bool isRope() const
 220     {
 221         return m_fiber &amp; isRopeInPointer;
 222     }
 223 
 224     bool is8Bit() const;
 225 
 226 protected:
 227     friend class JSValue;
 228 
<span class="line-modified"> 229     JS_EXPORT_PRIVATE bool equalSlowCase(JSGlobalObject*, JSString* other) const;</span>
 230     bool isSubstring() const;
 231 
 232     mutable uintptr_t m_fiber;
 233 
 234 private:
 235     friend class LLIntOffsetsExtractor;
 236 
<span class="line-modified"> 237     static JSValue toThis(JSCell*, JSGlobalObject*, ECMAMode);</span>
 238 
<span class="line-modified"> 239     StringView unsafeView(JSGlobalObject*) const;</span>
 240 
 241     friend JSString* jsString(VM&amp;, const String&amp;);
<span class="line-modified"> 242     friend JSString* jsString(JSGlobalObject*, JSString*, JSString*);</span>
<span class="line-modified"> 243     friend JSString* jsString(JSGlobalObject*, const String&amp;, JSString*);</span>
<span class="line-modified"> 244     friend JSString* jsString(JSGlobalObject*, JSString*, const String&amp;);</span>
<span class="line-modified"> 245     friend JSString* jsString(JSGlobalObject*, const String&amp;, const String&amp;);</span>
<span class="line-modified"> 246     friend JSString* jsString(JSGlobalObject*, JSString*, JSString*, JSString*);</span>
<span class="line-modified"> 247     friend JSString* jsString(JSGlobalObject*, const String&amp;, const String&amp;, const String&amp;);</span>
 248     friend JSString* jsSingleCharacterString(VM&amp;, UChar);
 249     friend JSString* jsNontrivialString(VM&amp;, const String&amp;);
 250     friend JSString* jsNontrivialString(VM&amp;, String&amp;&amp;);
 251     friend JSString* jsSubstring(VM&amp;, const String&amp;, unsigned, unsigned);
<span class="line-modified"> 252     friend JSString* jsSubstring(VM&amp;, JSGlobalObject*, JSString*, unsigned, unsigned);</span>
 253     friend JSString* jsSubstringOfResolved(VM&amp;, GCDeferralContext*, JSString*, unsigned, unsigned);
 254     friend JSString* jsOwnedString(VM&amp;, const String&amp;);
 255 };
 256 
 257 // NOTE: This class cannot override JSString&#39;s destructor. JSString&#39;s destructor is called directly
 258 // from JSStringSubspace::
 259 class JSRopeString final : public JSString {
 260     friend class JSString;
 261 public:
<span class="line-added"> 262     template&lt;typename, SubspaceAccess&gt;</span>
<span class="line-added"> 263     static IsoSubspace* subspaceFor(VM&amp; vm)</span>
<span class="line-added"> 264     {</span>
<span class="line-added"> 265         return &amp;vm.ropeStringSpace;</span>
<span class="line-added"> 266     }</span>
<span class="line-added"> 267 </span>
 268     // We use lower 3bits of fiber0 for flags. These bits are usable due to alignment, and it is OK even in 32bit architecture.
 269     static constexpr uintptr_t is8BitInPointer = static_cast&lt;uintptr_t&gt;(StringImpl::flagIs8Bit());
 270     static constexpr uintptr_t isSubstringInPointer = 0x2;
 271     static_assert(is8BitInPointer == 0b100, &quot;&quot;);
 272     static_assert(isSubstringInPointer == 0b010, &quot;&quot;);
 273     static_assert(isRopeInPointer == 0b001, &quot;&quot;);
 274     static constexpr uintptr_t stringMask = ~(isRopeInPointer | is8BitInPointer | isSubstringInPointer);
 275 #if CPU(ADDRESS64)
 276     static_assert(sizeof(uintptr_t) == sizeof(uint64_t), &quot;&quot;);
 277     class CompactFibers {
 278     public:
<span class="line-modified"> 279         static constexpr uintptr_t addressMask = (1ULL &lt;&lt; OS_CONSTANT(EFFECTIVE_ADDRESS_WIDTH)) - 1;</span>
 280         JSString* fiber1() const
 281         {
 282 #if CPU(LITTLE_ENDIAN)
 283             return bitwise_cast&lt;JSString*&gt;(WTF::unalignedLoad&lt;uintptr_t&gt;(&amp;m_fiber1Lower) &amp; addressMask);
 284 #else
 285             return bitwise_cast&lt;JSString*&gt;(static_cast&lt;uintptr_t&gt;(m_fiber1Lower) | (static_cast&lt;uintptr_t&gt;(m_fiber1Upper) &lt;&lt; 32));
 286 #endif
 287         }
 288 
 289         void initializeFiber1(JSString* fiber)
 290         {
 291             uintptr_t pointer = bitwise_cast&lt;uintptr_t&gt;(fiber);
 292             m_fiber1Lower = static_cast&lt;uint32_t&gt;(pointer);
 293             m_fiber1Upper = static_cast&lt;uint16_t&gt;(pointer &gt;&gt; 32);
 294         }
 295 
 296         JSString* fiber2() const
 297         {
 298 #if CPU(LITTLE_ENDIAN)
<span class="line-modified"> 299             return bitwise_cast&lt;JSString*&gt;(WTF::unalignedLoad&lt;uintptr_t&gt;(&amp;m_fiber1Upper) &gt;&gt; 16);</span>



 300 #else
 301             return bitwise_cast&lt;JSString*&gt;(static_cast&lt;uintptr_t&gt;(m_fiber2Lower) | (static_cast&lt;uintptr_t&gt;(m_fiber2Upper) &lt;&lt; 16));
 302 #endif
 303         }
 304         void initializeFiber2(JSString* fiber)
 305         {
 306             uintptr_t pointer = bitwise_cast&lt;uintptr_t&gt;(fiber);
 307             m_fiber2Lower = static_cast&lt;uint16_t&gt;(pointer);
 308             m_fiber2Upper = static_cast&lt;uint32_t&gt;(pointer &gt;&gt; 16);
 309         }
 310 
 311         unsigned length() const { return m_length; }
 312         void initializeLength(unsigned length)
 313         {
 314             m_length = length;
 315         }
 316 
 317         static ptrdiff_t offsetOfLength() { return OBJECT_OFFSETOF(CompactFibers, m_length); }
 318         static ptrdiff_t offsetOfFiber1() { return OBJECT_OFFSETOF(CompactFibers, m_length); }
 319         static ptrdiff_t offsetOfFiber2() { return OBJECT_OFFSETOF(CompactFibers, m_fiber1Upper); }
</pre>
<hr />
<pre>
 567         return newString;
 568     }
 569     static JSRopeString* create(VM&amp; vm, JSString* s1, JSString* s2, JSString* s3)
 570     {
 571         JSRopeString* newString = new (NotNull, allocateCell&lt;JSRopeString&gt;(vm.heap)) JSRopeString(vm, s1, s2, s3);
 572         newString-&gt;finishCreation(vm);
 573         ASSERT(newString-&gt;length());
 574         ASSERT(newString-&gt;isRope());
 575         return newString;
 576     }
 577 
 578     ALWAYS_INLINE static JSRopeString* createSubstringOfResolved(VM&amp; vm, GCDeferralContext* deferralContext, JSString* base, unsigned offset, unsigned length)
 579     {
 580         JSRopeString* newString = new (NotNull, allocateCell&lt;JSRopeString&gt;(vm.heap, deferralContext)) JSRopeString(vm, base, offset, length);
 581         newString-&gt;finishCreationSubstringOfResolved(vm);
 582         ASSERT(newString-&gt;length());
 583         ASSERT(newString-&gt;isRope());
 584         return newString;
 585     }
 586 
<span class="line-modified"> 587     friend JSValue jsStringFromRegisterArray(JSGlobalObject*, Register*, unsigned);</span>

 588 
 589     // If nullOrExecForOOM is null, resolveRope() will be do nothing in the event of an OOM error.
 590     // The rope value will remain a null string in that case.
<span class="line-modified"> 591     JS_EXPORT_PRIVATE const String&amp; resolveRope(JSGlobalObject* nullOrGlobalObjectForOOM) const;</span>
<span class="line-modified"> 592     template&lt;typename Function&gt; const String&amp; resolveRopeWithFunction(JSGlobalObject* nullOrGlobalObjectForOOM, Function&amp;&amp;) const;</span>
<span class="line-modified"> 593     JS_EXPORT_PRIVATE AtomString resolveRopeToAtomString(JSGlobalObject*) const;</span>
<span class="line-modified"> 594     JS_EXPORT_PRIVATE RefPtr&lt;AtomStringImpl&gt; resolveRopeToExistingAtomString(JSGlobalObject*) const;</span>
<span class="line-modified"> 595     template&lt;typename CharacterType&gt; NEVER_INLINE void resolveRopeSlowCase(CharacterType*) const;</span>
<span class="line-modified"> 596     template&lt;typename CharacterType&gt; void resolveRopeInternalNoSubstring(CharacterType*) const;</span>
<span class="line-modified"> 597     void outOfMemory(JSGlobalObject* nullOrGlobalObjectForOOM) const;</span>
 598     void resolveRopeInternal8(LChar*) const;

 599     void resolveRopeInternal16(UChar*) const;
<span class="line-modified"> 600     StringView unsafeView(JSGlobalObject*) const;</span>
<span class="line-modified"> 601     StringViewWithUnderlyingString viewWithUnderlyingString(JSGlobalObject*) const;</span>

 602 
 603     JSString* fiber0() const
 604     {
 605         return bitwise_cast&lt;JSString*&gt;(m_fiber &amp; stringMask);
 606     }
 607 
 608     JSString* fiber1() const
 609     {
 610         return m_compactFibers.fiber1();
 611     }
 612 
 613     JSString* fiber2() const
 614     {
 615         return m_compactFibers.fiber2();
 616     }
 617 
 618     JSString* fiber(unsigned i) const
 619     {
 620         ASSERT(!isSubstring());
 621         ASSERT(i &lt; s_maxInternalRopeLength);
</pre>
<hr />
<pre>
 651     void initializeSubstringBase(JSString* fiber)
 652     {
 653         initializeFiber1(fiber);
 654     }
 655 
 656     JSString* substringBase() const { return fiber1(); }
 657 
 658     void initializeSubstringOffset(unsigned offset)
 659     {
 660         m_compactFibers.initializeFiber2(bitwise_cast&lt;JSString*&gt;(static_cast&lt;uintptr_t&gt;(offset)));
 661     }
 662 
 663     unsigned substringOffset() const
 664     {
 665         return static_cast&lt;unsigned&gt;(bitwise_cast&lt;uintptr_t&gt;(fiber2()));
 666     }
 667 
 668     static_assert(s_maxInternalRopeLength &gt;= 2, &quot;&quot;);
 669     mutable CompactFibers m_compactFibers;
 670 
<span class="line-modified"> 671     friend JSString* jsString(JSGlobalObject*, JSString*, JSString*);</span>
<span class="line-modified"> 672     friend JSString* jsString(JSGlobalObject*, const String&amp;, JSString*);</span>
<span class="line-modified"> 673     friend JSString* jsString(JSGlobalObject*, JSString*, const String&amp;);</span>
<span class="line-modified"> 674     friend JSString* jsString(JSGlobalObject*, const String&amp;, const String&amp;);</span>
<span class="line-modified"> 675     friend JSString* jsString(JSGlobalObject*, JSString*, JSString*, JSString*);</span>
<span class="line-modified"> 676     friend JSString* jsString(JSGlobalObject*, const String&amp;, const String&amp;, const String&amp;);</span>
 677     friend JSString* jsSubstringOfResolved(VM&amp;, GCDeferralContext*, JSString*, unsigned, unsigned);
<span class="line-modified"> 678     friend JSString* jsSubstring(VM&amp;, JSGlobalObject*, JSString*, unsigned, unsigned);</span>
 679 };
 680 
 681 JS_EXPORT_PRIVATE JSString* jsStringWithCacheSlowCase(VM&amp;, StringImpl&amp;);
 682 
 683 // JSString::is8Bit is safe to be called concurrently. Concurrent threads can access is8Bit even if the main thread
 684 // is in the middle of converting JSRopeString to JSString.
 685 ALWAYS_INLINE bool JSString::is8Bit() const
 686 {
 687     uintptr_t pointer = m_fiber;
 688     if (pointer &amp; isRopeInPointer) {
 689         // Do not load m_fiber twice. We should use the information in pointer.
 690         // Otherwise, JSRopeString may be converted to JSString between the first and second accesses.
 691         return pointer &amp; JSRopeString::is8BitInPointer;
 692     }
 693     return bitwise_cast&lt;StringImpl*&gt;(pointer)-&gt;is8Bit();
 694 }
 695 
 696 // JSString::length is safe to be called concurrently. Concurrent threads can access length even if the main thread
 697 // is in the middle of converting JSRopeString to JSString. This is OK because we never override the length bits
 698 // when we resolve a JSRopeString.
 699 ALWAYS_INLINE unsigned JSString::length() const
 700 {
 701     uintptr_t pointer = m_fiber;
 702     if (pointer &amp; isRopeInPointer)
 703         return jsCast&lt;const JSRopeString*&gt;(this)-&gt;length();
 704     return bitwise_cast&lt;StringImpl*&gt;(pointer)-&gt;length();
 705 }
 706 
<span class="line-added"> 707 inline const StringImpl* JSString::getValueImpl() const</span>
<span class="line-added"> 708 {</span>
<span class="line-added"> 709     ASSERT(!isRope());</span>
<span class="line-added"> 710     return bitwise_cast&lt;StringImpl*&gt;(m_fiber);</span>
<span class="line-added"> 711 }</span>
<span class="line-added"> 712 </span>
 713 inline const StringImpl* JSString::tryGetValueImpl() const
 714 {
 715     uintptr_t pointer = m_fiber;
 716     if (pointer &amp; isRopeInPointer)
 717         return nullptr;
 718     return bitwise_cast&lt;StringImpl*&gt;(pointer);
 719 }
 720 
 721 inline JSString* asString(JSValue value)
 722 {
 723     ASSERT(value.asCell()-&gt;isString());
 724     return jsCast&lt;JSString*&gt;(value.asCell());
 725 }
 726 
 727 // This MUST NOT GC.
 728 inline JSString* jsEmptyString(VM&amp; vm)
 729 {
 730     return vm.smallStrings.emptyString();
 731 }
 732 
</pre>
<hr />
<pre>
 734 {
 735     if (validateDFGDoesGC)
 736         RELEASE_ASSERT(vm.heap.expectDoesGC());
 737     if (c &lt;= maxSingleCharacterString)
 738         return vm.smallStrings.singleCharacterString(c);
 739     return JSString::create(vm, StringImpl::create(&amp;c, 1));
 740 }
 741 
 742 inline JSString* jsNontrivialString(VM&amp; vm, const String&amp; s)
 743 {
 744     ASSERT(s.length() &gt; 1);
 745     return JSString::create(vm, *s.impl());
 746 }
 747 
 748 inline JSString* jsNontrivialString(VM&amp; vm, String&amp;&amp; s)
 749 {
 750     ASSERT(s.length() &gt; 1);
 751     return JSString::create(vm, s.releaseImpl().releaseNonNull());
 752 }
 753 
<span class="line-modified"> 754 ALWAYS_INLINE Identifier JSString::toIdentifier(JSGlobalObject* globalObject) const</span>
 755 {
<span class="line-modified"> 756     VM&amp; vm = getVM(globalObject);</span>
 757     auto scope = DECLARE_THROW_SCOPE(vm);
<span class="line-modified"> 758     AtomString atomString = toAtomString(globalObject);</span>
 759     RETURN_IF_EXCEPTION(scope, { });
 760     return Identifier::fromString(vm, atomString);
 761 }
 762 
<span class="line-modified"> 763 ALWAYS_INLINE AtomString JSString::toAtomString(JSGlobalObject* globalObject) const</span>
 764 {
 765     if (validateDFGDoesGC)
 766         RELEASE_ASSERT(vm().heap.expectDoesGC());
 767     if (isRope())
<span class="line-modified"> 768         return static_cast&lt;const JSRopeString*&gt;(this)-&gt;resolveRopeToAtomString(globalObject);</span>
 769     return AtomString(valueInternal());
 770 }
 771 
<span class="line-modified"> 772 ALWAYS_INLINE RefPtr&lt;AtomStringImpl&gt; JSString::toExistingAtomString(JSGlobalObject* globalObject) const</span>
 773 {
 774     if (validateDFGDoesGC)
 775         RELEASE_ASSERT(vm().heap.expectDoesGC());
 776     if (isRope())
<span class="line-modified"> 777         return static_cast&lt;const JSRopeString*&gt;(this)-&gt;resolveRopeToExistingAtomString(globalObject);</span>
 778     if (valueInternal().impl()-&gt;isAtom())
 779         return static_cast&lt;AtomStringImpl*&gt;(valueInternal().impl());
 780     return AtomStringImpl::lookUp(valueInternal().impl());
 781 }
 782 
<span class="line-modified"> 783 inline const String&amp; JSString::value(JSGlobalObject* globalObject) const</span>
 784 {
 785     if (validateDFGDoesGC)
 786         RELEASE_ASSERT(vm().heap.expectDoesGC());
 787     if (isRope())
<span class="line-modified"> 788         return static_cast&lt;const JSRopeString*&gt;(this)-&gt;resolveRope(globalObject);</span>
 789     return valueInternal();
 790 }
 791 
 792 inline const String&amp; JSString::tryGetValue(bool allocationAllowed) const
 793 {
 794     if (allocationAllowed) {
 795         if (validateDFGDoesGC)
 796             RELEASE_ASSERT(vm().heap.expectDoesGC());
 797         if (isRope()) {
<span class="line-modified"> 798             // Pass nullptr for the JSGlobalObject so that resolveRope does not throw in the event of an OOM error.</span>
 799             return static_cast&lt;const JSRopeString*&gt;(this)-&gt;resolveRope(nullptr);
 800         }
 801     } else
 802         RELEASE_ASSERT(!isRope());
 803     return valueInternal();
 804 }
 805 
<span class="line-modified"> 806 inline JSString* JSString::getIndex(JSGlobalObject* globalObject, unsigned i)</span>
 807 {
<span class="line-modified"> 808     VM&amp; vm = getVM(globalObject);</span>
 809     auto scope = DECLARE_THROW_SCOPE(vm);
 810     ASSERT(canGetIndex(i));
<span class="line-modified"> 811     StringView view = unsafeView(globalObject);</span>
 812     RETURN_IF_EXCEPTION(scope, nullptr);
 813     return jsSingleCharacterString(vm, view[i]);
 814 }
 815 
 816 inline JSString* jsString(VM&amp; vm, const String&amp; s)
 817 {
 818     int size = s.length();
 819     if (!size)
 820         return vm.smallStrings.emptyString();
 821     if (size == 1) {
 822         UChar c = s.characterAt(0);
 823         if (c &lt;= maxSingleCharacterString)
 824             return vm.smallStrings.singleCharacterString(c);
 825     }
 826     return JSString::create(vm, *s.impl());
 827 }
 828 
<span class="line-modified"> 829 inline JSString* jsSubstring(VM&amp; vm, JSGlobalObject* globalObject, JSString* base, unsigned offset, unsigned length)</span>
 830 {
 831     auto scope = DECLARE_THROW_SCOPE(vm);
 832 
 833     ASSERT(offset &lt;= base-&gt;length());
 834     ASSERT(length &lt;= base-&gt;length());
 835     ASSERT(offset + length &lt;= base-&gt;length());
 836     if (!length)
 837         return vm.smallStrings.emptyString();
 838     if (!offset &amp;&amp; length == base-&gt;length())
 839         return base;
 840 
 841     // For now, let&#39;s not allow substrings with a rope base.
 842     // Resolve non-substring rope bases so we don&#39;t have to deal with it.
 843     // FIXME: Evaluate if this would be worth adding more branches.
 844     if (base-&gt;isSubstring()) {
 845         JSRopeString* baseRope = jsCast&lt;JSRopeString*&gt;(base);
 846         base = baseRope-&gt;substringBase();
 847         offset = baseRope-&gt;substringOffset() + offset;
 848         ASSERT(!base-&gt;isRope());
 849     } else if (base-&gt;isRope()) {
<span class="line-modified"> 850         jsCast&lt;JSRopeString*&gt;(base)-&gt;resolveRope(globalObject);</span>
 851         RETURN_IF_EXCEPTION(scope, nullptr);
 852     }
 853     return jsSubstringOfResolved(vm, nullptr, base, offset, length);
 854 }
 855 
 856 inline JSString* jsSubstringOfResolved(VM&amp; vm, GCDeferralContext* deferralContext, JSString* s, unsigned offset, unsigned length)
 857 {
 858     ASSERT(offset &lt;= s-&gt;length());
 859     ASSERT(length &lt;= s-&gt;length());
 860     ASSERT(offset + length &lt;= s-&gt;length());
 861     ASSERT(!s-&gt;isRope());
 862     if (!length)
 863         return vm.smallStrings.emptyString();
 864     if (!offset &amp;&amp; length == s-&gt;length())
 865         return s;
 866     if (length == 1) {
 867         auto&amp; base = s-&gt;valueInternal();
 868         UChar character = base.characterAt(offset);
 869         if (character &lt;= maxSingleCharacterString)
 870             return vm.smallStrings.singleCharacterString(character);
 871     }
 872     return JSRopeString::createSubstringOfResolved(vm, deferralContext, s, offset, length);
 873 }
 874 
 875 inline JSString* jsSubstringOfResolved(VM&amp; vm, JSString* s, unsigned offset, unsigned length)
 876 {
 877     return jsSubstringOfResolved(vm, nullptr, s, offset, length);
 878 }
 879 
<span class="line-modified"> 880 inline JSString* jsSubstring(JSGlobalObject* globalObject, JSString* s, unsigned offset, unsigned length)</span>
 881 {
<span class="line-modified"> 882     return jsSubstring(getVM(globalObject), globalObject, s, offset, length);</span>
 883 }
 884 
 885 inline JSString* jsSubstring(VM&amp; vm, const String&amp; s, unsigned offset, unsigned length)
 886 {
 887     ASSERT(offset &lt;= s.length());
 888     ASSERT(length &lt;= s.length());
 889     ASSERT(offset + length &lt;= s.length());
 890     if (!length)
 891         return vm.smallStrings.emptyString();
 892     if (length == 1) {
 893         UChar c = s.characterAt(offset);
 894         if (c &lt;= maxSingleCharacterString)
 895             return vm.smallStrings.singleCharacterString(c);
 896     }
 897     auto impl = StringImpl::createSubstringSharingImpl(*s.impl(), offset, length);
 898     if (impl-&gt;isSubString())
 899         return JSString::createHasOtherOwner(vm, WTFMove(impl));
 900     return JSString::create(vm, WTFMove(impl));
 901 }
 902 
 903 inline JSString* jsOwnedString(VM&amp; vm, const String&amp; s)
 904 {
 905     int size = s.length();
 906     if (!size)
 907         return vm.smallStrings.emptyString();
 908     if (size == 1) {
 909         UChar c = s.characterAt(0);
 910         if (c &lt;= maxSingleCharacterString)
 911             return vm.smallStrings.singleCharacterString(c);
 912     }
 913     return JSString::createHasOtherOwner(vm, *s.impl());
 914 }
 915 
<span class="line-modified"> 916 ALWAYS_INLINE JSString* jsStringWithCache(JSGlobalObject* globalObject, const String&amp; s)</span>
 917 {
<span class="line-modified"> 918     VM&amp; vm = getVM(globalObject);</span>
 919     StringImpl* stringImpl = s.impl();
 920     if (!stringImpl || !stringImpl-&gt;length())
 921         return jsEmptyString(vm);
 922 
 923     if (stringImpl-&gt;length() == 1) {
 924         UChar singleCharacter = (*stringImpl)[0u];
 925         if (singleCharacter &lt;= maxSingleCharacterString)
 926             return vm.smallStrings.singleCharacterString(static_cast&lt;unsigned char&gt;(singleCharacter));
 927     }
 928 
 929     if (JSString* lastCachedString = vm.lastCachedString.get()) {
 930         if (lastCachedString-&gt;tryGetValueImpl() == stringImpl)
 931             return lastCachedString;
 932     }
 933 
 934     return jsStringWithCacheSlowCase(vm, *stringImpl);
 935 }
 936 
<span class="line-modified"> 937 ALWAYS_INLINE bool JSString::getStringPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
 938 {
<span class="line-modified"> 939     VM&amp; vm = getVM(globalObject);</span>
 940     auto scope = DECLARE_THROW_SCOPE(vm);
 941 
 942     if (propertyName == vm.propertyNames-&gt;length) {
 943         slot.setValue(this, PropertyAttribute::DontEnum | PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, jsNumber(length()));
 944         return true;
 945     }
 946 
 947     Optional&lt;uint32_t&gt; index = parseIndex(propertyName);
 948     if (index &amp;&amp; index.value() &lt; length()) {
<span class="line-modified"> 949         JSValue value = getIndex(globalObject, index.value());</span>
 950         RETURN_IF_EXCEPTION(scope, false);
 951         slot.setValue(this, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, value);
 952         return true;
 953     }
 954 
 955     return false;
 956 }
 957 
<span class="line-modified"> 958 ALWAYS_INLINE bool JSString::getStringPropertySlot(JSGlobalObject* globalObject, unsigned propertyName, PropertySlot&amp; slot)</span>
 959 {
<span class="line-modified"> 960     VM&amp; vm = getVM(globalObject);</span>
 961     auto scope = DECLARE_THROW_SCOPE(vm);
 962 
 963     if (propertyName &lt; length()) {
<span class="line-modified"> 964         JSValue value = getIndex(globalObject, propertyName);</span>
 965         RETURN_IF_EXCEPTION(scope, false);
 966         slot.setValue(this, PropertyAttribute::DontDelete | PropertyAttribute::ReadOnly, value);
 967         return true;
 968     }
 969 
 970     return false;
 971 }
 972 
 973 inline bool isJSString(JSCell* cell)
 974 {
 975     return cell-&gt;type() == StringType;
 976 }
 977 
 978 inline bool isJSString(JSValue v)
 979 {
 980     return v.isCell() &amp;&amp; isJSString(v.asCell());
 981 }
 982 
<span class="line-modified"> 983 ALWAYS_INLINE StringView JSRopeString::unsafeView(JSGlobalObject* globalObject) const</span>
 984 {
 985     if (validateDFGDoesGC)
 986         RELEASE_ASSERT(vm().heap.expectDoesGC());
 987     if (isSubstring()) {
 988         auto&amp; base = substringBase()-&gt;valueInternal();
 989         if (base.is8Bit())
 990             return StringView(base.characters8() + substringOffset(), length());
 991         return StringView(base.characters16() + substringOffset(), length());
 992     }
<span class="line-modified"> 993     return resolveRope(globalObject);</span>
 994 }
 995 
<span class="line-modified"> 996 ALWAYS_INLINE StringViewWithUnderlyingString JSRopeString::viewWithUnderlyingString(JSGlobalObject* globalObject) const</span>
 997 {
 998     if (validateDFGDoesGC)
 999         RELEASE_ASSERT(vm().heap.expectDoesGC());
1000     if (isSubstring()) {
1001         auto&amp; base = substringBase()-&gt;valueInternal();
1002         if (base.is8Bit())
1003             return { { base.characters8() + substringOffset(), length() }, base };
1004         return { { base.characters16() + substringOffset(), length() }, base };
1005     }
<span class="line-modified">1006     auto&amp; string = resolveRope(globalObject);</span>
1007     return { string, string };
1008 }
1009 
<span class="line-modified">1010 ALWAYS_INLINE StringView JSString::unsafeView(JSGlobalObject* globalObject) const</span>
1011 {
1012     if (validateDFGDoesGC)
1013         RELEASE_ASSERT(vm().heap.expectDoesGC());
1014     if (isRope())
<span class="line-modified">1015         return static_cast&lt;const JSRopeString*&gt;(this)-&gt;unsafeView(globalObject);</span>
1016     return valueInternal();
1017 }
1018 
<span class="line-modified">1019 ALWAYS_INLINE StringViewWithUnderlyingString JSString::viewWithUnderlyingString(JSGlobalObject* globalObject) const</span>
1020 {
1021     if (isRope())
<span class="line-modified">1022         return static_cast&lt;const JSRopeString&amp;&gt;(*this).viewWithUnderlyingString(globalObject);</span>
1023     return { valueInternal(), valueInternal() };
1024 }
1025 
1026 inline bool JSString::isSubstring() const
1027 {
1028     return m_fiber &amp; JSRopeString::isSubstringInPointer;
1029 }
1030 
1031 // --- JSValue inlines ----------------------------
1032 
<span class="line-modified">1033 inline bool JSValue::toBoolean(JSGlobalObject* globalObject) const</span>
1034 {
1035     if (isInt32())
1036         return asInt32();
1037     if (isDouble())
1038         return asDouble() &gt; 0.0 || asDouble() &lt; 0.0; // false for NaN
1039     if (isCell())
<span class="line-modified">1040         return asCell()-&gt;toBoolean(globalObject);</span>
1041     return isTrue(); // false, null, and undefined all convert to false.
1042 }
1043 
<span class="line-modified">1044 inline JSString* JSValue::toString(JSGlobalObject* globalObject) const</span>
1045 {
1046     if (isString())
1047         return asString(asCell());
1048     bool returnEmptyStringOnError = true;
<span class="line-modified">1049     return toStringSlowCase(globalObject, returnEmptyStringOnError);</span>
1050 }
1051 
<span class="line-modified">1052 inline JSString* JSValue::toStringOrNull(JSGlobalObject* globalObject) const</span>
1053 {
1054     if (isString())
1055         return asString(asCell());
1056     bool returnEmptyStringOnError = false;
<span class="line-modified">1057     return toStringSlowCase(globalObject, returnEmptyStringOnError);</span>
1058 }
1059 
<span class="line-modified">1060 inline String JSValue::toWTFString(JSGlobalObject* globalObject) const</span>
1061 {
1062     if (isString())
<span class="line-modified">1063         return static_cast&lt;JSString*&gt;(asCell())-&gt;value(globalObject);</span>
<span class="line-modified">1064     return toWTFStringSlowCase(globalObject);</span>
1065 }
1066 
1067 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSString.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSStringInlines.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/libwebrtc/LibWebRTCMediaEndpoint.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2017-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1.  Redistributions of source code must retain the above copyright
  8  *     notice, this list of conditions and the following disclaimer.
  9  * 2.  Redistributions in binary form must reproduce the above copyright
 10  *     notice, this list of conditions and the following disclaimer in the
 11  *     documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 15  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 16  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 17  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 18  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 19  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 20  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 21  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 22  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 23  */
 24 
 25 #include &quot;config.h&quot;
 26 #include &quot;LibWebRTCMediaEndpoint.h&quot;
 27 
 28 #if USE(LIBWEBRTC)
 29 
 30 #include &quot;EventNames.h&quot;
<a name="1" id="anc1"></a><span class="line-added"> 31 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 32 #include &quot;JSRTCStatsReport.h&quot;
 33 #include &quot;LibWebRTCDataChannelHandler.h&quot;
 34 #include &quot;LibWebRTCPeerConnectionBackend.h&quot;
 35 #include &quot;LibWebRTCProvider.h&quot;
 36 #include &quot;LibWebRTCRtpReceiverBackend.h&quot;
 37 #include &quot;LibWebRTCRtpSenderBackend.h&quot;
 38 #include &quot;LibWebRTCRtpTransceiverBackend.h&quot;
 39 #include &quot;LibWebRTCStatsCollector.h&quot;
 40 #include &quot;LibWebRTCUtils.h&quot;
 41 #include &quot;Logging.h&quot;
 42 #include &quot;NotImplemented.h&quot;
 43 #include &quot;Performance.h&quot;
 44 #include &quot;PlatformStrategies.h&quot;
 45 #include &quot;RTCDataChannel.h&quot;
 46 #include &quot;RTCDataChannelEvent.h&quot;
 47 #include &quot;RTCOfferOptions.h&quot;
 48 #include &quot;RTCPeerConnection.h&quot;
 49 #include &quot;RTCSessionDescription.h&quot;
 50 #include &quot;RTCStatsReport.h&quot;
 51 #include &quot;RealtimeIncomingAudioSource.h&quot;
 52 #include &quot;RealtimeIncomingVideoSource.h&quot;
 53 #include &quot;RealtimeOutgoingAudioSource.h&quot;
 54 #include &quot;RealtimeOutgoingVideoSource.h&quot;
 55 #include &quot;RuntimeEnabledFeatures.h&quot;
<a name="2" id="anc2"></a><span class="line-modified"> 56 #include &lt;webrtc/rtc_base/physical_socket_server.h&gt;</span>
<span class="line-modified"> 57 #include &lt;webrtc/p2p/base/basic_packet_socket_factory.h&gt;</span>
<span class="line-modified"> 58 #include &lt;webrtc/p2p/client/basic_port_allocator.h&gt;</span>
<span class="line-modified"> 59 #include &lt;webrtc/pc/peer_connection_factory.h&gt;</span>
 60 #include &lt;webrtc/system_wrappers/include/field_trial.h&gt;
 61 #include &lt;wtf/MainThread.h&gt;
 62 
 63 namespace WebCore {
 64 
 65 LibWebRTCMediaEndpoint::LibWebRTCMediaEndpoint(LibWebRTCPeerConnectionBackend&amp; peerConnection, LibWebRTCProvider&amp; client)
 66     : m_peerConnectionBackend(peerConnection)
 67     , m_peerConnectionFactory(*client.factory())
 68     , m_createSessionDescriptionObserver(*this)
 69     , m_setLocalSessionDescriptionObserver(*this)
 70     , m_setRemoteSessionDescriptionObserver(*this)
 71     , m_statsLogTimer(*this, &amp;LibWebRTCMediaEndpoint::gatherStatsForLogging)
 72 #if !RELEASE_LOG_DISABLED
 73     , m_logger(peerConnection.logger())
 74     , m_logIdentifier(peerConnection.logIdentifier())
 75 #endif
 76 {
 77     ASSERT(isMainThread());
 78     ASSERT(client.factory());
 79 
 80     if (RuntimeEnabledFeatures::sharedFeatures().webRTCH264SimulcastEnabled())
 81         webrtc::field_trial::InitFieldTrialsFromString(&quot;WebRTC-H264Simulcast/Enabled/&quot;);
 82 }
 83 
 84 bool LibWebRTCMediaEndpoint::setConfiguration(LibWebRTCProvider&amp; client, webrtc::PeerConnectionInterface::RTCConfiguration&amp;&amp; configuration)
 85 {
<a name="3" id="anc3"></a><span class="line-modified"> 86     configuration.sdp_semantics = webrtc::SdpSemantics::kUnifiedPlan;</span>

 87 
 88     if (!m_backend) {
 89         if (!m_rtcSocketFactory) {
 90             auto&amp; document = downcast&lt;Document&gt;(*m_peerConnectionBackend.connection().scriptExecutionContext());
<a name="4" id="anc4"></a><span class="line-modified"> 91             m_rtcSocketFactory = client.createSocketFactory(document.userAgent(document.url()));</span>
 92         }
 93         m_backend = client.createPeerConnection(*this, m_rtcSocketFactory.get(), WTFMove(configuration));
 94         return !!m_backend;
 95     }
 96     auto oldConfiguration = m_backend-&gt;GetConfiguration();
 97     configuration.certificates = oldConfiguration.certificates;
<a name="5" id="anc5"></a><span class="line-modified"> 98     return m_backend-&gt;SetConfiguration(WTFMove(configuration)).ok();</span>
<span class="line-added"> 99 }</span>
<span class="line-added">100 </span>
<span class="line-added">101 void LibWebRTCMediaEndpoint::suspend()</span>
<span class="line-added">102 {</span>
<span class="line-added">103     if (m_rtcSocketFactory)</span>
<span class="line-added">104         m_rtcSocketFactory-&gt;suspend();</span>
<span class="line-added">105 }</span>
<span class="line-added">106 </span>
<span class="line-added">107 void LibWebRTCMediaEndpoint::resume()</span>
<span class="line-added">108 {</span>
<span class="line-added">109     if (m_rtcSocketFactory)</span>
<span class="line-added">110         m_rtcSocketFactory-&gt;resume();</span>
111 }
112 
113 static inline const char* sessionDescriptionType(RTCSdpType sdpType)
114 {
115     switch (sdpType) {
116     case RTCSdpType::Offer:
117         return &quot;offer&quot;;
118     case RTCSdpType::Pranswer:
119         return &quot;pranswer&quot;;
120     case RTCSdpType::Answer:
121         return &quot;answer&quot;;
122     case RTCSdpType::Rollback:
123         return &quot;rollback&quot;;
124     }
125 
126     ASSERT_NOT_REACHED();
127     return &quot;&quot;;
128 }
129 
130 static inline RTCSdpType fromSessionDescriptionType(const webrtc::SessionDescriptionInterface&amp; description)
131 {
132     auto type = description.type();
133     if (type == webrtc::SessionDescriptionInterface::kOffer)
134         return RTCSdpType::Offer;
135     if (type == webrtc::SessionDescriptionInterface::kAnswer)
136         return RTCSdpType::Answer;
137     ASSERT(type == webrtc::SessionDescriptionInterface::kPrAnswer);
138     return RTCSdpType::Pranswer;
139 }
140 
141 static inline RefPtr&lt;RTCSessionDescription&gt; fromSessionDescription(const webrtc::SessionDescriptionInterface* description)
142 {
143     if (!description)
144         return nullptr;
145 
146     std::string sdp;
147     description-&gt;ToString(&amp;sdp);
148 
149     return RTCSessionDescription::create(fromSessionDescriptionType(*description), fromStdString(sdp));
150 }
151 
152 // FIXME: We might want to create a new object only if the session actually changed for all description getters.
153 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::currentLocalDescription() const
154 {
155     return m_backend ? fromSessionDescription(m_backend-&gt;current_local_description()) : nullptr;
156 }
157 
158 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::currentRemoteDescription() const
159 {
160     return m_backend ? fromSessionDescription(m_backend-&gt;current_remote_description()) : nullptr;
161 }
162 
163 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::pendingLocalDescription() const
164 {
165     return m_backend ? fromSessionDescription(m_backend-&gt;pending_local_description()) : nullptr;
166 }
167 
168 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::pendingRemoteDescription() const
169 {
170     return m_backend ? fromSessionDescription(m_backend-&gt;pending_remote_description()) : nullptr;
171 }
172 
173 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::localDescription() const
174 {
175     return m_backend ? fromSessionDescription(m_backend-&gt;local_description()) : nullptr;
176 }
177 
178 RefPtr&lt;RTCSessionDescription&gt; LibWebRTCMediaEndpoint::remoteDescription() const
179 {
180     return m_backend ? fromSessionDescription(m_backend-&gt;remote_description()) : nullptr;
181 }
182 
183 void LibWebRTCMediaEndpoint::doSetLocalDescription(RTCSessionDescription&amp; description)
184 {
185     ASSERT(m_backend);
186 
187     webrtc::SdpParseError error;
188     std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt; sessionDescription(webrtc::CreateSessionDescription(sessionDescriptionType(description.type()), description.sdp().utf8().data(), &amp;error));
189 
190     if (!sessionDescription) {
191         m_peerConnectionBackend.setLocalDescriptionFailed(Exception { OperationError, fromStdString(error.description) });
192         return;
193     }
194 
195     // FIXME: See https://bugs.webkit.org/show_bug.cgi?id=173783. Remove this test once fixed at LibWebRTC level.
196     if (description.type() == RTCSdpType::Answer &amp;&amp; !m_backend-&gt;pending_remote_description()) {
197         m_peerConnectionBackend.setLocalDescriptionFailed(Exception { InvalidStateError, &quot;Failed to set local answer sdp: no pending remote description.&quot;_s });
198         return;
199     }
200 
201     m_backend-&gt;SetLocalDescription(&amp;m_setLocalSessionDescriptionObserver, sessionDescription.release());
202 }
203 
204 void LibWebRTCMediaEndpoint::doSetRemoteDescription(RTCSessionDescription&amp; description)
205 {
206     ASSERT(m_backend);
207 
208     webrtc::SdpParseError error;
209     std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt; sessionDescription(webrtc::CreateSessionDescription(sessionDescriptionType(description.type()), description.sdp().utf8().data(), &amp;error));
210     if (!sessionDescription) {
211         m_peerConnectionBackend.setRemoteDescriptionFailed(Exception { SyntaxError, fromStdString(error.description) });
212         return;
213     }
214     m_backend-&gt;SetRemoteDescription(&amp;m_setRemoteSessionDescriptionObserver, sessionDescription.release());
215 
216     startLoggingStats();
217 }
218 
219 bool LibWebRTCMediaEndpoint::addTrack(LibWebRTCRtpSenderBackend&amp; sender, MediaStreamTrack&amp; track, const Vector&lt;String&gt;&amp; mediaStreamIds)
220 {
221     ASSERT(m_backend);
222 
<a name="6" id="anc6"></a>








223     LibWebRTCRtpSenderBackend::Source source;
224     rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt; rtcTrack;
225     switch (track.privateTrack().type()) {
226     case RealtimeMediaSource::Type::Audio: {
227         auto audioSource = RealtimeOutgoingAudioSource::create(track.privateTrack());
228         rtcTrack = m_peerConnectionFactory.CreateAudioTrack(track.id().utf8().data(), audioSource.ptr());
229         source = WTFMove(audioSource);
230         break;
231     }
232     case RealtimeMediaSource::Type::Video: {
233         auto videoSource = RealtimeOutgoingVideoSource::create(track.privateTrack());
234         rtcTrack = m_peerConnectionFactory.CreateVideoTrack(track.id().utf8().data(), videoSource.ptr());
235         source = WTFMove(videoSource);
236         break;
237     }
238     case RealtimeMediaSource::Type::None:
239         ASSERT_NOT_REACHED();
240         return false;
241     }
242 
243     sender.setSource(WTFMove(source));
244     if (auto rtpSender = sender.rtcSender()) {
245         rtpSender-&gt;SetTrack(rtcTrack.get());
246         return true;
247     }
248 
249     std::vector&lt;std::string&gt; ids;
250     for (auto&amp; id : mediaStreamIds)
251         ids.push_back(id.utf8().data());
252 
253     auto newRTPSender = m_backend-&gt;AddTrack(rtcTrack.get(), WTFMove(ids));
254     if (!newRTPSender.ok())
255         return false;
256     sender.setRTCSender(newRTPSender.MoveValue());
257     return true;
258 }
259 
260 void LibWebRTCMediaEndpoint::removeTrack(LibWebRTCRtpSenderBackend&amp; sender)
261 {
262     ASSERT(m_backend);
263     m_backend-&gt;RemoveTrack(sender.rtcSender());
264     sender.clearSource();
265 }
266 
267 void LibWebRTCMediaEndpoint::doCreateOffer(const RTCOfferOptions&amp; options)
268 {
269     ASSERT(m_backend);
270 
271     m_isInitiator = true;
272     webrtc::PeerConnectionInterface::RTCOfferAnswerOptions rtcOptions;
273     rtcOptions.ice_restart = options.iceRestart;
274     rtcOptions.voice_activity_detection = options.voiceActivityDetection;
275 
<a name="7" id="anc7"></a>





276     m_backend-&gt;CreateOffer(&amp;m_createSessionDescriptionObserver, rtcOptions);
277 }
278 
279 void LibWebRTCMediaEndpoint::doCreateAnswer()
280 {
281     ASSERT(m_backend);
282 
283     m_isInitiator = false;
284     m_backend-&gt;CreateAnswer(&amp;m_createSessionDescriptionObserver, { });
285 }
286 
287 rtc::scoped_refptr&lt;LibWebRTCStatsCollector&gt; LibWebRTCMediaEndpoint::createStatsCollector(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
288 {
<a name="8" id="anc8"></a><span class="line-modified">289     return LibWebRTCStatsCollector::create([promise = WTFMove(promise), protectedThis = makeRef(*this)](auto&amp;&amp; report) mutable {</span>
290         ASSERT(isMainThread());
<a name="9" id="anc9"></a><span class="line-modified">291         if (protectedThis-&gt;isStopped() || !report)</span>
<span class="line-modified">292             return;</span>




293 
<a name="10" id="anc10"></a><span class="line-modified">294         promise-&gt;resolve&lt;IDLInterface&lt;RTCStatsReport&gt;&gt;(report.releaseNonNull());</span>



295     });
296 }
297 
298 void LibWebRTCMediaEndpoint::getStats(Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
299 {
300     if (m_backend)
301         m_backend-&gt;GetStats(createStatsCollector(WTFMove(promise)));
302 }
303 
304 void LibWebRTCMediaEndpoint::getStats(webrtc::RtpReceiverInterface&amp; receiver, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
305 {
306     if (m_backend)
307         m_backend-&gt;GetStats(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;(&amp;receiver), createStatsCollector(WTFMove(promise)));
308 }
309 
310 void LibWebRTCMediaEndpoint::getStats(webrtc::RtpSenderInterface&amp; sender, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
311 {
312     if (m_backend)
313         m_backend-&gt;GetStats(rtc::scoped_refptr&lt;webrtc::RtpSenderInterface&gt;(&amp;sender), createStatsCollector(WTFMove(promise)));
314 }
315 
316 static RTCSignalingState signalingState(webrtc::PeerConnectionInterface::SignalingState state)
317 {
318     switch (state) {
319     case webrtc::PeerConnectionInterface::kStable:
320         return RTCSignalingState::Stable;
321     case webrtc::PeerConnectionInterface::kHaveLocalOffer:
322         return RTCSignalingState::HaveLocalOffer;
323     case webrtc::PeerConnectionInterface::kHaveLocalPrAnswer:
324         return RTCSignalingState::HaveLocalPranswer;
325     case webrtc::PeerConnectionInterface::kHaveRemoteOffer:
326         return RTCSignalingState::HaveRemoteOffer;
327     case webrtc::PeerConnectionInterface::kHaveRemotePrAnswer:
328         return RTCSignalingState::HaveRemotePranswer;
329     case webrtc::PeerConnectionInterface::kClosed:
330         return RTCSignalingState::Stable;
331     }
332 
333     ASSERT_NOT_REACHED();
334     return RTCSignalingState::Stable;
335 }
336 
337 void LibWebRTCMediaEndpoint::OnSignalingChange(webrtc::PeerConnectionInterface::SignalingState rtcState)
338 {
339     auto state = signalingState(rtcState);
340     callOnMainThread([protectedThis = makeRef(*this), state] {
341         if (protectedThis-&gt;isStopped())
342             return;
343         protectedThis-&gt;m_peerConnectionBackend.updateSignalingState(state);
344     });
345 }
346 
347 MediaStream&amp; LibWebRTCMediaEndpoint::mediaStreamFromRTCStream(webrtc::MediaStreamInterface&amp; rtcStream)
348 {
349     auto label = fromStdString(rtcStream.id());
350     auto mediaStream = m_remoteStreamsById.ensure(label, [label, this]() mutable {
351         auto&amp; document = downcast&lt;Document&gt;(*m_peerConnectionBackend.connection().scriptExecutionContext());
352         return MediaStream::create(document, MediaStreamPrivate::create(document.logger(), { }, WTFMove(label)));
353     });
354     return *mediaStream.iterator-&gt;value;
355 }
356 
357 void LibWebRTCMediaEndpoint::addRemoteStream(webrtc::MediaStreamInterface&amp;)
358 {
359 }
360 
361 void LibWebRTCMediaEndpoint::addRemoteTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;&amp;&amp; rtcReceiver, const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp; rtcStreams)
362 {
363     ASSERT(rtcReceiver);
364     RefPtr&lt;RTCRtpReceiver&gt; receiver;
365     RefPtr&lt;RealtimeMediaSource&gt; remoteSource;
366 
367     auto* rtcTrack = rtcReceiver-&gt;track().get();
368 
369     switch (rtcReceiver-&gt;media_type()) {
370     case cricket::MEDIA_TYPE_DATA:
371         return;
372     case cricket::MEDIA_TYPE_AUDIO: {
373         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcTrack);
374         auto audioReceiver = m_peerConnectionBackend.audioReceiver(fromStdString(rtcTrack-&gt;id()));
375 
376         receiver = WTFMove(audioReceiver.receiver);
377         audioReceiver.source-&gt;setSourceTrack(WTFMove(audioTrack));
378         break;
379     }
380     case cricket::MEDIA_TYPE_VIDEO: {
381         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcTrack);
382         auto videoReceiver = m_peerConnectionBackend.videoReceiver(fromStdString(rtcTrack-&gt;id()));
383 
384         receiver = WTFMove(videoReceiver.receiver);
385         videoReceiver.source-&gt;setSourceTrack(WTFMove(videoTrack));
386         break;
387     }
388     }
389 
390     receiver-&gt;setBackend(makeUnique&lt;LibWebRTCRtpReceiverBackend&gt;(WTFMove(rtcReceiver)));
391     auto&amp; track = receiver-&gt;track();
392     addPendingTrackEvent(receiver.releaseNonNull(), track, rtcStreams, nullptr);
393 }
394 
395 void LibWebRTCMediaEndpoint::addPendingTrackEvent(Ref&lt;RTCRtpReceiver&gt;&amp;&amp; receiver, MediaStreamTrack&amp; track, const std::vector&lt;rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt;&gt;&amp; rtcStreams, RefPtr&lt;RTCRtpTransceiver&gt;&amp;&amp; transceiver)
396 {
397     Vector&lt;RefPtr&lt;MediaStream&gt;&gt; streams;
398     for (auto&amp; rtcStream : rtcStreams) {
399         auto&amp; mediaStream = mediaStreamFromRTCStream(*rtcStream.get());
400         streams.append(&amp;mediaStream);
401         mediaStream.addTrackFromPlatform(track);
402     }
403     auto streamIds = WTF::map(streams, [](auto&amp; stream) -&gt; String {
404         return stream-&gt;id();
405     });
406     m_remoteStreamsFromRemoteTrack.add(&amp;track, WTFMove(streamIds));
407 
408     m_peerConnectionBackend.addPendingTrackEvent({ WTFMove(receiver), makeRef(track), WTFMove(streams), WTFMove(transceiver) });
409 }
410 
411 static inline void setExistingReceiverSourceTrack(RealtimeMediaSource&amp; existingSource, webrtc::RtpReceiverInterface&amp; rtcReceiver)
412 {
413     switch (rtcReceiver.media_type()) {
414     case cricket::MEDIA_TYPE_AUDIO: {
415         ASSERT(existingSource.type() == RealtimeMediaSource::Type::Audio);
416         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcReceiver.track().get());
417         downcast&lt;RealtimeIncomingAudioSource&gt;(existingSource).setSourceTrack(WTFMove(audioTrack));
418         return;
419     }
420     case cricket::MEDIA_TYPE_VIDEO: {
421         ASSERT(existingSource.type() == RealtimeMediaSource::Type::Video);
422         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcReceiver.track().get());
423         downcast&lt;RealtimeIncomingVideoSource&gt;(existingSource).setSourceTrack(WTFMove(videoTrack));
424         return;
425     }
426     case cricket::MEDIA_TYPE_DATA:
427         ASSERT_NOT_REACHED();
428         return;
429     }
430 }
431 
432 RefPtr&lt;RealtimeMediaSource&gt; LibWebRTCMediaEndpoint::sourceFromNewReceiver(webrtc::RtpReceiverInterface&amp; rtcReceiver)
433 {
434     auto rtcTrack = rtcReceiver.track();
435     switch (rtcReceiver.media_type()) {
436     case cricket::MEDIA_TYPE_DATA:
437         return nullptr;
438     case cricket::MEDIA_TYPE_AUDIO: {
439         rtc::scoped_refptr&lt;webrtc::AudioTrackInterface&gt; audioTrack = static_cast&lt;webrtc::AudioTrackInterface*&gt;(rtcTrack.get());
440         return RealtimeIncomingAudioSource::create(WTFMove(audioTrack), fromStdString(rtcTrack-&gt;id()));
441     }
442     case cricket::MEDIA_TYPE_VIDEO: {
443         rtc::scoped_refptr&lt;webrtc::VideoTrackInterface&gt; videoTrack = static_cast&lt;webrtc::VideoTrackInterface*&gt;(rtcTrack.get());
444         return RealtimeIncomingVideoSource::create(WTFMove(videoTrack), fromStdString(rtcTrack-&gt;id()));
445     }
446     }
447 
448     RELEASE_ASSERT_NOT_REACHED();
449 }
450 
451 void LibWebRTCMediaEndpoint::collectTransceivers()
452 {
453     if (!m_backend)
454         return;
455 
<a name="11" id="anc11"></a>


456     for (auto&amp; rtcTransceiver : m_backend-&gt;GetTransceivers()) {
457         auto* existingTransceiver = m_peerConnectionBackend.existingTransceiver([&amp;](auto&amp; transceiverBackend) {
458             return rtcTransceiver.get() == transceiverBackend.rtcTransceiver();
459         });
460         if (existingTransceiver)
461             continue;
462 
463         auto rtcReceiver = rtcTransceiver-&gt;receiver();
464         auto source = sourceFromNewReceiver(*rtcReceiver);
465         if (!source)
466             return;
467 
468         m_peerConnectionBackend.newRemoteTransceiver(makeUnique&lt;LibWebRTCRtpTransceiverBackend&gt;(WTFMove(rtcTransceiver)), source.releaseNonNull());
469     }
470 }
471 
472 void LibWebRTCMediaEndpoint::newTransceiver(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt;&amp;&amp; rtcTransceiver)
473 {
474     auto* transceiver = m_peerConnectionBackend.existingTransceiver([&amp;](auto&amp; transceiverBackend) {
475         return rtcTransceiver.get() == transceiverBackend.rtcTransceiver();
476     });
477     if (transceiver) {
478         auto rtcReceiver = rtcTransceiver-&gt;receiver();
479         setExistingReceiverSourceTrack(transceiver-&gt;receiver().track().source(), *rtcReceiver);
480         addPendingTrackEvent(makeRef(transceiver-&gt;receiver()), transceiver-&gt;receiver().track(), rtcReceiver-&gt;streams(), makeRef(*transceiver));
481         return;
482     }
483 
484     auto rtcReceiver = rtcTransceiver-&gt;receiver();
485     auto source = sourceFromNewReceiver(*rtcReceiver);
486     if (!source)
487         return;
488 
489     auto&amp; newTransceiver = m_peerConnectionBackend.newRemoteTransceiver(makeUnique&lt;LibWebRTCRtpTransceiverBackend&gt;(WTFMove(rtcTransceiver)), source.releaseNonNull());
490 
491     addPendingTrackEvent(makeRef(newTransceiver.receiver()), newTransceiver.receiver().track(), rtcReceiver-&gt;streams(), makeRef(newTransceiver));
492 }
493 
494 void LibWebRTCMediaEndpoint::removeRemoteTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt;&amp;&amp; receiver)
495 {
<a name="12" id="anc12"></a>



496     auto* transceiver = m_peerConnectionBackend.existingTransceiver([&amp;receiver](auto&amp; transceiverBackend) {
497         auto* rtcTransceiver = transceiverBackend.rtcTransceiver();
498         return rtcTransceiver &amp;&amp; receiver.get() == rtcTransceiver-&gt;receiver().get();
499     });
500     if (!transceiver)
501         return;
502 
503     auto&amp; track = transceiver-&gt;receiver().track();
504 
505     for (auto&amp; id : m_remoteStreamsFromRemoteTrack.get(&amp;track)) {
506         if (auto stream = m_remoteStreamsById.get(id))
507             stream-&gt;privateStream().removeTrack(track.privateTrack(), MediaStreamPrivate::NotifyClientOption::Notify);
508     }
509 
510     track.source().setMuted(true);
511 }
512 
513 template&lt;typename T&gt;
514 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::createTransceiverBackends(T&amp;&amp; trackOrKind, const RTCRtpTransceiverInit&amp; init, LibWebRTCRtpSenderBackend::Source&amp;&amp; source)
515 {
516     auto result = m_backend-&gt;AddTransceiver(WTFMove(trackOrKind), fromRtpTransceiverInit(init));
517     if (!result.ok())
518         return WTF::nullopt;
519 
520     auto transceiver = makeUnique&lt;LibWebRTCRtpTransceiverBackend&gt;(result.MoveValue());
521     return LibWebRTCMediaEndpoint::Backends { transceiver-&gt;createSenderBackend(m_peerConnectionBackend, WTFMove(source)), transceiver-&gt;createReceiverBackend(), WTFMove(transceiver) };
522 }
523 
524 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::addTransceiver(const String&amp; trackKind, const RTCRtpTransceiverInit&amp; init)
525 {
526     auto type = trackKind == &quot;audio&quot; ? cricket::MediaType::MEDIA_TYPE_AUDIO : cricket::MediaType::MEDIA_TYPE_VIDEO;
527     return createTransceiverBackends(type, init, nullptr);
528 }
529 
530 std::pair&lt;LibWebRTCRtpSenderBackend::Source, rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt;&gt; LibWebRTCMediaEndpoint::createSourceAndRTCTrack(MediaStreamTrack&amp; track)
531 {
532     LibWebRTCRtpSenderBackend::Source source;
533     rtc::scoped_refptr&lt;webrtc::MediaStreamTrackInterface&gt; rtcTrack;
534     switch (track.privateTrack().type()) {
535     case RealtimeMediaSource::Type::None:
536         ASSERT_NOT_REACHED();
537         break;
538     case RealtimeMediaSource::Type::Audio: {
539         auto audioSource = RealtimeOutgoingAudioSource::create(track.privateTrack());
540         rtcTrack = m_peerConnectionFactory.CreateAudioTrack(track.id().utf8().data(), audioSource.ptr());
541         source = WTFMove(audioSource);
542         break;
543     }
544     case RealtimeMediaSource::Type::Video: {
545         auto videoSource = RealtimeOutgoingVideoSource::create(track.privateTrack());
546         rtcTrack = m_peerConnectionFactory.CreateVideoTrack(track.id().utf8().data(), videoSource.ptr());
547         source = WTFMove(videoSource);
548         break;
549     }
550     }
551     return std::make_pair(WTFMove(source), WTFMove(rtcTrack));
552 }
553 
554 Optional&lt;LibWebRTCMediaEndpoint::Backends&gt; LibWebRTCMediaEndpoint::addTransceiver(MediaStreamTrack&amp; track, const RTCRtpTransceiverInit&amp; init)
555 {
556     auto sourceAndTrack = createSourceAndRTCTrack(track);
557     return createTransceiverBackends(WTFMove(sourceAndTrack.second), init, WTFMove(sourceAndTrack.first));
558 }
559 
560 void LibWebRTCMediaEndpoint::setSenderSourceFromTrack(LibWebRTCRtpSenderBackend&amp; sender, MediaStreamTrack&amp; track)
561 {
562     auto sourceAndTrack = createSourceAndRTCTrack(track);
563     sender.setSource(WTFMove(sourceAndTrack.first));
564     sender.rtcSender()-&gt;SetTrack(WTFMove(sourceAndTrack.second));
565 }
566 
567 std::unique_ptr&lt;LibWebRTCRtpTransceiverBackend&gt; LibWebRTCMediaEndpoint::transceiverBackendFromSender(LibWebRTCRtpSenderBackend&amp; backend)
568 {
569     for (auto&amp; transceiver : m_backend-&gt;GetTransceivers()) {
570         if (transceiver-&gt;sender().get() == backend.rtcSender())
571             return makeUnique&lt;LibWebRTCRtpTransceiverBackend&gt;(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt;(transceiver));
572     }
573     return nullptr;
574 }
575 
576 
577 void LibWebRTCMediaEndpoint::removeRemoteStream(webrtc::MediaStreamInterface&amp; rtcStream)
578 {
579     bool removed = m_remoteStreamsById.remove(fromStdString(rtcStream.id()));
580     ASSERT_UNUSED(removed, removed);
581 }
582 
583 void LibWebRTCMediaEndpoint::OnAddStream(rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt; stream)
584 {
585     callOnMainThread([protectedThis = makeRef(*this), stream = WTFMove(stream)] {
586         if (protectedThis-&gt;isStopped())
587             return;
588         ASSERT(stream);
589         protectedThis-&gt;addRemoteStream(*stream.get());
590     });
591 }
592 
593 void LibWebRTCMediaEndpoint::OnRemoveStream(rtc::scoped_refptr&lt;webrtc::MediaStreamInterface&gt; stream)
594 {
595     callOnMainThread([protectedThis = makeRef(*this), stream = WTFMove(stream)] {
596         if (protectedThis-&gt;isStopped())
597             return;
598         ASSERT(stream);
599         protectedThis-&gt;removeRemoteStream(*stream.get());
600     });
601 }
602 
<a name="13" id="anc13"></a>











603 void LibWebRTCMediaEndpoint::OnTrack(rtc::scoped_refptr&lt;webrtc::RtpTransceiverInterface&gt; transceiver)
604 {
<a name="14" id="anc14"></a>


605     callOnMainThread([protectedThis = makeRef(*this), transceiver = WTFMove(transceiver)]() mutable {
606         if (protectedThis-&gt;isStopped())
607             return;
608         protectedThis-&gt;newTransceiver(WTFMove(transceiver));
609     });
610 }
611 
612 void LibWebRTCMediaEndpoint::OnRemoveTrack(rtc::scoped_refptr&lt;webrtc::RtpReceiverInterface&gt; receiver)
613 {
614     callOnMainThread([protectedThis = makeRef(*this), receiver = WTFMove(receiver)]() mutable {
615         if (protectedThis-&gt;isStopped())
616             return;
617         protectedThis-&gt;removeRemoteTrack(WTFMove(receiver));
618     });
619 }
620 
621 std::unique_ptr&lt;RTCDataChannelHandler&gt; LibWebRTCMediaEndpoint::createDataChannel(const String&amp; label, const RTCDataChannelInit&amp; options)
622 {
623     auto init = LibWebRTCDataChannelHandler::fromRTCDataChannelInit(options);
624     auto channel = m_backend-&gt;CreateDataChannel(label.utf8().data(), &amp;init);
625     return channel ? makeUnique&lt;LibWebRTCDataChannelHandler&gt;(WTFMove(channel)) : nullptr;
626 }
627 
628 void LibWebRTCMediaEndpoint::OnDataChannel(rtc::scoped_refptr&lt;webrtc::DataChannelInterface&gt; dataChannel)
629 {
630     callOnMainThread([protectedThis = makeRef(*this), dataChannel = WTFMove(dataChannel)]() mutable {
631         if (protectedThis-&gt;isStopped())
632             return;
633         auto&amp; connection = protectedThis-&gt;m_peerConnectionBackend.connection();
<a name="15" id="anc15"></a><span class="line-modified">634         connection.dispatchEventWhenFeasible(LibWebRTCDataChannelHandler::channelEvent(*connection.document(), WTFMove(dataChannel)));</span>
635     });
636 }
637 
<a name="16" id="anc16"></a><span class="line-added">638 void LibWebRTCMediaEndpoint::close()</span>
<span class="line-added">639 {</span>
<span class="line-added">640     m_backend-&gt;Close();</span>
<span class="line-added">641     stopLoggingStats();</span>
<span class="line-added">642 }</span>
<span class="line-added">643 </span>
644 void LibWebRTCMediaEndpoint::stop()
645 {
646     if (!m_backend)
647         return;
648 
649     stopLoggingStats();
650 
651     m_backend-&gt;Close();
652     m_backend = nullptr;
653     m_remoteStreamsById.clear();
654     m_remoteStreamsFromRemoteTrack.clear();
655 }
656 
657 void LibWebRTCMediaEndpoint::OnRenegotiationNeeded()
658 {
659     callOnMainThread([protectedThis = makeRef(*this)] {
660         if (protectedThis-&gt;isStopped())
661             return;
662         protectedThis-&gt;m_peerConnectionBackend.markAsNeedingNegotiation();
663     });
664 }
665 
666 static inline RTCIceConnectionState toRTCIceConnectionState(webrtc::PeerConnectionInterface::IceConnectionState state)
667 {
668     switch (state) {
669     case webrtc::PeerConnectionInterface::kIceConnectionNew:
670         return RTCIceConnectionState::New;
671     case webrtc::PeerConnectionInterface::kIceConnectionChecking:
672         return RTCIceConnectionState::Checking;
673     case webrtc::PeerConnectionInterface::kIceConnectionConnected:
674         return RTCIceConnectionState::Connected;
675     case webrtc::PeerConnectionInterface::kIceConnectionCompleted:
676         return RTCIceConnectionState::Completed;
677     case webrtc::PeerConnectionInterface::kIceConnectionFailed:
678         return RTCIceConnectionState::Failed;
679     case webrtc::PeerConnectionInterface::kIceConnectionDisconnected:
680         return RTCIceConnectionState::Disconnected;
681     case webrtc::PeerConnectionInterface::kIceConnectionClosed:
682         return RTCIceConnectionState::Closed;
683     case webrtc::PeerConnectionInterface::kIceConnectionMax:
684         break;
685     }
686 
687     ASSERT_NOT_REACHED();
688     return RTCIceConnectionState::New;
689 }
690 
691 void LibWebRTCMediaEndpoint::OnIceConnectionChange(webrtc::PeerConnectionInterface::IceConnectionState state)
692 {
693     auto connectionState = toRTCIceConnectionState(state);
694     callOnMainThread([protectedThis = makeRef(*this), connectionState] {
695         if (protectedThis-&gt;isStopped())
696             return;
697         if (protectedThis-&gt;m_peerConnectionBackend.connection().iceConnectionState() != connectionState)
698             protectedThis-&gt;m_peerConnectionBackend.connection().updateIceConnectionState(connectionState);
699     });
700 }
701 
702 void LibWebRTCMediaEndpoint::OnIceGatheringChange(webrtc::PeerConnectionInterface::IceGatheringState state)
703 {
704     callOnMainThread([protectedThis = makeRef(*this), state] {
705         if (protectedThis-&gt;isStopped())
706             return;
707         if (state == webrtc::PeerConnectionInterface::kIceGatheringComplete)
708             protectedThis-&gt;m_peerConnectionBackend.doneGatheringCandidates();
709         else if (state == webrtc::PeerConnectionInterface::kIceGatheringGathering)
710             protectedThis-&gt;m_peerConnectionBackend.connection().updateIceGatheringState(RTCIceGatheringState::Gathering);
711     });
712 }
713 
714 void LibWebRTCMediaEndpoint::OnIceCandidate(const webrtc::IceCandidateInterface *rtcCandidate)
715 {
716     ASSERT(rtcCandidate);
717 
718     std::string sdp;
719     rtcCandidate-&gt;ToString(&amp;sdp);
720 
721     auto sdpMLineIndex = safeCast&lt;unsigned short&gt;(rtcCandidate-&gt;sdp_mline_index());
722 
723     callOnMainThread([protectedThis = makeRef(*this), mid = fromStdString(rtcCandidate-&gt;sdp_mid()), sdp = fromStdString(sdp), sdpMLineIndex, url = fromStdString(rtcCandidate-&gt;server_url())]() mutable {
724         if (protectedThis-&gt;isStopped())
725             return;
726         protectedThis-&gt;m_peerConnectionBackend.newICECandidate(WTFMove(sdp), WTFMove(mid), sdpMLineIndex, WTFMove(url));
727     });
728 }
729 
730 void LibWebRTCMediaEndpoint::OnIceCandidatesRemoved(const std::vector&lt;cricket::Candidate&gt;&amp;)
731 {
732     ASSERT_NOT_REACHED();
733 }
734 
735 void LibWebRTCMediaEndpoint::createSessionDescriptionSucceeded(std::unique_ptr&lt;webrtc::SessionDescriptionInterface&gt;&amp;&amp; description)
736 {
737     std::string sdp;
738     description-&gt;ToString(&amp;sdp);
739 
740     callOnMainThread([protectedThis = makeRef(*this), sdp = fromStdString(sdp)]() mutable {
741         if (protectedThis-&gt;isStopped())
742             return;
743         if (protectedThis-&gt;m_isInitiator)
744             protectedThis-&gt;m_peerConnectionBackend.createOfferSucceeded(WTFMove(sdp));
745         else
746             protectedThis-&gt;m_peerConnectionBackend.createAnswerSucceeded(WTFMove(sdp));
747     });
748 }
749 
750 void LibWebRTCMediaEndpoint::createSessionDescriptionFailed(ExceptionCode errorCode, const char* errorMessage)
751 {
752     callOnMainThread([protectedThis = makeRef(*this), errorCode, errorMessage = String(errorMessage)] () mutable {
753         if (protectedThis-&gt;isStopped())
754             return;
755         if (protectedThis-&gt;m_isInitiator)
756             protectedThis-&gt;m_peerConnectionBackend.createOfferFailed(Exception { errorCode, WTFMove(errorMessage) });
757         else
758             protectedThis-&gt;m_peerConnectionBackend.createAnswerFailed(Exception { errorCode, WTFMove(errorMessage) });
759     });
760 }
761 
762 void LibWebRTCMediaEndpoint::setLocalSessionDescriptionSucceeded()
763 {
764     callOnMainThread([protectedThis = makeRef(*this)] {
765         if (protectedThis-&gt;isStopped())
766             return;
767         protectedThis-&gt;m_peerConnectionBackend.setLocalDescriptionSucceeded();
768     });
769 }
770 
771 void LibWebRTCMediaEndpoint::setLocalSessionDescriptionFailed(ExceptionCode errorCode, const char* errorMessage)
772 {
773     callOnMainThread([protectedThis = makeRef(*this), errorCode, errorMessage = String(errorMessage)] () mutable {
774         if (protectedThis-&gt;isStopped())
775             return;
776         protectedThis-&gt;m_peerConnectionBackend.setLocalDescriptionFailed(Exception { errorCode, WTFMove(errorMessage) });
777     });
778 }
779 
780 void LibWebRTCMediaEndpoint::setRemoteSessionDescriptionSucceeded()
781 {
782     callOnMainThread([protectedThis = makeRef(*this)] {
783         if (protectedThis-&gt;isStopped())
784             return;
785         protectedThis-&gt;m_peerConnectionBackend.setRemoteDescriptionSucceeded();
786     });
787 }
788 
789 void LibWebRTCMediaEndpoint::setRemoteSessionDescriptionFailed(ExceptionCode errorCode, const char* errorMessage)
790 {
791     callOnMainThread([protectedThis = makeRef(*this), errorCode, errorMessage = String(errorMessage)] () mutable {
792         if (protectedThis-&gt;isStopped())
793             return;
794         protectedThis-&gt;m_peerConnectionBackend.setRemoteDescriptionFailed(Exception { errorCode, WTFMove(errorMessage) });
795     });
796 }
797 
798 void LibWebRTCMediaEndpoint::gatherStatsForLogging()
799 {
800     m_backend-&gt;GetStats(this);
801 }
802 
803 class RTCStatsLogger {
804 public:
805     explicit RTCStatsLogger(const webrtc::RTCStats&amp; stats)
806         : m_stats(stats)
807     {
808     }
809 
810     String toJSONString() const { return String(m_stats.ToJson().c_str()); }
811 
812 private:
813     const webrtc::RTCStats&amp; m_stats;
814 };
815 
816 void LibWebRTCMediaEndpoint::OnStatsDelivered(const rtc::scoped_refptr&lt;const webrtc::RTCStatsReport&gt;&amp; report)
817 {
818 #if !RELEASE_LOG_DISABLED
819     int64_t timestamp = report-&gt;timestamp_us();
820     if (!m_statsFirstDeliveredTimestamp)
821         m_statsFirstDeliveredTimestamp = timestamp;
822 
823     callOnMainThread([protectedThis = makeRef(*this), this, timestamp, report] {
824         if (m_backend &amp;&amp; m_statsLogTimer.repeatInterval() != statsLogInterval(timestamp)) {
825             m_statsLogTimer.stop();
826             m_statsLogTimer.startRepeating(statsLogInterval(timestamp));
827         }
828 
829         for (auto iterator = report-&gt;begin(); iterator != report-&gt;end(); ++iterator) {
830             if (logger().willLog(logChannel(), WTFLogLevel::Debug)) {
831                 // Stats are very verbose, let&#39;s only display them in inspector console in verbose mode.
832                 logger().debug(LogWebRTC,
833                     Logger::LogSiteIdentifier(&quot;LibWebRTCMediaEndpoint&quot;, &quot;OnStatsDelivered&quot;, logIdentifier()),
834                     RTCStatsLogger { *iterator });
835             } else {
836                 logger().logAlways(LogWebRTCStats,
837                     Logger::LogSiteIdentifier(&quot;LibWebRTCMediaEndpoint&quot;, &quot;OnStatsDelivered&quot;, logIdentifier()),
838                     RTCStatsLogger { *iterator });
839             }
840         }
841     });
842 #else
843     UNUSED_PARAM(report);
844 #endif
845 }
846 
847 void LibWebRTCMediaEndpoint::startLoggingStats()
848 {
849 #if !RELEASE_LOG_DISABLED
850     if (m_statsLogTimer.isActive())
851         m_statsLogTimer.stop();
852     m_statsLogTimer.startRepeating(statsLogInterval(0));
853 #endif
854 }
855 
856 void LibWebRTCMediaEndpoint::stopLoggingStats()
857 {
858     m_statsLogTimer.stop();
859 }
860 
861 #if !RELEASE_LOG_DISABLED
862 WTFLogChannel&amp; LibWebRTCMediaEndpoint::logChannel() const
863 {
864     return LogWebRTC;
865 }
866 
867 Seconds LibWebRTCMediaEndpoint::statsLogInterval(int64_t reportTimestamp) const
868 {
869     if (logger().willLog(logChannel(), WTFLogLevel::Info))
870         return 2_s;
871 
872     if (reportTimestamp - m_statsFirstDeliveredTimestamp &gt; 15000000)
873         return 10_s;
874 
875     return 4_s;
876 }
877 #endif
878 
879 } // namespace WebCore
880 
881 namespace WTF {
882 
883 template&lt;typename Type&gt;
884 struct LogArgument;
885 
886 template &lt;&gt;
887 struct LogArgument&lt;WebCore::RTCStatsLogger&gt; {
888     static String toString(const WebCore::RTCStatsLogger&amp; logger)
889     {
890         return String(logger.toJSONString());
891     }
892 };
893 
894 }; // namespace WTF
895 
896 
897 #endif // USE(LIBWEBRTC)
<a name="17" id="anc17"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="17" type="hidden" />
</body>
</html>
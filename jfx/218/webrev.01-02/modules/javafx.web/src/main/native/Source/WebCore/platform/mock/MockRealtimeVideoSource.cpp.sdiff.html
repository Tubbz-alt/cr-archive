<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/mock/MockRealtimeVideoSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="MockRealtimeMediaSourceCenter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MockRealtimeVideoSource.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/mock/MockRealtimeVideoSource.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 39 #include &quot;Logging.h&quot;
 40 #include &quot;MediaConstraints.h&quot;
 41 #include &quot;MockRealtimeMediaSourceCenter.h&quot;
 42 #include &quot;NotImplemented.h&quot;
 43 #include &quot;PlatformLayer.h&quot;
 44 #include &quot;RealtimeMediaSourceSettings.h&quot;
 45 #include &quot;RealtimeVideoSource.h&quot;
 46 #include &lt;math.h&gt;
 47 #include &lt;wtf/UUID.h&gt;
 48 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 49 
 50 namespace WebCore {
 51 
 52 #if !PLATFORM(MAC) &amp;&amp; !PLATFORM(IOS_FAMILY) &amp;&amp; !(USE(GSTREAMER) &amp;&amp; USE(LIBWEBRTC))
 53 CaptureSourceOrError MockRealtimeVideoSource::create(String&amp;&amp; deviceID, String&amp;&amp; name, String&amp;&amp; hashSalt, const MediaConstraints* constraints)
 54 {
 55 #ifndef NDEBUG
 56     auto device = MockRealtimeMediaSourceCenter::mockDeviceWithPersistentID(deviceID);
 57     ASSERT(device);
 58     if (!device)
<span class="line-modified"> 59         return { };</span>
 60 #endif
 61 
 62     auto source = adoptRef(*new MockRealtimeVideoSource(WTFMove(deviceID), WTFMove(name), WTFMove(hashSalt)));
 63     if (constraints &amp;&amp; source-&gt;applyConstraints(*constraints))
 64         return { };
 65 
 66     return CaptureSourceOrError(RealtimeVideoSource::create(WTFMove(source)));
 67 }
 68 #endif
 69 
 70 MockRealtimeVideoSource::MockRealtimeVideoSource(String&amp;&amp; deviceID, String&amp;&amp; name, String&amp;&amp; hashSalt)
 71     : RealtimeVideoCaptureSource(WTFMove(name), WTFMove(deviceID), WTFMove(hashSalt))
 72     , m_emitFrameTimer(RunLoop::current(), this, &amp;MockRealtimeVideoSource::generateFrame)
 73 {
 74     auto device = MockRealtimeMediaSourceCenter::mockDeviceWithPersistentID(persistentID());
 75     ASSERT(device);
 76     m_device = *device;
 77 
 78     m_dashWidths.reserveInitialCapacity(2);
 79     m_dashWidths.uncheckedAppend(6);
</pre>
<hr />
<pre>
172     supportedConstraints.setSupportsWidth(true);
173     supportedConstraints.setSupportsHeight(true);
174     supportedConstraints.setSupportsAspectRatio(true);
175     if (mockCamera()) {
176         supportedConstraints.setSupportsDeviceId(true);
177         supportedConstraints.setSupportsFacingMode(true);
178     } else {
179         supportedConstraints.setSupportsDisplaySurface(true);
180         supportedConstraints.setSupportsLogicalSurface(true);
181     }
182     settings.setSupportedConstraints(supportedConstraints);
183 
184     m_currentSettings = WTFMove(settings);
185 
186     return m_currentSettings.value();
187 }
188 
189 void MockRealtimeVideoSource::setFrameRateWithPreset(double, RefPtr&lt;VideoPreset&gt; preset)
190 {
191     m_preset = WTFMove(preset);
<span class="line-modified">192     if (preset)</span>
<span class="line-modified">193         setIntrinsicSize(preset-&gt;size);</span>
194 }
195 
196 IntSize MockRealtimeVideoSource::captureSize() const
197 {
198     return m_preset ? m_preset-&gt;size : this-&gt;size();
199 }
200 
201 void MockRealtimeVideoSource::settingsDidChange(OptionSet&lt;RealtimeMediaSourceSettings::Flag&gt; settings)
202 {
203     m_currentSettings = WTF::nullopt;
204     if (settings.containsAny({ RealtimeMediaSourceSettings::Flag::Width, RealtimeMediaSourceSettings::Flag::Height })) {
205         m_baseFontSize = captureSize().height() * .08;
206         m_bipBopFontSize = m_baseFontSize * 2.5;
207         m_statsFontSize = m_baseFontSize * .5;
208         m_imageBuffer = nullptr;
209     }
210 }
211 
212 void MockRealtimeVideoSource::startCaptureTimer()
213 {
</pre>
<hr />
<pre>
245     m_path.clear();
246     m_path.moveTo(location);
247     m_path.addArc(location, radius, 0, 2 * piFloat, false);
248     m_path.closeSubpath();
249     context.setFillColor(Color::white);
250     context.setFillRule(WindRule::NonZero);
251     context.fillPath(m_path);
252 
253     float endAngle = piFloat * (((fmod(m_frameNumber, frameRate()) + 0.5) * (2.0 / frameRate())) + 1);
254     m_path.clear();
255     m_path.moveTo(location);
256     m_path.addArc(location, radius, 1.5 * piFloat, endAngle, false);
257     m_path.closeSubpath();
258     context.setFillColor(Color::gray);
259     context.setFillRule(WindRule::NonZero);
260     context.fillPath(m_path);
261 }
262 
263 void MockRealtimeVideoSource::drawBoxes(GraphicsContext&amp; context)
264 {
<span class="line-modified">265     static const RGBA32 magenta = 0xffff00ff;</span>
<span class="line-modified">266     static const RGBA32 yellow = 0xffffff00;</span>
<span class="line-modified">267     static const RGBA32 blue = 0xff0000ff;</span>
<span class="line-modified">268     static const RGBA32 red = 0xffff0000;</span>
<span class="line-removed">269     static const RGBA32 green = 0xff008000;</span>
<span class="line-removed">270     static const RGBA32 cyan = 0xFF00FFFF;</span>
271 
272     IntSize size = captureSize();
273     float boxSize = size.width() * .035;
274     float boxTop = size.height() * .6;
275 
276     m_path.clear();
277     FloatRect frameRect(2, 2, size.width() - 3, size.height() - 3);
278     context.setStrokeColor(Color::white);
279     context.setStrokeThickness(3);
280     context.setLineDash(m_dashWidths, 0);
281     m_path.addRect(frameRect);
282     m_path.closeSubpath();
283     context.strokePath(m_path);
284 
285     context.setLineDash(DashArray(), 0);
286     m_path.clear();
287     m_path.moveTo(FloatPoint(0, boxTop + boxSize));
288     m_path.addLineTo(FloatPoint(size.width(), boxTop + boxSize));
289     m_path.closeSubpath();
290     context.setStrokeColor(Color::white);
</pre>
<hr />
<pre>
300     }
301     boxLeft += boxSize + 2;
302     for (unsigned i = 0; i &lt; boxSize / 4; i++) {
303         m_path.moveTo(FloatPoint(boxLeft, boxTop + 4 * i));
304         m_path.addLineTo(FloatPoint(boxLeft + boxSize - 1, boxTop + 4 * i));
305     }
306     context.setStrokeThickness(3);
307     boxLeft += boxSize + 2;
308     for (unsigned i = 0; i &lt; boxSize / 8; i++) {
309         m_path.moveTo(FloatPoint(boxLeft + 8 * i, boxTop));
310         m_path.addLineTo(FloatPoint(boxLeft + 8 * i, boxTop + boxSize - 1));
311     }
312     boxLeft += boxSize + 2;
313     for (unsigned i = 0; i &lt; boxSize / 8; i++) {
314         m_path.moveTo(FloatPoint(boxLeft, boxTop + 8 * i));
315         m_path.addLineTo(FloatPoint(boxLeft + boxSize - 1, boxTop + 8 * i));
316     }
317 
318     boxTop += boxSize + 2;
319     boxLeft = boxSize;
<span class="line-modified">320     Color boxColors[] = { Color::white, yellow, cyan, green, magenta, red, blue };</span>
<span class="line-modified">321     for (unsigned i = 0; i &lt; sizeof(boxColors) / sizeof(boxColors[0]); i++) {</span>
<span class="line-modified">322         context.fillRect(FloatRect(boxLeft, boxTop, boxSize + 1, boxSize + 1), boxColors[i]);</span>
323         boxLeft += boxSize + 1;
324     }
325     context.strokePath(m_path);
326 }
327 
328 void MockRealtimeVideoSource::drawText(GraphicsContext&amp; context)
329 {
330     unsigned milliseconds = lround(elapsedTime().milliseconds());
331     unsigned seconds = milliseconds / 1000 % 60;
332     unsigned minutes = seconds / 60 % 60;
333     unsigned hours = minutes / 60 % 60;
334 
335     FontCascadeDescription fontDescription;
336     fontDescription.setOneFamily(&quot;Courier&quot;);
337     fontDescription.setWeight(FontSelectionValue(500));
338 
339     fontDescription.setSpecifiedSize(m_baseFontSize);
340     fontDescription.setComputedSize(m_baseFontSize);
341     FontCascade timeFont { FontCascadeDescription { fontDescription }, 0, 0 };
342     timeFont.update(nullptr);
</pre>
<hr />
<pre>
441 
442     auto size = captureSize();
443     FloatRect frameRect(FloatPoint(), size);
444 
445     context.fillRect(FloatRect(FloatPoint(), size), m_fillColor);
446 
447     if (!muted()) {
448         drawText(context);
449         drawAnimation(context);
450         drawBoxes(context);
451     }
452 
453     updateSampleBuffer();
454 }
455 
456 ImageBuffer* MockRealtimeVideoSource::imageBuffer() const
457 {
458     if (m_imageBuffer)
459         return m_imageBuffer.get();
460 
<span class="line-modified">461     m_imageBuffer = ImageBuffer::create(captureSize(), Unaccelerated);</span>
462     if (!m_imageBuffer)
463         return nullptr;
464 
<span class="line-modified">465     m_imageBuffer-&gt;context().setImageInterpolationQuality(InterpolationDefault);</span>
466     m_imageBuffer-&gt;context().setStrokeThickness(1);
467 
468     return m_imageBuffer.get();
469 }
470 
471 bool MockRealtimeVideoSource::mockDisplayType(CaptureDevice::DeviceType type) const
472 {
473     if (!WTF::holds_alternative&lt;MockDisplayProperties&gt;(m_device.properties))
474         return false;
475 
476     return WTF::get&lt;MockDisplayProperties&gt;(m_device.properties).type == type;
477 }
478 
479 void MockRealtimeVideoSource::orientationChanged(int orientation)
480 {
481     auto deviceOrientation = m_deviceOrientation;
482     switch (orientation) {
483     case 0:
484         m_deviceOrientation = MediaSample::VideoRotation::None;
485         break;
</pre>
</td>
<td>
<hr />
<pre>
 39 #include &quot;Logging.h&quot;
 40 #include &quot;MediaConstraints.h&quot;
 41 #include &quot;MockRealtimeMediaSourceCenter.h&quot;
 42 #include &quot;NotImplemented.h&quot;
 43 #include &quot;PlatformLayer.h&quot;
 44 #include &quot;RealtimeMediaSourceSettings.h&quot;
 45 #include &quot;RealtimeVideoSource.h&quot;
 46 #include &lt;math.h&gt;
 47 #include &lt;wtf/UUID.h&gt;
 48 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 49 
 50 namespace WebCore {
 51 
 52 #if !PLATFORM(MAC) &amp;&amp; !PLATFORM(IOS_FAMILY) &amp;&amp; !(USE(GSTREAMER) &amp;&amp; USE(LIBWEBRTC))
 53 CaptureSourceOrError MockRealtimeVideoSource::create(String&amp;&amp; deviceID, String&amp;&amp; name, String&amp;&amp; hashSalt, const MediaConstraints* constraints)
 54 {
 55 #ifndef NDEBUG
 56     auto device = MockRealtimeMediaSourceCenter::mockDeviceWithPersistentID(deviceID);
 57     ASSERT(device);
 58     if (!device)
<span class="line-modified"> 59         return { &quot;No mock camera device&quot;_s };</span>
 60 #endif
 61 
 62     auto source = adoptRef(*new MockRealtimeVideoSource(WTFMove(deviceID), WTFMove(name), WTFMove(hashSalt)));
 63     if (constraints &amp;&amp; source-&gt;applyConstraints(*constraints))
 64         return { };
 65 
 66     return CaptureSourceOrError(RealtimeVideoSource::create(WTFMove(source)));
 67 }
 68 #endif
 69 
 70 MockRealtimeVideoSource::MockRealtimeVideoSource(String&amp;&amp; deviceID, String&amp;&amp; name, String&amp;&amp; hashSalt)
 71     : RealtimeVideoCaptureSource(WTFMove(name), WTFMove(deviceID), WTFMove(hashSalt))
 72     , m_emitFrameTimer(RunLoop::current(), this, &amp;MockRealtimeVideoSource::generateFrame)
 73 {
 74     auto device = MockRealtimeMediaSourceCenter::mockDeviceWithPersistentID(persistentID());
 75     ASSERT(device);
 76     m_device = *device;
 77 
 78     m_dashWidths.reserveInitialCapacity(2);
 79     m_dashWidths.uncheckedAppend(6);
</pre>
<hr />
<pre>
172     supportedConstraints.setSupportsWidth(true);
173     supportedConstraints.setSupportsHeight(true);
174     supportedConstraints.setSupportsAspectRatio(true);
175     if (mockCamera()) {
176         supportedConstraints.setSupportsDeviceId(true);
177         supportedConstraints.setSupportsFacingMode(true);
178     } else {
179         supportedConstraints.setSupportsDisplaySurface(true);
180         supportedConstraints.setSupportsLogicalSurface(true);
181     }
182     settings.setSupportedConstraints(supportedConstraints);
183 
184     m_currentSettings = WTFMove(settings);
185 
186     return m_currentSettings.value();
187 }
188 
189 void MockRealtimeVideoSource::setFrameRateWithPreset(double, RefPtr&lt;VideoPreset&gt; preset)
190 {
191     m_preset = WTFMove(preset);
<span class="line-modified">192     if (m_preset)</span>
<span class="line-modified">193         setIntrinsicSize(m_preset-&gt;size);</span>
194 }
195 
196 IntSize MockRealtimeVideoSource::captureSize() const
197 {
198     return m_preset ? m_preset-&gt;size : this-&gt;size();
199 }
200 
201 void MockRealtimeVideoSource::settingsDidChange(OptionSet&lt;RealtimeMediaSourceSettings::Flag&gt; settings)
202 {
203     m_currentSettings = WTF::nullopt;
204     if (settings.containsAny({ RealtimeMediaSourceSettings::Flag::Width, RealtimeMediaSourceSettings::Flag::Height })) {
205         m_baseFontSize = captureSize().height() * .08;
206         m_bipBopFontSize = m_baseFontSize * 2.5;
207         m_statsFontSize = m_baseFontSize * .5;
208         m_imageBuffer = nullptr;
209     }
210 }
211 
212 void MockRealtimeVideoSource::startCaptureTimer()
213 {
</pre>
<hr />
<pre>
245     m_path.clear();
246     m_path.moveTo(location);
247     m_path.addArc(location, radius, 0, 2 * piFloat, false);
248     m_path.closeSubpath();
249     context.setFillColor(Color::white);
250     context.setFillRule(WindRule::NonZero);
251     context.fillPath(m_path);
252 
253     float endAngle = piFloat * (((fmod(m_frameNumber, frameRate()) + 0.5) * (2.0 / frameRate())) + 1);
254     m_path.clear();
255     m_path.moveTo(location);
256     m_path.addArc(location, radius, 1.5 * piFloat, endAngle, false);
257     m_path.closeSubpath();
258     context.setFillColor(Color::gray);
259     context.setFillRule(WindRule::NonZero);
260     context.fillPath(m_path);
261 }
262 
263 void MockRealtimeVideoSource::drawBoxes(GraphicsContext&amp; context)
264 {
<span class="line-modified">265     constexpr SimpleColor magenta { 0xffff00ff };</span>
<span class="line-modified">266     constexpr SimpleColor blue { 0xff0000ff };</span>
<span class="line-modified">267     constexpr SimpleColor red { 0xffff0000 };</span>
<span class="line-modified">268     constexpr SimpleColor darkGreen { 0xff008000 };</span>


269 
270     IntSize size = captureSize();
271     float boxSize = size.width() * .035;
272     float boxTop = size.height() * .6;
273 
274     m_path.clear();
275     FloatRect frameRect(2, 2, size.width() - 3, size.height() - 3);
276     context.setStrokeColor(Color::white);
277     context.setStrokeThickness(3);
278     context.setLineDash(m_dashWidths, 0);
279     m_path.addRect(frameRect);
280     m_path.closeSubpath();
281     context.strokePath(m_path);
282 
283     context.setLineDash(DashArray(), 0);
284     m_path.clear();
285     m_path.moveTo(FloatPoint(0, boxTop + boxSize));
286     m_path.addLineTo(FloatPoint(size.width(), boxTop + boxSize));
287     m_path.closeSubpath();
288     context.setStrokeColor(Color::white);
</pre>
<hr />
<pre>
298     }
299     boxLeft += boxSize + 2;
300     for (unsigned i = 0; i &lt; boxSize / 4; i++) {
301         m_path.moveTo(FloatPoint(boxLeft, boxTop + 4 * i));
302         m_path.addLineTo(FloatPoint(boxLeft + boxSize - 1, boxTop + 4 * i));
303     }
304     context.setStrokeThickness(3);
305     boxLeft += boxSize + 2;
306     for (unsigned i = 0; i &lt; boxSize / 8; i++) {
307         m_path.moveTo(FloatPoint(boxLeft + 8 * i, boxTop));
308         m_path.addLineTo(FloatPoint(boxLeft + 8 * i, boxTop + boxSize - 1));
309     }
310     boxLeft += boxSize + 2;
311     for (unsigned i = 0; i &lt; boxSize / 8; i++) {
312         m_path.moveTo(FloatPoint(boxLeft, boxTop + 8 * i));
313         m_path.addLineTo(FloatPoint(boxLeft + boxSize - 1, boxTop + 8 * i));
314     }
315 
316     boxTop += boxSize + 2;
317     boxLeft = boxSize;
<span class="line-modified">318     constexpr SimpleColor boxColors[] = { Color::white, Color::yellow, Color::cyan, darkGreen, magenta, red, blue };</span>
<span class="line-modified">319     for (auto&amp; boxColor : boxColors) {</span>
<span class="line-modified">320         context.fillRect(FloatRect(boxLeft, boxTop, boxSize + 1, boxSize + 1), boxColor);</span>
321         boxLeft += boxSize + 1;
322     }
323     context.strokePath(m_path);
324 }
325 
326 void MockRealtimeVideoSource::drawText(GraphicsContext&amp; context)
327 {
328     unsigned milliseconds = lround(elapsedTime().milliseconds());
329     unsigned seconds = milliseconds / 1000 % 60;
330     unsigned minutes = seconds / 60 % 60;
331     unsigned hours = minutes / 60 % 60;
332 
333     FontCascadeDescription fontDescription;
334     fontDescription.setOneFamily(&quot;Courier&quot;);
335     fontDescription.setWeight(FontSelectionValue(500));
336 
337     fontDescription.setSpecifiedSize(m_baseFontSize);
338     fontDescription.setComputedSize(m_baseFontSize);
339     FontCascade timeFont { FontCascadeDescription { fontDescription }, 0, 0 };
340     timeFont.update(nullptr);
</pre>
<hr />
<pre>
439 
440     auto size = captureSize();
441     FloatRect frameRect(FloatPoint(), size);
442 
443     context.fillRect(FloatRect(FloatPoint(), size), m_fillColor);
444 
445     if (!muted()) {
446         drawText(context);
447         drawAnimation(context);
448         drawBoxes(context);
449     }
450 
451     updateSampleBuffer();
452 }
453 
454 ImageBuffer* MockRealtimeVideoSource::imageBuffer() const
455 {
456     if (m_imageBuffer)
457         return m_imageBuffer.get();
458 
<span class="line-modified">459     m_imageBuffer = ImageBuffer::create(captureSize(), RenderingMode::Unaccelerated);</span>
460     if (!m_imageBuffer)
461         return nullptr;
462 
<span class="line-modified">463     m_imageBuffer-&gt;context().setImageInterpolationQuality(InterpolationQuality::Default);</span>
464     m_imageBuffer-&gt;context().setStrokeThickness(1);
465 
466     return m_imageBuffer.get();
467 }
468 
469 bool MockRealtimeVideoSource::mockDisplayType(CaptureDevice::DeviceType type) const
470 {
471     if (!WTF::holds_alternative&lt;MockDisplayProperties&gt;(m_device.properties))
472         return false;
473 
474     return WTF::get&lt;MockDisplayProperties&gt;(m_device.properties).type == type;
475 }
476 
477 void MockRealtimeVideoSource::orientationChanged(int orientation)
478 {
479     auto deviceOrientation = m_deviceOrientation;
480     switch (orientation) {
481     case 0:
482         m_deviceOrientation = MediaSample::VideoRotation::None;
483         break;
</pre>
</td>
</tr>
</table>
<center><a href="MockRealtimeMediaSourceCenter.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="MockRealtimeVideoSource.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmMemory.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmInstance.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmMemory.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmMemory.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
103     }
104 
105     MemoryResult tryAllocateFastMemory()
106     {
107         MemoryResult result = [&amp;] {
108             auto holder = holdLock(m_lock);
109             if (m_fastMemories.size() &gt;= m_maxFastMemoryCount)
110                 return MemoryResult(nullptr, MemoryResult::SyncTryToReclaimMemory);
111 
112             void* result = Gigacage::tryAllocateZeroedVirtualPages(Gigacage::Primitive, Memory::fastMappedBytes());
113             if (!result)
114                 return MemoryResult(nullptr, MemoryResult::SyncTryToReclaimMemory);
115 
116             m_fastMemories.append(result);
117 
118             return MemoryResult(
119                 result,
120                 m_fastMemories.size() &gt;= m_maxFastMemoryCount / 2 ? MemoryResult::SuccessAndNotifyMemoryPressure : MemoryResult::Success);
121         }();
122 
<span class="line-modified">123         if (Options::logWebAssemblyMemory())</span>
<span class="line-removed">124             dataLog(&quot;Allocated virtual: &quot;, result, &quot;; state: &quot;, *this, &quot;\n&quot;);</span>
125 
126         return result;
127     }
128 
129     void freeFastMemory(void* basePtr)
130     {
131         {
132             auto holder = holdLock(m_lock);
133             Gigacage::freeVirtualPages(Gigacage::Primitive, basePtr, Memory::fastMappedBytes());
134             m_fastMemories.removeFirst(basePtr);
135         }
136 
<span class="line-modified">137         if (Options::logWebAssemblyMemory())</span>
<span class="line-removed">138             dataLog(&quot;Freed virtual; state: &quot;, *this, &quot;\n&quot;);</span>
139     }
140 
141     bool isAddressInFastMemory(void* address)
142     {
143         // NOTE: This can be called from a signal handler, but only after we proved that we&#39;re in JIT code.
144         auto holder = holdLock(m_lock);
145         for (void* memory : m_fastMemories) {
146             char* start = static_cast&lt;char*&gt;(memory);
147             if (start &lt;= address &amp;&amp; address &lt;= start + Memory::fastMappedBytes())
148                 return true;
149         }
150         return false;
151     }
152 
153     // We allow people to &quot;commit&quot; more wasm memory than there is on the system since most of the time
154     // people don&#39;t actually write to most of that memory. There is some chance that this gets us
155     // JetSammed but that&#39;s possible anyway.
156     inline size_t memoryLimit() const { return ramSize() * 3; }
157 
158     // FIXME: Ideally, bmalloc would have this kind of mechanism. Then, we would just forward to that
159     // mechanism here.
160     MemoryResult::Kind tryAllocatePhysicalBytes(size_t bytes)
161     {
162         MemoryResult::Kind result = [&amp;] {
163             auto holder = holdLock(m_lock);
164             if (m_physicalBytes + bytes &gt; memoryLimit())
165                 return MemoryResult::SyncTryToReclaimMemory;
166 
167             m_physicalBytes += bytes;
168 
169             if (m_physicalBytes &gt;= memoryLimit() / 2)
170                 return MemoryResult::SuccessAndNotifyMemoryPressure;
171 
172             return MemoryResult::Success;
173         }();
174 
<span class="line-modified">175         if (Options::logWebAssemblyMemory())</span>
<span class="line-removed">176             dataLog(&quot;Allocated physical: &quot;, bytes, &quot;, &quot;, MemoryResult::toString(result), &quot;; state: &quot;, *this, &quot;\n&quot;);</span>
177 
178         return result;
179     }
180 
181     void freePhysicalBytes(size_t bytes)
182     {
183         {
184             auto holder = holdLock(m_lock);
185             m_physicalBytes -= bytes;
186         }
187 
<span class="line-modified">188         if (Options::logWebAssemblyMemory())</span>
<span class="line-removed">189             dataLog(&quot;Freed physical: &quot;, bytes, &quot;; state: &quot;, *this, &quot;\n&quot;);</span>
190     }
191 
192     void dump(PrintStream&amp; out) const
193     {
194         out.print(&quot;fast memories =  &quot;, m_fastMemories.size(), &quot;/&quot;, m_maxFastMemoryCount, &quot;, bytes = &quot;, m_physicalBytes, &quot;/&quot;, memoryLimit());
195     }
196 
197 private:
198     Lock m_lock;
199     unsigned m_maxFastMemoryCount { 0 };
200     Vector&lt;void*&gt; m_fastMemories;
201     size_t m_physicalBytes { 0 };
202 };
203 
204 static MemoryManager&amp; memoryManager()
205 {
206     static std::once_flag onceFlag;
207     static MemoryManager* manager;
208     std::call_once(
209         onceFlag,
</pre>
</td>
<td>
<hr />
<pre>
103     }
104 
105     MemoryResult tryAllocateFastMemory()
106     {
107         MemoryResult result = [&amp;] {
108             auto holder = holdLock(m_lock);
109             if (m_fastMemories.size() &gt;= m_maxFastMemoryCount)
110                 return MemoryResult(nullptr, MemoryResult::SyncTryToReclaimMemory);
111 
112             void* result = Gigacage::tryAllocateZeroedVirtualPages(Gigacage::Primitive, Memory::fastMappedBytes());
113             if (!result)
114                 return MemoryResult(nullptr, MemoryResult::SyncTryToReclaimMemory);
115 
116             m_fastMemories.append(result);
117 
118             return MemoryResult(
119                 result,
120                 m_fastMemories.size() &gt;= m_maxFastMemoryCount / 2 ? MemoryResult::SuccessAndNotifyMemoryPressure : MemoryResult::Success);
121         }();
122 
<span class="line-modified">123         dataLogLnIf(Options::logWebAssemblyMemory(), &quot;Allocated virtual: &quot;, result, &quot;; state: &quot;, *this);</span>

124 
125         return result;
126     }
127 
128     void freeFastMemory(void* basePtr)
129     {
130         {
131             auto holder = holdLock(m_lock);
132             Gigacage::freeVirtualPages(Gigacage::Primitive, basePtr, Memory::fastMappedBytes());
133             m_fastMemories.removeFirst(basePtr);
134         }
135 
<span class="line-modified">136         dataLogLnIf(Options::logWebAssemblyMemory(), &quot;Freed virtual; state: &quot;, *this);</span>

137     }
138 
139     bool isAddressInFastMemory(void* address)
140     {
141         // NOTE: This can be called from a signal handler, but only after we proved that we&#39;re in JIT code.
142         auto holder = holdLock(m_lock);
143         for (void* memory : m_fastMemories) {
144             char* start = static_cast&lt;char*&gt;(memory);
145             if (start &lt;= address &amp;&amp; address &lt;= start + Memory::fastMappedBytes())
146                 return true;
147         }
148         return false;
149     }
150 
151     // We allow people to &quot;commit&quot; more wasm memory than there is on the system since most of the time
152     // people don&#39;t actually write to most of that memory. There is some chance that this gets us
153     // JetSammed but that&#39;s possible anyway.
154     inline size_t memoryLimit() const { return ramSize() * 3; }
155 
156     // FIXME: Ideally, bmalloc would have this kind of mechanism. Then, we would just forward to that
157     // mechanism here.
158     MemoryResult::Kind tryAllocatePhysicalBytes(size_t bytes)
159     {
160         MemoryResult::Kind result = [&amp;] {
161             auto holder = holdLock(m_lock);
162             if (m_physicalBytes + bytes &gt; memoryLimit())
163                 return MemoryResult::SyncTryToReclaimMemory;
164 
165             m_physicalBytes += bytes;
166 
167             if (m_physicalBytes &gt;= memoryLimit() / 2)
168                 return MemoryResult::SuccessAndNotifyMemoryPressure;
169 
170             return MemoryResult::Success;
171         }();
172 
<span class="line-modified">173         dataLogLnIf(Options::logWebAssemblyMemory(), &quot;Allocated physical: &quot;, bytes, &quot;, &quot;, MemoryResult::toString(result), &quot;; state: &quot;, *this);</span>

174 
175         return result;
176     }
177 
178     void freePhysicalBytes(size_t bytes)
179     {
180         {
181             auto holder = holdLock(m_lock);
182             m_physicalBytes -= bytes;
183         }
184 
<span class="line-modified">185         dataLogLnIf(Options::logWebAssemblyMemory(), &quot;Freed physical: &quot;, bytes, &quot;; state: &quot;, *this);</span>

186     }
187 
188     void dump(PrintStream&amp; out) const
189     {
190         out.print(&quot;fast memories =  &quot;, m_fastMemories.size(), &quot;/&quot;, m_maxFastMemoryCount, &quot;, bytes = &quot;, m_physicalBytes, &quot;/&quot;, memoryLimit());
191     }
192 
193 private:
194     Lock m_lock;
195     unsigned m_maxFastMemoryCount { 0 };
196     Vector&lt;void*&gt; m_fastMemories;
197     size_t m_physicalBytes { 0 };
198 };
199 
200 static MemoryManager&amp; memoryManager()
201 {
202     static std::once_flag onceFlag;
203     static MemoryManager* manager;
204     std::call_once(
205         onceFlag,
</pre>
</td>
</tr>
</table>
<center><a href="WasmInstance.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmMemory.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
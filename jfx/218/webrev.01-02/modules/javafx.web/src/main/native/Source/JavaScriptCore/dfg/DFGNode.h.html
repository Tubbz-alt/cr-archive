<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGNode.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2011-2018 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(DFG_JIT)
  29 
  30 #include &quot;B3SparseCollection.h&quot;
  31 #include &quot;BasicBlockLocation.h&quot;
  32 #include &quot;CodeBlock.h&quot;
  33 #include &quot;DFGAdjacencyList.h&quot;
  34 #include &quot;DFGArithMode.h&quot;
  35 #include &quot;DFGArrayMode.h&quot;
  36 #include &quot;DFGCommon.h&quot;
  37 #include &quot;DFGEpoch.h&quot;
  38 #include &quot;DFGLazyJSValue.h&quot;
  39 #include &quot;DFGMultiGetByOffsetData.h&quot;
  40 #include &quot;DFGNodeFlags.h&quot;
  41 #include &quot;DFGNodeOrigin.h&quot;
  42 #include &quot;DFGNodeType.h&quot;
  43 #include &quot;DFGObjectMaterializationData.h&quot;
  44 #include &quot;DFGOpInfo.h&quot;
  45 #include &quot;DFGRegisteredStructure.h&quot;
  46 #include &quot;DFGRegisteredStructureSet.h&quot;
  47 #include &quot;DFGTransition.h&quot;
  48 #include &quot;DFGUseKind.h&quot;
  49 #include &quot;DFGVariableAccessData.h&quot;
  50 #include &quot;GetByIdVariant.h&quot;
  51 #include &quot;JSCJSValue.h&quot;
  52 #include &quot;Operands.h&quot;
  53 #include &quot;PutByIdVariant.h&quot;
  54 #include &quot;SpeculatedType.h&quot;
  55 #include &quot;TypeLocation.h&quot;
  56 #include &quot;ValueProfile.h&quot;
  57 #include &lt;type_traits&gt;
  58 #include &lt;wtf/FastMalloc.h&gt;
  59 #include &lt;wtf/ListDump.h&gt;
  60 #include &lt;wtf/LoggingHashSet.h&gt;
  61 
  62 namespace JSC {
  63 
  64 namespace DOMJIT {
  65 class GetterSetter;
  66 class CallDOMGetterSnippet;
  67 class Signature;
  68 }
  69 
  70 namespace Profiler {
  71 class ExecutionCounter;
  72 }
  73 
  74 class Snippet;
  75 
  76 namespace DFG {
  77 
  78 class Graph;
  79 class PromotedLocationDescriptor;
  80 struct BasicBlock;
  81 
  82 struct StorageAccessData {
  83     PropertyOffset offset;
  84     unsigned identifierNumber;
  85 };
  86 
  87 struct MultiPutByOffsetData {
  88     unsigned identifierNumber;
  89     Vector&lt;PutByIdVariant, 2&gt; variants;
  90 
  91     bool writesStructures() const;
  92     bool reallocatesStorage() const;
  93 };
  94 
  95 struct MatchStructureVariant {
  96     RegisteredStructure structure;
  97     bool result;
  98 };
  99 
 100 struct MatchStructureData {
 101     Vector&lt;MatchStructureVariant, 2&gt; variants;
 102 };
 103 
 104 struct NewArrayBufferData {
 105     union {
 106         struct {
 107             unsigned vectorLengthHint;
 108             unsigned indexingMode;
 109         };
 110         uint64_t asQuadWord;
 111     };
 112 };
 113 static_assert(sizeof(IndexingType) &lt;= sizeof(unsigned), &quot;&quot;);
 114 static_assert(sizeof(NewArrayBufferData) == sizeof(uint64_t), &quot;&quot;);
 115 
 116 struct DataViewData {
 117     union {
 118         struct {
 119             uint8_t byteSize;
 120             bool isSigned;
 121             bool isFloatingPoint; // Used for the DataViewSet node.
 122             TriState isLittleEndian;
 123         };
 124         uint64_t asQuadWord;
 125     };
 126 };
 127 static_assert(sizeof(DataViewData) == sizeof(uint64_t), &quot;&quot;);
 128 
 129 struct BranchTarget {
 130     BranchTarget()
 131         : block(0)
 132         , count(PNaN)
 133     {
 134     }
 135 
 136     explicit BranchTarget(BasicBlock* block)
 137         : block(block)
 138         , count(PNaN)
 139     {
 140     }
 141 
 142     void setBytecodeIndex(unsigned bytecodeIndex)
 143     {
 144         block = bitwise_cast&lt;BasicBlock*&gt;(static_cast&lt;uintptr_t&gt;(bytecodeIndex));
 145     }
 146     unsigned bytecodeIndex() const { return bitwise_cast&lt;uintptr_t&gt;(block); }
 147 
 148     void dump(PrintStream&amp;) const;
 149 
 150     BasicBlock* block;
 151     float count;
 152 };
 153 
 154 struct BranchData {
 155     static BranchData withBytecodeIndices(
 156         unsigned takenBytecodeIndex, unsigned notTakenBytecodeIndex)
 157     {
 158         BranchData result;
 159         result.taken.block = bitwise_cast&lt;BasicBlock*&gt;(static_cast&lt;uintptr_t&gt;(takenBytecodeIndex));
 160         result.notTaken.block = bitwise_cast&lt;BasicBlock*&gt;(static_cast&lt;uintptr_t&gt;(notTakenBytecodeIndex));
 161         return result;
 162     }
 163 
 164     unsigned takenBytecodeIndex() const { return taken.bytecodeIndex(); }
 165     unsigned notTakenBytecodeIndex() const { return notTaken.bytecodeIndex(); }
 166 
 167     BasicBlock*&amp; forCondition(bool condition)
 168     {
 169         if (condition)
 170             return taken.block;
 171         return notTaken.block;
 172     }
 173 
 174     BranchTarget taken;
 175     BranchTarget notTaken;
 176 };
 177 
 178 // The SwitchData and associated data structures duplicate the information in
 179 // JumpTable. The DFG may ultimately end up using the JumpTable, though it may
 180 // instead decide to do something different - this is entirely up to the DFG.
 181 // These data structures give the DFG a higher-level semantic description of
 182 // what is going on, which will allow it to make the right decision.
 183 //
 184 // Note that there will never be multiple SwitchCases in SwitchData::cases that
 185 // have the same SwitchCase::value, since the bytecode&#39;s JumpTables never have
 186 // duplicates - since the JumpTable maps a value to a target. It&#39;s a
 187 // one-to-many mapping. So we may have duplicate targets, but never duplicate
 188 // values.
 189 struct SwitchCase {
 190     SwitchCase()
 191     {
 192     }
 193 
 194     SwitchCase(LazyJSValue value, BasicBlock* target)
 195         : value(value)
 196         , target(target)
 197     {
 198     }
 199 
 200     static SwitchCase withBytecodeIndex(LazyJSValue value, unsigned bytecodeIndex)
 201     {
 202         SwitchCase result;
 203         result.value = value;
 204         result.target.setBytecodeIndex(bytecodeIndex);
 205         return result;
 206     }
 207 
 208     LazyJSValue value;
 209     BranchTarget target;
 210 };
 211 
 212 struct SwitchData {
 213     // Initializes most fields to obviously invalid values. Anyone
 214     // constructing this should make sure to initialize everything they
 215     // care about manually.
 216     SwitchData()
 217         : switchTableIndex(UINT_MAX)
 218         , kind(static_cast&lt;SwitchKind&gt;(-1))
 219         , didUseJumpTable(false)
 220     {
 221     }
 222 
 223     Vector&lt;SwitchCase&gt; cases;
 224     BranchTarget fallThrough;
 225     size_t switchTableIndex;
 226     SwitchKind kind;
 227     bool didUseJumpTable;
 228 };
 229 
 230 struct EntrySwitchData {
 231     Vector&lt;BasicBlock*&gt; cases;
 232 };
 233 
 234 struct CallVarargsData {
 235     int firstVarArgOffset;
 236 };
 237 
 238 struct LoadVarargsData {
 239     VirtualRegister start; // Local for the first element. This is the first actual argument, not this.
 240     VirtualRegister count; // Local for the count.
 241     VirtualRegister machineStart;
 242     VirtualRegister machineCount;
 243     unsigned offset; // Which array element to start with. Usually this is 0.
 244     unsigned mandatoryMinimum; // The number of elements on the stack that must be initialized; if the array is too short then the missing elements must get undefined. Does not include &quot;this&quot;.
 245     unsigned limit; // Maximum number of elements to load. Includes &quot;this&quot;.
 246 };
 247 
 248 struct StackAccessData {
 249     StackAccessData()
 250         : format(DeadFlush)
 251     {
 252     }
 253 
 254     StackAccessData(Operand operand, FlushFormat format)
 255         : operand(operand)
 256         , format(format)
 257     {
 258     }
 259 
 260     Operand operand;
 261     VirtualRegister machineLocal;
 262     FlushFormat format;
 263 
 264     FlushedAt flushedAt() { return FlushedAt(format, machineLocal); }
 265 };
 266 
 267 struct CallDOMGetterData {
 268     FunctionPtr&lt;OperationPtrTag&gt; customAccessorGetter;
 269     const DOMJIT::GetterSetter* domJIT { nullptr };
 270     DOMJIT::CallDOMGetterSnippet* snippet { nullptr };
 271     unsigned identifierNumber { 0 };
 272 };
 273 
 274 enum class BucketOwnerType : uint32_t {
 275     Map,
 276     Set
 277 };
 278 
 279 // === Node ===
 280 //
 281 // Node represents a single operation in the data flow graph.
 282 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(DFGNode);
 283 struct Node {
 284     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(DFGNode);
 285 public:
 286     static const char HashSetTemplateInstantiationString[];
 287 
 288     enum VarArgTag { VarArg };
 289 
 290     Node() { }
 291 
 292     Node(NodeType op, NodeOrigin nodeOrigin, const AdjacencyList&amp; children)
 293         : origin(nodeOrigin)
 294         , children(children)
 295         , m_virtualRegister(VirtualRegister())
 296         , m_refCount(1)
 297         , m_prediction(SpecNone)
 298         , owner(nullptr)
 299     {
 300         m_misc.replacement = nullptr;
 301         setOpAndDefaultFlags(op);
 302     }
 303 
 304     // Construct a node with up to 3 children, no immediate value.
 305     Node(NodeType op, NodeOrigin nodeOrigin, Edge child1 = Edge(), Edge child2 = Edge(), Edge child3 = Edge())
 306         : origin(nodeOrigin)
 307         , children(AdjacencyList::Fixed, child1, child2, child3)
 308         , m_virtualRegister(VirtualRegister())
 309         , m_refCount(1)
 310         , m_prediction(SpecNone)
 311         , owner(nullptr)
 312     {
 313         m_misc.replacement = nullptr;
 314         setOpAndDefaultFlags(op);
 315         ASSERT(!(m_flags &amp; NodeHasVarArgs));
 316     }
 317 
 318     // Construct a node with up to 3 children, no immediate value.
 319     Node(NodeFlags result, NodeType op, NodeOrigin nodeOrigin, Edge child1 = Edge(), Edge child2 = Edge(), Edge child3 = Edge())
 320         : origin(nodeOrigin)
 321         , children(AdjacencyList::Fixed, child1, child2, child3)
 322         , m_virtualRegister(VirtualRegister())
 323         , m_refCount(1)
 324         , m_prediction(SpecNone)
 325         , owner(nullptr)
 326     {
 327         m_misc.replacement = nullptr;
 328         setOpAndDefaultFlags(op);
 329         setResult(result);
 330         ASSERT(!(m_flags &amp; NodeHasVarArgs));
 331     }
 332 
 333     // Construct a node with up to 3 children and an immediate value.
 334     Node(NodeType op, NodeOrigin nodeOrigin, OpInfo imm, Edge child1 = Edge(), Edge child2 = Edge(), Edge child3 = Edge())
 335         : origin(nodeOrigin)
 336         , children(AdjacencyList::Fixed, child1, child2, child3)
 337         , m_virtualRegister(VirtualRegister())
 338         , m_refCount(1)
 339         , m_prediction(SpecNone)
 340         , m_opInfo(imm.m_value)
 341         , owner(nullptr)
 342     {
 343         m_misc.replacement = nullptr;
 344         setOpAndDefaultFlags(op);
 345         ASSERT(!(m_flags &amp; NodeHasVarArgs));
 346     }
 347 
 348     // Construct a node with up to 3 children and an immediate value.
 349     Node(NodeFlags result, NodeType op, NodeOrigin nodeOrigin, OpInfo imm, Edge child1 = Edge(), Edge child2 = Edge(), Edge child3 = Edge())
 350         : origin(nodeOrigin)
 351         , children(AdjacencyList::Fixed, child1, child2, child3)
 352         , m_virtualRegister(VirtualRegister())
 353         , m_refCount(1)
 354         , m_prediction(SpecNone)
 355         , m_opInfo(imm.m_value)
 356         , owner(nullptr)
 357     {
 358         m_misc.replacement = nullptr;
 359         setOpAndDefaultFlags(op);
 360         setResult(result);
 361         ASSERT(!(m_flags &amp; NodeHasVarArgs));
 362     }
 363 
 364     // Construct a node with up to 3 children and two immediate values.
 365     Node(NodeType op, NodeOrigin nodeOrigin, OpInfo imm1, OpInfo imm2, Edge child1 = Edge(), Edge child2 = Edge(), Edge child3 = Edge())
 366         : origin(nodeOrigin)
 367         , children(AdjacencyList::Fixed, child1, child2, child3)
 368         , m_virtualRegister(VirtualRegister())
 369         , m_refCount(1)
 370         , m_prediction(SpecNone)
 371         , m_opInfo(imm1.m_value)
 372         , m_opInfo2(imm2.m_value)
 373         , owner(nullptr)
 374     {
 375         m_misc.replacement = nullptr;
 376         setOpAndDefaultFlags(op);
 377         ASSERT(!(m_flags &amp; NodeHasVarArgs));
 378     }
 379 
 380     // Construct a node with a variable number of children and two immediate values.
 381     Node(VarArgTag, NodeType op, NodeOrigin nodeOrigin, OpInfo imm1, OpInfo imm2, unsigned firstChild, unsigned numChildren)
 382         : origin(nodeOrigin)
 383         , children(AdjacencyList::Variable, firstChild, numChildren)
 384         , m_virtualRegister(VirtualRegister())
 385         , m_refCount(1)
 386         , m_prediction(SpecNone)
 387         , m_opInfo(imm1.m_value)
 388         , m_opInfo2(imm2.m_value)
 389         , owner(nullptr)
 390     {
 391         m_misc.replacement = nullptr;
 392         setOpAndDefaultFlags(op);
 393         ASSERT(m_flags &amp; NodeHasVarArgs);
 394     }
 395 
 396     NodeType op() const { return static_cast&lt;NodeType&gt;(m_op); }
 397     NodeFlags flags() const { return m_flags; }
 398 
 399     unsigned index() const { return m_index; }
 400 
 401     void setOp(NodeType op)
 402     {
 403         m_op = op;
 404     }
 405 
 406     void setFlags(NodeFlags flags)
 407     {
 408         m_flags = flags;
 409     }
 410 
 411     bool mergeFlags(NodeFlags flags)
 412     {
 413         NodeFlags newFlags = m_flags | flags;
 414         if (newFlags == m_flags)
 415             return false;
 416         m_flags = newFlags;
 417         return true;
 418     }
 419 
 420     bool filterFlags(NodeFlags flags)
 421     {
 422         NodeFlags newFlags = m_flags &amp; flags;
 423         if (newFlags == m_flags)
 424             return false;
 425         m_flags = newFlags;
 426         return true;
 427     }
 428 
 429     bool clearFlags(NodeFlags flags)
 430     {
 431         return filterFlags(~flags);
 432     }
 433 
 434     void setResult(NodeFlags result)
 435     {
 436         ASSERT(!(result &amp; ~NodeResultMask));
 437         clearFlags(NodeResultMask);
 438         mergeFlags(result);
 439     }
 440 
 441     NodeFlags result() const
 442     {
 443         return flags() &amp; NodeResultMask;
 444     }
 445 
 446     void setOpAndDefaultFlags(NodeType op)
 447     {
 448         m_op = op;
 449         m_flags = defaultFlags(op);
 450     }
 451 
 452     void remove(Graph&amp;);
 453     void removeWithoutChecks();
 454 
 455     void convertToCheckStructure(RegisteredStructureSet* set)
 456     {
 457         setOpAndDefaultFlags(CheckStructure);
 458         m_opInfo = set;
 459     }
 460 
 461     void convertToCheckStructureOrEmpty(RegisteredStructureSet* set)
 462     {
 463         if (SpecCellCheck &amp; SpecEmpty)
 464             setOpAndDefaultFlags(CheckStructureOrEmpty);
 465         else
 466             setOpAndDefaultFlags(CheckStructure);
 467         m_opInfo = set;
 468     }
 469 
 470     void convertCheckStructureOrEmptyToCheckStructure()
 471     {
 472         ASSERT(op() == CheckStructureOrEmpty);
 473         setOpAndDefaultFlags(CheckStructure);
 474     }
 475 
 476     void convertToCheckStructureImmediate(Node* structure)
 477     {
 478         ASSERT(op() == CheckStructure || op() == CheckStructureOrEmpty);
 479         m_op = CheckStructureImmediate;
 480         children.setChild1(Edge(structure, CellUse));
 481     }
 482 
 483     void convertCheckArrayOrEmptyToCheckArray()
 484     {
 485         ASSERT(op() == CheckArrayOrEmpty);
 486         setOpAndDefaultFlags(CheckArray);
 487     }
 488 
 489     void replaceWith(Graph&amp;, Node* other);
 490     void replaceWithWithoutChecks(Node* other);
 491 
 492     void convertToIdentity();
 493     void convertToIdentityOn(Node*);
 494 
 495     bool mustGenerate()
 496     {
 497         return m_flags &amp; NodeMustGenerate;
 498     }
 499 
 500     bool isConstant()
 501     {
 502         switch (op()) {
 503         case JSConstant:
 504         case DoubleConstant:
 505         case Int52Constant:
 506             return true;
 507         default:
 508             return false;
 509         }
 510     }
 511 
 512     bool hasConstant()
 513     {
 514         switch (op()) {
 515         case JSConstant:
 516         case DoubleConstant:
 517         case Int52Constant:
 518             return true;
 519 
 520         case PhantomDirectArguments:
 521         case PhantomClonedArguments:
 522             // These pretend to be the empty value constant for the benefit of the DFG backend, which
 523             // otherwise wouldn&#39;t take kindly to a node that doesn&#39;t compute a value.
 524             return true;
 525 
 526         default:
 527             return false;
 528         }
 529     }
 530 
 531     FrozenValue* constant()
 532     {
 533         ASSERT(hasConstant());
 534 
 535         if (op() == PhantomDirectArguments || op() == PhantomClonedArguments) {
 536             // These pretend to be the empty value constant for the benefit of the DFG backend, which
 537             // otherwise wouldn&#39;t take kindly to a node that doesn&#39;t compute a value.
 538             return FrozenValue::emptySingleton();
 539         }
 540 
 541         return m_opInfo.as&lt;FrozenValue*&gt;();
 542     }
 543 
 544     // Don&#39;t call this directly - use Graph::convertToConstant() instead!
 545     void convertToConstant(FrozenValue* value)
 546     {
 547         if (hasDoubleResult())
 548             m_op = DoubleConstant;
 549         else if (hasInt52Result())
 550             m_op = Int52Constant;
 551         else
 552             m_op = JSConstant;
 553         m_flags &amp;= ~(NodeMustGenerate | NodeHasVarArgs);
 554         m_opInfo = value;
 555         children.reset();
 556     }
 557 
 558     void convertToLazyJSConstant(Graph&amp;, LazyJSValue);
 559 
 560     void convertToConstantStoragePointer(void* pointer)
 561     {
 562         ASSERT(op() == GetIndexedPropertyStorage);
 563         m_op = ConstantStoragePointer;
 564         m_opInfo = pointer;
 565         children.reset();
 566     }
 567 
 568     void convertToPutStack(StackAccessData* data)
 569     {
 570         m_op = PutStack;
 571         m_flags |= NodeMustGenerate;
 572         m_opInfo = data;
 573         m_opInfo2 = OpInfoWrapper();
 574     }
 575 
 576     void convertToGetStack(StackAccessData* data)
 577     {
 578         m_op = GetStack;
 579         m_flags &amp;= ~NodeMustGenerate;
 580         m_opInfo = data;
 581         m_opInfo2 = OpInfoWrapper();
 582         children.reset();
 583     }
 584 
 585     void convertToGetByOffset(StorageAccessData&amp; data, Edge storage, Edge base)
 586     {
 587         ASSERT(m_op == GetById || m_op == GetByIdFlush || m_op == GetByIdDirect || m_op == GetByIdDirectFlush || m_op == MultiGetByOffset);
 588         m_opInfo = &amp;data;
 589         children.setChild1(storage);
 590         children.setChild2(base);
 591         m_op = GetByOffset;
 592         m_flags &amp;= ~NodeMustGenerate;
 593     }
 594 
 595     void convertToMultiGetByOffset(MultiGetByOffsetData* data)
 596     {
 597         RELEASE_ASSERT(m_op == GetById || m_op == GetByIdFlush || m_op == GetByIdDirect || m_op == GetByIdDirectFlush);
 598         m_opInfo = data;
 599         child1().setUseKind(CellUse);
 600         m_op = MultiGetByOffset;
 601         RELEASE_ASSERT(m_flags &amp; NodeMustGenerate);
 602     }
 603 
 604     void convertToPutByOffset(StorageAccessData&amp; data, Edge storage, Edge base)
 605     {
 606         ASSERT(m_op == PutById || m_op == PutByIdDirect || m_op == PutByIdFlush || m_op == MultiPutByOffset);
 607         m_opInfo = &amp;data;
 608         children.setChild3(children.child2());
 609         children.setChild2(base);
 610         children.setChild1(storage);
 611         m_op = PutByOffset;
 612     }
 613 
 614     void convertToMultiPutByOffset(MultiPutByOffsetData* data)
 615     {
 616         ASSERT(m_op == PutById || m_op == PutByIdDirect || m_op == PutByIdFlush);
 617         m_opInfo = data;
 618         m_op = MultiPutByOffset;
 619     }
 620 
 621     void convertToPhantomNewObject()
 622     {
 623         ASSERT(m_op == NewObject);
 624         m_op = PhantomNewObject;
 625         m_flags &amp;= ~NodeHasVarArgs;
 626         m_flags |= NodeMustGenerate;
 627         m_opInfo = OpInfoWrapper();
 628         m_opInfo2 = OpInfoWrapper();
 629         children = AdjacencyList();
 630     }
 631 
 632     void convertToPhantomNewFunction()
 633     {
 634         ASSERT(m_op == NewFunction || m_op == NewGeneratorFunction || m_op == NewAsyncFunction || m_op == NewAsyncGeneratorFunction);
 635         m_op = PhantomNewFunction;
 636         m_flags |= NodeMustGenerate;
 637         m_opInfo = OpInfoWrapper();
 638         m_opInfo2 = OpInfoWrapper();
 639         children = AdjacencyList();
 640     }
 641 
 642     void convertToPhantomNewGeneratorFunction()
 643     {
 644         ASSERT(m_op == NewGeneratorFunction);
 645         m_op = PhantomNewGeneratorFunction;
 646         m_flags |= NodeMustGenerate;
 647         m_opInfo = OpInfoWrapper();
 648         m_opInfo2 = OpInfoWrapper();
 649         children = AdjacencyList();
 650     }
 651 
 652     void convertToPhantomNewArrayIterator()
 653     {
 654         ASSERT(m_op == NewArrayIterator);
 655         m_op = PhantomNewArrayIterator;
 656         m_flags &amp;= ~NodeHasVarArgs;
 657         m_flags |= NodeMustGenerate;
 658         m_opInfo = OpInfoWrapper();
 659         m_opInfo2 = OpInfoWrapper();
 660         children = AdjacencyList();
 661     }
 662 
 663     void convertToPhantomNewAsyncFunction()
 664     {
 665         ASSERT(m_op == NewAsyncFunction);
 666         m_op = PhantomNewAsyncFunction;
 667         m_flags |= NodeMustGenerate;
 668         m_opInfo = OpInfoWrapper();
 669         m_opInfo2 = OpInfoWrapper();
 670         children = AdjacencyList();
 671     }
 672 
 673     void convertToPhantomNewAsyncGeneratorFunction()
 674     {
 675         ASSERT(m_op == NewAsyncGeneratorFunction);
 676         m_op = PhantomNewAsyncGeneratorFunction;
 677         m_flags |= NodeMustGenerate;
 678         m_opInfo = OpInfoWrapper();
 679         m_opInfo2 = OpInfoWrapper();
 680         children = AdjacencyList();
 681     }
 682 
 683     void convertToPhantomCreateActivation()
 684     {
 685         ASSERT(m_op == CreateActivation);
 686         m_op = PhantomCreateActivation;
 687         m_flags &amp;= ~NodeHasVarArgs;
 688         m_flags |= NodeMustGenerate;
 689         m_opInfo = OpInfoWrapper();
 690         m_opInfo2 = OpInfoWrapper();
 691         children = AdjacencyList();
 692     }
 693 
 694     void convertToPhantomNewRegexp()
 695     {
 696         ASSERT(m_op == NewRegexp);
 697         setOpAndDefaultFlags(PhantomNewRegexp);
 698         m_opInfo = OpInfoWrapper();
 699         m_opInfo2 = OpInfoWrapper();
 700         children = AdjacencyList();
 701     }
 702 
 703     void convertPhantomToPhantomLocal()
 704     {
 705         ASSERT(m_op == Phantom &amp;&amp; (child1()-&gt;op() == Phi || child1()-&gt;op() == SetLocal || child1()-&gt;op() == SetArgumentDefinitely));
 706         m_op = PhantomLocal;
 707         m_opInfo = child1()-&gt;m_opInfo; // Copy the variableAccessData.
 708         children.setChild1(Edge());
 709     }
 710 
 711     void convertFlushToPhantomLocal()
 712     {
 713         ASSERT(m_op == Flush);
 714         m_op = PhantomLocal;
 715         children = AdjacencyList();
 716     }
 717 
 718     void convertToToString()
 719     {
 720         ASSERT(m_op == ToPrimitive || m_op == StringValueOf || m_op == ToPropertyKey);
 721         m_op = ToString;
 722     }
 723 
 724     void convertToArithNegate()
 725     {
 726         ASSERT(m_op == ArithAbs &amp;&amp; child1().useKind() == Int32Use);
 727         m_op = ArithNegate;
 728     }
 729 
 730     void convertToCompareEqPtr(FrozenValue* cell, Edge node)
 731     {
 732         ASSERT(m_op == CompareStrictEq || m_op == SameValue);
 733         setOpAndDefaultFlags(CompareEqPtr);
 734         children.setChild1(node);
 735         children.setChild2(Edge());
 736         m_opInfo = cell;
 737     }
 738 
 739     void convertToNumberToStringWithValidRadixConstant(int32_t radix)
 740     {
 741         ASSERT(m_op == NumberToStringWithRadix);
 742         ASSERT(2 &lt;= radix &amp;&amp; radix &lt;= 36);
 743         setOpAndDefaultFlags(NumberToStringWithValidRadixConstant);
 744         children.setChild2(Edge());
 745         m_opInfo = radix;
 746     }
 747 
 748     void convertToGetGlobalThis()
 749     {
 750         ASSERT(m_op == ToThis);
 751         setOpAndDefaultFlags(GetGlobalThis);
 752         children.setChild1(Edge());
 753     }
 754 
 755     void convertToCallObjectConstructor(FrozenValue* globalObject)
 756     {
 757         ASSERT(m_op == ToObject);
 758         setOpAndDefaultFlags(CallObjectConstructor);
 759         m_opInfo = globalObject;
 760     }
 761 
 762     void convertToNewStringObject(RegisteredStructure structure)
 763     {
 764         ASSERT(m_op == CallObjectConstructor || m_op == ToObject);
 765         setOpAndDefaultFlags(NewStringObject);
 766         m_opInfo = structure;
 767         m_opInfo2 = OpInfoWrapper();
 768     }
 769 
 770     void convertToNewObject(RegisteredStructure structure)
 771     {
 772         ASSERT(m_op == CallObjectConstructor || m_op == CreateThis || m_op == ObjectCreate);
 773         setOpAndDefaultFlags(NewObject);
 774         children.reset();
 775         m_opInfo = structure;
 776         m_opInfo2 = OpInfoWrapper();
 777     }
 778 
 779     void convertToNewPromise(RegisteredStructure structure)
 780     {
 781         ASSERT(m_op == CreatePromise);
 782         bool internal = isInternalPromise();
 783         setOpAndDefaultFlags(NewPromise);
 784         children.reset();
 785         m_opInfo = structure;
 786         m_opInfo2 = internal;
 787     }
 788 
 789     void convertToNewInternalFieldObject(NodeType newOp, RegisteredStructure structure)
 790     {
 791         ASSERT(m_op == CreateAsyncGenerator || m_op == CreateGenerator);
 792         setOpAndDefaultFlags(newOp);
 793         children.reset();
 794         m_opInfo = structure;
 795         m_opInfo2 = OpInfoWrapper();
 796     }
 797 
 798     void convertToNewArrayBuffer(FrozenValue* immutableButterfly);
 799 
 800     void convertToDirectCall(FrozenValue*);
 801 
 802     void convertToCallDOM(Graph&amp;);
 803 
 804     void convertToRegExpExecNonGlobalOrStickyWithoutChecks(FrozenValue* regExp);
 805     void convertToRegExpMatchFastGlobalWithoutChecks(FrozenValue* regExp);
 806 
 807     void convertToSetRegExpObjectLastIndex()
 808     {
 809         setOp(SetRegExpObjectLastIndex);
 810         m_opInfo = false;
 811     }
 812 
 813     void convertToInById(unsigned identifierNumber)
 814     {
 815         ASSERT(m_op == InByVal);
 816         setOpAndDefaultFlags(InById);
 817         children.setChild2(Edge());
 818         m_opInfo = identifierNumber;
 819         m_opInfo2 = OpInfoWrapper();
 820     }
 821 
 822     JSValue asJSValue()
 823     {
 824         return constant()-&gt;value();
 825     }
 826 
 827     bool isInt32Constant()
 828     {
 829         return isConstant() &amp;&amp; constant()-&gt;value().isInt32();
 830     }
 831 
 832     int32_t asInt32()
 833     {
 834         return asJSValue().asInt32();
 835     }
 836 
 837     uint32_t asUInt32()
 838     {
 839         return asInt32();
 840     }
 841 
 842     bool isDoubleConstant()
 843     {
 844         return isConstant() &amp;&amp; constant()-&gt;value().isDouble();
 845     }
 846 
 847     bool isNumberConstant()
 848     {
 849         return isConstant() &amp;&amp; constant()-&gt;value().isNumber();
 850     }
 851 
 852     double asNumber()
 853     {
 854         return asJSValue().asNumber();
 855     }
 856 
 857     bool isAnyIntConstant()
 858     {
 859         return isConstant() &amp;&amp; constant()-&gt;value().isAnyInt();
 860     }
 861 
 862     int64_t asAnyInt()
 863     {
 864         return asJSValue().asAnyInt();
 865     }
 866 
 867     bool isBooleanConstant()
 868     {
 869         return isConstant() &amp;&amp; constant()-&gt;value().isBoolean();
 870     }
 871 
 872     bool asBoolean()
 873     {
 874         return constant()-&gt;value().asBoolean();
 875     }
 876 
 877     bool isUndefinedOrNullConstant()
 878     {
 879         return isConstant() &amp;&amp; constant()-&gt;value().isUndefinedOrNull();
 880     }
 881 
 882     bool isCellConstant()
 883     {
 884         return isConstant() &amp;&amp; constant()-&gt;value() &amp;&amp; constant()-&gt;value().isCell();
 885     }
 886 
 887     JSCell* asCell()
 888     {
 889         return constant()-&gt;value().asCell();
 890     }
 891 
 892     template&lt;typename T&gt;
 893     T dynamicCastConstant(VM&amp; vm)
 894     {
 895         if (!isCellConstant())
 896             return nullptr;
 897         return jsDynamicCast&lt;T&gt;(vm, asCell());
 898     }
 899 
 900     bool hasLazyJSValue()
 901     {
 902         return op() == LazyJSConstant;
 903     }
 904 
 905     LazyJSValue lazyJSValue()
 906     {
 907         ASSERT(hasLazyJSValue());
 908         return *m_opInfo.as&lt;LazyJSValue*&gt;();
 909     }
 910 
 911     String tryGetString(Graph&amp;);
 912 
 913     JSValue initializationValueForActivation() const
 914     {
 915         ASSERT(op() == CreateActivation);
 916         return m_opInfo2.as&lt;FrozenValue*&gt;()-&gt;value();
 917     }
 918 
 919     bool hasArgumentsChild()
 920     {
 921         switch (op()) {
 922         case GetMyArgumentByVal:
 923         case GetMyArgumentByValOutOfBounds:
 924         case VarargsLength:
 925         case LoadVarargs:
 926         case ForwardVarargs:
 927         case CallVarargs:
 928         case CallForwardVarargs:
 929         case ConstructVarargs:
 930         case ConstructForwardVarargs:
 931         case TailCallVarargs:
 932         case TailCallForwardVarargs:
 933         case TailCallVarargsInlinedCaller:
 934         case TailCallForwardVarargsInlinedCaller:
 935             return true;
 936         default:
 937             return false;
 938         }
 939     }
 940 
 941     Edge&amp; argumentsChild()
 942     {
 943         switch (op()) {
 944         case GetMyArgumentByVal:
 945         case GetMyArgumentByValOutOfBounds:
 946         case VarargsLength:
 947             return child1();
 948         case LoadVarargs:
 949         case ForwardVarargs:
 950             return child2();
 951         case CallVarargs:
 952         case CallForwardVarargs:
 953         case ConstructVarargs:
 954         case ConstructForwardVarargs:
 955         case TailCallVarargs:
 956         case TailCallForwardVarargs:
 957         case TailCallVarargsInlinedCaller:
 958         case TailCallForwardVarargsInlinedCaller:
 959             return child3();
 960         default:
 961             RELEASE_ASSERT_NOT_REACHED();
 962             return child1();
 963         }
 964     }
 965 
 966     bool containsMovHint()
 967     {
 968         switch (op()) {
 969         case MovHint:
 970         case ZombieHint:
 971             return true;
 972         default:
 973             return false;
 974         }
 975     }
 976 
 977     bool hasVariableAccessData(Graph&amp;);
 978     bool accessesStack(Graph&amp; graph)
 979     {
 980         return hasVariableAccessData(graph);
 981     }
 982 
 983     // This is useful for debugging code, where a node that should have a variable
 984     // access data doesn&#39;t have one because it hasn&#39;t been initialized yet.
 985     VariableAccessData* tryGetVariableAccessData()
 986     {
 987         VariableAccessData* result = m_opInfo.as&lt;VariableAccessData*&gt;();
 988         if (!result)
 989             return 0;
 990         return result-&gt;find();
 991     }
 992 
 993     VariableAccessData* variableAccessData()
 994     {
 995         return m_opInfo.as&lt;VariableAccessData*&gt;()-&gt;find();
 996     }
 997 
 998     Operand operand()
 999     {
1000         return variableAccessData()-&gt;operand();
1001     }
1002 
1003     VirtualRegister machineLocal()
1004     {
1005         return variableAccessData()-&gt;machineLocal();
1006     }
1007 
1008     bool hasUnlinkedOperand()
1009     {
1010         switch (op()) {
1011         case ExtractOSREntryLocal:
1012         case MovHint:
1013         case ZombieHint:
1014         case KillStack:
1015             return true;
1016         default:
1017             return false;
1018         }
1019     }
1020 
1021     Operand unlinkedOperand()
1022     {
1023         ASSERT(hasUnlinkedOperand());
1024         return Operand::fromBits(m_opInfo.as&lt;uint64_t&gt;());
1025     }
1026 
1027     bool hasStackAccessData()
1028     {
1029         switch (op()) {
1030         case PutStack:
1031         case GetStack:
1032             return true;
1033         default:
1034             return false;
1035         }
1036     }
1037 
1038     StackAccessData* stackAccessData()
1039     {
1040         ASSERT(hasStackAccessData());
1041         return m_opInfo.as&lt;StackAccessData*&gt;();
1042     }
1043 
1044     unsigned argumentCountIncludingThis()
1045     {
1046         ASSERT(op() == SetArgumentCountIncludingThis);
1047         return m_opInfo.as&lt;unsigned&gt;();
1048     }
1049 
1050     bool hasPhi()
1051     {
1052         return op() == Upsilon;
1053     }
1054 
1055     Node* phi()
1056     {
1057         ASSERT(hasPhi());
1058         return m_opInfo.as&lt;Node*&gt;();
1059     }
1060 
1061     bool isStoreBarrier()
1062     {
1063         return op() == StoreBarrier || op() == FencedStoreBarrier;
1064     }
1065 
1066     bool hasIdentifier()
1067     {
1068         switch (op()) {
1069         case TryGetById:
1070         case GetById:
1071         case GetByIdFlush:
1072         case GetByIdWithThis:
1073         case GetByIdDirect:
1074         case GetByIdDirectFlush:
1075         case PutById:
1076         case PutByIdFlush:
1077         case PutByIdDirect:
1078         case PutByIdWithThis:
1079         case PutGetterById:
1080         case PutSetterById:
1081         case PutGetterSetterById:
1082         case DeleteById:
1083         case InById:
1084         case GetDynamicVar:
1085         case PutDynamicVar:
1086         case ResolveScopeForHoistingFuncDeclInEval:
1087         case ResolveScope:
1088         case ToObject:
1089             return true;
1090         default:
1091             return false;
1092         }
1093     }
1094 
1095     unsigned identifierNumber()
1096     {
1097         ASSERT(hasIdentifier());
1098         return m_opInfo.as&lt;unsigned&gt;();
1099     }
1100 
1101     bool hasGetPutInfo()
1102     {
1103         switch (op()) {
1104         case GetDynamicVar:
1105         case PutDynamicVar:
1106             return true;
1107         default:
1108             return false;
1109         }
1110     }
1111 
1112     unsigned getPutInfo()
1113     {
1114         ASSERT(hasGetPutInfo());
1115         return static_cast&lt;unsigned&gt;(m_opInfo.as&lt;uint64_t&gt;() &gt;&gt; 32);
1116     }
1117 
1118     bool hasAccessorAttributes()
1119     {
1120         switch (op()) {
1121         case PutGetterById:
1122         case PutSetterById:
1123         case PutGetterSetterById:
1124         case PutGetterByVal:
1125         case PutSetterByVal:
1126             return true;
1127         default:
1128             return false;
1129         }
1130     }
1131 
1132     int32_t accessorAttributes()
1133     {
1134         ASSERT(hasAccessorAttributes());
1135         switch (op()) {
1136         case PutGetterById:
1137         case PutSetterById:
1138         case PutGetterSetterById:
1139             return m_opInfo2.as&lt;int32_t&gt;();
1140         case PutGetterByVal:
1141         case PutSetterByVal:
1142             return m_opInfo.as&lt;int32_t&gt;();
1143         default:
1144             RELEASE_ASSERT_NOT_REACHED();
1145             return 0;
1146         }
1147     }
1148 
1149     bool hasPromotedLocationDescriptor()
1150     {
1151         return op() == PutHint;
1152     }
1153 
1154     PromotedLocationDescriptor promotedLocationDescriptor();
1155 
1156     // This corrects the arithmetic node flags, so that irrelevant bits are
1157     // ignored. In particular, anything other than ArithMul or ValueMul does not need
1158     // to know if it can speculate on negative zero.
1159     NodeFlags arithNodeFlags()
1160     {
1161         NodeFlags result = m_flags &amp; NodeArithFlagsMask;
1162         if (op() == ArithMul || op() == ArithDiv || op() == ValueDiv || op() == ArithMod || op() == ArithNegate || op() == ArithPow || op() == ArithRound || op() == ArithFloor || op() == ArithCeil || op() == ArithTrunc || op() == DoubleAsInt32 || op() == ValueNegate || op() == ValueMul || op() == ValueDiv)
1163             return result;
1164         return result &amp; ~NodeBytecodeNeedsNegZero;
1165     }
1166 
1167     bool mayHaveNonIntResult()
1168     {
1169         return m_flags &amp; NodeMayHaveNonIntResult;
1170     }
1171 
1172     bool mayHaveDoubleResult()
1173     {
1174         return m_flags &amp; NodeMayHaveDoubleResult;
1175     }
1176 
1177     bool mayHaveNonNumericResult()
1178     {
1179         return m_flags &amp; NodeMayHaveNonNumericResult;
1180     }
1181 
1182     bool mayHaveBigIntResult()
1183     {
1184         return m_flags &amp; NodeMayHaveBigIntResult;
1185     }
1186 
1187     bool hasNewArrayBufferData()
1188     {
1189         return op() == NewArrayBuffer || op() == PhantomNewArrayBuffer;
1190     }
1191 
1192     NewArrayBufferData newArrayBufferData()
1193     {
1194         ASSERT(hasNewArrayBufferData());
1195         return m_opInfo2.asNewArrayBufferData();
1196     }
1197 
1198     unsigned hasVectorLengthHint()
1199     {
1200         switch (op()) {
1201         case NewArray:
1202         case NewArrayBuffer:
1203         case PhantomNewArrayBuffer:
1204             return true;
1205         default:
1206             return false;
1207         }
1208     }
1209 
1210     unsigned vectorLengthHint()
1211     {
1212         ASSERT(hasVectorLengthHint());
1213         if (op() == NewArray)
1214             return m_opInfo2.as&lt;unsigned&gt;();
1215         return newArrayBufferData().vectorLengthHint;
1216     }
1217 
1218     bool hasIndexingType()
1219     {
1220         switch (op()) {
1221         case NewArray:
1222         case NewArrayWithSize:
1223         case NewArrayBuffer:
1224         case PhantomNewArrayBuffer:
1225             return true;
1226         default:
1227             return false;
1228         }
1229     }
1230 
1231     BitVector* bitVector()
1232     {
1233         ASSERT(op() == NewArrayWithSpread || op() == PhantomNewArrayWithSpread);
1234         return m_opInfo.as&lt;BitVector*&gt;();
1235     }
1236 
1237     // Return the indexing type that an array allocation *wants* to use. It may end up using a different
1238     // type if we&#39;re having a bad time. You can determine the actual indexing type by asking the global
1239     // object:
1240     //
1241     //     m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType())
1242     //
1243     // This will give you a Structure*, and that will have some indexing type that may be different from
1244     // the this one.
1245     IndexingType indexingType()
1246     {
1247         ASSERT(hasIndexingType());
1248         if (op() == NewArrayBuffer || op() == PhantomNewArrayBuffer)
1249             return static_cast&lt;IndexingType&gt;(newArrayBufferData().indexingMode) &amp; IndexingTypeMask;
1250         return static_cast&lt;IndexingType&gt;(m_opInfo.as&lt;uint32_t&gt;());
1251     }
1252 
1253     IndexingType indexingMode()
1254     {
1255         ASSERT(hasIndexingType());
1256         if (op() == NewArrayBuffer || op() == PhantomNewArrayBuffer)
1257             return static_cast&lt;IndexingType&gt;(newArrayBufferData().indexingMode);
1258         return static_cast&lt;IndexingType&gt;(m_opInfo.as&lt;uint32_t&gt;());
1259     }
1260 
1261     bool hasTypedArrayType()
1262     {
1263         switch (op()) {
1264         case NewTypedArray:
1265             return true;
1266         default:
1267             return false;
1268         }
1269     }
1270 
1271     TypedArrayType typedArrayType()
1272     {
1273         ASSERT(hasTypedArrayType());
1274         TypedArrayType result = static_cast&lt;TypedArrayType&gt;(m_opInfo.as&lt;uint32_t&gt;());
1275         ASSERT(isTypedView(result));
1276         return result;
1277     }
1278 
1279     bool hasInlineCapacity()
1280     {
1281         return op() == CreateThis;
1282     }
1283 
1284     unsigned inlineCapacity()
1285     {
1286         ASSERT(hasInlineCapacity());
1287         return m_opInfo.as&lt;unsigned&gt;();
1288     }
1289 
1290     bool hasIsInternalPromise()
1291     {
1292         return op() == CreatePromise || op() == NewPromise;
1293     }
1294 
1295     bool isInternalPromise()
1296     {
1297         ASSERT(hasIsInternalPromise());
1298         return m_opInfo2.as&lt;bool&gt;();
1299     }
1300 
1301     void setIndexingType(IndexingType indexingType)
1302     {
1303         ASSERT(hasIndexingType());
1304         m_opInfo = indexingType;
1305     }
1306 
1307     bool hasScopeOffset()
1308     {
1309         return op() == GetClosureVar || op() == PutClosureVar;
1310     }
1311 
1312     ScopeOffset scopeOffset()
1313     {
1314         ASSERT(hasScopeOffset());
1315         return ScopeOffset(m_opInfo.as&lt;uint32_t&gt;());
1316     }
1317 
1318     unsigned hasInternalFieldIndex()
1319     {
1320         return op() == GetInternalField || op() == PutInternalField;
1321     }
1322 
1323     unsigned internalFieldIndex()
1324     {
1325         ASSERT(hasInternalFieldIndex());
1326         return m_opInfo.as&lt;uint32_t&gt;();
1327     }
1328 
1329     bool hasDirectArgumentsOffset()
1330     {
1331         return op() == GetFromArguments || op() == PutToArguments;
1332     }
1333 
1334     DirectArgumentsOffset capturedArgumentsOffset()
1335     {
1336         ASSERT(hasDirectArgumentsOffset());
1337         return DirectArgumentsOffset(m_opInfo.as&lt;uint32_t&gt;());
1338     }
1339 
1340     bool hasRegisterPointer()
1341     {
1342         return op() == GetGlobalVar || op() == GetGlobalLexicalVariable || op() == PutGlobalVariable;
1343     }
1344 
1345     WriteBarrier&lt;Unknown&gt;* variablePointer()
1346     {
1347         return m_opInfo.as&lt;WriteBarrier&lt;Unknown&gt;*&gt;();
1348     }
1349 
1350     bool hasCallVarargsData()
1351     {
1352         switch (op()) {
1353         case CallVarargs:
1354         case CallForwardVarargs:
1355         case TailCallVarargs:
1356         case TailCallForwardVarargs:
1357         case TailCallVarargsInlinedCaller:
1358         case TailCallForwardVarargsInlinedCaller:
1359         case ConstructVarargs:
1360         case ConstructForwardVarargs:
1361             return true;
1362         default:
1363             return false;
1364         }
1365     }
1366 
1367     CallVarargsData* callVarargsData()
1368     {
1369         ASSERT(hasCallVarargsData());
1370         return m_opInfo.as&lt;CallVarargsData*&gt;();
1371     }
1372 
1373     bool hasLoadVarargsData()
1374     {
1375         return op() == LoadVarargs || op() == ForwardVarargs || op() == VarargsLength;
1376     }
1377 
1378     LoadVarargsData* loadVarargsData()
1379     {
1380         ASSERT(hasLoadVarargsData());
1381         return m_opInfo.as&lt;LoadVarargsData*&gt;();
1382     }
1383 
1384     InlineCallFrame* argumentsInlineCallFrame()
1385     {
1386         ASSERT(op() == GetArgumentCountIncludingThis);
1387         return m_opInfo.as&lt;InlineCallFrame*&gt;();
1388     }
1389 
1390     bool hasQueriedType()
1391     {
1392         return op() == IsCellWithType;
1393     }
1394 
1395     JSType queriedType()
1396     {
1397         static_assert(std::is_same&lt;uint8_t, std::underlying_type&lt;JSType&gt;::type&gt;::value, &quot;Ensure that uint8_t is the underlying type for JSType.&quot;);
1398         return static_cast&lt;JSType&gt;(m_opInfo.as&lt;uint32_t&gt;());
1399     }
1400 
1401     bool hasSpeculatedTypeForQuery()
1402     {
1403         return op() == IsCellWithType;
1404     }
1405 
1406     Optional&lt;SpeculatedType&gt; speculatedTypeForQuery()
1407     {
1408         return speculationFromJSType(queriedType());
1409     }
1410 
1411     bool hasResult()
1412     {
1413         return !!result();
1414     }
1415 
1416     bool hasInt32Result()
1417     {
1418         return result() == NodeResultInt32;
1419     }
1420 
1421     bool hasInt52Result()
1422     {
1423         return result() == NodeResultInt52;
1424     }
1425 
1426     bool hasNumberResult()
1427     {
1428         return result() == NodeResultNumber;
1429     }
1430 
1431     bool hasNumberOrAnyIntResult()
1432     {
1433         return hasNumberResult() || hasInt32Result() || hasInt52Result();
1434     }
1435 
1436     bool hasNumericResult()
1437     {
1438         switch (op()) {
1439         case ValueSub:
1440         case ValueMul:
1441         case ValueBitAnd:
1442         case ValueBitOr:
1443         case ValueBitXor:
1444         case ValueBitNot:
1445         case ValueBitLShift:
1446         case ValueBitRShift:
1447         case ValueNegate:
1448             return true;
1449         default:
1450             return false;
1451         }
1452     }
1453 
1454     bool hasDoubleResult()
1455     {
1456         return result() == NodeResultDouble;
1457     }
1458 
1459     bool hasJSResult()
1460     {
1461         return result() == NodeResultJS;
1462     }
1463 
1464     bool hasBooleanResult()
1465     {
1466         return result() == NodeResultBoolean;
1467     }
1468 
1469     bool hasStorageResult()
1470     {
1471         return result() == NodeResultStorage;
1472     }
1473 
1474     UseKind defaultUseKind()
1475     {
1476         return useKindForResult(result());
1477     }
1478 
1479     Edge defaultEdge()
1480     {
1481         return Edge(this, defaultUseKind());
1482     }
1483 
1484     bool isJump()
1485     {
1486         return op() == Jump;
1487     }
1488 
1489     bool isBranch()
1490     {
1491         return op() == Branch;
1492     }
1493 
1494     bool isSwitch() const
1495     {
1496         return op() == Switch;
1497     }
1498 
1499     bool isEntrySwitch() const
1500     {
1501         return op() == EntrySwitch;
1502     }
1503 
1504     bool isTerminal()
1505     {
1506         switch (op()) {
1507         case Jump:
1508         case Branch:
1509         case Switch:
1510         case EntrySwitch:
1511         case Return:
1512         case TailCall:
1513         case DirectTailCall:
1514         case TailCallVarargs:
1515         case TailCallForwardVarargs:
1516         case Unreachable:
1517         case Throw:
1518         case ThrowStaticError:
1519             return true;
1520         default:
1521             return false;
1522         }
1523     }
1524 
1525     bool isFunctionTerminal()
1526     {
1527         if (isTerminal() &amp;&amp; !numSuccessors())
1528             return true;
1529 
1530         return false;
1531     }
1532 
1533     // As is described in DFGNodeType.h&#39;s ForceOSRExit, this is a pseudo-terminal.
1534     // It means that execution should fall out of DFG at this point, but execution
1535     // does continue in the basic block - just in a different compiler.
1536     // FIXME: This is used for lightweight reachability decision. But this should
1537     // be replaced with AI-based reachability ideally.
1538     bool isPseudoTerminal()
1539     {
1540         switch (op()) {
1541         case ForceOSRExit:
1542         case CheckBadCell:
1543             return true;
1544         default:
1545             return false;
1546         }
1547     }
1548 
1549     unsigned targetBytecodeOffsetDuringParsing()
1550     {
1551         ASSERT(isJump());
1552         return m_opInfo.as&lt;unsigned&gt;();
1553     }
1554 
1555     BasicBlock*&amp; targetBlock()
1556     {
1557         ASSERT(isJump());
1558         return *bitwise_cast&lt;BasicBlock**&gt;(&amp;m_opInfo.u.pointer);
1559     }
1560 
1561     BranchData* branchData()
1562     {
1563         ASSERT(isBranch());
1564         return m_opInfo.as&lt;BranchData*&gt;();
1565     }
1566 
1567     SwitchData* switchData()
1568     {
1569         ASSERT(isSwitch());
1570         return m_opInfo.as&lt;SwitchData*&gt;();
1571     }
1572 
1573     EntrySwitchData* entrySwitchData()
1574     {
1575         ASSERT(isEntrySwitch());
1576         return m_opInfo.as&lt;EntrySwitchData*&gt;();
1577     }
1578 
1579     bool hasIntrinsic()
1580     {
1581         switch (op()) {
1582         case CPUIntrinsic:
1583         case DateGetTime:
1584         case DateGetInt32OrNaN:
1585             return true;
1586         default:
1587             return false;
1588         }
1589     }
1590 
1591     Intrinsic intrinsic()
1592     {
1593         ASSERT(hasIntrinsic());
1594         return m_opInfo.as&lt;Intrinsic&gt;();
1595     }
1596 
1597     unsigned numSuccessors()
1598     {
1599         switch (op()) {
1600         case Jump:
1601             return 1;
1602         case Branch:
1603             return 2;
1604         case Switch:
1605             return switchData()-&gt;cases.size() + 1;
1606         case EntrySwitch:
1607             return entrySwitchData()-&gt;cases.size();
1608         default:
1609             return 0;
1610         }
1611     }
1612 
1613     BasicBlock*&amp; successor(unsigned index)
1614     {
1615         if (isSwitch()) {
1616             if (index &lt; switchData()-&gt;cases.size())
1617                 return switchData()-&gt;cases[index].target.block;
1618             RELEASE_ASSERT(index == switchData()-&gt;cases.size());
1619             return switchData()-&gt;fallThrough.block;
1620         } else if (isEntrySwitch())
1621             return entrySwitchData()-&gt;cases[index];
1622 
1623         switch (index) {
1624         case 0:
1625             if (isJump())
1626                 return targetBlock();
1627             return branchData()-&gt;taken.block;
1628         case 1:
1629             return branchData()-&gt;notTaken.block;
1630         default:
1631             RELEASE_ASSERT_NOT_REACHED();
1632             return targetBlock();
1633         }
1634     }
1635 
1636     class SuccessorsIterable {
1637     public:
1638         SuccessorsIterable()
1639             : m_terminal(nullptr)
1640         {
1641         }
1642 
1643         SuccessorsIterable(Node* terminal)
1644             : m_terminal(terminal)
1645         {
1646         }
1647 
1648         class iterator {
1649         public:
1650             iterator()
1651                 : m_terminal(nullptr)
1652                 , m_index(UINT_MAX)
1653             {
1654             }
1655 
1656             iterator(Node* terminal, unsigned index)
1657                 : m_terminal(terminal)
1658                 , m_index(index)
1659             {
1660             }
1661 
1662             BasicBlock* operator*()
1663             {
1664                 return m_terminal-&gt;successor(m_index);
1665             }
1666 
1667             iterator&amp; operator++()
1668             {
1669                 m_index++;
1670                 return *this;
1671             }
1672 
1673             bool operator==(const iterator&amp; other) const
1674             {
1675                 return m_index == other.m_index;
1676             }
1677 
1678             bool operator!=(const iterator&amp; other) const
1679             {
1680                 return !(*this == other);
1681             }
1682         private:
1683             Node* m_terminal;
1684             unsigned m_index;
1685         };
1686 
1687         iterator begin()
1688         {
1689             return iterator(m_terminal, 0);
1690         }
1691 
1692         iterator end()
1693         {
1694             return iterator(m_terminal, m_terminal-&gt;numSuccessors());
1695         }
1696 
1697         size_t size() const { return m_terminal-&gt;numSuccessors(); }
1698         BasicBlock* at(size_t index) const { return m_terminal-&gt;successor(index); }
1699         BasicBlock* operator[](size_t index) const { return at(index); }
1700 
1701     private:
1702         Node* m_terminal;
1703     };
1704 
1705     SuccessorsIterable successors()
1706     {
1707         return SuccessorsIterable(this);
1708     }
1709 
1710     BasicBlock*&amp; successorForCondition(bool condition)
1711     {
1712         return branchData()-&gt;forCondition(condition);
1713     }
1714 
1715     bool hasHeapPrediction()
1716     {
1717         switch (op()) {
1718         case ArithAbs:
1719         case ArithRound:
1720         case ArithFloor:
1721         case ArithCeil:
1722         case ArithTrunc:
1723         case GetDirectPname:
1724         case GetById:
1725         case GetByIdFlush:
1726         case GetByIdWithThis:
1727         case GetByIdDirect:
1728         case GetByIdDirectFlush:
1729         case GetPrototypeOf:
1730         case TryGetById:
1731         case GetByVal:
1732         case GetByValWithThis:
1733         case Call:
1734         case DirectCall:
1735         case TailCallInlinedCaller:
1736         case DirectTailCallInlinedCaller:
1737         case Construct:
1738         case DirectConstruct:
1739         case CallVarargs:
1740         case CallEval:
1741         case TailCallVarargsInlinedCaller:
1742         case ConstructVarargs:
1743         case CallForwardVarargs:
1744         case TailCallForwardVarargsInlinedCaller:
1745         case GetByOffset:
1746         case MultiGetByOffset:
1747         case GetClosureVar:
1748         case GetInternalField:
1749         case GetFromArguments:
1750         case GetArgument:
1751         case ArrayPop:
1752         case ArrayPush:
1753         case RegExpExec:
1754         case RegExpExecNonGlobalOrSticky:
1755         case RegExpTest:
1756         case RegExpMatchFast:
1757         case RegExpMatchFastGlobal:
1758         case GetGlobalVar:
1759         case GetGlobalLexicalVariable:
1760         case StringReplace:
1761         case StringReplaceRegExp:
1762         case ToNumber:
1763         case ToNumeric:
1764         case ToObject:
1765         case ValueBitAnd:
1766         case ValueBitOr:
1767         case ValueBitXor:
1768         case ValueBitNot:
1769         case ValueBitLShift:
1770         case ValueBitRShift:
1771         case CallObjectConstructor:
1772         case LoadKeyFromMapBucket:
1773         case LoadValueFromMapBucket:
1774         case CallDOMGetter:
1775         case CallDOM:
1776         case ParseInt:
1777         case AtomicsAdd:
1778         case AtomicsAnd:
1779         case AtomicsCompareExchange:
1780         case AtomicsExchange:
1781         case AtomicsLoad:
1782         case AtomicsOr:
1783         case AtomicsStore:
1784         case AtomicsSub:
1785         case AtomicsXor:
1786         case GetDynamicVar:
1787         case ExtractValueFromWeakMapGet:
1788         case ToThis:
1789         case DataViewGetInt:
1790         case DataViewGetFloat:
1791         case DateGetInt32OrNaN:
1792             return true;
1793         default:
1794             return false;
1795         }
1796     }
1797 
1798     SpeculatedType getHeapPrediction()
1799     {
1800         ASSERT(hasHeapPrediction());
1801         return m_opInfo2.as&lt;SpeculatedType&gt;();
1802     }
1803 
1804     void setHeapPrediction(SpeculatedType prediction)
1805     {
1806         ASSERT(hasHeapPrediction());
1807         m_opInfo2 = prediction;
1808     }
1809 
1810     SpeculatedType getForcedPrediction()
1811     {
1812         ASSERT(op() == IdentityWithProfile);
1813         return m_opInfo.as&lt;SpeculatedType&gt;();
1814     }
1815 
1816     uint32_t catchOSREntryIndex() const
1817     {
1818         ASSERT(op() == ExtractCatchLocal);
1819         return m_opInfo.as&lt;uint32_t&gt;();
1820     }
1821 
1822     SpeculatedType catchLocalPrediction()
1823     {
1824         ASSERT(op() == ExtractCatchLocal);
1825         return m_opInfo2.as&lt;SpeculatedType&gt;();
1826     }
1827 
1828     bool hasCellOperand()
1829     {
1830         switch (op()) {
1831         case CheckCell:
1832         case OverridesHasInstance:
1833         case NewFunction:
1834         case NewGeneratorFunction:
1835         case NewAsyncFunction:
1836         case NewAsyncGeneratorFunction:
1837         case CreateActivation:
1838         case MaterializeCreateActivation:
1839         case NewRegexp:
1840         case NewArrayBuffer:
1841         case PhantomNewArrayBuffer:
1842         case CompareEqPtr:
1843         case CallObjectConstructor:
1844         case DirectCall:
1845         case DirectTailCall:
1846         case DirectConstruct:
1847         case DirectTailCallInlinedCaller:
1848         case RegExpExecNonGlobalOrSticky:
1849         case RegExpMatchFastGlobal:
1850             return true;
1851         default:
1852             return false;
1853         }
1854     }
1855 
1856     FrozenValue* cellOperand()
1857     {
1858         ASSERT(hasCellOperand());
1859         return m_opInfo.as&lt;FrozenValue*&gt;();
1860     }
1861 
1862     template&lt;typename T&gt;
1863     T castOperand()
1864     {
1865         return cellOperand()-&gt;cast&lt;T&gt;();
1866     }
1867 
1868     void setCellOperand(FrozenValue* value)
1869     {
1870         ASSERT(hasCellOperand());
1871         m_opInfo = value;
1872     }
1873 
1874     bool hasWatchpointSet()
1875     {
1876         return op() == NotifyWrite;
1877     }
1878 
1879     WatchpointSet* watchpointSet()
1880     {
1881         ASSERT(hasWatchpointSet());
1882         return m_opInfo.as&lt;WatchpointSet*&gt;();
1883     }
1884 
1885     bool hasStoragePointer()
1886     {
1887         return op() == ConstantStoragePointer;
1888     }
1889 
1890     void* storagePointer()
1891     {
1892         ASSERT(hasStoragePointer());
1893         return m_opInfo.as&lt;void*&gt;();
1894     }
1895 
1896     bool hasUidOperand()
1897     {
1898         return op() == CheckIdent;
1899     }
1900 
1901     UniquedStringImpl* uidOperand()
1902     {
1903         ASSERT(hasUidOperand());
1904         return m_opInfo.as&lt;UniquedStringImpl*&gt;();
1905     }
1906 
1907     bool hasTypeInfoOperand()
1908     {
1909         return op() == CheckTypeInfoFlags;
1910     }
1911 
1912     unsigned typeInfoOperand()
1913     {
1914         ASSERT(hasTypeInfoOperand() &amp;&amp; m_opInfo.as&lt;uint32_t&gt;() &lt;= static_cast&lt;uint32_t&gt;(UCHAR_MAX));
1915         return m_opInfo.as&lt;uint32_t&gt;();
1916     }
1917 
1918     bool hasTransition()
1919     {
1920         switch (op()) {
1921         case PutStructure:
1922         case AllocatePropertyStorage:
1923         case ReallocatePropertyStorage:
1924             return true;
1925         default:
1926             return false;
1927         }
1928     }
1929 
1930     Transition* transition()
1931     {
1932         ASSERT(hasTransition());
1933         return m_opInfo.as&lt;Transition*&gt;();
1934     }
1935 
1936     bool hasStructureSet()
1937     {
1938         switch (op()) {
1939         case CheckStructure:
1940         case CheckStructureOrEmpty:
1941         case CheckStructureImmediate:
1942         case MaterializeNewObject:
1943             return true;
1944         default:
1945             return false;
1946         }
1947     }
1948 
1949     const RegisteredStructureSet&amp; structureSet()
1950     {
1951         ASSERT(hasStructureSet());
1952         return *m_opInfo.as&lt;RegisteredStructureSet*&gt;();
1953     }
1954 
1955     bool hasStructure()
1956     {
1957         switch (op()) {
1958         case ArrayifyToStructure:
1959         case MaterializeNewInternalFieldObject:
1960         case NewObject:
1961         case NewPromise:
1962         case NewGenerator:
1963         case NewAsyncGenerator:
1964         case NewArrayIterator:
1965         case NewStringObject:
1966             return true;
1967         default:
1968             return false;
1969         }
1970     }
1971 
1972     RegisteredStructure structure()
1973     {
1974         ASSERT(hasStructure());
1975         return m_opInfo.asRegisteredStructure();
1976     }
1977 
1978     bool hasStorageAccessData()
1979     {
1980         switch (op()) {
1981         case GetByOffset:
1982         case PutByOffset:
1983         case GetGetterSetterByOffset:
1984             return true;
1985         default:
1986             return false;
1987         }
1988     }
1989 
1990     StorageAccessData&amp; storageAccessData()
1991     {
1992         ASSERT(hasStorageAccessData());
1993         return *m_opInfo.as&lt;StorageAccessData*&gt;();
1994     }
1995 
1996     bool hasMultiGetByOffsetData()
1997     {
1998         return op() == MultiGetByOffset;
1999     }
2000 
2001     MultiGetByOffsetData&amp; multiGetByOffsetData()
2002     {
2003         ASSERT(hasMultiGetByOffsetData());
2004         return *m_opInfo.as&lt;MultiGetByOffsetData*&gt;();
2005     }
2006 
2007     bool hasMultiPutByOffsetData()
2008     {
2009         return op() == MultiPutByOffset;
2010     }
2011 
2012     MultiPutByOffsetData&amp; multiPutByOffsetData()
2013     {
2014         ASSERT(hasMultiPutByOffsetData());
2015         return *m_opInfo.as&lt;MultiPutByOffsetData*&gt;();
2016     }
2017 
2018     bool hasMatchStructureData()
2019     {
2020         return op() == MatchStructure;
2021     }
2022 
2023     MatchStructureData&amp; matchStructureData()
2024     {
2025         ASSERT(hasMatchStructureData());
2026         return *m_opInfo.as&lt;MatchStructureData*&gt;();
2027     }
2028 
2029     bool hasObjectMaterializationData()
2030     {
2031         switch (op()) {
2032         case MaterializeNewObject:
2033         case MaterializeNewInternalFieldObject:
2034         case MaterializeCreateActivation:
2035             return true;
2036 
2037         default:
2038             return false;
2039         }
2040     }
2041 
2042     ObjectMaterializationData&amp; objectMaterializationData()
2043     {
2044         ASSERT(hasObjectMaterializationData());
2045         return *m_opInfo2.as&lt;ObjectMaterializationData*&gt;();
2046     }
2047 
2048     bool isObjectAllocation()
2049     {
2050         switch (op()) {
2051         case NewObject:
2052         case MaterializeNewObject:
2053             return true;
2054         default:
2055             return false;
2056         }
2057     }
2058 
2059     bool isPhantomObjectAllocation()
2060     {
2061         switch (op()) {
2062         case PhantomNewObject:
2063             return true;
2064         default:
2065             return false;
2066         }
2067     }
2068 
2069     bool isActivationAllocation()
2070     {
2071         switch (op()) {
2072         case CreateActivation:
2073         case MaterializeCreateActivation:
2074             return true;
2075         default:
2076             return false;
2077         }
2078     }
2079 
2080     bool isPhantomActivationAllocation()
2081     {
2082         switch (op()) {
2083         case PhantomCreateActivation:
2084             return true;
2085         default:
2086             return false;
2087         }
2088     }
2089 
2090     bool isFunctionAllocation()
2091     {
2092         switch (op()) {
2093         case NewFunction:
2094         case NewGeneratorFunction:
2095         case NewAsyncGeneratorFunction:
2096         case NewAsyncFunction:
2097             return true;
2098         default:
2099             return false;
2100         }
2101     }
2102 
2103     bool isPhantomFunctionAllocation()
2104     {
2105         switch (op()) {
2106         case PhantomNewFunction:
2107         case PhantomNewGeneratorFunction:
2108         case PhantomNewAsyncFunction:
2109         case PhantomNewAsyncGeneratorFunction:
2110             return true;
2111         default:
2112             return false;
2113         }
2114     }
2115 
2116     bool isPhantomAllocation()
2117     {
2118         switch (op()) {
2119         case PhantomNewObject:
2120         case PhantomDirectArguments:
2121         case PhantomCreateRest:
2122         case PhantomSpread:
2123         case PhantomNewArrayWithSpread:
2124         case PhantomNewArrayBuffer:
2125         case PhantomClonedArguments:
2126         case PhantomNewFunction:
2127         case PhantomNewGeneratorFunction:
2128         case PhantomNewAsyncFunction:
2129         case PhantomNewAsyncGeneratorFunction:
2130         case PhantomNewArrayIterator:
2131         case PhantomCreateActivation:
2132         case PhantomNewRegexp:
2133             return true;
2134         default:
2135             return false;
2136         }
2137     }
2138 
2139     bool hasArrayMode()
2140     {
2141         switch (op()) {
2142         case GetIndexedPropertyStorage:
2143         case GetArrayLength:
2144         case GetVectorLength:
2145         case InByVal:
2146         case PutByValDirect:
2147         case PutByVal:
2148         case PutByValAlias:
2149         case GetByVal:
2150         case StringCharAt:
2151         case StringCharCodeAt:
2152         case StringCodePointAt:
2153         case CheckArray:
2154         case CheckArrayOrEmpty:
2155         case Arrayify:
2156         case ArrayifyToStructure:
2157         case ArrayPush:
2158         case ArrayPop:
2159         case ArrayIndexOf:
2160         case HasIndexedProperty:
2161         case AtomicsAdd:
2162         case AtomicsAnd:
2163         case AtomicsCompareExchange:
2164         case AtomicsExchange:
2165         case AtomicsLoad:
2166         case AtomicsOr:
2167         case AtomicsStore:
2168         case AtomicsSub:
2169         case AtomicsXor:
2170             return true;
2171         default:
2172             return false;
2173         }
2174     }
2175 
2176     ArrayMode arrayMode()
2177     {
2178         ASSERT(hasArrayMode());
2179         if (op() == ArrayifyToStructure)
2180             return ArrayMode::fromWord(m_opInfo2.as&lt;uint32_t&gt;());
2181         return ArrayMode::fromWord(m_opInfo.as&lt;uint32_t&gt;());
2182     }
2183 
2184     bool setArrayMode(ArrayMode arrayMode)
2185     {
2186         ASSERT(hasArrayMode());
2187         if (this-&gt;arrayMode() == arrayMode)
2188             return false;
2189         m_opInfo = arrayMode.asWord();
2190         return true;
2191     }
2192 
2193     bool hasArithMode()
2194     {
2195         switch (op()) {
2196         case ArithAbs:
2197         case ArithAdd:
2198         case ArithSub:
2199         case ArithNegate:
2200         case ArithMul:
2201         case ArithDiv:
2202         case ArithMod:
2203         case UInt32ToNumber:
2204         case DoubleAsInt32:
2205             return true;
2206         default:
2207             return false;
2208         }
2209     }
2210 
2211     Arith::Mode arithMode()
2212     {
2213         ASSERT(hasArithMode());
2214         return static_cast&lt;Arith::Mode&gt;(m_opInfo.as&lt;uint32_t&gt;());
2215     }
2216 
2217     void setArithMode(Arith::Mode mode)
2218     {
2219         m_opInfo = mode;
2220     }
2221 
2222     bool hasArithRoundingMode()
2223     {
2224         return op() == ArithRound || op() == ArithFloor || op() == ArithCeil || op() == ArithTrunc;
2225     }
2226 
2227     Arith::RoundingMode arithRoundingMode()
2228     {
2229         ASSERT(hasArithRoundingMode());
2230         return static_cast&lt;Arith::RoundingMode&gt;(m_opInfo.as&lt;uint32_t&gt;());
2231     }
2232 
2233     void setArithRoundingMode(Arith::RoundingMode mode)
2234     {
2235         ASSERT(hasArithRoundingMode());
2236         m_opInfo = static_cast&lt;uint32_t&gt;(mode);
2237     }
2238 
2239     bool hasArithUnaryType()
2240     {
2241         return op() == ArithUnary;
2242     }
2243 
2244     Arith::UnaryType arithUnaryType()
2245     {
2246         ASSERT(hasArithUnaryType());
2247         return static_cast&lt;Arith::UnaryType&gt;(m_opInfo.as&lt;uint32_t&gt;());
2248     }
2249 
2250     bool hasVirtualRegister()
2251     {
2252         return m_virtualRegister.isValid();
2253     }
2254 
2255     VirtualRegister virtualRegister()
2256     {
2257         ASSERT(hasResult());
2258         ASSERT(m_virtualRegister.isValid());
2259         return m_virtualRegister;
2260     }
2261 
2262     void setVirtualRegister(VirtualRegister virtualRegister)
2263     {
2264         ASSERT(hasResult());
2265         ASSERT(!m_virtualRegister.isValid());
2266         m_virtualRegister = virtualRegister;
2267     }
2268 
2269     bool hasExecutionCounter()
2270     {
2271         return op() == CountExecution;
2272     }
2273 
2274     Profiler::ExecutionCounter* executionCounter()
2275     {
2276         return m_opInfo.as&lt;Profiler::ExecutionCounter*&gt;();
2277     }
2278 
2279     unsigned entrypointIndex()
2280     {
2281         ASSERT(op() == InitializeEntrypointArguments);
2282         return m_opInfo.as&lt;unsigned&gt;();
2283     }
2284 
2285     DataViewData dataViewData()
2286     {
2287         ASSERT(op() == DataViewGetInt || op() == DataViewGetFloat || op() == DataViewSet);
2288         return bitwise_cast&lt;DataViewData&gt;(m_opInfo.as&lt;uint64_t&gt;());
2289     }
2290 
2291     bool shouldGenerate()
2292     {
2293         return m_refCount;
2294     }
2295 
2296     // Return true if the execution of this Node does not affect our ability to OSR to the FTL.
2297     // FIXME: Isn&#39;t this just like checking if the node has effects?
2298     bool isSemanticallySkippable()
2299     {
2300         return op() == CountExecution || op() == InvalidationPoint;
2301     }
2302 
2303     unsigned refCount()
2304     {
2305         return m_refCount;
2306     }
2307 
2308     unsigned postfixRef()
2309     {
2310         return m_refCount++;
2311     }
2312 
2313     unsigned adjustedRefCount()
2314     {
2315         return mustGenerate() ? m_refCount - 1 : m_refCount;
2316     }
2317 
2318     void setRefCount(unsigned refCount)
2319     {
2320         m_refCount = refCount;
2321     }
2322 
2323     Edge&amp; child1()
2324     {
2325         ASSERT(!(m_flags &amp; NodeHasVarArgs));
2326         return children.child1();
2327     }
2328 
2329     // This is useful if you want to do a fast check on the first child
2330     // before also doing a check on the opcode. Use this with care and
2331     // avoid it if possible.
2332     Edge child1Unchecked()
2333     {
2334         return children.child1Unchecked();
2335     }
2336 
2337     Edge&amp; child2()
2338     {
2339         ASSERT(!(m_flags &amp; NodeHasVarArgs));
2340         return children.child2();
2341     }
2342 
2343     Edge&amp; child3()
2344     {
2345         ASSERT(!(m_flags &amp; NodeHasVarArgs));
2346         return children.child3();
2347     }
2348 
2349     unsigned firstChild()
2350     {
2351         ASSERT(m_flags &amp; NodeHasVarArgs);
2352         return children.firstChild();
2353     }
2354 
2355     unsigned numChildren()
2356     {
2357         ASSERT(m_flags &amp; NodeHasVarArgs);
2358         return children.numChildren();
2359     }
2360 
2361     UseKind binaryUseKind()
2362     {
2363         ASSERT(child1().useKind() == child2().useKind());
2364         return child1().useKind();
2365     }
2366 
2367     bool isBinaryUseKind(UseKind left, UseKind right)
2368     {
2369         return child1().useKind() == left &amp;&amp; child2().useKind() == right;
2370     }
2371 
2372     bool isBinaryUseKind(UseKind useKind)
2373     {
2374         return isBinaryUseKind(useKind, useKind);
2375     }
2376 
2377     Edge childFor(UseKind useKind)
2378     {
2379         if (child1().useKind() == useKind)
2380             return child1();
2381         if (child2().useKind() == useKind)
2382             return child2();
2383         if (child3().useKind() == useKind)
2384             return child3();
2385         return Edge();
2386     }
2387 
2388     SpeculatedType prediction()
2389     {
2390         return m_prediction;
2391     }
2392 
2393     bool predict(SpeculatedType prediction)
2394     {
2395         return mergeSpeculation(m_prediction, prediction);
2396     }
2397 
2398     bool shouldSpeculateInt32()
2399     {
2400         return isInt32Speculation(prediction());
2401     }
2402 
2403     bool shouldSpeculateNotInt32()
2404     {
2405         return isNotInt32Speculation(prediction());
2406     }
2407 
2408     bool sawBooleans()
2409     {
2410         return !!(prediction() &amp; SpecBoolean);
2411     }
2412 
2413     bool shouldSpeculateInt32OrBoolean()
2414     {
2415         return isInt32OrBooleanSpeculation(prediction());
2416     }
2417 
2418     bool shouldSpeculateInt32ForArithmetic()
2419     {
2420         return isInt32SpeculationForArithmetic(prediction());
2421     }
2422 
2423     bool shouldSpeculateInt32OrBooleanForArithmetic()
2424     {
2425         return isInt32OrBooleanSpeculationForArithmetic(prediction());
2426     }
2427 
2428     bool shouldSpeculateInt32OrBooleanExpectingDefined()
2429     {
2430         return isInt32OrBooleanSpeculationExpectingDefined(prediction());
2431     }
2432 
2433     bool shouldSpeculateInt52()
2434     {
2435         // We have to include SpecInt32Only here for two reasons:
2436         // 1. We diligently write code that first checks if we should speculate Int32.
2437         // For example:
2438         // if (shouldSpeculateInt32()) ...
2439         // else if (shouldSpeculateInt52()) ...
2440         // This means we it&#39;s totally valid to speculate Int52 when we&#39;re dealing
2441         // with a type that&#39;s the union of Int32 and Int52.
2442         //
2443         // It would be a performance mistake to not include Int32 here because we obviously
2444         // have variables that are the union of Int32 and Int52 values, and it&#39;s better
2445         // to speculate Int52 than double in that situation.
2446         //
2447         // 2. We also write code where we ask if the inputs can be Int52, like if
2448         // we know via profiling that an Add overflows, we may not emit an Int32 add.
2449         // However, we only emit such an add if both inputs can be Int52, and Int32
2450         // can trivially become Int52.
2451         //
2452         return enableInt52() &amp;&amp; isInt32OrInt52Speculation(prediction());
2453     }
2454 
2455     bool shouldSpeculateDouble()
2456     {
2457         return isDoubleSpeculation(prediction());
2458     }
2459 
2460     bool shouldSpeculateDoubleReal()
2461     {
2462         return isDoubleRealSpeculation(prediction());
2463     }
2464 
2465     bool shouldSpeculateNumber()
2466     {
2467         return isFullNumberSpeculation(prediction());
2468     }
2469 
2470     bool shouldSpeculateNumberOrBoolean()
2471     {
2472         return isFullNumberOrBooleanSpeculation(prediction());
2473     }
2474 
2475     bool shouldSpeculateNumberOrBooleanExpectingDefined()
2476     {
2477         return isFullNumberOrBooleanSpeculationExpectingDefined(prediction());
2478     }
2479 
2480     bool shouldSpeculateBoolean()
2481     {
2482         return isBooleanSpeculation(prediction());
2483     }
2484 
2485     bool shouldSpeculateNotBoolean()
2486     {
2487         return isNotBooleanSpeculation(prediction());
2488     }
2489 
2490     bool shouldSpeculateOther()
2491     {
2492         return isOtherSpeculation(prediction());
2493     }
2494 
2495     bool shouldSpeculateMisc()
2496     {
2497         return isMiscSpeculation(prediction());
2498     }
2499 
2500     bool shouldSpeculateStringIdent()
2501     {
2502         return isStringIdentSpeculation(prediction());
2503     }
2504 
2505     bool shouldSpeculateNotStringVar()
2506     {
2507         return isNotStringVarSpeculation(prediction());
2508     }
2509 
2510     bool shouldSpeculateString()
2511     {
2512         return isStringSpeculation(prediction());
2513     }
2514 
2515     bool shouldSpeculateNotString()
2516     {
2517         return isNotStringSpeculation(prediction());
2518     }
2519 
2520     bool shouldSpeculateStringOrOther()
2521     {
2522         return isStringOrOtherSpeculation(prediction());
2523     }
2524 
2525     bool shouldSpeculateStringObject()
2526     {
2527         return isStringObjectSpeculation(prediction());
2528     }
2529 
2530     bool shouldSpeculateStringOrStringObject()
2531     {
2532         return isStringOrStringObjectSpeculation(prediction());
2533     }
2534 
2535     bool shouldSpeculateRegExpObject()
2536     {
2537         return isRegExpObjectSpeculation(prediction());
2538     }
2539 
2540     bool shouldSpeculateSymbol()
2541     {
2542         return isSymbolSpeculation(prediction());
2543     }
2544 
2545     bool shouldSpeculateBigInt()
2546     {
2547         return isBigIntSpeculation(prediction());
2548     }
2549 
2550     bool shouldSpeculateFinalObject()
2551     {
2552         return isFinalObjectSpeculation(prediction());
2553     }
2554 
2555     bool shouldSpeculateFinalObjectOrOther()
2556     {
2557         return isFinalObjectOrOtherSpeculation(prediction());
2558     }
2559 
2560     bool shouldSpeculateArray()
2561     {
2562         return isArraySpeculation(prediction());
2563     }
2564 
2565     bool shouldSpeculateFunction()
2566     {
2567         return isFunctionSpeculation(prediction());
2568     }
2569 
2570     bool shouldSpeculateProxyObject()
2571     {
2572         return isProxyObjectSpeculation(prediction());
2573     }
2574 
2575     bool shouldSpeculateDerivedArray()
2576     {
2577         return isDerivedArraySpeculation(prediction());
2578     }
2579 
2580     bool shouldSpeculateDirectArguments()
2581     {
2582         return isDirectArgumentsSpeculation(prediction());
2583     }
2584 
2585     bool shouldSpeculateScopedArguments()
2586     {
2587         return isScopedArgumentsSpeculation(prediction());
2588     }
2589 
2590     bool shouldSpeculateInt8Array()
2591     {
2592         return isInt8ArraySpeculation(prediction());
2593     }
2594 
2595     bool shouldSpeculateInt16Array()
2596     {
2597         return isInt16ArraySpeculation(prediction());
2598     }
2599 
2600     bool shouldSpeculateInt32Array()
2601     {
2602         return isInt32ArraySpeculation(prediction());
2603     }
2604 
2605     bool shouldSpeculateUint8Array()
2606     {
2607         return isUint8ArraySpeculation(prediction());
2608     }
2609 
2610     bool shouldSpeculateUint8ClampedArray()
2611     {
2612         return isUint8ClampedArraySpeculation(prediction());
2613     }
2614 
2615     bool shouldSpeculateUint16Array()
2616     {
2617         return isUint16ArraySpeculation(prediction());
2618     }
2619 
2620     bool shouldSpeculateUint32Array()
2621     {
2622         return isUint32ArraySpeculation(prediction());
2623     }
2624 
2625     bool shouldSpeculateFloat32Array()
2626     {
2627         return isFloat32ArraySpeculation(prediction());
2628     }
2629 
2630     bool shouldSpeculateFloat64Array()
2631     {
2632         return isFloat64ArraySpeculation(prediction());
2633     }
2634 
2635     bool shouldSpeculateArrayOrOther()
2636     {
2637         return isArrayOrOtherSpeculation(prediction());
2638     }
2639 
2640     bool shouldSpeculateObject()
2641     {
2642         return isObjectSpeculation(prediction());
2643     }
2644 
2645     bool shouldSpeculateObjectOrOther()
2646     {
2647         return isObjectOrOtherSpeculation(prediction());
2648     }
2649 
2650     bool shouldSpeculateCell()
2651     {
2652         return isCellSpeculation(prediction());
2653     }
2654 
2655     bool shouldSpeculateCellOrOther()
2656     {
2657         return isCellOrOtherSpeculation(prediction());
2658     }
2659 
2660     bool shouldSpeculateNotCell()
2661     {
2662         return isNotCellSpeculation(prediction());
2663     }
2664 
2665     bool shouldSpeculateUntypedForArithmetic()
2666     {
2667         return isUntypedSpeculationForArithmetic(prediction());
2668     }
2669 
2670     static bool shouldSpeculateUntypedForArithmetic(Node* op1, Node* op2)
2671     {
2672         return op1-&gt;shouldSpeculateUntypedForArithmetic() || op2-&gt;shouldSpeculateUntypedForArithmetic();
2673     }
2674 
2675     bool shouldSpeculateUntypedForBitOps()
2676     {
2677         return isUntypedSpeculationForBitOps(prediction());
2678     }
2679 
2680     static bool shouldSpeculateUntypedForBitOps(Node* op1, Node* op2)
2681     {
2682         return op1-&gt;shouldSpeculateUntypedForBitOps() || op2-&gt;shouldSpeculateUntypedForBitOps();
2683     }
2684 
2685     static bool shouldSpeculateBoolean(Node* op1, Node* op2)
2686     {
2687         return op1-&gt;shouldSpeculateBoolean() &amp;&amp; op2-&gt;shouldSpeculateBoolean();
2688     }
2689 
2690     static bool shouldSpeculateInt32(Node* op1, Node* op2)
2691     {
2692         return op1-&gt;shouldSpeculateInt32() &amp;&amp; op2-&gt;shouldSpeculateInt32();
2693     }
2694 
2695     static bool shouldSpeculateInt32OrBoolean(Node* op1, Node* op2)
2696     {
2697         return op1-&gt;shouldSpeculateInt32OrBoolean()
2698             &amp;&amp; op2-&gt;shouldSpeculateInt32OrBoolean();
2699     }
2700 
2701     static bool shouldSpeculateInt32OrBooleanForArithmetic(Node* op1, Node* op2)
2702     {
2703         return op1-&gt;shouldSpeculateInt32OrBooleanForArithmetic()
2704             &amp;&amp; op2-&gt;shouldSpeculateInt32OrBooleanForArithmetic();
2705     }
2706 
2707     static bool shouldSpeculateInt32OrBooleanExpectingDefined(Node* op1, Node* op2)
2708     {
2709         return op1-&gt;shouldSpeculateInt32OrBooleanExpectingDefined()
2710             &amp;&amp; op2-&gt;shouldSpeculateInt32OrBooleanExpectingDefined();
2711     }
2712 
2713     static bool shouldSpeculateInt52(Node* op1, Node* op2)
2714     {
2715         return enableInt52() &amp;&amp; op1-&gt;shouldSpeculateInt52() &amp;&amp; op2-&gt;shouldSpeculateInt52();
2716     }
2717 
2718     static bool shouldSpeculateNumber(Node* op1, Node* op2)
2719     {
2720         return op1-&gt;shouldSpeculateNumber() &amp;&amp; op2-&gt;shouldSpeculateNumber();
2721     }
2722 
2723     static bool shouldSpeculateNumberOrBoolean(Node* op1, Node* op2)
2724     {
2725         return op1-&gt;shouldSpeculateNumberOrBoolean()
2726             &amp;&amp; op2-&gt;shouldSpeculateNumberOrBoolean();
2727     }
2728 
2729     static bool shouldSpeculateNumberOrBooleanExpectingDefined(Node* op1, Node* op2)
2730     {
2731         return op1-&gt;shouldSpeculateNumberOrBooleanExpectingDefined()
2732             &amp;&amp; op2-&gt;shouldSpeculateNumberOrBooleanExpectingDefined();
2733     }
2734 
2735     static bool shouldSpeculateSymbol(Node* op1, Node* op2)
2736     {
2737         return op1-&gt;shouldSpeculateSymbol() &amp;&amp; op2-&gt;shouldSpeculateSymbol();
2738     }
2739 
2740     static bool shouldSpeculateBigInt(Node* op1, Node* op2)
2741     {
2742         return op1-&gt;shouldSpeculateBigInt() &amp;&amp; op2-&gt;shouldSpeculateBigInt();
2743     }
2744 
2745     static bool shouldSpeculateFinalObject(Node* op1, Node* op2)
2746     {
2747         return op1-&gt;shouldSpeculateFinalObject() &amp;&amp; op2-&gt;shouldSpeculateFinalObject();
2748     }
2749 
2750     static bool shouldSpeculateArray(Node* op1, Node* op2)
2751     {
2752         return op1-&gt;shouldSpeculateArray() &amp;&amp; op2-&gt;shouldSpeculateArray();
2753     }
2754 
2755     bool canSpeculateInt32(RareCaseProfilingSource source)
2756     {
2757         return nodeCanSpeculateInt32(arithNodeFlags(), source);
2758     }
2759 
2760     bool canSpeculateInt52(RareCaseProfilingSource source)
2761     {
2762         return nodeCanSpeculateInt52(arithNodeFlags(), source);
2763     }
2764 
2765     RareCaseProfilingSource sourceFor(PredictionPass pass)
2766     {
2767         if (pass == PrimaryPass || child1()-&gt;sawBooleans() || (child2() &amp;&amp; child2()-&gt;sawBooleans()))
2768             return DFGRareCase;
2769         return AllRareCases;
2770     }
2771 
2772     bool canSpeculateInt32(PredictionPass pass)
2773     {
2774         return canSpeculateInt32(sourceFor(pass));
2775     }
2776 
2777     bool canSpeculateInt52(PredictionPass pass)
2778     {
2779         return canSpeculateInt52(sourceFor(pass));
2780     }
2781 
2782     bool hasTypeLocation()
2783     {
2784         return op() == ProfileType;
2785     }
2786 
2787     TypeLocation* typeLocation()
2788     {
2789         ASSERT(hasTypeLocation());
2790         return m_opInfo.as&lt;TypeLocation*&gt;();
2791     }
2792 
2793     bool hasBasicBlockLocation()
2794     {
2795         return op() == ProfileControlFlow;
2796     }
2797 
2798     BasicBlockLocation* basicBlockLocation()
2799     {
2800         ASSERT(hasBasicBlockLocation());
2801         return m_opInfo.as&lt;BasicBlockLocation*&gt;();
2802     }
2803 
2804     bool hasCallDOMGetterData() const
2805     {
2806         return op() == CallDOMGetter;
2807     }
2808 
2809     CallDOMGetterData* callDOMGetterData()
2810     {
2811         ASSERT(hasCallDOMGetterData());
2812         return m_opInfo.as&lt;CallDOMGetterData*&gt;();
2813     }
2814 
2815     bool hasClassInfo() const
2816     {
2817         return op() == CheckSubClass;
2818     }
2819 
2820     const ClassInfo* classInfo()
2821     {
2822         return m_opInfo.as&lt;const ClassInfo*&gt;();
2823     }
2824 
2825     bool hasSignature() const
2826     {
2827         // Note that this does not include TailCall node types intentionally.
2828         // CallDOM node types are always converted from Call.
2829         return op() == Call || op() == CallDOM;
2830     }
2831 
2832     const DOMJIT::Signature* signature()
2833     {
2834         return m_opInfo.as&lt;const DOMJIT::Signature*&gt;();
2835     }
2836 
2837     bool hasInternalMethodType() const
2838     {
2839         return op() == HasIndexedProperty;
2840     }
2841 
2842     PropertySlot::InternalMethodType internalMethodType() const
2843     {
2844         ASSERT(hasInternalMethodType());
2845         return static_cast&lt;PropertySlot::InternalMethodType&gt;(m_opInfo2.as&lt;uint32_t&gt;());
2846     }
2847 
2848     void setInternalMethodType(PropertySlot::InternalMethodType type)
2849     {
2850         ASSERT(hasInternalMethodType());
2851         m_opInfo2 = static_cast&lt;uint32_t&gt;(type);
2852     }
2853 
2854     Node* replacement() const
2855     {
2856         return m_misc.replacement;
2857     }
2858 
2859     void setReplacement(Node* replacement)
2860     {
2861         m_misc.replacement = replacement;
2862     }
2863 
2864     Epoch epoch() const
2865     {
2866         return Epoch::fromUnsigned(m_misc.epoch);
2867     }
2868 
2869     void setEpoch(Epoch epoch)
2870     {
2871         m_misc.epoch = epoch.toUnsigned();
2872     }
2873 
2874     bool hasNumberOfArgumentsToSkip()
2875     {
2876         return op() == CreateRest || op() == PhantomCreateRest || op() == GetRestLength || op() == GetMyArgumentByVal || op() == GetMyArgumentByValOutOfBounds;
2877     }
2878 
2879     unsigned numberOfArgumentsToSkip()
2880     {
2881         ASSERT(hasNumberOfArgumentsToSkip());
2882         return m_opInfo.as&lt;unsigned&gt;();
2883     }
2884 
2885     bool hasArgumentIndex()
2886     {
2887         return op() == GetArgument;
2888     }
2889 
2890     unsigned argumentIndex()
2891     {
2892         ASSERT(hasArgumentIndex());
2893         return m_opInfo.as&lt;unsigned&gt;();
2894     }
2895 
2896     bool hasBucketOwnerType()
2897     {
2898         return op() == GetMapBucketNext || op() == LoadKeyFromMapBucket || op() == LoadValueFromMapBucket;
2899     }
2900 
2901     BucketOwnerType bucketOwnerType()
2902     {
2903         ASSERT(hasBucketOwnerType());
2904         return m_opInfo.as&lt;BucketOwnerType&gt;();
2905     }
2906 
2907     bool hasValidRadixConstant()
2908     {
2909         return op() == NumberToStringWithValidRadixConstant;
2910     }
2911 
2912     int32_t validRadixConstant()
2913     {
2914         ASSERT(hasValidRadixConstant());
2915         return m_opInfo.as&lt;int32_t&gt;();
2916     }
2917 
2918     bool hasIgnoreLastIndexIsWritable()
2919     {
2920         return op() == SetRegExpObjectLastIndex;
2921     }
2922 
2923     bool ignoreLastIndexIsWritable()
2924     {
2925         ASSERT(hasIgnoreLastIndexIsWritable());
2926         return m_opInfo.as&lt;uint32_t&gt;();
2927     }
2928 
2929     uint32_t errorType()
2930     {
2931         ASSERT(op() == ThrowStaticError);
2932         return m_opInfo.as&lt;uint32_t&gt;();
2933     }
2934 
2935     bool hasCallLinkStatus()
2936     {
2937         return op() == FilterCallLinkStatus;
2938     }
2939 
2940     CallLinkStatus* callLinkStatus()
2941     {
2942         ASSERT(hasCallLinkStatus());
2943         return m_opInfo.as&lt;CallLinkStatus*&gt;();
2944     }
2945 
2946     bool hasGetByStatus()
2947     {
2948         return op() == FilterGetByStatus;
2949     }
2950 
2951     GetByStatus* getByStatus()
2952     {
2953         ASSERT(hasGetByStatus());
2954         return m_opInfo.as&lt;GetByStatus*&gt;();
2955     }
2956 
2957     bool hasInByIdStatus()
2958     {
2959         return op() == FilterInByIdStatus;
2960     }
2961 
2962     InByIdStatus* inByIdStatus()
2963     {
2964         ASSERT(hasInByIdStatus());
2965         return m_opInfo.as&lt;InByIdStatus*&gt;();
2966     }
2967 
2968     bool hasPutByIdStatus()
2969     {
2970         return op() == FilterPutByIdStatus;
2971     }
2972 
2973     PutByIdStatus* putByIdStatus()
2974     {
2975         ASSERT(hasPutByIdStatus());
2976         return m_opInfo.as&lt;PutByIdStatus*&gt;();
2977     }
2978 
2979     void dumpChildren(PrintStream&amp; out)
2980     {
2981         if (!child1())
2982             return;
2983         out.printf(&quot;@%u&quot;, child1()-&gt;index());
2984         if (!child2())
2985             return;
2986         out.printf(&quot;, @%u&quot;, child2()-&gt;index());
2987         if (!child3())
2988             return;
2989         out.printf(&quot;, @%u&quot;, child3()-&gt;index());
2990     }
2991 
2992     NodeOrigin origin;
2993 
2994     // References to up to 3 children, or links to a variable length set of children.
2995     AdjacencyList children;
2996 
2997 private:
2998     friend class B3::SparseCollection&lt;Node&gt;;
2999 
3000     unsigned m_index { std::numeric_limits&lt;unsigned&gt;::max() };
3001     unsigned m_op : 10; // real type is NodeType
3002     unsigned m_flags : 21;
3003     // The virtual register number (spill location) associated with this .
3004     VirtualRegister m_virtualRegister;
3005     // The number of uses of the result of this operation (+1 for &#39;must generate&#39; nodes, which have side-effects).
3006     unsigned m_refCount;
3007     // The prediction ascribed to this node after propagation.
3008     SpeculatedType m_prediction { SpecNone };
3009     // Immediate values, accesses type-checked via accessors above.
3010     struct OpInfoWrapper {
3011         OpInfoWrapper()
3012         {
3013             u.int64 = 0;
3014         }
3015         OpInfoWrapper(uint32_t intValue)
3016         {
3017             u.int64 = 0;
3018             u.int32 = intValue;
3019         }
3020         OpInfoWrapper(uint64_t intValue)
3021         {
3022             u.int64 = intValue;
3023         }
3024         OpInfoWrapper(void* pointer)
3025         {
3026             u.int64 = 0;
3027             u.pointer = pointer;
3028         }
3029         OpInfoWrapper(const void* constPointer)
3030         {
3031             u.int64 = 0;
3032             u.constPointer = constPointer;
3033         }
3034         OpInfoWrapper(RegisteredStructure structure)
3035         {
3036             u.int64 = 0;
3037             u.pointer = bitwise_cast&lt;void*&gt;(structure);
3038         }
3039         OpInfoWrapper&amp; operator=(uint32_t int32)
3040         {
3041             u.int64 = 0;
3042             u.int32 = int32;
3043             return *this;
3044         }
3045         OpInfoWrapper&amp; operator=(int32_t int32)
3046         {
3047             u.int64 = 0;
3048             u.int32 = int32;
3049             return *this;
3050         }
3051         OpInfoWrapper&amp; operator=(uint64_t int64)
3052         {
3053             u.int64 = int64;
3054             return *this;
3055         }
3056         OpInfoWrapper&amp; operator=(void* pointer)
3057         {
3058             u.int64 = 0;
3059             u.pointer = pointer;
3060             return *this;
3061         }
3062         OpInfoWrapper&amp; operator=(const void* constPointer)
3063         {
3064             u.int64 = 0;
3065             u.constPointer = constPointer;
3066             return *this;
3067         }
3068         OpInfoWrapper&amp; operator=(RegisteredStructure structure)
3069         {
3070             u.int64 = 0;
3071             u.pointer = bitwise_cast&lt;void*&gt;(structure);
3072             return *this;
3073         }
3074         OpInfoWrapper&amp; operator=(NewArrayBufferData newArrayBufferData)
3075         {
3076             u.int64 = bitwise_cast&lt;uint64_t&gt;(newArrayBufferData);
3077             return *this;
3078         }
3079         template &lt;typename T&gt;
3080         ALWAYS_INLINE auto as() const -&gt; typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value &amp;&amp; !std::is_const&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::value, T&gt;::type
3081         {
3082             return static_cast&lt;T&gt;(u.pointer);
3083         }
3084         template &lt;typename T&gt;
3085         ALWAYS_INLINE auto as() const -&gt; typename std::enable_if&lt;std::is_pointer&lt;T&gt;::value &amp;&amp; std::is_const&lt;typename std::remove_pointer&lt;T&gt;::type&gt;::value, T&gt;::type
3086         {
3087             return static_cast&lt;T&gt;(u.constPointer);
3088         }
3089         template &lt;typename T&gt;
3090         ALWAYS_INLINE auto as() const -&gt; typename std::enable_if&lt;(std::is_integral&lt;T&gt;::value || std::is_enum&lt;T&gt;::value) &amp;&amp; sizeof(T) &lt;= 4, T&gt;::type
3091         {
3092             return static_cast&lt;T&gt;(u.int32);
3093         }
3094         template &lt;typename T&gt;
3095         ALWAYS_INLINE auto as() const -&gt; typename std::enable_if&lt;(std::is_integral&lt;T&gt;::value || std::is_enum&lt;T&gt;::value) &amp;&amp; sizeof(T) == 8, T&gt;::type
3096         {
3097             return static_cast&lt;T&gt;(u.int64);
3098         }
3099         ALWAYS_INLINE RegisteredStructure asRegisteredStructure() const
3100         {
3101             return bitwise_cast&lt;RegisteredStructure&gt;(u.pointer);
3102         }
3103         ALWAYS_INLINE NewArrayBufferData asNewArrayBufferData() const
3104         {
3105             return bitwise_cast&lt;NewArrayBufferData&gt;(u.int64);
3106         }
3107 
3108         union {
3109             uint32_t int32;
3110             uint64_t int64;
3111             void* pointer;
3112             const void* constPointer;
3113         } u;
3114     };
3115     OpInfoWrapper m_opInfo;
3116     OpInfoWrapper m_opInfo2;
3117 
3118     // Miscellaneous data that is usually meaningless, but can hold some analysis results
3119     // if you ask right. For example, if you do Graph::initializeNodeOwners(), Node::owner
3120     // will tell you which basic block a node belongs to. You cannot rely on this persisting
3121     // across transformations unless you do the maintenance work yourself. Other phases use
3122     // Node::replacement, but they do so manually: first you do Graph::clearReplacements()
3123     // and then you set, and use, replacement&#39;s yourself. Same thing for epoch.
3124     //
3125     // Bottom line: don&#39;t use these fields unless you initialize them yourself, or by
3126     // calling some appropriate methods that initialize them the way you want. Otherwise,
3127     // these fields are meaningless.
3128 private:
3129     union {
3130         Node* replacement;
3131         unsigned epoch;
3132     } m_misc;
3133 public:
3134     BasicBlock* owner;
3135 };
3136 
3137 // Uncomment this to log NodeSet operations.
3138 // typedef LoggingHashSet&lt;Node::HashSetTemplateInstantiationString, Node*&gt; NodeSet;
3139 typedef HashSet&lt;Node*&gt; NodeSet;
3140 
3141 struct NodeComparator {
3142     template&lt;typename NodePtrType&gt;
3143     bool operator()(NodePtrType a, NodePtrType b) const
3144     {
3145         return a-&gt;index() &lt; b-&gt;index();
3146     }
3147 };
3148 
3149 template&lt;typename T&gt;
3150 CString nodeListDump(const T&amp; nodeList)
3151 {
3152     return sortedListDump(nodeList, NodeComparator());
3153 }
3154 
3155 template&lt;typename T&gt;
3156 CString nodeMapDump(const T&amp; nodeMap, DumpContext* context = 0)
3157 {
3158     Vector&lt;typename T::KeyType&gt; keys;
3159     for (
3160         typename T::const_iterator iter = nodeMap.begin();
3161         iter != nodeMap.end(); ++iter)
3162         keys.append(iter-&gt;key);
3163     std::sort(keys.begin(), keys.end(), NodeComparator());
3164     StringPrintStream out;
3165     CommaPrinter comma;
3166     for(unsigned i = 0; i &lt; keys.size(); ++i)
3167         out.print(comma, keys[i], &quot;=&gt;&quot;, inContext(nodeMap.get(keys[i]), context));
3168     return out.toCString();
3169 }
3170 
3171 template&lt;typename T&gt;
3172 CString nodeValuePairListDump(const T&amp; nodeValuePairList, DumpContext* context = 0)
3173 {
3174     using V = typename T::ValueType;
3175     T sortedList = nodeValuePairList;
3176     std::sort(sortedList.begin(), sortedList.end(), [](const V&amp; a, const V&amp; b) {
3177         return NodeComparator()(a.node, b.node);
3178     });
3179 
3180     StringPrintStream out;
3181     CommaPrinter comma;
3182     for (const auto&amp; pair : sortedList)
3183         out.print(comma, pair.node, &quot;=&gt;&quot;, inContext(pair.value, context));
3184     return out.toCString();
3185 }
3186 
3187 } } // namespace JSC::DFG
3188 
3189 namespace WTF {
3190 
3191 void printInternal(PrintStream&amp;, JSC::DFG::SwitchKind);
3192 void printInternal(PrintStream&amp;, JSC::DFG::Node*);
3193 
3194 inline JSC::DFG::Node* inContext(JSC::DFG::Node* node, JSC::DumpContext*) { return node; }
3195 
3196 template&lt;&gt;
3197 struct LoggingHashKeyTraits&lt;JSC::DFG::Node*&gt; {
3198     static void print(PrintStream&amp; out, JSC::DFG::Node* key)
3199     {
3200         out.print(&quot;bitwise_cast&lt;::JSC::DFG::Node*&gt;(&quot;, RawPointer(key), &quot;lu)&quot;);
3201     }
3202 };
3203 
3204 } // namespace WTF
3205 
3206 using WTF::inContext;
3207 
3208 #endif
    </pre>
  </body>
</html>
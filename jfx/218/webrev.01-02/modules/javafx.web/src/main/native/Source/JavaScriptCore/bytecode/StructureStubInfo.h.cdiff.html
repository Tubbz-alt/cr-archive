<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/StructureStubInfo.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StructureStubInfo.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SuperSampler.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/StructureStubInfo.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2008-2018 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2008-2020 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 23,10 ***</span>
<span class="line-new-header">--- 23,11 ---</span>
   * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
   */
  
  #pragma once
  
<span class="line-added">+ #include &quot;CacheableIdentifier.h&quot;</span>
  #include &quot;CodeBlock.h&quot;
  #include &quot;CodeOrigin.h&quot;
  #include &quot;Instruction.h&quot;
  #include &quot;JITStubRoutine.h&quot;
  #include &quot;MacroAssembler.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 34,24 ***</span>
  #include &quot;RegisterSet.h&quot;
  #include &quot;Structure.h&quot;
  #include &quot;StructureSet.h&quot;
  #include &quot;StructureStubClearingWatchpoint.h&quot;
  #include &quot;StubInfoSummary.h&quot;
  
  namespace JSC {
  
  #if ENABLE(JIT)
  
  class AccessCase;
  class AccessGenerationResult;
  class PolymorphicAccess;
  
  enum class AccessType : int8_t {
<span class="line-modified">!     Get,</span>
<span class="line-modified">!     GetWithThis,</span>
<span class="line-modified">!     GetDirect,</span>
<span class="line-modified">!     TryGet,</span>
      Put,
      In,
      InstanceOf
  };
  
<span class="line-new-header">--- 35,26 ---</span>
  #include &quot;RegisterSet.h&quot;
  #include &quot;Structure.h&quot;
  #include &quot;StructureSet.h&quot;
  #include &quot;StructureStubClearingWatchpoint.h&quot;
  #include &quot;StubInfoSummary.h&quot;
<span class="line-added">+ #include &lt;wtf/Box.h&gt;</span>
  
  namespace JSC {
  
  #if ENABLE(JIT)
  
  class AccessCase;
  class AccessGenerationResult;
  class PolymorphicAccess;
  
  enum class AccessType : int8_t {
<span class="line-modified">!     GetById,</span>
<span class="line-modified">!     GetByIdWithThis,</span>
<span class="line-modified">!     GetByIdDirect,</span>
<span class="line-modified">!     TryGetById,</span>
<span class="line-added">+     GetByVal,</span>
      Put,
      In,
      InstanceOf
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,31 ***</span>
      WTF_MAKE_FAST_ALLOCATED;
  public:
      StructureStubInfo(AccessType);
      ~StructureStubInfo();
  
<span class="line-modified">!     void initGetByIdSelf(CodeBlock*, Structure* baseObjectStructure, PropertyOffset);</span>
      void initArrayLength();
      void initStringLength();
      void initPutByIdReplace(CodeBlock*, Structure* baseObjectStructure, PropertyOffset);
      void initInByIdSelf(CodeBlock*, Structure* baseObjectStructure, PropertyOffset);
  
<span class="line-modified">!     AccessGenerationResult addAccessCase(const GCSafeConcurrentJSLocker&amp;, CodeBlock*, const Identifier&amp;, std::unique_ptr&lt;AccessCase&gt;);</span>
  
      void reset(CodeBlock*);
  
      void deref();
      void aboutToDie();
  
      // Check if the stub has weak references that are dead. If it does, then it resets itself,
      // either entirely or just enough to ensure that those dead pointers don&#39;t get used anymore.
      void visitWeakReferences(CodeBlock*);
  
      // This returns true if it has marked everything that it will ever mark.
      bool propagateTransitions(SlotVisitor&amp;);
  
<span class="line-modified">!     ALWAYS_INLINE bool considerCaching(VM&amp; vm, CodeBlock* codeBlock, Structure* structure)</span>
      {
          DisallowGC disallowGC;
  
          // We never cache non-cells.
          if (!structure) {
<span class="line-new-header">--- 73,33 ---</span>
      WTF_MAKE_FAST_ALLOCATED;
  public:
      StructureStubInfo(AccessType);
      ~StructureStubInfo();
  
<span class="line-modified">!     void initGetByIdSelf(CodeBlock*, Structure* baseObjectStructure, PropertyOffset, CacheableIdentifier);</span>
      void initArrayLength();
      void initStringLength();
      void initPutByIdReplace(CodeBlock*, Structure* baseObjectStructure, PropertyOffset);
      void initInByIdSelf(CodeBlock*, Structure* baseObjectStructure, PropertyOffset);
  
<span class="line-modified">!     AccessGenerationResult addAccessCase(const GCSafeConcurrentJSLocker&amp;, CodeBlock*, CacheableIdentifier, std::unique_ptr&lt;AccessCase&gt;);</span>
  
      void reset(CodeBlock*);
  
      void deref();
      void aboutToDie();
  
<span class="line-added">+     void visitAggregate(SlotVisitor&amp;);</span>
<span class="line-added">+ </span>
      // Check if the stub has weak references that are dead. If it does, then it resets itself,
      // either entirely or just enough to ensure that those dead pointers don&#39;t get used anymore.
      void visitWeakReferences(CodeBlock*);
  
      // This returns true if it has marked everything that it will ever mark.
      bool propagateTransitions(SlotVisitor&amp;);
  
<span class="line-modified">!     ALWAYS_INLINE bool considerCaching(VM&amp; vm, CodeBlock* codeBlock, Structure* structure, UniquedStringImpl* impl = nullptr)</span>
      {
          DisallowGC disallowGC;
  
          // We never cache non-cells.
          if (!structure) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 150,136 ***</span>
              // immediately generating code for it.
              //
              // NOTE: This will behave oddly for InstanceOf if the user varies the prototype but not
              // the base&#39;s structure. That seems unlikely for the canonical use of instanceof, where
              // the prototype is fixed.
<span class="line-modified">!             bool isNewlyAdded = bufferedStructures.add(structure);</span>
              if (isNewlyAdded)
                  vm.heap.writeBarrier(codeBlock);
              return isNewlyAdded;
          }
          countdown--;
          return false;
      }
  
<span class="line-modified">!     StubInfoSummary summary() const;</span>
  
<span class="line-modified">!     static StubInfoSummary summary(const StructureStubInfo*);</span>
  
      bool containsPC(void* pc) const;
  
      CodeOrigin codeOrigin;
<span class="line-modified">!     CallSiteIndex callSiteIndex;</span>
  
      union {
          struct {
              WriteBarrierBase&lt;Structure&gt; baseObjectStructure;
              PropertyOffset offset;
          } byIdSelf;
          PolymorphicAccess* stub;
      } u;
  
      // Represents those structures that already have buffered AccessCases in the PolymorphicAccess.
      // Note that it&#39;s always safe to clear this. If we clear it prematurely, then if we see the same
      // structure again during this buffering countdown, we will create an AccessCase object for it.
      // That&#39;s not so bad - we&#39;ll get rid of the redundant ones once we regenerate.
<span class="line-modified">!     StructureSet bufferedStructures;</span>
  
<span class="line-modified">!     struct {</span>
<span class="line-modified">!         CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; start; // This is either the start of the inline IC for *byId caches. or the location of patchable jump for &#39;instanceof&#39; caches.</span>
<span class="line-modified">!         CodeLocationLabel&lt;JSInternalPtrTag&gt; doneLocation;</span>
<span class="line-modified">!         CodeLocationCall&lt;JSInternalPtrTag&gt; slowPathCallLocation;</span>
<span class="line-removed">-         CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; slowPathStartLocation;</span>
  
<span class="line-modified">!         RegisterSet usedRegisters;</span>
  
<span class="line-modified">!         uint32_t inlineSize() const</span>
<span class="line-modified">!         {</span>
<span class="line-modified">!             int32_t inlineSize = MacroAssembler::differenceBetweenCodePtr(start, doneLocation);</span>
<span class="line-modified">!             ASSERT(inlineSize &gt;= 0);</span>
<span class="line-modified">!             return inlineSize;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         GPRReg baseGPR;</span>
<span class="line-modified">!         GPRReg valueGPR;</span>
          GPRReg thisGPR;
  #if USE(JSVALUE32_64)
<span class="line-modified">!         GPRReg valueTagGPR;</span>
<span class="line-modified">!         GPRReg baseTagGPR;</span>
          GPRReg thisTagGPR;
  #endif
<span class="line-removed">-     } patch;</span>
  
<span class="line-modified">!     GPRReg baseGPR() const</span>
      {
<span class="line-modified">!         return patch.baseGPR;</span>
      }
  
<span class="line-modified">!     CodeLocationCall&lt;JSInternalPtrTag&gt; slowPathCallLocation() { return patch.slowPathCallLocation; }</span>
<span class="line-modified">!     CodeLocationLabel&lt;JSInternalPtrTag&gt; doneLocation() { return patch.doneLocation; }</span>
<span class="line-modified">!     CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; slowPathStartLocation() { return patch.slowPathStartLocation; }</span>
  
<span class="line-modified">!     CodeLocationJump&lt;JSInternalPtrTag&gt; patchableJump()</span>
      {
<span class="line-modified">!         ASSERT(accessType == AccessType::InstanceOf);</span>
<span class="line-modified">!         return patch.start.jumpAtOffset&lt;JSInternalPtrTag&gt;(0);</span>
      }
  
<span class="line-modified">!     JSValueRegs valueRegs() const</span>
      {
          return JSValueRegs(
  #if USE(JSVALUE32_64)
<span class="line-modified">!             patch.valueTagGPR,</span>
  #endif
<span class="line-modified">!             patch.valueGPR);</span>
      }
  
  
      AccessType accessType;
<span class="line-modified">!     CacheType cacheType;</span>
      uint8_t countdown; // We repatch only when this is zero. If not zero, we decrement.
      uint8_t repatchCount;
      uint8_t numberOfCoolDowns;
      uint8_t bufferingCountdown;
      bool resetByGC : 1;
      bool tookSlowPath : 1;
      bool everConsidered : 1;
      bool prototypeIsKnownObject : 1; // Only relevant for InstanceOf.
      bool sawNonCell : 1;
  };
  
  inline CodeOrigin getStructureStubInfoCodeOrigin(StructureStubInfo&amp; structureStubInfo)
  {
      return structureStubInfo.codeOrigin;
  }
  
<span class="line-modified">! inline J_JITOperation_ESsiJI appropriateOptimizingGetByIdFunction(AccessType type)</span>
  {
      switch (type) {
<span class="line-modified">!     case AccessType::Get:</span>
          return operationGetByIdOptimize;
<span class="line-modified">!     case AccessType::TryGet:</span>
          return operationTryGetByIdOptimize;
<span class="line-modified">!     case AccessType::GetDirect:</span>
          return operationGetByIdDirectOptimize;
<span class="line-modified">!     case AccessType::GetWithThis:</span>
      default:
          ASSERT_NOT_REACHED();
          return nullptr;
      }
  }
  
<span class="line-modified">! inline J_JITOperation_EJI appropriateGenericGetByIdFunction(AccessType type)</span>
  {
      switch (type) {
<span class="line-modified">!     case AccessType::Get:</span>
          return operationGetByIdGeneric;
<span class="line-modified">!     case AccessType::TryGet:</span>
          return operationTryGetByIdGeneric;
<span class="line-modified">!     case AccessType::GetDirect:</span>
          return operationGetByIdDirectGeneric;
<span class="line-modified">!     case AccessType::GetWithThis:</span>
      default:
          ASSERT_NOT_REACHED();
          return nullptr;
      }
  }
<span class="line-new-header">--- 155,180 ---</span>
              // immediately generating code for it.
              //
              // NOTE: This will behave oddly for InstanceOf if the user varies the prototype but not
              // the base&#39;s structure. That seems unlikely for the canonical use of instanceof, where
              // the prototype is fixed.
<span class="line-modified">!             bool isNewlyAdded = bufferedStructures.add({ structure, impl }).isNewEntry;</span>
              if (isNewlyAdded)
                  vm.heap.writeBarrier(codeBlock);
              return isNewlyAdded;
          }
          countdown--;
          return false;
      }
  
<span class="line-modified">!     StubInfoSummary summary(VM&amp;) const;</span>
  
<span class="line-modified">!     static StubInfoSummary summary(VM&amp;, const StructureStubInfo*);</span>
  
      bool containsPC(void* pc) const;
  
      CodeOrigin codeOrigin;
<span class="line-modified">! private:</span>
<span class="line-added">+     CacheableIdentifier m_getByIdSelfIdentifier;</span>
<span class="line-added">+ public:</span>
  
      union {
          struct {
              WriteBarrierBase&lt;Structure&gt; baseObjectStructure;
              PropertyOffset offset;
          } byIdSelf;
          PolymorphicAccess* stub;
      } u;
  
<span class="line-added">+     CacheableIdentifier getByIdSelfIdentifier()</span>
<span class="line-added">+     {</span>
<span class="line-added">+         RELEASE_ASSERT(m_cacheType == CacheType::GetByIdSelf);</span>
<span class="line-added">+         return m_getByIdSelfIdentifier;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ private:</span>
      // Represents those structures that already have buffered AccessCases in the PolymorphicAccess.
      // Note that it&#39;s always safe to clear this. If we clear it prematurely, then if we see the same
      // structure again during this buffering countdown, we will create an AccessCase object for it.
      // That&#39;s not so bad - we&#39;ll get rid of the redundant ones once we regenerate.
<span class="line-modified">!     HashSet&lt;std::pair&lt;Structure*, RefPtr&lt;UniquedStringImpl&gt;&gt;&gt; bufferedStructures;</span>
<span class="line-added">+ public:</span>
  
<span class="line-modified">!     CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; start; // This is either the start of the inline IC for *byId caches. or the location of patchable jump for &#39;instanceof&#39; caches.</span>
<span class="line-modified">!     CodeLocationLabel&lt;JSInternalPtrTag&gt; doneLocation;</span>
<span class="line-modified">!     CodeLocationCall&lt;JSInternalPtrTag&gt; slowPathCallLocation;</span>
<span class="line-modified">!     CodeLocationLabel&lt;JITStubRoutinePtrTag&gt; slowPathStartLocation;</span>
  
<span class="line-modified">!     RegisterSet usedRegisters;</span>
  
<span class="line-modified">!     uint32_t inlineSize() const</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         int32_t inlineSize = MacroAssembler::differenceBetweenCodePtr(start, doneLocation);</span>
<span class="line-modified">!         ASSERT(inlineSize &gt;= 0);</span>
<span class="line-modified">!         return inlineSize;</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     GPRReg baseGPR;</span>
<span class="line-modified">!     GPRReg valueGPR;</span>
<span class="line-added">+     union {</span>
          GPRReg thisGPR;
<span class="line-added">+         GPRReg prototypeGPR;</span>
<span class="line-added">+         GPRReg propertyGPR;</span>
<span class="line-added">+     } regs;</span>
  #if USE(JSVALUE32_64)
<span class="line-modified">!     GPRReg valueTagGPR;</span>
<span class="line-modified">!     // FIXME: [32-bits] Check if StructureStubInfo::baseTagGPR is used somewhere.</span>
<span class="line-added">+     // https://bugs.webkit.org/show_bug.cgi?id=204726</span>
<span class="line-added">+     GPRReg baseTagGPR;</span>
<span class="line-added">+     union {</span>
          GPRReg thisTagGPR;
<span class="line-added">+         GPRReg propertyTagGPR;</span>
<span class="line-added">+     } v;</span>
  #endif
  
<span class="line-modified">!     CodeLocationJump&lt;JSInternalPtrTag&gt; patchableJump()</span>
      {
<span class="line-modified">!         ASSERT(accessType == AccessType::InstanceOf);</span>
<span class="line-added">+         return start.jumpAtOffset&lt;JSInternalPtrTag&gt;(0);</span>
      }
  
<span class="line-modified">!     JSValueRegs valueRegs() const</span>
<span class="line-modified">!     {</span>
<span class="line-modified">!         return JSValueRegs(</span>
<span class="line-added">+ #if USE(JSVALUE32_64)</span>
<span class="line-added">+             valueTagGPR,</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+             valueGPR);</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     JSValueRegs propertyRegs() const</span>
      {
<span class="line-modified">!         return JSValueRegs(</span>
<span class="line-modified">! #if USE(JSVALUE32_64)</span>
<span class="line-added">+             v.propertyTagGPR,</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+             regs.propertyGPR);</span>
      }
  
<span class="line-modified">!     JSValueRegs baseRegs() const</span>
      {
          return JSValueRegs(
  #if USE(JSVALUE32_64)
<span class="line-modified">!             baseTagGPR,</span>
  #endif
<span class="line-modified">!             baseGPR);</span>
      }
  
<span class="line-added">+     bool thisValueIsInThisGPR() const { return accessType == AccessType::GetByIdWithThis; }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #if ASSERT_ENABLED</span>
<span class="line-added">+     void checkConsistency();</span>
<span class="line-added">+ #else</span>
<span class="line-added">+     ALWAYS_INLINE void checkConsistency() { }</span>
<span class="line-added">+ #endif</span>
  
      AccessType accessType;
<span class="line-modified">! private:</span>
<span class="line-added">+     CacheType m_cacheType;</span>
<span class="line-added">+     void setCacheType(CacheType);</span>
<span class="line-added">+ public:</span>
<span class="line-added">+     CacheType cacheType() const { return m_cacheType; }</span>
      uint8_t countdown; // We repatch only when this is zero. If not zero, we decrement.
      uint8_t repatchCount;
      uint8_t numberOfCoolDowns;
<span class="line-added">+ </span>
<span class="line-added">+     CallSiteIndex callSiteIndex;</span>
<span class="line-added">+ </span>
      uint8_t bufferingCountdown;
      bool resetByGC : 1;
      bool tookSlowPath : 1;
      bool everConsidered : 1;
      bool prototypeIsKnownObject : 1; // Only relevant for InstanceOf.
      bool sawNonCell : 1;
<span class="line-added">+     bool hasConstantIdentifier : 1;</span>
<span class="line-added">+     bool propertyIsString : 1;</span>
<span class="line-added">+     bool propertyIsInt32 : 1;</span>
<span class="line-added">+     bool propertyIsSymbol : 1;</span>
  };
  
  inline CodeOrigin getStructureStubInfoCodeOrigin(StructureStubInfo&amp; structureStubInfo)
  {
      return structureStubInfo.codeOrigin;
  }
  
<span class="line-modified">! inline auto appropriateOptimizingGetByIdFunction(AccessType type) -&gt; decltype(&amp;operationGetByIdOptimize)</span>
  {
      switch (type) {
<span class="line-modified">!     case AccessType::GetById:</span>
          return operationGetByIdOptimize;
<span class="line-modified">!     case AccessType::TryGetById:</span>
          return operationTryGetByIdOptimize;
<span class="line-modified">!     case AccessType::GetByIdDirect:</span>
          return operationGetByIdDirectOptimize;
<span class="line-modified">!     case AccessType::GetByIdWithThis:</span>
      default:
          ASSERT_NOT_REACHED();
          return nullptr;
      }
  }
  
<span class="line-modified">! inline auto appropriateGenericGetByIdFunction(AccessType type) -&gt; decltype(&amp;operationGetByIdGeneric)</span>
  {
      switch (type) {
<span class="line-modified">!     case AccessType::GetById:</span>
          return operationGetByIdGeneric;
<span class="line-modified">!     case AccessType::TryGetById:</span>
          return operationTryGetByIdGeneric;
<span class="line-modified">!     case AccessType::GetByIdDirect:</span>
          return operationGetByIdDirectGeneric;
<span class="line-modified">!     case AccessType::GetByIdWithThis:</span>
      default:
          ASSERT_NOT_REACHED();
          return nullptr;
      }
  }
</pre>
<center><a href="StructureStubInfo.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SuperSampler.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
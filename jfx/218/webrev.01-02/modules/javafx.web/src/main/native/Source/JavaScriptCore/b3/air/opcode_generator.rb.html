<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/b3/air/opcode_generator.rb</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 #!/usr/bin/env ruby
   2 
   3 # Copyright (C) 2015-2017 Apple Inc. All rights reserved.
   4 #
   5 # Redistribution and use in source and binary forms, with or without
   6 # modification, are permitted provided that the following conditions
   7 # are met:
   8 # 1. Redistributions of source code must retain the above copyright
   9 #    notice, this list of conditions and the following disclaimer.
  10 # 2. Redistributions in binary form must reproduce the above copyright
  11 #    notice, this list of conditions and the following disclaimer in the
  12 #    documentation and/or other materials provided with the distribution.
  13 #
  14 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  15 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  16 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  18 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  19 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  20 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  21 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  22 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  23 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  24 # THE POSSIBILITY OF SUCH DAMAGE.
  25 
  26 require &quot;pathname&quot;
  27 
  28 class Opcode
  29     attr_reader :name, :custom, :overloads
  30     attr_reader :attributes
  31 
  32     def initialize(name, custom)
  33         @name = name
  34         @custom = custom
  35         @attributes = {}
  36         unless custom
  37             @overloads = []
  38         end
  39     end
  40 
  41     def masmName
  42         name[0].downcase + name[1..-1]
  43     end
  44 end
  45 
  46 class Arg
  47     attr_reader :role, :bank, :width
  48 
  49     def initialize(role, bank, width)
  50         @role = role
  51         @bank = bank
  52         @width = width
  53     end
  54     
  55     def self.widthCode(width)
  56         if width == &quot;Ptr&quot;
  57             &quot;POINTER_WIDTH&quot;
  58         else
  59             &quot;Width#{width}&quot;
  60         end
  61     end
  62 
  63     def widthCode
  64         Arg.widthCode(width)
  65     end
  66     
  67     def self.roleCode(role)
  68         case role
  69         when &quot;U&quot;
  70             &quot;Use&quot;
  71         when &quot;D&quot;
  72             &quot;Def&quot;
  73         when &quot;ZD&quot;
  74             &quot;ZDef&quot;
  75         when &quot;UD&quot;
  76             &quot;UseDef&quot;
  77         when &quot;UZD&quot;
  78             &quot;UseZDef&quot;
  79         when &quot;UA&quot;
  80             &quot;UseAddr&quot;
  81         when &quot;S&quot;
  82             &quot;Scratch&quot;
  83         when &quot;ED&quot;
  84             &quot;EarlyDef&quot;
  85         when &quot;EZD&quot;
  86             &quot;EarlyZDef&quot;
  87         when &quot;LU&quot;
  88             &quot;LateUse&quot;
  89         else
  90             raise
  91         end
  92     end
  93     
  94     def roleCode
  95         Arg.roleCode(role)
  96     end
  97     
  98     def to_s
  99         &quot;#{role}:#{bank}:#{width}&quot;
 100     end
 101 end
 102 
 103 class Overload
 104     attr_reader :signature, :forms
 105 
 106     def initialize(signature, forms)
 107         @signature = signature
 108         @forms = forms
 109     end
 110 end
 111 
 112 class Kind
 113     attr_reader :name
 114     attr_accessor :custom
 115 
 116     def initialize(name)
 117         @name = name
 118         @custom = false
 119     end
 120 
 121     def ==(other)
 122         if other.is_a? String
 123             @name == other
 124         else
 125             @name == other.name and @custom == other.custom
 126         end
 127     end
 128 
 129     def Kind.argKinds(kind)
 130         if kind == &quot;Addr&quot;
 131             [&quot;Addr&quot;, &quot;Stack&quot;, &quot;CallArg&quot;]
 132         else
 133             [kind]
 134         end
 135     end
 136 
 137     def argKinds
 138         Kind.argKinds(kind)
 139     end
 140 end
 141 
 142 class Form
 143     attr_reader :kinds, :altName, :archs
 144 
 145     def initialize(kinds, altName, archs)
 146         @kinds = kinds
 147         @altName = altName
 148         @archs = archs
 149     end
 150 end
 151 
 152 class Origin
 153     attr_reader :fileName, :lineNumber
 154     
 155     def initialize(fileName, lineNumber)
 156         @fileName = fileName
 157         @lineNumber = lineNumber
 158     end
 159     
 160     def to_s
 161         &quot;#{fileName}:#{lineNumber}&quot;
 162     end
 163 end
 164 
 165 class Token
 166     attr_reader :origin, :string
 167     
 168     def initialize(origin, string)
 169         @origin = origin
 170         @string = string
 171     end
 172     
 173     def ==(other)
 174         if other.is_a? Token
 175             @string == other.string
 176         else
 177             @string == other
 178         end
 179     end
 180     
 181     def =~(other)
 182         @string =~ other
 183     end
 184     
 185     def to_s
 186         &quot;#{@string.inspect} at #{origin}&quot;
 187     end
 188     
 189     def parseError(*comment)
 190         if comment.empty?
 191             raise &quot;Parse error: #{to_s}&quot;
 192         else
 193             raise &quot;Parse error: #{to_s}: #{comment[0]}&quot;
 194         end
 195     end
 196 end
 197 
 198 def lex(str, fileName)
 199     fileName = Pathname.new(fileName)
 200     result = []
 201     lineNumber = 1
 202     while not str.empty?
 203         case str
 204         when /\A\#([^\n]*)/
 205             # comment, ignore
 206         when /\A\n/
 207             # newline, ignore
 208             lineNumber += 1
 209         when /\A([a-zA-Z0-9_]+)/
 210             result &lt;&lt; Token.new(Origin.new(fileName, lineNumber), $&amp;)
 211         when /\A([ \t\r]+)/
 212             # whitespace, ignore
 213         when /\A[,:*\/]/
 214             result &lt;&lt; Token.new(Origin.new(fileName, lineNumber), $&amp;)
 215         else
 216             raise &quot;Lexer error at #{Origin.new(fileName, lineNumber).to_s}, unexpected sequence #{str[0..20].inspect}&quot;
 217         end
 218         str = $~.post_match
 219     end
 220     result
 221 end
 222 
 223 def isRole(token)
 224     token =~ /\A((U)|(D)|(UD)|(ZD)|(UZD)|(UA)|(S)|(ED)|(EZD)|(LU))\Z/
 225 end
 226 
 227 def isGF(token)
 228     token =~ /\A((G)|(F))\Z/
 229 end
 230 
 231 def isKind(token)
 232     token =~ /\A((Tmp)|(Imm)|(BigImm)|(BitImm)|(BitImm64)|(SimpleAddr)|(Addr)|(ExtendedOffsetAddr)|(Index)|(RelCond)|(ResCond)|(DoubleCond)|(StatusCond))\Z/
 233 end
 234 
 235 def isArch(token)
 236     token =~ /\A((x86)|(x86_32)|(x86_64)|(arm)|(armv7)|(arm64)|(32)|(64))\Z/
 237 end
 238 
 239 def isWidth(token)
 240     token =~ /\A((8)|(16)|(32)|(64)|(Ptr))\Z/
 241 end
 242 
 243 def isKeyword(token)
 244     isRole(token) or isGF(token) or isKind(token) or isArch(token) or isWidth(token) or
 245         token == &quot;custom&quot; or token == &quot;as&quot;
 246 end
 247 
 248 def isIdentifier(token)
 249     token =~ /\A([a-zA-Z0-9_]+)\Z/ and not isKeyword(token)
 250 end
 251 
 252 class Parser
 253     def initialize(data, fileName)
 254         @tokens = lex(data, fileName)
 255         @idx = 0
 256     end
 257 
 258     def token
 259         @tokens[@idx]
 260     end
 261 
 262     def advance
 263         @idx += 1
 264     end
 265 
 266     def parseError(*comment)
 267         if token
 268             token.parseError(*comment)
 269         else
 270             if comment.empty?
 271                 raise &quot;Parse error at end of file&quot;
 272             else
 273                 raise &quot;Parse error at end of file: #{comment[0]}&quot;
 274             end
 275         end
 276     end
 277 
 278     def consume(string)
 279         parseError(&quot;Expected #{string}&quot;) unless token == string
 280         advance
 281     end
 282 
 283     def consumeIdentifier
 284         result = token.string
 285         parseError(&quot;Expected identifier&quot;) unless isIdentifier(result)
 286         advance
 287         result
 288     end
 289 
 290     def consumeRole
 291         result = token.string
 292         parseError(&quot;Expected role (U, D, UD, ZD, UZD, UA, or S)&quot;) unless isRole(result)
 293         advance
 294         result
 295     end
 296 
 297     def consumeBank
 298         result = token.string
 299         parseError(&quot;Expected bank (G or F)&quot;) unless isGF(result)
 300         advance
 301         result
 302     end
 303 
 304     def consumeKind
 305         result = token.string
 306         parseError(&quot;Expected kind (Imm, BigImm, BitImm, BitImm64, Tmp, SimpleAddr, Addr, ExtendedOffsetAddr, Index, RelCond, ResCond, DoubleCond, or StatusCond)&quot;) unless isKind(result)
 307         advance
 308         result
 309     end
 310 
 311     def consumeWidth
 312         result = token.string
 313         parseError(&quot;Expected width (8, 16, 32, or 64)&quot;) unless isWidth(result)
 314         advance
 315         result
 316     end
 317 
 318     def parseArchs
 319         return nil unless isArch(token)
 320 
 321         result = []
 322         while isArch(token)
 323             case token.string
 324             when &quot;x86&quot;
 325                 result &lt;&lt; &quot;X86&quot;
 326                 result &lt;&lt; &quot;X86_64&quot;
 327             when &quot;x86_32&quot;
 328                 result &lt;&lt; &quot;X86&quot;
 329             when &quot;x86_64&quot;
 330                 result &lt;&lt; &quot;X86_64&quot;
 331             when &quot;arm&quot;
 332                 result &lt;&lt; &quot;ARMv7&quot;
 333                 result &lt;&lt; &quot;ARM64&quot;
 334             when &quot;armv7&quot;
 335                 result &lt;&lt; &quot;ARMv7&quot;
 336             when &quot;arm64&quot;
 337                 result &lt;&lt; &quot;ARM64&quot;
 338             when &quot;32&quot;
 339                 result &lt;&lt; &quot;X86&quot;
 340                 result &lt;&lt; &quot;ARMv7&quot;
 341             when &quot;64&quot;
 342                 result &lt;&lt; &quot;X86_64&quot;
 343                 result &lt;&lt; &quot;ARM64&quot;
 344             else
 345                 raise token.string
 346             end
 347             advance
 348         end
 349 
 350         consume(&quot;:&quot;)
 351         @lastArchs = result
 352     end
 353 
 354     def consumeArchs
 355         result = @lastArchs
 356         @lastArchs = nil
 357         result
 358     end
 359 
 360     def parseAndConsumeArchs
 361         parseArchs
 362         consumeArchs
 363     end
 364 
 365     def intersectArchs(left, right)
 366         return left unless right
 367         return right unless left
 368 
 369         left.select {
 370             | value |
 371             right.find {
 372                 | otherValue |
 373                 value == otherValue
 374             }
 375         }
 376     end
 377 
 378     def parse
 379         result = {}
 380         
 381         loop {
 382             break if @idx &gt;= @tokens.length
 383 
 384             if token == &quot;custom&quot;
 385                 consume(&quot;custom&quot;)
 386                 opcodeName = consumeIdentifier
 387 
 388                 parseError(&quot;Cannot overload a custom opcode&quot;) if result[opcodeName]
 389 
 390                 result[opcodeName] = Opcode.new(opcodeName, true)
 391             else
 392                 opcodeArchs = parseAndConsumeArchs
 393 
 394                 opcodeName = consumeIdentifier
 395 
 396                 if result[opcodeName]
 397                     opcode = result[opcodeName]
 398                     parseError(&quot;Cannot overload a custom opcode&quot;) if opcode.custom
 399                 else
 400                     opcode = Opcode.new(opcodeName, false)
 401                     result[opcodeName] = opcode
 402                 end
 403 
 404                 signature = []
 405                 forms = []
 406                 
 407                 if isRole(token)
 408                     loop {
 409                         role = consumeRole
 410                         consume(&quot;:&quot;)
 411                         bank = consumeBank
 412                         consume(&quot;:&quot;)
 413                         width = consumeWidth
 414                         
 415                         signature &lt;&lt; Arg.new(role, bank, width)
 416                         
 417                         break unless token == &quot;,&quot;
 418                         consume(&quot;,&quot;)
 419                     }
 420                 end
 421 
 422                 while token == &quot;/&quot;
 423                     consume(&quot;/&quot;)
 424                     case token.string
 425                     when &quot;branch&quot;
 426                         opcode.attributes[:branch] = true
 427                         opcode.attributes[:terminal] = true
 428                     when &quot;terminal&quot;
 429                         opcode.attributes[:terminal] = true
 430                     when &quot;effects&quot;
 431                         opcode.attributes[:effects] = true
 432                     when &quot;return&quot;
 433                         opcode.attributes[:return] = true
 434                         opcode.attributes[:terminal] = true
 435                     else
 436                         parseError(&quot;Bad / directive&quot;)
 437                     end
 438                     advance
 439                 end
 440 
 441                 parseArchs
 442                 if isKind(token)
 443                     loop {
 444                         kinds = []
 445                         altName = nil
 446                         formArchs = consumeArchs
 447                         loop {
 448                             kinds &lt;&lt; Kind.new(consumeKind)
 449 
 450                             if token == &quot;*&quot;
 451                                 parseError(&quot;Can only apply * to Tmp&quot;) unless kinds[-1].name == &quot;Tmp&quot;
 452                                 kinds[-1].custom = true
 453                                 consume(&quot;*&quot;)
 454                             end
 455 
 456                             break unless token == &quot;,&quot;
 457                             consume(&quot;,&quot;)
 458                         }
 459 
 460                         if token == &quot;as&quot;
 461                             consume(&quot;as&quot;)
 462                             altName = consumeIdentifier
 463                         end
 464 
 465                         parseError(&quot;Form has wrong number of arguments for overload&quot;) unless kinds.length == signature.length
 466                         kinds.each_with_index {
 467                             | kind, index |
 468                             if kind.name == &quot;Imm&quot; or kind.name == &quot;BigImm&quot; or kind.name == &quot;BitImm&quot; or kind.name == &quot;BitImm64&quot;
 469                                 if signature[index].role != &quot;U&quot;
 470                                     parseError(&quot;Form has an immediate for a non-use argument&quot;)
 471                                 end
 472                                 if signature[index].bank != &quot;G&quot;
 473                                     parseError(&quot;Form has an immediate for a non-general-purpose argument&quot;)
 474                                 end
 475                             end
 476                         }
 477                         forms &lt;&lt; Form.new(kinds, altName, intersectArchs(opcodeArchs, formArchs))
 478 
 479                         parseArchs
 480                         break unless isKind(token)
 481                     }
 482                 end
 483 
 484                 if signature.length == 0
 485                     raise unless forms.length == 0
 486                     forms &lt;&lt; Form.new([], nil, opcodeArchs)
 487                 end
 488 
 489                 opcode.overloads &lt;&lt; Overload.new(signature, forms)
 490             end
 491         }
 492 
 493         result
 494     end
 495 end
 496 
 497 $fileName = ARGV[0]
 498 
 499 parser = Parser.new(IO::read($fileName), $fileName)
 500 $opcodes = parser.parse
 501 
 502 def writeH(filename)
 503     File.open(&quot;Air#{filename}.h&quot;, &quot;w&quot;) {
 504         | outp |
 505         
 506         outp.puts &quot;// Generated by opcode_generator.rb from #{$fileName} -- do not edit!&quot;
 507         
 508         outp.puts &quot;#ifndef Air#{filename}_h&quot;
 509         outp.puts &quot;#define Air#{filename}_h&quot;
 510 
 511         yield outp
 512         
 513         outp.puts &quot;#endif // Air#{filename}_h&quot;
 514     }
 515 end
 516 
 517 writeH(&quot;Opcode&quot;) {
 518     | outp |
 519     outp.puts &quot;namespace JSC { namespace B3 { namespace Air {&quot;
 520     outp.puts &quot;enum Opcode : int16_t {&quot;
 521     $opcodes.keys.each {
 522         | opcode |
 523         outp.puts &quot;    #{opcode},&quot;
 524     }
 525     outp.puts &quot;};&quot;
 526 
 527     outp.puts &quot;static const unsigned numOpcodes = #{$opcodes.keys.size};&quot;
 528     outp.puts &quot;} } } // namespace JSC::B3::Air&quot;
 529     
 530     outp.puts &quot;namespace WTF {&quot;
 531     outp.puts &quot;class PrintStream;&quot;
 532     outp.puts &quot;JS_EXPORT_PRIVATE void printInternal(PrintStream&amp;, JSC::B3::Air::Opcode);&quot;
 533     outp.puts &quot;} // namespace WTF&quot;
 534 }
 535 
 536 # From here on, we don&#39;t try to emit properly indented code, since we&#39;re using a recursive pattern
 537 # matcher.
 538 
 539 def matchForms(outp, speed, forms, columnIndex, columnGetter, filter, callback)
 540     return if forms.length == 0
 541 
 542     if filter[forms]
 543         return
 544     end
 545 
 546     if columnIndex &gt;= forms[0].kinds.length
 547         raise &quot;Did not reduce to one form: #{forms.inspect}&quot; unless forms.length == 1
 548         callback[forms[0]]
 549         outp.puts &quot;break;&quot;
 550         return
 551     end
 552     
 553     groups = {}
 554     forms.each {
 555         | form |
 556         kind = form.kinds[columnIndex].name
 557         if groups[kind]
 558             groups[kind] &lt;&lt; form
 559         else
 560             groups[kind] = [form]
 561         end
 562     }
 563 
 564     if speed == :fast and groups.length == 1
 565         matchForms(outp, speed, forms, columnIndex + 1, columnGetter, filter, callback)
 566         return
 567     end
 568 
 569     outp.puts &quot;switch (#{columnGetter[columnIndex]}) {&quot;
 570     groups.each_pair {
 571         | key, value |
 572         outp.puts &quot;#if USE(JSVALUE64)&quot; if key == &quot;BigImm&quot; or key == &quot;BitImm64&quot;
 573         Kind.argKinds(key).each {
 574             | argKind |
 575             outp.puts &quot;case Arg::#{argKind}:&quot;
 576         }
 577         matchForms(outp, speed, value, columnIndex + 1, columnGetter, filter, callback)
 578         outp.puts &quot;break;&quot;
 579         outp.puts &quot;#endif // USE(JSVALUE64)&quot; if key == &quot;BigImm&quot; or key == &quot;BitImm64&quot;
 580     }
 581     outp.puts &quot;default:&quot;
 582     outp.puts &quot;break;&quot;
 583     outp.puts &quot;}&quot;
 584 end
 585 
 586 def matchInstOverload(outp, speed, inst)
 587     outp.puts &quot;switch (#{inst}-&gt;kind.opcode) {&quot;
 588     $opcodes.values.each {
 589         | opcode |
 590         outp.puts &quot;case Opcode::#{opcode.name}:&quot;
 591         if opcode.custom
 592             yield opcode, nil
 593         else
 594             needOverloadSwitch = ((opcode.overloads.size != 1) or speed == :safe)
 595             outp.puts &quot;switch (#{inst}-&gt;args.size()) {&quot; if needOverloadSwitch
 596             opcode.overloads.each {
 597                 | overload |
 598                 outp.puts &quot;case #{overload.signature.length}:&quot; if needOverloadSwitch
 599                 yield opcode, overload
 600                 outp.puts &quot;break;&quot; if needOverloadSwitch
 601             }
 602             if needOverloadSwitch
 603                 outp.puts &quot;default:&quot;
 604                 outp.puts &quot;break;&quot;
 605                 outp.puts &quot;}&quot;
 606             end
 607         end
 608         outp.puts &quot;break;&quot;
 609     }
 610     outp.puts &quot;default:&quot;
 611     outp.puts &quot;break;&quot;
 612     outp.puts &quot;}&quot;
 613 end
 614     
 615 def matchInstOverloadForm(outp, speed, inst)
 616     matchInstOverload(outp, speed, inst) {
 617         | opcode, overload |
 618         if opcode.custom
 619             yield opcode, nil, nil
 620         else
 621             columnGetter = proc {
 622                 | columnIndex |
 623                 &quot;#{inst}-&gt;args[#{columnIndex}].kind()&quot;
 624             }
 625             filter = proc { false }
 626             callback = proc {
 627                 | form |
 628                 yield opcode, overload, form
 629             }
 630             matchForms(outp, speed, overload.forms, 0, columnGetter, filter, callback)
 631         end
 632     }
 633 end
 634 
 635 def beginArchs(outp, archs)
 636     return unless archs
 637     if archs.empty?
 638         outp.puts &quot;#if 0&quot;
 639         return
 640     end
 641     outp.puts(&quot;#if &quot; + archs.map {
 642                   | arch |
 643                   &quot;CPU(#{arch})&quot;
 644               }.join(&quot; || &quot;))
 645 end
 646 
 647 def endArchs(outp, archs)
 648     return unless archs
 649     outp.puts &quot;#endif&quot;
 650 end
 651 
 652 maxNumOperands = 0
 653 $opcodes.values.each {
 654     | opcode |
 655     next if opcode.custom
 656     opcode.overloads.each {
 657         | overload |
 658         maxNumOperands = overload.signature.length if overload.signature.length &gt; maxNumOperands
 659     }
 660 }
 661 
 662 formTableWidth = (maxNumOperands + 1) * maxNumOperands / 2
 663 
 664 writeH(&quot;OpcodeUtils&quot;) {
 665     | outp |
 666     outp.puts &quot;#include \&quot;AirCustom.h\&quot;&quot;
 667     outp.puts &quot;#include \&quot;AirInst.h\&quot;&quot;
 668     outp.puts &quot;#include \&quot;AirFormTable.h\&quot;&quot;
 669     outp.puts &quot;namespace JSC { namespace B3 { namespace Air {&quot;
 670     
 671     outp.puts &quot;inline bool opgenHiddenTruth() { return true; }&quot;
 672     outp.puts &quot;template&lt;typename T&gt;&quot;
 673     outp.puts &quot;inline T* opgenHiddenPtrIdentity(T* pointer) { return pointer; }&quot;
 674     outp.puts &quot;#define OPGEN_RETURN(value) do {\\&quot;
 675     outp.puts &quot;    if (opgenHiddenTruth())\\&quot;
 676     outp.puts &quot;        return value;\\&quot;
 677     outp.puts &quot;} while (false)&quot;
 678 
 679     outp.puts &quot;template&lt;typename Functor&gt;&quot;
 680     outp.puts &quot;ALWAYS_INLINE void Inst::forEachArg(const Functor&amp; functor)&quot;
 681     outp.puts &quot;{&quot;
 682     outp.puts &quot;switch (kind.opcode) {&quot;
 683     $opcodes.values.each {
 684         | opcode |
 685         if opcode.custom
 686             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
 687         end
 688     }
 689     outp.puts &quot;forEachArgCustom(scopedLambdaRef&lt;EachArgCallback&gt;(functor));&quot;
 690     outp.puts &quot;return;&quot;
 691     outp.puts &quot;default:&quot;
 692     outp.puts &quot;forEachArgSimple(functor);&quot;
 693     outp.puts &quot;return;&quot;
 694     outp.puts &quot;}&quot;
 695     outp.puts &quot;}&quot;
 696     
 697     outp.puts &quot;template&lt;typename Func&gt;&quot;
 698     outp.puts &quot;ALWAYS_INLINE void Inst::forEachArgSimple(const Func&amp; func)&quot;
 699     outp.puts &quot;{&quot;
 700     outp.puts &quot;    size_t numOperands = args.size();&quot;
 701     outp.puts &quot;    size_t formOffset = (numOperands - 1) * numOperands / 2;&quot;
 702     outp.puts &quot;    const uint8_t* formBase = g_formTable + kind.opcode * #{formTableWidth} + formOffset;&quot;
 703     outp.puts &quot;    for (size_t i = 0; i &lt; numOperands; ++i) {&quot;
 704     outp.puts &quot;        uint8_t form = formBase[i];&quot;
 705     outp.puts &quot;        ASSERT(!(form &amp; (1 &lt;&lt; formInvalidShift)));&quot;
 706     outp.puts &quot;        func(args[i], decodeFormRole(form), decodeFormBank(form), decodeFormWidth(form));&quot;
 707     outp.puts &quot;    }&quot;
 708     outp.puts &quot;}&quot;
 709 
 710     outp.puts &quot;template&lt;typename... Arguments&gt;&quot;
 711     outp.puts &quot;ALWAYS_INLINE bool isValidForm(Opcode opcode, Arguments... arguments)&quot;
 712     outp.puts &quot;{&quot;
 713     outp.puts &quot;Arg::Kind kinds[sizeof...(Arguments)] = { arguments... };&quot;
 714     outp.puts &quot;switch (opcode) {&quot;
 715     $opcodes.values.each {
 716         | opcode |
 717         outp.puts &quot;case Opcode::#{opcode.name}:&quot;
 718         if opcode.custom
 719             outp.puts &quot;OPGEN_RETURN(#{opcode.name}Custom::isValidFormStatic(arguments...));&quot;
 720         else
 721             outp.puts &quot;switch (sizeof...(Arguments)) {&quot;
 722             opcode.overloads.each {
 723                 | overload |
 724                 outp.puts &quot;case #{overload.signature.length}:&quot;
 725                 columnGetter = proc { | columnIndex | &quot;opgenHiddenPtrIdentity(kinds)[#{columnIndex}]&quot; }
 726                 filter = proc { false }
 727                 callback = proc {
 728                     | form |
 729                     # This conservatively says that Stack is not a valid form for UseAddr,
 730                     # because it&#39;s only valid if it&#39;s not a spill slot. This is consistent with
 731                     # isValidForm() being conservative and it also happens to be practical since
 732                     # we don&#39;t really use isValidForm for deciding when Stack is safe.
 733                     overload.signature.length.times {
 734                         | index |
 735                         if overload.signature[index].role == &quot;UA&quot;
 736                             outp.puts &quot;if (opgenHiddenPtrIdentity(kinds)[#{index}] == Arg::Stack)&quot;
 737                             outp.puts &quot;    return false;&quot;
 738                         end
 739                     }
 740                     
 741                     notCustom = (not form.kinds.detect { | kind | kind.custom })
 742                     if notCustom
 743                         beginArchs(outp, form.archs)
 744                         outp.puts &quot;OPGEN_RETURN(true);&quot;
 745                         endArchs(outp, form.archs)
 746                     end
 747                 }
 748                 matchForms(outp, :safe, overload.forms, 0, columnGetter, filter, callback)
 749                 outp.puts &quot;break;&quot;
 750             }
 751             outp.puts &quot;default:&quot;
 752             outp.puts &quot;break;&quot;
 753             outp.puts &quot;}&quot;
 754         end
 755         outp.puts &quot;break;&quot;
 756     }
 757     outp.puts &quot;default:&quot;
 758     outp.puts &quot;break;&quot;
 759     outp.puts &quot;}&quot;
 760     outp.puts &quot;return false; &quot;
 761     outp.puts &quot;}&quot;
 762 
 763     outp.puts &quot;inline bool isDefinitelyTerminal(Opcode opcode)&quot;
 764     outp.puts &quot;{&quot;
 765     outp.puts &quot;switch (opcode) {&quot;
 766     didFindTerminals = false
 767     $opcodes.values.each {
 768         | opcode |
 769         if opcode.attributes[:terminal]
 770             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
 771             didFindTerminals = true
 772         end
 773     }
 774     if didFindTerminals
 775         outp.puts &quot;return true;&quot;
 776     end
 777     outp.puts &quot;default:&quot;
 778     outp.puts &quot;return false;&quot;
 779     outp.puts &quot;}&quot;
 780     outp.puts &quot;}&quot;
 781 
 782     outp.puts &quot;inline bool isReturn(Opcode opcode)&quot;
 783     outp.puts &quot;{&quot;
 784     outp.puts &quot;switch (opcode) {&quot;
 785     didFindReturns = false
 786     $opcodes.values.each {
 787         | opcode |
 788         if opcode.attributes[:return]
 789             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
 790             didFindReturns = true
 791         end
 792     }
 793     if didFindReturns
 794         outp.puts &quot;return true;&quot;
 795     end
 796     outp.puts &quot;default:&quot;
 797     outp.puts &quot;return false;&quot;
 798     outp.puts &quot;}&quot;
 799     outp.puts &quot;}&quot;
 800     
 801     outp.puts &quot;} } } // namespace JSC::B3::Air&quot;
 802 }
 803 
 804 writeH(&quot;OpcodeGenerated&quot;) {
 805     | outp |
 806     outp.puts &quot;#include \&quot;AirInstInlines.h\&quot;&quot;
 807     outp.puts &quot;#include \&quot;CCallHelpers.h\&quot;&quot;
 808     outp.puts &quot;#include \&quot;wtf/PrintStream.h\&quot;&quot;
 809     outp.puts &quot;namespace WTF {&quot;
 810     outp.puts &quot;using namespace JSC::B3::Air;&quot;
 811     outp.puts &quot;void printInternal(PrintStream&amp; out, Opcode opcode)&quot;
 812     outp.puts &quot;{&quot;
 813     outp.puts &quot;    switch (opcode) {&quot;
 814     $opcodes.keys.each {
 815         | opcode |
 816         outp.puts &quot;    case Opcode::#{opcode}:&quot;
 817         outp.puts &quot;        out.print(\&quot;#{opcode}\&quot;);&quot;
 818         outp.puts &quot;        return;&quot;
 819     }
 820     outp.puts &quot;    }&quot;
 821     outp.puts &quot;    RELEASE_ASSERT_NOT_REACHED();&quot;
 822     outp.puts &quot;}&quot;
 823     outp.puts &quot;} // namespace WTF&quot;
 824     outp.puts &quot;namespace JSC { namespace B3 { namespace Air {&quot;
 825     
 826     outp.puts &quot;const uint8_t g_formTable[#{$opcodes.size * formTableWidth}] = {&quot;
 827     $opcodes.values.each {
 828         | opcode |
 829         overloads = [nil] * (maxNumOperands + 1)
 830         unless opcode.custom
 831             opcode.overloads.each {
 832                 | overload |
 833                 overloads[overload.signature.length] = overload
 834             }
 835         end
 836         
 837         (0..maxNumOperands).each {
 838             | numOperands |
 839             overload = overloads[numOperands]
 840             if overload
 841                 outp.puts &quot;// #{opcode.name} #{overload.signature.join(&#39;, &#39;)}&quot;
 842                 numOperands.times {
 843                     | index |
 844                     arg = overload.signature[index]
 845                     outp.print &quot;ENCODE_INST_FORM(Arg::#{arg.roleCode}, #{arg.bank}P, #{arg.widthCode}), &quot;
 846                 }
 847             else
 848                 outp.puts &quot;// Invalid: #{opcode.name} with numOperands = #{numOperands}&quot;
 849                 numOperands.times {
 850                     outp.print &quot;INVALID_INST_FORM, &quot;
 851                 }
 852             end
 853             outp.puts
 854         }
 855     }
 856     outp.puts &quot;};&quot;
 857     
 858     outp.puts &quot;void Inst::forEachArgCustom(ScopedLambda&lt;EachArgCallback&gt; lambda)&quot;
 859     outp.puts &quot;{&quot;
 860     outp.puts &quot;switch (kind.opcode) {&quot;
 861     $opcodes.values.each {
 862         | opcode |
 863         if opcode.custom
 864             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
 865             outp.puts &quot;#{opcode.name}Custom::forEachArg(*this, lambda);&quot;
 866             outp.puts &quot;break;&quot;
 867         end
 868     }
 869     outp.puts &quot;default:&quot;
 870     outp.puts &quot;dataLog(\&quot;Bad call to forEachArgCustom, not custom opcode: \&quot;, kind, \&quot;\\n\&quot;);&quot;
 871     outp.puts &quot;RELEASE_ASSERT_NOT_REACHED();&quot;
 872     outp.puts &quot;}&quot;
 873     outp.puts &quot;}&quot;
 874     
 875     outp.puts &quot;bool Inst::isValidForm()&quot;
 876     outp.puts &quot;{&quot;
 877     matchInstOverloadForm(outp, :safe, &quot;this&quot;) {
 878         | opcode, overload, form |
 879         if opcode.custom
 880             outp.puts &quot;OPGEN_RETURN(#{opcode.name}Custom::isValidForm(*this));&quot;
 881         else
 882             beginArchs(outp, form.archs)
 883             needsMoreValidation = false
 884             overload.signature.length.times {
 885                 | index |
 886                 arg = overload.signature[index]
 887                 kind = form.kinds[index]
 888                 needsMoreValidation |= kind.custom
 889 
 890                 # Some kinds of Args reqire additional validation.
 891                 case kind.name
 892                 when &quot;Tmp&quot;
 893                     outp.puts &quot;if (!args[#{index}].tmp().is#{arg.bank}P())&quot;
 894                     outp.puts &quot;OPGEN_RETURN(false);&quot;
 895                 when &quot;Imm&quot;
 896                     outp.puts &quot;if (!Arg::isValidImmForm(args[#{index}].value()))&quot;
 897                     outp.puts &quot;OPGEN_RETURN(false);&quot;
 898                 when &quot;BitImm&quot;
 899                     outp.puts &quot;if (!Arg::isValidBitImmForm(args[#{index}].value()))&quot;
 900                     outp.puts &quot;OPGEN_RETURN(false);&quot;
 901                 when &quot;BitImm64&quot;
 902                     outp.puts &quot;if (!Arg::isValidBitImm64Form(args[#{index}].value()))&quot;
 903                     outp.puts &quot;OPGEN_RETURN(false);&quot;
 904                 when &quot;SimpleAddr&quot;
 905                     outp.puts &quot;if (!args[#{index}].ptr().isGP())&quot;
 906                     outp.puts &quot;OPGEN_RETURN(false);&quot;
 907                 when &quot;Addr&quot;
 908                     if arg.role == &quot;UA&quot;
 909                         outp.puts &quot;if (args[#{index}].isStack() &amp;&amp; args[#{index}].stackSlot()-&gt;isSpill())&quot;
 910                         outp.puts &quot;OPGEN_RETURN(false);&quot;
 911                     end
 912                     outp.puts &quot;if (!Arg::isValidAddrForm(args[#{index}].offset()))&quot;
 913                     outp.puts &quot;OPGEN_RETURN(false);&quot;
 914                 when &quot;ExtendedOffsetAddr&quot;
 915                     if arg.role == &quot;UA&quot;
 916                         outp.puts &quot;if (args[#{index}].isStack() &amp;&amp; args[#{index}].stackSlot()-&gt;isSpill())&quot;
 917                         outp.puts &quot;OPGEN_RETURN(false);&quot;
 918                     end
 919                 when &quot;Index&quot;
 920                     outp.puts &quot;if (!Arg::isValidIndexForm(args[#{index}].scale(), args[#{index}].offset(), #{arg.widthCode}))&quot;
 921                     outp.puts &quot;OPGEN_RETURN(false);&quot;
 922                 when &quot;BigImm&quot;
 923                 when &quot;RelCond&quot;
 924                 when &quot;ResCond&quot;
 925                 when &quot;DoubleCond&quot;
 926                 when &quot;StatusCond&quot;
 927                 else
 928                     raise &quot;Unexpected kind: #{kind.name}&quot;
 929                 end
 930             }
 931             if needsMoreValidation
 932                 outp.puts &quot;if (!is#{opcode.name}Valid(*this))&quot;
 933                 outp.puts &quot;OPGEN_RETURN(false);&quot;
 934             end
 935             outp.puts &quot;OPGEN_RETURN(true);&quot;
 936             endArchs(outp, form.archs)
 937         end
 938     }
 939     outp.puts &quot;return false;&quot;
 940     outp.puts &quot;}&quot;
 941 
 942     outp.puts &quot;bool Inst::admitsStack(unsigned argIndex)&quot;
 943     outp.puts &quot;{&quot;
 944     outp.puts &quot;switch (kind.opcode) {&quot;
 945     $opcodes.values.each {
 946         | opcode |
 947         outp.puts &quot;case Opcode::#{opcode.name}:&quot;
 948 
 949         if opcode.custom
 950             outp.puts &quot;OPGEN_RETURN(#{opcode.name}Custom::admitsStack(*this, argIndex));&quot;
 951         else
 952             # Switch on the argIndex.
 953             outp.puts &quot;switch (argIndex) {&quot;
 954 
 955             numArgs = opcode.overloads.map {
 956                 | overload |
 957                 overload.signature.length
 958             }.max
 959             
 960             numArgs.times {
 961                 | argIndex |
 962                 outp.puts &quot;case #{argIndex}:&quot;
 963 
 964                 # Check if all of the forms of all of the overloads either do, or don&#39;t, admit an address
 965                 # at this index. We expect this to be a very common case.
 966                 numYes = 0
 967                 numNo = 0
 968                 opcode.overloads.each {
 969                     | overload |
 970                     useAddr = (overload.signature[argIndex] and
 971                                overload.signature[argIndex].role == &quot;UA&quot;)
 972                     overload.forms.each {
 973                         | form |
 974                         if form.kinds[argIndex] == &quot;Addr&quot; and not useAddr
 975                             numYes += 1
 976                         else
 977                             numNo += 1
 978                         end
 979                     }
 980                 }
 981 
 982                 # Note that we deliberately test numYes first because if we end up with no forms, we want
 983                 # to say that Address is inadmissible.
 984                 if numYes == 0
 985                     outp.puts &quot;OPGEN_RETURN(false);&quot;
 986                 elsif numNo == 0
 987                     outp.puts &quot;OPGEN_RETURN(true);&quot;
 988                 else
 989                     # Now do the full test.
 990 
 991                     needOverloadSwitch = (opcode.overloads.size != 1)
 992 
 993                     outp.puts &quot;switch (args.size()) {&quot; if needOverloadSwitch
 994                     opcode.overloads.each {
 995                         | overload |
 996 
 997                         useAddr = (overload.signature[argIndex] and
 998                                    overload.signature[argIndex].role == &quot;UA&quot;)
 999                         
1000                         # Again, check if all of them do what we want.
1001                         numYes = 0
1002                         numNo = 0
1003                         overload.forms.each {
1004                             | form |
1005                             if form.kinds[argIndex] == &quot;Addr&quot; and not useAddr
1006                                 numYes += 1
1007                             else
1008                                 numNo += 1
1009                             end
1010                         }
1011 
1012                         if numYes == 0
1013                             # Don&#39;t emit anything, just drop to default.
1014                         elsif numNo == 0
1015                             outp.puts &quot;case #{overload.signature.length}:&quot; if needOverloadSwitch
1016                             outp.puts &quot;OPGEN_RETURN(true);&quot;
1017                             outp.puts &quot;break;&quot; if needOverloadSwitch
1018                         else
1019                             outp.puts &quot;case #{overload.signature.length}:&quot; if needOverloadSwitch
1020 
1021                             # This is how we test the hypothesis that changing this argument to an
1022                             # address yields a valid form.
1023                             columnGetter = proc {
1024                                 | columnIndex |
1025                                 if columnIndex == argIndex
1026                                     &quot;Arg::Addr&quot;
1027                                 else
1028                                     &quot;args[#{columnIndex}].kind()&quot;
1029                                 end
1030                             }
1031                             filter = proc {
1032                                 | forms |
1033                                 numYes = 0
1034 
1035                                 forms.each {
1036                                     | form |
1037                                     if form.kinds[argIndex] == &quot;Addr&quot;
1038                                         numYes += 1
1039                                     end
1040                                 }
1041 
1042                                 if numYes == 0
1043                                     # Drop down, emit no code, since we cannot match.
1044                                     true
1045                                 else
1046                                     # Keep going.
1047                                     false
1048                                 end
1049                             }
1050                             callback = proc {
1051                                 | form |
1052                                 beginArchs(outp, form.archs)
1053                                 outp.puts &quot;OPGEN_RETURN(true);&quot;
1054                                 endArchs(outp, form.archs)
1055                             }
1056                             matchForms(outp, :safe, overload.forms, 0, columnGetter, filter, callback)
1057 
1058                             outp.puts &quot;break;&quot; if needOverloadSwitch
1059                         end
1060                     }
1061                     if needOverloadSwitch
1062                         outp.puts &quot;default:&quot;
1063                         outp.puts &quot;break;&quot;
1064                         outp.puts &quot;}&quot;
1065                     end
1066                 end
1067                 
1068                 outp.puts &quot;break;&quot;
1069             }
1070             
1071             outp.puts &quot;default:&quot;
1072             outp.puts &quot;break;&quot;
1073             outp.puts &quot;}&quot;
1074         end
1075         
1076         outp.puts &quot;break;&quot;
1077     }
1078     outp.puts &quot;default:&quot;;
1079     outp.puts &quot;break;&quot;
1080     outp.puts &quot;}&quot;
1081     outp.puts &quot;return false;&quot;
1082     outp.puts &quot;}&quot;
1083 
1084     outp.puts &quot;bool Inst::admitsExtendedOffsetAddr(unsigned argIndex)&quot;
1085     outp.puts &quot;{&quot;
1086     outp.puts &quot;switch (kind.opcode) {&quot;
1087     $opcodes.values.each {
1088         | opcode |
1089         if opcode.custom
1090             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
1091             outp.puts &quot;OPGEN_RETURN(#{opcode.name}Custom::admitsExtendedOffsetAddr(*this, argIndex));&quot;
1092             outp.puts &quot;break;&quot;
1093         end
1094     }
1095     outp.puts &quot;default:&quot;
1096     outp.puts &quot;break;&quot;
1097     outp.puts &quot;}&quot;
1098     outp.puts &quot;return false;&quot;
1099     outp.puts &quot;}&quot;
1100 
1101 
1102     outp.puts &quot;bool Inst::isTerminal()&quot;
1103     outp.puts &quot;{&quot;
1104     outp.puts &quot;switch (kind.opcode) {&quot;
1105     foundTrue = false
1106     $opcodes.values.each {
1107         | opcode |
1108         if opcode.attributes[:terminal]
1109             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
1110             foundTrue = true
1111         end
1112     }
1113     if foundTrue
1114         outp.puts &quot;return true;&quot;
1115     end
1116     $opcodes.values.each {
1117         | opcode |
1118         if opcode.custom
1119             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
1120             outp.puts &quot;return #{opcode.name}Custom::isTerminal(*this);&quot;
1121         end
1122     }
1123     outp.puts &quot;default:&quot;
1124     outp.puts &quot;return false;&quot;
1125     outp.puts &quot;}&quot;
1126     outp.puts &quot;}&quot;
1127     
1128     outp.puts &quot;bool Inst::hasNonArgNonControlEffects()&quot;
1129     outp.puts &quot;{&quot;
1130     outp.puts &quot;if (kind.effects)&quot;
1131     outp.puts &quot;return true;&quot;
1132     outp.puts &quot;switch (kind.opcode) {&quot;
1133     foundTrue = false
1134     $opcodes.values.each {
1135         | opcode |
1136         if opcode.attributes[:effects]
1137             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
1138             foundTrue = true
1139         end
1140     }
1141     if foundTrue
1142         outp.puts &quot;return true;&quot;
1143     end
1144     $opcodes.values.each {
1145         | opcode |
1146         if opcode.custom
1147             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
1148             outp.puts &quot;return #{opcode.name}Custom::hasNonArgNonControlEffects(*this);&quot;
1149         end
1150     }
1151     outp.puts &quot;default:&quot;
1152     outp.puts &quot;return false;&quot;
1153     outp.puts &quot;}&quot;
1154     outp.puts &quot;}&quot;
1155     
1156     outp.puts &quot;bool Inst::hasNonArgEffects()&quot;
1157     outp.puts &quot;{&quot;
1158     outp.puts &quot;if (kind.effects)&quot;
1159     outp.puts &quot;return true;&quot;
1160     outp.puts &quot;switch (kind.opcode) {&quot;
1161     foundTrue = false
1162     $opcodes.values.each {
1163         | opcode |
1164         if opcode.attributes[:terminal] or opcode.attributes[:effects]
1165             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
1166             foundTrue = true
1167         end
1168     }
1169     if foundTrue
1170         outp.puts &quot;return true;&quot;
1171     end
1172     $opcodes.values.each {
1173         | opcode |
1174         if opcode.custom
1175             outp.puts &quot;case Opcode::#{opcode.name}:&quot;
1176             outp.puts &quot;return #{opcode.name}Custom::hasNonArgEffects(*this);&quot;
1177         end
1178     }
1179     outp.puts &quot;default:&quot;
1180     outp.puts &quot;return false;&quot;
1181     outp.puts &quot;}&quot;
1182     outp.puts &quot;}&quot;
1183     
1184     outp.puts &quot;CCallHelpers::Jump Inst::generate(CCallHelpers&amp; jit, GenerationContext&amp; context)&quot;
1185     outp.puts &quot;{&quot;
1186     outp.puts &quot;UNUSED_PARAM(jit);&quot;
1187     outp.puts &quot;UNUSED_PARAM(context);&quot;
1188     outp.puts &quot;CCallHelpers::Jump result;&quot;
1189     matchInstOverloadForm(outp, :fast, &quot;this&quot;) {
1190         | opcode, overload, form |
1191         if opcode.custom
1192             outp.puts &quot;OPGEN_RETURN(#{opcode.name}Custom::generate(*this, jit, context));&quot;
1193         else
1194             beginArchs(outp, form.archs)
1195             if form.altName
1196                 methodName = form.altName
1197             else
1198                 methodName = opcode.masmName
1199             end
1200             if opcode.attributes[:branch]
1201                 outp.print &quot;result = &quot;
1202             end
1203             outp.print &quot;jit.#{methodName}(&quot;
1204 
1205             form.kinds.each_with_index {
1206                 | kind, index |
1207                 if index != 0
1208                     outp.print &quot;, &quot;
1209                 end
1210                 case kind.name
1211                 when &quot;Tmp&quot;
1212                     if overload.signature[index].bank == &quot;G&quot;
1213                         outp.print &quot;args[#{index}].gpr()&quot;
1214                     else
1215                         outp.print &quot;args[#{index}].fpr()&quot;
1216                     end
1217                 when &quot;Imm&quot;, &quot;BitImm&quot;
1218                     outp.print &quot;args[#{index}].asTrustedImm32()&quot;
1219                 when &quot;BigImm&quot;, &quot;BitImm64&quot;
1220                     outp.print &quot;args[#{index}].asTrustedImm64()&quot;
1221                 when &quot;SimpleAddr&quot;, &quot;Addr&quot;, &quot;ExtendedOffsetAddr&quot;
1222                     outp.print &quot;args[#{index}].asAddress()&quot;
1223                 when &quot;Index&quot;
1224                     outp.print &quot;args[#{index}].asBaseIndex()&quot;
1225                 when &quot;RelCond&quot;
1226                     outp.print &quot;args[#{index}].asRelationalCondition()&quot;
1227                 when &quot;ResCond&quot;
1228                     outp.print &quot;args[#{index}].asResultCondition()&quot;
1229                 when &quot;DoubleCond&quot;
1230                     outp.print &quot;args[#{index}].asDoubleCondition()&quot;
1231                 when &quot;StatusCond&quot;
1232                     outp.print &quot;args[#{index}].asStatusCondition()&quot;
1233                 end
1234             }
1235 
1236             outp.puts &quot;);&quot;
1237             outp.puts &quot;OPGEN_RETURN(result);&quot;
1238             endArchs(outp, form.archs)
1239         end
1240     }
1241     outp.puts &quot;RELEASE_ASSERT_NOT_REACHED();&quot;
1242     outp.puts &quot;return result;&quot;
1243     outp.puts &quot;}&quot;
1244 
1245     outp.puts &quot;} } } // namespace JSC::B3::Air&quot;
1246 }
1247 
    </pre>
  </body>
</html>
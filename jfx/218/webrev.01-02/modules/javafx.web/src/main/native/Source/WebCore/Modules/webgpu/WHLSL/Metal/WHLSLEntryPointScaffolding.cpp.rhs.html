<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLEntryPointScaffolding.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WHLSLEntryPointScaffolding.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
 31 #include &quot;WHLSLBuiltInSemantic.h&quot;
 32 #include &quot;WHLSLFunctionDefinition.h&quot;
 33 #include &quot;WHLSLGatherEntryPointItems.h&quot;
 34 #include &quot;WHLSLPipelineDescriptor.h&quot;
 35 #include &quot;WHLSLReferenceType.h&quot;
 36 #include &quot;WHLSLResourceSemantic.h&quot;
 37 #include &quot;WHLSLStageInOutSemantic.h&quot;
 38 #include &quot;WHLSLStructureDefinition.h&quot;
 39 #include &quot;WHLSLTypeNamer.h&quot;
 40 #include &lt;algorithm&gt;
 41 #include &lt;wtf/Optional.h&gt;
 42 #include &lt;wtf/text/StringBuilder.h&gt;
 43 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 44 
 45 namespace WebCore {
 46 
 47 namespace WHLSL {
 48 
 49 namespace Metal {
 50 
 51 static String attributeForSemantic(AST::BuiltInSemantic&amp; builtInSemantic)
 52 {
 53     switch (builtInSemantic.variable()) {
 54     case AST::BuiltInSemantic::Variable::SVInstanceID:
 55         return &quot;[[instance_id]]&quot;_str;
 56     case AST::BuiltInSemantic::Variable::SVVertexID:
 57         return &quot;[[vertex_id]]&quot;_str;
 58     case AST::BuiltInSemantic::Variable::PSize:
 59         return &quot;[[point_size]]&quot;_str;
 60     case AST::BuiltInSemantic::Variable::SVPosition:
 61         return &quot;[[position]]&quot;_str;
 62     case AST::BuiltInSemantic::Variable::SVIsFrontFace:
 63         return &quot;[[front_facing]]&quot;_str;
 64     case AST::BuiltInSemantic::Variable::SVSampleIndex:
 65         return &quot;[[sample_id]]&quot;_str;
 66     case AST::BuiltInSemantic::Variable::SVInnerCoverage:
 67         return &quot;[[sample_mask]]&quot;_str;
 68     case AST::BuiltInSemantic::Variable::SVTarget:
 69         return makeString(&quot;[[color(&quot;, *builtInSemantic.targetIndex(), &quot;)]]&quot;);
 70     case AST::BuiltInSemantic::Variable::SVDepth:
 71         return &quot;[[depth(any)]]&quot;_str;
 72     case AST::BuiltInSemantic::Variable::SVCoverage:
 73         return &quot;[[sample_mask]]&quot;_str;
 74     case AST::BuiltInSemantic::Variable::SVDispatchThreadID:
 75         return &quot;[[thread_position_in_grid]]&quot;_str;
 76     case AST::BuiltInSemantic::Variable::SVGroupID:
 77         return &quot;[[threadgroup_position_in_grid]]&quot;_str;
 78     case AST::BuiltInSemantic::Variable::SVGroupIndex:
 79         return &quot;[[thread_index_in_threadgroup]]&quot;_str;
 80     default:
 81         ASSERT(builtInSemantic.variable() == AST::BuiltInSemantic::Variable::SVGroupThreadID);
 82         return &quot;[[thread_position_in_threadgroup]]&quot;_str;
 83     }
 84 }
 85 
 86 static String attributeForSemantic(AST::Semantic&amp; semantic)
 87 {
 88     if (WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(semantic))
 89         return attributeForSemantic(WTF::get&lt;AST::BuiltInSemantic&gt;(semantic));
 90     auto&amp; stageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(semantic);
 91     return makeString(&quot;[[user(user&quot;, stageInOutSemantic.index(), &quot;)]]&quot;);
 92 }
 93 
 94 EntryPointScaffolding::EntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, EntryPointItems&amp; entryPointItems, HashMap&lt;Binding*, size_t&gt;&amp; resourceMap, Layout&amp; layout, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName)
 95     : m_functionDefinition(functionDefinition)
 96     , m_intrinsics(intrinsics)
 97     , m_typeNamer(typeNamer)
 98     , m_entryPointItems(entryPointItems)
 99     , m_resourceMap(resourceMap)
100     , m_layout(layout)
101     , m_generateNextVariableName(generateNextVariableName)
102 {
103     m_namedBindGroups.reserveInitialCapacity(m_layout.size());
104     for (size_t i = 0; i &lt; m_layout.size(); ++i) {
105         NamedBindGroup namedBindGroup;
106         namedBindGroup.structName = m_typeNamer.generateNextTypeName();
107         namedBindGroup.variableName = m_generateNextVariableName();
108         namedBindGroup.argumentBufferIndex = m_layout[i].name; // convertLayout() in GPURenderPipelineMetal.mm makes sure these don&#39;t collide.
109         namedBindGroup.namedBindings.reserveInitialCapacity(m_layout[i].bindings.size());
110         for (size_t j = 0; j &lt; m_layout[i].bindings.size(); ++j) {
111             NamedBinding namedBinding;
112             namedBinding.elementName = m_typeNamer.generateNextStructureElementName();
113             namedBinding.index = m_layout[i].bindings[j].internalName;
114             WTF::visit(WTF::makeVisitor([&amp;](UniformBufferBinding&amp; uniformBufferBinding) {
115                 LengthInformation lengthInformation { m_typeNamer.generateNextStructureElementName(), m_generateNextVariableName(), uniformBufferBinding.lengthName };
116                 namedBinding.lengthInformation = lengthInformation;
117             }, [&amp;](SamplerBinding&amp;) {
118             }, [&amp;](TextureBinding&amp;) {
119             }, [&amp;](StorageBufferBinding&amp; storageBufferBinding) {
120                 LengthInformation lengthInformation { m_typeNamer.generateNextStructureElementName(), m_generateNextVariableName(), storageBufferBinding.lengthName };
121                 namedBinding.lengthInformation = lengthInformation;
122             }), m_layout[i].bindings[j].binding);
123             namedBindGroup.namedBindings.uncheckedAppend(WTFMove(namedBinding));
124         }
125         m_namedBindGroups.uncheckedAppend(WTFMove(namedBindGroup));
126     }
127 
128     for (size_t i = 0; i &lt; m_entryPointItems.inputs.size(); ++i) {
129         if (!WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(*m_entryPointItems.inputs[i].semantic))
130             continue;
131         NamedBuiltIn namedBuiltIn;
132         namedBuiltIn.indexInEntryPointItems = i;
133         namedBuiltIn.variableName = m_generateNextVariableName();
134         m_namedBuiltIns.append(WTFMove(namedBuiltIn));
135     }
136 
137     m_parameterVariables.reserveInitialCapacity(m_functionDefinition.parameters().size());
138     for (size_t i = 0; i &lt; m_functionDefinition.parameters().size(); ++i)
139         m_parameterVariables.uncheckedAppend(m_generateNextVariableName());
140 }
141 
<a name="1" id="anc1"></a><span class="line-modified">142 void EntryPointScaffolding::emitResourceHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent, ShaderStage shaderStage)</span>
143 {
144     for (size_t i = 0; i &lt; m_layout.size(); ++i) {
145         stringBuilder.append(indent, &quot;struct &quot;, m_namedBindGroups[i].structName, &quot; {\n&quot;);
146         {
147             IndentationScope scope(indent);
148             Vector&lt;std::pair&lt;unsigned, String&gt;&gt; structItems;
149             for (size_t j = 0; j &lt; m_layout[i].bindings.size(); ++j) {
<a name="2" id="anc2"></a><span class="line-modified">150                 auto&amp; binding = m_layout[i].bindings[j];</span>
<span class="line-modified">151                 if (!binding.visibility.contains(shaderStage))</span>
152                     continue;
<a name="3" id="anc3"></a><span class="line-modified">153 </span>
<span class="line-modified">154                 auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;</span>
<span class="line-modified">155                 auto index = m_namedBindGroups[i].namedBindings[j].index;</span>
<span class="line-modified">156                 if (auto lengthInformation = m_namedBindGroups[i].namedBindings[j].lengthInformation)</span>
<span class="line-modified">157                     structItems.append(std::make_pair(lengthInformation-&gt;index, makeString(&quot;uint2 &quot;, lengthInformation-&gt;elementName, &quot; [[id(&quot;, lengthInformation-&gt;index, &quot;)]];&quot;)));</span>
<span class="line-modified">158 </span>
<span class="line-modified">159                 auto iterator = m_resourceMap.find(&amp;m_layout[i].bindings[j]);</span>
<span class="line-modified">160                 if (iterator != m_resourceMap.end()) {</span>
<span class="line-modified">161                     auto&amp; type = m_entryPointItems.inputs[iterator-&gt;value].unnamedType-&gt;unifyNode();</span>
<span class="line-modified">162                     if (is&lt;AST::UnnamedType&gt;(type) &amp;&amp; is&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(type))) {</span>
<span class="line-modified">163                         auto&amp; referenceType = downcast&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(type));</span>
<span class="line-modified">164                         auto mangledTypeName = m_typeNamer.mangledNameForType(referenceType.elementType());</span>
<span class="line-modified">165                         auto addressSpace = toString(referenceType.addressSpace());</span>
<span class="line-modified">166                         structItems.append(std::make_pair(index, makeString(addressSpace, &quot; &quot;, mangledTypeName, &quot;* &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-modified">167                     } else if (is&lt;AST::NamedType&gt;(type) &amp;&amp; is&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(type))) {</span>
<span class="line-modified">168                         auto&amp; namedType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(type));</span>
<span class="line-added">169                         auto mangledTypeName = m_typeNamer.mangledNameForType(namedType);</span>
<span class="line-added">170                         structItems.append(std::make_pair(index, makeString(mangledTypeName, &#39; &#39;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-added">171                     }</span>
<span class="line-added">172                 } else {</span>
<span class="line-added">173                     // The binding doesn&#39;t appear in the shader source.</span>
<span class="line-added">174                     // However, we must still emit a placeholder, so successive items in the argument buffer struct have the correct offset.</span>
<span class="line-added">175                     // Because the binding doesn&#39;t appear in the shader source, we don&#39;t know which exact type the bind point should have.</span>
<span class="line-added">176                     // Therefore, we must synthesize a type out of thin air.</span>
<span class="line-added">177                     WTF::visit(WTF::makeVisitor([&amp;](UniformBufferBinding) {</span>
<span class="line-added">178                         structItems.append(std::make_pair(index, makeString(&quot;constant void* &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-added">179                     }, [&amp;](SamplerBinding) {</span>
<span class="line-added">180                         structItems.append(std::make_pair(index, makeString(&quot;sampler &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-added">181                     }, [&amp;](TextureBinding) {</span>
<span class="line-added">182                         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=201384 We don&#39;t know which texture type the binding represents. This is no good very bad.</span>
<span class="line-added">183                         structItems.append(std::make_pair(index, makeString(&quot;texture2d&lt;float&gt; &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-added">184                     }, [&amp;](StorageBufferBinding) {</span>
<span class="line-added">185                         structItems.append(std::make_pair(index, makeString(&quot;device void* &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="line-added">186                     }), binding.binding);</span>
187                 }
188             }
189             std::sort(structItems.begin(), structItems.end(), [](const std::pair&lt;unsigned, String&gt;&amp; left, const std::pair&lt;unsigned, String&gt;&amp; right) {
190                 return left.first &lt; right.first;
191             });
192             for (const auto&amp; structItem : structItems)
193                 stringBuilder.append(indent, structItem.second, &#39;\n&#39;);
194         }
195         stringBuilder.append(indent, &quot;};\n\n&quot;);
196     }
197 }
198 
199 bool EntryPointScaffolding::emitResourceSignature(StringBuilder&amp; stringBuilder, IncludePrecedingComma includePrecedingComma)
200 {
201     if (!m_layout.size())
202         return false;
203 
204     if (includePrecedingComma == IncludePrecedingComma::Yes)
205         stringBuilder.append(&quot;, &quot;);
206 
207     for (size_t i = 0; i &lt; m_layout.size(); ++i) {
208         if (i)
209             stringBuilder.append(&quot;, &quot;);
210         auto&amp; namedBindGroup = m_namedBindGroups[i];
211         stringBuilder.append(&quot;device &quot;, namedBindGroup.structName, &quot;&amp; &quot;, namedBindGroup.variableName, &quot; [[buffer(&quot;, namedBindGroup.argumentBufferIndex, &quot;)]]&quot;);
212     }
213     return true;
214 }
215 
216 static StringView internalTypeForSemantic(const AST::BuiltInSemantic&amp; builtInSemantic)
217 {
218     switch (builtInSemantic.variable()) {
219     case AST::BuiltInSemantic::Variable::SVInstanceID:
220         return &quot;uint&quot;;
221     case AST::BuiltInSemantic::Variable::SVVertexID:
222         return &quot;uint&quot;;
223     case AST::BuiltInSemantic::Variable::PSize:
224         return &quot;float&quot;;
225     case AST::BuiltInSemantic::Variable::SVPosition:
226         return &quot;float4&quot;;
227     case AST::BuiltInSemantic::Variable::SVIsFrontFace:
228         return &quot;bool&quot;;
229     case AST::BuiltInSemantic::Variable::SVSampleIndex:
230         return &quot;uint&quot;;
231     case AST::BuiltInSemantic::Variable::SVInnerCoverage:
232         return &quot;uint&quot;;
233     case AST::BuiltInSemantic::Variable::SVTarget:
234         return { };
235     case AST::BuiltInSemantic::Variable::SVDepth:
236         return &quot;float&quot;;
237     case AST::BuiltInSemantic::Variable::SVCoverage:
238         return &quot;uint&quot;;
239     case AST::BuiltInSemantic::Variable::SVDispatchThreadID:
240         return &quot;uint3&quot;;
241     case AST::BuiltInSemantic::Variable::SVGroupID:
242         return &quot;uint3&quot;;
243     case AST::BuiltInSemantic::Variable::SVGroupIndex:
244         return &quot;uint&quot;;
245     default:
246         ASSERT(builtInSemantic.variable() == AST::BuiltInSemantic::Variable::SVGroupThreadID);
247         return &quot;uint3&quot;;
248     }
249 }
250 
251 bool EntryPointScaffolding::emitBuiltInsSignature(StringBuilder&amp; stringBuilder, IncludePrecedingComma includePrecedingComma)
252 {
253     if (!m_namedBuiltIns.size())
254         return false;
255 
256     if (includePrecedingComma == IncludePrecedingComma::Yes)
257         stringBuilder.append(&quot;, &quot;);
258 
259     for (size_t i = 0; i &lt; m_namedBuiltIns.size(); ++i) {
260         if (i)
261             stringBuilder.append(&quot;, &quot;);
262         auto&amp; namedBuiltIn = m_namedBuiltIns[i];
263         auto&amp; item = m_entryPointItems.inputs[namedBuiltIn.indexInEntryPointItems];
264         auto&amp; builtInSemantic = WTF::get&lt;AST::BuiltInSemantic&gt;(*item.semantic);
265         auto internalType = internalTypeForSemantic(builtInSemantic);
266         if (!internalType.isNull())
267             stringBuilder.append(internalType);
268         else
269             stringBuilder.append(m_typeNamer.mangledNameForType(*item.unnamedType));
270         stringBuilder.append(&#39; &#39;, namedBuiltIn.variableName, &#39; &#39;, attributeForSemantic(builtInSemantic));
271     }
272     return true;
273 }
274 
275 void EntryPointScaffolding::emitMangledInputPath(StringBuilder&amp; stringBuilder, Vector&lt;String&gt;&amp; path)
276 {
277     ASSERT(!path.isEmpty());
278     bool found = false;
279     AST::StructureDefinition* structureDefinition = nullptr;
280     for (size_t i = 0; i &lt; m_functionDefinition.parameters().size(); ++i) {
281         if (m_functionDefinition.parameters()[i]-&gt;name() == path[0]) {
282             stringBuilder.append(m_parameterVariables[i]);
283             auto&amp; unifyNode = m_functionDefinition.parameters()[i]-&gt;type()-&gt;unifyNode();
284             if (is&lt;AST::NamedType&gt;(unifyNode)) {
285                 auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);
286                 if (is&lt;AST::StructureDefinition&gt;(namedType))
287                     structureDefinition = &amp;downcast&lt;AST::StructureDefinition&gt;(namedType);
288             }
289             found = true;
290             break;
291         }
292     }
293     ASSERT(found);
294     for (size_t i = 1; i &lt; path.size(); ++i) {
295         ASSERT(structureDefinition);
296         auto* next = structureDefinition-&gt;find(path[i]);
297         ASSERT(next);
298         stringBuilder.append(&#39;.&#39;, m_typeNamer.mangledNameForStructureElement(*next));
299         structureDefinition = nullptr;
300         auto&amp; unifyNode = next-&gt;type().unifyNode();
301         if (is&lt;AST::NamedType&gt;(unifyNode)) {
302             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);
303             if (is&lt;AST::StructureDefinition&gt;(namedType))
304                 structureDefinition = &amp;downcast&lt;AST::StructureDefinition&gt;(namedType);
305         }
306     }
307 }
308 
309 void EntryPointScaffolding::emitMangledOutputPath(StringBuilder&amp; stringBuilder, Vector&lt;String&gt;&amp; path)
310 {
311     AST::StructureDefinition* structureDefinition = nullptr;
312     auto&amp; unifyNode = m_functionDefinition.type().unifyNode();
313     structureDefinition = &amp;downcast&lt;AST::StructureDefinition&gt;(downcast&lt;AST::NamedType&gt;(unifyNode));
314     for (auto&amp; component : path) {
315         ASSERT(structureDefinition);
316         auto* next = structureDefinition-&gt;find(component);
317         ASSERT(next);
318         stringBuilder.append(&#39;.&#39;, m_typeNamer.mangledNameForStructureElement(*next));
319         structureDefinition = nullptr;
320         auto&amp; unifyNode = next-&gt;type().unifyNode();
321         if (is&lt;AST::NamedType&gt;(unifyNode)) {
322             auto&amp; namedType = downcast&lt;AST::NamedType&gt;(unifyNode);
323             if (is&lt;AST::StructureDefinition&gt;(namedType))
324                 structureDefinition = &amp;downcast&lt;AST::StructureDefinition&gt;(namedType);
325         }
326     }
327 }
328 
329 void EntryPointScaffolding::emitUnpackResourcesAndNamedBuiltIns(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)
330 {
331     for (size_t i = 0; i &lt; m_functionDefinition.parameters().size(); ++i)
332         stringBuilder.append(indent, m_typeNamer.mangledNameForType(*m_functionDefinition.parameters()[i]-&gt;type()), &#39; &#39;, m_parameterVariables[i], &quot;;\n&quot;);
333 
334     for (size_t i = 0; i &lt; m_layout.size(); ++i) {
335         auto variableName = m_namedBindGroups[i].variableName;
336         for (size_t j = 0; j &lt; m_layout[i].bindings.size(); ++j) {
337             auto iterator = m_resourceMap.find(&amp;m_layout[i].bindings[j]);
338             if (iterator == m_resourceMap.end())
339                 continue;
340             if (m_namedBindGroups[i].namedBindings[j].lengthInformation) {
341                 auto&amp; path = m_entryPointItems.inputs[iterator-&gt;value].path;
342                 auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;
343                 auto lengthElementName = m_namedBindGroups[i].namedBindings[j].lengthInformation-&gt;elementName;
344                 auto lengthTemporaryName = m_namedBindGroups[i].namedBindings[j].lengthInformation-&gt;temporaryName;
345 
346                 auto&amp; unnamedType = *m_entryPointItems.inputs[iterator-&gt;value].unnamedType;
347                 auto mangledTypeName = m_typeNamer.mangledNameForType(downcast&lt;AST::ReferenceType&gt;(unnamedType).elementType());
348 
349                 stringBuilder.append(
350                     indent, &quot;size_t &quot;, lengthTemporaryName, &quot; = &quot;, variableName, &#39;.&#39;, lengthElementName, &quot;.y;\n&quot;,
351                     indent, lengthTemporaryName, &quot; = &quot;, lengthTemporaryName, &quot; &lt;&lt; 32;\n&quot;,
352                     indent, lengthTemporaryName, &quot; = &quot;, lengthTemporaryName, &quot; | &quot;, variableName, &#39;.&#39;, lengthElementName, &quot;.x;\n&quot;,
353                     indent, lengthTemporaryName, &quot; = &quot;, lengthTemporaryName, &quot; / sizeof(&quot;, mangledTypeName, &quot;);\n&quot;,
354                     indent, &quot;if (&quot;, lengthTemporaryName, &quot; &gt; 0xFFFFFFFF)\n&quot;,
355                     indent, &quot;    &quot;, lengthTemporaryName, &quot; = 0xFFFFFFFF;\n&quot;
356                 );
357 
358                 stringBuilder.append(indent);
359                 emitMangledInputPath(stringBuilder, path);
360                 stringBuilder.append(
361                     &quot; = { &quot;, variableName, &#39;.&#39;, elementName, &quot;, static_cast&lt;uint32_t&gt;(&quot;, lengthTemporaryName, &quot;) };\n&quot;
362                 );
363             } else {
364                 auto&amp; path = m_entryPointItems.inputs[iterator-&gt;value].path;
365                 auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;
366 
367                 stringBuilder.append(indent);
368                 emitMangledInputPath(stringBuilder, path);
369                 stringBuilder.append(&quot; = &quot;, variableName, &#39;.&#39;, elementName, &quot;;\n&quot;);
370             }
371         }
372     }
373 
374     for (auto&amp; namedBuiltIn : m_namedBuiltIns) {
375         auto&amp; item = m_entryPointItems.inputs[namedBuiltIn.indexInEntryPointItems];
376         auto&amp; path = item.path;
377         auto&amp; variableName = namedBuiltIn.variableName;
378         auto mangledTypeName = m_typeNamer.mangledNameForType(*item.unnamedType);
379 
380         stringBuilder.append(indent);
381         emitMangledInputPath(stringBuilder, path);
382         stringBuilder.append(&quot; = &quot;, mangledTypeName, &#39;(&#39;, variableName, &quot;);\n&quot;);
383     }
384 }
385 
386 VertexEntryPointScaffolding::VertexEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, EntryPointItems&amp; entryPointItems, HashMap&lt;Binding*, size_t&gt;&amp; resourceMap, Layout&amp; layout, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName, HashMap&lt;VertexAttribute*, size_t&gt;&amp; matchedVertexAttributes)
387     : EntryPointScaffolding(functionDefinition, intrinsics, typeNamer, entryPointItems, resourceMap, layout, WTFMove(generateNextVariableName))
388     , m_matchedVertexAttributes(matchedVertexAttributes)
389     , m_stageInStructName(typeNamer.generateNextTypeName())
390     , m_returnStructName(typeNamer.generateNextTypeName())
391     , m_stageInParameterName(m_generateNextVariableName())
392 {
393     m_namedStageIns.reserveInitialCapacity(m_matchedVertexAttributes.size());
394     for (auto&amp; keyValuePair : m_matchedVertexAttributes) {
395         NamedStageIn namedStageIn;
396         namedStageIn.indexInEntryPointItems = keyValuePair.value;
397         namedStageIn.elementName = m_typeNamer.generateNextStructureElementName();
398         namedStageIn.attributeIndex = keyValuePair.key-&gt;metalLocation;
399         m_namedStageIns.uncheckedAppend(WTFMove(namedStageIn));
400     }
401 
402     m_namedOutputs.reserveInitialCapacity(m_entryPointItems.outputs.size());
403     for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {
404         auto&amp; outputItem = m_entryPointItems.outputs[i];
405         NamedOutput namedOutput;
406         namedOutput.elementName = m_typeNamer.generateNextStructureElementName();
407         StringView internalType;
408         if (WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(*outputItem.semantic))
409             internalType = internalTypeForSemantic(WTF::get&lt;AST::BuiltInSemantic&gt;(*outputItem.semantic));
410         if (!internalType.isNull())
411             namedOutput.internalTypeName = internalType.toString();
412         else
413             namedOutput.internalTypeName = m_typeNamer.mangledNameForType(*outputItem.unnamedType);
414         m_namedOutputs.uncheckedAppend(WTFMove(namedOutput));
415     }
416 }
417 
418 void VertexEntryPointScaffolding::emitHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)
419 {
420     stringBuilder.append(indent, &quot;struct &quot;, m_stageInStructName, &quot; {\n&quot;);
421     {
422         IndentationScope scope(indent);
423         for (auto&amp; namedStageIn : m_namedStageIns) {
424             auto mangledTypeName = m_typeNamer.mangledNameForType(*m_entryPointItems.inputs[namedStageIn.indexInEntryPointItems].unnamedType);
425             auto elementName = namedStageIn.elementName;
426             auto attributeIndex = namedStageIn.attributeIndex;
427             stringBuilder.append(indent, mangledTypeName, &#39; &#39;, elementName, &quot; [[attribute(&quot;, attributeIndex, &quot;)]];\n&quot;);
428         }
429     }
430     stringBuilder.append(
431         indent, &quot;};\n\n&quot;,
432         indent, &quot;struct &quot;, m_returnStructName, &quot; {\n&quot;
433     );
434     {
435         IndentationScope scope(indent);
436         for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {
437             auto&amp; outputItem = m_entryPointItems.outputs[i];
438             auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;
439             auto elementName = m_namedOutputs[i].elementName;
440             auto attribute = attributeForSemantic(*outputItem.semantic);
441             stringBuilder.append(indent, internalTypeName, &#39; &#39;, elementName, &#39; &#39;, attribute, &quot;;\n&quot;);
442         }
443     }
444     stringBuilder.append(indent, &quot;};\n\n&quot;);
445 
<a name="4" id="anc4"></a><span class="line-modified">446     emitResourceHelperTypes(stringBuilder, indent, ShaderStage::Vertex);</span>
447 }
448 
449 void VertexEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)
450 {
451     stringBuilder.append(indent, &quot;vertex &quot;, m_returnStructName, &#39; &#39;, functionName, &#39;(&#39;, m_stageInStructName, &#39; &#39;, m_stageInParameterName, &quot; [[stage_in]]&quot;);
452     emitResourceSignature(stringBuilder, IncludePrecedingComma::Yes);
453     emitBuiltInsSignature(stringBuilder, IncludePrecedingComma::Yes);
454     stringBuilder.append(&quot;)\n&quot;);
455 }
456 
457 void VertexEntryPointScaffolding::emitUnpack(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)
458 {
459     emitUnpackResourcesAndNamedBuiltIns(stringBuilder, indent);
460 
461     for (auto&amp; namedStageIn : m_namedStageIns) {
462         auto&amp; path = m_entryPointItems.inputs[namedStageIn.indexInEntryPointItems].path;
463         auto&amp; elementName = namedStageIn.elementName;
464 
465         stringBuilder.append(indent);
466         emitMangledInputPath(stringBuilder, path);
467         stringBuilder.append(&quot; = &quot;, m_stageInParameterName, &#39;.&#39;, elementName, &quot;;\n&quot;);
468     }
469 }
470 
471 void VertexEntryPointScaffolding::emitPack(StringBuilder&amp; stringBuilder, MangledVariableName inputVariableName, MangledVariableName outputVariableName, Indentation&lt;4&gt; indent)
472 {
473     stringBuilder.append(indent, m_returnStructName, &#39; &#39;, outputVariableName, &quot;;\n&quot;);
474     if (m_entryPointItems.outputs.size() == 1 &amp;&amp; !m_entryPointItems.outputs[0].path.size()) {
475         auto&amp; elementName = m_namedOutputs[0].elementName;
476         stringBuilder.append(indent, outputVariableName, &#39;.&#39;, elementName, &quot; = &quot;, inputVariableName, &quot;;\n&quot;);
477         return;
478     }
479     for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {
480         auto&amp; elementName = m_namedOutputs[i].elementName;
481         auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;
482         auto&amp; path = m_entryPointItems.outputs[i].path;
483         stringBuilder.append(indent, outputVariableName, &#39;.&#39;, elementName, &quot; = &quot;, internalTypeName, &#39;(&#39;, inputVariableName);
484         emitMangledOutputPath(stringBuilder, path);
485         stringBuilder.append(&quot;);\n&quot;);
486     }
487 }
488 
489 FragmentEntryPointScaffolding::FragmentEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, EntryPointItems&amp; entryPointItems, HashMap&lt;Binding*, size_t&gt;&amp; resourceMap, Layout&amp; layout, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName, HashMap&lt;AttachmentDescriptor*, size_t&gt;&amp;)
490     : EntryPointScaffolding(functionDefinition, intrinsics, typeNamer, entryPointItems, resourceMap, layout, WTFMove(generateNextVariableName))
491     , m_stageInStructName(typeNamer.generateNextTypeName())
492     , m_returnStructName(typeNamer.generateNextTypeName())
493     , m_stageInParameterName(m_generateNextVariableName())
494 {
495     for (size_t i = 0; i &lt; m_entryPointItems.inputs.size(); ++i) {
496         auto&amp; inputItem = m_entryPointItems.inputs[i];
497         if (!WTF::holds_alternative&lt;AST::StageInOutSemantic&gt;(*inputItem.semantic))
498             continue;
499         auto&amp; stageInOutSemantic = WTF::get&lt;AST::StageInOutSemantic&gt;(*inputItem.semantic);
500         NamedStageIn namedStageIn;
501         namedStageIn.indexInEntryPointItems = i;
502         namedStageIn.elementName = m_typeNamer.generateNextStructureElementName();
503         namedStageIn.attributeIndex = stageInOutSemantic.index();
504         m_namedStageIns.append(WTFMove(namedStageIn));
505     }
506 
507     m_namedOutputs.reserveInitialCapacity(m_entryPointItems.outputs.size());
508     for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {
509         auto&amp; outputItem = m_entryPointItems.outputs[i];
510         NamedOutput namedOutput;
511         namedOutput.elementName = m_typeNamer.generateNextStructureElementName();
512         StringView internalType;
513         if (WTF::holds_alternative&lt;AST::BuiltInSemantic&gt;(*outputItem.semantic))
514             internalType = internalTypeForSemantic(WTF::get&lt;AST::BuiltInSemantic&gt;(*outputItem.semantic));
515         if (!internalType.isNull())
516             namedOutput.internalTypeName = internalType.toString();
517         else
518             namedOutput.internalTypeName = m_typeNamer.mangledNameForType(*outputItem.unnamedType);
519         m_namedOutputs.uncheckedAppend(WTFMove(namedOutput));
520     }
521 }
522 
523 void FragmentEntryPointScaffolding::emitHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)
524 {
525     stringBuilder.append(indent, &quot;struct &quot;, m_stageInStructName, &quot; {\n&quot;);
526     {
527         IndentationScope scope(indent);
528         for (auto&amp; namedStageIn : m_namedStageIns) {
529             auto mangledTypeName = m_typeNamer.mangledNameForType(*m_entryPointItems.inputs[namedStageIn.indexInEntryPointItems].unnamedType);
530             auto elementName = namedStageIn.elementName;
531             auto attributeIndex = namedStageIn.attributeIndex;
532             stringBuilder.append(indent, mangledTypeName, &#39; &#39;, elementName, &quot; [[user(user&quot;, attributeIndex, &quot;)]];\n&quot;);
533         }
534     }
535     stringBuilder.append(
536         indent, &quot;};\n\n&quot;,
537         indent, &quot;struct &quot;, m_returnStructName, &quot; {\n&quot;
538     );
539     {
540         IndentationScope scope(indent);
541         for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {
542             auto&amp; outputItem = m_entryPointItems.outputs[i];
543             auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;
544             auto elementName = m_namedOutputs[i].elementName;
545             auto attribute = attributeForSemantic(*outputItem.semantic);
546             stringBuilder.append(indent, internalTypeName, &#39; &#39;, elementName, &#39; &#39;, attribute, &quot;;\n&quot;);
547         }
548     }
549     stringBuilder.append(indent, &quot;};\n\n&quot;);
550 
<a name="5" id="anc5"></a><span class="line-modified">551     emitResourceHelperTypes(stringBuilder, indent, ShaderStage::Fragment);</span>
552 }
553 
554 void FragmentEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)
555 {
556     stringBuilder.append(indent, &quot;fragment &quot;, m_returnStructName, &#39; &#39;, functionName, &#39;(&#39;, m_stageInStructName, &#39; &#39;, m_stageInParameterName, &quot; [[stage_in]]&quot;);
557     emitResourceSignature(stringBuilder, IncludePrecedingComma::Yes);
558     emitBuiltInsSignature(stringBuilder, IncludePrecedingComma::Yes);
559     stringBuilder.append(&quot;)\n&quot;);
560 }
561 
562 void FragmentEntryPointScaffolding::emitUnpack(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)
563 {
564     emitUnpackResourcesAndNamedBuiltIns(stringBuilder, indent);
565 
566     for (auto&amp; namedStageIn : m_namedStageIns) {
567         auto&amp; path = m_entryPointItems.inputs[namedStageIn.indexInEntryPointItems].path;
568         auto&amp; elementName = namedStageIn.elementName;
569 
570         stringBuilder.append(indent);
571         emitMangledInputPath(stringBuilder, path);
572         stringBuilder.append(&quot; = &quot;, m_stageInParameterName, &#39;.&#39;, elementName, &quot;;\n&quot;);
573     }
574 }
575 
576 void FragmentEntryPointScaffolding::emitPack(StringBuilder&amp; stringBuilder, MangledVariableName inputVariableName, MangledVariableName outputVariableName, Indentation&lt;4&gt; indent)
577 {
578     stringBuilder.append(indent, m_returnStructName, &#39; &#39;, outputVariableName, &quot;;\n&quot;);
579     if (m_entryPointItems.outputs.size() == 1 &amp;&amp; !m_entryPointItems.outputs[0].path.size()) {
580         auto&amp; elementName = m_namedOutputs[0].elementName;
581         stringBuilder.append(indent, outputVariableName, &#39;.&#39;, elementName, &quot; = &quot;, inputVariableName, &quot;;\n&quot;);
582         return;
583     }
584     for (size_t i = 0; i &lt; m_entryPointItems.outputs.size(); ++i) {
585         auto&amp; elementName = m_namedOutputs[i].elementName;
586         auto&amp; internalTypeName = m_namedOutputs[i].internalTypeName;
587         auto&amp; path = m_entryPointItems.outputs[i].path;
588         stringBuilder.append(indent, outputVariableName, &#39;.&#39;, elementName, &quot; = &quot;, internalTypeName, &#39;(&#39;, inputVariableName);
589         emitMangledOutputPath(stringBuilder, path);
590         stringBuilder.append(&quot;);\n&quot;);
591     }
592 }
593 
594 ComputeEntryPointScaffolding::ComputeEntryPointScaffolding(AST::FunctionDefinition&amp; functionDefinition, Intrinsics&amp; intrinsics, TypeNamer&amp; typeNamer, EntryPointItems&amp; entryPointItems, HashMap&lt;Binding*, size_t&gt;&amp; resourceMap, Layout&amp; layout, std::function&lt;MangledVariableName()&gt;&amp;&amp; generateNextVariableName)
595     : EntryPointScaffolding(functionDefinition, intrinsics, typeNamer, entryPointItems, resourceMap, layout, WTFMove(generateNextVariableName))
596 {
597 }
598 
599 void ComputeEntryPointScaffolding::emitHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)
600 {
<a name="6" id="anc6"></a><span class="line-modified">601     emitResourceHelperTypes(stringBuilder, indent, ShaderStage::Compute);</span>
602 }
603 
604 void ComputeEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)
605 {
606     stringBuilder.append(indent, &quot;kernel void &quot;, functionName, &#39;(&#39;);
607     bool addedToSignature = emitResourceSignature(stringBuilder, IncludePrecedingComma::No);
608     emitBuiltInsSignature(stringBuilder, addedToSignature ? IncludePrecedingComma::Yes : IncludePrecedingComma::No);
609     stringBuilder.append(&quot;)\n&quot;);
610 }
611 
612 void ComputeEntryPointScaffolding::emitUnpack(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)
613 {
614     emitUnpackResourcesAndNamedBuiltIns(stringBuilder, indent);
615 }
616 
617 void ComputeEntryPointScaffolding::emitPack(StringBuilder&amp;, MangledVariableName, MangledVariableName, Indentation&lt;4&gt;)
618 {
619     ASSERT_NOT_REACHED();
620 }
621 
622 }
623 
624 }
625 
626 }
627 
628 #endif
<a name="7" id="anc7"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="7" type="hidden" />
</body>
</html>
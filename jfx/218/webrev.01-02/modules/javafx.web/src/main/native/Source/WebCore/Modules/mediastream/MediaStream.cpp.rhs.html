<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/mediastream/MediaStream.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  * Copyright (C) 2011, 2012, 2015 Ericsson AB. All rights reserved.
  4  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  5  * Copyright (C) 2013 Nokia Corporation and/or its subsidiary(-ies).
  6  *
  7  * Redistribution and use in source and binary forms, with or without
  8  * modification, are permitted provided that the following conditions
  9  * are met:
 10  * 1.  Redistributions of source code must retain the above copyright
 11  *     notice, this list of conditions and the following disclaimer.
 12  * 2.  Redistributions in binary form must reproduce the above copyright
 13  *     notice, this list of conditions and the following disclaimer in the
 14  *     documentation and/or other materials provided with the distribution.
 15  *
 16  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 17  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 18  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 19  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 20  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 21  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 22  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 23  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 25  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;MediaStream.h&quot;
 30 
 31 #if ENABLE(MEDIA_STREAM)
 32 
 33 #include &quot;Document.h&quot;
 34 #include &quot;Event.h&quot;
 35 #include &quot;EventNames.h&quot;
 36 #include &quot;Frame.h&quot;
 37 #include &quot;FrameLoader.h&quot;
 38 #include &quot;Logging.h&quot;
 39 #include &quot;MediaStreamTrackEvent.h&quot;
 40 #include &quot;NetworkingContext.h&quot;
 41 #include &quot;Page.h&quot;
 42 #include &quot;RealtimeMediaSource.h&quot;
 43 #include &lt;wtf/IsoMallocInlines.h&gt;
 44 #include &lt;wtf/URL.h&gt;
 45 
 46 namespace WebCore {
 47 
 48 WTF_MAKE_ISO_ALLOCATED_IMPL(MediaStream);
 49 
 50 Ref&lt;MediaStream&gt; MediaStream::create(Document&amp; document)
 51 {
 52     return MediaStream::create(document, MediaStreamPrivate::create(document.logger(), { }));
 53 }
 54 
 55 Ref&lt;MediaStream&gt; MediaStream::create(Document&amp; document, MediaStream&amp; stream)
 56 {
 57     return adoptRef(*new MediaStream(document, stream.getTracks()));
 58 }
 59 
 60 Ref&lt;MediaStream&gt; MediaStream::create(Document&amp; document, const MediaStreamTrackVector&amp; tracks)
 61 {
 62     return adoptRef(*new MediaStream(document, tracks));
 63 }
 64 
 65 Ref&lt;MediaStream&gt; MediaStream::create(Document&amp; document, Ref&lt;MediaStreamPrivate&gt;&amp;&amp; streamPrivate)
 66 {
 67     return adoptRef(*new MediaStream(document, WTFMove(streamPrivate)));
 68 }
 69 
 70 static inline MediaStreamTrackPrivateVector createTrackPrivateVector(const MediaStreamTrackVector&amp; tracks)
 71 {
 72     MediaStreamTrackPrivateVector trackPrivates;
 73     trackPrivates.reserveCapacity(tracks.size());
 74     for (auto&amp; track : tracks)
 75         trackPrivates.append(&amp;track-&gt;privateTrack());
 76     return trackPrivates;
 77 }
 78 
 79 MediaStream::MediaStream(Document&amp; document, const MediaStreamTrackVector&amp; tracks)
 80     : ActiveDOMObject(document)
 81     , m_private(MediaStreamPrivate::create(document.logger(), createTrackPrivateVector(tracks)))
<a name="1" id="anc1"></a>
 82 {
 83     // This constructor preserves MediaStreamTrack instances and must be used by calls originating
 84     // from the JavaScript MediaStream constructor.
 85 
 86     for (auto&amp; track : tracks) {
 87         track-&gt;addObserver(*this);
 88         m_trackSet.add(track-&gt;id(), track);
 89     }
 90 
 91     setIsActive(m_private-&gt;active());
 92     m_private-&gt;addObserver(*this);
 93     suspendIfNeeded();
 94 }
 95 
 96 MediaStream::MediaStream(Document&amp; document, Ref&lt;MediaStreamPrivate&gt;&amp;&amp; streamPrivate)
 97     : ActiveDOMObject(document)
 98     , m_private(WTFMove(streamPrivate))
<a name="2" id="anc2"></a>
 99 {
100     ALWAYS_LOG(LOGIDENTIFIER);
101 
<a name="3" id="anc3"></a>


102     for (auto&amp; trackPrivate : m_private-&gt;tracks()) {
103         auto track = MediaStreamTrack::create(document, *trackPrivate);
104         track-&gt;addObserver(*this);
105         m_trackSet.add(track-&gt;id(), WTFMove(track));
106     }
<a name="4" id="anc4"></a><span class="line-added">107 </span>
<span class="line-added">108     setIsActive(m_private-&gt;active());</span>
<span class="line-added">109     m_private-&gt;addObserver(*this);</span>
110     suspendIfNeeded();
111 }
112 
113 MediaStream::~MediaStream()
114 {
115     // Set isActive to false immediately so any callbacks triggered by shutting down, e.g.
116     // mediaState(), are short circuited.
117     m_isActive = false;
118     m_private-&gt;removeObserver(*this);
119     for (auto&amp; track : m_trackSet.values())
120         track-&gt;removeObserver(*this);
121     if (Document* document = this-&gt;document()) {
122         if (m_isWaitingUntilMediaCanStart)
123             document-&gt;removeMediaCanStartListener(*this);
124     }
125 }
126 
127 RefPtr&lt;MediaStream&gt; MediaStream::clone()
128 {
129     ALWAYS_LOG(LOGIDENTIFIER);
130 
131     MediaStreamTrackVector clonedTracks;
132     clonedTracks.reserveInitialCapacity(m_trackSet.size());
133 
134     for (auto&amp; track : m_trackSet.values())
135         clonedTracks.uncheckedAppend(track-&gt;clone());
136 
137     return MediaStream::create(*document(), clonedTracks);
138 }
139 
140 void MediaStream::addTrack(MediaStreamTrack&amp; track)
141 {
142     ALWAYS_LOG(LOGIDENTIFIER, track.logIdentifier());
143 
144     if (!internalAddTrack(track, StreamModifier::DomAPI))
145         return;
146 
147     for (auto&amp; observer : m_observers)
148         observer-&gt;didAddOrRemoveTrack();
149 }
150 
151 void MediaStream::removeTrack(MediaStreamTrack&amp; track)
152 {
153     ALWAYS_LOG(LOGIDENTIFIER, track.logIdentifier());
154 
155     if (!internalRemoveTrack(track.id(), StreamModifier::DomAPI))
156         return;
157 
158     for (auto&amp; observer : m_observers)
159         observer-&gt;didAddOrRemoveTrack();
160 }
161 
162 MediaStreamTrack* MediaStream::getTrackById(String id)
163 {
164     auto it = m_trackSet.find(id);
165     if (it != m_trackSet.end())
166         return it-&gt;value.get();
167 
168     return nullptr;
169 }
170 
171 MediaStreamTrackVector MediaStream::getAudioTracks() const
172 {
173     return trackVectorForType(RealtimeMediaSource::Type::Audio);
174 }
175 
176 MediaStreamTrackVector MediaStream::getVideoTracks() const
177 {
178     return trackVectorForType(RealtimeMediaSource::Type::Video);
179 }
180 
181 MediaStreamTrackVector MediaStream::getTracks() const
182 {
183     return copyToVector(m_trackSet.values());
184 }
185 
186 void MediaStream::trackDidEnd()
187 {
188     m_private-&gt;updateActiveState(MediaStreamPrivate::NotifyClientOption::Notify);
189 }
190 
191 void MediaStream::activeStatusChanged()
192 {
193     updateActiveState();
194 }
195 
196 void MediaStream::didAddTrack(MediaStreamTrackPrivate&amp; trackPrivate)
197 {
198     ScriptExecutionContext* context = scriptExecutionContext();
199     if (!context)
200         return;
201 
202     if (!getTrackById(trackPrivate.id()))
203         internalAddTrack(MediaStreamTrack::create(*context, trackPrivate), StreamModifier::Platform);
204 }
205 
206 void MediaStream::didRemoveTrack(MediaStreamTrackPrivate&amp; trackPrivate)
207 {
208     internalRemoveTrack(trackPrivate.id(), StreamModifier::Platform);
209 }
210 
211 void MediaStream::addTrackFromPlatform(Ref&lt;MediaStreamTrack&gt;&amp;&amp; track)
212 {
213     ALWAYS_LOG(LOGIDENTIFIER, track-&gt;logIdentifier());
214 
215     auto* privateTrack = &amp;track-&gt;privateTrack();
216     internalAddTrack(WTFMove(track), StreamModifier::Platform);
217     m_private-&gt;addTrack(privateTrack, MediaStreamPrivate::NotifyClientOption::Notify);
218 }
219 
220 bool MediaStream::internalAddTrack(Ref&lt;MediaStreamTrack&gt;&amp;&amp; trackToAdd, StreamModifier streamModifier)
221 {
222     auto result = m_trackSet.add(trackToAdd-&gt;id(), WTFMove(trackToAdd));
223     if (!result.isNewEntry)
224         return false;
225 
226     ASSERT(result.iterator-&gt;value);
227     auto&amp; track = *result.iterator-&gt;value;
228     track.addObserver(*this);
229 
230     updateActiveState();
231 
232     if (streamModifier == StreamModifier::DomAPI)
233         m_private-&gt;addTrack(&amp;track.privateTrack(), MediaStreamPrivate::NotifyClientOption::DontNotify);
234     else
235         dispatchEvent(MediaStreamTrackEvent::create(eventNames().addtrackEvent, Event::CanBubble::No, Event::IsCancelable::No, &amp;track));
236 
237     return true;
238 }
239 
240 bool MediaStream::internalRemoveTrack(const String&amp; trackId, StreamModifier streamModifier)
241 {
242     auto track = m_trackSet.take(trackId);
243     if (!track)
244         return false;
245 
246     track-&gt;removeObserver(*this);
247 
248     updateActiveState();
249 
250     if (streamModifier == StreamModifier::DomAPI)
251         m_private-&gt;removeTrack(track-&gt;privateTrack(), MediaStreamPrivate::NotifyClientOption::DontNotify);
252     else
253         dispatchEvent(MediaStreamTrackEvent::create(eventNames().removetrackEvent, Event::CanBubble::No, Event::IsCancelable::No, WTFMove(track)));
254 
255     return true;
256 }
257 
258 void MediaStream::setIsActive(bool active)
259 {
260     if (m_isActive == active)
261         return;
262 
263     ALWAYS_LOG(LOGIDENTIFIER, active);
264 
265     m_isActive = active;
266     statusDidChange();
267 }
268 
269 void MediaStream::mediaCanStart(Document&amp; document)
270 {
271     ALWAYS_LOG(LOGIDENTIFIER);
272 
273     ASSERT_UNUSED(document, &amp;document == this-&gt;document());
274     ASSERT(m_isWaitingUntilMediaCanStart);
275     if (m_isWaitingUntilMediaCanStart) {
276         m_isWaitingUntilMediaCanStart = false;
277         startProducingData();
278     }
279 }
280 
281 void MediaStream::startProducingData()
282 {
283     Document* document = this-&gt;document();
284     if (!document || !document-&gt;page())
285         return;
286 
287     ALWAYS_LOG(LOGIDENTIFIER);
288 
289     // If we can&#39;t start a load right away, start it later.
290     if (!document-&gt;page()-&gt;canStartMedia()) {
291         ALWAYS_LOG(LOGIDENTIFIER, &quot;not allowed to start in background, waiting&quot;);
292         if (m_isWaitingUntilMediaCanStart)
293             return;
294 
295         m_isWaitingUntilMediaCanStart = true;
296         document-&gt;addMediaCanStartListener(*this);
297         return;
298     }
299 
300     if (m_isProducingData)
301         return;
302     m_isProducingData = true;
<a name="5" id="anc5"></a>

303     m_private-&gt;startProducingData();
304 }
305 
306 void MediaStream::stopProducingData()
307 {
<a name="6" id="anc6"></a><span class="line-added">308     ALWAYS_LOG(LOGIDENTIFIER);</span>
<span class="line-added">309 </span>
310     if (!m_isProducingData)
311         return;
312 
<a name="7" id="anc7"></a>

313     m_isProducingData = false;
<a name="8" id="anc8"></a>


314     m_private-&gt;stopProducingData();
315 }
316 
317 MediaProducer::MediaStateFlags MediaStream::mediaState() const
318 {
319     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
320 
321     if (!m_isActive || !document() || !document()-&gt;page())
322         return state;
323 
324     for (const auto&amp; track : m_trackSet.values())
325         state |= track-&gt;mediaState();
326 
327     return state;
328 }
329 
330 void MediaStream::statusDidChange()
331 {
<a name="9" id="anc9"></a><span class="line-modified">332     if (auto* document = this-&gt;document()) {</span>


333         if (!m_isActive)
334             return;
335         document-&gt;updateIsPlayingMedia();
336     }
337 }
338 
339 void MediaStream::characteristicsChanged()
340 {
341     auto state = mediaState();
342     if (m_state != state) {
343         m_state = state;
344         statusDidChange();
345     }
346 }
347 
348 void MediaStream::updateActiveState()
349 {
350     bool active = false;
351     for (auto&amp; track : m_trackSet.values()) {
352         if (!track-&gt;ended()) {
353             active = true;
354             break;
355         }
356     }
357 
358     if (m_isActive == active)
359         return;
360 
361     setIsActive(active);
362 }
363 
364 MediaStreamTrackVector MediaStream::trackVectorForType(RealtimeMediaSource::Type filterType) const
365 {
366     MediaStreamTrackVector tracks;
367     for (auto&amp; track : m_trackSet.values()) {
368         if (track-&gt;source().type() == filterType)
369             tracks.append(track);
370     }
371 
372     return tracks;
373 }
374 
375 void MediaStream::addObserver(MediaStream::Observer* observer)
376 {
377     if (m_observers.find(observer) == notFound)
378         m_observers.append(observer);
379 }
380 
381 void MediaStream::removeObserver(MediaStream::Observer* observer)
382 {
383     size_t pos = m_observers.find(observer);
384     if (pos != notFound)
385         m_observers.remove(pos);
386 }
387 
388 Document* MediaStream::document() const
389 {
390     return downcast&lt;Document&gt;(scriptExecutionContext());
391 }
392 
<a name="10" id="anc10"></a>





























































393 void MediaStream::stop()
394 {
395     m_isActive = false;
396 }
397 
398 const char* MediaStream::activeDOMObjectName() const
399 {
400     return &quot;MediaStream&quot;;
401 }
402 
<a name="11" id="anc11"></a>




403 bool MediaStream::hasPendingActivity() const
404 {
405     return m_isActive;
406 }
407 
408 #if !RELEASE_LOG_DISABLED
409 WTFLogChannel&amp; MediaStream::logChannel() const
410 {
411     return LogWebRTC;
412 }
413 #endif
414 
415 } // namespace WebCore
416 
417 #endif // ENABLE(MEDIA_STREAM)
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
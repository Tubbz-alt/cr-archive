<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/scripts/codegen/cpp_generator.py</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 #!/usr/bin/env python
  2 #
  3 # Copyright (c) 2014-2018 Apple Inc. All rights reserved.
  4 # Copyright (c) 2014 University of Washington. All rights reserved.
  5 #
  6 # Redistribution and use in source and binary forms, with or without
  7 # modification, are permitted provided that the following conditions
  8 # are met:
  9 # 1. Redistributions of source code must retain the above copyright
 10 #    notice, this list of conditions and the following disclaimer.
 11 # 2. Redistributions in binary form must reproduce the above copyright
 12 #    notice, this list of conditions and the following disclaimer in the
 13 #    documentation and/or other materials provided with the distribution.
 14 #
 15 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 16 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 17 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 19 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 20 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 21 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 22 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 23 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 24 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 25 # THE POSSIBILITY OF SUCH DAMAGE.
 26 
 27 import logging
 28 import os.path
 29 import re
 30 
 31 try:
 32     from .generator import ucfirst, Generator
 33     from .models import PrimitiveType, ObjectType, ArrayType, EnumType, AliasedType, Frameworks
 34 except ValueError:
 35     from generator import ucfirst, Generator
 36     from models import PrimitiveType, ObjectType, ArrayType, EnumType, AliasedType, Frameworks
 37 
 38 log = logging.getLogger(&#39;global&#39;)
 39 
 40 _PRIMITIVE_TO_CPP_NAME_MAP = {
 41     &#39;boolean&#39;: &#39;bool&#39;,
 42     &#39;integer&#39;: &#39;int&#39;,
 43     &#39;number&#39;: &#39;double&#39;,
 44     &#39;string&#39;: &#39;String&#39;,
 45     &#39;object&#39;: &#39;JSON::Object&#39;,
 46     &#39;array&#39;: &#39;JSON::Array&#39;,
 47     &#39;any&#39;: &#39;JSON::Value&#39;
 48 }
 49 
 50 class CppGenerator(Generator):
 51     def __init__(self, *args, **kwargs):
 52         Generator.__init__(self, *args, **kwargs)
 53 
 54     def protocol_name(self):
 55         return self.model().framework.setting(&#39;cpp_protocol_group&#39;, &#39;&#39;)
 56 
 57     def helpers_namespace(self):
 58         return &#39;%sHelpers&#39; % self.protocol_name()
 59 
 60     # Miscellaneous text manipulation routines.
 61     @staticmethod
 62     def cpp_getter_method_for_type(_type):
 63         if isinstance(_type, ObjectType):
 64             return &#39;getObject&#39;
 65         if isinstance(_type, ArrayType):
 66             return &#39;getArray&#39;
 67         if isinstance(_type, PrimitiveType):
 68             if _type.raw_name() is &#39;integer&#39;:
 69                 return &#39;getInteger&#39;
 70             elif _type.raw_name() is &#39;number&#39;:
 71                 return &#39;getDouble&#39;
 72             elif _type.raw_name() is &#39;any&#39;:
 73                 return &#39;getValue&#39;
 74             else:
 75                 return &#39;get&#39; + ucfirst(_type.raw_name())
 76         if isinstance(_type, AliasedType):
 77             return CppGenerator.cpp_getter_method_for_type(_type.aliased_type)
 78         if isinstance(_type, EnumType):
 79             return CppGenerator.cpp_getter_method_for_type(_type.primitive_type)
 80 
 81     @staticmethod
 82     def cpp_setter_method_for_type(_type):
 83         if isinstance(_type, ObjectType):
 84             return &#39;setObject&#39;
 85         if isinstance(_type, ArrayType):
 86             return &#39;setArray&#39;
 87         if isinstance(_type, PrimitiveType):
 88             if _type.raw_name() is &#39;integer&#39;:
 89                 return &#39;setInteger&#39;
 90             elif _type.raw_name() is &#39;number&#39;:
 91                 return &#39;setDouble&#39;
 92             elif _type.raw_name() is &#39;any&#39;:
 93                 return &#39;setValue&#39;
 94             else:
 95                 return &#39;set&#39; + ucfirst(_type.raw_name())
 96         if isinstance(_type, AliasedType):
 97             return CppGenerator.cpp_setter_method_for_type(_type.aliased_type)
 98         if isinstance(_type, EnumType):
 99             return CppGenerator.cpp_setter_method_for_type(_type.primitive_type)
100 
101     # Generate type representations for various situations.
102     @staticmethod
103     def cpp_protocol_type_for_type(_type):
104         if isinstance(_type, AliasedType):
105             _type = _type.aliased_type  # Fall through to enum or primitive.
106 
107         if isinstance(_type, ObjectType) and len(_type.members) == 0:
108             return &#39;JSON::Object&#39;
109         if isinstance(_type, ArrayType):
110             if _type.raw_name() is None:  # Otherwise, fall through and use typedef&#39;d name.
111                 return &#39;JSON::ArrayOf&lt;%s&gt;&#39; % CppGenerator.cpp_protocol_type_for_type(_type.element_type)
112         if isinstance(_type, (ObjectType, EnumType, ArrayType)):
113             return &#39;Inspector::Protocol::%s::%s&#39; % (_type.type_domain().domain_name, _type.raw_name())
114         if isinstance(_type, PrimitiveType):
115             return CppGenerator.cpp_name_for_primitive_type(_type)
116 
117     @staticmethod
118     def cpp_protocol_type_for_type_member(type_member, object_declaration):
119         if isinstance(type_member.type, EnumType) and type_member.type.is_anonymous:
120             return &#39;::&#39;.join([CppGenerator.cpp_protocol_type_for_type(object_declaration.type), ucfirst(type_member.member_name)])
121         else:
122             return CppGenerator.cpp_protocol_type_for_type(type_member.type)
123 
124     @staticmethod
125     def cpp_type_for_unchecked_formal_in_parameter(parameter):
126         _type = parameter.type
127         if isinstance(_type, AliasedType):
128             _type = _type.aliased_type  # Fall through to enum or primitive.
129 
130         if isinstance(_type, EnumType):
131             _type = _type.primitive_type  # Fall through to primitive.
132 
133         # This handles the &#39;any&#39; type and objects with defined properties.
134         if isinstance(_type, ObjectType) or _type.qualified_name() is &#39;object&#39;:
135             cpp_name = &#39;JSON::Object&#39;
136             if parameter.is_optional:
137                 return &#39;const %s*&#39; % cpp_name
138             else:
139                 return &#39;const %s&amp;&#39; % cpp_name
140         if isinstance(_type, ArrayType):
141             cpp_name = &#39;JSON::Array&#39;
142             if parameter.is_optional:
143                 return &#39;const %s*&#39; % cpp_name
144             else:
145                 return &#39;const %s&amp;&#39; % cpp_name
146         if isinstance(_type, PrimitiveType):
147             cpp_name = CppGenerator.cpp_name_for_primitive_type(_type)
148             if parameter.is_optional:
149                 return &#39;const %s*&#39; % cpp_name
150             elif _type.raw_name() in [&#39;string&#39;]:
151                 return &#39;const %s&amp;&#39; % cpp_name
152             else:
153                 return cpp_name
154 
155         return &quot;unknown_unchecked_formal_in_parameter_type&quot;
156 
157     @staticmethod
158     def cpp_type_for_checked_formal_event_parameter(parameter):
159         return CppGenerator.cpp_type_for_type_with_name(parameter.type, parameter.parameter_name, parameter.is_optional)
160 
161     @staticmethod
162     def cpp_type_for_type_member(member):
163         return CppGenerator.cpp_type_for_type_with_name(member.type, member.member_name, False)
164 
165     @staticmethod
166     def cpp_type_for_type_with_name(_type, type_name, is_optional):
167         if isinstance(_type, (ArrayType, ObjectType)):
168             return &#39;RefPtr&lt;%s&gt;&#39; % CppGenerator.cpp_protocol_type_for_type(_type)
169         if isinstance(_type, AliasedType):
170             builder_type = CppGenerator.cpp_protocol_type_for_type(_type)
171             if is_optional:
172                 return &#39;const %s*&#39; % builder_type
173             elif _type.aliased_type.qualified_name() in [&#39;integer&#39;, &#39;number&#39;]:
174                 return CppGenerator.cpp_name_for_primitive_type(_type.aliased_type)
175             elif _type.aliased_type.qualified_name() in [&#39;string&#39;]:
176                 return &#39;const %s&amp;&#39; % builder_type
177             else:
178                 return builder_type
179         if isinstance(_type, PrimitiveType):
180             cpp_name = CppGenerator.cpp_name_for_primitive_type(_type)
181             if _type.qualified_name() in [&#39;object&#39;]:
182                 return &#39;RefPtr&lt;JSON::Object&gt;&#39;
183             elif _type.qualified_name() in [&#39;any&#39;]:
184                 return &#39;RefPtr&lt;JSON::Value&gt;&#39;
185             elif is_optional:
186                 return &#39;const %s*&#39; % cpp_name
187             elif _type.qualified_name() in [&#39;string&#39;]:
188                 return &#39;const %s&amp;&#39; % cpp_name
189             else:
190                 return cpp_name
191         if isinstance(_type, EnumType):
192             if _type.is_anonymous:
193                 enum_type_name = ucfirst(type_name)
194             else:
195                 enum_type_name = &#39;Inspector::Protocol::%s::%s&#39; % (_type.type_domain().domain_name, _type.raw_name())
196 
197             if is_optional:
198                 return &#39;%s*&#39; % enum_type_name
199             else:
200                 return &#39;%s&#39; % enum_type_name
201 
202     @staticmethod
203     def cpp_type_for_formal_out_parameter(parameter):
204         _type = parameter.type
205 
206         if isinstance(_type, AliasedType):
207             _type = _type.aliased_type  # Fall through.
208 
209         if isinstance(_type, (ObjectType, ArrayType)):
210             return &#39;RefPtr&lt;%s&gt;&amp;&#39; % CppGenerator.cpp_protocol_type_for_type(_type)
211         if isinstance(_type, PrimitiveType):
212             cpp_name = CppGenerator.cpp_name_for_primitive_type(_type)
213             if parameter.is_optional:
214                 return &quot;Optional&lt;%s&gt;&amp;&quot; % cpp_name
215             else:
216                 return &#39;%s*&#39; % cpp_name
217         if isinstance(_type, EnumType):
218             if _type.is_anonymous:
219                 return &#39;%sBackendDispatcherHandler::%s*&#39; % (_type.type_domain().domain_name, ucfirst(parameter.parameter_name))
220             else:
221                 return &#39;Inspector::Protocol::%s::%s*&#39; % (_type.type_domain().domain_name, _type.raw_name())
222 
223         raise ValueError(&quot;unknown formal out parameter type.&quot;)
224 
225     # FIXME: this is only slightly different from out parameters; they could be unified.
226     @staticmethod
227     def cpp_type_for_formal_async_parameter(parameter):
228         _type = parameter.type
229         if isinstance(_type, AliasedType):
230             _type = _type.aliased_type  # Fall through.
231 
232         if isinstance(_type, (ObjectType, ArrayType)):
233             return &#39;RefPtr&lt;%s&gt;&amp;&amp;&#39; % CppGenerator.cpp_protocol_type_for_type(_type)
234         if isinstance(_type, PrimitiveType):
235             cpp_name = CppGenerator.cpp_name_for_primitive_type(_type)
236             if parameter.is_optional:
237                 return &quot;Optional&lt;%s&gt;&amp;&quot; % cpp_name
238             elif _type.qualified_name() in [&#39;integer&#39;, &#39;number&#39;]:
239                 return CppGenerator.cpp_name_for_primitive_type(_type)
240             elif _type.qualified_name() in [&#39;string&#39;]:
241                 return &#39;const %s&amp;&#39; % cpp_name
242             else:
243                 return cpp_name
244         if isinstance(_type, EnumType):
245             if _type.is_anonymous:
246                 cpp_name = &#39;%sBackendDispatcherHandler::%s&#39; % (_type.type_domain().domain_name, ucfirst(parameter.parameter_name))
247             else:
248                 cpp_name = &#39;Inspector::Protocol::%s::%s&#39; % (_type.type_domain().domain_name, _type.raw_name())
249 
250             if parameter.is_optional:
251                 return &quot;Optional&lt;%s&gt;&quot; % cpp_name
252             else:
253                 return cpp_name
254 
255         raise ValueError(&quot;Unknown formal async parameter type.&quot;)
256 
257     # In-parameters don&#39;t use builder types, because they could be passed
258     # &quot;open types&quot; that are manually constructed out of InspectorObjects.
259 
260     # FIXME: Only parameters that are actually open types should need non-builder parameter types.
261     @staticmethod
262     def cpp_type_for_stack_in_parameter(parameter):
263         _type = parameter.type
264         if isinstance(_type, AliasedType):
265             _type = _type.aliased_type  # Fall through.
266 
267         if isinstance(_type, EnumType):
268             _type = _type.primitive_type  # Fall through.
269 
270         if isinstance(_type, ObjectType):
271             return &quot;RefPtr&lt;JSON::Object&gt;&quot;
272         if isinstance(_type, ArrayType):
273             return &quot;RefPtr&lt;JSON::Array&gt;&quot;
274         if isinstance(_type, PrimitiveType):
275             cpp_name = CppGenerator.cpp_name_for_primitive_type(_type)
276             if _type.qualified_name() in [&#39;any&#39;, &#39;object&#39;]:
277                 return &quot;RefPtr&lt;%s&gt;&quot; % CppGenerator.cpp_name_for_primitive_type(_type)
<a name="1" id="anc1"></a><span class="line-modified">278             elif parameter.is_optional and _type.qualified_name() not in [&#39;boolean&#39;, &#39;string&#39;, &#39;integer&#39;]:</span>
279                 return &quot;Optional&lt;%s&gt;&quot; % cpp_name
280             else:
281                 return cpp_name
282 
283     @staticmethod
284     def cpp_type_for_stack_out_parameter(parameter):
285         _type = parameter.type
286         if isinstance(_type, (ArrayType, ObjectType)):
287             return &#39;RefPtr&lt;%s&gt;&#39; % CppGenerator.cpp_protocol_type_for_type(_type)
288         if isinstance(_type, AliasedType):
289             builder_type = CppGenerator.cpp_protocol_type_for_type(_type)
290             if parameter.is_optional:
291                 return &quot;Optional&lt;%s&gt;&quot; % builder_type
292             return &#39;%s&#39; % builder_type
293         if isinstance(_type, PrimitiveType):
294             cpp_name = CppGenerator.cpp_name_for_primitive_type(_type)
295             if parameter.is_optional:
296                 return &quot;Optional&lt;%s&gt;&quot; % cpp_name
297             else:
298                 return cpp_name
299         if isinstance(_type, EnumType):
300             if _type.is_anonymous:
301                 return &#39;%sBackendDispatcherHandler::%s&#39; % (_type.type_domain().domain_name, ucfirst(parameter.parameter_name))
302             else:
303                 return &#39;Inspector::Protocol::%s::%s&#39; % (_type.type_domain().domain_name, _type.raw_name())
304 
305     @staticmethod
306     def cpp_assertion_method_for_type_member(type_member, object_declaration):
307 
308         def assertion_method_for_type(_type):
309             return &#39;BindingTraits&lt;%s&gt;::assertValueHasExpectedType&#39; % CppGenerator.cpp_protocol_type_for_type(_type)
310 
311         if isinstance(type_member.type, AliasedType):
312             return assertion_method_for_type(type_member.type.aliased_type)
313         if isinstance(type_member.type, EnumType) and type_member.type.is_anonymous:
314             return &#39;BindingTraits&lt;%s&gt;::assertValueHasExpectedType&#39; % CppGenerator.cpp_protocol_type_for_type_member(type_member, object_declaration)
315 
316         return assertion_method_for_type(type_member.type)
317 
318     @staticmethod
319     def cpp_name_for_primitive_type(_type):
320         return _PRIMITIVE_TO_CPP_NAME_MAP.get(_type.raw_name())
321 
322     # Decide whether certain helpers are necessary in a situation.
323     @staticmethod
324     def should_use_wrapper_for_return_type(_type):
325         return not isinstance(_type, (ArrayType, ObjectType))
326 
327     @staticmethod
328     def should_use_references_for_type(_type):
329         return isinstance(_type, (ArrayType, ObjectType)) or (isinstance(_type, (PrimitiveType)) and _type.qualified_name() in [&quot;any&quot;, &quot;object&quot;])
330 
331     @staticmethod
332     def should_pass_by_copy_for_return_type(_type):
333         return isinstance(_type, (ArrayType, ObjectType)) or (isinstance(_type, (PrimitiveType)) and _type.qualified_name() == &quot;object&quot;)
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
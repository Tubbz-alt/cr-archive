<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/CSSFilter.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../plugins/npapi.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSFilter.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/CSSFilter.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
104     if (!filter) {
105         // Although we did not find the referenced filter, it might exist later in the document.
106         // FIXME: This skips anonymous RenderObjects. &lt;https://webkit.org/b/131085&gt;
107         if (auto* element = renderer.element())
108             document-&gt;accessSVGExtensions().addPendingResource(filterOperation.fragment(), *element);
109         return nullptr;
110     }
111 
112     RefPtr&lt;FilterEffect&gt; effect;
113 
114     auto builder = makeUnique&lt;SVGFilterBuilder&gt;(&amp;previousEffect);
115     m_sourceAlpha = builder-&gt;getEffectById(SourceAlpha::effectName());
116 
117     for (auto&amp; effectElement : childrenOfType&lt;SVGFilterPrimitiveStandardAttributes&gt;(*filter)) {
118         effect = effectElement.build(builder.get(), *this);
119         if (!effect)
120             continue;
121 
122         effectElement.setStandardAttributes(effect.get());
123         if (effectElement.renderer())
<span class="line-modified">124             effect-&gt;setOperatingColorSpace(effectElement.renderer()-&gt;style().svgStyle().colorInterpolationFilters() == ColorInterpolation::LinearRGB ? ColorSpaceLinearRGB : ColorSpaceSRGB);</span>
125 
126         builder-&gt;add(effectElement.result(), effect);
127         m_effects.append(*effect);
128     }
129     return effect;
130 }
131 
132 bool CSSFilter::build(RenderElement&amp; renderer, const FilterOperations&amp; operations, FilterConsumer consumer)
133 {
134     m_hasFilterThatMovesPixels = operations.hasFilterThatMovesPixels();
135     m_hasFilterThatShouldBeRestrictedBySecurityOrigin = operations.hasFilterThatShouldBeRestrictedBySecurityOrigin();
<span class="line-removed">136     if (m_hasFilterThatMovesPixels)</span>
<span class="line-removed">137         m_outsets = operations.outsets();</span>
138 
139     m_effects.clear();

140 
141     RefPtr&lt;FilterEffect&gt; previousEffect = m_sourceGraphic.ptr();
142     for (auto&amp; operation : operations.operations()) {
143         RefPtr&lt;FilterEffect&gt; effect;
144         auto&amp; filterOperation = *operation;
145         switch (filterOperation.type()) {
146         case FilterOperation::REFERENCE: {
147             auto&amp; referenceOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
148             effect = buildReferenceFilter(renderer, *previousEffect, referenceOperation);
149             break;
150         }
151         case FilterOperation::GRAYSCALE: {
152             auto&amp; colorMatrixOperation = downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation);
153             Vector&lt;float&gt; inputParameters;
154             double oneMinusAmount = clampTo(1 - colorMatrixOperation.amount(), 0.0, 1.0);
155 
156             // See https://dvcs.w3.org/hg/FXTF/raw-file/tip/filters/index.html#grayscaleEquivalent
157             // for information on parameters.
158 
159             inputParameters.append(narrowPrecisionToFloat(0.2126 + 0.7874 * oneMinusAmount));
</pre>
<hr />
<pre>
273         case FilterOperation::BLUR: {
274             auto&amp; blurOperation = downcast&lt;BlurFilterOperation&gt;(filterOperation);
275             float stdDeviation = floatValueForLength(blurOperation.stdDeviation(), 0);
276             effect = FEGaussianBlur::create(*this, stdDeviation, stdDeviation, consumer == FilterConsumer::FilterProperty ? EDGEMODE_NONE : EDGEMODE_DUPLICATE);
277             break;
278         }
279         case FilterOperation::DROP_SHADOW: {
280             auto&amp; dropShadowOperation = downcast&lt;DropShadowFilterOperation&gt;(filterOperation);
281             effect = FEDropShadow::create(*this, dropShadowOperation.stdDeviation(), dropShadowOperation.stdDeviation(),
282                 dropShadowOperation.x(), dropShadowOperation.y(), dropShadowOperation.color(), 1);
283             break;
284         }
285         default:
286             break;
287         }
288 
289         if (effect) {
290             // Unlike SVG Filters and CSSFilterImages, filter functions on the filter
291             // property applied here should not clip to their primitive subregions.
292             effect-&gt;setClipsToBounds(consumer == FilterConsumer::FilterFunction);
<span class="line-modified">293             effect-&gt;setOperatingColorSpace(ColorSpaceSRGB);</span>
294 
295             if (filterOperation.type() != FilterOperation::REFERENCE) {
296                 effect-&gt;inputEffects().append(WTFMove(previousEffect));
297                 m_effects.append(*effect);
298             }
299             previousEffect = WTFMove(effect);
300         }
301     }
302 
303     // If we didn&#39;t make any effects, tell our caller we are not valid.
304     if (m_effects.isEmpty())
305         return false;
306 
307     setMaxEffectRects(m_sourceDrawingRegion);
308     return true;
309 }
310 
311 bool CSSFilter::updateBackingStoreRect(const FloatRect&amp; filterRect)
312 {
313     if (filterRect.isEmpty() || ImageBuffer::sizeNeedsClamping(filterRect.size()))
</pre>
<hr />
<pre>
350     FloatSize scale;
351     if (ImageBuffer::sizeNeedsClamping(subRegion.size(), scale)) {
352         setFilterResolution(scale);
353         lastEffect.determineFilterPrimitiveSubregion();
354     }
355 }
356 
357 void CSSFilter::clearIntermediateResults()
358 {
359     m_sourceGraphic-&gt;clearResult();
360     if (m_sourceAlpha)
361         m_sourceAlpha-&gt;clearResult();
362     for (auto&amp; effect : m_effects)
363         effect-&gt;clearResult();
364 }
365 
366 void CSSFilter::apply()
367 {
368     auto&amp; effect = m_effects.last().get();
369     effect.apply();
<span class="line-modified">370     effect.transformResultColorSpace(ColorSpaceSRGB);</span>
371 }
372 
373 LayoutRect CSSFilter::computeSourceImageRectForDirtyRect(const LayoutRect&amp; filterBoxRect, const LayoutRect&amp; dirtyRect)
374 {
375     // The result of this function is the area in the &quot;filterBoxRect&quot; that needs to be repainted, so that we fully cover the &quot;dirtyRect&quot;.
376     auto rectForRepaint = dirtyRect;
<span class="line-modified">377     if (hasFilterThatMovesPixels()) {</span>
<span class="line-modified">378         // Note that the outsets are reversed here because we are going backwards -&gt; we have the dirty rect and</span>
<span class="line-removed">379         // need to find out what is the rectangle that might influence the result inside that dirty rect.</span>
<span class="line-removed">380         rectForRepaint.move(-m_outsets.right(), -m_outsets.bottom());</span>
<span class="line-removed">381         rectForRepaint.expand(m_outsets.left() + m_outsets.right(), m_outsets.top() + m_outsets.bottom());</span>
<span class="line-removed">382     }</span>
383     rectForRepaint.intersect(filterBoxRect);
384     return rectForRepaint;
385 }
386 
387 ImageBuffer* CSSFilter::output() const
388 {
389     return m_effects.last()-&gt;imageBufferResult();
390 }
391 
392 void CSSFilter::setSourceImageRect(const FloatRect&amp; sourceImageRect)
393 {
394     m_sourceDrawingRegion = sourceImageRect;
395     setMaxEffectRects(sourceImageRect);
396     setFilterRegion(sourceImageRect);
397     m_graphicsBufferAttached = false;
398 }
399 
<span class="line-removed">400 </span>
401 void CSSFilter::setMaxEffectRects(const FloatRect&amp; effectRect)
402 {
403     for (auto&amp; effect : m_effects)
404         effect-&gt;setMaxEffectRect(effectRect);
405 }
406 
407 IntRect CSSFilter::outputRect() const
408 {
409     auto&amp; lastEffect = m_effects.last().get();
410     if (!lastEffect.hasResult())
411         return { };
412     return lastEffect.requestedRegionOfInputImageData(IntRect { m_filterRegion });
413 }
414 













415 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
104     if (!filter) {
105         // Although we did not find the referenced filter, it might exist later in the document.
106         // FIXME: This skips anonymous RenderObjects. &lt;https://webkit.org/b/131085&gt;
107         if (auto* element = renderer.element())
108             document-&gt;accessSVGExtensions().addPendingResource(filterOperation.fragment(), *element);
109         return nullptr;
110     }
111 
112     RefPtr&lt;FilterEffect&gt; effect;
113 
114     auto builder = makeUnique&lt;SVGFilterBuilder&gt;(&amp;previousEffect);
115     m_sourceAlpha = builder-&gt;getEffectById(SourceAlpha::effectName());
116 
117     for (auto&amp; effectElement : childrenOfType&lt;SVGFilterPrimitiveStandardAttributes&gt;(*filter)) {
118         effect = effectElement.build(builder.get(), *this);
119         if (!effect)
120             continue;
121 
122         effectElement.setStandardAttributes(effect.get());
123         if (effectElement.renderer())
<span class="line-modified">124             effect-&gt;setOperatingColorSpace(effectElement.renderer()-&gt;style().svgStyle().colorInterpolationFilters() == ColorInterpolation::LinearRGB ? ColorSpace::LinearRGB : ColorSpace::SRGB);</span>
125 
126         builder-&gt;add(effectElement.result(), effect);
127         m_effects.append(*effect);
128     }
129     return effect;
130 }
131 
132 bool CSSFilter::build(RenderElement&amp; renderer, const FilterOperations&amp; operations, FilterConsumer consumer)
133 {
134     m_hasFilterThatMovesPixels = operations.hasFilterThatMovesPixels();
135     m_hasFilterThatShouldBeRestrictedBySecurityOrigin = operations.hasFilterThatShouldBeRestrictedBySecurityOrigin();


136 
137     m_effects.clear();
<span class="line-added">138     m_outsets = { };</span>
139 
140     RefPtr&lt;FilterEffect&gt; previousEffect = m_sourceGraphic.ptr();
141     for (auto&amp; operation : operations.operations()) {
142         RefPtr&lt;FilterEffect&gt; effect;
143         auto&amp; filterOperation = *operation;
144         switch (filterOperation.type()) {
145         case FilterOperation::REFERENCE: {
146             auto&amp; referenceOperation = downcast&lt;ReferenceFilterOperation&gt;(filterOperation);
147             effect = buildReferenceFilter(renderer, *previousEffect, referenceOperation);
148             break;
149         }
150         case FilterOperation::GRAYSCALE: {
151             auto&amp; colorMatrixOperation = downcast&lt;BasicColorMatrixFilterOperation&gt;(filterOperation);
152             Vector&lt;float&gt; inputParameters;
153             double oneMinusAmount = clampTo(1 - colorMatrixOperation.amount(), 0.0, 1.0);
154 
155             // See https://dvcs.w3.org/hg/FXTF/raw-file/tip/filters/index.html#grayscaleEquivalent
156             // for information on parameters.
157 
158             inputParameters.append(narrowPrecisionToFloat(0.2126 + 0.7874 * oneMinusAmount));
</pre>
<hr />
<pre>
272         case FilterOperation::BLUR: {
273             auto&amp; blurOperation = downcast&lt;BlurFilterOperation&gt;(filterOperation);
274             float stdDeviation = floatValueForLength(blurOperation.stdDeviation(), 0);
275             effect = FEGaussianBlur::create(*this, stdDeviation, stdDeviation, consumer == FilterConsumer::FilterProperty ? EDGEMODE_NONE : EDGEMODE_DUPLICATE);
276             break;
277         }
278         case FilterOperation::DROP_SHADOW: {
279             auto&amp; dropShadowOperation = downcast&lt;DropShadowFilterOperation&gt;(filterOperation);
280             effect = FEDropShadow::create(*this, dropShadowOperation.stdDeviation(), dropShadowOperation.stdDeviation(),
281                 dropShadowOperation.x(), dropShadowOperation.y(), dropShadowOperation.color(), 1);
282             break;
283         }
284         default:
285             break;
286         }
287 
288         if (effect) {
289             // Unlike SVG Filters and CSSFilterImages, filter functions on the filter
290             // property applied here should not clip to their primitive subregions.
291             effect-&gt;setClipsToBounds(consumer == FilterConsumer::FilterFunction);
<span class="line-modified">292             effect-&gt;setOperatingColorSpace(ColorSpace::SRGB);</span>
293 
294             if (filterOperation.type() != FilterOperation::REFERENCE) {
295                 effect-&gt;inputEffects().append(WTFMove(previousEffect));
296                 m_effects.append(*effect);
297             }
298             previousEffect = WTFMove(effect);
299         }
300     }
301 
302     // If we didn&#39;t make any effects, tell our caller we are not valid.
303     if (m_effects.isEmpty())
304         return false;
305 
306     setMaxEffectRects(m_sourceDrawingRegion);
307     return true;
308 }
309 
310 bool CSSFilter::updateBackingStoreRect(const FloatRect&amp; filterRect)
311 {
312     if (filterRect.isEmpty() || ImageBuffer::sizeNeedsClamping(filterRect.size()))
</pre>
<hr />
<pre>
349     FloatSize scale;
350     if (ImageBuffer::sizeNeedsClamping(subRegion.size(), scale)) {
351         setFilterResolution(scale);
352         lastEffect.determineFilterPrimitiveSubregion();
353     }
354 }
355 
356 void CSSFilter::clearIntermediateResults()
357 {
358     m_sourceGraphic-&gt;clearResult();
359     if (m_sourceAlpha)
360         m_sourceAlpha-&gt;clearResult();
361     for (auto&amp; effect : m_effects)
362         effect-&gt;clearResult();
363 }
364 
365 void CSSFilter::apply()
366 {
367     auto&amp; effect = m_effects.last().get();
368     effect.apply();
<span class="line-modified">369     effect.transformResultColorSpace(ColorSpace::SRGB);</span>
370 }
371 
372 LayoutRect CSSFilter::computeSourceImageRectForDirtyRect(const LayoutRect&amp; filterBoxRect, const LayoutRect&amp; dirtyRect)
373 {
374     // The result of this function is the area in the &quot;filterBoxRect&quot; that needs to be repainted, so that we fully cover the &quot;dirtyRect&quot;.
375     auto rectForRepaint = dirtyRect;
<span class="line-modified">376     if (hasFilterThatMovesPixels())</span>
<span class="line-modified">377         rectForRepaint += outsets();</span>




378     rectForRepaint.intersect(filterBoxRect);
379     return rectForRepaint;
380 }
381 
382 ImageBuffer* CSSFilter::output() const
383 {
384     return m_effects.last()-&gt;imageBufferResult();
385 }
386 
387 void CSSFilter::setSourceImageRect(const FloatRect&amp; sourceImageRect)
388 {
389     m_sourceDrawingRegion = sourceImageRect;
390     setMaxEffectRects(sourceImageRect);
391     setFilterRegion(sourceImageRect);
392     m_graphicsBufferAttached = false;
393 }
394 

395 void CSSFilter::setMaxEffectRects(const FloatRect&amp; effectRect)
396 {
397     for (auto&amp; effect : m_effects)
398         effect-&gt;setMaxEffectRect(effectRect);
399 }
400 
401 IntRect CSSFilter::outputRect() const
402 {
403     auto&amp; lastEffect = m_effects.last().get();
404     if (!lastEffect.hasResult())
405         return { };
406     return lastEffect.requestedRegionOfInputImageData(IntRect { m_filterRegion });
407 }
408 
<span class="line-added">409 IntOutsets CSSFilter::outsets() const</span>
<span class="line-added">410 {</span>
<span class="line-added">411     if (!m_hasFilterThatMovesPixels)</span>
<span class="line-added">412         return { };</span>
<span class="line-added">413 </span>
<span class="line-added">414     if (!m_outsets.isZero())</span>
<span class="line-added">415         return m_outsets;</span>
<span class="line-added">416 </span>
<span class="line-added">417     for (auto&amp; effect : m_effects)</span>
<span class="line-added">418         m_outsets += effect-&gt;outsets();</span>
<span class="line-added">419     return m_outsets;</span>
<span class="line-added">420 }</span>
<span class="line-added">421 </span>
422 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="../plugins/npapi.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CSSFilter.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorPageAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2011 Google Inc. All rights reserved.
  3  * Copyright (C) 2015-2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions are
  7  * met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright
 10  * notice, this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above
 12  * copyright notice, this list of conditions and the following disclaimer
 13  * in the documentation and/or other materials provided with the
 14  * distribution.
 15  *     * Neither the name of Google Inc. nor the names of its
 16  * contributors may be used to endorse or promote products derived from
 17  * this software without specific prior written permission.
 18  *
 19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 20  * &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 21  * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 22  * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 23  * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 24  * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 25  * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 26  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 27  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 28  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 29  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 30  */
 31 
 32 #include &quot;config.h&quot;
 33 #include &quot;InspectorPageAgent.h&quot;
 34 
 35 #include &quot;CachedResource.h&quot;
 36 #include &quot;CachedResourceLoader.h&quot;
 37 #include &quot;Cookie.h&quot;
 38 #include &quot;CookieJar.h&quot;
 39 #include &quot;CustomHeaderFields.h&quot;
 40 #include &quot;DOMWrapperWorld.h&quot;
 41 #include &quot;Document.h&quot;
 42 #include &quot;DocumentLoader.h&quot;
 43 #include &quot;Frame.h&quot;
 44 #include &quot;FrameLoadRequest.h&quot;
 45 #include &quot;FrameLoader.h&quot;
 46 #include &quot;FrameSnapshotting.h&quot;
 47 #include &quot;FrameView.h&quot;
 48 #include &quot;HTMLFrameOwnerElement.h&quot;
 49 #include &quot;HTMLNames.h&quot;
 50 #include &quot;ImageBuffer.h&quot;
 51 #include &quot;InspectorClient.h&quot;
 52 #include &quot;InspectorDOMAgent.h&quot;
 53 #include &quot;InspectorNetworkAgent.h&quot;
 54 #include &quot;InspectorOverlay.h&quot;
 55 #include &quot;InstrumentingAgents.h&quot;
 56 #include &quot;MIMETypeRegistry.h&quot;
 57 #include &quot;MemoryCache.h&quot;
 58 #include &quot;Page.h&quot;
 59 #include &quot;RenderObject.h&quot;
 60 #include &quot;RenderTheme.h&quot;
 61 #include &quot;ScriptController.h&quot;
 62 #include &quot;ScriptSourceCode.h&quot;
 63 #include &quot;SecurityOrigin.h&quot;
 64 #include &quot;Settings.h&quot;
 65 #include &quot;StyleScope.h&quot;
 66 #include &quot;TextEncoding.h&quot;
 67 #include &quot;UserGestureIndicator.h&quot;
 68 #include &lt;JavaScriptCore/ContentSearchUtilities.h&gt;
 69 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 70 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 71 #include &lt;wtf/ListHashSet.h&gt;
 72 #include &lt;wtf/Stopwatch.h&gt;
 73 #include &lt;wtf/text/Base64.h&gt;
 74 #include &lt;wtf/text/StringBuilder.h&gt;
 75 
 76 #if ENABLE(APPLICATION_MANIFEST)
 77 #include &quot;CachedApplicationManifest.h&quot;
 78 #endif
 79 
 80 #if ENABLE(WEB_ARCHIVE) &amp;&amp; USE(CF)
 81 #include &quot;LegacyWebArchive.h&quot;
 82 #endif
 83 
 84 
 85 namespace WebCore {
 86 
 87 using namespace Inspector;
 88 
 89 // Keep this in sync with Page.Setting
 90 #define FOR_EACH_INSPECTOR_OVERRIDE_SETTING(macro) \
 91     macro(AuthorAndUserStylesEnabled) \
 92     macro(ICECandidateFilteringEnabled) \
 93     macro(ImagesEnabled) \
 94     macro(MediaCaptureRequiresSecureConnection) \
 95     macro(MockCaptureDevicesEnabled) \
 96     macro(NeedsSiteSpecificQuirks) \
 97     macro(ScriptEnabled) \
 98     macro(ShowDebugBorders) \
 99     macro(ShowRepaintCounter) \
100     macro(WebRTCEncryptionEnabled) \
101     macro(WebSecurityEnabled)
102 
103 static bool decodeBuffer(const char* buffer, unsigned size, const String&amp; textEncodingName, String* result)
104 {
105     if (buffer) {
106         TextEncoding encoding(textEncodingName);
107         if (!encoding.isValid())
108             encoding = WindowsLatin1Encoding();
109         *result = encoding.decode(buffer, size);
110         return true;
111     }
112     return false;
113 }
114 
115 bool InspectorPageAgent::mainResourceContent(Frame* frame, bool withBase64Encode, String* result)
116 {
117     RefPtr&lt;SharedBuffer&gt; buffer = frame-&gt;loader().documentLoader()-&gt;mainResourceData();
118     if (!buffer)
119         return false;
120     return InspectorPageAgent::dataContent(buffer-&gt;data(), buffer-&gt;size(), frame-&gt;document()-&gt;encoding(), withBase64Encode, result);
121 }
122 
123 bool InspectorPageAgent::sharedBufferContent(RefPtr&lt;SharedBuffer&gt;&amp;&amp; buffer, const String&amp; textEncodingName, bool withBase64Encode, String* result)
124 {
125     return dataContent(buffer ? buffer-&gt;data() : nullptr, buffer ? buffer-&gt;size() : 0, textEncodingName, withBase64Encode, result);
126 }
127 
128 bool InspectorPageAgent::dataContent(const char* data, unsigned size, const String&amp; textEncodingName, bool withBase64Encode, String* result)
129 {
130     if (withBase64Encode) {
131         *result = base64Encode(data, size);
132         return true;
133     }
134 
135     return decodeBuffer(data, size, textEncodingName, result);
136 }
137 
138 Vector&lt;CachedResource*&gt; InspectorPageAgent::cachedResourcesForFrame(Frame* frame)
139 {
140     Vector&lt;CachedResource*&gt; result;
141 
142     for (auto&amp; cachedResourceHandle : frame-&gt;document()-&gt;cachedResourceLoader().allCachedResources().values()) {
143         auto* cachedResource = cachedResourceHandle.get();
144         if (cachedResource-&gt;resourceRequest().hiddenFromInspector())
145             continue;
146 
147         switch (cachedResource-&gt;type()) {
148         case CachedResource::Type::ImageResource:
149             // Skip images that were not auto loaded (images disabled in the user agent).
150 #if ENABLE(SVG_FONTS)
151         case CachedResource::Type::SVGFontResource:
152 #endif
153         case CachedResource::Type::FontResource:
154             // Skip fonts that were referenced in CSS but never used/downloaded.
155             if (cachedResource-&gt;stillNeedsLoad())
156                 continue;
157             break;
158         default:
159             // All other CachedResource types download immediately.
160             break;
161         }
162 
163         result.append(cachedResource);
164     }
165 
166     return result;
167 }
168 
169 void InspectorPageAgent::resourceContent(ErrorString&amp; errorString, Frame* frame, const URL&amp; url, String* result, bool* base64Encoded)
170 {
171     DocumentLoader* loader = assertDocumentLoader(errorString, frame);
172     if (!loader)
173         return;
174 
175     RefPtr&lt;SharedBuffer&gt; buffer;
176     bool success = false;
177     if (equalIgnoringFragmentIdentifier(url, loader-&gt;url())) {
178         *base64Encoded = false;
179         success = mainResourceContent(frame, *base64Encoded, result);
180     }
181 
182     if (!success) {
183         if (auto* resource = cachedResource(frame, url))
184             success = InspectorNetworkAgent::cachedResourceContent(*resource, result, base64Encoded);
185     }
186 
187     if (!success)
188         errorString = &quot;Missing resource for given url&quot;_s;
189 }
190 
191 String InspectorPageAgent::sourceMapURLForResource(CachedResource* cachedResource)
192 {
193     if (!cachedResource)
194         return String();
195 
196     // Scripts are handled in a separate path.
197     if (cachedResource-&gt;type() != CachedResource::Type::CSSStyleSheet)
198         return String();
199 
200     String sourceMapHeader = cachedResource-&gt;response().httpHeaderField(HTTPHeaderName::SourceMap);
201     if (!sourceMapHeader.isEmpty())
202         return sourceMapHeader;
203 
204     sourceMapHeader = cachedResource-&gt;response().httpHeaderField(HTTPHeaderName::XSourceMap);
205     if (!sourceMapHeader.isEmpty())
206         return sourceMapHeader;
207 
208     String content;
209     bool base64Encoded;
210     if (InspectorNetworkAgent::cachedResourceContent(*cachedResource, &amp;content, &amp;base64Encoded) &amp;&amp; !base64Encoded)
211         return ContentSearchUtilities::findStylesheetSourceMapURL(content);
212 
213     return String();
214 }
215 
216 CachedResource* InspectorPageAgent::cachedResource(Frame* frame, const URL&amp; url)
217 {
218     if (url.isNull())
219         return nullptr;
220 
221     CachedResource* cachedResource = frame-&gt;document()-&gt;cachedResourceLoader().cachedResource(MemoryCache::removeFragmentIdentifierIfNeeded(url));
222     if (!cachedResource) {
223         ResourceRequest request(url);
224         request.setDomainForCachePartition(frame-&gt;document()-&gt;domainForCachePartition());
225         cachedResource = MemoryCache::singleton().resourceForRequest(request, frame-&gt;page()-&gt;sessionID());
226     }
227 
228     return cachedResource;
229 }
230 
231 Inspector::Protocol::Page::ResourceType InspectorPageAgent::resourceTypeJSON(InspectorPageAgent::ResourceType resourceType)
232 {
233     switch (resourceType) {
234     case DocumentResource:
235         return Inspector::Protocol::Page::ResourceType::Document;
236     case ImageResource:
237         return Inspector::Protocol::Page::ResourceType::Image;
238     case FontResource:
239         return Inspector::Protocol::Page::ResourceType::Font;
240     case StyleSheetResource:
241         return Inspector::Protocol::Page::ResourceType::StyleSheet;
242     case ScriptResource:
243         return Inspector::Protocol::Page::ResourceType::Script;
244     case XHRResource:
245         return Inspector::Protocol::Page::ResourceType::XHR;
246     case FetchResource:
247         return Inspector::Protocol::Page::ResourceType::Fetch;
248     case PingResource:
249         return Inspector::Protocol::Page::ResourceType::Ping;
250     case BeaconResource:
251         return Inspector::Protocol::Page::ResourceType::Beacon;
252     case WebSocketResource:
253         return Inspector::Protocol::Page::ResourceType::WebSocket;
254     case OtherResource:
255         return Inspector::Protocol::Page::ResourceType::Other;
256 #if ENABLE(APPLICATION_MANIFEST)
257     case ApplicationManifestResource:
258         break;
259 #endif
260     }
261     return Inspector::Protocol::Page::ResourceType::Other;
262 }
263 
264 InspectorPageAgent::ResourceType InspectorPageAgent::inspectorResourceType(CachedResource::Type type)
265 {
266     switch (type) {
267     case CachedResource::Type::ImageResource:
268         return InspectorPageAgent::ImageResource;
269 #if ENABLE(SVG_FONTS)
270     case CachedResource::Type::SVGFontResource:
271 #endif
272     case CachedResource::Type::FontResource:
273         return InspectorPageAgent::FontResource;
274 #if ENABLE(XSLT)
275     case CachedResource::Type::XSLStyleSheet:
276 #endif
277     case CachedResource::Type::CSSStyleSheet:
278         return InspectorPageAgent::StyleSheetResource;
279     case CachedResource::Type::Script:
280         return InspectorPageAgent::ScriptResource;
281     case CachedResource::Type::MainResource:
282         return InspectorPageAgent::DocumentResource;
283     case CachedResource::Type::Beacon:
284         return InspectorPageAgent::BeaconResource;
285 #if ENABLE(APPLICATION_MANIFEST)
286     case CachedResource::Type::ApplicationManifest:
287         return InspectorPageAgent::ApplicationManifestResource;
288 #endif
289     case CachedResource::Type::Ping:
290         return InspectorPageAgent::PingResource;
291     case CachedResource::Type::MediaResource:
292     case CachedResource::Type::Icon:
293     case CachedResource::Type::RawResource:
294     default:
295         return InspectorPageAgent::OtherResource;
296     }
297 }
298 
299 InspectorPageAgent::ResourceType InspectorPageAgent::inspectorResourceType(const CachedResource&amp; cachedResource)
300 {
301     if (cachedResource.type() == CachedResource::Type::RawResource) {
302         switch (cachedResource.resourceRequest().requester()) {
303         case ResourceRequest::Requester::Fetch:
304             return InspectorPageAgent::FetchResource;
305         case ResourceRequest::Requester::Main:
306             return InspectorPageAgent::DocumentResource;
307         default:
308             return InspectorPageAgent::XHRResource;
309         }
310     }
311 
312     return inspectorResourceType(cachedResource.type());
313 }
314 
315 Inspector::Protocol::Page::ResourceType InspectorPageAgent::cachedResourceTypeJSON(const CachedResource&amp; cachedResource)
316 {
317     return resourceTypeJSON(inspectorResourceType(cachedResource));
318 }
319 
320 Frame* InspectorPageAgent::findFrameWithSecurityOrigin(Page&amp; page, const String&amp; originRawString)
321 {
322     for (Frame* frame = &amp;page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
323         if (frame-&gt;document()-&gt;securityOrigin().toRawString() == originRawString)
324             return frame;
325     }
326     return nullptr;
327 }
328 
329 DocumentLoader* InspectorPageAgent::assertDocumentLoader(ErrorString&amp; errorString, Frame* frame)
330 {
331     FrameLoader&amp; frameLoader = frame-&gt;loader();
332     DocumentLoader* documentLoader = frameLoader.documentLoader();
333     if (!documentLoader)
334         errorString = &quot;Missing document loader for given frame&quot;_s;
335     return documentLoader;
336 }
337 
338 InspectorPageAgent::InspectorPageAgent(PageAgentContext&amp; context, InspectorClient* client, InspectorOverlay* overlay)
339     : InspectorAgentBase(&quot;Page&quot;_s, context)
340     , m_frontendDispatcher(makeUnique&lt;Inspector::PageFrontendDispatcher&gt;(context.frontendRouter))
341     , m_backendDispatcher(Inspector::PageBackendDispatcher::create(context.backendDispatcher, this))
342     , m_inspectedPage(context.inspectedPage)
343     , m_client(client)
344     , m_overlay(overlay)
345 {
346 }
347 
348 InspectorPageAgent::~InspectorPageAgent() = default;
349 
350 void InspectorPageAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
351 {
352 }
353 
354 void InspectorPageAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
355 {
356     ErrorString unused;
357     disable(unused);
358 }
359 
360 void InspectorPageAgent::enable(ErrorString&amp; errorString)
361 {
362     if (m_instrumentingAgents.inspectorPageAgent() == this) {
363         errorString = &quot;Page domain already enabled&quot;_s;
364         return;
365     }
366 
367     m_instrumentingAgents.setInspectorPageAgent(this);
368 
369     auto stopwatch = m_environment.executionStopwatch();
370     stopwatch-&gt;reset();
371     stopwatch-&gt;start();
372 
373 #if HAVE(OS_DARK_MODE_SUPPORT)
374     defaultAppearanceDidChange(m_inspectedPage.defaultUseDarkAppearance());
375 #endif
376 }
377 
378 void InspectorPageAgent::disable(ErrorString&amp;)
379 {
380     m_instrumentingAgents.setInspectorPageAgent(nullptr);
381 
382     ErrorString unused;
383     setShowPaintRects(unused, false);
384     setShowRulers(unused, false);
385     overrideUserAgent(unused, nullptr);
386     setEmulatedMedia(unused, emptyString());
387     setForcedAppearance(unused, emptyString());
388 
389 #define DISABLE_INSPECTOR_OVERRIDE_SETTING(name) \
390     m_inspectedPage.settings().set##name##InspectorOverride(WTF::nullopt);
391 
392     FOR_EACH_INSPECTOR_OVERRIDE_SETTING(DISABLE_INSPECTOR_OVERRIDE_SETTING)
393 
394 #undef DISABLE_INSPECTOR_OVERRIDE_SETTING
395 
396     m_client-&gt;setMockCaptureDevicesEnabledOverride(WTF::nullopt);
397 }
398 
399 double InspectorPageAgent::timestamp()
400 {
401     return m_environment.executionStopwatch()-&gt;elapsedTime().seconds();
402 }
403 
404 void InspectorPageAgent::reload(ErrorString&amp;, const bool* optionalReloadFromOrigin, const bool* optionalRevalidateAllResources)
405 {
406     bool reloadFromOrigin = optionalReloadFromOrigin &amp;&amp; *optionalReloadFromOrigin;
407     bool revalidateAllResources = optionalRevalidateAllResources &amp;&amp; *optionalRevalidateAllResources;
408 
409     OptionSet&lt;ReloadOption&gt; reloadOptions;
410     if (reloadFromOrigin)
411         reloadOptions.add(ReloadOption::FromOrigin);
412     if (!revalidateAllResources)
413         reloadOptions.add(ReloadOption::ExpiredOnly);
414 
415     m_inspectedPage.mainFrame().loader().reload(reloadOptions);
416 }
417 
418 void InspectorPageAgent::navigate(ErrorString&amp;, const String&amp; url)
419 {
420     UserGestureIndicator indicator { ProcessingUserGesture };
421     Frame&amp; frame = m_inspectedPage.mainFrame();
422 
423     ResourceRequest resourceRequest { frame.document()-&gt;completeURL(url) };
424     FrameLoadRequest frameLoadRequest { *frame.document(), frame.document()-&gt;securityOrigin(), resourceRequest, &quot;_self&quot;_s, LockHistory::No, LockBackForwardList::No, MaybeSendReferrer, AllowNavigationToInvalidURL::No, NewFrameOpenerPolicy::Allow, ShouldOpenExternalURLsPolicy::ShouldNotAllow, InitiatedByMainFrame::Unknown };
425     frame.loader().changeLocation(WTFMove(frameLoadRequest));
426 }
427 
428 void InspectorPageAgent::overrideUserAgent(ErrorString&amp;, const String* value)
429 {
430     m_userAgentOverride = value ? *value : String();
431 }
432 
433 static inline Optional&lt;bool&gt; asOptionalBool(const bool* value)
434 {
435     if (!value)
436         return WTF::nullopt;
437     return *value;
438 }
439 
440 void InspectorPageAgent::overrideSetting(ErrorString&amp; errorString, const String&amp; settingString, const bool* value)
441 {
442     if (settingString.isEmpty()) {
443         errorString = &quot;settingString is empty&quot;_s;
444         return;
445     }
446 
447     auto setting = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::Page::Setting&gt;(settingString);
448     if (!setting) {
449         errorString = makeString(&quot;Unknown settingString: &quot;_s, settingString);
450         return;
451     }
452 
453     auto overrideValue = asOptionalBool(value);
454     switch (setting.value()) {
455 #define CASE_INSPECTOR_OVERRIDE_SETTING(name) \
456     case Inspector::Protocol::Page::Setting::name:                              \
457         m_inspectedPage.settings().set##name##InspectorOverride(overrideValue); \
458         break;                                                                  \
459 
460     FOR_EACH_INSPECTOR_OVERRIDE_SETTING(CASE_INSPECTOR_OVERRIDE_SETTING)
461 
462 #undef CASE_INSPECTOR_OVERRIDE_SETTING
463     }
464 
465     // Update the UIProcess / client for particular overrides.
466     if (setting.value() == Inspector::Protocol::Page::Setting::MockCaptureDevicesEnabled)
467         m_client-&gt;setMockCaptureDevicesEnabledOverride(overrideValue);
468 }
469 
470 static Inspector::Protocol::Page::CookieSameSitePolicy cookieSameSitePolicyJSON(Cookie::SameSitePolicy policy)
471 {
472     switch (policy) {
473     case Cookie::SameSitePolicy::None:
474         return Inspector::Protocol::Page::CookieSameSitePolicy::None;
475     case Cookie::SameSitePolicy::Lax:
476         return Inspector::Protocol::Page::CookieSameSitePolicy::Lax;
477     case Cookie::SameSitePolicy::Strict:
478         return Inspector::Protocol::Page::CookieSameSitePolicy::Strict;
479     }
480     ASSERT_NOT_REACHED();
481     return Inspector::Protocol::Page::CookieSameSitePolicy::None;
482 }
483 
484 static Ref&lt;Inspector::Protocol::Page::Cookie&gt; buildObjectForCookie(const Cookie&amp; cookie)
485 {
486     return Inspector::Protocol::Page::Cookie::create()
487         .setName(cookie.name)
488         .setValue(cookie.value)
489         .setDomain(cookie.domain)
490         .setPath(cookie.path)
491         .setExpires(cookie.expires)
492         .setSize((cookie.name.length() + cookie.value.length()))
493         .setHttpOnly(cookie.httpOnly)
494         .setSecure(cookie.secure)
495         .setSession(cookie.session)
496         .setSameSite(cookieSameSitePolicyJSON(cookie.sameSite))
497         .release();
498 }
499 
500 static Ref&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;&gt; buildArrayForCookies(ListHashSet&lt;Cookie&gt;&amp; cookiesList)
501 {
502     auto cookies = JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;::create();
503 
504     for (const auto&amp; cookie : cookiesList)
505         cookies-&gt;addItem(buildObjectForCookie(cookie));
506 
507     return cookies;
508 }
509 
510 static Vector&lt;URL&gt; allResourcesURLsForFrame(Frame* frame)
511 {
512     Vector&lt;URL&gt; result;
513 
514     result.append(frame-&gt;loader().documentLoader()-&gt;url());
515 
516     for (auto* cachedResource : InspectorPageAgent::cachedResourcesForFrame(frame))
517         result.append(cachedResource-&gt;url());
518 
519     return result;
520 }
521 
522 void InspectorPageAgent::getCookies(ErrorString&amp;, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;&gt;&amp; cookies)
523 {
524     // If we can get raw cookies.
525     ListHashSet&lt;Cookie&gt; rawCookiesList;
526 
527     // If we can&#39;t get raw cookies - fall back to String representation
528     StringBuilder stringCookiesList;
529 
530     // Return value to getRawCookies should be the same for every call because
531     // the return value is platform/network backend specific, and the call will
532     // always return the same true/false value.
533     bool rawCookiesImplemented = false;
534 
535     for (Frame* frame = &amp;m_inspectedPage.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
536         Document* document = frame-&gt;document();
537         if (!document || !document-&gt;page())
538             continue;
539 
540         for (auto&amp; url : allResourcesURLsForFrame(frame)) {
541             Vector&lt;Cookie&gt; docCookiesList;
542             rawCookiesImplemented = document-&gt;page()-&gt;cookieJar().getRawCookies(*document, URL({ }, url), docCookiesList);
543 
544             if (!rawCookiesImplemented) {
545                 // FIXME: We need duplication checking for the String representation of cookies.
546                 // Exceptions are thrown by cookie() in sandboxed frames. That won&#39;t happen here
547                 // because &quot;document&quot; is the document of the main frame of the page.
548                 stringCookiesList.append(document-&gt;cookie().releaseReturnValue());
549             } else {
550                 for (auto&amp; cookie : docCookiesList)
551                     rawCookiesList.add(cookie);
552             }
553         }
554     }
555 
556     // FIXME: Do not return empty string/empty array. Make returns optional instead. https://bugs.webkit.org/show_bug.cgi?id=80855
557     if (rawCookiesImplemented)
558         cookies = buildArrayForCookies(rawCookiesList);
559     else
560         cookies = JSON::ArrayOf&lt;Inspector::Protocol::Page::Cookie&gt;::create();
561 }
562 
563 void InspectorPageAgent::deleteCookie(ErrorString&amp;, const String&amp; cookieName, const String&amp; url)
564 {
565     URL parsedURL({ }, url);
566     for (Frame* frame = &amp;m_inspectedPage.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
567         if (auto* document = frame-&gt;document()) {
568             if (auto* page = document-&gt;page())
569                 page-&gt;cookieJar().deleteCookie(*document, parsedURL, cookieName);
570         }
571     }
572 }
573 
574 void InspectorPageAgent::getResourceTree(ErrorString&amp;, RefPtr&lt;Inspector::Protocol::Page::FrameResourceTree&gt;&amp; object)
575 {
576     object = buildObjectForFrameTree(&amp;m_inspectedPage.mainFrame());
577 }
578 
579 void InspectorPageAgent::getResourceContent(ErrorString&amp; errorString, const String&amp; frameId, const String&amp; url, String* content, bool* base64Encoded)
580 {
581     Frame* frame = assertFrame(errorString, frameId);
582     if (!frame)
583         return;
584 
585     resourceContent(errorString, frame, URL({ }, url), content, base64Encoded);
586 }
587 
588 void InspectorPageAgent::setBootstrapScript(ErrorString&amp;, const String* optionalSource)
589 {
590     m_bootstrapScript = optionalSource ? *optionalSource : nullString();
591 }
592 
593 void InspectorPageAgent::searchInResource(ErrorString&amp; errorString, const String&amp; frameId, const String&amp; url, const String&amp; query, const bool* optionalCaseSensitive, const bool* optionalIsRegex, const String* optionalRequestId, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::GenericTypes::SearchMatch&gt;&gt;&amp; results)
594 {
595     results = JSON::ArrayOf&lt;Inspector::Protocol::GenericTypes::SearchMatch&gt;::create();
596 
597     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
598     bool caseSensitive = optionalCaseSensitive ? *optionalCaseSensitive : false;
599 
600     if (optionalRequestId) {
601         if (InspectorNetworkAgent* networkAgent = m_instrumentingAgents.inspectorNetworkAgent()) {
602             networkAgent-&gt;searchInRequest(errorString, *optionalRequestId, query, caseSensitive, isRegex, results);
603             return;
604         }
605     }
606 
607     Frame* frame = assertFrame(errorString, frameId);
608     if (!frame)
609         return;
610 
611     DocumentLoader* loader = assertDocumentLoader(errorString, frame);
612     if (!loader)
613         return;
614 
615     URL kurl({ }, url);
616 
617     String content;
618     bool success = false;
619     if (equalIgnoringFragmentIdentifier(kurl, loader-&gt;url()))
620         success = mainResourceContent(frame, false, &amp;content);
621 
622     if (!success) {
623         if (auto* resource = cachedResource(frame, kurl)) {
624             if (auto textContent = InspectorNetworkAgent::textContentForCachedResource(*resource)) {
625                 content = *textContent;
626                 success = true;
627             }
628         }
629     }
630 
631     if (!success)
632         return;
633 
634     results = ContentSearchUtilities::searchInTextByLines(content, query, caseSensitive, isRegex);
635 }
636 
637 static Ref&lt;Inspector::Protocol::Page::SearchResult&gt; buildObjectForSearchResult(const String&amp; frameId, const String&amp; url, int matchesCount)
638 {
639     return Inspector::Protocol::Page::SearchResult::create()
640         .setUrl(url)
641         .setFrameId(frameId)
642         .setMatchesCount(matchesCount)
643         .release();
644 }
645 
646 void InspectorPageAgent::searchInResources(ErrorString&amp;, const String&amp; text, const bool* optionalCaseSensitive, const bool* optionalIsRegex, RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::SearchResult&gt;&gt;&amp; result)
647 {
648     result = JSON::ArrayOf&lt;Inspector::Protocol::Page::SearchResult&gt;::create();
649 
650     bool caseSensitive = optionalCaseSensitive ? *optionalCaseSensitive : false;
651     bool isRegex = optionalIsRegex ? *optionalIsRegex : false;
652 
653     auto searchStringType = isRegex ? ContentSearchUtilities::SearchStringType::Regex : ContentSearchUtilities::SearchStringType::ContainsString;
654     auto regex = ContentSearchUtilities::createRegularExpressionForSearchString(text, caseSensitive, searchStringType);
655 
656     for (Frame* frame = &amp;m_inspectedPage.mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
657         for (auto* cachedResource : cachedResourcesForFrame(frame)) {
658             if (auto textContent = InspectorNetworkAgent::textContentForCachedResource(*cachedResource)) {
659                 int matchesCount = ContentSearchUtilities::countRegularExpressionMatches(regex, *textContent);
660                 if (matchesCount)
661                     result-&gt;addItem(buildObjectForSearchResult(frameId(frame), cachedResource-&gt;url(), matchesCount));
662             }
663         }
664     }
665 
666     if (InspectorNetworkAgent* networkAgent = m_instrumentingAgents.inspectorNetworkAgent())
667         networkAgent-&gt;searchOtherRequests(regex, result);
668 }
669 
670 void InspectorPageAgent::setShowRulers(ErrorString&amp;, bool showRulers)
671 {
672     m_overlay-&gt;setShowRulers(showRulers);
673 }
674 
675 void InspectorPageAgent::setShowPaintRects(ErrorString&amp;, bool show)
676 {
677     m_showPaintRects = show;
678     m_client-&gt;setShowPaintRects(show);
679 
680     if (m_client-&gt;overridesShowPaintRects())
681         return;
682 
683     m_overlay-&gt;setShowPaintRects(show);
684 }
685 
686 void InspectorPageAgent::domContentEventFired()
687 {
688     m_isFirstLayoutAfterOnLoad = true;
689     m_frontendDispatcher-&gt;domContentEventFired(timestamp());
690 }
691 
692 void InspectorPageAgent::loadEventFired()
693 {
694     m_frontendDispatcher-&gt;loadEventFired(timestamp());
695 }
696 
697 void InspectorPageAgent::frameNavigated(Frame&amp; frame)
698 {
699     m_frontendDispatcher-&gt;frameNavigated(buildObjectForFrame(&amp;frame));
700 }
701 
702 void InspectorPageAgent::frameDetached(Frame&amp; frame)
703 {
704     auto identifier = m_frameToIdentifier.take(&amp;frame);
705     if (identifier.isNull())
706         return;
707     m_frontendDispatcher-&gt;frameDetached(identifier);
708     m_identifierToFrame.remove(identifier);
709 }
710 
711 Frame* InspectorPageAgent::frameForId(const String&amp; frameId)
712 {
713     return frameId.isEmpty() ? nullptr : m_identifierToFrame.get(frameId);
714 }
715 
716 String InspectorPageAgent::frameId(Frame* frame)
717 {
718     if (!frame)
719         return emptyString();
720     return m_frameToIdentifier.ensure(frame, [this, frame] {
721         auto identifier = IdentifiersFactory::createIdentifier();
722         m_identifierToFrame.set(identifier, frame);
723         return identifier;
724     }).iterator-&gt;value;
725 }
726 
727 String InspectorPageAgent::loaderId(DocumentLoader* loader)
728 {
729     if (!loader)
730         return emptyString();
731     return m_loaderToIdentifier.ensure(loader, [] {
732         return IdentifiersFactory::createIdentifier();
733     }).iterator-&gt;value;
734 }
735 
736 Frame* InspectorPageAgent::assertFrame(ErrorString&amp; errorString, const String&amp; frameId)
737 {
738     Frame* frame = frameForId(frameId);
739     if (!frame)
740         errorString = &quot;Missing frame for given frameId&quot;_s;
741     return frame;
742 }
743 
744 void InspectorPageAgent::loaderDetachedFromFrame(DocumentLoader&amp; loader)
745 {
746     m_loaderToIdentifier.remove(&amp;loader);
747 }
748 
749 void InspectorPageAgent::frameStartedLoading(Frame&amp; frame)
750 {
751     m_frontendDispatcher-&gt;frameStartedLoading(frameId(&amp;frame));
752 }
753 
754 void InspectorPageAgent::frameStoppedLoading(Frame&amp; frame)
755 {
756     m_frontendDispatcher-&gt;frameStoppedLoading(frameId(&amp;frame));
757 }
758 
759 void InspectorPageAgent::frameScheduledNavigation(Frame&amp; frame, Seconds delay)
760 {
761     m_frontendDispatcher-&gt;frameScheduledNavigation(frameId(&amp;frame), delay.value());
762 }
763 
764 void InspectorPageAgent::frameClearedScheduledNavigation(Frame&amp; frame)
765 {
766     m_frontendDispatcher-&gt;frameClearedScheduledNavigation(frameId(&amp;frame));
767 }
768 
769 void InspectorPageAgent::defaultAppearanceDidChange(bool useDarkAppearance)
770 {
771     m_frontendDispatcher-&gt;defaultAppearanceDidChange(useDarkAppearance ? Inspector::Protocol::Page::Appearance::Dark : Inspector::Protocol::Page::Appearance::Light);
772 }
773 
774 void InspectorPageAgent::didClearWindowObjectInWorld(Frame&amp; frame, DOMWrapperWorld&amp; world)
775 {
776     if (&amp;world != &amp;mainThreadNormalWorld())
777         return;
778 
779     if (m_bootstrapScript.isEmpty())
780         return;
781 
782     frame.script().evaluateIgnoringException(ScriptSourceCode(m_bootstrapScript, URL { URL(), &quot;web-inspector://bootstrap.js&quot;_s }));
783 }
784 
785 void InspectorPageAgent::didPaint(RenderObject&amp; renderer, const LayoutRect&amp; rect)
786 {
787     if (!m_showPaintRects)
788         return;
789 
790     LayoutRect absoluteRect = LayoutRect(renderer.localToAbsoluteQuad(FloatRect(rect)).boundingBox());
791     FrameView* view = renderer.document().view();
792 
793     LayoutRect rootRect = absoluteRect;
794     if (!view-&gt;frame().isMainFrame()) {
795         IntRect rootViewRect = view-&gt;contentsToRootView(snappedIntRect(absoluteRect));
796         rootRect = view-&gt;frame().mainFrame().view()-&gt;rootViewToContents(rootViewRect);
797     }
798 
799     if (m_client-&gt;overridesShowPaintRects()) {
800         m_client-&gt;showPaintRect(rootRect);
801         return;
802     }
803 
804     m_overlay-&gt;showPaintRect(rootRect);
805 }
806 
807 void InspectorPageAgent::didLayout()
808 {
809     bool isFirstLayout = m_isFirstLayoutAfterOnLoad;
810     if (isFirstLayout)
811         m_isFirstLayoutAfterOnLoad = false;
812 
813     m_overlay-&gt;update();
814 }
815 
816 void InspectorPageAgent::didScroll()
817 {
818     m_overlay-&gt;update();
819 }
820 
821 void InspectorPageAgent::didRecalculateStyle()
822 {
823     m_overlay-&gt;update();
824 }
825 
826 Ref&lt;Inspector::Protocol::Page::Frame&gt; InspectorPageAgent::buildObjectForFrame(Frame* frame)
827 {
828     ASSERT_ARG(frame, frame);
829 
830     auto frameObject = Inspector::Protocol::Page::Frame::create()
831         .setId(frameId(frame))
832         .setLoaderId(loaderId(frame-&gt;loader().documentLoader()))
833         .setUrl(frame-&gt;document()-&gt;url().string())
834         .setMimeType(frame-&gt;loader().documentLoader()-&gt;responseMIMEType())
835         .setSecurityOrigin(frame-&gt;document()-&gt;securityOrigin().toRawString())
836         .release();
837     if (frame-&gt;tree().parent())
838         frameObject-&gt;setParentId(frameId(frame-&gt;tree().parent()));
839     if (frame-&gt;ownerElement()) {
840         String name = frame-&gt;ownerElement()-&gt;getNameAttribute();
841         if (name.isEmpty())
842             name = frame-&gt;ownerElement()-&gt;attributeWithoutSynchronization(HTMLNames::idAttr);
843         frameObject-&gt;setName(name);
844     }
845 
846     return frameObject;
847 }
848 
849 Ref&lt;Inspector::Protocol::Page::FrameResourceTree&gt; InspectorPageAgent::buildObjectForFrameTree(Frame* frame)
850 {
851     ASSERT_ARG(frame, frame);
852 
853     Ref&lt;Inspector::Protocol::Page::Frame&gt; frameObject = buildObjectForFrame(frame);
854     auto subresources = JSON::ArrayOf&lt;Inspector::Protocol::Page::FrameResource&gt;::create();
855     auto result = Inspector::Protocol::Page::FrameResourceTree::create()
856         .setFrame(WTFMove(frameObject))
857         .setResources(subresources.copyRef())
858         .release();
859 
860     for (auto* cachedResource : cachedResourcesForFrame(frame)) {
861         auto resourceObject = Inspector::Protocol::Page::FrameResource::create()
862             .setUrl(cachedResource-&gt;url())
863             .setType(cachedResourceTypeJSON(*cachedResource))
864             .setMimeType(cachedResource-&gt;response().mimeType())
865             .release();
866         if (cachedResource-&gt;wasCanceled())
867             resourceObject-&gt;setCanceled(true);
868         else if (cachedResource-&gt;status() == CachedResource::LoadError || cachedResource-&gt;status() == CachedResource::DecodeError)
869             resourceObject-&gt;setFailed(true);
870         String sourceMappingURL = InspectorPageAgent::sourceMapURLForResource(cachedResource);
871         if (!sourceMappingURL.isEmpty())
872             resourceObject-&gt;setSourceMapURL(sourceMappingURL);
873         String targetId = cachedResource-&gt;resourceRequest().initiatorIdentifier();
874         if (!targetId.isEmpty())
875             resourceObject-&gt;setTargetId(targetId);
876         subresources-&gt;addItem(WTFMove(resourceObject));
877     }
878 
879     RefPtr&lt;JSON::ArrayOf&lt;Inspector::Protocol::Page::FrameResourceTree&gt;&gt; childrenArray;
880     for (Frame* child = frame-&gt;tree().firstChild(); child; child = child-&gt;tree().nextSibling()) {
881         if (!childrenArray) {
882             childrenArray = JSON::ArrayOf&lt;Inspector::Protocol::Page::FrameResourceTree&gt;::create();
883             result-&gt;setChildFrames(childrenArray);
884         }
885         childrenArray-&gt;addItem(buildObjectForFrameTree(child));
886     }
887     return result;
888 }
889 
890 void InspectorPageAgent::setEmulatedMedia(ErrorString&amp;, const String&amp; media)
891 {
892     if (media == m_emulatedMedia)
893         return;
894 
895     m_emulatedMedia = media;
896 
897     // FIXME: Schedule a rendering update instead of synchronously updating the layout.
898     m_inspectedPage.updateStyleAfterChangeInEnvironment();
899 
900     auto document = makeRefPtr(m_inspectedPage.mainFrame().document());
901     if (!document)
902         return;
903 
904     document-&gt;updateLayout();
905     document-&gt;evaluateMediaQueriesAndReportChanges();
906 }
907 
908 void InspectorPageAgent::setForcedAppearance(ErrorString&amp;, const String&amp; appearance)
909 {
910     if (appearance == m_forcedAppearance)
911         return;
912 
913     m_forcedAppearance = appearance;
914 
915     if (appearance == &quot;Light&quot;_s)
916         m_inspectedPage.setUseDarkAppearanceOverride(false);
917     else if (appearance == &quot;Dark&quot;_s)
918         m_inspectedPage.setUseDarkAppearanceOverride(true);
919     else
920         m_inspectedPage.setUseDarkAppearanceOverride(WTF::nullopt);
921 }
922 
923 void InspectorPageAgent::applyUserAgentOverride(String&amp; userAgent)
924 {
925     if (!m_userAgentOverride.isEmpty())
926         userAgent = m_userAgentOverride;
927 }
928 
929 void InspectorPageAgent::applyEmulatedMedia(String&amp; media)
930 {
931     if (!m_emulatedMedia.isEmpty())
932         media = m_emulatedMedia;
933 }
934 
935 void InspectorPageAgent::snapshotNode(ErrorString&amp; errorString, int nodeId, String* outDataURL)
936 {
937     InspectorDOMAgent* domAgent = m_instrumentingAgents.inspectorDOMAgent();
938     ASSERT(domAgent);
939     Node* node = domAgent-&gt;assertNode(errorString, nodeId);
940     if (!node)
941         return;
942 
943     std::unique_ptr&lt;ImageBuffer&gt; snapshot = WebCore::snapshotNode(m_inspectedPage.mainFrame(), *node);
944     if (!snapshot) {
945         errorString = &quot;Could not capture snapshot&quot;_s;
946         return;
947     }
948 
949     *outDataURL = snapshot-&gt;toDataURL(&quot;image/png&quot;_s, WTF::nullopt, PreserveResolution::Yes);
950 }
951 
952 void InspectorPageAgent::snapshotRect(ErrorString&amp; errorString, int x, int y, int width, int height, const String&amp; coordinateSystem, String* outDataURL)
953 {
954     SnapshotOptions options = SnapshotOptionsNone;
955     if (coordinateSystem == &quot;Viewport&quot;)
956         options |= SnapshotOptionsInViewCoordinates;
957 
958     IntRect rectangle(x, y, width, height);
959     std::unique_ptr&lt;ImageBuffer&gt; snapshot = snapshotFrameRect(m_inspectedPage.mainFrame(), rectangle, options);
960 
961     if (!snapshot) {
962         errorString = &quot;Could not capture snapshot&quot;_s;
963         return;
964     }
965 
966     *outDataURL = snapshot-&gt;toDataURL(&quot;image/png&quot;_s, WTF::nullopt, PreserveResolution::Yes);
967 }
968 
969 void InspectorPageAgent::archive(ErrorString&amp; errorString, String* data)
970 {
971 #if ENABLE(WEB_ARCHIVE) &amp;&amp; USE(CF)
972     auto archive = LegacyWebArchive::create(m_inspectedPage.mainFrame());
973     if (!archive) {
974         errorString = &quot;Could not create web archive for main frame&quot;_s;
975         return;
976     }
977 
978     RetainPtr&lt;CFDataRef&gt; buffer = archive-&gt;rawDataRepresentation();
979     *data = base64Encode(CFDataGetBytePtr(buffer.get()), CFDataGetLength(buffer.get()));
980 #else
981     UNUSED_PARAM(data);
982     errorString = &quot;Not supported&quot;_s;
983 #endif
984 }
985 
986 } // namespace WebCore
    </pre>
  </body>
</html>
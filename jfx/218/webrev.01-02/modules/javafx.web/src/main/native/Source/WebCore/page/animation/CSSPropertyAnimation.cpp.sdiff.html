<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/page/animation/CSSPropertyAnimation.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CSSAnimationController.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSPropertyAnimation.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/page/animation/CSSPropertyAnimation.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  90 static inline Length blendFunc(const CSSPropertyBlendingClient*, const Length&amp; from, const Length&amp; to, double progress)
  91 {
  92     return blend(from, to, progress);
  93 }
  94 
  95 static inline GapLength blendFunc(const CSSPropertyBlendingClient*, const GapLength&amp; from, const GapLength&amp; to, double progress)
  96 {
  97     return (from.isNormal() || to.isNormal()) ? to : blend(from.length(), to.length(), progress);
  98 }
  99 
 100 static inline LengthSize blendFunc(const CSSPropertyBlendingClient* anim, const LengthSize&amp; from, const LengthSize&amp; to, double progress)
 101 {
 102     return { blendFunc(anim, from.width, to.width, progress), blendFunc(anim, from.height, to.height, progress) };
 103 }
 104 
 105 static inline ShadowStyle blendFunc(const CSSPropertyBlendingClient* anim, ShadowStyle from, ShadowStyle to, double progress)
 106 {
 107     if (from == to)
 108         return to;
 109 
<span class="line-modified"> 110     double fromVal = from == Normal ? 1 : 0;</span>
<span class="line-modified"> 111     double toVal = to == Normal ? 1 : 0;</span>
 112     double result = blendFunc(anim, fromVal, toVal, progress);
<span class="line-modified"> 113     return result &gt; 0 ? Normal : Inset;</span>
 114 }
 115 
 116 static inline std::unique_ptr&lt;ShadowData&gt; blendFunc(const CSSPropertyBlendingClient* anim, const ShadowData* from, const ShadowData* to, double progress)
 117 {
 118     ASSERT(from &amp;&amp; to);
 119     if (from-&gt;style() != to-&gt;style())
 120         return makeUnique&lt;ShadowData&gt;(*to);
 121 
 122     return makeUnique&lt;ShadowData&gt;(blend(from-&gt;location(), to-&gt;location(), progress),
 123         blend(from-&gt;radius(), to-&gt;radius(), progress),
 124         blend(from-&gt;spread(), to-&gt;spread(), progress),
 125         blendFunc(anim, from-&gt;style(), to-&gt;style(), progress),
 126         from-&gt;isWebkitBoxShadow(),
 127         blend(from-&gt;color(), to-&gt;color(), progress));
 128 }
 129 
 130 static inline TransformOperations blendFunc(const CSSPropertyBlendingClient* animation, const TransformOperations&amp; from, const TransformOperations&amp; to, double progress)
 131 {
 132     if (animation-&gt;transformFunctionListsMatch())
 133         return to.blendByMatchingOperations(from, progress);
</pre>
<hr />
<pre>
 268 }
 269 
 270 static inline TextDecorationThickness blendFunc(const CSSPropertyBlendingClient* anim, const TextDecorationThickness&amp; from, const TextDecorationThickness&amp; to, double progress)
 271 {
 272     if (from.isLength() &amp;&amp; to.isLength())
 273         return TextDecorationThickness::createWithLength(blendFunc(anim, from.lengthValue(), to.lengthValue(), progress));
 274     return TextDecorationThickness::createWithAuto();
 275 }
 276 
 277 static inline LengthBox blendFunc(const CSSPropertyBlendingClient* anim, const LengthBox&amp; from, const LengthBox&amp; to, double progress)
 278 {
 279     LengthBox result(blendFunc(anim, from.top(), to.top(), progress),
 280                      blendFunc(anim, from.right(), to.right(), progress),
 281                      blendFunc(anim, from.bottom(), to.bottom(), progress),
 282                      blendFunc(anim, from.left(), to.left(), progress));
 283     return result;
 284 }
 285 
 286 static inline SVGLengthValue blendFunc(const CSSPropertyBlendingClient*, const SVGLengthValue&amp; from, const SVGLengthValue&amp; to, double progress)
 287 {
<span class="line-modified"> 288     return to.blend(from, narrowPrecisionToFloat(progress));</span>
 289 }
 290 
 291 static inline Vector&lt;SVGLengthValue&gt; blendFunc(const CSSPropertyBlendingClient*, const Vector&lt;SVGLengthValue&gt;&amp; from, const Vector&lt;SVGLengthValue&gt;&amp; to, double progress)
 292 {
 293     size_t fromLength = from.size();
 294     size_t toLength = to.size();
 295     if (!fromLength)
 296         return !progress ? from : to;
 297     if (!toLength)
 298         return progress == 1 ? from : to;
 299     size_t resultLength = fromLength;
 300     if (fromLength != toLength) {
 301         if (!remainder(std::max(fromLength, toLength), std::min(fromLength, toLength)))
 302             resultLength = std::max(fromLength, toLength);
 303         else
 304             resultLength = fromLength * toLength;
 305     }
 306     Vector&lt;SVGLengthValue&gt; result(resultLength);
 307     for (size_t i = 0; i &lt; resultLength; ++i)
<span class="line-modified"> 308         result[i] = to[i % toLength].blend(from[i % fromLength], narrowPrecisionToFloat(progress));</span>
 309     return result;
 310 }
 311 
 312 static inline RefPtr&lt;StyleImage&gt; crossfadeBlend(const CSSPropertyBlendingClient*, StyleCachedImage* fromStyleImage, StyleCachedImage* toStyleImage, double progress)
 313 {
 314     // If progress is at one of the extremes, we want getComputedStyle to show the image,
 315     // not a completed cross-fade, so we hand back one of the existing images.
 316     if (!progress)
 317         return fromStyleImage;
 318     if (progress == 1)
 319         return toStyleImage;
 320     if (!fromStyleImage-&gt;cachedImage() || !toStyleImage-&gt;cachedImage())
 321         return toStyleImage;
 322 
 323     auto fromImageValue = CSSImageValue::create(*fromStyleImage-&gt;cachedImage());
 324     auto toImageValue = CSSImageValue::create(*toStyleImage-&gt;cachedImage());
<span class="line-modified"> 325     auto percentageValue = CSSPrimitiveValue::create(progress, CSSPrimitiveValue::CSS_NUMBER);</span>
 326 
 327     auto crossfadeValue = CSSCrossfadeValue::create(WTFMove(fromImageValue), WTFMove(toImageValue), WTFMove(percentageValue));
 328     return StyleGeneratedImage::create(WTFMove(crossfadeValue));
 329 }
 330 
 331 static inline RefPtr&lt;StyleImage&gt; blendFunc(const CSSPropertyBlendingClient* anim, StyleImage* from, StyleImage* to, double progress)
 332 {






 333     if (!from || !to)
 334         return to;
 335 
 336     // Animation between two generated images. Cross fade for all other cases.
 337     if (is&lt;StyleGeneratedImage&gt;(*from) &amp;&amp; is&lt;StyleGeneratedImage&gt;(*to)) {
 338         CSSImageGeneratorValue&amp; fromGenerated = downcast&lt;StyleGeneratedImage&gt;(*from).imageValue();
 339         CSSImageGeneratorValue&amp; toGenerated = downcast&lt;StyleGeneratedImage&gt;(*to).imageValue();
 340 
 341         if (is&lt;CSSFilterImageValue&gt;(fromGenerated) &amp;&amp; is&lt;CSSFilterImageValue&gt;(toGenerated)) {
 342             // Animation of generated images just possible if input images are equal.
 343             // Otherwise fall back to cross fade animation.
 344             CSSFilterImageValue&amp; fromFilter = downcast&lt;CSSFilterImageValue&gt;(fromGenerated);
 345             CSSFilterImageValue&amp; toFilter = downcast&lt;CSSFilterImageValue&gt;(toGenerated);
 346             if (fromFilter.equalInputImages(toFilter) &amp;&amp; fromFilter.cachedImage())
 347                 return blendFilter(anim, fromFilter.cachedImage(), fromFilter.filterOperations(), toFilter.filterOperations(), progress);
 348         }
 349 
 350         if (is&lt;CSSCrossfadeValue&gt;(fromGenerated) &amp;&amp; is&lt;CSSCrossfadeValue&gt;(toGenerated)) {
 351             CSSCrossfadeValue&amp; fromCrossfade = downcast&lt;CSSCrossfadeValue&gt;(fromGenerated);
 352             CSSCrossfadeValue&amp; toCrossfade = downcast&lt;CSSCrossfadeValue&gt;(toGenerated);
</pre>
<hr />
<pre>
 742 #endif
 743             ;
 744     }
 745 
 746     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 747     {
 748         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*PropertyWrapperGetter&lt;const FilterOperations&amp;&gt;::m_getter)(), (b-&gt;*PropertyWrapperGetter&lt;const FilterOperations&amp;&gt;::m_getter)(), progress, property()));
 749     }
 750 };
 751 
 752 static inline size_t shadowListLength(const ShadowData* shadow)
 753 {
 754     size_t count;
 755     for (count = 0; shadow; shadow = shadow-&gt;next())
 756         ++count;
 757     return count;
 758 }
 759 
 760 static inline const ShadowData* shadowForBlending(const ShadowData* srcShadow, const ShadowData* otherShadow)
 761 {
<span class="line-modified"> 762     static NeverDestroyed&lt;ShadowData&gt; defaultShadowData(IntPoint(), 0, 0, Normal, false, Color::transparent);</span>
<span class="line-modified"> 763     static NeverDestroyed&lt;ShadowData&gt; defaultInsetShadowData(IntPoint(), 0, 0, Inset, false, Color::transparent);</span>
<span class="line-modified"> 764     static NeverDestroyed&lt;ShadowData&gt; defaultWebKitBoxShadowData(IntPoint(), 0, 0, Normal, true, Color::transparent);</span>
<span class="line-modified"> 765     static NeverDestroyed&lt;ShadowData&gt; defaultInsetWebKitBoxShadowData(IntPoint(), 0, 0, Inset, true, Color::transparent);</span>
 766 
 767     if (srcShadow)
 768         return srcShadow;
 769 
<span class="line-modified"> 770     if (otherShadow-&gt;style() == Inset)</span>
 771         return otherShadow-&gt;isWebkitBoxShadow() ? &amp;defaultInsetWebKitBoxShadowData.get() : &amp;defaultInsetShadowData.get();
 772 
 773     return otherShadow-&gt;isWebkitBoxShadow() ? &amp;defaultWebKitBoxShadowData.get() : &amp;defaultShadowData.get();
 774 }
 775 
 776 class PropertyWrapperShadow : public AnimationPropertyWrapperBase {
 777     WTF_MAKE_FAST_ALLOCATED;
 778 public:
 779     PropertyWrapperShadow(CSSPropertyID prop, const ShadowData* (RenderStyle::*getter)() const, void (RenderStyle::*setter)(std::unique_ptr&lt;ShadowData&gt;, bool))
 780         : AnimationPropertyWrapperBase(prop)
 781         , m_getter(getter)
 782         , m_setter(setter)
 783     {
 784     }
 785 
 786     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 787     {
 788         if (a == b)
 789             return true;
 790         if (!a || !b)
</pre>
<hr />
<pre>
1595         new StyleImagePropertyWrapper(CSSPropertyWebkitMaskBoxImageSource, &amp;RenderStyle::maskBoxImageSource, &amp;RenderStyle::setMaskBoxImageSource),
1596         new PropertyWrapper&lt;const NinePieceImage&amp;&gt;(CSSPropertyWebkitMaskBoxImage, &amp;RenderStyle::maskBoxImage, &amp;RenderStyle::setMaskBoxImage),
1597 
1598         new FillLayersPropertyWrapper(CSSPropertyBackgroundPositionX, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1599         new FillLayersPropertyWrapper(CSSPropertyBackgroundPositionY, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1600         new FillLayersPropertyWrapper(CSSPropertyBackgroundSize, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1601         new FillLayersPropertyWrapper(CSSPropertyWebkitBackgroundSize, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1602 
1603         new FillLayersPropertyWrapper(CSSPropertyWebkitMaskPositionX, &amp;RenderStyle::maskLayers, &amp;RenderStyle::ensureMaskLayers),
1604         new FillLayersPropertyWrapper(CSSPropertyWebkitMaskPositionY, &amp;RenderStyle::maskLayers, &amp;RenderStyle::ensureMaskLayers),
1605         new FillLayersPropertyWrapper(CSSPropertyWebkitMaskSize, &amp;RenderStyle::maskLayers, &amp;RenderStyle::ensureMaskLayers),
1606 
1607         new PropertyWrapper&lt;float&gt;(CSSPropertyFontSize, &amp;RenderStyle::computedFontSize, &amp;RenderStyle::setFontSize),
1608         new PropertyWrapper&lt;unsigned short&gt;(CSSPropertyColumnRuleWidth, &amp;RenderStyle::columnRuleWidth, &amp;RenderStyle::setColumnRuleWidth),
1609         new LengthVariantPropertyWrapper&lt;GapLength&gt;(CSSPropertyColumnGap, &amp;RenderStyle::columnGap, &amp;RenderStyle::setColumnGap),
1610         new LengthVariantPropertyWrapper&lt;GapLength&gt;(CSSPropertyRowGap, &amp;RenderStyle::rowGap, &amp;RenderStyle::setRowGap),
1611         new PropertyWrapper&lt;unsigned short&gt;(CSSPropertyColumnCount, &amp;RenderStyle::columnCount, &amp;RenderStyle::setColumnCount),
1612         new PropertyWrapper&lt;float&gt;(CSSPropertyColumnWidth, &amp;RenderStyle::columnWidth, &amp;RenderStyle::setColumnWidth),
1613         new PropertyWrapper&lt;float&gt;(CSSPropertyWebkitBorderHorizontalSpacing, &amp;RenderStyle::horizontalBorderSpacing, &amp;RenderStyle::setHorizontalBorderSpacing),
1614         new PropertyWrapper&lt;float&gt;(CSSPropertyWebkitBorderVerticalSpacing, &amp;RenderStyle::verticalBorderSpacing, &amp;RenderStyle::setVerticalBorderSpacing),
<span class="line-modified">1615         new PropertyWrapper&lt;int&gt;(CSSPropertyZIndex, &amp;RenderStyle::zIndex, &amp;RenderStyle::setZIndex),</span>
1616         new PropertyWrapper&lt;short&gt;(CSSPropertyOrphans, &amp;RenderStyle::orphans, &amp;RenderStyle::setOrphans),
1617         new PropertyWrapper&lt;short&gt;(CSSPropertyWidows, &amp;RenderStyle::widows, &amp;RenderStyle::setWidows),
1618         new LengthPropertyWrapper(CSSPropertyLineHeight, &amp;RenderStyle::specifiedLineHeight, &amp;RenderStyle::setLineHeight),
1619         new PropertyWrapper&lt;float&gt;(CSSPropertyOutlineOffset, &amp;RenderStyle::outlineOffset, &amp;RenderStyle::setOutlineOffset),
1620         new PropertyWrapper&lt;float&gt;(CSSPropertyOutlineWidth, &amp;RenderStyle::outlineWidth, &amp;RenderStyle::setOutlineWidth),
1621         new PropertyWrapper&lt;float&gt;(CSSPropertyLetterSpacing, &amp;RenderStyle::letterSpacing, &amp;RenderStyle::setLetterSpacing),
1622         new LengthPropertyWrapper(CSSPropertyWordSpacing, &amp;RenderStyle::wordSpacing, &amp;RenderStyle::setWordSpacing),
1623         new LengthPropertyWrapper(CSSPropertyTextIndent, &amp;RenderStyle::textIndent, &amp;RenderStyle::setTextIndent),
1624 
1625         new PropertyWrapper&lt;float&gt;(CSSPropertyPerspective, &amp;RenderStyle::perspective, &amp;RenderStyle::setPerspective),
1626         new LengthPropertyWrapper(CSSPropertyPerspectiveOriginX, &amp;RenderStyle::perspectiveOriginX, &amp;RenderStyle::setPerspectiveOriginX),
1627         new LengthPropertyWrapper(CSSPropertyPerspectiveOriginY, &amp;RenderStyle::perspectiveOriginY, &amp;RenderStyle::setPerspectiveOriginY),
1628         new LengthPropertyWrapper(CSSPropertyTransformOriginX, &amp;RenderStyle::transformOriginX, &amp;RenderStyle::setTransformOriginX),
1629         new LengthPropertyWrapper(CSSPropertyTransformOriginY, &amp;RenderStyle::transformOriginY, &amp;RenderStyle::setTransformOriginY),
1630         new PropertyWrapper&lt;float&gt;(CSSPropertyTransformOriginZ, &amp;RenderStyle::transformOriginZ, &amp;RenderStyle::setTransformOriginZ),
1631         new LengthVariantPropertyWrapper&lt;LengthSize&gt;(CSSPropertyBorderTopLeftRadius, &amp;RenderStyle::borderTopLeftRadius, &amp;RenderStyle::setBorderTopLeftRadius),
1632         new LengthVariantPropertyWrapper&lt;LengthSize&gt;(CSSPropertyBorderTopRightRadius, &amp;RenderStyle::borderTopRightRadius, &amp;RenderStyle::setBorderTopRightRadius),
1633         new LengthVariantPropertyWrapper&lt;LengthSize&gt;(CSSPropertyBorderBottomLeftRadius, &amp;RenderStyle::borderBottomLeftRadius, &amp;RenderStyle::setBorderBottomLeftRadius),
1634         new LengthVariantPropertyWrapper&lt;LengthSize&gt;(CSSPropertyBorderBottomRightRadius, &amp;RenderStyle::borderBottomRightRadius, &amp;RenderStyle::setBorderBottomRightRadius),
1635         new PropertyWrapper&lt;Visibility&gt;(CSSPropertyVisibility, &amp;RenderStyle::visibility, &amp;RenderStyle::setVisibility),
1636         new PropertyWrapper&lt;float&gt;(CSSPropertyZoom, &amp;RenderStyle::zoom, &amp;RenderStyle::setZoomWithoutReturnValue),
1637 
1638         new LengthVariantPropertyWrapper&lt;LengthBox&gt;(CSSPropertyClip, &amp;RenderStyle::clip, &amp;RenderStyle::setClip),
1639 
1640         new PropertyWrapperAcceleratedOpacity(),
1641         new PropertyWrapperAcceleratedTransform(),
1642 
1643         new PropertyWrapperFilter(CSSPropertyFilter, &amp;RenderStyle::filter, &amp;RenderStyle::setFilter),
1644 #if ENABLE(FILTERS_LEVEL_2)
1645         new PropertyWrapperFilter(CSSPropertyWebkitBackdropFilter, &amp;RenderStyle::backdropFilter, &amp;RenderStyle::setBackdropFilter),
1646 #endif
1647         new PropertyWrapperFilter(CSSPropertyAppleColorFilter, &amp;RenderStyle::appleColorFilter, &amp;RenderStyle::setAppleColorFilter),
1648 
<span class="line-modified">1649         new PropertyWrapperClipPath(CSSPropertyWebkitClipPath, &amp;RenderStyle::clipPath, &amp;RenderStyle::setClipPath),</span>
1650 
1651         new PropertyWrapperShape(CSSPropertyShapeOutside, &amp;RenderStyle::shapeOutside, &amp;RenderStyle::setShapeOutside),
1652         new LengthPropertyWrapper(CSSPropertyShapeMargin, &amp;RenderStyle::shapeMargin, &amp;RenderStyle::setShapeMargin),
1653         new PropertyWrapper&lt;float&gt;(CSSPropertyShapeImageThreshold, &amp;RenderStyle::shapeImageThreshold, &amp;RenderStyle::setShapeImageThreshold),
1654 
1655         new PropertyWrapperVisitedAffectedColor(CSSPropertyColumnRuleColor, MaybeInvalidColor, &amp;RenderStyle::columnRuleColor, &amp;RenderStyle::setColumnRuleColor, &amp;RenderStyle::visitedLinkColumnRuleColor, &amp;RenderStyle::setVisitedLinkColumnRuleColor),
1656         new PropertyWrapperVisitedAffectedColor(CSSPropertyWebkitTextStrokeColor, MaybeInvalidColor, &amp;RenderStyle::textStrokeColor, &amp;RenderStyle::setTextStrokeColor, &amp;RenderStyle::visitedLinkTextStrokeColor, &amp;RenderStyle::setVisitedLinkTextStrokeColor),
1657         new PropertyWrapperVisitedAffectedColor(CSSPropertyWebkitTextFillColor, MaybeInvalidColor, &amp;RenderStyle::textFillColor, &amp;RenderStyle::setTextFillColor, &amp;RenderStyle::visitedLinkTextFillColor, &amp;RenderStyle::setVisitedLinkTextFillColor),
1658         new PropertyWrapperVisitedAffectedColor(CSSPropertyBorderLeftColor, MaybeInvalidColor, &amp;RenderStyle::borderLeftColor, &amp;RenderStyle::setBorderLeftColor, &amp;RenderStyle::visitedLinkBorderLeftColor, &amp;RenderStyle::setVisitedLinkBorderLeftColor),
1659         new PropertyWrapperVisitedAffectedColor(CSSPropertyBorderRightColor, MaybeInvalidColor, &amp;RenderStyle::borderRightColor, &amp;RenderStyle::setBorderRightColor, &amp;RenderStyle::visitedLinkBorderRightColor, &amp;RenderStyle::setVisitedLinkBorderRightColor),
1660         new PropertyWrapperVisitedAffectedColor(CSSPropertyBorderTopColor, MaybeInvalidColor, &amp;RenderStyle::borderTopColor, &amp;RenderStyle::setBorderTopColor, &amp;RenderStyle::visitedLinkBorderTopColor, &amp;RenderStyle::setVisitedLinkBorderTopColor),
1661         new PropertyWrapperVisitedAffectedColor(CSSPropertyBorderBottomColor, MaybeInvalidColor, &amp;RenderStyle::borderBottomColor, &amp;RenderStyle::setBorderBottomColor, &amp;RenderStyle::visitedLinkBorderBottomColor, &amp;RenderStyle::setVisitedLinkBorderBottomColor),
1662         new PropertyWrapperVisitedAffectedColor(CSSPropertyOutlineColor, MaybeInvalidColor, &amp;RenderStyle::outlineColor, &amp;RenderStyle::setOutlineColor, &amp;RenderStyle::visitedLinkOutlineColor, &amp;RenderStyle::setVisitedLinkOutlineColor),
1663 
1664         new PropertyWrapperShadow(CSSPropertyBoxShadow, &amp;RenderStyle::boxShadow, &amp;RenderStyle::setBoxShadow),
1665         new PropertyWrapperShadow(CSSPropertyWebkitBoxShadow, &amp;RenderStyle::boxShadow, &amp;RenderStyle::setBoxShadow),
1666         new PropertyWrapperShadow(CSSPropertyTextShadow, &amp;RenderStyle::textShadow, &amp;RenderStyle::setTextShadow),
1667 
1668         new PropertyWrapperSVGPaint(CSSPropertyFill, &amp;RenderStyle::fillPaintType, &amp;RenderStyle::fillPaintColor, &amp;RenderStyle::setFillPaintColor),
1669         new PropertyWrapper&lt;float&gt;(CSSPropertyFillOpacity, &amp;RenderStyle::fillOpacity, &amp;RenderStyle::setFillOpacity),
</pre>
<hr />
<pre>
1777 
1778 static bool gatherEnclosingShorthandProperties(CSSPropertyID property, AnimationPropertyWrapperBase* wrapper, HashSet&lt;CSSPropertyID&gt;&amp; propertySet)
1779 {
1780     if (!wrapper-&gt;isShorthandWrapper())
1781         return false;
1782 
1783     ShorthandPropertyWrapper* shorthandWrapper = static_cast&lt;ShorthandPropertyWrapper*&gt;(wrapper);
1784     bool contained = false;
1785     for (auto&amp; currWrapper : shorthandWrapper-&gt;propertyWrappers()) {
1786         if (gatherEnclosingShorthandProperties(property, currWrapper, propertySet) || currWrapper-&gt;property() == property)
1787             contained = true;
1788     }
1789 
1790     if (contained)
1791         propertySet.add(wrapper-&gt;property());
1792 
1793     return contained;
1794 }
1795 
1796 // Returns true if we need to start animation timers
<span class="line-modified">1797 bool CSSPropertyAnimation::blendProperties(const CSSPropertyBlendingClient* anim, CSSPropertyID prop, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress)</span>
1798 {
1799     ASSERT(prop != CSSPropertyInvalid);
1800 
1801     AnimationPropertyWrapperBase* wrapper = CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
1802     if (wrapper) {
1803         wrapper-&gt;blend(anim, dst, a, b, progress);
1804 #if !LOG_DISABLED
1805         wrapper-&gt;logBlend(a, b, dst, progress);
1806 #endif
<span class="line-removed">1807         return !wrapper-&gt;animationIsAccelerated() || !anim-&gt;isAccelerated();</span>
1808     }
<span class="line-removed">1809     return false;</span>
1810 }
1811 
1812 bool CSSPropertyAnimation::isPropertyAnimatable(CSSPropertyID prop)
1813 {
1814     return CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
1815 }
1816 
1817 bool CSSPropertyAnimation::animationOfPropertyIsAccelerated(CSSPropertyID prop)
1818 {
1819     AnimationPropertyWrapperBase* wrapper = CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
1820     return wrapper ? wrapper-&gt;animationIsAccelerated() : false;
1821 }
1822 
1823 // Note: this is inefficient. It&#39;s only called from pauseTransitionAtTime().
1824 HashSet&lt;CSSPropertyID&gt; CSSPropertyAnimation::animatableShorthandsAffectingProperty(CSSPropertyID property)
1825 {
1826     CSSPropertyAnimationWrapperMap&amp; map = CSSPropertyAnimationWrapperMap::singleton();
1827 
1828     HashSet&lt;CSSPropertyID&gt; foundProperties;
1829     for (unsigned i = 0; i &lt; map.size(); ++i)
</pre>
</td>
<td>
<hr />
<pre>
  90 static inline Length blendFunc(const CSSPropertyBlendingClient*, const Length&amp; from, const Length&amp; to, double progress)
  91 {
  92     return blend(from, to, progress);
  93 }
  94 
  95 static inline GapLength blendFunc(const CSSPropertyBlendingClient*, const GapLength&amp; from, const GapLength&amp; to, double progress)
  96 {
  97     return (from.isNormal() || to.isNormal()) ? to : blend(from.length(), to.length(), progress);
  98 }
  99 
 100 static inline LengthSize blendFunc(const CSSPropertyBlendingClient* anim, const LengthSize&amp; from, const LengthSize&amp; to, double progress)
 101 {
 102     return { blendFunc(anim, from.width, to.width, progress), blendFunc(anim, from.height, to.height, progress) };
 103 }
 104 
 105 static inline ShadowStyle blendFunc(const CSSPropertyBlendingClient* anim, ShadowStyle from, ShadowStyle to, double progress)
 106 {
 107     if (from == to)
 108         return to;
 109 
<span class="line-modified"> 110     double fromVal = from == ShadowStyle::Normal ? 1 : 0;</span>
<span class="line-modified"> 111     double toVal = to == ShadowStyle::Normal ? 1 : 0;</span>
 112     double result = blendFunc(anim, fromVal, toVal, progress);
<span class="line-modified"> 113     return result &gt; 0 ? ShadowStyle::Normal : ShadowStyle::Inset;</span>
 114 }
 115 
 116 static inline std::unique_ptr&lt;ShadowData&gt; blendFunc(const CSSPropertyBlendingClient* anim, const ShadowData* from, const ShadowData* to, double progress)
 117 {
 118     ASSERT(from &amp;&amp; to);
 119     if (from-&gt;style() != to-&gt;style())
 120         return makeUnique&lt;ShadowData&gt;(*to);
 121 
 122     return makeUnique&lt;ShadowData&gt;(blend(from-&gt;location(), to-&gt;location(), progress),
 123         blend(from-&gt;radius(), to-&gt;radius(), progress),
 124         blend(from-&gt;spread(), to-&gt;spread(), progress),
 125         blendFunc(anim, from-&gt;style(), to-&gt;style(), progress),
 126         from-&gt;isWebkitBoxShadow(),
 127         blend(from-&gt;color(), to-&gt;color(), progress));
 128 }
 129 
 130 static inline TransformOperations blendFunc(const CSSPropertyBlendingClient* animation, const TransformOperations&amp; from, const TransformOperations&amp; to, double progress)
 131 {
 132     if (animation-&gt;transformFunctionListsMatch())
 133         return to.blendByMatchingOperations(from, progress);
</pre>
<hr />
<pre>
 268 }
 269 
 270 static inline TextDecorationThickness blendFunc(const CSSPropertyBlendingClient* anim, const TextDecorationThickness&amp; from, const TextDecorationThickness&amp; to, double progress)
 271 {
 272     if (from.isLength() &amp;&amp; to.isLength())
 273         return TextDecorationThickness::createWithLength(blendFunc(anim, from.lengthValue(), to.lengthValue(), progress));
 274     return TextDecorationThickness::createWithAuto();
 275 }
 276 
 277 static inline LengthBox blendFunc(const CSSPropertyBlendingClient* anim, const LengthBox&amp; from, const LengthBox&amp; to, double progress)
 278 {
 279     LengthBox result(blendFunc(anim, from.top(), to.top(), progress),
 280                      blendFunc(anim, from.right(), to.right(), progress),
 281                      blendFunc(anim, from.bottom(), to.bottom(), progress),
 282                      blendFunc(anim, from.left(), to.left(), progress));
 283     return result;
 284 }
 285 
 286 static inline SVGLengthValue blendFunc(const CSSPropertyBlendingClient*, const SVGLengthValue&amp; from, const SVGLengthValue&amp; to, double progress)
 287 {
<span class="line-modified"> 288     return SVGLengthValue::blend(from, to, narrowPrecisionToFloat(progress));</span>
 289 }
 290 
 291 static inline Vector&lt;SVGLengthValue&gt; blendFunc(const CSSPropertyBlendingClient*, const Vector&lt;SVGLengthValue&gt;&amp; from, const Vector&lt;SVGLengthValue&gt;&amp; to, double progress)
 292 {
 293     size_t fromLength = from.size();
 294     size_t toLength = to.size();
 295     if (!fromLength)
 296         return !progress ? from : to;
 297     if (!toLength)
 298         return progress == 1 ? from : to;
 299     size_t resultLength = fromLength;
 300     if (fromLength != toLength) {
 301         if (!remainder(std::max(fromLength, toLength), std::min(fromLength, toLength)))
 302             resultLength = std::max(fromLength, toLength);
 303         else
 304             resultLength = fromLength * toLength;
 305     }
 306     Vector&lt;SVGLengthValue&gt; result(resultLength);
 307     for (size_t i = 0; i &lt; resultLength; ++i)
<span class="line-modified"> 308         result[i] = SVGLengthValue::blend(from[i % fromLength], to[i % toLength], narrowPrecisionToFloat(progress));</span>
 309     return result;
 310 }
 311 
 312 static inline RefPtr&lt;StyleImage&gt; crossfadeBlend(const CSSPropertyBlendingClient*, StyleCachedImage* fromStyleImage, StyleCachedImage* toStyleImage, double progress)
 313 {
 314     // If progress is at one of the extremes, we want getComputedStyle to show the image,
 315     // not a completed cross-fade, so we hand back one of the existing images.
 316     if (!progress)
 317         return fromStyleImage;
 318     if (progress == 1)
 319         return toStyleImage;
 320     if (!fromStyleImage-&gt;cachedImage() || !toStyleImage-&gt;cachedImage())
 321         return toStyleImage;
 322 
 323     auto fromImageValue = CSSImageValue::create(*fromStyleImage-&gt;cachedImage());
 324     auto toImageValue = CSSImageValue::create(*toStyleImage-&gt;cachedImage());
<span class="line-modified"> 325     auto percentageValue = CSSPrimitiveValue::create(progress, CSSUnitType::CSS_NUMBER);</span>
 326 
 327     auto crossfadeValue = CSSCrossfadeValue::create(WTFMove(fromImageValue), WTFMove(toImageValue), WTFMove(percentageValue));
 328     return StyleGeneratedImage::create(WTFMove(crossfadeValue));
 329 }
 330 
 331 static inline RefPtr&lt;StyleImage&gt; blendFunc(const CSSPropertyBlendingClient* anim, StyleImage* from, StyleImage* to, double progress)
 332 {
<span class="line-added"> 333     if (!from || !to)</span>
<span class="line-added"> 334         return to;</span>
<span class="line-added"> 335 </span>
<span class="line-added"> 336     from = from-&gt;selectedImage();</span>
<span class="line-added"> 337     to = to-&gt;selectedImage();</span>
<span class="line-added"> 338 </span>
 339     if (!from || !to)
 340         return to;
 341 
 342     // Animation between two generated images. Cross fade for all other cases.
 343     if (is&lt;StyleGeneratedImage&gt;(*from) &amp;&amp; is&lt;StyleGeneratedImage&gt;(*to)) {
 344         CSSImageGeneratorValue&amp; fromGenerated = downcast&lt;StyleGeneratedImage&gt;(*from).imageValue();
 345         CSSImageGeneratorValue&amp; toGenerated = downcast&lt;StyleGeneratedImage&gt;(*to).imageValue();
 346 
 347         if (is&lt;CSSFilterImageValue&gt;(fromGenerated) &amp;&amp; is&lt;CSSFilterImageValue&gt;(toGenerated)) {
 348             // Animation of generated images just possible if input images are equal.
 349             // Otherwise fall back to cross fade animation.
 350             CSSFilterImageValue&amp; fromFilter = downcast&lt;CSSFilterImageValue&gt;(fromGenerated);
 351             CSSFilterImageValue&amp; toFilter = downcast&lt;CSSFilterImageValue&gt;(toGenerated);
 352             if (fromFilter.equalInputImages(toFilter) &amp;&amp; fromFilter.cachedImage())
 353                 return blendFilter(anim, fromFilter.cachedImage(), fromFilter.filterOperations(), toFilter.filterOperations(), progress);
 354         }
 355 
 356         if (is&lt;CSSCrossfadeValue&gt;(fromGenerated) &amp;&amp; is&lt;CSSCrossfadeValue&gt;(toGenerated)) {
 357             CSSCrossfadeValue&amp; fromCrossfade = downcast&lt;CSSCrossfadeValue&gt;(fromGenerated);
 358             CSSCrossfadeValue&amp; toCrossfade = downcast&lt;CSSCrossfadeValue&gt;(toGenerated);
</pre>
<hr />
<pre>
 748 #endif
 749             ;
 750     }
 751 
 752     void blend(const CSSPropertyBlendingClient* anim, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress) const override
 753     {
 754         (dst-&gt;*m_setter)(blendFunc(anim, (a-&gt;*PropertyWrapperGetter&lt;const FilterOperations&amp;&gt;::m_getter)(), (b-&gt;*PropertyWrapperGetter&lt;const FilterOperations&amp;&gt;::m_getter)(), progress, property()));
 755     }
 756 };
 757 
 758 static inline size_t shadowListLength(const ShadowData* shadow)
 759 {
 760     size_t count;
 761     for (count = 0; shadow; shadow = shadow-&gt;next())
 762         ++count;
 763     return count;
 764 }
 765 
 766 static inline const ShadowData* shadowForBlending(const ShadowData* srcShadow, const ShadowData* otherShadow)
 767 {
<span class="line-modified"> 768     static NeverDestroyed&lt;ShadowData&gt; defaultShadowData(LayoutPoint(), 0, 0, ShadowStyle::Normal, false, Color::transparent);</span>
<span class="line-modified"> 769     static NeverDestroyed&lt;ShadowData&gt; defaultInsetShadowData(LayoutPoint(), 0, 0, ShadowStyle::Inset, false, Color::transparent);</span>
<span class="line-modified"> 770     static NeverDestroyed&lt;ShadowData&gt; defaultWebKitBoxShadowData(LayoutPoint(), 0, 0, ShadowStyle::Normal, true, Color::transparent);</span>
<span class="line-modified"> 771     static NeverDestroyed&lt;ShadowData&gt; defaultInsetWebKitBoxShadowData(LayoutPoint(), 0, 0, ShadowStyle::Inset, true, Color::transparent);</span>
 772 
 773     if (srcShadow)
 774         return srcShadow;
 775 
<span class="line-modified"> 776     if (otherShadow-&gt;style() == ShadowStyle::Inset)</span>
 777         return otherShadow-&gt;isWebkitBoxShadow() ? &amp;defaultInsetWebKitBoxShadowData.get() : &amp;defaultInsetShadowData.get();
 778 
 779     return otherShadow-&gt;isWebkitBoxShadow() ? &amp;defaultWebKitBoxShadowData.get() : &amp;defaultShadowData.get();
 780 }
 781 
 782 class PropertyWrapperShadow : public AnimationPropertyWrapperBase {
 783     WTF_MAKE_FAST_ALLOCATED;
 784 public:
 785     PropertyWrapperShadow(CSSPropertyID prop, const ShadowData* (RenderStyle::*getter)() const, void (RenderStyle::*setter)(std::unique_ptr&lt;ShadowData&gt;, bool))
 786         : AnimationPropertyWrapperBase(prop)
 787         , m_getter(getter)
 788         , m_setter(setter)
 789     {
 790     }
 791 
 792     bool equals(const RenderStyle* a, const RenderStyle* b) const override
 793     {
 794         if (a == b)
 795             return true;
 796         if (!a || !b)
</pre>
<hr />
<pre>
1601         new StyleImagePropertyWrapper(CSSPropertyWebkitMaskBoxImageSource, &amp;RenderStyle::maskBoxImageSource, &amp;RenderStyle::setMaskBoxImageSource),
1602         new PropertyWrapper&lt;const NinePieceImage&amp;&gt;(CSSPropertyWebkitMaskBoxImage, &amp;RenderStyle::maskBoxImage, &amp;RenderStyle::setMaskBoxImage),
1603 
1604         new FillLayersPropertyWrapper(CSSPropertyBackgroundPositionX, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1605         new FillLayersPropertyWrapper(CSSPropertyBackgroundPositionY, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1606         new FillLayersPropertyWrapper(CSSPropertyBackgroundSize, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1607         new FillLayersPropertyWrapper(CSSPropertyWebkitBackgroundSize, &amp;RenderStyle::backgroundLayers, &amp;RenderStyle::ensureBackgroundLayers),
1608 
1609         new FillLayersPropertyWrapper(CSSPropertyWebkitMaskPositionX, &amp;RenderStyle::maskLayers, &amp;RenderStyle::ensureMaskLayers),
1610         new FillLayersPropertyWrapper(CSSPropertyWebkitMaskPositionY, &amp;RenderStyle::maskLayers, &amp;RenderStyle::ensureMaskLayers),
1611         new FillLayersPropertyWrapper(CSSPropertyWebkitMaskSize, &amp;RenderStyle::maskLayers, &amp;RenderStyle::ensureMaskLayers),
1612 
1613         new PropertyWrapper&lt;float&gt;(CSSPropertyFontSize, &amp;RenderStyle::computedFontSize, &amp;RenderStyle::setFontSize),
1614         new PropertyWrapper&lt;unsigned short&gt;(CSSPropertyColumnRuleWidth, &amp;RenderStyle::columnRuleWidth, &amp;RenderStyle::setColumnRuleWidth),
1615         new LengthVariantPropertyWrapper&lt;GapLength&gt;(CSSPropertyColumnGap, &amp;RenderStyle::columnGap, &amp;RenderStyle::setColumnGap),
1616         new LengthVariantPropertyWrapper&lt;GapLength&gt;(CSSPropertyRowGap, &amp;RenderStyle::rowGap, &amp;RenderStyle::setRowGap),
1617         new PropertyWrapper&lt;unsigned short&gt;(CSSPropertyColumnCount, &amp;RenderStyle::columnCount, &amp;RenderStyle::setColumnCount),
1618         new PropertyWrapper&lt;float&gt;(CSSPropertyColumnWidth, &amp;RenderStyle::columnWidth, &amp;RenderStyle::setColumnWidth),
1619         new PropertyWrapper&lt;float&gt;(CSSPropertyWebkitBorderHorizontalSpacing, &amp;RenderStyle::horizontalBorderSpacing, &amp;RenderStyle::setHorizontalBorderSpacing),
1620         new PropertyWrapper&lt;float&gt;(CSSPropertyWebkitBorderVerticalSpacing, &amp;RenderStyle::verticalBorderSpacing, &amp;RenderStyle::setVerticalBorderSpacing),
<span class="line-modified">1621         new PropertyWrapper&lt;int&gt;(CSSPropertyZIndex, &amp;RenderStyle::specifiedZIndex, &amp;RenderStyle::setSpecifiedZIndex),</span>
1622         new PropertyWrapper&lt;short&gt;(CSSPropertyOrphans, &amp;RenderStyle::orphans, &amp;RenderStyle::setOrphans),
1623         new PropertyWrapper&lt;short&gt;(CSSPropertyWidows, &amp;RenderStyle::widows, &amp;RenderStyle::setWidows),
1624         new LengthPropertyWrapper(CSSPropertyLineHeight, &amp;RenderStyle::specifiedLineHeight, &amp;RenderStyle::setLineHeight),
1625         new PropertyWrapper&lt;float&gt;(CSSPropertyOutlineOffset, &amp;RenderStyle::outlineOffset, &amp;RenderStyle::setOutlineOffset),
1626         new PropertyWrapper&lt;float&gt;(CSSPropertyOutlineWidth, &amp;RenderStyle::outlineWidth, &amp;RenderStyle::setOutlineWidth),
1627         new PropertyWrapper&lt;float&gt;(CSSPropertyLetterSpacing, &amp;RenderStyle::letterSpacing, &amp;RenderStyle::setLetterSpacing),
1628         new LengthPropertyWrapper(CSSPropertyWordSpacing, &amp;RenderStyle::wordSpacing, &amp;RenderStyle::setWordSpacing),
1629         new LengthPropertyWrapper(CSSPropertyTextIndent, &amp;RenderStyle::textIndent, &amp;RenderStyle::setTextIndent),
1630 
1631         new PropertyWrapper&lt;float&gt;(CSSPropertyPerspective, &amp;RenderStyle::perspective, &amp;RenderStyle::setPerspective),
1632         new LengthPropertyWrapper(CSSPropertyPerspectiveOriginX, &amp;RenderStyle::perspectiveOriginX, &amp;RenderStyle::setPerspectiveOriginX),
1633         new LengthPropertyWrapper(CSSPropertyPerspectiveOriginY, &amp;RenderStyle::perspectiveOriginY, &amp;RenderStyle::setPerspectiveOriginY),
1634         new LengthPropertyWrapper(CSSPropertyTransformOriginX, &amp;RenderStyle::transformOriginX, &amp;RenderStyle::setTransformOriginX),
1635         new LengthPropertyWrapper(CSSPropertyTransformOriginY, &amp;RenderStyle::transformOriginY, &amp;RenderStyle::setTransformOriginY),
1636         new PropertyWrapper&lt;float&gt;(CSSPropertyTransformOriginZ, &amp;RenderStyle::transformOriginZ, &amp;RenderStyle::setTransformOriginZ),
1637         new LengthVariantPropertyWrapper&lt;LengthSize&gt;(CSSPropertyBorderTopLeftRadius, &amp;RenderStyle::borderTopLeftRadius, &amp;RenderStyle::setBorderTopLeftRadius),
1638         new LengthVariantPropertyWrapper&lt;LengthSize&gt;(CSSPropertyBorderTopRightRadius, &amp;RenderStyle::borderTopRightRadius, &amp;RenderStyle::setBorderTopRightRadius),
1639         new LengthVariantPropertyWrapper&lt;LengthSize&gt;(CSSPropertyBorderBottomLeftRadius, &amp;RenderStyle::borderBottomLeftRadius, &amp;RenderStyle::setBorderBottomLeftRadius),
1640         new LengthVariantPropertyWrapper&lt;LengthSize&gt;(CSSPropertyBorderBottomRightRadius, &amp;RenderStyle::borderBottomRightRadius, &amp;RenderStyle::setBorderBottomRightRadius),
1641         new PropertyWrapper&lt;Visibility&gt;(CSSPropertyVisibility, &amp;RenderStyle::visibility, &amp;RenderStyle::setVisibility),
1642         new PropertyWrapper&lt;float&gt;(CSSPropertyZoom, &amp;RenderStyle::zoom, &amp;RenderStyle::setZoomWithoutReturnValue),
1643 
1644         new LengthVariantPropertyWrapper&lt;LengthBox&gt;(CSSPropertyClip, &amp;RenderStyle::clip, &amp;RenderStyle::setClip),
1645 
1646         new PropertyWrapperAcceleratedOpacity(),
1647         new PropertyWrapperAcceleratedTransform(),
1648 
1649         new PropertyWrapperFilter(CSSPropertyFilter, &amp;RenderStyle::filter, &amp;RenderStyle::setFilter),
1650 #if ENABLE(FILTERS_LEVEL_2)
1651         new PropertyWrapperFilter(CSSPropertyWebkitBackdropFilter, &amp;RenderStyle::backdropFilter, &amp;RenderStyle::setBackdropFilter),
1652 #endif
1653         new PropertyWrapperFilter(CSSPropertyAppleColorFilter, &amp;RenderStyle::appleColorFilter, &amp;RenderStyle::setAppleColorFilter),
1654 
<span class="line-modified">1655         new PropertyWrapperClipPath(CSSPropertyClipPath, &amp;RenderStyle::clipPath, &amp;RenderStyle::setClipPath),</span>
1656 
1657         new PropertyWrapperShape(CSSPropertyShapeOutside, &amp;RenderStyle::shapeOutside, &amp;RenderStyle::setShapeOutside),
1658         new LengthPropertyWrapper(CSSPropertyShapeMargin, &amp;RenderStyle::shapeMargin, &amp;RenderStyle::setShapeMargin),
1659         new PropertyWrapper&lt;float&gt;(CSSPropertyShapeImageThreshold, &amp;RenderStyle::shapeImageThreshold, &amp;RenderStyle::setShapeImageThreshold),
1660 
1661         new PropertyWrapperVisitedAffectedColor(CSSPropertyColumnRuleColor, MaybeInvalidColor, &amp;RenderStyle::columnRuleColor, &amp;RenderStyle::setColumnRuleColor, &amp;RenderStyle::visitedLinkColumnRuleColor, &amp;RenderStyle::setVisitedLinkColumnRuleColor),
1662         new PropertyWrapperVisitedAffectedColor(CSSPropertyWebkitTextStrokeColor, MaybeInvalidColor, &amp;RenderStyle::textStrokeColor, &amp;RenderStyle::setTextStrokeColor, &amp;RenderStyle::visitedLinkTextStrokeColor, &amp;RenderStyle::setVisitedLinkTextStrokeColor),
1663         new PropertyWrapperVisitedAffectedColor(CSSPropertyWebkitTextFillColor, MaybeInvalidColor, &amp;RenderStyle::textFillColor, &amp;RenderStyle::setTextFillColor, &amp;RenderStyle::visitedLinkTextFillColor, &amp;RenderStyle::setVisitedLinkTextFillColor),
1664         new PropertyWrapperVisitedAffectedColor(CSSPropertyBorderLeftColor, MaybeInvalidColor, &amp;RenderStyle::borderLeftColor, &amp;RenderStyle::setBorderLeftColor, &amp;RenderStyle::visitedLinkBorderLeftColor, &amp;RenderStyle::setVisitedLinkBorderLeftColor),
1665         new PropertyWrapperVisitedAffectedColor(CSSPropertyBorderRightColor, MaybeInvalidColor, &amp;RenderStyle::borderRightColor, &amp;RenderStyle::setBorderRightColor, &amp;RenderStyle::visitedLinkBorderRightColor, &amp;RenderStyle::setVisitedLinkBorderRightColor),
1666         new PropertyWrapperVisitedAffectedColor(CSSPropertyBorderTopColor, MaybeInvalidColor, &amp;RenderStyle::borderTopColor, &amp;RenderStyle::setBorderTopColor, &amp;RenderStyle::visitedLinkBorderTopColor, &amp;RenderStyle::setVisitedLinkBorderTopColor),
1667         new PropertyWrapperVisitedAffectedColor(CSSPropertyBorderBottomColor, MaybeInvalidColor, &amp;RenderStyle::borderBottomColor, &amp;RenderStyle::setBorderBottomColor, &amp;RenderStyle::visitedLinkBorderBottomColor, &amp;RenderStyle::setVisitedLinkBorderBottomColor),
1668         new PropertyWrapperVisitedAffectedColor(CSSPropertyOutlineColor, MaybeInvalidColor, &amp;RenderStyle::outlineColor, &amp;RenderStyle::setOutlineColor, &amp;RenderStyle::visitedLinkOutlineColor, &amp;RenderStyle::setVisitedLinkOutlineColor),
1669 
1670         new PropertyWrapperShadow(CSSPropertyBoxShadow, &amp;RenderStyle::boxShadow, &amp;RenderStyle::setBoxShadow),
1671         new PropertyWrapperShadow(CSSPropertyWebkitBoxShadow, &amp;RenderStyle::boxShadow, &amp;RenderStyle::setBoxShadow),
1672         new PropertyWrapperShadow(CSSPropertyTextShadow, &amp;RenderStyle::textShadow, &amp;RenderStyle::setTextShadow),
1673 
1674         new PropertyWrapperSVGPaint(CSSPropertyFill, &amp;RenderStyle::fillPaintType, &amp;RenderStyle::fillPaintColor, &amp;RenderStyle::setFillPaintColor),
1675         new PropertyWrapper&lt;float&gt;(CSSPropertyFillOpacity, &amp;RenderStyle::fillOpacity, &amp;RenderStyle::setFillOpacity),
</pre>
<hr />
<pre>
1783 
1784 static bool gatherEnclosingShorthandProperties(CSSPropertyID property, AnimationPropertyWrapperBase* wrapper, HashSet&lt;CSSPropertyID&gt;&amp; propertySet)
1785 {
1786     if (!wrapper-&gt;isShorthandWrapper())
1787         return false;
1788 
1789     ShorthandPropertyWrapper* shorthandWrapper = static_cast&lt;ShorthandPropertyWrapper*&gt;(wrapper);
1790     bool contained = false;
1791     for (auto&amp; currWrapper : shorthandWrapper-&gt;propertyWrappers()) {
1792         if (gatherEnclosingShorthandProperties(property, currWrapper, propertySet) || currWrapper-&gt;property() == property)
1793             contained = true;
1794     }
1795 
1796     if (contained)
1797         propertySet.add(wrapper-&gt;property());
1798 
1799     return contained;
1800 }
1801 
1802 // Returns true if we need to start animation timers
<span class="line-modified">1803 void CSSPropertyAnimation::blendProperties(const CSSPropertyBlendingClient* anim, CSSPropertyID prop, RenderStyle* dst, const RenderStyle* a, const RenderStyle* b, double progress)</span>
1804 {
1805     ASSERT(prop != CSSPropertyInvalid);
1806 
1807     AnimationPropertyWrapperBase* wrapper = CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
1808     if (wrapper) {
1809         wrapper-&gt;blend(anim, dst, a, b, progress);
1810 #if !LOG_DISABLED
1811         wrapper-&gt;logBlend(a, b, dst, progress);
1812 #endif

1813     }

1814 }
1815 
1816 bool CSSPropertyAnimation::isPropertyAnimatable(CSSPropertyID prop)
1817 {
1818     return CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
1819 }
1820 
1821 bool CSSPropertyAnimation::animationOfPropertyIsAccelerated(CSSPropertyID prop)
1822 {
1823     AnimationPropertyWrapperBase* wrapper = CSSPropertyAnimationWrapperMap::singleton().wrapperForProperty(prop);
1824     return wrapper ? wrapper-&gt;animationIsAccelerated() : false;
1825 }
1826 
1827 // Note: this is inefficient. It&#39;s only called from pauseTransitionAtTime().
1828 HashSet&lt;CSSPropertyID&gt; CSSPropertyAnimation::animatableShorthandsAffectingProperty(CSSPropertyID property)
1829 {
1830     CSSPropertyAnimationWrapperMap&amp; map = CSSPropertyAnimationWrapperMap::singleton();
1831 
1832     HashSet&lt;CSSPropertyID&gt; foundProperties;
1833     for (unsigned i = 0; i &lt; map.size(); ++i)
</pre>
</td>
</tr>
</table>
<center><a href="CSSAnimationController.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSPropertyAnimation.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
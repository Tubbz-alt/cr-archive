<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBigInt.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSBigInt.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSBoundFunction.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSBigInt.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,34 ***</span>
  #pragma once
  
  #include &quot;CPU.h&quot;
  #include &quot;ExceptionHelpers.h&quot;
  #include &quot;JSObject.h&quot;
<span class="line-modified">! #include &lt;wtf/CagedPtr.h&gt;</span>
  #include &lt;wtf/text/StringBuilder.h&gt;
  #include &lt;wtf/text/StringView.h&gt;
  #include &lt;wtf/text/WTFString.h&gt;
  
  namespace JSC {
  
  class JSBigInt final : public JSCell {
      using Base = JSCell;
<span class="line-modified">!     static const unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal | OverridesToThis;</span>
      friend class CachedBigInt;
  
<span class="line-modified">! public:</span>
  
<span class="line-modified">!     JSBigInt(VM&amp;, Structure*, unsigned length);</span>
  
      enum class InitializationType { None, WithZero };
      void initialize(InitializationType);
  
      static size_t estimatedSize(JSCell*, VM&amp;);
  
      static Structure* createStructure(VM&amp;, JSGlobalObject*, JSValue prototype);
      static JSBigInt* createZero(VM&amp;);
<span class="line-modified">!     static JSBigInt* tryCreateWithLength(ExecState*, unsigned length);</span>
      static JSBigInt* createWithLengthUnchecked(VM&amp;, unsigned length);
  
      static JSBigInt* createFrom(VM&amp;, int32_t value);
      static JSBigInt* createFrom(VM&amp;, uint32_t value);
      static JSBigInt* createFrom(VM&amp;, int64_t value);
<span class="line-new-header">--- 27,42 ---</span>
  #pragma once
  
  #include &quot;CPU.h&quot;
  #include &quot;ExceptionHelpers.h&quot;
  #include &quot;JSObject.h&quot;
<span class="line-modified">! #include &lt;wtf/CagedUniquePtr.h&gt;</span>
  #include &lt;wtf/text/StringBuilder.h&gt;
  #include &lt;wtf/text/StringView.h&gt;
  #include &lt;wtf/text/WTFString.h&gt;
  
  namespace JSC {
  
  class JSBigInt final : public JSCell {
<span class="line-added">+ public:</span>
      using Base = JSCell;
<span class="line-modified">!     using Digit = UCPURegister;</span>
<span class="line-added">+ </span>
<span class="line-added">+     static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal | OverridesToThis;</span>
      friend class CachedBigInt;
  
<span class="line-modified">!     static constexpr bool needsDestruction = true;</span>
<span class="line-added">+     static void destroy(JSCell*);</span>
  
<span class="line-modified">!     template&lt;typename CellType, SubspaceAccess&gt;</span>
<span class="line-added">+     static IsoSubspace* subspaceFor(VM&amp; vm)</span>
<span class="line-added">+     {</span>
<span class="line-added">+         return &amp;vm.bigIntSpace;</span>
<span class="line-added">+     }</span>
  
      enum class InitializationType { None, WithZero };
      void initialize(InitializationType);
  
      static size_t estimatedSize(JSCell*, VM&amp;);
  
      static Structure* createStructure(VM&amp;, JSGlobalObject*, JSValue prototype);
      static JSBigInt* createZero(VM&amp;);
<span class="line-modified">!     static JSBigInt* tryCreateWithLength(JSGlobalObject*, unsigned length);</span>
      static JSBigInt* createWithLengthUnchecked(VM&amp;, unsigned length);
  
      static JSBigInt* createFrom(VM&amp;, int32_t value);
      static JSBigInt* createFrom(VM&amp;, uint32_t value);
      static JSBigInt* createFrom(VM&amp;, int64_t value);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 65,11 ***</span>
          return OBJECT_OFFSETOF(JSBigInt, m_length);
      }
  
      DECLARE_EXPORT_INFO;
  
<span class="line-modified">!     JSValue toPrimitive(ExecState*, PreferredPrimitiveType) const;</span>
  
      void setSign(bool sign) { m_sign = sign; }
      bool sign() const { return m_sign; }
  
      unsigned length() const { return m_length; }
<span class="line-new-header">--- 73,11 ---</span>
          return OBJECT_OFFSETOF(JSBigInt, m_length);
      }
  
      DECLARE_EXPORT_INFO;
  
<span class="line-modified">!     JSValue toPrimitive(JSGlobalObject*, PreferredPrimitiveType) const;</span>
  
      void setSign(bool sign) { m_sign = sign; }
      bool sign() const { return m_sign; }
  
      unsigned length() const { return m_length; }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 80,18 ***</span>
      };
  
      enum class ParseIntMode { DisallowEmptyString, AllowEmptyString };
      enum class ParseIntSign { Unsigned, Signed };
  
<span class="line-modified">!     static JSBigInt* parseInt(ExecState*, VM&amp;, StringView, uint8_t radix, ErrorParseMode = ErrorParseMode::ThrowExceptions, ParseIntSign = ParseIntSign::Unsigned);</span>
<span class="line-modified">!     static JSBigInt* parseInt(ExecState*, StringView, ErrorParseMode = ErrorParseMode::ThrowExceptions);</span>
<span class="line-modified">!     static JSBigInt* stringToBigInt(ExecState*, StringView);</span>
  
      static String tryGetString(VM&amp;, JSBigInt*, unsigned radix);
  
      Optional&lt;uint8_t&gt; singleDigitValueForString();
<span class="line-modified">!     String toString(ExecState*, unsigned radix);</span>
  
      enum class ComparisonMode {
          LessThan,
          LessThanOrEqual
      };
<span class="line-new-header">--- 88,18 ---</span>
      };
  
      enum class ParseIntMode { DisallowEmptyString, AllowEmptyString };
      enum class ParseIntSign { Unsigned, Signed };
  
<span class="line-modified">!     static JSBigInt* parseInt(JSGlobalObject*, VM&amp;, StringView, uint8_t radix, ErrorParseMode = ErrorParseMode::ThrowExceptions, ParseIntSign = ParseIntSign::Unsigned);</span>
<span class="line-modified">!     static JSBigInt* parseInt(JSGlobalObject*, StringView, ErrorParseMode = ErrorParseMode::ThrowExceptions);</span>
<span class="line-modified">!     static JSBigInt* stringToBigInt(JSGlobalObject*, StringView);</span>
  
      static String tryGetString(VM&amp;, JSBigInt*, unsigned radix);
  
      Optional&lt;uint8_t&gt; singleDigitValueForString();
<span class="line-modified">!     String toString(JSGlobalObject*, unsigned radix);</span>
  
      enum class ComparisonMode {
          LessThan,
          LessThanOrEqual
      };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,39 ***</span>
  
      JS_EXPORT_PRIVATE static bool equals(JSBigInt*, JSBigInt*);
      bool equalsToNumber(JSValue);
      static ComparisonResult compare(JSBigInt* x, JSBigInt* y);
  
<span class="line-modified">!     bool getPrimitiveNumber(ExecState*, double&amp; number, JSValue&amp; result) const;</span>
<span class="line-modified">!     double toNumber(ExecState*) const;</span>
  
<span class="line-modified">!     JSObject* toObject(ExecState*, JSGlobalObject*) const;</span>
      inline bool toBoolean() const { return !isZero(); }
  
<span class="line-modified">!     static JSBigInt* exponentiate(ExecState*, JSBigInt* base, JSBigInt* exponent);</span>
  
<span class="line-modified">!     static JSBigInt* multiply(ExecState*, JSBigInt* x, JSBigInt* y);</span>
  
      ComparisonResult static compareToDouble(JSBigInt* x, double y);
  
<span class="line-modified">!     static JSBigInt* add(ExecState*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">!     static JSBigInt* sub(ExecState*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">!     static JSBigInt* divide(ExecState*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">!     static JSBigInt* remainder(ExecState*, JSBigInt* x, JSBigInt* y);</span>
      static JSBigInt* unaryMinus(VM&amp;, JSBigInt* x);
  
<span class="line-modified">!     static JSBigInt* bitwiseAnd(ExecState*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">!     static JSBigInt* bitwiseOr(ExecState*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">!     static JSBigInt* bitwiseXor(ExecState*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">!     static JSBigInt* bitwiseNot(ExecState*, JSBigInt* x);</span>
  
<span class="line-modified">!     static JSBigInt* leftShift(ExecState*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">!     static JSBigInt* signedRightShift(ExecState*, JSBigInt* x, JSBigInt* y);</span>
  
  private:
  
<span class="line-removed">-     using Digit = UCPURegister;</span>
      static constexpr unsigned bitsPerByte = 8;
      static constexpr unsigned digitBits = sizeof(Digit) * bitsPerByte;
      static constexpr unsigned halfDigitBits = digitBits / 2;
      static constexpr Digit halfDigitMask = (1ull &lt;&lt; halfDigitBits) - 1;
      static constexpr int maxInt = 0x7FFFFFFF;
<span class="line-new-header">--- 113,41 ---</span>
  
      JS_EXPORT_PRIVATE static bool equals(JSBigInt*, JSBigInt*);
      bool equalsToNumber(JSValue);
      static ComparisonResult compare(JSBigInt* x, JSBigInt* y);
  
<span class="line-modified">!     bool getPrimitiveNumber(JSGlobalObject*, double&amp; number, JSValue&amp; result) const;</span>
<span class="line-modified">!     double toNumber(JSGlobalObject*) const;</span>
  
<span class="line-modified">!     JSObject* toObject(JSGlobalObject*) const;</span>
      inline bool toBoolean() const { return !isZero(); }
  
<span class="line-modified">!     static JSBigInt* exponentiate(JSGlobalObject*, JSBigInt* base, JSBigInt* exponent);</span>
  
<span class="line-modified">!     static JSBigInt* multiply(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
  
      ComparisonResult static compareToDouble(JSBigInt* x, double y);
  
<span class="line-modified">!     static JSBigInt* inc(JSGlobalObject*, JSBigInt* x);</span>
<span class="line-modified">!     static JSBigInt* dec(JSGlobalObject*, JSBigInt* x);</span>
<span class="line-modified">!     static JSBigInt* add(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">!     static JSBigInt* sub(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-added">+     static JSBigInt* divide(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-added">+     static JSBigInt* remainder(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
      static JSBigInt* unaryMinus(VM&amp;, JSBigInt* x);
  
<span class="line-modified">!     static JSBigInt* bitwiseAnd(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">!     static JSBigInt* bitwiseOr(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">!     static JSBigInt* bitwiseXor(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">!     static JSBigInt* bitwiseNot(JSGlobalObject*, JSBigInt* x);</span>
  
<span class="line-modified">!     static JSBigInt* leftShift(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">!     static JSBigInt* signedRightShift(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
  
  private:
<span class="line-added">+     JSBigInt(VM&amp;, Structure*, Digit*, unsigned length);</span>
  
      static constexpr unsigned bitsPerByte = 8;
      static constexpr unsigned digitBits = sizeof(Digit) * bitsPerByte;
      static constexpr unsigned halfDigitBits = digitBits / 2;
      static constexpr Digit halfDigitMask = (1ull &lt;&lt; halfDigitBits) - 1;
      static constexpr int maxInt = 0x7FFFFFFF;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 153,18 ***</span>
  
      static ComparisonResult absoluteCompare(JSBigInt* x, JSBigInt* y);
      static void absoluteDivWithDigitDivisor(VM&amp;, JSBigInt* x, Digit divisor, JSBigInt** quotient, Digit&amp; remainder);
      static void internalMultiplyAdd(JSBigInt* source, Digit factor, Digit summand, unsigned, JSBigInt* result);
      static void multiplyAccumulate(JSBigInt* multiplicand, Digit multiplier, JSBigInt* accumulator, unsigned accumulatorIndex);
<span class="line-modified">!     static void absoluteDivWithBigIntDivisor(ExecState*, JSBigInt* dividend, JSBigInt* divisor, JSBigInt** quotient, JSBigInt** remainder);</span>
  
      enum class LeftShiftMode {
          SameSizeResult,
          AlwaysAddOneDigit
      };
  
<span class="line-modified">!     static JSBigInt* absoluteLeftShiftAlwaysCopy(ExecState*, JSBigInt* x, unsigned shift, LeftShiftMode);</span>
      static bool productGreaterThan(Digit factor1, Digit factor2, Digit high, Digit low);
  
      Digit absoluteInplaceAdd(JSBigInt* summand, unsigned startIndex);
      Digit absoluteInplaceSub(JSBigInt* subtrahend, unsigned startIndex);
      void inplaceRightShift(unsigned shift);
<span class="line-new-header">--- 163,18 ---</span>
  
      static ComparisonResult absoluteCompare(JSBigInt* x, JSBigInt* y);
      static void absoluteDivWithDigitDivisor(VM&amp;, JSBigInt* x, Digit divisor, JSBigInt** quotient, Digit&amp; remainder);
      static void internalMultiplyAdd(JSBigInt* source, Digit factor, Digit summand, unsigned, JSBigInt* result);
      static void multiplyAccumulate(JSBigInt* multiplicand, Digit multiplier, JSBigInt* accumulator, unsigned accumulatorIndex);
<span class="line-modified">!     static void absoluteDivWithBigIntDivisor(JSGlobalObject*, JSBigInt* dividend, JSBigInt* divisor, JSBigInt** quotient, JSBigInt** remainder);</span>
  
      enum class LeftShiftMode {
          SameSizeResult,
          AlwaysAddOneDigit
      };
  
<span class="line-modified">!     static JSBigInt* absoluteLeftShiftAlwaysCopy(JSGlobalObject*, JSBigInt* x, unsigned shift, LeftShiftMode);</span>
      static bool productGreaterThan(Digit factor1, Digit factor2, Digit high, Digit low);
  
      Digit absoluteInplaceAdd(JSBigInt* summand, unsigned startIndex);
      Digit absoluteInplaceSub(JSBigInt* subtrahend, unsigned startIndex);
      void inplaceRightShift(unsigned shift);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 190,67 ***</span>
      enum class SignOption {
          Signed,
          Unsigned
      };
  
<span class="line-modified">!     static JSBigInt* absoluteAddOne(ExecState*, JSBigInt* x, SignOption);</span>
<span class="line-modified">!     static JSBigInt* absoluteSubOne(ExecState*, JSBigInt* x, unsigned resultLength);</span>
  
      // Digit arithmetic helpers.
      static Digit digitAdd(Digit a, Digit b, Digit&amp; carry);
      static Digit digitSub(Digit a, Digit b, Digit&amp; borrow);
      static Digit digitMul(Digit a, Digit b, Digit&amp; high);
      static Digit digitDiv(Digit high, Digit low, Digit divisor, Digit&amp; remainder);
      static Digit digitPow(Digit base, Digit exponent);
  
<span class="line-modified">!     static String toStringBasePowerOfTwo(VM&amp;, ExecState*, JSBigInt*, unsigned radix);</span>
<span class="line-modified">!     static String toStringGeneric(VM&amp;, ExecState*, JSBigInt*, unsigned radix);</span>
  
      inline bool isZero() const
      {
          ASSERT(length() || !sign());
          return length() == 0;
      }
  
      template &lt;typename CharType&gt;
<span class="line-modified">!     static JSBigInt* parseInt(ExecState*, CharType*  data, unsigned length, ErrorParseMode);</span>
  
      template &lt;typename CharType&gt;
<span class="line-modified">!     static JSBigInt* parseInt(ExecState*, VM&amp;, CharType* data, unsigned length, unsigned startIndex, unsigned radix, ErrorParseMode, ParseIntSign = ParseIntSign::Signed, ParseIntMode = ParseIntMode::AllowEmptyString);</span>
  
<span class="line-modified">!     static JSBigInt* allocateFor(ExecState*, VM&amp;, unsigned radix, unsigned charcount);</span>
  
      static JSBigInt* copy(VM&amp;, JSBigInt* x);
      JSBigInt* rightTrim(VM&amp;);
  
      void inplaceMultiplyAdd(Digit multiplier, Digit part);
<span class="line-modified">!     static JSBigInt* absoluteAdd(ExecState*, JSBigInt* x, JSBigInt* y, bool resultSign);</span>
      static JSBigInt* absoluteSub(VM&amp;, JSBigInt* x, JSBigInt* y, bool resultSign);
  
<span class="line-modified">!     static JSBigInt* leftShiftByAbsolute(ExecState*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">!     static JSBigInt* rightShiftByAbsolute(ExecState*, JSBigInt* x, JSBigInt* y);</span>
  
      static JSBigInt* rightShiftByMaximum(VM&amp;, bool sign);
  
      static Optional&lt;Digit&gt; toShiftAmount(JSBigInt* x);
  
<span class="line-removed">-     static size_t allocationSize(unsigned length);</span>
      inline static size_t offsetOfData()
      {
<span class="line-modified">!         return WTF::roundUpToMultipleOf&lt;sizeof(Digit)&gt;(sizeof(JSBigInt));</span>
      }
  
<span class="line-modified">!     inline Digit* dataStorage()</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         return bitwise_cast&lt;Digit*&gt;(reinterpret_cast&lt;char*&gt;(this) + offsetOfData());</span>
<span class="line-removed">-     }</span>
  
      Digit digit(unsigned);
      void setDigit(unsigned, Digit);
  
      const unsigned m_length;
      bool m_sign { false };
  };
  
  inline JSBigInt* asBigInt(JSValue value)
  {
      ASSERT(value.asCell()-&gt;isBigInt());
<span class="line-new-header">--- 200,64 ---</span>
      enum class SignOption {
          Signed,
          Unsigned
      };
  
<span class="line-modified">!     static JSBigInt* absoluteAddOne(JSGlobalObject*, JSBigInt* x, SignOption);</span>
<span class="line-modified">!     static JSBigInt* absoluteSubOne(JSGlobalObject*, JSBigInt* x, unsigned resultLength);</span>
  
      // Digit arithmetic helpers.
      static Digit digitAdd(Digit a, Digit b, Digit&amp; carry);
      static Digit digitSub(Digit a, Digit b, Digit&amp; borrow);
      static Digit digitMul(Digit a, Digit b, Digit&amp; high);
      static Digit digitDiv(Digit high, Digit low, Digit divisor, Digit&amp; remainder);
      static Digit digitPow(Digit base, Digit exponent);
  
<span class="line-modified">!     static String toStringBasePowerOfTwo(VM&amp;, JSGlobalObject*, JSBigInt*, unsigned radix);</span>
<span class="line-modified">!     static String toStringGeneric(VM&amp;, JSGlobalObject*, JSBigInt*, unsigned radix);</span>
  
      inline bool isZero() const
      {
          ASSERT(length() || !sign());
          return length() == 0;
      }
  
      template &lt;typename CharType&gt;
<span class="line-modified">!     static JSBigInt* parseInt(JSGlobalObject*, CharType*  data, unsigned length, ErrorParseMode);</span>
  
      template &lt;typename CharType&gt;
<span class="line-modified">!     static JSBigInt* parseInt(JSGlobalObject*, VM&amp;, CharType* data, unsigned length, unsigned startIndex, unsigned radix, ErrorParseMode, ParseIntSign = ParseIntSign::Signed, ParseIntMode = ParseIntMode::AllowEmptyString);</span>
  
<span class="line-modified">!     static JSBigInt* allocateFor(JSGlobalObject*, VM&amp;, unsigned radix, unsigned charcount);</span>
  
      static JSBigInt* copy(VM&amp;, JSBigInt* x);
      JSBigInt* rightTrim(VM&amp;);
  
      void inplaceMultiplyAdd(Digit multiplier, Digit part);
<span class="line-modified">!     static JSBigInt* absoluteAdd(JSGlobalObject*, JSBigInt* x, JSBigInt* y, bool resultSign);</span>
      static JSBigInt* absoluteSub(VM&amp;, JSBigInt* x, JSBigInt* y, bool resultSign);
  
<span class="line-modified">!     static JSBigInt* leftShiftByAbsolute(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
<span class="line-modified">!     static JSBigInt* rightShiftByAbsolute(JSGlobalObject*, JSBigInt* x, JSBigInt* y);</span>
  
      static JSBigInt* rightShiftByMaximum(VM&amp;, bool sign);
  
      static Optional&lt;Digit&gt; toShiftAmount(JSBigInt* x);
  
      inline static size_t offsetOfData()
      {
<span class="line-modified">!         return OBJECT_OFFSETOF(JSBigInt, m_data);</span>
      }
  
<span class="line-modified">!     inline Digit* dataStorage() { return m_data.get(m_length); }</span>
  
      Digit digit(unsigned);
      void setDigit(unsigned, Digit);
  
      const unsigned m_length;
      bool m_sign { false };
<span class="line-added">+     CagedUniquePtr&lt;Gigacage::Primitive, Digit&gt; m_data;</span>
  };
  
  inline JSBigInt* asBigInt(JSValue value)
  {
      ASSERT(value.asCell()-&gt;isBigInt());
</pre>
<center><a href="JSBigInt.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSBoundFunction.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/ConcurrentBuffer.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/ConcurrentBuffer.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/ConcurrentBuffer.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/ConcurrentBuffer.h
@@ -32,10 +32,12 @@
 #include <wtf/Noncopyable.h>
 #include <wtf/Vector.h>
 
 namespace WTF {
 
+DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(ConcurrentBuffer);
+
 // ConcurrentBuffer is suitable for when you plan to store immutable data and sometimes append to it.
 // It supports storing data that is not copy-constructable but bit-copyable.
 template<typename T>
 class ConcurrentBuffer final {
     WTF_MAKE_NONCOPYABLE(ConcurrentBuffer);
@@ -51,11 +53,11 @@
         if (Array* array = m_array) {
             for (size_t i = 0; i < array->size; ++i)
                 array->data[i].~T();
         }
         for (Array* array : m_allArrays)
-            fastFree(array);
+            ConcurrentBufferMalloc::free(array);
     }
 
     // Growing is not concurrent. This assumes you are holding some other lock before you do this.
     void growExact(size_t newSize)
     {
@@ -96,11 +98,11 @@
     Array* createArray(size_t size)
     {
         Checked<size_t> objectSize = sizeof(T);
         objectSize *= size;
         objectSize += static_cast<size_t>(OBJECT_OFFSETOF(Array, data));
-        Array* result = static_cast<Array*>(fastMalloc(objectSize.unsafeGet()));
+        Array* result = static_cast<Array*>(ConcurrentBufferMalloc::malloc(objectSize.unsafeGet()));
         result->size = size;
         return result;
     }
 
     Array* m_array { nullptr };

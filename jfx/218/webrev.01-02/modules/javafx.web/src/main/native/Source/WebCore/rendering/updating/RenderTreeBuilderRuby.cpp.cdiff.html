<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderRuby.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderTreeBuilderMultiColumn.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderTreeBuilderTable.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderRuby.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 46,11 ***</span>
  {
      ASSERT(!object
          || !isRuby(object-&gt;parent())
          || is&lt;RenderRubyRun&gt;(*object)
          || (object-&gt;isInline() &amp;&amp; (object-&gt;isBeforeContent() || object-&gt;isAfterContent()))
<span class="line-modified">!         || (object-&gt;isAnonymous() &amp;&amp; is&lt;RenderBlock&gt;(*object) &amp;&amp; object-&gt;style().display() == DisplayType::InlineBlock));</span>
  
      return object
          &amp;&amp; isRuby(object-&gt;parent())
          &amp;&amp; is&lt;RenderBlock&gt;(*object)
          &amp;&amp; !is&lt;RenderRubyRun&gt;(*object);
<span class="line-new-header">--- 46,13 ---</span>
  {
      ASSERT(!object
          || !isRuby(object-&gt;parent())
          || is&lt;RenderRubyRun&gt;(*object)
          || (object-&gt;isInline() &amp;&amp; (object-&gt;isBeforeContent() || object-&gt;isAfterContent()))
<span class="line-modified">!         || (object-&gt;isAnonymous() &amp;&amp; is&lt;RenderBlock&gt;(*object) &amp;&amp; object-&gt;style().display() == DisplayType::InlineBlock)</span>
<span class="line-added">+         || object-&gt;isRenderMultiColumnFlow()</span>
<span class="line-added">+         || object-&gt;isRenderMultiColumnSet());</span>
  
      return object
          &amp;&amp; isRuby(object-&gt;parent())
          &amp;&amp; is&lt;RenderBlock&gt;(*object)
          &amp;&amp; !is&lt;RenderRubyRun&gt;(*object);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 70,21 ***</span>
          &amp;&amp; !object-&gt;nextSibling()
          &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()
          &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()-&gt;style().styleType() == PseudoId::After;
  }
  
<span class="line-modified">! #ifndef ASSERT_DISABLED</span>
  static inline bool isRubyChildForNormalRemoval(const RenderObject&amp; object)
  {
      return object.isRubyRun()
      || object.isBeforeContent()
      || object.isAfterContent()
      || object.isRenderMultiColumnFlow()
      || object.isRenderMultiColumnSet()
      || isAnonymousRubyInlineBlock(&amp;object);
  }
<span class="line-modified">! #endif</span>
  
  static inline RenderBlock* rubyBeforeBlock(const RenderElement* ruby)
  {
      RenderObject* child = ruby-&gt;firstChild();
      return isRubyBeforeBlock(child) ? downcast&lt;RenderBlock&gt;(child) : nullptr;
<span class="line-new-header">--- 72,21 ---</span>
          &amp;&amp; !object-&gt;nextSibling()
          &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()
          &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()-&gt;style().styleType() == PseudoId::After;
  }
  
<span class="line-modified">! #if ASSERT_ENABLED</span>
  static inline bool isRubyChildForNormalRemoval(const RenderObject&amp; object)
  {
      return object.isRubyRun()
      || object.isBeforeContent()
      || object.isAfterContent()
      || object.isRenderMultiColumnFlow()
      || object.isRenderMultiColumnSet()
      || isAnonymousRubyInlineBlock(&amp;object);
  }
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
  
  static inline RenderBlock* rubyBeforeBlock(const RenderElement* ruby)
  {
      RenderObject* child = ruby-&gt;firstChild();
      return isRubyBeforeBlock(child) ? downcast&lt;RenderBlock&gt;(child) : nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 107,11 ***</span>
  {
      RenderObject* child = ruby-&gt;lastChild();
      if (child &amp;&amp; !is&lt;RenderRubyRun&gt;(*child))
          child = child-&gt;previousSibling();
      if (!is&lt;RenderRubyRun&gt;(child)) {
<span class="line-modified">!         ASSERT(!child || child-&gt;isBeforeContent() || child == rubyBeforeBlock(ruby));</span>
          return nullptr;
      }
      return downcast&lt;RenderRubyRun&gt;(child);
  }
  
<span class="line-new-header">--- 109,11 ---</span>
  {
      RenderObject* child = ruby-&gt;lastChild();
      if (child &amp;&amp; !is&lt;RenderRubyRun&gt;(*child))
          child = child-&gt;previousSibling();
      if (!is&lt;RenderRubyRun&gt;(child)) {
<span class="line-modified">!         ASSERT(!child || child-&gt;isBeforeContent() || child == rubyBeforeBlock(ruby) || child-&gt;isRenderMultiColumnFlow() || child-&gt;isRenderMultiColumnSet());</span>
          return nullptr;
      }
      return downcast&lt;RenderRubyRun&gt;(child);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 211,19 ***</span>
              // the old text goes into a new run that is inserted as next sibling.
              ASSERT(beforeChild-&gt;parent() == &amp;parent);
              RenderElement* ruby = parent.parent();
              ASSERT(isRuby(ruby));
              auto newRun = RenderRubyRun::staticCreateRubyRun(ruby);
              m_builder.attach(*ruby, WTFMove(newRun), parent.nextSibling());
              // Add the new ruby text and move the old one to the new run
              // Note: Doing it in this order and not using RenderRubyRun&#39;s methods,
              // in order to avoid automatic removal of the ruby run in case there is no
              // other child besides the old ruby text.
              m_builder.blockFlowBuilder().attach(parent, WTFMove(child), beforeChild);
              auto takenBeforeChild = m_builder.blockBuilder().detach(parent, *beforeChild);
  
<span class="line-modified">!             m_builder.attach(*newRun, WTFMove(takenBeforeChild));</span>
              return;
          }
          if (parent.hasRubyBase()) {
              // Insertion before a ruby base object.
              // In this case we need insert a new run before the current one and split the base.
<span class="line-new-header">--- 213,20 ---</span>
              // the old text goes into a new run that is inserted as next sibling.
              ASSERT(beforeChild-&gt;parent() == &amp;parent);
              RenderElement* ruby = parent.parent();
              ASSERT(isRuby(ruby));
              auto newRun = RenderRubyRun::staticCreateRubyRun(ruby);
<span class="line-added">+             auto&amp; run = *newRun;</span>
              m_builder.attach(*ruby, WTFMove(newRun), parent.nextSibling());
              // Add the new ruby text and move the old one to the new run
              // Note: Doing it in this order and not using RenderRubyRun&#39;s methods,
              // in order to avoid automatic removal of the ruby run in case there is no
              // other child besides the old ruby text.
              m_builder.blockFlowBuilder().attach(parent, WTFMove(child), beforeChild);
              auto takenBeforeChild = m_builder.blockBuilder().detach(parent, *beforeChild);
  
<span class="line-modified">!             m_builder.attach(run, WTFMove(takenBeforeChild));</span>
              return;
          }
          if (parent.hasRubyBase()) {
              // Insertion before a ruby base object.
              // In this case we need insert a new run before the current one and split the base.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 381,13 ***</span>
  RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::Ruby::detach(RenderRubyAsInline&amp; parent, RenderObject&amp; child)
  {
      // If the child&#39;s parent is *this (must be a ruby run or generated content or anonymous block),
      // just use the normal remove method.
      if (child.parent() == &amp;parent) {
<span class="line-removed">- #ifndef ASSERT_DISABLED</span>
          ASSERT(isRubyChildForNormalRemoval(child));
<span class="line-removed">- #endif</span>
          return m_builder.detachFromRenderElement(parent, child);
      }
      // If the child&#39;s parent is an anoymous block (must be generated :before/:after content)
      // just use the block&#39;s remove method.
      if (isAnonymousRubyInlineBlock(child.parent())) {
<span class="line-new-header">--- 384,11 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 405,13 ***</span>
  RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::Ruby::detach(RenderRubyAsBlock&amp; parent, RenderObject&amp; child)
  {
      // If the child&#39;s parent is *this (must be a ruby run or generated content or anonymous block),
      // just use the normal remove method.
      if (child.parent() == &amp;parent) {
<span class="line-removed">- #ifndef ASSERT_DISABLED</span>
          ASSERT(isRubyChildForNormalRemoval(child));
<span class="line-removed">- #endif</span>
          return m_builder.blockBuilder().detach(parent, child);
      }
      // If the child&#39;s parent is an anoymous block (must be generated :before/:after content)
      // just use the block&#39;s remove method.
      if (isAnonymousRubyInlineBlock(child.parent())) {
<span class="line-new-header">--- 406,11 ---</span>
</pre>
<center><a href="RenderTreeBuilderMultiColumn.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderTreeBuilderTable.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
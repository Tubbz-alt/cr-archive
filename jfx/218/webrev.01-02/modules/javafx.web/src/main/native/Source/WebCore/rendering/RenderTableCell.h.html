<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderTableCell.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1997 Martin Jones (mjones@kde.org)
  3  *           (C) 1997 Torben Weis (weis@kde.org)
  4  *           (C) 1998 Waldo Bastian (bastian@kde.org)
  5  *           (C) 1999 Lars Knoll (knoll@kde.org)
  6  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  7  * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2009 Apple Inc. All rights reserved.
  8  *
  9  * This library is free software; you can redistribute it and/or
 10  * modify it under the terms of the GNU Library General Public
 11  * License as published by the Free Software Foundation; either
 12  * version 2 of the License, or (at your option) any later version.
 13  *
 14  * This library is distributed in the hope that it will be useful,
 15  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 16  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 17  * Library General Public License for more details.
 18  *
 19  * You should have received a copy of the GNU Library General Public License
 20  * along with this library; see the file COPYING.LIB.  If not, write to
 21  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 22  * Boston, MA 02110-1301, USA.
 23  */
 24 
 25 #pragma once
 26 
 27 #include &quot;RenderBlockFlow.h&quot;
 28 #include &quot;RenderTableRow.h&quot;
 29 #include &quot;RenderTableSection.h&quot;
 30 
 31 namespace WebCore {
 32 
 33 // These is limited by the size of RenderTableCell::m_column bitfield.
 34 static const unsigned unsetColumnIndex = 0x1FFFFFF;
 35 static const unsigned maxColumnIndex = 0x1FFFFFE; // 33554430
 36 
 37 enum IncludeBorderColorOrNot { DoNotIncludeBorderColor, IncludeBorderColor };
 38 
 39 class RenderTableCell final : public RenderBlockFlow {
 40     WTF_MAKE_ISO_ALLOCATED(RenderTableCell);
 41 public:
 42     RenderTableCell(Element&amp;, RenderStyle&amp;&amp;);
 43     RenderTableCell(Document&amp;, RenderStyle&amp;&amp;);
 44 
 45     unsigned colSpan() const;
 46     unsigned rowSpan() const;
 47 
 48     // Called from HTMLTableCellElement.
 49     void colSpanOrRowSpanChanged();
 50 
 51     void setCol(unsigned column);
 52     unsigned col() const;
 53 
 54     RenderTableCell* nextCell() const;
 55     RenderTableCell* previousCell() const;
 56 
 57     RenderTableRow* row() const { return downcast&lt;RenderTableRow&gt;(parent()); }
 58     RenderTableSection* section() const;
 59     RenderTable* table() const;
 60     unsigned rowIndex() const;
 61     Length styleOrColLogicalWidth() const;
 62     LayoutUnit logicalHeightForRowSizing() const;
 63 
 64     void setCellLogicalWidth(LayoutUnit constrainedLogicalWidth);
 65 
 66     LayoutUnit borderLeft() const override;
 67     LayoutUnit borderRight() const override;
 68     LayoutUnit borderTop() const override;
 69     LayoutUnit borderBottom() const override;
 70     LayoutUnit borderStart() const override;
 71     LayoutUnit borderEnd() const override;
 72     LayoutUnit borderBefore() const override;
 73     LayoutUnit borderAfter() const override;
 74 
 75     void collectBorderValues(RenderTable::CollapsedBorderValues&amp;) const;
 76     static void sortBorderValues(RenderTable::CollapsedBorderValues&amp;);
 77 
 78     void layout() override;
 79 
 80     void paint(PaintInfo&amp;, const LayoutPoint&amp;) override;
 81 
 82     void paintCollapsedBorders(PaintInfo&amp;, const LayoutPoint&amp;);
 83     void paintBackgroundsBehindCell(PaintInfo&amp;, const LayoutPoint&amp;, RenderElement* backgroundObject);
 84 
 85     LayoutUnit cellBaselinePosition() const;
 86     bool isBaselineAligned() const;
 87 
 88     void computeIntrinsicPadding(LayoutUnit rowHeight);
 89     void clearIntrinsicPadding() { setIntrinsicPadding(0, 0); }
 90 
 91     LayoutUnit intrinsicPaddingBefore() const { return m_intrinsicPaddingBefore; }
 92     LayoutUnit intrinsicPaddingAfter() const { return m_intrinsicPaddingAfter; }
 93 
 94     LayoutUnit paddingTop() const override;
 95     LayoutUnit paddingBottom() const override;
 96     LayoutUnit paddingLeft() const override;
 97     LayoutUnit paddingRight() const override;
 98 
 99     // FIXME: For now we just assume the cell has the same block flow direction as the table. It&#39;s likely we&#39;ll
100     // create an extra anonymous RenderBlock to handle mixing directionality anyway, in which case we can lock
101     // the block flow directionality of the cells to the table&#39;s directionality.
102     LayoutUnit paddingBefore() const override;
103     LayoutUnit paddingAfter() const override;
104 
105     void setOverrideContentLogicalHeightFromRowHeight(LayoutUnit);
106 
107     void scrollbarsChanged(bool horizontalScrollbarChanged, bool verticalScrollbarChanged) override;
108 
109     bool cellWidthChanged() const { return m_cellWidthChanged; }
110     void setCellWidthChanged(bool b = true) { m_cellWidthChanged = b; }
111 
112     static RenderPtr&lt;RenderTableCell&gt; createAnonymousWithParentRenderer(const RenderTableRow&amp;);
113     RenderPtr&lt;RenderBox&gt; createAnonymousBoxWithSameTypeAs(const RenderBox&amp;) const override;
114 
115     // This function is used to unify which table part&#39;s style we use for computing direction and
116     // writing mode. Writing modes are not allowed on row group and row but direction is.
117     // This means we can safely use the same style in all cases to simplify our code.
118     // FIXME: Eventually this function should replaced by style() once we support direction
119     // on all table parts and writing-mode on cells.
120     const RenderStyle&amp; styleForCellFlow() const { return row()-&gt;style(); }
121 
122     const BorderValue&amp; borderAdjoiningTableStart() const;
123     const BorderValue&amp; borderAdjoiningTableEnd() const;
124     const BorderValue&amp; borderAdjoiningCellBefore(const RenderTableCell&amp;);
125     const BorderValue&amp; borderAdjoiningCellAfter(const RenderTableCell&amp;);
126 
127     using RenderBlockFlow::nodeAtPoint;
128 #if ASSERT_ENABLED
129     bool isFirstOrLastCellInRow() const { return !table()-&gt;cellAfter(this) || !table()-&gt;cellBefore(this); }
130 #endif
131 
132     LayoutRect clippedOverflowRectForRepaint(const RenderLayerModelObject* repaintContainer) const override;
133 
134     void invalidateHasEmptyCollapsedBorders();
135     void setHasEmptyCollapsedBorder(CollapsedBorderSide, bool empty) const;
136 
137 protected:
138     void styleDidChange(StyleDifference, const RenderStyle* oldStyle) override;
139     void computePreferredLogicalWidths() override;
140 
141 private:
142     static RenderPtr&lt;RenderTableCell&gt; createTableCellWithStyle(Document&amp;, const RenderStyle&amp;);
143 
144     const char* renderName() const override { return (isAnonymous() || isPseudoElement()) ? &quot;RenderTableCell (anonymous)&quot; : &quot;RenderTableCell&quot;; }
145 
146     bool isTableCell() const override { return true; }
147 
148     void willBeRemovedFromTree() override;
149 
150     void updateLogicalWidth() override;
151 
152     void paintBoxDecorations(PaintInfo&amp;, const LayoutPoint&amp;) override;
153     void paintMask(PaintInfo&amp;, const LayoutPoint&amp;) override;
154 
155     bool boxShadowShouldBeAppliedToBackground(const LayoutPoint&amp; paintOffset, BackgroundBleedAvoidance, InlineFlowBox*) const override;
156 
157     LayoutSize offsetFromContainer(RenderElement&amp;, const LayoutPoint&amp;, bool* offsetDependsOnPoint = 0) const override;
158     Optional&lt;LayoutRect&gt; computeVisibleRectInContainer(const LayoutRect&amp;, const RenderLayerModelObject* container, VisibleRectContext) const override;
159 
160     LayoutUnit borderHalfLeft(bool outer) const;
161     LayoutUnit borderHalfRight(bool outer) const;
162     LayoutUnit borderHalfTop(bool outer) const;
163     LayoutUnit borderHalfBottom(bool outer) const;
164 
165     LayoutUnit borderHalfStart(bool outer) const;
166     LayoutUnit borderHalfEnd(bool outer) const;
167     LayoutUnit borderHalfBefore(bool outer) const;
168     LayoutUnit borderHalfAfter(bool outer) const;
169 
170     void setIntrinsicPaddingBefore(LayoutUnit p) { m_intrinsicPaddingBefore = p; }
171     void setIntrinsicPaddingAfter(LayoutUnit p) { m_intrinsicPaddingAfter = p; }
172     void setIntrinsicPadding(LayoutUnit before, LayoutUnit after) { setIntrinsicPaddingBefore(before); setIntrinsicPaddingAfter(after); }
173 
174     bool hasStartBorderAdjoiningTable() const;
175     bool hasEndBorderAdjoiningTable() const;
176 
177     CollapsedBorderValue collapsedStartBorder(IncludeBorderColorOrNot = IncludeBorderColor) const;
178     CollapsedBorderValue collapsedEndBorder(IncludeBorderColorOrNot = IncludeBorderColor) const;
179     CollapsedBorderValue collapsedBeforeBorder(IncludeBorderColorOrNot = IncludeBorderColor) const;
180     CollapsedBorderValue collapsedAfterBorder(IncludeBorderColorOrNot = IncludeBorderColor) const;
181 
182     CollapsedBorderValue cachedCollapsedLeftBorder(const RenderStyle&amp;) const;
183     CollapsedBorderValue cachedCollapsedRightBorder(const RenderStyle&amp;) const;
184     CollapsedBorderValue cachedCollapsedTopBorder(const RenderStyle&amp;) const;
185     CollapsedBorderValue cachedCollapsedBottomBorder(const RenderStyle&amp;) const;
186 
187     CollapsedBorderValue computeCollapsedStartBorder(IncludeBorderColorOrNot = IncludeBorderColor) const;
188     CollapsedBorderValue computeCollapsedEndBorder(IncludeBorderColorOrNot = IncludeBorderColor) const;
189     CollapsedBorderValue computeCollapsedBeforeBorder(IncludeBorderColorOrNot = IncludeBorderColor) const;
190     CollapsedBorderValue computeCollapsedAfterBorder(IncludeBorderColorOrNot = IncludeBorderColor) const;
191 
192     Length logicalWidthFromColumns(RenderTableCol* firstColForThisCell, Length widthFromStyle) const;
193 
194     void updateColAndRowSpanFlags();
195 
196     unsigned parseRowSpanFromDOM() const;
197     unsigned parseColSpanFromDOM() const;
198 
199     void nextSibling() const = delete;
200     void previousSibling() const = delete;
201 
202     bool hasLineIfEmpty() const final;
203 
204     // Note MSVC will only pack members if they have identical types, hence we use unsigned instead of bool here.
205     unsigned m_column : 25;
206     unsigned m_cellWidthChanged : 1;
207     unsigned m_hasColSpan: 1;
208     unsigned m_hasRowSpan: 1;
209     mutable unsigned m_hasEmptyCollapsedBeforeBorder: 1;
210     mutable unsigned m_hasEmptyCollapsedAfterBorder: 1;
211     mutable unsigned m_hasEmptyCollapsedStartBorder: 1;
212     mutable unsigned m_hasEmptyCollapsedEndBorder: 1;
213     LayoutUnit m_intrinsicPaddingBefore { 0 };
214     LayoutUnit m_intrinsicPaddingAfter { 0 };
215 };
216 
217 inline RenderTableCell* RenderTableCell::nextCell() const
218 {
219     return downcast&lt;RenderTableCell&gt;(RenderBlockFlow::nextSibling());
220 }
221 
222 inline RenderTableCell* RenderTableCell::previousCell() const
223 {
224     return downcast&lt;RenderTableCell&gt;(RenderBlockFlow::previousSibling());
225 }
226 
227 inline unsigned RenderTableCell::colSpan() const
228 {
229     if (!m_hasColSpan)
230         return 1;
231     return parseColSpanFromDOM();
232 }
233 
234 inline unsigned RenderTableCell::rowSpan() const
235 {
236     if (!m_hasRowSpan)
237         return 1;
238     return parseRowSpanFromDOM();
239 }
240 
241 inline void RenderTableCell::setCol(unsigned column)
242 {
243     if (UNLIKELY(column &gt; maxColumnIndex))
244         column = maxColumnIndex;
245     m_column = column;
246 }
247 
248 inline unsigned RenderTableCell::col() const
249 {
250     ASSERT(m_column != unsetColumnIndex);
251     return m_column;
252 }
253 
254 inline RenderTableSection* RenderTableCell::section() const
255 {
256     RenderTableRow* row = this-&gt;row();
257     if (!row)
258         return nullptr;
259     return downcast&lt;RenderTableSection&gt;(row-&gt;parent());
260 }
261 
262 inline RenderTable* RenderTableCell::table() const
263 {
264     RenderTableSection* section = this-&gt;section();
265     if (!section)
266         return nullptr;
267     return downcast&lt;RenderTable&gt;(section-&gt;parent());
268 }
269 
270 inline unsigned RenderTableCell::rowIndex() const
271 {
272     // This function shouldn&#39;t be called on a detached cell.
273     ASSERT(row());
274     return row()-&gt;rowIndex();
275 }
276 
277 inline Length RenderTableCell::styleOrColLogicalWidth() const
278 {
279     Length styleWidth = style().logicalWidth();
280     if (!styleWidth.isAuto())
281         return styleWidth;
282     if (RenderTableCol* firstColumn = table()-&gt;colElement(col()))
283         return logicalWidthFromColumns(firstColumn, styleWidth);
284     return styleWidth;
285 }
286 
287 inline LayoutUnit RenderTableCell::logicalHeightForRowSizing() const
288 {
289     // FIXME: This function does too much work, and is very hot during table layout!
290     LayoutUnit adjustedLogicalHeight = logicalHeight() - (intrinsicPaddingBefore() + intrinsicPaddingAfter());
291     if (!style().logicalHeight().isSpecified())
292         return adjustedLogicalHeight;
293     LayoutUnit styleLogicalHeight = valueForLength(style().logicalHeight(), 0);
294     // In strict mode, box-sizing: content-box do the right thing and actually add in the border and padding.
295     // Call computedCSSPadding* directly to avoid including implicitPadding.
296     if (!document().inQuirksMode() &amp;&amp; style().boxSizing() != BoxSizing::BorderBox)
297         styleLogicalHeight += computedCSSPaddingBefore() + computedCSSPaddingAfter() + borderBefore() + borderAfter();
298     return std::max(styleLogicalHeight, adjustedLogicalHeight);
299 }
300 
301 inline bool RenderTableCell::isBaselineAligned() const
302 {
303     VerticalAlign va = style().verticalAlign();
304     return va == VerticalAlign::Baseline || va == VerticalAlign::TextBottom || va == VerticalAlign::TextTop || va == VerticalAlign::Super || va == VerticalAlign::Sub || va == VerticalAlign::Length;
305 }
306 
307 inline const BorderValue&amp; RenderTableCell::borderAdjoiningTableStart() const
308 {
309     ASSERT(isFirstOrLastCellInRow());
310     if (isDirectionSame(section(), table()))
311         return style().borderStart();
312 
313     return style().borderEnd();
314 }
315 
316 inline const BorderValue&amp; RenderTableCell::borderAdjoiningTableEnd() const
317 {
318     ASSERT(isFirstOrLastCellInRow());
319     if (isDirectionSame(section(), table()))
320         return style().borderEnd();
321 
322     return style().borderStart();
323 }
324 
325 inline const BorderValue&amp; RenderTableCell::borderAdjoiningCellBefore(const RenderTableCell&amp; cell)
326 {
327     ASSERT_UNUSED(cell, table()-&gt;cellAfter(&amp;cell) == this);
328     // FIXME: https://webkit.org/b/79272 - Add support for mixed directionality at the cell level.
329     return style().borderStart();
330 }
331 
332 inline const BorderValue&amp; RenderTableCell::borderAdjoiningCellAfter(const RenderTableCell&amp; cell)
333 {
334     ASSERT_UNUSED(cell, table()-&gt;cellBefore(&amp;cell) == this);
335     // FIXME: https://webkit.org/b/79272 - Add support for mixed directionality at the cell level.
336     return style().borderEnd();
337 }
338 
339 inline RenderTableCell* RenderTableRow::firstCell() const
340 {
341     return downcast&lt;RenderTableCell&gt;(RenderBox::firstChild());
342 }
343 
344 inline RenderTableCell* RenderTableRow::lastCell() const
345 {
346     return downcast&lt;RenderTableCell&gt;(RenderBox::lastChild());
347 }
348 
349 inline void RenderTableCell::setHasEmptyCollapsedBorder(CollapsedBorderSide side, bool empty) const
350 {
351     switch (side) {
352     case CBSAfter: {
353         m_hasEmptyCollapsedAfterBorder = empty;
354         break;
355     }
356     case CBSBefore: {
357         m_hasEmptyCollapsedBeforeBorder = empty;
358         break;
359     }
360     case CBSStart: {
361         m_hasEmptyCollapsedStartBorder = empty;
362         break;
363     }
364     case CBSEnd: {
365         m_hasEmptyCollapsedEndBorder = empty;
366         break;
367     }
368     }
369     if (empty)
370         table()-&gt;collapsedEmptyBorderIsPresent();
371 }
372 
373 inline void RenderTableCell::invalidateHasEmptyCollapsedBorders()
374 {
375     m_hasEmptyCollapsedBeforeBorder = false;
376     m_hasEmptyCollapsedAfterBorder = false;
377     m_hasEmptyCollapsedStartBorder = false;
378     m_hasEmptyCollapsedEndBorder = false;
379 }
380 
381 inline RenderPtr&lt;RenderBox&gt; RenderTableCell::createAnonymousBoxWithSameTypeAs(const RenderBox&amp; renderer) const
382 {
383     return RenderTableCell::createTableCellWithStyle(renderer.document(), renderer.style());
384 }
385 
386 } // namespace WebCore
387 
388 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderTableCell, isTableCell())
    </pre>
  </body>
</html>
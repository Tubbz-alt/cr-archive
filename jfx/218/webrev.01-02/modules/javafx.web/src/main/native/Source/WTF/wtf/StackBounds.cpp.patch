diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/StackBounds.cpp b/modules/javafx.web/src/main/native/Source/WTF/wtf/StackBounds.cpp
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/StackBounds.cpp
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/StackBounds.cpp
@@ -1,7 +1,7 @@
 /*
- *  Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009 Apple Inc. All rights reserved.
+ *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
  *  Copyright (C) 2007 Eric Seidel <eric@webkit.org>
  *
  *  This library is free software; you can redistribute it and/or
  *  modify it under the terms of the GNU Lesser General Public
  *  License as published by the Free Software Foundation; either
@@ -46,69 +46,24 @@
 namespace WTF {
 
 #if PLATFORM(JAVA)
 // 16K is a safe value to guard java stack red zone
 #define JAVA_RED_ZONE 0x4000
-#if OS(WINDOWS)
-// This is safe for the default stack sizes in all supported Windows
-// configurations, but is not safe for stack sizes lower than the default.
-#if CPU(X86_64)
-static const ptrdiff_t estimatedStackSize = 1024 * 1024;
-#else
-// estimatedStackSize needs to be a little greater than 256KB to keep
-// Interpreter::StackPolicy::StackPolicy happy and less than 320KB
-// to play safe against the default stack size on 32 bit Windows.
-static const ptrdiff_t estimatedStackSize = 272 * 1024;
-#endif
-#endif
-#endif
-
-#if CPU(X86) || CPU(X86_64) || CPU(ARM) || CPU(ARM64) || CPU(MIPS)
-ALWAYS_INLINE StackBounds::StackDirection StackBounds::stackDirection()
-{
-    return StackDirection::Downward;
-}
-#else
-static NEVER_INLINE NOT_TAIL_CALLED StackBounds::StackDirection testStackDirection2(volatile const uint8_t* pointer)
-{
-    volatile uint8_t* stackValue = bitwise_cast<uint8_t*>(currentStackPointer());
-    return (pointer < stackValue) ? StackBounds::StackDirection::Upward : StackBounds::StackDirection::Downward;
-}
-
-static NEVER_INLINE NOT_TAIL_CALLED StackBounds::StackDirection testStackDirection()
-{
-    NO_TAIL_CALLS();
-    volatile uint8_t* stackValue = bitwise_cast<uint8_t*>(currentStackPointer());
-    return testStackDirection2(stackValue);
-}
-
-NEVER_INLINE StackBounds::StackDirection StackBounds::stackDirection()
-{
-    static StackBounds::StackDirection result = StackBounds::StackDirection::Downward;
-    static std::once_flag onceKey;
-    std::call_once(onceKey, [] {
-        NO_TAIL_CALLS();
-        result = testStackDirection();
-    });
-    return result;
-}
 #endif
 
 #if OS(DARWIN)
 
 StackBounds StackBounds::newThreadStackBounds(PlatformThreadHandle thread)
 {
-    ASSERT(stackDirection() == StackDirection::Downward);
     void* origin = pthread_get_stackaddr_np(thread);
     rlim_t size = pthread_get_stacksize_np(thread);
     void* bound = static_cast<char*>(origin) - size;
     return StackBounds { origin, bound };
 }
 
 StackBounds StackBounds::currentThreadStackBoundsInternal()
 {
-    ASSERT(stackDirection() == StackDirection::Downward);
     if (pthread_main_np()) {
         // FIXME: <rdar://problem/13741204>
         // pthread_get_size lies to us when we're the main thread, use get_rlimit instead
         void* origin = pthread_get_stackaddr_np(pthread_self());
         rlimit limit;
@@ -130,15 +85,11 @@
 StackBounds StackBounds::newThreadStackBounds(PlatformThreadHandle thread)
 {
     stack_t stack;
     pthread_stackseg_np(thread, &stack);
     void* origin = stack.ss_sp;
-    void* bound = nullptr;
-    if (stackDirection() == StackDirection::Upward)
-        bound = static_cast<char*>(origin) + stack.ss_size;
-    else
-        bound = static_cast<char*>(origin) - stack.ss_size;
+    void* bound = static_cast<char*>(origin) - stack.ss_size;
     return StackBounds { origin, bound };
 }
 
 #else // !OS(OPENBSD)
 
@@ -163,14 +114,10 @@
     void* origin = static_cast<char*>(bound) + stackSize;
 #if PLATFORM(JAVA)
     bound = static_cast<char*>(bound) + JAVA_RED_ZONE;
 #endif
     // pthread_attr_getstack's bound is the lowest accessible pointer of the stack.
-    // If stack grows up, origin and bound in this code should be swapped.
-    if (stackDirection() == StackDirection::Upward)
-        std::swap(origin, bound);
-
     return StackBounds { origin, bound };
 }
 
 #endif // OS(OPENBSD)
 
@@ -181,16 +128,17 @@
 
 #elif OS(WINDOWS)
 
 StackBounds StackBounds::currentThreadStackBoundsInternal()
 {
-    ASSERT(stackDirection() == StackDirection::Downward);
     MEMORY_BASIC_INFORMATION stackOrigin { };
     VirtualQuery(&stackOrigin, &stackOrigin, sizeof(stackOrigin));
     // stackOrigin.AllocationBase points to the reserved stack memory base address.
 
+    const LPVOID theAllocBase = stackOrigin.AllocationBase;
     void* origin = static_cast<char*>(stackOrigin.BaseAddress) + stackOrigin.RegionSize;
+
     // The stack on Windows consists out of three parts (uncommitted memory, a guard page and present
     // committed memory). The 3 regions have different BaseAddresses but all have the same AllocationBase
     // since they are all from the same VirtualAlloc. The 3 regions are laid out in memory (from high to
     // low) as follows:
     //
@@ -202,27 +150,20 @@
     //         | uncommittedMemory |    v
     //    Low  |-------------------|  ----- <--- stackOrigin.AllocationBase
     //
     // See http://msdn.microsoft.com/en-us/library/ms686774%28VS.85%29.aspx for more information.
 
-    MEMORY_BASIC_INFORMATION uncommittedMemory;
-
-#if PLATFORM(JAVA)
     // look for uncommited memory block.
-    const LPVOID theAllocBase = stackOrigin.AllocationBase;
+    MEMORY_BASIC_INFORMATION uncommittedMemory;
     LPVOID a = stackOrigin.AllocationBase;
 
     do {
         size_t ret = VirtualQuery(a, &uncommittedMemory, sizeof(uncommittedMemory));
         ASSERT(ret != 0);
         a = (LPVOID)((static_cast<char*>(a)) + uncommittedMemory.RegionSize);
     } while (theAllocBase == uncommittedMemory.AllocationBase &&
         uncommittedMemory.State != MEM_RESERVE);
-#else
-    VirtualQuery(stackOrigin.AllocationBase, &uncommittedMemory, sizeof(uncommittedMemory));
-    ASSERT(uncommittedMemory.State == MEM_RESERVE);
-#endif
 
     MEMORY_BASIC_INFORMATION guardPage;
     VirtualQuery(static_cast<char*>(uncommittedMemory.BaseAddress) + uncommittedMemory.RegionSize, &guardPage, sizeof(guardPage));
     ASSERT(guardPage.Protect & PAGE_GUARD);
 

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/dom/ElementIterator.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2013 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &quot;ElementTraversal.h&quot;
 29 
<a name="1" id="anc1"></a><span class="line-modified"> 30 #if ASSERT_ENABLED</span>
 31 #include &quot;ElementIteratorAssertions.h&quot;
 32 #endif
 33 
 34 namespace WebCore {
 35 
 36 template &lt;typename ElementType&gt;
 37 class ElementIterator {
 38 public:
 39     ElementIterator(const ContainerNode* root);
 40     ElementIterator(const ContainerNode* root, ElementType* current);
 41 
 42     ElementType&amp; operator*() const;
 43     ElementType* operator-&gt;() const;
 44 
 45     bool operator==(const ElementIterator&amp; other) const;
 46     bool operator!=(const ElementIterator&amp; other) const;
 47 
 48     ElementIterator&amp; traverseNext();
 49     ElementIterator&amp; traversePrevious();
 50     ElementIterator&amp; traverseNextSibling();
 51     ElementIterator&amp; traversePreviousSibling();
 52     ElementIterator&amp; traverseNextSkippingChildren();
 53     ElementIterator&amp; traverseAncestor();
 54 
 55     void dropAssertions();
 56 
 57 private:
 58     const ContainerNode* m_root;
 59     ElementType* m_current;
 60 
<a name="2" id="anc2"></a><span class="line-modified"> 61 #if ASSERT_ENABLED</span>
 62     ElementIteratorAssertions m_assertions;
 63 #endif
 64 };
 65 
 66 template &lt;typename ElementType&gt;
 67 class ElementConstIterator {
 68 public:
 69     ElementConstIterator(const ContainerNode* root);
 70     ElementConstIterator(const ContainerNode* root, const ElementType* current);
 71 
 72     const ElementType&amp; operator*() const;
 73     const ElementType* operator-&gt;() const;
 74 
 75     bool operator==(const ElementConstIterator&amp; other) const;
 76     bool operator!=(const ElementConstIterator&amp; other) const;
 77 
 78     ElementConstIterator&amp; traverseNext();
 79     ElementConstIterator&amp; traversePrevious();
 80     ElementConstIterator&amp; traverseNextSibling();
 81     ElementConstIterator&amp; traversePreviousSibling();
 82     ElementConstIterator&amp; traverseNextSkippingChildren();
 83     ElementConstIterator&amp; traverseAncestor();
 84 
 85     void dropAssertions();
 86 
 87 private:
 88     const ContainerNode* m_root;
 89     const ElementType* m_current;
 90 
<a name="3" id="anc3"></a><span class="line-modified"> 91 #if ASSERT_ENABLED</span>
 92     ElementIteratorAssertions m_assertions;
 93 #endif
 94 };
 95 
 96 // ElementIterator
 97 
 98 template &lt;typename ElementType&gt;
 99 inline ElementIterator&lt;ElementType&gt;::ElementIterator(const ContainerNode* root)
100     : m_root(root)
101     , m_current(nullptr)
102 {
103 }
104 
105 template &lt;typename ElementType&gt;
106 inline ElementIterator&lt;ElementType&gt;::ElementIterator(const ContainerNode* root, ElementType* current)
107     : m_root(root)
108     , m_current(current)
<a name="4" id="anc4"></a><span class="line-modified">109 #if ASSERT_ENABLED</span>
110     , m_assertions(current)
111 #endif
112 {
113 }
114 
115 template &lt;typename ElementType&gt;
116 inline ElementIterator&lt;ElementType&gt;&amp; ElementIterator&lt;ElementType&gt;::traverseNext()
117 {
118     ASSERT(m_current);
119     ASSERT(!m_assertions.domTreeHasMutated());
120     m_current = Traversal&lt;ElementType&gt;::next(*m_current, m_root);
<a name="5" id="anc5"></a><span class="line-modified">121 #if ASSERT_ENABLED</span>
122     // Drop the assertion when the iterator reaches the end.
123     if (!m_current)
124         m_assertions.dropEventDispatchAssertion();
125 #endif
126     return *this;
127 }
128 
129 template &lt;typename ElementType&gt;
130 inline ElementIterator&lt;ElementType&gt;&amp; ElementIterator&lt;ElementType&gt;::traversePrevious()
131 {
132     ASSERT(m_current);
133     ASSERT(!m_assertions.domTreeHasMutated());
134     m_current = Traversal&lt;ElementType&gt;::previous(*m_current, m_root);
<a name="6" id="anc6"></a><span class="line-modified">135 #if ASSERT_ENABLED</span>
136     // Drop the assertion when the iterator reaches the end.
137     if (!m_current)
138         m_assertions.dropEventDispatchAssertion();
139 #endif
140     return *this;
141 }
142 
143 template &lt;typename ElementType&gt;
144 inline ElementIterator&lt;ElementType&gt;&amp; ElementIterator&lt;ElementType&gt;::traverseNextSibling()
145 {
146     ASSERT(m_current);
147     ASSERT(!m_assertions.domTreeHasMutated());
148     m_current = Traversal&lt;ElementType&gt;::nextSibling(*m_current);
<a name="7" id="anc7"></a><span class="line-modified">149 #if ASSERT_ENABLED</span>
150     // Drop the assertion when the iterator reaches the end.
151     if (!m_current)
152         m_assertions.dropEventDispatchAssertion();
153 #endif
154     return *this;
155 }
156 
157 template &lt;typename ElementType&gt;
158 inline ElementIterator&lt;ElementType&gt;&amp; ElementIterator&lt;ElementType&gt;::traversePreviousSibling()
159 {
160     ASSERT(m_current);
161     ASSERT(!m_assertions.domTreeHasMutated());
162     m_current = Traversal&lt;ElementType&gt;::previousSibling(*m_current);
<a name="8" id="anc8"></a><span class="line-modified">163 #if ASSERT_ENABLED</span>
164     // Drop the assertion when the iterator reaches the end.
165     if (!m_current)
166         m_assertions.dropEventDispatchAssertion();
167 #endif
168     return *this;
169 }
170 
171 template &lt;typename ElementType&gt;
172 inline ElementIterator&lt;ElementType&gt;&amp; ElementIterator&lt;ElementType&gt;::traverseNextSkippingChildren()
173 {
174     ASSERT(m_current);
175     ASSERT(!m_assertions.domTreeHasMutated());
176     m_current = Traversal&lt;ElementType&gt;::nextSkippingChildren(*m_current, m_root);
<a name="9" id="anc9"></a><span class="line-modified">177 #if ASSERT_ENABLED</span>
178     // Drop the assertion when the iterator reaches the end.
179     if (!m_current)
180         m_assertions.dropEventDispatchAssertion();
181 #endif
182     return *this;
183 }
184 
185 template &lt;typename ElementType&gt;
186 inline void ElementIterator&lt;ElementType&gt;::dropAssertions()
187 {
<a name="10" id="anc10"></a><span class="line-modified">188 #if ASSERT_ENABLED</span>
189     m_assertions.clear();
190 #endif
191 }
192 
193 template &lt;typename ElementType&gt;
194 inline ElementType* findElementAncestorOfType(const Node&amp; current)
195 {
196     for (Element* ancestor = current.parentElement(); ancestor; ancestor = ancestor-&gt;parentElement()) {
197         if (is&lt;ElementType&gt;(*ancestor))
198             return downcast&lt;ElementType&gt;(ancestor);
199     }
200     return nullptr;
201 }
202 
203 template &lt;&gt;
204 inline Element* findElementAncestorOfType&lt;Element&gt;(const Node&amp; current)
205 {
206     return current.parentElement();
207 }
208 
209 template &lt;typename ElementType&gt;
210 inline ElementIterator&lt;ElementType&gt;&amp; ElementIterator&lt;ElementType&gt;::traverseAncestor()
211 {
212     ASSERT(m_current);
213     ASSERT(m_current != m_root);
214     ASSERT(!m_assertions.domTreeHasMutated());
215     m_current = findElementAncestorOfType&lt;ElementType&gt;(*m_current);
<a name="11" id="anc11"></a><span class="line-modified">216 #if ASSERT_ENABLED</span>
217     // Drop the assertion when the iterator reaches the end.
218     if (!m_current)
219         m_assertions.dropEventDispatchAssertion();
220 #endif
221     return *this;
222 }
223 
224 template &lt;typename ElementType&gt;
225 inline ElementType&amp; ElementIterator&lt;ElementType&gt;::operator*() const
226 {
227     ASSERT(m_current);
228     ASSERT(!m_assertions.domTreeHasMutated());
229     return *m_current;
230 }
231 
232 template &lt;typename ElementType&gt;
233 inline ElementType* ElementIterator&lt;ElementType&gt;::operator-&gt;() const
234 {
235     ASSERT(m_current);
236     ASSERT(!m_assertions.domTreeHasMutated());
237     return m_current;
238 }
239 
240 template &lt;typename ElementType&gt;
241 inline bool ElementIterator&lt;ElementType&gt;::operator==(const ElementIterator&amp; other) const
242 {
243     ASSERT(m_root == other.m_root);
244     ASSERT(!m_assertions.domTreeHasMutated());
245     return m_current == other.m_current;
246 }
247 
248 template &lt;typename ElementType&gt;
249 inline bool ElementIterator&lt;ElementType&gt;::operator!=(const ElementIterator&amp; other) const
250 {
251     return !(*this == other);
252 }
253 
254 // ElementConstIterator
255 
256 template &lt;typename ElementType&gt;
257 inline ElementConstIterator&lt;ElementType&gt;::ElementConstIterator(const ContainerNode* root)
258     : m_root(root)
259     , m_current(nullptr)
260 {
261 }
262 
263 template &lt;typename ElementType&gt;
264 inline ElementConstIterator&lt;ElementType&gt;::ElementConstIterator(const ContainerNode* root, const ElementType* current)
265     : m_root(root)
266     , m_current(current)
<a name="12" id="anc12"></a><span class="line-modified">267 #if ASSERT_ENABLED</span>
268     , m_assertions(current)
269 #endif
270 {
271 }
272 
273 template &lt;typename ElementType&gt;
274 inline ElementConstIterator&lt;ElementType&gt;&amp; ElementConstIterator&lt;ElementType&gt;::traverseNext()
275 {
276     ASSERT(m_current);
277     ASSERT(!m_assertions.domTreeHasMutated());
278     m_current = Traversal&lt;ElementType&gt;::next(*m_current, m_root);
<a name="13" id="anc13"></a><span class="line-modified">279 #if ASSERT_ENABLED</span>
280     // Drop the assertion when the iterator reaches the end.
281     if (!m_current)
282         m_assertions.dropEventDispatchAssertion();
283 #endif
284     return *this;
285 }
286 
287 template &lt;typename ElementType&gt;
288 inline ElementConstIterator&lt;ElementType&gt;&amp; ElementConstIterator&lt;ElementType&gt;::traversePrevious()
289 {
290     ASSERT(m_current);
291     ASSERT(!m_assertions.domTreeHasMutated());
292     m_current = Traversal&lt;ElementType&gt;::previous(*m_current, m_root);
<a name="14" id="anc14"></a><span class="line-modified">293 #if ASSERT_ENABLED</span>
294     // Drop the assertion when the iterator reaches the end.
295     if (!m_current)
296         m_assertions.dropEventDispatchAssertion();
297 #endif
298     return *this;
299 }
300 
301 template &lt;typename ElementType&gt;
302 inline ElementConstIterator&lt;ElementType&gt;&amp; ElementConstIterator&lt;ElementType&gt;::traverseNextSibling()
303 {
304     ASSERT(m_current);
305     ASSERT(!m_assertions.domTreeHasMutated());
306     m_current = Traversal&lt;ElementType&gt;::nextSibling(*m_current);
<a name="15" id="anc15"></a><span class="line-modified">307 #if ASSERT_ENABLED</span>
308     // Drop the assertion when the iterator reaches the end.
309     if (!m_current)
310         m_assertions.dropEventDispatchAssertion();
311 #endif
312     return *this;
313 }
314 
315 template &lt;typename ElementType&gt;
316 inline ElementConstIterator&lt;ElementType&gt;&amp; ElementConstIterator&lt;ElementType&gt;::traversePreviousSibling()
317 {
318     ASSERT(m_current);
319     ASSERT(!m_assertions.domTreeHasMutated());
320     m_current = Traversal&lt;ElementType&gt;::previousSibling(*m_current);
<a name="16" id="anc16"></a><span class="line-modified">321 #if ASSERT_ENABLED</span>
322     // Drop the assertion when the iterator reaches the end.
323     if (!m_current)
324         m_assertions.dropEventDispatchAssertion();
325 #endif
326     return *this;
327 }
328 
329 template &lt;typename ElementType&gt;
330 inline ElementConstIterator&lt;ElementType&gt;&amp; ElementConstIterator&lt;ElementType&gt;::traverseNextSkippingChildren()
331 {
332     ASSERT(m_current);
333     ASSERT(!m_assertions.domTreeHasMutated());
334     m_current = Traversal&lt;ElementType&gt;::nextSkippingChildren(*m_current, m_root);
<a name="17" id="anc17"></a><span class="line-modified">335 #if ASSERT_ENABLED</span>
336     // Drop the assertion when the iterator reaches the end.
337     if (!m_current)
338         m_assertions.dropEventDispatchAssertion();
339 #endif
340     return *this;
341 }
342 
343 template &lt;typename ElementType&gt;
344 inline ElementConstIterator&lt;ElementType&gt;&amp; ElementConstIterator&lt;ElementType&gt;::traverseAncestor()
345 {
346     ASSERT(m_current);
347     ASSERT(m_current != m_root);
348     ASSERT(!m_assertions.domTreeHasMutated());
349     m_current = findElementAncestorOfType&lt;const ElementType&gt;(*m_current);
<a name="18" id="anc18"></a><span class="line-modified">350 #if ASSERT_ENABLED</span>
351     // Drop the assertion when the iterator reaches the end.
352     if (!m_current)
353         m_assertions.dropEventDispatchAssertion();
354 #endif
355     return *this;
356 }
357 
358 template &lt;typename ElementType&gt;
359 inline void ElementConstIterator&lt;ElementType&gt;::dropAssertions()
360 {
<a name="19" id="anc19"></a><span class="line-modified">361 #if ASSERT_ENABLED</span>
362     m_assertions.clear();
363 #endif
364 }
365 
366 template &lt;typename ElementType&gt;
367 inline const ElementType&amp; ElementConstIterator&lt;ElementType&gt;::operator*() const
368 {
369     ASSERT(m_current);
370     ASSERT(!m_assertions.domTreeHasMutated());
371     return *m_current;
372 }
373 
374 template &lt;typename ElementType&gt;
375 inline const ElementType* ElementConstIterator&lt;ElementType&gt;::operator-&gt;() const
376 {
377     ASSERT(m_current);
378     ASSERT(!m_assertions.domTreeHasMutated());
379     return m_current;
380 }
381 
382 template &lt;typename ElementType&gt;
383 inline bool ElementConstIterator&lt;ElementType&gt;::operator==(const ElementConstIterator&amp; other) const
384 {
385     ASSERT(m_root == other.m_root);
386     ASSERT(!m_assertions.domTreeHasMutated());
387     return m_current == other.m_current;
388 }
389 
390 template &lt;typename ElementType&gt;
391 inline bool ElementConstIterator&lt;ElementType&gt;::operator!=(const ElementConstIterator&amp; other) const
392 {
393     return !(*this == other);
394 }
395 
396 } // namespace WebCore
397 
398 #include &quot;ElementAncestorIterator.h&quot;
399 #include &quot;ElementChildIterator.h&quot;
400 #include &quot;TypedElementDescendantIterator.h&quot;
<a name="20" id="anc20"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="20" type="hidden" />
</body>
</html>
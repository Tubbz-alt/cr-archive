<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorCanvasAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorDOMAgent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorDOMAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29  */
  30 
  31 #include &quot;config.h&quot;
  32 #include &quot;InspectorDOMAgent.h&quot;
  33 
  34 #include &quot;AXObjectCache.h&quot;
  35 #include &quot;AccessibilityNodeObject.h&quot;
  36 #include &quot;Attr.h&quot;
  37 #include &quot;CSSComputedStyleDeclaration.h&quot;

  38 #include &quot;CSSPropertyNames.h&quot;
  39 #include &quot;CSSPropertySourceData.h&quot;
  40 #include &quot;CSSRule.h&quot;
  41 #include &quot;CSSRuleList.h&quot;


  42 #include &quot;CSSStyleRule.h&quot;
  43 #include &quot;CSSStyleSheet.h&quot;
  44 #include &quot;CharacterData.h&quot;
  45 #include &quot;CommandLineAPIHost.h&quot;

  46 #include &quot;ContainerNode.h&quot;
  47 #include &quot;Cookie.h&quot;
  48 #include &quot;CookieJar.h&quot;
  49 #include &quot;DOMEditor.h&quot;
  50 #include &quot;DOMException.h&quot;
  51 #include &quot;DOMPatchSupport.h&quot;
  52 #include &quot;DOMWindow.h&quot;
  53 #include &quot;Document.h&quot;
  54 #include &quot;DocumentType.h&quot;
  55 #include &quot;Editing.h&quot;
  56 #include &quot;Element.h&quot;
  57 #include &quot;Event.h&quot;
  58 #include &quot;EventListener.h&quot;
  59 #include &quot;EventNames.h&quot;
  60 #include &quot;Frame.h&quot;
  61 #include &quot;FrameTree.h&quot;
  62 #include &quot;FrameView.h&quot;
  63 #include &quot;FullscreenManager.h&quot;
  64 #include &quot;HTMLElement.h&quot;
  65 #include &quot;HTMLFrameOwnerElement.h&quot;
</pre>
<hr />
<pre>
  75 #include &quot;InspectorClient.h&quot;
  76 #include &quot;InspectorController.h&quot;
  77 #include &quot;InspectorHistory.h&quot;
  78 #include &quot;InspectorNodeFinder.h&quot;
  79 #include &quot;InspectorOverlay.h&quot;
  80 #include &quot;InspectorPageAgent.h&quot;
  81 #include &quot;InstrumentingAgents.h&quot;
  82 #include &quot;IntRect.h&quot;
  83 #include &quot;JSDOMBindingSecurity.h&quot;
  84 #include &quot;JSEventListener.h&quot;
  85 #include &quot;JSNode.h&quot;
  86 #include &quot;MutationEvent.h&quot;
  87 #include &quot;Node.h&quot;
  88 #include &quot;NodeList.h&quot;
  89 #include &quot;Page.h&quot;
  90 #include &quot;Pasteboard.h&quot;
  91 #include &quot;PseudoElement.h&quot;
  92 #include &quot;RenderStyle.h&quot;
  93 #include &quot;RenderStyleConstants.h&quot;
  94 #include &quot;ScriptState.h&quot;

  95 #include &quot;ShadowRoot.h&quot;
  96 #include &quot;StaticNodeList.h&quot;
  97 #include &quot;StyleProperties.h&quot;
  98 #include &quot;StyleResolver.h&quot;
  99 #include &quot;StyleSheetList.h&quot;
 100 #include &quot;Text.h&quot;
 101 #include &quot;TextNodeTraversal.h&quot;
 102 #include &quot;Timer.h&quot;
 103 #include &quot;VideoPlaybackQuality.h&quot;
 104 #include &quot;WebInjectedScriptManager.h&quot;
 105 #include &quot;XPathResult.h&quot;
 106 #include &quot;markup.h&quot;
 107 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 108 #include &lt;JavaScriptCore/InjectedScript.h&gt;
 109 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
 110 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 111 #include &lt;pal/crypto/CryptoDigest.h&gt;

 112 #include &lt;wtf/text/Base64.h&gt;
 113 #include &lt;wtf/text/CString.h&gt;
 114 #include &lt;wtf/text/WTFString.h&gt;
 115 
 116 namespace WebCore {
 117 
 118 using namespace Inspector;
 119 
 120 using namespace HTMLNames;
 121 
 122 static const size_t maxTextSize = 10000;
 123 static const UChar ellipsisUChar[] = { 0x2026, 0 };
 124 
 125 static Color parseColor(const JSON::Object* colorObject)
 126 {
 127     if (!colorObject)
 128         return Color::transparent;
 129 
 130     int r = 0;
 131     int g = 0;
</pre>
<hr />
<pre>
 200 }
 201 
 202 void RevalidateStyleAttributeTask::timerFired()
 203 {
 204     // The timer is stopped on m_domAgent destruction, so this method will never be called after m_domAgent has been destroyed.
 205     Vector&lt;Element*&gt; elements;
 206     for (auto&amp; element : m_elements)
 207         elements.append(element.get());
 208     m_domAgent-&gt;styleAttributeInvalidated(elements);
 209 
 210     m_elements.clear();
 211 }
 212 
 213 class InspectableNode final : public CommandLineAPIHost::InspectableObject {
 214 public:
 215     explicit InspectableNode(Node* node)
 216         : m_node(node)
 217     {
 218     }
 219 
<span class="line-modified"> 220     JSC::JSValue get(JSC::ExecState&amp; state) final</span>
 221     {
 222         return InspectorDOMAgent::nodeAsScriptValue(state, m_node.get());
 223     }
 224 private:
 225     RefPtr&lt;Node&gt; m_node;
 226 };
 227 
 228 class EventFiredCallback final : public EventListener {
 229 public:
 230     static Ref&lt;EventFiredCallback&gt; create(InspectorDOMAgent&amp; domAgent)
 231     {
 232         return adoptRef(*new EventFiredCallback(domAgent));
 233     }
 234 
 235     bool operator==(const EventListener&amp; other) const final
 236     {
 237         return this == &amp;other;
 238     }
 239 
 240     void handleEvent(ScriptExecutionContext&amp;, Event&amp; event) final
</pre>
<hr />
<pre>
 444     return downcast&lt;Document&gt;(node);
 445 }
 446 
 447 Element* InspectorDOMAgent::assertElement(ErrorString&amp; errorString, int nodeId)
 448 {
 449     Node* node = assertNode(errorString, nodeId);
 450     if (!node)
 451         return nullptr;
 452     if (!is&lt;Element&gt;(node)) {
 453         errorString = &quot;Node for given nodeId is not an element&quot;_s;
 454         return nullptr;
 455     }
 456     return downcast&lt;Element&gt;(node);
 457 }
 458 
 459 Node* InspectorDOMAgent::assertEditableNode(ErrorString&amp; errorString, int nodeId)
 460 {
 461     Node* node = assertNode(errorString, nodeId);
 462     if (!node)
 463         return nullptr;
<span class="line-modified"> 464     if (node-&gt;isInUserAgentShadowTree()) {</span>
 465         errorString = &quot;Node for given nodeId is in a shadow tree&quot;_s;
 466         return nullptr;
 467     }
 468     if (node-&gt;isPseudoElement()) {
 469         errorString = &quot;Node for given nodeId is a pseudo-element&quot;_s;
 470         return nullptr;
 471     }
 472     return node;
 473 }
 474 
 475 Element* InspectorDOMAgent::assertEditableElement(ErrorString&amp; errorString, int nodeId)
 476 {
 477     Node* node = assertEditableNode(errorString, nodeId);
 478     if (!node)
 479         return nullptr;
 480     if (!is&lt;Element&gt;(node)) {
 481         errorString = &quot;Node for given nodeId is not an element&quot;_s;
 482         return nullptr;
 483     }
 484     return downcast&lt;Element&gt;(node);
</pre>
<hr />
<pre>
 524             pushChildNodesToFrontend(childNodeId, depth);
 525         }
 526 
 527         return;
 528     }
 529 
 530     auto children = buildArrayForContainerChildren(node, depth, nodeMap);
 531     m_frontendDispatcher-&gt;setChildNodes(nodeId, WTFMove(children));
 532 }
 533 
 534 void InspectorDOMAgent::discardBindings()
 535 {
 536     m_documentNodeToIdMap.clear();
 537     m_idToNode.clear();
 538     m_dispatchedEvents.clear();
 539     m_eventListenerEntries.clear();
 540     releaseDanglingNodes();
 541     m_childrenRequested.clear();
 542 }
 543 









 544 int InspectorDOMAgent::pushNodeToFrontend(ErrorString&amp; errorString, int documentNodeId, Node* nodeToPush)
 545 {
 546     Document* document = assertDocument(errorString, documentNodeId);
 547     if (!document)
 548         return 0;
 549     if (&amp;nodeToPush-&gt;document() != document) {
 550         errorString = &quot;nodeToPush is not part of the document with given documentNodeId&quot;_s;
 551         return 0;
 552     }
 553 
<span class="line-modified"> 554     return pushNodePathToFrontend(nodeToPush);</span>
 555 }
 556 
 557 Node* InspectorDOMAgent::nodeForId(int id)
 558 {
 559     if (!m_idToNode.isValidKey(id))
 560         return nullptr;
 561 
 562     return m_idToNode.get(id);
 563 }
 564 
 565 void InspectorDOMAgent::requestChildNodes(ErrorString&amp; errorString, int nodeId, const int* depth)
 566 {
 567     int sanitizedDepth;
 568 
 569     if (!depth)
 570         sanitizedDepth = 1;
 571     else if (*depth == -1)
 572         sanitizedDepth = INT_MAX;
 573     else if (*depth &gt; 0)
 574         sanitizedDepth = *depth;
</pre>
<hr />
<pre>
 581 }
 582 
 583 void InspectorDOMAgent::querySelector(ErrorString&amp; errorString, int nodeId, const String&amp; selectors, int* elementId)
 584 {
 585     *elementId = 0;
 586     Node* node = assertNode(errorString, nodeId);
 587     if (!node)
 588         return;
 589     if (!is&lt;ContainerNode&gt;(*node)) {
 590         assertElement(errorString, nodeId);
 591         return;
 592     }
 593 
 594     auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelector(selectors);
 595     if (queryResult.hasException()) {
 596         errorString = &quot;DOM Error while querying with given selectors&quot;_s;
 597         return;
 598     }
 599 
 600     if (auto* element = queryResult.releaseReturnValue())
<span class="line-modified"> 601         *elementId = pushNodePathToFrontend(element);</span>
 602 }
 603 
 604 void InspectorDOMAgent::querySelectorAll(ErrorString&amp; errorString, int nodeId, const String&amp; selectors, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; result)
 605 {
 606     Node* node = assertNode(errorString, nodeId);
 607     if (!node)
 608         return;
 609     if (!is&lt;ContainerNode&gt;(*node)) {
 610         assertElement(errorString, nodeId);
 611         return;
 612     }
 613 
 614     auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelectorAll(selectors);
 615     if (queryResult.hasException()) {
 616         errorString = &quot;DOM Error while querying with given selectors&quot;_s;
 617         return;
 618     }
 619 
 620     auto nodes = queryResult.releaseReturnValue();
 621     result = JSON::ArrayOf&lt;int&gt;::create();
 622     for (unsigned i = 0; i &lt; nodes-&gt;length(); ++i)
 623         result-&gt;addItem(pushNodePathToFrontend(nodes-&gt;item(i)));
 624 }
 625 
 626 int InspectorDOMAgent::pushNodePathToFrontend(Node* nodeToPush)






 627 {
 628     ASSERT(nodeToPush);  // Invalid input
 629 
<span class="line-modified"> 630     if (!m_document)</span>

 631         return 0;
<span class="line-modified"> 632     if (!m_documentNodeToIdMap.contains(m_document))</span>



 633         return 0;

 634 
 635     // Return id in case the node is known.
 636     int result = m_documentNodeToIdMap.get(nodeToPush);
 637     if (result)
 638         return result;
 639 
 640     Node* node = nodeToPush;
 641     Vector&lt;Node*&gt; path;
 642     NodeToIdMap* danglingMap = 0;
 643 
 644     while (true) {
 645         Node* parent = innerParentNode(node);
 646         if (!parent) {
 647             // Node being pushed is detached -&gt; push subtree root.
 648             auto newMap = makeUnique&lt;NodeToIdMap&gt;();
 649             danglingMap = newMap.get();
 650             m_danglingNodeToIdMaps.append(newMap.release());
 651             auto children = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
 652             children-&gt;addItem(buildObjectForNode(node, 0, danglingMap));
 653             m_frontendDispatcher-&gt;setChildNodes(0, WTFMove(children));
</pre>
<hr />
<pre>
 758         return;
 759     auto newElement = createElementResult.releaseReturnValue();
 760 
 761     // Copy over the original node&#39;s attributes.
 762     newElement-&gt;cloneAttributesFromElement(downcast&lt;Element&gt;(*oldNode));
 763 
 764     // Copy over the original node&#39;s children.
 765     RefPtr&lt;Node&gt; child;
 766     while ((child = oldNode-&gt;firstChild())) {
 767         if (!m_domEditor-&gt;insertBefore(newElement, *child, 0, errorString))
 768             return;
 769     }
 770 
 771     // Replace the old node with the new node
 772     RefPtr&lt;ContainerNode&gt; parent = oldNode-&gt;parentNode();
 773     if (!m_domEditor-&gt;insertBefore(*parent, newElement.copyRef(), oldNode-&gt;nextSibling(), errorString))
 774         return;
 775     if (!m_domEditor-&gt;removeChild(*parent, *oldNode, errorString))
 776         return;
 777 
<span class="line-modified"> 778     *newId = pushNodePathToFrontend(newElement.ptr());</span>
 779     if (m_childrenRequested.contains(nodeId))
 780         pushChildNodesToFrontend(*newId);
 781 }
 782 
 783 void InspectorDOMAgent::getOuterHTML(ErrorString&amp; errorString, int nodeId, WTF::String* outerHTML)
 784 {
 785     Node* node = assertNode(errorString, nodeId);
 786     if (!node)
 787         return;
 788 
 789     *outerHTML = serializeFragment(*node, SerializedNodes::SubtreeIncludingNode);
 790 }
 791 
 792 void InspectorDOMAgent::setOuterHTML(ErrorString&amp; errorString, int nodeId, const String&amp; outerHTML)
 793 {
 794     if (!nodeId) {
 795         DOMPatchSupport { *m_domEditor, *m_document }.patchDocument(outerHTML);
 796         return;
 797     }
 798 
 799     Node* node = assertEditableNode(errorString, nodeId);
 800     if (!node)
 801         return;
 802 
 803     Document&amp; document = node-&gt;document();
 804     if (!document.isHTMLDocument() &amp;&amp; !document.isXMLDocument()) {
 805         errorString = &quot;Document of node for given nodeId is not HTML/XML&quot;_s;
 806         return;
 807     }
 808 
 809     Node* newNode = nullptr;
 810     if (!m_domEditor-&gt;setOuterHTML(*node, outerHTML, newNode, errorString))
 811         return;
 812 
 813     if (!newNode) {
 814         // The only child node has been deleted.
 815         return;
 816     }
 817 
<span class="line-modified"> 818     int newId = pushNodePathToFrontend(newNode);</span>
 819 
 820     bool childrenRequested = m_childrenRequested.contains(nodeId);
 821     if (childrenRequested)
 822         pushChildNodesToFrontend(newId);
 823 }
 824 
 825 void InspectorDOMAgent::insertAdjacentHTML(ErrorString&amp; errorString, int nodeId, const String&amp; position, const String&amp; html)
 826 {
 827     Node* node = assertEditableNode(errorString, nodeId);
 828     if (!node)
 829         return;
 830 
 831     if (!is&lt;Element&gt;(node)) {
 832         errorString = &quot;Node for given nodeId is not an element&quot;_s;
 833         return;
 834     }
 835 
 836     m_domEditor-&gt;insertAdjacentHTML(downcast&lt;Element&gt;(*node), position, html, errorString);
 837 }
 838 
</pre>
<hr />
<pre>
1095     if (!m_nodeToFocus)
1096         return;
1097 
1098     focusNode();
1099 }
1100 
1101 void InspectorDOMAgent::focusNode()
1102 {
1103     if (!m_documentRequested)
1104         return;
1105 
1106     ASSERT(m_nodeToFocus);
1107 
1108     RefPtr&lt;Node&gt; node = m_nodeToFocus.get();
1109     m_nodeToFocus = nullptr;
1110 
1111     Frame* frame = node-&gt;document().frame();
1112     if (!frame)
1113         return;
1114 
<span class="line-modified">1115     JSC::ExecState* scriptState = mainWorldExecState(frame);</span>
1116     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(scriptState);
1117     if (injectedScript.hasNoValue())
1118         return;
1119 
1120     injectedScript.inspectObject(nodeAsScriptValue(*scriptState, node.get()));
1121 }
1122 
1123 void InspectorDOMAgent::mouseDidMoveOverElement(const HitTestResult&amp; result, unsigned)
1124 {
1125     m_mousedOverNode = result.innerNode();
1126 
1127     if (!m_searchingForNode)
1128         return;
1129 
1130     highlightMousedOverNode();
1131 }
1132 
1133 void InspectorDOMAgent::highlightMousedOverNode()
1134 {
1135     Node* node = m_mousedOverNode.get();
</pre>
<hr />
<pre>
1196 {
1197     auto quad = makeUnique&lt;FloatQuad&gt;();
1198     if (!parseQuad(quadArray, quad.get())) {
1199         errorString = &quot;Unexpected invalid quadArray&quot;_s;
1200         return;
1201     }
1202     innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
1203 }
1204 
1205 void InspectorDOMAgent::innerHighlightQuad(std::unique_ptr&lt;FloatQuad&gt; quad, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1206 {
1207     auto highlightConfig = makeUnique&lt;HighlightConfig&gt;();
1208     highlightConfig-&gt;content = parseColor(color);
1209     highlightConfig-&gt;contentOutline = parseColor(outlineColor);
1210     highlightConfig-&gt;usePageCoordinates = usePageCoordinates ? *usePageCoordinates : false;
1211     m_overlay-&gt;highlightQuad(WTFMove(quad), *highlightConfig);
1212 }
1213 
1214 void InspectorDOMAgent::highlightSelector(ErrorString&amp; errorString, const JSON::Object&amp; highlightInspectorObject, const String&amp; selectorString, const String* frameId)
1215 {




1216     RefPtr&lt;Document&gt; document;
1217 
1218     if (frameId) {
1219         auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
1220         if (!pageAgent) {
1221             errorString = &quot;Page domain must be enabled&quot;_s;
1222             return;
1223         }
1224 
1225         auto* frame = pageAgent-&gt;assertFrame(errorString, *frameId);
1226         if (!frame)
1227             return;
1228 
1229         document = frame-&gt;document();
1230     } else
1231         document = m_document;
1232 
1233     if (!document) {
1234         errorString = &quot;Missing document of frame for given frameId&quot;_s;
1235         return;
1236     }
1237 
<span class="line-modified">1238     auto queryResult = document-&gt;querySelectorAll(selectorString);</span>
<span class="line-modified">1239     // FIXME: &lt;https://webkit.org/b/146161&gt; Web Inspector: DOM.highlightSelector should work for &quot;a:visited&quot;</span>
<span class="line-modified">1240     if (queryResult.hasException()) {</span>
<span class="line-removed">1241         errorString = &quot;DOM Error while querying with given selectorString&quot;_s;</span>
<span class="line-removed">1242         return;</span>
<span class="line-removed">1243     }</span>
1244 
<span class="line-modified">1245     auto highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);</span>
<span class="line-removed">1246     if (!highlightConfig)</span>
<span class="line-removed">1247         return;</span>
1248 
<span class="line-modified">1249     m_overlay-&gt;highlightNodeList(queryResult.releaseReturnValue(), *highlightConfig);</span>





















































1250 }
1251 
1252 void InspectorDOMAgent::highlightNode(ErrorString&amp; errorString, const JSON::Object&amp; highlightInspectorObject, const int* nodeId, const String* objectId)
1253 {
1254     Node* node = nullptr;
1255     if (nodeId)
1256         node = assertNode(errorString, *nodeId);
1257     else if (objectId) {
1258         node = nodeForObjectId(*objectId);
1259         if (!node)
1260             errorString = &quot;Missing node for given objectId&quot;_s;
1261     } else
1262         errorString = &quot;Either nodeId or objectId must be specified&quot;_s;
1263 
1264     if (!node)
1265         return;
1266 
1267     std::unique_ptr&lt;HighlightConfig&gt; highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
1268     if (!highlightConfig)
1269         return;
</pre>
<hr />
<pre>
1338         return;
1339 
1340     Element* targetElement = assertEditableElement(errorString, targetElementId);
1341     if (!targetElement)
1342         return;
1343 
1344     Node* anchorNode = 0;
1345     if (anchorNodeId &amp;&amp; *anchorNodeId) {
1346         anchorNode = assertEditableNode(errorString, *anchorNodeId);
1347         if (!anchorNode)
1348             return;
1349         if (anchorNode-&gt;parentNode() != targetElement) {
1350             errorString = &quot;Given anchorNodeId must be a child of given targetElementId&quot;_s;
1351             return;
1352         }
1353     }
1354 
1355     if (!m_domEditor-&gt;insertBefore(*targetElement, *node, anchorNode, errorString))
1356         return;
1357 
<span class="line-modified">1358     *newNodeId = pushNodePathToFrontend(node);</span>
1359 }
1360 
1361 void InspectorDOMAgent::undo(ErrorString&amp; errorString)
1362 {
1363     auto result = m_history-&gt;undo();
1364     if (result.hasException())
1365         errorString = toErrorString(result.releaseException());
1366 }
1367 
1368 void InspectorDOMAgent::redo(ErrorString&amp; errorString)
1369 {
1370     auto result = m_history-&gt;redo();
1371     if (result.hasException())
1372         errorString = toErrorString(result.releaseException());
1373 }
1374 
1375 void InspectorDOMAgent::markUndoableState(ErrorString&amp;)
1376 {
1377     m_history-&gt;markUndoableState();
1378 }
1379 
1380 void InspectorDOMAgent::focus(ErrorString&amp; errorString, int nodeId)
1381 {
1382     Element* element = assertElement(errorString, nodeId);
1383     if (!element)
1384         return;
1385     if (!element-&gt;isFocusable()) {
1386         errorString = &quot;Element for given nodeId is not focusable&quot;_s;
1387         return;
1388     }
1389     element-&gt;focus();
1390 }
1391 
1392 void InspectorDOMAgent::setInspectedNode(ErrorString&amp; errorString, int nodeId)
1393 {
1394     Node* node = assertNode(errorString, nodeId);
1395     if (!node)
1396         return;
1397 
<span class="line-modified">1398     if (node-&gt;isInUserAgentShadowTree()) {</span>
1399         errorString = &quot;Node for given nodeId is in a shadow tree&quot;_s;
1400         return;
1401     }
1402 
1403     m_inspectedNode = node;
1404 
1405     if (auto&amp; commandLineAPIHost = static_cast&lt;WebInjectedScriptManager&amp;&gt;(m_injectedScriptManager).commandLineAPIHost())
1406         commandLineAPIHost-&gt;addInspectedObject(makeUnique&lt;InspectableNode&gt;(node));
1407 
1408     m_suppressEventListenerChangedEvent = false;
1409 }
1410 
1411 void InspectorDOMAgent::resolveNode(ErrorString&amp; errorString, int nodeId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
1412 {
1413     String objectGroupName = objectGroup ? *objectGroup : emptyString();
1414     Node* node = assertNode(errorString, nodeId);
1415     if (!node)
1416         return;
1417     RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; object = resolveNode(node, objectGroupName);
1418     if (!object) {
1419         errorString = &quot;Missing injected script for given nodeId&quot;_s;
1420         return;
1421     }
1422     result = object;
1423 }
1424 
1425 void InspectorDOMAgent::getAttributes(ErrorString&amp; errorString, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; result)
1426 {
1427     Element* element = assertElement(errorString, nodeId);
1428     if (!element)
1429         return;
1430 
1431     result = buildArrayForElementAttributes(element);
1432 }
1433 
<span class="line-modified">1434 void InspectorDOMAgent::requestNode(ErrorString&amp;, const String&amp; objectId, int* nodeId)</span>
1435 {
1436     Node* node = nodeForObjectId(objectId);
1437     if (node)
<span class="line-modified">1438         *nodeId = pushNodePathToFrontend(node);</span>
1439     else
1440         *nodeId = 0;
1441 }
1442 
1443 String InspectorDOMAgent::documentURLString(Document* document)
1444 {
1445     if (!document || document-&gt;url().isNull())
1446         return emptyString();
1447     return document-&gt;url().string();
1448 }
1449 
1450 static String documentBaseURLString(Document* document)
1451 {
1452     return document-&gt;completeURL(emptyString()).string();
1453 }
1454 
1455 static bool pseudoElementType(PseudoId pseudoId, Inspector::Protocol::DOM::PseudoType* type)
1456 {
1457     switch (pseudoId) {
1458     case PseudoId::Before:
</pre>
<hr />
<pre>
1670 
1671 Ref&lt;Inspector::Protocol::DOM::EventListener&gt; InspectorDOMAgent::buildObjectForEventListener(const RegisteredEventListener&amp; registeredEventListener, int identifier, EventTarget&amp; eventTarget, const AtomString&amp; eventType, bool disabled, bool hasBreakpoint)
1672 {
1673     Ref&lt;EventListener&gt; eventListener = registeredEventListener.callback();
1674 
1675     String handlerName;
1676     int lineNumber = 0;
1677     int columnNumber = 0;
1678     String scriptID;
1679     if (is&lt;JSEventListener&gt;(eventListener.get())) {
1680         auto&amp; scriptListener = downcast&lt;JSEventListener&gt;(eventListener.get());
1681 
1682         Document* document = nullptr;
1683         if (auto* scriptExecutionContext = eventTarget.scriptExecutionContext()) {
1684             if (is&lt;Document&gt;(scriptExecutionContext))
1685                 document = downcast&lt;Document&gt;(scriptExecutionContext);
1686         } else if (is&lt;Node&gt;(eventTarget))
1687             document = &amp;downcast&lt;Node&gt;(eventTarget).document();
1688 
1689         JSC::JSObject* handlerObject = nullptr;
<span class="line-modified">1690         JSC::ExecState* exec = nullptr;</span>
1691 
1692         JSC::JSLockHolder lock(scriptListener.isolatedWorld().vm());
1693 
1694         if (document) {
1695             handlerObject = scriptListener.jsFunction(*document);
1696             exec = execStateFromNode(scriptListener.isolatedWorld(), document);
1697         }
1698 
1699         if (handlerObject &amp;&amp; exec) {
1700             JSC::VM&amp; vm = exec-&gt;vm();
1701             JSC::JSFunction* handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(vm, handlerObject);
1702 
1703             if (!handlerFunction) {
1704                 auto scope = DECLARE_CATCH_SCOPE(vm);
1705 
1706                 // If the handler is not actually a function, see if it implements the EventListener interface and use that.
1707                 auto handleEventValue = handlerObject-&gt;get(exec, JSC::Identifier::fromString(vm, &quot;handleEvent&quot;));
1708 
1709                 if (UNLIKELY(scope.exception()))
1710                     scope.clearException();
</pre>
<hr />
<pre>
1744         auto location = Inspector::Protocol::Debugger::Location::create()
1745             .setScriptId(scriptID)
1746             .setLineNumber(lineNumber)
1747             .release();
1748         location-&gt;setColumnNumber(columnNumber);
1749         value-&gt;setLocation(WTFMove(location));
1750     }
1751     if (!handlerName.isEmpty())
1752         value-&gt;setHandlerName(handlerName);
1753     if (registeredEventListener.isPassive())
1754         value-&gt;setPassive(true);
1755     if (registeredEventListener.isOnce())
1756         value-&gt;setOnce(true);
1757     if (disabled)
1758         value-&gt;setDisabled(disabled);
1759     if (hasBreakpoint)
1760         value-&gt;setHasBreakpoint(hasBreakpoint);
1761     return value;
1762 }
1763 
<span class="line-modified">1764 void InspectorDOMAgent::processAccessibilityChildren(AccessibilityObject&amp; axObject, JSON::ArrayOf&lt;int&gt;&amp; childNodeIds)</span>
1765 {
1766     const auto&amp; children = axObject.children();
1767     if (!children.size())
1768         return;
1769 
1770     for (const auto&amp; childObject : children) {
1771         if (Node* childNode = childObject-&gt;node())
1772             childNodeIds.addItem(pushNodePathToFrontend(childNode));
1773         else
1774             processAccessibilityChildren(*childObject, childNodeIds);
1775     }
1776 }
1777 
1778 RefPtr&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt; InspectorDOMAgent::buildObjectForAccessibilityProperties(Node* node)
1779 {
1780     ASSERT(node);
1781     if (!node)
1782         return nullptr;
1783 
1784     if (!WebCore::AXObjectCache::accessibilityEnabled())
</pre>
<hr />
<pre>
1807     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; ownedNodeIds;
1808     Node* parentNode = nullptr;
1809     bool pressed = false;
1810     bool readonly = false;
1811     bool required = false;
1812     String role;
1813     bool selected = false;
1814     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; selectedChildNodeIds;
1815     bool supportsChecked = false;
1816     bool supportsExpanded = false;
1817     bool supportsLiveRegion = false;
1818     bool supportsPressed = false;
1819     bool supportsRequired = false;
1820     bool supportsFocused = false;
1821     bool isPopupButton = false;
1822     int headingLevel = 0;
1823     unsigned hierarchicalLevel = 0;
1824     unsigned level = 0;
1825 
1826     if (AXObjectCache* axObjectCache = node-&gt;document().axObjectCache()) {
<span class="line-modified">1827         if (AccessibilityObject* axObject = axObjectCache-&gt;getOrCreate(node)) {</span>
1828 
<span class="line-modified">1829             if (AccessibilityObject* activeDescendant = axObject-&gt;activeDescendant())</span>
1830                 activeDescendantNode = activeDescendant-&gt;node();
1831 
1832             // An AX object is &quot;busy&quot; if it or any ancestor has aria-busy=&quot;true&quot; set.
<span class="line-modified">1833             AccessibilityObject* current = axObject;</span>
1834             while (!busy &amp;&amp; current) {
1835                 busy = current-&gt;isBusy();
1836                 current = current-&gt;parentObject();
1837             }
1838 
1839             supportsChecked = axObject-&gt;supportsChecked();
1840             if (supportsChecked) {
1841                 AccessibilityButtonState checkValue = axObject-&gt;checkboxOrRadioValue(); // Element using aria-checked.
1842                 if (checkValue == AccessibilityButtonState::On)
1843                     checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::True;
1844                 else if (checkValue == AccessibilityButtonState::Mixed)
1845                     checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::Mixed;
1846                 else if (axObject-&gt;isChecked()) // Native checkbox.
1847                     checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::True;
1848             }
1849 
1850             if (!axObject-&gt;children().isEmpty()) {
1851                 childNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1852                 processAccessibilityChildren(*axObject, *childNodeIds);
1853             }
</pre>
<hr />
<pre>
1954                 String ariaLive = axObject-&gt;liveRegionStatus();
1955                 if (ariaLive == &quot;assertive&quot;)
1956                     liveRegionStatus = Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus::Assertive;
1957                 else if (ariaLive == &quot;polite&quot;)
1958                     liveRegionStatus = Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus::Polite;
1959             }
1960 
1961             if (is&lt;AccessibilityNodeObject&gt;(*axObject))
1962                 mouseEventNode = downcast&lt;AccessibilityNodeObject&gt;(*axObject).mouseButtonListener(MouseButtonListenerResultFilter::IncludeBodyElement);
1963 
1964             if (axObject-&gt;supportsARIAOwns()) {
1965                 Vector&lt;Element*&gt; ownedElements;
1966                 axObject-&gt;elementsFromAttribute(ownedElements, aria_ownsAttr);
1967                 if (ownedElements.size()) {
1968                     ownedNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1969                     for (Element* ownedElement : ownedElements)
1970                         ownedNodeIds-&gt;addItem(pushNodePathToFrontend(ownedElement));
1971                 }
1972             }
1973 
<span class="line-modified">1974             if (AccessibilityObject* parentObject = axObject-&gt;parentObjectUnignored())</span>
1975                 parentNode = parentObject-&gt;node();
1976 
1977             supportsPressed = axObject-&gt;pressedIsPresent();
1978             if (supportsPressed)
1979                 pressed = axObject-&gt;isPressed();
1980 
1981             if (axObject-&gt;isTextControl())
1982                 readonly = !axObject-&gt;canSetValueAttribute();
1983 
1984             supportsRequired = axObject-&gt;supportsRequiredAttribute();
1985             if (supportsRequired)
1986                 required = axObject-&gt;isRequired();
1987 
1988             role = axObject-&gt;computedRoleString();
1989             selected = axObject-&gt;isSelected();
1990 
<span class="line-modified">1991             AccessibilityObject::AccessibilityChildrenVector selectedChildren;</span>
1992             axObject-&gt;selectedChildren(selectedChildren);
1993             if (selectedChildren.size()) {
1994                 selectedChildNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1995                 for (auto&amp; selectedChildObject : selectedChildren) {
1996                     if (Node* selectedChildNode = selectedChildObject-&gt;node())
1997                         selectedChildNodeIds-&gt;addItem(pushNodePathToFrontend(selectedChildNode));
1998                 }
1999             }
2000 
2001             headingLevel = axObject-&gt;headingLevel();
2002             hierarchicalLevel = axObject-&gt;hierarchicalLevel();
2003 
2004             level = hierarchicalLevel ? hierarchicalLevel : headingLevel;
2005             isPopupButton = axObject-&gt;isPopUpButton() || axObject-&gt;hasPopup();
2006         }
2007     }
2008 
2009     Ref&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt; value = Inspector::Protocol::DOM::AccessibilityProperties::create()
2010         .setExists(exists)
2011         .setLabel(label)
</pre>
<hr />
<pre>
2562         const auto&amp; childName = pathTokens[i + 1];
2563         if (!child || child-&gt;nodeName() != childName)
2564             return nullptr;
2565         node = child;
2566     }
2567     return node;
2568 }
2569 
2570 Node* InspectorDOMAgent::nodeForObjectId(const String&amp; objectId)
2571 {
2572     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
2573     if (injectedScript.hasNoValue())
2574         return nullptr;
2575 
2576     return scriptValueAsNode(injectedScript.findObjectById(objectId));
2577 }
2578 
2579 void InspectorDOMAgent::pushNodeByPathToFrontend(ErrorString&amp; errorString, const String&amp; path, int* nodeId)
2580 {
2581     if (Node* node = nodeForPath(path))
<span class="line-modified">2582         *nodeId = pushNodePathToFrontend(node);</span>
2583     else
2584         errorString = &quot;Missing node for given path&quot;_s;
2585 }
2586 
2587 RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; InspectorDOMAgent::resolveNode(Node* node, const String&amp; objectGroup)
2588 {
2589     Document* document = &amp;node-&gt;document();
2590     if (auto* templateHost = document-&gt;templateDocumentHost())
2591         document = templateHost;
2592     auto* frame =  document-&gt;frame();
2593     if (!frame)
2594         return nullptr;
2595 
2596     auto&amp; state = *mainWorldExecState(frame);
2597     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
2598     if (injectedScript.hasNoValue())
2599         return nullptr;
2600 
2601     return injectedScript.wrapObject(nodeAsScriptValue(state, node), objectGroup);
2602 }
2603 
2604 Node* InspectorDOMAgent::scriptValueAsNode(JSC::JSValue value)
2605 {
2606     if (!value || !value.isObject())
2607         return nullptr;
2608     return JSNode::toWrapped(value.getObject()-&gt;vm(), value.getObject());
2609 }
2610 
<span class="line-modified">2611 JSC::JSValue InspectorDOMAgent::nodeAsScriptValue(JSC::ExecState&amp; state, Node* node)</span>
2612 {
2613     JSC::JSLockHolder lock(&amp;state);
2614     return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), BindingSecurity::checkSecurityForNode(state, node));
2615 }
2616 





2617 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
  20  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  21  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  22  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
  23  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  24  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  25  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  26  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  28  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29  */
  30 
  31 #include &quot;config.h&quot;
  32 #include &quot;InspectorDOMAgent.h&quot;
  33 
  34 #include &quot;AXObjectCache.h&quot;
  35 #include &quot;AccessibilityNodeObject.h&quot;
  36 #include &quot;Attr.h&quot;
  37 #include &quot;CSSComputedStyleDeclaration.h&quot;
<span class="line-added">  38 #include &quot;CSSParser.h&quot;</span>
  39 #include &quot;CSSPropertyNames.h&quot;
  40 #include &quot;CSSPropertySourceData.h&quot;
  41 #include &quot;CSSRule.h&quot;
  42 #include &quot;CSSRuleList.h&quot;
<span class="line-added">  43 #include &quot;CSSSelector.h&quot;</span>
<span class="line-added">  44 #include &quot;CSSSelectorList.h&quot;</span>
  45 #include &quot;CSSStyleRule.h&quot;
  46 #include &quot;CSSStyleSheet.h&quot;
  47 #include &quot;CharacterData.h&quot;
  48 #include &quot;CommandLineAPIHost.h&quot;
<span class="line-added">  49 #include &quot;ComposedTreeIterator.h&quot;</span>
  50 #include &quot;ContainerNode.h&quot;
  51 #include &quot;Cookie.h&quot;
  52 #include &quot;CookieJar.h&quot;
  53 #include &quot;DOMEditor.h&quot;
  54 #include &quot;DOMException.h&quot;
  55 #include &quot;DOMPatchSupport.h&quot;
  56 #include &quot;DOMWindow.h&quot;
  57 #include &quot;Document.h&quot;
  58 #include &quot;DocumentType.h&quot;
  59 #include &quot;Editing.h&quot;
  60 #include &quot;Element.h&quot;
  61 #include &quot;Event.h&quot;
  62 #include &quot;EventListener.h&quot;
  63 #include &quot;EventNames.h&quot;
  64 #include &quot;Frame.h&quot;
  65 #include &quot;FrameTree.h&quot;
  66 #include &quot;FrameView.h&quot;
  67 #include &quot;FullscreenManager.h&quot;
  68 #include &quot;HTMLElement.h&quot;
  69 #include &quot;HTMLFrameOwnerElement.h&quot;
</pre>
<hr />
<pre>
  79 #include &quot;InspectorClient.h&quot;
  80 #include &quot;InspectorController.h&quot;
  81 #include &quot;InspectorHistory.h&quot;
  82 #include &quot;InspectorNodeFinder.h&quot;
  83 #include &quot;InspectorOverlay.h&quot;
  84 #include &quot;InspectorPageAgent.h&quot;
  85 #include &quot;InstrumentingAgents.h&quot;
  86 #include &quot;IntRect.h&quot;
  87 #include &quot;JSDOMBindingSecurity.h&quot;
  88 #include &quot;JSEventListener.h&quot;
  89 #include &quot;JSNode.h&quot;
  90 #include &quot;MutationEvent.h&quot;
  91 #include &quot;Node.h&quot;
  92 #include &quot;NodeList.h&quot;
  93 #include &quot;Page.h&quot;
  94 #include &quot;Pasteboard.h&quot;
  95 #include &quot;PseudoElement.h&quot;
  96 #include &quot;RenderStyle.h&quot;
  97 #include &quot;RenderStyleConstants.h&quot;
  98 #include &quot;ScriptState.h&quot;
<span class="line-added">  99 #include &quot;SelectorChecker.h&quot;</span>
 100 #include &quot;ShadowRoot.h&quot;
 101 #include &quot;StaticNodeList.h&quot;
 102 #include &quot;StyleProperties.h&quot;
 103 #include &quot;StyleResolver.h&quot;
 104 #include &quot;StyleSheetList.h&quot;
 105 #include &quot;Text.h&quot;
 106 #include &quot;TextNodeTraversal.h&quot;
 107 #include &quot;Timer.h&quot;
 108 #include &quot;VideoPlaybackQuality.h&quot;
 109 #include &quot;WebInjectedScriptManager.h&quot;
 110 #include &quot;XPathResult.h&quot;
 111 #include &quot;markup.h&quot;
 112 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 113 #include &lt;JavaScriptCore/InjectedScript.h&gt;
 114 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
 115 #include &lt;JavaScriptCore/JSCInlines.h&gt;
 116 #include &lt;pal/crypto/CryptoDigest.h&gt;
<span class="line-added"> 117 #include &lt;wtf/Function.h&gt;</span>
 118 #include &lt;wtf/text/Base64.h&gt;
 119 #include &lt;wtf/text/CString.h&gt;
 120 #include &lt;wtf/text/WTFString.h&gt;
 121 
 122 namespace WebCore {
 123 
 124 using namespace Inspector;
 125 
 126 using namespace HTMLNames;
 127 
 128 static const size_t maxTextSize = 10000;
 129 static const UChar ellipsisUChar[] = { 0x2026, 0 };
 130 
 131 static Color parseColor(const JSON::Object* colorObject)
 132 {
 133     if (!colorObject)
 134         return Color::transparent;
 135 
 136     int r = 0;
 137     int g = 0;
</pre>
<hr />
<pre>
 206 }
 207 
 208 void RevalidateStyleAttributeTask::timerFired()
 209 {
 210     // The timer is stopped on m_domAgent destruction, so this method will never be called after m_domAgent has been destroyed.
 211     Vector&lt;Element*&gt; elements;
 212     for (auto&amp; element : m_elements)
 213         elements.append(element.get());
 214     m_domAgent-&gt;styleAttributeInvalidated(elements);
 215 
 216     m_elements.clear();
 217 }
 218 
 219 class InspectableNode final : public CommandLineAPIHost::InspectableObject {
 220 public:
 221     explicit InspectableNode(Node* node)
 222         : m_node(node)
 223     {
 224     }
 225 
<span class="line-modified"> 226     JSC::JSValue get(JSC::JSGlobalObject&amp; state) final</span>
 227     {
 228         return InspectorDOMAgent::nodeAsScriptValue(state, m_node.get());
 229     }
 230 private:
 231     RefPtr&lt;Node&gt; m_node;
 232 };
 233 
 234 class EventFiredCallback final : public EventListener {
 235 public:
 236     static Ref&lt;EventFiredCallback&gt; create(InspectorDOMAgent&amp; domAgent)
 237     {
 238         return adoptRef(*new EventFiredCallback(domAgent));
 239     }
 240 
 241     bool operator==(const EventListener&amp; other) const final
 242     {
 243         return this == &amp;other;
 244     }
 245 
 246     void handleEvent(ScriptExecutionContext&amp;, Event&amp; event) final
</pre>
<hr />
<pre>
 450     return downcast&lt;Document&gt;(node);
 451 }
 452 
 453 Element* InspectorDOMAgent::assertElement(ErrorString&amp; errorString, int nodeId)
 454 {
 455     Node* node = assertNode(errorString, nodeId);
 456     if (!node)
 457         return nullptr;
 458     if (!is&lt;Element&gt;(node)) {
 459         errorString = &quot;Node for given nodeId is not an element&quot;_s;
 460         return nullptr;
 461     }
 462     return downcast&lt;Element&gt;(node);
 463 }
 464 
 465 Node* InspectorDOMAgent::assertEditableNode(ErrorString&amp; errorString, int nodeId)
 466 {
 467     Node* node = assertNode(errorString, nodeId);
 468     if (!node)
 469         return nullptr;
<span class="line-modified"> 470     if (node-&gt;isInUserAgentShadowTree() &amp;&amp; !m_allowEditingUserAgentShadowTrees) {</span>
 471         errorString = &quot;Node for given nodeId is in a shadow tree&quot;_s;
 472         return nullptr;
 473     }
 474     if (node-&gt;isPseudoElement()) {
 475         errorString = &quot;Node for given nodeId is a pseudo-element&quot;_s;
 476         return nullptr;
 477     }
 478     return node;
 479 }
 480 
 481 Element* InspectorDOMAgent::assertEditableElement(ErrorString&amp; errorString, int nodeId)
 482 {
 483     Node* node = assertEditableNode(errorString, nodeId);
 484     if (!node)
 485         return nullptr;
 486     if (!is&lt;Element&gt;(node)) {
 487         errorString = &quot;Node for given nodeId is not an element&quot;_s;
 488         return nullptr;
 489     }
 490     return downcast&lt;Element&gt;(node);
</pre>
<hr />
<pre>
 530             pushChildNodesToFrontend(childNodeId, depth);
 531         }
 532 
 533         return;
 534     }
 535 
 536     auto children = buildArrayForContainerChildren(node, depth, nodeMap);
 537     m_frontendDispatcher-&gt;setChildNodes(nodeId, WTFMove(children));
 538 }
 539 
 540 void InspectorDOMAgent::discardBindings()
 541 {
 542     m_documentNodeToIdMap.clear();
 543     m_idToNode.clear();
 544     m_dispatchedEvents.clear();
 545     m_eventListenerEntries.clear();
 546     releaseDanglingNodes();
 547     m_childrenRequested.clear();
 548 }
 549 
<span class="line-added"> 550 int InspectorDOMAgent::pushNodeToFrontend(Node* nodeToPush)</span>
<span class="line-added"> 551 {</span>
<span class="line-added"> 552     if (!nodeToPush)</span>
<span class="line-added"> 553         return 0;</span>
<span class="line-added"> 554 </span>
<span class="line-added"> 555     ErrorString ignored;</span>
<span class="line-added"> 556     return pushNodeToFrontend(ignored, boundNodeId(&amp;nodeToPush-&gt;document()), nodeToPush);</span>
<span class="line-added"> 557 }</span>
<span class="line-added"> 558 </span>
 559 int InspectorDOMAgent::pushNodeToFrontend(ErrorString&amp; errorString, int documentNodeId, Node* nodeToPush)
 560 {
 561     Document* document = assertDocument(errorString, documentNodeId);
 562     if (!document)
 563         return 0;
 564     if (&amp;nodeToPush-&gt;document() != document) {
 565         errorString = &quot;nodeToPush is not part of the document with given documentNodeId&quot;_s;
 566         return 0;
 567     }
 568 
<span class="line-modified"> 569     return pushNodePathToFrontend(errorString, nodeToPush);</span>
 570 }
 571 
 572 Node* InspectorDOMAgent::nodeForId(int id)
 573 {
 574     if (!m_idToNode.isValidKey(id))
 575         return nullptr;
 576 
 577     return m_idToNode.get(id);
 578 }
 579 
 580 void InspectorDOMAgent::requestChildNodes(ErrorString&amp; errorString, int nodeId, const int* depth)
 581 {
 582     int sanitizedDepth;
 583 
 584     if (!depth)
 585         sanitizedDepth = 1;
 586     else if (*depth == -1)
 587         sanitizedDepth = INT_MAX;
 588     else if (*depth &gt; 0)
 589         sanitizedDepth = *depth;
</pre>
<hr />
<pre>
 596 }
 597 
 598 void InspectorDOMAgent::querySelector(ErrorString&amp; errorString, int nodeId, const String&amp; selectors, int* elementId)
 599 {
 600     *elementId = 0;
 601     Node* node = assertNode(errorString, nodeId);
 602     if (!node)
 603         return;
 604     if (!is&lt;ContainerNode&gt;(*node)) {
 605         assertElement(errorString, nodeId);
 606         return;
 607     }
 608 
 609     auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelector(selectors);
 610     if (queryResult.hasException()) {
 611         errorString = &quot;DOM Error while querying with given selectors&quot;_s;
 612         return;
 613     }
 614 
 615     if (auto* element = queryResult.releaseReturnValue())
<span class="line-modified"> 616         *elementId = pushNodePathToFrontend(errorString, element);</span>
 617 }
 618 
 619 void InspectorDOMAgent::querySelectorAll(ErrorString&amp; errorString, int nodeId, const String&amp; selectors, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; result)
 620 {
 621     Node* node = assertNode(errorString, nodeId);
 622     if (!node)
 623         return;
 624     if (!is&lt;ContainerNode&gt;(*node)) {
 625         assertElement(errorString, nodeId);
 626         return;
 627     }
 628 
 629     auto queryResult = downcast&lt;ContainerNode&gt;(*node).querySelectorAll(selectors);
 630     if (queryResult.hasException()) {
 631         errorString = &quot;DOM Error while querying with given selectors&quot;_s;
 632         return;
 633     }
 634 
 635     auto nodes = queryResult.releaseReturnValue();
 636     result = JSON::ArrayOf&lt;int&gt;::create();
 637     for (unsigned i = 0; i &lt; nodes-&gt;length(); ++i)
 638         result-&gt;addItem(pushNodePathToFrontend(nodes-&gt;item(i)));
 639 }
 640 
 641 int InspectorDOMAgent::pushNodePathToFrontend(Node* nodeToPush)
<span class="line-added"> 642 {</span>
<span class="line-added"> 643     ErrorString ignored;</span>
<span class="line-added"> 644     return pushNodePathToFrontend(ignored, nodeToPush);</span>
<span class="line-added"> 645 }</span>
<span class="line-added"> 646 </span>
<span class="line-added"> 647 int InspectorDOMAgent::pushNodePathToFrontend(ErrorString errorString, Node* nodeToPush)</span>
 648 {
 649     ASSERT(nodeToPush);  // Invalid input
 650 
<span class="line-modified"> 651     if (!m_document) {</span>
<span class="line-added"> 652         errorString = &quot;Missing document&quot;_s;</span>
 653         return 0;
<span class="line-modified"> 654     }</span>
<span class="line-added"> 655 </span>
<span class="line-added"> 656     if (!m_documentNodeToIdMap.contains(m_document)) {</span>
<span class="line-added"> 657         errorString = &quot;Document must have been requested&quot;_s;</span>
 658         return 0;
<span class="line-added"> 659     }</span>
 660 
 661     // Return id in case the node is known.
 662     int result = m_documentNodeToIdMap.get(nodeToPush);
 663     if (result)
 664         return result;
 665 
 666     Node* node = nodeToPush;
 667     Vector&lt;Node*&gt; path;
 668     NodeToIdMap* danglingMap = 0;
 669 
 670     while (true) {
 671         Node* parent = innerParentNode(node);
 672         if (!parent) {
 673             // Node being pushed is detached -&gt; push subtree root.
 674             auto newMap = makeUnique&lt;NodeToIdMap&gt;();
 675             danglingMap = newMap.get();
 676             m_danglingNodeToIdMaps.append(newMap.release());
 677             auto children = JSON::ArrayOf&lt;Inspector::Protocol::DOM::Node&gt;::create();
 678             children-&gt;addItem(buildObjectForNode(node, 0, danglingMap));
 679             m_frontendDispatcher-&gt;setChildNodes(0, WTFMove(children));
</pre>
<hr />
<pre>
 784         return;
 785     auto newElement = createElementResult.releaseReturnValue();
 786 
 787     // Copy over the original node&#39;s attributes.
 788     newElement-&gt;cloneAttributesFromElement(downcast&lt;Element&gt;(*oldNode));
 789 
 790     // Copy over the original node&#39;s children.
 791     RefPtr&lt;Node&gt; child;
 792     while ((child = oldNode-&gt;firstChild())) {
 793         if (!m_domEditor-&gt;insertBefore(newElement, *child, 0, errorString))
 794             return;
 795     }
 796 
 797     // Replace the old node with the new node
 798     RefPtr&lt;ContainerNode&gt; parent = oldNode-&gt;parentNode();
 799     if (!m_domEditor-&gt;insertBefore(*parent, newElement.copyRef(), oldNode-&gt;nextSibling(), errorString))
 800         return;
 801     if (!m_domEditor-&gt;removeChild(*parent, *oldNode, errorString))
 802         return;
 803 
<span class="line-modified"> 804     *newId = pushNodePathToFrontend(errorString, newElement.ptr());</span>
 805     if (m_childrenRequested.contains(nodeId))
 806         pushChildNodesToFrontend(*newId);
 807 }
 808 
 809 void InspectorDOMAgent::getOuterHTML(ErrorString&amp; errorString, int nodeId, WTF::String* outerHTML)
 810 {
 811     Node* node = assertNode(errorString, nodeId);
 812     if (!node)
 813         return;
 814 
 815     *outerHTML = serializeFragment(*node, SerializedNodes::SubtreeIncludingNode);
 816 }
 817 
 818 void InspectorDOMAgent::setOuterHTML(ErrorString&amp; errorString, int nodeId, const String&amp; outerHTML)
 819 {
 820     if (!nodeId) {
 821         DOMPatchSupport { *m_domEditor, *m_document }.patchDocument(outerHTML);
 822         return;
 823     }
 824 
 825     Node* node = assertEditableNode(errorString, nodeId);
 826     if (!node)
 827         return;
 828 
 829     Document&amp; document = node-&gt;document();
 830     if (!document.isHTMLDocument() &amp;&amp; !document.isXMLDocument()) {
 831         errorString = &quot;Document of node for given nodeId is not HTML/XML&quot;_s;
 832         return;
 833     }
 834 
 835     Node* newNode = nullptr;
 836     if (!m_domEditor-&gt;setOuterHTML(*node, outerHTML, newNode, errorString))
 837         return;
 838 
 839     if (!newNode) {
 840         // The only child node has been deleted.
 841         return;
 842     }
 843 
<span class="line-modified"> 844     int newId = pushNodePathToFrontend(errorString, newNode);</span>
 845 
 846     bool childrenRequested = m_childrenRequested.contains(nodeId);
 847     if (childrenRequested)
 848         pushChildNodesToFrontend(newId);
 849 }
 850 
 851 void InspectorDOMAgent::insertAdjacentHTML(ErrorString&amp; errorString, int nodeId, const String&amp; position, const String&amp; html)
 852 {
 853     Node* node = assertEditableNode(errorString, nodeId);
 854     if (!node)
 855         return;
 856 
 857     if (!is&lt;Element&gt;(node)) {
 858         errorString = &quot;Node for given nodeId is not an element&quot;_s;
 859         return;
 860     }
 861 
 862     m_domEditor-&gt;insertAdjacentHTML(downcast&lt;Element&gt;(*node), position, html, errorString);
 863 }
 864 
</pre>
<hr />
<pre>
1121     if (!m_nodeToFocus)
1122         return;
1123 
1124     focusNode();
1125 }
1126 
1127 void InspectorDOMAgent::focusNode()
1128 {
1129     if (!m_documentRequested)
1130         return;
1131 
1132     ASSERT(m_nodeToFocus);
1133 
1134     RefPtr&lt;Node&gt; node = m_nodeToFocus.get();
1135     m_nodeToFocus = nullptr;
1136 
1137     Frame* frame = node-&gt;document().frame();
1138     if (!frame)
1139         return;
1140 
<span class="line-modified">1141     JSC::JSGlobalObject* scriptState = mainWorldExecState(frame);</span>
1142     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptFor(scriptState);
1143     if (injectedScript.hasNoValue())
1144         return;
1145 
1146     injectedScript.inspectObject(nodeAsScriptValue(*scriptState, node.get()));
1147 }
1148 
1149 void InspectorDOMAgent::mouseDidMoveOverElement(const HitTestResult&amp; result, unsigned)
1150 {
1151     m_mousedOverNode = result.innerNode();
1152 
1153     if (!m_searchingForNode)
1154         return;
1155 
1156     highlightMousedOverNode();
1157 }
1158 
1159 void InspectorDOMAgent::highlightMousedOverNode()
1160 {
1161     Node* node = m_mousedOverNode.get();
</pre>
<hr />
<pre>
1222 {
1223     auto quad = makeUnique&lt;FloatQuad&gt;();
1224     if (!parseQuad(quadArray, quad.get())) {
1225         errorString = &quot;Unexpected invalid quadArray&quot;_s;
1226         return;
1227     }
1228     innerHighlightQuad(WTFMove(quad), color, outlineColor, usePageCoordinates);
1229 }
1230 
1231 void InspectorDOMAgent::innerHighlightQuad(std::unique_ptr&lt;FloatQuad&gt; quad, const JSON::Object* color, const JSON::Object* outlineColor, const bool* usePageCoordinates)
1232 {
1233     auto highlightConfig = makeUnique&lt;HighlightConfig&gt;();
1234     highlightConfig-&gt;content = parseColor(color);
1235     highlightConfig-&gt;contentOutline = parseColor(outlineColor);
1236     highlightConfig-&gt;usePageCoordinates = usePageCoordinates ? *usePageCoordinates : false;
1237     m_overlay-&gt;highlightQuad(WTFMove(quad), *highlightConfig);
1238 }
1239 
1240 void InspectorDOMAgent::highlightSelector(ErrorString&amp; errorString, const JSON::Object&amp; highlightInspectorObject, const String&amp; selectorString, const String* frameId)
1241 {
<span class="line-added">1242     auto highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);</span>
<span class="line-added">1243     if (!highlightConfig)</span>
<span class="line-added">1244         return;</span>
<span class="line-added">1245 </span>
1246     RefPtr&lt;Document&gt; document;
1247 
1248     if (frameId) {
1249         auto* pageAgent = m_instrumentingAgents.inspectorPageAgent();
1250         if (!pageAgent) {
1251             errorString = &quot;Page domain must be enabled&quot;_s;
1252             return;
1253         }
1254 
1255         auto* frame = pageAgent-&gt;assertFrame(errorString, *frameId);
1256         if (!frame)
1257             return;
1258 
1259         document = frame-&gt;document();
1260     } else
1261         document = m_document;
1262 
1263     if (!document) {
1264         errorString = &quot;Missing document of frame for given frameId&quot;_s;
1265         return;
1266     }
1267 
<span class="line-modified">1268     CSSParser parser(*document);</span>
<span class="line-modified">1269     CSSSelectorList selectorList;</span>
<span class="line-modified">1270     parser.parseSelector(selectorString, selectorList);</span>



1271 
<span class="line-modified">1272     SelectorChecker selectorChecker(*document);</span>


1273 
<span class="line-modified">1274     Vector&lt;Ref&lt;Node&gt;&gt; nodeList;</span>
<span class="line-added">1275     HashSet&lt;Node*&gt; seenNodes;</span>
<span class="line-added">1276 </span>
<span class="line-added">1277     for (auto&amp; descendant : composedTreeDescendants(*document)) {</span>
<span class="line-added">1278         if (!is&lt;Element&gt;(descendant))</span>
<span class="line-added">1279             continue;</span>
<span class="line-added">1280 </span>
<span class="line-added">1281         auto&amp; descendantElement = downcast&lt;Element&gt;(descendant);</span>
<span class="line-added">1282 </span>
<span class="line-added">1283         auto isInUserAgentShadowTree = descendantElement.isInUserAgentShadowTree();</span>
<span class="line-added">1284         auto pseudoId = descendantElement.pseudoId();</span>
<span class="line-added">1285         auto&amp; pseudo = descendantElement.pseudo();</span>
<span class="line-added">1286 </span>
<span class="line-added">1287         for (const auto* selector = selectorList.first(); selector; selector = CSSSelectorList::next(selector)) {</span>
<span class="line-added">1288             if (isInUserAgentShadowTree &amp;&amp; (selector-&gt;match() != CSSSelector::PseudoElement || selector-&gt;value() != pseudo))</span>
<span class="line-added">1289                 continue;</span>
<span class="line-added">1290 </span>
<span class="line-added">1291             SelectorChecker::CheckingContext context(SelectorChecker::Mode::ResolvingStyle);</span>
<span class="line-added">1292             context.pseudoId = pseudoId;</span>
<span class="line-added">1293 </span>
<span class="line-added">1294             unsigned ignoredSpecificity;</span>
<span class="line-added">1295             if (selectorChecker.match(*selector, descendantElement, context, ignoredSpecificity)) {</span>
<span class="line-added">1296                 if (seenNodes.add(&amp;descendantElement))</span>
<span class="line-added">1297                     nodeList.append(descendantElement);</span>
<span class="line-added">1298             }</span>
<span class="line-added">1299 </span>
<span class="line-added">1300             if (context.pseudoIDSet) {</span>
<span class="line-added">1301                 auto pseudoIDs = PseudoIdSet::fromMask(context.pseudoIDSet.data());</span>
<span class="line-added">1302 </span>
<span class="line-added">1303                 if (pseudoIDs.has(PseudoId::Before)) {</span>
<span class="line-added">1304                     pseudoIDs.remove(PseudoId::Before);</span>
<span class="line-added">1305                     if (auto* beforePseudoElement = descendantElement.beforePseudoElement()) {</span>
<span class="line-added">1306                         if (seenNodes.add(beforePseudoElement))</span>
<span class="line-added">1307                             nodeList.append(*beforePseudoElement);</span>
<span class="line-added">1308                     }</span>
<span class="line-added">1309                 }</span>
<span class="line-added">1310 </span>
<span class="line-added">1311                 if (pseudoIDs.has(PseudoId::After)) {</span>
<span class="line-added">1312                     pseudoIDs.remove(PseudoId::After);</span>
<span class="line-added">1313                     if (auto* afterPseudoElement = descendantElement.afterPseudoElement()) {</span>
<span class="line-added">1314                         if (seenNodes.add(afterPseudoElement))</span>
<span class="line-added">1315                             nodeList.append(*afterPseudoElement);</span>
<span class="line-added">1316                     }</span>
<span class="line-added">1317                 }</span>
<span class="line-added">1318 </span>
<span class="line-added">1319                 if (pseudoIDs) {</span>
<span class="line-added">1320                     if (seenNodes.add(&amp;descendantElement))</span>
<span class="line-added">1321                         nodeList.append(descendantElement);</span>
<span class="line-added">1322                 }</span>
<span class="line-added">1323             }</span>
<span class="line-added">1324         }</span>
<span class="line-added">1325     }</span>
<span class="line-added">1326 </span>
<span class="line-added">1327     m_overlay-&gt;highlightNodeList(StaticNodeList::create(WTFMove(nodeList)), *highlightConfig);</span>
1328 }
1329 
1330 void InspectorDOMAgent::highlightNode(ErrorString&amp; errorString, const JSON::Object&amp; highlightInspectorObject, const int* nodeId, const String* objectId)
1331 {
1332     Node* node = nullptr;
1333     if (nodeId)
1334         node = assertNode(errorString, *nodeId);
1335     else if (objectId) {
1336         node = nodeForObjectId(*objectId);
1337         if (!node)
1338             errorString = &quot;Missing node for given objectId&quot;_s;
1339     } else
1340         errorString = &quot;Either nodeId or objectId must be specified&quot;_s;
1341 
1342     if (!node)
1343         return;
1344 
1345     std::unique_ptr&lt;HighlightConfig&gt; highlightConfig = highlightConfigFromInspectorObject(errorString, &amp;highlightInspectorObject);
1346     if (!highlightConfig)
1347         return;
</pre>
<hr />
<pre>
1416         return;
1417 
1418     Element* targetElement = assertEditableElement(errorString, targetElementId);
1419     if (!targetElement)
1420         return;
1421 
1422     Node* anchorNode = 0;
1423     if (anchorNodeId &amp;&amp; *anchorNodeId) {
1424         anchorNode = assertEditableNode(errorString, *anchorNodeId);
1425         if (!anchorNode)
1426             return;
1427         if (anchorNode-&gt;parentNode() != targetElement) {
1428             errorString = &quot;Given anchorNodeId must be a child of given targetElementId&quot;_s;
1429             return;
1430         }
1431     }
1432 
1433     if (!m_domEditor-&gt;insertBefore(*targetElement, *node, anchorNode, errorString))
1434         return;
1435 
<span class="line-modified">1436     *newNodeId = pushNodePathToFrontend(errorString, node);</span>
1437 }
1438 
1439 void InspectorDOMAgent::undo(ErrorString&amp; errorString)
1440 {
1441     auto result = m_history-&gt;undo();
1442     if (result.hasException())
1443         errorString = toErrorString(result.releaseException());
1444 }
1445 
1446 void InspectorDOMAgent::redo(ErrorString&amp; errorString)
1447 {
1448     auto result = m_history-&gt;redo();
1449     if (result.hasException())
1450         errorString = toErrorString(result.releaseException());
1451 }
1452 
1453 void InspectorDOMAgent::markUndoableState(ErrorString&amp;)
1454 {
1455     m_history-&gt;markUndoableState();
1456 }
1457 
1458 void InspectorDOMAgent::focus(ErrorString&amp; errorString, int nodeId)
1459 {
1460     Element* element = assertElement(errorString, nodeId);
1461     if (!element)
1462         return;
1463     if (!element-&gt;isFocusable()) {
1464         errorString = &quot;Element for given nodeId is not focusable&quot;_s;
1465         return;
1466     }
1467     element-&gt;focus();
1468 }
1469 
1470 void InspectorDOMAgent::setInspectedNode(ErrorString&amp; errorString, int nodeId)
1471 {
1472     Node* node = assertNode(errorString, nodeId);
1473     if (!node)
1474         return;
1475 
<span class="line-modified">1476     if (node-&gt;isInUserAgentShadowTree() &amp;&amp; !m_allowEditingUserAgentShadowTrees) {</span>
1477         errorString = &quot;Node for given nodeId is in a shadow tree&quot;_s;
1478         return;
1479     }
1480 
1481     m_inspectedNode = node;
1482 
1483     if (auto&amp; commandLineAPIHost = static_cast&lt;WebInjectedScriptManager&amp;&gt;(m_injectedScriptManager).commandLineAPIHost())
1484         commandLineAPIHost-&gt;addInspectedObject(makeUnique&lt;InspectableNode&gt;(node));
1485 
1486     m_suppressEventListenerChangedEvent = false;
1487 }
1488 
1489 void InspectorDOMAgent::resolveNode(ErrorString&amp; errorString, int nodeId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)
1490 {
1491     String objectGroupName = objectGroup ? *objectGroup : emptyString();
1492     Node* node = assertNode(errorString, nodeId);
1493     if (!node)
1494         return;
1495     RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; object = resolveNode(node, objectGroupName);
1496     if (!object) {
1497         errorString = &quot;Missing injected script for given nodeId&quot;_s;
1498         return;
1499     }
1500     result = object;
1501 }
1502 
1503 void InspectorDOMAgent::getAttributes(ErrorString&amp; errorString, int nodeId, RefPtr&lt;JSON::ArrayOf&lt;String&gt;&gt;&amp; result)
1504 {
1505     Element* element = assertElement(errorString, nodeId);
1506     if (!element)
1507         return;
1508 
1509     result = buildArrayForElementAttributes(element);
1510 }
1511 
<span class="line-modified">1512 void InspectorDOMAgent::requestNode(ErrorString&amp; errorString, const String&amp; objectId, int* nodeId)</span>
1513 {
1514     Node* node = nodeForObjectId(objectId);
1515     if (node)
<span class="line-modified">1516         *nodeId = pushNodePathToFrontend(errorString, node);</span>
1517     else
1518         *nodeId = 0;
1519 }
1520 
1521 String InspectorDOMAgent::documentURLString(Document* document)
1522 {
1523     if (!document || document-&gt;url().isNull())
1524         return emptyString();
1525     return document-&gt;url().string();
1526 }
1527 
1528 static String documentBaseURLString(Document* document)
1529 {
1530     return document-&gt;completeURL(emptyString()).string();
1531 }
1532 
1533 static bool pseudoElementType(PseudoId pseudoId, Inspector::Protocol::DOM::PseudoType* type)
1534 {
1535     switch (pseudoId) {
1536     case PseudoId::Before:
</pre>
<hr />
<pre>
1748 
1749 Ref&lt;Inspector::Protocol::DOM::EventListener&gt; InspectorDOMAgent::buildObjectForEventListener(const RegisteredEventListener&amp; registeredEventListener, int identifier, EventTarget&amp; eventTarget, const AtomString&amp; eventType, bool disabled, bool hasBreakpoint)
1750 {
1751     Ref&lt;EventListener&gt; eventListener = registeredEventListener.callback();
1752 
1753     String handlerName;
1754     int lineNumber = 0;
1755     int columnNumber = 0;
1756     String scriptID;
1757     if (is&lt;JSEventListener&gt;(eventListener.get())) {
1758         auto&amp; scriptListener = downcast&lt;JSEventListener&gt;(eventListener.get());
1759 
1760         Document* document = nullptr;
1761         if (auto* scriptExecutionContext = eventTarget.scriptExecutionContext()) {
1762             if (is&lt;Document&gt;(scriptExecutionContext))
1763                 document = downcast&lt;Document&gt;(scriptExecutionContext);
1764         } else if (is&lt;Node&gt;(eventTarget))
1765             document = &amp;downcast&lt;Node&gt;(eventTarget).document();
1766 
1767         JSC::JSObject* handlerObject = nullptr;
<span class="line-modified">1768         JSC::JSGlobalObject* exec = nullptr;</span>
1769 
1770         JSC::JSLockHolder lock(scriptListener.isolatedWorld().vm());
1771 
1772         if (document) {
1773             handlerObject = scriptListener.jsFunction(*document);
1774             exec = execStateFromNode(scriptListener.isolatedWorld(), document);
1775         }
1776 
1777         if (handlerObject &amp;&amp; exec) {
1778             JSC::VM&amp; vm = exec-&gt;vm();
1779             JSC::JSFunction* handlerFunction = JSC::jsDynamicCast&lt;JSC::JSFunction*&gt;(vm, handlerObject);
1780 
1781             if (!handlerFunction) {
1782                 auto scope = DECLARE_CATCH_SCOPE(vm);
1783 
1784                 // If the handler is not actually a function, see if it implements the EventListener interface and use that.
1785                 auto handleEventValue = handlerObject-&gt;get(exec, JSC::Identifier::fromString(vm, &quot;handleEvent&quot;));
1786 
1787                 if (UNLIKELY(scope.exception()))
1788                     scope.clearException();
</pre>
<hr />
<pre>
1822         auto location = Inspector::Protocol::Debugger::Location::create()
1823             .setScriptId(scriptID)
1824             .setLineNumber(lineNumber)
1825             .release();
1826         location-&gt;setColumnNumber(columnNumber);
1827         value-&gt;setLocation(WTFMove(location));
1828     }
1829     if (!handlerName.isEmpty())
1830         value-&gt;setHandlerName(handlerName);
1831     if (registeredEventListener.isPassive())
1832         value-&gt;setPassive(true);
1833     if (registeredEventListener.isOnce())
1834         value-&gt;setOnce(true);
1835     if (disabled)
1836         value-&gt;setDisabled(disabled);
1837     if (hasBreakpoint)
1838         value-&gt;setHasBreakpoint(hasBreakpoint);
1839     return value;
1840 }
1841 
<span class="line-modified">1842 void InspectorDOMAgent::processAccessibilityChildren(AXCoreObject&amp; axObject, JSON::ArrayOf&lt;int&gt;&amp; childNodeIds)</span>
1843 {
1844     const auto&amp; children = axObject.children();
1845     if (!children.size())
1846         return;
1847 
1848     for (const auto&amp; childObject : children) {
1849         if (Node* childNode = childObject-&gt;node())
1850             childNodeIds.addItem(pushNodePathToFrontend(childNode));
1851         else
1852             processAccessibilityChildren(*childObject, childNodeIds);
1853     }
1854 }
1855 
1856 RefPtr&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt; InspectorDOMAgent::buildObjectForAccessibilityProperties(Node* node)
1857 {
1858     ASSERT(node);
1859     if (!node)
1860         return nullptr;
1861 
1862     if (!WebCore::AXObjectCache::accessibilityEnabled())
</pre>
<hr />
<pre>
1885     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; ownedNodeIds;
1886     Node* parentNode = nullptr;
1887     bool pressed = false;
1888     bool readonly = false;
1889     bool required = false;
1890     String role;
1891     bool selected = false;
1892     RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt; selectedChildNodeIds;
1893     bool supportsChecked = false;
1894     bool supportsExpanded = false;
1895     bool supportsLiveRegion = false;
1896     bool supportsPressed = false;
1897     bool supportsRequired = false;
1898     bool supportsFocused = false;
1899     bool isPopupButton = false;
1900     int headingLevel = 0;
1901     unsigned hierarchicalLevel = 0;
1902     unsigned level = 0;
1903 
1904     if (AXObjectCache* axObjectCache = node-&gt;document().axObjectCache()) {
<span class="line-modified">1905         if (AXCoreObject* axObject = axObjectCache-&gt;getOrCreate(node)) {</span>
1906 
<span class="line-modified">1907             if (AXCoreObject* activeDescendant = axObject-&gt;activeDescendant())</span>
1908                 activeDescendantNode = activeDescendant-&gt;node();
1909 
1910             // An AX object is &quot;busy&quot; if it or any ancestor has aria-busy=&quot;true&quot; set.
<span class="line-modified">1911             AXCoreObject* current = axObject;</span>
1912             while (!busy &amp;&amp; current) {
1913                 busy = current-&gt;isBusy();
1914                 current = current-&gt;parentObject();
1915             }
1916 
1917             supportsChecked = axObject-&gt;supportsChecked();
1918             if (supportsChecked) {
1919                 AccessibilityButtonState checkValue = axObject-&gt;checkboxOrRadioValue(); // Element using aria-checked.
1920                 if (checkValue == AccessibilityButtonState::On)
1921                     checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::True;
1922                 else if (checkValue == AccessibilityButtonState::Mixed)
1923                     checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::Mixed;
1924                 else if (axObject-&gt;isChecked()) // Native checkbox.
1925                     checked = Inspector::Protocol::DOM::AccessibilityProperties::Checked::True;
1926             }
1927 
1928             if (!axObject-&gt;children().isEmpty()) {
1929                 childNodeIds = JSON::ArrayOf&lt;int&gt;::create();
1930                 processAccessibilityChildren(*axObject, *childNodeIds);
1931             }
</pre>
<hr />
<pre>
2032                 String ariaLive = axObject-&gt;liveRegionStatus();
2033                 if (ariaLive == &quot;assertive&quot;)
2034                     liveRegionStatus = Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus::Assertive;
2035                 else if (ariaLive == &quot;polite&quot;)
2036                     liveRegionStatus = Inspector::Protocol::DOM::AccessibilityProperties::LiveRegionStatus::Polite;
2037             }
2038 
2039             if (is&lt;AccessibilityNodeObject&gt;(*axObject))
2040                 mouseEventNode = downcast&lt;AccessibilityNodeObject&gt;(*axObject).mouseButtonListener(MouseButtonListenerResultFilter::IncludeBodyElement);
2041 
2042             if (axObject-&gt;supportsARIAOwns()) {
2043                 Vector&lt;Element*&gt; ownedElements;
2044                 axObject-&gt;elementsFromAttribute(ownedElements, aria_ownsAttr);
2045                 if (ownedElements.size()) {
2046                     ownedNodeIds = JSON::ArrayOf&lt;int&gt;::create();
2047                     for (Element* ownedElement : ownedElements)
2048                         ownedNodeIds-&gt;addItem(pushNodePathToFrontend(ownedElement));
2049                 }
2050             }
2051 
<span class="line-modified">2052             if (AXCoreObject* parentObject = axObject-&gt;parentObjectUnignored())</span>
2053                 parentNode = parentObject-&gt;node();
2054 
2055             supportsPressed = axObject-&gt;pressedIsPresent();
2056             if (supportsPressed)
2057                 pressed = axObject-&gt;isPressed();
2058 
2059             if (axObject-&gt;isTextControl())
2060                 readonly = !axObject-&gt;canSetValueAttribute();
2061 
2062             supportsRequired = axObject-&gt;supportsRequiredAttribute();
2063             if (supportsRequired)
2064                 required = axObject-&gt;isRequired();
2065 
2066             role = axObject-&gt;computedRoleString();
2067             selected = axObject-&gt;isSelected();
2068 
<span class="line-modified">2069             AXCoreObject::AccessibilityChildrenVector selectedChildren;</span>
2070             axObject-&gt;selectedChildren(selectedChildren);
2071             if (selectedChildren.size()) {
2072                 selectedChildNodeIds = JSON::ArrayOf&lt;int&gt;::create();
2073                 for (auto&amp; selectedChildObject : selectedChildren) {
2074                     if (Node* selectedChildNode = selectedChildObject-&gt;node())
2075                         selectedChildNodeIds-&gt;addItem(pushNodePathToFrontend(selectedChildNode));
2076                 }
2077             }
2078 
2079             headingLevel = axObject-&gt;headingLevel();
2080             hierarchicalLevel = axObject-&gt;hierarchicalLevel();
2081 
2082             level = hierarchicalLevel ? hierarchicalLevel : headingLevel;
2083             isPopupButton = axObject-&gt;isPopUpButton() || axObject-&gt;hasPopup();
2084         }
2085     }
2086 
2087     Ref&lt;Inspector::Protocol::DOM::AccessibilityProperties&gt; value = Inspector::Protocol::DOM::AccessibilityProperties::create()
2088         .setExists(exists)
2089         .setLabel(label)
</pre>
<hr />
<pre>
2640         const auto&amp; childName = pathTokens[i + 1];
2641         if (!child || child-&gt;nodeName() != childName)
2642             return nullptr;
2643         node = child;
2644     }
2645     return node;
2646 }
2647 
2648 Node* InspectorDOMAgent::nodeForObjectId(const String&amp; objectId)
2649 {
2650     InjectedScript injectedScript = m_injectedScriptManager.injectedScriptForObjectId(objectId);
2651     if (injectedScript.hasNoValue())
2652         return nullptr;
2653 
2654     return scriptValueAsNode(injectedScript.findObjectById(objectId));
2655 }
2656 
2657 void InspectorDOMAgent::pushNodeByPathToFrontend(ErrorString&amp; errorString, const String&amp; path, int* nodeId)
2658 {
2659     if (Node* node = nodeForPath(path))
<span class="line-modified">2660         *nodeId = pushNodePathToFrontend(errorString, node);</span>
2661     else
2662         errorString = &quot;Missing node for given path&quot;_s;
2663 }
2664 
2665 RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt; InspectorDOMAgent::resolveNode(Node* node, const String&amp; objectGroup)
2666 {
2667     Document* document = &amp;node-&gt;document();
2668     if (auto* templateHost = document-&gt;templateDocumentHost())
2669         document = templateHost;
2670     auto* frame =  document-&gt;frame();
2671     if (!frame)
2672         return nullptr;
2673 
2674     auto&amp; state = *mainWorldExecState(frame);
2675     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);
2676     if (injectedScript.hasNoValue())
2677         return nullptr;
2678 
2679     return injectedScript.wrapObject(nodeAsScriptValue(state, node), objectGroup);
2680 }
2681 
2682 Node* InspectorDOMAgent::scriptValueAsNode(JSC::JSValue value)
2683 {
2684     if (!value || !value.isObject())
2685         return nullptr;
2686     return JSNode::toWrapped(value.getObject()-&gt;vm(), value.getObject());
2687 }
2688 
<span class="line-modified">2689 JSC::JSValue InspectorDOMAgent::nodeAsScriptValue(JSC::JSGlobalObject&amp; state, Node* node)</span>
2690 {
2691     JSC::JSLockHolder lock(&amp;state);
2692     return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), BindingSecurity::checkSecurityForNode(state, node));
2693 }
2694 
<span class="line-added">2695 void InspectorDOMAgent::setAllowEditingUserAgentShadowTrees(ErrorString&amp;, bool allow)</span>
<span class="line-added">2696 {</span>
<span class="line-added">2697     m_allowEditingUserAgentShadowTrees = allow;</span>
<span class="line-added">2698 }</span>
<span class="line-added">2699 </span>
2700 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="InspectorCanvasAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorDOMAgent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/Page.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2006-2019 Apple Inc. All rights reserved.
   3  * Copyright (C) 2008 Torch Mobile Inc. All rights reserved. (http://www.torchmobile.com/)
   4  *
   5  * This library is free software; you can redistribute it and/or
   6  * modify it under the terms of the GNU Library General Public
   7  * License as published by the Free Software Foundation; either
   8  * version 2 of the License, or (at your option) any later version.
   9  * This library is distributed in the hope that it will be useful,
  10  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  11  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  12  * Library General Public License for more details.
  13  *
  14  * You should have received a copy of the GNU Library General Public License
  15  * along with this library; see the file COPYING.LIB.  If not, write to
  16  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  17  * Boston, MA 02110-1301, USA.
  18  */
  19 
  20 #include &quot;config.h&quot;
  21 #include &quot;Page.h&quot;
  22 
  23 #include &quot;ActivityStateChangeObserver.h&quot;
  24 #include &quot;AlternativeTextClient.h&quot;
  25 #include &quot;ApplicationCacheStorage.h&quot;
  26 #include &quot;AuthenticatorCoordinator.h&quot;
  27 #include &quot;BackForwardCache.h&quot;
  28 #include &quot;BackForwardClient.h&quot;
  29 #include &quot;BackForwardController.h&quot;
  30 #include &quot;CSSAnimationController.h&quot;
  31 #include &quot;CacheStorageProvider.h&quot;
  32 #include &quot;Chrome.h&quot;
  33 #include &quot;ChromeClient.h&quot;
  34 #include &quot;ConstantPropertyMap.h&quot;
  35 #include &quot;ContextMenuClient.h&quot;
  36 #include &quot;ContextMenuController.h&quot;
  37 #include &quot;CookieJar.h&quot;
  38 #include &quot;CustomHeaderFields.h&quot;
  39 #include &quot;DOMRect.h&quot;
  40 #include &quot;DOMRectList.h&quot;
  41 #include &quot;DatabaseProvider.h&quot;
  42 #include &quot;DiagnosticLoggingClient.h&quot;
  43 #include &quot;DiagnosticLoggingKeys.h&quot;
  44 #include &quot;DocumentLoader.h&quot;
  45 #include &quot;DocumentMarkerController.h&quot;
  46 #include &quot;DocumentTimeline.h&quot;
  47 #include &quot;DragController.h&quot;
  48 #include &quot;Editing.h&quot;
  49 #include &quot;Editor.h&quot;
  50 #include &quot;EditorClient.h&quot;
  51 #include &quot;EmptyClients.h&quot;
  52 #include &quot;Event.h&quot;
  53 #include &quot;EventNames.h&quot;
  54 #include &quot;ExtensionStyleSheets.h&quot;
  55 #include &quot;FocusController.h&quot;
  56 #include &quot;FrameLoader.h&quot;
  57 #include &quot;FrameLoaderClient.h&quot;
  58 #include &quot;FrameSelection.h&quot;
  59 #include &quot;FrameTree.h&quot;
  60 #include &quot;FrameView.h&quot;
  61 #include &quot;FullscreenManager.h&quot;
  62 #include &quot;HTMLElement.h&quot;
  63 #include &quot;HTMLMediaElement.h&quot;
  64 #include &quot;HTMLTextAreaElement.h&quot;
  65 #include &quot;HTMLTextFormControlElement.h&quot;
  66 #include &quot;HistoryController.h&quot;
  67 #include &quot;HistoryItem.h&quot;
  68 #include &quot;InspectorClient.h&quot;
  69 #include &quot;InspectorController.h&quot;
  70 #include &quot;InspectorInstrumentation.h&quot;
  71 #include &quot;LegacySchemeRegistry.h&quot;
  72 #include &quot;LibWebRTCProvider.h&quot;
  73 #include &quot;LoaderStrategy.h&quot;
  74 #include &quot;Logging.h&quot;
  75 #include &quot;LowPowerModeNotifier.h&quot;
  76 #include &quot;MediaCanStartListener.h&quot;
  77 #include &quot;MediaRecorderProvider.h&quot;
  78 #include &quot;Navigator.h&quot;
  79 #include &quot;PageConfiguration.h&quot;
  80 #include &quot;PageConsoleClient.h&quot;
  81 #include &quot;PageDebuggable.h&quot;
  82 #include &quot;PageGroup.h&quot;
  83 #include &quot;PageOverlayController.h&quot;
  84 #include &quot;PaymentCoordinator.h&quot;
  85 #include &quot;PerformanceLogging.h&quot;
  86 #include &quot;PerformanceLoggingClient.h&quot;
  87 #include &quot;PerformanceMonitor.h&quot;
  88 #include &quot;PlatformMediaSessionManager.h&quot;
  89 #include &quot;PlatformStrategies.h&quot;
  90 #include &quot;PlugInClient.h&quot;
  91 #include &quot;PluginData.h&quot;
  92 #include &quot;PluginInfoProvider.h&quot;
  93 #include &quot;PluginViewBase.h&quot;
  94 #include &quot;PointerCaptureController.h&quot;
  95 #include &quot;PointerLockController.h&quot;
  96 #include &quot;ProgressTracker.h&quot;
  97 #include &quot;RenderDescendantIterator.h&quot;
  98 #include &quot;RenderLayerCompositor.h&quot;
  99 #include &quot;RenderTheme.h&quot;
 100 #include &quot;RenderView.h&quot;
 101 #include &quot;RenderWidget.h&quot;
 102 #include &quot;ResizeObserver.h&quot;
 103 #include &quot;ResourceUsageOverlay.h&quot;
 104 #include &quot;RuntimeEnabledFeatures.h&quot;
 105 #include &quot;SVGDocumentExtensions.h&quot;
 106 #include &quot;ScriptController.h&quot;
 107 #include &quot;ScriptedAnimationController.h&quot;
 108 #include &quot;ScrollLatchingState.h&quot;
 109 #include &quot;ScrollingCoordinator.h&quot;
 110 #include &quot;Settings.h&quot;
 111 #include &quot;SharedBuffer.h&quot;
 112 #include &quot;SocketProvider.h&quot;
 113 #include &quot;StorageArea.h&quot;
 114 #include &quot;StorageNamespace.h&quot;
 115 #include &quot;StorageNamespaceProvider.h&quot;
 116 #include &quot;StyleAdjuster.h&quot;
 117 #include &quot;StyleResolver.h&quot;
 118 #include &quot;StyleScope.h&quot;
 119 #include &quot;SubframeLoader.h&quot;
 120 #include &quot;TextIterator.h&quot;
 121 #include &quot;TextResourceDecoder.h&quot;
 122 #include &quot;UserContentProvider.h&quot;
 123 #include &quot;UserContentURLPattern.h&quot;
 124 #include &quot;UserInputBridge.h&quot;
 125 #include &quot;ValidationMessageClient.h&quot;
 126 #include &quot;VisitedLinkState.h&quot;
 127 #include &quot;VisitedLinkStore.h&quot;
 128 #include &quot;VoidCallback.h&quot;
 129 #include &quot;WheelEventDeltaFilter.h&quot;
 130 #include &quot;Widget.h&quot;
 131 #include &lt;wtf/Deque.h&gt;
 132 #include &lt;wtf/FileSystem.h&gt;
 133 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 134 #include &lt;wtf/StdLibExtras.h&gt;
 135 #include &lt;wtf/SystemTracing.h&gt;
 136 #include &lt;wtf/text/Base64.h&gt;
 137 #include &lt;wtf/text/StringHash.h&gt;
 138 
 139 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 140 #include &quot;HTMLVideoElement.h&quot;
 141 #include &quot;MediaPlaybackTarget.h&quot;
 142 #endif
 143 
 144 #if PLATFORM(MAC)
 145 #include &quot;ServicesOverlayController.h&quot;
 146 #endif
 147 
 148 #if ENABLE(MEDIA_SESSION)
 149 #include &quot;MediaSessionManager.h&quot;
 150 #endif
 151 
 152 #if ENABLE(INDEXED_DATABASE)
 153 #include &quot;IDBConnectionToServer.h&quot;
 154 #endif
 155 
 156 #if ENABLE(WEBGL)
 157 #include &quot;WebGLStateTracker.h&quot;
 158 #endif
 159 
 160 namespace WebCore {
 161 
 162 static HashSet&lt;Page*&gt;&amp; allPages()
 163 {
 164     static NeverDestroyed&lt;HashSet&lt;Page*&gt;&gt; set;
 165     return set;
 166 }
 167 
 168 static unsigned nonUtilityPageCount { 0 };
 169 
 170 static inline bool isUtilityPageChromeClient(ChromeClient&amp; chromeClient)
 171 {
 172     return chromeClient.isEmptyChromeClient() || chromeClient.isSVGImageChromeClient();
 173 }
 174 
 175 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, pageCounter, (&quot;Page&quot;));
 176 
 177 void Page::forEachPage(const WTF::Function&lt;void(Page&amp;)&gt;&amp; function)
 178 {
 179     for (auto* page : allPages())
 180         function(*page);
 181 }
 182 
 183 void Page::updateValidationBubbleStateIfNeeded()
 184 {
 185     if (auto* client = validationMessageClient())
 186         client-&gt;updateValidationBubbleStateIfNeeded();
 187 }
 188 
 189 static void networkStateChanged(bool isOnLine)
 190 {
 191     Vector&lt;Ref&lt;Frame&gt;&gt; frames;
 192 
 193     // Get all the frames of all the pages in all the page groups
 194     for (auto* page : allPages()) {
 195         for (Frame* frame = &amp;page-&gt;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
 196             frames.append(*frame);
 197         InspectorInstrumentation::networkStateChanged(*page);
 198     }
 199 
 200     auto&amp; eventName = isOnLine ? eventNames().onlineEvent : eventNames().offlineEvent;
 201     for (auto&amp; frame : frames) {
 202         if (!frame-&gt;document())
 203             continue;
 204         frame-&gt;document()-&gt;dispatchWindowEvent(Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::No));
 205     }
 206 }
 207 
 208 static constexpr OptionSet&lt;ActivityState::Flag&gt; pageInitialActivityState()
 209 {
 210     return { ActivityState::IsVisible, ActivityState::IsInWindow };
 211 }
 212 
 213 Page::Page(PageConfiguration&amp;&amp; pageConfiguration)
 214     : m_chrome(makeUnique&lt;Chrome&gt;(*this, *pageConfiguration.chromeClient))
 215     , m_dragCaretController(makeUnique&lt;DragCaretController&gt;())
 216 #if ENABLE(DRAG_SUPPORT)
 217     , m_dragController(makeUnique&lt;DragController&gt;(*this, WTFMove(pageConfiguration.dragClient)))
 218 #endif
 219     , m_focusController(makeUnique&lt;FocusController&gt;(*this, pageInitialActivityState()))
 220 #if ENABLE(CONTEXT_MENUS)
 221     , m_contextMenuController(makeUnique&lt;ContextMenuController&gt;(*this, *pageConfiguration.contextMenuClient))
 222 #endif
 223     , m_userInputBridge(makeUnique&lt;UserInputBridge&gt;(*this))
 224     , m_inspectorController(makeUnique&lt;InspectorController&gt;(*this, pageConfiguration.inspectorClient))
 225 #if ENABLE(POINTER_EVENTS)
 226     , m_pointerCaptureController(makeUnique&lt;PointerCaptureController&gt;(*this))
 227 #endif
 228 #if ENABLE(POINTER_LOCK)
 229     , m_pointerLockController(makeUnique&lt;PointerLockController&gt;(*this))
 230 #endif
 231     , m_settings(Settings::create(this))
 232     , m_progress(makeUnique&lt;ProgressTracker&gt;(WTFMove(pageConfiguration.progressTrackerClient)))
 233     , m_backForwardController(makeUnique&lt;BackForwardController&gt;(*this, WTFMove(pageConfiguration.backForwardClient)))
 234     , m_mainFrame(Frame::create(this, nullptr, pageConfiguration.loaderClientForMainFrame))
 235     , m_editorClient(WTFMove(pageConfiguration.editorClient))
 236     , m_plugInClient(WTFMove(pageConfiguration.plugInClient))
 237     , m_validationMessageClient(WTFMove(pageConfiguration.validationMessageClient))
 238     , m_diagnosticLoggingClient(WTFMove(pageConfiguration.diagnosticLoggingClient))
 239     , m_performanceLoggingClient(WTFMove(pageConfiguration.performanceLoggingClient))
 240 #if ENABLE(WEBGL)
 241     , m_webGLStateTracker(WTFMove(pageConfiguration.webGLStateTracker))
 242 #endif
 243 #if ENABLE(SPEECH_SYNTHESIS)
 244     , m_speechSynthesisClient(WTFMove(pageConfiguration.speechSynthesisClient))
 245 #endif
 246     , m_mediaRecorderProvider((WTFMove(pageConfiguration.mediaRecorderProvider)))
 247     , m_libWebRTCProvider(WTFMove(pageConfiguration.libWebRTCProvider))
 248     , m_verticalScrollElasticity(ScrollElasticityAllowed)
 249     , m_horizontalScrollElasticity(ScrollElasticityAllowed)
 250     , m_domTimerAlignmentInterval(DOMTimer::defaultAlignmentInterval())
 251     , m_domTimerAlignmentIntervalIncreaseTimer(*this, &amp;Page::domTimerAlignmentIntervalIncreaseTimerFired)
 252     , m_activityState(pageInitialActivityState())
 253     , m_alternativeTextClient(WTFMove(pageConfiguration.alternativeTextClient))
 254     , m_consoleClient(makeUnique&lt;PageConsoleClient&gt;(*this))
 255 #if ENABLE(REMOTE_INSPECTOR)
 256     , m_inspectorDebuggable(makeUnique&lt;PageDebuggable&gt;(*this))
 257 #endif
 258     , m_socketProvider(WTFMove(pageConfiguration.socketProvider))
 259     , m_cookieJar(WTFMove(pageConfiguration.cookieJar))
 260     , m_applicationCacheStorage(*WTFMove(pageConfiguration.applicationCacheStorage))
 261     , m_cacheStorageProvider(WTFMove(pageConfiguration.cacheStorageProvider))
 262     , m_databaseProvider(*WTFMove(pageConfiguration.databaseProvider))
 263     , m_pluginInfoProvider(*WTFMove(pageConfiguration.pluginInfoProvider))
 264     , m_storageNamespaceProvider(*WTFMove(pageConfiguration.storageNamespaceProvider))
 265     , m_userContentProvider(*WTFMove(pageConfiguration.userContentProvider))
 266     , m_visitedLinkStore(*WTFMove(pageConfiguration.visitedLinkStore))
 267     , m_sessionID(pageConfiguration.sessionID)
 268 #if ENABLE(VIDEO)
 269     , m_playbackControlsManagerUpdateTimer(*this, &amp;Page::playbackControlsManagerUpdateTimerFired)
 270 #endif
 271     , m_isUtilityPage(isUtilityPageChromeClient(chrome().client()))
 272     , m_performanceMonitor(isUtilityPage() ? nullptr : makeUnique&lt;PerformanceMonitor&gt;(*this))
 273     , m_lowPowerModeNotifier(makeUnique&lt;LowPowerModeNotifier&gt;([this](bool isLowPowerModeEnabled) { handleLowModePowerChange(isLowPowerModeEnabled); }))
 274     , m_performanceLogging(makeUnique&lt;PerformanceLogging&gt;(*this))
 275 #if PLATFORM(MAC) &amp;&amp; (ENABLE(SERVICE_CONTROLS) || ENABLE(TELEPHONE_NUMBER_DETECTION))
 276     , m_servicesOverlayController(makeUnique&lt;ServicesOverlayController&gt;(*this))
 277 #endif
 278     , m_recentWheelEventDeltaFilter(WheelEventDeltaFilter::create())
 279     , m_pageOverlayController(makeUnique&lt;PageOverlayController&gt;(*this))
 280 #if ENABLE(APPLE_PAY)
 281     , m_paymentCoordinator(makeUnique&lt;PaymentCoordinator&gt;(*pageConfiguration.paymentCoordinatorClient))
 282 #endif
 283 #if ENABLE(WEB_AUTHN)
 284     , m_authenticatorCoordinator(makeUniqueRef&lt;AuthenticatorCoordinator&gt;(WTFMove(pageConfiguration.authenticatorCoordinatorClient)))
 285 #endif
 286 #if ENABLE(APPLICATION_MANIFEST)
 287     , m_applicationManifest(pageConfiguration.applicationManifest)
 288 #endif
 289 #if ENABLE(DEVICE_ORIENTATION) &amp;&amp; PLATFORM(IOS_FAMILY)
 290     , m_deviceOrientationUpdateProvider(WTFMove(pageConfiguration.deviceOrientationUpdateProvider))
 291 #endif
 292 {
 293     updateTimerThrottlingState();
 294 
 295     m_pluginInfoProvider-&gt;addPage(*this);
 296     m_userContentProvider-&gt;addPage(*this);
 297     m_visitedLinkStore-&gt;addPage(*this);
 298 
 299     static bool addedListener;
 300     if (!addedListener) {
 301         platformStrategies()-&gt;loaderStrategy()-&gt;addOnlineStateChangeListener(&amp;networkStateChanged);
 302         addedListener = true;
 303     }
 304 
 305     ASSERT(!allPages().contains(this));
 306     allPages().add(this);
 307 
 308     if (!isUtilityPage()) {
 309         ++nonUtilityPageCount;
 310         MemoryPressureHandler::setPageCount(nonUtilityPageCount);
 311     }
 312 
 313 #ifndef NDEBUG
 314     pageCounter.increment();
 315 #endif
 316 
 317 #if ENABLE(REMOTE_INSPECTOR)
 318     if (m_inspectorController-&gt;inspectorClient() &amp;&amp; m_inspectorController-&gt;inspectorClient()-&gt;allowRemoteInspectionToPageDirectly())
 319         m_inspectorDebuggable-&gt;init();
 320 #endif
 321 
 322 #if PLATFORM(COCOA)
 323     platformInitialize();
 324 #endif
 325 
 326 #if USE(LIBWEBRTC)
 327     m_libWebRTCProvider-&gt;supportsVP8(RuntimeEnabledFeatures::sharedFeatures().webRTCVP8CodecEnabled());
 328 #endif
 329 
 330     m_corsDisablingPatterns.reserveInitialCapacity(pageConfiguration.corsDisablingPatterns.size());
 331     for (auto&amp;&amp; pattern : WTFMove(pageConfiguration.corsDisablingPatterns)) {
 332         UserContentURLPattern parsedPattern(WTFMove(pattern));
 333         if (parsedPattern.isValid())
 334             m_corsDisablingPatterns.uncheckedAppend(WTFMove(parsedPattern));
 335     }
 336     m_corsDisablingPatterns.shrinkToFit();
 337 }
 338 
 339 Page::~Page()
 340 {
 341     ASSERT(!m_nestedRunLoopCount);
 342     ASSERT(!m_unnestCallback);
 343 
 344     m_validationMessageClient = nullptr;
 345     m_diagnosticLoggingClient = nullptr;
 346     m_performanceLoggingClient = nullptr;
 347     m_mainFrame-&gt;setView(nullptr);
 348     setGroupName(String());
 349     allPages().remove(this);
 350     if (!isUtilityPage()) {
 351         --nonUtilityPageCount;
 352         MemoryPressureHandler::setPageCount(nonUtilityPageCount);
 353     }
 354 
 355     m_settings-&gt;pageDestroyed();
 356 
 357     m_inspectorController-&gt;inspectedPageDestroyed();
 358 
 359     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
 360         frame-&gt;willDetachPage();
 361         frame-&gt;detachFromPage();
 362     }
 363 
 364     if (m_scrollingCoordinator)
 365         m_scrollingCoordinator-&gt;pageDestroyed();
 366 
 367     backForward().close();
 368     if (!isUtilityPage())
 369         BackForwardCache::singleton().removeAllItemsForPage(*this);
 370 
 371 #ifndef NDEBUG
 372     pageCounter.decrement();
 373 #endif
 374 
 375     m_pluginInfoProvider-&gt;removePage(*this);
 376     m_userContentProvider-&gt;removePage(*this);
 377     m_visitedLinkStore-&gt;removePage(*this);
 378 }
 379 
 380 void Page::clearPreviousItemFromAllPages(HistoryItem* item)
 381 {
 382     for (auto* page : allPages()) {
 383         auto&amp; controller = page-&gt;mainFrame().loader().history();
 384         if (item == controller.previousItem()) {
 385             controller.clearPreviousItem();
 386             return;
 387         }
 388     }
 389 }
 390 
 391 uint64_t Page::renderTreeSize() const
 392 {
 393     uint64_t total = 0;
 394     forEachDocument([&amp;] (Document&amp; document) {
 395         if (auto* renderView = document.renderView())
 396             total += renderView-&gt;rendererCount();
 397     });
 398     return total;
 399 }
 400 
 401 OptionSet&lt;DisabledAdaptations&gt; Page::disabledAdaptations() const
 402 {
 403     if (mainFrame().document())
 404         return mainFrame().document()-&gt;disabledAdaptations();
 405 
 406     return { };
 407 }
 408 
 409 ViewportArguments Page::viewportArguments() const
 410 {
 411     return mainFrame().document() ? mainFrame().document()-&gt;viewportArguments() : ViewportArguments();
 412 }
 413 
 414 void Page::setOverrideViewportArguments(const Optional&lt;ViewportArguments&gt;&amp; viewportArguments)
 415 {
 416     if (viewportArguments == m_overrideViewportArguments)
 417         return;
 418 
 419     m_overrideViewportArguments = viewportArguments;
 420     if (auto* document = mainFrame().document())
 421         document-&gt;updateViewportArguments();
 422 }
 423 
 424 ScrollingCoordinator* Page::scrollingCoordinator()
 425 {
 426     if (!m_scrollingCoordinator &amp;&amp; m_settings-&gt;scrollingCoordinatorEnabled()) {
 427         m_scrollingCoordinator = chrome().client().createScrollingCoordinator(*this);
 428         if (!m_scrollingCoordinator)
 429             m_scrollingCoordinator = ScrollingCoordinator::create(this);
 430     }
 431 
 432     return m_scrollingCoordinator.get();
 433 }
 434 
 435 String Page::scrollingStateTreeAsText()
 436 {
 437     if (Document* document = m_mainFrame-&gt;document())
 438         document-&gt;updateLayout();
 439 
 440     if (ScrollingCoordinator* scrollingCoordinator = this-&gt;scrollingCoordinator())
 441         return scrollingCoordinator-&gt;scrollingStateTreeAsText();
 442 
 443     return String();
 444 }
 445 
 446 String Page::synchronousScrollingReasonsAsText()
 447 {
 448     if (Document* document = m_mainFrame-&gt;document())
 449         document-&gt;updateLayout();
 450 
 451     if (ScrollingCoordinator* scrollingCoordinator = this-&gt;scrollingCoordinator())
 452         return scrollingCoordinator-&gt;synchronousScrollingReasonsAsText();
 453 
 454     return String();
 455 }
 456 
 457 Ref&lt;DOMRectList&gt; Page::nonFastScrollableRects()
 458 {
 459     if (Document* document = m_mainFrame-&gt;document())
 460         document-&gt;updateLayout();
 461 
 462     Vector&lt;IntRect&gt; rects;
 463     if (ScrollingCoordinator* scrollingCoordinator = this-&gt;scrollingCoordinator()) {
 464         const EventTrackingRegions&amp; eventTrackingRegions = scrollingCoordinator-&gt;absoluteEventTrackingRegions();
 465         for (const auto&amp; synchronousEventRegion : eventTrackingRegions.eventSpecificSynchronousDispatchRegions)
 466             rects.appendVector(synchronousEventRegion.value.rects());
 467     }
 468 
 469     Vector&lt;FloatQuad&gt; quads(rects.size());
 470     for (size_t i = 0; i &lt; rects.size(); ++i)
 471         quads[i] = FloatRect(rects[i]);
 472 
 473     return DOMRectList::create(quads);
 474 }
 475 
 476 Ref&lt;DOMRectList&gt; Page::touchEventRectsForEvent(const String&amp; eventName)
 477 {
 478     if (Document* document = m_mainFrame-&gt;document()) {
 479         document-&gt;updateLayout();
 480 #if ENABLE(IOS_TOUCH_EVENTS)
 481         document-&gt;updateTouchEventRegions();
 482 #endif
 483     }
 484 
 485     Vector&lt;IntRect&gt; rects;
 486     if (ScrollingCoordinator* scrollingCoordinator = this-&gt;scrollingCoordinator()) {
 487         const EventTrackingRegions&amp; eventTrackingRegions = scrollingCoordinator-&gt;absoluteEventTrackingRegions();
 488         const auto&amp; region = eventTrackingRegions.eventSpecificSynchronousDispatchRegions.get(eventName);
 489         rects.appendVector(region.rects());
 490     }
 491 
 492     Vector&lt;FloatQuad&gt; quads(rects.size());
 493     for (size_t i = 0; i &lt; rects.size(); ++i)
 494         quads[i] = FloatRect(rects[i]);
 495 
 496     return DOMRectList::create(quads);
 497 }
 498 
 499 Ref&lt;DOMRectList&gt; Page::passiveTouchEventListenerRects()
 500 {
 501     if (Document* document = m_mainFrame-&gt;document()) {
 502         document-&gt;updateLayout();
 503 #if ENABLE(IOS_TOUCH_EVENTS)
 504         document-&gt;updateTouchEventRegions();
 505 #endif
 506     }
 507 
 508     Vector&lt;IntRect&gt; rects;
 509     if (ScrollingCoordinator* scrollingCoordinator = this-&gt;scrollingCoordinator())
 510         rects.appendVector(scrollingCoordinator-&gt;absoluteEventTrackingRegions().asynchronousDispatchRegion.rects());
 511 
 512     Vector&lt;FloatQuad&gt; quads(rects.size());
 513     for (size_t i = 0; i &lt; rects.size(); ++i)
 514         quads[i] = FloatRect(rects[i]);
 515 
 516     return DOMRectList::create(quads);
 517 }
 518 
 519 bool Page::openedByDOM() const
 520 {
 521     return m_openedByDOM;
 522 }
 523 
 524 void Page::setOpenedByDOM()
 525 {
 526     m_openedByDOM = true;
 527 }
 528 
 529 void Page::goToItem(HistoryItem&amp; item, FrameLoadType type, ShouldTreatAsContinuingLoad shouldTreatAsContinuingLoad)
 530 {
 531     // stopAllLoaders may end up running onload handlers, which could cause further history traversals that may lead to the passed in HistoryItem
 532     // being deref()-ed. Make sure we can still use it with HistoryController::goToItem later.
 533     Ref&lt;HistoryItem&gt; protector(item);
 534 
 535     auto&amp; frameLoader = m_mainFrame-&gt;loader();
 536     if (frameLoader.history().shouldStopLoadingForHistoryItem(item))
 537         m_mainFrame-&gt;loader().stopAllLoadersAndCheckCompleteness();
 538 
 539     m_mainFrame-&gt;loader().history().goToItem(item, type, shouldTreatAsContinuingLoad);
 540 }
 541 
 542 void Page::setGroupName(const String&amp; name)
 543 {
 544     if (m_group &amp;&amp; !m_group-&gt;name().isEmpty()) {
 545         ASSERT(m_group != m_singlePageGroup.get());
 546         ASSERT(!m_singlePageGroup);
 547         m_group-&gt;removePage(*this);
 548     }
 549 
 550     if (name.isEmpty())
 551         m_group = m_singlePageGroup.get();
 552     else {
 553         m_singlePageGroup = nullptr;
 554         m_group = PageGroup::pageGroup(name);
 555         m_group-&gt;addPage(*this);
 556     }
 557 }
 558 
 559 const String&amp; Page::groupName() const
 560 {
 561     return m_group ? m_group-&gt;name() : nullAtom().string();
 562 }
 563 
 564 void Page::initGroup()
 565 {
 566     ASSERT(!m_singlePageGroup);
 567     ASSERT(!m_group);
 568     m_singlePageGroup = makeUnique&lt;PageGroup&gt;(*this);
 569     m_group = m_singlePageGroup.get();
 570 }
 571 
 572 void Page::updateStyleAfterChangeInEnvironment()
 573 {
 574     forEachDocument([] (Document&amp; document) {
 575         if (auto* styleResolver = document.styleScope().resolverIfExists())
 576             styleResolver-&gt;invalidateMatchedDeclarationsCache();
 577         document.scheduleFullStyleRebuild();
 578         document.styleScope().didChangeStyleSheetEnvironment();
 579         document.scheduleTimedRenderingUpdate();
 580     });
 581 }
 582 
 583 void Page::updateStyleForAllPagesAfterGlobalChangeInEnvironment()
 584 {
 585     for (auto* page : allPages())
 586         page-&gt;updateStyleAfterChangeInEnvironment();
 587 }
 588 
 589 void Page::setNeedsRecalcStyleInAllFrames()
 590 {
 591     // FIXME: Figure out what this function is actually trying to add in different call sites.
 592     forEachDocument([] (Document&amp; document) {
 593         document.styleScope().didChangeStyleSheetEnvironment();
 594     });
 595 }
 596 
 597 void Page::refreshPlugins(bool reload)
 598 {
 599     HashSet&lt;PluginInfoProvider*&gt; pluginInfoProviders;
 600 
 601     for (auto* page : allPages())
 602         pluginInfoProviders.add(&amp;page-&gt;pluginInfoProvider());
 603 
 604     for (auto&amp; pluginInfoProvider : pluginInfoProviders)
 605         pluginInfoProvider-&gt;refresh(reload);
 606 }
 607 
 608 PluginData&amp; Page::pluginData()
 609 {
 610     if (!m_pluginData)
 611         m_pluginData = PluginData::create(*this);
 612     return *m_pluginData;
 613 }
 614 
 615 void Page::clearPluginData()
 616 {
 617     m_pluginData = nullptr;
 618 }
 619 
 620 bool Page::showAllPlugins() const
 621 {
 622     if (m_showAllPlugins)
 623         return true;
 624 
 625     if (Document* document = mainFrame().document())
 626         return document-&gt;securityOrigin().isLocal();
 627 
 628     return false;
 629 }
 630 
 631 inline Optional&lt;std::pair&lt;MediaCanStartListener&amp;, Document&amp;&gt;&gt;  Page::takeAnyMediaCanStartListener()
 632 {
 633     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
 634         if (!frame-&gt;document())
 635             continue;
 636         if (MediaCanStartListener* listener = frame-&gt;document()-&gt;takeAnyMediaCanStartListener())
 637             return { { *listener, *frame-&gt;document() } };
 638     }
 639     return WTF::nullopt;
 640 }
 641 
 642 void Page::setCanStartMedia(bool canStartMedia)
 643 {
 644     if (m_canStartMedia == canStartMedia)
 645         return;
 646 
 647     m_canStartMedia = canStartMedia;
 648 
 649     while (m_canStartMedia) {
 650         auto listener = takeAnyMediaCanStartListener();
 651         if (!listener)
 652             break;
 653         listener-&gt;first.mediaCanStart(listener-&gt;second);
 654     }
 655 }
 656 
 657 static Frame* incrementFrame(Frame* curr, bool forward, CanWrap canWrap, DidWrap* didWrap = nullptr)
 658 {
 659     return forward
 660         ? curr-&gt;tree().traverseNext(canWrap, didWrap)
 661         : curr-&gt;tree().traversePrevious(canWrap, didWrap);
 662 }
 663 
 664 bool Page::findString(const String&amp; target, FindOptions options, DidWrap* didWrap)
 665 {
 666     if (target.isEmpty())
 667         return false;
 668 
 669     CanWrap canWrap = options.contains(WrapAround) ? CanWrap::Yes : CanWrap::No;
 670     Frame* frame = &amp;focusController().focusedOrMainFrame();
 671     Frame* startFrame = frame;
 672     do {
 673         if (frame-&gt;editor().findString(target, (options - WrapAround) | StartInSelection)) {
 674             if (frame != startFrame)
 675                 startFrame-&gt;selection().clear();
 676             focusController().setFocusedFrame(frame);
 677             return true;
 678         }
 679         frame = incrementFrame(frame, !options.contains(Backwards), canWrap, didWrap);
 680     } while (frame &amp;&amp; frame != startFrame);
 681 
 682     // Search contents of startFrame, on the other side of the selection that we did earlier.
 683     // We cheat a bit and just research with wrap on
 684     if (canWrap == CanWrap::Yes &amp;&amp; !startFrame-&gt;selection().isNone()) {
 685         if (didWrap)
 686             *didWrap = DidWrap::Yes;
 687         bool found = startFrame-&gt;editor().findString(target, options | WrapAround | StartInSelection);
 688         focusController().setFocusedFrame(frame);
 689         return found;
 690     }
 691 
 692     return false;
 693 }
 694 
 695 void Page::findStringMatchingRanges(const String&amp; target, FindOptions options, int limit, Vector&lt;RefPtr&lt;Range&gt;&gt;&amp; matchRanges, int&amp; indexForSelection)
 696 {
 697     indexForSelection = 0;
 698 
 699     Frame* frame = &amp;mainFrame();
 700     Frame* frameWithSelection = nullptr;
 701     do {
 702         frame-&gt;editor().countMatchesForText(target, 0, options, limit ? (limit - matchRanges.size()) : 0, true, &amp;matchRanges);
 703         if (frame-&gt;selection().isRange())
 704             frameWithSelection = frame;
 705         frame = incrementFrame(frame, true, CanWrap::No);
 706     } while (frame);
 707 
 708     if (matchRanges.isEmpty())
 709         return;
 710 
 711     if (frameWithSelection) {
 712         indexForSelection = NoMatchAfterUserSelection;
 713         RefPtr&lt;Range&gt; selectedRange = frameWithSelection-&gt;selection().selection().firstRange();
 714         if (options.contains(Backwards)) {
 715             for (size_t i = matchRanges.size(); i &gt; 0; --i) {
 716                 auto result = selectedRange-&gt;compareBoundaryPoints(Range::END_TO_START, *matchRanges[i - 1]);
 717                 if (!result.hasException() &amp;&amp; result.releaseReturnValue() &gt; 0) {
 718                     indexForSelection = i - 1;
 719                     break;
 720                 }
 721             }
 722         } else {
 723             for (size_t i = 0, size = matchRanges.size(); i &lt; size; ++i) {
 724                 auto result = selectedRange-&gt;compareBoundaryPoints(Range::START_TO_END, *matchRanges[i]);
 725                 if (!result.hasException() &amp;&amp; result.releaseReturnValue() &lt; 0) {
 726                     indexForSelection = i;
 727                     break;
 728                 }
 729             }
 730         }
 731     } else {
 732         if (options.contains(Backwards))
 733             indexForSelection = matchRanges.size() - 1;
 734         else
 735             indexForSelection = 0;
 736     }
 737 }
 738 
 739 RefPtr&lt;Range&gt; Page::rangeOfString(const String&amp; target, Range* referenceRange, FindOptions options)
 740 {
 741     if (target.isEmpty())
 742         return nullptr;
 743 
 744     if (referenceRange &amp;&amp; referenceRange-&gt;ownerDocument().page() != this)
 745         return nullptr;
 746 
 747     CanWrap canWrap = options.contains(WrapAround) ? CanWrap::Yes : CanWrap::No;
 748     Frame* frame = referenceRange ? referenceRange-&gt;ownerDocument().frame() : &amp;mainFrame();
 749     Frame* startFrame = frame;
 750     do {
 751         if (RefPtr&lt;Range&gt; resultRange = frame-&gt;editor().rangeOfString(target, frame == startFrame ? referenceRange : 0, options - WrapAround))
 752             return resultRange;
 753 
 754         frame = incrementFrame(frame, !options.contains(Backwards), canWrap);
 755     } while (frame &amp;&amp; frame != startFrame);
 756 
 757     // Search contents of startFrame, on the other side of the reference range that we did earlier.
 758     // We cheat a bit and just search again with wrap on.
 759     if (canWrap == CanWrap::Yes &amp;&amp; referenceRange) {
 760         if (RefPtr&lt;Range&gt; resultRange = startFrame-&gt;editor().rangeOfString(target, referenceRange, options | WrapAround | StartInSelection))
 761             return resultRange;
 762     }
 763 
 764     return nullptr;
 765 }
 766 
 767 unsigned Page::findMatchesForText(const String&amp; target, FindOptions options, unsigned maxMatchCount, ShouldHighlightMatches shouldHighlightMatches, ShouldMarkMatches shouldMarkMatches)
 768 {
 769     if (target.isEmpty())
 770         return 0;
 771 
 772     unsigned matchCount = 0;
 773 
 774     Frame* frame = &amp;mainFrame();
 775     do {
 776         if (shouldMarkMatches == MarkMatches)
 777             frame-&gt;editor().setMarkedTextMatchesAreHighlighted(shouldHighlightMatches == HighlightMatches);
 778         matchCount += frame-&gt;editor().countMatchesForText(target, 0, options, maxMatchCount ? (maxMatchCount - matchCount) : 0, shouldMarkMatches == MarkMatches, 0);
 779         frame = incrementFrame(frame, true, CanWrap::No);
 780     } while (frame);
 781 
 782     return matchCount;
 783 }
 784 
 785 unsigned Page::markAllMatchesForText(const String&amp; target, FindOptions options, bool shouldHighlight, unsigned maxMatchCount)
 786 {
 787     return findMatchesForText(target, options, maxMatchCount, shouldHighlight ? HighlightMatches : DoNotHighlightMatches, MarkMatches);
 788 }
 789 
 790 unsigned Page::countFindMatches(const String&amp; target, FindOptions options, unsigned maxMatchCount)
 791 {
 792     return findMatchesForText(target, options, maxMatchCount, DoNotHighlightMatches, DoNotMarkMatches);
 793 }
 794 
 795 struct FindReplacementRange {
 796     RefPtr&lt;ContainerNode&gt; root;
 797     size_t location { notFound };
 798     size_t length { 0 };
 799 };
 800 
 801 static void replaceRanges(Page&amp; page, const Vector&lt;FindReplacementRange&gt;&amp; ranges, const String&amp; replacementText)
 802 {
 803     HashMap&lt;RefPtr&lt;ContainerNode&gt;, Vector&lt;FindReplacementRange&gt;&gt; rangesByContainerNode;
 804     for (auto&amp; range : ranges) {
 805         auto&amp; rangeList = rangesByContainerNode.ensure(range.root, [] {
 806             return Vector&lt;FindReplacementRange&gt; { };
 807         }).iterator-&gt;value;
 808 
 809         // Ensure that ranges are sorted by their end offsets, per editing container.
 810         auto endOffsetForRange = range.location + range.length;
 811         auto insertionIndex = rangeList.size();
 812         for (auto iterator = rangeList.rbegin(); iterator != rangeList.rend(); ++iterator) {
 813             auto endOffsetBeforeInsertionIndex = iterator-&gt;location + iterator-&gt;length;
 814             if (endOffsetForRange &gt;= endOffsetBeforeInsertionIndex)
 815                 break;
 816             insertionIndex--;
 817         }
 818         rangeList.insert(insertionIndex, range);
 819     }
 820 
 821     HashMap&lt;RefPtr&lt;Frame&gt;, unsigned&gt; frameToTraversalIndexMap;
 822     unsigned currentFrameTraversalIndex = 0;
 823     for (Frame* frame = &amp;page.mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
 824         frameToTraversalIndexMap.set(frame, currentFrameTraversalIndex++);
 825 
 826     // Likewise, iterate backwards (in document and frame order) through editing containers that contain text matches,
 827     // so that we&#39;re consistent with our backwards iteration behavior per editing container when replacing text.
 828     auto containerNodesInOrderOfReplacement = copyToVector(rangesByContainerNode.keys());
 829     std::sort(containerNodesInOrderOfReplacement.begin(), containerNodesInOrderOfReplacement.end(), [frameToTraversalIndexMap] (auto&amp; firstNode, auto&amp; secondNode) {
 830         if (firstNode == secondNode)
 831             return false;
 832 
 833         auto firstFrame = makeRefPtr(firstNode-&gt;document().frame());
 834         if (!firstFrame)
 835             return true;
 836 
 837         auto secondFrame = makeRefPtr(secondNode-&gt;document().frame());
 838         if (!secondFrame)
 839             return false;
 840 
 841         if (firstFrame == secondFrame) {
 842             // comparePositions is used here instead of Node::compareDocumentPosition because some editing roots may exist inside shadow roots.
 843             return comparePositions({ firstNode.get(), Position::PositionIsBeforeChildren }, { secondNode.get(), Position::PositionIsBeforeChildren }) &gt; 0;
 844         }
 845         return frameToTraversalIndexMap.get(firstFrame) &gt; frameToTraversalIndexMap.get(secondFrame);
 846     });
 847 
 848     for (auto&amp; container : containerNodesInOrderOfReplacement) {
 849         auto frame = makeRefPtr(container-&gt;document().frame());
 850         if (!frame)
 851             continue;
 852 
 853         // Iterate backwards through ranges when replacing text, such that earlier text replacements don&#39;t clobber replacement ranges later on.
 854         auto&amp; ranges = rangesByContainerNode.find(container)-&gt;value;
 855         for (auto iterator = ranges.rbegin(); iterator != ranges.rend(); ++iterator) {
 856             auto range = TextIterator::rangeFromLocationAndLength(container.get(), iterator-&gt;location, iterator-&gt;length);
 857             if (!range || range-&gt;collapsed())
 858                 continue;
 859 
 860             frame-&gt;selection().setSelectedRange(range.get(), DOWNSTREAM, FrameSelection::ShouldCloseTyping::Yes);
 861             frame-&gt;editor().replaceSelectionWithText(replacementText, Editor::SelectReplacement::Yes, Editor::SmartReplace::No, EditAction::InsertReplacement);
 862         }
 863     }
 864 }
 865 
 866 uint32_t Page::replaceRangesWithText(const Vector&lt;Ref&lt;Range&gt;&gt;&amp; rangesToReplace, const String&amp; replacementText, bool selectionOnly)
 867 {
 868     // FIXME: In the future, we should respect the `selectionOnly` flag by checking whether each range being replaced is
 869     // contained within its frame&#39;s selection.
 870     UNUSED_PARAM(selectionOnly);
 871 
 872     Vector&lt;FindReplacementRange&gt; replacementRanges;
 873     replacementRanges.reserveInitialCapacity(rangesToReplace.size());
 874 
 875     for (auto&amp; range : rangesToReplace) {
 876         auto highestRoot = makeRefPtr(highestEditableRoot(range-&gt;startPosition()));
 877         if (!highestRoot || highestRoot != highestEditableRoot(range-&gt;endPosition()))
 878             continue;
 879 
 880         auto frame = makeRefPtr(highestRoot-&gt;document().frame());
 881         if (!frame)
 882             continue;
 883 
 884         size_t replacementLocation = notFound;
 885         size_t replacementLength = 0;
 886         if (!TextIterator::getLocationAndLengthFromRange(highestRoot.get(), range.ptr(), replacementLocation, replacementLength))
 887             continue;
 888 
 889         if (replacementLocation == notFound || !replacementLength)
 890             continue;
 891 
 892         replacementRanges.append({ WTFMove(highestRoot), replacementLocation, replacementLength });
 893     }
 894 
 895     replaceRanges(*this, replacementRanges, replacementText);
 896     return rangesToReplace.size();
 897 }
 898 
 899 uint32_t Page::replaceSelectionWithText(const String&amp; replacementText)
 900 {
 901     auto frame = makeRef(focusController().focusedOrMainFrame());
 902     auto selection = frame-&gt;selection().selection();
 903     if (!selection.isContentEditable())
 904         return 0;
 905 
 906     auto editAction = selection.isRange() ? EditAction::InsertReplacement : EditAction::Insert;
 907     frame-&gt;editor().replaceSelectionWithText(replacementText, Editor::SelectReplacement::Yes, Editor::SmartReplace::No, editAction);
 908     return 1;
 909 }
 910 
 911 void Page::unmarkAllTextMatches()
 912 {
 913     forEachDocument([] (Document&amp; document) {
 914         document.markers().removeMarkers(DocumentMarker::TextMatch);
 915     });
 916 }
 917 
 918 static bool isEditableTextInputElement(const Element&amp; element)
 919 {
 920     if (is&lt;HTMLTextFormControlElement&gt;(element)) {
 921         if (!element.isTextField() &amp;&amp; !is&lt;HTMLTextAreaElement&gt;(element))
 922             return false;
 923         return downcast&lt;HTMLTextFormControlElement&gt;(element).isInnerTextElementEditable();
 924     }
 925     return element.isRootEditableElement();
 926 }
 927 
 928 Vector&lt;Ref&lt;Element&gt;&gt; Page::editableElementsInRect(const FloatRect&amp; searchRectInRootViewCoordinates) const
 929 {
 930     Vector&lt;Ref&lt;Element&gt;&gt; result;
 931     forEachDocument([&amp;] (Document&amp; document) {
 932         Deque&lt;Node*&gt; nodesToSearch;
 933         nodesToSearch.append(&amp;document);
 934         while (!nodesToSearch.isEmpty()) {
 935             auto* node = nodesToSearch.takeFirst();
 936 
 937             // It is possible to have nested text input contexts (e.g. &lt;input type=&#39;text&#39;&gt; inside contenteditable) but
 938             // in this case we just take the outermost context and skip the rest.
 939             if (!is&lt;Element&gt;(node) || !isEditableTextInputElement(downcast&lt;Element&gt;(*node))) {
 940                 for (auto* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling())
 941                     nodesToSearch.append(child);
 942                 continue;
 943             }
 944 
 945             auto&amp; element = downcast&lt;Element&gt;(*node);
 946             if (searchRectInRootViewCoordinates.intersects(element.clientRect()))
 947                 result.append(element);
 948         }
 949     });
 950     return result;
 951 }
 952 
 953 const VisibleSelection&amp; Page::selection() const
 954 {
 955     return focusController().focusedOrMainFrame().selection().selection();
 956 }
 957 
 958 void Page::setDefersLoading(bool defers)
 959 {
 960     if (!m_settings-&gt;loadDeferringEnabled())
 961         return;
 962 
 963     if (m_settings-&gt;wantsBalancedSetDefersLoadingBehavior()) {
 964         ASSERT(defers || m_defersLoadingCallCount);
 965         if (defers &amp;&amp; ++m_defersLoadingCallCount &gt; 1)
 966             return;
 967         if (!defers &amp;&amp; --m_defersLoadingCallCount)
 968             return;
 969     } else {
 970         ASSERT(!m_defersLoadingCallCount);
 971         if (defers == m_defersLoading)
 972             return;
 973     }
 974 
 975     m_defersLoading = defers;
 976     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
 977         frame-&gt;loader().setDefersLoading(defers);
 978 }
 979 
 980 void Page::clearUndoRedoOperations()
 981 {
 982     m_editorClient-&gt;clearUndoRedoOperations();
 983 }
 984 
 985 bool Page::inLowQualityImageInterpolationMode() const
 986 {
 987     return m_inLowQualityInterpolationMode;
 988 }
 989 
 990 void Page::setInLowQualityImageInterpolationMode(bool mode)
 991 {
 992     m_inLowQualityInterpolationMode = mode;
 993 }
 994 
 995 DiagnosticLoggingClient&amp; Page::diagnosticLoggingClient() const
 996 {
 997     if (!settings().diagnosticLoggingEnabled() || !m_diagnosticLoggingClient)
 998         return emptyDiagnosticLoggingClient();
 999     return *m_diagnosticLoggingClient;
1000 }
1001 
1002 void Page::setMediaVolume(float volume)
1003 {
1004     if (!(volume &gt;= 0 &amp;&amp; volume &lt;= 1))
1005         return;
1006 
1007     if (m_mediaVolume == volume)
1008         return;
1009 
1010     m_mediaVolume = volume;
1011 
1012 #if ENABLE(VIDEO)
1013     forEachMediaElement([] (HTMLMediaElement&amp; element) {
1014         element.mediaVolumeDidChange();
1015     });
1016 #endif
1017 }
1018 
1019 void Page::setZoomedOutPageScaleFactor(float scale)
1020 {
1021     if (m_zoomedOutPageScaleFactor == scale)
1022         return;
1023     m_zoomedOutPageScaleFactor = scale;
1024 
1025     mainFrame().deviceOrPageScaleFactorChanged();
1026 }
1027 
1028 void Page::setPageScaleFactor(float scale, const IntPoint&amp; origin, bool inStableState)
1029 {
1030     LOG(Viewports, &quot;Page::setPageScaleFactor %.2f - inStableState %d&quot;, scale, inStableState);
1031 
1032     Document* document = mainFrame().document();
1033     RefPtr&lt;FrameView&gt; view = document-&gt;view();
1034 
1035     if (scale == m_pageScaleFactor) {
1036         if (view &amp;&amp; view-&gt;scrollPosition() != origin &amp;&amp; !delegatesScaling())
1037             document-&gt;updateLayoutIgnorePendingStylesheets();
1038     } else {
1039         m_pageScaleFactor = scale;
1040 
1041         if (view &amp;&amp; !delegatesScaling()) {
1042             view-&gt;setNeedsLayoutAfterViewConfigurationChange();
1043             view-&gt;setNeedsCompositingGeometryUpdate();
1044 
1045             document-&gt;resolveStyle(Document::ResolveStyleType::Rebuild);
1046 
1047             // Transform change on RenderView doesn&#39;t trigger repaint on non-composited contents.
1048             mainFrame().view()-&gt;invalidateRect(IntRect(LayoutRect::infiniteRect()));
1049         }
1050 
1051         mainFrame().deviceOrPageScaleFactorChanged();
1052 
1053         if (view &amp;&amp; view-&gt;fixedElementsLayoutRelativeToFrame())
1054             view-&gt;setViewportConstrainedObjectsNeedLayout();
1055 
1056         if (view &amp;&amp; view-&gt;scrollPosition() != origin &amp;&amp; !delegatesScaling() &amp;&amp; document-&gt;renderView() &amp;&amp; document-&gt;renderView()-&gt;needsLayout() &amp;&amp; view-&gt;didFirstLayout())
1057             view-&gt;layoutContext().layout();
1058     }
1059 
1060     if (view &amp;&amp; view-&gt;scrollPosition() != origin) {
1061         if (!view-&gt;delegatesScrolling())
1062             view-&gt;setScrollPosition(origin);
1063 #if USE(COORDINATED_GRAPHICS)
1064         else
1065             view-&gt;requestScrollPositionUpdate(origin);
1066 #endif
1067     }
1068 
1069 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1070     if (inStableState) {
1071         forEachMediaElement([] (HTMLMediaElement&amp; element) {
1072             element.pageScaleFactorChanged();
1073         });
1074     }
1075 #else
1076     UNUSED_PARAM(inStableState);
1077 #endif
1078 }
1079 
1080 void Page::setDelegatesScaling(bool delegatesScaling)
1081 {
1082     m_delegatesScaling = delegatesScaling;
1083 }
1084 
1085 void Page::setViewScaleFactor(float scale)
1086 {
1087     if (m_viewScaleFactor == scale)
1088         return;
1089 
1090     m_viewScaleFactor = scale;
1091     BackForwardCache::singleton().markPagesForDeviceOrPageScaleChanged(*this);
1092 }
1093 
1094 void Page::setDeviceScaleFactor(float scaleFactor)
1095 {
1096     ASSERT(scaleFactor &gt; 0);
1097     if (scaleFactor &lt;= 0)
1098         return;
1099 
1100     if (m_deviceScaleFactor == scaleFactor)
1101         return;
1102 
1103     m_deviceScaleFactor = scaleFactor;
1104     setNeedsRecalcStyleInAllFrames();
1105 
1106     mainFrame().deviceOrPageScaleFactorChanged();
1107     BackForwardCache::singleton().markPagesForDeviceOrPageScaleChanged(*this);
1108 
1109     pageOverlayController().didChangeDeviceScaleFactor();
1110 }
1111 
1112 void Page::setInitialScale(float initialScale)
1113 {
1114     m_initialScale = initialScale;
1115 }
1116 
1117 void Page::setUserInterfaceLayoutDirection(UserInterfaceLayoutDirection userInterfaceLayoutDirection)
1118 {
1119     if (m_userInterfaceLayoutDirection == userInterfaceLayoutDirection)
1120         return;
1121 
1122     m_userInterfaceLayoutDirection = userInterfaceLayoutDirection;
1123 
1124 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
1125     forEachMediaElement([] (HTMLMediaElement&amp; element) {
1126         element.userInterfaceLayoutDirectionChanged();
1127     });
1128 #endif
1129 }
1130 
1131 #if ENABLE(VIDEO)
1132 
1133 void Page::updateMediaElementRateChangeRestrictions()
1134 {
1135     // FIXME: This used to call this on all media elements, seemingly by accident. But was there some advantage to that for elements in the back/forward cache?
1136     forEachMediaElement([] (HTMLMediaElement&amp; element) {
1137         element.updateRateChangeRestrictions();
1138     });
1139 }
1140 
1141 #endif
1142 
1143 void Page::didStartProvisionalLoad()
1144 {
1145     if (m_performanceMonitor)
1146         m_performanceMonitor-&gt;didStartProvisionalLoad();
1147 }
1148 
1149 void Page::didFinishLoad()
1150 {
1151     resetRelevantPaintedObjectCounter();
1152 
1153     if (m_performanceMonitor)
1154         m_performanceMonitor-&gt;didFinishLoad();
1155 }
1156 
1157 bool Page::isOnlyNonUtilityPage() const
1158 {
1159     return !isUtilityPage() &amp;&amp; nonUtilityPageCount == 1;
1160 }
1161 
1162 bool Page::isLowPowerModeEnabled() const
1163 {
1164     if (m_lowPowerModeEnabledOverrideForTesting)
1165         return m_lowPowerModeEnabledOverrideForTesting.value();
1166 
1167     return m_lowPowerModeNotifier-&gt;isLowPowerModeEnabled();
1168 }
1169 
1170 void Page::setLowPowerModeEnabledOverrideForTesting(Optional&lt;bool&gt; isEnabled)
1171 {
1172     m_lowPowerModeEnabledOverrideForTesting = isEnabled;
1173     handleLowModePowerChange(m_lowPowerModeEnabledOverrideForTesting.valueOr(false));
1174 }
1175 
1176 void Page::setTopContentInset(float contentInset)
1177 {
1178     if (m_topContentInset == contentInset)
1179         return;
1180 
1181     m_topContentInset = contentInset;
1182 
1183     if (FrameView* view = mainFrame().view())
1184         view-&gt;topContentInsetDidChange(m_topContentInset);
1185 }
1186 
1187 void Page::setShouldSuppressScrollbarAnimations(bool suppressAnimations)
1188 {
1189     if (suppressAnimations == m_suppressScrollbarAnimations)
1190         return;
1191 
1192     lockAllOverlayScrollbarsToHidden(suppressAnimations);
1193     m_suppressScrollbarAnimations = suppressAnimations;
1194 }
1195 
1196 void Page::lockAllOverlayScrollbarsToHidden(bool lockOverlayScrollbars)
1197 {
1198     FrameView* view = mainFrame().view();
1199     if (!view)
1200         return;
1201 
1202     view-&gt;lockOverlayScrollbarStateToHidden(lockOverlayScrollbars);
1203 
1204     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1205         FrameView* frameView = frame-&gt;view();
1206         if (!frameView)
1207             continue;
1208 
1209         const HashSet&lt;ScrollableArea*&gt;* scrollableAreas = frameView-&gt;scrollableAreas();
1210         if (!scrollableAreas)
1211             continue;
1212 
1213         for (auto&amp; scrollableArea : *scrollableAreas)
1214             scrollableArea-&gt;lockOverlayScrollbarStateToHidden(lockOverlayScrollbars);
1215     }
1216 }
1217 
1218 void Page::setVerticalScrollElasticity(ScrollElasticity elasticity)
1219 {
1220     if (m_verticalScrollElasticity == elasticity)
1221         return;
1222 
1223     m_verticalScrollElasticity = elasticity;
1224 
1225     if (FrameView* view = mainFrame().view())
1226         view-&gt;setVerticalScrollElasticity(elasticity);
1227 }
1228 
1229 void Page::setHorizontalScrollElasticity(ScrollElasticity elasticity)
1230 {
1231     if (m_horizontalScrollElasticity == elasticity)
1232         return;
1233 
1234     m_horizontalScrollElasticity = elasticity;
1235 
1236     if (FrameView* view = mainFrame().view())
1237         view-&gt;setHorizontalScrollElasticity(elasticity);
1238 }
1239 
1240 void Page::setPagination(const Pagination&amp; pagination)
1241 {
1242     if (m_pagination == pagination)
1243         return;
1244 
1245     m_pagination = pagination;
1246 
1247     setNeedsRecalcStyleInAllFrames();
1248 }
1249 
1250 void Page::setPaginationLineGridEnabled(bool enabled)
1251 {
1252     if (m_paginationLineGridEnabled == enabled)
1253         return;
1254 
1255     m_paginationLineGridEnabled = enabled;
1256 
1257     setNeedsRecalcStyleInAllFrames();
1258 }
1259 
1260 unsigned Page::pageCount() const
1261 {
1262     if (m_pagination.mode == Pagination::Unpaginated)
1263         return 0;
1264 
1265     if (Document* document = mainFrame().document())
1266         document-&gt;updateLayoutIgnorePendingStylesheets();
1267 
1268     RenderView* contentRenderer = mainFrame().contentRenderer();
1269     return contentRenderer ? contentRenderer-&gt;pageCount() : 0;
1270 }
1271 
1272 void Page::setIsInWindow(bool isInWindow)
1273 {
1274     setActivityState(isInWindow ? m_activityState | ActivityState::IsInWindow : m_activityState - ActivityState::IsInWindow);
1275 }
1276 
1277 void Page::setIsInWindowInternal(bool isInWindow)
1278 {
1279     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1280         if (FrameView* frameView = frame-&gt;view())
1281             frameView-&gt;setIsInWindow(isInWindow);
1282     }
1283 
1284     if (isInWindow)
1285         resumeAnimatingImages();
1286 }
1287 
1288 void Page::addActivityStateChangeObserver(ActivityStateChangeObserver&amp; observer)
1289 {
1290     m_activityStateChangeObservers.add(&amp;observer);
1291 }
1292 
1293 void Page::removeActivityStateChangeObserver(ActivityStateChangeObserver&amp; observer)
1294 {
1295     m_activityStateChangeObservers.remove(&amp;observer);
1296 }
1297 
1298 void Page::layoutIfNeeded()
1299 {
1300     if (FrameView* view = m_mainFrame-&gt;view())
1301         view-&gt;updateLayoutAndStyleIfNeededRecursive();
1302 }
1303 
1304 // https://html.spec.whatwg.org/multipage/webappapis.html#update-the-rendering
1305 void Page::updateRendering()
1306 {
1307     // This function is not reentrant, e.g. a rAF callback may force repaint.
1308     if (m_inUpdateRendering) {
1309         layoutIfNeeded();
1310         return;
1311     }
1312 
1313     TraceScope traceScope(RenderingUpdateStart, RenderingUpdateEnd);
1314 
1315     SetForScope&lt;bool&gt; change(m_inUpdateRendering, true);
1316 
1317     layoutIfNeeded();
1318 
1319     // Flush autofocus candidates
1320 
1321     forEachDocument([] (Document&amp; document) {
1322         document.runResizeSteps();
1323     });
1324 
1325     forEachDocument([] (Document&amp; document) {
1326         document.runScrollSteps();
1327     });
1328 
1329     forEachDocument([] (Document&amp; document) {
1330         document.evaluateMediaQueriesAndReportChanges();
1331     });
1332 
1333     forEachDocument([] (Document&amp; document) {
1334         if (!document.domWindow())
1335             return;
1336         DOMHighResTimeStamp timestamp = document.domWindow()-&gt;nowTimestamp();
1337         document.updateAnimationsAndSendEvents(timestamp);
1338         // FIXME: Run the fullscreen steps.
1339         document.serviceRequestAnimationFrameCallbacks(timestamp);
1340     });
1341 
1342     layoutIfNeeded();
1343 
1344 #if ENABLE(INTERSECTION_OBSERVER)
1345     forEachDocument([] (Document&amp; document) {
1346         document.updateIntersectionObservations();
1347     });
1348 #endif
1349 
1350 #if ENABLE(RESIZE_OBSERVER)
1351     forEachDocument([&amp;] (Document&amp; document) {
1352         document.updateResizeObservations(*this);
1353     });
1354 #endif
1355 
1356     layoutIfNeeded();
1357 
1358     forEachDocument([] (Document&amp; document) {
1359         document.updateHighlightPositions();
1360     });
1361 }
1362 
1363 void Page::suspendScriptedAnimations()
1364 {
1365     m_scriptedAnimationsSuspended = true;
1366 
1367     forEachDocument([] (Document&amp; document) {
1368         document.suspendScriptedAnimationControllerCallbacks();
1369     });
1370 }
1371 
1372 void Page::resumeScriptedAnimations()
1373 {
1374     m_scriptedAnimationsSuspended = false;
1375 
1376     forEachDocument([] (Document&amp; document) {
1377         document.resumeScriptedAnimationControllerCallbacks();
1378     });
1379 }
1380 
1381 enum class ThrottlingReasonOperation { Add, Remove };
1382 static void updateScriptedAnimationsThrottlingReason(Page&amp; page, ThrottlingReasonOperation operation, ScriptedAnimationController::ThrottlingReason reason)
1383 {
1384     page.forEachDocument([&amp;] (Document&amp; document) {
1385         if (auto* controller = document.scriptedAnimationController()) {
1386             if (operation == ThrottlingReasonOperation::Add)
1387                 controller-&gt;addThrottlingReason(reason);
1388             else
1389                 controller-&gt;removeThrottlingReason(reason);
1390         }
1391     });
1392 }
1393 
1394 void Page::setIsVisuallyIdleInternal(bool isVisuallyIdle)
1395 {
1396     updateScriptedAnimationsThrottlingReason(*this, isVisuallyIdle ? ThrottlingReasonOperation::Add : ThrottlingReasonOperation::Remove, ScriptedAnimationController::ThrottlingReason::VisuallyIdle);
1397 }
1398 
1399 void Page::handleLowModePowerChange(bool isLowPowerModeEnabled)
1400 {
1401     updateScriptedAnimationsThrottlingReason(*this, isLowPowerModeEnabled ? ThrottlingReasonOperation::Add : ThrottlingReasonOperation::Remove, ScriptedAnimationController::ThrottlingReason::LowPowerMode);
1402     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1403         forEachDocument([] (Document&amp; document) {
1404             if (auto timeline = document.existingTimeline())
1405                 timeline-&gt;updateThrottlingState();
1406         });
1407     } else
1408         mainFrame().animation().updateThrottlingState();
1409     updateDOMTimerAlignmentInterval();
1410 }
1411 
1412 void Page::userStyleSheetLocationChanged()
1413 {
1414     // FIXME: Eventually we will move to a model of just being handed the sheet
1415     // text instead of loading the URL ourselves.
1416     URL url = m_settings-&gt;userStyleSheetLocation();
1417 
1418     // Allow any local file URL scheme to be loaded.
1419     if (LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(url.protocol().toStringWithoutCopying()))
1420         m_userStyleSheetPath = url.fileSystemPath();
1421     else
1422         m_userStyleSheetPath = String();
1423 
1424     m_didLoadUserStyleSheet = false;
1425     m_userStyleSheet = String();
1426     m_userStyleSheetModificationTime = WTF::nullopt;
1427 
1428     // Data URLs with base64-encoded UTF-8 style sheets are common. We can process them
1429     // synchronously and avoid using a loader.
1430     if (url.protocolIsData() &amp;&amp; url.string().startsWith(&quot;data:text/css;charset=utf-8;base64,&quot;)) {
1431         m_didLoadUserStyleSheet = true;
1432 
1433         Vector&lt;char&gt; styleSheetAsUTF8;
1434         if (base64Decode(decodeURLEscapeSequences(url.string().substring(35)), styleSheetAsUTF8, Base64IgnoreSpacesAndNewLines))
1435             m_userStyleSheet = String::fromUTF8(styleSheetAsUTF8.data(), styleSheetAsUTF8.size());
1436     }
1437 
1438     forEachDocument([] (Document&amp; document) {
1439         document.extensionStyleSheets().updatePageUserSheet();
1440     });
1441 }
1442 
1443 const String&amp; Page::userStyleSheet() const
1444 {
1445     if (m_userStyleSheetPath.isEmpty())
1446         return m_userStyleSheet;
1447 
1448     auto modificationTime = FileSystem::getFileModificationTime(m_userStyleSheetPath);
1449     if (!modificationTime) {
1450         // The stylesheet either doesn&#39;t exist, was just deleted, or is
1451         // otherwise unreadable. If we&#39;ve read the stylesheet before, we should
1452         // throw away that data now as it no longer represents what&#39;s on disk.
1453         m_userStyleSheet = String();
1454         return m_userStyleSheet;
1455     }
1456 
1457     // If the stylesheet hasn&#39;t changed since the last time we read it, we can
1458     // just return the old data.
1459     if (m_didLoadUserStyleSheet &amp;&amp; (m_userStyleSheetModificationTime &amp;&amp; modificationTime.value() &lt;= m_userStyleSheetModificationTime.value()))
1460         return m_userStyleSheet;
1461 
1462     m_didLoadUserStyleSheet = true;
1463     m_userStyleSheet = String();
1464     m_userStyleSheetModificationTime = modificationTime;
1465 
1466     // FIXME: It would be better to load this asynchronously to avoid blocking
1467     // the process, but we will first need to create an asynchronous loading
1468     // mechanism that is not tied to a particular Frame. We will also have to
1469     // determine what our behavior should be before the stylesheet is loaded
1470     // and what should happen when it finishes loading, especially with respect
1471     // to when the load event fires, when Document::close is called, and when
1472     // layout/paint are allowed to happen.
1473     auto data = SharedBuffer::createWithContentsOfFile(m_userStyleSheetPath);
1474     if (!data)
1475         return m_userStyleSheet;
1476 
1477     m_userStyleSheet = TextResourceDecoder::create(&quot;text/css&quot;)-&gt;decodeAndFlush(data-&gt;data(), data-&gt;size());
1478 
1479     return m_userStyleSheet;
1480 }
1481 
1482 void Page::userAgentChanged()
1483 {
1484     for (auto* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext()) {
1485         auto* window = frame-&gt;window();
1486         if (!window)
1487             continue;
1488         if (auto* navigator = window-&gt;optionalNavigator())
1489             navigator-&gt;userAgentChanged();
1490     }
1491 }
1492 
1493 void Page::invalidateStylesForAllLinks()
1494 {
1495     forEachDocument([] (Document&amp; document) {
1496         document.visitedLinkState().invalidateStyleForAllLinks();
1497     });
1498 }
1499 
1500 void Page::invalidateStylesForLink(SharedStringHash linkHash)
1501 {
1502     forEachDocument([&amp;] (Document&amp; document) {
1503         document.visitedLinkState().invalidateStyleForLink(linkHash);
1504     });
1505 }
1506 
1507 void Page::invalidateInjectedStyleSheetCacheInAllFrames()
1508 {
1509     forEachDocument([] (Document&amp; document) {
1510         document.extensionStyleSheets().invalidateInjectedStyleSheetCache();
1511     });
1512 }
1513 
1514 void Page::setDebugger(JSC::Debugger* debugger)
1515 {
1516     if (m_debugger == debugger)
1517         return;
1518 
1519     m_debugger = debugger;
1520 
1521     for (Frame* frame = &amp;m_mainFrame.get(); frame; frame = frame-&gt;tree().traverseNext())
1522         frame-&gt;windowProxy().attachDebugger(m_debugger);
1523 }
1524 
1525 StorageNamespace* Page::sessionStorage(bool optionalCreate)
1526 {
1527     if (!m_sessionStorage &amp;&amp; optionalCreate)
1528         m_sessionStorage = m_storageNamespaceProvider-&gt;createSessionStorageNamespace(*this, m_settings-&gt;sessionStorageQuota());
1529 
1530     return m_sessionStorage.get();
1531 }
1532 
1533 void Page::setSessionStorage(RefPtr&lt;StorageNamespace&gt;&amp;&amp; newStorage)
1534 {
1535     m_sessionStorage = WTFMove(newStorage);
1536 }
1537 
1538 bool Page::hasCustomHTMLTokenizerTimeDelay() const
1539 {
1540     return m_settings-&gt;maxParseDuration() != -1;
1541 }
1542 
1543 double Page::customHTMLTokenizerTimeDelay() const
1544 {
1545     ASSERT(m_settings-&gt;maxParseDuration() != -1);
1546     return m_settings-&gt;maxParseDuration();
1547 }
1548 
1549 void Page::setMemoryCacheClientCallsEnabled(bool enabled)
1550 {
1551     if (m_areMemoryCacheClientCallsEnabled == enabled)
1552         return;
1553 
1554     m_areMemoryCacheClientCallsEnabled = enabled;
1555     if (!enabled)
1556         return;
1557 
1558     for (RefPtr&lt;Frame&gt; frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
1559         frame-&gt;loader().tellClientAboutPastMemoryCacheLoads();
1560 }
1561 
1562 void Page::hiddenPageDOMTimerThrottlingStateChanged()
1563 {
1564     // Disable &amp; reengage to ensure state is updated.
1565     setTimerThrottlingState(TimerThrottlingState::Disabled);
1566     updateTimerThrottlingState();
1567 }
1568 
1569 void Page::updateTimerThrottlingState()
1570 {
1571     // Timer throttling disabled if page is visually active, or disabled by setting.
1572     if (!m_settings-&gt;hiddenPageDOMTimerThrottlingEnabled() || !(m_activityState &amp; ActivityState::IsVisuallyIdle)) {
1573         setTimerThrottlingState(TimerThrottlingState::Disabled);
1574         return;
1575     }
1576 
1577     // If the page is visible (but idle), there is any activity (loading, media playing, etc), or per setting,
1578     // we allow timer throttling, but not increasing timer throttling.
1579     if (!m_settings-&gt;hiddenPageDOMTimerThrottlingAutoIncreases()
1580         || m_activityState.containsAny({ActivityState::IsVisible, ActivityState::IsAudible, ActivityState::IsLoading, ActivityState::IsCapturingMedia })) {
1581         setTimerThrottlingState(TimerThrottlingState::Enabled);
1582         return;
1583     }
1584 
1585     // If we get here increasing timer throttling is enabled.
1586     setTimerThrottlingState(TimerThrottlingState::EnabledIncreasing);
1587 }
1588 
1589 void Page::setTimerThrottlingState(TimerThrottlingState state)
1590 {
1591     if (state == m_timerThrottlingState)
1592         return;
1593 
1594     m_timerThrottlingState = state;
1595     m_timerThrottlingStateLastChangedTime = MonotonicTime::now();
1596 
1597     updateDOMTimerAlignmentInterval();
1598 
1599     // When throttling is disabled, release all throttled timers.
1600     if (state == TimerThrottlingState::Disabled) {
1601         forEachDocument([] (Document&amp; document) {
1602             document.didChangeTimerAlignmentInterval();
1603         });
1604     }
1605 }
1606 
1607 void Page::setDOMTimerAlignmentIntervalIncreaseLimit(Seconds limit)
1608 {
1609     m_domTimerAlignmentIntervalIncreaseLimit = limit;
1610 
1611     // If (m_domTimerAlignmentIntervalIncreaseLimit &lt; m_domTimerAlignmentInterval) then we need
1612     // to update m_domTimerAlignmentInterval, if greater then need to restart the increase timer.
1613     if (m_timerThrottlingState == TimerThrottlingState::EnabledIncreasing)
1614         updateDOMTimerAlignmentInterval();
1615 }
1616 
1617 void Page::updateDOMTimerAlignmentInterval()
1618 {
1619     bool needsIncreaseTimer = false;
1620 
1621     switch (m_timerThrottlingState) {
1622     case TimerThrottlingState::Disabled:
1623         m_domTimerAlignmentInterval = isLowPowerModeEnabled() ? DOMTimer::defaultAlignmentIntervalInLowPowerMode() : DOMTimer::defaultAlignmentInterval();
1624         break;
1625 
1626     case TimerThrottlingState::Enabled:
1627         m_domTimerAlignmentInterval = DOMTimer::hiddenPageAlignmentInterval();
1628         break;
1629 
1630     case TimerThrottlingState::EnabledIncreasing:
1631         // For pages in prerender state maximum throttling kicks in immediately.
1632         if (m_isPrerender)
1633             m_domTimerAlignmentInterval = m_domTimerAlignmentIntervalIncreaseLimit;
1634         else {
1635             ASSERT(!!m_timerThrottlingStateLastChangedTime);
1636             m_domTimerAlignmentInterval = MonotonicTime::now() - m_timerThrottlingStateLastChangedTime;
1637             // If we&#39;re below the limit, set the timer. If above, clamp to limit.
1638             if (m_domTimerAlignmentInterval &lt; m_domTimerAlignmentIntervalIncreaseLimit)
1639                 needsIncreaseTimer = true;
1640             else
1641                 m_domTimerAlignmentInterval = m_domTimerAlignmentIntervalIncreaseLimit;
1642         }
1643         // Alignment interval should not be less than DOMTimer::hiddenPageAlignmentInterval().
1644         m_domTimerAlignmentInterval = std::max(m_domTimerAlignmentInterval, DOMTimer::hiddenPageAlignmentInterval());
1645     }
1646 
1647     // If throttling is enabled, auto-increasing of throttling is enabled, and the auto-increase
1648     // limit has not yet been reached, and then arm the timer to consider an increase. Time to wait
1649     // between increases is equal to the current throttle time. Since alinment interval increases
1650     // exponentially, time between steps is exponential too.
1651     if (!needsIncreaseTimer)
1652         m_domTimerAlignmentIntervalIncreaseTimer.stop();
1653     else if (!m_domTimerAlignmentIntervalIncreaseTimer.isActive())
1654         m_domTimerAlignmentIntervalIncreaseTimer.startOneShot(m_domTimerAlignmentInterval);
1655 }
1656 
1657 void Page::domTimerAlignmentIntervalIncreaseTimerFired()
1658 {
1659     ASSERT(m_settings-&gt;hiddenPageDOMTimerThrottlingAutoIncreases());
1660     ASSERT(m_timerThrottlingState == TimerThrottlingState::EnabledIncreasing);
1661     ASSERT(m_domTimerAlignmentInterval &lt; m_domTimerAlignmentIntervalIncreaseLimit);
1662 
1663     // Alignment interval is increased to equal the time the page has been throttled, to a limit.
1664     updateDOMTimerAlignmentInterval();
1665 }
1666 
1667 void Page::dnsPrefetchingStateChanged()
1668 {
1669     forEachDocument([] (Document&amp; document) {
1670         document.initDNSPrefetch();
1671     });
1672 }
1673 
1674 Vector&lt;Ref&lt;PluginViewBase&gt;&gt; Page::pluginViews()
1675 {
1676     Vector&lt;Ref&lt;PluginViewBase&gt;&gt; views;
1677     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
1678         auto* view = frame-&gt;view();
1679         if (!view)
1680             break;
1681         for (auto&amp; widget : view-&gt;children()) {
1682             if (is&lt;PluginViewBase&gt;(widget))
1683                 views.append(downcast&lt;PluginViewBase&gt;(widget.get()));
1684         }
1685     }
1686     return views;
1687 }
1688 
1689 void Page::storageBlockingStateChanged()
1690 {
1691     forEachDocument([] (Document&amp; document) {
1692         document.storageBlockingStateDidChange();
1693     });
1694 
1695     // Collect the PluginViews in to a vector to ensure that action the plug-in takes
1696     // from below storageBlockingStateChanged does not affect their lifetime.
1697     for (auto&amp; view : pluginViews())
1698         view-&gt;storageBlockingStateChanged();
1699 }
1700 
1701 void Page::updateIsPlayingMedia(uint64_t sourceElementID)
1702 {
1703     MediaProducer::MediaStateFlags state = MediaProducer::IsNotPlaying;
1704     forEachDocument([&amp;] (Document&amp; document) {
1705         state |= document.mediaState();
1706     });
1707 
1708     if (state == m_mediaState)
1709         return;
1710 
1711     m_mediaState = state;
1712 
1713     chrome().client().isPlayingMediaDidChange(state, sourceElementID);
1714 }
1715 
1716 void Page::schedulePlaybackControlsManagerUpdate()
1717 {
1718 #if ENABLE(VIDEO)
1719     if (!m_playbackControlsManagerUpdateTimer.isActive())
1720         m_playbackControlsManagerUpdateTimer.startOneShot(0_s);
1721 #endif
1722 }
1723 
1724 #if ENABLE(VIDEO)
1725 
1726 void Page::playbackControlsManagerUpdateTimerFired()
1727 {
1728     if (auto bestMediaElement = HTMLMediaElement::bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose::ControlsManager))
1729         chrome().client().setUpPlaybackControlsManager(*bestMediaElement);
1730     else
1731         chrome().client().clearPlaybackControlsManager();
1732 }
1733 
1734 #endif
1735 
1736 void Page::setMuted(MediaProducer::MutedStateFlags muted)
1737 {
1738     if (m_mutedState == muted)
1739         return;
1740 
1741     m_mutedState = muted;
1742 
1743     forEachDocument([] (Document&amp; document) {
1744         document.pageMutedStateDidChange();
1745     });
1746 }
1747 
1748 void Page::stopMediaCapture()
1749 {
1750 #if ENABLE(MEDIA_STREAM)
1751     forEachDocument([] (Document&amp; document) {
1752         document.stopMediaCapture();
1753     });
1754 #endif
1755 }
1756 
1757 void Page::stopAllMediaPlayback()
1758 {
1759 #if ENABLE(VIDEO)
1760     forEachDocument([] (Document&amp; document) {
1761         document.stopAllMediaPlayback();
1762     });
1763 #endif
1764 }
1765 
1766 void Page::suspendAllMediaPlayback()
1767 {
1768 #if ENABLE(VIDEO)
1769     ASSERT(!m_mediaPlaybackIsSuspended);
1770     if (m_mediaPlaybackIsSuspended)
1771         return;
1772 
1773     forEachDocument([] (Document&amp; document) {
1774         document.suspendAllMediaPlayback();
1775     });
1776 
1777     m_mediaPlaybackIsSuspended = true;
1778 #endif
1779 }
1780 
1781 void Page::resumeAllMediaPlayback()
1782 {
1783 #if ENABLE(VIDEO)
1784     ASSERT(m_mediaPlaybackIsSuspended);
1785     if (!m_mediaPlaybackIsSuspended)
1786         return;
1787     m_mediaPlaybackIsSuspended = false;
1788 
1789     forEachDocument([] (Document&amp; document) {
1790         document.resumeAllMediaPlayback();
1791     });
1792 #endif
1793 }
1794 
1795 void Page::suspendAllMediaBuffering()
1796 {
1797 #if ENABLE(VIDEO)
1798     ASSERT(!m_mediaBufferingIsSuspended);
1799     if (m_mediaBufferingIsSuspended)
1800         return;
1801     m_mediaBufferingIsSuspended = true;
1802 
1803     forEachDocument([] (Document&amp; document) {
1804         document.suspendAllMediaBuffering();
1805     });
1806 #endif
1807 }
1808 
1809 void Page::resumeAllMediaBuffering()
1810 {
1811 #if ENABLE(VIDEO)
1812     if (!m_mediaBufferingIsSuspended)
1813         return;
1814     m_mediaBufferingIsSuspended = false;
1815 
1816     forEachDocument([] (Document&amp; document) {
1817         document.resumeAllMediaBuffering();
1818     });
1819 #endif
1820 }
1821 
1822 #if ENABLE(MEDIA_SESSION)
1823 
1824 void Page::handleMediaEvent(MediaEventType eventType)
1825 {
1826     switch (eventType) {
1827     case MediaEventType::PlayPause:
1828         MediaSessionManager::singleton().togglePlayback();
1829         break;
1830     case MediaEventType::TrackNext:
1831         MediaSessionManager::singleton().skipToNextTrack();
1832         break;
1833     case MediaEventType::TrackPrevious:
1834         MediaSessionManager::singleton().skipToPreviousTrack();
1835         break;
1836     }
1837 }
1838 
1839 void Page::setVolumeOfMediaElement(double volume, uint64_t elementID)
1840 {
1841     if (HTMLMediaElement* element = HTMLMediaElement::elementWithID(elementID))
1842         element-&gt;setVolume(volume, ASSERT_NO_EXCEPTION);
1843 }
1844 
1845 #endif
1846 
1847 #if ASSERT_ENABLED
1848 
1849 void Page::checkSubframeCountConsistency() const
1850 {
1851     ASSERT(m_subframeCount &gt;= 0);
1852 
1853     int subframeCount = 0;
1854     for (const Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
1855         ++subframeCount;
1856 
1857     ASSERT(m_subframeCount + 1 == subframeCount);
1858 }
1859 
1860 #endif // ASSERT_ENABLED
1861 
1862 void Page::resumeAnimatingImages()
1863 {
1864     // Drawing models which cache painted content while out-of-window (WebKit2&#39;s composited drawing areas, etc.)
1865     // require that we repaint animated images to kickstart the animation loop.
1866     if (FrameView* view = mainFrame().view())
1867         view-&gt;resumeVisibleImageAnimationsIncludingSubframes();
1868 }
1869 
1870 void Page::setActivityState(OptionSet&lt;ActivityState::Flag&gt; activityState)
1871 {
1872     auto changed = m_activityState ^ activityState;
1873     if (!changed)
1874         return;
1875 
1876     auto oldActivityState = m_activityState;
1877 
1878     bool wasVisibleAndActive = isVisibleAndActive();
1879     m_activityState = activityState;
1880 
1881     m_focusController-&gt;setActivityState(activityState);
1882 
1883     if (changed &amp; ActivityState::IsVisible)
1884         setIsVisibleInternal(activityState.contains(ActivityState::IsVisible));
1885     if (changed &amp; ActivityState::IsInWindow)
1886         setIsInWindowInternal(activityState.contains(ActivityState::IsInWindow));
1887     if (changed &amp; ActivityState::IsVisuallyIdle)
1888         setIsVisuallyIdleInternal(activityState.contains(ActivityState::IsVisuallyIdle));
1889     if (changed &amp; ActivityState::WindowIsActive) {
1890         if (auto* view = m_mainFrame-&gt;view())
1891             view-&gt;updateTiledBackingAdaptiveSizing();
1892     }
1893 
1894     if (changed.containsAny({ActivityState::IsVisible, ActivityState::IsVisuallyIdle, ActivityState::IsAudible, ActivityState::IsLoading, ActivityState::IsCapturingMedia }))
1895         updateTimerThrottlingState();
1896 
1897     for (auto* observer : m_activityStateChangeObservers)
1898         observer-&gt;activityStateDidChange(oldActivityState, m_activityState);
1899 
1900     if (wasVisibleAndActive != isVisibleAndActive())
1901         PlatformMediaSessionManager::updateNowPlayingInfoIfNecessary();
1902 
1903     if (m_performanceMonitor)
1904         m_performanceMonitor-&gt;activityStateChanged(oldActivityState, activityState);
1905 }
1906 
1907 bool Page::isVisibleAndActive() const
1908 {
1909     return m_activityState.contains(ActivityState::IsVisible) &amp;&amp; m_activityState.contains(ActivityState::WindowIsActive);
1910 }
1911 
1912 bool Page::isWindowActive() const
1913 {
1914     return m_activityState.contains(ActivityState::WindowIsActive);
1915 }
1916 
1917 void Page::setIsVisible(bool isVisible)
1918 {
1919     auto state = m_activityState;
1920 
1921     if (isVisible) {
1922         state.remove(ActivityState::IsVisuallyIdle);
1923         state.add({ ActivityState::IsVisible, ActivityState::IsVisibleOrOccluded });
1924     } else {
1925         state.add(ActivityState::IsVisuallyIdle);
1926         state.remove({ ActivityState::IsVisible, ActivityState::IsVisibleOrOccluded });
1927     }
1928     setActivityState(state);
1929 }
1930 
1931 void Page::setIsVisibleInternal(bool isVisible)
1932 {
1933     // FIXME: The visibility state should be stored on the top-level document.
1934     // https://bugs.webkit.org/show_bug.cgi?id=116769
1935 
1936     if (isVisible) {
1937         m_isPrerender = false;
1938 
1939         resumeScriptedAnimations();
1940 
1941 #if PLATFORM(IOS_FAMILY)
1942         forEachDocument([] (Document&amp; document) {
1943             document.resumeDeviceMotionAndOrientationUpdates();
1944         });
1945 #endif
1946 
1947         if (FrameView* view = mainFrame().view())
1948             view-&gt;show();
1949 
1950         if (m_settings-&gt;hiddenPageCSSAnimationSuspensionEnabled()) {
1951             if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1952                 forEachDocument([] (Document&amp; document) {
1953                     if (auto* timeline = document.existingTimeline())
1954                         timeline-&gt;resumeAnimations();
1955                 });
1956             } else
1957                 mainFrame().animation().resumeAnimations();
1958         }
1959 
1960         forEachDocument([] (Document&amp; document) {
1961             if (document.svgExtensions())
1962                 document.accessSVGExtensions().unpauseAnimations();
1963         });
1964 
1965         resumeAnimatingImages();
1966 
1967         if (m_navigationToLogWhenVisible) {
1968             logNavigation(m_navigationToLogWhenVisible.value());
1969             m_navigationToLogWhenVisible = WTF::nullopt;
1970         }
1971     }
1972 
1973     if (!isVisible) {
1974         if (m_settings-&gt;hiddenPageCSSAnimationSuspensionEnabled()) {
1975             if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
1976                 forEachDocument([] (Document&amp; document) {
1977                     if (auto* timeline = document.existingTimeline())
1978                         timeline-&gt;suspendAnimations();
1979                 });
1980             } else
1981                 mainFrame().animation().suspendAnimations();
1982         }
1983 
1984         forEachDocument([] (Document&amp; document) {
1985             if (document.svgExtensions())
1986                 document.accessSVGExtensions().pauseAnimations();
1987         });
1988 
1989 #if PLATFORM(IOS_FAMILY)
1990         forEachDocument([] (Document&amp; document) {
1991             document.suspendDeviceMotionAndOrientationUpdates();
1992         });
1993 #endif
1994 
1995         suspendScriptedAnimations();
1996 
1997         if (FrameView* view = mainFrame().view())
1998             view-&gt;hide();
1999     }
2000 
2001     forEachDocument([] (Document&amp; document) {
2002         document.visibilityStateChanged();
2003     });
2004 }
2005 
2006 void Page::setIsPrerender()
2007 {
2008     m_isPrerender = true;
2009     updateDOMTimerAlignmentInterval();
2010 }
2011 
2012 VisibilityState Page::visibilityState() const
2013 {
2014     if (isVisible())
2015         return VisibilityState::Visible;
2016     if (m_isPrerender)
2017         return VisibilityState::Prerender;
2018     return VisibilityState::Hidden;
2019 }
2020 
2021 void Page::setHeaderHeight(int headerHeight)
2022 {
2023     if (headerHeight == m_headerHeight)
2024         return;
2025 
2026     m_headerHeight = headerHeight;
2027 
2028     FrameView* frameView = mainFrame().view();
2029     if (!frameView)
2030         return;
2031 
2032     RenderView* renderView = frameView-&gt;renderView();
2033     if (!renderView)
2034         return;
2035 
2036     frameView-&gt;setNeedsLayoutAfterViewConfigurationChange();
2037     frameView-&gt;setNeedsCompositingGeometryUpdate();
2038 }
2039 
2040 void Page::setFooterHeight(int footerHeight)
2041 {
2042     if (footerHeight == m_footerHeight)
2043         return;
2044 
2045     m_footerHeight = footerHeight;
2046 
2047     FrameView* frameView = mainFrame().view();
2048     if (!frameView)
2049         return;
2050 
2051     RenderView* renderView = frameView-&gt;renderView();
2052     if (!renderView)
2053         return;
2054 
2055     frameView-&gt;setNeedsLayoutAfterViewConfigurationChange();
2056     frameView-&gt;setNeedsCompositingGeometryUpdate();
2057 }
2058 
2059 void Page::incrementNestedRunLoopCount()
2060 {
2061     m_nestedRunLoopCount++;
2062 }
2063 
2064 void Page::decrementNestedRunLoopCount()
2065 {
2066     ASSERT(m_nestedRunLoopCount);
2067     if (m_nestedRunLoopCount &lt;= 0)
2068         return;
2069 
2070     m_nestedRunLoopCount--;
2071 
2072     if (!m_nestedRunLoopCount &amp;&amp; m_unnestCallback) {
2073         callOnMainThread([this] {
2074             if (insideNestedRunLoop())
2075                 return;
2076 
2077             // This callback may destruct the Page.
2078             if (m_unnestCallback) {
2079                 auto callback = WTFMove(m_unnestCallback);
2080                 callback();
2081             }
2082         });
2083     }
2084 }
2085 
2086 void Page::whenUnnested(WTF::Function&lt;void()&gt;&amp;&amp; callback)
2087 {
2088     ASSERT(!m_unnestCallback);
2089 
2090     m_unnestCallback = WTFMove(callback);
2091 }
2092 
2093 #if ENABLE(REMOTE_INSPECTOR)
2094 
2095 bool Page::remoteInspectionAllowed() const
2096 {
2097     return m_inspectorDebuggable-&gt;remoteDebuggingAllowed();
2098 }
2099 
2100 void Page::setRemoteInspectionAllowed(bool allowed)
2101 {
2102     m_inspectorDebuggable-&gt;setRemoteDebuggingAllowed(allowed);
2103 }
2104 
2105 String Page::remoteInspectionNameOverride() const
2106 {
2107     return m_inspectorDebuggable-&gt;nameOverride();
2108 }
2109 
2110 void Page::setRemoteInspectionNameOverride(const String&amp; name)
2111 {
2112     m_inspectorDebuggable-&gt;setNameOverride(name);
2113 }
2114 
2115 void Page::remoteInspectorInformationDidChange() const
2116 {
2117     m_inspectorDebuggable-&gt;update();
2118 }
2119 
2120 #endif
2121 
2122 void Page::addLayoutMilestones(OptionSet&lt;LayoutMilestone&gt; milestones)
2123 {
2124     // In the future, we may want a function that replaces m_layoutMilestones instead of just adding to it.
2125     m_requestedLayoutMilestones.add(milestones);
2126 }
2127 
2128 void Page::removeLayoutMilestones(OptionSet&lt;LayoutMilestone&gt; milestones)
2129 {
2130     m_requestedLayoutMilestones.remove(milestones);
2131 }
2132 
2133 Color Page::pageExtendedBackgroundColor() const
2134 {
2135     FrameView* frameView = mainFrame().view();
2136     if (!frameView)
2137         return Color();
2138 
2139     RenderView* renderView = frameView-&gt;renderView();
2140     if (!renderView)
2141         return Color();
2142 
2143     return renderView-&gt;compositor().rootExtendedBackgroundColor();
2144 }
2145 
2146 // These are magical constants that might be tweaked over time.
2147 static const double gMinimumPaintedAreaRatio = 0.1;
2148 static const double gMaximumUnpaintedAreaRatio = 0.04;
2149 
2150 bool Page::isCountingRelevantRepaintedObjects() const
2151 {
2152     return m_isCountingRelevantRepaintedObjects &amp;&amp; m_requestedLayoutMilestones.contains(DidHitRelevantRepaintedObjectsAreaThreshold);
2153 }
2154 
2155 void Page::startCountingRelevantRepaintedObjects()
2156 {
2157     // Reset everything in case we didn&#39;t hit the threshold last time.
2158     resetRelevantPaintedObjectCounter();
2159 
2160     m_isCountingRelevantRepaintedObjects = true;
2161 }
2162 
2163 void Page::resetRelevantPaintedObjectCounter()
2164 {
2165     m_isCountingRelevantRepaintedObjects = false;
2166     m_relevantUnpaintedRenderObjects.clear();
2167     m_topRelevantPaintedRegion = Region();
2168     m_bottomRelevantPaintedRegion = Region();
2169     m_relevantUnpaintedRegion = Region();
2170 }
2171 
2172 static LayoutRect relevantViewRect(RenderView* view)
2173 {
2174     LayoutRect viewRect = view-&gt;viewRect();
2175 
2176     float relevantViewRectWidth = 980;
2177 #if PLATFORM(WATCHOS)
2178     // FIXME(186051): Consider limiting the relevant rect width to the view width everywhere.
2179     relevantViewRectWidth = std::min&lt;float&gt;(viewRect.width().toFloat(), relevantViewRectWidth);
2180 #endif
2181 
2182     // DidHitRelevantRepaintedObjectsAreaThreshold is a LayoutMilestone intended to indicate that
2183     // a certain relevant amount of content has been drawn to the screen. This is the rect that
2184     // has been determined to be relevant in the context of this goal. We may choose to tweak
2185     // the rect over time, much like we may choose to tweak gMinimumPaintedAreaRatio and
2186     // gMaximumUnpaintedAreaRatio. But this seems to work well right now.
2187     LayoutRect relevantViewRect { 0, 0, LayoutUnit(relevantViewRectWidth), 1300 };
2188     // If the viewRect is wider than the relevantViewRect, center the relevantViewRect.
2189     if (viewRect.width() &gt; relevantViewRect.width())
2190         relevantViewRect.setX((viewRect.width() - relevantViewRect.width()) / 2);
2191 
2192     return relevantViewRect;
2193 }
2194 
2195 void Page::addRelevantRepaintedObject(RenderObject* object, const LayoutRect&amp; objectPaintRect)
2196 {
2197     if (!isCountingRelevantRepaintedObjects())
2198         return;
2199 
2200     // Objects inside sub-frames are not considered to be relevant.
2201     if (&amp;object-&gt;frame() != &amp;mainFrame())
2202         return;
2203 
2204     LayoutRect relevantRect = relevantViewRect(&amp;object-&gt;view());
2205 
2206     // The objects are only relevant if they are being painted within the viewRect().
2207     if (!objectPaintRect.intersects(snappedIntRect(relevantRect)))
2208         return;
2209 
2210     IntRect snappedPaintRect = snappedIntRect(objectPaintRect);
2211 
2212     // If this object was previously counted as an unpainted object, remove it from that HashSet
2213     // and corresponding Region. FIXME: This doesn&#39;t do the right thing if the objects overlap.
2214     if (m_relevantUnpaintedRenderObjects.remove(object))
2215         m_relevantUnpaintedRegion.subtract(snappedPaintRect);
2216 
2217     // Split the relevantRect into a top half and a bottom half. Making sure we have coverage in
2218     // both halves helps to prevent cases where we have a fully loaded menu bar or masthead with
2219     // no content beneath that.
2220     LayoutRect topRelevantRect = relevantRect;
2221     topRelevantRect.contract(LayoutSize(0_lu, relevantRect.height() / 2));
2222     LayoutRect bottomRelevantRect = topRelevantRect;
2223     bottomRelevantRect.setY(relevantRect.height() / 2);
2224 
2225     // If the rect straddles both Regions, split it appropriately.
2226     if (topRelevantRect.intersects(snappedPaintRect) &amp;&amp; bottomRelevantRect.intersects(snappedPaintRect)) {
2227         IntRect topIntersection = snappedPaintRect;
2228         topIntersection.intersect(snappedIntRect(topRelevantRect));
2229         m_topRelevantPaintedRegion.unite(topIntersection);
2230 
2231         IntRect bottomIntersection = snappedPaintRect;
2232         bottomIntersection.intersect(snappedIntRect(bottomRelevantRect));
2233         m_bottomRelevantPaintedRegion.unite(bottomIntersection);
2234     } else if (topRelevantRect.intersects(snappedPaintRect))
2235         m_topRelevantPaintedRegion.unite(snappedPaintRect);
2236     else
2237         m_bottomRelevantPaintedRegion.unite(snappedPaintRect);
2238 
2239     float topPaintedArea = m_topRelevantPaintedRegion.totalArea();
2240     float bottomPaintedArea = m_bottomRelevantPaintedRegion.totalArea();
2241     float viewArea = relevantRect.width() * relevantRect.height();
2242 
2243     float ratioThatIsPaintedOnTop = topPaintedArea / viewArea;
2244     float ratioThatIsPaintedOnBottom = bottomPaintedArea / viewArea;
2245     float ratioOfViewThatIsUnpainted = m_relevantUnpaintedRegion.totalArea() / viewArea;
2246 
2247     if (ratioThatIsPaintedOnTop &gt; (gMinimumPaintedAreaRatio / 2) &amp;&amp; ratioThatIsPaintedOnBottom &gt; (gMinimumPaintedAreaRatio / 2)
2248         &amp;&amp; ratioOfViewThatIsUnpainted &lt; gMaximumUnpaintedAreaRatio) {
2249         m_isCountingRelevantRepaintedObjects = false;
2250         resetRelevantPaintedObjectCounter();
2251         if (Frame* frame = &amp;mainFrame())
2252             frame-&gt;loader().didReachLayoutMilestone(DidHitRelevantRepaintedObjectsAreaThreshold);
2253     }
2254 }
2255 
2256 void Page::addRelevantUnpaintedObject(RenderObject* object, const LayoutRect&amp; objectPaintRect)
2257 {
2258     if (!isCountingRelevantRepaintedObjects())
2259         return;
2260 
2261     // The objects are only relevant if they are being painted within the relevantViewRect().
2262     if (!objectPaintRect.intersects(snappedIntRect(relevantViewRect(&amp;object-&gt;view()))))
2263         return;
2264 
2265     m_relevantUnpaintedRenderObjects.add(object);
2266     m_relevantUnpaintedRegion.unite(snappedIntRect(objectPaintRect));
2267 }
2268 
2269 void Page::suspendActiveDOMObjectsAndAnimations()
2270 {
2271     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
2272         frame-&gt;suspendActiveDOMObjectsAndAnimations();
2273 }
2274 
2275 void Page::resumeActiveDOMObjectsAndAnimations()
2276 {
2277     for (Frame* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext())
2278         frame-&gt;resumeActiveDOMObjectsAndAnimations();
2279 
2280     resumeAnimatingImages();
2281 }
2282 
2283 bool Page::hasSeenAnyPlugin() const
2284 {
2285     return !m_seenPlugins.isEmpty();
2286 }
2287 
2288 bool Page::hasSeenPlugin(const String&amp; serviceType) const
2289 {
2290     return m_seenPlugins.contains(serviceType);
2291 }
2292 
2293 void Page::sawPlugin(const String&amp; serviceType)
2294 {
2295     m_seenPlugins.add(serviceType);
2296 }
2297 
2298 void Page::resetSeenPlugins()
2299 {
2300     m_seenPlugins.clear();
2301 }
2302 
2303 bool Page::hasSeenAnyMediaEngine() const
2304 {
2305     return !m_seenMediaEngines.isEmpty();
2306 }
2307 
2308 bool Page::hasSeenMediaEngine(const String&amp; engineDescription) const
2309 {
2310     return m_seenMediaEngines.contains(engineDescription);
2311 }
2312 
2313 void Page::sawMediaEngine(const String&amp; engineDescription)
2314 {
2315     m_seenMediaEngines.add(engineDescription);
2316 }
2317 
2318 void Page::resetSeenMediaEngines()
2319 {
2320     m_seenMediaEngines.clear();
2321 }
2322 
2323 void Page::hiddenPageCSSAnimationSuspensionStateChanged()
2324 {
2325     if (!isVisible()) {
2326         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
2327             forEachDocument([&amp;] (Document&amp; document) {
2328                 if (auto* timeline = document.existingTimeline()) {
2329                     if (m_settings-&gt;hiddenPageCSSAnimationSuspensionEnabled())
2330                         timeline-&gt;suspendAnimations();
2331                     else
2332                         timeline-&gt;resumeAnimations();
2333                 }
2334             });
2335         } else {
2336             if (m_settings-&gt;hiddenPageCSSAnimationSuspensionEnabled())
2337                 mainFrame().animation().suspendAnimations();
2338             else
2339                 mainFrame().animation().resumeAnimations();
2340         }
2341     }
2342 }
2343 
2344 #if ENABLE(VIDEO_TRACK)
2345 
2346 void Page::captionPreferencesChanged()
2347 {
2348     forEachDocument([] (Document&amp; document) {
2349         document.captionPreferencesChanged();
2350     });
2351 }
2352 
2353 #endif
2354 
2355 void Page::forbidPrompts()
2356 {
2357     ++m_forbidPromptsDepth;
2358 }
2359 
2360 void Page::allowPrompts()
2361 {
2362     ASSERT(m_forbidPromptsDepth);
2363     --m_forbidPromptsDepth;
2364 }
2365 
2366 bool Page::arePromptsAllowed()
2367 {
2368     return !m_forbidPromptsDepth;
2369 }
2370 
2371 void Page::forbidSynchronousLoads()
2372 {
2373     ++m_forbidSynchronousLoadsDepth;
2374 }
2375 
2376 void Page::allowSynchronousLoads()
2377 {
2378     ASSERT(m_forbidSynchronousLoadsDepth);
2379     --m_forbidSynchronousLoadsDepth;
2380 }
2381 
2382 bool Page::areSynchronousLoadsAllowed()
2383 {
2384     return !m_forbidSynchronousLoadsDepth;
2385 }
2386 
2387 void Page::logNavigation(const Navigation&amp; navigation)
2388 {
2389     String navigationDescription;
2390     switch (navigation.type) {
2391     case FrameLoadType::Standard:
2392         navigationDescription = &quot;standard&quot;_s;
2393         break;
2394     case FrameLoadType::Back:
2395         navigationDescription = &quot;back&quot;_s;
2396         break;
2397     case FrameLoadType::Forward:
2398         navigationDescription = &quot;forward&quot;_s;
2399         break;
2400     case FrameLoadType::IndexedBackForward:
2401         navigationDescription = &quot;indexedBackForward&quot;_s;
2402         break;
2403     case FrameLoadType::Reload:
2404         navigationDescription = &quot;reload&quot;_s;
2405         break;
2406     case FrameLoadType::Same:
2407         navigationDescription = &quot;same&quot;_s;
2408         break;
2409     case FrameLoadType::ReloadFromOrigin:
2410         navigationDescription = &quot;reloadFromOrigin&quot;_s;
2411         break;
2412     case FrameLoadType::ReloadExpiredOnly:
2413         navigationDescription = &quot;reloadRevalidatingExpired&quot;_s;
2414         break;
2415     case FrameLoadType::Replace:
2416     case FrameLoadType::RedirectWithLockedBackForwardList:
2417         // Not logging those for now.
2418         return;
2419     }
2420     diagnosticLoggingClient().logDiagnosticMessage(DiagnosticLoggingKeys::navigationKey(), navigationDescription, ShouldSample::No);
2421 
2422     if (!navigation.domain.isEmpty())
2423         diagnosticLoggingClient().logDiagnosticMessageWithEnhancedPrivacy(DiagnosticLoggingKeys::domainVisitedKey(), navigation.domain.string(), ShouldSample::Yes);
2424 }
2425 
2426 void Page::mainFrameLoadStarted(const URL&amp; destinationURL, FrameLoadType type)
2427 {
2428     Navigation navigation = { RegistrableDomain { destinationURL }, type };
2429 
2430     // To avoid being too verbose, we only log navigations if the page is or becomes visible. This avoids logging non-user observable loads.
2431     if (!isVisible()) {
2432         m_navigationToLogWhenVisible = navigation;
2433         return;
2434     }
2435 
2436     m_navigationToLogWhenVisible = WTF::nullopt;
2437     logNavigation(navigation);
2438 }
2439 
2440 PluginInfoProvider&amp; Page::pluginInfoProvider()
2441 {
2442     return m_pluginInfoProvider;
2443 }
2444 
2445 UserContentProvider&amp; Page::userContentProvider()
2446 {
2447     return m_userContentProvider;
2448 }
2449 
2450 void Page::setUserContentProvider(Ref&lt;UserContentProvider&gt;&amp;&amp; userContentProvider)
2451 {
2452     m_userContentProvider-&gt;removePage(*this);
2453     m_userContentProvider = WTFMove(userContentProvider);
2454     m_userContentProvider-&gt;addPage(*this);
2455 
2456     invalidateInjectedStyleSheetCacheInAllFrames();
2457 }
2458 
2459 VisitedLinkStore&amp; Page::visitedLinkStore()
2460 {
2461     return m_visitedLinkStore;
2462 }
2463 
2464 void Page::setVisitedLinkStore(Ref&lt;VisitedLinkStore&gt;&amp;&amp; visitedLinkStore)
2465 {
2466     m_visitedLinkStore-&gt;removePage(*this);
2467     m_visitedLinkStore = WTFMove(visitedLinkStore);
2468     m_visitedLinkStore-&gt;addPage(*this);
2469 
2470     invalidateStylesForAllLinks();
2471 }
2472 
2473 PAL::SessionID Page::sessionID() const
2474 {
2475     return m_sessionID;
2476 }
2477 
2478 // This is only called by WebKitLegacy.
2479 void Page::setSessionID(PAL::SessionID sessionID)
2480 {
2481     ASSERT(sessionID.isValid());
2482     ASSERT(m_sessionID == PAL::SessionID::legacyPrivateSessionID() || m_sessionID == PAL::SessionID::defaultSessionID());
2483     ASSERT(sessionID == PAL::SessionID::legacyPrivateSessionID() || sessionID == PAL::SessionID::defaultSessionID());
2484 
2485 #if ENABLE(INDEXED_DATABASE)
2486     if (sessionID != m_sessionID)
2487         m_idbConnectionToServer = nullptr;
2488 #endif
2489 
2490     if (sessionID != m_sessionID &amp;&amp; m_sessionStorage)
2491         m_sessionStorage-&gt;setSessionIDForTesting(sessionID);
2492 
2493     bool privateBrowsingStateChanged = (sessionID.isEphemeral() != m_sessionID.isEphemeral());
2494 
2495     m_sessionID = sessionID;
2496 
2497     if (!privateBrowsingStateChanged)
2498         return;
2499 
2500     forEachDocument([&amp;] (Document&amp; document) {
2501         document.privateBrowsingStateDidChange(m_sessionID);
2502     });
2503 
2504     // Collect the PluginViews in to a vector to ensure that action the plug-in takes
2505     // from below privateBrowsingStateChanged does not affect their lifetime.
2506 
2507     for (auto&amp; view : pluginViews())
2508         view-&gt;privateBrowsingStateChanged(sessionID.isEphemeral());
2509 }
2510 
2511 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2512 void Page::addPlaybackTargetPickerClient(uint64_t contextId)
2513 {
2514     chrome().client().addPlaybackTargetPickerClient(contextId);
2515 }
2516 
2517 void Page::removePlaybackTargetPickerClient(uint64_t contextId)
2518 {
2519     chrome().client().removePlaybackTargetPickerClient(contextId);
2520 }
2521 
2522 void Page::showPlaybackTargetPicker(uint64_t contextId, const WebCore::IntPoint&amp; location, bool isVideo, RouteSharingPolicy routeSharingPolicy, const String&amp; routingContextUID)
2523 {
2524 #if PLATFORM(IOS_FAMILY)
2525     // FIXME: refactor iOS implementation.
2526     UNUSED_PARAM(contextId);
2527     UNUSED_PARAM(location);
2528     chrome().client().showPlaybackTargetPicker(isVideo, routeSharingPolicy, routingContextUID);
2529 #else
2530     UNUSED_PARAM(routeSharingPolicy);
2531     UNUSED_PARAM(routingContextUID);
2532     chrome().client().showPlaybackTargetPicker(contextId, location, isVideo);
2533 #endif
2534 }
2535 
2536 void Page::playbackTargetPickerClientStateDidChange(uint64_t contextId, MediaProducer::MediaStateFlags state)
2537 {
2538     chrome().client().playbackTargetPickerClientStateDidChange(contextId, state);
2539 }
2540 
2541 void Page::setMockMediaPlaybackTargetPickerEnabled(bool enabled)
2542 {
2543     chrome().client().setMockMediaPlaybackTargetPickerEnabled(enabled);
2544 }
2545 
2546 void Page::setMockMediaPlaybackTargetPickerState(const String&amp; name, MediaPlaybackTargetContext::State state)
2547 {
2548     chrome().client().setMockMediaPlaybackTargetPickerState(name, state);
2549 }
2550 
2551 void Page::mockMediaPlaybackTargetPickerDismissPopup()
2552 {
2553     chrome().client().mockMediaPlaybackTargetPickerDismissPopup();
2554 }
2555 
2556 void Page::setPlaybackTarget(uint64_t contextId, Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; target)
2557 {
2558     forEachDocument([&amp;] (Document&amp; document) {
2559         document.setPlaybackTarget(contextId, target.copyRef());
2560     });
2561 }
2562 
2563 void Page::playbackTargetAvailabilityDidChange(uint64_t contextId, bool available)
2564 {
2565     forEachDocument([&amp;] (Document&amp; document) {
2566         document.playbackTargetAvailabilityDidChange(contextId, available);
2567     });
2568 }
2569 
2570 void Page::setShouldPlayToPlaybackTarget(uint64_t clientId, bool shouldPlay)
2571 {
2572     forEachDocument([&amp;] (Document&amp; document) {
2573         document.setShouldPlayToPlaybackTarget(clientId, shouldPlay);
2574     });
2575 }
2576 
2577 void Page::playbackTargetPickerWasDismissed(uint64_t clientId)
2578 {
2579     forEachDocument([&amp;] (Document&amp; document) {
2580         document.playbackTargetPickerWasDismissed(clientId);
2581     });
2582 }
2583 
2584 #endif
2585 
2586 WheelEventTestMonitor&amp; Page::ensureWheelEventTestMonitor()
2587 {
2588     if (!m_wheelEventTestMonitor) {
2589         m_wheelEventTestMonitor = adoptRef(new WheelEventTestMonitor());
2590         // We need to update the scrolling coordinator so that the mainframe scrolling node can expect wheel event test triggers.
2591         if (auto* frameView = mainFrame().view()) {
2592             if (m_scrollingCoordinator)
2593                 m_scrollingCoordinator-&gt;updateIsMonitoringWheelEventsForFrameView(*frameView);
2594         }
2595     }
2596 
2597     return *m_wheelEventTestMonitor;
2598 }
2599 
2600 #if ENABLE(VIDEO)
2601 
2602 void Page::setAllowsMediaDocumentInlinePlayback(bool flag)
2603 {
2604     if (m_allowsMediaDocumentInlinePlayback == flag)
2605         return;
2606     m_allowsMediaDocumentInlinePlayback = flag;
2607 
2608     forEachMediaElement([] (HTMLMediaElement&amp; element) {
2609         element.allowsMediaDocumentInlinePlaybackChanged();
2610     });
2611 }
2612 
2613 #endif
2614 
2615 #if ENABLE(INDEXED_DATABASE)
2616 IDBClient::IDBConnectionToServer&amp; Page::idbConnection()
2617 {
2618     if (!m_idbConnectionToServer)
2619         m_idbConnectionToServer = &amp;databaseProvider().idbConnectionToServerForSession(m_sessionID);
2620 
2621     return *m_idbConnectionToServer;
2622 }
2623 
2624 IDBClient::IDBConnectionToServer* Page::optionalIDBConnection()
2625 {
2626     return m_idbConnectionToServer.get();
2627 }
2628 
2629 void Page::clearIDBConnection()
2630 {
2631     m_idbConnectionToServer = nullptr;
2632 }
2633 #endif
2634 
2635 #if ENABLE(RESOURCE_USAGE)
2636 void Page::setResourceUsageOverlayVisible(bool visible)
2637 {
2638     if (!visible) {
2639         m_resourceUsageOverlay = nullptr;
2640         return;
2641     }
2642 
2643     if (!m_resourceUsageOverlay &amp;&amp; m_settings-&gt;acceleratedCompositingEnabled())
2644         m_resourceUsageOverlay = makeUnique&lt;ResourceUsageOverlay&gt;(*this);
2645 }
2646 #endif
2647 
2648 bool Page::isAlwaysOnLoggingAllowed() const
2649 {
2650     return m_sessionID.isAlwaysOnLoggingAllowed();
2651 }
2652 
2653 String Page::captionUserPreferencesStyleSheet()
2654 {
2655     return m_captionUserPreferencesStyleSheet;
2656 }
2657 
2658 void Page::setCaptionUserPreferencesStyleSheet(const String&amp; styleSheet)
2659 {
2660     if (m_captionUserPreferencesStyleSheet == styleSheet)
2661         return;
2662 
2663     m_captionUserPreferencesStyleSheet = styleSheet;
2664 }
2665 
2666 void Page::accessibilitySettingsDidChange()
2667 {
2668     forEachDocument([] (auto&amp; document) {
2669         document.styleScope().evaluateMediaQueriesForAccessibilitySettingsChange();
2670         document.updateElementsAffectedByMediaQueries();
2671         document.scheduleTimedRenderingUpdate();
2672     });
2673 }
2674 
2675 void Page::appearanceDidChange()
2676 {
2677     forEachDocument([] (auto&amp; document) {
2678         document.styleScope().didChangeStyleSheetEnvironment();
2679         document.styleScope().evaluateMediaQueriesForAppearanceChange();
2680         document.updateElementsAffectedByMediaQueries();
2681         document.scheduleTimedRenderingUpdate();
2682     });
2683 }
2684 
2685 void Page::setUnobscuredSafeAreaInsets(const FloatBoxExtent&amp; insets)
2686 {
2687     if (m_unobscuredSafeAreaInsets == insets)
2688         return;
2689 
2690     m_unobscuredSafeAreaInsets = insets;
2691 
2692     forEachDocument([&amp;] (Document&amp; document) {
2693         document.constantProperties().didChangeSafeAreaInsets();
2694     });
2695 }
2696 
2697 void Page::setUseSystemAppearance(bool value)
2698 {
2699     if (m_useSystemAppearance == value)
2700         return;
2701 
2702     m_useSystemAppearance = value;
2703 
2704     appearanceDidChange();
2705 
2706     forEachDocument([&amp;] (Document&amp; document) {
2707         // System apperance change may affect stylesheet parsing. We need to reparse.
2708         document.extensionStyleSheets().clearPageUserSheet();
2709         document.extensionStyleSheets().invalidateInjectedStyleSheetCache();
2710     });
2711 }
2712 
2713 void Page::effectiveAppearanceDidChange(bool useDarkAppearance, bool useElevatedUserInterfaceLevel)
2714 {
2715 #if ENABLE(DARK_MODE_CSS)
2716     if (m_useDarkAppearance == useDarkAppearance &amp;&amp; m_useElevatedUserInterfaceLevel == useElevatedUserInterfaceLevel)
2717         return;
2718 
2719     m_useDarkAppearance = useDarkAppearance;
2720     m_useElevatedUserInterfaceLevel = useElevatedUserInterfaceLevel;
2721 
2722     InspectorInstrumentation::defaultAppearanceDidChange(*this, useDarkAppearance);
2723 
2724     appearanceDidChange();
2725 #else
2726     UNUSED_PARAM(useDarkAppearance);
2727 
2728     if (m_useElevatedUserInterfaceLevel == useElevatedUserInterfaceLevel)
2729         return;
2730 
2731     m_useElevatedUserInterfaceLevel = useElevatedUserInterfaceLevel;
2732 
2733     appearanceDidChange();
2734 #endif
2735 }
2736 
2737 bool Page::useDarkAppearance() const
2738 {
2739 #if ENABLE(DARK_MODE_CSS)
2740     FrameView* view = mainFrame().view();
2741     if (!view || !equalLettersIgnoringASCIICase(view-&gt;mediaType(), &quot;screen&quot;))
2742         return false;
2743     if (m_useDarkAppearanceOverride)
2744         return m_useDarkAppearanceOverride.value();
2745     return m_useDarkAppearance;
2746 #else
2747     return false;
2748 #endif
2749 }
2750 
2751 void Page::setUseDarkAppearanceOverride(Optional&lt;bool&gt; valueOverride)
2752 {
2753 #if HAVE(OS_DARK_MODE_SUPPORT)
2754     if (valueOverride == m_useDarkAppearanceOverride)
2755         return;
2756 
2757     m_useDarkAppearanceOverride = valueOverride;
2758 
2759     appearanceDidChange();
2760 #else
2761     UNUSED_PARAM(valueOverride);
2762 #endif
2763 }
2764 
2765 void Page::setFullscreenInsets(const FloatBoxExtent&amp; insets)
2766 {
2767     if (insets == m_fullscreenInsets)
2768         return;
2769 
2770     m_fullscreenInsets = insets;
2771 
2772     forEachDocument([] (Document&amp; document) {
2773         document.constantProperties().didChangeFullscreenInsets();
2774     });
2775 }
2776 
2777 void Page::setFullscreenAutoHideDuration(Seconds duration)
2778 {
2779     if (duration == m_fullscreenAutoHideDuration)
2780         return;
2781 
2782     m_fullscreenAutoHideDuration = duration;
2783 
2784     forEachDocument([&amp;] (Document&amp; document) {
2785         document.constantProperties().setFullscreenAutoHideDuration(duration);
2786     });
2787 }
2788 
2789 void Page::setFullscreenControlsHidden(bool hidden)
2790 {
2791 #if ENABLE(FULLSCREEN_API)
2792     forEachDocument([&amp;] (Document&amp; document) {
2793         document.fullscreenManager().setFullscreenControlsHidden(hidden);
2794     });
2795 #else
2796     UNUSED_PARAM(hidden);
2797 #endif
2798 }
2799 
2800 void Page::disableICECandidateFiltering()
2801 {
2802     m_shouldEnableICECandidateFilteringByDefault = false;
2803 #if ENABLE(WEB_RTC)
2804     m_rtcController.disableICECandidateFilteringForAllOrigins();
2805 #endif
2806 }
2807 
2808 void Page::enableICECandidateFiltering()
2809 {
2810     m_shouldEnableICECandidateFilteringByDefault = true;
2811 #if ENABLE(WEB_RTC)
2812     m_rtcController.enableICECandidateFiltering();
2813 #endif
2814 }
2815 
2816 void Page::didChangeMainDocument()
2817 {
2818 #if ENABLE(WEB_RTC)
2819     m_rtcController.reset(m_shouldEnableICECandidateFilteringByDefault);
2820 #endif
2821 #if ENABLE(POINTER_EVENTS)
2822     m_pointerCaptureController-&gt;reset();
2823 #endif
2824 }
2825 
2826 RenderingUpdateScheduler&amp; Page::renderingUpdateScheduler()
2827 {
2828     if (!m_renderingUpdateScheduler)
2829         m_renderingUpdateScheduler = RenderingUpdateScheduler::create(*this);
2830     return *m_renderingUpdateScheduler;
2831 }
2832 
2833 void Page::forEachDocument(const Function&lt;void(Document&amp;)&gt;&amp; functor) const
2834 {
2835     Vector&lt;Ref&lt;Document&gt;&gt; documents;
2836     for (auto* frame = &amp;mainFrame(); frame; frame = frame-&gt;tree().traverseNext()) {
2837         auto* document = frame-&gt;document();
2838         if (!document)
2839             continue;
2840         documents.append(*document);
2841     }
2842     for (auto&amp; document : documents)
2843         functor(document);
2844 }
2845 
2846 void Page::forEachMediaElement(const Function&lt;void(HTMLMediaElement&amp;)&gt;&amp; functor)
2847 {
2848 #if ENABLE(VIDEO)
2849     forEachDocument([&amp;] (Document&amp; document) {
2850         document.forEachMediaElement(functor);
2851     });
2852 #endif
2853 }
2854 
2855 void Page::applicationWillResignActive()
2856 {
2857 #if ENABLE(VIDEO)
2858     forEachMediaElement([] (HTMLMediaElement&amp; element) {
2859         element.applicationWillResignActive();
2860     });
2861 #endif
2862 }
2863 
2864 void Page::applicationDidEnterBackground()
2865 {
2866     m_libWebRTCProvider-&gt;setActive(false);
2867 }
2868 
2869 void Page::applicationWillEnterForeground()
2870 {
2871     m_libWebRTCProvider-&gt;setActive(true);
2872 }
2873 
2874 void Page::applicationDidBecomeActive()
2875 {
2876 #if ENABLE(VIDEO)
2877     forEachMediaElement([] (HTMLMediaElement&amp; element) {
2878         element.applicationDidBecomeActive();
2879     });
2880 #endif
2881 }
2882 
2883 #if PLATFORM(MAC)
2884 ScrollLatchingState* Page::latchingState()
2885 {
2886     if (m_latchingState.isEmpty())
2887         return nullptr;
2888 
2889     return &amp;m_latchingState.last();
2890 }
2891 
2892 void Page::pushNewLatchingState()
2893 {
2894     m_latchingState.append(ScrollLatchingState());
2895 }
2896 
2897 void Page::resetLatchingState()
2898 {
2899     m_latchingState.clear();
2900 }
2901 
2902 void Page::popLatchingState()
2903 {
2904     m_latchingState.removeLast();
2905 }
2906 
2907 void Page::removeLatchingStateForTarget(Element&amp; targetNode)
2908 {
2909     if (m_latchingState.isEmpty())
2910         return;
2911 
2912     m_latchingState.removeAllMatching([&amp;targetNode] (ScrollLatchingState&amp; state) {
2913         auto* wheelElement = state.wheelEventElement();
2914         if (!wheelElement)
2915             return false;
2916 
2917         return targetNode.isEqualNode(wheelElement);
2918     });
2919 }
2920 #endif // PLATFORM(MAC)
2921 
2922 static void dispatchPrintEvent(Frame&amp; mainFrame, const AtomString&amp; eventType)
2923 {
2924     Vector&lt;Ref&lt;Frame&gt;&gt; frames;
2925     for (auto* frame = &amp;mainFrame; frame; frame = frame-&gt;tree().traverseNext())
2926         frames.append(*frame);
2927 
2928     for (auto&amp; frame : frames) {
2929         if (auto* window = frame-&gt;window())
2930             window-&gt;dispatchEvent(Event::create(eventType, Event::CanBubble::No, Event::IsCancelable::No), window-&gt;document());
2931     }
2932 }
2933 
2934 void Page::dispatchBeforePrintEvent()
2935 {
2936     dispatchPrintEvent(m_mainFrame, eventNames().beforeprintEvent);
2937 }
2938 
2939 void Page::dispatchAfterPrintEvent()
2940 {
2941     dispatchPrintEvent(m_mainFrame, eventNames().afterprintEvent);
2942 }
2943 
2944 #if ENABLE(APPLE_PAY)
2945 void Page::setPaymentCoordinator(std::unique_ptr&lt;PaymentCoordinator&gt;&amp;&amp; paymentCoordinator)
2946 {
2947     m_paymentCoordinator = WTFMove(paymentCoordinator);
2948 }
2949 #endif
2950 
2951 void Page::configureLoggingChannel(const String&amp; channelName, WTFLogChannelState state, WTFLogLevel level)
2952 {
2953 #if !RELEASE_LOG_DISABLED
2954     if (auto* channel = getLogChannel(channelName)) {
2955         channel-&gt;state = state;
2956         channel-&gt;level = level;
2957 
2958 #if USE(LIBWEBRTC)
2959         if (channel == &amp;LogWebRTC &amp;&amp; m_mainFrame-&gt;document())
2960             libWebRTCProvider().setEnableLogging(!sessionID().isEphemeral());
2961 #endif
2962     }
2963 
2964     chrome().client().configureLoggingChannel(channelName, state, level);
2965 #else
2966     UNUSED_PARAM(channelName);
2967     UNUSED_PARAM(state);
2968     UNUSED_PARAM(level);
2969 #endif
2970 }
2971 
2972 void Page::didFinishLoadingImageForElement(HTMLImageElement&amp; element)
2973 {
2974     auto protectedElement = makeRef(element);
2975     if (auto frame = makeRefPtr(element.document().frame()))
2976         frame-&gt;editor().revealSelectionIfNeededAfterLoadingImageForElement(element);
2977     chrome().client().didFinishLoadingImageForElement(element);
2978 }
2979 
2980 #if ENABLE(TEXT_AUTOSIZING)
2981 
2982 void Page::recomputeTextAutoSizingInAllFrames()
2983 {
2984     ASSERT(settings().textAutosizingEnabled() &amp;&amp; settings().textAutosizingUsesIdempotentMode());
2985     forEachDocument([] (Document&amp; document) {
2986         if (auto* renderView = document.renderView()) {
2987             for (auto&amp; renderer : descendantsOfType&lt;RenderElement&gt;(*renderView)) {
2988                 if (auto* element = renderer.element()) {
2989                     if (Style::Adjuster::adjustForTextAutosizing(renderer.mutableStyle(), *element))
2990                         renderer.setNeedsLayout();
2991                 }
2992             }
2993         }
2994     });
2995 }
2996 
2997 #endif
2998 
2999 bool Page::shouldDisableCorsForRequestTo(const URL&amp; url) const
3000 {
3001     return WTF::anyOf(m_corsDisablingPatterns, [&amp;] (const auto&amp; pattern) {
3002         return pattern.matches(url);
3003     });
3004 }
3005 
3006 } // namespace WebCore
    </pre>
  </body>
</html>
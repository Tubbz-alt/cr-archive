<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityRenderObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="AccessibilityObjectInterface.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityRenderObject.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/accessibility/AccessibilityRenderObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 131,13 ***</span>
  Ref&lt;AccessibilityRenderObject&gt; AccessibilityRenderObject::create(RenderObject* renderer)
  {
      return adoptRef(*new AccessibilityRenderObject(renderer));
  }
  
<span class="line-modified">! void AccessibilityRenderObject::detach(AccessibilityDetachmentType detachmentType, AXObjectCache* cache)</span>
  {
<span class="line-modified">!     AccessibilityNodeObject::detach(detachmentType, cache);</span>
  
      detachRemoteSVGRoot();
  
  #ifndef NDEBUG
      if (m_renderer)
<span class="line-new-header">--- 131,13 ---</span>
  Ref&lt;AccessibilityRenderObject&gt; AccessibilityRenderObject::create(RenderObject* renderer)
  {
      return adoptRef(*new AccessibilityRenderObject(renderer));
  }
  
<span class="line-modified">! void AccessibilityRenderObject::detachRemoteParts(AccessibilityDetachmentType detachmentType)</span>
  {
<span class="line-modified">!     AccessibilityNodeObject::detachRemoteParts(detachmentType);</span>
  
      detachRemoteSVGRoot();
  
  #ifndef NDEBUG
      if (m_renderer)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 974,11 ***</span>
          return AccessibilityObject::speakAsProperty();
  
      return m_renderer-&gt;style().speakAs();
  }
  
<span class="line-modified">! void AccessibilityRenderObject::addRadioButtonGroupChildren(AccessibilityObject* parent, AccessibilityChildrenVector&amp; linkedUIElements) const</span>
  {
      for (const auto&amp; child : parent-&gt;children()) {
          if (child-&gt;roleValue() == AccessibilityRole::RadioButton)
              linkedUIElements.append(child);
          else
<span class="line-new-header">--- 974,11 ---</span>
          return AccessibilityObject::speakAsProperty();
  
      return m_renderer-&gt;style().speakAs();
  }
  
<span class="line-modified">! void AccessibilityRenderObject::addRadioButtonGroupChildren(AXCoreObject* parent, AccessibilityChildrenVector&amp; linkedUIElements) const</span>
  {
      for (const auto&amp; child : parent-&gt;children()) {
          if (child-&gt;roleValue() == AccessibilityRole::RadioButton)
              linkedUIElements.append(child);
          else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 993,11 ***</span>
  
      Node* node = this-&gt;node();
      if (is&lt;HTMLInputElement&gt;(node)) {
          HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
          for (auto&amp; radioSibling : input.radioButtonGroup()) {
<span class="line-modified">!             if (AccessibilityObject* object = axObjectCache()-&gt;getOrCreate(radioSibling))</span>
                  linkedUIElements.append(object);
          }
      } else {
          // If we didn&#39;t find any radio button siblings with the traditional naming, lets search for a radio group role and find its children.
          for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
<span class="line-new-header">--- 993,11 ---</span>
  
      Node* node = this-&gt;node();
      if (is&lt;HTMLInputElement&gt;(node)) {
          HTMLInputElement&amp; input = downcast&lt;HTMLInputElement&gt;(*node);
          for (auto&amp; radioSibling : input.radioButtonGroup()) {
<span class="line-modified">!             if (AccessibilityObject* object = axObjectCache()-&gt;getOrCreate(radioSibling.ptr()))</span>
                  linkedUIElements.append(object);
          }
      } else {
          // If we didn&#39;t find any radio button siblings with the traditional naming, lets search for a radio group role and find its children.
          for (AccessibilityObject* parent = parentObject(); parent; parent = parent-&gt;parentObject()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1031,11 ***</span>
  }
  
  bool AccessibilityRenderObject::hasPopup() const
  {
      // Return true if this has the aria-haspopup attribute, or if it has an ancestor of type link with the aria-haspopup attribute.
<span class="line-modified">!     return AccessibilityObject::matchedParent(*this, true, [this] (const AccessibilityObject&amp; object) {</span>
          return (this == &amp;object) ? !equalLettersIgnoringASCIICase(object.popupValue(), &quot;false&quot;)
              : object.isLink() &amp;&amp; !equalLettersIgnoringASCIICase(object.popupValue(), &quot;false&quot;);
      });
  }
  
<span class="line-new-header">--- 1031,11 ---</span>
  }
  
  bool AccessibilityRenderObject::hasPopup() const
  {
      // Return true if this has the aria-haspopup attribute, or if it has an ancestor of type link with the aria-haspopup attribute.
<span class="line-modified">!     return Accessibility::findAncestor&lt;AccessibilityObject&gt;(*this, true, [this] (const AccessibilityObject&amp; object) {</span>
          return (this == &amp;object) ? !equalLettersIgnoringASCIICase(object.popupValue(), &quot;false&quot;)
              : object.isLink() &amp;&amp; !equalLettersIgnoringASCIICase(object.popupValue(), &quot;false&quot;);
      });
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1279,11 ***</span>
      if (m_renderer-&gt;isBR())
          return true;
  
      if (is&lt;RenderText&gt;(*m_renderer)) {
          // static text beneath MenuItems and MenuButtons are just reported along with the menu item, so it&#39;s ignored on an individual level
<span class="line-modified">!         AccessibilityObject* parent = parentObjectUnignored();</span>
          if (parent &amp;&amp; (parent-&gt;isMenuItem() || parent-&gt;ariaRoleAttribute() == AccessibilityRole::MenuButton))
              return true;
          auto&amp; renderText = downcast&lt;RenderText&gt;(*m_renderer);
          if (!renderText.hasRenderedText())
              return true;
<span class="line-new-header">--- 1279,11 ---</span>
      if (m_renderer-&gt;isBR())
          return true;
  
      if (is&lt;RenderText&gt;(*m_renderer)) {
          // static text beneath MenuItems and MenuButtons are just reported along with the menu item, so it&#39;s ignored on an individual level
<span class="line-modified">!         AXCoreObject* parent = parentObjectUnignored();</span>
          if (parent &amp;&amp; (parent-&gt;isMenuItem() || parent-&gt;ariaRoleAttribute() == AccessibilityRole::MenuButton))
              return true;
          auto&amp; renderText = downcast&lt;RenderText&gt;(*m_renderer);
          if (!renderText.hasRenderedText())
              return true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1431,11 ***</span>
          }
          // Otherwise fall through; use presence of help text, title, or description to decide.
      }
  
      if (m_renderer-&gt;isListMarker()) {
<span class="line-modified">!         AccessibilityObject* parent = parentObjectUnignored();</span>
          return parent &amp;&amp; !parent-&gt;isListItem();
      }
  
      if (isWebArea())
          return false;
<span class="line-new-header">--- 1431,11 ---</span>
          }
          // Otherwise fall through; use presence of help text, title, or description to decide.
      }
  
      if (m_renderer-&gt;isListMarker()) {
<span class="line-modified">!         AXCoreObject* parent = parentObjectUnignored();</span>
          return parent &amp;&amp; !parent-&gt;isListItem();
      }
  
      if (isWebArea())
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1568,11 ***</span>
      }
  
      return doAXStringForRange(documentBasedSelectedTextRange());
  }
  
<span class="line-modified">! const AtomString&amp; AccessibilityRenderObject::accessKey() const</span>
  {
      Node* node = m_renderer-&gt;node();
      if (!is&lt;Element&gt;(node))
          return nullAtom();
      return downcast&lt;Element&gt;(*node).attributeWithoutSynchronization(accesskeyAttr);
<span class="line-new-header">--- 1568,11 ---</span>
      }
  
      return doAXStringForRange(documentBasedSelectedTextRange());
  }
  
<span class="line-modified">! String AccessibilityRenderObject::accessKey() const</span>
  {
      Node* node = m_renderer-&gt;node();
      if (!is&lt;Element&gt;(node))
          return nullAtom();
      return downcast&lt;Element&gt;(*node).attributeWithoutSynchronization(accesskeyAttr);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2368,11 ***</span>
      if (allowsTextRanges())
          return boundsForRange(rangeForPlainTextRange(range));
      return IntRect();
  }
  
<span class="line-modified">! AccessibilityObject* AccessibilityRenderObject::accessibilityImageMapHitTest(HTMLAreaElement* area, const IntPoint&amp; point) const</span>
  {
      if (!area)
          return nullptr;
  
      AccessibilityObject* parent = nullptr;
<span class="line-new-header">--- 2368,11 ---</span>
      if (allowsTextRanges())
          return boundsForRange(rangeForPlainTextRange(range));
      return IntRect();
  }
  
<span class="line-modified">! AXCoreObject* AccessibilityRenderObject::accessibilityImageMapHitTest(HTMLAreaElement* area, const IntPoint&amp; point) const</span>
  {
      if (!area)
          return nullptr;
  
      AccessibilityObject* parent = nullptr;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2391,21 ***</span>
      }
  
      return nullptr;
  }
  
<span class="line-modified">! AccessibilityObjectInterface* AccessibilityRenderObject::remoteSVGElementHitTest(const IntPoint&amp; point) const</span>
  {
      AccessibilityObject* remote = remoteSVGRootElement(Create);
      if (!remote)
          return nullptr;
  
      IntSize offset = point - roundedIntPoint(boundingBoxRect().location());
      return remote-&gt;accessibilityHitTest(IntPoint(offset));
  }
  
<span class="line-modified">! AccessibilityObjectInterface* AccessibilityRenderObject::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
  {
      if (isSVGImage())
          return remoteSVGElementHitTest(point);
  
      return AccessibilityObject::elementAccessibilityHitTest(point);
<span class="line-new-header">--- 2391,21 ---</span>
      }
  
      return nullptr;
  }
  
<span class="line-modified">! AXCoreObject* AccessibilityRenderObject::remoteSVGElementHitTest(const IntPoint&amp; point) const</span>
  {
      AccessibilityObject* remote = remoteSVGRootElement(Create);
      if (!remote)
          return nullptr;
  
      IntSize offset = point - roundedIntPoint(boundingBoxRect().location());
      return remote-&gt;accessibilityHitTest(IntPoint(offset));
  }
  
<span class="line-modified">! AXCoreObject* AccessibilityRenderObject::elementAccessibilityHitTest(const IntPoint&amp; point) const</span>
  {
      if (isSVGImage())
          return remoteSVGElementHitTest(point);
  
      return AccessibilityObject::elementAccessibilityHitTest(point);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2415,11 ***</span>
  {
      // We need to allow automation of mouse events on video tags.
      return shadowHost &amp;&amp; !shadowHost-&gt;hasTagName(videoTag);
  }
  
<span class="line-modified">! AccessibilityObjectInterface* AccessibilityRenderObject::accessibilityHitTest(const IntPoint&amp; point) const</span>
  {
      if (!m_renderer || !m_renderer-&gt;hasLayer())
          return nullptr;
  
      m_renderer-&gt;document().updateLayout();
<span class="line-new-header">--- 2415,11 ---</span>
  {
      // We need to allow automation of mouse events on video tags.
      return shadowHost &amp;&amp; !shadowHost-&gt;hasTagName(videoTag);
  }
  
<span class="line-modified">! AXCoreObject* AccessibilityRenderObject::accessibilityHitTest(const IntPoint&amp; point) const</span>
  {
      if (!m_renderer || !m_renderer-&gt;hasLayer())
          return nullptr;
  
      m_renderer-&gt;document().updateLayout();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2448,19 ***</span>
  
      RenderObject* obj = node-&gt;renderer();
      if (!obj)
          return nullptr;
  
<span class="line-modified">!     AccessibilityObject* result = obj-&gt;document().axObjectCache()-&gt;getOrCreate(obj);</span>
      result-&gt;updateChildrenIfNecessary();
  
      // Allow the element to perform any hit-testing it might need to do to reach non-render children.
      result = static_cast&lt;AccessibilityObject*&gt;(result-&gt;elementAccessibilityHitTest(point));
  
      if (result &amp;&amp; result-&gt;accessibilityIsIgnored()) {
          // If this element is the label of a control, a hit test should return the control.
<span class="line-modified">!         AccessibilityObject* controlObject = result-&gt;correspondingControlForLabelElement();</span>
          if (controlObject &amp;&amp; !controlObject-&gt;exposesTitleUIElement())
              return controlObject;
  
          result = result-&gt;parentObjectUnignored();
      }
<span class="line-new-header">--- 2448,19 ---</span>
  
      RenderObject* obj = node-&gt;renderer();
      if (!obj)
          return nullptr;
  
<span class="line-modified">!     AXCoreObject* result = obj-&gt;document().axObjectCache()-&gt;getOrCreate(obj);</span>
      result-&gt;updateChildrenIfNecessary();
  
      // Allow the element to perform any hit-testing it might need to do to reach non-render children.
      result = static_cast&lt;AccessibilityObject*&gt;(result-&gt;elementAccessibilityHitTest(point));
  
      if (result &amp;&amp; result-&gt;accessibilityIsIgnored()) {
          // If this element is the label of a control, a hit test should return the control.
<span class="line-modified">!         AXCoreObject* controlObject = result-&gt;correspondingControlForLabelElement();</span>
          if (controlObject &amp;&amp; !controlObject-&gt;exposesTitleUIElement())
              return controlObject;
  
          result = result-&gt;parentObjectUnignored();
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3134,11 ***</span>
          areaObject.setHTMLMapElement(map);
          areaObject.setParent(this);
          if (!areaObject.accessibilityIsIgnored())
              m_children.append(&amp;areaObject);
          else
<span class="line-modified">!             axObjectCache()-&gt;remove(areaObject.axObjectID());</span>
      }
  }
  
  void AccessibilityRenderObject::updateChildrenIfNecessary()
  {
<span class="line-new-header">--- 3134,11 ---</span>
          areaObject.setHTMLMapElement(map);
          areaObject.setParent(this);
          if (!areaObject.accessibilityIsIgnored())
              m_children.append(&amp;areaObject);
          else
<span class="line-modified">!             axObjectCache()-&gt;remove(areaObject.objectID());</span>
      }
  }
  
  void AccessibilityRenderObject::updateChildrenIfNecessary()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3306,11 ***</span>
      // try to insert hidden nodes in the correct place in the DOM order.
      unsigned insertionIndex = 0;
      for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
          if (child-&gt;renderer()) {
              // Find out where the last render sibling is located within m_children.
<span class="line-modified">!             AccessibilityObject* childObject = axObjectCache()-&gt;get(child-&gt;renderer());</span>
              if (childObject &amp;&amp; childObject-&gt;accessibilityIsIgnored()) {
                  auto&amp; children = childObject-&gt;children();
                  if (children.size())
                      childObject = children.last().get();
                  else
<span class="line-new-header">--- 3306,11 ---</span>
      // try to insert hidden nodes in the correct place in the DOM order.
      unsigned insertionIndex = 0;
      for (Node* child = node-&gt;firstChild(); child; child = child-&gt;nextSibling()) {
          if (child-&gt;renderer()) {
              // Find out where the last render sibling is located within m_children.
<span class="line-modified">!             AXCoreObject* childObject = axObjectCache()-&gt;get(child-&gt;renderer());</span>
              if (childObject &amp;&amp; childObject-&gt;accessibilityIsIgnored()) {
                  auto&amp; children = childObject-&gt;children();
                  if (children.size())
                      childObject = children.last().get();
                  else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3523,11 ***</span>
      case AccessibilityRole::Tree:
      case AccessibilityRole::TreeGrid:
          ariaSelectedRows(result);
          return;
      case AccessibilityRole::TabList:
<span class="line-modified">!         if (AccessibilityObject* selectedTab = selectedTabItem())</span>
              result.append(selectedTab);
          return;
      case AccessibilityRole::List:
          if (auto* selectedListItemChild = selectedListItem())
              result.append(selectedListItemChild);
<span class="line-new-header">--- 3523,11 ---</span>
      case AccessibilityRole::Tree:
      case AccessibilityRole::TreeGrid:
          ariaSelectedRows(result);
          return;
      case AccessibilityRole::TabList:
<span class="line-modified">!         if (AXCoreObject* selectedTab = selectedTabItem())</span>
              result.append(selectedTab);
          return;
      case AccessibilityRole::List:
          if (auto* selectedListItemChild = selectedListItem())
              result.append(selectedListItemChild);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3561,30 ***</span>
  
  void AccessibilityRenderObject::visibleChildren(AccessibilityChildrenVector&amp; result)
  {
      ASSERT(result.isEmpty());
  
<span class="line-modified">!     // only listboxes are asked for their visible children.</span>
<span class="line-modified">!     if (ariaRoleAttribute() != AccessibilityRole::ListBox) {</span>
<span class="line-modified">!         // native list boxes would be AccessibilityListBoxes, so only check for aria list boxes</span>
<span class="line-removed">-         ASSERT_NOT_REACHED();</span>
          return;
<span class="line-removed">-     }</span>
      return ariaListboxVisibleChildren(result);
  }
  
  void AccessibilityRenderObject::tabChildren(AccessibilityChildrenVector&amp; result)
  {
<span class="line-modified">!     ASSERT(roleValue() == AccessibilityRole::TabList);</span>
  
      for (const auto&amp; child : children()) {
          if (child-&gt;isTabItem())
              result.append(child);
      }
  }
  
<span class="line-modified">! const String&amp; AccessibilityRenderObject::actionVerb() const</span>
  {
  #if !PLATFORM(IOS_FAMILY)
      // FIXME: Need to add verbs for select elements.
      static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
      static NeverDestroyed&lt;const String&gt; textFieldAction(AXTextFieldActionVerb());
<span class="line-new-header">--- 3561,29 ---</span>
  
  void AccessibilityRenderObject::visibleChildren(AccessibilityChildrenVector&amp; result)
  {
      ASSERT(result.isEmpty());
  
<span class="line-modified">!     // Only listboxes are asked for their visible children.</span>
<span class="line-modified">!     // Native list boxes would be AccessibilityListBoxes, so only check for aria list boxes.</span>
<span class="line-modified">!     if (ariaRoleAttribute() != AccessibilityRole::ListBox)</span>
          return;
      return ariaListboxVisibleChildren(result);
  }
  
  void AccessibilityRenderObject::tabChildren(AccessibilityChildrenVector&amp; result)
  {
<span class="line-modified">!     if (roleValue() != AccessibilityRole::TabList)</span>
<span class="line-added">+         return;</span>
  
      for (const auto&amp; child : children()) {
          if (child-&gt;isTabItem())
              result.append(child);
      }
  }
  
<span class="line-modified">! String AccessibilityRenderObject::actionVerb() const</span>
  {
  #if !PLATFORM(IOS_FAMILY)
      // FIXME: Need to add verbs for select elements.
      static NeverDestroyed&lt;const String&gt; buttonAction(AXButtonActionVerb());
      static NeverDestroyed&lt;const String&gt; textFieldAction(AXTextFieldActionVerb());
</pre>
<center><a href="AccessibilityObjectInterface.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="AccessibilityRenderObject.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
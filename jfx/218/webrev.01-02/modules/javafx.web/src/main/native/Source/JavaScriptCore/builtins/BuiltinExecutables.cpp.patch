diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/BuiltinExecutables.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/BuiltinExecutables.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/BuiltinExecutables.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/BuiltinExecutables.cpp
@@ -42,10 +42,11 @@
 
 SourceCode BuiltinExecutables::defaultConstructorSourceCode(ConstructorKind constructorKind)
 {
     switch (constructorKind) {
     case ConstructorKind::None:
+    case ConstructorKind::Naked:
         break;
     case ConstructorKind::Base: {
         static NeverDestroyed<const String> baseConstructorCode(MAKE_STATIC_STRING_IMPL("(function () { })"));
         return makeSource(baseConstructorCode, { });
     }
@@ -56,34 +57,30 @@
     }
     RELEASE_ASSERT_NOT_REACHED();
     return SourceCode();
 }
 
-UnlinkedFunctionExecutable* BuiltinExecutables::createDefaultConstructor(ConstructorKind constructorKind, const Identifier& name)
+UnlinkedFunctionExecutable* BuiltinExecutables::createDefaultConstructor(ConstructorKind constructorKind, const Identifier& name, NeedsClassFieldInitializer needsClassFieldInitializer)
 {
     switch (constructorKind) {
     case ConstructorKind::None:
+    case ConstructorKind::Naked:
         break;
     case ConstructorKind::Base:
     case ConstructorKind::Extends:
-        return createExecutable(m_vm, defaultConstructorSourceCode(constructorKind), name, constructorKind, ConstructAbility::CanConstruct);
+        return createExecutable(m_vm, defaultConstructorSourceCode(constructorKind), name, constructorKind, ConstructAbility::CanConstruct, needsClassFieldInitializer);
     }
     ASSERT_NOT_REACHED();
     return nullptr;
 }
 
-UnlinkedFunctionExecutable* BuiltinExecutables::createBuiltinExecutable(const SourceCode& code, const Identifier& name, ConstructAbility constructAbility)
+UnlinkedFunctionExecutable* BuiltinExecutables::createBuiltinExecutable(const SourceCode& code, const Identifier& name, ConstructorKind constructorKind, ConstructAbility constructAbility)
 {
-    return createExecutable(m_vm, code, name, ConstructorKind::None, constructAbility);
+    return createExecutable(m_vm, code, name, constructorKind, constructAbility, NeedsClassFieldInitializer::No);
 }
 
-UnlinkedFunctionExecutable* createBuiltinExecutable(VM& vm, const SourceCode& code, const Identifier& name, ConstructAbility constructAbility)
-{
-    return BuiltinExecutables::createExecutable(vm, code, name, ConstructorKind::None, constructAbility);
-}
-
-UnlinkedFunctionExecutable* BuiltinExecutables::createExecutable(VM& vm, const SourceCode& source, const Identifier& name, ConstructorKind constructorKind, ConstructAbility constructAbility)
+UnlinkedFunctionExecutable* BuiltinExecutables::createExecutable(VM& vm, const SourceCode& source, const Identifier& name, ConstructorKind constructorKind, ConstructAbility constructAbility, NeedsClassFieldInitializer needsClassFieldInitializer)
 {
     // FIXME: Can we just make MetaData computation be constexpr and have the compiler do this for us?
     // https://bugs.webkit.org/show_bug.cgi?id=193272
     // Someone should get mad at me for writing this code. But, it prevents us from recursing into
     // the parser, and hence, from throwing stack overflow when parsing a builtin.
@@ -180,11 +177,11 @@
     positionBeforeLastNewline.line = lineCount;
     positionBeforeLastNewline.offset = source.startOffset() + offsetOfLastNewline;
     positionBeforeLastNewline.lineStartOffset = source.startOffset() + positionBeforeLastNewlineLineStartOffset;
 
     SourceCode newSource = source.subExpression(source.startOffset() + parametersStart, source.startOffset() + (view.length() - closeBraceOffsetFromEnd), 0, parametersStart);
-    bool isBuiltinDefaultClassConstructor = constructorKind != ConstructorKind::None;
+    bool isBuiltinDefaultClassConstructor = constructorKind != ConstructorKind::None && constructorKind != ConstructorKind::Naked;
     UnlinkedFunctionKind kind = isBuiltinDefaultClassConstructor ? UnlinkedNormalFunction : UnlinkedBuiltinFunction;
 
     SourceParseMode parseMode = isAsyncFunction ? SourceParseMode::AsyncFunctionMode : SourceParseMode::NormalFunctionMode;
 
     JSTokenLocation start;
@@ -206,11 +203,11 @@
 
     metadata.finishParsing(newSource, Identifier(), FunctionMode::FunctionExpression);
     metadata.overrideName(name);
     metadata.setEndPosition(positionBeforeLastNewline);
 
-    if (!ASSERT_DISABLED || Options::validateBytecode()) {
+    if (UNLIKELY(ASSERT_ENABLED || Options::validateBytecode())) {
         JSTextPosition positionBeforeLastNewlineFromParser;
         ParserError error;
         JSParserBuiltinMode builtinMode = isBuiltinDefaultClassConstructor ? JSParserBuiltinMode::NotBuiltin : JSParserBuiltinMode::Builtin;
         std::unique_ptr<ProgramNode> program = parse<ProgramNode>(
             vm, source, Identifier(), builtinMode,
@@ -252,11 +249,11 @@
             RELEASE_ASSERT(error.isValid());
             RELEASE_ASSERT(error.type() == ParserError::StackOverflow);
         }
     }
 
-    UnlinkedFunctionExecutable* functionExecutable = UnlinkedFunctionExecutable::create(vm, source, &metadata, kind, constructAbility, JSParserScriptMode::Classic, WTF::nullopt, DerivedContextType::None, isBuiltinDefaultClassConstructor);
+    UnlinkedFunctionExecutable* functionExecutable = UnlinkedFunctionExecutable::create(vm, source, &metadata, kind, constructAbility, JSParserScriptMode::Classic, WTF::nullopt, DerivedContextType::None, needsClassFieldInitializer, isBuiltinDefaultClassConstructor);
     return functionExecutable;
 }
 
 void BuiltinExecutables::finalizeUnconditionally()
 {
@@ -277,11 +274,11 @@
     unsigned index = static_cast<unsigned>(BuiltinCodeIndex::name);\
     if (!m_unlinkedExecutables[index]) {\
         Identifier executableName = m_vm.propertyNames->builtinNames().functionName##PublicName();\
         if (overrideName)\
             executableName = Identifier::fromString(m_vm, overrideName);\
-        m_unlinkedExecutables[index] = createBuiltinExecutable(name##Source(), executableName, s_##name##ConstructAbility);\
+        m_unlinkedExecutables[index] = createBuiltinExecutable(name##Source(), executableName, s_##name##ConstructorKind, s_##name##ConstructAbility);\
     }\
     return m_unlinkedExecutables[index];\
 }
 JSC_FOREACH_BUILTIN_CODE(DEFINE_BUILTIN_EXECUTABLES)
 #undef DEFINE_BUILTIN_EXECUTABLES

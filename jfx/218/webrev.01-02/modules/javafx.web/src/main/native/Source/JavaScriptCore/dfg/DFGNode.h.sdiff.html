<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGNode.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGNode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGNodeFlowProjection.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGNode.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  38 #include &quot;DFGLazyJSValue.h&quot;
  39 #include &quot;DFGMultiGetByOffsetData.h&quot;
  40 #include &quot;DFGNodeFlags.h&quot;
  41 #include &quot;DFGNodeOrigin.h&quot;
  42 #include &quot;DFGNodeType.h&quot;
  43 #include &quot;DFGObjectMaterializationData.h&quot;
  44 #include &quot;DFGOpInfo.h&quot;
  45 #include &quot;DFGRegisteredStructure.h&quot;
  46 #include &quot;DFGRegisteredStructureSet.h&quot;
  47 #include &quot;DFGTransition.h&quot;
  48 #include &quot;DFGUseKind.h&quot;
  49 #include &quot;DFGVariableAccessData.h&quot;
  50 #include &quot;GetByIdVariant.h&quot;
  51 #include &quot;JSCJSValue.h&quot;
  52 #include &quot;Operands.h&quot;
  53 #include &quot;PutByIdVariant.h&quot;
  54 #include &quot;SpeculatedType.h&quot;
  55 #include &quot;TypeLocation.h&quot;
  56 #include &quot;ValueProfile.h&quot;
  57 #include &lt;type_traits&gt;

  58 #include &lt;wtf/ListDump.h&gt;
  59 #include &lt;wtf/LoggingHashSet.h&gt;
  60 
  61 namespace JSC {
  62 
  63 namespace DOMJIT {
  64 class GetterSetter;
  65 class CallDOMGetterSnippet;
  66 class Signature;
  67 }
  68 
  69 namespace Profiler {
  70 class ExecutionCounter;
  71 }
  72 
  73 class Snippet;
  74 
  75 namespace DFG {
  76 
  77 class Graph;
</pre>
<hr />
<pre>
 233 struct CallVarargsData {
 234     int firstVarArgOffset;
 235 };
 236 
 237 struct LoadVarargsData {
 238     VirtualRegister start; // Local for the first element. This is the first actual argument, not this.
 239     VirtualRegister count; // Local for the count.
 240     VirtualRegister machineStart;
 241     VirtualRegister machineCount;
 242     unsigned offset; // Which array element to start with. Usually this is 0.
 243     unsigned mandatoryMinimum; // The number of elements on the stack that must be initialized; if the array is too short then the missing elements must get undefined. Does not include &quot;this&quot;.
 244     unsigned limit; // Maximum number of elements to load. Includes &quot;this&quot;.
 245 };
 246 
 247 struct StackAccessData {
 248     StackAccessData()
 249         : format(DeadFlush)
 250     {
 251     }
 252 
<span class="line-modified"> 253     StackAccessData(VirtualRegister local, FlushFormat format)</span>
<span class="line-modified"> 254         : local(local)</span>
 255         , format(format)
 256     {
 257     }
 258 
<span class="line-modified"> 259     VirtualRegister local;</span>
 260     VirtualRegister machineLocal;
 261     FlushFormat format;
 262 
 263     FlushedAt flushedAt() { return FlushedAt(format, machineLocal); }
 264 };
 265 
 266 struct CallDOMGetterData {
 267     FunctionPtr&lt;OperationPtrTag&gt; customAccessorGetter;
 268     const DOMJIT::GetterSetter* domJIT { nullptr };
 269     DOMJIT::CallDOMGetterSnippet* snippet { nullptr };
 270     unsigned identifierNumber { 0 };
 271 };
 272 
 273 enum class BucketOwnerType : uint32_t {
 274     Map,
 275     Set
 276 };
 277 
 278 // === Node ===
 279 //
 280 // Node represents a single operation in the data flow graph.

 281 struct Node {
<span class="line-modified"> 282     WTF_MAKE_FAST_ALLOCATED;</span>
 283 public:
 284     static const char HashSetTemplateInstantiationString[];
 285 
 286     enum VarArgTag { VarArg };
 287 
 288     Node() { }
 289 
 290     Node(NodeType op, NodeOrigin nodeOrigin, const AdjacencyList&amp; children)
 291         : origin(nodeOrigin)
 292         , children(children)
 293         , m_virtualRegister(VirtualRegister())
 294         , m_refCount(1)
 295         , m_prediction(SpecNone)
 296         , owner(nullptr)
 297     {
 298         m_misc.replacement = nullptr;
 299         setOpAndDefaultFlags(op);
 300     }
 301 
 302     // Construct a node with up to 3 children, no immediate value.
</pre>
<hr />
<pre>
 461         if (SpecCellCheck &amp; SpecEmpty)
 462             setOpAndDefaultFlags(CheckStructureOrEmpty);
 463         else
 464             setOpAndDefaultFlags(CheckStructure);
 465         m_opInfo = set;
 466     }
 467 
 468     void convertCheckStructureOrEmptyToCheckStructure()
 469     {
 470         ASSERT(op() == CheckStructureOrEmpty);
 471         setOpAndDefaultFlags(CheckStructure);
 472     }
 473 
 474     void convertToCheckStructureImmediate(Node* structure)
 475     {
 476         ASSERT(op() == CheckStructure || op() == CheckStructureOrEmpty);
 477         m_op = CheckStructureImmediate;
 478         children.setChild1(Edge(structure, CellUse));
 479     }
 480 






 481     void replaceWith(Graph&amp;, Node* other);
 482     void replaceWithWithoutChecks(Node* other);
 483 
 484     void convertToIdentity();
 485     void convertToIdentityOn(Node*);
 486 
 487     bool mustGenerate()
 488     {
 489         return m_flags &amp; NodeMustGenerate;
 490     }
 491 
 492     bool isConstant()
 493     {
 494         switch (op()) {
 495         case JSConstant:
 496         case DoubleConstant:
 497         case Int52Constant:
 498             return true;
 499         default:
 500             return false;
</pre>
<hr />
<pre>
 595 
 596     void convertToPutByOffset(StorageAccessData&amp; data, Edge storage, Edge base)
 597     {
 598         ASSERT(m_op == PutById || m_op == PutByIdDirect || m_op == PutByIdFlush || m_op == MultiPutByOffset);
 599         m_opInfo = &amp;data;
 600         children.setChild3(children.child2());
 601         children.setChild2(base);
 602         children.setChild1(storage);
 603         m_op = PutByOffset;
 604     }
 605 
 606     void convertToMultiPutByOffset(MultiPutByOffsetData* data)
 607     {
 608         ASSERT(m_op == PutById || m_op == PutByIdDirect || m_op == PutByIdFlush);
 609         m_opInfo = data;
 610         m_op = MultiPutByOffset;
 611     }
 612 
 613     void convertToPhantomNewObject()
 614     {
<span class="line-modified"> 615         ASSERT(m_op == NewObject || m_op == MaterializeNewObject);</span>
 616         m_op = PhantomNewObject;
 617         m_flags &amp;= ~NodeHasVarArgs;
 618         m_flags |= NodeMustGenerate;
 619         m_opInfo = OpInfoWrapper();
 620         m_opInfo2 = OpInfoWrapper();
 621         children = AdjacencyList();
 622     }
 623 
 624     void convertToPhantomNewFunction()
 625     {
 626         ASSERT(m_op == NewFunction || m_op == NewGeneratorFunction || m_op == NewAsyncFunction || m_op == NewAsyncGeneratorFunction);
 627         m_op = PhantomNewFunction;
 628         m_flags |= NodeMustGenerate;
 629         m_opInfo = OpInfoWrapper();
 630         m_opInfo2 = OpInfoWrapper();
 631         children = AdjacencyList();
 632     }
 633 
 634     void convertToPhantomNewGeneratorFunction()
 635     {
 636         ASSERT(m_op == NewGeneratorFunction);
 637         m_op = PhantomNewGeneratorFunction;
 638         m_flags |= NodeMustGenerate;
 639         m_opInfo = OpInfoWrapper();
 640         m_opInfo2 = OpInfoWrapper();
 641         children = AdjacencyList();
 642     }
 643 











 644     void convertToPhantomNewAsyncFunction()
 645     {
 646         ASSERT(m_op == NewAsyncFunction);
 647         m_op = PhantomNewAsyncFunction;
 648         m_flags |= NodeMustGenerate;
 649         m_opInfo = OpInfoWrapper();
 650         m_opInfo2 = OpInfoWrapper();
 651         children = AdjacencyList();
 652     }
 653 
 654     void convertToPhantomNewAsyncGeneratorFunction()
 655     {
 656         ASSERT(m_op == NewAsyncGeneratorFunction);
 657         m_op = PhantomNewAsyncGeneratorFunction;
 658         m_flags |= NodeMustGenerate;
 659         m_opInfo = OpInfoWrapper();
 660         m_opInfo2 = OpInfoWrapper();
 661         children = AdjacencyList();
 662     }
 663 
 664     void convertToPhantomCreateActivation()
 665     {
<span class="line-modified"> 666         ASSERT(m_op == CreateActivation || m_op == MaterializeCreateActivation);</span>
 667         m_op = PhantomCreateActivation;
 668         m_flags &amp;= ~NodeHasVarArgs;
 669         m_flags |= NodeMustGenerate;
 670         m_opInfo = OpInfoWrapper();
 671         m_opInfo2 = OpInfoWrapper();
 672         children = AdjacencyList();
 673     }
 674 
 675     void convertToPhantomNewRegexp()
 676     {
 677         ASSERT(m_op == NewRegexp);
 678         setOpAndDefaultFlags(PhantomNewRegexp);
 679         m_opInfo = OpInfoWrapper();
 680         m_opInfo2 = OpInfoWrapper();
 681         children = AdjacencyList();
 682     }
 683 
 684     void convertPhantomToPhantomLocal()
 685     {
 686         ASSERT(m_op == Phantom &amp;&amp; (child1()-&gt;op() == Phi || child1()-&gt;op() == SetLocal || child1()-&gt;op() == SetArgumentDefinitely));
 687         m_op = PhantomLocal;
 688         m_opInfo = child1()-&gt;m_opInfo; // Copy the variableAccessData.
 689         children.setChild1(Edge());
 690     }
 691 
 692     void convertFlushToPhantomLocal()
 693     {
 694         ASSERT(m_op == Flush);
 695         m_op = PhantomLocal;
 696         children = AdjacencyList();
 697     }
 698 
 699     void convertToToString()
 700     {
<span class="line-modified"> 701         ASSERT(m_op == ToPrimitive || m_op == StringValueOf);</span>
 702         m_op = ToString;
 703     }
 704 
 705     void convertToArithNegate()
 706     {
 707         ASSERT(m_op == ArithAbs &amp;&amp; child1().useKind() == Int32Use);
 708         m_op = ArithNegate;
 709     }
 710 
 711     void convertToCompareEqPtr(FrozenValue* cell, Edge node)
 712     {
 713         ASSERT(m_op == CompareStrictEq || m_op == SameValue);
 714         setOpAndDefaultFlags(CompareEqPtr);
 715         children.setChild1(node);
 716         children.setChild2(Edge());
 717         m_opInfo = cell;
 718     }
 719 
 720     void convertToNumberToStringWithValidRadixConstant(int32_t radix)
 721     {
</pre>
<hr />
<pre>
 740         m_opInfo = globalObject;
 741     }
 742 
 743     void convertToNewStringObject(RegisteredStructure structure)
 744     {
 745         ASSERT(m_op == CallObjectConstructor || m_op == ToObject);
 746         setOpAndDefaultFlags(NewStringObject);
 747         m_opInfo = structure;
 748         m_opInfo2 = OpInfoWrapper();
 749     }
 750 
 751     void convertToNewObject(RegisteredStructure structure)
 752     {
 753         ASSERT(m_op == CallObjectConstructor || m_op == CreateThis || m_op == ObjectCreate);
 754         setOpAndDefaultFlags(NewObject);
 755         children.reset();
 756         m_opInfo = structure;
 757         m_opInfo2 = OpInfoWrapper();
 758     }
 759 



















 760     void convertToNewArrayBuffer(FrozenValue* immutableButterfly);
 761 
 762     void convertToDirectCall(FrozenValue*);
 763 
 764     void convertToCallDOM(Graph&amp;);
 765 
 766     void convertToRegExpExecNonGlobalOrStickyWithoutChecks(FrozenValue* regExp);
 767     void convertToRegExpMatchFastGlobalWithoutChecks(FrozenValue* regExp);
 768 
 769     void convertToSetRegExpObjectLastIndex()
 770     {
 771         setOp(SetRegExpObjectLastIndex);
 772         m_opInfo = false;
 773     }
 774 
 775     void convertToInById(unsigned identifierNumber)
 776     {
 777         ASSERT(m_op == InByVal);
 778         setOpAndDefaultFlags(InById);
 779         children.setChild2(Edge());
</pre>
<hr />
<pre>
 866 
 867     LazyJSValue lazyJSValue()
 868     {
 869         ASSERT(hasLazyJSValue());
 870         return *m_opInfo.as&lt;LazyJSValue*&gt;();
 871     }
 872 
 873     String tryGetString(Graph&amp;);
 874 
 875     JSValue initializationValueForActivation() const
 876     {
 877         ASSERT(op() == CreateActivation);
 878         return m_opInfo2.as&lt;FrozenValue*&gt;()-&gt;value();
 879     }
 880 
 881     bool hasArgumentsChild()
 882     {
 883         switch (op()) {
 884         case GetMyArgumentByVal:
 885         case GetMyArgumentByValOutOfBounds:

 886         case LoadVarargs:
 887         case ForwardVarargs:
 888         case CallVarargs:
 889         case CallForwardVarargs:
 890         case ConstructVarargs:
 891         case ConstructForwardVarargs:
 892         case TailCallVarargs:
 893         case TailCallForwardVarargs:
 894         case TailCallVarargsInlinedCaller:
 895         case TailCallForwardVarargsInlinedCaller:
 896             return true;
 897         default:
 898             return false;
 899         }
 900     }
 901 
 902     Edge&amp; argumentsChild()
 903     {
 904         switch (op()) {
 905         case GetMyArgumentByVal:
 906         case GetMyArgumentByValOutOfBounds:


 907         case LoadVarargs:
 908         case ForwardVarargs:
<span class="line-modified"> 909             return child1();</span>
 910         case CallVarargs:
 911         case CallForwardVarargs:
 912         case ConstructVarargs:
 913         case ConstructForwardVarargs:
 914         case TailCallVarargs:
 915         case TailCallForwardVarargs:
 916         case TailCallVarargsInlinedCaller:
 917         case TailCallForwardVarargsInlinedCaller:
 918             return child3();
 919         default:
 920             RELEASE_ASSERT_NOT_REACHED();
 921             return child1();
 922         }
 923     }
 924 
 925     bool containsMovHint()
 926     {
 927         switch (op()) {
 928         case MovHint:
 929         case ZombieHint:
</pre>
<hr />
<pre>
 937     bool accessesStack(Graph&amp; graph)
 938     {
 939         return hasVariableAccessData(graph);
 940     }
 941 
 942     // This is useful for debugging code, where a node that should have a variable
 943     // access data doesn&#39;t have one because it hasn&#39;t been initialized yet.
 944     VariableAccessData* tryGetVariableAccessData()
 945     {
 946         VariableAccessData* result = m_opInfo.as&lt;VariableAccessData*&gt;();
 947         if (!result)
 948             return 0;
 949         return result-&gt;find();
 950     }
 951 
 952     VariableAccessData* variableAccessData()
 953     {
 954         return m_opInfo.as&lt;VariableAccessData*&gt;()-&gt;find();
 955     }
 956 
<span class="line-modified"> 957     VirtualRegister local()</span>
 958     {
<span class="line-modified"> 959         return variableAccessData()-&gt;local();</span>
 960     }
 961 
 962     VirtualRegister machineLocal()
 963     {
 964         return variableAccessData()-&gt;machineLocal();
 965     }
 966 
<span class="line-modified"> 967     bool hasUnlinkedLocal()</span>
 968     {
 969         switch (op()) {
 970         case ExtractOSREntryLocal:
 971         case MovHint:
 972         case ZombieHint:
 973         case KillStack:
 974             return true;
 975         default:
 976             return false;
 977         }
 978     }
 979 
<span class="line-modified"> 980     VirtualRegister unlinkedLocal()</span>
 981     {
<span class="line-modified"> 982         ASSERT(hasUnlinkedLocal());</span>
<span class="line-modified"> 983         return VirtualRegister(m_opInfo.as&lt;int32_t&gt;());</span>
 984     }
 985 
 986     bool hasStackAccessData()
 987     {
 988         switch (op()) {
 989         case PutStack:
 990         case GetStack:
 991             return true;
 992         default:
 993             return false;
 994         }
 995     }
 996 
 997     StackAccessData* stackAccessData()
 998     {
 999         ASSERT(hasStackAccessData());
1000         return m_opInfo.as&lt;StackAccessData*&gt;();
1001     }
1002 
1003     unsigned argumentCountIncludingThis()
</pre>
<hr />
<pre>
1229 
1230     TypedArrayType typedArrayType()
1231     {
1232         ASSERT(hasTypedArrayType());
1233         TypedArrayType result = static_cast&lt;TypedArrayType&gt;(m_opInfo.as&lt;uint32_t&gt;());
1234         ASSERT(isTypedView(result));
1235         return result;
1236     }
1237 
1238     bool hasInlineCapacity()
1239     {
1240         return op() == CreateThis;
1241     }
1242 
1243     unsigned inlineCapacity()
1244     {
1245         ASSERT(hasInlineCapacity());
1246         return m_opInfo.as&lt;unsigned&gt;();
1247     }
1248 











1249     void setIndexingType(IndexingType indexingType)
1250     {
1251         ASSERT(hasIndexingType());
1252         m_opInfo = indexingType;
1253     }
1254 
1255     bool hasScopeOffset()
1256     {
1257         return op() == GetClosureVar || op() == PutClosureVar;
1258     }
1259 
1260     ScopeOffset scopeOffset()
1261     {
1262         ASSERT(hasScopeOffset());
1263         return ScopeOffset(m_opInfo.as&lt;uint32_t&gt;());
1264     }
1265 











1266     bool hasDirectArgumentsOffset()
1267     {
1268         return op() == GetFromArguments || op() == PutToArguments;
1269     }
1270 
1271     DirectArgumentsOffset capturedArgumentsOffset()
1272     {
1273         ASSERT(hasDirectArgumentsOffset());
1274         return DirectArgumentsOffset(m_opInfo.as&lt;uint32_t&gt;());
1275     }
1276 
1277     bool hasRegisterPointer()
1278     {
1279         return op() == GetGlobalVar || op() == GetGlobalLexicalVariable || op() == PutGlobalVariable;
1280     }
1281 
1282     WriteBarrier&lt;Unknown&gt;* variablePointer()
1283     {
1284         return m_opInfo.as&lt;WriteBarrier&lt;Unknown&gt;*&gt;();
1285     }
</pre>
<hr />
<pre>
1292         case TailCallVarargs:
1293         case TailCallForwardVarargs:
1294         case TailCallVarargsInlinedCaller:
1295         case TailCallForwardVarargsInlinedCaller:
1296         case ConstructVarargs:
1297         case ConstructForwardVarargs:
1298             return true;
1299         default:
1300             return false;
1301         }
1302     }
1303 
1304     CallVarargsData* callVarargsData()
1305     {
1306         ASSERT(hasCallVarargsData());
1307         return m_opInfo.as&lt;CallVarargsData*&gt;();
1308     }
1309 
1310     bool hasLoadVarargsData()
1311     {
<span class="line-modified">1312         return op() == LoadVarargs || op() == ForwardVarargs;</span>
1313     }
1314 
1315     LoadVarargsData* loadVarargsData()
1316     {
1317         ASSERT(hasLoadVarargsData());
1318         return m_opInfo.as&lt;LoadVarargsData*&gt;();
1319     }
1320 
1321     InlineCallFrame* argumentsInlineCallFrame()
1322     {
1323         ASSERT(op() == GetArgumentCountIncludingThis);
1324         return m_opInfo.as&lt;InlineCallFrame*&gt;();
1325     }
1326 
1327     bool hasQueriedType()
1328     {
1329         return op() == IsCellWithType;
1330     }
1331 
1332     JSType queriedType()
1333     {
1334         static_assert(std::is_same&lt;uint8_t, std::underlying_type&lt;JSType&gt;::type&gt;::value, &quot;Ensure that uint8_t is the underlying type for JSType.&quot;);
1335         return static_cast&lt;JSType&gt;(m_opInfo.as&lt;uint32_t&gt;());
1336     }
1337 
1338     bool hasSpeculatedTypeForQuery()
1339     {
1340         return op() == IsCellWithType;
1341     }
1342 
<span class="line-modified">1343     SpeculatedType speculatedTypeForQuery()</span>
1344     {
1345         return speculationFromJSType(queriedType());
1346     }
1347 
1348     bool hasResult()
1349     {
1350         return !!result();
1351     }
1352 
1353     bool hasInt32Result()
1354     {
1355         return result() == NodeResultInt32;
1356     }
1357 
1358     bool hasInt52Result()
1359     {
1360         return result() == NodeResultInt52;
1361     }
1362 
1363     bool hasNumberResult()
1364     {
1365         return result() == NodeResultNumber;
1366     }
1367 
1368     bool hasNumberOrAnyIntResult()
1369     {
1370         return hasNumberResult() || hasInt32Result() || hasInt52Result();
1371     }
1372 
1373     bool hasNumericResult()
1374     {
1375         switch (op()) {
1376         case ValueSub:
1377         case ValueMul:
1378         case ValueBitAnd:
1379         case ValueBitOr:
1380         case ValueBitXor:



1381         case ValueNegate:
1382             return true;
1383         default:
1384             return false;
1385         }
1386     }
1387 
1388     bool hasDoubleResult()
1389     {
1390         return result() == NodeResultDouble;
1391     }
1392 
1393     bool hasJSResult()
1394     {
1395         return result() == NodeResultJS;
1396     }
1397 
1398     bool hasBooleanResult()
1399     {
1400         return result() == NodeResultBoolean;
</pre>
<hr />
<pre>
1493     }
1494 
1495     BranchData* branchData()
1496     {
1497         ASSERT(isBranch());
1498         return m_opInfo.as&lt;BranchData*&gt;();
1499     }
1500 
1501     SwitchData* switchData()
1502     {
1503         ASSERT(isSwitch());
1504         return m_opInfo.as&lt;SwitchData*&gt;();
1505     }
1506 
1507     EntrySwitchData* entrySwitchData()
1508     {
1509         ASSERT(isEntrySwitch());
1510         return m_opInfo.as&lt;EntrySwitchData*&gt;();
1511     }
1512 












1513     Intrinsic intrinsic()
1514     {
<span class="line-modified">1515         RELEASE_ASSERT(op() == CPUIntrinsic);</span>
1516         return m_opInfo.as&lt;Intrinsic&gt;();
1517     }
1518 
1519     unsigned numSuccessors()
1520     {
1521         switch (op()) {
1522         case Jump:
1523             return 1;
1524         case Branch:
1525             return 2;
1526         case Switch:
1527             return switchData()-&gt;cases.size() + 1;
1528         case EntrySwitch:
1529             return entrySwitchData()-&gt;cases.size();
1530         default:
1531             return 0;
1532         }
1533     }
1534 
1535     BasicBlock*&amp; successor(unsigned index)
</pre>
<hr />
<pre>
1650         case GetByIdDirectFlush:
1651         case GetPrototypeOf:
1652         case TryGetById:
1653         case GetByVal:
1654         case GetByValWithThis:
1655         case Call:
1656         case DirectCall:
1657         case TailCallInlinedCaller:
1658         case DirectTailCallInlinedCaller:
1659         case Construct:
1660         case DirectConstruct:
1661         case CallVarargs:
1662         case CallEval:
1663         case TailCallVarargsInlinedCaller:
1664         case ConstructVarargs:
1665         case CallForwardVarargs:
1666         case TailCallForwardVarargsInlinedCaller:
1667         case GetByOffset:
1668         case MultiGetByOffset:
1669         case GetClosureVar:

1670         case GetFromArguments:
1671         case GetArgument:
1672         case ArrayPop:
1673         case ArrayPush:
1674         case RegExpExec:
1675         case RegExpExecNonGlobalOrSticky:
1676         case RegExpTest:
1677         case RegExpMatchFast:
1678         case RegExpMatchFastGlobal:
1679         case GetGlobalVar:
1680         case GetGlobalLexicalVariable:
1681         case StringReplace:
1682         case StringReplaceRegExp:
1683         case ToNumber:

1684         case ToObject:
1685         case ValueBitAnd:
1686         case ValueBitOr:
1687         case ValueBitXor:
1688         case ValueBitNot:
1689         case ValueBitLShift:

1690         case CallObjectConstructor:
1691         case LoadKeyFromMapBucket:
1692         case LoadValueFromMapBucket:
1693         case CallDOMGetter:
1694         case CallDOM:
1695         case ParseInt:
1696         case AtomicsAdd:
1697         case AtomicsAnd:
1698         case AtomicsCompareExchange:
1699         case AtomicsExchange:
1700         case AtomicsLoad:
1701         case AtomicsOr:
1702         case AtomicsStore:
1703         case AtomicsSub:
1704         case AtomicsXor:
1705         case GetDynamicVar:
1706         case ExtractValueFromWeakMapGet:
1707         case ToThis:
1708         case DataViewGetInt:
1709         case DataViewGetFloat:

1710             return true;
1711         default:
1712             return false;
1713         }
1714     }
1715 
1716     SpeculatedType getHeapPrediction()
1717     {
1718         ASSERT(hasHeapPrediction());
1719         return m_opInfo2.as&lt;SpeculatedType&gt;();
1720     }
1721 
1722     void setHeapPrediction(SpeculatedType prediction)
1723     {
1724         ASSERT(hasHeapPrediction());
1725         m_opInfo2 = prediction;
1726     }
1727 
1728     SpeculatedType getForcedPrediction()
1729     {
</pre>
<hr />
<pre>
1796 
1797     WatchpointSet* watchpointSet()
1798     {
1799         ASSERT(hasWatchpointSet());
1800         return m_opInfo.as&lt;WatchpointSet*&gt;();
1801     }
1802 
1803     bool hasStoragePointer()
1804     {
1805         return op() == ConstantStoragePointer;
1806     }
1807 
1808     void* storagePointer()
1809     {
1810         ASSERT(hasStoragePointer());
1811         return m_opInfo.as&lt;void*&gt;();
1812     }
1813 
1814     bool hasUidOperand()
1815     {
<span class="line-modified">1816         return op() == CheckStringIdent;</span>
1817     }
1818 
1819     UniquedStringImpl* uidOperand()
1820     {
1821         ASSERT(hasUidOperand());
1822         return m_opInfo.as&lt;UniquedStringImpl*&gt;();
1823     }
1824 
1825     bool hasTypeInfoOperand()
1826     {
1827         return op() == CheckTypeInfoFlags;
1828     }
1829 
1830     unsigned typeInfoOperand()
1831     {
1832         ASSERT(hasTypeInfoOperand() &amp;&amp; m_opInfo.as&lt;uint32_t&gt;() &lt;= static_cast&lt;uint32_t&gt;(UCHAR_MAX));
1833         return m_opInfo.as&lt;uint32_t&gt;();
1834     }
1835 
1836     bool hasTransition()
</pre>
<hr />
<pre>
1857         case CheckStructure:
1858         case CheckStructureOrEmpty:
1859         case CheckStructureImmediate:
1860         case MaterializeNewObject:
1861             return true;
1862         default:
1863             return false;
1864         }
1865     }
1866 
1867     const RegisteredStructureSet&amp; structureSet()
1868     {
1869         ASSERT(hasStructureSet());
1870         return *m_opInfo.as&lt;RegisteredStructureSet*&gt;();
1871     }
1872 
1873     bool hasStructure()
1874     {
1875         switch (op()) {
1876         case ArrayifyToStructure:

1877         case NewObject:




1878         case NewStringObject:
1879             return true;
1880         default:
1881             return false;
1882         }
1883     }
1884 
1885     RegisteredStructure structure()
1886     {
1887         ASSERT(hasStructure());
1888         return m_opInfo.asRegisteredStructure();
1889     }
1890 
1891     bool hasStorageAccessData()
1892     {
1893         switch (op()) {
1894         case GetByOffset:
1895         case PutByOffset:
1896         case GetGetterSetterByOffset:
1897             return true;
</pre>
<hr />
<pre>
1926     {
1927         ASSERT(hasMultiPutByOffsetData());
1928         return *m_opInfo.as&lt;MultiPutByOffsetData*&gt;();
1929     }
1930 
1931     bool hasMatchStructureData()
1932     {
1933         return op() == MatchStructure;
1934     }
1935 
1936     MatchStructureData&amp; matchStructureData()
1937     {
1938         ASSERT(hasMatchStructureData());
1939         return *m_opInfo.as&lt;MatchStructureData*&gt;();
1940     }
1941 
1942     bool hasObjectMaterializationData()
1943     {
1944         switch (op()) {
1945         case MaterializeNewObject:

1946         case MaterializeCreateActivation:
1947             return true;
1948 
1949         default:
1950             return false;
1951         }
1952     }
1953 
1954     ObjectMaterializationData&amp; objectMaterializationData()
1955     {
1956         ASSERT(hasObjectMaterializationData());
1957         return *m_opInfo2.as&lt;ObjectMaterializationData*&gt;();
1958     }
1959 
1960     bool isObjectAllocation()
1961     {
1962         switch (op()) {
1963         case NewObject:
1964         case MaterializeNewObject:
1965             return true;
</pre>
<hr />
<pre>
2022             return true;
2023         default:
2024             return false;
2025         }
2026     }
2027 
2028     bool isPhantomAllocation()
2029     {
2030         switch (op()) {
2031         case PhantomNewObject:
2032         case PhantomDirectArguments:
2033         case PhantomCreateRest:
2034         case PhantomSpread:
2035         case PhantomNewArrayWithSpread:
2036         case PhantomNewArrayBuffer:
2037         case PhantomClonedArguments:
2038         case PhantomNewFunction:
2039         case PhantomNewGeneratorFunction:
2040         case PhantomNewAsyncFunction:
2041         case PhantomNewAsyncGeneratorFunction:

2042         case PhantomCreateActivation:
2043         case PhantomNewRegexp:
2044             return true;
2045         default:
2046             return false;
2047         }
2048     }
2049 
2050     bool hasArrayMode()
2051     {
2052         switch (op()) {
2053         case GetIndexedPropertyStorage:
2054         case GetArrayLength:
2055         case GetVectorLength:
2056         case InByVal:
2057         case PutByValDirect:
2058         case PutByVal:
2059         case PutByValAlias:
2060         case GetByVal:
2061         case StringCharAt:
2062         case StringCharCodeAt:

2063         case CheckArray:

2064         case Arrayify:
2065         case ArrayifyToStructure:
2066         case ArrayPush:
2067         case ArrayPop:
2068         case ArrayIndexOf:
2069         case HasIndexedProperty:
2070         case AtomicsAdd:
2071         case AtomicsAnd:
2072         case AtomicsCompareExchange:
2073         case AtomicsExchange:
2074         case AtomicsLoad:
2075         case AtomicsOr:
2076         case AtomicsStore:
2077         case AtomicsSub:
2078         case AtomicsXor:
2079             return true;
2080         default:
2081             return false;
2082         }
2083     }
</pre>
<hr />
<pre>
2835         return m_opInfo.as&lt;uint32_t&gt;();
2836     }
2837 
2838     uint32_t errorType()
2839     {
2840         ASSERT(op() == ThrowStaticError);
2841         return m_opInfo.as&lt;uint32_t&gt;();
2842     }
2843 
2844     bool hasCallLinkStatus()
2845     {
2846         return op() == FilterCallLinkStatus;
2847     }
2848 
2849     CallLinkStatus* callLinkStatus()
2850     {
2851         ASSERT(hasCallLinkStatus());
2852         return m_opInfo.as&lt;CallLinkStatus*&gt;();
2853     }
2854 
<span class="line-modified">2855     bool hasGetByIdStatus()</span>
2856     {
<span class="line-modified">2857         return op() == FilterGetByIdStatus;</span>
2858     }
2859 
<span class="line-modified">2860     GetByIdStatus* getByIdStatus()</span>
2861     {
<span class="line-modified">2862         ASSERT(hasGetByIdStatus());</span>
<span class="line-modified">2863         return m_opInfo.as&lt;GetByIdStatus*&gt;();</span>
2864     }
2865 
2866     bool hasInByIdStatus()
2867     {
2868         return op() == FilterInByIdStatus;
2869     }
2870 
2871     InByIdStatus* inByIdStatus()
2872     {
2873         ASSERT(hasInByIdStatus());
2874         return m_opInfo.as&lt;InByIdStatus*&gt;();
2875     }
2876 
2877     bool hasPutByIdStatus()
2878     {
2879         return op() == FilterPutByIdStatus;
2880     }
2881 
2882     PutByIdStatus* putByIdStatus()
2883     {
</pre>
</td>
<td>
<hr />
<pre>
  38 #include &quot;DFGLazyJSValue.h&quot;
  39 #include &quot;DFGMultiGetByOffsetData.h&quot;
  40 #include &quot;DFGNodeFlags.h&quot;
  41 #include &quot;DFGNodeOrigin.h&quot;
  42 #include &quot;DFGNodeType.h&quot;
  43 #include &quot;DFGObjectMaterializationData.h&quot;
  44 #include &quot;DFGOpInfo.h&quot;
  45 #include &quot;DFGRegisteredStructure.h&quot;
  46 #include &quot;DFGRegisteredStructureSet.h&quot;
  47 #include &quot;DFGTransition.h&quot;
  48 #include &quot;DFGUseKind.h&quot;
  49 #include &quot;DFGVariableAccessData.h&quot;
  50 #include &quot;GetByIdVariant.h&quot;
  51 #include &quot;JSCJSValue.h&quot;
  52 #include &quot;Operands.h&quot;
  53 #include &quot;PutByIdVariant.h&quot;
  54 #include &quot;SpeculatedType.h&quot;
  55 #include &quot;TypeLocation.h&quot;
  56 #include &quot;ValueProfile.h&quot;
  57 #include &lt;type_traits&gt;
<span class="line-added">  58 #include &lt;wtf/FastMalloc.h&gt;</span>
  59 #include &lt;wtf/ListDump.h&gt;
  60 #include &lt;wtf/LoggingHashSet.h&gt;
  61 
  62 namespace JSC {
  63 
  64 namespace DOMJIT {
  65 class GetterSetter;
  66 class CallDOMGetterSnippet;
  67 class Signature;
  68 }
  69 
  70 namespace Profiler {
  71 class ExecutionCounter;
  72 }
  73 
  74 class Snippet;
  75 
  76 namespace DFG {
  77 
  78 class Graph;
</pre>
<hr />
<pre>
 234 struct CallVarargsData {
 235     int firstVarArgOffset;
 236 };
 237 
 238 struct LoadVarargsData {
 239     VirtualRegister start; // Local for the first element. This is the first actual argument, not this.
 240     VirtualRegister count; // Local for the count.
 241     VirtualRegister machineStart;
 242     VirtualRegister machineCount;
 243     unsigned offset; // Which array element to start with. Usually this is 0.
 244     unsigned mandatoryMinimum; // The number of elements on the stack that must be initialized; if the array is too short then the missing elements must get undefined. Does not include &quot;this&quot;.
 245     unsigned limit; // Maximum number of elements to load. Includes &quot;this&quot;.
 246 };
 247 
 248 struct StackAccessData {
 249     StackAccessData()
 250         : format(DeadFlush)
 251     {
 252     }
 253 
<span class="line-modified"> 254     StackAccessData(Operand operand, FlushFormat format)</span>
<span class="line-modified"> 255         : operand(operand)</span>
 256         , format(format)
 257     {
 258     }
 259 
<span class="line-modified"> 260     Operand operand;</span>
 261     VirtualRegister machineLocal;
 262     FlushFormat format;
 263 
 264     FlushedAt flushedAt() { return FlushedAt(format, machineLocal); }
 265 };
 266 
 267 struct CallDOMGetterData {
 268     FunctionPtr&lt;OperationPtrTag&gt; customAccessorGetter;
 269     const DOMJIT::GetterSetter* domJIT { nullptr };
 270     DOMJIT::CallDOMGetterSnippet* snippet { nullptr };
 271     unsigned identifierNumber { 0 };
 272 };
 273 
 274 enum class BucketOwnerType : uint32_t {
 275     Map,
 276     Set
 277 };
 278 
 279 // === Node ===
 280 //
 281 // Node represents a single operation in the data flow graph.
<span class="line-added"> 282 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(DFGNode);</span>
 283 struct Node {
<span class="line-modified"> 284     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(DFGNode);</span>
 285 public:
 286     static const char HashSetTemplateInstantiationString[];
 287 
 288     enum VarArgTag { VarArg };
 289 
 290     Node() { }
 291 
 292     Node(NodeType op, NodeOrigin nodeOrigin, const AdjacencyList&amp; children)
 293         : origin(nodeOrigin)
 294         , children(children)
 295         , m_virtualRegister(VirtualRegister())
 296         , m_refCount(1)
 297         , m_prediction(SpecNone)
 298         , owner(nullptr)
 299     {
 300         m_misc.replacement = nullptr;
 301         setOpAndDefaultFlags(op);
 302     }
 303 
 304     // Construct a node with up to 3 children, no immediate value.
</pre>
<hr />
<pre>
 463         if (SpecCellCheck &amp; SpecEmpty)
 464             setOpAndDefaultFlags(CheckStructureOrEmpty);
 465         else
 466             setOpAndDefaultFlags(CheckStructure);
 467         m_opInfo = set;
 468     }
 469 
 470     void convertCheckStructureOrEmptyToCheckStructure()
 471     {
 472         ASSERT(op() == CheckStructureOrEmpty);
 473         setOpAndDefaultFlags(CheckStructure);
 474     }
 475 
 476     void convertToCheckStructureImmediate(Node* structure)
 477     {
 478         ASSERT(op() == CheckStructure || op() == CheckStructureOrEmpty);
 479         m_op = CheckStructureImmediate;
 480         children.setChild1(Edge(structure, CellUse));
 481     }
 482 
<span class="line-added"> 483     void convertCheckArrayOrEmptyToCheckArray()</span>
<span class="line-added"> 484     {</span>
<span class="line-added"> 485         ASSERT(op() == CheckArrayOrEmpty);</span>
<span class="line-added"> 486         setOpAndDefaultFlags(CheckArray);</span>
<span class="line-added"> 487     }</span>
<span class="line-added"> 488 </span>
 489     void replaceWith(Graph&amp;, Node* other);
 490     void replaceWithWithoutChecks(Node* other);
 491 
 492     void convertToIdentity();
 493     void convertToIdentityOn(Node*);
 494 
 495     bool mustGenerate()
 496     {
 497         return m_flags &amp; NodeMustGenerate;
 498     }
 499 
 500     bool isConstant()
 501     {
 502         switch (op()) {
 503         case JSConstant:
 504         case DoubleConstant:
 505         case Int52Constant:
 506             return true;
 507         default:
 508             return false;
</pre>
<hr />
<pre>
 603 
 604     void convertToPutByOffset(StorageAccessData&amp; data, Edge storage, Edge base)
 605     {
 606         ASSERT(m_op == PutById || m_op == PutByIdDirect || m_op == PutByIdFlush || m_op == MultiPutByOffset);
 607         m_opInfo = &amp;data;
 608         children.setChild3(children.child2());
 609         children.setChild2(base);
 610         children.setChild1(storage);
 611         m_op = PutByOffset;
 612     }
 613 
 614     void convertToMultiPutByOffset(MultiPutByOffsetData* data)
 615     {
 616         ASSERT(m_op == PutById || m_op == PutByIdDirect || m_op == PutByIdFlush);
 617         m_opInfo = data;
 618         m_op = MultiPutByOffset;
 619     }
 620 
 621     void convertToPhantomNewObject()
 622     {
<span class="line-modified"> 623         ASSERT(m_op == NewObject);</span>
 624         m_op = PhantomNewObject;
 625         m_flags &amp;= ~NodeHasVarArgs;
 626         m_flags |= NodeMustGenerate;
 627         m_opInfo = OpInfoWrapper();
 628         m_opInfo2 = OpInfoWrapper();
 629         children = AdjacencyList();
 630     }
 631 
 632     void convertToPhantomNewFunction()
 633     {
 634         ASSERT(m_op == NewFunction || m_op == NewGeneratorFunction || m_op == NewAsyncFunction || m_op == NewAsyncGeneratorFunction);
 635         m_op = PhantomNewFunction;
 636         m_flags |= NodeMustGenerate;
 637         m_opInfo = OpInfoWrapper();
 638         m_opInfo2 = OpInfoWrapper();
 639         children = AdjacencyList();
 640     }
 641 
 642     void convertToPhantomNewGeneratorFunction()
 643     {
 644         ASSERT(m_op == NewGeneratorFunction);
 645         m_op = PhantomNewGeneratorFunction;
 646         m_flags |= NodeMustGenerate;
 647         m_opInfo = OpInfoWrapper();
 648         m_opInfo2 = OpInfoWrapper();
 649         children = AdjacencyList();
 650     }
 651 
<span class="line-added"> 652     void convertToPhantomNewArrayIterator()</span>
<span class="line-added"> 653     {</span>
<span class="line-added"> 654         ASSERT(m_op == NewArrayIterator);</span>
<span class="line-added"> 655         m_op = PhantomNewArrayIterator;</span>
<span class="line-added"> 656         m_flags &amp;= ~NodeHasVarArgs;</span>
<span class="line-added"> 657         m_flags |= NodeMustGenerate;</span>
<span class="line-added"> 658         m_opInfo = OpInfoWrapper();</span>
<span class="line-added"> 659         m_opInfo2 = OpInfoWrapper();</span>
<span class="line-added"> 660         children = AdjacencyList();</span>
<span class="line-added"> 661     }</span>
<span class="line-added"> 662 </span>
 663     void convertToPhantomNewAsyncFunction()
 664     {
 665         ASSERT(m_op == NewAsyncFunction);
 666         m_op = PhantomNewAsyncFunction;
 667         m_flags |= NodeMustGenerate;
 668         m_opInfo = OpInfoWrapper();
 669         m_opInfo2 = OpInfoWrapper();
 670         children = AdjacencyList();
 671     }
 672 
 673     void convertToPhantomNewAsyncGeneratorFunction()
 674     {
 675         ASSERT(m_op == NewAsyncGeneratorFunction);
 676         m_op = PhantomNewAsyncGeneratorFunction;
 677         m_flags |= NodeMustGenerate;
 678         m_opInfo = OpInfoWrapper();
 679         m_opInfo2 = OpInfoWrapper();
 680         children = AdjacencyList();
 681     }
 682 
 683     void convertToPhantomCreateActivation()
 684     {
<span class="line-modified"> 685         ASSERT(m_op == CreateActivation);</span>
 686         m_op = PhantomCreateActivation;
 687         m_flags &amp;= ~NodeHasVarArgs;
 688         m_flags |= NodeMustGenerate;
 689         m_opInfo = OpInfoWrapper();
 690         m_opInfo2 = OpInfoWrapper();
 691         children = AdjacencyList();
 692     }
 693 
 694     void convertToPhantomNewRegexp()
 695     {
 696         ASSERT(m_op == NewRegexp);
 697         setOpAndDefaultFlags(PhantomNewRegexp);
 698         m_opInfo = OpInfoWrapper();
 699         m_opInfo2 = OpInfoWrapper();
 700         children = AdjacencyList();
 701     }
 702 
 703     void convertPhantomToPhantomLocal()
 704     {
 705         ASSERT(m_op == Phantom &amp;&amp; (child1()-&gt;op() == Phi || child1()-&gt;op() == SetLocal || child1()-&gt;op() == SetArgumentDefinitely));
 706         m_op = PhantomLocal;
 707         m_opInfo = child1()-&gt;m_opInfo; // Copy the variableAccessData.
 708         children.setChild1(Edge());
 709     }
 710 
 711     void convertFlushToPhantomLocal()
 712     {
 713         ASSERT(m_op == Flush);
 714         m_op = PhantomLocal;
 715         children = AdjacencyList();
 716     }
 717 
 718     void convertToToString()
 719     {
<span class="line-modified"> 720         ASSERT(m_op == ToPrimitive || m_op == StringValueOf || m_op == ToPropertyKey);</span>
 721         m_op = ToString;
 722     }
 723 
 724     void convertToArithNegate()
 725     {
 726         ASSERT(m_op == ArithAbs &amp;&amp; child1().useKind() == Int32Use);
 727         m_op = ArithNegate;
 728     }
 729 
 730     void convertToCompareEqPtr(FrozenValue* cell, Edge node)
 731     {
 732         ASSERT(m_op == CompareStrictEq || m_op == SameValue);
 733         setOpAndDefaultFlags(CompareEqPtr);
 734         children.setChild1(node);
 735         children.setChild2(Edge());
 736         m_opInfo = cell;
 737     }
 738 
 739     void convertToNumberToStringWithValidRadixConstant(int32_t radix)
 740     {
</pre>
<hr />
<pre>
 759         m_opInfo = globalObject;
 760     }
 761 
 762     void convertToNewStringObject(RegisteredStructure structure)
 763     {
 764         ASSERT(m_op == CallObjectConstructor || m_op == ToObject);
 765         setOpAndDefaultFlags(NewStringObject);
 766         m_opInfo = structure;
 767         m_opInfo2 = OpInfoWrapper();
 768     }
 769 
 770     void convertToNewObject(RegisteredStructure structure)
 771     {
 772         ASSERT(m_op == CallObjectConstructor || m_op == CreateThis || m_op == ObjectCreate);
 773         setOpAndDefaultFlags(NewObject);
 774         children.reset();
 775         m_opInfo = structure;
 776         m_opInfo2 = OpInfoWrapper();
 777     }
 778 
<span class="line-added"> 779     void convertToNewPromise(RegisteredStructure structure)</span>
<span class="line-added"> 780     {</span>
<span class="line-added"> 781         ASSERT(m_op == CreatePromise);</span>
<span class="line-added"> 782         bool internal = isInternalPromise();</span>
<span class="line-added"> 783         setOpAndDefaultFlags(NewPromise);</span>
<span class="line-added"> 784         children.reset();</span>
<span class="line-added"> 785         m_opInfo = structure;</span>
<span class="line-added"> 786         m_opInfo2 = internal;</span>
<span class="line-added"> 787     }</span>
<span class="line-added"> 788 </span>
<span class="line-added"> 789     void convertToNewInternalFieldObject(NodeType newOp, RegisteredStructure structure)</span>
<span class="line-added"> 790     {</span>
<span class="line-added"> 791         ASSERT(m_op == CreateAsyncGenerator || m_op == CreateGenerator);</span>
<span class="line-added"> 792         setOpAndDefaultFlags(newOp);</span>
<span class="line-added"> 793         children.reset();</span>
<span class="line-added"> 794         m_opInfo = structure;</span>
<span class="line-added"> 795         m_opInfo2 = OpInfoWrapper();</span>
<span class="line-added"> 796     }</span>
<span class="line-added"> 797 </span>
 798     void convertToNewArrayBuffer(FrozenValue* immutableButterfly);
 799 
 800     void convertToDirectCall(FrozenValue*);
 801 
 802     void convertToCallDOM(Graph&amp;);
 803 
 804     void convertToRegExpExecNonGlobalOrStickyWithoutChecks(FrozenValue* regExp);
 805     void convertToRegExpMatchFastGlobalWithoutChecks(FrozenValue* regExp);
 806 
 807     void convertToSetRegExpObjectLastIndex()
 808     {
 809         setOp(SetRegExpObjectLastIndex);
 810         m_opInfo = false;
 811     }
 812 
 813     void convertToInById(unsigned identifierNumber)
 814     {
 815         ASSERT(m_op == InByVal);
 816         setOpAndDefaultFlags(InById);
 817         children.setChild2(Edge());
</pre>
<hr />
<pre>
 904 
 905     LazyJSValue lazyJSValue()
 906     {
 907         ASSERT(hasLazyJSValue());
 908         return *m_opInfo.as&lt;LazyJSValue*&gt;();
 909     }
 910 
 911     String tryGetString(Graph&amp;);
 912 
 913     JSValue initializationValueForActivation() const
 914     {
 915         ASSERT(op() == CreateActivation);
 916         return m_opInfo2.as&lt;FrozenValue*&gt;()-&gt;value();
 917     }
 918 
 919     bool hasArgumentsChild()
 920     {
 921         switch (op()) {
 922         case GetMyArgumentByVal:
 923         case GetMyArgumentByValOutOfBounds:
<span class="line-added"> 924         case VarargsLength:</span>
 925         case LoadVarargs:
 926         case ForwardVarargs:
 927         case CallVarargs:
 928         case CallForwardVarargs:
 929         case ConstructVarargs:
 930         case ConstructForwardVarargs:
 931         case TailCallVarargs:
 932         case TailCallForwardVarargs:
 933         case TailCallVarargsInlinedCaller:
 934         case TailCallForwardVarargsInlinedCaller:
 935             return true;
 936         default:
 937             return false;
 938         }
 939     }
 940 
 941     Edge&amp; argumentsChild()
 942     {
 943         switch (op()) {
 944         case GetMyArgumentByVal:
 945         case GetMyArgumentByValOutOfBounds:
<span class="line-added"> 946         case VarargsLength:</span>
<span class="line-added"> 947             return child1();</span>
 948         case LoadVarargs:
 949         case ForwardVarargs:
<span class="line-modified"> 950             return child2();</span>
 951         case CallVarargs:
 952         case CallForwardVarargs:
 953         case ConstructVarargs:
 954         case ConstructForwardVarargs:
 955         case TailCallVarargs:
 956         case TailCallForwardVarargs:
 957         case TailCallVarargsInlinedCaller:
 958         case TailCallForwardVarargsInlinedCaller:
 959             return child3();
 960         default:
 961             RELEASE_ASSERT_NOT_REACHED();
 962             return child1();
 963         }
 964     }
 965 
 966     bool containsMovHint()
 967     {
 968         switch (op()) {
 969         case MovHint:
 970         case ZombieHint:
</pre>
<hr />
<pre>
 978     bool accessesStack(Graph&amp; graph)
 979     {
 980         return hasVariableAccessData(graph);
 981     }
 982 
 983     // This is useful for debugging code, where a node that should have a variable
 984     // access data doesn&#39;t have one because it hasn&#39;t been initialized yet.
 985     VariableAccessData* tryGetVariableAccessData()
 986     {
 987         VariableAccessData* result = m_opInfo.as&lt;VariableAccessData*&gt;();
 988         if (!result)
 989             return 0;
 990         return result-&gt;find();
 991     }
 992 
 993     VariableAccessData* variableAccessData()
 994     {
 995         return m_opInfo.as&lt;VariableAccessData*&gt;()-&gt;find();
 996     }
 997 
<span class="line-modified"> 998     Operand operand()</span>
 999     {
<span class="line-modified">1000         return variableAccessData()-&gt;operand();</span>
1001     }
1002 
1003     VirtualRegister machineLocal()
1004     {
1005         return variableAccessData()-&gt;machineLocal();
1006     }
1007 
<span class="line-modified">1008     bool hasUnlinkedOperand()</span>
1009     {
1010         switch (op()) {
1011         case ExtractOSREntryLocal:
1012         case MovHint:
1013         case ZombieHint:
1014         case KillStack:
1015             return true;
1016         default:
1017             return false;
1018         }
1019     }
1020 
<span class="line-modified">1021     Operand unlinkedOperand()</span>
1022     {
<span class="line-modified">1023         ASSERT(hasUnlinkedOperand());</span>
<span class="line-modified">1024         return Operand::fromBits(m_opInfo.as&lt;uint64_t&gt;());</span>
1025     }
1026 
1027     bool hasStackAccessData()
1028     {
1029         switch (op()) {
1030         case PutStack:
1031         case GetStack:
1032             return true;
1033         default:
1034             return false;
1035         }
1036     }
1037 
1038     StackAccessData* stackAccessData()
1039     {
1040         ASSERT(hasStackAccessData());
1041         return m_opInfo.as&lt;StackAccessData*&gt;();
1042     }
1043 
1044     unsigned argumentCountIncludingThis()
</pre>
<hr />
<pre>
1270 
1271     TypedArrayType typedArrayType()
1272     {
1273         ASSERT(hasTypedArrayType());
1274         TypedArrayType result = static_cast&lt;TypedArrayType&gt;(m_opInfo.as&lt;uint32_t&gt;());
1275         ASSERT(isTypedView(result));
1276         return result;
1277     }
1278 
1279     bool hasInlineCapacity()
1280     {
1281         return op() == CreateThis;
1282     }
1283 
1284     unsigned inlineCapacity()
1285     {
1286         ASSERT(hasInlineCapacity());
1287         return m_opInfo.as&lt;unsigned&gt;();
1288     }
1289 
<span class="line-added">1290     bool hasIsInternalPromise()</span>
<span class="line-added">1291     {</span>
<span class="line-added">1292         return op() == CreatePromise || op() == NewPromise;</span>
<span class="line-added">1293     }</span>
<span class="line-added">1294 </span>
<span class="line-added">1295     bool isInternalPromise()</span>
<span class="line-added">1296     {</span>
<span class="line-added">1297         ASSERT(hasIsInternalPromise());</span>
<span class="line-added">1298         return m_opInfo2.as&lt;bool&gt;();</span>
<span class="line-added">1299     }</span>
<span class="line-added">1300 </span>
1301     void setIndexingType(IndexingType indexingType)
1302     {
1303         ASSERT(hasIndexingType());
1304         m_opInfo = indexingType;
1305     }
1306 
1307     bool hasScopeOffset()
1308     {
1309         return op() == GetClosureVar || op() == PutClosureVar;
1310     }
1311 
1312     ScopeOffset scopeOffset()
1313     {
1314         ASSERT(hasScopeOffset());
1315         return ScopeOffset(m_opInfo.as&lt;uint32_t&gt;());
1316     }
1317 
<span class="line-added">1318     unsigned hasInternalFieldIndex()</span>
<span class="line-added">1319     {</span>
<span class="line-added">1320         return op() == GetInternalField || op() == PutInternalField;</span>
<span class="line-added">1321     }</span>
<span class="line-added">1322 </span>
<span class="line-added">1323     unsigned internalFieldIndex()</span>
<span class="line-added">1324     {</span>
<span class="line-added">1325         ASSERT(hasInternalFieldIndex());</span>
<span class="line-added">1326         return m_opInfo.as&lt;uint32_t&gt;();</span>
<span class="line-added">1327     }</span>
<span class="line-added">1328 </span>
1329     bool hasDirectArgumentsOffset()
1330     {
1331         return op() == GetFromArguments || op() == PutToArguments;
1332     }
1333 
1334     DirectArgumentsOffset capturedArgumentsOffset()
1335     {
1336         ASSERT(hasDirectArgumentsOffset());
1337         return DirectArgumentsOffset(m_opInfo.as&lt;uint32_t&gt;());
1338     }
1339 
1340     bool hasRegisterPointer()
1341     {
1342         return op() == GetGlobalVar || op() == GetGlobalLexicalVariable || op() == PutGlobalVariable;
1343     }
1344 
1345     WriteBarrier&lt;Unknown&gt;* variablePointer()
1346     {
1347         return m_opInfo.as&lt;WriteBarrier&lt;Unknown&gt;*&gt;();
1348     }
</pre>
<hr />
<pre>
1355         case TailCallVarargs:
1356         case TailCallForwardVarargs:
1357         case TailCallVarargsInlinedCaller:
1358         case TailCallForwardVarargsInlinedCaller:
1359         case ConstructVarargs:
1360         case ConstructForwardVarargs:
1361             return true;
1362         default:
1363             return false;
1364         }
1365     }
1366 
1367     CallVarargsData* callVarargsData()
1368     {
1369         ASSERT(hasCallVarargsData());
1370         return m_opInfo.as&lt;CallVarargsData*&gt;();
1371     }
1372 
1373     bool hasLoadVarargsData()
1374     {
<span class="line-modified">1375         return op() == LoadVarargs || op() == ForwardVarargs || op() == VarargsLength;</span>
1376     }
1377 
1378     LoadVarargsData* loadVarargsData()
1379     {
1380         ASSERT(hasLoadVarargsData());
1381         return m_opInfo.as&lt;LoadVarargsData*&gt;();
1382     }
1383 
1384     InlineCallFrame* argumentsInlineCallFrame()
1385     {
1386         ASSERT(op() == GetArgumentCountIncludingThis);
1387         return m_opInfo.as&lt;InlineCallFrame*&gt;();
1388     }
1389 
1390     bool hasQueriedType()
1391     {
1392         return op() == IsCellWithType;
1393     }
1394 
1395     JSType queriedType()
1396     {
1397         static_assert(std::is_same&lt;uint8_t, std::underlying_type&lt;JSType&gt;::type&gt;::value, &quot;Ensure that uint8_t is the underlying type for JSType.&quot;);
1398         return static_cast&lt;JSType&gt;(m_opInfo.as&lt;uint32_t&gt;());
1399     }
1400 
1401     bool hasSpeculatedTypeForQuery()
1402     {
1403         return op() == IsCellWithType;
1404     }
1405 
<span class="line-modified">1406     Optional&lt;SpeculatedType&gt; speculatedTypeForQuery()</span>
1407     {
1408         return speculationFromJSType(queriedType());
1409     }
1410 
1411     bool hasResult()
1412     {
1413         return !!result();
1414     }
1415 
1416     bool hasInt32Result()
1417     {
1418         return result() == NodeResultInt32;
1419     }
1420 
1421     bool hasInt52Result()
1422     {
1423         return result() == NodeResultInt52;
1424     }
1425 
1426     bool hasNumberResult()
1427     {
1428         return result() == NodeResultNumber;
1429     }
1430 
1431     bool hasNumberOrAnyIntResult()
1432     {
1433         return hasNumberResult() || hasInt32Result() || hasInt52Result();
1434     }
1435 
1436     bool hasNumericResult()
1437     {
1438         switch (op()) {
1439         case ValueSub:
1440         case ValueMul:
1441         case ValueBitAnd:
1442         case ValueBitOr:
1443         case ValueBitXor:
<span class="line-added">1444         case ValueBitNot:</span>
<span class="line-added">1445         case ValueBitLShift:</span>
<span class="line-added">1446         case ValueBitRShift:</span>
1447         case ValueNegate:
1448             return true;
1449         default:
1450             return false;
1451         }
1452     }
1453 
1454     bool hasDoubleResult()
1455     {
1456         return result() == NodeResultDouble;
1457     }
1458 
1459     bool hasJSResult()
1460     {
1461         return result() == NodeResultJS;
1462     }
1463 
1464     bool hasBooleanResult()
1465     {
1466         return result() == NodeResultBoolean;
</pre>
<hr />
<pre>
1559     }
1560 
1561     BranchData* branchData()
1562     {
1563         ASSERT(isBranch());
1564         return m_opInfo.as&lt;BranchData*&gt;();
1565     }
1566 
1567     SwitchData* switchData()
1568     {
1569         ASSERT(isSwitch());
1570         return m_opInfo.as&lt;SwitchData*&gt;();
1571     }
1572 
1573     EntrySwitchData* entrySwitchData()
1574     {
1575         ASSERT(isEntrySwitch());
1576         return m_opInfo.as&lt;EntrySwitchData*&gt;();
1577     }
1578 
<span class="line-added">1579     bool hasIntrinsic()</span>
<span class="line-added">1580     {</span>
<span class="line-added">1581         switch (op()) {</span>
<span class="line-added">1582         case CPUIntrinsic:</span>
<span class="line-added">1583         case DateGetTime:</span>
<span class="line-added">1584         case DateGetInt32OrNaN:</span>
<span class="line-added">1585             return true;</span>
<span class="line-added">1586         default:</span>
<span class="line-added">1587             return false;</span>
<span class="line-added">1588         }</span>
<span class="line-added">1589     }</span>
<span class="line-added">1590 </span>
1591     Intrinsic intrinsic()
1592     {
<span class="line-modified">1593         ASSERT(hasIntrinsic());</span>
1594         return m_opInfo.as&lt;Intrinsic&gt;();
1595     }
1596 
1597     unsigned numSuccessors()
1598     {
1599         switch (op()) {
1600         case Jump:
1601             return 1;
1602         case Branch:
1603             return 2;
1604         case Switch:
1605             return switchData()-&gt;cases.size() + 1;
1606         case EntrySwitch:
1607             return entrySwitchData()-&gt;cases.size();
1608         default:
1609             return 0;
1610         }
1611     }
1612 
1613     BasicBlock*&amp; successor(unsigned index)
</pre>
<hr />
<pre>
1728         case GetByIdDirectFlush:
1729         case GetPrototypeOf:
1730         case TryGetById:
1731         case GetByVal:
1732         case GetByValWithThis:
1733         case Call:
1734         case DirectCall:
1735         case TailCallInlinedCaller:
1736         case DirectTailCallInlinedCaller:
1737         case Construct:
1738         case DirectConstruct:
1739         case CallVarargs:
1740         case CallEval:
1741         case TailCallVarargsInlinedCaller:
1742         case ConstructVarargs:
1743         case CallForwardVarargs:
1744         case TailCallForwardVarargsInlinedCaller:
1745         case GetByOffset:
1746         case MultiGetByOffset:
1747         case GetClosureVar:
<span class="line-added">1748         case GetInternalField:</span>
1749         case GetFromArguments:
1750         case GetArgument:
1751         case ArrayPop:
1752         case ArrayPush:
1753         case RegExpExec:
1754         case RegExpExecNonGlobalOrSticky:
1755         case RegExpTest:
1756         case RegExpMatchFast:
1757         case RegExpMatchFastGlobal:
1758         case GetGlobalVar:
1759         case GetGlobalLexicalVariable:
1760         case StringReplace:
1761         case StringReplaceRegExp:
1762         case ToNumber:
<span class="line-added">1763         case ToNumeric:</span>
1764         case ToObject:
1765         case ValueBitAnd:
1766         case ValueBitOr:
1767         case ValueBitXor:
1768         case ValueBitNot:
1769         case ValueBitLShift:
<span class="line-added">1770         case ValueBitRShift:</span>
1771         case CallObjectConstructor:
1772         case LoadKeyFromMapBucket:
1773         case LoadValueFromMapBucket:
1774         case CallDOMGetter:
1775         case CallDOM:
1776         case ParseInt:
1777         case AtomicsAdd:
1778         case AtomicsAnd:
1779         case AtomicsCompareExchange:
1780         case AtomicsExchange:
1781         case AtomicsLoad:
1782         case AtomicsOr:
1783         case AtomicsStore:
1784         case AtomicsSub:
1785         case AtomicsXor:
1786         case GetDynamicVar:
1787         case ExtractValueFromWeakMapGet:
1788         case ToThis:
1789         case DataViewGetInt:
1790         case DataViewGetFloat:
<span class="line-added">1791         case DateGetInt32OrNaN:</span>
1792             return true;
1793         default:
1794             return false;
1795         }
1796     }
1797 
1798     SpeculatedType getHeapPrediction()
1799     {
1800         ASSERT(hasHeapPrediction());
1801         return m_opInfo2.as&lt;SpeculatedType&gt;();
1802     }
1803 
1804     void setHeapPrediction(SpeculatedType prediction)
1805     {
1806         ASSERT(hasHeapPrediction());
1807         m_opInfo2 = prediction;
1808     }
1809 
1810     SpeculatedType getForcedPrediction()
1811     {
</pre>
<hr />
<pre>
1878 
1879     WatchpointSet* watchpointSet()
1880     {
1881         ASSERT(hasWatchpointSet());
1882         return m_opInfo.as&lt;WatchpointSet*&gt;();
1883     }
1884 
1885     bool hasStoragePointer()
1886     {
1887         return op() == ConstantStoragePointer;
1888     }
1889 
1890     void* storagePointer()
1891     {
1892         ASSERT(hasStoragePointer());
1893         return m_opInfo.as&lt;void*&gt;();
1894     }
1895 
1896     bool hasUidOperand()
1897     {
<span class="line-modified">1898         return op() == CheckIdent;</span>
1899     }
1900 
1901     UniquedStringImpl* uidOperand()
1902     {
1903         ASSERT(hasUidOperand());
1904         return m_opInfo.as&lt;UniquedStringImpl*&gt;();
1905     }
1906 
1907     bool hasTypeInfoOperand()
1908     {
1909         return op() == CheckTypeInfoFlags;
1910     }
1911 
1912     unsigned typeInfoOperand()
1913     {
1914         ASSERT(hasTypeInfoOperand() &amp;&amp; m_opInfo.as&lt;uint32_t&gt;() &lt;= static_cast&lt;uint32_t&gt;(UCHAR_MAX));
1915         return m_opInfo.as&lt;uint32_t&gt;();
1916     }
1917 
1918     bool hasTransition()
</pre>
<hr />
<pre>
1939         case CheckStructure:
1940         case CheckStructureOrEmpty:
1941         case CheckStructureImmediate:
1942         case MaterializeNewObject:
1943             return true;
1944         default:
1945             return false;
1946         }
1947     }
1948 
1949     const RegisteredStructureSet&amp; structureSet()
1950     {
1951         ASSERT(hasStructureSet());
1952         return *m_opInfo.as&lt;RegisteredStructureSet*&gt;();
1953     }
1954 
1955     bool hasStructure()
1956     {
1957         switch (op()) {
1958         case ArrayifyToStructure:
<span class="line-added">1959         case MaterializeNewInternalFieldObject:</span>
1960         case NewObject:
<span class="line-added">1961         case NewPromise:</span>
<span class="line-added">1962         case NewGenerator:</span>
<span class="line-added">1963         case NewAsyncGenerator:</span>
<span class="line-added">1964         case NewArrayIterator:</span>
1965         case NewStringObject:
1966             return true;
1967         default:
1968             return false;
1969         }
1970     }
1971 
1972     RegisteredStructure structure()
1973     {
1974         ASSERT(hasStructure());
1975         return m_opInfo.asRegisteredStructure();
1976     }
1977 
1978     bool hasStorageAccessData()
1979     {
1980         switch (op()) {
1981         case GetByOffset:
1982         case PutByOffset:
1983         case GetGetterSetterByOffset:
1984             return true;
</pre>
<hr />
<pre>
2013     {
2014         ASSERT(hasMultiPutByOffsetData());
2015         return *m_opInfo.as&lt;MultiPutByOffsetData*&gt;();
2016     }
2017 
2018     bool hasMatchStructureData()
2019     {
2020         return op() == MatchStructure;
2021     }
2022 
2023     MatchStructureData&amp; matchStructureData()
2024     {
2025         ASSERT(hasMatchStructureData());
2026         return *m_opInfo.as&lt;MatchStructureData*&gt;();
2027     }
2028 
2029     bool hasObjectMaterializationData()
2030     {
2031         switch (op()) {
2032         case MaterializeNewObject:
<span class="line-added">2033         case MaterializeNewInternalFieldObject:</span>
2034         case MaterializeCreateActivation:
2035             return true;
2036 
2037         default:
2038             return false;
2039         }
2040     }
2041 
2042     ObjectMaterializationData&amp; objectMaterializationData()
2043     {
2044         ASSERT(hasObjectMaterializationData());
2045         return *m_opInfo2.as&lt;ObjectMaterializationData*&gt;();
2046     }
2047 
2048     bool isObjectAllocation()
2049     {
2050         switch (op()) {
2051         case NewObject:
2052         case MaterializeNewObject:
2053             return true;
</pre>
<hr />
<pre>
2110             return true;
2111         default:
2112             return false;
2113         }
2114     }
2115 
2116     bool isPhantomAllocation()
2117     {
2118         switch (op()) {
2119         case PhantomNewObject:
2120         case PhantomDirectArguments:
2121         case PhantomCreateRest:
2122         case PhantomSpread:
2123         case PhantomNewArrayWithSpread:
2124         case PhantomNewArrayBuffer:
2125         case PhantomClonedArguments:
2126         case PhantomNewFunction:
2127         case PhantomNewGeneratorFunction:
2128         case PhantomNewAsyncFunction:
2129         case PhantomNewAsyncGeneratorFunction:
<span class="line-added">2130         case PhantomNewArrayIterator:</span>
2131         case PhantomCreateActivation:
2132         case PhantomNewRegexp:
2133             return true;
2134         default:
2135             return false;
2136         }
2137     }
2138 
2139     bool hasArrayMode()
2140     {
2141         switch (op()) {
2142         case GetIndexedPropertyStorage:
2143         case GetArrayLength:
2144         case GetVectorLength:
2145         case InByVal:
2146         case PutByValDirect:
2147         case PutByVal:
2148         case PutByValAlias:
2149         case GetByVal:
2150         case StringCharAt:
2151         case StringCharCodeAt:
<span class="line-added">2152         case StringCodePointAt:</span>
2153         case CheckArray:
<span class="line-added">2154         case CheckArrayOrEmpty:</span>
2155         case Arrayify:
2156         case ArrayifyToStructure:
2157         case ArrayPush:
2158         case ArrayPop:
2159         case ArrayIndexOf:
2160         case HasIndexedProperty:
2161         case AtomicsAdd:
2162         case AtomicsAnd:
2163         case AtomicsCompareExchange:
2164         case AtomicsExchange:
2165         case AtomicsLoad:
2166         case AtomicsOr:
2167         case AtomicsStore:
2168         case AtomicsSub:
2169         case AtomicsXor:
2170             return true;
2171         default:
2172             return false;
2173         }
2174     }
</pre>
<hr />
<pre>
2926         return m_opInfo.as&lt;uint32_t&gt;();
2927     }
2928 
2929     uint32_t errorType()
2930     {
2931         ASSERT(op() == ThrowStaticError);
2932         return m_opInfo.as&lt;uint32_t&gt;();
2933     }
2934 
2935     bool hasCallLinkStatus()
2936     {
2937         return op() == FilterCallLinkStatus;
2938     }
2939 
2940     CallLinkStatus* callLinkStatus()
2941     {
2942         ASSERT(hasCallLinkStatus());
2943         return m_opInfo.as&lt;CallLinkStatus*&gt;();
2944     }
2945 
<span class="line-modified">2946     bool hasGetByStatus()</span>
2947     {
<span class="line-modified">2948         return op() == FilterGetByStatus;</span>
2949     }
2950 
<span class="line-modified">2951     GetByStatus* getByStatus()</span>
2952     {
<span class="line-modified">2953         ASSERT(hasGetByStatus());</span>
<span class="line-modified">2954         return m_opInfo.as&lt;GetByStatus*&gt;();</span>
2955     }
2956 
2957     bool hasInByIdStatus()
2958     {
2959         return op() == FilterInByIdStatus;
2960     }
2961 
2962     InByIdStatus* inByIdStatus()
2963     {
2964         ASSERT(hasInByIdStatus());
2965         return m_opInfo.as&lt;InByIdStatus*&gt;();
2966     }
2967 
2968     bool hasPutByIdStatus()
2969     {
2970         return op() == FilterPutByIdStatus;
2971     }
2972 
2973     PutByIdStatus* putByIdStatus()
2974     {
</pre>
</td>
</tr>
</table>
<center><a href="DFGNode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGNodeFlowProjection.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
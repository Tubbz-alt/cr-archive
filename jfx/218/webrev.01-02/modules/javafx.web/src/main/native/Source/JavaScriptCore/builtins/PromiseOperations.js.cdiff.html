<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/PromiseOperations.js</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PromiseConstructor.js.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PromisePrototype.js.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/builtins/PromiseOperations.js</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,8 ***</span>
  /*
   * Copyright (C) 2015 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;.
<span class="line-modified">!  * Copyright (C) 2016 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,8 ---</span>
  /*
   * Copyright (C) 2015 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;.
<span class="line-modified">!  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 25,55 ***</span>
   */
  
  // @internal
  
  @globalPrivate
<span class="line-modified">! function isPromise(promise)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     &quot;use strict&quot;;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return @isObject(promise) &amp;&amp; !!@getByIdDirectPrivate(promise, &quot;promiseState&quot;);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- @globalPrivate</span>
<span class="line-removed">- function newPromiseReaction(capability, onFulfilled, onRejected)</span>
  {
      &quot;use strict&quot;;
  
      return {
<span class="line-modified">!         @capabilities: capability,</span>
          @onFulfilled: onFulfilled,
          @onRejected: onRejected,
      };
  }
  
  @globalPrivate
<span class="line-modified">! function newPromiseCapability(constructor)</span>
  {
<span class="line-removed">-     &quot;use strict&quot;;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (!@isConstructor(constructor))</span>
<span class="line-removed">-         @throwTypeError(&quot;promise capability requires a constructor function&quot;);</span>
<span class="line-removed">- </span>
      var promiseCapability = {
<span class="line-removed">-         @promise: @undefined,</span>
          @resolve: @undefined,
<span class="line-modified">!         @reject: @undefined</span>
      };
  
<span class="line-modified">!     function @executor(resolve, reject)</span>
<span class="line-modified">!     {</span>
          if (promiseCapability.@resolve !== @undefined)
              @throwTypeError(&quot;resolve function is already set&quot;);
          if (promiseCapability.@reject !== @undefined)
              @throwTypeError(&quot;reject function is already set&quot;);
  
          promiseCapability.@resolve = resolve;
          promiseCapability.@reject = reject;
<span class="line-modified">!     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     var promise = new constructor(@executor);</span>
  
      if (typeof promiseCapability.@resolve !== &quot;function&quot;)
          @throwTypeError(&quot;executor did not take a resolve function&quot;);
  
      if (typeof promiseCapability.@reject !== &quot;function&quot;)
<span class="line-new-header">--- 25,43 ---</span>
   */
  
  // @internal
  
  @globalPrivate
<span class="line-modified">! function newPromiseReaction(promiseOrCapability, onFulfilled, onRejected)</span>
  {
      &quot;use strict&quot;;
  
      return {
<span class="line-modified">!         @promiseOrCapability: promiseOrCapability,</span>
          @onFulfilled: onFulfilled,
          @onRejected: onRejected,
<span class="line-added">+         @next: @undefined,</span>
      };
  }
  
  @globalPrivate
<span class="line-modified">! function newPromiseCapabilitySlow(constructor)</span>
  {
      var promiseCapability = {
          @resolve: @undefined,
<span class="line-modified">!         @reject: @undefined,</span>
<span class="line-added">+         @promise: @undefined,</span>
      };
  
<span class="line-modified">!     if (!@isConstructor(constructor))</span>
<span class="line-modified">!         @throwTypeError(&quot;promise capability requires a constructor function&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     var promise = new constructor(function (resolve, reject) {</span>
          if (promiseCapability.@resolve !== @undefined)
              @throwTypeError(&quot;resolve function is already set&quot;);
          if (promiseCapability.@reject !== @undefined)
              @throwTypeError(&quot;reject function is already set&quot;);
  
          promiseCapability.@resolve = resolve;
          promiseCapability.@reject = reject;
<span class="line-modified">!     });</span>
  
      if (typeof promiseCapability.@resolve !== &quot;function&quot;)
          @throwTypeError(&quot;executor did not take a resolve function&quot;);
  
      if (typeof promiseCapability.@reject !== &quot;function&quot;)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 82,150 ***</span>
      promiseCapability.@promise = promise;
  
      return promiseCapability;
  }
  
  @globalPrivate
  function newHandledRejectedPromise(error)
  {
      &quot;use strict&quot;;
<span class="line-modified">!     let promise = @Promise.@reject(error);</span>
<span class="line-modified">!     @putByIdDirectPrivate(promise, &quot;promiseIsHandled&quot;, true);</span>
      return promise;
  }
  
  @globalPrivate
  function triggerPromiseReactions(state, reactions, argument)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     for (var index = 0, length = reactions.length; index &lt; length; ++index)</span>
<span class="line-modified">!         @enqueueJob(@promiseReactionJob, [state, reactions[index], argument]);</span>
  }
  
  @globalPrivate
  function rejectPromise(promise, reason)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var reactions = @getByIdDirectPrivate(promise, &quot;promiseReactions&quot;);</span>
<span class="line-modified">!     @putByIdDirectPrivate(promise, &quot;promiseResult&quot;, reason);</span>
<span class="line-modified">!     @putByIdDirectPrivate(promise, &quot;promiseReactions&quot;, @undefined);</span>
<span class="line-modified">!     @putByIdDirectPrivate(promise, &quot;promiseState&quot;, @promiseStateRejected);</span>
  
      @InspectorInstrumentation.promiseRejected(promise, reason, reactions);
  
<span class="line-modified">!     if (!@getByIdDirectPrivate(promise, &quot;promiseIsHandled&quot;))</span>
          @hostPromiseRejectionTracker(promise, @promiseRejectionReject);
  
      @triggerPromiseReactions(@promiseStateRejected, reactions, reason);
  }
  
  @globalPrivate
  function fulfillPromise(promise, value)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var reactions = @getByIdDirectPrivate(promise, &quot;promiseReactions&quot;);</span>
<span class="line-modified">!     @putByIdDirectPrivate(promise, &quot;promiseResult&quot;, value);</span>
<span class="line-modified">!     @putByIdDirectPrivate(promise, &quot;promiseReactions&quot;, @undefined);</span>
<span class="line-modified">!     @putByIdDirectPrivate(promise, &quot;promiseState&quot;, @promiseStateFulfilled);</span>
  
      @InspectorInstrumentation.promiseFulfilled(promise, value, reactions);
  
      @triggerPromiseReactions(@promiseStateFulfilled, reactions, value);
  }
  
  @globalPrivate
  function createResolvingFunctions(promise)
  {
      &quot;use strict&quot;;
  
      var alreadyResolved = false;
  
      function @resolve(resolution) {
          if (alreadyResolved)
              return @undefined;
          alreadyResolved = true;
  
<span class="line-modified">!         if (resolution === promise)</span>
<span class="line-modified">!             return @rejectPromise(promise, @makeTypeError(&quot;Resolve a promise with itself&quot;));</span>
  
<span class="line-modified">!         if (!@isObject(resolution))</span>
<span class="line-modified">!             return @fulfillPromise(promise, resolution);</span>
  
<span class="line-modified">!         var then;</span>
<span class="line-modified">!         try {</span>
<span class="line-modified">!             then = resolution.then;</span>
<span class="line-modified">!         } catch (error) {</span>
<span class="line-modified">!             return @rejectPromise(promise, error);</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         if (typeof then !== &#39;function&#39;)</span>
<span class="line-modified">!             return @fulfillPromise(promise, resolution);</span>
  
<span class="line-modified">!         @enqueueJob(@promiseResolveThenableJob, [promise, resolution, then]);</span>
  
<span class="line-modified">!         return @undefined;</span>
      }
  
      function @reject(reason) {
          if (alreadyResolved)
              return @undefined;
          alreadyResolved = true;
  
<span class="line-modified">!         return @rejectPromise(promise, reason);</span>
      }
  
      return { @resolve, @reject };
  }
  
  @globalPrivate
  function promiseReactionJob(state, reaction, argument)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var promiseCapability = reaction.@capabilities;</span>
  
<span class="line-removed">-     var result;</span>
      var handler = (state === @promiseStateFulfilled) ? reaction.@onFulfilled: reaction.@onRejected;
      try {
          result = handler(argument);
      } catch (error) {
<span class="line-modified">!         return promiseCapability.@reject.@call(@undefined, error);</span>
      }
  
<span class="line-modified">!     return promiseCapability.@resolve.@call(@undefined, result);</span>
  }
  
  @globalPrivate
<span class="line-modified">! function promiseResolveThenableJob(promiseToResolve, thenable, then)</span>
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     var resolvingFunctions = @createResolvingFunctions(promiseToResolve);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     try {</span>
<span class="line-modified">!         return then.@call(thenable, resolvingFunctions.@resolve, resolvingFunctions.@reject);</span>
<span class="line-modified">!     } catch (error) {</span>
<span class="line-modified">!         return resolvingFunctions.@reject.@call(@undefined, error);</span>
      }
  }
  
  @globalPrivate
<span class="line-modified">! function initializePromise(executor)</span>
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     @putByIdDirectPrivate(this, &quot;promiseState&quot;, @promiseStatePending);</span>
<span class="line-modified">!     @putByIdDirectPrivate(this, &quot;promiseReactions&quot;, []);</span>
<span class="line-modified">!     @putByIdDirectPrivate(this, &quot;promiseIsHandled&quot;, false);</span>
  
<span class="line-removed">-     var resolvingFunctions = @createResolvingFunctions(this);</span>
      try {
<span class="line-modified">!         executor(resolvingFunctions.@resolve, resolvingFunctions.@reject);</span>
      } catch (error) {
          return resolvingFunctions.@reject.@call(@undefined, error);
      }
<span class="line-removed">- </span>
<span class="line-removed">-     return this;</span>
  }
<span class="line-new-header">--- 70,402 ---</span>
      promiseCapability.@promise = promise;
  
      return promiseCapability;
  }
  
<span class="line-added">+ @globalPrivate</span>
<span class="line-added">+ function newPromiseCapability(constructor)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     &quot;use strict&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (constructor === @Promise) {</span>
<span class="line-added">+         var promise = @newPromise();</span>
<span class="line-added">+         var capturedPromise = promise;</span>
<span class="line-added">+         function @resolve(resolution) {</span>
<span class="line-added">+             return @resolvePromiseWithFirstResolvingFunctionCallCheck(capturedPromise, resolution);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         function @reject(reason) {</span>
<span class="line-added">+             return @rejectPromiseWithFirstResolvingFunctionCallCheck(capturedPromise, reason);</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return { @resolve, @reject, @promise: promise };</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return @newPromiseCapabilitySlow(constructor);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ @globalPrivate</span>
<span class="line-added">+ function promiseResolveSlow(constructor, value)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     @assert(constructor !== @Promise);</span>
<span class="line-added">+     var promiseCapability = @newPromiseCapabilitySlow(constructor);</span>
<span class="line-added">+     promiseCapability.@resolve.@call(@undefined, value);</span>
<span class="line-added">+     return promiseCapability.@promise;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ @globalPrivate</span>
<span class="line-added">+ function promiseRejectSlow(constructor, reason)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     @assert(constructor !== @Promise);</span>
<span class="line-added">+     var promiseCapability = @newPromiseCapabilitySlow(constructor);</span>
<span class="line-added">+     promiseCapability.@reject.@call(@undefined, reason);</span>
<span class="line-added">+     return promiseCapability.@promise;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  @globalPrivate
  function newHandledRejectedPromise(error)
  {
      &quot;use strict&quot;;
<span class="line-modified">!     var promise = @newPromise();</span>
<span class="line-modified">!     @rejectPromiseWithFirstResolvingFunctionCallCheck(promise, error);</span>
<span class="line-added">+     @putPromiseInternalField(promise, @promiseFieldFlags, @getPromiseInternalField(promise, @promiseFieldFlags) | @promiseFlagsIsHandled);</span>
      return promise;
  }
  
  @globalPrivate
  function triggerPromiseReactions(state, reactions, argument)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     // Reverse the order of singly-linked-list.</span>
<span class="line-modified">!     var previous = @undefined;</span>
<span class="line-added">+     var current = reactions;</span>
<span class="line-added">+     while (current) {</span>
<span class="line-added">+         var next = current.@next;</span>
<span class="line-added">+         current.@next = previous;</span>
<span class="line-added">+         previous = current;</span>
<span class="line-added">+         current = next;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     reactions = previous;</span>
<span class="line-added">+ </span>
<span class="line-added">+     current = reactions;</span>
<span class="line-added">+     while (current) {</span>
<span class="line-added">+         @enqueueJob(@promiseReactionJob, state, current, argument);</span>
<span class="line-added">+         current = current.@next;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ @globalPrivate</span>
<span class="line-added">+ function resolvePromise(promise, resolution)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     &quot;use strict&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     @assert(@isPromise(promise));</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (resolution === promise)</span>
<span class="line-added">+         return @rejectPromise(promise, @makeTypeError(&quot;Cannot resolve a promise with itself&quot;));</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!@isObject(resolution))</span>
<span class="line-added">+         return @fulfillPromise(promise, resolution);</span>
<span class="line-added">+ </span>
<span class="line-added">+     var then;</span>
<span class="line-added">+     try {</span>
<span class="line-added">+         then = resolution.then;</span>
<span class="line-added">+     } catch (error) {</span>
<span class="line-added">+         return @rejectPromise(promise, error);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (@isPromise(resolution) &amp;&amp; then === @defaultPromiseThen) {</span>
<span class="line-added">+         @enqueueJob(@promiseResolveThenableJobFast, resolution, promise);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (typeof then !== &#39;function&#39;)</span>
<span class="line-added">+         return @fulfillPromise(promise, resolution);</span>
<span class="line-added">+ </span>
<span class="line-added">+     @enqueueJob(@promiseResolveThenableJob, resolution, then, @createResolvingFunctions(promise));</span>
  }
  
  @globalPrivate
  function rejectPromise(promise, reason)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     @assert(@isPromise(promise));</span>
<span class="line-modified">!     @assert((@getPromiseInternalField(promise, @promiseFieldFlags) &amp; @promiseStateMask) == @promiseStatePending);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     var flags = @getPromiseInternalField(promise, @promiseFieldFlags);</span>
<span class="line-added">+     var reactions = @getPromiseInternalField(promise, @promiseFieldReactionsOrResult);</span>
<span class="line-added">+     @putPromiseInternalField(promise, @promiseFieldReactionsOrResult, reason);</span>
<span class="line-added">+     @putPromiseInternalField(promise, @promiseFieldFlags, flags | @promiseStateRejected);</span>
  
      @InspectorInstrumentation.promiseRejected(promise, reason, reactions);
  
<span class="line-modified">!     if (!(flags &amp; @promiseFlagsIsHandled))</span>
          @hostPromiseRejectionTracker(promise, @promiseRejectionReject);
  
      @triggerPromiseReactions(@promiseStateRejected, reactions, reason);
  }
  
  @globalPrivate
  function fulfillPromise(promise, value)
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     @assert(@isPromise(promise));</span>
<span class="line-modified">!     @assert((@getPromiseInternalField(promise, @promiseFieldFlags) &amp; @promiseStateMask) == @promiseStatePending);</span>
<span class="line-modified">! </span>
<span class="line-modified">!     var flags = @getPromiseInternalField(promise, @promiseFieldFlags);</span>
<span class="line-added">+     var reactions = @getPromiseInternalField(promise, @promiseFieldReactionsOrResult);</span>
<span class="line-added">+     @putPromiseInternalField(promise, @promiseFieldReactionsOrResult, value);</span>
<span class="line-added">+     @putPromiseInternalField(promise, @promiseFieldFlags, flags | @promiseStateFulfilled);</span>
  
      @InspectorInstrumentation.promiseFulfilled(promise, value, reactions);
  
      @triggerPromiseReactions(@promiseStateFulfilled, reactions, value);
  }
  
<span class="line-added">+ @globalPrivate</span>
<span class="line-added">+ function resolvePromiseWithFirstResolvingFunctionCallCheck(promise, value)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     @assert(@isPromise(promise));</span>
<span class="line-added">+     var flags = @getPromiseInternalField(promise, @promiseFieldFlags);</span>
<span class="line-added">+     if (flags &amp; @promiseFlagsIsFirstResolvingFunctionCalled)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     @putPromiseInternalField(promise, @promiseFieldFlags, flags | @promiseFlagsIsFirstResolvingFunctionCalled);</span>
<span class="line-added">+     return @resolvePromise(promise, value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ @globalPrivate</span>
<span class="line-added">+ function rejectPromiseWithFirstResolvingFunctionCallCheck(promise, reason)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     @assert(@isPromise(promise));</span>
<span class="line-added">+     var flags = @getPromiseInternalField(promise, @promiseFieldFlags);</span>
<span class="line-added">+     if (flags &amp; @promiseFlagsIsFirstResolvingFunctionCalled)</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     @putPromiseInternalField(promise, @promiseFieldFlags, flags | @promiseFlagsIsFirstResolvingFunctionCalled);</span>
<span class="line-added">+     return @rejectPromise(promise, reason);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  @globalPrivate
  function createResolvingFunctions(promise)
  {
      &quot;use strict&quot;;
  
<span class="line-added">+     @assert(@isPromise(promise));</span>
<span class="line-added">+ </span>
      var alreadyResolved = false;
  
      function @resolve(resolution) {
          if (alreadyResolved)
              return @undefined;
          alreadyResolved = true;
  
<span class="line-modified">!         return @resolvePromise(promise, resolution);</span>
<span class="line-modified">!     }</span>
  
<span class="line-modified">!     function @reject(reason) {</span>
<span class="line-modified">!         if (alreadyResolved)</span>
<span class="line-added">+             return @undefined;</span>
<span class="line-added">+         alreadyResolved = true;</span>
  
<span class="line-modified">!         return @rejectPromise(promise, reason);</span>
<span class="line-modified">!     }</span>
<span class="line-modified">! </span>
<span class="line-modified">!     return { @resolve, @reject };</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-added">+ @globalPrivate</span>
<span class="line-added">+ function promiseReactionJobWithoutPromise(handler, argument)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     &quot;use strict&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     try {</span>
<span class="line-added">+         handler(argument);</span>
<span class="line-added">+     } catch {</span>
<span class="line-added">+         // This is user-uncatchable promise. We just ignore the error here.</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // This function has strong guarantee that each handler function (onFulfilled and onRejected) will be called at most once.</span>
<span class="line-added">+ @globalPrivate</span>
<span class="line-added">+ function resolveWithoutPromise(resolution, onFulfilled, onRejected)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     &quot;use strict&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!@isObject(resolution)) {</span>
<span class="line-added">+         @fulfillWithoutPromise(resolution, onFulfilled, onRejected);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     var then;</span>
<span class="line-modified">!     try {</span>
<span class="line-added">+         then = resolution.then;</span>
<span class="line-added">+     } catch (error) {</span>
<span class="line-added">+         @rejectWithoutPromise(error, onFulfilled, onRejected);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     if (@isPromise(resolution) &amp;&amp; then === @defaultPromiseThen) {</span>
<span class="line-added">+         @enqueueJob(@promiseResolveThenableJobWithoutPromiseFast, resolution, onFulfilled, onRejected);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
  
<span class="line-modified">!     if (typeof then !== &#39;function&#39;) {</span>
<span class="line-added">+         @fulfillWithoutPromise(resolution, onFulfilled, onRejected);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Wrap onFulfilled and onRejected with @createResolvingFunctionsWithoutPromise to ensure that each function will be called at most once.</span>
<span class="line-added">+     @enqueueJob(@promiseResolveThenableJob, resolution, then, @createResolvingFunctionsWithoutPromise(onFulfilled, onRejected));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // This function has strong guarantee that each handler function (onFulfilled and onRejected) will be called at most once.</span>
<span class="line-added">+ @globalPrivate</span>
<span class="line-added">+ function rejectWithoutPromise(reason, onFulfilled, onRejected)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     &quot;use strict&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     @enqueueJob(@promiseReactionJobWithoutPromise, onRejected, reason);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // This function has strong guarantee that each handler function (onFulfilled and onRejected) will be called at most once.</span>
<span class="line-added">+ @globalPrivate</span>
<span class="line-added">+ function fulfillWithoutPromise(value, onFulfilled, onRejected)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     &quot;use strict&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     @enqueueJob(@promiseReactionJobWithoutPromise, onFulfilled, value);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ @globalPrivate</span>
<span class="line-added">+ function createResolvingFunctionsWithoutPromise(onFulfilled, onRejected)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     &quot;use strict&quot;;</span>
<span class="line-added">+ </span>
<span class="line-added">+     var alreadyResolved = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+     function @resolve(resolution) {</span>
<span class="line-added">+         if (alreadyResolved)</span>
<span class="line-added">+             return @undefined;</span>
<span class="line-added">+         alreadyResolved = true;</span>
<span class="line-added">+ </span>
<span class="line-added">+         @resolveWithoutPromise(resolution, onFulfilled, onRejected);</span>
      }
  
      function @reject(reason) {
          if (alreadyResolved)
              return @undefined;
          alreadyResolved = true;
  
<span class="line-modified">!         @rejectWithoutPromise(reason, onFulfilled, onRejected);</span>
      }
  
      return { @resolve, @reject };
  }
  
  @globalPrivate
  function promiseReactionJob(state, reaction, argument)
  {
<span class="line-added">+     // Promise Reaction has four types.</span>
<span class="line-added">+     // 1. @promiseOrCapability is PromiseCapability, and having handlers.</span>
<span class="line-added">+     //     The most generic one.</span>
<span class="line-added">+     // 2. @promiseOrCapability is Promise, and having handlers.</span>
<span class="line-added">+     //     We just have promise.</span>
<span class="line-added">+     // 3. @promiseOrCapability is Promise, and not having handlers.</span>
<span class="line-added">+     //     It only has promise. Just resolving it with the value.</span>
<span class="line-added">+     // 4. Only having @onFulfilled and @onRejected</span>
<span class="line-added">+     //     It does not have promise capability. Just handlers are passed.</span>
      &quot;use strict&quot;;
  
<span class="line-modified">!     var promiseOrCapability = reaction.@promiseOrCapability;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Case (3).</span>
<span class="line-added">+     if (!reaction.@onRejected) {</span>
<span class="line-added">+         @assert(!reaction.@onFulfilled);</span>
<span class="line-added">+         try {</span>
<span class="line-added">+             @assert(@isPromise(promiseOrCapability));</span>
<span class="line-added">+             if (state === @promiseStateFulfilled)</span>
<span class="line-added">+                 @resolvePromise(promiseOrCapability, argument);</span>
<span class="line-added">+             else</span>
<span class="line-added">+                 @rejectPromise(promiseOrCapability, argument);</span>
<span class="line-added">+         } catch {</span>
<span class="line-added">+             // This is user-uncatchable promise. We just ignore the error here.</span>
<span class="line-added">+         }</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
  
      var handler = (state === @promiseStateFulfilled) ? reaction.@onFulfilled: reaction.@onRejected;
<span class="line-added">+ </span>
<span class="line-added">+     // Case (4).</span>
<span class="line-added">+     if (!promiseOrCapability) {</span>
<span class="line-added">+         @promiseReactionJobWithoutPromise(handler, argument);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Case (1), or (2).</span>
<span class="line-added">+     var result;</span>
      try {
          result = handler(argument);
      } catch (error) {
<span class="line-modified">!         if (@isPromise(promiseOrCapability)) {</span>
<span class="line-added">+             @rejectPromise(promiseOrCapability, error);</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         promiseOrCapability.@reject.@call(@undefined, error);</span>
<span class="line-added">+         return;</span>
      }
  
<span class="line-modified">!     if (@isPromise(promiseOrCapability)) {</span>
<span class="line-added">+         @resolvePromise(promiseOrCapability, result);</span>
<span class="line-added">+         return;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     promiseOrCapability.@resolve.@call(@undefined, result);</span>
  }
  
  @globalPrivate
<span class="line-modified">! function promiseResolveThenableJobFast(thenable, promiseToResolve)</span>
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     @assert(@isPromise(thenable));</span>
<span class="line-modified">!     @assert(@isPromise(promiseToResolve));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     var flags = @getPromiseInternalField(thenable, @promiseFieldFlags);</span>
<span class="line-modified">!     var state = flags &amp; @promiseStateMask;</span>
<span class="line-modified">!     var reaction = @newPromiseReaction(promiseToResolve, @undefined, @undefined);</span>
<span class="line-added">+     if (state === @promiseStatePending) {</span>
<span class="line-added">+         reaction.@next = @getPromiseInternalField(thenable, @promiseFieldReactionsOrResult);</span>
<span class="line-added">+         @putPromiseInternalField(thenable, @promiseFieldReactionsOrResult, reaction);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         if (state === @promiseStateRejected &amp;&amp; !(flags &amp; @promiseFlagsIsHandled))</span>
<span class="line-added">+             @hostPromiseRejectionTracker(thenable, @promiseRejectionHandle);</span>
<span class="line-added">+         @enqueueJob(@promiseReactionJob, state, reaction, @getPromiseInternalField(thenable, @promiseFieldReactionsOrResult));</span>
      }
<span class="line-added">+     @putPromiseInternalField(thenable, @promiseFieldFlags, @getPromiseInternalField(thenable, @promiseFieldFlags) | @promiseFlagsIsHandled);</span>
  }
  
  @globalPrivate
<span class="line-modified">! function promiseResolveThenableJobWithoutPromiseFast(thenable, onFulfilled, onRejected)</span>
  {
      &quot;use strict&quot;;
  
<span class="line-modified">!     @assert(@isPromise(thenable));</span>
<span class="line-modified">! </span>
<span class="line-modified">!     var flags = @getPromiseInternalField(thenable, @promiseFieldFlags);</span>
<span class="line-added">+     var state = flags &amp; @promiseStateMask;</span>
<span class="line-added">+     if (state === @promiseStatePending) {</span>
<span class="line-added">+         var reaction = @newPromiseReaction(@undefined, onFulfilled, onRejected);</span>
<span class="line-added">+         reaction.@next = @getPromiseInternalField(thenable, @promiseFieldReactionsOrResult);</span>
<span class="line-added">+         @putPromiseInternalField(thenable, @promiseFieldReactionsOrResult, reaction);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         var result = @getPromiseInternalField(thenable, @promiseFieldReactionsOrResult);</span>
<span class="line-added">+         if (state === @promiseStateRejected) {</span>
<span class="line-added">+             if (!(flags &amp; @promiseFlagsIsHandled))</span>
<span class="line-added">+                 @hostPromiseRejectionTracker(thenable, @promiseRejectionHandle);</span>
<span class="line-added">+             @rejectWithoutPromise(result, onFulfilled, onRejected);</span>
<span class="line-added">+         } else</span>
<span class="line-added">+             @fulfillWithoutPromise(result, onFulfilled, onRejected);</span>
<span class="line-added">+     }</span>
<span class="line-added">+     @putPromiseInternalField(thenable, @promiseFieldFlags, @getPromiseInternalField(thenable, @promiseFieldFlags) | @promiseFlagsIsHandled);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ @globalPrivate</span>
<span class="line-added">+ function promiseResolveThenableJob(thenable, then, resolvingFunctions)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     &quot;use strict&quot;;</span>
  
      try {
<span class="line-modified">!         return then.@call(thenable, resolvingFunctions.@resolve, resolvingFunctions.@reject);</span>
      } catch (error) {
          return resolvingFunctions.@reject.@call(@undefined, error);
      }
  }
</pre>
<center><a href="PromiseConstructor.js.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PromisePrototype.js.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
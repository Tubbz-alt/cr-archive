<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/WebCore/rendering/InlineTextBox.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * (C) 1999 Lars Knoll (knoll@kde.org)
  3  * (C) 2000 Dirk Mueller (mueller@kde.org)
  4  * Copyright (C) 2004-2017 Apple Inc. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  *
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;InlineBox.h&quot;
 26 #include &quot;RenderText.h&quot;
 27 #include &quot;TextRun.h&quot;
 28 
 29 namespace WebCore {
 30 
 31 class RenderCombineText;
 32 class RenderedDocumentMarker;
 33 class TextPainter;
 34 struct CompositionUnderline;
 35 struct MarkedText;
 36 struct TextPaintStyle;
 37 
 38 const unsigned short cNoTruncation = USHRT_MAX;
 39 const unsigned short cFullTruncation = USHRT_MAX - 1;
 40 
 41 class InlineTextBox : public InlineBox {
 42     WTF_MAKE_ISO_ALLOCATED(InlineTextBox);
 43 public:
 44     explicit InlineTextBox(RenderText&amp; renderer)
 45         : InlineBox(renderer)
 46     {
 47         setBehavesLikeText(true);
 48     }
 49 
 50     virtual ~InlineTextBox();
 51 
 52     RenderText&amp; renderer() const { return downcast&lt;RenderText&gt;(InlineBox::renderer()); }
 53     const RenderStyle&amp; lineStyle() const { return isFirstLine() ? renderer().firstLineStyle() : renderer().style(); }
 54 
 55     InlineTextBox* prevTextBox() const { return m_prevTextBox; }
 56     InlineTextBox* nextTextBox() const { return m_nextTextBox; }
 57     void setNextTextBox(InlineTextBox* n) { m_nextTextBox = n; }
 58     void setPreviousTextBox(InlineTextBox* p) { m_prevTextBox = p; }
 59 
 60     bool hasTextContent() const;
 61 
 62     // These functions do not account for combined text. For combined text this box will always have len() == 1
 63     // regardless of whether the resulting composition is the empty string. Use hasTextContent() if you want to
 64     // know whether this box has text content.
 65     //
 66     // FIXME: These accessors should ASSERT(!isDirty()). See https://bugs.webkit.org/show_bug.cgi?id=97264
 67     // Note len() == 1 for combined text regardless of whether the composition is empty. Use hasTextContent() to
 68     unsigned start() const { return m_start; }
 69     unsigned end() const { return m_len ? m_start + m_len - 1 : m_start; }
 70     unsigned len() const { return m_len; }
 71 
 72     void setStart(unsigned start) { m_start = start; }
 73     void setLen(unsigned len) { m_len = len; }
 74 
 75     void offsetRun(int d) { ASSERT(!isDirty()); ASSERT(d &gt; 0 || m_start &gt;= static_cast&lt;unsigned&gt;(-d)); m_start += d; }
 76 
 77     unsigned short truncation() const { return m_truncation; }
 78 
 79     void markDirty(bool dirty = true) final;
 80 
 81     using InlineBox::hasHyphen;
 82     using InlineBox::setHasHyphen;
 83     using InlineBox::canHaveLeadingExpansion;
 84     using InlineBox::setCanHaveLeadingExpansion;
 85     using InlineBox::canHaveTrailingExpansion;
 86     using InlineBox::setCanHaveTrailingExpansion;
 87     using InlineBox::forceTrailingExpansion;
 88     using InlineBox::setForceTrailingExpansion;
 89     using InlineBox::forceLeadingExpansion;
 90     using InlineBox::setForceLeadingExpansion;
 91 
 92     static inline bool compareByStart(const InlineTextBox* first, const InlineTextBox* second) { return first-&gt;start() &lt; second-&gt;start(); }
 93 
 94     int baselinePosition(FontBaseline) const final;
 95     LayoutUnit lineHeight() const final;
 96 
 97     Optional&lt;bool&gt; emphasisMarkExistsAndIsAbove(const RenderStyle&amp;) const;
 98 
 99     LayoutRect logicalOverflowRect() const;
100     void setLogicalOverflowRect(const LayoutRect&amp;);
101     LayoutUnit logicalTopVisualOverflow() const { return logicalOverflowRect().y(); }
102     LayoutUnit logicalBottomVisualOverflow() const { return logicalOverflowRect().maxY(); }
103     LayoutUnit logicalLeftVisualOverflow() const { return logicalOverflowRect().x(); }
104     LayoutUnit logicalRightVisualOverflow() const { return logicalOverflowRect().maxX(); }
105 
106     virtual void dirtyOwnLineBoxes() { dirtyLineBoxes(); }
107 
108 #if ENABLE(TREE_DEBUGGING)
109     void outputLineBox(WTF::TextStream&amp;, bool mark, int depth) const final;
110     const char* boxName() const final;
111 #endif
112 
113 private:
114     LayoutUnit selectionTop() const;
115     LayoutUnit selectionBottom() const;
116     LayoutUnit selectionHeight() const;
117 
118 public:
119     FloatRect calculateBoundaries() const override { return FloatRect(x(), y(), width(), height()); }
120 
121     virtual LayoutRect localSelectionRect(unsigned startPos, unsigned endPos) const;
122     bool isSelected(unsigned startPosition, unsigned endPosition) const;
123     std::pair&lt;unsigned, unsigned&gt; selectionStartEnd() const;
124 
125 protected:
126     void paint(PaintInfo&amp;, const LayoutPoint&amp;, LayoutUnit lineTop, LayoutUnit lineBottom) override;
127     bool nodeAtPoint(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, LayoutUnit lineTop, LayoutUnit lineBottom, HitTestAction) override;
128 
129     unsigned clampedOffset(unsigned) const;
130 
131 private:
132     void deleteLine() final;
133     void extractLine() final;
134     void attachLine() final;
135 
136 public:
137     RenderObject::SelectionState selectionState() final;
138 
139 private:
140     void clearTruncation() final { m_truncation = cNoTruncation; }
141     float placeEllipsisBox(bool flowIsLTR, float visibleLeftEdge, float visibleRightEdge, float ellipsisWidth, float &amp;truncatedWidth, bool&amp; foundBox) final;
142 
143 public:
144     bool isLineBreak() const final;
145 
146 private:
147     bool isInlineTextBox() const final { return true; }
148 
149 public:
150     int caretMinOffset() const final;
151     int caretMaxOffset() const final;
152 
153 private:
154     float textPos() const; // returns the x position relative to the left start of the text line.
155 
156 public:
157     virtual int offsetForPosition(float x, bool includePartialGlyphs = true) const;
158     virtual float positionForOffset(unsigned offset) const;
159 
160     bool hasMarkers() const;
161     FloatRect calculateUnionOfAllDocumentMarkerBounds() const;
162     FloatRect calculateDocumentMarkerBounds(const MarkedText&amp;) const;
163 
164 private:
165     struct MarkedTextStyle;
166     struct StyledMarkedText;
167 
168     enum class TextPaintPhase { Background, Foreground, Decoration };
169 
170     Vector&lt;MarkedText&gt; collectMarkedTextsForDraggedContent();
171     Vector&lt;MarkedText&gt; collectMarkedTextsForDocumentMarkers(TextPaintPhase) const;
172 
173     MarkedTextStyle computeStyleForUnmarkedMarkedText(const PaintInfo&amp;) const;
174     StyledMarkedText resolveStyleForMarkedText(const MarkedText&amp;, const MarkedTextStyle&amp; baseStyle, const PaintInfo&amp;);
175     Vector&lt;StyledMarkedText&gt; subdivideAndResolveStyle(const Vector&lt;MarkedText&gt;&amp;, const MarkedTextStyle&amp; baseStyle, const PaintInfo&amp;);
176 
177     using MarkedTextStylesEqualityFunction = bool (*)(const MarkedTextStyle&amp;, const MarkedTextStyle&amp;);
178     Vector&lt;StyledMarkedText&gt; coalesceAdjacentMarkedTexts(const Vector&lt;StyledMarkedText&gt;&amp;, MarkedTextStylesEqualityFunction);
179 
180     FloatPoint textOriginFromBoxRect(const FloatRect&amp;) const;
181 
182     void paintMarkedTexts(PaintInfo&amp;, TextPaintPhase, const FloatRect&amp; boxRect, const Vector&lt;StyledMarkedText&gt;&amp;, const FloatRect&amp; decorationClipOutRect = { });
183 
184     void paintPlatformDocumentMarker(GraphicsContext&amp;, const FloatPoint&amp; boxOrigin, const MarkedText&amp;);
185     void paintPlatformDocumentMarkers(GraphicsContext&amp;, const FloatPoint&amp; boxOrigin);
186 
187     void paintCompositionBackground(PaintInfo&amp;, const FloatPoint&amp; boxOrigin);
188     void paintCompositionUnderlines(PaintInfo&amp;, const FloatPoint&amp; boxOrigin) const;
189     void paintCompositionUnderline(PaintInfo&amp;, const FloatPoint&amp; boxOrigin, const CompositionUnderline&amp;) const;
190 
191     void paintMarkedTextBackground(PaintInfo&amp;, const FloatPoint&amp; boxOrigin, const Color&amp;, unsigned clampedStartOffset, unsigned clampedEndOffset);
192     void paintMarkedTextForeground(PaintInfo&amp;, const FloatRect&amp; boxRect, const StyledMarkedText&amp;);
193     void paintMarkedTextDecoration(PaintInfo&amp;, const FloatRect&amp; boxRect, const FloatRect&amp; clipOutRect, const StyledMarkedText&amp;);
194 
195     const RenderCombineText* combinedText() const;
196     const FontCascade&amp; lineFont() const;
197 
198     String text(bool ignoreCombinedText = false, bool ignoreHyphen = false) const; // The effective text for the run.
199     TextRun createTextRun(bool ignoreCombinedText = false, bool ignoreHyphen = false) const;
200 
201     ExpansionBehavior expansionBehavior() const;
202 
203     void behavesLikeText() const = delete;
204 
205     InlineTextBox* m_prevTextBox { nullptr }; // The previous box that also uses our RenderObject
206     InlineTextBox* m_nextTextBox { nullptr }; // The next box that also uses our RenderObject
207 
208     unsigned m_start { 0 };
209     unsigned short m_len { 0 };
210 
211     // Where to truncate when text overflow is applied. We use special constants to
212     // denote no truncation (the whole run paints) and full truncation (nothing paints at all).
213     unsigned short m_truncation { cNoTruncation };
214 };
215 
216 } // namespace WebCore
217 
218 SPECIALIZE_TYPE_TRAITS_INLINE_BOX(InlineTextBox, isInlineTextBox())
    </pre>
  </body>
</html>
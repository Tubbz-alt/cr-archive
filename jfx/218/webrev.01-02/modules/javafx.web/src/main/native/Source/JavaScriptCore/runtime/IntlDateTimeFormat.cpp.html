<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlDateTimeFormat.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
   3  * Copyright (C) 2016-2020 Apple Inc. All rights reserved.
   4  *
   5  * Redistribution and use in source and binary forms, with or without
   6  * modification, are permitted provided that the following conditions
   7  * are met:
   8  * 1. Redistributions of source code must retain the above copyright
   9  *    notice, this list of conditions and the following disclaimer.
  10  * 2. Redistributions in binary form must reproduce the above copyright
  11  *    notice, this list of conditions and the following disclaimer in the
  12  *    documentation and/or other materials provided with the distribution.
  13  *
  14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  15  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  16  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  17  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  18  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  19  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  20  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  21  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  22  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  23  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  24  * THE POSSIBILITY OF SUCH DAMAGE.
  25  */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;IntlDateTimeFormat.h&quot;
  29 
  30 #if ENABLE(INTL)
  31 
  32 #include &quot;DateInstance.h&quot;
  33 #include &quot;Error.h&quot;
  34 #include &quot;IntlDateTimeFormatConstructor.h&quot;
  35 #include &quot;IntlObject.h&quot;
  36 #include &quot;JSBoundFunction.h&quot;
  37 #include &quot;JSCInlines.h&quot;
  38 #include &quot;ObjectConstructor.h&quot;
  39 #include &lt;unicode/ucal.h&gt;
  40 #include &lt;unicode/udatpg.h&gt;
  41 #include &lt;unicode/uenum.h&gt;
  42 #include &lt;wtf/text/StringBuilder.h&gt;
  43 
  44 #if JSC_ICU_HAS_UFIELDPOSITER
  45 #include &lt;unicode/ufieldpositer.h&gt;
  46 #endif
  47 
  48 namespace JSC {
  49 
  50 static const double minECMAScriptTime = -8.64E15;
  51 
  52 const ClassInfo IntlDateTimeFormat::s_info = { &quot;Object&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(IntlDateTimeFormat) };
  53 
  54 namespace IntlDTFInternal {
  55 static const char* const relevantExtensionKeys[3] = { &quot;ca&quot;, &quot;nu&quot;, &quot;hc&quot; };
  56 }
  57 
  58 static const size_t indexOfExtensionKeyCa = 0;
  59 static const size_t indexOfExtensionKeyNu = 1;
  60 static const size_t indexOfExtensionKeyHc = 2;
  61 
  62 void IntlDateTimeFormat::UDateFormatDeleter::operator()(UDateFormat* dateFormat) const
  63 {
  64     if (dateFormat)
  65         udat_close(dateFormat);
  66 }
  67 
  68 #if JSC_ICU_HAS_UFIELDPOSITER
  69 void IntlDateTimeFormat::UFieldPositionIteratorDeleter::operator()(UFieldPositionIterator* iterator) const
  70 {
  71     if (iterator)
  72         ufieldpositer_close(iterator);
  73 }
  74 #endif
  75 
  76 IntlDateTimeFormat* IntlDateTimeFormat::create(VM&amp; vm, Structure* structure)
  77 {
  78     IntlDateTimeFormat* format = new (NotNull, allocateCell&lt;IntlDateTimeFormat&gt;(vm.heap)) IntlDateTimeFormat(vm, structure);
  79     format-&gt;finishCreation(vm);
  80     return format;
  81 }
  82 
  83 Structure* IntlDateTimeFormat::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  84 {
  85     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
  86 }
  87 
  88 IntlDateTimeFormat::IntlDateTimeFormat(VM&amp; vm, Structure* structure)
  89     : Base(vm, structure)
  90 {
  91 }
  92 
  93 void IntlDateTimeFormat::finishCreation(VM&amp; vm)
  94 {
  95     Base::finishCreation(vm);
  96     ASSERT(inherits(vm, info()));
  97 }
  98 
  99 void IntlDateTimeFormat::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 100 {
 101     IntlDateTimeFormat* thisObject = jsCast&lt;IntlDateTimeFormat*&gt;(cell);
 102     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 103 
 104     Base::visitChildren(thisObject, visitor);
 105 
 106     visitor.append(thisObject-&gt;m_boundFormat);
 107 }
 108 
 109 void IntlDateTimeFormat::setBoundFormat(VM&amp; vm, JSBoundFunction* format)
 110 {
 111     m_boundFormat.set(vm, this, format);
 112 }
 113 
 114 static String defaultTimeZone()
 115 {
 116     // 6.4.3 DefaultTimeZone () (ECMA-402 2.0)
 117     // The DefaultTimeZone abstract operation returns a String value representing the valid (6.4.1) and canonicalized (6.4.2) time zone name for the host environment’s current time zone.
 118 
 119     UErrorCode status = U_ZERO_ERROR;
 120     Vector&lt;UChar, 32&gt; buffer(32);
 121     auto bufferLength = ucal_getDefaultTimeZone(buffer.data(), buffer.size(), &amp;status);
 122     if (status == U_BUFFER_OVERFLOW_ERROR) {
 123         status = U_ZERO_ERROR;
 124         buffer.grow(bufferLength);
 125         ucal_getDefaultTimeZone(buffer.data(), bufferLength, &amp;status);
 126     }
 127     if (U_SUCCESS(status)) {
 128         status = U_ZERO_ERROR;
 129         Vector&lt;UChar, 32&gt; canonicalBuffer(32);
 130         auto canonicalLength = ucal_getCanonicalTimeZoneID(buffer.data(), bufferLength, canonicalBuffer.data(), canonicalBuffer.size(), nullptr, &amp;status);
 131         if (status == U_BUFFER_OVERFLOW_ERROR) {
 132             status = U_ZERO_ERROR;
 133             canonicalBuffer.grow(canonicalLength);
 134             ucal_getCanonicalTimeZoneID(buffer.data(), bufferLength, canonicalBuffer.data(), canonicalLength, nullptr, &amp;status);
 135         }
 136         if (U_SUCCESS(status))
 137             return String(canonicalBuffer.data(), canonicalLength);
 138     }
 139 
 140     return &quot;UTC&quot;_s;
 141 }
 142 
 143 static String canonicalizeTimeZoneName(const String&amp; timeZoneName)
 144 {
 145     // 6.4.1 IsValidTimeZoneName (timeZone)
 146     // The abstract operation returns true if timeZone, converted to upper case as described in 6.1, is equal to one of the Zone or Link names of the IANA Time Zone Database, converted to upper case as described in 6.1. It returns false otherwise.
 147     UErrorCode status = U_ZERO_ERROR;
 148     UEnumeration* timeZones = ucal_openTimeZones(&amp;status);
 149     ASSERT(U_SUCCESS(status));
 150 
 151     String canonical;
 152     do {
 153         status = U_ZERO_ERROR;
 154         int32_t ianaTimeZoneLength;
 155         // Time zone names are respresented as UChar[] in all related ICU apis.
 156         const UChar* ianaTimeZone = uenum_unext(timeZones, &amp;ianaTimeZoneLength, &amp;status);
 157         ASSERT(U_SUCCESS(status));
 158 
 159         // End of enumeration.
 160         if (!ianaTimeZone)
 161             break;
 162 
 163         StringView ianaTimeZoneView(ianaTimeZone, ianaTimeZoneLength);
 164         if (!equalIgnoringASCIICase(timeZoneName, ianaTimeZoneView))
 165             continue;
 166 
 167         // Found a match, now canonicalize.
 168         // 6.4.2 CanonicalizeTimeZoneName (timeZone) (ECMA-402 2.0)
 169         // 1. Let ianaTimeZone be the Zone or Link name of the IANA Time Zone Database such that timeZone, converted to upper case as described in 6.1, is equal to ianaTimeZone, converted to upper case as described in 6.1.
 170         // 2. If ianaTimeZone is a Link name, then let ianaTimeZone be the corresponding Zone name as specified in the “backward” file of the IANA Time Zone Database.
 171 
 172         Vector&lt;UChar, 32&gt; buffer(ianaTimeZoneLength);
 173         status = U_ZERO_ERROR;
 174         auto canonicalLength = ucal_getCanonicalTimeZoneID(ianaTimeZone, ianaTimeZoneLength, buffer.data(), ianaTimeZoneLength, nullptr, &amp;status);
 175         if (status == U_BUFFER_OVERFLOW_ERROR) {
 176             buffer.grow(canonicalLength);
 177             status = U_ZERO_ERROR;
 178             ucal_getCanonicalTimeZoneID(ianaTimeZone, ianaTimeZoneLength, buffer.data(), canonicalLength, nullptr, &amp;status);
 179         }
 180         ASSERT(U_SUCCESS(status));
 181         canonical = String(buffer.data(), canonicalLength);
 182     } while (canonical.isNull());
 183     uenum_close(timeZones);
 184 
 185     // 3. If ianaTimeZone is &quot;Etc/UTC&quot; or &quot;Etc/GMT&quot;, then return &quot;UTC&quot;.
 186     if (canonical == &quot;Etc/UTC&quot; || canonical == &quot;Etc/GMT&quot;)
 187         canonical = &quot;UTC&quot;_s;
 188 
 189     // 4. Return ianaTimeZone.
 190     return canonical;
 191 }
 192 
 193 namespace IntlDTFInternal {
 194 static Vector&lt;String&gt; localeData(const String&amp; locale, size_t keyIndex)
 195 {
 196     Vector&lt;String&gt; keyLocaleData;
 197     switch (keyIndex) {
 198     case indexOfExtensionKeyCa: {
 199         UErrorCode status = U_ZERO_ERROR;
 200         UEnumeration* calendars = ucal_getKeywordValuesForLocale(&quot;calendar&quot;, locale.utf8().data(), false, &amp;status);
 201         ASSERT(U_SUCCESS(status));
 202 
 203         int32_t nameLength;
 204         while (const char* availableName = uenum_next(calendars, &amp;nameLength, &amp;status)) {
 205             ASSERT(U_SUCCESS(status));
 206             String calendar = String(availableName, nameLength);
 207             keyLocaleData.append(calendar);
 208             // Ensure aliases used in language tag are allowed.
 209             if (calendar == &quot;gregorian&quot;)
 210                 keyLocaleData.append(&quot;gregory&quot;_s);
 211             else if (calendar == &quot;islamic-civil&quot;)
 212                 keyLocaleData.append(&quot;islamicc&quot;_s);
 213             else if (calendar == &quot;ethiopic-amete-alem&quot;)
 214                 keyLocaleData.append(&quot;ethioaa&quot;_s);
 215         }
 216         uenum_close(calendars);
 217         break;
 218     }
 219     case indexOfExtensionKeyNu:
 220         keyLocaleData = numberingSystemsForLocale(locale);
 221         break;
 222     case indexOfExtensionKeyHc:
 223         // Null default so we know to use &#39;j&#39; in pattern.
 224         keyLocaleData.append(String());
 225         keyLocaleData.append(&quot;h11&quot;_s);
 226         keyLocaleData.append(&quot;h12&quot;_s);
 227         keyLocaleData.append(&quot;h23&quot;_s);
 228         keyLocaleData.append(&quot;h24&quot;_s);
 229         break;
 230     default:
 231         ASSERT_NOT_REACHED();
 232     }
 233     return keyLocaleData;
 234 }
 235 
 236 static JSObject* toDateTimeOptionsAnyDate(JSGlobalObject* globalObject, JSValue originalOptions)
 237 {
 238     // 12.1.1 ToDateTimeOptions abstract operation (ECMA-402 2.0)
 239     VM&amp; vm = globalObject-&gt;vm();
 240     auto scope = DECLARE_THROW_SCOPE(vm);
 241 
 242     // 1. If options is undefined, then let options be null, else let options be ToObject(options).
 243     // 2. ReturnIfAbrupt(options).
 244     // 3. Let options be ObjectCreate(options).
 245     JSObject* options;
 246     if (originalOptions.isUndefined())
 247         options = constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure());
 248     else {
 249         JSObject* originalToObject = originalOptions.toObject(globalObject);
 250         RETURN_IF_EXCEPTION(scope, nullptr);
 251         options = constructEmptyObject(globalObject, originalToObject);
 252     }
 253 
 254     // 4. Let needDefaults be true.
 255     bool needDefaults = true;
 256 
 257     // 5. If required is &quot;date&quot; or &quot;any&quot;,
 258     // Always &quot;any&quot;.
 259 
 260     // a. For each of the property names &quot;weekday&quot;, &quot;year&quot;, &quot;month&quot;, &quot;day&quot;:
 261     // i. Let prop be the property name.
 262     // ii. Let value be Get(options, prop).
 263     // iii. ReturnIfAbrupt(value).
 264     // iv. If value is not undefined, then let needDefaults be false.
 265     JSValue weekday = options-&gt;get(globalObject, vm.propertyNames-&gt;weekday);
 266     RETURN_IF_EXCEPTION(scope, nullptr);
 267     if (!weekday.isUndefined())
 268         needDefaults = false;
 269 
 270     JSValue year = options-&gt;get(globalObject, vm.propertyNames-&gt;year);
 271     RETURN_IF_EXCEPTION(scope, nullptr);
 272     if (!year.isUndefined())
 273         needDefaults = false;
 274 
 275     JSValue month = options-&gt;get(globalObject, vm.propertyNames-&gt;month);
 276     RETURN_IF_EXCEPTION(scope, nullptr);
 277     if (!month.isUndefined())
 278         needDefaults = false;
 279 
 280     JSValue day = options-&gt;get(globalObject, vm.propertyNames-&gt;day);
 281     RETURN_IF_EXCEPTION(scope, nullptr);
 282     if (!day.isUndefined())
 283         needDefaults = false;
 284 
 285     // 6. If required is &quot;time&quot; or &quot;any&quot;,
 286     // Always &quot;any&quot;.
 287 
 288     // a. For each of the property names &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;:
 289     // i. Let prop be the property name.
 290     // ii. Let value be Get(options, prop).
 291     // iii. ReturnIfAbrupt(value).
 292     // iv. If value is not undefined, then let needDefaults be false.
 293     JSValue hour = options-&gt;get(globalObject, vm.propertyNames-&gt;hour);
 294     RETURN_IF_EXCEPTION(scope, nullptr);
 295     if (!hour.isUndefined())
 296         needDefaults = false;
 297 
 298     JSValue minute = options-&gt;get(globalObject, vm.propertyNames-&gt;minute);
 299     RETURN_IF_EXCEPTION(scope, nullptr);
 300     if (!minute.isUndefined())
 301         needDefaults = false;
 302 
 303     JSValue second = options-&gt;get(globalObject, vm.propertyNames-&gt;second);
 304     RETURN_IF_EXCEPTION(scope, nullptr);
 305     if (!second.isUndefined())
 306         needDefaults = false;
 307 
 308     // 7. If needDefaults is true and defaults is either &quot;date&quot; or &quot;all&quot;, then
 309     // Defaults is always &quot;date&quot;.
 310     if (needDefaults) {
 311         // a. For each of the property names &quot;year&quot;, &quot;month&quot;, &quot;day&quot;:
 312         // i. Let status be CreateDatePropertyOrThrow(options, prop, &quot;numeric&quot;).
 313         // ii. ReturnIfAbrupt(status).
 314         JSString* numeric = jsNontrivialString(vm, &quot;numeric&quot;_s);
 315 
 316         options-&gt;putDirect(vm, vm.propertyNames-&gt;year, numeric);
 317         RETURN_IF_EXCEPTION(scope, nullptr);
 318 
 319         options-&gt;putDirect(vm, vm.propertyNames-&gt;month, numeric);
 320         RETURN_IF_EXCEPTION(scope, nullptr);
 321 
 322         options-&gt;putDirect(vm, vm.propertyNames-&gt;day, numeric);
 323         RETURN_IF_EXCEPTION(scope, nullptr);
 324     }
 325 
 326     // 8. If needDefaults is true and defaults is either &quot;time&quot; or &quot;all&quot;, then
 327     // Defaults is always &quot;date&quot;. Ignore this branch.
 328 
 329     // 9. Return options.
 330     return options;
 331 }
 332 }
 333 
 334 void IntlDateTimeFormat::setFormatsFromPattern(const StringView&amp; pattern)
 335 {
 336     // Get all symbols from the pattern, and set format fields accordingly.
 337     // http://unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 338     unsigned length = pattern.length();
 339     for (unsigned i = 0; i &lt; length; ++i) {
 340         UChar currentCharacter = pattern[i];
 341         if (!isASCIIAlpha(currentCharacter))
 342             continue;
 343 
 344         unsigned count = 1;
 345         while (i + 1 &lt; length &amp;&amp; pattern[i + 1] == currentCharacter) {
 346             ++count;
 347             ++i;
 348         }
 349 
 350         // If hourCycle was null, this sets it to the locale default.
 351         if (m_hourCycle.isNull()) {
 352             if (currentCharacter == &#39;h&#39;)
 353                 m_hourCycle = &quot;h12&quot;_s;
 354             else if (currentCharacter == &#39;H&#39;)
 355                 m_hourCycle = &quot;h23&quot;_s;
 356             else if (currentCharacter == &#39;k&#39;)
 357                 m_hourCycle = &quot;h24&quot;_s;
 358             else if (currentCharacter == &#39;K&#39;)
 359                 m_hourCycle = &quot;h11&quot;_s;
 360         }
 361 
 362         switch (currentCharacter) {
 363         case &#39;G&#39;:
 364             if (count &lt;= 3)
 365                 m_era = Era::Short;
 366             else if (count == 4)
 367                 m_era = Era::Long;
 368             else if (count == 5)
 369                 m_era = Era::Narrow;
 370             break;
 371         case &#39;y&#39;:
 372             if (count == 1)
 373                 m_year = Year::Numeric;
 374             else if (count == 2)
 375                 m_year = Year::TwoDigit;
 376             break;
 377         case &#39;M&#39;:
 378         case &#39;L&#39;:
 379             if (count == 1)
 380                 m_month = Month::Numeric;
 381             else if (count == 2)
 382                 m_month = Month::TwoDigit;
 383             else if (count == 3)
 384                 m_month = Month::Short;
 385             else if (count == 4)
 386                 m_month = Month::Long;
 387             else if (count == 5)
 388                 m_month = Month::Narrow;
 389             break;
 390         case &#39;E&#39;:
 391         case &#39;e&#39;:
 392         case &#39;c&#39;:
 393             if (count &lt;= 3)
 394                 m_weekday = Weekday::Short;
 395             else if (count == 4)
 396                 m_weekday = Weekday::Long;
 397             else if (count == 5)
 398                 m_weekday = Weekday::Narrow;
 399             break;
 400         case &#39;d&#39;:
 401             if (count == 1)
 402                 m_day = Day::Numeric;
 403             else if (count == 2)
 404                 m_day = Day::TwoDigit;
 405             break;
 406         case &#39;h&#39;:
 407         case &#39;H&#39;:
 408         case &#39;k&#39;:
 409         case &#39;K&#39;:
 410             if (count == 1)
 411                 m_hour = Hour::Numeric;
 412             else if (count == 2)
 413                 m_hour = Hour::TwoDigit;
 414             break;
 415         case &#39;m&#39;:
 416             if (count == 1)
 417                 m_minute = Minute::Numeric;
 418             else if (count == 2)
 419                 m_minute = Minute::TwoDigit;
 420             break;
 421         case &#39;s&#39;:
 422             if (count == 1)
 423                 m_second = Second::Numeric;
 424             else if (count == 2)
 425                 m_second = Second::TwoDigit;
 426             break;
 427         case &#39;z&#39;:
 428         case &#39;v&#39;:
 429         case &#39;V&#39;:
 430             if (count == 1)
 431                 m_timeZoneName = TimeZoneName::Short;
 432             else if (count == 4)
 433                 m_timeZoneName = TimeZoneName::Long;
 434             break;
 435         }
 436     }
 437 }
 438 
 439 void IntlDateTimeFormat::initializeDateTimeFormat(JSGlobalObject* globalObject, JSValue locales, JSValue originalOptions)
 440 {
 441     VM&amp; vm = globalObject-&gt;vm();
 442     auto scope = DECLARE_THROW_SCOPE(vm);
 443 
 444     // 12.1.1 InitializeDateTimeFormat (dateTimeFormat, locales, options) (ECMA-402)
 445     // https://tc39.github.io/ecma402/#sec-initializedatetimeformat
 446 
 447     Vector&lt;String&gt; requestedLocales = canonicalizeLocaleList(globalObject, locales);
 448     RETURN_IF_EXCEPTION(scope, void());
 449 
 450     JSObject* options = IntlDTFInternal::toDateTimeOptionsAnyDate(globalObject, originalOptions);
 451     RETURN_IF_EXCEPTION(scope, void());
 452 
 453     HashMap&lt;String, String&gt; opt;
 454 
 455     String localeMatcher = intlStringOption(globalObject, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);
 456     RETURN_IF_EXCEPTION(scope, void());
 457     opt.add(vm.propertyNames-&gt;localeMatcher.string(), localeMatcher);
 458 
 459     bool isHour12Undefined;
 460     bool hour12 = intlBooleanOption(globalObject, options, vm.propertyNames-&gt;hour12, isHour12Undefined);
 461     RETURN_IF_EXCEPTION(scope, void());
 462 
 463     String hourCycle = intlStringOption(globalObject, options, vm.propertyNames-&gt;hourCycle, { &quot;h11&quot;, &quot;h12&quot;, &quot;h23&quot;, &quot;h24&quot; }, &quot;hourCycle must be \&quot;h11\&quot;, \&quot;h12\&quot;, \&quot;h23\&quot;, or \&quot;h24\&quot;&quot;, nullptr);
 464     RETURN_IF_EXCEPTION(scope, void());
 465     if (isHour12Undefined) {
 466         // Set hour12 here to simplify hour logic later.
 467         hour12 = (hourCycle == &quot;h11&quot; || hourCycle == &quot;h12&quot;);
 468         if (!hourCycle.isNull())
 469             opt.add(&quot;hc&quot;_s, hourCycle);
 470     } else
 471         opt.add(&quot;hc&quot;_s, String());
 472 
 473     const HashSet&lt;String&gt;&amp; availableLocales = intlDateTimeFormatAvailableLocales();
 474     HashMap&lt;String, String&gt; resolved = resolveLocale(globalObject, availableLocales, requestedLocales, opt, IntlDTFInternal::relevantExtensionKeys, WTF_ARRAY_LENGTH(IntlDTFInternal::relevantExtensionKeys), IntlDTFInternal::localeData);
 475 
 476     m_locale = resolved.get(vm.propertyNames-&gt;locale.string());
 477     if (m_locale.isEmpty()) {
 478         throwTypeError(globalObject, scope, &quot;failed to initialize DateTimeFormat due to invalid locale&quot;_s);
 479         return;
 480     }
 481 
 482     m_calendar = resolved.get(&quot;ca&quot;_s);
 483     if (m_calendar == &quot;gregorian&quot;)
 484         m_calendar = &quot;gregory&quot;_s;
 485     else if (m_calendar == &quot;islamicc&quot;)
 486         m_calendar = &quot;islamic-civil&quot;_s;
 487     else if (m_calendar == &quot;ethioaa&quot;)
 488         m_calendar = &quot;ethiopic-amete-alem&quot;_s;
 489 
 490     m_hourCycle = resolved.get(&quot;hc&quot;_s);
 491     m_numberingSystem = resolved.get(&quot;nu&quot;_s);
 492     String dataLocale = resolved.get(&quot;dataLocale&quot;_s);
 493 
 494     JSValue tzValue = options-&gt;get(globalObject, vm.propertyNames-&gt;timeZone);
 495     RETURN_IF_EXCEPTION(scope, void());
 496     String tz;
 497     if (!tzValue.isUndefined()) {
 498         String originalTz = tzValue.toWTFString(globalObject);
 499         RETURN_IF_EXCEPTION(scope, void());
 500         tz = canonicalizeTimeZoneName(originalTz);
 501         if (tz.isNull()) {
 502             throwRangeError(globalObject, scope, &quot;invalid time zone: &quot; + originalTz);
 503             return;
 504         }
 505     } else
 506         tz = defaultTimeZone();
 507     m_timeZone = tz;
 508 
 509     StringBuilder skeletonBuilder;
 510     auto narrowShortLong = { &quot;narrow&quot;, &quot;short&quot;, &quot;long&quot; };
 511     auto twoDigitNumeric = { &quot;2-digit&quot;, &quot;numeric&quot; };
 512     auto twoDigitNumericNarrowShortLong = { &quot;2-digit&quot;, &quot;numeric&quot;, &quot;narrow&quot;, &quot;short&quot;, &quot;long&quot; };
 513     auto shortLong = { &quot;short&quot;, &quot;long&quot; };
 514 
 515     String weekday = intlStringOption(globalObject, options, vm.propertyNames-&gt;weekday, narrowShortLong, &quot;weekday must be \&quot;narrow\&quot;, \&quot;short\&quot;, or \&quot;long\&quot;&quot;, nullptr);
 516     RETURN_IF_EXCEPTION(scope, void());
 517     if (!weekday.isNull()) {
 518         if (weekday == &quot;narrow&quot;)
 519             skeletonBuilder.appendLiteral(&quot;EEEEE&quot;);
 520         else if (weekday == &quot;short&quot;)
 521             skeletonBuilder.appendLiteral(&quot;EEE&quot;);
 522         else if (weekday == &quot;long&quot;)
 523             skeletonBuilder.appendLiteral(&quot;EEEE&quot;);
 524     }
 525 
 526     String era = intlStringOption(globalObject, options, vm.propertyNames-&gt;era, narrowShortLong, &quot;era must be \&quot;narrow\&quot;, \&quot;short\&quot;, or \&quot;long\&quot;&quot;, nullptr);
 527     RETURN_IF_EXCEPTION(scope, void());
 528     if (!era.isNull()) {
 529         if (era == &quot;narrow&quot;)
 530             skeletonBuilder.appendLiteral(&quot;GGGGG&quot;);
 531         else if (era == &quot;short&quot;)
 532             skeletonBuilder.appendLiteral(&quot;GGG&quot;);
 533         else if (era == &quot;long&quot;)
 534             skeletonBuilder.appendLiteral(&quot;GGGG&quot;);
 535     }
 536 
 537     String year = intlStringOption(globalObject, options, vm.propertyNames-&gt;year, twoDigitNumeric, &quot;year must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);
 538     RETURN_IF_EXCEPTION(scope, void());
 539     if (!year.isNull()) {
 540         if (year == &quot;2-digit&quot;)
 541             skeletonBuilder.appendLiteral(&quot;yy&quot;);
 542         else if (year == &quot;numeric&quot;)
 543             skeletonBuilder.append(&#39;y&#39;);
 544     }
 545 
 546     String month = intlStringOption(globalObject, options, vm.propertyNames-&gt;month, twoDigitNumericNarrowShortLong, &quot;month must be \&quot;2-digit\&quot;, \&quot;numeric\&quot;, \&quot;narrow\&quot;, \&quot;short\&quot;, or \&quot;long\&quot;&quot;, nullptr);
 547     RETURN_IF_EXCEPTION(scope, void());
 548     if (!month.isNull()) {
 549         if (month == &quot;2-digit&quot;)
 550             skeletonBuilder.appendLiteral(&quot;MM&quot;);
 551         else if (month == &quot;numeric&quot;)
 552             skeletonBuilder.append(&#39;M&#39;);
 553         else if (month == &quot;narrow&quot;)
 554             skeletonBuilder.appendLiteral(&quot;MMMMM&quot;);
 555         else if (month == &quot;short&quot;)
 556             skeletonBuilder.appendLiteral(&quot;MMM&quot;);
 557         else if (month == &quot;long&quot;)
 558             skeletonBuilder.appendLiteral(&quot;MMMM&quot;);
 559     }
 560 
 561     String day = intlStringOption(globalObject, options, vm.propertyNames-&gt;day, twoDigitNumeric, &quot;day must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);
 562     RETURN_IF_EXCEPTION(scope, void());
 563     if (!day.isNull()) {
 564         if (day == &quot;2-digit&quot;)
 565             skeletonBuilder.appendLiteral(&quot;dd&quot;);
 566         else if (day == &quot;numeric&quot;)
 567             skeletonBuilder.append(&#39;d&#39;);
 568     }
 569 
 570     String hour = intlStringOption(globalObject, options, vm.propertyNames-&gt;hour, twoDigitNumeric, &quot;hour must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);
 571     RETURN_IF_EXCEPTION(scope, void());
 572     if (hour == &quot;2-digit&quot;) {
 573         if (isHour12Undefined &amp;&amp; m_hourCycle.isNull())
 574             skeletonBuilder.appendLiteral(&quot;jj&quot;);
 575         else if (hour12)
 576             skeletonBuilder.appendLiteral(&quot;hh&quot;);
 577         else
 578             skeletonBuilder.appendLiteral(&quot;HH&quot;);
 579     } else if (hour == &quot;numeric&quot;) {
 580         if (isHour12Undefined &amp;&amp; m_hourCycle.isNull())
 581             skeletonBuilder.append(&#39;j&#39;);
 582         else if (hour12)
 583             skeletonBuilder.append(&#39;h&#39;);
 584         else
 585             skeletonBuilder.append(&#39;H&#39;);
 586     } else
 587         m_hourCycle = String();
 588 
 589     String minute = intlStringOption(globalObject, options, vm.propertyNames-&gt;minute, twoDigitNumeric, &quot;minute must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);
 590     RETURN_IF_EXCEPTION(scope, void());
 591     if (!minute.isNull()) {
 592         if (minute == &quot;2-digit&quot;)
 593             skeletonBuilder.appendLiteral(&quot;mm&quot;);
 594         else if (minute == &quot;numeric&quot;)
 595             skeletonBuilder.append(&#39;m&#39;);
 596     }
 597 
 598     String second = intlStringOption(globalObject, options, vm.propertyNames-&gt;second, twoDigitNumeric, &quot;second must be \&quot;2-digit\&quot; or \&quot;numeric\&quot;&quot;, nullptr);
 599     RETURN_IF_EXCEPTION(scope, void());
 600     if (!second.isNull()) {
 601         if (second == &quot;2-digit&quot;)
 602             skeletonBuilder.appendLiteral(&quot;ss&quot;);
 603         else if (second == &quot;numeric&quot;)
 604             skeletonBuilder.append(&#39;s&#39;);
 605     }
 606 
 607     String timeZoneName = intlStringOption(globalObject, options, vm.propertyNames-&gt;timeZoneName, shortLong, &quot;timeZoneName must be \&quot;short\&quot; or \&quot;long\&quot;&quot;, nullptr);
 608     RETURN_IF_EXCEPTION(scope, void());
 609     if (!timeZoneName.isNull()) {
 610         if (timeZoneName == &quot;short&quot;)
 611             skeletonBuilder.append(&#39;z&#39;);
 612         else if (timeZoneName == &quot;long&quot;)
 613             skeletonBuilder.appendLiteral(&quot;zzzz&quot;);
 614     }
 615 
 616     intlStringOption(globalObject, options, vm.propertyNames-&gt;formatMatcher, { &quot;basic&quot;, &quot;best fit&quot; }, &quot;formatMatcher must be either \&quot;basic\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);
 617     RETURN_IF_EXCEPTION(scope, void());
 618 
 619     // Always use ICU date format generator, rather than our own pattern list and matcher.
 620     UErrorCode status = U_ZERO_ERROR;
 621     UDateTimePatternGenerator* generator = udatpg_open(dataLocale.utf8().data(), &amp;status);
 622     if (U_FAILURE(status)) {
 623         throwTypeError(globalObject, scope, &quot;failed to initialize DateTimeFormat&quot;_s);
 624         return;
 625     }
 626 
 627     String skeleton = skeletonBuilder.toString();
 628     StringView skeletonView(skeleton);
 629     Vector&lt;UChar, 32&gt; patternBuffer(32);
 630     status = U_ZERO_ERROR;
 631     auto patternLength = udatpg_getBestPatternWithOptions(generator, skeletonView.upconvertedCharacters(), skeletonView.length(), UDATPG_MATCH_HOUR_FIELD_LENGTH, patternBuffer.data(), patternBuffer.size(), &amp;status);
 632     if (status == U_BUFFER_OVERFLOW_ERROR) {
 633         status = U_ZERO_ERROR;
 634         patternBuffer.grow(patternLength);
 635         udatpg_getBestPattern(generator, skeletonView.upconvertedCharacters(), skeletonView.length(), patternBuffer.data(), patternLength, &amp;status);
 636     }
 637     udatpg_close(generator);
 638     if (U_FAILURE(status)) {
 639         throwTypeError(globalObject, scope, &quot;failed to initialize DateTimeFormat&quot;_s);
 640         return;
 641     }
 642 
 643     // Enforce our hourCycle, replacing hour characters in pattern.
 644     if (!m_hourCycle.isNull()) {
 645         UChar hour = &#39;H&#39;;
 646         if (m_hourCycle == &quot;h11&quot;)
 647             hour = &#39;K&#39;;
 648         else if (m_hourCycle == &quot;h12&quot;)
 649             hour = &#39;h&#39;;
 650         else if (m_hourCycle == &quot;h24&quot;)
 651             hour = &#39;k&#39;;
 652 
 653         bool isEscaped = false;
 654         bool hasHour = false;
 655         for (auto i = 0; i &lt; patternLength; ++i) {
 656             UChar c = patternBuffer[i];
 657             if (c == &#39;\&#39;&#39;)
 658                 isEscaped = !isEscaped;
 659             else if (!isEscaped &amp;&amp; (c == &#39;h&#39; || c == &#39;H&#39; || c == &#39;k&#39; || c == &#39;K&#39;)) {
 660                 patternBuffer[i] = hour;
 661                 hasHour = true;
 662             }
 663         }
 664         if (!hasHour)
 665             m_hourCycle = String();
 666     }
 667 
 668     StringView pattern(patternBuffer.data(), patternLength);
 669     setFormatsFromPattern(pattern);
 670 
 671     status = U_ZERO_ERROR;
 672     StringView timeZoneView(m_timeZone);
 673     m_dateFormat = std::unique_ptr&lt;UDateFormat, UDateFormatDeleter&gt;(udat_open(UDAT_PATTERN, UDAT_PATTERN, m_locale.utf8().data(), timeZoneView.upconvertedCharacters(), timeZoneView.length(), pattern.upconvertedCharacters(), pattern.length(), &amp;status));
 674     if (U_FAILURE(status)) {
 675         throwTypeError(globalObject, scope, &quot;failed to initialize DateTimeFormat&quot;_s);
 676         return;
 677     }
 678 
 679     // Gregorian calendar should be used from the beginning of ECMAScript time.
 680     // Failure here means unsupported calendar, and can safely be ignored.
 681     UCalendar* cal = const_cast&lt;UCalendar*&gt;(udat_getCalendar(m_dateFormat.get()));
 682     ucal_setGregorianChange(cal, minECMAScriptTime, &amp;status);
 683 
 684     m_initializedDateTimeFormat = true;
 685 }
 686 
 687 ASCIILiteral IntlDateTimeFormat::weekdayString(Weekday weekday)
 688 {
 689     switch (weekday) {
 690     case Weekday::Narrow:
 691         return &quot;narrow&quot;_s;
 692     case Weekday::Short:
 693         return &quot;short&quot;_s;
 694     case Weekday::Long:
 695         return &quot;long&quot;_s;
 696     case Weekday::None:
 697         ASSERT_NOT_REACHED();
 698         return ASCIILiteral::null();
 699     }
 700     ASSERT_NOT_REACHED();
 701     return ASCIILiteral::null();
 702 }
 703 
 704 ASCIILiteral IntlDateTimeFormat::eraString(Era era)
 705 {
 706     switch (era) {
 707     case Era::Narrow:
 708         return &quot;narrow&quot;_s;
 709     case Era::Short:
 710         return &quot;short&quot;_s;
 711     case Era::Long:
 712         return &quot;long&quot;_s;
 713     case Era::None:
 714         ASSERT_NOT_REACHED();
 715         return ASCIILiteral::null();
 716     }
 717     ASSERT_NOT_REACHED();
 718     return ASCIILiteral::null();
 719 }
 720 
 721 ASCIILiteral IntlDateTimeFormat::yearString(Year year)
 722 {
 723     switch (year) {
 724     case Year::TwoDigit:
 725         return &quot;2-digit&quot;_s;
 726     case Year::Numeric:
 727         return &quot;numeric&quot;_s;
 728     case Year::None:
 729         ASSERT_NOT_REACHED();
 730         return ASCIILiteral::null();
 731     }
 732     ASSERT_NOT_REACHED();
 733     return ASCIILiteral::null();
 734 }
 735 
 736 ASCIILiteral IntlDateTimeFormat::monthString(Month month)
 737 {
 738     switch (month) {
 739     case Month::TwoDigit:
 740         return &quot;2-digit&quot;_s;
 741     case Month::Numeric:
 742         return &quot;numeric&quot;_s;
 743     case Month::Narrow:
 744         return &quot;narrow&quot;_s;
 745     case Month::Short:
 746         return &quot;short&quot;_s;
 747     case Month::Long:
 748         return &quot;long&quot;_s;
 749     case Month::None:
 750         ASSERT_NOT_REACHED();
 751         return ASCIILiteral::null();
 752     }
 753     ASSERT_NOT_REACHED();
 754     return ASCIILiteral::null();
 755 }
 756 
 757 ASCIILiteral IntlDateTimeFormat::dayString(Day day)
 758 {
 759     switch (day) {
 760     case Day::TwoDigit:
 761         return &quot;2-digit&quot;_s;
 762     case Day::Numeric:
 763         return &quot;numeric&quot;_s;
 764     case Day::None:
 765         ASSERT_NOT_REACHED();
 766         return ASCIILiteral::null();
 767     }
 768     ASSERT_NOT_REACHED();
 769     return ASCIILiteral::null();
 770 }
 771 
 772 ASCIILiteral IntlDateTimeFormat::hourString(Hour hour)
 773 {
 774     switch (hour) {
 775     case Hour::TwoDigit:
 776         return &quot;2-digit&quot;_s;
 777     case Hour::Numeric:
 778         return &quot;numeric&quot;_s;
 779     case Hour::None:
 780         ASSERT_NOT_REACHED();
 781         return ASCIILiteral::null();
 782     }
 783     ASSERT_NOT_REACHED();
 784     return ASCIILiteral::null();
 785 }
 786 
 787 ASCIILiteral IntlDateTimeFormat::minuteString(Minute minute)
 788 {
 789     switch (minute) {
 790     case Minute::TwoDigit:
 791         return &quot;2-digit&quot;_s;
 792     case Minute::Numeric:
 793         return &quot;numeric&quot;_s;
 794     case Minute::None:
 795         ASSERT_NOT_REACHED();
 796         return ASCIILiteral::null();
 797     }
 798     ASSERT_NOT_REACHED();
 799     return ASCIILiteral::null();
 800 }
 801 
 802 ASCIILiteral IntlDateTimeFormat::secondString(Second second)
 803 {
 804     switch (second) {
 805     case Second::TwoDigit:
 806         return &quot;2-digit&quot;_s;
 807     case Second::Numeric:
 808         return &quot;numeric&quot;_s;
 809     case Second::None:
 810         ASSERT_NOT_REACHED();
 811         return ASCIILiteral::null();
 812     }
 813     ASSERT_NOT_REACHED();
 814     return ASCIILiteral::null();
 815 }
 816 
 817 ASCIILiteral IntlDateTimeFormat::timeZoneNameString(TimeZoneName timeZoneName)
 818 {
 819     switch (timeZoneName) {
 820     case TimeZoneName::Short:
 821         return &quot;short&quot;_s;
 822     case TimeZoneName::Long:
 823         return &quot;long&quot;_s;
 824     case TimeZoneName::None:
 825         ASSERT_NOT_REACHED();
 826         return ASCIILiteral::null();
 827     }
 828     ASSERT_NOT_REACHED();
 829     return ASCIILiteral::null();
 830 }
 831 
 832 JSObject* IntlDateTimeFormat::resolvedOptions(JSGlobalObject* globalObject)
 833 {
 834     VM&amp; vm = globalObject-&gt;vm();
 835     auto scope = DECLARE_THROW_SCOPE(vm);
 836 
 837     // 12.3.5 Intl.DateTimeFormat.prototype.resolvedOptions() (ECMA-402 2.0)
 838     // The function returns a new object whose properties and attributes are set as if constructed by an object literal assigning to each of the following properties the value of the corresponding internal slot of this DateTimeFormat object (see 12.4): locale, calendar, numberingSystem, timeZone, hour12, weekday, era, year, month, day, hour, minute, second, and timeZoneName. Properties whose corresponding internal slots are not present are not assigned.
 839     // Note: In this version of the ECMAScript 2015 Internationalization API, the timeZone property will be the name of the default time zone if no timeZone property was provided in the options object provided to the Intl.DateTimeFormat constructor. The previous version left the timeZone property undefined in this case.
 840     if (!m_initializedDateTimeFormat) {
 841         initializeDateTimeFormat(globalObject, jsUndefined(), jsUndefined());
 842         scope.assertNoException();
 843     }
 844 
 845     JSObject* options = constructEmptyObject(globalObject);
 846     options-&gt;putDirect(vm, vm.propertyNames-&gt;locale, jsNontrivialString(vm, m_locale));
 847     options-&gt;putDirect(vm, vm.propertyNames-&gt;calendar, jsNontrivialString(vm, m_calendar));
 848     options-&gt;putDirect(vm, vm.propertyNames-&gt;numberingSystem, jsNontrivialString(vm, m_numberingSystem));
 849     options-&gt;putDirect(vm, vm.propertyNames-&gt;timeZone, jsNontrivialString(vm, m_timeZone));
 850 
 851     if (!m_hourCycle.isNull()) {
 852         options-&gt;putDirect(vm, vm.propertyNames-&gt;hourCycle, jsNontrivialString(vm, m_hourCycle));
 853         options-&gt;putDirect(vm, vm.propertyNames-&gt;hour12, jsBoolean(m_hourCycle == &quot;h11&quot; || m_hourCycle == &quot;h12&quot;));
 854     }
 855 
 856     if (m_weekday != Weekday::None)
 857         options-&gt;putDirect(vm, vm.propertyNames-&gt;weekday, jsNontrivialString(vm, weekdayString(m_weekday)));
 858 
 859     if (m_era != Era::None)
 860         options-&gt;putDirect(vm, vm.propertyNames-&gt;era, jsNontrivialString(vm, eraString(m_era)));
 861 
 862     if (m_year != Year::None)
 863         options-&gt;putDirect(vm, vm.propertyNames-&gt;year, jsNontrivialString(vm, yearString(m_year)));
 864 
 865     if (m_month != Month::None)
 866         options-&gt;putDirect(vm, vm.propertyNames-&gt;month, jsNontrivialString(vm, monthString(m_month)));
 867 
 868     if (m_day != Day::None)
 869         options-&gt;putDirect(vm, vm.propertyNames-&gt;day, jsNontrivialString(vm, dayString(m_day)));
 870 
 871     if (m_hour != Hour::None)
 872         options-&gt;putDirect(vm, vm.propertyNames-&gt;hour, jsNontrivialString(vm, hourString(m_hour)));
 873 
 874     if (m_minute != Minute::None)
 875         options-&gt;putDirect(vm, vm.propertyNames-&gt;minute, jsNontrivialString(vm, minuteString(m_minute)));
 876 
 877     if (m_second != Second::None)
 878         options-&gt;putDirect(vm, vm.propertyNames-&gt;second, jsNontrivialString(vm, secondString(m_second)));
 879 
 880     if (m_timeZoneName != TimeZoneName::None)
 881         options-&gt;putDirect(vm, vm.propertyNames-&gt;timeZoneName, jsNontrivialString(vm, timeZoneNameString(m_timeZoneName)));
 882 
 883     return options;
 884 }
 885 
 886 JSValue IntlDateTimeFormat::format(JSGlobalObject* globalObject, double value)
 887 {
 888     VM&amp; vm = globalObject-&gt;vm();
 889     auto scope = DECLARE_THROW_SCOPE(vm);
 890 
 891     // 12.3.4 FormatDateTime abstract operation (ECMA-402 2.0)
 892     if (!m_initializedDateTimeFormat) {
 893         initializeDateTimeFormat(globalObject, jsUndefined(), jsUndefined());
 894         scope.assertNoException();
 895     }
 896 
 897     // 1. If x is not a finite Number, then throw a RangeError exception.
 898     if (!std::isfinite(value))
 899         return throwRangeError(globalObject, scope, &quot;date value is not finite in DateTimeFormat format()&quot;_s);
 900 
 901     // Delegate remaining steps to ICU.
 902     UErrorCode status = U_ZERO_ERROR;
 903     Vector&lt;UChar, 32&gt; result(32);
 904     auto resultLength = udat_format(m_dateFormat.get(), value, result.data(), result.size(), nullptr, &amp;status);
 905     if (status == U_BUFFER_OVERFLOW_ERROR) {
 906         status = U_ZERO_ERROR;
 907         result.grow(resultLength);
 908         udat_format(m_dateFormat.get(), value, result.data(), resultLength, nullptr, &amp;status);
 909     }
 910     if (U_FAILURE(status))
 911         return throwTypeError(globalObject, scope, &quot;failed to format date value&quot;_s);
 912 
 913     return jsString(vm, String(result.data(), resultLength));
 914 }
 915 
 916 #if JSC_ICU_HAS_UFIELDPOSITER
 917 ASCIILiteral IntlDateTimeFormat::partTypeString(UDateFormatField field)
 918 {
 919     switch (field) {
 920     case UDAT_ERA_FIELD:
 921         return &quot;era&quot;_s;
 922     case UDAT_YEAR_FIELD:
 923     case UDAT_YEAR_NAME_FIELD:
 924     case UDAT_EXTENDED_YEAR_FIELD:
 925         return &quot;year&quot;_s;
 926     case UDAT_MONTH_FIELD:
 927     case UDAT_STANDALONE_MONTH_FIELD:
 928         return &quot;month&quot;_s;
 929     case UDAT_DATE_FIELD:
 930         return &quot;day&quot;_s;
 931     case UDAT_HOUR_OF_DAY1_FIELD:
 932     case UDAT_HOUR_OF_DAY0_FIELD:
 933     case UDAT_HOUR1_FIELD:
 934     case UDAT_HOUR0_FIELD:
 935         return &quot;hour&quot;_s;
 936     case UDAT_MINUTE_FIELD:
 937         return &quot;minute&quot;_s;
 938     case UDAT_SECOND_FIELD:
 939     case UDAT_FRACTIONAL_SECOND_FIELD:
 940         return &quot;second&quot;_s;
 941     case UDAT_DAY_OF_WEEK_FIELD:
 942     case UDAT_DOW_LOCAL_FIELD:
 943     case UDAT_STANDALONE_DAY_FIELD:
 944         return &quot;weekday&quot;_s;
 945     case UDAT_AM_PM_FIELD:
 946 #if U_ICU_VERSION_MAJOR_NUM &gt;= 57
 947     case UDAT_AM_PM_MIDNIGHT_NOON_FIELD:
 948     case UDAT_FLEXIBLE_DAY_PERIOD_FIELD:
 949 #endif
 950         return &quot;dayPeriod&quot;_s;
 951     case UDAT_TIMEZONE_FIELD:
 952     case UDAT_TIMEZONE_RFC_FIELD:
 953     case UDAT_TIMEZONE_GENERIC_FIELD:
 954     case UDAT_TIMEZONE_SPECIAL_FIELD:
 955     case UDAT_TIMEZONE_LOCALIZED_GMT_OFFSET_FIELD:
 956     case UDAT_TIMEZONE_ISO_FIELD:
 957     case UDAT_TIMEZONE_ISO_LOCAL_FIELD:
 958         return &quot;timeZoneName&quot;_s;
 959     // These should not show up because there is no way to specify them in DateTimeFormat options.
 960     // If they do, they don&#39;t fit well into any of known part types, so consider it an &quot;unknown&quot;.
 961     case UDAT_DAY_OF_YEAR_FIELD:
 962     case UDAT_DAY_OF_WEEK_IN_MONTH_FIELD:
 963     case UDAT_WEEK_OF_YEAR_FIELD:
 964     case UDAT_WEEK_OF_MONTH_FIELD:
 965     case UDAT_YEAR_WOY_FIELD:
 966     case UDAT_JULIAN_DAY_FIELD:
 967     case UDAT_MILLISECONDS_IN_DAY_FIELD:
 968     case UDAT_QUARTER_FIELD:
 969     case UDAT_STANDALONE_QUARTER_FIELD:
 970     case UDAT_RELATED_YEAR_FIELD:
 971     case UDAT_TIME_SEPARATOR_FIELD:
 972 #if U_ICU_VERSION_MAJOR_NUM &lt; 58 || !defined(U_HIDE_DEPRECATED_API)
 973     case UDAT_FIELD_COUNT:
 974 #endif
 975     // Any newer additions to the UDateFormatField enum should just be considered an &quot;unknown&quot; part.
 976     default:
 977         return &quot;unknown&quot;_s;
 978     }
 979     return &quot;unknown&quot;_s;
 980 }
 981 
 982 
 983 JSValue IntlDateTimeFormat::formatToParts(JSGlobalObject* globalObject, double value)
 984 {
 985     VM&amp; vm = globalObject-&gt;vm();
 986     auto scope = DECLARE_THROW_SCOPE(vm);
 987 
 988     // 12.1.8 FormatDateTimeToParts (ECMA-402 4.0)
 989     // https://tc39.github.io/ecma402/#sec-formatdatetimetoparts
 990 
 991     if (!std::isfinite(value))
 992         return throwRangeError(globalObject, scope, &quot;date value is not finite in DateTimeFormat formatToParts()&quot;_s);
 993 
 994     UErrorCode status = U_ZERO_ERROR;
 995     auto fields = std::unique_ptr&lt;UFieldPositionIterator, UFieldPositionIteratorDeleter&gt;(ufieldpositer_open(&amp;status));
 996     if (U_FAILURE(status))
 997         return throwTypeError(globalObject, scope, &quot;failed to open field position iterator&quot;_s);
 998 
 999     status = U_ZERO_ERROR;
1000     Vector&lt;UChar, 32&gt; result(32);
1001     auto resultLength = udat_formatForFields(m_dateFormat.get(), value, result.data(), result.size(), fields.get(), &amp;status);
1002     if (status == U_BUFFER_OVERFLOW_ERROR) {
1003         status = U_ZERO_ERROR;
1004         result.grow(resultLength);
1005         udat_formatForFields(m_dateFormat.get(), value, result.data(), resultLength, fields.get(), &amp;status);
1006     }
1007     if (U_FAILURE(status))
1008         return throwTypeError(globalObject, scope, &quot;failed to format date value&quot;_s);
1009 
1010     JSArray* parts = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), 0);
1011     if (!parts)
1012         return throwOutOfMemoryError(globalObject, scope);
1013 
1014     auto resultString = String(result.data(), resultLength);
1015     auto typePropertyName = Identifier::fromString(vm, &quot;type&quot;);
1016     auto literalString = jsNontrivialString(vm, &quot;literal&quot;_s);
1017 
1018     int32_t previousEndIndex = 0;
1019     int32_t beginIndex = 0;
1020     int32_t endIndex = 0;
1021     while (previousEndIndex &lt; resultLength) {
1022         auto fieldType = ufieldpositer_next(fields.get(), &amp;beginIndex, &amp;endIndex);
1023         if (fieldType &lt; 0)
1024             beginIndex = endIndex = resultLength;
1025 
1026         if (previousEndIndex &lt; beginIndex) {
1027             auto value = jsString(vm, resultString.substring(previousEndIndex, beginIndex - previousEndIndex));
1028             JSObject* part = constructEmptyObject(globalObject);
1029             part-&gt;putDirect(vm, typePropertyName, literalString);
1030             part-&gt;putDirect(vm, vm.propertyNames-&gt;value, value);
1031             parts-&gt;push(globalObject, part);
1032             RETURN_IF_EXCEPTION(scope, { });
1033         }
1034         previousEndIndex = endIndex;
1035 
1036         if (fieldType &gt;= 0) {
1037             auto type = jsString(vm, partTypeString(UDateFormatField(fieldType)));
1038             auto value = jsString(vm, resultString.substring(beginIndex, endIndex - beginIndex));
1039             JSObject* part = constructEmptyObject(globalObject);
1040             part-&gt;putDirect(vm, typePropertyName, type);
1041             part-&gt;putDirect(vm, vm.propertyNames-&gt;value, value);
1042             parts-&gt;push(globalObject, part);
1043             RETURN_IF_EXCEPTION(scope, { });
1044         }
1045     }
1046 
1047 
1048     return parts;
1049 }
1050 #endif
1051 
1052 } // namespace JSC
1053 
1054 #endif // ENABLE(INTL)
    </pre>
  </body>
</html>
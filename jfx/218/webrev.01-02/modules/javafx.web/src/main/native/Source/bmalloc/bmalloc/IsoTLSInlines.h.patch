diff a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoTLSInlines.h b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoTLSInlines.h
--- a/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoTLSInlines.h
+++ b/modules/javafx.web/src/main/native/Source/bmalloc/bmalloc/IsoTLSInlines.h
@@ -28,10 +28,14 @@
 #include "Environment.h"
 #include "IsoHeapImpl.h"
 #include "IsoTLS.h"
 #include "bmalloc.h"
 
+#if BOS(DARWIN)
+#include <malloc/malloc.h>
+#endif
+
 namespace bmalloc {
 
 template<typename Type>
 void* IsoTLS::allocate(api::IsoHeap<Type>& handle, bool abortOnFailure)
 {
@@ -54,11 +58,11 @@
         return;
     if (!handle.isInitialized())
         return;
     unsigned offset = handle.allocatorOffset();
     if (offset < tls->m_extent)
-        reinterpret_cast<IsoAllocator<typename api::IsoHeap<Type>::Config>*>(tls->m_data + offset)->scavenge();
+        reinterpret_cast<IsoAllocator<typename api::IsoHeap<Type>::Config>*>(tls->m_data + offset)->scavenge(handle.impl());
     offset = handle.deallocatorOffset();
     if (offset < tls->m_extent)
         reinterpret_cast<IsoDeallocator<typename api::IsoHeap<Type>::Config>*>(tls->m_data + offset)->scavenge();
     handle.impl().scavengeNow();
 }
@@ -68,17 +72,17 @@
 {
     unsigned offset = handle.allocatorOffset();
     IsoTLS* tls = get();
     if (!tls || offset >= tls->m_extent)
         return allocateSlow<Config>(handle, abortOnFailure);
-    return tls->allocateFast<Config>(offset, abortOnFailure);
+    return tls->allocateFast<Config>(handle, offset, abortOnFailure);
 }
 
-template<typename Config>
-void* IsoTLS::allocateFast(unsigned offset, bool abortOnFailure)
+template<typename Config, typename Type>
+void* IsoTLS::allocateFast(api::IsoHeap<Type>& handle, unsigned offset, bool abortOnFailure)
 {
-    return reinterpret_cast<IsoAllocator<Config>*>(m_data + offset)->allocate(abortOnFailure);
+    return reinterpret_cast<IsoAllocator<Config>*>(m_data + offset)->allocate(handle.impl(), abortOnFailure);
 }
 
 template<typename Config, typename Type>
 BNO_INLINE void* IsoTLS::allocateSlow(api::IsoHeap<Type>& handle, bool abortOnFailure)
 {
@@ -86,11 +90,15 @@
         switch (s_mallocFallbackState) {
         case MallocFallbackState::Undecided:
             determineMallocFallbackState();
             continue;
         case MallocFallbackState::FallBackToMalloc:
+#if BENABLE_MALLOC_HEAP_BREAKDOWN
+            return malloc_zone_malloc(handle.m_zone, Config::objectSize);
+#else
             return api::tryMalloc(Config::objectSize);
+#endif
         case MallocFallbackState::DoNotFallBack:
             break;
         }
         break;
     }
@@ -98,11 +106,11 @@
     // If debug heap is enabled, s_mallocFallbackState becomes MallocFallbackState::FallBackToMalloc.
     BASSERT(!Environment::get()->isDebugHeapEnabled());
 
     IsoTLS* tls = ensureHeapAndEntries(handle);
 
-    return tls->allocateFast<Config>(handle.allocatorOffset(), abortOnFailure);
+    return tls->allocateFast<Config>(handle, handle.allocatorOffset(), abortOnFailure);
 }
 
 template<typename Config, typename Type>
 void IsoTLS::deallocateImpl(api::IsoHeap<Type>& handle, void* p)
 {
@@ -129,11 +137,15 @@
         switch (s_mallocFallbackState) {
         case MallocFallbackState::Undecided:
             determineMallocFallbackState();
             continue;
         case MallocFallbackState::FallBackToMalloc:
+#if BENABLE_MALLOC_HEAP_BREAKDOWN
+            return malloc_zone_free(handle.m_zone, p);
+#else
             return api::free(p);
+#endif
         case MallocFallbackState::DoNotFallBack:
             break;
         }
         break;
     }
@@ -170,11 +182,11 @@
 
 template<typename Type>
 void IsoTLS::ensureHeap(api::IsoHeap<Type>& handle)
 {
     if (!handle.isInitialized()) {
-        std::lock_guard<Mutex> locker(handle.m_initializationLock);
+        LockHolder locker(handle.m_initializationLock);
         if (!handle.isInitialized())
             handle.initialize();
     }
 }
 

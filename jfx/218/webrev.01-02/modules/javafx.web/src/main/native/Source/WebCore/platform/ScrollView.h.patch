diff a/modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollView.h b/modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollView.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollView.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/platform/ScrollView.h
@@ -118,11 +118,10 @@
     bool verticalScrollbarLock() const { return m_verticalScrollbarLock; }
 
     void setScrollingModesLock(bool lock = true) { m_horizontalScrollbarLock = m_verticalScrollbarLock = lock; }
 
     WEBCORE_EXPORT virtual void setCanHaveScrollbars(bool);
-    bool canHaveScrollbars() const { return horizontalScrollbarMode() != ScrollbarAlwaysOff || verticalScrollbarMode() != ScrollbarAlwaysOff; }
 
     virtual bool avoidScrollbarCreation() const { return false; }
 
     void setScrollbarOverlayStyle(ScrollbarOverlayStyle) final;
 
@@ -138,11 +137,11 @@
     WEBCORE_EXPORT void setDelegatesScrolling(bool);
 
     // Overridden by FrameView to create custom CSS scrollbars if applicable.
     virtual Ref<Scrollbar> createScrollbar(ScrollbarOrientation);
 
-    void styleDidChange();
+    virtual void styleDidChange();
 
     // If the prohibits scrolling flag is set, then all scrolling in the view (even programmatic scrolling) is turned off.
     void setProhibitsScrolling(bool b) { m_prohibitsScrolling = b; }
     bool prohibitsScrolling() const { return m_prohibitsScrolling; }
 
@@ -174,25 +173,27 @@
 
     // Parts of the document can be visible through transparent or blured UI widgets of the chrome. Those parts
     // contribute to painting but not to the scrollable area.
     // The unobscuredContentRect is the area that is not covered by UI elements.
     WEBCORE_EXPORT IntRect unobscuredContentRect(VisibleContentRectIncludesScrollbars = ExcludeScrollbars) const;
+
 #if PLATFORM(IOS_FAMILY)
     IntRect unobscuredContentRectIncludingScrollbars() const { return unobscuredContentRect(IncludeScrollbars); }
 #else
     IntRect unobscuredContentRectIncludingScrollbars() const { return visibleContentRectIncludingScrollbars(); }
 #endif
 
-#if PLATFORM(IOS_FAMILY)
     // This is the area that is partially or fully exposed, and may extend under overlapping UI elements.
     WEBCORE_EXPORT FloatRect exposedContentRect() const;
 
     // The given rects are only used if there is no platform widget.
     WEBCORE_EXPORT void setExposedContentRect(const FloatRect&);
-    const FloatSize& unobscuredContentSize() const { return m_unobscuredContentSize; }
+
+    WEBCORE_EXPORT FloatSize unobscuredContentSize() const;
     WEBCORE_EXPORT void setUnobscuredContentSize(const FloatSize&);
 
+#if PLATFORM(IOS_FAMILY)
     void setActualScrollPosition(const IntPoint&);
     LegacyTileCache* legacyTileCache();
 #endif
 
     // Size available for view contents, including content inset areas. Not affected by zooming.
@@ -228,11 +229,11 @@
     int scrollX() const { return scrollPosition().x(); }
     int scrollY() const { return scrollPosition().y(); }
 
     // Scroll position used by web-exposed features (has legacy iOS behavior).
     WEBCORE_EXPORT IntPoint contentsScrollPosition() const;
-    void setContentsScrollPosition(const IntPoint&);
+    void setContentsScrollPosition(const IntPoint&, ScrollClamping = ScrollClamping::Clamped);
 
 #if PLATFORM(IOS_FAMILY)
     int actualScrollX() const { return unobscuredContentRect().x(); }
     int actualScrollY() const { return unobscuredContentRect().y(); }
     // FIXME: maybe fix scrollPosition() on iOS to return the actual scroll position.
@@ -258,11 +259,11 @@
 
     void cacheCurrentScrollPosition() { m_cachedScrollPosition = scrollPosition(); }
     ScrollPosition cachedScrollPosition() const { return m_cachedScrollPosition; }
 
     // Functions for scrolling the view.
-    virtual void setScrollPosition(const ScrollPosition&);
+    virtual void setScrollPosition(const ScrollPosition&, ScrollClamping = ScrollClamping::Clamped);
     void scrollBy(const IntSize& s) { return setScrollPosition(scrollPosition() + s); }
 
     // This function scrolls by lines, pages or pixels.
     bool scroll(ScrollDirection, ScrollGranularity);
 
@@ -423,13 +424,11 @@
 
     virtual bool shouldDeferScrollUpdateAfterContentSizeChange() = 0;
 
     virtual void scrollOffsetChangedViaPlatformWidgetImpl(const ScrollOffset&, const ScrollOffset&) = 0;
 
-#if PLATFORM(IOS_FAMILY)
     virtual void unobscuredContentSizeChanged() = 0;
-#endif
 
 #if PLATFORM(COCOA) && defined __OBJC__
 public:
     WEBCORE_EXPORT NSView* documentView() const;
 
@@ -463,17 +462,24 @@
     void platformRemoveChild(Widget*);
     void platformSetScrollbarModes();
     void platformScrollbarModes(ScrollbarMode& horizontal, ScrollbarMode& vertical) const;
     void platformSetCanBlitOnScroll(bool);
     bool platformCanBlitOnScroll() const;
+
     IntRect platformVisibleContentRect(bool includeScrollbars) const;
     IntSize platformVisibleContentSize(bool includeScrollbars) const;
     IntRect platformVisibleContentRectIncludingObscuredArea(bool includeScrollbars) const;
     IntSize platformVisibleContentSizeIncludingObscuredArea(bool includeScrollbars) const;
+
+    IntRect platformUnobscuredContentRect(VisibleContentRectIncludesScrollbars) const;
+    FloatRect platformExposedContentRect() const;
+
     void platformSetContentsSize();
+
     IntRect platformContentsToScreen(const IntRect&) const;
     IntPoint platformScreenToContents(const IntPoint&) const;
+
     void platformSetScrollPosition(const IntPoint&);
     bool platformScroll(ScrollDirection, ScrollGranularity);
     void platformSetScrollbarsSuppressed(bool repaintOnUnsuppress);
     void platformRepaintContentRectangle(const IntRect&);
     bool platformIsOffscreen() const;
@@ -488,17 +494,21 @@
     RefPtr<Scrollbar> m_horizontalScrollbar;
     RefPtr<Scrollbar> m_verticalScrollbar;
     ScrollbarMode m_horizontalScrollbarMode { ScrollbarAuto };
     ScrollbarMode m_verticalScrollbarMode { ScrollbarAuto };
 
-#if PLATFORM(IOS_FAMILY)
+
+    // FIXME: More things will move into here.
+    struct DelegatedScrollingGeometry {
+        FloatSize unobscuredContentSize;
+        FloatRect exposedContentRect;
+    };
+    Optional<DelegatedScrollingGeometry> m_delegatedScrollingGeometry;
+
+#if USE(COORDINATED_GRAPHICS)
     // FIXME: exposedContentRect is a very similar concept to fixedVisibleContentRect except it does not differentiate
     // between exposed and unobscured areas. The two attributes should eventually be merged.
-    FloatRect m_exposedContentRect;
-    FloatSize m_unobscuredContentSize;
-    // This is only used for history scroll position restoration.
-#else
     IntRect m_fixedVisibleContentRect;
 #endif
     ScrollPosition m_scrollPosition;
     IntPoint m_cachedScrollPosition;
     IntSize m_fixedLayoutSize;
@@ -527,10 +537,11 @@
     bool m_drawPanScrollIcon { false };
     bool m_useFixedLayout { false };
 
     bool m_paintsEntireContents { false };
     bool m_delegatesScrolling { false };
+
 }; // class ScrollView
 
 } // namespace WebCore
 
 SPECIALIZE_TYPE_TRAITS_WIDGET(ScrollView, isScrollView())

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/wayland/PlatformDisplayWayland.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../transforms/TransformationMatrix.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../image-decoders/ScalableImageDecoder.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/wayland/PlatformDisplayWayland.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 76 
 77 PlatformDisplayWayland::~PlatformDisplayWayland()
 78 {
 79     if (m_nativeDisplayOwned == NativeDisplayOwned::Yes) {
 80         m_compositor = nullptr;
 81         m_registry = nullptr;
 82         wl_display_disconnect(m_display);
 83     }
 84 }
 85 
 86 void PlatformDisplayWayland::initialize()
 87 {
 88     if (!m_display)
 89         return;
 90 
 91     m_registry.reset(wl_display_get_registry(m_display));
 92     wl_registry_add_listener(m_registry.get(), &amp;s_registryListener, this);
 93     wl_display_roundtrip(m_display);
 94 
 95 #if USE(EGL)
<span class="line-modified"> 96 #if defined(EGL_KHR_platform_wayland)</span>
 97     const char* extensions = eglQueryString(nullptr, EGL_EXTENSIONS);

 98     if (GLContext::isExtensionSupported(extensions, &quot;EGL_KHR_platform_base&quot;)) {
 99         if (auto* getPlatformDisplay = reinterpret_cast&lt;PFNEGLGETPLATFORMDISPLAYEXTPROC&gt;(eglGetProcAddress(&quot;eglGetPlatformDisplay&quot;)))
100             m_eglDisplay = getPlatformDisplay(EGL_PLATFORM_WAYLAND_KHR, m_display, nullptr);
<span class="line-modified">101     } else if (GLContext::isExtensionSupported(extensions, &quot;EGL_EXT_platform_base&quot;)) {</span>



102         if (auto* getPlatformDisplay = reinterpret_cast&lt;PFNEGLGETPLATFORMDISPLAYEXTPROC&gt;(eglGetProcAddress(&quot;eglGetPlatformDisplayEXT&quot;)))
<span class="line-modified">103             m_eglDisplay = getPlatformDisplay(EGL_PLATFORM_WAYLAND_KHR, m_display, nullptr);</span>
<span class="line-modified">104     } else</span>

105 #endif

106         m_eglDisplay = eglGetDisplay(m_display);
107 
108     PlatformDisplay::initializeEGLDisplay();
109 #endif
110 }
111 
112 void PlatformDisplayWayland::registryGlobal(const char* interface, uint32_t name)
113 {
114     if (!std::strcmp(interface, &quot;wl_compositor&quot;))
115         m_compositor.reset(static_cast&lt;struct wl_compositor*&gt;(wl_registry_bind(m_registry.get(), name, &amp;wl_compositor_interface, 1)));
116 }
117 
118 WlUniquePtr&lt;struct wl_surface&gt; PlatformDisplayWayland::createSurface() const
119 {
120     if (!m_compositor)
121         return nullptr;
122 
123     return WlUniquePtr&lt;struct wl_surface&gt;(wl_compositor_create_surface(m_compositor.get()));
124 }
125 
</pre>
</td>
<td>
<hr />
<pre>
 76 
 77 PlatformDisplayWayland::~PlatformDisplayWayland()
 78 {
 79     if (m_nativeDisplayOwned == NativeDisplayOwned::Yes) {
 80         m_compositor = nullptr;
 81         m_registry = nullptr;
 82         wl_display_disconnect(m_display);
 83     }
 84 }
 85 
 86 void PlatformDisplayWayland::initialize()
 87 {
 88     if (!m_display)
 89         return;
 90 
 91     m_registry.reset(wl_display_get_registry(m_display));
 92     wl_registry_add_listener(m_registry.get(), &amp;s_registryListener, this);
 93     wl_display_roundtrip(m_display);
 94 
 95 #if USE(EGL)
<span class="line-modified"> 96 #if defined(EGL_KHR_platform_wayland) || defined(EGL_EXT_platform_wayland)</span>
 97     const char* extensions = eglQueryString(nullptr, EGL_EXTENSIONS);
<span class="line-added"> 98 #if defined(EGL_KHR_platform_wayland)</span>
 99     if (GLContext::isExtensionSupported(extensions, &quot;EGL_KHR_platform_base&quot;)) {
100         if (auto* getPlatformDisplay = reinterpret_cast&lt;PFNEGLGETPLATFORMDISPLAYEXTPROC&gt;(eglGetProcAddress(&quot;eglGetPlatformDisplay&quot;)))
101             m_eglDisplay = getPlatformDisplay(EGL_PLATFORM_WAYLAND_KHR, m_display, nullptr);
<span class="line-modified">102     }</span>
<span class="line-added">103 #endif</span>
<span class="line-added">104 #if defined(EGL_EXT_platform_wayland)</span>
<span class="line-added">105     if (m_eglDisplay == EGL_NO_DISPLAY &amp;&amp; GLContext::isExtensionSupported(extensions, &quot;EGL_EXT_platform_base&quot;)) {</span>
106         if (auto* getPlatformDisplay = reinterpret_cast&lt;PFNEGLGETPLATFORMDISPLAYEXTPROC&gt;(eglGetProcAddress(&quot;eglGetPlatformDisplayEXT&quot;)))
<span class="line-modified">107             m_eglDisplay = getPlatformDisplay(EGL_PLATFORM_WAYLAND_EXT, m_display, nullptr);</span>
<span class="line-modified">108     }</span>
<span class="line-added">109 #endif</span>
110 #endif
<span class="line-added">111     if (m_eglDisplay == EGL_NO_DISPLAY)</span>
112         m_eglDisplay = eglGetDisplay(m_display);
113 
114     PlatformDisplay::initializeEGLDisplay();
115 #endif
116 }
117 
118 void PlatformDisplayWayland::registryGlobal(const char* interface, uint32_t name)
119 {
120     if (!std::strcmp(interface, &quot;wl_compositor&quot;))
121         m_compositor.reset(static_cast&lt;struct wl_compositor*&gt;(wl_registry_bind(m_registry.get(), name, &amp;wl_compositor_interface, 1)));
122 }
123 
124 WlUniquePtr&lt;struct wl_surface&gt; PlatformDisplayWayland::createSurface() const
125 {
126     if (!m_compositor)
127         return nullptr;
128 
129     return WlUniquePtr&lt;struct wl_surface&gt;(wl_compositor_create_surface(m_compositor.get()));
130 }
131 
</pre>
</td>
</tr>
</table>
<center><a href="../transforms/TransformationMatrix.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../image-decoders/ScalableImageDecoder.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
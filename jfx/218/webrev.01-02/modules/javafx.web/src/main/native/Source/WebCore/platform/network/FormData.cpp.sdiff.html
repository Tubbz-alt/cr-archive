<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/network/FormData.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DataURLDecoder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FormData.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/network/FormData.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB. If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;FormData.h&quot;
 24 
 25 #include &quot;BlobRegistryImpl.h&quot;
 26 #include &quot;BlobURL.h&quot;
 27 #include &quot;Chrome.h&quot;
<span class="line-removed"> 28 #include &quot;ChromeClient.h&quot;</span>
 29 #include &quot;DOMFormData.h&quot;
 30 #include &quot;File.h&quot;
 31 #include &quot;FormDataBuilder.h&quot;
 32 #include &quot;Page.h&quot;
 33 #include &quot;SharedBuffer.h&quot;
 34 #include &quot;TextEncoding.h&quot;
 35 #include &quot;ThreadableBlobRegistry.h&quot;
 36 #include &lt;wtf/FileSystem.h&gt;
 37 #include &lt;wtf/text/LineEnding.h&gt;
 38 
 39 namespace WebCore {
 40 
 41 inline FormData::FormData()
 42 {
 43 }
 44 
 45 inline FormData::FormData(const FormData&amp; data)
 46     : RefCounted&lt;FormData&gt;()
 47     , m_elements(data.m_elements)
 48     , m_identifier(data.m_identifier)
</pre>
<hr />
<pre>
107 {
108     return adoptRef(*new FormData(*this));
109 }
110 
111 Ref&lt;FormData&gt; FormData::isolatedCopy() const
112 {
113     // FIXME: isolatedCopy() does not copy m_identifier, m_boundary, or m_containsPasswordData.
114     // Is all of that correct and intentional?
115 
116     auto formData = create();
117 
118     formData-&gt;m_alwaysStream = m_alwaysStream;
119 
120     formData-&gt;m_elements.reserveInitialCapacity(m_elements.size());
121     for (auto&amp; element : m_elements)
122         formData-&gt;m_elements.uncheckedAppend(element.isolatedCopy());
123 
124     return formData;
125 }
126 
<span class="line-modified">127 static inline uint64_t computeLengthInBytes(const FormDataElement&amp; element, const Function&lt;uint64_t(const URL&amp;)&gt;&amp; blobSize)</span>
128 {
<span class="line-modified">129     return switchOn(element.data,</span>
130         [] (const Vector&lt;char&gt;&amp; bytes) {
131             return static_cast&lt;uint64_t&gt;(bytes.size());
132         }, [] (const FormDataElement::EncodedFileData&amp; fileData) {
133             if (fileData.fileLength != BlobDataItem::toEndOfFile)
134                 return static_cast&lt;uint64_t&gt;(fileData.fileLength);
135             long long fileSize;
136             if (FileSystem::getFileSize(fileData.filename, fileSize))
137                 return static_cast&lt;uint64_t&gt;(fileSize);
138             return static_cast&lt;uint64_t&gt;(0);
139         }, [&amp;blobSize] (const FormDataElement::EncodedBlobData&amp; blobData) {
140             return blobSize(blobData.url);
141         }
142     );
143 }
144 
<span class="line-modified">145 uint64_t FormDataElement::lengthInBytes(BlobRegistryImpl* blobRegistry) const</span>
<span class="line-removed">146 {</span>
<span class="line-removed">147     return computeLengthInBytes(*this, [&amp;](auto&amp; url) {</span>
<span class="line-removed">148         return blobRegistry ? blobRegistry-&gt;blobSize(url) : 0;</span>
<span class="line-removed">149     });</span>
<span class="line-removed">150 }</span>
<span class="line-removed">151 </span>
<span class="line-removed">152 uint64_t FormDataElement::lengthInBytes(PAL::SessionID sessionID) const</span>
153 {
<span class="line-modified">154     return computeLengthInBytes(*this, [&amp;](auto&amp; url) {</span>
<span class="line-modified">155         return blobRegistry().blobSize(sessionID, url);</span>
156     });
157 }
158 
159 FormDataElement FormDataElement::isolatedCopy() const
160 {
161     return switchOn(data,
162         [] (const Vector&lt;char&gt;&amp; bytes) {
163             Vector&lt;char&gt; copy;
164             copy.append(bytes.data(), bytes.size());
165             return FormDataElement(WTFMove(copy));
166         }, [] (const FormDataElement::EncodedFileData&amp; fileData) {
167             return FormDataElement(fileData.isolatedCopy());
168         }, [] (const FormDataElement::EncodedBlobData&amp; blobData) {
169             return FormDataElement(blobData.url.isolatedCopy());
170         }
171     );
172 }
173 
174 void FormData::appendData(const void* data, size_t size)
175 {
</pre>
<hr />
<pre>
307         return;
308     }
309 
310     auto* blobData = blobRegistry-&gt;getBlobDataFromURL(url);
311     if (!blobData) {
312         LOG_ERROR(&quot;Could not get blob data from a registry&quot;);
313         return;
314     }
315 
316     for (const auto&amp; blobItem : blobData-&gt;items()) {
317         if (blobItem.type() == BlobDataItem::Type::Data) {
318             ASSERT(blobItem.data().data());
319             formData.appendData(blobItem.data().data()-&gt;data() + static_cast&lt;int&gt;(blobItem.offset()), static_cast&lt;int&gt;(blobItem.length()));
320         } else if (blobItem.type() == BlobDataItem::Type::File)
321             formData.appendFileRange(blobItem.file()-&gt;path(), blobItem.offset(), blobItem.length(), blobItem.file()-&gt;expectedModificationTime());
322         else
323             ASSERT_NOT_REACHED();
324     }
325 }
326 
<span class="line-modified">327 Ref&lt;FormData&gt; FormData::resolveBlobReferences(BlobRegistryImpl* blobRegistry)</span>
328 {
329     // First check if any blobs needs to be resolved, or we can take the fast path.
330     bool hasBlob = false;
331     for (auto&amp; element : m_elements) {
332         if (WTF::holds_alternative&lt;FormDataElement::EncodedBlobData&gt;(element.data)) {
333             hasBlob = true;
334             break;
335         }
336     }
337 
338     if (!hasBlob)
339         return *this;
340 
341     // Create a copy to append the result into.
342     auto newFormData = FormData::create();
343     newFormData-&gt;setAlwaysStream(alwaysStream());
344     newFormData-&gt;setIdentifier(identifier());
345 
346     for (auto&amp; element : m_elements) {
347         switchOn(element.data,
348             [&amp;] (const Vector&lt;char&gt;&amp; bytes) {
349                 newFormData-&gt;appendData(bytes.data(), bytes.size());
350             }, [&amp;] (const FormDataElement::EncodedFileData&amp; fileData) {
351                 newFormData-&gt;appendFileRange(fileData.filename, fileData.fileStart, fileData.fileLength, fileData.expectedFileModificationTime);
352             }, [&amp;] (const FormDataElement::EncodedBlobData&amp; blobData) {
<span class="line-modified">353                 appendBlobResolved(blobRegistry, newFormData.get(), blobData.url);</span>
354             }
355         );
356     }
357     return newFormData;
358 }
359 
360 FormDataForUpload FormData::prepareForUpload()
361 {
362     Vector&lt;String&gt; generatedFiles;
363     for (auto&amp; element : m_elements) {
364         auto* fileData = WTF::get_if&lt;FormDataElement::EncodedFileData&gt;(element.data);
365         if (!fileData)
366             continue;
367         if (!FileSystem::fileIsDirectory(fileData-&gt;filename, FileSystem::ShouldFollowSymbolicLinks::Yes))
368             continue;
369         if (fileData-&gt;fileStart || fileData-&gt;fileLength != BlobDataItem::toEndOfFile)
370             continue;
371         if (!fileData-&gt;fileModificationTimeMatchesExpectation())
372             continue;
373 
</pre>
<hr />
<pre>
377         fileData-&gt;filename = generatedFilename;
378         generatedFiles.append(WTFMove(generatedFilename));
379     }
380 
381     return { *this, WTFMove(generatedFiles) };
382 }
383 
384 FormDataForUpload::FormDataForUpload(FormData&amp; data, Vector&lt;String&gt;&amp;&amp; temporaryZipFiles)
385     : m_data(data)
386     , m_temporaryZipFiles(WTFMove(temporaryZipFiles))
387 {
388 }
389 
390 FormDataForUpload::~FormDataForUpload()
391 {
392     ASSERT(isMainThread());
393     for (auto&amp; file : m_temporaryZipFiles)
394         FileSystem::deleteFile(file);
395 }
396 
<span class="line-modified">397 uint64_t FormData::lengthInBytes(PAL::SessionID sessionID) const</span>
398 {
399     if (!m_lengthInBytes) {
400         uint64_t length = 0;
401         for (auto&amp; element : m_elements)
<span class="line-modified">402             length += element.lengthInBytes(sessionID);</span>
403         m_lengthInBytes = length;
404     }
405     return *m_lengthInBytes;
406 }
407 
408 RefPtr&lt;SharedBuffer&gt; FormData::asSharedBuffer() const
409 {
410     for (auto&amp; element : m_elements) {
411         if (!WTF::holds_alternative&lt;Vector&lt;char&gt;&gt;(element.data))
412             return nullptr;
413     }
414     return SharedBuffer::create(flatten());
415 }
416 
417 URL FormData::asBlobURL() const
418 {
419     if (m_elements.size() != 1)
420         return { };
421 
422     if (auto* blobData = WTF::get_if&lt;FormDataElement::EncodedBlobData&gt;(m_elements.first().data))
</pre>
</td>
<td>
<hr />
<pre>
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB. If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #include &quot;config.h&quot;
 23 #include &quot;FormData.h&quot;
 24 
 25 #include &quot;BlobRegistryImpl.h&quot;
 26 #include &quot;BlobURL.h&quot;
 27 #include &quot;Chrome.h&quot;

 28 #include &quot;DOMFormData.h&quot;
 29 #include &quot;File.h&quot;
 30 #include &quot;FormDataBuilder.h&quot;
 31 #include &quot;Page.h&quot;
 32 #include &quot;SharedBuffer.h&quot;
 33 #include &quot;TextEncoding.h&quot;
 34 #include &quot;ThreadableBlobRegistry.h&quot;
 35 #include &lt;wtf/FileSystem.h&gt;
 36 #include &lt;wtf/text/LineEnding.h&gt;
 37 
 38 namespace WebCore {
 39 
 40 inline FormData::FormData()
 41 {
 42 }
 43 
 44 inline FormData::FormData(const FormData&amp; data)
 45     : RefCounted&lt;FormData&gt;()
 46     , m_elements(data.m_elements)
 47     , m_identifier(data.m_identifier)
</pre>
<hr />
<pre>
106 {
107     return adoptRef(*new FormData(*this));
108 }
109 
110 Ref&lt;FormData&gt; FormData::isolatedCopy() const
111 {
112     // FIXME: isolatedCopy() does not copy m_identifier, m_boundary, or m_containsPasswordData.
113     // Is all of that correct and intentional?
114 
115     auto formData = create();
116 
117     formData-&gt;m_alwaysStream = m_alwaysStream;
118 
119     formData-&gt;m_elements.reserveInitialCapacity(m_elements.size());
120     for (auto&amp; element : m_elements)
121         formData-&gt;m_elements.uncheckedAppend(element.isolatedCopy());
122 
123     return formData;
124 }
125 
<span class="line-modified">126 uint64_t FormDataElement::lengthInBytes(const Function&lt;uint64_t(const URL&amp;)&gt;&amp; blobSize) const</span>
127 {
<span class="line-modified">128     return switchOn(data,</span>
129         [] (const Vector&lt;char&gt;&amp; bytes) {
130             return static_cast&lt;uint64_t&gt;(bytes.size());
131         }, [] (const FormDataElement::EncodedFileData&amp; fileData) {
132             if (fileData.fileLength != BlobDataItem::toEndOfFile)
133                 return static_cast&lt;uint64_t&gt;(fileData.fileLength);
134             long long fileSize;
135             if (FileSystem::getFileSize(fileData.filename, fileSize))
136                 return static_cast&lt;uint64_t&gt;(fileSize);
137             return static_cast&lt;uint64_t&gt;(0);
138         }, [&amp;blobSize] (const FormDataElement::EncodedBlobData&amp; blobData) {
139             return blobSize(blobData.url);
140         }
141     );
142 }
143 
<span class="line-modified">144 uint64_t FormDataElement::lengthInBytes() const</span>







145 {
<span class="line-modified">146     return lengthInBytes([](auto&amp; url) {</span>
<span class="line-modified">147         return ThreadableBlobRegistry::blobSize(url);</span>
148     });
149 }
150 
151 FormDataElement FormDataElement::isolatedCopy() const
152 {
153     return switchOn(data,
154         [] (const Vector&lt;char&gt;&amp; bytes) {
155             Vector&lt;char&gt; copy;
156             copy.append(bytes.data(), bytes.size());
157             return FormDataElement(WTFMove(copy));
158         }, [] (const FormDataElement::EncodedFileData&amp; fileData) {
159             return FormDataElement(fileData.isolatedCopy());
160         }, [] (const FormDataElement::EncodedBlobData&amp; blobData) {
161             return FormDataElement(blobData.url.isolatedCopy());
162         }
163     );
164 }
165 
166 void FormData::appendData(const void* data, size_t size)
167 {
</pre>
<hr />
<pre>
299         return;
300     }
301 
302     auto* blobData = blobRegistry-&gt;getBlobDataFromURL(url);
303     if (!blobData) {
304         LOG_ERROR(&quot;Could not get blob data from a registry&quot;);
305         return;
306     }
307 
308     for (const auto&amp; blobItem : blobData-&gt;items()) {
309         if (blobItem.type() == BlobDataItem::Type::Data) {
310             ASSERT(blobItem.data().data());
311             formData.appendData(blobItem.data().data()-&gt;data() + static_cast&lt;int&gt;(blobItem.offset()), static_cast&lt;int&gt;(blobItem.length()));
312         } else if (blobItem.type() == BlobDataItem::Type::File)
313             formData.appendFileRange(blobItem.file()-&gt;path(), blobItem.offset(), blobItem.length(), blobItem.file()-&gt;expectedModificationTime());
314         else
315             ASSERT_NOT_REACHED();
316     }
317 }
318 
<span class="line-modified">319 Ref&lt;FormData&gt; FormData::resolveBlobReferences(BlobRegistryImpl* blobRegistryImpl)</span>
320 {
321     // First check if any blobs needs to be resolved, or we can take the fast path.
322     bool hasBlob = false;
323     for (auto&amp; element : m_elements) {
324         if (WTF::holds_alternative&lt;FormDataElement::EncodedBlobData&gt;(element.data)) {
325             hasBlob = true;
326             break;
327         }
328     }
329 
330     if (!hasBlob)
331         return *this;
332 
333     // Create a copy to append the result into.
334     auto newFormData = FormData::create();
335     newFormData-&gt;setAlwaysStream(alwaysStream());
336     newFormData-&gt;setIdentifier(identifier());
337 
338     for (auto&amp; element : m_elements) {
339         switchOn(element.data,
340             [&amp;] (const Vector&lt;char&gt;&amp; bytes) {
341                 newFormData-&gt;appendData(bytes.data(), bytes.size());
342             }, [&amp;] (const FormDataElement::EncodedFileData&amp; fileData) {
343                 newFormData-&gt;appendFileRange(fileData.filename, fileData.fileStart, fileData.fileLength, fileData.expectedFileModificationTime);
344             }, [&amp;] (const FormDataElement::EncodedBlobData&amp; blobData) {
<span class="line-modified">345                 appendBlobResolved(blobRegistryImpl ? blobRegistryImpl : blobRegistry().blobRegistryImpl(), newFormData.get(), blobData.url);</span>
346             }
347         );
348     }
349     return newFormData;
350 }
351 
352 FormDataForUpload FormData::prepareForUpload()
353 {
354     Vector&lt;String&gt; generatedFiles;
355     for (auto&amp; element : m_elements) {
356         auto* fileData = WTF::get_if&lt;FormDataElement::EncodedFileData&gt;(element.data);
357         if (!fileData)
358             continue;
359         if (!FileSystem::fileIsDirectory(fileData-&gt;filename, FileSystem::ShouldFollowSymbolicLinks::Yes))
360             continue;
361         if (fileData-&gt;fileStart || fileData-&gt;fileLength != BlobDataItem::toEndOfFile)
362             continue;
363         if (!fileData-&gt;fileModificationTimeMatchesExpectation())
364             continue;
365 
</pre>
<hr />
<pre>
369         fileData-&gt;filename = generatedFilename;
370         generatedFiles.append(WTFMove(generatedFilename));
371     }
372 
373     return { *this, WTFMove(generatedFiles) };
374 }
375 
376 FormDataForUpload::FormDataForUpload(FormData&amp; data, Vector&lt;String&gt;&amp;&amp; temporaryZipFiles)
377     : m_data(data)
378     , m_temporaryZipFiles(WTFMove(temporaryZipFiles))
379 {
380 }
381 
382 FormDataForUpload::~FormDataForUpload()
383 {
384     ASSERT(isMainThread());
385     for (auto&amp; file : m_temporaryZipFiles)
386         FileSystem::deleteFile(file);
387 }
388 
<span class="line-modified">389 uint64_t FormData::lengthInBytes() const</span>
390 {
391     if (!m_lengthInBytes) {
392         uint64_t length = 0;
393         for (auto&amp; element : m_elements)
<span class="line-modified">394             length += element.lengthInBytes();</span>
395         m_lengthInBytes = length;
396     }
397     return *m_lengthInBytes;
398 }
399 
400 RefPtr&lt;SharedBuffer&gt; FormData::asSharedBuffer() const
401 {
402     for (auto&amp; element : m_elements) {
403         if (!WTF::holds_alternative&lt;Vector&lt;char&gt;&gt;(element.data))
404             return nullptr;
405     }
406     return SharedBuffer::create(flatten());
407 }
408 
409 URL FormData::asBlobURL() const
410 {
411     if (m_elements.size() != 1)
412         return { };
413 
414     if (auto* blobData = WTF::get_if&lt;FormDataElement::EncodedBlobData&gt;(m_elements.first().data))
</pre>
</td>
</tr>
</table>
<center><a href="DataURLDecoder.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FormData.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
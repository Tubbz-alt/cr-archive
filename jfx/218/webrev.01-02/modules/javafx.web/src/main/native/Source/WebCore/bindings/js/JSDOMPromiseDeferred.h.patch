diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromiseDeferred.h b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromiseDeferred.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromiseDeferred.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMPromiseDeferred.h
@@ -23,97 +23,104 @@
  * THE POSSIBILITY OF SUCH DAMAGE.
  */
 
 #pragma once
 
+#include "EventLoop.h"
 #include "ExceptionOr.h"
 #include "JSDOMConvert.h"
 #include "JSDOMGuardedObject.h"
+#include "ScriptExecutionContext.h"
 #include <JavaScriptCore/CatchScope.h>
-#include <JavaScriptCore/JSPromiseDeferred.h>
+#include <JavaScriptCore/JSPromise.h>
 
 namespace WebCore {
 
 class JSDOMWindow;
 
-class DeferredPromise : public DOMGuarded<JSC::JSPromiseDeferred> {
+class DeferredPromise : public DOMGuarded<JSC::JSPromise> {
 public:
     enum class Mode {
         ClearPromiseOnResolve,
         RetainPromiseOnResolve
     };
 
-    static RefPtr<DeferredPromise> create(JSC::ExecState& state, JSDOMGlobalObject& globalObject, Mode mode = Mode::ClearPromiseOnResolve)
+    static RefPtr<DeferredPromise> create(JSDOMGlobalObject& globalObject, Mode mode = Mode::ClearPromiseOnResolve)
     {
-        auto* promiseDeferred = JSC::JSPromiseDeferred::tryCreate(&state, &globalObject);
-        if (!promiseDeferred)
-            return nullptr;
-        return adoptRef(new DeferredPromise(globalObject, *promiseDeferred, mode));
+        JSC::VM& vm = JSC::getVM(&globalObject);
+        auto* promise = JSC::JSPromise::create(vm, globalObject.promiseStructure());
+        ASSERT(promise);
+        return adoptRef(new DeferredPromise(globalObject, *promise, mode));
     }
 
-    static Ref<DeferredPromise> create(JSDOMGlobalObject& globalObject, JSC::JSPromiseDeferred& deferred, Mode mode = Mode::ClearPromiseOnResolve)
+    static Ref<DeferredPromise> create(JSDOMGlobalObject& globalObject, JSC::JSPromise& deferred, Mode mode = Mode::ClearPromiseOnResolve)
     {
         return adoptRef(*new DeferredPromise(globalObject, deferred, mode));
     }
 
     template<class IDLType>
     void resolve(typename IDLType::ParameterType value)
     {
-        if (isSuspended())
+        if (shouldIgnoreRequestToFulfill())
             return;
+
         ASSERT(deferred());
         ASSERT(globalObject());
-        JSC::ExecState* exec = globalObject()->globalExec();
-        JSC::JSLockHolder locker(exec);
-        resolve(*exec, toJS<IDLType>(*exec, *globalObject(), std::forward<typename IDLType::ParameterType>(value)));
+        JSC::JSGlobalObject* lexicalGlobalObject = globalObject();
+        JSC::JSLockHolder locker(lexicalGlobalObject);
+        resolve(*lexicalGlobalObject, toJS<IDLType>(*lexicalGlobalObject, *globalObject(), std::forward<typename IDLType::ParameterType>(value)));
     }
 
     void resolve()
     {
-        if (isSuspended())
+        if (shouldIgnoreRequestToFulfill())
             return;
+
         ASSERT(deferred());
         ASSERT(globalObject());
-        JSC::ExecState* exec = globalObject()->globalExec();
-        JSC::JSLockHolder locker(exec);
-        resolve(*exec, JSC::jsUndefined());
+        JSC::JSGlobalObject* lexicalGlobalObject = globalObject();
+        JSC::JSLockHolder locker(lexicalGlobalObject);
+        resolve(*lexicalGlobalObject, JSC::jsUndefined());
     }
 
     template<class IDLType>
     void resolveWithNewlyCreated(typename IDLType::ParameterType value)
     {
-        if (isSuspended())
+        if (shouldIgnoreRequestToFulfill())
             return;
+
         ASSERT(deferred());
         ASSERT(globalObject());
-        JSC::ExecState* exec = globalObject()->globalExec();
-        JSC::JSLockHolder locker(exec);
-        resolve(*exec, toJSNewlyCreated<IDLType>(*exec, *globalObject(), std::forward<typename IDLType::ParameterType>(value)));
+        JSC::JSGlobalObject* lexicalGlobalObject = globalObject();
+        JSC::JSLockHolder locker(lexicalGlobalObject);
+        resolve(*lexicalGlobalObject, toJSNewlyCreated<IDLType>(*lexicalGlobalObject, *globalObject(), std::forward<typename IDLType::ParameterType>(value)));
     }
 
     template<class IDLType>
     void resolveCallbackValueWithNewlyCreated(const Function<typename IDLType::InnerParameterType(ScriptExecutionContext&)>& createValue)
     {
-        if (isSuspended())
+        if (shouldIgnoreRequestToFulfill())
             return;
+
         ASSERT(deferred());
         ASSERT(globalObject());
-        auto* exec = globalObject()->globalExec();
-        JSC::JSLockHolder locker(exec);
-        resolve(*exec, toJSNewlyCreated<IDLType>(*exec, *globalObject(), createValue(*globalObject()->scriptExecutionContext())));
+        auto* lexicalGlobalObject = globalObject();
+        JSC::JSLockHolder locker(lexicalGlobalObject);
+        resolve(*lexicalGlobalObject, toJSNewlyCreated<IDLType>(*lexicalGlobalObject, *globalObject(), createValue(*globalObject()->scriptExecutionContext())));
     }
 
     template<class IDLType>
     void reject(typename IDLType::ParameterType value)
     {
-        if (isSuspended())
+        if (shouldIgnoreRequestToFulfill())
             return;
+
         ASSERT(deferred());
         ASSERT(globalObject());
-        JSC::ExecState* exec = globalObject()->globalExec();
-        JSC::JSLockHolder locker(exec);
-        reject(*exec, toJS<IDLType>(*exec, *globalObject(), std::forward<typename IDLType::ParameterType>(value)));
+        JSC::JSGlobalObject* lexicalGlobalObject = globalObject();
+        JSC::JSLockHolder locker(lexicalGlobalObject);
+        reject(*lexicalGlobalObject, toJS<IDLType>(*lexicalGlobalObject, *globalObject(), std::forward<typename IDLType::ParameterType>(value)));
     }
 
     void reject();
     void reject(std::nullptr_t);
     void reject(Exception);
@@ -121,102 +128,113 @@
     void reject(const JSC::PrivateName&);
 
     template<typename Callback>
     void resolveWithCallback(Callback callback)
     {
-        if (isSuspended())
+        if (shouldIgnoreRequestToFulfill())
             return;
+
         ASSERT(deferred());
         ASSERT(globalObject());
-        JSC::ExecState* exec = globalObject()->globalExec();
-        JSC::JSLockHolder locker(exec);
-        resolve(*exec, callback(*exec, *globalObject()));
+        JSC::JSGlobalObject* lexicalGlobalObject = globalObject();
+        JSC::JSLockHolder locker(lexicalGlobalObject);
+        resolve(*lexicalGlobalObject, callback(*globalObject()));
     }
 
     template<typename Callback>
     void rejectWithCallback(Callback callback)
     {
-        if (isSuspended())
+        if (shouldIgnoreRequestToFulfill())
             return;
+
         ASSERT(deferred());
         ASSERT(globalObject());
-        JSC::ExecState* exec = globalObject()->globalExec();
-        JSC::JSLockHolder locker(exec);
-        reject(*exec, callback(*exec, *globalObject()));
+        JSC::JSGlobalObject* lexicalGlobalObject = globalObject();
+        JSC::JSLockHolder locker(lexicalGlobalObject);
+        reject(*lexicalGlobalObject, callback(*globalObject()));
     }
 
     JSC::JSValue promise() const;
 
-    void whenSettled(std::function<void()>&&);
+    void whenSettled(Function<void()>&&);
 
 private:
-    DeferredPromise(JSDOMGlobalObject& globalObject, JSC::JSPromiseDeferred& deferred, Mode mode)
-        : DOMGuarded<JSC::JSPromiseDeferred>(globalObject, deferred)
+    DeferredPromise(JSDOMGlobalObject& globalObject, JSC::JSPromise& deferred, Mode mode)
+        : DOMGuarded<JSC::JSPromise>(globalObject, deferred)
         , m_mode(mode)
     {
     }
 
-    JSC::JSPromiseDeferred* deferred() const { return guarded(); }
+    bool shouldIgnoreRequestToFulfill() const { return isEmpty() || activeDOMObjectAreStopped(); }
 
-    WEBCORE_EXPORT void callFunction(JSC::ExecState&, JSC::JSValue function, JSC::JSValue resolution);
+    JSC::JSPromise* deferred() const { return guarded(); }
 
-    void resolve(JSC::ExecState& state, JSC::JSValue resolution) { callFunction(state, deferred()->resolve(), resolution); }
-    void reject(JSC::ExecState& state, JSC::JSValue resolution) { callFunction(state, deferred()->reject(), resolution); }
+    enum class ResolveMode { Resolve, Reject };
+    WEBCORE_EXPORT void callFunction(JSC::JSGlobalObject&, ResolveMode, JSC::JSValue resolution);
+
+    void resolve(JSC::JSGlobalObject& lexicalGlobalObject, JSC::JSValue resolution) { callFunction(lexicalGlobalObject, ResolveMode::Resolve, resolution); }
+    void reject(JSC::JSGlobalObject& lexicalGlobalObject, JSC::JSValue resolution) { callFunction(lexicalGlobalObject, ResolveMode::Reject, resolution); }
 
     Mode m_mode;
 };
 
 class DOMPromiseDeferredBase {
+    WTF_MAKE_FAST_ALLOCATED;
 public:
     DOMPromiseDeferredBase(Ref<DeferredPromise>&& genericPromise)
-        : m_promiseDeferred(WTFMove(genericPromise))
+        : m_promise(WTFMove(genericPromise))
     {
     }
 
     DOMPromiseDeferredBase(DOMPromiseDeferredBase&& promise)
-        : m_promiseDeferred(WTFMove(promise.m_promiseDeferred))
+        : m_promise(WTFMove(promise.m_promise))
     {
     }
 
     DOMPromiseDeferredBase(const DOMPromiseDeferredBase& other)
-        : m_promiseDeferred(other.m_promiseDeferred.copyRef())
+        : m_promise(other.m_promise.copyRef())
     {
     }
 
     DOMPromiseDeferredBase& operator=(const DOMPromiseDeferredBase& other)
     {
-        m_promiseDeferred = other.m_promiseDeferred.copyRef();
+        m_promise = other.m_promise.copyRef();
         return *this;
     }
 
     DOMPromiseDeferredBase& operator=(DOMPromiseDeferredBase&& other)
     {
-        m_promiseDeferred = WTFMove(other.m_promiseDeferred);
+        m_promise = WTFMove(other.m_promise);
         return *this;
     }
 
     void reject()
     {
-        m_promiseDeferred->reject();
+        m_promise->reject();
     }
 
     template<typename... ErrorType>
     void reject(ErrorType&&... error)
     {
-        m_promiseDeferred->reject(std::forward<ErrorType>(error)...);
+        m_promise->reject(std::forward<ErrorType>(error)...);
     }
 
     template<typename IDLType>
     void rejectType(typename IDLType::ParameterType value)
     {
-        m_promiseDeferred->reject<IDLType>(std::forward<typename IDLType::ParameterType>(value));
+        m_promise->reject<IDLType>(std::forward<typename IDLType::ParameterType>(value));
     }
 
-    JSC::JSValue promise() const { return m_promiseDeferred->promise(); };
+    JSC::JSValue promise() const { return m_promise->promise(); };
+
+    void whenSettled(Function<void()>&& function)
+    {
+        m_promise->whenSettled(WTFMove(function));
+    }
 
 protected:
-    Ref<DeferredPromise> m_promiseDeferred;
+    Ref<DeferredPromise> m_promise;
 };
 
 template<typename IDLType>
 class DOMPromiseDeferred : public DOMPromiseDeferredBase {
 public:
@@ -225,11 +243,11 @@
     using DOMPromiseDeferredBase::promise;
     using DOMPromiseDeferredBase::reject;
 
     void resolve(typename IDLType::ParameterType value)
     {
-        m_promiseDeferred->resolve<IDLType>(std::forward<typename IDLType::ParameterType>(value));
+        m_promise->resolve<IDLType>(std::forward<typename IDLType::ParameterType>(value));
     }
 
     void settle(ExceptionOr<typename IDLType::ParameterType>&& result)
     {
         if (result.hasException()) {
@@ -247,11 +265,11 @@
     using DOMPromiseDeferredBase::promise;
     using DOMPromiseDeferredBase::reject;
 
     void resolve()
     {
-        m_promiseDeferred->resolve();
+        m_promise->resolve();
     }
 
     void settle(ExceptionOr<void>&& result)
     {
         if (result.hasException()) {
@@ -261,73 +279,69 @@
         resolve();
     }
 };
 
 
-Ref<DeferredPromise> createDeferredPromise(JSC::ExecState&, JSDOMWindow&);
+Ref<DeferredPromise> createDeferredPromise(JSC::JSGlobalObject&, JSDOMWindow&);
 
 void fulfillPromiseWithJSON(Ref<DeferredPromise>&&, const String&);
 void fulfillPromiseWithArrayBuffer(Ref<DeferredPromise>&&, ArrayBuffer*);
 void fulfillPromiseWithArrayBuffer(Ref<DeferredPromise>&&, const void*, size_t);
-WEBCORE_EXPORT void rejectPromiseWithExceptionIfAny(JSC::ExecState&, JSDOMGlobalObject&, JSC::JSPromiseDeferred&);
+WEBCORE_EXPORT void rejectPromiseWithExceptionIfAny(JSC::JSGlobalObject&, JSDOMGlobalObject&, JSC::JSPromise&);
 
 enum class RejectedPromiseWithTypeErrorCause { NativeGetter, InvalidThis };
-JSC::EncodedJSValue createRejectedPromiseWithTypeError(JSC::ExecState&, const String&, RejectedPromiseWithTypeErrorCause);
+JSC::EncodedJSValue createRejectedPromiseWithTypeError(JSC::JSGlobalObject&, const String&, RejectedPromiseWithTypeErrorCause);
 
-using PromiseFunction = void(JSC::ExecState&, Ref<DeferredPromise>&&);
+using PromiseFunction = void(JSC::JSGlobalObject&, JSC::CallFrame&, Ref<DeferredPromise>&&);
 
-enum class PromiseExecutionScope { WindowOnly, WindowOrWorker };
-
-template<PromiseFunction promiseFunction, PromiseExecutionScope executionScope>
-inline JSC::JSValue callPromiseFunction(JSC::ExecState& state)
+template<PromiseFunction promiseFunction>
+inline JSC::JSValue callPromiseFunction(JSC::JSGlobalObject& lexicalGlobalObject, JSC::CallFrame& callFrame)
 {
-    JSC::VM& vm = state.vm();
+    JSC::VM& vm = JSC::getVM(&lexicalGlobalObject);
     auto scope = DECLARE_CATCH_SCOPE(vm);
 
-    auto& globalObject = callerGlobalObject(state);
-    JSC::JSPromiseDeferred* promiseDeferred = JSC::JSPromiseDeferred::tryCreate(&state, &globalObject);
-
-    // promiseDeferred can be null when terminating a Worker abruptly.
-    if (executionScope == PromiseExecutionScope::WindowOrWorker && !promiseDeferred)
-        return JSC::jsUndefined();
+    auto& globalObject = callerGlobalObject(lexicalGlobalObject, callFrame);
+    auto* promise = JSC::JSPromise::create(vm, globalObject.promiseStructure());
+    ASSERT(promise);
 
-    promiseFunction(state, DeferredPromise::create(globalObject, *promiseDeferred));
+    promiseFunction(lexicalGlobalObject, callFrame, DeferredPromise::create(globalObject, *promise));
 
-    rejectPromiseWithExceptionIfAny(state, globalObject, *promiseDeferred);
-    EXCEPTION_ASSERT_UNUSED(scope, !scope.exception());
-    return promiseDeferred->promise();
+    rejectPromiseWithExceptionIfAny(lexicalGlobalObject, globalObject, *promise);
+    // FIXME: We could have error since any JS call can throw stack-overflow errors.
+    // https://bugs.webkit.org/show_bug.cgi?id=203402
+    RETURN_IF_EXCEPTION(scope, JSC::jsUndefined());
+    return promise;
 }
 
-template<PromiseExecutionScope executionScope, typename PromiseFunctor>
-inline JSC::JSValue callPromiseFunction(JSC::ExecState& state, PromiseFunctor functor)
+template<typename PromiseFunctor>
+inline JSC::JSValue callPromiseFunction(JSC::JSGlobalObject& lexicalGlobalObject, JSC::CallFrame& callFrame, PromiseFunctor functor)
 {
-    JSC::VM& vm = state.vm();
+    JSC::VM& vm = JSC::getVM(&lexicalGlobalObject);
     auto scope = DECLARE_CATCH_SCOPE(vm);
 
-    auto& globalObject = callerGlobalObject(state);
-    JSC::JSPromiseDeferred* promiseDeferred = JSC::JSPromiseDeferred::tryCreate(&state, &globalObject);
-
-    // promiseDeferred can be null when terminating a Worker abruptly.
-    if (executionScope == PromiseExecutionScope::WindowOrWorker && !promiseDeferred)
-        return JSC::jsUndefined();
+    auto& globalObject = callerGlobalObject(lexicalGlobalObject, callFrame);
+    auto* promise = JSC::JSPromise::create(vm, globalObject.promiseStructure());
+    ASSERT(promise);
 
-    functor(state, DeferredPromise::create(globalObject, *promiseDeferred));
+    functor(lexicalGlobalObject, callFrame, DeferredPromise::create(globalObject, *promise));
 
-    rejectPromiseWithExceptionIfAny(state, globalObject, *promiseDeferred);
-    EXCEPTION_ASSERT_UNUSED(scope, !scope.exception());
-    return promiseDeferred->promise();
+    rejectPromiseWithExceptionIfAny(lexicalGlobalObject, globalObject, *promise);
+    // FIXME: We could have error since any JS call can throw stack-overflow errors.
+    // https://bugs.webkit.org/show_bug.cgi?id=203402
+    RETURN_IF_EXCEPTION(scope, JSC::jsUndefined());
+    return promise;
 }
 
-using BindingPromiseFunction = JSC::EncodedJSValue(JSC::ExecState*, Ref<DeferredPromise>&&);
+using BindingPromiseFunction = JSC::EncodedJSValue(JSC::JSGlobalObject*, JSC::CallFrame*, Ref<DeferredPromise>&&);
 template<BindingPromiseFunction bindingFunction>
-inline void bindingPromiseFunctionAdapter(JSC::ExecState& state, Ref<DeferredPromise>&& promise)
+inline void bindingPromiseFunctionAdapter(JSC::JSGlobalObject& lexicalGlobalObject, JSC::CallFrame& callFrame, Ref<DeferredPromise>&& promise)
 {
-    bindingFunction(&state, WTFMove(promise));
+    bindingFunction(&lexicalGlobalObject, &callFrame, WTFMove(promise));
 }
 
-template<BindingPromiseFunction bindingPromiseFunction, PromiseExecutionScope executionScope>
-inline JSC::JSValue callPromiseFunction(JSC::ExecState& state)
+template<BindingPromiseFunction bindingPromiseFunction>
+inline JSC::JSValue callPromiseFunction(JSC::JSGlobalObject& lexicalGlobalObject, JSC::CallFrame& callFrame)
 {
-    return callPromiseFunction<bindingPromiseFunctionAdapter<bindingPromiseFunction>, executionScope>(state);
+    return callPromiseFunction<bindingPromiseFunctionAdapter<bindingPromiseFunction>>(lexicalGlobalObject, callFrame);
 }
 
 } // namespace WebCore

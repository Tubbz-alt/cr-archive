<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGSpeculativeJIT.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT32_64.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGSpeculativeJIT.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  51 class SlowPathGenerator;
  52 class SpeculativeJIT;
  53 class SpeculateInt32Operand;
  54 class SpeculateStrictInt32Operand;
  55 class SpeculateDoubleOperand;
  56 class SpeculateCellOperand;
  57 class SpeculateBooleanOperand;
  58 
  59 enum GeneratedOperandType { GeneratedOperandTypeUnknown, GeneratedOperandInteger, GeneratedOperandJSValue};
  60 
  61 // === SpeculativeJIT ===
  62 //
  63 // The SpeculativeJIT is used to generate a fast, but potentially
  64 // incomplete code path for the dataflow. When code generating
  65 // we may make assumptions about operand types, dynamically check,
  66 // and bail-out to an alternate code path if these checks fail.
  67 // Importantly, the speculative code path cannot be reentered once
  68 // a speculative check has failed. This allows the SpeculativeJIT
  69 // to propagate type information (including information that has
  70 // only speculatively been asserted) through the dataflow.

  71 class SpeculativeJIT {
<span class="line-modified">  72     WTF_MAKE_FAST_ALLOCATED;</span>
<span class="line-removed">  73 </span>
  74     friend struct OSRExit;
  75 private:
  76     typedef JITCompiler::TrustedImm32 TrustedImm32;
  77     typedef JITCompiler::Imm32 Imm32;
  78     typedef JITCompiler::ImmPtr ImmPtr;
  79     typedef JITCompiler::TrustedImm64 TrustedImm64;
  80     typedef JITCompiler::Imm64 Imm64;
  81 
  82     // These constants are used to set priorities for spill order for
  83     // the register allocator.
  84 #if USE(JSVALUE64)
  85     enum SpillOrder {
  86         SpillOrderConstant = 1, // no spill, and cheap fill
  87         SpillOrderSpilled  = 2, // no spill
  88         SpillOrderJS       = 4, // needs spill
  89         SpillOrderCell     = 4, // needs spill
  90         SpillOrderStorage  = 4, // needs spill
  91         SpillOrderInteger  = 5, // needs spill and box
  92         SpillOrderBoolean  = 5, // needs spill and box
  93         SpillOrderDouble   = 6, // needs spill and convert
</pre>
<hr />
<pre>
 521             m_jit.storeDouble(info.fpr(), JITCompiler::addressFor(spillMe));
 522             info.spill(*m_stream, spillMe, DataFormatDouble);
 523             return;
 524         }
 525 
 526         case DataFormatInt52:
 527         case DataFormatStrictInt52: {
 528             m_jit.store64(info.gpr(), JITCompiler::addressFor(spillMe));
 529             info.spill(*m_stream, spillMe, spillFormat);
 530             return;
 531         }
 532 
 533         default:
 534             // The following code handles JSValues, int32s, and cells.
 535             RELEASE_ASSERT(spillFormat == DataFormatCell || spillFormat &amp; DataFormatJS);
 536 
 537             GPRReg reg = info.gpr();
 538             // We need to box int32 and cell values ...
 539             // but on JSVALUE64 boxing a cell is a no-op!
 540             if (spillFormat == DataFormatInt32)
<span class="line-modified"> 541                 m_jit.or64(GPRInfo::tagTypeNumberRegister, reg);</span>
 542 
 543             // Spill the value, and record it as spilled in its boxed form.
 544             m_jit.store64(reg, JITCompiler::addressFor(spillMe));
 545             info.spill(*m_stream, spillMe, (DataFormat)(spillFormat | DataFormatJS));
 546             return;
 547 #elif USE(JSVALUE32_64)
 548         case DataFormatCell:
 549         case DataFormatBoolean: {
 550             m_jit.store32(info.gpr(), JITCompiler::payloadFor(spillMe));
 551             info.spill(*m_stream, spillMe, spillFormat);
 552             return;
 553         }
 554 
 555         case DataFormatDouble: {
 556             // On JSVALUE32_64 boxing a double is a no-op.
 557             m_jit.storeDouble(info.fpr(), JITCompiler::addressFor(spillMe));
 558             info.spill(*m_stream, spillMe, DataFormatDouble);
 559             return;
 560         }
 561 
</pre>
<hr />
<pre>
 643     }
 644     void bitOp(NodeType op, GPRReg op1, GPRReg op2, GPRReg result)
 645     {
 646         switch (op) {
 647         case ArithBitAnd:
 648             m_jit.and32(op1, op2, result);
 649             break;
 650         case ArithBitOr:
 651             m_jit.or32(op1, op2, result);
 652             break;
 653         case ArithBitXor:
 654             m_jit.xor32(op1, op2, result);
 655             break;
 656         default:
 657             RELEASE_ASSERT_NOT_REACHED();
 658         }
 659     }
 660     void shiftOp(NodeType op, GPRReg op1, int32_t shiftAmount, GPRReg result)
 661     {
 662         switch (op) {
<span class="line-modified"> 663         case BitRShift:</span>
 664             m_jit.rshift32(op1, Imm32(shiftAmount), result);
 665             break;
 666         case ArithBitLShift:
 667             m_jit.lshift32(op1, Imm32(shiftAmount), result);
 668             break;
 669         case BitURShift:
 670             m_jit.urshift32(op1, Imm32(shiftAmount), result);
 671             break;
 672         default:
 673             RELEASE_ASSERT_NOT_REACHED();
 674         }
 675     }
 676     void shiftOp(NodeType op, GPRReg op1, GPRReg shiftAmount, GPRReg result)
 677     {
 678         switch (op) {
<span class="line-modified"> 679         case BitRShift:</span>
 680             m_jit.rshift32(op1, shiftAmount, result);
 681             break;
 682         case ArithBitLShift:
 683             m_jit.lshift32(op1, shiftAmount, result);
 684             break;
 685         case BitURShift:
 686             m_jit.urshift32(op1, shiftAmount, result);
 687             break;
 688         default:
 689             RELEASE_ASSERT_NOT_REACHED();
 690         }
 691     }
 692 
 693     // Returns the index of the branch node if peephole is okay, UINT_MAX otherwise.
 694     unsigned detectPeepHoleBranch()
 695     {
 696         // Check that no intervening nodes will be generated.
 697         for (unsigned index = m_indexInBlock + 1; index &lt; m_block-&gt;size() - 1; ++index) {
 698             Node* node = m_block-&gt;at(index);
 699             if (!node-&gt;shouldGenerate())
 700                 continue;
 701             // Check if it&#39;s a Phantom that can be safely ignored.
 702             if (node-&gt;op() == Phantom &amp;&amp; !node-&gt;child1())
 703                 continue;
 704             return UINT_MAX;
 705         }
 706 
 707         // Check if the lastNode is a branch on this node.
 708         Node* lastNode = m_block-&gt;terminal();
 709         return lastNode-&gt;op() == Branch &amp;&amp; lastNode-&gt;child1() == m_currentNode ? m_block-&gt;size() - 1 : UINT_MAX;
 710     }
 711 
 712     void compileCheckTraps(Node*);
 713 
 714     void compileMovHint(Node*);
 715     void compileMovHintAndCheck(Node*);
 716 


 717     void cachedGetById(CodeOrigin, JSValueRegs base, JSValueRegs result, unsigned identifierNumber, JITCompiler::Jump slowPathTarget, SpillRegistersMode, AccessType);
 718     void cachedPutById(CodeOrigin, GPRReg baseGPR, JSValueRegs valueRegs, GPRReg scratchGPR, unsigned identifierNumber, PutKind, JITCompiler::Jump slowPathTarget = JITCompiler::Jump(), SpillRegistersMode = NeedToSpill);

 719 
 720 #if USE(JSVALUE64)
 721     void cachedGetById(CodeOrigin, GPRReg baseGPR, GPRReg resultGPR, unsigned identifierNumber, JITCompiler::Jump slowPathTarget, SpillRegistersMode, AccessType);
 722     void cachedGetByIdWithThis(CodeOrigin, GPRReg baseGPR, GPRReg thisGPR, GPRReg resultGPR, unsigned identifierNumber, const JITCompiler::JumpList&amp; slowPathTarget = JITCompiler::JumpList());
 723 #elif USE(JSVALUE32_64)
 724     void cachedGetById(CodeOrigin, GPRReg baseTagGPROrNone, GPRReg basePayloadGPR, GPRReg resultTagGPR, GPRReg resultPayloadGPR, unsigned identifierNumber, JITCompiler::Jump slowPathTarget, SpillRegistersMode, AccessType);
 725     void cachedGetByIdWithThis(CodeOrigin, GPRReg baseTagGPROrNone, GPRReg basePayloadGPR, GPRReg thisTagGPROrNone, GPRReg thisPayloadGPR, GPRReg resultTagGPR, GPRReg resultPayloadGPR, unsigned identifierNumber, const JITCompiler::JumpList&amp; slowPathTarget = JITCompiler::JumpList());
 726 #endif
 727 
 728     void compileDeleteById(Node*);
 729     void compileDeleteByVal(Node*);
 730     void compilePushWithScope(Node*);
 731     void compileGetById(Node*, AccessType);
 732     void compileGetByIdFlush(Node*, AccessType);
 733     void compileInById(Node*);
 734     void compileInByVal(Node*);
 735 
 736     void nonSpeculativeNonPeepholeCompareNullOrUndefined(Edge operand);
 737     void nonSpeculativePeepholeBranchNullOrUndefined(Edge operand, Node* branchNode);
 738 
<span class="line-modified"> 739     void nonSpeculativePeepholeBranch(Node*, Node* branchNode, MacroAssembler::RelationalCondition, S_JITOperation_EJJ helperFunction);</span>
<span class="line-modified"> 740     void nonSpeculativeNonPeepholeCompare(Node*, MacroAssembler::RelationalCondition, S_JITOperation_EJJ helperFunction);</span>
 741 
 742     void nonSpeculativePeepholeStrictEq(Node*, Node* branchNode, bool invert = false);
 743     void nonSpeculativeNonPeepholeStrictEq(Node*, bool invert = false);
 744     bool nonSpeculativeStrictEq(Node*, bool invert = false);
 745 
 746     void compileInstanceOfForCells(Node*, JSValueRegs valueGPR, JSValueRegs prototypeGPR, GPRReg resultGPT, GPRReg scratchGPR, GPRReg scratch2GPR, JITCompiler::Jump slowCase = JITCompiler::Jump());
 747     void compileInstanceOf(Node*);
 748     void compileInstanceOfCustom(Node*);
 749     void compileOverridesHasInstance(Node*);
 750 
 751     void compileIsCellWithType(Node*);
 752     void compileIsTypedArrayView(Node*);
 753 
 754     void emitCall(Node*);
 755 
 756     void emitAllocateButterfly(GPRReg storageGPR, GPRReg sizeGPR, GPRReg scratch1, GPRReg scratch2, GPRReg scratch3, MacroAssembler::JumpList&amp; slowCases);
 757     void emitInitializeButterfly(GPRReg storageGPR, GPRReg sizeGPR, JSValueRegs emptyValueRegs, GPRReg scratchGPR);
 758     void compileAllocateNewArrayWithSize(JSGlobalObject*, GPRReg resultGPR, GPRReg sizeGPR, IndexingType, bool shouldConvertLargeSizeToArrayStorage = true);
 759 
 760     // Called once a node has completed code generation but prior to setting
</pre>
<hr />
<pre>
 904         m_gprs.retain(reg, virtualRegister, SpillOrderStorage);
 905         GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 906         info.initStorage(node, node-&gt;refCount(), reg);
 907     }
 908     void doubleResult(FPRReg reg, Node* node, UseChildrenMode mode = CallUseChildren)
 909     {
 910         if (mode == CallUseChildren)
 911             useChildren(node);
 912 
 913         VirtualRegister virtualRegister = node-&gt;virtualRegister();
 914         m_fprs.retain(reg, virtualRegister, SpillOrderDouble);
 915         GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 916         info.initDouble(node, node-&gt;refCount(), reg);
 917     }
 918     void initConstantInfo(Node* node)
 919     {
 920         ASSERT(node-&gt;hasConstant());
 921         generationInfo(node).initConstant(node, node-&gt;refCount());
 922     }
 923 
<span class="line-removed"> 924 #define FIRST_ARGUMENT_TYPE typename FunctionTraits&lt;OperationType&gt;::template ArgumentType&lt;0&gt;</span>
<span class="line-removed"> 925 </span>
 926     template&lt;typename OperationType, typename ResultRegType, typename... Args&gt;
 927     std::enable_if_t&lt;
 928         FunctionTraits&lt;OperationType&gt;::hasResult,
 929     JITCompiler::Call&gt;
 930     callOperation(OperationType operation, ResultRegType result, Args... args)
 931     {
 932         m_jit.setupArguments&lt;OperationType&gt;(args...);
 933         return appendCallSetResult(operation, result);
 934     }
 935 
<span class="line-removed"> 936     template&lt;typename OperationType, typename Arg, typename... Args&gt;</span>
<span class="line-removed"> 937     std::enable_if_t&lt;</span>
<span class="line-removed"> 938         !FunctionTraits&lt;OperationType&gt;::hasResult</span>
<span class="line-removed"> 939         &amp;&amp; !std::is_same&lt;Arg, NoResultTag&gt;::value,</span>
<span class="line-removed"> 940     JITCompiler::Call&gt;</span>
<span class="line-removed"> 941     callOperation(OperationType operation, Arg arg, Args... args)</span>
<span class="line-removed"> 942     {</span>
<span class="line-removed"> 943         m_jit.setupArguments&lt;OperationType&gt;(arg, args...);</span>
<span class="line-removed"> 944         return appendCall(operation);</span>
<span class="line-removed"> 945     }</span>
<span class="line-removed"> 946 </span>
 947     template&lt;typename OperationType, typename... Args&gt;
 948     std::enable_if_t&lt;
 949         !FunctionTraits&lt;OperationType&gt;::hasResult,
 950     JITCompiler::Call&gt;
<span class="line-modified"> 951     callOperation(OperationType operation, NoResultTag, Args... args)</span>
 952     {
 953         m_jit.setupArguments&lt;OperationType&gt;(args...);
 954         return appendCall(operation);
 955     }
 956 
<span class="line-modified"> 957     template&lt;typename OperationType&gt;</span>
<span class="line-removed"> 958     std::enable_if_t&lt;</span>
<span class="line-removed"> 959         !FunctionTraits&lt;OperationType&gt;::hasResult,</span>
<span class="line-removed"> 960     JITCompiler::Call&gt;</span>
<span class="line-removed"> 961     callOperation(OperationType operation)</span>
 962     {
<span class="line-modified"> 963         m_jit.setupArguments&lt;OperationType&gt;();</span>
<span class="line-modified"> 964         return appendCall(operation);</span>
<span class="line-removed"> 965     }</span>
<span class="line-removed"> 966 </span>
<span class="line-removed"> 967 #undef FIRST_ARGUMENT_TYPE</span>
<span class="line-removed"> 968 </span>
<span class="line-removed"> 969     JITCompiler::Call callOperationWithCallFrameRollbackOnException(V_JITOperation_ECb operation, void* pointer)</span>
<span class="line-removed"> 970     {</span>
<span class="line-removed"> 971         m_jit.setupArguments&lt;V_JITOperation_ECb&gt;(TrustedImmPtr(pointer));</span>
 972         return appendCallWithCallFrameRollbackOnException(operation);
 973     }
 974 
<span class="line-modified"> 975     JITCompiler::Call callOperationWithCallFrameRollbackOnException(Z_JITOperation_E operation, GPRReg result)</span>
 976     {
<span class="line-modified"> 977         m_jit.setupArguments&lt;Z_JITOperation_E&gt;();</span>
 978         return appendCallWithCallFrameRollbackOnExceptionSetResult(operation, result);
 979     }
 980 
<span class="line-removed"> 981 #if !defined(NDEBUG) &amp;&amp; !CPU(ARM_THUMB2) &amp;&amp; !CPU(MIPS)</span>
 982     void prepareForExternalCall()
 983     {

 984         // We&#39;re about to call out to a &quot;native&quot; helper function. The helper
<span class="line-modified"> 985         // function is expected to set topCallFrame itself with the ExecState</span>
 986         // that is passed to it.
 987         //
 988         // We explicitly trash topCallFrame here so that we&#39;ll know if some of
 989         // the helper functions are not setting topCallFrame when they should
 990         // be doing so. Note: the previous value in topcallFrame was not valid
 991         // anyway since it was not being updated by JIT&#39;ed code by design.
 992 
 993         for (unsigned i = 0; i &lt; sizeof(void*) / 4; i++)
 994             m_jit.store32(TrustedImm32(0xbadbeef), reinterpret_cast&lt;char*&gt;(&amp;vm().topCallFrame) + i * 4);
<span class="line-removed"> 995     }</span>
<span class="line-removed"> 996 #else</span>
<span class="line-removed"> 997     void prepareForExternalCall() { }</span>
 998 #endif


 999 
1000     // These methods add call instructions, optionally setting results, and optionally rolling back the call frame on an exception.
1001     JITCompiler::Call appendCall(const FunctionPtr&lt;CFunctionPtrTag&gt; function)
1002     {
1003         prepareForExternalCall();
1004         m_jit.emitStoreCodeOrigin(m_currentNode-&gt;origin.semantic);
1005         return m_jit.appendCall(function);
1006     }
1007 
1008     JITCompiler::Call appendCallWithCallFrameRollbackOnException(const FunctionPtr&lt;CFunctionPtrTag&gt; function)
1009     {
1010         JITCompiler::Call call = appendCall(function);
1011         m_jit.exceptionCheckWithCallFrameRollback();
1012         return call;
1013     }
1014 
1015     JITCompiler::Call appendCallWithCallFrameRollbackOnExceptionSetResult(const FunctionPtr&lt;CFunctionPtrTag&gt; function, GPRReg result)
1016     {
1017         JITCompiler::Call call = appendCallWithCallFrameRollbackOnException(function);
1018         if ((result != InvalidGPRReg) &amp;&amp; (result != GPRInfo::returnValueGPR))
</pre>
<hr />
<pre>
1027             m_jit.move(GPRInfo::returnValueGPR, result);
1028         return call;
1029     }
1030 
1031     JITCompiler::Call appendCallSetResult(const FunctionPtr&lt;CFunctionPtrTag&gt; function, GPRReg result1, GPRReg result2)
1032     {
1033         JITCompiler::Call call = appendCall(function);
1034         m_jit.setupResults(result1, result2);
1035         return call;
1036     }
1037 
1038     JITCompiler::Call appendCallSetResult(const FunctionPtr&lt;CFunctionPtrTag&gt; function, JSValueRegs resultRegs)
1039     {
1040 #if USE(JSVALUE64)
1041         return appendCallSetResult(function, resultRegs.gpr());
1042 #else
1043         return appendCallSetResult(function, resultRegs.payloadGPR(), resultRegs.tagGPR());
1044 #endif
1045     }
1046 
<span class="line-modified">1047 #if CPU(X86)</span>
<span class="line-removed">1048     JITCompiler::Call appendCallSetResult(const FunctionPtr&lt;CFunctionPtrTag&gt; function, FPRReg result)</span>
<span class="line-removed">1049     {</span>
<span class="line-removed">1050         JITCompiler::Call call = appendCall(function);</span>
<span class="line-removed">1051         if (result != InvalidFPRReg) {</span>
<span class="line-removed">1052             m_jit.assembler().fstpl(0, JITCompiler::stackPointerRegister);</span>
<span class="line-removed">1053             m_jit.loadDouble(JITCompiler::stackPointerRegister, result);</span>
<span class="line-removed">1054         }</span>
<span class="line-removed">1055         return call;</span>
<span class="line-removed">1056     }</span>
<span class="line-removed">1057 #elif CPU(ARM_THUMB2) &amp;&amp; !CPU(ARM_HARDFP)</span>
1058     JITCompiler::Call appendCallSetResult(const FunctionPtr&lt;CFunctionPtrTag&gt; function, FPRReg result)
1059     {
1060         JITCompiler::Call call = appendCall(function);
1061         if (result != InvalidFPRReg)
1062             m_jit.assembler().vmov(result, GPRInfo::returnValueGPR, GPRInfo::returnValueGPR2);
1063         return call;
1064     }
1065 #else // CPU(X86_64) || (CPU(ARM_THUMB2) &amp;&amp; CPU(ARM_HARDFP)) || CPU(ARM64) || CPU(MIPS)
1066     JITCompiler::Call appendCallSetResult(const FunctionPtr&lt;CFunctionPtrTag&gt; function, FPRReg result)
1067     {
1068         JITCompiler::Call call = appendCall(function);
1069         if (result != InvalidFPRReg)
1070             m_jit.moveDouble(FPRInfo::returnValueFPR, result);
1071         return call;
1072     }
1073 #endif
1074 
1075     void branchDouble(JITCompiler::DoubleCondition cond, FPRReg left, FPRReg right, BasicBlock* destination)
1076     {
1077         return addBranch(m_jit.branchDouble(cond, left, right), destination);
</pre>
<hr />
<pre>
1158 
1159     void addBranch(const MacroAssembler::Jump&amp; jump, BasicBlock* destination)
1160     {
1161         m_branches.append(BranchRecord(jump, destination));
1162     }
1163     void addBranch(const MacroAssembler::JumpList&amp; jump, BasicBlock* destination);
1164 
1165     void linkBranches();
1166 
1167     void dump(const char* label = 0);
1168 
1169     bool betterUseStrictInt52(Node* node)
1170     {
1171         return !generationInfo(node).isInt52();
1172     }
1173     bool betterUseStrictInt52(Edge edge)
1174     {
1175         return betterUseStrictInt52(edge.node());
1176     }
1177 
<span class="line-modified">1178     bool compare(Node*, MacroAssembler::RelationalCondition, MacroAssembler::DoubleCondition, S_JITOperation_EJJ);</span>
1179     void compileCompareUnsigned(Node*, MacroAssembler::RelationalCondition);
<span class="line-modified">1180     bool compilePeepHoleBranch(Node*, MacroAssembler::RelationalCondition, MacroAssembler::DoubleCondition, S_JITOperation_EJJ);</span>
1181     void compilePeepHoleInt32Branch(Node*, Node* branchNode, JITCompiler::RelationalCondition);
1182     void compilePeepHoleInt52Branch(Node*, Node* branchNode, JITCompiler::RelationalCondition);
1183     void compilePeepHoleBooleanBranch(Node*, Node* branchNode, JITCompiler::RelationalCondition);
1184     void compilePeepHoleDoubleBranch(Node*, Node* branchNode, JITCompiler::DoubleCondition);
1185     void compilePeepHoleObjectEquality(Node*, Node* branchNode);
1186     void compilePeepHoleObjectStrictEquality(Edge objectChild, Edge otherChild, Node* branchNode);
1187     void compilePeepHoleObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild, Node* branchNode);
1188     void compileObjectEquality(Node*);
1189     void compileObjectStrictEquality(Edge objectChild, Edge otherChild);
1190     void compileObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild);
1191     void compileObjectOrOtherLogicalNot(Edge value);
1192     void compileLogicalNot(Node*);
1193     void compileLogicalNotStringOrOther(Node*);
1194     void compileStringEquality(
1195         Node*, GPRReg leftGPR, GPRReg rightGPR, GPRReg lengthGPR,
1196         GPRReg leftTempGPR, GPRReg rightTempGPR, GPRReg leftTemp2GPR,
1197         GPRReg rightTemp2GPR, const JITCompiler::JumpList&amp; fastTrue,
1198         const JITCompiler::JumpList&amp; fastSlow);
1199     void compileStringEquality(Node*);
1200     void compileStringIdentEquality(Node*);
</pre>
<hr />
<pre>
1216     struct StringSwitchCase {
1217         StringSwitchCase() { }
1218 
1219         StringSwitchCase(StringImpl* string, BasicBlock* target)
1220             : string(string)
1221             , target(target)
1222         {
1223         }
1224 
1225         bool operator&lt;(const StringSwitchCase&amp; other) const
1226         {
1227             return stringLessThan(*string, *other.string);
1228         }
1229 
1230         StringImpl* string;
1231         BasicBlock* target;
1232     };
1233 
1234     void emitSwitchIntJump(SwitchData*, GPRReg value, GPRReg scratch);
1235     void emitSwitchImm(Node*, SwitchData*);
<span class="line-modified">1236     void emitSwitchCharStringJump(SwitchData*, GPRReg value, GPRReg scratch);</span>
1237     void emitSwitchChar(Node*, SwitchData*);
1238     void emitBinarySwitchStringRecurse(
1239         SwitchData*, const Vector&lt;StringSwitchCase&gt;&amp;, unsigned numChecked,
1240         unsigned begin, unsigned end, GPRReg buffer, GPRReg length, GPRReg temp,
1241         unsigned alreadyCheckedLength, bool checkedExactLength);
<span class="line-modified">1242     void emitSwitchStringOnString(SwitchData*, GPRReg string);</span>
1243     void emitSwitchString(Node*, SwitchData*);
1244     void emitSwitch(Node*);
1245 
1246     void compileToStringOrCallStringConstructorOrStringValueOf(Node*);
1247     void compileNumberToStringWithRadix(Node*);
1248     void compileNumberToStringWithValidRadixConstant(Node*);
1249     void compileNumberToStringWithValidRadixConstant(Node*, int32_t radix);
1250     void compileNewStringObject(Node*);
1251     void compileNewSymbol(Node*);
1252 
1253     void compileNewTypedArrayWithSize(Node*);
1254 
1255     void compileInt32Compare(Node*, MacroAssembler::RelationalCondition);
1256     void compileInt52Compare(Node*, MacroAssembler::RelationalCondition);
1257     void compileBooleanCompare(Node*, MacroAssembler::RelationalCondition);
1258     void compileDoubleCompare(Node*, MacroAssembler::DoubleCondition);
1259     void compileStringCompare(Node*, MacroAssembler::RelationalCondition);
1260     void compileStringIdentCompare(Node*, MacroAssembler::RelationalCondition);
1261 
1262     bool compileStrictEq(Node*);
</pre>
<hr />
<pre>
1297     GPRReg temporaryRegisterForPutByVal(GPRTemporary&amp; temporary, Node* node)
1298     {
1299         return temporaryRegisterForPutByVal(temporary, node-&gt;arrayMode());
1300     }
1301 
1302     void compileGetCharCodeAt(Node*);
1303     void compileGetByValOnString(Node*);
1304     void compileFromCharCode(Node*);
1305 
1306     void compileGetByValOnDirectArguments(Node*);
1307     void compileGetByValOnScopedArguments(Node*);
1308 
1309     void compileGetScope(Node*);
1310     void compileSkipScope(Node*);
1311     void compileGetGlobalObject(Node*);
1312     void compileGetGlobalThis(Node*);
1313 
1314     void compileGetArrayLength(Node*);
1315 
1316     void compileCheckTypeInfoFlags(Node*);
<span class="line-modified">1317     void compileCheckStringIdent(Node*);</span>
1318 
1319     void compileParseInt(Node*);
1320 
1321     void compileValueRep(Node*);
1322     void compileDoubleRep(Node*);
1323 
1324     void compileValueToInt32(Node*);
1325     void compileUInt32ToNumber(Node*);
1326     void compileDoubleAsInt32(Node*);
1327 
1328     void compileValueBitNot(Node*);
1329     void compileBitwiseNot(Node*);
1330 
<span class="line-modified">1331     template&lt;typename SnippetGenerator, J_JITOperation_EJJ slowPathFunction&gt;</span>
1332     void emitUntypedBitOp(Node*);
1333     void compileBitwiseOp(Node*);
1334     void compileValueBitwiseOp(Node*);
1335 
1336     void emitUntypedRightShiftBitOp(Node*);
1337     void compileValueLShiftOp(Node*);

1338     void compileShiftOp(Node*);
1339 
1340     template &lt;typename Generator, typename RepatchingFunction, typename NonRepatchingFunction&gt;
1341     void compileMathIC(Node*, JITBinaryMathIC&lt;Generator&gt;*, bool needsScratchGPRReg, bool needsScratchFPRReg, RepatchingFunction, NonRepatchingFunction);
1342     template &lt;typename Generator, typename RepatchingFunction, typename NonRepatchingFunction&gt;
1343     void compileMathIC(Node*, JITUnaryMathIC&lt;Generator&gt;*, bool needsScratchGPRReg, RepatchingFunction, NonRepatchingFunction);
1344 
<span class="line-modified">1345     void compileArithDoubleUnaryOp(Node*, double (*doubleFunction)(double), double (*operation)(ExecState*, EncodedJSValue));</span>
1346     void compileValueAdd(Node*);
1347     void compileValueSub(Node*);
1348     void compileArithAdd(Node*);
1349     void compileMakeRope(Node*);
1350     void compileArithAbs(Node*);
1351     void compileArithClz32(Node*);
1352     void compileArithSub(Node*);

1353     void compileValueNegate(Node*);
1354     void compileArithNegate(Node*);
1355     void compileValueMul(Node*);
1356     void compileArithMul(Node*);
1357     void compileValueDiv(Node*);
1358     void compileArithDiv(Node*);
1359     void compileArithFRound(Node*);
1360     void compileValueMod(Node*);
1361     void compileArithMod(Node*);
1362     void compileArithPow(Node*);
1363     void compileValuePow(Node*);
1364     void compileArithRounding(Node*);
1365     void compileArithRandom(Node*);
1366     void compileArithUnary(Node*);
1367     void compileArithSqrt(Node*);
1368     void compileArithMinMax(Node*);
1369     void compileConstantStoragePointer(Node*);
1370     void compileGetIndexedPropertyStorage(Node*);
1371     JITCompiler::Jump jumpForTypedArrayOutOfBounds(Node*, GPRReg baseGPR, GPRReg indexGPR);
1372     JITCompiler::Jump jumpForTypedArrayIsNeuteredIfOutOfBounds(Node*, GPRReg baseGPR, JITCompiler::Jump outOfBounds);
</pre>
<hr />
<pre>
1383     void compileGetByValWithThis(Node*);
1384     void compileGetByOffset(Node*);
1385     void compilePutByOffset(Node*);
1386     void compileMatchStructure(Node*);
1387     // If this returns false it means that we terminated speculative execution.
1388     bool getIntTypedArrayStoreOperand(
1389         GPRTemporary&amp; value,
1390         GPRReg property,
1391 #if USE(JSVALUE32_64)
1392         GPRTemporary&amp; propertyTag,
1393         GPRTemporary&amp; valueTag,
1394 #endif
1395         Edge valueUse, JITCompiler::JumpList&amp; slowPathCases, bool isClamped = false);
1396     void loadFromIntTypedArray(GPRReg storageReg, GPRReg propertyReg, GPRReg resultReg, TypedArrayType);
1397     void setIntTypedArrayLoadResult(Node*, GPRReg resultReg, TypedArrayType, bool canSpeculate = false);
1398     template &lt;typename ClassType&gt; void compileNewFunctionCommon(GPRReg, RegisteredStructure, GPRReg, GPRReg, GPRReg, MacroAssembler::JumpList&amp;, size_t, FunctionExecutable*);
1399     void compileNewFunction(Node*);
1400     void compileSetFunctionName(Node*);
1401     void compileNewRegexp(Node*);
1402     void compileForwardVarargs(Node*);

1403     void compileLoadVarargs(Node*);
1404     void compileCreateActivation(Node*);
1405     void compileCreateDirectArguments(Node*);
1406     void compileGetFromArguments(Node*);
1407     void compilePutToArguments(Node*);
1408     void compileGetArgument(Node*);
1409     void compileCreateScopedArguments(Node*);
1410     void compileCreateClonedArguments(Node*);

1411     void compileCreateRest(Node*);
1412     void compileSpread(Node*);
1413     void compileNewArray(Node*);
1414     void compileNewArrayWithSpread(Node*);
1415     void compileGetRestLength(Node*);
1416     void compileArraySlice(Node*);
1417     void compileArrayIndexOf(Node*);
1418     void compileArrayPush(Node*);
1419     void compileNotifyWrite(Node*);
1420     void compileRegExpExec(Node*);
1421     void compileRegExpExecNonGlobalOrSticky(Node*);
1422     void compileRegExpMatchFast(Node*);
1423     void compileRegExpMatchFastGlobal(Node*);
1424     void compileRegExpTest(Node*);
1425     void compileStringReplace(Node*);
1426     void compileIsObject(Node*);
1427     void compileIsObjectOrNull(Node*);
1428     void compileIsFunction(Node*);
1429     void compileTypeOf(Node*);
1430     void compileCheckCell(Node*);
1431     void compileCheckNotEmpty(Node*);
1432     void compileCheckStructure(Node*);
1433     void emitStructureCheck(Node*, GPRReg cellGPR, GPRReg tempGPR);
1434     void compilePutAccessorById(Node*);
1435     void compilePutGetterSetterById(Node*);
1436     void compilePutAccessorByVal(Node*);
1437     void compileGetRegExpObjectLastIndex(Node*);
1438     void compileSetRegExpObjectLastIndex(Node*);
1439     void compileLazyJSConstant(Node*);
1440     void compileMaterializeNewObject(Node*);
1441     void compileRecordRegExpCachedResult(Node*);
1442     void compileToObjectOrCallObjectConstructor(Node*);
1443     void compileResolveScope(Node*);
1444     void compileResolveScopeForHoistingFuncDeclInEval(Node*);
1445     void compileGetGlobalVariable(Node*);
1446     void compilePutGlobalVariable(Node*);
1447     void compileGetDynamicVar(Node*);
1448     void compilePutDynamicVar(Node*);
1449     void compileGetClosureVar(Node*);
1450     void compilePutClosureVar(Node*);


1451     void compileCompareEqPtr(Node*);
1452     void compileDefineDataProperty(Node*);
1453     void compileDefineAccessorProperty(Node*);
1454     void compileStringSlice(Node*);
1455     void compileToLowerCase(Node*);
1456     void compileThrow(Node*);
1457     void compileThrowStaticError(Node*);
1458     void compileGetEnumerableLength(Node*);
1459     void compileHasGenericProperty(Node*);
1460     void compileToIndexString(Node*);
1461     void compilePutByIdFlush(Node*);
1462     void compilePutById(Node*);
1463     void compilePutByIdDirect(Node*);
1464     void compilePutByIdWithThis(Node*);
1465     void compileHasStructureProperty(Node*);
1466     void compileGetDirectPname(Node*);
1467     void compileGetPropertyEnumerator(Node*);
1468     void compileGetEnumeratorPname(Node*);
1469     void compileGetExecutable(Node*);
1470     void compileGetGetter(Node*);
1471     void compileGetSetter(Node*);
1472     void compileGetCallee(Node*);
1473     void compileSetCallee(Node*);
1474     void compileGetArgumentCountIncludingThis(Node*);
1475     void compileSetArgumentCountIncludingThis(Node*);
1476     void compileStrCat(Node*);
1477     void compileNewArrayBuffer(Node*);
1478     void compileNewArrayWithSize(Node*);
1479     void compileNewTypedArray(Node*);
1480     void compileToThis(Node*);
1481     void compileObjectKeys(Node*);
1482     void compileObjectCreate(Node*);
1483     void compileCreateThis(Node*);



1484     void compileNewObject(Node*);




1485     void compileToPrimitive(Node*);


1486     void compileLogShadowChickenPrologue(Node*);
1487     void compileLogShadowChickenTail(Node*);
1488     void compileHasIndexedProperty(Node*);
1489     void compileExtractCatchLocal(Node*);
1490     void compileClearCatchLocals(Node*);
1491     void compileProfileType(Node*);







1492 
1493     void moveTrueTo(GPRReg);
1494     void moveFalseTo(GPRReg);
1495     void blessBoolean(GPRReg);
1496 
1497     // Allocator for a cell of a specific size.
1498     template &lt;typename StructureType&gt; // StructureType can be GPR or ImmPtr.
1499     void emitAllocateJSCell(
1500         GPRReg resultGPR, const JITAllocator&amp; allocator, GPRReg allocatorGPR, StructureType structure,
1501         GPRReg scratchGPR, MacroAssembler::JumpList&amp; slowPath)
1502     {
1503         m_jit.emitAllocateJSCell(resultGPR, allocator, allocatorGPR, structure, scratchGPR, slowPath);
1504     }
1505 
1506     // Allocator for an object of a specific size.
1507     template &lt;typename StructureType, typename StorageType&gt; // StructureType and StorageType can be GPR or ImmPtr.
1508     void emitAllocateJSObject(
1509         GPRReg resultGPR, const JITAllocator&amp; allocator, GPRReg allocatorGPR, StructureType structure,
1510         StorageType storage, GPRReg scratchGPR, MacroAssembler::JumpList&amp; slowPath)
1511     {
</pre>
<hr />
<pre>
1588     void speculateAnyInt(Edge);
1589     void speculateInt32(Edge, JSValueRegs);
1590     void speculateDoubleRepAnyInt(Edge);
1591 #endif // USE(JSVALUE64)
1592     void speculateNumber(Edge);
1593     void speculateRealNumber(Edge);
1594     void speculateDoubleRepReal(Edge);
1595     void speculateBoolean(Edge);
1596     void speculateCell(Edge);
1597     void speculateCellOrOther(Edge);
1598     void speculateObject(Edge, GPRReg cell);
1599     void speculateObject(Edge);
1600     void speculateArray(Edge, GPRReg cell);
1601     void speculateArray(Edge);
1602     void speculateFunction(Edge, GPRReg cell);
1603     void speculateFunction(Edge);
1604     void speculateFinalObject(Edge, GPRReg cell);
1605     void speculateFinalObject(Edge);
1606     void speculateRegExpObject(Edge, GPRReg cell);
1607     void speculateRegExpObject(Edge);


1608     void speculateProxyObject(Edge, GPRReg cell);
1609     void speculateProxyObject(Edge);
1610     void speculateDerivedArray(Edge, GPRReg cell);
1611     void speculateDerivedArray(Edge);


1612     void speculateMapObject(Edge);
1613     void speculateMapObject(Edge, GPRReg cell);
1614     void speculateSetObject(Edge);
1615     void speculateSetObject(Edge, GPRReg cell);
1616     void speculateWeakMapObject(Edge);
1617     void speculateWeakMapObject(Edge, GPRReg cell);
1618     void speculateWeakSetObject(Edge);
1619     void speculateWeakSetObject(Edge, GPRReg cell);
1620     void speculateDataViewObject(Edge);
1621     void speculateDataViewObject(Edge, GPRReg cell);
1622     void speculateObjectOrOther(Edge);
1623     void speculateString(Edge edge, GPRReg cell);
1624     void speculateStringIdentAndLoadStorage(Edge edge, GPRReg string, GPRReg storage);
1625     void speculateStringIdent(Edge edge, GPRReg string);
1626     void speculateStringIdent(Edge);
1627     void speculateString(Edge);
1628     void speculateStringOrOther(Edge, JSValueRegs, GPRReg scratch);
1629     void speculateStringOrOther(Edge);
1630     void speculateNotStringVar(Edge);
1631     void speculateNotSymbol(Edge);
</pre>
<hr />
<pre>
1639     void speculateNotCell(Edge, JSValueRegs);
1640     void speculateNotCell(Edge);
1641     void speculateOther(Edge, JSValueRegs, GPRReg temp);
1642     void speculateOther(Edge, JSValueRegs);
1643     void speculateOther(Edge);
1644     void speculateMisc(Edge, JSValueRegs);
1645     void speculateMisc(Edge);
1646     void speculate(Node*, Edge);
1647 
1648     JITCompiler::JumpList jumpSlowForUnwantedArrayMode(GPRReg tempWithIndexingTypeReg, ArrayMode);
1649     void checkArray(Node*);
1650     void arrayify(Node*, GPRReg baseReg, GPRReg propertyReg);
1651     void arrayify(Node*);
1652 
1653     template&lt;bool strict&gt;
1654     GPRReg fillSpeculateInt32Internal(Edge, DataFormat&amp; returnFormat);
1655 
1656     void cageTypedArrayStorage(GPRReg, GPRReg);
1657 
1658     void recordSetLocal(
<span class="line-modified">1659         VirtualRegister bytecodeReg, VirtualRegister machineReg, DataFormat format)</span>
1660     {

1661         m_stream-&gt;appendAndLog(VariableEvent::setLocal(bytecodeReg, machineReg, format));
1662     }
1663 
1664     void recordSetLocal(DataFormat format)
1665     {
1666         VariableAccessData* variable = m_currentNode-&gt;variableAccessData();
<span class="line-modified">1667         recordSetLocal(variable-&gt;local(), variable-&gt;machineLocal(), format);</span>
1668     }
1669 
1670     GenerationInfo&amp; generationInfoFromVirtualRegister(VirtualRegister virtualRegister)
1671     {
1672         return m_generationInfo[virtualRegister.toLocal()];
1673     }
1674 
1675     GenerationInfo&amp; generationInfo(Node* node)
1676     {
1677         return generationInfoFromVirtualRegister(node-&gt;virtualRegister());
1678     }
1679 
1680     GenerationInfo&amp; generationInfo(Edge edge)
1681     {
1682         return generationInfo(edge.node());
1683     }
1684 
1685     // The JIT, while also provides MacroAssembler functionality.
1686     JITCompiler&amp; m_jit;
1687     Graph&amp; m_graph;
</pre>
</td>
<td>
<hr />
<pre>
  51 class SlowPathGenerator;
  52 class SpeculativeJIT;
  53 class SpeculateInt32Operand;
  54 class SpeculateStrictInt32Operand;
  55 class SpeculateDoubleOperand;
  56 class SpeculateCellOperand;
  57 class SpeculateBooleanOperand;
  58 
  59 enum GeneratedOperandType { GeneratedOperandTypeUnknown, GeneratedOperandInteger, GeneratedOperandJSValue};
  60 
  61 // === SpeculativeJIT ===
  62 //
  63 // The SpeculativeJIT is used to generate a fast, but potentially
  64 // incomplete code path for the dataflow. When code generating
  65 // we may make assumptions about operand types, dynamically check,
  66 // and bail-out to an alternate code path if these checks fail.
  67 // Importantly, the speculative code path cannot be reentered once
  68 // a speculative check has failed. This allows the SpeculativeJIT
  69 // to propagate type information (including information that has
  70 // only speculatively been asserted) through the dataflow.
<span class="line-added">  71 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SpeculativeJIT);</span>
  72 class SpeculativeJIT {
<span class="line-modified">  73     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(SpeculativeJIT);</span>

  74     friend struct OSRExit;
  75 private:
  76     typedef JITCompiler::TrustedImm32 TrustedImm32;
  77     typedef JITCompiler::Imm32 Imm32;
  78     typedef JITCompiler::ImmPtr ImmPtr;
  79     typedef JITCompiler::TrustedImm64 TrustedImm64;
  80     typedef JITCompiler::Imm64 Imm64;
  81 
  82     // These constants are used to set priorities for spill order for
  83     // the register allocator.
  84 #if USE(JSVALUE64)
  85     enum SpillOrder {
  86         SpillOrderConstant = 1, // no spill, and cheap fill
  87         SpillOrderSpilled  = 2, // no spill
  88         SpillOrderJS       = 4, // needs spill
  89         SpillOrderCell     = 4, // needs spill
  90         SpillOrderStorage  = 4, // needs spill
  91         SpillOrderInteger  = 5, // needs spill and box
  92         SpillOrderBoolean  = 5, // needs spill and box
  93         SpillOrderDouble   = 6, // needs spill and convert
</pre>
<hr />
<pre>
 521             m_jit.storeDouble(info.fpr(), JITCompiler::addressFor(spillMe));
 522             info.spill(*m_stream, spillMe, DataFormatDouble);
 523             return;
 524         }
 525 
 526         case DataFormatInt52:
 527         case DataFormatStrictInt52: {
 528             m_jit.store64(info.gpr(), JITCompiler::addressFor(spillMe));
 529             info.spill(*m_stream, spillMe, spillFormat);
 530             return;
 531         }
 532 
 533         default:
 534             // The following code handles JSValues, int32s, and cells.
 535             RELEASE_ASSERT(spillFormat == DataFormatCell || spillFormat &amp; DataFormatJS);
 536 
 537             GPRReg reg = info.gpr();
 538             // We need to box int32 and cell values ...
 539             // but on JSVALUE64 boxing a cell is a no-op!
 540             if (spillFormat == DataFormatInt32)
<span class="line-modified"> 541                 m_jit.or64(GPRInfo::numberTagRegister, reg);</span>
 542 
 543             // Spill the value, and record it as spilled in its boxed form.
 544             m_jit.store64(reg, JITCompiler::addressFor(spillMe));
 545             info.spill(*m_stream, spillMe, (DataFormat)(spillFormat | DataFormatJS));
 546             return;
 547 #elif USE(JSVALUE32_64)
 548         case DataFormatCell:
 549         case DataFormatBoolean: {
 550             m_jit.store32(info.gpr(), JITCompiler::payloadFor(spillMe));
 551             info.spill(*m_stream, spillMe, spillFormat);
 552             return;
 553         }
 554 
 555         case DataFormatDouble: {
 556             // On JSVALUE32_64 boxing a double is a no-op.
 557             m_jit.storeDouble(info.fpr(), JITCompiler::addressFor(spillMe));
 558             info.spill(*m_stream, spillMe, DataFormatDouble);
 559             return;
 560         }
 561 
</pre>
<hr />
<pre>
 643     }
 644     void bitOp(NodeType op, GPRReg op1, GPRReg op2, GPRReg result)
 645     {
 646         switch (op) {
 647         case ArithBitAnd:
 648             m_jit.and32(op1, op2, result);
 649             break;
 650         case ArithBitOr:
 651             m_jit.or32(op1, op2, result);
 652             break;
 653         case ArithBitXor:
 654             m_jit.xor32(op1, op2, result);
 655             break;
 656         default:
 657             RELEASE_ASSERT_NOT_REACHED();
 658         }
 659     }
 660     void shiftOp(NodeType op, GPRReg op1, int32_t shiftAmount, GPRReg result)
 661     {
 662         switch (op) {
<span class="line-modified"> 663         case ArithBitRShift:</span>
 664             m_jit.rshift32(op1, Imm32(shiftAmount), result);
 665             break;
 666         case ArithBitLShift:
 667             m_jit.lshift32(op1, Imm32(shiftAmount), result);
 668             break;
 669         case BitURShift:
 670             m_jit.urshift32(op1, Imm32(shiftAmount), result);
 671             break;
 672         default:
 673             RELEASE_ASSERT_NOT_REACHED();
 674         }
 675     }
 676     void shiftOp(NodeType op, GPRReg op1, GPRReg shiftAmount, GPRReg result)
 677     {
 678         switch (op) {
<span class="line-modified"> 679         case ArithBitRShift:</span>
 680             m_jit.rshift32(op1, shiftAmount, result);
 681             break;
 682         case ArithBitLShift:
 683             m_jit.lshift32(op1, shiftAmount, result);
 684             break;
 685         case BitURShift:
 686             m_jit.urshift32(op1, shiftAmount, result);
 687             break;
 688         default:
 689             RELEASE_ASSERT_NOT_REACHED();
 690         }
 691     }
 692 
 693     // Returns the index of the branch node if peephole is okay, UINT_MAX otherwise.
 694     unsigned detectPeepHoleBranch()
 695     {
 696         // Check that no intervening nodes will be generated.
 697         for (unsigned index = m_indexInBlock + 1; index &lt; m_block-&gt;size() - 1; ++index) {
 698             Node* node = m_block-&gt;at(index);
 699             if (!node-&gt;shouldGenerate())
 700                 continue;
 701             // Check if it&#39;s a Phantom that can be safely ignored.
 702             if (node-&gt;op() == Phantom &amp;&amp; !node-&gt;child1())
 703                 continue;
 704             return UINT_MAX;
 705         }
 706 
 707         // Check if the lastNode is a branch on this node.
 708         Node* lastNode = m_block-&gt;terminal();
 709         return lastNode-&gt;op() == Branch &amp;&amp; lastNode-&gt;child1() == m_currentNode ? m_block-&gt;size() - 1 : UINT_MAX;
 710     }
 711 
 712     void compileCheckTraps(Node*);
 713 
 714     void compileMovHint(Node*);
 715     void compileMovHintAndCheck(Node*);
 716 
<span class="line-added"> 717     void compileCheckNeutered(Node*);</span>
<span class="line-added"> 718 </span>
 719     void cachedGetById(CodeOrigin, JSValueRegs base, JSValueRegs result, unsigned identifierNumber, JITCompiler::Jump slowPathTarget, SpillRegistersMode, AccessType);
 720     void cachedPutById(CodeOrigin, GPRReg baseGPR, JSValueRegs valueRegs, GPRReg scratchGPR, unsigned identifierNumber, PutKind, JITCompiler::Jump slowPathTarget = JITCompiler::Jump(), SpillRegistersMode = NeedToSpill);
<span class="line-added"> 721     void cachedGetByVal(CodeOrigin, JSValueRegs base, JSValueRegs property, JSValueRegs result, JITCompiler::Jump slowPathTarget);</span>
 722 
 723 #if USE(JSVALUE64)
 724     void cachedGetById(CodeOrigin, GPRReg baseGPR, GPRReg resultGPR, unsigned identifierNumber, JITCompiler::Jump slowPathTarget, SpillRegistersMode, AccessType);
 725     void cachedGetByIdWithThis(CodeOrigin, GPRReg baseGPR, GPRReg thisGPR, GPRReg resultGPR, unsigned identifierNumber, const JITCompiler::JumpList&amp; slowPathTarget = JITCompiler::JumpList());
 726 #elif USE(JSVALUE32_64)
 727     void cachedGetById(CodeOrigin, GPRReg baseTagGPROrNone, GPRReg basePayloadGPR, GPRReg resultTagGPR, GPRReg resultPayloadGPR, unsigned identifierNumber, JITCompiler::Jump slowPathTarget, SpillRegistersMode, AccessType);
 728     void cachedGetByIdWithThis(CodeOrigin, GPRReg baseTagGPROrNone, GPRReg basePayloadGPR, GPRReg thisTagGPROrNone, GPRReg thisPayloadGPR, GPRReg resultTagGPR, GPRReg resultPayloadGPR, unsigned identifierNumber, const JITCompiler::JumpList&amp; slowPathTarget = JITCompiler::JumpList());
 729 #endif
 730 
 731     void compileDeleteById(Node*);
 732     void compileDeleteByVal(Node*);
 733     void compilePushWithScope(Node*);
 734     void compileGetById(Node*, AccessType);
 735     void compileGetByIdFlush(Node*, AccessType);
 736     void compileInById(Node*);
 737     void compileInByVal(Node*);
 738 
 739     void nonSpeculativeNonPeepholeCompareNullOrUndefined(Edge operand);
 740     void nonSpeculativePeepholeBranchNullOrUndefined(Edge operand, Node* branchNode);
 741 
<span class="line-modified"> 742     void nonSpeculativePeepholeBranch(Node*, Node* branchNode, MacroAssembler::RelationalCondition, S_JITOperation_GJJ helperFunction);</span>
<span class="line-modified"> 743     void nonSpeculativeNonPeepholeCompare(Node*, MacroAssembler::RelationalCondition, S_JITOperation_GJJ helperFunction);</span>
 744 
 745     void nonSpeculativePeepholeStrictEq(Node*, Node* branchNode, bool invert = false);
 746     void nonSpeculativeNonPeepholeStrictEq(Node*, bool invert = false);
 747     bool nonSpeculativeStrictEq(Node*, bool invert = false);
 748 
 749     void compileInstanceOfForCells(Node*, JSValueRegs valueGPR, JSValueRegs prototypeGPR, GPRReg resultGPT, GPRReg scratchGPR, GPRReg scratch2GPR, JITCompiler::Jump slowCase = JITCompiler::Jump());
 750     void compileInstanceOf(Node*);
 751     void compileInstanceOfCustom(Node*);
 752     void compileOverridesHasInstance(Node*);
 753 
 754     void compileIsCellWithType(Node*);
 755     void compileIsTypedArrayView(Node*);
 756 
 757     void emitCall(Node*);
 758 
 759     void emitAllocateButterfly(GPRReg storageGPR, GPRReg sizeGPR, GPRReg scratch1, GPRReg scratch2, GPRReg scratch3, MacroAssembler::JumpList&amp; slowCases);
 760     void emitInitializeButterfly(GPRReg storageGPR, GPRReg sizeGPR, JSValueRegs emptyValueRegs, GPRReg scratchGPR);
 761     void compileAllocateNewArrayWithSize(JSGlobalObject*, GPRReg resultGPR, GPRReg sizeGPR, IndexingType, bool shouldConvertLargeSizeToArrayStorage = true);
 762 
 763     // Called once a node has completed code generation but prior to setting
</pre>
<hr />
<pre>
 907         m_gprs.retain(reg, virtualRegister, SpillOrderStorage);
 908         GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 909         info.initStorage(node, node-&gt;refCount(), reg);
 910     }
 911     void doubleResult(FPRReg reg, Node* node, UseChildrenMode mode = CallUseChildren)
 912     {
 913         if (mode == CallUseChildren)
 914             useChildren(node);
 915 
 916         VirtualRegister virtualRegister = node-&gt;virtualRegister();
 917         m_fprs.retain(reg, virtualRegister, SpillOrderDouble);
 918         GenerationInfo&amp; info = generationInfoFromVirtualRegister(virtualRegister);
 919         info.initDouble(node, node-&gt;refCount(), reg);
 920     }
 921     void initConstantInfo(Node* node)
 922     {
 923         ASSERT(node-&gt;hasConstant());
 924         generationInfo(node).initConstant(node, node-&gt;refCount());
 925     }
 926 


 927     template&lt;typename OperationType, typename ResultRegType, typename... Args&gt;
 928     std::enable_if_t&lt;
 929         FunctionTraits&lt;OperationType&gt;::hasResult,
 930     JITCompiler::Call&gt;
 931     callOperation(OperationType operation, ResultRegType result, Args... args)
 932     {
 933         m_jit.setupArguments&lt;OperationType&gt;(args...);
 934         return appendCallSetResult(operation, result);
 935     }
 936 











 937     template&lt;typename OperationType, typename... Args&gt;
 938     std::enable_if_t&lt;
 939         !FunctionTraits&lt;OperationType&gt;::hasResult,
 940     JITCompiler::Call&gt;
<span class="line-modified"> 941     callOperation(OperationType operation, Args... args)</span>
 942     {
 943         m_jit.setupArguments&lt;OperationType&gt;(args...);
 944         return appendCall(operation);
 945     }
 946 
<span class="line-modified"> 947     JITCompiler::Call callOperationWithCallFrameRollbackOnException(V_JITOperation_Cb operation, CodeBlock* codeBlock)</span>




 948     {
<span class="line-modified"> 949         // Do not register CodeBlock* as a weak-pointer.</span>
<span class="line-modified"> 950         m_jit.setupArguments&lt;V_JITOperation_Cb&gt;(TrustedImmPtr(static_cast&lt;void*&gt;(codeBlock)));</span>







 951         return appendCallWithCallFrameRollbackOnException(operation);
 952     }
 953 
<span class="line-modified"> 954     JITCompiler::Call callOperationWithCallFrameRollbackOnException(Z_JITOperation_G operation, GPRReg result, JSGlobalObject* globalObject)</span>
 955     {
<span class="line-modified"> 956         m_jit.setupArguments&lt;Z_JITOperation_G&gt;(TrustedImmPtr::weakPointer(m_graph, globalObject));</span>
 957         return appendCallWithCallFrameRollbackOnExceptionSetResult(operation, result);
 958     }
 959 

 960     void prepareForExternalCall()
 961     {
<span class="line-added"> 962 #if !defined(NDEBUG) &amp;&amp; !CPU(ARM_THUMB2) &amp;&amp; !CPU(MIPS)</span>
 963         // We&#39;re about to call out to a &quot;native&quot; helper function. The helper
<span class="line-modified"> 964         // function is expected to set topCallFrame itself with the CallFrame</span>
 965         // that is passed to it.
 966         //
 967         // We explicitly trash topCallFrame here so that we&#39;ll know if some of
 968         // the helper functions are not setting topCallFrame when they should
 969         // be doing so. Note: the previous value in topcallFrame was not valid
 970         // anyway since it was not being updated by JIT&#39;ed code by design.
 971 
 972         for (unsigned i = 0; i &lt; sizeof(void*) / 4; i++)
 973             m_jit.store32(TrustedImm32(0xbadbeef), reinterpret_cast&lt;char*&gt;(&amp;vm().topCallFrame) + i * 4);



 974 #endif
<span class="line-added"> 975         m_jit.prepareCallOperation(vm());</span>
<span class="line-added"> 976     }</span>
 977 
 978     // These methods add call instructions, optionally setting results, and optionally rolling back the call frame on an exception.
 979     JITCompiler::Call appendCall(const FunctionPtr&lt;CFunctionPtrTag&gt; function)
 980     {
 981         prepareForExternalCall();
 982         m_jit.emitStoreCodeOrigin(m_currentNode-&gt;origin.semantic);
 983         return m_jit.appendCall(function);
 984     }
 985 
 986     JITCompiler::Call appendCallWithCallFrameRollbackOnException(const FunctionPtr&lt;CFunctionPtrTag&gt; function)
 987     {
 988         JITCompiler::Call call = appendCall(function);
 989         m_jit.exceptionCheckWithCallFrameRollback();
 990         return call;
 991     }
 992 
 993     JITCompiler::Call appendCallWithCallFrameRollbackOnExceptionSetResult(const FunctionPtr&lt;CFunctionPtrTag&gt; function, GPRReg result)
 994     {
 995         JITCompiler::Call call = appendCallWithCallFrameRollbackOnException(function);
 996         if ((result != InvalidGPRReg) &amp;&amp; (result != GPRInfo::returnValueGPR))
</pre>
<hr />
<pre>
1005             m_jit.move(GPRInfo::returnValueGPR, result);
1006         return call;
1007     }
1008 
1009     JITCompiler::Call appendCallSetResult(const FunctionPtr&lt;CFunctionPtrTag&gt; function, GPRReg result1, GPRReg result2)
1010     {
1011         JITCompiler::Call call = appendCall(function);
1012         m_jit.setupResults(result1, result2);
1013         return call;
1014     }
1015 
1016     JITCompiler::Call appendCallSetResult(const FunctionPtr&lt;CFunctionPtrTag&gt; function, JSValueRegs resultRegs)
1017     {
1018 #if USE(JSVALUE64)
1019         return appendCallSetResult(function, resultRegs.gpr());
1020 #else
1021         return appendCallSetResult(function, resultRegs.payloadGPR(), resultRegs.tagGPR());
1022 #endif
1023     }
1024 
<span class="line-modified">1025 #if CPU(ARM_THUMB2) &amp;&amp; !CPU(ARM_HARDFP)</span>










1026     JITCompiler::Call appendCallSetResult(const FunctionPtr&lt;CFunctionPtrTag&gt; function, FPRReg result)
1027     {
1028         JITCompiler::Call call = appendCall(function);
1029         if (result != InvalidFPRReg)
1030             m_jit.assembler().vmov(result, GPRInfo::returnValueGPR, GPRInfo::returnValueGPR2);
1031         return call;
1032     }
1033 #else // CPU(X86_64) || (CPU(ARM_THUMB2) &amp;&amp; CPU(ARM_HARDFP)) || CPU(ARM64) || CPU(MIPS)
1034     JITCompiler::Call appendCallSetResult(const FunctionPtr&lt;CFunctionPtrTag&gt; function, FPRReg result)
1035     {
1036         JITCompiler::Call call = appendCall(function);
1037         if (result != InvalidFPRReg)
1038             m_jit.moveDouble(FPRInfo::returnValueFPR, result);
1039         return call;
1040     }
1041 #endif
1042 
1043     void branchDouble(JITCompiler::DoubleCondition cond, FPRReg left, FPRReg right, BasicBlock* destination)
1044     {
1045         return addBranch(m_jit.branchDouble(cond, left, right), destination);
</pre>
<hr />
<pre>
1126 
1127     void addBranch(const MacroAssembler::Jump&amp; jump, BasicBlock* destination)
1128     {
1129         m_branches.append(BranchRecord(jump, destination));
1130     }
1131     void addBranch(const MacroAssembler::JumpList&amp; jump, BasicBlock* destination);
1132 
1133     void linkBranches();
1134 
1135     void dump(const char* label = 0);
1136 
1137     bool betterUseStrictInt52(Node* node)
1138     {
1139         return !generationInfo(node).isInt52();
1140     }
1141     bool betterUseStrictInt52(Edge edge)
1142     {
1143         return betterUseStrictInt52(edge.node());
1144     }
1145 
<span class="line-modified">1146     bool compare(Node*, MacroAssembler::RelationalCondition, MacroAssembler::DoubleCondition, S_JITOperation_GJJ);</span>
1147     void compileCompareUnsigned(Node*, MacroAssembler::RelationalCondition);
<span class="line-modified">1148     bool compilePeepHoleBranch(Node*, MacroAssembler::RelationalCondition, MacroAssembler::DoubleCondition, S_JITOperation_GJJ);</span>
1149     void compilePeepHoleInt32Branch(Node*, Node* branchNode, JITCompiler::RelationalCondition);
1150     void compilePeepHoleInt52Branch(Node*, Node* branchNode, JITCompiler::RelationalCondition);
1151     void compilePeepHoleBooleanBranch(Node*, Node* branchNode, JITCompiler::RelationalCondition);
1152     void compilePeepHoleDoubleBranch(Node*, Node* branchNode, JITCompiler::DoubleCondition);
1153     void compilePeepHoleObjectEquality(Node*, Node* branchNode);
1154     void compilePeepHoleObjectStrictEquality(Edge objectChild, Edge otherChild, Node* branchNode);
1155     void compilePeepHoleObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild, Node* branchNode);
1156     void compileObjectEquality(Node*);
1157     void compileObjectStrictEquality(Edge objectChild, Edge otherChild);
1158     void compileObjectToObjectOrOtherEquality(Edge leftChild, Edge rightChild);
1159     void compileObjectOrOtherLogicalNot(Edge value);
1160     void compileLogicalNot(Node*);
1161     void compileLogicalNotStringOrOther(Node*);
1162     void compileStringEquality(
1163         Node*, GPRReg leftGPR, GPRReg rightGPR, GPRReg lengthGPR,
1164         GPRReg leftTempGPR, GPRReg rightTempGPR, GPRReg leftTemp2GPR,
1165         GPRReg rightTemp2GPR, const JITCompiler::JumpList&amp; fastTrue,
1166         const JITCompiler::JumpList&amp; fastSlow);
1167     void compileStringEquality(Node*);
1168     void compileStringIdentEquality(Node*);
</pre>
<hr />
<pre>
1184     struct StringSwitchCase {
1185         StringSwitchCase() { }
1186 
1187         StringSwitchCase(StringImpl* string, BasicBlock* target)
1188             : string(string)
1189             , target(target)
1190         {
1191         }
1192 
1193         bool operator&lt;(const StringSwitchCase&amp; other) const
1194         {
1195             return stringLessThan(*string, *other.string);
1196         }
1197 
1198         StringImpl* string;
1199         BasicBlock* target;
1200     };
1201 
1202     void emitSwitchIntJump(SwitchData*, GPRReg value, GPRReg scratch);
1203     void emitSwitchImm(Node*, SwitchData*);
<span class="line-modified">1204     void emitSwitchCharStringJump(Node*, SwitchData*, GPRReg value, GPRReg scratch);</span>
1205     void emitSwitchChar(Node*, SwitchData*);
1206     void emitBinarySwitchStringRecurse(
1207         SwitchData*, const Vector&lt;StringSwitchCase&gt;&amp;, unsigned numChecked,
1208         unsigned begin, unsigned end, GPRReg buffer, GPRReg length, GPRReg temp,
1209         unsigned alreadyCheckedLength, bool checkedExactLength);
<span class="line-modified">1210     void emitSwitchStringOnString(Node*, SwitchData*, GPRReg string);</span>
1211     void emitSwitchString(Node*, SwitchData*);
1212     void emitSwitch(Node*);
1213 
1214     void compileToStringOrCallStringConstructorOrStringValueOf(Node*);
1215     void compileNumberToStringWithRadix(Node*);
1216     void compileNumberToStringWithValidRadixConstant(Node*);
1217     void compileNumberToStringWithValidRadixConstant(Node*, int32_t radix);
1218     void compileNewStringObject(Node*);
1219     void compileNewSymbol(Node*);
1220 
1221     void compileNewTypedArrayWithSize(Node*);
1222 
1223     void compileInt32Compare(Node*, MacroAssembler::RelationalCondition);
1224     void compileInt52Compare(Node*, MacroAssembler::RelationalCondition);
1225     void compileBooleanCompare(Node*, MacroAssembler::RelationalCondition);
1226     void compileDoubleCompare(Node*, MacroAssembler::DoubleCondition);
1227     void compileStringCompare(Node*, MacroAssembler::RelationalCondition);
1228     void compileStringIdentCompare(Node*, MacroAssembler::RelationalCondition);
1229 
1230     bool compileStrictEq(Node*);
</pre>
<hr />
<pre>
1265     GPRReg temporaryRegisterForPutByVal(GPRTemporary&amp; temporary, Node* node)
1266     {
1267         return temporaryRegisterForPutByVal(temporary, node-&gt;arrayMode());
1268     }
1269 
1270     void compileGetCharCodeAt(Node*);
1271     void compileGetByValOnString(Node*);
1272     void compileFromCharCode(Node*);
1273 
1274     void compileGetByValOnDirectArguments(Node*);
1275     void compileGetByValOnScopedArguments(Node*);
1276 
1277     void compileGetScope(Node*);
1278     void compileSkipScope(Node*);
1279     void compileGetGlobalObject(Node*);
1280     void compileGetGlobalThis(Node*);
1281 
1282     void compileGetArrayLength(Node*);
1283 
1284     void compileCheckTypeInfoFlags(Node*);
<span class="line-modified">1285     void compileCheckIdent(Node*);</span>
1286 
1287     void compileParseInt(Node*);
1288 
1289     void compileValueRep(Node*);
1290     void compileDoubleRep(Node*);
1291 
1292     void compileValueToInt32(Node*);
1293     void compileUInt32ToNumber(Node*);
1294     void compileDoubleAsInt32(Node*);
1295 
1296     void compileValueBitNot(Node*);
1297     void compileBitwiseNot(Node*);
1298 
<span class="line-modified">1299     template&lt;typename SnippetGenerator, J_JITOperation_GJJ slowPathFunction&gt;</span>
1300     void emitUntypedBitOp(Node*);
1301     void compileBitwiseOp(Node*);
1302     void compileValueBitwiseOp(Node*);
1303 
1304     void emitUntypedRightShiftBitOp(Node*);
1305     void compileValueLShiftOp(Node*);
<span class="line-added">1306     void compileValueBitRShift(Node*);</span>
1307     void compileShiftOp(Node*);
1308 
1309     template &lt;typename Generator, typename RepatchingFunction, typename NonRepatchingFunction&gt;
1310     void compileMathIC(Node*, JITBinaryMathIC&lt;Generator&gt;*, bool needsScratchGPRReg, bool needsScratchFPRReg, RepatchingFunction, NonRepatchingFunction);
1311     template &lt;typename Generator, typename RepatchingFunction, typename NonRepatchingFunction&gt;
1312     void compileMathIC(Node*, JITUnaryMathIC&lt;Generator&gt;*, bool needsScratchGPRReg, RepatchingFunction, NonRepatchingFunction);
1313 
<span class="line-modified">1314     void compileArithDoubleUnaryOp(Node*, double (*doubleFunction)(double), double (*operation)(JSGlobalObject*, EncodedJSValue));</span>
1315     void compileValueAdd(Node*);
1316     void compileValueSub(Node*);
1317     void compileArithAdd(Node*);
1318     void compileMakeRope(Node*);
1319     void compileArithAbs(Node*);
1320     void compileArithClz32(Node*);
1321     void compileArithSub(Node*);
<span class="line-added">1322     void compileIncOrDec(Node*);</span>
1323     void compileValueNegate(Node*);
1324     void compileArithNegate(Node*);
1325     void compileValueMul(Node*);
1326     void compileArithMul(Node*);
1327     void compileValueDiv(Node*);
1328     void compileArithDiv(Node*);
1329     void compileArithFRound(Node*);
1330     void compileValueMod(Node*);
1331     void compileArithMod(Node*);
1332     void compileArithPow(Node*);
1333     void compileValuePow(Node*);
1334     void compileArithRounding(Node*);
1335     void compileArithRandom(Node*);
1336     void compileArithUnary(Node*);
1337     void compileArithSqrt(Node*);
1338     void compileArithMinMax(Node*);
1339     void compileConstantStoragePointer(Node*);
1340     void compileGetIndexedPropertyStorage(Node*);
1341     JITCompiler::Jump jumpForTypedArrayOutOfBounds(Node*, GPRReg baseGPR, GPRReg indexGPR);
1342     JITCompiler::Jump jumpForTypedArrayIsNeuteredIfOutOfBounds(Node*, GPRReg baseGPR, JITCompiler::Jump outOfBounds);
</pre>
<hr />
<pre>
1353     void compileGetByValWithThis(Node*);
1354     void compileGetByOffset(Node*);
1355     void compilePutByOffset(Node*);
1356     void compileMatchStructure(Node*);
1357     // If this returns false it means that we terminated speculative execution.
1358     bool getIntTypedArrayStoreOperand(
1359         GPRTemporary&amp; value,
1360         GPRReg property,
1361 #if USE(JSVALUE32_64)
1362         GPRTemporary&amp; propertyTag,
1363         GPRTemporary&amp; valueTag,
1364 #endif
1365         Edge valueUse, JITCompiler::JumpList&amp; slowPathCases, bool isClamped = false);
1366     void loadFromIntTypedArray(GPRReg storageReg, GPRReg propertyReg, GPRReg resultReg, TypedArrayType);
1367     void setIntTypedArrayLoadResult(Node*, GPRReg resultReg, TypedArrayType, bool canSpeculate = false);
1368     template &lt;typename ClassType&gt; void compileNewFunctionCommon(GPRReg, RegisteredStructure, GPRReg, GPRReg, GPRReg, MacroAssembler::JumpList&amp;, size_t, FunctionExecutable*);
1369     void compileNewFunction(Node*);
1370     void compileSetFunctionName(Node*);
1371     void compileNewRegexp(Node*);
1372     void compileForwardVarargs(Node*);
<span class="line-added">1373     void compileVarargsLength(Node*);</span>
1374     void compileLoadVarargs(Node*);
1375     void compileCreateActivation(Node*);
1376     void compileCreateDirectArguments(Node*);
1377     void compileGetFromArguments(Node*);
1378     void compilePutToArguments(Node*);
1379     void compileGetArgument(Node*);
1380     void compileCreateScopedArguments(Node*);
1381     void compileCreateClonedArguments(Node*);
<span class="line-added">1382     void compileCreateArgumentsButterfly(Node*);</span>
1383     void compileCreateRest(Node*);
1384     void compileSpread(Node*);
1385     void compileNewArray(Node*);
1386     void compileNewArrayWithSpread(Node*);
1387     void compileGetRestLength(Node*);
1388     void compileArraySlice(Node*);
1389     void compileArrayIndexOf(Node*);
1390     void compileArrayPush(Node*);
1391     void compileNotifyWrite(Node*);
1392     void compileRegExpExec(Node*);
1393     void compileRegExpExecNonGlobalOrSticky(Node*);
1394     void compileRegExpMatchFast(Node*);
1395     void compileRegExpMatchFastGlobal(Node*);
1396     void compileRegExpTest(Node*);
1397     void compileStringReplace(Node*);
1398     void compileIsObject(Node*);
1399     void compileIsObjectOrNull(Node*);
1400     void compileIsFunction(Node*);
1401     void compileTypeOf(Node*);
1402     void compileCheckCell(Node*);
1403     void compileCheckNotEmpty(Node*);
1404     void compileCheckStructure(Node*);
1405     void emitStructureCheck(Node*, GPRReg cellGPR, GPRReg tempGPR);
1406     void compilePutAccessorById(Node*);
1407     void compilePutGetterSetterById(Node*);
1408     void compilePutAccessorByVal(Node*);
1409     void compileGetRegExpObjectLastIndex(Node*);
1410     void compileSetRegExpObjectLastIndex(Node*);
1411     void compileLazyJSConstant(Node*);
1412     void compileMaterializeNewObject(Node*);
1413     void compileRecordRegExpCachedResult(Node*);
1414     void compileToObjectOrCallObjectConstructor(Node*);
1415     void compileResolveScope(Node*);
1416     void compileResolveScopeForHoistingFuncDeclInEval(Node*);
1417     void compileGetGlobalVariable(Node*);
1418     void compilePutGlobalVariable(Node*);
1419     void compileGetDynamicVar(Node*);
1420     void compilePutDynamicVar(Node*);
1421     void compileGetClosureVar(Node*);
1422     void compilePutClosureVar(Node*);
<span class="line-added">1423     void compileGetInternalField(Node*);</span>
<span class="line-added">1424     void compilePutInternalField(Node*);</span>
1425     void compileCompareEqPtr(Node*);
1426     void compileDefineDataProperty(Node*);
1427     void compileDefineAccessorProperty(Node*);
1428     void compileStringSlice(Node*);
1429     void compileToLowerCase(Node*);
1430     void compileThrow(Node*);
1431     void compileThrowStaticError(Node*);
1432     void compileGetEnumerableLength(Node*);
1433     void compileHasGenericProperty(Node*);
1434     void compileToIndexString(Node*);
1435     void compilePutByIdFlush(Node*);
1436     void compilePutById(Node*);
1437     void compilePutByIdDirect(Node*);
1438     void compilePutByIdWithThis(Node*);
1439     void compileHasStructureProperty(Node*);
1440     void compileGetDirectPname(Node*);
1441     void compileGetPropertyEnumerator(Node*);
1442     void compileGetEnumeratorPname(Node*);
1443     void compileGetExecutable(Node*);
1444     void compileGetGetter(Node*);
1445     void compileGetSetter(Node*);
1446     void compileGetCallee(Node*);
1447     void compileSetCallee(Node*);
1448     void compileGetArgumentCountIncludingThis(Node*);
1449     void compileSetArgumentCountIncludingThis(Node*);
1450     void compileStrCat(Node*);
1451     void compileNewArrayBuffer(Node*);
1452     void compileNewArrayWithSize(Node*);
1453     void compileNewTypedArray(Node*);
1454     void compileToThis(Node*);
1455     void compileObjectKeys(Node*);
1456     void compileObjectCreate(Node*);
1457     void compileCreateThis(Node*);
<span class="line-added">1458     void compileCreatePromise(Node*);</span>
<span class="line-added">1459     void compileCreateGenerator(Node*);</span>
<span class="line-added">1460     void compileCreateAsyncGenerator(Node*);</span>
1461     void compileNewObject(Node*);
<span class="line-added">1462     void compileNewPromise(Node*);</span>
<span class="line-added">1463     void compileNewGenerator(Node*);</span>
<span class="line-added">1464     void compileNewAsyncGenerator(Node*);</span>
<span class="line-added">1465     void compileNewArrayIterator(Node*);</span>
1466     void compileToPrimitive(Node*);
<span class="line-added">1467     void compileToPropertyKey(Node*);</span>
<span class="line-added">1468     void compileToNumeric(Node*);</span>
1469     void compileLogShadowChickenPrologue(Node*);
1470     void compileLogShadowChickenTail(Node*);
1471     void compileHasIndexedProperty(Node*);
1472     void compileExtractCatchLocal(Node*);
1473     void compileClearCatchLocals(Node*);
1474     void compileProfileType(Node*);
<span class="line-added">1475     void compileStringCodePointAt(Node*);</span>
<span class="line-added">1476     void compileDateGet(Node*);</span>
<span class="line-added">1477 </span>
<span class="line-added">1478     template&lt;typename JSClass, typename Operation&gt;</span>
<span class="line-added">1479     void compileCreateInternalFieldObject(Node*, Operation);</span>
<span class="line-added">1480     template&lt;typename JSClass, typename Operation&gt;</span>
<span class="line-added">1481     void compileNewInternalFieldObject(Node*, Operation);</span>
1482 
1483     void moveTrueTo(GPRReg);
1484     void moveFalseTo(GPRReg);
1485     void blessBoolean(GPRReg);
1486 
1487     // Allocator for a cell of a specific size.
1488     template &lt;typename StructureType&gt; // StructureType can be GPR or ImmPtr.
1489     void emitAllocateJSCell(
1490         GPRReg resultGPR, const JITAllocator&amp; allocator, GPRReg allocatorGPR, StructureType structure,
1491         GPRReg scratchGPR, MacroAssembler::JumpList&amp; slowPath)
1492     {
1493         m_jit.emitAllocateJSCell(resultGPR, allocator, allocatorGPR, structure, scratchGPR, slowPath);
1494     }
1495 
1496     // Allocator for an object of a specific size.
1497     template &lt;typename StructureType, typename StorageType&gt; // StructureType and StorageType can be GPR or ImmPtr.
1498     void emitAllocateJSObject(
1499         GPRReg resultGPR, const JITAllocator&amp; allocator, GPRReg allocatorGPR, StructureType structure,
1500         StorageType storage, GPRReg scratchGPR, MacroAssembler::JumpList&amp; slowPath)
1501     {
</pre>
<hr />
<pre>
1578     void speculateAnyInt(Edge);
1579     void speculateInt32(Edge, JSValueRegs);
1580     void speculateDoubleRepAnyInt(Edge);
1581 #endif // USE(JSVALUE64)
1582     void speculateNumber(Edge);
1583     void speculateRealNumber(Edge);
1584     void speculateDoubleRepReal(Edge);
1585     void speculateBoolean(Edge);
1586     void speculateCell(Edge);
1587     void speculateCellOrOther(Edge);
1588     void speculateObject(Edge, GPRReg cell);
1589     void speculateObject(Edge);
1590     void speculateArray(Edge, GPRReg cell);
1591     void speculateArray(Edge);
1592     void speculateFunction(Edge, GPRReg cell);
1593     void speculateFunction(Edge);
1594     void speculateFinalObject(Edge, GPRReg cell);
1595     void speculateFinalObject(Edge);
1596     void speculateRegExpObject(Edge, GPRReg cell);
1597     void speculateRegExpObject(Edge);
<span class="line-added">1598     void speculatePromiseObject(Edge);</span>
<span class="line-added">1599     void speculatePromiseObject(Edge, GPRReg cell);</span>
1600     void speculateProxyObject(Edge, GPRReg cell);
1601     void speculateProxyObject(Edge);
1602     void speculateDerivedArray(Edge, GPRReg cell);
1603     void speculateDerivedArray(Edge);
<span class="line-added">1604     void speculateDateObject(Edge);</span>
<span class="line-added">1605     void speculateDateObject(Edge, GPRReg cell);</span>
1606     void speculateMapObject(Edge);
1607     void speculateMapObject(Edge, GPRReg cell);
1608     void speculateSetObject(Edge);
1609     void speculateSetObject(Edge, GPRReg cell);
1610     void speculateWeakMapObject(Edge);
1611     void speculateWeakMapObject(Edge, GPRReg cell);
1612     void speculateWeakSetObject(Edge);
1613     void speculateWeakSetObject(Edge, GPRReg cell);
1614     void speculateDataViewObject(Edge);
1615     void speculateDataViewObject(Edge, GPRReg cell);
1616     void speculateObjectOrOther(Edge);
1617     void speculateString(Edge edge, GPRReg cell);
1618     void speculateStringIdentAndLoadStorage(Edge edge, GPRReg string, GPRReg storage);
1619     void speculateStringIdent(Edge edge, GPRReg string);
1620     void speculateStringIdent(Edge);
1621     void speculateString(Edge);
1622     void speculateStringOrOther(Edge, JSValueRegs, GPRReg scratch);
1623     void speculateStringOrOther(Edge);
1624     void speculateNotStringVar(Edge);
1625     void speculateNotSymbol(Edge);
</pre>
<hr />
<pre>
1633     void speculateNotCell(Edge, JSValueRegs);
1634     void speculateNotCell(Edge);
1635     void speculateOther(Edge, JSValueRegs, GPRReg temp);
1636     void speculateOther(Edge, JSValueRegs);
1637     void speculateOther(Edge);
1638     void speculateMisc(Edge, JSValueRegs);
1639     void speculateMisc(Edge);
1640     void speculate(Node*, Edge);
1641 
1642     JITCompiler::JumpList jumpSlowForUnwantedArrayMode(GPRReg tempWithIndexingTypeReg, ArrayMode);
1643     void checkArray(Node*);
1644     void arrayify(Node*, GPRReg baseReg, GPRReg propertyReg);
1645     void arrayify(Node*);
1646 
1647     template&lt;bool strict&gt;
1648     GPRReg fillSpeculateInt32Internal(Edge, DataFormat&amp; returnFormat);
1649 
1650     void cageTypedArrayStorage(GPRReg, GPRReg);
1651 
1652     void recordSetLocal(
<span class="line-modified">1653         Operand bytecodeReg, VirtualRegister machineReg, DataFormat format)</span>
1654     {
<span class="line-added">1655         ASSERT(!bytecodeReg.isArgument() || bytecodeReg.virtualRegister().toArgument() &gt;= 0);</span>
1656         m_stream-&gt;appendAndLog(VariableEvent::setLocal(bytecodeReg, machineReg, format));
1657     }
1658 
1659     void recordSetLocal(DataFormat format)
1660     {
1661         VariableAccessData* variable = m_currentNode-&gt;variableAccessData();
<span class="line-modified">1662         recordSetLocal(variable-&gt;operand(), variable-&gt;machineLocal(), format);</span>
1663     }
1664 
1665     GenerationInfo&amp; generationInfoFromVirtualRegister(VirtualRegister virtualRegister)
1666     {
1667         return m_generationInfo[virtualRegister.toLocal()];
1668     }
1669 
1670     GenerationInfo&amp; generationInfo(Node* node)
1671     {
1672         return generationInfoFromVirtualRegister(node-&gt;virtualRegister());
1673     }
1674 
1675     GenerationInfo&amp; generationInfo(Edge edge)
1676     {
1677         return generationInfo(edge.node());
1678     }
1679 
1680     // The JIT, while also provides MacroAssembler functionality.
1681     JITCompiler&amp; m_jit;
1682     Graph&amp; m_graph;
</pre>
</td>
</tr>
</table>
<center><a href="DFGSpeculativeJIT.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGSpeculativeJIT32_64.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
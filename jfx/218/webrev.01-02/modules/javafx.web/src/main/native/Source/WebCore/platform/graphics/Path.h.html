<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/Path.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2003, 2006, 2009, 2016 Apple Inc. All rights reserved.
  3  * Copyright (C) 2006 Rob Buis &lt;buis@kde.org&gt;
  4  * Copyright (C) 2007-2008 Torch Mobile, Inc.
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 17  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 19  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 20  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 21  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 22  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 23  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 24  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 25  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 26  */
 27 
 28 #ifndef Path_h
 29 #define Path_h
 30 
 31 #include &quot;FloatRect.h&quot;
 32 #include &quot;WindRule.h&quot;
 33 #include &lt;wtf/FastMalloc.h&gt;
 34 #include &lt;wtf/Function.h&gt;
 35 #include &lt;wtf/Forward.h&gt;
 36 
 37 #if USE(CG)
 38 
 39 #include &lt;wtf/RetainPtr.h&gt;
 40 #include &lt;CoreGraphics/CGPath.h&gt;
 41 typedef struct CGPath PlatformPath;
 42 
 43 #elif USE(DIRECT2D)
 44 #include &quot;COMPtr.h&quot;
 45 
 46 interface ID2D1Geometry;
 47 interface ID2D1GeometryGroup;
 48 interface ID2D1PathGeometry;
 49 interface ID2D1GeometrySink;
 50 
 51 typedef ID2D1GeometryGroup PlatformPath;
 52 
 53 namespace WebCore {
 54 class PlatformContextDirect2D;
 55 }
 56 
 57 #elif USE(CAIRO)
 58 
 59 namespace WebCore {
 60 class CairoPath;
 61 }
 62 typedef WebCore::CairoPath PlatformPath;
 63 
 64 #elif USE(WINGDI)
 65 
 66 namespace WebCore {
 67 class PlatformPath;
 68 }
 69 typedef WebCore::PlatformPath PlatformPath;
 70 
 71 #elif PLATFORM(JAVA)
 72 #include &lt;wtf/RefPtr.h&gt;
 73 #include &quot;RQRef.h&quot;
 74 typedef RefPtr&lt;WebCore::RQRef&gt; PlatformPath;
 75 
 76 #else
 77 
 78 typedef void PlatformPath;
 79 
 80 #endif
 81 
 82 #if PLATFORM(JAVA)
 83 typedef RefPtr&lt;WebCore::RQRef&gt; PlatformPathPtr;
 84 #else
 85 typedef PlatformPath* PlatformPathPtr;
 86 #endif
 87 
 88 namespace WTF {
 89 class TextStream;
 90 }
 91 
 92 namespace WebCore {
 93 
 94 class AffineTransform;
 95 class FloatPoint;
 96 class FloatRoundedRect;
 97 class FloatSize;
 98 class GraphicsContext;
 99 class PathTraversalState;
100 class RoundedRect;
101 class StrokeStyleApplier;
102 
103 // The points in the structure are the same as those that would be used with the
104 // add... method. For example, a line returns the endpoint, while a cubic returns
105 // two tangent points and the endpoint.
106 struct PathElement {
107     enum class Type : uint8_t {
108         MoveToPoint, // The points member will contain 1 value.
109         AddLineToPoint, // The points member will contain 1 value.
110         AddQuadCurveToPoint, // The points member will contain 2 values.
111         AddCurveToPoint, // The points member will contain 3 values.
112         CloseSubpath // The points member will contain no values.
113     };
114 
115     FloatPoint points[3];
116     Type type;
117 };
118 
119 using PathApplierFunction = WTF::Function&lt;void(const PathElement&amp;)&gt;;
120 
121 class Path {
122     WTF_MAKE_FAST_ALLOCATED;
123 public:
124     WEBCORE_EXPORT Path();
125 #if USE(CG)
126     Path(RetainPtr&lt;CGMutablePathRef&gt;);
127 #endif
128     WEBCORE_EXPORT ~Path();
129 
130     WEBCORE_EXPORT Path(const Path&amp;);
131     WEBCORE_EXPORT Path(Path&amp;&amp;);
132     WEBCORE_EXPORT Path&amp; operator=(const Path&amp;);
133     WEBCORE_EXPORT Path&amp; operator=(Path&amp;&amp;);
134 
135     static Path polygonPathFromPoints(const Vector&lt;FloatPoint&gt;&amp;);
136 
137     bool contains(const FloatPoint&amp;, WindRule = WindRule::NonZero) const;
138     bool strokeContains(StrokeStyleApplier&amp;, const FloatPoint&amp;) const;
139     // fastBoundingRect() should equal or contain boundingRect(); boundingRect()
140     // should perfectly bound the points within the path.
141     FloatRect boundingRect() const;
142     WEBCORE_EXPORT FloatRect fastBoundingRect() const;
143     FloatRect strokeBoundingRect(StrokeStyleApplier* = 0) const;
144 
145     float length() const;
146     PathTraversalState traversalStateAtLength(float length) const;
147     FloatPoint pointAtLength(float length) const;
148 
149     WEBCORE_EXPORT void clear();
150     bool isNull() const { return !m_path; }
151     bool isEmpty() const;
152     // Gets the current point of the current path, which is conceptually the final point reached by the path so far.
153     // Note the Path can be empty (isEmpty() == true) and still have a current point.
154     bool hasCurrentPoint() const;
155     FloatPoint currentPoint() const;
156 
157     WEBCORE_EXPORT void moveTo(const FloatPoint&amp;);
158     WEBCORE_EXPORT void addLineTo(const FloatPoint&amp;);
159     WEBCORE_EXPORT void addQuadCurveTo(const FloatPoint&amp; controlPoint, const FloatPoint&amp; endPoint);
160     WEBCORE_EXPORT void addBezierCurveTo(const FloatPoint&amp; controlPoint1, const FloatPoint&amp; controlPoint2, const FloatPoint&amp; endPoint);
161     void addArcTo(const FloatPoint&amp;, const FloatPoint&amp;, float radius);
162     WEBCORE_EXPORT void closeSubpath();
163 
164     void addArc(const FloatPoint&amp;, float radius, float startAngle, float endAngle, bool anticlockwise);
165     void addRect(const FloatRect&amp;);
166     void addEllipse(FloatPoint, float radiusX, float radiusY, float rotation, float startAngle, float endAngle, bool anticlockwise);
167     void addEllipse(const FloatRect&amp;);
168 
169     enum class RoundedRectStrategy : uint8_t {
170         PreferNative,
171         PreferBezier
172     };
173 
174     WEBCORE_EXPORT void addRoundedRect(const FloatRect&amp;, const FloatSize&amp; roundingRadii, RoundedRectStrategy = RoundedRectStrategy::PreferNative);
175     WEBCORE_EXPORT void addRoundedRect(const FloatRoundedRect&amp;, RoundedRectStrategy = RoundedRectStrategy::PreferNative);
176     void addRoundedRect(const RoundedRect&amp;);
177 
178     void addPath(const Path&amp;, const AffineTransform&amp;);
179 
180     void translate(const FloatSize&amp;);
181 
182     // To keep Path() cheap, it does not allocate a PlatformPath immediately
183     // meaning Path::platformPath() can return null.
184 #if USE(DIRECT2D)
185     FloatRect fastBoundingRectForStroke(const PlatformContextDirect2D&amp;) const;
186     PlatformPathPtr platformPath() const { return m_path.get(); }
187 #else
188     PlatformPathPtr platformPath() const { return m_path; }
189 #endif
190     // ensurePlatformPath() will allocate a PlatformPath if it has not yet been and will never return null.
191     WEBCORE_EXPORT PlatformPathPtr ensurePlatformPath();
192 
193     WEBCORE_EXPORT void apply(const PathApplierFunction&amp;) const;
194     void transform(const AffineTransform&amp;);
195 
196     static float circleControlPoint()
197     {
198         // Approximation of control point positions on a bezier to simulate a quarter of a circle.
199         // This is 1-kappa, where kappa = 4 * (sqrt(2) - 1) / 3
200         return 0.447715;
201     }
202 
203     void addBeziersForRoundedRect(const FloatRect&amp;, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius);
204 
205 #if USE(CG) || USE(DIRECT2D)
206     void platformAddPathForRoundedRect(const FloatRect&amp;, const FloatSize&amp; topLeftRadius, const FloatSize&amp; topRightRadius, const FloatSize&amp; bottomLeftRadius, const FloatSize&amp; bottomRightRadius);
207 #endif
208 
209 #if USE(DIRECT2D)
210     void appendGeometry(ID2D1Geometry*);
211     void createGeometryWithFillMode(WindRule, COMPtr&lt;ID2D1GeometryGroup&gt;&amp;) const;
212 
213     void openFigureAtCurrentPointIfNecessary();
214     void closeAnyOpenGeometries(unsigned figureEndStyle) const;
215     void clearGeometries();
216 #endif
217 
218 #ifndef NDEBUG
219     void dump() const;
220 #endif
221 
222     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
223     template&lt;class Decoder&gt; static Optional&lt;Path&gt; decode(Decoder&amp;);
224 
225 private:
226 #if USE(DIRECT2D)
227     Vector&lt;ID2D1Geometry*&gt; m_geometries;
228     COMPtr&lt;ID2D1GeometryGroup&gt; m_path;
229     mutable COMPtr&lt;ID2D1GeometrySink&gt; m_activePath;
230     mutable bool m_figureIsOpened { false };
231 #else
232     PlatformPathPtr m_path { nullptr };
233 #endif
234 };
235 
236 WTF::TextStream&amp; operator&lt;&lt;(WTF::TextStream&amp;, const Path&amp;);
237 
238 template&lt;class Encoder&gt; void Path::encode(Encoder&amp; encoder) const
239 {
240     uint64_t numPoints = 0;
241     apply([&amp;numPoints](const PathElement&amp;) {
242         ++numPoints;
243     });
244 
245     encoder &lt;&lt; numPoints;
246 
247     apply([&amp;](auto&amp; element) {
248         encoder.encodeEnum(element.type);
249 
250         switch (element.type) {
251         case PathElement::Type::MoveToPoint:
252             encoder &lt;&lt; element.points[0];
253             break;
254         case PathElement::Type::AddLineToPoint:
255             encoder &lt;&lt; element.points[0];
256             break;
257         case PathElement::Type::AddQuadCurveToPoint:
258             encoder &lt;&lt; element.points[0];
259             encoder &lt;&lt; element.points[1];
260             break;
261         case PathElement::Type::AddCurveToPoint:
262             encoder &lt;&lt; element.points[0];
263             encoder &lt;&lt; element.points[1];
264             encoder &lt;&lt; element.points[2];
265             break;
266         case PathElement::Type::CloseSubpath:
267             break;
268         }
269     });
270 }
271 
272 template&lt;class Decoder&gt; Optional&lt;Path&gt; Path::decode(Decoder&amp; decoder)
273 {
274     Path path;
275     uint64_t numPoints;
276     if (!decoder.decode(numPoints))
277         return WTF::nullopt;
278 
279     path.clear();
280 
281     for (uint64_t i = 0; i &lt; numPoints; ++i) {
282         PathElement::Type elementType;
283         if (!decoder.decodeEnum(elementType))
284             return WTF::nullopt;
285 
286         switch (elementType) {
287         case PathElement::Type::MoveToPoint: {
288             FloatPoint point;
289             if (!decoder.decode(point))
290                 return WTF::nullopt;
291             path.moveTo(point);
292             break;
293         }
294         case PathElement::Type::AddLineToPoint: {
295             FloatPoint point;
296             if (!decoder.decode(point))
297                 return WTF::nullopt;
298             path.addLineTo(point);
299             break;
300         }
301         case PathElement::Type::AddQuadCurveToPoint: {
302             FloatPoint controlPoint;
303             if (!decoder.decode(controlPoint))
304                 return WTF::nullopt;
305 
306             FloatPoint endPoint;
307             if (!decoder.decode(endPoint))
308                 return WTF::nullopt;
309 
310             path.addQuadCurveTo(controlPoint, endPoint);
311             break;
312         }
313         case PathElement::Type::AddCurveToPoint: {
314             FloatPoint controlPoint1;
315             if (!decoder.decode(controlPoint1))
316                 return WTF::nullopt;
317 
318             FloatPoint controlPoint2;
319             if (!decoder.decode(controlPoint2))
320                 return WTF::nullopt;
321 
322             FloatPoint endPoint;
323             if (!decoder.decode(endPoint))
324                 return WTF::nullopt;
325 
326             path.addBezierCurveTo(controlPoint1, controlPoint2, endPoint);
327             break;
328         }
329         case PathElement::Type::CloseSubpath:
330             path.closeSubpath();
331             break;
332         }
333     }
334 
335     return path;
336 }
337 
338 }
339 
340 #endif
    </pre>
  </body>
</html>
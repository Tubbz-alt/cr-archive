<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCache.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Font.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FontCache.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCache.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 56 
 57 
 58 namespace WebCore {
 59 using namespace WTF;
 60 
 61 FontCache&amp; FontCache::singleton()
 62 {
 63     static NeverDestroyed&lt;FontCache&gt; globalFontCache;
 64     return globalFontCache;
 65 }
 66 
 67 FontCache::FontCache()
 68     : m_purgeTimer(*this, &amp;FontCache::purgeInactiveFontDataIfNeeded)
 69 {
 70 }
 71 
 72 struct FontPlatformDataCacheKey {
 73     WTF_MAKE_FAST_ALLOCATED;
 74 public:
 75     FontPlatformDataCacheKey() { }
<span class="line-modified"> 76     FontPlatformDataCacheKey(const AtomString&amp; family, const FontDescription&amp; description, const FontFeatureSettings* fontFaceFeatures, const FontVariantSettings* fontFaceVariantSettings, FontSelectionSpecifiedCapabilities fontFaceCapabilities)</span>
 77         : m_fontDescriptionKey(description)
 78         , m_family(family)
 79         , m_fontFaceFeatures(fontFaceFeatures ? *fontFaceFeatures : FontFeatureSettings())
<span class="line-removed"> 80         , m_fontFaceVariantSettings(fontFaceVariantSettings ? *fontFaceVariantSettings : FontVariantSettings())</span>
 81         , m_fontFaceCapabilities(fontFaceCapabilities)
 82     { }
 83 
 84     explicit FontPlatformDataCacheKey(HashTableDeletedValueType t)
 85         : m_fontDescriptionKey(t)
 86     { }
 87 
 88     bool isHashTableDeletedValue() const { return m_fontDescriptionKey.isHashTableDeletedValue(); }
 89 
 90     bool operator==(const FontPlatformDataCacheKey&amp; other) const
 91     {
 92         if (m_fontDescriptionKey != other.m_fontDescriptionKey
 93             || m_fontFaceFeatures != other.m_fontFaceFeatures
<span class="line-removed"> 94             || m_fontFaceVariantSettings != other.m_fontFaceVariantSettings</span>
 95             || m_fontFaceCapabilities != other.m_fontFaceCapabilities)
 96             return false;
 97         if (m_family.impl() == other.m_family.impl())
 98             return true;
 99         if (m_family.isNull() || other.m_family.isNull())
100             return false;
101         return FontCascadeDescription::familyNamesAreEqual(m_family, other.m_family);
102     }
103 
104     FontDescriptionKey m_fontDescriptionKey;
105     AtomString m_family;
106     FontFeatureSettings m_fontFaceFeatures;
<span class="line-removed">107     FontVariantSettings m_fontFaceVariantSettings;</span>
108     FontSelectionSpecifiedCapabilities m_fontFaceCapabilities;
109 };
110 
111 struct FontPlatformDataCacheKeyHash {
112     static unsigned hash(const FontPlatformDataCacheKey&amp; fontKey)
113     {
114         IntegerHasher hasher;
115         hasher.add(FontCascadeDescription::familyNameHash(fontKey.m_family));
116         hasher.add(fontKey.m_fontDescriptionKey.computeHash());
117         hasher.add(fontKey.m_fontFaceFeatures.hash());
<span class="line-removed">118         hasher.add(fontKey.m_fontFaceVariantSettings.uniqueValue());</span>
119         if (auto weight = fontKey.m_fontFaceCapabilities.weight)
120             hasher.add(weight-&gt;uniqueValue());
121         else
122             hasher.add(std::numeric_limits&lt;unsigned&gt;::max());
123         if (auto width = fontKey.m_fontFaceCapabilities.weight)
124             hasher.add(width-&gt;uniqueValue());
125         else
126             hasher.add(std::numeric_limits&lt;unsigned&gt;::max());
127         if (auto slope = fontKey.m_fontFaceCapabilities.weight)
128             hasher.add(slope-&gt;uniqueValue());
129         else
130             hasher.add(std::numeric_limits&lt;unsigned&gt;::max());
131         return hasher.hash();
132     }
133 
134     static bool equal(const FontPlatformDataCacheKey&amp; a, const FontPlatformDataCacheKey&amp; b)
135     {
136         return a == b;
137     }
138 
</pre>
<hr />
<pre>
183     // On Windows, Courier New is a TrueType font that is always present and
184     // Courier is a bitmap font that we do not support. So, we don&#39;t want to map
185     // Courier New to Courier.
186     // FIXME: Not sure why this is harmful on Windows, since the alternative will
187     // only be tried if Courier New is not found.
188     case 11:
189         if (equalLettersIgnoringASCIICase(familyName, &quot;courier new&quot;))
190             return courier;
191         break;
192 #endif
193     case 15:
194         if (equalLettersIgnoringASCIICase(familyName, &quot;times new roman&quot;))
195             return times;
196         break;
197     }
198 
199     return nullAtom();
200 }
201 
202 FontPlatformData* FontCache::getCachedFontPlatformData(const FontDescription&amp; fontDescription, const AtomString&amp; passedFamilyName,
<span class="line-modified">203     const FontFeatureSettings* fontFaceFeatures, const FontVariantSettings* fontFaceVariantSettings, FontSelectionSpecifiedCapabilities fontFaceCapabilities, bool checkingAlternateName)</span>
204 {
205 #if PLATFORM(IOS_FAMILY)
206     auto locker = holdLock(fontLock);
207 #endif
208 
209 #if OS(WINDOWS) &amp;&amp; ENABLE(OPENTYPE_VERTICAL)
210     // Leading &quot;@&quot; in the font name enables Windows vertical flow flag for the font.
211     // Because we do vertical flow by ourselves, we don&#39;t want to use the Windows feature.
212     // IE disregards &quot;@&quot; regardless of the orientatoin, so we follow the behavior.
213     const AtomString&amp; familyName = (passedFamilyName.isEmpty() || passedFamilyName[0] != &#39;@&#39;) ?
214         passedFamilyName : AtomString(passedFamilyName.impl()-&gt;substring(1));
215 #else
216     const AtomString&amp; familyName = passedFamilyName;
217 #endif
218 
219     static bool initialized;
220     if (!initialized) {
221         platformInit();
222         initialized = true;
223     }
224 
<span class="line-modified">225     FontPlatformDataCacheKey key(familyName, fontDescription, fontFaceFeatures, fontFaceVariantSettings, fontFaceCapabilities);</span>
226 
227     auto addResult = fontPlatformDataCache().add(key, nullptr);
228     FontPlatformDataCache::iterator it = addResult.iterator;
229     if (addResult.isNewEntry) {
<span class="line-modified">230         it-&gt;value = createFontPlatformData(fontDescription, familyName, fontFaceFeatures, fontFaceVariantSettings, fontFaceCapabilities);</span>
231 
232         if (!it-&gt;value &amp;&amp; !checkingAlternateName) {
233             // We were unable to find a font.  We have a small set of fonts that we alias to other names,
234             // e.g., Arial/Helvetica, Courier/Courier New, etc.  Try looking up the font under the aliased name.
235             const AtomString&amp; alternateName = alternateFamilyName(familyName);
236             if (!alternateName.isNull()) {
<span class="line-modified">237                 FontPlatformData* fontPlatformDataForAlternateName = getCachedFontPlatformData(fontDescription, alternateName, fontFaceFeatures, fontFaceVariantSettings, fontFaceCapabilities, true);</span>
238                 // Lookup the key in the hash table again as the previous iterator may have
239                 // been invalidated by the recursive call to getCachedFontPlatformData().
240                 it = fontPlatformDataCache().find(key);
241                 ASSERT(it != fontPlatformDataCache().end());
242                 if (fontPlatformDataForAlternateName)
243                     it-&gt;value = makeUnique&lt;FontPlatformData&gt;(*fontPlatformDataForAlternateName);
244             }
245         }
246     }
247 
248     return it-&gt;value.get();
249 }
250 
251 struct FontDataCacheKeyHash {
252     static unsigned hash(const FontPlatformData&amp; platformData)
253     {
254         return platformData.hash();
255     }
256 
257     static bool equal(const FontPlatformData&amp; a, const FontPlatformData&amp; b)
</pre>
<hr />
<pre>
299 RefPtr&lt;OpenTypeVerticalData&gt; FontCache::verticalData(const FontPlatformData&amp; platformData)
300 {
301     auto addResult = fontVerticalDataCache().ensure(platformData, [&amp;platformData] {
302         return OpenTypeVerticalData::create(platformData);
303     });
304     return addResult.iterator-&gt;value;
305 }
306 #endif
307 
308 #if PLATFORM(IOS_FAMILY)
309 const unsigned cMaxInactiveFontData = 120;
310 const unsigned cTargetInactiveFontData = 100;
311 #else
312 const unsigned cMaxInactiveFontData = 225;
313 const unsigned cTargetInactiveFontData = 200;
314 #endif
315 
316 const unsigned cMaxUnderMemoryPressureInactiveFontData = 50;
317 const unsigned cTargetUnderMemoryPressureInactiveFontData = 30;
318 
<span class="line-modified">319 RefPtr&lt;Font&gt; FontCache::fontForFamily(const FontDescription&amp; fontDescription, const AtomString&amp; family, const FontFeatureSettings* fontFaceFeatures, const FontVariantSettings* fontFaceVariantSettings, FontSelectionSpecifiedCapabilities fontFaceCapabilities, bool checkingAlternateName)</span>
320 {
321     if (!m_purgeTimer.isActive())
322         m_purgeTimer.startOneShot(0_s);
323 
<span class="line-modified">324     if (auto* platformData = getCachedFontPlatformData(fontDescription, family, fontFaceFeatures, fontFaceVariantSettings, fontFaceCapabilities, checkingAlternateName))</span>
325         return fontForPlatformData(*platformData);
326 
327     return nullptr;
328 }
329 
330 Ref&lt;Font&gt; FontCache::fontForPlatformData(const FontPlatformData&amp; platformData)
331 {
332 #if PLATFORM(IOS_FAMILY)
333     auto locker = holdLock(fontLock);
334 #endif
335 
336     auto addResult = cachedFonts().ensure(platformData, [&amp;] {
337         return Font::create(platformData);
338     });
339 
340     ASSERT(addResult.iterator-&gt;value-&gt;platformData() == platformData);
341 
342     return addResult.iterator-&gt;value.copyRef();
343 }
344 
</pre>
</td>
<td>
<hr />
<pre>
 56 
 57 
 58 namespace WebCore {
 59 using namespace WTF;
 60 
 61 FontCache&amp; FontCache::singleton()
 62 {
 63     static NeverDestroyed&lt;FontCache&gt; globalFontCache;
 64     return globalFontCache;
 65 }
 66 
 67 FontCache::FontCache()
 68     : m_purgeTimer(*this, &amp;FontCache::purgeInactiveFontDataIfNeeded)
 69 {
 70 }
 71 
 72 struct FontPlatformDataCacheKey {
 73     WTF_MAKE_FAST_ALLOCATED;
 74 public:
 75     FontPlatformDataCacheKey() { }
<span class="line-modified"> 76     FontPlatformDataCacheKey(const AtomString&amp; family, const FontDescription&amp; description, const FontFeatureSettings* fontFaceFeatures, FontSelectionSpecifiedCapabilities fontFaceCapabilities)</span>
 77         : m_fontDescriptionKey(description)
 78         , m_family(family)
 79         , m_fontFaceFeatures(fontFaceFeatures ? *fontFaceFeatures : FontFeatureSettings())

 80         , m_fontFaceCapabilities(fontFaceCapabilities)
 81     { }
 82 
 83     explicit FontPlatformDataCacheKey(HashTableDeletedValueType t)
 84         : m_fontDescriptionKey(t)
 85     { }
 86 
 87     bool isHashTableDeletedValue() const { return m_fontDescriptionKey.isHashTableDeletedValue(); }
 88 
 89     bool operator==(const FontPlatformDataCacheKey&amp; other) const
 90     {
 91         if (m_fontDescriptionKey != other.m_fontDescriptionKey
 92             || m_fontFaceFeatures != other.m_fontFaceFeatures

 93             || m_fontFaceCapabilities != other.m_fontFaceCapabilities)
 94             return false;
 95         if (m_family.impl() == other.m_family.impl())
 96             return true;
 97         if (m_family.isNull() || other.m_family.isNull())
 98             return false;
 99         return FontCascadeDescription::familyNamesAreEqual(m_family, other.m_family);
100     }
101 
102     FontDescriptionKey m_fontDescriptionKey;
103     AtomString m_family;
104     FontFeatureSettings m_fontFaceFeatures;

105     FontSelectionSpecifiedCapabilities m_fontFaceCapabilities;
106 };
107 
108 struct FontPlatformDataCacheKeyHash {
109     static unsigned hash(const FontPlatformDataCacheKey&amp; fontKey)
110     {
111         IntegerHasher hasher;
112         hasher.add(FontCascadeDescription::familyNameHash(fontKey.m_family));
113         hasher.add(fontKey.m_fontDescriptionKey.computeHash());
114         hasher.add(fontKey.m_fontFaceFeatures.hash());

115         if (auto weight = fontKey.m_fontFaceCapabilities.weight)
116             hasher.add(weight-&gt;uniqueValue());
117         else
118             hasher.add(std::numeric_limits&lt;unsigned&gt;::max());
119         if (auto width = fontKey.m_fontFaceCapabilities.weight)
120             hasher.add(width-&gt;uniqueValue());
121         else
122             hasher.add(std::numeric_limits&lt;unsigned&gt;::max());
123         if (auto slope = fontKey.m_fontFaceCapabilities.weight)
124             hasher.add(slope-&gt;uniqueValue());
125         else
126             hasher.add(std::numeric_limits&lt;unsigned&gt;::max());
127         return hasher.hash();
128     }
129 
130     static bool equal(const FontPlatformDataCacheKey&amp; a, const FontPlatformDataCacheKey&amp; b)
131     {
132         return a == b;
133     }
134 
</pre>
<hr />
<pre>
179     // On Windows, Courier New is a TrueType font that is always present and
180     // Courier is a bitmap font that we do not support. So, we don&#39;t want to map
181     // Courier New to Courier.
182     // FIXME: Not sure why this is harmful on Windows, since the alternative will
183     // only be tried if Courier New is not found.
184     case 11:
185         if (equalLettersIgnoringASCIICase(familyName, &quot;courier new&quot;))
186             return courier;
187         break;
188 #endif
189     case 15:
190         if (equalLettersIgnoringASCIICase(familyName, &quot;times new roman&quot;))
191             return times;
192         break;
193     }
194 
195     return nullAtom();
196 }
197 
198 FontPlatformData* FontCache::getCachedFontPlatformData(const FontDescription&amp; fontDescription, const AtomString&amp; passedFamilyName,
<span class="line-modified">199     const FontFeatureSettings* fontFaceFeatures, FontSelectionSpecifiedCapabilities fontFaceCapabilities, bool checkingAlternateName)</span>
200 {
201 #if PLATFORM(IOS_FAMILY)
202     auto locker = holdLock(fontLock);
203 #endif
204 
205 #if OS(WINDOWS) &amp;&amp; ENABLE(OPENTYPE_VERTICAL)
206     // Leading &quot;@&quot; in the font name enables Windows vertical flow flag for the font.
207     // Because we do vertical flow by ourselves, we don&#39;t want to use the Windows feature.
208     // IE disregards &quot;@&quot; regardless of the orientatoin, so we follow the behavior.
209     const AtomString&amp; familyName = (passedFamilyName.isEmpty() || passedFamilyName[0] != &#39;@&#39;) ?
210         passedFamilyName : AtomString(passedFamilyName.impl()-&gt;substring(1));
211 #else
212     const AtomString&amp; familyName = passedFamilyName;
213 #endif
214 
215     static bool initialized;
216     if (!initialized) {
217         platformInit();
218         initialized = true;
219     }
220 
<span class="line-modified">221     FontPlatformDataCacheKey key(familyName, fontDescription, fontFaceFeatures, fontFaceCapabilities);</span>
222 
223     auto addResult = fontPlatformDataCache().add(key, nullptr);
224     FontPlatformDataCache::iterator it = addResult.iterator;
225     if (addResult.isNewEntry) {
<span class="line-modified">226         it-&gt;value = createFontPlatformData(fontDescription, familyName, fontFaceFeatures, fontFaceCapabilities);</span>
227 
228         if (!it-&gt;value &amp;&amp; !checkingAlternateName) {
229             // We were unable to find a font.  We have a small set of fonts that we alias to other names,
230             // e.g., Arial/Helvetica, Courier/Courier New, etc.  Try looking up the font under the aliased name.
231             const AtomString&amp; alternateName = alternateFamilyName(familyName);
232             if (!alternateName.isNull()) {
<span class="line-modified">233                 FontPlatformData* fontPlatformDataForAlternateName = getCachedFontPlatformData(fontDescription, alternateName, fontFaceFeatures, fontFaceCapabilities, true);</span>
234                 // Lookup the key in the hash table again as the previous iterator may have
235                 // been invalidated by the recursive call to getCachedFontPlatformData().
236                 it = fontPlatformDataCache().find(key);
237                 ASSERT(it != fontPlatformDataCache().end());
238                 if (fontPlatformDataForAlternateName)
239                     it-&gt;value = makeUnique&lt;FontPlatformData&gt;(*fontPlatformDataForAlternateName);
240             }
241         }
242     }
243 
244     return it-&gt;value.get();
245 }
246 
247 struct FontDataCacheKeyHash {
248     static unsigned hash(const FontPlatformData&amp; platformData)
249     {
250         return platformData.hash();
251     }
252 
253     static bool equal(const FontPlatformData&amp; a, const FontPlatformData&amp; b)
</pre>
<hr />
<pre>
295 RefPtr&lt;OpenTypeVerticalData&gt; FontCache::verticalData(const FontPlatformData&amp; platformData)
296 {
297     auto addResult = fontVerticalDataCache().ensure(platformData, [&amp;platformData] {
298         return OpenTypeVerticalData::create(platformData);
299     });
300     return addResult.iterator-&gt;value;
301 }
302 #endif
303 
304 #if PLATFORM(IOS_FAMILY)
305 const unsigned cMaxInactiveFontData = 120;
306 const unsigned cTargetInactiveFontData = 100;
307 #else
308 const unsigned cMaxInactiveFontData = 225;
309 const unsigned cTargetInactiveFontData = 200;
310 #endif
311 
312 const unsigned cMaxUnderMemoryPressureInactiveFontData = 50;
313 const unsigned cTargetUnderMemoryPressureInactiveFontData = 30;
314 
<span class="line-modified">315 RefPtr&lt;Font&gt; FontCache::fontForFamily(const FontDescription&amp; fontDescription, const AtomString&amp; family, const FontFeatureSettings* fontFaceFeatures, FontSelectionSpecifiedCapabilities fontFaceCapabilities, bool checkingAlternateName)</span>
316 {
317     if (!m_purgeTimer.isActive())
318         m_purgeTimer.startOneShot(0_s);
319 
<span class="line-modified">320     if (auto* platformData = getCachedFontPlatformData(fontDescription, family, fontFaceFeatures, fontFaceCapabilities, checkingAlternateName))</span>
321         return fontForPlatformData(*platformData);
322 
323     return nullptr;
324 }
325 
326 Ref&lt;Font&gt; FontCache::fontForPlatformData(const FontPlatformData&amp; platformData)
327 {
328 #if PLATFORM(IOS_FAMILY)
329     auto locker = holdLock(fontLock);
330 #endif
331 
332     auto addResult = cachedFonts().ensure(platformData, [&amp;] {
333         return Font::create(platformData);
334     });
335 
336     ASSERT(addResult.iterator-&gt;value-&gt;platformData() == platformData);
337 
338     return addResult.iterator-&gt;value.copyRef();
339 }
340 
</pre>
</td>
</tr>
</table>
<center><a href="Font.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FontCache.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
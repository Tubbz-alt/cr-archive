<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/coordinated/CoordinatedGraphicsLayer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../TextureMapperShaderProgram.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CoordinatedGraphicsLayer.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/coordinated/CoordinatedGraphicsLayer.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  89 
  90 void CoordinatedGraphicsLayer::didUpdateTileBuffers()
  91 {
  92     if (!isShowingRepaintCounter())
  93         return;
  94 
  95     auto repaintCount = incrementRepaintCount();
  96     m_nicosia.repaintCounter.count = repaintCount;
  97     m_nicosia.delta.repaintCounterChanged = true;
  98 }
  99 
 100 void CoordinatedGraphicsLayer::setShouldUpdateVisibleRect()
 101 {
 102     m_shouldUpdateVisibleRect = true;
 103     for (auto&amp; child : children())
 104         downcast&lt;CoordinatedGraphicsLayer&gt;(child.get()).setShouldUpdateVisibleRect();
 105     if (replicaLayer())
 106         downcast&lt;CoordinatedGraphicsLayer&gt;(*replicaLayer()).setShouldUpdateVisibleRect();
 107 }
 108 
<span class="line-modified"> 109 void CoordinatedGraphicsLayer::didChangeGeometry()</span>
 110 {
<span class="line-modified"> 111     notifyFlushRequired();</span>

 112     setShouldUpdateVisibleRect();
 113 }
 114 
 115 CoordinatedGraphicsLayer::CoordinatedGraphicsLayer(Type layerType, GraphicsLayerClient&amp; client)
 116     : GraphicsLayer(layerType, client)
 117 #ifndef NDEBUG
 118     , m_isPurging(false)
 119 #endif
 120     , m_shouldUpdateVisibleRect(true)
 121     , m_movingVisibleRect(false)
 122     , m_pendingContentsScaleAdjustment(false)
 123     , m_pendingVisibleRectAdjustment(false)
 124     , m_shouldUpdatePlatformLayer(false)
 125     , m_coordinator(0)
 126     , m_compositedNativeImagePtr(0)
 127     , m_animationStartedTimer(*this, &amp;CoordinatedGraphicsLayer::animationStartedTimerFired)
 128     , m_requestPendingTileCreationTimer(RunLoop::main(), this, &amp;CoordinatedGraphicsLayer::requestPendingTileCreationTimerFired)
 129 {
 130     static Nicosia::PlatformLayer::LayerID nextLayerID = 1;
 131     m_id = nextLayerID++;
</pre>
<hr />
<pre>
 221     return true;
 222 }
 223 
 224 void CoordinatedGraphicsLayer::removeFromParent()
 225 {
 226     if (CoordinatedGraphicsLayer* parentLayer = downcast&lt;CoordinatedGraphicsLayer&gt;(parent()))
 227         parentLayer-&gt;didChangeChildren();
 228     GraphicsLayer::removeFromParent();
 229 }
 230 
 231 void CoordinatedGraphicsLayer::setPosition(const FloatPoint&amp; p)
 232 {
 233     if (position() == p)
 234         return;
 235 
 236     GraphicsLayer::setPosition(p);
 237     m_nicosia.delta.positionChanged = true;
 238     didChangeGeometry();
 239 }
 240 









 241 void CoordinatedGraphicsLayer::setAnchorPoint(const FloatPoint3D&amp; p)
 242 {
 243     if (anchorPoint() == p)
 244         return;
 245 
 246     GraphicsLayer::setAnchorPoint(p);
 247     m_nicosia.delta.anchorPointChanged = true;
 248     didChangeGeometry();
 249 }
 250 
 251 void CoordinatedGraphicsLayer::setSize(const FloatSize&amp; size)
 252 {
 253     if (this-&gt;size() == size)
 254         return;
 255 
 256     GraphicsLayer::setSize(size);
 257     m_nicosia.delta.sizeChanged = true;
 258 
 259     if (maskLayer())
 260         maskLayer()-&gt;setSize(size);
 261     didChangeGeometry();
 262 }
 263 



















 264 void CoordinatedGraphicsLayer::setTransform(const TransformationMatrix&amp; t)
 265 {
 266     if (transform() == t)
 267         return;
 268 
 269     GraphicsLayer::setTransform(t);
 270     m_nicosia.delta.transformChanged = true;
 271 
 272     didChangeGeometry();
 273 }
 274 
 275 void CoordinatedGraphicsLayer::setChildrenTransform(const TransformationMatrix&amp; t)
 276 {
 277     if (childrenTransform() == t)
 278         return;
 279 
 280     GraphicsLayer::setChildrenTransform(t);
 281     m_nicosia.delta.childrenTransformChanged = true;
 282 
 283     didChangeGeometry();
</pre>
<hr />
<pre>
 777                 m_nicosia.imageBacking = nullptr;
 778             }
 779         }
 780         if (!m_nicosia.imageBacking) {
 781             m_nicosia.imageBacking = Nicosia::ImageBacking::create(Nicosia::ImageBackingTextureMapperImpl::createFactory());
 782             m_nicosia.delta.imageBackingChanged = true;
 783         }
 784 
 785         // Update the image contents only when the image layer is visible and the native image changed.
 786         auto&amp; impl = downcast&lt;Nicosia::ImageBackingTextureMapperImpl&gt;(m_nicosia.imageBacking-&gt;impl());
 787         auto&amp; layerState = impl.layerState();
 788         layerState.imageID = imageID;
 789         layerState.update.isVisible = transformedVisibleRect().intersects(IntRect(contentsRect()));
 790         if (layerState.update.isVisible &amp;&amp; layerState.nativeImageID != nativeImageID) {
 791             auto buffer = Nicosia::Buffer::create(IntSize(image.size()),
 792                 !image.currentFrameKnownToBeOpaque() ? Nicosia::Buffer::SupportsAlpha : Nicosia::Buffer::NoFlags);
 793             Nicosia::PaintingContext::paint(buffer,
 794                 [&amp;image](GraphicsContext&amp; context)
 795                 {
 796                     IntRect rect { { }, IntSize { image.size() } };
<span class="line-modified"> 797                     context.drawImage(image, rect, rect, ImagePaintingOptions(CompositeCopy));</span>
 798                 });
 799             layerState.nativeImageID = nativeImageID;
 800             layerState.update.buffer = WTFMove(buffer);
 801             m_nicosia.delta.imageBackingChanged = true;
 802         }
 803     } else if (m_nicosia.imageBacking) {
 804         auto&amp; layerState = downcast&lt;Nicosia::ImageBackingTextureMapperImpl&gt;(m_nicosia.imageBacking-&gt;impl()).layerState();
 805         layerState.update = Nicosia::ImageBackingTextureMapperImpl::Update { };
 806         m_nicosia.imageBacking = nullptr;
 807         m_nicosia.delta.imageBackingChanged = true;
 808     }
 809 
 810     {
 811         m_nicosia.layer-&gt;updateState(
 812             [this](Nicosia::CompositionLayer::LayerState&amp; state)
 813             {
 814                 // OR the local delta value into the layer&#39;s pending state delta. After that,
 815                 // go through each local change and update the pending state accordingly.
 816                 auto&amp; localDelta = m_nicosia.delta;
 817                 state.delta.value |= localDelta.value;
</pre>
<hr />
<pre>
 826                 if (localDelta.transformChanged)
 827                     state.transform = transform();
 828                 if (localDelta.childrenTransformChanged)
 829                     state.childrenTransform = childrenTransform();
 830 
 831                 if (localDelta.contentsRectChanged)
 832                     state.contentsRect = contentsRect();
 833                 if (localDelta.contentsTilingChanged) {
 834                     state.contentsTilePhase = contentsTilePhase();
 835                     state.contentsTileSize = contentsTileSize();
 836                 }
 837 
 838                 if (localDelta.opacityChanged)
 839                     state.opacity = opacity();
 840                 if (localDelta.solidColorChanged)
 841                     state.solidColor = m_solidColor;
 842 
 843                 if (localDelta.filtersChanged)
 844                     state.filters = filters();
 845                 if (localDelta.animationsChanged)
<span class="line-modified"> 846                     state.animations = m_animations.getActiveAnimations();</span>
 847 
 848                 if (localDelta.childrenChanged) {
 849                     state.children = WTF::map(children(),
 850                         [](auto&amp; child)
 851                         {
 852                             return downcast&lt;CoordinatedGraphicsLayer&gt;(child.get()).m_nicosia.layer;
 853                         });
 854                 }
 855 
 856                 if (localDelta.maskChanged) {
 857                     auto* mask = downcast&lt;CoordinatedGraphicsLayer&gt;(maskLayer());
 858                     state.mask = mask ? mask-&gt;m_nicosia.layer : nullptr;
 859                 }
 860 
 861                 if (localDelta.replicaChanged) {
 862                     auto* replica = downcast&lt;CoordinatedGraphicsLayer&gt;(replicaLayer());
 863                     state.replica = replica ? replica-&gt;m_nicosia.layer : nullptr;
 864                 }
 865 
 866                 if (localDelta.flagsChanged) {
</pre>
<hr />
<pre>
1115 const RefPtr&lt;Nicosia::CompositionLayer&gt;&amp; CoordinatedGraphicsLayer::compositionLayer() const
1116 {
1117     return m_nicosia.layer;
1118 }
1119 
1120 void CoordinatedGraphicsLayer::setNeedsVisibleRectAdjustment()
1121 {
1122     if (shouldHaveBackingStore())
1123         m_pendingVisibleRectAdjustment = true;
1124 }
1125 
1126 static inline bool isIntegral(float value)
1127 {
1128     return static_cast&lt;int&gt;(value) == value;
1129 }
1130 
1131 FloatPoint CoordinatedGraphicsLayer::computePositionRelativeToBase()
1132 {
1133     FloatPoint offset;
1134     for (const GraphicsLayer* currLayer = this; currLayer; currLayer = currLayer-&gt;parent())
<span class="line-modified">1135         offset += currLayer-&gt;position();</span>
1136 
1137     return offset;
1138 }
1139 
1140 void CoordinatedGraphicsLayer::computePixelAlignment(FloatPoint&amp; position, FloatSize&amp; size, FloatPoint3D&amp; anchorPoint, FloatSize&amp; alignmentOffset)
1141 {
1142     if (isIntegral(effectiveContentsScale())) {
1143         position = m_position;
1144         size = m_size;
1145         anchorPoint = m_anchorPoint;
1146         alignmentOffset = FloatSize();
1147         return;
1148     }
1149 
1150     FloatPoint positionRelativeToBase = computePositionRelativeToBase();
1151 
1152     FloatRect baseRelativeBounds(positionRelativeToBase, m_size);
1153     FloatRect scaledBounds = baseRelativeBounds;
1154 
1155     // Scale by the effective scale factor to compute the screen-relative bounds.
</pre>
<hr />
<pre>
1191     if (m_movingVisibleRect)
1192         client().getCurrentTransform(this, currentTransform);
1193     m_layerTransform.setLocalTransform(currentTransform);
1194 
1195     m_layerTransform.setAnchorPoint(m_adjustedAnchorPoint);
1196     m_layerTransform.setPosition(m_adjustedPosition);
1197     m_layerTransform.setSize(m_adjustedSize);
1198 
1199     m_layerTransform.setFlattening(!preserves3D());
1200     m_layerTransform.setChildrenTransform(childrenTransform());
1201     m_layerTransform.combineTransforms(parent() ? downcast&lt;CoordinatedGraphicsLayer&gt;(*parent()).m_layerTransform.combinedForChildren() : TransformationMatrix());
1202 
1203     m_cachedInverseTransform = m_layerTransform.combined().inverse().valueOr(TransformationMatrix());
1204 
1205     // The combined transform will be used in tiledBackingStoreVisibleRect.
1206     setNeedsVisibleRectAdjustment();
1207 }
1208 
1209 bool CoordinatedGraphicsLayer::shouldHaveBackingStore() const
1210 {
<span class="line-modified">1211     return drawsContent() &amp;&amp; contentsAreVisible() &amp;&amp; !m_size.isEmpty();</span>

1212 }
1213 
1214 bool CoordinatedGraphicsLayer::selfOrAncestorHasActiveTransformAnimation() const
1215 {
1216     if (m_animations.hasActiveAnimationsOfType(AnimatedPropertyTransform))
1217         return true;
1218 
1219     if (!parent())
1220         return false;
1221 
1222     return downcast&lt;CoordinatedGraphicsLayer&gt;(*parent()).selfOrAncestorHasActiveTransformAnimation();
1223 }
1224 
1225 bool CoordinatedGraphicsLayer::selfOrAncestorHaveNonAffineTransforms()
1226 {
1227     if (!m_layerTransform.combined().isAffine())
1228         return true;
1229 
1230     if (!parent())
1231         return false;
</pre>
<hr />
<pre>
1285 {
1286     m_animations.resume();
1287     didChangeAnimations();
1288 }
1289 
1290 void CoordinatedGraphicsLayer::animationStartedTimerFired()
1291 {
1292     client().notifyAnimationStarted(this, &quot;&quot;, m_lastAnimationStartTime);
1293 }
1294 
1295 void CoordinatedGraphicsLayer::requestPendingTileCreationTimerFired()
1296 {
1297     notifyFlushRequired();
1298 }
1299 
1300 bool CoordinatedGraphicsLayer::usesContentsLayer() const
1301 {
1302     return m_nicosia.contentLayer || m_compositedImage;
1303 }
1304 







1305 } // namespace WebCore
1306 
1307 SPECIALIZE_TYPE_TRAITS_ANIMATEDBACKINGSTORECLIENT(WebCore::CoordinatedAnimatedBackingStoreClient, type() == Nicosia::AnimatedBackingStoreClient::Type::Coordinated)
1308 
1309 #endif // USE(COORDINATED_GRAPHICS)
</pre>
</td>
<td>
<hr />
<pre>
  89 
  90 void CoordinatedGraphicsLayer::didUpdateTileBuffers()
  91 {
  92     if (!isShowingRepaintCounter())
  93         return;
  94 
  95     auto repaintCount = incrementRepaintCount();
  96     m_nicosia.repaintCounter.count = repaintCount;
  97     m_nicosia.delta.repaintCounterChanged = true;
  98 }
  99 
 100 void CoordinatedGraphicsLayer::setShouldUpdateVisibleRect()
 101 {
 102     m_shouldUpdateVisibleRect = true;
 103     for (auto&amp; child : children())
 104         downcast&lt;CoordinatedGraphicsLayer&gt;(child.get()).setShouldUpdateVisibleRect();
 105     if (replicaLayer())
 106         downcast&lt;CoordinatedGraphicsLayer&gt;(*replicaLayer()).setShouldUpdateVisibleRect();
 107 }
 108 
<span class="line-modified"> 109 void CoordinatedGraphicsLayer::didChangeGeometry(FlushNotification flushNotification)</span>
 110 {
<span class="line-modified"> 111     if (flushNotification == FlushNotification::Required)</span>
<span class="line-added"> 112         notifyFlushRequired();</span>
 113     setShouldUpdateVisibleRect();
 114 }
 115 
 116 CoordinatedGraphicsLayer::CoordinatedGraphicsLayer(Type layerType, GraphicsLayerClient&amp; client)
 117     : GraphicsLayer(layerType, client)
 118 #ifndef NDEBUG
 119     , m_isPurging(false)
 120 #endif
 121     , m_shouldUpdateVisibleRect(true)
 122     , m_movingVisibleRect(false)
 123     , m_pendingContentsScaleAdjustment(false)
 124     , m_pendingVisibleRectAdjustment(false)
 125     , m_shouldUpdatePlatformLayer(false)
 126     , m_coordinator(0)
 127     , m_compositedNativeImagePtr(0)
 128     , m_animationStartedTimer(*this, &amp;CoordinatedGraphicsLayer::animationStartedTimerFired)
 129     , m_requestPendingTileCreationTimer(RunLoop::main(), this, &amp;CoordinatedGraphicsLayer::requestPendingTileCreationTimerFired)
 130 {
 131     static Nicosia::PlatformLayer::LayerID nextLayerID = 1;
 132     m_id = nextLayerID++;
</pre>
<hr />
<pre>
 222     return true;
 223 }
 224 
 225 void CoordinatedGraphicsLayer::removeFromParent()
 226 {
 227     if (CoordinatedGraphicsLayer* parentLayer = downcast&lt;CoordinatedGraphicsLayer&gt;(parent()))
 228         parentLayer-&gt;didChangeChildren();
 229     GraphicsLayer::removeFromParent();
 230 }
 231 
 232 void CoordinatedGraphicsLayer::setPosition(const FloatPoint&amp; p)
 233 {
 234     if (position() == p)
 235         return;
 236 
 237     GraphicsLayer::setPosition(p);
 238     m_nicosia.delta.positionChanged = true;
 239     didChangeGeometry();
 240 }
 241 
<span class="line-added"> 242 void CoordinatedGraphicsLayer::syncPosition(const FloatPoint&amp; p)</span>
<span class="line-added"> 243 {</span>
<span class="line-added"> 244     if (position() == p)</span>
<span class="line-added"> 245         return;</span>
<span class="line-added"> 246 </span>
<span class="line-added"> 247     GraphicsLayer::syncPosition(p);</span>
<span class="line-added"> 248     didChangeGeometry(FlushNotification::NotRequired);</span>
<span class="line-added"> 249 }</span>
<span class="line-added"> 250 </span>
 251 void CoordinatedGraphicsLayer::setAnchorPoint(const FloatPoint3D&amp; p)
 252 {
 253     if (anchorPoint() == p)
 254         return;
 255 
 256     GraphicsLayer::setAnchorPoint(p);
 257     m_nicosia.delta.anchorPointChanged = true;
 258     didChangeGeometry();
 259 }
 260 
 261 void CoordinatedGraphicsLayer::setSize(const FloatSize&amp; size)
 262 {
 263     if (this-&gt;size() == size)
 264         return;
 265 
 266     GraphicsLayer::setSize(size);
 267     m_nicosia.delta.sizeChanged = true;
 268 
 269     if (maskLayer())
 270         maskLayer()-&gt;setSize(size);
 271     didChangeGeometry();
 272 }
 273 
<span class="line-added"> 274 void CoordinatedGraphicsLayer::setBoundsOrigin(const FloatPoint&amp; boundsOrigin)</span>
<span class="line-added"> 275 {</span>
<span class="line-added"> 276     if (this-&gt;boundsOrigin() == boundsOrigin)</span>
<span class="line-added"> 277         return;</span>
<span class="line-added"> 278 </span>
<span class="line-added"> 279     GraphicsLayer::setBoundsOrigin(boundsOrigin);</span>
<span class="line-added"> 280     m_nicosia.delta.boundsOriginChanged = true;</span>
<span class="line-added"> 281     didChangeGeometry();</span>
<span class="line-added"> 282 }</span>
<span class="line-added"> 283 </span>
<span class="line-added"> 284 void CoordinatedGraphicsLayer::syncBoundsOrigin(const FloatPoint&amp; boundsOrigin)</span>
<span class="line-added"> 285 {</span>
<span class="line-added"> 286     if (this-&gt;boundsOrigin() == boundsOrigin)</span>
<span class="line-added"> 287         return;</span>
<span class="line-added"> 288 </span>
<span class="line-added"> 289     GraphicsLayer::syncBoundsOrigin(boundsOrigin);</span>
<span class="line-added"> 290     didChangeGeometry(FlushNotification::NotRequired);</span>
<span class="line-added"> 291 }</span>
<span class="line-added"> 292 </span>
 293 void CoordinatedGraphicsLayer::setTransform(const TransformationMatrix&amp; t)
 294 {
 295     if (transform() == t)
 296         return;
 297 
 298     GraphicsLayer::setTransform(t);
 299     m_nicosia.delta.transformChanged = true;
 300 
 301     didChangeGeometry();
 302 }
 303 
 304 void CoordinatedGraphicsLayer::setChildrenTransform(const TransformationMatrix&amp; t)
 305 {
 306     if (childrenTransform() == t)
 307         return;
 308 
 309     GraphicsLayer::setChildrenTransform(t);
 310     m_nicosia.delta.childrenTransformChanged = true;
 311 
 312     didChangeGeometry();
</pre>
<hr />
<pre>
 806                 m_nicosia.imageBacking = nullptr;
 807             }
 808         }
 809         if (!m_nicosia.imageBacking) {
 810             m_nicosia.imageBacking = Nicosia::ImageBacking::create(Nicosia::ImageBackingTextureMapperImpl::createFactory());
 811             m_nicosia.delta.imageBackingChanged = true;
 812         }
 813 
 814         // Update the image contents only when the image layer is visible and the native image changed.
 815         auto&amp; impl = downcast&lt;Nicosia::ImageBackingTextureMapperImpl&gt;(m_nicosia.imageBacking-&gt;impl());
 816         auto&amp; layerState = impl.layerState();
 817         layerState.imageID = imageID;
 818         layerState.update.isVisible = transformedVisibleRect().intersects(IntRect(contentsRect()));
 819         if (layerState.update.isVisible &amp;&amp; layerState.nativeImageID != nativeImageID) {
 820             auto buffer = Nicosia::Buffer::create(IntSize(image.size()),
 821                 !image.currentFrameKnownToBeOpaque() ? Nicosia::Buffer::SupportsAlpha : Nicosia::Buffer::NoFlags);
 822             Nicosia::PaintingContext::paint(buffer,
 823                 [&amp;image](GraphicsContext&amp; context)
 824                 {
 825                     IntRect rect { { }, IntSize { image.size() } };
<span class="line-modified"> 826                     context.drawImage(image, rect, rect, ImagePaintingOptions(CompositeOperator::Copy));</span>
 827                 });
 828             layerState.nativeImageID = nativeImageID;
 829             layerState.update.buffer = WTFMove(buffer);
 830             m_nicosia.delta.imageBackingChanged = true;
 831         }
 832     } else if (m_nicosia.imageBacking) {
 833         auto&amp; layerState = downcast&lt;Nicosia::ImageBackingTextureMapperImpl&gt;(m_nicosia.imageBacking-&gt;impl()).layerState();
 834         layerState.update = Nicosia::ImageBackingTextureMapperImpl::Update { };
 835         m_nicosia.imageBacking = nullptr;
 836         m_nicosia.delta.imageBackingChanged = true;
 837     }
 838 
 839     {
 840         m_nicosia.layer-&gt;updateState(
 841             [this](Nicosia::CompositionLayer::LayerState&amp; state)
 842             {
 843                 // OR the local delta value into the layer&#39;s pending state delta. After that,
 844                 // go through each local change and update the pending state accordingly.
 845                 auto&amp; localDelta = m_nicosia.delta;
 846                 state.delta.value |= localDelta.value;
</pre>
<hr />
<pre>
 855                 if (localDelta.transformChanged)
 856                     state.transform = transform();
 857                 if (localDelta.childrenTransformChanged)
 858                     state.childrenTransform = childrenTransform();
 859 
 860                 if (localDelta.contentsRectChanged)
 861                     state.contentsRect = contentsRect();
 862                 if (localDelta.contentsTilingChanged) {
 863                     state.contentsTilePhase = contentsTilePhase();
 864                     state.contentsTileSize = contentsTileSize();
 865                 }
 866 
 867                 if (localDelta.opacityChanged)
 868                     state.opacity = opacity();
 869                 if (localDelta.solidColorChanged)
 870                     state.solidColor = m_solidColor;
 871 
 872                 if (localDelta.filtersChanged)
 873                     state.filters = filters();
 874                 if (localDelta.animationsChanged)
<span class="line-modified"> 875                     state.animations = m_animations;</span>
 876 
 877                 if (localDelta.childrenChanged) {
 878                     state.children = WTF::map(children(),
 879                         [](auto&amp; child)
 880                         {
 881                             return downcast&lt;CoordinatedGraphicsLayer&gt;(child.get()).m_nicosia.layer;
 882                         });
 883                 }
 884 
 885                 if (localDelta.maskChanged) {
 886                     auto* mask = downcast&lt;CoordinatedGraphicsLayer&gt;(maskLayer());
 887                     state.mask = mask ? mask-&gt;m_nicosia.layer : nullptr;
 888                 }
 889 
 890                 if (localDelta.replicaChanged) {
 891                     auto* replica = downcast&lt;CoordinatedGraphicsLayer&gt;(replicaLayer());
 892                     state.replica = replica ? replica-&gt;m_nicosia.layer : nullptr;
 893                 }
 894 
 895                 if (localDelta.flagsChanged) {
</pre>
<hr />
<pre>
1144 const RefPtr&lt;Nicosia::CompositionLayer&gt;&amp; CoordinatedGraphicsLayer::compositionLayer() const
1145 {
1146     return m_nicosia.layer;
1147 }
1148 
1149 void CoordinatedGraphicsLayer::setNeedsVisibleRectAdjustment()
1150 {
1151     if (shouldHaveBackingStore())
1152         m_pendingVisibleRectAdjustment = true;
1153 }
1154 
1155 static inline bool isIntegral(float value)
1156 {
1157     return static_cast&lt;int&gt;(value) == value;
1158 }
1159 
1160 FloatPoint CoordinatedGraphicsLayer::computePositionRelativeToBase()
1161 {
1162     FloatPoint offset;
1163     for (const GraphicsLayer* currLayer = this; currLayer; currLayer = currLayer-&gt;parent())
<span class="line-modified">1164         offset += (currLayer-&gt;position() - currLayer-&gt;boundsOrigin());</span>
1165 
1166     return offset;
1167 }
1168 
1169 void CoordinatedGraphicsLayer::computePixelAlignment(FloatPoint&amp; position, FloatSize&amp; size, FloatPoint3D&amp; anchorPoint, FloatSize&amp; alignmentOffset)
1170 {
1171     if (isIntegral(effectiveContentsScale())) {
1172         position = m_position;
1173         size = m_size;
1174         anchorPoint = m_anchorPoint;
1175         alignmentOffset = FloatSize();
1176         return;
1177     }
1178 
1179     FloatPoint positionRelativeToBase = computePositionRelativeToBase();
1180 
1181     FloatRect baseRelativeBounds(positionRelativeToBase, m_size);
1182     FloatRect scaledBounds = baseRelativeBounds;
1183 
1184     // Scale by the effective scale factor to compute the screen-relative bounds.
</pre>
<hr />
<pre>
1220     if (m_movingVisibleRect)
1221         client().getCurrentTransform(this, currentTransform);
1222     m_layerTransform.setLocalTransform(currentTransform);
1223 
1224     m_layerTransform.setAnchorPoint(m_adjustedAnchorPoint);
1225     m_layerTransform.setPosition(m_adjustedPosition);
1226     m_layerTransform.setSize(m_adjustedSize);
1227 
1228     m_layerTransform.setFlattening(!preserves3D());
1229     m_layerTransform.setChildrenTransform(childrenTransform());
1230     m_layerTransform.combineTransforms(parent() ? downcast&lt;CoordinatedGraphicsLayer&gt;(*parent()).m_layerTransform.combinedForChildren() : TransformationMatrix());
1231 
1232     m_cachedInverseTransform = m_layerTransform.combined().inverse().valueOr(TransformationMatrix());
1233 
1234     // The combined transform will be used in tiledBackingStoreVisibleRect.
1235     setNeedsVisibleRectAdjustment();
1236 }
1237 
1238 bool CoordinatedGraphicsLayer::shouldHaveBackingStore() const
1239 {
<span class="line-modified">1240     return drawsContent() &amp;&amp; contentsAreVisible() &amp;&amp; !m_size.isEmpty()</span>
<span class="line-added">1241         &amp;&amp; (!!opacity() || m_animations.hasActiveAnimationsOfType(AnimatedPropertyOpacity));</span>
1242 }
1243 
1244 bool CoordinatedGraphicsLayer::selfOrAncestorHasActiveTransformAnimation() const
1245 {
1246     if (m_animations.hasActiveAnimationsOfType(AnimatedPropertyTransform))
1247         return true;
1248 
1249     if (!parent())
1250         return false;
1251 
1252     return downcast&lt;CoordinatedGraphicsLayer&gt;(*parent()).selfOrAncestorHasActiveTransformAnimation();
1253 }
1254 
1255 bool CoordinatedGraphicsLayer::selfOrAncestorHaveNonAffineTransforms()
1256 {
1257     if (!m_layerTransform.combined().isAffine())
1258         return true;
1259 
1260     if (!parent())
1261         return false;
</pre>
<hr />
<pre>
1315 {
1316     m_animations.resume();
1317     didChangeAnimations();
1318 }
1319 
1320 void CoordinatedGraphicsLayer::animationStartedTimerFired()
1321 {
1322     client().notifyAnimationStarted(this, &quot;&quot;, m_lastAnimationStartTime);
1323 }
1324 
1325 void CoordinatedGraphicsLayer::requestPendingTileCreationTimerFired()
1326 {
1327     notifyFlushRequired();
1328 }
1329 
1330 bool CoordinatedGraphicsLayer::usesContentsLayer() const
1331 {
1332     return m_nicosia.contentLayer || m_compositedImage;
1333 }
1334 
<span class="line-added">1335 #if USE(NICOSIA)</span>
<span class="line-added">1336 PlatformLayer* CoordinatedGraphicsLayer::platformLayer() const</span>
<span class="line-added">1337 {</span>
<span class="line-added">1338     return m_nicosia.layer.get();</span>
<span class="line-added">1339 }</span>
<span class="line-added">1340 #endif</span>
<span class="line-added">1341 </span>
1342 } // namespace WebCore
1343 
1344 SPECIALIZE_TYPE_TRAITS_ANIMATEDBACKINGSTORECLIENT(WebCore::CoordinatedAnimatedBackingStoreClient, type() == Nicosia::AnimatedBackingStoreClient::Type::Coordinated)
1345 
1346 #endif // USE(COORDINATED_GRAPHICS)
</pre>
</td>
</tr>
</table>
<center><a href="../TextureMapperShaderProgram.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="CoordinatedGraphicsLayer.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
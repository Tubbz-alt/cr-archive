<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/HeapUtil.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 namespace JSC {
 29 
 30 // Are you tired of waiting for all of WebKit to build because you changed the implementation of a
 31 // function in HeapInlines.h?  Does it bother you that you&#39;re waiting on rebuilding the JS DOM
 32 // bindings even though your change is in a function called from only 2 .cpp files?  Then HeapUtil.h
 33 // is for you!  Everything in this class should be a static method that takes a Heap&amp; if needed.
 34 // This is a friend of Heap, so you can access all of Heap&#39;s privates.
 35 //
 36 // This ends up being an issue because Heap exposes a lot of methods that ought to be inline for
 37 // performance or that must be inline because they are templates.  This class ought to contain
 38 // methods that are used for the implementation of the collector, or for unusual clients that need
 39 // to reach deep into the collector for some reason.  Don&#39;t put things in here that would cause you
 40 // to have to include it from more than a handful of places, since that would defeat the purpose.
 41 // This class isn&#39;t here to look pretty.  It&#39;s to let us hack the GC more easily!
 42 
 43 class HeapUtil {
 44 public:
 45     // This function must be run after stopAllocation() is called and
 46     // before liveness data is cleared to be accurate.
 47     template&lt;typename Func&gt;
 48     static void findGCObjectPointersForMarking(
 49         Heap&amp; heap, HeapVersion markingVersion, HeapVersion newlyAllocatedVersion, TinyBloomFilter filter,
 50         void* passedPointer, const Func&amp; func)
 51     {
 52         const HashSet&lt;MarkedBlock*&gt;&amp; set = heap.objectSpace().blocks().set();
 53 
 54         ASSERT(heap.objectSpace().isMarking());
 55         static const bool isMarking = true;
 56 
 57         char* pointer = static_cast&lt;char*&gt;(passedPointer);
 58 
 59         // It could point to a large allocation.
 60         if (heap.objectSpace().largeAllocationsForThisCollectionSize()) {
 61             if (heap.objectSpace().largeAllocationsForThisCollectionBegin()[0]-&gt;aboveLowerBound(pointer)
 62                 &amp;&amp; heap.objectSpace().largeAllocationsForThisCollectionEnd()[-1]-&gt;belowUpperBound(pointer)) {
 63                 LargeAllocation** result = approximateBinarySearch&lt;LargeAllocation*&gt;(
 64                     heap.objectSpace().largeAllocationsForThisCollectionBegin(),
 65                     heap.objectSpace().largeAllocationsForThisCollectionSize(),
 66                     LargeAllocation::fromCell(pointer),
 67                     [] (LargeAllocation** ptr) -&gt; LargeAllocation* { return *ptr; });
 68                 if (result) {
 69                     auto attemptLarge = [&amp;] (LargeAllocation* allocation) {
 70                         if (allocation-&gt;contains(pointer))
 71                             func(allocation-&gt;cell(), allocation-&gt;attributes().cellKind);
 72                     };
 73 
 74                     if (result &gt; heap.objectSpace().largeAllocationsForThisCollectionBegin())
 75                         attemptLarge(result[-1]);
 76                     attemptLarge(result[0]);
 77                     if (result + 1 &lt; heap.objectSpace().largeAllocationsForThisCollectionEnd())
 78                         attemptLarge(result[1]);
 79                 }
 80             }
 81         }
 82 
 83         MarkedBlock* candidate = MarkedBlock::blockFor(pointer);
 84         // It&#39;s possible for a butterfly pointer to point past the end of a butterfly. Check this now.
 85         if (pointer &lt;= bitwise_cast&lt;char*&gt;(candidate) + sizeof(IndexingHeader)) {
 86             // We may be interested in the last cell of the previous MarkedBlock.
 87             char* previousPointer = bitwise_cast&lt;char*&gt;(bitwise_cast&lt;uintptr_t&gt;(pointer) - sizeof(IndexingHeader) - 1);
 88             MarkedBlock* previousCandidate = MarkedBlock::blockFor(previousPointer);
 89             if (!filter.ruleOut(bitwise_cast&lt;Bits&gt;(previousCandidate))
 90                 &amp;&amp; set.contains(previousCandidate)
 91                 &amp;&amp; hasInteriorPointers(previousCandidate-&gt;handle().cellKind())) {
 92                 previousPointer = static_cast&lt;char*&gt;(previousCandidate-&gt;handle().cellAlign(previousPointer));
 93                 if (previousCandidate-&gt;handle().isLiveCell(markingVersion, newlyAllocatedVersion, isMarking, previousPointer))
 94                     func(previousPointer, previousCandidate-&gt;handle().cellKind());
 95             }
 96         }
 97 
 98         if (filter.ruleOut(bitwise_cast&lt;Bits&gt;(candidate))) {
 99             ASSERT(!candidate || !set.contains(candidate));
100             return;
101         }
102 
103         if (!set.contains(candidate))
104             return;
105 
106         HeapCell::Kind cellKind = candidate-&gt;handle().cellKind();
107 
108         auto tryPointer = [&amp;] (void* pointer) {
109             if (candidate-&gt;handle().isLiveCell(markingVersion, newlyAllocatedVersion, isMarking, pointer))
110                 func(pointer, cellKind);
111         };
112 
113         if (isJSCellKind(cellKind)) {
114             if (MarkedBlock::isAtomAligned(pointer))
115                 tryPointer(pointer);
116             if (!hasInteriorPointers(cellKind))
117                 return;
118         }
119 
120         // A butterfly could point into the middle of an object.
121         char* alignedPointer = static_cast&lt;char*&gt;(candidate-&gt;handle().cellAlign(pointer));
122         tryPointer(alignedPointer);
123 
124         // Also, a butterfly could point at the end of an object plus sizeof(IndexingHeader). In that
125         // case, this is pointing to the object to the right of the one we should be marking.
126         if (candidate-&gt;atomNumber(alignedPointer) &gt; 0
127             &amp;&amp; pointer &lt;= alignedPointer + sizeof(IndexingHeader))
128             tryPointer(alignedPointer - candidate-&gt;cellSize());
129     }
130 
131     static bool isPointerGCObjectJSCell(
132         Heap&amp; heap, TinyBloomFilter filter, const void* pointer)
133     {
134         // It could point to a large allocation.
135         const Vector&lt;LargeAllocation*&gt;&amp; largeAllocations = heap.objectSpace().largeAllocations();
136         if (!largeAllocations.isEmpty()) {
137             if (largeAllocations[0]-&gt;aboveLowerBound(pointer)
138                 &amp;&amp; largeAllocations.last()-&gt;belowUpperBound(pointer)) {
139                 LargeAllocation*const* result = approximateBinarySearch&lt;LargeAllocation*const&gt;(
140                     largeAllocations.begin(), largeAllocations.size(),
141                     LargeAllocation::fromCell(pointer),
142                     [] (LargeAllocation*const* ptr) -&gt; LargeAllocation* { return *ptr; });
143                 if (result) {
144                     if (result &gt; largeAllocations.begin()
145                         &amp;&amp; result[-1]-&gt;cell() == pointer
146                         &amp;&amp; isJSCellKind(result[-1]-&gt;attributes().cellKind))
147                         return true;
148                     if (result[0]-&gt;cell() == pointer
149                         &amp;&amp; isJSCellKind(result[0]-&gt;attributes().cellKind))
150                         return true;
151                     if (result + 1 &lt; largeAllocations.end()
152                         &amp;&amp; result[1]-&gt;cell() == pointer
153                         &amp;&amp; isJSCellKind(result[1]-&gt;attributes().cellKind))
154                         return true;
155                 }
156             }
157         }
158 
159         const HashSet&lt;MarkedBlock*&gt;&amp; set = heap.objectSpace().blocks().set();
160 
161         MarkedBlock* candidate = MarkedBlock::blockFor(pointer);
162         if (filter.ruleOut(bitwise_cast&lt;Bits&gt;(candidate))) {
163             ASSERT(!candidate || !set.contains(candidate));
164             return false;
165         }
166 
167         if (!MarkedBlock::isAtomAligned(pointer))
168             return false;
169 
170         if (!set.contains(candidate))
171             return false;
172 
173         if (candidate-&gt;handle().cellKind() != HeapCell::JSCell)
174             return false;
175 
176         if (!candidate-&gt;handle().isLiveCell(pointer))
177             return false;
178 
179         return true;
180     }
181 
182     static bool isValueGCObject(
183         Heap&amp; heap, TinyBloomFilter filter, JSValue value)
184     {
185         if (!value.isCell())
186             return false;
187         return isPointerGCObjectJSCell(heap, filter, static_cast&lt;void*&gt;(value.asCell()));
188     }
189 };
190 
191 } // namespace JSC
192 
    </pre>
  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/css/parser/SizesAttributeParser.cpp b/modules/javafx.web/src/main/native/Source/WebCore/css/parser/SizesAttributeParser.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/css/parser/SizesAttributeParser.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/css/parser/SizesAttributeParser.cpp
@@ -42,11 +42,11 @@
 #include "SizesCalcParser.h"
 #include "StyleScope.h"
 
 namespace WebCore {
 
-float SizesAttributeParser::computeLength(double value, CSSPrimitiveValue::UnitType type, const Document& document)
+float SizesAttributeParser::computeLength(double value, CSSUnitType type, const Document& document)
 {
     auto* renderer = document.renderView();
     if (!renderer)
         return 0;
     auto& style = renderer->style();
@@ -56,25 +56,24 @@
     // Because we evaluate "sizes" at parse time (before style has been resolved), the font metrics used for these specific units
     // are not available. The font selector's internal consistency isn't guaranteed just yet, so we can just temporarily clear
     // the pointer to it for the duration of the unit evaluation. This is acceptible because the style always comes from the
     // RenderView, which has its font information hardcoded in resolveForDocument() to be -webkit-standard, whose operations
     // don't require a font selector.
-    if (type == CSSPrimitiveValue::CSS_EXS || type == CSSPrimitiveValue::CSS_CHS) {
+    if (type == CSSUnitType::CSS_EXS || type == CSSUnitType::CSS_CHS) {
         RefPtr<FontSelector> fontSelector = style.fontCascade().fontSelector();
         style.fontCascade().update(nullptr);
         float result = CSSPrimitiveValue::computeNonCalcLengthDouble(conversionData, type, value);
         style.fontCascade().update(fontSelector.get());
         return result;
     }
 
     return clampTo<float>(CSSPrimitiveValue::computeNonCalcLengthDouble(conversionData, type, value));
 }
 
-SizesAttributeParser::SizesAttributeParser(const String& attribute, const Document& document)
+SizesAttributeParser::SizesAttributeParser(const String& attribute, const Document& document, MediaQueryDynamicResults* mediaQueryDynamicResults)
     : m_document(document)
-    , m_length(0)
-    , m_lengthWasSet(false)
+    , m_mediaQueryDynamicResults(mediaQueryDynamicResults)
 {
     m_isValid = parse(CSSTokenizer(attribute).tokenRange());
 }
 
 float SizesAttributeParser::length()
@@ -113,11 +112,11 @@
     // A Media Condition cannot have a media type other than screen.
     auto* renderer = m_document.renderView();
     if (!renderer)
         return false;
     auto& style = renderer->style();
-    return MediaQueryEvaluator { "screen", m_document, &style }.evaluate(mediaCondition, const_cast<Style::Scope&>(m_document.styleScope()).resolverIfExists());
+    return MediaQueryEvaluator { "screen", m_document, &style }.evaluate(mediaCondition, m_mediaQueryDynamicResults);
 }
 
 bool SizesAttributeParser::parse(CSSParserTokenRange range)
 {
     // Split on a comma token and parse the result tokens as (media-condition, length) pairs
@@ -158,9 +157,9 @@
 {
     auto* renderer = m_document.renderView();
     if (!renderer)
         return 0;
     auto& style = renderer->style();
-    return clampTo<float>(CSSPrimitiveValue::computeNonCalcLengthDouble({ &style, &style, renderer }, CSSPrimitiveValue::CSS_VW, 100.0));
+    return clampTo<float>(CSSPrimitiveValue::computeNonCalcLengthDouble({ &style, &style, renderer }, CSSUnitType::CSS_VW, 100.0));
 }
 
 } // namespace WebCore

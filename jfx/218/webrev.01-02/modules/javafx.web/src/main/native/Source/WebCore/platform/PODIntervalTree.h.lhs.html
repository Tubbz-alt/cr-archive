<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/PODIntervalTree.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.
<a name="1" id="anc1"></a>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 21  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 23  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
<a name="2" id="anc2"></a><span class="line-modified"> 26 #ifndef PODIntervalTree_h</span>
<span class="line-removed"> 27 #define PODIntervalTree_h</span>
 28 
 29 #include &quot;PODInterval.h&quot;
 30 #include &quot;PODRedBlackTree.h&quot;
<a name="3" id="anc3"></a><span class="line-removed"> 31 #include &lt;wtf/Assertions.h&gt;</span>
<span class="line-removed"> 32 #include &lt;wtf/Noncopyable.h&gt;</span>
 33 #include &lt;wtf/Optional.h&gt;
 34 #include &lt;wtf/Vector.h&gt;
<a name="4" id="anc4"></a><span class="line-removed"> 35 #include &lt;wtf/text/ValueToString.h&gt;</span>
 36 
<a name="5" id="anc5"></a><span class="line-modified"> 37 namespace WebCore {</span>
<span class="line-removed"> 38 </span>
<span class="line-removed"> 39 template &lt;class T, class UserData = void*&gt;</span>
<span class="line-removed"> 40 class PODIntervalSearchAdapter {</span>
<span class="line-removed"> 41 public:</span>
<span class="line-removed"> 42     typedef PODInterval&lt;T, UserData&gt; IntervalType;</span>
 43 
<a name="6" id="anc6"></a><span class="line-modified"> 44     PODIntervalSearchAdapter(Vector&lt;IntervalType&gt;&amp; result, const T&amp; lowValue, const T&amp; highValue)</span>
<span class="line-removed"> 45         : m_result(result)</span>
<span class="line-removed"> 46         , m_lowValue(lowValue)</span>
<span class="line-removed"> 47         , m_highValue(highValue)</span>
<span class="line-removed"> 48     {</span>
<span class="line-removed"> 49     }</span>
<span class="line-removed"> 50 </span>
<span class="line-removed"> 51     const T&amp; lowValue() const { return m_lowValue; }</span>
<span class="line-removed"> 52     const T&amp; highValue() const { return m_highValue; }</span>
<span class="line-removed"> 53     void collectIfNeeded(const IntervalType&amp; data) const</span>
<span class="line-removed"> 54     {</span>
<span class="line-removed"> 55         if (data.overlaps(m_lowValue, m_highValue))</span>
<span class="line-removed"> 56             m_result.append(data);</span>
<span class="line-removed"> 57     }</span>
 58 
<a name="7" id="anc7"></a><span class="line-modified"> 59 private:</span>
<span class="line-removed"> 60     Vector&lt;IntervalType&gt;&amp; m_result;</span>
<span class="line-removed"> 61     T m_lowValue;</span>
<span class="line-removed"> 62     T m_highValue;</span>
<span class="line-removed"> 63 };</span>
 64 
 65 // An interval tree, which is a form of augmented red-black tree. It
 66 // supports efficient (O(lg n)) insertion, removal and querying of
 67 // intervals in the tree.
<a name="8" id="anc8"></a><span class="line-modified"> 68 template&lt;class T, class UserData = void*&gt;</span>
<span class="line-removed"> 69 class PODIntervalTree : public PODRedBlackTree&lt;PODInterval&lt;T, UserData&gt;&gt; {</span>
 70     WTF_MAKE_FAST_ALLOCATED;
<a name="9" id="anc9"></a><span class="line-removed"> 71     WTF_MAKE_NONCOPYABLE(PODIntervalTree);</span>
 72 public:
<a name="10" id="anc10"></a><span class="line-modified"> 73     // Typedef to reduce typing when declaring intervals to be stored in</span>
<span class="line-modified"> 74     // this tree.</span>
<span class="line-removed"> 75     typedef PODInterval&lt;T, UserData&gt; IntervalType;</span>
<span class="line-removed"> 76     typedef PODIntervalSearchAdapter&lt;T, UserData&gt; IntervalSearchAdapterType;</span>
<span class="line-removed"> 77 </span>
<span class="line-removed"> 78     PODIntervalTree()</span>
<span class="line-removed"> 79         : PODRedBlackTree&lt;IntervalType&gt;()</span>
<span class="line-removed"> 80     {</span>
<span class="line-removed"> 81         init();</span>
<span class="line-removed"> 82     }</span>
 83 
<a name="11" id="anc11"></a><span class="line-modified"> 84     // Returns all intervals in the tree which overlap the given query</span>
<span class="line-removed"> 85     // interval. The returned intervals are sorted by increasing low</span>
<span class="line-removed"> 86     // endpoint.</span>
 87     Vector&lt;IntervalType&gt; allOverlaps(const IntervalType&amp; interval) const
 88     {
 89         Vector&lt;IntervalType&gt; result;
<a name="12" id="anc12"></a><span class="line-modified"> 90         allOverlaps(interval, result);</span>

 91         return result;
 92     }
 93 
<a name="13" id="anc13"></a><span class="line-modified"> 94     // Returns all intervals in the tree which overlap the given query</span>
<span class="line-removed"> 95     // interval. The returned intervals are sorted by increasing low</span>
<span class="line-removed"> 96     // endpoint.</span>
<span class="line-removed"> 97     void allOverlaps(const IntervalType&amp; interval, Vector&lt;IntervalType&gt;&amp; result) const</span>
<span class="line-removed"> 98     {</span>
<span class="line-removed"> 99         // Explicit dereference of &quot;this&quot; required because of</span>
<span class="line-removed">100         // inheritance rules in template classes.</span>
<span class="line-removed">101         IntervalSearchAdapterType adapter(result, interval.low(), interval.high());</span>
<span class="line-removed">102         searchForOverlapsFrom&lt;IntervalSearchAdapterType&gt;(this-&gt;root(), adapter);</span>
<span class="line-removed">103     }</span>
<span class="line-removed">104 </span>
<span class="line-removed">105     template &lt;class AdapterType&gt;</span>
<span class="line-removed">106     void allOverlapsWithAdapter(AdapterType&amp; adapter) const</span>
107     {
<a name="14" id="anc14"></a><span class="line-modified">108         // Explicit dereference of &quot;this&quot; required because of</span>
<span class="line-removed">109         // inheritance rules in template classes.</span>
<span class="line-removed">110         searchForOverlapsFrom&lt;AdapterType&gt;(this-&gt;root(), adapter);</span>
111     }
112 
<a name="15" id="anc15"></a><span class="line-modified">113     // Helper to create interval objects.</span>
<span class="line-removed">114     static IntervalType createInterval(const T&amp; low, const T&amp; high, const UserData data = 0)</span>
115     {
<a name="16" id="anc16"></a><span class="line-modified">116         return IntervalType(low, high, data);</span>
<span class="line-removed">117     }</span>
<span class="line-removed">118 </span>
<span class="line-removed">119     Optional&lt;IntervalType&gt; nextIntervalAfter(const IntervalType&amp; interval)</span>
<span class="line-removed">120     {</span>
<span class="line-removed">121         auto next = smallestNodeGreaterThanFrom(interval, this-&gt;root());</span>
122         if (!next)
123             return WTF::nullopt;
<a name="17" id="anc17"></a><span class="line-removed">124 </span>
125         return next-&gt;data();
126     }
127 
<a name="18" id="anc18"></a><span class="line-modified">128     bool checkInvariants() const override</span>


129     {
<a name="19" id="anc19"></a><span class="line-modified">130         if (!PODRedBlackTree&lt;IntervalType&gt;::checkInvariants())</span>
131             return false;
132         if (!this-&gt;root())
133             return true;
<a name="20" id="anc20"></a><span class="line-modified">134         return checkInvariantsFromNode(this-&gt;root(), 0);</span>
135     }
136 
<a name="21" id="anc21"></a><span class="line-modified">137 private:</span>
<span class="line-removed">138     typedef typename PODRedBlackTree&lt;IntervalType&gt;::Node IntervalNode;</span>
139 
<a name="22" id="anc22"></a><span class="line-modified">140     // Initializes the tree.</span>
<span class="line-modified">141     void init()</span>
<span class="line-modified">142     {</span>
<span class="line-removed">143         // Explicit dereference of &quot;this&quot; required because of</span>
<span class="line-removed">144         // inheritance rules in template classes.</span>
<span class="line-removed">145         this-&gt;setNeedsFullOrderingComparisons(true);</span>
<span class="line-removed">146     }</span>
147 
148     // Starting from the given node, adds all overlaps with the given
149     // interval to the result vector. The intervals are sorted by
150     // increasing low endpoint.
<a name="23" id="anc23"></a><span class="line-modified">151     template &lt;class AdapterType&gt;</span>
<span class="line-removed">152     void searchForOverlapsFrom(IntervalNode* node, AdapterType&amp; adapter) const</span>
153     {
154         if (!node)
155             return;
156 
157         // Because the intervals are sorted by left endpoint, inorder
158         // traversal produces results sorted as desired.
159 
160         // See whether we need to traverse the left subtree.
161         IntervalNode* left = node-&gt;left();
162         if (left
163             // This is phrased this way to avoid the need for operator
164             // &lt;= on type T.
165             &amp;&amp; !(left-&gt;data().maxHigh() &lt; adapter.lowValue()))
166             searchForOverlapsFrom&lt;AdapterType&gt;(left, adapter);
167 
168         // Check for overlap with current node.
169         adapter.collectIfNeeded(node-&gt;data());
170 
171         // See whether we need to traverse the right subtree.
172         // This is phrased this way to avoid the need for operator &lt;=
173         // on type T.
174         if (!(adapter.highValue() &lt; node-&gt;data().low()))
175             searchForOverlapsFrom&lt;AdapterType&gt;(node-&gt;right(), adapter);
176     }
177 
<a name="24" id="anc24"></a><span class="line-modified">178     IntervalNode* smallestNodeGreaterThanFrom(const IntervalType&amp; interval, IntervalNode* node) const</span>
179     {
180         if (!node)
181             return nullptr;
182 
<a name="25" id="anc25"></a><span class="line-modified">183         if (!(interval.high() &lt; node-&gt;data().low()))</span>
<span class="line-modified">184             return smallestNodeGreaterThanFrom(interval, node-&gt;right());</span>
185 
<a name="26" id="anc26"></a><span class="line-modified">186         if (auto left = smallestNodeGreaterThanFrom(interval, node-&gt;right()))</span>
187             return left;
188 
189         return node;
<a name="27" id="anc27"></a><span class="line-removed">190 }</span>
<span class="line-removed">191 </span>
<span class="line-removed">192     bool updateNode(IntervalNode* node) override</span>
<span class="line-removed">193     {</span>
<span class="line-removed">194         // Would use const T&amp;, but need to reassign this reference in this</span>
<span class="line-removed">195         // function.</span>
<span class="line-removed">196         const T* curMax = &amp;node-&gt;data().high();</span>
<span class="line-removed">197         IntervalNode* left = node-&gt;left();</span>
<span class="line-removed">198         if (left) {</span>
<span class="line-removed">199             if (*curMax &lt; left-&gt;data().maxHigh())</span>
<span class="line-removed">200                 curMax = &amp;left-&gt;data().maxHigh();</span>
<span class="line-removed">201         }</span>
<span class="line-removed">202         IntervalNode* right = node-&gt;right();</span>
<span class="line-removed">203         if (right) {</span>
<span class="line-removed">204             if (*curMax &lt; right-&gt;data().maxHigh())</span>
<span class="line-removed">205                 curMax = &amp;right-&gt;data().maxHigh();</span>
<span class="line-removed">206         }</span>
<span class="line-removed">207         // This is phrased like this to avoid needing operator!= on type T.</span>
<span class="line-removed">208         if (!(*curMax == node-&gt;data().maxHigh())) {</span>
<span class="line-removed">209             node-&gt;data().setMaxHigh(*curMax);</span>
<span class="line-removed">210             return true;</span>
<span class="line-removed">211         }</span>
<span class="line-removed">212         return false;</span>
213     }
214 
<a name="28" id="anc28"></a>

215     bool checkInvariantsFromNode(IntervalNode* node, T* currentMaxValue) const
216     {
217         // These assignments are only done in order to avoid requiring
218         // a default constructor on type T.
219         T leftMaxValue(node-&gt;data().maxHigh());
220         T rightMaxValue(node-&gt;data().maxHigh());
221         IntervalNode* left = node-&gt;left();
222         IntervalNode* right = node-&gt;right();
223         if (left) {
224             if (!checkInvariantsFromNode(left, &amp;leftMaxValue))
225                 return false;
226         }
227         if (right) {
228             if (!checkInvariantsFromNode(right, &amp;rightMaxValue))
229                 return false;
230         }
231         if (!left &amp;&amp; !right) {
232             // Base case.
233             if (currentMaxValue)
234                 *currentMaxValue = node-&gt;data().high();
235             return (node-&gt;data().high() == node-&gt;data().maxHigh());
236         }
237         T localMaxValue(node-&gt;data().maxHigh());
238         if (!left || !right) {
239             if (left)
240                 localMaxValue = leftMaxValue;
241             else
242                 localMaxValue = rightMaxValue;
243         } else
244             localMaxValue = (leftMaxValue &lt; rightMaxValue) ? rightMaxValue : leftMaxValue;
245         if (localMaxValue &lt; node-&gt;data().high())
246             localMaxValue = node-&gt;data().high();
247         if (!(localMaxValue == node-&gt;data().maxHigh())) {
<a name="29" id="anc29"></a><span class="line-modified">248 #ifndef NDEBUG</span>
<span class="line-modified">249             String localMaxValueString = ValueToString&lt;T&gt;::string(localMaxValue);</span>
<span class="line-modified">250             LOG_ERROR(&quot;PODIntervalTree verification failed at node 0x%p: localMaxValue=%s and data=%s&quot;,</span>
<span class="line-modified">251                       node, localMaxValueString.utf8().data(), node-&gt;data().toString().utf8().data());</span>
<span class="line-removed">252 #endif</span>
253             return false;
254         }
255         if (currentMaxValue)
256             *currentMaxValue = localMaxValue;
257         return true;
258     }
<a name="30" id="anc30"></a>


259 };
260 
<a name="31" id="anc31"></a><span class="line-modified">261 } // namespace WebCore</span>


262 
<a name="32" id="anc32"></a><span class="line-modified">263 #ifndef NDEBUG</span>
<span class="line-modified">264 namespace WTF {</span>



265 
<a name="33" id="anc33"></a><span class="line-modified">266 // Support for printing PODIntervals at the PODRedBlackTree level.</span>
<span class="line-modified">267 template&lt;class T, class UserData&gt;</span>
<span class="line-modified">268 struct ValueToString&lt;WebCore::PODInterval&lt;T, UserData&gt;&gt; {</span>
<span class="line-removed">269     static String string(const WebCore::PODInterval&lt;T, UserData&gt;&amp; interval)</span>
270     {
<a name="34" id="anc34"></a><span class="line-modified">271         return interval.toString();</span>

272     }
<a name="35" id="anc35"></a>



273 };
274 
<a name="36" id="anc36"></a><span class="line-modified">275 } // namespace WTF</span>
<span class="line-modified">276 #endif</span>




















277 
<a name="37" id="anc37"></a><span class="line-modified">278 #endif // PODIntervalTree_h</span>
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
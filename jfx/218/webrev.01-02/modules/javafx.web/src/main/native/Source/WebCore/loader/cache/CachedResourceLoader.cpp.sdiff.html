<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResourceLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CachedResourceClient.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CachedResourceLoader.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResourceLoader.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  28 #include &quot;CachedResourceLoader.h&quot;
  29 
  30 #include &quot;CachedCSSStyleSheet.h&quot;
  31 #include &quot;CachedFont.h&quot;
  32 #include &quot;CachedImage.h&quot;
  33 #include &quot;CachedRawResource.h&quot;
  34 #include &quot;CachedResourceRequest.h&quot;
  35 #include &quot;CachedSVGDocument.h&quot;
  36 #include &quot;CachedSVGFont.h&quot;
  37 #include &quot;CachedScript.h&quot;
  38 #include &quot;CachedXSLStyleSheet.h&quot;
  39 #include &quot;Chrome.h&quot;
  40 #include &quot;ChromeClient.h&quot;
  41 #include &quot;ContentExtensionError.h&quot;
  42 #include &quot;ContentExtensionRule.h&quot;
  43 #include &quot;ContentRuleListResults.h&quot;
  44 #include &quot;ContentSecurityPolicy.h&quot;
  45 #include &quot;CrossOriginAccessControl.h&quot;
  46 #include &quot;CustomHeaderFields.h&quot;
  47 #include &quot;DOMWindow.h&quot;

  48 #include &quot;DiagnosticLoggingClient.h&quot;
  49 #include &quot;DiagnosticLoggingKeys.h&quot;
  50 #include &quot;Document.h&quot;
  51 #include &quot;DocumentLoader.h&quot;
  52 #include &quot;Frame.h&quot;
  53 #include &quot;FrameLoader.h&quot;
  54 #include &quot;FrameLoaderClient.h&quot;
  55 #include &quot;HTMLElement.h&quot;
  56 #include &quot;HTMLFrameOwnerElement.h&quot;
  57 #include &quot;HTTPHeaderField.h&quot;

  58 #include &quot;LoaderStrategy.h&quot;
  59 #include &quot;LocalizedStrings.h&quot;
  60 #include &quot;Logging.h&quot;
  61 #include &quot;MemoryCache.h&quot;
  62 #include &quot;Page.h&quot;
  63 #include &quot;PingLoader.h&quot;
  64 #include &quot;PlatformStrategies.h&quot;
  65 #include &quot;RenderElement.h&quot;
  66 #include &quot;ResourceLoadInfo.h&quot;
  67 #include &quot;ResourceTiming.h&quot;

  68 #include &quot;RuntimeEnabledFeatures.h&quot;
  69 #include &quot;ScriptController.h&quot;
  70 #include &quot;SecurityOrigin.h&quot;
  71 #include &quot;SecurityPolicy.h&quot;
  72 #include &quot;ServiceWorker.h&quot;
  73 #include &quot;Settings.h&quot;
  74 #include &quot;StyleSheetContents.h&quot;
  75 #include &quot;SubresourceLoader.h&quot;
  76 #include &quot;UserContentController.h&quot;
  77 #include &quot;UserStyleSheet.h&quot;
  78 #include &lt;pal/SessionID.h&gt;
  79 #include &lt;wtf/text/CString.h&gt;
  80 #include &lt;wtf/text/WTFString.h&gt;
  81 
  82 #if ENABLE(APPLICATION_MANIFEST)
  83 #include &quot;CachedApplicationManifest.h&quot;
  84 #endif
  85 
  86 #if ENABLE(VIDEO_TRACK)
  87 #include &quot;CachedTextTrack.h&quot;
  88 #endif
  89 




  90 #undef RELEASE_LOG_IF_ALLOWED
  91 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - CachedResourceLoader::&quot; fmt, this, ##__VA_ARGS__)
  92 
  93 namespace WebCore {
  94 
  95 // Timeout for link preloads to be used after window.onload
  96 static const Seconds unusedPreloadTimeout { 3_s };
  97 
  98 template &lt;typename T, typename U&gt;
  99 static inline ResourceErrorOr&lt;CachedResourceHandle&lt;T&gt;&gt; castCachedResourceTo(ResourceErrorOr&lt;CachedResourceHandle&lt;U&gt;&gt;&amp;&amp; cachedResource)
 100 {
 101     if (cachedResource)
 102         return CachedResourceHandle&lt;T&gt; { static_cast&lt;T*&gt;(cachedResource.value().get()) };
 103     return makeUnexpected(cachedResource.error());
 104 }
 105 
 106 static CachedResource* createResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 107 {
 108     switch (type) {
 109     case CachedResource::Type::ImageResource:
</pre>
<hr />
<pre>
 170     m_unusedPreloadsTimer.stop();
 171 }
 172 
 173 CachedResource* CachedResourceLoader::cachedResource(const String&amp; resourceURL) const
 174 {
 175     ASSERT(!resourceURL.isNull());
 176     return cachedResource(MemoryCache::removeFragmentIdentifierIfNeeded(m_document-&gt;completeURL(resourceURL)));
 177 }
 178 
 179 CachedResource* CachedResourceLoader::cachedResource(const URL&amp; url) const
 180 {
 181     ASSERT(!MemoryCache::shouldRemoveFragmentIdentifier(url));
 182     return m_documentResources.get(url).get();
 183 }
 184 
 185 Frame* CachedResourceLoader::frame() const
 186 {
 187     return m_documentLoader ? m_documentLoader-&gt;frame() : nullptr;
 188 }
 189 
<span class="line-removed"> 190 PAL::SessionID CachedResourceLoader::sessionID() const</span>
<span class="line-removed"> 191 {</span>
<span class="line-removed"> 192     auto sessionID = PAL::SessionID::defaultSessionID();</span>
<span class="line-removed"> 193     if (auto* frame = this-&gt;frame()) {</span>
<span class="line-removed"> 194         if (auto* page = frame-&gt;page())</span>
<span class="line-removed"> 195             sessionID = page-&gt;sessionID();</span>
<span class="line-removed"> 196     }</span>
<span class="line-removed"> 197     return sessionID;</span>
<span class="line-removed"> 198 }</span>
<span class="line-removed"> 199 </span>
 200 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedImage&gt;&gt; CachedResourceLoader::requestImage(CachedResourceRequest&amp;&amp; request)
 201 {
 202     if (Frame* frame = this-&gt;frame()) {
 203         if (frame-&gt;loader().pageDismissalEventBeingDispatched() != FrameLoader::PageDismissalType::None) {
 204             if (Document* document = frame-&gt;document())
 205                 request.upgradeInsecureRequestIfNeeded(*document);
 206             URL requestURL = request.resourceRequest().url();
 207             if (requestURL.isValid() &amp;&amp; canRequest(CachedResource::Type::ImageResource, requestURL, request, ForPreload::No))
 208                 PingLoader::loadImage(*frame, requestURL);
 209             return CachedResourceHandle&lt;CachedImage&gt; { };
 210         }
 211     }
 212 
 213     auto defer = clientDefersImage(request.resourceRequest().url()) ? DeferOption::DeferredByClient : DeferOption::NoDefer;
 214     return castCachedResourceTo&lt;CachedImage&gt;(requestResource(CachedResource::Type::ImageResource, WTFMove(request), ForPreload::No, defer));
 215 }
 216 
 217 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedFont&gt;&gt; CachedResourceLoader::requestFont(CachedResourceRequest&amp;&amp; request, bool isSVG)
 218 {
 219 #if ENABLE(SVG_FONTS)
</pre>
<hr />
<pre>
 229 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedTextTrack&gt;&gt; CachedResourceLoader::requestTextTrack(CachedResourceRequest&amp;&amp; request)
 230 {
 231     return castCachedResourceTo&lt;CachedTextTrack&gt;(requestResource(CachedResource::Type::TextTrackResource, WTFMove(request)));
 232 }
 233 #endif
 234 
 235 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedCSSStyleSheet&gt;&gt; CachedResourceLoader::requestCSSStyleSheet(CachedResourceRequest&amp;&amp; request)
 236 {
 237     return castCachedResourceTo&lt;CachedCSSStyleSheet&gt;(requestResource(CachedResource::Type::CSSStyleSheet, WTFMove(request)));
 238 }
 239 
 240 CachedResourceHandle&lt;CachedCSSStyleSheet&gt; CachedResourceLoader::requestUserCSSStyleSheet(Page&amp; page, CachedResourceRequest&amp;&amp; request)
 241 {
 242     request.setDestinationIfNotSet(FetchOptions::Destination::Style);
 243 
 244     ASSERT(document());
 245     request.setDomainForCachePartition(*document());
 246 
 247     auto&amp; memoryCache = MemoryCache::singleton();
 248     if (request.allowsCaching()) {
<span class="line-modified"> 249         if (CachedResource* existing = memoryCache.resourceForRequest(request.resourceRequest(), sessionID())) {</span>
 250             if (is&lt;CachedCSSStyleSheet&gt;(*existing))
 251                 return downcast&lt;CachedCSSStyleSheet&gt;(existing);
 252             memoryCache.remove(*existing);
 253         }
 254     }
 255 
 256     request.removeFragmentIdentifierIfNeeded();
 257 
 258     CachedResourceHandle&lt;CachedCSSStyleSheet&gt; userSheet = new CachedCSSStyleSheet(WTFMove(request), page.sessionID(), &amp;page.cookieJar());
 259 
 260     if (userSheet-&gt;allowsCaching())
 261         memoryCache.add(*userSheet);
 262 
 263     userSheet-&gt;load(*this);
 264     return userSheet;
 265 }
 266 
 267 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedScript&gt;&gt; CachedResourceLoader::requestScript(CachedResourceRequest&amp;&amp; request)
 268 {
 269     return castCachedResourceTo&lt;CachedScript&gt;(requestResource(CachedResource::Type::Script, WTFMove(request)));
</pre>
<hr />
<pre>
 495     return url.protocolIsData() &amp;&amp; options.sameOriginDataURLFlag == SameOriginDataURLFlag::Set;
 496 }
 497 
 498 // Security checks defined in https://fetch.spec.whatwg.org/#main-fetch step 2 and 5.
 499 bool CachedResourceLoader::canRequest(CachedResource::Type type, const URL&amp; url, const CachedResourceRequest&amp; request, ForPreload forPreload)
 500 {
 501     auto&amp; options = request.options();
 502 
 503     if (document() &amp;&amp; !document()-&gt;securityOrigin().canDisplay(url)) {
 504         if (forPreload == ForPreload::No)
 505             FrameLoader::reportLocalLoadFailed(frame(), url.stringCenterEllipsizedToLength());
 506         LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource URL was not allowed by SecurityOrigin::canDisplay&quot;);
 507         return false;
 508     }
 509 
 510     if (options.mode == FetchOptions::Mode::SameOrigin &amp;&amp; !m_document-&gt;securityOrigin().canRequest(url) &amp;&amp; !isSameOriginDataURL(url, options)) {
 511         printAccessDeniedMessage(url);
 512         return false;
 513     }
 514 
<span class="line-modified"> 515     if (options.mode == FetchOptions::Mode::NoCors &amp;&amp; options.redirect != FetchOptions::Redirect::Follow &amp;&amp; type != CachedResource::Type::Ping) {</span>
 516         ASSERT(type != CachedResource::Type::MainResource);
 517         frame()-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;No-Cors mode requires follow redirect mode&quot;_s);
 518         return false;
 519     }
 520 
 521     if (!allowedByContentSecurityPolicy(type, url, options, ContentSecurityPolicy::RedirectResponseReceived::No))
 522         return false;
 523 
 524     // SVG Images have unique security rules that prevent all subresource requests except for data urls.
 525     if (type != CachedResource::Type::MainResource &amp;&amp; frame() &amp;&amp; frame()-&gt;page()) {
 526         if (frame()-&gt;page()-&gt;chrome().client().isSVGImageChromeClient() &amp;&amp; !url.protocolIsData())
 527             return false;
 528     }
 529 
 530     // Last of all, check for insecure content. We do this last so that when folks block insecure content with a CSP policy, they don&#39;t get a warning.
 531     // They&#39;ll still get a warning in the console about CSP blocking the load.
 532 
 533     // FIXME: Should we consider whether the request is for preload here?
 534     if (!checkInsecureContent(type, url))
 535         return false;
</pre>
<hr />
<pre>
 669 
 670     // If the cached resource has not followed redirections, it is incomplete and we should not use it.
 671     // Let&#39;s make sure the memory cache has no such resource.
 672     ASSERT(resource.response().type() != ResourceResponse::Type::Opaqueredirect);
 673 
 674     // We could support redirect modes other than Follow in case of a redirected resource.
 675     // This case is rare and is not worth optimizing currently.
 676     if (request.options().redirect != FetchOptions::Redirect::Follow &amp;&amp; resource.hasRedirections())
 677         return false;
 678 
 679     // FIXME: Implement reuse of cached raw resources.
 680     if (resource.type() == CachedResource::Type::RawResource || resource.type() == CachedResource::Type::MediaResource)
 681         return false;
 682 
 683     if (resource.type() == CachedResource::Type::Beacon || resource.type() == CachedResource::Type::Ping)
 684         return false;
 685 
 686     return true;
 687 }
 688 
<span class="line-modified"> 689 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::updateCachedResourceWithCurrentRequest(const CachedResource&amp; resource, CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)</span>
 690 {
 691     if (!isResourceSuitableForDirectReuse(resource, request)) {
 692         request.setCachingPolicy(CachingPolicy::DisallowCaching);
<span class="line-modified"> 693         return loadResource(resource.type(), WTFMove(request), cookieJar);</span>
 694     }
 695 
<span class="line-modified"> 696     auto resourceHandle = createResource(resource.type(), WTFMove(request), sessionID, cookieJar);</span>
 697     resourceHandle-&gt;loadFrom(resource);
 698     return resourceHandle;
 699 }
 700 
 701 static inline void logMemoryCacheResourceRequest(Frame* frame, const String&amp; key, const String&amp; description)
 702 {
 703     if (!frame || !frame-&gt;page())
 704         return;
 705     frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessage(key, description, ShouldSample::Yes);
 706 }
 707 
 708 void CachedResourceLoader::prepareFetch(CachedResource::Type type, CachedResourceRequest&amp; request)
 709 {
 710     // Implementing step 1 to 7 of https://fetch.spec.whatwg.org/#fetching
 711     auto* document = this-&gt;document();
 712 
 713     if (document) {
 714         if (!request.origin())
 715             request.setOrigin(document-&gt;securityOrigin());
 716 #if ENABLE(SERVICE_WORKER)
</pre>
<hr />
<pre>
 769         return FetchOptions::Destination::Track;
 770 #endif
 771 #if ENABLE(APPLICATION_MANIFEST)
 772     case CachedResource::Type::ApplicationManifest:
 773         return FetchOptions::Destination::Manifest;
 774 #endif
 775     case CachedResource::Type::Beacon:
 776     case CachedResource::Type::Ping:
 777     case CachedResource::Type::LinkPrefetch:
 778     case CachedResource::Type::RawResource:
 779     case CachedResource::Type::MediaResource:
 780         // The caller is responsible for setting the appropriate destination.
 781         return FetchOptions::Destination::EmptyString;
 782     }
 783     ASSERT_NOT_REACHED();
 784     return FetchOptions::Destination::EmptyString;
 785 }
 786 
 787 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::requestResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, ForPreload forPreload, DeferOption defer)
 788 {







 789     request.setDestinationIfNotSet(destinationForType(type));
 790 
 791     // Entry point to https://fetch.spec.whatwg.org/#main-fetch.
 792     std::unique_ptr&lt;ResourceRequest&gt; originalRequest;
 793     if (CachedResource::shouldUsePingLoad(type) || request.options().destination == FetchOptions::Destination::EmptyString) {
 794         originalRequest = makeUnique&lt;ResourceRequest&gt;(request.resourceRequest());
 795         originalRequest-&gt;clearHTTPReferrer();
 796         originalRequest-&gt;clearHTTPOrigin();
 797     }
 798 
 799     if (Document* document = this-&gt;document())
 800         request.upgradeInsecureRequestIfNeeded(*document);
 801 



 802     request.updateReferrerPolicy(document() ? document()-&gt;referrerPolicy() : ReferrerPolicy::NoReferrerWhenDowngrade);
 803     URL url = request.resourceRequest().url();
 804 
 805     LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource &#39;%.255s&#39;, charset &#39;%s&#39;, priority=%d, forPreload=%u&quot;, url.stringCenterEllipsizedToLength().latin1().data(), request.charset().latin1().data(), request.priority() ? static_cast&lt;int&gt;(request.priority().value()) : -1, forPreload == ForPreload::Yes);
 806 
 807     if (!url.isValid()) {
<span class="line-modified"> 808         RELEASE_LOG_IF_ALLOWED(&quot;requestResource: URL is invalid (frame = %p)&quot;, frame());</span>
 809         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;URL is invalid&quot;_s });
 810     }
 811 
 812     prepareFetch(type, request);
 813 
 814     // We are passing url as well as request, as request url may contain a fragment identifier.
 815     if (!canRequest(type, url, request, forPreload)) {
<span class="line-modified"> 816         RELEASE_LOG_IF_ALLOWED(&quot;requestResource: Not allowed to request resource (frame = %p)&quot;, frame());</span>
 817         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;Not allowed to request resource&quot;_s, ResourceError::Type::AccessControl });
 818     }
 819 
 820 #if ENABLE(CONTENT_EXTENSIONS)
<span class="line-modified"> 821     if (frame() &amp;&amp; frame()-&gt;page() &amp;&amp; m_documentLoader) {</span>
 822         const auto&amp; resourceRequest = request.resourceRequest();
<span class="line-modified"> 823         auto* page = frame()-&gt;page();</span>
<span class="line-removed"> 824         auto results = page-&gt;userContentProvider().processContentRuleListsForLoad(resourceRequest.url(), ContentExtensions::toResourceType(type), *m_documentLoader);</span>
 825         bool blockedLoad = results.summary.blockedLoad;
 826         bool madeHTTPS = results.summary.madeHTTPS;
<span class="line-modified"> 827         request.applyResults(WTFMove(results), page);</span>
 828         if (blockedLoad) {
<span class="line-modified"> 829             RELEASE_LOG_IF_ALLOWED(&quot;requestResource: Resource blocked by content blocker (frame = %p)&quot;, frame());</span>
 830             if (type == CachedResource::Type::MainResource) {
<span class="line-modified"> 831                 CachedResourceHandle&lt;CachedResource&gt; resource = createResource(type, WTFMove(request), page-&gt;sessionID(), &amp;page-&gt;cookieJar());</span>
 832                 ASSERT(resource);
 833                 resource-&gt;error(CachedResource::Status::LoadError);
 834                 resource-&gt;setResourceError(ResourceError(ContentExtensions::WebKitContentBlockerDomain, 0, resourceRequest.url(), WEB_UI_STRING(&quot;The URL was blocked by a content blocker&quot;, &quot;WebKitErrorBlockedByContentBlocker description&quot;)));
 835                 return resource;
 836             }
 837             return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;Resource blocked by content blocker&quot;_s, ResourceError::Type::AccessControl });
 838         }
 839         if (madeHTTPS
 840             &amp;&amp; type == CachedResource::Type::MainResource
 841             &amp;&amp; m_documentLoader-&gt;isLoadingMainResource()) {
 842             // This is to make sure the correct &#39;new&#39; URL shows in the location bar.
 843             m_documentLoader-&gt;frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();
 844         }
 845         url = request.resourceRequest().url(); // The content extension could have changed it from http to https.
 846         url = MemoryCache::removeFragmentIdentifierIfNeeded(url); // Might need to remove fragment identifier again.
 847     }
 848 #endif
 849 
<span class="line-modified"> 850     if (frame() &amp;&amp; m_documentLoader &amp;&amp; !m_documentLoader-&gt;customHeaderFields().isEmpty()) {</span>
 851         bool sameOriginRequest = false;
 852         auto requestedOrigin = SecurityOrigin::create(url);
 853         if (type == CachedResource::Type::MainResource) {
<span class="line-modified"> 854             if (frame()-&gt;isMainFrame())</span>
 855                 sameOriginRequest = true;
<span class="line-modified"> 856             else if (auto* topDocument = frame()-&gt;mainFrame().document())</span>
 857                 sameOriginRequest = topDocument-&gt;securityOrigin().isSameSchemeHostPort(requestedOrigin.get());
 858         } else if (document()) {
 859             sameOriginRequest = document()-&gt;topDocument().securityOrigin().isSameSchemeHostPort(requestedOrigin.get())
 860                 &amp;&amp; document()-&gt;securityOrigin().isSameSchemeHostPort(requestedOrigin.get());
 861         }
 862         for (auto&amp; fields : m_documentLoader-&gt;customHeaderFields()) {
 863             if (sameOriginRequest || fields.thirdPartyDomainsMatch(url)) {
 864                 for (auto&amp; field : fields.fields)
 865                     request.resourceRequest().setHTTPHeaderField(field.name(), field.value());
 866             }
 867         }
 868     }
 869 
 870     LoadTiming loadTiming;
 871     loadTiming.markStartTimeAndFetchStart();
 872     InitiatorContext initiatorContext = request.options().initiatorContext;
 873 
 874     if (request.resourceRequest().url().protocolIsInHTTPFamily())
 875         updateHTTPRequestHeaders(type, request);
 876 
 877     auto&amp; memoryCache = MemoryCache::singleton();
 878     if (request.allowsCaching() &amp;&amp; memoryCache.disabled())
 879         m_documentResources.remove(url.string());
 880 
 881     // See if we can use an existing resource from the cache.
 882     CachedResourceHandle&lt;CachedResource&gt; resource;
 883     if (document())
 884         request.setDomainForCachePartition(*document());
 885 
 886     if (request.allowsCaching())
<span class="line-modified"> 887         resource = memoryCache.resourceForRequest(request.resourceRequest(), sessionID());</span>
 888 
 889     if (resource &amp;&amp; request.isLinkPreload() &amp;&amp; !resource-&gt;isLinkPreload())
 890         resource-&gt;setLinkPreload();
 891 
<span class="line-modified"> 892     logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheUsageKey(), resource ? DiagnosticLoggingKeys::inMemoryCacheKey() : DiagnosticLoggingKeys::notInMemoryCacheKey());</span>
 893 
<span class="line-modified"> 894     auto* cookieJar = document() &amp;&amp; document()-&gt;page() ? &amp;document()-&gt;page()-&gt;cookieJar() : nullptr;</span>
 895 
 896     RevalidationPolicy policy = determineRevalidationPolicy(type, request, resource.get(), forPreload, defer);
 897     switch (policy) {
 898     case Reload:
 899         memoryCache.remove(*resource);
 900         FALLTHROUGH;
 901     case Load:
 902         if (resource)
<span class="line-modified"> 903             logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::unusedKey());</span>
<span class="line-modified"> 904         resource = loadResource(type, WTFMove(request), cookieJar);</span>
 905         break;
 906     case Revalidate:
 907         if (resource)
<span class="line-modified"> 908             logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::revalidatingKey());</span>
 909         resource = revalidateResource(WTFMove(request), *resource);
 910         break;
 911     case Use:
 912         ASSERT(resource);
 913         if (request.options().mode == FetchOptions::Mode::NoCors) {
 914             if (auto error = validateCrossOriginResourcePolicy(*request.origin(), request.resourceRequest().url(), resource-&gt;response()))
 915                 return makeUnexpected(WTFMove(*error));



 916         }
 917         if (shouldUpdateCachedResourceWithCurrentRequest(*resource, request)) {
<span class="line-modified"> 918             resource = updateCachedResourceWithCurrentRequest(*resource, WTFMove(request), document()-&gt;page()-&gt;sessionID(), cookieJar);</span>
 919             if (resource-&gt;status() != CachedResource::Status::Cached)
 920                 policy = Load;
 921         } else {
 922             ResourceError error;
 923             if (!shouldContinueAfterNotifyingLoadedFromMemoryCache(request, *resource, error))
 924                 return makeUnexpected(WTFMove(error));
<span class="line-modified"> 925             logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::usedKey());</span>
 926             loadTiming.setResponseEnd(MonotonicTime::now());
 927 
 928             memoryCache.resourceAccessed(*resource);
 929 
 930             if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled() &amp;&amp; document() &amp;&amp; !resource-&gt;isLoading()) {
 931                 auto resourceTiming = ResourceTiming::fromCache(url, request.initiatorName(), loadTiming, resource-&gt;response(), *request.origin());
 932                 if (initiatorContext == InitiatorContext::Worker) {
 933                     ASSERT(is&lt;CachedRawResource&gt;(resource.get()));
 934                     downcast&lt;CachedRawResource&gt;(resource.get())-&gt;finishedTimingForWorkerLoad(WTFMove(resourceTiming));
 935                 } else {
 936                     ASSERT(initiatorContext == InitiatorContext::Document);
<span class="line-modified"> 937                     m_resourceTimingInfo.storeResourceTimingInitiatorInformation(resource, request.initiatorName(), frame());</span>
 938                     m_resourceTimingInfo.addResourceTiming(*resource.get(), *document(), WTFMove(resourceTiming));
 939                 }
 940             }
 941 
 942             if (forPreload == ForPreload::No)
 943                 resource-&gt;setLoadPriority(request.priority());
 944         }
 945         break;
 946     }
 947     ASSERT(resource);
 948     resource-&gt;setOriginalRequest(WTFMove(originalRequest));
 949 
 950     if (forPreload == ForPreload::No &amp;&amp; resource-&gt;loader() &amp;&amp; resource-&gt;ignoreForRequestCount()) {
 951         resource-&gt;setIgnoreForRequestCount(false);
 952         incrementRequestCount(*resource);
 953     }
 954 
 955     if ((policy != Use || resource-&gt;stillNeedsLoad()) &amp;&amp; defer == DeferOption::NoDefer) {
 956         resource-&gt;load(*this);
 957 
</pre>
<hr />
<pre>
 981     m_validatedURLs.clear();
 982 
 983     // If m_preloads is not empty here, it&#39;s full of link preloads,
 984     // as speculative preloads were cleared at DCL.
 985     if (m_preloads &amp;&amp; m_preloads-&gt;size() &amp;&amp; !m_unusedPreloadsTimer.isActive())
 986         m_unusedPreloadsTimer.startOneShot(unusedPreloadTimeout);
 987 }
 988 
 989 void CachedResourceLoader::stopUnusedPreloadsTimer()
 990 {
 991     m_unusedPreloadsTimer.stop();
 992 }
 993 
 994 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::revalidateResource(CachedResourceRequest&amp;&amp; request, CachedResource&amp; resource)
 995 {
 996     ASSERT(resource.inCache());
 997     auto&amp; memoryCache = MemoryCache::singleton();
 998     ASSERT(!memoryCache.disabled());
 999     ASSERT(resource.canUseCacheValidator());
1000     ASSERT(!resource.resourceToRevalidate());
<span class="line-removed">1001     ASSERT(resource.sessionID() == sessionID());</span>
1002     ASSERT(resource.allowsCaching());
1003 
1004     CachedResourceHandle&lt;CachedResource&gt; newResource = createResource(resource.type(), WTFMove(request), resource.sessionID(), resource.cookieJar());
1005 
1006     LOG(ResourceLoading, &quot;Resource %p created to revalidate %p&quot;, newResource.get(), &amp;resource);
1007     newResource-&gt;setResourceToRevalidate(&amp;resource);
1008 
1009     memoryCache.remove(resource);
1010     memoryCache.add(*newResource);
1011 
1012     if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled())
1013         m_resourceTimingInfo.storeResourceTimingInitiatorInformation(newResource, newResource-&gt;initiatorName(), frame());
1014 
1015     return newResource;
1016 }
1017 
<span class="line-modified">1018 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::loadResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, const CookieJar* cookieJar)</span>
1019 {
1020     auto&amp; memoryCache = MemoryCache::singleton();
<span class="line-modified">1021     ASSERT(!request.allowsCaching() || !memoryCache.resourceForRequest(request.resourceRequest(), sessionID())</span>
1022         || request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::DoNotUseAnyCache || request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData || request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::RefreshAnyCacheData);
1023 
1024     LOG(ResourceLoading, &quot;Loading CachedResource for &#39;%s&#39;.&quot;, request.resourceRequest().url().stringCenterEllipsizedToLength().latin1().data());
1025 
<span class="line-modified">1026     CachedResourceHandle&lt;CachedResource&gt; resource = createResource(type, WTFMove(request), sessionID(), cookieJar);</span>
1027 
1028     if (resource-&gt;allowsCaching())
1029         memoryCache.add(*resource);
1030 
1031     if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled())
1032         m_resourceTimingInfo.storeResourceTimingInitiatorInformation(resource, resource-&gt;initiatorName(), frame());
1033 
1034     return resource;
1035 }
1036 
1037 static void logRevalidation(const String&amp; reason, DiagnosticLoggingClient&amp; logClient)
1038 {
1039     logClient.logDiagnosticMessage(DiagnosticLoggingKeys::cachedResourceRevalidationReasonKey(), reason, ShouldSample::Yes);
1040 }
1041 
1042 static void logResourceRevalidationDecision(CachedResource::RevalidationDecision reason, const Frame* frame)
1043 {
1044     if (!frame || !frame-&gt;page())
1045         return;
1046     auto&amp; logClient = frame-&gt;page()-&gt;diagnosticLoggingClient();
</pre>
<hr />
<pre>
1215         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to missing cache validators.&quot;);
1216         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonMustRevalidateNoValidatorKey());
1217         return Reload;
1218     }
1219 
1220     return Use;
1221 }
1222 
1223 void CachedResourceLoader::printAccessDeniedMessage(const URL&amp; url) const
1224 {
1225     if (url.isNull())
1226         return;
1227 
1228     if (!frame())
1229         return;
1230 
1231     String message;
1232     if (!m_document || m_document-&gt;url().isNull())
1233         message = makeString(&quot;Unsafe attempt to load URL &quot;, url.stringCenterEllipsizedToLength(), &#39;.&#39;);
1234     else
<span class="line-modified">1235         message = makeString(&quot;Unsafe attempt to load URL &quot;, url.stringCenterEllipsizedToLength(), &quot; from origin &quot;, m_document-&gt;origin(), &quot;. Domains, protocols and ports must match.\n&quot;);</span>
1236 
1237     frame()-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
1238 }
1239 
1240 void CachedResourceLoader::setAutoLoadImages(bool enable)
1241 {
1242     if (enable == m_autoLoadImages)
1243         return;
1244 
1245     m_autoLoadImages = enable;
1246 
1247     if (!m_autoLoadImages)
1248         return;
1249 
1250     reloadImagesIfNotDeferred();
1251 }
1252 
1253 void CachedResourceLoader::setImagesEnabled(bool enable)
1254 {
1255     if (enable == m_imagesEnabled)
</pre>
<hr />
<pre>
1279 }
1280 
1281 void CachedResourceLoader::reloadImagesIfNotDeferred()
1282 {
1283     for (auto&amp; resource : m_documentResources.values()) {
1284         if (is&lt;CachedImage&gt;(*resource) &amp;&amp; resource-&gt;stillNeedsLoad() &amp;&amp; !clientDefersImage(resource-&gt;url()))
1285             downcast&lt;CachedImage&gt;(*resource).load(*this);
1286     }
1287 }
1288 
1289 CachePolicy CachedResourceLoader::cachePolicy(CachedResource::Type type, const URL&amp; url) const
1290 {
1291     Frame* frame = this-&gt;frame();
1292     if (!frame)
1293         return CachePolicyVerify;
1294 
1295     if (type != CachedResource::Type::MainResource)
1296         return frame-&gt;loader().subresourceCachePolicy(url);
1297 
1298     if (Page* page = frame-&gt;page()) {
<span class="line-modified">1299         if (page-&gt;isResourceCachingDisabled())</span>
1300             return CachePolicyReload;
1301     }
1302 
1303     switch (frame-&gt;loader().loadType()) {
1304     case FrameLoadType::ReloadFromOrigin:
1305     case FrameLoadType::Reload:
1306         return CachePolicyReload;
1307     case FrameLoadType::Back:
1308     case FrameLoadType::Forward:
1309     case FrameLoadType::IndexedBackForward:
1310         // Do not revalidate cached main resource on back/forward navigation.
1311         return CachePolicyHistoryBuffer;
1312     default:
1313         return CachePolicyVerify;
1314     }
1315 }
1316 
1317 void CachedResourceLoader::loadDone(LoadCompletionType type, bool shouldPerformPostLoadActions)
1318 {
1319     RefPtr&lt;DocumentLoader&gt; protectDocumentLoader(m_documentLoader);
</pre>
<hr />
<pre>
1362 
1363 void CachedResourceLoader::incrementRequestCount(const CachedResource&amp; resource)
1364 {
1365     if (resource.ignoreForRequestCount())
1366         return;
1367 
1368     ++m_requestCount;
1369 }
1370 
1371 void CachedResourceLoader::decrementRequestCount(const CachedResource&amp; resource)
1372 {
1373     if (resource.ignoreForRequestCount())
1374         return;
1375 
1376     --m_requestCount;
1377     ASSERT(m_requestCount &gt; -1);
1378 }
1379 
1380 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::preload(CachedResource::Type type, CachedResourceRequest&amp;&amp; request)
1381 {



1382     if (request.charset().isEmpty() &amp;&amp; (type == CachedResource::Type::Script || type == CachedResource::Type::CSSStyleSheet))
1383         request.setCharset(m_document-&gt;charset());
1384 
1385     auto resource = requestResource(type, WTFMove(request), ForPreload::Yes);
1386     if (resource &amp;&amp; (!m_preloads || !m_preloads-&gt;contains(resource.value().get()))) {
1387         auto resourceValue = resource.value();
1388         // Fonts need special treatment since just creating the resource doesn&#39;t trigger a load.
1389         if (type == CachedResource::Type::FontResource)
1390             downcast&lt;CachedFont&gt;(resourceValue.get())-&gt;beginLoadIfNeeded(*this);
1391         resourceValue-&gt;increasePreloadCount();
1392 
1393         if (!m_preloads)
1394             m_preloads = makeUnique&lt;ListHashSet&lt;CachedResource*&gt;&gt;();
1395         m_preloads-&gt;add(resourceValue.get());
1396     }
1397     return resource;
1398 }
1399 
1400 void CachedResourceLoader::warnUnusedPreloads()
1401 {
</pre>
</td>
<td>
<hr />
<pre>
  28 #include &quot;CachedResourceLoader.h&quot;
  29 
  30 #include &quot;CachedCSSStyleSheet.h&quot;
  31 #include &quot;CachedFont.h&quot;
  32 #include &quot;CachedImage.h&quot;
  33 #include &quot;CachedRawResource.h&quot;
  34 #include &quot;CachedResourceRequest.h&quot;
  35 #include &quot;CachedSVGDocument.h&quot;
  36 #include &quot;CachedSVGFont.h&quot;
  37 #include &quot;CachedScript.h&quot;
  38 #include &quot;CachedXSLStyleSheet.h&quot;
  39 #include &quot;Chrome.h&quot;
  40 #include &quot;ChromeClient.h&quot;
  41 #include &quot;ContentExtensionError.h&quot;
  42 #include &quot;ContentExtensionRule.h&quot;
  43 #include &quot;ContentRuleListResults.h&quot;
  44 #include &quot;ContentSecurityPolicy.h&quot;
  45 #include &quot;CrossOriginAccessControl.h&quot;
  46 #include &quot;CustomHeaderFields.h&quot;
  47 #include &quot;DOMWindow.h&quot;
<span class="line-added">  48 #include &quot;DateComponents.h&quot;</span>
  49 #include &quot;DiagnosticLoggingClient.h&quot;
  50 #include &quot;DiagnosticLoggingKeys.h&quot;
  51 #include &quot;Document.h&quot;
  52 #include &quot;DocumentLoader.h&quot;
  53 #include &quot;Frame.h&quot;
  54 #include &quot;FrameLoader.h&quot;
  55 #include &quot;FrameLoaderClient.h&quot;
  56 #include &quot;HTMLElement.h&quot;
  57 #include &quot;HTMLFrameOwnerElement.h&quot;
  58 #include &quot;HTTPHeaderField.h&quot;
<span class="line-added">  59 #include &quot;InspectorInstrumentation.h&quot;</span>
  60 #include &quot;LoaderStrategy.h&quot;
  61 #include &quot;LocalizedStrings.h&quot;
  62 #include &quot;Logging.h&quot;
  63 #include &quot;MemoryCache.h&quot;
  64 #include &quot;Page.h&quot;
  65 #include &quot;PingLoader.h&quot;
  66 #include &quot;PlatformStrategies.h&quot;
  67 #include &quot;RenderElement.h&quot;
  68 #include &quot;ResourceLoadInfo.h&quot;
  69 #include &quot;ResourceTiming.h&quot;
<span class="line-added">  70 #include &quot;RuntimeApplicationChecks.h&quot;</span>
  71 #include &quot;RuntimeEnabledFeatures.h&quot;
  72 #include &quot;ScriptController.h&quot;
  73 #include &quot;SecurityOrigin.h&quot;
  74 #include &quot;SecurityPolicy.h&quot;
  75 #include &quot;ServiceWorker.h&quot;
  76 #include &quot;Settings.h&quot;
  77 #include &quot;StyleSheetContents.h&quot;
  78 #include &quot;SubresourceLoader.h&quot;
  79 #include &quot;UserContentController.h&quot;
  80 #include &quot;UserStyleSheet.h&quot;
  81 #include &lt;pal/SessionID.h&gt;
  82 #include &lt;wtf/text/CString.h&gt;
  83 #include &lt;wtf/text/WTFString.h&gt;
  84 
  85 #if ENABLE(APPLICATION_MANIFEST)
  86 #include &quot;CachedApplicationManifest.h&quot;
  87 #endif
  88 
  89 #if ENABLE(VIDEO_TRACK)
  90 #include &quot;CachedTextTrack.h&quot;
  91 #endif
  92 
<span class="line-added">  93 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">  94 #include &quot;Device.h&quot;</span>
<span class="line-added">  95 #endif</span>
<span class="line-added">  96 </span>
  97 #undef RELEASE_LOG_IF_ALLOWED
  98 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - CachedResourceLoader::&quot; fmt, this, ##__VA_ARGS__)
  99 
 100 namespace WebCore {
 101 
 102 // Timeout for link preloads to be used after window.onload
 103 static const Seconds unusedPreloadTimeout { 3_s };
 104 
 105 template &lt;typename T, typename U&gt;
 106 static inline ResourceErrorOr&lt;CachedResourceHandle&lt;T&gt;&gt; castCachedResourceTo(ResourceErrorOr&lt;CachedResourceHandle&lt;U&gt;&gt;&amp;&amp; cachedResource)
 107 {
 108     if (cachedResource)
 109         return CachedResourceHandle&lt;T&gt; { static_cast&lt;T*&gt;(cachedResource.value().get()) };
 110     return makeUnexpected(cachedResource.error());
 111 }
 112 
 113 static CachedResource* createResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 114 {
 115     switch (type) {
 116     case CachedResource::Type::ImageResource:
</pre>
<hr />
<pre>
 177     m_unusedPreloadsTimer.stop();
 178 }
 179 
 180 CachedResource* CachedResourceLoader::cachedResource(const String&amp; resourceURL) const
 181 {
 182     ASSERT(!resourceURL.isNull());
 183     return cachedResource(MemoryCache::removeFragmentIdentifierIfNeeded(m_document-&gt;completeURL(resourceURL)));
 184 }
 185 
 186 CachedResource* CachedResourceLoader::cachedResource(const URL&amp; url) const
 187 {
 188     ASSERT(!MemoryCache::shouldRemoveFragmentIdentifier(url));
 189     return m_documentResources.get(url).get();
 190 }
 191 
 192 Frame* CachedResourceLoader::frame() const
 193 {
 194     return m_documentLoader ? m_documentLoader-&gt;frame() : nullptr;
 195 }
 196 










 197 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedImage&gt;&gt; CachedResourceLoader::requestImage(CachedResourceRequest&amp;&amp; request)
 198 {
 199     if (Frame* frame = this-&gt;frame()) {
 200         if (frame-&gt;loader().pageDismissalEventBeingDispatched() != FrameLoader::PageDismissalType::None) {
 201             if (Document* document = frame-&gt;document())
 202                 request.upgradeInsecureRequestIfNeeded(*document);
 203             URL requestURL = request.resourceRequest().url();
 204             if (requestURL.isValid() &amp;&amp; canRequest(CachedResource::Type::ImageResource, requestURL, request, ForPreload::No))
 205                 PingLoader::loadImage(*frame, requestURL);
 206             return CachedResourceHandle&lt;CachedImage&gt; { };
 207         }
 208     }
 209 
 210     auto defer = clientDefersImage(request.resourceRequest().url()) ? DeferOption::DeferredByClient : DeferOption::NoDefer;
 211     return castCachedResourceTo&lt;CachedImage&gt;(requestResource(CachedResource::Type::ImageResource, WTFMove(request), ForPreload::No, defer));
 212 }
 213 
 214 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedFont&gt;&gt; CachedResourceLoader::requestFont(CachedResourceRequest&amp;&amp; request, bool isSVG)
 215 {
 216 #if ENABLE(SVG_FONTS)
</pre>
<hr />
<pre>
 226 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedTextTrack&gt;&gt; CachedResourceLoader::requestTextTrack(CachedResourceRequest&amp;&amp; request)
 227 {
 228     return castCachedResourceTo&lt;CachedTextTrack&gt;(requestResource(CachedResource::Type::TextTrackResource, WTFMove(request)));
 229 }
 230 #endif
 231 
 232 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedCSSStyleSheet&gt;&gt; CachedResourceLoader::requestCSSStyleSheet(CachedResourceRequest&amp;&amp; request)
 233 {
 234     return castCachedResourceTo&lt;CachedCSSStyleSheet&gt;(requestResource(CachedResource::Type::CSSStyleSheet, WTFMove(request)));
 235 }
 236 
 237 CachedResourceHandle&lt;CachedCSSStyleSheet&gt; CachedResourceLoader::requestUserCSSStyleSheet(Page&amp; page, CachedResourceRequest&amp;&amp; request)
 238 {
 239     request.setDestinationIfNotSet(FetchOptions::Destination::Style);
 240 
 241     ASSERT(document());
 242     request.setDomainForCachePartition(*document());
 243 
 244     auto&amp; memoryCache = MemoryCache::singleton();
 245     if (request.allowsCaching()) {
<span class="line-modified"> 246         if (CachedResource* existing = memoryCache.resourceForRequest(request.resourceRequest(), page.sessionID())) {</span>
 247             if (is&lt;CachedCSSStyleSheet&gt;(*existing))
 248                 return downcast&lt;CachedCSSStyleSheet&gt;(existing);
 249             memoryCache.remove(*existing);
 250         }
 251     }
 252 
 253     request.removeFragmentIdentifierIfNeeded();
 254 
 255     CachedResourceHandle&lt;CachedCSSStyleSheet&gt; userSheet = new CachedCSSStyleSheet(WTFMove(request), page.sessionID(), &amp;page.cookieJar());
 256 
 257     if (userSheet-&gt;allowsCaching())
 258         memoryCache.add(*userSheet);
 259 
 260     userSheet-&gt;load(*this);
 261     return userSheet;
 262 }
 263 
 264 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedScript&gt;&gt; CachedResourceLoader::requestScript(CachedResourceRequest&amp;&amp; request)
 265 {
 266     return castCachedResourceTo&lt;CachedScript&gt;(requestResource(CachedResource::Type::Script, WTFMove(request)));
</pre>
<hr />
<pre>
 492     return url.protocolIsData() &amp;&amp; options.sameOriginDataURLFlag == SameOriginDataURLFlag::Set;
 493 }
 494 
 495 // Security checks defined in https://fetch.spec.whatwg.org/#main-fetch step 2 and 5.
 496 bool CachedResourceLoader::canRequest(CachedResource::Type type, const URL&amp; url, const CachedResourceRequest&amp; request, ForPreload forPreload)
 497 {
 498     auto&amp; options = request.options();
 499 
 500     if (document() &amp;&amp; !document()-&gt;securityOrigin().canDisplay(url)) {
 501         if (forPreload == ForPreload::No)
 502             FrameLoader::reportLocalLoadFailed(frame(), url.stringCenterEllipsizedToLength());
 503         LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource URL was not allowed by SecurityOrigin::canDisplay&quot;);
 504         return false;
 505     }
 506 
 507     if (options.mode == FetchOptions::Mode::SameOrigin &amp;&amp; !m_document-&gt;securityOrigin().canRequest(url) &amp;&amp; !isSameOriginDataURL(url, options)) {
 508         printAccessDeniedMessage(url);
 509         return false;
 510     }
 511 
<span class="line-modified"> 512     if (options.mode == FetchOptions::Mode::NoCors &amp;&amp; !m_document-&gt;securityOrigin().canRequest(url) &amp;&amp; options.redirect != FetchOptions::Redirect::Follow &amp;&amp; type != CachedResource::Type::Ping) {</span>
 513         ASSERT(type != CachedResource::Type::MainResource);
 514         frame()-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;No-Cors mode requires follow redirect mode&quot;_s);
 515         return false;
 516     }
 517 
 518     if (!allowedByContentSecurityPolicy(type, url, options, ContentSecurityPolicy::RedirectResponseReceived::No))
 519         return false;
 520 
 521     // SVG Images have unique security rules that prevent all subresource requests except for data urls.
 522     if (type != CachedResource::Type::MainResource &amp;&amp; frame() &amp;&amp; frame()-&gt;page()) {
 523         if (frame()-&gt;page()-&gt;chrome().client().isSVGImageChromeClient() &amp;&amp; !url.protocolIsData())
 524             return false;
 525     }
 526 
 527     // Last of all, check for insecure content. We do this last so that when folks block insecure content with a CSP policy, they don&#39;t get a warning.
 528     // They&#39;ll still get a warning in the console about CSP blocking the load.
 529 
 530     // FIXME: Should we consider whether the request is for preload here?
 531     if (!checkInsecureContent(type, url))
 532         return false;
</pre>
<hr />
<pre>
 666 
 667     // If the cached resource has not followed redirections, it is incomplete and we should not use it.
 668     // Let&#39;s make sure the memory cache has no such resource.
 669     ASSERT(resource.response().type() != ResourceResponse::Type::Opaqueredirect);
 670 
 671     // We could support redirect modes other than Follow in case of a redirected resource.
 672     // This case is rare and is not worth optimizing currently.
 673     if (request.options().redirect != FetchOptions::Redirect::Follow &amp;&amp; resource.hasRedirections())
 674         return false;
 675 
 676     // FIXME: Implement reuse of cached raw resources.
 677     if (resource.type() == CachedResource::Type::RawResource || resource.type() == CachedResource::Type::MediaResource)
 678         return false;
 679 
 680     if (resource.type() == CachedResource::Type::Beacon || resource.type() == CachedResource::Type::Ping)
 681         return false;
 682 
 683     return true;
 684 }
 685 
<span class="line-modified"> 686 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::updateCachedResourceWithCurrentRequest(const CachedResource&amp; resource, CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar&amp; cookieJar)</span>
 687 {
 688     if (!isResourceSuitableForDirectReuse(resource, request)) {
 689         request.setCachingPolicy(CachingPolicy::DisallowCaching);
<span class="line-modified"> 690         return loadResource(resource.type(), sessionID, WTFMove(request), cookieJar);</span>
 691     }
 692 
<span class="line-modified"> 693     auto resourceHandle = createResource(resource.type(), WTFMove(request), sessionID, &amp;cookieJar);</span>
 694     resourceHandle-&gt;loadFrom(resource);
 695     return resourceHandle;
 696 }
 697 
 698 static inline void logMemoryCacheResourceRequest(Frame* frame, const String&amp; key, const String&amp; description)
 699 {
 700     if (!frame || !frame-&gt;page())
 701         return;
 702     frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessage(key, description, ShouldSample::Yes);
 703 }
 704 
 705 void CachedResourceLoader::prepareFetch(CachedResource::Type type, CachedResourceRequest&amp; request)
 706 {
 707     // Implementing step 1 to 7 of https://fetch.spec.whatwg.org/#fetching
 708     auto* document = this-&gt;document();
 709 
 710     if (document) {
 711         if (!request.origin())
 712             request.setOrigin(document-&gt;securityOrigin());
 713 #if ENABLE(SERVICE_WORKER)
</pre>
<hr />
<pre>
 766         return FetchOptions::Destination::Track;
 767 #endif
 768 #if ENABLE(APPLICATION_MANIFEST)
 769     case CachedResource::Type::ApplicationManifest:
 770         return FetchOptions::Destination::Manifest;
 771 #endif
 772     case CachedResource::Type::Beacon:
 773     case CachedResource::Type::Ping:
 774     case CachedResource::Type::LinkPrefetch:
 775     case CachedResource::Type::RawResource:
 776     case CachedResource::Type::MediaResource:
 777         // The caller is responsible for setting the appropriate destination.
 778         return FetchOptions::Destination::EmptyString;
 779     }
 780     ASSERT_NOT_REACHED();
 781     return FetchOptions::Destination::EmptyString;
 782 }
 783 
 784 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::requestResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, ForPreload forPreload, DeferOption defer)
 785 {
<span class="line-added"> 786     if (!frame() || !frame()-&gt;page()) {</span>
<span class="line-added"> 787         RELEASE_LOG_IF_ALLOWED(&quot;requestResource: failed because no frame or page&quot;);</span>
<span class="line-added"> 788         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, request.resourceRequest().url(), &quot;Invalid loader state&quot;_s });</span>
<span class="line-added"> 789     }</span>
<span class="line-added"> 790     auto&amp; frame = *this-&gt;frame();</span>
<span class="line-added"> 791     auto&amp; page = *frame.page();</span>
<span class="line-added"> 792 </span>
 793     request.setDestinationIfNotSet(destinationForType(type));
 794 
 795     // Entry point to https://fetch.spec.whatwg.org/#main-fetch.
 796     std::unique_ptr&lt;ResourceRequest&gt; originalRequest;
 797     if (CachedResource::shouldUsePingLoad(type) || request.options().destination == FetchOptions::Destination::EmptyString) {
 798         originalRequest = makeUnique&lt;ResourceRequest&gt;(request.resourceRequest());
 799         originalRequest-&gt;clearHTTPReferrer();
 800         originalRequest-&gt;clearHTTPOrigin();
 801     }
 802 
 803     if (Document* document = this-&gt;document())
 804         request.upgradeInsecureRequestIfNeeded(*document);
 805 
<span class="line-added"> 806     if (InspectorInstrumentation::willInterceptRequest(&amp;frame, request.resourceRequest()))</span>
<span class="line-added"> 807         request.setCachingPolicy(CachingPolicy::DisallowCaching);</span>
<span class="line-added"> 808 </span>
 809     request.updateReferrerPolicy(document() ? document()-&gt;referrerPolicy() : ReferrerPolicy::NoReferrerWhenDowngrade);
 810     URL url = request.resourceRequest().url();
 811 
 812     LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource &#39;%.255s&#39;, charset &#39;%s&#39;, priority=%d, forPreload=%u&quot;, url.stringCenterEllipsizedToLength().latin1().data(), request.charset().latin1().data(), request.priority() ? static_cast&lt;int&gt;(request.priority().value()) : -1, forPreload == ForPreload::Yes);
 813 
 814     if (!url.isValid()) {
<span class="line-modified"> 815         RELEASE_LOG_IF_ALLOWED(&quot;requestResource: URL is invalid (frame = %p)&quot;, &amp;frame);</span>
 816         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;URL is invalid&quot;_s });
 817     }
 818 
 819     prepareFetch(type, request);
 820 
 821     // We are passing url as well as request, as request url may contain a fragment identifier.
 822     if (!canRequest(type, url, request, forPreload)) {
<span class="line-modified"> 823         RELEASE_LOG_IF_ALLOWED(&quot;requestResource: Not allowed to request resource (frame = %p)&quot;, &amp;frame);</span>
 824         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;Not allowed to request resource&quot;_s, ResourceError::Type::AccessControl });
 825     }
 826 
 827 #if ENABLE(CONTENT_EXTENSIONS)
<span class="line-modified"> 828     if (m_documentLoader) {</span>
 829         const auto&amp; resourceRequest = request.resourceRequest();
<span class="line-modified"> 830         auto results = page.userContentProvider().processContentRuleListsForLoad(resourceRequest.url(), ContentExtensions::toResourceType(type), *m_documentLoader);</span>

 831         bool blockedLoad = results.summary.blockedLoad;
 832         bool madeHTTPS = results.summary.madeHTTPS;
<span class="line-modified"> 833         request.applyResults(WTFMove(results), &amp;page);</span>
 834         if (blockedLoad) {
<span class="line-modified"> 835             RELEASE_LOG_IF_ALLOWED(&quot;requestResource: Resource blocked by content blocker (frame = %p)&quot;, &amp;frame);</span>
 836             if (type == CachedResource::Type::MainResource) {
<span class="line-modified"> 837                 CachedResourceHandle&lt;CachedResource&gt; resource = createResource(type, WTFMove(request), page.sessionID(), &amp;page.cookieJar());</span>
 838                 ASSERT(resource);
 839                 resource-&gt;error(CachedResource::Status::LoadError);
 840                 resource-&gt;setResourceError(ResourceError(ContentExtensions::WebKitContentBlockerDomain, 0, resourceRequest.url(), WEB_UI_STRING(&quot;The URL was blocked by a content blocker&quot;, &quot;WebKitErrorBlockedByContentBlocker description&quot;)));
 841                 return resource;
 842             }
 843             return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;Resource blocked by content blocker&quot;_s, ResourceError::Type::AccessControl });
 844         }
 845         if (madeHTTPS
 846             &amp;&amp; type == CachedResource::Type::MainResource
 847             &amp;&amp; m_documentLoader-&gt;isLoadingMainResource()) {
 848             // This is to make sure the correct &#39;new&#39; URL shows in the location bar.
 849             m_documentLoader-&gt;frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();
 850         }
 851         url = request.resourceRequest().url(); // The content extension could have changed it from http to https.
 852         url = MemoryCache::removeFragmentIdentifierIfNeeded(url); // Might need to remove fragment identifier again.
 853     }
 854 #endif
 855 
<span class="line-modified"> 856     if (m_documentLoader &amp;&amp; !m_documentLoader-&gt;customHeaderFields().isEmpty()) {</span>
 857         bool sameOriginRequest = false;
 858         auto requestedOrigin = SecurityOrigin::create(url);
 859         if (type == CachedResource::Type::MainResource) {
<span class="line-modified"> 860             if (frame.isMainFrame())</span>
 861                 sameOriginRequest = true;
<span class="line-modified"> 862             else if (auto* topDocument = frame.mainFrame().document())</span>
 863                 sameOriginRequest = topDocument-&gt;securityOrigin().isSameSchemeHostPort(requestedOrigin.get());
 864         } else if (document()) {
 865             sameOriginRequest = document()-&gt;topDocument().securityOrigin().isSameSchemeHostPort(requestedOrigin.get())
 866                 &amp;&amp; document()-&gt;securityOrigin().isSameSchemeHostPort(requestedOrigin.get());
 867         }
 868         for (auto&amp; fields : m_documentLoader-&gt;customHeaderFields()) {
 869             if (sameOriginRequest || fields.thirdPartyDomainsMatch(url)) {
 870                 for (auto&amp; field : fields.fields)
 871                     request.resourceRequest().setHTTPHeaderField(field.name(), field.value());
 872             }
 873         }
 874     }
 875 
 876     LoadTiming loadTiming;
 877     loadTiming.markStartTimeAndFetchStart();
 878     InitiatorContext initiatorContext = request.options().initiatorContext;
 879 
 880     if (request.resourceRequest().url().protocolIsInHTTPFamily())
 881         updateHTTPRequestHeaders(type, request);
 882 
 883     auto&amp; memoryCache = MemoryCache::singleton();
 884     if (request.allowsCaching() &amp;&amp; memoryCache.disabled())
 885         m_documentResources.remove(url.string());
 886 
 887     // See if we can use an existing resource from the cache.
 888     CachedResourceHandle&lt;CachedResource&gt; resource;
 889     if (document())
 890         request.setDomainForCachePartition(*document());
 891 
 892     if (request.allowsCaching())
<span class="line-modified"> 893         resource = memoryCache.resourceForRequest(request.resourceRequest(), page.sessionID());</span>
 894 
 895     if (resource &amp;&amp; request.isLinkPreload() &amp;&amp; !resource-&gt;isLinkPreload())
 896         resource-&gt;setLinkPreload();
 897 
<span class="line-modified"> 898     logMemoryCacheResourceRequest(&amp;frame, DiagnosticLoggingKeys::memoryCacheUsageKey(), resource ? DiagnosticLoggingKeys::inMemoryCacheKey() : DiagnosticLoggingKeys::notInMemoryCacheKey());</span>
 899 
<span class="line-modified"> 900     auto&amp; cookieJar = page.cookieJar();</span>
 901 
 902     RevalidationPolicy policy = determineRevalidationPolicy(type, request, resource.get(), forPreload, defer);
 903     switch (policy) {
 904     case Reload:
 905         memoryCache.remove(*resource);
 906         FALLTHROUGH;
 907     case Load:
 908         if (resource)
<span class="line-modified"> 909             logMemoryCacheResourceRequest(&amp;frame, DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::unusedKey());</span>
<span class="line-modified"> 910         resource = loadResource(type, page.sessionID(), WTFMove(request), cookieJar);</span>
 911         break;
 912     case Revalidate:
 913         if (resource)
<span class="line-modified"> 914             logMemoryCacheResourceRequest(&amp;frame, DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::revalidatingKey());</span>
 915         resource = revalidateResource(WTFMove(request), *resource);
 916         break;
 917     case Use:
 918         ASSERT(resource);
 919         if (request.options().mode == FetchOptions::Mode::NoCors) {
 920             if (auto error = validateCrossOriginResourcePolicy(*request.origin(), request.resourceRequest().url(), resource-&gt;response()))
 921                 return makeUnexpected(WTFMove(*error));
<span class="line-added"> 922 </span>
<span class="line-added"> 923             if (auto error = validateRangeRequestedFlag(request.resourceRequest(), resource-&gt;response()))</span>
<span class="line-added"> 924                 return makeUnexpected(WTFMove(*error));</span>
 925         }
 926         if (shouldUpdateCachedResourceWithCurrentRequest(*resource, request)) {
<span class="line-modified"> 927             resource = updateCachedResourceWithCurrentRequest(*resource, WTFMove(request), page.sessionID(), cookieJar);</span>
 928             if (resource-&gt;status() != CachedResource::Status::Cached)
 929                 policy = Load;
 930         } else {
 931             ResourceError error;
 932             if (!shouldContinueAfterNotifyingLoadedFromMemoryCache(request, *resource, error))
 933                 return makeUnexpected(WTFMove(error));
<span class="line-modified"> 934             logMemoryCacheResourceRequest(&amp;frame, DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::usedKey());</span>
 935             loadTiming.setResponseEnd(MonotonicTime::now());
 936 
 937             memoryCache.resourceAccessed(*resource);
 938 
 939             if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled() &amp;&amp; document() &amp;&amp; !resource-&gt;isLoading()) {
 940                 auto resourceTiming = ResourceTiming::fromCache(url, request.initiatorName(), loadTiming, resource-&gt;response(), *request.origin());
 941                 if (initiatorContext == InitiatorContext::Worker) {
 942                     ASSERT(is&lt;CachedRawResource&gt;(resource.get()));
 943                     downcast&lt;CachedRawResource&gt;(resource.get())-&gt;finishedTimingForWorkerLoad(WTFMove(resourceTiming));
 944                 } else {
 945                     ASSERT(initiatorContext == InitiatorContext::Document);
<span class="line-modified"> 946                     m_resourceTimingInfo.storeResourceTimingInitiatorInformation(resource, request.initiatorName(), &amp;frame);</span>
 947                     m_resourceTimingInfo.addResourceTiming(*resource.get(), *document(), WTFMove(resourceTiming));
 948                 }
 949             }
 950 
 951             if (forPreload == ForPreload::No)
 952                 resource-&gt;setLoadPriority(request.priority());
 953         }
 954         break;
 955     }
 956     ASSERT(resource);
 957     resource-&gt;setOriginalRequest(WTFMove(originalRequest));
 958 
 959     if (forPreload == ForPreload::No &amp;&amp; resource-&gt;loader() &amp;&amp; resource-&gt;ignoreForRequestCount()) {
 960         resource-&gt;setIgnoreForRequestCount(false);
 961         incrementRequestCount(*resource);
 962     }
 963 
 964     if ((policy != Use || resource-&gt;stillNeedsLoad()) &amp;&amp; defer == DeferOption::NoDefer) {
 965         resource-&gt;load(*this);
 966 
</pre>
<hr />
<pre>
 990     m_validatedURLs.clear();
 991 
 992     // If m_preloads is not empty here, it&#39;s full of link preloads,
 993     // as speculative preloads were cleared at DCL.
 994     if (m_preloads &amp;&amp; m_preloads-&gt;size() &amp;&amp; !m_unusedPreloadsTimer.isActive())
 995         m_unusedPreloadsTimer.startOneShot(unusedPreloadTimeout);
 996 }
 997 
 998 void CachedResourceLoader::stopUnusedPreloadsTimer()
 999 {
1000     m_unusedPreloadsTimer.stop();
1001 }
1002 
1003 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::revalidateResource(CachedResourceRequest&amp;&amp; request, CachedResource&amp; resource)
1004 {
1005     ASSERT(resource.inCache());
1006     auto&amp; memoryCache = MemoryCache::singleton();
1007     ASSERT(!memoryCache.disabled());
1008     ASSERT(resource.canUseCacheValidator());
1009     ASSERT(!resource.resourceToRevalidate());

1010     ASSERT(resource.allowsCaching());
1011 
1012     CachedResourceHandle&lt;CachedResource&gt; newResource = createResource(resource.type(), WTFMove(request), resource.sessionID(), resource.cookieJar());
1013 
1014     LOG(ResourceLoading, &quot;Resource %p created to revalidate %p&quot;, newResource.get(), &amp;resource);
1015     newResource-&gt;setResourceToRevalidate(&amp;resource);
1016 
1017     memoryCache.remove(resource);
1018     memoryCache.add(*newResource);
1019 
1020     if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled())
1021         m_resourceTimingInfo.storeResourceTimingInitiatorInformation(newResource, newResource-&gt;initiatorName(), frame());
1022 
1023     return newResource;
1024 }
1025 
<span class="line-modified">1026 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::loadResource(CachedResource::Type type, PAL::SessionID sessionID, CachedResourceRequest&amp;&amp; request, const CookieJar&amp; cookieJar)</span>
1027 {
1028     auto&amp; memoryCache = MemoryCache::singleton();
<span class="line-modified">1029     ASSERT(!request.allowsCaching() || !memoryCache.resourceForRequest(request.resourceRequest(), sessionID)</span>
1030         || request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::DoNotUseAnyCache || request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData || request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::RefreshAnyCacheData);
1031 
1032     LOG(ResourceLoading, &quot;Loading CachedResource for &#39;%s&#39;.&quot;, request.resourceRequest().url().stringCenterEllipsizedToLength().latin1().data());
1033 
<span class="line-modified">1034     CachedResourceHandle&lt;CachedResource&gt; resource = createResource(type, WTFMove(request), sessionID, &amp;cookieJar);</span>
1035 
1036     if (resource-&gt;allowsCaching())
1037         memoryCache.add(*resource);
1038 
1039     if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled())
1040         m_resourceTimingInfo.storeResourceTimingInitiatorInformation(resource, resource-&gt;initiatorName(), frame());
1041 
1042     return resource;
1043 }
1044 
1045 static void logRevalidation(const String&amp; reason, DiagnosticLoggingClient&amp; logClient)
1046 {
1047     logClient.logDiagnosticMessage(DiagnosticLoggingKeys::cachedResourceRevalidationReasonKey(), reason, ShouldSample::Yes);
1048 }
1049 
1050 static void logResourceRevalidationDecision(CachedResource::RevalidationDecision reason, const Frame* frame)
1051 {
1052     if (!frame || !frame-&gt;page())
1053         return;
1054     auto&amp; logClient = frame-&gt;page()-&gt;diagnosticLoggingClient();
</pre>
<hr />
<pre>
1223         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to missing cache validators.&quot;);
1224         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonMustRevalidateNoValidatorKey());
1225         return Reload;
1226     }
1227 
1228     return Use;
1229 }
1230 
1231 void CachedResourceLoader::printAccessDeniedMessage(const URL&amp; url) const
1232 {
1233     if (url.isNull())
1234         return;
1235 
1236     if (!frame())
1237         return;
1238 
1239     String message;
1240     if (!m_document || m_document-&gt;url().isNull())
1241         message = makeString(&quot;Unsafe attempt to load URL &quot;, url.stringCenterEllipsizedToLength(), &#39;.&#39;);
1242     else
<span class="line-modified">1243         message = makeString(&quot;Unsafe attempt to load URL &quot;, url.stringCenterEllipsizedToLength(), &quot; from origin &quot;, m_document-&gt;securityOrigin().toString(), &quot;. Domains, protocols and ports must match.\n&quot;);</span>
1244 
1245     frame()-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
1246 }
1247 
1248 void CachedResourceLoader::setAutoLoadImages(bool enable)
1249 {
1250     if (enable == m_autoLoadImages)
1251         return;
1252 
1253     m_autoLoadImages = enable;
1254 
1255     if (!m_autoLoadImages)
1256         return;
1257 
1258     reloadImagesIfNotDeferred();
1259 }
1260 
1261 void CachedResourceLoader::setImagesEnabled(bool enable)
1262 {
1263     if (enable == m_imagesEnabled)
</pre>
<hr />
<pre>
1287 }
1288 
1289 void CachedResourceLoader::reloadImagesIfNotDeferred()
1290 {
1291     for (auto&amp; resource : m_documentResources.values()) {
1292         if (is&lt;CachedImage&gt;(*resource) &amp;&amp; resource-&gt;stillNeedsLoad() &amp;&amp; !clientDefersImage(resource-&gt;url()))
1293             downcast&lt;CachedImage&gt;(*resource).load(*this);
1294     }
1295 }
1296 
1297 CachePolicy CachedResourceLoader::cachePolicy(CachedResource::Type type, const URL&amp; url) const
1298 {
1299     Frame* frame = this-&gt;frame();
1300     if (!frame)
1301         return CachePolicyVerify;
1302 
1303     if (type != CachedResource::Type::MainResource)
1304         return frame-&gt;loader().subresourceCachePolicy(url);
1305 
1306     if (Page* page = frame-&gt;page()) {
<span class="line-modified">1307         if (page-&gt;isResourceCachingDisabledByWebInspector())</span>
1308             return CachePolicyReload;
1309     }
1310 
1311     switch (frame-&gt;loader().loadType()) {
1312     case FrameLoadType::ReloadFromOrigin:
1313     case FrameLoadType::Reload:
1314         return CachePolicyReload;
1315     case FrameLoadType::Back:
1316     case FrameLoadType::Forward:
1317     case FrameLoadType::IndexedBackForward:
1318         // Do not revalidate cached main resource on back/forward navigation.
1319         return CachePolicyHistoryBuffer;
1320     default:
1321         return CachePolicyVerify;
1322     }
1323 }
1324 
1325 void CachedResourceLoader::loadDone(LoadCompletionType type, bool shouldPerformPostLoadActions)
1326 {
1327     RefPtr&lt;DocumentLoader&gt; protectDocumentLoader(m_documentLoader);
</pre>
<hr />
<pre>
1370 
1371 void CachedResourceLoader::incrementRequestCount(const CachedResource&amp; resource)
1372 {
1373     if (resource.ignoreForRequestCount())
1374         return;
1375 
1376     ++m_requestCount;
1377 }
1378 
1379 void CachedResourceLoader::decrementRequestCount(const CachedResource&amp; resource)
1380 {
1381     if (resource.ignoreForRequestCount())
1382         return;
1383 
1384     --m_requestCount;
1385     ASSERT(m_requestCount &gt; -1);
1386 }
1387 
1388 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::preload(CachedResource::Type type, CachedResourceRequest&amp;&amp; request)
1389 {
<span class="line-added">1390     if (InspectorInstrumentation::willInterceptRequest(frame(), request.resourceRequest()))</span>
<span class="line-added">1391         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, request.resourceRequest().url(), &quot;Inspector intercept&quot;_s });</span>
<span class="line-added">1392 </span>
1393     if (request.charset().isEmpty() &amp;&amp; (type == CachedResource::Type::Script || type == CachedResource::Type::CSSStyleSheet))
1394         request.setCharset(m_document-&gt;charset());
1395 
1396     auto resource = requestResource(type, WTFMove(request), ForPreload::Yes);
1397     if (resource &amp;&amp; (!m_preloads || !m_preloads-&gt;contains(resource.value().get()))) {
1398         auto resourceValue = resource.value();
1399         // Fonts need special treatment since just creating the resource doesn&#39;t trigger a load.
1400         if (type == CachedResource::Type::FontResource)
1401             downcast&lt;CachedFont&gt;(resourceValue.get())-&gt;beginLoadIfNeeded(*this);
1402         resourceValue-&gt;increasePreloadCount();
1403 
1404         if (!m_preloads)
1405             m_preloads = makeUnique&lt;ListHashSet&lt;CachedResource*&gt;&gt;();
1406         m_preloads-&gt;add(resourceValue.get());
1407     }
1408     return resource;
1409 }
1410 
1411 void CachedResourceLoader::warnUnusedPreloads()
1412 {
</pre>
</td>
</tr>
</table>
<center><a href="CachedResourceClient.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CachedResourceLoader.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
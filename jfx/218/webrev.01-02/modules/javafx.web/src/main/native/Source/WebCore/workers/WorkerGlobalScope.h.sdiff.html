<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerGlobalScope.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WorkerGlobalScope.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WorkerGlobalScopeProxy.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/workers/WorkerGlobalScope.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  *
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;Base64Utilities.h&quot;
 30 #include &quot;CacheStorageConnection.h&quot;
 31 #include &quot;EventTarget.h&quot;
 32 #include &quot;ImageBitmap.h&quot;
 33 #include &quot;ScriptExecutionContext.h&quot;
 34 #include &quot;Supplementable.h&quot;
 35 #include &lt;wtf/URL.h&gt;
 36 #include &quot;WorkerCacheStorageConnection.h&quot;
<span class="line-modified"> 37 #include &quot;WorkerEventQueue.h&quot;</span>
 38 #include &quot;WorkerScriptController.h&quot;
 39 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
 40 #include &lt;memory&gt;
<span class="line-removed"> 41 #include &lt;pal/SessionID.h&gt;</span>
 42 
 43 namespace WebCore {
 44 

 45 class ContentSecurityPolicyResponseHeaders;
 46 class Crypto;
<span class="line-modified"> 47 class MicrotaskQueue;</span>
 48 class Performance;
 49 class ScheduledAction;

 50 class WorkerInspectorController;
 51 class WorkerLocation;
 52 class WorkerNavigator;

 53 class WorkerThread;

 54 
 55 namespace IDBClient {
 56 class IDBConnectionProxy;
 57 }
 58 
 59 class WorkerGlobalScope : public RefCounted&lt;WorkerGlobalScope&gt;, public Supplementable&lt;WorkerGlobalScope&gt;, public ScriptExecutionContext, public EventTargetWithInlineData, public Base64Utilities {
 60     WTF_MAKE_ISO_ALLOCATED(WorkerGlobalScope);
 61 public:
 62     virtual ~WorkerGlobalScope();
 63 
 64     virtual bool isDedicatedWorkerGlobalScope() const { return false; }
 65     virtual bool isServiceWorkerGlobalScope() const { return false; }
 66 


 67     const URL&amp; url() const final { return m_url; }
<span class="line-modified"> 68     String origin() const final;</span>
 69     const String&amp; identifier() const { return m_identifier; }
 70 
 71 #if ENABLE(INDEXED_DATABASE)
 72     IDBClient::IDBConnectionProxy* idbConnectionProxy() final;


 73 #endif
 74 
 75     WorkerCacheStorageConnection&amp; cacheStorageConnection();




 76 
 77     WorkerScriptController* script() { return m_script.get(); }
 78     void clearScript() { m_script = nullptr; }
 79 
 80     WorkerInspectorController&amp; inspectorController() const { return *m_inspectorController; }
 81 
<span class="line-removed"> 82     MicrotaskQueue&amp; microtaskQueue() const { return *m_microtaskQueue; }</span>
<span class="line-removed"> 83 </span>
 84     WorkerThread&amp; thread() const { return m_thread; }
 85 
 86     using ScriptExecutionContext::hasPendingActivity;
 87 
 88     void postTask(Task&amp;&amp;) final; // Executes the task on context&#39;s thread asynchronously.
 89 
 90     WorkerGlobalScope&amp; self() { return *this; }
 91     WorkerLocation&amp; location() const;
 92     void close();
 93 
 94     virtual ExceptionOr&lt;void&gt; importScripts(const Vector&lt;String&gt;&amp; urls);
 95     WorkerNavigator&amp; navigator();
 96 
 97     void setIsOnline(bool);
 98 
<span class="line-modified"> 99     ExceptionOr&lt;int&gt; setTimeout(JSC::ExecState&amp;, std::unique_ptr&lt;ScheduledAction&gt;, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments);</span>
100     void clearTimeout(int timeoutId);
<span class="line-modified">101     ExceptionOr&lt;int&gt; setInterval(JSC::ExecState&amp;, std::unique_ptr&lt;ScheduledAction&gt;, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments);</span>
102     void clearInterval(int timeoutId);
103 
104     bool isContextThread() const final;
105     bool isSecureContext() const final;
106 
107     WorkerNavigator* optionalNavigator() const { return m_navigator.get(); }
108     WorkerLocation* optionalLocation() const { return m_location.get(); }
109 
110     using RefCounted::ref;
111     using RefCounted::deref;
112 
113     bool isClosing() { return m_closing; }
114 
115     void addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp;) final;
116 


117     Crypto&amp; crypto();
118     Performance&amp; performance() const;
119 
120     void prepareForTermination();
121 
122     void removeAllEventListeners() final;
123 
124     void createImageBitmap(ImageBitmap::Source&amp;&amp;, ImageBitmapOptions&amp;&amp;, ImageBitmap::Promise&amp;&amp;);
125     void createImageBitmap(ImageBitmap::Source&amp;&amp;, int sx, int sy, int sw, int sh, ImageBitmapOptions&amp;&amp;, ImageBitmap::Promise&amp;&amp;);
126 
127     unsigned long createUniqueIdentifier() { return m_uniqueIdentifier++; }
128 
<span class="line-modified">129     PAL::SessionID sessionID() const final { return m_sessionID; }</span>


130 
131 protected:
<span class="line-modified">132     WorkerGlobalScope(const URL&amp;, Ref&lt;SecurityOrigin&gt;&amp;&amp;, const String&amp; identifier, const String&amp; userAgent, bool isOnline, WorkerThread&amp;, bool shouldBypassMainWorldContentSecurityPolicy, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin, MonotonicTime timeOrigin, IDBClient::IDBConnectionProxy*, SocketProvider*, PAL::SessionID);</span>
133 
134     void applyContentSecurityPolicyResponseHeaders(const ContentSecurityPolicyResponseHeaders&amp;);
135 
136 private:
137     void refScriptExecutionContext() final { ref(); }
138     void derefScriptExecutionContext() final { deref(); }
139 
140     void refEventTarget() final { ref(); }
141     void derefEventTarget() final { deref(); }
142 
143     void logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;) final;
144 
145     // The following addMessage and addConsoleMessage functions are deprecated.
146     // Callers should try to create the ConsoleMessage themselves.
<span class="line-modified">147     void addMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, JSC::ExecState*, unsigned long requestIdentifier) final;</span>
148     void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier) final;
149 
150     bool isWorkerGlobalScope() const final { return true; }
151 
152     ScriptExecutionContext* scriptExecutionContext() const final { return const_cast&lt;WorkerGlobalScope*&gt;(this); }
<span class="line-modified">153     URL completeURL(const String&amp;) const final;</span>
154     String userAgent(const URL&amp;) const final;
155     void disableEval(const String&amp; errorMessage) final;
156     void disableWebAssembly(const String&amp; errorMessage) final;
157     EventTarget* errorEventTarget() final;
<span class="line-removed">158     WorkerEventQueue&amp; eventQueue() const final;</span>
159     String resourceRequestIdentifier() const final { return m_identifier; }
160     SocketProvider* socketProvider() final;
161 
162     bool shouldBypassMainWorldContentSecurityPolicy() const final { return m_shouldBypassMainWorldContentSecurityPolicy; }
163     bool isJSExecutionForbidden() const final;
<span class="line-removed">164     SecurityOrigin&amp; topOrigin() const final { return m_topOrigin.get(); }</span>
165 
166 #if ENABLE(WEB_CRYPTO)
<span class="line-removed">167     // The following two functions are side effects of providing extra protection to serialized</span>
<span class="line-removed">168     // CryptoKey data that went through the structured clone algorithm to local storage such as</span>
<span class="line-removed">169     // IndexedDB. They don&#39;t provide any proctection against communications between mainThread</span>
<span class="line-removed">170     // and workerThreads. In fact, they cause extra expense as workerThreads cannot talk to clients</span>
<span class="line-removed">171     // to unwrap/wrap crypto keys. Hence, workerThreads must always ask mainThread to unwrap/wrap</span>
<span class="line-removed">172     // keys, which results in a second communication and plain keys being transferred between</span>
<span class="line-removed">173     // workerThreads and the mainThread.</span>
174     bool wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey) final;
175     bool unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key) final;
176 #endif
177 
178 #if ENABLE(INDEXED_DATABASE)
179     void stopIndexedDatabase();
180 #endif
181 
182     URL m_url;
183     String m_identifier;
184     String m_userAgent;
185 
186     mutable RefPtr&lt;WorkerLocation&gt; m_location;
187     mutable RefPtr&lt;WorkerNavigator&gt; m_navigator;
188 
189     WorkerThread&amp; m_thread;
190     std::unique_ptr&lt;WorkerScriptController&gt; m_script;
191     std::unique_ptr&lt;WorkerInspectorController&gt; m_inspectorController;
<span class="line-removed">192     std::unique_ptr&lt;MicrotaskQueue&gt; m_microtaskQueue;</span>
193 
194     bool m_closing { false };
195     bool m_isOnline;
196     bool m_shouldBypassMainWorldContentSecurityPolicy;
197 
<span class="line-modified">198     mutable WorkerEventQueue m_eventQueue;</span>

199 
200     Ref&lt;SecurityOrigin&gt; m_topOrigin;
201 
202 #if ENABLE(INDEXED_DATABASE)
203     RefPtr&lt;IDBClient::IDBConnectionProxy&gt; m_connectionProxy;
204 #endif
205 
206     RefPtr&lt;SocketProvider&gt; m_socketProvider;
207 
208     RefPtr&lt;Performance&gt; m_performance;
209     mutable RefPtr&lt;Crypto&gt; m_crypto;
210 
<span class="line-removed">211     PAL::SessionID m_sessionID;</span>
212     RefPtr&lt;WorkerCacheStorageConnection&gt; m_cacheStorageConnection;
<span class="line-modified">213 </span>
214     unsigned long m_uniqueIdentifier { 1 };





215 };
216 
217 } // namespace WebCore
218 
219 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::WorkerGlobalScope)
220     static bool isType(const WebCore::ScriptExecutionContext&amp; context) { return context.isWorkerGlobalScope(); }
221 SPECIALIZE_TYPE_TRAITS_END()
</pre>
</td>
<td>
<hr />
<pre>
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  *
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;Base64Utilities.h&quot;
 30 #include &quot;CacheStorageConnection.h&quot;
 31 #include &quot;EventTarget.h&quot;
 32 #include &quot;ImageBitmap.h&quot;
 33 #include &quot;ScriptExecutionContext.h&quot;
 34 #include &quot;Supplementable.h&quot;
 35 #include &lt;wtf/URL.h&gt;
 36 #include &quot;WorkerCacheStorageConnection.h&quot;
<span class="line-modified"> 37 #include &quot;WorkerMessagePortChannelProvider.h&quot;</span>
 38 #include &quot;WorkerScriptController.h&quot;
 39 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;
 40 #include &lt;memory&gt;

 41 
 42 namespace WebCore {
 43 
<span class="line-added"> 44 class CSSValuePool;</span>
 45 class ContentSecurityPolicyResponseHeaders;
 46 class Crypto;
<span class="line-modified"> 47 class EventLoopTaskGroup;</span>
 48 class Performance;
 49 class ScheduledAction;
<span class="line-added"> 50 class WorkerEventLoop;</span>
 51 class WorkerInspectorController;
 52 class WorkerLocation;
 53 class WorkerNavigator;
<span class="line-added"> 54 class WorkerSWClientConnection;</span>
 55 class WorkerThread;
<span class="line-added"> 56 struct WorkerParameters;</span>
 57 
 58 namespace IDBClient {
 59 class IDBConnectionProxy;
 60 }
 61 
 62 class WorkerGlobalScope : public RefCounted&lt;WorkerGlobalScope&gt;, public Supplementable&lt;WorkerGlobalScope&gt;, public ScriptExecutionContext, public EventTargetWithInlineData, public Base64Utilities {
 63     WTF_MAKE_ISO_ALLOCATED(WorkerGlobalScope);
 64 public:
 65     virtual ~WorkerGlobalScope();
 66 
 67     virtual bool isDedicatedWorkerGlobalScope() const { return false; }
 68     virtual bool isServiceWorkerGlobalScope() const { return false; }
 69 
<span class="line-added"> 70     EventLoopTaskGroup&amp; eventLoop() final;</span>
<span class="line-added"> 71 </span>
 72     const URL&amp; url() const final { return m_url; }
<span class="line-modified"> 73     String origin() const;</span>
 74     const String&amp; identifier() const { return m_identifier; }
 75 
 76 #if ENABLE(INDEXED_DATABASE)
 77     IDBClient::IDBConnectionProxy* idbConnectionProxy() final;
<span class="line-added"> 78     void suspend();</span>
<span class="line-added"> 79     void resume();</span>
 80 #endif
 81 
 82     WorkerCacheStorageConnection&amp; cacheStorageConnection();
<span class="line-added"> 83     MessagePortChannelProvider&amp; messagePortChannelProvider();</span>
<span class="line-added"> 84 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-added"> 85     WorkerSWClientConnection&amp; swClientConnection();</span>
<span class="line-added"> 86 #endif</span>
 87 
 88     WorkerScriptController* script() { return m_script.get(); }
 89     void clearScript() { m_script = nullptr; }
 90 
 91     WorkerInspectorController&amp; inspectorController() const { return *m_inspectorController; }
 92 


 93     WorkerThread&amp; thread() const { return m_thread; }
 94 
 95     using ScriptExecutionContext::hasPendingActivity;
 96 
 97     void postTask(Task&amp;&amp;) final; // Executes the task on context&#39;s thread asynchronously.
 98 
 99     WorkerGlobalScope&amp; self() { return *this; }
100     WorkerLocation&amp; location() const;
101     void close();
102 
103     virtual ExceptionOr&lt;void&gt; importScripts(const Vector&lt;String&gt;&amp; urls);
104     WorkerNavigator&amp; navigator();
105 
106     void setIsOnline(bool);
107 
<span class="line-modified">108     ExceptionOr&lt;int&gt; setTimeout(JSC::JSGlobalObject&amp;, std::unique_ptr&lt;ScheduledAction&gt;, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments);</span>
109     void clearTimeout(int timeoutId);
<span class="line-modified">110     ExceptionOr&lt;int&gt; setInterval(JSC::JSGlobalObject&amp;, std::unique_ptr&lt;ScheduledAction&gt;, int timeout, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments);</span>
111     void clearInterval(int timeoutId);
112 
113     bool isContextThread() const final;
114     bool isSecureContext() const final;
115 
116     WorkerNavigator* optionalNavigator() const { return m_navigator.get(); }
117     WorkerLocation* optionalLocation() const { return m_location.get(); }
118 
119     using RefCounted::ref;
120     using RefCounted::deref;
121 
122     bool isClosing() { return m_closing; }
123 
124     void addConsoleMessage(std::unique_ptr&lt;Inspector::ConsoleMessage&gt;&amp;&amp;) final;
125 
<span class="line-added">126     SecurityOrigin&amp; topOrigin() const final { return m_topOrigin.get(); }</span>
<span class="line-added">127 </span>
128     Crypto&amp; crypto();
129     Performance&amp; performance() const;
130 
131     void prepareForTermination();
132 
133     void removeAllEventListeners() final;
134 
135     void createImageBitmap(ImageBitmap::Source&amp;&amp;, ImageBitmapOptions&amp;&amp;, ImageBitmap::Promise&amp;&amp;);
136     void createImageBitmap(ImageBitmap::Source&amp;&amp;, int sx, int sy, int sw, int sh, ImageBitmapOptions&amp;&amp;, ImageBitmap::Promise&amp;&amp;);
137 
138     unsigned long createUniqueIdentifier() { return m_uniqueIdentifier++; }
139 
<span class="line-modified">140     CSSValuePool&amp; cssValuePool();</span>
<span class="line-added">141 </span>
<span class="line-added">142     ReferrerPolicy referrerPolicy() const final;</span>
143 
144 protected:
<span class="line-modified">145     WorkerGlobalScope(const WorkerParameters&amp;, Ref&lt;SecurityOrigin&gt;&amp;&amp;, WorkerThread&amp;, Ref&lt;SecurityOrigin&gt;&amp;&amp; topOrigin, IDBClient::IDBConnectionProxy*, SocketProvider*);</span>
146 
147     void applyContentSecurityPolicyResponseHeaders(const ContentSecurityPolicyResponseHeaders&amp;);
148 
149 private:
150     void refScriptExecutionContext() final { ref(); }
151     void derefScriptExecutionContext() final { deref(); }
152 
153     void refEventTarget() final { ref(); }
154     void derefEventTarget() final { deref(); }
155 
156     void logExceptionToConsole(const String&amp; errorMessage, const String&amp; sourceURL, int lineNumber, int columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;) final;
157 
158     // The following addMessage and addConsoleMessage functions are deprecated.
159     // Callers should try to create the ConsoleMessage themselves.
<span class="line-modified">160     void addMessage(MessageSource, MessageLevel, const String&amp; message, const String&amp; sourceURL, unsigned lineNumber, unsigned columnNumber, RefPtr&lt;Inspector::ScriptCallStack&gt;&amp;&amp;, JSC::JSGlobalObject*, unsigned long requestIdentifier) final;</span>
161     void addConsoleMessage(MessageSource, MessageLevel, const String&amp; message, unsigned long requestIdentifier) final;
162 
163     bool isWorkerGlobalScope() const final { return true; }
164 
165     ScriptExecutionContext* scriptExecutionContext() const final { return const_cast&lt;WorkerGlobalScope*&gt;(this); }
<span class="line-modified">166     URL completeURL(const String&amp;, ForceUTF8 = ForceUTF8::No) const final;</span>
167     String userAgent(const URL&amp;) const final;
168     void disableEval(const String&amp; errorMessage) final;
169     void disableWebAssembly(const String&amp; errorMessage) final;
170     EventTarget* errorEventTarget() final;

171     String resourceRequestIdentifier() const final { return m_identifier; }
172     SocketProvider* socketProvider() final;
173 
174     bool shouldBypassMainWorldContentSecurityPolicy() const final { return m_shouldBypassMainWorldContentSecurityPolicy; }
175     bool isJSExecutionForbidden() const final;

176 
177 #if ENABLE(WEB_CRYPTO)







178     bool wrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; key, Vector&lt;uint8_t&gt;&amp; wrappedKey) final;
179     bool unwrapCryptoKey(const Vector&lt;uint8_t&gt;&amp; wrappedKey, Vector&lt;uint8_t&gt;&amp; key) final;
180 #endif
181 
182 #if ENABLE(INDEXED_DATABASE)
183     void stopIndexedDatabase();
184 #endif
185 
186     URL m_url;
187     String m_identifier;
188     String m_userAgent;
189 
190     mutable RefPtr&lt;WorkerLocation&gt; m_location;
191     mutable RefPtr&lt;WorkerNavigator&gt; m_navigator;
192 
193     WorkerThread&amp; m_thread;
194     std::unique_ptr&lt;WorkerScriptController&gt; m_script;
195     std::unique_ptr&lt;WorkerInspectorController&gt; m_inspectorController;

196 
197     bool m_closing { false };
198     bool m_isOnline;
199     bool m_shouldBypassMainWorldContentSecurityPolicy;
200 
<span class="line-modified">201     RefPtr&lt;WorkerEventLoop&gt; m_eventLoop;</span>
<span class="line-added">202     std::unique_ptr&lt;EventLoopTaskGroup&gt; m_defaultTaskGroup;</span>
203 
204     Ref&lt;SecurityOrigin&gt; m_topOrigin;
205 
206 #if ENABLE(INDEXED_DATABASE)
207     RefPtr&lt;IDBClient::IDBConnectionProxy&gt; m_connectionProxy;
208 #endif
209 
210     RefPtr&lt;SocketProvider&gt; m_socketProvider;
211 
212     RefPtr&lt;Performance&gt; m_performance;
213     mutable RefPtr&lt;Crypto&gt; m_crypto;
214 

215     RefPtr&lt;WorkerCacheStorageConnection&gt; m_cacheStorageConnection;
<span class="line-modified">216     std::unique_ptr&lt;WorkerMessagePortChannelProvider&gt; m_messagePortChannelProvider;</span>
217     unsigned long m_uniqueIdentifier { 1 };
<span class="line-added">218 #if ENABLE(SERVICE_WORKER)</span>
<span class="line-added">219     RefPtr&lt;WorkerSWClientConnection&gt; m_swClientConnection;</span>
<span class="line-added">220 #endif</span>
<span class="line-added">221     std::unique_ptr&lt;CSSValuePool&gt; m_cssValuePool;</span>
<span class="line-added">222     ReferrerPolicy m_referrerPolicy;</span>
223 };
224 
225 } // namespace WebCore
226 
227 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::WorkerGlobalScope)
228     static bool isType(const WebCore::ScriptExecutionContext&amp; context) { return context.isWorkerGlobalScope(); }
229 SPECIALIZE_TYPE_TRAITS_END()
</pre>
</td>
</tr>
</table>
<center><a href="WorkerGlobalScope.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WorkerGlobalScopeProxy.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
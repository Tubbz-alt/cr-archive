<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/client/IDBConnectionProxy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2016 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;IDBConnectionProxy.h&quot;
 28 
 29 #if ENABLE(INDEXED_DATABASE)
 30 
 31 #include &quot;IDBCursorInfo.h&quot;
 32 #include &quot;IDBDatabase.h&quot;
 33 #include &quot;IDBGetRecordData.h&quot;
 34 #include &quot;IDBIterateCursorData.h&quot;
 35 #include &quot;IDBKeyRangeData.h&quot;
 36 #include &quot;IDBOpenDBRequest.h&quot;
 37 #include &quot;IDBRequestData.h&quot;
 38 #include &quot;IDBResultData.h&quot;
 39 #include &quot;ScriptExecutionContext.h&quot;
 40 #include &quot;SecurityOrigin.h&quot;
 41 #include &lt;wtf/MainThread.h&gt;
 42 
 43 namespace WebCore {
 44 namespace IDBClient {
 45 
 46 IDBConnectionProxy::IDBConnectionProxy(IDBConnectionToServer&amp; connection)
 47     : m_connectionToServer(connection)
 48     , m_serverConnectionIdentifier(connection.identifier())
 49 {
 50     ASSERT(isMainThread());
 51 }
 52 
 53 void IDBConnectionProxy::ref()
 54 {
 55     m_connectionToServer.ref();
 56 }
 57 
 58 void IDBConnectionProxy::deref()
 59 {
 60     m_connectionToServer.deref();
 61 }
 62 
 63 Ref&lt;IDBOpenDBRequest&gt; IDBConnectionProxy::openDatabase(ScriptExecutionContext&amp; context, const IDBDatabaseIdentifier&amp; databaseIdentifier, uint64_t version)
 64 {
 65     RefPtr&lt;IDBOpenDBRequest&gt; request;
 66     {
 67         Locker&lt;Lock&gt; locker(m_openDBRequestMapLock);
 68 
 69         request = IDBOpenDBRequest::createOpenRequest(context, *this, databaseIdentifier, version);
 70         ASSERT(!m_openDBRequestMap.contains(request-&gt;resourceIdentifier()));
 71         m_openDBRequestMap.set(request-&gt;resourceIdentifier(), request.get());
 72     }
 73 
 74     callConnectionOnMainThread(&amp;IDBConnectionToServer::openDatabase, IDBRequestData(*this, *request));
 75 
 76     return request.releaseNonNull();
 77 }
 78 
 79 Ref&lt;IDBOpenDBRequest&gt; IDBConnectionProxy::deleteDatabase(ScriptExecutionContext&amp; context, const IDBDatabaseIdentifier&amp; databaseIdentifier)
 80 {
 81     RefPtr&lt;IDBOpenDBRequest&gt; request;
 82     {
 83         Locker&lt;Lock&gt; locker(m_openDBRequestMapLock);
 84 
 85         request = IDBOpenDBRequest::createDeleteRequest(context, *this, databaseIdentifier);
 86         ASSERT(!m_openDBRequestMap.contains(request-&gt;resourceIdentifier()));
 87         m_openDBRequestMap.set(request-&gt;resourceIdentifier(), request.get());
 88     }
 89 
 90     callConnectionOnMainThread(&amp;IDBConnectionToServer::deleteDatabase, IDBRequestData(*this, *request));
 91 
 92     return request.releaseNonNull();
 93 }
 94 
 95 void IDBConnectionProxy::didOpenDatabase(const IDBResultData&amp; resultData)
 96 {
 97     completeOpenDBRequest(resultData);
 98 }
 99 
100 void IDBConnectionProxy::didDeleteDatabase(const IDBResultData&amp; resultData)
101 {
102     completeOpenDBRequest(resultData);
103 }
104 
105 void IDBConnectionProxy::completeOpenDBRequest(const IDBResultData&amp; resultData)
106 {
107     ASSERT(isMainThread());
108 
109     RefPtr&lt;IDBOpenDBRequest&gt; request;
110     {
111         Locker&lt;Lock&gt; locker(m_openDBRequestMapLock);
112         request = m_openDBRequestMap.take(resultData.requestIdentifier());
113     }
114 
115     if (!request)
116         return;
117 
<a name="1" id="anc1"></a><span class="line-added">118     if (request-&gt;isContextSuspended()) {</span>
<span class="line-added">119         switch (resultData.type()) {</span>
<span class="line-added">120         case IDBResultType::OpenDatabaseUpgradeNeeded: {</span>
<span class="line-added">121             abortOpenAndUpgradeNeeded(resultData.databaseConnectionIdentifier(), resultData.transactionInfo().identifier());</span>
<span class="line-added">122             auto result = IDBResultData::error(resultData.requestIdentifier(), IDBError { UnknownError, &quot;Version change transaction on cached page is aborted to unblock other connections&quot;_s });</span>
<span class="line-added">123             request-&gt;performCallbackOnOriginThread(*request, &amp;IDBOpenDBRequest::requestCompleted, result);</span>
<span class="line-added">124             return;</span>
<span class="line-added">125         }</span>
<span class="line-added">126         default:</span>
<span class="line-added">127             break;</span>
<span class="line-added">128         }</span>
<span class="line-added">129     }</span>
<span class="line-added">130 </span>
131     request-&gt;performCallbackOnOriginThread(*request, &amp;IDBOpenDBRequest::requestCompleted, resultData);
132 }
133 
134 void IDBConnectionProxy::createObjectStore(TransactionOperation&amp; operation, const IDBObjectStoreInfo&amp; info)
135 {
136     const IDBRequestData requestData { operation };
137     saveOperation(operation);
138 
139     callConnectionOnMainThread(&amp;IDBConnectionToServer::createObjectStore, requestData, info);
140 }
141 
142 void IDBConnectionProxy::renameObjectStore(TransactionOperation&amp; operation, uint64_t objectStoreIdentifier, const String&amp; newName)
143 {
144     const IDBRequestData requestData { operation };
145     saveOperation(operation);
146 
147     callConnectionOnMainThread(&amp;IDBConnectionToServer::renameObjectStore, requestData, objectStoreIdentifier, newName);
148 }
149 
150 void IDBConnectionProxy::renameIndex(TransactionOperation&amp; operation, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
151 {
152     const IDBRequestData requestData { operation };
153     saveOperation(operation);
154 
155     callConnectionOnMainThread(&amp;IDBConnectionToServer::renameIndex, requestData, objectStoreIdentifier, indexIdentifier, newName);
156 }
157 
158 void IDBConnectionProxy::deleteObjectStore(TransactionOperation&amp; operation, const String&amp; objectStoreName)
159 {
160     const IDBRequestData requestData { operation };
161     saveOperation(operation);
162 
163     callConnectionOnMainThread(&amp;IDBConnectionToServer::deleteObjectStore, requestData, objectStoreName);
164 }
165 
166 void IDBConnectionProxy::clearObjectStore(TransactionOperation&amp; operation, uint64_t objectStoreIdentifier)
167 {
168     const IDBRequestData requestData { operation };
169     saveOperation(operation);
170 
171     callConnectionOnMainThread(&amp;IDBConnectionToServer::clearObjectStore, requestData, objectStoreIdentifier);
172 }
173 
174 void IDBConnectionProxy::createIndex(TransactionOperation&amp; operation, const IDBIndexInfo&amp; info)
175 {
176     const IDBRequestData requestData { operation };
177     saveOperation(operation);
178 
179     callConnectionOnMainThread(&amp;IDBConnectionToServer::createIndex, requestData, info);
180 }
181 
182 void IDBConnectionProxy::deleteIndex(TransactionOperation&amp; operation, uint64_t objectStoreIdentifier, const String&amp; indexName)
183 {
184     const IDBRequestData requestData { operation };
185     saveOperation(operation);
186 
187     callConnectionOnMainThread(&amp;IDBConnectionToServer::deleteIndex, requestData, WTFMove(objectStoreIdentifier), indexName);
188 }
189 
190 void IDBConnectionProxy::putOrAdd(TransactionOperation&amp; operation, IDBKeyData&amp;&amp; keyData, const IDBValue&amp; value, const IndexedDB::ObjectStoreOverwriteMode mode)
191 {
192     const IDBRequestData requestData { operation };
193     saveOperation(operation);
194 
195     callConnectionOnMainThread(&amp;IDBConnectionToServer::putOrAdd, requestData, keyData, value, mode);
196 }
197 
198 void IDBConnectionProxy::getRecord(TransactionOperation&amp; operation, const IDBGetRecordData&amp; getRecordData)
199 {
200     const IDBRequestData requestData { operation };
201     saveOperation(operation);
202 
203     callConnectionOnMainThread(&amp;IDBConnectionToServer::getRecord, requestData, getRecordData);
204 }
205 
206 void IDBConnectionProxy::getAllRecords(TransactionOperation&amp; operation, const IDBGetAllRecordsData&amp; getAllRecordsData)
207 {
208     const IDBRequestData requestData { operation };
209     saveOperation(operation);
210 
211     callConnectionOnMainThread(&amp;IDBConnectionToServer::getAllRecords, requestData, getAllRecordsData);
212 }
213 
214 void IDBConnectionProxy::getCount(TransactionOperation&amp; operation, const IDBKeyRangeData&amp; keyRange)
215 {
216     const IDBRequestData requestData { operation };
217     saveOperation(operation);
218 
219     callConnectionOnMainThread(&amp;IDBConnectionToServer::getCount, requestData, keyRange);
220 }
221 
222 void IDBConnectionProxy::deleteRecord(TransactionOperation&amp; operation, const IDBKeyRangeData&amp; keyRange)
223 {
224     const IDBRequestData requestData { operation };
225     saveOperation(operation);
226 
227     callConnectionOnMainThread(&amp;IDBConnectionToServer::deleteRecord, requestData, keyRange);
228 }
229 
230 void IDBConnectionProxy::openCursor(TransactionOperation&amp; operation, const IDBCursorInfo&amp; info)
231 {
232     const IDBRequestData requestData { operation };
233     saveOperation(operation);
234 
235     callConnectionOnMainThread(&amp;IDBConnectionToServer::openCursor, requestData, info);
236 }
237 
238 void IDBConnectionProxy::iterateCursor(TransactionOperation&amp; operation, const IDBIterateCursorData&amp; data)
239 {
240     const IDBRequestData requestData { operation };
<a name="2" id="anc2"></a><span class="line-modified">241     if (data.option != IndexedDB::CursorIterateOption::DoNotReply)</span>
<span class="line-added">242         saveOperation(operation);</span>
243 
244     callConnectionOnMainThread(&amp;IDBConnectionToServer::iterateCursor, requestData, data);
245 }
246 
247 void IDBConnectionProxy::saveOperation(TransactionOperation&amp; operation)
248 {
249     Locker&lt;Lock&gt; locker(m_transactionOperationLock);
250 
251     ASSERT(!m_activeOperations.contains(operation.identifier()));
252     m_activeOperations.set(operation.identifier(), &amp;operation);
253 }
254 
255 void IDBConnectionProxy::completeOperation(const IDBResultData&amp; resultData)
256 {
257     RefPtr&lt;TransactionOperation&gt; operation;
258     {
259         Locker&lt;Lock&gt; locker(m_transactionOperationLock);
260         operation = m_activeOperations.take(resultData.requestIdentifier());
261     }
262 
263     if (!operation)
264         return;
265 
266     operation-&gt;transitionToComplete(resultData, WTFMove(operation));
267 }
268 
269 void IDBConnectionProxy::abortOpenAndUpgradeNeeded(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
270 {
271     callConnectionOnMainThread(&amp;IDBConnectionToServer::abortOpenAndUpgradeNeeded, databaseConnectionIdentifier, transactionIdentifier);
272 }
273 
274 void IDBConnectionProxy::fireVersionChangeEvent(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; requestIdentifier, uint64_t requestedVersion)
275 {
276     RefPtr&lt;IDBDatabase&gt; database;
277     {
278         Locker&lt;Lock&gt; locker(m_databaseConnectionMapLock);
279         database = m_databaseConnectionMap.get(databaseConnectionIdentifier);
280     }
281 
282     if (!database)
283         return;
284 
<a name="3" id="anc3"></a><span class="line-added">285     if (database-&gt;isContextSuspended()) {</span>
<span class="line-added">286         didFireVersionChangeEvent(databaseConnectionIdentifier, requestIdentifier, IndexedDB::ConnectionClosedOnBehalfOfServer::Yes);</span>
<span class="line-added">287         database-&gt;performCallbackOnOriginThread(*database, &amp;IDBDatabase::connectionToServerLost, IDBError { UnknownError, &quot;Connection on cached page closed to unblock other connections&quot;_s});</span>
<span class="line-added">288         return;</span>
<span class="line-added">289     }</span>
<span class="line-added">290 </span>
291     database-&gt;performCallbackOnOriginThread(*database, &amp;IDBDatabase::fireVersionChangeEvent, requestIdentifier, requestedVersion);
292 }
293 
<a name="4" id="anc4"></a><span class="line-modified">294 void IDBConnectionProxy::didFireVersionChangeEvent(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; requestIdentifier, IndexedDB::ConnectionClosedOnBehalfOfServer connectionClosed)</span>
295 {
<a name="5" id="anc5"></a><span class="line-modified">296     callConnectionOnMainThread(&amp;IDBConnectionToServer::didFireVersionChangeEvent, databaseConnectionIdentifier, requestIdentifier, connectionClosed);</span>
297 }
298 
299 void IDBConnectionProxy::notifyOpenDBRequestBlocked(const IDBResourceIdentifier&amp; requestIdentifier, uint64_t oldVersion, uint64_t newVersion)
300 {
301     ASSERT(isMainThread());
302 
303     RefPtr&lt;IDBOpenDBRequest&gt; request;
304     {
305         Locker&lt;Lock&gt; locker(m_openDBRequestMapLock);
306         request = m_openDBRequestMap.get(requestIdentifier);
307     }
308 
309     if (!request)
310         return;
311 
312     request-&gt;performCallbackOnOriginThread(*request, &amp;IDBOpenDBRequest::requestBlocked, oldVersion, newVersion);
313 }
314 
315 void IDBConnectionProxy::openDBRequestCancelled(const IDBRequestData&amp; requestData)
316 {
317     callConnectionOnMainThread(&amp;IDBConnectionToServer::openDBRequestCancelled, requestData);
318 }
319 
320 void IDBConnectionProxy::establishTransaction(IDBTransaction&amp; transaction)
321 {
322     {
323         Locker&lt;Lock&gt; locker(m_transactionMapLock);
324         ASSERT(!hasRecordOfTransaction(transaction));
325         m_pendingTransactions.set(transaction.info().identifier(), &amp;transaction);
326     }
327 
328     callConnectionOnMainThread(&amp;IDBConnectionToServer::establishTransaction, transaction.database().databaseConnectionIdentifier(), transaction.info());
329 }
330 
331 void IDBConnectionProxy::didStartTransaction(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBError&amp; error)
332 {
333     RefPtr&lt;IDBTransaction&gt; transaction;
334     {
335         Locker&lt;Lock&gt; locker(m_transactionMapLock);
336         transaction = m_pendingTransactions.take(transactionIdentifier);
337     }
338 
339     if (!transaction)
340         return;
341 
342     transaction-&gt;performCallbackOnOriginThread(*transaction, &amp;IDBTransaction::didStart, error);
343 }
344 
345 void IDBConnectionProxy::commitTransaction(IDBTransaction&amp; transaction)
346 {
347     {
348         Locker&lt;Lock&gt; locker(m_transactionMapLock);
349         ASSERT(!m_committingTransactions.contains(transaction.info().identifier()));
350         m_committingTransactions.set(transaction.info().identifier(), &amp;transaction);
351     }
352 
353     callConnectionOnMainThread(&amp;IDBConnectionToServer::commitTransaction, transaction.info().identifier());
354 }
355 
356 void IDBConnectionProxy::didCommitTransaction(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBError&amp; error)
357 {
358     RefPtr&lt;IDBTransaction&gt; transaction;
359     {
360         Locker&lt;Lock&gt; locker(m_transactionMapLock);
361         transaction = m_committingTransactions.take(transactionIdentifier);
362     }
363 
364     if (!transaction)
365         return;
366 
367     transaction-&gt;performCallbackOnOriginThread(*transaction, &amp;IDBTransaction::didCommit, error);
368 }
369 
370 void IDBConnectionProxy::abortTransaction(IDBTransaction&amp; transaction)
371 {
372     {
373         Locker&lt;Lock&gt; locker(m_transactionMapLock);
374         ASSERT(!m_abortingTransactions.contains(transaction.info().identifier()));
375         m_abortingTransactions.set(transaction.info().identifier(), &amp;transaction);
376     }
377 
378     callConnectionOnMainThread(&amp;IDBConnectionToServer::abortTransaction, transaction.info().identifier());
379 }
380 
381 void IDBConnectionProxy::didAbortTransaction(const IDBResourceIdentifier&amp; transactionIdentifier, const IDBError&amp; error)
382 {
383     RefPtr&lt;IDBTransaction&gt; transaction;
384     {
385         Locker&lt;Lock&gt; locker(m_transactionMapLock);
386         transaction = m_abortingTransactions.take(transactionIdentifier);
387     }
388 
389     if (!transaction)
390         return;
391 
392     transaction-&gt;performCallbackOnOriginThread(*transaction, &amp;IDBTransaction::didAbort, error);
393 }
394 
395 bool IDBConnectionProxy::hasRecordOfTransaction(const IDBTransaction&amp; transaction) const
396 {
397     ASSERT(m_transactionMapLock.isLocked());
398 
399     auto identifier = transaction.info().identifier();
400     return m_pendingTransactions.contains(identifier) || m_committingTransactions.contains(identifier) || m_abortingTransactions.contains(identifier);
401 }
402 
403 void IDBConnectionProxy::didFinishHandlingVersionChangeTransaction(uint64_t databaseConnectionIdentifier, IDBTransaction&amp; transaction)
404 {
405     callConnectionOnMainThread(&amp;IDBConnectionToServer::didFinishHandlingVersionChangeTransaction, databaseConnectionIdentifier, transaction.info().identifier());
406 }
407 
408 void IDBConnectionProxy::databaseConnectionPendingClose(IDBDatabase&amp; database)
409 {
410     callConnectionOnMainThread(&amp;IDBConnectionToServer::databaseConnectionPendingClose, database.databaseConnectionIdentifier());
411 }
412 
413 void IDBConnectionProxy::databaseConnectionClosed(IDBDatabase&amp; database)
414 {
415     callConnectionOnMainThread(&amp;IDBConnectionToServer::databaseConnectionClosed, database.databaseConnectionIdentifier());
416 }
417 
418 void IDBConnectionProxy::didCloseFromServer(uint64_t databaseConnectionIdentifier, const IDBError&amp; error)
419 {
420     RefPtr&lt;IDBDatabase&gt; database;
421     {
422         Locker&lt;Lock&gt; locker(m_databaseConnectionMapLock);
423         database = m_databaseConnectionMap.get(databaseConnectionIdentifier);
424     }
425 
<a name="6" id="anc6"></a><span class="line-modified">426     if (!database)</span>



427         return;
<a name="7" id="anc7"></a>
428 
429     database-&gt;performCallbackOnOriginThread(*database, &amp;IDBDatabase::didCloseFromServer, error);
430 }
431 
<a name="8" id="anc8"></a>




432 void IDBConnectionProxy::connectionToServerLost(const IDBError&amp; error)
433 {
434     Vector&lt;uint64_t&gt; databaseConnectionIdentifiers;
435     {
436         Locker&lt;Lock&gt; locker(m_databaseConnectionMapLock);
437         databaseConnectionIdentifiers = copyToVector(m_databaseConnectionMap.keys());
438     }
439 
440     for (auto connectionIdentifier : databaseConnectionIdentifiers) {
441         RefPtr&lt;IDBDatabase&gt; database;
442         {
443             Locker&lt;Lock&gt; locker(m_databaseConnectionMapLock);
444             database = m_databaseConnectionMap.get(connectionIdentifier);
445         }
446 
447         if (!database)
448             continue;
449 
450         database-&gt;performCallbackOnOriginThread(*database, &amp;IDBDatabase::connectionToServerLost, error);
451     }
452 
453     Vector&lt;IDBResourceIdentifier&gt; openDBRequestIdentifiers;
454     {
455         Locker&lt;Lock&gt; locker(m_openDBRequestMapLock);
456         openDBRequestIdentifiers = copyToVector(m_openDBRequestMap.keys());
457     }
458 
459     for (auto&amp; requestIdentifier : openDBRequestIdentifiers) {
460         RefPtr&lt;IDBOpenDBRequest&gt; request;
461         {
462             Locker&lt;Lock&gt; locker(m_openDBRequestMapLock);
463             request = m_openDBRequestMap.get(requestIdentifier);
464         }
465 
466         if (!request)
467             continue;
468 
469         auto result = IDBResultData::error(requestIdentifier, error);
470         request-&gt;performCallbackOnOriginThread(*request, &amp;IDBOpenDBRequest::requestCompleted, result);
471     }
472 }
473 
474 void IDBConnectionProxy::scheduleMainThreadTasks()
475 {
476     Locker&lt;Lock&gt; locker(m_mainThreadTaskLock);
477     if (m_mainThreadProtector)
478         return;
479 
480     m_mainThreadProtector = &amp;m_connectionToServer;
481     callOnMainThread([this] {
482         handleMainThreadTasks();
483     });
484 }
485 
486 void IDBConnectionProxy::handleMainThreadTasks()
487 {
488     RefPtr&lt;IDBConnectionToServer&gt; protector;
489     {
490         Locker&lt;Lock&gt; locker(m_mainThreadTaskLock);
491         ASSERT(m_mainThreadProtector);
492         protector = WTFMove(m_mainThreadProtector);
493     }
494 
495     while (auto task = m_mainThreadQueue.tryGetMessage())
496         task-&gt;performTask();
497 }
498 
499 void IDBConnectionProxy::getAllDatabaseNames(const SecurityOrigin&amp; mainFrameOrigin, const SecurityOrigin&amp; openingOrigin, Function&lt;void (const Vector&lt;String&gt;&amp;)&gt;&amp;&amp; callback)
500 {
501     // This method is only meant to be called by the web inspector on the main thread.
502     RELEASE_ASSERT(isMainThread());
503 
504     m_connectionToServer.getAllDatabaseNames(mainFrameOrigin, openingOrigin, WTFMove(callback));
505 }
506 
507 void IDBConnectionProxy::registerDatabaseConnection(IDBDatabase&amp; database)
508 {
509     Locker&lt;Lock&gt; locker(m_databaseConnectionMapLock);
510 
511     ASSERT(!m_databaseConnectionMap.contains(database.databaseConnectionIdentifier()));
512     m_databaseConnectionMap.set(database.databaseConnectionIdentifier(), &amp;database);
513 }
514 
515 void IDBConnectionProxy::unregisterDatabaseConnection(IDBDatabase&amp; database)
516 {
517     Locker&lt;Lock&gt; locker(m_databaseConnectionMapLock);
518 
519     ASSERT(!m_databaseConnectionMap.contains(database.databaseConnectionIdentifier()) || m_databaseConnectionMap.get(database.databaseConnectionIdentifier()) == &amp;database);
520     m_databaseConnectionMap.remove(database.databaseConnectionIdentifier());
521 }
522 
523 void IDBConnectionProxy::forgetActiveOperations(const Vector&lt;RefPtr&lt;TransactionOperation&gt;&gt;&amp; operations)
524 {
525     Locker&lt;Lock&gt; locker(m_transactionOperationLock);
526 
527     for (auto&amp; operation : operations)
528         m_activeOperations.remove(operation-&gt;identifier());
529 }
530 
531 void IDBConnectionProxy::forgetTransaction(IDBTransaction&amp; transaction)
532 {
533     Locker&lt;Lock&gt; locker(m_transactionMapLock);
534 
535     m_pendingTransactions.remove(transaction.info().identifier());
536     m_committingTransactions.remove(transaction.info().identifier());
537     m_abortingTransactions.remove(transaction.info().identifier());
538 }
539 
540 template&lt;typename KeyType, typename ValueType&gt;
541 void removeItemsMatchingCurrentThread(HashMap&lt;KeyType, ValueType&gt;&amp; map)
542 {
<a name="9" id="anc9"></a><span class="line-added">543     // FIXME: Revisit when introducing WebThread aware thread comparison.</span>
<span class="line-added">544     // https://bugs.webkit.org/show_bug.cgi?id=204345</span>
545     auto&amp; currentThread = Thread::current();
546 
547     Vector&lt;KeyType&gt; keys;
548     keys.reserveInitialCapacity(map.size());
549     for (auto&amp; iterator : map) {
550         if (&amp;iterator.value-&gt;originThread() == &amp;currentThread)
551             keys.uncheckedAppend(iterator.key);
552     }
553 
554     for (auto&amp; key : keys)
555         map.remove(key);
556 }
557 
<a name="10" id="anc10"></a><span class="line-added">558 template&lt;typename KeyType, typename ValueType&gt;</span>
<span class="line-added">559 void setMatchingItemsContextSuspended(ScriptExecutionContext&amp; currentContext, HashMap&lt;KeyType, ValueType&gt;&amp; map, bool isContextSuspended)</span>
<span class="line-added">560 {</span>
<span class="line-added">561     // FIXME: Revisit when introducing WebThread aware thread comparison.</span>
<span class="line-added">562     // https://bugs.webkit.org/show_bug.cgi?id=204345</span>
<span class="line-added">563     auto&amp; currentThread = Thread::current();</span>
<span class="line-added">564     for (auto&amp; iterator : map) {</span>
<span class="line-added">565         if (&amp;iterator.value-&gt;originThread() != &amp;currentThread)</span>
<span class="line-added">566             continue;</span>
<span class="line-added">567 </span>
<span class="line-added">568         auto* context = iterator.value-&gt;scriptExecutionContext();</span>
<span class="line-added">569         if (!context)</span>
<span class="line-added">570             continue;</span>
<span class="line-added">571 </span>
<span class="line-added">572         if (context == &amp;currentContext)</span>
<span class="line-added">573             iterator.value-&gt;setIsContextSuspended(isContextSuspended);</span>
<span class="line-added">574     }</span>
<span class="line-added">575 }</span>
<span class="line-added">576 </span>
577 void IDBConnectionProxy::forgetActivityForCurrentThread()
578 {
579     ASSERT(!isMainThread());
580 
581     {
582         Locker&lt;Lock&gt; lock(m_databaseConnectionMapLock);
583         removeItemsMatchingCurrentThread(m_databaseConnectionMap);
584     }
585     {
586         Locker&lt;Lock&gt; lock(m_openDBRequestMapLock);
587         removeItemsMatchingCurrentThread(m_openDBRequestMap);
588     }
589     {
590         Locker&lt;Lock&gt; lock(m_transactionMapLock);
591         removeItemsMatchingCurrentThread(m_pendingTransactions);
592         removeItemsMatchingCurrentThread(m_committingTransactions);
593         removeItemsMatchingCurrentThread(m_abortingTransactions);
594     }
595     {
596         Locker&lt;Lock&gt; lock(m_transactionOperationLock);
597         removeItemsMatchingCurrentThread(m_activeOperations);
598     }
599 }
600 
<a name="11" id="anc11"></a><span class="line-added">601 void IDBConnectionProxy::setContextSuspended(ScriptExecutionContext&amp; currentContext, bool isContextSuspended)</span>
<span class="line-added">602 {</span>
<span class="line-added">603     {</span>
<span class="line-added">604         Locker&lt;Lock&gt; lock(m_databaseConnectionMapLock);</span>
<span class="line-added">605         setMatchingItemsContextSuspended(currentContext, m_databaseConnectionMap, isContextSuspended);</span>
<span class="line-added">606     }</span>
<span class="line-added">607     {</span>
<span class="line-added">608         Locker&lt;Lock&gt; lock(m_openDBRequestMapLock);</span>
<span class="line-added">609         setMatchingItemsContextSuspended(currentContext, m_openDBRequestMap, isContextSuspended);</span>
<span class="line-added">610     }</span>
<span class="line-added">611 }</span>
<span class="line-added">612 </span>
613 } // namesapce IDBClient
614 } // namespace WebCore
615 
616 #endif // ENABLE(INDEXED_DATABASE)
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/Watchpoint.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2012-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/Atomics.h&gt;
 29 #include &lt;wtf/FastMalloc.h&gt;
 30 #include &lt;wtf/Noncopyable.h&gt;
 31 #include &lt;wtf/Nonmovable.h&gt;
 32 #include &lt;wtf/PrintStream.h&gt;
 33 #include &lt;wtf/ScopedLambda.h&gt;
 34 #include &lt;wtf/SentinelLinkedList.h&gt;
 35 #include &lt;wtf/ThreadSafeRefCounted.h&gt;
 36 
 37 namespace JSC {
 38 
 39 class VM;
 40 
 41 class FireDetail {
 42     void* operator new(size_t) = delete;
 43 
 44 public:
 45     FireDetail()
 46     {
 47     }
 48 
 49     virtual ~FireDetail()
 50     {
 51     }
 52 
 53     virtual void dump(PrintStream&amp;) const = 0;
 54 };
 55 
 56 class StringFireDetail : public FireDetail {
 57 public:
 58     StringFireDetail(const char* string)
 59         : m_string(string)
 60     {
 61     }
 62 
 63     void dump(PrintStream&amp; out) const override;
 64 
 65 private:
 66     const char* m_string;
 67 };
 68 
 69 template&lt;typename... Types&gt;
 70 class LazyFireDetail : public FireDetail {
 71 public:
 72     LazyFireDetail(const Types&amp;... args)
 73     {
 74         m_lambda = scopedLambda&lt;void(PrintStream&amp;)&gt;([&amp;] (PrintStream&amp; out) {
 75             out.print(args...);
 76         });
 77     }
 78 
 79     void dump(PrintStream&amp; out) const override { m_lambda(out); }
 80 
 81 private:
 82     ScopedLambda&lt;void(PrintStream&amp;)&gt; m_lambda;
 83 };
 84 
 85 template&lt;typename... Types&gt;
 86 LazyFireDetail&lt;Types...&gt; createLazyFireDetail(const Types&amp;... types)
 87 {
 88     return LazyFireDetail&lt;Types...&gt;(types...);
 89 }
 90 
 91 class WatchpointSet;
 92 
 93 // Really unfortunately, we do not have the way to dispatch appropriate destructor in base class&#39; destructor
 94 // based on enum type. If we call destructor explicitly in the base class, it ends up calling the base destructor
 95 // twice. C++20 allows this by using std::std::destroying_delete_t. But we are not using C++20 right now.
 96 //
 97 // Because we cannot dispatch destructors of derived classes in the destructor of the base class, what it means is,
 98 // 1. Calling Watchpoint::~Watchpoint directly is illegal.
 99 // 2. `delete watchpoint` where watchpoint is non-final derived class is illegal. If watchpoint is final derived class, it works.
100 // 3. If we really want to do (2), we need to call `watchpoint-&gt;destroy()` instead, and dispatch an appropriate destructor in Watchpoint::destroy.
101 //
102 // Luckily, none of our derived watchpoint classes have members which require destructors. So we do not dispatch
103 // the destructor call to the drived class in the base class. If it becomes really required, we can introduce
104 // a custom deleter for some classes which directly call &quot;delete&quot; to the allocated non-final Watchpoint class
105 // (e.g. std::unique_ptr&lt;Watchpoint&gt;, RefPtr&lt;Watchpoint&gt;), and call Watchpoint::destroy instead of &quot;delete&quot;
106 // operator. But since we do not require it for now, we are doing the simplest thing.
107 #define JSC_WATCHPOINT_TYPES_WITHOUT_JIT(macro) \
108     macro(AdaptiveInferredPropertyValueStructure, AdaptiveInferredPropertyValueWatchpointBase::StructureWatchpoint) \
109     macro(AdaptiveInferredPropertyValueProperty, AdaptiveInferredPropertyValueWatchpointBase::PropertyWatchpoint) \
110     macro(CodeBlockJettisoning, CodeBlockJettisoningWatchpoint) \
111     macro(LLIntPrototypeLoadAdaptiveStructure, LLIntPrototypeLoadAdaptiveStructureWatchpoint) \
112     macro(FunctionRareDataAllocationProfileClearing, FunctionRareData::AllocationProfileClearingWatchpoint) \
113     macro(ObjectToStringAdaptiveStructure, ObjectToStringAdaptiveStructureWatchpoint)
114 
115 #if ENABLE(JIT)
116 #define JSC_WATCHPOINT_TYPES_WITHOUT_DFG(macro) \
117     JSC_WATCHPOINT_TYPES_WITHOUT_JIT(macro) \
<a name="2" id="anc2"></a><span class="line-modified">118     macro(StructureTransitionStructureStubClearing, StructureTransitionStructureStubClearingWatchpoint)</span>
119 
120 #if ENABLE(DFG_JIT)
121 #define JSC_WATCHPOINT_TYPES(macro) \
122     JSC_WATCHPOINT_TYPES_WITHOUT_DFG(macro) \
123     macro(AdaptiveStructure, DFG::AdaptiveStructureWatchpoint)
124 #else
125 #define JSC_WATCHPOINT_TYPES(macro) \
126     JSC_WATCHPOINT_TYPES_WITHOUT_DFG(macro)
127 #endif
128 
129 #else
130 #define JSC_WATCHPOINT_TYPES(macro) \
131     JSC_WATCHPOINT_TYPES_WITHOUT_JIT(macro)
132 #endif
133 
134 #define JSC_WATCHPOINT_FIELD(type, member) \
135     type member; \
136     static_assert(std::is_trivially_destructible&lt;type&gt;::value, &quot;&quot;); \
137 
<a name="3" id="anc3"></a><span class="line-added">138 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(Watchpoint);</span>
139 
140 class Watchpoint : public PackedRawSentinelNode&lt;Watchpoint&gt; {
141     WTF_MAKE_NONCOPYABLE(Watchpoint);
142     WTF_MAKE_NONMOVABLE(Watchpoint);
<a name="4" id="anc4"></a><span class="line-modified">143     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(Watchpoint);</span>
144 public:
145 #define JSC_DEFINE_WATCHPOINT_TYPES(type, _) type,
146     enum class Type : uint8_t {
147         JSC_WATCHPOINT_TYPES(JSC_DEFINE_WATCHPOINT_TYPES)
148     };
149 #undef JSC_DEFINE_WATCHPOINT_TYPES
150 
151     Watchpoint(Type type)
152         : m_type(type)
153     { }
154 
155 protected:
156     ~Watchpoint();
157 
158 private:
159     friend class WatchpointSet;
160     void fire(VM&amp;, const FireDetail&amp;);
161 
162     Type m_type;
163 };
164 
165 // Make sure that the state can be represented in 2 bits.
166 enum WatchpointState : uint8_t {
167     ClearWatchpoint = 0,
168     IsWatched = 1,
169     IsInvalidated = 2
170 };
171 
172 class InlineWatchpointSet;
173 class DeferredWatchpointFire;
174 class VM;
175 
<a name="5" id="anc5"></a><span class="line-added">176 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(WatchpointSet);</span>
<span class="line-added">177 </span>
178 class WatchpointSet : public ThreadSafeRefCounted&lt;WatchpointSet&gt; {
<a name="6" id="anc6"></a><span class="line-added">179     WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(WatchpointSet);</span>
180     friend class LLIntOffsetsExtractor;
181     friend class DeferredWatchpointFire;
182 public:
183     JS_EXPORT_PRIVATE WatchpointSet(WatchpointState);
184 
185     // FIXME: In many cases, it would be amazing if this *did* fire the watchpoints. I suspect that
186     // this might be hard to get right, but still, it might be awesome.
187     JS_EXPORT_PRIVATE ~WatchpointSet(); // Note that this will not fire any of the watchpoints; if you need to know when a WatchpointSet dies then you need a separate mechanism for this.
188 
189     static Ref&lt;WatchpointSet&gt; create(WatchpointState state)
190     {
191         return adoptRef(*new WatchpointSet(state));
192     }
193 
194     // Fast way of getting the state, which only works from the main thread.
195     WatchpointState stateOnJSThread() const
196     {
197         return static_cast&lt;WatchpointState&gt;(m_state);
198     }
199 
200     // It is safe to call this from another thread. It may return an old
201     // state. Guarantees that if *first* read the state() of the thing being
202     // watched and it returned IsWatched and *second* you actually read its
203     // value then it&#39;s safe to assume that if the state being watched changes
204     // then also the watchpoint state() will change to IsInvalidated.
205     WatchpointState state() const
206     {
207         WTF::loadLoadFence();
208         WatchpointState result = static_cast&lt;WatchpointState&gt;(m_state);
209         WTF::loadLoadFence();
210         return result;
211     }
212 
213     // It is safe to call this from another thread.  It may return true
214     // even if the set actually had been invalidated, but that ought to happen
215     // only in the case of races, and should be rare. Guarantees that if you
216     // call this after observing something that must imply that the set is
217     // invalidated, then you will see this return false. This is ensured by
218     // issuing a load-load fence prior to querying the state.
219     bool isStillValid() const
220     {
221         return state() != IsInvalidated;
222     }
223     // Like isStillValid(), may be called from another thread.
224     bool hasBeenInvalidated() const { return !isStillValid(); }
225 
226     // As a convenience, this will ignore 0. That&#39;s because code paths in the DFG
227     // that create speculation watchpoints may choose to bail out if speculation
228     // had already been terminated.
229     void add(Watchpoint*);
230 
231     // Force the watchpoint set to behave as if it was being watched even if no
232     // watchpoints have been installed. This will result in invalidation if the
233     // watchpoint would have fired. That&#39;s a pretty good indication that you
234     // probably don&#39;t want to set watchpoints, since we typically don&#39;t want to
235     // set watchpoints that we believe will actually be fired.
236     void startWatching()
237     {
238         ASSERT(m_state != IsInvalidated);
239         if (m_state == IsWatched)
240             return;
241         WTF::storeStoreFence();
242         m_state = IsWatched;
243         WTF::storeStoreFence();
244     }
245 
246     template &lt;typename T&gt;
247     void fireAll(VM&amp; vm, T&amp; fireDetails)
248     {
249         if (LIKELY(m_state != IsWatched))
250             return;
251         fireAllSlow(vm, fireDetails);
252     }
253 
254     void touch(VM&amp; vm, const FireDetail&amp; detail)
255     {
256         if (state() == ClearWatchpoint)
257             startWatching();
258         else
259             fireAll(vm, detail);
260     }
261 
262     void touch(VM&amp; vm, const char* reason)
263     {
264         touch(vm, StringFireDetail(reason));
265     }
266 
267     void invalidate(VM&amp; vm, const FireDetail&amp; detail)
268     {
269         if (state() == IsWatched)
270             fireAll(vm, detail);
271         m_state = IsInvalidated;
272     }
273 
274     void invalidate(VM&amp; vm, const char* reason)
275     {
276         invalidate(vm, StringFireDetail(reason));
277     }
278 
279     bool isBeingWatched() const
280     {
281         return m_setIsNotEmpty;
282     }
283 
284     int8_t* addressOfState() { return &amp;m_state; }
285     static ptrdiff_t offsetOfState() { return OBJECT_OFFSETOF(WatchpointSet, m_state); }
286     int8_t* addressOfSetIsNotEmpty() { return &amp;m_setIsNotEmpty; }
287 
288     JS_EXPORT_PRIVATE void fireAllSlow(VM&amp;, const FireDetail&amp;); // Call only if you&#39;ve checked isWatched.
289     JS_EXPORT_PRIVATE void fireAllSlow(VM&amp;, DeferredWatchpointFire* deferredWatchpoints); // Ditto.
290     JS_EXPORT_PRIVATE void fireAllSlow(VM&amp;, const char* reason); // Ditto.
291 
292 private:
293     void fireAllWatchpoints(VM&amp;, const FireDetail&amp;);
294     void take(WatchpointSet* other);
295 
296     friend class InlineWatchpointSet;
297 
298     int8_t m_state;
299     int8_t m_setIsNotEmpty;
300 
301     SentinelLinkedList&lt;Watchpoint, PackedRawSentinelNode&lt;Watchpoint&gt;&gt; m_set;
302 };
303 
304 // InlineWatchpointSet is a low-overhead, non-copyable watchpoint set in which
305 // it is not possible to quickly query whether it is being watched in a single
306 // branch. There is a fairly simple tradeoff between WatchpointSet and
307 // InlineWatchpointSet:
308 //
309 // Do you have to emit JIT code that rapidly tests whether the watchpoint set
310 // is being watched?  If so, use WatchpointSet.
311 //
312 // Do you need multiple parties to have pointers to the same WatchpointSet?
313 // If so, use WatchpointSet.
314 //
315 // Do you have to allocate a lot of watchpoint sets?  If so, use
316 // InlineWatchpointSet unless you answered &quot;yes&quot; to the previous questions.
317 //
318 // InlineWatchpointSet will use just one pointer-width word of memory unless
319 // you actually add watchpoints to it, in which case it internally inflates
320 // to a pointer to a WatchpointSet, and transfers its state to the
321 // WatchpointSet.
322 
323 class InlineWatchpointSet {
324     WTF_MAKE_NONCOPYABLE(InlineWatchpointSet);
325 public:
326     InlineWatchpointSet(WatchpointState state)
327         : m_data(encodeState(state))
328     {
329     }
330 
331     ~InlineWatchpointSet()
332     {
333         if (isThin())
334             return;
335         freeFat();
336     }
337 
338     // Fast way of getting the state, which only works from the main thread.
339     WatchpointState stateOnJSThread() const
340     {
341         uintptr_t data = m_data;
342         if (isFat(data))
343             return fat(data)-&gt;stateOnJSThread();
344         return decodeState(data);
345     }
346 
347     // It is safe to call this from another thread. It may return a prior state,
348     // but that should be fine since you should only perform actions based on the
349     // state if you also add a watchpoint.
350     WatchpointState state() const
351     {
352         WTF::loadLoadFence();
353         uintptr_t data = m_data;
354         WTF::loadLoadFence();
355         if (isFat(data))
356             return fat(data)-&gt;state();
357         return decodeState(data);
358     }
359 
360     // It is safe to call this from another thread.  It may return false
361     // even if the set actually had been invalidated, but that ought to happen
362     // only in the case of races, and should be rare.
363     bool hasBeenInvalidated() const
364     {
365         return state() == IsInvalidated;
366     }
367 
368     // Like hasBeenInvalidated(), may be called from another thread.
369     bool isStillValid() const
370     {
371         return !hasBeenInvalidated();
372     }
373 
374     void add(Watchpoint*);
375 
376     void startWatching()
377     {
378         if (isFat()) {
379             fat()-&gt;startWatching();
380             return;
381         }
382         ASSERT(decodeState(m_data) != IsInvalidated);
383         m_data = encodeState(IsWatched);
384     }
385 
386     template &lt;typename T&gt;
387     void fireAll(VM&amp; vm, T fireDetails)
388     {
389         if (isFat()) {
390             fat()-&gt;fireAll(vm, fireDetails);
391             return;
392         }
393         if (decodeState(m_data) == ClearWatchpoint)
394             return;
395         m_data = encodeState(IsInvalidated);
396         WTF::storeStoreFence();
397     }
398 
399     void invalidate(VM&amp; vm, const FireDetail&amp; detail)
400     {
401         if (isFat())
402             fat()-&gt;invalidate(vm, detail);
403         else
404             m_data = encodeState(IsInvalidated);
405     }
406 
407     JS_EXPORT_PRIVATE void fireAll(VM&amp;, const char* reason);
408 
409     void touch(VM&amp; vm, const FireDetail&amp; detail)
410     {
411         if (isFat()) {
412             fat()-&gt;touch(vm, detail);
413             return;
414         }
415         uintptr_t data = m_data;
416         if (decodeState(data) == IsInvalidated)
417             return;
418         WTF::storeStoreFence();
419         if (decodeState(data) == ClearWatchpoint)
420             m_data = encodeState(IsWatched);
421         else
422             m_data = encodeState(IsInvalidated);
423         WTF::storeStoreFence();
424     }
425 
426     void touch(VM&amp; vm, const char* reason)
427     {
428         touch(vm, StringFireDetail(reason));
429     }
430 
431     // Note that for any watchpoint that is visible from the DFG, it would be incorrect to write code like:
432     //
433     // if (w.isBeingWatched())
434     //     w.fireAll()
435     //
436     // Concurrently to this, the DFG could do:
437     //
438     // if (w.isStillValid())
439     //     perform optimizations;
440     // if (!w.isStillValid())
441     //     retry compilation;
442     //
443     // Note that the DFG algorithm is widespread, and sound, because fireAll() and invalidate() will leave
444     // the watchpoint in a !isStillValid() state. Hence, if fireAll() or invalidate() interleaved between
445     // the first isStillValid() check and the second one, then it would simply cause the DFG to retry
446     // compilation later.
447     //
448     // But, if you change some piece of state that the DFG might optimize for, but invalidate the
449     // watchpoint by doing:
450     //
451     // if (w.isBeingWatched())
452     //     w.fireAll()
453     //
454     // then the DFG would never know that you invalidated state between the two checks.
455     //
456     // There are two ways to work around this:
457     //
458     // - Call fireAll() without a isBeingWatched() check. Then, the DFG will know that the watchpoint has
459     //   been invalidated when it does its second check.
460     //
461     // - Do not expose the watchpoint set to the DFG directly, and have your own way of validating whether
462     //   the assumptions that the DFG thread used are still valid when the DFG code is installed.
463     bool isBeingWatched() const
464     {
465         if (isFat())
466             return fat()-&gt;isBeingWatched();
467         return false;
468     }
469 
470     // We expose this because sometimes a client knows its about to start
471     // watching this InlineWatchpointSet, hence it&#39;ll become inflated regardless.
472     // Such clients may find it useful to have a WatchpointSet* pointer, for example,
473     // if they collect a Vector of WatchpointSet*.
474     WatchpointSet* inflate()
475     {
476         if (LIKELY(isFat()))
477             return fat();
478         return inflateSlow();
479     }
480 
481 private:
<a name="7" id="anc7"></a><span class="line-modified">482     static constexpr uintptr_t IsThinFlag        = 1;</span>
<span class="line-modified">483     static constexpr uintptr_t StateMask         = 6;</span>
<span class="line-modified">484     static constexpr uintptr_t StateShift        = 1;</span>
485 
486     static bool isThin(uintptr_t data) { return data &amp; IsThinFlag; }
487     static bool isFat(uintptr_t data) { return !isThin(data); }
488 
489     static WatchpointState decodeState(uintptr_t data)
490     {
491         ASSERT(isThin(data));
492         return static_cast&lt;WatchpointState&gt;((data &amp; StateMask) &gt;&gt; StateShift);
493     }
494 
495     static uintptr_t encodeState(WatchpointState state)
496     {
497         return (static_cast&lt;uintptr_t&gt;(state) &lt;&lt; StateShift) | IsThinFlag;
498     }
499 
500     bool isThin() const { return isThin(m_data); }
501     bool isFat() const { return isFat(m_data); };
502 
503     static WatchpointSet* fat(uintptr_t data)
504     {
505         return bitwise_cast&lt;WatchpointSet*&gt;(data);
506     }
507 
508     WatchpointSet* fat()
509     {
510         ASSERT(isFat());
511         return fat(m_data);
512     }
513 
514     const WatchpointSet* fat() const
515     {
516         ASSERT(isFat());
517         return fat(m_data);
518     }
519 
520     JS_EXPORT_PRIVATE WatchpointSet* inflateSlow();
521     JS_EXPORT_PRIVATE void freeFat();
522 
523     uintptr_t m_data;
524 };
525 
526 class DeferredWatchpointFire : public FireDetail {
527     WTF_MAKE_NONCOPYABLE(DeferredWatchpointFire);
528 public:
529     JS_EXPORT_PRIVATE DeferredWatchpointFire(VM&amp;);
530     JS_EXPORT_PRIVATE ~DeferredWatchpointFire();
531 
532     JS_EXPORT_PRIVATE void takeWatchpointsToFire(WatchpointSet*);
533     JS_EXPORT_PRIVATE void fireAll();
534 
535     void dump(PrintStream&amp; out) const override = 0;
536 private:
537     VM&amp; m_vm;
538     WatchpointSet m_watchpointsToFire;
539 };
540 
541 } // namespace JSC
542 
543 namespace WTF {
544 
545 void printInternal(PrintStream&amp; out, JSC::WatchpointState);
546 
547 } // namespace WTF
548 
<a name="8" id="anc8"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="8" type="hidden" />
</body>
</html>
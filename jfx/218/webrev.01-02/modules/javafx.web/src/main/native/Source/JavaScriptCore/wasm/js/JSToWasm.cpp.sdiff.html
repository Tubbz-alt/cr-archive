<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSToWasm.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../generateWasmOpsHeader.py.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSToWasm.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSToWasm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSToWasm.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;CCallHelpers.h&quot;
 32 #include &quot;DisallowMacroScratchRegisterUsage.h&quot;

 33 #include &quot;JSCInlines.h&quot;
 34 #include &quot;JSWebAssemblyHelpers.h&quot;
 35 #include &quot;JSWebAssemblyInstance.h&quot;
 36 #include &quot;JSWebAssemblyRuntimeError.h&quot;
 37 #include &quot;MaxFrameExtentForSlowPathCall.h&quot;
 38 #include &quot;WasmCallingConvention.h&quot;
 39 #include &quot;WasmContextInlines.h&quot;

 40 #include &quot;WasmSignatureInlines.h&quot;
 41 #include &quot;WasmToJS.h&quot;
 42 
 43 namespace JSC { namespace Wasm {
 44 
<span class="line-modified"> 45 std::unique_ptr&lt;InternalFunction&gt; createJSToWasmWrapper(CompilationContext&amp; compilationContext, const Signature&amp; signature, Vector&lt;UnlinkedWasmToWasmCall&gt;* unlinkedWasmToWasmCalls, const ModuleInformation&amp; info, MemoryMode mode, unsigned functionIndex)</span>
 46 {
<span class="line-modified"> 47     CCallHelpers&amp; jit = *compilationContext.embedderEntrypointJIT;</span>














































































 48 


 49     auto result = makeUnique&lt;InternalFunction&gt;();
 50     jit.emitFunctionPrologue();
 51 
 52     // FIXME Stop using 0 as codeBlocks. https://bugs.webkit.org/show_bug.cgi?id=165321
 53     jit.store64(CCallHelpers::TrustedImm64(0), CCallHelpers::Address(GPRInfo::callFrameRegister, CallFrameSlot::codeBlock * static_cast&lt;int&gt;(sizeof(Register))));
 54     MacroAssembler::DataLabelPtr calleeMoveLocation = jit.moveWithPatch(MacroAssembler::TrustedImmPtr(nullptr), GPRInfo::nonPreservedNonReturnGPR);
 55     jit.storePtr(GPRInfo::nonPreservedNonReturnGPR, CCallHelpers::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));
 56     CodeLocationDataLabelPtr&lt;WasmEntryPtrTag&gt;* linkedCalleeMove = &amp;result-&gt;calleeMoveLocation;
 57     jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
 58         *linkedCalleeMove = linkBuffer.locationOf&lt;WasmEntryPtrTag&gt;(calleeMoveLocation);
 59     });
 60 
 61     const PinnedRegisterInfo&amp; pinnedRegs = PinnedRegisterInfo::get();
 62     RegisterSet toSave = pinnedRegs.toSave(mode);
 63 
<span class="line-modified"> 64 #if !ASSERT_DISABLED</span>
 65     unsigned toSaveSize = toSave.numberOfSetGPRs();
 66     // They should all be callee saves.
 67     toSave.filter(RegisterSet::calleeSaveRegisters());
 68     ASSERT(toSave.numberOfSetGPRs() == toSaveSize);
 69 #endif
 70 
 71     RegisterAtOffsetList registersToSpill(toSave, RegisterAtOffsetList::OffsetBaseType::FramePointerBased);
 72     result-&gt;entrypoint.calleeSaveRegisters = registersToSpill;
 73 
<span class="line-modified"> 74     unsigned totalFrameSize = registersToSpill.size() * sizeof(void*);</span>
<span class="line-modified"> 75     totalFrameSize += WasmCallingConvention::headerSizeInBytes();</span>
<span class="line-modified"> 76     totalFrameSize -= sizeof(CallerFrameAndPC);</span>
<span class="line-modified"> 77     unsigned numGPRs = 0;</span>
<span class="line-modified"> 78     unsigned numFPRs = 0;</span>
<span class="line-removed"> 79     bool argumentsIncludeI64 = false;</span>
<span class="line-removed"> 80     for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {</span>
<span class="line-removed"> 81         switch (signature.argument(i)) {</span>
<span class="line-removed"> 82         case Wasm::I64:</span>
<span class="line-removed"> 83             argumentsIncludeI64 = true;</span>
<span class="line-removed"> 84             FALLTHROUGH;</span>
<span class="line-removed"> 85         case Wasm::I32:</span>
<span class="line-removed"> 86         case Wasm::Anyref:</span>
<span class="line-removed"> 87         case Wasm::Funcref:</span>
<span class="line-removed"> 88             if (numGPRs &gt;= wasmCallingConvention().m_gprArgs.size())</span>
<span class="line-removed"> 89                 totalFrameSize += sizeof(void*);</span>
<span class="line-removed"> 90             ++numGPRs;</span>
<span class="line-removed"> 91             break;</span>
<span class="line-removed"> 92         case Wasm::F32:</span>
<span class="line-removed"> 93         case Wasm::F64:</span>
<span class="line-removed"> 94             if (numFPRs &gt;= wasmCallingConvention().m_fprArgs.size())</span>
<span class="line-removed"> 95                 totalFrameSize += sizeof(void*);</span>
<span class="line-removed"> 96             ++numFPRs;</span>
<span class="line-removed"> 97             break;</span>
<span class="line-removed"> 98         default:</span>
<span class="line-removed"> 99             RELEASE_ASSERT_NOT_REACHED();</span>
<span class="line-removed">100         }</span>
<span class="line-removed">101     }</span>
102 
103     totalFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), totalFrameSize);
104     jit.subPtr(MacroAssembler::TrustedImm32(totalFrameSize), MacroAssembler::stackPointerRegister);
105 
106     // We save all these registers regardless of having a memory or not.
107     // The reason is that we use one of these as a scratch. That said,
108     // almost all real wasm programs use memory, so it&#39;s not really
109     // worth optimizing for the case that they don&#39;t.
110     for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {
111         GPRReg reg = regAtOffset.reg().gpr();
112         ptrdiff_t offset = regAtOffset.offset();
113         jit.storePtr(reg, CCallHelpers::Address(GPRInfo::callFrameRegister, offset));
114     }
115 
<span class="line-modified">116     if (argumentsIncludeI64 || signature.returnType() == Wasm::I64) {</span>
117         if (Context::useFastTLS())
118             jit.loadWasmContextInstance(GPRInfo::argumentGPR2);
119         else {
120             // vmEntryToWasm passes the JSWebAssemblyInstance corresponding to Wasm::Context*&#39;s
121             // instance as the first JS argument when we&#39;re not using fast TLS to hold the
122             // Wasm::Context*&#39;s instance.
123             jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, CallFrameSlot::thisArgument * sizeof(EncodedJSValue)), GPRInfo::argumentGPR2);
124             jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR2, JSWebAssemblyInstance::offsetOfInstance()), GPRInfo::argumentGPR2);
125         }
126 
<span class="line-modified">127         emitThrowWasmToJSException(jit, GPRInfo::argumentGPR2, argumentsIncludeI64 ? ExceptionType::I64ArgumentType : ExceptionType::I64ReturnType);</span>
128         return result;
129     }
130 
131     GPRReg wasmContextInstanceGPR = pinnedRegs.wasmContextInstancePointer;
132 
133     {
<span class="line-modified">134         CCallHelpers::Address calleeFrame = CCallHelpers::Address(MacroAssembler::stackPointerRegister, -static_cast&lt;ptrdiff_t&gt;(sizeof(CallerFrameAndPC)));</span>
<span class="line-modified">135         numGPRs = 0;</span>
<span class="line-modified">136         numFPRs = 0;</span>

137         // We&#39;re going to set the pinned registers after this. So
138         // we can use this as a scratch for now since we saved it above.
139         GPRReg scratchReg = pinnedRegs.baseMemoryPointer;
140 
<span class="line-removed">141         ptrdiff_t jsOffset = CallFrameSlot::thisArgument * sizeof(EncodedJSValue);</span>
<span class="line-removed">142 </span>
<span class="line-removed">143         // vmEntryToWasm passes the JSWebAssemblyInstance corresponding to Wasm::Context*&#39;s</span>
<span class="line-removed">144         // instance as the first JS argument when we&#39;re not using fast TLS to hold the</span>
<span class="line-removed">145         // Wasm::Context*&#39;s instance.</span>
146         if (!Context::useFastTLS()) {
<span class="line-modified">147             jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), wasmContextInstanceGPR);</span>
148             jit.loadPtr(CCallHelpers::Address(wasmContextInstanceGPR, JSWebAssemblyInstance::offsetOfInstance()), wasmContextInstanceGPR);
<span class="line-removed">149             jsOffset += sizeof(EncodedJSValue);</span>
150         }
151 
<span class="line-removed">152         ptrdiff_t wasmOffset = CallFrame::headerSizeInRegisters * sizeof(void*);</span>
153         for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {
<span class="line-modified">154             switch (signature.argument(i)) {</span>
<span class="line-modified">155             case Wasm::I32:</span>
<span class="line-modified">156             case Wasm::I64:</span>
<span class="line-modified">157             case Wasm::Funcref:</span>
<span class="line-modified">158             case Wasm::Anyref:</span>
<span class="line-modified">159                 if (numGPRs &gt;= wasmCallingConvention().m_gprArgs.size()) {</span>
<span class="line-modified">160                     if (signature.argument(i) == Wasm::I32) {</span>
<span class="line-modified">161                         jit.load32(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchReg);</span>
<span class="line-removed">162                         jit.store32(scratchReg, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">163                     } else {</span>
<span class="line-removed">164                         jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchReg);</span>
<span class="line-removed">165                         jit.store64(scratchReg, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">166                     }</span>
<span class="line-removed">167                     wasmOffset += sizeof(void*);</span>
<span class="line-removed">168                 } else {</span>
<span class="line-removed">169                     if (signature.argument(i) == Wasm::I32)</span>
<span class="line-removed">170                         jit.load32(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), wasmCallingConvention().m_gprArgs[numGPRs].gpr());</span>
<span class="line-removed">171                     else</span>
<span class="line-removed">172                         jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), wasmCallingConvention().m_gprArgs[numGPRs].gpr());</span>
<span class="line-removed">173                 }</span>
<span class="line-removed">174                 ++numGPRs;</span>
<span class="line-removed">175                 break;</span>
<span class="line-removed">176             case Wasm::F32:</span>
<span class="line-removed">177             case Wasm::F64:</span>
<span class="line-removed">178                 if (numFPRs &gt;= wasmCallingConvention().m_fprArgs.size()) {</span>
<span class="line-removed">179                     if (signature.argument(i) == Wasm::F32) {</span>
<span class="line-removed">180                         jit.load32(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchReg);</span>
<span class="line-removed">181                         jit.store32(scratchReg, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">182                     } else {</span>
<span class="line-removed">183                         jit.load64(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), scratchReg);</span>
<span class="line-removed">184                         jit.store64(scratchReg, calleeFrame.withOffset(wasmOffset));</span>
<span class="line-removed">185                     }</span>
<span class="line-removed">186                     wasmOffset += sizeof(void*);</span>
187                 } else {
<span class="line-modified">188                     if (signature.argument(i) == Wasm::F32)</span>
<span class="line-modified">189                         jit.loadFloat(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), wasmCallingConvention().m_fprArgs[numFPRs].fpr());</span>
<span class="line-removed">190                     else</span>
<span class="line-removed">191                         jit.loadDouble(CCallHelpers::Address(GPRInfo::callFrameRegister, jsOffset), wasmCallingConvention().m_fprArgs[numFPRs].fpr());</span>
192                 }
<span class="line-modified">193                 ++numFPRs;</span>
<span class="line-modified">194                 break;</span>
<span class="line-modified">195             default:</span>
<span class="line-modified">196                 RELEASE_ASSERT_NOT_REACHED();</span>

197             }
<span class="line-removed">198 </span>
<span class="line-removed">199             jsOffset += sizeof(EncodedJSValue);</span>
200         }
201     }
202 
203     if (!!info.memory) {
204         GPRReg baseMemory = pinnedRegs.baseMemoryPointer;
<span class="line-modified">205         GPRReg scratchOrSize = wasmCallingConventionAir().prologueScratch(0);</span>
206 
207         if (Context::useFastTLS())
208             jit.loadWasmContextInstance(baseMemory);
209 
210         GPRReg currentInstanceGPR = Context::useFastTLS() ? baseMemory : wasmContextInstanceGPR;
211         if (isARM64E()) {
212             if (mode != Wasm::MemoryMode::Signaling)
213                 scratchOrSize = pinnedRegs.sizeRegister;
214             jit.loadPtr(CCallHelpers::Address(currentInstanceGPR, Wasm::Instance::offsetOfCachedMemorySize()), scratchOrSize);
215         } else {
216             if (mode != Wasm::MemoryMode::Signaling)
217                 jit.loadPtr(CCallHelpers::Address(currentInstanceGPR, Wasm::Instance::offsetOfCachedMemorySize()), pinnedRegs.sizeRegister);
218         }
219 
220         jit.loadPtr(CCallHelpers::Address(currentInstanceGPR, Wasm::Instance::offsetOfCachedMemory()), baseMemory);
221         jit.cageConditionally(Gigacage::Primitive, baseMemory, scratchOrSize, scratchOrSize);
222     }
223 
224     CCallHelpers::Call call = jit.threadSafePatchableNearCall();
225     unsigned functionIndexSpace = functionIndex + info.importFunctionCount();
226     ASSERT(functionIndexSpace &lt; info.functionIndexSpaceSize());
227     jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndexSpace] (LinkBuffer&amp; linkBuffer) {
228         unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndexSpace });
229     });
230 


231     for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {
232         GPRReg reg = regAtOffset.reg().gpr();
233         ASSERT(reg != GPRInfo::returnValueGPR);
234         ptrdiff_t offset = regAtOffset.offset();
235         jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, offset), reg);
236     }
237 
<span class="line-removed">238     switch (signature.returnType()) {</span>
<span class="line-removed">239     case Wasm::Void:</span>
<span class="line-removed">240         jit.moveTrustedValue(jsUndefined(), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-removed">241         break;</span>
<span class="line-removed">242     case Wasm::Anyref:</span>
<span class="line-removed">243     case Wasm::Funcref:</span>
<span class="line-removed">244         break;</span>
<span class="line-removed">245     case Wasm::I32:</span>
<span class="line-removed">246         jit.zeroExtend32ToPtr(GPRInfo::returnValueGPR, GPRInfo::returnValueGPR);</span>
<span class="line-removed">247         jit.boxInt32(GPRInfo::returnValueGPR, JSValueRegs { GPRInfo::returnValueGPR }, DoNotHaveTagRegisters);</span>
<span class="line-removed">248         break;</span>
<span class="line-removed">249     case Wasm::F32:</span>
<span class="line-removed">250         jit.convertFloatToDouble(FPRInfo::returnValueFPR, FPRInfo::returnValueFPR);</span>
<span class="line-removed">251         FALLTHROUGH;</span>
<span class="line-removed">252     case Wasm::F64: {</span>
<span class="line-removed">253         jit.moveTrustedValue(jsNumber(pureNaN()), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-removed">254         auto isNaN = jit.branchIfNaN(FPRInfo::returnValueFPR);</span>
<span class="line-removed">255         jit.boxDouble(FPRInfo::returnValueFPR, JSValueRegs { GPRInfo::returnValueGPR }, DoNotHaveTagRegisters);</span>
<span class="line-removed">256         isNaN.link(&amp;jit);</span>
<span class="line-removed">257         break;</span>
<span class="line-removed">258     }</span>
<span class="line-removed">259     case Wasm::I64:</span>
<span class="line-removed">260     case Wasm::Func:</span>
<span class="line-removed">261         jit.breakpoint();</span>
<span class="line-removed">262         break;</span>
<span class="line-removed">263     default:</span>
<span class="line-removed">264         break;</span>
<span class="line-removed">265     }</span>
<span class="line-removed">266 </span>
267     jit.emitFunctionEpilogue();
268     jit.ret();
269 
270     return result;
271 }
272 
273 } } // namespace JSC::Wasm
274 
275 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
<td>
<hr />
<pre>
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;JSToWasm.h&quot;
 28 
 29 #if ENABLE(WEBASSEMBLY)
 30 
 31 #include &quot;CCallHelpers.h&quot;
 32 #include &quot;DisallowMacroScratchRegisterUsage.h&quot;
<span class="line-added"> 33 #include &quot;FrameTracers.h&quot;</span>
 34 #include &quot;JSCInlines.h&quot;
 35 #include &quot;JSWebAssemblyHelpers.h&quot;
 36 #include &quot;JSWebAssemblyInstance.h&quot;
 37 #include &quot;JSWebAssemblyRuntimeError.h&quot;
 38 #include &quot;MaxFrameExtentForSlowPathCall.h&quot;
 39 #include &quot;WasmCallingConvention.h&quot;
 40 #include &quot;WasmContextInlines.h&quot;
<span class="line-added"> 41 #include &quot;WasmOperations.h&quot;</span>
 42 #include &quot;WasmSignatureInlines.h&quot;
 43 #include &quot;WasmToJS.h&quot;
 44 
 45 namespace JSC { namespace Wasm {
 46 
<span class="line-modified"> 47 inline void boxWasmResult(CCallHelpers&amp; jit, Wasm::Type type, Reg src, JSValueRegs dst)</span>
 48 {
<span class="line-modified"> 49     switch (type) {</span>
<span class="line-added"> 50     case Wasm::Void:</span>
<span class="line-added"> 51         jit.moveTrustedValue(jsUndefined(), dst);</span>
<span class="line-added"> 52         break;</span>
<span class="line-added"> 53     case Wasm::Anyref:</span>
<span class="line-added"> 54     case Wasm::Funcref:</span>
<span class="line-added"> 55         jit.move(src.gpr(), dst.payloadGPR());</span>
<span class="line-added"> 56         break;</span>
<span class="line-added"> 57     case Wasm::I32:</span>
<span class="line-added"> 58         jit.zeroExtend32ToPtr(src.gpr(), dst.payloadGPR());</span>
<span class="line-added"> 59         jit.boxInt32(dst.payloadGPR(), dst, DoNotHaveTagRegisters);</span>
<span class="line-added"> 60         break;</span>
<span class="line-added"> 61     case Wasm::F32:</span>
<span class="line-added"> 62         jit.convertFloatToDouble(src.fpr(), src.fpr());</span>
<span class="line-added"> 63         FALLTHROUGH;</span>
<span class="line-added"> 64     case Wasm::F64: {</span>
<span class="line-added"> 65         jit.moveTrustedValue(jsNumber(pureNaN()), dst);</span>
<span class="line-added"> 66         auto isNaN = jit.branchIfNaN(src.fpr());</span>
<span class="line-added"> 67         jit.boxDouble(src.fpr(), dst, DoNotHaveTagRegisters);</span>
<span class="line-added"> 68         isNaN.link(&amp;jit);</span>
<span class="line-added"> 69         break;</span>
<span class="line-added"> 70     }</span>
<span class="line-added"> 71     default:</span>
<span class="line-added"> 72         jit.breakpoint();</span>
<span class="line-added"> 73         break;</span>
<span class="line-added"> 74     }</span>
<span class="line-added"> 75 }</span>
<span class="line-added"> 76 </span>
<span class="line-added"> 77 void marshallJSResult(CCallHelpers&amp; jit, const Signature&amp; signature, const CallInformation&amp; wasmFrameConvention, const RegisterAtOffsetList&amp; savedResultRegisters)</span>
<span class="line-added"> 78 {</span>
<span class="line-added"> 79     if (signature.returnsVoid())</span>
<span class="line-added"> 80         jit.moveTrustedValue(jsUndefined(), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-added"> 81     else if (signature.returnCount() == 1)</span>
<span class="line-added"> 82         boxWasmResult(jit, signature.returnType(0), wasmFrameConvention.results[0].reg(), JSValueRegs { GPRInfo::returnValueGPR });</span>
<span class="line-added"> 83     else {</span>
<span class="line-added"> 84         IndexingType indexingType = ArrayWithUndecided;</span>
<span class="line-added"> 85         JSValueRegs scratch = JSValueRegs { wasmCallingConvention().prologueScratchGPRs[1] };</span>
<span class="line-added"> 86         // We can use the first floating point register as a scratch since it will always be moved onto the stack before other values.</span>
<span class="line-added"> 87         FPRReg fprScratch = wasmCallingConvention().fprArgs[0].fpr();</span>
<span class="line-added"> 88         for (unsigned i = 0; i &lt; signature.returnCount(); ++i) {</span>
<span class="line-added"> 89             B3::ValueRep rep = wasmFrameConvention.results[i];</span>
<span class="line-added"> 90             Type type = signature.returnType(i);</span>
<span class="line-added"> 91 </span>
<span class="line-added"> 92             if (rep.isReg()) {</span>
<span class="line-added"> 93                 boxWasmResult(jit, signature.returnType(i), rep.reg(), scratch);</span>
<span class="line-added"> 94                 jit.storeValue(scratch, CCallHelpers::Address(CCallHelpers::stackPointerRegister, savedResultRegisters.find(rep.reg())-&gt;offset() + wasmFrameConvention.headerAndArgumentStackSizeInBytes));</span>
<span class="line-added"> 95             } else {</span>
<span class="line-added"> 96                 auto location = CCallHelpers::Address(CCallHelpers::stackPointerRegister, rep.offsetFromSP());</span>
<span class="line-added"> 97                 Reg tmp = type == F32 || type == F64 ? Reg(fprScratch) : Reg(scratch.gpr());</span>
<span class="line-added"> 98                 jit.load64ToReg(location, tmp);</span>
<span class="line-added"> 99                 boxWasmResult(jit, signature.returnType(i), tmp, scratch);</span>
<span class="line-added">100                 jit.storeValue(scratch, location);</span>
<span class="line-added">101             }</span>
<span class="line-added">102 </span>
<span class="line-added">103             switch (type) {</span>
<span class="line-added">104             case Wasm::I32:</span>
<span class="line-added">105                 indexingType = leastUpperBoundOfIndexingTypes(indexingType, ArrayWithInt32);</span>
<span class="line-added">106                 break;</span>
<span class="line-added">107             case Wasm::F32:</span>
<span class="line-added">108             case Wasm::F64:</span>
<span class="line-added">109                 indexingType = leastUpperBoundOfIndexingTypes(indexingType, ArrayWithDouble);</span>
<span class="line-added">110                 break;</span>
<span class="line-added">111             default:</span>
<span class="line-added">112                 indexingType = leastUpperBoundOfIndexingTypes(indexingType, ArrayWithContiguous);</span>
<span class="line-added">113                 break;</span>
<span class="line-added">114             }</span>
<span class="line-added">115         }</span>
<span class="line-added">116 </span>
<span class="line-added">117         GPRReg wasmContextInstanceGPR = PinnedRegisterInfo::get().wasmContextInstancePointer;</span>
<span class="line-added">118         if (Context::useFastTLS()) {</span>
<span class="line-added">119             wasmContextInstanceGPR = GPRInfo::argumentGPR1;</span>
<span class="line-added">120             static_assert(std::is_same_v&lt;Wasm::Instance*, typename FunctionTraits&lt;decltype(operationAllocateResultsArray)&gt;::ArgumentType&lt;1&gt;&gt;);</span>
<span class="line-added">121             jit.loadWasmContextInstance(wasmContextInstanceGPR);</span>
<span class="line-added">122         }</span>
<span class="line-added">123 </span>
<span class="line-added">124         jit.setupArguments&lt;decltype(operationAllocateResultsArray)&gt;(wasmContextInstanceGPR, CCallHelpers::TrustedImmPtr(&amp;signature), indexingType, CCallHelpers::stackPointerRegister);</span>
<span class="line-added">125         jit.callOperation(FunctionPtr&lt;OperationPtrTag&gt;(operationAllocateResultsArray));</span>
<span class="line-added">126     }</span>
<span class="line-added">127 }</span>
128 
<span class="line-added">129 std::unique_ptr&lt;InternalFunction&gt; createJSToWasmWrapper(CCallHelpers&amp; jit, const Signature&amp; signature, Vector&lt;UnlinkedWasmToWasmCall&gt;* unlinkedWasmToWasmCalls, const ModuleInformation&amp; info, MemoryMode mode, unsigned functionIndex)</span>
<span class="line-added">130 {</span>
131     auto result = makeUnique&lt;InternalFunction&gt;();
132     jit.emitFunctionPrologue();
133 
134     // FIXME Stop using 0 as codeBlocks. https://bugs.webkit.org/show_bug.cgi?id=165321
135     jit.store64(CCallHelpers::TrustedImm64(0), CCallHelpers::Address(GPRInfo::callFrameRegister, CallFrameSlot::codeBlock * static_cast&lt;int&gt;(sizeof(Register))));
136     MacroAssembler::DataLabelPtr calleeMoveLocation = jit.moveWithPatch(MacroAssembler::TrustedImmPtr(nullptr), GPRInfo::nonPreservedNonReturnGPR);
137     jit.storePtr(GPRInfo::nonPreservedNonReturnGPR, CCallHelpers::Address(GPRInfo::callFrameRegister, CallFrameSlot::callee * static_cast&lt;int&gt;(sizeof(Register))));
138     CodeLocationDataLabelPtr&lt;WasmEntryPtrTag&gt;* linkedCalleeMove = &amp;result-&gt;calleeMoveLocation;
139     jit.addLinkTask([=] (LinkBuffer&amp; linkBuffer) {
140         *linkedCalleeMove = linkBuffer.locationOf&lt;WasmEntryPtrTag&gt;(calleeMoveLocation);
141     });
142 
143     const PinnedRegisterInfo&amp; pinnedRegs = PinnedRegisterInfo::get();
144     RegisterSet toSave = pinnedRegs.toSave(mode);
145 
<span class="line-modified">146 #if ASSERT_ENABLED</span>
147     unsigned toSaveSize = toSave.numberOfSetGPRs();
148     // They should all be callee saves.
149     toSave.filter(RegisterSet::calleeSaveRegisters());
150     ASSERT(toSave.numberOfSetGPRs() == toSaveSize);
151 #endif
152 
153     RegisterAtOffsetList registersToSpill(toSave, RegisterAtOffsetList::OffsetBaseType::FramePointerBased);
154     result-&gt;entrypoint.calleeSaveRegisters = registersToSpill;
155 
<span class="line-modified">156     size_t totalFrameSize = registersToSpill.size() * sizeof(CPURegister);</span>
<span class="line-modified">157     CallInformation wasmFrameConvention = wasmCallingConvention().callInformationFor(signature);</span>
<span class="line-modified">158     RegisterAtOffsetList savedResultRegisters = wasmFrameConvention.computeResultsOffsetList();</span>
<span class="line-modified">159     totalFrameSize += wasmFrameConvention.headerAndArgumentStackSizeInBytes;</span>
<span class="line-modified">160     totalFrameSize += savedResultRegisters.size() * sizeof(CPURegister);</span>























161 
162     totalFrameSize = WTF::roundUpToMultipleOf(stackAlignmentBytes(), totalFrameSize);
163     jit.subPtr(MacroAssembler::TrustedImm32(totalFrameSize), MacroAssembler::stackPointerRegister);
164 
165     // We save all these registers regardless of having a memory or not.
166     // The reason is that we use one of these as a scratch. That said,
167     // almost all real wasm programs use memory, so it&#39;s not really
168     // worth optimizing for the case that they don&#39;t.
169     for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {
170         GPRReg reg = regAtOffset.reg().gpr();
171         ptrdiff_t offset = regAtOffset.offset();
172         jit.storePtr(reg, CCallHelpers::Address(GPRInfo::callFrameRegister, offset));
173     }
174 
<span class="line-modified">175     if (wasmFrameConvention.argumentsIncludeI64 || wasmFrameConvention.resultsIncludeI64) {</span>
176         if (Context::useFastTLS())
177             jit.loadWasmContextInstance(GPRInfo::argumentGPR2);
178         else {
179             // vmEntryToWasm passes the JSWebAssemblyInstance corresponding to Wasm::Context*&#39;s
180             // instance as the first JS argument when we&#39;re not using fast TLS to hold the
181             // Wasm::Context*&#39;s instance.
182             jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, CallFrameSlot::thisArgument * sizeof(EncodedJSValue)), GPRInfo::argumentGPR2);
183             jit.loadPtr(CCallHelpers::Address(GPRInfo::argumentGPR2, JSWebAssemblyInstance::offsetOfInstance()), GPRInfo::argumentGPR2);
184         }
185 
<span class="line-modified">186         emitThrowWasmToJSException(jit, GPRInfo::argumentGPR2, wasmFrameConvention.argumentsIncludeI64 ? ExceptionType::I64ArgumentType : ExceptionType::I64ReturnType);</span>
187         return result;
188     }
189 
190     GPRReg wasmContextInstanceGPR = pinnedRegs.wasmContextInstancePointer;
191 
192     {
<span class="line-modified">193         CallInformation jsFrameConvention = jsCallingConvention().callInformationFor(signature, CallRole::Callee);</span>
<span class="line-modified">194 </span>
<span class="line-modified">195         CCallHelpers::Address calleeFrame = CCallHelpers::Address(MacroAssembler::stackPointerRegister, 0);</span>
<span class="line-added">196 </span>
197         // We&#39;re going to set the pinned registers after this. So
198         // we can use this as a scratch for now since we saved it above.
199         GPRReg scratchReg = pinnedRegs.baseMemoryPointer;
200 





201         if (!Context::useFastTLS()) {
<span class="line-modified">202             jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, JSCallingConvention::instanceStackOffset), wasmContextInstanceGPR);</span>
203             jit.loadPtr(CCallHelpers::Address(wasmContextInstanceGPR, JSWebAssemblyInstance::offsetOfInstance()), wasmContextInstanceGPR);

204         }
205 

206         for (unsigned i = 0; i &lt; signature.argumentCount(); i++) {
<span class="line-modified">207             RELEASE_ASSERT(jsFrameConvention.params[i].isStack());</span>
<span class="line-modified">208 </span>
<span class="line-modified">209             Type type = signature.argument(i);</span>
<span class="line-modified">210             CCallHelpers::Address jsParam(GPRInfo::callFrameRegister, jsFrameConvention.params[i].offsetFromFP());</span>
<span class="line-modified">211             if (wasmFrameConvention.params[i].isStackArgument()) {</span>
<span class="line-modified">212                 if (type == Wasm::I32 || type == Wasm::F32) {</span>
<span class="line-modified">213                     jit.load32(jsParam, scratchReg);</span>
<span class="line-modified">214                     jit.store32(scratchReg, calleeFrame.withOffset(wasmFrameConvention.params[i].offsetFromSP()));</span>

























215                 } else {
<span class="line-modified">216                     jit.load64(jsParam, scratchReg);</span>
<span class="line-modified">217                     jit.store64(scratchReg, calleeFrame.withOffset(wasmFrameConvention.params[i].offsetFromSP()));</span>


218                 }
<span class="line-modified">219             } else {</span>
<span class="line-modified">220                 if (type == Wasm::I32 || type == Wasm::F32)</span>
<span class="line-modified">221                     jit.load32ToReg(jsParam, wasmFrameConvention.params[i].reg());</span>
<span class="line-modified">222                 else</span>
<span class="line-added">223                     jit.load64ToReg(jsParam, wasmFrameConvention.params[i].reg());</span>
224             }


225         }
226     }
227 
228     if (!!info.memory) {
229         GPRReg baseMemory = pinnedRegs.baseMemoryPointer;
<span class="line-modified">230         GPRReg scratchOrSize = wasmCallingConvention().prologueScratchGPRs[0];</span>
231 
232         if (Context::useFastTLS())
233             jit.loadWasmContextInstance(baseMemory);
234 
235         GPRReg currentInstanceGPR = Context::useFastTLS() ? baseMemory : wasmContextInstanceGPR;
236         if (isARM64E()) {
237             if (mode != Wasm::MemoryMode::Signaling)
238                 scratchOrSize = pinnedRegs.sizeRegister;
239             jit.loadPtr(CCallHelpers::Address(currentInstanceGPR, Wasm::Instance::offsetOfCachedMemorySize()), scratchOrSize);
240         } else {
241             if (mode != Wasm::MemoryMode::Signaling)
242                 jit.loadPtr(CCallHelpers::Address(currentInstanceGPR, Wasm::Instance::offsetOfCachedMemorySize()), pinnedRegs.sizeRegister);
243         }
244 
245         jit.loadPtr(CCallHelpers::Address(currentInstanceGPR, Wasm::Instance::offsetOfCachedMemory()), baseMemory);
246         jit.cageConditionally(Gigacage::Primitive, baseMemory, scratchOrSize, scratchOrSize);
247     }
248 
249     CCallHelpers::Call call = jit.threadSafePatchableNearCall();
250     unsigned functionIndexSpace = functionIndex + info.importFunctionCount();
251     ASSERT(functionIndexSpace &lt; info.functionIndexSpaceSize());
252     jit.addLinkTask([unlinkedWasmToWasmCalls, call, functionIndexSpace] (LinkBuffer&amp; linkBuffer) {
253         unlinkedWasmToWasmCalls-&gt;append({ linkBuffer.locationOfNearCall&lt;WasmEntryPtrTag&gt;(call), functionIndexSpace });
254     });
255 
<span class="line-added">256     marshallJSResult(jit, signature, wasmFrameConvention, savedResultRegisters);</span>
<span class="line-added">257 </span>
258     for (const RegisterAtOffset&amp; regAtOffset : registersToSpill) {
259         GPRReg reg = regAtOffset.reg().gpr();
260         ASSERT(reg != GPRInfo::returnValueGPR);
261         ptrdiff_t offset = regAtOffset.offset();
262         jit.loadPtr(CCallHelpers::Address(GPRInfo::callFrameRegister, offset), reg);
263     }
264 





























265     jit.emitFunctionEpilogue();
266     jit.ret();
267 
268     return result;
269 }
270 
271 } } // namespace JSC::Wasm
272 
273 #endif // ENABLE(WEBASSEMBLY)
</pre>
</td>
</tr>
</table>
<center><a href="../generateWasmOpsHeader.py.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSToWasm.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
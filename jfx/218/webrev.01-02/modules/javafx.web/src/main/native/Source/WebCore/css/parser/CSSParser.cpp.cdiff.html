<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParser.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../makeprop.pl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSParser.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParser.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 30,24 ***</span>
  
  #include &quot;CSSCustomPropertyValue.h&quot;
  #include &quot;CSSKeyframeRule.h&quot;
  #include &quot;CSSParserFastPaths.h&quot;
  #include &quot;CSSParserImpl.h&quot;
  #include &quot;CSSPendingSubstitutionValue.h&quot;
  #include &quot;CSSPropertyParser.h&quot;
  #include &quot;CSSSelectorParser.h&quot;
  #include &quot;CSSSupportsParser.h&quot;
  #include &quot;CSSTokenizer.h&quot;
  #include &quot;CSSVariableData.h&quot;
  #include &quot;CSSVariableReferenceValue.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;Element.h&quot;
  #include &quot;Page.h&quot;
  #include &quot;RenderStyle.h&quot;
  #include &quot;RenderTheme.h&quot;
<span class="line-removed">- #include &quot;RuntimeEnabledFeatures.h&quot;</span>
  #include &quot;Settings.h&quot;
  #include &quot;StyleColor.h&quot;
  #include &quot;StyleResolver.h&quot;
  #include &quot;StyleRule.h&quot;
  #include &quot;StyleSheetContents.h&quot;
  #include &lt;wtf/NeverDestroyed.h&gt;
<span class="line-new-header">--- 30,27 ---</span>
  
  #include &quot;CSSCustomPropertyValue.h&quot;
  #include &quot;CSSKeyframeRule.h&quot;
  #include &quot;CSSParserFastPaths.h&quot;
  #include &quot;CSSParserImpl.h&quot;
<span class="line-added">+ #include &quot;CSSParserTokenRange.h&quot;</span>
  #include &quot;CSSPendingSubstitutionValue.h&quot;
  #include &quot;CSSPropertyParser.h&quot;
<span class="line-added">+ #include &quot;CSSPropertyParserHelpers.h&quot;</span>
  #include &quot;CSSSelectorParser.h&quot;
  #include &quot;CSSSupportsParser.h&quot;
  #include &quot;CSSTokenizer.h&quot;
<span class="line-added">+ #include &quot;CSSValuePool.h&quot;</span>
  #include &quot;CSSVariableData.h&quot;
  #include &quot;CSSVariableReferenceValue.h&quot;
  #include &quot;Document.h&quot;
  #include &quot;Element.h&quot;
  #include &quot;Page.h&quot;
  #include &quot;RenderStyle.h&quot;
  #include &quot;RenderTheme.h&quot;
  #include &quot;Settings.h&quot;
<span class="line-added">+ #include &quot;StyleBuilder.h&quot;</span>
  #include &quot;StyleColor.h&quot;
  #include &quot;StyleResolver.h&quot;
  #include &quot;StyleRule.h&quot;
  #include &quot;StyleSheetContents.h&quot;
  #include &lt;wtf/NeverDestroyed.h&gt;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 98,11 ***</span>
      Color namedColor { string };
      if (namedColor.isValid())
          return namedColor;
  
      // Try the fast path to parse hex and rgb.
<span class="line-modified">!     RefPtr&lt;CSSValue&gt; value = CSSParserFastPaths::parseColor(string, strict ? HTMLStandardMode : HTMLQuirksMode);</span>
  
      // If that fails, try the full parser.
      if (!value)
          value = parseSingleValue(CSSPropertyColor, string, strictCSSParserContext());
      if (!value || !value-&gt;isPrimitiveValue())
<span class="line-new-header">--- 101,11 ---</span>
      Color namedColor { string };
      if (namedColor.isValid())
          return namedColor;
  
      // Try the fast path to parse hex and rgb.
<span class="line-modified">!     RefPtr&lt;CSSValue&gt; value = CSSParserFastPaths::parseColor(string, strict ? HTMLStandardMode : HTMLQuirksMode, CSSValuePool::singleton());</span>
  
      // If that fails, try the full parser.
      if (!value)
          value = parseSingleValue(CSSPropertyColor, string, strictCSSParserContext());
      if (!value || !value-&gt;isPrimitiveValue())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 111,10 ***</span>
<span class="line-new-header">--- 114,31 ---</span>
      if (!primitiveValue.isRGBColor())
          return Color();
      return primitiveValue.color();
  }
  
<span class="line-added">+ Color CSSParser::parseColorWorkerSafe(const String&amp; string, CSSValuePool&amp; valuePool, bool strict)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (string.isEmpty())</span>
<span class="line-added">+         return Color();</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Try named colors first.</span>
<span class="line-added">+     Color namedColor { string };</span>
<span class="line-added">+     if (namedColor.isValid())</span>
<span class="line-added">+         return namedColor;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Try the fast path to parse hex and rgb.</span>
<span class="line-added">+     RefPtr&lt;CSSValue&gt; value = CSSParserFastPaths::parseColor(string, strict ? HTMLStandardMode : HTMLQuirksMode, valuePool);</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (!value || !value-&gt;isPrimitiveValue())</span>
<span class="line-added">+         return Color();</span>
<span class="line-added">+     const auto&amp; primitiveValue = downcast&lt;CSSPrimitiveValue&gt;(*value);</span>
<span class="line-added">+     if (!primitiveValue.isRGBColor())</span>
<span class="line-added">+         return Color();</span>
<span class="line-added">+     return primitiveValue.color();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  Color CSSParser::parseSystemColor(const String&amp; string, const CSSParserContext* context)
  {
      CSSValueID id = cssValueKeywordID(string);
      if (!StyleColor::isSystemColor(id))
          return Color();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 175,14 ***</span>
  void CSSParser::parseDeclarationForInspector(const CSSParserContext&amp; context, const String&amp; string, CSSParserObserver&amp; observer)
  {
      CSSParserImpl::parseDeclarationListForInspector(string, context, observer);
  }
  
<span class="line-modified">! RefPtr&lt;CSSValue&gt; CSSParser::parseValueWithVariableReferences(CSSPropertyID propID, const CSSValue&amp; value, ApplyCascadedPropertyState&amp; state)</span>
  {
      ASSERT((propID == CSSPropertyCustom &amp;&amp; value.isCustomPropertyValue()) || (propID != CSSPropertyCustom &amp;&amp; !value.isCustomPropertyValue()));
<span class="line-modified">!     auto&amp; style = *state.styleResolver-&gt;style();</span>
      auto direction = style.direction();
      auto writingMode = style.writingMode();
  
      if (value.isPendingSubstitutionValue()) {
          // FIXME: Should have a resolvedShorthands cache to stop this from being done
<span class="line-new-header">--- 199,14 ---</span>
  void CSSParser::parseDeclarationForInspector(const CSSParserContext&amp; context, const String&amp; string, CSSParserObserver&amp; observer)
  {
      CSSParserImpl::parseDeclarationListForInspector(string, context, observer);
  }
  
<span class="line-modified">! RefPtr&lt;CSSValue&gt; CSSParser::parseValueWithVariableReferences(CSSPropertyID propID, const CSSValue&amp; value, Style::BuilderState&amp; builderState)</span>
  {
      ASSERT((propID == CSSPropertyCustom &amp;&amp; value.isCustomPropertyValue()) || (propID != CSSPropertyCustom &amp;&amp; !value.isCustomPropertyValue()));
<span class="line-modified">!     auto&amp; style = builderState.style();</span>
      auto direction = style.direction();
      auto writingMode = style.writingMode();
  
      if (value.isPendingSubstitutionValue()) {
          // FIXME: Should have a resolvedShorthands cache to stop this from being done
</pre>
<hr />
<pre>
<span class="line-old-header">*** 191,17 ***</span>
          CSSPropertyID shorthandID = pendingSubstitution.shorthandPropertyId();
          if (CSSProperty::isDirectionAwareProperty(shorthandID))
              shorthandID = CSSProperty::resolveDirectionAwareProperty(shorthandID, direction, writingMode);
          CSSVariableReferenceValue* shorthandValue = pendingSubstitution.shorthandValue();
  
<span class="line-modified">!         auto resolvedData = shorthandValue-&gt;resolveVariableReferences(state);</span>
          if (!resolvedData)
              return nullptr;
          Vector&lt;CSSParserToken&gt; resolvedTokens = resolvedData-&gt;tokens();
  
          ParsedPropertyVector parsedProperties;
<span class="line-modified">!         if (!CSSPropertyParser::parseValue(shorthandID, false, resolvedTokens, m_context, parsedProperties, StyleRule::Style))</span>
              return nullptr;
  
          for (auto&amp; property : parsedProperties) {
              if (property.id() == propID)
                  return property.value();
<span class="line-new-header">--- 215,17 ---</span>
          CSSPropertyID shorthandID = pendingSubstitution.shorthandPropertyId();
          if (CSSProperty::isDirectionAwareProperty(shorthandID))
              shorthandID = CSSProperty::resolveDirectionAwareProperty(shorthandID, direction, writingMode);
          CSSVariableReferenceValue* shorthandValue = pendingSubstitution.shorthandValue();
  
<span class="line-modified">!         auto resolvedData = shorthandValue-&gt;resolveVariableReferences(builderState);</span>
          if (!resolvedData)
              return nullptr;
          Vector&lt;CSSParserToken&gt; resolvedTokens = resolvedData-&gt;tokens();
  
          ParsedPropertyVector parsedProperties;
<span class="line-modified">!         if (!CSSPropertyParser::parseValue(shorthandID, false, resolvedTokens, m_context, parsedProperties, StyleRuleType::Style))</span>
              return nullptr;
  
          for (auto&amp; property : parsedProperties) {
              if (property.id() == propID)
                  return property.value();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 210,35 ***</span>
          return nullptr;
      }
  
      if (value.isVariableReferenceValue()) {
          const CSSVariableReferenceValue&amp; valueWithReferences = downcast&lt;CSSVariableReferenceValue&gt;(value);
<span class="line-modified">!         auto resolvedData = valueWithReferences.resolveVariableReferences(state);</span>
          if (!resolvedData)
              return nullptr;
          return CSSPropertyParser::parseSingleValue(propID, resolvedData-&gt;tokens(), m_context);
      }
  
      const auto&amp; customPropValue = downcast&lt;CSSCustomPropertyValue&gt;(value);
      const auto&amp; valueWithReferences = WTF::get&lt;Ref&lt;CSSVariableReferenceValue&gt;&gt;(customPropValue.value()).get();
  
      auto&amp; name = downcast&lt;CSSCustomPropertyValue&gt;(value).name();
<span class="line-modified">!     auto* registered = state.styleResolver-&gt;document().getCSSRegisteredCustomPropertySet().get(name);</span>
      auto&amp; syntax = registered ? registered-&gt;syntax : &quot;*&quot;;
<span class="line-modified">!     auto resolvedData = valueWithReferences.resolveVariableReferences(state);</span>
  
      if (!resolvedData)
          return nullptr;
  
      // FIXME handle REM cycles.
      HashSet&lt;CSSPropertyID&gt; dependencies;
      CSSPropertyParser::collectParsedCustomPropertyValueDependencies(syntax, false, dependencies, resolvedData-&gt;tokens(), m_context);
  
      for (auto id : dependencies)
<span class="line-modified">!         state.styleResolver-&gt;applyCascadedProperties(id, id, state);</span>
  
<span class="line-modified">!     return CSSPropertyParser::parseTypedCustomPropertyValue(name, syntax, resolvedData-&gt;tokens(), *state.styleResolver, m_context);</span>
  }
  
  std::unique_ptr&lt;Vector&lt;double&gt;&gt; CSSParser::parseKeyframeKeyList(const String&amp; selector)
  {
      return CSSParserImpl::parseKeyframeKeyList(selector);
<span class="line-new-header">--- 234,35 ---</span>
          return nullptr;
      }
  
      if (value.isVariableReferenceValue()) {
          const CSSVariableReferenceValue&amp; valueWithReferences = downcast&lt;CSSVariableReferenceValue&gt;(value);
<span class="line-modified">!         auto resolvedData = valueWithReferences.resolveVariableReferences(builderState);</span>
          if (!resolvedData)
              return nullptr;
          return CSSPropertyParser::parseSingleValue(propID, resolvedData-&gt;tokens(), m_context);
      }
  
      const auto&amp; customPropValue = downcast&lt;CSSCustomPropertyValue&gt;(value);
      const auto&amp; valueWithReferences = WTF::get&lt;Ref&lt;CSSVariableReferenceValue&gt;&gt;(customPropValue.value()).get();
  
      auto&amp; name = downcast&lt;CSSCustomPropertyValue&gt;(value).name();
<span class="line-modified">!     auto* registered = builderState.document().getCSSRegisteredCustomPropertySet().get(name);</span>
      auto&amp; syntax = registered ? registered-&gt;syntax : &quot;*&quot;;
<span class="line-modified">!     auto resolvedData = valueWithReferences.resolveVariableReferences(builderState);</span>
  
      if (!resolvedData)
          return nullptr;
  
      // FIXME handle REM cycles.
      HashSet&lt;CSSPropertyID&gt; dependencies;
      CSSPropertyParser::collectParsedCustomPropertyValueDependencies(syntax, false, dependencies, resolvedData-&gt;tokens(), m_context);
  
      for (auto id : dependencies)
<span class="line-modified">!         builderState.builder().applyProperty(id);</span>
  
<span class="line-modified">!     return CSSPropertyParser::parseTypedCustomPropertyValue(name, syntax, resolvedData-&gt;tokens(), builderState, m_context);</span>
  }
  
  std::unique_ptr&lt;Vector&lt;double&gt;&gt; CSSParser::parseKeyframeKeyList(const String&amp; selector)
  {
      return CSSParserImpl::parseKeyframeKeyList(selector);
</pre>
<center><a href="../makeprop.pl.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CSSParser.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/page/Frame.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 1998, 1999 Torben Weis &lt;weis@kde.org&gt;
   3  *                     1999 Lars Knoll &lt;knoll@kde.org&gt;
   4  *                     1999 Antti Koivisto &lt;koivisto@kde.org&gt;
   5  *                     2000 Simon Hausmann &lt;hausmann@kde.org&gt;
   6  *                     2000 Stefan Schimanski &lt;1Stein@gmx.de&gt;
   7  *                     2001 George Staikos &lt;staikos@kde.org&gt;
   8  * Copyright (C) 2004-2019 Apple Inc. All rights reserved.
   9  * Copyright (C) 2005 Alexey Proskuryakov &lt;ap@nypop.com&gt;
  10  * Copyright (C) 2008 Nokia Corporation and/or its subsidiary(-ies)
  11  * Copyright (C) 2008 Eric Seidel &lt;eric@webkit.org&gt;
  12  * Copyright (C) 2008 Google Inc.
  13  *
  14  * This library is free software; you can redistribute it and/or
  15  * modify it under the terms of the GNU Library General Public
  16  * License as published by the Free Software Foundation; either
  17  * version 2 of the License, or (at your option) any later version.
  18  *
  19  * This library is distributed in the hope that it will be useful,
  20  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  21  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  22  * Library General Public License for more details.
  23  *
  24  * You should have received a copy of the GNU Library General Public License
  25  * along with this library; see the file COPYING.LIB.  If not, write to
  26  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  27  * Boston, MA 02110-1301, USA.
  28  */
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;Frame.h&quot;
  32 
  33 #include &quot;ApplyStyleCommand.h&quot;
  34 #include &quot;BackForwardCache.h&quot;
  35 #include &quot;BackForwardController.h&quot;
  36 #include &quot;CSSAnimationController.h&quot;
  37 #include &quot;CSSComputedStyleDeclaration.h&quot;
  38 #include &quot;CSSPropertyNames.h&quot;
  39 #include &quot;CachedCSSStyleSheet.h&quot;
  40 #include &quot;CachedResourceLoader.h&quot;
  41 #include &quot;Chrome.h&quot;
  42 #include &quot;ChromeClient.h&quot;
  43 #include &quot;DOMWindow.h&quot;
  44 #include &quot;DocumentTimeline.h&quot;
  45 #include &quot;DocumentType.h&quot;
  46 #include &quot;Editing.h&quot;
  47 #include &quot;Editor.h&quot;
  48 #include &quot;EditorClient.h&quot;
  49 #include &quot;Event.h&quot;
  50 #include &quot;EventHandler.h&quot;
  51 #include &quot;EventNames.h&quot;
  52 #include &quot;FloatQuad.h&quot;
  53 #include &quot;FocusController.h&quot;
  54 #include &quot;FrameDestructionObserver.h&quot;
  55 #include &quot;FrameLoader.h&quot;
  56 #include &quot;FrameLoaderClient.h&quot;
  57 #include &quot;FrameSelection.h&quot;
  58 #include &quot;FrameView.h&quot;
  59 #include &quot;GraphicsContext.h&quot;
  60 #include &quot;GraphicsLayer.h&quot;
  61 #include &quot;HTMLFormControlElement.h&quot;
  62 #include &quot;HTMLFormElement.h&quot;
  63 #include &quot;HTMLFrameElementBase.h&quot;
  64 #include &quot;HTMLNames.h&quot;
  65 #include &quot;HTMLTableCellElement.h&quot;
  66 #include &quot;HTMLTableRowElement.h&quot;
  67 #include &quot;HitTestResult.h&quot;
  68 #include &quot;ImageBuffer.h&quot;
  69 #include &quot;InspectorInstrumentation.h&quot;
  70 #include &quot;JSWindowProxy.h&quot;
  71 #include &quot;Logging.h&quot;
  72 #include &quot;NavigationScheduler.h&quot;
  73 #include &quot;Navigator.h&quot;
  74 #include &quot;NodeList.h&quot;
  75 #include &quot;NodeTraversal.h&quot;
  76 #include &quot;Page.h&quot;
  77 #include &quot;ProcessWarming.h&quot;
  78 #include &quot;RenderLayerCompositor.h&quot;
  79 #include &quot;RenderTableCell.h&quot;
  80 #include &quot;RenderText.h&quot;
  81 #include &quot;RenderTextControl.h&quot;
  82 #include &quot;RenderTheme.h&quot;
  83 #include &quot;RenderView.h&quot;
  84 #include &quot;RenderWidget.h&quot;
  85 #include &quot;RuntimeEnabledFeatures.h&quot;
  86 #include &quot;SVGDocument.h&quot;
  87 #include &quot;SVGDocumentExtensions.h&quot;
  88 #include &quot;ScriptController.h&quot;
  89 #include &quot;ScriptSourceCode.h&quot;
  90 #include &quot;ScrollingCoordinator.h&quot;
  91 #include &quot;Settings.h&quot;
  92 #include &quot;StyleProperties.h&quot;
  93 #include &quot;StyleScope.h&quot;
  94 #include &quot;TextNodeTraversal.h&quot;
  95 #include &quot;TextResourceDecoder.h&quot;
  96 #include &quot;UserContentController.h&quot;
  97 #include &quot;UserContentURLPattern.h&quot;
  98 #include &quot;UserGestureIndicator.h&quot;
  99 #include &quot;UserScript.h&quot;
 100 #include &quot;UserTypingGestureIndicator.h&quot;
 101 #include &quot;VisibleUnits.h&quot;
 102 #include &quot;markup.h&quot;
 103 #include &quot;npruntime_impl.h&quot;
 104 #include &quot;runtime_root.h&quot;
 105 #include &lt;JavaScriptCore/RegularExpression.h&gt;
 106 #include &lt;wtf/RefCountedLeakCounter.h&gt;
 107 #include &lt;wtf/StdLibExtras.h&gt;
 108 #include &lt;wtf/text/StringBuilder.h&gt;
 109 
 110 namespace WebCore {
 111 
 112 using namespace HTMLNames;
 113 
 114 #if PLATFORM(IOS_FAMILY)
 115 static const Seconds scrollFrequency { 1000_s / 60. };
 116 #endif
 117 
 118 DEFINE_DEBUG_ONLY_GLOBAL(WTF::RefCountedLeakCounter, frameCounter, (&quot;Frame&quot;));
 119 
 120 // We prewarm local storage for at most 5 origins in a given page.
 121 static const unsigned maxlocalStoragePrewarmingCount { 5 };
 122 
 123 static inline Frame* parentFromOwnerElement(HTMLFrameOwnerElement* ownerElement)
 124 {
 125     if (!ownerElement)
 126         return 0;
 127     return ownerElement-&gt;document().frame();
 128 }
 129 
 130 static inline float parentPageZoomFactor(Frame* frame)
 131 {
 132     Frame* parent = frame-&gt;tree().parent();
 133     if (!parent)
 134         return 1;
 135     return parent-&gt;pageZoomFactor();
 136 }
 137 
 138 static inline float parentTextZoomFactor(Frame* frame)
 139 {
 140     Frame* parent = frame-&gt;tree().parent();
 141     if (!parent)
 142         return 1;
 143     return parent-&gt;textZoomFactor();
 144 }
 145 
 146 Frame::Frame(Page&amp; page, HTMLFrameOwnerElement* ownerElement, FrameLoaderClient&amp; frameLoaderClient)
 147     : m_mainFrame(ownerElement ? page.mainFrame() : *this)
 148     , m_page(&amp;page)
 149     , m_settings(&amp;page.settings())
 150     , m_treeNode(*this, parentFromOwnerElement(ownerElement))
 151     , m_loader(makeUniqueRef&lt;FrameLoader&gt;(*this, frameLoaderClient))
 152     , m_navigationScheduler(makeUniqueRef&lt;NavigationScheduler&gt;(*this))
 153     , m_ownerElement(ownerElement)
 154     , m_script(makeUniqueRef&lt;ScriptController&gt;(*this))
 155     , m_editor(makeUniqueRef&lt;Editor&gt;(*this))
 156     , m_selection(makeUniqueRef&lt;FrameSelection&gt;(this))
 157     , m_animationController(makeUniqueRef&lt;CSSAnimationController&gt;(*this))
 158     , m_pageZoomFactor(parentPageZoomFactor(this))
 159     , m_textZoomFactor(parentTextZoomFactor(this))
 160     , m_eventHandler(makeUniqueRef&lt;EventHandler&gt;(*this))
 161 {
 162     ProcessWarming::initializeNames();
 163 
 164     if (ownerElement) {
 165         m_mainFrame.selfOnlyRef();
 166         page.incrementSubframeCount();
 167         ownerElement-&gt;setContentFrame(this);
 168     }
 169 
 170 #ifndef NDEBUG
 171     frameCounter.increment();
 172 #endif
 173 
 174     // Pause future ActiveDOMObjects if this frame is being created while the page is in a paused state.
 175     Frame* parent = parentFromOwnerElement(ownerElement);
 176     if (parent &amp;&amp; parent-&gt;activeDOMObjectsAndAnimationsSuspended())
 177         suspendActiveDOMObjectsAndAnimations();
 178 }
 179 
 180 void Frame::init()
 181 {
 182     m_loader-&gt;init();
 183 }
 184 
 185 Ref&lt;Frame&gt; Frame::create(Page* page, HTMLFrameOwnerElement* ownerElement, FrameLoaderClient* client)
 186 {
 187     ASSERT(page);
 188     ASSERT(client);
 189     return adoptRef(*new Frame(*page, ownerElement, *client));
 190 }
 191 
 192 Frame::~Frame()
 193 {
 194     setView(nullptr);
 195     loader().cancelAndClear();
 196 
 197     // FIXME: We should not be doing all this work inside the destructor
 198 
 199 #ifndef NDEBUG
 200     frameCounter.decrement();
 201 #endif
 202 
 203     disconnectOwnerElement();
 204 
 205     while (auto* destructionObserver = m_destructionObservers.takeAny())
 206         destructionObserver-&gt;frameDestroyed();
 207 
 208     if (!isMainFrame())
 209         m_mainFrame.selfOnlyDeref();
 210 }
 211 
 212 void Frame::addDestructionObserver(FrameDestructionObserver* observer)
 213 {
 214     m_destructionObservers.add(observer);
 215 }
 216 
 217 void Frame::removeDestructionObserver(FrameDestructionObserver* observer)
 218 {
 219     m_destructionObservers.remove(observer);
 220 }
 221 
 222 void Frame::setView(RefPtr&lt;FrameView&gt;&amp;&amp; view)
 223 {
 224     // We the custom scroll bars as early as possible to prevent m_doc-&gt;detach()
 225     // from messing with the view such that its scroll bars won&#39;t be torn down.
 226     // FIXME: We should revisit this.
 227     if (m_view)
 228         m_view-&gt;prepareForDetach();
 229 
 230     // Prepare for destruction now, so any unload event handlers get run and the DOMWindow is
 231     // notified. If we wait until the view is destroyed, then things won&#39;t be hooked up enough for
 232     // these calls to work.
 233     if (!view &amp;&amp; m_doc &amp;&amp; m_doc-&gt;backForwardCacheState() != Document::InBackForwardCache)
 234         m_doc-&gt;prepareForDestruction();
 235 
 236     if (m_view)
 237         m_view-&gt;layoutContext().unscheduleLayout();
 238 
 239     m_eventHandler-&gt;clear();
 240 
 241     RELEASE_ASSERT(!m_doc || !m_doc-&gt;hasLivingRenderTree());
 242 
 243     m_view = WTFMove(view);
 244 
 245     // Only one form submission is allowed per view of a part.
 246     // Since this part may be getting reused as a result of being
 247     // pulled from the back/forward cache, reset this flag.
 248     loader().resetMultipleFormSubmissionProtection();
 249 }
 250 
 251 void Frame::setDocument(RefPtr&lt;Document&gt;&amp;&amp; newDocument)
 252 {
 253     ASSERT(!newDocument || newDocument-&gt;frame() == this);
 254 
 255     if (m_documentIsBeingReplaced)
 256         return;
 257 
 258     m_documentIsBeingReplaced = true;
 259 
 260     if (isMainFrame()) {
 261         if (m_page)
 262             m_page-&gt;didChangeMainDocument();
 263         m_loader-&gt;client().dispatchDidChangeMainDocument();
 264 
 265         // We want to generate the same unique names whenever a page is loaded to avoid making layout tests
 266         // flaky and for things like form state restoration to work. To achieve this, we reset our frame
 267         // identifier generator every time the page is navigated.
 268         tree().resetFrameIdentifiers();
 269     }
 270 
 271 #if ENABLE(ATTACHMENT_ELEMENT)
 272     if (m_doc) {
 273         for (auto&amp; attachment : m_doc-&gt;attachmentElementsByIdentifier().values())
 274             editor().didRemoveAttachmentElement(attachment);
 275     }
 276 #endif
 277 
 278     if (m_doc &amp;&amp; m_doc-&gt;backForwardCacheState() != Document::InBackForwardCache)
 279         m_doc-&gt;prepareForDestruction();
 280 
 281     m_doc = newDocument.copyRef();
 282     ASSERT(!m_doc || m_doc-&gt;domWindow());
 283     ASSERT(!m_doc || m_doc-&gt;domWindow()-&gt;frame() == this);
 284 
 285     // Don&#39;t use m_doc because it can be overwritten and we want to guarantee
 286     // that the document is not destroyed during this function call.
 287     if (newDocument)
 288         newDocument-&gt;didBecomeCurrentDocumentInFrame();
 289 
 290 #if ENABLE(ATTACHMENT_ELEMENT)
 291     if (m_doc) {
 292         for (auto&amp; attachment : m_doc-&gt;attachmentElementsByIdentifier().values())
 293             editor().didInsertAttachmentElement(attachment);
 294     }
 295 #endif
 296 
 297     InspectorInstrumentation::frameDocumentUpdated(*this);
 298 
 299     m_documentIsBeingReplaced = false;
 300 }
 301 
 302 #if ENABLE(ORIENTATION_EVENTS)
 303 void Frame::orientationChanged()
 304 {
 305     Vector&lt;Ref&lt;Frame&gt;&gt; frames;
 306     for (Frame* frame = this; frame; frame = frame-&gt;tree().traverseNext())
 307         frames.append(*frame);
 308 
 309     auto newOrientation = orientation();
 310     for (auto&amp; frame : frames) {
 311         if (Document* document = frame-&gt;document())
 312             document-&gt;orientationChanged(newOrientation);
 313     }
 314 }
 315 
 316 int Frame::orientation() const
 317 {
 318     if (m_page)
 319         return m_page-&gt;chrome().client().deviceOrientation();
 320     return 0;
 321 }
 322 #endif // ENABLE(ORIENTATION_EVENTS)
 323 
 324 static JSC::Yarr::RegularExpression createRegExpForLabels(const Vector&lt;String&gt;&amp; labels)
 325 {
 326     // REVIEW- version of this call in FrameMac.mm caches based on the NSArray ptrs being
 327     // the same across calls.  We can&#39;t do that.
 328 
 329     static NeverDestroyed&lt;JSC::Yarr::RegularExpression&gt; wordRegExp(&quot;\\w&quot;);
 330     StringBuilder pattern;
 331     pattern.append(&#39;(&#39;);
 332     unsigned int numLabels = labels.size();
 333     unsigned int i;
 334     for (i = 0; i &lt; numLabels; i++) {
 335         String label = labels[i];
 336 
 337         bool startsWithWordChar = false;
 338         bool endsWithWordChar = false;
 339         if (label.length()) {
 340             startsWithWordChar = wordRegExp.get().match(label.substring(0, 1)) &gt;= 0;
 341             endsWithWordChar = wordRegExp.get().match(label.substring(label.length() - 1, 1)) &gt;= 0;
 342         }
 343 
 344         if (i)
 345             pattern.append(&#39;|&#39;);
 346         // Search for word boundaries only if label starts/ends with &quot;word characters&quot;.
 347         // If we always searched for word boundaries, this wouldn&#39;t work for languages
 348         // such as Japanese.
 349         if (startsWithWordChar)
 350             pattern.appendLiteral(&quot;\\b&quot;);
 351         pattern.append(label);
 352         if (endsWithWordChar)
 353             pattern.appendLiteral(&quot;\\b&quot;);
 354     }
 355     pattern.append(&#39;)&#39;);
 356     return JSC::Yarr::RegularExpression(pattern.toString(), JSC::Yarr::TextCaseInsensitive);
 357 }
 358 
 359 String Frame::searchForLabelsAboveCell(const JSC::Yarr::RegularExpression&amp; regExp, HTMLTableCellElement* cell, size_t* resultDistanceFromStartOfCell)
 360 {
 361     HTMLTableCellElement* aboveCell = cell-&gt;cellAbove();
 362     if (aboveCell) {
 363         // search within the above cell we found for a match
 364         size_t lengthSearched = 0;
 365         for (Text* textNode = TextNodeTraversal::firstWithin(*aboveCell); textNode; textNode = TextNodeTraversal::next(*textNode, aboveCell)) {
 366             if (!textNode-&gt;renderer() || textNode-&gt;renderer()-&gt;style().visibility() != Visibility::Visible)
 367                 continue;
 368             // For each text chunk, run the regexp
 369             String nodeString = textNode-&gt;data();
 370             int pos = regExp.searchRev(nodeString);
 371             if (pos &gt;= 0) {
 372                 if (resultDistanceFromStartOfCell)
 373                     *resultDistanceFromStartOfCell = lengthSearched;
 374                 return nodeString.substring(pos, regExp.matchedLength());
 375             }
 376             lengthSearched += nodeString.length();
 377         }
 378     }
 379 
 380     // Any reason in practice to search all cells in that are above cell?
 381     if (resultDistanceFromStartOfCell)
 382         *resultDistanceFromStartOfCell = notFound;
 383     return String();
 384 }
 385 
 386 // FIXME: This should take an Element&amp;.
 387 String Frame::searchForLabelsBeforeElement(const Vector&lt;String&gt;&amp; labels, Element* element, size_t* resultDistance, bool* resultIsInCellAbove)
 388 {
 389     ASSERT(element);
 390     JSC::Yarr::RegularExpression regExp = createRegExpForLabels(labels);
 391     // We stop searching after we&#39;ve seen this many chars
 392     const unsigned int charsSearchedThreshold = 500;
 393     // This is the absolute max we search.  We allow a little more slop than
 394     // charsSearchedThreshold, to make it more likely that we&#39;ll search whole nodes.
 395     const unsigned int maxCharsSearched = 600;
 396     // If the starting element is within a table, the cell that contains it
 397     HTMLTableCellElement* startingTableCell = nullptr;
 398     bool searchedCellAbove = false;
 399 
 400     if (resultDistance)
 401         *resultDistance = notFound;
 402     if (resultIsInCellAbove)
 403         *resultIsInCellAbove = false;
 404 
 405     // walk backwards in the node tree, until another element, or form, or end of tree
 406     int unsigned lengthSearched = 0;
 407     Node* n;
 408     for (n = NodeTraversal::previous(*element); n &amp;&amp; lengthSearched &lt; charsSearchedThreshold; n = NodeTraversal::previous(*n)) {
 409         // We hit another form element or the start of the form - bail out
 410         if (is&lt;HTMLFormElement&gt;(*n) || is&lt;HTMLFormControlElement&gt;(*n))
 411             break;
 412 
 413         if (n-&gt;hasTagName(tdTag) &amp;&amp; !startingTableCell)
 414             startingTableCell = downcast&lt;HTMLTableCellElement&gt;(n);
 415         else if (is&lt;HTMLTableRowElement&gt;(*n) &amp;&amp; startingTableCell) {
 416             String result = searchForLabelsAboveCell(regExp, startingTableCell, resultDistance);
 417             if (!result.isEmpty()) {
 418                 if (resultIsInCellAbove)
 419                     *resultIsInCellAbove = true;
 420                 return result;
 421             }
 422             searchedCellAbove = true;
 423         } else if (n-&gt;isTextNode() &amp;&amp; n-&gt;renderer() &amp;&amp; n-&gt;renderer()-&gt;style().visibility() == Visibility::Visible) {
 424             // For each text chunk, run the regexp
 425             String nodeString = n-&gt;nodeValue();
 426             // add 100 for slop, to make it more likely that we&#39;ll search whole nodes
 427             if (lengthSearched + nodeString.length() &gt; maxCharsSearched)
 428                 nodeString = nodeString.right(charsSearchedThreshold - lengthSearched);
 429             int pos = regExp.searchRev(nodeString);
 430             if (pos &gt;= 0) {
 431                 if (resultDistance)
 432                     *resultDistance = lengthSearched;
 433                 return nodeString.substring(pos, regExp.matchedLength());
 434             }
 435             lengthSearched += nodeString.length();
 436         }
 437     }
 438 
 439     // If we started in a cell, but bailed because we found the start of the form or the
 440     // previous element, we still might need to search the row above us for a label.
 441     if (startingTableCell &amp;&amp; !searchedCellAbove) {
 442         String result = searchForLabelsAboveCell(regExp, startingTableCell, resultDistance);
 443         if (!result.isEmpty()) {
 444             if (resultIsInCellAbove)
 445                 *resultIsInCellAbove = true;
 446             return result;
 447         }
 448     }
 449     return String();
 450 }
 451 
 452 static String matchLabelsAgainstString(const Vector&lt;String&gt;&amp; labels, const String&amp; stringToMatch)
 453 {
 454     if (stringToMatch.isEmpty())
 455         return String();
 456 
 457     String mutableStringToMatch = stringToMatch;
 458 
 459     // Make numbers and _&#39;s in field names behave like word boundaries, e.g., &quot;address2&quot;
 460     replace(mutableStringToMatch, JSC::Yarr::RegularExpression(&quot;\\d&quot;), &quot; &quot;);
 461     mutableStringToMatch.replace(&#39;_&#39;, &#39; &#39;);
 462 
 463     JSC::Yarr::RegularExpression regExp = createRegExpForLabels(labels);
 464     // Use the largest match we can find in the whole string
 465     int pos;
 466     int length;
 467     int bestPos = -1;
 468     int bestLength = -1;
 469     int start = 0;
 470     do {
 471         pos = regExp.match(mutableStringToMatch, start);
 472         if (pos != -1) {
 473             length = regExp.matchedLength();
 474             if (length &gt;= bestLength) {
 475                 bestPos = pos;
 476                 bestLength = length;
 477             }
 478             start = pos + 1;
 479         }
 480     } while (pos != -1);
 481 
 482     if (bestPos != -1)
 483         return mutableStringToMatch.substring(bestPos, bestLength);
 484     return String();
 485 }
 486 
 487 String Frame::matchLabelsAgainstElement(const Vector&lt;String&gt;&amp; labels, Element* element)
 488 {
 489     // Match against the name element, then against the id element if no match is found for the name element.
 490     // See 7538330 for one popular site that benefits from the id element check.
 491     // FIXME: This code is mirrored in FrameMac.mm. It would be nice to make the Mac code call the platform-agnostic
 492     // code, which would require converting the NSArray of NSStrings to a Vector of Strings somewhere along the way.
 493     String resultFromNameAttribute = matchLabelsAgainstString(labels, element-&gt;getNameAttribute());
 494     if (!resultFromNameAttribute.isEmpty())
 495         return resultFromNameAttribute;
 496 
 497     return matchLabelsAgainstString(labels, element-&gt;attributeWithoutSynchronization(idAttr));
 498 }
 499 
 500 #if PLATFORM(IOS_FAMILY)
 501 
 502 void Frame::setSelectionChangeCallbacksDisabled(bool selectionChangeCallbacksDisabled)
 503 {
 504     m_selectionChangeCallbacksDisabled = selectionChangeCallbacksDisabled;
 505 }
 506 
 507 bool Frame::selectionChangeCallbacksDisabled() const
 508 {
 509     return m_selectionChangeCallbacksDisabled;
 510 }
 511 #endif // PLATFORM(IOS_FAMILY)
 512 
 513 bool Frame::requestDOMPasteAccess()
 514 {
 515     if (m_settings-&gt;javaScriptCanAccessClipboard() &amp;&amp; m_settings-&gt;DOMPasteAllowed())
 516         return true;
 517 
 518     if (!m_settings-&gt;domPasteAccessRequestsEnabled() || !m_doc)
 519         return false;
 520 
 521     auto gestureToken = UserGestureIndicator::currentUserGesture();
 522     if (!gestureToken || !gestureToken-&gt;processingUserGesture())
 523         return false;
 524 
 525     switch (gestureToken-&gt;domPasteAccessPolicy()) {
 526     case DOMPasteAccessPolicy::Granted:
 527         return true;
 528     case DOMPasteAccessPolicy::Denied:
 529         return false;
 530     case DOMPasteAccessPolicy::NotRequestedYet: {
 531         auto* client = m_editor-&gt;client();
 532         if (!client)
 533             return false;
 534 
 535         auto response = client-&gt;requestDOMPasteAccess(m_doc-&gt;originIdentifierForPasteboard());
 536         gestureToken-&gt;didRequestDOMPasteAccess(response);
 537         switch (response) {
 538         case DOMPasteAccessResponse::GrantedForCommand:
 539         case DOMPasteAccessResponse::GrantedForGesture:
 540             return true;
 541         case DOMPasteAccessResponse::DeniedForGesture:
 542             return false;
 543         }
 544     }
 545     }
 546 
 547     ASSERT_NOT_REACHED();
 548     return false;
 549 }
 550 
 551 void Frame::setPrinting(bool printing, const FloatSize&amp; pageSize, const FloatSize&amp; originalPageSize, float maximumShrinkRatio, AdjustViewSizeOrNot shouldAdjustViewSize)
 552 {
 553     if (!view())
 554         return;
 555     // In setting printing, we should not validate resources already cached for the document.
 556     // See https://bugs.webkit.org/show_bug.cgi?id=43704
 557     ResourceCacheValidationSuppressor validationSuppressor(m_doc-&gt;cachedResourceLoader());
 558 
 559     m_doc-&gt;setPrinting(printing);
 560     view()-&gt;adjustMediaTypeForPrinting(printing);
 561 
 562     // FIXME: Consider invoking Page::updateRendering or an equivalent.
 563     m_doc-&gt;styleScope().didChangeStyleSheetEnvironment();
 564     m_doc-&gt;evaluateMediaQueriesAndReportChanges();
 565     if (!view())
 566         return;
 567 
 568     auto&amp; frameView = *view();
 569     if (shouldUsePrintingLayout())
 570         frameView.forceLayoutForPagination(pageSize, originalPageSize, maximumShrinkRatio, shouldAdjustViewSize);
 571     else {
 572         frameView.forceLayout();
 573         if (shouldAdjustViewSize == AdjustViewSize)
 574             frameView.adjustViewSize();
 575     }
 576 
 577     // Subframes of the one we&#39;re printing don&#39;t lay out to the page size.
 578     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
 579         child-&gt;setPrinting(printing, FloatSize(), FloatSize(), 0, shouldAdjustViewSize);
 580 }
 581 
 582 bool Frame::shouldUsePrintingLayout() const
 583 {
 584     // Only top frame being printed should be fit to page size.
 585     // Subframes should be constrained by parents only.
 586     return m_doc-&gt;printing() &amp;&amp; (!tree().parent() || !tree().parent()-&gt;m_doc-&gt;printing());
 587 }
 588 
 589 FloatSize Frame::resizePageRectsKeepingRatio(const FloatSize&amp; originalSize, const FloatSize&amp; expectedSize)
 590 {
 591     FloatSize resultSize;
 592     if (!contentRenderer())
 593         return FloatSize();
 594 
 595     if (contentRenderer()-&gt;style().isHorizontalWritingMode()) {
 596         ASSERT(fabs(originalSize.width()) &gt; std::numeric_limits&lt;float&gt;::epsilon());
 597         float ratio = originalSize.height() / originalSize.width();
 598         resultSize.setWidth(floorf(expectedSize.width()));
 599         resultSize.setHeight(floorf(resultSize.width() * ratio));
 600     } else {
 601         ASSERT(fabs(originalSize.height()) &gt; std::numeric_limits&lt;float&gt;::epsilon());
 602         float ratio = originalSize.width() / originalSize.height();
 603         resultSize.setHeight(floorf(expectedSize.height()));
 604         resultSize.setWidth(floorf(resultSize.height() * ratio));
 605     }
 606     return resultSize;
 607 }
 608 
 609 void Frame::injectUserScripts(UserScriptInjectionTime injectionTime)
 610 {
 611     if (!m_page)
 612         return;
 613 
 614     if (loader().stateMachine().creatingInitialEmptyDocument() &amp;&amp; !settings().shouldInjectUserScriptsInInitialEmptyDocument())
 615         return;
 616 
 617     m_page-&gt;userContentProvider().forEachUserScript([this, protectedThis = makeRef(*this), injectionTime](DOMWrapperWorld&amp; world, const UserScript&amp; script) {
 618         if (script.injectionTime() == injectionTime)
 619             injectUserScriptImmediately(world, script);
 620     });
 621 }
 622 
 623 void Frame::injectUserScriptImmediately(DOMWrapperWorld&amp; world, const UserScript&amp; script)
 624 {
 625     auto* document = this-&gt;document();
 626     if (!document)
 627         return;
 628     if (script.injectedFrames() == InjectInTopFrameOnly &amp;&amp; !isMainFrame())
 629         return;
 630     if (!UserContentURLPattern::matchesPatterns(document-&gt;url(), script.whitelist(), script.blacklist()))
 631         return;
 632     if (!m_script-&gt;shouldAllowUserAgentScripts(*document))
 633         return;
 634 
 635     document-&gt;setAsRunningUserScripts();
 636     loader().client().willInjectUserScript(world);
 637     m_script-&gt;evaluateInWorldIgnoringException(ScriptSourceCode(script.source(), URL(script.url())), world);
 638 }
 639 
 640 RenderView* Frame::contentRenderer() const
 641 {
 642     return document() ? document()-&gt;renderView() : nullptr;
 643 }
 644 
 645 RenderWidget* Frame::ownerRenderer() const
 646 {
 647     auto* ownerElement = m_ownerElement;
 648     if (!ownerElement)
 649         return nullptr;
 650     auto* object = ownerElement-&gt;renderer();
 651     // FIXME: If &lt;object&gt; is ever fixed to disassociate itself from frames
 652     // that it has started but canceled, then this can turn into an ASSERT
 653     // since m_ownerElement would be nullptr when the load is canceled.
 654     // https://bugs.webkit.org/show_bug.cgi?id=18585
 655     if (!is&lt;RenderWidget&gt;(object))
 656         return nullptr;
 657     return downcast&lt;RenderWidget&gt;(object);
 658 }
 659 
 660 Frame* Frame::frameForWidget(const Widget&amp; widget)
 661 {
 662     if (auto* renderer = RenderWidget::find(widget))
 663         return renderer-&gt;frameOwnerElement().document().frame();
 664 
 665     // Assume all widgets are either a FrameView or owned by a RenderWidget.
 666     // FIXME: That assumption is not right for scroll bars!
 667     return &amp;downcast&lt;FrameView&gt;(widget).frame();
 668 }
 669 
 670 void Frame::clearTimers(FrameView *view, Document *document)
 671 {
 672     if (view) {
 673         view-&gt;layoutContext().unscheduleLayout();
 674         if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
 675             if (auto* timeline = document-&gt;existingTimeline())
 676                 timeline-&gt;suspendAnimations();
 677         } else
 678             view-&gt;frame().animation().suspendAnimationsForDocument(document);
 679         view-&gt;frame().eventHandler().stopAutoscrollTimer();
 680     }
 681 }
 682 
 683 void Frame::clearTimers()
 684 {
 685     clearTimers(m_view.get(), document());
 686 }
 687 
 688 void Frame::willDetachPage()
 689 {
 690     if (Frame* parent = tree().parent())
 691         parent-&gt;loader().checkLoadComplete();
 692 
 693     for (auto&amp; observer : m_destructionObservers)
 694         observer-&gt;willDetachPage();
 695 
 696     // FIXME: It&#39;s unclear as to why this is called more than once, but it is,
 697     // so page() could be NULL.
 698     if (page() &amp;&amp; page()-&gt;focusController().focusedFrame() == this)
 699         page()-&gt;focusController().setFocusedFrame(nullptr);
 700 
 701     if (page() &amp;&amp; page()-&gt;scrollingCoordinator() &amp;&amp; m_view)
 702         page()-&gt;scrollingCoordinator()-&gt;willDestroyScrollableArea(*m_view);
 703 
 704     script().clearScriptObjects();
 705     script().updatePlatformScriptObjects();
 706 
 707     // We promise that the Frame is always connected to a Page while the render tree is live.
 708     //
 709     // The render tree can be torn down in a few different ways, but the two important ones are:
 710     //
 711     // - When calling Frame::setView() with a null FrameView*. This is always done before calling
 712     //   Frame::willDetachPage (this function.) Hence the assertion below.
 713     //
 714     // - When adding a document to the back/forward cache, the tree is torn down before instantiating
 715     //   the CachedPage+CachedFrame object tree.
 716     ASSERT(!document() || !document()-&gt;renderView());
 717 }
 718 
 719 void Frame::disconnectOwnerElement()
 720 {
 721     if (m_ownerElement) {
 722         m_ownerElement-&gt;clearContentFrame();
 723         if (m_page)
 724             m_page-&gt;decrementSubframeCount();
 725     }
 726     m_ownerElement = nullptr;
 727 
 728     if (auto* document = this-&gt;document())
 729         document-&gt;frameWasDisconnectedFromOwner();
 730 }
 731 
 732 String Frame::displayStringModifiedByEncoding(const String&amp; str) const
 733 {
 734     return document() ? document()-&gt;displayStringModifiedByEncoding(str) : str;
 735 }
 736 
 737 VisiblePosition Frame::visiblePositionForPoint(const IntPoint&amp; framePoint) const
 738 {
 739     HitTestResult result = eventHandler().hitTestResultAtPoint(framePoint, HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::AllowChildFrameContent);
 740     Node* node = result.innerNonSharedNode();
 741     if (!node)
 742         return VisiblePosition();
 743     auto renderer = node-&gt;renderer();
 744     if (!renderer)
 745         return VisiblePosition();
 746     VisiblePosition visiblePos = renderer-&gt;positionForPoint(result.localPoint(), nullptr);
 747     if (visiblePos.isNull())
 748         visiblePos = firstPositionInOrBeforeNode(node);
 749     return visiblePos;
 750 }
 751 
 752 Document* Frame::documentAtPoint(const IntPoint&amp; point)
 753 {
 754     if (!view())
 755         return nullptr;
 756 
 757     IntPoint pt = view()-&gt;windowToContents(point);
 758     HitTestResult result = HitTestResult(pt);
 759 
 760     if (contentRenderer())
 761         result = eventHandler().hitTestResultAtPoint(pt, HitTestRequest::ReadOnly | HitTestRequest::Active | HitTestRequest::DisallowUserAgentShadowContent | HitTestRequest::AllowChildFrameContent);
 762     return result.innerNode() ? &amp;result.innerNode()-&gt;document() : 0;
 763 }
 764 
 765 RefPtr&lt;Range&gt; Frame::rangeForPoint(const IntPoint&amp; framePoint)
 766 {
 767     VisiblePosition position = visiblePositionForPoint(framePoint);
 768     if (position.isNull())
 769         return nullptr;
 770 
 771     Position deepPosition = position.deepEquivalent();
 772     Text* containerText = deepPosition.containerText();
 773     if (!containerText || !containerText-&gt;renderer() || containerText-&gt;renderer()-&gt;style().userSelect() == UserSelect::None)
 774         return nullptr;
 775 
 776     VisiblePosition previous = position.previous();
 777     if (previous.isNotNull()) {
 778         RefPtr&lt;Range&gt; previousCharacterRange = makeRange(previous, position);
 779         LayoutRect rect = editor().firstRectForRange(previousCharacterRange.get());
 780         if (rect.contains(framePoint))
 781             return previousCharacterRange;
 782     }
 783 
 784     VisiblePosition next = position.next();
 785     if (RefPtr&lt;Range&gt; nextCharacterRange = makeRange(position, next)) {
 786         LayoutRect rect = editor().firstRectForRange(nextCharacterRange.get());
 787         if (rect.contains(framePoint))
 788             return nextCharacterRange;
 789     }
 790 
 791     return nullptr;
 792 }
 793 
 794 void Frame::createView(const IntSize&amp; viewportSize, const Optional&lt;Color&gt;&amp; backgroundColor,
 795     const IntSize&amp; fixedLayoutSize, const IntRect&amp; fixedVisibleContentRect,
 796     bool useFixedLayout, ScrollbarMode horizontalScrollbarMode, bool horizontalLock,
 797     ScrollbarMode verticalScrollbarMode, bool verticalLock)
 798 {
 799     ASSERT(m_page);
 800 
 801     bool isMainFrame = this-&gt;isMainFrame();
 802 
 803     if (isMainFrame &amp;&amp; view())
 804         view()-&gt;setParentVisible(false);
 805 
 806     setView(nullptr);
 807 
 808     RefPtr&lt;FrameView&gt; frameView;
 809     if (isMainFrame) {
 810         frameView = FrameView::create(*this, viewportSize);
 811         frameView-&gt;setFixedLayoutSize(fixedLayoutSize);
 812 #if USE(COORDINATED_GRAPHICS)
 813         frameView-&gt;setFixedVisibleContentRect(fixedVisibleContentRect);
 814 #else
 815         UNUSED_PARAM(fixedVisibleContentRect);
 816 #endif
 817         frameView-&gt;setUseFixedLayout(useFixedLayout);
 818     } else
 819         frameView = FrameView::create(*this);
 820 
 821     frameView-&gt;setScrollbarModes(horizontalScrollbarMode, verticalScrollbarMode, horizontalLock, verticalLock);
 822 
 823     setView(frameView.copyRef());
 824 
 825     frameView-&gt;updateBackgroundRecursively(backgroundColor);
 826 
 827     if (isMainFrame)
 828         frameView-&gt;setParentVisible(true);
 829 
 830     if (ownerRenderer())
 831         ownerRenderer()-&gt;setWidget(frameView);
 832 
 833     if (HTMLFrameOwnerElement* owner = ownerElement())
 834         view()-&gt;setCanHaveScrollbars(owner-&gt;scrollingMode() != ScrollbarAlwaysOff);
 835 }
 836 
 837 DOMWindow* Frame::window() const
 838 {
 839     return document() ? document()-&gt;domWindow() : nullptr;
 840 }
 841 
 842 AbstractDOMWindow* Frame::virtualWindow() const
 843 {
 844     return window();
 845 }
 846 
 847 String Frame::layerTreeAsText(LayerTreeFlags flags) const
 848 {
 849     document()-&gt;updateLayout();
 850 
 851     if (!contentRenderer())
 852         return String();
 853 
 854     return contentRenderer()-&gt;compositor().layerTreeAsText(flags);
 855 }
 856 
 857 String Frame::trackedRepaintRectsAsText() const
 858 {
 859     if (!m_view)
 860         return String();
 861     return m_view-&gt;trackedRepaintRectsAsText();
 862 }
 863 
 864 void Frame::setPageZoomFactor(float factor)
 865 {
 866     setPageAndTextZoomFactors(factor, m_textZoomFactor);
 867 }
 868 
 869 void Frame::setTextZoomFactor(float factor)
 870 {
 871     setPageAndTextZoomFactors(m_pageZoomFactor, factor);
 872 }
 873 
 874 void Frame::setPageAndTextZoomFactors(float pageZoomFactor, float textZoomFactor)
 875 {
 876     if (m_pageZoomFactor == pageZoomFactor &amp;&amp; m_textZoomFactor == textZoomFactor)
 877         return;
 878 
 879     Page* page = this-&gt;page();
 880     if (!page)
 881         return;
 882 
 883     Document* document = this-&gt;document();
 884     if (!document)
 885         return;
 886 
 887     m_editor-&gt;dismissCorrectionPanelAsIgnored();
 888 
 889     // Respect SVGs zoomAndPan=&quot;disabled&quot; property in standalone SVG documents.
 890     // FIXME: How to handle compound documents + zoomAndPan=&quot;disabled&quot;? Needs SVG WG clarification.
 891     if (is&lt;SVGDocument&gt;(*document) &amp;&amp; !downcast&lt;SVGDocument&gt;(*document).zoomAndPanEnabled())
 892         return;
 893 
 894     if (m_pageZoomFactor != pageZoomFactor) {
 895         if (FrameView* view = this-&gt;view()) {
 896             // Update the scroll position when doing a full page zoom, so the content stays in relatively the same position.
 897             LayoutPoint scrollPosition = view-&gt;scrollPosition();
 898             float percentDifference = (pageZoomFactor / m_pageZoomFactor);
 899             view-&gt;setScrollPosition(IntPoint(scrollPosition.x() * percentDifference, scrollPosition.y() * percentDifference));
 900         }
 901     }
 902 
 903     m_pageZoomFactor = pageZoomFactor;
 904     m_textZoomFactor = textZoomFactor;
 905 
 906     document-&gt;resolveStyle(Document::ResolveStyleType::Rebuild);
 907 
 908     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
 909         child-&gt;setPageAndTextZoomFactors(m_pageZoomFactor, m_textZoomFactor);
 910 
 911     if (FrameView* view = this-&gt;view()) {
 912         if (document-&gt;renderView() &amp;&amp; document-&gt;renderView()-&gt;needsLayout() &amp;&amp; view-&gt;didFirstLayout())
 913             view-&gt;layoutContext().layout();
 914     }
 915 }
 916 
 917 float Frame::frameScaleFactor() const
 918 {
 919     Page* page = this-&gt;page();
 920 
 921     // Main frame is scaled with respect to he container but inner frames are not scaled with respect to the main frame.
 922     if (!page || !isMainFrame())
 923         return 1;
 924 
 925     if (page-&gt;delegatesScaling())
 926         return 1;
 927 
 928     return page-&gt;pageScaleFactor();
 929 }
 930 
 931 void Frame::suspendActiveDOMObjectsAndAnimations()
 932 {
 933     bool wasSuspended = activeDOMObjectsAndAnimationsSuspended();
 934 
 935     m_activeDOMObjectsAndAnimationsSuspendedCount++;
 936 
 937     if (wasSuspended)
 938         return;
 939 
 940     // FIXME: Suspend/resume calls will not match if the frame is navigated, and gets a new document.
 941     clearTimers(); // Suspends animations and pending relayouts.
 942     if (m_doc)
 943         m_doc-&gt;suspendScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
 944 }
 945 
 946 void Frame::resumeActiveDOMObjectsAndAnimations()
 947 {
 948     if (!activeDOMObjectsAndAnimationsSuspended())
 949         return;
 950 
 951     m_activeDOMObjectsAndAnimationsSuspendedCount--;
 952 
 953     if (activeDOMObjectsAndAnimationsSuspended())
 954         return;
 955 
 956     if (!m_doc)
 957         return;
 958 
 959     // FIXME: Suspend/resume calls will not match if the frame is navigated, and gets a new document.
 960     m_doc-&gt;resumeScheduledTasks(ReasonForSuspension::PageWillBeSuspended);
 961 
 962     // Frame::clearTimers() suspended animations and pending relayouts.
 963 
 964     if (RuntimeEnabledFeatures::sharedFeatures().webAnimationsCSSIntegrationEnabled()) {
 965         if (auto* timeline = m_doc-&gt;existingTimeline())
 966             timeline-&gt;resumeAnimations();
 967     } else
 968         animation().resumeAnimationsForDocument(m_doc.get());
 969     if (m_view)
 970         m_view-&gt;layoutContext().scheduleLayout();
 971 }
 972 
 973 void Frame::deviceOrPageScaleFactorChanged()
 974 {
 975     for (RefPtr&lt;Frame&gt; child = tree().firstChild(); child; child = child-&gt;tree().nextSibling())
 976         child-&gt;deviceOrPageScaleFactorChanged();
 977 
 978     if (RenderView* root = contentRenderer())
 979         root-&gt;compositor().deviceOrPageScaleFactorChanged();
 980 }
 981 
 982 bool Frame::isAlwaysOnLoggingAllowed() const
 983 {
 984     return page() &amp;&amp; page()-&gt;isAlwaysOnLoggingAllowed();
 985 }
 986 
 987 void Frame::dropChildren()
 988 {
 989     ASSERT(isMainFrame());
 990     while (Frame* child = tree().firstChild())
 991         tree().removeChild(*child);
 992 }
 993 
 994 void Frame::didPrewarmLocalStorage()
 995 {
 996     ASSERT(isMainFrame());
 997     ASSERT(m_localStoragePrewarmingCount &lt; maxlocalStoragePrewarmingCount);
 998     ++m_localStoragePrewarmingCount;
 999 }
1000 
1001 bool Frame::mayPrewarmLocalStorage() const
1002 {
1003     ASSERT(isMainFrame());
1004     return m_localStoragePrewarmingCount &lt; maxlocalStoragePrewarmingCount;
1005 }
1006 
1007 void Frame::selfOnlyRef()
1008 {
1009     ASSERT(isMainFrame());
1010     if (m_selfOnlyRefCount++)
1011         return;
1012 
1013     ref();
1014 }
1015 
1016 void Frame::selfOnlyDeref()
1017 {
1018     ASSERT(isMainFrame());
1019     ASSERT(m_selfOnlyRefCount);
1020     if (--m_selfOnlyRefCount)
1021         return;
1022 
1023     if (hasOneRef())
1024         dropChildren();
1025 
1026     deref();
1027 }
1028 
1029 } // namespace WebCore
    </pre>
  </body>
</html>
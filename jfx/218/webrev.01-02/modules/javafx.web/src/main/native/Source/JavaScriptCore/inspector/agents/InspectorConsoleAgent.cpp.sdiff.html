<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorConsoleAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorAuditAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorConsoleAgent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/inspector/agents/InspectorConsoleAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2014, 2015 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2011 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 21  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 23  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorConsoleAgent.h&quot;
 28 
 29 #include &quot;ConsoleMessage.h&quot;
 30 #include &quot;InjectedScriptManager.h&quot;
 31 #include &quot;InspectorFrontendRouter.h&quot;
 32 #include &quot;InspectorHeapAgent.h&quot;
 33 #include &quot;ScriptArguments.h&quot;
 34 #include &quot;ScriptCallFrame.h&quot;
 35 #include &quot;ScriptCallStack.h&quot;
 36 #include &quot;ScriptCallStackFactory.h&quot;
 37 #include &quot;ScriptObject.h&quot;
 38 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 39 
 40 namespace Inspector {
 41 
<span class="line-modified"> 42 static const unsigned maximumConsoleMessages = 100;</span>
<span class="line-modified"> 43 static const int expireConsoleMessagesStep = 10;</span>
 44 
 45 InspectorConsoleAgent::InspectorConsoleAgent(AgentContext&amp; context)
 46     : InspectorAgentBase(&quot;Console&quot;_s)
 47     , m_injectedScriptManager(context.injectedScriptManager)
 48     , m_frontendDispatcher(makeUnique&lt;ConsoleFrontendDispatcher&gt;(context.frontendRouter))
 49     , m_backendDispatcher(ConsoleBackendDispatcher::create(context.backendDispatcher, this))
 50 {
 51 }
 52 
 53 InspectorConsoleAgent::~InspectorConsoleAgent() = default;
 54 
 55 void InspectorConsoleAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
 56 {
 57 }
 58 
 59 void InspectorConsoleAgent::willDestroyFrontendAndBackend(DisconnectReason)
 60 {
 61     String errorString;
 62     disable(errorString);
 63 }
</pre>
<hr />
<pre>
 89 
 90 void InspectorConsoleAgent::disable(ErrorString&amp;)
 91 {
 92     if (!m_enabled)
 93         return;
 94 
 95     m_enabled = false;
 96 }
 97 
 98 void InspectorConsoleAgent::clearMessages(ErrorString&amp;)
 99 {
100     m_consoleMessages.clear();
101     m_expiredConsoleMessageCount = 0;
102 
103     m_injectedScriptManager.releaseObjectGroup(&quot;console&quot;_s);
104 
105     if (m_enabled)
106         m_frontendDispatcher-&gt;messagesCleared();
107 }
108 





109 void InspectorConsoleAgent::reset()
110 {
111     ErrorString ignored;
112     clearMessages(ignored);
113 
114     m_times.clear();
115     m_counts.clear();
116 }
117 
118 void InspectorConsoleAgent::addMessageToConsole(std::unique_ptr&lt;ConsoleMessage&gt; message)
119 {
<span class="line-removed">120     if (!m_injectedScriptManager.inspectorEnvironment().developerExtrasEnabled())</span>
<span class="line-removed">121         return;</span>
<span class="line-removed">122 </span>
123     if (message-&gt;type() == MessageType::Clear) {
124         ErrorString ignored;
125         clearMessages(ignored);
126     }
127 
128     addConsoleMessage(WTFMove(message));
129 }
130 
<span class="line-modified">131 void InspectorConsoleAgent::startTiming(JSC::ExecState* exec, const String&amp; label)</span>
132 {
<span class="line-removed">133     if (!m_injectedScriptManager.inspectorEnvironment().developerExtrasEnabled())</span>
<span class="line-removed">134         return;</span>
<span class="line-removed">135 </span>
136     ASSERT(!label.isNull());
137     if (label.isNull())
138         return;
139 
140     auto result = m_times.add(label, MonotonicTime::now());
141 
142     if (!result.isNewEntry) {
143         // FIXME: Send an enum to the frontend for localization?
144         String warning = makeString(&quot;Timer \&quot;&quot;, label, &quot;\&quot; already exists&quot;);
<span class="line-modified">145         addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Timing, MessageLevel::Warning, warning, createScriptCallStackForConsole(exec, 1)));</span>
146     }
147 }
148 
<span class="line-modified">149 void InspectorConsoleAgent::logTiming(JSC::ExecState* exec, const String&amp; label, Ref&lt;ScriptArguments&gt;&amp;&amp; arguments)</span>
150 {
<span class="line-removed">151     if (!m_injectedScriptManager.inspectorEnvironment().developerExtrasEnabled())</span>
<span class="line-removed">152         return;</span>
<span class="line-removed">153 </span>
154     ASSERT(!label.isNull());
155     if (label.isNull())
156         return;
157 
<span class="line-modified">158     auto callStack = createScriptCallStackForConsole(exec, 1);</span>
159 
160     auto it = m_times.find(label);
161     if (it == m_times.end()) {
162         // FIXME: Send an enum to the frontend for localization?
163         String warning = makeString(&quot;Timer \&quot;&quot;, label, &quot;\&quot; does not exist&quot;);
164         addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Timing, MessageLevel::Warning, warning, WTFMove(callStack)));
165         return;
166     }
167 
168     MonotonicTime startTime = it-&gt;value;
169     Seconds elapsed = MonotonicTime::now() - startTime;
170     String message = makeString(label, &quot;: &quot;, FormattedNumber::fixedWidth(elapsed.milliseconds(), 3), &quot;ms&quot;);
171     addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Timing, MessageLevel::Debug, message, WTFMove(arguments), WTFMove(callStack)));
172 }
173 
<span class="line-modified">174 void InspectorConsoleAgent::stopTiming(JSC::ExecState* exec, const String&amp; label)</span>
175 {
<span class="line-removed">176     if (!m_injectedScriptManager.inspectorEnvironment().developerExtrasEnabled())</span>
<span class="line-removed">177         return;</span>
<span class="line-removed">178 </span>
179     ASSERT(!label.isNull());
180     if (label.isNull())
181         return;
182 
<span class="line-modified">183     auto callStack = createScriptCallStackForConsole(exec, 1);</span>
184 
185     auto it = m_times.find(label);
186     if (it == m_times.end()) {
187         // FIXME: Send an enum to the frontend for localization?
188         String warning = makeString(&quot;Timer \&quot;&quot;, label, &quot;\&quot; does not exist&quot;);
189         addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Timing, MessageLevel::Warning, warning, WTFMove(callStack)));
190         return;
191     }
192 
193     MonotonicTime startTime = it-&gt;value;
194     Seconds elapsed = MonotonicTime::now() - startTime;
195     String message = makeString(label, &quot;: &quot;, FormattedNumber::fixedWidth(elapsed.milliseconds(), 3), &quot;ms&quot;);
196     addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Timing, MessageLevel::Debug, message, WTFMove(callStack)));
197 
198     m_times.remove(it);
199 }
200 
201 void InspectorConsoleAgent::takeHeapSnapshot(const String&amp; title)
202 {
<span class="line-removed">203     if (!m_injectedScriptManager.inspectorEnvironment().developerExtrasEnabled())</span>
<span class="line-removed">204         return;</span>
<span class="line-removed">205 </span>
206     if (!m_heapAgent)
207         return;
208 
209     ErrorString ignored;
210     double timestamp;
211     String snapshotData;
212     m_heapAgent-&gt;snapshot(ignored, &amp;timestamp, &amp;snapshotData);
213 
214     m_frontendDispatcher-&gt;heapSnapshot(timestamp, snapshotData, title.isEmpty() ? nullptr : &amp;title);
215 }
216 
<span class="line-modified">217 void InspectorConsoleAgent::count(JSC::ExecState* exec, const String&amp; label)</span>
218 {
<span class="line-removed">219     if (!m_injectedScriptManager.inspectorEnvironment().developerExtrasEnabled())</span>
<span class="line-removed">220         return;</span>
<span class="line-removed">221 </span>
222     auto result = m_counts.add(label, 1);
223     if (!result.isNewEntry)
224         result.iterator-&gt;value += 1;
225 
226     // FIXME: Web Inspector should have a better UI for counters, but for now we just log an updated counter value.
227 
228     String message = makeString(label, &quot;: &quot;, result.iterator-&gt;value);
<span class="line-modified">229     addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Log, MessageLevel::Debug, message, createScriptCallStackForConsole(exec, 1)));</span>
230 }
231 
<span class="line-modified">232 void InspectorConsoleAgent::countReset(JSC::ExecState* exec, const String&amp; label)</span>
233 {
<span class="line-removed">234     if (!m_injectedScriptManager.inspectorEnvironment().developerExtrasEnabled())</span>
<span class="line-removed">235         return;</span>
<span class="line-removed">236 </span>
237     auto it = m_counts.find(label);
238     if (it == m_counts.end()) {
239         // FIXME: Send an enum to the frontend for localization?
240         String warning = makeString(&quot;Counter \&quot;&quot;, label, &quot;\&quot; does not exist&quot;);
<span class="line-modified">241         addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Log, MessageLevel::Warning, warning, createScriptCallStackForConsole(exec, 1)));</span>
242         return;
243     }
244 
245     it-&gt;value = 0;
246 
247     // FIXME: Web Inspector should have a better UI for counters, but for now we just log an updated counter value.
248 }
249 
250 static bool isGroupMessage(MessageType type)
251 {
252     return type == MessageType::StartGroup
253         || type == MessageType::StartGroupCollapsed
254         || type == MessageType::EndGroup;
255 }
256 
257 void InspectorConsoleAgent::addConsoleMessage(std::unique_ptr&lt;ConsoleMessage&gt; consoleMessage)
258 {
<span class="line-removed">259     if (!m_injectedScriptManager.inspectorEnvironment().developerExtrasEnabled())</span>
<span class="line-removed">260         return;</span>
<span class="line-removed">261 </span>
262     ASSERT_ARG(consoleMessage, consoleMessage);
263 
264     ConsoleMessage* previousMessage = m_consoleMessages.isEmpty() ? nullptr : m_consoleMessages.last().get();
265 
266     if (previousMessage &amp;&amp; !isGroupMessage(previousMessage-&gt;type()) &amp;&amp; previousMessage-&gt;isEqual(consoleMessage.get())) {
267         previousMessage-&gt;incrementCount();
268         if (m_enabled)
269             previousMessage-&gt;updateRepeatCountInConsole(*m_frontendDispatcher);
270     } else {
271         ConsoleMessage* newMessage = consoleMessage.get();
272         m_consoleMessages.append(WTFMove(consoleMessage));
273         if (m_enabled)
274             newMessage-&gt;addToFrontend(*m_frontendDispatcher, m_injectedScriptManager, true);
275 
276         if (m_consoleMessages.size() &gt;= maximumConsoleMessages) {
277             m_expiredConsoleMessageCount += expireConsoleMessagesStep;
278             m_consoleMessages.remove(0, expireConsoleMessagesStep);
279         }
280     }
281 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (C) 2014-2019 Apple Inc. All rights reserved.</span>
  3  * Copyright (C) 2011 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 16  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 17  * DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 18  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 19  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 20  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 21  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 23  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorConsoleAgent.h&quot;
 28 
 29 #include &quot;ConsoleMessage.h&quot;
 30 #include &quot;InjectedScriptManager.h&quot;
 31 #include &quot;InspectorFrontendRouter.h&quot;
 32 #include &quot;InspectorHeapAgent.h&quot;
 33 #include &quot;ScriptArguments.h&quot;
 34 #include &quot;ScriptCallFrame.h&quot;
 35 #include &quot;ScriptCallStack.h&quot;
 36 #include &quot;ScriptCallStackFactory.h&quot;
 37 #include &quot;ScriptObject.h&quot;
 38 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
 39 
 40 namespace Inspector {
 41 
<span class="line-modified"> 42 static constexpr unsigned maximumConsoleMessages = 100;</span>
<span class="line-modified"> 43 static constexpr int expireConsoleMessagesStep = 10;</span>
 44 
 45 InspectorConsoleAgent::InspectorConsoleAgent(AgentContext&amp; context)
 46     : InspectorAgentBase(&quot;Console&quot;_s)
 47     , m_injectedScriptManager(context.injectedScriptManager)
 48     , m_frontendDispatcher(makeUnique&lt;ConsoleFrontendDispatcher&gt;(context.frontendRouter))
 49     , m_backendDispatcher(ConsoleBackendDispatcher::create(context.backendDispatcher, this))
 50 {
 51 }
 52 
 53 InspectorConsoleAgent::~InspectorConsoleAgent() = default;
 54 
 55 void InspectorConsoleAgent::didCreateFrontendAndBackend(FrontendRouter*, BackendDispatcher*)
 56 {
 57 }
 58 
 59 void InspectorConsoleAgent::willDestroyFrontendAndBackend(DisconnectReason)
 60 {
 61     String errorString;
 62     disable(errorString);
 63 }
</pre>
<hr />
<pre>
 89 
 90 void InspectorConsoleAgent::disable(ErrorString&amp;)
 91 {
 92     if (!m_enabled)
 93         return;
 94 
 95     m_enabled = false;
 96 }
 97 
 98 void InspectorConsoleAgent::clearMessages(ErrorString&amp;)
 99 {
100     m_consoleMessages.clear();
101     m_expiredConsoleMessageCount = 0;
102 
103     m_injectedScriptManager.releaseObjectGroup(&quot;console&quot;_s);
104 
105     if (m_enabled)
106         m_frontendDispatcher-&gt;messagesCleared();
107 }
108 
<span class="line-added">109 bool InspectorConsoleAgent::developerExtrasEnabled() const</span>
<span class="line-added">110 {</span>
<span class="line-added">111     return m_injectedScriptManager.inspectorEnvironment().developerExtrasEnabled();</span>
<span class="line-added">112 }</span>
<span class="line-added">113 </span>
114 void InspectorConsoleAgent::reset()
115 {
116     ErrorString ignored;
117     clearMessages(ignored);
118 
119     m_times.clear();
120     m_counts.clear();
121 }
122 
123 void InspectorConsoleAgent::addMessageToConsole(std::unique_ptr&lt;ConsoleMessage&gt; message)
124 {



125     if (message-&gt;type() == MessageType::Clear) {
126         ErrorString ignored;
127         clearMessages(ignored);
128     }
129 
130     addConsoleMessage(WTFMove(message));
131 }
132 
<span class="line-modified">133 void InspectorConsoleAgent::startTiming(JSC::JSGlobalObject* globalObject, const String&amp; label)</span>
134 {



135     ASSERT(!label.isNull());
136     if (label.isNull())
137         return;
138 
139     auto result = m_times.add(label, MonotonicTime::now());
140 
141     if (!result.isNewEntry) {
142         // FIXME: Send an enum to the frontend for localization?
143         String warning = makeString(&quot;Timer \&quot;&quot;, label, &quot;\&quot; already exists&quot;);
<span class="line-modified">144         addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Timing, MessageLevel::Warning, warning, createScriptCallStackForConsole(globalObject, 1)));</span>
145     }
146 }
147 
<span class="line-modified">148 void InspectorConsoleAgent::logTiming(JSC::JSGlobalObject* globalObject, const String&amp; label, Ref&lt;ScriptArguments&gt;&amp;&amp; arguments)</span>
149 {



150     ASSERT(!label.isNull());
151     if (label.isNull())
152         return;
153 
<span class="line-modified">154     auto callStack = createScriptCallStackForConsole(globalObject, 1);</span>
155 
156     auto it = m_times.find(label);
157     if (it == m_times.end()) {
158         // FIXME: Send an enum to the frontend for localization?
159         String warning = makeString(&quot;Timer \&quot;&quot;, label, &quot;\&quot; does not exist&quot;);
160         addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Timing, MessageLevel::Warning, warning, WTFMove(callStack)));
161         return;
162     }
163 
164     MonotonicTime startTime = it-&gt;value;
165     Seconds elapsed = MonotonicTime::now() - startTime;
166     String message = makeString(label, &quot;: &quot;, FormattedNumber::fixedWidth(elapsed.milliseconds(), 3), &quot;ms&quot;);
167     addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Timing, MessageLevel::Debug, message, WTFMove(arguments), WTFMove(callStack)));
168 }
169 
<span class="line-modified">170 void InspectorConsoleAgent::stopTiming(JSC::JSGlobalObject* globalObject, const String&amp; label)</span>
171 {



172     ASSERT(!label.isNull());
173     if (label.isNull())
174         return;
175 
<span class="line-modified">176     auto callStack = createScriptCallStackForConsole(globalObject, 1);</span>
177 
178     auto it = m_times.find(label);
179     if (it == m_times.end()) {
180         // FIXME: Send an enum to the frontend for localization?
181         String warning = makeString(&quot;Timer \&quot;&quot;, label, &quot;\&quot; does not exist&quot;);
182         addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Timing, MessageLevel::Warning, warning, WTFMove(callStack)));
183         return;
184     }
185 
186     MonotonicTime startTime = it-&gt;value;
187     Seconds elapsed = MonotonicTime::now() - startTime;
188     String message = makeString(label, &quot;: &quot;, FormattedNumber::fixedWidth(elapsed.milliseconds(), 3), &quot;ms&quot;);
189     addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Timing, MessageLevel::Debug, message, WTFMove(callStack)));
190 
191     m_times.remove(it);
192 }
193 
194 void InspectorConsoleAgent::takeHeapSnapshot(const String&amp; title)
195 {



196     if (!m_heapAgent)
197         return;
198 
199     ErrorString ignored;
200     double timestamp;
201     String snapshotData;
202     m_heapAgent-&gt;snapshot(ignored, &amp;timestamp, &amp;snapshotData);
203 
204     m_frontendDispatcher-&gt;heapSnapshot(timestamp, snapshotData, title.isEmpty() ? nullptr : &amp;title);
205 }
206 
<span class="line-modified">207 void InspectorConsoleAgent::count(JSC::JSGlobalObject* globalObject, const String&amp; label)</span>
208 {



209     auto result = m_counts.add(label, 1);
210     if (!result.isNewEntry)
211         result.iterator-&gt;value += 1;
212 
213     // FIXME: Web Inspector should have a better UI for counters, but for now we just log an updated counter value.
214 
215     String message = makeString(label, &quot;: &quot;, result.iterator-&gt;value);
<span class="line-modified">216     addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Log, MessageLevel::Debug, message, createScriptCallStackForConsole(globalObject, 1)));</span>
217 }
218 
<span class="line-modified">219 void InspectorConsoleAgent::countReset(JSC::JSGlobalObject* globalObject, const String&amp; label)</span>
220 {



221     auto it = m_counts.find(label);
222     if (it == m_counts.end()) {
223         // FIXME: Send an enum to the frontend for localization?
224         String warning = makeString(&quot;Counter \&quot;&quot;, label, &quot;\&quot; does not exist&quot;);
<span class="line-modified">225         addMessageToConsole(makeUnique&lt;ConsoleMessage&gt;(MessageSource::ConsoleAPI, MessageType::Log, MessageLevel::Warning, warning, createScriptCallStackForConsole(globalObject, 1)));</span>
226         return;
227     }
228 
229     it-&gt;value = 0;
230 
231     // FIXME: Web Inspector should have a better UI for counters, but for now we just log an updated counter value.
232 }
233 
234 static bool isGroupMessage(MessageType type)
235 {
236     return type == MessageType::StartGroup
237         || type == MessageType::StartGroupCollapsed
238         || type == MessageType::EndGroup;
239 }
240 
241 void InspectorConsoleAgent::addConsoleMessage(std::unique_ptr&lt;ConsoleMessage&gt; consoleMessage)
242 {



243     ASSERT_ARG(consoleMessage, consoleMessage);
244 
245     ConsoleMessage* previousMessage = m_consoleMessages.isEmpty() ? nullptr : m_consoleMessages.last().get();
246 
247     if (previousMessage &amp;&amp; !isGroupMessage(previousMessage-&gt;type()) &amp;&amp; previousMessage-&gt;isEqual(consoleMessage.get())) {
248         previousMessage-&gt;incrementCount();
249         if (m_enabled)
250             previousMessage-&gt;updateRepeatCountInConsole(*m_frontendDispatcher);
251     } else {
252         ConsoleMessage* newMessage = consoleMessage.get();
253         m_consoleMessages.append(WTFMove(consoleMessage));
254         if (m_enabled)
255             newMessage-&gt;addToFrontend(*m_frontendDispatcher, m_injectedScriptManager, true);
256 
257         if (m_consoleMessages.size() &gt;= maximumConsoleMessages) {
258             m_expiredConsoleMessageCount += expireConsoleMessagesStep;
259             m_consoleMessages.remove(0, expireConsoleMessagesStep);
260         }
261     }
262 }
</pre>
</td>
</tr>
</table>
<center><a href="InspectorAuditAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorConsoleAgent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
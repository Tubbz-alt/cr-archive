<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WTF/wtf/HashTraits.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HashTable.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HexNumber.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/HashTraits.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2005-2018 Apple Inc. All rights reserved.</span>
   *
   * This library is free software; you can redistribute it and/or
   * modify it under the terms of the GNU Library General Public
   * License as published by the Free Software Foundation; either
   * version 2 of the License, or (at your option) any later version.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2005-2019 Apple Inc. All rights reserved.</span>
   *
   * This library is free software; you can redistribute it and/or
   * modify it under the terms of the GNU Library General Public
   * License as published by the Free Software Foundation; either
   * version 2 of the License, or (at your option) any later version.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 36,28 ***</span>
  
  template&lt;bool isInteger, typename T&gt; struct GenericHashTraitsBase;
  
  template&lt;typename T&gt; struct GenericHashTraitsBase&lt;false, T&gt; {
      // The emptyValueIsZero flag is used to optimize allocation of empty hash tables with zeroed memory.
<span class="line-modified">!     static const bool emptyValueIsZero = false;</span>
  
      // The hasIsEmptyValueFunction flag allows the hash table to automatically generate code to check
      // for the empty value when it can be done with the equality operator, but allows custom functions
      // for cases like String that need them.
<span class="line-modified">!     static const bool hasIsEmptyValueFunction = false;</span>
  
      // Used by WeakPtr to indicate that the value may become deleted without being explicitly removed.
<span class="line-modified">!     static const bool hasIsReleasedWeakValueFunction = false;</span>
  
      // The starting table size. Can be overridden when we know beforehand that
      // a hash table will have at least N entries.
<span class="line-modified">!     static const unsigned minimumTableSize = 8;</span>
  };
  
  // Default integer traits disallow both 0 and -1 as keys (max value instead of -1 for unsigned).
  template&lt;typename T&gt; struct GenericHashTraitsBase&lt;true, T&gt; : GenericHashTraitsBase&lt;false, T&gt; {
<span class="line-modified">!     static const bool emptyValueIsZero = true;</span>
      static void constructDeletedValue(T&amp; slot) { slot = static_cast&lt;T&gt;(-1); }
      static bool isDeletedValue(T value) { return value == static_cast&lt;T&gt;(-1); }
  };
  
  template&lt;typename T&gt; struct GenericHashTraits : GenericHashTraitsBase&lt;std::is_integral&lt;T&gt;::value, T&gt; {
<span class="line-new-header">--- 36,28 ---</span>
  
  template&lt;bool isInteger, typename T&gt; struct GenericHashTraitsBase;
  
  template&lt;typename T&gt; struct GenericHashTraitsBase&lt;false, T&gt; {
      // The emptyValueIsZero flag is used to optimize allocation of empty hash tables with zeroed memory.
<span class="line-modified">!     static constexpr bool emptyValueIsZero = false;</span>
  
      // The hasIsEmptyValueFunction flag allows the hash table to automatically generate code to check
      // for the empty value when it can be done with the equality operator, but allows custom functions
      // for cases like String that need them.
<span class="line-modified">!     static constexpr bool hasIsEmptyValueFunction = false;</span>
  
      // Used by WeakPtr to indicate that the value may become deleted without being explicitly removed.
<span class="line-modified">!     static constexpr bool hasIsReleasedWeakValueFunction = false;</span>
  
      // The starting table size. Can be overridden when we know beforehand that
      // a hash table will have at least N entries.
<span class="line-modified">!     static constexpr unsigned minimumTableSize = 8;</span>
  };
  
  // Default integer traits disallow both 0 and -1 as keys (max value instead of -1 for unsigned).
  template&lt;typename T&gt; struct GenericHashTraitsBase&lt;true, T&gt; : GenericHashTraitsBase&lt;false, T&gt; {
<span class="line-modified">!     static constexpr bool emptyValueIsZero = true;</span>
      static void constructDeletedValue(T&amp; slot) { slot = static_cast&lt;T&gt;(-1); }
      static bool isDeletedValue(T value) { return value == static_cast&lt;T&gt;(-1); }
  };
  
  template&lt;typename T&gt; struct GenericHashTraits : GenericHashTraitsBase&lt;std::is_integral&lt;T&gt;::value, T&gt; {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 97,50 ***</span>
  template&lt;&gt; struct HashTraits&lt;float&gt; : FloatHashTraits&lt;float&gt; { };
  template&lt;&gt; struct HashTraits&lt;double&gt; : FloatHashTraits&lt;double&gt; { };
  
  // Default unsigned traits disallow both 0 and max as keys -- use these traits to allow zero and disallow max - 1.
  template&lt;typename T&gt; struct UnsignedWithZeroKeyHashTraits : GenericHashTraits&lt;T&gt; {
<span class="line-modified">!     static const bool emptyValueIsZero = false;</span>
      static T emptyValue() { return std::numeric_limits&lt;T&gt;::max(); }
      static void constructDeletedValue(T&amp; slot) { slot = std::numeric_limits&lt;T&gt;::max() - 1; }
      static bool isDeletedValue(T value) { return value == std::numeric_limits&lt;T&gt;::max() - 1; }
  };
  
  template&lt;typename T&gt; struct SignedWithZeroKeyHashTraits : GenericHashTraits&lt;T&gt; {
<span class="line-modified">!     static const bool emptyValueIsZero = false;</span>
      static T emptyValue() { return std::numeric_limits&lt;T&gt;::min(); }
      static void constructDeletedValue(T&amp; slot) { slot = std::numeric_limits&lt;T&gt;::max(); }
      static bool isDeletedValue(T value) { return value == std::numeric_limits&lt;T&gt;::max(); }
  };
  
  // Can be used with strong enums, allows zero as key.
  template&lt;typename T&gt; struct StrongEnumHashTraits : GenericHashTraits&lt;T&gt; {
      using UnderlyingType = typename std::underlying_type&lt;T&gt;::type;
<span class="line-modified">!     static const bool emptyValueIsZero = false;</span>
      static T emptyValue() { return static_cast&lt;T&gt;(std::numeric_limits&lt;UnderlyingType&gt;::max()); }
      static void constructDeletedValue(T&amp; slot) { slot = static_cast&lt;T&gt;(std::numeric_limits&lt;UnderlyingType&gt;::max() - 1); }
      static bool isDeletedValue(T value) { return value == static_cast&lt;T&gt;(std::numeric_limits&lt;UnderlyingType&gt;::max() - 1); }
  };
  
  template&lt;typename P&gt; struct HashTraits&lt;P*&gt; : GenericHashTraits&lt;P*&gt; {
<span class="line-modified">!     static const bool emptyValueIsZero = true;</span>
      static void constructDeletedValue(P*&amp; slot) { slot = reinterpret_cast&lt;P*&gt;(-1); }
      static bool isDeletedValue(P* value) { return value == reinterpret_cast&lt;P*&gt;(-1); }
  };
  
  #ifdef __OBJC__
  
  template&lt;&gt; struct HashTraits&lt;__unsafe_unretained id&gt; : GenericHashTraits&lt;__unsafe_unretained id&gt; {
<span class="line-modified">!     static const bool emptyValueIsZero = true;</span>
      static void constructDeletedValue(__unsafe_unretained id&amp; slot) { slot = (__bridge __unsafe_unretained id)reinterpret_cast&lt;CFTypeRef&gt;(-1); }
      static bool isDeletedValue(__unsafe_unretained id value) { return (__bridge CFTypeRef)value == reinterpret_cast&lt;CFTypeRef&gt;(-1); }
  };
  
  #endif
  
  template&lt;typename T&gt; struct SimpleClassHashTraits : GenericHashTraits&lt;T&gt; {
<span class="line-modified">!     static const bool emptyValueIsZero = true;</span>
      static void constructDeletedValue(T&amp; slot) { new (NotNull, std::addressof(slot)) T(HashTableDeletedValue); }
      static bool isDeletedValue(const T&amp; value) { return value.isHashTableDeletedValue(); }
  };
  
  template&lt;typename T, typename Deleter&gt; struct HashTraits&lt;std::unique_ptr&lt;T, Deleter&gt;&gt; : SimpleClassHashTraits&lt;std::unique_ptr&lt;T, Deleter&gt;&gt; {
<span class="line-new-header">--- 97,50 ---</span>
  template&lt;&gt; struct HashTraits&lt;float&gt; : FloatHashTraits&lt;float&gt; { };
  template&lt;&gt; struct HashTraits&lt;double&gt; : FloatHashTraits&lt;double&gt; { };
  
  // Default unsigned traits disallow both 0 and max as keys -- use these traits to allow zero and disallow max - 1.
  template&lt;typename T&gt; struct UnsignedWithZeroKeyHashTraits : GenericHashTraits&lt;T&gt; {
<span class="line-modified">!     static constexpr bool emptyValueIsZero = false;</span>
      static T emptyValue() { return std::numeric_limits&lt;T&gt;::max(); }
      static void constructDeletedValue(T&amp; slot) { slot = std::numeric_limits&lt;T&gt;::max() - 1; }
      static bool isDeletedValue(T value) { return value == std::numeric_limits&lt;T&gt;::max() - 1; }
  };
  
  template&lt;typename T&gt; struct SignedWithZeroKeyHashTraits : GenericHashTraits&lt;T&gt; {
<span class="line-modified">!     static constexpr bool emptyValueIsZero = false;</span>
      static T emptyValue() { return std::numeric_limits&lt;T&gt;::min(); }
      static void constructDeletedValue(T&amp; slot) { slot = std::numeric_limits&lt;T&gt;::max(); }
      static bool isDeletedValue(T value) { return value == std::numeric_limits&lt;T&gt;::max(); }
  };
  
  // Can be used with strong enums, allows zero as key.
  template&lt;typename T&gt; struct StrongEnumHashTraits : GenericHashTraits&lt;T&gt; {
      using UnderlyingType = typename std::underlying_type&lt;T&gt;::type;
<span class="line-modified">!     static constexpr bool emptyValueIsZero = false;</span>
      static T emptyValue() { return static_cast&lt;T&gt;(std::numeric_limits&lt;UnderlyingType&gt;::max()); }
      static void constructDeletedValue(T&amp; slot) { slot = static_cast&lt;T&gt;(std::numeric_limits&lt;UnderlyingType&gt;::max() - 1); }
      static bool isDeletedValue(T value) { return value == static_cast&lt;T&gt;(std::numeric_limits&lt;UnderlyingType&gt;::max() - 1); }
  };
  
  template&lt;typename P&gt; struct HashTraits&lt;P*&gt; : GenericHashTraits&lt;P*&gt; {
<span class="line-modified">!     static constexpr bool emptyValueIsZero = true;</span>
      static void constructDeletedValue(P*&amp; slot) { slot = reinterpret_cast&lt;P*&gt;(-1); }
      static bool isDeletedValue(P* value) { return value == reinterpret_cast&lt;P*&gt;(-1); }
  };
  
  #ifdef __OBJC__
  
  template&lt;&gt; struct HashTraits&lt;__unsafe_unretained id&gt; : GenericHashTraits&lt;__unsafe_unretained id&gt; {
<span class="line-modified">!     static constexpr bool emptyValueIsZero = true;</span>
      static void constructDeletedValue(__unsafe_unretained id&amp; slot) { slot = (__bridge __unsafe_unretained id)reinterpret_cast&lt;CFTypeRef&gt;(-1); }
      static bool isDeletedValue(__unsafe_unretained id value) { return (__bridge CFTypeRef)value == reinterpret_cast&lt;CFTypeRef&gt;(-1); }
  };
  
  #endif
  
  template&lt;typename T&gt; struct SimpleClassHashTraits : GenericHashTraits&lt;T&gt; {
<span class="line-modified">!     static constexpr bool emptyValueIsZero = true;</span>
      static void constructDeletedValue(T&amp; slot) { new (NotNull, std::addressof(slot)) T(HashTableDeletedValue); }
      static bool isDeletedValue(const T&amp; value) { return value.isHashTableDeletedValue(); }
  };
  
  template&lt;typename T, typename Deleter&gt; struct HashTraits&lt;std::unique_ptr&lt;T, Deleter&gt;&gt; : SimpleClassHashTraits&lt;std::unique_ptr&lt;T, Deleter&gt;&gt; {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 194,20 ***</span>
          SimpleClassHashTraits&lt;RefPtr&lt;P&gt;&gt;::constructDeletedValue(value);
      }
  };
  
  template&lt;typename P&gt; struct RefHashTraits : SimpleClassHashTraits&lt;Ref&lt;P&gt;&gt; {
<span class="line-modified">!     static const bool emptyValueIsZero = true;</span>
      static Ref&lt;P&gt; emptyValue() { return HashTableEmptyValue; }
  
      template &lt;typename&gt;
      static void constructEmptyValue(Ref&lt;P&gt;&amp; slot)
      {
          new (NotNull, std::addressof(slot)) Ref&lt;P&gt;(HashTableEmptyValue);
      }
  
<span class="line-modified">!     static const bool hasIsEmptyValueFunction = true;</span>
      static bool isEmptyValue(const Ref&lt;P&gt;&amp; value) { return value.isHashTableEmptyValue(); }
  
      static void assignToEmpty(Ref&lt;P&gt;&amp; emptyValue, Ref&lt;P&gt;&amp;&amp; newValue) { ASSERT(isEmptyValue(emptyValue)); emptyValue.assignToHashTableEmptyValue(WTFMove(newValue)); }
  
      typedef P* PeekType;
<span class="line-new-header">--- 194,20 ---</span>
          SimpleClassHashTraits&lt;RefPtr&lt;P&gt;&gt;::constructDeletedValue(value);
      }
  };
  
  template&lt;typename P&gt; struct RefHashTraits : SimpleClassHashTraits&lt;Ref&lt;P&gt;&gt; {
<span class="line-modified">!     static constexpr bool emptyValueIsZero = true;</span>
      static Ref&lt;P&gt; emptyValue() { return HashTableEmptyValue; }
  
      template &lt;typename&gt;
      static void constructEmptyValue(Ref&lt;P&gt;&amp; slot)
      {
          new (NotNull, std::addressof(slot)) Ref&lt;P&gt;(HashTableEmptyValue);
      }
  
<span class="line-modified">!     static constexpr bool hasIsEmptyValueFunction = true;</span>
      static bool isEmptyValue(const Ref&lt;P&gt;&amp; value) { return value.isHashTableEmptyValue(); }
  
      static void assignToEmpty(Ref&lt;P&gt;&amp; emptyValue, Ref&lt;P&gt;&amp;&amp; newValue) { ASSERT(isEmptyValue(emptyValue)); emptyValue.assignToHashTableEmptyValue(WTFMove(newValue)); }
  
      typedef P* PeekType;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 218,12 ***</span>
      static TakeType take(Ref&lt;P&gt;&amp;&amp; value) { return isEmptyValue(value) ? WTF::nullopt : Optional&lt;Ref&lt;P&gt;&gt;(WTFMove(value)); }
  };
  
  template&lt;typename P&gt; struct HashTraits&lt;Ref&lt;P&gt;&gt; : RefHashTraits&lt;P&gt; { };
  
  template&lt;&gt; struct HashTraits&lt;String&gt; : SimpleClassHashTraits&lt;String&gt; {
<span class="line-modified">!     static const bool hasIsEmptyValueFunction = true;</span>
      static bool isEmptyValue(const String&amp;);
  
      static void customDeleteBucket(String&amp;);
  };
  
<span class="line-new-header">--- 218,25 ---</span>
      static TakeType take(Ref&lt;P&gt;&amp;&amp; value) { return isEmptyValue(value) ? WTF::nullopt : Optional&lt;Ref&lt;P&gt;&gt;(WTFMove(value)); }
  };
  
  template&lt;typename P&gt; struct HashTraits&lt;Ref&lt;P&gt;&gt; : RefHashTraits&lt;P&gt; { };
  
<span class="line-added">+ template&lt;typename P&gt; struct HashTraits&lt;Packed&lt;P*&gt;&gt; : SimpleClassHashTraits&lt;Packed&lt;P*&gt;&gt; {</span>
<span class="line-added">+     static constexpr bool hasIsEmptyValueFunction = true;</span>
<span class="line-added">+     using TargetType = Packed&lt;P*&gt;;</span>
<span class="line-added">+     static_assert(TargetType::alignment &lt; 4 * KB, &quot;The first page is always unmapped since it includes nullptr.&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     static Packed&lt;P*&gt; emptyValue() { return nullptr; }</span>
<span class="line-added">+     static bool isEmptyValue(const TargetType&amp; value) { return value.get() == nullptr; }</span>
<span class="line-added">+ </span>
<span class="line-added">+     using PeekType = P*;</span>
<span class="line-added">+     static PeekType peek(const TargetType&amp; value) { return value.get(); }</span>
<span class="line-added">+     static PeekType peek(P* value) { return value; }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  template&lt;&gt; struct HashTraits&lt;String&gt; : SimpleClassHashTraits&lt;String&gt; {
<span class="line-modified">!     static constexpr bool hasIsEmptyValueFunction = true;</span>
      static bool isEmptyValue(const String&amp;);
  
      static void customDeleteBucket(String&amp;);
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 257,11 ***</span>
  struct HashTraitHasCustomDelete {
      static T&amp; bucketArg;
      template&lt;typename X&gt; static std::true_type TestHasCustomDelete(X*, decltype(X::customDeleteBucket(bucketArg))* = nullptr);
      static std::false_type TestHasCustomDelete(...);
      typedef decltype(TestHasCustomDelete(static_cast&lt;Traits*&gt;(nullptr))) ResultType;
<span class="line-modified">!     static const bool value = ResultType::value;</span>
  };
  
  template&lt;typename Traits, typename T&gt;
  typename std::enable_if&lt;HashTraitHasCustomDelete&lt;Traits, T&gt;::value&gt;::type
  hashTraitsDeleteBucket(T&amp; value)
<span class="line-new-header">--- 270,11 ---</span>
  struct HashTraitHasCustomDelete {
      static T&amp; bucketArg;
      template&lt;typename X&gt; static std::true_type TestHasCustomDelete(X*, decltype(X::customDeleteBucket(bucketArg))* = nullptr);
      static std::false_type TestHasCustomDelete(...);
      typedef decltype(TestHasCustomDelete(static_cast&lt;Traits*&gt;(nullptr))) ResultType;
<span class="line-modified">!     static constexpr bool value = ResultType::value;</span>
  };
  
  template&lt;typename Traits, typename T&gt;
  typename std::enable_if&lt;HashTraitHasCustomDelete&lt;Traits, T&gt;::value&gt;::type
  hashTraitsDeleteBucket(T&amp; value)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 282,14 ***</span>
      typedef FirstTraitsArg FirstTraits;
      typedef SecondTraitsArg SecondTraits;
      typedef std::pair&lt;typename FirstTraits::TraitType, typename SecondTraits::TraitType&gt; TraitType;
      typedef std::pair&lt;typename FirstTraits::EmptyValueType, typename SecondTraits::EmptyValueType&gt; EmptyValueType;
  
<span class="line-modified">!     static const bool emptyValueIsZero = FirstTraits::emptyValueIsZero &amp;&amp; SecondTraits::emptyValueIsZero;</span>
      static EmptyValueType emptyValue() { return std::make_pair(FirstTraits::emptyValue(), SecondTraits::emptyValue()); }
  
<span class="line-modified">!     static const unsigned minimumTableSize = FirstTraits::minimumTableSize;</span>
  
      static void constructDeletedValue(TraitType&amp; slot) { FirstTraits::constructDeletedValue(slot.first); }
      static bool isDeletedValue(const TraitType&amp; value) { return FirstTraits::isDeletedValue(value.first); }
  };
  
<span class="line-new-header">--- 295,14 ---</span>
      typedef FirstTraitsArg FirstTraits;
      typedef SecondTraitsArg SecondTraits;
      typedef std::pair&lt;typename FirstTraits::TraitType, typename SecondTraits::TraitType&gt; TraitType;
      typedef std::pair&lt;typename FirstTraits::EmptyValueType, typename SecondTraits::EmptyValueType&gt; EmptyValueType;
  
<span class="line-modified">!     static constexpr bool emptyValueIsZero = FirstTraits::emptyValueIsZero &amp;&amp; SecondTraits::emptyValueIsZero;</span>
      static EmptyValueType emptyValue() { return std::make_pair(FirstTraits::emptyValue(), SecondTraits::emptyValue()); }
  
<span class="line-modified">!     static constexpr unsigned minimumTableSize = FirstTraits::minimumTableSize;</span>
  
      static void constructDeletedValue(TraitType&amp; slot) { FirstTraits::constructDeletedValue(slot.first); }
      static bool isDeletedValue(const TraitType&amp; value) { return FirstTraits::isDeletedValue(value.first); }
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 305,14 ***</span>
      // better here right now because GCC can&#39;t do C++.
      template&lt;typename BoolType&gt;
      static constexpr bool allTrue(BoolType value) { return value; }
      template&lt;typename BoolType, typename... BoolTypes&gt;
      static constexpr bool allTrue(BoolType value, BoolTypes... values) { return value &amp;&amp; allTrue(values...); }
<span class="line-modified">!     static const bool emptyValueIsZero = allTrue(FirstTrait::emptyValueIsZero, Traits::emptyValueIsZero...);</span>
      static EmptyValueType emptyValue() { return std::make_tuple(FirstTrait::emptyValue(), Traits::emptyValue()...); }
  
<span class="line-modified">!     static const unsigned minimumTableSize = FirstTrait::minimumTableSize;</span>
  
      static void constructDeletedValue(TraitType&amp; slot) { FirstTrait::constructDeletedValue(std::get&lt;0&gt;(slot)); }
      static bool isDeletedValue(const TraitType&amp; value) { return FirstTrait::isDeletedValue(std::get&lt;0&gt;(value)); }
  };
  
<span class="line-new-header">--- 318,14 ---</span>
      // better here right now because GCC can&#39;t do C++.
      template&lt;typename BoolType&gt;
      static constexpr bool allTrue(BoolType value) { return value; }
      template&lt;typename BoolType, typename... BoolTypes&gt;
      static constexpr bool allTrue(BoolType value, BoolTypes... values) { return value &amp;&amp; allTrue(values...); }
<span class="line-modified">!     static constexpr bool emptyValueIsZero = allTrue(FirstTrait::emptyValueIsZero, Traits::emptyValueIsZero...);</span>
      static EmptyValueType emptyValue() { return std::make_tuple(FirstTrait::emptyValue(), Traits::emptyValue()...); }
  
<span class="line-modified">!     static constexpr unsigned minimumTableSize = FirstTrait::minimumTableSize;</span>
  
      static void constructDeletedValue(TraitType&amp; slot) { FirstTrait::constructDeletedValue(std::get&lt;0&gt;(slot)); }
      static bool isDeletedValue(const TraitType&amp; value) { return FirstTrait::isDeletedValue(std::get&lt;0&gt;(value)); }
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 325,21 ***</span>
      typedef ValueTraitsArg ValueTraits;
      typedef KeyValuePair&lt;typename KeyTraits::TraitType, typename ValueTraits::TraitType&gt; TraitType;
      typedef KeyValuePair&lt;typename KeyTraits::EmptyValueType, typename ValueTraits::EmptyValueType&gt; EmptyValueType;
      typedef typename ValueTraitsArg::TraitType ValueType;
  
<span class="line-modified">!     static const bool emptyValueIsZero = KeyTraits::emptyValueIsZero &amp;&amp; ValueTraits::emptyValueIsZero;</span>
      static EmptyValueType emptyValue() { return KeyValuePair&lt;typename KeyTraits::EmptyValueType, typename ValueTraits::EmptyValueType&gt;(KeyTraits::emptyValue(), ValueTraits::emptyValue()); }
  
      template &lt;typename&gt;
      static void constructEmptyValue(TraitType&amp; slot)
      {
          KeyTraits::template constructEmptyValue&lt;KeyTraits&gt;(slot.key);
          ValueTraits::template constructEmptyValue&lt;ValueTraits&gt;(slot.value);
      }
  
<span class="line-modified">!     static const unsigned minimumTableSize = KeyTraits::minimumTableSize;</span>
  
      static void constructDeletedValue(TraitType&amp; slot) { KeyTraits::constructDeletedValue(slot.key); }
      static bool isDeletedValue(const TraitType&amp; value) { return KeyTraits::isDeletedValue(value.key); }
  
      static void customDeleteBucket(TraitType&amp; value)
<span class="line-new-header">--- 338,21 ---</span>
      typedef ValueTraitsArg ValueTraits;
      typedef KeyValuePair&lt;typename KeyTraits::TraitType, typename ValueTraits::TraitType&gt; TraitType;
      typedef KeyValuePair&lt;typename KeyTraits::EmptyValueType, typename ValueTraits::EmptyValueType&gt; EmptyValueType;
      typedef typename ValueTraitsArg::TraitType ValueType;
  
<span class="line-modified">!     static constexpr bool emptyValueIsZero = KeyTraits::emptyValueIsZero &amp;&amp; ValueTraits::emptyValueIsZero;</span>
      static EmptyValueType emptyValue() { return KeyValuePair&lt;typename KeyTraits::EmptyValueType, typename ValueTraits::EmptyValueType&gt;(KeyTraits::emptyValue(), ValueTraits::emptyValue()); }
  
      template &lt;typename&gt;
      static void constructEmptyValue(TraitType&amp; slot)
      {
          KeyTraits::template constructEmptyValue&lt;KeyTraits&gt;(slot.key);
          ValueTraits::template constructEmptyValue&lt;ValueTraits&gt;(slot.value);
      }
  
<span class="line-modified">!     static constexpr unsigned minimumTableSize = KeyTraits::minimumTableSize;</span>
  
      static void constructDeletedValue(TraitType&amp; slot) { KeyTraits::constructDeletedValue(slot.key); }
      static bool isDeletedValue(const TraitType&amp; value) { return KeyTraits::isDeletedValue(value.key); }
  
      static void customDeleteBucket(TraitType&amp; value)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 355,20 ***</span>
  template&lt;typename Key, typename Value&gt;
  struct HashTraits&lt;KeyValuePair&lt;Key, Value&gt;&gt; : public KeyValuePairHashTraits&lt;HashTraits&lt;Key&gt;, HashTraits&lt;Value&gt;&gt; { };
  
  template&lt;typename T&gt;
  struct NullableHashTraits : public HashTraits&lt;T&gt; {
<span class="line-modified">!     static const bool emptyValueIsZero = false;</span>
      static T emptyValue() { return reinterpret_cast&lt;T&gt;(1); }
  };
  
  // Useful for classes that want complete control over what is empty and what is deleted,
  // and how to construct both.
  template&lt;typename T&gt;
  struct CustomHashTraits : public GenericHashTraits&lt;T&gt; {
<span class="line-modified">!     static const bool emptyValueIsZero = false;</span>
<span class="line-modified">!     static const bool hasIsEmptyValueFunction = true;</span>
  
      static void constructDeletedValue(T&amp; slot)
      {
          new (NotNull, std::addressof(slot)) T(T::DeletedValue);
      }
<span class="line-new-header">--- 368,28 ---</span>
  template&lt;typename Key, typename Value&gt;
  struct HashTraits&lt;KeyValuePair&lt;Key, Value&gt;&gt; : public KeyValuePairHashTraits&lt;HashTraits&lt;Key&gt;, HashTraits&lt;Value&gt;&gt; { };
  
  template&lt;typename T&gt;
  struct NullableHashTraits : public HashTraits&lt;T&gt; {
<span class="line-modified">!     static constexpr bool emptyValueIsZero = false;</span>
      static T emptyValue() { return reinterpret_cast&lt;T&gt;(1); }
  };
  
<span class="line-added">+ template&lt;typename T, size_t inlineCapacity&gt;</span>
<span class="line-added">+ struct HashTraits&lt;Vector&lt;T, inlineCapacity&gt;&gt; : GenericHashTraits&lt;Vector&lt;T, inlineCapacity&gt;&gt; {</span>
<span class="line-added">+     static constexpr bool emptyValueIsZero = !inlineCapacity;</span>
<span class="line-added">+ </span>
<span class="line-added">+     static void constructDeletedValue(Vector&lt;T, inlineCapacity&gt;&amp; slot) { new (NotNull, std::addressof(slot)) Vector&lt;T, inlineCapacity&gt;(WTF::HashTableDeletedValue); }</span>
<span class="line-added">+     static bool isDeletedValue(const Vector&lt;T, inlineCapacity&gt;&amp; value) { return value.isHashTableDeletedValue(); }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  // Useful for classes that want complete control over what is empty and what is deleted,
  // and how to construct both.
  template&lt;typename T&gt;
  struct CustomHashTraits : public GenericHashTraits&lt;T&gt; {
<span class="line-modified">!     static constexpr bool emptyValueIsZero = false;</span>
<span class="line-modified">!     static constexpr bool hasIsEmptyValueFunction = true;</span>
  
      static void constructDeletedValue(T&amp; slot)
      {
          new (NotNull, std::addressof(slot)) T(T::DeletedValue);
      }
</pre>
<center><a href="HashTable.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HexNumber.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
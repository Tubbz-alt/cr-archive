<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderDeprecatedFlexibleBox.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderElement.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -59,11 +59,11 @@</span>
  #include &quot;RenderIterator.h&quot;
  #include &quot;RenderLayer.h&quot;
  #include &quot;RenderLayerCompositor.h&quot;
  #include &quot;RenderLineBreak.h&quot;
  #include &quot;RenderListItem.h&quot;
<span class="udiff-line-modified-removed">- #if !ASSERT_DISABLED</span>
<span class="udiff-line-modified-added">+ #if ASSERT_ENABLED</span>
  #include &quot;RenderListMarker.h&quot;
  #endif
  #include &quot;RenderFragmentContainer.h&quot;
  #include &quot;RenderTableCaption.h&quot;
  #include &quot;RenderTableCell.h&quot;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -162,11 +162,10 @@</span>
              return createRenderer&lt;RenderInline&gt;(element, WTFMove(style));
          FALLTHROUGH; // Fieldsets should make a block flow if display:inline is set.
      case DisplayType::Block:
      case DisplayType::FlowRoot:
      case DisplayType::InlineBlock:
<span class="udiff-line-removed">-     case DisplayType::Compact:</span>
          return createRenderer&lt;RenderBlockFlow&gt;(element, WTFMove(style));
      case DisplayType::ListItem:
          return createRenderer&lt;RenderListItem&gt;(element, WTFMove(style));
      case DisplayType::Flex:
      case DisplayType::InlineFlex:
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -468,11 +467,11 @@</span>
      // - when the document is painted, both layers are painted. The &lt;body&gt; layer doesn&#39;t
      //   know that it&#39;s inside a &quot;hidden SVG subtree&quot;, and thus paints, even if it shouldn&#39;t.
      // To avoid the problem alltogether, detect early if we&#39;re inside a hidden SVG subtree
      // and stop creating layers at all for these cases - they&#39;re not used anyways.
      if (child.hasLayer() &amp;&amp; !layerCreationAllowedForSubtree())
<span class="udiff-line-modified-removed">-         downcast&lt;RenderLayerModelObject&gt;(child).layer()-&gt;removeOnlyThisLayer();</span>
<span class="udiff-line-modified-added">+         downcast&lt;RenderLayerModelObject&gt;(child).layer()-&gt;removeOnlyThisLayer(RenderLayer::LayerChangeTiming::RenderTreeConstruction);</span>
  }
  
  RenderObject* RenderElement::attachRendererInternal(RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
  {
      child-&gt;setParent(this);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -709,12 +708,12 @@</span>
      auto* oldStyle = hasInitializedStyle() ? &amp;style() : nullptr;
      if (oldStyle) {
          // If our z-index changes value or our visibility changes,
          // we need to dirty our stacking context&#39;s z-order list.
          bool visibilityChanged = m_style.visibility() != newStyle.visibility()
<span class="udiff-line-modified-removed">-             || m_style.zIndex() != newStyle.zIndex()</span>
<span class="udiff-line-modified-removed">-             || m_style.hasAutoZIndex() != newStyle.hasAutoZIndex();</span>
<span class="udiff-line-modified-added">+             || m_style.usedZIndex() != newStyle.usedZIndex()</span>
<span class="udiff-line-modified-added">+             || m_style.hasAutoUsedZIndex() != newStyle.hasAutoUsedZIndex();</span>
  
          if (visibilityChanged)
              document().invalidateRenderingDependentRegions();
  
          if (visibilityChanged) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -884,11 +883,11 @@</span>
      // that needs to be drawn and layer visibility optimization can&#39;t be used
      if (parent()-&gt;style().visibility() != Visibility::Visible &amp;&amp; style().visibility() == Visibility::Visible &amp;&amp; !hasLayer()) {
          if (!layer)
              layer = parent()-&gt;enclosingLayer();
          if (layer)
<span class="udiff-line-modified-removed">-             layer-&gt;setHasVisibleContent();</span>
<span class="udiff-line-modified-added">+             layer-&gt;dirtyVisibleContentStatus();</span>
      }
  
      RenderObject::insertedIntoTree();
  }
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1356,19 +1355,19 @@</span>
  
      RenderStyle* cachedStyle = style().getCachedPseudoStyle(pseudo);
      if (cachedStyle)
          return cachedStyle;
  
<span class="udiff-line-modified-removed">-     std::unique_ptr&lt;RenderStyle&gt; result = getUncachedPseudoStyle(PseudoStyleRequest(pseudo), parentStyle);</span>
<span class="udiff-line-modified-added">+     std::unique_ptr&lt;RenderStyle&gt; result = getUncachedPseudoStyle({ pseudo }, parentStyle);</span>
      if (result)
          return const_cast&lt;RenderStyle&amp;&gt;(m_style).addCachedPseudoStyle(WTFMove(result));
      return nullptr;
  }
  
<span class="udiff-line-modified-removed">- std::unique_ptr&lt;RenderStyle&gt; RenderElement::getUncachedPseudoStyle(const PseudoStyleRequest&amp; pseudoStyleRequest, const RenderStyle* parentStyle, const RenderStyle* ownStyle) const</span>
<span class="udiff-line-modified-added">+ std::unique_ptr&lt;RenderStyle&gt; RenderElement::getUncachedPseudoStyle(const Style::PseudoElementRequest&amp; pseudoElementRequest, const RenderStyle* parentStyle, const RenderStyle* ownStyle) const</span>
  {
<span class="udiff-line-modified-removed">-     if (pseudoStyleRequest.pseudoId &lt; PseudoId::FirstInternalPseudoId &amp;&amp; !ownStyle &amp;&amp; !style().hasPseudoStyle(pseudoStyleRequest.pseudoId))</span>
<span class="udiff-line-modified-added">+     if (pseudoElementRequest.pseudoId &lt; PseudoId::FirstInternalPseudoId &amp;&amp; !ownStyle &amp;&amp; !style().hasPseudoStyle(pseudoElementRequest.pseudoId))</span>
          return nullptr;
  
      if (!parentStyle) {
          ASSERT(!ownStyle);
          parentStyle = &amp;style();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1377,11 +1376,11 @@</span>
      if (isAnonymous())
          return nullptr;
  
      auto&amp; styleResolver = element()-&gt;styleResolver();
  
<span class="udiff-line-modified-removed">-     std::unique_ptr&lt;RenderStyle&gt; style = styleResolver.pseudoStyleForElement(*element(), pseudoStyleRequest, *parentStyle);</span>
<span class="udiff-line-modified-added">+     std::unique_ptr&lt;RenderStyle&gt; style = styleResolver.pseudoStyleForElement(*element(), pseudoElementRequest, *parentStyle);</span>
  
      if (style)
          Style::loadPendingResources(*style, document(), element());
  
      return style;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1412,16 +1411,21 @@</span>
      if (isAnonymous())
          return nullptr;
  
      if (ShadowRoot* root = element()-&gt;containingShadowRoot()) {
          if (root-&gt;mode() == ShadowRootMode::UserAgent) {
<span class="udiff-line-modified-removed">-             if (Element* shadowHost = element()-&gt;shadowHost())</span>
<span class="udiff-line-modified-removed">-                 return shadowHost-&gt;renderer()-&gt;getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::Selection));</span>
<span class="udiff-line-modified-added">+             auto* currentElement = element()-&gt;shadowHost();</span>
<span class="udiff-line-modified-added">+             // When an element has display: contents, this element doesn&#39;t have a renderer</span>
<span class="udiff-line-added">+             // and its children will render as children of the parent element.</span>
<span class="udiff-line-added">+             while (currentElement &amp;&amp; currentElement-&gt;hasDisplayContents())</span>
<span class="udiff-line-added">+                 currentElement = currentElement-&gt;parentElement();</span>
<span class="udiff-line-added">+             if (currentElement &amp;&amp; currentElement-&gt;renderer())</span>
<span class="udiff-line-added">+                 return currentElement-&gt;renderer()-&gt;getUncachedPseudoStyle({ PseudoId::Selection });</span>
          }
      }
  
<span class="udiff-line-modified-removed">-     return getUncachedPseudoStyle(PseudoStyleRequest(PseudoId::Selection));</span>
<span class="udiff-line-modified-added">+     return getUncachedPseudoStyle({ PseudoId::Selection });</span>
  }
  
  Color RenderElement::selectionForegroundColor() const
  {
      return selectionColor(CSSPropertyWebkitTextFillColor);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2031,11 +2035,11 @@</span>
      }
  }
  
  bool RenderElement::hasOutlineAnnotation() const
  {
<span class="udiff-line-modified-removed">-     return element() &amp;&amp; element()-&gt;isLink() &amp;&amp; document().printing();</span>
<span class="udiff-line-modified-added">+     return element() &amp;&amp; element()-&gt;isLink() &amp;&amp; (document().printing() || (view().frameView().paintBehavior() &amp; PaintBehavior::AnnotateLinks));</span>
  }
  
  bool RenderElement::hasSelfPaintingLayer() const
  {
      if (!hasLayer())
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2051,19 +2055,10 @@</span>
      return !settings().repaintOutsideLayoutEnabled();
  }
  
  ImageOrientation RenderElement::imageOrientation() const
  {
<span class="udiff-line-removed">- #if USE(CG) || USE(CAIRO) || USE(DIRECT2D)</span>
<span class="udiff-line-removed">-     // This can only be enabled for ports which honor the orientation flag in their drawing code.</span>
<span class="udiff-line-removed">-     if (document().isImageDocument())</span>
<span class="udiff-line-removed">-         return ImageOrientation::FromImage;</span>
<span class="udiff-line-removed">- #endif</span>
<span class="udiff-line-removed">-     // Respect the image&#39;s orientation if it&#39;s being used as a full-page image or it&#39;s</span>
<span class="udiff-line-removed">-     // an &lt;img&gt; and the setting to respect it everywhere is set.</span>
<span class="udiff-line-removed">-     if (settings().shouldRespectImageOrientation() &amp;&amp; is&lt;HTMLImageElement&gt;(element()))</span>
<span class="udiff-line-removed">-         return ImageOrientation::FromImage;</span>
      return style().imageOrientation();
  }
  
  void RenderElement::adjustFragmentedFlowStateOnContainingBlockChangeIfNeeded()
  {
</pre>
<center><a href="RenderDeprecatedFlexibleBox.cpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderElement.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
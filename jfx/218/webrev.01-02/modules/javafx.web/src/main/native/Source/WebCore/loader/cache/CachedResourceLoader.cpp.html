<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResourceLoader.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2     Copyright (C) 1998 Lars Knoll (knoll@mpi-hd.mpg.de)
   3     Copyright (C) 2001 Dirk Mueller (mueller@kde.org)
   4     Copyright (C) 2002 Waldo Bastian (bastian@kde.org)
   5     Copyright (C) 2004-2017 Apple Inc. All rights reserved.
   6     Copyright (C) 2009 Torch Mobile Inc. http://www.torchmobile.com/
   7 
   8     This library is free software; you can redistribute it and/or
   9     modify it under the terms of the GNU Library General Public
  10     License as published by the Free Software Foundation; either
  11     version 2 of the License, or (at your option) any later version.
  12 
  13     This library is distributed in the hope that it will be useful,
  14     but WITHOUT ANY WARRANTY; without even the implied warranty of
  15     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  16     Library General Public License for more details.
  17 
  18     You should have received a copy of the GNU Library General Public License
  19     along with this library; see the file COPYING.LIB.  If not, write to
  20     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  21     Boston, MA 02110-1301, USA.
  22 
  23     This class provides all functionality needed for loading images, style sheets and html
  24     pages from the web. It has a memory cache for these objects.
  25 */
  26 
  27 #include &quot;config.h&quot;
  28 #include &quot;CachedResourceLoader.h&quot;
  29 
  30 #include &quot;CachedCSSStyleSheet.h&quot;
  31 #include &quot;CachedFont.h&quot;
  32 #include &quot;CachedImage.h&quot;
  33 #include &quot;CachedRawResource.h&quot;
  34 #include &quot;CachedResourceRequest.h&quot;
  35 #include &quot;CachedSVGDocument.h&quot;
  36 #include &quot;CachedSVGFont.h&quot;
  37 #include &quot;CachedScript.h&quot;
  38 #include &quot;CachedXSLStyleSheet.h&quot;
  39 #include &quot;Chrome.h&quot;
  40 #include &quot;ChromeClient.h&quot;
  41 #include &quot;ContentExtensionError.h&quot;
  42 #include &quot;ContentExtensionRule.h&quot;
  43 #include &quot;ContentRuleListResults.h&quot;
  44 #include &quot;ContentSecurityPolicy.h&quot;
  45 #include &quot;CrossOriginAccessControl.h&quot;
  46 #include &quot;CustomHeaderFields.h&quot;
  47 #include &quot;DOMWindow.h&quot;
  48 #include &quot;DateComponents.h&quot;
  49 #include &quot;DiagnosticLoggingClient.h&quot;
  50 #include &quot;DiagnosticLoggingKeys.h&quot;
  51 #include &quot;Document.h&quot;
  52 #include &quot;DocumentLoader.h&quot;
  53 #include &quot;Frame.h&quot;
  54 #include &quot;FrameLoader.h&quot;
  55 #include &quot;FrameLoaderClient.h&quot;
  56 #include &quot;HTMLElement.h&quot;
  57 #include &quot;HTMLFrameOwnerElement.h&quot;
  58 #include &quot;HTTPHeaderField.h&quot;
  59 #include &quot;InspectorInstrumentation.h&quot;
  60 #include &quot;LoaderStrategy.h&quot;
  61 #include &quot;LocalizedStrings.h&quot;
  62 #include &quot;Logging.h&quot;
  63 #include &quot;MemoryCache.h&quot;
  64 #include &quot;Page.h&quot;
  65 #include &quot;PingLoader.h&quot;
  66 #include &quot;PlatformStrategies.h&quot;
  67 #include &quot;RenderElement.h&quot;
  68 #include &quot;ResourceLoadInfo.h&quot;
  69 #include &quot;ResourceTiming.h&quot;
  70 #include &quot;RuntimeApplicationChecks.h&quot;
  71 #include &quot;RuntimeEnabledFeatures.h&quot;
  72 #include &quot;ScriptController.h&quot;
  73 #include &quot;SecurityOrigin.h&quot;
  74 #include &quot;SecurityPolicy.h&quot;
  75 #include &quot;ServiceWorker.h&quot;
  76 #include &quot;Settings.h&quot;
  77 #include &quot;StyleSheetContents.h&quot;
  78 #include &quot;SubresourceLoader.h&quot;
  79 #include &quot;UserContentController.h&quot;
  80 #include &quot;UserStyleSheet.h&quot;
  81 #include &lt;pal/SessionID.h&gt;
  82 #include &lt;wtf/text/CString.h&gt;
  83 #include &lt;wtf/text/WTFString.h&gt;
  84 
  85 #if ENABLE(APPLICATION_MANIFEST)
  86 #include &quot;CachedApplicationManifest.h&quot;
  87 #endif
  88 
  89 #if ENABLE(VIDEO_TRACK)
  90 #include &quot;CachedTextTrack.h&quot;
  91 #endif
  92 
  93 #if PLATFORM(IOS_FAMILY)
  94 #include &quot;Device.h&quot;
  95 #endif
  96 
  97 #undef RELEASE_LOG_IF_ALLOWED
  98 #define RELEASE_LOG_IF_ALLOWED(fmt, ...) RELEASE_LOG_IF(isAlwaysOnLoggingAllowed(), Network, &quot;%p - CachedResourceLoader::&quot; fmt, this, ##__VA_ARGS__)
  99 
 100 namespace WebCore {
 101 
 102 // Timeout for link preloads to be used after window.onload
 103 static const Seconds unusedPreloadTimeout { 3_s };
 104 
 105 template &lt;typename T, typename U&gt;
 106 static inline ResourceErrorOr&lt;CachedResourceHandle&lt;T&gt;&gt; castCachedResourceTo(ResourceErrorOr&lt;CachedResourceHandle&lt;U&gt;&gt;&amp;&amp; cachedResource)
 107 {
 108     if (cachedResource)
 109         return CachedResourceHandle&lt;T&gt; { static_cast&lt;T*&gt;(cachedResource.value().get()) };
 110     return makeUnexpected(cachedResource.error());
 111 }
 112 
 113 static CachedResource* createResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 114 {
 115     switch (type) {
 116     case CachedResource::Type::ImageResource:
 117         return new CachedImage(WTFMove(request), sessionID, cookieJar);
 118     case CachedResource::Type::CSSStyleSheet:
 119         return new CachedCSSStyleSheet(WTFMove(request), sessionID, cookieJar);
 120     case CachedResource::Type::Script:
 121         return new CachedScript(WTFMove(request), sessionID, cookieJar);
 122     case CachedResource::Type::SVGDocumentResource:
 123         return new CachedSVGDocument(WTFMove(request), sessionID, cookieJar);
 124 #if ENABLE(SVG_FONTS)
 125     case CachedResource::Type::SVGFontResource:
 126         return new CachedSVGFont(WTFMove(request), sessionID, cookieJar);
 127 #endif
 128     case CachedResource::Type::FontResource:
 129         return new CachedFont(WTFMove(request), sessionID, cookieJar);
 130     case CachedResource::Type::Beacon:
 131     case CachedResource::Type::Ping:
 132     case CachedResource::Type::MediaResource:
 133     case CachedResource::Type::RawResource:
 134     case CachedResource::Type::Icon:
 135     case CachedResource::Type::MainResource:
 136         return new CachedRawResource(WTFMove(request), type, sessionID, cookieJar);
 137 #if ENABLE(XSLT)
 138     case CachedResource::Type::XSLStyleSheet:
 139         return new CachedXSLStyleSheet(WTFMove(request), sessionID, cookieJar);
 140 #endif
 141     case CachedResource::Type::LinkPrefetch:
 142         return new CachedResource(WTFMove(request), CachedResource::Type::LinkPrefetch, sessionID, cookieJar);
 143 #if ENABLE(VIDEO_TRACK)
 144     case CachedResource::Type::TextTrackResource:
 145         return new CachedTextTrack(WTFMove(request), sessionID, cookieJar);
 146 #endif
 147 #if ENABLE(APPLICATION_MANIFEST)
 148     case CachedResource::Type::ApplicationManifest:
 149         return new CachedApplicationManifest(WTFMove(request), sessionID, cookieJar);
 150 #endif
 151     }
 152     ASSERT_NOT_REACHED();
 153     return nullptr;
 154 }
 155 
 156 CachedResourceLoader::CachedResourceLoader(DocumentLoader* documentLoader)
 157     : m_document(nullptr)
 158     , m_documentLoader(documentLoader)
 159     , m_requestCount(0)
 160     , m_unusedPreloadsTimer(*this, &amp;CachedResourceLoader::warnUnusedPreloads)
 161     , m_garbageCollectDocumentResourcesTimer(*this, &amp;CachedResourceLoader::garbageCollectDocumentResources)
 162     , m_autoLoadImages(true)
 163     , m_imagesEnabled(true)
 164     , m_allowStaleResources(false)
 165 {
 166 }
 167 
 168 CachedResourceLoader::~CachedResourceLoader()
 169 {
 170     m_documentLoader = nullptr;
 171     m_document = nullptr;
 172 
 173     clearPreloads(ClearPreloadsMode::ClearAllPreloads);
 174 
 175     // Make sure no requests still point to this CachedResourceLoader
 176     ASSERT(m_requestCount == 0);
 177     m_unusedPreloadsTimer.stop();
 178 }
 179 
 180 CachedResource* CachedResourceLoader::cachedResource(const String&amp; resourceURL) const
 181 {
 182     ASSERT(!resourceURL.isNull());
 183     return cachedResource(MemoryCache::removeFragmentIdentifierIfNeeded(m_document-&gt;completeURL(resourceURL)));
 184 }
 185 
 186 CachedResource* CachedResourceLoader::cachedResource(const URL&amp; url) const
 187 {
 188     ASSERT(!MemoryCache::shouldRemoveFragmentIdentifier(url));
 189     return m_documentResources.get(url).get();
 190 }
 191 
 192 Frame* CachedResourceLoader::frame() const
 193 {
 194     return m_documentLoader ? m_documentLoader-&gt;frame() : nullptr;
 195 }
 196 
 197 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedImage&gt;&gt; CachedResourceLoader::requestImage(CachedResourceRequest&amp;&amp; request)
 198 {
 199     if (Frame* frame = this-&gt;frame()) {
 200         if (frame-&gt;loader().pageDismissalEventBeingDispatched() != FrameLoader::PageDismissalType::None) {
 201             if (Document* document = frame-&gt;document())
 202                 request.upgradeInsecureRequestIfNeeded(*document);
 203             URL requestURL = request.resourceRequest().url();
 204             if (requestURL.isValid() &amp;&amp; canRequest(CachedResource::Type::ImageResource, requestURL, request, ForPreload::No))
 205                 PingLoader::loadImage(*frame, requestURL);
 206             return CachedResourceHandle&lt;CachedImage&gt; { };
 207         }
 208     }
 209 
 210     auto defer = clientDefersImage(request.resourceRequest().url()) ? DeferOption::DeferredByClient : DeferOption::NoDefer;
 211     return castCachedResourceTo&lt;CachedImage&gt;(requestResource(CachedResource::Type::ImageResource, WTFMove(request), ForPreload::No, defer));
 212 }
 213 
 214 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedFont&gt;&gt; CachedResourceLoader::requestFont(CachedResourceRequest&amp;&amp; request, bool isSVG)
 215 {
 216 #if ENABLE(SVG_FONTS)
 217     if (isSVG)
 218         return castCachedResourceTo&lt;CachedFont&gt;(requestResource(CachedResource::Type::SVGFontResource, WTFMove(request)));
 219 #else
 220     UNUSED_PARAM(isSVG);
 221 #endif
 222     return castCachedResourceTo&lt;CachedFont&gt;(requestResource(CachedResource::Type::FontResource, WTFMove(request)));
 223 }
 224 
 225 #if ENABLE(VIDEO_TRACK)
 226 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedTextTrack&gt;&gt; CachedResourceLoader::requestTextTrack(CachedResourceRequest&amp;&amp; request)
 227 {
 228     return castCachedResourceTo&lt;CachedTextTrack&gt;(requestResource(CachedResource::Type::TextTrackResource, WTFMove(request)));
 229 }
 230 #endif
 231 
 232 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedCSSStyleSheet&gt;&gt; CachedResourceLoader::requestCSSStyleSheet(CachedResourceRequest&amp;&amp; request)
 233 {
 234     return castCachedResourceTo&lt;CachedCSSStyleSheet&gt;(requestResource(CachedResource::Type::CSSStyleSheet, WTFMove(request)));
 235 }
 236 
 237 CachedResourceHandle&lt;CachedCSSStyleSheet&gt; CachedResourceLoader::requestUserCSSStyleSheet(Page&amp; page, CachedResourceRequest&amp;&amp; request)
 238 {
 239     request.setDestinationIfNotSet(FetchOptions::Destination::Style);
 240 
 241     ASSERT(document());
 242     request.setDomainForCachePartition(*document());
 243 
 244     auto&amp; memoryCache = MemoryCache::singleton();
 245     if (request.allowsCaching()) {
 246         if (CachedResource* existing = memoryCache.resourceForRequest(request.resourceRequest(), page.sessionID())) {
 247             if (is&lt;CachedCSSStyleSheet&gt;(*existing))
 248                 return downcast&lt;CachedCSSStyleSheet&gt;(existing);
 249             memoryCache.remove(*existing);
 250         }
 251     }
 252 
 253     request.removeFragmentIdentifierIfNeeded();
 254 
 255     CachedResourceHandle&lt;CachedCSSStyleSheet&gt; userSheet = new CachedCSSStyleSheet(WTFMove(request), page.sessionID(), &amp;page.cookieJar());
 256 
 257     if (userSheet-&gt;allowsCaching())
 258         memoryCache.add(*userSheet);
 259 
 260     userSheet-&gt;load(*this);
 261     return userSheet;
 262 }
 263 
 264 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedScript&gt;&gt; CachedResourceLoader::requestScript(CachedResourceRequest&amp;&amp; request)
 265 {
 266     return castCachedResourceTo&lt;CachedScript&gt;(requestResource(CachedResource::Type::Script, WTFMove(request)));
 267 }
 268 
 269 #if ENABLE(XSLT)
 270 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedXSLStyleSheet&gt;&gt; CachedResourceLoader::requestXSLStyleSheet(CachedResourceRequest&amp;&amp; request)
 271 {
 272     return castCachedResourceTo&lt;CachedXSLStyleSheet&gt;(requestResource(CachedResource::Type::XSLStyleSheet, WTFMove(request)));
 273 }
 274 #endif
 275 
 276 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedSVGDocument&gt;&gt; CachedResourceLoader::requestSVGDocument(CachedResourceRequest&amp;&amp; request)
 277 {
 278     return castCachedResourceTo&lt;CachedSVGDocument&gt;(requestResource(CachedResource::Type::SVGDocumentResource, WTFMove(request)));
 279 }
 280 
 281 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::requestLinkResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request)
 282 {
 283     ASSERT(frame());
 284     ASSERT(type == CachedResource::Type::LinkPrefetch);
 285     return requestResource(type, WTFMove(request));
 286 }
 287 
 288 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestMedia(CachedResourceRequest&amp;&amp; request)
 289 {
 290     // FIXME: Assert request.options().destination is FetchOptions::Destination::{Audio, Video}.
 291     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::MediaResource, WTFMove(request)));
 292 }
 293 
 294 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestIcon(CachedResourceRequest&amp;&amp; request)
 295 {
 296     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::Icon, WTFMove(request)));
 297 }
 298 
 299 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestRawResource(CachedResourceRequest&amp;&amp; request)
 300 {
 301     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::RawResource, WTFMove(request)));
 302 }
 303 
 304 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestBeaconResource(CachedResourceRequest&amp;&amp; request)
 305 {
 306     ASSERT(request.options().destination == FetchOptions::Destination::EmptyString);
 307     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::Beacon, WTFMove(request)));
 308 }
 309 
 310 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestPingResource(CachedResourceRequest&amp;&amp; request)
 311 {
 312     ASSERT(request.options().destination == FetchOptions::Destination::EmptyString);
 313     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::Ping, WTFMove(request)));
 314 }
 315 
 316 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedRawResource&gt;&gt; CachedResourceLoader::requestMainResource(CachedResourceRequest&amp;&amp; request)
 317 {
 318     return castCachedResourceTo&lt;CachedRawResource&gt;(requestResource(CachedResource::Type::MainResource, WTFMove(request)));
 319 }
 320 
 321 #if ENABLE(APPLICATION_MANIFEST)
 322 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedApplicationManifest&gt;&gt; CachedResourceLoader::requestApplicationManifest(CachedResourceRequest&amp;&amp; request)
 323 {
 324     return castCachedResourceTo&lt;CachedApplicationManifest&gt;(requestResource(CachedResource::Type::ApplicationManifest, WTFMove(request)));
 325 }
 326 #endif // ENABLE(APPLICATION_MANIFEST)
 327 
 328 static MixedContentChecker::ContentType contentTypeFromResourceType(CachedResource::Type type)
 329 {
 330     switch (type) {
 331     // https://w3c.github.io/webappsec-mixed-content/#category-optionally-blockable
 332     // Editor&#39;s Draft, 11 February 2016
 333     // 3.1. Optionally-blockable Content
 334     case CachedResource::Type::ImageResource:
 335     case CachedResource::Type::MediaResource:
 336             return MixedContentChecker::ContentType::ActiveCanWarn;
 337 
 338     case CachedResource::Type::CSSStyleSheet:
 339     case CachedResource::Type::Script:
 340     case CachedResource::Type::FontResource:
 341         return MixedContentChecker::ContentType::Active;
 342 
 343 #if ENABLE(SVG_FONTS)
 344     case CachedResource::Type::SVGFontResource:
 345         return MixedContentChecker::ContentType::Active;
 346 #endif
 347 
 348     case CachedResource::Type::Beacon:
 349     case CachedResource::Type::Ping:
 350     case CachedResource::Type::RawResource:
 351     case CachedResource::Type::Icon:
 352     case CachedResource::Type::SVGDocumentResource:
 353         return MixedContentChecker::ContentType::Active;
 354 #if ENABLE(XSLT)
 355     case CachedResource::Type::XSLStyleSheet:
 356         return MixedContentChecker::ContentType::Active;
 357 #endif
 358 
 359     case CachedResource::Type::LinkPrefetch:
 360         return MixedContentChecker::ContentType::Active;
 361 
 362 #if ENABLE(VIDEO_TRACK)
 363     case CachedResource::Type::TextTrackResource:
 364         return MixedContentChecker::ContentType::Active;
 365 #endif
 366 #if ENABLE(APPLICATION_MANIFEST)
 367     case CachedResource::Type::ApplicationManifest:
 368         return MixedContentChecker::ContentType::Active;
 369 #endif
 370     default:
 371         ASSERT_NOT_REACHED();
 372         return MixedContentChecker::ContentType::Active;
 373     }
 374 }
 375 
 376 bool CachedResourceLoader::checkInsecureContent(CachedResource::Type type, const URL&amp; url) const
 377 {
 378     if (!canRequestInContentDispositionAttachmentSandbox(type, url))
 379         return false;
 380 
 381     switch (type) {
 382     case CachedResource::Type::Script:
 383 #if ENABLE(XSLT)
 384     case CachedResource::Type::XSLStyleSheet:
 385 #endif
 386     case CachedResource::Type::SVGDocumentResource:
 387     case CachedResource::Type::CSSStyleSheet:
 388         // These resource can inject script into the current document (Script,
 389         // XSL) or exfiltrate the content of the current document (CSS).
 390         if (Frame* frame = this-&gt;frame()) {
 391             if (!frame-&gt;loader().mixedContentChecker().canRunInsecureContent(m_document-&gt;securityOrigin(), url))
 392                 return false;
 393             Frame&amp; top = frame-&gt;tree().top();
 394             if (&amp;top != frame &amp;&amp; !top.loader().mixedContentChecker().canRunInsecureContent(top.document()-&gt;securityOrigin(), url))
 395                 return false;
 396         }
 397         break;
 398 #if ENABLE(VIDEO_TRACK)
 399     case CachedResource::Type::TextTrackResource:
 400 #endif
 401     case CachedResource::Type::MediaResource:
 402     case CachedResource::Type::RawResource:
 403     case CachedResource::Type::Icon:
 404     case CachedResource::Type::ImageResource:
 405 #if ENABLE(SVG_FONTS)
 406     case CachedResource::Type::SVGFontResource:
 407 #endif
 408     case CachedResource::Type::FontResource: {
 409         // These resources can corrupt only the frame&#39;s pixels.
 410         if (Frame* frame = this-&gt;frame()) {
 411             if (!frame-&gt;loader().mixedContentChecker().canDisplayInsecureContent(m_document-&gt;securityOrigin(), contentTypeFromResourceType(type), url, MixedContentChecker::AlwaysDisplayInNonStrictMode::Yes))
 412                 return false;
 413             Frame&amp; topFrame = frame-&gt;tree().top();
 414             if (!topFrame.loader().mixedContentChecker().canDisplayInsecureContent(topFrame.document()-&gt;securityOrigin(), contentTypeFromResourceType(type), url))
 415                 return false;
 416         }
 417         break;
 418     }
 419     case CachedResource::Type::MainResource:
 420     case CachedResource::Type::Beacon:
 421     case CachedResource::Type::Ping:
 422     case CachedResource::Type::LinkPrefetch:
 423         // Prefetch cannot affect the current document.
 424 #if ENABLE(APPLICATION_MANIFEST)
 425     case CachedResource::Type::ApplicationManifest:
 426 #endif
 427         break;
 428     }
 429     return true;
 430 }
 431 
 432 bool CachedResourceLoader::allowedByContentSecurityPolicy(CachedResource::Type type, const URL&amp; url, const ResourceLoaderOptions&amp; options, ContentSecurityPolicy::RedirectResponseReceived redirectResponseReceived) const
 433 {
 434     if (options.contentSecurityPolicyImposition == ContentSecurityPolicyImposition::SkipPolicyCheck)
 435         return true;
 436 
 437     ASSERT(m_document);
 438     ASSERT(m_document-&gt;contentSecurityPolicy());
 439 
 440     switch (type) {
 441 #if ENABLE(XSLT)
 442     case CachedResource::Type::XSLStyleSheet:
 443 #endif
 444     case CachedResource::Type::Script:
 445         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowScriptFromSource(url, redirectResponseReceived))
 446             return false;
 447         break;
 448     case CachedResource::Type::CSSStyleSheet:
 449         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowStyleFromSource(url, redirectResponseReceived))
 450             return false;
 451         break;
 452     case CachedResource::Type::SVGDocumentResource:
 453     case CachedResource::Type::Icon:
 454     case CachedResource::Type::ImageResource:
 455         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowImageFromSource(url, redirectResponseReceived))
 456             return false;
 457         break;
 458 #if ENABLE(SVG_FONTS)
 459     case CachedResource::Type::SVGFontResource:
 460 #endif
 461     case CachedResource::Type::FontResource:
 462         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowFontFromSource(url, redirectResponseReceived))
 463             return false;
 464         break;
 465     case CachedResource::Type::MediaResource:
 466 #if ENABLE(VIDEO_TRACK)
 467     case CachedResource::Type::TextTrackResource:
 468 #endif
 469         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowMediaFromSource(url, redirectResponseReceived))
 470             return false;
 471         break;
 472     case CachedResource::Type::Beacon:
 473     case CachedResource::Type::Ping:
 474     case CachedResource::Type::RawResource:
 475         return true;
 476 #if ENABLE(APPLICATION_MANIFEST)
 477     case CachedResource::Type::ApplicationManifest:
 478         if (!m_document-&gt;contentSecurityPolicy()-&gt;allowManifestFromSource(url, redirectResponseReceived))
 479             return false;
 480         break;
 481 #endif
 482     default:
 483         ASSERT_NOT_REACHED();
 484     }
 485 
 486     return true;
 487 }
 488 
 489 static inline bool isSameOriginDataURL(const URL&amp; url, const ResourceLoaderOptions&amp; options)
 490 {
 491     // FIXME: Remove same-origin data URL flag since it was removed from fetch spec (https://github.com/whatwg/fetch/issues/381).
 492     return url.protocolIsData() &amp;&amp; options.sameOriginDataURLFlag == SameOriginDataURLFlag::Set;
 493 }
 494 
 495 // Security checks defined in https://fetch.spec.whatwg.org/#main-fetch step 2 and 5.
 496 bool CachedResourceLoader::canRequest(CachedResource::Type type, const URL&amp; url, const CachedResourceRequest&amp; request, ForPreload forPreload)
 497 {
 498     auto&amp; options = request.options();
 499 
 500     if (document() &amp;&amp; !document()-&gt;securityOrigin().canDisplay(url)) {
 501         if (forPreload == ForPreload::No)
 502             FrameLoader::reportLocalLoadFailed(frame(), url.stringCenterEllipsizedToLength());
 503         LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource URL was not allowed by SecurityOrigin::canDisplay&quot;);
 504         return false;
 505     }
 506 
 507     if (options.mode == FetchOptions::Mode::SameOrigin &amp;&amp; !m_document-&gt;securityOrigin().canRequest(url) &amp;&amp; !isSameOriginDataURL(url, options)) {
 508         printAccessDeniedMessage(url);
 509         return false;
 510     }
 511 
 512     if (options.mode == FetchOptions::Mode::NoCors &amp;&amp; !m_document-&gt;securityOrigin().canRequest(url) &amp;&amp; options.redirect != FetchOptions::Redirect::Follow &amp;&amp; type != CachedResource::Type::Ping) {
 513         ASSERT(type != CachedResource::Type::MainResource);
 514         frame()-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, &quot;No-Cors mode requires follow redirect mode&quot;_s);
 515         return false;
 516     }
 517 
 518     if (!allowedByContentSecurityPolicy(type, url, options, ContentSecurityPolicy::RedirectResponseReceived::No))
 519         return false;
 520 
 521     // SVG Images have unique security rules that prevent all subresource requests except for data urls.
 522     if (type != CachedResource::Type::MainResource &amp;&amp; frame() &amp;&amp; frame()-&gt;page()) {
 523         if (frame()-&gt;page()-&gt;chrome().client().isSVGImageChromeClient() &amp;&amp; !url.protocolIsData())
 524             return false;
 525     }
 526 
 527     // Last of all, check for insecure content. We do this last so that when folks block insecure content with a CSP policy, they don&#39;t get a warning.
 528     // They&#39;ll still get a warning in the console about CSP blocking the load.
 529 
 530     // FIXME: Should we consider whether the request is for preload here?
 531     if (!checkInsecureContent(type, url))
 532         return false;
 533 
 534     return true;
 535 }
 536 
 537 // FIXME: Should we find a way to know whether the redirection is for a preload request like we do for CachedResourceLoader::canRequest?
 538 bool CachedResourceLoader::canRequestAfterRedirection(CachedResource::Type type, const URL&amp; url, const ResourceLoaderOptions&amp; options) const
 539 {
 540     if (document() &amp;&amp; !document()-&gt;securityOrigin().canDisplay(url)) {
 541         FrameLoader::reportLocalLoadFailed(frame(), url.stringCenterEllipsizedToLength());
 542         LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource URL was not allowed by SecurityOrigin::canDisplay&quot;);
 543         return false;
 544     }
 545 
 546     // FIXME: According to https://fetch.spec.whatwg.org/#http-redirect-fetch, we should check that the URL is HTTP(s) except if in navigation mode.
 547     // But we currently allow at least data URLs to be loaded.
 548 
 549     if (options.mode == FetchOptions::Mode::SameOrigin &amp;&amp; !m_document-&gt;securityOrigin().canRequest(url)) {
 550         printAccessDeniedMessage(url);
 551         return false;
 552     }
 553 
 554     if (!allowedByContentSecurityPolicy(type, url, options, ContentSecurityPolicy::RedirectResponseReceived::Yes))
 555         return false;
 556 
 557     // Last of all, check for insecure content. We do this last so that when folks block insecure content with a CSP policy, they don&#39;t get a warning.
 558     // They&#39;ll still get a warning in the console about CSP blocking the load.
 559     if (!checkInsecureContent(type, url))
 560         return false;
 561 
 562     return true;
 563 }
 564 
 565 bool CachedResourceLoader::updateRequestAfterRedirection(CachedResource::Type type, ResourceRequest&amp; request, const ResourceLoaderOptions&amp; options)
 566 {
 567     ASSERT(m_documentLoader);
 568     if (auto* document = m_documentLoader-&gt;cachedResourceLoader().document())
 569         upgradeInsecureResourceRequestIfNeeded(request, *document);
 570 
 571     // FIXME: We might want to align the checks done here with the ones done in CachedResourceLoader::requestResource, content extensions blocking in particular.
 572 
 573     return canRequestAfterRedirection(type, request.url(), options);
 574 }
 575 
 576 bool CachedResourceLoader::canRequestInContentDispositionAttachmentSandbox(CachedResource::Type type, const URL&amp; url) const
 577 {
 578     Document* document;
 579 
 580     // FIXME: Do we want to expand this to all resource types that the mixed content checker would consider active content?
 581     switch (type) {
 582     case CachedResource::Type::MainResource:
 583         if (auto ownerElement = frame() ? frame()-&gt;ownerElement() : nullptr) {
 584             document = &amp;ownerElement-&gt;document();
 585             break;
 586         }
 587         return true;
 588     case CachedResource::Type::CSSStyleSheet:
 589         document = m_document.get();
 590         break;
 591     default:
 592         return true;
 593     }
 594 
 595     if (!document-&gt;shouldEnforceContentDispositionAttachmentSandbox() || document-&gt;securityOrigin().canRequest(url))
 596         return true;
 597 
 598     String message = &quot;Unsafe attempt to load URL &quot; + url.stringCenterEllipsizedToLength() + &quot; from document with Content-Disposition: attachment at URL &quot; + document-&gt;url().stringCenterEllipsizedToLength() + &quot;.&quot;;
 599     document-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
 600     return false;
 601 }
 602 
 603 bool CachedResourceLoader::shouldContinueAfterNotifyingLoadedFromMemoryCache(const CachedResourceRequest&amp; request, CachedResource&amp; resource, ResourceError&amp; error)
 604 {
 605     if (!frame() || resource.status() != CachedResource::Cached)
 606         return true;
 607 
 608     ResourceRequest newRequest = ResourceRequest(resource.url());
 609     newRequest.setInitiatorIdentifier(request.resourceRequest().initiatorIdentifier());
 610     if (auto inspectorInitiatorNodeIdentifier = request.resourceRequest().inspectorInitiatorNodeIdentifier())
 611         newRequest.setInspectorInitiatorNodeIdentifier(*inspectorInitiatorNodeIdentifier);
 612     if (request.resourceRequest().hiddenFromInspector())
 613         newRequest.setHiddenFromInspector(true);
 614     frame()-&gt;loader().loadedResourceFromMemoryCache(resource, newRequest, error);
 615 
 616     // FIXME &lt;http://webkit.org/b/113251&gt;: If the delegate modifies the request&#39;s
 617     // URL, it is no longer appropriate to use this CachedResource.
 618     return !newRequest.isNull();
 619 }
 620 
 621 bool CachedResourceLoader::shouldUpdateCachedResourceWithCurrentRequest(const CachedResource&amp; resource, const CachedResourceRequest&amp; request)
 622 {
 623     // WebKit is not supporting CORS for fonts (https://bugs.webkit.org/show_bug.cgi?id=86817), no need to update the resource before reusing it.
 624     if (resource.type() == CachedResource::Type::FontResource)
 625         return false;
 626 
 627 #if ENABLE(SVG_FONTS)
 628     if (resource.type() == CachedResource::Type::SVGFontResource)
 629         return false;
 630 #endif
 631 
 632 #if ENABLE(XSLT)
 633     // Load is same-origin, we do not check for CORS.
 634     if (resource.type() == CachedResource::Type::XSLStyleSheet)
 635         return false;
 636 #endif
 637 
 638     // FIXME: We should enable resource reuse for these resource types
 639     switch (resource.type()) {
 640     case CachedResource::Type::SVGDocumentResource:
 641         return false;
 642     case CachedResource::Type::MainResource:
 643         return false;
 644     case CachedResource::Type::LinkPrefetch:
 645         return false;
 646     default:
 647         break;
 648     }
 649 
 650     if (resource.options().mode != request.options().mode || !serializedOriginsMatch(request.origin(), resource.origin()))
 651         return true;
 652 
 653     if (resource.options().redirect != request.options().redirect &amp;&amp; resource.hasRedirections())
 654         return true;
 655 
 656     return false;
 657 }
 658 
 659 static inline bool isResourceSuitableForDirectReuse(const CachedResource&amp; resource, const CachedResourceRequest&amp; request)
 660 {
 661     // FIXME: For being loaded requests, the response tainting may not be correctly computed if the fetch mode is not the same.
 662     // Even if the fetch mode is the same, we are not sure that the resource can be reused (Vary: Origin header for instance).
 663     // We should find a way to improve this.
 664     if (resource.status() != CachedResource::Cached)
 665         return false;
 666 
 667     // If the cached resource has not followed redirections, it is incomplete and we should not use it.
 668     // Let&#39;s make sure the memory cache has no such resource.
 669     ASSERT(resource.response().type() != ResourceResponse::Type::Opaqueredirect);
 670 
 671     // We could support redirect modes other than Follow in case of a redirected resource.
 672     // This case is rare and is not worth optimizing currently.
 673     if (request.options().redirect != FetchOptions::Redirect::Follow &amp;&amp; resource.hasRedirections())
 674         return false;
 675 
 676     // FIXME: Implement reuse of cached raw resources.
 677     if (resource.type() == CachedResource::Type::RawResource || resource.type() == CachedResource::Type::MediaResource)
 678         return false;
 679 
 680     if (resource.type() == CachedResource::Type::Beacon || resource.type() == CachedResource::Type::Ping)
 681         return false;
 682 
 683     return true;
 684 }
 685 
 686 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::updateCachedResourceWithCurrentRequest(const CachedResource&amp; resource, CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar&amp; cookieJar)
 687 {
 688     if (!isResourceSuitableForDirectReuse(resource, request)) {
 689         request.setCachingPolicy(CachingPolicy::DisallowCaching);
 690         return loadResource(resource.type(), sessionID, WTFMove(request), cookieJar);
 691     }
 692 
 693     auto resourceHandle = createResource(resource.type(), WTFMove(request), sessionID, &amp;cookieJar);
 694     resourceHandle-&gt;loadFrom(resource);
 695     return resourceHandle;
 696 }
 697 
 698 static inline void logMemoryCacheResourceRequest(Frame* frame, const String&amp; key, const String&amp; description)
 699 {
 700     if (!frame || !frame-&gt;page())
 701         return;
 702     frame-&gt;page()-&gt;diagnosticLoggingClient().logDiagnosticMessage(key, description, ShouldSample::Yes);
 703 }
 704 
 705 void CachedResourceLoader::prepareFetch(CachedResource::Type type, CachedResourceRequest&amp; request)
 706 {
 707     // Implementing step 1 to 7 of https://fetch.spec.whatwg.org/#fetching
 708     auto* document = this-&gt;document();
 709 
 710     if (document) {
 711         if (!request.origin())
 712             request.setOrigin(document-&gt;securityOrigin());
 713 #if ENABLE(SERVICE_WORKER)
 714         request.setClientIdentifierIfNeeded(document-&gt;identifier());
 715         if (auto* activeServiceWorker = document-&gt;activeServiceWorker())
 716             request.setSelectedServiceWorkerRegistrationIdentifierIfNeeded(activeServiceWorker-&gt;registrationIdentifier());
 717 #endif
 718     }
 719 
 720     request.setAcceptHeaderIfNone(type);
 721 
 722     // Accept-Language value is handled in underlying port-specific code.
 723     // FIXME: Decide whether to support client hints
 724 }
 725 
 726 void CachedResourceLoader::updateHTTPRequestHeaders(CachedResource::Type type, CachedResourceRequest&amp; request)
 727 {
 728     // Implementing steps 7 to 12 of https://fetch.spec.whatwg.org/#http-network-or-cache-fetch
 729 
 730     // FIXME: We should reconcile handling of MainResource with other resources.
 731     if (type != CachedResource::Type::MainResource) {
 732         // In some cases we may try to load resources in frameless documents. Such loads always fail.
 733         // FIXME: We shouldn&#39;t need to do the check on frame.
 734         if (auto* frame = this-&gt;frame())
 735             request.updateReferrerOriginAndUserAgentHeaders(frame-&gt;loader());
 736     }
 737 
 738     request.updateAccordingCacheMode();
 739     request.updateAcceptEncodingHeader();
 740 }
 741 
 742 static FetchOptions::Destination destinationForType(CachedResource::Type type)
 743 {
 744     switch (type) {
 745     case CachedResource::Type::MainResource:
 746     case CachedResource::Type::SVGDocumentResource:
 747         return FetchOptions::Destination::Document;
 748     case CachedResource::Type::ImageResource:
 749     case CachedResource::Type::Icon:
 750         return FetchOptions::Destination::Image;
 751     case CachedResource::Type::CSSStyleSheet:
 752         return FetchOptions::Destination::Style;
 753     case CachedResource::Type::Script:
 754         return FetchOptions::Destination::Script;
 755     case CachedResource::Type::FontResource:
 756 #if ENABLE(SVG_FONTS)
 757     case CachedResource::Type::SVGFontResource:
 758 #endif
 759         return FetchOptions::Destination::Font;
 760 #if ENABLE(XSLT)
 761     case CachedResource::Type::XSLStyleSheet:
 762         return FetchOptions::Destination::Xslt;
 763 #endif
 764 #if ENABLE(VIDEO_TRACK)
 765     case CachedResource::Type::TextTrackResource:
 766         return FetchOptions::Destination::Track;
 767 #endif
 768 #if ENABLE(APPLICATION_MANIFEST)
 769     case CachedResource::Type::ApplicationManifest:
 770         return FetchOptions::Destination::Manifest;
 771 #endif
 772     case CachedResource::Type::Beacon:
 773     case CachedResource::Type::Ping:
 774     case CachedResource::Type::LinkPrefetch:
 775     case CachedResource::Type::RawResource:
 776     case CachedResource::Type::MediaResource:
 777         // The caller is responsible for setting the appropriate destination.
 778         return FetchOptions::Destination::EmptyString;
 779     }
 780     ASSERT_NOT_REACHED();
 781     return FetchOptions::Destination::EmptyString;
 782 }
 783 
 784 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::requestResource(CachedResource::Type type, CachedResourceRequest&amp;&amp; request, ForPreload forPreload, DeferOption defer)
 785 {
 786     if (!frame() || !frame()-&gt;page()) {
 787         RELEASE_LOG_IF_ALLOWED(&quot;requestResource: failed because no frame or page&quot;);
 788         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, request.resourceRequest().url(), &quot;Invalid loader state&quot;_s });
 789     }
 790     auto&amp; frame = *this-&gt;frame();
 791     auto&amp; page = *frame.page();
 792 
 793     request.setDestinationIfNotSet(destinationForType(type));
 794 
 795     // Entry point to https://fetch.spec.whatwg.org/#main-fetch.
 796     std::unique_ptr&lt;ResourceRequest&gt; originalRequest;
 797     if (CachedResource::shouldUsePingLoad(type) || request.options().destination == FetchOptions::Destination::EmptyString) {
 798         originalRequest = makeUnique&lt;ResourceRequest&gt;(request.resourceRequest());
 799         originalRequest-&gt;clearHTTPReferrer();
 800         originalRequest-&gt;clearHTTPOrigin();
 801     }
 802 
 803     if (Document* document = this-&gt;document())
 804         request.upgradeInsecureRequestIfNeeded(*document);
 805 
 806     if (InspectorInstrumentation::willInterceptRequest(&amp;frame, request.resourceRequest()))
 807         request.setCachingPolicy(CachingPolicy::DisallowCaching);
 808 
 809     request.updateReferrerPolicy(document() ? document()-&gt;referrerPolicy() : ReferrerPolicy::NoReferrerWhenDowngrade);
 810     URL url = request.resourceRequest().url();
 811 
 812     LOG(ResourceLoading, &quot;CachedResourceLoader::requestResource &#39;%.255s&#39;, charset &#39;%s&#39;, priority=%d, forPreload=%u&quot;, url.stringCenterEllipsizedToLength().latin1().data(), request.charset().latin1().data(), request.priority() ? static_cast&lt;int&gt;(request.priority().value()) : -1, forPreload == ForPreload::Yes);
 813 
 814     if (!url.isValid()) {
 815         RELEASE_LOG_IF_ALLOWED(&quot;requestResource: URL is invalid (frame = %p)&quot;, &amp;frame);
 816         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;URL is invalid&quot;_s });
 817     }
 818 
 819     prepareFetch(type, request);
 820 
 821     // We are passing url as well as request, as request url may contain a fragment identifier.
 822     if (!canRequest(type, url, request, forPreload)) {
 823         RELEASE_LOG_IF_ALLOWED(&quot;requestResource: Not allowed to request resource (frame = %p)&quot;, &amp;frame);
 824         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;Not allowed to request resource&quot;_s, ResourceError::Type::AccessControl });
 825     }
 826 
 827 #if ENABLE(CONTENT_EXTENSIONS)
 828     if (m_documentLoader) {
 829         const auto&amp; resourceRequest = request.resourceRequest();
 830         auto results = page.userContentProvider().processContentRuleListsForLoad(resourceRequest.url(), ContentExtensions::toResourceType(type), *m_documentLoader);
 831         bool blockedLoad = results.summary.blockedLoad;
 832         bool madeHTTPS = results.summary.madeHTTPS;
 833         request.applyResults(WTFMove(results), &amp;page);
 834         if (blockedLoad) {
 835             RELEASE_LOG_IF_ALLOWED(&quot;requestResource: Resource blocked by content blocker (frame = %p)&quot;, &amp;frame);
 836             if (type == CachedResource::Type::MainResource) {
 837                 CachedResourceHandle&lt;CachedResource&gt; resource = createResource(type, WTFMove(request), page.sessionID(), &amp;page.cookieJar());
 838                 ASSERT(resource);
 839                 resource-&gt;error(CachedResource::Status::LoadError);
 840                 resource-&gt;setResourceError(ResourceError(ContentExtensions::WebKitContentBlockerDomain, 0, resourceRequest.url(), WEB_UI_STRING(&quot;The URL was blocked by a content blocker&quot;, &quot;WebKitErrorBlockedByContentBlocker description&quot;)));
 841                 return resource;
 842             }
 843             return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, url, &quot;Resource blocked by content blocker&quot;_s, ResourceError::Type::AccessControl });
 844         }
 845         if (madeHTTPS
 846             &amp;&amp; type == CachedResource::Type::MainResource
 847             &amp;&amp; m_documentLoader-&gt;isLoadingMainResource()) {
 848             // This is to make sure the correct &#39;new&#39; URL shows in the location bar.
 849             m_documentLoader-&gt;frameLoader()-&gt;client().dispatchDidChangeProvisionalURL();
 850         }
 851         url = request.resourceRequest().url(); // The content extension could have changed it from http to https.
 852         url = MemoryCache::removeFragmentIdentifierIfNeeded(url); // Might need to remove fragment identifier again.
 853     }
 854 #endif
 855 
 856     if (m_documentLoader &amp;&amp; !m_documentLoader-&gt;customHeaderFields().isEmpty()) {
 857         bool sameOriginRequest = false;
 858         auto requestedOrigin = SecurityOrigin::create(url);
 859         if (type == CachedResource::Type::MainResource) {
 860             if (frame.isMainFrame())
 861                 sameOriginRequest = true;
 862             else if (auto* topDocument = frame.mainFrame().document())
 863                 sameOriginRequest = topDocument-&gt;securityOrigin().isSameSchemeHostPort(requestedOrigin.get());
 864         } else if (document()) {
 865             sameOriginRequest = document()-&gt;topDocument().securityOrigin().isSameSchemeHostPort(requestedOrigin.get())
 866                 &amp;&amp; document()-&gt;securityOrigin().isSameSchemeHostPort(requestedOrigin.get());
 867         }
 868         for (auto&amp; fields : m_documentLoader-&gt;customHeaderFields()) {
 869             if (sameOriginRequest || fields.thirdPartyDomainsMatch(url)) {
 870                 for (auto&amp; field : fields.fields)
 871                     request.resourceRequest().setHTTPHeaderField(field.name(), field.value());
 872             }
 873         }
 874     }
 875 
 876     LoadTiming loadTiming;
 877     loadTiming.markStartTimeAndFetchStart();
 878     InitiatorContext initiatorContext = request.options().initiatorContext;
 879 
 880     if (request.resourceRequest().url().protocolIsInHTTPFamily())
 881         updateHTTPRequestHeaders(type, request);
 882 
 883     auto&amp; memoryCache = MemoryCache::singleton();
 884     if (request.allowsCaching() &amp;&amp; memoryCache.disabled())
 885         m_documentResources.remove(url.string());
 886 
 887     // See if we can use an existing resource from the cache.
 888     CachedResourceHandle&lt;CachedResource&gt; resource;
 889     if (document())
 890         request.setDomainForCachePartition(*document());
 891 
 892     if (request.allowsCaching())
 893         resource = memoryCache.resourceForRequest(request.resourceRequest(), page.sessionID());
 894 
 895     if (resource &amp;&amp; request.isLinkPreload() &amp;&amp; !resource-&gt;isLinkPreload())
 896         resource-&gt;setLinkPreload();
 897 
 898     logMemoryCacheResourceRequest(&amp;frame, DiagnosticLoggingKeys::memoryCacheUsageKey(), resource ? DiagnosticLoggingKeys::inMemoryCacheKey() : DiagnosticLoggingKeys::notInMemoryCacheKey());
 899 
 900     auto&amp; cookieJar = page.cookieJar();
 901 
 902     RevalidationPolicy policy = determineRevalidationPolicy(type, request, resource.get(), forPreload, defer);
 903     switch (policy) {
 904     case Reload:
 905         memoryCache.remove(*resource);
 906         FALLTHROUGH;
 907     case Load:
 908         if (resource)
 909             logMemoryCacheResourceRequest(&amp;frame, DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::unusedKey());
 910         resource = loadResource(type, page.sessionID(), WTFMove(request), cookieJar);
 911         break;
 912     case Revalidate:
 913         if (resource)
 914             logMemoryCacheResourceRequest(&amp;frame, DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::revalidatingKey());
 915         resource = revalidateResource(WTFMove(request), *resource);
 916         break;
 917     case Use:
 918         ASSERT(resource);
 919         if (request.options().mode == FetchOptions::Mode::NoCors) {
 920             if (auto error = validateCrossOriginResourcePolicy(*request.origin(), request.resourceRequest().url(), resource-&gt;response()))
 921                 return makeUnexpected(WTFMove(*error));
 922 
 923             if (auto error = validateRangeRequestedFlag(request.resourceRequest(), resource-&gt;response()))
 924                 return makeUnexpected(WTFMove(*error));
 925         }
 926         if (shouldUpdateCachedResourceWithCurrentRequest(*resource, request)) {
 927             resource = updateCachedResourceWithCurrentRequest(*resource, WTFMove(request), page.sessionID(), cookieJar);
 928             if (resource-&gt;status() != CachedResource::Status::Cached)
 929                 policy = Load;
 930         } else {
 931             ResourceError error;
 932             if (!shouldContinueAfterNotifyingLoadedFromMemoryCache(request, *resource, error))
 933                 return makeUnexpected(WTFMove(error));
 934             logMemoryCacheResourceRequest(&amp;frame, DiagnosticLoggingKeys::memoryCacheEntryDecisionKey(), DiagnosticLoggingKeys::usedKey());
 935             loadTiming.setResponseEnd(MonotonicTime::now());
 936 
 937             memoryCache.resourceAccessed(*resource);
 938 
 939             if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled() &amp;&amp; document() &amp;&amp; !resource-&gt;isLoading()) {
 940                 auto resourceTiming = ResourceTiming::fromCache(url, request.initiatorName(), loadTiming, resource-&gt;response(), *request.origin());
 941                 if (initiatorContext == InitiatorContext::Worker) {
 942                     ASSERT(is&lt;CachedRawResource&gt;(resource.get()));
 943                     downcast&lt;CachedRawResource&gt;(resource.get())-&gt;finishedTimingForWorkerLoad(WTFMove(resourceTiming));
 944                 } else {
 945                     ASSERT(initiatorContext == InitiatorContext::Document);
 946                     m_resourceTimingInfo.storeResourceTimingInitiatorInformation(resource, request.initiatorName(), &amp;frame);
 947                     m_resourceTimingInfo.addResourceTiming(*resource.get(), *document(), WTFMove(resourceTiming));
 948                 }
 949             }
 950 
 951             if (forPreload == ForPreload::No)
 952                 resource-&gt;setLoadPriority(request.priority());
 953         }
 954         break;
 955     }
 956     ASSERT(resource);
 957     resource-&gt;setOriginalRequest(WTFMove(originalRequest));
 958 
 959     if (forPreload == ForPreload::No &amp;&amp; resource-&gt;loader() &amp;&amp; resource-&gt;ignoreForRequestCount()) {
 960         resource-&gt;setIgnoreForRequestCount(false);
 961         incrementRequestCount(*resource);
 962     }
 963 
 964     if ((policy != Use || resource-&gt;stillNeedsLoad()) &amp;&amp; defer == DeferOption::NoDefer) {
 965         resource-&gt;load(*this);
 966 
 967         // We don&#39;t support immediate loads, but we do support immediate failure.
 968         if (resource-&gt;errorOccurred()) {
 969             if (resource-&gt;allowsCaching() &amp;&amp; resource-&gt;inCache())
 970                 memoryCache.remove(*resource);
 971 
 972             auto resourceError = resource-&gt;resourceError();
 973             // Synchronous cancellations are likely due to access control.
 974             if (resourceError.isNull() || resourceError.isCancellation())
 975                 return makeUnexpected(ResourceError { String(), 0, url, String(), ResourceError::Type::AccessControl });
 976             return makeUnexpected(resourceError);
 977         }
 978     }
 979 
 980     if (document() &amp;&amp; !document()-&gt;loadEventFinished() &amp;&amp; !resource-&gt;resourceRequest().url().protocolIsData())
 981         m_validatedURLs.add(resource-&gt;resourceRequest().url());
 982 
 983     ASSERT(resource-&gt;url() == url.string());
 984     m_documentResources.set(resource-&gt;url(), resource);
 985     return resource;
 986 }
 987 
 988 void CachedResourceLoader::documentDidFinishLoadEvent()
 989 {
 990     m_validatedURLs.clear();
 991 
 992     // If m_preloads is not empty here, it&#39;s full of link preloads,
 993     // as speculative preloads were cleared at DCL.
 994     if (m_preloads &amp;&amp; m_preloads-&gt;size() &amp;&amp; !m_unusedPreloadsTimer.isActive())
 995         m_unusedPreloadsTimer.startOneShot(unusedPreloadTimeout);
 996 }
 997 
 998 void CachedResourceLoader::stopUnusedPreloadsTimer()
 999 {
1000     m_unusedPreloadsTimer.stop();
1001 }
1002 
1003 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::revalidateResource(CachedResourceRequest&amp;&amp; request, CachedResource&amp; resource)
1004 {
1005     ASSERT(resource.inCache());
1006     auto&amp; memoryCache = MemoryCache::singleton();
1007     ASSERT(!memoryCache.disabled());
1008     ASSERT(resource.canUseCacheValidator());
1009     ASSERT(!resource.resourceToRevalidate());
1010     ASSERT(resource.allowsCaching());
1011 
1012     CachedResourceHandle&lt;CachedResource&gt; newResource = createResource(resource.type(), WTFMove(request), resource.sessionID(), resource.cookieJar());
1013 
1014     LOG(ResourceLoading, &quot;Resource %p created to revalidate %p&quot;, newResource.get(), &amp;resource);
1015     newResource-&gt;setResourceToRevalidate(&amp;resource);
1016 
1017     memoryCache.remove(resource);
1018     memoryCache.add(*newResource);
1019 
1020     if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled())
1021         m_resourceTimingInfo.storeResourceTimingInitiatorInformation(newResource, newResource-&gt;initiatorName(), frame());
1022 
1023     return newResource;
1024 }
1025 
1026 CachedResourceHandle&lt;CachedResource&gt; CachedResourceLoader::loadResource(CachedResource::Type type, PAL::SessionID sessionID, CachedResourceRequest&amp;&amp; request, const CookieJar&amp; cookieJar)
1027 {
1028     auto&amp; memoryCache = MemoryCache::singleton();
1029     ASSERT(!request.allowsCaching() || !memoryCache.resourceForRequest(request.resourceRequest(), sessionID)
1030         || request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::DoNotUseAnyCache || request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData || request.resourceRequest().cachePolicy() == ResourceRequestCachePolicy::RefreshAnyCacheData);
1031 
1032     LOG(ResourceLoading, &quot;Loading CachedResource for &#39;%s&#39;.&quot;, request.resourceRequest().url().stringCenterEllipsizedToLength().latin1().data());
1033 
1034     CachedResourceHandle&lt;CachedResource&gt; resource = createResource(type, WTFMove(request), sessionID, &amp;cookieJar);
1035 
1036     if (resource-&gt;allowsCaching())
1037         memoryCache.add(*resource);
1038 
1039     if (RuntimeEnabledFeatures::sharedFeatures().resourceTimingEnabled())
1040         m_resourceTimingInfo.storeResourceTimingInitiatorInformation(resource, resource-&gt;initiatorName(), frame());
1041 
1042     return resource;
1043 }
1044 
1045 static void logRevalidation(const String&amp; reason, DiagnosticLoggingClient&amp; logClient)
1046 {
1047     logClient.logDiagnosticMessage(DiagnosticLoggingKeys::cachedResourceRevalidationReasonKey(), reason, ShouldSample::Yes);
1048 }
1049 
1050 static void logResourceRevalidationDecision(CachedResource::RevalidationDecision reason, const Frame* frame)
1051 {
1052     if (!frame || !frame-&gt;page())
1053         return;
1054     auto&amp; logClient = frame-&gt;page()-&gt;diagnosticLoggingClient();
1055     switch (reason) {
1056     case CachedResource::RevalidationDecision::No:
1057         break;
1058     case CachedResource::RevalidationDecision::YesDueToExpired:
1059         logRevalidation(DiagnosticLoggingKeys::isExpiredKey(), logClient);
1060         break;
1061     case CachedResource::RevalidationDecision::YesDueToNoStore:
1062         logRevalidation(DiagnosticLoggingKeys::noStoreKey(), logClient);
1063         break;
1064     case CachedResource::RevalidationDecision::YesDueToNoCache:
1065         logRevalidation(DiagnosticLoggingKeys::noCacheKey(), logClient);
1066         break;
1067     case CachedResource::RevalidationDecision::YesDueToCachePolicy:
1068         logRevalidation(DiagnosticLoggingKeys::reloadKey(), logClient);
1069         break;
1070     }
1071 }
1072 
1073 CachedResourceLoader::RevalidationPolicy CachedResourceLoader::determineRevalidationPolicy(CachedResource::Type type, CachedResourceRequest&amp; cachedResourceRequest, CachedResource* existingResource, ForPreload forPreload, DeferOption defer) const
1074 {
1075     auto&amp; request = cachedResourceRequest.resourceRequest();
1076 
1077     if (!existingResource)
1078         return Load;
1079 
1080     if (request.cachePolicy() == ResourceRequestCachePolicy::DoNotUseAnyCache || request.cachePolicy() == ResourceRequestCachePolicy::ReloadIgnoringCacheData)
1081         return Load;
1082 
1083     if (request.cachePolicy() == ResourceRequestCachePolicy::RefreshAnyCacheData)
1084         return Reload;
1085 
1086 #if ENABLE(SERVICE_WORKER)
1087     // FIXME: We should validate/specify this behavior.
1088     if (cachedResourceRequest.options().serviceWorkerRegistrationIdentifier != existingResource-&gt;options().serviceWorkerRegistrationIdentifier) {
1089         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading because selected service worker differs&quot;);
1090         return Reload;
1091     }
1092 #endif
1093 
1094     // We already have a preload going for this URL.
1095     if (forPreload == ForPreload::Yes &amp;&amp; existingResource-&gt;isPreloaded())
1096         return Use;
1097 
1098     // If the same URL has been loaded as a different type, we need to reload.
1099     if (existingResource-&gt;type() != type) {
1100         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to type mismatch.&quot;);
1101         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonTypeMismatchKey());
1102         return Reload;
1103     }
1104 
1105     if (!existingResource-&gt;varyHeaderValuesMatch(request))
1106         return Reload;
1107 
1108     auto* textDecoder = existingResource-&gt;textResourceDecoder();
1109     if (textDecoder &amp;&amp; !textDecoder-&gt;hasEqualEncodingForCharset(cachedResourceRequest.charset())) {
1110         if (!existingResource-&gt;hasUnknownEncoding())
1111             return Reload;
1112         existingResource-&gt;setHasUnknownEncoding(false);
1113         existingResource-&gt;setEncoding(cachedResourceRequest.charset());
1114     }
1115 
1116     // FIXME: We should use the same cache policy for all resource types. The raw resource policy is overly strict
1117     //        while the normal subresource policy is too loose.
1118     if (existingResource-&gt;isMainOrMediaOrIconOrRawResource() &amp;&amp; frame()) {
1119         bool strictPolicyDisabled = frame()-&gt;loader().isStrictRawResourceValidationPolicyDisabledForTesting();
1120         bool canReuseRawResource = strictPolicyDisabled || downcast&lt;CachedRawResource&gt;(*existingResource).canReuse(request);
1121         if (!canReuseRawResource)
1122             return Reload;
1123     }
1124 
1125     // Conditional requests should have failed canReuse check.
1126     ASSERT(!request.isConditional());
1127 
1128     // Do not load from cache if images are not enabled. The load for this image will be blocked in CachedImage::load.
1129     if (defer == DeferOption::DeferredByClient)
1130         return Reload;
1131 
1132     // Don&#39;t reload resources while pasting or if cache mode allows stale resources.
1133     if (m_allowStaleResources || cachedResourceRequest.options().cache == FetchOptions::Cache::ForceCache || cachedResourceRequest.options().cache == FetchOptions::Cache::OnlyIfCached)
1134         return Use;
1135 
1136     ASSERT(cachedResourceRequest.options().cache == FetchOptions::Cache::Default || cachedResourceRequest.options().cache == FetchOptions::Cache::NoCache);
1137 
1138     // Always use preloads.
1139     if (existingResource-&gt;isPreloaded())
1140         return Use;
1141 
1142     // We can find resources that are being validated from cache only when validation is just successfully completing.
1143     if (existingResource-&gt;validationCompleting())
1144         return Use;
1145     ASSERT(!existingResource-&gt;validationInProgress());
1146 
1147     auto cachePolicy = this-&gt;cachePolicy(type, request.url());
1148 
1149     // Validate the redirect chain.
1150     bool cachePolicyIsHistoryBuffer = cachePolicy == CachePolicyHistoryBuffer;
1151     if (!existingResource-&gt;redirectChainAllowsReuse(cachePolicyIsHistoryBuffer ? ReuseExpiredRedirection : DoNotReuseExpiredRedirection)) {
1152         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to not cached or expired redirections.&quot;);
1153         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonRedirectChainKey());
1154         return Reload;
1155     }
1156 
1157     // CachePolicyHistoryBuffer uses the cache except if this is a main resource with &quot;cache-control: no-store&quot;.
1158     if (cachePolicyIsHistoryBuffer) {
1159         // FIXME: Ignoring &quot;cache-control: no-cache&quot; for sub-resources on history navigation but not the main
1160         // resource is inconsistent. We should probably harmonize this.
1161         if (!existingResource-&gt;response().cacheControlContainsNoStore() || type != CachedResource::Type::MainResource)
1162             return Use;
1163     }
1164 
1165     // Don&#39;t reuse resources with Cache-control: no-store.
1166     if (existingResource-&gt;response().cacheControlContainsNoStore()) {
1167         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to Cache-control: no-store.&quot;);
1168         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonNoStoreKey());
1169         return Reload;
1170     }
1171 
1172     // If credentials were sent with the previous request and won&#39;t be
1173     // with this one, or vice versa, re-fetch the resource.
1174     //
1175     // This helps with the case where the server sends back
1176     // &quot;Access-Control-Allow-Origin: *&quot; all the time, but some of the
1177     // client&#39;s requests are made without CORS and some with.
1178     if (existingResource-&gt;resourceRequest().allowCookies() != request.allowCookies() || existingResource-&gt;options().credentials != cachedResourceRequest.options().credentials) {
1179         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to difference in credentials settings.&quot;);
1180         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonCredentialSettingsKey());
1181         return Reload;
1182     }
1183 
1184     // During the initial load, avoid loading the same resource multiple times for a single document, even if the cache policies would tell us to.
1185     if (document() &amp;&amp; !document()-&gt;loadEventFinished() &amp;&amp; m_validatedURLs.contains(existingResource-&gt;url()))
1186         return Use;
1187 
1188     // CachePolicyReload always reloads
1189     if (cachePolicy == CachePolicyReload) {
1190         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to CachePolicyReload.&quot;);
1191         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonReloadKey());
1192         return Reload;
1193     }
1194 
1195     // We&#39;ll try to reload the resource if it failed last time.
1196     if (existingResource-&gt;errorOccurred()) {
1197         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicye reloading due to resource being in the error state&quot;);
1198         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonErrorKey());
1199         return Reload;
1200     }
1201 
1202     if (existingResource-&gt;isLoading()) {
1203         // Do not use cached main resources that are still loading because sharing
1204         // loading CachedResources in this case causes issues with regards to cancellation.
1205         // If one of the DocumentLoader clients decides to cancel the load, then the load
1206         // would be cancelled for all other DocumentLoaders as well.
1207         if (type == CachedResource::Type::MainResource)
1208             return Reload;
1209         // For cached subresources that are still loading we ignore the cache policy.
1210         return Use;
1211     }
1212 
1213     auto revalidationDecision = existingResource-&gt;makeRevalidationDecision(cachePolicy);
1214     logResourceRevalidationDecision(revalidationDecision, frame());
1215 
1216     // Check if the cache headers requires us to revalidate (cache expiration for example).
1217     if (revalidationDecision != CachedResource::RevalidationDecision::No) {
1218         // See if the resource has usable ETag or Last-modified headers.
1219         if (existingResource-&gt;canUseCacheValidator())
1220             return Revalidate;
1221 
1222         // No, must reload.
1223         LOG(ResourceLoading, &quot;CachedResourceLoader::determineRevalidationPolicy reloading due to missing cache validators.&quot;);
1224         logMemoryCacheResourceRequest(frame(), DiagnosticLoggingKeys::inMemoryCacheKey(), DiagnosticLoggingKeys::unusedReasonMustRevalidateNoValidatorKey());
1225         return Reload;
1226     }
1227 
1228     return Use;
1229 }
1230 
1231 void CachedResourceLoader::printAccessDeniedMessage(const URL&amp; url) const
1232 {
1233     if (url.isNull())
1234         return;
1235 
1236     if (!frame())
1237         return;
1238 
1239     String message;
1240     if (!m_document || m_document-&gt;url().isNull())
1241         message = makeString(&quot;Unsafe attempt to load URL &quot;, url.stringCenterEllipsizedToLength(), &#39;.&#39;);
1242     else
1243         message = makeString(&quot;Unsafe attempt to load URL &quot;, url.stringCenterEllipsizedToLength(), &quot; from origin &quot;, m_document-&gt;securityOrigin().toString(), &quot;. Domains, protocols and ports must match.\n&quot;);
1244 
1245     frame()-&gt;document()-&gt;addConsoleMessage(MessageSource::Security, MessageLevel::Error, message);
1246 }
1247 
1248 void CachedResourceLoader::setAutoLoadImages(bool enable)
1249 {
1250     if (enable == m_autoLoadImages)
1251         return;
1252 
1253     m_autoLoadImages = enable;
1254 
1255     if (!m_autoLoadImages)
1256         return;
1257 
1258     reloadImagesIfNotDeferred();
1259 }
1260 
1261 void CachedResourceLoader::setImagesEnabled(bool enable)
1262 {
1263     if (enable == m_imagesEnabled)
1264         return;
1265 
1266     m_imagesEnabled = enable;
1267 
1268     if (!m_imagesEnabled)
1269         return;
1270 
1271     reloadImagesIfNotDeferred();
1272 }
1273 
1274 bool CachedResourceLoader::clientDefersImage(const URL&amp;) const
1275 {
1276     return !m_imagesEnabled;
1277 }
1278 
1279 bool CachedResourceLoader::shouldPerformImageLoad(const URL&amp; url) const
1280 {
1281     return m_autoLoadImages || url.protocolIsData();
1282 }
1283 
1284 bool CachedResourceLoader::shouldDeferImageLoad(const URL&amp; url) const
1285 {
1286     return clientDefersImage(url) || !shouldPerformImageLoad(url);
1287 }
1288 
1289 void CachedResourceLoader::reloadImagesIfNotDeferred()
1290 {
1291     for (auto&amp; resource : m_documentResources.values()) {
1292         if (is&lt;CachedImage&gt;(*resource) &amp;&amp; resource-&gt;stillNeedsLoad() &amp;&amp; !clientDefersImage(resource-&gt;url()))
1293             downcast&lt;CachedImage&gt;(*resource).load(*this);
1294     }
1295 }
1296 
1297 CachePolicy CachedResourceLoader::cachePolicy(CachedResource::Type type, const URL&amp; url) const
1298 {
1299     Frame* frame = this-&gt;frame();
1300     if (!frame)
1301         return CachePolicyVerify;
1302 
1303     if (type != CachedResource::Type::MainResource)
1304         return frame-&gt;loader().subresourceCachePolicy(url);
1305 
1306     if (Page* page = frame-&gt;page()) {
1307         if (page-&gt;isResourceCachingDisabledByWebInspector())
1308             return CachePolicyReload;
1309     }
1310 
1311     switch (frame-&gt;loader().loadType()) {
1312     case FrameLoadType::ReloadFromOrigin:
1313     case FrameLoadType::Reload:
1314         return CachePolicyReload;
1315     case FrameLoadType::Back:
1316     case FrameLoadType::Forward:
1317     case FrameLoadType::IndexedBackForward:
1318         // Do not revalidate cached main resource on back/forward navigation.
1319         return CachePolicyHistoryBuffer;
1320     default:
1321         return CachePolicyVerify;
1322     }
1323 }
1324 
1325 void CachedResourceLoader::loadDone(LoadCompletionType type, bool shouldPerformPostLoadActions)
1326 {
1327     RefPtr&lt;DocumentLoader&gt; protectDocumentLoader(m_documentLoader);
1328     RefPtr&lt;Document&gt; protectDocument(m_document.get());
1329 
1330     ASSERT(shouldPerformPostLoadActions || type == LoadCompletionType::Cancel);
1331 
1332     if (frame())
1333         frame()-&gt;loader().loadDone(type);
1334 
1335     if (shouldPerformPostLoadActions)
1336         performPostLoadActions();
1337 
1338     if (!m_garbageCollectDocumentResourcesTimer.isActive())
1339         m_garbageCollectDocumentResourcesTimer.startOneShot(0_s);
1340 }
1341 
1342 // Garbage collecting m_documentResources is a workaround for the
1343 // CachedResourceHandles on the RHS being strong references. Ideally this
1344 // would be a weak map, however CachedResourceHandles perform additional
1345 // bookkeeping on CachedResources, so instead pseudo-GC them -- when the
1346 // reference count reaches 1, m_documentResources is the only reference, so
1347 // remove it from the map.
1348 void CachedResourceLoader::garbageCollectDocumentResources()
1349 {
1350     LOG(ResourceLoading, &quot;CachedResourceLoader %p garbageCollectDocumentResources&quot;, this);
1351 
1352     typedef Vector&lt;String, 10&gt; StringVector;
1353     StringVector resourcesToDelete;
1354 
1355     for (auto&amp; resource : m_documentResources) {
1356         LOG(ResourceLoading, &quot;  cached resource %p - hasOneHandle %d&quot;, resource.value.get(), resource.value-&gt;hasOneHandle());
1357 
1358         if (resource.value-&gt;hasOneHandle())
1359             resourcesToDelete.append(resource.key);
1360     }
1361 
1362     for (auto&amp; resource : resourcesToDelete)
1363         m_documentResources.remove(resource);
1364 }
1365 
1366 void CachedResourceLoader::performPostLoadActions()
1367 {
1368     platformStrategies()-&gt;loaderStrategy()-&gt;servePendingRequests();
1369 }
1370 
1371 void CachedResourceLoader::incrementRequestCount(const CachedResource&amp; resource)
1372 {
1373     if (resource.ignoreForRequestCount())
1374         return;
1375 
1376     ++m_requestCount;
1377 }
1378 
1379 void CachedResourceLoader::decrementRequestCount(const CachedResource&amp; resource)
1380 {
1381     if (resource.ignoreForRequestCount())
1382         return;
1383 
1384     --m_requestCount;
1385     ASSERT(m_requestCount &gt; -1);
1386 }
1387 
1388 ResourceErrorOr&lt;CachedResourceHandle&lt;CachedResource&gt;&gt; CachedResourceLoader::preload(CachedResource::Type type, CachedResourceRequest&amp;&amp; request)
1389 {
1390     if (InspectorInstrumentation::willInterceptRequest(frame(), request.resourceRequest()))
1391         return makeUnexpected(ResourceError { errorDomainWebKitInternal, 0, request.resourceRequest().url(), &quot;Inspector intercept&quot;_s });
1392 
1393     if (request.charset().isEmpty() &amp;&amp; (type == CachedResource::Type::Script || type == CachedResource::Type::CSSStyleSheet))
1394         request.setCharset(m_document-&gt;charset());
1395 
1396     auto resource = requestResource(type, WTFMove(request), ForPreload::Yes);
1397     if (resource &amp;&amp; (!m_preloads || !m_preloads-&gt;contains(resource.value().get()))) {
1398         auto resourceValue = resource.value();
1399         // Fonts need special treatment since just creating the resource doesn&#39;t trigger a load.
1400         if (type == CachedResource::Type::FontResource)
1401             downcast&lt;CachedFont&gt;(resourceValue.get())-&gt;beginLoadIfNeeded(*this);
1402         resourceValue-&gt;increasePreloadCount();
1403 
1404         if (!m_preloads)
1405             m_preloads = makeUnique&lt;ListHashSet&lt;CachedResource*&gt;&gt;();
1406         m_preloads-&gt;add(resourceValue.get());
1407     }
1408     return resource;
1409 }
1410 
1411 void CachedResourceLoader::warnUnusedPreloads()
1412 {
1413     if (!m_preloads)
1414         return;
1415     for (const auto&amp; resource : *m_preloads) {
1416         if (resource &amp;&amp; resource-&gt;isLinkPreload() &amp;&amp; resource-&gt;preloadResult() == CachedResource::PreloadResult::PreloadNotReferenced &amp;&amp; document()) {
1417             document()-&gt;addConsoleMessage(MessageSource::Other, MessageLevel::Warning,
1418                 &quot;The resource &quot; + resource-&gt;url().string() +
1419                 &quot; was preloaded using link preload but not used within a few seconds from the window&#39;s load event. Please make sure it wasn&#39;t preloaded for nothing.&quot;);
1420         }
1421     }
1422 }
1423 
1424 bool CachedResourceLoader::isPreloaded(const String&amp; urlString) const
1425 {
1426     const URL&amp; url = m_document-&gt;completeURL(urlString);
1427 
1428     if (m_preloads) {
1429         for (auto&amp; resource : *m_preloads) {
1430             if (resource-&gt;url() == url)
1431                 return true;
1432         }
1433     }
1434     return false;
1435 }
1436 
1437 void CachedResourceLoader::clearPreloads(ClearPreloadsMode mode)
1438 {
1439     if (!m_preloads)
1440         return;
1441 
1442     std::unique_ptr&lt;ListHashSet&lt;CachedResource*&gt;&gt; remainingLinkPreloads;
1443     for (auto* resource : *m_preloads) {
1444         ASSERT(resource);
1445         if (mode == ClearPreloadsMode::ClearSpeculativePreloads &amp;&amp; resource-&gt;isLinkPreload()) {
1446             if (!remainingLinkPreloads)
1447                 remainingLinkPreloads = makeUnique&lt;ListHashSet&lt;CachedResource*&gt;&gt;();
1448             remainingLinkPreloads-&gt;add(resource);
1449             continue;
1450         }
1451         resource-&gt;decreasePreloadCount();
1452         bool deleted = resource-&gt;deleteIfPossible();
1453         if (!deleted &amp;&amp; resource-&gt;preloadResult() == CachedResource::PreloadResult::PreloadNotReferenced)
1454             MemoryCache::singleton().remove(*resource);
1455     }
1456     m_preloads = WTFMove(remainingLinkPreloads);
1457 }
1458 
1459 const ResourceLoaderOptions&amp; CachedResourceLoader::defaultCachedResourceOptions()
1460 {
1461     static NeverDestroyed&lt;ResourceLoaderOptions&gt; options(
1462         SendCallbackPolicy::SendCallbacks,
1463         ContentSniffingPolicy::SniffContent,
1464         DataBufferingPolicy::BufferData,
1465         StoredCredentialsPolicy::Use,
1466         ClientCredentialPolicy::MayAskClientForCredentials,
1467         FetchOptions::Credentials::Include,
1468         SecurityCheckPolicy::DoSecurityCheck,
1469         FetchOptions::Mode::NoCors,
1470         CertificateInfoPolicy::DoNotIncludeCertificateInfo,
1471         ContentSecurityPolicyImposition::DoPolicyCheck,
1472         DefersLoadingPolicy::AllowDefersLoading,
1473         CachingPolicy::AllowCaching);
1474     return options;
1475 }
1476 
1477 bool CachedResourceLoader::isAlwaysOnLoggingAllowed() const
1478 {
1479     return m_documentLoader ? m_documentLoader-&gt;isAlwaysOnLoggingAllowed() : true;
1480 }
1481 
1482 }
    </pre>
  </body>
</html>
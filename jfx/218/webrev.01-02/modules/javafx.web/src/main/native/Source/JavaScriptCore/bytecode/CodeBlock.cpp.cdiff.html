<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CodeBlock.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CallVariant.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CodeBlock.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/bytecode/CodeBlock.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2008-2019 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2008 Cameron Zwarich &lt;cwzwarich@uwaterloo.ca&gt;
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2008-2020 Apple Inc. All rights reserved.</span>
   * Copyright (C) 2008 Cameron Zwarich &lt;cwzwarich@uwaterloo.ca&gt;
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 36,10 ***</span>
<span class="line-new-header">--- 36,11 ---</span>
  #include &quot;BytecodeGenerator.h&quot;
  #include &quot;BytecodeLivenessAnalysis.h&quot;
  #include &quot;BytecodeStructs.h&quot;
  #include &quot;BytecodeUseDef.h&quot;
  #include &quot;CallLinkStatus.h&quot;
<span class="line-added">+ #include &quot;CheckpointOSRExitSideState.h&quot;</span>
  #include &quot;CodeBlockInlines.h&quot;
  #include &quot;CodeBlockSet.h&quot;
  #include &quot;DFGCapabilities.h&quot;
  #include &quot;DFGCommon.h&quot;
  #include &quot;DFGDriver.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 107,10 ***</span>
<span class="line-new-header">--- 108,12 ---</span>
  #include &quot;FTLJITCode.h&quot;
  #endif
  
  namespace JSC {
  
<span class="line-added">+ DEFINE_ALLOCATOR_WITH_HEAP_IDENTIFIER(CodeBlockRareData);</span>
<span class="line-added">+ </span>
  const ClassInfo CodeBlock::s_info = {
      &quot;CodeBlock&quot;, nullptr, nullptr, nullptr,
      CREATE_METHOD_TABLE(CodeBlock)
  };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 244,11 ***</span>
  
  void CodeBlock::dumpBytecode(PrintStream&amp; out)
  {
      ICStatusMap statusMap;
      getICStatusMap(statusMap);
<span class="line-modified">!     BytecodeDumper&lt;CodeBlock&gt;::dumpBlock(this, instructions(), out, statusMap);</span>
  }
  
  void CodeBlock::dumpBytecode(PrintStream&amp; out, const InstructionStream::Ref&amp; it, const ICStatusMap&amp; statusMap)
  {
      BytecodeDumper&lt;CodeBlock&gt;::dumpBytecode(this, out, it, statusMap);
<span class="line-new-header">--- 247,11 ---</span>
  
  void CodeBlock::dumpBytecode(PrintStream&amp; out)
  {
      ICStatusMap statusMap;
      getICStatusMap(statusMap);
<span class="line-modified">!     CodeBlockBytecodeDumper&lt;CodeBlock&gt;::dumpBlock(this, instructions(), out, statusMap);</span>
  }
  
  void CodeBlock::dumpBytecode(PrintStream&amp; out, const InstructionStream::Ref&amp; it, const ICStatusMap&amp; statusMap)
  {
      BytecodeDumper&lt;CodeBlock&gt;::dumpBytecode(this, out, it, statusMap);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 290,10 ***</span>
<span class="line-new-header">--- 293,12 ---</span>
      , m_capabilityLevelState(DFG::CapabilityLevelNotSet)
  #endif
      , m_didFailJITCompilation(false)
      , m_didFailFTLCompilation(false)
      , m_hasBeenCompiledWithFTL(false)
<span class="line-added">+     , m_hasLinkedOSRExit(false)</span>
<span class="line-added">+     , m_isEligibleForLLIntDowngrade(false)</span>
      , m_numCalleeLocals(other.m_numCalleeLocals)
      , m_numVars(other.m_numVars)
      , m_numberOfArgumentsToSkip(other.m_numberOfArgumentsToSkip)
      , m_hasDebuggerStatement(false)
      , m_steppingMode(SteppingModeDisabled)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 349,10 ***</span>
<span class="line-new-header">--- 354,12 ---</span>
      , m_capabilityLevelState(DFG::CapabilityLevelNotSet)
  #endif
      , m_didFailJITCompilation(false)
      , m_didFailFTLCompilation(false)
      , m_hasBeenCompiledWithFTL(false)
<span class="line-added">+     , m_hasLinkedOSRExit(false)</span>
<span class="line-added">+     , m_isEligibleForLLIntDowngrade(false)</span>
      , m_numCalleeLocals(unlinkedCodeBlock-&gt;numCalleeLocals())
      , m_numVars(unlinkedCodeBlock-&gt;numVars())
      , m_hasDebuggerStatement(false)
      , m_steppingMode(SteppingModeDisabled)
      , m_numBreakpoints(0)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 397,25 ***</span>
  
      ScriptExecutable* topLevelExecutable = ownerExecutable-&gt;topLevelExecutable();
      setConstantRegisters(unlinkedCodeBlock-&gt;constantRegisters(), unlinkedCodeBlock-&gt;constantsSourceCodeRepresentation(), topLevelExecutable);
      RETURN_IF_EXCEPTION(throwScope, false);
  
<span class="line-removed">-     for (unsigned i = 0; i &lt; LinkTimeConstantCount; i++) {</span>
<span class="line-removed">-         LinkTimeConstant type = static_cast&lt;LinkTimeConstant&gt;(i);</span>
<span class="line-removed">-         if (unsigned registerIndex = unlinkedCodeBlock-&gt;registerIndexForLinkTimeConstant(type))</span>
<span class="line-removed">-             m_constantRegisters[registerIndex].set(vm, this, m_globalObject-&gt;jsCellForLinkTimeConstant(type));</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      // We already have the cloned symbol table for the module environment since we need to instantiate
      // the module environments before linking the code block. We replace the stored symbol table with the already cloned one.
      if (UnlinkedModuleProgramCodeBlock* unlinkedModuleProgramCodeBlock = jsDynamicCast&lt;UnlinkedModuleProgramCodeBlock*&gt;(vm, unlinkedCodeBlock)) {
          SymbolTable* clonedSymbolTable = jsCast&lt;ModuleProgramExecutable*&gt;(ownerExecutable)-&gt;moduleEnvironmentSymbolTable();
          if (m_unlinkedCode-&gt;wasCompiledWithTypeProfilerOpcodes()) {
              ConcurrentJSLocker locker(clonedSymbolTable-&gt;m_lock);
              clonedSymbolTable-&gt;prepareForTypeProfiling(locker);
          }
<span class="line-modified">!         replaceConstant(unlinkedModuleProgramCodeBlock-&gt;moduleEnvironmentSymbolTableConstantRegisterOffset(), clonedSymbolTable);</span>
      }
  
      bool shouldUpdateFunctionHasExecutedCache = m_unlinkedCode-&gt;wasCompiledWithTypeProfilerOpcodes() || m_unlinkedCode-&gt;wasCompiledWithControlFlowProfilerOpcodes();
      m_functionDecls = RefCountedArray&lt;WriteBarrier&lt;FunctionExecutable&gt;&gt;(unlinkedCodeBlock-&gt;numberOfFunctionDecls());
      for (size_t count = unlinkedCodeBlock-&gt;numberOfFunctionDecls(), i = 0; i &lt; count; ++i) {
<span class="line-new-header">--- 404,19 ---</span>
  
      ScriptExecutable* topLevelExecutable = ownerExecutable-&gt;topLevelExecutable();
      setConstantRegisters(unlinkedCodeBlock-&gt;constantRegisters(), unlinkedCodeBlock-&gt;constantsSourceCodeRepresentation(), topLevelExecutable);
      RETURN_IF_EXCEPTION(throwScope, false);
  
      // We already have the cloned symbol table for the module environment since we need to instantiate
      // the module environments before linking the code block. We replace the stored symbol table with the already cloned one.
      if (UnlinkedModuleProgramCodeBlock* unlinkedModuleProgramCodeBlock = jsDynamicCast&lt;UnlinkedModuleProgramCodeBlock*&gt;(vm, unlinkedCodeBlock)) {
          SymbolTable* clonedSymbolTable = jsCast&lt;ModuleProgramExecutable*&gt;(ownerExecutable)-&gt;moduleEnvironmentSymbolTable();
          if (m_unlinkedCode-&gt;wasCompiledWithTypeProfilerOpcodes()) {
              ConcurrentJSLocker locker(clonedSymbolTable-&gt;m_lock);
              clonedSymbolTable-&gt;prepareForTypeProfiling(locker);
          }
<span class="line-modified">!         replaceConstant(VirtualRegister(unlinkedModuleProgramCodeBlock-&gt;moduleEnvironmentSymbolTableConstantRegisterOffset()), clonedSymbolTable);</span>
      }
  
      bool shouldUpdateFunctionHasExecutedCache = m_unlinkedCode-&gt;wasCompiledWithTypeProfilerOpcodes() || m_unlinkedCode-&gt;wasCompiledWithControlFlowProfilerOpcodes();
      m_functionDecls = RefCountedArray&lt;WriteBarrier&lt;FunctionExecutable&gt;&gt;(unlinkedCodeBlock-&gt;numberOfFunctionDecls());
      for (size_t count = unlinkedCodeBlock-&gt;numberOfFunctionDecls(), i = 0; i &lt; count; ++i) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 443,18 ***</span>
              m_rareData-&gt;m_exceptionHandlers.resizeToFit(count);
              for (size_t i = 0; i &lt; count; i++) {
                  const UnlinkedHandlerInfo&amp; unlinkedHandler = unlinkedCodeBlock-&gt;exceptionHandler(i);
                  HandlerInfo&amp; handler = m_rareData-&gt;m_exceptionHandlers[i];
  #if ENABLE(JIT)
<span class="line-modified">!                 auto instruction = instructions().at(unlinkedHandler.target);</span>
<span class="line-modified">!                 MacroAssemblerCodePtr&lt;BytecodePtrTag&gt; codePtr;</span>
<span class="line-removed">-                 if (instruction-&gt;isWide32())</span>
<span class="line-removed">-                     codePtr = LLInt::getWide32CodePtr&lt;BytecodePtrTag&gt;(op_catch);</span>
<span class="line-removed">-                 else if (instruction-&gt;isWide16())</span>
<span class="line-removed">-                     codePtr = LLInt::getWide16CodePtr&lt;BytecodePtrTag&gt;(op_catch);</span>
<span class="line-removed">-                 else</span>
<span class="line-removed">-                     codePtr = LLInt::getCodePtr&lt;BytecodePtrTag&gt;(op_catch);</span>
                  handler.initialize(unlinkedHandler, CodeLocationLabel&lt;ExceptionHandlerPtrTag&gt;(codePtr.retagged&lt;ExceptionHandlerPtrTag&gt;()));
  #else
                  handler.initialize(unlinkedHandler);
  #endif
              }
<span class="line-new-header">--- 444,12 ---</span>
              m_rareData-&gt;m_exceptionHandlers.resizeToFit(count);
              for (size_t i = 0; i &lt; count; i++) {
                  const UnlinkedHandlerInfo&amp; unlinkedHandler = unlinkedCodeBlock-&gt;exceptionHandler(i);
                  HandlerInfo&amp; handler = m_rareData-&gt;m_exceptionHandlers[i];
  #if ENABLE(JIT)
<span class="line-modified">!                 auto&amp; instruction = *instructions().at(unlinkedHandler.target).ptr();</span>
<span class="line-modified">!                 MacroAssemblerCodePtr&lt;BytecodePtrTag&gt; codePtr = LLInt::getCodePtr&lt;BytecodePtrTag&gt;(instruction);</span>
                  handler.initialize(unlinkedHandler, CodeLocationLabel&lt;ExceptionHandlerPtrTag&gt;(codePtr.retagged&lt;ExceptionHandlerPtrTag&gt;()));
  #else
                  handler.initialize(unlinkedHandler);
  #endif
              }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 476,11 ***</span>
          if (size_t count = unlinkedCodeBlock-&gt;numberOfSwitchJumpTables()) {
              m_rareData-&gt;m_switchJumpTables.grow(count);
              for (size_t i = 0; i &lt; count; i++) {
                  UnlinkedSimpleJumpTable&amp; sourceTable = unlinkedCodeBlock-&gt;switchJumpTable(i);
                  SimpleJumpTable&amp; destTable = m_rareData-&gt;m_switchJumpTables[i];
<span class="line-modified">!                 destTable.branchOffsets = sourceTable.branchOffsets;</span>
                  destTable.min = sourceTable.min;
              }
          }
      }
  
<span class="line-new-header">--- 471,12 ---</span>
          if (size_t count = unlinkedCodeBlock-&gt;numberOfSwitchJumpTables()) {
              m_rareData-&gt;m_switchJumpTables.grow(count);
              for (size_t i = 0; i &lt; count; i++) {
                  UnlinkedSimpleJumpTable&amp; sourceTable = unlinkedCodeBlock-&gt;switchJumpTable(i);
                  SimpleJumpTable&amp; destTable = m_rareData-&gt;m_switchJumpTables[i];
<span class="line-modified">!                 destTable.branchOffsets.resizeToFit(sourceTable.branchOffsets.size());</span>
<span class="line-added">+                 std::copy(sourceTable.branchOffsets.begin(), sourceTable.branchOffsets.end(), destTable.branchOffsets.begin());</span>
                  destTable.min = sourceTable.min;
              }
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 536,18 ***</span>
<span class="line-new-header">--- 532,21 ---</span>
          LINK(OpTryGetById, profile)
          LINK(OpGetByIdDirect, profile)
          LINK(OpGetByValWithThis, profile)
          LINK(OpGetFromArguments, profile)
          LINK(OpToNumber, profile)
<span class="line-added">+         LINK(OpToNumeric, profile)</span>
          LINK(OpToObject, profile)
          LINK(OpGetArgument, profile)
<span class="line-added">+         LINK(OpGetInternalField, profile)</span>
          LINK(OpToThis, profile)
          LINK(OpBitand, profile)
          LINK(OpBitor, profile)
          LINK(OpBitnot, profile)
          LINK(OpBitxor, profile)
          LINK(OpLshift, profile)
<span class="line-added">+         LINK(OpRshift, profile)</span>
  
          LINK(OpGetById, profile)
  
          LINK(OpCall, profile)
          LINK(OpTailCall, profile)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 564,17 ***</span>
<span class="line-new-header">--- 563,21 ---</span>
  
          LINK(OpNewObject, objectAllocationProfile)
  
          LINK(OpPutById)
          LINK(OpCreateThis)
<span class="line-added">+         LINK(OpCreatePromise)</span>
<span class="line-added">+         LINK(OpCreateGenerator)</span>
  
          LINK(OpAdd)
          LINK(OpMul)
          LINK(OpDiv)
          LINK(OpSub)
  
          LINK(OpNegate)
<span class="line-added">+         LINK(OpInc)</span>
<span class="line-added">+         LINK(OpDec)</span>
  
          LINK(OpJneqPtr)
  
          LINK(OpCatch)
          LINK(OpProfileControlFlow)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 583,20 ***</span>
              INITIALIZE_METADATA(OpResolveScope)
  
              const Identifier&amp; ident = identifier(bytecode.m_var);
              RELEASE_ASSERT(bytecode.m_resolveType != LocalClosureVar);
  
<span class="line-modified">!             ResolveOp op = JSScope::abstractResolve(m_globalObject-&gt;globalExec(), bytecode.m_localScopeDepth, scope, ident, Get, bytecode.m_resolveType, InitializationMode::NotInitialization);</span>
              RETURN_IF_EXCEPTION(throwScope, false);
  
              metadata.m_resolveType = op.type;
              metadata.m_localScopeDepth = op.depth;
              if (op.lexicalEnvironment) {
                  if (op.type == ModuleVar) {
                      // Keep the linked module environment strongly referenced.
                      if (stronglyReferencedModuleEnvironments.add(jsCast&lt;JSModuleEnvironment*&gt;(op.lexicalEnvironment)).isNewEntry)
<span class="line-modified">!                         addConstant(op.lexicalEnvironment);</span>
                      metadata.m_lexicalEnvironment.set(vm, this, op.lexicalEnvironment);
                  } else
                      metadata.m_symbolTable.set(vm, this, op.lexicalEnvironment-&gt;symbolTable());
              } else if (JSScope* constantScope = JSScope::constantScopeForCodeBlock(op.type, this)) {
                  metadata.m_constantScope.set(vm, this, constantScope);
<span class="line-new-header">--- 586,20 ---</span>
              INITIALIZE_METADATA(OpResolveScope)
  
              const Identifier&amp; ident = identifier(bytecode.m_var);
              RELEASE_ASSERT(bytecode.m_resolveType != LocalClosureVar);
  
<span class="line-modified">!             ResolveOp op = JSScope::abstractResolve(m_globalObject.get(), bytecode.m_localScopeDepth, scope, ident, Get, bytecode.m_resolveType, InitializationMode::NotInitialization);</span>
              RETURN_IF_EXCEPTION(throwScope, false);
  
              metadata.m_resolveType = op.type;
              metadata.m_localScopeDepth = op.depth;
              if (op.lexicalEnvironment) {
                  if (op.type == ModuleVar) {
                      // Keep the linked module environment strongly referenced.
                      if (stronglyReferencedModuleEnvironments.add(jsCast&lt;JSModuleEnvironment*&gt;(op.lexicalEnvironment)).isNewEntry)
<span class="line-modified">!                         addConstant(ConcurrentJSLocker(m_lock), op.lexicalEnvironment);</span>
                      metadata.m_lexicalEnvironment.set(vm, this, op.lexicalEnvironment);
                  } else
                      metadata.m_symbolTable.set(vm, this, op.lexicalEnvironment-&gt;symbolTable());
              } else if (JSScope* constantScope = JSScope::constantScopeForCodeBlock(op.type, this)) {
                  metadata.m_constantScope.set(vm, this, constantScope);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 618,11 ***</span>
                  metadata.m_getPutInfo = GetPutInfo(bytecode.m_getPutInfo.resolveMode(), ClosureVar, bytecode.m_getPutInfo.initializationMode());
                  break;
              }
  
              const Identifier&amp; ident = identifier(bytecode.m_var);
<span class="line-modified">!             ResolveOp op = JSScope::abstractResolve(m_globalObject-&gt;globalExec(), bytecode.m_localScopeDepth, scope, ident, Get, bytecode.m_getPutInfo.resolveType(), InitializationMode::NotInitialization);</span>
              RETURN_IF_EXCEPTION(throwScope, false);
  
              metadata.m_getPutInfo = GetPutInfo(bytecode.m_getPutInfo.resolveMode(), op.type, bytecode.m_getPutInfo.initializationMode());
              if (op.type == ModuleVar)
                  metadata.m_getPutInfo = GetPutInfo(bytecode.m_getPutInfo.resolveMode(), ClosureVar, bytecode.m_getPutInfo.initializationMode());
<span class="line-new-header">--- 621,11 ---</span>
                  metadata.m_getPutInfo = GetPutInfo(bytecode.m_getPutInfo.resolveMode(), ClosureVar, bytecode.m_getPutInfo.initializationMode());
                  break;
              }
  
              const Identifier&amp; ident = identifier(bytecode.m_var);
<span class="line-modified">!             ResolveOp op = JSScope::abstractResolve(m_globalObject.get(), bytecode.m_localScopeDepth, scope, ident, Get, bytecode.m_getPutInfo.resolveType(), InitializationMode::NotInitialization);</span>
              RETURN_IF_EXCEPTION(throwScope, false);
  
              metadata.m_getPutInfo = GetPutInfo(bytecode.m_getPutInfo.resolveMode(), op.type, bytecode.m_getPutInfo.initializationMode());
              if (op.type == ModuleVar)
                  metadata.m_getPutInfo = GetPutInfo(bytecode.m_getPutInfo.resolveMode(), ClosureVar, bytecode.m_getPutInfo.initializationMode());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 638,11 ***</span>
              INITIALIZE_METADATA(OpPutToScope)
  
              if (bytecode.m_getPutInfo.resolveType() == LocalClosureVar) {
                  // Only do watching if the property we&#39;re putting to is not anonymous.
                  if (bytecode.m_var != UINT_MAX) {
<span class="line-modified">!                     SymbolTable* symbolTable = jsCast&lt;SymbolTable*&gt;(getConstant(bytecode.m_symbolTableOrScopeDepth.symbolTable().offset()));</span>
                      const Identifier&amp; ident = identifier(bytecode.m_var);
                      ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
                      auto iter = symbolTable-&gt;find(locker, ident.impl());
                      ASSERT(iter != symbolTable-&gt;end(locker));
                      iter-&gt;value.prepareToWatch();
<span class="line-new-header">--- 641,11 ---</span>
              INITIALIZE_METADATA(OpPutToScope)
  
              if (bytecode.m_getPutInfo.resolveType() == LocalClosureVar) {
                  // Only do watching if the property we&#39;re putting to is not anonymous.
                  if (bytecode.m_var != UINT_MAX) {
<span class="line-modified">!                     SymbolTable* symbolTable = jsCast&lt;SymbolTable*&gt;(getConstant(bytecode.m_symbolTableOrScopeDepth.symbolTable()));</span>
                      const Identifier&amp; ident = identifier(bytecode.m_var);
                      ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
                      auto iter = symbolTable-&gt;find(locker, ident.impl());
                      ASSERT(iter != symbolTable-&gt;end(locker));
                      iter-&gt;value.prepareToWatch();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 652,11 ***</span>
                  break;
              }
  
              const Identifier&amp; ident = identifier(bytecode.m_var);
              metadata.m_watchpointSet = nullptr;
<span class="line-modified">!             ResolveOp op = JSScope::abstractResolve(m_globalObject-&gt;globalExec(), bytecode.m_symbolTableOrScopeDepth.scopeDepth(), scope, ident, Put, bytecode.m_getPutInfo.resolveType(), bytecode.m_getPutInfo.initializationMode());</span>
              RETURN_IF_EXCEPTION(throwScope, false);
  
              metadata.m_getPutInfo = GetPutInfo(bytecode.m_getPutInfo.resolveMode(), op.type, bytecode.m_getPutInfo.initializationMode());
              if (op.type == GlobalVar || op.type == GlobalVarWithVarInjectionChecks || op.type == GlobalLexicalVar || op.type == GlobalLexicalVarWithVarInjectionChecks)
                  metadata.m_watchpointSet = op.watchpointSet;
<span class="line-new-header">--- 655,11 ---</span>
                  break;
              }
  
              const Identifier&amp; ident = identifier(bytecode.m_var);
              metadata.m_watchpointSet = nullptr;
<span class="line-modified">!             ResolveOp op = JSScope::abstractResolve(m_globalObject.get(), bytecode.m_symbolTableOrScopeDepth.scopeDepth(), scope, ident, Put, bytecode.m_getPutInfo.resolveType(), bytecode.m_getPutInfo.initializationMode());</span>
              RETURN_IF_EXCEPTION(throwScope, false);
  
              metadata.m_getPutInfo = GetPutInfo(bytecode.m_getPutInfo.resolveMode(), op.type, bytecode.m_getPutInfo.initializationMode());
              if (op.type == GlobalVar || op.type == GlobalVarWithVarInjectionChecks || op.type == GlobalLexicalVar || op.type == GlobalLexicalVarWithVarInjectionChecks)
                  metadata.m_watchpointSet = op.watchpointSet;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 685,11 ***</span>
              case ProfileTypeBytecodeClosureVar: {
                  const Identifier&amp; ident = identifier(bytecode.m_identifier);
                  unsigned localScopeDepth = bytecode.m_symbolTableOrScopeDepth.scopeDepth();
                  // Even though type profiling may be profiling either a Get or a Put, we can always claim a Get because
                  // we&#39;re abstractly &quot;read&quot;ing from a JSScope.
<span class="line-modified">!                 ResolveOp op = JSScope::abstractResolve(m_globalObject-&gt;globalExec(), localScopeDepth, scope, ident, Get, bytecode.m_resolveType, InitializationMode::NotInitialization);</span>
                  RETURN_IF_EXCEPTION(throwScope, false);
  
                  if (op.type == ClosureVar || op.type == ModuleVar)
                      symbolTable = op.lexicalEnvironment-&gt;symbolTable();
                  else if (op.type == GlobalVar)
<span class="line-new-header">--- 688,11 ---</span>
              case ProfileTypeBytecodeClosureVar: {
                  const Identifier&amp; ident = identifier(bytecode.m_identifier);
                  unsigned localScopeDepth = bytecode.m_symbolTableOrScopeDepth.scopeDepth();
                  // Even though type profiling may be profiling either a Get or a Put, we can always claim a Get because
                  // we&#39;re abstractly &quot;read&quot;ing from a JSScope.
<span class="line-modified">!                 ResolveOp op = JSScope::abstractResolve(m_globalObject.get(), localScopeDepth, scope, ident, Get, bytecode.m_resolveType, InitializationMode::NotInitialization);</span>
                  RETURN_IF_EXCEPTION(throwScope, false);
  
                  if (op.type == ClosureVar || op.type == ModuleVar)
                      symbolTable = op.lexicalEnvironment-&gt;symbolTable();
                  else if (op.type == GlobalVar)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 706,12 ***</span>
                      globalVariableID = TypeProfilerNoGlobalIDExists;
  
                  break;
              }
              case ProfileTypeBytecodeLocallyResolved: {
<span class="line-modified">!                 int symbolTableIndex = bytecode.m_symbolTableOrScopeDepth.symbolTable().offset();</span>
<span class="line-removed">-                 SymbolTable* symbolTable = jsCast&lt;SymbolTable*&gt;(getConstant(symbolTableIndex));</span>
                  const Identifier&amp; ident = identifier(bytecode.m_identifier);
                  ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
                  // If our parent scope was created while profiling was disabled, it will not have prepared for profiling yet.
                  globalVariableID = symbolTable-&gt;uniqueIDForVariable(locker, ident.impl(), vm);
                  globalTypeSet = symbolTable-&gt;globalTypeSetForVariable(locker, ident.impl(), vm);
<span class="line-new-header">--- 709,11 ---</span>
                      globalVariableID = TypeProfilerNoGlobalIDExists;
  
                  break;
              }
              case ProfileTypeBytecodeLocallyResolved: {
<span class="line-modified">!                 SymbolTable* symbolTable = jsCast&lt;SymbolTable*&gt;(getConstant(bytecode.m_symbolTableOrScopeDepth.symbolTable()));</span>
                  const Identifier&amp; ident = identifier(bytecode.m_identifier);
                  ConcurrentJSLocker locker(symbolTable-&gt;m_lock);
                  // If our parent scope was created while profiling was disabled, it will not have prepared for profiling yet.
                  globalVariableID = symbolTable-&gt;uniqueIDForVariable(locker, ident.impl(), vm);
                  globalTypeSet = symbolTable-&gt;globalTypeSetForVariable(locker, ident.impl(), vm);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 754,11 ***</span>
              metadata.m_typeLocation = location;
              break;
          }
  
          case op_debug: {
<span class="line-modified">!             if (instruction-&gt;as&lt;OpDebug&gt;().m_debugHookType == DidReachBreakpoint)</span>
                  m_hasDebuggerStatement = true;
              break;
          }
  
          case op_create_rest: {
<span class="line-new-header">--- 756,11 ---</span>
              metadata.m_typeLocation = location;
              break;
          }
  
          case op_debug: {
<span class="line-modified">!             if (instruction-&gt;as&lt;OpDebug&gt;().m_debugHookType == DidReachDebuggerStatement)</span>
                  m_hasDebuggerStatement = true;
              break;
          }
  
          case op_create_rest: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 863,72 ***</span>
          }
      }
  #endif // ENABLE(JIT)
  }
  
<span class="line-modified">! void CodeBlock::setConstantIdentifierSetRegisters(VM&amp; vm, const Vector&lt;ConstantIdentifierSetEntry&gt;&amp; constants)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSGlobalObject* globalObject = m_globalObject.get();
<span class="line-removed">-     ExecState* exec = globalObject-&gt;globalExec();</span>
  
      for (const auto&amp; entry : constants) {
          const IdentifierSet&amp; set = entry.first;
  
          Structure* setStructure = globalObject-&gt;setStructure();
          RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">!         JSSet* jsSet = JSSet::create(exec, vm, setStructure, set.size());</span>
          RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!         for (auto setEntry : set) {</span>
              JSString* jsString = jsOwnedString(vm, setEntry.get());
<span class="line-modified">!             jsSet-&gt;add(exec, jsString);</span>
              RETURN_IF_EXCEPTION(scope, void());
          }
          m_constantRegisters[entry.second].set(vm, this, jsSet);
      }
  }
  
<span class="line-modified">! void CodeBlock::setConstantRegisters(const Vector&lt;WriteBarrier&lt;Unknown&gt;&gt;&amp; constants, const Vector&lt;SourceCodeRepresentation&gt;&amp; constantsSourceCodeRepresentation, ScriptExecutable* topLevelExecutable)</span>
  {
      VM&amp; vm = *m_vm;
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSGlobalObject* globalObject = m_globalObject.get();
<span class="line-removed">-     ExecState* exec = globalObject-&gt;globalExec();</span>
  
      ASSERT(constants.size() == constantsSourceCodeRepresentation.size());
      size_t count = constants.size();
<span class="line-modified">!     m_constantRegisters.resizeToFit(count);</span>
      for (size_t i = 0; i &lt; count; i++) {
          JSValue constant = constants[i].get();
<span class="line-modified">! </span>
<span class="line-modified">!         if (!constant.isEmpty()) {</span>
<span class="line-modified">!             if (constant.isCell()) {</span>
<span class="line-modified">!                 JSCell* cell = constant.asCell();</span>
<span class="line-modified">!                 if (SymbolTable* symbolTable = jsDynamicCast&lt;SymbolTable*&gt;(vm, cell)) {</span>
<span class="line-modified">!                     if (m_unlinkedCode-&gt;wasCompiledWithTypeProfilerOpcodes()) {</span>
<span class="line-modified">!                         ConcurrentJSLocker locker(symbolTable-&gt;m_lock);</span>
<span class="line-modified">!                         symbolTable-&gt;prepareForTypeProfiling(locker);</span>
                      }
<span class="line-removed">- </span>
<span class="line-removed">-                     SymbolTable* clone = symbolTable-&gt;cloneScopePart(vm);</span>
<span class="line-removed">-                     if (wasCompiledWithDebuggingOpcodes())</span>
<span class="line-removed">-                         clone-&gt;setRareDataCodeBlock(this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     constant = clone;</span>
<span class="line-removed">-                 } else if (auto* descriptor = jsDynamicCast&lt;JSTemplateObjectDescriptor*&gt;(vm, cell)) {</span>
<span class="line-removed">-                     auto* templateObject = topLevelExecutable-&gt;createTemplateObject(exec, descriptor);</span>
<span class="line-removed">-                     RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-removed">-                     constant = templateObject;</span>
                  }
              }
          }
<span class="line-removed">- </span>
          m_constantRegisters[i].set(vm, this, constant);
      }
<span class="line-removed">- </span>
<span class="line-removed">-     m_constantsSourceCodeRepresentation = constantsSourceCodeRepresentation;</span>
  }
  
  void CodeBlock::setAlternative(VM&amp; vm, CodeBlock* alternative)
  {
      RELEASE_ASSERT(alternative);
<span class="line-new-header">--- 865,81 ---</span>
          }
      }
  #endif // ENABLE(JIT)
  }
  
<span class="line-modified">! void CodeBlock::setConstantIdentifierSetRegisters(VM&amp; vm, const RefCountedArray&lt;ConstantIdentifierSetEntry&gt;&amp; constants)</span>
  {
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSGlobalObject* globalObject = m_globalObject.get();
  
      for (const auto&amp; entry : constants) {
          const IdentifierSet&amp; set = entry.first;
  
          Structure* setStructure = globalObject-&gt;setStructure();
          RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">!         JSSet* jsSet = JSSet::create(globalObject, vm, setStructure, set.size());</span>
          RETURN_IF_EXCEPTION(scope, void());
  
<span class="line-modified">!         for (const auto&amp; setEntry : set) {</span>
              JSString* jsString = jsOwnedString(vm, setEntry.get());
<span class="line-modified">!             jsSet-&gt;add(globalObject, jsString);</span>
              RETURN_IF_EXCEPTION(scope, void());
          }
          m_constantRegisters[entry.second].set(vm, this, jsSet);
      }
  }
  
<span class="line-modified">! void CodeBlock::setConstantRegisters(const RefCountedArray&lt;WriteBarrier&lt;Unknown&gt;&gt;&amp; constants, const RefCountedArray&lt;SourceCodeRepresentation&gt;&amp; constantsSourceCodeRepresentation, ScriptExecutable* topLevelExecutable)</span>
  {
      VM&amp; vm = *m_vm;
      auto scope = DECLARE_THROW_SCOPE(vm);
      JSGlobalObject* globalObject = m_globalObject.get();
  
      ASSERT(constants.size() == constantsSourceCodeRepresentation.size());
      size_t count = constants.size();
<span class="line-modified">!     {</span>
<span class="line-added">+         ConcurrentJSLocker locker(m_lock);</span>
<span class="line-added">+         m_constantRegisters.resizeToFit(count);</span>
<span class="line-added">+         m_constantsSourceCodeRepresentation.resizeToFit(count);</span>
<span class="line-added">+     }</span>
      for (size_t i = 0; i &lt; count; i++) {
          JSValue constant = constants[i].get();
<span class="line-modified">!         SourceCodeRepresentation representation = constantsSourceCodeRepresentation[i];</span>
<span class="line-modified">!         m_constantsSourceCodeRepresentation[i] = representation;</span>
<span class="line-modified">!         switch (representation) {</span>
<span class="line-modified">!         case SourceCodeRepresentation::LinkTimeConstant:</span>
<span class="line-modified">!             constant = globalObject-&gt;linkTimeConstant(static_cast&lt;LinkTimeConstant&gt;(constant.asInt32AsAnyInt()));</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case SourceCodeRepresentation::Other:</span>
<span class="line-modified">!         case SourceCodeRepresentation::Integer:</span>
<span class="line-added">+         case SourceCodeRepresentation::Double:</span>
<span class="line-added">+             if (!constant.isEmpty()) {</span>
<span class="line-added">+                 if (constant.isCell()) {</span>
<span class="line-added">+                     JSCell* cell = constant.asCell();</span>
<span class="line-added">+                     if (SymbolTable* symbolTable = jsDynamicCast&lt;SymbolTable*&gt;(vm, cell)) {</span>
<span class="line-added">+                         if (m_unlinkedCode-&gt;wasCompiledWithTypeProfilerOpcodes()) {</span>
<span class="line-added">+                             ConcurrentJSLocker locker(symbolTable-&gt;m_lock);</span>
<span class="line-added">+                             symbolTable-&gt;prepareForTypeProfiling(locker);</span>
<span class="line-added">+                         }</span>
<span class="line-added">+ </span>
<span class="line-added">+                         SymbolTable* clone = symbolTable-&gt;cloneScopePart(vm);</span>
<span class="line-added">+                         if (wasCompiledWithDebuggingOpcodes())</span>
<span class="line-added">+                             clone-&gt;setRareDataCodeBlock(this);</span>
<span class="line-added">+ </span>
<span class="line-added">+                         constant = clone;</span>
<span class="line-added">+                     } else if (auto* descriptor = jsDynamicCast&lt;JSTemplateObjectDescriptor*&gt;(vm, cell)) {</span>
<span class="line-added">+                         auto* templateObject = topLevelExecutable-&gt;createTemplateObject(globalObject, descriptor);</span>
<span class="line-added">+                         RETURN_IF_EXCEPTION(scope, void());</span>
<span class="line-added">+                         constant = templateObject;</span>
                      }
                  }
              }
<span class="line-added">+             break;</span>
          }
          m_constantRegisters[i].set(vm, this, constant);
      }
  }
  
  void CodeBlock::setAlternative(VM&amp; vm, CodeBlock* alternative)
  {
      RELEASE_ASSERT(alternative);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1075,37 ***</span>
      if (!vm.heap.isMarked(transition.m_from.get()))
          return false;
  
      return true;
  }
  #endif // ENABLE(DFG_JIT)
  
  void CodeBlock::propagateTransitions(const ConcurrentJSLocker&amp;, SlotVisitor&amp; visitor)
  {
<span class="line-removed">-     UNUSED_PARAM(visitor);</span>
<span class="line-removed">- </span>
      VM&amp; vm = *m_vm;
  
      if (jitType() == JITType::InterpreterThunk) {
<span class="line-modified">!         const Vector&lt;InstructionStream::Offset&gt;&amp; propertyAccessInstructions = m_unlinkedCode-&gt;propertyAccessInstructions();</span>
<span class="line-modified">!         const InstructionStream&amp; instructionStream = instructions();</span>
<span class="line-removed">-         for (size_t i = 0; i &lt; propertyAccessInstructions.size(); ++i) {</span>
<span class="line-removed">-             auto instruction = instructionStream.at(propertyAccessInstructions[i]);</span>
<span class="line-removed">-             if (instruction-&gt;is&lt;OpPutById&gt;()) {</span>
<span class="line-removed">-                 auto&amp; metadata = instruction-&gt;as&lt;OpPutById&gt;().metadata(this);</span>
                  StructureID oldStructureID = metadata.m_oldStructureID;
                  StructureID newStructureID = metadata.m_newStructureID;
                  if (!oldStructureID || !newStructureID)
<span class="line-modified">!                     continue;</span>
                  Structure* oldStructure =
                      vm.heap.structureIDTable().get(oldStructureID);
                  Structure* newStructure =
                      vm.heap.structureIDTable().get(newStructureID);
                  if (vm.heap.isMarked(oldStructure))
                      visitor.appendUnbarriered(newStructure);
<span class="line-modified">!                 continue;</span>
<span class="line-removed">-             }</span>
          }
      }
  
  #if ENABLE(JIT)
      if (JITCode::isJIT(jitType())) {
<span class="line-new-header">--- 1086,39 ---</span>
      if (!vm.heap.isMarked(transition.m_from.get()))
          return false;
  
      return true;
  }
<span class="line-added">+ </span>
<span class="line-added">+ BytecodeIndex CodeBlock::bytecodeIndexForExit(BytecodeIndex exitIndex) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (exitIndex.checkpoint()) {</span>
<span class="line-added">+         const auto&amp; instruction = instructions().at(exitIndex);</span>
<span class="line-added">+         exitIndex = instruction.next().index();</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return exitIndex;</span>
<span class="line-added">+ }</span>
  #endif // ENABLE(DFG_JIT)
  
  void CodeBlock::propagateTransitions(const ConcurrentJSLocker&amp;, SlotVisitor&amp; visitor)
  {
      VM&amp; vm = *m_vm;
  
      if (jitType() == JITType::InterpreterThunk) {
<span class="line-modified">!         if (m_metadata) {</span>
<span class="line-modified">!             m_metadata-&gt;forEach&lt;OpPutById&gt;([&amp;] (auto&amp; metadata) {</span>
                  StructureID oldStructureID = metadata.m_oldStructureID;
                  StructureID newStructureID = metadata.m_newStructureID;
                  if (!oldStructureID || !newStructureID)
<span class="line-modified">!                     return;</span>
                  Structure* oldStructure =
                      vm.heap.structureIDTable().get(oldStructureID);
                  Structure* newStructure =
                      vm.heap.structureIDTable().get(newStructureID);
                  if (vm.heap.isMarked(oldStructure))
                      visitor.appendUnbarriered(newStructure);
<span class="line-modified">!             });</span>
          }
      }
  
  #if ENABLE(JIT)
      if (JITCode::isJIT(jitType())) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1120,12 ***</span>
      if (JITCode::isOptimizingJIT(jitType())) {
          DFG::CommonData* dfgCommon = m_jitCode-&gt;dfgCommon();
  
          dfgCommon-&gt;recordedStatuses.markIfCheap(visitor);
  
<span class="line-modified">!         for (auto&amp; weakReference : dfgCommon-&gt;weakStructureReferences)</span>
<span class="line-modified">!             weakReference-&gt;markIfCheap(visitor);</span>
  
          for (auto&amp; transition : dfgCommon-&gt;transitions) {
              if (shouldMarkTransition(vm, transition)) {
                  // If the following three things are live, then the target of the
                  // transition is also live:
<span class="line-new-header">--- 1133,12 ---</span>
      if (JITCode::isOptimizingJIT(jitType())) {
          DFG::CommonData* dfgCommon = m_jitCode-&gt;dfgCommon();
  
          dfgCommon-&gt;recordedStatuses.markIfCheap(visitor);
  
<span class="line-modified">!         for (StructureID structureID : dfgCommon-&gt;weakStructureReferences)</span>
<span class="line-modified">!             vm.getStructure(structureID)-&gt;markIfCheap(visitor);</span>
  
          for (auto&amp; transition : dfgCommon-&gt;transitions) {
              if (shouldMarkTransition(vm, transition)) {
                  // If the following three things are live, then the target of the
                  // transition is also live:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1180,12 ***</span>
              allAreLiveSoFar = false;
              break;
          }
      }
      if (allAreLiveSoFar) {
<span class="line-modified">!         for (unsigned i = 0; i &lt; dfgCommon-&gt;weakStructureReferences.size(); ++i) {</span>
<span class="line-modified">!             if (!vm.heap.isMarked(dfgCommon-&gt;weakStructureReferences[i].get())) {</span>
                  allAreLiveSoFar = false;
                  break;
              }
          }
      }
<span class="line-new-header">--- 1193,13 ---</span>
              allAreLiveSoFar = false;
              break;
          }
      }
      if (allAreLiveSoFar) {
<span class="line-modified">!         for (StructureID structureID : dfgCommon-&gt;weakStructureReferences) {</span>
<span class="line-modified">!             Structure* structure = vm.getStructure(structureID);</span>
<span class="line-added">+             if (!vm.heap.isMarked(structure)) {</span>
                  allAreLiveSoFar = false;
                  break;
              }
          }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1202,132 ***</span>
  }
  
  void CodeBlock::finalizeLLIntInlineCaches()
  {
      VM&amp; vm = *m_vm;
<span class="line-removed">-     const Vector&lt;InstructionStream::Offset&gt;&amp; propertyAccessInstructions = m_unlinkedCode-&gt;propertyAccessInstructions();</span>
  
<span class="line-modified">!     auto handleGetPutFromScope = [&amp;] (auto&amp; metadata) {</span>
<span class="line-modified">!         GetPutInfo getPutInfo = metadata.m_getPutInfo;</span>
<span class="line-modified">!         if (getPutInfo.resolveType() == GlobalVar || getPutInfo.resolveType() == GlobalVarWithVarInjectionChecks</span>
<span class="line-removed">-             || getPutInfo.resolveType() == LocalClosureVar || getPutInfo.resolveType() == GlobalLexicalVar || getPutInfo.resolveType() == GlobalLexicalVarWithVarInjectionChecks)</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         WriteBarrierBase&lt;Structure&gt;&amp; structure = metadata.m_structure;</span>
<span class="line-removed">-         if (!structure || vm.heap.isMarked(structure.get()))</span>
<span class="line-removed">-             return;</span>
<span class="line-removed">-         if (Options::verboseOSR())</span>
<span class="line-removed">-             dataLogF(&quot;Clearing scope access with structure %p.\n&quot;, structure.get());</span>
<span class="line-removed">-         structure.clear();</span>
<span class="line-removed">-     };</span>
  
<span class="line-modified">!     const InstructionStream&amp; instructionStream = instructions();</span>
<span class="line-removed">-     for (size_t size = propertyAccessInstructions.size(), i = 0; i &lt; size; ++i) {</span>
<span class="line-removed">-         const auto curInstruction = instructionStream.at(propertyAccessInstructions[i]);</span>
<span class="line-removed">-         switch (curInstruction-&gt;opcodeID()) {</span>
<span class="line-removed">-         case op_get_by_id: {</span>
<span class="line-removed">-             auto&amp; metadata = curInstruction-&gt;as&lt;OpGetById&gt;().metadata(this);</span>
              if (metadata.m_modeMetadata.mode != GetByIdMode::Default)
<span class="line-modified">!                 break;</span>
              StructureID oldStructureID = metadata.m_modeMetadata.defaultMode.structureID;
              if (!oldStructureID || vm.heap.isMarked(vm.heap.structureIDTable().get(oldStructureID)))
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             if (Options::verboseOSR())</span>
<span class="line-removed">-                 dataLogF(&quot;Clearing LLInt property access.\n&quot;);</span>
              LLIntPrototypeLoadAdaptiveStructureWatchpoint::clearLLIntGetByIdCache(metadata);
<span class="line-modified">!             break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case op_get_by_id_direct: {</span>
<span class="line-removed">-             auto&amp; metadata = curInstruction-&gt;as&lt;OpGetByIdDirect&gt;().metadata(this);</span>
              StructureID oldStructureID = metadata.m_structureID;
              if (!oldStructureID || vm.heap.isMarked(vm.heap.structureIDTable().get(oldStructureID)))
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             if (Options::verboseOSR())</span>
<span class="line-removed">-                 dataLogF(&quot;Clearing LLInt property access.\n&quot;);</span>
              metadata.m_structureID = 0;
              metadata.m_offset = 0;
<span class="line-modified">!             break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case op_put_by_id: {</span>
<span class="line-removed">-             auto&amp; metadata = curInstruction-&gt;as&lt;OpPutById&gt;().metadata(this);</span>
              StructureID oldStructureID = metadata.m_oldStructureID;
              StructureID newStructureID = metadata.m_newStructureID;
              StructureChain* chain = metadata.m_structureChain.get();
              if ((!oldStructureID || vm.heap.isMarked(vm.heap.structureIDTable().get(oldStructureID)))
                  &amp;&amp; (!newStructureID || vm.heap.isMarked(vm.heap.structureIDTable().get(newStructureID)))
                  &amp;&amp; (!chain || vm.heap.isMarked(chain)))
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             if (Options::verboseOSR())</span>
<span class="line-removed">-                 dataLogF(&quot;Clearing LLInt put transition.\n&quot;);</span>
              metadata.m_oldStructureID = 0;
              metadata.m_offset = 0;
              metadata.m_newStructureID = 0;
              metadata.m_structureChain.clear();
<span class="line-modified">!             break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=166418</span>
<span class="line-removed">-         // We need to add optimizations for op_resolve_scope_for_hoisting_func_decl_in_eval to do link time scope resolution.</span>
<span class="line-removed">-         case op_resolve_scope_for_hoisting_func_decl_in_eval:</span>
<span class="line-removed">-             break;</span>
<span class="line-removed">-         case op_to_this: {</span>
<span class="line-removed">-             auto&amp; metadata = curInstruction-&gt;as&lt;OpToThis&gt;().metadata(this);</span>
              if (!metadata.m_cachedStructureID || vm.heap.isMarked(vm.heap.structureIDTable().get(metadata.m_cachedStructureID)))
<span class="line-modified">!                 break;</span>
              if (Options::verboseOSR()) {
                  Structure* structure = vm.heap.structureIDTable().get(metadata.m_cachedStructureID);
                  dataLogF(&quot;Clearing LLInt to_this with structure %p.\n&quot;, structure);
              }
              metadata.m_cachedStructureID = 0;
              metadata.m_toThisStatus = merge(metadata.m_toThisStatus, ToThisClearedByGC);
<span class="line-modified">!             break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case op_create_this: {</span>
<span class="line-removed">-             auto&amp; metadata = curInstruction-&gt;as&lt;OpCreateThis&gt;().metadata(this);</span>
              auto&amp; cacheWriteBarrier = metadata.m_cachedCallee;
              if (!cacheWriteBarrier || cacheWriteBarrier.unvalidatedGet() == JSCell::seenMultipleCalleeObjects())
<span class="line-modified">!                 break;</span>
              JSCell* cachedFunction = cacheWriteBarrier.get();
              if (vm.heap.isMarked(cachedFunction))
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             if (Options::verboseOSR())</span>
<span class="line-removed">-                 dataLogF(&quot;Clearing LLInt create_this with cached callee %p.\n&quot;, cachedFunction);</span>
              cacheWriteBarrier.clear();
<span class="line-modified">!             break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case op_resolve_scope: {</span>
              // Right now this isn&#39;t strictly necessary. Any symbol tables that this will refer to
              // are for outer functions, and we refer to those functions strongly, and they refer
              // to the symbol table strongly. But it&#39;s nice to be on the safe side.
<span class="line-removed">-             auto&amp; metadata = curInstruction-&gt;as&lt;OpResolveScope&gt;().metadata(this);</span>
              WriteBarrierBase&lt;SymbolTable&gt;&amp; symbolTable = metadata.m_symbolTable;
              if (!symbolTable || vm.heap.isMarked(symbolTable.get()))
<span class="line-modified">!                 break;</span>
<span class="line-modified">!             if (Options::verboseOSR())</span>
<span class="line-removed">-                 dataLogF(&quot;Clearing dead symbolTable %p.\n&quot;, symbolTable.get());</span>
              symbolTable.clear();
<span class="line-modified">!             break;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         case op_get_from_scope:</span>
<span class="line-modified">!             handleGetPutFromScope(curInstruction-&gt;as&lt;OpGetFromScope&gt;().metadata(this));</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         case op_put_to_scope:</span>
<span class="line-modified">!             handleGetPutFromScope(curInstruction-&gt;as&lt;OpPutToScope&gt;().metadata(this));</span>
<span class="line-modified">!             break;</span>
<span class="line-modified">!         default:</span>
<span class="line-modified">!             OpcodeID opcodeID = curInstruction-&gt;opcodeID();</span>
<span class="line-modified">!             ASSERT_WITH_MESSAGE_UNUSED(opcodeID, false, &quot;Unhandled opcode in CodeBlock::finalizeUnconditionally, %s(%d) at bc %u&quot;, opcodeNames[opcodeID], opcodeID, propertyAccessInstructions[i]);</span>
<span class="line-modified">!         }</span>
      }
  
      // We can&#39;t just remove all the sets when we clear the caches since we might have created a watchpoint set
      // then cleared the cache without GCing in between.
      m_llintGetByIdWatchpointMap.removeIf([&amp;] (const StructureWatchpointMap::KeyValuePairType&amp; pair) -&gt; bool {
          auto clear = [&amp;] () {
              auto&amp; instruction = instructions().at(std::get&lt;1&gt;(pair.key));
              OpcodeID opcode = instruction-&gt;opcodeID();
              if (opcode == op_get_by_id) {
<span class="line-modified">!                 if (Options::verboseOSR())</span>
<span class="line-removed">-                     dataLogF(&quot;Clearing LLInt property access.\n&quot;);</span>
                  LLIntPrototypeLoadAdaptiveStructureWatchpoint::clearLLIntGetByIdCache(instruction-&gt;as&lt;OpGetById&gt;().metadata(this));
              }
              return true;
          };
  
<span class="line-new-header">--- 1216,119 ---</span>
  }
  
  void CodeBlock::finalizeLLIntInlineCaches()
  {
      VM&amp; vm = *m_vm;
  
<span class="line-modified">!     if (m_metadata) {</span>
<span class="line-modified">!         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=166418</span>
<span class="line-modified">!         // We need to add optimizations for op_resolve_scope_for_hoisting_func_decl_in_eval to do link time scope resolution.</span>
  
<span class="line-modified">!         m_metadata-&gt;forEach&lt;OpGetById&gt;([&amp;] (auto&amp; metadata) {</span>
              if (metadata.m_modeMetadata.mode != GetByIdMode::Default)
<span class="line-modified">!                 return;</span>
              StructureID oldStructureID = metadata.m_modeMetadata.defaultMode.structureID;
              if (!oldStructureID || vm.heap.isMarked(vm.heap.structureIDTable().get(oldStructureID)))
<span class="line-modified">!                 return;</span>
<span class="line-modified">!             dataLogLnIf(Options::verboseOSR(), &quot;Clearing LLInt property access.&quot;);</span>
              LLIntPrototypeLoadAdaptiveStructureWatchpoint::clearLLIntGetByIdCache(metadata);
<span class="line-modified">!         });</span>
<span class="line-modified">! </span>
<span class="line-modified">!         m_metadata-&gt;forEach&lt;OpGetByIdDirect&gt;([&amp;] (auto&amp; metadata) {</span>
              StructureID oldStructureID = metadata.m_structureID;
              if (!oldStructureID || vm.heap.isMarked(vm.heap.structureIDTable().get(oldStructureID)))
<span class="line-modified">!                 return;</span>
<span class="line-modified">!             dataLogLnIf(Options::verboseOSR(), &quot;Clearing LLInt property access.&quot;);</span>
              metadata.m_structureID = 0;
              metadata.m_offset = 0;
<span class="line-modified">!         });</span>
<span class="line-modified">! </span>
<span class="line-modified">!         m_metadata-&gt;forEach&lt;OpPutById&gt;([&amp;] (auto&amp; metadata) {</span>
              StructureID oldStructureID = metadata.m_oldStructureID;
              StructureID newStructureID = metadata.m_newStructureID;
              StructureChain* chain = metadata.m_structureChain.get();
              if ((!oldStructureID || vm.heap.isMarked(vm.heap.structureIDTable().get(oldStructureID)))
                  &amp;&amp; (!newStructureID || vm.heap.isMarked(vm.heap.structureIDTable().get(newStructureID)))
                  &amp;&amp; (!chain || vm.heap.isMarked(chain)))
<span class="line-modified">!                 return;</span>
<span class="line-modified">!             dataLogLnIf(Options::verboseOSR(), &quot;Clearing LLInt put transition.&quot;);</span>
              metadata.m_oldStructureID = 0;
              metadata.m_offset = 0;
              metadata.m_newStructureID = 0;
              metadata.m_structureChain.clear();
<span class="line-modified">!         });</span>
<span class="line-modified">! </span>
<span class="line-modified">!         m_metadata-&gt;forEach&lt;OpToThis&gt;([&amp;] (auto&amp; metadata) {</span>
              if (!metadata.m_cachedStructureID || vm.heap.isMarked(vm.heap.structureIDTable().get(metadata.m_cachedStructureID)))
<span class="line-modified">!                 return;</span>
              if (Options::verboseOSR()) {
                  Structure* structure = vm.heap.structureIDTable().get(metadata.m_cachedStructureID);
                  dataLogF(&quot;Clearing LLInt to_this with structure %p.\n&quot;, structure);
              }
              metadata.m_cachedStructureID = 0;
              metadata.m_toThisStatus = merge(metadata.m_toThisStatus, ToThisClearedByGC);
<span class="line-modified">!         });</span>
<span class="line-modified">! </span>
<span class="line-modified">!         auto handleCreateBytecode = [&amp;] (auto&amp; metadata, ASCIILiteral name) {</span>
              auto&amp; cacheWriteBarrier = metadata.m_cachedCallee;
              if (!cacheWriteBarrier || cacheWriteBarrier.unvalidatedGet() == JSCell::seenMultipleCalleeObjects())
<span class="line-modified">!                 return;</span>
              JSCell* cachedFunction = cacheWriteBarrier.get();
              if (vm.heap.isMarked(cachedFunction))
<span class="line-modified">!                 return;</span>
<span class="line-modified">!             dataLogLnIf(Options::verboseOSR(), &quot;Clearing LLInt &quot;, name, &quot; with cached callee &quot;, RawPointer(cachedFunction), &quot;.&quot;);</span>
              cacheWriteBarrier.clear();
<span class="line-modified">!         };</span>
<span class="line-modified">! </span>
<span class="line-modified">!         m_metadata-&gt;forEach&lt;OpCreateThis&gt;([&amp;] (auto&amp; metadata) {</span>
<span class="line-added">+             handleCreateBytecode(metadata, &quot;op_create_this&quot;_s);</span>
<span class="line-added">+         });</span>
<span class="line-added">+         m_metadata-&gt;forEach&lt;OpCreatePromise&gt;([&amp;] (auto&amp; metadata) {</span>
<span class="line-added">+             handleCreateBytecode(metadata, &quot;op_create_promise&quot;_s);</span>
<span class="line-added">+         });</span>
<span class="line-added">+         m_metadata-&gt;forEach&lt;OpCreateGenerator&gt;([&amp;] (auto&amp; metadata) {</span>
<span class="line-added">+             handleCreateBytecode(metadata, &quot;op_create_generator&quot;_s);</span>
<span class="line-added">+         });</span>
<span class="line-added">+         m_metadata-&gt;forEach&lt;OpCreateAsyncGenerator&gt;([&amp;] (auto&amp; metadata) {</span>
<span class="line-added">+             handleCreateBytecode(metadata, &quot;op_create_async_generator&quot;_s);</span>
<span class="line-added">+         });</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_metadata-&gt;forEach&lt;OpResolveScope&gt;([&amp;] (auto&amp; metadata) {</span>
              // Right now this isn&#39;t strictly necessary. Any symbol tables that this will refer to
              // are for outer functions, and we refer to those functions strongly, and they refer
              // to the symbol table strongly. But it&#39;s nice to be on the safe side.
              WriteBarrierBase&lt;SymbolTable&gt;&amp; symbolTable = metadata.m_symbolTable;
              if (!symbolTable || vm.heap.isMarked(symbolTable.get()))
<span class="line-modified">!                 return;</span>
<span class="line-modified">!             dataLogLnIf(Options::verboseOSR(), &quot;Clearing dead symbolTable &quot;, RawPointer(symbolTable.get()));</span>
              symbolTable.clear();
<span class="line-modified">!         });</span>
<span class="line-modified">! </span>
<span class="line-modified">!         auto handleGetPutFromScope = [&amp;] (auto&amp; metadata) {</span>
<span class="line-modified">!             GetPutInfo getPutInfo = metadata.m_getPutInfo;</span>
<span class="line-modified">!             if (getPutInfo.resolveType() == GlobalVar || getPutInfo.resolveType() == GlobalVarWithVarInjectionChecks</span>
<span class="line-modified">!                 || getPutInfo.resolveType() == LocalClosureVar || getPutInfo.resolveType() == GlobalLexicalVar || getPutInfo.resolveType() == GlobalLexicalVarWithVarInjectionChecks)</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!             WriteBarrierBase&lt;Structure&gt;&amp; structure = metadata.m_structure;</span>
<span class="line-modified">!             if (!structure || vm.heap.isMarked(structure.get()))</span>
<span class="line-modified">!                 return;</span>
<span class="line-modified">!             dataLogLnIf(Options::verboseOSR(), &quot;Clearing scope access with structure &quot;, RawPointer(structure.get()));</span>
<span class="line-modified">!             structure.clear();</span>
<span class="line-added">+         };</span>
<span class="line-added">+ </span>
<span class="line-added">+         m_metadata-&gt;forEach&lt;OpGetFromScope&gt;(handleGetPutFromScope);</span>
<span class="line-added">+         m_metadata-&gt;forEach&lt;OpPutToScope&gt;(handleGetPutFromScope);</span>
      }
  
      // We can&#39;t just remove all the sets when we clear the caches since we might have created a watchpoint set
      // then cleared the cache without GCing in between.
      m_llintGetByIdWatchpointMap.removeIf([&amp;] (const StructureWatchpointMap::KeyValuePairType&amp; pair) -&gt; bool {
          auto clear = [&amp;] () {
              auto&amp; instruction = instructions().at(std::get&lt;1&gt;(pair.key));
              OpcodeID opcode = instruction-&gt;opcodeID();
              if (opcode == op_get_by_id) {
<span class="line-modified">!                 dataLogLnIf(Options::verboseOSR(), &quot;Clearing LLInt property access.&quot;);</span>
                  LLIntPrototypeLoadAdaptiveStructureWatchpoint::clearLLIntGetByIdCache(instruction-&gt;as&lt;OpGetById&gt;().metadata(this));
              }
              return true;
          };
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1342,12 ***</span>
          return false;
      });
  
      forEachLLIntCallLinkInfo([&amp;](LLIntCallLinkInfo&amp; callLinkInfo) {
          if (callLinkInfo.isLinked() &amp;&amp; !vm.heap.isMarked(callLinkInfo.callee())) {
<span class="line-modified">!             if (Options::verboseOSR())</span>
<span class="line-removed">-                 dataLog(&quot;Clearing LLInt call from &quot;, *this, &quot;\n&quot;);</span>
              callLinkInfo.unlink();
          }
          if (callLinkInfo.lastSeenCallee() &amp;&amp; !vm.heap.isMarked(callLinkInfo.lastSeenCallee()))
              callLinkInfo.clearLastSeenCallee();
      });
<span class="line-new-header">--- 1343,11 ---</span>
          return false;
      });
  
      forEachLLIntCallLinkInfo([&amp;](LLIntCallLinkInfo&amp; callLinkInfo) {
          if (callLinkInfo.isLinked() &amp;&amp; !vm.heap.isMarked(callLinkInfo.callee())) {
<span class="line-modified">!             dataLogLnIf(Options::verboseOSR(), &quot;Clearing LLInt call from &quot;, *this);</span>
              callLinkInfo.unlink();
          }
          if (callLinkInfo.lastSeenCallee() &amp;&amp; !vm.heap.isMarked(callLinkInfo.lastSeenCallee()))
              callLinkInfo.clearLastSeenCallee();
      });
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1355,11 ***</span>
  
  #if ENABLE(JIT)
  CodeBlock::JITData&amp; CodeBlock::ensureJITDataSlow(const ConcurrentJSLocker&amp;)
  {
      ASSERT(!m_jitData);
<span class="line-modified">!     m_jitData = makeUnique&lt;JITData&gt;();</span>
      return *m_jitData;
  }
  
  void CodeBlock::finalizeBaselineJITInlineCaches()
  {
<span class="line-new-header">--- 1355,15 ---</span>
  
  #if ENABLE(JIT)
  CodeBlock::JITData&amp; CodeBlock::ensureJITDataSlow(const ConcurrentJSLocker&amp;)
  {
      ASSERT(!m_jitData);
<span class="line-modified">!     auto jitData = makeUnique&lt;JITData&gt;();</span>
<span class="line-added">+     // calleeSaveRegisters() can access m_jitData without taking a lock from Baseline JIT. This is OK since JITData::m_calleeSaveRegisters is filled in DFG and FTL CodeBlocks.</span>
<span class="line-added">+     // But we should not see garbage pointer in that case. We ensure JITData::m_calleeSaveRegisters is initialized as nullptr before exposing it to BaselineJIT by store-store-fence.</span>
<span class="line-added">+     WTF::storeStoreFence();</span>
<span class="line-added">+     m_jitData = WTFMove(jitData);</span>
      return *m_jitData;
  }
  
  void CodeBlock::finalizeBaselineJITInlineCaches()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1377,10 ***</span>
<span class="line-new-header">--- 1381,45 ---</span>
  {
      UNUSED_PARAM(vm);
  
      updateAllPredictions();
  
<span class="line-added">+ #if ENABLE(JIT)</span>
<span class="line-added">+     bool isEligibleForLLIntDowngrade = m_isEligibleForLLIntDowngrade;</span>
<span class="line-added">+     m_isEligibleForLLIntDowngrade = false;</span>
<span class="line-added">+     // If BaselineJIT code is not executing, and an optimized replacement exists, we attempt</span>
<span class="line-added">+     // to discard baseline JIT code and reinstall LLInt code to save JIT memory.</span>
<span class="line-added">+     if (Options::useLLInt() &amp;&amp; !m_hasLinkedOSRExit &amp;&amp; jitType() == JITType::BaselineJIT &amp;&amp; !m_vm-&gt;heap.codeBlockSet().isCurrentlyExecuting(this)) {</span>
<span class="line-added">+         if (CodeBlock* optimizedCodeBlock = optimizedReplacement()) {</span>
<span class="line-added">+             if (!optimizedCodeBlock-&gt;m_osrExitCounter) {</span>
<span class="line-added">+                 if (isEligibleForLLIntDowngrade) {</span>
<span class="line-added">+                     m_jitCode = nullptr;</span>
<span class="line-added">+                     LLInt::setEntrypoint(this);</span>
<span class="line-added">+                     RELEASE_ASSERT(jitType() == JITType::InterpreterThunk);</span>
<span class="line-added">+ </span>
<span class="line-added">+                     for (size_t i = 0; i &lt; m_unlinkedCode-&gt;numberOfExceptionHandlers(); i++) {</span>
<span class="line-added">+                         const UnlinkedHandlerInfo&amp; unlinkedHandler = m_unlinkedCode-&gt;exceptionHandler(i);</span>
<span class="line-added">+                         HandlerInfo&amp; handler = m_rareData-&gt;m_exceptionHandlers[i];</span>
<span class="line-added">+                         auto&amp; instruction = *instructions().at(unlinkedHandler.target).ptr();</span>
<span class="line-added">+                         MacroAssemblerCodePtr&lt;BytecodePtrTag&gt; codePtr = LLInt::getCodePtr&lt;BytecodePtrTag&gt;(instruction);</span>
<span class="line-added">+                         handler.initialize(unlinkedHandler, CodeLocationLabel&lt;ExceptionHandlerPtrTag&gt;(codePtr.retagged&lt;ExceptionHandlerPtrTag&gt;()));</span>
<span class="line-added">+                     }</span>
<span class="line-added">+ </span>
<span class="line-added">+                     unlinkIncomingCalls();</span>
<span class="line-added">+ </span>
<span class="line-added">+                     // It&#39;s safe to clear these out here because in finalizeUnconditionally all compiler threads</span>
<span class="line-added">+                     // are safepointed, meaning they&#39;re running either before or after bytecode parser, and bytecode</span>
<span class="line-added">+                     // parser is the only data structure pointing into the various *infos.</span>
<span class="line-added">+                     resetJITData();</span>
<span class="line-added">+                 } else</span>
<span class="line-added">+                     m_isEligibleForLLIntDowngrade = true;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+ #endif</span>
<span class="line-added">+ </span>
      if (JITCode::couldBeInterpreted(jitType()))
          finalizeLLIntInlineCaches();
  
  #if ENABLE(JIT)
      if (!!jitCode())
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1479,29 ***</span>
  {
      ConcurrentJSLocker locker(m_lock);
      return ensureJITData(locker).m_stubInfos.add(accessType);
  }
  
<span class="line-modified">! JITAddIC* CodeBlock::addJITAddIC(ArithProfile* arithProfile)</span>
  {
      ConcurrentJSLocker locker(m_lock);
      return ensureJITData(locker).m_addICs.add(arithProfile);
  }
  
<span class="line-modified">! JITMulIC* CodeBlock::addJITMulIC(ArithProfile* arithProfile)</span>
  {
      ConcurrentJSLocker locker(m_lock);
      return ensureJITData(locker).m_mulICs.add(arithProfile);
  }
  
<span class="line-modified">! JITSubIC* CodeBlock::addJITSubIC(ArithProfile* arithProfile)</span>
  {
      ConcurrentJSLocker locker(m_lock);
      return ensureJITData(locker).m_subICs.add(arithProfile);
  }
  
<span class="line-modified">! JITNegIC* CodeBlock::addJITNegIC(ArithProfile* arithProfile)</span>
  {
      ConcurrentJSLocker locker(m_lock);
      return ensureJITData(locker).m_negICs.add(arithProfile);
  }
  
<span class="line-new-header">--- 1518,29 ---</span>
  {
      ConcurrentJSLocker locker(m_lock);
      return ensureJITData(locker).m_stubInfos.add(accessType);
  }
  
<span class="line-modified">! JITAddIC* CodeBlock::addJITAddIC(BinaryArithProfile* arithProfile)</span>
  {
      ConcurrentJSLocker locker(m_lock);
      return ensureJITData(locker).m_addICs.add(arithProfile);
  }
  
<span class="line-modified">! JITMulIC* CodeBlock::addJITMulIC(BinaryArithProfile* arithProfile)</span>
  {
      ConcurrentJSLocker locker(m_lock);
      return ensureJITData(locker).m_mulICs.add(arithProfile);
  }
  
<span class="line-modified">! JITSubIC* CodeBlock::addJITSubIC(BinaryArithProfile* arithProfile)</span>
  {
      ConcurrentJSLocker locker(m_lock);
      return ensureJITData(locker).m_subICs.add(arithProfile);
  }
  
<span class="line-modified">! JITNegIC* CodeBlock::addJITNegIC(UnaryArithProfile* arithProfile)</span>
  {
      ConcurrentJSLocker locker(m_lock);
      return ensureJITData(locker).m_negICs.add(arithProfile);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1527,11 ***</span>
  {
      ConcurrentJSLocker locker(m_lock);
      return ensureJITData(locker).m_callLinkInfos.add();
  }
  
<span class="line-modified">! CallLinkInfo* CodeBlock::getCallLinkInfoForBytecodeIndex(unsigned index)</span>
  {
      ConcurrentJSLocker locker(m_lock);
      if (auto* jitData = m_jitData.get()) {
          for (CallLinkInfo* callLinkInfo : jitData-&gt;m_callLinkInfos) {
              if (callLinkInfo-&gt;codeOrigin() == CodeOrigin(index))
<span class="line-new-header">--- 1566,11 ---</span>
  {
      ConcurrentJSLocker locker(m_lock);
      return ensureJITData(locker).m_callLinkInfos.add();
  }
  
<span class="line-modified">! CallLinkInfo* CodeBlock::getCallLinkInfoForBytecodeIndex(BytecodeIndex index)</span>
  {
      ConcurrentJSLocker locker(m_lock);
      if (auto* jitData = m_jitData.get()) {
          for (CallLinkInfo* callLinkInfo : jitData-&gt;m_callLinkInfos) {
              if (callLinkInfo-&gt;codeOrigin() == CodeOrigin(index))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1539,31 ***</span>
          }
      }
      return nullptr;
  }
  
<span class="line-modified">! RareCaseProfile* CodeBlock::addRareCaseProfile(int bytecodeOffset)</span>
  {
      ConcurrentJSLocker locker(m_lock);
<span class="line-modified">!     auto&amp; jitData = ensureJITData(locker);</span>
<span class="line-removed">-     jitData.m_rareCaseProfiles.append(RareCaseProfile(bytecodeOffset));</span>
<span class="line-removed">-     return &amp;jitData.m_rareCaseProfiles.last();</span>
  }
  
<span class="line-modified">! RareCaseProfile* CodeBlock::rareCaseProfileForBytecodeOffset(const ConcurrentJSLocker&amp;, int bytecodeOffset)</span>
  {
      if (auto* jitData = m_jitData.get()) {
<span class="line-modified">!         return tryBinarySearch&lt;RareCaseProfile, int&gt;(</span>
<span class="line-modified">!             jitData-&gt;m_rareCaseProfiles, jitData-&gt;m_rareCaseProfiles.size(), bytecodeOffset,</span>
<span class="line-modified">!             getRareCaseProfileBytecodeOffset);</span>
      }
      return nullptr;
  }
  
<span class="line-modified">! unsigned CodeBlock::rareCaseProfileCountForBytecodeOffset(const ConcurrentJSLocker&amp; locker, int bytecodeOffset)</span>
  {
<span class="line-modified">!     RareCaseProfile* profile = rareCaseProfileForBytecodeOffset(locker, bytecodeOffset);</span>
      if (profile)
          return profile-&gt;m_counter;
      return 0;
  }
  
<span class="line-new-header">--- 1578,29 ---</span>
          }
      }
      return nullptr;
  }
  
<span class="line-modified">! void CodeBlock::setRareCaseProfiles(RefCountedArray&lt;RareCaseProfile&gt;&amp;&amp; rareCaseProfiles)</span>
  {
      ConcurrentJSLocker locker(m_lock);
<span class="line-modified">!     ensureJITData(locker).m_rareCaseProfiles = WTFMove(rareCaseProfiles);</span>
  }
  
<span class="line-modified">! RareCaseProfile* CodeBlock::rareCaseProfileForBytecodeIndex(const ConcurrentJSLocker&amp;, BytecodeIndex bytecodeIndex)</span>
  {
      if (auto* jitData = m_jitData.get()) {
<span class="line-modified">!         return tryBinarySearch&lt;RareCaseProfile, BytecodeIndex&gt;(</span>
<span class="line-modified">!             jitData-&gt;m_rareCaseProfiles, jitData-&gt;m_rareCaseProfiles.size(), bytecodeIndex,</span>
<span class="line-modified">!             getRareCaseProfileBytecodeIndex);</span>
      }
      return nullptr;
  }
  
<span class="line-modified">! unsigned CodeBlock::rareCaseProfileCountForBytecodeIndex(const ConcurrentJSLocker&amp; locker, BytecodeIndex bytecodeIndex)</span>
  {
<span class="line-modified">!     RareCaseProfile* profile = rareCaseProfileForBytecodeIndex(locker, bytecodeIndex);</span>
      if (profile)
          return profile-&gt;m_counter;
      return 0;
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1586,17 ***</span>
  
      if (auto* jitData = m_jitData.get()) {
          // We can clear these because no other thread will have references to any stub infos, call
          // link infos, or by val infos if we don&#39;t have JIT code. Attempts to query these data
          // structures using the concurrent API (getICStatusMap and friends) will return nothing if we
<span class="line-modified">!         // don&#39;t have JIT code.</span>
<span class="line-modified">!         jitData-&gt;m_stubInfos.clear();</span>
<span class="line-modified">!         jitData-&gt;m_callLinkInfos.clear();</span>
<span class="line-modified">!         jitData-&gt;m_byValInfos.clear();</span>
          // We can clear this because the DFG&#39;s queries to these data structures are guarded by whether
          // there is JIT code.
<span class="line-modified">!         jitData-&gt;m_rareCaseProfiles.clear();</span>
      }
  }
  #endif
  
  void CodeBlock::visitOSRExitTargets(const ConcurrentJSLocker&amp;, SlotVisitor&amp; visitor)
<span class="line-new-header">--- 1623,28 ---</span>
  
      if (auto* jitData = m_jitData.get()) {
          // We can clear these because no other thread will have references to any stub infos, call
          // link infos, or by val infos if we don&#39;t have JIT code. Attempts to query these data
          // structures using the concurrent API (getICStatusMap and friends) will return nothing if we
<span class="line-modified">!         // don&#39;t have JIT code. So it&#39;s safe to call this if we fail a baseline JIT compile.</span>
<span class="line-modified">!         //</span>
<span class="line-modified">!         // We also call this from finalizeUnconditionally when we degrade from baseline JIT to LLInt</span>
<span class="line-modified">!         // code. This is safe to do since all compiler threads are safepointed in finalizeUnconditionally,</span>
<span class="line-added">+         // which means we&#39;ve made it past bytecode parsing. Only the bytecode parser will hold onto</span>
<span class="line-added">+         // references to these various *infos via its use of ICStatusMap. Also, OSR exit might point to</span>
<span class="line-added">+         // these *infos, but when we have an OSR exit linked to this CodeBlock, we won&#39;t downgrade</span>
<span class="line-added">+         // to LLInt.</span>
<span class="line-added">+ </span>
<span class="line-added">+         for (StructureStubInfo* stubInfo : jitData-&gt;m_stubInfos) {</span>
<span class="line-added">+             stubInfo-&gt;aboutToDie();</span>
<span class="line-added">+             stubInfo-&gt;deref();</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          // We can clear this because the DFG&#39;s queries to these data structures are guarded by whether
          // there is JIT code.
<span class="line-modified">! </span>
<span class="line-added">+         m_jitData = nullptr;</span>
      }
  }
  #endif
  
  void CodeBlock::visitOSRExitTargets(const ConcurrentJSLocker&amp;, SlotVisitor&amp; visitor)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1639,16 ***</span>
  
  #if ENABLE(JIT)
      if (auto* jitData = m_jitData.get()) {
          for (ByValInfo* byValInfo : jitData-&gt;m_byValInfos)
              visitor.append(byValInfo-&gt;cachedSymbol);
      }
  #endif
  
  #if ENABLE(DFG_JIT)
<span class="line-modified">!     if (JITCode::isOptimizingJIT(jitType()))</span>
          visitOSRExitTargets(locker, visitor);
  #endif
  }
  
  void CodeBlock::stronglyVisitWeakReferences(const ConcurrentJSLocker&amp;, SlotVisitor&amp; visitor)
  {
<span class="line-new-header">--- 1687,21 ---</span>
  
  #if ENABLE(JIT)
      if (auto* jitData = m_jitData.get()) {
          for (ByValInfo* byValInfo : jitData-&gt;m_byValInfos)
              visitor.append(byValInfo-&gt;cachedSymbol);
<span class="line-added">+         for (StructureStubInfo* stubInfo : jitData-&gt;m_stubInfos)</span>
<span class="line-added">+             stubInfo-&gt;visitAggregate(visitor);</span>
      }
  #endif
  
  #if ENABLE(DFG_JIT)
<span class="line-modified">!     if (JITCode::isOptimizingJIT(jitType())) {</span>
<span class="line-added">+         DFG::CommonData* dfgCommon = m_jitCode-&gt;dfgCommon();</span>
<span class="line-added">+         dfgCommon-&gt;recordedStatuses.visitAggregate(visitor);</span>
          visitOSRExitTargets(locker, visitor);
<span class="line-added">+     }</span>
  #endif
  }
  
  void CodeBlock::stronglyVisitWeakReferences(const ConcurrentJSLocker&amp;, SlotVisitor&amp; visitor)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1668,12 ***</span>
      }
  
      for (auto&amp; weakReference : dfgCommon-&gt;weakReferences)
          visitor.append(weakReference);
  
<span class="line-modified">!     for (auto&amp; weakStructureReference : dfgCommon-&gt;weakStructureReferences)</span>
<span class="line-modified">!         visitor.append(weakStructureReference);</span>
  
      dfgCommon-&gt;livenessHasBeenProved = true;
  #endif
  }
  
<span class="line-new-header">--- 1721,12 ---</span>
      }
  
      for (auto&amp; weakReference : dfgCommon-&gt;weakReferences)
          visitor.append(weakReference);
  
<span class="line-modified">!     for (StructureID structureID : dfgCommon-&gt;weakStructureReferences)</span>
<span class="line-modified">!         visitor.appendUnbarriered(visitor.vm().getStructure(structureID));</span>
  
      dfgCommon-&gt;livenessHasBeenProved = true;
  #endif
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1719,33 ***</span>
      return this;
  #endif
  }
  
  #if ENABLE(JIT)
<span class="line-modified">! bool CodeBlock::hasOptimizedReplacement(JITType typeToReplace)</span>
  {
      CodeBlock* replacement = this-&gt;replacement();
<span class="line-modified">!     return replacement &amp;&amp; JITCode::isHigherTier(replacement-&gt;jitType(), typeToReplace);</span>
  }
  
  bool CodeBlock::hasOptimizedReplacement()
  {
      return hasOptimizedReplacement(jitType());
  }
  #endif
  
<span class="line-modified">! HandlerInfo* CodeBlock::handlerForBytecodeOffset(unsigned bytecodeOffset, RequiredHandler requiredHandler)</span>
  {
<span class="line-modified">!     RELEASE_ASSERT(bytecodeOffset &lt; instructions().size());</span>
<span class="line-modified">!     return handlerForIndex(bytecodeOffset, requiredHandler);</span>
  }
  
  HandlerInfo* CodeBlock::handlerForIndex(unsigned index, RequiredHandler requiredHandler)
  {
      if (!m_rareData)
          return 0;
<span class="line-modified">!     return HandlerInfo::handlerForIndex(m_rareData-&gt;m_exceptionHandlers, index, requiredHandler);</span>
  }
  
  DisposableCallSiteIndex CodeBlock::newExceptionHandlingCallSiteIndex(CallSiteIndex originalCallSite)
  {
  #if ENABLE(DFG_JIT)
<span class="line-new-header">--- 1772,47 ---</span>
      return this;
  #endif
  }
  
  #if ENABLE(JIT)
<span class="line-modified">! CodeBlock* CodeBlock::optimizedReplacement(JITType typeToReplace)</span>
  {
      CodeBlock* replacement = this-&gt;replacement();
<span class="line-modified">!     if (!replacement)</span>
<span class="line-added">+         return nullptr;</span>
<span class="line-added">+     if (JITCode::isHigherTier(replacement-&gt;jitType(), typeToReplace))</span>
<span class="line-added">+         return replacement;</span>
<span class="line-added">+     return nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ CodeBlock* CodeBlock::optimizedReplacement()</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return optimizedReplacement(jitType());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool CodeBlock::hasOptimizedReplacement(JITType typeToReplace)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return !!optimizedReplacement(typeToReplace);</span>
  }
  
  bool CodeBlock::hasOptimizedReplacement()
  {
      return hasOptimizedReplacement(jitType());
  }
  #endif
  
<span class="line-modified">! HandlerInfo* CodeBlock::handlerForBytecodeIndex(BytecodeIndex bytecodeIndex, RequiredHandler requiredHandler)</span>
  {
<span class="line-modified">!     RELEASE_ASSERT(bytecodeIndex.offset() &lt; instructions().size());</span>
<span class="line-modified">!     return handlerForIndex(bytecodeIndex.offset(), requiredHandler);</span>
  }
  
  HandlerInfo* CodeBlock::handlerForIndex(unsigned index, RequiredHandler requiredHandler)
  {
      if (!m_rareData)
          return 0;
<span class="line-modified">!     return HandlerInfo::handlerForIndex&lt;HandlerInfo&gt;(m_rareData-&gt;m_exceptionHandlers, index, requiredHandler);</span>
  }
  
  DisposableCallSiteIndex CodeBlock::newExceptionHandlingCallSiteIndex(CallSiteIndex originalCallSite)
  {
  #if ENABLE(DFG_JIT)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1763,17 ***</span>
  #endif
  }
  
  
  
<span class="line-modified">! void CodeBlock::ensureCatchLivenessIsComputedForBytecodeOffset(InstructionStream::Offset bytecodeOffset)</span>
  {
<span class="line-modified">!     auto&amp; instruction = instructions().at(bytecodeOffset);</span>
      OpCatch op = instruction-&gt;as&lt;OpCatch&gt;();
      auto&amp; metadata = op.metadata(this);
      if (!!metadata.m_buffer) {
<span class="line-modified">! #if !ASSERT_DISABLED</span>
          ConcurrentJSLocker locker(m_lock);
          bool found = false;
          auto* rareData = m_rareData.get();
          ASSERT(rareData);
          for (auto&amp; profile : rareData-&gt;m_catchProfiles) {
<span class="line-new-header">--- 1830,17 ---</span>
  #endif
  }
  
  
  
<span class="line-modified">! void CodeBlock::ensureCatchLivenessIsComputedForBytecodeIndex(BytecodeIndex bytecodeIndex)</span>
  {
<span class="line-modified">!     auto&amp; instruction = instructions().at(bytecodeIndex);</span>
      OpCatch op = instruction-&gt;as&lt;OpCatch&gt;();
      auto&amp; metadata = op.metadata(this);
      if (!!metadata.m_buffer) {
<span class="line-modified">! #if ASSERT_ENABLED</span>
          ConcurrentJSLocker locker(m_lock);
          bool found = false;
          auto* rareData = m_rareData.get();
          ASSERT(rareData);
          for (auto&amp; profile : rareData-&gt;m_catchProfiles) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1781,41 ***</span>
                  found = true;
                  break;
              }
          }
          ASSERT(found);
<span class="line-modified">! #endif</span>
          return;
      }
  
<span class="line-modified">!     ensureCatchLivenessIsComputedForBytecodeOffsetSlow(op, bytecodeOffset);</span>
  }
  
<span class="line-modified">! void CodeBlock::ensureCatchLivenessIsComputedForBytecodeOffsetSlow(const OpCatch&amp; op, InstructionStream::Offset bytecodeOffset)</span>
  {
      BytecodeLivenessAnalysis&amp; bytecodeLiveness = livenessAnalysis();
  
      // We get the live-out set of variables at op_catch, not the live-in. This
      // is because the variables that the op_catch defines might be dead, and
      // we can avoid profiling them and extracting them when doing OSR entry
      // into the DFG.
  
<span class="line-modified">!     auto nextOffset = instructions().at(bytecodeOffset).next().offset();</span>
<span class="line-modified">!     FastBitVector liveLocals = bytecodeLiveness.getLivenessInfoAtBytecodeOffset(this, nextOffset);</span>
      Vector&lt;VirtualRegister&gt; liveOperands;
      liveOperands.reserveInitialCapacity(liveLocals.bitCount());
      liveLocals.forEachSetBit([&amp;] (unsigned liveLocal) {
          liveOperands.append(virtualRegisterForLocal(liveLocal));
      });
  
      for (int i = 0; i &lt; numParameters(); ++i)
<span class="line-modified">!         liveOperands.append(virtualRegisterForArgument(i));</span>
  
<span class="line-modified">!     auto profiles = makeUnique&lt;ValueProfileAndOperandBuffer&gt;(liveOperands.size());</span>
      RELEASE_ASSERT(profiles-&gt;m_size == liveOperands.size());
      for (unsigned i = 0; i &lt; profiles-&gt;m_size; ++i)
<span class="line-modified">!         profiles-&gt;m_buffer.get()[i].m_operand = liveOperands[i].offset();</span>
  
      createRareDataIfNecessary();
  
      // The compiler thread will read this pointer value and then proceed to dereference it
      // if it is not null. We need to make sure all above stores happen before this store so
<span class="line-new-header">--- 1848,41 ---</span>
                  found = true;
                  break;
              }
          }
          ASSERT(found);
<span class="line-modified">! #endif // ASSERT_ENABLED</span>
          return;
      }
  
<span class="line-modified">!     ensureCatchLivenessIsComputedForBytecodeIndexSlow(op, bytecodeIndex);</span>
  }
  
<span class="line-modified">! void CodeBlock::ensureCatchLivenessIsComputedForBytecodeIndexSlow(const OpCatch&amp; op, BytecodeIndex bytecodeIndex)</span>
  {
      BytecodeLivenessAnalysis&amp; bytecodeLiveness = livenessAnalysis();
  
      // We get the live-out set of variables at op_catch, not the live-in. This
      // is because the variables that the op_catch defines might be dead, and
      // we can avoid profiling them and extracting them when doing OSR entry
      // into the DFG.
  
<span class="line-modified">!     auto nextOffset = instructions().at(bytecodeIndex).next().offset();</span>
<span class="line-modified">!     FastBitVector liveLocals = bytecodeLiveness.getLivenessInfoAtBytecodeIndex(this, BytecodeIndex(nextOffset));</span>
      Vector&lt;VirtualRegister&gt; liveOperands;
      liveOperands.reserveInitialCapacity(liveLocals.bitCount());
      liveLocals.forEachSetBit([&amp;] (unsigned liveLocal) {
          liveOperands.append(virtualRegisterForLocal(liveLocal));
      });
  
      for (int i = 0; i &lt; numParameters(); ++i)
<span class="line-modified">!         liveOperands.append(virtualRegisterForArgumentIncludingThis(i));</span>
  
<span class="line-modified">!     auto profiles = makeUnique&lt;ValueProfileAndVirtualRegisterBuffer&gt;(liveOperands.size());</span>
      RELEASE_ASSERT(profiles-&gt;m_size == liveOperands.size());
      for (unsigned i = 0; i &lt; profiles-&gt;m_size; ++i)
<span class="line-modified">!         profiles-&gt;m_buffer.get()[i].m_operand = liveOperands[i];</span>
  
      createRareDataIfNecessary();
  
      // The compiler thread will read this pointer value and then proceed to dereference it
      // if it is not null. We need to make sure all above stores happen before this store so
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1843,80 ***</span>
      }
  
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! unsigned CodeBlock::lineNumberForBytecodeOffset(unsigned bytecodeOffset)</span>
  {
<span class="line-modified">!     RELEASE_ASSERT(bytecodeOffset &lt; instructions().size());</span>
<span class="line-modified">!     return ownerExecutable()-&gt;firstLine() + m_unlinkedCode-&gt;lineNumberForBytecodeOffset(bytecodeOffset);</span>
  }
  
<span class="line-modified">! unsigned CodeBlock::columnNumberForBytecodeOffset(unsigned bytecodeOffset)</span>
  {
      int divot;
      int startOffset;
      int endOffset;
      unsigned line;
      unsigned column;
<span class="line-modified">!     expressionRangeForBytecodeOffset(bytecodeOffset, divot, startOffset, endOffset, line, column);</span>
      return column;
  }
  
<span class="line-modified">! void CodeBlock::expressionRangeForBytecodeOffset(unsigned bytecodeOffset, int&amp; divot, int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const</span>
  {
<span class="line-modified">!     m_unlinkedCode-&gt;expressionRangeForBytecodeOffset(bytecodeOffset, divot, startOffset, endOffset, line, column);</span>
      divot += sourceOffset();
      column += line ? 1 : firstLineColumnOffset();
      line += ownerExecutable()-&gt;firstLine();
  }
  
<span class="line-modified">! bool CodeBlock::hasOpDebugForLineAndColumn(unsigned line, unsigned column)</span>
  {
      const InstructionStream&amp; instructionStream = instructions();
      for (const auto&amp; it : instructionStream) {
          if (it-&gt;is&lt;OpDebug&gt;()) {
              int unused;
              unsigned opDebugLine;
              unsigned opDebugColumn;
<span class="line-modified">!             expressionRangeForBytecodeOffset(it.offset(), unused, unused, unused, opDebugLine, opDebugColumn);</span>
<span class="line-modified">!             if (line == opDebugLine &amp;&amp; (column == Breakpoint::unspecifiedColumn || column == opDebugColumn))</span>
                  return true;
          }
      }
      return false;
  }
  
<span class="line-modified">! void CodeBlock::shrinkToFit(ShrinkMode shrinkMode)</span>
  {
<span class="line-modified">!     ConcurrentJSLocker locker(m_lock);</span>
<span class="line-modified">! </span>
<span class="line-modified">! #if ENABLE(JIT)</span>
<span class="line-removed">-     if (auto* jitData = m_jitData.get())</span>
<span class="line-removed">-         jitData-&gt;m_rareCaseProfiles.shrinkToFit();</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (shrinkMode == EarlyShrink) {</span>
          m_constantRegisters.shrinkToFit();
<span class="line-modified">!         m_constantsSourceCodeRepresentation.shrinkToFit();</span>
  
          if (m_rareData) {
              m_rareData-&gt;m_switchJumpTables.shrinkToFit();
              m_rareData-&gt;m_stringSwitchJumpTables.shrinkToFit();
          }
      } // else don&#39;t shrink these, because we would have already pointed pointers into these tables.
  }
  
  #if ENABLE(JIT)
<span class="line-modified">! void CodeBlock::linkIncomingCall(ExecState* callerFrame, CallLinkInfo* incoming)</span>
  {
      noticeIncomingCall(callerFrame);
      ConcurrentJSLocker locker(m_lock);
      ensureJITData(locker).m_incomingCalls.push(incoming);
  }
  
<span class="line-modified">! void CodeBlock::linkIncomingPolymorphicCall(ExecState* callerFrame, PolymorphicCallNode* incoming)</span>
  {
      noticeIncomingCall(callerFrame);
      {
          ConcurrentJSLocker locker(m_lock);
          ensureJITData(locker).m_incomingPolymorphicCalls.push(incoming);
<span class="line-new-header">--- 1910,79 ---</span>
      }
  
      RELEASE_ASSERT_NOT_REACHED();
  }
  
<span class="line-modified">! unsigned CodeBlock::lineNumberForBytecodeIndex(BytecodeIndex bytecodeIndex)</span>
  {
<span class="line-modified">!     RELEASE_ASSERT(bytecodeIndex.offset() &lt; instructions().size());</span>
<span class="line-modified">!     return ownerExecutable()-&gt;firstLine() + m_unlinkedCode-&gt;lineNumberForBytecodeIndex(bytecodeIndex);</span>
  }
  
<span class="line-modified">! unsigned CodeBlock::columnNumberForBytecodeIndex(BytecodeIndex bytecodeIndex)</span>
  {
      int divot;
      int startOffset;
      int endOffset;
      unsigned line;
      unsigned column;
<span class="line-modified">!     expressionRangeForBytecodeIndex(bytecodeIndex, divot, startOffset, endOffset, line, column);</span>
      return column;
  }
  
<span class="line-modified">! void CodeBlock::expressionRangeForBytecodeIndex(BytecodeIndex bytecodeIndex, int&amp; divot, int&amp; startOffset, int&amp; endOffset, unsigned&amp; line, unsigned&amp; column) const</span>
  {
<span class="line-modified">!     m_unlinkedCode-&gt;expressionRangeForBytecodeIndex(bytecodeIndex, divot, startOffset, endOffset, line, column);</span>
      divot += sourceOffset();
      column += line ? 1 : firstLineColumnOffset();
      line += ownerExecutable()-&gt;firstLine();
  }
  
<span class="line-modified">! bool CodeBlock::hasOpDebugForLineAndColumn(unsigned line, Optional&lt;unsigned&gt; column)</span>
  {
      const InstructionStream&amp; instructionStream = instructions();
      for (const auto&amp; it : instructionStream) {
          if (it-&gt;is&lt;OpDebug&gt;()) {
              int unused;
              unsigned opDebugLine;
              unsigned opDebugColumn;
<span class="line-modified">!             expressionRangeForBytecodeIndex(it.index(), unused, unused, unused, opDebugLine, opDebugColumn);</span>
<span class="line-modified">!             if (line == opDebugLine &amp;&amp; (!column || column == opDebugColumn))</span>
                  return true;
          }
      }
      return false;
  }
  
<span class="line-modified">! void CodeBlock::shrinkToFit(const ConcurrentJSLocker&amp;, ShrinkMode shrinkMode)</span>
  {
<span class="line-modified">! #if USE(JSVALUE32_64)</span>
<span class="line-modified">!     // Only 32bit Baseline JIT is touching m_constantRegisters address directly.</span>
<span class="line-modified">!     if (shrinkMode == ShrinkMode::EarlyShrink)</span>
          m_constantRegisters.shrinkToFit();
<span class="line-modified">! #else</span>
<span class="line-added">+     m_constantRegisters.shrinkToFit();</span>
<span class="line-added">+ #endif</span>
<span class="line-added">+     m_constantsSourceCodeRepresentation.shrinkToFit();</span>
  
<span class="line-added">+     if (shrinkMode == ShrinkMode::EarlyShrink) {</span>
          if (m_rareData) {
              m_rareData-&gt;m_switchJumpTables.shrinkToFit();
              m_rareData-&gt;m_stringSwitchJumpTables.shrinkToFit();
          }
      } // else don&#39;t shrink these, because we would have already pointed pointers into these tables.
  }
  
  #if ENABLE(JIT)
<span class="line-modified">! void CodeBlock::linkIncomingCall(CallFrame* callerFrame, CallLinkInfo* incoming)</span>
  {
      noticeIncomingCall(callerFrame);
      ConcurrentJSLocker locker(m_lock);
      ensureJITData(locker).m_incomingCalls.push(incoming);
  }
  
<span class="line-modified">! void CodeBlock::linkIncomingPolymorphicCall(CallFrame* callerFrame, PolymorphicCallNode* incoming)</span>
  {
      noticeIncomingCall(callerFrame);
      {
          ConcurrentJSLocker locker(m_lock);
          ensureJITData(locker).m_incomingPolymorphicCalls.push(incoming);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1941,11 ***</span>
              jitData-&gt;m_incomingPolymorphicCalls.begin()-&gt;unlink(vm());
      }
  #endif // ENABLE(JIT)
  }
  
<span class="line-modified">! void CodeBlock::linkIncomingCall(ExecState* callerFrame, LLIntCallLinkInfo* incoming)</span>
  {
      noticeIncomingCall(callerFrame);
      m_incomingLLIntCalls.push(incoming);
  }
  
<span class="line-new-header">--- 2007,11 ---</span>
              jitData-&gt;m_incomingPolymorphicCalls.begin()-&gt;unlink(vm());
      }
  #endif // ENABLE(JIT)
  }
  
<span class="line-modified">! void CodeBlock::linkIncomingCall(CallFrame* callerFrame, LLIntCallLinkInfo* incoming)</span>
  {
      noticeIncomingCall(callerFrame);
      m_incomingLLIntCalls.push(incoming);
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2166,25 ***</span>
      mutable unsigned m_depthToCheck;
      mutable bool m_foundStartCallFrame;
      mutable bool m_didRecurse;
  };
  
<span class="line-modified">! void CodeBlock::noticeIncomingCall(ExecState* callerFrame)</span>
  {
      CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
  
<span class="line-modified">!     if (Options::verboseCallLink())</span>
<span class="line-removed">-         dataLog(&quot;Noticing call link from &quot;, pointerDump(callerCodeBlock), &quot; to &quot;, *this, &quot;\n&quot;);</span>
  
  #if ENABLE(DFG_JIT)
      if (!m_shouldAlwaysBeInlined)
          return;
  
      if (!callerCodeBlock) {
          m_shouldAlwaysBeInlined = false;
<span class="line-modified">!         if (Options::verboseCallLink())</span>
<span class="line-removed">-             dataLog(&quot;    Clearing SABI because caller is native.\n&quot;);</span>
          return;
      }
  
      if (!hasBaselineJITProfiling())
          return;
<span class="line-new-header">--- 2232,23 ---</span>
      mutable unsigned m_depthToCheck;
      mutable bool m_foundStartCallFrame;
      mutable bool m_didRecurse;
  };
  
<span class="line-modified">! void CodeBlock::noticeIncomingCall(CallFrame* callerFrame)</span>
  {
      CodeBlock* callerCodeBlock = callerFrame-&gt;codeBlock();
  
<span class="line-modified">!     dataLogLnIf(Options::verboseCallLink(), &quot;Noticing call link from &quot;, pointerDump(callerCodeBlock), &quot; to &quot;, *this);</span>
  
  #if ENABLE(DFG_JIT)
      if (!m_shouldAlwaysBeInlined)
          return;
  
      if (!callerCodeBlock) {
          m_shouldAlwaysBeInlined = false;
<span class="line-modified">!         dataLogLnIf(Options::verboseCallLink(), &quot;    Clearing SABI because caller is native.&quot;);</span>
          return;
      }
  
      if (!hasBaselineJITProfiling())
          return;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2195,50 ***</span>
      if (!canInline(capabilityLevelState()))
          return;
  
      if (!DFG::isSmallEnoughToInlineCodeInto(callerCodeBlock)) {
          m_shouldAlwaysBeInlined = false;
<span class="line-modified">!         if (Options::verboseCallLink())</span>
<span class="line-removed">-             dataLog(&quot;    Clearing SABI because caller is too large.\n&quot;);</span>
          return;
      }
  
      if (callerCodeBlock-&gt;jitType() == JITType::InterpreterThunk) {
          // If the caller is still in the interpreter, then we can&#39;t expect inlining to
          // happen anytime soon. Assume it&#39;s profitable to optimize it separately. This
          // ensures that a function is SABI only if it is called no more frequently than
          // any of its callers.
          m_shouldAlwaysBeInlined = false;
<span class="line-modified">!         if (Options::verboseCallLink())</span>
<span class="line-removed">-             dataLog(&quot;    Clearing SABI because caller is in LLInt.\n&quot;);</span>
          return;
      }
  
      if (JITCode::isOptimizingJIT(callerCodeBlock-&gt;jitType())) {
          m_shouldAlwaysBeInlined = false;
<span class="line-modified">!         if (Options::verboseCallLink())</span>
<span class="line-removed">-             dataLog(&quot;    Clearing SABI bcause caller was already optimized.\n&quot;);</span>
          return;
      }
  
      if (callerCodeBlock-&gt;codeType() != FunctionCode) {
          // If the caller is either eval or global code, assume that that won&#39;t be
          // optimized anytime soon. For eval code this is particularly true since we
          // delay eval optimization by a *lot*.
          m_shouldAlwaysBeInlined = false;
<span class="line-modified">!         if (Options::verboseCallLink())</span>
<span class="line-removed">-             dataLog(&quot;    Clearing SABI because caller is not a function.\n&quot;);</span>
          return;
      }
  
      // Recursive calls won&#39;t be inlined.
      RecursionCheckFunctor functor(callerFrame, this, Options::maximumInliningDepth());
<span class="line-modified">!     vm().topCallFrame-&gt;iterate(functor);</span>
  
      if (functor.didRecurse()) {
<span class="line-modified">!         if (Options::verboseCallLink())</span>
<span class="line-removed">-             dataLog(&quot;    Clearing SABI because recursion was detected.\n&quot;);</span>
          m_shouldAlwaysBeInlined = false;
          return;
      }
  
      if (callerCodeBlock-&gt;capabilityLevelState() == DFG::CapabilityLevelNotSet) {
<span class="line-new-header">--- 2259,45 ---</span>
      if (!canInline(capabilityLevelState()))
          return;
  
      if (!DFG::isSmallEnoughToInlineCodeInto(callerCodeBlock)) {
          m_shouldAlwaysBeInlined = false;
<span class="line-modified">!         dataLogLnIf(Options::verboseCallLink(), &quot;    Clearing SABI because caller is too large.&quot;);</span>
          return;
      }
  
      if (callerCodeBlock-&gt;jitType() == JITType::InterpreterThunk) {
          // If the caller is still in the interpreter, then we can&#39;t expect inlining to
          // happen anytime soon. Assume it&#39;s profitable to optimize it separately. This
          // ensures that a function is SABI only if it is called no more frequently than
          // any of its callers.
          m_shouldAlwaysBeInlined = false;
<span class="line-modified">!         dataLogLnIf(Options::verboseCallLink(), &quot;    Clearing SABI because caller is in LLInt.&quot;);</span>
          return;
      }
  
      if (JITCode::isOptimizingJIT(callerCodeBlock-&gt;jitType())) {
          m_shouldAlwaysBeInlined = false;
<span class="line-modified">!         dataLogLnIf(Options::verboseCallLink(), &quot;    Clearing SABI bcause caller was already optimized.&quot;);</span>
          return;
      }
  
      if (callerCodeBlock-&gt;codeType() != FunctionCode) {
          // If the caller is either eval or global code, assume that that won&#39;t be
          // optimized anytime soon. For eval code this is particularly true since we
          // delay eval optimization by a *lot*.
          m_shouldAlwaysBeInlined = false;
<span class="line-modified">!         dataLogLnIf(Options::verboseCallLink(), &quot;    Clearing SABI because caller is not a function.&quot;);</span>
          return;
      }
  
      // Recursive calls won&#39;t be inlined.
      RecursionCheckFunctor functor(callerFrame, this, Options::maximumInliningDepth());
<span class="line-modified">!     vm().topCallFrame-&gt;iterate(vm(), functor);</span>
  
      if (functor.didRecurse()) {
<span class="line-modified">!         dataLogLnIf(Options::verboseCallLink(), &quot;    Clearing SABI because recursion was detected.&quot;);</span>
          m_shouldAlwaysBeInlined = false;
          return;
      }
  
      if (callerCodeBlock-&gt;capabilityLevelState() == DFG::CapabilityLevelNotSet) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2247,12 ***</span>
      }
  
      if (canCompile(callerCodeBlock-&gt;capabilityLevelState()))
          return;
  
<span class="line-modified">!     if (Options::verboseCallLink())</span>
<span class="line-removed">-         dataLog(&quot;    Clearing SABI because the caller is not a DFG candidate.\n&quot;);</span>
  
      m_shouldAlwaysBeInlined = false;
  #endif
  }
  
<span class="line-new-header">--- 2306,11 ---</span>
      }
  
      if (canCompile(callerCodeBlock-&gt;capabilityLevelState()))
          return;
  
<span class="line-modified">!     dataLogLnIf(Options::verboseCallLink(), &quot;    Clearing SABI because the caller is not a DFG candidate.&quot;);</span>
  
      m_shouldAlwaysBeInlined = false;
  #endif
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2396,16 ***</span>
  
      double result = d + a * sqrt(bytecodeCost + b) + c * bytecodeCost;
  
      result *= codeTypeThresholdMultiplier();
  
<span class="line-modified">!     if (Options::verboseOSR()) {</span>
<span class="line-modified">!         dataLog(</span>
<span class="line-modified">!             *this, &quot;: bytecode cost is &quot;, bytecodeCost,</span>
<span class="line-removed">-             &quot;, scaling execution counter by &quot;, result, &quot; * &quot;, codeTypeThresholdMultiplier(),</span>
<span class="line-removed">-             &quot;\n&quot;);</span>
<span class="line-removed">-     }</span>
      return result;
  }
  
  static int32_t clipThreshold(double threshold)
  {
<span class="line-new-header">--- 2454,13 ---</span>
  
      double result = d + a * sqrt(bytecodeCost + b) + c * bytecodeCost;
  
      result *= codeTypeThresholdMultiplier();
  
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(),</span>
<span class="line-modified">!         *this, &quot;: bytecode cost is &quot;, bytecodeCost,</span>
<span class="line-modified">!         &quot;, scaling execution counter by &quot;, result, &quot; * &quot;, codeTypeThresholdMultiplier());</span>
      return result;
  }
  
  static int32_t clipThreshold(double threshold)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2490,65 ***</span>
  }
  #endif
  
  void CodeBlock::optimizeNextInvocation()
  {
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLog(*this, &quot;: Optimizing next invocation.\n&quot;);</span>
      m_jitExecuteCounter.setNewThreshold(0, this);
  }
  
  void CodeBlock::dontOptimizeAnytimeSoon()
  {
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLog(*this, &quot;: Not optimizing anytime soon.\n&quot;);</span>
      m_jitExecuteCounter.deferIndefinitely();
  }
  
  void CodeBlock::optimizeAfterWarmUp()
  {
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLog(*this, &quot;: Optimizing after warm-up.\n&quot;);</span>
  #if ENABLE(DFG_JIT)
      m_jitExecuteCounter.setNewThreshold(
          adjustedCounterValue(Options::thresholdForOptimizeAfterWarmUp()), this);
  #endif
  }
  
  void CodeBlock::optimizeAfterLongWarmUp()
  {
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLog(*this, &quot;: Optimizing after long warm-up.\n&quot;);</span>
  #if ENABLE(DFG_JIT)
      m_jitExecuteCounter.setNewThreshold(
          adjustedCounterValue(Options::thresholdForOptimizeAfterLongWarmUp()), this);
  #endif
  }
  
  void CodeBlock::optimizeSoon()
  {
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLog(*this, &quot;: Optimizing soon.\n&quot;);</span>
  #if ENABLE(DFG_JIT)
      m_jitExecuteCounter.setNewThreshold(
          adjustedCounterValue(Options::thresholdForOptimizeSoon()), this);
  #endif
  }
  
  void CodeBlock::forceOptimizationSlowPathConcurrently()
  {
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLog(*this, &quot;: Forcing slow path concurrently.\n&quot;);</span>
      m_jitExecuteCounter.forceSlowPathConcurrently();
  }
  
  #if ENABLE(DFG_JIT)
  void CodeBlock::setOptimizationThresholdBasedOnCompilationResult(CompilationResult result)
  {
      JITType type = jitType();
      if (type != JITType::BaselineJIT) {
<span class="line-modified">!         dataLog(*this, &quot;: expected to have baseline code but have &quot;, type, &quot;\n&quot;);</span>
          CRASH_WITH_INFO(bitwise_cast&lt;uintptr_t&gt;(jitCode().get()), static_cast&lt;uint8_t&gt;(type));
      }
  
      CodeBlock* replacement = this-&gt;replacement();
      bool hasReplacement = (replacement &amp;&amp; replacement != this);
<span class="line-new-header">--- 2545,59 ---</span>
  }
  #endif
  
  void CodeBlock::optimizeNextInvocation()
  {
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), *this, &quot;: Optimizing next invocation.&quot;);</span>
      m_jitExecuteCounter.setNewThreshold(0, this);
  }
  
  void CodeBlock::dontOptimizeAnytimeSoon()
  {
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), *this, &quot;: Not optimizing anytime soon.&quot;);</span>
      m_jitExecuteCounter.deferIndefinitely();
  }
  
  void CodeBlock::optimizeAfterWarmUp()
  {
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), *this, &quot;: Optimizing after warm-up.&quot;);</span>
  #if ENABLE(DFG_JIT)
      m_jitExecuteCounter.setNewThreshold(
          adjustedCounterValue(Options::thresholdForOptimizeAfterWarmUp()), this);
  #endif
  }
  
  void CodeBlock::optimizeAfterLongWarmUp()
  {
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), *this, &quot;: Optimizing after long warm-up.&quot;);</span>
  #if ENABLE(DFG_JIT)
      m_jitExecuteCounter.setNewThreshold(
          adjustedCounterValue(Options::thresholdForOptimizeAfterLongWarmUp()), this);
  #endif
  }
  
  void CodeBlock::optimizeSoon()
  {
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), *this, &quot;: Optimizing soon.&quot;);</span>
  #if ENABLE(DFG_JIT)
      m_jitExecuteCounter.setNewThreshold(
          adjustedCounterValue(Options::thresholdForOptimizeSoon()), this);
  #endif
  }
  
  void CodeBlock::forceOptimizationSlowPathConcurrently()
  {
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), *this, &quot;: Forcing slow path concurrently.&quot;);</span>
      m_jitExecuteCounter.forceSlowPathConcurrently();
  }
  
  #if ENABLE(DFG_JIT)
  void CodeBlock::setOptimizationThresholdBasedOnCompilationResult(CompilationResult result)
  {
      JITType type = jitType();
      if (type != JITType::BaselineJIT) {
<span class="line-modified">!         dataLogLn(*this, &quot;: expected to have baseline code but have &quot;, type);</span>
          CRASH_WITH_INFO(bitwise_cast&lt;uintptr_t&gt;(jitCode().get()), static_cast&lt;uint8_t&gt;(type));
      }
  
      CodeBlock* replacement = this-&gt;replacement();
      bool hasReplacement = (replacement &amp;&amp; replacement != this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2624,13 ***</span>
  {
      return osrExitCounter() &gt;= exitCountThresholdForReoptimizationFromLoop();
  }
  #endif
  
<span class="line-modified">! ArrayProfile* CodeBlock::getArrayProfile(const ConcurrentJSLocker&amp;, unsigned bytecodeOffset)</span>
  {
<span class="line-modified">!     auto instruction = instructions().at(bytecodeOffset);</span>
      switch (instruction-&gt;opcodeID()) {
  #define CASE1(Op) \
      case Op::opcodeID: \
          return &amp;instruction-&gt;as&lt;Op&gt;().metadata(this).m_arrayProfile;
  
<span class="line-new-header">--- 2673,13 ---</span>
  {
      return osrExitCounter() &gt;= exitCountThresholdForReoptimizationFromLoop();
  }
  #endif
  
<span class="line-modified">! ArrayProfile* CodeBlock::getArrayProfile(const ConcurrentJSLocker&amp;, BytecodeIndex bytecodeIndex)</span>
  {
<span class="line-modified">!     auto instruction = instructions().at(bytecodeIndex);</span>
      switch (instruction-&gt;opcodeID()) {
  #define CASE1(Op) \
      case Op::opcodeID: \
          return &amp;instruction-&gt;as&lt;Op&gt;().metadata(this).m_arrayProfile;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2656,14 ***</span>
      }
  
      return nullptr;
  }
  
<span class="line-modified">! ArrayProfile* CodeBlock::getArrayProfile(unsigned bytecodeOffset)</span>
  {
      ConcurrentJSLocker locker(m_lock);
<span class="line-modified">!     return getArrayProfile(locker, bytecodeOffset);</span>
  }
  
  #if ENABLE(DFG_JIT)
  Vector&lt;CodeOrigin, 0, UnsafeVectorOverflow&gt;&amp; CodeBlock::codeOrigins()
  {
<span class="line-new-header">--- 2705,14 ---</span>
      }
  
      return nullptr;
  }
  
<span class="line-modified">! ArrayProfile* CodeBlock::getArrayProfile(BytecodeIndex bytecodeIndex)</span>
  {
      ConcurrentJSLocker locker(m_lock);
<span class="line-modified">!     return getArrayProfile(locker, bytecodeIndex);</span>
  }
  
  #if ENABLE(DFG_JIT)
  Vector&lt;CodeOrigin, 0, UnsafeVectorOverflow&gt;&amp; CodeBlock::codeOrigins()
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2710,11 ***</span>
          profile.computeUpdatedPrediction(locker);
      });
  
      if (auto* rareData = m_rareData.get()) {
          for (auto&amp; profileBucket : rareData-&gt;m_catchProfiles) {
<span class="line-modified">!             profileBucket-&gt;forEach([&amp;] (ValueProfileAndOperand&amp; profile) {</span>
                  profile.computeUpdatedPrediction(locker);
              });
          }
      }
  
<span class="line-new-header">--- 2759,11 ---</span>
          profile.computeUpdatedPrediction(locker);
      });
  
      if (auto* rareData = m_rareData.get()) {
          for (auto&amp; profileBucket : rareData-&gt;m_catchProfiles) {
<span class="line-modified">!             profileBucket-&gt;forEach([&amp;] (ValueProfileAndVirtualRegister&amp; profile) {</span>
                  profile.computeUpdatedPrediction(locker);
              });
          }
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2748,12 ***</span>
      updateAllArrayPredictions();
  }
  
  bool CodeBlock::shouldOptimizeNow()
  {
<span class="line-modified">!     if (Options::verboseOSR())</span>
<span class="line-removed">-         dataLog(&quot;Considering optimizing &quot;, *this, &quot;...\n&quot;);</span>
  
      if (m_optimizationDelayCounter &gt;= Options::maximumOptimizationDelay())
          return true;
  
      updateAllArrayPredictions();
<span class="line-new-header">--- 2797,11 ---</span>
      updateAllArrayPredictions();
  }
  
  bool CodeBlock::shouldOptimizeNow()
  {
<span class="line-modified">!     dataLogLnIf(Options::verboseOSR(), &quot;Considering optimizing &quot;, *this, &quot;...&quot;);</span>
  
      if (m_optimizationDelayCounter &gt;= Options::maximumOptimizationDelay())
          return true;
  
      updateAllArrayPredictions();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2784,11 ***</span>
  
  #if ENABLE(DFG_JIT)
  void CodeBlock::tallyFrequentExitSites()
  {
      ASSERT(JITCode::isOptimizingJIT(jitType()));
<span class="line-modified">!     ASSERT(alternative()-&gt;jitType() == JITType::BaselineJIT);</span>
  
      CodeBlock* profiledBlock = alternative();
  
      switch (jitType()) {
      case JITType::DFGJIT: {
<span class="line-new-header">--- 2832,11 ---</span>
  
  #if ENABLE(DFG_JIT)
  void CodeBlock::tallyFrequentExitSites()
  {
      ASSERT(JITCode::isOptimizingJIT(jitType()));
<span class="line-modified">!     ASSERT(JITCode::isBaselineCode(alternative()-&gt;jitType()));</span>
  
      CodeBlock* profiledBlock = alternative();
  
      switch (jitType()) {
      case JITType::DFGJIT: {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2967,13 ***</span>
          return makeString(&quot;arguments[&quot;, pad(&#39; &#39;, 3, virtualRegister.toArgument()), &#39;]&#39;);
  
      return emptyString();
  }
  
<span class="line-modified">! ValueProfile* CodeBlock::tryGetValueProfileForBytecodeOffset(int bytecodeOffset)</span>
  {
<span class="line-modified">!     auto instruction = instructions().at(bytecodeOffset);</span>
      switch (instruction-&gt;opcodeID()) {
  
  #define CASE(Op) \
      case Op::opcodeID: \
          return &amp;instruction-&gt;as&lt;Op&gt;().metadata(this).m_profile;
<span class="line-new-header">--- 3015,13 ---</span>
          return makeString(&quot;arguments[&quot;, pad(&#39; &#39;, 3, virtualRegister.toArgument()), &#39;]&#39;);
  
      return emptyString();
  }
  
<span class="line-modified">! ValueProfile* CodeBlock::tryGetValueProfileForBytecodeIndex(BytecodeIndex bytecodeIndex)</span>
  {
<span class="line-modified">!     auto instruction = instructions().at(bytecodeIndex);</span>
      switch (instruction-&gt;opcodeID()) {
  
  #define CASE(Op) \
      case Op::opcodeID: \
          return &amp;instruction-&gt;as&lt;Op&gt;().metadata(this).m_profile;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2986,27 ***</span>
          return nullptr;
  
      }
  }
  
<span class="line-modified">! SpeculatedType CodeBlock::valueProfilePredictionForBytecodeOffset(const ConcurrentJSLocker&amp; locker, int bytecodeOffset)</span>
  {
<span class="line-modified">!     if (ValueProfile* valueProfile = tryGetValueProfileForBytecodeOffset(bytecodeOffset))</span>
          return valueProfile-&gt;computeUpdatedPrediction(locker);
      return SpecNone;
  }
  
<span class="line-modified">! ValueProfile&amp; CodeBlock::valueProfileForBytecodeOffset(int bytecodeOffset)</span>
  {
<span class="line-modified">!     return *tryGetValueProfileForBytecodeOffset(bytecodeOffset);</span>
  }
  
  void CodeBlock::validate()
  {
      BytecodeLivenessAnalysis liveness(this); // Compute directly from scratch so it doesn&#39;t effect CodeBlock footprint.
  
<span class="line-modified">!     FastBitVector liveAtHead = liveness.getLivenessInfoAtBytecodeOffset(this, 0);</span>
  
      if (liveAtHead.numBits() != static_cast&lt;size_t&gt;(m_numCalleeLocals)) {
          beginValidationDidFail();
          dataLog(&quot;    Wrong number of bits in result!\n&quot;);
          dataLog(&quot;    Result: &quot;, liveAtHead, &quot;\n&quot;);
<span class="line-new-header">--- 3034,27 ---</span>
          return nullptr;
  
      }
  }
  
<span class="line-modified">! SpeculatedType CodeBlock::valueProfilePredictionForBytecodeIndex(const ConcurrentJSLocker&amp; locker, BytecodeIndex bytecodeIndex)</span>
  {
<span class="line-modified">!     if (ValueProfile* valueProfile = tryGetValueProfileForBytecodeIndex(bytecodeIndex))</span>
          return valueProfile-&gt;computeUpdatedPrediction(locker);
      return SpecNone;
  }
  
<span class="line-modified">! ValueProfile&amp; CodeBlock::valueProfileForBytecodeIndex(BytecodeIndex bytecodeIndex)</span>
  {
<span class="line-modified">!     return *tryGetValueProfileForBytecodeIndex(bytecodeIndex);</span>
  }
  
  void CodeBlock::validate()
  {
      BytecodeLivenessAnalysis liveness(this); // Compute directly from scratch so it doesn&#39;t effect CodeBlock footprint.
  
<span class="line-modified">!     FastBitVector liveAtHead = liveness.getLivenessInfoAtBytecodeIndex(this, BytecodeIndex(0));</span>
  
      if (liveAtHead.numBits() != static_cast&lt;size_t&gt;(m_numCalleeLocals)) {
          beginValidationDidFail();
          dataLog(&quot;    Wrong number of bits in result!\n&quot;);
          dataLog(&quot;    Result: &quot;, liveAtHead, &quot;\n&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3026,11 ***</span>
      }
  
      const InstructionStream&amp; instructionStream = instructions();
      for (const auto&amp; instruction : instructionStream) {
          OpcodeID opcode = instruction-&gt;opcodeID();
<span class="line-modified">!         if (!!baselineAlternative()-&gt;handlerForBytecodeOffset(instruction.offset())) {</span>
              if (opcode == op_catch || opcode == op_enter) {
                  // op_catch/op_enter logically represent an entrypoint. Entrypoints are not allowed to be
                  // inside of a try block because they are responsible for bootstrapping state. And they
                  // are never allowed throw an exception because of this. We rely on this when compiling
                  // in the DFG. Because an entrypoint never throws, the bytecode generator will never
<span class="line-new-header">--- 3074,11 ---</span>
      }
  
      const InstructionStream&amp; instructionStream = instructions();
      for (const auto&amp; instruction : instructionStream) {
          OpcodeID opcode = instruction-&gt;opcodeID();
<span class="line-modified">!         if (!!baselineAlternative()-&gt;handlerForBytecodeIndex(BytecodeIndex(instruction.offset()))) {</span>
              if (opcode == op_catch || opcode == op_enter) {
                  // op_catch/op_enter logically represent an entrypoint. Entrypoints are not allowed to be
                  // inside of a try block because they are responsible for bootstrapping state. And they
                  // are never allowed throw an exception because of this. We rely on this when compiling
                  // in the DFG. Because an entrypoint never throws, the bytecode generator will never
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3084,20 ***</span>
      int offset = bytecodeOffset(pc);
      int target = m_unlinkedCode-&gt;outOfLineJumpOffset(offset);
      return instructions().at(offset + target).ptr();
  }
  
<span class="line-modified">! ArithProfile* CodeBlock::arithProfileForBytecodeOffset(InstructionStream::Offset bytecodeOffset)</span>
  {
<span class="line-modified">!     return arithProfileForPC(instructions().at(bytecodeOffset).ptr());</span>
  }
  
<span class="line-modified">! ArithProfile* CodeBlock::arithProfileForPC(const Instruction* pc)</span>
  {
      switch (pc-&gt;opcodeID()) {
<span class="line-removed">-     case op_negate:</span>
<span class="line-removed">-         return &amp;pc-&gt;as&lt;OpNegate&gt;().metadata(this).m_arithProfile;</span>
      case op_add:
          return &amp;pc-&gt;as&lt;OpAdd&gt;().metadata(this).m_arithProfile;
      case op_mul:
          return &amp;pc-&gt;as&lt;OpMul&gt;().metadata(this).m_arithProfile;
      case op_sub:
<span class="line-new-header">--- 3132,23 ---</span>
      int offset = bytecodeOffset(pc);
      int target = m_unlinkedCode-&gt;outOfLineJumpOffset(offset);
      return instructions().at(offset + target).ptr();
  }
  
<span class="line-modified">! BinaryArithProfile* CodeBlock::binaryArithProfileForBytecodeIndex(BytecodeIndex bytecodeIndex)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     return binaryArithProfileForPC(instructions().at(bytecodeIndex.offset()).ptr());</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ UnaryArithProfile* CodeBlock::unaryArithProfileForBytecodeIndex(BytecodeIndex bytecodeIndex)</span>
  {
<span class="line-modified">!     return unaryArithProfileForPC(instructions().at(bytecodeIndex.offset()).ptr());</span>
  }
  
<span class="line-modified">! BinaryArithProfile* CodeBlock::binaryArithProfileForPC(const Instruction* pc)</span>
  {
      switch (pc-&gt;opcodeID()) {
      case op_add:
          return &amp;pc-&gt;as&lt;OpAdd&gt;().metadata(this).m_arithProfile;
      case op_mul:
          return &amp;pc-&gt;as&lt;OpMul&gt;().metadata(this).m_arithProfile;
      case op_sub:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3109,15 ***</span>
      }
  
      return nullptr;
  }
  
<span class="line-modified">! bool CodeBlock::couldTakeSpecialFastCase(InstructionStream::Offset bytecodeOffset)</span>
  {
      if (!hasBaselineJITProfiling())
          return false;
<span class="line-modified">!     ArithProfile* profile = arithProfileForBytecodeOffset(bytecodeOffset);</span>
      if (!profile)
          return false;
      return profile-&gt;tookSpecialFastPath();
  }
  
<span class="line-new-header">--- 3160,31 ---</span>
      }
  
      return nullptr;
  }
  
<span class="line-modified">! UnaryArithProfile* CodeBlock::unaryArithProfileForPC(const Instruction* pc)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     switch (pc-&gt;opcodeID()) {</span>
<span class="line-added">+     case op_negate:</span>
<span class="line-added">+         return &amp;pc-&gt;as&lt;OpNegate&gt;().metadata(this).m_arithProfile;</span>
<span class="line-added">+     case op_inc:</span>
<span class="line-added">+         return &amp;pc-&gt;as&lt;OpInc&gt;().metadata(this).m_arithProfile;</span>
<span class="line-added">+     case op_dec:</span>
<span class="line-added">+         return &amp;pc-&gt;as&lt;OpDec&gt;().metadata(this).m_arithProfile;</span>
<span class="line-added">+     default:</span>
<span class="line-added">+         break;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     return nullptr;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ bool CodeBlock::couldTakeSpecialArithFastCase(BytecodeIndex bytecodeIndex)</span>
  {
      if (!hasBaselineJITProfiling())
          return false;
<span class="line-modified">!     BinaryArithProfile* profile = binaryArithProfileForBytecodeIndex(bytecodeIndex);</span>
      if (!profile)
          return false;
      return profile-&gt;tookSpecialFastPath();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3132,11 ***</span>
  
  void CodeBlock::insertBasicBlockBoundariesForControlFlowProfiler()
  {
      if (!unlinkedCodeBlock()-&gt;hasOpProfileControlFlowBytecodeOffsets())
          return;
<span class="line-modified">!     const Vector&lt;InstructionStream::Offset&gt;&amp; bytecodeOffsets = unlinkedCodeBlock()-&gt;opProfileControlFlowBytecodeOffsets();</span>
      for (size_t i = 0, offsetsLength = bytecodeOffsets.size(); i &lt; offsetsLength; i++) {
          // Because op_profile_control_flow is emitted at the beginning of every basic block, finding
          // the next op_profile_control_flow will give us the text range of a single basic block.
          size_t startIdx = bytecodeOffsets[i];
          auto instruction = instructions().at(startIdx);
<span class="line-new-header">--- 3199,11 ---</span>
  
  void CodeBlock::insertBasicBlockBoundariesForControlFlowProfiler()
  {
      if (!unlinkedCodeBlock()-&gt;hasOpProfileControlFlowBytecodeOffsets())
          return;
<span class="line-modified">!     const RefCountedArray&lt;InstructionStream::Offset&gt;&amp; bytecodeOffsets = unlinkedCodeBlock()-&gt;opProfileControlFlowBytecodeOffsets();</span>
      for (size_t i = 0, offsetsLength = bytecodeOffsets.size(); i &lt; offsetsLength; i++) {
          // Because op_profile_control_flow is emitted at the beginning of every basic block, finding
          // the next op_profile_control_flow will give us the text range of a single basic block.
          size_t startIdx = bytecodeOffsets[i];
          auto instruction = instructions().at(startIdx);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3232,32 ***</span>
  
      return WTF::nullopt;
  }
  #endif // ENABLE(JIT)
  
<span class="line-modified">! Optional&lt;unsigned&gt; CodeBlock::bytecodeOffsetFromCallSiteIndex(CallSiteIndex callSiteIndex)</span>
  {
<span class="line-modified">!     Optional&lt;unsigned&gt; bytecodeOffset;</span>
      JITType jitType = this-&gt;jitType();
<span class="line-modified">!     if (jitType == JITType::InterpreterThunk || jitType == JITType::BaselineJIT) {</span>
<span class="line-modified">! #if USE(JSVALUE64)</span>
<span class="line-modified">!         bytecodeOffset = callSiteIndex.bits();</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-         Instruction* instruction = bitwise_cast&lt;Instruction*&gt;(callSiteIndex.bits());</span>
<span class="line-removed">-         bytecodeOffset = this-&gt;bytecodeOffset(instruction);</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     } else if (jitType == JITType::DFGJIT || jitType == JITType::FTLJIT) {</span>
  #if ENABLE(DFG_JIT)
          RELEASE_ASSERT(canGetCodeOrigin(callSiteIndex));
          CodeOrigin origin = codeOrigin(callSiteIndex);
<span class="line-modified">!         bytecodeOffset = origin.bytecodeIndex();</span>
  #else
          RELEASE_ASSERT_NOT_REACHED();
  #endif
      }
  
<span class="line-modified">!     return bytecodeOffset;</span>
  }
  
  int32_t CodeBlock::thresholdForJIT(int32_t threshold)
  {
      switch (unlinkedCodeBlock()-&gt;didOptimize()) {
<span class="line-new-header">--- 3299,27 ---</span>
  
      return WTF::nullopt;
  }
  #endif // ENABLE(JIT)
  
<span class="line-modified">! Optional&lt;BytecodeIndex&gt; CodeBlock::bytecodeIndexFromCallSiteIndex(CallSiteIndex callSiteIndex)</span>
  {
<span class="line-modified">!     Optional&lt;BytecodeIndex&gt; bytecodeIndex;</span>
      JITType jitType = this-&gt;jitType();
<span class="line-modified">!     if (jitType == JITType::InterpreterThunk || jitType == JITType::BaselineJIT)</span>
<span class="line-modified">!         bytecodeIndex = callSiteIndex.bytecodeIndex();</span>
<span class="line-modified">!     else if (jitType == JITType::DFGJIT || jitType == JITType::FTLJIT) {</span>
  #if ENABLE(DFG_JIT)
          RELEASE_ASSERT(canGetCodeOrigin(callSiteIndex));
          CodeOrigin origin = codeOrigin(callSiteIndex);
<span class="line-modified">!         bytecodeIndex = origin.bytecodeIndex();</span>
  #else
          RELEASE_ASSERT_NOT_REACHED();
  #endif
      }
  
<span class="line-modified">!     return bytecodeIndex;</span>
  }
  
  int32_t CodeBlock::thresholdForJIT(int32_t threshold)
  {
      switch (unlinkedCodeBlock()-&gt;didOptimize()) {
</pre>
<center><a href="CallVariant.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="CodeBlock.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
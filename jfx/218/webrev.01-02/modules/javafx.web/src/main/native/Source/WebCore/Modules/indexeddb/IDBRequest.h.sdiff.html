<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBRequest.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IDBRequest.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBRequestCompletionEvent.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/IDBRequest.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
101     IndexedDB::ObjectStoreRecordType requestedObjectStoreRecordType() const;
102     IndexedDB::IndexRecordType requestedIndexRecordType() const;
103 
104     ScriptExecutionContext* scriptExecutionContext() const final { return ActiveDOMObject::scriptExecutionContext(); }
105 
106     using ThreadSafeRefCounted::ref;
107     using ThreadSafeRefCounted::deref;
108 
109     void completeRequestAndDispatchEvent(const IDBResultData&amp;);
110 
111     void setResult(const IDBKeyData&amp;);
112     void setResult(const Vector&lt;IDBKeyData&gt;&amp;);
113     void setResultToStructuredClone(const IDBGetResult&amp;);
114     void setResult(const IDBGetAllResult&amp;);
115     void setResult(uint64_t);
116     void setResultToUndefined();
117 
118     void willIterateCursor(IDBCursor&amp;);
119     void didOpenOrIterateCursor(const IDBResultData&amp;);
120 
<span class="line-modified">121     const IDBCursor* pendingCursor() const { return m_pendingCursor.get(); }</span>
122 
123     void setSource(IDBCursor&amp;);
124     void setVersionChangeTransaction(IDBTransaction&amp;);
125 
126     IndexedDB::RequestType requestType() const { return m_requestType; }
127 
128     bool hasPendingActivity() const final;
129 


130 protected:
131     IDBRequest(ScriptExecutionContext&amp;, IDBClient::IDBConnectionProxy&amp;);
132 
133     void enqueueEvent(Ref&lt;Event&gt;&amp;&amp;);
134     void dispatchEvent(Event&amp;) override;
135 
136     void setResult(Ref&lt;IDBDatabase&gt;&amp;&amp;);
137 
138     IDBClient::IDBConnectionProxy&amp; connectionProxy() { return m_connectionProxy.get(); }
139 
140     // FIXME: Protected data members aren&#39;t great for maintainability.
141     // Consider adding protected helper functions and making these private.
142     ReadyState m_readyState { ReadyState::Pending };
143     RefPtr&lt;IDBTransaction&gt; m_transaction;
144     bool m_shouldExposeTransactionToDOM { true };
145     RefPtr&lt;DOMException&gt; m_domError;
146     IndexedDB::RequestType m_requestType { IndexedDB::RequestType::Other };
147     bool m_contextStopped { false };
148     Event* m_openDatabaseSuccessEvent { nullptr };
149 
150 private:
151     IDBRequest(ScriptExecutionContext&amp;, IDBObjectStore&amp;, IDBTransaction&amp;);
152     IDBRequest(ScriptExecutionContext&amp;, IDBCursor&amp;, IDBTransaction&amp;);
153     IDBRequest(ScriptExecutionContext&amp;, IDBIndex&amp;, IDBTransaction&amp;);
154     IDBRequest(ScriptExecutionContext&amp;, IDBObjectStore&amp;, IndexedDB::ObjectStoreRecordType, IDBTransaction&amp;);
155     IDBRequest(ScriptExecutionContext&amp;, IDBIndex&amp;, IndexedDB::IndexRecordType, IDBTransaction&amp;);
156 
157     EventTargetInterface eventTargetInterface() const override;
158 
159     const char* activeDOMObjectName() const final;
<span class="line-removed">160     bool canSuspendForDocumentSuspension() const final;</span>
161     void stop() final;
162     virtual void cancelForStop();
163 
164     void refEventTarget() final { ref(); }
165     void derefEventTarget() final { deref(); }
166     void uncaughtExceptionInEventHandler() final;
167 
168     virtual bool isOpenDBRequest() const { return false; }
169 
170     void onError();
171     void onSuccess();
172 
173     void clearWrappers();
174 
175     IDBCursor* resultCursor();
176 
177     IDBError m_idbError;
178     IDBResourceIdentifier m_resourceIdentifier;
179 
180     JSValueInWrappedObject m_resultWrapper;
181     JSValueInWrappedObject m_cursorWrapper;
182     Result m_result;
183     Optional&lt;Source&gt; m_source;
184 
185     bool m_hasPendingActivity { true };
186     IndexedDB::ObjectStoreRecordType m_requestedObjectStoreRecordType { IndexedDB::ObjectStoreRecordType::ValueOnly };
187     IndexedDB::IndexRecordType m_requestedIndexRecordType { IndexedDB::IndexRecordType::Key };
188 
189     RefPtr&lt;IDBCursor&gt; m_pendingCursor;
190 
191     Ref&lt;IDBClient::IDBConnectionProxy&gt; m_connectionProxy;
192 
193     bool m_dispatchingEvent { false };
194     bool m_hasUncaughtException { false };


195 };
196 
197 } // namespace WebCore
198 
199 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
<td>
<hr />
<pre>
101     IndexedDB::ObjectStoreRecordType requestedObjectStoreRecordType() const;
102     IndexedDB::IndexRecordType requestedIndexRecordType() const;
103 
104     ScriptExecutionContext* scriptExecutionContext() const final { return ActiveDOMObject::scriptExecutionContext(); }
105 
106     using ThreadSafeRefCounted::ref;
107     using ThreadSafeRefCounted::deref;
108 
109     void completeRequestAndDispatchEvent(const IDBResultData&amp;);
110 
111     void setResult(const IDBKeyData&amp;);
112     void setResult(const Vector&lt;IDBKeyData&gt;&amp;);
113     void setResultToStructuredClone(const IDBGetResult&amp;);
114     void setResult(const IDBGetAllResult&amp;);
115     void setResult(uint64_t);
116     void setResultToUndefined();
117 
118     void willIterateCursor(IDBCursor&amp;);
119     void didOpenOrIterateCursor(const IDBResultData&amp;);
120 
<span class="line-modified">121     IDBCursor* pendingCursor() const { return m_pendingCursor ? m_pendingCursor.get() : nullptr; }</span>
122 
123     void setSource(IDBCursor&amp;);
124     void setVersionChangeTransaction(IDBTransaction&amp;);
125 
126     IndexedDB::RequestType requestType() const { return m_requestType; }
127 
128     bool hasPendingActivity() const final;
129 
<span class="line-added">130     void setTransactionOperationID(uint64_t transactionOperationID) { m_currentTransactionOperationID = transactionOperationID; }</span>
<span class="line-added">131 </span>
132 protected:
133     IDBRequest(ScriptExecutionContext&amp;, IDBClient::IDBConnectionProxy&amp;);
134 
135     void enqueueEvent(Ref&lt;Event&gt;&amp;&amp;);
136     void dispatchEvent(Event&amp;) override;
137 
138     void setResult(Ref&lt;IDBDatabase&gt;&amp;&amp;);
139 
140     IDBClient::IDBConnectionProxy&amp; connectionProxy() { return m_connectionProxy.get(); }
141 
142     // FIXME: Protected data members aren&#39;t great for maintainability.
143     // Consider adding protected helper functions and making these private.
144     ReadyState m_readyState { ReadyState::Pending };
145     RefPtr&lt;IDBTransaction&gt; m_transaction;
146     bool m_shouldExposeTransactionToDOM { true };
147     RefPtr&lt;DOMException&gt; m_domError;
148     IndexedDB::RequestType m_requestType { IndexedDB::RequestType::Other };
149     bool m_contextStopped { false };
150     Event* m_openDatabaseSuccessEvent { nullptr };
151 
152 private:
153     IDBRequest(ScriptExecutionContext&amp;, IDBObjectStore&amp;, IDBTransaction&amp;);
154     IDBRequest(ScriptExecutionContext&amp;, IDBCursor&amp;, IDBTransaction&amp;);
155     IDBRequest(ScriptExecutionContext&amp;, IDBIndex&amp;, IDBTransaction&amp;);
156     IDBRequest(ScriptExecutionContext&amp;, IDBObjectStore&amp;, IndexedDB::ObjectStoreRecordType, IDBTransaction&amp;);
157     IDBRequest(ScriptExecutionContext&amp;, IDBIndex&amp;, IndexedDB::IndexRecordType, IDBTransaction&amp;);
158 
159     EventTargetInterface eventTargetInterface() const override;
160 
161     const char* activeDOMObjectName() const final;

162     void stop() final;
163     virtual void cancelForStop();
164 
165     void refEventTarget() final { ref(); }
166     void derefEventTarget() final { deref(); }
167     void uncaughtExceptionInEventHandler() final;
168 
169     virtual bool isOpenDBRequest() const { return false; }
170 
171     void onError();
172     void onSuccess();
173 
174     void clearWrappers();
175 
176     IDBCursor* resultCursor();
177 
178     IDBError m_idbError;
179     IDBResourceIdentifier m_resourceIdentifier;
180 
181     JSValueInWrappedObject m_resultWrapper;
182     JSValueInWrappedObject m_cursorWrapper;
183     Result m_result;
184     Optional&lt;Source&gt; m_source;
185 
186     bool m_hasPendingActivity { true };
187     IndexedDB::ObjectStoreRecordType m_requestedObjectStoreRecordType { IndexedDB::ObjectStoreRecordType::ValueOnly };
188     IndexedDB::IndexRecordType m_requestedIndexRecordType { IndexedDB::IndexRecordType::Key };
189 
190     RefPtr&lt;IDBCursor&gt; m_pendingCursor;
191 
192     Ref&lt;IDBClient::IDBConnectionProxy&gt; m_connectionProxy;
193 
194     bool m_dispatchingEvent { false };
195     bool m_hasUncaughtException { false };
<span class="line-added">196 </span>
<span class="line-added">197     uint64_t m_currentTransactionOperationID { 0 };</span>
198 };
199 
200 } // namespace WebCore
201 
202 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
</tr>
</table>
<center><a href="IDBRequest.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="IDBRequestCompletionEvent.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
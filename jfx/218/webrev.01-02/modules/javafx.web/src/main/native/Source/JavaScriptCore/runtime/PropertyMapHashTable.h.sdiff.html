<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/PropertyMapHashTable.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="PropertyDescriptor.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PropertyNameArray.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/PropertyMapHashTable.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  *  Copyright (C) 2004, 2005, 2006, 2007, 2008, 2014 Apple Inc. All rights reserved.</span>
  3  *
  4  *  This library is free software; you can redistribute it and/or
  5  *  modify it under the terms of the GNU Library General Public
  6  *  License as published by the Free Software Foundation; either
  7  *  version 2 of the License, or (at your option) any later version.
  8  *
  9  *  This library is distributed in the hope that it will be useful,
 10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  *  Library General Public License for more details.
 13  *
 14  *  You should have received a copy of the GNU Library General Public License
 15  *  along with this library; see the file COPYING.LIB.  If not, write to
 16  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  *  Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #pragma once
 22 
 23 #include &quot;JSExportMacros.h&quot;
 24 #include &quot;PropertyOffset.h&quot;
 25 #include &quot;Structure.h&quot;
 26 #include &quot;WriteBarrier.h&quot;
 27 #include &lt;wtf/HashTable.h&gt;
 28 #include &lt;wtf/MathExtras.h&gt;
 29 #include &lt;wtf/Vector.h&gt;
 30 #include &lt;wtf/text/AtomStringImpl.h&gt;
 31 
 32 
 33 #define DUMP_PROPERTYMAP_STATS 0
 34 #define DUMP_PROPERTYMAP_COLLISIONS 0
 35 
 36 #define PROPERTY_MAP_DELETED_ENTRY_KEY ((UniquedStringImpl*)1)
 37 
 38 namespace JSC {
 39 


 40 #if DUMP_PROPERTYMAP_STATS
 41 
 42 struct PropertyMapHashTableStats {
 43     std::atomic&lt;unsigned&gt; numFinds;
 44     std::atomic&lt;unsigned&gt; numCollisions;
 45     std::atomic&lt;unsigned&gt; numLookups;
 46     std::atomic&lt;unsigned&gt; numLookupProbing;
 47     std::atomic&lt;unsigned&gt; numAdds;
 48     std::atomic&lt;unsigned&gt; numRemoves;
 49     std::atomic&lt;unsigned&gt; numRehashes;
 50     std::atomic&lt;unsigned&gt; numReinserts;
 51 };
 52 
 53 JS_EXPORT_PRIVATE extern PropertyMapHashTableStats* propertyMapHashTableStats;
 54 
 55 #endif
 56 
 57 inline bool isPowerOf2(unsigned v)
 58 {
 59     return hasOneBitSet(v);
</pre>
<hr />
<pre>
104         }
105 
106         T* operator-&gt;()
107         {
108             return m_valuePtr;
109         }
110 
111         ordered_iterator(T* valuePtr, T* endValuePtr)
112             : m_valuePtr(valuePtr)
113             , m_endValuePtr(endValuePtr)
114         {
115         }
116 
117     private:
118         T* m_valuePtr;
119         T* m_endValuePtr;
120     };
121 
122 public:
123     typedef JSCell Base;
<span class="line-modified">124     static const unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
125 
126     template&lt;typename CellType, SubspaceAccess&gt;
127     static IsoSubspace* subspaceFor(VM&amp; vm)
128     {
129         return &amp;vm.propertyTableSpace;
130     }
131 
<span class="line-modified">132     static const bool needsDestruction = true;</span>
133     static void destroy(JSCell*);
134 
135     DECLARE_EXPORT_INFO;
136 
137     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
138     {
139         return Structure::create(vm, globalObject, prototype, TypeInfo(CellType, StructureFlags), info());
140     }
141 
142     typedef UniquedStringImpl* KeyType;
143     typedef PropertyMapEntry ValueType;
144 
145     // The in order iterator provides overloaded * and -&gt; to access the Value at the current position.
146     typedef ordered_iterator&lt;ValueType&gt; iterator;
147     typedef ordered_iterator&lt;const ValueType&gt; const_iterator;
148 
149     // The find_iterator is a pair of a pointer to a Value* an the entry in the index.
150     // If &#39;find&#39; does not find an entry then iter.first will be 0, and iter.second will
151     // give the point in m_index where an entry should be inserted.
152     typedef std::pair&lt;ValueType*, unsigned&gt; find_iterator;
153 
154     // Constructor is passed an initial capacity, a PropertyTable to copy, or both.
155     static PropertyTable* create(VM&amp;, unsigned initialCapacity);
156     static PropertyTable* clone(VM&amp;, const PropertyTable&amp;);
157     static PropertyTable* clone(VM&amp;, unsigned initialCapacity, const PropertyTable&amp;);
158     ~PropertyTable();
159 
160     // Ordered iteration methods.
161     iterator begin();
162     iterator end();
163     const_iterator begin() const;
164     const_iterator end() const;
165 
166     // Find a value in the table.
167     find_iterator find(const KeyType&amp;);
168     ValueType* get(const KeyType&amp;);
169     // Add a value to the table
<span class="line-modified">170     enum EffectOnPropertyOffset { PropertyOffsetMayChange, PropertyOffsetMustNotChange };</span>
<span class="line-removed">171     std::pair&lt;find_iterator, bool&gt; add(const ValueType&amp; entry, PropertyOffset&amp;, EffectOnPropertyOffset);</span>
172     // Remove a value from the table.
173     void remove(const find_iterator&amp; iter);
174     void remove(const KeyType&amp; key);
175 
176     // Returns the number of values in the hashtable.
177     unsigned size() const;
178 
179     // Checks if there are any values in the hashtable.
180     bool isEmpty() const;
181 
182     // Number of slots in the property storage array in use, included deletedOffsets.
183     unsigned propertyStorageSize() const;
184 
185     // Used to maintain a list of unused entries in the property storage.
186     void clearDeletedOffsets();
187     bool hasDeletedOffset();
188     PropertyOffset getDeletedOffset();
189     void addDeletedOffset(PropertyOffset);
190 
191     PropertyOffset nextOffset(PropertyOffset inlineCapacity);
192 
193     // Copy this PropertyTable, ensuring the copy has at least the capacity provided.
194     PropertyTable* copy(VM&amp;, unsigned newCapacity);
195 
196 #ifndef NDEBUG
197     size_t sizeInMemory();
198     void checkConsistency();
199 #endif
200 
201     static ptrdiff_t offsetOfIndexSize() { return OBJECT_OFFSETOF(PropertyTable, m_indexSize); }
202     static ptrdiff_t offsetOfIndexMask() { return OBJECT_OFFSETOF(PropertyTable, m_indexMask); }
203     static ptrdiff_t offsetOfIndex() { return OBJECT_OFFSETOF(PropertyTable, m_index); }
204 
<span class="line-modified">205     static const unsigned EmptyEntryIndex = 0;</span>
206 
207 private:
208     PropertyTable(VM&amp;, unsigned initialCapacity);
209     PropertyTable(VM&amp;, const PropertyTable&amp;);
210     PropertyTable(VM&amp;, unsigned initialCapacity, const PropertyTable&amp;);
211 
212     PropertyTable(const PropertyTable&amp;);
213     // Used to insert a value known not to be in the table, and where we know capacity to be available.
214     void reinsert(const ValueType&amp; entry);
215 
216     // Rehash the table.  Used to grow, or to recover deleted slots.
217     void rehash(unsigned newCapacity);
218 
219     // The capacity of the table of values is half of the size of the index.
220     unsigned tableCapacity() const;
221 
222     // We keep an extra deleted slot after the array to make iteration work,
223     // and to use for deleted values. Index values into the array are 1-based,
224     // so this is tableCapacity() + 1.
225     // For example, if m_tableSize is 16, then tableCapacity() is 8 - but the
</pre>
<hr />
<pre>
241 
242     // total number of  used entries in the values array - by either valid entries, or deleted ones.
243     unsigned usedCount() const;
244 
245     // The size in bytes of data needed for by the table.
246     size_t dataSize();
247 
248     // Calculates the appropriate table size (rounds up to a power of two).
249     static unsigned sizeForCapacity(unsigned capacity);
250 
251     // Check if capacity is available.
252     bool canInsert();
253 
254     unsigned m_indexSize;
255     unsigned m_indexMask;
256     unsigned* m_index;
257     unsigned m_keyCount;
258     unsigned m_deletedCount;
259     std::unique_ptr&lt;Vector&lt;PropertyOffset&gt;&gt; m_deletedOffsets;
260 
<span class="line-modified">261     static const unsigned MinimumTableSize = 16;</span>
262 };
263 
264 inline PropertyTable::iterator PropertyTable::begin()
265 {
266     auto* tableEnd = this-&gt;tableEnd();
267     return iterator(skipDeletedEntries(table(), tableEnd), tableEnd);
268 }
269 
270 inline PropertyTable::iterator PropertyTable::end()
271 {
272     auto* tableEnd = this-&gt;tableEnd();
273     return iterator(tableEnd, tableEnd);
274 }
275 
276 inline PropertyTable::const_iterator PropertyTable::begin() const
277 {
278     auto* tableEnd = this-&gt;tableEnd();
279     return const_iterator(skipDeletedEntries(table(), tableEnd), tableEnd);
280 }
281 
</pre>
<hr />
<pre>
302         if (key == table()[entryIndex - 1].key)
303             return std::make_pair(&amp;table()[entryIndex - 1], hash &amp; m_indexMask);
304 
305 #if DUMP_PROPERTYMAP_STATS
306         ++propertyMapHashTableStats-&gt;numCollisions;
307 #endif
308 
309 #if DUMP_PROPERTYMAP_COLLISIONS
310         dataLog(&quot;PropertyTable collision for &quot;, key, &quot; (&quot;, hash, &quot;)\n&quot;);
311         dataLog(&quot;Collided with &quot;, table()[entryIndex - 1].key, &quot;(&quot;, IdentifierRepHash::hash(table()[entryIndex - 1].key), &quot;)\n&quot;);
312 #endif
313 
314         hash++;
315     }
316 }
317 
318 inline PropertyTable::ValueType* PropertyTable::get(const KeyType&amp; key)
319 {
320     ASSERT(key);
321     ASSERT(key-&gt;isAtom() || key-&gt;isSymbol());

322 
323     if (!m_keyCount)
324         return nullptr;
325 
326     unsigned hash = IdentifierRepHash::hash(key);
327 
328 #if DUMP_PROPERTYMAP_STATS
329     ++propertyMapHashTableStats-&gt;numLookups;
330 #endif
331 
332     while (true) {
333         unsigned entryIndex = m_index[hash &amp; m_indexMask];
334         if (entryIndex == EmptyEntryIndex)
335             return nullptr;
<span class="line-modified">336         if (key == table()[entryIndex - 1].key)</span>

337             return &amp;table()[entryIndex - 1];

338 
339 #if DUMP_PROPERTYMAP_STATS
340         ++propertyMapHashTableStats-&gt;numLookupProbing;
341 #endif
342 
343         hash++;
344     }
345 }
346 
<span class="line-modified">347 inline std::pair&lt;PropertyTable::find_iterator, bool&gt; PropertyTable::add(const ValueType&amp; entry, PropertyOffset&amp; offset, EffectOnPropertyOffset offsetEffect)</span>
348 {


349     // Look for a value with a matching key already in the array.
350     find_iterator iter = find(entry.key);
<span class="line-modified">351     if (iter.first) {</span>
<span class="line-removed">352         RELEASE_ASSERT(iter.first-&gt;offset &lt;= offset);</span>
353         return std::make_pair(iter, false);
<span class="line-removed">354     }</span>
355 
356 #if DUMP_PROPERTYMAP_STATS
357     ++propertyMapHashTableStats-&gt;numAdds;
358 #endif
359 
360     // Ref the key
361     entry.key-&gt;ref();
362 
363     // ensure capacity is available.
364     if (!canInsert()) {
365         rehash(m_keyCount + 1);
366         iter = find(entry.key);
367         ASSERT(!iter.first);
368     }
369 
370     // Allocate a slot in the hashtable, and set the index to reference this.
371     unsigned entryIndex = usedCount() + 1;
372     m_index[iter.second] = entryIndex;
373     iter.first = &amp;table()[entryIndex - 1];
374     *iter.first = entry;
375 
376     ++m_keyCount;
377 
<span class="line-removed">378     if (offsetEffect == PropertyOffsetMayChange)</span>
<span class="line-removed">379         offset = std::max(offset, entry.offset);</span>
<span class="line-removed">380     else</span>
<span class="line-removed">381         RELEASE_ASSERT(offset &gt;= entry.offset);</span>
<span class="line-removed">382 </span>
383     return std::make_pair(iter, true);
384 }
385 
386 inline void PropertyTable::remove(const find_iterator&amp; iter)
387 {
388     // Removing a key that doesn&#39;t exist does nothing!
389     if (!iter.first)
390         return;
391 
392 #if DUMP_PROPERTYMAP_STATS
393     ++propertyMapHashTableStats-&gt;numRemoves;
394 #endif
395 
396     // Replace this one element with the deleted sentinel. Also clear out
397     // the entry so we can iterate all the entries as needed.
398     m_index[iter.second] = deletedEntryIndex();
399     iter.first-&gt;key-&gt;deref();
400     iter.first-&gt;key = PROPERTY_MAP_DELETED_ENTRY_KEY;
401 
402     ASSERT(m_keyCount &gt;= 1);
</pre>
<hr />
<pre>
432 {
433     m_deletedOffsets = nullptr;
434 }
435 
436 inline bool PropertyTable::hasDeletedOffset()
437 {
438     return m_deletedOffsets &amp;&amp; !m_deletedOffsets-&gt;isEmpty();
439 }
440 
441 inline PropertyOffset PropertyTable::getDeletedOffset()
442 {
443     PropertyOffset offset = m_deletedOffsets-&gt;last();
444     m_deletedOffsets-&gt;removeLast();
445     return offset;
446 }
447 
448 inline void PropertyTable::addDeletedOffset(PropertyOffset offset)
449 {
450     if (!m_deletedOffsets)
451         m_deletedOffsets = makeUnique&lt;Vector&lt;PropertyOffset&gt;&gt;();

452     m_deletedOffsets-&gt;append(offset);
453 }
454 
455 inline PropertyOffset PropertyTable::nextOffset(PropertyOffset inlineCapacity)
456 {
457     if (hasDeletedOffset())
458         return getDeletedOffset();
459 
460     return offsetForPropertyNumber(size(), inlineCapacity);
461 }
462 
463 inline PropertyTable* PropertyTable::copy(VM&amp; vm, unsigned newCapacity)
464 {
465     ASSERT(newCapacity &gt;= m_keyCount);
466 
467     // Fast case; if the new table will be the same m_indexSize as this one, we can memcpy it,
468     // save rehashing all keys.
469     if (sizeForCapacity(newCapacity) == m_indexSize)
470         return PropertyTable::clone(vm, *this);
471     return PropertyTable::clone(vm, newCapacity, *this);
</pre>
<hr />
<pre>
497     m_index[iter.second] = entryIndex;
498     table()[entryIndex - 1] = entry;
499 
500     ++m_keyCount;
501 }
502 
503 inline void PropertyTable::rehash(unsigned newCapacity)
504 {
505 #if DUMP_PROPERTYMAP_STATS
506     ++propertyMapHashTableStats-&gt;numRehashes;
507 #endif
508 
509     unsigned* oldEntryIndices = m_index;
510     iterator iter = this-&gt;begin();
511     iterator end = this-&gt;end();
512 
513     m_indexSize = sizeForCapacity(newCapacity);
514     m_indexMask = m_indexSize - 1;
515     m_keyCount = 0;
516     m_deletedCount = 0;
<span class="line-modified">517     m_index = static_cast&lt;unsigned*&gt;(fastZeroedMalloc(dataSize()));</span>

518 
519     for (; iter != end; ++iter) {
520         ASSERT(canInsert());
521         reinsert(*iter);
522     }
523 
<span class="line-modified">524     fastFree(oldEntryIndices);</span>
525 }
526 
527 inline unsigned PropertyTable::tableCapacity() const { return m_indexSize &gt;&gt; 1; }
528 
529 inline unsigned PropertyTable::deletedEntryIndex() const { return tableCapacity() + 1; }
530 
531 template&lt;typename T&gt;
532 inline T* PropertyTable::skipDeletedEntries(T* valuePtr, T* endValuePtr)
533 {
534     while (valuePtr &lt; endValuePtr &amp;&amp; valuePtr-&gt;key == PROPERTY_MAP_DELETED_ENTRY_KEY)
535         ++valuePtr;
536     return valuePtr;
537 }
538 
539 inline PropertyTable::ValueType* PropertyTable::table()
540 {
541     // The table of values lies after the hash index.
542     return reinterpret_cast&lt;ValueType*&gt;(m_index + m_indexSize);
543 }
544 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  *  Copyright (C) 2004-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  *  This library is free software; you can redistribute it and/or
  5  *  modify it under the terms of the GNU Library General Public
  6  *  License as published by the Free Software Foundation; either
  7  *  version 2 of the License, or (at your option) any later version.
  8  *
  9  *  This library is distributed in the hope that it will be useful,
 10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  *  Library General Public License for more details.
 13  *
 14  *  You should have received a copy of the GNU Library General Public License
 15  *  along with this library; see the file COPYING.LIB.  If not, write to
 16  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  *  Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #pragma once
 22 
 23 #include &quot;JSExportMacros.h&quot;
 24 #include &quot;PropertyOffset.h&quot;
 25 #include &quot;Structure.h&quot;
 26 #include &quot;WriteBarrier.h&quot;
 27 #include &lt;wtf/HashTable.h&gt;
 28 #include &lt;wtf/MathExtras.h&gt;
 29 #include &lt;wtf/Vector.h&gt;
 30 #include &lt;wtf/text/AtomStringImpl.h&gt;
 31 
 32 
 33 #define DUMP_PROPERTYMAP_STATS 0
 34 #define DUMP_PROPERTYMAP_COLLISIONS 0
 35 
 36 #define PROPERTY_MAP_DELETED_ENTRY_KEY ((UniquedStringImpl*)1)
 37 
 38 namespace JSC {
 39 
<span class="line-added"> 40 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(PropertyTable);</span>
<span class="line-added"> 41 </span>
 42 #if DUMP_PROPERTYMAP_STATS
 43 
 44 struct PropertyMapHashTableStats {
 45     std::atomic&lt;unsigned&gt; numFinds;
 46     std::atomic&lt;unsigned&gt; numCollisions;
 47     std::atomic&lt;unsigned&gt; numLookups;
 48     std::atomic&lt;unsigned&gt; numLookupProbing;
 49     std::atomic&lt;unsigned&gt; numAdds;
 50     std::atomic&lt;unsigned&gt; numRemoves;
 51     std::atomic&lt;unsigned&gt; numRehashes;
 52     std::atomic&lt;unsigned&gt; numReinserts;
 53 };
 54 
 55 JS_EXPORT_PRIVATE extern PropertyMapHashTableStats* propertyMapHashTableStats;
 56 
 57 #endif
 58 
 59 inline bool isPowerOf2(unsigned v)
 60 {
 61     return hasOneBitSet(v);
</pre>
<hr />
<pre>
106         }
107 
108         T* operator-&gt;()
109         {
110             return m_valuePtr;
111         }
112 
113         ordered_iterator(T* valuePtr, T* endValuePtr)
114             : m_valuePtr(valuePtr)
115             , m_endValuePtr(endValuePtr)
116         {
117         }
118 
119     private:
120         T* m_valuePtr;
121         T* m_endValuePtr;
122     };
123 
124 public:
125     typedef JSCell Base;
<span class="line-modified">126     static constexpr unsigned StructureFlags = Base::StructureFlags | StructureIsImmortal;</span>
127 
128     template&lt;typename CellType, SubspaceAccess&gt;
129     static IsoSubspace* subspaceFor(VM&amp; vm)
130     {
131         return &amp;vm.propertyTableSpace;
132     }
133 
<span class="line-modified">134     static constexpr bool needsDestruction = true;</span>
135     static void destroy(JSCell*);
136 
137     DECLARE_EXPORT_INFO;
138 
139     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
140     {
141         return Structure::create(vm, globalObject, prototype, TypeInfo(CellType, StructureFlags), info());
142     }
143 
144     typedef UniquedStringImpl* KeyType;
145     typedef PropertyMapEntry ValueType;
146 
147     // The in order iterator provides overloaded * and -&gt; to access the Value at the current position.
148     typedef ordered_iterator&lt;ValueType&gt; iterator;
149     typedef ordered_iterator&lt;const ValueType&gt; const_iterator;
150 
151     // The find_iterator is a pair of a pointer to a Value* an the entry in the index.
152     // If &#39;find&#39; does not find an entry then iter.first will be 0, and iter.second will
153     // give the point in m_index where an entry should be inserted.
154     typedef std::pair&lt;ValueType*, unsigned&gt; find_iterator;
155 
156     // Constructor is passed an initial capacity, a PropertyTable to copy, or both.
157     static PropertyTable* create(VM&amp;, unsigned initialCapacity);
158     static PropertyTable* clone(VM&amp;, const PropertyTable&amp;);
159     static PropertyTable* clone(VM&amp;, unsigned initialCapacity, const PropertyTable&amp;);
160     ~PropertyTable();
161 
162     // Ordered iteration methods.
163     iterator begin();
164     iterator end();
165     const_iterator begin() const;
166     const_iterator end() const;
167 
168     // Find a value in the table.
169     find_iterator find(const KeyType&amp;);
170     ValueType* get(const KeyType&amp;);
171     // Add a value to the table
<span class="line-modified">172     std::pair&lt;find_iterator, bool&gt; WARN_UNUSED_RETURN add(const ValueType&amp; entry);</span>

173     // Remove a value from the table.
174     void remove(const find_iterator&amp; iter);
175     void remove(const KeyType&amp; key);
176 
177     // Returns the number of values in the hashtable.
178     unsigned size() const;
179 
180     // Checks if there are any values in the hashtable.
181     bool isEmpty() const;
182 
183     // Number of slots in the property storage array in use, included deletedOffsets.
184     unsigned propertyStorageSize() const;
185 
186     // Used to maintain a list of unused entries in the property storage.
187     void clearDeletedOffsets();
188     bool hasDeletedOffset();
189     PropertyOffset getDeletedOffset();
190     void addDeletedOffset(PropertyOffset);
191 
192     PropertyOffset nextOffset(PropertyOffset inlineCapacity);
193 
194     // Copy this PropertyTable, ensuring the copy has at least the capacity provided.
195     PropertyTable* copy(VM&amp;, unsigned newCapacity);
196 
197 #ifndef NDEBUG
198     size_t sizeInMemory();
199     void checkConsistency();
200 #endif
201 
202     static ptrdiff_t offsetOfIndexSize() { return OBJECT_OFFSETOF(PropertyTable, m_indexSize); }
203     static ptrdiff_t offsetOfIndexMask() { return OBJECT_OFFSETOF(PropertyTable, m_indexMask); }
204     static ptrdiff_t offsetOfIndex() { return OBJECT_OFFSETOF(PropertyTable, m_index); }
205 
<span class="line-modified">206     static constexpr unsigned EmptyEntryIndex = 0;</span>
207 
208 private:
209     PropertyTable(VM&amp;, unsigned initialCapacity);
210     PropertyTable(VM&amp;, const PropertyTable&amp;);
211     PropertyTable(VM&amp;, unsigned initialCapacity, const PropertyTable&amp;);
212 
213     PropertyTable(const PropertyTable&amp;);
214     // Used to insert a value known not to be in the table, and where we know capacity to be available.
215     void reinsert(const ValueType&amp; entry);
216 
217     // Rehash the table.  Used to grow, or to recover deleted slots.
218     void rehash(unsigned newCapacity);
219 
220     // The capacity of the table of values is half of the size of the index.
221     unsigned tableCapacity() const;
222 
223     // We keep an extra deleted slot after the array to make iteration work,
224     // and to use for deleted values. Index values into the array are 1-based,
225     // so this is tableCapacity() + 1.
226     // For example, if m_tableSize is 16, then tableCapacity() is 8 - but the
</pre>
<hr />
<pre>
242 
243     // total number of  used entries in the values array - by either valid entries, or deleted ones.
244     unsigned usedCount() const;
245 
246     // The size in bytes of data needed for by the table.
247     size_t dataSize();
248 
249     // Calculates the appropriate table size (rounds up to a power of two).
250     static unsigned sizeForCapacity(unsigned capacity);
251 
252     // Check if capacity is available.
253     bool canInsert();
254 
255     unsigned m_indexSize;
256     unsigned m_indexMask;
257     unsigned* m_index;
258     unsigned m_keyCount;
259     unsigned m_deletedCount;
260     std::unique_ptr&lt;Vector&lt;PropertyOffset&gt;&gt; m_deletedOffsets;
261 
<span class="line-modified">262     static constexpr unsigned MinimumTableSize = 16;</span>
263 };
264 
265 inline PropertyTable::iterator PropertyTable::begin()
266 {
267     auto* tableEnd = this-&gt;tableEnd();
268     return iterator(skipDeletedEntries(table(), tableEnd), tableEnd);
269 }
270 
271 inline PropertyTable::iterator PropertyTable::end()
272 {
273     auto* tableEnd = this-&gt;tableEnd();
274     return iterator(tableEnd, tableEnd);
275 }
276 
277 inline PropertyTable::const_iterator PropertyTable::begin() const
278 {
279     auto* tableEnd = this-&gt;tableEnd();
280     return const_iterator(skipDeletedEntries(table(), tableEnd), tableEnd);
281 }
282 
</pre>
<hr />
<pre>
303         if (key == table()[entryIndex - 1].key)
304             return std::make_pair(&amp;table()[entryIndex - 1], hash &amp; m_indexMask);
305 
306 #if DUMP_PROPERTYMAP_STATS
307         ++propertyMapHashTableStats-&gt;numCollisions;
308 #endif
309 
310 #if DUMP_PROPERTYMAP_COLLISIONS
311         dataLog(&quot;PropertyTable collision for &quot;, key, &quot; (&quot;, hash, &quot;)\n&quot;);
312         dataLog(&quot;Collided with &quot;, table()[entryIndex - 1].key, &quot;(&quot;, IdentifierRepHash::hash(table()[entryIndex - 1].key), &quot;)\n&quot;);
313 #endif
314 
315         hash++;
316     }
317 }
318 
319 inline PropertyTable::ValueType* PropertyTable::get(const KeyType&amp; key)
320 {
321     ASSERT(key);
322     ASSERT(key-&gt;isAtom() || key-&gt;isSymbol());
<span class="line-added">323     ASSERT(key != PROPERTY_MAP_DELETED_ENTRY_KEY);</span>
324 
325     if (!m_keyCount)
326         return nullptr;
327 
328     unsigned hash = IdentifierRepHash::hash(key);
329 
330 #if DUMP_PROPERTYMAP_STATS
331     ++propertyMapHashTableStats-&gt;numLookups;
332 #endif
333 
334     while (true) {
335         unsigned entryIndex = m_index[hash &amp; m_indexMask];
336         if (entryIndex == EmptyEntryIndex)
337             return nullptr;
<span class="line-modified">338         if (key == table()[entryIndex - 1].key) {</span>
<span class="line-added">339             ASSERT(!m_deletedOffsets || !m_deletedOffsets-&gt;contains(table()[entryIndex - 1].offset));</span>
340             return &amp;table()[entryIndex - 1];
<span class="line-added">341         }</span>
342 
343 #if DUMP_PROPERTYMAP_STATS
344         ++propertyMapHashTableStats-&gt;numLookupProbing;
345 #endif
346 
347         hash++;
348     }
349 }
350 
<span class="line-modified">351 inline std::pair&lt;PropertyTable::find_iterator, bool&gt; WARN_UNUSED_RETURN PropertyTable::add(const ValueType&amp; entry)</span>
352 {
<span class="line-added">353     ASSERT(!m_deletedOffsets || !m_deletedOffsets-&gt;contains(entry.offset));</span>
<span class="line-added">354 </span>
355     // Look for a value with a matching key already in the array.
356     find_iterator iter = find(entry.key);
<span class="line-modified">357     if (iter.first)</span>

358         return std::make_pair(iter, false);

359 
360 #if DUMP_PROPERTYMAP_STATS
361     ++propertyMapHashTableStats-&gt;numAdds;
362 #endif
363 
364     // Ref the key
365     entry.key-&gt;ref();
366 
367     // ensure capacity is available.
368     if (!canInsert()) {
369         rehash(m_keyCount + 1);
370         iter = find(entry.key);
371         ASSERT(!iter.first);
372     }
373 
374     // Allocate a slot in the hashtable, and set the index to reference this.
375     unsigned entryIndex = usedCount() + 1;
376     m_index[iter.second] = entryIndex;
377     iter.first = &amp;table()[entryIndex - 1];
378     *iter.first = entry;
379 
380     ++m_keyCount;
381 





382     return std::make_pair(iter, true);
383 }
384 
385 inline void PropertyTable::remove(const find_iterator&amp; iter)
386 {
387     // Removing a key that doesn&#39;t exist does nothing!
388     if (!iter.first)
389         return;
390 
391 #if DUMP_PROPERTYMAP_STATS
392     ++propertyMapHashTableStats-&gt;numRemoves;
393 #endif
394 
395     // Replace this one element with the deleted sentinel. Also clear out
396     // the entry so we can iterate all the entries as needed.
397     m_index[iter.second] = deletedEntryIndex();
398     iter.first-&gt;key-&gt;deref();
399     iter.first-&gt;key = PROPERTY_MAP_DELETED_ENTRY_KEY;
400 
401     ASSERT(m_keyCount &gt;= 1);
</pre>
<hr />
<pre>
431 {
432     m_deletedOffsets = nullptr;
433 }
434 
435 inline bool PropertyTable::hasDeletedOffset()
436 {
437     return m_deletedOffsets &amp;&amp; !m_deletedOffsets-&gt;isEmpty();
438 }
439 
440 inline PropertyOffset PropertyTable::getDeletedOffset()
441 {
442     PropertyOffset offset = m_deletedOffsets-&gt;last();
443     m_deletedOffsets-&gt;removeLast();
444     return offset;
445 }
446 
447 inline void PropertyTable::addDeletedOffset(PropertyOffset offset)
448 {
449     if (!m_deletedOffsets)
450         m_deletedOffsets = makeUnique&lt;Vector&lt;PropertyOffset&gt;&gt;();
<span class="line-added">451     ASSERT(!m_deletedOffsets-&gt;contains(offset));</span>
452     m_deletedOffsets-&gt;append(offset);
453 }
454 
455 inline PropertyOffset PropertyTable::nextOffset(PropertyOffset inlineCapacity)
456 {
457     if (hasDeletedOffset())
458         return getDeletedOffset();
459 
460     return offsetForPropertyNumber(size(), inlineCapacity);
461 }
462 
463 inline PropertyTable* PropertyTable::copy(VM&amp; vm, unsigned newCapacity)
464 {
465     ASSERT(newCapacity &gt;= m_keyCount);
466 
467     // Fast case; if the new table will be the same m_indexSize as this one, we can memcpy it,
468     // save rehashing all keys.
469     if (sizeForCapacity(newCapacity) == m_indexSize)
470         return PropertyTable::clone(vm, *this);
471     return PropertyTable::clone(vm, newCapacity, *this);
</pre>
<hr />
<pre>
497     m_index[iter.second] = entryIndex;
498     table()[entryIndex - 1] = entry;
499 
500     ++m_keyCount;
501 }
502 
503 inline void PropertyTable::rehash(unsigned newCapacity)
504 {
505 #if DUMP_PROPERTYMAP_STATS
506     ++propertyMapHashTableStats-&gt;numRehashes;
507 #endif
508 
509     unsigned* oldEntryIndices = m_index;
510     iterator iter = this-&gt;begin();
511     iterator end = this-&gt;end();
512 
513     m_indexSize = sizeForCapacity(newCapacity);
514     m_indexMask = m_indexSize - 1;
515     m_keyCount = 0;
516     m_deletedCount = 0;
<span class="line-modified">517 </span>
<span class="line-added">518     m_index = static_cast&lt;unsigned*&gt;(PropertyTableMalloc::zeroedMalloc(dataSize()));</span>
519 
520     for (; iter != end; ++iter) {
521         ASSERT(canInsert());
522         reinsert(*iter);
523     }
524 
<span class="line-modified">525     PropertyTableMalloc::free(oldEntryIndices);</span>
526 }
527 
528 inline unsigned PropertyTable::tableCapacity() const { return m_indexSize &gt;&gt; 1; }
529 
530 inline unsigned PropertyTable::deletedEntryIndex() const { return tableCapacity() + 1; }
531 
532 template&lt;typename T&gt;
533 inline T* PropertyTable::skipDeletedEntries(T* valuePtr, T* endValuePtr)
534 {
535     while (valuePtr &lt; endValuePtr &amp;&amp; valuePtr-&gt;key == PROPERTY_MAP_DELETED_ENTRY_KEY)
536         ++valuePtr;
537     return valuePtr;
538 }
539 
540 inline PropertyTable::ValueType* PropertyTable::table()
541 {
542     // The table of values lies after the hash index.
543     return reinterpret_cast&lt;ValueType*&gt;(m_index + m_indexSize);
544 }
545 
</pre>
</td>
</tr>
</table>
<center><a href="PropertyDescriptor.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="PropertyNameArray.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
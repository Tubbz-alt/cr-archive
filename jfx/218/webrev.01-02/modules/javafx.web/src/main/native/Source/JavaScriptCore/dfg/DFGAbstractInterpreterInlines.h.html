<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGAbstractInterpreterInlines.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #pragma once
  27 
  28 #if ENABLE(DFG_JIT)
  29 
  30 #include &quot;ArrayConstructor.h&quot;
  31 #include &quot;ArrayPrototype.h&quot;
  32 #include &quot;DFGAbstractInterpreter.h&quot;
  33 #include &quot;DFGAbstractInterpreterClobberState.h&quot;
  34 #include &quot;DOMJITGetterSetter.h&quot;
  35 #include &quot;DOMJITSignature.h&quot;
  36 #include &quot;GetByStatus.h&quot;
  37 #include &quot;GetterSetter.h&quot;
  38 #include &quot;HashMapImpl.h&quot;
  39 #include &quot;JITOperations.h&quot;
  40 #include &quot;JSAsyncGenerator.h&quot;
  41 #include &quot;JSGenerator.h&quot;
  42 #include &quot;JSImmutableButterfly.h&quot;
  43 #include &quot;JSInternalPromise.h&quot;
  44 #include &quot;JSInternalPromiseConstructor.h&quot;
  45 #include &quot;JSPromiseConstructor.h&quot;
  46 #include &quot;MathCommon.h&quot;
  47 #include &quot;NumberConstructor.h&quot;
  48 #include &quot;Operations.h&quot;
  49 #include &quot;PutByIdStatus.h&quot;
  50 #include &quot;StringObject.h&quot;
  51 #include &quot;StructureCache.h&quot;
  52 #include &quot;StructureRareDataInlines.h&quot;
  53 #include &lt;wtf/BooleanLattice.h&gt;
  54 #include &lt;wtf/CheckedArithmetic.h&gt;
  55 
  56 namespace JSC { namespace DFG {
  57 
  58 template&lt;typename AbstractStateType&gt;
  59 AbstractInterpreter&lt;AbstractStateType&gt;::AbstractInterpreter(Graph&amp; graph, AbstractStateType&amp; state)
  60     : m_codeBlock(graph.m_codeBlock)
  61     , m_graph(graph)
  62     , m_vm(m_graph.m_vm)
  63     , m_state(state)
  64 {
  65     if (m_graph.m_form == SSA)
  66         m_phiChildren = makeUnique&lt;PhiChildren&gt;(m_graph);
  67 }
  68 
  69 template&lt;typename AbstractStateType&gt;
  70 AbstractInterpreter&lt;AbstractStateType&gt;::~AbstractInterpreter()
  71 {
  72 }
  73 
  74 template&lt;typename AbstractStateType&gt;
  75 typename AbstractInterpreter&lt;AbstractStateType&gt;::BooleanResult
  76 AbstractInterpreter&lt;AbstractStateType&gt;::booleanResult(
  77     Node* node, AbstractValue&amp; value)
  78 {
  79     JSValue childConst = value.value();
  80     if (childConst) {
  81         if (childConst.toBoolean(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)))
  82             return DefinitelyTrue;
  83         return DefinitelyFalse;
  84     }
  85 
  86     // Next check if we can fold because we know that the source is an object or string and does not equal undefined.
  87     if (isCellSpeculation(value.m_type) &amp;&amp; !value.m_structure.isTop()) {
  88         bool allTrue = true;
  89         for (unsigned i = value.m_structure.size(); i--;) {
  90             RegisteredStructure structure = value.m_structure[i];
  91             if (structure-&gt;masqueradesAsUndefined(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic))
  92                 || structure-&gt;typeInfo().type() == StringType) {
  93                 allTrue = false;
  94                 break;
  95             }
  96         }
  97         if (allTrue)
  98             return DefinitelyTrue;
  99     }
 100 
 101     return UnknownBooleanResult;
 102 }
 103 
 104 template&lt;typename AbstractStateType&gt;
 105 void AbstractInterpreter&lt;AbstractStateType&gt;::startExecuting()
 106 {
 107     ASSERT(m_state.block());
 108     ASSERT(m_state.isValid());
 109 
 110     m_state.setClobberState(AbstractInterpreterClobberState::NotClobbered);
 111 }
 112 
 113 template&lt;typename AbstractStateType&gt;
 114 class AbstractInterpreterExecuteEdgesFunc {
 115 public:
 116     AbstractInterpreterExecuteEdgesFunc(AbstractInterpreter&lt;AbstractStateType&gt;&amp; interpreter)
 117         : m_interpreter(interpreter)
 118     {
 119     }
 120 
 121     // This func is manually written out so that we can put ALWAYS_INLINE on it.
 122     ALWAYS_INLINE void operator()(Edge&amp; edge) const
 123     {
 124         m_interpreter.filterEdgeByUse(edge);
 125     }
 126 
 127 private:
 128     AbstractInterpreter&lt;AbstractStateType&gt;&amp; m_interpreter;
 129 };
 130 
 131 template&lt;typename AbstractStateType&gt;
 132 void AbstractInterpreter&lt;AbstractStateType&gt;::executeEdges(Node* node)
 133 {
 134     m_graph.doToChildren(node, AbstractInterpreterExecuteEdgesFunc&lt;AbstractStateType&gt;(*this));
 135 }
 136 
 137 template&lt;typename AbstractStateType&gt;
 138 void AbstractInterpreter&lt;AbstractStateType&gt;::executeKnownEdgeTypes(Node* node)
 139 {
 140     // Some use kinds are required to not have checks, because we know somehow that the incoming
 141     // value will already have the type we want. In those cases, AI may not be smart enough to
 142     // prove that this is indeed the case. But the existance of the edge is enough to prove that
 143     // it is indeed the case. Taking advantage of this is not optional, since otherwise the DFG
 144     // and FTL backends may emit checks in a node that lacks a valid exit origin.
 145     m_graph.doToChildren(
 146         node,
 147         [&amp;] (Edge&amp; edge) {
 148             if (mayHaveTypeCheck(edge.useKind()))
 149                 return;
 150 
 151             filterEdgeByUse(edge);
 152         });
 153 }
 154 
 155 template&lt;typename AbstractStateType&gt;
 156 ALWAYS_INLINE void AbstractInterpreter&lt;AbstractStateType&gt;::filterByType(Edge&amp; edge, SpeculatedType type)
 157 {
 158     AbstractValue&amp; value = m_state.forNodeWithoutFastForward(edge);
 159     if (value.isType(type)) {
 160         m_state.setProofStatus(edge, IsProved);
 161         return;
 162     }
 163     m_state.setProofStatus(edge, NeedsCheck);
 164     m_state.fastForwardAndFilterUnproven(value, type);
 165 }
 166 
 167 template&lt;typename AbstractStateType&gt;
 168 void AbstractInterpreter&lt;AbstractStateType&gt;::verifyEdge(Node* node, Edge edge)
 169 {
 170     if (!(m_state.forNodeWithoutFastForward(edge).m_type &amp; ~typeFilterFor(edge.useKind())))
 171         return;
 172 
 173     DFG_CRASH(m_graph, node, toCString(&quot;Edge verification error: &quot;, node, &quot;-&gt;&quot;, edge, &quot; was expected to have type &quot;, SpeculationDump(typeFilterFor(edge.useKind())), &quot; but has type &quot;, SpeculationDump(forNode(edge).m_type), &quot; (&quot;, forNode(edge).m_type, &quot;)&quot;).data(), AbstractInterpreterInvalidType, node-&gt;op(), edge-&gt;op(), edge.useKind(), forNode(edge).m_type);
 174 }
 175 
 176 template&lt;typename AbstractStateType&gt;
 177 void AbstractInterpreter&lt;AbstractStateType&gt;::verifyEdges(Node* node)
 178 {
 179     DFG_NODE_DO_TO_CHILDREN(m_graph, node, verifyEdge);
 180 }
 181 
 182 enum class ToThisResult {
 183     Identity,
 184     Undefined,
 185     GlobalThis,
 186     Dynamic,
 187 };
 188 inline ToThisResult isToThisAnIdentity(VM&amp; vm, bool isStrictMode, AbstractValue&amp; valueForNode)
 189 {
 190     // We look at the type first since that will cover most cases and does not require iterating all the structures.
 191     if (isStrictMode) {
 192         if (valueForNode.m_type &amp;&amp; !(valueForNode.m_type &amp; SpecObjectOther))
 193             return ToThisResult::Identity;
 194     } else {
 195         if (valueForNode.m_type &amp;&amp; !(valueForNode.m_type &amp; (~SpecObject | SpecObjectOther)))
 196             return ToThisResult::Identity;
 197     }
 198 
 199     if (JSValue value = valueForNode.value()) {
 200         if (value.isCell()) {
 201             auto* toThisMethod = value.asCell()-&gt;classInfo(vm)-&gt;methodTable.toThis;
 202             if (toThisMethod == &amp;JSObject::toThis)
 203                 return ToThisResult::Identity;
 204             if (toThisMethod == &amp;JSScope::toThis) {
 205                 if (isStrictMode)
 206                     return ToThisResult::Undefined;
 207                 return ToThisResult::GlobalThis;
 208             }
 209         }
 210     }
 211 
 212     if ((isStrictMode || (valueForNode.m_type &amp;&amp; !(valueForNode.m_type &amp; ~SpecObject))) &amp;&amp; valueForNode.m_structure.isFinite()) {
 213         bool allStructuresAreJSScope = !valueForNode.m_structure.isClear();
 214         bool overridesToThis = false;
 215         valueForNode.m_structure.forEach([&amp;](RegisteredStructure structure) {
 216             TypeInfo type = structure-&gt;typeInfo();
 217             ASSERT(type.isObject() || type.type() == StringType || type.type() == SymbolType || type.type() == BigIntType);
 218             if (!isStrictMode)
 219                 ASSERT(type.isObject());
 220             // We don&#39;t need to worry about strings/symbols here since either:
 221             // 1) We are in strict mode and strings/symbols are not wrapped
 222             // 2) The AI has proven that the type of this is a subtype of object
 223             if (type.isObject() &amp;&amp; type.overridesToThis())
 224                 overridesToThis = true;
 225 
 226             // If all the structures are JSScope&#39;s ones, we know the details of JSScope::toThis() operation.
 227             allStructuresAreJSScope &amp;= structure-&gt;classInfo()-&gt;methodTable.toThis == JSScope::info()-&gt;methodTable.toThis;
 228         });
 229         if (!overridesToThis)
 230             return ToThisResult::Identity;
 231         if (allStructuresAreJSScope) {
 232             if (isStrictMode)
 233                 return ToThisResult::Undefined;
 234             return ToThisResult::GlobalThis;
 235         }
 236     }
 237 
 238     return ToThisResult::Dynamic;
 239 }
 240 
 241 template&lt;typename AbstractStateType&gt;
 242 bool AbstractInterpreter&lt;AbstractStateType&gt;::handleConstantBinaryBitwiseOp(Node* node)
 243 {
 244     JSValue left = forNode(node-&gt;child1()).value();
 245     JSValue right = forNode(node-&gt;child2()).value();
 246     if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 247         int32_t a = left.asInt32();
 248         int32_t b = right.asInt32();
 249         if (node-&gt;isBinaryUseKind(UntypedUse))
 250             didFoldClobberWorld();
 251         NodeType op = node-&gt;op();
 252         switch (op) {
 253         case ValueBitAnd:
 254         case ArithBitAnd:
 255             setConstant(node, JSValue(a &amp; b));
 256             break;
 257         case ValueBitOr:
 258         case ArithBitOr:
 259             setConstant(node, JSValue(a | b));
 260             break;
 261         case ValueBitXor:
 262         case ArithBitXor:
 263             setConstant(node, JSValue(a ^ b));
 264             break;
 265         case ArithBitRShift:
 266         case ValueBitRShift:
 267             setConstant(node, JSValue(a &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));
 268             break;
 269         case ValueBitLShift:
 270         case ArithBitLShift:
 271             setConstant(node, JSValue(a &lt;&lt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f)));
 272             break;
 273         case BitURShift:
 274             setConstant(node, JSValue(static_cast&lt;int32_t&gt;(static_cast&lt;uint32_t&gt;(a) &gt;&gt; (static_cast&lt;uint32_t&gt;(b) &amp; 0x1f))));
 275             break;
 276         default:
 277             RELEASE_ASSERT_NOT_REACHED();
 278             break;
 279         }
 280 
 281         return true;
 282     }
 283 
 284     return false;
 285 }
 286 
 287 template&lt;typename AbstractStateType&gt;
 288 bool AbstractInterpreter&lt;AbstractStateType&gt;::handleConstantDivOp(Node* node)
 289 {
 290     JSValue left = forNode(node-&gt;child1()).value();
 291     JSValue right = forNode(node-&gt;child2()).value();
 292 
 293     if (left &amp;&amp; right) {
 294         NodeType op = node-&gt;op();
 295         bool isDivOperation = op == ValueDiv || op == ArithDiv;
 296 
 297         // Only possible case of ValueOp below is UntypedUse,
 298         // so we need to reflect clobberize rules.
 299         bool isClobbering = op == ValueDiv || op == ValueMod;
 300 
 301         if (left.isInt32() &amp;&amp; right.isInt32()) {
 302             double doubleResult;
 303             if (isDivOperation)
 304                 doubleResult = left.asNumber() / right.asNumber();
 305             else
 306                 doubleResult = fmod(left.asNumber(), right.asNumber());
 307 
 308             if (node-&gt;hasArithMode()) {
 309                 if (!shouldCheckOverflow(node-&gt;arithMode()))
 310                     doubleResult = toInt32(doubleResult);
 311                 else if (!shouldCheckNegativeZero(node-&gt;arithMode()))
 312                     doubleResult += 0; // Sanitizes zero.
 313             }
 314 
 315             JSValue valueResult = jsNumber(doubleResult);
 316             if (valueResult.isInt32()) {
 317                 if (isClobbering)
 318                     didFoldClobberWorld();
 319                 setConstant(node, valueResult);
 320                 return true;
 321             }
 322         } else if (left.isNumber() &amp;&amp; right.isNumber()) {
 323             if (isClobbering)
 324                 didFoldClobberWorld();
 325 
 326             if (isDivOperation) {
 327                 if (op == ValueDiv)
 328                     setConstant(node, jsNumber(left.asNumber() / right.asNumber()));
 329                 else
 330                     setConstant(node, jsDoubleNumber(left.asNumber() / right.asNumber()));
 331             } else {
 332                 if (op == ValueMod)
 333                     setConstant(node, jsNumber(fmod(left.asNumber(), right.asNumber())));
 334                 else
 335                     setConstant(node, jsDoubleNumber(fmod(left.asNumber(), right.asNumber())));
 336             }
 337 
 338             return true;
 339         }
 340     }
 341 
 342     return false;
 343 }
 344 
 345 template&lt;typename AbstractStateType&gt;
 346 bool AbstractInterpreter&lt;AbstractStateType&gt;::executeEffects(unsigned clobberLimit, Node* node)
 347 {
 348     verifyEdges(node);
 349 
 350     m_state.createValueForNode(node);
 351 
 352     switch (node-&gt;op()) {
 353     case JSConstant:
 354     case DoubleConstant:
 355     case Int52Constant: {
 356         setBuiltInConstant(node, *node-&gt;constant());
 357         break;
 358     }
 359 
 360     case LazyJSConstant: {
 361         LazyJSValue value = node-&gt;lazyJSValue();
 362         switch (value.kind()) {
 363         case LazyJSValue::KnownValue:
 364             setConstant(node, value.value()-&gt;value());
 365             break;
 366         case LazyJSValue::SingleCharacterString:
 367         case LazyJSValue::KnownStringImpl:
 368         case LazyJSValue::NewStringImpl:
 369             setTypeForNode(node, SpecString);
 370             break;
 371         }
 372         break;
 373     }
 374 
 375     case IdentityWithProfile:
 376     case Identity: {
 377         setForNode(node, forNode(node-&gt;child1()));
 378         if (forNode(node).value())
 379             m_state.setShouldTryConstantFolding(true);
 380         break;
 381     }
 382 
 383     case ExtractCatchLocal:
 384     case ExtractOSREntryLocal: {
 385         makeBytecodeTopForNode(node);
 386         break;
 387     }
 388 
 389     case GetLocal: {
 390         VariableAccessData* variableAccessData = node-&gt;variableAccessData();
 391         AbstractValue value = m_state.operand(variableAccessData-&gt;operand());
 392         // The value in the local should already be checked.
 393         DFG_ASSERT(m_graph, node, value.isType(typeFilterFor(variableAccessData-&gt;flushFormat())));
 394         if (value.value())
 395             m_state.setShouldTryConstantFolding(true);
 396         setForNode(node, value);
 397         break;
 398     }
 399 
 400     case GetStack: {
 401         StackAccessData* data = node-&gt;stackAccessData();
 402         AbstractValue value = m_state.operand(data-&gt;operand);
 403         // The value in the local should already be checked.
 404         DFG_ASSERT(m_graph, node, value.isType(typeFilterFor(data-&gt;format)));
 405         if (value.value())
 406             m_state.setShouldTryConstantFolding(true);
 407         setForNode(node, value);
 408         break;
 409     }
 410 
 411     case SetLocal: {
 412         m_state.operand(node-&gt;operand()) = forNode(node-&gt;child1());
 413         break;
 414     }
 415 
 416     case PutStack: {
 417         m_state.operand(node-&gt;stackAccessData()-&gt;operand) = forNode(node-&gt;child1());
 418         break;
 419     }
 420 
 421     case MovHint: {
 422         // Don&#39;t need to do anything. A MovHint only informs us about what would have happened
 423         // in bytecode, but this code is just concerned with what is actually happening during
 424         // DFG execution.
 425         break;
 426     }
 427 
 428     case KillStack: {
 429         // This is just a hint telling us that the OSR state of the local is no longer inside the
 430         // flushed data.
 431         break;
 432     }
 433 
 434     case SetArgumentDefinitely:
 435     case SetArgumentMaybe:
 436         // Assert that the state of arguments has been set. SetArgumentDefinitely/SetArgumentMaybe means
 437         // that someone set the argument values out-of-band, and currently this always means setting to a
 438         // non-clear value.
 439         ASSERT(!m_state.operand(node-&gt;operand()).isClear());
 440         break;
 441 
 442     case InitializeEntrypointArguments: {
 443         unsigned entrypointIndex = node-&gt;entrypointIndex();
 444         const Vector&lt;FlushFormat&gt;&amp; argumentFormats = m_graph.m_argumentFormats[entrypointIndex];
 445         for (unsigned argument = 0; argument &lt; argumentFormats.size(); ++argument) {
 446             AbstractValue&amp; value = m_state.argument(argument);
 447             switch (argumentFormats[argument]) {
 448             case FlushedInt32:
 449                 value.setNonCellType(SpecInt32Only);
 450                 break;
 451             case FlushedBoolean:
 452                 value.setNonCellType(SpecBoolean);
 453                 break;
 454             case FlushedCell:
 455                 value.setType(m_graph, SpecCellCheck);
 456                 break;
 457             case FlushedJSValue:
 458                 value.makeBytecodeTop();
 459                 break;
 460             default:
 461                 DFG_CRASH(m_graph, node, &quot;Bad flush format for argument&quot;);
 462                 break;
 463             }
 464         }
 465         break;
 466     }
 467 
 468     case VarargsLength: {
 469         clobberWorld();
 470         setTypeForNode(node, SpecInt32Only);
 471         break;
 472     }
 473 
 474     case LoadVarargs:
 475     case ForwardVarargs: {
 476         // FIXME: ForwardVarargs should check if the count becomes known, and if it does, it should turn
 477         // itself into a straight-line sequence of GetStack/PutStack.
 478         // https://bugs.webkit.org/show_bug.cgi?id=143071
 479         switch (node-&gt;op()) {
 480         case LoadVarargs:
 481             clobberWorld();
 482             break;
 483         case ForwardVarargs:
 484             break;
 485         default:
 486             DFG_CRASH(m_graph, node, &quot;Bad opcode&quot;);
 487             break;
 488         }
 489         LoadVarargsData* data = node-&gt;loadVarargsData();
 490         m_state.operand(data-&gt;count).setNonCellType(SpecInt32Only);
 491         for (unsigned i = data-&gt;limit - 1; i--;)
 492             m_state.operand(data-&gt;start + i).makeHeapTop();
 493         break;
 494     }
 495 
 496     case ValueBitNot: {
 497         JSValue operand = forNode(node-&gt;child1()).value();
 498         if (operand &amp;&amp; operand.isInt32()) {
 499             didFoldClobberWorld();
 500             int32_t a = operand.asInt32();
 501             setConstant(node, JSValue(~a));
 502             break;
 503         }
 504 
 505         if (node-&gt;child1().useKind() == BigIntUse)
 506             setTypeForNode(node, SpecBigInt);
 507         else {
 508             clobberWorld();
 509             setTypeForNode(node, SpecInt32Only | SpecBigInt);
 510         }
 511 
 512         break;
 513     }
 514 
 515     case ArithBitNot: {
 516         JSValue operand = forNode(node-&gt;child1()).value();
 517         if (operand &amp;&amp; operand.isInt32()) {
 518             int32_t a = operand.asInt32();
 519             setConstant(node, JSValue(~a));
 520             break;
 521         }
 522 
 523         setNonCellTypeForNode(node, SpecInt32Only);
 524         break;
 525     }
 526 
 527     case ValueBitXor:
 528     case ValueBitAnd:
 529     case ValueBitOr:
 530     case ValueBitRShift:
 531     case ValueBitLShift: {
 532         if (handleConstantBinaryBitwiseOp(node))
 533             break;
 534 
 535         if (node-&gt;binaryUseKind() == BigIntUse)
 536             setTypeForNode(node, SpecBigInt);
 537         else {
 538             clobberWorld();
 539             setTypeForNode(node, SpecInt32Only | SpecBigInt);
 540         }
 541         break;
 542     }
 543 
 544     case ArithBitAnd:
 545     case ArithBitOr:
 546     case ArithBitXor:
 547     case ArithBitRShift:
 548     case ArithBitLShift:
 549     case BitURShift: {
 550         if (node-&gt;child1().useKind() == UntypedUse || node-&gt;child2().useKind() == UntypedUse) {
 551             clobberWorld();
 552             setNonCellTypeForNode(node, SpecInt32Only);
 553             break;
 554         }
 555 
 556         if (handleConstantBinaryBitwiseOp(node))
 557             break;
 558 
 559         if (node-&gt;op() == ArithBitAnd
 560             &amp;&amp; (isBoolInt32Speculation(forNode(node-&gt;child1()).m_type) ||
 561                 isBoolInt32Speculation(forNode(node-&gt;child2()).m_type))) {
 562             setNonCellTypeForNode(node, SpecBoolInt32);
 563             break;
 564         }
 565 
 566         setNonCellTypeForNode(node, SpecInt32Only);
 567         break;
 568     }
 569 
 570     case UInt32ToNumber: {
 571         JSValue child = forNode(node-&gt;child1()).value();
 572         if (doesOverflow(node-&gt;arithMode())) {
 573             if (enableInt52()) {
 574                 if (child &amp;&amp; child.isAnyInt()) {
 575                     int64_t machineInt = child.asAnyInt();
 576                     setConstant(node, jsNumber(static_cast&lt;uint32_t&gt;(machineInt)));
 577                     break;
 578                 }
 579                 setNonCellTypeForNode(node, SpecInt52Any);
 580                 break;
 581             }
 582             if (child &amp;&amp; child.isInt32()) {
 583                 uint32_t value = child.asInt32();
 584                 setConstant(node, jsNumber(value));
 585                 break;
 586             }
 587             setNonCellTypeForNode(node, SpecAnyIntAsDouble);
 588             break;
 589         }
 590         if (child &amp;&amp; child.isInt32()) {
 591             int32_t value = child.asInt32();
 592             if (value &gt;= 0) {
 593                 setConstant(node, jsNumber(value));
 594                 break;
 595             }
 596         }
 597         setNonCellTypeForNode(node, SpecInt32Only);
 598         break;
 599     }
 600 
 601     case BooleanToNumber: {
 602         JSValue concreteValue = forNode(node-&gt;child1()).value();
 603         if (concreteValue) {
 604             if (concreteValue.isBoolean())
 605                 setConstant(node, jsNumber(concreteValue.asBoolean()));
 606             else
 607                 setConstant(node, *m_graph.freeze(concreteValue));
 608             break;
 609         }
 610         AbstractValue&amp; value = forNode(node);
 611         value = forNode(node-&gt;child1());
 612         if (node-&gt;child1().useKind() == UntypedUse &amp;&amp; !(value.m_type &amp; ~SpecBoolean))
 613             m_state.setShouldTryConstantFolding(true);
 614         if (value.m_type &amp; SpecBoolean) {
 615             value.merge(SpecBoolInt32);
 616             value.filter(~SpecBoolean);
 617         }
 618         break;
 619     }
 620 
 621     case DoubleAsInt32: {
 622         JSValue child = forNode(node-&gt;child1()).value();
 623         if (child &amp;&amp; child.isNumber()) {
 624             double asDouble = child.asNumber();
 625             int32_t asInt = JSC::toInt32(asDouble);
 626             if (bitwise_cast&lt;int64_t&gt;(static_cast&lt;double&gt;(asInt)) == bitwise_cast&lt;int64_t&gt;(asDouble)) {
 627                 setConstant(node, JSValue(asInt));
 628                 break;
 629             }
 630         }
 631         setNonCellTypeForNode(node, SpecInt32Only);
 632         break;
 633     }
 634 
 635     case ValueToInt32: {
 636         JSValue child = forNode(node-&gt;child1()).value();
 637         if (child) {
 638             if (child.isNumber()) {
 639                 if (child.isInt32())
 640                     setConstant(node, child);
 641                 else
 642                     setConstant(node, JSValue(JSC::toInt32(child.asDouble())));
 643                 break;
 644             }
 645             if (child.isBoolean()) {
 646                 setConstant(node, jsNumber(child.asBoolean()));
 647                 break;
 648             }
 649             if (child.isUndefinedOrNull()) {
 650                 setConstant(node, jsNumber(0));
 651                 break;
 652             }
 653         }
 654 
 655         if (isBooleanSpeculation(forNode(node-&gt;child1()).m_type)) {
 656             setNonCellTypeForNode(node, SpecBoolInt32);
 657             break;
 658         }
 659 
 660         setNonCellTypeForNode(node, SpecInt32Only);
 661         break;
 662     }
 663 
 664     case DoubleRep: {
 665         JSValue child = forNode(node-&gt;child1()).value();
 666         if (Optional&lt;double&gt; number = child.toNumberFromPrimitive()) {
 667             setConstant(node, jsDoubleNumber(*number));
 668             break;
 669         }
 670 
 671         SpeculatedType type = forNode(node-&gt;child1()).m_type;
 672         switch (node-&gt;child1().useKind()) {
 673         case NotCellUse: {
 674             if (type &amp; SpecOther) {
 675                 type &amp;= ~SpecOther;
 676                 type |= SpecDoublePureNaN | SpecBoolInt32; // Null becomes zero, undefined becomes NaN.
 677             }
 678             if (type &amp; SpecBoolean) {
 679                 type &amp;= ~SpecBoolean;
 680                 type |= SpecBoolInt32; // True becomes 1, false becomes 0.
 681             }
 682             type &amp;= SpecBytecodeNumber;
 683             break;
 684         }
 685 
 686         case Int52RepUse:
 687         case NumberUse:
 688         case RealNumberUse:
 689             break;
 690 
 691         default:
 692             RELEASE_ASSERT_NOT_REACHED();
 693         }
 694         setNonCellTypeForNode(node, type);
 695         forNode(node).fixTypeForRepresentation(m_graph, node);
 696         break;
 697     }
 698 
 699     case Int52Rep: {
 700         JSValue child = forNode(node-&gt;child1()).value();
 701         if (child &amp;&amp; child.isAnyInt()) {
 702             setConstant(node, child);
 703             break;
 704         }
 705 
 706         setTypeForNode(node, forNode(node-&gt;child1()).m_type);
 707         forNode(node).fixTypeForRepresentation(m_graph, node);
 708         break;
 709     }
 710 
 711     case ValueRep: {
 712         JSValue value = forNode(node-&gt;child1()).value();
 713         if (value) {
 714             setConstant(node, value);
 715             break;
 716         }
 717 
 718         setTypeForNode(node, forNode(node-&gt;child1()).m_type &amp; ~SpecDoubleImpureNaN);
 719         forNode(node).fixTypeForRepresentation(m_graph, node);
 720         break;
 721     }
 722 
 723     case ValueSub:
 724     case ValueAdd: {
 725         DFG_ASSERT(m_graph, node, node-&gt;binaryUseKind() == UntypedUse || node-&gt;binaryUseKind() == BigIntUse);
 726         if (node-&gt;binaryUseKind() == BigIntUse)
 727             setTypeForNode(node, SpecBigInt);
 728         else {
 729             clobberWorld();
 730             setTypeForNode(node, SpecString | SpecBytecodeNumber | SpecBigInt);
 731         }
 732         break;
 733     }
 734 
 735     case StrCat: {
 736         setTypeForNode(node, SpecString);
 737         break;
 738     }
 739 
 740     case ArithAdd: {
 741         JSValue left = forNode(node-&gt;child1()).value();
 742         JSValue right = forNode(node-&gt;child2()).value();
 743         switch (node-&gt;binaryUseKind()) {
 744         case Int32Use:
 745             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 746                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 747                     setConstant(node, jsNumber(left.asInt32() + right.asInt32()));
 748                     break;
 749                 }
 750                 JSValue result = jsNumber(left.asNumber() + right.asNumber());
 751                 if (result.isInt32()) {
 752                     setConstant(node, result);
 753                     break;
 754                 }
 755             }
 756             setNonCellTypeForNode(node, SpecInt32Only);
 757             break;
 758         case Int52RepUse:
 759             if (left &amp;&amp; right &amp;&amp; left.isAnyInt() &amp;&amp; right.isAnyInt()) {
 760                 JSValue result = jsNumber(left.asAnyInt() + right.asAnyInt());
 761                 if (result.isAnyInt()) {
 762                     setConstant(node, result);
 763                     break;
 764                 }
 765             }
 766             setNonCellTypeForNode(node, SpecInt52Any);
 767             break;
 768         case DoubleRepUse:
 769             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
 770                 setConstant(node, jsDoubleNumber(left.asNumber() + right.asNumber()));
 771                 break;
 772             }
 773             setNonCellTypeForNode(node,
 774                 typeOfDoubleSum(
 775                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
 776             break;
 777         default:
 778             RELEASE_ASSERT_NOT_REACHED();
 779             break;
 780         }
 781         break;
 782     }
 783 
 784     case AtomicsIsLockFree: {
 785         if (node-&gt;child1().useKind() != Int32Use)
 786             clobberWorld();
 787         setNonCellTypeForNode(node, SpecBoolInt32);
 788         break;
 789     }
 790 
 791     case ArithClz32: {
 792         JSValue operand = forNode(node-&gt;child1()).value();
 793         if (Optional&lt;double&gt; number = operand.toNumberFromPrimitive()) {
 794             switch (node-&gt;child1().useKind()) {
 795             case Int32Use:
 796             case KnownInt32Use:
 797                 break;
 798             default:
 799                 didFoldClobberWorld();
 800                 break;
 801             }
 802             uint32_t value = toUInt32(*number);
 803             setConstant(node, jsNumber(clz(value)));
 804             break;
 805         }
 806         switch (node-&gt;child1().useKind()) {
 807         case Int32Use:
 808         case KnownInt32Use:
 809             break;
 810         default:
 811             clobberWorld();
 812             break;
 813         }
 814         setNonCellTypeForNode(node, SpecInt32Only);
 815         break;
 816     }
 817 
 818     case MakeRope: {
 819         unsigned numberOfRemovedChildren = 0;
 820         for (unsigned i = 0; i &lt; AdjacencyList::Size; ++i) {
 821             Edge&amp; edge = node-&gt;children.child(i);
 822             if (!edge)
 823                 break;
 824             JSValue childConstant = m_state.forNode(edge).value();
 825             if (!childConstant)
 826                 continue;
 827             if (!childConstant.isString())
 828                 continue;
 829             if (asString(childConstant)-&gt;length())
 830                 continue;
 831             ++numberOfRemovedChildren;
 832         }
 833 
 834         if (numberOfRemovedChildren)
 835             m_state.setShouldTryConstantFolding(true);
 836         setForNode(node, m_vm.stringStructure.get());
 837         break;
 838     }
 839 
 840     case ArithSub: {
 841         JSValue left = forNode(node-&gt;child1()).value();
 842         JSValue right = forNode(node-&gt;child2()).value();
 843         switch (node-&gt;binaryUseKind()) {
 844         case Int32Use:
 845             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
 846                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 847                     setConstant(node, jsNumber(left.asInt32() - right.asInt32()));
 848                     break;
 849                 }
 850                 JSValue result = jsNumber(left.asNumber() - right.asNumber());
 851                 if (result.isInt32()) {
 852                     setConstant(node, result);
 853                     break;
 854                 }
 855             }
 856             setNonCellTypeForNode(node, SpecInt32Only);
 857             break;
 858         case Int52RepUse:
 859             if (left &amp;&amp; right &amp;&amp; left.isAnyInt() &amp;&amp; right.isAnyInt()) {
 860                 JSValue result = jsNumber(left.asAnyInt() - right.asAnyInt());
 861                 if (result.isAnyInt()) {
 862                     setConstant(node, result);
 863                     break;
 864                 }
 865             }
 866             setNonCellTypeForNode(node, SpecInt52Any);
 867             break;
 868         case DoubleRepUse:
 869             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
 870                 setConstant(node, jsDoubleNumber(left.asNumber() - right.asNumber()));
 871                 break;
 872             }
 873             setNonCellTypeForNode(node,
 874                 typeOfDoubleDifference(
 875                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
 876             break;
 877         case UntypedUse:
 878             clobberWorld();
 879             setNonCellTypeForNode(node, SpecBytecodeNumber);
 880             break;
 881         default:
 882             RELEASE_ASSERT_NOT_REACHED();
 883             break;
 884         }
 885         break;
 886     }
 887 
 888     case ValueNegate: {
 889         clobberWorld();
 890         setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
 891         break;
 892     }
 893 
 894     case ArithNegate: {
 895         JSValue child = forNode(node-&gt;child1()).value();
 896         switch (node-&gt;child1().useKind()) {
 897         case Int32Use:
 898             if (child &amp;&amp; child.isInt32()) {
 899                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
 900                     setConstant(node, jsNumber(-child.asInt32()));
 901                     break;
 902                 }
 903                 double doubleResult;
 904                 if (shouldCheckNegativeZero(node-&gt;arithMode()))
 905                     doubleResult = -child.asNumber();
 906                 else
 907                     doubleResult = 0 - child.asNumber();
 908                 JSValue valueResult = jsNumber(doubleResult);
 909                 if (valueResult.isInt32()) {
 910                     setConstant(node, valueResult);
 911                     break;
 912                 }
 913             }
 914             setNonCellTypeForNode(node, SpecInt32Only);
 915             break;
 916         case Int52RepUse:
 917             if (child &amp;&amp; child.isAnyInt()) {
 918                 double doubleResult;
 919                 if (shouldCheckNegativeZero(node-&gt;arithMode()))
 920                     doubleResult = -child.asNumber();
 921                 else
 922                     doubleResult = 0 - child.asNumber();
 923                 JSValue valueResult = jsNumber(doubleResult);
 924                 if (valueResult.isAnyInt()) {
 925                     setConstant(node, valueResult);
 926                     break;
 927                 }
 928             }
 929             setNonCellTypeForNode(node, SpecInt52Any);
 930             break;
 931         case DoubleRepUse:
 932             if (child &amp;&amp; child.isNumber()) {
 933                 setConstant(node, jsDoubleNumber(-child.asNumber()));
 934                 break;
 935             }
 936             setNonCellTypeForNode(node,
 937                 typeOfDoubleNegation(
 938                     forNode(node-&gt;child1()).m_type));
 939             break;
 940         default:
 941             RELEASE_ASSERT_NOT_REACHED();
 942             break;
 943         }
 944         break;
 945     }
 946 
 947     case Inc:
 948     case Dec: {
 949         // FIXME: support some form of constant folding here.
 950         // https://bugs.webkit.org/show_bug.cgi?id=204258
 951         switch (node-&gt;child1().useKind()) {
 952         case Int32Use:
 953             setNonCellTypeForNode(node, SpecInt32Only);
 954             break;
 955         case Int52RepUse:
 956             setNonCellTypeForNode(node, SpecInt52Any);
 957             break;
 958         case DoubleRepUse:
 959             setNonCellTypeForNode(node, typeOfDoubleIncOrDec(forNode(node-&gt;child1()).m_type));
 960             break;
 961         case BigIntUse:
 962             setTypeForNode(node, SpecBigInt);
 963             break;
 964         default:
 965             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
 966             clobberWorld(); // Because of the call to ToNumeric()
 967             break;
 968         }
 969         break;
 970     }
 971 
 972     case ValuePow: {
 973         JSValue childX = forNode(node-&gt;child1()).value();
 974         JSValue childY = forNode(node-&gt;child2()).value();
 975         if (childX &amp;&amp; childY &amp;&amp; childX.isNumber() &amp;&amp; childY.isNumber()) {
 976             // We need to call `didFoldClobberWorld` here because this path is only possible
 977             // when node-&gt;useKind is UntypedUse. In the case of BigIntUse, children will be
 978             // cleared by `AbstractInterpreter::executeEffects`.
 979             didFoldClobberWorld();
 980             // Our boxing scheme here matches what we do in operationValuePow.
 981             setConstant(node, jsNumber(operationMathPow(childX.asNumber(), childY.asNumber())));
 982             break;
 983         }
 984 
 985         if (node-&gt;binaryUseKind() == BigIntUse)
 986             setTypeForNode(node, SpecBigInt);
 987         else {
 988             clobberWorld();
 989             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
 990         }
 991         break;
 992     }
 993 
 994     case ValueMul: {
 995         if (node-&gt;binaryUseKind() == BigIntUse)
 996             setTypeForNode(node, SpecBigInt);
 997         else {
 998             clobberWorld();
 999             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
1000         }
1001         break;
1002     }
1003 
1004     case ArithMul: {
1005         JSValue left = forNode(node-&gt;child1()).value();
1006         JSValue right = forNode(node-&gt;child2()).value();
1007         switch (node-&gt;binaryUseKind()) {
1008         case Int32Use:
1009             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
1010                 if (!shouldCheckOverflow(node-&gt;arithMode())) {
1011                     setConstant(node, jsNumber(left.asInt32() * right.asInt32()));
1012                     break;
1013                 }
1014                 double doubleResult = left.asNumber() * right.asNumber();
1015                 if (!shouldCheckNegativeZero(node-&gt;arithMode()))
1016                     doubleResult += 0; // Sanitizes zero.
1017                 JSValue valueResult = jsNumber(doubleResult);
1018                 if (valueResult.isInt32()) {
1019                     setConstant(node, valueResult);
1020                     break;
1021                 }
1022             }
1023             setNonCellTypeForNode(node, SpecInt32Only);
1024             break;
1025         case Int52RepUse:
1026             if (left &amp;&amp; right &amp;&amp; left.isAnyInt() &amp;&amp; right.isAnyInt()) {
1027                 double doubleResult = left.asNumber() * right.asNumber();
1028                 if (!shouldCheckNegativeZero(node-&gt;arithMode()))
1029                     doubleResult += 0;
1030                 JSValue valueResult = jsNumber(doubleResult);
1031                 if (valueResult.isAnyInt()) {
1032                     setConstant(node, valueResult);
1033                     break;
1034                 }
1035             }
1036             setNonCellTypeForNode(node, SpecInt52Any);
1037             break;
1038         case DoubleRepUse:
1039             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
1040                 setConstant(node, jsDoubleNumber(left.asNumber() * right.asNumber()));
1041                 break;
1042             }
1043             setNonCellTypeForNode(node,
1044                 typeOfDoubleProduct(
1045                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
1046             break;
1047         default:
1048             RELEASE_ASSERT_NOT_REACHED();
1049             break;
1050         }
1051         break;
1052     }
1053 
1054     case ValueMod:
1055     case ValueDiv: {
1056         if (handleConstantDivOp(node))
1057             break;
1058 
1059         if (node-&gt;binaryUseKind() == BigIntUse)
1060             setTypeForNode(node, SpecBigInt);
1061         else {
1062             clobberWorld();
1063             setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
1064         }
1065         break;
1066     }
1067 
1068     case ArithMod:
1069     case ArithDiv: {
1070         if (handleConstantDivOp(node))
1071             break;
1072 
1073         switch (node-&gt;binaryUseKind()) {
1074         case Int32Use:
1075             setNonCellTypeForNode(node, SpecInt32Only);
1076             break;
1077         case DoubleRepUse:
1078             if (node-&gt;op() == ArithDiv) {
1079                 setNonCellTypeForNode(node,
1080                     typeOfDoubleQuotient(
1081                         forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
1082             } else {
1083                 setNonCellTypeForNode(node,
1084                     typeOfDoubleBinaryOp(
1085                         forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
1086             }
1087 
1088             break;
1089         default:
1090             RELEASE_ASSERT_NOT_REACHED();
1091             break;
1092         }
1093         break;
1094     }
1095 
1096     case ArithMin: {
1097         JSValue left = forNode(node-&gt;child1()).value();
1098         JSValue right = forNode(node-&gt;child2()).value();
1099         switch (node-&gt;binaryUseKind()) {
1100         case Int32Use:
1101             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
1102                 setConstant(node, jsNumber(std::min(left.asInt32(), right.asInt32())));
1103                 break;
1104             }
1105             setNonCellTypeForNode(node, SpecInt32Only);
1106             break;
1107         case DoubleRepUse:
1108             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
1109                 double a = left.asNumber();
1110                 double b = right.asNumber();
1111                 setConstant(node, jsDoubleNumber(a &lt; b ? a : (b &lt;= a ? b : a + b)));
1112                 break;
1113             }
1114             setNonCellTypeForNode(node,
1115                 typeOfDoubleMinMax(
1116                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
1117             break;
1118         default:
1119             RELEASE_ASSERT_NOT_REACHED();
1120             break;
1121         }
1122         break;
1123     }
1124 
1125     case ArithMax: {
1126         JSValue left = forNode(node-&gt;child1()).value();
1127         JSValue right = forNode(node-&gt;child2()).value();
1128         switch (node-&gt;binaryUseKind()) {
1129         case Int32Use:
1130             if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32()) {
1131                 setConstant(node, jsNumber(std::max(left.asInt32(), right.asInt32())));
1132                 break;
1133             }
1134             setNonCellTypeForNode(node, SpecInt32Only);
1135             break;
1136         case DoubleRepUse:
1137             if (left &amp;&amp; right &amp;&amp; left.isNumber() &amp;&amp; right.isNumber()) {
1138                 double a = left.asNumber();
1139                 double b = right.asNumber();
1140                 setConstant(node, jsDoubleNumber(a &gt; b ? a : (b &gt;= a ? b : a + b)));
1141                 break;
1142             }
1143             setNonCellTypeForNode(node,
1144                 typeOfDoubleMinMax(
1145                     forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
1146             break;
1147         default:
1148             RELEASE_ASSERT_NOT_REACHED();
1149             break;
1150         }
1151         break;
1152     }
1153 
1154     case ArithAbs: {
1155         JSValue child = forNode(node-&gt;child1()).value();
1156         switch (node-&gt;child1().useKind()) {
1157         case Int32Use:
1158             if (Optional&lt;double&gt; number = child.toNumberFromPrimitive()) {
1159                 JSValue result = jsNumber(fabs(*number));
1160                 if (result.isInt32()) {
1161                     setConstant(node, result);
1162                     break;
1163                 }
1164             }
1165             setNonCellTypeForNode(node, SpecInt32Only);
1166             break;
1167         case DoubleRepUse:
1168             if (Optional&lt;double&gt; number = child.toNumberFromPrimitive()) {
1169                 setConstant(node, jsDoubleNumber(fabs(*number)));
1170                 break;
1171             }
1172             setNonCellTypeForNode(node, typeOfDoubleAbs(forNode(node-&gt;child1()).m_type));
1173             break;
1174         default:
1175             DFG_ASSERT(m_graph, node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
1176             clobberWorld();
1177             setNonCellTypeForNode(node, SpecBytecodeNumber);
1178             break;
1179         }
1180         break;
1181     }
1182 
1183     case ArithPow: {
1184         JSValue childY = forNode(node-&gt;child2()).value();
1185         if (childY &amp;&amp; childY.isNumber()) {
1186             if (!childY.asNumber()) {
1187                 setConstant(node, jsDoubleNumber(1));
1188                 break;
1189             }
1190 
1191             JSValue childX = forNode(node-&gt;child1()).value();
1192             if (childX &amp;&amp; childX.isNumber()) {
1193                 setConstant(node, jsDoubleNumber(operationMathPow(childX.asNumber(), childY.asNumber())));
1194                 break;
1195             }
1196         }
1197         setNonCellTypeForNode(node, typeOfDoublePow(forNode(node-&gt;child1()).m_type, forNode(node-&gt;child2()).m_type));
1198         break;
1199     }
1200 
1201     case ArithRandom: {
1202         setNonCellTypeForNode(node, SpecDoubleReal);
1203         break;
1204     }
1205 
1206     case ArithRound:
1207     case ArithFloor:
1208     case ArithCeil:
1209     case ArithTrunc: {
1210         JSValue operand = forNode(node-&gt;child1()).value();
1211         if (Optional&lt;double&gt; number = operand.toNumberFromPrimitive()) {
1212             if (node-&gt;child1().useKind() != DoubleRepUse)
1213                 didFoldClobberWorld();
1214 
1215             double roundedValue = 0;
1216             if (node-&gt;op() == ArithRound)
1217                 roundedValue = jsRound(*number);
1218             else if (node-&gt;op() == ArithFloor)
1219                 roundedValue = floor(*number);
1220             else if (node-&gt;op() == ArithCeil)
1221                 roundedValue = ceil(*number);
1222             else {
1223                 ASSERT(node-&gt;op() == ArithTrunc);
1224                 roundedValue = trunc(*number);
1225             }
1226 
1227             if (node-&gt;child1().useKind() == UntypedUse) {
1228                 setConstant(node, jsNumber(roundedValue));
1229                 break;
1230             }
1231             if (producesInteger(node-&gt;arithRoundingMode())) {
1232                 int32_t roundedValueAsInt32 = static_cast&lt;int32_t&gt;(roundedValue);
1233                 if (roundedValueAsInt32 == roundedValue) {
1234                     if (shouldCheckNegativeZero(node-&gt;arithRoundingMode())) {
1235                         if (roundedValueAsInt32 || !std::signbit(roundedValue)) {
1236                             setConstant(node, jsNumber(roundedValueAsInt32));
1237                             break;
1238                         }
1239                     } else {
1240                         setConstant(node, jsNumber(roundedValueAsInt32));
1241                         break;
1242                     }
1243                 }
1244             } else {
1245                 setConstant(node, jsDoubleNumber(roundedValue));
1246                 break;
1247             }
1248         }
1249         if (node-&gt;child1().useKind() == DoubleRepUse) {
1250             if (producesInteger(node-&gt;arithRoundingMode()))
1251                 setNonCellTypeForNode(node, SpecInt32Only);
1252             else if (node-&gt;child1().useKind() == DoubleRepUse)
1253                 setNonCellTypeForNode(node, typeOfDoubleRounding(forNode(node-&gt;child1()).m_type));
1254         } else {
1255             DFG_ASSERT(m_graph, node, node-&gt;child1().useKind() == UntypedUse, node-&gt;child1().useKind());
1256             clobberWorld();
1257             setNonCellTypeForNode(node, SpecBytecodeNumber);
1258         }
1259         break;
1260     }
1261 
1262     case ArithSqrt:
1263         executeDoubleUnaryOpEffects(node, sqrt);
1264         break;
1265 
1266     case ArithFRound:
1267         executeDoubleUnaryOpEffects(node, [](double value) -&gt; double { return static_cast&lt;float&gt;(value); });
1268         break;
1269 
1270     case ArithUnary:
1271         executeDoubleUnaryOpEffects(node, arithUnaryFunction(node-&gt;arithUnaryType()));
1272         break;
1273 
1274     case LogicalNot: {
1275         switch (booleanResult(node, forNode(node-&gt;child1()))) {
1276         case DefinitelyTrue:
1277             setConstant(node, jsBoolean(false));
1278             break;
1279         case DefinitelyFalse:
1280             setConstant(node, jsBoolean(true));
1281             break;
1282         default:
1283             setNonCellTypeForNode(node, SpecBoolean);
1284             break;
1285         }
1286         break;
1287     }
1288 
1289     case MapHash: {
1290         if (JSValue key = forNode(node-&gt;child1()).value()) {
1291             if (Optional&lt;uint32_t&gt; hash = concurrentJSMapHash(key)) {
1292                 // Although C++ code uses uint32_t for the hash, the closest type in DFG IR is Int32
1293                 // and that&#39;s what MapHash returns. So, we have to cast to int32_t to avoid large
1294                 // unsigned values becoming doubles. This casting between signed and unsigned
1295                 // happens in the assembly code we emit when we don&#39;t constant fold this node.
1296                 setConstant(node, jsNumber(static_cast&lt;int32_t&gt;(*hash)));
1297                 break;
1298             }
1299         }
1300         setNonCellTypeForNode(node, SpecInt32Only);
1301         break;
1302     }
1303 
1304     case NormalizeMapKey: {
1305         if (JSValue key = forNode(node-&gt;child1()).value()) {
1306             setConstant(node, *m_graph.freeze(normalizeMapKey(key)));
1307             break;
1308         }
1309 
1310         SpeculatedType typeMaybeNormalized = (SpecFullNumber &amp; ~SpecInt32Only);
1311         if (!(forNode(node-&gt;child1()).m_type &amp; typeMaybeNormalized)) {
1312             m_state.setShouldTryConstantFolding(true);
1313             forNode(node) = forNode(node-&gt;child1());
1314             break;
1315         }
1316 
1317         makeHeapTopForNode(node);
1318         break;
1319     }
1320 
1321     case StringValueOf: {
1322         clobberWorld();
1323         setTypeForNode(node, SpecString);
1324         break;
1325     }
1326 
1327     case StringSlice: {
1328         setTypeForNode(node, SpecString);
1329         break;
1330     }
1331 
1332     case ToLowerCase: {
1333         setTypeForNode(node, SpecString);
1334         break;
1335     }
1336 
1337     case LoadKeyFromMapBucket:
1338     case LoadValueFromMapBucket:
1339     case ExtractValueFromWeakMapGet:
1340         makeHeapTopForNode(node);
1341         break;
1342 
1343     case GetMapBucket:
1344     case GetMapBucketHead:
1345         if (node-&gt;child1().useKind() == MapObjectUse)
1346             setForNode(node, m_vm.hashMapBucketMapStructure.get());
1347         else {
1348             ASSERT(node-&gt;child1().useKind() == SetObjectUse);
1349             setForNode(node, m_vm.hashMapBucketSetStructure.get());
1350         }
1351         break;
1352 
1353     case GetMapBucketNext:
1354         if (node-&gt;bucketOwnerType() == BucketOwnerType::Map)
1355             setForNode(node, m_vm.hashMapBucketMapStructure.get());
1356         else {
1357             ASSERT(node-&gt;bucketOwnerType() == BucketOwnerType::Set);
1358             setForNode(node, m_vm.hashMapBucketSetStructure.get());
1359         }
1360         break;
1361 
1362     case SetAdd:
1363         setForNode(node, m_vm.hashMapBucketSetStructure.get());
1364         break;
1365 
1366     case MapSet:
1367         setForNode(node, m_vm.hashMapBucketMapStructure.get());
1368         break;
1369 
1370     case WeakSetAdd:
1371     case WeakMapSet:
1372         break;
1373 
1374     case WeakMapGet:
1375         makeBytecodeTopForNode(node);
1376         break;
1377 
1378     case IsEmpty:
1379     case IsUndefined:
1380     case IsUndefinedOrNull:
1381     case IsBoolean:
1382     case IsNumber:
1383     case NumberIsInteger:
1384     case IsObject:
1385     case IsObjectOrNull:
1386     case IsFunction:
1387     case IsCellWithType:
1388     case IsTypedArrayView: {
1389         AbstractValue child = forNode(node-&gt;child1());
1390         if (child.value()) {
1391             bool constantWasSet = true;
1392             switch (node-&gt;op()) {
1393             case IsCellWithType:
1394                 setConstant(node, jsBoolean(child.value().isCell() &amp;&amp; child.value().asCell()-&gt;type() == node-&gt;queriedType()));
1395                 break;
1396             case IsUndefined:
1397                 setConstant(node, jsBoolean(
1398                     child.value().isCell()
1399                     ? child.value().asCell()-&gt;structure(m_vm)-&gt;masqueradesAsUndefined(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic))
1400                     : child.value().isUndefined()));
1401                 break;
1402             case IsUndefinedOrNull:
1403                 setConstant(node, jsBoolean(child.value().isUndefinedOrNull()));
1404                 break;
1405             case IsBoolean:
1406                 setConstant(node, jsBoolean(child.value().isBoolean()));
1407                 break;
1408             case IsNumber:
1409                 setConstant(node, jsBoolean(child.value().isNumber()));
1410                 break;
1411             case NumberIsInteger:
1412                 setConstant(node, jsBoolean(NumberConstructor::isIntegerImpl(child.value())));
1413                 break;
1414             case IsObject:
1415                 setConstant(node, jsBoolean(child.value().isObject()));
1416                 break;
1417             case IsObjectOrNull:
1418                 if (child.value().isObject()) {
1419                     JSObject* object = asObject(child.value());
1420                     if (object-&gt;type() == JSFunctionType)
1421                         setConstant(node, jsBoolean(false));
1422                     else if (!(object-&gt;inlineTypeFlags() &amp; OverridesGetCallData))
1423                         setConstant(node, jsBoolean(!child.value().asCell()-&gt;structure(m_vm)-&gt;masqueradesAsUndefined(m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic))));
1424                     else {
1425                         // FIXME: This could just call getCallData.
1426                         // https://bugs.webkit.org/show_bug.cgi?id=144457
1427                         constantWasSet = false;
1428                     }
1429                 } else
1430                     setConstant(node, jsBoolean(child.value().isNull()));
1431                 break;
1432             case IsFunction:
1433                 if (child.value().isObject()) {
1434                     JSObject* object = asObject(child.value());
1435                     if (object-&gt;type() == JSFunctionType)
1436                         setConstant(node, jsBoolean(true));
1437                     else if (!(object-&gt;inlineTypeFlags() &amp; OverridesGetCallData))
1438                         setConstant(node, jsBoolean(false));
1439                     else {
1440                         // FIXME: This could just call getCallData.
1441                         // https://bugs.webkit.org/show_bug.cgi?id=144457
1442                         constantWasSet = false;
1443                     }
1444                 } else
1445                     setConstant(node, jsBoolean(false));
1446                 break;
1447             case IsEmpty:
1448                 setConstant(node, jsBoolean(child.value().isEmpty()));
1449                 break;
1450             case IsTypedArrayView:
1451                 setConstant(node, jsBoolean(child.value().isObject() &amp;&amp; isTypedView(child.value().getObject()-&gt;classInfo(m_vm)-&gt;typedArrayStorageType)));
1452                 break;
1453             default:
1454                 constantWasSet = false;
1455                 break;
1456             }
1457             if (constantWasSet)
1458                 break;
1459         }
1460 
1461         if (!(child.m_type &amp; ~SpecCell)) {
1462             if (child.m_structure.isFinite()) {
1463                 bool constantWasSet = false;
1464                 switch (node-&gt;op()) {
1465                 case IsCellWithType: {
1466                     bool ok = true;
1467                     Optional&lt;bool&gt; result;
1468                     child.m_structure.forEach(
1469                         [&amp;] (RegisteredStructure structure) {
1470                             bool matched = structure-&gt;typeInfo().type() == node-&gt;queriedType();
1471                             if (!result)
1472                                 result = matched;
1473                             else {
1474                                 if (result.value() != matched)
1475                                     ok = false;
1476                             }
1477                         });
1478                     if (ok &amp;&amp; result) {
1479                         setConstant(node, jsBoolean(result.value()));
1480                         constantWasSet = true;
1481                     }
1482                     break;
1483                 }
1484                 default:
1485                     break;
1486                 }
1487                 if (constantWasSet)
1488                     break;
1489             }
1490         }
1491 
1492         // FIXME: This code should really use AbstractValue::isType() and
1493         // AbstractValue::couldBeType().
1494         // https://bugs.webkit.org/show_bug.cgi?id=146870
1495 
1496         bool constantWasSet = false;
1497         switch (node-&gt;op()) {
1498         case IsEmpty: {
1499             if (child.m_type &amp;&amp; !(child.m_type &amp; SpecEmpty)) {
1500                 setConstant(node, jsBoolean(false));
1501                 constantWasSet = true;
1502                 break;
1503             }
1504 
1505             if (child.m_type &amp;&amp; !(child.m_type &amp; ~SpecEmpty)) {
1506                 setConstant(node, jsBoolean(true));
1507                 constantWasSet = true;
1508                 break;
1509             }
1510 
1511             break;
1512         }
1513         case IsUndefined:
1514             // FIXME: Use the masquerades-as-undefined watchpoint thingy.
1515             // https://bugs.webkit.org/show_bug.cgi?id=144456
1516 
1517             if (!(child.m_type &amp; (SpecOther | SpecObjectOther))) {
1518                 setConstant(node, jsBoolean(false));
1519                 constantWasSet = true;
1520                 break;
1521             }
1522 
1523             break;
1524         case IsUndefinedOrNull:
1525             if (!(child.m_type &amp; ~SpecOther)) {
1526                 setConstant(node, jsBoolean(true));
1527                 constantWasSet = true;
1528                 break;
1529             }
1530 
1531             if (!(child.m_type &amp; SpecOther)) {
1532                 setConstant(node, jsBoolean(false));
1533                 constantWasSet = true;
1534                 break;
1535             }
1536             break;
1537         case IsBoolean:
1538             if (!(child.m_type &amp; ~SpecBoolean)) {
1539                 setConstant(node, jsBoolean(true));
1540                 constantWasSet = true;
1541                 break;
1542             }
1543 
1544             if (!(child.m_type &amp; SpecBoolean)) {
1545                 setConstant(node, jsBoolean(false));
1546                 constantWasSet = true;
1547                 break;
1548             }
1549 
1550             break;
1551         case IsNumber:
1552             if (!(child.m_type &amp; ~SpecFullNumber)) {
1553                 setConstant(node, jsBoolean(true));
1554                 constantWasSet = true;
1555                 break;
1556             }
1557 
1558             if (!(child.m_type &amp; SpecFullNumber)) {
1559                 setConstant(node, jsBoolean(false));
1560                 constantWasSet = true;
1561                 break;
1562             }
1563 
1564             break;
1565 
1566         case NumberIsInteger:
1567             if (!(child.m_type &amp; ~SpecInt32Only)) {
1568                 setConstant(node, jsBoolean(true));
1569                 constantWasSet = true;
1570                 break;
1571             }
1572 
1573             if (!(child.m_type &amp; SpecFullNumber)) {
1574                 setConstant(node, jsBoolean(false));
1575                 constantWasSet = true;
1576                 break;
1577             }
1578 
1579             break;
1580 
1581         case IsObject:
1582             if (!(child.m_type &amp; ~SpecObject)) {
1583                 setConstant(node, jsBoolean(true));
1584                 constantWasSet = true;
1585                 break;
1586             }
1587 
1588             if (!(child.m_type &amp; SpecObject)) {
1589                 setConstant(node, jsBoolean(false));
1590                 constantWasSet = true;
1591                 break;
1592             }
1593 
1594             break;
1595         case IsObjectOrNull:
1596             // FIXME: Use the masquerades-as-undefined watchpoint thingy.
1597             // https://bugs.webkit.org/show_bug.cgi?id=144456
1598 
1599             // These expressions are complicated to parse. A helpful way to parse this is that
1600             // &quot;!(T &amp; ~S)&quot; means &quot;T is a subset of S&quot;. Conversely, &quot;!(T &amp; S)&quot; means &quot;T is a
1601             // disjoint set from S&quot;. Things like &quot;T - S&quot; means that, provided that S is a
1602             // subset of T, it&#39;s the &quot;set of all things in T but not in S&quot;. Things like &quot;T | S&quot;
1603             // mean the &quot;union of T and S&quot;.
1604 
1605             // Is the child&#39;s type an object that isn&#39;t an other-object (i.e. object that could
1606             // have masquaredes-as-undefined traps) and isn&#39;t a function?  Then: we should fold
1607             // this to true.
1608             if (!(child.m_type &amp; ~(SpecObject - SpecObjectOther - SpecFunction))) {
1609                 setConstant(node, jsBoolean(true));
1610                 constantWasSet = true;
1611                 break;
1612             }
1613 
1614             // Is the child&#39;s type definitely not either of: an object that isn&#39;t a function,
1615             // or either undefined or null?  Then: we should fold this to false.  This means
1616             // for example that if it&#39;s any non-function object, including those that have
1617             // masquerades-as-undefined traps, then we don&#39;t fold. It also means we won&#39;t fold
1618             // if it&#39;s undefined-or-null, since the type bits don&#39;t distinguish between
1619             // undefined (which should fold to false) and null (which should fold to true).
1620             if (!(child.m_type &amp; ((SpecObject - SpecFunction) | SpecOther))) {
1621                 setConstant(node, jsBoolean(false));
1622                 constantWasSet = true;
1623                 break;
1624             }
1625 
1626             break;
1627         case IsFunction:
1628             if (!(child.m_type &amp; ~SpecFunction)) {
1629                 setConstant(node, jsBoolean(true));
1630                 constantWasSet = true;
1631                 break;
1632             }
1633 
1634             if (!(child.m_type &amp; (SpecFunction | SpecObjectOther | SpecProxyObject))) {
1635                 setConstant(node, jsBoolean(false));
1636                 constantWasSet = true;
1637                 break;
1638             }
1639             break;
1640 
1641         case IsCellWithType: {
1642             Optional&lt;SpeculatedType&gt; filter = node-&gt;speculatedTypeForQuery();
1643             if (!filter) {
1644                 if (!(child.m_type &amp; SpecCell)) {
1645                     setConstant(node, jsBoolean(false));
1646                     constantWasSet = true;
1647                 }
1648                 break;
1649             }
1650             if (!(child.m_type &amp; ~filter.value())) {
1651                 setConstant(node, jsBoolean(true));
1652                 constantWasSet = true;
1653                 break;
1654             }
1655             if (!(child.m_type &amp; filter.value())) {
1656                 setConstant(node, jsBoolean(false));
1657                 constantWasSet = true;
1658                 break;
1659             }
1660             break;
1661         }
1662 
1663         case IsTypedArrayView:
1664             if (!(child.m_type &amp; ~SpecTypedArrayView)) {
1665                 setConstant(node, jsBoolean(true));
1666                 constantWasSet = true;
1667                 break;
1668             }
1669             if (!(child.m_type &amp; SpecTypedArrayView)) {
1670                 setConstant(node, jsBoolean(false));
1671                 constantWasSet = true;
1672                 break;
1673             }
1674             break;
1675 
1676         default:
1677             break;
1678         }
1679         if (constantWasSet)
1680             break;
1681 
1682         setNonCellTypeForNode(node, SpecBoolean);
1683         break;
1684     }
1685 
1686     case TypeOf: {
1687         JSValue child = forNode(node-&gt;child1()).value();
1688         AbstractValue&amp; abstractChild = forNode(node-&gt;child1());
1689         if (child) {
1690             JSValue typeString = jsTypeStringForValue(m_vm, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic), child);
1691             setConstant(node, *m_graph.freeze(typeString));
1692             break;
1693         }
1694 
1695         if (isFullNumberSpeculation(abstractChild.m_type)) {
1696             setConstant(node, *m_graph.freeze(m_vm.smallStrings.numberString()));
1697             break;
1698         }
1699 
1700         if (isStringSpeculation(abstractChild.m_type)) {
1701             setConstant(node, *m_graph.freeze(m_vm.smallStrings.stringString()));
1702             break;
1703         }
1704 
1705         // FIXME: We could use the masquerades-as-undefined watchpoint here.
1706         // https://bugs.webkit.org/show_bug.cgi?id=144456
1707         if (!(abstractChild.m_type &amp; ~(SpecObject - SpecObjectOther - SpecFunction))) {
1708             setConstant(node, *m_graph.freeze(m_vm.smallStrings.objectString()));
1709             break;
1710         }
1711 
1712         if (isFunctionSpeculation(abstractChild.m_type)) {
1713             setConstant(node, *m_graph.freeze(m_vm.smallStrings.functionString()));
1714             break;
1715         }
1716 
1717         if (isBooleanSpeculation(abstractChild.m_type)) {
1718             setConstant(node, *m_graph.freeze(m_vm.smallStrings.booleanString()));
1719             break;
1720         }
1721 
1722         if (isSymbolSpeculation(abstractChild.m_type)) {
1723             setConstant(node, *m_graph.freeze(m_vm.smallStrings.symbolString()));
1724             break;
1725         }
1726 
1727         if (isBigIntSpeculation(abstractChild.m_type)) {
1728             setConstant(node, *m_graph.freeze(m_vm.smallStrings.bigintString()));
1729             break;
1730         }
1731 
1732         setTypeForNode(node, SpecStringIdent);
1733         break;
1734     }
1735 
1736     case CompareBelow:
1737     case CompareBelowEq: {
1738         JSValue leftConst = forNode(node-&gt;child1()).value();
1739         JSValue rightConst = forNode(node-&gt;child2()).value();
1740         if (leftConst &amp;&amp; rightConst) {
1741             if (leftConst.isInt32() &amp;&amp; rightConst.isInt32()) {
1742                 uint32_t a = static_cast&lt;uint32_t&gt;(leftConst.asInt32());
1743                 uint32_t b = static_cast&lt;uint32_t&gt;(rightConst.asInt32());
1744                 switch (node-&gt;op()) {
1745                 case CompareBelow:
1746                     setConstant(node, jsBoolean(a &lt; b));
1747                     break;
1748                 case CompareBelowEq:
1749                     setConstant(node, jsBoolean(a &lt;= b));
1750                     break;
1751                 default:
1752                     RELEASE_ASSERT_NOT_REACHED();
1753                     break;
1754                 }
1755                 break;
1756             }
1757         }
1758 
1759         if (node-&gt;child1() == node-&gt;child2()) {
1760             switch (node-&gt;op()) {
1761             case CompareBelow:
1762                 setConstant(node, jsBoolean(false));
1763                 break;
1764             case CompareBelowEq:
1765                 setConstant(node, jsBoolean(true));
1766                 break;
1767             default:
1768                 DFG_CRASH(m_graph, node, &quot;Unexpected node type&quot;);
1769                 break;
1770             }
1771             break;
1772         }
1773         setNonCellTypeForNode(node, SpecBoolean);
1774         break;
1775     }
1776 
1777     case CompareLess:
1778     case CompareLessEq:
1779     case CompareGreater:
1780     case CompareGreaterEq:
1781     case CompareEq: {
1782         bool isClobbering = node-&gt;isBinaryUseKind(UntypedUse);
1783 
1784         if (isClobbering)
1785             didFoldClobberWorld();
1786 
1787         JSValue leftConst = forNode(node-&gt;child1()).value();
1788         JSValue rightConst = forNode(node-&gt;child2()).value();
1789         if (leftConst &amp;&amp; rightConst) {
1790             if (leftConst.isNumber() &amp;&amp; rightConst.isNumber()) {
1791                 double a = leftConst.asNumber();
1792                 double b = rightConst.asNumber();
1793                 switch (node-&gt;op()) {
1794                 case CompareLess:
1795                     setConstant(node, jsBoolean(a &lt; b));
1796                     break;
1797                 case CompareLessEq:
1798                     setConstant(node, jsBoolean(a &lt;= b));
1799                     break;
1800                 case CompareGreater:
1801                     setConstant(node, jsBoolean(a &gt; b));
1802                     break;
1803                 case CompareGreaterEq:
1804                     setConstant(node, jsBoolean(a &gt;= b));
1805                     break;
1806                 case CompareEq:
1807                     setConstant(node, jsBoolean(a == b));
1808                     break;
1809                 default:
1810                     RELEASE_ASSERT_NOT_REACHED();
1811                     break;
1812                 }
1813                 break;
1814             }
1815 
1816             if (leftConst.isString() &amp;&amp; rightConst.isString()) {
1817                 const StringImpl* a = asString(leftConst)-&gt;tryGetValueImpl();
1818                 const StringImpl* b = asString(rightConst)-&gt;tryGetValueImpl();
1819                 if (a &amp;&amp; b) {
1820                     bool result;
1821                     if (node-&gt;op() == CompareEq)
1822                         result = WTF::equal(a, b);
1823                     else if (node-&gt;op() == CompareLess)
1824                         result = codePointCompare(a, b) &lt; 0;
1825                     else if (node-&gt;op() == CompareLessEq)
1826                         result = codePointCompare(a, b) &lt;= 0;
1827                     else if (node-&gt;op() == CompareGreater)
1828                         result = codePointCompare(a, b) &gt; 0;
1829                     else if (node-&gt;op() == CompareGreaterEq)
1830                         result = codePointCompare(a, b) &gt;= 0;
1831                     else
1832                         RELEASE_ASSERT_NOT_REACHED();
1833                     setConstant(node, jsBoolean(result));
1834                     break;
1835                 }
1836             }
1837 
1838             if (node-&gt;op() == CompareEq &amp;&amp; leftConst.isSymbol() &amp;&amp; rightConst.isSymbol()) {
1839                 setConstant(node, jsBoolean(asSymbol(leftConst) == asSymbol(rightConst)));
1840                 break;
1841             }
1842         }
1843 
1844         if (node-&gt;op() == CompareEq) {
1845             SpeculatedType leftType = forNode(node-&gt;child1()).m_type;
1846             SpeculatedType rightType = forNode(node-&gt;child2()).m_type;
1847             if (!valuesCouldBeEqual(leftType, rightType)) {
1848                 setConstant(node, jsBoolean(false));
1849                 break;
1850             }
1851 
1852             if (leftType == SpecOther)
1853                 std::swap(leftType, rightType);
1854             if (rightType == SpecOther) {
1855                 // Undefined and Null are always equal when compared to eachother.
1856                 if (!(leftType &amp; ~SpecOther)) {
1857                     setConstant(node, jsBoolean(true));
1858                     break;
1859                 }
1860 
1861                 // Any other type compared to Null or Undefined is always false
1862                 // as long as the MasqueradesAsUndefined watchpoint is valid.
1863                 //
1864                 // MasqueradesAsUndefined only matters for SpecObjectOther, other
1865                 // cases are always &quot;false&quot;.
1866                 if (!(leftType &amp; (SpecObjectOther | SpecOther))) {
1867                     setConstant(node, jsBoolean(false));
1868                     break;
1869                 }
1870 
1871                 if (!(leftType &amp; SpecOther) &amp;&amp; m_graph.masqueradesAsUndefinedWatchpointIsStillValid(node-&gt;origin.semantic)) {
1872                     JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
1873                     m_graph.watchpoints().addLazily(globalObject-&gt;masqueradesAsUndefinedWatchpoint());
1874                     setConstant(node, jsBoolean(false));
1875                     break;
1876                 }
1877             }
1878         }
1879 
1880         if (node-&gt;child1() == node-&gt;child2()) {
1881             if (node-&gt;isBinaryUseKind(Int32Use) ||
1882                 node-&gt;isBinaryUseKind(Int52RepUse) ||
1883                 node-&gt;isBinaryUseKind(StringUse) ||
1884                 node-&gt;isBinaryUseKind(BooleanUse) ||
1885                 node-&gt;isBinaryUseKind(SymbolUse) ||
1886                 node-&gt;isBinaryUseKind(StringIdentUse) ||
1887                 node-&gt;isBinaryUseKind(ObjectUse) ||
1888                 node-&gt;isBinaryUseKind(ObjectUse, ObjectOrOtherUse) ||
1889                 node-&gt;isBinaryUseKind(ObjectOrOtherUse, ObjectUse)) {
1890                 switch (node-&gt;op()) {
1891                 case CompareLess:
1892                 case CompareGreater:
1893                     setConstant(node, jsBoolean(false));
1894                     break;
1895                 case CompareLessEq:
1896                 case CompareGreaterEq:
1897                 case CompareEq:
1898                     setConstant(node, jsBoolean(true));
1899                     break;
1900                 default:
1901                     DFG_CRASH(m_graph, node, &quot;Unexpected node type&quot;);
1902                     break;
1903                 }
1904                 break;
1905             }
1906         }
1907 
1908         if (isClobbering)
1909             clobberWorld();
1910         setNonCellTypeForNode(node, SpecBoolean);
1911         break;
1912     }
1913 
1914     case CompareStrictEq:
1915     case SameValue: {
1916         Node* leftNode = node-&gt;child1().node();
1917         Node* rightNode = node-&gt;child2().node();
1918         JSValue left = forNode(leftNode).value();
1919         JSValue right = forNode(rightNode).value();
1920         if (left &amp;&amp; right) {
1921             if (left.isString() &amp;&amp; right.isString()) {
1922                 // We need this case because JSValue::strictEqual is otherwise too racy for
1923                 // string comparisons.
1924                 const StringImpl* a = asString(left)-&gt;tryGetValueImpl();
1925                 const StringImpl* b = asString(right)-&gt;tryGetValueImpl();
1926                 if (a &amp;&amp; b) {
1927                     setConstant(node, jsBoolean(WTF::equal(a, b)));
1928                     break;
1929                 }
1930             } else {
1931                 if (node-&gt;op() == CompareStrictEq)
1932                     setConstant(node, jsBoolean(JSValue::strictEqual(nullptr, left, right)));
1933                 else
1934                     setConstant(node, jsBoolean(sameValue(nullptr, left, right)));
1935                 break;
1936             }
1937         }
1938 
1939         if (node-&gt;isBinaryUseKind(UntypedUse)) {
1940             // FIXME: Revisit this condition when introducing BigInt to JSC.
1941             auto isNonStringCellConstant = [] (JSValue value) {
1942                 return value &amp;&amp; value.isCell() &amp;&amp; !value.isString();
1943             };
1944 
1945             if (isNonStringCellConstant(left) || isNonStringCellConstant(right)) {
1946                 m_state.setShouldTryConstantFolding(true);
1947                 setNonCellTypeForNode(node, SpecBoolean);
1948                 break;
1949             }
1950         }
1951 
1952         SpeculatedType leftLUB = leastUpperBoundOfStrictlyEquivalentSpeculations(forNode(leftNode).m_type);
1953         SpeculatedType rightLUB = leastUpperBoundOfStrictlyEquivalentSpeculations(forNode(rightNode).m_type);
1954         if (!(leftLUB &amp; rightLUB)) {
1955             setConstant(node, jsBoolean(false));
1956             break;
1957         }
1958 
1959         if (node-&gt;child1() == node-&gt;child2()) {
1960             if (node-&gt;isBinaryUseKind(BooleanUse) ||
1961                 node-&gt;isBinaryUseKind(Int32Use) ||
1962                 node-&gt;isBinaryUseKind(Int52RepUse) ||
1963                 node-&gt;isBinaryUseKind(StringUse) ||
1964                 node-&gt;isBinaryUseKind(StringIdentUse) ||
1965                 node-&gt;isBinaryUseKind(SymbolUse) ||
1966                 node-&gt;isBinaryUseKind(ObjectUse) ||
1967                 node-&gt;isBinaryUseKind(MiscUse, UntypedUse) ||
1968                 node-&gt;isBinaryUseKind(UntypedUse, MiscUse) ||
1969                 node-&gt;isBinaryUseKind(StringIdentUse, NotStringVarUse) ||
1970                 node-&gt;isBinaryUseKind(NotStringVarUse, StringIdentUse) ||
1971                 node-&gt;isBinaryUseKind(StringUse, UntypedUse) ||
1972                 node-&gt;isBinaryUseKind(UntypedUse, StringUse)) {
1973                 setConstant(node, jsBoolean(true));
1974                 break;
1975             }
1976         }
1977 
1978         setNonCellTypeForNode(node, SpecBoolean);
1979         break;
1980     }
1981 
1982     case CompareEqPtr: {
1983         Node* childNode = node-&gt;child1().node();
1984         JSValue childValue = forNode(childNode).value();
1985         if (childValue) {
1986             setConstant(node, jsBoolean(childValue.isCell() &amp;&amp; childValue.asCell() == node-&gt;cellOperand()-&gt;cell()));
1987             break;
1988         }
1989 
1990         setNonCellTypeForNode(node, SpecBoolean);
1991         break;
1992     }
1993 
1994     case StringCharCodeAt:
1995     case StringCodePointAt:
1996         setNonCellTypeForNode(node, SpecInt32Only);
1997         break;
1998 
1999     case StringFromCharCode:
2000         switch (node-&gt;child1().useKind()) {
2001         case Int32Use:
2002             break;
2003         case UntypedUse:
2004             clobberWorld();
2005             break;
2006         default:
2007             DFG_CRASH(m_graph, node, &quot;Bad use kind&quot;);
2008             break;
2009         }
2010         setTypeForNode(node, SpecString);
2011         break;
2012 
2013     case StringCharAt:
2014         setForNode(node, m_vm.stringStructure.get());
2015         break;
2016 
2017     case GetByVal:
2018     case AtomicsAdd:
2019     case AtomicsAnd:
2020     case AtomicsCompareExchange:
2021     case AtomicsExchange:
2022     case AtomicsLoad:
2023     case AtomicsOr:
2024     case AtomicsStore:
2025     case AtomicsSub:
2026     case AtomicsXor: {
2027         if (node-&gt;op() == GetByVal) {
2028             auto foldGetByValOnConstantProperty = [&amp;] (Edge&amp; arrayEdge, Edge&amp; indexEdge) {
2029                 // FIXME: We can expand this for non x86 environments.
2030                 // https://bugs.webkit.org/show_bug.cgi?id=134641
2031                 if (!isX86())
2032                     return false;
2033 
2034                 AbstractValue&amp; arrayValue = forNode(arrayEdge);
2035 
2036                 // Check the structure set is finite. This means that this constant&#39;s structure is watched and guaranteed the one of this set.
2037                 // When the structure is changed, this code should be invalidated. This is important since the following code relies on the
2038                 // constant object&#39;s is not changed.
2039                 if (!arrayValue.m_structure.isFinite())
2040                     return false;
2041 
2042                 JSValue arrayConstant = arrayValue.value();
2043                 if (!arrayConstant)
2044                     return false;
2045 
2046                 JSObject* array = jsDynamicCast&lt;JSObject*&gt;(m_vm, arrayConstant);
2047                 if (!array)
2048                     return false;
2049 
2050                 JSValue indexConstant = forNode(indexEdge).value();
2051                 if (!indexConstant || !indexConstant.isInt32() || indexConstant.asInt32() &lt; 0)
2052                     return false;
2053                 uint32_t index = indexConstant.asUInt32();
2054 
2055                 // Check that the early StructureID is not nuked, get the butterfly, and check the late StructureID again.
2056                 // And we check the indexing mode of the structure. If the indexing mode is CoW, the butterfly is
2057                 // definitely JSImmutableButterfly.
2058                 StructureID structureIDEarly = array-&gt;structureID();
2059                 if (isNuked(structureIDEarly))
2060                     return false;
2061 
2062                 if (node-&gt;arrayMode().arrayClass() == Array::OriginalCopyOnWriteArray) {
2063 
2064                     WTF::loadLoadFence();
2065                     Butterfly* butterfly = array-&gt;butterfly();
2066 
2067                     WTF::loadLoadFence();
2068                     StructureID structureIDLate = array-&gt;structureID();
2069 
2070                     if (structureIDEarly != structureIDLate)
2071                         return false;
2072 
2073                     Structure* structure = m_vm.getStructure(structureIDLate);
2074                     switch (node-&gt;arrayMode().type()) {
2075                     case Array::Int32:
2076                     case Array::Contiguous:
2077                     case Array::Double:
2078                         if (structure-&gt;indexingMode() != (toIndexingShape(node-&gt;arrayMode().type()) | CopyOnWrite | IsArray))
2079                             return false;
2080                         break;
2081                     default:
2082                         return false;
2083                     }
2084                     ASSERT(isCopyOnWrite(structure-&gt;indexingMode()));
2085 
2086                     JSImmutableButterfly* immutableButterfly = JSImmutableButterfly::fromButterfly(butterfly);
2087                     if (index &lt; immutableButterfly-&gt;length()) {
2088                         JSValue value = immutableButterfly-&gt;get(index);
2089                         ASSERT(value);
2090                         if (value.isCell())
2091                             setConstant(node, *m_graph.freeze(value.asCell()));
2092                         else
2093                             setConstant(node, value);
2094                         return true;
2095                     }
2096 
2097                     if (node-&gt;arrayMode().isOutOfBounds()) {
2098                         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2099                         Structure* arrayPrototypeStructure = globalObject-&gt;arrayPrototype()-&gt;structure(m_vm);
2100                         Structure* objectPrototypeStructure = globalObject-&gt;objectPrototype()-&gt;structure(m_vm);
2101                         if (arrayPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
2102                             &amp;&amp; objectPrototypeStructure-&gt;transitionWatchpointSetIsStillValid()
2103                             &amp;&amp; globalObject-&gt;arrayPrototypeChainIsSane()) {
2104                             m_graph.registerAndWatchStructureTransition(arrayPrototypeStructure);
2105                             m_graph.registerAndWatchStructureTransition(objectPrototypeStructure);
2106                             // Note that Array::Double and Array::Int32 return JSValue if array mode is OutOfBounds.
2107                             setConstant(node, jsUndefined());
2108                             return true;
2109                         }
2110                     }
2111                     return false;
2112                 }
2113 
2114                 if (node-&gt;arrayMode().type() == Array::ArrayStorage || node-&gt;arrayMode().type() == Array::SlowPutArrayStorage) {
2115                     JSValue value;
2116                     {
2117                         // ArrayStorage&#39;s Butterfly can be half-broken state.
2118                         auto locker = holdLock(array-&gt;cellLock());
2119 
2120                         WTF::loadLoadFence();
2121                         Butterfly* butterfly = array-&gt;butterfly();
2122 
2123                         WTF::loadLoadFence();
2124                         StructureID structureIDLate = array-&gt;structureID();
2125 
2126                         if (structureIDEarly != structureIDLate)
2127                             return false;
2128 
2129                         Structure* structure = m_vm.getStructure(structureIDLate);
2130                         if (!hasAnyArrayStorage(structure-&gt;indexingMode()))
2131                             return false;
2132 
2133                         if (structure-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero())
2134                             return false;
2135 
2136                         ArrayStorage* storage = butterfly-&gt;arrayStorage();
2137                         if (index &gt;= storage-&gt;length())
2138                             return false;
2139 
2140                         if (index &lt; storage-&gt;vectorLength())
2141                             return false;
2142 
2143                         SparseArrayValueMap* map = storage-&gt;m_sparseMap.get();
2144                         if (!map)
2145                             return false;
2146 
2147                         value = map-&gt;getConcurrently(index);
2148                     }
2149                     if (!value)
2150                         return false;
2151 
2152                     if (value.isCell())
2153                         setConstant(node, *m_graph.freeze(value.asCell()));
2154                     else
2155                         setConstant(node, value);
2156                     return true;
2157                 }
2158 
2159                 return false;
2160             };
2161 
2162             bool didFold = false;
2163             switch (node-&gt;arrayMode().type()) {
2164             case Array::Generic:
2165             case Array::Int32:
2166             case Array::Double:
2167             case Array::Contiguous:
2168             case Array::ArrayStorage:
2169             case Array::SlowPutArrayStorage:
2170                 if (foldGetByValOnConstantProperty(m_graph.child(node, 0), m_graph.child(node, 1))) {
2171                     if (!node-&gt;arrayMode().isInBounds())
2172                         didFoldClobberWorld();
2173                     didFold = true;
2174                 }
2175                 break;
2176             default:
2177                 break;
2178             }
2179 
2180             if (didFold)
2181                 break;
2182         }
2183 
2184         if (node-&gt;op() != GetByVal) {
2185             unsigned numExtraArgs = numExtraAtomicsArgs(node-&gt;op());
2186             Edge storageEdge = m_graph.child(node, 2 + numExtraArgs);
2187             if (!storageEdge)
2188                 clobberWorld();
2189         }
2190         switch (node-&gt;arrayMode().type()) {
2191         case Array::SelectUsingPredictions:
2192         case Array::Unprofiled:
2193         case Array::SelectUsingArguments:
2194             RELEASE_ASSERT_NOT_REACHED();
2195             break;
2196         case Array::ForceExit:
2197             m_state.setIsValid(false);
2198             break;
2199         case Array::Undecided: {
2200             JSValue index = forNode(m_graph.child(node, 1)).value();
2201             if (index &amp;&amp; index.isInt32() &amp;&amp; index.asInt32() &gt;= 0) {
2202                 setConstant(node, jsUndefined());
2203                 break;
2204             }
2205             setNonCellTypeForNode(node, SpecOther);
2206             break;
2207         }
2208         case Array::Generic:
2209             clobberWorld();
2210             makeHeapTopForNode(node);
2211             break;
2212         case Array::String:
2213             if (node-&gt;arrayMode().isOutOfBounds()) {
2214                 // If the watchpoint was still valid we could totally set this to be
2215                 // SpecString | SpecOther. Except that we&#39;d have to be careful. If we
2216                 // tested the watchpoint state here then it could change by the time
2217                 // we got to the backend. So to do this right, we&#39;d have to get the
2218                 // fixup phase to check the watchpoint state and then bake into the
2219                 // GetByVal operation the fact that we&#39;re using a watchpoint, using
2220                 // something like Array::SaneChain (except not quite, because that
2221                 // implies an in-bounds access). None of this feels like it&#39;s worth it,
2222                 // so we&#39;re going with TOP for now. The same thing applies to
2223                 // clobbering the world.
2224                 clobberWorld();
2225                 makeHeapTopForNode(node);
2226             } else
2227                 setForNode(node, m_vm.stringStructure.get());
2228             break;
2229         case Array::DirectArguments:
2230         case Array::ScopedArguments:
2231             if (node-&gt;arrayMode().isOutOfBounds())
2232                 clobberWorld();
2233             makeHeapTopForNode(node);
2234             break;
2235         case Array::Int32:
2236             if (node-&gt;arrayMode().isOutOfBounds()) {
2237                 clobberWorld();
2238                 makeHeapTopForNode(node);
2239             } else
2240                 setNonCellTypeForNode(node, SpecInt32Only);
2241             break;
2242         case Array::Double:
2243             if (node-&gt;arrayMode().isOutOfBounds()) {
2244                 clobberWorld();
2245                 makeHeapTopForNode(node);
2246             } else if (node-&gt;arrayMode().isSaneChain())
2247                 setNonCellTypeForNode(node, SpecBytecodeDouble);
2248             else
2249                 setNonCellTypeForNode(node, SpecDoubleReal);
2250             break;
2251         case Array::Contiguous:
2252         case Array::ArrayStorage:
2253         case Array::SlowPutArrayStorage:
2254             if (node-&gt;arrayMode().isOutOfBounds())
2255                 clobberWorld();
2256             makeHeapTopForNode(node);
2257             break;
2258         case Array::Int8Array:
2259             setNonCellTypeForNode(node, SpecInt32Only);
2260             break;
2261         case Array::Int16Array:
2262             setNonCellTypeForNode(node, SpecInt32Only);
2263             break;
2264         case Array::Int32Array:
2265             setNonCellTypeForNode(node, SpecInt32Only);
2266             break;
2267         case Array::Uint8Array:
2268             setNonCellTypeForNode(node, SpecInt32Only);
2269             break;
2270         case Array::Uint8ClampedArray:
2271             setNonCellTypeForNode(node, SpecInt32Only);
2272             break;
2273         case Array::Uint16Array:
2274             setNonCellTypeForNode(node, SpecInt32Only);
2275             break;
2276         case Array::Uint32Array:
2277             if (node-&gt;shouldSpeculateInt32())
2278                 setNonCellTypeForNode(node, SpecInt32Only);
2279             else if (node-&gt;shouldSpeculateInt52())
2280                 setNonCellTypeForNode(node, SpecInt52Any);
2281             else
2282                 setNonCellTypeForNode(node, SpecAnyIntAsDouble);
2283             break;
2284         case Array::Float32Array:
2285             setNonCellTypeForNode(node, SpecFullDouble);
2286             break;
2287         case Array::Float64Array:
2288             setNonCellTypeForNode(node, SpecFullDouble);
2289             break;
2290         default:
2291             RELEASE_ASSERT_NOT_REACHED();
2292             break;
2293         }
2294         break;
2295     }
2296 
2297     case PutByValDirect:
2298     case PutByVal:
2299     case PutByValAlias: {
2300         switch (node-&gt;arrayMode().modeForPut().type()) {
2301         case Array::ForceExit:
2302             m_state.setIsValid(false);
2303             break;
2304         case Array::Generic:
2305             clobberWorld();
2306             break;
2307         case Array::Int32:
2308             if (node-&gt;arrayMode().isOutOfBounds())
2309                 clobberWorld();
2310             break;
2311         case Array::Double:
2312             if (node-&gt;arrayMode().isOutOfBounds())
2313                 clobberWorld();
2314             break;
2315         case Array::Contiguous:
2316         case Array::ArrayStorage:
2317             if (node-&gt;arrayMode().isOutOfBounds())
2318                 clobberWorld();
2319             break;
2320         case Array::SlowPutArrayStorage:
2321             if (node-&gt;arrayMode().mayStoreToHole())
2322                 clobberWorld();
2323             break;
2324         default:
2325             break;
2326         }
2327         break;
2328     }
2329 
2330     case ArrayPush:
2331         clobberWorld();
2332         setNonCellTypeForNode(node, SpecBytecodeNumber);
2333         break;
2334 
2335     case ArraySlice: {
2336         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2337 
2338         // FIXME: We could do better here if we prove that the
2339         // incoming value has only a single structure.
2340         RegisteredStructureSet structureSet;
2341         structureSet.add(m_graph.registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithInt32)));
2342         structureSet.add(m_graph.registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous)));
2343         structureSet.add(m_graph.registerStructure(globalObject-&gt;originalArrayStructureForIndexingType(ArrayWithDouble)));
2344 
2345         setForNode(node, structureSet);
2346         break;
2347     }
2348 
2349     case ArrayIndexOf: {
2350         setNonCellTypeForNode(node, SpecInt32Only);
2351         break;
2352     }
2353 
2354     case ArrayPop:
2355         clobberWorld();
2356         makeHeapTopForNode(node);
2357         break;
2358 
2359     case GetMyArgumentByVal:
2360     case GetMyArgumentByValOutOfBounds: {
2361         JSValue index = forNode(node-&gt;child2()).m_value;
2362         InlineCallFrame* inlineCallFrame = node-&gt;child1()-&gt;origin.semantic.inlineCallFrame();
2363 
2364         if (index &amp;&amp; index.isUInt32()) {
2365             // This pretends to return TOP for accesses that are actually proven out-of-bounds because
2366             // that&#39;s the conservative thing to do. Otherwise we&#39;d need to write more code to mark such
2367             // paths as unreachable, or to return undefined. We could implement that eventually.
2368 
2369             Checked&lt;unsigned, RecordOverflow&gt; argumentIndexChecked = index.asUInt32();
2370             argumentIndexChecked += node-&gt;numberOfArgumentsToSkip();
2371             unsigned argumentIndex;
2372             if (argumentIndexChecked.safeGet(argumentIndex) != CheckedState::DidOverflow) {
2373                 if (inlineCallFrame) {
2374                     if (argumentIndex &lt; static_cast&lt;unsigned&gt;(inlineCallFrame-&gt;argumentCountIncludingThis - 1)) {
2375                         setForNode(node, m_state.operand(
2376                             virtualRegisterForArgumentIncludingThis(argumentIndex + 1) + inlineCallFrame-&gt;stackOffset));
2377                         m_state.setShouldTryConstantFolding(true);
2378                         break;
2379                     }
2380                 } else {
2381                     if (argumentIndex &lt; m_state.numberOfArguments() - 1) {
2382                         setForNode(node, m_state.argument(argumentIndex + 1));
2383                         m_state.setShouldTryConstantFolding(true);
2384                         break;
2385                     }
2386                 }
2387             }
2388         }
2389 
2390         if (inlineCallFrame) {
2391             // We have a bound on the types even though it&#39;s random access. Take advantage of this.
2392 
2393             AbstractValue result;
2394             for (unsigned i = 1 + node-&gt;numberOfArgumentsToSkip(); i &lt; inlineCallFrame-&gt;argumentCountIncludingThis; ++i) {
2395                 result.merge(
2396                     m_state.operand(
2397                         virtualRegisterForArgumentIncludingThis(i) + inlineCallFrame-&gt;stackOffset));
2398             }
2399 
2400             if (node-&gt;op() == GetMyArgumentByValOutOfBounds)
2401                 result.merge(SpecOther);
2402 
2403             if (result.value())
2404                 m_state.setShouldTryConstantFolding(true);
2405 
2406             setForNode(node, result);
2407             break;
2408         }
2409 
2410         makeHeapTopForNode(node);
2411         break;
2412     }
2413 
2414     case RegExpExec:
2415     case RegExpExecNonGlobalOrSticky:
2416         if (node-&gt;op() == RegExpExec) {
2417             // Even if we&#39;ve proven known input types as RegExpObject and String,
2418             // accessing lastIndex is effectful if it&#39;s a global regexp.
2419             clobberWorld();
2420         }
2421 
2422         if (JSValue globalObjectValue = forNode(node-&gt;child1()).m_value) {
2423             if (JSGlobalObject* globalObject = jsDynamicCast&lt;JSGlobalObject*&gt;(m_vm, globalObjectValue)) {
2424                 if (!globalObject-&gt;isHavingABadTime()) {
2425                     m_graph.watchpoints().addLazily(globalObject-&gt;havingABadTimeWatchpoint());
2426                     RegisteredStructureSet structureSet;
2427                     structureSet.add(m_graph.registerStructure(globalObject-&gt;regExpMatchesArrayStructure()));
2428                     setForNode(node, structureSet);
2429                     forNode(node).merge(SpecOther);
2430                     break;
2431                 }
2432             }
2433         }
2434         setTypeForNode(node, SpecOther | SpecArray);
2435         break;
2436 
2437     case RegExpTest:
2438         // Even if we&#39;ve proven known input types as RegExpObject and String,
2439         // accessing lastIndex is effectful if it&#39;s a global regexp.
2440         clobberWorld();
2441         setNonCellTypeForNode(node, SpecBoolean);
2442         break;
2443 
2444     case RegExpMatchFast:
2445         ASSERT(node-&gt;child2().useKind() == RegExpObjectUse);
2446         ASSERT(node-&gt;child3().useKind() == StringUse || node-&gt;child3().useKind() == KnownStringUse);
2447         setTypeForNode(node, SpecOther | SpecArray);
2448         break;
2449 
2450     case RegExpMatchFastGlobal:
2451         ASSERT(node-&gt;child2().useKind() == StringUse || node-&gt;child2().useKind() == KnownStringUse);
2452         setTypeForNode(node, SpecOther | SpecArray);
2453         break;
2454 
2455     case StringReplace:
2456     case StringReplaceRegExp:
2457         if (node-&gt;child1().useKind() == StringUse
2458             &amp;&amp; node-&gt;child2().useKind() == RegExpObjectUse
2459             &amp;&amp; node-&gt;child3().useKind() == StringUse) {
2460             // This doesn&#39;t clobber the world. It just reads and writes regexp state.
2461         } else
2462             clobberWorld();
2463         setForNode(node, m_vm.stringStructure.get());
2464         break;
2465 
2466     case Jump:
2467         break;
2468 
2469     case Branch: {
2470         Node* child = node-&gt;child1().node();
2471         BooleanResult result = booleanResult(node, forNode(child));
2472         if (result == DefinitelyTrue) {
2473             m_state.setBranchDirection(TakeTrue);
2474             break;
2475         }
2476         if (result == DefinitelyFalse) {
2477             m_state.setBranchDirection(TakeFalse);
2478             break;
2479         }
2480         // FIXME: The above handles the trivial cases of sparse conditional
2481         // constant propagation, but we can do better:
2482         // We can specialize the source variable&#39;s value on each direction of
2483         // the branch.
2484         m_state.setBranchDirection(TakeBoth);
2485         break;
2486     }
2487 
2488     case Switch: {
2489         // Nothing to do for now.
2490         // FIXME: Do sparse conditional things.
2491         break;
2492     }
2493 
2494     case EntrySwitch:
2495         break;
2496 
2497     case Return:
2498         m_state.setIsValid(false);
2499         break;
2500 
2501     case Throw:
2502     case ThrowStaticError:
2503     case TailCall:
2504     case DirectTailCall:
2505     case TailCallVarargs:
2506     case TailCallForwardVarargs:
2507         clobberWorld();
2508         m_state.setIsValid(false);
2509         break;
2510 
2511     case ToPrimitive: {
2512         JSValue childConst = forNode(node-&gt;child1()).value();
2513         if (childConst &amp;&amp; childConst.isNumber()) {
2514             didFoldClobberWorld();
2515             setConstant(node, childConst);
2516             break;
2517         }
2518 
2519         ASSERT(node-&gt;child1().useKind() == UntypedUse);
2520 
2521         if (!(forNode(node-&gt;child1()).m_type &amp; ~(SpecFullNumber | SpecBoolean | SpecString | SpecSymbol | SpecBigInt))) {
2522             m_state.setShouldTryConstantFolding(true);
2523             didFoldClobberWorld();
2524             setForNode(node, forNode(node-&gt;child1()));
2525             break;
2526         }
2527 
2528         clobberWorld();
2529 
2530         setTypeForNode(node, SpecHeapTop &amp; ~SpecObject);
2531         break;
2532     }
2533 
2534     case ToPropertyKey: {
2535         if (!(forNode(node-&gt;child1()).m_type &amp; ~(SpecString | SpecSymbol))) {
2536             m_state.setShouldTryConstantFolding(true);
2537             didFoldClobberWorld();
2538             setForNode(node, forNode(node-&gt;child1()));
2539             break;
2540         }
2541 
2542         clobberWorld();
2543 
2544         setTypeForNode(node, SpecString | SpecSymbol);
2545         break;
2546     }
2547 
2548     case ToNumber: {
2549         JSValue childConst = forNode(node-&gt;child1()).value();
2550         if (childConst &amp;&amp; childConst.isNumber()) {
2551             didFoldClobberWorld();
2552             setConstant(node, childConst);
2553             break;
2554         }
2555 
2556         ASSERT(node-&gt;child1().useKind() == UntypedUse);
2557 
2558         if (!(forNode(node-&gt;child1()).m_type &amp; ~SpecBytecodeNumber)) {
2559             m_state.setShouldTryConstantFolding(true);
2560             didFoldClobberWorld();
2561             setForNode(node, forNode(node-&gt;child1()));
2562             break;
2563         }
2564 
2565         clobberWorld();
2566         setNonCellTypeForNode(node, SpecBytecodeNumber);
2567         break;
2568     }
2569 
2570     case ToNumeric: {
2571         JSValue childConst = forNode(node-&gt;child1()).value();
2572         if (childConst &amp;&amp; (childConst.isNumber() || childConst.isBigInt())) {
2573             didFoldClobberWorld();
2574             setConstant(node, childConst);
2575             break;
2576         }
2577 
2578         ASSERT(node-&gt;child1().useKind() == UntypedUse);
2579 
2580         if (!(forNode(node-&gt;child1()).m_type &amp; ~(SpecBytecodeNumber | SpecBigInt))) {
2581             m_state.setShouldTryConstantFolding(true);
2582             didFoldClobberWorld();
2583             setForNode(node, forNode(node-&gt;child1()));
2584             break;
2585         }
2586 
2587         clobberWorld();
2588         setTypeForNode(node, SpecBytecodeNumber | SpecBigInt);
2589         break;
2590     }
2591 
2592     case ToString:
2593     case CallStringConstructor: {
2594         switch (node-&gt;child1().useKind()) {
2595         case StringObjectUse:
2596         case StringOrStringObjectUse:
2597         case Int32Use:
2598         case Int52RepUse:
2599         case DoubleRepUse:
2600         case NotCellUse:
2601             break;
2602         case CellUse:
2603         case UntypedUse:
2604             clobberWorld();
2605             break;
2606         default:
2607             RELEASE_ASSERT_NOT_REACHED();
2608             break;
2609         }
2610         setForNode(node, m_vm.stringStructure.get());
2611         break;
2612     }
2613 
2614     case NumberToStringWithRadix: {
2615         JSValue radixValue = forNode(node-&gt;child2()).m_value;
2616         if (radixValue &amp;&amp; radixValue.isInt32()) {
2617             int32_t radix = radixValue.asInt32();
2618             if (2 &lt;= radix &amp;&amp; radix &lt;= 36) {
2619                 m_state.setShouldTryConstantFolding(true);
2620                 didFoldClobberWorld();
2621                 setForNode(node, m_graph.m_vm.stringStructure.get());
2622                 break;
2623             }
2624         }
2625         clobberWorld();
2626         setForNode(node, m_graph.m_vm.stringStructure.get());
2627         break;
2628     }
2629 
2630     case NumberToStringWithValidRadixConstant: {
2631         setForNode(node, m_graph.m_vm.stringStructure.get());
2632         break;
2633     }
2634 
2635     case NewStringObject: {
2636         ASSERT(node-&gt;structure()-&gt;classInfo() == StringObject::info());
2637         setForNode(node, node-&gt;structure());
2638         break;
2639     }
2640 
2641     case NewSymbol: {
2642         setForNode(node, m_vm.symbolStructure.get());
2643         break;
2644     }
2645 
2646     case NewArray:
2647         ASSERT(node-&gt;indexingMode() == node-&gt;indexingType()); // Copy on write arrays should only be created by NewArrayBuffer.
2648         setForNode(node,
2649             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingType()));
2650         break;
2651 
2652     case NewArrayWithSpread:
2653         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
2654             // We&#39;ve compiled assuming we&#39;re not having a bad time, so to be consistent
2655             // with StructureRegisterationPhase we must say we produce an original array
2656             // allocation structure.
2657 #if USE(JSVALUE64)
2658             BitVector* bitVector = node-&gt;bitVector();
2659             if (node-&gt;numChildren() == 1 &amp;&amp; bitVector-&gt;get(0)) {
2660                 Edge use = m_graph.varArgChild(node, 0);
2661                 if (use-&gt;op() == PhantomSpread) {
2662                     if (use-&gt;child1()-&gt;op() == PhantomNewArrayBuffer) {
2663                         auto* immutableButterfly = use-&gt;child1()-&gt;castOperand&lt;JSImmutableButterfly*&gt;();
2664                         if (hasContiguous(immutableButterfly-&gt;indexingType())) {
2665                             m_state.setShouldTryConstantFolding(true);
2666                             setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;originalArrayStructureForIndexingType(CopyOnWriteArrayWithContiguous));
2667                             break;
2668                         }
2669                     }
2670                 } else {
2671                     setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;originalArrayStructureForIndexingType(CopyOnWriteArrayWithContiguous));
2672                     break;
2673                 }
2674             }
2675 #endif
2676             setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;originalArrayStructureForIndexingType(ArrayWithContiguous));
2677         } else {
2678             setForNode(node,
2679                 m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous));
2680         }
2681 
2682         break;
2683 
2684     case Spread:
2685         switch (node-&gt;child1()-&gt;op()) {
2686         case PhantomNewArrayBuffer:
2687         case PhantomCreateRest:
2688             break;
2689         default:
2690             if (!m_graph.canDoFastSpread(node, forNode(node-&gt;child1())))
2691                 clobberWorld();
2692             else
2693                 didFoldClobberWorld();
2694             break;
2695         }
2696 
2697         setForNode(node, m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get());
2698         break;
2699 
2700     case NewArrayBuffer:
2701         setForNode(node,
2702             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;arrayStructureForIndexingTypeDuringAllocation(node-&gt;indexingMode()));
2703         break;
2704 
2705     case NewArrayWithSize:
2706         setTypeForNode(node, SpecArray);
2707         break;
2708 
2709     case NewTypedArray:
2710         switch (node-&gt;child1().useKind()) {
2711         case Int32Use:
2712             break;
2713         case UntypedUse:
2714             clobberWorld();
2715             break;
2716         default:
2717             RELEASE_ASSERT_NOT_REACHED();
2718             break;
2719         }
2720         setForNode(node,
2721             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;typedArrayStructureConcurrently(
2722                 node-&gt;typedArrayType()));
2723         break;
2724 
2725     case NewRegexp:
2726         setForNode(node, m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;regExpStructure());
2727         break;
2728 
2729     case ToThis: {
2730         AbstractValue&amp; source = forNode(node-&gt;child1());
2731         AbstractValue&amp; destination = forNode(node);
2732         bool strictMode = m_graph.isStrictModeFor(node-&gt;origin.semantic);
2733 
2734         ToThisResult result = isToThisAnIdentity(m_vm, strictMode, source);
2735         switch (result) {
2736         case ToThisResult::Identity:
2737             m_state.setShouldTryConstantFolding(true);
2738             destination = source;
2739             break;
2740         case ToThisResult::Undefined:
2741             setConstant(node, jsUndefined());
2742             break;
2743         case ToThisResult::GlobalThis:
2744             m_state.setShouldTryConstantFolding(true);
2745             destination.setType(m_graph, SpecObject);
2746             break;
2747         case ToThisResult::Dynamic:
2748             if (strictMode)
2749                 destination.makeHeapTop();
2750             else {
2751                 destination = source;
2752                 destination.merge(SpecObject);
2753             }
2754             break;
2755         }
2756         break;
2757     }
2758 
2759     case CreateThis: {
2760         if (JSValue base = forNode(node-&gt;child1()).m_value) {
2761             if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, base)) {
2762                 if (FunctionRareData* rareData = function-&gt;rareData()) {
2763                     if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {
2764                         if (Structure* structure = rareData-&gt;objectAllocationStructure()) {
2765                             m_graph.freeze(rareData);
2766                             m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());
2767                             m_state.setShouldTryConstantFolding(true);
2768                             didFoldClobberWorld();
2769                             setForNode(node, structure);
2770                             break;
2771                         }
2772                     }
2773                 }
2774             }
2775         }
2776         clobberWorld();
2777         setTypeForNode(node, SpecFinalObject);
2778         break;
2779     }
2780 
2781     case CreatePromise: {
2782         JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2783         if (JSValue base = forNode(node-&gt;child1()).m_value) {
2784             if (base == (node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseConstructor() : globalObject-&gt;promiseConstructor())) {
2785                 m_state.setShouldTryConstantFolding(true);
2786                 didFoldClobberWorld();
2787                 setForNode(node, node-&gt;isInternalPromise() ? globalObject-&gt;internalPromiseStructure() : globalObject-&gt;promiseStructure());
2788                 break;
2789             }
2790             if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_graph.m_vm, base)) {
2791                 if (FunctionRareData* rareData = function-&gt;rareData()) {
2792                     if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {
2793                         Structure* structure = rareData-&gt;internalFunctionAllocationStructure();
2794                         if (structure
2795                             &amp;&amp; structure-&gt;classInfo() == (node-&gt;isInternalPromise() ? JSInternalPromise::info() : JSPromise::info())
2796                             &amp;&amp; structure-&gt;globalObject() == globalObject
2797                             &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {
2798                             m_graph.freeze(rareData);
2799                             m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());
2800                             m_state.setShouldTryConstantFolding(true);
2801                             didFoldClobberWorld();
2802                             setForNode(node, structure);
2803                             break;
2804                         }
2805                     }
2806                 }
2807             }
2808         }
2809         clobberWorld();
2810         setTypeForNode(node, SpecPromiseObject);
2811         break;
2812     }
2813 
2814     case CreateGenerator:
2815     case CreateAsyncGenerator: {
2816         auto tryToFold = [&amp;] (const ClassInfo* classInfo) -&gt; bool {
2817             JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2818             if (JSValue base = forNode(node-&gt;child1()).m_value) {
2819                 if (auto* function = jsDynamicCast&lt;JSFunction*&gt;(m_graph.m_vm, base)) {
2820                     if (FunctionRareData* rareData = function-&gt;rareData()) {
2821                         if (rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {
2822                             Structure* structure = rareData-&gt;internalFunctionAllocationStructure();
2823                             if (structure
2824                                 &amp;&amp; structure-&gt;classInfo() == classInfo
2825                                 &amp;&amp; structure-&gt;globalObject() == globalObject
2826                                 &amp;&amp; rareData-&gt;allocationProfileWatchpointSet().isStillValid()) {
2827                                 m_graph.freeze(rareData);
2828                                 m_graph.watchpoints().addLazily(rareData-&gt;allocationProfileWatchpointSet());
2829                                 m_state.setShouldTryConstantFolding(true);
2830                                 didFoldClobberWorld();
2831                                 setForNode(node, structure);
2832                                 return true;
2833                             }
2834                         }
2835                     }
2836                 }
2837             }
2838             return false;
2839         };
2840 
2841         bool found = false;
2842         switch (node-&gt;op()) {
2843         case CreateGenerator:
2844             found = tryToFold(JSGenerator::info());
2845             break;
2846         case CreateAsyncGenerator:
2847             found = tryToFold(JSAsyncGenerator::info());
2848             break;
2849         default:
2850             RELEASE_ASSERT_NOT_REACHED();
2851             break;
2852         }
2853         if (found)
2854             break;
2855         clobberWorld();
2856         setTypeForNode(node, SpecObjectOther);
2857         break;
2858     }
2859 
2860     case NewPromise:
2861     case NewGenerator:
2862     case NewAsyncGenerator:
2863     case NewArrayIterator:
2864     case NewObject:
2865     case MaterializeNewInternalFieldObject:
2866         ASSERT(!!node-&gt;structure().get());
2867         setForNode(node, node-&gt;structure());
2868         break;
2869 
2870     case ObjectCreate: {
2871         if (JSValue base = forNode(node-&gt;child1()).m_value) {
2872             JSGlobalObject* globalObject = m_graph.globalObjectFor(node-&gt;origin.semantic);
2873             Structure* structure = nullptr;
2874             if (base.isNull())
2875                 structure = globalObject-&gt;nullPrototypeObjectStructure();
2876             else if (base.isObject())
2877                 structure = m_vm.structureCache.emptyObjectStructureConcurrently(globalObject, base.getObject(), JSFinalObject::defaultInlineCapacity());
2878 
2879             if (structure) {
2880                 m_state.setShouldTryConstantFolding(true);
2881                 if (node-&gt;child1().useKind() == UntypedUse)
2882                     didFoldClobberWorld();
2883                 setForNode(node, structure);
2884                 break;
2885             }
2886         }
2887         if (node-&gt;child1().useKind() == UntypedUse)
2888             clobberWorld();
2889         setTypeForNode(node, SpecFinalObject);
2890         break;
2891     }
2892 
2893     case ObjectKeys: {
2894         if (node-&gt;child1().useKind() == ObjectUse) {
2895             auto&amp; structureSet = forNode(node-&gt;child1()).m_structure;
2896             if (structureSet.isFinite() &amp;&amp; structureSet.size() == 1) {
2897                 RegisteredStructure structure = structureSet.onlyStructure();
2898                 if (auto* rareData = structure-&gt;rareDataConcurrently()) {
2899                     if (!!rareData-&gt;cachedOwnKeysConcurrently()) {
2900                         if (m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
2901                             m_state.setShouldTryConstantFolding(true);
2902                             didFoldClobberWorld();
2903                             setTypeForNode(node, SpecArray);
2904                             break;
2905                         }
2906                     }
2907                 }
2908             }
2909         }
2910 
2911         clobberWorld();
2912         setTypeForNode(node, SpecArray);
2913         break;
2914     }
2915 
2916     case ToObject:
2917     case CallObjectConstructor: {
2918         AbstractValue&amp; source = forNode(node-&gt;child1());
2919         AbstractValue&amp; destination = forNode(node);
2920 
2921         if (!(source.m_type &amp; ~SpecObject)) {
2922             m_state.setShouldTryConstantFolding(true);
2923             if (node-&gt;op() == ToObject)
2924                 didFoldClobberWorld();
2925             destination = source;
2926             break;
2927         }
2928 
2929         if (node-&gt;op() == ToObject)
2930             clobberWorld();
2931         setTypeForNode(node, SpecObject);
2932         break;
2933     }
2934 
2935     case PhantomNewObject:
2936     case PhantomNewFunction:
2937     case PhantomNewGeneratorFunction:
2938     case PhantomNewAsyncGeneratorFunction:
2939     case PhantomNewAsyncFunction:
2940     case PhantomCreateActivation:
2941     case PhantomDirectArguments:
2942     case PhantomClonedArguments:
2943     case PhantomCreateRest:
2944     case PhantomSpread:
2945     case PhantomNewArrayWithSpread:
2946     case PhantomNewArrayBuffer:
2947     case PhantomNewArrayIterator:
2948     case PhantomNewRegexp:
2949     case BottomValue: {
2950         clearForNode(node);
2951         break;
2952     }
2953 
2954     case PutHint:
2955         break;
2956 
2957     case MaterializeNewObject: {
2958         setForNode(node, node-&gt;structureSet());
2959         break;
2960     }
2961 
2962     case PushWithScope:
2963         // We don&#39;t use the more precise withScopeStructure() here because it is a LazyProperty and may not yet be allocated.
2964         setTypeForNode(node, SpecObjectOther);
2965         break;
2966 
2967     case CreateActivation:
2968     case MaterializeCreateActivation:
2969         setForNode(node,
2970             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;activationStructure());
2971         break;
2972 
2973     case CreateDirectArguments:
2974         setForNode(node, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;directArgumentsStructure());
2975         break;
2976 
2977     case CreateScopedArguments:
2978         setForNode(node, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;scopedArgumentsStructure());
2979         break;
2980 
2981     case CreateClonedArguments:
2982         if (!m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
2983             setTypeForNode(node, SpecObject);
2984             break;
2985         }
2986         setForNode(node, m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;clonedArgumentsStructure());
2987         break;
2988 
2989     case CreateArgumentsButterfly:
2990         setForNode(node, m_vm.immutableButterflyStructures[arrayIndexFromIndexingType(CopyOnWriteArrayWithContiguous) - NumberOfIndexingShapes].get());
2991         break;
2992 
2993     case NewGeneratorFunction:
2994         setForNode(node,
2995             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;generatorFunctionStructure());
2996         break;
2997 
2998     case NewAsyncGeneratorFunction:
2999         setForNode(node,
3000             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;asyncGeneratorFunctionStructure());
3001         break;
3002 
3003     case NewAsyncFunction:
3004         setForNode(node,
3005             m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic)-&gt;asyncFunctionStructure());
3006         break;
3007 
3008     case NewFunction: {
3009         JSGlobalObject* globalObject = m_codeBlock-&gt;globalObjectFor(node-&gt;origin.semantic);
3010         Structure* structure = JSFunction::selectStructureForNewFuncExp(globalObject, node-&gt;castOperand&lt;FunctionExecutable*&gt;());
3011         setForNode(node, structure);
3012         break;
3013     }
3014 
3015     case GetCallee:
3016         if (FunctionExecutable* executable = jsDynamicCast&lt;FunctionExecutable*&gt;(m_vm, m_codeBlock-&gt;ownerExecutable())) {
3017             if (JSFunction* function = executable-&gt;singleton().inferredValue()) {
3018                 m_graph.watchpoints().addLazily(executable);
3019                 setConstant(node, *m_graph.freeze(function));
3020                 break;
3021             }
3022         }
3023         setTypeForNode(node, SpecFunction | SpecObjectOther);
3024         break;
3025 
3026     case GetArgumentCountIncludingThis:
3027         setTypeForNode(node, SpecInt32Only);
3028         break;
3029 
3030     case SetCallee:
3031     case SetArgumentCountIncludingThis:
3032         break;
3033 
3034     case GetRestLength:
3035         setNonCellTypeForNode(node, SpecInt32Only);
3036         break;
3037 
3038     case GetGetter: {
3039         if (JSValue base = forNode(node-&gt;child1()).m_value) {
3040             GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(m_vm, base);
3041             if (getterSetter &amp;&amp; !getterSetter-&gt;isGetterNull()) {
3042                 setConstant(node, *m_graph.freeze(getterSetter-&gt;getterConcurrently()));
3043                 break;
3044             }
3045         }
3046 
3047         setTypeForNode(node, SpecObject);
3048         break;
3049     }
3050 
3051     case GetSetter: {
3052         if (JSValue base = forNode(node-&gt;child1()).m_value) {
3053             GetterSetter* getterSetter = jsDynamicCast&lt;GetterSetter*&gt;(m_vm, base);
3054             if (getterSetter &amp;&amp; !getterSetter-&gt;isSetterNull()) {
3055                 setConstant(node, *m_graph.freeze(getterSetter-&gt;setterConcurrently()));
3056                 break;
3057             }
3058         }
3059 
3060         setTypeForNode(node, SpecObject);
3061         break;
3062     }
3063 
3064     case GetScope:
3065         if (JSValue base = forNode(node-&gt;child1()).m_value) {
3066             if (JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, base)) {
3067                 setConstant(node, *m_graph.freeze(function-&gt;scope()));
3068                 break;
3069             }
3070         }
3071         setTypeForNode(node, SpecObjectOther);
3072         break;
3073 
3074     case SkipScope: {
3075         if (JSValue child = forNode(node-&gt;child1()).value()) {
3076             if (JSScope* scope = jsDynamicCast&lt;JSScope*&gt;(m_vm, child)) {
3077                 if (JSScope* nextScope = scope-&gt;next()) {
3078                     setConstant(node, *m_graph.freeze(JSValue(nextScope)));
3079                     break;
3080                 }
3081             }
3082         }
3083         setTypeForNode(node, SpecObjectOther);
3084         break;
3085     }
3086 
3087     case GetGlobalObject: {
3088         JSValue child = forNode(node-&gt;child1()).value();
3089         if (child) {
3090             setConstant(node, *m_graph.freeze(JSValue(asObject(child)-&gt;globalObject(m_vm))));
3091             break;
3092         }
3093 
3094         if (forNode(node-&gt;child1()).m_structure.isFinite()) {
3095             JSGlobalObject* globalObject = nullptr;
3096             bool ok = true;
3097             forNode(node-&gt;child1()).m_structure.forEach(
3098                 [&amp;] (RegisteredStructure structure) {
3099                     if (!globalObject)
3100                         globalObject = structure-&gt;globalObject();
3101                     else if (globalObject != structure-&gt;globalObject())
3102                         ok = false;
3103                 });
3104             if (globalObject &amp;&amp; ok) {
3105                 setConstant(node, *m_graph.freeze(JSValue(globalObject)));
3106                 break;
3107             }
3108         }
3109 
3110         setTypeForNode(node, SpecObjectOther);
3111         break;
3112     }
3113 
3114     case GetGlobalThis: {
3115         setTypeForNode(node, SpecObject);
3116         break;
3117     }
3118 
3119     case GetClosureVar:
3120         if (JSValue value = m_graph.tryGetConstantClosureVar(forNode(node-&gt;child1()), node-&gt;scopeOffset())) {
3121             setConstant(node, *m_graph.freeze(value));
3122             break;
3123         }
3124         makeBytecodeTopForNode(node);
3125         break;
3126 
3127     case PutClosureVar:
3128         break;
3129 
3130     case GetInternalField:
3131         makeBytecodeTopForNode(node);
3132         break;
3133 
3134     case PutInternalField:
3135         break;
3136 
3137 
3138     case GetRegExpObjectLastIndex:
3139         makeHeapTopForNode(node);
3140         break;
3141 
3142     case SetRegExpObjectLastIndex:
3143     case RecordRegExpCachedResult:
3144         break;
3145 
3146     case GetFromArguments:
3147         makeHeapTopForNode(node);
3148         break;
3149 
3150     case PutToArguments:
3151         break;
3152 
3153     case GetArgument:
3154         makeHeapTopForNode(node);
3155         break;
3156 
3157     case TryGetById:
3158         // FIXME: This should constant fold at least as well as the normal GetById case.
3159         // https://bugs.webkit.org/show_bug.cgi?id=156422
3160         makeHeapTopForNode(node);
3161         break;
3162 
3163     case GetByIdDirect:
3164     case GetByIdDirectFlush:
3165     case GetById:
3166     case GetByIdFlush: {
3167         AbstractValue&amp; value = forNode(node-&gt;child1());
3168         if (value.m_structure.isFinite()
3169             &amp;&amp; (node-&gt;child1().useKind() == CellUse || !(value.m_type &amp; ~SpecCell))) {
3170             UniquedStringImpl* uid = m_graph.identifiers()[node-&gt;identifierNumber()];
3171             GetByStatus status = GetByStatus::computeFor(value.m_structure.toStructureSet(), uid);
3172             if (status.isSimple()) {
3173                 // Figure out what the result is going to be - is it TOP, a constant, or maybe
3174                 // something more subtle?
3175                 AbstractValue result;
3176                 for (unsigned i = status.numVariants(); i--;) {
3177                     // This thing won&#39;t give us a variant that involves prototypes. If it did, we&#39;d
3178                     // have more work to do here.
3179                     DFG_ASSERT(m_graph, node, status[i].conditionSet().isEmpty());
3180 
3181                     result.merge(
3182                         m_graph.inferredValueForProperty(
3183                             value, status[i].offset(), m_state.structureClobberState()));
3184                 }
3185 
3186                 m_state.setShouldTryConstantFolding(true);
3187                 didFoldClobberWorld();
3188                 forNode(node) = result;
3189                 break;
3190             }
3191         }
3192 
3193         clobberWorld();
3194         makeHeapTopForNode(node);
3195         break;
3196     }
3197 
3198     case GetByValWithThis:
3199     case GetByIdWithThis:
3200         clobberWorld();
3201         makeHeapTopForNode(node);
3202         break;
3203 
3204     case GetArrayLength: {
3205         JSArrayBufferView* view = m_graph.tryGetFoldableView(
3206             forNode(node-&gt;child1()).m_value, node-&gt;arrayMode());
3207         if (view) {
3208             setConstant(node, jsNumber(view-&gt;length()));
3209             break;
3210         }
3211         setNonCellTypeForNode(node, SpecInt32Only);
3212         break;
3213     }
3214 
3215     case GetVectorLength: {
3216         setNonCellTypeForNode(node, SpecInt32Only);
3217         break;
3218     }
3219 
3220     case DeleteById:
3221     case DeleteByVal: {
3222         // FIXME: This could decide if the delete will be successful based on the set of structures that
3223         // we get from our base value. https://bugs.webkit.org/show_bug.cgi?id=156611
3224         clobberWorld();
3225         setNonCellTypeForNode(node, SpecBoolean);
3226         break;
3227     }
3228 
3229     case CheckStructure: {
3230         AbstractValue&amp; value = forNode(node-&gt;child1());
3231 
3232         const RegisteredStructureSet&amp; set = node-&gt;structureSet();
3233 
3234         // It&#39;s interesting that we could have proven that the object has a larger structure set
3235         // that includes the set we&#39;re testing. In that case we could make the structure check
3236         // more efficient. We currently don&#39;t.
3237 
3238         if (value.m_structure.isSubsetOf(set))
3239             m_state.setShouldTryConstantFolding(true);
3240 
3241         SpeculatedType admittedTypes = SpecNone;
3242         switch (node-&gt;child1().useKind()) {
3243         case CellUse:
3244         case KnownCellUse:
3245             admittedTypes = SpecNone;
3246             break;
3247         case CellOrOtherUse:
3248             admittedTypes = SpecOther;
3249             break;
3250         default:
3251             DFG_CRASH(m_graph, node, &quot;Bad use kind&quot;);
3252             break;
3253         }
3254 
3255         filter(value, set, admittedTypes);
3256         break;
3257     }
3258 
3259     case CheckStructureOrEmpty: {
3260         AbstractValue&amp; value = forNode(node-&gt;child1());
3261 
3262         bool mayBeEmpty = value.m_type &amp; SpecEmpty;
3263         if (!mayBeEmpty)
3264             m_state.setShouldTryConstantFolding(true);
3265 
3266         SpeculatedType admittedTypes = mayBeEmpty ? SpecEmpty : SpecNone;
3267         filter(value, node-&gt;structureSet(), admittedTypes);
3268         break;
3269     }
3270 
3271     case CheckStructureImmediate: {
3272         // FIXME: This currently can only reason about one structure at a time.
3273         // https://bugs.webkit.org/show_bug.cgi?id=136988
3274 
3275         AbstractValue&amp; value = forNode(node-&gt;child1());
3276         const RegisteredStructureSet&amp; set = node-&gt;structureSet();
3277 
3278         if (value.value()) {
3279             if (Structure* structure = jsDynamicCast&lt;Structure*&gt;(m_vm, value.value())) {
3280                 if (set.contains(m_graph.registerStructure(structure))) {
3281                     m_state.setShouldTryConstantFolding(true);
3282                     break;
3283                 }
3284             }
3285             m_state.setIsValid(false);
3286             break;
3287         }
3288 
3289         if (m_phiChildren) {
3290             bool allGood = true;
3291             m_phiChildren-&gt;forAllTransitiveIncomingValues(
3292                 node,
3293                 [&amp;] (Node* incoming) {
3294                     if (Structure* structure = incoming-&gt;dynamicCastConstant&lt;Structure*&gt;(m_vm)) {
3295                         if (set.contains(m_graph.registerStructure(structure)))
3296                             return;
3297                     }
3298                     allGood = false;
3299                 });
3300             if (allGood) {
3301                 m_state.setShouldTryConstantFolding(true);
3302                 break;
3303             }
3304         }
3305 
3306         if (RegisteredStructure structure = set.onlyStructure()) {
3307             filterByValue(node-&gt;child1(), *m_graph.freeze(structure.get()));
3308             break;
3309         }
3310 
3311         // Aw shucks, we can&#39;t do anything!
3312         break;
3313     }
3314 
3315     case PutStructure:
3316         if (!forNode(node-&gt;child1()).m_structure.isClear()) {
3317             if (forNode(node-&gt;child1()).m_structure.onlyStructure() == node-&gt;transition()-&gt;next) {
3318                 didFoldClobberStructures();
3319                 m_state.setShouldTryConstantFolding(true);
3320             } else {
3321                 observeTransition(
3322                     clobberLimit, node-&gt;transition()-&gt;previous, node-&gt;transition()-&gt;next);
3323                 forNode(node-&gt;child1()).changeStructure(m_graph, node-&gt;transition()-&gt;next);
3324             }
3325         } else {
3326             // We&#39;re going to exit before we get here, but for the sake of validation, we&#39;ve folded our write to StructureID.
3327             didFoldClobberStructures();
3328         }
3329         break;
3330     case GetButterfly:
3331     case AllocatePropertyStorage:
3332     case ReallocatePropertyStorage:
3333     case NukeStructureAndSetButterfly:
3334         // FIXME: We don&#39;t model the fact that the structureID is nuked, simply because currently
3335         // nobody would currently benefit from having that information. But it&#39;s a bug nonetheless.
3336         if (node-&gt;op() == NukeStructureAndSetButterfly)
3337             didFoldClobberStructures();
3338         clearForNode(node); // The result is not a JS value.
3339         break;
3340     case CheckSubClass: {
3341         JSValue constant = forNode(node-&gt;child1()).value();
3342         if (constant) {
3343             if (constant.isCell() &amp;&amp; constant.asCell()-&gt;inherits(m_vm, node-&gt;classInfo())) {
3344                 m_state.setShouldTryConstantFolding(true);
3345                 ASSERT(constant);
3346                 break;
3347             }
3348         }
3349 
3350         AbstractValue&amp; value = forNode(node-&gt;child1());
3351 
3352         if (value.m_structure.isSubClassOf(node-&gt;classInfo()))
3353             m_state.setShouldTryConstantFolding(true);
3354 
3355         filterClassInfo(value, node-&gt;classInfo());
3356         break;
3357     }
3358     case CallDOMGetter: {
3359         CallDOMGetterData* callDOMGetterData = node-&gt;callDOMGetterData();
3360         DOMJIT::CallDOMGetterSnippet* snippet = callDOMGetterData-&gt;snippet;
3361         if (!snippet || snippet-&gt;effect.writes)
3362             clobberWorld();
3363         if (callDOMGetterData-&gt;domJIT)
3364             setTypeForNode(node, callDOMGetterData-&gt;domJIT-&gt;resultType());
3365         else
3366             makeBytecodeTopForNode(node);
3367         break;
3368     }
3369     case CallDOM: {
3370         const DOMJIT::Signature* signature = node-&gt;signature();
3371         if (signature-&gt;effect.writes)
3372             clobberWorld();
3373         setTypeForNode(node, signature-&gt;result);
3374         break;
3375     }
3376 
3377     case CheckArrayOrEmpty:
3378     case CheckArray: {
3379         AbstractValue&amp; value = forNode(node-&gt;child1());
3380 
3381         SpeculatedType admittedTypes = SpecNone;
3382         if (node-&gt;op() == CheckArrayOrEmpty) {
3383             bool mayBeEmpty = value.m_type &amp; SpecEmpty;
3384             if (!mayBeEmpty)
3385                 m_state.setShouldTryConstantFolding(true);
3386             else
3387                 admittedTypes = SpecEmpty;
3388         }
3389 
3390         if (node-&gt;arrayMode().alreadyChecked(m_graph, node, value)) {
3391             m_state.setShouldTryConstantFolding(true);
3392             break;
3393         }
3394 
3395         switch (node-&gt;arrayMode().type()) {
3396         case Array::String:
3397             filter(node-&gt;child1(), SpecString | admittedTypes);
3398             break;
3399         case Array::Int32:
3400         case Array::Double:
3401         case Array::Contiguous:
3402         case Array::Undecided:
3403         case Array::ArrayStorage:
3404         case Array::SlowPutArrayStorage:
3405             break;
3406         case Array::DirectArguments:
3407             filter(node-&gt;child1(), SpecDirectArguments | admittedTypes);
3408             break;
3409         case Array::ScopedArguments:
3410             filter(node-&gt;child1(), SpecScopedArguments | admittedTypes);
3411             break;
3412         case Array::Int8Array:
3413             filter(node-&gt;child1(), SpecInt8Array | admittedTypes);
3414             break;
3415         case Array::Int16Array:
3416             filter(node-&gt;child1(), SpecInt16Array | admittedTypes);
3417             break;
3418         case Array::Int32Array:
3419             filter(node-&gt;child1(), SpecInt32Array | admittedTypes);
3420             break;
3421         case Array::Uint8Array:
3422             filter(node-&gt;child1(), SpecUint8Array | admittedTypes);
3423             break;
3424         case Array::Uint8ClampedArray:
3425             filter(node-&gt;child1(), SpecUint8ClampedArray | admittedTypes);
3426             break;
3427         case Array::Uint16Array:
3428             filter(node-&gt;child1(), SpecUint16Array | admittedTypes);
3429             break;
3430         case Array::Uint32Array:
3431             filter(node-&gt;child1(), SpecUint32Array | admittedTypes);
3432             break;
3433         case Array::Float32Array:
3434             filter(node-&gt;child1(), SpecFloat32Array | admittedTypes);
3435             break;
3436         case Array::Float64Array:
3437             filter(node-&gt;child1(), SpecFloat64Array | admittedTypes);
3438             break;
3439         case Array::AnyTypedArray:
3440             filter(node-&gt;child1(), SpecTypedArrayView | admittedTypes);
3441             break;
3442         default:
3443             RELEASE_ASSERT_NOT_REACHED();
3444             break;
3445         }
3446         filterArrayModes(node-&gt;child1(), node-&gt;arrayMode().arrayModesThatPassFiltering(), admittedTypes);
3447         break;
3448     }
3449 
3450     case Arrayify: {
3451         if (node-&gt;arrayMode().alreadyChecked(m_graph, node, forNode(node-&gt;child1()))) {
3452             didFoldClobberStructures();
3453             m_state.setShouldTryConstantFolding(true);
3454             break;
3455         }
3456         ASSERT(node-&gt;arrayMode().conversion() == Array::Convert);
3457         clobberStructures();
3458         filterArrayModes(node-&gt;child1(), node-&gt;arrayMode().arrayModesThatPassFiltering());
3459         break;
3460     }
3461     case ArrayifyToStructure: {
3462         AbstractValue&amp; value = forNode(node-&gt;child1());
3463         if (value.m_structure.isSubsetOf(RegisteredStructureSet(node-&gt;structure())))
3464             m_state.setShouldTryConstantFolding(true);
3465         clobberStructures();
3466 
3467         // We have a bunch of options of how to express the abstract set at this point. Let set S
3468         // be the set of structures that the value had before clobbering and assume that all of
3469         // them are watchable. The new value should be the least expressible upper bound of the
3470         // intersection of &quot;values that currently have structure = node-&gt;structure()&quot; and &quot;values
3471         // that have structure in S plus any structure transition-reachable from S&quot;. Assume that
3472         // node-&gt;structure() is not in S but it is transition-reachable from S. Then we would
3473         // like to say that the result is &quot;values that have structure = node-&gt;structure() until
3474         // we invalidate&quot;, but there is no way to express this using the AbstractValue syntax. So
3475         // we must choose between:
3476         //
3477         // 1) &quot;values that currently have structure = node-&gt;structure()&quot;. This is a valid
3478         //    superset of the value that we really want, and it&#39;s specific enough to satisfy the
3479         //    preconditions of the array access that this is guarding. It&#39;s also specific enough
3480         //    to allow relevant optimizations in the case that we didn&#39;t have a contradiction
3481         //    like in this example. Notice that in the abscence of any contradiction, this result
3482         //    is precise rather than being a conservative LUB.
3483         //
3484         // 2) &quot;values that currently hava structure in S plus any structure transition-reachable
3485         //    from S&quot;. This is also a valid superset of the value that we really want, but it&#39;s
3486         //    not specific enough to satisfy the preconditions of the array access that this is
3487         //    guarding - so playing such shenanigans would preclude us from having assertions on
3488         //    the typing preconditions of any array accesses. This would also not be a desirable
3489         //    answer in the absence of a contradiction.
3490         //
3491         // Note that it&#39;s tempting to simply say that the resulting value is BOTTOM because of
3492         // the contradiction. That would be wrong, since we haven&#39;t hit an invalidation point,
3493         // yet.
3494         forNode(node-&gt;child1()).set(m_graph, node-&gt;structure());
3495         break;
3496     }
3497     case GetIndexedPropertyStorage: {
3498         JSArrayBufferView* view = m_graph.tryGetFoldableView(
3499             forNode(node-&gt;child1()).m_value, node-&gt;arrayMode());
3500         if (view)
3501             m_state.setShouldTryConstantFolding(true);
3502         clearForNode(node);
3503         break;
3504     }
3505     case ConstantStoragePointer: {
3506         clearForNode(node);
3507         break;
3508     }
3509 
3510     case GetTypedArrayByteOffset: {
3511         JSArrayBufferView* view = m_graph.tryGetFoldableView(forNode(node-&gt;child1()).m_value);
3512         if (view) {
3513             Optional&lt;unsigned&gt; byteOffset = view-&gt;byteOffsetConcurrently();
3514             if (byteOffset) {
3515                 setConstant(node, jsNumber(*byteOffset));
3516                 break;
3517             }
3518         }
3519         setNonCellTypeForNode(node, SpecInt32Only);
3520         break;
3521     }
3522 
3523     case GetPrototypeOf: {
3524         AbstractValue&amp; value = forNode(node-&gt;child1());
3525         if ((value.m_type &amp;&amp; !(value.m_type &amp; ~SpecObject)) &amp;&amp; value.m_structure.isFinite()) {
3526             bool canFold = !value.m_structure.isClear();
3527             JSValue prototype;
3528             value.m_structure.forEach([&amp;] (RegisteredStructure structure) {
3529                 auto getPrototypeMethod = structure-&gt;classInfo()-&gt;methodTable.getPrototype;
3530                 MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
3531                 if (getPrototypeMethod != defaultGetPrototype) {
3532                     canFold = false;
3533                     return;
3534                 }
3535 
3536                 if (structure-&gt;hasPolyProto()) {
3537                     canFold = false;
3538                     return;
3539                 }
3540                 if (!prototype)
3541                     prototype = structure-&gt;storedPrototype();
3542                 else if (prototype != structure-&gt;storedPrototype())
3543                     canFold = false;
3544             });
3545 
3546             if (prototype &amp;&amp; canFold) {
3547                 switch (node-&gt;child1().useKind()) {
3548                 case ArrayUse:
3549                 case FunctionUse:
3550                 case FinalObjectUse:
3551                     break;
3552                 default:
3553                     didFoldClobberWorld();
3554                     break;
3555                 }
3556                 setConstant(node, *m_graph.freeze(prototype));
3557                 break;
3558             }
3559         }
3560 
3561         switch (node-&gt;child1().useKind()) {
3562         case ArrayUse:
3563         case FunctionUse:
3564         case FinalObjectUse:
3565             break;
3566         default:
3567             clobberWorld();
3568             break;
3569         }
3570         setTypeForNode(node, SpecObject | SpecOther);
3571         break;
3572     }
3573 
3574     case GetByOffset: {
3575         StorageAccessData&amp; data = node-&gt;storageAccessData();
3576 
3577         // FIXME: The part of this that handles inferred property types relies on AI knowing the structure
3578         // right now. That&#39;s probably not optimal. In some cases, we may perform an optimization (usually
3579         // by something other than AI, maybe by CSE for example) that obscures AI&#39;s view of the structure
3580         // at the point where GetByOffset runs. Currently, when that happens, we&#39;ll have to rely entirely
3581         // on the type that ByteCodeParser was able to prove.
3582         AbstractValue value = m_graph.inferredValueForProperty(
3583             forNode(node-&gt;child2()), data.offset, m_state.structureClobberState());
3584 
3585         // If we decide that there does not exist any value that this can return, then it&#39;s probably
3586         // because the compilation was already invalidated.
3587         if (value.isClear())
3588             m_state.setIsValid(false);
3589 
3590         setForNode(node, value);
3591         if (value.m_value)
3592             m_state.setShouldTryConstantFolding(true);
3593         break;
3594     }
3595 
3596     case GetGetterSetterByOffset: {
3597         StorageAccessData&amp; data = node-&gt;storageAccessData();
3598         AbstractValue base = forNode(node-&gt;child2());
3599         JSValue result = m_graph.tryGetConstantProperty(base, data.offset);
3600         if (result &amp;&amp; jsDynamicCast&lt;GetterSetter*&gt;(m_vm, result)) {
3601             setConstant(node, *m_graph.freeze(result));
3602             break;
3603         }
3604 
3605         setForNode(node, m_vm.getterSetterStructure.get());
3606         break;
3607     }
3608 
3609     case MultiGetByOffset: {
3610         // This code will filter the base value in a manner that is possibly different (either more
3611         // or less precise) than the way it would be filtered if this was strength-reduced to a
3612         // CheckStructure. This is fine. It&#39;s legal for different passes over the code to prove
3613         // different things about the code, so long as all of them are sound. That even includes
3614         // one guy proving that code should never execute (due to a contradiction) and another guy
3615         // not finding that contradiction. If someone ever proved that there would be a
3616         // contradiction then there must always be a contradiction even if subsequent passes don&#39;t
3617         // realize it. This is the case here.
3618 
3619         // Ordinarily you have to be careful with calling setShouldTryConstantFolding()
3620         // because of the effect on compile times, but this node is FTL-only.
3621         m_state.setShouldTryConstantFolding(true);
3622 
3623         AbstractValue base = forNode(node-&gt;child1());
3624         RegisteredStructureSet baseSet;
3625         AbstractValue result;
3626         for (const MultiGetByOffsetCase&amp; getCase : node-&gt;multiGetByOffsetData().cases) {
3627             RegisteredStructureSet set = getCase.set();
3628             set.filter(base);
3629             if (set.isEmpty())
3630                 continue;
3631             baseSet.merge(set);
3632 
3633             switch (getCase.method().kind()) {
3634             case GetByOffsetMethod::Constant: {
3635                 AbstractValue thisResult;
3636                 thisResult.set(
3637                     m_graph,
3638                     *getCase.method().constant(),
3639                     m_state.structureClobberState());
3640                 result.merge(thisResult);
3641                 break;
3642             }
3643 
3644             default: {
3645                 result.makeHeapTop();
3646                 break;
3647             } }
3648         }
3649 
3650         if (forNode(node-&gt;child1()).changeStructure(m_graph, baseSet) == Contradiction)
3651             m_state.setIsValid(false);
3652 
3653         setForNode(node, result);
3654         break;
3655     }
3656 
3657     case PutByOffset: {
3658         break;
3659     }
3660 
3661     case MultiPutByOffset: {
3662         RegisteredStructureSet newSet;
3663         TransitionVector transitions;
3664 
3665         // Ordinarily you have to be careful with calling setShouldTryConstantFolding()
3666         // because of the effect on compile times, but this node is FTL-only.
3667         m_state.setShouldTryConstantFolding(true);
3668 
3669         AbstractValue base = forNode(node-&gt;child1());
3670         AbstractValue originalValue = forNode(node-&gt;child2());
3671         AbstractValue resultingValue;
3672 
3673         if (node-&gt;multiPutByOffsetData().writesStructures())
3674             didFoldClobberStructures();
3675 
3676         for (unsigned i = node-&gt;multiPutByOffsetData().variants.size(); i--;) {
3677             const PutByIdVariant&amp; variant = node-&gt;multiPutByOffsetData().variants[i];
3678             RegisteredStructureSet thisSet = *m_graph.addStructureSet(variant.oldStructure());
3679             thisSet.filter(base);
3680             if (thisSet.isEmpty())
3681                 continue;
3682 
3683             AbstractValue thisValue = originalValue;
3684             resultingValue.merge(thisValue);
3685 
3686             if (variant.kind() == PutByIdVariant::Transition) {
3687                 RegisteredStructure newStructure = m_graph.registerStructure(variant.newStructure());
3688                 if (thisSet.onlyStructure() != newStructure) {
3689                     transitions.append(
3690                         Transition(m_graph.registerStructure(variant.oldStructureForTransition()), newStructure));
3691                 } // else this is really a replace.
3692                 newSet.add(newStructure);
3693             } else {
3694                 ASSERT(variant.kind() == PutByIdVariant::Replace);
3695                 newSet.merge(thisSet);
3696             }
3697         }
3698 
3699         // We need to order AI executing these effects in the same order as they&#39;re executed
3700         // at runtime. This is critical when you have JS code like `o.f = o;`. We first
3701         // filter types on o, then transition o. Not the other way around. If we got
3702         // this ordering wrong, we could end up with the wrong type representing o.
3703         setForNode(node-&gt;child2(), resultingValue);
3704         if (!!originalValue &amp;&amp; !resultingValue)
3705             m_state.setIsValid(false);
3706 
3707         observeTransitions(clobberLimit, transitions);
3708         if (forNode(node-&gt;child1()).changeStructure(m_graph, newSet) == Contradiction)
3709             m_state.setIsValid(false);
3710         break;
3711     }
3712 
3713     case GetExecutable: {
3714         JSValue value = forNode(node-&gt;child1()).value();
3715         if (value) {
3716             JSFunction* function = jsDynamicCast&lt;JSFunction*&gt;(m_vm, value);
3717             if (function) {
3718                 setConstant(node, *m_graph.freeze(function-&gt;executable()));
3719                 break;
3720             }
3721         }
3722         setTypeForNode(node, SpecCellOther);
3723         break;
3724     }
3725 
3726     case CheckCell: {
3727         JSValue value = forNode(node-&gt;child1()).value();
3728         if (value == node-&gt;cellOperand()-&gt;value()) {
3729             m_state.setShouldTryConstantFolding(true);
3730             ASSERT(value);
3731             break;
3732         }
3733         filterByValue(node-&gt;child1(), *node-&gt;cellOperand());
3734         break;
3735     }
3736 
3737     case AssertNotEmpty:
3738     case CheckNotEmpty: {
3739         AbstractValue&amp; value = forNode(node-&gt;child1());
3740         if (!(value.m_type &amp; SpecEmpty)) {
3741             m_state.setShouldTryConstantFolding(true);
3742             break;
3743         }
3744 
3745         filter(value, ~SpecEmpty);
3746         break;
3747     }
3748 
3749     case CheckIdent: {
3750         AbstractValue&amp; value = forNode(node-&gt;child1());
3751         UniquedStringImpl* uid = node-&gt;uidOperand();
3752 
3753         JSValue childConstant = value.value();
3754         if (childConstant) {
3755             if (childConstant.isString()) {
3756                 if (asString(childConstant)-&gt;tryGetValueImpl() == uid) {
3757                     m_state.setShouldTryConstantFolding(true);
3758                     break;
3759                 }
3760             } else if (childConstant.isSymbol()) {
3761                 if (&amp;jsCast&lt;Symbol*&gt;(childConstant)-&gt;uid() == uid) {
3762                     m_state.setShouldTryConstantFolding(true);
3763                     break;
3764                 }
3765             }
3766         }
3767 
3768         if (node-&gt;child1().useKind() == StringIdentUse)
3769             filter(value, SpecStringIdent);
3770         else
3771             filter(value, SpecSymbol);
3772         break;
3773     }
3774 
3775     case CheckInBounds: {
3776         JSValue left = forNode(node-&gt;child1()).value();
3777         JSValue right = forNode(node-&gt;child2()).value();
3778         if (left &amp;&amp; right &amp;&amp; left.isInt32() &amp;&amp; right.isInt32() &amp;&amp; static_cast&lt;uint32_t&gt;(left.asInt32()) &lt; static_cast&lt;uint32_t&gt;(right.asInt32()))
3779             m_state.setShouldTryConstantFolding(true);
3780 
3781         // We claim we result in Int32. It&#39;s not really important what our result is (though we
3782         // don&#39;t want to claim we may result in the empty value), other nodes with data flow edges
3783         // to us just do that to maintain the invariant that they can&#39;t be hoisted higher than us.
3784         // So we just arbitrarily pick Int32. In some ways, StorageResult may be the more correct
3785         // thing to do here. We pick NodeResultJS because it makes converting this to an identity
3786         // easier.
3787         setNonCellTypeForNode(node, SpecInt32Only);
3788         break;
3789     }
3790 
3791     case PutById:
3792     case PutByIdFlush:
3793     case PutByIdDirect: {
3794         AbstractValue&amp; value = forNode(node-&gt;child1());
3795         if (value.m_structure.isFinite()) {
3796             PutByIdStatus status = PutByIdStatus::computeFor(
3797                 m_graph.globalObjectFor(node-&gt;origin.semantic),
3798                 value.m_structure.toStructureSet(),
3799                 m_graph.identifiers()[node-&gt;identifierNumber()],
3800                 node-&gt;op() == PutByIdDirect);
3801 
3802             bool allGood = true;
3803             if (status.isSimple()) {
3804                 RegisteredStructureSet newSet;
3805                 TransitionVector transitions;
3806 
3807                 for (const PutByIdVariant&amp; variant : status.variants()) {
3808                     for (const ObjectPropertyCondition&amp; condition : variant.conditionSet()) {
3809                         if (!m_graph.watchCondition(condition)) {
3810                             allGood = false;
3811                             break;
3812                         }
3813                     }
3814 
3815                     if (!allGood)
3816                         break;
3817 
3818                     if (variant.kind() == PutByIdVariant::Transition) {
3819                         RegisteredStructure newStructure = m_graph.registerStructure(variant.newStructure());
3820                         transitions.append(
3821                             Transition(
3822                                 m_graph.registerStructure(variant.oldStructureForTransition()), newStructure));
3823                         newSet.add(newStructure);
3824                     } else {
3825                         ASSERT(variant.kind() == PutByIdVariant::Replace);
3826                         newSet.merge(*m_graph.addStructureSet(variant.oldStructure()));
3827                     }
3828                 }
3829 
3830                 if (status.numVariants() == 1 || m_graph.m_plan.isFTL())
3831                     m_state.setShouldTryConstantFolding(true);
3832 
3833                 if (allGood) {
3834                     didFoldClobberWorld();
3835                     observeTransitions(clobberLimit, transitions);
3836                     if (forNode(node-&gt;child1()).changeStructure(m_graph, newSet) == Contradiction)
3837                         m_state.setIsValid(false);
3838                     break;
3839                 }
3840             }
3841         }
3842 
3843         clobberWorld();
3844         break;
3845     }
3846 
3847     case PutByValWithThis:
3848     case PutByIdWithThis:
3849         clobberWorld();
3850         break;
3851 
3852     case PutGetterById:
3853     case PutSetterById:
3854     case PutGetterSetterById:
3855     case PutGetterByVal:
3856     case PutSetterByVal: {
3857         clobberWorld();
3858         break;
3859     }
3860 
3861     case DefineDataProperty:
3862     case DefineAccessorProperty:
3863         clobberWorld();
3864         break;
3865 
3866     case InById: {
3867         // FIXME: We can determine when the property definitely exists based on abstract
3868         // value information.
3869         clobberWorld();
3870         filter(node-&gt;child1(), SpecObject);
3871         setNonCellTypeForNode(node, SpecBoolean);
3872         break;
3873     }
3874 
3875     case InByVal: {
3876         AbstractValue&amp; property = forNode(node-&gt;child2());
3877         if (JSValue constant = property.value()) {
3878             if (constant.isString()) {
3879                 JSString* string = asString(constant);
3880                 const StringImpl* impl = string-&gt;tryGetValueImpl();
3881                 if (impl &amp;&amp; impl-&gt;isAtom())
3882                     m_state.setShouldTryConstantFolding(true);
3883             }
3884         }
3885 
3886         // FIXME: We can determine when the property definitely exists based on abstract
3887         // value information.
3888         clobberWorld();
3889         filter(node-&gt;child1(), SpecObject);
3890         setNonCellTypeForNode(node, SpecBoolean);
3891         break;
3892     }
3893 
3894     case HasOwnProperty: {
3895         clobberWorld();
3896         setNonCellTypeForNode(node, SpecBoolean);
3897         break;
3898     }
3899 
3900     case GetEnumerableLength: {
3901         setNonCellTypeForNode(node, SpecInt32Only);
3902         break;
3903     }
3904     case HasGenericProperty: {
3905         setNonCellTypeForNode(node, SpecBoolean);
3906         clobberWorld();
3907         break;
3908     }
3909     case HasStructureProperty: {
3910         setNonCellTypeForNode(node, SpecBoolean);
3911         clobberWorld();
3912         break;
3913     }
3914     case HasIndexedProperty: {
3915         ArrayMode mode = node-&gt;arrayMode();
3916         switch (mode.type()) {
3917         case Array::Int32:
3918         case Array::Double:
3919         case Array::Contiguous:
3920         case Array::ArrayStorage: {
3921             break;
3922         }
3923         default: {
3924             clobberWorld();
3925             break;
3926         }
3927         }
3928         setNonCellTypeForNode(node, SpecBoolean);
3929         break;
3930     }
3931     case GetDirectPname: {
3932         clobberWorld();
3933         makeHeapTopForNode(node);
3934         break;
3935     }
3936     case GetPropertyEnumerator: {
3937         setTypeForNode(node, SpecCell);
3938         clobberWorld();
3939         break;
3940     }
3941     case GetEnumeratorStructurePname: {
3942         setTypeForNode(node, SpecString | SpecOther);
3943         break;
3944     }
3945     case GetEnumeratorGenericPname: {
3946         setTypeForNode(node, SpecString | SpecOther);
3947         break;
3948     }
3949     case ToIndexString: {
3950         setTypeForNode(node, SpecString);
3951         break;
3952     }
3953 
3954     case GetGlobalVar:
3955         makeHeapTopForNode(node);
3956         break;
3957 
3958     case GetGlobalLexicalVariable:
3959         makeBytecodeTopForNode(node);
3960         break;
3961 
3962     case GetDynamicVar:
3963         clobberWorld();
3964         makeBytecodeTopForNode(node);
3965         break;
3966 
3967     case PutDynamicVar:
3968         clobberWorld();
3969         break;
3970 
3971     case ResolveScope:
3972         clobberWorld();
3973         setTypeForNode(node, SpecObject);
3974         break;
3975 
3976     case ResolveScopeForHoistingFuncDeclInEval:
3977         clobberWorld();
3978         makeBytecodeTopForNode(node);
3979         break;
3980 
3981     case PutGlobalVariable:
3982     case NotifyWrite:
3983         break;
3984 
3985     case OverridesHasInstance:
3986         setNonCellTypeForNode(node, SpecBoolean);
3987         break;
3988 
3989     case InstanceOf:
3990         clobberWorld();
3991         setNonCellTypeForNode(node, SpecBoolean);
3992         break;
3993 
3994     case InstanceOfCustom:
3995         clobberWorld();
3996         setNonCellTypeForNode(node, SpecBoolean);
3997         break;
3998 
3999     case MatchStructure: {
4000         AbstractValue base = forNode(node-&gt;child1());
4001         RegisteredStructureSet baseSet;
4002 
4003         BooleanLattice result = BooleanLattice::Bottom;
4004         for (MatchStructureVariant&amp; variant : node-&gt;matchStructureData().variants) {
4005             RegisteredStructure structure = variant.structure;
4006             if (!base.contains(structure)) {
4007                 m_state.setShouldTryConstantFolding(true);
4008                 continue;
4009             }
4010 
4011             baseSet.add(structure);
4012             result = leastUpperBoundOfBooleanLattices(
4013                 result, variant.result ? BooleanLattice::True : BooleanLattice::False);
4014         }
4015 
4016         if (forNode(node-&gt;child1()).changeStructure(m_graph, baseSet) == Contradiction)
4017             m_state.setIsValid(false);
4018 
4019         switch (result) {
4020         case BooleanLattice::False:
4021             setConstant(node, jsBoolean(false));
4022             break;
4023         case BooleanLattice::True:
4024             setConstant(node, jsBoolean(true));
4025             break;
4026         default:
4027             setNonCellTypeForNode(node, SpecBoolean);
4028             break;
4029         }
4030         break;
4031     }
4032 
4033     case Phi:
4034         RELEASE_ASSERT(m_graph.m_form == SSA);
4035         setForNode(node, forNode(NodeFlowProjection(node, NodeFlowProjection::Shadow)));
4036         // The state of this node would have already been decided, but it may have become a
4037         // constant, in which case we&#39;d like to know.
4038         if (forNode(node).m_value)
4039             m_state.setShouldTryConstantFolding(true);
4040         break;
4041 
4042     case Upsilon: {
4043         NodeFlowProjection shadow(node-&gt;phi(), NodeFlowProjection::Shadow);
4044         if (shadow.isStillValid()) {
4045             m_state.createValueForNode(shadow);
4046             setForNode(shadow, forNode(node-&gt;child1()));
4047         }
4048         break;
4049     }
4050 
4051     case Flush:
4052     case PhantomLocal:
4053         break;
4054 
4055     case Call:
4056     case TailCallInlinedCaller:
4057     case Construct:
4058     case CallVarargs:
4059     case CallForwardVarargs:
4060     case TailCallVarargsInlinedCaller:
4061     case ConstructVarargs:
4062     case ConstructForwardVarargs:
4063     case TailCallForwardVarargsInlinedCaller:
4064     case CallEval:
4065     case DirectCall:
4066     case DirectConstruct:
4067     case DirectTailCallInlinedCaller:
4068         clobberWorld();
4069         makeHeapTopForNode(node);
4070         break;
4071 
4072     case ForceOSRExit:
4073     case CheckBadCell:
4074         m_state.setIsValid(false);
4075         break;
4076 
4077     case InvalidationPoint:
4078         m_state.setStructureClobberState(StructuresAreWatched);
4079         m_state.observeInvalidationPoint();
4080         break;
4081 
4082     case CPUIntrinsic:
4083         if (node-&gt;intrinsic() == CPURdtscIntrinsic)
4084             setNonCellTypeForNode(node, SpecInt32Only);
4085         else
4086             setNonCellTypeForNode(node, SpecOther);
4087         break;
4088 
4089     case CheckTraps:
4090     case LogShadowChickenPrologue:
4091     case LogShadowChickenTail:
4092     case ProfileType:
4093     case ProfileControlFlow:
4094     case Phantom:
4095     case CountExecution:
4096     case CheckTierUpInLoop:
4097     case CheckTierUpAtReturn:
4098     case CheckNeutered:
4099     case SuperSamplerBegin:
4100     case SuperSamplerEnd:
4101     case CheckTierUpAndOSREnter:
4102     case LoopHint:
4103     case ZombieHint:
4104     case ExitOK:
4105     case FilterCallLinkStatus:
4106     case FilterGetByStatus:
4107     case FilterPutByIdStatus:
4108     case FilterInByIdStatus:
4109     case ClearCatchLocals:
4110         break;
4111 
4112     case CheckTypeInfoFlags: {
4113         const AbstractValue&amp; abstractValue = forNode(node-&gt;child1());
4114         unsigned bits = node-&gt;typeInfoOperand();
4115         ASSERT(bits);
4116         if (bits == ImplementsDefaultHasInstance) {
4117             if (abstractValue.m_type == SpecFunctionWithDefaultHasInstance) {
4118                 m_state.setShouldTryConstantFolding(true);
4119                 break;
4120             }
4121         }
4122 
4123         if (JSValue value = abstractValue.value()) {
4124             if (value.isCell()) {
4125                 // This works because if we see a cell here, we know it&#39;s fully constructed
4126                 // and we can read its inline type info flags. These flags don&#39;t change over the
4127                 // object&#39;s lifetime.
4128                 if ((value.asCell()-&gt;inlineTypeFlags() &amp; bits) == bits) {
4129                     m_state.setShouldTryConstantFolding(true);
4130                     break;
4131                 }
4132             }
4133         }
4134 
4135         if (abstractValue.m_structure.isFinite()) {
4136             bool ok = true;
4137             abstractValue.m_structure.forEach([&amp;] (RegisteredStructure structure) {
4138                 ok &amp;= (structure-&gt;typeInfo().inlineTypeFlags() &amp; bits) == bits;
4139             });
4140             if (ok) {
4141                 m_state.setShouldTryConstantFolding(true);
4142                 break;
4143             }
4144         }
4145 
4146         break;
4147     }
4148 
4149     case ParseInt: {
4150         AbstractValue value = forNode(node-&gt;child1());
4151         if (value.m_type &amp;&amp; !(value.m_type &amp; ~SpecInt32Only)) {
4152             JSValue radix;
4153             if (!node-&gt;child2())
4154                 radix = jsNumber(0);
4155             else
4156                 radix = forNode(node-&gt;child2()).m_value;
4157 
4158             if (radix.isNumber()
4159                 &amp;&amp; (radix.asNumber() == 0 || radix.asNumber() == 10)) {
4160                 m_state.setShouldTryConstantFolding(true);
4161                 if (node-&gt;child1().useKind() == UntypedUse)
4162                     didFoldClobberWorld();
4163                 setNonCellTypeForNode(node, SpecInt32Only);
4164                 break;
4165             }
4166         }
4167 
4168         if (node-&gt;child1().useKind() == UntypedUse)
4169             clobberWorld();
4170         setNonCellTypeForNode(node, SpecBytecodeNumber);
4171         break;
4172     }
4173 
4174     case CreateRest:
4175         if (!m_graph.isWatchingHavingABadTimeWatchpoint(node)) {
4176             // This means we&#39;re already having a bad time.
4177             clobberWorld();
4178             setTypeForNode(node, SpecArray);
4179             break;
4180         }
4181         setForNode(node,
4182             m_graph.globalObjectFor(node-&gt;origin.semantic)-&gt;restParameterStructure());
4183         break;
4184 
4185     case CheckVarargs:
4186     case Check: {
4187         // Simplify out checks that don&#39;t actually do checking.
4188         m_graph.doToChildren(node, [&amp;] (Edge edge) {
4189             if (!edge)
4190                 return;
4191             if (edge.isProved() || edge.willNotHaveCheck())
4192                 m_state.setShouldTryConstantFolding(true);
4193         });
4194         break;
4195     }
4196 
4197     case SetFunctionName: {
4198         clobberWorld();
4199         break;
4200     }
4201 
4202     case StoreBarrier:
4203     case FencedStoreBarrier: {
4204         filter(node-&gt;child1(), SpecCell);
4205         break;
4206     }
4207 
4208     case DataViewGetInt: {
4209         DataViewData data = node-&gt;dataViewData();
4210         if (data.byteSize &lt; 4)
4211             setNonCellTypeForNode(node, SpecInt32Only);
4212         else {
4213             ASSERT(data.byteSize == 4);
4214             if (data.isSigned)
4215                 setNonCellTypeForNode(node, SpecInt32Only);
4216             else
4217                 setNonCellTypeForNode(node, SpecInt52Any);
4218         }
4219         break;
4220     }
4221 
4222     case DataViewGetFloat: {
4223         setNonCellTypeForNode(node, SpecFullDouble);
4224         break;
4225     }
4226 
4227     case DateGetInt32OrNaN: {
4228         setNonCellTypeForNode(node, SpecInt32Only | SpecDoublePureNaN);
4229         break;
4230     }
4231 
4232     case DateGetTime: {
4233         setNonCellTypeForNode(node, SpecFullDouble);
4234         break;
4235     }
4236 
4237     case DataViewSet: {
4238         break;
4239     }
4240 
4241     case Unreachable:
4242         // It may be that during a previous run of AI we proved that something was unreachable, but
4243         // during this run of AI we forget that it&#39;s unreachable. AI&#39;s proofs don&#39;t have to get
4244         // monotonically stronger over time. So, we don&#39;t assert that AI doesn&#39;t reach the
4245         // Unreachable. We have no choice but to take our past proof at face value. Otherwise we&#39;ll
4246         // crash whenever AI fails to be as powerful on run K as it was on run K-1.
4247         m_state.setIsValid(false);
4248         break;
4249 
4250     case LastNodeType:
4251     case ArithIMul:
4252     case FiatInt52:
4253         DFG_CRASH(m_graph, node, &quot;Unexpected node type&quot;);
4254         break;
4255     }
4256 
4257     return m_state.isValid();
4258 }
4259 
4260 template&lt;typename AbstractStateType&gt;
4261 void AbstractInterpreter&lt;AbstractStateType&gt;::filterICStatus(Node* node)
4262 {
4263     switch (node-&gt;op()) {
4264     case FilterCallLinkStatus:
4265         if (JSValue value = forNode(node-&gt;child1()).m_value)
4266             node-&gt;callLinkStatus()-&gt;filter(m_vm, value);
4267         break;
4268 
4269     case FilterGetByStatus: {
4270         AbstractValue&amp; value = forNode(node-&gt;child1());
4271         if (value.m_structure.isFinite())
4272             node-&gt;getByStatus()-&gt;filter(value.m_structure.toStructureSet());
4273         break;
4274     }
4275 
4276     case FilterInByIdStatus: {
4277         AbstractValue&amp; value = forNode(node-&gt;child1());
4278         if (value.m_structure.isFinite())
4279             node-&gt;inByIdStatus()-&gt;filter(value.m_structure.toStructureSet());
4280         break;
4281     }
4282 
4283     case FilterPutByIdStatus: {
4284         AbstractValue&amp; value = forNode(node-&gt;child1());
4285         if (value.m_structure.isFinite())
4286             node-&gt;putByIdStatus()-&gt;filter(value.m_structure.toStructureSet());
4287         break;
4288     }
4289 
4290     default:
4291         RELEASE_ASSERT_NOT_REACHED();
4292         break;
4293     }
4294 }
4295 
4296 template&lt;typename AbstractStateType&gt;
4297 bool AbstractInterpreter&lt;AbstractStateType&gt;::executeEffects(unsigned indexInBlock)
4298 {
4299     return executeEffects(indexInBlock, m_state.block()-&gt;at(indexInBlock));
4300 }
4301 
4302 template&lt;typename AbstractStateType&gt;
4303 bool AbstractInterpreter&lt;AbstractStateType&gt;::execute(unsigned indexInBlock)
4304 {
4305     Node* node = m_state.block()-&gt;at(indexInBlock);
4306 
4307     startExecuting();
4308     executeEdges(node);
4309     return executeEffects(indexInBlock, node);
4310 }
4311 
4312 template&lt;typename AbstractStateType&gt;
4313 bool AbstractInterpreter&lt;AbstractStateType&gt;::execute(Node* node)
4314 {
4315     startExecuting();
4316     executeEdges(node);
4317     return executeEffects(UINT_MAX, node);
4318 }
4319 
4320 template&lt;typename AbstractStateType&gt;
4321 void AbstractInterpreter&lt;AbstractStateType&gt;::clobberWorld()
4322 {
4323     clobberStructures();
4324 }
4325 
4326 template&lt;typename AbstractStateType&gt;
4327 void AbstractInterpreter&lt;AbstractStateType&gt;::didFoldClobberWorld()
4328 {
4329     didFoldClobberStructures();
4330 }
4331 
4332 template&lt;typename AbstractStateType&gt;
4333 template&lt;typename Functor&gt;
4334 void AbstractInterpreter&lt;AbstractStateType&gt;::forAllValues(
4335     unsigned clobberLimit, Functor&amp; functor)
4336 {
4337     if (clobberLimit &gt;= m_state.block()-&gt;size())
4338         clobberLimit = m_state.block()-&gt;size();
4339     else
4340         clobberLimit++;
4341     ASSERT(clobberLimit &lt;= m_state.block()-&gt;size());
4342     for (size_t i = clobberLimit; i--;) {
4343         NodeFlowProjection::forEach(
4344             m_state.block()-&gt;at(i),
4345             [&amp;] (NodeFlowProjection nodeProjection) {
4346                 functor(forNode(nodeProjection));
4347             });
4348     }
4349     if (m_graph.m_form == SSA) {
4350         for (NodeFlowProjection node : m_state.block()-&gt;ssa-&gt;liveAtHead) {
4351             if (node.isStillValid())
4352                 functor(forNode(node));
4353         }
4354     }
4355     for (size_t i = m_state.numberOfArguments(); i--;)
4356         functor(m_state.argument(i));
4357     for (size_t i = m_state.numberOfLocals(); i--;)
4358         functor(m_state.local(i));
4359 }
4360 
4361 template&lt;typename AbstractStateType&gt;
4362 void AbstractInterpreter&lt;AbstractStateType&gt;::clobberStructures()
4363 {
4364     m_state.clobberStructures();
4365     m_state.mergeClobberState(AbstractInterpreterClobberState::ClobberedStructures);
4366     m_state.setStructureClobberState(StructuresAreClobbered);
4367 }
4368 
4369 template&lt;typename AbstractStateType&gt;
4370 void AbstractInterpreter&lt;AbstractStateType&gt;::didFoldClobberStructures()
4371 {
4372     m_state.mergeClobberState(AbstractInterpreterClobberState::FoldedClobber);
4373 }
4374 
4375 template&lt;typename AbstractStateType&gt;
4376 void AbstractInterpreter&lt;AbstractStateType&gt;::observeTransition(
4377     unsigned clobberLimit, RegisteredStructure from, RegisteredStructure to)
4378 {
4379     // Stop performing precise structure transition tracking.
4380     // Precise structure transition tracking shows quadratic complexity for # of nodes in a basic block.
4381     // If it is too large, we conservatively clobber all the structures.
4382     if (m_state.block()-&gt;size() &gt; Options::maxDFGNodesInBasicBlockForPreciseAnalysis()) {
4383         clobberStructures();
4384         return;
4385     }
4386 
4387     AbstractValue::TransitionObserver transitionObserver(from, to);
4388     forAllValues(clobberLimit, transitionObserver);
4389 
4390     ASSERT(!from-&gt;dfgShouldWatch()); // We don&#39;t need to claim to be in a clobbered state because &#39;from&#39; was never watchable (during the time we were compiling), hence no constants ever introduced into the DFG IR that ever had a watchable structure would ever have the same structure as from.
4391 
4392     m_state.mergeClobberState(AbstractInterpreterClobberState::ObservedTransitions);
4393 }
4394 
4395 template&lt;typename AbstractStateType&gt;
4396 void AbstractInterpreter&lt;AbstractStateType&gt;::observeTransitions(
4397     unsigned clobberLimit, const TransitionVector&amp; vector)
4398 {
4399     if (vector.isEmpty())
4400         return;
4401 
4402     // Stop performing precise structure transition tracking.
4403     // Precise structure transition tracking shows quadratic complexity for # of nodes in a basic block.
4404     // If it is too large, we conservatively clobber all the structures.
4405     if (m_state.block()-&gt;size() &gt; Options::maxDFGNodesInBasicBlockForPreciseAnalysis()) {
4406         clobberStructures();
4407         return;
4408     }
4409 
4410     AbstractValue::TransitionsObserver transitionsObserver(vector);
4411     forAllValues(clobberLimit, transitionsObserver);
4412 
4413     if (ASSERT_ENABLED) {
4414         // We don&#39;t need to claim to be in a clobbered state because none of the Transition::previous structures are watchable.
4415         for (unsigned i = vector.size(); i--;)
4416             ASSERT(!vector[i].previous-&gt;dfgShouldWatch());
4417     }
4418 
4419     m_state.mergeClobberState(AbstractInterpreterClobberState::ObservedTransitions);
4420 }
4421 
4422 template&lt;typename AbstractStateType&gt;
4423 void AbstractInterpreter&lt;AbstractStateType&gt;::dump(PrintStream&amp; out) const
4424 {
4425     const_cast&lt;AbstractInterpreter&lt;AbstractStateType&gt;*&gt;(this)-&gt;dump(out);
4426 }
4427 
4428 template&lt;typename AbstractStateType&gt;
4429 void AbstractInterpreter&lt;AbstractStateType&gt;::dump(PrintStream&amp; out)
4430 {
4431     CommaPrinter comma(&quot; &quot;);
4432     HashSet&lt;NodeFlowProjection&gt; seen;
4433     if (m_graph.m_form == SSA) {
4434         for (NodeFlowProjection node : m_state.block()-&gt;ssa-&gt;liveAtHead) {
4435             seen.add(node);
4436             AbstractValue&amp; value = forNode(node);
4437             if (value.isClear())
4438                 continue;
4439             out.print(comma, node, &quot;:&quot;, value);
4440         }
4441     }
4442     for (size_t i = 0; i &lt; m_state.block()-&gt;size(); ++i) {
4443         NodeFlowProjection::forEach(
4444             m_state.block()-&gt;at(i), [&amp;] (NodeFlowProjection nodeProjection) {
4445                 seen.add(nodeProjection);
4446                 AbstractValue&amp; value = forNode(nodeProjection);
4447                 if (value.isClear())
4448                     return;
4449                 out.print(comma, nodeProjection, &quot;:&quot;, value);
4450             });
4451     }
4452     if (m_graph.m_form == SSA) {
4453         for (NodeFlowProjection node : m_state.block()-&gt;ssa-&gt;liveAtTail) {
4454             if (seen.contains(node))
4455                 continue;
4456             AbstractValue&amp; value = forNode(node);
4457             if (value.isClear())
4458                 continue;
4459             out.print(comma, node, &quot;:&quot;, value);
4460         }
4461     }
4462 }
4463 
4464 template&lt;typename AbstractStateType&gt;
4465 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filter(
4466     AbstractValue&amp; value, const RegisteredStructureSet&amp; set, SpeculatedType admittedTypes)
4467 {
4468     if (value.filter(m_graph, set, admittedTypes) == FiltrationOK)
4469         return FiltrationOK;
4470     m_state.setIsValid(false);
4471     return Contradiction;
4472 }
4473 
4474 template&lt;typename AbstractStateType&gt;
4475 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filterArrayModes(
4476     AbstractValue&amp; value, ArrayModes arrayModes, SpeculatedType admittedTypes)
4477 {
4478     if (value.filterArrayModes(arrayModes, admittedTypes) == FiltrationOK)
4479         return FiltrationOK;
4480     m_state.setIsValid(false);
4481     return Contradiction;
4482 }
4483 
4484 template&lt;typename AbstractStateType&gt;
4485 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filter(
4486     AbstractValue&amp; value, SpeculatedType type)
4487 {
4488     if (value.filter(type) == FiltrationOK)
4489         return FiltrationOK;
4490     m_state.setIsValid(false);
4491     return Contradiction;
4492 }
4493 
4494 template&lt;typename AbstractStateType&gt;
4495 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filterByValue(
4496     AbstractValue&amp; abstractValue, FrozenValue concreteValue)
4497 {
4498     if (abstractValue.filterByValue(concreteValue) == FiltrationOK)
4499         return FiltrationOK;
4500     m_state.setIsValid(false);
4501     return Contradiction;
4502 }
4503 
4504 template&lt;typename AbstractStateType&gt;
4505 FiltrationResult AbstractInterpreter&lt;AbstractStateType&gt;::filterClassInfo(
4506     AbstractValue&amp; value, const ClassInfo* classInfo)
4507 {
4508     if (value.filterClassInfo(m_graph, classInfo) == FiltrationOK)
4509         return FiltrationOK;
4510     m_state.setIsValid(false);
4511     return Contradiction;
4512 }
4513 
4514 template&lt;typename AbstractStateType&gt;
4515 void AbstractInterpreter&lt;AbstractStateType&gt;::executeDoubleUnaryOpEffects(Node* node, double(*equivalentFunction)(double))
4516 {
4517     JSValue child = forNode(node-&gt;child1()).value();
4518     if (Optional&lt;double&gt; number = child.toNumberFromPrimitive()) {
4519         if (node-&gt;child1().useKind() != DoubleRepUse)
4520             didFoldClobberWorld();
4521         setConstant(node, jsDoubleNumber(equivalentFunction(*number)));
4522         return;
4523     }
4524     SpeculatedType type;
4525     if (node-&gt;child1().useKind() == DoubleRepUse)
4526         type = typeOfDoubleUnaryOp(forNode(node-&gt;child1()).m_type);
4527     else {
4528         clobberWorld();
4529         type = SpecBytecodeNumber;
4530     }
4531     setNonCellTypeForNode(node, type);
4532 }
4533 
4534 } } // namespace JSC::DFG
4535 
4536 #endif // ENABLE(DFG_JIT)
    </pre>
  </body>
</html>
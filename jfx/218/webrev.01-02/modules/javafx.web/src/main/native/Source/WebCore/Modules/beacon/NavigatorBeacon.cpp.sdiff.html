<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/beacon/NavigatorBeacon.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../applepay/paymentrequest/ApplePayPaymentHandler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../cache/CacheStorageConnection.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/beacon/NavigatorBeacon.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
104     URL parsedUrl = document.completeURL(url);
105 
106     // Set parsedUrl to the result of the URL parser steps with url and base. If the algorithm returns an error, or if
107     // parsedUrl&#39;s scheme is not &quot;http&quot; or &quot;https&quot;, throw a &quot;TypeError&quot; exception and terminate these steps.
108     if (!parsedUrl.isValid())
109         return Exception { TypeError, &quot;This URL is invalid&quot;_s };
110     if (!parsedUrl.protocolIsInHTTPFamily())
111         return Exception { TypeError, &quot;Beacons can only be sent over HTTP(S)&quot;_s };
112 
113     if (!document.frame())
114         return false;
115 
116     auto&amp; contentSecurityPolicy = *document.contentSecurityPolicy();
117     if (!document.shouldBypassMainWorldContentSecurityPolicy() &amp;&amp; !contentSecurityPolicy.allowConnectToSource(parsedUrl)) {
118         // We simulate a network error so we return true here. This is consistent with Blink.
119         return true;
120     }
121 
122     ResourceRequest request(parsedUrl);
123     request.setHTTPMethod(&quot;POST&quot;_s);
<span class="line-removed">124     request.setPriority(ResourceLoadPriority::VeryLow);</span>
125 
126     ResourceLoaderOptions options;
127     options.credentials = FetchOptions::Credentials::Include;
128     options.cache = FetchOptions::Cache::NoCache;
129     options.keepAlive = true;
130     options.sendLoadCallbacks = SendCallbackPolicy::SendCallbacks;
131 
132     if (body) {
133         options.mode = FetchOptions::Mode::Cors;
134         String mimeType;
135         auto result = FetchBody::extract(WTFMove(body.value()), mimeType);
136         if (result.hasException())
137             return result.releaseException();
138         auto fetchBody = result.releaseReturnValue();
139         if (fetchBody.hasReadableStream())
140             return Exception { TypeError, &quot;Beacons cannot send ReadableStream body&quot;_s };
141 
<span class="line-modified">142         request.setHTTPBody(fetchBody.bodyAsFormData(document));</span>
143         if (!mimeType.isEmpty()) {
144             request.setHTTPContentType(mimeType);
145             if (isCrossOriginSafeRequestHeader(HTTPHeaderName::ContentType, mimeType))
146                 options.mode = FetchOptions::Mode::NoCors;
147         }
148     }
149 
150     auto cachedResource = document.cachedResourceLoader().requestBeaconResource({ WTFMove(request), options });
151     if (!cachedResource) {
152         logError(cachedResource.error());
153         return false;
154     }
155 
156     ASSERT(!m_inflightBeacons.contains(cachedResource.value().get()));
157     m_inflightBeacons.append(cachedResource.value().get());
158     cachedResource.value()-&gt;addClient(*this);
159     return true;
160 }
161 
162 ExceptionOr&lt;bool&gt; NavigatorBeacon::sendBeacon(Navigator&amp; navigator, Document&amp; document, const String&amp; url, Optional&lt;FetchBody::Init&gt;&amp;&amp; body)
</pre>
</td>
<td>
<hr />
<pre>
104     URL parsedUrl = document.completeURL(url);
105 
106     // Set parsedUrl to the result of the URL parser steps with url and base. If the algorithm returns an error, or if
107     // parsedUrl&#39;s scheme is not &quot;http&quot; or &quot;https&quot;, throw a &quot;TypeError&quot; exception and terminate these steps.
108     if (!parsedUrl.isValid())
109         return Exception { TypeError, &quot;This URL is invalid&quot;_s };
110     if (!parsedUrl.protocolIsInHTTPFamily())
111         return Exception { TypeError, &quot;Beacons can only be sent over HTTP(S)&quot;_s };
112 
113     if (!document.frame())
114         return false;
115 
116     auto&amp; contentSecurityPolicy = *document.contentSecurityPolicy();
117     if (!document.shouldBypassMainWorldContentSecurityPolicy() &amp;&amp; !contentSecurityPolicy.allowConnectToSource(parsedUrl)) {
118         // We simulate a network error so we return true here. This is consistent with Blink.
119         return true;
120     }
121 
122     ResourceRequest request(parsedUrl);
123     request.setHTTPMethod(&quot;POST&quot;_s);

124 
125     ResourceLoaderOptions options;
126     options.credentials = FetchOptions::Credentials::Include;
127     options.cache = FetchOptions::Cache::NoCache;
128     options.keepAlive = true;
129     options.sendLoadCallbacks = SendCallbackPolicy::SendCallbacks;
130 
131     if (body) {
132         options.mode = FetchOptions::Mode::Cors;
133         String mimeType;
134         auto result = FetchBody::extract(WTFMove(body.value()), mimeType);
135         if (result.hasException())
136             return result.releaseException();
137         auto fetchBody = result.releaseReturnValue();
138         if (fetchBody.hasReadableStream())
139             return Exception { TypeError, &quot;Beacons cannot send ReadableStream body&quot;_s };
140 
<span class="line-modified">141         request.setHTTPBody(fetchBody.bodyAsFormData());</span>
142         if (!mimeType.isEmpty()) {
143             request.setHTTPContentType(mimeType);
144             if (isCrossOriginSafeRequestHeader(HTTPHeaderName::ContentType, mimeType))
145                 options.mode = FetchOptions::Mode::NoCors;
146         }
147     }
148 
149     auto cachedResource = document.cachedResourceLoader().requestBeaconResource({ WTFMove(request), options });
150     if (!cachedResource) {
151         logError(cachedResource.error());
152         return false;
153     }
154 
155     ASSERT(!m_inflightBeacons.contains(cachedResource.value().get()));
156     m_inflightBeacons.append(cachedResource.value().get());
157     cachedResource.value()-&gt;addClient(*this);
158     return true;
159 }
160 
161 ExceptionOr&lt;bool&gt; NavigatorBeacon::sendBeacon(Navigator&amp; navigator, Document&amp; document, const String&amp; url, Optional&lt;FetchBody::Init&gt;&amp;&amp; body)
</pre>
</td>
</tr>
</table>
<center><a href="../applepay/paymentrequest/ApplePayPaymentHandler.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../cache/CacheStorageConnection.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
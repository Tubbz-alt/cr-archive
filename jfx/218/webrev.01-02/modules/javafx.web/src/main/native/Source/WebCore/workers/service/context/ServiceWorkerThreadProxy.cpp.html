<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/ServiceWorkerThreadProxy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ServiceWorkerThreadProxy.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 
 31 #include &quot;CacheStorageProvider.h&quot;
 32 #include &quot;EventLoop.h&quot;
 33 #include &quot;EventNames.h&quot;
 34 #include &quot;FetchLoader.h&quot;
 35 #include &quot;Frame.h&quot;
 36 #include &quot;FrameLoader.h&quot;
 37 #include &quot;LoaderStrategy.h&quot;
 38 #include &quot;MessageWithMessagePorts.h&quot;
 39 #include &quot;PlatformStrategies.h&quot;
 40 #include &quot;ServiceWorkerClientData.h&quot;
 41 #include &quot;ServiceWorkerClientIdentifier.h&quot;
 42 #include &quot;Settings.h&quot;
 43 #include &quot;WorkerGlobalScope.h&quot;
 44 #include &lt;wtf/MainThread.h&gt;
 45 #include &lt;wtf/RunLoop.h&gt;
 46 
 47 namespace WebCore {
 48 
 49 URL static inline topOriginURL(const SecurityOrigin&amp; origin)
 50 {
 51     URL url;
 52     url.setProtocol(origin.protocol());
 53     url.setHost(origin.host());
 54     if (origin.port())
 55         url.setPort(*origin.port());
 56     return url;
 57 }
 58 
 59 static inline UniqueRef&lt;Page&gt; createPageForServiceWorker(PageConfiguration&amp;&amp; configuration, const ServiceWorkerContextData&amp; data, SecurityOrigin::StorageBlockingPolicy storageBlockingPolicy)
 60 {
 61     auto page = makeUniqueRef&lt;Page&gt;(WTFMove(configuration));
 62 
 63     auto&amp; mainFrame = page-&gt;mainFrame();
 64     mainFrame.loader().initForSynthesizedDocument({ });
 65     auto document = Document::createNonRenderedPlaceholder(mainFrame, data.scriptURL);
 66     document-&gt;createDOMWindow();
 67 
 68     document-&gt;mutableSettings().setStorageBlockingPolicy(storageBlockingPolicy);
 69     document-&gt;storageBlockingStateDidChange();
 70 
 71     auto origin = data.registration.key.topOrigin().securityOrigin();
 72     origin-&gt;setStorageBlockingPolicy(storageBlockingPolicy);
 73 
 74     document-&gt;setSiteForCookies(topOriginURL(origin));
 75     document-&gt;setFirstPartyForCookies(topOriginURL(origin));
 76     document-&gt;setDomainForCachePartition(origin-&gt;domainForCachePartition());
 77 
 78     if (auto policy = parseReferrerPolicy(data.referrerPolicy, ReferrerPolicySource::HTTPHeader))
 79         document-&gt;setReferrerPolicy(*policy);
 80 
 81     mainFrame.setDocument(WTFMove(document));
 82     return page;
 83 }
 84 
 85 static inline IDBClient::IDBConnectionProxy* idbConnectionProxy(Document&amp; document)
 86 {
 87 #if ENABLE(INDEXED_DATABASE)
 88     return document.idbConnectionProxy();
 89 #else
 90     return nullptr;
 91 #endif
 92 }
 93 
 94 static HashSet&lt;ServiceWorkerThreadProxy*&gt;&amp; allServiceWorkerThreadProxies()
 95 {
 96     static NeverDestroyed&lt;HashSet&lt;ServiceWorkerThreadProxy*&gt;&gt; set;
 97     return set;
 98 }
 99 
100 ServiceWorkerThreadProxy::ServiceWorkerThreadProxy(PageConfiguration&amp;&amp; pageConfiguration, const ServiceWorkerContextData&amp; data, String&amp;&amp; userAgent, CacheStorageProvider&amp; cacheStorageProvider, SecurityOrigin::StorageBlockingPolicy storageBlockingPolicy)
101     : m_page(createPageForServiceWorker(WTFMove(pageConfiguration), data, storageBlockingPolicy))
102     , m_document(*m_page-&gt;mainFrame().document())
103     , m_serviceWorkerThread(ServiceWorkerThread::create(data, WTFMove(userAgent), *this, *this, idbConnectionProxy(m_document), m_document-&gt;socketProvider()))
104     , m_cacheStorageProvider(cacheStorageProvider)
105     , m_inspectorProxy(*this)
106 {
107     static bool addedListener;
108     if (!addedListener) {
109         platformStrategies()-&gt;loaderStrategy()-&gt;addOnlineStateChangeListener(&amp;networkStateChanged);
110         addedListener = true;
111     }
112 
113     ASSERT(!allServiceWorkerThreadProxies().contains(this));
114     allServiceWorkerThreadProxies().add(this);
115 
116 #if ENABLE(REMOTE_INSPECTOR)
117     m_remoteDebuggable = makeUnique&lt;ServiceWorkerDebuggable&gt;(*this, data);
118     m_remoteDebuggable-&gt;setRemoteDebuggingAllowed(true);
119     m_remoteDebuggable-&gt;init();
120 #endif
121 }
122 
123 ServiceWorkerThreadProxy::~ServiceWorkerThreadProxy()
124 {
125     ASSERT(allServiceWorkerThreadProxies().contains(this));
126     allServiceWorkerThreadProxies().remove(this);
127 }
128 
129 bool ServiceWorkerThreadProxy::postTaskForModeToWorkerGlobalScope(ScriptExecutionContext::Task&amp;&amp; task, const String&amp; mode)
130 {
131     if (m_isTerminatingOrTerminated)
132         return false;
133 
134     m_serviceWorkerThread-&gt;runLoop().postTaskForMode(WTFMove(task), mode);
135     return true;
136 }
137 
138 void ServiceWorkerThreadProxy::postTaskToLoader(ScriptExecutionContext::Task&amp;&amp; task)
139 {
140     callOnMainThread([task = WTFMove(task), this, protectedThis = makeRef(*this)] () mutable {
141         task.performTask(m_document.get());
142     });
143 }
144 
145 void ServiceWorkerThreadProxy::postMessageToDebugger(const String&amp; message)
146 {
147     RunLoop::main().dispatch([this, protectedThis = makeRef(*this), message = message.isolatedCopy()] {
148         // FIXME: Handle terminated case.
149         m_inspectorProxy.sendMessageFromWorkerToFrontend(message);
150     });
151 }
152 
153 void ServiceWorkerThreadProxy::setResourceCachingDisabledByWebInspector(bool disabled)
154 {
155     postTaskToLoader([this, protectedThis = makeRef(*this), disabled] (ScriptExecutionContext&amp;) {
156         ASSERT(isMainThread());
157         m_page-&gt;setResourceCachingDisabledByWebInspector(disabled);
158     });
159 }
160 
161 Ref&lt;CacheStorageConnection&gt; ServiceWorkerThreadProxy::createCacheStorageConnection()
162 {
163     ASSERT(isMainThread());
164     if (!m_cacheStorageConnection)
165         m_cacheStorageConnection = m_cacheStorageProvider.createCacheStorageConnection();
166     return *m_cacheStorageConnection;
167 }
168 
169 std::unique_ptr&lt;FetchLoader&gt; ServiceWorkerThreadProxy::createBlobLoader(FetchLoaderClient&amp; client, const URL&amp; blobURL)
170 {
171     auto loader = makeUnique&lt;FetchLoader&gt;(client, nullptr);
172     loader-&gt;startLoadingBlobURL(m_document, blobURL);
173     if (!loader-&gt;isStarted())
174         return nullptr;
175     return loader;
176 }
177 
178 void ServiceWorkerThreadProxy::networkStateChanged(bool isOnLine)
179 {
180     for (auto* proxy : allServiceWorkerThreadProxies())
181         proxy-&gt;notifyNetworkStateChange(isOnLine);
182 }
183 
184 void ServiceWorkerThreadProxy::notifyNetworkStateChange(bool isOnline)
185 {
186     if (m_isTerminatingOrTerminated)
187         return;
188 
189     postTaskForModeToWorkerGlobalScope([isOnline] (ScriptExecutionContext&amp; context) {
190         auto&amp; globalScope = downcast&lt;WorkerGlobalScope&gt;(context);
191         globalScope.setIsOnline(isOnline);
192         globalScope.eventLoop().queueTask(TaskSource::DOMManipulation, [globalScope = makeRef(globalScope), isOnline] {
193             globalScope-&gt;dispatchEvent(Event::create(isOnline ? eventNames().onlineEvent : eventNames().offlineEvent, Event::CanBubble::No, Event::IsCancelable::No));
194         });
195     }, WorkerRunLoop::defaultMode());
196 }
197 
198 void ServiceWorkerThreadProxy::startFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier, Ref&lt;ServiceWorkerFetch::Client&gt;&amp;&amp; client, Optional&lt;ServiceWorkerClientIdentifier&gt;&amp;&amp; clientId, ResourceRequest&amp;&amp; request, String&amp;&amp; referrer, FetchOptions&amp;&amp; options)
199 {
200     auto key = std::make_pair(connectionIdentifier, fetchIdentifier);
201 
202     if (m_ongoingFetchTasks.isEmpty())
203         thread().startFetchEventMonitoring();
204 
205     ASSERT(!m_ongoingFetchTasks.contains(key));
206     m_ongoingFetchTasks.add(key, client.copyRef());
207     postTaskForModeToWorkerGlobalScope([this, protectedThis = makeRef(*this), client = WTFMove(client), clientId, request = request.isolatedCopy(), referrer = referrer.isolatedCopy(), options = options.isolatedCopy()](auto&amp;) mutable {
208         thread().queueTaskToFireFetchEvent(WTFMove(client), WTFMove(clientId), WTFMove(request), WTFMove(referrer), WTFMove(options));
209     }, WorkerRunLoop::defaultMode());
210 }
211 
212 void ServiceWorkerThreadProxy::cancelFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier)
213 {
214     auto client = m_ongoingFetchTasks.take(std::make_pair(connectionIdentifier, fetchIdentifier));
215     if (!client)
216         return;
217 
218     if (m_ongoingFetchTasks.isEmpty())
219         thread().stopFetchEventMonitoring();
220 
221     postTaskForModeToWorkerGlobalScope([client = WTFMove(client.value())] (ScriptExecutionContext&amp;) {
222         client-&gt;cancel();
223     }, WorkerRunLoop::defaultMode());
224 }
225 
226 void ServiceWorkerThreadProxy::continueDidReceiveFetchResponse(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier)
227 {
228     auto client = m_ongoingFetchTasks.get(std::make_pair(connectionIdentifier, fetchIdentifier));
229     if (!client)
230         return;
231 
232     postTaskForModeToWorkerGlobalScope([client = makeRef(*client)] (ScriptExecutionContext&amp;) {
233         client-&gt;continueDidReceiveResponse();
234     }, WorkerRunLoop::defaultMode());
235 }
236 
237 void ServiceWorkerThreadProxy::removeFetch(SWServerConnectionIdentifier connectionIdentifier, FetchIdentifier fetchIdentifier)
238 {
239     m_ongoingFetchTasks.remove(std::make_pair(connectionIdentifier, fetchIdentifier));
240 
241     if (m_ongoingFetchTasks.isEmpty())
242         thread().stopFetchEventMonitoring();
243 }
244 
245 void ServiceWorkerThreadProxy::postMessageToServiceWorker(MessageWithMessagePorts&amp;&amp; message, ServiceWorkerOrClientData&amp;&amp; sourceData)
246 {
247     thread().willPostTaskToFireMessageEvent();
248     thread().runLoop().postTask([this, protectedThis = makeRef(*this), message = WTFMove(message), sourceData = WTFMove(sourceData)](auto&amp;) mutable {
249         thread().queueTaskToPostMessage(WTFMove(message), WTFMove(sourceData));
250     });
251 }
252 
253 void ServiceWorkerThreadProxy::fireInstallEvent()
254 {
255     thread().willPostTaskToFireInstallEvent();
256     thread().runLoop().postTask([this, protectedThis = makeRef(*this)](auto&amp;) mutable {
257         thread().queueTaskToFireInstallEvent();
258     });
259 }
260 
261 void ServiceWorkerThreadProxy::fireActivateEvent()
262 {
263     thread().willPostTaskToFireActivateEvent();
264     thread().runLoop().postTask([this, protectedThis = makeRef(*this)](auto&amp;) mutable {
265         thread().queueTaskToFireActivateEvent();
266     });
267 }
268 
269 } // namespace WebCore
270 
271 #endif // ENABLE(SERVICE_WORKER)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/ftl/FTLOutput.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2013-2019 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;FTLOutput.h&quot;
 28 
 29 #if ENABLE(FTL_JIT)
 30 
 31 #include &quot;B3ArgumentRegValue.h&quot;
 32 #include &quot;B3AtomicValue.h&quot;
 33 #include &quot;B3BasicBlockInlines.h&quot;
 34 #include &quot;B3CCallValue.h&quot;
 35 #include &quot;B3Const32Value.h&quot;
 36 #include &quot;B3ConstPtrValue.h&quot;
 37 #include &quot;B3FenceValue.h&quot;
 38 #include &quot;B3MathExtras.h&quot;
 39 #include &quot;B3MemoryValue.h&quot;
 40 #include &quot;B3SlotBaseValue.h&quot;
 41 #include &quot;B3StackmapGenerationParams.h&quot;
 42 #include &quot;B3SwitchValue.h&quot;
 43 #include &quot;B3UpsilonValue.h&quot;
 44 #include &quot;B3ValueInlines.h&quot;
 45 #include &quot;SuperSampler.h&quot;
 46 
 47 namespace JSC { namespace FTL {
 48 
 49 using namespace B3;
 50 
 51 Output::Output(State&amp; state)
 52     : m_proc(*state.proc)
 53 {
 54 }
 55 
 56 Output::~Output()
 57 {
 58 }
 59 
 60 void Output::initialize(AbstractHeapRepository&amp; heaps)
 61 {
 62     m_heaps = &amp;heaps;
 63 }
 64 
 65 LBasicBlock Output::newBlock()
 66 {
 67     LBasicBlock result = m_proc.addBlock(m_frequency);
 68 
 69     if (!m_nextBlock)
 70         m_blockOrder.append(result);
 71     else
 72         m_blockOrder.insertBefore(m_nextBlock, result);
 73 
 74     return result;
 75 }
 76 
 77 void Output::applyBlockOrder()
 78 {
 79     m_proc.setBlockOrder(m_blockOrder);
 80 }
 81 
 82 LBasicBlock Output::appendTo(LBasicBlock block, LBasicBlock nextBlock)
 83 {
 84     appendTo(block);
 85     return insertNewBlocksBefore(nextBlock);
 86 }
 87 
 88 void Output::appendTo(LBasicBlock block)
 89 {
 90     m_block = block;
 91 }
 92 
 93 LValue Output::framePointer()
 94 {
 95     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::FramePointer, origin());
 96 }
 97 
 98 SlotBaseValue* Output::lockedStackSlot(size_t bytes)
 99 {
100     return m_block-&gt;appendNew&lt;SlotBaseValue&gt;(m_proc, origin(), m_proc.addStackSlot(bytes));
101 }
102 
103 LValue Output::constBool(bool value)
104 {
105     if (value)
106         return booleanTrue;
107     return booleanFalse;
108 }
109 
110 LValue Output::constInt32(int32_t value)
111 {
112     return m_block-&gt;appendNew&lt;B3::Const32Value&gt;(m_proc, origin(), value);
113 }
114 
115 LValue Output::constInt64(int64_t value)
116 {
117     return m_block-&gt;appendNew&lt;B3::Const64Value&gt;(m_proc, origin(), value);
118 }
119 
120 LValue Output::constDouble(double value)
121 {
122     return m_block-&gt;appendNew&lt;B3::ConstDoubleValue&gt;(m_proc, origin(), value);
123 }
124 
125 LValue Output::phi(LType type)
126 {
127     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Phi, type, origin());
128 }
129 
130 LValue Output::opaque(LValue value)
131 {
132     return m_block-&gt;appendNew&lt;Value&gt;(m_proc, Opaque, origin(), value);
133 }
134 
135 LValue Output::add(LValue left, LValue right)
136 {
137     if (Value* result = left-&gt;addConstant(m_proc, right)) {
138         m_block-&gt;append(result);
139         return result;
140     }
141     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Add, origin(), left, right);
142 }
143 
144 LValue Output::sub(LValue left, LValue right)
145 {
146     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Sub, origin(), left, right);
147 }
148 
149 LValue Output::mul(LValue left, LValue right)
150 {
151     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Mul, origin(), left, right);
152 }
153 
154 LValue Output::div(LValue left, LValue right)
155 {
156     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Div, origin(), left, right);
157 }
158 
159 LValue Output::chillDiv(LValue left, LValue right)
160 {
161     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, chill(B3::Div), origin(), left, right);
162 }
163 
164 LValue Output::mod(LValue left, LValue right)
165 {
166     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Mod, origin(), left, right);
167 }
168 
169 LValue Output::chillMod(LValue left, LValue right)
170 {
171     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, chill(B3::Mod), origin(), left, right);
172 }
173 
174 LValue Output::neg(LValue value)
175 {
176     return m_block-&gt;appendNew&lt;Value&gt;(m_proc, B3::Neg, origin(), value);
177 }
178 
179 LValue Output::doubleAdd(LValue left, LValue right)
180 {
181     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Add, origin(), left, right);
182 }
183 
184 LValue Output::doubleSub(LValue left, LValue right)
185 {
186     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Sub, origin(), left, right);
187 }
188 
189 LValue Output::doubleMul(LValue left, LValue right)
190 {
191     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Mul, origin(), left, right);
192 }
193 
194 LValue Output::doubleDiv(LValue left, LValue right)
195 {
196     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Div, origin(), left, right);
197 }
198 
199 LValue Output::doubleMod(LValue left, LValue right)
200 {
201     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Mod, origin(), left, right);
202 }
203 
204 LValue Output::bitAnd(LValue left, LValue right)
205 {
206     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::BitAnd, origin(), left, right);
207 }
208 
209 LValue Output::bitOr(LValue left, LValue right)
210 {
211     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::BitOr, origin(), left, right);
212 }
213 
214 LValue Output::bitXor(LValue left, LValue right)
215 {
216     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::BitXor, origin(), left, right);
217 }
218 
219 LValue Output::shl(LValue left, LValue right)
220 {
221     right = castToInt32(right);
222     if (Value* result = left-&gt;shlConstant(m_proc, right)) {
223         m_block-&gt;append(result);
224         return result;
225     }
226     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Shl, origin(), left, right);
227 }
228 
229 LValue Output::aShr(LValue left, LValue right)
230 {
231     right = castToInt32(right);
232     if (Value* result = left-&gt;sShrConstant(m_proc, right)) {
233         m_block-&gt;append(result);
234         return result;
235     }
236     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::SShr, origin(), left, right);
237 }
238 
239 LValue Output::lShr(LValue left, LValue right)
240 {
241     right = castToInt32(right);
242     if (Value* result = left-&gt;zShrConstant(m_proc, right)) {
243         m_block-&gt;append(result);
244         return result;
245     }
246     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::ZShr, origin(), left, right);
247 }
248 
249 LValue Output::bitNot(LValue value)
250 {
251     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::BitXor, origin(),
252         value,
253         m_block-&gt;appendIntConstant(m_proc, origin(), value-&gt;type(), -1));
254 }
255 
256 LValue Output::logicalNot(LValue value)
257 {
258     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Equal, origin(), value, int32Zero);
259 }
260 
261 LValue Output::ctlz32(LValue operand)
262 {
263     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Clz, origin(), operand);
264 }
265 
266 LValue Output::doubleAbs(LValue value)
267 {
268     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Abs, origin(), value);
269 }
270 
271 LValue Output::doubleCeil(LValue operand)
272 {
273     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Ceil, origin(), operand);
274 }
275 
276 LValue Output::doubleFloor(LValue operand)
277 {
278     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Floor, origin(), operand);
279 }
280 
281 LValue Output::doubleTrunc(LValue value)
282 {
283     if (MacroAssembler::supportsFloatingPointRounding()) {
284         PatchpointValue* result = patchpoint(Double);
285         result-&gt;append(value, ValueRep::SomeRegister);
286         result-&gt;setGenerator(
287             [] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
288                 jit.roundTowardZeroDouble(params[1].fpr(), params[0].fpr());
289             });
290         result-&gt;effects = Effects::none();
291         return result;
292     }
293     double (*truncDouble)(double) = trunc;
294     return callWithoutSideEffects(Double, truncDouble, value);
295 }
296 
297 LValue Output::doubleUnary(DFG::Arith::UnaryType type, LValue value)
298 {
299     double (*unaryFunction)(double) = DFG::arithUnaryFunction(type);
300     return callWithoutSideEffects(B3::Double, unaryFunction, value);
301 }
302 
303 LValue Output::doublePow(LValue xOperand, LValue yOperand)
304 {
305     double (*powDouble)(double, double) = pow;
306     return callWithoutSideEffects(B3::Double, powDouble, xOperand, yOperand);
307 }
308 
309 LValue Output::doublePowi(LValue x, LValue y)
310 {
311     // FIXME: powDoubleInt32() should be inlined here since Output knows about block layout and
312     // should be involved in any operation that creates blocks.
313     // https://bugs.webkit.org/show_bug.cgi?id=152223
314     auto result = powDoubleInt32(m_proc, m_block, origin(), x, y);
315     m_block = result.first;
316     return result.second;
317 }
318 
319 LValue Output::doubleSqrt(LValue value)
320 {
321     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Sqrt, origin(), value);
322 }
323 
324 LValue Output::doubleToInt(LValue value)
325 {
326     PatchpointValue* result = patchpoint(Int32);
327     result-&gt;append(value, ValueRep::SomeRegister);
328     result-&gt;setGenerator(
329         [] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
330             jit.truncateDoubleToInt32(params[1].fpr(), params[0].gpr());
331         });
332     result-&gt;effects = Effects::none();
333     return result;
334 }
335 
336 LValue Output::doubleToInt64(LValue value)
337 {
338     PatchpointValue* result = patchpoint(Int64);
339     result-&gt;append(value, ValueRep::SomeRegister);
340     result-&gt;setGenerator(
341         [] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
342             jit.truncateDoubleToInt64(params[1].fpr(), params[0].gpr());
343         });
344     result-&gt;effects = Effects::none();
345     return result;
346 }
347 
348 LValue Output::doubleToUInt(LValue value)
349 {
350     PatchpointValue* result = patchpoint(Int32);
351     result-&gt;append(value, ValueRep::SomeRegister);
352     result-&gt;setGenerator(
353         [] (CCallHelpers&amp; jit, const StackmapGenerationParams&amp; params) {
354             jit.truncateDoubleToUint32(params[1].fpr(), params[0].gpr());
355         });
356     result-&gt;effects = Effects::none();
357     return result;
358 }
359 
360 LValue Output::signExt32To64(LValue value)
361 {
362     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::SExt32, origin(), value);
363 }
364 
365 LValue Output::signExt32ToPtr(LValue value)
366 {
367     return signExt32To64(value);
368 }
369 
370 LValue Output::zeroExt(LValue value, LType type)
371 {
372     if (value-&gt;type() == type)
373         return value;
374     if (value-&gt;hasInt32())
375         return m_block-&gt;appendIntConstant(m_proc, origin(), Int64, static_cast&lt;uint64_t&gt;(static_cast&lt;uint32_t&gt;(value-&gt;asInt32())));
376     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::ZExt32, origin(), value);
377 }
378 
379 LValue Output::intToDouble(LValue value)
380 {
381     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::IToD, origin(), value);
382 }
383 
384 LValue Output::unsignedToDouble(LValue value)
385 {
386     return intToDouble(zeroExt(value, Int64));
387 }
388 
389 LValue Output::castToInt32(LValue value)
390 {
391     if (value-&gt;type() == Int32)
392         return value;
393     if (value-&gt;hasInt64())
394         return constInt32(static_cast&lt;int32_t&gt;(value-&gt;asInt64()));
395     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Trunc, origin(), value);
396 }
397 
398 LValue Output::doubleToFloat(LValue value)
399 {
400     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::DoubleToFloat, origin(), value);
401 }
402 
403 LValue Output::floatToDouble(LValue value)
404 {
405     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::FloatToDouble, origin(), value);
406 }
407 
408 LValue Output::load(TypedPointer pointer, LType type)
409 {
410     LValue load = m_block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load, type, origin(), pointer.value());
411     m_heaps-&gt;decorateMemory(pointer.heap(), load);
412     return load;
413 }
414 
415 LValue Output::load8SignExt32(TypedPointer pointer)
416 {
417     LValue load = m_block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load8S, Int32, origin(), pointer.value());
418     m_heaps-&gt;decorateMemory(pointer.heap(), load);
419     return load;
420 }
421 
422 LValue Output::load8ZeroExt32(TypedPointer pointer)
423 {
424     LValue load = m_block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load8Z, Int32, origin(), pointer.value());
425     m_heaps-&gt;decorateMemory(pointer.heap(), load);
426     return load;
427 }
428 
429 LValue Output::load16SignExt32(TypedPointer pointer)
430 {
431     LValue load = m_block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load16S, Int32, origin(), pointer.value());
432     m_heaps-&gt;decorateMemory(pointer.heap(), load);
433     return load;
434 }
435 
436 LValue Output::load16ZeroExt32(TypedPointer pointer)
437 {
438     LValue load = m_block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Load16Z, Int32, origin(), pointer.value());
439     m_heaps-&gt;decorateMemory(pointer.heap(), load);
440     return load;
441 }
442 
443 LValue Output::store(LValue value, TypedPointer pointer)
444 {
445     LValue store = m_block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Store, origin(), value, pointer.value());
446     m_heaps-&gt;decorateMemory(pointer.heap(), store);
447     return store;
448 }
449 
450 FenceValue* Output::fence(const AbstractHeap* read, const AbstractHeap* write)
451 {
452     FenceValue* result = m_block-&gt;appendNew&lt;FenceValue&gt;(m_proc, origin());
453     m_heaps-&gt;decorateFenceRead(read, result);
454     m_heaps-&gt;decorateFenceWrite(write, result);
455     return result;
456 }
457 
458 LValue Output::store32As8(LValue value, TypedPointer pointer)
459 {
460     LValue store = m_block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Store8, origin(), value, pointer.value());
461     m_heaps-&gt;decorateMemory(pointer.heap(), store);
462     return store;
463 }
464 
465 LValue Output::store32As16(LValue value, TypedPointer pointer)
466 {
467     LValue store = m_block-&gt;appendNew&lt;MemoryValue&gt;(m_proc, Store16, origin(), value, pointer.value());
468     m_heaps-&gt;decorateMemory(pointer.heap(), store);
469     return store;
470 }
471 
472 LValue Output::baseIndex(LValue base, LValue index, Scale scale, ptrdiff_t offset)
473 {
474     LValue accumulatedOffset;
475 
476     switch (scale) {
477     case ScaleOne:
478         accumulatedOffset = index;
479         break;
480     case ScaleTwo:
481         accumulatedOffset = shl(index, intPtrOne);
482         break;
483     case ScaleFour:
484         accumulatedOffset = shl(index, intPtrTwo);
485         break;
486     case ScaleEight:
487     case ScalePtr:
488         accumulatedOffset = shl(index, intPtrThree);
489         break;
490     }
491 
492     if (offset)
493         accumulatedOffset = add(accumulatedOffset, constIntPtr(offset));
494 
495     return add(base, accumulatedOffset);
496 }
497 
498 LValue Output::equal(LValue left, LValue right)
499 {
500     TriState result = left-&gt;equalConstant(right);
501     if (result != MixedTriState)
502         return constBool(result == TrueTriState);
503     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Equal, origin(), left, right);
504 }
505 
506 LValue Output::notEqual(LValue left, LValue right)
507 {
508     TriState result = left-&gt;notEqualConstant(right);
509     if (result != MixedTriState)
510         return constBool(result == TrueTriState);
511     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::NotEqual, origin(), left, right);
512 }
513 
514 LValue Output::above(LValue left, LValue right)
515 {
516     TriState result = left-&gt;aboveConstant(right);
517     if (result != MixedTriState)
518         return constBool(result == TrueTriState);
519     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Above, origin(), left, right);
520 }
521 
522 LValue Output::aboveOrEqual(LValue left, LValue right)
523 {
524     TriState result = left-&gt;aboveEqualConstant(right);
525     if (result != MixedTriState)
526         return constBool(result == TrueTriState);
527     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::AboveEqual, origin(), left, right);
528 }
529 
530 LValue Output::below(LValue left, LValue right)
531 {
532     TriState result = left-&gt;belowConstant(right);
533     if (result != MixedTriState)
534         return constBool(result == TrueTriState);
535     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Below, origin(), left, right);
536 }
537 
538 LValue Output::belowOrEqual(LValue left, LValue right)
539 {
540     TriState result = left-&gt;belowEqualConstant(right);
541     if (result != MixedTriState)
542         return constBool(result == TrueTriState);
543     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::BelowEqual, origin(), left, right);
544 }
545 
546 LValue Output::greaterThan(LValue left, LValue right)
547 {
548     TriState result = left-&gt;greaterThanConstant(right);
549     if (result != MixedTriState)
550         return constBool(result == TrueTriState);
551     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::GreaterThan, origin(), left, right);
552 }
553 
554 LValue Output::greaterThanOrEqual(LValue left, LValue right)
555 {
556     TriState result = left-&gt;greaterEqualConstant(right);
557     if (result != MixedTriState)
558         return constBool(result == TrueTriState);
559     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::GreaterEqual, origin(), left, right);
560 }
561 
562 LValue Output::lessThan(LValue left, LValue right)
563 {
564     TriState result = left-&gt;lessThanConstant(right);
565     if (result != MixedTriState)
566         return constBool(result == TrueTriState);
567     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::LessThan, origin(), left, right);
568 }
569 
570 LValue Output::lessThanOrEqual(LValue left, LValue right)
571 {
572     TriState result = left-&gt;lessEqualConstant(right);
573     if (result != MixedTriState)
574         return constBool(result == TrueTriState);
575     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::LessEqual, origin(), left, right);
576 }
577 
578 LValue Output::doubleEqual(LValue left, LValue right)
579 {
580     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Equal, origin(), left, right);
581 }
582 
583 LValue Output::doubleEqualOrUnordered(LValue left, LValue right)
584 {
585     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::EqualOrUnordered, origin(), left, right);
586 }
587 
588 LValue Output::doubleNotEqualOrUnordered(LValue left, LValue right)
589 {
590     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::NotEqual, origin(), left, right);
591 }
592 
593 LValue Output::doubleLessThan(LValue left, LValue right)
594 {
595     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::LessThan, origin(), left, right);
596 }
597 
598 LValue Output::doubleLessThanOrEqual(LValue left, LValue right)
599 {
600     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::LessEqual, origin(), left, right);
601 }
602 
603 LValue Output::doubleGreaterThan(LValue left, LValue right)
604 {
605     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::GreaterThan, origin(), left, right);
606 }
607 
608 LValue Output::doubleGreaterThanOrEqual(LValue left, LValue right)
609 {
610     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::GreaterEqual, origin(), left, right);
611 }
612 
613 LValue Output::doubleNotEqualAndOrdered(LValue left, LValue right)
614 {
615     return logicalNot(doubleEqualOrUnordered(left, right));
616 }
617 
618 LValue Output::doubleLessThanOrUnordered(LValue left, LValue right)
619 {
620     return logicalNot(doubleGreaterThanOrEqual(left, right));
621 }
622 
623 LValue Output::doubleLessThanOrEqualOrUnordered(LValue left, LValue right)
624 {
625     return logicalNot(doubleGreaterThan(left, right));
626 }
627 
628 LValue Output::doubleGreaterThanOrUnordered(LValue left, LValue right)
629 {
630     return logicalNot(doubleLessThanOrEqual(left, right));
631 }
632 
633 LValue Output::doubleGreaterThanOrEqualOrUnordered(LValue left, LValue right)
634 {
635     return logicalNot(doubleLessThan(left, right));
636 }
637 
638 LValue Output::isZero32(LValue value)
639 {
640     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Equal, origin(), value, int32Zero);
641 }
642 
643 LValue Output::notZero32(LValue value)
644 {
645     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::NotEqual, origin(), value, int32Zero);
646 }
647 
648 LValue Output::isZero64(LValue value)
649 {
650     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Equal, origin(), value, int64Zero);
651 }
652 
653 LValue Output::notZero64(LValue value)
654 {
655     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::NotEqual, origin(), value, int64Zero);
656 }
657 
658 LValue Output::select(LValue value, LValue left, LValue right, SelectPredictability predictability)
659 {
660     if (value-&gt;hasInt32()) {
661         if (value-&gt;asInt32())
662             return left;
663         else
664             return right;
665     }
666 
667     if (predictability == SelectPredictability::NotPredictable)
668         return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Select, origin(), value, left, right);
669 
670     LBasicBlock continuation = newBlock();
671     LBasicBlock leftTakenBlock = newBlock();
672     LBasicBlock rightTakenBlock = newBlock();
673 
674     m_block-&gt;appendNewControlValue(
675         m_proc, B3::Branch, origin(), value,
676         FrequentedBlock(leftTakenBlock, predictability != SelectPredictability::RightLikely ? FrequencyClass::Normal : FrequencyClass::Rare),
677         FrequentedBlock(rightTakenBlock, predictability != SelectPredictability::LeftLikely ? FrequencyClass::Normal : FrequencyClass::Rare));
678 
679     LValue phi = continuation-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::Phi, left-&gt;type(), origin());
680 
681     leftTakenBlock-&gt;appendNew&lt;B3::UpsilonValue&gt;(m_proc, origin(), left, phi);
682     leftTakenBlock-&gt;appendNewControlValue(m_proc, B3::Jump, origin(), B3::FrequentedBlock(continuation));
683 
684     rightTakenBlock-&gt;appendNew&lt;B3::UpsilonValue&gt;(m_proc, origin(), right, phi);
685     rightTakenBlock-&gt;appendNewControlValue(m_proc, B3::Jump, origin(), B3::FrequentedBlock(continuation));
686 
687     m_block = continuation;
688     return phi;
689 }
690 
691 LValue Output::atomicXchgAdd(LValue operand, TypedPointer pointer, Width width)
692 {
693     LValue result = m_block-&gt;appendNew&lt;AtomicValue&gt;(m_proc, AtomicXchgAdd, origin(), width, operand, pointer.value(), 0, HeapRange(), HeapRange());
694     m_heaps-&gt;decorateMemory(pointer.heap(), result);
695     return result;
696 }
697 
698 LValue Output::atomicXchgAnd(LValue operand, TypedPointer pointer, Width width)
699 {
700     LValue result = m_block-&gt;appendNew&lt;AtomicValue&gt;(m_proc, AtomicXchgAnd, origin(), width, operand, pointer.value(), 0, HeapRange(), HeapRange());
701     m_heaps-&gt;decorateMemory(pointer.heap(), result);
702     return result;
703 }
704 
705 LValue Output::atomicXchgOr(LValue operand, TypedPointer pointer, Width width)
706 {
707     LValue result = m_block-&gt;appendNew&lt;AtomicValue&gt;(m_proc, AtomicXchgOr, origin(), width, operand, pointer.value(), 0, HeapRange(), HeapRange());
708     m_heaps-&gt;decorateMemory(pointer.heap(), result);
709     return result;
710 }
711 
712 LValue Output::atomicXchgSub(LValue operand, TypedPointer pointer, Width width)
713 {
714     LValue result = m_block-&gt;appendNew&lt;AtomicValue&gt;(m_proc, AtomicXchgSub, origin(), width, operand, pointer.value(), 0, HeapRange(), HeapRange());
715     m_heaps-&gt;decorateMemory(pointer.heap(), result);
716     return result;
717 }
718 
719 LValue Output::atomicXchgXor(LValue operand, TypedPointer pointer, Width width)
720 {
721     LValue result = m_block-&gt;appendNew&lt;AtomicValue&gt;(m_proc, AtomicXchgXor, origin(), width, operand, pointer.value(), 0, HeapRange(), HeapRange());
722     m_heaps-&gt;decorateMemory(pointer.heap(), result);
723     return result;
724 }
725 
726 LValue Output::atomicXchg(LValue operand, TypedPointer pointer, Width width)
727 {
728     LValue result = m_block-&gt;appendNew&lt;AtomicValue&gt;(m_proc, AtomicXchg, origin(), width, operand, pointer.value(), 0, HeapRange(), HeapRange());
729     m_heaps-&gt;decorateMemory(pointer.heap(), result);
730     return result;
731 }
732 
733 LValue Output::atomicStrongCAS(LValue expected, LValue newValue, TypedPointer pointer, Width width)
734 {
735     LValue result = m_block-&gt;appendNew&lt;AtomicValue&gt;(m_proc, AtomicStrongCAS, origin(), width, expected, newValue, pointer.value(), 0, HeapRange(), HeapRange());
736     m_heaps-&gt;decorateMemory(pointer.heap(), result);
737     return result;
738 }
739 
740 void Output::jump(LBasicBlock destination)
741 {
742     m_block-&gt;appendNewControlValue(m_proc, B3::Jump, origin(), B3::FrequentedBlock(destination));
743 }
744 
745 void Output::branch(LValue condition, LBasicBlock taken, Weight takenWeight, LBasicBlock notTaken, Weight notTakenWeight)
746 {
747     m_block-&gt;appendNewControlValue(
748         m_proc, B3::Branch, origin(), condition,
749         FrequentedBlock(taken, takenWeight.frequencyClass()),
750         FrequentedBlock(notTaken, notTakenWeight.frequencyClass()));
751 }
752 
753 void Output::check(LValue condition, WeightedTarget taken, Weight notTakenWeight)
754 {
755     LBasicBlock continuation = newBlock();
756     branch(condition, taken, WeightedTarget(continuation, notTakenWeight));
757     appendTo(continuation);
758 }
759 
760 void Output::check(LValue condition, WeightedTarget taken)
761 {
762     check(condition, taken, taken.weight().inverse());
763 }
764 
765 void Output::ret(LValue value)
766 {
767     m_block-&gt;appendNewControlValue(m_proc, B3::Return, origin(), value);
768 }
769 
770 void Output::unreachable()
771 {
772     m_block-&gt;appendNewControlValue(m_proc, B3::Oops, origin());
773 }
774 
775 void Output::appendSuccessor(WeightedTarget target)
776 {
777     m_block-&gt;appendSuccessor(target.frequentedBlock());
778 }
779 
780 CheckValue* Output::speculate(LValue value)
781 {
782     return m_block-&gt;appendNew&lt;B3::CheckValue&gt;(m_proc, B3::Check, origin(), value);
783 }
784 
785 CheckValue* Output::speculateAdd(LValue left, LValue right)
786 {
787     return m_block-&gt;appendNew&lt;B3::CheckValue&gt;(m_proc, B3::CheckAdd, origin(), left, right);
788 }
789 
790 CheckValue* Output::speculateSub(LValue left, LValue right)
791 {
792     return m_block-&gt;appendNew&lt;B3::CheckValue&gt;(m_proc, B3::CheckSub, origin(), left, right);
793 }
794 
795 CheckValue* Output::speculateMul(LValue left, LValue right)
796 {
797     return m_block-&gt;appendNew&lt;B3::CheckValue&gt;(m_proc, B3::CheckMul, origin(), left, right);
798 }
799 
800 PatchpointValue* Output::patchpoint(LType type)
801 {
802     return m_block-&gt;appendNew&lt;B3::PatchpointValue&gt;(m_proc, type, origin());
803 }
804 
805 void Output::trap()
806 {
807     m_block-&gt;appendNewControlValue(m_proc, B3::Oops, origin());
808 }
809 
810 ValueFromBlock Output::anchor(LValue value)
811 {
812     B3::UpsilonValue* upsilon = m_block-&gt;appendNew&lt;B3::UpsilonValue&gt;(m_proc, origin(), value);
813     return ValueFromBlock(upsilon, m_block);
814 }
815 
816 LValue Output::bitCast(LValue value, LType type)
817 {
818     ASSERT_UNUSED(type, type == Int64 || type == Double);
819     return m_block-&gt;appendNew&lt;B3::Value&gt;(m_proc, B3::BitwiseCast, origin(), value);
820 }
821 
822 LValue Output::fround(LValue doubleValue)
823 {
824     return floatToDouble(doubleToFloat(doubleValue));
825 }
826 
827 LValue Output::load(TypedPointer pointer, LoadType type)
828 {
829     switch (type) {
830     case Load8SignExt32:
831         return load8SignExt32(pointer);
832     case Load8ZeroExt32:
833         return load8ZeroExt32(pointer);
834     case Load16SignExt32:
835         return load8SignExt32(pointer);
836     case Load16ZeroExt32:
837         return load8ZeroExt32(pointer);
838     case Load32:
839         return load32(pointer);
840     case Load64:
841         return load64(pointer);
842     case LoadPtr:
843         return loadPtr(pointer);
844     case LoadFloat:
845         return loadFloat(pointer);
846     case LoadDouble:
847         return loadDouble(pointer);
848     }
849     RELEASE_ASSERT_NOT_REACHED();
850     return nullptr;
851 }
852 
853 LValue Output::store(LValue value, TypedPointer pointer, StoreType type)
854 {
855     switch (type) {
856     case Store32As8:
857         return store32As8(value, pointer);
858     case Store32As16:
859         return store32As16(value, pointer);
860     case Store32:
861         return store32(value, pointer);
862     case Store64:
863         return store64(value, pointer);
864     case StorePtr:
865         return storePtr(value, pointer);
866     case StoreFloat:
867         return storeFloat(value, pointer);
868     case StoreDouble:
869         return storeDouble(value, pointer);
870     }
871     RELEASE_ASSERT_NOT_REACHED();
872     return nullptr;
873 }
874 
875 TypedPointer Output::absolute(const void* address)
876 {
877     return TypedPointer(m_heaps-&gt;absolute[address], constIntPtr(address));
878 }
879 
880 void Output::incrementSuperSamplerCount()
881 {
882     TypedPointer counter = absolute(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount));
883     store32(add(load32(counter), int32One), counter);
884 }
885 
886 void Output::decrementSuperSamplerCount()
887 {
888     TypedPointer counter = absolute(bitwise_cast&lt;void*&gt;(&amp;g_superSamplerCount));
889     store32(sub(load32(counter), int32One), counter);
890 }
891 
892 void Output::addIncomingToPhi(LValue phi, ValueFromBlock value)
893 {
894     if (value)
895         value.value()-&gt;as&lt;B3::UpsilonValue&gt;()-&gt;setPhi(phi);
896 }
897 
898 void Output::entrySwitch(const Vector&lt;LBasicBlock&gt;&amp; cases)
899 {
900     RELEASE_ASSERT(cases.size() == m_proc.numEntrypoints());
901     m_block-&gt;appendNew&lt;Value&gt;(m_proc, EntrySwitch, origin());
902     for (LBasicBlock block : cases)
903         m_block-&gt;appendSuccessor(FrequentedBlock(block));
904 }
905 
906 } } // namespace JSC::FTL
907 
908 #endif // ENABLE(FTL_JIT)
909 
    </pre>
  </body>
</html>
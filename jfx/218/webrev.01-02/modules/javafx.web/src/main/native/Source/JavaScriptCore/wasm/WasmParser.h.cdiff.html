<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmParser.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="WasmOperations.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmPlan.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/WasmParser.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 27,29 ***</span>
  
  #if ENABLE(WEBASSEMBLY)
  
  #include &quot;B3Compilation.h&quot;
  #include &quot;B3Procedure.h&quot;
  #include &quot;WasmFormat.h&quot;
  #include &quot;WasmLimits.h&quot;
  #include &quot;WasmModuleInformation.h&quot;
  #include &quot;WasmOps.h&quot;
  #include &quot;WasmSections.h&quot;
  #include &lt;type_traits&gt;
  #include &lt;wtf/Expected.h&gt;
  #include &lt;wtf/LEBDecoder.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
  #include &lt;wtf/text/WTFString.h&gt;
  #include &lt;wtf/unicode/UTF8Conversion.h&gt;
  
  namespace JSC { namespace Wasm {
  
  namespace FailureHelper {
  // FIXME We should move this to makeString. It&#39;s in its own namespace to enable C++ Argument Dependent Lookup à la std::swap: user code can deblare its own &quot;boxFailure&quot; and the fail() helper will find it.
<span class="line-modified">! static inline auto makeString(const char *failure) { return failure; }</span>
<span class="line-modified">! template &lt;typename Int, typename = typename std::enable_if&lt;std::is_integral&lt;Int&gt;::value&gt;::type&gt;</span>
<span class="line-removed">- static inline auto makeString(Int failure) { return String::number(failure); }</span>
  }
  
  template&lt;typename SuccessType&gt;
  class Parser {
  public:
<span class="line-new-header">--- 27,30 ---</span>
  
  #if ENABLE(WEBASSEMBLY)
  
  #include &quot;B3Compilation.h&quot;
  #include &quot;B3Procedure.h&quot;
<span class="line-added">+ #include &quot;VirtualRegister.h&quot;</span>
  #include &quot;WasmFormat.h&quot;
  #include &quot;WasmLimits.h&quot;
  #include &quot;WasmModuleInformation.h&quot;
  #include &quot;WasmOps.h&quot;
  #include &quot;WasmSections.h&quot;
  #include &lt;type_traits&gt;
  #include &lt;wtf/Expected.h&gt;
  #include &lt;wtf/LEBDecoder.h&gt;
  #include &lt;wtf/StdLibExtras.h&gt;
<span class="line-added">+ #include &lt;wtf/StringPrintStream.h&gt;</span>
  #include &lt;wtf/text/WTFString.h&gt;
  #include &lt;wtf/unicode/UTF8Conversion.h&gt;
  
  namespace JSC { namespace Wasm {
  
  namespace FailureHelper {
  // FIXME We should move this to makeString. It&#39;s in its own namespace to enable C++ Argument Dependent Lookup à la std::swap: user code can deblare its own &quot;boxFailure&quot; and the fail() helper will find it.
<span class="line-modified">! template&lt;typename T&gt;</span>
<span class="line-modified">! inline String makeString(const T&amp; failure) { return WTF::toString(failure); }</span>
  }
  
  template&lt;typename SuccessType&gt;
  class Parser {
  public:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 69,21 ***</span>
      bool WARN_UNUSED_RETURN consumeString(const char*);
      bool WARN_UNUSED_RETURN consumeUTF8String(Name&amp;, size_t);
  
      bool WARN_UNUSED_RETURN parseVarUInt1(uint8_t&amp;);
      bool WARN_UNUSED_RETURN parseInt7(int8_t&amp;);
      bool WARN_UNUSED_RETURN parseUInt7(uint8_t&amp;);
      bool WARN_UNUSED_RETURN parseUInt8(uint8_t&amp;);
      bool WARN_UNUSED_RETURN parseUInt32(uint32_t&amp;);
      bool WARN_UNUSED_RETURN parseUInt64(uint64_t&amp;);
      bool WARN_UNUSED_RETURN parseVarUInt32(uint32_t&amp;);
      bool WARN_UNUSED_RETURN parseVarUInt64(uint64_t&amp;);
  
      bool WARN_UNUSED_RETURN parseVarInt32(int32_t&amp;);
      bool WARN_UNUSED_RETURN parseVarInt64(int64_t&amp;);
  
<span class="line-modified">!     bool WARN_UNUSED_RETURN parseResultType(Type&amp;);</span>
      bool WARN_UNUSED_RETURN parseValueType(Type&amp;);
      bool WARN_UNUSED_RETURN parseExternalKind(ExternalKind&amp;);
  
      size_t m_offset = 0;
  
<span class="line-new-header">--- 70,22 ---</span>
      bool WARN_UNUSED_RETURN consumeString(const char*);
      bool WARN_UNUSED_RETURN consumeUTF8String(Name&amp;, size_t);
  
      bool WARN_UNUSED_RETURN parseVarUInt1(uint8_t&amp;);
      bool WARN_UNUSED_RETURN parseInt7(int8_t&amp;);
<span class="line-added">+     bool WARN_UNUSED_RETURN peekInt7(int8_t&amp;);</span>
      bool WARN_UNUSED_RETURN parseUInt7(uint8_t&amp;);
      bool WARN_UNUSED_RETURN parseUInt8(uint8_t&amp;);
      bool WARN_UNUSED_RETURN parseUInt32(uint32_t&amp;);
      bool WARN_UNUSED_RETURN parseUInt64(uint64_t&amp;);
      bool WARN_UNUSED_RETURN parseVarUInt32(uint32_t&amp;);
      bool WARN_UNUSED_RETURN parseVarUInt64(uint64_t&amp;);
  
      bool WARN_UNUSED_RETURN parseVarInt32(int32_t&amp;);
      bool WARN_UNUSED_RETURN parseVarInt64(int64_t&amp;);
  
<span class="line-modified">!     PartialResult WARN_UNUSED_RETURN parseBlockSignature(const ModuleInformation&amp;, BlockSignature&amp;);</span>
      bool WARN_UNUSED_RETURN parseValueType(Type&amp;);
      bool WARN_UNUSED_RETURN parseExternalKind(ExternalKind&amp;);
  
      size_t m_offset = 0;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 105,16 ***</span>
<span class="line-new-header">--- 107,19 ---</span>
      } while (0)
  
  private:
      const uint8_t* m_source;
      size_t m_sourceLength;
<span class="line-added">+     // We keep a local reference to the global table so we don&#39;t have to fetch it to find thunk signatures.</span>
<span class="line-added">+     const SignatureInformation&amp; m_signatureInformation;</span>
  };
  
  template&lt;typename SuccessType&gt;
  ALWAYS_INLINE Parser&lt;SuccessType&gt;::Parser(const uint8_t* sourceBuffer, size_t sourceLength)
      : m_source(sourceBuffer)
      , m_sourceLength(sourceLength)
<span class="line-added">+     , m_signatureInformation(SignatureInformation::singleton())</span>
  {
  }
  
  template&lt;typename SuccessType&gt;
  ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::consumeCharacter(char c)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 233,10 ***</span>
<span class="line-new-header">--- 238,20 ---</span>
      uint8_t v = source()[m_offset++];
      result = (v &amp; 0x40) ? WTF::bitwise_cast&lt;int8_t&gt;(uint8_t(v | 0x80)) : v;
      return (v &amp; 0x80) == 0;
  }
  
<span class="line-added">+ template&lt;typename SuccessType&gt;</span>
<span class="line-added">+ ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::peekInt7(int8_t&amp; result)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     if (m_offset &gt;= length())</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     uint8_t v = source()[m_offset];</span>
<span class="line-added">+     result = (v &amp; 0x40) ? WTF::bitwise_cast&lt;int8_t&gt;(uint8_t(v | 0x80)) : v;</span>
<span class="line-added">+     return (v &amp; 0x80) == 0;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  template&lt;typename SuccessType&gt;
  ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseUInt7(uint8_t&amp; result)
  {
      if (m_offset &gt;= length())
          return false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 255,25 ***</span>
      result = static_cast&lt;uint8_t&gt;(temp);
      return true;
  }
  
  template&lt;typename SuccessType&gt;
<span class="line-modified">! ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseResultType(Type&amp; result)</span>
  {
      int8_t value;
<span class="line-modified">!     if (!parseInt7(value))</span>
<span class="line-modified">!         return false;</span>
<span class="line-modified">!     if (!isValidType(value))</span>
<span class="line-modified">!         return false;</span>
<span class="line-modified">!     result = static_cast&lt;Type&gt;(value);</span>
<span class="line-modified">!     return true;</span>
  }
  
  template&lt;typename SuccessType&gt;
  ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseValueType(Type&amp; result)
  {
<span class="line-modified">!     return parseResultType(result) &amp;&amp; isValueType(result);</span>
  }
  
  template&lt;typename SuccessType&gt;
  ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseExternalKind(ExternalKind&amp; result)
  {
<span class="line-new-header">--- 270,42 ---</span>
      result = static_cast&lt;uint8_t&gt;(temp);
      return true;
  }
  
  template&lt;typename SuccessType&gt;
<span class="line-modified">! ALWAYS_INLINE typename Parser&lt;SuccessType&gt;::PartialResult Parser&lt;SuccessType&gt;::parseBlockSignature(const ModuleInformation&amp; info, BlockSignature&amp; result)</span>
  {
      int8_t value;
<span class="line-modified">!     if (peekInt7(value) &amp;&amp; isValidType(value)) {</span>
<span class="line-modified">!         Type type = static_cast&lt;Type&gt;(value);</span>
<span class="line-modified">!         WASM_PARSER_FAIL_IF(!(isValueType(type) || type == Void), &quot;result type of block: &quot;, makeString(type), &quot; is not a value type or Void&quot;);</span>
<span class="line-modified">!         result = m_signatureInformation.thunkFor(type);</span>
<span class="line-modified">!         m_offset++;</span>
<span class="line-modified">!         return { };</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     WASM_PARSER_FAIL_IF(!Options::useWebAssemblyMultiValues(), &quot;Type table indices for block signatures are not supported yet&quot;);</span>
<span class="line-added">+ </span>
<span class="line-added">+     int64_t index;</span>
<span class="line-added">+     WASM_PARSER_FAIL_IF(!parseVarInt64(index), &quot;Block-like instruction doesn&#39;t return value type but can&#39;t decode type section index&quot;);</span>
<span class="line-added">+     WASM_PARSER_FAIL_IF(index &lt; 0, &quot;Block-like instruction signature index is negative&quot;);</span>
<span class="line-added">+     WASM_PARSER_FAIL_IF(static_cast&lt;size_t&gt;(index) &gt;= info.usedSignatures.size(), &quot;Block-like instruction signature index is out of bounds. Index: &quot;, index, &quot; type index space: &quot;, info.usedSignatures.size());</span>
<span class="line-added">+ </span>
<span class="line-added">+     result = &amp;info.usedSignatures[index].get();</span>
<span class="line-added">+     return { };</span>
  }
  
  template&lt;typename SuccessType&gt;
  ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseValueType(Type&amp; result)
  {
<span class="line-modified">!     int8_t value;</span>
<span class="line-added">+     if (!parseInt7(value))</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     if (!isValidType(value) || !isValueType(static_cast&lt;Type&gt;(value)))</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+     result = static_cast&lt;Type&gt;(value);</span>
<span class="line-added">+     return true;</span>
  }
  
  template&lt;typename SuccessType&gt;
  ALWAYS_INLINE bool Parser&lt;SuccessType&gt;::parseExternalKind(ExternalKind&amp; result)
  {
</pre>
<center><a href="WasmOperations.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="WasmPlan.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
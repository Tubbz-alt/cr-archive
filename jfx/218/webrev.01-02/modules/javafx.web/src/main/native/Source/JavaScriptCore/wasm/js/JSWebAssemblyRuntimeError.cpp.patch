diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssemblyRuntimeError.cpp b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssemblyRuntimeError.cpp
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssemblyRuntimeError.cpp
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/wasm/js/JSWebAssemblyRuntimeError.cpp
@@ -30,31 +30,30 @@
 
 #include "JSCInlines.h"
 
 namespace JSC {
 
-JSWebAssemblyRuntimeError* JSWebAssemblyRuntimeError::create(ExecState* exec, VM& vm, Structure* structure, const String& message)
+JSWebAssemblyRuntimeError* JSWebAssemblyRuntimeError::create(JSGlobalObject* globalObject, VM& vm, Structure* structure, const String& message)
 {
     auto* instance = new (NotNull, allocateCell<JSWebAssemblyRuntimeError>(vm.heap)) JSWebAssemblyRuntimeError(vm, structure);
     instance->m_sourceAppender = defaultSourceAppender;
     bool useCurrentFrame = true;
-    instance->finishCreation(exec, vm, message, useCurrentFrame);
+    instance->finishCreation(globalObject, vm, message, useCurrentFrame);
     return instance;
 }
 
 JSWebAssemblyRuntimeError::JSWebAssemblyRuntimeError(VM& vm, Structure* structure)
     : Base(vm, structure)
 {
 }
 
 const ClassInfo JSWebAssemblyRuntimeError::s_info = { "WebAssembly.RuntimeError", &Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSWebAssemblyRuntimeError) };
 
-JSObject* createJSWebAssemblyRuntimeError(ExecState* exec, VM& vm, const String& message)
+JSObject* createJSWebAssemblyRuntimeError(JSGlobalObject* globalObject, VM& vm, const String& message)
 {
     ASSERT(!message.isEmpty());
-    JSGlobalObject* globalObject = exec->lexicalGlobalObject();
-    return JSWebAssemblyRuntimeError::create(exec, vm, globalObject->webAssemblyRuntimeErrorStructure(), message);
+    return JSWebAssemblyRuntimeError::create(globalObject, vm, globalObject->webAssemblyRuntimeErrorStructure(), message);
 }
 
 } // namespace JSC
 
 #endif // ENABLE(WEBASSEMBLY)

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSPluginElementFunctions.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSPerformanceEntryCustom.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSPluginElementFunctions.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSPluginElementFunctions.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 63,11 ***</span>
  
      HTMLPlugInElement&amp; pluginElement = downcast&lt;HTMLPlugInElement&gt;(element);
      return pluginScriptObjectFromPluginViewBase(pluginElement, jsHTMLElement-&gt;globalObject());
  }
  
<span class="line-modified">! JSObject* pluginScriptObject(ExecState* exec, JSHTMLElement* jsHTMLElement)</span>
  {
      HTMLElement&amp; element = jsHTMLElement-&gt;wrapped();
      if (!is&lt;HTMLPlugInElement&gt;(element))
          return nullptr;
  
<span class="line-new-header">--- 63,11 ---</span>
  
      HTMLPlugInElement&amp; pluginElement = downcast&lt;HTMLPlugInElement&gt;(element);
      return pluginScriptObjectFromPluginViewBase(pluginElement, jsHTMLElement-&gt;globalObject());
  }
  
<span class="line-modified">! JSObject* pluginScriptObject(JSGlobalObject* lexicalGlobalObject, JSHTMLElement* jsHTMLElement)</span>
  {
      HTMLElement&amp; element = jsHTMLElement-&gt;wrapped();
      if (!is&lt;HTMLPlugInElement&gt;(element))
          return nullptr;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 89,78 ***</span>
      // The plugin element holds an owning reference, so we don&#39;t have to.
      auto* instance = pluginElement.bindingsInstance();
      if (!instance || !instance-&gt;rootObject())
          return nullptr;
  
<span class="line-modified">!     return instance-&gt;createRuntimeObject(exec);</span>
  }
  
<span class="line-modified">! static EncodedJSValue pluginElementPropertyGetter(ExecState* exec, EncodedJSValue thisValue, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = exec-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSHTMLElement* thisObject = jsDynamicCast&lt;JSHTMLElement*&gt;(vm, JSValue::decode(thisValue));
      if (!thisObject)
<span class="line-modified">!         return throwVMTypeError(exec, scope);</span>
<span class="line-modified">!     JSObject* scriptObject = pluginScriptObject(exec, thisObject);</span>
      if (!scriptObject)
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     return JSValue::encode(scriptObject-&gt;get(exec, propertyName));</span>
  }
  
<span class="line-modified">! bool pluginElementCustomGetOwnPropertySlot(JSHTMLElement* element, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      if (!element-&gt;globalObject()-&gt;world().isNormal()) {
<span class="line-modified">!         JSC::JSValue proto = element-&gt;getPrototypeDirect(exec-&gt;vm());</span>
<span class="line-modified">!         if (proto.isObject() &amp;&amp; JSC::jsCast&lt;JSC::JSObject*&gt;(asObject(proto))-&gt;hasProperty(exec, propertyName))</span>
              return false;
      }
  
<span class="line-modified">!     JSObject* scriptObject = pluginScriptObject(exec, element);</span>
      if (!scriptObject)
          return false;
  
<span class="line-modified">!     if (!scriptObject-&gt;hasProperty(exec, propertyName))</span>
          return false;
  
      slot.setCustom(element, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum, pluginElementPropertyGetter);
      return true;
  }
  
<span class="line-modified">! bool pluginElementCustomPut(JSHTMLElement* element, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot, bool&amp; putResult)</span>
  {
<span class="line-modified">!     JSObject* scriptObject = pluginScriptObject(exec, element);</span>
      if (!scriptObject)
          return false;
<span class="line-modified">!     if (!scriptObject-&gt;hasProperty(exec, propertyName))</span>
          return false;
<span class="line-modified">!     putResult = scriptObject-&gt;methodTable(exec-&gt;vm())-&gt;put(scriptObject, exec, propertyName, value, slot);</span>
      return true;
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL callPlugin(ExecState* exec)</span>
  {
<span class="line-modified">!     JSHTMLElement* element = jsCast&lt;JSHTMLElement*&gt;(exec-&gt;jsCallee());</span>
  
      // Get the plug-in script object.
<span class="line-modified">!     JSObject* scriptObject = pluginScriptObject(exec, element);</span>
      ASSERT(scriptObject);
  
<span class="line-modified">!     size_t argumentCount = exec-&gt;argumentCount();</span>
      MarkedArgumentBuffer argumentList;
      for (size_t i = 0; i &lt; argumentCount; i++)
<span class="line-modified">!         argumentList.append(exec-&gt;argument(i));</span>
      ASSERT(!argumentList.hasOverflowed());
  
      CallData callData;
<span class="line-modified">!     CallType callType = getCallData(exec-&gt;vm(), scriptObject, callData);</span>
      ASSERT(callType == CallType::Host);
  
      // Call the object.
<span class="line-modified">!     JSValue result = call(exec, scriptObject, callType, callData, exec-&gt;thisValue(), argumentList);</span>
      return JSValue::encode(result);
  }
  
  CallType pluginElementCustomGetCallData(JSHTMLElement* element, CallData&amp; callData)
  {
<span class="line-new-header">--- 89,78 ---</span>
      // The plugin element holds an owning reference, so we don&#39;t have to.
      auto* instance = pluginElement.bindingsInstance();
      if (!instance || !instance-&gt;rootObject())
          return nullptr;
  
<span class="line-modified">!     return instance-&gt;createRuntimeObject(lexicalGlobalObject);</span>
  }
  
<span class="line-modified">! static EncodedJSValue pluginElementPropertyGetter(JSGlobalObject* lexicalGlobalObject, EncodedJSValue thisValue, PropertyName propertyName)</span>
  {
<span class="line-modified">!     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
      JSHTMLElement* thisObject = jsDynamicCast&lt;JSHTMLElement*&gt;(vm, JSValue::decode(thisValue));
      if (!thisObject)
<span class="line-modified">!         return throwVMTypeError(lexicalGlobalObject, scope);</span>
<span class="line-modified">!     JSObject* scriptObject = pluginScriptObject(lexicalGlobalObject, thisObject);</span>
      if (!scriptObject)
          return JSValue::encode(jsUndefined());
  
<span class="line-modified">!     return JSValue::encode(scriptObject-&gt;get(lexicalGlobalObject, propertyName));</span>
  }
  
<span class="line-modified">! bool pluginElementCustomGetOwnPropertySlot(JSHTMLElement* element, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
  {
      if (!element-&gt;globalObject()-&gt;world().isNormal()) {
<span class="line-modified">!         JSC::JSValue proto = element-&gt;getPrototypeDirect(lexicalGlobalObject-&gt;vm());</span>
<span class="line-modified">!         if (proto.isObject() &amp;&amp; JSC::jsCast&lt;JSC::JSObject*&gt;(asObject(proto))-&gt;hasProperty(lexicalGlobalObject, propertyName))</span>
              return false;
      }
  
<span class="line-modified">!     JSObject* scriptObject = pluginScriptObject(lexicalGlobalObject, element);</span>
      if (!scriptObject)
          return false;
  
<span class="line-modified">!     if (!scriptObject-&gt;hasProperty(lexicalGlobalObject, propertyName))</span>
          return false;
  
      slot.setCustom(element, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum, pluginElementPropertyGetter);
      return true;
  }
  
<span class="line-modified">! bool pluginElementCustomPut(JSHTMLElement* element, JSGlobalObject* lexicalGlobalObject, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot, bool&amp; putResult)</span>
  {
<span class="line-modified">!     JSObject* scriptObject = pluginScriptObject(lexicalGlobalObject, element);</span>
      if (!scriptObject)
          return false;
<span class="line-modified">!     if (!scriptObject-&gt;hasProperty(lexicalGlobalObject, propertyName))</span>
          return false;
<span class="line-modified">!     putResult = scriptObject-&gt;methodTable(lexicalGlobalObject-&gt;vm())-&gt;put(scriptObject, lexicalGlobalObject, propertyName, value, slot);</span>
      return true;
  }
  
<span class="line-modified">! static EncodedJSValue JSC_HOST_CALL callPlugin(JSGlobalObject* lexicalGlobalObject, CallFrame* callFrame)</span>
  {
<span class="line-modified">!     JSHTMLElement* element = jsCast&lt;JSHTMLElement*&gt;(callFrame-&gt;jsCallee());</span>
  
      // Get the plug-in script object.
<span class="line-modified">!     JSObject* scriptObject = pluginScriptObject(lexicalGlobalObject, element);</span>
      ASSERT(scriptObject);
  
<span class="line-modified">!     size_t argumentCount = callFrame-&gt;argumentCount();</span>
      MarkedArgumentBuffer argumentList;
      for (size_t i = 0; i &lt; argumentCount; i++)
<span class="line-modified">!         argumentList.append(callFrame-&gt;argument(i));</span>
      ASSERT(!argumentList.hasOverflowed());
  
      CallData callData;
<span class="line-modified">!     CallType callType = getCallData(lexicalGlobalObject-&gt;vm(), scriptObject, callData);</span>
      ASSERT(callType == CallType::Host);
  
      // Call the object.
<span class="line-modified">!     JSValue result = call(lexicalGlobalObject, scriptObject, callType, callData, callFrame-&gt;thisValue(), argumentList);</span>
      return JSValue::encode(result);
  }
  
  CallType pluginElementCustomGetCallData(JSHTMLElement* element, CallData&amp; callData)
  {
</pre>
<center><a href="JSPerformanceEntryCustom.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="JSPluginElementFunctions.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
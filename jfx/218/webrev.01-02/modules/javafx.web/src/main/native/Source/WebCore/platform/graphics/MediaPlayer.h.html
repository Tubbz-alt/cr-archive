<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/MediaPlayer.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2007-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(VIDEO)
 29 
 30 #include &quot;AudioTrackPrivate.h&quot;
 31 #include &quot;ContentType.h&quot;
 32 #include &quot;GraphicsTypesGL.h&quot;
 33 #include &quot;LayoutRect.h&quot;
 34 #include &quot;LegacyCDMSession.h&quot;
 35 #include &quot;MediaPlayerEnums.h&quot;
 36 #include &quot;NativeImage.h&quot;
 37 #include &quot;PlatformLayer.h&quot;
 38 #include &quot;PlatformMediaResourceLoader.h&quot;
 39 #include &quot;PlatformMediaSession.h&quot;
 40 #include &quot;SecurityOriginHash.h&quot;
 41 #include &quot;Timer.h&quot;
 42 #include &lt;wtf/URL.h&gt;
 43 #include &quot;VideoTrackPrivate.h&quot;
 44 #include &lt;JavaScriptCore/Uint8Array.h&gt;
 45 #include &lt;wtf/Function.h&gt;
 46 #include &lt;wtf/HashSet.h&gt;
 47 #include &lt;wtf/Logger.h&gt;
 48 #include &lt;wtf/MediaTime.h&gt;
 49 #include &lt;wtf/WallTime.h&gt;
 50 #include &lt;wtf/text/StringHash.h&gt;
 51 
 52 #if ENABLE(AVF_CAPTIONS)
 53 #include &quot;PlatformTextTrack.h&quot;
 54 #endif
 55 
 56 OBJC_CLASS AVPlayer;
 57 OBJC_CLASS NSArray;
 58 
 59 namespace WebCore {
 60 
 61 class AudioSourceProvider;
 62 class CDMInstance;
 63 class CachedResourceLoader;
 64 class GraphicsContextGLOpenGL;
 65 class GraphicsContext;
 66 class InbandTextTrackPrivate;
 67 class LegacyCDMSessionClient;
 68 class MediaPlaybackTarget;
 69 class MediaPlayer;
 70 class MediaPlayerFactory;
 71 class MediaPlayerPrivateInterface;
 72 class MediaPlayerRequestInstallMissingPluginsCallback;
 73 class MediaSourcePrivateClient;
 74 class MediaStreamPrivate;
 75 class PlatformTimeRanges;
 76 class TextTrackRepresentation;
 77 
 78 struct Cookie;
 79 struct GraphicsDeviceAdapter;
 80 
 81 struct MediaEngineSupportParameters {
 82     ContentType type;
 83     URL url;
 84     bool isMediaSource { false };
 85     bool isMediaStream { false };
 86     Vector&lt;ContentType&gt; contentTypesRequiringHardwareSupport;
 87 
 88     template&lt;class Encoder&gt;
 89     void encode(Encoder&amp; encoder) const
 90     {
 91         encoder &lt;&lt; type;
 92         encoder &lt;&lt; url;
 93         encoder &lt;&lt; isMediaSource;
 94         encoder &lt;&lt; isMediaStream;
 95         encoder &lt;&lt; contentTypesRequiringHardwareSupport;
 96     }
 97 
 98     template &lt;class Decoder&gt;
 99     static Optional&lt;MediaEngineSupportParameters&gt; decode(Decoder&amp; decoder)
100     {
101         Optional&lt;ContentType&gt; type;
102         decoder &gt;&gt; type;
103         if (!type)
104             return WTF::nullopt;
105 
106         Optional&lt;URL&gt; url;
107         decoder &gt;&gt; url;
108         if (!url)
109             return WTF::nullopt;
110 
111         Optional&lt;bool&gt; isMediaSource;
112         decoder &gt;&gt; isMediaSource;
113         if (!isMediaSource)
114             return WTF::nullopt;
115 
116         Optional&lt;bool&gt; isMediaStream;
117         decoder &gt;&gt; isMediaStream;
118         if (!isMediaStream)
119             return WTF::nullopt;
120 
121         Optional&lt;Vector&lt;ContentType&gt;&gt; typesRequiringHardware;
122         decoder &gt;&gt; typesRequiringHardware;
123         if (!typesRequiringHardware)
124             return WTF::nullopt;
125 
126         return {{ WTFMove(*type), WTFMove(*url), *isMediaSource, *isMediaStream, *typesRequiringHardware }};
127     }
128 };
129 
130 struct VideoPlaybackQualityMetrics {
131     uint32_t totalVideoFrames { 0 };
132     uint32_t droppedVideoFrames { 0 };
133     uint32_t corruptedVideoFrames { 0 };
134     double totalFrameDelay { 0 };
135     uint32_t displayCompositedVideoFrames { 0 };
136 };
137 
138 class MediaPlayerClient {
139 public:
140     virtual ~MediaPlayerClient() = default;
141 
142     // the network state has changed
143     virtual void mediaPlayerNetworkStateChanged() { }
144 
145     // the ready state has changed
146     virtual void mediaPlayerReadyStateChanged() { }
147 
148     // the volume state has changed
149     virtual void mediaPlayerVolumeChanged() { }
150 
151     // the mute state has changed
152     virtual void mediaPlayerMuteChanged() { }
153 
154     // time has jumped, eg. not as a result of normal playback
155     virtual void mediaPlayerTimeChanged() { }
156 
157     // the media file duration has changed, or is now known
158     virtual void mediaPlayerDurationChanged() { }
159 
160     // the playback rate has changed
161     virtual void mediaPlayerRateChanged() { }
162 
163     // the play/pause status changed
164     virtual void mediaPlayerPlaybackStateChanged() { }
165 
166     // The MediaPlayer could not discover an engine which supports the requested resource.
167     virtual void mediaPlayerResourceNotSupported() { }
168 
169 // Presentation-related methods
170     // a new frame of video is available
171     virtual void mediaPlayerRepaint() { }
172 
173     // the movie size has changed
174     virtual void mediaPlayerSizeChanged() { }
175 
176     virtual void mediaPlayerEngineUpdated() { }
177 
178     // The first frame of video is available to render. A media engine need only make this callback if the
179     // first frame is not available immediately when prepareForRendering is called.
180     virtual void mediaPlayerFirstVideoFrameAvailable() { }
181 
182     // A characteristic of the media file, eg. video, audio, closed captions, etc, has changed.
183     virtual void mediaPlayerCharacteristicChanged() { }
184 
185     // whether the rendering system can accelerate the display of this MediaPlayer.
186     virtual bool mediaPlayerRenderingCanBeAccelerated() { return false; }
187 
188     // called when the media player&#39;s rendering mode changed, which indicates a change in the
189     // availability of the platformLayer().
190     virtual void mediaPlayerRenderingModeChanged() { }
191 
192     // whether accelerated compositing is enabled for video rendering
193     virtual bool mediaPlayerAcceleratedCompositingEnabled() { return false; }
194 
195     virtual void mediaPlayerActiveSourceBuffersChanged() { }
196 
197 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
198     virtual GraphicsDeviceAdapter* mediaPlayerGraphicsDeviceAdapter() const { return nullptr; }
199 #endif
200 
201 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
202     virtual RefPtr&lt;ArrayBuffer&gt; mediaPlayerCachedKeyForKeyId(const String&amp;) const { return nullptr; }
203     virtual bool mediaPlayerKeyNeeded(Uint8Array*) { return false; }
204     virtual String mediaPlayerMediaKeysStorageDirectory() const { return emptyString(); }
205 #endif
206 
207 #if ENABLE(ENCRYPTED_MEDIA)
208     virtual void mediaPlayerInitializationDataEncountered(const String&amp;, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;) { }
209     virtual void mediaPlayerWaitingForKeyChanged() { }
210 #endif
211 
212 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
213     virtual void mediaPlayerCurrentPlaybackTargetIsWirelessChanged(bool) { };
214 #endif
215 
216     virtual String mediaPlayerReferrer() const { return String(); }
217     virtual String mediaPlayerUserAgent() const { return String(); }
218     virtual void mediaPlayerEnterFullscreen() { }
219     virtual void mediaPlayerExitFullscreen() { }
220     virtual bool mediaPlayerIsFullscreen() const { return false; }
221     virtual bool mediaPlayerIsFullscreenPermitted() const { return false; }
222     virtual bool mediaPlayerIsVideo() const { return false; }
223     virtual LayoutRect mediaPlayerContentBoxRect() const { return LayoutRect(); }
224     virtual float mediaPlayerContentsScale() const { return 1; }
225     virtual void mediaPlayerPause() { }
226     virtual void mediaPlayerPlay() { }
227     virtual bool mediaPlayerPlatformVolumeConfigurationRequired() const { return false; }
228     virtual bool mediaPlayerIsLooping() const { return false; }
229     virtual CachedResourceLoader* mediaPlayerCachedResourceLoader() { return nullptr; }
230     virtual RefPtr&lt;PlatformMediaResourceLoader&gt; mediaPlayerCreateResourceLoader() { return nullptr; }
231     virtual bool doesHaveAttribute(const AtomString&amp;, AtomString* = nullptr) const { return false; }
232     virtual bool mediaPlayerShouldUsePersistentCache() const { return true; }
233     virtual const String&amp; mediaPlayerMediaCacheDirectory() const { return emptyString(); }
234 
235 #if ENABLE(VIDEO_TRACK)
236     virtual void mediaPlayerDidAddAudioTrack(AudioTrackPrivate&amp;) { }
237     virtual void mediaPlayerDidAddTextTrack(InbandTextTrackPrivate&amp;) { }
238     virtual void mediaPlayerDidAddVideoTrack(VideoTrackPrivate&amp;) { }
239     virtual void mediaPlayerDidRemoveAudioTrack(AudioTrackPrivate&amp;) { }
240     virtual void mediaPlayerDidRemoveTextTrack(InbandTextTrackPrivate&amp;) { }
241     virtual void mediaPlayerDidRemoveVideoTrack(VideoTrackPrivate&amp;) { }
242 
243     virtual void textTrackRepresentationBoundsChanged(const IntRect&amp;) { }
244 #endif
245 
246 #if ENABLE(VIDEO_TRACK) &amp;&amp; ENABLE(AVF_CAPTIONS)
247     virtual Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; outOfBandTrackSources() { return { }; }
248 #endif
249 
250 #if PLATFORM(IOS_FAMILY)
251     virtual String mediaPlayerNetworkInterfaceName() const { return String(); }
252     virtual bool mediaPlayerGetRawCookies(const URL&amp;, Vector&lt;Cookie&gt;&amp;) const { return false; }
253 #endif
254 
255     virtual String mediaPlayerSourceApplicationIdentifier() const { return emptyString(); }
256 
257     virtual void mediaPlayerEngineFailedToLoad() const { }
258 
259     virtual double mediaPlayerRequestedPlaybackRate() const { return 0; }
260     virtual MediaPlayerEnums::VideoFullscreenMode mediaPlayerFullscreenMode() const { return MediaPlayerEnums::VideoFullscreenModeNone; }
261     virtual bool mediaPlayerIsVideoFullscreenStandby() const { return false; }
262     virtual Vector&lt;String&gt; mediaPlayerPreferredAudioCharacteristics() const { return Vector&lt;String&gt;(); }
263 
264 #if USE(GSTREAMER)
265     virtual void requestInstallMissingPlugins(const String&amp;, const String&amp;, MediaPlayerRequestInstallMissingPluginsCallback&amp;) { };
266 #endif
267 
268     virtual bool mediaPlayerShouldDisableSleep() const { return false; }
269     virtual const Vector&lt;ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const = 0;
270     virtual bool mediaPlayerShouldCheckHardwareSupport() const { return false; }
271 
272     virtual void mediaPlayerBufferedTimeRangesChanged() { }
273     virtual void mediaPlayerSeekableTimeRangesChanged() { }
274 
275 #if !RELEASE_LOG_DISABLED
276     virtual const void* mediaPlayerLogIdentifier() { return nullptr; }
277     virtual const Logger&amp; mediaPlayerLogger() = 0;
278 #endif
279 };
280 
281 class WEBCORE_EXPORT MediaPlayer : public MediaPlayerEnums, public RefCounted&lt;MediaPlayer&gt; {
282     WTF_MAKE_NONCOPYABLE(MediaPlayer); WTF_MAKE_FAST_ALLOCATED;
283 public:
284     static Ref&lt;MediaPlayer&gt; create(MediaPlayerClient&amp;);
285     static Ref&lt;MediaPlayer&gt; create(MediaPlayerClient&amp;, MediaPlayerEnums::MediaEngineIdentifier);
286     virtual ~MediaPlayer();
287 
288     void invalidate();
289 
290     // Media engine support.
291     using MediaPlayerEnums::SupportsType;
292     static const MediaPlayerFactory* mediaEngine(MediaPlayerEnums::MediaEngineIdentifier);
293     static SupportsType supportsType(const MediaEngineSupportParameters&amp;);
294     static void getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp;);
295     static bool isAvailable();
296     static HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp; path);
297     static void clearMediaCache(const String&amp; path, WallTime modifiedSince);
298     static void clearMediaCacheForOrigins(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;);
299     static bool supportsKeySystem(const String&amp; keySystem, const String&amp; mimeType);
300 
301     bool supportsPictureInPicture() const;
302     bool supportsFullscreen() const;
303     bool supportsScanning() const;
304     bool canSaveMediaData() const;
305     bool requiresImmediateCompositing() const;
306     bool doesHaveAttribute(const AtomString&amp;, AtomString* value = nullptr) const;
307     PlatformLayer* platformLayer() const;
308 
309 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
310     void setVideoFullscreenLayer(PlatformLayer*, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler = [] { });
311     void setVideoFullscreenFrame(FloatRect);
312     void updateVideoFullscreenInlineImage();
313     using MediaPlayerEnums::VideoGravity;
314     void setVideoFullscreenGravity(VideoGravity);
315     void setVideoFullscreenMode(VideoFullscreenMode);
316     VideoFullscreenMode fullscreenMode() const;
317     void videoFullscreenStandbyChanged();
318     bool isVideoFullscreenStandby() const;
319 #endif
320 
321 #if PLATFORM(IOS_FAMILY)
322     NSArray *timedMetadata() const;
323     String accessLog() const;
324     String errorLog() const;
325 #endif
326 
327     FloatSize naturalSize();
328     bool hasVideo() const;
329     bool hasAudio() const;
330 
331     IntSize size() const { return m_size; }
332     void setSize(const IntSize&amp; size);
333 
334     bool load(const URL&amp;, const ContentType&amp;, const String&amp; keySystem);
335 #if ENABLE(MEDIA_SOURCE)
336     bool load(const URL&amp;, const ContentType&amp;, MediaSourcePrivateClient*);
337 #endif
338 #if ENABLE(MEDIA_STREAM)
339     bool load(MediaStreamPrivate&amp;);
340 #endif
341     void cancelLoad();
342 
343     bool visible() const;
344     void setVisible(bool);
345 
346     void prepareToPlay();
347     void play();
348     void pause();
349 
350     using MediaPlayerEnums::BufferingPolicy;
351     void setBufferingPolicy(BufferingPolicy);
352 
353 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
354     // Represents synchronous exceptions that can be thrown from the Encrypted Media methods.
355     // This is different from the asynchronous MediaKeyError.
356     enum MediaKeyException { NoError, InvalidPlayerState, KeySystemNotSupported };
357 
358     std::unique_ptr&lt;LegacyCDMSession&gt; createSession(const String&amp; keySystem, LegacyCDMSessionClient*);
359     void setCDMSession(LegacyCDMSession*);
360     void keyAdded();
361 #endif
362 
363 #if ENABLE(ENCRYPTED_MEDIA)
364     void cdmInstanceAttached(CDMInstance&amp;);
365     void cdmInstanceDetached(CDMInstance&amp;);
366     void attemptToDecryptWithInstance(CDMInstance&amp;);
367 #endif
368 
369     bool paused() const;
370     bool seeking() const;
371 
372     static double invalidTime() { return -1.0;}
373     MediaTime duration() const;
374     MediaTime currentTime() const;
375     void seek(const MediaTime&amp;);
376     void seekWithTolerance(const MediaTime&amp;, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance);
377 
378     MediaTime startTime() const;
379     MediaTime initialTime() const;
380 
381     MediaTime getStartDate() const;
382 
383     double rate() const;
384     void setRate(double);
385     double requestedRate() const;
386 
387     bool preservesPitch() const;
388     void setPreservesPitch(bool);
389 
390     std::unique_ptr&lt;PlatformTimeRanges&gt; buffered();
391     std::unique_ptr&lt;PlatformTimeRanges&gt; seekable();
392     void bufferedTimeRangesChanged();
393     void seekableTimeRangesChanged();
394     MediaTime minTimeSeekable();
395     MediaTime maxTimeSeekable();
396 
397     double seekableTimeRangesLastModifiedTime();
398     double liveUpdateInterval();
399 
400     bool didLoadingProgress();
401 
402     double volume() const;
403     void setVolume(double);
404     bool platformVolumeConfigurationRequired() const { return client().mediaPlayerPlatformVolumeConfigurationRequired(); }
405 
406     bool muted() const;
407     void setMuted(bool);
408 
409     bool hasClosedCaptions() const;
410     void setClosedCaptionsVisible(bool closedCaptionsVisible);
411 
412     void paint(GraphicsContext&amp;, const FloatRect&amp;);
413     void paintCurrentFrameInContext(GraphicsContext&amp;, const FloatRect&amp;);
414 
415     // copyVideoTextureToPlatformTexture() is used to do the GPU-GPU textures copy without a readback to system memory.
416     // The first five parameters denote the corresponding GraphicsContext, destination texture, requested level, requested type and the required internalFormat for destination texture.
417     // The last two parameters premultiplyAlpha and flipY denote whether addtional premultiplyAlpha and flip operation are required during the copy.
418     // It returns true on success and false on failure.
419 
420     // In the GPU-GPU textures copy, the source texture(Video texture) should have valid target, internalFormat and size, etc.
421     // The destination texture may need to be resized to to the dimensions of the source texture or re-defined to the required internalFormat.
422     // The current restrictions require that format shoud be RGB or RGBA, type should be UNSIGNED_BYTE and level should be 0. It may be lifted in the future.
423 
424     bool copyVideoTextureToPlatformTexture(GraphicsContextGLOpenGL*, PlatformGLObject texture, GCGLenum target, GCGLint level, GCGLenum internalFormat, GCGLenum format, GCGLenum type, bool premultiplyAlpha, bool flipY);
425 
426     NativeImagePtr nativeImageForCurrentTime();
427 
428     using MediaPlayerEnums::NetworkState;
429     NetworkState networkState();
430 
431     using MediaPlayerEnums::ReadyState;
432     ReadyState readyState();
433 
434     using MediaPlayerEnums::MovieLoadType;
435     MovieLoadType movieLoadType() const;
436 
437     using MediaPlayerEnums::Preload;
438     Preload preload() const;
439     void setPreload(Preload);
440 
441     void networkStateChanged();
442     void readyStateChanged();
443     void volumeChanged(double);
444     void muteChanged(bool);
445     void timeChanged();
446     void sizeChanged();
447     void rateChanged();
448     void playbackStateChanged();
449     void durationChanged();
450     void firstVideoFrameAvailable();
451     void characteristicChanged();
452 
453     void repaint();
454 
455     bool hasAvailableVideoFrame() const;
456     void prepareForRendering();
457 
458 #if USE(NATIVE_FULLSCREEN_VIDEO)
459     void enterFullscreen();
460     void exitFullscreen();
461 #endif
462 
463 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
464     enum WirelessPlaybackTargetType { TargetTypeNone, TargetTypeAirPlay, TargetTypeTVOut };
465     WirelessPlaybackTargetType wirelessPlaybackTargetType() const;
466 
467     String wirelessPlaybackTargetName() const;
468 
469     bool wirelessVideoPlaybackDisabled() const;
470     void setWirelessVideoPlaybackDisabled(bool);
471 
472     void currentPlaybackTargetIsWirelessChanged(bool);
473     void playbackTargetAvailabilityChanged();
474 
475     bool isCurrentPlaybackTargetWireless() const;
476     bool canPlayToWirelessPlaybackTarget() const;
477     void setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp;);
478 
479     void setShouldPlayToPlaybackTarget(bool);
480 #endif
481 
482     double minFastReverseRate() const;
483     double maxFastForwardRate() const;
484 
485 #if USE(NATIVE_FULLSCREEN_VIDEO)
486     bool canEnterFullscreen() const;
487 #endif
488 
489     // whether accelerated rendering is supported by the media engine for the current media.
490     bool supportsAcceleratedRendering() const;
491     // called when the rendering system flips the into or out of accelerated rendering mode.
492     void acceleratedRenderingStateChanged();
493 
494     bool shouldMaintainAspectRatio() const;
495     void setShouldMaintainAspectRatio(bool);
496 
497 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
498     GraphicsDeviceAdapter* graphicsDeviceAdapter() const;
499 #endif
500 
501     bool hasSingleSecurityOrigin() const;
502     bool didPassCORSAccessCheck() const;
503     bool wouldTaintOrigin(const SecurityOrigin&amp;) const;
504 
505     MediaTime mediaTimeForTimeValue(const MediaTime&amp;) const;
506 
507     double maximumDurationToCacheMediaTime() const;
508 
509     unsigned decodedFrameCount() const;
510     unsigned droppedFrameCount() const;
511     unsigned audioDecodedByteCount() const;
512     unsigned videoDecodedByteCount() const;
513 
514     void setPrivateBrowsingMode(bool);
515 
516 #if ENABLE(WEB_AUDIO)
517     AudioSourceProvider* audioSourceProvider();
518 #endif
519 
520 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
521     RefPtr&lt;ArrayBuffer&gt; cachedKeyForKeyId(const String&amp; keyId) const;
522     bool keyNeeded(Uint8Array* initData);
523     String mediaKeysStorageDirectory() const;
524 #endif
525 
526 #if ENABLE(ENCRYPTED_MEDIA)
527     void initializationDataEncountered(const String&amp;, RefPtr&lt;ArrayBuffer&gt;&amp;&amp;);
528     void waitingForKeyChanged();
529     bool waitingForKey() const;
530 #endif
531 
532     String referrer() const;
533     String userAgent() const;
534 
535     String engineDescription() const;
536     long platformErrorCode() const;
537 
538     CachedResourceLoader* cachedResourceLoader();
539     RefPtr&lt;PlatformMediaResourceLoader&gt; createResourceLoader();
540 
541 #if ENABLE(VIDEO_TRACK)
542     void addAudioTrack(AudioTrackPrivate&amp;);
543     void addTextTrack(InbandTextTrackPrivate&amp;);
544     void addVideoTrack(VideoTrackPrivate&amp;);
545     void removeAudioTrack(AudioTrackPrivate&amp;);
546     void removeTextTrack(InbandTextTrackPrivate&amp;);
547     void removeVideoTrack(VideoTrackPrivate&amp;);
548 
549     bool requiresTextTrackRepresentation() const;
550     void setTextTrackRepresentation(TextTrackRepresentation*);
551     void syncTextTrackBounds();
552     void tracksChanged();
553 #endif
554 
555 #if ENABLE(VIDEO_TRACK) &amp;&amp; ENABLE(AVF_CAPTIONS)
556     void notifyTrackModeChanged();
557     Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; outOfBandTrackSources();
558 #endif
559 
560 #if PLATFORM(IOS_FAMILY)
561     String mediaPlayerNetworkInterfaceName() const;
562     bool getRawCookies(const URL&amp;, Vector&lt;Cookie&gt;&amp;) const;
563 #endif
564 
565     static void resetMediaEngines();
566 
567 #if USE(GSTREAMER)
568     void simulateAudioInterruption();
569 #endif
570 
571     void beginSimulatedHDCPError();
572     void endSimulatedHDCPError();
573 
574     String languageOfPrimaryAudioTrack() const;
575 
576     size_t extraMemoryCost() const;
577 
578     unsigned long long fileSize() const;
579 
580     Optional&lt;VideoPlaybackQualityMetrics&gt; videoPlaybackQualityMetrics();
581 
582     String sourceApplicationIdentifier() const;
583     Vector&lt;String&gt; preferredAudioCharacteristics() const;
584 
585     bool ended() const;
586 
587     void setShouldDisableSleep(bool);
588     bool shouldDisableSleep() const;
589 
590     String contentMIMEType() const { return m_contentType.containerType(); }
591     String contentTypeCodecs() const { return m_contentType.parameter(ContentType::codecsParameter()); }
592     bool contentMIMETypeWasInferredFromExtension() const { return m_contentMIMETypeWasInferredFromExtension; }
593 
594     const Vector&lt;ContentType&gt;&amp; mediaContentTypesRequiringHardwareSupport() const;
595     bool shouldCheckHardwareSupport() const;
596 
597 #if !RELEASE_LOG_DISABLED
598     const Logger&amp; mediaPlayerLogger();
599     const void* mediaPlayerLogIdentifier() { return client().mediaPlayerLogIdentifier(); }
600 #endif
601 
602     void applicationWillResignActive();
603     void applicationDidBecomeActive();
604 
605 #if USE(AVFOUNDATION)
606     AVPlayer *objCAVFoundationAVPlayer() const;
607 #endif
608 
609     bool performTaskAtMediaTime(WTF::Function&lt;void()&gt;&amp;&amp;, MediaTime);
610 
611     bool shouldIgnoreIntrinsicSize();
612 
613     bool renderingCanBeAccelerated() const { return client().mediaPlayerRenderingCanBeAccelerated(); }
614     void renderingModeChanged() const  { client().mediaPlayerRenderingModeChanged(); }
615     bool acceleratedCompositingEnabled() { return client().mediaPlayerAcceleratedCompositingEnabled(); }
616     void activeSourceBuffersChanged() { client().mediaPlayerActiveSourceBuffersChanged(); }
617     LayoutRect playerContentBoxRect() const { return client().mediaPlayerContentBoxRect(); }
618     float playerContentsScale() const { return client().mediaPlayerContentsScale(); }
619     bool shouldUsePersistentCache() const { return client().mediaPlayerShouldUsePersistentCache(); }
620     const String&amp; mediaCacheDirectory() const { return client().mediaPlayerMediaCacheDirectory(); }
621     bool isVideoPlayer() const { return client().mediaPlayerIsVideo(); }
622     void mediaEngineUpdated() { client().mediaPlayerEngineUpdated(); }
623     void resourceNotSupported() { client().mediaPlayerResourceNotSupported(); }
624     bool isLooping() const { return client().mediaPlayerIsLooping(); }
625 
626     void remoteEngineFailedToLoad();
627 
628 #if USE(GSTREAMER)
629     void requestInstallMissingPlugins(const String&amp; details, const String&amp; description, MediaPlayerRequestInstallMissingPluginsCallback&amp; callback) { client().requestInstallMissingPlugins(details, description, callback); }
630 #endif
631 
632 private:
633     MediaPlayer(MediaPlayerClient&amp;);
634     MediaPlayer(MediaPlayerClient&amp;, MediaPlayerEnums::MediaEngineIdentifier);
635 
636     MediaPlayerClient&amp; client() const { return *m_client; }
637 
638     const MediaPlayerFactory* nextBestMediaEngine(const MediaPlayerFactory*);
639     void loadWithNextMediaEngine(const MediaPlayerFactory*);
640     const MediaPlayerFactory* nextMediaEngine(const MediaPlayerFactory*);
641     void reloadTimerFired();
642 
643     MediaPlayerClient* m_client;
644     Timer m_reloadTimer;
645     std::unique_ptr&lt;MediaPlayerPrivateInterface&gt; m_private;
646     const MediaPlayerFactory* m_currentMediaEngine { nullptr };
647     URL m_url;
648     ContentType m_contentType;
649     String m_keySystem;
650     Optional&lt;MediaPlayerEnums::MediaEngineIdentifier&gt; m_activeEngineIdentifier;
651     IntSize m_size;
652     Preload m_preload { Preload::Auto };
653     double m_volume { 1 };
654     bool m_visible { false };
655     bool m_muted { false };
656     bool m_preservesPitch { true };
657     bool m_privateBrowsing { false };
658     bool m_shouldPrepareToRender { false };
659     bool m_contentMIMETypeWasInferredFromExtension { false };
660     bool m_initializingMediaEngine { false };
661 
662 #if ENABLE(MEDIA_SOURCE)
663     RefPtr&lt;MediaSourcePrivateClient&gt; m_mediaSource;
664 #endif
665 #if ENABLE(MEDIA_STREAM)
666     RefPtr&lt;MediaStreamPrivate&gt; m_mediaStream;
667 #endif
668 };
669 
670 class MediaPlayerFactory {
671     WTF_MAKE_FAST_ALLOCATED;
672 public:
673     MediaPlayerFactory() = default;
674     virtual ~MediaPlayerFactory() = default;
675 
676     virtual MediaPlayerEnums::MediaEngineIdentifier identifier() const  = 0;
677     virtual std::unique_ptr&lt;MediaPlayerPrivateInterface&gt; createMediaEnginePlayer(MediaPlayer*) const = 0;
678     virtual void getSupportedTypes(HashSet&lt;String, ASCIICaseInsensitiveHash&gt;&amp;) const = 0;
679     virtual MediaPlayer::SupportsType supportsTypeAndCodecs(const MediaEngineSupportParameters&amp;) const = 0;
680 
681     virtual HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; originsInMediaCache(const String&amp;) const { return { }; }
682     virtual void clearMediaCache(const String&amp;, WallTime) const { }
683     virtual void clearMediaCacheForOrigins(const String&amp;, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp;) const { }
684     virtual bool supportsKeySystem(const String&amp; /* keySystem */, const String&amp; /* mimeType */) const { return false; }
685 };
686 
687 using MediaEngineRegistrar = void(std::unique_ptr&lt;MediaPlayerFactory&gt;&amp;&amp;);
688 using MediaEngineRegister = void(MediaEngineRegistrar);
689 
690 class MediaPlayerFactorySupport {
691 public:
692     WEBCORE_EXPORT static void callRegisterMediaEngine(MediaEngineRegister);
693 };
694 
695 class RemoteMediaPlayerSupport {
696 public:
697     using RegisterRemotePlayerCallback = WTF::Function&lt;void(MediaEngineRegistrar, MediaPlayerEnums::MediaEngineIdentifier)&gt;;
698     WEBCORE_EXPORT static void setRegisterRemotePlayerCallback(RegisterRemotePlayerCallback&amp;&amp;);
699 };
700 
701 
702 } // namespace WebCore
703 
704 #endif // ENABLE(VIDEO)
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSObject.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSObjectInlines.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSObject.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  38 #include &quot;PropertySlot.h&quot;
  39 #include &quot;PropertyStorage.h&quot;
  40 #include &quot;PutDirectIndexMode.h&quot;
  41 #include &quot;PutPropertySlot.h&quot;
  42 #include &quot;Structure.h&quot;
  43 #include &quot;StructureTransitionTable.h&quot;
  44 #include &quot;VM.h&quot;
  45 #include &quot;JSString.h&quot;
  46 #include &quot;SparseArrayValueMap.h&quot;
  47 #include &lt;wtf/StdLibExtras.h&gt;
  48 
  49 namespace JSC {
  50 namespace DOMJIT {
  51 class Signature;
  52 }
  53 
  54 inline JSCell* getJSFunction(JSValue value)
  55 {
  56     if (value.isCell() &amp;&amp; (value.asCell()-&gt;type() == JSFunctionType))
  57         return value.asCell();
<span class="line-modified">  58     return 0;</span>
  59 }
  60 
  61 class Exception;
  62 class GetterSetter;
  63 class InternalFunction;
  64 class JSFunction;
  65 class LLIntOffsetsExtractor;
  66 class MarkedBlock;
  67 class PropertyDescriptor;
  68 class PropertyNameArray;
  69 class Structure;
  70 class ThrowScope;
  71 struct HashTable;
  72 struct HashTableValue;
  73 
<span class="line-modified">  74 JS_EXPORT_PRIVATE Exception* throwTypeError(ExecState*, ThrowScope&amp;, const String&amp;);</span>
  75 extern JS_EXPORT_PRIVATE const ASCIILiteral NonExtensibleObjectPropertyDefineError;
  76 extern JS_EXPORT_PRIVATE const ASCIILiteral ReadonlyPropertyWriteError;
  77 extern JS_EXPORT_PRIVATE const ASCIILiteral ReadonlyPropertyChangeError;
  78 extern JS_EXPORT_PRIVATE const ASCIILiteral UnableToDeletePropertyError;
  79 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeAccessMechanismError;
  80 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeConfigurabilityError;
  81 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeEnumerabilityError;
  82 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeWritabilityError;
  83 
  84 COMPILE_ASSERT(PropertyAttribute::None &lt; FirstInternalAttribute, None_is_below_FirstInternalAttribute);
  85 COMPILE_ASSERT(PropertyAttribute::ReadOnly &lt; FirstInternalAttribute, ReadOnly_is_below_FirstInternalAttribute);
  86 COMPILE_ASSERT(PropertyAttribute::DontEnum &lt; FirstInternalAttribute, DontEnum_is_below_FirstInternalAttribute);
  87 COMPILE_ASSERT(PropertyAttribute::DontDelete &lt; FirstInternalAttribute, DontDelete_is_below_FirstInternalAttribute);
  88 COMPILE_ASSERT(PropertyAttribute::Accessor &lt; FirstInternalAttribute, Accessor_is_below_FirstInternalAttribute);
  89 
  90 class JSFinalObject;
  91 
  92 class JSObject : public JSCell {
  93     friend class BatchedTransitionOptimizer;
  94     friend class JIT;
  95     friend class JSCell;
  96     friend class JSFinalObject;
  97     friend class MarkedBlock;
  98     JS_EXPORT_PRIVATE friend bool setUpStaticFunctionSlot(VM&amp;, const HashTableValue*, JSObject*, PropertyName, PropertySlot&amp;);
  99 
 100     enum PutMode {
 101         PutModePut,
 102         PutModeDefineOwnProperty,
 103     };
 104 
 105 public:
<span class="line-modified"> 106     typedef JSCell Base;</span>






 107 
 108     // This is a super dangerous method for JITs. Sometimes the JITs will want to create either a
 109     // JSFinalObject or a JSArray. This is the method that will do that.
<span class="line-modified"> 110     static JSObject* createRawObject(ExecState* exec, Structure* structure, Butterfly* = nullptr);</span>
 111 
 112     JS_EXPORT_PRIVATE static size_t estimatedSize(JSCell*, VM&amp;);
 113     JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&amp;);
 114     JS_EXPORT_PRIVATE static void analyzeHeap(JSCell*, HeapAnalyzer&amp;);
 115 
 116     JS_EXPORT_PRIVATE static String className(const JSObject*, VM&amp;);
 117     JS_EXPORT_PRIVATE static String calculatedClassName(JSObject*);
 118 
 119     // This function is what Object.prototype.toString() will use to get the name of
 120     // an object when using Symbol.toStringTag fails. For the most part there is no
 121     // difference between this and className(). The main use case is for new JS language
 122     // objects to set the default tag to &quot;Object&quot;.
<span class="line-modified"> 123     JS_EXPORT_PRIVATE static String toStringName(const JSObject*, ExecState*);</span>
 124 
 125     // This is the fully virtual [[GetPrototypeOf]] internal function defined
 126     // in the ECMAScript 6 specification. Use this when doing a [[GetPrototypeOf]]
 127     // operation as dictated in the specification.
<span class="line-modified"> 128     JSValue getPrototype(VM&amp;, ExecState*);</span>
<span class="line-modified"> 129     JS_EXPORT_PRIVATE static JSValue getPrototype(JSObject*, ExecState*);</span>
 130     // This gets the prototype directly off of the structure. This does not do
 131     // dynamic dispatch on the getPrototype method table method. It is not valid
 132     // to use this when performing a [[GetPrototypeOf]] operation in the specification.
 133     // It is valid to use though when you know that you want to directly get it
 134     // without consulting the method table. This is akin to getting the [[Prototype]]
 135     // internal field directly as described in the specification.
 136     JSValue getPrototypeDirect(VM&amp;) const;
 137 
 138     // This sets the prototype without checking for cycles and without
 139     // doing dynamic dispatch on [[SetPrototypeOf]] operation in the specification.
 140     // It is not valid to use this when performing a [[SetPrototypeOf]] operation in
 141     // the specification. It is valid to use though when you know that you want to directly
 142     // set it without consulting the method table and when you definitely won&#39;t
 143     // introduce a cycle in the prototype chain. This is akin to setting the
 144     // [[Prototype]] internal field directly as described in the specification.
 145     JS_EXPORT_PRIVATE void setPrototypeDirect(VM&amp;, JSValue prototype);
 146 private:
 147     // This is OrdinarySetPrototypeOf in the specification. Section 9.1.2.1
 148     // https://tc39.github.io/ecma262/#sec-ordinarysetprototypeof
<span class="line-modified"> 149     JS_EXPORT_PRIVATE bool setPrototypeWithCycleCheck(VM&amp;, ExecState*, JSValue prototype, bool shouldThrowIfCantSet);</span>
 150 public:
 151     // This is the fully virtual [[SetPrototypeOf]] internal function defined
 152     // in the ECMAScript 6 specification. Use this when doing a [[SetPrototypeOf]]
 153     // operation as dictated in the specification.
<span class="line-modified"> 154     bool setPrototype(VM&amp;, ExecState*, JSValue prototype, bool shouldThrowIfCantSet = false);</span>
<span class="line-modified"> 155     JS_EXPORT_PRIVATE static bool setPrototype(JSObject*, ExecState*, JSValue prototype, bool shouldThrowIfCantSet);</span>
 156 
 157     inline bool mayInterceptIndexedAccesses(VM&amp;);
 158 
<span class="line-modified"> 159     JSValue get(ExecState*, PropertyName) const;</span>
<span class="line-modified"> 160     JSValue get(ExecState*, unsigned propertyName) const;</span>
 161 
 162     template&lt;bool checkNullStructure = false&gt;
<span class="line-modified"> 163     bool getPropertySlot(ExecState*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified"> 164     bool getPropertySlot(ExecState*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="line-modified"> 165     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(ExecState*, PropertyName, CallbackWhenNoException) const;</span>
<span class="line-modified"> 166     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(ExecState*, PropertyName, PropertySlot&amp;, CallbackWhenNoException) const;</span>
 167 
<span class="line-modified"> 168     static bool getOwnPropertySlot(JSObject*, ExecState*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified"> 169     JS_EXPORT_PRIVATE static bool getOwnPropertySlotByIndex(JSObject*, ExecState*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="line-modified"> 170     bool getOwnPropertySlotInline(ExecState*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified"> 171     static void doPutPropertySecurityCheck(JSObject*, ExecState*, PropertyName, PutPropertySlot&amp;);</span>
 172 
 173     // The key difference between this and getOwnPropertySlot is that getOwnPropertySlot
 174     // currently returns incorrect results for the DOM window (with non-own properties)
 175     // being returned. Once this is fixed we should migrate code &amp; remove this method.
<span class="line-modified"> 176     JS_EXPORT_PRIVATE bool getOwnPropertyDescriptor(ExecState*, PropertyName, PropertyDescriptor&amp;);</span>
 177 
 178     unsigned getArrayLength() const
 179     {
 180         if (!hasIndexedProperties(indexingType()))
 181             return 0;
 182         return m_butterfly-&gt;publicLength();
 183     }
 184 
 185     unsigned getVectorLength()
 186     {
 187         if (!hasIndexedProperties(indexingType()))
 188             return 0;
 189         return m_butterfly-&gt;vectorLength();
 190     }
 191 
<span class="line-modified"> 192     static bool putInlineForJSObject(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
 193 
<span class="line-modified"> 194     JS_EXPORT_PRIVATE static bool put(JSCell*, ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
 195     // putByIndex assumes that the receiver is this JSCell object.
<span class="line-modified"> 196     JS_EXPORT_PRIVATE static bool putByIndex(JSCell*, ExecState*, unsigned propertyName, JSValue, bool shouldThrow);</span>
 197 
 198     // This performs the ECMAScript Set() operation.
<span class="line-modified"> 199     ALWAYS_INLINE bool putByIndexInline(ExecState* exec, unsigned propertyName, JSValue value, bool shouldThrow)</span>
 200     {
<span class="line-modified"> 201         VM&amp; vm = exec-&gt;vm();</span>
 202         if (canSetIndexQuickly(propertyName, value)) {
 203             setIndexQuickly(vm, propertyName, value);
 204             return true;
 205         }
<span class="line-modified"> 206         return methodTable(vm)-&gt;putByIndex(this, exec, propertyName, value, shouldThrow);</span>
 207     }
 208 
 209     // This is similar to the putDirect* methods:
 210     //  - the prototype chain is not consulted
 211     //  - accessors are not called.
 212     //  - it will ignore extensibility and read-only properties if PutDirectIndexLikePutDirect is passed as the mode (the default).
 213     // This method creates a property with attributes writable, enumerable and configurable all set to true if attributes is zero,
 214     // otherwise, it creates a property with the provided attributes. Semantically, this is performing defineOwnProperty.
<span class="line-modified"> 215     bool putDirectIndex(ExecState* exec, unsigned propertyName, JSValue value, unsigned attributes, PutDirectIndexMode mode)</span>
 216     {
 217         ASSERT(!value.isCustomGetterSetter());
 218         auto canSetIndexQuicklyForPutDirect = [&amp;] () -&gt; bool {
 219             switch (indexingMode()) {
 220             case ALL_BLANK_INDEXING_TYPES:
 221             case ALL_UNDECIDED_INDEXING_TYPES:
 222                 return false;
 223             case ALL_WRITABLE_INT32_INDEXING_TYPES:
 224             case ALL_WRITABLE_DOUBLE_INDEXING_TYPES:
 225             case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
 226             case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 227                 return propertyName &lt; m_butterfly-&gt;vectorLength();
 228             default:
 229                 if (isCopyOnWrite(indexingMode()))
 230                     return false;
 231                 RELEASE_ASSERT_NOT_REACHED();
 232                 return false;
 233             }
 234         };
 235 
 236         if (!attributes &amp;&amp; canSetIndexQuicklyForPutDirect()) {
<span class="line-modified"> 237             setIndexQuickly(exec-&gt;vm(), propertyName, value);</span>
 238             return true;
 239         }
<span class="line-modified"> 240         return putDirectIndexSlowOrBeyondVectorLength(exec, propertyName, value, attributes, mode);</span>
 241     }
 242     // This is semantically equivalent to performing defineOwnProperty(propertyName, {configurable:true, writable:true, enumerable:true, value:value}).
<span class="line-modified"> 243     bool putDirectIndex(ExecState* exec, unsigned propertyName, JSValue value)</span>
 244     {
<span class="line-modified"> 245         return putDirectIndex(exec, propertyName, value, 0, PutDirectIndexLikePutDirect);</span>
 246     }
 247 
 248     // A generally non-throwing version of putDirect and putDirectIndex.
 249     // However, it&#39;s only guaranteed to not throw based on what the receiver is.
 250     // For example, if the receiver is a ProxyObject, this is not guaranteed, since
 251     // it may call into arbitrary JS code. It&#39;s the responsibility of the user of
 252     // this API to ensure that the receiver object is a well known type if they
 253     // want to ensure that this won&#39;t throw an exception.
<span class="line-modified"> 254     JS_EXPORT_PRIVATE bool putDirectMayBeIndex(ExecState*, PropertyName, JSValue);</span>
 255 
 256     bool hasIndexingHeader(VM&amp; vm) const
 257     {
 258         return structure(vm)-&gt;hasIndexingHeader(this);
 259     }
 260 
 261     bool canGetIndexQuicklyForTypedArray(unsigned) const;
 262     JSValue getIndexQuicklyForTypedArray(unsigned) const;
 263 
 264     bool canGetIndexQuickly(unsigned i) const
 265     {
 266         const Butterfly* butterfly = this-&gt;butterfly();
 267         switch (indexingType()) {
 268         case ALL_BLANK_INDEXING_TYPES:
 269             return canGetIndexQuicklyForTypedArray(i);
 270         case ALL_UNDECIDED_INDEXING_TYPES:
 271             return false;
 272         case ALL_INT32_INDEXING_TYPES:
 273         case ALL_CONTIGUOUS_INDEXING_TYPES:
 274             return i &lt; butterfly-&gt;vectorLength() &amp;&amp; butterfly-&gt;contiguous().at(this, i);
</pre>
<hr />
<pre>
 331             break;
 332         case ALL_DOUBLE_INDEXING_TYPES: {
 333             if (i &gt;= butterfly-&gt;publicLength())
 334                 break;
 335             double result = butterfly-&gt;contiguousDouble().at(this, i);
 336             if (result != result)
 337                 break;
 338             return JSValue(JSValue::EncodeAsDouble, result);
 339         }
 340         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 341             if (i &lt; butterfly-&gt;arrayStorage()-&gt;vectorLength())
 342                 return butterfly-&gt;arrayStorage()-&gt;m_vector[i].get();
 343             break;
 344         default:
 345             RELEASE_ASSERT_NOT_REACHED();
 346             break;
 347         }
 348         return JSValue();
 349     }
 350 
<span class="line-modified"> 351     JSValue getDirectIndex(ExecState* exec, unsigned i)</span>
 352     {
 353         if (JSValue result = tryGetIndexQuickly(i))
 354             return result;
 355         PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
<span class="line-modified"> 356         if (methodTable(exec-&gt;vm())-&gt;getOwnPropertySlotByIndex(this, exec, i, slot))</span>
<span class="line-modified"> 357             return slot.getValue(exec, i);</span>
 358         return JSValue();
 359     }
 360 
<span class="line-modified"> 361     JSValue getIndex(ExecState* exec, unsigned i) const</span>
 362     {
 363         if (JSValue result = tryGetIndexQuickly(i))
 364             return result;
<span class="line-modified"> 365         return get(exec, i);</span>
 366     }
 367 
 368     bool canSetIndexQuicklyForTypedArray(unsigned, JSValue) const;
 369     void setIndexQuicklyForTypedArray(unsigned, JSValue);
 370 
 371     bool canSetIndexQuickly(unsigned i, JSValue value)
 372     {
 373         Butterfly* butterfly = this-&gt;butterfly();
 374         switch (indexingMode()) {
 375         case ALL_BLANK_INDEXING_TYPES:
 376             return canSetIndexQuicklyForTypedArray(i, value);
 377         case ALL_UNDECIDED_INDEXING_TYPES:
 378             return false;
 379         case ALL_WRITABLE_INT32_INDEXING_TYPES:
 380         case ALL_WRITABLE_DOUBLE_INDEXING_TYPES:
 381         case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
 382         case NonArrayWithArrayStorage:
 383         case ArrayWithArrayStorage:
 384             return i &lt; butterfly-&gt;vectorLength();
 385         case NonArrayWithSlowPutArrayStorage:
</pre>
<hr />
<pre>
 392             RELEASE_ASSERT_NOT_REACHED();
 393             return false;
 394         }
 395     }
 396 
 397     void setIndexQuickly(VM&amp; vm, unsigned i, JSValue v)
 398     {
 399         Butterfly* butterfly = m_butterfly.get();
 400         ASSERT(!isCopyOnWrite(indexingMode()));
 401         switch (indexingType()) {
 402         case ALL_INT32_INDEXING_TYPES: {
 403             ASSERT(i &lt; butterfly-&gt;vectorLength());
 404             if (!v.isInt32()) {
 405                 convertInt32ToDoubleOrContiguousWhilePerformingSetIndex(vm, i, v);
 406                 return;
 407             }
 408             FALLTHROUGH;
 409         }
 410         case ALL_CONTIGUOUS_INDEXING_TYPES: {
 411             ASSERT(i &lt; butterfly-&gt;vectorLength());
<span class="line-modified"> 412             butterfly-&gt;contiguous().at(this, i).set(vm, this, v);</span>
 413             if (i &gt;= butterfly-&gt;publicLength())
 414                 butterfly-&gt;setPublicLength(i + 1);

 415             break;
 416         }
 417         case ALL_DOUBLE_INDEXING_TYPES: {
 418             ASSERT(i &lt; butterfly-&gt;vectorLength());
 419             if (!v.isNumber()) {
 420                 convertDoubleToContiguousWhilePerformingSetIndex(vm, i, v);
 421                 return;
 422             }
 423             double value = v.asNumber();
 424             if (value != value) {
 425                 convertDoubleToContiguousWhilePerformingSetIndex(vm, i, v);
 426                 return;
 427             }
 428             butterfly-&gt;contiguousDouble().at(this, i) = value;
 429             if (i &gt;= butterfly-&gt;publicLength())
 430                 butterfly-&gt;setPublicLength(i + 1);
 431             break;
 432         }
 433         case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 434             ArrayStorage* storage = butterfly-&gt;arrayStorage();
</pre>
<hr />
<pre>
 585         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 586             return m_butterfly-&gt;arrayStorage()-&gt;inSparseMode();
 587         default:
 588             RELEASE_ASSERT_NOT_REACHED();
 589             return false;
 590         }
 591     }
 592 
 593     void enterDictionaryIndexingMode(VM&amp;);
 594 
 595     // putDirect is effectively an unchecked vesion of &#39;defineOwnProperty&#39;:
 596     //  - the prototype chain is not consulted
 597     //  - accessors are not called.
 598     //  - attributes will be respected (after the call the property will exist with the given attributes)
 599     //  - the property name is assumed to not be an index.
 600     bool putDirect(VM&amp;, PropertyName, JSValue, unsigned attributes = 0);
 601     bool putDirect(VM&amp;, PropertyName, JSValue, PutPropertySlot&amp;);
 602     void putDirectWithoutTransition(VM&amp;, PropertyName, JSValue, unsigned attributes = 0);
 603     bool putDirectNonIndexAccessor(VM&amp;, PropertyName, GetterSetter*, unsigned attributes);
 604     void putDirectNonIndexAccessorWithoutTransition(VM&amp;, PropertyName, GetterSetter*, unsigned attributes);
<span class="line-modified"> 605     bool putDirectAccessor(ExecState*, PropertyName, GetterSetter*, unsigned attributes);</span>
 606     JS_EXPORT_PRIVATE bool putDirectCustomAccessor(VM&amp;, PropertyName, JSValue, unsigned attributes);
 607 
<span class="line-modified"> 608     bool putGetter(ExecState*, PropertyName, JSValue, unsigned attributes);</span>
<span class="line-modified"> 609     bool putSetter(ExecState*, PropertyName, JSValue, unsigned attributes);</span>
 610 
<span class="line-modified"> 611     JS_EXPORT_PRIVATE bool hasProperty(ExecState*, PropertyName) const;</span>
<span class="line-modified"> 612     JS_EXPORT_PRIVATE bool hasProperty(ExecState*, unsigned propertyName) const;</span>
<span class="line-modified"> 613     bool hasPropertyGeneric(ExecState*, PropertyName, PropertySlot::InternalMethodType) const;</span>
<span class="line-modified"> 614     bool hasPropertyGeneric(ExecState*, unsigned propertyName, PropertySlot::InternalMethodType) const;</span>
<span class="line-modified"> 615     bool hasOwnProperty(ExecState*, PropertyName, PropertySlot&amp;) const;</span>
<span class="line-modified"> 616     bool hasOwnProperty(ExecState*, PropertyName) const;</span>
<span class="line-modified"> 617     bool hasOwnProperty(ExecState*, unsigned) const;</span>
 618 
<span class="line-modified"> 619     JS_EXPORT_PRIVATE static bool deleteProperty(JSCell*, ExecState*, PropertyName);</span>
<span class="line-modified"> 620     JS_EXPORT_PRIVATE static bool deletePropertyByIndex(JSCell*, ExecState*, unsigned propertyName);</span>
 621 
<span class="line-modified"> 622     JS_EXPORT_PRIVATE static JSValue defaultValue(const JSObject*, ExecState*, PreferredPrimitiveType);</span>
<span class="line-modified"> 623     JSValue ordinaryToPrimitive(ExecState*, PreferredPrimitiveType) const;</span>
 624 
<span class="line-modified"> 625     JS_EXPORT_PRIVATE bool hasInstance(ExecState*, JSValue value, JSValue hasInstanceValue);</span>
<span class="line-modified"> 626     JS_EXPORT_PRIVATE bool hasInstance(ExecState*, JSValue);</span>
<span class="line-modified"> 627     static bool defaultHasInstance(ExecState*, JSValue, JSValue prototypeProperty);</span>
 628 
<span class="line-modified"> 629     JS_EXPORT_PRIVATE static void getOwnPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified"> 630     JS_EXPORT_PRIVATE static void getOwnNonIndexPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified"> 631     JS_EXPORT_PRIVATE static void getPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
 632 
<span class="line-modified"> 633     JS_EXPORT_PRIVATE static uint32_t getEnumerableLength(ExecState*, JSObject*);</span>
<span class="line-modified"> 634     JS_EXPORT_PRIVATE static void getStructurePropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified"> 635     JS_EXPORT_PRIVATE static void getGenericPropertyNames(JSObject*, ExecState*, PropertyNameArray&amp;, EnumerationMode);</span>
 636 
<span class="line-modified"> 637     JS_EXPORT_PRIVATE JSValue toPrimitive(ExecState*, PreferredPrimitiveType = NoPreference) const;</span>
<span class="line-modified"> 638     bool getPrimitiveNumber(ExecState*, double&amp; number, JSValue&amp;) const;</span>
<span class="line-modified"> 639     JS_EXPORT_PRIVATE double toNumber(ExecState*) const;</span>
<span class="line-modified"> 640     JS_EXPORT_PRIVATE JSString* toString(ExecState*) const;</span>
 641 
<span class="line-modified"> 642     JS_EXPORT_PRIVATE static JSValue toThis(JSCell*, ExecState*, ECMAMode);</span>
 643 
 644     // This get function only looks at the property map.
 645     JSValue getDirect(VM&amp; vm, PropertyName propertyName) const
 646     {
 647         Structure* structure = this-&gt;structure(vm);
 648         PropertyOffset offset = structure-&gt;get(vm, propertyName);
 649         checkOffset(offset, structure-&gt;inlineCapacity());
 650         return offset != invalidOffset ? getDirect(offset) : JSValue();
 651     }
 652 
 653     JSValue getDirect(VM&amp; vm, PropertyName propertyName, unsigned&amp; attributes) const
 654     {
 655         Structure* structure = this-&gt;structure(vm);
 656         PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);
 657         checkOffset(offset, structure-&gt;inlineCapacity());
 658         return offset != invalidOffset ? getDirect(offset) : JSValue();
 659     }
 660 
 661     PropertyOffset getDirectOffset(VM&amp; vm, PropertyName propertyName)
 662     {
</pre>
<hr />
<pre>
 709 
 710     ALWAYS_INLINE WriteBarrierBase&lt;Unknown&gt;* locationForOffset(PropertyOffset offset)
 711     {
 712         if (isInlineOffset(offset))
 713             return &amp;inlineStorage()[offsetInInlineStorage(offset)];
 714         return &amp;outOfLineStorage()[offsetInOutOfLineStorage(offset)];
 715     }
 716 
 717     void transitionTo(VM&amp;, Structure*);
 718 
 719     bool hasCustomProperties(VM&amp; vm) { return structure(vm)-&gt;didTransition(); }
 720     bool hasGetterSetterProperties(VM&amp; vm) { return structure(vm)-&gt;hasGetterSetterProperties(); }
 721     bool hasCustomGetterSetterProperties(VM&amp; vm) { return structure(vm)-&gt;hasCustomGetterSetterProperties(); }
 722 
 723     // putOwnDataProperty has &#39;put&#39; like semantics, however this method:
 724     //  - assumes the object contains no own getter/setter properties.
 725     //  - provides no special handling for __proto__
 726     //  - does not walk the prototype chain (to check for accessors or non-writable properties).
 727     // This is used by JSLexicalEnvironment.
 728     bool putOwnDataProperty(VM&amp;, PropertyName, JSValue, PutPropertySlot&amp;);
<span class="line-modified"> 729     bool putOwnDataPropertyMayBeIndex(ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>



 730 
 731     // Fast access to known property offsets.
 732     ALWAYS_INLINE JSValue getDirect(PropertyOffset offset) const { return locationForOffset(offset)-&gt;get(); }
 733     JSValue getDirectConcurrently(Structure* expectedStructure, PropertyOffset) const;
 734     void putDirect(VM&amp; vm, PropertyOffset offset, JSValue value) { locationForOffset(offset)-&gt;set(vm, this, value); }
 735     void putDirectWithoutBarrier(PropertyOffset offset, JSValue value) { locationForOffset(offset)-&gt;setWithoutWriteBarrier(value); }
 736     void putDirectUndefined(PropertyOffset offset) { locationForOffset(offset)-&gt;setUndefined(); }
 737 
 738     JS_EXPORT_PRIVATE bool putDirectNativeIntrinsicGetter(VM&amp;, JSGlobalObject*, Identifier, NativeFunction, Intrinsic, unsigned attributes);
 739     JS_EXPORT_PRIVATE void putDirectNativeIntrinsicGetterWithoutTransition(VM&amp;, JSGlobalObject*, Identifier, NativeFunction, Intrinsic, unsigned attributes);
 740     JS_EXPORT_PRIVATE bool putDirectNativeFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, unsigned attributes);
 741     JS_EXPORT_PRIVATE bool putDirectNativeFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, const DOMJIT::Signature*, unsigned attributes);
 742     JS_EXPORT_PRIVATE void putDirectNativeFunctionWithoutTransition(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, unsigned attributes);
 743 
 744     JS_EXPORT_PRIVATE JSFunction* putDirectBuiltinFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, FunctionExecutable*, unsigned attributes);
 745     JSFunction* putDirectBuiltinFunctionWithoutTransition(VM&amp;, JSGlobalObject*, const PropertyName&amp;, FunctionExecutable*, unsigned attributes);
 746 
<span class="line-modified"> 747     JS_EXPORT_PRIVATE static bool defineOwnProperty(JSObject*, ExecState*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);</span>
 748 
 749     bool isEnvironment() const;
 750     bool isGlobalObject() const;
 751     bool isJSLexicalEnvironment() const;
 752     bool isGlobalLexicalEnvironment() const;
 753     bool isStrictEvalActivation() const;
 754     bool isWithScope() const;
 755 
 756     bool isErrorInstance() const;
 757 
 758     JS_EXPORT_PRIVATE void seal(VM&amp;);
 759     JS_EXPORT_PRIVATE void freeze(VM&amp;);
<span class="line-modified"> 760     JS_EXPORT_PRIVATE static bool preventExtensions(JSObject*, ExecState*);</span>
<span class="line-modified"> 761     JS_EXPORT_PRIVATE static bool isExtensible(JSObject*, ExecState*);</span>
 762     bool isSealed(VM&amp; vm) { return structure(vm)-&gt;isSealed(vm); }
 763     bool isFrozen(VM&amp; vm) { return structure(vm)-&gt;isFrozen(vm); }
 764 
 765     JS_EXPORT_PRIVATE bool anyObjectInChainMayInterceptIndexedAccesses(VM&amp;) const;
 766     JS_EXPORT_PRIVATE bool prototypeChainMayInterceptStoreTo(VM&amp;, PropertyName);
 767     bool needsSlowPutIndexing(VM&amp;) const;
 768 
 769 private:
 770     NonPropertyTransition suggestedArrayStorageTransition(VM&amp;) const;
 771 public:
 772     // You should only call isStructureExtensible() when:
 773     // - Performing this check in a way that isn&#39;t described in the specification
 774     //   as calling the virtual [[IsExtensible]] trap.
 775     // - When you&#39;re guaranteed that object-&gt;methodTable(vm)-&gt;isExtensible isn&#39;t
 776     //   overridden.
 777     ALWAYS_INLINE bool isStructureExtensible(VM&amp; vm) { return structure(vm)-&gt;isStructureExtensible(); }
 778     // You should call this when performing [[IsExtensible]] trap in a place
 779     // that is described in the specification. This performs the fully virtual
 780     // [[IsExtensible]] trap.
<span class="line-modified"> 781     bool isExtensible(ExecState*);</span>
 782     bool indexingShouldBeSparse(VM&amp; vm)
 783     {
 784         return !isStructureExtensible(vm)
 785             || structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero();
 786     }
 787 
 788     bool staticPropertiesReified(VM&amp; vm) { return structure(vm)-&gt;staticPropertiesReified(); }
<span class="line-modified"> 789     void reifyAllStaticProperties(ExecState*);</span>
 790 
 791     JS_EXPORT_PRIVATE Butterfly* allocateMoreOutOfLineStorage(VM&amp;, size_t oldSize, size_t newSize);
 792 
 793     // Call this when you do not need to change the structure.
 794     void setButterfly(VM&amp;, Butterfly*);
 795 
 796     // Call this if you do need to change the structure, or if you changed something about a structure
 797     // in-place.
 798     void nukeStructureAndSetButterfly(VM&amp;, StructureID oldStructureID, Butterfly*);
 799 
 800     void setStructure(VM&amp;, Structure*);
 801 
 802     JS_EXPORT_PRIVATE void convertToDictionary(VM&amp;);
 803 
 804     void flattenDictionaryObject(VM&amp; vm)
 805     {
 806         structure(vm)-&gt;flattenDictionaryStructure(vm, this);
 807     }
 808     void shiftButterflyAfterFlattening(const GCSafeConcurrentJSLocker&amp;, VM&amp;, Structure* structure, size_t outOfLineCapacityAfter);
 809 
</pre>
<hr />
<pre>
 813         ASSERT(!isGlobalObject() || ((JSObject*)structure()-&gt;globalObject()) == this);
 814         return structure()-&gt;globalObject();
 815     }
 816 
 817     JSGlobalObject* globalObject(VM&amp; vm) const
 818     {
 819         ASSERT(structure(vm)-&gt;globalObject());
 820         ASSERT(!isGlobalObject() || ((JSObject*)structure(vm)-&gt;globalObject()) == this);
 821         return structure(vm)-&gt;globalObject();
 822     }
 823 
 824     void switchToSlowPutArrayStorage(VM&amp;);
 825 
 826     // The receiver is the prototype in this case. The following:
 827     //
 828     // asObject(foo-&gt;structure()-&gt;storedPrototype())-&gt;attemptToInterceptPutByIndexOnHoleForPrototype(...)
 829     //
 830     // is equivalent to:
 831     //
 832     // foo-&gt;attemptToInterceptPutByIndexOnHole(...);
<span class="line-modified"> 833     bool attemptToInterceptPutByIndexOnHoleForPrototype(ExecState*, JSValue thisValue, unsigned propertyName, JSValue, bool shouldThrow, bool&amp; putResult);</span>
 834 
 835     // Returns 0 if int32 storage cannot be created - either because
 836     // indexing should be sparse, we&#39;re having a bad time, or because
 837     // we already have a more general form of storage (double,
 838     // contiguous, array storage).
 839     ContiguousJSValues tryMakeWritableInt32(VM&amp; vm)
 840     {
 841         if (LIKELY(hasInt32(indexingType()) &amp;&amp; !isCopyOnWrite(indexingMode())))
 842             return m_butterfly-&gt;contiguousInt32();
 843 
 844         return tryMakeWritableInt32Slow(vm);
 845     }
 846 
 847     // Returns 0 if double storage cannot be created - either because
 848     // indexing should be sparse, we&#39;re having a bad time, or because
 849     // we already have a more general form of storage (contiguous,
 850     // or array storage).
 851     ContiguousDoubles tryMakeWritableDouble(VM&amp; vm)
 852     {
 853         if (LIKELY(hasDouble(indexingType()) &amp;&amp; !isCopyOnWrite(indexingMode())))
</pre>
<hr />
<pre>
 878         return ensureArrayStorageSlow(vm);
 879     }
 880 
 881     void ensureWritable(VM&amp; vm)
 882     {
 883         if (isCopyOnWrite(indexingMode()))
 884             convertFromCopyOnWrite(vm);
 885     }
 886 
 887     static size_t offsetOfInlineStorage();
 888 
 889     static ptrdiff_t butterflyOffset()
 890     {
 891         return OBJECT_OFFSETOF(JSObject, m_butterfly);
 892     }
 893     void* butterflyAddress()
 894     {
 895         return &amp;m_butterfly;
 896     }
 897 
<span class="line-modified"> 898     JS_EXPORT_PRIVATE JSValue getMethod(ExecState*, CallData&amp;, CallType&amp;, const Identifier&amp;, const String&amp; errorMessage);</span>
 899 
 900     bool canPerformFastPutInline(VM&amp;, PropertyName);
 901     bool canPerformFastPutInlineExcludingProto(VM&amp;);
 902 
 903     bool mayBePrototype() const;
 904     void didBecomePrototype();
 905 


 906     DECLARE_EXPORT_INFO;
 907 
 908 protected:
 909     void finishCreation(VM&amp; vm)
 910     {
 911         Base::finishCreation(vm);
 912         ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, this));
 913         ASSERT(structure(vm)-&gt;hasPolyProto() || getPrototypeDirect(vm).isNull() || Heap::heap(this) == Heap::heap(getPrototypeDirect(vm)));
 914         ASSERT(structure(vm)-&gt;isObject());
 915         ASSERT(classInfo(vm));
 916     }
 917 
 918     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 919     {
 920         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 921     }
 922 
 923     // To instantiate objects you likely want JSFinalObject, below.
 924     // To create derived types you likely want JSNonFinalObject, below.
 925     JSObject(VM&amp;, Structure*, Butterfly* = nullptr);
 926 
 927     // Visits the butterfly unless there is a race. Returns the structure if there was no race.
 928     Structure* visitButterfly(SlotVisitor&amp;);
 929 
 930     Structure* visitButterflyImpl(SlotVisitor&amp;);
 931 
<span class="line-modified"> 932     void markAuxiliaryAndVisitOutOfLineProperties(SlotVisitor&amp;, Butterfly*, Structure*, PropertyOffset lastOffset);</span>
 933 
 934     // Call this if you know that the object is in a mode where it has array
 935     // storage. This will assert otherwise.
 936     ArrayStorage* arrayStorage()
 937     {
 938         ASSERT(hasAnyArrayStorage(indexingType()));
 939         return m_butterfly-&gt;arrayStorage();
 940     }
 941 
 942     // Call this if you want to predicate some actions on whether or not the
 943     // object is in a mode where it has array storage.
 944     ArrayStorage* arrayStorageOrNull()
 945     {
 946         switch (indexingType()) {
 947         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 948             return m_butterfly-&gt;arrayStorage();
 949 
 950         default:
 951             return 0;
 952         }
</pre>
<hr />
<pre>
 974     ContiguousDoubles convertUndecidedToDouble(VM&amp;);
 975     ContiguousJSValues convertUndecidedToContiguous(VM&amp;);
 976     ArrayStorage* convertUndecidedToArrayStorage(VM&amp;, NonPropertyTransition);
 977     ArrayStorage* convertUndecidedToArrayStorage(VM&amp;);
 978 
 979     ContiguousDoubles convertInt32ToDouble(VM&amp;);
 980     ContiguousJSValues convertInt32ToContiguous(VM&amp;);
 981     ArrayStorage* convertInt32ToArrayStorage(VM&amp;, NonPropertyTransition);
 982     ArrayStorage* convertInt32ToArrayStorage(VM&amp;);
 983 
 984     ContiguousJSValues convertDoubleToContiguous(VM&amp;);
 985     ArrayStorage* convertDoubleToArrayStorage(VM&amp;, NonPropertyTransition);
 986     ArrayStorage* convertDoubleToArrayStorage(VM&amp;);
 987 
 988     ArrayStorage* convertContiguousToArrayStorage(VM&amp;, NonPropertyTransition);
 989     ArrayStorage* convertContiguousToArrayStorage(VM&amp;);
 990 
 991 
 992     ArrayStorage* ensureArrayStorageExistsAndEnterDictionaryIndexingMode(VM&amp;);
 993 
<span class="line-modified"> 994     bool defineOwnNonIndexProperty(ExecState*, PropertyName, const PropertyDescriptor&amp;, bool throwException);</span>
 995 
 996     template&lt;IndexingType indexingShape&gt;
<span class="line-modified"> 997     bool putByIndexBeyondVectorLengthWithoutAttributes(ExecState*, unsigned propertyName, JSValue);</span>
<span class="line-modified"> 998     bool putByIndexBeyondVectorLengthWithArrayStorage(ExecState*, unsigned propertyName, JSValue, bool shouldThrow, ArrayStorage*);</span>
 999 
1000     bool increaseVectorLength(VM&amp;, unsigned newLength);
1001     void deallocateSparseIndexMap();
<span class="line-modified">1002     bool defineOwnIndexedProperty(ExecState*, unsigned, const PropertyDescriptor&amp;, bool throwException);</span>
1003     SparseArrayValueMap* allocateSparseIndexMap(VM&amp;);
1004 
1005     void notifyPresenceOfIndexedAccessors(VM&amp;);
1006 
<span class="line-modified">1007     bool attemptToInterceptPutByIndexOnHole(ExecState*, unsigned index, JSValue, bool shouldThrow, bool&amp; putResult);</span>
1008 
1009     // Call this if you want setIndexQuickly to succeed and you&#39;re sure that
1010     // the array is contiguous.
1011     bool WARN_UNUSED_RETURN ensureLength(VM&amp; vm, unsigned length)
1012     {
1013         RELEASE_ASSERT(length &lt;= MAX_STORAGE_VECTOR_LENGTH);
1014         ASSERT(hasContiguous(indexingType()) || hasInt32(indexingType()) || hasDouble(indexingType()) || hasUndecided(indexingType()));
1015 
1016         if (m_butterfly-&gt;vectorLength() &lt; length || isCopyOnWrite(indexingMode())) {
1017             if (!ensureLengthSlow(vm, length))
1018                 return false;
1019         }
1020 
1021         if (m_butterfly-&gt;publicLength() &lt; length)
1022             m_butterfly-&gt;setPublicLength(length);
1023         return true;
1024     }
1025 
1026     // Call this if you want to shrink the butterfly backing store, and you&#39;re
1027     // sure that the array is contiguous.
1028     void reallocateAndShrinkButterfly(VM&amp;, unsigned length);
1029 
1030     template&lt;IndexingType indexingShape&gt;
1031     unsigned countElements(Butterfly*);
1032 
1033     // This is relevant to undecided, int32, double, and contiguous.
1034     unsigned countElements();
1035 
1036 private:
1037     friend class LLIntOffsetsExtractor;
1038     friend class VMInspector;
1039 
1040     // Nobody should ever ask any of these questions on something already known to be a JSObject.
1041     using JSCell::isAPIValueWrapper;
1042     using JSCell::isGetterSetter;
1043     void getObject();
<span class="line-modified">1044     void getString(ExecState* exec);</span>
1045     void isObject();
1046     void isString();
1047 
1048     Butterfly* createInitialIndexedStorage(VM&amp;, unsigned length);
1049 
1050     ArrayStorage* enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(VM&amp;, ArrayStorage*);
1051 
1052     template&lt;PutMode&gt;
1053     bool putDirectInternal(VM&amp;, PropertyName, JSValue, unsigned attr, PutPropertySlot&amp;);
1054 
<span class="line-modified">1055     JS_EXPORT_PRIVATE NEVER_INLINE bool putInlineSlow(ExecState*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
1056 
<span class="line-modified">1057     bool getNonIndexPropertySlot(ExecState*, PropertyName, PropertySlot&amp;);</span>
1058     bool getOwnNonIndexPropertySlot(VM&amp;, Structure*, PropertyName, PropertySlot&amp;);
1059     JS_EXPORT_PRIVATE void fillGetterPropertySlot(VM&amp;, PropertySlot&amp;, JSCell*, unsigned, PropertyOffset);
1060     void fillCustomGetterPropertySlot(VM&amp;, PropertySlot&amp;, CustomGetterSetter*, unsigned, Structure*);
1061 
1062     JS_EXPORT_PRIVATE bool getOwnStaticPropertySlot(VM&amp;, PropertyName, PropertySlot&amp;);
<span class="line-removed">1063     struct PropertyHashEntry {</span>
<span class="line-removed">1064         const HashTable* table;</span>
<span class="line-removed">1065         const HashTableValue* value;</span>
<span class="line-removed">1066     };</span>
<span class="line-removed">1067     Optional&lt;PropertyHashEntry&gt; findPropertyHashEntry(VM&amp;, PropertyName) const;</span>
1068 
<span class="line-modified">1069     bool putByIndexBeyondVectorLength(ExecState*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="line-modified">1070     bool putDirectIndexBeyondVectorLengthWithArrayStorage(ExecState*, unsigned propertyName, JSValue, unsigned attributes, PutDirectIndexMode, ArrayStorage*);</span>
<span class="line-modified">1071     JS_EXPORT_PRIVATE bool putDirectIndexSlowOrBeyondVectorLength(ExecState*, unsigned propertyName, JSValue, unsigned attributes, PutDirectIndexMode);</span>
1072 
1073     unsigned getNewVectorLength(VM&amp;, unsigned indexBias, unsigned currentVectorLength, unsigned currentLength, unsigned desiredLength);
1074     unsigned getNewVectorLength(VM&amp;, unsigned desiredLength);
1075 
1076     ArrayStorage* constructConvertedArrayStorageWithoutCopyingElements(VM&amp;, unsigned neededLength);
1077 
1078     JS_EXPORT_PRIVATE void setIndexQuicklyToUndecided(VM&amp;, unsigned index, JSValue);
1079     JS_EXPORT_PRIVATE void convertInt32ToDoubleOrContiguousWhilePerformingSetIndex(VM&amp;, unsigned index, JSValue);
1080     JS_EXPORT_PRIVATE void convertDoubleToContiguousWhilePerformingSetIndex(VM&amp;, unsigned index, JSValue);
1081 
1082     bool ensureLengthSlow(VM&amp;, unsigned length);
1083 
1084     ContiguousJSValues tryMakeWritableInt32Slow(VM&amp;);
1085     ContiguousDoubles tryMakeWritableDoubleSlow(VM&amp;);
1086     ContiguousJSValues tryMakeWritableContiguousSlow(VM&amp;);
1087     JS_EXPORT_PRIVATE ArrayStorage* ensureArrayStorageSlow(VM&amp;);
1088 
1089     PropertyOffset prepareToPutDirectWithoutTransition(VM&amp;, PropertyName, unsigned attributes, StructureID, Structure*);
1090 
1091     AuxiliaryBarrier&lt;Butterfly*&gt; m_butterfly;
</pre>
<hr />
<pre>
1114     {
1115     }
1116 
1117     void finishCreation(VM&amp; vm)
1118     {
1119         Base::finishCreation(vm);
1120         ASSERT(!this-&gt;structure(vm)-&gt;hasInlineStorage());
1121         ASSERT(classInfo(vm));
1122     }
1123 };
1124 
1125 class JSFinalObject;
1126 
1127 // JSFinalObject is a type of JSObject that contains sufficient internal
1128 // storage to fully make use of the collector cell containing it.
1129 class JSFinalObject final : public JSObject {
1130     friend class JSObject;
1131 
1132 public:
1133     typedef JSObject Base;
<span class="line-modified">1134     static const unsigned StructureFlags = Base::StructureFlags;</span>
1135 
1136     static size_t allocationSize(Checked&lt;size_t&gt; inlineCapacity)
1137     {
1138         return (sizeof(JSObject) + inlineCapacity * sizeof(WriteBarrierBase&lt;Unknown&gt;)).unsafeGet();
1139     }
1140 
1141     static inline const TypeInfo typeInfo() { return TypeInfo(FinalObjectType, StructureFlags); }
<span class="line-modified">1142     static const IndexingType defaultIndexingType = NonArray;</span>
1143 
<span class="line-modified">1144     static const unsigned defaultSize = 64;</span>
1145     static inline unsigned defaultInlineCapacity()
1146     {
1147         return (defaultSize - allocationSize(0)) / sizeof(WriteBarrier&lt;Unknown&gt;);
1148     }
1149 
<span class="line-modified">1150     static const unsigned maxSize = 512;</span>
1151     static inline unsigned maxInlineCapacity()
1152     {
1153         return (maxSize - allocationSize(0)) / sizeof(WriteBarrier&lt;Unknown&gt;);
1154     }
1155 
<span class="line-modified">1156     static JSFinalObject* create(ExecState*, Structure*, Butterfly* = nullptr);</span>
<span class="line-removed">1157     static JSFinalObject* create(VM&amp;, Structure*);</span>
1158     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, unsigned inlineCapacity)
1159     {
1160         return Structure::create(vm, globalObject, prototype, typeInfo(), info(), defaultIndexingType, inlineCapacity);
1161     }
1162 
1163     JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&amp;);
1164 
1165     DECLARE_EXPORT_INFO;
1166 
1167 protected:
1168     void visitChildrenCommon(SlotVisitor&amp;);
1169 
1170     void finishCreation(VM&amp; vm)
1171     {
1172         Base::finishCreation(vm);
1173         ASSERT(structure(vm)-&gt;totalStorageCapacity() == structure(vm)-&gt;inlineCapacity());
1174         ASSERT(classInfo(vm));
1175     }
1176 
1177 private:
1178     friend class LLIntOffsetsExtractor;
1179 
1180     explicit JSFinalObject(VM&amp; vm, Structure* structure, Butterfly* butterfly = nullptr)
1181         : JSObject(vm, structure, butterfly)
1182     {
<span class="line-modified">1183         memset(inlineStorageUnsafe(), 0, structure-&gt;inlineCapacity() * sizeof(EncodedJSValue));</span>
1184     }
1185 };
1186 
<span class="line-modified">1187 JS_EXPORT_PRIVATE EncodedJSValue JSC_HOST_CALL objectPrivateFuncInstanceOf(ExecState*);</span>
1188 
<span class="line-modified">1189 inline JSObject* JSObject::createRawObject(</span>
<span class="line-removed">1190     ExecState* exec, Structure* structure, Butterfly* butterfly)</span>
1191 {
<span class="line-removed">1192     VM&amp; vm = exec-&gt;vm();</span>
1193     JSObject* finalObject = new (
1194         NotNull,
1195         allocateCell&lt;JSFinalObject&gt;(
1196             vm.heap,
1197             JSFinalObject::allocationSize(structure-&gt;inlineCapacity())
1198         )
1199     ) JSObject(vm, structure, butterfly);
1200     finalObject-&gt;finishCreation(vm);
1201     return finalObject;
1202 }
1203 
<span class="line-modified">1204 inline JSFinalObject* JSFinalObject::create(</span>
<span class="line-removed">1205     ExecState* exec, Structure* structure, Butterfly* butterfly)</span>
1206 {
<span class="line-removed">1207     VM&amp; vm = exec-&gt;vm();</span>
1208     JSFinalObject* finalObject = new (
1209         NotNull,
1210         allocateCell&lt;JSFinalObject&gt;(
1211             vm.heap,
1212             allocationSize(structure-&gt;inlineCapacity())
1213         )
1214     ) JSFinalObject(vm, structure, butterfly);
1215     finalObject-&gt;finishCreation(vm);
1216     return finalObject;
1217 }
1218 
<span class="line-removed">1219 inline JSFinalObject* JSFinalObject::create(VM&amp; vm, Structure* structure)</span>
<span class="line-removed">1220 {</span>
<span class="line-removed">1221     JSFinalObject* finalObject = new (NotNull, allocateCell&lt;JSFinalObject&gt;(vm.heap, allocationSize(structure-&gt;inlineCapacity()))) JSFinalObject(vm, structure);</span>
<span class="line-removed">1222     finalObject-&gt;finishCreation(vm);</span>
<span class="line-removed">1223     return finalObject;</span>
<span class="line-removed">1224 }</span>
<span class="line-removed">1225 </span>
1226 inline size_t JSObject::offsetOfInlineStorage()
1227 {
1228     return sizeof(JSObject);
1229 }
1230 
1231 inline bool JSObject::isGlobalObject() const
1232 {
1233     return type() == GlobalObjectType;
1234 }
1235 
1236 inline bool JSObject::isJSLexicalEnvironment() const
1237 {
1238     return type() == LexicalEnvironmentType || type() == ModuleEnvironmentType;
1239 }
1240 
1241 inline bool JSObject::isGlobalLexicalEnvironment() const
1242 {
1243     return type() == GlobalLexicalEnvironmentType;
1244 }
1245 
</pre>
<hr />
<pre>
1280         WTF::storeStoreFence();
1281         return;
1282     }
1283 
1284     m_butterfly.set(vm, this, butterfly);
1285 }
1286 
1287 inline void JSObject::nukeStructureAndSetButterfly(VM&amp; vm, StructureID oldStructureID, Butterfly* butterfly)
1288 {
1289     if (isX86() || vm.heap.mutatorShouldBeFenced()) {
1290         setStructureIDDirectly(nuke(oldStructureID));
1291         WTF::storeStoreFence();
1292         m_butterfly.set(vm, this, butterfly);
1293         WTF::storeStoreFence();
1294         return;
1295     }
1296 
1297     m_butterfly.set(vm, this, butterfly);
1298 }
1299 
<span class="line-removed">1300 inline CallType getCallData(VM&amp; vm, JSValue value, CallData&amp; callData)</span>
<span class="line-removed">1301 {</span>
<span class="line-removed">1302     CallType result = value.isCell() ? value.asCell()-&gt;methodTable(vm)-&gt;getCallData(value.asCell(), callData) : CallType::None;</span>
<span class="line-removed">1303     ASSERT(result == CallType::None || value.isValidCallee());</span>
<span class="line-removed">1304     return result;</span>
<span class="line-removed">1305 }</span>
<span class="line-removed">1306 </span>
<span class="line-removed">1307 inline ConstructType getConstructData(VM&amp; vm, JSValue value, ConstructData&amp; constructData)</span>
<span class="line-removed">1308 {</span>
<span class="line-removed">1309     ConstructType result = value.isCell() ? value.asCell()-&gt;methodTable(vm)-&gt;getConstructData(value.asCell(), constructData) : ConstructType::None;</span>
<span class="line-removed">1310     ASSERT(result == ConstructType::None || value.isValidCallee());</span>
<span class="line-removed">1311     return result;</span>
<span class="line-removed">1312 }</span>
<span class="line-removed">1313 </span>
1314 inline JSObject* asObject(JSCell* cell)
1315 {
1316     ASSERT(cell-&gt;isObject());
1317     return jsCast&lt;JSObject*&gt;(cell);
1318 }
1319 
1320 inline JSObject* asObject(JSValue value)
1321 {
1322     return asObject(value.asCell());
1323 }
1324 
1325 inline JSObject::JSObject(VM&amp; vm, Structure* structure, Butterfly* butterfly)
1326     : JSCell(vm, structure)
1327     , m_butterfly(vm, this, butterfly)
1328 {
1329 }
1330 
1331 inline JSValue JSObject::getPrototypeDirect(VM&amp; vm) const
1332 {
1333     return structure(vm)-&gt;storedPrototype(this);
1334 }
1335 
<span class="line-modified">1336 inline JSValue JSObject::getPrototype(VM&amp; vm, ExecState* exec)</span>
1337 {
1338     auto getPrototypeMethod = methodTable(vm)-&gt;getPrototype;
1339     MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
1340     if (LIKELY(getPrototypeMethod == defaultGetPrototype))
1341         return getPrototypeDirect(vm);
<span class="line-modified">1342     return getPrototypeMethod(this, exec);</span>
1343 }
1344 
1345 // Normally, we never shrink the butterfly so if we know an offset is valid for some
1346 // past structure then it should be valid for any new structure. However, we may sometimes
1347 // shrink the butterfly when we are holding the Structure&#39;s ConcurrentJSLock, such as when we
1348 // flatten an object.
1349 inline JSValue JSObject::getDirectConcurrently(Structure* structure, PropertyOffset offset) const
1350 {
1351     ConcurrentJSLocker locker(structure-&gt;lock());
1352     if (!structure-&gt;isValidOffset(offset))
1353         return { };
1354     return getDirect(offset);
1355 }
1356 
1357 // It is safe to call this method with a PropertyName that is actually an index,
1358 // but if so will always return false (doesn&#39;t search index storage).
1359 ALWAYS_INLINE bool JSObject::getOwnNonIndexPropertySlot(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertySlot&amp; slot)
1360 {
1361     unsigned attributes;
1362     PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);
</pre>
<hr />
<pre>
1394 {
1395     ASSERT(attributes &amp; PropertyAttribute::CustomAccessorOrValue);
1396     if (customGetterSetter-&gt;inherits&lt;DOMAttributeGetterSetter&gt;(vm)) {
1397         auto* domAttribute = jsCast&lt;DOMAttributeGetterSetter*&gt;(customGetterSetter);
1398         if (structure-&gt;isUncacheableDictionary())
1399             slot.setCustom(this, attributes, domAttribute-&gt;getter(), domAttribute-&gt;domAttribute());
1400         else
1401             slot.setCacheableCustom(this, attributes, domAttribute-&gt;getter(), domAttribute-&gt;domAttribute());
1402         return;
1403     }
1404 
1405     if (structure-&gt;isUncacheableDictionary())
1406         slot.setCustom(this, attributes, customGetterSetter-&gt;getter());
1407     else
1408         slot.setCacheableCustom(this, attributes, customGetterSetter-&gt;getter());
1409 }
1410 
1411 // It may seem crazy to inline a function this large, especially a virtual function,
1412 // but it makes a big difference to property lookup that derived classes can inline their
1413 // base class call to this.
<span class="line-modified">1414 ALWAYS_INLINE bool JSObject::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
1415 {
<span class="line-modified">1416     VM&amp; vm = exec-&gt;vm();</span>
1417     Structure* structure = object-&gt;structure(vm);
1418     if (object-&gt;getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))
1419         return true;
1420     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">1421         return getOwnPropertySlotByIndex(object, exec, index.value(), slot);</span>
1422     return false;
1423 }
1424 
<span class="line-modified">1425 ALWAYS_INLINE void JSObject::doPutPropertySecurityCheck(JSObject*, ExecState*, PropertyName, PutPropertySlot&amp;)</span>
1426 {
1427 }
1428 
1429 // It may seem crazy to inline a function this large but it makes a big difference
1430 // since this is function very hot in variable lookup
1431 template&lt;bool checkNullStructure&gt;
<span class="line-modified">1432 ALWAYS_INLINE bool JSObject::getPropertySlot(ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
1433 {
<span class="line-modified">1434     VM&amp; vm = exec-&gt;vm();</span>
1435     auto&amp; structureIDTable = vm.heap.structureIDTable();
1436     JSObject* object = this;
1437     while (true) {
1438         if (UNLIKELY(TypeInfo::overridesGetOwnPropertySlot(object-&gt;inlineTypeFlags()))) {
1439             // If propertyName is an index then we may have missed it (as this loop is using
1440             // getOwnNonIndexPropertySlot), so we cannot safely call the overridden getOwnPropertySlot
1441             // (lest we return a property from a prototype that is shadowed). Check now for an index,
1442             // if so we need to start afresh from this object.
1443             if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">1444                 return getPropertySlot(exec, index.value(), slot);</span>
1445             // Safe to continue searching from current position; call getNonIndexPropertySlot to avoid
1446             // parsing the int again.
<span class="line-modified">1447             return object-&gt;getNonIndexPropertySlot(exec, propertyName, slot);</span>
1448         }
1449         ASSERT(object-&gt;type() != ProxyObjectType);
1450         Structure* structure = structureIDTable.get(object-&gt;structureID());
1451 #if USE(JSVALUE64)
1452         if (checkNullStructure &amp;&amp; UNLIKELY(!structure))
1453             CRASH_WITH_INFO(object-&gt;type(), object-&gt;structureID(), structureIDTable.size());
1454 #endif
1455         if (object-&gt;getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))
1456             return true;
1457         // FIXME: This doesn&#39;t look like it&#39;s following the specification:
1458         // https://bugs.webkit.org/show_bug.cgi?id=172572
1459         JSValue prototype = structure-&gt;storedPrototype(object);
1460         if (!prototype.isObject())
1461             break;
1462         object = asObject(prototype);
1463     }
1464 
1465     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">1466         return getPropertySlot(exec, index.value(), slot);</span>
1467     return false;
1468 }
1469 
<span class="line-modified">1470 inline JSValue JSObject::get(ExecState* exec, PropertyName propertyName) const</span>
1471 {
<span class="line-modified">1472     VM&amp; vm = exec-&gt;vm();</span>
1473     auto scope = DECLARE_THROW_SCOPE(vm);
1474     PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
<span class="line-modified">1475     bool hasProperty = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);</span>
1476     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
1477     if (hasProperty)
<span class="line-modified">1478         RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));</span>
1479 
1480     return jsUndefined();
1481 }
1482 
<span class="line-modified">1483 inline JSValue JSObject::get(ExecState* exec, unsigned propertyName) const</span>
1484 {
<span class="line-modified">1485     VM&amp; vm = exec-&gt;vm();</span>
1486     auto scope = DECLARE_THROW_SCOPE(vm);
1487     PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
<span class="line-modified">1488     bool hasProperty = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(exec, propertyName, slot);</span>
1489     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
1490     if (hasProperty)
<span class="line-modified">1491         RELEASE_AND_RETURN(scope, slot.getValue(exec, propertyName));</span>
1492 
1493     return jsUndefined();
1494 }
1495 
<span class="line-removed">1496 inline bool JSObject::putOwnDataProperty(VM&amp; vm, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
<span class="line-removed">1497 {</span>
<span class="line-removed">1498     ASSERT(value);</span>
<span class="line-removed">1499     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));</span>
<span class="line-removed">1500     ASSERT(!structure(vm)-&gt;hasGetterSetterProperties());</span>
<span class="line-removed">1501     ASSERT(!structure(vm)-&gt;hasCustomGetterSetterProperties());</span>
<span class="line-removed">1502 </span>
<span class="line-removed">1503     return putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot);</span>
<span class="line-removed">1504 }</span>
<span class="line-removed">1505 </span>
<span class="line-removed">1506 inline bool JSObject::putOwnDataPropertyMayBeIndex(ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
<span class="line-removed">1507 {</span>
<span class="line-removed">1508     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-removed">1509     ASSERT(value);</span>
<span class="line-removed">1510     ASSERT(!Heap::heap(value) || Heap::heap(value) == Heap::heap(this));</span>
<span class="line-removed">1511     ASSERT(!structure(vm)-&gt;hasGetterSetterProperties());</span>
<span class="line-removed">1512     ASSERT(!structure(vm)-&gt;hasCustomGetterSetterProperties());</span>
<span class="line-removed">1513 </span>
<span class="line-removed">1514     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))</span>
<span class="line-removed">1515         return putDirectIndex(exec, index.value(), value, 0, PutDirectIndexLikePutDirect);</span>
<span class="line-removed">1516 </span>
<span class="line-removed">1517     return putDirectInternal&lt;PutModePut&gt;(vm, propertyName, value, 0, slot);</span>
<span class="line-removed">1518 }</span>
<span class="line-removed">1519 </span>
1520 inline bool JSObject::putDirect(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes)
1521 {
1522     ASSERT(!value.isGetterSetter() &amp;&amp; !(attributes &amp; PropertyAttribute::Accessor));
1523     ASSERT(!value.isCustomGetterSetter() &amp;&amp; !(attributes &amp; PropertyAttribute::CustomAccessorOrValue));
1524     PutPropertySlot slot(this);
1525     return putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, value, attributes, slot);
1526 }
1527 
1528 inline bool JSObject::putDirect(VM&amp; vm, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
1529 {
1530     ASSERT(!value.isGetterSetter());
1531     ASSERT(!value.isCustomGetterSetter());
1532     return putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, value, 0, slot);
1533 }
1534 
<span class="line-removed">1535 ALWAYS_INLINE JSObject* Register::object() const</span>
<span class="line-removed">1536 {</span>
<span class="line-removed">1537     return asObject(jsValue());</span>
<span class="line-removed">1538 }</span>
<span class="line-removed">1539 </span>
<span class="line-removed">1540 ALWAYS_INLINE Register&amp; Register::operator=(JSObject* object)</span>
<span class="line-removed">1541 {</span>
<span class="line-removed">1542     u.value = JSValue::encode(JSValue(object));</span>
<span class="line-removed">1543     return *this;</span>
<span class="line-removed">1544 }</span>
<span class="line-removed">1545 </span>
1546 inline size_t offsetInButterfly(PropertyOffset offset)
1547 {
1548     return offsetInOutOfLineStorage(offset) + Butterfly::indexOfPropertyStorage();
1549 }
1550 
1551 inline size_t JSObject::butterflyPreCapacity()
1552 {
1553     VM&amp; vm = this-&gt;vm();
1554     if (UNLIKELY(hasIndexingHeader(vm)))
1555         return butterfly()-&gt;indexingHeader()-&gt;preCapacity(structure(vm));
1556     return 0;
1557 }
1558 
1559 inline size_t JSObject::butterflyTotalSize()
1560 {
1561     VM&amp; vm = this-&gt;vm();
1562     Structure* structure = this-&gt;structure(vm);
1563     Butterfly* butterfly = this-&gt;butterfly();
1564     size_t preCapacity;
1565     size_t indexingPayloadSizeInBytes;
</pre>
<hr />
<pre>
1603 }
1604 
1605 COMPILE_ASSERT(!(sizeof(JSObject) % sizeof(WriteBarrierBase&lt;Unknown&gt;)), JSObject_inline_storage_has_correct_alignment);
1606 
1607 template&lt;unsigned charactersCount&gt;
1608 ALWAYS_INLINE Identifier makeIdentifier(VM&amp; vm, const char (&amp;characters)[charactersCount])
1609 {
1610     return Identifier::fromString(vm, characters);
1611 }
1612 
1613 ALWAYS_INLINE Identifier makeIdentifier(VM&amp; vm, const char* name)
1614 {
1615     return Identifier::fromString(vm, name);
1616 }
1617 
1618 ALWAYS_INLINE Identifier makeIdentifier(VM&amp;, const Identifier&amp; name)
1619 {
1620     return name;
1621 }
1622 
<span class="line-modified">1623 bool validateAndApplyPropertyDescriptor(ExecState*, JSObject*, PropertyName, bool isExtensible,</span>
1624     const PropertyDescriptor&amp; descriptor, bool isCurrentDefined, const PropertyDescriptor&amp; current, bool throwException);
1625 
<span class="line-modified">1626 JS_EXPORT_PRIVATE NEVER_INLINE bool ordinarySetSlow(ExecState*, JSObject*, PropertyName, JSValue, JSValue receiver, bool shouldThrow);</span>
1627 
1628 // Helper for defining native functions, if you&#39;re not using a static hash table.
1629 // Use this macro from within finishCreation() methods in prototypes. This assumes
<span class="line-modified">1630 // you&#39;ve defined variables called exec, globalObject, and vm, and they</span>
1631 // have the expected meanings.
1632 #define JSC_NATIVE_INTRINSIC_FUNCTION(jsName, cppName, attributes, length, intrinsic) \
1633     putDirectNativeFunction(\
1634         vm, globalObject, makeIdentifier(vm, (jsName)), (length), cppName, \
1635         (intrinsic), (attributes))
1636 
1637 #define JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(jsName, cppName, attributes, length, intrinsic) \
1638     putDirectNativeFunctionWithoutTransition(\
1639         vm, globalObject, makeIdentifier(vm, (jsName)), (length), cppName, \
1640         (intrinsic), (attributes))
1641 
1642 // As above, but this assumes that the function you&#39;re defining doesn&#39;t have an
1643 // intrinsic.
1644 #define JSC_NATIVE_FUNCTION(jsName, cppName, attributes, length) \
1645     JSC_NATIVE_INTRINSIC_FUNCTION(jsName, cppName, (attributes), (length), NoIntrinsic)
1646 
1647 #define JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(jsName, cppName, attributes, length) \
1648     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(jsName, cppName, (attributes), (length), NoIntrinsic)
1649 
1650 // Identical helpers but for builtins. Note that currently, we don&#39;t support builtins that are
</pre>
<hr />
<pre>
1657     putDirectBuiltinFunctionWithoutTransition(\
1658         vm, globalObject, makeIdentifier(vm, (jsName)), (generatorName)(vm), (attributes))
1659 
1660 // Helper for defining native getters on properties.
1661 #define JSC_NATIVE_INTRINSIC_GETTER(jsName, cppName, attributes, intrinsic)  \
1662     putDirectNativeIntrinsicGetter(\
1663         vm, globalObject, makeIdentifier(vm, (jsName)), (cppName), \
1664         (intrinsic), ((attributes) | PropertyAttribute::Accessor))
1665 
1666 #define JSC_NATIVE_INTRINSIC_GETTER_WITHOUT_TRANSITION(jsName, cppName, attributes, intrinsic)  \
1667     putDirectNativeIntrinsicGetterWithoutTransition(\
1668         vm, globalObject, makeIdentifier(vm, (jsName)), (cppName), \
1669         (intrinsic), ((attributes) | PropertyAttribute::Accessor))
1670 
1671 #define JSC_NATIVE_GETTER(jsName, cppName, attributes) \
1672     JSC_NATIVE_INTRINSIC_GETTER((jsName), (cppName), (attributes), NoIntrinsic)
1673 
1674 #define JSC_NATIVE_GETTER_WITHOUT_TRANSITION(jsName, cppName, attributes) \
1675     JSC_NATIVE_INTRINSIC_GETTER_WITHOUT_TRANSITION((jsName), (cppName), (attributes), NoIntrinsic)
1676 





1677 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  38 #include &quot;PropertySlot.h&quot;
  39 #include &quot;PropertyStorage.h&quot;
  40 #include &quot;PutDirectIndexMode.h&quot;
  41 #include &quot;PutPropertySlot.h&quot;
  42 #include &quot;Structure.h&quot;
  43 #include &quot;StructureTransitionTable.h&quot;
  44 #include &quot;VM.h&quot;
  45 #include &quot;JSString.h&quot;
  46 #include &quot;SparseArrayValueMap.h&quot;
  47 #include &lt;wtf/StdLibExtras.h&gt;
  48 
  49 namespace JSC {
  50 namespace DOMJIT {
  51 class Signature;
  52 }
  53 
  54 inline JSCell* getJSFunction(JSValue value)
  55 {
  56     if (value.isCell() &amp;&amp; (value.asCell()-&gt;type() == JSFunctionType))
  57         return value.asCell();
<span class="line-modified">  58     return nullptr;</span>
  59 }
  60 
  61 class Exception;
  62 class GetterSetter;
  63 class InternalFunction;
  64 class JSFunction;
  65 class LLIntOffsetsExtractor;
  66 class MarkedBlock;
  67 class PropertyDescriptor;
  68 class PropertyNameArray;
  69 class Structure;
  70 class ThrowScope;
  71 struct HashTable;
  72 struct HashTableValue;
  73 
<span class="line-modified">  74 JS_EXPORT_PRIVATE Exception* throwTypeError(JSGlobalObject*, ThrowScope&amp;, const String&amp;);</span>
  75 extern JS_EXPORT_PRIVATE const ASCIILiteral NonExtensibleObjectPropertyDefineError;
  76 extern JS_EXPORT_PRIVATE const ASCIILiteral ReadonlyPropertyWriteError;
  77 extern JS_EXPORT_PRIVATE const ASCIILiteral ReadonlyPropertyChangeError;
  78 extern JS_EXPORT_PRIVATE const ASCIILiteral UnableToDeletePropertyError;
  79 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeAccessMechanismError;
  80 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeConfigurabilityError;
  81 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeEnumerabilityError;
  82 extern JS_EXPORT_PRIVATE const ASCIILiteral UnconfigurablePropertyChangeWritabilityError;
  83 
  84 COMPILE_ASSERT(PropertyAttribute::None &lt; FirstInternalAttribute, None_is_below_FirstInternalAttribute);
  85 COMPILE_ASSERT(PropertyAttribute::ReadOnly &lt; FirstInternalAttribute, ReadOnly_is_below_FirstInternalAttribute);
  86 COMPILE_ASSERT(PropertyAttribute::DontEnum &lt; FirstInternalAttribute, DontEnum_is_below_FirstInternalAttribute);
  87 COMPILE_ASSERT(PropertyAttribute::DontDelete &lt; FirstInternalAttribute, DontDelete_is_below_FirstInternalAttribute);
  88 COMPILE_ASSERT(PropertyAttribute::Accessor &lt; FirstInternalAttribute, Accessor_is_below_FirstInternalAttribute);
  89 
  90 class JSFinalObject;
  91 
  92 class JSObject : public JSCell {
  93     friend class BatchedTransitionOptimizer;
  94     friend class JIT;
  95     friend class JSCell;
  96     friend class JSFinalObject;
  97     friend class MarkedBlock;
  98     JS_EXPORT_PRIVATE friend bool setUpStaticFunctionSlot(VM&amp;, const HashTableValue*, JSObject*, PropertyName, PropertySlot&amp;);
  99 
 100     enum PutMode {
 101         PutModePut,
 102         PutModeDefineOwnProperty,
 103     };
 104 
 105 public:
<span class="line-modified"> 106     using Base = JSCell;</span>
<span class="line-added"> 107 </span>
<span class="line-added"> 108     // Don&#39;t call this directly. Call JSC::subspaceFor&lt;Type&gt;(vm) instead.</span>
<span class="line-added"> 109     // FIXME: Refer to Subspace by reference.</span>
<span class="line-added"> 110     // https://bugs.webkit.org/show_bug.cgi?id=166988</span>
<span class="line-added"> 111     template&lt;typename CellType, SubspaceAccess&gt;</span>
<span class="line-added"> 112     static CompleteSubspace* subspaceFor(VM&amp;);</span>
 113 
 114     // This is a super dangerous method for JITs. Sometimes the JITs will want to create either a
 115     // JSFinalObject or a JSArray. This is the method that will do that.
<span class="line-modified"> 116     static JSObject* createRawObject(VM&amp; vm, Structure* structure, Butterfly* = nullptr);</span>
 117 
 118     JS_EXPORT_PRIVATE static size_t estimatedSize(JSCell*, VM&amp;);
 119     JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&amp;);
 120     JS_EXPORT_PRIVATE static void analyzeHeap(JSCell*, HeapAnalyzer&amp;);
 121 
 122     JS_EXPORT_PRIVATE static String className(const JSObject*, VM&amp;);
 123     JS_EXPORT_PRIVATE static String calculatedClassName(JSObject*);
 124 
 125     // This function is what Object.prototype.toString() will use to get the name of
 126     // an object when using Symbol.toStringTag fails. For the most part there is no
 127     // difference between this and className(). The main use case is for new JS language
 128     // objects to set the default tag to &quot;Object&quot;.
<span class="line-modified"> 129     JS_EXPORT_PRIVATE static String toStringName(const JSObject*, JSGlobalObject*);</span>
 130 
 131     // This is the fully virtual [[GetPrototypeOf]] internal function defined
 132     // in the ECMAScript 6 specification. Use this when doing a [[GetPrototypeOf]]
 133     // operation as dictated in the specification.
<span class="line-modified"> 134     JSValue getPrototype(VM&amp;, JSGlobalObject*);</span>
<span class="line-modified"> 135     JS_EXPORT_PRIVATE static JSValue getPrototype(JSObject*, JSGlobalObject*);</span>
 136     // This gets the prototype directly off of the structure. This does not do
 137     // dynamic dispatch on the getPrototype method table method. It is not valid
 138     // to use this when performing a [[GetPrototypeOf]] operation in the specification.
 139     // It is valid to use though when you know that you want to directly get it
 140     // without consulting the method table. This is akin to getting the [[Prototype]]
 141     // internal field directly as described in the specification.
 142     JSValue getPrototypeDirect(VM&amp;) const;
 143 
 144     // This sets the prototype without checking for cycles and without
 145     // doing dynamic dispatch on [[SetPrototypeOf]] operation in the specification.
 146     // It is not valid to use this when performing a [[SetPrototypeOf]] operation in
 147     // the specification. It is valid to use though when you know that you want to directly
 148     // set it without consulting the method table and when you definitely won&#39;t
 149     // introduce a cycle in the prototype chain. This is akin to setting the
 150     // [[Prototype]] internal field directly as described in the specification.
 151     JS_EXPORT_PRIVATE void setPrototypeDirect(VM&amp;, JSValue prototype);
 152 private:
 153     // This is OrdinarySetPrototypeOf in the specification. Section 9.1.2.1
 154     // https://tc39.github.io/ecma262/#sec-ordinarysetprototypeof
<span class="line-modified"> 155     JS_EXPORT_PRIVATE bool setPrototypeWithCycleCheck(VM&amp;, JSGlobalObject*, JSValue prototype, bool shouldThrowIfCantSet);</span>
 156 public:
 157     // This is the fully virtual [[SetPrototypeOf]] internal function defined
 158     // in the ECMAScript 6 specification. Use this when doing a [[SetPrototypeOf]]
 159     // operation as dictated in the specification.
<span class="line-modified"> 160     bool setPrototype(VM&amp;, JSGlobalObject*, JSValue prototype, bool shouldThrowIfCantSet = false);</span>
<span class="line-modified"> 161     JS_EXPORT_PRIVATE static bool setPrototype(JSObject*, JSGlobalObject*, JSValue prototype, bool shouldThrowIfCantSet);</span>
 162 
 163     inline bool mayInterceptIndexedAccesses(VM&amp;);
 164 
<span class="line-modified"> 165     JSValue get(JSGlobalObject*, PropertyName) const;</span>
<span class="line-modified"> 166     JSValue get(JSGlobalObject*, unsigned propertyName) const;</span>
 167 
 168     template&lt;bool checkNullStructure = false&gt;
<span class="line-modified"> 169     bool getPropertySlot(JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified"> 170     bool getPropertySlot(JSGlobalObject*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="line-modified"> 171     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(JSGlobalObject*, PropertyName, CallbackWhenNoException) const;</span>
<span class="line-modified"> 172     template&lt;typename CallbackWhenNoException&gt; typename std::result_of&lt;CallbackWhenNoException(bool, PropertySlot&amp;)&gt;::type getPropertySlot(JSGlobalObject*, PropertyName, PropertySlot&amp;, CallbackWhenNoException) const;</span>
 173 
<span class="line-modified"> 174     static bool getOwnPropertySlot(JSObject*, JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified"> 175     JS_EXPORT_PRIVATE static bool getOwnPropertySlotByIndex(JSObject*, JSGlobalObject*, unsigned propertyName, PropertySlot&amp;);</span>
<span class="line-modified"> 176     bool getOwnPropertySlotInline(JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
<span class="line-modified"> 177     static void doPutPropertySecurityCheck(JSObject*, JSGlobalObject*, PropertyName, PutPropertySlot&amp;);</span>
 178 
 179     // The key difference between this and getOwnPropertySlot is that getOwnPropertySlot
 180     // currently returns incorrect results for the DOM window (with non-own properties)
 181     // being returned. Once this is fixed we should migrate code &amp; remove this method.
<span class="line-modified"> 182     JS_EXPORT_PRIVATE bool getOwnPropertyDescriptor(JSGlobalObject*, PropertyName, PropertyDescriptor&amp;);</span>
 183 
 184     unsigned getArrayLength() const
 185     {
 186         if (!hasIndexedProperties(indexingType()))
 187             return 0;
 188         return m_butterfly-&gt;publicLength();
 189     }
 190 
 191     unsigned getVectorLength()
 192     {
 193         if (!hasIndexedProperties(indexingType()))
 194             return 0;
 195         return m_butterfly-&gt;vectorLength();
 196     }
 197 
<span class="line-modified"> 198     static bool putInlineForJSObject(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
 199 
<span class="line-modified"> 200     JS_EXPORT_PRIVATE static bool put(JSCell*, JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
 201     // putByIndex assumes that the receiver is this JSCell object.
<span class="line-modified"> 202     JS_EXPORT_PRIVATE static bool putByIndex(JSCell*, JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow);</span>
 203 
 204     // This performs the ECMAScript Set() operation.
<span class="line-modified"> 205     ALWAYS_INLINE bool putByIndexInline(JSGlobalObject* globalObject, unsigned propertyName, JSValue value, bool shouldThrow)</span>
 206     {
<span class="line-modified"> 207         VM&amp; vm = getVM(globalObject);</span>
 208         if (canSetIndexQuickly(propertyName, value)) {
 209             setIndexQuickly(vm, propertyName, value);
 210             return true;
 211         }
<span class="line-modified"> 212         return methodTable(vm)-&gt;putByIndex(this, globalObject, propertyName, value, shouldThrow);</span>
 213     }
 214 
 215     // This is similar to the putDirect* methods:
 216     //  - the prototype chain is not consulted
 217     //  - accessors are not called.
 218     //  - it will ignore extensibility and read-only properties if PutDirectIndexLikePutDirect is passed as the mode (the default).
 219     // This method creates a property with attributes writable, enumerable and configurable all set to true if attributes is zero,
 220     // otherwise, it creates a property with the provided attributes. Semantically, this is performing defineOwnProperty.
<span class="line-modified"> 221     bool putDirectIndex(JSGlobalObject* globalObject, unsigned propertyName, JSValue value, unsigned attributes, PutDirectIndexMode mode)</span>
 222     {
 223         ASSERT(!value.isCustomGetterSetter());
 224         auto canSetIndexQuicklyForPutDirect = [&amp;] () -&gt; bool {
 225             switch (indexingMode()) {
 226             case ALL_BLANK_INDEXING_TYPES:
 227             case ALL_UNDECIDED_INDEXING_TYPES:
 228                 return false;
 229             case ALL_WRITABLE_INT32_INDEXING_TYPES:
 230             case ALL_WRITABLE_DOUBLE_INDEXING_TYPES:
 231             case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
 232             case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 233                 return propertyName &lt; m_butterfly-&gt;vectorLength();
 234             default:
 235                 if (isCopyOnWrite(indexingMode()))
 236                     return false;
 237                 RELEASE_ASSERT_NOT_REACHED();
 238                 return false;
 239             }
 240         };
 241 
 242         if (!attributes &amp;&amp; canSetIndexQuicklyForPutDirect()) {
<span class="line-modified"> 243             setIndexQuickly(getVM(globalObject), propertyName, value);</span>
 244             return true;
 245         }
<span class="line-modified"> 246         return putDirectIndexSlowOrBeyondVectorLength(globalObject, propertyName, value, attributes, mode);</span>
 247     }
 248     // This is semantically equivalent to performing defineOwnProperty(propertyName, {configurable:true, writable:true, enumerable:true, value:value}).
<span class="line-modified"> 249     bool putDirectIndex(JSGlobalObject* globalObject, unsigned propertyName, JSValue value)</span>
 250     {
<span class="line-modified"> 251         return putDirectIndex(globalObject, propertyName, value, 0, PutDirectIndexLikePutDirect);</span>
 252     }
 253 
 254     // A generally non-throwing version of putDirect and putDirectIndex.
 255     // However, it&#39;s only guaranteed to not throw based on what the receiver is.
 256     // For example, if the receiver is a ProxyObject, this is not guaranteed, since
 257     // it may call into arbitrary JS code. It&#39;s the responsibility of the user of
 258     // this API to ensure that the receiver object is a well known type if they
 259     // want to ensure that this won&#39;t throw an exception.
<span class="line-modified"> 260     JS_EXPORT_PRIVATE bool putDirectMayBeIndex(JSGlobalObject*, PropertyName, JSValue);</span>
 261 
 262     bool hasIndexingHeader(VM&amp; vm) const
 263     {
 264         return structure(vm)-&gt;hasIndexingHeader(this);
 265     }
 266 
 267     bool canGetIndexQuicklyForTypedArray(unsigned) const;
 268     JSValue getIndexQuicklyForTypedArray(unsigned) const;
 269 
 270     bool canGetIndexQuickly(unsigned i) const
 271     {
 272         const Butterfly* butterfly = this-&gt;butterfly();
 273         switch (indexingType()) {
 274         case ALL_BLANK_INDEXING_TYPES:
 275             return canGetIndexQuicklyForTypedArray(i);
 276         case ALL_UNDECIDED_INDEXING_TYPES:
 277             return false;
 278         case ALL_INT32_INDEXING_TYPES:
 279         case ALL_CONTIGUOUS_INDEXING_TYPES:
 280             return i &lt; butterfly-&gt;vectorLength() &amp;&amp; butterfly-&gt;contiguous().at(this, i);
</pre>
<hr />
<pre>
 337             break;
 338         case ALL_DOUBLE_INDEXING_TYPES: {
 339             if (i &gt;= butterfly-&gt;publicLength())
 340                 break;
 341             double result = butterfly-&gt;contiguousDouble().at(this, i);
 342             if (result != result)
 343                 break;
 344             return JSValue(JSValue::EncodeAsDouble, result);
 345         }
 346         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 347             if (i &lt; butterfly-&gt;arrayStorage()-&gt;vectorLength())
 348                 return butterfly-&gt;arrayStorage()-&gt;m_vector[i].get();
 349             break;
 350         default:
 351             RELEASE_ASSERT_NOT_REACHED();
 352             break;
 353         }
 354         return JSValue();
 355     }
 356 
<span class="line-modified"> 357     JSValue getDirectIndex(JSGlobalObject* globalObject, unsigned i)</span>
 358     {
 359         if (JSValue result = tryGetIndexQuickly(i))
 360             return result;
 361         PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
<span class="line-modified"> 362         if (methodTable(getVM(globalObject))-&gt;getOwnPropertySlotByIndex(this, globalObject, i, slot))</span>
<span class="line-modified"> 363             return slot.getValue(globalObject, i);</span>
 364         return JSValue();
 365     }
 366 
<span class="line-modified"> 367     JSValue getIndex(JSGlobalObject* globalObject, unsigned i) const</span>
 368     {
 369         if (JSValue result = tryGetIndexQuickly(i))
 370             return result;
<span class="line-modified"> 371         return get(globalObject, i);</span>
 372     }
 373 
 374     bool canSetIndexQuicklyForTypedArray(unsigned, JSValue) const;
 375     void setIndexQuicklyForTypedArray(unsigned, JSValue);
 376 
 377     bool canSetIndexQuickly(unsigned i, JSValue value)
 378     {
 379         Butterfly* butterfly = this-&gt;butterfly();
 380         switch (indexingMode()) {
 381         case ALL_BLANK_INDEXING_TYPES:
 382             return canSetIndexQuicklyForTypedArray(i, value);
 383         case ALL_UNDECIDED_INDEXING_TYPES:
 384             return false;
 385         case ALL_WRITABLE_INT32_INDEXING_TYPES:
 386         case ALL_WRITABLE_DOUBLE_INDEXING_TYPES:
 387         case ALL_WRITABLE_CONTIGUOUS_INDEXING_TYPES:
 388         case NonArrayWithArrayStorage:
 389         case ArrayWithArrayStorage:
 390             return i &lt; butterfly-&gt;vectorLength();
 391         case NonArrayWithSlowPutArrayStorage:
</pre>
<hr />
<pre>
 398             RELEASE_ASSERT_NOT_REACHED();
 399             return false;
 400         }
 401     }
 402 
 403     void setIndexQuickly(VM&amp; vm, unsigned i, JSValue v)
 404     {
 405         Butterfly* butterfly = m_butterfly.get();
 406         ASSERT(!isCopyOnWrite(indexingMode()));
 407         switch (indexingType()) {
 408         case ALL_INT32_INDEXING_TYPES: {
 409             ASSERT(i &lt; butterfly-&gt;vectorLength());
 410             if (!v.isInt32()) {
 411                 convertInt32ToDoubleOrContiguousWhilePerformingSetIndex(vm, i, v);
 412                 return;
 413             }
 414             FALLTHROUGH;
 415         }
 416         case ALL_CONTIGUOUS_INDEXING_TYPES: {
 417             ASSERT(i &lt; butterfly-&gt;vectorLength());
<span class="line-modified"> 418             butterfly-&gt;contiguous().at(this, i).setWithoutWriteBarrier(v);</span>
 419             if (i &gt;= butterfly-&gt;publicLength())
 420                 butterfly-&gt;setPublicLength(i + 1);
<span class="line-added"> 421             vm.heap.writeBarrier(this, v);</span>
 422             break;
 423         }
 424         case ALL_DOUBLE_INDEXING_TYPES: {
 425             ASSERT(i &lt; butterfly-&gt;vectorLength());
 426             if (!v.isNumber()) {
 427                 convertDoubleToContiguousWhilePerformingSetIndex(vm, i, v);
 428                 return;
 429             }
 430             double value = v.asNumber();
 431             if (value != value) {
 432                 convertDoubleToContiguousWhilePerformingSetIndex(vm, i, v);
 433                 return;
 434             }
 435             butterfly-&gt;contiguousDouble().at(this, i) = value;
 436             if (i &gt;= butterfly-&gt;publicLength())
 437                 butterfly-&gt;setPublicLength(i + 1);
 438             break;
 439         }
 440         case ALL_ARRAY_STORAGE_INDEXING_TYPES: {
 441             ArrayStorage* storage = butterfly-&gt;arrayStorage();
</pre>
<hr />
<pre>
 592         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 593             return m_butterfly-&gt;arrayStorage()-&gt;inSparseMode();
 594         default:
 595             RELEASE_ASSERT_NOT_REACHED();
 596             return false;
 597         }
 598     }
 599 
 600     void enterDictionaryIndexingMode(VM&amp;);
 601 
 602     // putDirect is effectively an unchecked vesion of &#39;defineOwnProperty&#39;:
 603     //  - the prototype chain is not consulted
 604     //  - accessors are not called.
 605     //  - attributes will be respected (after the call the property will exist with the given attributes)
 606     //  - the property name is assumed to not be an index.
 607     bool putDirect(VM&amp;, PropertyName, JSValue, unsigned attributes = 0);
 608     bool putDirect(VM&amp;, PropertyName, JSValue, PutPropertySlot&amp;);
 609     void putDirectWithoutTransition(VM&amp;, PropertyName, JSValue, unsigned attributes = 0);
 610     bool putDirectNonIndexAccessor(VM&amp;, PropertyName, GetterSetter*, unsigned attributes);
 611     void putDirectNonIndexAccessorWithoutTransition(VM&amp;, PropertyName, GetterSetter*, unsigned attributes);
<span class="line-modified"> 612     bool putDirectAccessor(JSGlobalObject*, PropertyName, GetterSetter*, unsigned attributes);</span>
 613     JS_EXPORT_PRIVATE bool putDirectCustomAccessor(VM&amp;, PropertyName, JSValue, unsigned attributes);
 614 
<span class="line-modified"> 615     bool putGetter(JSGlobalObject*, PropertyName, JSValue, unsigned attributes);</span>
<span class="line-modified"> 616     bool putSetter(JSGlobalObject*, PropertyName, JSValue, unsigned attributes);</span>
 617 
<span class="line-modified"> 618     JS_EXPORT_PRIVATE bool hasProperty(JSGlobalObject*, PropertyName) const;</span>
<span class="line-modified"> 619     JS_EXPORT_PRIVATE bool hasProperty(JSGlobalObject*, unsigned propertyName) const;</span>
<span class="line-modified"> 620     bool hasPropertyGeneric(JSGlobalObject*, PropertyName, PropertySlot::InternalMethodType) const;</span>
<span class="line-modified"> 621     bool hasPropertyGeneric(JSGlobalObject*, unsigned propertyName, PropertySlot::InternalMethodType) const;</span>
<span class="line-modified"> 622     bool hasOwnProperty(JSGlobalObject*, PropertyName, PropertySlot&amp;) const;</span>
<span class="line-modified"> 623     bool hasOwnProperty(JSGlobalObject*, PropertyName) const;</span>
<span class="line-modified"> 624     bool hasOwnProperty(JSGlobalObject*, unsigned) const;</span>
 625 
<span class="line-modified"> 626     JS_EXPORT_PRIVATE static bool deleteProperty(JSCell*, JSGlobalObject*, PropertyName);</span>
<span class="line-modified"> 627     JS_EXPORT_PRIVATE static bool deletePropertyByIndex(JSCell*, JSGlobalObject*, unsigned propertyName);</span>
 628 
<span class="line-modified"> 629     JS_EXPORT_PRIVATE static JSValue defaultValue(const JSObject*, JSGlobalObject*, PreferredPrimitiveType);</span>
<span class="line-modified"> 630     JSValue ordinaryToPrimitive(JSGlobalObject*, PreferredPrimitiveType) const;</span>
 631 
<span class="line-modified"> 632     JS_EXPORT_PRIVATE bool hasInstance(JSGlobalObject*, JSValue value, JSValue hasInstanceValue);</span>
<span class="line-modified"> 633     JS_EXPORT_PRIVATE bool hasInstance(JSGlobalObject*, JSValue);</span>
<span class="line-modified"> 634     static bool defaultHasInstance(JSGlobalObject*, JSValue, JSValue prototypeProperty);</span>
 635 
<span class="line-modified"> 636     JS_EXPORT_PRIVATE static void getOwnPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified"> 637     JS_EXPORT_PRIVATE static void getOwnNonIndexPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified"> 638     JS_EXPORT_PRIVATE static void getPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
 639 
<span class="line-modified"> 640     JS_EXPORT_PRIVATE static uint32_t getEnumerableLength(JSGlobalObject*, JSObject*);</span>
<span class="line-modified"> 641     JS_EXPORT_PRIVATE static void getStructurePropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
<span class="line-modified"> 642     JS_EXPORT_PRIVATE static void getGenericPropertyNames(JSObject*, JSGlobalObject*, PropertyNameArray&amp;, EnumerationMode);</span>
 643 
<span class="line-modified"> 644     JS_EXPORT_PRIVATE JSValue toPrimitive(JSGlobalObject*, PreferredPrimitiveType = NoPreference) const;</span>
<span class="line-modified"> 645     bool getPrimitiveNumber(JSGlobalObject*, double&amp; number, JSValue&amp;) const;</span>
<span class="line-modified"> 646     JS_EXPORT_PRIVATE double toNumber(JSGlobalObject*) const;</span>
<span class="line-modified"> 647     JS_EXPORT_PRIVATE JSString* toString(JSGlobalObject*) const;</span>
 648 
<span class="line-modified"> 649     JS_EXPORT_PRIVATE static JSValue toThis(JSCell*, JSGlobalObject*, ECMAMode);</span>
 650 
 651     // This get function only looks at the property map.
 652     JSValue getDirect(VM&amp; vm, PropertyName propertyName) const
 653     {
 654         Structure* structure = this-&gt;structure(vm);
 655         PropertyOffset offset = structure-&gt;get(vm, propertyName);
 656         checkOffset(offset, structure-&gt;inlineCapacity());
 657         return offset != invalidOffset ? getDirect(offset) : JSValue();
 658     }
 659 
 660     JSValue getDirect(VM&amp; vm, PropertyName propertyName, unsigned&amp; attributes) const
 661     {
 662         Structure* structure = this-&gt;structure(vm);
 663         PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);
 664         checkOffset(offset, structure-&gt;inlineCapacity());
 665         return offset != invalidOffset ? getDirect(offset) : JSValue();
 666     }
 667 
 668     PropertyOffset getDirectOffset(VM&amp; vm, PropertyName propertyName)
 669     {
</pre>
<hr />
<pre>
 716 
 717     ALWAYS_INLINE WriteBarrierBase&lt;Unknown&gt;* locationForOffset(PropertyOffset offset)
 718     {
 719         if (isInlineOffset(offset))
 720             return &amp;inlineStorage()[offsetInInlineStorage(offset)];
 721         return &amp;outOfLineStorage()[offsetInOutOfLineStorage(offset)];
 722     }
 723 
 724     void transitionTo(VM&amp;, Structure*);
 725 
 726     bool hasCustomProperties(VM&amp; vm) { return structure(vm)-&gt;didTransition(); }
 727     bool hasGetterSetterProperties(VM&amp; vm) { return structure(vm)-&gt;hasGetterSetterProperties(); }
 728     bool hasCustomGetterSetterProperties(VM&amp; vm) { return structure(vm)-&gt;hasCustomGetterSetterProperties(); }
 729 
 730     // putOwnDataProperty has &#39;put&#39; like semantics, however this method:
 731     //  - assumes the object contains no own getter/setter properties.
 732     //  - provides no special handling for __proto__
 733     //  - does not walk the prototype chain (to check for accessors or non-writable properties).
 734     // This is used by JSLexicalEnvironment.
 735     bool putOwnDataProperty(VM&amp;, PropertyName, JSValue, PutPropertySlot&amp;);
<span class="line-modified"> 736     bool putOwnDataPropertyMayBeIndex(JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
<span class="line-added"> 737 private:</span>
<span class="line-added"> 738     void validatePutOwnDataProperty(VM&amp;, PropertyName, JSValue);</span>
<span class="line-added"> 739 public:</span>
 740 
 741     // Fast access to known property offsets.
 742     ALWAYS_INLINE JSValue getDirect(PropertyOffset offset) const { return locationForOffset(offset)-&gt;get(); }
 743     JSValue getDirectConcurrently(Structure* expectedStructure, PropertyOffset) const;
 744     void putDirect(VM&amp; vm, PropertyOffset offset, JSValue value) { locationForOffset(offset)-&gt;set(vm, this, value); }
 745     void putDirectWithoutBarrier(PropertyOffset offset, JSValue value) { locationForOffset(offset)-&gt;setWithoutWriteBarrier(value); }
 746     void putDirectUndefined(PropertyOffset offset) { locationForOffset(offset)-&gt;setUndefined(); }
 747 
 748     JS_EXPORT_PRIVATE bool putDirectNativeIntrinsicGetter(VM&amp;, JSGlobalObject*, Identifier, NativeFunction, Intrinsic, unsigned attributes);
 749     JS_EXPORT_PRIVATE void putDirectNativeIntrinsicGetterWithoutTransition(VM&amp;, JSGlobalObject*, Identifier, NativeFunction, Intrinsic, unsigned attributes);
 750     JS_EXPORT_PRIVATE bool putDirectNativeFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, unsigned attributes);
 751     JS_EXPORT_PRIVATE bool putDirectNativeFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, const DOMJIT::Signature*, unsigned attributes);
 752     JS_EXPORT_PRIVATE void putDirectNativeFunctionWithoutTransition(VM&amp;, JSGlobalObject*, const PropertyName&amp;, unsigned functionLength, NativeFunction, Intrinsic, unsigned attributes);
 753 
 754     JS_EXPORT_PRIVATE JSFunction* putDirectBuiltinFunction(VM&amp;, JSGlobalObject*, const PropertyName&amp;, FunctionExecutable*, unsigned attributes);
 755     JSFunction* putDirectBuiltinFunctionWithoutTransition(VM&amp;, JSGlobalObject*, const PropertyName&amp;, FunctionExecutable*, unsigned attributes);
 756 
<span class="line-modified"> 757     JS_EXPORT_PRIVATE static bool defineOwnProperty(JSObject*, JSGlobalObject*, PropertyName, const PropertyDescriptor&amp;, bool shouldThrow);</span>
 758 
 759     bool isEnvironment() const;
 760     bool isGlobalObject() const;
 761     bool isJSLexicalEnvironment() const;
 762     bool isGlobalLexicalEnvironment() const;
 763     bool isStrictEvalActivation() const;
 764     bool isWithScope() const;
 765 
 766     bool isErrorInstance() const;
 767 
 768     JS_EXPORT_PRIVATE void seal(VM&amp;);
 769     JS_EXPORT_PRIVATE void freeze(VM&amp;);
<span class="line-modified"> 770     JS_EXPORT_PRIVATE static bool preventExtensions(JSObject*, JSGlobalObject*);</span>
<span class="line-modified"> 771     JS_EXPORT_PRIVATE static bool isExtensible(JSObject*, JSGlobalObject*);</span>
 772     bool isSealed(VM&amp; vm) { return structure(vm)-&gt;isSealed(vm); }
 773     bool isFrozen(VM&amp; vm) { return structure(vm)-&gt;isFrozen(vm); }
 774 
 775     JS_EXPORT_PRIVATE bool anyObjectInChainMayInterceptIndexedAccesses(VM&amp;) const;
 776     JS_EXPORT_PRIVATE bool prototypeChainMayInterceptStoreTo(VM&amp;, PropertyName);
 777     bool needsSlowPutIndexing(VM&amp;) const;
 778 
 779 private:
 780     NonPropertyTransition suggestedArrayStorageTransition(VM&amp;) const;
 781 public:
 782     // You should only call isStructureExtensible() when:
 783     // - Performing this check in a way that isn&#39;t described in the specification
 784     //   as calling the virtual [[IsExtensible]] trap.
 785     // - When you&#39;re guaranteed that object-&gt;methodTable(vm)-&gt;isExtensible isn&#39;t
 786     //   overridden.
 787     ALWAYS_INLINE bool isStructureExtensible(VM&amp; vm) { return structure(vm)-&gt;isStructureExtensible(); }
 788     // You should call this when performing [[IsExtensible]] trap in a place
 789     // that is described in the specification. This performs the fully virtual
 790     // [[IsExtensible]] trap.
<span class="line-modified"> 791     bool isExtensible(JSGlobalObject*);</span>
 792     bool indexingShouldBeSparse(VM&amp; vm)
 793     {
 794         return !isStructureExtensible(vm)
 795             || structure(vm)-&gt;typeInfo().interceptsGetOwnPropertySlotByIndexEvenWhenLengthIsNotZero();
 796     }
 797 
 798     bool staticPropertiesReified(VM&amp; vm) { return structure(vm)-&gt;staticPropertiesReified(); }
<span class="line-modified"> 799     void reifyAllStaticProperties(JSGlobalObject*);</span>
 800 
 801     JS_EXPORT_PRIVATE Butterfly* allocateMoreOutOfLineStorage(VM&amp;, size_t oldSize, size_t newSize);
 802 
 803     // Call this when you do not need to change the structure.
 804     void setButterfly(VM&amp;, Butterfly*);
 805 
 806     // Call this if you do need to change the structure, or if you changed something about a structure
 807     // in-place.
 808     void nukeStructureAndSetButterfly(VM&amp;, StructureID oldStructureID, Butterfly*);
 809 
 810     void setStructure(VM&amp;, Structure*);
 811 
 812     JS_EXPORT_PRIVATE void convertToDictionary(VM&amp;);
 813 
 814     void flattenDictionaryObject(VM&amp; vm)
 815     {
 816         structure(vm)-&gt;flattenDictionaryStructure(vm, this);
 817     }
 818     void shiftButterflyAfterFlattening(const GCSafeConcurrentJSLocker&amp;, VM&amp;, Structure* structure, size_t outOfLineCapacityAfter);
 819 
</pre>
<hr />
<pre>
 823         ASSERT(!isGlobalObject() || ((JSObject*)structure()-&gt;globalObject()) == this);
 824         return structure()-&gt;globalObject();
 825     }
 826 
 827     JSGlobalObject* globalObject(VM&amp; vm) const
 828     {
 829         ASSERT(structure(vm)-&gt;globalObject());
 830         ASSERT(!isGlobalObject() || ((JSObject*)structure(vm)-&gt;globalObject()) == this);
 831         return structure(vm)-&gt;globalObject();
 832     }
 833 
 834     void switchToSlowPutArrayStorage(VM&amp;);
 835 
 836     // The receiver is the prototype in this case. The following:
 837     //
 838     // asObject(foo-&gt;structure()-&gt;storedPrototype())-&gt;attemptToInterceptPutByIndexOnHoleForPrototype(...)
 839     //
 840     // is equivalent to:
 841     //
 842     // foo-&gt;attemptToInterceptPutByIndexOnHole(...);
<span class="line-modified"> 843     bool attemptToInterceptPutByIndexOnHoleForPrototype(JSGlobalObject*, JSValue thisValue, unsigned propertyName, JSValue, bool shouldThrow, bool&amp; putResult);</span>
 844 
 845     // Returns 0 if int32 storage cannot be created - either because
 846     // indexing should be sparse, we&#39;re having a bad time, or because
 847     // we already have a more general form of storage (double,
 848     // contiguous, array storage).
 849     ContiguousJSValues tryMakeWritableInt32(VM&amp; vm)
 850     {
 851         if (LIKELY(hasInt32(indexingType()) &amp;&amp; !isCopyOnWrite(indexingMode())))
 852             return m_butterfly-&gt;contiguousInt32();
 853 
 854         return tryMakeWritableInt32Slow(vm);
 855     }
 856 
 857     // Returns 0 if double storage cannot be created - either because
 858     // indexing should be sparse, we&#39;re having a bad time, or because
 859     // we already have a more general form of storage (contiguous,
 860     // or array storage).
 861     ContiguousDoubles tryMakeWritableDouble(VM&amp; vm)
 862     {
 863         if (LIKELY(hasDouble(indexingType()) &amp;&amp; !isCopyOnWrite(indexingMode())))
</pre>
<hr />
<pre>
 888         return ensureArrayStorageSlow(vm);
 889     }
 890 
 891     void ensureWritable(VM&amp; vm)
 892     {
 893         if (isCopyOnWrite(indexingMode()))
 894             convertFromCopyOnWrite(vm);
 895     }
 896 
 897     static size_t offsetOfInlineStorage();
 898 
 899     static ptrdiff_t butterflyOffset()
 900     {
 901         return OBJECT_OFFSETOF(JSObject, m_butterfly);
 902     }
 903     void* butterflyAddress()
 904     {
 905         return &amp;m_butterfly;
 906     }
 907 
<span class="line-modified"> 908     JS_EXPORT_PRIVATE JSValue getMethod(JSGlobalObject*, CallData&amp;, CallType&amp;, const Identifier&amp;, const String&amp; errorMessage);</span>
 909 
 910     bool canPerformFastPutInline(VM&amp;, PropertyName);
 911     bool canPerformFastPutInlineExcludingProto(VM&amp;);
 912 
 913     bool mayBePrototype() const;
 914     void didBecomePrototype();
 915 
<span class="line-added"> 916     Optional&lt;Structure::PropertyHashEntry&gt; findPropertyHashEntry(VM&amp;, PropertyName) const;</span>
<span class="line-added"> 917 </span>
 918     DECLARE_EXPORT_INFO;
 919 
 920 protected:
 921     void finishCreation(VM&amp; vm)
 922     {
 923         Base::finishCreation(vm);
 924         ASSERT(jsDynamicCast&lt;JSObject*&gt;(vm, this));
 925         ASSERT(structure(vm)-&gt;hasPolyProto() || getPrototypeDirect(vm).isNull() || Heap::heap(this) == Heap::heap(getPrototypeDirect(vm)));
 926         ASSERT(structure(vm)-&gt;isObject());
 927         ASSERT(classInfo(vm));
 928     }
 929 
 930     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 931     {
 932         return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 933     }
 934 
 935     // To instantiate objects you likely want JSFinalObject, below.
 936     // To create derived types you likely want JSNonFinalObject, below.
 937     JSObject(VM&amp;, Structure*, Butterfly* = nullptr);
 938 
 939     // Visits the butterfly unless there is a race. Returns the structure if there was no race.
 940     Structure* visitButterfly(SlotVisitor&amp;);
 941 
 942     Structure* visitButterflyImpl(SlotVisitor&amp;);
 943 
<span class="line-modified"> 944     void markAuxiliaryAndVisitOutOfLineProperties(SlotVisitor&amp;, Butterfly*, Structure*, PropertyOffset maxOffset);</span>
 945 
 946     // Call this if you know that the object is in a mode where it has array
 947     // storage. This will assert otherwise.
 948     ArrayStorage* arrayStorage()
 949     {
 950         ASSERT(hasAnyArrayStorage(indexingType()));
 951         return m_butterfly-&gt;arrayStorage();
 952     }
 953 
 954     // Call this if you want to predicate some actions on whether or not the
 955     // object is in a mode where it has array storage.
 956     ArrayStorage* arrayStorageOrNull()
 957     {
 958         switch (indexingType()) {
 959         case ALL_ARRAY_STORAGE_INDEXING_TYPES:
 960             return m_butterfly-&gt;arrayStorage();
 961 
 962         default:
 963             return 0;
 964         }
</pre>
<hr />
<pre>
 986     ContiguousDoubles convertUndecidedToDouble(VM&amp;);
 987     ContiguousJSValues convertUndecidedToContiguous(VM&amp;);
 988     ArrayStorage* convertUndecidedToArrayStorage(VM&amp;, NonPropertyTransition);
 989     ArrayStorage* convertUndecidedToArrayStorage(VM&amp;);
 990 
 991     ContiguousDoubles convertInt32ToDouble(VM&amp;);
 992     ContiguousJSValues convertInt32ToContiguous(VM&amp;);
 993     ArrayStorage* convertInt32ToArrayStorage(VM&amp;, NonPropertyTransition);
 994     ArrayStorage* convertInt32ToArrayStorage(VM&amp;);
 995 
 996     ContiguousJSValues convertDoubleToContiguous(VM&amp;);
 997     ArrayStorage* convertDoubleToArrayStorage(VM&amp;, NonPropertyTransition);
 998     ArrayStorage* convertDoubleToArrayStorage(VM&amp;);
 999 
1000     ArrayStorage* convertContiguousToArrayStorage(VM&amp;, NonPropertyTransition);
1001     ArrayStorage* convertContiguousToArrayStorage(VM&amp;);
1002 
1003 
1004     ArrayStorage* ensureArrayStorageExistsAndEnterDictionaryIndexingMode(VM&amp;);
1005 
<span class="line-modified">1006     bool defineOwnNonIndexProperty(JSGlobalObject*, PropertyName, const PropertyDescriptor&amp;, bool throwException);</span>
1007 
1008     template&lt;IndexingType indexingShape&gt;
<span class="line-modified">1009     bool putByIndexBeyondVectorLengthWithoutAttributes(JSGlobalObject*, unsigned propertyName, JSValue);</span>
<span class="line-modified">1010     bool putByIndexBeyondVectorLengthWithArrayStorage(JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow, ArrayStorage*);</span>
1011 
1012     bool increaseVectorLength(VM&amp;, unsigned newLength);
1013     void deallocateSparseIndexMap();
<span class="line-modified">1014     bool defineOwnIndexedProperty(JSGlobalObject*, unsigned, const PropertyDescriptor&amp;, bool throwException);</span>
1015     SparseArrayValueMap* allocateSparseIndexMap(VM&amp;);
1016 
1017     void notifyPresenceOfIndexedAccessors(VM&amp;);
1018 
<span class="line-modified">1019     bool attemptToInterceptPutByIndexOnHole(JSGlobalObject*, unsigned index, JSValue, bool shouldThrow, bool&amp; putResult);</span>
1020 
1021     // Call this if you want setIndexQuickly to succeed and you&#39;re sure that
1022     // the array is contiguous.
1023     bool WARN_UNUSED_RETURN ensureLength(VM&amp; vm, unsigned length)
1024     {
1025         RELEASE_ASSERT(length &lt;= MAX_STORAGE_VECTOR_LENGTH);
1026         ASSERT(hasContiguous(indexingType()) || hasInt32(indexingType()) || hasDouble(indexingType()) || hasUndecided(indexingType()));
1027 
1028         if (m_butterfly-&gt;vectorLength() &lt; length || isCopyOnWrite(indexingMode())) {
1029             if (!ensureLengthSlow(vm, length))
1030                 return false;
1031         }
1032 
1033         if (m_butterfly-&gt;publicLength() &lt; length)
1034             m_butterfly-&gt;setPublicLength(length);
1035         return true;
1036     }
1037 
1038     // Call this if you want to shrink the butterfly backing store, and you&#39;re
1039     // sure that the array is contiguous.
1040     void reallocateAndShrinkButterfly(VM&amp;, unsigned length);
1041 
1042     template&lt;IndexingType indexingShape&gt;
1043     unsigned countElements(Butterfly*);
1044 
1045     // This is relevant to undecided, int32, double, and contiguous.
1046     unsigned countElements();
1047 
1048 private:
1049     friend class LLIntOffsetsExtractor;
1050     friend class VMInspector;
1051 
1052     // Nobody should ever ask any of these questions on something already known to be a JSObject.
1053     using JSCell::isAPIValueWrapper;
1054     using JSCell::isGetterSetter;
1055     void getObject();
<span class="line-modified">1056     void getString(JSGlobalObject* globalObject);</span>
1057     void isObject();
1058     void isString();
1059 
1060     Butterfly* createInitialIndexedStorage(VM&amp;, unsigned length);
1061 
1062     ArrayStorage* enterDictionaryIndexingModeWhenArrayStorageAlreadyExists(VM&amp;, ArrayStorage*);
1063 
1064     template&lt;PutMode&gt;
1065     bool putDirectInternal(VM&amp;, PropertyName, JSValue, unsigned attr, PutPropertySlot&amp;);
1066 
<span class="line-modified">1067     JS_EXPORT_PRIVATE NEVER_INLINE bool putInlineSlow(JSGlobalObject*, PropertyName, JSValue, PutPropertySlot&amp;);</span>
1068 
<span class="line-modified">1069     bool getNonIndexPropertySlot(JSGlobalObject*, PropertyName, PropertySlot&amp;);</span>
1070     bool getOwnNonIndexPropertySlot(VM&amp;, Structure*, PropertyName, PropertySlot&amp;);
1071     JS_EXPORT_PRIVATE void fillGetterPropertySlot(VM&amp;, PropertySlot&amp;, JSCell*, unsigned, PropertyOffset);
1072     void fillCustomGetterPropertySlot(VM&amp;, PropertySlot&amp;, CustomGetterSetter*, unsigned, Structure*);
1073 
1074     JS_EXPORT_PRIVATE bool getOwnStaticPropertySlot(VM&amp;, PropertyName, PropertySlot&amp;);





1075 
<span class="line-modified">1076     bool putByIndexBeyondVectorLength(JSGlobalObject*, unsigned propertyName, JSValue, bool shouldThrow);</span>
<span class="line-modified">1077     bool putDirectIndexBeyondVectorLengthWithArrayStorage(JSGlobalObject*, unsigned propertyName, JSValue, unsigned attributes, PutDirectIndexMode, ArrayStorage*);</span>
<span class="line-modified">1078     JS_EXPORT_PRIVATE bool putDirectIndexSlowOrBeyondVectorLength(JSGlobalObject*, unsigned propertyName, JSValue, unsigned attributes, PutDirectIndexMode);</span>
1079 
1080     unsigned getNewVectorLength(VM&amp;, unsigned indexBias, unsigned currentVectorLength, unsigned currentLength, unsigned desiredLength);
1081     unsigned getNewVectorLength(VM&amp;, unsigned desiredLength);
1082 
1083     ArrayStorage* constructConvertedArrayStorageWithoutCopyingElements(VM&amp;, unsigned neededLength);
1084 
1085     JS_EXPORT_PRIVATE void setIndexQuicklyToUndecided(VM&amp;, unsigned index, JSValue);
1086     JS_EXPORT_PRIVATE void convertInt32ToDoubleOrContiguousWhilePerformingSetIndex(VM&amp;, unsigned index, JSValue);
1087     JS_EXPORT_PRIVATE void convertDoubleToContiguousWhilePerformingSetIndex(VM&amp;, unsigned index, JSValue);
1088 
1089     bool ensureLengthSlow(VM&amp;, unsigned length);
1090 
1091     ContiguousJSValues tryMakeWritableInt32Slow(VM&amp;);
1092     ContiguousDoubles tryMakeWritableDoubleSlow(VM&amp;);
1093     ContiguousJSValues tryMakeWritableContiguousSlow(VM&amp;);
1094     JS_EXPORT_PRIVATE ArrayStorage* ensureArrayStorageSlow(VM&amp;);
1095 
1096     PropertyOffset prepareToPutDirectWithoutTransition(VM&amp;, PropertyName, unsigned attributes, StructureID, Structure*);
1097 
1098     AuxiliaryBarrier&lt;Butterfly*&gt; m_butterfly;
</pre>
<hr />
<pre>
1121     {
1122     }
1123 
1124     void finishCreation(VM&amp; vm)
1125     {
1126         Base::finishCreation(vm);
1127         ASSERT(!this-&gt;structure(vm)-&gt;hasInlineStorage());
1128         ASSERT(classInfo(vm));
1129     }
1130 };
1131 
1132 class JSFinalObject;
1133 
1134 // JSFinalObject is a type of JSObject that contains sufficient internal
1135 // storage to fully make use of the collector cell containing it.
1136 class JSFinalObject final : public JSObject {
1137     friend class JSObject;
1138 
1139 public:
1140     typedef JSObject Base;
<span class="line-modified">1141     static constexpr unsigned StructureFlags = Base::StructureFlags;</span>
1142 
1143     static size_t allocationSize(Checked&lt;size_t&gt; inlineCapacity)
1144     {
1145         return (sizeof(JSObject) + inlineCapacity * sizeof(WriteBarrierBase&lt;Unknown&gt;)).unsafeGet();
1146     }
1147 
1148     static inline const TypeInfo typeInfo() { return TypeInfo(FinalObjectType, StructureFlags); }
<span class="line-modified">1149     static constexpr IndexingType defaultIndexingType = NonArray;</span>
1150 
<span class="line-modified">1151     static constexpr unsigned defaultSize = 64;</span>
1152     static inline unsigned defaultInlineCapacity()
1153     {
1154         return (defaultSize - allocationSize(0)) / sizeof(WriteBarrier&lt;Unknown&gt;);
1155     }
1156 
<span class="line-modified">1157     static constexpr unsigned maxSize = 512;</span>
1158     static inline unsigned maxInlineCapacity()
1159     {
1160         return (maxSize - allocationSize(0)) / sizeof(WriteBarrier&lt;Unknown&gt;);
1161     }
1162 
<span class="line-modified">1163     static JSFinalObject* create(VM&amp;, Structure*, Butterfly* = nullptr);</span>

1164     static Structure* createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, unsigned inlineCapacity)
1165     {
1166         return Structure::create(vm, globalObject, prototype, typeInfo(), info(), defaultIndexingType, inlineCapacity);
1167     }
1168 
1169     JS_EXPORT_PRIVATE static void visitChildren(JSCell*, SlotVisitor&amp;);
1170 
1171     DECLARE_EXPORT_INFO;
1172 
1173 protected:
1174     void visitChildrenCommon(SlotVisitor&amp;);
1175 
1176     void finishCreation(VM&amp; vm)
1177     {
1178         Base::finishCreation(vm);
1179         ASSERT(structure(vm)-&gt;totalStorageCapacity() == structure(vm)-&gt;inlineCapacity());
1180         ASSERT(classInfo(vm));
1181     }
1182 
1183 private:
1184     friend class LLIntOffsetsExtractor;
1185 
1186     explicit JSFinalObject(VM&amp; vm, Structure* structure, Butterfly* butterfly = nullptr)
1187         : JSObject(vm, structure, butterfly)
1188     {
<span class="line-modified">1189         gcSafeZeroMemory(inlineStorageUnsafe(), structure-&gt;inlineCapacity() * sizeof(EncodedJSValue));</span>
1190     }
1191 };
1192 
<span class="line-modified">1193 JS_EXPORT_PRIVATE EncodedJSValue JSC_HOST_CALL objectPrivateFuncInstanceOf(JSGlobalObject*, CallFrame*);</span>
1194 
<span class="line-modified">1195 inline JSObject* JSObject::createRawObject(VM&amp; vm, Structure* structure, Butterfly* butterfly)</span>

1196 {

1197     JSObject* finalObject = new (
1198         NotNull,
1199         allocateCell&lt;JSFinalObject&gt;(
1200             vm.heap,
1201             JSFinalObject::allocationSize(structure-&gt;inlineCapacity())
1202         )
1203     ) JSObject(vm, structure, butterfly);
1204     finalObject-&gt;finishCreation(vm);
1205     return finalObject;
1206 }
1207 
<span class="line-modified">1208 inline JSFinalObject* JSFinalObject::create(VM&amp; vm, Structure* structure, Butterfly* butterfly)</span>

1209 {

1210     JSFinalObject* finalObject = new (
1211         NotNull,
1212         allocateCell&lt;JSFinalObject&gt;(
1213             vm.heap,
1214             allocationSize(structure-&gt;inlineCapacity())
1215         )
1216     ) JSFinalObject(vm, structure, butterfly);
1217     finalObject-&gt;finishCreation(vm);
1218     return finalObject;
1219 }
1220 







1221 inline size_t JSObject::offsetOfInlineStorage()
1222 {
1223     return sizeof(JSObject);
1224 }
1225 
1226 inline bool JSObject::isGlobalObject() const
1227 {
1228     return type() == GlobalObjectType;
1229 }
1230 
1231 inline bool JSObject::isJSLexicalEnvironment() const
1232 {
1233     return type() == LexicalEnvironmentType || type() == ModuleEnvironmentType;
1234 }
1235 
1236 inline bool JSObject::isGlobalLexicalEnvironment() const
1237 {
1238     return type() == GlobalLexicalEnvironmentType;
1239 }
1240 
</pre>
<hr />
<pre>
1275         WTF::storeStoreFence();
1276         return;
1277     }
1278 
1279     m_butterfly.set(vm, this, butterfly);
1280 }
1281 
1282 inline void JSObject::nukeStructureAndSetButterfly(VM&amp; vm, StructureID oldStructureID, Butterfly* butterfly)
1283 {
1284     if (isX86() || vm.heap.mutatorShouldBeFenced()) {
1285         setStructureIDDirectly(nuke(oldStructureID));
1286         WTF::storeStoreFence();
1287         m_butterfly.set(vm, this, butterfly);
1288         WTF::storeStoreFence();
1289         return;
1290     }
1291 
1292     m_butterfly.set(vm, this, butterfly);
1293 }
1294 














1295 inline JSObject* asObject(JSCell* cell)
1296 {
1297     ASSERT(cell-&gt;isObject());
1298     return jsCast&lt;JSObject*&gt;(cell);
1299 }
1300 
1301 inline JSObject* asObject(JSValue value)
1302 {
1303     return asObject(value.asCell());
1304 }
1305 
1306 inline JSObject::JSObject(VM&amp; vm, Structure* structure, Butterfly* butterfly)
1307     : JSCell(vm, structure)
1308     , m_butterfly(vm, this, butterfly)
1309 {
1310 }
1311 
1312 inline JSValue JSObject::getPrototypeDirect(VM&amp; vm) const
1313 {
1314     return structure(vm)-&gt;storedPrototype(this);
1315 }
1316 
<span class="line-modified">1317 inline JSValue JSObject::getPrototype(VM&amp; vm, JSGlobalObject* globalObject)</span>
1318 {
1319     auto getPrototypeMethod = methodTable(vm)-&gt;getPrototype;
1320     MethodTable::GetPrototypeFunctionPtr defaultGetPrototype = JSObject::getPrototype;
1321     if (LIKELY(getPrototypeMethod == defaultGetPrototype))
1322         return getPrototypeDirect(vm);
<span class="line-modified">1323     return getPrototypeMethod(this, globalObject);</span>
1324 }
1325 
1326 // Normally, we never shrink the butterfly so if we know an offset is valid for some
1327 // past structure then it should be valid for any new structure. However, we may sometimes
1328 // shrink the butterfly when we are holding the Structure&#39;s ConcurrentJSLock, such as when we
1329 // flatten an object.
1330 inline JSValue JSObject::getDirectConcurrently(Structure* structure, PropertyOffset offset) const
1331 {
1332     ConcurrentJSLocker locker(structure-&gt;lock());
1333     if (!structure-&gt;isValidOffset(offset))
1334         return { };
1335     return getDirect(offset);
1336 }
1337 
1338 // It is safe to call this method with a PropertyName that is actually an index,
1339 // but if so will always return false (doesn&#39;t search index storage).
1340 ALWAYS_INLINE bool JSObject::getOwnNonIndexPropertySlot(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertySlot&amp; slot)
1341 {
1342     unsigned attributes;
1343     PropertyOffset offset = structure-&gt;get(vm, propertyName, attributes);
</pre>
<hr />
<pre>
1375 {
1376     ASSERT(attributes &amp; PropertyAttribute::CustomAccessorOrValue);
1377     if (customGetterSetter-&gt;inherits&lt;DOMAttributeGetterSetter&gt;(vm)) {
1378         auto* domAttribute = jsCast&lt;DOMAttributeGetterSetter*&gt;(customGetterSetter);
1379         if (structure-&gt;isUncacheableDictionary())
1380             slot.setCustom(this, attributes, domAttribute-&gt;getter(), domAttribute-&gt;domAttribute());
1381         else
1382             slot.setCacheableCustom(this, attributes, domAttribute-&gt;getter(), domAttribute-&gt;domAttribute());
1383         return;
1384     }
1385 
1386     if (structure-&gt;isUncacheableDictionary())
1387         slot.setCustom(this, attributes, customGetterSetter-&gt;getter());
1388     else
1389         slot.setCacheableCustom(this, attributes, customGetterSetter-&gt;getter());
1390 }
1391 
1392 // It may seem crazy to inline a function this large, especially a virtual function,
1393 // but it makes a big difference to property lookup that derived classes can inline their
1394 // base class call to this.
<span class="line-modified">1395 ALWAYS_INLINE bool JSObject::getOwnPropertySlot(JSObject* object, JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
1396 {
<span class="line-modified">1397     VM&amp; vm = getVM(globalObject);</span>
1398     Structure* structure = object-&gt;structure(vm);
1399     if (object-&gt;getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))
1400         return true;
1401     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">1402         return getOwnPropertySlotByIndex(object, globalObject, index.value(), slot);</span>
1403     return false;
1404 }
1405 
<span class="line-modified">1406 ALWAYS_INLINE void JSObject::doPutPropertySecurityCheck(JSObject*, JSGlobalObject*, PropertyName, PutPropertySlot&amp;)</span>
1407 {
1408 }
1409 
1410 // It may seem crazy to inline a function this large but it makes a big difference
1411 // since this is function very hot in variable lookup
1412 template&lt;bool checkNullStructure&gt;
<span class="line-modified">1413 ALWAYS_INLINE bool JSObject::getPropertySlot(JSGlobalObject* globalObject, PropertyName propertyName, PropertySlot&amp; slot)</span>
1414 {
<span class="line-modified">1415     VM&amp; vm = getVM(globalObject);</span>
1416     auto&amp; structureIDTable = vm.heap.structureIDTable();
1417     JSObject* object = this;
1418     while (true) {
1419         if (UNLIKELY(TypeInfo::overridesGetOwnPropertySlot(object-&gt;inlineTypeFlags()))) {
1420             // If propertyName is an index then we may have missed it (as this loop is using
1421             // getOwnNonIndexPropertySlot), so we cannot safely call the overridden getOwnPropertySlot
1422             // (lest we return a property from a prototype that is shadowed). Check now for an index,
1423             // if so we need to start afresh from this object.
1424             if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">1425                 return getPropertySlot(globalObject, index.value(), slot);</span>
1426             // Safe to continue searching from current position; call getNonIndexPropertySlot to avoid
1427             // parsing the int again.
<span class="line-modified">1428             return object-&gt;getNonIndexPropertySlot(globalObject, propertyName, slot);</span>
1429         }
1430         ASSERT(object-&gt;type() != ProxyObjectType);
1431         Structure* structure = structureIDTable.get(object-&gt;structureID());
1432 #if USE(JSVALUE64)
1433         if (checkNullStructure &amp;&amp; UNLIKELY(!structure))
1434             CRASH_WITH_INFO(object-&gt;type(), object-&gt;structureID(), structureIDTable.size());
1435 #endif
1436         if (object-&gt;getOwnNonIndexPropertySlot(vm, structure, propertyName, slot))
1437             return true;
1438         // FIXME: This doesn&#39;t look like it&#39;s following the specification:
1439         // https://bugs.webkit.org/show_bug.cgi?id=172572
1440         JSValue prototype = structure-&gt;storedPrototype(object);
1441         if (!prototype.isObject())
1442             break;
1443         object = asObject(prototype);
1444     }
1445 
1446     if (Optional&lt;uint32_t&gt; index = parseIndex(propertyName))
<span class="line-modified">1447         return getPropertySlot(globalObject, index.value(), slot);</span>
1448     return false;
1449 }
1450 
<span class="line-modified">1451 inline JSValue JSObject::get(JSGlobalObject* globalObject, PropertyName propertyName) const</span>
1452 {
<span class="line-modified">1453     VM&amp; vm = getVM(globalObject);</span>
1454     auto scope = DECLARE_THROW_SCOPE(vm);
1455     PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
<span class="line-modified">1456     bool hasProperty = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
1457     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
1458     if (hasProperty)
<span class="line-modified">1459         RELEASE_AND_RETURN(scope, slot.getValue(globalObject, propertyName));</span>
1460 
1461     return jsUndefined();
1462 }
1463 
<span class="line-modified">1464 inline JSValue JSObject::get(JSGlobalObject* globalObject, unsigned propertyName) const</span>
1465 {
<span class="line-modified">1466     VM&amp; vm = getVM(globalObject);</span>
1467     auto scope = DECLARE_THROW_SCOPE(vm);
1468     PropertySlot slot(this, PropertySlot::InternalMethodType::Get);
<span class="line-modified">1469     bool hasProperty = const_cast&lt;JSObject*&gt;(this)-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
1470     EXCEPTION_ASSERT(!scope.exception() || !hasProperty);
1471     if (hasProperty)
<span class="line-modified">1472         RELEASE_AND_RETURN(scope, slot.getValue(globalObject, propertyName));</span>
1473 
1474     return jsUndefined();
1475 }
1476 
























1477 inline bool JSObject::putDirect(VM&amp; vm, PropertyName propertyName, JSValue value, unsigned attributes)
1478 {
1479     ASSERT(!value.isGetterSetter() &amp;&amp; !(attributes &amp; PropertyAttribute::Accessor));
1480     ASSERT(!value.isCustomGetterSetter() &amp;&amp; !(attributes &amp; PropertyAttribute::CustomAccessorOrValue));
1481     PutPropertySlot slot(this);
1482     return putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, value, attributes, slot);
1483 }
1484 
1485 inline bool JSObject::putDirect(VM&amp; vm, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)
1486 {
1487     ASSERT(!value.isGetterSetter());
1488     ASSERT(!value.isCustomGetterSetter());
1489     return putDirectInternal&lt;PutModeDefineOwnProperty&gt;(vm, propertyName, value, 0, slot);
1490 }
1491 











1492 inline size_t offsetInButterfly(PropertyOffset offset)
1493 {
1494     return offsetInOutOfLineStorage(offset) + Butterfly::indexOfPropertyStorage();
1495 }
1496 
1497 inline size_t JSObject::butterflyPreCapacity()
1498 {
1499     VM&amp; vm = this-&gt;vm();
1500     if (UNLIKELY(hasIndexingHeader(vm)))
1501         return butterfly()-&gt;indexingHeader()-&gt;preCapacity(structure(vm));
1502     return 0;
1503 }
1504 
1505 inline size_t JSObject::butterflyTotalSize()
1506 {
1507     VM&amp; vm = this-&gt;vm();
1508     Structure* structure = this-&gt;structure(vm);
1509     Butterfly* butterfly = this-&gt;butterfly();
1510     size_t preCapacity;
1511     size_t indexingPayloadSizeInBytes;
</pre>
<hr />
<pre>
1549 }
1550 
1551 COMPILE_ASSERT(!(sizeof(JSObject) % sizeof(WriteBarrierBase&lt;Unknown&gt;)), JSObject_inline_storage_has_correct_alignment);
1552 
1553 template&lt;unsigned charactersCount&gt;
1554 ALWAYS_INLINE Identifier makeIdentifier(VM&amp; vm, const char (&amp;characters)[charactersCount])
1555 {
1556     return Identifier::fromString(vm, characters);
1557 }
1558 
1559 ALWAYS_INLINE Identifier makeIdentifier(VM&amp; vm, const char* name)
1560 {
1561     return Identifier::fromString(vm, name);
1562 }
1563 
1564 ALWAYS_INLINE Identifier makeIdentifier(VM&amp;, const Identifier&amp; name)
1565 {
1566     return name;
1567 }
1568 
<span class="line-modified">1569 bool validateAndApplyPropertyDescriptor(JSGlobalObject*, JSObject*, PropertyName, bool isExtensible,</span>
1570     const PropertyDescriptor&amp; descriptor, bool isCurrentDefined, const PropertyDescriptor&amp; current, bool throwException);
1571 
<span class="line-modified">1572 JS_EXPORT_PRIVATE NEVER_INLINE bool ordinarySetSlow(JSGlobalObject*, JSObject*, PropertyName, JSValue, JSValue receiver, bool shouldThrow);</span>
1573 
1574 // Helper for defining native functions, if you&#39;re not using a static hash table.
1575 // Use this macro from within finishCreation() methods in prototypes. This assumes
<span class="line-modified">1576 // you&#39;ve defined variables called globalObject, globalObject, and vm, and they</span>
1577 // have the expected meanings.
1578 #define JSC_NATIVE_INTRINSIC_FUNCTION(jsName, cppName, attributes, length, intrinsic) \
1579     putDirectNativeFunction(\
1580         vm, globalObject, makeIdentifier(vm, (jsName)), (length), cppName, \
1581         (intrinsic), (attributes))
1582 
1583 #define JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(jsName, cppName, attributes, length, intrinsic) \
1584     putDirectNativeFunctionWithoutTransition(\
1585         vm, globalObject, makeIdentifier(vm, (jsName)), (length), cppName, \
1586         (intrinsic), (attributes))
1587 
1588 // As above, but this assumes that the function you&#39;re defining doesn&#39;t have an
1589 // intrinsic.
1590 #define JSC_NATIVE_FUNCTION(jsName, cppName, attributes, length) \
1591     JSC_NATIVE_INTRINSIC_FUNCTION(jsName, cppName, (attributes), (length), NoIntrinsic)
1592 
1593 #define JSC_NATIVE_FUNCTION_WITHOUT_TRANSITION(jsName, cppName, attributes, length) \
1594     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(jsName, cppName, (attributes), (length), NoIntrinsic)
1595 
1596 // Identical helpers but for builtins. Note that currently, we don&#39;t support builtins that are
</pre>
<hr />
<pre>
1603     putDirectBuiltinFunctionWithoutTransition(\
1604         vm, globalObject, makeIdentifier(vm, (jsName)), (generatorName)(vm), (attributes))
1605 
1606 // Helper for defining native getters on properties.
1607 #define JSC_NATIVE_INTRINSIC_GETTER(jsName, cppName, attributes, intrinsic)  \
1608     putDirectNativeIntrinsicGetter(\
1609         vm, globalObject, makeIdentifier(vm, (jsName)), (cppName), \
1610         (intrinsic), ((attributes) | PropertyAttribute::Accessor))
1611 
1612 #define JSC_NATIVE_INTRINSIC_GETTER_WITHOUT_TRANSITION(jsName, cppName, attributes, intrinsic)  \
1613     putDirectNativeIntrinsicGetterWithoutTransition(\
1614         vm, globalObject, makeIdentifier(vm, (jsName)), (cppName), \
1615         (intrinsic), ((attributes) | PropertyAttribute::Accessor))
1616 
1617 #define JSC_NATIVE_GETTER(jsName, cppName, attributes) \
1618     JSC_NATIVE_INTRINSIC_GETTER((jsName), (cppName), (attributes), NoIntrinsic)
1619 
1620 #define JSC_NATIVE_GETTER_WITHOUT_TRANSITION(jsName, cppName, attributes) \
1621     JSC_NATIVE_INTRINSIC_GETTER_WITHOUT_TRANSITION((jsName), (cppName), (attributes), NoIntrinsic)
1622 
<span class="line-added">1623 </span>
<span class="line-added">1624 #define STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(DerivedClass, BaseClass) \</span>
<span class="line-added">1625     static_assert(sizeof(DerivedClass) == sizeof(BaseClass)); \</span>
<span class="line-added">1626     static_assert(DerivedClass::destroy == BaseClass::destroy);</span>
<span class="line-added">1627 </span>
1628 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="JSObject.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSObjectInlines.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
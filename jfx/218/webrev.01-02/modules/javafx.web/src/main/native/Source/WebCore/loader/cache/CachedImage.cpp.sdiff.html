<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedImage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CachedFont.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CachedImage.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedImage.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 40 #include &quot;SVGImage.h&quot;
 41 #include &quot;SecurityOrigin.h&quot;
 42 #include &quot;Settings.h&quot;
 43 #include &quot;SharedBuffer.h&quot;
 44 #include &quot;SubresourceLoader.h&quot;
 45 #include &lt;wtf/NeverDestroyed.h&gt;
 46 #include &lt;wtf/StdLibExtras.h&gt;
 47 
 48 #if PLATFORM(IOS_FAMILY)
 49 #include &quot;SystemMemory.h&quot;
 50 #endif
 51 
 52 #if USE(CG)
 53 #include &quot;PDFDocumentImage.h&quot;
 54 #endif
 55 
 56 namespace WebCore {
 57 
 58 CachedImage::CachedImage(CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 59     : CachedResource(WTFMove(request), Type::ImageResource, sessionID, cookieJar)




 60 {
 61     setStatus(Unknown);
 62 }
 63 
 64 CachedImage::CachedImage(Image* image, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 65     : CachedResource(URL(), Type::ImageResource, sessionID, cookieJar)
 66     , m_image(image)




 67 {
 68 }
 69 
 70 CachedImage::CachedImage(const URL&amp; url, Image* image, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar, const String&amp; domainForCachePartition)
 71     : CachedResource(url, Type::ImageResource, sessionID, cookieJar)
 72     , m_image(image)

 73     , m_isManuallyCached(true)


 74 {
 75     m_resourceRequest.setDomainForCachePartition(domainForCachePartition);
 76 
 77     // Use the incoming URL in the response field. This ensures that code using the response directly,
 78     // such as origin checks for security, actually see something.
 79     m_response.setURL(url);
 80 }
 81 
 82 CachedImage::~CachedImage()
 83 {
 84     clearImage();
 85 }
 86 
 87 void CachedImage::load(CachedResourceLoader&amp; loader)
 88 {
 89     if (loader.shouldPerformImageLoad(url()))
 90         CachedResource::load(loader);
 91     else
 92         setLoading(false);
 93 }
</pre>
<hr />
<pre>
263         return;
264     ASSERT(containerZoom);
265     if (!m_image) {
266         m_pendingContainerContextRequests.set(&amp;client, ContainerContext { containerSize, containerZoom, imageURL });
267         return;
268     }
269 
270     if (!m_image-&gt;isSVGImage()) {
271         m_image-&gt;setContainerSize(containerSize);
272         return;
273     }
274 
275     m_svgImageCache-&gt;setContainerContextForClient(client, containerSize, containerZoom, imageURL);
276 }
277 
278 FloatSize CachedImage::imageSizeForRenderer(const RenderElement* renderer, SizeType sizeType) const
279 {
280     if (!m_image)
281         return { };
282 
<span class="line-removed">283     if (is&lt;BitmapImage&gt;(*m_image) &amp;&amp; renderer &amp;&amp; renderer-&gt;imageOrientation() == ImageOrientation::FromImage)</span>
<span class="line-removed">284         return downcast&lt;BitmapImage&gt;(*m_image).sizeRespectingOrientation();</span>
<span class="line-removed">285 </span>
286     if (is&lt;SVGImage&gt;(*m_image) &amp;&amp; sizeType == UsedSize)
287         return m_svgImageCache-&gt;imageSizeForRenderer(renderer);
288 
<span class="line-modified">289     return m_image-&gt;size();</span>
290 }
291 
<span class="line-modified">292 LayoutSize CachedImage::imageSizeForRenderer(const RenderElement* renderer, float multiplier, SizeType sizeType) const</span>

293 {
294     LayoutSize imageSize = LayoutSize(imageSizeForRenderer(renderer, sizeType));
295     if (imageSize.isEmpty() || multiplier == 1.0f)
296         return imageSize;
297 
<span class="line-removed">298     // Don&#39;t let images that have a width/height &gt;= 1 shrink below 1 when zoomed.</span>
299     float widthScale = m_image-&gt;hasRelativeWidth() ? 1.0f : multiplier;
300     float heightScale = m_image-&gt;hasRelativeHeight() ? 1.0f : multiplier;
<span class="line-removed">301     LayoutSize minimumSize(imageSize.width() &gt; 0 ? 1 : 0, imageSize.height() &gt; 0 ? 1 : 0);</span>
302     imageSize.scale(widthScale, heightScale);











303     imageSize.clampToMinimumSize(minimumSize);

304     ASSERT(multiplier != 1.0f || (imageSize.width().fraction() == 0.0f &amp;&amp; imageSize.height().fraction() == 0.0f));
305     return imageSize;
306 }
307 
308 void CachedImage::computeIntrinsicDimensions(Length&amp; intrinsicWidth, Length&amp; intrinsicHeight, FloatSize&amp; intrinsicRatio)
309 {
310     if (m_image)
311         m_image-&gt;computeIntrinsicDimensions(intrinsicWidth, intrinsicHeight, intrinsicRatio);
312 }
313 
314 void CachedImage::notifyObservers(const IntRect* changeRect)
315 {
316     CachedResourceClientWalker&lt;CachedImageClient&gt; w(m_clients);
317     while (CachedImageClient* c = w.next())
318         c-&gt;imageChanged(this, changeRect);
319 }
320 
321 void CachedImage::checkShouldPaintBrokenImage()
322 {
323     if (!m_loader || m_loader-&gt;reachedTerminalState())
</pre>
<hr />
<pre>
468     if (encodedDataStatus &gt; EncodedDataStatus::Error &amp;&amp; encodedDataStatus &lt; EncodedDataStatus::SizeAvailable)
469         return;
470 
471     if (encodedDataStatus == EncodedDataStatus::Error || m_image-&gt;isNull()) {
472         // Image decoding failed. Either we need more image data or the image data is malformed.
473         error(errorOccurred() ? status() : DecodeError);
474         if (m_loader &amp;&amp; encodedDataStatus == EncodedDataStatus::Error)
475             m_loader-&gt;cancel();
476         if (inCache())
477             MemoryCache::singleton().remove(*this);
478         return;
479     }
480 
481     // Tell our observers to try to draw.
482     notifyObservers();
483 }
484 
485 bool CachedImage::shouldDeferUpdateImageData() const
486 {
487     static const double updateImageDataBackoffIntervals[] = { 0, 1, 3, 6, 15 };
<span class="line-modified">488     unsigned interval = std::min&lt;unsigned&gt;(m_updateImageDataCount, 4);</span>
489 
490     // The first time through, the chunk time will be 0 and the image will get an update.
491     return (MonotonicTime::now() - m_lastUpdateImageDataTime).seconds() &lt; updateImageDataBackoffIntervals[interval];
492 }
493 
494 RefPtr&lt;SharedBuffer&gt; CachedImage::convertedDataIfNeeded(SharedBuffer* data) const
495 {
496     if (!data || !isPostScriptResource())
497         return data;
498 #if PLATFORM(MAC) &amp;&amp; !USE(WEBKIT_IMAGE_DECODERS)
499     return SharedBuffer::create(PDFDocumentImage::convertPostScriptDataToPDF(data-&gt;createCFData()).get());
500 #else
501     // Loading the image should have been canceled if the system does not support converting PostScript to PDF.
502     ASSERT_NOT_REACHED();
503     return nullptr;
504 #endif
505 }
506 
507 void CachedImage::didUpdateImageData()
508 {
509     m_lastUpdateImageDataTime = MonotonicTime::now();
<span class="line-modified">510     ASSERT(m_updateImageDataCount &lt; std::numeric_limits&lt;unsigned&gt;::max());</span>
<span class="line-modified">511     ++m_updateImageDataCount;</span>

512 }
513 
514 EncodedDataStatus CachedImage::updateImageData(bool allDataReceived)
515 {
516     if (!m_image || !m_data)
517         return EncodedDataStatus::Error;
518     EncodedDataStatus result = m_image-&gt;setData(m_data.get(), allDataReceived);
519     didUpdateImageData();
520     return result;
521 }
522 
523 void CachedImage::updateBuffer(SharedBuffer&amp; data)
524 {
525     ASSERT(dataBufferingPolicy() == DataBufferingPolicy::BufferData);
526     updateBufferInternal(data);
527     CachedResource::updateBuffer(data);
528 }
529 
530 void CachedImage::updateData(const char* data, unsigned length)
531 {
</pre>
</td>
<td>
<hr />
<pre>
 40 #include &quot;SVGImage.h&quot;
 41 #include &quot;SecurityOrigin.h&quot;
 42 #include &quot;Settings.h&quot;
 43 #include &quot;SharedBuffer.h&quot;
 44 #include &quot;SubresourceLoader.h&quot;
 45 #include &lt;wtf/NeverDestroyed.h&gt;
 46 #include &lt;wtf/StdLibExtras.h&gt;
 47 
 48 #if PLATFORM(IOS_FAMILY)
 49 #include &quot;SystemMemory.h&quot;
 50 #endif
 51 
 52 #if USE(CG)
 53 #include &quot;PDFDocumentImage.h&quot;
 54 #endif
 55 
 56 namespace WebCore {
 57 
 58 CachedImage::CachedImage(CachedResourceRequest&amp;&amp; request, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 59     : CachedResource(WTFMove(request), Type::ImageResource, sessionID, cookieJar)
<span class="line-added"> 60     , m_updateImageDataCount(0)</span>
<span class="line-added"> 61     , m_isManuallyCached(false)</span>
<span class="line-added"> 62     , m_shouldPaintBrokenImage(true)</span>
<span class="line-added"> 63     , m_forceUpdateImageDataEnabledForTesting(false)</span>
 64 {
 65     setStatus(Unknown);
 66 }
 67 
 68 CachedImage::CachedImage(Image* image, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar)
 69     : CachedResource(URL(), Type::ImageResource, sessionID, cookieJar)
 70     , m_image(image)
<span class="line-added"> 71     , m_updateImageDataCount(0)</span>
<span class="line-added"> 72     , m_isManuallyCached(false)</span>
<span class="line-added"> 73     , m_shouldPaintBrokenImage(true)</span>
<span class="line-added"> 74     , m_forceUpdateImageDataEnabledForTesting(false)</span>
 75 {
 76 }
 77 
 78 CachedImage::CachedImage(const URL&amp; url, Image* image, const PAL::SessionID&amp; sessionID, const CookieJar* cookieJar, const String&amp; domainForCachePartition)
 79     : CachedResource(url, Type::ImageResource, sessionID, cookieJar)
 80     , m_image(image)
<span class="line-added"> 81     , m_updateImageDataCount(0)</span>
 82     , m_isManuallyCached(true)
<span class="line-added"> 83     , m_shouldPaintBrokenImage(true)</span>
<span class="line-added"> 84     , m_forceUpdateImageDataEnabledForTesting(false)</span>
 85 {
 86     m_resourceRequest.setDomainForCachePartition(domainForCachePartition);
 87 
 88     // Use the incoming URL in the response field. This ensures that code using the response directly,
 89     // such as origin checks for security, actually see something.
 90     m_response.setURL(url);
 91 }
 92 
 93 CachedImage::~CachedImage()
 94 {
 95     clearImage();
 96 }
 97 
 98 void CachedImage::load(CachedResourceLoader&amp; loader)
 99 {
100     if (loader.shouldPerformImageLoad(url()))
101         CachedResource::load(loader);
102     else
103         setLoading(false);
104 }
</pre>
<hr />
<pre>
274         return;
275     ASSERT(containerZoom);
276     if (!m_image) {
277         m_pendingContainerContextRequests.set(&amp;client, ContainerContext { containerSize, containerZoom, imageURL });
278         return;
279     }
280 
281     if (!m_image-&gt;isSVGImage()) {
282         m_image-&gt;setContainerSize(containerSize);
283         return;
284     }
285 
286     m_svgImageCache-&gt;setContainerContextForClient(client, containerSize, containerZoom, imageURL);
287 }
288 
289 FloatSize CachedImage::imageSizeForRenderer(const RenderElement* renderer, SizeType sizeType) const
290 {
291     if (!m_image)
292         return { };
293 



294     if (is&lt;SVGImage&gt;(*m_image) &amp;&amp; sizeType == UsedSize)
295         return m_svgImageCache-&gt;imageSizeForRenderer(renderer);
296 
<span class="line-modified">297     return m_image-&gt;size(renderer ? renderer-&gt;imageOrientation() : ImageOrientation(ImageOrientation::FromImage));</span>
298 }
299 
<span class="line-modified">300 </span>
<span class="line-added">301 LayoutSize CachedImage::unclampedImageSizeForRenderer(const RenderElement* renderer, float multiplier, SizeType sizeType) const</span>
302 {
303     LayoutSize imageSize = LayoutSize(imageSizeForRenderer(renderer, sizeType));
304     if (imageSize.isEmpty() || multiplier == 1.0f)
305         return imageSize;
306 

307     float widthScale = m_image-&gt;hasRelativeWidth() ? 1.0f : multiplier;
308     float heightScale = m_image-&gt;hasRelativeHeight() ? 1.0f : multiplier;

309     imageSize.scale(widthScale, heightScale);
<span class="line-added">310     return imageSize;</span>
<span class="line-added">311 }</span>
<span class="line-added">312 </span>
<span class="line-added">313 LayoutSize CachedImage::imageSizeForRenderer(const RenderElement* renderer, float multiplier, SizeType sizeType) const</span>
<span class="line-added">314 {</span>
<span class="line-added">315     auto imageSize = unclampedImageSizeForRenderer(renderer, multiplier, sizeType);</span>
<span class="line-added">316     if (imageSize.isEmpty() || multiplier == 1.0f)</span>
<span class="line-added">317         return imageSize;</span>
<span class="line-added">318 </span>
<span class="line-added">319     // Don&#39;t let images that have a width/height &gt;= 1 shrink below 1 when zoomed.</span>
<span class="line-added">320     LayoutSize minimumSize(imageSize.width() &gt; 0 ? 1 : 0, imageSize.height() &gt; 0 ? 1 : 0);</span>
321     imageSize.clampToMinimumSize(minimumSize);
<span class="line-added">322 </span>
323     ASSERT(multiplier != 1.0f || (imageSize.width().fraction() == 0.0f &amp;&amp; imageSize.height().fraction() == 0.0f));
324     return imageSize;
325 }
326 
327 void CachedImage::computeIntrinsicDimensions(Length&amp; intrinsicWidth, Length&amp; intrinsicHeight, FloatSize&amp; intrinsicRatio)
328 {
329     if (m_image)
330         m_image-&gt;computeIntrinsicDimensions(intrinsicWidth, intrinsicHeight, intrinsicRatio);
331 }
332 
333 void CachedImage::notifyObservers(const IntRect* changeRect)
334 {
335     CachedResourceClientWalker&lt;CachedImageClient&gt; w(m_clients);
336     while (CachedImageClient* c = w.next())
337         c-&gt;imageChanged(this, changeRect);
338 }
339 
340 void CachedImage::checkShouldPaintBrokenImage()
341 {
342     if (!m_loader || m_loader-&gt;reachedTerminalState())
</pre>
<hr />
<pre>
487     if (encodedDataStatus &gt; EncodedDataStatus::Error &amp;&amp; encodedDataStatus &lt; EncodedDataStatus::SizeAvailable)
488         return;
489 
490     if (encodedDataStatus == EncodedDataStatus::Error || m_image-&gt;isNull()) {
491         // Image decoding failed. Either we need more image data or the image data is malformed.
492         error(errorOccurred() ? status() : DecodeError);
493         if (m_loader &amp;&amp; encodedDataStatus == EncodedDataStatus::Error)
494             m_loader-&gt;cancel();
495         if (inCache())
496             MemoryCache::singleton().remove(*this);
497         return;
498     }
499 
500     // Tell our observers to try to draw.
501     notifyObservers();
502 }
503 
504 bool CachedImage::shouldDeferUpdateImageData() const
505 {
506     static const double updateImageDataBackoffIntervals[] = { 0, 1, 3, 6, 15 };
<span class="line-modified">507     unsigned interval = m_updateImageDataCount;</span>
508 
509     // The first time through, the chunk time will be 0 and the image will get an update.
510     return (MonotonicTime::now() - m_lastUpdateImageDataTime).seconds() &lt; updateImageDataBackoffIntervals[interval];
511 }
512 
513 RefPtr&lt;SharedBuffer&gt; CachedImage::convertedDataIfNeeded(SharedBuffer* data) const
514 {
515     if (!data || !isPostScriptResource())
516         return data;
517 #if PLATFORM(MAC) &amp;&amp; !USE(WEBKIT_IMAGE_DECODERS)
518     return SharedBuffer::create(PDFDocumentImage::convertPostScriptDataToPDF(data-&gt;createCFData()).get());
519 #else
520     // Loading the image should have been canceled if the system does not support converting PostScript to PDF.
521     ASSERT_NOT_REACHED();
522     return nullptr;
523 #endif
524 }
525 
526 void CachedImage::didUpdateImageData()
527 {
528     m_lastUpdateImageDataTime = MonotonicTime::now();
<span class="line-modified">529     unsigned previous = m_updateImageDataCount;</span>
<span class="line-modified">530     if (previous != maxUpdateImageDataCount)</span>
<span class="line-added">531         m_updateImageDataCount += 1;</span>
532 }
533 
534 EncodedDataStatus CachedImage::updateImageData(bool allDataReceived)
535 {
536     if (!m_image || !m_data)
537         return EncodedDataStatus::Error;
538     EncodedDataStatus result = m_image-&gt;setData(m_data.get(), allDataReceived);
539     didUpdateImageData();
540     return result;
541 }
542 
543 void CachedImage::updateBuffer(SharedBuffer&amp; data)
544 {
545     ASSERT(dataBufferingPolicy() == DataBufferingPolicy::BufferData);
546     updateBufferInternal(data);
547     CachedResource::updateBuffer(data);
548 }
549 
550 void CachedImage::updateData(const char* data, unsigned length)
551 {
</pre>
</td>
</tr>
</table>
<center><a href="CachedFont.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="CachedImage.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
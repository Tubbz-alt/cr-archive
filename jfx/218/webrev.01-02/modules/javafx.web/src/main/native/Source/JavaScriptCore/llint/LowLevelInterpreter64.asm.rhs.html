<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/llint/LowLevelInterpreter64.asm</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 # Copyright (C) 2011-2019 Apple Inc. All rights reserved.
   2 #
   3 # Redistribution and use in source and binary forms, with or without
   4 # modification, are permitted provided that the following conditions
   5 # are met:
   6 # 1. Redistributions of source code must retain the above copyright
   7 #    notice, this list of conditions and the following disclaimer.
   8 # 2. Redistributions in binary form must reproduce the above copyright
   9 #    notice, this list of conditions and the following disclaimer in the
  10 #    documentation and/or other materials provided with the distribution.
  11 #
  12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
  13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
  16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
  22 # THE POSSIBILITY OF SUCH DAMAGE.
  23 
  24 
  25 # Utilities.
<a name="1" id="anc1"></a><span class="line-modified">  26 macro storePC()</span>
<span class="line-modified">  27     storei PC, LLIntReturnPC[cfr]</span>









  28 end
  29 
<a name="2" id="anc2"></a><span class="line-modified">  30 macro loadPC()</span>
<span class="line-modified">  31     loadi LLIntReturnPC[cfr], PC</span>


  32 end
  33 
  34 macro getuOperandNarrow(opcodeStruct, fieldName, dst)
<a name="3" id="anc3"></a><span class="line-modified">  35     loadb constexpr %opcodeStruct%_%fieldName%_index + OpcodeIDNarrowSize[PB, PC, 1], dst</span>
  36 end
  37 
  38 macro getOperandNarrow(opcodeStruct, fieldName, dst)
<a name="4" id="anc4"></a><span class="line-modified">  39     loadbsq constexpr %opcodeStruct%_%fieldName%_index + OpcodeIDNarrowSize[PB, PC, 1], dst</span>
  40 end
  41 
  42 macro getuOperandWide16(opcodeStruct, fieldName, dst)
<a name="5" id="anc5"></a><span class="line-modified">  43     loadh constexpr %opcodeStruct%_%fieldName%_index * 2 + OpcodeIDWide16Size[PB, PC, 1], dst</span>
  44 end
  45 
  46 macro getOperandWide16(opcodeStruct, fieldName, dst)
<a name="6" id="anc6"></a><span class="line-modified">  47     loadhsq constexpr %opcodeStruct%_%fieldName%_index * 2 + OpcodeIDWide16Size[PB, PC, 1], dst</span>
  48 end
  49 
  50 macro getuOperandWide32(opcodeStruct, fieldName, dst)
<a name="7" id="anc7"></a><span class="line-modified">  51     loadi constexpr %opcodeStruct%_%fieldName%_index * 4 + OpcodeIDWide32Size[PB, PC, 1], dst</span>
  52 end
  53 
  54 macro getOperandWide32(opcodeStruct, fieldName, dst)
<a name="8" id="anc8"></a><span class="line-modified">  55     loadis constexpr %opcodeStruct%_%fieldName%_index * 4 + OpcodeIDWide32Size[PB, PC, 1], dst</span>
  56 end
  57 
  58 macro makeReturn(get, dispatch, fn)
  59     fn(macro (value)
  60         move value, t2
  61         get(m_dst, t1)
  62         storeq t2, [cfr, t1, 8]
  63         dispatch()
  64     end)
  65 end
  66 
  67 macro makeReturnProfiled(opcodeStruct, get, metadata, dispatch, fn)
  68     fn(macro (value)
  69         move value, t3
  70         metadata(t1, t2)
  71         valueProfile(opcodeStruct, t1, t3)
  72         get(m_dst, t1)
  73         storeq t3, [cfr, t1, 8]
  74         dispatch()
  75     end)
  76 end
  77 
  78 macro valueProfile(opcodeStruct, metadata, value)
  79     storeq value, %opcodeStruct%::Metadata::m_profile.m_buckets[metadata]
  80 end
  81 
<a name="9" id="anc9"></a><span class="line-added">  82 # After calling, calling bytecode is claiming input registers are not used.</span>
  83 macro dispatchAfterCall(size, opcodeStruct, dispatch)
<a name="10" id="anc10"></a><span class="line-modified">  84     loadPC()</span>
  85     loadp CodeBlock[cfr], PB
  86     loadp CodeBlock::m_instructionsRawPointer[PB], PB
  87     get(size, opcodeStruct, m_dst, t1)
  88     storeq r0, [cfr, t1, 8]
  89     metadata(size, opcodeStruct, t2, t1)
  90     valueProfile(opcodeStruct, t2, r0)
  91     dispatch()
  92 end
  93 
  94 macro cCall2(function)
  95     checkStackPointerAlignment(t4, 0xbad0c002)
  96     if X86_64 or ARM64 or ARM64E
  97         call function
  98     elsif X86_64_WIN
  99         # Note: this implementation is only correct if the return type size is &gt; 8 bytes.
 100         # See macro cCall2Void for an implementation when the return type &lt;= 8 bytes.
 101         # On Win64, when the return type is larger than 8 bytes, we need to allocate space on the stack for the return value.
 102         # On entry rcx (a0), should contain a pointer to this stack space. The other parameters are shifted to the right,
 103         # rdx (a1) should contain the first argument, and r8 (a2) should contain the second argument.
 104         # On return, rax contains a pointer to this stack value, and we then need to copy the 16 byte return value into rax (r0) and rdx (r1)
 105         # since the return value is expected to be split between the two.
 106         # See http://msdn.microsoft.com/en-us/library/7572ztz4.aspx
 107         move a1, a2
 108         move a0, a1
 109         subp 48, sp
 110         move sp, a0
 111         addp 32, a0
 112         call function
 113         addp 48, sp
 114         move 8[r0], r1
 115         move [r0], r0
 116     elsif C_LOOP or C_LOOP_WIN
 117         cloopCallSlowPath function, a0, a1
 118     else
 119         error
 120     end
 121 end
 122 
 123 macro cCall2Void(function)
 124     if C_LOOP or C_LOOP_WIN
 125         cloopCallSlowPathVoid function, a0, a1
 126     elsif X86_64_WIN
 127         # Note: we cannot use the cCall2 macro for Win64 in this case,
 128         # as the Win64 cCall2 implemenation is only correct when the return type size is &gt; 8 bytes.
 129         # On Win64, rcx and rdx are used for passing the first two parameters.
 130         # We also need to make room on the stack for all four parameter registers.
 131         # See http://msdn.microsoft.com/en-us/library/ms235286.aspx
 132         subp 32, sp 
 133         call function
 134         addp 32, sp
 135     else
 136         cCall2(function)
 137     end
 138 end
 139 
 140 # This barely works. arg3 and arg4 should probably be immediates.
 141 macro cCall4(function)
 142     checkStackPointerAlignment(t4, 0xbad0c004)
 143     if X86_64 or ARM64 or ARM64E
 144         call function
 145     elsif X86_64_WIN
 146         # On Win64, rcx, rdx, r8, and r9 are used for passing the first four parameters.
 147         # We also need to make room on the stack for all four parameter registers.
 148         # See http://msdn.microsoft.com/en-us/library/ms235286.aspx
 149         subp 64, sp
 150         call function
 151         addp 64, sp
 152     else
 153         error
 154     end
 155 end
 156 
 157 macro doVMEntry(makeCall)
 158     functionPrologue()
 159     pushCalleeSaves()
 160 
 161     const entry = a0
 162     const vm = a1
 163     const protoCallFrame = a2
 164 
 165     vmEntryRecord(cfr, sp)
 166 
 167     checkStackPointerAlignment(t4, 0xbad0dc01)
 168 
 169     storep vm, VMEntryRecord::m_vm[sp]
 170     loadp VM::topCallFrame[vm], t4
 171     storep t4, VMEntryRecord::m_prevTopCallFrame[sp]
 172     loadp VM::topEntryFrame[vm], t4
 173     storep t4, VMEntryRecord::m_prevTopEntryFrame[sp]
 174     loadp ProtoCallFrame::calleeValue[protoCallFrame], t4
 175     storep t4, VMEntryRecord::m_callee[sp]
 176 
 177     loadi ProtoCallFrame::paddedArgCount[protoCallFrame], t4
 178     addp CallFrameHeaderSlots, t4, t4
 179     lshiftp 3, t4
 180     subp sp, t4, t3
 181     bqbeq sp, t3, .throwStackOverflow
 182 
 183     # Ensure that we have enough additional stack capacity for the incoming args,
 184     # and the frame for the JS code we&#39;re executing. We need to do this check
 185     # before we start copying the args from the protoCallFrame below.
 186     if C_LOOP or C_LOOP_WIN
 187         bpaeq t3, VM::m_cloopStackLimit[vm], .stackHeightOK
 188         move entry, t4
 189         move vm, t5
 190         cloopCallSlowPath _llint_stack_check_at_vm_entry, vm, t3
 191         bpeq t0, 0, .stackCheckFailed
 192         move t4, entry
 193         move t5, vm
 194         jmp .stackHeightOK
 195 
 196 .stackCheckFailed:
 197         move t4, entry
 198         move t5, vm
 199         jmp .throwStackOverflow
 200     else
 201         bpb t3, VM::m_softStackLimit[vm], .throwStackOverflow
 202     end
 203 
 204 .stackHeightOK:
 205     move t3, sp
 206     move (constexpr ProtoCallFrame::numberOfRegisters), t3
 207 
 208 .copyHeaderLoop:
<a name="11" id="anc11"></a><span class="line-modified"> 209     # Copy the CodeBlock/Callee/ArgumentCountIncludingThis/|this| from protoCallFrame into the callee frame.</span>
 210     subi 1, t3
 211     loadq [protoCallFrame, t3, 8], extraTempReg
 212     storeq extraTempReg, CodeBlock[sp, t3, 8]
 213     btinz t3, .copyHeaderLoop
 214 
 215     loadi PayloadOffset + ProtoCallFrame::argCountAndCodeOriginValue[protoCallFrame], t4
 216     subi 1, t4
 217     loadi ProtoCallFrame::paddedArgCount[protoCallFrame], extraTempReg
 218     subi 1, extraTempReg
 219 
 220     bieq t4, extraTempReg, .copyArgs
 221     move ValueUndefined, t3
 222 .fillExtraArgsLoop:
 223     subi 1, extraTempReg
 224     storeq t3, ThisArgumentOffset + 8[sp, extraTempReg, 8]
 225     bineq t4, extraTempReg, .fillExtraArgsLoop
 226 
 227 .copyArgs:
 228     loadp ProtoCallFrame::args[protoCallFrame], t3
 229 
 230 .copyArgsLoop:
 231     btiz t4, .copyArgsDone
 232     subi 1, t4
 233     loadq [t3, t4, 8], extraTempReg
 234     storeq extraTempReg, ThisArgumentOffset + 8[sp, t4, 8]
 235     jmp .copyArgsLoop
 236 
 237 .copyArgsDone:
 238     if ARM64 or ARM64E
 239         move sp, t4
 240         storep t4, VM::topCallFrame[vm]
 241     else
 242         storep sp, VM::topCallFrame[vm]
 243     end
 244     storep cfr, VM::topEntryFrame[vm]
 245 
 246     checkStackPointerAlignment(extraTempReg, 0xbad0dc02)
 247 
<a name="12" id="anc12"></a><span class="line-modified"> 248     makeCall(entry, protoCallFrame, t3, t4)</span>
 249 
 250     # We may have just made a call into a JS function, so we can&#39;t rely on sp
 251     # for anything but the fact that our own locals (ie the VMEntryRecord) are
 252     # not below it. It also still has to be aligned, though.
 253     checkStackPointerAlignment(t2, 0xbad0dc03)
 254 
 255     vmEntryRecord(cfr, t4)
 256 
 257     loadp VMEntryRecord::m_vm[t4], vm
 258     loadp VMEntryRecord::m_prevTopCallFrame[t4], t2
 259     storep t2, VM::topCallFrame[vm]
 260     loadp VMEntryRecord::m_prevTopEntryFrame[t4], t2
 261     storep t2, VM::topEntryFrame[vm]
 262 
 263     subp cfr, CalleeRegisterSaveSize, sp
 264 
 265     popCalleeSaves()
 266     functionEpilogue()
 267     ret
 268 
 269 .throwStackOverflow:
 270     move vm, a0
 271     move protoCallFrame, a1
 272     cCall2(_llint_throw_stack_overflow_error)
 273 
 274     vmEntryRecord(cfr, t4)
 275 
 276     loadp VMEntryRecord::m_vm[t4], vm
 277     loadp VMEntryRecord::m_prevTopCallFrame[t4], extraTempReg
 278     storep extraTempReg, VM::topCallFrame[vm]
 279     loadp VMEntryRecord::m_prevTopEntryFrame[t4], extraTempReg
 280     storep extraTempReg, VM::topEntryFrame[vm]
 281 
 282     subp cfr, CalleeRegisterSaveSize, sp
 283 
 284     popCalleeSaves()
 285     functionEpilogue()
 286     ret
 287 end
 288 
 289 
<a name="13" id="anc13"></a><span class="line-modified"> 290 # a0, a2, t3, t4</span>
<span class="line-added"> 291 macro makeJavaScriptCall(entry, protoCallFrame, temp1, temp2)</span>
 292     addp 16, sp
 293     if C_LOOP or C_LOOP_WIN
 294         cloopCallJSFunction entry
 295     else
 296         call entry, JSEntryPtrTag
 297     end
 298     subp 16, sp
 299 end
 300 
<a name="14" id="anc14"></a><span class="line-modified"> 301 # a0, a2, t3, t4</span>
<span class="line-modified"> 302 macro makeHostFunctionCall(entry, protoCallFrame, temp1, temp2)</span>
<span class="line-added"> 303     move entry, temp1</span>
 304     storep cfr, [sp]
<a name="15" id="anc15"></a><span class="line-modified"> 305     loadp ProtoCallFrame::globalObject[protoCallFrame], a0</span>
<span class="line-added"> 306     move sp, a1</span>
 307     if C_LOOP or C_LOOP_WIN
 308         storep lr, 8[sp]
<a name="16" id="anc16"></a><span class="line-modified"> 309         cloopCallNative temp1</span>
 310     elsif X86_64_WIN
 311         # We need to allocate 32 bytes on the stack for the shadow space.
 312         subp 32, sp
<a name="17" id="anc17"></a><span class="line-modified"> 313         call temp1, JSEntryPtrTag</span>
 314         addp 32, sp
 315     else
<a name="18" id="anc18"></a><span class="line-modified"> 316         call temp1, JSEntryPtrTag</span>
 317     end
 318 end
 319 
 320 op(handleUncaughtException, macro ()
 321     loadp Callee[cfr], t3
<a name="19" id="anc19"></a><span class="line-modified"> 322     convertCalleeToVM(t3)</span>

 323     restoreCalleeSavesFromVMEntryFrameCalleeSavesBuffer(t3, t0)
 324     storep 0, VM::callFrameForCatch[t3]
 325 
 326     loadp VM::topEntryFrame[t3], cfr
 327     vmEntryRecord(cfr, t2)
 328 
 329     loadp VMEntryRecord::m_vm[t2], t3
 330     loadp VMEntryRecord::m_prevTopCallFrame[t2], extraTempReg
 331     storep extraTempReg, VM::topCallFrame[t3]
 332     loadp VMEntryRecord::m_prevTopEntryFrame[t2], extraTempReg
 333     storep extraTempReg, VM::topEntryFrame[t3]
 334 
 335     subp cfr, CalleeRegisterSaveSize, sp
 336 
 337     popCalleeSaves()
 338     functionEpilogue()
 339     ret
 340 end)
 341 
 342 
 343 macro prepareStateForCCall()
 344     addp PB, PC
 345 end
 346 
 347 macro restoreStateAfterCCall()
 348     move r0, PC
 349     subp PB, PC
 350 end
 351 
 352 macro callSlowPath(slowPath)
 353     prepareStateForCCall()
 354     move cfr, a0
 355     move PC, a1
 356     cCall2(slowPath)
 357     restoreStateAfterCCall()
 358 end
 359 
 360 macro traceOperand(fromWhere, operand)
 361     prepareStateForCCall()
 362     move fromWhere, a2
 363     move operand, a3
 364     move cfr, a0
 365     move PC, a1
 366     cCall4(_llint_trace_operand)
 367     restoreStateAfterCCall()
 368 end
 369 
 370 macro traceValue(fromWhere, operand)
 371     prepareStateForCCall()
 372     move fromWhere, a2
 373     move operand, a3
 374     move cfr, a0
 375     move PC, a1
 376     cCall4(_llint_trace_value)
 377     restoreStateAfterCCall()
 378 end
 379 
<a name="20" id="anc20"></a><span class="line-modified"> 380 # Call a slow path for call opcodes.</span>
 381 macro callCallSlowPath(slowPath, action)
<a name="21" id="anc21"></a><span class="line-modified"> 382     storePC()</span>
 383     prepareStateForCCall()
 384     move cfr, a0
 385     move PC, a1
 386     cCall2(slowPath)
 387     action(r0, r1)
 388 end
 389 
 390 macro callTrapHandler(throwHandler)
<a name="22" id="anc22"></a><span class="line-modified"> 391     storePC()</span>
 392     prepareStateForCCall()
 393     move cfr, a0
 394     move PC, a1
 395     cCall2(_llint_slow_path_handle_traps)
 396     btpnz r0, throwHandler
<a name="23" id="anc23"></a><span class="line-modified"> 397     loadi LLIntReturnPC[cfr], PC</span>
 398 end
 399 
 400 macro checkSwitchToJITForLoop()
 401     checkSwitchToJIT(
 402         1,
 403         macro()
<a name="24" id="anc24"></a><span class="line-modified"> 404             storePC()</span>
 405             prepareStateForCCall()
 406             move cfr, a0
 407             move PC, a1
 408             cCall2(_llint_loop_osr)
 409             btpz r0, .recover
 410             move r1, sp
 411             jmp r0, JSEntryPtrTag
 412         .recover:
<a name="25" id="anc25"></a><span class="line-modified"> 413             loadPC()</span>
 414         end)
 415 end
 416 
 417 macro cage(basePtr, mask, ptr, scratch)
 418     if GIGACAGE_ENABLED and not (C_LOOP or C_LOOP_WIN)
 419         loadp basePtr, scratch
 420         btpz scratch, .done
 421         andp mask, ptr
 422         addp scratch, ptr
 423     .done:
 424     end
 425 end
 426 
 427 macro cagedPrimitive(ptr, length, scratch, scratch2)
 428     if ARM64E
 429         const source = scratch2
 430         move ptr, scratch2
 431     else
 432         const source = ptr
 433     end
 434     if GIGACAGE_ENABLED
<a name="26" id="anc26"></a><span class="line-modified"> 435         cage(_g_gigacageConfig + Gigacage::Config::basePtrs + GigacagePrimitiveBasePtrOffset, constexpr Gigacage::primitiveGigacageMask, source, scratch)</span>
 436         if ARM64E
 437             const numberOfPACBits = constexpr MacroAssembler::numberOfPACBits
 438             bfiq scratch2, 0, 64 - numberOfPACBits, ptr
 439         end
 440     end
 441     if ARM64E
 442         untagArrayPtr length, ptr
 443     end
 444 end
 445 
 446 macro loadCagedJSValue(source, dest, scratchOrLength)
 447     loadp source, dest
<a name="27" id="anc27"></a><span class="line-modified"> 448     if GIGACAGE_ENABLED</span>
<span class="line-added"> 449         cage(_g_gigacageConfig + Gigacage::Config::basePtrs + GigacageJSValueBasePtrOffset, constexpr Gigacage::jsValueGigacageMask, dest, scratchOrLength)</span>
<span class="line-added"> 450     end</span>
 451 end
 452 
 453 macro loadVariable(get, fieldName, valueReg)
 454     get(fieldName, valueReg)
 455     loadq [cfr, valueReg, 8], valueReg
 456 end
 457 
<a name="28" id="anc28"></a><span class="line-added"> 458 # Index and value must be different registers. Index may be clobbered.</span>
<span class="line-added"> 459 macro loadConstant(size, index, value)</span>
<span class="line-added"> 460     macro loadNarrow()</span>
<span class="line-added"> 461         loadp CodeBlock[cfr], value</span>
<span class="line-added"> 462         loadp CodeBlock::m_constantRegisters + VectorBufferOffset[value], value</span>
<span class="line-added"> 463         loadq -(FirstConstantRegisterIndexNarrow * 8)[value, index, 8], value</span>
<span class="line-added"> 464     end</span>
<span class="line-added"> 465 </span>
<span class="line-added"> 466     macro loadWide16()</span>
<span class="line-added"> 467         loadp CodeBlock[cfr], value</span>
<span class="line-added"> 468         loadp CodeBlock::m_constantRegisters + VectorBufferOffset[value], value</span>
<span class="line-added"> 469         loadq -(FirstConstantRegisterIndexWide16 * 8)[value, index, 8], value</span>
<span class="line-added"> 470     end</span>
<span class="line-added"> 471 </span>
<span class="line-added"> 472     macro loadWide32()</span>
<span class="line-added"> 473         loadp CodeBlock[cfr], value</span>
<span class="line-added"> 474         loadp CodeBlock::m_constantRegisters + VectorBufferOffset[value], value</span>
<span class="line-added"> 475         subp FirstConstantRegisterIndexWide32, index</span>
<span class="line-added"> 476         loadq [value, index, 8], value</span>
<span class="line-added"> 477     end</span>
<span class="line-added"> 478 </span>
<span class="line-added"> 479     size(loadNarrow, loadWide16, loadWide32, macro (load) load() end)</span>
<span class="line-added"> 480 end</span>
<span class="line-added"> 481 </span>
 482 # Index and value must be different registers. Index may be clobbered.
 483 macro loadConstantOrVariable(size, index, value)
 484     macro loadNarrow()
 485         bpgteq index, FirstConstantRegisterIndexNarrow, .constant
 486         loadq [cfr, index, 8], value
 487         jmp .done
 488     .constant:
<a name="29" id="anc29"></a><span class="line-modified"> 489         loadConstant(size, index, value)</span>


 490     .done:
 491     end
 492 
 493     macro loadWide16()
 494         bpgteq index, FirstConstantRegisterIndexWide16, .constant
 495         loadq [cfr, index, 8], value
 496         jmp .done
 497     .constant:
<a name="30" id="anc30"></a><span class="line-modified"> 498         loadConstant(size, index, value)</span>


 499     .done:
 500     end
 501 
 502     macro loadWide32()
 503         bpgteq index, FirstConstantRegisterIndexWide32, .constant
 504         loadq [cfr, index, 8], value
 505         jmp .done
 506     .constant:
<a name="31" id="anc31"></a><span class="line-modified"> 507         loadConstant(size, index, value)</span>



 508     .done:
 509     end
 510 
 511     size(loadNarrow, loadWide16, loadWide32, macro (load) load() end)
 512 end
 513 
 514 macro loadConstantOrVariableInt32(size, index, value, slow)
 515     loadConstantOrVariable(size, index, value)
<a name="32" id="anc32"></a><span class="line-modified"> 516     bqb value, numberTag, slow</span>
 517 end
 518 
 519 macro loadConstantOrVariableCell(size, index, value, slow)
 520     loadConstantOrVariable(size, index, value)
<a name="33" id="anc33"></a><span class="line-modified"> 521     btqnz value, notCellMask, slow</span>
 522 end
 523 
 524 macro writeBarrierOnCellWithReload(cell, reloadAfterSlowPath)
 525     skipIfIsRememberedOrInEden(
 526         cell,
 527         macro()
 528             push PB, PC
 529             move cell, a1 # cell can be a0
 530             move cfr, a0
 531             cCall2Void(_llint_write_barrier_slow)
 532             pop PC, PB
 533             reloadAfterSlowPath()
 534         end)
 535 end
 536 
<a name="34" id="anc34"></a><span class="line-added"> 537 macro writeBarrierOnCellAndValueWithReload(cell, value, reloadAfterSlowPath)</span>
<span class="line-added"> 538     btqnz value, notCellMask, .writeBarrierDone</span>
<span class="line-added"> 539     btqz value, .writeBarrierDone</span>
<span class="line-added"> 540     writeBarrierOnCellWithReload(cell, reloadAfterSlowPath)</span>
<span class="line-added"> 541 .writeBarrierDone:</span>
<span class="line-added"> 542 end</span>
<span class="line-added"> 543 </span>
 544 macro writeBarrierOnOperandWithReload(size, get, cellFieldName, reloadAfterSlowPath)
 545     get(cellFieldName, t1)
 546     loadConstantOrVariableCell(size, t1, t2, .writeBarrierDone)
 547     writeBarrierOnCellWithReload(t2, reloadAfterSlowPath)
 548 .writeBarrierDone:
 549 end
 550 
 551 macro writeBarrierOnOperand(size, get, cellFieldName)
 552     writeBarrierOnOperandWithReload(size, get, cellFieldName, macro () end)
 553 end
 554 
 555 macro writeBarrierOnOperands(size, get, cellFieldName, valueFieldName)
 556     get(valueFieldName, t1)
 557     loadConstantOrVariableCell(size, t1, t0, .writeBarrierDone)
 558     btpz t0, .writeBarrierDone
 559 
 560     writeBarrierOnOperand(size, get, cellFieldName)
 561 .writeBarrierDone:
 562 end
 563 
 564 macro writeBarrierOnGlobal(size, get, valueFieldName, loadMacro)
 565     get(valueFieldName, t1)
 566     loadConstantOrVariableCell(size, t1, t0, .writeBarrierDone)
 567     btpz t0, .writeBarrierDone
 568 
 569     loadMacro(t3)
 570     writeBarrierOnCellWithReload(t3, macro() end)
 571 .writeBarrierDone:
 572 end
 573 
 574 macro writeBarrierOnGlobalObject(size, get, valueFieldName)
 575     writeBarrierOnGlobal(size, get, valueFieldName,
 576         macro(registerToStoreGlobal)
 577             loadp CodeBlock[cfr], registerToStoreGlobal
 578             loadp CodeBlock::m_globalObject[registerToStoreGlobal], registerToStoreGlobal
 579         end)
 580 end
 581 
 582 macro writeBarrierOnGlobalLexicalEnvironment(size, get, valueFieldName)
 583     writeBarrierOnGlobal(size, get, valueFieldName,
 584         macro(registerToStoreGlobal)
 585             loadp CodeBlock[cfr], registerToStoreGlobal
 586             loadp CodeBlock::m_globalObject[registerToStoreGlobal], registerToStoreGlobal
 587             loadp JSGlobalObject::m_globalLexicalEnvironment[registerToStoreGlobal], registerToStoreGlobal
 588         end)
 589 end
 590 
 591 macro structureIDToStructureWithScratch(structureIDThenStructure, scratch, scratch2)
 592     loadp CodeBlock[cfr], scratch
 593     move structureIDThenStructure, scratch2
 594     loadp CodeBlock::m_vm[scratch], scratch
 595     rshifti NumberOfStructureIDEntropyBits, scratch2
 596     loadp VM::heap + Heap::m_structureIDTable + StructureIDTable::m_table[scratch], scratch
 597     loadp [scratch, scratch2, PtrSize], scratch2
 598     lshiftp StructureEntropyBitsShift, structureIDThenStructure
 599     xorp scratch2, structureIDThenStructure
 600 end
 601 
 602 macro loadStructureWithScratch(cell, structure, scratch, scratch2)
 603     loadi JSCell::m_structureID[cell], structure
 604     structureIDToStructureWithScratch(structure, scratch, scratch2)
 605 end
 606 
 607 # Entrypoints into the interpreter.
 608 
 609 # Expects that CodeBlock is in t1, which is what prologue() leaves behind.
 610 macro functionArityCheck(doneLabel, slowPath)
<a name="35" id="anc35"></a><span class="line-modified"> 611     loadi PayloadOffset + ArgumentCountIncludingThis[cfr], t0</span>
 612     biaeq t0, CodeBlock::m_numParameters[t1], doneLabel
 613     prepareStateForCCall()
 614     move cfr, a0
 615     move PC, a1
 616     cCall2(slowPath)   # This slowPath has the protocol: r0 = 0 =&gt; no error, r0 != 0 =&gt; error
 617     btiz r0, .noError
 618 
 619     # We&#39;re throwing before the frame is fully set up. This frame will be
 620     # ignored by the unwinder. So, let&#39;s restore the callee saves before we
 621     # start unwinding. We need to do this before we change the cfr.
 622     restoreCalleeSavesUsedByLLInt()
 623 
 624     move r1, cfr   # r1 contains caller frame
 625     jmp _llint_throw_from_slow_path_trampoline
 626 
 627 .noError:
 628     move r1, t1 # r1 contains slotsToAdd.
 629     btiz t1, .continue
<a name="36" id="anc36"></a><span class="line-modified"> 630     loadi PayloadOffset + ArgumentCountIncludingThis[cfr], t2</span>
 631     addi CallFrameHeaderSlots, t2
 632 
 633     // Check if there are some unaligned slots we can use
 634     move t1, t3
 635     andi StackAlignmentSlots - 1, t3
 636     btiz t3, .noExtraSlot
 637     move ValueUndefined, t0
 638 .fillExtraSlots:
 639     storeq t0, [cfr, t2, 8]
 640     addi 1, t2
 641     bsubinz 1, t3, .fillExtraSlots
 642     andi ~(StackAlignmentSlots - 1), t1
 643     btiz t1, .continue
 644 
 645 .noExtraSlot:
 646     if ARM64E
 647         loadp 8[cfr], lr
 648         addp 16, cfr, t3
 649         untagReturnAddress t3
 650     end
 651 
 652     // Move frame up t1 slots
 653     negq t1
 654     move cfr, t3
 655     subp CalleeSaveSpaceAsVirtualRegisters * 8, t3
 656     addi CalleeSaveSpaceAsVirtualRegisters, t2
 657     move t1, t0
 658     # Adds to sp are always 64-bit on arm64 so we need maintain t0&#39;s high bits.
 659     lshiftq 3, t0
 660     addp t0, cfr
 661     addp t0, sp
 662 .copyLoop:
 663     loadq [t3], t0
 664     storeq t0, [t3, t1, 8]
 665     addp 8, t3
 666     bsubinz 1, t2, .copyLoop
 667 
 668     // Fill new slots with JSUndefined
 669     move t1, t2
 670     move ValueUndefined, t0
 671 .fillLoop:
 672     storeq t0, [t3, t1, 8]
 673     addp 8, t3
 674     baddinz 1, t2, .fillLoop
 675 
 676     if ARM64E
 677         addp 16, cfr, t1
 678         tagReturnAddress t1
 679         storep lr, 8[cfr]
 680     end
 681 
 682 .continue:
 683     # Reload CodeBlock and reset PC, since the slow_path clobbered them.
 684     loadp CodeBlock[cfr], t1
 685     loadp CodeBlock::m_instructionsRawPointer[t1], PB
 686     move 0, PC
 687     jmp doneLabel
 688 end
 689 
<a name="37" id="anc37"></a>








 690 # Instruction implementations
<a name="38" id="anc38"></a><span class="line-added"> 691 </span>
 692 _llint_op_enter:
 693     traceExecution()
 694     checkStackPointerAlignment(t2, 0xdead00e1)
<a name="39" id="anc39"></a><span class="line-modified"> 695     loadp CodeBlock[cfr], t2                // t2&lt;CodeBlock&gt; = cfr.CodeBlock</span>
<span class="line-modified"> 696     loadi CodeBlock::m_numVars[t2], t2      // t2&lt;size_t&gt; = t2&lt;CodeBlock&gt;.m_numVars</span>
 697     subq CalleeSaveSpaceAsVirtualRegisters, t2
 698     move cfr, t1
 699     subq CalleeSaveSpaceAsVirtualRegisters * 8, t1
 700     btiz t2, .opEnterDone
 701     move ValueUndefined, t0
 702     negi t2
 703     sxi2q t2, t2
 704 .opEnterLoop:
 705     storeq t0, [t1, t2, 8]
 706     addq 1, t2
 707     btqnz t2, .opEnterLoop
 708 .opEnterDone:
<a name="40" id="anc40"></a><span class="line-modified"> 709     callSlowPath(_slow_path_enter)</span>





 710     dispatchOp(narrow, op_enter)
<a name="41" id="anc41"></a><span class="line-modified"> 711 </span>


 712 
 713 llintOpWithProfile(op_get_argument, OpGetArgument, macro (size, get, dispatch, return)
 714     get(m_index, t2)
<a name="42" id="anc42"></a><span class="line-modified"> 715     loadi PayloadOffset + ArgumentCountIncludingThis[cfr], t0</span>
 716     bilteq t0, t2, .opGetArgumentOutOfBounds
 717     loadq ThisArgumentOffset[cfr, t2, 8], t0
 718     return(t0)
 719 
 720 .opGetArgumentOutOfBounds:
 721     return(ValueUndefined)
 722 end)
 723 
 724 
 725 llintOpWithReturn(op_argument_count, OpArgumentCount, macro (size, get, dispatch, return)
<a name="43" id="anc43"></a><span class="line-modified"> 726     loadi PayloadOffset + ArgumentCountIncludingThis[cfr], t0</span>
 727     subi 1, t0
<a name="44" id="anc44"></a><span class="line-modified"> 728     orq TagNumber, t0</span>
 729     return(t0)
 730 end)
 731 
 732 
 733 llintOpWithReturn(op_get_scope, OpGetScope, macro (size, get, dispatch, return)
 734     loadp Callee[cfr], t0
 735     loadp JSCallee::m_scope[t0], t0
 736     return(t0)
 737 end)
 738 
 739 
 740 llintOpWithMetadata(op_to_this, OpToThis, macro (size, get, dispatch, metadata, return)
 741     get(m_srcDst, t0)
 742     loadq [cfr, t0, 8], t0
<a name="45" id="anc45"></a><span class="line-modified"> 743     btqnz t0, notCellMask, .opToThisSlow</span>
 744     bbneq JSCell::m_type[t0], FinalObjectType, .opToThisSlow
 745     loadi JSCell::m_structureID[t0], t1
 746     metadata(t2, t3)
 747     loadi OpToThis::Metadata::m_cachedStructureID[t2], t2
 748     bineq t1, t2, .opToThisSlow
 749     dispatch()
 750 
 751 .opToThisSlow:
 752     callSlowPath(_slow_path_to_this)
 753     dispatch()
 754 end)
 755 
 756 
 757 llintOp(op_check_tdz, OpCheckTdz, macro (size, get, dispatch)
 758     get(m_targetVirtualRegister, t0)
 759     loadConstantOrVariable(size, t0, t1)
 760     bqneq t1, ValueEmpty, .opNotTDZ
 761     callSlowPath(_slow_path_throw_tdz_error)
 762 
 763 .opNotTDZ:
 764     dispatch()
 765 end)
 766 
 767 
 768 llintOpWithReturn(op_mov, OpMov, macro (size, get, dispatch, return)
 769     get(m_src, t1)
 770     loadConstantOrVariable(size, t1, t2)
 771     return(t2)
 772 end)
 773 
 774 
 775 llintOpWithReturn(op_not, OpNot, macro (size, get, dispatch, return)
 776     get(m_operand, t0)
 777     loadConstantOrVariable(size, t0, t2)
 778     xorq ValueFalse, t2
 779     btqnz t2, ~1, .opNotSlow
 780     xorq ValueTrue, t2
 781     return(t2)
 782 
 783 .opNotSlow:
 784     callSlowPath(_slow_path_not)
 785     dispatch()
 786 end)
 787 
 788 
 789 macro equalityComparisonOp(opcodeName, opcodeStruct, integerComparison)
 790     llintOpWithReturn(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, return)
 791         get(m_rhs, t0)
 792         get(m_lhs, t2)
 793         loadConstantOrVariableInt32(size, t0, t1, .slow)
 794         loadConstantOrVariableInt32(size, t2, t0, .slow)
 795         integerComparison(t0, t1, t0)
 796         orq ValueFalse, t0
 797         return(t0)
 798 
 799     .slow:
 800         callSlowPath(_slow_path_%opcodeName%)
 801         dispatch()
 802     end)
 803 end
 804 
 805 
 806 macro equalNullComparisonOp(opcodeName, opcodeStruct, fn)
 807     llintOpWithReturn(opcodeName, opcodeStruct, macro (size, get, dispatch, return)
 808         get(m_operand, t0)
 809         loadq [cfr, t0, 8], t0
<a name="46" id="anc46"></a><span class="line-modified"> 810         btqnz t0, notCellMask, .immediate</span>
 811         btbnz JSCell::m_flags[t0], MasqueradesAsUndefined, .masqueradesAsUndefined
 812         move 0, t0
 813         jmp .done
 814     .masqueradesAsUndefined:
 815         loadStructureWithScratch(t0, t2, t1, t3)
 816         loadp CodeBlock[cfr], t0
 817         loadp CodeBlock::m_globalObject[t0], t0
 818         cpeq Structure::m_globalObject[t2], t0, t0
 819         jmp .done
 820     .immediate:
<a name="47" id="anc47"></a><span class="line-modified"> 821         andq ~TagUndefined, t0</span>
 822         cqeq t0, ValueNull, t0
 823     .done:
 824         fn(t0)
 825         return(t0)
 826     end)
 827 end
 828 
 829 equalNullComparisonOp(op_eq_null, OpEqNull,
 830     macro (value) orq ValueFalse, value end)
 831 
 832 
 833 equalNullComparisonOp(op_neq_null, OpNeqNull,
 834     macro (value) xorq ValueTrue, value end)
 835 
 836 
 837 llintOpWithReturn(op_is_undefined_or_null, OpIsUndefinedOrNull, macro (size, get, dispatch, return)
 838     get(m_operand, t1)
 839     loadConstantOrVariable(size, t1, t0)
<a name="48" id="anc48"></a><span class="line-modified"> 840     andq ~TagUndefined, t0</span>
 841     cqeq t0, ValueNull, t0
 842     orq ValueFalse, t0
 843     return(t0)
 844 end)
 845 
 846 
 847 macro strictEqOp(opcodeName, opcodeStruct, equalityOperation)
 848     llintOpWithReturn(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, return)
 849         get(m_rhs, t0)
 850         get(m_lhs, t2)
 851         loadConstantOrVariable(size, t0, t1)
 852         loadConstantOrVariable(size, t2, t0)
 853         move t0, t2
 854         orq t1, t2
<a name="49" id="anc49"></a><span class="line-modified"> 855         btqz t2, notCellMask, .slow</span>
<span class="line-modified"> 856         bqaeq t0, numberTag, .leftOK</span>
<span class="line-modified"> 857         btqnz t0, numberTag, .slow</span>
 858     .leftOK:
<a name="50" id="anc50"></a><span class="line-modified"> 859         bqaeq t1, numberTag, .rightOK</span>
<span class="line-modified"> 860         btqnz t1, numberTag, .slow</span>
 861     .rightOK:
 862         equalityOperation(t0, t1, t0)
 863         orq ValueFalse, t0
 864         return(t0)
 865 
 866     .slow:
 867         callSlowPath(_slow_path_%opcodeName%)
 868         dispatch()
 869     end)
 870 end
 871 
 872 
 873 strictEqOp(stricteq, OpStricteq,
 874     macro (left, right, result) cqeq left, right, result end)
 875 
 876 
 877 strictEqOp(nstricteq, OpNstricteq,
 878     macro (left, right, result) cqneq left, right, result end)
 879 
 880 
 881 macro strictEqualityJumpOp(opcodeName, opcodeStruct, equalityOperation)
 882     llintOpWithJump(op_%opcodeName%, opcodeStruct, macro (size, get, jump, dispatch)
 883         get(m_lhs, t2)
 884         get(m_rhs, t3)
 885         loadConstantOrVariable(size, t2, t0)
 886         loadConstantOrVariable(size, t3, t1)
 887         move t0, t2
 888         orq t1, t2
<a name="51" id="anc51"></a><span class="line-modified"> 889         btqz t2, notCellMask, .slow</span>
<span class="line-modified"> 890         bqaeq t0, numberTag, .leftOK</span>
<span class="line-modified"> 891         btqnz t0, numberTag, .slow</span>
 892     .leftOK:
<a name="52" id="anc52"></a><span class="line-modified"> 893         bqaeq t1, numberTag, .rightOK</span>
<span class="line-modified"> 894         btqnz t1, numberTag, .slow</span>
 895     .rightOK:
 896         equalityOperation(t0, t1, .jumpTarget)
 897         dispatch()
 898 
 899     .jumpTarget:
 900         jump(m_targetLabel)
 901 
 902     .slow:
 903         callSlowPath(_llint_slow_path_%opcodeName%)
 904         nextInstruction()
 905     end)
 906 end
 907 
 908 
 909 strictEqualityJumpOp(jstricteq, OpJstricteq,
 910     macro (left, right, target) bqeq left, right, target end)
 911 
 912 
 913 strictEqualityJumpOp(jnstricteq, OpJnstricteq,
 914     macro (left, right, target) bqneq left, right, target end)
 915 
<a name="53" id="anc53"></a><span class="line-added"> 916 macro preOp(opcodeName, opcodeStruct, integerOperation)</span>
<span class="line-added"> 917     llintOpWithMetadata(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, metadata, return)</span>
<span class="line-added"> 918         macro updateArithProfile(type)</span>
<span class="line-added"> 919             orh type, %opcodeStruct%::Metadata::m_arithProfile + UnaryArithProfile::m_bits[t1]</span>
<span class="line-added"> 920         end</span>
 921 
<a name="54" id="anc54"></a>

 922         get(m_srcDst, t0)
<a name="55" id="anc55"></a><span class="line-modified"> 923         loadq [cfr, t0, 8], t3</span>
<span class="line-modified"> 924         metadata(t1, t2)</span>
<span class="line-modified"> 925         # Metadata in t1, srcDst in t3</span>
<span class="line-modified"> 926         bqb t3, numberTag, .slow</span>
<span class="line-modified"> 927         integerOperation(t3, .slow)</span>
<span class="line-added"> 928         orq numberTag, t3</span>
<span class="line-added"> 929         storeq t3, [cfr, t0, 8]</span>
<span class="line-added"> 930         updateArithProfile(ArithProfileInt)</span>
 931         dispatch()
<a name="56" id="anc56"></a><span class="line-added"> 932 </span>
 933     .slow:
 934         callSlowPath(_slow_path_%opcodeName%)
 935         dispatch()
 936     end)
 937 end
 938 
 939 llintOpWithProfile(op_to_number, OpToNumber, macro (size, get, dispatch, return)
 940     get(m_operand, t0)
 941     loadConstantOrVariable(size, t0, t2)
<a name="57" id="anc57"></a><span class="line-modified"> 942     bqaeq t2, numberTag, .opToNumberIsImmediate</span>
<span class="line-modified"> 943     btqz t2, numberTag, .opToNumberSlow</span>
 944 .opToNumberIsImmediate:
 945     return(t2)
 946 
 947 .opToNumberSlow:
 948     callSlowPath(_slow_path_to_number)
 949     dispatch()
 950 end)
 951 
<a name="58" id="anc58"></a><span class="line-added"> 952 llintOpWithProfile(op_to_numeric, OpToNumeric, macro (size, get, dispatch, return)</span>
<span class="line-added"> 953     get(m_operand, t0)</span>
<span class="line-added"> 954     loadConstantOrVariable(size, t0, t2)</span>
<span class="line-added"> 955     bqaeq t2, numberTag, .opToNumericIsImmediate</span>
<span class="line-added"> 956     btqz t2, numberTag, .opToNumericSlow</span>
<span class="line-added"> 957 .opToNumericIsImmediate:</span>
<span class="line-added"> 958     return(t2)</span>
<span class="line-added"> 959 </span>
<span class="line-added"> 960 .opToNumericSlow:</span>
<span class="line-added"> 961     callSlowPath(_slow_path_to_numeric)</span>
<span class="line-added"> 962     dispatch()</span>
<span class="line-added"> 963 end)</span>
<span class="line-added"> 964 </span>
 965 
 966 llintOpWithReturn(op_to_string, OpToString, macro (size, get, dispatch, return)
 967     get(m_operand, t1)
 968     loadConstantOrVariable(size, t1, t0)
<a name="59" id="anc59"></a><span class="line-modified"> 969     btqnz t0, notCellMask, .opToStringSlow</span>
 970     bbneq JSCell::m_type[t0], StringType, .opToStringSlow
 971 .opToStringIsString:
 972     return(t0)
 973 
 974 .opToStringSlow:
 975     callSlowPath(_slow_path_to_string)
 976     dispatch()
 977 end)
 978 
 979 
 980 llintOpWithProfile(op_to_object, OpToObject, macro (size, get, dispatch, return)
 981     get(m_operand, t0)
 982     loadConstantOrVariable(size, t0, t2)
<a name="60" id="anc60"></a><span class="line-modified"> 983     btqnz t2, notCellMask, .opToObjectSlow</span>
 984     bbb JSCell::m_type[t2], ObjectType, .opToObjectSlow
 985     return(t2)
 986 
 987 .opToObjectSlow:
 988     callSlowPath(_slow_path_to_object)
 989     dispatch()
 990 end)
 991 
 992 
 993 llintOpWithMetadata(op_negate, OpNegate, macro (size, get, dispatch, metadata, return)
<a name="61" id="anc61"></a><span class="line-added"> 994 </span>
<span class="line-added"> 995     macro updateArithProfile(type)</span>
<span class="line-added"> 996         orh type, OpNegate::Metadata::m_arithProfile + UnaryArithProfile::m_bits[t1]</span>
<span class="line-added"> 997     end</span>
<span class="line-added"> 998 </span>
 999     get(m_operand, t0)
1000     loadConstantOrVariable(size, t0, t3)
1001     metadata(t1, t2)
<a name="62" id="anc62"></a><span class="line-modified">1002     bqb t3, numberTag, .opNegateNotInt</span>

1003     btiz t3, 0x7fffffff, .opNegateSlow
1004     negi t3
<a name="63" id="anc63"></a><span class="line-modified">1005     orq numberTag, t3</span>
<span class="line-modified">1006     updateArithProfile(ArithProfileInt)</span>

1007     return(t3)
1008 .opNegateNotInt:
<a name="64" id="anc64"></a><span class="line-modified">1009     btqz t3, numberTag, .opNegateSlow</span>
1010     xorq 0x8000000000000000, t3
<a name="65" id="anc65"></a><span class="line-modified">1011     updateArithProfile(ArithProfileNumber)</span>

1012     return(t3)
1013 
1014 .opNegateSlow:
1015     callSlowPath(_slow_path_negate)
1016     dispatch()
1017 end)
1018 
1019 
1020 macro binaryOpCustomStore(opcodeName, opcodeStruct, integerOperationAndStore, doubleOperation)
1021     llintOpWithMetadata(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, metadata, return)
1022         metadata(t5, t0)
1023 
1024         macro profile(type)
<a name="66" id="anc66"></a><span class="line-modified">1025             orh type, %opcodeStruct%::Metadata::m_arithProfile + BinaryArithProfile::m_bits[t5]</span>
1026         end
1027 
1028         get(m_rhs, t0)
1029         get(m_lhs, t2)
1030         loadConstantOrVariable(size, t0, t1)
1031         loadConstantOrVariable(size, t2, t0)
<a name="67" id="anc67"></a><span class="line-modified">1032         bqb t0, numberTag, .op1NotInt</span>
<span class="line-modified">1033         bqb t1, numberTag, .op2NotInt</span>
1034         get(m_dst, t2)
1035         integerOperationAndStore(t1, t0, .slow, t2)
1036 
1037         profile(ArithProfileIntInt)
1038         dispatch()
1039 
1040     .op1NotInt:
1041         # First operand is definitely not an int, the second operand could be anything.
<a name="68" id="anc68"></a><span class="line-modified">1042         btqz t0, numberTag, .slow</span>
<span class="line-modified">1043         bqaeq t1, numberTag, .op1NotIntOp2Int</span>
<span class="line-modified">1044         btqz t1, numberTag, .slow</span>
<span class="line-modified">1045         addq numberTag, t1</span>
1046         fq2d t1, ft1
1047         profile(ArithProfileNumberNumber)
1048         jmp .op1NotIntReady
1049     .op1NotIntOp2Int:
1050         profile(ArithProfileNumberInt)
<a name="69" id="anc69"></a><span class="line-modified">1051         ci2ds t1, ft1</span>
1052     .op1NotIntReady:
1053         get(m_dst, t2)
<a name="70" id="anc70"></a><span class="line-modified">1054         addq numberTag, t0</span>
1055         fq2d t0, ft0
1056         doubleOperation(ft1, ft0)
1057         fd2q ft0, t0
<a name="71" id="anc71"></a><span class="line-modified">1058         subq numberTag, t0</span>
1059         storeq t0, [cfr, t2, 8]
1060         dispatch()
1061 
1062     .op2NotInt:
1063         # First operand is definitely an int, the second is definitely not.
1064         get(m_dst, t2)
<a name="72" id="anc72"></a><span class="line-modified">1065         btqz t1, numberTag, .slow</span>
1066         profile(ArithProfileIntNumber)
<a name="73" id="anc73"></a><span class="line-modified">1067         ci2ds t0, ft0</span>
<span class="line-modified">1068         addq numberTag, t1</span>
1069         fq2d t1, ft1
1070         doubleOperation(ft1, ft0)
1071         fd2q ft0, t0
<a name="74" id="anc74"></a><span class="line-modified">1072         subq numberTag, t0</span>
1073         storeq t0, [cfr, t2, 8]
1074         dispatch()
1075 
1076     .slow:
1077         callSlowPath(_slow_path_%opcodeName%)
1078         dispatch()
1079     end)
1080 end
1081 
1082 if X86_64 or X86_64_WIN
1083     binaryOpCustomStore(div, OpDiv,
1084         macro (left, right, slow, index)
1085             # Assume t3 is scratchable.
1086             btiz left, slow
1087             bineq left, -1, .notNeg2TwoThe31DivByNeg1
1088             bieq right, -2147483648, .slow
1089         .notNeg2TwoThe31DivByNeg1:
1090             btinz right, .intOK
1091             bilt left, 0, slow
1092         .intOK:
1093             move left, t3
1094             move right, t0
1095             cdqi
1096             idivi t3
1097             btinz t1, slow
<a name="75" id="anc75"></a><span class="line-modified">1098             orq numberTag, t0</span>
1099             storeq t0, [cfr, index, 8]
1100         end,
1101         macro (left, right) divd left, right end)
1102 else
1103     slowPathOp(div)
1104 end
1105 
1106 
1107 binaryOpCustomStore(mul, OpMul,
1108     macro (left, right, slow, index)
1109         # Assume t3 is scratchable.
1110         move right, t3
1111         bmulio left, t3, slow
1112         btinz t3, .done
1113         bilt left, 0, slow
1114         bilt right, 0, slow
1115     .done:
<a name="76" id="anc76"></a><span class="line-modified">1116         orq numberTag, t3</span>
1117         storeq t3, [cfr, index, 8]
1118     end,
1119     macro (left, right) muld left, right end)
1120 
1121 
1122 macro binaryOp(opcodeName, opcodeStruct, integerOperation, doubleOperation)
1123     binaryOpCustomStore(opcodeName, opcodeStruct,
1124         macro (left, right, slow, index)
1125             integerOperation(left, right, slow)
<a name="77" id="anc77"></a><span class="line-modified">1126             orq numberTag, right</span>
1127             storeq right, [cfr, index, 8]
1128         end,
1129         doubleOperation)
1130 end
1131 
1132 binaryOp(add, OpAdd,
1133     macro (left, right, slow) baddio left, right, slow end,
1134     macro (left, right) addd left, right end)
1135 
1136 
1137 binaryOp(sub, OpSub,
1138     macro (left, right, slow) bsubio left, right, slow end,
1139     macro (left, right) subd left, right end)
1140 
1141 
1142 llintOpWithReturn(op_unsigned, OpUnsigned, macro (size, get, dispatch, return)
1143     get(m_operand, t1)
1144     loadConstantOrVariable(size, t1, t2)
1145     bilt t2, 0, .opUnsignedSlow
1146     return(t2)
1147 .opUnsignedSlow:
1148     callSlowPath(_slow_path_unsigned)
1149     dispatch()
1150 end)
1151 
1152 
1153 macro commonBitOp(opKind, opcodeName, opcodeStruct, operation)
1154     opKind(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, return)
1155         get(m_rhs, t0)
1156         get(m_lhs, t2)
1157         loadConstantOrVariable(size, t0, t1)
1158         loadConstantOrVariable(size, t2, t0)
<a name="78" id="anc78"></a><span class="line-modified">1159         bqb t0, numberTag, .slow</span>
<span class="line-modified">1160         bqb t1, numberTag, .slow</span>
1161         operation(t1, t0)
<a name="79" id="anc79"></a><span class="line-modified">1162         orq numberTag, t0</span>
1163         return(t0)
1164 
1165     .slow:
1166         callSlowPath(_slow_path_%opcodeName%)
1167         dispatch()
1168     end)
1169 end
1170 
1171 macro bitOp(opcodeName, opcodeStruct, operation)
1172     commonBitOp(llintOpWithReturn, opcodeName, opcodeStruct, operation)
1173 end
1174 
1175 macro bitOpProfiled(opcodeName, opcodeStruct, operation)
1176     commonBitOp(llintOpWithProfile, opcodeName, opcodeStruct, operation)
1177 end
1178 
1179 bitOpProfiled(lshift, OpLshift,
1180     macro (left, right) lshifti left, right end)
1181 
1182 
<a name="80" id="anc80"></a><span class="line-modified">1183 bitOpProfiled(rshift, OpRshift,</span>
1184     macro (left, right) rshifti left, right end)
1185 
1186 
1187 bitOp(urshift, OpUrshift,
1188     macro (left, right) urshifti left, right end)
1189 
1190 bitOpProfiled(bitand, OpBitand,
1191     macro (left, right) andi left, right end)
1192 
1193 bitOpProfiled(bitor, OpBitor,
1194     macro (left, right) ori left, right end)
1195 
1196 bitOpProfiled(bitxor, OpBitxor,
1197     macro (left, right) xori left, right end)
1198 
1199 llintOpWithProfile(op_bitnot, OpBitnot, macro (size, get, dispatch, return)
1200     get(m_operand, t0)
1201     loadConstantOrVariableInt32(size, t0, t3, .opBitNotSlow)
1202     noti t3
<a name="81" id="anc81"></a><span class="line-modified">1203     orq numberTag, t3</span>
1204     return(t3)
1205 .opBitNotSlow:
1206     callSlowPath(_slow_path_bitnot)
1207     dispatch()
1208 end)
1209 
1210 
1211 llintOp(op_overrides_has_instance, OpOverridesHasInstance, macro (size, get, dispatch)
1212     get(m_dst, t3)
1213 
1214     get(m_hasInstanceValue, t1)
1215     loadConstantOrVariable(size, t1, t0)
1216     loadp CodeBlock[cfr], t2
1217     loadp CodeBlock::m_globalObject[t2], t2
1218     loadp JSGlobalObject::m_functionProtoHasInstanceSymbolFunction[t2], t2
1219     bqneq t0, t2, .opOverridesHasInstanceNotDefaultSymbol
1220 
1221     get(m_constructor, t1)
1222     loadConstantOrVariable(size, t1, t0)
1223     tbz JSCell::m_flags[t0], ImplementsDefaultHasInstance, t1
1224     orq ValueFalse, t1
1225     storeq t1, [cfr, t3, 8]
1226     dispatch()
1227 
1228 .opOverridesHasInstanceNotDefaultSymbol:
1229     storeq ValueTrue, [cfr, t3, 8]
1230     dispatch()
1231 end)
1232 
1233 
1234 llintOpWithReturn(op_is_empty, OpIsEmpty, macro (size, get, dispatch, return)
1235     get(m_operand, t1)
1236     loadConstantOrVariable(size, t1, t0)
1237     cqeq t0, ValueEmpty, t3
1238     orq ValueFalse, t3
1239     return(t3)
1240 end)
1241 
1242 
1243 llintOpWithReturn(op_is_undefined, OpIsUndefined, macro (size, get, dispatch, return)
1244     get(m_operand, t1)
1245     loadConstantOrVariable(size, t1, t0)
<a name="82" id="anc82"></a><span class="line-modified">1246     btqz t0, notCellMask, .opIsUndefinedCell</span>
1247     cqeq t0, ValueUndefined, t3
1248     orq ValueFalse, t3
1249     return(t3)
1250 .opIsUndefinedCell:
1251     btbnz JSCell::m_flags[t0], MasqueradesAsUndefined, .masqueradesAsUndefined
1252     move ValueFalse, t1
1253     return(t1)
1254 .masqueradesAsUndefined:
1255     loadStructureWithScratch(t0, t3, t1, t2)
1256     loadp CodeBlock[cfr], t1
1257     loadp CodeBlock::m_globalObject[t1], t1
1258     cpeq Structure::m_globalObject[t3], t1, t0
1259     orq ValueFalse, t0
1260     return(t0)
1261 end)
1262 
1263 
1264 llintOpWithReturn(op_is_boolean, OpIsBoolean, macro (size, get, dispatch, return)
1265     get(m_operand, t1)
1266     loadConstantOrVariable(size, t1, t0)
1267     xorq ValueFalse, t0
1268     tqz t0, ~1, t0
1269     orq ValueFalse, t0
1270     return(t0)
1271 end)
1272 
1273 
1274 llintOpWithReturn(op_is_number, OpIsNumber, macro (size, get, dispatch, return)
1275     get(m_operand, t1)
1276     loadConstantOrVariable(size, t1, t0)
<a name="83" id="anc83"></a><span class="line-modified">1277     tqnz t0, numberTag, t1</span>
1278     orq ValueFalse, t1
1279     return(t1)
1280 end)
1281 
1282 
1283 llintOpWithReturn(op_is_cell_with_type, OpIsCellWithType, macro (size, get, dispatch, return)
1284     getu(size, OpIsCellWithType, m_type, t0)
1285     get(m_operand, t1)
1286     loadConstantOrVariable(size, t1, t3)
<a name="84" id="anc84"></a><span class="line-modified">1287     btqnz t3, notCellMask, .notCellCase</span>
1288     cbeq JSCell::m_type[t3], t0, t1
1289     orq ValueFalse, t1
1290     return(t1)
1291 .notCellCase:
1292     return(ValueFalse)
1293 end)
1294 
1295 
1296 llintOpWithReturn(op_is_object, OpIsObject, macro (size, get, dispatch, return)
1297     get(m_operand, t1)
1298     loadConstantOrVariable(size, t1, t0)
<a name="85" id="anc85"></a><span class="line-modified">1299     btqnz t0, notCellMask, .opIsObjectNotCell</span>
1300     cbaeq JSCell::m_type[t0], ObjectType, t1
1301     orq ValueFalse, t1
1302     return(t1)
1303 .opIsObjectNotCell:
1304     return(ValueFalse)
1305 end)
1306 
1307 
1308 macro loadPropertyAtVariableOffset(propertyOffsetAsInt, objectAndStorage, value)
1309     bilt propertyOffsetAsInt, firstOutOfLineOffset, .isInline
1310     loadp JSObject::m_butterfly[objectAndStorage], objectAndStorage
1311     negi propertyOffsetAsInt
1312     sxi2q propertyOffsetAsInt, propertyOffsetAsInt
1313     jmp .ready
1314 .isInline:
1315     addp sizeof JSObject - (firstOutOfLineOffset - 2) * 8, objectAndStorage
1316 .ready:
1317     loadq (firstOutOfLineOffset - 2) * 8[objectAndStorage, propertyOffsetAsInt, 8], value
1318 end
1319 
1320 
1321 macro storePropertyAtVariableOffset(propertyOffsetAsInt, objectAndStorage, value)
1322     bilt propertyOffsetAsInt, firstOutOfLineOffset, .isInline
1323     loadp JSObject::m_butterfly[objectAndStorage], objectAndStorage
1324     negi propertyOffsetAsInt
1325     sxi2q propertyOffsetAsInt, propertyOffsetAsInt
1326     jmp .ready
1327 .isInline:
1328     addp sizeof JSObject - (firstOutOfLineOffset - 2) * 8, objectAndStorage
1329 .ready:
1330     storeq value, (firstOutOfLineOffset - 2) * 8[objectAndStorage, propertyOffsetAsInt, 8]
1331 end
1332 
1333 
1334 llintOpWithMetadata(op_get_by_id_direct, OpGetByIdDirect, macro (size, get, dispatch, metadata, return)
1335     metadata(t2, t0)
1336     get(m_base, t0)
1337     loadConstantOrVariableCell(size, t0, t3, .opGetByIdDirectSlow)
1338     loadi JSCell::m_structureID[t3], t1
1339     loadi OpGetByIdDirect::Metadata::m_structureID[t2], t0
1340     bineq t0, t1, .opGetByIdDirectSlow
1341     loadi OpGetByIdDirect::Metadata::m_offset[t2], t1
1342     loadPropertyAtVariableOffset(t1, t3, t0)
1343     valueProfile(OpGetByIdDirect, t2, t0)
1344     return(t0)
1345 
1346 .opGetByIdDirectSlow:
1347     callSlowPath(_llint_slow_path_get_by_id_direct)
1348     dispatch()
1349 end)
1350 
<a name="86" id="anc86"></a>
1351 llintOpWithMetadata(op_get_by_id, OpGetById, macro (size, get, dispatch, metadata, return)
1352     metadata(t2, t1)
1353     loadb OpGetById::Metadata::m_modeMetadata.mode[t2], t1
1354     get(m_base, t0)
1355     loadConstantOrVariableCell(size, t0, t3, .opGetByIdSlow)
1356 
1357 .opGetByIdDefault:
1358     bbneq t1, constexpr GetByIdMode::Default, .opGetByIdProtoLoad
1359     loadi JSCell::m_structureID[t3], t1
1360     loadi OpGetById::Metadata::m_modeMetadata.defaultMode.structureID[t2], t0
1361     bineq t0, t1, .opGetByIdSlow
1362     loadis OpGetById::Metadata::m_modeMetadata.defaultMode.cachedOffset[t2], t1
1363     loadPropertyAtVariableOffset(t1, t3, t0)
1364     valueProfile(OpGetById, t2, t0)
1365     return(t0)
1366 
1367 .opGetByIdProtoLoad:
1368     bbneq t1, constexpr GetByIdMode::ProtoLoad, .opGetByIdArrayLength
1369     loadi JSCell::m_structureID[t3], t1
1370     loadi OpGetById::Metadata::m_modeMetadata.protoLoadMode.structureID[t2], t3
1371     bineq t3, t1, .opGetByIdSlow
1372     loadis OpGetById::Metadata::m_modeMetadata.protoLoadMode.cachedOffset[t2], t1
1373     loadp OpGetById::Metadata::m_modeMetadata.protoLoadMode.cachedSlot[t2], t3
1374     loadPropertyAtVariableOffset(t1, t3, t0)
1375     valueProfile(OpGetById, t2, t0)
1376     return(t0)
1377 
1378 .opGetByIdArrayLength:
1379     bbneq t1, constexpr GetByIdMode::ArrayLength, .opGetByIdUnset
1380     move t3, t0
1381     arrayProfile(OpGetById::Metadata::m_modeMetadata.arrayLengthMode.arrayProfile, t0, t2, t5)
1382     btiz t0, IsArray, .opGetByIdSlow
1383     btiz t0, IndexingShapeMask, .opGetByIdSlow
1384     loadCagedJSValue(JSObject::m_butterfly[t3], t0, t1)
1385     loadi -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t0], t0
1386     bilt t0, 0, .opGetByIdSlow
<a name="87" id="anc87"></a><span class="line-modified">1387     orq numberTag, t0</span>
1388     valueProfile(OpGetById, t2, t0)
1389     return(t0)
1390 
1391 .opGetByIdUnset:
1392     loadi JSCell::m_structureID[t3], t1
1393     loadi OpGetById::Metadata::m_modeMetadata.unsetMode.structureID[t2], t0
1394     bineq t0, t1, .opGetByIdSlow
1395     valueProfile(OpGetById, t2, ValueUndefined)
1396     return(ValueUndefined)
1397 
1398 .opGetByIdSlow:
1399     callSlowPath(_llint_slow_path_get_by_id)
1400     dispatch()
<a name="88" id="anc88"></a><span class="line-added">1401 </span>
<span class="line-added">1402 .osrReturnPoint:</span>
<span class="line-added">1403     getterSetterOSRExitReturnPoint(op_get_by_id, size)</span>
<span class="line-added">1404     metadata(t2, t3)</span>
<span class="line-added">1405     valueProfile(OpGetById, t2, r0)</span>
<span class="line-added">1406     return(r0)</span>
<span class="line-added">1407 </span>
1408 end)
1409 
1410 
1411 llintOpWithMetadata(op_put_by_id, OpPutById, macro (size, get, dispatch, metadata, return)
1412     get(m_base, t3)
1413     loadConstantOrVariableCell(size, t3, t0, .opPutByIdSlow)
1414     metadata(t5, t2)
1415     loadi OpPutById::Metadata::m_oldStructureID[t5], t2
1416     bineq t2, JSCell::m_structureID[t0], .opPutByIdSlow
1417 
1418     # At this point, we have:
1419     # t0 -&gt; object base
1420     # t2 -&gt; current structure ID
1421     # t5 -&gt; metadata
1422 
1423     loadi OpPutById::Metadata::m_newStructureID[t5], t1
1424     btiz t1, .opPutByIdNotTransition
1425 
1426     # This is the transition case. t1 holds the new structureID. t2 holds the old structure ID.
1427     # If we have a chain, we need to check it. t0 is the base. We may clobber t1 to use it as
1428     # scratch.
1429     loadp OpPutById::Metadata::m_structureChain[t5], t3
1430     btpz t3, .opPutByIdTransitionDirect
1431 
<a name="89" id="anc89"></a><span class="line-modified">1432     loadp CodeBlock[cfr], t1</span>
<span class="line-added">1433     loadp CodeBlock::m_vm[t1], t1</span>
<span class="line-added">1434     loadp VM::heap + Heap::m_structureIDTable + StructureIDTable::m_table[t1], t1</span>
<span class="line-added">1435 </span>
<span class="line-added">1436     macro structureIDToStructureWithScratchAndTable(structureIDThenStructure, table, scratch)</span>
<span class="line-added">1437         move structureIDThenStructure, scratch</span>
<span class="line-added">1438         rshifti NumberOfStructureIDEntropyBits, scratch</span>
<span class="line-added">1439         loadp [table, scratch, PtrSize], scratch</span>
<span class="line-added">1440         lshiftp StructureEntropyBitsShift, structureIDThenStructure</span>
<span class="line-added">1441         xorp scratch, structureIDThenStructure</span>
<span class="line-added">1442     end</span>
1443 
<a name="90" id="anc90"></a><span class="line-modified">1444     structureIDToStructureWithScratchAndTable(t2, t1, t0)</span>

1445 
1446     loadp StructureChain::m_vector[t3], t3
1447     assert(macro (ok) btpnz t3, ok end)
1448 
1449     loadq Structure::m_prototype[t2], t2
1450     bqeq t2, ValueNull, .opPutByIdTransitionChainDone
1451 .opPutByIdTransitionChainLoop:
<a name="91" id="anc91"></a>



1452     loadi JSCell::m_structureID[t2], t2
<a name="92" id="anc92"></a><span class="line-modified">1453     bineq t2, [t3], .opPutByIdSlow</span>
<span class="line-modified">1454     addp 4, t3</span>
<span class="line-modified">1455     structureIDToStructureWithScratchAndTable(t2, t1, t0)</span>
<span class="line-modified">1456     loadq Structure::m_prototype[t2], t2</span>
1457     bqneq t2, ValueNull, .opPutByIdTransitionChainLoop
1458 
1459 .opPutByIdTransitionChainDone:
1460     # Reload the new structure, since we clobbered it above.
1461     loadi OpPutById::Metadata::m_newStructureID[t5], t1
<a name="93" id="anc93"></a><span class="line-added">1462     # Reload base into t0</span>
<span class="line-added">1463     get(m_base, t3)</span>
<span class="line-added">1464     loadConstantOrVariable(size, t3, t0)</span>
1465 
1466 .opPutByIdTransitionDirect:
1467     storei t1, JSCell::m_structureID[t0]
1468     writeBarrierOnOperandWithReload(size, get, m_base, macro ()
1469         # Reload metadata into t5
1470         metadata(t5, t1)
1471         # Reload base into t0
1472         get(m_base, t1)
1473         loadConstantOrVariable(size, t1, t0)
1474     end)
1475 
1476 .opPutByIdNotTransition:
1477     # The only thing live right now is t0, which holds the base.
1478     get(m_value, t1)
1479     loadConstantOrVariable(size, t1, t2)
1480     loadi OpPutById::Metadata::m_offset[t5], t1
1481     storePropertyAtVariableOffset(t1, t0, t2)
1482     writeBarrierOnOperands(size, get, m_base, m_value)
1483     dispatch()
1484 
1485 .opPutByIdSlow:
1486     callSlowPath(_llint_slow_path_put_by_id)
1487     dispatch()
<a name="94" id="anc94"></a><span class="line-added">1488 </span>
<span class="line-added">1489 .osrReturnPoint:</span>
<span class="line-added">1490     getterSetterOSRExitReturnPoint(op_put_by_id, size)</span>
<span class="line-added">1491     dispatch()</span>
<span class="line-added">1492 </span>
1493 end)
1494 
1495 
1496 llintOpWithMetadata(op_get_by_val, OpGetByVal, macro (size, get, dispatch, metadata, return)
1497     macro finishGetByVal(result, scratch)
1498         get(m_dst, scratch)
1499         storeq result, [cfr, scratch, 8]
1500         valueProfile(OpGetByVal, t5, result)
1501         dispatch()
1502     end
1503 
1504     macro finishIntGetByVal(result, scratch)
<a name="95" id="anc95"></a><span class="line-modified">1505         orq numberTag, result</span>
1506         finishGetByVal(result, scratch)
1507     end
1508 
1509     macro finishDoubleGetByVal(result, scratch1, scratch2)
1510         fd2q result, scratch1
<a name="96" id="anc96"></a><span class="line-modified">1511         subq numberTag, scratch1</span>
1512         finishGetByVal(scratch1, scratch2)
1513     end
1514 
1515     metadata(t5, t2)
1516 
1517     get(m_base, t2)
1518     loadConstantOrVariableCell(size, t2, t0, .opGetByValSlow)
1519 
1520     move t0, t2
1521     arrayProfile(OpGetByVal::Metadata::m_arrayProfile, t2, t5, t1)
1522 
1523     get(m_property, t3)
1524     loadConstantOrVariableInt32(size, t3, t1, .opGetByValSlow)
1525     sxi2q t1, t1
1526 
<a name="97" id="anc97"></a><span class="line-modified">1527     loadCagedJSValue(JSObject::m_butterfly[t0], t3, numberTag)</span>
<span class="line-modified">1528     move TagNumber, numberTag</span>
1529 
1530     andi IndexingShapeMask, t2
1531     bieq t2, Int32Shape, .opGetByValIsContiguous
1532     bineq t2, ContiguousShape, .opGetByValNotContiguous
1533 
1534 .opGetByValIsContiguous:
1535     biaeq t1, -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t3], .opGetByValSlow
1536     get(m_dst, t0)
1537     loadq [t3, t1, 8], t2
1538     btqz t2, .opGetByValSlow
1539     jmp .opGetByValDone
1540 
1541 .opGetByValNotContiguous:
1542     bineq t2, DoubleShape, .opGetByValNotDouble
1543     biaeq t1, -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t3], .opGetByValSlow
1544     get(m_dst, t0)
1545     loadd [t3, t1, 8], ft0
1546     bdnequn ft0, ft0, .opGetByValSlow
1547     fd2q ft0, t2
<a name="98" id="anc98"></a><span class="line-modified">1548     subq numberTag, t2</span>
1549     jmp .opGetByValDone
1550     
1551 .opGetByValNotDouble:
1552     subi ArrayStorageShape, t2
1553     bia t2, SlowPutArrayStorageShape - ArrayStorageShape, .opGetByValNotIndexedStorage
1554     biaeq t1, -sizeof IndexingHeader + IndexingHeader::u.lengths.vectorLength[t3], .opGetByValSlow
1555     get(m_dst, t0)
1556     loadq ArrayStorage::m_vector[t3, t1, 8], t2
1557     btqz t2, .opGetByValSlow
1558 
1559 .opGetByValDone:
1560     storeq t2, [cfr, t0, 8]
1561     valueProfile(OpGetByVal, t5, t2)
1562     dispatch()
1563 
1564 .opGetByValNotIndexedStorage:
1565     # First lets check if we even have a typed array. This lets us do some boilerplate up front.
1566     loadb JSCell::m_type[t0], t2
1567     subi FirstTypedArrayType, t2
1568     biaeq t2, NumberOfTypedArrayTypesExcludingDataView, .opGetByValSlow
1569     
1570     # Sweet, now we know that we have a typed array. Do some basic things now.
1571 
1572     if ARM64E
1573         const length = t6
1574         const scratch = t7
1575         loadi JSArrayBufferView::m_length[t0], length
1576         biaeq t1, length, .opGetByValSlow
1577     else
1578         # length and scratch are intentionally undefined on this branch because they are not used on other platforms.
1579         biaeq t1, JSArrayBufferView::m_length[t0], .opGetByValSlow
1580     end
1581 
1582     loadp JSArrayBufferView::m_vector[t0], t3
1583     cagedPrimitive(t3, length, t0, scratch)
1584 
1585     # Now bisect through the various types:
1586     #    Int8ArrayType,
1587     #    Uint8ArrayType,
1588     #    Uint8ClampedArrayType,
1589     #    Int16ArrayType,
1590     #    Uint16ArrayType,
1591     #    Int32ArrayType,
1592     #    Uint32ArrayType,
1593     #    Float32ArrayType,
1594     #    Float64ArrayType,
1595 
1596     bia t2, Uint16ArrayType - FirstTypedArrayType, .opGetByValAboveUint16Array
1597 
1598     # We have one of Int8ArrayType .. Uint16ArrayType.
1599     bia t2, Uint8ClampedArrayType - FirstTypedArrayType, .opGetByValInt16ArrayOrUint16Array
1600 
1601     # We have one of Int8ArrayType ... Uint8ClampedArrayType
1602     bia t2, Int8ArrayType - FirstTypedArrayType, .opGetByValUint8ArrayOrUint8ClampedArray
1603 
1604     # We have Int8ArrayType.
1605     loadbsi [t3, t1], t0
1606     finishIntGetByVal(t0, t1)
1607 
1608 .opGetByValUint8ArrayOrUint8ClampedArray:
1609     bia t2, Uint8ArrayType - FirstTypedArrayType, .opGetByValUint8ClampedArray
1610 
1611     # We have Uint8ArrayType.
1612     loadb [t3, t1], t0
1613     finishIntGetByVal(t0, t1)
1614 
1615 .opGetByValUint8ClampedArray:
1616     # We have Uint8ClampedArrayType.
1617     loadb [t3, t1], t0
1618     finishIntGetByVal(t0, t1)
1619 
1620 .opGetByValInt16ArrayOrUint16Array:
1621     # We have either Int16ArrayType or Uint16ClampedArrayType.
1622     bia t2, Int16ArrayType - FirstTypedArrayType, .opGetByValUint16Array
1623 
1624     # We have Int16ArrayType.
1625     loadhsi [t3, t1, 2], t0
1626     finishIntGetByVal(t0, t1)
1627 
1628 .opGetByValUint16Array:
1629     # We have Uint16ArrayType.
1630     loadh [t3, t1, 2], t0
1631     finishIntGetByVal(t0, t1)
1632 
1633 .opGetByValAboveUint16Array:
1634     # We have one of Int32ArrayType .. Float64ArrayType.
1635     bia t2, Uint32ArrayType - FirstTypedArrayType, .opGetByValFloat32ArrayOrFloat64Array
1636 
1637     # We have either Int32ArrayType or Uint32ArrayType
1638     bia t2, Int32ArrayType - FirstTypedArrayType, .opGetByValUint32Array
1639 
1640     # We have Int32ArrayType.
1641     loadi [t3, t1, 4], t0
1642     finishIntGetByVal(t0, t1)
1643 
1644 .opGetByValUint32Array:
1645     # We have Uint32ArrayType.
1646     # This is the hardest part because of large unsigned values.
1647     loadi [t3, t1, 4], t0
1648     bilt t0, 0, .opGetByValSlow # This case is still awkward to implement in LLInt.
1649     finishIntGetByVal(t0, t1)
1650 
1651 .opGetByValFloat32ArrayOrFloat64Array:
1652     # We have one of Float32ArrayType or Float64ArrayType. Sadly, we cannot handle Float32Array
1653     # inline yet. That would require some offlineasm changes.
1654     bieq t2, Float32ArrayType - FirstTypedArrayType, .opGetByValSlow
1655 
1656     # We have Float64ArrayType.
1657     loadd [t3, t1, 8], ft0
1658     bdnequn ft0, ft0, .opGetByValSlow
1659     finishDoubleGetByVal(ft0, t0, t1)
1660 
1661 .opGetByValSlow:
1662     callSlowPath(_llint_slow_path_get_by_val)
1663     dispatch()
<a name="99" id="anc99"></a><span class="line-added">1664 </span>
<span class="line-added">1665 .osrReturnPoint:</span>
<span class="line-added">1666     getterSetterOSRExitReturnPoint(op_get_by_val, size)</span>
<span class="line-added">1667     metadata(t5, t2)</span>
<span class="line-added">1668     valueProfile(OpGetByVal, t5, r0)</span>
<span class="line-added">1669     return(r0)</span>
<span class="line-added">1670 </span>
1671 end)
1672 
1673 
<a name="100" id="anc100"></a><span class="line-modified">1674 macro putByValOp(opcodeName, opcodeStruct, osrExitPoint)</span>
1675     llintOpWithMetadata(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, metadata, return)
1676         macro contiguousPutByVal(storeCallback)
1677             biaeq t3, -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t0], .outOfBounds
1678         .storeResult:
1679             get(m_value, t2)
1680             storeCallback(t2, t1, [t0, t3, 8])
1681             dispatch()
1682 
1683         .outOfBounds:
1684             biaeq t3, -sizeof IndexingHeader + IndexingHeader::u.lengths.vectorLength[t0], .opPutByValOutOfBounds
1685             storeb 1, %opcodeStruct%::Metadata::m_arrayProfile.m_mayStoreToHole[t5]
1686             addi 1, t3, t2
1687             storei t2, -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t0]
1688             jmp .storeResult
1689         end
1690 
1691         get(m_base, t0)
1692         loadConstantOrVariableCell(size, t0, t1, .opPutByValSlow)
1693         move t1, t2
1694         metadata(t5, t0)
1695         arrayProfile(%opcodeStruct%::Metadata::m_arrayProfile, t2, t5, t0)
1696         get(m_property, t0)
1697         loadConstantOrVariableInt32(size, t0, t3, .opPutByValSlow)
1698         sxi2q t3, t3
<a name="101" id="anc101"></a><span class="line-modified">1699         loadCagedJSValue(JSObject::m_butterfly[t1], t0, numberTag)</span>
<span class="line-modified">1700         move TagNumber, numberTag</span>
1701         btinz t2, CopyOnWrite, .opPutByValSlow
1702         andi IndexingShapeMask, t2
1703         bineq t2, Int32Shape, .opPutByValNotInt32
1704         contiguousPutByVal(
1705             macro (operand, scratch, address)
1706                 loadConstantOrVariable(size, operand, scratch)
<a name="102" id="anc102"></a><span class="line-modified">1707                 bqb scratch, numberTag, .opPutByValSlow</span>
1708                 storeq scratch, address
1709                 writeBarrierOnOperands(size, get, m_base, m_value)
1710             end)
1711 
1712     .opPutByValNotInt32:
1713         bineq t2, DoubleShape, .opPutByValNotDouble
1714         contiguousPutByVal(
1715             macro (operand, scratch, address)
1716                 loadConstantOrVariable(size, operand, scratch)
<a name="103" id="anc103"></a><span class="line-modified">1717                 bqb scratch, numberTag, .notInt</span>
<span class="line-modified">1718                 ci2ds scratch, ft0</span>
1719                 jmp .ready
1720             .notInt:
<a name="104" id="anc104"></a><span class="line-modified">1721                 addq numberTag, scratch</span>
1722                 fq2d scratch, ft0
1723                 bdnequn ft0, ft0, .opPutByValSlow
1724             .ready:
1725                 stored ft0, address
1726                 writeBarrierOnOperands(size, get, m_base, m_value)
1727             end)
1728 
1729     .opPutByValNotDouble:
1730         bineq t2, ContiguousShape, .opPutByValNotContiguous
1731         contiguousPutByVal(
1732             macro (operand, scratch, address)
1733                 loadConstantOrVariable(size, operand, scratch)
1734                 storeq scratch, address
1735                 writeBarrierOnOperands(size, get, m_base, m_value)
1736             end)
1737 
1738     .opPutByValNotContiguous:
1739         bineq t2, ArrayStorageShape, .opPutByValSlow
1740         biaeq t3, -sizeof IndexingHeader + IndexingHeader::u.lengths.vectorLength[t0], .opPutByValOutOfBounds
1741         btqz ArrayStorage::m_vector[t0, t3, 8], .opPutByValArrayStorageEmpty
1742     .opPutByValArrayStorageStoreResult:
1743         get(m_value, t2)
1744         loadConstantOrVariable(size, t2, t1)
1745         storeq t1, ArrayStorage::m_vector[t0, t3, 8]
1746         writeBarrierOnOperands(size, get, m_base, m_value)
1747         dispatch()
1748 
1749     .opPutByValArrayStorageEmpty:
1750         storeb 1, %opcodeStruct%::Metadata::m_arrayProfile.m_mayStoreToHole[t5]
1751         addi 1, ArrayStorage::m_numValuesInVector[t0]
1752         bib t3, -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t0], .opPutByValArrayStorageStoreResult
1753         addi 1, t3, t1
1754         storei t1, -sizeof IndexingHeader + IndexingHeader::u.lengths.publicLength[t0]
1755         jmp .opPutByValArrayStorageStoreResult
1756 
1757     .opPutByValOutOfBounds:
1758         storeb 1, %opcodeStruct%::Metadata::m_arrayProfile.m_outOfBounds[t5]
1759     .opPutByValSlow:
1760         callSlowPath(_llint_slow_path_%opcodeName%)
1761         dispatch()
<a name="105" id="anc105"></a><span class="line-added">1762 </span>
<span class="line-added">1763         osrExitPoint(size, dispatch)</span>
<span class="line-added">1764 </span>
1765     end)
1766 end
1767 
<a name="106" id="anc106"></a><span class="line-modified">1768 putByValOp(put_by_val, OpPutByVal, macro (size, dispatch)</span>
<span class="line-added">1769 .osrReturnPoint:</span>
<span class="line-added">1770     getterSetterOSRExitReturnPoint(op_put_by_val, size)</span>
<span class="line-added">1771     dispatch()</span>
<span class="line-added">1772 end)</span>
1773 
<a name="107" id="anc107"></a><span class="line-modified">1774 putByValOp(put_by_val_direct, OpPutByValDirect, macro (a, b) end)</span>
1775 
1776 
1777 macro llintJumpTrueOrFalseOp(opcodeName, opcodeStruct, conditionOp)
1778     llintOpWithJump(op_%opcodeName%, opcodeStruct, macro (size, get, jump, dispatch)
1779         get(m_condition, t1)
1780         loadConstantOrVariable(size, t1, t0)
1781         btqnz t0, ~0xf, .slow
1782         conditionOp(t0, .target)
1783         dispatch()
1784 
1785     .target:
1786         jump(m_targetLabel)
1787 
1788     .slow:
1789         callSlowPath(_llint_slow_path_%opcodeName%)
1790         nextInstruction()
1791     end)
1792 end
1793 
1794 
1795 macro equalNullJumpOp(opcodeName, opcodeStruct, cellHandler, immediateHandler)
1796     llintOpWithJump(op_%opcodeName%, opcodeStruct, macro (size, get, jump, dispatch)
1797         get(m_value, t0)
1798         assertNotConstant(size, t0)
1799         loadq [cfr, t0, 8], t0
<a name="108" id="anc108"></a><span class="line-modified">1800         btqnz t0, notCellMask, .immediate</span>
1801         loadStructureWithScratch(t0, t2, t1, t3)
1802         cellHandler(t2, JSCell::m_flags[t0], .target)
1803         dispatch()
1804 
1805     .target:
1806         jump(m_targetLabel)
1807 
1808     .immediate:
<a name="109" id="anc109"></a><span class="line-modified">1809         andq ~TagUndefined, t0</span>
1810         immediateHandler(t0, .target)
1811         dispatch()
1812     end)
1813 end
1814 
1815 equalNullJumpOp(jeq_null, OpJeqNull,
1816     macro (structure, value, target) 
1817         btbz value, MasqueradesAsUndefined, .notMasqueradesAsUndefined
1818         loadp CodeBlock[cfr], t0
1819         loadp CodeBlock::m_globalObject[t0], t0
1820         bpeq Structure::m_globalObject[structure], t0, target
1821 .notMasqueradesAsUndefined:
1822     end,
1823     macro (value, target) bqeq value, ValueNull, target end)
1824 
1825 
1826 equalNullJumpOp(jneq_null, OpJneqNull,
1827     macro (structure, value, target) 
1828         btbz value, MasqueradesAsUndefined, target
1829         loadp CodeBlock[cfr], t0
1830         loadp CodeBlock::m_globalObject[t0], t0
1831         bpneq Structure::m_globalObject[structure], t0, target
1832     end,
1833     macro (value, target) bqneq value, ValueNull, target end)
1834 
1835 macro undefinedOrNullJumpOp(opcodeName, opcodeStruct, fn)
1836     llintOpWithJump(op_%opcodeName%, opcodeStruct, macro (size, get, jump, dispatch)
1837         get(m_value, t1)
1838         loadConstantOrVariable(size, t1, t0)
<a name="110" id="anc110"></a><span class="line-modified">1839         andq ~TagUndefined, t0</span>
1840         fn(t0, .target)
1841         dispatch()
1842 
1843     .target:
1844         jump(m_targetLabel)
1845     end)
1846 end
1847 
1848 undefinedOrNullJumpOp(jundefined_or_null, OpJundefinedOrNull,
1849     macro (value, target) bqeq value, ValueNull, target end)
1850 
1851 undefinedOrNullJumpOp(jnundefined_or_null, OpJnundefinedOrNull,
1852     macro (value, target) bqneq value, ValueNull, target end)
1853 
1854 llintOpWithMetadata(op_jneq_ptr, OpJneqPtr, macro (size, get, dispatch, metadata, return)
1855     get(m_value, t0)
<a name="111" id="anc111"></a><span class="line-modified">1856     get(m_specialPointer, t1)</span>
<span class="line-modified">1857     loadConstant(size, t1, t2)</span>
<span class="line-modified">1858     bpneq t2, [cfr, t0, 8], .opJneqPtrTarget</span>


1859     dispatch()
1860 
1861 .opJneqPtrTarget:
1862     metadata(t5, t0)
1863     storeb 1, OpJneqPtr::Metadata::m_hasJumped[t5]
1864     get(m_targetLabel, t0)
<a name="112" id="anc112"></a><span class="line-modified">1865     jumpImpl(dispatchIndirect, t0)</span>
1866 end)
1867 
1868 
1869 macro compareJumpOp(opcodeName, opcodeStruct, integerCompare, doubleCompare)
1870     llintOpWithJump(op_%opcodeName%, opcodeStruct, macro (size, get, jump, dispatch)
1871         get(m_lhs, t2)
1872         get(m_rhs, t3)
1873         loadConstantOrVariable(size, t2, t0)
1874         loadConstantOrVariable(size, t3, t1)
<a name="113" id="anc113"></a><span class="line-modified">1875         bqb t0, numberTag, .op1NotInt</span>
<span class="line-modified">1876         bqb t1, numberTag, .op2NotInt</span>
1877         integerCompare(t0, t1, .jumpTarget)
1878         dispatch()
1879 
1880     .op1NotInt:
<a name="114" id="anc114"></a><span class="line-modified">1881         btqz t0, numberTag, .slow</span>
<span class="line-modified">1882         bqb t1, numberTag, .op1NotIntOp2NotInt</span>
<span class="line-modified">1883         ci2ds t1, ft1</span>
1884         jmp .op1NotIntReady
1885     .op1NotIntOp2NotInt:
<a name="115" id="anc115"></a><span class="line-modified">1886         btqz t1, numberTag, .slow</span>
<span class="line-modified">1887         addq numberTag, t1</span>
1888         fq2d t1, ft1
1889     .op1NotIntReady:
<a name="116" id="anc116"></a><span class="line-modified">1890         addq numberTag, t0</span>
1891         fq2d t0, ft0
1892         doubleCompare(ft0, ft1, .jumpTarget)
1893         dispatch()
1894 
1895     .op2NotInt:
<a name="117" id="anc117"></a><span class="line-modified">1896         ci2ds t0, ft0</span>
<span class="line-modified">1897         btqz t1, numberTag, .slow</span>
<span class="line-modified">1898         addq numberTag, t1</span>
1899         fq2d t1, ft1
1900         doubleCompare(ft0, ft1, .jumpTarget)
1901         dispatch()
1902 
1903     .jumpTarget:
1904         jump(m_targetLabel)
1905 
1906     .slow:
1907         callSlowPath(_llint_slow_path_%opcodeName%)
1908         nextInstruction()
1909     end)
1910 end
1911 
1912 
1913 macro equalityJumpOp(opcodeName, opcodeStruct, integerComparison)
1914     llintOpWithJump(op_%opcodeName%, opcodeStruct, macro (size, get, jump, dispatch)
1915         get(m_lhs, t2)
1916         get(m_rhs, t3)
1917         loadConstantOrVariableInt32(size, t2, t0, .slow)
1918         loadConstantOrVariableInt32(size, t3, t1, .slow)
1919         integerComparison(t0, t1, .jumpTarget)
1920         dispatch()
1921 
1922     .jumpTarget:
1923         jump(m_targetLabel)
1924 
1925     .slow:
1926         callSlowPath(_llint_slow_path_%opcodeName%)
1927         nextInstruction()
1928     end)
1929 end
1930 
1931 
1932 macro compareUnsignedJumpOp(opcodeName, opcodeStruct, integerCompareMacro)
1933     llintOpWithJump(op_%opcodeName%, opcodeStruct, macro (size, get, jump, dispatch)
1934         get(m_lhs, t2)
1935         get(m_rhs, t3)
1936         loadConstantOrVariable(size, t2, t0)
1937         loadConstantOrVariable(size, t3, t1)
1938         integerCompareMacro(t0, t1, .jumpTarget)
1939         dispatch()
1940 
1941     .jumpTarget:
1942         jump(m_targetLabel)
1943     end)
1944 end
1945 
1946 
1947 macro compareUnsignedOp(opcodeName, opcodeStruct, integerCompareAndSet)
1948     llintOpWithReturn(op_%opcodeName%, opcodeStruct, macro (size, get, dispatch, return)
1949         get(m_lhs, t2)
1950         get(m_rhs,  t0)
1951         loadConstantOrVariable(size, t0, t1)
1952         loadConstantOrVariable(size, t2, t0)
1953         integerCompareAndSet(t0, t1, t0)
1954         orq ValueFalse, t0
1955         return(t0)
1956     end)
1957 end
1958 
1959 
1960 llintOpWithJump(op_switch_imm, OpSwitchImm, macro (size, get, jump, dispatch)
1961     get(m_scrutinee, t2)
1962     getu(size, OpSwitchImm, m_tableIndex, t3)
1963     loadConstantOrVariable(size, t2, t1)
1964     loadp CodeBlock[cfr], t2
1965     loadp CodeBlock::m_rareData[t2], t2
1966     muli sizeof SimpleJumpTable, t3
1967     loadp CodeBlock::RareData::m_switchJumpTables + VectorBufferOffset[t2], t2
1968     addp t3, t2
<a name="118" id="anc118"></a><span class="line-modified">1969     bqb t1, numberTag, .opSwitchImmNotInt</span>
1970     subi SimpleJumpTable::min[t2], t1
1971     biaeq t1, SimpleJumpTable::branchOffsets + VectorSizeOffset[t2], .opSwitchImmFallThrough
1972     loadp SimpleJumpTable::branchOffsets + VectorBufferOffset[t2], t3
1973     loadis [t3, t1, 4], t1
1974     btiz t1, .opSwitchImmFallThrough
1975     dispatchIndirect(t1)
1976 
1977 .opSwitchImmNotInt:
<a name="119" id="anc119"></a><span class="line-modified">1978     btqnz t1, numberTag, .opSwitchImmSlow   # Go slow if it&#39;s a double.</span>
1979 .opSwitchImmFallThrough:
1980     jump(m_defaultOffset)
1981 
1982 .opSwitchImmSlow:
1983     callSlowPath(_llint_slow_path_switch_imm)
1984     nextInstruction()
1985 end)
1986 
1987 
1988 llintOpWithJump(op_switch_char, OpSwitchChar, macro (size, get, jump, dispatch)
1989     get(m_scrutinee, t2)
1990     getu(size, OpSwitchChar, m_tableIndex, t3)
1991     loadConstantOrVariable(size, t2, t1)
1992     loadp CodeBlock[cfr], t2
1993     loadp CodeBlock::m_rareData[t2], t2
1994     muli sizeof SimpleJumpTable, t3
1995     loadp CodeBlock::RareData::m_switchJumpTables + VectorBufferOffset[t2], t2
1996     addp t3, t2
<a name="120" id="anc120"></a><span class="line-modified">1997     btqnz t1, notCellMask, .opSwitchCharFallThrough</span>
1998     bbneq JSCell::m_type[t1], StringType, .opSwitchCharFallThrough
1999     loadp JSString::m_fiber[t1], t0
2000     btpnz t0, isRopeInPointer, .opSwitchOnRope
2001     bineq StringImpl::m_length[t0], 1, .opSwitchCharFallThrough
2002     loadp StringImpl::m_data8[t0], t1
2003     btinz StringImpl::m_hashAndFlags[t0], HashFlags8BitBuffer, .opSwitchChar8Bit
2004     loadh [t1], t0
2005     jmp .opSwitchCharReady
2006 .opSwitchChar8Bit:
2007     loadb [t1], t0
2008 .opSwitchCharReady:
2009     subi SimpleJumpTable::min[t2], t0
2010     biaeq t0, SimpleJumpTable::branchOffsets + VectorSizeOffset[t2], .opSwitchCharFallThrough
2011     loadp SimpleJumpTable::branchOffsets + VectorBufferOffset[t2], t2
2012     loadis [t2, t0, 4], t1
2013     btiz t1, .opSwitchCharFallThrough
2014     dispatchIndirect(t1)
2015 
2016 .opSwitchCharFallThrough:
2017     jump(m_defaultOffset)
2018 
2019 .opSwitchOnRope:
2020     bineq JSRopeString::m_compactFibers + JSRopeString::CompactFibers::m_length[t1], 1, .opSwitchCharFallThrough
2021 
2022 .opSwitchOnRopeChar:
2023     callSlowPath(_llint_slow_path_switch_char)
2024     nextInstruction()
2025 end)
2026 
2027 
2028 # we assume t5 contains the metadata, and we should not scratch that
2029 macro arrayProfileForCall(opcodeStruct, getu)
2030     getu(m_argv, t3)
2031     negp t3
2032     loadq ThisArgumentOffset[cfr, t3, 8], t0
<a name="121" id="anc121"></a><span class="line-modified">2033     btqnz t0, notCellMask, .done</span>
2034     loadi JSCell::m_structureID[t0], t3
2035     storei t3, %opcodeStruct%::Metadata::m_callLinkInfo.m_arrayProfile.m_lastSeenStructureID[t5]
2036 .done:
2037 end
2038 
2039 macro commonCallOp(opcodeName, slowPath, opcodeStruct, prepareCall, prologue)
2040     llintOpWithMetadata(opcodeName, opcodeStruct, macro (size, get, dispatch, metadata, return)
2041         metadata(t5, t0)
2042 
2043         prologue(macro (fieldName, dst)
2044             getu(size, opcodeStruct, fieldName, dst)
2045         end, metadata)
2046 
2047         get(m_callee, t0)
2048         loadp %opcodeStruct%::Metadata::m_callLinkInfo.m_calleeOrLastSeenCalleeWithLinkBit[t5], t2
2049         loadConstantOrVariable(size, t0, t3)
2050         bqneq t3, t2, .opCallSlow
2051         getu(size, opcodeStruct, m_argv, t3)
2052         lshifti 3, t3
2053         negp t3
2054         addp cfr, t3
2055         storeq t2, Callee[t3]
2056         getu(size, opcodeStruct, m_argc, t2)
<a name="122" id="anc122"></a><span class="line-modified">2057         storePC()</span>
<span class="line-modified">2058         storei t2, ArgumentCountIncludingThis + PayloadOffset[t3]</span>
2059         move t3, sp
2060         prepareCall(%opcodeStruct%::Metadata::m_callLinkInfo.m_machineCodeTarget[t5], t2, t3, t4, JSEntryPtrTag)
<a name="123" id="anc123"></a><span class="line-modified">2061         callTargetFunction(opcodeName, size, opcodeStruct, dispatch, %opcodeStruct%::Metadata::m_callLinkInfo.m_machineCodeTarget[t5], JSEntryPtrTag)</span>
2062 
2063     .opCallSlow:
<a name="124" id="anc124"></a><span class="line-modified">2064         slowPathForCall(opcodeName, size, opcodeStruct, dispatch, slowPath, prepareCall)</span>
2065     end)
2066 end
2067 
2068 llintOp(op_ret, OpRet, macro (size, get, dispatch)
2069     checkSwitchToJITForEpilogue()
2070     get(m_value, t2)
2071     loadConstantOrVariable(size, t2, r0)
2072     doReturn()
2073 end)
2074 
2075 
2076 llintOpWithReturn(op_to_primitive, OpToPrimitive, macro (size, get, dispatch, return)
2077     get(m_src, t2)
2078     loadConstantOrVariable(size, t2, t0)
<a name="125" id="anc125"></a><span class="line-modified">2079     btqnz t0, notCellMask, .opToPrimitiveIsImm</span>
2080     bbaeq JSCell::m_type[t0], ObjectType, .opToPrimitiveSlowCase
2081 .opToPrimitiveIsImm:
2082     return(t0)
2083 
2084 .opToPrimitiveSlowCase:
2085     callSlowPath(_slow_path_to_primitive)
2086     dispatch()
2087 end)
2088 
2089 
<a name="126" id="anc126"></a><span class="line-added">2090 llintOpWithReturn(op_to_property_key, OpToPropertyKey, macro (size, get, dispatch, return)</span>
<span class="line-added">2091     get(m_src, t2)</span>
<span class="line-added">2092     loadConstantOrVariable(size, t2, t0)</span>
<span class="line-added">2093 </span>
<span class="line-added">2094     btqnz t0, notCellMask, .opToPropertyKeySlow</span>
<span class="line-added">2095     bbeq JSCell::m_type[t0], SymbolType, .done</span>
<span class="line-added">2096     bbneq JSCell::m_type[t0], StringType, .opToPropertyKeySlow</span>
<span class="line-added">2097 </span>
<span class="line-added">2098 .done:</span>
<span class="line-added">2099     return(t0)</span>
<span class="line-added">2100 </span>
<span class="line-added">2101 .opToPropertyKeySlow:</span>
<span class="line-added">2102     callSlowPath(_slow_path_to_property_key)</span>
<span class="line-added">2103     dispatch()</span>
<span class="line-added">2104 end)</span>
<span class="line-added">2105 </span>
<span class="line-added">2106 </span>
2107 commonOp(llint_op_catch, macro() end, macro (size)
2108     # This is where we end up from the JIT&#39;s throw trampoline (because the
2109     # machine code return address will be set to _llint_op_catch), and from
2110     # the interpreter&#39;s throw trampoline (see _llint_throw_trampoline).
2111     # The throwing code must have known that we were throwing to the interpreter,
2112     # and have set VM::targetInterpreterPCForThrow.
2113     loadp Callee[cfr], t3
<a name="127" id="anc127"></a><span class="line-modified">2114     convertCalleeToVM(t3)</span>

2115     restoreCalleeSavesFromVMEntryFrameCalleeSavesBuffer(t3, t0)
2116     loadp VM::callFrameForCatch[t3], cfr
2117     storep 0, VM::callFrameForCatch[t3]
2118     restoreStackPointerAfterCall()
2119 
2120     loadp CodeBlock[cfr], PB
2121     loadp CodeBlock::m_metadata[PB], metadataTable
2122     loadp CodeBlock::m_instructionsRawPointer[PB], PB
2123     loadp VM::targetInterpreterPCForThrow[t3], PC
2124     subp PB, PC
2125 
2126     callSlowPath(_llint_slow_path_check_if_exception_is_uncatchable_and_notify_profiler)
2127     bpeq r1, 0, .isCatchableException
2128     jmp _llint_throw_from_slow_path_trampoline
2129 
2130 .isCatchableException:
<a name="128" id="anc128"></a><span class="line-modified">2131     loadp CodeBlock[cfr], t3</span>
<span class="line-modified">2132     loadp CodeBlock::m_vm[t3], t3</span>

2133 
2134     loadp VM::m_exception[t3], t0
2135     storep 0, VM::m_exception[t3]
2136     get(size, OpCatch, m_exception, t2)
2137     storeq t0, [cfr, t2, 8]
2138 
2139     loadq Exception::m_value[t0], t3
2140     get(size, OpCatch, m_thrownValue, t2)
2141     storeq t3, [cfr, t2, 8]
2142 
2143     traceExecution()
2144 
2145     callSlowPath(_llint_slow_path_profile_catch)
2146 
2147     dispatchOp(size, op_catch)
2148 end)
2149 
2150 
2151 llintOp(op_end, OpEnd, macro (size, get, dispatch)
2152     checkSwitchToJITForEpilogue()
2153     get(m_value, t0)
2154     assertNotConstant(size, t0)
2155     loadq [cfr, t0, 8], r0
2156     doReturn()
2157 end)
2158 
2159 
2160 op(llint_throw_from_slow_path_trampoline, macro ()
2161     loadp Callee[cfr], t1
<a name="129" id="anc129"></a><span class="line-modified">2162     convertCalleeToVM(t1)</span>

2163     copyCalleeSavesToVMEntryFrameCalleeSavesBuffer(t1, t2)
2164 
2165     callSlowPath(_llint_slow_path_handle_exception)
2166 
2167     # When throwing from the interpreter (i.e. throwing from LLIntSlowPaths), so
2168     # the throw target is not necessarily interpreted code, we come to here.
2169     # This essentially emulates the JIT&#39;s throwing protocol.
2170     loadp Callee[cfr], t1
<a name="130" id="anc130"></a><span class="line-modified">2171     convertCalleeToVM(t1)</span>

2172     jmp VM::targetMachinePCForThrow[t1], ExceptionHandlerPtrTag
2173 end)
2174 
2175 
2176 op(llint_throw_during_call_trampoline, macro ()
2177     preserveReturnAddressAfterCall(t2)
2178     jmp _llint_throw_from_slow_path_trampoline
2179 end)
2180 
2181 
2182 macro nativeCallTrampoline(executableOffsetToFunction)
<a name="131" id="anc131"></a>
2183     functionPrologue()
2184     storep 0, CodeBlock[cfr]
<a name="132" id="anc132"></a><span class="line-modified">2185     loadp Callee[cfr], a0</span>
<span class="line-modified">2186     loadp JSFunction::m_executableOrRareData[a0], a2</span>
<span class="line-modified">2187     btpz a2, (constexpr JSFunction::rareDataTag), .isExecutable</span>
<span class="line-modified">2188     loadp (FunctionRareData::m_executable - (constexpr JSFunction::rareDataTag))[a2], a2</span>
<span class="line-added">2189 .isExecutable:</span>
<span class="line-added">2190     loadp JSFunction::m_scope[a0], a0</span>
<span class="line-added">2191     loadp JSGlobalObject::m_vm[a0], a1</span>
<span class="line-added">2192     storep cfr, VM::topCallFrame[a1]</span>
2193     if ARM64 or ARM64E or C_LOOP or C_LOOP_WIN
2194         storep lr, ReturnPC[cfr]
2195     end
<a name="133" id="anc133"></a><span class="line-modified">2196     move cfr, a1</span>


2197     checkStackPointerAlignment(t3, 0xdead0001)
2198     if C_LOOP or C_LOOP_WIN
<a name="134" id="anc134"></a><span class="line-modified">2199         cloopCallNative executableOffsetToFunction[a2]</span>
2200     else
2201         if X86_64_WIN
2202             subp 32, sp
<a name="135" id="anc135"></a><span class="line-modified">2203             call executableOffsetToFunction[a2], JSEntryPtrTag</span>
2204             addp 32, sp
2205         else
<a name="136" id="anc136"></a><span class="line-modified">2206             call executableOffsetToFunction[a2], JSEntryPtrTag</span>
2207         end
2208     end
2209 
2210     loadp Callee[cfr], t3
<a name="137" id="anc137"></a><span class="line-modified">2211     loadp JSFunction::m_scope[t3], t3</span>
<span class="line-modified">2212     loadp JSGlobalObject::m_vm[t3], t3</span>
2213 
2214     btpnz VM::m_exception[t3], .handleException
2215 
2216     functionEpilogue()
2217     ret
2218 
2219 .handleException:
2220     storep cfr, VM::topCallFrame[t3]
2221     jmp _llint_throw_from_slow_path_trampoline
2222 end
2223 
2224 macro internalFunctionCallTrampoline(offsetOfFunction)
2225     functionPrologue()
2226     storep 0, CodeBlock[cfr]
<a name="138" id="anc138"></a><span class="line-modified">2227     loadp Callee[cfr], a2</span>
<span class="line-modified">2228     loadp InternalFunction::m_globalObject[a2], a0</span>
<span class="line-modified">2229     loadp JSGlobalObject::m_vm[a0], a1</span>
<span class="line-modified">2230     storep cfr, VM::topCallFrame[a1]</span>
2231     if ARM64 or ARM64E or C_LOOP or C_LOOP_WIN
2232         storep lr, ReturnPC[cfr]
2233     end
<a name="139" id="anc139"></a><span class="line-modified">2234     move cfr, a1</span>

2235     checkStackPointerAlignment(t3, 0xdead0001)
2236     if C_LOOP or C_LOOP_WIN
<a name="140" id="anc140"></a><span class="line-modified">2237         cloopCallNative offsetOfFunction[a2]</span>
2238     else
2239         if X86_64_WIN
2240             subp 32, sp
<a name="141" id="anc141"></a><span class="line-modified">2241             call offsetOfFunction[a2], JSEntryPtrTag</span>
2242             addp 32, sp
2243         else
<a name="142" id="anc142"></a><span class="line-modified">2244             call offsetOfFunction[a2], JSEntryPtrTag</span>
2245         end
2246     end
2247 
2248     loadp Callee[cfr], t3
<a name="143" id="anc143"></a><span class="line-modified">2249     loadp InternalFunction::m_globalObject[t3], t3</span>
<span class="line-modified">2250     loadp JSGlobalObject::m_vm[t3], t3</span>
2251 
2252     btpnz VM::m_exception[t3], .handleException
2253 
2254     functionEpilogue()
2255     ret
2256 
2257 .handleException:
2258     storep cfr, VM::topCallFrame[t3]
2259     jmp _llint_throw_from_slow_path_trampoline
2260 end
2261 
2262 macro varInjectionCheck(slowPath, scratch)
2263     loadp CodeBlock[cfr], scratch
2264     loadp CodeBlock::m_globalObject[scratch], scratch
2265     loadp JSGlobalObject::m_varInjectionWatchpoint[scratch], scratch
2266     bbeq WatchpointSet::m_state[scratch], IsInvalidated, slowPath
2267 end
2268 
2269 llintOpWithMetadata(op_resolve_scope, OpResolveScope, macro (size, get, dispatch, metadata, return)
2270     metadata(t5, t0)
2271 
2272     macro getConstantScope(dst)
2273         loadp OpResolveScope::Metadata::m_constantScope[t5], dst
2274     end
2275 
2276     macro returnConstantScope()
2277         getConstantScope(t0)
2278         return(t0)
2279     end
2280 
2281     macro globalLexicalBindingEpochCheck(slowPath, globalObject, scratch)
2282         loadi OpResolveScope::Metadata::m_globalLexicalBindingEpoch[t5], scratch
2283         bineq JSGlobalObject::m_globalLexicalBindingEpoch[globalObject], scratch, slowPath
2284     end
2285 
2286     macro resolveScope()
2287         loadi OpResolveScope::Metadata::m_localScopeDepth[t5], t2
2288         get(m_scope, t0)
2289         loadq [cfr, t0, 8], t0
2290         btiz t2, .resolveScopeLoopEnd
2291 
2292     .resolveScopeLoop:
2293         loadp JSScope::m_next[t0], t0
2294         subi 1, t2
2295         btinz t2, .resolveScopeLoop
2296 
2297     .resolveScopeLoopEnd:
2298         return(t0)
2299     end
2300 
2301     loadi OpResolveScope::Metadata::m_resolveType[t5], t0
2302 
2303 #rGlobalProperty:
2304     bineq t0, GlobalProperty, .rGlobalVar
2305     getConstantScope(t0)
2306     globalLexicalBindingEpochCheck(.rDynamic, t0, t2)
2307     return(t0)
2308 
2309 .rGlobalVar:
2310     bineq t0, GlobalVar, .rGlobalLexicalVar
2311     returnConstantScope()
2312 
2313 .rGlobalLexicalVar:
2314     bineq t0, GlobalLexicalVar, .rClosureVar
2315     returnConstantScope()
2316 
2317 .rClosureVar:
2318     bineq t0, ClosureVar, .rModuleVar
2319     resolveScope()
2320 
2321 .rModuleVar:
2322     bineq t0, ModuleVar, .rGlobalPropertyWithVarInjectionChecks
2323     returnConstantScope()
2324 
2325 .rGlobalPropertyWithVarInjectionChecks:
2326     bineq t0, GlobalPropertyWithVarInjectionChecks, .rGlobalVarWithVarInjectionChecks
2327     varInjectionCheck(.rDynamic, t2)
2328     getConstantScope(t0)
2329     globalLexicalBindingEpochCheck(.rDynamic, t0, t2)
2330     return(t0)
2331 
2332 .rGlobalVarWithVarInjectionChecks:
2333     bineq t0, GlobalVarWithVarInjectionChecks, .rGlobalLexicalVarWithVarInjectionChecks
2334     varInjectionCheck(.rDynamic, t2)
2335     returnConstantScope()
2336 
2337 .rGlobalLexicalVarWithVarInjectionChecks:
2338     bineq t0, GlobalLexicalVarWithVarInjectionChecks, .rClosureVarWithVarInjectionChecks
2339     varInjectionCheck(.rDynamic, t2)
2340     returnConstantScope()
2341 
2342 .rClosureVarWithVarInjectionChecks:
2343     bineq t0, ClosureVarWithVarInjectionChecks, .rDynamic
2344     varInjectionCheck(.rDynamic, t2)
2345     resolveScope()
2346 
2347 .rDynamic:
2348     callSlowPath(_slow_path_resolve_scope)
2349     dispatch()
2350 end)
2351 
2352 
2353 macro loadWithStructureCheck(opcodeStruct, get, slowPath)
2354     get(m_scope, t0)
2355     loadq [cfr, t0, 8], t0
2356     loadStructureWithScratch(t0, t2, t1, t3)
2357     loadp %opcodeStruct%::Metadata::m_structure[t5], t1
2358     bpneq t2, t1, slowPath
2359 end
2360 
2361 llintOpWithMetadata(op_get_from_scope, OpGetFromScope, macro (size, get, dispatch, metadata, return)
2362     metadata(t5, t0)
2363 
2364     macro getProperty()
2365         loadp OpGetFromScope::Metadata::m_operand[t5], t1
2366         loadPropertyAtVariableOffset(t1, t0, t2)
2367         valueProfile(OpGetFromScope, t5, t2)
2368         return(t2)
2369     end
2370 
2371     macro getGlobalVar(tdzCheckIfNecessary)
2372         loadp OpGetFromScope::Metadata::m_operand[t5], t0
2373         loadq [t0], t0
2374         tdzCheckIfNecessary(t0)
2375         valueProfile(OpGetFromScope, t5, t0)
2376         return(t0)
2377     end
2378 
2379     macro getClosureVar()
2380         loadp OpGetFromScope::Metadata::m_operand[t5], t1
2381         loadq JSLexicalEnvironment_variables[t0, t1, 8], t0
2382         valueProfile(OpGetFromScope, t5, t0)
2383         return(t0)
2384     end
2385 
2386     loadi OpGetFromScope::Metadata::m_getPutInfo + GetPutInfo::m_operand[t5], t0
2387     andi ResolveTypeMask, t0
2388 
2389 #gGlobalProperty:
2390     bineq t0, GlobalProperty, .gGlobalVar
2391     loadWithStructureCheck(OpGetFromScope, get, .gDynamic) # This structure check includes lexical binding epoch check since when the epoch is changed, scope will be changed too.
2392     getProperty()
2393 
2394 .gGlobalVar:
2395     bineq t0, GlobalVar, .gGlobalLexicalVar
2396     getGlobalVar(macro(v) end)
2397 
2398 .gGlobalLexicalVar:
2399     bineq t0, GlobalLexicalVar, .gClosureVar
2400     getGlobalVar(
2401         macro (value)
2402             bqeq value, ValueEmpty, .gDynamic
2403         end)
2404 
2405 .gClosureVar:
2406     bineq t0, ClosureVar, .gGlobalPropertyWithVarInjectionChecks
2407     loadVariable(get, m_scope, t0)
2408     getClosureVar()
2409 
2410 .gGlobalPropertyWithVarInjectionChecks:
2411     bineq t0, GlobalPropertyWithVarInjectionChecks, .gGlobalVarWithVarInjectionChecks
2412     loadWithStructureCheck(OpGetFromScope, get, .gDynamic) # This structure check includes lexical binding epoch check since when the epoch is changed, scope will be changed too.
2413     getProperty()
2414 
2415 .gGlobalVarWithVarInjectionChecks:
2416     bineq t0, GlobalVarWithVarInjectionChecks, .gGlobalLexicalVarWithVarInjectionChecks
2417     varInjectionCheck(.gDynamic, t2)
2418     getGlobalVar(macro(v) end)
2419 
2420 .gGlobalLexicalVarWithVarInjectionChecks:
2421     bineq t0, GlobalLexicalVarWithVarInjectionChecks, .gClosureVarWithVarInjectionChecks
2422     varInjectionCheck(.gDynamic, t2)
2423     getGlobalVar(
2424         macro (value)
2425             bqeq value, ValueEmpty, .gDynamic
2426         end)
2427 
2428 .gClosureVarWithVarInjectionChecks:
2429     bineq t0, ClosureVarWithVarInjectionChecks, .gDynamic
2430     varInjectionCheck(.gDynamic, t2)
2431     loadVariable(get, m_scope, t0)
2432     getClosureVar()
2433 
2434 .gDynamic:
2435     callSlowPath(_llint_slow_path_get_from_scope)
2436     dispatch()
2437 end)
2438 
2439 
2440 llintOpWithMetadata(op_put_to_scope, OpPutToScope, macro (size, get, dispatch, metadata, return)
2441     macro putProperty()
2442         get(m_value, t1)
2443         loadConstantOrVariable(size, t1, t2)
2444         loadp OpPutToScope::Metadata::m_operand[t5], t1
2445         storePropertyAtVariableOffset(t1, t0, t2)
2446     end
2447 
2448     macro putGlobalVariable()
2449         get(m_value, t0)
2450         loadConstantOrVariable(size, t0, t1)
2451         loadp OpPutToScope::Metadata::m_watchpointSet[t5], t2
2452         btpz t2, .noVariableWatchpointSet
2453         notifyWrite(t2, .pDynamic)
2454     .noVariableWatchpointSet:
2455         loadp OpPutToScope::Metadata::m_operand[t5], t0
2456         storeq t1, [t0]
2457     end
2458 
2459     macro putClosureVar()
2460         get(m_value, t1)
2461         loadConstantOrVariable(size, t1, t2)
2462         loadp OpPutToScope::Metadata::m_operand[t5], t1
2463         storeq t2, JSLexicalEnvironment_variables[t0, t1, 8]
2464     end
2465 
2466     macro putLocalClosureVar()
2467         get(m_value, t1)
2468         loadConstantOrVariable(size, t1, t2)
2469         loadp OpPutToScope::Metadata::m_watchpointSet[t5], t3
2470         btpz t3, .noVariableWatchpointSet
2471         notifyWrite(t3, .pDynamic)
2472     .noVariableWatchpointSet:
2473         loadp OpPutToScope::Metadata::m_operand[t5], t1
2474         storeq t2, JSLexicalEnvironment_variables[t0, t1, 8]
2475     end
2476 
2477     macro checkTDZInGlobalPutToScopeIfNecessary()
2478         loadi OpPutToScope::Metadata::m_getPutInfo + GetPutInfo::m_operand[t5], t0
2479         andi InitializationModeMask, t0
2480         rshifti InitializationModeShift, t0
2481         bineq t0, NotInitialization, .noNeedForTDZCheck
2482         loadp OpPutToScope::Metadata::m_operand[t5], t0
2483         loadq [t0], t0
2484         bqeq t0, ValueEmpty, .pDynamic
2485     .noNeedForTDZCheck:
2486     end
2487 
2488     metadata(t5, t0)
2489     loadi OpPutToScope::Metadata::m_getPutInfo + GetPutInfo::m_operand[t5], t0
2490     andi ResolveTypeMask, t0
2491 
2492 #pLocalClosureVar:
2493     bineq t0, LocalClosureVar, .pGlobalProperty
2494     loadVariable(get, m_scope, t0)
2495     putLocalClosureVar()
2496     writeBarrierOnOperands(size, get, m_scope, m_value)
2497     dispatch()
2498 
2499 .pGlobalProperty:
2500     bineq t0, GlobalProperty, .pGlobalVar
2501     loadWithStructureCheck(OpPutToScope, get, .pDynamic) # This structure check includes lexical binding epoch check since when the epoch is changed, scope will be changed too.
2502     putProperty()
2503     writeBarrierOnOperands(size, get, m_scope, m_value)
2504     dispatch()
2505 
2506 .pGlobalVar:
2507     bineq t0, GlobalVar, .pGlobalLexicalVar
2508     putGlobalVariable()
2509     writeBarrierOnGlobalObject(size, get, m_value)
2510     dispatch()
2511 
2512 .pGlobalLexicalVar:
2513     bineq t0, GlobalLexicalVar, .pClosureVar
2514     checkTDZInGlobalPutToScopeIfNecessary()
2515     putGlobalVariable()
2516     writeBarrierOnGlobalLexicalEnvironment(size, get, m_value)
2517     dispatch()
2518 
2519 .pClosureVar:
2520     bineq t0, ClosureVar, .pGlobalPropertyWithVarInjectionChecks
2521     loadVariable(get, m_scope, t0)
2522     putClosureVar()
2523     writeBarrierOnOperands(size, get, m_scope, m_value)
2524     dispatch()
2525 
2526 .pGlobalPropertyWithVarInjectionChecks:
2527     bineq t0, GlobalPropertyWithVarInjectionChecks, .pGlobalVarWithVarInjectionChecks
2528     loadWithStructureCheck(OpPutToScope, get, .pDynamic) # This structure check includes lexical binding epoch check since when the epoch is changed, scope will be changed too.
2529     putProperty()
2530     writeBarrierOnOperands(size, get, m_scope, m_value)
2531     dispatch()
2532 
2533 .pGlobalVarWithVarInjectionChecks:
2534     bineq t0, GlobalVarWithVarInjectionChecks, .pGlobalLexicalVarWithVarInjectionChecks
2535     varInjectionCheck(.pDynamic, t2)
2536     putGlobalVariable()
2537     writeBarrierOnGlobalObject(size, get, m_value)
2538     dispatch()
2539 
2540 .pGlobalLexicalVarWithVarInjectionChecks:
2541     bineq t0, GlobalLexicalVarWithVarInjectionChecks, .pClosureVarWithVarInjectionChecks
2542     varInjectionCheck(.pDynamic, t2)
2543     checkTDZInGlobalPutToScopeIfNecessary()
2544     putGlobalVariable()
2545     writeBarrierOnGlobalLexicalEnvironment(size, get, m_value)
2546     dispatch()
2547 
2548 .pClosureVarWithVarInjectionChecks:
2549     bineq t0, ClosureVarWithVarInjectionChecks, .pModuleVar
2550     varInjectionCheck(.pDynamic, t2)
2551     loadVariable(get, m_scope, t0)
2552     putClosureVar()
2553     writeBarrierOnOperands(size, get, m_scope, m_value)
2554     dispatch()
2555 
2556 .pModuleVar:
2557     bineq t0, ModuleVar, .pDynamic
2558     callSlowPath(_slow_path_throw_strict_mode_readonly_property_write_error)
2559     dispatch()
2560 
2561 .pDynamic:
2562     callSlowPath(_llint_slow_path_put_to_scope)
2563     dispatch()
2564 end)
2565 
2566 
2567 llintOpWithProfile(op_get_from_arguments, OpGetFromArguments, macro (size, get, dispatch, return)
2568     loadVariable(get, m_arguments, t0)
2569     getu(size, OpGetFromArguments, m_index, t1)
2570     loadq DirectArguments_storage[t0, t1, 8], t0
2571     return(t0)
2572 end)
2573 
2574 
2575 llintOp(op_put_to_arguments, OpPutToArguments, macro (size, get, dispatch)
2576     loadVariable(get, m_arguments, t0)
2577     getu(size, OpPutToArguments, m_index, t1)
2578     get(m_value, t3)
2579     loadConstantOrVariable(size, t3, t2)
2580     storeq t2, DirectArguments_storage[t0, t1, 8]
2581     writeBarrierOnOperands(size, get, m_arguments, m_value)
2582     dispatch()
2583 end)
2584 
2585 
2586 llintOpWithReturn(op_get_parent_scope, OpGetParentScope, macro (size, get, dispatch, return)
2587     loadVariable(get, m_scope, t0)
2588     loadp JSScope::m_next[t0], t0
2589     return(t0)
2590 end)
2591 
2592 
2593 llintOpWithMetadata(op_profile_type, OpProfileType, macro (size, get, dispatch, metadata, return)
2594     loadp CodeBlock[cfr], t1
2595     loadp CodeBlock::m_vm[t1], t1
2596     # t1 is holding the pointer to the typeProfilerLog.
2597     loadp VM::m_typeProfilerLog[t1], t1
2598     # t2 is holding the pointer to the current log entry.
2599     loadp TypeProfilerLog::m_currentLogEntryPtr[t1], t2
2600 
2601     # t0 is holding the JSValue argument.
2602     get(m_targetVirtualRegister, t3)
2603     loadConstantOrVariable(size, t3, t0)
2604 
2605     bqeq t0, ValueEmpty, .opProfileTypeDone
2606     # Store the JSValue onto the log entry.
2607     storeq t0, TypeProfilerLog::LogEntry::value[t2]
2608     
2609     # Store the TypeLocation onto the log entry.
2610     metadata(t5, t3)
2611     loadp OpProfileType::Metadata::m_typeLocation[t5], t3
2612     storep t3, TypeProfilerLog::LogEntry::location[t2]
2613 
<a name="144" id="anc144"></a><span class="line-modified">2614     btqz t0, notCellMask, .opProfileTypeIsCell</span>
2615     storei 0, TypeProfilerLog::LogEntry::structureID[t2]
2616     jmp .opProfileTypeSkipIsCell
2617 .opProfileTypeIsCell:
2618     loadi JSCell::m_structureID[t0], t3
2619     storei t3, TypeProfilerLog::LogEntry::structureID[t2]
2620 .opProfileTypeSkipIsCell:
2621     
2622     # Increment the current log entry.
2623     addp sizeof TypeProfilerLog::LogEntry, t2
2624     storep t2, TypeProfilerLog::m_currentLogEntryPtr[t1]
2625 
2626     loadp TypeProfilerLog::m_logEndPtr[t1], t1
2627     bpneq t2, t1, .opProfileTypeDone
2628     callSlowPath(_slow_path_profile_type_clear_log)
2629 
2630 .opProfileTypeDone:
2631     dispatch()
2632 end)
2633 
2634 
2635 llintOpWithMetadata(op_profile_control_flow, OpProfileControlFlow, macro (size, get, dispatch, metadata, return)
2636     metadata(t5, t0)
2637     loadp OpProfileControlFlow::Metadata::m_basicBlockLocation[t5], t0
2638     addq 1, BasicBlockLocation::m_executionCount[t0]
2639     dispatch()
2640 end)
2641 
2642 
2643 llintOpWithReturn(op_get_rest_length, OpGetRestLength, macro (size, get, dispatch, return)
<a name="145" id="anc145"></a><span class="line-modified">2644     loadi PayloadOffset + ArgumentCountIncludingThis[cfr], t0</span>
2645     subi 1, t0
2646     getu(size, OpGetRestLength, m_numParametersToSkip, t1)
2647     bilteq t0, t1, .storeZero
2648     subi t1, t0
2649     jmp .boxUp
2650 .storeZero:
2651     move 0, t0
2652 .boxUp:
<a name="146" id="anc146"></a><span class="line-modified">2653     orq numberTag, t0</span>
<span class="line-added">2654     return(t0)</span>
<span class="line-added">2655 end)</span>
<span class="line-added">2656 </span>
<span class="line-added">2657 </span>
<span class="line-added">2658 llintOpWithProfile(op_get_internal_field, OpGetInternalField, macro (size, get, dispatch, return)</span>
<span class="line-added">2659     loadVariable(get, m_base, t1)</span>
<span class="line-added">2660     getu(size, OpGetInternalField, m_index, t2)</span>
<span class="line-added">2661     loadq JSInternalFieldObjectImpl_internalFields[t1, t2, SlotSize], t0</span>
2662     return(t0)
2663 end)
2664 
<a name="147" id="anc147"></a><span class="line-added">2665 llintOp(op_put_internal_field, OpPutInternalField, macro (size, get, dispatch)</span>
<span class="line-added">2666     loadVariable(get, m_base, t0)</span>
<span class="line-added">2667     get(m_value, t1)</span>
<span class="line-added">2668     loadConstantOrVariable(size, t1, t2)</span>
<span class="line-added">2669     getu(size, OpPutInternalField, m_index, t1)</span>
<span class="line-added">2670     storeq t2, JSInternalFieldObjectImpl_internalFields[t0, t1, SlotSize]</span>
<span class="line-added">2671     writeBarrierOnCellAndValueWithReload(t0, t2, macro() end)</span>
<span class="line-added">2672     dispatch()</span>
<span class="line-added">2673 end)</span>
<span class="line-added">2674 </span>
2675 
2676 llintOp(op_log_shadow_chicken_prologue, OpLogShadowChickenPrologue, macro (size, get, dispatch)
2677     acquireShadowChickenPacket(.opLogShadowChickenPrologueSlow)
2678     storep cfr, ShadowChicken::Packet::frame[t0]
2679     loadp CallerFrame[cfr], t1
2680     storep t1, ShadowChicken::Packet::callerFrame[t0]
2681     loadp Callee[cfr], t1
2682     storep t1, ShadowChicken::Packet::callee[t0]
2683     loadVariable(get, m_scope, t1)
2684     storep t1, ShadowChicken::Packet::scope[t0]
2685     dispatch()
2686 .opLogShadowChickenPrologueSlow:
2687     callSlowPath(_llint_slow_path_log_shadow_chicken_prologue)
2688     dispatch()
2689 end)
2690 
2691 
2692 llintOp(op_log_shadow_chicken_tail, OpLogShadowChickenTail, macro (size, get, dispatch)
2693     acquireShadowChickenPacket(.opLogShadowChickenTailSlow)
2694     storep cfr, ShadowChicken::Packet::frame[t0]
2695     storep ShadowChickenTailMarker, ShadowChicken::Packet::callee[t0]
2696     loadVariable(get, m_thisValue, t1)
2697     storep t1, ShadowChicken::Packet::thisValue[t0]
2698     loadVariable(get, m_scope, t1)
2699     storep t1, ShadowChicken::Packet::scope[t0]
2700     loadp CodeBlock[cfr], t1
2701     storep t1, ShadowChicken::Packet::codeBlock[t0]
2702     storei PC, ShadowChicken::Packet::callSiteIndex[t0]
2703     dispatch()
2704 .opLogShadowChickenTailSlow:
2705     callSlowPath(_llint_slow_path_log_shadow_chicken_tail)
2706     dispatch()
2707 end)
<a name="148" id="anc148"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="148" type="hidden" />
</body>
</html>
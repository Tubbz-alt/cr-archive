<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorCanvasAgent.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="InspectorCSSAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorCanvasAgent.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/inspector/agents/InspectorCanvasAgent.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorCanvasAgent.h&quot;
 28 
<span class="line-removed"> 29 #include &quot;ActiveDOMCallbackMicrotask.h&quot;</span>
 30 #include &quot;CanvasRenderingContext.h&quot;
 31 #include &quot;CanvasRenderingContext2D.h&quot;
 32 #include &quot;Document.h&quot;
 33 #include &quot;Element.h&quot;

 34 #include &quot;Frame.h&quot;
 35 #include &quot;HTMLCanvasElement.h&quot;

 36 #include &quot;ImageBitmapRenderingContext.h&quot;
 37 #include &quot;InspectorDOMAgent.h&quot;

 38 #include &quot;InstrumentingAgents.h&quot;
<span class="line-removed"> 39 #include &quot;JSCanvasRenderingContext2D.h&quot;</span>
 40 #include &quot;JSExecState.h&quot;
<span class="line-removed"> 41 #include &quot;JSImageBitmapRenderingContext.h&quot;</span>
<span class="line-removed"> 42 #include &quot;Microtasks.h&quot;</span>
<span class="line-removed"> 43 #include &quot;OffscreenCanvas.h&quot;</span>
 44 #include &quot;ScriptState.h&quot;
 45 #include &quot;StringAdaptors.h&quot;
 46 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 47 #include &lt;JavaScriptCore/InjectedScript.h&gt;
 48 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
 49 #include &lt;JavaScriptCore/InspectorProtocolObjects.h&gt;
 50 #include &lt;JavaScriptCore/JSCInlines.h&gt;

 51 #include &lt;wtf/HashSet.h&gt;
 52 #include &lt;wtf/Lock.h&gt;








 53 
 54 #if ENABLE(WEBGL)
<span class="line-removed"> 55 #include &quot;JSWebGLRenderingContext.h&quot;</span>
 56 #include &quot;WebGLProgram.h&quot;
<span class="line-modified"> 57 #include &quot;WebGLShader.h&quot;</span>

 58 #endif
 59 
 60 #if ENABLE(WEBGL2)
<span class="line-modified"> 61 #include &quot;JSWebGL2RenderingContext.h&quot;</span>
 62 #endif
 63 
 64 #if ENABLE(WEBGPU)
<span class="line-modified"> 65 #include &quot;JSGPUCanvasContext.h&quot;</span>





 66 #endif
 67 
 68 namespace WebCore {
 69 
 70 using namespace Inspector;
 71 
 72 InspectorCanvasAgent::InspectorCanvasAgent(PageAgentContext&amp; context)
 73     : InspectorAgentBase(&quot;Canvas&quot;_s, context)
 74     , m_frontendDispatcher(makeUnique&lt;Inspector::CanvasFrontendDispatcher&gt;(context.frontendRouter))
 75     , m_backendDispatcher(Inspector::CanvasBackendDispatcher::create(context.backendDispatcher, this))
 76     , m_injectedScriptManager(context.injectedScriptManager)
 77     , m_inspectedPage(context.inspectedPage)
 78     , m_canvasDestroyedTimer(*this, &amp;InspectorCanvasAgent::canvasDestroyedTimerFired)

 79 {
 80 }
 81 
 82 InspectorCanvasAgent::~InspectorCanvasAgent() = default;
 83 
 84 void InspectorCanvasAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 85 {
 86 }
 87 
 88 void InspectorCanvasAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
 89 {
 90     ErrorString ignored;
 91     disable(ignored);
 92 }
 93 
 94 void InspectorCanvasAgent::discardAgent()
 95 {
<span class="line-modified"> 96     clearCanvasData();</span>
 97 }
 98 
 99 void InspectorCanvasAgent::enable(ErrorString&amp;)
100 {
101     if (m_instrumentingAgents.inspectorCanvasAgent() == this)
102         return;
103 
104     m_instrumentingAgents.setInspectorCanvasAgent(this);
105 
<span class="line-modified">106     const auto canvasExistsInCurrentPage = [&amp;] (CanvasRenderingContext* canvasRenderingContext) {</span>
<span class="line-removed">107         if (!canvasRenderingContext)</span>
<span class="line-removed">108             return false;</span>
<span class="line-removed">109 </span>
<span class="line-removed">110         auto* scriptExecutionContext = canvasRenderingContext-&gt;canvasBase().scriptExecutionContext();</span>
111         if (!is&lt;Document&gt;(scriptExecutionContext))
112             return false;
113 
114         // FIXME: &lt;https://webkit.org/b/168475&gt; Web Inspector: Correctly display iframe&#39;s WebSockets
115         auto* document = downcast&lt;Document&gt;(scriptExecutionContext);
116         return document-&gt;page() == &amp;m_inspectedPage;
117     };
118 
119     {
120         LockHolder lock(CanvasRenderingContext::instancesMutex());
<span class="line-modified">121         for (auto* canvasRenderingContext : CanvasRenderingContext::instances(lock)) {</span>
<span class="line-modified">122             if (canvasExistsInCurrentPage(canvasRenderingContext))</span>
<span class="line-modified">123                 bindCanvas(*canvasRenderingContext, false);</span>






124         }
125     }
126 










127 #if ENABLE(WEBGL)
128     {
129         LockHolder lock(WebGLProgram::instancesMutex());
<span class="line-modified">130         for (auto&amp; entry : WebGLProgram::instances(lock)) {</span>
<span class="line-modified">131             if (canvasExistsInCurrentPage(entry.value))</span>
<span class="line-modified">132                 didCreateProgram(*entry.value, *entry.key);</span>










133         }
134     }
135 #endif
136 }
137 
138 void InspectorCanvasAgent::disable(ErrorString&amp;)
139 {
140     m_instrumentingAgents.setInspectorCanvasAgent(nullptr);
141 
<span class="line-modified">142     clearCanvasData();</span>
143 
144     m_recordingAutoCaptureFrameCount = WTF::nullopt;
145 }
146 
147 void InspectorCanvasAgent::requestNode(ErrorString&amp; errorString, const String&amp; canvasId, int* nodeId)
148 {
149     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
150     if (!inspectorCanvas)
151         return;
152 
153     auto* node = inspectorCanvas-&gt;canvasElement();
154     if (!node) {
155         errorString = &quot;Missing element of canvas for given canvasId&quot;_s;
156         return;
157     }
158 
159     int documentNodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;boundNodeId(&amp;node-&gt;document());
160     if (!documentNodeId) {
161         errorString = &quot;Document must have been requested&quot;_s;
162         return;
163     }
164 
165     *nodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;pushNodeToFrontend(errorString, documentNodeId, node);
166 }
167 
168 void InspectorCanvasAgent::requestContent(ErrorString&amp; errorString, const String&amp; canvasId, String* content)
169 {
170     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
171     if (!inspectorCanvas)
172         return;
173 
174     *content = inspectorCanvas-&gt;getCanvasContentAsDataURL(errorString);
175 }
176 
<span class="line-modified">177 void InspectorCanvasAgent::requestCSSCanvasClientNodes(ErrorString&amp; errorString, const String&amp; canvasId, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; result)</span>
178 {






179     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
180     if (!inspectorCanvas)
181         return;
182 
<span class="line-modified">183     result = JSON::ArrayOf&lt;int&gt;::create();</span>
<span class="line-modified">184     for (auto* client : inspectorCanvas-&gt;context().canvasBase().cssCanvasClients()) {</span>
<span class="line-modified">185         if (int documentNodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;boundNodeId(&amp;client-&gt;document()))</span>
<span class="line-modified">186             result-&gt;addItem(m_instrumentingAgents.inspectorDOMAgent()-&gt;pushNodeToFrontend(errorString, documentNodeId, client));</span>
187     }
188 }
189 
<span class="line-modified">190 static JSC::JSValue contextAsScriptValue(JSC::ExecState&amp; state, CanvasRenderingContext&amp; context)</span>
<span class="line-removed">191 {</span>
<span class="line-removed">192     JSC::JSLockHolder lock(&amp;state);</span>
<span class="line-removed">193 </span>
<span class="line-removed">194     if (is&lt;CanvasRenderingContext2D&gt;(context))</span>
<span class="line-removed">195         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;CanvasRenderingContext2D&gt;(context));</span>
<span class="line-removed">196 #if ENABLE(WEBGL)</span>
<span class="line-removed">197     if (is&lt;WebGLRenderingContext&gt;(context))</span>
<span class="line-removed">198         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;WebGLRenderingContext&gt;(context));</span>
<span class="line-removed">199 #endif</span>
<span class="line-removed">200 #if ENABLE(WEBGL2)</span>
<span class="line-removed">201     if (is&lt;WebGL2RenderingContext&gt;(context))</span>
<span class="line-removed">202         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;WebGL2RenderingContext&gt;(context));</span>
<span class="line-removed">203 #endif</span>
<span class="line-removed">204 #if ENABLE(WEBGPU)</span>
<span class="line-removed">205     if (is&lt;GPUCanvasContext&gt;(context))</span>
<span class="line-removed">206         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;GPUCanvasContext&gt;(context));</span>
<span class="line-removed">207 #endif</span>
<span class="line-removed">208     if (is&lt;ImageBitmapRenderingContext&gt;(context))</span>
<span class="line-removed">209         return toJS(&amp;state, deprecatedGlobalObjectForPrototype(&amp;state), downcast&lt;ImageBitmapRenderingContext&gt;(context));</span>
<span class="line-removed">210 </span>
<span class="line-removed">211     return { };</span>
<span class="line-removed">212 }</span>
<span class="line-removed">213 </span>
<span class="line-removed">214 void InspectorCanvasAgent::resolveCanvasContext(ErrorString&amp; errorString, const String&amp; canvasId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)</span>
215 {
216     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
217     if (!inspectorCanvas)
218         return;
219 
<span class="line-modified">220     auto&amp; state = *inspectorCanvas-&gt;context().canvasBase().scriptExecutionContext()-&gt;execState();</span>
<span class="line-modified">221     auto injectedScript = m_injectedScriptManager.injectedScriptFor(&amp;state);</span>
222     ASSERT(!injectedScript.hasNoValue());
223 
<span class="line-modified">224     JSC::JSValue value = contextAsScriptValue(state, inspectorCanvas-&gt;context());</span>

225     if (!value) {
226         ASSERT_NOT_REACHED();
227         errorString = &quot;Internal error: unknown context of canvas for given canvasId&quot;_s;
228         return;
229     }
230 
231     String objectGroupName = objectGroup ? *objectGroup : String();
232     result = injectedScript.wrapObject(value, objectGroupName);
233 }
234 
235 void InspectorCanvasAgent::setRecordingAutoCaptureFrameCount(ErrorString&amp;, int count)
236 {
237     if (count &gt; 0)
238         m_recordingAutoCaptureFrameCount = count;
239     else
240         m_recordingAutoCaptureFrameCount = WTF::nullopt;
241 }
242 
243 void InspectorCanvasAgent::startRecording(ErrorString&amp; errorString, const String&amp; canvasId, const int* frameCount, const int* memoryLimit)
244 {
245     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
246     if (!inspectorCanvas)
247         return;
248 
<span class="line-modified">249     if (inspectorCanvas-&gt;context().callTracingActive()) {</span>






250         errorString = &quot;Already recording canvas&quot;_s;
251         return;
252     }
253 
254     RecordingOptions recordingOptions;
255     if (frameCount)
256         recordingOptions.frameCount = *frameCount;
257     if (memoryLimit)
258         recordingOptions.memoryLimit = *memoryLimit;
259     startRecording(*inspectorCanvas, Inspector::Protocol::Recording::Initiator::Frontend, WTFMove(recordingOptions));
260 }
261 
262 void InspectorCanvasAgent::stopRecording(ErrorString&amp; errorString, const String&amp; canvasId)
263 {
264     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
265     if (!inspectorCanvas)
266         return;
267 
<span class="line-modified">268     if (!inspectorCanvas-&gt;context().callTracingActive()) {</span>






269         errorString = &quot;Not recording canvas&quot;_s;
270         return;
271     }
272 
<span class="line-modified">273     didFinishRecordingCanvasFrame(inspectorCanvas-&gt;context(), true);</span>
274 }
275 
<span class="line-modified">276 void InspectorCanvasAgent::requestShaderSource(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderType, String* content)</span>
277 {
<span class="line-removed">278 #if ENABLE(WEBGL)</span>
279     auto inspectorProgram = assertInspectorProgram(errorString, programId);
280     if (!inspectorProgram)
281         return;
282 
<span class="line-modified">283     auto* shader = inspectorProgram-&gt;shaderForType(shaderType);</span>
<span class="line-modified">284     if (!shader) {</span>
<span class="line-modified">285         errorString = &quot;Missing shader for given shaderType&quot;_s;</span>
286         return;
287     }
288 
<span class="line-modified">289     *content = shader-&gt;getSource();</span>
<span class="line-modified">290 #else</span>
<span class="line-modified">291     UNUSED_PARAM(programId);</span>
<span class="line-modified">292     UNUSED_PARAM(shaderType);</span>
<span class="line-modified">293     UNUSED_PARAM(content);</span>
<span class="line-modified">294     errorString = &quot;Not supported&quot;_s;</span>
<span class="line-modified">295 #endif</span>
296 }
297 
<span class="line-modified">298 void InspectorCanvasAgent::updateShader(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderType, const String&amp; source)</span>
299 {
<span class="line-removed">300 #if ENABLE(WEBGL)</span>
301     auto inspectorProgram = assertInspectorProgram(errorString, programId);
302     if (!inspectorProgram)
303         return;
304 
<span class="line-modified">305     auto* shader = inspectorProgram-&gt;shaderForType(shaderType);</span>
<span class="line-modified">306     if (!shader) {</span>
<span class="line-modified">307         errorString = &quot;Missing shader for given shaderType&quot;_s;</span>
308         return;
309     }
310 
<span class="line-modified">311     WebGLRenderingContextBase&amp; contextWebGL = inspectorProgram-&gt;context();</span>
<span class="line-modified">312     contextWebGL.shaderSource(shader, source);</span>
<span class="line-removed">313     contextWebGL.compileShader(shader);</span>
<span class="line-removed">314 </span>
<span class="line-removed">315     if (!shader-&gt;isValid()) {</span>
<span class="line-removed">316         errorString = &quot;Failed to update shader&quot;_s;</span>
<span class="line-removed">317         return;</span>
<span class="line-removed">318     }</span>
<span class="line-removed">319 </span>
<span class="line-removed">320     contextWebGL.linkProgramWithoutInvalidatingAttribLocations(&amp;inspectorProgram-&gt;program());</span>
<span class="line-removed">321 #else</span>
<span class="line-removed">322     UNUSED_PARAM(programId);</span>
<span class="line-removed">323     UNUSED_PARAM(shaderType);</span>
<span class="line-removed">324     UNUSED_PARAM(source);</span>
<span class="line-removed">325     errorString = &quot;Not supported&quot;_s;</span>
<span class="line-removed">326 #endif</span>
327 }
328 
329 void InspectorCanvasAgent::setShaderProgramDisabled(ErrorString&amp; errorString, const String&amp; programId, bool disabled)
330 {
<span class="line-removed">331 #if ENABLE(WEBGL)</span>
332     auto inspectorProgram = assertInspectorProgram(errorString, programId);
333     if (!inspectorProgram)
334         return;
335 
336     inspectorProgram-&gt;setDisabled(disabled);
<span class="line-removed">337 #else</span>
<span class="line-removed">338     UNUSED_PARAM(programId);</span>
<span class="line-removed">339     UNUSED_PARAM(disabled);</span>
<span class="line-removed">340     errorString = &quot;Not supported&quot;_s;</span>
<span class="line-removed">341 #endif</span>
342 }
343 
344 void InspectorCanvasAgent::setShaderProgramHighlighted(ErrorString&amp; errorString, const String&amp; programId, bool highlighted)
345 {
<span class="line-removed">346 #if ENABLE(WEBGL)</span>
347     auto inspectorProgram = assertInspectorProgram(errorString, programId);
348     if (!inspectorProgram)
349         return;
350 
351     inspectorProgram-&gt;setHighlighted(highlighted);
<span class="line-removed">352 #else</span>
<span class="line-removed">353     UNUSED_PARAM(programId);</span>
<span class="line-removed">354     UNUSED_PARAM(highlighted);</span>
<span class="line-removed">355     errorString = &quot;Not supported&quot;_s;</span>
<span class="line-removed">356 #endif</span>
357 }
358 
359 void InspectorCanvasAgent::frameNavigated(Frame&amp; frame)
360 {
361     if (frame.isMainFrame()) {
<span class="line-modified">362         clearCanvasData();</span>
363         return;
364     }
365 
366     Vector&lt;InspectorCanvas*&gt; inspectorCanvases;
367     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
368         if (auto* canvasElement = inspectorCanvas-&gt;canvasElement()) {
369             if (canvasElement-&gt;document().frame() == &amp;frame)
370                 inspectorCanvases.append(inspectorCanvas.get());
371         }
372     }
373 
<span class="line-modified">374     for (auto* inspectorCanvas : inspectorCanvases) {</span>
<span class="line-modified">375         String identifier = unbindCanvas(*inspectorCanvas);</span>
<span class="line-removed">376         m_frontendDispatcher-&gt;canvasRemoved(identifier);</span>
<span class="line-removed">377     }</span>
378 }
379 
380 void InspectorCanvasAgent::didChangeCSSCanvasClientNodes(CanvasBase&amp; canvasBase)
381 {
382     auto* context = canvasBase.renderingContext();
383     if (!context) {
384         ASSERT_NOT_REACHED();
385         return;
386     }
387 
388     auto inspectorCanvas = findInspectorCanvas(*context);
389     ASSERT(inspectorCanvas);
390     if (!inspectorCanvas)
391         return;
392 
<span class="line-modified">393     m_frontendDispatcher-&gt;cssCanvasClientNodesChanged(inspectorCanvas-&gt;identifier());</span>
394 }
395 
396 void InspectorCanvasAgent::didCreateCanvasRenderingContext(CanvasRenderingContext&amp; context)
397 {
398     if (findInspectorCanvas(context)) {
399         ASSERT_NOT_REACHED();
400         return;
401     }
402 
403     auto&amp; inspectorCanvas = bindCanvas(context, true);
404 
405     if (m_recordingAutoCaptureFrameCount) {
406         RecordingOptions recordingOptions;
407         recordingOptions.frameCount = m_recordingAutoCaptureFrameCount.value();
408         startRecording(inspectorCanvas, Inspector::Protocol::Recording::Initiator::AutoCapture, WTFMove(recordingOptions));
409     }
410 }
411 
412 void InspectorCanvasAgent::didChangeCanvasMemory(CanvasRenderingContext&amp; context)
413 {
<span class="line-modified">414     auto inspectorCanvas = findInspectorCanvas(context);</span>















415     ASSERT(inspectorCanvas);
416     if (!inspectorCanvas)
417         return;
418 
419     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
420 
421     if (auto* node = inspectorCanvas-&gt;canvasElement())
422         m_frontendDispatcher-&gt;canvasMemoryChanged(inspectorCanvas-&gt;identifier(), node-&gt;memoryCost());
423 }
424 
425 void InspectorCanvasAgent::recordCanvasAction(CanvasRenderingContext&amp; canvasRenderingContext, const String&amp; name, std::initializer_list&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)
426 {
427     auto inspectorCanvas = findInspectorCanvas(canvasRenderingContext);
428     ASSERT(inspectorCanvas);
429     if (!inspectorCanvas)
430         return;
431 
432     ASSERT(canvasRenderingContext.callTracingActive());
433     if (!canvasRenderingContext.callTracingActive())
434         return;
435 
<span class="line-modified">436     // Only enqueue a microtask for the first action of each frame. Any subsequent actions will be</span>
<span class="line-modified">437     // covered by the initial microtask until the next frame.</span>
<span class="line-modified">438     if (!inspectorCanvas-&gt;currentFrameHasData()) {</span>
<span class="line-modified">439         if (auto* scriptExecutionContext = inspectorCanvas-&gt;context().canvasBase().scriptExecutionContext()) {</span>
<span class="line-modified">440             auto&amp; queue = MicrotaskQueue::mainThreadQueue();</span>
<span class="line-modified">441             queue.append(makeUnique&lt;ActiveDOMCallbackMicrotask&gt;(queue, *scriptExecutionContext, [&amp;, protectedInspectorCanvas = inspectorCanvas.copyRef()] {</span>
<span class="line-modified">442                 if (auto* canvasElement = protectedInspectorCanvas-&gt;canvasElement()) {</span>
<span class="line-modified">443                     if (canvasElement-&gt;isDescendantOf(canvasElement-&gt;document()))</span>
<span class="line-modified">444                         return;</span>












445                 }
446 
<span class="line-modified">447                 if (protectedInspectorCanvas-&gt;context().callTracingActive())</span>
<span class="line-modified">448                     didFinishRecordingCanvasFrame(protectedInspectorCanvas-&gt;context());</span>
<span class="line-removed">449             }));</span>
450         }
451     }
452 


453     inspectorCanvas-&gt;recordAction(name, WTFMove(parameters));
454 
455     if (!inspectorCanvas-&gt;hasBufferSpace())
<span class="line-modified">456         didFinishRecordingCanvasFrame(inspectorCanvas-&gt;context(), true);</span>
457 }
458 
459 void InspectorCanvasAgent::canvasChanged(CanvasBase&amp; canvasBase, const FloatRect&amp;)
460 {
461     auto* context = canvasBase.renderingContext();
462     if (!context)
463         return;
464 
465     auto inspectorCanvas = findInspectorCanvas(*context);
466     ASSERT(inspectorCanvas);
467     if (!inspectorCanvas)
468         return;
469 
470     inspectorCanvas-&gt;canvasChanged();
471 }
472 
473 void InspectorCanvasAgent::canvasDestroyed(CanvasBase&amp; canvasBase)
474 {
475     auto* context = canvasBase.renderingContext();
476     if (!context)
477         return;
478 
479     auto inspectorCanvas = findInspectorCanvas(*context);
480     ASSERT(inspectorCanvas);
481     if (!inspectorCanvas)
482         return;
483 
<span class="line-modified">484     String identifier = unbindCanvas(*inspectorCanvas);</span>
<span class="line-removed">485 </span>
<span class="line-removed">486     // WebCore::CanvasObserver::canvasDestroyed is called in response to the GC destroying the CanvasBase.</span>
<span class="line-removed">487     // Due to the single-process model used in WebKit1, the event must be dispatched from a timer to prevent</span>
<span class="line-removed">488     // the frontend from making JS allocations while the GC is still active.</span>
<span class="line-removed">489     m_removedCanvasIdentifiers.append(identifier);</span>
<span class="line-removed">490 </span>
<span class="line-removed">491     if (!m_canvasDestroyedTimer.isActive())</span>
<span class="line-removed">492         m_canvasDestroyedTimer.startOneShot(0_s);</span>
493 }
494 
495 void InspectorCanvasAgent::didFinishRecordingCanvasFrame(CanvasRenderingContext&amp; context, bool forceDispatch)
496 {



497     auto inspectorCanvas = findInspectorCanvas(context);
498     ASSERT(inspectorCanvas);
499     if (!inspectorCanvas)
500         return;
501 
<span class="line-removed">502     if (!inspectorCanvas-&gt;context().callTracingActive())</span>
<span class="line-removed">503         return;</span>
<span class="line-removed">504 </span>
505     if (!inspectorCanvas-&gt;hasRecordingData()) {
506         if (forceDispatch) {
507             m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), nullptr);
508             inspectorCanvas-&gt;resetRecordingData();

509         }
510         return;
511     }
512 
513     if (forceDispatch)
514         inspectorCanvas-&gt;markCurrentFrameIncomplete();
515 
516     inspectorCanvas-&gt;finalizeFrame();
517     if (inspectorCanvas-&gt;currentFrameHasData())
518         m_frontendDispatcher-&gt;recordingProgress(inspectorCanvas-&gt;identifier(), inspectorCanvas-&gt;releaseFrames(), inspectorCanvas-&gt;bufferUsed());
519 
520     if (!forceDispatch &amp;&amp; !inspectorCanvas-&gt;overFrameCount())
521         return;
522 
523     m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), inspectorCanvas-&gt;releaseObjectForRecording());


524 }
525 
<span class="line-modified">526 void InspectorCanvasAgent::consoleStartRecordingCanvas(CanvasRenderingContext&amp; context, JSC::ExecState&amp; exec, JSC::JSObject* options)</span>
527 {
528     auto inspectorCanvas = findInspectorCanvas(context);
529     ASSERT(inspectorCanvas);
530     if (!inspectorCanvas)
531         return;
532 
533     RecordingOptions recordingOptions;
534     if (options) {
535         JSC::VM&amp; vm = exec.vm();
536         if (JSC::JSValue optionSingleFrame = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;singleFrame&quot;)))
537             recordingOptions.frameCount = optionSingleFrame.toBoolean(&amp;exec) ? 1 : 0;
538         if (JSC::JSValue optionFrameCount = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;frameCount&quot;)))
539             recordingOptions.frameCount = optionFrameCount.toNumber(&amp;exec);
540         if (JSC::JSValue optionMemoryLimit = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;memoryLimit&quot;)))
541             recordingOptions.memoryLimit = optionMemoryLimit.toNumber(&amp;exec);
542         if (JSC::JSValue optionName = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;name&quot;)))
543             recordingOptions.name = optionName.toWTFString(&amp;exec);
544     }
545     startRecording(*inspectorCanvas, Inspector::Protocol::Recording::Initiator::Console, WTFMove(recordingOptions));
546 }
547 





548 #if ENABLE(WEBGL)
549 void InspectorCanvasAgent::didEnableExtension(WebGLRenderingContextBase&amp; context, const String&amp; extension)
550 {
551     auto inspectorCanvas = findInspectorCanvas(context);
552     ASSERT(inspectorCanvas);
553     if (!inspectorCanvas)
554         return;
555 
556     m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);
557 }
558 
<span class="line-modified">559 void InspectorCanvasAgent::didCreateProgram(WebGLRenderingContextBase&amp; context, WebGLProgram&amp; program)</span>
560 {
561     auto inspectorCanvas = findInspectorCanvas(context);
562     ASSERT(inspectorCanvas);
563     if (!inspectorCanvas)
564         return;
565 
<span class="line-modified">566     auto inspectorProgram = InspectorShaderProgram::create(program, *inspectorCanvas);</span>
<span class="line-modified">567     String programIdentifier = inspectorProgram-&gt;identifier();</span>
<span class="line-modified">568     m_identifierToInspectorProgram.set(programIdentifier, WTFMove(inspectorProgram));</span>
<span class="line-modified">569     m_frontendDispatcher-&gt;programCreated(inspectorCanvas-&gt;identifier(), programIdentifier);</span>
570 }
571 
<span class="line-modified">572 void InspectorCanvasAgent::willDeleteProgram(WebGLProgram&amp; program)</span>
573 {
574     auto inspectorProgram = findInspectorProgram(program);
575     if (!inspectorProgram)
576         return;
577 
<span class="line-modified">578     String identifier = unbindProgram(*inspectorProgram);</span>
<span class="line-removed">579     m_frontendDispatcher-&gt;programDeleted(identifier);</span>
580 }
581 
<span class="line-modified">582 bool InspectorCanvasAgent::isShaderProgramDisabled(WebGLProgram&amp; program)</span>
583 {
584     auto inspectorProgram = findInspectorProgram(program);
585     ASSERT(inspectorProgram);
586     if (!inspectorProgram)
587         return false;
588 
589     return inspectorProgram-&gt;disabled();
590 }
591 
<span class="line-modified">592 bool InspectorCanvasAgent::isShaderProgramHighlighted(WebGLProgram&amp; program)</span>
593 {
594     auto inspectorProgram = findInspectorProgram(program);
595     ASSERT(inspectorProgram);
596     if (!inspectorProgram)
597         return false;
598 
599     return inspectorProgram-&gt;highlighted();
600 }
601 #endif
602 































































603 void InspectorCanvasAgent::startRecording(InspectorCanvas&amp; inspectorCanvas, Inspector::Protocol::Recording::Initiator initiator, RecordingOptions&amp;&amp; recordingOptions)
604 {
<span class="line-modified">605     auto&amp; canvasRenderingContext = inspectorCanvas.context();</span>


606 
<span class="line-modified">607     if (!is&lt;CanvasRenderingContext2D&gt;(canvasRenderingContext)</span>

608 #if ENABLE(WEBGL)
<span class="line-modified">609         &amp;&amp; !is&lt;WebGLRenderingContext&gt;(canvasRenderingContext)</span>
610 #endif
611 #if ENABLE(WEBGL2)
<span class="line-modified">612         &amp;&amp; !is&lt;WebGL2RenderingContext&gt;(canvasRenderingContext)</span>
613 #endif
<span class="line-modified">614         &amp;&amp; !is&lt;ImageBitmapRenderingContext&gt;(canvasRenderingContext))</span>
615         return;
616 
<span class="line-modified">617     if (canvasRenderingContext.callTracingActive())</span>
618         return;
619 
620     inspectorCanvas.resetRecordingData();
621     if (recordingOptions.frameCount)
622         inspectorCanvas.setFrameCount(recordingOptions.frameCount.value());
623     if (recordingOptions.memoryLimit)
624         inspectorCanvas.setBufferLimit(recordingOptions.memoryLimit.value());
625     if (recordingOptions.name)
626         inspectorCanvas.setRecordingName(recordingOptions.name.value());
<span class="line-modified">627     canvasRenderingContext.setCallTracingActive(true);</span>
628 
629     m_frontendDispatcher-&gt;recordingStarted(inspectorCanvas.identifier(), initiator);
630 }
631 
632 void InspectorCanvasAgent::canvasDestroyedTimerFired()
633 {
634     if (!m_removedCanvasIdentifiers.size())
635         return;
636 
637     for (auto&amp; identifier : m_removedCanvasIdentifiers)
638         m_frontendDispatcher-&gt;canvasRemoved(identifier);
639 
640     m_removedCanvasIdentifiers.clear();
641 }
642 
<span class="line-modified">643 void InspectorCanvasAgent::clearCanvasData()</span>











644 {
<span class="line-modified">645     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values())</span>
<span class="line-modified">646         inspectorCanvas-&gt;context().canvasBase().removeObserver(*this);</span>


647 
648     m_identifierToInspectorCanvas.clear();
<span class="line-removed">649 #if ENABLE(WEBGL)</span>
<span class="line-removed">650     m_identifierToInspectorProgram.clear();</span>
651     m_removedCanvasIdentifiers.clear();
<span class="line-removed">652 #endif</span>
<span class="line-removed">653 </span>
654     if (m_canvasDestroyedTimer.isActive())
655         m_canvasDestroyedTimer.stop();







656 }
657 
658 InspectorCanvas&amp; InspectorCanvasAgent::bindCanvas(CanvasRenderingContext&amp; context, bool captureBacktrace)
659 {
660     auto inspectorCanvas = InspectorCanvas::create(context);
661     m_identifierToInspectorCanvas.set(inspectorCanvas-&gt;identifier(), inspectorCanvas.copyRef());
662 
<span class="line-modified">663     inspectorCanvas-&gt;context().canvasBase().addObserver(*this);</span>
664 
665     m_frontendDispatcher-&gt;canvasAdded(inspectorCanvas-&gt;buildObjectForCanvas(captureBacktrace));
666 
667 #if ENABLE(WEBGL)
<span class="line-modified">668     if (is&lt;WebGLRenderingContextBase&gt;(inspectorCanvas-&gt;context())) {</span>
<span class="line-modified">669         WebGLRenderingContextBase&amp; contextWebGL = downcast&lt;WebGLRenderingContextBase&gt;(inspectorCanvas-&gt;context());</span>
670         if (Optional&lt;Vector&lt;String&gt;&gt; extensions = contextWebGL.getSupportedExtensions()) {
671             for (const String&amp; extension : *extensions) {
672                 if (contextWebGL.extensionIsEnabled(extension))
673                     m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);
674             }
675         }
676     }
677 #endif
678 
679     return inspectorCanvas;
680 }
681 
<span class="line-modified">682 String InspectorCanvasAgent::unbindCanvas(InspectorCanvas&amp; inspectorCanvas)</span>












683 {
684 #if ENABLE(WEBGL)
685     Vector&lt;InspectorShaderProgram*&gt; programsToRemove;
686     for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
687         if (&amp;inspectorProgram-&gt;canvas() == &amp;inspectorCanvas)
688             programsToRemove.append(inspectorProgram.get());
689     }
690 
691     for (auto* inspectorProgram : programsToRemove)
692         unbindProgram(*inspectorProgram);
693 #endif
694 
<span class="line-modified">695     inspectorCanvas.context().canvasBase().removeObserver(*this);</span>

696 
697     String identifier = inspectorCanvas.identifier();
698     m_identifierToInspectorCanvas.remove(identifier);
699 
<span class="line-modified">700     return identifier;</span>






701 }
702 
703 RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::assertInspectorCanvas(ErrorString&amp; errorString, const String&amp; canvasId)
704 {
705     auto inspectorCanvas = m_identifierToInspectorCanvas.get(canvasId);
706     if (!inspectorCanvas) {
707         errorString = &quot;Missing canvas for given canvasId&quot;_s;
708         return nullptr;
709     }
710     return inspectorCanvas;
711 }
712 
713 RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::findInspectorCanvas(CanvasRenderingContext&amp; context)
714 {
715     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
<span class="line-modified">716         if (&amp;inspectorCanvas-&gt;context() == &amp;context)</span>
717             return inspectorCanvas;
718     }
719     return nullptr;
720 }
721 
<span class="line-modified">722 #if ENABLE(WEBGL)</span>
<span class="line-modified">723 String InspectorCanvasAgent::unbindProgram(InspectorShaderProgram&amp; inspectorProgram)</span>










724 {
725     String identifier = inspectorProgram.identifier();
726     m_identifierToInspectorProgram.remove(identifier);
727 
<span class="line-modified">728     return identifier;</span>






729 }
730 
731 RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::assertInspectorProgram(ErrorString&amp; errorString, const String&amp; programId)
732 {
733     auto inspectorProgram = m_identifierToInspectorProgram.get(programId);
734     if (!inspectorProgram) {
735         errorString = &quot;Missing program for given programId&quot;_s;
736         return nullptr;
737     }
738     return inspectorProgram;
739 }
740 

741 RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::findInspectorProgram(WebGLProgram&amp; program)
742 {
743     for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
<span class="line-modified">744         if (&amp;inspectorProgram-&gt;program() == &amp;program)</span>











745             return inspectorProgram;
746     }
747     return nullptr;
748 }
749 #endif
750 
751 } // namespace WebCore
</pre>
</td>
<td>
<hr />
<pre>
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;InspectorCanvasAgent.h&quot;
 28 

 29 #include &quot;CanvasRenderingContext.h&quot;
 30 #include &quot;CanvasRenderingContext2D.h&quot;
 31 #include &quot;Document.h&quot;
 32 #include &quot;Element.h&quot;
<span class="line-added"> 33 #include &quot;EventLoop.h&quot;</span>
 34 #include &quot;Frame.h&quot;
 35 #include &quot;HTMLCanvasElement.h&quot;
<span class="line-added"> 36 #include &quot;ImageBitmap.h&quot;</span>
 37 #include &quot;ImageBitmapRenderingContext.h&quot;
 38 #include &quot;InspectorDOMAgent.h&quot;
<span class="line-added"> 39 #include &quot;InspectorShaderProgram.h&quot;</span>
 40 #include &quot;InstrumentingAgents.h&quot;

 41 #include &quot;JSExecState.h&quot;



 42 #include &quot;ScriptState.h&quot;
 43 #include &quot;StringAdaptors.h&quot;
 44 #include &lt;JavaScriptCore/IdentifiersFactory.h&gt;
 45 #include &lt;JavaScriptCore/InjectedScript.h&gt;
 46 #include &lt;JavaScriptCore/InjectedScriptManager.h&gt;
 47 #include &lt;JavaScriptCore/InspectorProtocolObjects.h&gt;
 48 #include &lt;JavaScriptCore/JSCInlines.h&gt;
<span class="line-added"> 49 #include &lt;wtf/HashMap.h&gt;</span>
 50 #include &lt;wtf/HashSet.h&gt;
 51 #include &lt;wtf/Lock.h&gt;
<span class="line-added"> 52 #include &lt;wtf/Optional.h&gt;</span>
<span class="line-added"> 53 #include &lt;wtf/RefPtr.h&gt;</span>
<span class="line-added"> 54 #include &lt;wtf/Vector.h&gt;</span>
<span class="line-added"> 55 #include &lt;wtf/text/WTFString.h&gt;</span>
<span class="line-added"> 56 </span>
<span class="line-added"> 57 #if ENABLE(OFFSCREEN_CANVAS)</span>
<span class="line-added"> 58 #include &quot;OffscreenCanvas.h&quot;</span>
<span class="line-added"> 59 #endif</span>
 60 
 61 #if ENABLE(WEBGL)

 62 #include &quot;WebGLProgram.h&quot;
<span class="line-modified"> 63 #include &quot;WebGLRenderingContext.h&quot;</span>
<span class="line-added"> 64 #include &quot;WebGLRenderingContextBase.h&quot;</span>
 65 #endif
 66 
 67 #if ENABLE(WEBGL2)
<span class="line-modified"> 68 #include &quot;WebGL2RenderingContext.h&quot;</span>
 69 #endif
 70 
 71 #if ENABLE(WEBGPU)
<span class="line-modified"> 72 #include &quot;GPUCanvasContext.h&quot;</span>
<span class="line-added"> 73 #include &quot;WebGPUComputePipeline.h&quot;</span>
<span class="line-added"> 74 #include &quot;WebGPUDevice.h&quot;</span>
<span class="line-added"> 75 #include &quot;WebGPUPipeline.h&quot;</span>
<span class="line-added"> 76 #include &quot;WebGPURenderPipeline.h&quot;</span>
<span class="line-added"> 77 #include &quot;WebGPUSwapChain.h&quot;</span>
 78 #endif
 79 
 80 namespace WebCore {
 81 
 82 using namespace Inspector;
 83 
 84 InspectorCanvasAgent::InspectorCanvasAgent(PageAgentContext&amp; context)
 85     : InspectorAgentBase(&quot;Canvas&quot;_s, context)
 86     , m_frontendDispatcher(makeUnique&lt;Inspector::CanvasFrontendDispatcher&gt;(context.frontendRouter))
 87     , m_backendDispatcher(Inspector::CanvasBackendDispatcher::create(context.backendDispatcher, this))
 88     , m_injectedScriptManager(context.injectedScriptManager)
 89     , m_inspectedPage(context.inspectedPage)
 90     , m_canvasDestroyedTimer(*this, &amp;InspectorCanvasAgent::canvasDestroyedTimerFired)
<span class="line-added"> 91     , m_programDestroyedTimer(*this, &amp;InspectorCanvasAgent::programDestroyedTimerFired)</span>
 92 {
 93 }
 94 
 95 InspectorCanvasAgent::~InspectorCanvasAgent() = default;
 96 
 97 void InspectorCanvasAgent::didCreateFrontendAndBackend(Inspector::FrontendRouter*, Inspector::BackendDispatcher*)
 98 {
 99 }
100 
101 void InspectorCanvasAgent::willDestroyFrontendAndBackend(Inspector::DisconnectReason)
102 {
103     ErrorString ignored;
104     disable(ignored);
105 }
106 
107 void InspectorCanvasAgent::discardAgent()
108 {
<span class="line-modified">109     reset();</span>
110 }
111 
112 void InspectorCanvasAgent::enable(ErrorString&amp;)
113 {
114     if (m_instrumentingAgents.inspectorCanvasAgent() == this)
115         return;
116 
117     m_instrumentingAgents.setInspectorCanvasAgent(this);
118 
<span class="line-modified">119     const auto existsInCurrentPage = [&amp;] (ScriptExecutionContext* scriptExecutionContext) {</span>




120         if (!is&lt;Document&gt;(scriptExecutionContext))
121             return false;
122 
123         // FIXME: &lt;https://webkit.org/b/168475&gt; Web Inspector: Correctly display iframe&#39;s WebSockets
124         auto* document = downcast&lt;Document&gt;(scriptExecutionContext);
125         return document-&gt;page() == &amp;m_inspectedPage;
126     };
127 
128     {
129         LockHolder lock(CanvasRenderingContext::instancesMutex());
<span class="line-modified">130         for (auto* context : CanvasRenderingContext::instances(lock)) {</span>
<span class="line-modified">131 #if ENABLE(WEBGPU)</span>
<span class="line-modified">132             // The actual &quot;context&quot; for WebGPU is the `WebGPUDevice`, not the &lt;canvas&gt;.</span>
<span class="line-added">133             if (is&lt;GPUCanvasContext&gt;(context))</span>
<span class="line-added">134                 continue;</span>
<span class="line-added">135 #endif</span>
<span class="line-added">136 </span>
<span class="line-added">137             if (existsInCurrentPage(context-&gt;canvasBase().scriptExecutionContext()))</span>
<span class="line-added">138                 bindCanvas(*context, false);</span>
139         }
140     }
141 
<span class="line-added">142 #if ENABLE(WEBGPU)</span>
<span class="line-added">143     {</span>
<span class="line-added">144         LockHolder lock(WebGPUDevice::instancesMutex());</span>
<span class="line-added">145         for (auto* device : WebGPUDevice::instances(lock)) {</span>
<span class="line-added">146             if (existsInCurrentPage(device-&gt;scriptExecutionContext()))</span>
<span class="line-added">147                 bindCanvas(*device, false);</span>
<span class="line-added">148         }</span>
<span class="line-added">149     }</span>
<span class="line-added">150 #endif</span>
<span class="line-added">151 </span>
152 #if ENABLE(WEBGL)
153     {
154         LockHolder lock(WebGLProgram::instancesMutex());
<span class="line-modified">155         for (auto&amp; [program, contextWebGLBase] : WebGLProgram::instances(lock)) {</span>
<span class="line-modified">156             if (contextWebGLBase &amp;&amp; existsInCurrentPage(contextWebGLBase-&gt;canvasBase().scriptExecutionContext()))</span>
<span class="line-modified">157                 didCreateWebGLProgram(*contextWebGLBase, *program);</span>
<span class="line-added">158         }</span>
<span class="line-added">159     }</span>
<span class="line-added">160 #endif</span>
<span class="line-added">161 </span>
<span class="line-added">162 #if ENABLE(WEBGPU)</span>
<span class="line-added">163     {</span>
<span class="line-added">164         LockHolder lock(WebGPUPipeline::instancesMutex());</span>
<span class="line-added">165         for (auto&amp; [pipeline, device] : WebGPUPipeline::instances(lock)) {</span>
<span class="line-added">166             if (device &amp;&amp; existsInCurrentPage(device-&gt;scriptExecutionContext()) &amp;&amp; pipeline-&gt;isValid())</span>
<span class="line-added">167                 didCreateWebGPUPipeline(*device, *pipeline);</span>
168         }
169     }
170 #endif
171 }
172 
173 void InspectorCanvasAgent::disable(ErrorString&amp;)
174 {
175     m_instrumentingAgents.setInspectorCanvasAgent(nullptr);
176 
<span class="line-modified">177     reset();</span>
178 
179     m_recordingAutoCaptureFrameCount = WTF::nullopt;
180 }
181 
182 void InspectorCanvasAgent::requestNode(ErrorString&amp; errorString, const String&amp; canvasId, int* nodeId)
183 {
184     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
185     if (!inspectorCanvas)
186         return;
187 
188     auto* node = inspectorCanvas-&gt;canvasElement();
189     if (!node) {
190         errorString = &quot;Missing element of canvas for given canvasId&quot;_s;
191         return;
192     }
193 
194     int documentNodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;boundNodeId(&amp;node-&gt;document());
195     if (!documentNodeId) {
196         errorString = &quot;Document must have been requested&quot;_s;
197         return;
198     }
199 
200     *nodeId = m_instrumentingAgents.inspectorDOMAgent()-&gt;pushNodeToFrontend(errorString, documentNodeId, node);
201 }
202 
203 void InspectorCanvasAgent::requestContent(ErrorString&amp; errorString, const String&amp; canvasId, String* content)
204 {
205     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
206     if (!inspectorCanvas)
207         return;
208 
209     *content = inspectorCanvas-&gt;getCanvasContentAsDataURL(errorString);
210 }
211 
<span class="line-modified">212 void InspectorCanvasAgent::requestClientNodes(ErrorString&amp; errorString, const String&amp; canvasId, RefPtr&lt;JSON::ArrayOf&lt;int&gt;&gt;&amp; clientNodeIds)</span>
213 {
<span class="line-added">214     auto* domAgent = m_instrumentingAgents.inspectorDOMAgent();</span>
<span class="line-added">215     if (!domAgent) {</span>
<span class="line-added">216         errorString = &quot;DOM domain must be enabled&quot;_s;</span>
<span class="line-added">217         return;</span>
<span class="line-added">218     }</span>
<span class="line-added">219 </span>
220     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
221     if (!inspectorCanvas)
222         return;
223 
<span class="line-modified">224     clientNodeIds = JSON::ArrayOf&lt;int&gt;::create();</span>
<span class="line-modified">225     for (auto&amp; clientNode : inspectorCanvas-&gt;clientNodes()) {</span>
<span class="line-modified">226         if (auto documentNodeId = domAgent-&gt;boundNodeId(&amp;clientNode-&gt;document()))</span>
<span class="line-modified">227             clientNodeIds-&gt;addItem(domAgent-&gt;pushNodeToFrontend(errorString, documentNodeId, clientNode));</span>
228     }
229 }
230 
<span class="line-modified">231 void InspectorCanvasAgent::resolveContext(ErrorString&amp; errorString, const String&amp; canvasId, const String* objectGroup, RefPtr&lt;Inspector::Protocol::Runtime::RemoteObject&gt;&amp; result)</span>
























232 {
233     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
234     if (!inspectorCanvas)
235         return;
236 
<span class="line-modified">237     auto* state = inspectorCanvas-&gt;scriptExecutionContext()-&gt;execState();</span>
<span class="line-modified">238     auto injectedScript = m_injectedScriptManager.injectedScriptFor(state);</span>
239     ASSERT(!injectedScript.hasNoValue());
240 
<span class="line-modified">241     JSC::JSValue value = inspectorCanvas-&gt;resolveContext(state);</span>
<span class="line-added">242 </span>
243     if (!value) {
244         ASSERT_NOT_REACHED();
245         errorString = &quot;Internal error: unknown context of canvas for given canvasId&quot;_s;
246         return;
247     }
248 
249     String objectGroupName = objectGroup ? *objectGroup : String();
250     result = injectedScript.wrapObject(value, objectGroupName);
251 }
252 
253 void InspectorCanvasAgent::setRecordingAutoCaptureFrameCount(ErrorString&amp;, int count)
254 {
255     if (count &gt; 0)
256         m_recordingAutoCaptureFrameCount = count;
257     else
258         m_recordingAutoCaptureFrameCount = WTF::nullopt;
259 }
260 
261 void InspectorCanvasAgent::startRecording(ErrorString&amp; errorString, const String&amp; canvasId, const int* frameCount, const int* memoryLimit)
262 {
263     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
264     if (!inspectorCanvas)
265         return;
266 
<span class="line-modified">267     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice</span>
<span class="line-added">268 </span>
<span class="line-added">269     auto* context = inspectorCanvas-&gt;canvasContext();</span>
<span class="line-added">270     if (!context)</span>
<span class="line-added">271         return;</span>
<span class="line-added">272 </span>
<span class="line-added">273     if (context-&gt;callTracingActive()) {</span>
274         errorString = &quot;Already recording canvas&quot;_s;
275         return;
276     }
277 
278     RecordingOptions recordingOptions;
279     if (frameCount)
280         recordingOptions.frameCount = *frameCount;
281     if (memoryLimit)
282         recordingOptions.memoryLimit = *memoryLimit;
283     startRecording(*inspectorCanvas, Inspector::Protocol::Recording::Initiator::Frontend, WTFMove(recordingOptions));
284 }
285 
286 void InspectorCanvasAgent::stopRecording(ErrorString&amp; errorString, const String&amp; canvasId)
287 {
288     auto inspectorCanvas = assertInspectorCanvas(errorString, canvasId);
289     if (!inspectorCanvas)
290         return;
291 
<span class="line-modified">292     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice</span>
<span class="line-added">293 </span>
<span class="line-added">294     auto* context = inspectorCanvas-&gt;canvasContext();</span>
<span class="line-added">295     if (!context)</span>
<span class="line-added">296         return;</span>
<span class="line-added">297 </span>
<span class="line-added">298     if (!context-&gt;callTracingActive()) {</span>
299         errorString = &quot;Not recording canvas&quot;_s;
300         return;
301     }
302 
<span class="line-modified">303     didFinishRecordingCanvasFrame(*context, true);</span>
304 }
305 
<span class="line-modified">306 void InspectorCanvasAgent::requestShaderSource(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderTypeString, String* outSource)</span>
307 {

308     auto inspectorProgram = assertInspectorProgram(errorString, programId);
309     if (!inspectorProgram)
310         return;
311 
<span class="line-modified">312     auto shaderType = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::Canvas::ShaderType&gt;(shaderTypeString);</span>
<span class="line-modified">313     if (!shaderType) {</span>
<span class="line-modified">314         errorString = makeString(&quot;Unknown shaderType: &quot;_s, shaderTypeString);</span>
315         return;
316     }
317 
<span class="line-modified">318     auto source = inspectorProgram-&gt;requestShaderSource(shaderType.value());</span>
<span class="line-modified">319     if (!source) {</span>
<span class="line-modified">320         errorString = &quot;Missing shader of given shaderType for given programId&quot;_s;</span>
<span class="line-modified">321         return;</span>
<span class="line-modified">322     }</span>
<span class="line-modified">323 </span>
<span class="line-modified">324     *outSource = source;</span>
325 }
326 
<span class="line-modified">327 void InspectorCanvasAgent::updateShader(ErrorString&amp; errorString, const String&amp; programId, const String&amp; shaderTypeString, const String&amp; source)</span>
328 {

329     auto inspectorProgram = assertInspectorProgram(errorString, programId);
330     if (!inspectorProgram)
331         return;
332 
<span class="line-modified">333     auto shaderType = Inspector::Protocol::InspectorHelpers::parseEnumValueFromString&lt;Inspector::Protocol::Canvas::ShaderType&gt;(shaderTypeString);</span>
<span class="line-modified">334     if (!shaderType) {</span>
<span class="line-modified">335         errorString = makeString(&quot;Unknown shaderType: &quot;_s, shaderTypeString);</span>
336         return;
337     }
338 
<span class="line-modified">339     if (!inspectorProgram-&gt;updateShader(shaderType.value(), source))</span>
<span class="line-modified">340         errorString = &quot;Failed to update shader of given shaderType for given programId&quot;_s;</span>














341 }
342 
343 void InspectorCanvasAgent::setShaderProgramDisabled(ErrorString&amp; errorString, const String&amp; programId, bool disabled)
344 {

345     auto inspectorProgram = assertInspectorProgram(errorString, programId);
346     if (!inspectorProgram)
347         return;
348 
349     inspectorProgram-&gt;setDisabled(disabled);





350 }
351 
352 void InspectorCanvasAgent::setShaderProgramHighlighted(ErrorString&amp; errorString, const String&amp; programId, bool highlighted)
353 {

354     auto inspectorProgram = assertInspectorProgram(errorString, programId);
355     if (!inspectorProgram)
356         return;
357 
358     inspectorProgram-&gt;setHighlighted(highlighted);





359 }
360 
361 void InspectorCanvasAgent::frameNavigated(Frame&amp; frame)
362 {
363     if (frame.isMainFrame()) {
<span class="line-modified">364         reset();</span>
365         return;
366     }
367 
368     Vector&lt;InspectorCanvas*&gt; inspectorCanvases;
369     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
370         if (auto* canvasElement = inspectorCanvas-&gt;canvasElement()) {
371             if (canvasElement-&gt;document().frame() == &amp;frame)
372                 inspectorCanvases.append(inspectorCanvas.get());
373         }
374     }
375 
<span class="line-modified">376     for (auto* inspectorCanvas : inspectorCanvases)</span>
<span class="line-modified">377         unbindCanvas(*inspectorCanvas);</span>


378 }
379 
380 void InspectorCanvasAgent::didChangeCSSCanvasClientNodes(CanvasBase&amp; canvasBase)
381 {
382     auto* context = canvasBase.renderingContext();
383     if (!context) {
384         ASSERT_NOT_REACHED();
385         return;
386     }
387 
388     auto inspectorCanvas = findInspectorCanvas(*context);
389     ASSERT(inspectorCanvas);
390     if (!inspectorCanvas)
391         return;
392 
<span class="line-modified">393     m_frontendDispatcher-&gt;clientNodesChanged(inspectorCanvas-&gt;identifier());</span>
394 }
395 
396 void InspectorCanvasAgent::didCreateCanvasRenderingContext(CanvasRenderingContext&amp; context)
397 {
398     if (findInspectorCanvas(context)) {
399         ASSERT_NOT_REACHED();
400         return;
401     }
402 
403     auto&amp; inspectorCanvas = bindCanvas(context, true);
404 
405     if (m_recordingAutoCaptureFrameCount) {
406         RecordingOptions recordingOptions;
407         recordingOptions.frameCount = m_recordingAutoCaptureFrameCount.value();
408         startRecording(inspectorCanvas, Inspector::Protocol::Recording::Initiator::AutoCapture, WTFMove(recordingOptions));
409     }
410 }
411 
412 void InspectorCanvasAgent::didChangeCanvasMemory(CanvasRenderingContext&amp; context)
413 {
<span class="line-modified">414     RefPtr&lt;InspectorCanvas&gt; inspectorCanvas;</span>
<span class="line-added">415 </span>
<span class="line-added">416 #if ENABLE(WEBGPU)</span>
<span class="line-added">417     if (is&lt;GPUCanvasContext&gt;(context)) {</span>
<span class="line-added">418         for (auto&amp; item : m_identifierToInspectorCanvas.values()) {</span>
<span class="line-added">419             if (item-&gt;isDeviceForCanvasContext(context)) {</span>
<span class="line-added">420                 inspectorCanvas = item;</span>
<span class="line-added">421                 break;</span>
<span class="line-added">422             }</span>
<span class="line-added">423         }</span>
<span class="line-added">424     }</span>
<span class="line-added">425 #endif</span>
<span class="line-added">426 </span>
<span class="line-added">427     if (!inspectorCanvas)</span>
<span class="line-added">428         inspectorCanvas = findInspectorCanvas(context);</span>
<span class="line-added">429 </span>
430     ASSERT(inspectorCanvas);
431     if (!inspectorCanvas)
432         return;
433 
434     // FIXME: &lt;https://webkit.org/b/180833&gt; Web Inspector: support OffscreenCanvas for Canvas related operations
435 
436     if (auto* node = inspectorCanvas-&gt;canvasElement())
437         m_frontendDispatcher-&gt;canvasMemoryChanged(inspectorCanvas-&gt;identifier(), node-&gt;memoryCost());
438 }
439 
440 void InspectorCanvasAgent::recordCanvasAction(CanvasRenderingContext&amp; canvasRenderingContext, const String&amp; name, std::initializer_list&lt;RecordCanvasActionVariant&gt;&amp;&amp; parameters)
441 {
442     auto inspectorCanvas = findInspectorCanvas(canvasRenderingContext);
443     ASSERT(inspectorCanvas);
444     if (!inspectorCanvas)
445         return;
446 
447     ASSERT(canvasRenderingContext.callTracingActive());
448     if (!canvasRenderingContext.callTracingActive())
449         return;
450 
<span class="line-modified">451     // Only enqueue one microtask for all actively recording canvases.</span>
<span class="line-modified">452     if (m_recordingCanvasIdentifiers.isEmpty()) {</span>
<span class="line-modified">453         if (auto* scriptExecutionContext = inspectorCanvas-&gt;scriptExecutionContext()) {</span>
<span class="line-modified">454             scriptExecutionContext-&gt;eventLoop().queueMicrotask([weakThis = makeWeakPtr(*this)] {</span>
<span class="line-modified">455                 if (!weakThis)</span>
<span class="line-modified">456                     return;</span>
<span class="line-modified">457 </span>
<span class="line-modified">458                 auto&amp; canvasAgent = *weakThis;</span>
<span class="line-modified">459 </span>
<span class="line-added">460                 auto identifiers = copyToVector(canvasAgent.m_recordingCanvasIdentifiers);</span>
<span class="line-added">461                 for (auto&amp; identifier : identifiers) {</span>
<span class="line-added">462                     auto inspectorCanvas = canvasAgent.m_identifierToInspectorCanvas.get(identifier);</span>
<span class="line-added">463                     if (!inspectorCanvas)</span>
<span class="line-added">464                         continue;</span>
<span class="line-added">465 </span>
<span class="line-added">466                     auto* canvasRenderingContext = inspectorCanvas-&gt;canvasContext();</span>
<span class="line-added">467                     ASSERT(canvasRenderingContext);</span>
<span class="line-added">468                     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice</span>
<span class="line-added">469 </span>
<span class="line-added">470                     if (canvasRenderingContext-&gt;callTracingActive())</span>
<span class="line-added">471                         canvasAgent.didFinishRecordingCanvasFrame(*canvasRenderingContext);</span>
472                 }
473 
<span class="line-modified">474                 canvasAgent.m_recordingCanvasIdentifiers.clear();</span>
<span class="line-modified">475             });</span>

476         }
477     }
478 
<span class="line-added">479     m_recordingCanvasIdentifiers.add(inspectorCanvas-&gt;identifier());</span>
<span class="line-added">480 </span>
481     inspectorCanvas-&gt;recordAction(name, WTFMove(parameters));
482 
483     if (!inspectorCanvas-&gt;hasBufferSpace())
<span class="line-modified">484         didFinishRecordingCanvasFrame(canvasRenderingContext, true);</span>
485 }
486 
487 void InspectorCanvasAgent::canvasChanged(CanvasBase&amp; canvasBase, const FloatRect&amp;)
488 {
489     auto* context = canvasBase.renderingContext();
490     if (!context)
491         return;
492 
493     auto inspectorCanvas = findInspectorCanvas(*context);
494     ASSERT(inspectorCanvas);
495     if (!inspectorCanvas)
496         return;
497 
498     inspectorCanvas-&gt;canvasChanged();
499 }
500 
501 void InspectorCanvasAgent::canvasDestroyed(CanvasBase&amp; canvasBase)
502 {
503     auto* context = canvasBase.renderingContext();
504     if (!context)
505         return;
506 
507     auto inspectorCanvas = findInspectorCanvas(*context);
508     ASSERT(inspectorCanvas);
509     if (!inspectorCanvas)
510         return;
511 
<span class="line-modified">512     unbindCanvas(*inspectorCanvas);</span>








513 }
514 
515 void InspectorCanvasAgent::didFinishRecordingCanvasFrame(CanvasRenderingContext&amp; context, bool forceDispatch)
516 {
<span class="line-added">517     if (!context.callTracingActive())</span>
<span class="line-added">518         return;</span>
<span class="line-added">519 </span>
520     auto inspectorCanvas = findInspectorCanvas(context);
521     ASSERT(inspectorCanvas);
522     if (!inspectorCanvas)
523         return;
524 



525     if (!inspectorCanvas-&gt;hasRecordingData()) {
526         if (forceDispatch) {
527             m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), nullptr);
528             inspectorCanvas-&gt;resetRecordingData();
<span class="line-added">529             ASSERT(!m_recordingCanvasIdentifiers.contains(inspectorCanvas-&gt;identifier()));</span>
530         }
531         return;
532     }
533 
534     if (forceDispatch)
535         inspectorCanvas-&gt;markCurrentFrameIncomplete();
536 
537     inspectorCanvas-&gt;finalizeFrame();
538     if (inspectorCanvas-&gt;currentFrameHasData())
539         m_frontendDispatcher-&gt;recordingProgress(inspectorCanvas-&gt;identifier(), inspectorCanvas-&gt;releaseFrames(), inspectorCanvas-&gt;bufferUsed());
540 
541     if (!forceDispatch &amp;&amp; !inspectorCanvas-&gt;overFrameCount())
542         return;
543 
544     m_frontendDispatcher-&gt;recordingFinished(inspectorCanvas-&gt;identifier(), inspectorCanvas-&gt;releaseObjectForRecording());
<span class="line-added">545 </span>
<span class="line-added">546     m_recordingCanvasIdentifiers.remove(inspectorCanvas-&gt;identifier());</span>
547 }
548 
<span class="line-modified">549 void InspectorCanvasAgent::consoleStartRecordingCanvas(CanvasRenderingContext&amp; context, JSC::JSGlobalObject&amp; exec, JSC::JSObject* options)</span>
550 {
551     auto inspectorCanvas = findInspectorCanvas(context);
552     ASSERT(inspectorCanvas);
553     if (!inspectorCanvas)
554         return;
555 
556     RecordingOptions recordingOptions;
557     if (options) {
558         JSC::VM&amp; vm = exec.vm();
559         if (JSC::JSValue optionSingleFrame = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;singleFrame&quot;)))
560             recordingOptions.frameCount = optionSingleFrame.toBoolean(&amp;exec) ? 1 : 0;
561         if (JSC::JSValue optionFrameCount = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;frameCount&quot;)))
562             recordingOptions.frameCount = optionFrameCount.toNumber(&amp;exec);
563         if (JSC::JSValue optionMemoryLimit = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;memoryLimit&quot;)))
564             recordingOptions.memoryLimit = optionMemoryLimit.toNumber(&amp;exec);
565         if (JSC::JSValue optionName = options-&gt;get(&amp;exec, JSC::Identifier::fromString(vm, &quot;name&quot;)))
566             recordingOptions.name = optionName.toWTFString(&amp;exec);
567     }
568     startRecording(*inspectorCanvas, Inspector::Protocol::Recording::Initiator::Console, WTFMove(recordingOptions));
569 }
570 
<span class="line-added">571 void InspectorCanvasAgent::consoleStopRecordingCanvas(CanvasRenderingContext&amp; context)</span>
<span class="line-added">572 {</span>
<span class="line-added">573     didFinishRecordingCanvasFrame(context, true);</span>
<span class="line-added">574 }</span>
<span class="line-added">575 </span>
576 #if ENABLE(WEBGL)
577 void InspectorCanvasAgent::didEnableExtension(WebGLRenderingContextBase&amp; context, const String&amp; extension)
578 {
579     auto inspectorCanvas = findInspectorCanvas(context);
580     ASSERT(inspectorCanvas);
581     if (!inspectorCanvas)
582         return;
583 
584     m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);
585 }
586 
<span class="line-modified">587 void InspectorCanvasAgent::didCreateWebGLProgram(WebGLRenderingContextBase&amp; context, WebGLProgram&amp; program)</span>
588 {
589     auto inspectorCanvas = findInspectorCanvas(context);
590     ASSERT(inspectorCanvas);
591     if (!inspectorCanvas)
592         return;
593 
<span class="line-modified">594     auto inspectorProgramRef = InspectorShaderProgram::create(program, *inspectorCanvas);</span>
<span class="line-modified">595     auto&amp; inspectorProgram = inspectorProgramRef.get();</span>
<span class="line-modified">596     m_identifierToInspectorProgram.set(inspectorProgram.identifier(), WTFMove(inspectorProgramRef));</span>
<span class="line-modified">597     m_frontendDispatcher-&gt;programCreated(inspectorProgram.buildObjectForShaderProgram());</span>
598 }
599 
<span class="line-modified">600 void InspectorCanvasAgent::willDestroyWebGLProgram(WebGLProgram&amp; program)</span>
601 {
602     auto inspectorProgram = findInspectorProgram(program);
603     if (!inspectorProgram)
604         return;
605 
<span class="line-modified">606     unbindProgram(*inspectorProgram);</span>

607 }
608 
<span class="line-modified">609 bool InspectorCanvasAgent::isWebGLProgramDisabled(WebGLProgram&amp; program)</span>
610 {
611     auto inspectorProgram = findInspectorProgram(program);
612     ASSERT(inspectorProgram);
613     if (!inspectorProgram)
614         return false;
615 
616     return inspectorProgram-&gt;disabled();
617 }
618 
<span class="line-modified">619 bool InspectorCanvasAgent::isWebGLProgramHighlighted(WebGLProgram&amp; program)</span>
620 {
621     auto inspectorProgram = findInspectorProgram(program);
622     ASSERT(inspectorProgram);
623     if (!inspectorProgram)
624         return false;
625 
626     return inspectorProgram-&gt;highlighted();
627 }
628 #endif
629 
<span class="line-added">630 #if ENABLE(WEBGPU)</span>
<span class="line-added">631 void InspectorCanvasAgent::didCreateWebGPUDevice(WebGPUDevice&amp; device)</span>
<span class="line-added">632 {</span>
<span class="line-added">633     if (findInspectorCanvas(device)) {</span>
<span class="line-added">634         ASSERT_NOT_REACHED();</span>
<span class="line-added">635         return;</span>
<span class="line-added">636     }</span>
<span class="line-added">637 </span>
<span class="line-added">638     bindCanvas(device, true);</span>
<span class="line-added">639 }</span>
<span class="line-added">640 </span>
<span class="line-added">641 void InspectorCanvasAgent::willDestroyWebGPUDevice(WebGPUDevice&amp; device)</span>
<span class="line-added">642 {</span>
<span class="line-added">643     auto inspectorCanvas = findInspectorCanvas(device);</span>
<span class="line-added">644     ASSERT(inspectorCanvas);</span>
<span class="line-added">645     if (!inspectorCanvas)</span>
<span class="line-added">646         return;</span>
<span class="line-added">647 </span>
<span class="line-added">648     unbindCanvas(*inspectorCanvas);</span>
<span class="line-added">649 }</span>
<span class="line-added">650 </span>
<span class="line-added">651 void InspectorCanvasAgent::willConfigureSwapChain(GPUCanvasContext&amp; contextGPU, WebGPUSwapChain&amp; newSwapChain)</span>
<span class="line-added">652 {</span>
<span class="line-added">653     auto notifyDeviceForSwapChain = [&amp;] (WebGPUSwapChain&amp; webGPUSwapChain) {</span>
<span class="line-added">654         for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {</span>
<span class="line-added">655             if (auto* device = inspectorCanvas-&gt;deviceContext()) {</span>
<span class="line-added">656                 if (device-&gt;device().swapChain() == webGPUSwapChain.swapChain())</span>
<span class="line-added">657                     m_frontendDispatcher-&gt;clientNodesChanged(inspectorCanvas-&gt;identifier());</span>
<span class="line-added">658             }</span>
<span class="line-added">659         }</span>
<span class="line-added">660     };</span>
<span class="line-added">661 </span>
<span class="line-added">662     if (auto* existingSwapChain = contextGPU.swapChain())</span>
<span class="line-added">663         notifyDeviceForSwapChain(*existingSwapChain);</span>
<span class="line-added">664 </span>
<span class="line-added">665     notifyDeviceForSwapChain(newSwapChain);</span>
<span class="line-added">666 }</span>
<span class="line-added">667 </span>
<span class="line-added">668 void InspectorCanvasAgent::didCreateWebGPUPipeline(WebGPUDevice&amp; device, WebGPUPipeline&amp; pipeline)</span>
<span class="line-added">669 {</span>
<span class="line-added">670     auto inspectorCanvas = findInspectorCanvas(device);</span>
<span class="line-added">671     ASSERT(inspectorCanvas);</span>
<span class="line-added">672     if (!inspectorCanvas)</span>
<span class="line-added">673         return;</span>
<span class="line-added">674 </span>
<span class="line-added">675     ASSERT(pipeline.isValid());</span>
<span class="line-added">676 </span>
<span class="line-added">677     auto inspectorProgramRef = InspectorShaderProgram::create(pipeline, *inspectorCanvas);</span>
<span class="line-added">678     auto&amp; inspectorProgram = inspectorProgramRef.get();</span>
<span class="line-added">679     m_identifierToInspectorProgram.set(inspectorProgram.identifier(), WTFMove(inspectorProgramRef));</span>
<span class="line-added">680     m_frontendDispatcher-&gt;programCreated(inspectorProgram.buildObjectForShaderProgram());</span>
<span class="line-added">681 }</span>
<span class="line-added">682 </span>
<span class="line-added">683 void InspectorCanvasAgent::willDestroyWebGPUPipeline(WebGPUPipeline&amp; pipeline)</span>
<span class="line-added">684 {</span>
<span class="line-added">685     auto inspectorProgram = findInspectorProgram(pipeline);</span>
<span class="line-added">686     if (!inspectorProgram)</span>
<span class="line-added">687         return;</span>
<span class="line-added">688 </span>
<span class="line-added">689     unbindProgram(*inspectorProgram);</span>
<span class="line-added">690 }</span>
<span class="line-added">691 #endif</span>
<span class="line-added">692 </span>
693 void InspectorCanvasAgent::startRecording(InspectorCanvas&amp; inspectorCanvas, Inspector::Protocol::Recording::Initiator initiator, RecordingOptions&amp;&amp; recordingOptions)
694 {
<span class="line-modified">695     auto* context = inspectorCanvas.canvasContext();</span>
<span class="line-added">696     ASSERT(context);</span>
<span class="line-added">697     // FIXME: &lt;https://webkit.org/b/201651&gt; Web Inspector: Canvas: support canvas recordings for WebGPUDevice</span>
698 
<span class="line-modified">699     if (!is&lt;CanvasRenderingContext2D&gt;(context)</span>
<span class="line-added">700         &amp;&amp; !is&lt;ImageBitmapRenderingContext&gt;(context)</span>
701 #if ENABLE(WEBGL)
<span class="line-modified">702         &amp;&amp; !is&lt;WebGLRenderingContext&gt;(context)</span>
703 #endif
704 #if ENABLE(WEBGL2)
<span class="line-modified">705         &amp;&amp; !is&lt;WebGL2RenderingContext&gt;(context)</span>
706 #endif
<span class="line-modified">707     )</span>
708         return;
709 
<span class="line-modified">710     if (context-&gt;callTracingActive())</span>
711         return;
712 
713     inspectorCanvas.resetRecordingData();
714     if (recordingOptions.frameCount)
715         inspectorCanvas.setFrameCount(recordingOptions.frameCount.value());
716     if (recordingOptions.memoryLimit)
717         inspectorCanvas.setBufferLimit(recordingOptions.memoryLimit.value());
718     if (recordingOptions.name)
719         inspectorCanvas.setRecordingName(recordingOptions.name.value());
<span class="line-modified">720     context-&gt;setCallTracingActive(true);</span>
721 
722     m_frontendDispatcher-&gt;recordingStarted(inspectorCanvas.identifier(), initiator);
723 }
724 
725 void InspectorCanvasAgent::canvasDestroyedTimerFired()
726 {
727     if (!m_removedCanvasIdentifiers.size())
728         return;
729 
730     for (auto&amp; identifier : m_removedCanvasIdentifiers)
731         m_frontendDispatcher-&gt;canvasRemoved(identifier);
732 
733     m_removedCanvasIdentifiers.clear();
734 }
735 
<span class="line-modified">736 void InspectorCanvasAgent::programDestroyedTimerFired()</span>
<span class="line-added">737 {</span>
<span class="line-added">738     if (!m_removedProgramIdentifiers.size())</span>
<span class="line-added">739         return;</span>
<span class="line-added">740 </span>
<span class="line-added">741     for (auto&amp; identifier : m_removedProgramIdentifiers)</span>
<span class="line-added">742         m_frontendDispatcher-&gt;programDeleted(identifier);</span>
<span class="line-added">743 </span>
<span class="line-added">744     m_removedProgramIdentifiers.clear();</span>
<span class="line-added">745 }</span>
<span class="line-added">746 </span>
<span class="line-added">747 void InspectorCanvasAgent::reset()</span>
748 {
<span class="line-modified">749     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {</span>
<span class="line-modified">750         if (auto* context = inspectorCanvas-&gt;canvasContext())</span>
<span class="line-added">751             context-&gt;canvasBase().removeObserver(*this);</span>
<span class="line-added">752     }</span>
753 
754     m_identifierToInspectorCanvas.clear();


755     m_removedCanvasIdentifiers.clear();


756     if (m_canvasDestroyedTimer.isActive())
757         m_canvasDestroyedTimer.stop();
<span class="line-added">758 </span>
<span class="line-added">759     m_identifierToInspectorProgram.clear();</span>
<span class="line-added">760     m_removedProgramIdentifiers.clear();</span>
<span class="line-added">761     if (m_programDestroyedTimer.isActive())</span>
<span class="line-added">762         m_programDestroyedTimer.stop();</span>
<span class="line-added">763 </span>
<span class="line-added">764     m_recordingCanvasIdentifiers.clear();</span>
765 }
766 
767 InspectorCanvas&amp; InspectorCanvasAgent::bindCanvas(CanvasRenderingContext&amp; context, bool captureBacktrace)
768 {
769     auto inspectorCanvas = InspectorCanvas::create(context);
770     m_identifierToInspectorCanvas.set(inspectorCanvas-&gt;identifier(), inspectorCanvas.copyRef());
771 
<span class="line-modified">772     context.canvasBase().addObserver(*this);</span>
773 
774     m_frontendDispatcher-&gt;canvasAdded(inspectorCanvas-&gt;buildObjectForCanvas(captureBacktrace));
775 
776 #if ENABLE(WEBGL)
<span class="line-modified">777     if (is&lt;WebGLRenderingContextBase&gt;(context)) {</span>
<span class="line-modified">778         auto&amp; contextWebGL = downcast&lt;WebGLRenderingContextBase&gt;(context);</span>
779         if (Optional&lt;Vector&lt;String&gt;&gt; extensions = contextWebGL.getSupportedExtensions()) {
780             for (const String&amp; extension : *extensions) {
781                 if (contextWebGL.extensionIsEnabled(extension))
782                     m_frontendDispatcher-&gt;extensionEnabled(inspectorCanvas-&gt;identifier(), extension);
783             }
784         }
785     }
786 #endif
787 
788     return inspectorCanvas;
789 }
790 
<span class="line-modified">791 #if ENABLE(WEBGPU)</span>
<span class="line-added">792 InspectorCanvas&amp; InspectorCanvasAgent::bindCanvas(WebGPUDevice&amp; device, bool captureBacktrace)</span>
<span class="line-added">793 {</span>
<span class="line-added">794     auto inspectorCanvas = InspectorCanvas::create(device);</span>
<span class="line-added">795     m_identifierToInspectorCanvas.set(inspectorCanvas-&gt;identifier(), inspectorCanvas.copyRef());</span>
<span class="line-added">796 </span>
<span class="line-added">797     m_frontendDispatcher-&gt;canvasAdded(inspectorCanvas-&gt;buildObjectForCanvas(captureBacktrace));</span>
<span class="line-added">798 </span>
<span class="line-added">799     return inspectorCanvas;</span>
<span class="line-added">800 }</span>
<span class="line-added">801 #endif</span>
<span class="line-added">802 </span>
<span class="line-added">803 void InspectorCanvasAgent::unbindCanvas(InspectorCanvas&amp; inspectorCanvas)</span>
804 {
805 #if ENABLE(WEBGL)
806     Vector&lt;InspectorShaderProgram*&gt; programsToRemove;
807     for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
808         if (&amp;inspectorProgram-&gt;canvas() == &amp;inspectorCanvas)
809             programsToRemove.append(inspectorProgram.get());
810     }
811 
812     for (auto* inspectorProgram : programsToRemove)
813         unbindProgram(*inspectorProgram);
814 #endif
815 
<span class="line-modified">816     if (auto* context = inspectorCanvas.canvasContext())</span>
<span class="line-added">817         context-&gt;canvasBase().removeObserver(*this);</span>
818 
819     String identifier = inspectorCanvas.identifier();
820     m_identifierToInspectorCanvas.remove(identifier);
821 
<span class="line-modified">822     // This can be called in response to GC. Due to the single-process model used in WebKit1, the</span>
<span class="line-added">823     // event must be dispatched from a timer to prevent the frontend from making JS allocations</span>
<span class="line-added">824     // while the GC is still active.</span>
<span class="line-added">825     m_removedCanvasIdentifiers.append(identifier);</span>
<span class="line-added">826 </span>
<span class="line-added">827     if (!m_canvasDestroyedTimer.isActive())</span>
<span class="line-added">828         m_canvasDestroyedTimer.startOneShot(0_s);</span>
829 }
830 
831 RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::assertInspectorCanvas(ErrorString&amp; errorString, const String&amp; canvasId)
832 {
833     auto inspectorCanvas = m_identifierToInspectorCanvas.get(canvasId);
834     if (!inspectorCanvas) {
835         errorString = &quot;Missing canvas for given canvasId&quot;_s;
836         return nullptr;
837     }
838     return inspectorCanvas;
839 }
840 
841 RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::findInspectorCanvas(CanvasRenderingContext&amp; context)
842 {
843     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {
<span class="line-modified">844         if (inspectorCanvas-&gt;canvasContext() == &amp;context)</span>
845             return inspectorCanvas;
846     }
847     return nullptr;
848 }
849 
<span class="line-modified">850 #if ENABLE(WEBGPU)</span>
<span class="line-modified">851 RefPtr&lt;InspectorCanvas&gt; InspectorCanvasAgent::findInspectorCanvas(WebGPUDevice&amp; device)</span>
<span class="line-added">852 {</span>
<span class="line-added">853     for (auto&amp; inspectorCanvas : m_identifierToInspectorCanvas.values()) {</span>
<span class="line-added">854         if (inspectorCanvas-&gt;deviceContext() == &amp;device)</span>
<span class="line-added">855             return inspectorCanvas;</span>
<span class="line-added">856     }</span>
<span class="line-added">857     return nullptr;</span>
<span class="line-added">858 }</span>
<span class="line-added">859 #endif</span>
<span class="line-added">860 </span>
<span class="line-added">861 void InspectorCanvasAgent::unbindProgram(InspectorShaderProgram&amp; inspectorProgram)</span>
862 {
863     String identifier = inspectorProgram.identifier();
864     m_identifierToInspectorProgram.remove(identifier);
865 
<span class="line-modified">866     // This can be called in response to GC. Due to the single-process model used in WebKit1, the</span>
<span class="line-added">867     // event must be dispatched from a timer to prevent the frontend from making JS allocations</span>
<span class="line-added">868     // while the GC is still active.</span>
<span class="line-added">869     m_removedProgramIdentifiers.append(identifier);</span>
<span class="line-added">870 </span>
<span class="line-added">871     if (!m_programDestroyedTimer.isActive())</span>
<span class="line-added">872         m_programDestroyedTimer.startOneShot(0_s);</span>
873 }
874 
875 RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::assertInspectorProgram(ErrorString&amp; errorString, const String&amp; programId)
876 {
877     auto inspectorProgram = m_identifierToInspectorProgram.get(programId);
878     if (!inspectorProgram) {
879         errorString = &quot;Missing program for given programId&quot;_s;
880         return nullptr;
881     }
882     return inspectorProgram;
883 }
884 
<span class="line-added">885 #if ENABLE(WEBGL)</span>
886 RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::findInspectorProgram(WebGLProgram&amp; program)
887 {
888     for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {
<span class="line-modified">889         if (inspectorProgram-&gt;program() == &amp;program)</span>
<span class="line-added">890             return inspectorProgram;</span>
<span class="line-added">891     }</span>
<span class="line-added">892     return nullptr;</span>
<span class="line-added">893 }</span>
<span class="line-added">894 #endif</span>
<span class="line-added">895 </span>
<span class="line-added">896 #if ENABLE(WEBGPU)</span>
<span class="line-added">897 RefPtr&lt;InspectorShaderProgram&gt; InspectorCanvasAgent::findInspectorProgram(WebGPUPipeline&amp; pipeline)</span>
<span class="line-added">898 {</span>
<span class="line-added">899     for (auto&amp; inspectorProgram : m_identifierToInspectorProgram.values()) {</span>
<span class="line-added">900         if (inspectorProgram-&gt;pipeline() == &amp;pipeline)</span>
901             return inspectorProgram;
902     }
903     return nullptr;
904 }
905 #endif
906 
907 } // namespace WebCore
</pre>
</td>
</tr>
</table>
<center><a href="InspectorCSSAgent.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InspectorCanvasAgent.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
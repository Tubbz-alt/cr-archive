<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilder.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../svg/SVGTextLayoutEngineSpacing.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderTreeBuilderBlock.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilder.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeBuilder.h&quot;
 28 
 29 #include &quot;AXObjectCache.h&quot;
 30 #include &quot;Frame.h&quot;
 31 #include &quot;FrameSelection.h&quot;
 32 #include &quot;RenderButton.h&quot;
 33 #include &quot;RenderCounter.h&quot;
 34 #include &quot;RenderElement.h&quot;
 35 #include &quot;RenderFullScreen.h&quot;
 36 #include &quot;RenderGrid.h&quot;
 37 #include &quot;RenderLineBreak.h&quot;
 38 #include &quot;RenderMathMLFenced.h&quot;
 39 #include &quot;RenderMenuList.h&quot;
 40 #include &quot;RenderMultiColumnFlow.h&quot;

 41 #include &quot;RenderRuby.h&quot;
 42 #include &quot;RenderRubyBase.h&quot;
 43 #include &quot;RenderRubyRun.h&quot;
 44 #include &quot;RenderSVGContainer.h&quot;
 45 #include &quot;RenderSVGInline.h&quot;
 46 #include &quot;RenderSVGRoot.h&quot;
 47 #include &quot;RenderSVGText.h&quot;
 48 #include &quot;RenderTable.h&quot;
 49 #include &quot;RenderTableRow.h&quot;
 50 #include &quot;RenderTableSection.h&quot;
 51 #include &quot;RenderText.h&quot;
 52 #include &quot;RenderTextFragment.h&quot;
 53 #include &quot;RenderTreeBuilderBlock.h&quot;
 54 #include &quot;RenderTreeBuilderBlockFlow.h&quot;
 55 #include &quot;RenderTreeBuilderContinuation.h&quot;
 56 #include &quot;RenderTreeBuilderFirstLetter.h&quot;
 57 #include &quot;RenderTreeBuilderFormControls.h&quot;
 58 #include &quot;RenderTreeBuilderFullScreen.h&quot;
 59 #include &quot;RenderTreeBuilderInline.h&quot;
 60 #include &quot;RenderTreeBuilderList.h&quot;
 61 #include &quot;RenderTreeBuilderMathML.h&quot;
 62 #include &quot;RenderTreeBuilderMultiColumn.h&quot;
 63 #include &quot;RenderTreeBuilderRuby.h&quot;
 64 #include &quot;RenderTreeBuilderSVG.h&quot;
 65 #include &quot;RenderTreeBuilderTable.h&quot;







 66 
 67 namespace WebCore {
 68 
 69 RenderTreeBuilder* RenderTreeBuilder::s_current;
 70 
 71 static void markBoxForRelayoutAfterSplit(RenderBox&amp; box)
 72 {
 73     // FIXME: The table code should handle that automatically. If not,
 74     // we should fix it and remove the table part checks.
 75     if (is&lt;RenderTable&gt;(box)) {
 76         // Because we may have added some sections with already computed column structures, we need to
 77         // sync the table structure with them now. This avoids crashes when adding new cells to the table.
 78         downcast&lt;RenderTable&gt;(box).forceSectionsRecalc();
 79     } else if (is&lt;RenderTableSection&gt;(box))
 80         downcast&lt;RenderTableSection&gt;(box).setNeedsCellRecalc();
 81 
 82     box.setNeedsLayoutAndPrefWidthsRecalc();
 83 }
 84 
 85 static void getInlineRun(RenderObject* start, RenderObject* boundary, RenderObject*&amp; inlineRunStart, RenderObject*&amp; inlineRunEnd)
</pre>
<hr />
<pre>
168 
169     // We need to detach the subtree first so that the descendants don&#39;t have
170     // access to previous/next sublings at detach().
171     // FIXME: webkit.org/b/182909.
172     if (!is&lt;RenderElement&gt;(toDestroy.get()))
173         return;
174 
175     auto&amp; childToDestroy = downcast&lt;RenderElement&gt;(*toDestroy.get());
176     while (childToDestroy.firstChild()) {
177         auto&amp; firstChild = *childToDestroy.firstChild();
178         if (auto* node = firstChild.node())
179             node-&gt;setRenderer(nullptr);
180         destroy(firstChild);
181     }
182 }
183 
184 void RenderTreeBuilder::attach(RenderElement&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
185 {
186     auto insertRecursiveIfNeeded = [&amp;](RenderElement&amp; parentCandidate) {
187         if (&amp;parent == &amp;parentCandidate) {





188             attachToRenderElement(parent, WTFMove(child), beforeChild);
189             return;
190         }
191         attach(parentCandidate, WTFMove(child), beforeChild);
192     };
193 
194     ASSERT(&amp;parent.view() == &amp;m_view);
195 
196     if (is&lt;RenderText&gt;(beforeChild)) {
197         if (auto* wrapperInline = downcast&lt;RenderText&gt;(*beforeChild).inlineWrapperForDisplayContents())
198             beforeChild = wrapperInline;














199     }
200 
201     if (is&lt;RenderTableRow&gt;(parent)) {
202         auto&amp; parentCandidate = tableBuilder().findOrCreateParentForChild(downcast&lt;RenderTableRow&gt;(parent), *child, beforeChild);
203         if (&amp;parentCandidate == &amp;parent) {
204             tableBuilder().attach(downcast&lt;RenderTableRow&gt;(parentCandidate), WTFMove(child), beforeChild);
205             return;
206         }
207         insertRecursiveIfNeeded(parentCandidate);
208         return;
209     }
210 
211     if (is&lt;RenderTableSection&gt;(parent)) {
212         auto&amp; parentCandidate = tableBuilder().findOrCreateParentForChild(downcast&lt;RenderTableSection&gt;(parent), *child, beforeChild);
213         if (&amp;parent == &amp;parentCandidate) {
214             tableBuilder().attach(downcast&lt;RenderTableSection&gt;(parent), WTFMove(child), beforeChild);
215             return;
216         }
217         insertRecursiveIfNeeded(parentCandidate);
218         return;
</pre>
<hr />
<pre>
414 
415         auto* fragmentedFlow = newChild-&gt;enclosingFragmentedFlow();
416         if (is&lt;RenderMultiColumnFlow&gt;(fragmentedFlow))
417             multiColumnBuilder().multiColumnDescendantInserted(downcast&lt;RenderMultiColumnFlow&gt;(*fragmentedFlow), *newChild);
418 
419         if (is&lt;RenderElement&gt;(*newChild))
420             RenderCounter::rendererSubtreeAttached(downcast&lt;RenderElement&gt;(*newChild));
421     }
422 
423     newChild-&gt;setNeedsLayoutAndPrefWidthsRecalc();
424     parent.setPreferredLogicalWidthsDirty(true);
425     if (!parent.normalChildNeedsLayout())
426         parent.setChildNeedsLayout(); // We may supply the static position for an absolute positioned child.
427 
428     if (AXObjectCache* cache = parent.document().axObjectCache())
429         cache-&gt;childrenChanged(&amp;parent, newChild);
430     if (is&lt;RenderBlockFlow&gt;(parent))
431         downcast&lt;RenderBlockFlow&gt;(parent).invalidateLineLayoutPath();
432     if (parent.hasOutlineAutoAncestor() || parent.outlineStyleForRepaint().outlineStyleIsAuto() == OutlineIsAuto::On)
433         newChild-&gt;setHasOutlineAutoAncestor();







434 }
435 
436 void RenderTreeBuilder::move(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject&amp; child, RenderObject* beforeChild, NormalizeAfterInsertion normalizeAfterInsertion)
437 {
438     // We assume that callers have cleared their positioned objects list for child moves so the
439     // positioned renderer maps don&#39;t become stale. It would be too slow to do the map lookup on each call.
440     ASSERT(normalizeAfterInsertion == NormalizeAfterInsertion::No || !is&lt;RenderBlock&gt;(from) || !downcast&lt;RenderBlock&gt;(from).hasPositionedObjects());
441 
442     ASSERT(&amp;from == child.parent());
443     ASSERT(!beforeChild || &amp;to == beforeChild-&gt;parent());
444     if (normalizeAfterInsertion == NormalizeAfterInsertion::Yes &amp;&amp; (to.isRenderBlock() || to.isRenderInline())) {
445         // Takes care of adding the new child correctly if toBlock and fromBlock
446         // have different kind of children (block vs inline).
447         auto childToMove = detachFromRenderElement(from, child);
448         attach(to, WTFMove(childToMove), beforeChild);
449     } else {
450         auto childToMove = detachFromRenderElement(from, child);
451         attachToRenderElementInternal(to, WTFMove(childToMove), beforeChild);
452     }
453 }
</pre>
<hr />
<pre>
643         markBoxForRelayoutAfterSplit(parent);
644 
645     ASSERT(beforeChild-&gt;parent() == &amp;parent);
646     return beforeChild;
647 }
648 
649 void RenderTreeBuilder::childFlowStateChangesAndAffectsParentBlock(RenderElement&amp; child)
650 {
651     auto* parent = child.parent();
652     if (!child.isInline()) {
653         if (is&lt;RenderBlock&gt;(parent))
654             blockBuilder().childBecameNonInline(downcast&lt;RenderBlock&gt;(*parent), child);
655         else if (is&lt;RenderInline&gt;(*parent))
656             inlineBuilder().childBecameNonInline(downcast&lt;RenderInline&gt;(*parent), child);
657 
658         // childBecameNonInline might have re-parented us.
659         if (auto* newParent = child.parent()) {
660             // We need to re-run the grid items placement if it had gained a new item.
661             if (newParent != parent &amp;&amp; is&lt;RenderGrid&gt;(*newParent))
662                 downcast&lt;RenderGrid&gt;(*newParent).dirtyGrid();






663         }
664     } else {
665         // An anonymous block must be made to wrap this inline.
666         auto newBlock = downcast&lt;RenderBlock&gt;(*parent).createAnonymousBlock();
667         auto&amp; block = *newBlock;
668         attachToRenderElementInternal(*parent, WTFMove(newBlock), &amp;child);
669         auto thisToMove = detachFromRenderElement(*parent, child);
670         attachToRenderElementInternal(block, WTFMove(thisToMove));
671     }
672 }
673 
674 void RenderTreeBuilder::removeAnonymousWrappersForInlineChildrenIfNeeded(RenderElement&amp; parent)
675 {
676     if (!is&lt;RenderBlock&gt;(parent))
677         return;
678     auto&amp; blockParent = downcast&lt;RenderBlock&gt;(parent);
679     if (!blockParent.canDropAnonymousBlockChild())
680         return;
681 
682     // We have changed to floated or out-of-flow positioning so maybe all our parent&#39;s
</pre>
<hr />
<pre>
831 
832     if (!parent.renderTreeBeingDestroyed())
833         child.willBeRemovedFromTree();
834 
835     child.resetFragmentedFlowStateOnRemoval();
836 
837     // WARNING: There should be no code running between willBeRemovedFromTree() and the actual removal below.
838     // This is needed to avoid race conditions where willBeRemovedFromTree() would dirty the tree&#39;s structure
839     // and the code running here would force an untimely rebuilding, leaving |child| dangling.
840     auto childToTake = parent.detachRendererInternal(child);
841 
842     // rendererRemovedFromTree() walks the whole subtree. We can improve performance
843     // by skipping this step when destroying the entire tree.
844     if (!parent.renderTreeBeingDestroyed() &amp;&amp; is&lt;RenderElement&gt;(*childToTake))
845         RenderCounter::rendererRemovedFromTree(downcast&lt;RenderElement&gt;(*childToTake));
846 
847     if (!parent.renderTreeBeingDestroyed()) {
848         if (AXObjectCache* cache = parent.document().existingAXObjectCache())
849             cache-&gt;childrenChanged(&amp;parent);
850     }




851 


852     return childToTake;
853 }
854 
855 void RenderTreeBuilder::attachToRenderGrid(RenderGrid&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
856 {
857     auto&amp; newChild = *child;
858     blockBuilder().attach(parent, WTFMove(child), beforeChild);
859 
860     // Positioned grid items do not take up space or otherwise participate in the layout of the grid,
861     // for that reason we don&#39;t need to mark the grid as dirty when they are added.
862     if (newChild.isOutOfFlowPositioned())
863         return;
864 
865     // The grid needs to be recomputed as it might contain auto-placed items that
866     // will change their position.
867     parent.dirtyGrid();
868 }
869 
870 }
</pre>
</td>
<td>
<hr />
<pre>
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderTreeBuilder.h&quot;
 28 
 29 #include &quot;AXObjectCache.h&quot;
 30 #include &quot;Frame.h&quot;
 31 #include &quot;FrameSelection.h&quot;
 32 #include &quot;RenderButton.h&quot;
 33 #include &quot;RenderCounter.h&quot;
 34 #include &quot;RenderElement.h&quot;
 35 #include &quot;RenderFullScreen.h&quot;
 36 #include &quot;RenderGrid.h&quot;
 37 #include &quot;RenderLineBreak.h&quot;
 38 #include &quot;RenderMathMLFenced.h&quot;
 39 #include &quot;RenderMenuList.h&quot;
 40 #include &quot;RenderMultiColumnFlow.h&quot;
<span class="line-added"> 41 #include &quot;RenderMultiColumnSpannerPlaceholder.h&quot;</span>
 42 #include &quot;RenderRuby.h&quot;
 43 #include &quot;RenderRubyBase.h&quot;
 44 #include &quot;RenderRubyRun.h&quot;
 45 #include &quot;RenderSVGContainer.h&quot;
 46 #include &quot;RenderSVGInline.h&quot;
 47 #include &quot;RenderSVGRoot.h&quot;
 48 #include &quot;RenderSVGText.h&quot;
 49 #include &quot;RenderTable.h&quot;
 50 #include &quot;RenderTableRow.h&quot;
 51 #include &quot;RenderTableSection.h&quot;
 52 #include &quot;RenderText.h&quot;
 53 #include &quot;RenderTextFragment.h&quot;
 54 #include &quot;RenderTreeBuilderBlock.h&quot;
 55 #include &quot;RenderTreeBuilderBlockFlow.h&quot;
 56 #include &quot;RenderTreeBuilderContinuation.h&quot;
 57 #include &quot;RenderTreeBuilderFirstLetter.h&quot;
 58 #include &quot;RenderTreeBuilderFormControls.h&quot;
 59 #include &quot;RenderTreeBuilderFullScreen.h&quot;
 60 #include &quot;RenderTreeBuilderInline.h&quot;
 61 #include &quot;RenderTreeBuilderList.h&quot;
 62 #include &quot;RenderTreeBuilderMathML.h&quot;
 63 #include &quot;RenderTreeBuilderMultiColumn.h&quot;
 64 #include &quot;RenderTreeBuilderRuby.h&quot;
 65 #include &quot;RenderTreeBuilderSVG.h&quot;
 66 #include &quot;RenderTreeBuilderTable.h&quot;
<span class="line-added"> 67 #include &quot;RenderView.h&quot;</span>
<span class="line-added"> 68 </span>
<span class="line-added"> 69 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added"> 70 #include &quot;FrameView.h&quot;</span>
<span class="line-added"> 71 #include &quot;FrameViewLayoutContext.h&quot;</span>
<span class="line-added"> 72 #include &quot;RuntimeEnabledFeatures.h&quot;</span>
<span class="line-added"> 73 #endif</span>
 74 
 75 namespace WebCore {
 76 
 77 RenderTreeBuilder* RenderTreeBuilder::s_current;
 78 
 79 static void markBoxForRelayoutAfterSplit(RenderBox&amp; box)
 80 {
 81     // FIXME: The table code should handle that automatically. If not,
 82     // we should fix it and remove the table part checks.
 83     if (is&lt;RenderTable&gt;(box)) {
 84         // Because we may have added some sections with already computed column structures, we need to
 85         // sync the table structure with them now. This avoids crashes when adding new cells to the table.
 86         downcast&lt;RenderTable&gt;(box).forceSectionsRecalc();
 87     } else if (is&lt;RenderTableSection&gt;(box))
 88         downcast&lt;RenderTableSection&gt;(box).setNeedsCellRecalc();
 89 
 90     box.setNeedsLayoutAndPrefWidthsRecalc();
 91 }
 92 
 93 static void getInlineRun(RenderObject* start, RenderObject* boundary, RenderObject*&amp; inlineRunStart, RenderObject*&amp; inlineRunEnd)
</pre>
<hr />
<pre>
176 
177     // We need to detach the subtree first so that the descendants don&#39;t have
178     // access to previous/next sublings at detach().
179     // FIXME: webkit.org/b/182909.
180     if (!is&lt;RenderElement&gt;(toDestroy.get()))
181         return;
182 
183     auto&amp; childToDestroy = downcast&lt;RenderElement&gt;(*toDestroy.get());
184     while (childToDestroy.firstChild()) {
185         auto&amp; firstChild = *childToDestroy.firstChild();
186         if (auto* node = firstChild.node())
187             node-&gt;setRenderer(nullptr);
188         destroy(firstChild);
189     }
190 }
191 
192 void RenderTreeBuilder::attach(RenderElement&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
193 {
194     auto insertRecursiveIfNeeded = [&amp;](RenderElement&amp; parentCandidate) {
195         if (&amp;parent == &amp;parentCandidate) {
<span class="line-added">196             // Parents inside multicols can&#39;t call internal attach directly.</span>
<span class="line-added">197             if (is&lt;RenderBlockFlow&gt;(parent) &amp;&amp; downcast&lt;RenderBlockFlow&gt;(parent).multiColumnFlow()) {</span>
<span class="line-added">198                 blockFlowBuilder().attach(downcast&lt;RenderBlockFlow&gt;(parent), WTFMove(child), beforeChild);</span>
<span class="line-added">199                 return;</span>
<span class="line-added">200             }</span>
201             attachToRenderElement(parent, WTFMove(child), beforeChild);
202             return;
203         }
204         attach(parentCandidate, WTFMove(child), beforeChild);
205     };
206 
207     ASSERT(&amp;parent.view() == &amp;m_view);
208 
209     if (is&lt;RenderText&gt;(beforeChild)) {
210         if (auto* wrapperInline = downcast&lt;RenderText&gt;(*beforeChild).inlineWrapperForDisplayContents())
211             beforeChild = wrapperInline;
<span class="line-added">212     } else if (is&lt;RenderBox&gt;(beforeChild)) {</span>
<span class="line-added">213         // Adjust the beforeChild if it happens to be a spanner and the its actual location is inside the fragmented flow.</span>
<span class="line-added">214         auto&amp; beforeChildBox = downcast&lt;RenderBox&gt;(*beforeChild);</span>
<span class="line-added">215         if (auto* enclosingFragmentedFlow = parent.enclosingFragmentedFlow()) {</span>
<span class="line-added">216             auto columnSpannerPlaceholderForBeforeChild = [&amp;]() -&gt; RenderMultiColumnSpannerPlaceholder* {</span>
<span class="line-added">217                 if (!is&lt;RenderMultiColumnFlow&gt;(enclosingFragmentedFlow))</span>
<span class="line-added">218                     return nullptr;</span>
<span class="line-added">219                 auto&amp; multiColumnFlow = downcast&lt;RenderMultiColumnFlow&gt;(*enclosingFragmentedFlow);</span>
<span class="line-added">220                 return multiColumnFlow.findColumnSpannerPlaceholder(&amp;beforeChildBox);</span>
<span class="line-added">221             };</span>
<span class="line-added">222 </span>
<span class="line-added">223             if (auto* spannerPlaceholder = columnSpannerPlaceholderForBeforeChild())</span>
<span class="line-added">224                 beforeChild = spannerPlaceholder;</span>
<span class="line-added">225         }</span>
226     }
227 
228     if (is&lt;RenderTableRow&gt;(parent)) {
229         auto&amp; parentCandidate = tableBuilder().findOrCreateParentForChild(downcast&lt;RenderTableRow&gt;(parent), *child, beforeChild);
230         if (&amp;parentCandidate == &amp;parent) {
231             tableBuilder().attach(downcast&lt;RenderTableRow&gt;(parentCandidate), WTFMove(child), beforeChild);
232             return;
233         }
234         insertRecursiveIfNeeded(parentCandidate);
235         return;
236     }
237 
238     if (is&lt;RenderTableSection&gt;(parent)) {
239         auto&amp; parentCandidate = tableBuilder().findOrCreateParentForChild(downcast&lt;RenderTableSection&gt;(parent), *child, beforeChild);
240         if (&amp;parent == &amp;parentCandidate) {
241             tableBuilder().attach(downcast&lt;RenderTableSection&gt;(parent), WTFMove(child), beforeChild);
242             return;
243         }
244         insertRecursiveIfNeeded(parentCandidate);
245         return;
</pre>
<hr />
<pre>
441 
442         auto* fragmentedFlow = newChild-&gt;enclosingFragmentedFlow();
443         if (is&lt;RenderMultiColumnFlow&gt;(fragmentedFlow))
444             multiColumnBuilder().multiColumnDescendantInserted(downcast&lt;RenderMultiColumnFlow&gt;(*fragmentedFlow), *newChild);
445 
446         if (is&lt;RenderElement&gt;(*newChild))
447             RenderCounter::rendererSubtreeAttached(downcast&lt;RenderElement&gt;(*newChild));
448     }
449 
450     newChild-&gt;setNeedsLayoutAndPrefWidthsRecalc();
451     parent.setPreferredLogicalWidthsDirty(true);
452     if (!parent.normalChildNeedsLayout())
453         parent.setChildNeedsLayout(); // We may supply the static position for an absolute positioned child.
454 
455     if (AXObjectCache* cache = parent.document().axObjectCache())
456         cache-&gt;childrenChanged(&amp;parent, newChild);
457     if (is&lt;RenderBlockFlow&gt;(parent))
458         downcast&lt;RenderBlockFlow&gt;(parent).invalidateLineLayoutPath();
459     if (parent.hasOutlineAutoAncestor() || parent.outlineStyleForRepaint().outlineStyleIsAuto() == OutlineIsAuto::On)
460         newChild-&gt;setHasOutlineAutoAncestor();
<span class="line-added">461 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">462     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextEnabled()) {</span>
<span class="line-added">463         if (parent.document().view())</span>
<span class="line-added">464             parent.document().view()-&gt;layoutContext().invalidateLayoutTreeContent();</span>
<span class="line-added">465 </span>
<span class="line-added">466     }</span>
<span class="line-added">467 #endif</span>
468 }
469 
470 void RenderTreeBuilder::move(RenderBoxModelObject&amp; from, RenderBoxModelObject&amp; to, RenderObject&amp; child, RenderObject* beforeChild, NormalizeAfterInsertion normalizeAfterInsertion)
471 {
472     // We assume that callers have cleared their positioned objects list for child moves so the
473     // positioned renderer maps don&#39;t become stale. It would be too slow to do the map lookup on each call.
474     ASSERT(normalizeAfterInsertion == NormalizeAfterInsertion::No || !is&lt;RenderBlock&gt;(from) || !downcast&lt;RenderBlock&gt;(from).hasPositionedObjects());
475 
476     ASSERT(&amp;from == child.parent());
477     ASSERT(!beforeChild || &amp;to == beforeChild-&gt;parent());
478     if (normalizeAfterInsertion == NormalizeAfterInsertion::Yes &amp;&amp; (to.isRenderBlock() || to.isRenderInline())) {
479         // Takes care of adding the new child correctly if toBlock and fromBlock
480         // have different kind of children (block vs inline).
481         auto childToMove = detachFromRenderElement(from, child);
482         attach(to, WTFMove(childToMove), beforeChild);
483     } else {
484         auto childToMove = detachFromRenderElement(from, child);
485         attachToRenderElementInternal(to, WTFMove(childToMove), beforeChild);
486     }
487 }
</pre>
<hr />
<pre>
677         markBoxForRelayoutAfterSplit(parent);
678 
679     ASSERT(beforeChild-&gt;parent() == &amp;parent);
680     return beforeChild;
681 }
682 
683 void RenderTreeBuilder::childFlowStateChangesAndAffectsParentBlock(RenderElement&amp; child)
684 {
685     auto* parent = child.parent();
686     if (!child.isInline()) {
687         if (is&lt;RenderBlock&gt;(parent))
688             blockBuilder().childBecameNonInline(downcast&lt;RenderBlock&gt;(*parent), child);
689         else if (is&lt;RenderInline&gt;(*parent))
690             inlineBuilder().childBecameNonInline(downcast&lt;RenderInline&gt;(*parent), child);
691 
692         // childBecameNonInline might have re-parented us.
693         if (auto* newParent = child.parent()) {
694             // We need to re-run the grid items placement if it had gained a new item.
695             if (newParent != parent &amp;&amp; is&lt;RenderGrid&gt;(*newParent))
696                 downcast&lt;RenderGrid&gt;(*newParent).dirtyGrid();
<span class="line-added">697             else if (auto* enclosingFragmentedFlow = newParent-&gt;enclosingFragmentedFlow()) {</span>
<span class="line-added">698                 if (is&lt;RenderMultiColumnFlow&gt;(*enclosingFragmentedFlow)) {</span>
<span class="line-added">699                     // Let the fragmented flow know that it has a new in-flow descendant.</span>
<span class="line-added">700                     multiColumnBuilder().multiColumnDescendantInserted(downcast&lt;RenderMultiColumnFlow&gt;(*enclosingFragmentedFlow), child);</span>
<span class="line-added">701                 }</span>
<span class="line-added">702             }</span>
703         }
704     } else {
705         // An anonymous block must be made to wrap this inline.
706         auto newBlock = downcast&lt;RenderBlock&gt;(*parent).createAnonymousBlock();
707         auto&amp; block = *newBlock;
708         attachToRenderElementInternal(*parent, WTFMove(newBlock), &amp;child);
709         auto thisToMove = detachFromRenderElement(*parent, child);
710         attachToRenderElementInternal(block, WTFMove(thisToMove));
711     }
712 }
713 
714 void RenderTreeBuilder::removeAnonymousWrappersForInlineChildrenIfNeeded(RenderElement&amp; parent)
715 {
716     if (!is&lt;RenderBlock&gt;(parent))
717         return;
718     auto&amp; blockParent = downcast&lt;RenderBlock&gt;(parent);
719     if (!blockParent.canDropAnonymousBlockChild())
720         return;
721 
722     // We have changed to floated or out-of-flow positioning so maybe all our parent&#39;s
</pre>
<hr />
<pre>
871 
872     if (!parent.renderTreeBeingDestroyed())
873         child.willBeRemovedFromTree();
874 
875     child.resetFragmentedFlowStateOnRemoval();
876 
877     // WARNING: There should be no code running between willBeRemovedFromTree() and the actual removal below.
878     // This is needed to avoid race conditions where willBeRemovedFromTree() would dirty the tree&#39;s structure
879     // and the code running here would force an untimely rebuilding, leaving |child| dangling.
880     auto childToTake = parent.detachRendererInternal(child);
881 
882     // rendererRemovedFromTree() walks the whole subtree. We can improve performance
883     // by skipping this step when destroying the entire tree.
884     if (!parent.renderTreeBeingDestroyed() &amp;&amp; is&lt;RenderElement&gt;(*childToTake))
885         RenderCounter::rendererRemovedFromTree(downcast&lt;RenderElement&gt;(*childToTake));
886 
887     if (!parent.renderTreeBeingDestroyed()) {
888         if (AXObjectCache* cache = parent.document().existingAXObjectCache())
889             cache-&gt;childrenChanged(&amp;parent);
890     }
<span class="line-added">891 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)</span>
<span class="line-added">892     if (RuntimeEnabledFeatures::sharedFeatures().layoutFormattingContextEnabled()) {</span>
<span class="line-added">893         if (parent.document().view())</span>
<span class="line-added">894             parent.document().view()-&gt;layoutContext().invalidateLayoutTreeContent();</span>
895 
<span class="line-added">896     }</span>
<span class="line-added">897 #endif</span>
898     return childToTake;
899 }
900 
901 void RenderTreeBuilder::attachToRenderGrid(RenderGrid&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
902 {
903     auto&amp; newChild = *child;
904     blockBuilder().attach(parent, WTFMove(child), beforeChild);
905 
906     // Positioned grid items do not take up space or otherwise participate in the layout of the grid,
907     // for that reason we don&#39;t need to mark the grid as dirty when they are added.
908     if (newChild.isOutOfFlowPositioned())
909         return;
910 
911     // The grid needs to be recomputed as it might contain auto-placed items that
912     // will change their position.
913     parent.dirtyGrid();
914 }
915 
916 }
</pre>
</td>
</tr>
</table>
<center><a href="../svg/SVGTextLayoutEngineSpacing.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderTreeBuilderBlock.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
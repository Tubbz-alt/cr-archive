<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITMathIC.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016-2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #if ENABLE(JIT)
 29 
 30 #include &quot;ArithProfile.h&quot;
 31 #include &quot;CCallHelpers.h&quot;
 32 #include &quot;JITAddGenerator.h&quot;
 33 #include &quot;JITMathICInlineResult.h&quot;
 34 #include &quot;JITMulGenerator.h&quot;
 35 #include &quot;JITNegGenerator.h&quot;
 36 #include &quot;JITSubGenerator.h&quot;
 37 #include &quot;LinkBuffer.h&quot;
 38 #include &quot;Repatch.h&quot;
 39 
 40 namespace JSC {
 41 
 42 class LinkBuffer;
 43 
 44 struct MathICGenerationState {
 45     MacroAssembler::Label fastPathStart;
 46     MacroAssembler::Label fastPathEnd;
 47     MacroAssembler::Label slowPathStart;
 48     MacroAssembler::Call slowPathCall;
 49     MacroAssembler::JumpList slowPathJumps;
 50     bool shouldSlowPathRepatch;
 51 };
 52 
 53 #define ENABLE_MATH_IC_STATS 0
 54 
 55 template &lt;typename GeneratorType, typename ArithProfileType&gt;
 56 class JITMathIC {
 57     WTF_MAKE_FAST_ALLOCATED;
 58 public:
 59     JITMathIC(ArithProfileType* arithProfile)
 60         : m_arithProfile(arithProfile)
 61     {
 62     }
 63 
 64     CodeLocationLabel&lt;JSInternalPtrTag&gt; doneLocation() { return m_inlineEnd; }
 65     CodeLocationCall&lt;JSInternalPtrTag&gt; slowPathCallLocation() { return m_slowPathCallLocation; }
 66     CodeLocationLabel&lt;JSInternalPtrTag&gt; slowPathStartLocation() { return m_slowPathStartLocation; }
 67 
 68     bool generateInline(CCallHelpers&amp; jit, MathICGenerationState&amp; state, bool shouldEmitProfiling = true)
 69     {
 70         state.fastPathStart = jit.label();
 71         size_t startSize = jit.m_assembler.buffer().codeSize();
 72 
 73         if (m_arithProfile &amp;&amp; m_arithProfile-&gt;isObservedTypeEmpty()) {
 74             // It looks like the MathIC has yet to execute. We don&#39;t want to emit code in this
 75             // case for a couple reasons. First, the operation may never execute, so if we don&#39;t emit
 76             // code, it&#39;s a win. Second, if the operation does execute, we can emit better code
 77             // once we have an idea about the types.
 78             state.slowPathJumps.append(jit.patchableJump());
 79             size_t inlineSize = jit.m_assembler.buffer().codeSize() - startSize;
 80             ASSERT_UNUSED(inlineSize, static_cast&lt;ptrdiff_t&gt;(inlineSize) &lt;= MacroAssembler::patchableJumpSize());
 81             state.shouldSlowPathRepatch = true;
 82             state.fastPathEnd = jit.label();
 83             ASSERT(!m_generateFastPathOnRepatch); // We should have gathered some observed type info about the types before trying to regenerate again.
 84             m_generateFastPathOnRepatch = true;
 85             return true;
 86         }
 87 
 88         JITMathICInlineResult result = m_generator.generateInline(jit, state, m_arithProfile);
 89 
 90         switch (result) {
 91         case JITMathICInlineResult::GeneratedFastPath: {
 92             size_t inlineSize = jit.m_assembler.buffer().codeSize() - startSize;
 93             if (static_cast&lt;ptrdiff_t&gt;(inlineSize) &lt; MacroAssembler::patchableJumpSize()) {
 94                 size_t nopsToEmitInBytes = MacroAssembler::patchableJumpSize() - inlineSize;
 95                 jit.emitNops(nopsToEmitInBytes);
 96             }
 97             state.shouldSlowPathRepatch = true;
 98             state.fastPathEnd = jit.label();
 99             return true;
100         }
101         case JITMathICInlineResult::GenerateFullSnippet: {
102             MacroAssembler::JumpList endJumpList;
103             bool result = m_generator.generateFastPath(jit, endJumpList, state.slowPathJumps, m_arithProfile, shouldEmitProfiling);
104             if (result) {
105                 state.fastPathEnd = jit.label();
106                 state.shouldSlowPathRepatch = false;
107                 endJumpList.link(&amp;jit);
108                 return true;
109             }
110             return false;
111         }
112         case JITMathICInlineResult::DontGenerate: {
113             return false;
114         }
115         default:
116             ASSERT_NOT_REACHED();
117         }
118 
119         return false;
120     }
121 
122     void generateOutOfLine(CodeBlock* codeBlock, FunctionPtr&lt;CFunctionPtrTag&gt; callReplacement)
123     {
124         auto linkJumpToOutOfLineSnippet = [&amp;] () {
125             CCallHelpers jit(codeBlock);
126             auto jump = jit.jump();
127             // We don&#39;t need a nop sled here because nobody should be jumping into the middle of an IC.
128             bool needsBranchCompaction = false;
129             RELEASE_ASSERT(jit.m_assembler.buffer().codeSize() &lt;= static_cast&lt;size_t&gt;(MacroAssembler::differenceBetweenCodePtr(m_inlineStart, m_inlineEnd)));
130             LinkBuffer linkBuffer(jit, m_inlineStart, jit.m_assembler.buffer().codeSize(), JITCompilationMustSucceed, needsBranchCompaction);
131             RELEASE_ASSERT(linkBuffer.isValid());
132             linkBuffer.link(jump, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(m_code.code()));
133             FINALIZE_CODE(linkBuffer, NoPtrTag, &quot;JITMathIC: linking constant jump to out of line stub&quot;);
134         };
135 
136         auto replaceCall = [&amp;] () {
137 #if COMPILER(MSVC) &amp;&amp; !COMPILER(CLANG)
138             ftlThunkAwareRepatchCall(codeBlock, slowPathCallLocation().retagged&lt;JSInternalPtrTag&gt;(), callReplacement);
139 #else
140             ftlThunkAwareRepatchCall(codeBlock, slowPathCallLocation().template retagged&lt;JSInternalPtrTag&gt;(), callReplacement);
141 #endif
142         };
143 
144         bool shouldEmitProfiling = !JITCode::isOptimizingJIT(codeBlock-&gt;jitType());
145 
146         if (m_generateFastPathOnRepatch) {
147 
148             CCallHelpers jit(codeBlock);
149             MathICGenerationState generationState;
150             bool generatedInline = generateInline(jit, generationState, shouldEmitProfiling);
151 
152             // We no longer want to try to regenerate the fast path.
153             m_generateFastPathOnRepatch = false;
154 
155             if (generatedInline) {
156                 auto jumpToDone = jit.jump();
157 
158                 LinkBuffer linkBuffer(jit, codeBlock, JITCompilationCanFail);
159                 if (!linkBuffer.didFailToAllocate()) {
160                     linkBuffer.link(generationState.slowPathJumps, slowPathStartLocation());
161                     linkBuffer.link(jumpToDone, doneLocation());
162 
163                     m_code = FINALIZE_CODE_FOR(
164                         codeBlock, linkBuffer, JITStubRoutinePtrTag, &quot;JITMathIC: generating out of line fast IC snippet&quot;);
165 
166                     if (!generationState.shouldSlowPathRepatch) {
167                         // We won&#39;t need to regenerate, so we can wire the slow path call
168                         // to a non repatching variant.
169                         replaceCall();
170                     }
171 
172                     linkJumpToOutOfLineSnippet();
173 
174                     return;
175                 }
176             }
177 
178             // We weren&#39;t able to generate an out of line fast path.
179             // We just generate the snippet in its full generality.
180         }
181 
182         // We rewire to the alternate regardless of whether or not we can allocate the out of line path
183         // because if we fail allocating the out of line path, we don&#39;t want to waste time trying to
184         // allocate it in the future.
185         replaceCall();
186 
187         {
188             CCallHelpers jit(codeBlock);
189 
190             MacroAssembler::JumpList endJumpList;
191             MacroAssembler::JumpList slowPathJumpList;
192 
193             bool emittedFastPath = m_generator.generateFastPath(jit, endJumpList, slowPathJumpList, m_arithProfile, shouldEmitProfiling);
194             if (!emittedFastPath)
195                 return;
196             endJumpList.append(jit.jump());
197 
198             LinkBuffer linkBuffer(jit, codeBlock, JITCompilationCanFail);
199             if (linkBuffer.didFailToAllocate())
200                 return;
201 
202             linkBuffer.link(endJumpList, doneLocation());
203             linkBuffer.link(slowPathJumpList, slowPathStartLocation());
204 
205             m_code = FINALIZE_CODE_FOR(
206                 codeBlock, linkBuffer, JITStubRoutinePtrTag, &quot;JITMathIC: generating out of line IC snippet&quot;);
207         }
208 
209         linkJumpToOutOfLineSnippet();
210     }
211 
212     void finalizeInlineCode(const MathICGenerationState&amp; state, LinkBuffer&amp; linkBuffer)
213     {
214         CodeLocationLabel&lt;JSInternalPtrTag&gt; start = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(state.fastPathStart);
215         m_inlineStart = start;
216 
217         m_inlineEnd = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(state.fastPathEnd);
218         ASSERT(m_inlineEnd.untaggedExecutableAddress() &gt; m_inlineStart.untaggedExecutableAddress());
219 
220         m_slowPathCallLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(state.slowPathCall);
221         m_slowPathStartLocation = linkBuffer.locationOf&lt;JSInternalPtrTag&gt;(state.slowPathStart);
222     }
223 
224     ArithProfileType* arithProfile() const { return m_arithProfile; }
225 
226 #if ENABLE(MATH_IC_STATS)
227     size_t m_generatedCodeSize { 0 };
228     size_t codeSize() const
229     {
230         size_t result = m_generatedCodeSize;
231         if (m_code)
232             result += m_code.size();
233         return result;
234     }
235 #endif
236 
237     ArithProfileType* m_arithProfile;
238     MacroAssemblerCodeRef&lt;JITStubRoutinePtrTag&gt; m_code;
239     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_inlineStart;
240     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_inlineEnd;
241     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_slowPathCallLocation;
242     CodeLocationLabel&lt;JSInternalPtrTag&gt; m_slowPathStartLocation;
243     bool m_generateFastPathOnRepatch { false };
244     GeneratorType m_generator;
245 };
246 
247 template &lt;typename GeneratorType&gt;
248 class JITBinaryMathIC : public JITMathIC&lt;GeneratorType, BinaryArithProfile&gt; {
249 public:
250     JITBinaryMathIC(BinaryArithProfile* arithProfile)
251         : JITMathIC&lt;GeneratorType, BinaryArithProfile&gt;(arithProfile)
252     {
253     }
254 };
255 
256 typedef JITBinaryMathIC&lt;JITAddGenerator&gt; JITAddIC;
257 typedef JITBinaryMathIC&lt;JITMulGenerator&gt; JITMulIC;
258 typedef JITBinaryMathIC&lt;JITSubGenerator&gt; JITSubIC;
259 
260 template &lt;typename GeneratorType&gt;
261 class JITUnaryMathIC : public JITMathIC&lt;GeneratorType, UnaryArithProfile&gt; {
262 public:
263     JITUnaryMathIC(UnaryArithProfile* arithProfile)
264         : JITMathIC&lt;GeneratorType, UnaryArithProfile&gt;(arithProfile)
265     {
266     }
267 };
268 
269 typedef JITUnaryMathIC&lt;JITNegGenerator&gt; JITNegIC;
270 
271 } // namespace JSC
272 
273 #endif // ENABLE(JIT)
    </pre>
  </body>
</html>
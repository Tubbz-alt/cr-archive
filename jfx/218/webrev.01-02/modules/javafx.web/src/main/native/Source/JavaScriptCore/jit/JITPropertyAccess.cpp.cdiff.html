<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITPropertyAccess.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JITOperationsMSVC64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITPropertyAccess32_64.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/jit/JITPropertyAccess.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 35,10 ***</span>
<span class="line-new-header">--- 35,11 ---</span>
  #include &quot;InterpreterInlines.h&quot;
  #include &quot;JITInlines.h&quot;
  #include &quot;JSArray.h&quot;
  #include &quot;JSFunction.h&quot;
  #include &quot;JSLexicalEnvironment.h&quot;
<span class="line-added">+ #include &quot;JSPromise.h&quot;</span>
  #include &quot;LinkBuffer.h&quot;
  #include &quot;OpcodeInlines.h&quot;
  #include &quot;ResultType.h&quot;
  #include &quot;ScopedArguments.h&quot;
  #include &quot;ScopedArgumentsTable.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 54,148 ***</span>
  
  void JIT::emit_op_get_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int property = bytecode.m_property.offset();</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
<span class="line-removed">-     ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();</span>
  
      emitGetVirtualRegister(base, regT0);
<span class="line-modified">!     bool propertyNameIsIntegerConstant = isOperandConstantInt(property);</span>
<span class="line-removed">-     if (propertyNameIsIntegerConstant)</span>
<span class="line-removed">-         move(Imm32(getOperandConstantInt(property)), regT1);</span>
<span class="line-removed">-     else</span>
<span class="line-removed">-         emitGetVirtualRegister(property, regT1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     emitJumpSlowCaseIfNotJSCell(regT0, base);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     PatchableJump notIndex;</span>
<span class="line-removed">-     if (!propertyNameIsIntegerConstant) {</span>
<span class="line-removed">-         notIndex = emitPatchableJumpIfNotInt(regT1);</span>
<span class="line-removed">-         addSlowCase(notIndex);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         // This is technically incorrect - we&#39;re zero-extending an int32. On the hot path this doesn&#39;t matter.</span>
<span class="line-removed">-         // We check the value as if it was a uint32 against the m_vectorLength - which will always fail if</span>
<span class="line-removed">-         // number was signed since m_vectorLength is always less than intmax (since the total allocation</span>
<span class="line-removed">-         // size is always less than 4Gb). As such zero extending will have been correct (and extending the value</span>
<span class="line-removed">-         // to 64-bits is necessary since it&#39;s used in the address calculation). We zero extend rather than sign</span>
<span class="line-removed">-         // extending since it makes it easier to re-tag the value in the slow case.</span>
<span class="line-removed">-         zeroExtend32ToPtr(regT1, regT1);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     emitArrayProfilingSiteWithCell(regT0, regT2, profile);</span>
<span class="line-removed">-     and32(TrustedImm32(IndexingShapeMask), regT2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     PatchableJump badType;</span>
<span class="line-removed">-     JumpList slowCases;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JITArrayMode mode = chooseArrayMode(profile);</span>
<span class="line-removed">-     switch (mode) {</span>
<span class="line-removed">-     case JITInt32:</span>
<span class="line-removed">-         slowCases = emitInt32GetByVal(currentInstruction, badType);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case JITDouble:</span>
<span class="line-removed">-         slowCases = emitDoubleGetByVal(currentInstruction, badType);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case JITContiguous:</span>
<span class="line-removed">-         slowCases = emitContiguousGetByVal(currentInstruction, badType);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case JITArrayStorage:</span>
<span class="line-removed">-         slowCases = emitArrayStorageGetByVal(currentInstruction, badType);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-         CRASH();</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     addSlowCase(badType);</span>
<span class="line-removed">-     addSlowCase(slowCases);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Label done = label();</span>
  
<span class="line-modified">!     if (!ASSERT_DISABLED) {</span>
<span class="line-modified">!         Jump resultOK = branchIfNotEmpty(regT0);</span>
<span class="line-modified">!         abortWithReason(JITGetByValResultIsNotEmpty);</span>
<span class="line-modified">!         resultOK.link(this);</span>
      }
  
<span class="line-removed">-     emitValueProfilingSite(metadata);</span>
<span class="line-removed">-     emitPutVirtualRegister(dst);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Label nextHotPath = label();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeOffset, notIndex, badType, mode, profile, done, nextHotPath));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JITGetByIdGenerator JIT::emitGetByValWithCachedId(ByValInfo* byValInfo, OpGetByVal bytecode, const Identifier&amp; propertyName, Jump&amp; fastDoneCase, Jump&amp; slowDoneCase, JumpList&amp; slowCases)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     // base: regT0</span>
<span class="line-removed">-     // property: regT1</span>
<span class="line-removed">-     // scratch: regT3</span>
<span class="line-removed">- </span>
<span class="line-removed">-     int dst = bytecode.m_dst.offset();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     slowCases.append(branchIfNotCell(regT1));</span>
<span class="line-removed">-     emitByValIdentifierCheck(byValInfo, regT1, regT3, propertyName, slowCases);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JITGetByIdGenerator gen(</span>
<span class="line-removed">-         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(m_bytecodeOffset), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-removed">-         propertyName.impl(), JSValueRegs(regT0), JSValueRegs(regT0), AccessType::Get);</span>
<span class="line-removed">-     gen.generateFastPath(*this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     fastDoneCase = jump();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Label coldPathBegin = label();</span>
<span class="line-removed">-     gen.slowPathJump().link(this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdOptimize, dst, gen.stubInfo(), regT0, propertyName.impl());</span>
<span class="line-removed">-     gen.reportSlowPathCall(coldPathBegin, call);</span>
<span class="line-removed">-     slowDoneCase = jump();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return gen;</span>
  }
  
  void JIT::emitSlow_op_get_by_val(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
<span class="line-modified">!     auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();</span>
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int property = bytecode.m_property.offset();</span>
<span class="line-modified">!     ByValInfo* byValInfo = m_byValCompilationInfo[m_byValInstructionIndex].byValInfo;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     linkSlowCaseIfNotJSCell(iter, base); // base cell check</span>
<span class="line-modified">! </span>
<span class="line-modified">!     if (!isOperandConstantInt(property))</span>
<span class="line-modified">!         linkSlowCase(iter); // property int32 check</span>
<span class="line-modified">!     Jump nonCell = jump();</span>
<span class="line-modified">!     linkSlowCase(iter); // base array check</span>
<span class="line-modified">!     Jump notString = branchIfNotString(regT0);</span>
<span class="line-modified">!     emitNakedCall(CodeLocationLabel&lt;NoPtrTag&gt;(m_vm-&gt;getCTIStub(stringGetByValGenerator).retaggedCode&lt;NoPtrTag&gt;()));</span>
<span class="line-removed">-     Jump failed = branchTest64(Zero, regT0);</span>
<span class="line-removed">-     emitPutVirtualRegister(dst, regT0);</span>
<span class="line-removed">-     emitJumpSlowToHot(jump(), currentInstruction-&gt;size());</span>
<span class="line-removed">-     failed.link(this);</span>
<span class="line-removed">-     notString.link(this);</span>
<span class="line-removed">-     nonCell.link(this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     linkSlowCase(iter); // vector length check</span>
<span class="line-removed">-     linkSlowCase(iter); // empty value</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Label slowPath = label();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     emitGetVirtualRegister(base, regT0);</span>
<span class="line-removed">-     emitGetVirtualRegister(property, regT1);</span>
<span class="line-removed">-     Call call = callOperation(operationGetByValOptimize, dst, regT0, regT1, byValInfo);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;</span>
<span class="line-removed">-     m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;</span>
<span class="line-removed">-     m_byValInstructionIndex++;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     emitValueProfilingSite(bytecode.metadata(m_codeBlock));</span>
  }
  
  void JIT::emit_op_put_by_val_direct(const Instruction* currentInstruction)
  {
      emit_op_put_by_val&lt;OpPutByValDirect&gt;(currentInstruction);
<span class="line-new-header">--- 55,58 ---</span>
  
  void JIT::emit_op_get_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister property = bytecode.m_property;</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
  
      emitGetVirtualRegister(base, regT0);
<span class="line-modified">!     emitGetVirtualRegister(property, regT1);</span>
  
<span class="line-modified">!     if (metadata.m_seenIdentifiers.count() &gt; Options::getByValICMaxNumberOfIdentifiers()) {</span>
<span class="line-modified">!         auto notCell = branchIfNotCell(regT0);</span>
<span class="line-modified">!         emitArrayProfilingSiteWithCell(regT0, regT2, profile);</span>
<span class="line-modified">!         notCell.link(this);</span>
<span class="line-added">+         callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByVal, dst, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, regT1);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+         emitJumpSlowCaseIfNotJSCell(regT0, base);</span>
<span class="line-added">+         emitArrayProfilingSiteWithCell(regT0, regT2, profile);</span>
<span class="line-added">+ </span>
<span class="line-added">+         JITGetByValGenerator gen(</span>
<span class="line-added">+             m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-added">+             JSValueRegs(regT0), JSValueRegs(regT1), JSValueRegs(regT0));</span>
<span class="line-added">+         if (isOperandConstantInt(property))</span>
<span class="line-added">+             gen.stubInfo()-&gt;propertyIsInt32 = true;</span>
<span class="line-added">+         gen.generateFastPath(*this);</span>
<span class="line-added">+         addSlowCase(gen.slowPathJump());</span>
<span class="line-added">+         m_getByVals.append(gen);</span>
<span class="line-added">+ </span>
<span class="line-added">+         emitValueProfilingSite(bytecode.metadata(m_codeBlock));</span>
<span class="line-added">+         emitPutVirtualRegister(dst);</span>
      }
  
  }
  
  void JIT::emitSlow_op_get_by_val(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
<span class="line-modified">!     if (hasAnySlowCases(iter)) {</span>
<span class="line-modified">!         auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();</span>
<span class="line-modified">!         VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!         auto&amp; metadata = bytecode.metadata(m_codeBlock);</span>
<span class="line-modified">!         ArrayProfile* profile = &amp;metadata.m_arrayProfile;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         linkAllSlowCases(iter);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         JITGetByValGenerator&amp; gen = m_getByVals[m_getByValIndex];</span>
<span class="line-modified">!         ++m_getByValIndex;</span>
<span class="line-modified">!         Label coldPathBegin = label();</span>
<span class="line-modified">!         Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByValOptimize, dst, TrustedImmPtr(m_codeBlock-&gt;globalObject()), gen.stubInfo(), profile, regT0, regT1);</span>
<span class="line-modified">!         gen.reportSlowPathCall(coldPathBegin, call);</span>
<span class="line-modified">!     }</span>
  }
  
  void JIT::emit_op_put_by_val_direct(const Instruction* currentInstruction)
  {
      emit_op_put_by_val&lt;OpPutByValDirect&gt;(currentInstruction);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 204,12 ***</span>
  template&lt;typename Op&gt;
  void JIT::emit_op_put_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int property = bytecode.m_property.offset();</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
      ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
  
      emitGetVirtualRegister(base, regT0);
      bool propertyNameIsIntegerConstant = isOperandConstantInt(property);
<span class="line-new-header">--- 115,12 ---</span>
  template&lt;typename Op&gt;
  void JIT::emit_op_put_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister property = bytecode.m_property;</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
      ByValInfo* byValInfo = m_codeBlock-&gt;addByValInfo();
  
      emitGetVirtualRegister(base, regT0);
      bool propertyNameIsIntegerConstant = isOperandConstantInt(property);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 257,18 ***</span>
      addSlowCase(badType);
      addSlowCase(slowCases);
  
      Label done = label();
  
<span class="line-modified">!     m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeOffset, notIndex, badType, mode, profile, done, done));</span>
  }
  
  template&lt;typename Op&gt;
  JIT::JumpList JIT::emitGenericContiguousPutByVal(Op bytecode, PatchableJump&amp; badType, IndexingType indexingShape)
  {
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
  
      JumpList slowCases;
  
      badType = patchableBranch32(NotEqual, regT2, TrustedImm32(indexingShape));
<span class="line-new-header">--- 168,18 ---</span>
      addSlowCase(badType);
      addSlowCase(slowCases);
  
      Label done = label();
  
<span class="line-modified">!     m_byValCompilationInfo.append(ByValCompilationInfo(byValInfo, m_bytecodeIndex, notIndex, badType, mode, profile, done, done));</span>
  }
  
  template&lt;typename Op&gt;
  JIT::JumpList JIT::emitGenericContiguousPutByVal(Op bytecode, PatchableJump&amp; badType, IndexingType indexingShape)
  {
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
  
      JumpList slowCases;
  
      badType = patchableBranch32(NotEqual, regT2, TrustedImm32(indexingShape));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 286,20 ***</span>
      case DoubleShape: {
          Jump notInt = branchIfNotInt32(regT3);
          convertInt32ToDouble(regT3, fpRegT0);
          Jump ready = jump();
          notInt.link(this);
<span class="line-modified">!         add64(tagTypeNumberRegister, regT3);</span>
          move64ToDouble(regT3, fpRegT0);
          slowCases.append(branchIfNaN(fpRegT0));
          ready.link(this);
          storeDouble(fpRegT0, BaseIndex(regT2, regT1, TimesEight));
          break;
      }
      case ContiguousShape:
          store64(regT3, BaseIndex(regT2, regT1, TimesEight));
<span class="line-modified">!         emitWriteBarrier(bytecode.m_base.offset(), value, ShouldFilterValue);</span>
          break;
      default:
          CRASH();
          break;
      }
<span class="line-new-header">--- 197,20 ---</span>
      case DoubleShape: {
          Jump notInt = branchIfNotInt32(regT3);
          convertInt32ToDouble(regT3, fpRegT0);
          Jump ready = jump();
          notInt.link(this);
<span class="line-modified">!         add64(numberTagRegister, regT3);</span>
          move64ToDouble(regT3, fpRegT0);
          slowCases.append(branchIfNaN(fpRegT0));
          ready.link(this);
          storeDouble(fpRegT0, BaseIndex(regT2, regT1, TimesEight));
          break;
      }
      case ContiguousShape:
          store64(regT3, BaseIndex(regT2, regT1, TimesEight));
<span class="line-modified">!         emitWriteBarrier(bytecode.m_base, value, ShouldFilterValue);</span>
          break;
      default:
          CRASH();
          break;
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 322,11 ***</span>
  
  template&lt;typename Op&gt;
  JIT::JumpList JIT::emitArrayStoragePutByVal(Op bytecode, PatchableJump&amp; badType)
  {
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
  
      JumpList slowCases;
  
      badType = patchableBranch32(NotEqual, regT2, TrustedImm32(ArrayStorageShape));
<span class="line-new-header">--- 233,11 ---</span>
  
  template&lt;typename Op&gt;
  JIT::JumpList JIT::emitArrayStoragePutByVal(Op bytecode, PatchableJump&amp; badType)
  {
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
  
      JumpList slowCases;
  
      badType = patchableBranch32(NotEqual, regT2, TrustedImm32(ArrayStorageShape));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 336,11 ***</span>
      Jump empty = branchTest64(Zero, BaseIndex(regT2, regT1, TimesEight, ArrayStorage::vectorOffset()));
  
      Label storeResult(this);
      emitGetVirtualRegister(value, regT3);
      store64(regT3, BaseIndex(regT2, regT1, TimesEight, ArrayStorage::vectorOffset()));
<span class="line-modified">!     emitWriteBarrier(bytecode.m_base.offset(), value, ShouldFilterValue);</span>
      Jump end = jump();
  
      empty.link(this);
      emitArrayProfileStoreToHoleSpecialCase(profile);
      add32(TrustedImm32(1), Address(regT2, ArrayStorage::numValuesInVectorOffset()));
<span class="line-new-header">--- 247,11 ---</span>
      Jump empty = branchTest64(Zero, BaseIndex(regT2, regT1, TimesEight, ArrayStorage::vectorOffset()));
  
      Label storeResult(this);
      emitGetVirtualRegister(value, regT3);
      store64(regT3, BaseIndex(regT2, regT1, TimesEight, ArrayStorage::vectorOffset()));
<span class="line-modified">!     emitWriteBarrier(bytecode.m_base, value, ShouldFilterValue);</span>
      Jump end = jump();
  
      empty.link(this);
      emitArrayProfileStoreToHoleSpecialCase(profile);
      add32(TrustedImm32(1), Address(regT2, ArrayStorage::numValuesInVectorOffset()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 361,48 ***</span>
  {
      // base: regT0
      // property: regT1
      // scratch: regT2
  
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
  
      slowCases.append(branchIfNotCell(regT1));
      emitByValIdentifierCheck(byValInfo, regT1, regT1, propertyName, slowCases);
  
      // Write barrier breaks the registers. So after issuing the write barrier,
      // reload the registers.
      emitGetVirtualRegisters(base, regT0, value, regT1);
  
      JITPutByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(m_bytecodeOffset), RegisterSet::stubUnavailableRegisters(),</span>
          JSValueRegs(regT0), JSValueRegs(regT1), regT2, m_codeBlock-&gt;ecmaMode(), putKind);
      gen.generateFastPath(*this);
      emitWriteBarrier(base, value, ShouldFilterBase);
      doneCases.append(jump());
  
      Label coldPathBegin = label();
      gen.slowPathJump().link(this);
  
<span class="line-modified">!     Call call = callOperation(gen.slowPathFunction(), gen.stubInfo(), regT1, regT0, propertyName.impl());</span>
      gen.reportSlowPathCall(coldPathBegin, call);
      doneCases.append(jump());
  
      return gen;
  }
  
  void JIT::emitSlow_op_put_by_val(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      bool isDirect = currentInstruction-&gt;opcodeID() == op_put_by_val_direct;
<span class="line-modified">!     int base;</span>
<span class="line-modified">!     int property;</span>
<span class="line-modified">!     int value;</span>
  
      auto load = [&amp;](auto bytecode) {
<span class="line-modified">!         base = bytecode.m_base.offset();</span>
<span class="line-modified">!         property = bytecode.m_property.offset();</span>
<span class="line-modified">!         value = bytecode.m_value.offset();</span>
      };
  
      if (isDirect)
          load(currentInstruction-&gt;as&lt;OpPutByValDirect&gt;());
      else
<span class="line-new-header">--- 272,48 ---</span>
  {
      // base: regT0
      // property: regT1
      // scratch: regT2
  
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
  
      slowCases.append(branchIfNotCell(regT1));
      emitByValIdentifierCheck(byValInfo, regT1, regT1, propertyName, slowCases);
  
      // Write barrier breaks the registers. So after issuing the write barrier,
      // reload the registers.
      emitGetVirtualRegisters(base, regT0, value, regT1);
  
      JITPutByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
          JSValueRegs(regT0), JSValueRegs(regT1), regT2, m_codeBlock-&gt;ecmaMode(), putKind);
      gen.generateFastPath(*this);
      emitWriteBarrier(base, value, ShouldFilterBase);
      doneCases.append(jump());
  
      Label coldPathBegin = label();
      gen.slowPathJump().link(this);
  
<span class="line-modified">!     Call call = callOperation(gen.slowPathFunction(), TrustedImmPtr(m_codeBlock-&gt;globalObject()), gen.stubInfo(), regT1, regT0, propertyName.impl());</span>
      gen.reportSlowPathCall(coldPathBegin, call);
      doneCases.append(jump());
  
      return gen;
  }
  
  void JIT::emitSlow_op_put_by_val(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      bool isDirect = currentInstruction-&gt;opcodeID() == op_put_by_val_direct;
<span class="line-modified">!     VirtualRegister base;</span>
<span class="line-modified">!     VirtualRegister property;</span>
<span class="line-modified">!     VirtualRegister value;</span>
  
      auto load = [&amp;](auto bytecode) {
<span class="line-modified">!         base = bytecode.m_base;</span>
<span class="line-modified">!         property = bytecode.m_property;</span>
<span class="line-modified">!         value = bytecode.m_value;</span>
      };
  
      if (isDirect)
          load(currentInstruction-&gt;as&lt;OpPutByValDirect&gt;());
      else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 414,100 ***</span>
      Label slowPath = label();
  
      emitGetVirtualRegister(base, regT0);
      emitGetVirtualRegister(property, regT1);
      emitGetVirtualRegister(value, regT2);
<span class="line-modified">!     Call call = callOperation(isDirect ? operationDirectPutByValOptimize : operationPutByValOptimize, regT0, regT1, regT2, byValInfo);</span>
  
      m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;
      m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;
      m_byValInstructionIndex++;
  }
  
  void JIT::emit_op_put_getter_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterById&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_base.offset(), regT0);</span>
      int32_t options = bytecode.m_attributes;
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_accessor.offset(), regT1);</span>
<span class="line-modified">!     callOperation(operationPutGetterById, regT0, m_codeBlock-&gt;identifier(bytecode.m_property).impl(), options, regT1);</span>
  }
  
  void JIT::emit_op_put_setter_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutSetterById&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_base.offset(), regT0);</span>
      int32_t options = bytecode.m_attributes;
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_accessor.offset(), regT1);</span>
<span class="line-modified">!     callOperation(operationPutSetterById, regT0, m_codeBlock-&gt;identifier(bytecode.m_property).impl(), options, regT1);</span>
  }
  
  void JIT::emit_op_put_getter_setter_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterSetterById&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_base.offset(), regT0);</span>
      int32_t attribute = bytecode.m_attributes;
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_getter.offset(), regT1);</span>
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_setter.offset(), regT2);</span>
<span class="line-modified">!     callOperation(operationPutGetterSetter, regT0, m_codeBlock-&gt;identifier(bytecode.m_property).impl(), attribute, regT1, regT2);</span>
  }
  
  void JIT::emit_op_put_getter_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterByVal&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_base.offset(), regT0);</span>
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_property.offset(), regT1);</span>
      int32_t attributes = bytecode.m_attributes;
      emitGetVirtualRegister(bytecode.m_accessor, regT2);
<span class="line-modified">!     callOperation(operationPutGetterByVal, regT0, regT1, attributes, regT2);</span>
  }
  
  void JIT::emit_op_put_setter_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutSetterByVal&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_base.offset(), regT0);</span>
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_property.offset(), regT1);</span>
      int32_t attributes = bytecode.m_attributes;
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_accessor.offset(), regT2);</span>
<span class="line-modified">!     callOperation(operationPutSetterByVal, regT0, regT1, attributes, regT2);</span>
  }
  
  void JIT::emit_op_del_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDelById&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
      int property = bytecode.m_property;
      emitGetVirtualRegister(base, regT0);
<span class="line-modified">!     callOperation(operationDeleteByIdJSResult, dst, regT0, m_codeBlock-&gt;identifier(property).impl());</span>
  }
  
  void JIT::emit_op_del_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDelByVal&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int base = bytecode.m_base.offset();</span>
<span class="line-modified">!     int property = bytecode.m_property.offset();</span>
      emitGetVirtualRegister(base, regT0);
      emitGetVirtualRegister(property, regT1);
<span class="line-modified">!     callOperation(operationDeleteByValJSResult, dst, regT0, regT1);</span>
  }
  
  void JIT::emit_op_try_get_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpTryGetById&gt;();
<span class="line-modified">!     int resultVReg = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int baseVReg = bytecode.m_base.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitGetVirtualRegister(baseVReg, regT0);
  
      emitJumpSlowCaseIfNotJSCell(regT0, baseVReg);
  
      JITGetByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(m_bytecodeOffset), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!         ident-&gt;impl(), JSValueRegs(regT0), JSValueRegs(regT0), AccessType::TryGet);</span>
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_getByIds.append(gen);
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
<span class="line-new-header">--- 325,100 ---</span>
      Label slowPath = label();
  
      emitGetVirtualRegister(base, regT0);
      emitGetVirtualRegister(property, regT1);
      emitGetVirtualRegister(value, regT2);
<span class="line-modified">!     Call call = callOperation(isDirect ? operationDirectPutByValOptimize : operationPutByValOptimize, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, regT1, regT2, byValInfo);</span>
  
      m_byValCompilationInfo[m_byValInstructionIndex].slowPathTarget = slowPath;
      m_byValCompilationInfo[m_byValInstructionIndex].returnAddress = call;
      m_byValInstructionIndex++;
  }
  
  void JIT::emit_op_put_getter_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterById&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_base, regT0);</span>
      int32_t options = bytecode.m_attributes;
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_accessor, regT1);</span>
<span class="line-modified">!     callOperation(operationPutGetterById, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, m_codeBlock-&gt;identifier(bytecode.m_property).impl(), options, regT1);</span>
  }
  
  void JIT::emit_op_put_setter_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutSetterById&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_base, regT0);</span>
      int32_t options = bytecode.m_attributes;
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_accessor, regT1);</span>
<span class="line-modified">!     callOperation(operationPutSetterById, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, m_codeBlock-&gt;identifier(bytecode.m_property).impl(), options, regT1);</span>
  }
  
  void JIT::emit_op_put_getter_setter_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterSetterById&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_base, regT0);</span>
      int32_t attribute = bytecode.m_attributes;
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_getter, regT1);</span>
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_setter, regT2);</span>
<span class="line-modified">!     callOperation(operationPutGetterSetter, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, m_codeBlock-&gt;identifier(bytecode.m_property).impl(), attribute, regT1, regT2);</span>
  }
  
  void JIT::emit_op_put_getter_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutGetterByVal&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_base, regT0);</span>
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_property, regT1);</span>
      int32_t attributes = bytecode.m_attributes;
      emitGetVirtualRegister(bytecode.m_accessor, regT2);
<span class="line-modified">!     callOperation(operationPutGetterByVal, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, regT1, attributes, regT2);</span>
  }
  
  void JIT::emit_op_put_setter_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutSetterByVal&gt;();
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_base, regT0);</span>
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_property, regT1);</span>
      int32_t attributes = bytecode.m_attributes;
<span class="line-modified">!     emitGetVirtualRegister(bytecode.m_accessor, regT2);</span>
<span class="line-modified">!     callOperation(operationPutSetterByVal, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, regT1, attributes, regT2);</span>
  }
  
  void JIT::emit_op_del_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDelById&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
      int property = bytecode.m_property;
      emitGetVirtualRegister(base, regT0);
<span class="line-modified">!     callOperation(operationDeleteByIdJSResult, dst, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, m_codeBlock-&gt;identifier(property).impl());</span>
  }
  
  void JIT::emit_op_del_by_val(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpDelByVal&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister base = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister property = bytecode.m_property;</span>
      emitGetVirtualRegister(base, regT0);
      emitGetVirtualRegister(property, regT1);
<span class="line-modified">!     callOperation(operationDeleteByValJSResult, dst, TrustedImmPtr(m_codeBlock-&gt;globalObject()), regT0, regT1);</span>
  }
  
  void JIT::emit_op_try_get_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpTryGetById&gt;();
<span class="line-modified">!     VirtualRegister resultVReg = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister baseVReg = bytecode.m_base;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitGetVirtualRegister(baseVReg, regT0);
  
      emitJumpSlowCaseIfNotJSCell(regT0, baseVReg);
  
      JITGetByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!         ident-&gt;impl(), JSValueRegs(regT0), JSValueRegs(regT0), AccessType::TryGetById);</span>
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_getByIds.append(gen);
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 517,36 ***</span>
  void JIT::emitSlow_op_try_get_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpTryGetById&gt;();
<span class="line-modified">!     int resultVReg = bytecode.m_dst.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperation(operationTryGetByIdOptimize, resultVReg, gen.stubInfo(), regT0, ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emit_op_get_by_id_direct(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdDirect&gt;();
<span class="line-modified">!     int resultVReg = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int baseVReg = bytecode.m_base.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitGetVirtualRegister(baseVReg, regT0);
  
      emitJumpSlowCaseIfNotJSCell(regT0, baseVReg);
  
      JITGetByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(m_bytecodeOffset), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!         ident-&gt;impl(), JSValueRegs(regT0), JSValueRegs(regT0), AccessType::GetDirect);</span>
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_getByIds.append(gen);
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
<span class="line-new-header">--- 428,36 ---</span>
  void JIT::emitSlow_op_try_get_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpTryGetById&gt;();
<span class="line-modified">!     VirtualRegister resultVReg = bytecode.m_dst;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperation(operationTryGetByIdOptimize, resultVReg, TrustedImmPtr(m_codeBlock-&gt;globalObject()), gen.stubInfo(), regT0, ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emit_op_get_by_id_direct(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdDirect&gt;();
<span class="line-modified">!     VirtualRegister resultVReg = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister baseVReg = bytecode.m_base;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitGetVirtualRegister(baseVReg, regT0);
  
      emitJumpSlowCaseIfNotJSCell(regT0, baseVReg);
  
      JITGetByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!         ident-&gt;impl(), JSValueRegs(regT0), JSValueRegs(regT0), AccessType::GetByIdDirect);</span>
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_getByIds.append(gen);
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 556,28 ***</span>
  void JIT::emitSlow_op_get_by_id_direct(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdDirect&gt;();
<span class="line-modified">!     int resultVReg = bytecode.m_dst.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdDirectOptimize, resultVReg, gen.stubInfo(), regT0, ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emit_op_get_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetById&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int resultVReg = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int baseVReg = bytecode.m_base.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitGetVirtualRegister(baseVReg, regT0);
  
      emitJumpSlowCaseIfNotJSCell(regT0, baseVReg);
<span class="line-new-header">--- 467,28 ---</span>
  void JIT::emitSlow_op_get_by_id_direct(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdDirect&gt;();
<span class="line-modified">!     VirtualRegister resultVReg = bytecode.m_dst;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdDirectOptimize, resultVReg, TrustedImmPtr(m_codeBlock-&gt;globalObject()), gen.stubInfo(), regT0, ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emit_op_get_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetById&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister resultVReg = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister baseVReg = bytecode.m_base;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitGetVirtualRegister(baseVReg, regT0);
  
      emitJumpSlowCaseIfNotJSCell(regT0, baseVReg);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 587,12 ***</span>
          emitArrayProfilingSiteWithCell(regT0, regT1, &amp;metadata.m_modeMetadata.arrayLengthMode.arrayProfile);
          notArrayLengthMode.link(this);
      }
  
      JITGetByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(m_bytecodeOffset), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!         ident-&gt;impl(), JSValueRegs(regT0), JSValueRegs(regT0), AccessType::Get);</span>
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_getByIds.append(gen);
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
<span class="line-new-header">--- 498,12 ---</span>
          emitArrayProfilingSiteWithCell(regT0, regT1, &amp;metadata.m_modeMetadata.arrayLengthMode.arrayProfile);
          notArrayLengthMode.link(this);
      }
  
      JITGetByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!         ident-&gt;impl(), JSValueRegs(regT0), JSValueRegs(regT0), AccessType::GetById);</span>
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_getByIds.append(gen);
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 600,23 ***</span>
  }
  
  void JIT::emit_op_get_by_id_with_this(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdWithThis&gt;();
<span class="line-modified">!     int resultVReg = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int baseVReg = bytecode.m_base.offset();</span>
<span class="line-modified">!     int thisVReg = bytecode.m_thisValue.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitGetVirtualRegister(baseVReg, regT0);
      emitGetVirtualRegister(thisVReg, regT1);
      emitJumpSlowCaseIfNotJSCell(regT0, baseVReg);
      emitJumpSlowCaseIfNotJSCell(regT1, thisVReg);
  
      JITGetByIdWithThisGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(m_bytecodeOffset), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!         ident-&gt;impl(), JSValueRegs(regT0), JSValueRegs(regT0), JSValueRegs(regT1), AccessType::GetWithThis);</span>
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_getByIdsWithThis.append(gen);
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
<span class="line-new-header">--- 511,23 ---</span>
  }
  
  void JIT::emit_op_get_by_id_with_this(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdWithThis&gt;();
<span class="line-modified">!     VirtualRegister resultVReg = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister baseVReg = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister thisVReg = bytecode.m_thisValue;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitGetVirtualRegister(baseVReg, regT0);
      emitGetVirtualRegister(thisVReg, regT1);
      emitJumpSlowCaseIfNotJSCell(regT0, baseVReg);
      emitJumpSlowCaseIfNotJSCell(regT1, thisVReg);
  
      JITGetByIdWithThisGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
<span class="line-modified">!         ident-&gt;impl(), JSValueRegs(regT0), JSValueRegs(regT0), JSValueRegs(regT1));</span>
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_getByIdsWithThis.append(gen);
  
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 626,44 ***</span>
  void JIT::emitSlow_op_get_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpGetById&gt;();
<span class="line-modified">!     int resultVReg = bytecode.m_dst.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdOptimize, resultVReg, gen.stubInfo(), regT0, ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emitSlow_op_get_by_id_with_this(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdWithThis&gt;();
<span class="line-modified">!     int resultVReg = bytecode.m_dst.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITGetByIdWithThisGenerator&amp; gen = m_getByIdsWithThis[m_getByIdWithThisIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdWithThisOptimize, resultVReg, gen.stubInfo(), regT0, regT1, ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emit_op_put_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutById&gt;();
<span class="line-modified">!     int baseVReg = bytecode.m_base.offset();</span>
<span class="line-modified">!     int valueVReg = bytecode.m_value.offset();</span>
      bool direct = !!(bytecode.m_flags &amp; PutByIdIsDirect);
  
      // In order to be able to patch both the Structure, and the object offset, we store one pointer,
      // to just after the arguments have been loaded into registers &#39;hotPathBegin&#39;, and we generate code
      // such that the Structure &amp; offset are always at the same distance from this.
<span class="line-new-header">--- 537,44 ---</span>
  void JIT::emitSlow_op_get_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpGetById&gt;();
<span class="line-modified">!     VirtualRegister resultVReg = bytecode.m_dst;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITGetByIdGenerator&amp; gen = m_getByIds[m_getByIdIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdOptimize, resultVReg, TrustedImmPtr(m_codeBlock-&gt;globalObject()), gen.stubInfo(), regT0, ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emitSlow_op_get_by_id_with_this(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpGetByIdWithThis&gt;();
<span class="line-modified">!     VirtualRegister resultVReg = bytecode.m_dst;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITGetByIdWithThisGenerator&amp; gen = m_getByIdsWithThis[m_getByIdWithThisIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetByIdWithThisOptimize, resultVReg, TrustedImmPtr(m_codeBlock-&gt;globalObject()), gen.stubInfo(), regT0, regT1, ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emit_op_put_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutById&gt;();
<span class="line-modified">!     VirtualRegister baseVReg = bytecode.m_base;</span>
<span class="line-modified">!     VirtualRegister valueVReg = bytecode.m_value;</span>
      bool direct = !!(bytecode.m_flags &amp; PutByIdIsDirect);
  
      // In order to be able to patch both the Structure, and the object offset, we store one pointer,
      // to just after the arguments have been loaded into registers &#39;hotPathBegin&#39;, and we generate code
      // such that the Structure &amp; offset are always at the same distance from this.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 671,11 ***</span>
      emitGetVirtualRegisters(baseVReg, regT0, valueVReg, regT1);
  
      emitJumpSlowCaseIfNotJSCell(regT0, baseVReg);
  
      JITPutByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(m_bytecodeOffset), RegisterSet::stubUnavailableRegisters(),</span>
          JSValueRegs(regT0), JSValueRegs(regT1), regT2, m_codeBlock-&gt;ecmaMode(),
          direct ? Direct : NotDirect);
  
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
<span class="line-new-header">--- 582,11 ---</span>
      emitGetVirtualRegisters(baseVReg, regT0, valueVReg, regT1);
  
      emitJumpSlowCaseIfNotJSCell(regT0, baseVReg);
  
      JITPutByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
          JSValueRegs(regT0), JSValueRegs(regT1), regT2, m_codeBlock-&gt;ecmaMode(),
          direct ? Direct : NotDirect);
  
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 694,28 ***</span>
  
      Label coldPathBegin(this);
  
      JITPutByIdGenerator&amp; gen = m_putByIds[m_putByIdIndex++];
  
<span class="line-modified">!     Call call = callOperation(gen.slowPathFunction(), gen.stubInfo(), regT1, regT0, ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emit_op_in_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpInById&gt;();
<span class="line-modified">!     int resultVReg = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int baseVReg = bytecode.m_base.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitGetVirtualRegister(baseVReg, regT0);
  
      emitJumpSlowCaseIfNotJSCell(regT0, baseVReg);
  
      JITInByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeOffset), CallSiteIndex(m_bytecodeOffset), RegisterSet::stubUnavailableRegisters(),</span>
          ident-&gt;impl(), JSValueRegs(regT0), JSValueRegs(regT0));
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_inByIds.append(gen);
  
<span class="line-new-header">--- 605,28 ---</span>
  
      Label coldPathBegin(this);
  
      JITPutByIdGenerator&amp; gen = m_putByIds[m_putByIdIndex++];
  
<span class="line-modified">!     Call call = callOperation(gen.slowPathFunction(), TrustedImmPtr(m_codeBlock-&gt;globalObject()), gen.stubInfo(), regT1, regT0, ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emit_op_in_by_id(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpInById&gt;();
<span class="line-modified">!     VirtualRegister resultVReg = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister baseVReg = bytecode.m_base;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      emitGetVirtualRegister(baseVReg, regT0);
  
      emitJumpSlowCaseIfNotJSCell(regT0, baseVReg);
  
      JITInByIdGenerator gen(
<span class="line-modified">!         m_codeBlock, CodeOrigin(m_bytecodeIndex), CallSiteIndex(m_bytecodeIndex), RegisterSet::stubUnavailableRegisters(),</span>
          ident-&gt;impl(), JSValueRegs(regT0), JSValueRegs(regT0));
      gen.generateFastPath(*this);
      addSlowCase(gen.slowPathJump());
      m_inByIds.append(gen);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 725,18 ***</span>
  void JIT::emitSlow_op_in_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpInById&gt;();
<span class="line-modified">!     int resultVReg = bytecode.m_dst.offset();</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITInByIdGenerator&amp; gen = m_inByIds[m_inByIdIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperation(operationInByIdOptimize, resultVReg, gen.stubInfo(), regT0, ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emitVarInjectionCheck(bool needsVarInjectionChecks)
<span class="line-new-header">--- 636,18 ---</span>
  void JIT::emitSlow_op_in_by_id(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpInById&gt;();
<span class="line-modified">!     VirtualRegister resultVReg = bytecode.m_dst;</span>
      const Identifier* ident = &amp;(m_codeBlock-&gt;identifier(bytecode.m_property));
  
      JITInByIdGenerator&amp; gen = m_inByIds[m_inByIdIndex++];
  
      Label coldPathBegin = label();
  
<span class="line-modified">!     Call call = callOperation(operationInByIdOptimize, resultVReg, TrustedImmPtr(m_codeBlock-&gt;globalObject()), gen.stubInfo(), regT0, ident-&gt;impl());</span>
  
      gen.reportSlowPathCall(coldPathBegin, call);
  }
  
  void JIT::emitVarInjectionCheck(bool needsVarInjectionChecks)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 744,11 ***</span>
      if (!needsVarInjectionChecks)
          return;
      addSlowCase(branch8(Equal, AbsoluteAddress(m_codeBlock-&gt;globalObject()-&gt;varInjectionWatchpoint()-&gt;addressOfState()), TrustedImm32(IsInvalidated)));
  }
  
<span class="line-modified">! void JIT::emitResolveClosure(int dst, int scope, bool needsVarInjectionChecks, unsigned depth)</span>
  {
      emitVarInjectionCheck(needsVarInjectionChecks);
      emitGetVirtualRegister(scope, regT0);
      for (unsigned i = 0; i &lt; depth; ++i)
          loadPtr(Address(regT0, JSScope::offsetOfNext()), regT0);
<span class="line-new-header">--- 655,11 ---</span>
      if (!needsVarInjectionChecks)
          return;
      addSlowCase(branch8(Equal, AbsoluteAddress(m_codeBlock-&gt;globalObject()-&gt;varInjectionWatchpoint()-&gt;addressOfState()), TrustedImm32(IsInvalidated)));
  }
  
<span class="line-modified">! void JIT::emitResolveClosure(VirtualRegister dst, VirtualRegister scope, bool needsVarInjectionChecks, unsigned depth)</span>
  {
      emitVarInjectionCheck(needsVarInjectionChecks);
      emitGetVirtualRegister(scope, regT0);
      for (unsigned i = 0; i &lt; depth; ++i)
          loadPtr(Address(regT0, JSScope::offsetOfNext()), regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 757,12 ***</span>
  
  void JIT::emit_op_resolve_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpResolveScope&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int scope = bytecode.m_scope.offset();</span>
      ResolveType resolveType = metadata.m_resolveType;
      unsigned depth = metadata.m_localScopeDepth;
  
      auto emitCode = [&amp;] (ResolveType resolveType) {
          switch (resolveType) {
<span class="line-new-header">--- 668,12 ---</span>
  
  void JIT::emit_op_resolve_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpResolveScope&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister scope = bytecode.m_scope;</span>
      ResolveType resolveType = metadata.m_resolveType;
      unsigned depth = metadata.m_localScopeDepth;
  
      auto emitCode = [&amp;] (ResolveType resolveType) {
          switch (resolveType) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 857,11 ***</span>
          emitCode(resolveType);
          break;
      }
  }
  
<span class="line-modified">! void JIT::emitLoadWithStructureCheck(int scope, Structure** structureSlot)</span>
  {
      loadPtr(structureSlot, regT1);
      emitGetVirtualRegister(scope, regT0);
      addSlowCase(branchTestPtr(Zero, regT1));
      load32(Address(regT1, Structure::structureIDOffset()), regT1);
<span class="line-new-header">--- 768,11 ---</span>
          emitCode(resolveType);
          break;
      }
  }
  
<span class="line-modified">! void JIT::emitLoadWithStructureCheck(VirtualRegister scope, Structure** structureSlot)</span>
  {
      loadPtr(structureSlot, regT1);
      emitGetVirtualRegister(scope, regT0);
      addSlowCase(branchTestPtr(Zero, regT1));
      load32(Address(regT1, Structure::structureIDOffset()), regT1);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 877,22 ***</span>
  {
      loadPtr(operand, reg);
      loadPtr(reg, reg);
  }
  
<span class="line-modified">! void JIT::emitGetClosureVar(int scope, uintptr_t operand)</span>
  {
      emitGetVirtualRegister(scope, regT0);
      loadPtr(Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register)), regT0);
  }
  
  void JIT::emit_op_get_from_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetFromScope&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int scope = bytecode.m_scope.offset();</span>
      ResolveType resolveType = metadata.m_getPutInfo.resolveType();
      Structure** structureSlot = metadata.m_structure.slot();
      uintptr_t* operandSlot = reinterpret_cast&lt;uintptr_t*&gt;(&amp;metadata.m_operand);
  
      auto emitCode = [&amp;] (ResolveType resolveType, bool indirectLoadForOperand) {
<span class="line-new-header">--- 788,22 ---</span>
  {
      loadPtr(operand, reg);
      loadPtr(reg, reg);
  }
  
<span class="line-modified">! void JIT::emitGetClosureVar(VirtualRegister scope, uintptr_t operand)</span>
  {
      emitGetVirtualRegister(scope, regT0);
      loadPtr(Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register)), regT0);
  }
  
  void JIT::emit_op_get_from_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetFromScope&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister scope = bytecode.m_scope;</span>
      ResolveType resolveType = metadata.m_getPutInfo.resolveType();
      Structure** structureSlot = metadata.m_structure.slot();
      uintptr_t* operandSlot = reinterpret_cast&lt;uintptr_t*&gt;(&amp;metadata.m_operand);
  
      auto emitCode = [&amp;] (ResolveType resolveType, bool indirectLoadForOperand) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 908,11 ***</span>
              jitAssert(scopedLambda&lt;Jump(void)&gt;([&amp;] () -&gt; Jump {
                  return branchPtr(Equal, base, TrustedImmPtr(m_codeBlock-&gt;globalObject()));
              }));
  
              load32(operandSlot, offset);
<span class="line-modified">!             if (!ASSERT_DISABLED) {</span>
                  Jump isOutOfLine = branch32(GreaterThanOrEqual, offset, TrustedImm32(firstOutOfLineOffset));
                  abortWithReason(JITOffsetIsNotOutOfLine);
                  isOutOfLine.link(this);
              }
              loadPtr(Address(base, JSObject::butterflyOffset()), scratch);
<span class="line-new-header">--- 819,11 ---</span>
              jitAssert(scopedLambda&lt;Jump(void)&gt;([&amp;] () -&gt; Jump {
                  return branchPtr(Equal, base, TrustedImmPtr(m_codeBlock-&gt;globalObject()));
              }));
  
              load32(operandSlot, offset);
<span class="line-modified">!             if (ASSERT_ENABLED) {</span>
                  Jump isOutOfLine = branch32(GreaterThanOrEqual, offset, TrustedImm32(firstOutOfLineOffset));
                  abortWithReason(JITOffsetIsNotOutOfLine);
                  isOutOfLine.link(this);
              }
              loadPtr(Address(base, JSObject::butterflyOffset()), scratch);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1006,30 ***</span>
  void JIT::emitSlow_op_get_from_scope(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpGetFromScope&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetFromScope, dst, currentInstruction);</span>
  }
  
<span class="line-modified">! void JIT::emitPutGlobalVariable(JSValue* operand, int value, WatchpointSet* set)</span>
  {
      emitGetVirtualRegister(value, regT0);
      emitNotifyWrite(set);
      storePtr(regT0, operand);
  }
<span class="line-modified">! void JIT::emitPutGlobalVariableIndirect(JSValue** addressOfOperand, int value, WatchpointSet** indirectWatchpointSet)</span>
  {
      emitGetVirtualRegister(value, regT0);
      loadPtr(indirectWatchpointSet, regT1);
      emitNotifyWrite(regT1);
      loadPtr(addressOfOperand, regT1);
      storePtr(regT0, regT1);
  }
  
<span class="line-modified">! void JIT::emitPutClosureVar(int scope, uintptr_t operand, int value, WatchpointSet* set)</span>
  {
      emitGetVirtualRegister(value, regT1);
      emitGetVirtualRegister(scope, regT0);
      emitNotifyWrite(set);
      storePtr(regT1, Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register)));
<span class="line-new-header">--- 917,30 ---</span>
  void JIT::emitSlow_op_get_from_scope(const Instruction* currentInstruction, Vector&lt;SlowCaseEntry&gt;::iterator&amp; iter)
  {
      linkAllSlowCases(iter);
  
      auto bytecode = currentInstruction-&gt;as&lt;OpGetFromScope&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     callOperationWithProfile(bytecode.metadata(m_codeBlock), operationGetFromScope, dst, TrustedImmPtr(m_codeBlock-&gt;globalObject()), currentInstruction);</span>
  }
  
<span class="line-modified">! void JIT::emitPutGlobalVariable(JSValue* operand, VirtualRegister value, WatchpointSet* set)</span>
  {
      emitGetVirtualRegister(value, regT0);
      emitNotifyWrite(set);
      storePtr(regT0, operand);
  }
<span class="line-modified">! void JIT::emitPutGlobalVariableIndirect(JSValue** addressOfOperand, VirtualRegister value, WatchpointSet** indirectWatchpointSet)</span>
  {
      emitGetVirtualRegister(value, regT0);
      loadPtr(indirectWatchpointSet, regT1);
      emitNotifyWrite(regT1);
      loadPtr(addressOfOperand, regT1);
      storePtr(regT0, regT1);
  }
  
<span class="line-modified">! void JIT::emitPutClosureVar(VirtualRegister scope, uintptr_t operand, VirtualRegister value, WatchpointSet* set)</span>
  {
      emitGetVirtualRegister(value, regT1);
      emitGetVirtualRegister(scope, regT0);
      emitNotifyWrite(set);
      storePtr(regT1, Address(regT0, JSLexicalEnvironment::offsetOfVariables() + operand * sizeof(Register)));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1037,12 ***</span>
  
  void JIT::emit_op_put_to_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutToScope&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     int scope = bytecode.m_scope.offset();</span>
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
      GetPutInfo getPutInfo = copiedGetPutInfo(bytecode);
      ResolveType resolveType = getPutInfo.resolveType();
      Structure** structureSlot = metadata.m_structure.slot();
      uintptr_t* operandSlot = reinterpret_cast&lt;uintptr_t*&gt;(&amp;metadata.m_operand);
  
<span class="line-new-header">--- 948,12 ---</span>
  
  void JIT::emit_op_put_to_scope(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutToScope&gt;();
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
<span class="line-modified">!     VirtualRegister scope = bytecode.m_scope;</span>
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
      GetPutInfo getPutInfo = copiedGetPutInfo(bytecode);
      ResolveType resolveType = getPutInfo.resolveType();
      Structure** structureSlot = metadata.m_structure.slot();
      uintptr_t* operandSlot = reinterpret_cast&lt;uintptr_t*&gt;(&amp;metadata.m_operand);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1167,18 ***</span>
      ResolveType resolveType = copiedGetPutInfo(bytecode).resolveType();
      if (resolveType == ModuleVar) {
          JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_throw_strict_mode_readonly_property_write_error);
          slowPathCall.call();
      } else
<span class="line-modified">!         callOperation(operationPutToScope, currentInstruction);</span>
  }
  
  void JIT::emit_op_get_from_arguments(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetFromArguments&gt;();
<span class="line-modified">!     int dst = bytecode.m_dst.offset();</span>
<span class="line-modified">!     int arguments = bytecode.m_arguments.offset();</span>
      int index = bytecode.m_index;
  
      emitGetVirtualRegister(arguments, regT0);
      load64(Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;)), regT0);
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
<span class="line-new-header">--- 1078,18 ---</span>
      ResolveType resolveType = copiedGetPutInfo(bytecode).resolveType();
      if (resolveType == ModuleVar) {
          JITSlowPathCall slowPathCall(this, currentInstruction, slow_path_throw_strict_mode_readonly_property_write_error);
          slowPathCall.call();
      } else
<span class="line-modified">!         callOperation(operationPutToScope, TrustedImmPtr(m_codeBlock-&gt;globalObject()), currentInstruction);</span>
  }
  
  void JIT::emit_op_get_from_arguments(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpGetFromArguments&gt;();
<span class="line-modified">!     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-modified">!     VirtualRegister arguments = bytecode.m_arguments;</span>
      int index = bytecode.m_index;
  
      emitGetVirtualRegister(arguments, regT0);
      load64(Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;)), regT0);
      emitValueProfilingSite(bytecode.metadata(m_codeBlock));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1186,22 ***</span>
  }
  
  void JIT::emit_op_put_to_arguments(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutToArguments&gt;();
<span class="line-modified">!     int arguments = bytecode.m_arguments.offset();</span>
      int index = bytecode.m_index;
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
  
      emitGetVirtualRegister(arguments, regT0);
      emitGetVirtualRegister(value, regT1);
      store64(regT1, Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;)));
  
      emitWriteBarrier(arguments, value, ShouldFilterValue);
  }
  
<span class="line-modified">! void JIT::emitWriteBarrier(unsigned owner, unsigned value, WriteBarrierMode mode)</span>
  {
      Jump valueNotCell;
      if (mode == ShouldFilterValue || mode == ShouldFilterBaseAndValue) {
          emitGetVirtualRegister(value, regT0);
          valueNotCell = branchIfNotCell(regT0);
<span class="line-new-header">--- 1097,22 ---</span>
  }
  
  void JIT::emit_op_put_to_arguments(const Instruction* currentInstruction)
  {
      auto bytecode = currentInstruction-&gt;as&lt;OpPutToArguments&gt;();
<span class="line-modified">!     VirtualRegister arguments = bytecode.m_arguments;</span>
      int index = bytecode.m_index;
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
  
      emitGetVirtualRegister(arguments, regT0);
      emitGetVirtualRegister(value, regT1);
      store64(regT1, Address(regT0, DirectArguments::storageOffset() + index * sizeof(WriteBarrier&lt;Unknown&gt;)));
  
      emitWriteBarrier(arguments, value, ShouldFilterValue);
  }
  
<span class="line-modified">! void JIT::emitWriteBarrier(VirtualRegister owner, VirtualRegister value, WriteBarrierMode mode)</span>
  {
      Jump valueNotCell;
      if (mode == ShouldFilterValue || mode == ShouldFilterBaseAndValue) {
          emitGetVirtualRegister(value, regT0);
          valueNotCell = branchIfNotCell(regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1211,20 ***</span>
      Jump ownerNotCell;
      if (mode == ShouldFilterBaseAndValue || mode == ShouldFilterBase)
          ownerNotCell = branchIfNotCell(regT0);
  
      Jump ownerIsRememberedOrInEden = barrierBranch(vm(), regT0, regT1);
<span class="line-modified">!     callOperation(operationWriteBarrierSlowPath, regT0);</span>
      ownerIsRememberedOrInEden.link(this);
  
      if (mode == ShouldFilterBaseAndValue || mode == ShouldFilterBase)
          ownerNotCell.link(this);
      if (mode == ShouldFilterValue || mode == ShouldFilterBaseAndValue)
          valueNotCell.link(this);
  }
  
<span class="line-modified">! void JIT::emitWriteBarrier(JSCell* owner, unsigned value, WriteBarrierMode mode)</span>
  {
      emitGetVirtualRegister(value, regT0);
      Jump valueNotCell;
      if (mode == ShouldFilterValue)
          valueNotCell = branchIfNotCell(regT0);
<span class="line-new-header">--- 1122,20 ---</span>
      Jump ownerNotCell;
      if (mode == ShouldFilterBaseAndValue || mode == ShouldFilterBase)
          ownerNotCell = branchIfNotCell(regT0);
  
      Jump ownerIsRememberedOrInEden = barrierBranch(vm(), regT0, regT1);
<span class="line-modified">!     callOperation(operationWriteBarrierSlowPath, &amp;vm(), regT0);</span>
      ownerIsRememberedOrInEden.link(this);
  
      if (mode == ShouldFilterBaseAndValue || mode == ShouldFilterBase)
          ownerNotCell.link(this);
      if (mode == ShouldFilterValue || mode == ShouldFilterBaseAndValue)
          valueNotCell.link(this);
  }
  
<span class="line-modified">! void JIT::emitWriteBarrier(JSCell* owner, VirtualRegister value, WriteBarrierMode mode)</span>
  {
      emitGetVirtualRegister(value, regT0);
      Jump valueNotCell;
      if (mode == ShouldFilterValue)
          valueNotCell = branchIfNotCell(regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1233,13 ***</span>
  
      if (mode == ShouldFilterValue)
          valueNotCell.link(this);
  }
  
  #else // USE(JSVALUE64)
  
<span class="line-modified">! void JIT::emitWriteBarrier(unsigned owner, unsigned value, WriteBarrierMode mode)</span>
  {
      Jump valueNotCell;
      if (mode == ShouldFilterValue || mode == ShouldFilterBaseAndValue) {
          emitLoadTag(value, regT0);
          valueNotCell = branchIfNotCell(regT0);
<span class="line-new-header">--- 1144,41 ---</span>
  
      if (mode == ShouldFilterValue)
          valueNotCell.link(this);
  }
  
<span class="line-added">+ void JIT::emit_op_get_internal_field(const Instruction* currentInstruction)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto bytecode = currentInstruction-&gt;as&lt;OpGetInternalField&gt;();</span>
<span class="line-added">+     auto&amp; metadata = bytecode.metadata(m_codeBlock);</span>
<span class="line-added">+     VirtualRegister dst = bytecode.m_dst;</span>
<span class="line-added">+     VirtualRegister base = bytecode.m_base;</span>
<span class="line-added">+     unsigned index = bytecode.m_index;</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitGetVirtualRegister(base, regT1);</span>
<span class="line-added">+     loadPtr(Address(regT1, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index)), regT0);</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitValueProfilingSite(metadata);</span>
<span class="line-added">+     emitPutVirtualRegister(dst);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void JIT::emit_op_put_internal_field(const Instruction* currentInstruction)</span>
<span class="line-added">+ {</span>
<span class="line-added">+     auto bytecode = currentInstruction-&gt;as&lt;OpPutInternalField&gt;();</span>
<span class="line-added">+     VirtualRegister base = bytecode.m_base;</span>
<span class="line-added">+     VirtualRegister value = bytecode.m_value;</span>
<span class="line-added">+     unsigned index = bytecode.m_index;</span>
<span class="line-added">+ </span>
<span class="line-added">+     emitGetVirtualRegister(base, regT0);</span>
<span class="line-added">+     emitGetVirtualRegister(value, regT1);</span>
<span class="line-added">+     storePtr(regT1, Address(regT0, JSInternalFieldObjectImpl&lt;&gt;::offsetOfInternalField(index)));</span>
<span class="line-added">+     emitWriteBarrier(base, value, ShouldFilterValue);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  #else // USE(JSVALUE64)
  
<span class="line-modified">! void JIT::emitWriteBarrier(VirtualRegister owner, VirtualRegister value, WriteBarrierMode mode)</span>
  {
      Jump valueNotCell;
      if (mode == ShouldFilterValue || mode == ShouldFilterBaseAndValue) {
          emitLoadTag(value, regT0);
          valueNotCell = branchIfNotCell(regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1249,20 ***</span>
      Jump ownerNotCell;
      if (mode == ShouldFilterBase || mode == ShouldFilterBaseAndValue)
          ownerNotCell = branchIfNotCell(regT0);
  
      Jump ownerIsRememberedOrInEden = barrierBranch(vm(), regT1, regT2);
<span class="line-modified">!     callOperation(operationWriteBarrierSlowPath, regT1);</span>
      ownerIsRememberedOrInEden.link(this);
  
      if (mode == ShouldFilterBase || mode == ShouldFilterBaseAndValue)
          ownerNotCell.link(this);
      if (mode == ShouldFilterValue || mode == ShouldFilterBaseAndValue)
          valueNotCell.link(this);
  }
  
<span class="line-modified">! void JIT::emitWriteBarrier(JSCell* owner, unsigned value, WriteBarrierMode mode)</span>
  {
      Jump valueNotCell;
      if (mode == ShouldFilterValue) {
          emitLoadTag(value, regT0);
          valueNotCell = branchIfNotCell(regT0);
<span class="line-new-header">--- 1188,20 ---</span>
      Jump ownerNotCell;
      if (mode == ShouldFilterBase || mode == ShouldFilterBaseAndValue)
          ownerNotCell = branchIfNotCell(regT0);
  
      Jump ownerIsRememberedOrInEden = barrierBranch(vm(), regT1, regT2);
<span class="line-modified">!     callOperation(operationWriteBarrierSlowPath, &amp;vm(), regT1);</span>
      ownerIsRememberedOrInEden.link(this);
  
      if (mode == ShouldFilterBase || mode == ShouldFilterBaseAndValue)
          ownerNotCell.link(this);
      if (mode == ShouldFilterValue || mode == ShouldFilterBaseAndValue)
          valueNotCell.link(this);
  }
  
<span class="line-modified">! void JIT::emitWriteBarrier(JSCell* owner, VirtualRegister value, WriteBarrierMode mode)</span>
  {
      Jump valueNotCell;
      if (mode == ShouldFilterValue) {
          emitLoadTag(value, regT0);
          valueNotCell = branchIfNotCell(regT0);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1277,11 ***</span>
  #endif // USE(JSVALUE64)
  
  void JIT::emitWriteBarrier(JSCell* owner)
  {
      Jump ownerIsRememberedOrInEden = barrierBranch(vm(), owner, regT0);
<span class="line-modified">!     callOperation(operationWriteBarrierSlowPath, owner);</span>
      ownerIsRememberedOrInEden.link(this);
  }
  
  void JIT::emitByValIdentifierCheck(ByValInfo* byValInfo, RegisterID cell, RegisterID scratch, const Identifier&amp; propertyName, JumpList&amp; slowCases)
  {
<span class="line-new-header">--- 1216,11 ---</span>
  #endif // USE(JSVALUE64)
  
  void JIT::emitWriteBarrier(JSCell* owner)
  {
      Jump ownerIsRememberedOrInEden = barrierBranch(vm(), owner, regT0);
<span class="line-modified">!     callOperation(operationWriteBarrierSlowPath, &amp;vm(), owner);</span>
      ownerIsRememberedOrInEden.link(this);
  }
  
  void JIT::emitByValIdentifierCheck(ByValInfo* byValInfo, RegisterID cell, RegisterID scratch, const Identifier&amp; propertyName, JumpList&amp; slowCases)
  {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1292,96 ***</span>
          loadPtr(Address(cell, JSString::offsetOfValue()), scratch);
          slowCases.append(branchPtr(NotEqual, scratch, TrustedImmPtr(propertyName.impl())));
      }
  }
  
<span class="line-removed">- void JIT::privateCompileGetByVal(const ConcurrentJSLocker&amp;, ByValInfo* byValInfo, ReturnAddressPtr returnAddress, JITArrayMode arrayMode)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     const Instruction* currentInstruction = m_codeBlock-&gt;instructions().at(byValInfo-&gt;bytecodeIndex).ptr();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     PatchableJump badType;</span>
<span class="line-removed">-     JumpList slowCases;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     switch (arrayMode) {</span>
<span class="line-removed">-     case JITInt32:</span>
<span class="line-removed">-         slowCases = emitInt32GetByVal(currentInstruction, badType);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case JITDouble:</span>
<span class="line-removed">-         slowCases = emitDoubleGetByVal(currentInstruction, badType);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case JITContiguous:</span>
<span class="line-removed">-         slowCases = emitContiguousGetByVal(currentInstruction, badType);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case JITArrayStorage:</span>
<span class="line-removed">-         slowCases = emitArrayStorageGetByVal(currentInstruction, badType);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case JITDirectArguments:</span>
<span class="line-removed">-         slowCases = emitDirectArgumentsGetByVal(currentInstruction, badType);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case JITScopedArguments:</span>
<span class="line-removed">-         slowCases = emitScopedArgumentsGetByVal(currentInstruction, badType);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-         TypedArrayType type = typedArrayTypeForJITArrayMode(arrayMode);</span>
<span class="line-removed">-         if (isInt(type))</span>
<span class="line-removed">-             slowCases = emitIntTypedArrayGetByVal(currentInstruction, badType, type);</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             slowCases = emitFloatTypedArrayGetByVal(currentInstruction, badType, type);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Jump done = jump();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     LinkBuffer patchBuffer(*this, m_codeBlock);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     patchBuffer.link(badType, byValInfo-&gt;slowPathTarget);</span>
<span class="line-removed">-     patchBuffer.link(slowCases, byValInfo-&gt;slowPathTarget);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     patchBuffer.link(done, byValInfo-&gt;badTypeDoneTarget);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     byValInfo-&gt;stubRoutine = FINALIZE_CODE_FOR_STUB(</span>
<span class="line-removed">-         m_codeBlock, patchBuffer, JITStubRoutinePtrTag,</span>
<span class="line-removed">-         &quot;Baseline get_by_val stub for %s, return point %p&quot;, toCString(*m_codeBlock).data(), returnAddress.value());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     MacroAssembler::repatchJump(byValInfo-&gt;badTypeJump, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(byValInfo-&gt;stubRoutine-&gt;code().code()));</span>
<span class="line-removed">-     MacroAssembler::repatchCall(CodeLocationCall&lt;NoPtrTag&gt;(MacroAssemblerCodePtr&lt;NoPtrTag&gt;(returnAddress)), FunctionPtr&lt;OperationPtrTag&gt;(operationGetByValGeneric));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void JIT::privateCompileGetByValWithCachedId(ByValInfo* byValInfo, ReturnAddressPtr returnAddress, const Identifier&amp; propertyName)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     const Instruction* currentInstruction = m_codeBlock-&gt;instructions().at(byValInfo-&gt;bytecodeIndex).ptr();</span>
<span class="line-removed">-     auto bytecode = currentInstruction-&gt;as&lt;OpGetByVal&gt;();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Jump fastDoneCase;</span>
<span class="line-removed">-     Jump slowDoneCase;</span>
<span class="line-removed">-     JumpList slowCases;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JITGetByIdGenerator gen = emitGetByValWithCachedId(byValInfo, bytecode, propertyName, fastDoneCase, slowDoneCase, slowCases);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     ConcurrentJSLocker locker(m_codeBlock-&gt;m_lock);</span>
<span class="line-removed">-     LinkBuffer patchBuffer(*this, m_codeBlock);</span>
<span class="line-removed">-     patchBuffer.link(slowCases, byValInfo-&gt;slowPathTarget);</span>
<span class="line-removed">-     patchBuffer.link(fastDoneCase, byValInfo-&gt;badTypeDoneTarget);</span>
<span class="line-removed">-     patchBuffer.link(slowDoneCase, byValInfo-&gt;badTypeNextHotPathTarget);</span>
<span class="line-removed">-     if (!m_exceptionChecks.empty())</span>
<span class="line-removed">-         patchBuffer.link(m_exceptionChecks, byValInfo-&gt;exceptionHandler);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     for (const auto&amp; callSite : m_calls) {</span>
<span class="line-removed">-         if (callSite.callee)</span>
<span class="line-removed">-             patchBuffer.link(callSite.from, callSite.callee);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     gen.finalize(patchBuffer, patchBuffer);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     byValInfo-&gt;stubRoutine = FINALIZE_CODE_FOR_STUB(</span>
<span class="line-removed">-         m_codeBlock, patchBuffer, JITStubRoutinePtrTag,</span>
<span class="line-removed">-         &quot;Baseline get_by_val with cached property name &#39;%s&#39; stub for %s, return point %p&quot;, propertyName.impl()-&gt;utf8().data(), toCString(*m_codeBlock).data(), returnAddress.value());</span>
<span class="line-removed">-     byValInfo-&gt;stubInfo = gen.stubInfo();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     MacroAssembler::repatchJump(byValInfo-&gt;notIndexJump, CodeLocationLabel&lt;JITStubRoutinePtrTag&gt;(byValInfo-&gt;stubRoutine-&gt;code().code()));</span>
<span class="line-removed">-     MacroAssembler::repatchCall(CodeLocationCall&lt;NoPtrTag&gt;(MacroAssemblerCodePtr&lt;NoPtrTag&gt;(returnAddress)), FunctionPtr&lt;OperationPtrTag&gt;(operationGetByValGeneric));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  template&lt;typename Op&gt;
  void JIT::privateCompilePutByVal(const ConcurrentJSLocker&amp;, ByValInfo* byValInfo, ReturnAddressPtr returnAddress, JITArrayMode arrayMode)
  {
      const Instruction* currentInstruction = m_codeBlock-&gt;instructions().at(byValInfo-&gt;bytecodeIndex).ptr();
      auto bytecode = currentInstruction-&gt;as&lt;Op&gt;();
<span class="line-new-header">--- 1231,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1563,210 ***</span>
      slowCases.append(branchIfEmpty(result));
  
      return slowCases;
  }
  
<span class="line-removed">- JIT::JumpList JIT::emitDirectArgumentsGetByVal(const Instruction*, PatchableJump&amp; badType)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     JumpList slowCases;</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if USE(JSVALUE64)</span>
<span class="line-removed">-     RegisterID base = regT0;</span>
<span class="line-removed">-     RegisterID property = regT1;</span>
<span class="line-removed">-     JSValueRegs result = JSValueRegs(regT0);</span>
<span class="line-removed">-     RegisterID scratch = regT3;</span>
<span class="line-removed">-     RegisterID scratch2 = regT4;</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     RegisterID base = regT0;</span>
<span class="line-removed">-     RegisterID property = regT2;</span>
<span class="line-removed">-     JSValueRegs result = JSValueRegs(regT1, regT0);</span>
<span class="line-removed">-     RegisterID scratch = regT3;</span>
<span class="line-removed">-     RegisterID scratch2 = regT4;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     load8(Address(base, JSCell::typeInfoTypeOffset()), scratch);</span>
<span class="line-removed">-     badType = patchableBranch32(NotEqual, scratch, TrustedImm32(DirectArgumentsType));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     load32(Address(base, DirectArguments::offsetOfLength()), scratch2);</span>
<span class="line-removed">-     slowCases.append(branch32(AboveOrEqual, property, scratch2));</span>
<span class="line-removed">-     slowCases.append(branchTestPtr(NonZero, Address(base, DirectArguments::offsetOfMappedArguments())));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     loadValue(BaseIndex(base, property, TimesEight, DirectArguments::storageOffset()), result);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return slowCases;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JIT::JumpList JIT::emitScopedArgumentsGetByVal(const Instruction*, PatchableJump&amp; badType)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     JumpList slowCases;</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if USE(JSVALUE64)</span>
<span class="line-removed">-     RegisterID base = regT0;</span>
<span class="line-removed">-     RegisterID property = regT1;</span>
<span class="line-removed">-     JSValueRegs result = JSValueRegs(regT0);</span>
<span class="line-removed">-     RegisterID scratch = regT3;</span>
<span class="line-removed">-     RegisterID scratch2 = regT4;</span>
<span class="line-removed">-     RegisterID scratch3 = regT5;</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     RegisterID base = regT0;</span>
<span class="line-removed">-     RegisterID property = regT2;</span>
<span class="line-removed">-     JSValueRegs result = JSValueRegs(regT1, regT0);</span>
<span class="line-removed">-     RegisterID scratch = regT3;</span>
<span class="line-removed">-     RegisterID scratch2 = regT4;</span>
<span class="line-removed">-     RegisterID scratch3 = regT5;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     load8(Address(base, JSCell::typeInfoTypeOffset()), scratch);</span>
<span class="line-removed">-     badType = patchableBranch32(NotEqual, scratch, TrustedImm32(ScopedArgumentsType));</span>
<span class="line-removed">-     loadPtr(Address(base, ScopedArguments::offsetOfStorage()), scratch3);</span>
<span class="line-removed">-     slowCases.append(branch32(AboveOrEqual, property, Address(scratch3, ScopedArguments::offsetOfTotalLengthInStorage())));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     loadPtr(Address(base, ScopedArguments::offsetOfTable()), scratch);</span>
<span class="line-removed">-     load32(Address(scratch, ScopedArgumentsTable::offsetOfLength()), scratch2);</span>
<span class="line-removed">-     Jump overflowCase = branch32(AboveOrEqual, property, scratch2);</span>
<span class="line-removed">-     loadPtr(Address(base, ScopedArguments::offsetOfScope()), scratch2);</span>
<span class="line-removed">-     loadPtr(Address(scratch, ScopedArgumentsTable::offsetOfArguments()), scratch);</span>
<span class="line-removed">-     load32(BaseIndex(scratch, property, TimesFour), scratch);</span>
<span class="line-removed">-     slowCases.append(branch32(Equal, scratch, TrustedImm32(ScopeOffset::invalidOffset)));</span>
<span class="line-removed">-     loadValue(BaseIndex(scratch2, scratch, TimesEight, JSLexicalEnvironment::offsetOfVariables()), result);</span>
<span class="line-removed">-     Jump done = jump();</span>
<span class="line-removed">-     overflowCase.link(this);</span>
<span class="line-removed">-     sub32(property, scratch2);</span>
<span class="line-removed">-     neg32(scratch2);</span>
<span class="line-removed">-     loadValue(BaseIndex(scratch3, scratch2, TimesEight), result);</span>
<span class="line-removed">-     slowCases.append(branchIfEmpty(result));</span>
<span class="line-removed">-     done.link(this);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     load32(Address(scratch3, ScopedArguments::offsetOfTotalLengthInStorage()), scratch);</span>
<span class="line-removed">-     emitPreparePreciseIndexMask32(property, scratch, scratch2);</span>
<span class="line-removed">-     andPtr(scratch2, result.payloadGPR());</span>
<span class="line-removed">- </span>
<span class="line-removed">-     return slowCases;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JIT::JumpList JIT::emitIntTypedArrayGetByVal(const Instruction*, PatchableJump&amp; badType, TypedArrayType type)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isInt(type));</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // The best way to test the array type is to use the classInfo. We need to do so without</span>
<span class="line-removed">-     // clobbering the register that holds the indexing type, base, and property.</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if USE(JSVALUE64)</span>
<span class="line-removed">-     RegisterID base = regT0;</span>
<span class="line-removed">-     RegisterID property = regT1;</span>
<span class="line-removed">-     JSValueRegs result = JSValueRegs(regT0);</span>
<span class="line-removed">-     RegisterID scratch = regT3;</span>
<span class="line-removed">-     RegisterID scratch2 = regT4;</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     RegisterID base = regT0;</span>
<span class="line-removed">-     RegisterID property = regT2;</span>
<span class="line-removed">-     JSValueRegs result = JSValueRegs(regT1, regT0);</span>
<span class="line-removed">-     RegisterID scratch = regT3;</span>
<span class="line-removed">-     RegisterID scratch2 = regT4;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     RegisterID resultPayload = result.payloadGPR();</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JumpList slowCases;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     load8(Address(base, JSCell::typeInfoTypeOffset()), scratch);</span>
<span class="line-removed">-     badType = patchableBranch32(NotEqual, scratch, TrustedImm32(typeForTypedArrayType(type)));</span>
<span class="line-removed">-     load32(Address(base, JSArrayBufferView::offsetOfLength()), scratch2);</span>
<span class="line-removed">-     slowCases.append(branch32(AboveOrEqual, property, scratch2));</span>
<span class="line-removed">-     loadPtr(Address(base, JSArrayBufferView::offsetOfVector()), scratch);</span>
<span class="line-removed">-     cageConditionally(Gigacage::Primitive, scratch, scratch2, scratch2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     switch (elementSize(type)) {</span>
<span class="line-removed">-     case 1:</span>
<span class="line-removed">-         if (JSC::isSigned(type))</span>
<span class="line-removed">-             load8SignedExtendTo32(BaseIndex(scratch, property, TimesOne), resultPayload);</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             load8(BaseIndex(scratch, property, TimesOne), resultPayload);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case 2:</span>
<span class="line-removed">-         if (JSC::isSigned(type))</span>
<span class="line-removed">-             load16SignedExtendTo32(BaseIndex(scratch, property, TimesTwo), resultPayload);</span>
<span class="line-removed">-         else</span>
<span class="line-removed">-             load16(BaseIndex(scratch, property, TimesTwo), resultPayload);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case 4:</span>
<span class="line-removed">-         load32(BaseIndex(scratch, property, TimesFour), resultPayload);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-         CRASH();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Jump done;</span>
<span class="line-removed">-     if (type == TypeUint32) {</span>
<span class="line-removed">-         Jump canBeInt = branch32(GreaterThanOrEqual, resultPayload, TrustedImm32(0));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         convertInt32ToDouble(resultPayload, fpRegT0);</span>
<span class="line-removed">-         addDouble(AbsoluteAddress(&amp;twoToThe32), fpRegT0);</span>
<span class="line-removed">-         boxDouble(fpRegT0, result);</span>
<span class="line-removed">-         done = jump();</span>
<span class="line-removed">-         canBeInt.link(this);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     boxInt32(resultPayload, result);</span>
<span class="line-removed">-     if (done.isSet())</span>
<span class="line-removed">-         done.link(this);</span>
<span class="line-removed">-     return slowCases;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- JIT::JumpList JIT::emitFloatTypedArrayGetByVal(const Instruction*, PatchableJump&amp; badType, TypedArrayType type)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-     ASSERT(isFloat(type));</span>
<span class="line-removed">- </span>
<span class="line-removed">- #if USE(JSVALUE64)</span>
<span class="line-removed">-     RegisterID base = regT0;</span>
<span class="line-removed">-     RegisterID property = regT1;</span>
<span class="line-removed">-     JSValueRegs result = JSValueRegs(regT0);</span>
<span class="line-removed">-     RegisterID scratch = regT3;</span>
<span class="line-removed">-     RegisterID scratch2 = regT4;</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     RegisterID base = regT0;</span>
<span class="line-removed">-     RegisterID property = regT2;</span>
<span class="line-removed">-     JSValueRegs result = JSValueRegs(regT1, regT0);</span>
<span class="line-removed">-     RegisterID scratch = regT3;</span>
<span class="line-removed">-     RegisterID scratch2 = regT4;</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">-     JumpList slowCases;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     load8(Address(base, JSCell::typeInfoTypeOffset()), scratch);</span>
<span class="line-removed">-     badType = patchableBranch32(NotEqual, scratch, TrustedImm32(typeForTypedArrayType(type)));</span>
<span class="line-removed">-     load32(Address(base, JSArrayBufferView::offsetOfLength()), scratch2);</span>
<span class="line-removed">-     slowCases.append(branch32(AboveOrEqual, property, scratch2));</span>
<span class="line-removed">-     loadPtr(Address(base, JSArrayBufferView::offsetOfVector()), scratch);</span>
<span class="line-removed">-     cageConditionally(Gigacage::Primitive, scratch, scratch2, scratch2);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     switch (elementSize(type)) {</span>
<span class="line-removed">-     case 4:</span>
<span class="line-removed">-         loadFloat(BaseIndex(scratch, property, TimesFour), fpRegT0);</span>
<span class="line-removed">-         convertFloatToDouble(fpRegT0, fpRegT0);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     case 8: {</span>
<span class="line-removed">-         loadDouble(BaseIndex(scratch, property, TimesEight), fpRegT0);</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     default:</span>
<span class="line-removed">-         CRASH();</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     purifyNaN(fpRegT0);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     boxDouble(fpRegT0, result);</span>
<span class="line-removed">-     return slowCases;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  template&lt;typename Op&gt;
  JIT::JumpList JIT::emitIntTypedArrayPutByVal(Op bytecode, PatchableJump&amp; badType, TypedArrayType type)
  {
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
      ASSERT(isInt(type));
  
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
  
  #if USE(JSVALUE64)
      RegisterID base = regT0;
      RegisterID property = regT1;
      RegisterID earlyScratch = regT3;
<span class="line-new-header">--- 1416,18 ---</span>
      slowCases.append(branchIfEmpty(result));
  
      return slowCases;
  }
  
  template&lt;typename Op&gt;
  JIT::JumpList JIT::emitIntTypedArrayPutByVal(Op bytecode, PatchableJump&amp; badType, TypedArrayType type)
  {
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
      ASSERT(isInt(type));
  
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
  
  #if USE(JSVALUE64)
      RegisterID base = regT0;
      RegisterID property = regT1;
      RegisterID earlyScratch = regT3;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1838,11 ***</span>
  {
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
      ASSERT(isFloat(type));
  
<span class="line-modified">!     int value = bytecode.m_value.offset();</span>
  
  #if USE(JSVALUE64)
      RegisterID base = regT0;
      RegisterID property = regT1;
      RegisterID earlyScratch = regT3;
<span class="line-new-header">--- 1499,11 ---</span>
  {
      auto&amp; metadata = bytecode.metadata(m_codeBlock);
      ArrayProfile* profile = &amp;metadata.m_arrayProfile;
      ASSERT(isFloat(type));
  
<span class="line-modified">!     VirtualRegister value = bytecode.m_value;</span>
  
  #if USE(JSVALUE64)
      RegisterID base = regT0;
      RegisterID property = regT1;
      RegisterID earlyScratch = regT3;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1871,11 ***</span>
      Jump doubleCase = branchIfNotInt32(earlyScratch);
      convertInt32ToDouble(earlyScratch, fpRegT0);
      Jump ready = jump();
      doubleCase.link(this);
      slowCases.append(branchIfNotNumber(earlyScratch));
<span class="line-modified">!     add64(tagTypeNumberRegister, earlyScratch);</span>
      move64ToDouble(earlyScratch, fpRegT0);
      ready.link(this);
  #else
      emitLoad(value, lateScratch, earlyScratch);
      Jump doubleCase = branchIfNotInt32(lateScratch);
<span class="line-new-header">--- 1532,11 ---</span>
      Jump doubleCase = branchIfNotInt32(earlyScratch);
      convertInt32ToDouble(earlyScratch, fpRegT0);
      Jump ready = jump();
      doubleCase.link(this);
      slowCases.append(branchIfNotNumber(earlyScratch));
<span class="line-modified">!     add64(numberTagRegister, earlyScratch);</span>
      move64ToDouble(earlyScratch, fpRegT0);
      ready.link(this);
  #else
      emitLoad(value, lateScratch, earlyScratch);
      Jump doubleCase = branchIfNotInt32(lateScratch);
</pre>
<center><a href="JITOperationsMSVC64.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JITPropertyAccess32_64.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
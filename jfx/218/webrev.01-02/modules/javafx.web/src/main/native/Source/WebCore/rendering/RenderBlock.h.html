<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlock.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2007 David Smith (catfish.man@gmail.com)
  5  * Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Apple Inc. All rights reserved.
  6  *
  7  * This library is free software; you can redistribute it and/or
  8  * modify it under the terms of the GNU Library General Public
  9  * License as published by the Free Software Foundation; either
 10  * version 2 of the License, or (at your option) any later version.
 11  *
 12  * This library is distributed in the hope that it will be useful,
 13  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 14  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15  * Library General Public License for more details.
 16  *
 17  * You should have received a copy of the GNU Library General Public License
 18  * along with this library; see the file COPYING.LIB.  If not, write to
 19  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20  * Boston, MA 02110-1301, USA.
 21  */
 22 
 23 #pragma once
 24 
 25 #include &quot;GapRects.h&quot;
 26 #include &quot;LineWidth.h&quot;
 27 #include &quot;RenderBox.h&quot;
 28 #include &quot;TextRun.h&quot;
 29 #include &lt;memory&gt;
 30 #include &lt;wtf/ListHashSet.h&gt;
 31 
 32 namespace WebCore {
 33 
 34 class LineLayoutState;
 35 class LogicalSelectionOffsetCaches;
 36 class RenderInline;
 37 class RenderText;
 38 
 39 struct BidiRun;
 40 struct PaintInfo;
 41 
 42 typedef WTF::ListHashSet&lt;RenderBox*&gt; TrackedRendererListHashSet;
 43 
 44 enum CaretType { CursorCaret, DragCaret };
 45 enum ContainingBlockState { NewContainingBlock, SameContainingBlock };
 46 
 47 enum TextRunFlag {
 48     DefaultTextRunFlags = 0,
 49     RespectDirection = 1 &lt;&lt; 0,
 50     RespectDirectionOverride = 1 &lt;&lt; 1
 51 };
 52 
 53 typedef unsigned TextRunFlags;
 54 
 55 class RenderBlock : public RenderBox {
 56     WTF_MAKE_ISO_ALLOCATED(RenderBlock);
 57 public:
 58     friend class LineLayoutState;
 59     virtual ~RenderBlock();
 60 
 61 protected:
 62     RenderBlock(Element&amp;, RenderStyle&amp;&amp;, BaseTypeFlags);
 63     RenderBlock(Document&amp;, RenderStyle&amp;&amp;, BaseTypeFlags);
 64 
 65 public:
 66     // These two functions are overridden for inline-block.
 67     LayoutUnit lineHeight(bool firstLine, LineDirectionMode, LinePositionMode = PositionOnContainingLine) const final;
 68     int baselinePosition(FontBaseline, bool firstLine, LineDirectionMode, LinePositionMode = PositionOnContainingLine) const override;
 69 
 70     LayoutUnit minLineHeightForReplacedRenderer(bool isFirstLine, LayoutUnit replacedHeight) const;
 71 
 72     // FIXME-BLOCKFLOW: Remove virtualizaion when all callers have moved to RenderBlockFlow
 73     virtual void deleteLines();
 74 
 75     virtual void layoutBlock(bool relayoutChildren, LayoutUnit pageLogicalHeight = 0_lu);
 76 
 77     virtual void invalidateLineLayoutPath() { }
 78 
 79     void insertPositionedObject(RenderBox&amp;);
 80     static void removePositionedObject(const RenderBox&amp;);
 81     void removePositionedObjects(const RenderBlock*, ContainingBlockState = SameContainingBlock);
 82 
 83     TrackedRendererListHashSet* positionedObjects() const;
 84     bool hasPositionedObjects() const
 85     {
 86         TrackedRendererListHashSet* objects = positionedObjects();
 87         return objects &amp;&amp; !objects-&gt;isEmpty();
 88     }
 89 
 90     void addPercentHeightDescendant(RenderBox&amp;);
 91     static void removePercentHeightDescendant(RenderBox&amp;);
 92     TrackedRendererListHashSet* percentHeightDescendants() const;
 93     bool hasPercentHeightDescendants() const
 94     {
 95         TrackedRendererListHashSet* objects = percentHeightDescendants();
 96         return objects &amp;&amp; !objects-&gt;isEmpty();
 97     }
 98     static bool hasPercentHeightContainerMap();
 99     static bool hasPercentHeightDescendant(RenderBox&amp;);
100     static void clearPercentHeightDescendantsFrom(RenderBox&amp;);
101     static void removePercentHeightDescendantIfNeeded(RenderBox&amp;);
102 
103     bool isContainingBlockAncestorFor(RenderObject&amp;) const;
104 
105     void setHasMarginBeforeQuirk(bool b) { setRenderBlockHasMarginBeforeQuirk(b); }
106     void setHasMarginAfterQuirk(bool b) { setRenderBlockHasMarginAfterQuirk(b); }
107     void setShouldForceRelayoutChildren(bool b) { setRenderBlockShouldForceRelayoutChildren(b); }
108 
109     bool hasMarginBeforeQuirk() const { return renderBlockHasMarginBeforeQuirk(); }
110     bool hasMarginAfterQuirk() const { return renderBlockHasMarginAfterQuirk(); }
111     bool hasBorderOrPaddingLogicalWidthChanged() const { return renderBlockShouldForceRelayoutChildren(); }
112 
113     bool hasMarginBeforeQuirk(const RenderBox&amp; child) const;
114     bool hasMarginAfterQuirk(const RenderBox&amp; child) const;
115 
116     void markPositionedObjectsForLayout();
117     void markForPaginationRelayoutIfNeeded() override;
118 
119     // FIXME-BLOCKFLOW: Remove virtualizaion when all of the line layout code has been moved out of RenderBlock
120     virtual bool containsFloats() const { return false; }
121 
122     // Versions that can compute line offsets with the fragment and page offset passed in. Used for speed to avoid having to
123     // compute the fragment all over again when you already know it.
124     LayoutUnit availableLogicalWidthForLineInFragment(LayoutUnit position, IndentTextOrNot shouldIndentText, RenderFragmentContainer* fragment, LayoutUnit logicalHeight = 0_lu) const
125     {
126         return std::max&lt;LayoutUnit&gt;(0, logicalRightOffsetForLineInFragment(position, shouldIndentText, fragment, logicalHeight)
127             - logicalLeftOffsetForLineInFragment(position, shouldIndentText, fragment, logicalHeight));
128     }
129     LayoutUnit logicalRightOffsetForLineInFragment(LayoutUnit position, IndentTextOrNot shouldIndentText, RenderFragmentContainer* fragment, LayoutUnit logicalHeight = 0_lu) const
130     {
131         return logicalRightOffsetForLine(position, logicalRightOffsetForContent(fragment), shouldIndentText, logicalHeight);
132     }
133     LayoutUnit logicalLeftOffsetForLineInFragment(LayoutUnit position, IndentTextOrNot shouldIndentText, RenderFragmentContainer* fragment, LayoutUnit logicalHeight = 0_lu) const
134     {
135         return logicalLeftOffsetForLine(position, logicalLeftOffsetForContent(fragment), shouldIndentText, logicalHeight);
136     }
137     LayoutUnit startOffsetForLineInFragment(LayoutUnit position, IndentTextOrNot shouldIndentText, RenderFragmentContainer* fragment, LayoutUnit logicalHeight = 0_lu) const
138     {
139         return style().isLeftToRightDirection() ? logicalLeftOffsetForLineInFragment(position, shouldIndentText, fragment, logicalHeight)
140             : logicalWidth() - logicalRightOffsetForLineInFragment(position, shouldIndentText, fragment, logicalHeight);
141     }
142     LayoutUnit endOffsetForLineInFragment(LayoutUnit position, IndentTextOrNot shouldIndentText, RenderFragmentContainer* fragment, LayoutUnit logicalHeight = 0_lu) const
143     {
144         return !style().isLeftToRightDirection() ? logicalLeftOffsetForLineInFragment(position, shouldIndentText, fragment, logicalHeight)
145             : logicalWidth() - logicalRightOffsetForLineInFragment(position, shouldIndentText, fragment, logicalHeight);
146     }
147 
148     LayoutUnit availableLogicalWidthForLine(LayoutUnit position, IndentTextOrNot shouldIndentText, LayoutUnit logicalHeight = 0_lu) const
149     {
150         return availableLogicalWidthForLineInFragment(position, shouldIndentText, fragmentAtBlockOffset(position), logicalHeight);
151     }
152     LayoutUnit logicalRightOffsetForLine(LayoutUnit position, IndentTextOrNot shouldIndentText, LayoutUnit logicalHeight = 0_lu) const
153     {
154         return logicalRightOffsetForLine(position, logicalRightOffsetForContent(position), shouldIndentText, logicalHeight);
155     }
156     LayoutUnit logicalLeftOffsetForLine(LayoutUnit position, IndentTextOrNot shouldIndentText, LayoutUnit logicalHeight = 0_lu) const
157     {
158         return logicalLeftOffsetForLine(position, logicalLeftOffsetForContent(position), shouldIndentText, logicalHeight);
159     }
160     LayoutUnit startOffsetForLine(LayoutUnit position, IndentTextOrNot shouldIndentText, LayoutUnit logicalHeight = 0_lu) const
161     {
162         return style().isLeftToRightDirection() ? logicalLeftOffsetForLine(position, shouldIndentText, logicalHeight)
163             : logicalWidth() - logicalRightOffsetForLine(position, shouldIndentText, logicalHeight);
164     }
165     LayoutUnit endOffsetForLine(LayoutUnit position, IndentTextOrNot shouldIndentText, LayoutUnit logicalHeight = 0_lu) const
166     {
167         return !style().isLeftToRightDirection() ? logicalLeftOffsetForLine(position, shouldIndentText, logicalHeight)
168             : logicalWidth() - logicalRightOffsetForLine(position, shouldIndentText, logicalHeight);
169     }
170 
171     LayoutUnit textIndentOffset() const;
172 
173     VisiblePosition positionForPoint(const LayoutPoint&amp;, const RenderFragmentContainer*) override;
174 
175     GapRects selectionGapRectsForRepaint(const RenderLayerModelObject* repaintContainer);
176     LayoutRect logicalLeftSelectionGap(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
177         RenderBoxModelObject* selObj, LayoutUnit logicalLeft, LayoutUnit logicalTop, LayoutUnit logicalHeight, const LogicalSelectionOffsetCaches&amp;, const PaintInfo*);
178     LayoutRect logicalRightSelectionGap(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
179         RenderBoxModelObject* selObj, LayoutUnit logicalRight, LayoutUnit logicalTop, LayoutUnit logicalHeight, const LogicalSelectionOffsetCaches&amp;, const PaintInfo*);
180     void getSelectionGapInfo(SelectionState, bool&amp; leftGap, bool&amp; rightGap);
181     bool isSelectionRoot() const;
182 
183     LayoutRect logicalRectToPhysicalRect(const LayoutPoint&amp; physicalPosition, const LayoutRect&amp; logicalRect);
184 
185     void addContinuationWithOutline(RenderInline*);
186     bool paintsContinuationOutline(RenderInline*);
187 
188     static RenderPtr&lt;RenderBlock&gt; createAnonymousWithParentRendererAndDisplay(const RenderBox&amp; parent, DisplayType = DisplayType::Block);
189     RenderPtr&lt;RenderBlock&gt; createAnonymousBlock(DisplayType = DisplayType::Block) const;
190 
191     RenderPtr&lt;RenderBox&gt; createAnonymousBoxWithSameTypeAs(const RenderBox&amp;) const override;
192 
193     static bool shouldSkipCreatingRunsForObject(RenderObject&amp; obj)
194     {
195         return obj.isFloating() || (obj.isOutOfFlowPositioned() &amp;&amp; !obj.style().isOriginalDisplayInlineType() &amp;&amp; !obj.container()-&gt;isRenderInline());
196     }
197 
198     static TextRun constructTextRun(StringView, const RenderStyle&amp;,
199         ExpansionBehavior = DefaultExpansion, TextRunFlags = DefaultTextRunFlags);
200     static TextRun constructTextRun(const String&amp;, const RenderStyle&amp;,
201         ExpansionBehavior = DefaultExpansion, TextRunFlags = DefaultTextRunFlags);
202     static TextRun constructTextRun(const AtomString&amp;, const RenderStyle&amp;,
203         ExpansionBehavior = DefaultExpansion, TextRunFlags = DefaultTextRunFlags);
204     static TextRun constructTextRun(const RenderText&amp;, const RenderStyle&amp;,
205         ExpansionBehavior = DefaultExpansion);
206     static TextRun constructTextRun(const RenderText&amp;, unsigned offset, unsigned length, const RenderStyle&amp;,
207         ExpansionBehavior = DefaultExpansion);
208     static TextRun constructTextRun(const LChar* characters, unsigned length, const RenderStyle&amp;,
209         ExpansionBehavior = DefaultExpansion);
210     static TextRun constructTextRun(const UChar* characters, unsigned length, const RenderStyle&amp;,
211         ExpansionBehavior = DefaultExpansion);
212 
213     LayoutUnit paginationStrut() const;
214     void setPaginationStrut(LayoutUnit);
215 
216     // The page logical offset is the object&#39;s offset from the top of the page in the page progression
217     // direction (so an x-offset in vertical text and a y-offset for horizontal text).
218     LayoutUnit pageLogicalOffset() const;
219     void setPageLogicalOffset(LayoutUnit);
220 
221     // Fieldset legends that are taller than the fieldset border add in intrinsic border
222     // in order to ensure that content gets properly pushed down across all layout systems
223     // (flexbox, block, etc.)
224     LayoutUnit intrinsicBorderForFieldset() const;
225     void setIntrinsicBorderForFieldset(LayoutUnit);
226     LayoutUnit borderTop() const override;
227     LayoutUnit borderBottom() const override;
228     LayoutUnit borderLeft() const override;
229     LayoutUnit borderRight() const override;
230     LayoutUnit borderBefore() const override;
231     LayoutUnit adjustBorderBoxLogicalHeightForBoxSizing(LayoutUnit height) const override;
232     LayoutUnit adjustContentBoxLogicalHeightForBoxSizing(Optional&lt;LayoutUnit&gt; height) const override;
233     void paintExcludedChildrenInBorder(PaintInfo&amp;, const LayoutPoint&amp;);
234 
235     // Accessors for logical width/height and margins in the containing block&#39;s block-flow direction.
236     enum ApplyLayoutDeltaMode { ApplyLayoutDelta, DoNotApplyLayoutDelta };
237     LayoutUnit logicalWidthForChild(const RenderBox&amp; child) const { return isHorizontalWritingMode() ? child.width() : child.height(); }
238     LayoutUnit logicalHeightForChild(const RenderBox&amp; child) const { return isHorizontalWritingMode() ? child.height() : child.width(); }
239     LayoutSize logicalSizeForChild(const RenderBox&amp; child) const { return isHorizontalWritingMode() ? child.size() : child.size().transposedSize(); }
240     LayoutUnit logicalTopForChild(const RenderBox&amp; child) const { return isHorizontalWritingMode() ? child.y() : child.x(); }
241     void setLogicalLeftForChild(RenderBox&amp; child, LayoutUnit logicalLeft, ApplyLayoutDeltaMode = DoNotApplyLayoutDelta);
242     void setLogicalTopForChild(RenderBox&amp; child, LayoutUnit logicalTop, ApplyLayoutDeltaMode = DoNotApplyLayoutDelta);
243     LayoutUnit marginBeforeForChild(const RenderBoxModelObject&amp; child) const { return child.marginBefore(&amp;style()); }
244     LayoutUnit marginAfterForChild(const RenderBoxModelObject&amp; child) const { return child.marginAfter(&amp;style()); }
245     LayoutUnit marginStartForChild(const RenderBoxModelObject&amp; child) const { return child.marginStart(&amp;style()); }
246     LayoutUnit marginEndForChild(const RenderBoxModelObject&amp; child) const { return child.marginEnd(&amp;style()); }
247     void setMarginStartForChild(RenderBox&amp; child, LayoutUnit value) const { child.setMarginStart(value, &amp;style()); }
248     void setMarginEndForChild(RenderBox&amp; child, LayoutUnit value) const { child.setMarginEnd(value, &amp;style()); }
249     void setMarginBeforeForChild(RenderBox&amp; child, LayoutUnit value) const { child.setMarginBefore(value, &amp;style()); }
250     void setMarginAfterForChild(RenderBox&amp; child, LayoutUnit value) const { child.setMarginAfter(value, &amp;style()); }
251     LayoutUnit collapsedMarginBeforeForChild(const RenderBox&amp; child) const;
252     LayoutUnit collapsedMarginAfterForChild(const RenderBox&amp; child) const;
253 
254     void getFirstLetter(RenderObject*&amp; firstLetter, RenderElement*&amp; firstLetterContainer, RenderObject* skipObject = nullptr);
255 
256     virtual void scrollbarsChanged(bool /*horizontalScrollbarChanged*/, bool /*verticalScrollbarChanged*/) { }
257 
258     LayoutUnit logicalLeftOffsetForContent(RenderFragmentContainer*) const;
259     LayoutUnit logicalRightOffsetForContent(RenderFragmentContainer*) const;
260     LayoutUnit availableLogicalWidthForContent(RenderFragmentContainer* fragment) const
261     {
262         return std::max&lt;LayoutUnit&gt;(0, logicalRightOffsetForContent(fragment) - logicalLeftOffsetForContent(fragment));
263     }
264     LayoutUnit startOffsetForContent(RenderFragmentContainer* fragment) const
265     {
266         return style().isLeftToRightDirection() ? logicalLeftOffsetForContent(fragment) : logicalWidth() - logicalRightOffsetForContent(fragment);
267     }
268     LayoutUnit endOffsetForContent(RenderFragmentContainer* fragment) const
269     {
270         return !style().isLeftToRightDirection() ? logicalLeftOffsetForContent(fragment) : logicalWidth() - logicalRightOffsetForContent(fragment);
271     }
272     LayoutUnit logicalLeftOffsetForContent(LayoutUnit blockOffset) const
273     {
274         return logicalLeftOffsetForContent(fragmentAtBlockOffset(blockOffset));
275     }
276     LayoutUnit logicalRightOffsetForContent(LayoutUnit blockOffset) const
277     {
278         return logicalRightOffsetForContent(fragmentAtBlockOffset(blockOffset));
279     }
280     LayoutUnit availableLogicalWidthForContent(LayoutUnit blockOffset) const
281     {
282         return availableLogicalWidthForContent(fragmentAtBlockOffset(blockOffset));
283     }
284     LayoutUnit startOffsetForContent(LayoutUnit blockOffset) const
285     {
286         return startOffsetForContent(fragmentAtBlockOffset(blockOffset));
287     }
288     LayoutUnit endOffsetForContent(LayoutUnit blockOffset) const
289     {
290         return endOffsetForContent(fragmentAtBlockOffset(blockOffset));
291     }
292     LayoutUnit logicalLeftOffsetForContent() const { return isHorizontalWritingMode() ? borderLeft() + paddingLeft() : borderTop() + paddingTop(); }
293     LayoutUnit logicalRightOffsetForContent() const { return logicalLeftOffsetForContent() + availableLogicalWidth(); }
294     LayoutUnit startOffsetForContent() const { return style().isLeftToRightDirection() ? logicalLeftOffsetForContent() : logicalWidth() - logicalRightOffsetForContent(); }
295     LayoutUnit endOffsetForContent() const { return !style().isLeftToRightDirection() ? logicalLeftOffsetForContent() : logicalWidth() - logicalRightOffsetForContent(); }
296 
297     LayoutUnit logicalLeftSelectionOffset(RenderBlock&amp; rootBlock, LayoutUnit position, const LogicalSelectionOffsetCaches&amp;);
298     LayoutUnit logicalRightSelectionOffset(RenderBlock&amp; rootBlock, LayoutUnit position, const LogicalSelectionOffsetCaches&amp;);
299 
300     LayoutUnit computeStartPositionDeltaForChildAvoidingFloats(const RenderBox&amp; child, LayoutUnit childMarginStart, RenderFragmentContainer* = 0);
301 
302 #if ASSERT_ENABLED
303     void checkPositionedObjectsNeedLayout();
304 #endif
305 
306     void updateHitTestResult(HitTestResult&amp;, const LayoutPoint&amp;) override;
307 
308     bool canHaveChildren() const override { return true; }
309     virtual bool canDropAnonymousBlockChild() const { return true; }
310 
311     RenderFragmentedFlow* cachedEnclosingFragmentedFlow() const;
312     void setCachedEnclosingFragmentedFlowNeedsUpdate();
313     virtual bool cachedEnclosingFragmentedFlowNeedsUpdate() const;
314     void resetEnclosingFragmentedFlowAndChildInfoIncludingDescendants(RenderFragmentedFlow* = nullptr) final;
315 
316     Optional&lt;LayoutUnit&gt; availableLogicalHeightForPercentageComputation() const;
317     bool hasDefiniteLogicalHeight() const;
318 
319     virtual bool shouldResetChildLogicalHeightBeforeLayout(const RenderBox&amp;) const { return false; }
320 
321 protected:
322     RenderFragmentedFlow* locateEnclosingFragmentedFlow() const override;
323     void willBeDestroyed() override;
324 
325     void layout() override;
326 
327     void layoutPositionedObjects(bool relayoutChildren, bool fixedPositionObjectsOnly = false);
328     virtual void layoutPositionedObject(RenderBox&amp;, bool relayoutChildren, bool fixedPositionObjectsOnly);
329 
330     void markFixedPositionObjectForLayoutIfNeeded(RenderBox&amp; child);
331 
332     LayoutUnit marginIntrinsicLogicalWidthForChild(RenderBox&amp;) const;
333 
334     void paint(PaintInfo&amp;, const LayoutPoint&amp;) override;
335     void paintObject(PaintInfo&amp;, const LayoutPoint&amp;) override;
336     virtual void paintChildren(PaintInfo&amp; forSelf, const LayoutPoint&amp;, PaintInfo&amp; forChild, bool usePrintRect);
337     enum PaintBlockType { PaintAsBlock, PaintAsInlineBlock };
338     bool paintChild(RenderBox&amp;, PaintInfo&amp; forSelf, const LayoutPoint&amp;, PaintInfo&amp; forChild, bool usePrintRect, PaintBlockType paintType = PaintAsBlock);
339 
340     LayoutUnit logicalRightOffsetForLine(LayoutUnit logicalTop, LayoutUnit fixedOffset, bool applyTextIndent, LayoutUnit logicalHeight = 0_lu) const
341     {
342         return adjustLogicalRightOffsetForLine(logicalRightFloatOffsetForLine(logicalTop, fixedOffset, logicalHeight), applyTextIndent);
343     }
344     LayoutUnit logicalLeftOffsetForLine(LayoutUnit logicalTop, LayoutUnit fixedOffset, bool applyTextIndent, LayoutUnit logicalHeight = 0_lu) const
345     {
346         return adjustLogicalLeftOffsetForLine(logicalLeftFloatOffsetForLine(logicalTop, fixedOffset, logicalHeight), applyTextIndent);
347     }
348 
349     bool nodeAtPoint(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction) override;
350 
351     void computeIntrinsicLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const override;
352     void computePreferredLogicalWidths() override;
353 
354     Optional&lt;int&gt; firstLineBaseline() const override;
355     Optional&lt;int&gt; inlineBlockBaseline(LineDirectionMode) const override;
356 
357     // Delay updating scrollbars until endAndCommitUpdateScrollInfoAfterLayoutTransaction() is called. These functions are used
358     // when a flexbox is laying out its descendants. If multiple calls are made to beginUpdateScrollInfoAfterLayoutTransaction()
359     // then endAndCommitUpdateScrollInfoAfterLayoutTransaction() will do nothing until it is called the same number of times.
360     void beginUpdateScrollInfoAfterLayoutTransaction();
361     void endAndCommitUpdateScrollInfoAfterLayoutTransaction();
362 
363     void removeFromUpdateScrollInfoAfterLayoutTransaction();
364 
365     void updateScrollInfoAfterLayout();
366 
367     void styleWillChange(StyleDifference, const RenderStyle&amp; newStyle) override;
368     void styleDidChange(StyleDifference, const RenderStyle* oldStyle) override;
369 
370     virtual bool hasLineIfEmpty() const;
371 
372     virtual bool canPerformSimplifiedLayout() const;
373     bool simplifiedLayout();
374     virtual void simplifiedNormalFlowLayout();
375 
376     bool childBoxIsUnsplittableForFragmentation(const RenderBox&amp; child) const;
377 
378 public:
379     virtual void computeOverflow(LayoutUnit oldClientAfterEdge, bool recomputeFloats = false);
380     void clearLayoutOverflow();
381 
382     // Adjust from painting offsets to the local coords of this renderer
383     void offsetForContents(LayoutPoint&amp;) const;
384     // Obtains the nearest enclosing block (including this block) that contributes a first-line style to our inline
385     // children.
386     RenderBlock* firstLineBlock() const override;
387 
388     enum FieldsetFindLegendOption { FieldsetIgnoreFloatingOrOutOfFlow, FieldsetIncludeFloatingOrOutOfFlow };
389     RenderBox* findFieldsetLegend(FieldsetFindLegendOption = FieldsetIgnoreFloatingOrOutOfFlow) const;
390     virtual void layoutExcludedChildren(bool /*relayoutChildren*/);
391     virtual bool computePreferredWidthsForExcludedChildren(LayoutUnit&amp;, LayoutUnit&amp;) const;
392 
393     void adjustBorderBoxRectForPainting(LayoutRect&amp;) override;
394     LayoutRect paintRectToClipOutFromBorder(const LayoutRect&amp;) override;
395     bool isInlineBlockOrInlineTable() const final { return isInline() &amp;&amp; isReplaced(); }
396 
397     void absoluteRects(Vector&lt;IntRect&gt;&amp;, const LayoutPoint&amp; accumulatedOffset) const override;
398     void absoluteQuads(Vector&lt;FloatQuad&gt;&amp;, bool* wasFixed) const override;
399 
400 protected:
401     virtual void addOverflowFromChildren();
402     // FIXME-BLOCKFLOW: Remove virtualization when all callers have moved to RenderBlockFlow
403     virtual void addOverflowFromInlineChildren() { }
404     void addOverflowFromBlockChildren();
405     void addOverflowFromPositionedObjects();
406     void addVisualOverflowFromTheme();
407 
408     void addFocusRingRects(Vector&lt;LayoutRect&gt;&amp;, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject* paintContainer = 0) override;
409     virtual void addFocusRingRectsForInlineChildren(Vector&lt;LayoutRect&gt;&amp;, const LayoutPoint&amp; additionalOffset, const RenderLayerModelObject* paintContainer);
410 
411     void computeFragmentRangeForBoxChild(const RenderBox&amp;) const;
412 
413     void estimateFragmentRangeForBoxChild(const RenderBox&amp;) const;
414     bool updateFragmentRangeForBoxChild(const RenderBox&amp;) const;
415 
416     void updateBlockChildDirtyBitsBeforeLayout(bool relayoutChildren, RenderBox&amp;);
417 
418     void preparePaginationBeforeBlockLayout(bool&amp;);
419 
420     void computeChildPreferredLogicalWidths(RenderObject&amp;, LayoutUnit&amp; minPreferredLogicalWidth, LayoutUnit&amp; maxPreferredLogicalWidth) const;
421 
422     void blockWillBeDestroyed();
423 
424 private:
425     static RenderPtr&lt;RenderBlock&gt; createAnonymousBlockWithStyleAndDisplay(Document&amp;, const RenderStyle&amp;, DisplayType);
426 
427     // FIXME-BLOCKFLOW: Remove virtualizaion when all callers have moved to RenderBlockFlow
428     virtual LayoutUnit logicalRightFloatOffsetForLine(LayoutUnit, LayoutUnit fixedOffset, LayoutUnit) const { return fixedOffset; };
429     // FIXME-BLOCKFLOW: Remove virtualizaion when all callers have moved to RenderBlockFlow
430     virtual LayoutUnit logicalLeftFloatOffsetForLine(LayoutUnit, LayoutUnit fixedOffset, LayoutUnit) const { return fixedOffset; }
431     LayoutUnit adjustLogicalRightOffsetForLine(LayoutUnit offsetFromFloats, bool applyTextIndent) const;
432     LayoutUnit adjustLogicalLeftOffsetForLine(LayoutUnit offsetFromFloats, bool applyTextIndent) const;
433 
434     const char* renderName() const override;
435 
436     bool isSelfCollapsingBlock() const override;
437     virtual bool childrenPreventSelfCollapsing() const;
438 
439     Node* nodeForHitTest() const;
440 
441     // FIXME-BLOCKFLOW: Remove virtualizaion when all callers have moved to RenderBlockFlow
442     virtual void paintFloats(PaintInfo&amp;, const LayoutPoint&amp;, bool) { }
443     virtual void paintInlineChildren(PaintInfo&amp;, const LayoutPoint&amp;) { }
444     void paintContents(PaintInfo&amp;, const LayoutPoint&amp;);
445     virtual void paintColumnRules(PaintInfo&amp;, const LayoutPoint&amp;) { };
446     void paintSelection(PaintInfo&amp;, const LayoutPoint&amp;);
447     void paintCaret(PaintInfo&amp;, const LayoutPoint&amp;, CaretType);
448 
449     virtual bool hitTestContents(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction);
450     // FIXME-BLOCKFLOW: Remove virtualization when all callers have moved to RenderBlockFlow
451     virtual bool hitTestFloats(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp;, const LayoutPoint&amp;) { return false; }
452     virtual bool hitTestInlineChildren(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp;, const LayoutPoint&amp;, HitTestAction) { return false; }
453     bool hitTestExcludedChildrenInBorder(const HitTestRequest&amp;, HitTestResult&amp;, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction);
454 
455     virtual bool isPointInOverflowControl(HitTestResult&amp;, const LayoutPoint&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset);
456 
457     void computeBlockPreferredLogicalWidths(LayoutUnit&amp; minLogicalWidth, LayoutUnit&amp; maxLogicalWidth) const;
458 
459     LayoutRect rectWithOutlineForRepaint(const RenderLayerModelObject* repaintContainer, LayoutUnit outlineWidth) const final;
460     const RenderStyle&amp; outlineStyleForRepaint() const final;
461 
462     void updateDragState(bool dragOn) final;
463 
464     LayoutRect selectionRectForRepaint(const RenderLayerModelObject* repaintContainer, bool /*clipToVisibleContent*/) final
465     {
466         return selectionGapRectsForRepaint(repaintContainer);
467     }
468     bool shouldPaintSelectionGaps() const final;
469     GapRects selectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
470         LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp;, const PaintInfo* = 0);
471     // FIXME-BLOCKFLOW: Remove virtualizaion when all callers have moved to RenderBlockFlow
472     virtual GapRects inlineSelectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
473         LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp;, const PaintInfo*);
474     GapRects blockSelectionGaps(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
475         LayoutUnit&amp; lastLogicalTop, LayoutUnit&amp; lastLogicalLeft, LayoutUnit&amp; lastLogicalRight, const LogicalSelectionOffsetCaches&amp;, const PaintInfo*);
476     LayoutRect blockSelectionGap(RenderBlock&amp; rootBlock, const LayoutPoint&amp; rootBlockPhysicalPosition, const LayoutSize&amp; offsetFromRootBlock,
477         LayoutUnit lastLogicalTop, LayoutUnit lastLogicalLeft, LayoutUnit lastLogicalRight, LayoutUnit logicalBottom, const LogicalSelectionOffsetCaches&amp;, const PaintInfo*);
478 
479     // FIXME-BLOCKFLOW: Remove virtualizaion when all callers have moved to RenderBlockFlow
480     virtual void clipOutFloatingObjects(RenderBlock&amp;, const PaintInfo*, const LayoutPoint&amp;, const LayoutSize&amp;) { };
481     friend class LogicalSelectionOffsetCaches;
482 
483     void paintContinuationOutlines(PaintInfo&amp;, const LayoutPoint&amp;);
484 
485     LayoutRect localCaretRect(InlineBox*, unsigned caretOffset, LayoutUnit* extraWidthToEndOfLine = 0) final;
486 
487     // FIXME-BLOCKFLOW: Remove virtualizaion when all callers have moved to RenderBlockFlow
488     virtual VisiblePosition positionForPointWithInlineChildren(const LayoutPoint&amp;, const RenderFragmentContainer*);
489 
490     RenderPtr&lt;RenderBlock&gt; clone() const;
491 
492     RenderFragmentedFlow* updateCachedEnclosingFragmentedFlow(RenderFragmentedFlow*) const;
493 
494     void removePositionedObjectsIfNeeded(const RenderStyle&amp; oldStyle, const RenderStyle&amp; newStyle);
495 
496     void absoluteQuadsIgnoringContinuation(const FloatRect&amp;, Vector&lt;FloatQuad&gt;&amp;, bool* wasFixed) const override;
497 
498 private:
499     bool hasRareData() const;
500 
501 protected:
502     void dirtyForLayoutFromPercentageHeightDescendants();
503 
504 protected:
505     bool recomputeLogicalWidth();
506 
507 public:
508     LayoutUnit offsetFromLogicalTopOfFirstPage() const override;
509     RenderFragmentContainer* fragmentAtBlockOffset(LayoutUnit) const;
510 
511     // FIXME: This is temporary to allow us to move code from RenderBlock into RenderBlockFlow that accesses member variables that we haven&#39;t moved out of
512     // RenderBlock yet.
513     friend class RenderBlockFlow;
514     // FIXME-BLOCKFLOW: Remove this when the line layout stuff has all moved out of RenderBlock
515     friend class LineBreaker;
516 
517     // RenderRubyBase objects need to be able to split and merge, moving their children around
518     // (calling moveChildTo, moveAllChildrenTo, and makeChildrenNonInline).
519     friend class RenderRubyBase;
520 
521 private:
522     // Used to store state between styleWillChange and styleDidChange
523     static bool s_canPropagateFloatIntoSibling;
524 };
525 
526 LayoutUnit blockDirectionOffset(RenderBlock&amp; rootBlock, const LayoutSize&amp; offsetFromRootBlock);
527 LayoutUnit inlineDirectionOffset(RenderBlock&amp; rootBlock, const LayoutSize&amp; offsetFromRootBlock);
528 VisiblePosition positionForPointRespectingEditingBoundaries(RenderBlock&amp;, RenderBox&amp;, const LayoutPoint&amp;);
529 
530 inline RenderPtr&lt;RenderBlock&gt; RenderBlock::createAnonymousWithParentRendererAndDisplay(const RenderBox&amp; parent, DisplayType display)
531 {
532     return createAnonymousBlockWithStyleAndDisplay(parent.document(), parent.style(), display);
533 }
534 
535 inline RenderPtr&lt;RenderBox&gt; RenderBlock::createAnonymousBoxWithSameTypeAs(const RenderBox&amp; renderer) const
536 {
537     return createAnonymousBlockWithStyleAndDisplay(document(), renderer.style(), style().display());
538 }
539 
540 inline RenderPtr&lt;RenderBlock&gt; RenderBlock::createAnonymousBlock(DisplayType display) const
541 {
542     return createAnonymousBlockWithStyleAndDisplay(document(), style(), display);
543 }
544 
545 } // namespace WebCore
546 
547 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderBlock, isRenderBlock())
    </pre>
  </body>
</html>
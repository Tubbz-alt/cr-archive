<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCache.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="FontCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FontCascade.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/FontCache.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 69 typedef IMLangFontLink IMLangFontLinkType;
 70 #endif
 71 #endif
 72 
 73 // This key contains the FontDescription fields other than family that matter when fetching FontDatas (platform fonts).
 74 struct FontDescriptionKey {
 75     FontDescriptionKey() = default;
 76 
 77     FontDescriptionKey(const FontDescription&amp; description)
 78         : m_size(description.computedPixelSize())
 79         , m_fontSelectionRequest(description.fontSelectionRequest())
 80         , m_flags(makeFlagsKey(description))
 81         , m_locale(description.locale())
 82         , m_featureSettings(description.featureSettings())
 83 #if ENABLE(VARIATION_FONTS)
 84         , m_variationSettings(description.variationSettings())
 85 #endif
 86     { }
 87 
 88     explicit FontDescriptionKey(WTF::HashTableDeletedValueType)
<span class="line-modified"> 89         : m_size(cHashTableDeletedSize)</span>
 90     { }
 91 
 92     bool operator==(const FontDescriptionKey&amp; other) const
 93     {
<span class="line-modified"> 94         return m_size == other.m_size</span>

 95             &amp;&amp; m_fontSelectionRequest == other.m_fontSelectionRequest
 96             &amp;&amp; m_flags == other.m_flags
 97             &amp;&amp; m_locale == other.m_locale
 98 #if ENABLE(VARIATION_FONTS)
 99             &amp;&amp; m_variationSettings == other.m_variationSettings
100 #endif
101             &amp;&amp; m_featureSettings == other.m_featureSettings;
102     }
103 
104     bool operator!=(const FontDescriptionKey&amp; other) const
105     {
106         return !(*this == other);
107     }
108 
<span class="line-modified">109     bool isHashTableDeletedValue() const { return m_size == cHashTableDeletedSize; }</span>
110 
111     inline unsigned computeHash() const
112     {
113         IntegerHasher hasher;
114         hasher.add(m_size);
115         hasher.add(m_fontSelectionRequest.weight);
116         hasher.add(m_fontSelectionRequest.width);
117         hasher.add(m_fontSelectionRequest.slope.valueOr(normalItalicValue()));
118         hasher.add(m_locale.existingHash());
119         for (unsigned flagItem : m_flags)
120             hasher.add(flagItem);
121         hasher.add(m_featureSettings.hash());
122 #if ENABLE(VARIATION_FONTS)
123         hasher.add(m_variationSettings.hash());
124 #endif
125         return hasher.hash();
126     }
127 
128 private:
129     static std::array&lt;unsigned, 2&gt; makeFlagsKey(const FontDescription&amp; description)
130     {
<span class="line-modified">131         unsigned first = static_cast&lt;unsigned&gt;(description.script()) &lt;&lt; 15</span>
<span class="line-removed">132             | static_cast&lt;unsigned&gt;(description.shouldAllowDesignSystemUIFonts()) &lt;&lt; 14</span>
133             | static_cast&lt;unsigned&gt;(description.shouldAllowUserInstalledFonts()) &lt;&lt; 13
134             | static_cast&lt;unsigned&gt;(description.fontStyleAxis() == FontStyleAxis::slnt) &lt;&lt; 12
135             | static_cast&lt;unsigned&gt;(description.opticalSizing()) &lt;&lt; 11
136             | static_cast&lt;unsigned&gt;(description.textRenderingMode()) &lt;&lt; 9
137             | static_cast&lt;unsigned&gt;(description.fontSynthesis()) &lt;&lt; 6
138             | static_cast&lt;unsigned&gt;(description.widthVariant()) &lt;&lt; 4
139             | static_cast&lt;unsigned&gt;(description.nonCJKGlyphOrientation()) &lt;&lt; 3
140             | static_cast&lt;unsigned&gt;(description.orientation()) &lt;&lt; 2
141             | static_cast&lt;unsigned&gt;(description.renderingMode());
142         unsigned second = static_cast&lt;unsigned&gt;(description.variantEastAsianRuby()) &lt;&lt; 27
143             | static_cast&lt;unsigned&gt;(description.variantEastAsianWidth()) &lt;&lt; 25
144             | static_cast&lt;unsigned&gt;(description.variantEastAsianVariant()) &lt;&lt; 22
145             | static_cast&lt;unsigned&gt;(description.variantAlternates()) &lt;&lt; 21
146             | static_cast&lt;unsigned&gt;(description.variantNumericSlashedZero()) &lt;&lt; 20
147             | static_cast&lt;unsigned&gt;(description.variantNumericOrdinal()) &lt;&lt; 19
148             | static_cast&lt;unsigned&gt;(description.variantNumericFraction()) &lt;&lt; 17
149             | static_cast&lt;unsigned&gt;(description.variantNumericSpacing()) &lt;&lt; 15
150             | static_cast&lt;unsigned&gt;(description.variantNumericFigure()) &lt;&lt; 13
151             | static_cast&lt;unsigned&gt;(description.variantCaps()) &lt;&lt; 10
152             | static_cast&lt;unsigned&gt;(description.variantPosition()) &lt;&lt; 8
153             | static_cast&lt;unsigned&gt;(description.variantContextualAlternates()) &lt;&lt; 6
154             | static_cast&lt;unsigned&gt;(description.variantHistoricalLigatures()) &lt;&lt; 4
155             | static_cast&lt;unsigned&gt;(description.variantDiscretionaryLigatures()) &lt;&lt; 2
156             | static_cast&lt;unsigned&gt;(description.variantCommonLigatures());
157         return {{ first, second }};
158     }
159 
<span class="line-removed">160     static const unsigned cHashTableDeletedSize = 0xFFFFFFFFU;</span>
<span class="line-removed">161 </span>
162     // FontCascade::locale() is explicitly not included in this struct.

163     unsigned m_size { 0 };
164     FontSelectionRequest m_fontSelectionRequest;
165     std::array&lt;unsigned, 2&gt; m_flags {{ 0, 0 }};
166     AtomString m_locale;
167     FontFeatureSettings m_featureSettings;
168 #if ENABLE(VARIATION_FONTS)
169     FontVariationSettings m_variationSettings;
170 #endif
171 };
172 
173 struct FontDescriptionKeyHash {
174     static unsigned hash(const FontDescriptionKey&amp; key)
175     {
176         return key.computeHash();
177     }
178 
179     static bool equal(const FontDescriptionKey&amp; a, const FontDescriptionKey&amp; b)
180     {
181         return a == b;
182     }
</pre>
<hr />
<pre>
196     RefPtr&lt;Font&gt; systemFallbackForCharacters(const FontDescription&amp;, const Font* originalFontData, IsForPlatformFont, PreferColoredFont, const UChar* characters, unsigned length);
197     Vector&lt;String&gt; systemFontFamilies();
198     void platformInit();
199 
200     static bool isSystemFontForbiddenForEditing(const String&amp;);
201 
202 #if PLATFORM(COCOA)
203     WEBCORE_EXPORT static void setFontWhitelist(const Vector&lt;String&gt;&amp;);
204 #endif
205 #if PLATFORM(WIN)
206     IMLangFontLinkType* getFontLinkInterface();
207     static void comInitialize();
208     static void comUninitialize();
209     static IMultiLanguage* getMultiLanguageInterface();
210 #endif
211 
212     // This function exists so CSSFontSelector can have a unified notion of preinstalled fonts and @font-face.
213     // It comes into play when you create an @font-face which shares a family name as a preinstalled font.
214     Vector&lt;FontSelectionCapabilities&gt; getFontSelectionCapabilitiesInFamily(const AtomString&amp;, AllowUserInstalledFonts);
215 
<span class="line-modified">216     WEBCORE_EXPORT RefPtr&lt;Font&gt; fontForFamily(const FontDescription&amp;, const AtomString&amp;, const FontFeatureSettings* fontFaceFeatures = nullptr, const FontVariantSettings* fontFaceVariantSettings = nullptr, FontSelectionSpecifiedCapabilities fontFaceCapabilities = { }, bool checkingAlternateName = false);</span>
217     WEBCORE_EXPORT Ref&lt;Font&gt; lastResortFallbackFont(const FontDescription&amp;);
218     WEBCORE_EXPORT Ref&lt;Font&gt; fontForPlatformData(const FontPlatformData&amp;);
219     RefPtr&lt;Font&gt; similarFont(const FontDescription&amp;, const AtomString&amp; family);
220 
221     void addClient(FontSelector&amp;);
222     void removeClient(FontSelector&amp;);
223 
224     unsigned short generation();
225     WEBCORE_EXPORT void invalidate();
226 
227     WEBCORE_EXPORT size_t fontCount();
228     WEBCORE_EXPORT size_t inactiveFontCount();
229     WEBCORE_EXPORT void purgeInactiveFontData(unsigned count = UINT_MAX);
230     void platformPurgeInactiveFontData();
231 
232 #if PLATFORM(WIN)
233     RefPtr&lt;Font&gt; fontFromDescriptionAndLogFont(const FontDescription&amp;, const LOGFONT&amp;, AtomString&amp; outFontFamilyName);
234 #endif
235 
236 #if ENABLE(OPENTYPE_VERTICAL)
</pre>
<hr />
<pre>
246         Vector&lt;String&gt; seenFamilies;
247         Vector&lt;String&gt; fontNamesRequiringSystemFallback;
248 
249         bool isEmpty() const;
250         PrewarmInformation isolatedCopy() const;
251 
252         template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
253         template&lt;class Decoder&gt; static Optional&lt;PrewarmInformation&gt; decode(Decoder&amp;);
254     };
255     PrewarmInformation collectPrewarmInformation() const;
256     void prewarm(const PrewarmInformation&amp;);
257     void prewarmGlobally();
258 
259 private:
260     FontCache();
261     ~FontCache() = delete;
262 
263     WEBCORE_EXPORT void purgeInactiveFontDataIfNeeded();
264 
265     // FIXME: This method should eventually be removed.
<span class="line-modified">266     FontPlatformData* getCachedFontPlatformData(const FontDescription&amp;, const AtomString&amp; family, const FontFeatureSettings* fontFaceFeatures = nullptr, const FontVariantSettings* fontFaceVariantSettings = nullptr, FontSelectionSpecifiedCapabilities fontFaceCapabilities = { }, bool checkingAlternateName = false);</span>
267 
268     // These methods are implemented by each platform.
269 #if PLATFORM(COCOA)
270     FontPlatformData* getCustomFallbackFont(const UInt32, const FontDescription&amp;);
271 #endif
<span class="line-modified">272     WEBCORE_EXPORT std::unique_ptr&lt;FontPlatformData&gt; createFontPlatformData(const FontDescription&amp;, const AtomString&amp; family, const FontFeatureSettings* fontFaceFeatures, const FontVariantSettings* fontFaceVariantSettings, FontSelectionSpecifiedCapabilities fontFaceCapabilities);</span>
273 
274     static const AtomString&amp; alternateFamilyName(const AtomString&amp;);
275     static const AtomString&amp; platformAlternateFamilyName(const AtomString&amp;);
276 
277     Timer m_purgeTimer;
278 
279     bool m_shouldMockBoldSystemFontForAccessibility { false };
280 
281 #if PLATFORM(COCOA)
282     ListHashSet&lt;String&gt; m_seenFamiliesForPrewarming;
283     ListHashSet&lt;String&gt; m_fontNamesRequiringSystemFallbackForPrewarming;
284     RefPtr&lt;WorkQueue&gt; m_prewarmQueue;
285 
286     friend class ComplexTextController;
287 #endif
288     friend class Font;
289 };
290 
291 inline std::unique_ptr&lt;FontPlatformData&gt; FontCache::createFontPlatformDataForTesting(const FontDescription&amp; fontDescription, const AtomString&amp; family)
292 {
<span class="line-modified">293     return createFontPlatformData(fontDescription, family, nullptr, nullptr, { });</span>
294 }
295 
296 #if !PLATFORM(COCOA) &amp;&amp; !USE(FREETYPE)
297 
298 inline void FontCache::platformPurgeInactiveFontData()
299 {
300 }
301 
302 #endif
303 
304 
305 inline bool FontCache::PrewarmInformation::isEmpty() const
306 {
307     return seenFamilies.isEmpty() &amp;&amp; fontNamesRequiringSystemFallback.isEmpty();
308 }
309 
310 inline FontCache::PrewarmInformation FontCache::PrewarmInformation::isolatedCopy() const
311 {
312     return { seenFamilies.isolatedCopy(), fontNamesRequiringSystemFallback.isolatedCopy() };
313 }
</pre>
</td>
<td>
<hr />
<pre>
 69 typedef IMLangFontLink IMLangFontLinkType;
 70 #endif
 71 #endif
 72 
 73 // This key contains the FontDescription fields other than family that matter when fetching FontDatas (platform fonts).
 74 struct FontDescriptionKey {
 75     FontDescriptionKey() = default;
 76 
 77     FontDescriptionKey(const FontDescription&amp; description)
 78         : m_size(description.computedPixelSize())
 79         , m_fontSelectionRequest(description.fontSelectionRequest())
 80         , m_flags(makeFlagsKey(description))
 81         , m_locale(description.locale())
 82         , m_featureSettings(description.featureSettings())
 83 #if ENABLE(VARIATION_FONTS)
 84         , m_variationSettings(description.variationSettings())
 85 #endif
 86     { }
 87 
 88     explicit FontDescriptionKey(WTF::HashTableDeletedValueType)
<span class="line-modified"> 89         : m_isDeletedValue(true)</span>
 90     { }
 91 
 92     bool operator==(const FontDescriptionKey&amp; other) const
 93     {
<span class="line-modified"> 94         return m_isDeletedValue == other.m_isDeletedValue</span>
<span class="line-added"> 95             &amp;&amp; m_size == other.m_size</span>
 96             &amp;&amp; m_fontSelectionRequest == other.m_fontSelectionRequest
 97             &amp;&amp; m_flags == other.m_flags
 98             &amp;&amp; m_locale == other.m_locale
 99 #if ENABLE(VARIATION_FONTS)
100             &amp;&amp; m_variationSettings == other.m_variationSettings
101 #endif
102             &amp;&amp; m_featureSettings == other.m_featureSettings;
103     }
104 
105     bool operator!=(const FontDescriptionKey&amp; other) const
106     {
107         return !(*this == other);
108     }
109 
<span class="line-modified">110     bool isHashTableDeletedValue() const { return m_isDeletedValue; }</span>
111 
112     inline unsigned computeHash() const
113     {
114         IntegerHasher hasher;
115         hasher.add(m_size);
116         hasher.add(m_fontSelectionRequest.weight);
117         hasher.add(m_fontSelectionRequest.width);
118         hasher.add(m_fontSelectionRequest.slope.valueOr(normalItalicValue()));
119         hasher.add(m_locale.existingHash());
120         for (unsigned flagItem : m_flags)
121             hasher.add(flagItem);
122         hasher.add(m_featureSettings.hash());
123 #if ENABLE(VARIATION_FONTS)
124         hasher.add(m_variationSettings.hash());
125 #endif
126         return hasher.hash();
127     }
128 
129 private:
130     static std::array&lt;unsigned, 2&gt; makeFlagsKey(const FontDescription&amp; description)
131     {
<span class="line-modified">132         unsigned first = static_cast&lt;unsigned&gt;(description.script()) &lt;&lt; 14</span>

133             | static_cast&lt;unsigned&gt;(description.shouldAllowUserInstalledFonts()) &lt;&lt; 13
134             | static_cast&lt;unsigned&gt;(description.fontStyleAxis() == FontStyleAxis::slnt) &lt;&lt; 12
135             | static_cast&lt;unsigned&gt;(description.opticalSizing()) &lt;&lt; 11
136             | static_cast&lt;unsigned&gt;(description.textRenderingMode()) &lt;&lt; 9
137             | static_cast&lt;unsigned&gt;(description.fontSynthesis()) &lt;&lt; 6
138             | static_cast&lt;unsigned&gt;(description.widthVariant()) &lt;&lt; 4
139             | static_cast&lt;unsigned&gt;(description.nonCJKGlyphOrientation()) &lt;&lt; 3
140             | static_cast&lt;unsigned&gt;(description.orientation()) &lt;&lt; 2
141             | static_cast&lt;unsigned&gt;(description.renderingMode());
142         unsigned second = static_cast&lt;unsigned&gt;(description.variantEastAsianRuby()) &lt;&lt; 27
143             | static_cast&lt;unsigned&gt;(description.variantEastAsianWidth()) &lt;&lt; 25
144             | static_cast&lt;unsigned&gt;(description.variantEastAsianVariant()) &lt;&lt; 22
145             | static_cast&lt;unsigned&gt;(description.variantAlternates()) &lt;&lt; 21
146             | static_cast&lt;unsigned&gt;(description.variantNumericSlashedZero()) &lt;&lt; 20
147             | static_cast&lt;unsigned&gt;(description.variantNumericOrdinal()) &lt;&lt; 19
148             | static_cast&lt;unsigned&gt;(description.variantNumericFraction()) &lt;&lt; 17
149             | static_cast&lt;unsigned&gt;(description.variantNumericSpacing()) &lt;&lt; 15
150             | static_cast&lt;unsigned&gt;(description.variantNumericFigure()) &lt;&lt; 13
151             | static_cast&lt;unsigned&gt;(description.variantCaps()) &lt;&lt; 10
152             | static_cast&lt;unsigned&gt;(description.variantPosition()) &lt;&lt; 8
153             | static_cast&lt;unsigned&gt;(description.variantContextualAlternates()) &lt;&lt; 6
154             | static_cast&lt;unsigned&gt;(description.variantHistoricalLigatures()) &lt;&lt; 4
155             | static_cast&lt;unsigned&gt;(description.variantDiscretionaryLigatures()) &lt;&lt; 2
156             | static_cast&lt;unsigned&gt;(description.variantCommonLigatures());
157         return {{ first, second }};
158     }
159 


160     // FontCascade::locale() is explicitly not included in this struct.
<span class="line-added">161     bool m_isDeletedValue { false };</span>
162     unsigned m_size { 0 };
163     FontSelectionRequest m_fontSelectionRequest;
164     std::array&lt;unsigned, 2&gt; m_flags {{ 0, 0 }};
165     AtomString m_locale;
166     FontFeatureSettings m_featureSettings;
167 #if ENABLE(VARIATION_FONTS)
168     FontVariationSettings m_variationSettings;
169 #endif
170 };
171 
172 struct FontDescriptionKeyHash {
173     static unsigned hash(const FontDescriptionKey&amp; key)
174     {
175         return key.computeHash();
176     }
177 
178     static bool equal(const FontDescriptionKey&amp; a, const FontDescriptionKey&amp; b)
179     {
180         return a == b;
181     }
</pre>
<hr />
<pre>
195     RefPtr&lt;Font&gt; systemFallbackForCharacters(const FontDescription&amp;, const Font* originalFontData, IsForPlatformFont, PreferColoredFont, const UChar* characters, unsigned length);
196     Vector&lt;String&gt; systemFontFamilies();
197     void platformInit();
198 
199     static bool isSystemFontForbiddenForEditing(const String&amp;);
200 
201 #if PLATFORM(COCOA)
202     WEBCORE_EXPORT static void setFontWhitelist(const Vector&lt;String&gt;&amp;);
203 #endif
204 #if PLATFORM(WIN)
205     IMLangFontLinkType* getFontLinkInterface();
206     static void comInitialize();
207     static void comUninitialize();
208     static IMultiLanguage* getMultiLanguageInterface();
209 #endif
210 
211     // This function exists so CSSFontSelector can have a unified notion of preinstalled fonts and @font-face.
212     // It comes into play when you create an @font-face which shares a family name as a preinstalled font.
213     Vector&lt;FontSelectionCapabilities&gt; getFontSelectionCapabilitiesInFamily(const AtomString&amp;, AllowUserInstalledFonts);
214 
<span class="line-modified">215     WEBCORE_EXPORT RefPtr&lt;Font&gt; fontForFamily(const FontDescription&amp;, const AtomString&amp;, const FontFeatureSettings* fontFaceFeatures = nullptr, FontSelectionSpecifiedCapabilities fontFaceCapabilities = { }, bool checkingAlternateName = false);</span>
216     WEBCORE_EXPORT Ref&lt;Font&gt; lastResortFallbackFont(const FontDescription&amp;);
217     WEBCORE_EXPORT Ref&lt;Font&gt; fontForPlatformData(const FontPlatformData&amp;);
218     RefPtr&lt;Font&gt; similarFont(const FontDescription&amp;, const AtomString&amp; family);
219 
220     void addClient(FontSelector&amp;);
221     void removeClient(FontSelector&amp;);
222 
223     unsigned short generation();
224     WEBCORE_EXPORT void invalidate();
225 
226     WEBCORE_EXPORT size_t fontCount();
227     WEBCORE_EXPORT size_t inactiveFontCount();
228     WEBCORE_EXPORT void purgeInactiveFontData(unsigned count = UINT_MAX);
229     void platformPurgeInactiveFontData();
230 
231 #if PLATFORM(WIN)
232     RefPtr&lt;Font&gt; fontFromDescriptionAndLogFont(const FontDescription&amp;, const LOGFONT&amp;, AtomString&amp; outFontFamilyName);
233 #endif
234 
235 #if ENABLE(OPENTYPE_VERTICAL)
</pre>
<hr />
<pre>
245         Vector&lt;String&gt; seenFamilies;
246         Vector&lt;String&gt; fontNamesRequiringSystemFallback;
247 
248         bool isEmpty() const;
249         PrewarmInformation isolatedCopy() const;
250 
251         template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
252         template&lt;class Decoder&gt; static Optional&lt;PrewarmInformation&gt; decode(Decoder&amp;);
253     };
254     PrewarmInformation collectPrewarmInformation() const;
255     void prewarm(const PrewarmInformation&amp;);
256     void prewarmGlobally();
257 
258 private:
259     FontCache();
260     ~FontCache() = delete;
261 
262     WEBCORE_EXPORT void purgeInactiveFontDataIfNeeded();
263 
264     // FIXME: This method should eventually be removed.
<span class="line-modified">265     FontPlatformData* getCachedFontPlatformData(const FontDescription&amp;, const AtomString&amp; family, const FontFeatureSettings* fontFaceFeatures = nullptr, FontSelectionSpecifiedCapabilities fontFaceCapabilities = { }, bool checkingAlternateName = false);</span>
266 
267     // These methods are implemented by each platform.
268 #if PLATFORM(COCOA)
269     FontPlatformData* getCustomFallbackFont(const UInt32, const FontDescription&amp;);
270 #endif
<span class="line-modified">271     WEBCORE_EXPORT std::unique_ptr&lt;FontPlatformData&gt; createFontPlatformData(const FontDescription&amp;, const AtomString&amp; family, const FontFeatureSettings* fontFaceFeatures, FontSelectionSpecifiedCapabilities fontFaceCapabilities);</span>
272 
273     static const AtomString&amp; alternateFamilyName(const AtomString&amp;);
274     static const AtomString&amp; platformAlternateFamilyName(const AtomString&amp;);
275 
276     Timer m_purgeTimer;
277 
278     bool m_shouldMockBoldSystemFontForAccessibility { false };
279 
280 #if PLATFORM(COCOA)
281     ListHashSet&lt;String&gt; m_seenFamiliesForPrewarming;
282     ListHashSet&lt;String&gt; m_fontNamesRequiringSystemFallbackForPrewarming;
283     RefPtr&lt;WorkQueue&gt; m_prewarmQueue;
284 
285     friend class ComplexTextController;
286 #endif
287     friend class Font;
288 };
289 
290 inline std::unique_ptr&lt;FontPlatformData&gt; FontCache::createFontPlatformDataForTesting(const FontDescription&amp; fontDescription, const AtomString&amp; family)
291 {
<span class="line-modified">292     return createFontPlatformData(fontDescription, family, nullptr, { });</span>
293 }
294 
295 #if !PLATFORM(COCOA) &amp;&amp; !USE(FREETYPE)
296 
297 inline void FontCache::platformPurgeInactiveFontData()
298 {
299 }
300 
301 #endif
302 
303 
304 inline bool FontCache::PrewarmInformation::isEmpty() const
305 {
306     return seenFamilies.isEmpty() &amp;&amp; fontNamesRequiringSystemFallback.isEmpty();
307 }
308 
309 inline FontCache::PrewarmInformation FontCache::PrewarmInformation::isolatedCopy() const
310 {
311     return { seenFamilies.isolatedCopy(), fontNamesRequiringSystemFallback.isolatedCopy() };
312 }
</pre>
</td>
</tr>
</table>
<center><a href="FontCache.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="FontCascade.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
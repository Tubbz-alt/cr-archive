<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/platform/PODIntervalTree.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2010 Google Inc. All rights reserved.
<a name="1" id="anc1"></a><span class="line-added">  3  * Copyright (C) 2019-2020 Apple Inc. All rights reserved.</span>
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  *
  9  * 1.  Redistributions of source code must retain the above copyright
 10  *     notice, this list of conditions and the following disclaimer.
 11  * 2.  Redistributions in binary form must reproduce the above copyright
 12  *     notice, this list of conditions and the following disclaimer in the
 13  *     documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 16  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 17  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 18  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 19  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 22  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 24  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
<a name="2" id="anc2"></a><span class="line-modified"> 27 #pragma once</span>

 28 
 29 #include &quot;PODInterval.h&quot;
 30 #include &quot;PODRedBlackTree.h&quot;
<a name="3" id="anc3"></a>

 31 #include &lt;wtf/Optional.h&gt;
 32 #include &lt;wtf/Vector.h&gt;
<a name="4" id="anc4"></a>
 33 
<a name="5" id="anc5"></a><span class="line-modified"> 34 // FIXME: The prefix &quot;POD&quot; here isn&#39;t correct; this tree works with non-POD types.</span>





 35 
<a name="6" id="anc6"></a><span class="line-modified"> 36 namespace WebCore {</span>













 37 
<a name="7" id="anc7"></a><span class="line-modified"> 38 struct PODIntervalNodeUpdater;</span>




 39 
 40 // An interval tree, which is a form of augmented red-black tree. It
 41 // supports efficient (O(lg n)) insertion, removal and querying of
 42 // intervals in the tree.
<a name="8" id="anc8"></a><span class="line-modified"> 43 template&lt;typename T, typename UserData&gt; class PODIntervalTree final : public PODRedBlackTree&lt;PODInterval&lt;T, UserData&gt;, PODIntervalNodeUpdater&gt; {</span>

 44     WTF_MAKE_FAST_ALLOCATED;
<a name="9" id="anc9"></a>
 45 public:
<a name="10" id="anc10"></a><span class="line-modified"> 46     using IntervalType = PODInterval&lt;T, UserData&gt;;</span>
<span class="line-modified"> 47     class OverlapsSearchAdapter;</span>








 48 
<a name="11" id="anc11"></a><span class="line-modified"> 49     // Returns all intervals in the tree which overlap the given query interval, sorted by the &lt; operator.</span>


 50     Vector&lt;IntervalType&gt; allOverlaps(const IntervalType&amp; interval) const
 51     {
 52         Vector&lt;IntervalType&gt; result;
<a name="12" id="anc12"></a><span class="line-modified"> 53         OverlapsSearchAdapter adapter(result, interval);</span>
<span class="line-added"> 54         allOverlapsWithAdapter(adapter);</span>
 55         return result;
 56     }
 57 
<a name="13" id="anc13"></a><span class="line-modified"> 58     template&lt;typename AdapterType&gt; void allOverlapsWithAdapter(AdapterType&amp; adapter) const</span>












 59     {
<a name="14" id="anc14"></a><span class="line-modified"> 60         searchForOverlapsFrom(this-&gt;root(), adapter);</span>


 61     }
 62 
<a name="15" id="anc15"></a><span class="line-modified"> 63     Optional&lt;IntervalType&gt; nextIntervalAfter(const T&amp; point)</span>

 64     {
<a name="16" id="anc16"></a><span class="line-modified"> 65         auto next = smallestNodeGreaterThanFrom(point, this-&gt;root());</span>





 66         if (!next)
 67             return WTF::nullopt;
<a name="17" id="anc17"></a>
 68         return next-&gt;data();
 69     }
 70 
<a name="18" id="anc18"></a><span class="line-modified"> 71 #ifndef NDEBUG</span>
<span class="line-added"> 72 </span>
<span class="line-added"> 73     bool checkInvariants() const</span>
 74     {
<a name="19" id="anc19"></a><span class="line-modified"> 75         if (!Base::checkInvariants())</span>
 76             return false;
 77         if (!this-&gt;root())
 78             return true;
<a name="20" id="anc20"></a><span class="line-modified"> 79         return checkInvariantsFromNode(this-&gt;root(), nullptr);</span>
 80     }
 81 
<a name="21" id="anc21"></a><span class="line-modified"> 82 #endif</span>

 83 
<a name="22" id="anc22"></a><span class="line-modified"> 84 private:</span>
<span class="line-modified"> 85     using Base = PODRedBlackTree&lt;PODInterval&lt;T, UserData&gt;, PODIntervalNodeUpdater&gt;;</span>
<span class="line-modified"> 86     using IntervalNode = typename Base::Node;</span>




 87 
 88     // Starting from the given node, adds all overlaps with the given
 89     // interval to the result vector. The intervals are sorted by
 90     // increasing low endpoint.
<a name="23" id="anc23"></a><span class="line-modified"> 91     template&lt;typename AdapterType&gt; void searchForOverlapsFrom(IntervalNode* node, AdapterType&amp; adapter) const</span>

 92     {
 93         if (!node)
 94             return;
 95 
 96         // Because the intervals are sorted by left endpoint, inorder
 97         // traversal produces results sorted as desired.
 98 
 99         // See whether we need to traverse the left subtree.
100         IntervalNode* left = node-&gt;left();
101         if (left
102             // This is phrased this way to avoid the need for operator
103             // &lt;= on type T.
104             &amp;&amp; !(left-&gt;data().maxHigh() &lt; adapter.lowValue()))
105             searchForOverlapsFrom&lt;AdapterType&gt;(left, adapter);
106 
107         // Check for overlap with current node.
108         adapter.collectIfNeeded(node-&gt;data());
109 
110         // See whether we need to traverse the right subtree.
111         // This is phrased this way to avoid the need for operator &lt;=
112         // on type T.
113         if (!(adapter.highValue() &lt; node-&gt;data().low()))
114             searchForOverlapsFrom&lt;AdapterType&gt;(node-&gt;right(), adapter);
115     }
116 
<a name="24" id="anc24"></a><span class="line-modified">117     IntervalNode* smallestNodeGreaterThanFrom(const T&amp; point, IntervalNode* node) const</span>
118     {
119         if (!node)
120             return nullptr;
121 
<a name="25" id="anc25"></a><span class="line-modified">122         if (!(point &lt; node-&gt;data().low()))</span>
<span class="line-modified">123             return smallestNodeGreaterThanFrom(point, node-&gt;right());</span>
124 
<a name="26" id="anc26"></a><span class="line-modified">125         if (auto left = smallestNodeGreaterThanFrom(point, node-&gt;right()))</span>
126             return left;
127 
128         return node;
<a name="27" id="anc27"></a>






















129     }
130 
<a name="28" id="anc28"></a><span class="line-added">131 #ifndef NDEBUG</span>
<span class="line-added">132 </span>
133     bool checkInvariantsFromNode(IntervalNode* node, T* currentMaxValue) const
134     {
135         // These assignments are only done in order to avoid requiring
136         // a default constructor on type T.
137         T leftMaxValue(node-&gt;data().maxHigh());
138         T rightMaxValue(node-&gt;data().maxHigh());
139         IntervalNode* left = node-&gt;left();
140         IntervalNode* right = node-&gt;right();
141         if (left) {
142             if (!checkInvariantsFromNode(left, &amp;leftMaxValue))
143                 return false;
144         }
145         if (right) {
146             if (!checkInvariantsFromNode(right, &amp;rightMaxValue))
147                 return false;
148         }
149         if (!left &amp;&amp; !right) {
150             // Base case.
151             if (currentMaxValue)
152                 *currentMaxValue = node-&gt;data().high();
153             return (node-&gt;data().high() == node-&gt;data().maxHigh());
154         }
155         T localMaxValue(node-&gt;data().maxHigh());
156         if (!left || !right) {
157             if (left)
158                 localMaxValue = leftMaxValue;
159             else
160                 localMaxValue = rightMaxValue;
161         } else
162             localMaxValue = (leftMaxValue &lt; rightMaxValue) ? rightMaxValue : leftMaxValue;
163         if (localMaxValue &lt; node-&gt;data().high())
164             localMaxValue = node-&gt;data().high();
165         if (!(localMaxValue == node-&gt;data().maxHigh())) {
<a name="29" id="anc29"></a><span class="line-modified">166             TextStream stream;</span>
<span class="line-modified">167             stream &lt;&lt; &quot;localMaxValue=&quot; &lt;&lt; localMaxValue &lt;&lt; &quot;and data =&quot; &lt;&lt; node-&gt;data();</span>
<span class="line-modified">168             LOG_ERROR(&quot;PODIntervalTree verification failed at node 0x%p: %s&quot;,</span>
<span class="line-modified">169                 node, stream.release().utf8().data());</span>

170             return false;
171         }
172         if (currentMaxValue)
173             *currentMaxValue = localMaxValue;
174         return true;
175     }
<a name="30" id="anc30"></a><span class="line-added">176 </span>
<span class="line-added">177 #endif</span>
<span class="line-added">178 </span>
179 };
180 
<a name="31" id="anc31"></a><span class="line-modified">181 template&lt;typename T, typename UserData&gt; class PODIntervalTree&lt;T, UserData&gt;::OverlapsSearchAdapter {</span>
<span class="line-added">182 public:</span>
<span class="line-added">183     using IntervalType = PODInterval&lt;T, UserData&gt;;</span>
184 
<a name="32" id="anc32"></a><span class="line-modified">185     OverlapsSearchAdapter(Vector&lt;IntervalType&gt;&amp; result, const IntervalType&amp; interval)</span>
<span class="line-modified">186         : m_result(result)</span>
<span class="line-added">187         , m_interval(interval)</span>
<span class="line-added">188     {</span>
<span class="line-added">189     }</span>
190 
<a name="33" id="anc33"></a><span class="line-modified">191     const T&amp; lowValue() const { return m_interval.low(); }</span>
<span class="line-modified">192     const T&amp; highValue() const { return m_interval.high(); }</span>
<span class="line-modified">193     void collectIfNeeded(const IntervalType&amp; data) const</span>

194     {
<a name="34" id="anc34"></a><span class="line-modified">195         if (data.overlaps(m_interval))</span>
<span class="line-added">196             m_result.append(data);</span>
197     }
<a name="35" id="anc35"></a><span class="line-added">198 </span>
<span class="line-added">199 private:</span>
<span class="line-added">200     Vector&lt;IntervalType&gt;&amp; m_result;</span>
<span class="line-added">201     const IntervalType&amp; m_interval;</span>
202 };
203 
<a name="36" id="anc36"></a><span class="line-modified">204 struct PODIntervalNodeUpdater {</span>
<span class="line-modified">205     template&lt;typename Node&gt; static bool update(Node&amp; node)</span>
<span class="line-added">206     {</span>
<span class="line-added">207         auto* curMax = &amp;node.data().high();</span>
<span class="line-added">208         auto* left = node.left();</span>
<span class="line-added">209         if (left) {</span>
<span class="line-added">210             if (*curMax &lt; left-&gt;data().maxHigh())</span>
<span class="line-added">211                 curMax = &amp;left-&gt;data().maxHigh();</span>
<span class="line-added">212         }</span>
<span class="line-added">213         auto* right = node.right();</span>
<span class="line-added">214         if (right) {</span>
<span class="line-added">215             if (*curMax &lt; right-&gt;data().maxHigh())</span>
<span class="line-added">216                 curMax = &amp;right-&gt;data().maxHigh();</span>
<span class="line-added">217         }</span>
<span class="line-added">218         // This is phrased like this to avoid needing operator!= on type T.</span>
<span class="line-added">219         if (!(*curMax == node.data().maxHigh())) {</span>
<span class="line-added">220             node.data().setMaxHigh(*curMax);</span>
<span class="line-added">221             return true;</span>
<span class="line-added">222         }</span>
<span class="line-added">223         return false;</span>
<span class="line-added">224     }</span>
<span class="line-added">225 };</span>
226 
<a name="37" id="anc37"></a><span class="line-modified">227 } // namespace WebCore</span>
<a name="38" id="anc38"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="38" type="hidden" />
</body>
</html>
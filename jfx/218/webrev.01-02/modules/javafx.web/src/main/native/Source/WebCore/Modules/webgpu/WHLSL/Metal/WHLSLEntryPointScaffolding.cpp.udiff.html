<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLEntryPointScaffolding.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../AST/WHLSLType.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLEntryPointScaffolding.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WHLSL/Metal/WHLSLEntryPointScaffolding.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -137,37 +137,55 @@</span>
      m_parameterVariables.reserveInitialCapacity(m_functionDefinition.parameters().size());
      for (size_t i = 0; i &lt; m_functionDefinition.parameters().size(); ++i)
          m_parameterVariables.uncheckedAppend(m_generateNextVariableName());
  }
  
<span class="udiff-line-modified-removed">- void EntryPointScaffolding::emitResourceHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)</span>
<span class="udiff-line-modified-added">+ void EntryPointScaffolding::emitResourceHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent, ShaderStage shaderStage)</span>
  {
      for (size_t i = 0; i &lt; m_layout.size(); ++i) {
          stringBuilder.append(indent, &quot;struct &quot;, m_namedBindGroups[i].structName, &quot; {\n&quot;);
          {
              IndentationScope scope(indent);
              Vector&lt;std::pair&lt;unsigned, String&gt;&gt; structItems;
              for (size_t j = 0; j &lt; m_layout[i].bindings.size(); ++j) {
<span class="udiff-line-modified-removed">-                 auto iterator = m_resourceMap.find(&amp;m_layout[i].bindings[j]);</span>
<span class="udiff-line-modified-removed">-                 if (iterator == m_resourceMap.end())</span>
<span class="udiff-line-modified-added">+                 auto&amp; binding = m_layout[i].bindings[j];</span>
<span class="udiff-line-modified-added">+                 if (!binding.visibility.contains(shaderStage))</span>
                      continue;
<span class="udiff-line-modified-removed">-                 auto&amp; type = m_entryPointItems.inputs[iterator-&gt;value].unnamedType-&gt;unifyNode();</span>
<span class="udiff-line-modified-removed">-                 if (is&lt;AST::UnnamedType&gt;(type) &amp;&amp; is&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(type))) {</span>
<span class="udiff-line-modified-removed">-                     auto&amp; referenceType = downcast&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(type));</span>
<span class="udiff-line-modified-removed">-                     auto mangledTypeName = m_typeNamer.mangledNameForType(referenceType.elementType());</span>
<span class="udiff-line-modified-removed">-                     auto addressSpace = toString(referenceType.addressSpace());</span>
<span class="udiff-line-modified-removed">-                     auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;</span>
<span class="udiff-line-modified-removed">-                     auto index = m_namedBindGroups[i].namedBindings[j].index;</span>
<span class="udiff-line-modified-removed">-                     structItems.append(std::make_pair(index, makeString(addressSpace, &quot; &quot;, mangledTypeName, &quot;* &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="udiff-line-modified-removed">-                     if (auto lengthInformation = m_namedBindGroups[i].namedBindings[j].lengthInformation)</span>
<span class="udiff-line-modified-removed">-                         structItems.append(std::make_pair(lengthInformation-&gt;index, makeString(&quot;uint2 &quot;, lengthInformation-&gt;elementName, &quot; [[id(&quot;, lengthInformation-&gt;index, &quot;)]];&quot;)));</span>
<span class="udiff-line-modified-removed">-                 } else if (is&lt;AST::NamedType&gt;(type) &amp;&amp; is&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(type))) {</span>
<span class="udiff-line-modified-removed">-                     auto&amp; namedType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(type));</span>
<span class="udiff-line-modified-removed">-                     auto mangledTypeName = m_typeNamer.mangledNameForType(namedType);</span>
<span class="udiff-line-modified-removed">-                     auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;</span>
<span class="udiff-line-modified-removed">-                     auto index = m_namedBindGroups[i].namedBindings[j].index;</span>
<span class="udiff-line-modified-removed">-                     structItems.append(std::make_pair(index, makeString(mangledTypeName, &#39; &#39;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                 auto elementName = m_namedBindGroups[i].namedBindings[j].elementName;</span>
<span class="udiff-line-modified-added">+                 auto index = m_namedBindGroups[i].namedBindings[j].index;</span>
<span class="udiff-line-modified-added">+                 if (auto lengthInformation = m_namedBindGroups[i].namedBindings[j].lengthInformation)</span>
<span class="udiff-line-modified-added">+                     structItems.append(std::make_pair(lengthInformation-&gt;index, makeString(&quot;uint2 &quot;, lengthInformation-&gt;elementName, &quot; [[id(&quot;, lengthInformation-&gt;index, &quot;)]];&quot;)));</span>
<span class="udiff-line-modified-added">+ </span>
<span class="udiff-line-modified-added">+                 auto iterator = m_resourceMap.find(&amp;m_layout[i].bindings[j]);</span>
<span class="udiff-line-modified-added">+                 if (iterator != m_resourceMap.end()) {</span>
<span class="udiff-line-modified-added">+                     auto&amp; type = m_entryPointItems.inputs[iterator-&gt;value].unnamedType-&gt;unifyNode();</span>
<span class="udiff-line-modified-added">+                     if (is&lt;AST::UnnamedType&gt;(type) &amp;&amp; is&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(type))) {</span>
<span class="udiff-line-modified-added">+                         auto&amp; referenceType = downcast&lt;AST::ReferenceType&gt;(downcast&lt;AST::UnnamedType&gt;(type));</span>
<span class="udiff-line-modified-added">+                         auto mangledTypeName = m_typeNamer.mangledNameForType(referenceType.elementType());</span>
<span class="udiff-line-modified-added">+                         auto addressSpace = toString(referenceType.addressSpace());</span>
<span class="udiff-line-modified-added">+                         structItems.append(std::make_pair(index, makeString(addressSpace, &quot; &quot;, mangledTypeName, &quot;* &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="udiff-line-modified-added">+                     } else if (is&lt;AST::NamedType&gt;(type) &amp;&amp; is&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(type))) {</span>
<span class="udiff-line-modified-added">+                         auto&amp; namedType = downcast&lt;AST::NativeTypeDeclaration&gt;(downcast&lt;AST::NamedType&gt;(type));</span>
<span class="udiff-line-added">+                         auto mangledTypeName = m_typeNamer.mangledNameForType(namedType);</span>
<span class="udiff-line-added">+                         structItems.append(std::make_pair(index, makeString(mangledTypeName, &#39; &#39;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     // The binding doesn&#39;t appear in the shader source.</span>
<span class="udiff-line-added">+                     // However, we must still emit a placeholder, so successive items in the argument buffer struct have the correct offset.</span>
<span class="udiff-line-added">+                     // Because the binding doesn&#39;t appear in the shader source, we don&#39;t know which exact type the bind point should have.</span>
<span class="udiff-line-added">+                     // Therefore, we must synthesize a type out of thin air.</span>
<span class="udiff-line-added">+                     WTF::visit(WTF::makeVisitor([&amp;](UniformBufferBinding) {</span>
<span class="udiff-line-added">+                         structItems.append(std::make_pair(index, makeString(&quot;constant void* &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="udiff-line-added">+                     }, [&amp;](SamplerBinding) {</span>
<span class="udiff-line-added">+                         structItems.append(std::make_pair(index, makeString(&quot;sampler &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="udiff-line-added">+                     }, [&amp;](TextureBinding) {</span>
<span class="udiff-line-added">+                         // FIXME: https://bugs.webkit.org/show_bug.cgi?id=201384 We don&#39;t know which texture type the binding represents. This is no good very bad.</span>
<span class="udiff-line-added">+                         structItems.append(std::make_pair(index, makeString(&quot;texture2d&lt;float&gt; &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="udiff-line-added">+                     }, [&amp;](StorageBufferBinding) {</span>
<span class="udiff-line-added">+                         structItems.append(std::make_pair(index, makeString(&quot;device void* &quot;, elementName, &quot; [[id(&quot;, index, &quot;)]];&quot;)));</span>
<span class="udiff-line-added">+                     }), binding.binding);</span>
                  }
              }
              std::sort(structItems.begin(), structItems.end(), [](const std::pair&lt;unsigned, String&gt;&amp; left, const std::pair&lt;unsigned, String&gt;&amp; right) {
                  return left.first &lt; right.first;
              });
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -423,11 +441,11 @@</span>
              stringBuilder.append(indent, internalTypeName, &#39; &#39;, elementName, &#39; &#39;, attribute, &quot;;\n&quot;);
          }
      }
      stringBuilder.append(indent, &quot;};\n\n&quot;);
  
<span class="udiff-line-modified-removed">-     emitResourceHelperTypes(stringBuilder, indent);</span>
<span class="udiff-line-modified-added">+     emitResourceHelperTypes(stringBuilder, indent, ShaderStage::Vertex);</span>
  }
  
  void VertexEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)
  {
      stringBuilder.append(indent, &quot;vertex &quot;, m_returnStructName, &#39; &#39;, functionName, &#39;(&#39;, m_stageInStructName, &#39; &#39;, m_stageInParameterName, &quot; [[stage_in]]&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -528,11 +546,11 @@</span>
              stringBuilder.append(indent, internalTypeName, &#39; &#39;, elementName, &#39; &#39;, attribute, &quot;;\n&quot;);
          }
      }
      stringBuilder.append(indent, &quot;};\n\n&quot;);
  
<span class="udiff-line-modified-removed">-     emitResourceHelperTypes(stringBuilder, indent);</span>
<span class="udiff-line-modified-added">+     emitResourceHelperTypes(stringBuilder, indent, ShaderStage::Fragment);</span>
  }
  
  void FragmentEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)
  {
      stringBuilder.append(indent, &quot;fragment &quot;, m_returnStructName, &#39; &#39;, functionName, &#39;(&#39;, m_stageInStructName, &#39; &#39;, m_stageInParameterName, &quot; [[stage_in]]&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -578,11 +596,11 @@</span>
  {
  }
  
  void ComputeEntryPointScaffolding::emitHelperTypes(StringBuilder&amp; stringBuilder, Indentation&lt;4&gt; indent)
  {
<span class="udiff-line-modified-removed">-     emitResourceHelperTypes(stringBuilder, indent);</span>
<span class="udiff-line-modified-added">+     emitResourceHelperTypes(stringBuilder, indent, ShaderStage::Compute);</span>
  }
  
  void ComputeEntryPointScaffolding::emitSignature(StringBuilder&amp; stringBuilder, MangledFunctionName functionName, Indentation&lt;4&gt; indent)
  {
      stringBuilder.append(indent, &quot;kernel void &quot;, functionName, &#39;(&#39;);
</pre>
<center><a href="../AST/WHLSLType.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="WHLSLEntryPointScaffolding.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
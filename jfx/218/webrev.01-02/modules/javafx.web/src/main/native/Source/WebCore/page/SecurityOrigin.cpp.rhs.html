<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/page/SecurityOrigin.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
<a name="1" id="anc1"></a><span class="line-modified">  2  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.</span>
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  *
  8  * 1.  Redistributions of source code must retain the above copyright
  9  *     notice, this list of conditions and the following disclaimer.
 10  * 2.  Redistributions in binary form must reproduce the above copyright
 11  *     notice, this list of conditions and the following disclaimer in the
 12  *     documentation and/or other materials provided with the distribution.
 13  * 3.  Neither the name of Apple Inc. (&quot;Apple&quot;) nor the names of
 14  *     its contributors may be used to endorse or promote products derived
 15  *     from this software without specific prior written permission.
 16  *
 17  * THIS SOFTWARE IS PROVIDED BY APPLE AND ITS CONTRIBUTORS &quot;AS IS&quot; AND ANY
 18  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 19  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 20  * DISCLAIMED. IN NO EVENT SHALL APPLE OR ITS CONTRIBUTORS BE LIABLE FOR ANY
 21  * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 22  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 23  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 24  * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 25  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 26  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 27  */
 28 
 29 #include &quot;config.h&quot;
 30 #include &quot;SecurityOrigin.h&quot;
 31 
 32 #include &quot;BlobURL.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 33 #include &quot;LegacySchemeRegistry.h&quot;</span>
 34 #include &quot;OriginAccessEntry.h&quot;
 35 #include &quot;PublicSuffix.h&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 36 #include &quot;RuntimeApplicationChecks.h&quot;</span>
 37 #include &quot;SecurityPolicy.h&quot;
 38 #include &quot;TextEncoding.h&quot;
 39 #include &quot;ThreadableBlobRegistry.h&quot;
 40 #include &lt;wtf/FileSystem.h&gt;
 41 #include &lt;wtf/MainThread.h&gt;
 42 #include &lt;wtf/NeverDestroyed.h&gt;
 43 #include &lt;wtf/StdLibExtras.h&gt;
 44 #include &lt;wtf/URL.h&gt;
 45 #include &lt;wtf/text/StringBuilder.h&gt;
 46 
 47 namespace WebCore {
 48 
<a name="4" id="anc4"></a><span class="line-added"> 49 constexpr unsigned maximumURLSize = 0x04000000;</span>
<span class="line-added"> 50 </span>
 51 static bool schemeRequiresHost(const URL&amp; url)
 52 {
 53     // We expect URLs with these schemes to have authority components. If the
 54     // URL lacks an authority component, we get concerned and mark the origin
 55     // as unique.
 56     return url.protocolIsInHTTPFamily() || url.protocolIs(&quot;ftp&quot;);
 57 }
 58 
<a name="5" id="anc5"></a><span class="line-added"> 59 bool SecurityOrigin::shouldIgnoreHost(const URL&amp; url)</span>
<span class="line-added"> 60 {</span>
<span class="line-added"> 61     return url.protocolIsData() || url.protocolIsAbout() || protocolIsJavaScript(url) || url.protocolIs(&quot;file&quot;);</span>
<span class="line-added"> 62 }</span>
<span class="line-added"> 63 </span>
 64 bool SecurityOrigin::shouldUseInnerURL(const URL&amp; url)
 65 {
 66     // FIXME: Blob URLs don&#39;t have inner URLs. Their form is &quot;blob:&lt;inner-origin&gt;/&lt;UUID&gt;&quot;, so treating the part after &quot;blob:&quot; as a URL is incorrect.
 67     if (url.protocolIsBlob())
 68         return true;
 69     UNUSED_PARAM(url);
 70     return false;
 71 }
 72 
 73 // In general, extracting the inner URL varies by scheme. It just so happens
 74 // that all the URL schemes we currently support that use inner URLs for their
 75 // security origin can be parsed using this algorithm.
 76 URL SecurityOrigin::extractInnerURL(const URL&amp; url)
 77 {
 78     // FIXME: Update this callsite to use the innerURL member function when
 79     // we finish implementing it.
 80     return { URL(), decodeURLEscapeSequences(url.path()) };
 81 }
 82 
 83 static RefPtr&lt;SecurityOrigin&gt; getCachedOrigin(const URL&amp; url)
 84 {
 85     if (url.protocolIsBlob())
 86         return ThreadableBlobRegistry::getCachedOrigin(url);
 87     return nullptr;
 88 }
 89 
 90 static bool shouldTreatAsUniqueOrigin(const URL&amp; url)
 91 {
 92     if (!url.isValid())
 93         return true;
 94 
 95     // FIXME: Do we need to unwrap the URL further?
 96     URL innerURL = SecurityOrigin::shouldUseInnerURL(url) ? SecurityOrigin::extractInnerURL(url) : url;
 97 
 98     // FIXME: Check whether innerURL is valid.
 99 
100     // For edge case URLs that were probably misparsed, make sure that the origin is unique.
101     // This is an additional safety net against bugs in URL parsing, and for network back-ends that parse URLs differently,
102     // and could misinterpret another component for hostname.
103     if (schemeRequiresHost(innerURL) &amp;&amp; innerURL.host().isEmpty())
104         return true;
105 
<a name="6" id="anc6"></a><span class="line-modified">106     if (LegacySchemeRegistry::shouldTreatURLSchemeAsNoAccess(innerURL.protocol().toStringWithoutCopying()))</span>
107         return true;
108 
109     // This is the common case.
110     return false;
111 }
112 
113 static bool isLoopbackIPAddress(StringView host)
114 {
115     // The IPv6 loopback address is 0:0:0:0:0:0:0:1, which compresses to ::1.
116     if (host == &quot;[::1]&quot;)
117         return true;
118 
119     // Check to see if it&#39;s a valid IPv4 address that has the form 127.*.*.*.
120     if (!host.startsWith(&quot;127.&quot;))
121         return false;
122     size_t dotsFound = 0;
123     for (size_t i = 0; i &lt; host.length(); ++i) {
124         if (host[i] == &#39;.&#39;) {
125             dotsFound++;
126             continue;
127         }
128         if (!isASCIIDigit(host[i]))
129             return false;
130     }
131     return dotsFound == 3;
132 }
133 
134 // https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy (Editor&#39;s Draft, 17 November 2016)
135 static bool shouldTreatAsPotentiallyTrustworthy(const String&amp; protocol, const String&amp; host)
136 {
<a name="7" id="anc7"></a><span class="line-modified">137     if (LegacySchemeRegistry::shouldTreatURLSchemeAsSecure(protocol))</span>
138         return true;
139 
140     if (SecurityOrigin::isLocalHostOrLoopbackIPAddress(host))
141         return true;
142 
<a name="8" id="anc8"></a><span class="line-modified">143     if (LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(protocol))</span>
144         return true;
145 
146     return false;
147 }
148 
149 bool shouldTreatAsPotentiallyTrustworthy(const URL&amp; url)
150 {
151     return shouldTreatAsPotentiallyTrustworthy(url.protocol().toStringWithoutCopying(), url.host().toStringWithoutCopying());
152 }
153 
154 SecurityOrigin::SecurityOrigin(const URL&amp; url)
155     : m_data(SecurityOriginData::fromURL(url))
<a name="9" id="anc9"></a><span class="line-modified">156     , m_isLocal(LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(m_data.protocol))</span>
157 {
158     // document.domain starts as m_data.host, but can be set by the DOM.
159     m_domain = m_data.host;
160 
161     if (m_data.port &amp;&amp; WTF::isDefaultPortForProtocol(m_data.port.value(), m_data.protocol))
162         m_data.port = WTF::nullopt;
163 
164     // By default, only local SecurityOrigins can load local resources.
165     m_canLoadLocalResources = isLocal();
166 
167     if (m_canLoadLocalResources)
168         m_filePath = url.fileSystemPath(); // In case enforceFilePathSeparation() is called.
169 
170     m_isPotentiallyTrustworthy = shouldTreatAsPotentiallyTrustworthy(url);
171 }
172 
173 SecurityOrigin::SecurityOrigin()
174     : m_data { emptyString(), emptyString(), WTF::nullopt }
175     , m_domain { emptyString() }
176     , m_isUnique { true }
177     , m_isPotentiallyTrustworthy { true }
178 {
179 }
180 
181 SecurityOrigin::SecurityOrigin(const SecurityOrigin* other)
182     : m_data { other-&gt;m_data.isolatedCopy() }
183     , m_domain { other-&gt;m_domain.isolatedCopy() }
184     , m_filePath { other-&gt;m_filePath.isolatedCopy() }
185     , m_isUnique { other-&gt;m_isUnique }
186     , m_universalAccess { other-&gt;m_universalAccess }
187     , m_domainWasSetInDOM { other-&gt;m_domainWasSetInDOM }
188     , m_canLoadLocalResources { other-&gt;m_canLoadLocalResources }
189     , m_storageBlockingPolicy { other-&gt;m_storageBlockingPolicy }
190     , m_enforcesFilePathSeparation { other-&gt;m_enforcesFilePathSeparation }
191     , m_needsStorageAccessFromFileURLsQuirk { other-&gt;m_needsStorageAccessFromFileURLsQuirk }
192     , m_isPotentiallyTrustworthy { other-&gt;m_isPotentiallyTrustworthy }
193     , m_isLocal { other-&gt;m_isLocal }
194 {
195 }
196 
197 Ref&lt;SecurityOrigin&gt; SecurityOrigin::create(const URL&amp; url)
198 {
199     if (RefPtr&lt;SecurityOrigin&gt; cachedOrigin = getCachedOrigin(url))
200         return cachedOrigin.releaseNonNull();
201 
202     if (shouldTreatAsUniqueOrigin(url))
203         return adoptRef(*new SecurityOrigin);
204 
205     if (shouldUseInnerURL(url))
206         return adoptRef(*new SecurityOrigin(extractInnerURL(url)));
207 
208     return adoptRef(*new SecurityOrigin(url));
209 }
210 
211 Ref&lt;SecurityOrigin&gt; SecurityOrigin::createUnique()
212 {
213     Ref&lt;SecurityOrigin&gt; origin(adoptRef(*new SecurityOrigin));
214     ASSERT(origin.get().isUnique());
215     return origin;
216 }
217 
218 Ref&lt;SecurityOrigin&gt; SecurityOrigin::createNonLocalWithAllowedFilePath(const URL&amp; url, const String&amp; filePath)
219 {
220     ASSERT(!url.isLocalFile());
221     auto securityOrigin = SecurityOrigin::create(url);
222     securityOrigin-&gt;m_filePath = filePath;
223     return securityOrigin;
224 }
225 
226 Ref&lt;SecurityOrigin&gt; SecurityOrigin::isolatedCopy() const
227 {
228     return adoptRef(*new SecurityOrigin(this));
229 }
230 
231 void SecurityOrigin::setDomainFromDOM(const String&amp; newDomain)
232 {
233     m_domainWasSetInDOM = true;
234     m_domain = newDomain.convertToASCIILowercase();
235 }
236 
237 bool SecurityOrigin::isSecure(const URL&amp; url)
238 {
239     // Invalid URLs are secure, as are URLs which have a secure protocol.
<a name="10" id="anc10"></a><span class="line-modified">240     if (!url.isValid() || LegacySchemeRegistry::shouldTreatURLSchemeAsSecure(url.protocol().toStringWithoutCopying()))</span>
241         return true;
242 
243     // URLs that wrap inner URLs are secure if those inner URLs are secure.
<a name="11" id="anc11"></a><span class="line-modified">244     if (shouldUseInnerURL(url) &amp;&amp; LegacySchemeRegistry::shouldTreatURLSchemeAsSecure(extractInnerURL(url).protocol().toStringWithoutCopying()))</span>
245         return true;
246 
247     return false;
248 }
249 
250 bool SecurityOrigin::canAccess(const SecurityOrigin&amp; other) const
251 {
252     if (m_universalAccess)
253         return true;
254 
255     if (this == &amp;other)
256         return true;
257 
258     if (isUnique() || other.isUnique())
259         return false;
260 
261     // Here are two cases where we should permit access:
262     //
263     // 1) Neither document has set document.domain. In this case, we insist
264     //    that the scheme, host, and port of the URLs match.
265     //
266     // 2) Both documents have set document.domain. In this case, we insist
267     //    that the documents have set document.domain to the same value and
268     //    that the scheme of the URLs match.
269     //
270     // This matches the behavior of Firefox 2 and Internet Explorer 6.
271     //
272     // Internet Explorer 7 and Opera 9 are more strict in that they require
273     // the port numbers to match when both pages have document.domain set.
274     //
275     // FIXME: Evaluate whether we can tighten this policy to require matched
276     //        port numbers.
277     //
278     // Opera 9 allows access when only one page has set document.domain, but
279     // this is a security vulnerability.
280 
281     bool canAccess = false;
282     if (m_data.protocol == other.m_data.protocol) {
283         if (!m_domainWasSetInDOM &amp;&amp; !other.m_domainWasSetInDOM) {
284             if (m_data.host == other.m_data.host &amp;&amp; m_data.port == other.m_data.port)
285                 canAccess = true;
286         } else if (m_domainWasSetInDOM &amp;&amp; other.m_domainWasSetInDOM) {
287             if (m_domain == other.m_domain)
288                 canAccess = true;
289         }
290     }
291 
292     if (canAccess &amp;&amp; isLocal())
293         canAccess = passesFileCheck(other);
294 
295     return canAccess;
296 }
297 
298 bool SecurityOrigin::passesFileCheck(const SecurityOrigin&amp; other) const
299 {
300     ASSERT(isLocal() &amp;&amp; other.isLocal());
301 
302     return !m_enforcesFilePathSeparation &amp;&amp; !other.m_enforcesFilePathSeparation;
303 }
304 
305 bool SecurityOrigin::canRequest(const URL&amp; url) const
306 {
307     if (m_universalAccess)
308         return true;
309 
310     if (getCachedOrigin(url) == this)
311         return true;
312 
313     if (isUnique())
314         return false;
315 
316     Ref&lt;SecurityOrigin&gt; targetOrigin(SecurityOrigin::create(url));
317 
318     if (targetOrigin-&gt;isUnique())
319         return false;
320 
321     // We call isSameSchemeHostPort here instead of canAccess because we want
322     // to ignore document.domain effects.
323     if (isSameSchemeHostPort(targetOrigin.get()))
324         return true;
325 
326     if (SecurityPolicy::isAccessWhiteListed(this, &amp;targetOrigin.get()))
327         return true;
328 
329     return false;
330 }
331 
332 bool SecurityOrigin::canReceiveDragData(const SecurityOrigin&amp; dragInitiator) const
333 {
334     if (this == &amp;dragInitiator)
335         return true;
336 
337     return canAccess(dragInitiator);
338 }
339 
340 // This is a hack to allow keep navigation to http/https feeds working. To remove this
341 // we need to introduce new API akin to registerURLSchemeAsLocal, that registers a
342 // protocols navigation policy.
343 // feed(|s|search): is considered a &#39;nesting&#39; scheme by embedders that support it, so it can be
344 // local or remote depending on what is nested. Currently we just check if we are nesting
345 // http or https, otherwise we ignore the nesting for the purpose of a security check. We need
346 // a facility for registering nesting schemes, and some generalized logic for them.
347 // This function should be removed as an outcome of https://bugs.webkit.org/show_bug.cgi?id=69196
348 static bool isFeedWithNestedProtocolInHTTPFamily(const URL&amp; url)
349 {
350     const String&amp; string = url.string();
351     if (!startsWithLettersIgnoringASCIICase(string, &quot;feed&quot;))
352         return false;
353     return startsWithLettersIgnoringASCIICase(string, &quot;feed://&quot;)
354         || startsWithLettersIgnoringASCIICase(string, &quot;feed:http:&quot;)
355         || startsWithLettersIgnoringASCIICase(string, &quot;feed:https:&quot;)
356         || startsWithLettersIgnoringASCIICase(string, &quot;feeds:http:&quot;)
357         || startsWithLettersIgnoringASCIICase(string, &quot;feeds:https:&quot;)
358         || startsWithLettersIgnoringASCIICase(string, &quot;feedsearch:http:&quot;)
359         || startsWithLettersIgnoringASCIICase(string, &quot;feedsearch:https:&quot;);
360 }
361 
362 bool SecurityOrigin::canDisplay(const URL&amp; url) const
363 {
<a name="12" id="anc12"></a><span class="line-added">364     ASSERT(!isInNetworkProcess());</span>
365     if (m_universalAccess)
366         return true;
367 
<a name="13" id="anc13"></a><span class="line-modified">368     if (url.pathEnd() &gt; maximumURLSize)</span>
<span class="line-added">369         return false;</span>
<span class="line-added">370 </span>
<span class="line-added">371 #if !PLATFORM(IOS_FAMILY) &amp;&amp; !ENABLE(BUBBLEWRAP_SANDBOX)</span>
372     if (m_data.protocol == &quot;file&quot; &amp;&amp; url.isLocalFile() &amp;&amp; !FileSystem::filesHaveSameVolume(m_filePath, url.fileSystemPath()))
373         return false;
374 #endif
375 
376     if (isFeedWithNestedProtocolInHTTPFamily(url))
377         return true;
378 
379     String protocol = url.protocol().toString();
380 
<a name="14" id="anc14"></a><span class="line-modified">381     if (LegacySchemeRegistry::canDisplayOnlyIfCanRequest(protocol))</span>
382         return canRequest(url);
383 
<a name="15" id="anc15"></a><span class="line-modified">384     if (LegacySchemeRegistry::shouldTreatURLSchemeAsDisplayIsolated(protocol))</span>
385         return equalIgnoringASCIICase(m_data.protocol, protocol) || SecurityPolicy::isAccessToURLWhiteListed(this, url);
386 
387     if (!SecurityPolicy::restrictAccessToLocal())
388         return true;
389 
390     if (url.isLocalFile() &amp;&amp; url.fileSystemPath() == m_filePath)
391         return true;
392 
<a name="16" id="anc16"></a><span class="line-modified">393     if (LegacySchemeRegistry::shouldTreatURLSchemeAsLocal(protocol))</span>
394         return canLoadLocalResources() || SecurityPolicy::isAccessToURLWhiteListed(this, url);
395 
396     return true;
397 }
398 
399 bool SecurityOrigin::canAccessStorage(const SecurityOrigin* topOrigin, ShouldAllowFromThirdParty shouldAllowFromThirdParty) const
400 {
401     if (isUnique())
402         return false;
403 
404     if (isLocal() &amp;&amp; !needsStorageAccessFromFileURLsQuirk() &amp;&amp; !m_universalAccess &amp;&amp; shouldAllowFromThirdParty != AlwaysAllowFromThirdParty)
405         return false;
406 
407     if (m_storageBlockingPolicy == BlockAllStorage)
408         return false;
409 
410     // FIXME: This check should be replaced with an ASSERT once we can guarantee that topOrigin is not null.
411     if (!topOrigin)
412         return true;
413 
414     if (topOrigin-&gt;m_storageBlockingPolicy == BlockAllStorage)
415         return false;
416 
417     if (shouldAllowFromThirdParty == AlwaysAllowFromThirdParty)
418         return true;
419 
420     if (m_universalAccess)
421         return true;
422 
423     if ((m_storageBlockingPolicy == BlockThirdPartyStorage || topOrigin-&gt;m_storageBlockingPolicy == BlockThirdPartyStorage) &amp;&amp; !topOrigin-&gt;isSameOriginAs(*this))
424         return false;
425 
426     return true;
427 }
428 
429 SecurityOrigin::Policy SecurityOrigin::canShowNotifications() const
430 {
431     if (m_universalAccess)
432         return AlwaysAllow;
433     if (isUnique())
434         return AlwaysDeny;
435     return Ask;
436 }
437 
438 bool SecurityOrigin::isSameOriginAs(const SecurityOrigin&amp; other) const
439 {
440     if (this == &amp;other)
441         return true;
442 
443     if (isUnique() || other.isUnique())
444         return false;
445 
446     return isSameSchemeHostPort(other);
447 }
448 
449 bool SecurityOrigin::isMatchingRegistrableDomainSuffix(const String&amp; domainSuffix, bool treatIPAddressAsDomain) const
450 {
451     if (domainSuffix.isEmpty())
452         return false;
453 
454     auto ipAddressSetting = treatIPAddressAsDomain ? OriginAccessEntry::TreatIPAddressAsDomain : OriginAccessEntry::TreatIPAddressAsIPAddress;
455     OriginAccessEntry accessEntry { protocol(), domainSuffix, OriginAccessEntry::AllowSubdomains, ipAddressSetting };
456     if (!accessEntry.matchesOrigin(*this))
457         return false;
458 
459     // Always return true if it is an exact match.
460     if (domainSuffix.length() == host().length())
461         return true;
462 
463 #if ENABLE(PUBLIC_SUFFIX_LIST)
464     return !isPublicSuffix(domainSuffix);
465 #else
466     return true;
467 #endif
468 }
469 
470 void SecurityOrigin::grantLoadLocalResources()
471 {
472     // Granting privileges to some, but not all, documents in a SecurityOrigin
473     // is a security hazard because the documents without the privilege can
474     // obtain the privilege by injecting script into the documents that have
475     // been granted the privilege.
476     m_canLoadLocalResources = true;
477 }
478 
479 void SecurityOrigin::grantUniversalAccess()
480 {
481     m_universalAccess = true;
482 }
483 
484 void SecurityOrigin::grantStorageAccessFromFileURLsQuirk()
485 {
486     m_needsStorageAccessFromFileURLsQuirk = true;
487 }
488 
489 String SecurityOrigin::domainForCachePartition() const
490 {
491     if (m_storageBlockingPolicy != BlockThirdPartyStorage)
492         return emptyString();
493 
494     if (isHTTPFamily())
495         return host();
496 
<a name="17" id="anc17"></a><span class="line-modified">497     if (LegacySchemeRegistry::shouldPartitionCacheForURLScheme(m_data.protocol))</span>
498         return host();
499 
500     return emptyString();
501 }
502 
503 void SecurityOrigin::setEnforcesFilePathSeparation()
504 {
505     ASSERT(isLocal());
506     m_enforcesFilePathSeparation = true;
507 }
508 
509 String SecurityOrigin::toString() const
510 {
511     if (isUnique())
512         return &quot;null&quot;_s;
513     if (m_data.protocol == &quot;file&quot; &amp;&amp; m_enforcesFilePathSeparation)
514         return &quot;null&quot;_s;
515     return toRawString();
516 }
517 
518 String SecurityOrigin::toRawString() const
519 {
520     return m_data.toString();
521 }
522 
523 static inline bool areOriginsMatching(const SecurityOrigin&amp; origin1, const SecurityOrigin&amp; origin2)
524 {
525     ASSERT(&amp;origin1 != &amp;origin2);
526 
527     if (origin1.isUnique() || origin2.isUnique())
528         return origin1.isUnique() == origin2.isUnique();
529 
530     if (origin1.protocol() != origin2.protocol())
531         return false;
532 
533     if (origin1.protocol() == &quot;file&quot;)
534         return origin1.enforcesFilePathSeparation() == origin2.enforcesFilePathSeparation();
535 
536     if (origin1.host() != origin2.host())
537         return false;
538 
539     return origin1.port() == origin2.port();
540 }
541 
542 // This function mimics the result of string comparison of serialized origins.
543 bool serializedOriginsMatch(const SecurityOrigin&amp; origin1, const SecurityOrigin&amp; origin2)
544 {
545     if (&amp;origin1 == &amp;origin2)
546         return true;
547 
548     ASSERT(!areOriginsMatching(origin1, origin2) || (origin1.toString() == origin2.toString()));
549     return areOriginsMatching(origin1, origin2);
550 }
551 
552 bool serializedOriginsMatch(const SecurityOrigin* origin1, const SecurityOrigin* origin2)
553 {
554     if (!origin1 || !origin2)
555         return origin1 == origin2;
556 
557     return serializedOriginsMatch(*origin1, *origin2);
558 }
559 
560 Ref&lt;SecurityOrigin&gt; SecurityOrigin::createFromString(const String&amp; originString)
561 {
562     return SecurityOrigin::create(URL(URL(), originString));
563 }
564 
565 Ref&lt;SecurityOrigin&gt; SecurityOrigin::create(const String&amp; protocol, const String&amp; host, Optional&lt;uint16_t&gt; port)
566 {
567     String decodedHost = decodeURLEscapeSequences(host);
568     auto origin = create(URL(URL(), protocol + &quot;://&quot; + host + &quot;/&quot;));
569     if (port &amp;&amp; !WTF::isDefaultPortForProtocol(*port, protocol))
570         origin-&gt;m_data.port = port;
571     return origin;
572 }
573 
574 bool SecurityOrigin::equal(const SecurityOrigin* other) const
575 {
576     if (other == this)
577         return true;
578 
579     if (!isSameSchemeHostPort(*other))
580         return false;
581 
582     if (m_domainWasSetInDOM != other-&gt;m_domainWasSetInDOM)
583         return false;
584 
585     if (m_domainWasSetInDOM &amp;&amp; m_domain != other-&gt;m_domain)
586         return false;
587 
588     return true;
589 }
590 
591 bool SecurityOrigin::isSameSchemeHostPort(const SecurityOrigin&amp; other) const
592 {
593     if (m_data != other.m_data)
594         return false;
595 
596     if (isLocal() &amp;&amp; !passesFileCheck(other))
597         return false;
598 
599     return true;
600 }
601 
602 bool SecurityOrigin::isLocalHostOrLoopbackIPAddress(StringView host)
603 {
604     if (isLoopbackIPAddress(host))
605         return true;
606 
607     // FIXME: Ensure that localhost resolves to the loopback address.
608     if (equalLettersIgnoringASCIICase(host, &quot;localhost&quot;))
609         return true;
610 
611     return false;
612 }
613 
614 } // namespace WebCore
<a name="18" id="anc18"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="18" type="hidden" />
</body>
</html>
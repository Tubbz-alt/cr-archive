<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderImage.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2000 Dirk Mueller (mueller@kde.org)
  5  *           (C) 2006 Allan Sandfeld Jensen (kde@carewolf.com)
  6  *           (C) 2006 Samuel Weinig (sam.weinig@gmail.com)
  7  * Copyright (C) 2003, 2004, 2005, 2006, 2008, 2009, 2010, 2011 Apple Inc. All rights reserved.
  8  * Copyright (C) 2010 Google Inc. All rights reserved.
  9  * Copyright (C) Research In Motion Limited 2011-2012. All rights reserved.
 10  *
 11  * This library is free software; you can redistribute it and/or
 12  * modify it under the terms of the GNU Library General Public
 13  * License as published by the Free Software Foundation; either
 14  * version 2 of the License, or (at your option) any later version.
 15  *
 16  * This library is distributed in the hope that it will be useful,
 17  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 18  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 19  * Library General Public License for more details.
 20  *
 21  * You should have received a copy of the GNU Library General Public License
 22  * along with this library; see the file COPYING.LIB.  If not, write to
 23  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 24  * Boston, MA 02110-1301, USA.
 25  *
 26  */
 27 
 28 #include &quot;config.h&quot;
 29 #include &quot;RenderImage.h&quot;
 30 
 31 #include &quot;AXObjectCache.h&quot;
 32 #include &quot;BitmapImage.h&quot;
 33 #include &quot;CachedImage.h&quot;
 34 #include &quot;FocusController.h&quot;
 35 #include &quot;FontCache.h&quot;
 36 #include &quot;FontCascade.h&quot;
 37 #include &quot;Frame.h&quot;
 38 #include &quot;FrameSelection.h&quot;
 39 #include &quot;GeometryUtilities.h&quot;
 40 #include &quot;GraphicsContext.h&quot;
 41 #include &quot;HTMLAreaElement.h&quot;
 42 #include &quot;HTMLImageElement.h&quot;
 43 #include &quot;HTMLInputElement.h&quot;
 44 #include &quot;HTMLMapElement.h&quot;
 45 #include &quot;HTMLNames.h&quot;
 46 #include &quot;HitTestResult.h&quot;
 47 #include &quot;InlineElementBox.h&quot;
 48 #include &quot;Page.h&quot;
 49 #include &quot;PaintInfo.h&quot;
 50 #include &quot;RenderFragmentedFlow.h&quot;
 51 #include &quot;RenderImageResourceStyleImage.h&quot;
 52 #include &quot;RenderLayoutState.h&quot;
 53 #include &quot;RenderTheme.h&quot;
 54 #include &quot;RenderView.h&quot;
 55 #include &quot;RuntimeEnabledFeatures.h&quot;
 56 #include &quot;SVGImage.h&quot;
 57 #include &quot;Settings.h&quot;
 58 #include &lt;wtf/IsoMallocInlines.h&gt;
 59 #include &lt;wtf/StackStats.h&gt;
 60 
 61 #if PLATFORM(IOS_FAMILY)
 62 #include &quot;LogicalSelectionOffsetCaches.h&quot;
 63 #include &quot;SelectionRect.h&quot;
 64 #endif
 65 
 66 #if USE(CG)
 67 #include &quot;PDFDocumentImage.h&quot;
 68 #include &quot;Settings.h&quot;
 69 #endif
 70 
 71 namespace WebCore {
 72 
 73 WTF_MAKE_ISO_ALLOCATED_IMPL(RenderImage);
 74 
 75 #if PLATFORM(IOS_FAMILY)
 76 // FIXME: This doesn&#39;t behave correctly for floating or positioned images, but WebCore doesn&#39;t handle those well
 77 // during selection creation yet anyway.
 78 // FIXME: We can&#39;t tell whether or not we contain the start or end of the selected Range using only the offsets
 79 // of the start and end, we need to know the whole Position.
 80 void RenderImage::collectSelectionRects(Vector&lt;SelectionRect&gt;&amp; rects, unsigned, unsigned)
 81 {
 82     RenderBlock* containingBlock = this-&gt;containingBlock();
 83 
 84     IntRect imageRect;
 85     // FIXME: It doesn&#39;t make sense to package line bounds into SelectionRects. We should find
 86     // the right and left extent of the selection once for the entire selected Range, perhaps
 87     // using the Range&#39;s common ancestor.
 88     IntRect lineExtentRect;
 89     bool isFirstOnLine = false;
 90     bool isLastOnLine = false;
 91 
 92     InlineBox* inlineBox = inlineBoxWrapper();
 93     if (!inlineBox) {
 94         // This is a block image.
 95         imageRect = IntRect(0, 0, width(), height());
 96         isFirstOnLine = true;
 97         isLastOnLine = true;
 98         lineExtentRect = imageRect;
 99         if (containingBlock-&gt;isHorizontalWritingMode()) {
100             lineExtentRect.setX(containingBlock-&gt;x());
101             lineExtentRect.setWidth(containingBlock-&gt;width());
102         } else {
103             lineExtentRect.setY(containingBlock-&gt;y());
104             lineExtentRect.setHeight(containingBlock-&gt;height());
105         }
106     } else {
107         LayoutUnit selectionTop = !containingBlock-&gt;style().isFlippedBlocksWritingMode() ? inlineBox-&gt;root().selectionTop() - logicalTop() : logicalBottom() - inlineBox-&gt;root().selectionBottom();
108         imageRect = IntRect(0,  selectionTop, logicalWidth(), inlineBox-&gt;root().selectionHeight());
109         isFirstOnLine = !inlineBox-&gt;previousOnLineExists();
110         isLastOnLine = !inlineBox-&gt;nextOnLineExists();
111         LogicalSelectionOffsetCaches cache(*containingBlock);
112         LayoutUnit leftOffset = containingBlock-&gt;logicalLeftSelectionOffset(*containingBlock, LayoutUnit(inlineBox-&gt;logicalTop()), cache);
113         LayoutUnit rightOffset = containingBlock-&gt;logicalRightSelectionOffset(*containingBlock, LayoutUnit(inlineBox-&gt;logicalTop()), cache);
114         lineExtentRect = IntRect(leftOffset - logicalLeft(), imageRect.y(), rightOffset - leftOffset, imageRect.height());
115         if (!inlineBox-&gt;isHorizontal()) {
116             imageRect = imageRect.transposedRect();
117             lineExtentRect = lineExtentRect.transposedRect();
118         }
119     }
120 
121     bool isFixed = false;
122     IntRect absoluteBounds = localToAbsoluteQuad(FloatRect(imageRect), UseTransforms, &amp;isFixed).enclosingBoundingBox();
123     IntRect lineExtentBounds = localToAbsoluteQuad(FloatRect(lineExtentRect)).enclosingBoundingBox();
124     if (!containingBlock-&gt;isHorizontalWritingMode())
125         lineExtentBounds = lineExtentBounds.transposedRect();
126 
127     // FIXME: We should consider either making SelectionRect a struct or better organize its optional fields into
128     // an auxiliary struct to simplify its initialization.
129     rects.append(SelectionRect(absoluteBounds, containingBlock-&gt;style().direction(), lineExtentBounds.x(), lineExtentBounds.maxX(), lineExtentBounds.maxY(), 0, false /* line break */, isFirstOnLine, isLastOnLine, false /* contains start */, false /* contains end */, containingBlock-&gt;style().isHorizontalWritingMode(), isFixed, false /* ruby text */, view().pageNumberForBlockProgressionOffset(absoluteBounds.x())));
130 }
131 #endif
132 
133 using namespace HTMLNames;
134 
135 RenderImage::RenderImage(Element&amp; element, RenderStyle&amp;&amp; style, StyleImage* styleImage, const float imageDevicePixelRatio)
136     : RenderReplaced(element, WTFMove(style), IntSize())
137     , m_imageResource(styleImage ? makeUnique&lt;RenderImageResourceStyleImage&gt;(*styleImage) : makeUnique&lt;RenderImageResource&gt;())
138     , m_imageDevicePixelRatio(imageDevicePixelRatio)
139 {
140     updateAltText();
141     if (is&lt;HTMLImageElement&gt;(element))
142         m_hasShadowControls = downcast&lt;HTMLImageElement&gt;(element).hasShadowControls();
143 }
144 
145 RenderImage::RenderImage(Document&amp; document, RenderStyle&amp;&amp; style, StyleImage* styleImage)
146     : RenderReplaced(document, WTFMove(style), IntSize())
147     , m_imageResource(styleImage ? makeUnique&lt;RenderImageResourceStyleImage&gt;(*styleImage) : makeUnique&lt;RenderImageResource&gt;())
148 {
149 }
150 
151 RenderImage::~RenderImage()
152 {
153     // Do not add any code here. Add it to willBeDestroyed() instead.
154 }
155 
156 void RenderImage::willBeDestroyed()
157 {
158     imageResource().shutdown();
159     RenderReplaced::willBeDestroyed();
160 }
161 
162 // If we&#39;ll be displaying either alt text or an image, add some padding.
163 static const unsigned short paddingWidth = 4;
164 static const unsigned short paddingHeight = 4;
165 
166 // Alt text is restricted to this maximum size, in pixels.  These are
167 // signed integers because they are compared with other signed values.
168 static const float maxAltTextWidth = 1024;
169 static const int maxAltTextHeight = 256;
170 
171 IntSize RenderImage::imageSizeForError(CachedImage* newImage) const
172 {
173     ASSERT_ARG(newImage, newImage);
174     ASSERT_ARG(newImage, newImage-&gt;imageForRenderer(this));
175 
176     FloatSize imageSize;
177     if (newImage-&gt;willPaintBrokenImage()) {
178         std::pair&lt;Image*, float&gt; brokenImageAndImageScaleFactor = newImage-&gt;brokenImage(document().deviceScaleFactor());
179         imageSize = brokenImageAndImageScaleFactor.first-&gt;size();
180         imageSize.scale(1 / brokenImageAndImageScaleFactor.second);
181     } else
182         imageSize = newImage-&gt;imageForRenderer(this)-&gt;size();
183 
184     // imageSize() returns 0 for the error image. We need the true size of the
185     // error image, so we have to get it by grabbing image() directly.
186     return IntSize(paddingWidth + imageSize.width() * style().effectiveZoom(), paddingHeight + imageSize.height() * style().effectiveZoom());
187 }
188 
189 // Sets the image height and width to fit the alt text.  Returns true if the
190 // image size changed.
191 ImageSizeChangeType RenderImage::setImageSizeForAltText(CachedImage* newImage /* = 0 */)
192 {
193     IntSize imageSize;
194     if (newImage &amp;&amp; newImage-&gt;imageForRenderer(this))
195         imageSize = imageSizeForError(newImage);
196     else if (!m_altText.isEmpty() || newImage) {
197         // If we&#39;ll be displaying either text or an image, add a little padding.
198         imageSize = IntSize(paddingWidth, paddingHeight);
199     }
200 
201     // we have an alt and the user meant it (its not a text we invented)
202     if (!m_altText.isEmpty()) {
203         const FontCascade&amp; font = style().fontCascade();
204         IntSize paddedTextSize(paddingWidth + std::min(ceilf(font.width(RenderBlock::constructTextRun(m_altText, style()))), maxAltTextWidth), paddingHeight + std::min(font.fontMetrics().height(), maxAltTextHeight));
205         imageSize = imageSize.expandedTo(paddedTextSize);
206     }
207 
208     if (imageSize == intrinsicSize())
209         return ImageSizeChangeNone;
210 
211     setIntrinsicSize(imageSize);
212     return ImageSizeChangeForAltText;
213 }
214 
215 bool RenderImage::isEditableImage() const
216 {
217     if (!element() || !is&lt;HTMLImageElement&gt;(element()))
218         return false;
219     return downcast&lt;HTMLImageElement&gt;(element())-&gt;hasEditableImageAttribute();
220 }
221 
222 bool RenderImage::requiresLayer() const
223 {
224     if (RenderReplaced::requiresLayer())
225         return true;
226 
227     if (isEditableImage())
228         return true;
229 
230     return false;
231 }
232 
233 void RenderImage::styleWillChange(StyleDifference diff, const RenderStyle&amp; newStyle)
234 {
235     if (!hasInitializedStyle())
236         imageResource().initialize(*this);
237     RenderReplaced::styleWillChange(diff, newStyle);
238 }
239 
240 void RenderImage::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
241 {
242     RenderReplaced::styleDidChange(diff, oldStyle);
243     if (m_needsToSetSizeForAltText) {
244         if (!m_altText.isEmpty() &amp;&amp; setImageSizeForAltText(cachedImage()))
245             repaintOrMarkForLayout(ImageSizeChangeForAltText);
246         m_needsToSetSizeForAltText = false;
247     }
<a name="1" id="anc1"></a>
248     if (diff == StyleDifference::Layout &amp;&amp; oldStyle-&gt;imageOrientation() != style().imageOrientation())
249         return repaintOrMarkForLayout(ImageSizeChangeNone);
<a name="2" id="anc2"></a>
250 
251 #if ENABLE(CSS_IMAGE_RESOLUTION)
252     if (diff == StyleDifference::Layout
253         &amp;&amp; (oldStyle-&gt;imageResolution() != style().imageResolution()
254             || oldStyle-&gt;imageResolutionSnap() != style().imageResolutionSnap()
255             || oldStyle-&gt;imageResolutionSource() != style().imageResolutionSource()))
256         repaintOrMarkForLayout(ImageSizeChangeNone);
257 #endif
258 }
259 
260 void RenderImage::imageChanged(WrappedImagePtr newImage, const IntRect* rect)
261 {
262     if (renderTreeBeingDestroyed())
263         return;
264 
265     if (hasVisibleBoxDecorations() || hasMask() || hasShapeOutside())
266         RenderReplaced::imageChanged(newImage, rect);
267 
268     if (newImage != imageResource().imagePtr() || !newImage)
269         return;
270 
271     // At a zoom level of 1 the image is guaranteed to have an integer size.
272     incrementVisuallyNonEmptyPixelCountIfNeeded(flooredIntSize(imageResource().imageSize(1.0f)));
273 
274     ImageSizeChangeType imageSizeChange = ImageSizeChangeNone;
275 
276     // Set image dimensions, taking into account the size of the alt text.
277     if (imageResource().errorOccurred()) {
278         if (!m_altText.isEmpty() &amp;&amp; document().hasPendingStyleRecalc()) {
279             ASSERT(element());
280             if (element()) {
281                 m_needsToSetSizeForAltText = true;
282                 element()-&gt;invalidateStyle();
283             }
284             return;
285         }
286         imageSizeChange = setImageSizeForAltText(cachedImage());
287     }
288     repaintOrMarkForLayout(imageSizeChange, rect);
289     if (AXObjectCache* cache = document().existingAXObjectCache())
290         cache-&gt;deferRecomputeIsIgnoredIfNeeded(element());
291 }
292 
293 void RenderImage::updateIntrinsicSizeIfNeeded(const LayoutSize&amp; newSize)
294 {
295     if (imageResource().errorOccurred() || !m_imageResource-&gt;cachedImage())
296         return;
297     setIntrinsicSize(newSize);
298 }
299 
300 void RenderImage::updateInnerContentRect()
301 {
302     // Propagate container size to image resource.
303     IntSize containerSize(replacedContentRect().size());
304     if (!containerSize.isEmpty()) {
305         URL imageSourceURL;
306         if (HTMLImageElement* imageElement = is&lt;HTMLImageElement&gt;(element()) ? downcast&lt;HTMLImageElement&gt;(element()) : nullptr)
307             imageSourceURL = document().completeURL(imageElement-&gt;imageSourceURL());
308         imageResource().setContainerContext(containerSize, imageSourceURL);
309     }
310 }
311 
312 void RenderImage::repaintOrMarkForLayout(ImageSizeChangeType imageSizeChange, const IntRect* rect)
313 {
314 #if ENABLE(CSS_IMAGE_RESOLUTION)
315     double scale = style().imageResolution();
316     if (style().imageResolutionSnap() == ImageResolutionSnap::Pixels)
317         scale = roundForImpreciseConversion&lt;int&gt;(scale);
318     if (scale &lt;= 0)
319         scale = 1;
320     LayoutSize newIntrinsicSize = imageResource().intrinsicSize(style().effectiveZoom() / scale);
321 #else
322     LayoutSize newIntrinsicSize = imageResource().intrinsicSize(style().effectiveZoom());
323 #endif
324     LayoutSize oldIntrinsicSize = intrinsicSize();
325 
326     updateIntrinsicSizeIfNeeded(newIntrinsicSize);
327 
328     // In the case of generated image content using :before/:after/content, we might not be
329     // in the render tree yet. In that case, we just need to update our intrinsic size.
330     // layout() will be called after we are inserted in the tree which will take care of
331     // what we are doing here.
332     if (!containingBlock())
333         return;
334 
335     bool imageSourceHasChangedSize = oldIntrinsicSize != newIntrinsicSize || imageSizeChange != ImageSizeChangeNone;
336 
337     if (imageSourceHasChangedSize &amp;&amp; setNeedsLayoutIfNeededAfterIntrinsicSizeChange())
338         return;
339 
340     if (everHadLayout() &amp;&amp; !selfNeedsLayout()) {
341         // The inner content rectangle is calculated during layout, but may need an update now
342         // (unless the box has already been scheduled for layout). In order to calculate it, we
343         // may need values from the containing block, though, so make sure that we&#39;re not too
344         // early. It may be that layout hasn&#39;t even taken place once yet.
345 
346         // FIXME: we should not have to trigger another call to setContainerContextForRenderer()
347         // from here, since it&#39;s already being done during layout.
348         updateInnerContentRect();
349     }
350 
351     LayoutRect repaintRect = contentBoxRect();
352     if (rect) {
353         // The image changed rect is in source image coordinates (pre-zooming),
354         // so map from the bounds of the image to the contentsBox.
355         repaintRect.intersect(enclosingIntRect(mapRect(*rect, FloatRect(FloatPoint(), imageResource().imageSize(1.0f)), repaintRect)));
356     }
357 
358     repaintRectangle(repaintRect);
359 
360     // Tell any potential compositing layers that the image needs updating.
361     contentChanged(ImageChanged);
362 }
363 
364 void RenderImage::notifyFinished(CachedResource&amp; newImage)
365 {
366     if (renderTreeBeingDestroyed())
367         return;
368 
369     invalidateBackgroundObscurationStatus();
370 
371     if (&amp;newImage == cachedImage()) {
372         // tell any potential compositing layers
373         // that the image is done and they can reference it directly.
374         contentChanged(ImageChanged);
375     }
376 
377     if (is&lt;HTMLImageElement&gt;(element()))
378         page().didFinishLoadingImageForElement(downcast&lt;HTMLImageElement&gt;(*element()));
379 }
380 
<a name="3" id="anc3"></a><span class="line-added">381 void RenderImage::setImageDevicePixelRatio(float factor)</span>
<span class="line-added">382 {</span>
<span class="line-added">383     if (m_imageDevicePixelRatio == factor)</span>
<span class="line-added">384         return;</span>
<span class="line-added">385 </span>
<span class="line-added">386     m_imageDevicePixelRatio = factor;</span>
<span class="line-added">387     intrinsicSizeChanged();</span>
<span class="line-added">388 }</span>
<span class="line-added">389 </span>
390 bool RenderImage::isShowingMissingOrImageError() const
391 {
392     return !imageResource().cachedImage() || imageResource().errorOccurred();
393 }
394 
395 bool RenderImage::isShowingAltText() const
396 {
397     return isShowingMissingOrImageError() &amp;&amp; !m_altText.isEmpty();
398 }
399 
<a name="4" id="anc4"></a><span class="line-added">400 bool RenderImage::shouldDisplayBrokenImageIcon() const</span>
<span class="line-added">401 {</span>
<span class="line-added">402     return imageResource().errorOccurred();</span>
<span class="line-added">403 }</span>
<span class="line-added">404 </span>
405 bool RenderImage::hasNonBitmapImage() const
406 {
407     if (!imageResource().cachedImage())
408         return false;
409 
410     Image* image = cachedImage()-&gt;imageForRenderer(this);
411     return image &amp;&amp; !is&lt;BitmapImage&gt;(image);
412 }
413 
414 void RenderImage::paintIncompleteImageOutline(PaintInfo&amp; paintInfo, LayoutPoint paintOffset, LayoutUnit borderWidth) const
415 {
416     auto contentSize = this-&gt;contentSize();
417     if (contentSize.width() &lt;= 2 || contentSize.height() &lt;= 2)
418         return;
419 
420     auto leftBorder = borderLeft();
421     auto topBorder = borderTop();
422     auto leftPadding = paddingLeft();
423     auto topPadding = paddingTop();
424 
425     // Draw an outline rect where the image should be.
426     GraphicsContext&amp; context = paintInfo.context();
427     context.setStrokeStyle(SolidStroke);
428     context.setStrokeColor(Color::lightGray);
429     context.setFillColor(Color::transparent);
430     context.drawRect(snapRectToDevicePixels(LayoutRect({ paintOffset.x() + leftBorder + leftPadding, paintOffset.y() + topBorder + topPadding }, contentSize), document().deviceScaleFactor()), borderWidth);
431 }
432 
433 void RenderImage::paintReplaced(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
434 {
435     GraphicsContext&amp; context = paintInfo.context();
436     if (context.invalidatingImagesWithAsyncDecodes()) {
437         if (cachedImage() &amp;&amp; cachedImage()-&gt;isClientWaitingForAsyncDecoding(*this))
438             cachedImage()-&gt;removeAllClientsWaitingForAsyncDecoding();
439         return;
440     }
441 
442     auto contentSize = this-&gt;contentSize();
443     float deviceScaleFactor = document().deviceScaleFactor();
444     LayoutUnit missingImageBorderWidth(1 / deviceScaleFactor);
445 
<a name="5" id="anc5"></a><span class="line-modified">446     if (!imageResource().cachedImage() || shouldDisplayBrokenImageIcon()) {</span>
447         if (paintInfo.phase == PaintPhase::Selection)
448             return;
449 
450         if (paintInfo.phase == PaintPhase::Foreground)
451             page().addRelevantUnpaintedObject(this, visualOverflowRect());
452 
453         paintIncompleteImageOutline(paintInfo, paintOffset, missingImageBorderWidth);
454 
455         if (contentSize.width() &gt; 2 &amp;&amp; contentSize.height() &gt; 2) {
456             LayoutUnit leftBorder = borderLeft();
457             LayoutUnit topBorder = borderTop();
458             LayoutUnit leftPad = paddingLeft();
459             LayoutUnit topPad = paddingTop();
460 
461             bool errorPictureDrawn = false;
462             LayoutSize imageOffset;
463             // When calculating the usable dimensions, exclude the pixels of
<a name="6" id="anc6"></a><span class="line-modified">464             // the outline rect so the error image/alt text doesn&#39;t draw on it.</span>
465             LayoutSize usableSize = contentSize - LayoutSize(2 * missingImageBorderWidth, 2 * missingImageBorderWidth);
466 
467             RefPtr&lt;Image&gt; image = imageResource().image();
468 
<a name="7" id="anc7"></a><span class="line-modified">469             if (shouldDisplayBrokenImageIcon() &amp;&amp; !image-&gt;isNull() &amp;&amp; usableSize.width() &gt;= image-&gt;width() &amp;&amp; usableSize.height() &gt;= image-&gt;height()) {</span>
470                 // Call brokenImage() explicitly to ensure we get the broken image icon at the appropriate resolution.
471                 std::pair&lt;Image*, float&gt; brokenImageAndImageScaleFactor = cachedImage()-&gt;brokenImage(deviceScaleFactor);
472                 image = brokenImageAndImageScaleFactor.first;
473                 FloatSize imageSize = image-&gt;size();
474                 imageSize.scale(1 / brokenImageAndImageScaleFactor.second);
<a name="8" id="anc8"></a><span class="line-added">475 </span>
476                 // Center the error image, accounting for border and padding.
477                 LayoutUnit centerX { (usableSize.width() - imageSize.width()) / 2 };
478                 if (centerX &lt; 0)
479                     centerX = 0;
480                 LayoutUnit centerY { (usableSize.height() - imageSize.height()) / 2 };
481                 if (centerY &lt; 0)
482                     centerY = 0;
483                 imageOffset = LayoutSize(leftBorder + leftPad + centerX + missingImageBorderWidth, topBorder + topPad + centerY + missingImageBorderWidth);
484 
485                 context.drawImage(*image, snapRectToDevicePixels(LayoutRect(paintOffset + imageOffset, imageSize), deviceScaleFactor), { imageOrientation() });
486                 errorPictureDrawn = true;
487             }
488 
489             if (!m_altText.isEmpty()) {
490                 String text = document().displayStringModifiedByEncoding(m_altText);
491                 context.setFillColor(style().visitedDependentColorWithColorFilter(CSSPropertyColor));
492                 const FontCascade&amp; font = style().fontCascade();
493                 const FontMetrics&amp; fontMetrics = font.fontMetrics();
494                 LayoutUnit ascent = fontMetrics.ascent();
495                 LayoutPoint altTextOffset = paintOffset;
496                 altTextOffset.move(leftBorder + leftPad + (paddingWidth / 2) - missingImageBorderWidth, topBorder + topPad + ascent + (paddingHeight / 2) - missingImageBorderWidth);
497 
498                 // Only draw the alt text if it&#39;ll fit within the content box,
499                 // and only if it fits above the error image.
500                 TextRun textRun = RenderBlock::constructTextRun(text, style());
501                 LayoutUnit textWidth { font.width(textRun) };
502                 if (errorPictureDrawn) {
503                     if (usableSize.width() &gt;= textWidth &amp;&amp; fontMetrics.height() &lt;= imageOffset.height())
504                         context.drawText(font, textRun, altTextOffset);
505                 } else if (usableSize.width() &gt;= textWidth &amp;&amp; usableSize.height() &gt;= fontMetrics.height())
506                     context.drawText(font, textRun, altTextOffset);
507             }
508         }
509         return;
510     }
511 
512     if (contentSize.isEmpty())
513         return;
514 
515     bool showBorderForIncompleteImage = settings().incompleteImageBorderEnabled();
516 
517     RefPtr&lt;Image&gt; img = imageResource().image(flooredIntSize(contentSize));
518     if (!img || img-&gt;isNull()) {
519         if (showBorderForIncompleteImage)
520             paintIncompleteImageOutline(paintInfo, paintOffset, missingImageBorderWidth);
521 
522         if (paintInfo.phase == PaintPhase::Foreground)
523             page().addRelevantUnpaintedObject(this, visualOverflowRect());
524         return;
525     }
526 
527     LayoutRect contentBoxRect = this-&gt;contentBoxRect();
528     contentBoxRect.moveBy(paintOffset);
529     LayoutRect replacedContentRect = this-&gt;replacedContentRect();
530     replacedContentRect.moveBy(paintOffset);
531     bool clip = !contentBoxRect.contains(replacedContentRect);
532     GraphicsContextStateSaver stateSaver(context, clip);
533     if (clip)
534         context.clip(contentBoxRect);
535 
536     ImageDrawResult result = paintIntoRect(paintInfo, snapRectToDevicePixels(replacedContentRect, deviceScaleFactor));
537 
538     if (showBorderForIncompleteImage &amp;&amp; (result != ImageDrawResult::DidDraw || (cachedImage() &amp;&amp; cachedImage()-&gt;isLoading())))
539         paintIncompleteImageOutline(paintInfo, paintOffset, missingImageBorderWidth);
540 
541     if (cachedImage() &amp;&amp; paintInfo.phase == PaintPhase::Foreground) {
542         // For now, count images as unpainted if they are still progressively loading. We may want
543         // to refine this in the future to account for the portion of the image that has painted.
544         LayoutRect visibleRect = intersection(replacedContentRect, contentBoxRect);
545         if (cachedImage()-&gt;isLoading() || result == ImageDrawResult::DidRequestDecoding)
546             page().addRelevantUnpaintedObject(this, visibleRect);
547         else
548             page().addRelevantRepaintedObject(this, visibleRect);
549     }
550 }
551 
552 void RenderImage::paint(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
553 {
554     RenderReplaced::paint(paintInfo, paintOffset);
555 
556     if (paintInfo.phase == PaintPhase::Outline)
557         paintAreaElementFocusRing(paintInfo, paintOffset);
558 }
559 
560 void RenderImage::paintAreaElementFocusRing(PaintInfo&amp; paintInfo, const LayoutPoint&amp; paintOffset)
561 {
562 #if !PLATFORM(IOS_FAMILY) || ENABLE(FULL_KEYBOARD_ACCESS)
563     if (document().printing() || !frame().selection().isFocusedAndActive())
564         return;
565 
566     if (paintInfo.context().paintingDisabled() &amp;&amp; !paintInfo.context().performingPaintInvalidation())
567         return;
568 
569     Element* focusedElement = document().focusedElement();
570     if (!is&lt;HTMLAreaElement&gt;(focusedElement))
571         return;
572 
573     HTMLAreaElement&amp; areaElement = downcast&lt;HTMLAreaElement&gt;(*focusedElement);
574     if (areaElement.imageElement() != element())
575         return;
576 
577     auto* areaElementStyle = areaElement.computedStyle();
578     if (!areaElementStyle)
579         return;
580 
581     float outlineWidth = areaElementStyle-&gt;outlineWidth();
582     if (!outlineWidth)
583         return;
584 
585     // Even if the theme handles focus ring drawing for entire elements, it won&#39;t do it for
586     // an area within an image, so we don&#39;t call RenderTheme::supportsFocusRing here.
587     auto path = areaElement.computePathForFocusRing(size());
588     if (path.isEmpty())
589         return;
590 
591     AffineTransform zoomTransform;
592     zoomTransform.scale(style().effectiveZoom());
593     path.transform(zoomTransform);
594 
595     auto adjustedOffset = paintOffset;
596     adjustedOffset.moveBy(location());
597     path.translate(toFloatSize(adjustedOffset));
598 
599 #if PLATFORM(MAC)
600     bool needsRepaint;
601     paintInfo.context().drawFocusRing(path, page().focusController().timeSinceFocusWasSet().seconds(), needsRepaint, RenderTheme::singleton().focusRingColor(styleColorOptions()));
602     if (needsRepaint)
603         page().focusController().setFocusedElementNeedsRepaint();
604 #else
605     paintInfo.context().drawFocusRing(path, outlineWidth, areaElementStyle-&gt;outlineOffset(), areaElementStyle-&gt;visitedDependentColorWithColorFilter(CSSPropertyOutlineColor));
606 #endif // PLATFORM(MAC)
607 #else
608     UNUSED_PARAM(paintInfo);
609     UNUSED_PARAM(paintOffset);
610 #endif // ENABLE(FULL_KEYBOARD_ACCESS)
611 }
612 
613 void RenderImage::areaElementFocusChanged(HTMLAreaElement* element)
614 {
615     ASSERT_UNUSED(element, element-&gt;imageElement() == this-&gt;element());
616 
617     // It would be more efficient to only repaint the focus ring rectangle
618     // for the passed-in area element. That would require adding functions
619     // to the area element class.
620     repaint();
621 }
622 
623 ImageDrawResult RenderImage::paintIntoRect(PaintInfo&amp; paintInfo, const FloatRect&amp; rect)
624 {
625     if (!imageResource().cachedImage() || imageResource().errorOccurred() || rect.width() &lt;= 0 || rect.height() &lt;= 0)
626         return ImageDrawResult::DidNothing;
627 
628     RefPtr&lt;Image&gt; img = imageResource().image(flooredIntSize(rect.size()));
629     if (!img || img-&gt;isNull())
630         return ImageDrawResult::DidNothing;
631 
632     HTMLImageElement* imageElement = is&lt;HTMLImageElement&gt;(element()) ? downcast&lt;HTMLImageElement&gt;(element()) : nullptr;
<a name="9" id="anc9"></a>
633 
634     // FIXME: Document when image != img.get().
635     Image* image = imageResource().image().get();
<a name="10" id="anc10"></a>
636 
637 #if USE(CG)
638     if (is&lt;PDFDocumentImage&gt;(image))
639         downcast&lt;PDFDocumentImage&gt;(*image).setPdfImageCachingPolicy(settings().pdfImageCachingPolicy());
640 #endif
641 
642     if (is&lt;BitmapImage&gt;(image))
643         downcast&lt;BitmapImage&gt;(*image).updateFromSettings(settings());
644 
<a name="11" id="anc11"></a><span class="line-modified">645     ImagePaintingOptions options = {</span>
<span class="line-modified">646         imageElement ? imageElement-&gt;compositeOperator() : CompositeOperator::SourceOver,</span>
<span class="line-added">647         decodingModeForImageDraw(*image, paintInfo),</span>
<span class="line-added">648         imageOrientation(),</span>
<span class="line-added">649         image ? chooseInterpolationQuality(paintInfo.context(), *image, image, LayoutSize(rect.size())) : InterpolationQuality::Default</span>
<span class="line-added">650     };</span>
<span class="line-added">651 </span>
<span class="line-added">652     auto drawResult = paintInfo.context().drawImage(*img, rect, options);</span>
653     if (drawResult == ImageDrawResult::DidRequestDecoding)
654         imageResource().cachedImage()-&gt;addClientWaitingForAsyncDecoding(*this);
655 
656 #if USE(SYSTEM_PREVIEW)
657     if (imageElement &amp;&amp; imageElement-&gt;isSystemPreviewImage() &amp;&amp; drawResult == ImageDrawResult::DidDraw &amp;&amp; RuntimeEnabledFeatures::sharedFeatures().systemPreviewEnabled())
658         theme().paintSystemPreviewBadge(*img, paintInfo, rect);
659 #endif
660 
661     return drawResult;
662 }
663 
664 bool RenderImage::boxShadowShouldBeAppliedToBackground(const LayoutPoint&amp; paintOffset, BackgroundBleedAvoidance bleedAvoidance, InlineFlowBox*) const
665 {
666     if (!RenderBoxModelObject::boxShadowShouldBeAppliedToBackground(paintOffset, bleedAvoidance))
667         return false;
668 
669     return !const_cast&lt;RenderImage*&gt;(this)-&gt;backgroundIsKnownToBeObscured(paintOffset);
670 }
671 
672 bool RenderImage::foregroundIsKnownToBeOpaqueInRect(const LayoutRect&amp; localRect, unsigned maxDepthToTest) const
673 {
674     UNUSED_PARAM(maxDepthToTest);
675     if (!imageResource().cachedImage() || imageResource().errorOccurred())
676         return false;
677     if (cachedImage() &amp;&amp; !cachedImage()-&gt;isLoaded())
678         return false;
679     if (!contentBoxRect().contains(localRect))
680         return false;
681     FillBox backgroundClip = style().backgroundClip();
682     // Background paints under borders.
683     if (backgroundClip == FillBox::Border &amp;&amp; style().hasBorder() &amp;&amp; !borderObscuresBackground())
684         return false;
685     // Background shows in padding area.
686     if ((backgroundClip == FillBox::Border || backgroundClip == FillBox::Padding) &amp;&amp; style().hasPadding())
687         return false;
688     // Object-fit may leave parts of the content box empty.
689     ObjectFit objectFit = style().objectFit();
690     if (objectFit != ObjectFit::Fill &amp;&amp; objectFit != ObjectFit::Cover)
691         return false;
692 
693     LengthPoint objectPosition = style().objectPosition();
694     if (objectPosition != RenderStyle::initialObjectPosition())
695         return false;
696 
697     // Check for image with alpha.
698     return cachedImage() &amp;&amp; cachedImage()-&gt;currentFrameKnownToBeOpaque(this);
699 }
700 
701 bool RenderImage::computeBackgroundIsKnownToBeObscured(const LayoutPoint&amp; paintOffset)
702 {
703     if (!hasBackground())
704         return false;
705 
706     LayoutRect paintedExtent;
707     if (!getBackgroundPaintedExtent(paintOffset, paintedExtent))
708         return false;
709     return foregroundIsKnownToBeOpaqueInRect(paintedExtent, 0);
710 }
711 
712 LayoutUnit RenderImage::minimumReplacedHeight() const
713 {
714     return imageResource().errorOccurred() ? intrinsicSize().height() : 0_lu;
715 }
716 
717 HTMLMapElement* RenderImage::imageMap() const
718 {
719     auto* imageElement = element();
720     if (!imageElement || !is&lt;HTMLImageElement&gt;(imageElement))
721         return nullptr;
722     return downcast&lt;HTMLImageElement&gt;(imageElement)-&gt;associatedMapElement();
723 }
724 
725 bool RenderImage::nodeAtPoint(const HitTestRequest&amp; request, HitTestResult&amp; result, const HitTestLocation&amp; locationInContainer, const LayoutPoint&amp; accumulatedOffset, HitTestAction hitTestAction)
726 {
727     HitTestResult tempResult(result.hitTestLocation());
728     bool inside = RenderReplaced::nodeAtPoint(request, tempResult, locationInContainer, accumulatedOffset, hitTestAction);
729 
730     if (tempResult.innerNode() &amp;&amp; element()) {
731         if (HTMLMapElement* map = imageMap()) {
732             LayoutRect contentBox = contentBoxRect();
733             float scaleFactor = 1 / style().effectiveZoom();
734             LayoutPoint mapLocation = locationInContainer.point() - toLayoutSize(accumulatedOffset) - locationOffset() - toLayoutSize(contentBox.location());
735             mapLocation.scale(scaleFactor);
736 
737             if (map-&gt;mapMouseEvent(mapLocation, contentBox.size(), tempResult))
738                 tempResult.setInnerNonSharedNode(element());
739         }
740     }
741 
742     if (!inside &amp;&amp; request.resultIsElementList())
743         result.append(tempResult, request);
744     if (inside)
745         result = tempResult;
746     return inside;
747 }
748 
749 void RenderImage::updateAltText()
750 {
751     if (!element())
752         return;
753 
754     if (is&lt;HTMLInputElement&gt;(*element()))
755         m_altText = downcast&lt;HTMLInputElement&gt;(*element()).altText();
756     else if (is&lt;HTMLImageElement&gt;(*element()))
757         m_altText = downcast&lt;HTMLImageElement&gt;(*element()).altText();
758 }
759 
760 bool RenderImage::canHaveChildren() const
761 {
762 #if !ENABLE(SERVICE_CONTROLS)
763     return false;
764 #else
765     return m_hasShadowControls;
766 #endif
767 }
768 
769 void RenderImage::layout()
770 {
771     // Recomputing overflow is required only when child content is present.
772     if (needsSimplifiedNormalFlowLayoutOnly() &amp;&amp; !m_hasShadowControls) {
773         clearNeedsLayout();
774         return;
775     }
776 
777     StackStats::LayoutCheckPoint layoutCheckPoint;
778 
779     LayoutSize oldSize = contentBoxRect().size();
780     RenderReplaced::layout();
781 
782     updateInnerContentRect();
783 
784     if (m_hasShadowControls)
785         layoutShadowControls(oldSize);
786 }
787 
788 void RenderImage::layoutShadowControls(const LayoutSize&amp; oldSize)
789 {
790     // We expect a single containing box under the UA shadow root.
791     ASSERT(firstChild() == lastChild());
792 
793     auto* controlsRenderer = downcast&lt;RenderBox&gt;(firstChild());
794     if (!controlsRenderer)
795         return;
796 
797     bool controlsNeedLayout = controlsRenderer-&gt;needsLayout();
798     // If the region chain has changed we also need to relayout the controls to update the region box info.
799     // FIXME: We can do better once we compute region box info for RenderReplaced, not only for RenderBlock.
800     const RenderFragmentedFlow* fragmentedFlow = enclosingFragmentedFlow();
801     if (fragmentedFlow &amp;&amp; !controlsNeedLayout) {
802         if (fragmentedFlow-&gt;pageLogicalSizeChanged())
803             controlsNeedLayout = true;
804     }
805 
806     LayoutSize newSize = contentBoxRect().size();
807     if (newSize == oldSize &amp;&amp; !controlsNeedLayout)
808         return;
809 
810     // When calling layout() on a child node, a parent must either push a LayoutStateMaintainter, or
811     // instantiate LayoutStateDisabler. Since using a LayoutStateMaintainer is slightly more efficient,
812     // and this method might be called many times per second during video playback, use a LayoutStateMaintainer:
813     LayoutStateMaintainer statePusher(*this, locationOffset(), hasTransform() || hasReflection() || style().isFlippedBlocksWritingMode());
814 
815     if (shadowControlsNeedCustomLayoutMetrics()) {
816         controlsRenderer-&gt;setLocation(LayoutPoint(borderLeft(), borderTop()) + LayoutSize(paddingLeft(), paddingTop()));
817         controlsRenderer-&gt;mutableStyle().setHeight(Length(newSize.height(), Fixed));
818         controlsRenderer-&gt;mutableStyle().setWidth(Length(newSize.width(), Fixed));
819     }
820 
821     controlsRenderer-&gt;setNeedsLayout(MarkOnlyThis);
822     controlsRenderer-&gt;layout();
823     clearChildNeedsLayout();
824 }
825 
826 void RenderImage::computeIntrinsicRatioInformation(FloatSize&amp; intrinsicSize, double&amp; intrinsicRatio) const
827 {
828     RenderReplaced::computeIntrinsicRatioInformation(intrinsicSize, intrinsicRatio);
829 
830     // Our intrinsicSize is empty if we&#39;re rendering generated images with relative width/height. Figure out the right intrinsic size to use.
831     if (intrinsicSize.isEmpty() &amp;&amp; (imageResource().imageHasRelativeWidth() || imageResource().imageHasRelativeHeight())) {
832         RenderObject* containingBlock = isOutOfFlowPositioned() ? container() : this-&gt;containingBlock();
833         if (is&lt;RenderBox&gt;(*containingBlock)) {
834             auto&amp; box = downcast&lt;RenderBox&gt;(*containingBlock);
835             intrinsicSize.setWidth(box.availableLogicalWidth());
836             intrinsicSize.setHeight(box.availableLogicalHeight(IncludeMarginBorderPadding));
837         }
838     }
<a name="12" id="anc12"></a><span class="line-added">839 </span>
840     // Don&#39;t compute an intrinsic ratio to preserve historical WebKit behavior if we&#39;re painting alt text and/or a broken image.
<a name="13" id="anc13"></a><span class="line-modified">841     if (shouldDisplayBrokenImageIcon()) {</span>
842         intrinsicRatio = 1;
843         return;
844     }
845 }
846 
847 bool RenderImage::needsPreferredWidthsRecalculation() const
848 {
849     if (RenderReplaced::needsPreferredWidthsRecalculation())
850         return true;
851     return embeddedContentBox();
852 }
853 
854 RenderBox* RenderImage::embeddedContentBox() const
855 {
856     CachedImage* cachedImage = this-&gt;cachedImage();
857     if (cachedImage &amp;&amp; is&lt;SVGImage&gt;(cachedImage-&gt;image()))
858         return downcast&lt;SVGImage&gt;(*cachedImage-&gt;image()).embeddedContentBox();
859 
860     return nullptr;
861 }
862 
863 void RenderImage::incrementVisuallyNonEmptyPixelCountIfNeeded(const IntSize&amp; size)
864 {
865     if (m_didIncrementVisuallyNonEmptyPixelCount)
866         return;
867 
868     view().frameView().incrementVisuallyNonEmptyPixelCount(size);
869     m_didIncrementVisuallyNonEmptyPixelCount = true;
870 }
871 
872 } // namespace WebCore
<a name="14" id="anc14"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="14" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVarargsForwardingPhase.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DFGValidate.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGVariableAccessData.cpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/dfg/DFGVarargsForwardingPhase.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2018 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (C) 2015-2019 Apple Inc. All rights reserved.</span>
   *
   * Redistribution and use in source and binary forms, with or without
   * modification, are permitted provided that the following conditions
   * are met:
   * 1. Redistributions of source code must retain the above copyright
</pre>
<hr />
<pre>
<span class="line-old-header">*** 39,26 ***</span>
  
  namespace JSC { namespace DFG {
  
  namespace {
  
<span class="line-removed">- namespace DFGVarargsForwardingPhaseInternal {</span>
<span class="line-removed">- static const bool verbose = false;</span>
<span class="line-removed">- }</span>
  
  class VarargsForwardingPhase : public Phase {
  public:
      VarargsForwardingPhase(Graph&amp; graph)
          : Phase(graph, &quot;varargs forwarding&quot;)
      {
      }
  
      bool run()
      {
          DFG_ASSERT(m_graph, nullptr, m_graph.m_form != SSA);
  
<span class="line-modified">!         if (DFGVarargsForwardingPhaseInternal::verbose) {</span>
              dataLog(&quot;Graph before varargs forwarding:\n&quot;);
              m_graph.dump();
          }
  
          m_changed = false;
<span class="line-new-header">--- 39,24 ---</span>
  
  namespace JSC { namespace DFG {
  
  namespace {
  
  
  class VarargsForwardingPhase : public Phase {
<span class="line-added">+     static constexpr bool verbose = false;</span>
  public:
      VarargsForwardingPhase(Graph&amp; graph)
          : Phase(graph, &quot;varargs forwarding&quot;)
      {
      }
  
      bool run()
      {
          DFG_ASSERT(m_graph, nullptr, m_graph.m_form != SSA);
  
<span class="line-modified">!         if (verbose) {</span>
              dataLog(&quot;Graph before varargs forwarding:\n&quot;);
              m_graph.dump();
          }
  
          m_changed = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 86,11 ***</span>
      void handleCandidate(BasicBlock* block, unsigned candidateNodeIndex)
      {
          // We expect calls into this function to be rare. So, this is written in a simple O(n) manner.
  
          Node* candidate = block-&gt;at(candidateNodeIndex);
<span class="line-modified">!         if (DFGVarargsForwardingPhaseInternal::verbose)</span>
              dataLog(&quot;Handling candidate &quot;, candidate, &quot;\n&quot;);
  
          // We eliminate GetButterfly over CreateClonedArguments if the butterfly is only
          // used by a GetByOffset  that loads the CreateClonedArguments&#39;s length. We also
          // eliminate it if the GetButterfly node is totally unused.
<span class="line-new-header">--- 84,11 ---</span>
      void handleCandidate(BasicBlock* block, unsigned candidateNodeIndex)
      {
          // We expect calls into this function to be rare. So, this is written in a simple O(n) manner.
  
          Node* candidate = block-&gt;at(candidateNodeIndex);
<span class="line-modified">!         if (verbose)</span>
              dataLog(&quot;Handling candidate &quot;, candidate, &quot;\n&quot;);
  
          // We eliminate GetButterfly over CreateClonedArguments if the butterfly is only
          // used by a GetByOffset  that loads the CreateClonedArguments&#39;s length. We also
          // eliminate it if the GetButterfly node is totally unused.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 103,11 ***</span>
          for (unsigned nodeIndex = candidateNodeIndex + 1; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
              Node* node = block-&gt;at(nodeIndex);
  
              auto defaultEscape = [&amp;] {
                  if (m_graph.uses(node, candidate)) {
<span class="line-modified">!                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
                          dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
                      return true;
                  }
                  return false;
              };
<span class="line-new-header">--- 101,11 ---</span>
          for (unsigned nodeIndex = candidateNodeIndex + 1; nodeIndex &lt; block-&gt;size(); ++nodeIndex) {
              Node* node = block-&gt;at(nodeIndex);
  
              auto defaultEscape = [&amp;] {
                  if (m_graph.uses(node, candidate)) {
<span class="line-modified">!                     if (verbose)</span>
                          dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
                      return true;
                  }
                  return false;
              };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 115,13 ***</span>
              bool validGetByOffset = false;
              switch (node-&gt;op()) {
              case MovHint:
                  if (node-&gt;child1() != candidate)
                      break;
                  lastUserIndex = nodeIndex;
<span class="line-modified">!                 if (!relevantLocals.contains(node-&gt;unlinkedLocal()))</span>
<span class="line-modified">!                     relevantLocals.append(node-&gt;unlinkedLocal());</span>
                  break;
  
              case CheckVarargs:
              case Check: {
                  bool sawEscape = false;
<span class="line-new-header">--- 113,14 ---</span>
              bool validGetByOffset = false;
              switch (node-&gt;op()) {
              case MovHint:
                  if (node-&gt;child1() != candidate)
                      break;
<span class="line-added">+                 ASSERT_WITH_MESSAGE(!node-&gt;unlinkedOperand().isTmp(), &quot;We don&#39;t currently support a tmp referring to an arguments object.&quot;);</span>
                  lastUserIndex = nodeIndex;
<span class="line-modified">!                 if (!relevantLocals.contains(node-&gt;unlinkedOperand().virtualRegister()))</span>
<span class="line-modified">!                     relevantLocals.append(node-&gt;unlinkedOperand().virtualRegister());</span>
                  break;
  
              case CheckVarargs:
              case Check: {
                  bool sawEscape = false;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 138,38 ***</span>
                              return;
  
                          sawEscape = true;
                      });
                  if (sawEscape) {
<span class="line-modified">!                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
                          dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
                      return;
                  }
                  break;
              }
  
              case LoadVarargs:
                  if (m_graph.uses(node, candidate))
                      lastUserIndex = nodeIndex;
                  break;
  
              case CallVarargs:
              case ConstructVarargs:
              case TailCallVarargs:
              case TailCallVarargsInlinedCaller:
                  if (node-&gt;child1() == candidate || node-&gt;child2() == candidate) {
<span class="line-modified">!                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
                          dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
                      return;
                  }
                  if (node-&gt;child2() == candidate)
                      lastUserIndex = nodeIndex;
                  break;
  
              case SetLocal:
                  if (node-&gt;child1() == candidate &amp;&amp; node-&gt;variableAccessData()-&gt;isLoadedFrom()) {
<span class="line-modified">!                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
                          dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
                      return;
                  }
                  break;
  
<span class="line-new-header">--- 137,39 ---</span>
                              return;
  
                          sawEscape = true;
                      });
                  if (sawEscape) {
<span class="line-modified">!                     if (verbose)</span>
                          dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
                      return;
                  }
                  break;
              }
  
<span class="line-added">+             case VarargsLength:</span>
              case LoadVarargs:
                  if (m_graph.uses(node, candidate))
                      lastUserIndex = nodeIndex;
                  break;
  
              case CallVarargs:
              case ConstructVarargs:
              case TailCallVarargs:
              case TailCallVarargsInlinedCaller:
                  if (node-&gt;child1() == candidate || node-&gt;child2() == candidate) {
<span class="line-modified">!                     if (verbose)</span>
                          dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
                      return;
                  }
                  if (node-&gt;child2() == candidate)
                      lastUserIndex = nodeIndex;
                  break;
  
              case SetLocal:
                  if (node-&gt;child1() == candidate &amp;&amp; node-&gt;variableAccessData()-&gt;isLoadedFrom()) {
<span class="line-modified">!                     if (verbose)</span>
                          dataLog(&quot;    Escape at &quot;, node, &quot;\n&quot;);
                      return;
                  }
                  break;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 192,11 ***</span>
                  if (defaultEscape())
                      return;
                  break;
              }
  
<span class="line-modified">!             case FilterGetByIdStatus:</span>
              case FilterPutByIdStatus:
              case FilterCallLinkStatus:
              case FilterInByIdStatus:
                  break;
  
<span class="line-new-header">--- 192,11 ---</span>
                  if (defaultEscape())
                      return;
                  break;
              }
  
<span class="line-modified">!             case FilterGetByStatus:</span>
              case FilterPutByIdStatus:
              case FilterCallLinkStatus:
              case FilterInByIdStatus:
                  break;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 224,32 ***</span>
              }
  
              if (!validGetByOffset) {
                  for (Node* butterfly : candidateButterflies) {
                      if (m_graph.uses(node, butterfly)) {
<span class="line-modified">!                         if (DFGVarargsForwardingPhaseInternal::verbose)</span>
                              dataLog(&quot;    Butterfly escaped at &quot;, node, &quot;\n&quot;);
                          return;
                      }
                  }
              }
  
              forAllKilledOperands(
                  m_graph, node, block-&gt;tryAt(nodeIndex + 1),
<span class="line-modified">!                 [&amp;] (VirtualRegister reg) {</span>
<span class="line-modified">!                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
<span class="line-modified">!                         dataLog(&quot;    Killing &quot;, reg, &quot; while we are interested in &quot;, listDump(relevantLocals), &quot;\n&quot;);</span>
                      for (unsigned i = 0; i &lt; relevantLocals.size(); ++i) {
<span class="line-modified">!                         if (relevantLocals[i] == reg) {</span>
                              relevantLocals[i--] = relevantLocals.last();
                              relevantLocals.removeLast();
                              lastUserIndex = nodeIndex;
                          }
                      }
                  });
          }
<span class="line-modified">!         if (DFGVarargsForwardingPhaseInternal::verbose)</span>
              dataLog(&quot;Selected lastUserIndex = &quot;, lastUserIndex, &quot;, &quot;, block-&gt;at(lastUserIndex), &quot;\n&quot;);
  
          // We&#39;re still in business. Determine if between the candidate and the last user there is any
          // effect that could interfere with sinking.
          for (unsigned nodeIndex = candidateNodeIndex + 1; nodeIndex &lt;= lastUserIndex; ++nodeIndex) {
<span class="line-new-header">--- 224,32 ---</span>
              }
  
              if (!validGetByOffset) {
                  for (Node* butterfly : candidateButterflies) {
                      if (m_graph.uses(node, butterfly)) {
<span class="line-modified">!                         if (verbose)</span>
                              dataLog(&quot;    Butterfly escaped at &quot;, node, &quot;\n&quot;);
                          return;
                      }
                  }
              }
  
              forAllKilledOperands(
                  m_graph, node, block-&gt;tryAt(nodeIndex + 1),
<span class="line-modified">!                 [&amp;] (Operand operand) {</span>
<span class="line-modified">!                     if (verbose)</span>
<span class="line-modified">!                         dataLog(&quot;    Killing &quot;, operand, &quot; while we are interested in &quot;, listDump(relevantLocals), &quot;\n&quot;);</span>
                      for (unsigned i = 0; i &lt; relevantLocals.size(); ++i) {
<span class="line-modified">!                         if (operand == relevantLocals[i]) {</span>
                              relevantLocals[i--] = relevantLocals.last();
                              relevantLocals.removeLast();
                              lastUserIndex = nodeIndex;
                          }
                      }
                  });
          }
<span class="line-modified">!         if (verbose)</span>
              dataLog(&quot;Selected lastUserIndex = &quot;, lastUserIndex, &quot;, &quot;, block-&gt;at(lastUserIndex), &quot;\n&quot;);
  
          // We&#39;re still in business. Determine if between the candidate and the last user there is any
          // effect that could interfere with sinking.
          for (unsigned nodeIndex = candidateNodeIndex + 1; nodeIndex &lt;= lastUserIndex; ++nodeIndex) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 261,29 ***</span>
              // what gets read on OSR exit.
              switch (node-&gt;op()) {
              case MovHint:
              case ZombieHint:
              case KillStack:
<span class="line-modified">!                 if (argumentsInvolveStackSlot(candidate, node-&gt;unlinkedLocal())) {</span>
<span class="line-modified">!                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
                          dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
                      return;
                  }
                  break;
  
              case PutStack:
<span class="line-modified">!                 if (argumentsInvolveStackSlot(candidate, node-&gt;stackAccessData()-&gt;local)) {</span>
<span class="line-modified">!                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
                          dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
                      return;
                  }
                  break;
  
              case SetLocal:
              case Flush:
<span class="line-modified">!                 if (argumentsInvolveStackSlot(candidate, node-&gt;local())) {</span>
<span class="line-modified">!                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
                          dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
                      return;
                  }
                  break;
  
<span class="line-new-header">--- 261,29 ---</span>
              // what gets read on OSR exit.
              switch (node-&gt;op()) {
              case MovHint:
              case ZombieHint:
              case KillStack:
<span class="line-modified">!                 if (argumentsInvolveStackSlot(candidate, node-&gt;unlinkedOperand())) {</span>
<span class="line-modified">!                     if (verbose)</span>
                          dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
                      return;
                  }
                  break;
  
              case PutStack:
<span class="line-modified">!                 if (argumentsInvolveStackSlot(candidate, node-&gt;stackAccessData()-&gt;operand)) {</span>
<span class="line-modified">!                     if (verbose)</span>
                          dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
                      return;
                  }
                  break;
  
              case SetLocal:
              case Flush:
<span class="line-modified">!                 if (argumentsInvolveStackSlot(candidate, node-&gt;operand())) {</span>
<span class="line-modified">!                     if (verbose)</span>
                          dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
                      return;
                  }
                  break;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 295,25 ***</span>
                          if (heap.kind() != Stack) {
                              ASSERT(!heap.overlaps(Stack));
                              return;
                          }
                          ASSERT(!heap.payload().isTop());
<span class="line-modified">!                         VirtualRegister reg(heap.payload().value32());</span>
<span class="line-removed">-                         if (argumentsInvolveStackSlot(candidate, reg))</span>
                              doesInterfere = true;
                      },
                      NoOpClobberize());
                  if (doesInterfere) {
<span class="line-modified">!                     if (DFGVarargsForwardingPhaseInternal::verbose)</span>
                          dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
                      return;
                  }
              } }
          }
  
          // We can make this work.
<span class="line-modified">!         if (DFGVarargsForwardingPhaseInternal::verbose)</span>
              dataLog(&quot;    Will do forwarding!\n&quot;);
          m_changed = true;
  
          // Transform the program.
          switch (candidate-&gt;op()) {
<span class="line-new-header">--- 295,24 ---</span>
                          if (heap.kind() != Stack) {
                              ASSERT(!heap.overlaps(Stack));
                              return;
                          }
                          ASSERT(!heap.payload().isTop());
<span class="line-modified">!                         if (argumentsInvolveStackSlot(candidate, heap.operand()))</span>
                              doesInterfere = true;
                      },
                      NoOpClobberize());
                  if (doesInterfere) {
<span class="line-modified">!                     if (verbose)</span>
                          dataLog(&quot;    Interference at &quot;, node, &quot;\n&quot;);
                      return;
                  }
              } }
          }
  
          // We can make this work.
<span class="line-modified">!         if (verbose)</span>
              dataLog(&quot;    Will do forwarding!\n&quot;);
          m_changed = true;
  
          // Transform the program.
          switch (candidate-&gt;op()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 339,12 ***</span>
              case MovHint:
              case PutHint:
                  // We don&#39;t need to change anything with these.
                  break;
  
              case LoadVarargs:
<span class="line-modified">!                 if (node-&gt;child1() != candidate)</span>
                      break;
                  node-&gt;setOpAndDefaultFlags(ForwardVarargs);
                  break;
  
              case CallVarargs:
<span class="line-new-header">--- 338,20 ---</span>
              case MovHint:
              case PutHint:
                  // We don&#39;t need to change anything with these.
                  break;
  
<span class="line-added">+             case VarargsLength: {</span>
<span class="line-added">+                 if (node-&gt;argumentsChild() != candidate)</span>
<span class="line-added">+                     break;</span>
<span class="line-added">+ </span>
<span class="line-added">+                 node-&gt;convertToIdentityOn(emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, node-&gt;origin, /* addThis = */ true));</span>
<span class="line-added">+                 break;</span>
<span class="line-added">+             }</span>
<span class="line-added">+ </span>
              case LoadVarargs:
<span class="line-modified">!                 if (node-&gt;argumentsChild() != candidate)</span>
                      break;
                  node-&gt;setOpAndDefaultFlags(ForwardVarargs);
                  break;
  
              case CallVarargs:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 386,11 ***</span>
                      node-&gt;remove(m_graph);
                  }
                  break;
              }
  
<span class="line-modified">!             case FilterGetByIdStatus:</span>
              case FilterPutByIdStatus:
              case FilterCallLinkStatus:
              case FilterInByIdStatus:
                  if (node-&gt;child1().node() == candidate)
                      node-&gt;remove(m_graph);
<span class="line-new-header">--- 393,11 ---</span>
                      node-&gt;remove(m_graph);
                  }
                  break;
              }
  
<span class="line-modified">!             case FilterGetByStatus:</span>
              case FilterPutByIdStatus:
              case FilterCallLinkStatus:
              case FilterInByIdStatus:
                  if (node-&gt;child1().node() == candidate)
                      node-&gt;remove(m_graph);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 412,11 ***</span>
                          emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, node-&gt;origin));
                  }
                  break;
  
              default:
<span class="line-modified">!                 if (ASSERT_DISABLED)</span>
                      break;
                  m_graph.doToChildren(
                      node,
                      [&amp;] (Edge edge) {
                          DFG_ASSERT(m_graph, node, edge != candidate);
<span class="line-new-header">--- 419,11 ---</span>
                          emitCodeToGetArgumentsArrayLength(insertionSet, candidate, nodeIndex, node-&gt;origin));
                  }
                  break;
  
              default:
<span class="line-modified">!                 if (!ASSERT_ENABLED)</span>
                      break;
                  m_graph.doToChildren(
                      node,
                      [&amp;] (Edge edge) {
                          DFG_ASSERT(m_graph, node, edge != candidate);
</pre>
<center><a href="DFGValidate.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="DFGVariableAccessData.cpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
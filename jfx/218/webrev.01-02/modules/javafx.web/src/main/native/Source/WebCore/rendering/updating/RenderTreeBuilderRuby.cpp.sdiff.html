<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderRuby.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderTreeBuilderMultiColumn.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderTreeBuilderTable.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/updating/RenderTreeBuilderRuby.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 31 #include &quot;RenderRubyBase.h&quot;
 32 #include &quot;RenderRubyRun.h&quot;
 33 #include &quot;RenderTreeBuilder.h&quot;
 34 #include &quot;RenderTreeBuilderBlock.h&quot;
 35 #include &quot;RenderTreeBuilderBlockFlow.h&quot;
 36 #include &quot;RenderTreeBuilderInline.h&quot;
 37 
 38 namespace WebCore {
 39 
 40 static inline RenderRubyRun&amp; findRubyRunParent(RenderObject&amp; child)
 41 {
 42     return *lineageOfType&lt;RenderRubyRun&gt;(child).first();
 43 }
 44 
 45 static inline bool isAnonymousRubyInlineBlock(const RenderObject* object)
 46 {
 47     ASSERT(!object
 48         || !isRuby(object-&gt;parent())
 49         || is&lt;RenderRubyRun&gt;(*object)
 50         || (object-&gt;isInline() &amp;&amp; (object-&gt;isBeforeContent() || object-&gt;isAfterContent()))
<span class="line-modified"> 51         || (object-&gt;isAnonymous() &amp;&amp; is&lt;RenderBlock&gt;(*object) &amp;&amp; object-&gt;style().display() == DisplayType::InlineBlock));</span>


 52 
 53     return object
 54         &amp;&amp; isRuby(object-&gt;parent())
 55         &amp;&amp; is&lt;RenderBlock&gt;(*object)
 56         &amp;&amp; !is&lt;RenderRubyRun&gt;(*object);
 57 }
 58 
 59 static inline bool isRubyBeforeBlock(const RenderObject* object)
 60 {
 61     return isAnonymousRubyInlineBlock(object)
 62         &amp;&amp; !object-&gt;previousSibling()
 63         &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()
 64         &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()-&gt;style().styleType() == PseudoId::Before;
 65 }
 66 
 67 static inline bool isRubyAfterBlock(const RenderObject* object)
 68 {
 69     return isAnonymousRubyInlineBlock(object)
 70         &amp;&amp; !object-&gt;nextSibling()
 71         &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()
 72         &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()-&gt;style().styleType() == PseudoId::After;
 73 }
 74 
<span class="line-modified"> 75 #ifndef ASSERT_DISABLED</span>
 76 static inline bool isRubyChildForNormalRemoval(const RenderObject&amp; object)
 77 {
 78     return object.isRubyRun()
 79     || object.isBeforeContent()
 80     || object.isAfterContent()
 81     || object.isRenderMultiColumnFlow()
 82     || object.isRenderMultiColumnSet()
 83     || isAnonymousRubyInlineBlock(&amp;object);
 84 }
<span class="line-modified"> 85 #endif</span>
 86 
 87 static inline RenderBlock* rubyBeforeBlock(const RenderElement* ruby)
 88 {
 89     RenderObject* child = ruby-&gt;firstChild();
 90     return isRubyBeforeBlock(child) ? downcast&lt;RenderBlock&gt;(child) : nullptr;
 91 }
 92 
 93 static inline RenderBlock* rubyAfterBlock(const RenderElement* ruby)
 94 {
 95     RenderObject* child = ruby-&gt;lastChild();
 96     return isRubyAfterBlock(child) ? downcast&lt;RenderBlock&gt;(child) : nullptr;
 97 }
 98 
 99 static auto createAnonymousRubyInlineBlock(RenderObject&amp; ruby)
100 {
101     auto newBlock = createRenderer&lt;RenderBlockFlow&gt;(ruby.document(), RenderStyle::createAnonymousStyleWithDisplay(ruby.style(), DisplayType::InlineBlock));
102     newBlock-&gt;initializeStyle();
103     return newBlock;
104 }
105 
106 static RenderRubyRun* lastRubyRun(const RenderElement* ruby)
107 {
108     RenderObject* child = ruby-&gt;lastChild();
109     if (child &amp;&amp; !is&lt;RenderRubyRun&gt;(*child))
110         child = child-&gt;previousSibling();
111     if (!is&lt;RenderRubyRun&gt;(child)) {
<span class="line-modified">112         ASSERT(!child || child-&gt;isBeforeContent() || child == rubyBeforeBlock(ruby));</span>
113         return nullptr;
114     }
115     return downcast&lt;RenderRubyRun&gt;(child);
116 }
117 
118 RenderTreeBuilder::Ruby::Ruby(RenderTreeBuilder&amp; builder)
119     : m_builder(builder)
120 {
121 }
122 
123 void RenderTreeBuilder::Ruby::moveInlineChildren(RenderRubyBase&amp; from, RenderRubyBase&amp; to, RenderObject* beforeChild)
124 {
125     ASSERT(from.childrenInline());
126 
127     if (!from.firstChild())
128         return;
129 
130     RenderBlock* toBlock = nullptr;
131     if (to.childrenInline()) {
132         // The standard and easy case: move the children into the target base
</pre>
<hr />
<pre>
196 }
197 
198 void RenderTreeBuilder::Ruby::attach(RenderRubyRun&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
199 {
200     if (child-&gt;isRubyText()) {
201         if (!beforeChild) {
202             // RenderRuby has already ascertained that we can add the child here.
203             ASSERT(!parent.hasRubyText());
204             // prepend ruby texts as first child
205             m_builder.blockFlowBuilder().attach(parent, WTFMove(child), parent.firstChild());
206             return;
207         }
208         if (beforeChild-&gt;isRubyText()) {
209             // New text is inserted just before another.
210             // In this case the new text takes the place of the old one, and
211             // the old text goes into a new run that is inserted as next sibling.
212             ASSERT(beforeChild-&gt;parent() == &amp;parent);
213             RenderElement* ruby = parent.parent();
214             ASSERT(isRuby(ruby));
215             auto newRun = RenderRubyRun::staticCreateRubyRun(ruby);

216             m_builder.attach(*ruby, WTFMove(newRun), parent.nextSibling());
217             // Add the new ruby text and move the old one to the new run
218             // Note: Doing it in this order and not using RenderRubyRun&#39;s methods,
219             // in order to avoid automatic removal of the ruby run in case there is no
220             // other child besides the old ruby text.
221             m_builder.blockFlowBuilder().attach(parent, WTFMove(child), beforeChild);
222             auto takenBeforeChild = m_builder.blockBuilder().detach(parent, *beforeChild);
223 
<span class="line-modified">224             m_builder.attach(*newRun, WTFMove(takenBeforeChild));</span>
225             return;
226         }
227         if (parent.hasRubyBase()) {
228             // Insertion before a ruby base object.
229             // In this case we need insert a new run before the current one and split the base.
230             RenderElement* ruby = parent.parent();
231             auto newRun = RenderRubyRun::staticCreateRubyRun(ruby);
232             auto&amp; run = *newRun;
233             m_builder.attach(*ruby, WTFMove(newRun), &amp;parent);
234             m_builder.attach(run, WTFMove(child));
235             moveChildrenInternal(rubyBaseSafe(parent), rubyBaseSafe(run), beforeChild);
236         }
237         return;
238     }
239     // child is not a text -&gt; insert it into the base
240     // (append it instead if beforeChild is the ruby text)
241     if (beforeChild &amp;&amp; beforeChild-&gt;isRubyText())
242         beforeChild = nullptr;
243     m_builder.attach(rubyBaseSafe(parent), WTFMove(child), beforeChild);
244 }
</pre>
<hr />
<pre>
366     beforeChild = nullptr;
367     return *lastRun;
368 }
369 
370 RenderRubyBase&amp; RenderTreeBuilder::Ruby::rubyBaseSafe(RenderRubyRun&amp; rubyRun)
371 {
372     auto* base = rubyRun.rubyBase();
373     if (!base) {
374         auto newBase = rubyRun.createRubyBase();
375         base = newBase.get();
376         m_builder.blockFlowBuilder().attach(rubyRun, WTFMove(newBase), nullptr);
377     }
378     return *base;
379 }
380 
381 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::Ruby::detach(RenderRubyAsInline&amp; parent, RenderObject&amp; child)
382 {
383     // If the child&#39;s parent is *this (must be a ruby run or generated content or anonymous block),
384     // just use the normal remove method.
385     if (child.parent() == &amp;parent) {
<span class="line-removed">386 #ifndef ASSERT_DISABLED</span>
387         ASSERT(isRubyChildForNormalRemoval(child));
<span class="line-removed">388 #endif</span>
389         return m_builder.detachFromRenderElement(parent, child);
390     }
391     // If the child&#39;s parent is an anoymous block (must be generated :before/:after content)
392     // just use the block&#39;s remove method.
393     if (isAnonymousRubyInlineBlock(child.parent())) {
394         ASSERT(child.isBeforeContent() || child.isAfterContent());
395         auto&amp; parent = *child.parent();
396         auto takenChild = m_builder.detach(parent, child);
397         m_builder.destroy(parent);
398         return takenChild;
399     }
400 
401     // Otherwise find the containing run and remove it from there.
402     return m_builder.detach(findRubyRunParent(child), child);
403 }
404 
405 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::Ruby::detach(RenderRubyAsBlock&amp; parent, RenderObject&amp; child)
406 {
407     // If the child&#39;s parent is *this (must be a ruby run or generated content or anonymous block),
408     // just use the normal remove method.
409     if (child.parent() == &amp;parent) {
<span class="line-removed">410 #ifndef ASSERT_DISABLED</span>
411         ASSERT(isRubyChildForNormalRemoval(child));
<span class="line-removed">412 #endif</span>
413         return m_builder.blockBuilder().detach(parent, child);
414     }
415     // If the child&#39;s parent is an anoymous block (must be generated :before/:after content)
416     // just use the block&#39;s remove method.
417     if (isAnonymousRubyInlineBlock(child.parent())) {
418         ASSERT(child.isBeforeContent() || child.isAfterContent());
419         auto&amp; parent = *child.parent();
420         auto takenChild = m_builder.detach(parent, child);
421         m_builder.destroy(parent);
422         return takenChild;
423     }
424 
425     // Otherwise find the containing run and remove it from there.
426     return m_builder.detach(findRubyRunParent(child), child);
427 }
428 
429 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::Ruby::detach(RenderRubyRun&amp; parent, RenderObject&amp; child)
430 {
431     // If the child is a ruby text, then merge the ruby base with the base of
432     // the right sibling run, if possible.
</pre>
</td>
<td>
<hr />
<pre>
 31 #include &quot;RenderRubyBase.h&quot;
 32 #include &quot;RenderRubyRun.h&quot;
 33 #include &quot;RenderTreeBuilder.h&quot;
 34 #include &quot;RenderTreeBuilderBlock.h&quot;
 35 #include &quot;RenderTreeBuilderBlockFlow.h&quot;
 36 #include &quot;RenderTreeBuilderInline.h&quot;
 37 
 38 namespace WebCore {
 39 
 40 static inline RenderRubyRun&amp; findRubyRunParent(RenderObject&amp; child)
 41 {
 42     return *lineageOfType&lt;RenderRubyRun&gt;(child).first();
 43 }
 44 
 45 static inline bool isAnonymousRubyInlineBlock(const RenderObject* object)
 46 {
 47     ASSERT(!object
 48         || !isRuby(object-&gt;parent())
 49         || is&lt;RenderRubyRun&gt;(*object)
 50         || (object-&gt;isInline() &amp;&amp; (object-&gt;isBeforeContent() || object-&gt;isAfterContent()))
<span class="line-modified"> 51         || (object-&gt;isAnonymous() &amp;&amp; is&lt;RenderBlock&gt;(*object) &amp;&amp; object-&gt;style().display() == DisplayType::InlineBlock)</span>
<span class="line-added"> 52         || object-&gt;isRenderMultiColumnFlow()</span>
<span class="line-added"> 53         || object-&gt;isRenderMultiColumnSet());</span>
 54 
 55     return object
 56         &amp;&amp; isRuby(object-&gt;parent())
 57         &amp;&amp; is&lt;RenderBlock&gt;(*object)
 58         &amp;&amp; !is&lt;RenderRubyRun&gt;(*object);
 59 }
 60 
 61 static inline bool isRubyBeforeBlock(const RenderObject* object)
 62 {
 63     return isAnonymousRubyInlineBlock(object)
 64         &amp;&amp; !object-&gt;previousSibling()
 65         &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()
 66         &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()-&gt;style().styleType() == PseudoId::Before;
 67 }
 68 
 69 static inline bool isRubyAfterBlock(const RenderObject* object)
 70 {
 71     return isAnonymousRubyInlineBlock(object)
 72         &amp;&amp; !object-&gt;nextSibling()
 73         &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()
 74         &amp;&amp; downcast&lt;RenderBlock&gt;(*object).firstChild()-&gt;style().styleType() == PseudoId::After;
 75 }
 76 
<span class="line-modified"> 77 #if ASSERT_ENABLED</span>
 78 static inline bool isRubyChildForNormalRemoval(const RenderObject&amp; object)
 79 {
 80     return object.isRubyRun()
 81     || object.isBeforeContent()
 82     || object.isAfterContent()
 83     || object.isRenderMultiColumnFlow()
 84     || object.isRenderMultiColumnSet()
 85     || isAnonymousRubyInlineBlock(&amp;object);
 86 }
<span class="line-modified"> 87 #endif // ASSERT_ENABLED</span>
 88 
 89 static inline RenderBlock* rubyBeforeBlock(const RenderElement* ruby)
 90 {
 91     RenderObject* child = ruby-&gt;firstChild();
 92     return isRubyBeforeBlock(child) ? downcast&lt;RenderBlock&gt;(child) : nullptr;
 93 }
 94 
 95 static inline RenderBlock* rubyAfterBlock(const RenderElement* ruby)
 96 {
 97     RenderObject* child = ruby-&gt;lastChild();
 98     return isRubyAfterBlock(child) ? downcast&lt;RenderBlock&gt;(child) : nullptr;
 99 }
100 
101 static auto createAnonymousRubyInlineBlock(RenderObject&amp; ruby)
102 {
103     auto newBlock = createRenderer&lt;RenderBlockFlow&gt;(ruby.document(), RenderStyle::createAnonymousStyleWithDisplay(ruby.style(), DisplayType::InlineBlock));
104     newBlock-&gt;initializeStyle();
105     return newBlock;
106 }
107 
108 static RenderRubyRun* lastRubyRun(const RenderElement* ruby)
109 {
110     RenderObject* child = ruby-&gt;lastChild();
111     if (child &amp;&amp; !is&lt;RenderRubyRun&gt;(*child))
112         child = child-&gt;previousSibling();
113     if (!is&lt;RenderRubyRun&gt;(child)) {
<span class="line-modified">114         ASSERT(!child || child-&gt;isBeforeContent() || child == rubyBeforeBlock(ruby) || child-&gt;isRenderMultiColumnFlow() || child-&gt;isRenderMultiColumnSet());</span>
115         return nullptr;
116     }
117     return downcast&lt;RenderRubyRun&gt;(child);
118 }
119 
120 RenderTreeBuilder::Ruby::Ruby(RenderTreeBuilder&amp; builder)
121     : m_builder(builder)
122 {
123 }
124 
125 void RenderTreeBuilder::Ruby::moveInlineChildren(RenderRubyBase&amp; from, RenderRubyBase&amp; to, RenderObject* beforeChild)
126 {
127     ASSERT(from.childrenInline());
128 
129     if (!from.firstChild())
130         return;
131 
132     RenderBlock* toBlock = nullptr;
133     if (to.childrenInline()) {
134         // The standard and easy case: move the children into the target base
</pre>
<hr />
<pre>
198 }
199 
200 void RenderTreeBuilder::Ruby::attach(RenderRubyRun&amp; parent, RenderPtr&lt;RenderObject&gt; child, RenderObject* beforeChild)
201 {
202     if (child-&gt;isRubyText()) {
203         if (!beforeChild) {
204             // RenderRuby has already ascertained that we can add the child here.
205             ASSERT(!parent.hasRubyText());
206             // prepend ruby texts as first child
207             m_builder.blockFlowBuilder().attach(parent, WTFMove(child), parent.firstChild());
208             return;
209         }
210         if (beforeChild-&gt;isRubyText()) {
211             // New text is inserted just before another.
212             // In this case the new text takes the place of the old one, and
213             // the old text goes into a new run that is inserted as next sibling.
214             ASSERT(beforeChild-&gt;parent() == &amp;parent);
215             RenderElement* ruby = parent.parent();
216             ASSERT(isRuby(ruby));
217             auto newRun = RenderRubyRun::staticCreateRubyRun(ruby);
<span class="line-added">218             auto&amp; run = *newRun;</span>
219             m_builder.attach(*ruby, WTFMove(newRun), parent.nextSibling());
220             // Add the new ruby text and move the old one to the new run
221             // Note: Doing it in this order and not using RenderRubyRun&#39;s methods,
222             // in order to avoid automatic removal of the ruby run in case there is no
223             // other child besides the old ruby text.
224             m_builder.blockFlowBuilder().attach(parent, WTFMove(child), beforeChild);
225             auto takenBeforeChild = m_builder.blockBuilder().detach(parent, *beforeChild);
226 
<span class="line-modified">227             m_builder.attach(run, WTFMove(takenBeforeChild));</span>
228             return;
229         }
230         if (parent.hasRubyBase()) {
231             // Insertion before a ruby base object.
232             // In this case we need insert a new run before the current one and split the base.
233             RenderElement* ruby = parent.parent();
234             auto newRun = RenderRubyRun::staticCreateRubyRun(ruby);
235             auto&amp; run = *newRun;
236             m_builder.attach(*ruby, WTFMove(newRun), &amp;parent);
237             m_builder.attach(run, WTFMove(child));
238             moveChildrenInternal(rubyBaseSafe(parent), rubyBaseSafe(run), beforeChild);
239         }
240         return;
241     }
242     // child is not a text -&gt; insert it into the base
243     // (append it instead if beforeChild is the ruby text)
244     if (beforeChild &amp;&amp; beforeChild-&gt;isRubyText())
245         beforeChild = nullptr;
246     m_builder.attach(rubyBaseSafe(parent), WTFMove(child), beforeChild);
247 }
</pre>
<hr />
<pre>
369     beforeChild = nullptr;
370     return *lastRun;
371 }
372 
373 RenderRubyBase&amp; RenderTreeBuilder::Ruby::rubyBaseSafe(RenderRubyRun&amp; rubyRun)
374 {
375     auto* base = rubyRun.rubyBase();
376     if (!base) {
377         auto newBase = rubyRun.createRubyBase();
378         base = newBase.get();
379         m_builder.blockFlowBuilder().attach(rubyRun, WTFMove(newBase), nullptr);
380     }
381     return *base;
382 }
383 
384 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::Ruby::detach(RenderRubyAsInline&amp; parent, RenderObject&amp; child)
385 {
386     // If the child&#39;s parent is *this (must be a ruby run or generated content or anonymous block),
387     // just use the normal remove method.
388     if (child.parent() == &amp;parent) {

389         ASSERT(isRubyChildForNormalRemoval(child));

390         return m_builder.detachFromRenderElement(parent, child);
391     }
392     // If the child&#39;s parent is an anoymous block (must be generated :before/:after content)
393     // just use the block&#39;s remove method.
394     if (isAnonymousRubyInlineBlock(child.parent())) {
395         ASSERT(child.isBeforeContent() || child.isAfterContent());
396         auto&amp; parent = *child.parent();
397         auto takenChild = m_builder.detach(parent, child);
398         m_builder.destroy(parent);
399         return takenChild;
400     }
401 
402     // Otherwise find the containing run and remove it from there.
403     return m_builder.detach(findRubyRunParent(child), child);
404 }
405 
406 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::Ruby::detach(RenderRubyAsBlock&amp; parent, RenderObject&amp; child)
407 {
408     // If the child&#39;s parent is *this (must be a ruby run or generated content or anonymous block),
409     // just use the normal remove method.
410     if (child.parent() == &amp;parent) {

411         ASSERT(isRubyChildForNormalRemoval(child));

412         return m_builder.blockBuilder().detach(parent, child);
413     }
414     // If the child&#39;s parent is an anoymous block (must be generated :before/:after content)
415     // just use the block&#39;s remove method.
416     if (isAnonymousRubyInlineBlock(child.parent())) {
417         ASSERT(child.isBeforeContent() || child.isAfterContent());
418         auto&amp; parent = *child.parent();
419         auto takenChild = m_builder.detach(parent, child);
420         m_builder.destroy(parent);
421         return takenChild;
422     }
423 
424     // Otherwise find the containing run and remove it from there.
425     return m_builder.detach(findRubyRunParent(child), child);
426 }
427 
428 RenderPtr&lt;RenderObject&gt; RenderTreeBuilder::Ruby::detach(RenderRubyRun&amp; parent, RenderObject&amp; child)
429 {
430     // If the child is a ruby text, then merge the ruby base with the base of
431     // the right sibling run, if possible.
</pre>
</td>
</tr>
</table>
<center><a href="RenderTreeBuilderMultiColumn.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="RenderTreeBuilderTable.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
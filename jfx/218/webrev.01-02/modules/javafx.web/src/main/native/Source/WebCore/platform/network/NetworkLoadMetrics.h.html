<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/network/NetworkLoadMetrics.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2010 Google, Inc. All Rights Reserved.
  3  * Copyright (C) 2014-2017 Apple, Inc. All Rights Reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;HTTPHeaderMap.h&quot;
 30 #include &lt;wtf/Optional.h&gt;
 31 #include &lt;wtf/Seconds.h&gt;
 32 #include &lt;wtf/persistence/PersistentDecoder.h&gt;
 33 #include &lt;wtf/persistence/PersistentEncoder.h&gt;
 34 #include &lt;wtf/text/WTFString.h&gt;
 35 
 36 #if PLATFORM(COCOA)
 37 OBJC_CLASS NSDictionary;
 38 #endif
 39 
 40 namespace WebCore {
 41 
 42 enum class NetworkLoadPriority : uint8_t {
 43     Low,
 44     Medium,
 45     High,
 46     Unknown,
 47 };
 48 
 49 class NetworkLoadMetrics {
 50 public:
 51     NetworkLoadMetrics()
 52     {
 53         reset();
 54     }
 55 
 56     NetworkLoadMetrics isolatedCopy() const
 57     {
 58         NetworkLoadMetrics copy;
 59 
 60         copy.domainLookupStart = domainLookupStart;
 61         copy.domainLookupEnd = domainLookupEnd;
 62         copy.connectStart = connectStart;
 63         copy.secureConnectionStart = secureConnectionStart;
 64         copy.connectEnd = connectEnd;
 65         copy.requestStart = requestStart;
 66         copy.responseStart = responseStart;
 67         copy.responseEnd = responseEnd;
 68         copy.complete = complete;
 69         copy.protocol = protocol.isolatedCopy();
 70 
 71         copy.remoteAddress = remoteAddress.isolatedCopy();
 72         copy.connectionIdentifier = connectionIdentifier.isolatedCopy();
 73         copy.tlsProtocol = tlsProtocol.isolatedCopy();
 74         copy.tlsCipher = tlsCipher.isolatedCopy();
 75         copy.priority = priority;
 76         copy.requestHeaders = requestHeaders.isolatedCopy();
 77 
 78         copy.requestHeaderBytesSent = requestHeaderBytesSent;
 79         copy.requestBodyBytesSent = requestBodyBytesSent;
 80         copy.responseHeaderBytesReceived = responseHeaderBytesReceived;
 81         copy.responseBodyBytesReceived = responseBodyBytesReceived;
 82         copy.responseBodyDecodedSize = responseBodyDecodedSize;
 83 
 84         return copy;
 85     }
 86 
 87     void reset()
 88     {
 89         domainLookupStart = Seconds(-1);
 90         domainLookupEnd = Seconds(-1);
 91         connectStart = Seconds(-1);
 92         secureConnectionStart = Seconds(-1);
 93         connectEnd = Seconds(-1);
 94         requestStart = Seconds(0);
 95         responseStart = Seconds(0);
 96         responseEnd = Seconds(0);
 97         complete = false;
 98         protocol = String();
 99         clearNonTimingData();
100     }
101 
102     void clearNonTimingData()
103     {
104         remoteAddress = String();
105         connectionIdentifier = String();
106         tlsProtocol = String();
107         tlsCipher = String();
108         priority = NetworkLoadPriority::Unknown;
109         requestHeaders.clear();
110         requestHeaderBytesSent = std::numeric_limits&lt;uint32_t&gt;::max();
111         requestBodyBytesSent = std::numeric_limits&lt;uint64_t&gt;::max();
112         responseHeaderBytesReceived = std::numeric_limits&lt;uint32_t&gt;::max();
113         responseBodyBytesReceived = std::numeric_limits&lt;uint64_t&gt;::max();
114         responseBodyDecodedSize = std::numeric_limits&lt;uint64_t&gt;::max();
115     }
116 
117     bool operator==(const NetworkLoadMetrics&amp; other) const
118     {
119         return domainLookupStart == other.domainLookupStart
120             &amp;&amp; domainLookupEnd == other.domainLookupEnd
121             &amp;&amp; connectStart == other.connectStart
122             &amp;&amp; secureConnectionStart == other.secureConnectionStart
123             &amp;&amp; connectEnd == other.connectEnd
124             &amp;&amp; requestStart == other.requestStart
125             &amp;&amp; responseStart == other.responseStart
126             &amp;&amp; responseEnd == other.responseEnd
127             &amp;&amp; complete == other.complete
128             &amp;&amp; protocol == other.protocol
129             &amp;&amp; remoteAddress == other.remoteAddress
130             &amp;&amp; connectionIdentifier == other.connectionIdentifier
131             &amp;&amp; tlsProtocol == other.tlsProtocol
132             &amp;&amp; tlsCipher == other.tlsCipher
133             &amp;&amp; priority == other.priority
134             &amp;&amp; requestHeaders == other.requestHeaders
135             &amp;&amp; requestHeaderBytesSent == other.requestHeaderBytesSent
136             &amp;&amp; requestBodyBytesSent == other.requestBodyBytesSent
137             &amp;&amp; responseHeaderBytesReceived == other.responseHeaderBytesReceived
138             &amp;&amp; responseBodyBytesReceived == other.responseBodyBytesReceived
139             &amp;&amp; responseBodyDecodedSize == other.responseBodyDecodedSize;
140     }
141 
142     bool operator!=(const NetworkLoadMetrics&amp; other) const
143     {
144         return !(*this == other);
145     }
146 
147     bool isComplete() const { return complete; }
148     void markComplete() { complete = true; }
149 
150     template&lt;class Encoder&gt; void encode(Encoder&amp;) const;
151     template&lt;class Decoder&gt; static bool decode(Decoder&amp;, NetworkLoadMetrics&amp;);
152 
153     // These should be treated as deltas to LoadTiming&#39;s fetchStart.
154     // They should be in ascending order as listed here.
155     Seconds domainLookupStart;     // -1 if no DNS.
156     Seconds domainLookupEnd;       // -1 if no DNS.
157     Seconds connectStart;          // -1 if reused connection.
158     Seconds secureConnectionStart; // -1 if no secure connection.
159     Seconds connectEnd;            // -1 if reused connection.
160     Seconds requestStart;
161     Seconds responseStart;
162     Seconds responseEnd;
163 
164     // ALPN Protocol ID: https://w3c.github.io/resource-timing/#bib-RFC7301
165     String protocol;
166 
167     String remoteAddress;
168     String connectionIdentifier;
169 
170     String tlsProtocol;
171     String tlsCipher;
172 
173     // Whether or not all of the properties (0 or otherwise) have been set.
174     NetworkLoadPriority priority;
175     bool complete { false };
176 
177     HTTPHeaderMap requestHeaders;
178 
179     uint64_t requestHeaderBytesSent;
180     uint64_t responseHeaderBytesReceived;
181     uint64_t requestBodyBytesSent;
182     uint64_t responseBodyBytesReceived;
183     uint64_t responseBodyDecodedSize;
184 };
185 
186 #if PLATFORM(COCOA)
187 WEBCORE_EXPORT void copyTimingData(NSDictionary *timingData, NetworkLoadMetrics&amp;);
188 #endif
189 
190 template&lt;class Encoder&gt;
191 void NetworkLoadMetrics::encode(Encoder&amp; encoder) const
192 {
193     encoder &lt;&lt; domainLookupStart;
194     encoder &lt;&lt; domainLookupEnd;
195     encoder &lt;&lt; connectStart;
196     encoder &lt;&lt; secureConnectionStart;
197     encoder &lt;&lt; connectEnd;
198     encoder &lt;&lt; requestStart;
199     encoder &lt;&lt; responseStart;
200     encoder &lt;&lt; responseEnd;
201     encoder &lt;&lt; complete;
202     encoder &lt;&lt; protocol;
203     encoder &lt;&lt; remoteAddress;
204     encoder &lt;&lt; connectionIdentifier;
205     encoder &lt;&lt; tlsProtocol;
206     encoder &lt;&lt; tlsCipher;
207     encoder &lt;&lt; priority;
208     encoder &lt;&lt; requestHeaders;
209     encoder &lt;&lt; requestHeaderBytesSent;
210     encoder &lt;&lt; requestBodyBytesSent;
211     encoder &lt;&lt; responseHeaderBytesReceived;
212     encoder &lt;&lt; responseBodyBytesReceived;
213     encoder &lt;&lt; responseBodyDecodedSize;
214 }
215 
216 template&lt;class Decoder&gt;
217 bool NetworkLoadMetrics::decode(Decoder&amp; decoder, NetworkLoadMetrics&amp; metrics)
218 {
219     return decoder.decode(metrics.domainLookupStart)
220         &amp;&amp; decoder.decode(metrics.domainLookupEnd)
221         &amp;&amp; decoder.decode(metrics.connectStart)
222         &amp;&amp; decoder.decode(metrics.secureConnectionStart)
223         &amp;&amp; decoder.decode(metrics.connectEnd)
224         &amp;&amp; decoder.decode(metrics.requestStart)
225         &amp;&amp; decoder.decode(metrics.responseStart)
226         &amp;&amp; decoder.decode(metrics.responseEnd)
227         &amp;&amp; decoder.decode(metrics.complete)
228         &amp;&amp; decoder.decode(metrics.protocol)
229         &amp;&amp; decoder.decode(metrics.remoteAddress)
230         &amp;&amp; decoder.decode(metrics.connectionIdentifier)
231         &amp;&amp; decoder.decode(metrics.tlsProtocol)
232         &amp;&amp; decoder.decode(metrics.tlsCipher)
233         &amp;&amp; decoder.decode(metrics.priority)
234         &amp;&amp; decoder.decode(metrics.requestHeaders)
235         &amp;&amp; decoder.decode(metrics.requestHeaderBytesSent)
236         &amp;&amp; decoder.decode(metrics.requestBodyBytesSent)
237         &amp;&amp; decoder.decode(metrics.responseHeaderBytesReceived)
238         &amp;&amp; decoder.decode(metrics.responseBodyBytesReceived)
239         &amp;&amp; decoder.decode(metrics.responseBodyDecodedSize);
240 }
241 
242 } // namespace WebCore
243 
244 // NetworkLoadMetrics should not be stored by the WTF::Persistence::Decoder.
245 namespace WTF {
246 namespace Persistence {
247 
248 template&lt;&gt; struct Coder&lt;Optional&lt;WebCore::NetworkLoadPriority&gt;&gt; {
249     static NO_RETURN_DUE_TO_ASSERT void encode(Encoder&amp;, const Optional&lt;WebCore::NetworkLoadPriority&gt;&amp;)
250     {
251         ASSERT_NOT_REACHED();
252     }
253 
254     static bool decode(Decoder&amp;, Optional&lt;WebCore::NetworkLoadPriority&gt;&amp;)
255     {
256         ASSERT_NOT_REACHED();
257         return false;
258     }
259 };
260 
261 }} // namespace WTF::Persistence
    </pre>
  </body>
</html>
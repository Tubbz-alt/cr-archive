<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/VMInspector.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SigillCrashAnalyzer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VMInspector.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/tools/VMInspector.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 39 
 40 #if !OS(WINDOWS)
 41 #include &lt;unistd.h&gt;
 42 #endif
 43 
 44 namespace JSC {
 45 
 46 VMInspector&amp; VMInspector::instance()
 47 {
 48     static VMInspector* manager;
 49     static std::once_flag once;
 50     std::call_once(once, [] {
 51         manager = new VMInspector();
 52     });
 53     return *manager;
 54 }
 55 
 56 void VMInspector::add(VM* vm)
 57 {
 58     auto locker = holdLock(m_lock);
<span class="line-modified"> 59     m_list.append(vm);</span>
 60 }
 61 
 62 void VMInspector::remove(VM* vm)
 63 {
 64     auto locker = holdLock(m_lock);
<span class="line-modified"> 65     m_list.remove(vm);</span>
 66 }
 67 
 68 auto VMInspector::lock(Seconds timeout) -&gt; Expected&lt;Locker, Error&gt;
 69 {
 70     // This function may be called from a signal handler (e.g. via visit()). Hence,
 71     // it should only use APIs that are safe to call from signal handlers. This is
 72     // why we use unistd.h&#39;s sleep() instead of its alternatives.
 73 
 74     // We&#39;ll be doing sleep(1) between tries below. Hence, sleepPerRetry is 1.
 75     unsigned maxRetries = (timeout &lt; Seconds::infinity()) ? timeout.value() : UINT_MAX;
 76 
 77     Expected&lt;Locker, Error&gt; locker = Locker::tryLock(m_lock);
 78     unsigned tryCount = 0;
 79     while (!locker &amp;&amp; tryCount &lt; maxRetries) {
 80         // We want the version of sleep from unistd.h. Cast to disambiguate.
 81 #if !OS(WINDOWS)
 82         (static_cast&lt;unsigned (*)(unsigned)&gt;(sleep))(1);
 83 #endif
 84         locker = Locker::tryLock(m_lock);
 85     }
</pre>
<hr />
<pre>
 89     return locker;
 90 }
 91 
 92 #if ENABLE(JIT)
 93 static bool ensureIsSafeToLock(Lock&amp; lock)
 94 {
 95     unsigned maxRetries = 2;
 96     unsigned tryCount = 0;
 97     while (tryCount &lt;= maxRetries) {
 98         bool success = lock.tryLock();
 99         if (success) {
100             lock.unlock();
101             return true;
102         }
103         tryCount++;
104     }
105     return false;
106 };
107 #endif // ENABLE(JIT)
108 







109 auto VMInspector::isValidExecutableMemory(const VMInspector::Locker&amp;, void* machinePC) -&gt; Expected&lt;bool, Error&gt;
110 {
111 #if ENABLE(JIT)
112     bool found = false;
113     bool hasTimeout = false;
114     iterate([&amp;] (VM&amp;) -&gt; FunctorStatus {
115         auto&amp; allocator = ExecutableAllocator::singleton();
116         auto&amp; lock = allocator.getLock();
117 
118         bool isSafeToLock = ensureIsSafeToLock(lock);
119         if (!isSafeToLock) {
120             hasTimeout = true;
121             return FunctorStatus::Continue; // Skip this VM.
122         }
123 
124         LockHolder executableAllocatorLocker(lock);
125         if (allocator.isValidExecutableMemory(executableAllocatorLocker, machinePC)) {
126             found = true;
127             return FunctorStatus::Done;
128         }
</pre>
<hr />
<pre>
180 
181             if (jitCode-&gt;contains(machinePC)) {
182                 codeBlock = cb;
183                 return;
184             }
185         });
186         if (codeBlock)
187             return FunctorStatus::Done;
188         return FunctorStatus::Continue;
189     });
190 
191     if (!codeBlock &amp;&amp; hasTimeout)
192         return makeUnexpected(Error::TimedOut);
193     return codeBlock;
194 #else
195     UNUSED_PARAM(machinePC);
196     return nullptr;
197 #endif
198 }
199 
<span class="line-modified">200 bool VMInspector::currentThreadOwnsJSLock(ExecState* exec)</span>
201 {
<span class="line-modified">202     return exec-&gt;vm().currentThreadIsHoldingAPILock();</span>
203 }
204 
<span class="line-modified">205 static bool ensureCurrentThreadOwnsJSLock(ExecState* exec)</span>
206 {
<span class="line-modified">207     if (VMInspector::currentThreadOwnsJSLock(exec))</span>
208         return true;
209     dataLog(&quot;ERROR: current thread does not own the JSLock\n&quot;);
210     return false;
211 }
212 
<span class="line-modified">213 void VMInspector::gc(ExecState* exec)</span>
214 {
<span class="line-modified">215     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">216     if (!ensureCurrentThreadOwnsJSLock(exec))</span>
217         return;
218     vm.heap.collectNow(Sync, CollectionScope::Full);
219 }
220 
<span class="line-modified">221 void VMInspector::edenGC(ExecState* exec)</span>
222 {
<span class="line-modified">223     VM&amp; vm = exec-&gt;vm();</span>
<span class="line-modified">224     if (!ensureCurrentThreadOwnsJSLock(exec))</span>
225         return;
226     vm.heap.collectSync(CollectionScope::Eden);
227 }
228 
229 bool VMInspector::isInHeap(Heap* heap, void* ptr)
230 {
231     MarkedBlock* candidate = MarkedBlock::blockFor(ptr);
232     if (heap-&gt;objectSpace().blocks().set().contains(candidate))
233         return true;
<span class="line-modified">234     for (LargeAllocation* allocation : heap-&gt;objectSpace().largeAllocations()) {</span>
235         if (allocation-&gt;contains(ptr))
236             return true;
237     }
238     return false;
239 }
240 
241 struct CellAddressCheckFunctor : MarkedBlock::CountFunctor {
242     CellAddressCheckFunctor(JSCell* candidate)
243         : candidate(candidate)
244     {
245     }
246 
247     IterationStatus operator()(HeapCell* cell, HeapCell::Kind) const
248     {
249         if (cell == candidate) {
250             found = true;
251             return IterationStatus::Done;
252         }
253         return IterationStatus::Continue;
254     }
255 
256     JSCell* candidate;
257     mutable bool found { false };
258 };
259 
260 bool VMInspector::isValidCell(Heap* heap, JSCell* candidate)
261 {
262     HeapIterationScope iterationScope(*heap);
263     CellAddressCheckFunctor functor(candidate);
264     heap-&gt;objectSpace().forEachLiveCell(iterationScope, functor);
265     return functor.found;
266 }
267 
<span class="line-modified">268 bool VMInspector::isValidCodeBlock(ExecState* exec, CodeBlock* candidate)</span>
269 {
<span class="line-modified">270     if (!ensureCurrentThreadOwnsJSLock(exec))</span>
271         return false;
272 
273     struct CodeBlockValidationFunctor {
274         CodeBlockValidationFunctor(CodeBlock* candidate)
275             : candidate(candidate)
276         {
277         }
278 
279         void operator()(CodeBlock* codeBlock) const
280         {
281             if (codeBlock == candidate)
282                 found = true;
283         }
284 
285         CodeBlock* candidate;
286         mutable bool found { false };
287     };
288 
<span class="line-modified">289     VM&amp; vm = exec-&gt;vm();</span>
290     CodeBlockValidationFunctor functor(candidate);
291     vm.heap.forEachCodeBlock(functor);
292     return functor.found;
293 }
294 
<span class="line-modified">295 CodeBlock* VMInspector::codeBlockForFrame(CallFrame* topCallFrame, unsigned frameNumber)</span>
296 {
<span class="line-modified">297     if (!ensureCurrentThreadOwnsJSLock(topCallFrame))</span>

298         return nullptr;
299 
300     if (!topCallFrame)
301         return nullptr;
302 
303     struct FetchCodeBlockFunctor {
304     public:
305         FetchCodeBlockFunctor(unsigned targetFrameNumber)
306             : targetFrame(targetFrameNumber)
307         {
308         }
309 
310         StackVisitor::Status operator()(StackVisitor&amp; visitor) const
311         {
312             auto currentFrame = nextFrame++;
313             if (currentFrame == targetFrame) {
314                 codeBlock = visitor-&gt;codeBlock();
315                 return StackVisitor::Done;
316             }
317             return StackVisitor::Continue;
318         }
319 
320         unsigned targetFrame;
321         mutable unsigned nextFrame { 0 };
322         mutable CodeBlock* codeBlock { nullptr };
323     };
324 
325     FetchCodeBlockFunctor functor(frameNumber);
<span class="line-modified">326     topCallFrame-&gt;iterate(functor);</span>
327     return functor.codeBlock;
328 }
329 
330 class DumpFrameFunctor {
331 public:
332     enum Action {
333         DumpOne,
334         DumpAll
335     };
336 
337     DumpFrameFunctor(Action action, unsigned framesToSkip)
338         : m_action(action)
339         , m_framesToSkip(framesToSkip)
340     {
341     }
342 
343     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
344     {
345         m_currentFrame++;
346         if (m_currentFrame &gt; m_framesToSkip) {
347             visitor-&gt;dump(WTF::dataFile(), Indenter(2), [&amp;] (PrintStream&amp; out) {
348                 out.print(&quot;[&quot;, (m_currentFrame - m_framesToSkip - 1), &quot;] &quot;);
349             });
350         }
351         if (m_action == DumpOne &amp;&amp; m_currentFrame &gt; m_framesToSkip)
352             return StackVisitor::Done;
353         return StackVisitor::Continue;
354     }
355 
356 private:
357     Action m_action;
358     unsigned m_framesToSkip;
359     mutable unsigned m_currentFrame { 0 };
360 };
361 
<span class="line-modified">362 void VMInspector::dumpCallFrame(CallFrame* callFrame, unsigned framesToSkip)</span>
363 {
<span class="line-modified">364     if (!ensureCurrentThreadOwnsJSLock(callFrame))</span>
365         return;
366     DumpFrameFunctor functor(DumpFrameFunctor::DumpOne, framesToSkip);
<span class="line-modified">367     callFrame-&gt;iterate(functor);</span>
368 }
369 
370 void VMInspector::dumpRegisters(CallFrame* callFrame)
371 {
372     CodeBlock* codeBlock = callFrame-&gt;codeBlock();
373     if (!codeBlock) {
374         dataLog(&quot;Dumping host frame registers not supported.\n&quot;);
375         return;
376     }
377     VM&amp; vm = codeBlock-&gt;vm();
378     auto valueAsString = [&amp;] (JSValue v) -&gt; CString {
379         if (!v.isCell() || VMInspector::isValidCell(&amp;vm.heap, reinterpret_cast&lt;JSCell*&gt;(JSValue::encode(v))))
380             return toCString(v);
381         return &quot;&quot;;
382     };
383 
384     dataLogF(&quot;Register frame: \n\n&quot;);
385     dataLogF(&quot;-----------------------------------------------------------------------------\n&quot;);
386     dataLogF(&quot;            use            |   address  |                value               \n&quot;);
387     dataLogF(&quot;-----------------------------------------------------------------------------\n&quot;);
388 
389     const Register* it;
390     const Register* end;
391 
<span class="line-modified">392     it = callFrame-&gt;registers() + CallFrameSlot::thisArgument + callFrame-&gt;argumentCount();</span>
<span class="line-modified">393     end = callFrame-&gt;registers() + CallFrameSlot::thisArgument - 1;</span>
394     while (it &gt; end) {
395         JSValue v = it-&gt;jsValue();
396         int registerNumber = it - callFrame-&gt;registers();
397         String name = codeBlock-&gt;nameForRegister(VirtualRegister(registerNumber));
398         dataLogF(&quot;[r% 3d %14s]      | %10p | 0x%-16llx %s\n&quot;, registerNumber, name.ascii().data(), it, (long long)JSValue::encode(v), valueAsString(v).data());
399         --it;
400     }
401 
402     dataLogF(&quot;-----------------------------------------------------------------------------\n&quot;);
403     dataLogF(&quot;[ArgumentCount]            | %10p | %lu \n&quot;, it, (unsigned long) callFrame-&gt;argumentCount());
404 
<span class="line-modified">405     callFrame-&gt;iterate([&amp;] (StackVisitor&amp; visitor) {</span>
406         if (visitor-&gt;callFrame() == callFrame) {
407             unsigned line = 0;
408             unsigned unusedColumn = 0;
409             visitor-&gt;computeLineAndColumn(line, unusedColumn);
<span class="line-modified">410             dataLogF(&quot;[ReturnVPC]                | %10p | %d (line %d)\n&quot;, it, visitor-&gt;bytecodeOffset(), line);</span>
411             return StackVisitor::Done;
412         }
413         return StackVisitor::Continue;
414     });
415 
416     --it;
417     dataLogF(&quot;[Callee]                   | %10p | 0x%-16llx %s\n&quot;, it, (long long)callFrame-&gt;callee().rawPtr(), valueAsString(it-&gt;jsValue()).data());
418     --it;
419     dataLogF(&quot;[CodeBlock]                | %10p | 0x%-16llx &quot;, it, (long long)codeBlock);
420     dataLogLn(codeBlock);
421     --it;
422 #if ENABLE(JIT)
<span class="line-modified">423     AbstractPC pc = callFrame-&gt;abstractReturnPC(callFrame-&gt;vm());</span>
424     if (pc.hasJITReturnAddress())
425         dataLogF(&quot;[ReturnPC]                 | %10p | %p \n&quot;, it, pc.jitReturnAddress().value());
426     --it;
427 #endif
428     dataLogF(&quot;[CallerFrame]              | %10p | %p \n&quot;, it, callFrame-&gt;callerFrame());
429     --it;
430     dataLogF(&quot;-----------------------------------------------------------------------------\n&quot;);
431 
432     size_t numberOfCalleeSaveSlots = codeBlock-&gt;calleeSaveSpaceAsVirtualRegisters();
433     const Register* endOfCalleeSaves = it - numberOfCalleeSaveSlots;
434 
435     end = it - codeBlock-&gt;numVars();
436     if (it != end) {
437         do {
438             JSValue v = it-&gt;jsValue();
439             int registerNumber = it - callFrame-&gt;registers();
440             String name = (it &gt; endOfCalleeSaves)
441                 ? &quot;CalleeSaveReg&quot;
442                 : codeBlock-&gt;nameForRegister(VirtualRegister(registerNumber));
443             dataLogF(&quot;[r% 3d %14s]      | %10p | 0x%-16llx %s\n&quot;, registerNumber, name.ascii().data(), it, (long long)JSValue::encode(v), valueAsString(v).data());
444             --it;
445         } while (it != end);
446     }
447     dataLogF(&quot;-----------------------------------------------------------------------------\n&quot;);
448 
449     end = it - codeBlock-&gt;numCalleeLocals() + codeBlock-&gt;numVars();
450     if (it != end) {
451         do {
452             JSValue v = (*it).jsValue();
453             int registerNumber = it - callFrame-&gt;registers();
454             dataLogF(&quot;[r% 3d]                     | %10p | 0x%-16llx %s\n&quot;, registerNumber, it, (long long)JSValue::encode(v), valueAsString(v).data());
455             --it;
456         } while (it != end);
457     }
458     dataLogF(&quot;-----------------------------------------------------------------------------\n&quot;);
459 }
460 
<span class="line-modified">461 void VMInspector::dumpStack(CallFrame* topCallFrame, unsigned framesToSkip)</span>
462 {
<span class="line-modified">463     if (!ensureCurrentThreadOwnsJSLock(topCallFrame))</span>
464         return;
465     if (!topCallFrame)
466         return;
467     DumpFrameFunctor functor(DumpFrameFunctor::DumpAll, framesToSkip);
<span class="line-modified">468     topCallFrame-&gt;iterate(functor);</span>
469 }
470 
471 void VMInspector::dumpValue(JSValue value)
472 {
<span class="line-modified">473     dataLog(value);</span>
474 }
475 
476 void VMInspector::dumpCellMemory(JSCell* cell)
477 {
478     dumpCellMemoryToStream(cell, WTF::dataFile());
479 }
480 
481 class IndentationScope {
482 public:
483     IndentationScope(unsigned&amp; indentation)
484         : m_indentation(indentation)
485     {
486         ++m_indentation;
487     }
488 
489     ~IndentationScope()
490     {
491         --m_indentation;
492     }
493 
</pre>
</td>
<td>
<hr />
<pre>
 39 
 40 #if !OS(WINDOWS)
 41 #include &lt;unistd.h&gt;
 42 #endif
 43 
 44 namespace JSC {
 45 
 46 VMInspector&amp; VMInspector::instance()
 47 {
 48     static VMInspector* manager;
 49     static std::once_flag once;
 50     std::call_once(once, [] {
 51         manager = new VMInspector();
 52     });
 53     return *manager;
 54 }
 55 
 56 void VMInspector::add(VM* vm)
 57 {
 58     auto locker = holdLock(m_lock);
<span class="line-modified"> 59     m_vmList.append(vm);</span>
 60 }
 61 
 62 void VMInspector::remove(VM* vm)
 63 {
 64     auto locker = holdLock(m_lock);
<span class="line-modified"> 65     m_vmList.remove(vm);</span>
 66 }
 67 
 68 auto VMInspector::lock(Seconds timeout) -&gt; Expected&lt;Locker, Error&gt;
 69 {
 70     // This function may be called from a signal handler (e.g. via visit()). Hence,
 71     // it should only use APIs that are safe to call from signal handlers. This is
 72     // why we use unistd.h&#39;s sleep() instead of its alternatives.
 73 
 74     // We&#39;ll be doing sleep(1) between tries below. Hence, sleepPerRetry is 1.
 75     unsigned maxRetries = (timeout &lt; Seconds::infinity()) ? timeout.value() : UINT_MAX;
 76 
 77     Expected&lt;Locker, Error&gt; locker = Locker::tryLock(m_lock);
 78     unsigned tryCount = 0;
 79     while (!locker &amp;&amp; tryCount &lt; maxRetries) {
 80         // We want the version of sleep from unistd.h. Cast to disambiguate.
 81 #if !OS(WINDOWS)
 82         (static_cast&lt;unsigned (*)(unsigned)&gt;(sleep))(1);
 83 #endif
 84         locker = Locker::tryLock(m_lock);
 85     }
</pre>
<hr />
<pre>
 89     return locker;
 90 }
 91 
 92 #if ENABLE(JIT)
 93 static bool ensureIsSafeToLock(Lock&amp; lock)
 94 {
 95     unsigned maxRetries = 2;
 96     unsigned tryCount = 0;
 97     while (tryCount &lt;= maxRetries) {
 98         bool success = lock.tryLock();
 99         if (success) {
100             lock.unlock();
101             return true;
102         }
103         tryCount++;
104     }
105     return false;
106 };
107 #endif // ENABLE(JIT)
108 
<span class="line-added">109 void VMInspector::forEachVM(Function&lt;FunctorStatus(VM&amp;)&gt;&amp;&amp; func)</span>
<span class="line-added">110 {</span>
<span class="line-added">111     VMInspector&amp; inspector = instance();</span>
<span class="line-added">112     Locker lock(inspector.getLock());</span>
<span class="line-added">113     inspector.iterate(func);</span>
<span class="line-added">114 }</span>
<span class="line-added">115 </span>
116 auto VMInspector::isValidExecutableMemory(const VMInspector::Locker&amp;, void* machinePC) -&gt; Expected&lt;bool, Error&gt;
117 {
118 #if ENABLE(JIT)
119     bool found = false;
120     bool hasTimeout = false;
121     iterate([&amp;] (VM&amp;) -&gt; FunctorStatus {
122         auto&amp; allocator = ExecutableAllocator::singleton();
123         auto&amp; lock = allocator.getLock();
124 
125         bool isSafeToLock = ensureIsSafeToLock(lock);
126         if (!isSafeToLock) {
127             hasTimeout = true;
128             return FunctorStatus::Continue; // Skip this VM.
129         }
130 
131         LockHolder executableAllocatorLocker(lock);
132         if (allocator.isValidExecutableMemory(executableAllocatorLocker, machinePC)) {
133             found = true;
134             return FunctorStatus::Done;
135         }
</pre>
<hr />
<pre>
187 
188             if (jitCode-&gt;contains(machinePC)) {
189                 codeBlock = cb;
190                 return;
191             }
192         });
193         if (codeBlock)
194             return FunctorStatus::Done;
195         return FunctorStatus::Continue;
196     });
197 
198     if (!codeBlock &amp;&amp; hasTimeout)
199         return makeUnexpected(Error::TimedOut);
200     return codeBlock;
201 #else
202     UNUSED_PARAM(machinePC);
203     return nullptr;
204 #endif
205 }
206 
<span class="line-modified">207 bool VMInspector::currentThreadOwnsJSLock(JSGlobalObject* globalObject)</span>
208 {
<span class="line-modified">209     return globalObject-&gt;vm().currentThreadIsHoldingAPILock();</span>
210 }
211 
<span class="line-modified">212 static bool ensureCurrentThreadOwnsJSLock(JSGlobalObject* globalObject)</span>
213 {
<span class="line-modified">214     if (VMInspector::currentThreadOwnsJSLock(globalObject))</span>
215         return true;
216     dataLog(&quot;ERROR: current thread does not own the JSLock\n&quot;);
217     return false;
218 }
219 
<span class="line-modified">220 void VMInspector::gc(JSGlobalObject* globalObject)</span>
221 {
<span class="line-modified">222     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">223     if (!ensureCurrentThreadOwnsJSLock(globalObject))</span>
224         return;
225     vm.heap.collectNow(Sync, CollectionScope::Full);
226 }
227 
<span class="line-modified">228 void VMInspector::edenGC(JSGlobalObject* globalObject)</span>
229 {
<span class="line-modified">230     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-modified">231     if (!ensureCurrentThreadOwnsJSLock(globalObject))</span>
232         return;
233     vm.heap.collectSync(CollectionScope::Eden);
234 }
235 
236 bool VMInspector::isInHeap(Heap* heap, void* ptr)
237 {
238     MarkedBlock* candidate = MarkedBlock::blockFor(ptr);
239     if (heap-&gt;objectSpace().blocks().set().contains(candidate))
240         return true;
<span class="line-modified">241     for (PreciseAllocation* allocation : heap-&gt;objectSpace().preciseAllocations()) {</span>
242         if (allocation-&gt;contains(ptr))
243             return true;
244     }
245     return false;
246 }
247 
248 struct CellAddressCheckFunctor : MarkedBlock::CountFunctor {
249     CellAddressCheckFunctor(JSCell* candidate)
250         : candidate(candidate)
251     {
252     }
253 
254     IterationStatus operator()(HeapCell* cell, HeapCell::Kind) const
255     {
256         if (cell == candidate) {
257             found = true;
258             return IterationStatus::Done;
259         }
260         return IterationStatus::Continue;
261     }
262 
263     JSCell* candidate;
264     mutable bool found { false };
265 };
266 
267 bool VMInspector::isValidCell(Heap* heap, JSCell* candidate)
268 {
269     HeapIterationScope iterationScope(*heap);
270     CellAddressCheckFunctor functor(candidate);
271     heap-&gt;objectSpace().forEachLiveCell(iterationScope, functor);
272     return functor.found;
273 }
274 
<span class="line-modified">275 bool VMInspector::isValidCodeBlock(JSGlobalObject* globalObject, CodeBlock* candidate)</span>
276 {
<span class="line-modified">277     if (!ensureCurrentThreadOwnsJSLock(globalObject))</span>
278         return false;
279 
280     struct CodeBlockValidationFunctor {
281         CodeBlockValidationFunctor(CodeBlock* candidate)
282             : candidate(candidate)
283         {
284         }
285 
286         void operator()(CodeBlock* codeBlock) const
287         {
288             if (codeBlock == candidate)
289                 found = true;
290         }
291 
292         CodeBlock* candidate;
293         mutable bool found { false };
294     };
295 
<span class="line-modified">296     VM&amp; vm = globalObject-&gt;vm();</span>
297     CodeBlockValidationFunctor functor(candidate);
298     vm.heap.forEachCodeBlock(functor);
299     return functor.found;
300 }
301 
<span class="line-modified">302 CodeBlock* VMInspector::codeBlockForFrame(JSGlobalObject* globalObject, CallFrame* topCallFrame, unsigned frameNumber)</span>
303 {
<span class="line-modified">304     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="line-added">305     if (!ensureCurrentThreadOwnsJSLock(globalObject))</span>
306         return nullptr;
307 
308     if (!topCallFrame)
309         return nullptr;
310 
311     struct FetchCodeBlockFunctor {
312     public:
313         FetchCodeBlockFunctor(unsigned targetFrameNumber)
314             : targetFrame(targetFrameNumber)
315         {
316         }
317 
318         StackVisitor::Status operator()(StackVisitor&amp; visitor) const
319         {
320             auto currentFrame = nextFrame++;
321             if (currentFrame == targetFrame) {
322                 codeBlock = visitor-&gt;codeBlock();
323                 return StackVisitor::Done;
324             }
325             return StackVisitor::Continue;
326         }
327 
328         unsigned targetFrame;
329         mutable unsigned nextFrame { 0 };
330         mutable CodeBlock* codeBlock { nullptr };
331     };
332 
333     FetchCodeBlockFunctor functor(frameNumber);
<span class="line-modified">334     topCallFrame-&gt;iterate(vm, functor);</span>
335     return functor.codeBlock;
336 }
337 
338 class DumpFrameFunctor {
339 public:
340     enum Action {
341         DumpOne,
342         DumpAll
343     };
344 
345     DumpFrameFunctor(Action action, unsigned framesToSkip)
346         : m_action(action)
347         , m_framesToSkip(framesToSkip)
348     {
349     }
350 
351     StackVisitor::Status operator()(StackVisitor&amp; visitor) const
352     {
353         m_currentFrame++;
354         if (m_currentFrame &gt; m_framesToSkip) {
355             visitor-&gt;dump(WTF::dataFile(), Indenter(2), [&amp;] (PrintStream&amp; out) {
356                 out.print(&quot;[&quot;, (m_currentFrame - m_framesToSkip - 1), &quot;] &quot;);
357             });
358         }
359         if (m_action == DumpOne &amp;&amp; m_currentFrame &gt; m_framesToSkip)
360             return StackVisitor::Done;
361         return StackVisitor::Continue;
362     }
363 
364 private:
365     Action m_action;
366     unsigned m_framesToSkip;
367     mutable unsigned m_currentFrame { 0 };
368 };
369 
<span class="line-modified">370 void VMInspector::dumpCallFrame(JSGlobalObject* globalObject, CallFrame* callFrame, unsigned framesToSkip)</span>
371 {
<span class="line-modified">372     if (!ensureCurrentThreadOwnsJSLock(globalObject))</span>
373         return;
374     DumpFrameFunctor functor(DumpFrameFunctor::DumpOne, framesToSkip);
<span class="line-modified">375     callFrame-&gt;iterate(globalObject-&gt;vm(), functor);</span>
376 }
377 
378 void VMInspector::dumpRegisters(CallFrame* callFrame)
379 {
380     CodeBlock* codeBlock = callFrame-&gt;codeBlock();
381     if (!codeBlock) {
382         dataLog(&quot;Dumping host frame registers not supported.\n&quot;);
383         return;
384     }
385     VM&amp; vm = codeBlock-&gt;vm();
386     auto valueAsString = [&amp;] (JSValue v) -&gt; CString {
387         if (!v.isCell() || VMInspector::isValidCell(&amp;vm.heap, reinterpret_cast&lt;JSCell*&gt;(JSValue::encode(v))))
388             return toCString(v);
389         return &quot;&quot;;
390     };
391 
392     dataLogF(&quot;Register frame: \n\n&quot;);
393     dataLogF(&quot;-----------------------------------------------------------------------------\n&quot;);
394     dataLogF(&quot;            use            |   address  |                value               \n&quot;);
395     dataLogF(&quot;-----------------------------------------------------------------------------\n&quot;);
396 
397     const Register* it;
398     const Register* end;
399 
<span class="line-modified">400     it = callFrame-&gt;registers() + (CallFrameSlot::thisArgument + callFrame-&gt;argumentCount());</span>
<span class="line-modified">401     end = callFrame-&gt;registers() + (CallFrameSlot::thisArgument - 1);</span>
402     while (it &gt; end) {
403         JSValue v = it-&gt;jsValue();
404         int registerNumber = it - callFrame-&gt;registers();
405         String name = codeBlock-&gt;nameForRegister(VirtualRegister(registerNumber));
406         dataLogF(&quot;[r% 3d %14s]      | %10p | 0x%-16llx %s\n&quot;, registerNumber, name.ascii().data(), it, (long long)JSValue::encode(v), valueAsString(v).data());
407         --it;
408     }
409 
410     dataLogF(&quot;-----------------------------------------------------------------------------\n&quot;);
411     dataLogF(&quot;[ArgumentCount]            | %10p | %lu \n&quot;, it, (unsigned long) callFrame-&gt;argumentCount());
412 
<span class="line-modified">413     callFrame-&gt;iterate(vm, [&amp;] (StackVisitor&amp; visitor) {</span>
414         if (visitor-&gt;callFrame() == callFrame) {
415             unsigned line = 0;
416             unsigned unusedColumn = 0;
417             visitor-&gt;computeLineAndColumn(line, unusedColumn);
<span class="line-modified">418             dataLogF(&quot;[ReturnVPC]                | %10p | %d (line %d)\n&quot;, it, visitor-&gt;bytecodeIndex().offset(), line);</span>
419             return StackVisitor::Done;
420         }
421         return StackVisitor::Continue;
422     });
423 
424     --it;
425     dataLogF(&quot;[Callee]                   | %10p | 0x%-16llx %s\n&quot;, it, (long long)callFrame-&gt;callee().rawPtr(), valueAsString(it-&gt;jsValue()).data());
426     --it;
427     dataLogF(&quot;[CodeBlock]                | %10p | 0x%-16llx &quot;, it, (long long)codeBlock);
428     dataLogLn(codeBlock);
429     --it;
430 #if ENABLE(JIT)
<span class="line-modified">431     AbstractPC pc = callFrame-&gt;abstractReturnPC(vm);</span>
432     if (pc.hasJITReturnAddress())
433         dataLogF(&quot;[ReturnPC]                 | %10p | %p \n&quot;, it, pc.jitReturnAddress().value());
434     --it;
435 #endif
436     dataLogF(&quot;[CallerFrame]              | %10p | %p \n&quot;, it, callFrame-&gt;callerFrame());
437     --it;
438     dataLogF(&quot;-----------------------------------------------------------------------------\n&quot;);
439 
440     size_t numberOfCalleeSaveSlots = codeBlock-&gt;calleeSaveSpaceAsVirtualRegisters();
441     const Register* endOfCalleeSaves = it - numberOfCalleeSaveSlots;
442 
443     end = it - codeBlock-&gt;numVars();
444     if (it != end) {
445         do {
446             JSValue v = it-&gt;jsValue();
447             int registerNumber = it - callFrame-&gt;registers();
448             String name = (it &gt; endOfCalleeSaves)
449                 ? &quot;CalleeSaveReg&quot;
450                 : codeBlock-&gt;nameForRegister(VirtualRegister(registerNumber));
451             dataLogF(&quot;[r% 3d %14s]      | %10p | 0x%-16llx %s\n&quot;, registerNumber, name.ascii().data(), it, (long long)JSValue::encode(v), valueAsString(v).data());
452             --it;
453         } while (it != end);
454     }
455     dataLogF(&quot;-----------------------------------------------------------------------------\n&quot;);
456 
457     end = it - codeBlock-&gt;numCalleeLocals() + codeBlock-&gt;numVars();
458     if (it != end) {
459         do {
460             JSValue v = (*it).jsValue();
461             int registerNumber = it - callFrame-&gt;registers();
462             dataLogF(&quot;[r% 3d]                     | %10p | 0x%-16llx %s\n&quot;, registerNumber, it, (long long)JSValue::encode(v), valueAsString(v).data());
463             --it;
464         } while (it != end);
465     }
466     dataLogF(&quot;-----------------------------------------------------------------------------\n&quot;);
467 }
468 
<span class="line-modified">469 void VMInspector::dumpStack(JSGlobalObject* globalObject, CallFrame* topCallFrame, unsigned framesToSkip)</span>
470 {
<span class="line-modified">471     if (!ensureCurrentThreadOwnsJSLock(globalObject))</span>
472         return;
473     if (!topCallFrame)
474         return;
475     DumpFrameFunctor functor(DumpFrameFunctor::DumpAll, framesToSkip);
<span class="line-modified">476     topCallFrame-&gt;iterate(globalObject-&gt;vm(), functor);</span>
477 }
478 
479 void VMInspector::dumpValue(JSValue value)
480 {
<span class="line-modified">481     dataLogLn(value);</span>
482 }
483 
484 void VMInspector::dumpCellMemory(JSCell* cell)
485 {
486     dumpCellMemoryToStream(cell, WTF::dataFile());
487 }
488 
489 class IndentationScope {
490 public:
491     IndentationScope(unsigned&amp; indentation)
492         : m_indentation(indentation)
493     {
494         ++m_indentation;
495     }
496 
497     ~IndentationScope()
498     {
499         --m_indentation;
500     }
501 
</pre>
</td>
</tr>
</table>
<center><a href="SigillCrashAnalyzer.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="VMInspector.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
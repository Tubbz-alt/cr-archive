diff a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WebCoreJSClientData.cpp b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WebCoreJSClientData.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WebCoreJSClientData.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/bindings/js/WebCoreJSClientData.cpp
@@ -26,28 +26,71 @@
 #include "config.h"
 #include "WebCoreJSClientData.h"
 
 #include "DOMGCOutputConstraint.h"
 #include "JSDOMBinding.h"
+#include "JSDOMBuiltinConstructorBase.h"
+#include "JSDOMWindow.h"
+#include "JSDOMWindowProperties.h"
+#include "JSDedicatedWorkerGlobalScope.h"
+#include "JSPaintWorkletGlobalScope.h"
+#include "JSRemoteDOMWindow.h"
+#include "JSServiceWorkerGlobalScope.h"
+#include "JSWindowProxy.h"
+#include "JSWorkerGlobalScope.h"
+#include "JSWorkletGlobalScope.h"
 #include <JavaScriptCore/FastMallocAlignedMemoryAllocator.h>
 #include <JavaScriptCore/HeapInlines.h>
+#include <JavaScriptCore/IsoHeapCellType.h>
 #include <JavaScriptCore/JSDestructibleObjectHeapCellType.h>
 #include <JavaScriptCore/MarkingConstraint.h>
 #include <JavaScriptCore/SubspaceInlines.h>
 #include <JavaScriptCore/VM.h>
+#include "runtime_array.h"
 #include "runtime_method.h"
+#include "runtime_object.h"
 #include <wtf/MainThread.h>
 
 namespace WebCore {
 using namespace JSC;
 
 JSVMClientData::JSVMClientData(VM& vm)
     : m_builtinFunctions(vm)
     , m_builtinNames(vm)
-    , m_runtimeMethodSpace ISO_SUBSPACE_INIT(vm.heap, vm.destructibleObjectHeapCellType.get(), RuntimeMethod) // Hash:0xf70c4a85
+    , m_runtimeArrayHeapCellType(JSC::IsoHeapCellType::create<RuntimeArray>())
+    , m_runtimeObjectHeapCellType(JSC::IsoHeapCellType::create<JSC::Bindings::RuntimeObject>())
+    , m_windowProxyHeapCellType(JSC::IsoHeapCellType::create<JSWindowProxy>())
+    , m_heapCellTypeForJSDOMWindow(JSC::IsoHeapCellType::create<JSDOMWindow>())
+    , m_heapCellTypeForJSDedicatedWorkerGlobalScope(JSC::IsoHeapCellType::create<JSDedicatedWorkerGlobalScope>())
+    , m_heapCellTypeForJSRemoteDOMWindow(JSC::IsoHeapCellType::create<JSRemoteDOMWindow>())
+    , m_heapCellTypeForJSWorkerGlobalScope(JSC::IsoHeapCellType::create<JSWorkerGlobalScope>())
+#if ENABLE(SERVICE_WORKER)
+    , m_heapCellTypeForJSServiceWorkerGlobalScope(JSC::IsoHeapCellType::create<JSServiceWorkerGlobalScope>())
+#endif
+#if ENABLE(CSS_PAINTING_API)
+    , m_heapCellTypeForJSPaintWorkletGlobalScope(JSC::IsoHeapCellType::create<JSPaintWorkletGlobalScope>())
+    , m_heapCellTypeForJSWorkletGlobalScope(JSC::IsoHeapCellType::create<JSWorkletGlobalScope>())
+#endif
+    , m_domBuiltinConstructorSpace ISO_SUBSPACE_INIT(vm.heap, vm.cellHeapCellType.get(), JSDOMBuiltinConstructorBase)
+    , m_domConstructorSpace ISO_SUBSPACE_INIT(vm.heap, vm.cellHeapCellType.get(), JSDOMConstructorBase)
+    , m_domWindowPropertiesSpace ISO_SUBSPACE_INIT(vm.heap, vm.cellHeapCellType.get(), JSDOMWindowProperties)
+    , m_runtimeArraySpace ISO_SUBSPACE_INIT(vm.heap, m_runtimeArrayHeapCellType.get(), RuntimeArray)
+    , m_runtimeMethodSpace ISO_SUBSPACE_INIT(vm.heap, vm.cellHeapCellType.get(), RuntimeMethod) // Hash:0xf70c4a85
+    , m_runtimeObjectSpace ISO_SUBSPACE_INIT(vm.heap, m_runtimeObjectHeapCellType.get(), JSC::Bindings::RuntimeObject)
+    , m_windowProxySpace ISO_SUBSPACE_INIT(vm.heap, m_windowProxyHeapCellType.get(), JSWindowProxy)
+    , m_subspaceForJSDOMWindow ISO_SUBSPACE_INIT(vm.heap, m_heapCellTypeForJSDOMWindow.get(), JSDOMWindow)
+    , m_subspaceForJSDedicatedWorkerGlobalScope ISO_SUBSPACE_INIT(vm.heap, m_heapCellTypeForJSDedicatedWorkerGlobalScope.get(), JSDedicatedWorkerGlobalScope)
+    , m_subspaceForJSRemoteDOMWindow ISO_SUBSPACE_INIT(vm.heap, m_heapCellTypeForJSRemoteDOMWindow.get(), JSRemoteDOMWindow)
+    , m_subspaceForJSWorkerGlobalScope ISO_SUBSPACE_INIT(vm.heap, m_heapCellTypeForJSWorkerGlobalScope.get(), JSWorkerGlobalScope)
+#if ENABLE(SERVICE_WORKER)
+    , m_subspaceForJSServiceWorkerGlobalScope ISO_SUBSPACE_INIT(vm.heap, m_heapCellTypeForJSServiceWorkerGlobalScope.get(), JSServiceWorkerGlobalScope)
+#endif
+#if ENABLE(CSS_PAINTING_API)
+    , m_subspaceForJSPaintWorkletGlobalScope ISO_SUBSPACE_INIT(vm.heap, m_heapCellTypeForJSPaintWorkletGlobalScope.get(), JSPaintWorkletGlobalScope)
+    , m_subspaceForJSWorkletGlobalScope ISO_SUBSPACE_INIT(vm.heap, m_heapCellTypeForJSWorkletGlobalScope.get(), JSWorkletGlobalScope)
+#endif
     , m_outputConstraintSpace("WebCore Wrapper w/ Output Constraint", vm.heap, vm.destructibleObjectHeapCellType.get(), vm.fastMallocAllocator.get()) // Hash:0x7724c2e4
-    , m_globalObjectOutputConstraintSpace("WebCore Global Object w/ Output Constraint", vm.heap, vm.cellHeapCellType.get(), vm.fastMallocAllocator.get()) // Hash:0x522d6ec9
 {
 }
 
 JSVMClientData::~JSVMClientData()
 {
@@ -61,22 +104,47 @@
 void JSVMClientData::getAllWorlds(Vector<Ref<DOMWrapperWorld>>& worlds)
 {
     ASSERT(worlds.isEmpty());
 
     worlds.reserveInitialCapacity(m_worldSet.size());
-    for (auto it = m_worldSet.begin(), end = m_worldSet.end(); it != end; ++it)
-        worlds.uncheckedAppend(*(*it));
+
+    // It is necessary to order the `DOMWrapperWorld`s because certain callers expect the main world
+    // to be the first item in the list, as they use the main world as an indicator of when the page
+    // is ready to start evaluating JavaScript. For example, Web Inspector waits for the main world
+    // change to clear any injected scripts and debugger/breakpoint state.
+
+    auto& mainNormalWorld = mainThreadNormalWorld();
+
+    // Add main normal world.
+    if (m_worldSet.contains(&mainNormalWorld))
+        worlds.uncheckedAppend(mainNormalWorld);
+
+    // Add other normal worlds.
+    for (auto* world : m_worldSet) {
+        if (world->type() != DOMWrapperWorld::Type::Normal)
+            continue;
+        if (world == &mainNormalWorld)
+            continue;
+        worlds.uncheckedAppend(*world);
+    }
+
+    // Add non-normal worlds.
+    for (auto* world : m_worldSet) {
+        if (world->type() == DOMWrapperWorld::Type::Normal)
+            continue;
+        worlds.uncheckedAppend(*world);
+    }
 }
 
 void JSVMClientData::initNormalWorld(VM* vm)
 {
     JSVMClientData* clientData = new JSVMClientData(*vm);
     vm->clientData = clientData; // ~VM deletes this pointer.
 
     vm->heap.addMarkingConstraint(makeUnique<DOMGCOutputConstraint>(*vm, *clientData));
 
-    clientData->m_normalWorld = DOMWrapperWorld::create(*vm, true);
+    clientData->m_normalWorld = DOMWrapperWorld::create(*vm, DOMWrapperWorld::Type::Normal);
     vm->m_typedArrayController = adoptRef(new WebCoreTypedArrayController());
 }
 
 } // namespace WebCore
 

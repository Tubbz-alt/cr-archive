<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/cssjit/FunctionCall.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="CompiledSelector.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorCompiler.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/cssjit/FunctionCall.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 57     {
 58         m_argumentCount = 1;
 59         m_firstArgument = registerID;
 60     }
 61 
 62     void setTwoArguments(const JSC::MacroAssembler::RegisterID&amp; firstRegisterID, const JSC::MacroAssembler::RegisterID&amp; secondRegisterID)
 63     {
 64         m_argumentCount = 2;
 65         m_firstArgument = firstRegisterID;
 66         m_secondArgument = secondRegisterID;
 67     }
 68 
 69     void call()
 70     {
 71         prepareAndCall();
 72         cleanupPostCall();
 73     }
 74 
 75     JSC::MacroAssembler::Jump callAndBranchOnBooleanReturnValue(JSC::MacroAssembler::ResultCondition condition)
 76     {
<span class="line-modified"> 77 #if CPU(X86) || CPU(X86_64)</span>
 78         return callAndBranchOnCondition(condition, JSC::MacroAssembler::TrustedImm32(0xff));
 79 #elif CPU(ARM64) || CPU(ARM)
 80         return callAndBranchOnCondition(condition, JSC::MacroAssembler::TrustedImm32(-1));
 81 #else
 82 #error Missing implementationg for matching boolean return values.
 83 #endif
 84     }
 85 
 86 private:
 87     JSC::MacroAssembler::Jump callAndBranchOnCondition(JSC::MacroAssembler::ResultCondition condition, JSC::MacroAssembler::TrustedImm32 mask)
 88     {
 89         prepareAndCall();
 90         m_assembler.test32(JSC::GPRInfo::returnValueGPR, mask);
 91         cleanupPostCall();
 92         return m_assembler.branch(condition);
 93     }
 94 
 95     void swapArguments()
 96     {
 97         JSC::MacroAssembler::RegisterID a = m_firstArgument;
 98         JSC::MacroAssembler::RegisterID b = m_secondArgument;
 99         // x86 can swap without a temporary register. On other architectures, we need allocate a temporary register to switch the values.
<span class="line-modified">100 #if CPU(X86) || CPU(X86_64)</span>
101         m_assembler.swap(a, b);
102 #elif CPU(ARM64) || CPU(ARM_THUMB2)
103         m_assembler.move(a, tempRegister);
104         m_assembler.move(b, a);
105         m_assembler.move(tempRegister, b);
106 #else
107 #error Missing implementationg for matching swapping argument registers.
108 #endif
109     }
110 
111     void prepareAndCall()
112     {
113         ASSERT(m_functionAddress.executableAddress());
114         ASSERT(!m_firstArgument || (m_firstArgument &amp;&amp; !m_secondArgument) || (m_firstArgument &amp;&amp; m_secondArgument));
115 
116         saveAllocatedCallerSavedRegisters();
117         m_stackAllocator.alignStackPreFunctionCall();
118 
119         if (m_argumentCount == 2) {
120             RELEASE_ASSERT(RegisterAllocator::isValidRegister(m_firstArgument));
</pre>
</td>
<td>
<hr />
<pre>
 57     {
 58         m_argumentCount = 1;
 59         m_firstArgument = registerID;
 60     }
 61 
 62     void setTwoArguments(const JSC::MacroAssembler::RegisterID&amp; firstRegisterID, const JSC::MacroAssembler::RegisterID&amp; secondRegisterID)
 63     {
 64         m_argumentCount = 2;
 65         m_firstArgument = firstRegisterID;
 66         m_secondArgument = secondRegisterID;
 67     }
 68 
 69     void call()
 70     {
 71         prepareAndCall();
 72         cleanupPostCall();
 73     }
 74 
 75     JSC::MacroAssembler::Jump callAndBranchOnBooleanReturnValue(JSC::MacroAssembler::ResultCondition condition)
 76     {
<span class="line-modified"> 77 #if CPU(X86_64)</span>
 78         return callAndBranchOnCondition(condition, JSC::MacroAssembler::TrustedImm32(0xff));
 79 #elif CPU(ARM64) || CPU(ARM)
 80         return callAndBranchOnCondition(condition, JSC::MacroAssembler::TrustedImm32(-1));
 81 #else
 82 #error Missing implementationg for matching boolean return values.
 83 #endif
 84     }
 85 
 86 private:
 87     JSC::MacroAssembler::Jump callAndBranchOnCondition(JSC::MacroAssembler::ResultCondition condition, JSC::MacroAssembler::TrustedImm32 mask)
 88     {
 89         prepareAndCall();
 90         m_assembler.test32(JSC::GPRInfo::returnValueGPR, mask);
 91         cleanupPostCall();
 92         return m_assembler.branch(condition);
 93     }
 94 
 95     void swapArguments()
 96     {
 97         JSC::MacroAssembler::RegisterID a = m_firstArgument;
 98         JSC::MacroAssembler::RegisterID b = m_secondArgument;
 99         // x86 can swap without a temporary register. On other architectures, we need allocate a temporary register to switch the values.
<span class="line-modified">100 #if CPU(X86_64)</span>
101         m_assembler.swap(a, b);
102 #elif CPU(ARM64) || CPU(ARM_THUMB2)
103         m_assembler.move(a, tempRegister);
104         m_assembler.move(b, a);
105         m_assembler.move(tempRegister, b);
106 #else
107 #error Missing implementationg for matching swapping argument registers.
108 #endif
109     }
110 
111     void prepareAndCall()
112     {
113         ASSERT(m_functionAddress.executableAddress());
114         ASSERT(!m_firstArgument || (m_firstArgument &amp;&amp; !m_secondArgument) || (m_firstArgument &amp;&amp; m_secondArgument));
115 
116         saveAllocatedCallerSavedRegisters();
117         m_stackAllocator.alignStackPreFunctionCall();
118 
119         if (m_argumentCount == 2) {
120             RELEASE_ASSERT(RegisterAllocator::isValidRegister(m_firstArgument));
</pre>
</td>
</tr>
</table>
<center><a href="CompiledSelector.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SelectorCompiler.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
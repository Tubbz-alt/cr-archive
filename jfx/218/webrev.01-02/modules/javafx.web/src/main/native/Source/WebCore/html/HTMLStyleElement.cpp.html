<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/html/HTMLStyleElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 1999 Lars Knoll (knoll@kde.org)
  3  *           (C) 1999 Antti Koivisto (koivisto@kde.org)
  4  *           (C) 2001 Dirk Mueller (mueller@kde.org)
  5  * Copyright (C) 2003, 2010, 2013 Apple Inc. All rights reserved.
  6  *           (C) 2007 Rob Buis (buis@kde.org)
  7  *
  8  * This library is free software; you can redistribute it and/or
  9  * modify it under the terms of the GNU Library General Public
 10  * License as published by the Free Software Foundation; either
 11  * version 2 of the License, or (at your option) any later version.
 12  *
 13  * This library is distributed in the hope that it will be useful,
 14  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 15  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 16  * Library General Public License for more details.
 17  *
 18  * You should have received a copy of the GNU Library General Public License
 19  * along with this library; see the file COPYING.LIB.  If not, write to
 20  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 21  * Boston, MA 02110-1301, USA.
 22  */
 23 
 24 #include &quot;config.h&quot;
 25 #include &quot;HTMLStyleElement.h&quot;
 26 
 27 #include &quot;CachedResource.h&quot;
 28 #include &quot;Document.h&quot;
 29 #include &quot;Event.h&quot;
 30 #include &quot;EventNames.h&quot;
 31 #include &quot;EventSender.h&quot;
 32 #include &quot;HTMLNames.h&quot;
 33 #include &quot;MediaList.h&quot;
 34 #include &quot;MediaQueryParser.h&quot;
 35 #include &quot;ScriptableDocumentParser.h&quot;
 36 #include &quot;ShadowRoot.h&quot;
 37 #include &quot;StyleScope.h&quot;
 38 #include &quot;StyleSheetContents.h&quot;
 39 #include &lt;wtf/IsoMallocInlines.h&gt;
 40 #include &lt;wtf/NeverDestroyed.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLStyleElement);
 45 
 46 using namespace HTMLNames;
 47 
 48 static StyleEventSender&amp; styleLoadEventSender()
 49 {
 50     static NeverDestroyed&lt;StyleEventSender&gt; sharedLoadEventSender(eventNames().loadEvent);
 51     return sharedLoadEventSender;
 52 }
 53 
 54 inline HTMLStyleElement::HTMLStyleElement(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 55     : HTMLElement(tagName, document)
 56     , m_styleSheetOwner(document, createdByParser)
 57 {
 58     ASSERT(hasTagName(styleTag));
 59 }
 60 
 61 HTMLStyleElement::~HTMLStyleElement()
 62 {
 63     m_styleSheetOwner.clearDocumentData(*this);
 64 
 65     styleLoadEventSender().cancelEvent(*this);
 66 }
 67 
 68 Ref&lt;HTMLStyleElement&gt; HTMLStyleElement::create(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 69 {
 70     return adoptRef(*new HTMLStyleElement(tagName, document, createdByParser));
 71 }
 72 
 73 Ref&lt;HTMLStyleElement&gt; HTMLStyleElement::create(Document&amp; document)
 74 {
 75     return adoptRef(*new HTMLStyleElement(styleTag, document, false));
 76 }
 77 
 78 void HTMLStyleElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 79 {
 80     if (name == titleAttr &amp;&amp; sheet() &amp;&amp; !isInShadowTree())
 81         sheet()-&gt;setTitle(value);
 82     else if (name == mediaAttr) {
 83         m_styleSheetOwner.setMedia(value);
 84         if (sheet()) {
 85             sheet()-&gt;setMediaQueries(MediaQuerySet::create(value, MediaQueryParserContext(document())));
 86             if (auto* scope = m_styleSheetOwner.styleScope())
 87                 scope-&gt;didChangeStyleSheetContents();
 88         } else
 89             m_styleSheetOwner.childrenChanged(*this);
 90     } else if (name == typeAttr)
 91         m_styleSheetOwner.setContentType(value);
 92     else
 93         HTMLElement::parseAttribute(name, value);
 94 }
 95 
 96 void HTMLStyleElement::finishParsingChildren()
 97 {
 98     m_styleSheetOwner.finishParsingChildren(*this);
 99     HTMLElement::finishParsingChildren();
100 }
101 
102 Node::InsertedIntoAncestorResult HTMLStyleElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
103 {
104     auto result = HTMLElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
105     if (insertionType.connectedToDocument)
106         m_styleSheetOwner.insertedIntoDocument(*this);
107     return result;
108 }
109 
110 void HTMLStyleElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
111 {
112     HTMLElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
113     if (removalType.disconnectedFromDocument)
114         m_styleSheetOwner.removedFromDocument(*this);
115 }
116 
117 void HTMLStyleElement::childrenChanged(const ChildChange&amp; change)
118 {
119     HTMLElement::childrenChanged(change);
120     m_styleSheetOwner.childrenChanged(*this);
121 }
122 
123 void HTMLStyleElement::dispatchPendingLoadEvents()
124 {
125     styleLoadEventSender().dispatchPendingEvents();
126 }
127 
128 void HTMLStyleElement::dispatchPendingEvent(StyleEventSender* eventSender)
129 {
130     ASSERT_UNUSED(eventSender, eventSender == &amp;styleLoadEventSender());
131     if (m_loadedSheet)
132         dispatchEvent(Event::create(eventNames().loadEvent, Event::CanBubble::No, Event::IsCancelable::No));
133     else
134         dispatchEvent(Event::create(eventNames().errorEvent, Event::CanBubble::No, Event::IsCancelable::No));
135 }
136 
137 void HTMLStyleElement::notifyLoadedSheetAndAllCriticalSubresources(bool errorOccurred)
138 {
139     if (m_firedLoad)
140         return;
141     m_loadedSheet = !errorOccurred;
142     styleLoadEventSender().dispatchEventSoon(*this);
143     m_firedLoad = true;
144 }
145 
146 void HTMLStyleElement::addSubresourceAttributeURLs(ListHashSet&lt;URL&gt;&amp; urls) const
147 {
148     HTMLElement::addSubresourceAttributeURLs(urls);
149 
150     if (auto styleSheet = makeRefPtr(this-&gt;sheet())) {
151         styleSheet-&gt;contents().traverseSubresources([&amp;] (auto&amp; resource) {
152             urls.add(resource.url());
153             return false;
154         });
155     }
156 }
157 
158 bool HTMLStyleElement::disabled() const
159 {
160     if (!sheet())
161         return false;
162 
163     return sheet()-&gt;disabled();
164 }
165 
166 void HTMLStyleElement::setDisabled(bool setDisabled)
167 {
168     if (CSSStyleSheet* styleSheet = sheet())
169         styleSheet-&gt;setDisabled(setDisabled);
170 }
171 
172 }
    </pre>
  </body>
</html>
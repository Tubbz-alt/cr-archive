<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/sql/SQLiteStatement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="SQLiteDatabase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SQLiteStatement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/sql/SQLiteStatement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28 
 29 #include &quot;Logging.h&quot;
 30 #include &quot;SQLValue.h&quot;
 31 #include &lt;sqlite3.h&gt;
 32 #include &lt;wtf/Assertions.h&gt;
 33 #include &lt;wtf/Variant.h&gt;
 34 #include &lt;wtf/text/StringView.h&gt;
 35 
 36 // SQLite 3.6.16 makes sqlite3_prepare_v2 automatically retry preparing the statement
 37 // once if the database scheme has changed. We rely on this behavior.
 38 #if SQLITE_VERSION_NUMBER &lt; 3006016
 39 #error SQLite version 3.6.16 or newer is required
 40 #endif
 41 
 42 namespace WebCore {
 43 
 44 SQLiteStatement::SQLiteStatement(SQLiteDatabase&amp; db, const String&amp; sql)
 45     : m_database(db)
 46     , m_query(sql)
 47     , m_statement(0)
<span class="line-removed"> 48 #ifndef NDEBUG</span>
<span class="line-removed"> 49     , m_isPrepared(false)</span>
<span class="line-removed"> 50 #endif</span>
 51 {
 52 }
 53 
 54 SQLiteStatement::~SQLiteStatement()
 55 {
 56     finalize();
 57 }
 58 
 59 int SQLiteStatement::prepare()
 60 {
 61     ASSERT(!m_isPrepared);
 62 
 63     LockHolder databaseLock(m_database.databaseMutex());
 64 
 65     CString query = m_query.stripWhiteSpace().utf8();
 66 
 67     LOG(SQLDatabase, &quot;SQL - prepare - %s&quot;, query.data());
 68 
 69     // Pass the length of the string including the null character to sqlite3_prepare_v2;
 70     // this lets SQLite avoid an extra string copy.
 71     size_t lengthIncludingNullCharacter = query.length() + 1;
 72 
 73     const char* tail = nullptr;
 74     int error = sqlite3_prepare_v2(m_database.sqlite3Handle(), query.data(), lengthIncludingNullCharacter, &amp;m_statement, &amp;tail);
 75 
 76     if (error != SQLITE_OK)
 77         LOG(SQLDatabase, &quot;sqlite3_prepare16 failed (%i)\n%s\n%s&quot;, error, query.data(), sqlite3_errmsg(m_database.sqlite3Handle()));
 78 
 79     if (tail &amp;&amp; *tail)
 80         error = SQLITE_ERROR;
 81 
<span class="line-modified"> 82 #ifndef NDEBUG</span>
 83     m_isPrepared = error == SQLITE_OK;
 84 #endif
 85     return error;
 86 }
 87 
 88 int SQLiteStatement::step()
 89 {
 90     LockHolder databaseLock(m_database.databaseMutex());
 91 
 92     if (!m_statement)
 93         return SQLITE_OK;
 94 
 95     // The database needs to update its last changes count before each statement
 96     // in order to compute properly the lastChanges() return value.
 97     m_database.updateLastChangesCount();
 98 
 99     LOG(SQLDatabase, &quot;SQL - step - %s&quot;, m_query.ascii().data());
100     int error = sqlite3_step(m_statement);
101     if (error != SQLITE_DONE &amp;&amp; error != SQLITE_ROW) {
102         LOG(SQLDatabase, &quot;sqlite3_step failed (%i)\nQuery - %s\nError - %s&quot;,
103             error, m_query.ascii().data(), sqlite3_errmsg(m_database.sqlite3Handle()));
104     }
105 
106     return error;
107 }
108 
109 int SQLiteStatement::finalize()
110 {
<span class="line-modified">111 #ifndef NDEBUG</span>
112     m_isPrepared = false;
113 #endif
114     if (!m_statement)
115         return SQLITE_OK;
116     LOG(SQLDatabase, &quot;SQL - finalize - %s&quot;, m_query.ascii().data());
117     int result = sqlite3_finalize(m_statement);
118     m_statement = 0;
119     return result;
120 }
121 
122 int SQLiteStatement::reset()
123 {
124     ASSERT(m_isPrepared);
125     if (!m_statement)
126         return SQLITE_OK;
127     LOG(SQLDatabase, &quot;SQL - reset - %s&quot;, m_query.ascii().data());
128     return sqlite3_reset(m_statement);
129 }
130 
131 bool SQLiteStatement::executeCommand()
</pre>
<hr />
<pre>
143 
144 bool SQLiteStatement::returnsAtLeastOneResult()
145 {
146     if (!m_statement &amp;&amp; prepare() != SQLITE_OK)
147         return false;
148     ASSERT(m_isPrepared);
149     if (step() != SQLITE_ROW) {
150         finalize();
151         return false;
152     }
153     finalize();
154     return true;
155 
156 }
157 
158 int SQLiteStatement::bindBlob(int index, const void* blob, int size)
159 {
160     ASSERT(m_isPrepared);
161     ASSERT(index &gt; 0);
162     ASSERT(static_cast&lt;unsigned&gt;(index) &lt;= bindParameterCount());
<span class="line-modified">163     ASSERT(blob);</span>
164     ASSERT(size &gt;= 0);
165 
166     if (!m_statement)
167         return SQLITE_ERROR;
168 
169     return sqlite3_bind_blob(m_statement, index, blob, size, SQLITE_TRANSIENT);
170 }
171 
172 int SQLiteStatement::bindBlob(int index, const String&amp; text)
173 {
174     // String::characters() returns 0 for the empty string, which SQLite
175     // treats as a null, so we supply a non-null pointer for that case.
176     auto upconvertedCharacters = StringView(text).upconvertedCharacters();
177     UChar anyCharacter = 0;
178     const UChar* characters;
179     if (text.isEmpty() &amp;&amp; !text.isNull())
180         characters = &amp;anyCharacter;
181     else
182         characters = upconvertedCharacters;
183 
</pre>
</td>
<td>
<hr />
<pre>
 28 
 29 #include &quot;Logging.h&quot;
 30 #include &quot;SQLValue.h&quot;
 31 #include &lt;sqlite3.h&gt;
 32 #include &lt;wtf/Assertions.h&gt;
 33 #include &lt;wtf/Variant.h&gt;
 34 #include &lt;wtf/text/StringView.h&gt;
 35 
 36 // SQLite 3.6.16 makes sqlite3_prepare_v2 automatically retry preparing the statement
 37 // once if the database scheme has changed. We rely on this behavior.
 38 #if SQLITE_VERSION_NUMBER &lt; 3006016
 39 #error SQLite version 3.6.16 or newer is required
 40 #endif
 41 
 42 namespace WebCore {
 43 
 44 SQLiteStatement::SQLiteStatement(SQLiteDatabase&amp; db, const String&amp; sql)
 45     : m_database(db)
 46     , m_query(sql)
 47     , m_statement(0)



 48 {
 49 }
 50 
 51 SQLiteStatement::~SQLiteStatement()
 52 {
 53     finalize();
 54 }
 55 
 56 int SQLiteStatement::prepare()
 57 {
 58     ASSERT(!m_isPrepared);
 59 
 60     LockHolder databaseLock(m_database.databaseMutex());
 61 
 62     CString query = m_query.stripWhiteSpace().utf8();
 63 
 64     LOG(SQLDatabase, &quot;SQL - prepare - %s&quot;, query.data());
 65 
 66     // Pass the length of the string including the null character to sqlite3_prepare_v2;
 67     // this lets SQLite avoid an extra string copy.
 68     size_t lengthIncludingNullCharacter = query.length() + 1;
 69 
 70     const char* tail = nullptr;
 71     int error = sqlite3_prepare_v2(m_database.sqlite3Handle(), query.data(), lengthIncludingNullCharacter, &amp;m_statement, &amp;tail);
 72 
 73     if (error != SQLITE_OK)
 74         LOG(SQLDatabase, &quot;sqlite3_prepare16 failed (%i)\n%s\n%s&quot;, error, query.data(), sqlite3_errmsg(m_database.sqlite3Handle()));
 75 
 76     if (tail &amp;&amp; *tail)
 77         error = SQLITE_ERROR;
 78 
<span class="line-modified"> 79 #if ASSERT_ENABLED</span>
 80     m_isPrepared = error == SQLITE_OK;
 81 #endif
 82     return error;
 83 }
 84 
 85 int SQLiteStatement::step()
 86 {
 87     LockHolder databaseLock(m_database.databaseMutex());
 88 
 89     if (!m_statement)
 90         return SQLITE_OK;
 91 
 92     // The database needs to update its last changes count before each statement
 93     // in order to compute properly the lastChanges() return value.
 94     m_database.updateLastChangesCount();
 95 
 96     LOG(SQLDatabase, &quot;SQL - step - %s&quot;, m_query.ascii().data());
 97     int error = sqlite3_step(m_statement);
 98     if (error != SQLITE_DONE &amp;&amp; error != SQLITE_ROW) {
 99         LOG(SQLDatabase, &quot;sqlite3_step failed (%i)\nQuery - %s\nError - %s&quot;,
100             error, m_query.ascii().data(), sqlite3_errmsg(m_database.sqlite3Handle()));
101     }
102 
103     return error;
104 }
105 
106 int SQLiteStatement::finalize()
107 {
<span class="line-modified">108 #if ASSERT_ENABLED</span>
109     m_isPrepared = false;
110 #endif
111     if (!m_statement)
112         return SQLITE_OK;
113     LOG(SQLDatabase, &quot;SQL - finalize - %s&quot;, m_query.ascii().data());
114     int result = sqlite3_finalize(m_statement);
115     m_statement = 0;
116     return result;
117 }
118 
119 int SQLiteStatement::reset()
120 {
121     ASSERT(m_isPrepared);
122     if (!m_statement)
123         return SQLITE_OK;
124     LOG(SQLDatabase, &quot;SQL - reset - %s&quot;, m_query.ascii().data());
125     return sqlite3_reset(m_statement);
126 }
127 
128 bool SQLiteStatement::executeCommand()
</pre>
<hr />
<pre>
140 
141 bool SQLiteStatement::returnsAtLeastOneResult()
142 {
143     if (!m_statement &amp;&amp; prepare() != SQLITE_OK)
144         return false;
145     ASSERT(m_isPrepared);
146     if (step() != SQLITE_ROW) {
147         finalize();
148         return false;
149     }
150     finalize();
151     return true;
152 
153 }
154 
155 int SQLiteStatement::bindBlob(int index, const void* blob, int size)
156 {
157     ASSERT(m_isPrepared);
158     ASSERT(index &gt; 0);
159     ASSERT(static_cast&lt;unsigned&gt;(index) &lt;= bindParameterCount());
<span class="line-modified">160     ASSERT(blob || !size);</span>
161     ASSERT(size &gt;= 0);
162 
163     if (!m_statement)
164         return SQLITE_ERROR;
165 
166     return sqlite3_bind_blob(m_statement, index, blob, size, SQLITE_TRANSIENT);
167 }
168 
169 int SQLiteStatement::bindBlob(int index, const String&amp; text)
170 {
171     // String::characters() returns 0 for the empty string, which SQLite
172     // treats as a null, so we supply a non-null pointer for that case.
173     auto upconvertedCharacters = StringView(text).upconvertedCharacters();
174     UChar anyCharacter = 0;
175     const UChar* characters;
176     if (text.isEmpty() &amp;&amp; !text.isNull())
177         characters = &amp;anyCharacter;
178     else
179         characters = upconvertedCharacters;
180 
</pre>
</td>
</tr>
</table>
<center><a href="SQLiteDatabase.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="SQLiteStatement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
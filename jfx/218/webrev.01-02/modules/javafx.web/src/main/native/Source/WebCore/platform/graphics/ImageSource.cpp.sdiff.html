<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageSource.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="ImagePaintingOptions.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ImageSource.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/ImageSource.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ImageSource.h&quot;
 28 
 29 #include &quot;BitmapImage.h&quot;
 30 #include &quot;ImageDecoder.h&quot;
 31 #include &quot;ImageObserver.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &lt;wtf/CheckedArithmetic.h&gt;
<span class="line-removed"> 34 #include &lt;wtf/MainThread.h&gt;</span>
<span class="line-removed"> 35 #include &lt;wtf/RunLoop.h&gt;</span>
 36 #include &lt;wtf/SystemTracing.h&gt;
 37 #include &lt;wtf/URL.h&gt;
 38 
 39 #if USE(DIRECT2D)
 40 #include &quot;GraphicsContext.h&quot;
 41 #include &quot;PlatformContextDirect2D.h&quot;
 42 #endif
 43 
 44 namespace WebCore {
 45 
 46 ImageSource::ImageSource(BitmapImage* image, AlphaOption alphaOption, GammaAndColorProfileOption gammaAndColorProfileOption)
 47     : m_image(image)
 48     , m_alphaOption(alphaOption)
 49     , m_gammaAndColorProfileOption(gammaAndColorProfileOption)

 50 {
<span class="line-removed"> 51     ASSERT(isMainThread());</span>
 52 }
 53 
 54 ImageSource::ImageSource(NativeImagePtr&amp;&amp; nativeImage)

 55 {
<span class="line-removed"> 56     ASSERT(isMainThread());</span>
<span class="line-removed"> 57 </span>
 58     m_frameCount = 1;
 59     m_encodedDataStatus = EncodedDataStatus::Complete;
 60     growFrames();
 61 
 62     setNativeImage(WTFMove(nativeImage));
 63 
 64     m_decodedSize = m_frames[0].frameBytes();
 65 
<span class="line-removed"> 66     // The assumption is the memory image will be displayed with the default</span>
<span class="line-removed"> 67     // orientation. So set m_sizeRespectingOrientation to be the same as m_size.</span>
 68     m_size = m_frames[0].size();
<span class="line-modified"> 69     m_sizeRespectingOrientation = m_size;</span>
 70 }
 71 
 72 ImageSource::~ImageSource()
 73 {
 74     ASSERT(!hasAsyncDecodingQueue());
<span class="line-modified"> 75     ASSERT(isMainThread());</span>
 76 }
 77 
 78 bool ImageSource::ensureDecoderAvailable(SharedBuffer* data)
 79 {
 80     if (!data || isDecoderAvailable())
 81         return true;
 82 
 83     m_decoder = ImageDecoder::create(*data, mimeType(), m_alphaOption, m_gammaAndColorProfileOption);
 84     if (!isDecoderAvailable())
 85         return false;
 86 
 87     m_decoder-&gt;setEncodedDataStatusChangeCallback([weakThis = makeWeakPtr(this)] (auto status) {
 88         if (weakThis)
 89             weakThis-&gt;encodedDataStatusChanged(status);
 90     });
 91 
 92     if (auto expectedContentSize = expectedContentLength())
 93         m_decoder-&gt;setExpectedContentSize(expectedContentSize);
 94 
 95     // Changing the decoder has to stop the decoding thread. The current frame will
</pre>
<hr />
<pre>
333 {
334     if (!m_frameRequestQueue)
335         m_frameRequestQueue = FrameRequestQueue::create();
336 
337     return *m_frameRequestQueue;
338 }
339 
340 bool ImageSource::canUseAsyncDecoding()
341 {
342     if (!isDecoderAvailable())
343         return false;
344     // FIXME: figure out the best heuristic for enabling async image decoding.
345     return size().area() * sizeof(uint32_t) &gt;= (frameCount() &gt; 1 ? 100 * KB : 500 * KB);
346 }
347 
348 void ImageSource::startAsyncDecodingQueue()
349 {
350     if (hasAsyncDecodingQueue() || !isDecoderAvailable())
351         return;
352 



353     // We need to protect this, m_decodingQueue and m_decoder from being deleted while we are in the decoding loop.
<span class="line-modified">354     decodingQueue().dispatch([protectedThis = makeRef(*this), protectedDecodingQueue = makeRef(decodingQueue()), protectedFrameRequestQueue = makeRef(frameRequestQueue()), protectedDecoder = makeRef(*m_decoder), sourceURL = sourceURL().string().isolatedCopy()] {</span>
355         ImageFrameRequest frameRequest;
356         Seconds minDecodingDuration = protectedThis-&gt;frameDecodingDurationForTesting();
357 
358         while (protectedFrameRequestQueue-&gt;dequeue(frameRequest)) {
359             TraceScope tracingScope(AsyncImageDecodeStart, AsyncImageDecodeEnd);
360 
361             MonotonicTime startingTime;
362             if (minDecodingDuration &gt; 0_s)
363                 startingTime = MonotonicTime::now();
364 
365             // Get the frame NativeImage on the decoding thread.
366             NativeImagePtr nativeImage = protectedDecoder-&gt;createFrameImageAtIndex(frameRequest.index, frameRequest.subsamplingLevel, frameRequest.decodingOptions);
367             if (nativeImage)
368                 LOG(Images, &quot;ImageSource::%s - %p - url: %s [frame %ld has been decoded]&quot;, __FUNCTION__, protectedThis.ptr(), sourceURL.utf8().data(), frameRequest.index);
369             else {
370                 LOG(Images, &quot;ImageSource::%s - %p - url: %s [decoding for frame %ld has failed]&quot;, __FUNCTION__, protectedThis.ptr(), sourceURL.utf8().data(), frameRequest.index);
371                 continue;
372             }
373 
374             // Pretend as if the decoding takes minDecodingDuration.
375             if (minDecodingDuration &gt; 0_s)
376                 sleep(minDecodingDuration - (MonotonicTime::now() - startingTime));
377 
<span class="line-modified">378             // Update the cached frames on the main thread to avoid updating the MemoryCache from a different thread.</span>
379             callOnMainThread([protectedThis = protectedThis.copyRef(), protectedQueue = protectedDecodingQueue.copyRef(), protectedDecoder = protectedDecoder.copyRef(), sourceURL = sourceURL.isolatedCopy(), nativeImage = WTFMove(nativeImage), frameRequest] () mutable {
380                 // The queue may have been closed if after we got the frame NativeImage, stopAsyncDecodingQueue() was called.
381                 if (protectedQueue.ptr() == protectedThis-&gt;m_decodingQueue &amp;&amp; protectedDecoder.ptr() == protectedThis-&gt;m_decoder) {
382                     ASSERT(protectedThis-&gt;m_frameCommitQueue.first() == frameRequest);
383                     protectedThis-&gt;m_frameCommitQueue.removeFirst();
384                     protectedThis-&gt;cacheNativeImageAtIndexAsync(WTFMove(nativeImage), frameRequest.index, frameRequest.subsamplingLevel, frameRequest.decodingOptions, frameRequest.decodingStatus);
385                 } else
386                     LOG(Images, &quot;ImageSource::%s - %p - url: %s [frame %ld will not cached]&quot;, __FUNCTION__, protectedThis.ptr(), sourceURL.utf8().data(), frameRequest.index);
387             });
388         }



389     });
390 }
391 
392 void ImageSource::requestFrameAsyncDecodingAtIndex(size_t index, SubsamplingLevel subsamplingLevel, const Optional&lt;IntSize&gt;&amp; sizeForDrawing)
393 {
394     ASSERT(isDecoderAvailable());
395     if (!hasAsyncDecodingQueue())
396         startAsyncDecodingQueue();
397 
398     ASSERT(index &lt; m_frames.size());
399     DecodingStatus decodingStatus = m_decoder-&gt;frameIsCompleteAtIndex(index) ? DecodingStatus::Complete : DecodingStatus::Partial;
400 
401     LOG(Images, &quot;ImageSource::%s - %p - url: %s [enqueuing frame %ld for decoding]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data(), index);
402     m_frameRequestQueue-&gt;enqueue({ index, subsamplingLevel, sizeForDrawing, decodingStatus });
403     m_frameCommitQueue.append({ index, subsamplingLevel, sizeForDrawing, decodingStatus });
404 }
405 
406 bool ImageSource::isAsyncDecodingQueueIdle() const
407 {
408     return m_frameCommitQueue.isEmpty();
</pre>
<hr />
<pre>
542 
543 String ImageSource::uti()
544 {
545 #if USE(CG)
546     return metadata&lt;String, (&amp;ImageDecoder::uti)&gt;(String(), &amp;m_uti);
547 #else
548     return String();
549 #endif
550 }
551 
552 String ImageSource::filenameExtension()
553 {
554     return metadata&lt;String, (&amp;ImageDecoder::filenameExtension)&gt;(String(), &amp;m_filenameExtension);
555 }
556 
557 Optional&lt;IntPoint&gt; ImageSource::hotSpot()
558 {
559     return metadata&lt;Optional&lt;IntPoint&gt;, (&amp;ImageDecoder::hotSpot)&gt;(WTF::nullopt, &amp;m_hotSpot);
560 }
561 
<span class="line-modified">562 IntSize ImageSource::size()</span>
563 {






564 #if !USE(CG)
565     // It&#39;s possible that we have decoded the metadata, but not frame contents yet. In that case ImageDecoder claims to
566     // have the size available, but the frame cache is empty. Return the decoder size without caching in such case.
567     if (m_frames.isEmpty() &amp;&amp; isDecoderAvailable())
<span class="line-modified">568         return m_decoder-&gt;size();</span>

569 #endif
<span class="line-modified">570     return frameMetadataAtIndexCacheIfNeeded&lt;IntSize&gt;(0, (&amp;ImageFrame::size), &amp;m_size, ImageFrame::Caching::Metadata, SubsamplingLevel::Default);</span>
<span class="line-removed">571 }</span>
572 
<span class="line-modified">573 IntSize ImageSource::sizeRespectingOrientation()</span>
<span class="line-modified">574 {</span>
<span class="line-modified">575     return frameMetadataAtIndexCacheIfNeeded&lt;IntSize&gt;(0, (&amp;ImageFrame::sizeRespectingOrientation), &amp;m_sizeRespectingOrientation, ImageFrame::Caching::Metadata, SubsamplingLevel::Default);</span>

576 }
577 
578 Color ImageSource::singlePixelSolidColor()
579 {
580     if (!m_singlePixelSolidColor &amp;&amp; (size() != IntSize(1, 1) || frameCount() != 1))
581         m_singlePixelSolidColor = Color();
582 
583     if (m_singlePixelSolidColor)
584         return m_singlePixelSolidColor.value();
585 
586     return frameMetadataAtIndexCacheIfNeeded&lt;Color&gt;(0, (&amp;ImageFrame::singlePixelSolidColor), &amp;m_singlePixelSolidColor, ImageFrame::Caching::MetadataAndImage);
587 }
588 
589 SubsamplingLevel ImageSource::maximumSubsamplingLevel()
590 {
591     if (m_maximumSubsamplingLevel)
592         return m_maximumSubsamplingLevel.value();
593 
594     if (!isDecoderAvailable() || !m_decoder-&gt;frameAllowSubsamplingAtIndex(0))
595         return SubsamplingLevel::Default;
</pre>
</td>
<td>
<hr />
<pre>
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;ImageSource.h&quot;
 28 
 29 #include &quot;BitmapImage.h&quot;
 30 #include &quot;ImageDecoder.h&quot;
 31 #include &quot;ImageObserver.h&quot;
 32 #include &quot;Logging.h&quot;
 33 #include &lt;wtf/CheckedArithmetic.h&gt;


 34 #include &lt;wtf/SystemTracing.h&gt;
 35 #include &lt;wtf/URL.h&gt;
 36 
 37 #if USE(DIRECT2D)
 38 #include &quot;GraphicsContext.h&quot;
 39 #include &quot;PlatformContextDirect2D.h&quot;
 40 #endif
 41 
 42 namespace WebCore {
 43 
 44 ImageSource::ImageSource(BitmapImage* image, AlphaOption alphaOption, GammaAndColorProfileOption gammaAndColorProfileOption)
 45     : m_image(image)
 46     , m_alphaOption(alphaOption)
 47     , m_gammaAndColorProfileOption(gammaAndColorProfileOption)
<span class="line-added"> 48     , m_runLoop(RunLoop::current())</span>
 49 {

 50 }
 51 
 52 ImageSource::ImageSource(NativeImagePtr&amp;&amp; nativeImage)
<span class="line-added"> 53     : m_runLoop(RunLoop::current())</span>
 54 {


 55     m_frameCount = 1;
 56     m_encodedDataStatus = EncodedDataStatus::Complete;
 57     growFrames();
 58 
 59     setNativeImage(WTFMove(nativeImage));
 60 
 61     m_decodedSize = m_frames[0].frameBytes();
 62 


 63     m_size = m_frames[0].size();
<span class="line-modified"> 64     m_orientation = ImageOrientation(ImageOrientation::None);</span>
 65 }
 66 
 67 ImageSource::~ImageSource()
 68 {
 69     ASSERT(!hasAsyncDecodingQueue());
<span class="line-modified"> 70     ASSERT(&amp;m_runLoop == &amp;RunLoop::current());</span>
 71 }
 72 
 73 bool ImageSource::ensureDecoderAvailable(SharedBuffer* data)
 74 {
 75     if (!data || isDecoderAvailable())
 76         return true;
 77 
 78     m_decoder = ImageDecoder::create(*data, mimeType(), m_alphaOption, m_gammaAndColorProfileOption);
 79     if (!isDecoderAvailable())
 80         return false;
 81 
 82     m_decoder-&gt;setEncodedDataStatusChangeCallback([weakThis = makeWeakPtr(this)] (auto status) {
 83         if (weakThis)
 84             weakThis-&gt;encodedDataStatusChanged(status);
 85     });
 86 
 87     if (auto expectedContentSize = expectedContentLength())
 88         m_decoder-&gt;setExpectedContentSize(expectedContentSize);
 89 
 90     // Changing the decoder has to stop the decoding thread. The current frame will
</pre>
<hr />
<pre>
328 {
329     if (!m_frameRequestQueue)
330         m_frameRequestQueue = FrameRequestQueue::create();
331 
332     return *m_frameRequestQueue;
333 }
334 
335 bool ImageSource::canUseAsyncDecoding()
336 {
337     if (!isDecoderAvailable())
338         return false;
339     // FIXME: figure out the best heuristic for enabling async image decoding.
340     return size().area() * sizeof(uint32_t) &gt;= (frameCount() &gt; 1 ? 100 * KB : 500 * KB);
341 }
342 
343 void ImageSource::startAsyncDecodingQueue()
344 {
345     if (hasAsyncDecodingQueue() || !isDecoderAvailable())
346         return;
347 
<span class="line-added">348     // Async decoding is only enabled for HTMLImageElement and CSS background images.</span>
<span class="line-added">349     ASSERT(isMainThread());</span>
<span class="line-added">350 </span>
351     // We need to protect this, m_decodingQueue and m_decoder from being deleted while we are in the decoding loop.
<span class="line-modified">352     decodingQueue().dispatch([protectedThis = makeRef(*this), protectedDecodingQueue = makeRef(decodingQueue()), protectedFrameRequestQueue = makeRef(frameRequestQueue()), protectedDecoder = makeRef(*m_decoder), sourceURL = sourceURL().string().isolatedCopy()] () mutable {</span>
353         ImageFrameRequest frameRequest;
354         Seconds minDecodingDuration = protectedThis-&gt;frameDecodingDurationForTesting();
355 
356         while (protectedFrameRequestQueue-&gt;dequeue(frameRequest)) {
357             TraceScope tracingScope(AsyncImageDecodeStart, AsyncImageDecodeEnd);
358 
359             MonotonicTime startingTime;
360             if (minDecodingDuration &gt; 0_s)
361                 startingTime = MonotonicTime::now();
362 
363             // Get the frame NativeImage on the decoding thread.
364             NativeImagePtr nativeImage = protectedDecoder-&gt;createFrameImageAtIndex(frameRequest.index, frameRequest.subsamplingLevel, frameRequest.decodingOptions);
365             if (nativeImage)
366                 LOG(Images, &quot;ImageSource::%s - %p - url: %s [frame %ld has been decoded]&quot;, __FUNCTION__, protectedThis.ptr(), sourceURL.utf8().data(), frameRequest.index);
367             else {
368                 LOG(Images, &quot;ImageSource::%s - %p - url: %s [decoding for frame %ld has failed]&quot;, __FUNCTION__, protectedThis.ptr(), sourceURL.utf8().data(), frameRequest.index);
369                 continue;
370             }
371 
372             // Pretend as if the decoding takes minDecodingDuration.
373             if (minDecodingDuration &gt; 0_s)
374                 sleep(minDecodingDuration - (MonotonicTime::now() - startingTime));
375 
<span class="line-modified">376             // Update the cached frames on the creation thread to avoid updating the MemoryCache from a different thread.</span>
377             callOnMainThread([protectedThis = protectedThis.copyRef(), protectedQueue = protectedDecodingQueue.copyRef(), protectedDecoder = protectedDecoder.copyRef(), sourceURL = sourceURL.isolatedCopy(), nativeImage = WTFMove(nativeImage), frameRequest] () mutable {
378                 // The queue may have been closed if after we got the frame NativeImage, stopAsyncDecodingQueue() was called.
379                 if (protectedQueue.ptr() == protectedThis-&gt;m_decodingQueue &amp;&amp; protectedDecoder.ptr() == protectedThis-&gt;m_decoder) {
380                     ASSERT(protectedThis-&gt;m_frameCommitQueue.first() == frameRequest);
381                     protectedThis-&gt;m_frameCommitQueue.removeFirst();
382                     protectedThis-&gt;cacheNativeImageAtIndexAsync(WTFMove(nativeImage), frameRequest.index, frameRequest.subsamplingLevel, frameRequest.decodingOptions, frameRequest.decodingStatus);
383                 } else
384                     LOG(Images, &quot;ImageSource::%s - %p - url: %s [frame %ld will not cached]&quot;, __FUNCTION__, protectedThis.ptr(), sourceURL.utf8().data(), frameRequest.index);
385             });
386         }
<span class="line-added">387 </span>
<span class="line-added">388         // Ensure destruction happens on creation thread.</span>
<span class="line-added">389         callOnMainThread([protectedThis = WTFMove(protectedThis), protectedQueue = WTFMove(protectedDecodingQueue), protectedDecoder = WTFMove(protectedDecoder)] () mutable { });</span>
390     });
391 }
392 
393 void ImageSource::requestFrameAsyncDecodingAtIndex(size_t index, SubsamplingLevel subsamplingLevel, const Optional&lt;IntSize&gt;&amp; sizeForDrawing)
394 {
395     ASSERT(isDecoderAvailable());
396     if (!hasAsyncDecodingQueue())
397         startAsyncDecodingQueue();
398 
399     ASSERT(index &lt; m_frames.size());
400     DecodingStatus decodingStatus = m_decoder-&gt;frameIsCompleteAtIndex(index) ? DecodingStatus::Complete : DecodingStatus::Partial;
401 
402     LOG(Images, &quot;ImageSource::%s - %p - url: %s [enqueuing frame %ld for decoding]&quot;, __FUNCTION__, this, sourceURL().string().utf8().data(), index);
403     m_frameRequestQueue-&gt;enqueue({ index, subsamplingLevel, sizeForDrawing, decodingStatus });
404     m_frameCommitQueue.append({ index, subsamplingLevel, sizeForDrawing, decodingStatus });
405 }
406 
407 bool ImageSource::isAsyncDecodingQueueIdle() const
408 {
409     return m_frameCommitQueue.isEmpty();
</pre>
<hr />
<pre>
543 
544 String ImageSource::uti()
545 {
546 #if USE(CG)
547     return metadata&lt;String, (&amp;ImageDecoder::uti)&gt;(String(), &amp;m_uti);
548 #else
549     return String();
550 #endif
551 }
552 
553 String ImageSource::filenameExtension()
554 {
555     return metadata&lt;String, (&amp;ImageDecoder::filenameExtension)&gt;(String(), &amp;m_filenameExtension);
556 }
557 
558 Optional&lt;IntPoint&gt; ImageSource::hotSpot()
559 {
560     return metadata&lt;Optional&lt;IntPoint&gt;, (&amp;ImageDecoder::hotSpot)&gt;(WTF::nullopt, &amp;m_hotSpot);
561 }
562 
<span class="line-modified">563 ImageOrientation ImageSource::orientation()</span>
564 {
<span class="line-added">565     return frameMetadataAtIndexCacheIfNeeded&lt;ImageOrientation&gt;(0, (&amp;ImageFrame::orientation), &amp;m_orientation, ImageFrame::Caching::Metadata);</span>
<span class="line-added">566 }</span>
<span class="line-added">567 </span>
<span class="line-added">568 IntSize ImageSource::size(ImageOrientation orientation)</span>
<span class="line-added">569 {</span>
<span class="line-added">570     IntSize size;</span>
571 #if !USE(CG)
572     // It&#39;s possible that we have decoded the metadata, but not frame contents yet. In that case ImageDecoder claims to
573     // have the size available, but the frame cache is empty. Return the decoder size without caching in such case.
574     if (m_frames.isEmpty() &amp;&amp; isDecoderAvailable())
<span class="line-modified">575         size = m_decoder-&gt;size();</span>
<span class="line-added">576     else</span>
577 #endif
<span class="line-modified">578         size = frameMetadataAtIndexCacheIfNeeded&lt;IntSize&gt;(0, (&amp;ImageFrame::size), &amp;m_size, ImageFrame::Caching::Metadata, SubsamplingLevel::Default);</span>

579 
<span class="line-modified">580     if (orientation == ImageOrientation::FromImage)</span>
<span class="line-modified">581         orientation = this-&gt;orientation();</span>
<span class="line-modified">582 </span>
<span class="line-added">583     return orientation.usesWidthAsHeight() ? size.transposedSize() : size;</span>
584 }
585 
586 Color ImageSource::singlePixelSolidColor()
587 {
588     if (!m_singlePixelSolidColor &amp;&amp; (size() != IntSize(1, 1) || frameCount() != 1))
589         m_singlePixelSolidColor = Color();
590 
591     if (m_singlePixelSolidColor)
592         return m_singlePixelSolidColor.value();
593 
594     return frameMetadataAtIndexCacheIfNeeded&lt;Color&gt;(0, (&amp;ImageFrame::singlePixelSolidColor), &amp;m_singlePixelSolidColor, ImageFrame::Caching::MetadataAndImage);
595 }
596 
597 SubsamplingLevel ImageSource::maximumSubsamplingLevel()
598 {
599     if (m_maximumSubsamplingLevel)
600         return m_maximumSubsamplingLevel.value();
601 
602     if (!isDecoderAvailable() || !m_decoder-&gt;frameAllowSubsamplingAtIndex(0))
603         return SubsamplingLevel::Default;
</pre>
</td>
</tr>
</table>
<center><a href="ImagePaintingOptions.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="ImageSource.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
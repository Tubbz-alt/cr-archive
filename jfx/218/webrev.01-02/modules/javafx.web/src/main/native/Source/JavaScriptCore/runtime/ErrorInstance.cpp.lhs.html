<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/ErrorInstance.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  *  Copyright (C) 1999-2000 Harri Porten (porten@kde.org)
  3  *  Copyright (C) 2003-2019 Apple Inc. All rights reserved.
  4  *
  5  *  This library is free software; you can redistribute it and/or
  6  *  modify it under the terms of the GNU Lesser General Public
  7  *  License as published by the Free Software Foundation; either
  8  *  version 2 of the License, or (at your option) any later version.
  9  *
 10  *  This library is distributed in the hope that it will be useful,
 11  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 12  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 13  *  Lesser General Public License for more details.
 14  *
 15  *  You should have received a copy of the GNU Lesser General Public
 16  *  License along with this library; if not, write to the Free Software
 17  *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 18  *
 19  */
 20 
 21 #include &quot;config.h&quot;
 22 #include &quot;ErrorInstance.h&quot;
 23 
 24 #include &quot;CodeBlock.h&quot;
 25 #include &quot;InlineCallFrame.h&quot;
 26 #include &quot;Interpreter.h&quot;
 27 #include &quot;JSScope.h&quot;
 28 #include &quot;JSCInlines.h&quot;
 29 #include &quot;ParseInt.h&quot;
 30 #include &quot;StackFrame.h&quot;
 31 #include &lt;wtf/text/StringBuilder.h&gt;
 32 
 33 namespace JSC {
 34 
 35 const ClassInfo ErrorInstance::s_info = { &quot;Error&quot;, &amp;JSNonFinalObject::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(ErrorInstance) };
 36 
 37 ErrorInstance::ErrorInstance(VM&amp; vm, Structure* structure)
 38     : Base(vm, structure)
 39 {
 40 }
 41 
<a name="1" id="anc1"></a><span class="line-modified"> 42 ErrorInstance* ErrorInstance::create(ExecState* state, Structure* structure, JSValue message, SourceAppender appender, RuntimeType type, bool useCurrentFrame)</span>
 43 {
<a name="2" id="anc2"></a><span class="line-modified"> 44     VM&amp; vm = state-&gt;vm();</span>
 45     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="3" id="anc3"></a><span class="line-modified"> 46     String messageString = message.isUndefined() ? String() : message.toWTFString(state);</span>
 47     RETURN_IF_EXCEPTION(scope, nullptr);
<a name="4" id="anc4"></a><span class="line-modified"> 48     return create(state, vm, structure, messageString, appender, type, useCurrentFrame);</span>
 49 }
 50 
<a name="5" id="anc5"></a><span class="line-modified"> 51 static void appendSourceToError(CallFrame* callFrame, ErrorInstance* exception, unsigned bytecodeOffset)</span>
 52 {
 53     ErrorInstance::SourceAppender appender = exception-&gt;sourceAppender();
 54     exception-&gt;clearSourceAppender();
 55     RuntimeType type = exception-&gt;runtimeTypeForCause();
 56     exception-&gt;clearRuntimeTypeForCause();
 57 
 58     if (!callFrame-&gt;codeBlock()-&gt;hasExpressionInfo())
 59         return;
 60 
 61     int startOffset = 0;
 62     int endOffset = 0;
 63     int divotPoint = 0;
 64     unsigned line = 0;
 65     unsigned column = 0;
 66 
 67     CodeBlock* codeBlock;
 68     CodeOrigin codeOrigin = callFrame-&gt;codeOrigin();
 69     if (codeOrigin &amp;&amp; codeOrigin.inlineCallFrame())
 70         codeBlock = baselineCodeBlockForInlineCallFrame(codeOrigin.inlineCallFrame());
 71     else
 72         codeBlock = callFrame-&gt;codeBlock();
 73 
<a name="6" id="anc6"></a><span class="line-modified"> 74     codeBlock-&gt;expressionRangeForBytecodeOffset(bytecodeOffset, divotPoint, startOffset, endOffset, line, column);</span>
 75 
 76     int expressionStart = divotPoint - startOffset;
 77     int expressionStop = divotPoint + endOffset;
 78 
 79     StringView sourceString = codeBlock-&gt;source().provider()-&gt;source();
 80     if (!expressionStop || expressionStart &gt; static_cast&lt;int&gt;(sourceString.length()))
 81         return;
 82 
<a name="7" id="anc7"></a><span class="line-modified"> 83     VM&amp; vm = callFrame-&gt;vm();</span>
 84     JSValue jsMessage = exception-&gt;getDirect(vm, vm.propertyNames-&gt;message);
 85     if (!jsMessage || !jsMessage.isString())
 86         return;
 87 
<a name="8" id="anc8"></a><span class="line-modified"> 88     String message = asString(jsMessage)-&gt;value(callFrame);</span>
 89     if (expressionStart &lt; expressionStop)
 90         message = appender(message, codeBlock-&gt;source().provider()-&gt;getRange(expressionStart, expressionStop).toString(), type, ErrorInstance::FoundExactSource);
 91     else {
 92         // No range information, so give a few characters of context.
 93         int dataLength = sourceString.length();
 94         int start = expressionStart;
 95         int stop = expressionStart;
 96         // Get up to 20 characters of context to the left and right of the divot, clamping to the line.
 97         // Then strip whitespace.
 98         while (start &gt; 0 &amp;&amp; (expressionStart - start &lt; 20) &amp;&amp; sourceString[start - 1] != &#39;\n&#39;)
 99             start--;
100         while (start &lt; (expressionStart - 1) &amp;&amp; isStrWhiteSpace(sourceString[start]))
101             start++;
102         while (stop &lt; dataLength &amp;&amp; (stop - expressionStart &lt; 20) &amp;&amp; sourceString[stop] != &#39;\n&#39;)
103             stop++;
104         while (stop &gt; expressionStart &amp;&amp; isStrWhiteSpace(sourceString[stop - 1]))
105             stop--;
106         message = appender(message, codeBlock-&gt;source().provider()-&gt;getRange(start, stop).toString(), type, ErrorInstance::FoundApproximateSource);
107     }
108     exception-&gt;putDirect(vm, vm.propertyNames-&gt;message, jsString(vm, message));
109 
110 }
111 
<a name="9" id="anc9"></a><span class="line-modified">112 void ErrorInstance::finishCreation(ExecState* exec, VM&amp; vm, const String&amp; message, bool useCurrentFrame)</span>
113 {
114     Base::finishCreation(vm);
115     ASSERT(inherits(vm, info()));
116     if (!message.isNull())
117         putDirect(vm, vm.propertyNames-&gt;message, jsString(vm, message), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));
118 
<a name="10" id="anc10"></a><span class="line-modified">119     std::unique_ptr&lt;Vector&lt;StackFrame&gt;&gt; stackTrace = getStackTrace(exec, vm, this, useCurrentFrame);</span>
120     {
121         auto locker = holdLock(cellLock());
122         m_stackTrace = WTFMove(stackTrace);
123     }
124     vm.heap.writeBarrier(this);
125 
126     if (m_stackTrace &amp;&amp; !m_stackTrace-&gt;isEmpty() &amp;&amp; hasSourceAppender()) {
<a name="11" id="anc11"></a><span class="line-modified">127         unsigned bytecodeOffset;</span>
128         CallFrame* callFrame;
<a name="12" id="anc12"></a><span class="line-modified">129         getBytecodeOffset(exec, vm, m_stackTrace.get(), callFrame, bytecodeOffset);</span>
<span class="line-modified">130         if (callFrame &amp;&amp; callFrame-&gt;codeBlock()) {</span>
<span class="line-modified">131             ASSERT(!callFrame-&gt;callee().isWasm());</span>
<span class="line-removed">132             appendSourceToError(callFrame, this, bytecodeOffset);</span>
<span class="line-removed">133         }</span>
134     }
135 }
136 
<a name="13" id="anc13"></a><span class="line-removed">137 void ErrorInstance::destroy(JSCell* cell)</span>
<span class="line-removed">138 {</span>
<span class="line-removed">139     static_cast&lt;ErrorInstance*&gt;(cell)-&gt;ErrorInstance::~ErrorInstance();</span>
<span class="line-removed">140 }</span>
<span class="line-removed">141 </span>
142 // Based on ErrorPrototype&#39;s errorProtoFuncToString(), but is modified to
143 // have no observable side effects to the user (i.e. does not call proxies,
144 // and getters).
<a name="14" id="anc14"></a><span class="line-modified">145 String ErrorInstance::sanitizedToString(ExecState* exec)</span>
146 {
<a name="15" id="anc15"></a><span class="line-modified">147     VM&amp; vm = exec-&gt;vm();</span>
148     auto scope = DECLARE_THROW_SCOPE(vm);
149 
150     JSValue nameValue;
151     auto namePropertName = vm.propertyNames-&gt;name;
152     PropertySlot nameSlot(this, PropertySlot::InternalMethodType::VMInquiry);
153 
154     JSValue currentObj = this;
155     unsigned prototypeDepth = 0;
156 
157     // We only check the current object and its prototype (2 levels) because normal
158     // Error objects may have a name property, and if not, its prototype should have
159     // a name property for the type of error e.g. &quot;SyntaxError&quot;.
160     while (currentObj.isCell() &amp;&amp; prototypeDepth++ &lt; 2) {
161         JSObject* obj = jsCast&lt;JSObject*&gt;(currentObj);
<a name="16" id="anc16"></a><span class="line-modified">162         if (JSObject::getOwnPropertySlot(obj, exec, namePropertName, nameSlot) &amp;&amp; nameSlot.isValue()) {</span>
<span class="line-modified">163             nameValue = nameSlot.getValue(exec, namePropertName);</span>
164             break;
165         }
166         currentObj = obj-&gt;getPrototypeDirect(vm);
167     }
168     scope.assertNoException();
169 
170     String nameString;
171     if (!nameValue)
172         nameString = &quot;Error&quot;_s;
173     else {
<a name="17" id="anc17"></a><span class="line-modified">174         nameString = nameValue.toWTFString(exec);</span>
175         RETURN_IF_EXCEPTION(scope, String());
176     }
177 
178     JSValue messageValue;
179     auto messagePropertName = vm.propertyNames-&gt;message;
180     PropertySlot messageSlot(this, PropertySlot::InternalMethodType::VMInquiry);
<a name="18" id="anc18"></a><span class="line-modified">181     if (JSObject::getOwnPropertySlot(this, exec, messagePropertName, messageSlot) &amp;&amp; messageSlot.isValue())</span>
<span class="line-modified">182         messageValue = messageSlot.getValue(exec, messagePropertName);</span>
183     scope.assertNoException();
184 
185     String messageString;
186     if (!messageValue)
187         messageString = String();
188     else {
<a name="19" id="anc19"></a><span class="line-modified">189         messageString = messageValue.toWTFString(exec);</span>
190         RETURN_IF_EXCEPTION(scope, String());
191     }
192 
193     if (!nameString.length())
194         return messageString;
195 
196     if (!messageString.length())
197         return nameString;
198 
199     StringBuilder builder;
200     builder.append(nameString);
201     builder.appendLiteral(&quot;: &quot;);
202     builder.append(messageString);
203     return builder.toString();
204 }
205 
206 void ErrorInstance::finalizeUnconditionally(VM&amp; vm)
207 {
208     if (!m_stackTrace)
209         return;
210 
211     // We don&#39;t want to keep our stack traces alive forever if the user doesn&#39;t access the stack trace.
212     // If we did, we might end up keeping functions (and their global objects) alive that happened to
213     // get caught in a trace.
214     for (const auto&amp; frame : *m_stackTrace.get()) {
215         if (!frame.isMarked(vm)) {
216             computeErrorInfo(vm);
217             return;
218         }
219     }
220 }
221 
222 void ErrorInstance::computeErrorInfo(VM&amp; vm)
223 {
224     ASSERT(!m_errorInfoMaterialized);
225 
226     if (m_stackTrace &amp;&amp; !m_stackTrace-&gt;isEmpty()) {
227         getLineColumnAndSource(m_stackTrace.get(), m_line, m_column, m_sourceURL);
228         m_stackString = Interpreter::stackTraceAsString(vm, *m_stackTrace.get());
229         m_stackTrace = nullptr;
230     }
231 }
232 
233 bool ErrorInstance::materializeErrorInfoIfNeeded(VM&amp; vm)
234 {
235     if (m_errorInfoMaterialized)
236         return false;
237 
238     computeErrorInfo(vm);
239 
240     if (!m_stackString.isNull()) {
<a name="20" id="anc20"></a><span class="line-modified">241         putDirect(vm, vm.propertyNames-&gt;line, jsNumber(m_line));</span>
<span class="line-modified">242         putDirect(vm, vm.propertyNames-&gt;column, jsNumber(m_column));</span>


243         if (!m_sourceURL.isEmpty())
<a name="21" id="anc21"></a><span class="line-modified">244             putDirect(vm, vm.propertyNames-&gt;sourceURL, jsString(vm, WTFMove(m_sourceURL)));</span>
245 
<a name="22" id="anc22"></a><span class="line-modified">246         putDirect(vm, vm.propertyNames-&gt;stack, jsString(vm, WTFMove(m_stackString)), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum));</span>
247     }
248 
249     m_errorInfoMaterialized = true;
250     return true;
251 }
252 
253 bool ErrorInstance::materializeErrorInfoIfNeeded(VM&amp; vm, PropertyName propertyName)
254 {
255     if (propertyName == vm.propertyNames-&gt;line
256         || propertyName == vm.propertyNames-&gt;column
257         || propertyName == vm.propertyNames-&gt;sourceURL
258         || propertyName == vm.propertyNames-&gt;stack)
259         return materializeErrorInfoIfNeeded(vm);
260     return false;
261 }
262 
<a name="23" id="anc23"></a><span class="line-modified">263 bool ErrorInstance::getOwnPropertySlot(JSObject* object, ExecState* exec, PropertyName propertyName, PropertySlot&amp; slot)</span>
264 {
<a name="24" id="anc24"></a><span class="line-modified">265     VM&amp; vm = exec-&gt;vm();</span>
266     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(object);
267     thisObject-&gt;materializeErrorInfoIfNeeded(vm, propertyName);
<a name="25" id="anc25"></a><span class="line-modified">268     return Base::getOwnPropertySlot(thisObject, exec, propertyName, slot);</span>
269 }
270 
<a name="26" id="anc26"></a><span class="line-modified">271 void ErrorInstance::getOwnNonIndexPropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)</span>
272 {
<a name="27" id="anc27"></a><span class="line-modified">273     VM&amp; vm = exec-&gt;vm();</span>
274     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(object);
275     thisObject-&gt;materializeErrorInfoIfNeeded(vm);
<a name="28" id="anc28"></a><span class="line-modified">276     Base::getOwnNonIndexPropertyNames(thisObject, exec, propertyNameArray, enumerationMode);</span>
277 }
278 
<a name="29" id="anc29"></a><span class="line-modified">279 void ErrorInstance::getStructurePropertyNames(JSObject* object, ExecState* exec, PropertyNameArray&amp; propertyNameArray, EnumerationMode enumerationMode)</span>
280 {
<a name="30" id="anc30"></a><span class="line-modified">281     VM&amp; vm = exec-&gt;vm();</span>
282     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(object);
283     thisObject-&gt;materializeErrorInfoIfNeeded(vm);
<a name="31" id="anc31"></a><span class="line-modified">284     Base::getStructurePropertyNames(thisObject, exec, propertyNameArray, enumerationMode);</span>
285 }
286 
<a name="32" id="anc32"></a><span class="line-modified">287 bool ErrorInstance::defineOwnProperty(JSObject* object, ExecState* exec, PropertyName propertyName, const PropertyDescriptor&amp; descriptor, bool shouldThrow)</span>
288 {
<a name="33" id="anc33"></a><span class="line-modified">289     VM&amp; vm = exec-&gt;vm();</span>
290     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(object);
291     thisObject-&gt;materializeErrorInfoIfNeeded(vm, propertyName);
<a name="34" id="anc34"></a><span class="line-modified">292     return Base::defineOwnProperty(thisObject, exec, propertyName, descriptor, shouldThrow);</span>
293 }
294 
<a name="35" id="anc35"></a><span class="line-modified">295 bool ErrorInstance::put(JSCell* cell, ExecState* exec, PropertyName propertyName, JSValue value, PutPropertySlot&amp; slot)</span>
296 {
<a name="36" id="anc36"></a><span class="line-modified">297     VM&amp; vm = exec-&gt;vm();</span>
298     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(cell);
299     bool materializedProperties = thisObject-&gt;materializeErrorInfoIfNeeded(vm, propertyName);
300     if (materializedProperties)
301         slot.disableCaching();
<a name="37" id="anc37"></a><span class="line-modified">302     return Base::put(thisObject, exec, propertyName, value, slot);</span>
303 }
304 
<a name="38" id="anc38"></a><span class="line-modified">305 bool ErrorInstance::deleteProperty(JSCell* cell, ExecState* exec, PropertyName propertyName)</span>
306 {
<a name="39" id="anc39"></a><span class="line-modified">307     VM&amp; vm = exec-&gt;vm();</span>
308     ErrorInstance* thisObject = jsCast&lt;ErrorInstance*&gt;(cell);
309     thisObject-&gt;materializeErrorInfoIfNeeded(vm, propertyName);
<a name="40" id="anc40"></a><span class="line-modified">310     return Base::deleteProperty(thisObject, exec, propertyName);</span>
311 }
312 
313 } // namespace JSC
<a name="41" id="anc41"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="41" type="hidden" />
</body>
</html>
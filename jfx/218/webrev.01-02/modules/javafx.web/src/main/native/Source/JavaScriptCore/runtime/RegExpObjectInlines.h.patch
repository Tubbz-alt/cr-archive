diff a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpObjectInlines.h b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpObjectInlines.h
--- a/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpObjectInlines.h
+++ b/modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/RegExpObjectInlines.h
@@ -32,50 +32,50 @@
 #include "RegExpObject.h"
 
 namespace JSC {
 
 ALWAYS_INLINE unsigned getRegExpObjectLastIndexAsUnsigned(
-    ExecState* exec, RegExpObject* regExpObject, const String& input)
+    JSGlobalObject* globalObject, RegExpObject* regExpObject, const String& input)
 {
-    VM& vm = exec->vm();
+    VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
     JSValue jsLastIndex = regExpObject->getLastIndex();
     unsigned lastIndex;
     if (LIKELY(jsLastIndex.isUInt32())) {
         lastIndex = jsLastIndex.asUInt32();
         if (lastIndex > input.length()) {
             scope.release();
-            regExpObject->setLastIndex(exec, 0);
+            regExpObject->setLastIndex(globalObject, 0);
             return UINT_MAX;
         }
     } else {
-        double doubleLastIndex = jsLastIndex.toInteger(exec);
+        double doubleLastIndex = jsLastIndex.toInteger(globalObject);
         RETURN_IF_EXCEPTION(scope, UINT_MAX);
         if (doubleLastIndex < 0 || doubleLastIndex > input.length()) {
             scope.release();
-            regExpObject->setLastIndex(exec, 0);
+            regExpObject->setLastIndex(globalObject, 0);
             return UINT_MAX;
         }
         lastIndex = static_cast<unsigned>(doubleLastIndex);
     }
     return lastIndex;
 }
 
-inline JSValue RegExpObject::execInline(ExecState* exec, JSGlobalObject* globalObject, JSString* string)
+inline JSValue RegExpObject::execInline(JSGlobalObject* globalObject, JSString* string)
 {
     VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     RegExp* regExp = this->regExp();
-    String input = string->value(exec);
+    String input = string->value(globalObject);
     RETURN_IF_EXCEPTION(scope, { });
 
     bool globalOrSticky = regExp->globalOrSticky();
 
     unsigned lastIndex;
     if (globalOrSticky) {
-        lastIndex = getRegExpObjectLastIndexAsUnsigned(exec, this, input);
+        lastIndex = getRegExpObjectLastIndexAsUnsigned(globalObject, this, input);
         EXCEPTION_ASSERT(!scope.exception() || lastIndex == UINT_MAX);
         if (lastIndex == UINT_MAX)
             return jsNull();
     } else
         lastIndex = 0;
@@ -85,46 +85,46 @@
         createRegExpMatchesArray(vm, globalObject, string, input, regExp, lastIndex, result);
     if (!array) {
         RETURN_IF_EXCEPTION(scope, { });
         scope.release();
         if (globalOrSticky)
-            setLastIndex(exec, 0);
+            setLastIndex(globalObject, 0);
         return jsNull();
     }
 
     if (globalOrSticky)
-        setLastIndex(exec, result.end);
+        setLastIndex(globalObject, result.end);
     RETURN_IF_EXCEPTION(scope, { });
     globalObject->regExpGlobalData().recordMatch(vm, globalObject, regExp, string, result);
     return array;
 }
 
 // Shared implementation used by test and exec.
 inline MatchResult RegExpObject::matchInline(
-    ExecState* exec, JSGlobalObject* globalObject, JSString* string)
+    JSGlobalObject* globalObject, JSString* string)
 {
     VM& vm = globalObject->vm();
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     RegExp* regExp = this->regExp();
-    String input = string->value(exec);
+    String input = string->value(globalObject);
     RETURN_IF_EXCEPTION(scope, { });
 
     if (!regExp->global() && !regExp->sticky()) {
         scope.release();
         return globalObject->regExpGlobalData().performMatch(vm, globalObject, regExp, string, input, 0);
     }
 
-    unsigned lastIndex = getRegExpObjectLastIndexAsUnsigned(exec, this, input);
+    unsigned lastIndex = getRegExpObjectLastIndexAsUnsigned(globalObject, this, input);
     EXCEPTION_ASSERT(!scope.exception() || (lastIndex == UINT_MAX));
     if (lastIndex == UINT_MAX)
         return MatchResult::failed();
 
     MatchResult result = globalObject->regExpGlobalData().performMatch(vm, globalObject, regExp, string, input, lastIndex);
     RETURN_IF_EXCEPTION(scope, { });
     scope.release();
-    setLastIndex(exec, result.end);
+    setLastIndex(globalObject, result.end);
     return result;
 }
 
 inline unsigned advanceStringUnicode(String s, unsigned length, unsigned currentIndex)
 {
@@ -141,30 +141,30 @@
 
     return currentIndex + 2;
 }
 
 template<typename FixEndFunc>
-JSValue collectMatches(VM& vm, ExecState* exec, JSString* string, const String& s, JSGlobalObject* globalObject, RegExp* regExp, const FixEndFunc& fixEnd)
+JSValue collectMatches(VM& vm, JSGlobalObject* globalObject, JSString* string, const String& s, RegExp* regExp, const FixEndFunc& fixEnd)
 {
     auto scope = DECLARE_THROW_SCOPE(vm);
 
     MatchResult result = globalObject->regExpGlobalData().performMatch(vm, globalObject, regExp, string, s, 0);
     RETURN_IF_EXCEPTION(scope, { });
     if (!result)
         return jsNull();
 
     static unsigned maxSizeForDirectPath = 100000;
 
-    JSArray* array = constructEmptyArray(exec, nullptr);
+    JSArray* array = constructEmptyArray(globalObject, nullptr);
     RETURN_IF_EXCEPTION(scope, { });
 
     bool hasException = false;
     unsigned arrayIndex = 0;
     auto iterate = [&] () {
         size_t end = result.end;
         size_t length = end - result.start;
-        array->putDirectIndex(exec, arrayIndex++, jsSubstringOfResolved(vm, string, result.start, length));
+        array->putDirectIndex(globalObject, arrayIndex++, jsSubstringOfResolved(vm, string, result.start, length));
         if (UNLIKELY(scope.exception())) {
             hasException = true;
             return;
         }
         if (!length)
@@ -181,11 +181,11 @@
             // First do a throw-away match to see how many matches we'll get.
             unsigned matchCount = 0;
             MatchResult savedResult = result;
             do {
                 if (array->length() + matchCount > MAX_STORAGE_VECTOR_LENGTH) {
-                    throwOutOfMemoryError(exec, scope);
+                    throwOutOfMemoryError(globalObject, scope);
                     return jsUndefined();
                 }
 
                 size_t end = result.end;
                 matchCount++;

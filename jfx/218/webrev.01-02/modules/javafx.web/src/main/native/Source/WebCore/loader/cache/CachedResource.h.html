<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/loader/cache/CachedResource.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2     Copyright (C) 1998 Lars Knoll (knoll@mpi-hd.mpg.de)
  3     Copyright (C) 2001 Dirk Mueller &lt;mueller@kde.org&gt;
  4     Copyright (C) 2006 Samuel Weinig (sam.weinig@gmail.com)
  5     Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Apple Inc. All rights reserved.
  6 
  7     This library is free software; you can redistribute it and/or
  8     modify it under the terms of the GNU Library General Public
  9     License as published by the Free Software Foundation; either
 10     version 2 of the License, or (at your option) any later version.
 11 
 12     This library is distributed in the hope that it will be useful,
 13     but WITHOUT ANY WARRANTY; without even the implied warranty of
 14     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 15     Library General Public License for more details.
 16 
 17     You should have received a copy of the GNU Library General Public License
 18     along with this library; see the file COPYING.LIB.  If not, write to
 19     the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 20     Boston, MA 02110-1301, USA.
 21 */
 22 
 23 #pragma once
 24 
 25 #include &quot;CachePolicy.h&quot;
 26 #include &quot;CacheValidation.h&quot;
 27 #include &quot;FrameLoaderTypes.h&quot;
 28 #include &quot;ResourceError.h&quot;
 29 #include &quot;ResourceLoadPriority.h&quot;
 30 #include &quot;ResourceLoaderOptions.h&quot;
 31 #include &quot;ResourceRequest.h&quot;
 32 #include &quot;ResourceResponse.h&quot;
 33 #include &quot;Timer.h&quot;
 34 #include &lt;pal/SessionID.h&gt;
 35 #include &lt;time.h&gt;
 36 #include &lt;wtf/HashCountedSet.h&gt;
 37 #include &lt;wtf/HashSet.h&gt;
 38 #include &lt;wtf/TypeCasts.h&gt;
 39 #include &lt;wtf/Vector.h&gt;
 40 #include &lt;wtf/text/WTFString.h&gt;
 41 
 42 namespace WebCore {
 43 
 44 class CachedResourceClient;
 45 class CachedResourceHandleBase;
 46 class CachedResourceLoader;
 47 class CachedResourceRequest;
 48 class CookieJar;
 49 class LoadTiming;
 50 class MemoryCache;
 51 class SecurityOrigin;
 52 class SharedBuffer;
 53 class SubresourceLoader;
 54 class TextResourceDecoder;
 55 
 56 // A resource that is held in the cache. Classes who want to use this object should derive
 57 // from CachedResourceClient, to get the function calls in case the requested data has arrived.
 58 // This class also does the actual communication with the loader to obtain the resource from the network.
 59 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(CachedResource);
 60 class CachedResource {
 61     WTF_MAKE_NONCOPYABLE(CachedResource);
 62     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(CachedResource);
 63     friend class MemoryCache;
 64 
 65 public:
 66     enum class Type : uint8_t {
 67         MainResource,
 68         ImageResource,
 69         CSSStyleSheet,
 70         Script,
 71         FontResource,
 72 #if ENABLE(SVG_FONTS)
 73         SVGFontResource,
 74 #endif
 75         MediaResource,
 76         RawResource,
 77         Icon,
 78         Beacon,
 79         Ping,
 80 #if ENABLE(XSLT)
 81         XSLStyleSheet,
 82 #endif
 83         LinkPrefetch,
 84 #if ENABLE(VIDEO_TRACK)
 85         TextTrackResource,
 86 #endif
 87 #if ENABLE(APPLICATION_MANIFEST)
 88         ApplicationManifest,
 89 #endif
 90         SVGDocumentResource,
 91         LastType = SVGDocumentResource,
 92     };
 93     static constexpr unsigned bitWidthOfType = 5;
 94     static_assert(static_cast&lt;unsigned&gt;(Type::LastType) &lt;= ((1U &lt;&lt; bitWidthOfType) - 1));
 95 
 96     enum Status : uint8_t {
 97         Unknown,      // let cache decide what to do with it
 98         Pending,      // only partially loaded
 99         Cached,       // regular case
100         LoadError,
101         DecodeError
102     };
103     static constexpr unsigned bitWidthOfStatus = 3;
104     static_assert(static_cast&lt;unsigned&gt;(DecodeError) &lt;= ((1ULL &lt;&lt; bitWidthOfStatus) - 1));
105 
106     CachedResource(CachedResourceRequest&amp;&amp;, Type, const PAL::SessionID&amp;, const CookieJar*);
107     virtual ~CachedResource();
108 
109     virtual void load(CachedResourceLoader&amp;);
110 
111     virtual void setEncoding(const String&amp;) { }
112     virtual String encoding() const { return String(); }
113     virtual const TextResourceDecoder* textResourceDecoder() const { return nullptr; }
114     virtual void updateBuffer(SharedBuffer&amp;);
115     virtual void updateData(const char* data, unsigned length);
116     virtual void finishLoading(SharedBuffer*);
117     virtual void error(CachedResource::Status);
118 
119     void setResourceError(const ResourceError&amp; error) { m_error = error; }
120     const ResourceError&amp; resourceError() const { return m_error; }
121 
122     virtual bool shouldIgnoreHTTPStatusCodeErrors() const { return false; }
123 
124     const ResourceRequest&amp; resourceRequest() const { return m_resourceRequest; }
125     const URL&amp; url() const { return m_resourceRequest.url();}
126     const String&amp; cachePartition() const { return m_resourceRequest.cachePartition(); }
127     PAL::SessionID sessionID() const { return m_sessionID; }
128     const CookieJar* cookieJar() const { return m_cookieJar.get(); }
129     Type type() const { return m_type; }
130     String mimeType() const { return m_response.mimeType(); }
131     long long expectedContentLength() const { return m_response.expectedContentLength(); }
132 
133     static bool shouldUsePingLoad(Type type) { return type == Type::Beacon || type == Type::Ping; }
134 
135     ResourceLoadPriority loadPriority() const { return m_loadPriority; }
136     void setLoadPriority(const Optional&lt;ResourceLoadPriority&gt;&amp;);
137 
138     WEBCORE_EXPORT void addClient(CachedResourceClient&amp;);
139     WEBCORE_EXPORT void removeClient(CachedResourceClient&amp;);
140     bool hasClients() const { return !m_clients.isEmpty() || !m_clientsAwaitingCallback.isEmpty(); }
141     bool hasClient(CachedResourceClient&amp; client) { return m_clients.contains(&amp;client) || m_clientsAwaitingCallback.contains(&amp;client); }
142     bool deleteIfPossible();
143 
144     enum class PreloadResult : uint8_t {
145         PreloadNotReferenced,
146         PreloadReferenced,
147         PreloadReferencedWhileLoading,
148         PreloadReferencedWhileComplete
149     };
150     static constexpr unsigned bitWidthOfPreloadResult = 2;
151 
152     PreloadResult preloadResult() const { return static_cast&lt;PreloadResult&gt;(m_preloadResult); }
153 
154     virtual void didAddClient(CachedResourceClient&amp;);
155     virtual void didRemoveClient(CachedResourceClient&amp;) { }
156     virtual void allClientsRemoved();
157     void destroyDecodedDataIfNeeded();
158 
159     unsigned numberOfClients() const { return m_clients.size(); }
160 
161     Status status() const { return static_cast&lt;Status&gt;(m_status); }
162     void setStatus(Status status)
163     {
164         m_status = status;
165         ASSERT(this-&gt;status() == status);
166     }
167 
168     unsigned size() const { return encodedSize() + decodedSize() + overheadSize(); }
169     unsigned encodedSize() const { return m_encodedSize; }
170     unsigned decodedSize() const { return m_decodedSize; }
171     unsigned overheadSize() const;
172 
173     bool isLoaded() const { return !m_loading; } // FIXME. Method name is inaccurate. Loading might not have started yet.
174 
175     bool isLoading() const { return m_loading; }
176     void setLoading(bool b) { m_loading = b; }
177     virtual bool stillNeedsLoad() const { return false; }
178 
179     SubresourceLoader* loader() { return m_loader.get(); }
180 
181     bool isImage() const { return type() == Type::ImageResource; }
182     // FIXME: CachedRawResource could be a main resource, an audio/video resource, or a raw XHR/icon resource.
183     bool isMainOrMediaOrIconOrRawResource() const { return type() == Type::MainResource || type() == Type::MediaResource || type() == Type::Icon || type() == Type::RawResource || type() == Type::Beacon || type() == Type::Ping; }
184 
185     // Whether this request should impact request counting and delay window.onload.
186     bool ignoreForRequestCount() const
187     {
188         return m_ignoreForRequestCount
189             || type() == Type::MainResource
190             || type() == Type::LinkPrefetch
191             || type() == Type::Beacon
192             || type() == Type::Ping
193             || type() == Type::Icon
194             || type() == Type::RawResource;
195     }
196 
197     void setIgnoreForRequestCount(bool ignoreForRequestCount) { m_ignoreForRequestCount = ignoreForRequestCount; }
198 
199     unsigned accessCount() const { return m_accessCount; }
200     void increaseAccessCount() { m_accessCount++; }
201 
202     // Computes the status of an object after loading.
203     // Updates the expire date on the cache entry file
204     void finish();
205 
206     // Called by the cache if the object has been removed from the cache
207     // while still being referenced. This means the object should delete itself
208     // if the number of clients observing it ever drops to 0.
209     // The resource can be brought back to cache after successful revalidation.
210     void setInCache(bool inCache) { m_inCache = inCache; }
211     bool inCache() const { return m_inCache; }
212 
213     void clearLoader();
214 
215     SharedBuffer* resourceBuffer() const { return m_data.get(); }
216 
217     virtual void redirectReceived(ResourceRequest&amp;&amp;, const ResourceResponse&amp;, CompletionHandler&lt;void(ResourceRequest&amp;&amp;)&gt;&amp;&amp;);
218     virtual void responseReceived(const ResourceResponse&amp;);
219     virtual bool shouldCacheResponse(const ResourceResponse&amp;) { return true; }
220     void setResponse(const ResourceResponse&amp;);
221     const ResourceResponse&amp; response() const { return m_response; }
222 
223     void setCrossOrigin();
224     bool isCrossOrigin() const;
225     bool isCORSSameOrigin() const;
226     ResourceResponse::Tainting responseTainting() const { return m_responseTainting; }
227 
228     void loadFrom(const CachedResource&amp;);
229 
230     SecurityOrigin* origin() const { return m_origin.get(); }
231     AtomString initiatorName() const { return m_initiatorName; }
232 
233     bool canDelete() const { return !hasClients() &amp;&amp; !m_loader &amp;&amp; !m_preloadCount &amp;&amp; !m_handleCount &amp;&amp; !m_resourceToRevalidate &amp;&amp; !m_proxyResource; }
234     bool hasOneHandle() const { return m_handleCount == 1; }
235 
236     bool isExpired() const;
237 
238     void cancelLoad();
239     bool wasCanceled() const { return m_error.isCancellation(); }
240     bool errorOccurred() const { return m_status == LoadError || m_status == DecodeError; }
241     bool loadFailedOrCanceled() const { return !m_error.isNull(); }
242 
243     bool shouldSendResourceLoadCallbacks() const { return m_options.sendLoadCallbacks == SendCallbackPolicy::SendCallbacks; }
244     DataBufferingPolicy dataBufferingPolicy() const { return m_options.dataBufferingPolicy; }
245 
246     bool allowsCaching() const { return m_options.cachingPolicy == CachingPolicy::AllowCaching; }
247     const ResourceLoaderOptions&amp; options() const { return m_options; }
248 
249     virtual void destroyDecodedData() { }
250 
251     bool isPreloaded() const { return m_preloadCount; }
252     void increasePreloadCount() { ++m_preloadCount; }
253     void decreasePreloadCount() { ASSERT(m_preloadCount); --m_preloadCount; }
254     bool isLinkPreload() { return m_isLinkPreload; }
255     void setLinkPreload() { m_isLinkPreload = true; }
256     bool hasUnknownEncoding() { return m_hasUnknownEncoding; }
257     void setHasUnknownEncoding(bool hasUnknownEncoding) { m_hasUnknownEncoding = hasUnknownEncoding; }
258 
259     void registerHandle(CachedResourceHandleBase*);
260     WEBCORE_EXPORT void unregisterHandle(CachedResourceHandleBase*);
261 
262     bool canUseCacheValidator() const;
263 
264     enum class RevalidationDecision { No, YesDueToCachePolicy, YesDueToNoStore, YesDueToNoCache, YesDueToExpired };
265     virtual RevalidationDecision makeRevalidationDecision(CachePolicy) const;
266     bool redirectChainAllowsReuse(ReuseExpiredRedirectionOrNot) const;
267     bool hasRedirections() const { return m_redirectChainCacheStatus.status != RedirectChainCacheStatus::Status::NoRedirection;  }
268 
269     bool varyHeaderValuesMatch(const ResourceRequest&amp;);
270 
271     bool isCacheValidator() const { return m_resourceToRevalidate; }
272     CachedResource* resourceToRevalidate() const { return m_resourceToRevalidate; }
273 
274     // HTTP revalidation support methods for CachedResourceLoader.
275     void setResourceToRevalidate(CachedResource*);
276     virtual void switchClientsToRevalidatedResource();
277     void clearResourceToRevalidate();
278     void updateResponseAfterRevalidation(const ResourceResponse&amp; validatingResponse);
279     bool validationInProgress() const { return m_proxyResource; }
280     bool validationCompleting() const { return m_proxyResource &amp;&amp; m_proxyResource-&gt;m_switchingClientsToRevalidatedResource; }
281 
282     virtual void didSendData(unsigned long long /* bytesSent */, unsigned long long /* totalBytesToBeSent */) { }
283 
284 #if USE(FOUNDATION) || USE(SOUP)
285     WEBCORE_EXPORT void tryReplaceEncodedData(SharedBuffer&amp;);
286 #endif
287 
288     unsigned long identifierForLoadWithoutResourceLoader() const { return m_identifierForLoadWithoutResourceLoader; }
289     static ResourceLoadPriority defaultPriorityForResourceType(Type);
290 
291     void setOriginalRequest(std::unique_ptr&lt;ResourceRequest&gt;&amp;&amp; originalRequest) { m_originalRequest = WTFMove(originalRequest); }
292     const std::unique_ptr&lt;ResourceRequest&gt;&amp; originalRequest() const { return m_originalRequest; }
293 
294 #if USE(QUICK_LOOK)
295     virtual void previewResponseReceived(const ResourceResponse&amp;);
296 #endif
297 
298 protected:
299     // CachedResource constructor that may be used when the CachedResource can already be filled with response data.
300     CachedResource(const URL&amp;, Type, const PAL::SessionID&amp;, const CookieJar*);
301 
302     void setEncodedSize(unsigned);
303     void setDecodedSize(unsigned);
304     void didAccessDecodedData(MonotonicTime timeStamp);
305 
306     virtual void didReplaceSharedBufferContents() { }
307 
308     virtual void setBodyDataFrom(const CachedResource&amp;);
309 
310 private:
311     class Callback;
312 
313     bool addClientToSet(CachedResourceClient&amp;);
314 
315     void decodedDataDeletionTimerFired();
316 
317     virtual void checkNotify();
318     virtual bool mayTryReplaceEncodedData() const { return false; }
319 
320     Seconds freshnessLifetime(const ResourceResponse&amp;) const;
321 
322     void addAdditionalRequestHeaders(CachedResourceLoader&amp;);
323     void failBeforeStarting();
324 
325 protected:
326     ResourceLoaderOptions m_options;
327     ResourceRequest m_resourceRequest;
328     ResourceResponse m_response;
329 
330     DeferrableOneShotTimer m_decodedDataDeletionTimer;
331 
332     // FIXME: Make the rest of these data members private and use functions in derived classes instead.
333     HashCountedSet&lt;CachedResourceClient*&gt; m_clients;
334     std::unique_ptr&lt;ResourceRequest&gt; m_originalRequest; // Needed by Ping loads.
335     RefPtr&lt;SubresourceLoader&gt; m_loader;
336     RefPtr&lt;SharedBuffer&gt; m_data;
337 
338 private:
339     MonotonicTime m_lastDecodedAccessTime; // Used as a &quot;thrash guard&quot; in the cache
340     PAL::SessionID m_sessionID;
341     RefPtr&lt;const CookieJar&gt; m_cookieJar;
342     WallTime m_responseTimestamp;
343     unsigned long m_identifierForLoadWithoutResourceLoader { 0 };
344 
345     HashMap&lt;CachedResourceClient*, std::unique_ptr&lt;Callback&gt;&gt; m_clientsAwaitingCallback;
346 
347     // These handles will need to be updated to point to the m_resourceToRevalidate in case we get 304 response.
348     HashSet&lt;CachedResourceHandleBase*&gt; m_handlesToRevalidate;
349 
350     Vector&lt;std::pair&lt;String, String&gt;&gt; m_varyingHeaderValues;
351 
352     // If this field is non-null we are using the resource as a proxy for checking whether an existing resource is still up to date
353     // using HTTP If-Modified-Since/If-None-Match headers. If the response is 304 all clients of this resource are moved
354     // to to be clients of m_resourceToRevalidate and the resource is deleted. If not, the field is zeroed and this
355     // resources becomes normal resource load.
356     CachedResource* m_resourceToRevalidate { nullptr };
357 
358     // If this field is non-null, the resource has a proxy for checking whether it is still up to date (see m_resourceToRevalidate).
359     CachedResource* m_proxyResource { nullptr };
360 
361     String m_fragmentIdentifierForRequest;
362 
363     ResourceError m_error;
364     RefPtr&lt;SecurityOrigin&gt; m_origin;
365     AtomString m_initiatorName;
366 
367     unsigned m_encodedSize { 0 };
368     unsigned m_decodedSize { 0 };
369     unsigned m_accessCount { 0 };
370     unsigned m_handleCount { 0 };
371     unsigned m_preloadCount { 0 };
372 
373     RedirectChainCacheStatus m_redirectChainCacheStatus;
374 
375     Type m_type : bitWidthOfType;
376 
377     PreloadResult m_preloadResult : bitWidthOfPreloadResult;
378     ResourceResponse::Tainting m_responseTainting : ResourceResponse::bitWidthOfTainting;
379     ResourceLoadPriority m_loadPriority : bitWidthOfResourceLoadPriority;
380 
381     Status m_status : bitWidthOfStatus;
382     bool m_requestedFromNetworkingLayer : 1;
383     bool m_inCache : 1;
384     bool m_loading : 1;
385     bool m_isLinkPreload : 1;
386     bool m_hasUnknownEncoding : 1;
387     bool m_switchingClientsToRevalidatedResource : 1;
388     bool m_ignoreForRequestCount : 1;
389 
390 #if ASSERT_ENABLED
391     bool m_deleted { false };
392     unsigned m_lruIndex { 0 };
393 #endif
394 };
395 
396 class CachedResource::Callback {
397     WTF_MAKE_FAST_ALLOCATED;
398 public:
399     Callback(CachedResource&amp;, CachedResourceClient&amp;);
400 
401     void cancel();
402 
403 private:
404     void timerFired();
405 
406     CachedResource&amp; m_resource;
407     CachedResourceClient&amp; m_client;
408     Timer m_timer;
409 };
410 
411 } // namespace WebCore
412 
413 #define SPECIALIZE_TYPE_TRAITS_CACHED_RESOURCE(ToClassName, CachedResourceType) \
414 SPECIALIZE_TYPE_TRAITS_BEGIN(WebCore::ToClassName) \
415     static bool isType(const WebCore::CachedResource&amp; resource) { return resource.type() == WebCore::CachedResourceType; } \
416 SPECIALIZE_TYPE_TRAITS_END()
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/FastMalloc.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  *  Copyright (C) 2005-2018 Apple Inc. All rights reserved.
  3  *
  4  *  This library is free software; you can redistribute it and/or
  5  *  modify it under the terms of the GNU Library General Public
  6  *  License as published by the Free Software Foundation; either
  7  *  version 2 of the License, or (at your option) any later version.
  8  *
  9  *  This library is distributed in the hope that it will be useful,
 10  *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 11  *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 12  *  Library General Public License for more details.
 13  *
 14  *  You should have received a copy of the GNU Library General Public License
 15  *  along with this library; see the file COPYING.LIB.  If not, write to
 16  *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 17  *  Boston, MA 02110-1301, USA.
 18  *
 19  */
 20 
 21 #pragma once
 22 
 23 #include &lt;new&gt;
 24 #include &lt;stdlib.h&gt;
 25 #include &lt;wtf/DebugHeap.h&gt;
 26 #include &lt;wtf/StdLibExtras.h&gt;
 27 
 28 namespace WTF {
 29 
 30 #if !defined(NDEBUG)
 31 WTF_EXPORT_PRIVATE void fastSetMaxSingleAllocationSize(size_t);
 32 #endif
 33 
 34 class TryMallocReturnValue {
 35 public:
 36     TryMallocReturnValue(void*);
 37     TryMallocReturnValue(TryMallocReturnValue&amp;&amp;);
 38     ~TryMallocReturnValue();
 39     template&lt;typename T&gt; bool getValue(T*&amp;) WARN_UNUSED_RETURN;
 40 private:
 41     void operator=(TryMallocReturnValue&amp;&amp;) = delete;
 42     mutable void* m_data;
 43 };
 44 
 45 WTF_EXPORT_PRIVATE bool isFastMallocEnabled();
 46 
 47 // These functions call CRASH() if an allocation fails.
 48 WTF_EXPORT_PRIVATE void* fastMalloc(size_t) RETURNS_NONNULL;
 49 WTF_EXPORT_PRIVATE void* fastZeroedMalloc(size_t) RETURNS_NONNULL;
 50 WTF_EXPORT_PRIVATE void* fastCalloc(size_t numElements, size_t elementSize) RETURNS_NONNULL;
 51 WTF_EXPORT_PRIVATE void* fastRealloc(void*, size_t) RETURNS_NONNULL;
 52 WTF_EXPORT_PRIVATE char* fastStrDup(const char*) RETURNS_NONNULL;
 53 
 54 WTF_EXPORT_PRIVATE TryMallocReturnValue tryFastMalloc(size_t);
 55 WTF_EXPORT_PRIVATE TryMallocReturnValue tryFastZeroedMalloc(size_t);
 56 WTF_EXPORT_PRIVATE TryMallocReturnValue tryFastCalloc(size_t numElements, size_t elementSize);
 57 WTF_EXPORT_PRIVATE TryMallocReturnValue tryFastRealloc(void*, size_t);
 58 
 59 WTF_EXPORT_PRIVATE void fastFree(void*);
 60 
 61 // Allocations from fastAlignedMalloc() must be freed using fastAlignedFree().
 62 WTF_EXPORT_PRIVATE void* fastAlignedMalloc(size_t alignment, size_t) RETURNS_NONNULL;
 63 WTF_EXPORT_PRIVATE void* tryFastAlignedMalloc(size_t alignment, size_t);
 64 WTF_EXPORT_PRIVATE void fastAlignedFree(void*);
 65 
 66 WTF_EXPORT_PRIVATE size_t fastMallocSize(const void*);
 67 
 68 // FIXME: This is non-helpful; fastMallocGoodSize will be removed soon.
 69 WTF_EXPORT_PRIVATE size_t fastMallocGoodSize(size_t);
 70 
 71 WTF_EXPORT_PRIVATE void releaseFastMallocFreeMemory();
 72 WTF_EXPORT_PRIVATE void releaseFastMallocFreeMemoryForThisThread();
 73 
 74 WTF_EXPORT_PRIVATE void fastCommitAlignedMemory(void*, size_t);
 75 WTF_EXPORT_PRIVATE void fastDecommitAlignedMemory(void*, size_t);
 76 
 77 WTF_EXPORT_PRIVATE void fastEnableMiniMode();
 78 
 79 struct FastMallocStatistics {
 80     size_t reservedVMBytes;
 81     size_t committedVMBytes;
 82     size_t freeListBytes;
 83 };
 84 WTF_EXPORT_PRIVATE FastMallocStatistics fastMallocStatistics();
 85 
 86 WTF_EXPORT_PRIVATE void fastMallocDumpMallocStats();
 87 
 88 // This defines a type which holds an unsigned integer and is the same
 89 // size as the minimally aligned memory allocation.
 90 typedef unsigned long long AllocAlignmentInteger;
 91 
 92 inline TryMallocReturnValue::TryMallocReturnValue(void* data)
 93     : m_data(data)
 94 {
 95 }
 96 
 97 inline TryMallocReturnValue::TryMallocReturnValue(TryMallocReturnValue&amp;&amp; source)
 98     : m_data(source.m_data)
 99 {
100     source.m_data = nullptr;
101 }
102 
103 inline TryMallocReturnValue::~TryMallocReturnValue()
104 {
105     ASSERT(!m_data);
106 }
107 
108 template&lt;typename T&gt; inline bool TryMallocReturnValue::getValue(T*&amp; data)
109 {
110     data = static_cast&lt;T*&gt;(m_data);
111     m_data = nullptr;
112     return data;
113 }
114 
115 // C++ STL allocator implementation. You can integrate fastMalloc into STL containers.
116 // e.g. std::unordered_map&lt;Key, Value, std::hash&lt;Key&gt;, std::equal_to&lt;Key&gt;, FastAllocator&lt;std::pair&lt;const Key, Value&gt;&gt;&gt;.
117 template&lt;typename T&gt;
118 class FastAllocator {
119 public:
120     using value_type = T;
121 
122     FastAllocator() = default;
123 
124     template&lt;typename U&gt; FastAllocator(const FastAllocator&lt;U&gt;&amp;) { }
125 
126     T* allocate(size_t count)
127     {
128         return reinterpret_cast&lt;T*&gt;(fastMalloc(sizeof(T) * count));
129     }
130 
131     void deallocate(T* pointer, size_t)
132     {
133         fastFree(pointer);
134     }
135 
136 #if defined(__GLIBCXX__) &amp;&amp; (!defined(_GLIBCXX_RELEASE) || _GLIBCXX_RELEASE &lt; 6)
137     // This allocator also supports pre-C++11 STL allocator interface. This is a workaround for GCC &lt; 6, which std::list
138     // does not support C++11 allocator. Note that _GLIBCXX_RELEASE is only defined after GCC 7 release. So currently
139     // this workaround is enabled in GCC 6 too.
140     // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=55409
141 
142     using pointer = value_type*;
143     using const_pointer = typename std::pointer_traits&lt;pointer&gt;::template rebind&lt;value_type const&gt;;
144     using void_pointer = typename std::pointer_traits&lt;pointer&gt;::template rebind&lt;void&gt;;
145     using const_void_pointer = typename std::pointer_traits&lt;pointer&gt;::template rebind&lt;const void&gt;;
146 
147     using reference = T&amp;;
148     using const_reference = const T&amp;;
149 
150     using difference_type = typename std::pointer_traits&lt;pointer&gt;::difference_type;
151     using size_type = std::make_unsigned_t&lt;difference_type&gt;;
152 
153     template &lt;class U&gt; struct rebind {
154         using other = FastAllocator&lt;U&gt;;
155     };
156 
157     value_type* allocate(std::size_t count, const_void_pointer)
158     {
159         return allocate(count);
160     }
161 
162     template &lt;class U, class ...Args&gt;
163     void construct(U* p, Args&amp;&amp; ...args)
164     {
165         new (const_cast&lt;void*&gt;(static_cast&lt;const void*&gt;(p))) U(std::forward&lt;Args&gt;(args)...);
166     }
167 
168     template &lt;class U&gt;
169     void destroy(U* p)
170     {
171         p-&gt;~U();
172     }
173 
174     std::size_t max_size() const
175     {
176         return std::numeric_limits&lt;size_type&gt;::max();
177     }
178 
179     FastAllocator&lt;T&gt; select_on_container_copy_construction() const
180     {
181         return *this;
182     }
183 
184     using propagate_on_container_copy_assignment = std::false_type;
185     using propagate_on_container_move_assignment = std::false_type;
186     using propagate_on_container_swap = std::false_type;
187     using is_always_equal = std::is_empty&lt;FastAllocator&gt;;
188 #endif // defined(__GLIBCXX__) &amp;&amp; (!defined(_GLIBCXX_RELEASE) || _GLIBCXX_RELEASE &lt; 6)
189 };
190 
191 template&lt;typename T, typename U&gt; inline bool operator==(const FastAllocator&lt;T&gt;&amp;, const FastAllocator&lt;U&gt;&amp;) { return true; }
192 template&lt;typename T, typename U&gt; inline bool operator!=(const FastAllocator&lt;T&gt;&amp;, const FastAllocator&lt;U&gt;&amp;) { return false; }
193 
194 struct FastMalloc {
195     static void* malloc(size_t size) { return fastMalloc(size); }
196 
197     static void* tryMalloc(size_t size)
198     {
199         auto result = tryFastMalloc(size);
200         void* realResult;
201         if (result.getValue(realResult))
202             return realResult;
203         return nullptr;
204     }
205 
206     static void* zeroedMalloc(size_t size) { return fastZeroedMalloc(size); }
207 
208     static void* tryZeroedMalloc(size_t size)
209     {
210         auto result = tryFastZeroedMalloc(size);
211         void* realResult;
212         if (result.getValue(realResult))
213             return realResult;
214         return nullptr;
215     }
216 
217     static void* realloc(void* p, size_t size) { return fastRealloc(p, size); }
218 
219     static void* tryRealloc(void* p, size_t size)
220     {
221         auto result = tryFastRealloc(p, size);
222         void* realResult;
223         if (result.getValue(realResult))
224             return realResult;
225         return nullptr;
226     }
227 
228     static void free(void* p) { fastFree(p); }
229 };
230 
231 template&lt;typename T&gt;
232 struct FastFree {
233     static_assert(std::is_trivially_destructible&lt;T&gt;::value, &quot;&quot;);
234 
235     void operator()(T* pointer) const
236     {
237         fastFree(const_cast&lt;typename std::remove_cv&lt;T&gt;::type*&gt;(pointer));
238     }
239 };
240 
241 template&lt;typename T&gt;
242 struct FastFree&lt;T[]&gt; {
243     static_assert(std::is_trivially_destructible&lt;T&gt;::value, &quot;&quot;);
244 
245     void operator()(T* pointer) const
246     {
247         fastFree(const_cast&lt;typename std::remove_cv&lt;T&gt;::type*&gt;(pointer));
248     }
249 };
250 
251 } // namespace WTF
252 
253 #if !defined(NDEBUG)
254 using WTF::fastSetMaxSingleAllocationSize;
255 #endif
256 
257 using WTF::FastAllocator;
258 using WTF::FastMalloc;
259 using WTF::FastFree;
260 using WTF::isFastMallocEnabled;
261 using WTF::fastCalloc;
262 using WTF::fastFree;
263 using WTF::fastMalloc;
264 using WTF::fastMallocGoodSize;
265 using WTF::fastMallocSize;
266 using WTF::fastRealloc;
267 using WTF::fastStrDup;
268 using WTF::fastZeroedMalloc;
269 using WTF::tryFastAlignedMalloc;
270 using WTF::tryFastCalloc;
271 using WTF::tryFastMalloc;
272 using WTF::tryFastZeroedMalloc;
273 using WTF::fastAlignedMalloc;
274 using WTF::fastAlignedFree;
275 
276 #if COMPILER(GCC_COMPATIBLE) &amp;&amp; OS(DARWIN)
277 #define WTF_PRIVATE_INLINE __private_extern__ inline __attribute__((always_inline))
278 #elif COMPILER(GCC_COMPATIBLE)
279 #define WTF_PRIVATE_INLINE inline __attribute__((always_inline))
280 #elif COMPILER(MSVC)
281 #define WTF_PRIVATE_INLINE __forceinline
282 #else
283 #define WTF_PRIVATE_INLINE inline
284 #endif
285 
286 #define WTF_MAKE_FAST_ALLOCATED_IMPL \
287     void* operator new(size_t, void* p) { return p; } \
288     void* operator new[](size_t, void* p) { return p; } \
289     \
290     void* operator new(size_t size) \
291     { \
292         return ::WTF::fastMalloc(size); \
293     } \
294     \
295     void operator delete(void* p) \
296     { \
297         ::WTF::fastFree(p); \
298     } \
299     \
300     void* operator new[](size_t size) \
301     { \
302         return ::WTF::fastMalloc(size); \
303     } \
304     \
305     void operator delete[](void* p) \
306     { \
307         ::WTF::fastFree(p); \
308     } \
309     void* operator new(size_t, NotNullTag, void* location) \
310     { \
311         ASSERT(location); \
312         return location; \
313     } \
314     using webkitFastMalloced = int; \
315 
316 // FIXME: WTF_MAKE_FAST_ALLOCATED should take class name so that we can create malloc_zone per this macro.
317 // https://bugs.webkit.org/show_bug.cgi?id=205702
318 #define WTF_MAKE_FAST_ALLOCATED \
319 public: \
320     WTF_MAKE_FAST_ALLOCATED_IMPL \
321 private: \
322 using __thisIsHereToForceASemicolonAfterThisMacro = int
323 
324 #define WTF_MAKE_STRUCT_FAST_ALLOCATED \
325     WTF_MAKE_FAST_ALLOCATED_IMPL \
326 using __thisIsHereToForceASemicolonAfterThisMacro = int
327 
328 #if ENABLE(MALLOC_HEAP_BREAKDOWN)
329 
330 #define WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER_IMPL(classname) \
331     void* operator new(size_t, void* p) { return p; } \
332     void* operator new[](size_t, void* p) { return p; } \
333     \
334     void* operator new(size_t size) \
335     { \
336         return classname##Malloc::malloc(size); \
337     } \
338     \
339     void operator delete(void* p) \
340     { \
341         classname##Malloc::free(p); \
342     } \
343     \
344     void* operator new[](size_t size) \
345     { \
346         return classname##Malloc::malloc(size); \
347     } \
348     \
349     void operator delete[](void* p) \
350     { \
351         classname##Malloc::free(p); \
352     } \
353     void* operator new(size_t, NotNullTag, void* location) \
354     { \
355         ASSERT(location); \
356         return location; \
357     } \
358     using webkitFastMalloced = int; \
359 
360 #define WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(classname) \
361 public: \
362     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER_IMPL(classname) \
363 private: \
364     WTF_EXPORT_PRIVATE static WTF::DebugHeap&amp; debugHeap(const char*); \
365 using __thisIsHereToForceASemicolonAfterThisMacro = int
366 
367 #define WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(className) \
368 private: \
369     WTF_EXPORT_PRIVATE static WTF::DebugHeap&amp; debugHeap(const char*); \
370 public: \
371     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER_IMPL(className) \
372 using __thisIsHereToForceASemicolonAfterThisMacro = int
373 
374 #else
375 
376 #define WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER_IMPL(classname) \
377     WTF_MAKE_FAST_ALLOCATED_IMPL
378 
379 #define WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(classname) \
380 public: \
381     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER_IMPL(classname) \
382 private: \
383 using __thisIsHereToForceASemicolonAfterThisMacro = int
384 
385 #define WTF_MAKE_STRUCT_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER(className) \
386 public: \
387     WTF_MAKE_FAST_ALLOCATED_WITH_HEAP_IDENTIFIER_IMPL(className) \
388 using __thisIsHereToForceASemicolonAfterThisMacro = int
389 
390 #endif
    </pre>
  </body>
</html>
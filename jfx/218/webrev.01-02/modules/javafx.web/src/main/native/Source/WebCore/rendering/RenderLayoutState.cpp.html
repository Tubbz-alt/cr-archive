<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayoutState.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2007, 2013 Apple Inc.  All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;RenderLayoutState.h&quot;
 28 
 29 #include &quot;RenderFragmentedFlow.h&quot;
 30 #include &quot;RenderInline.h&quot;
 31 #include &quot;RenderLayer.h&quot;
 32 #include &quot;RenderMultiColumnFlow.h&quot;
 33 #include &quot;RenderView.h&quot;
 34 #include &lt;wtf/WeakPtr.h&gt;
 35 
 36 namespace WebCore {
 37 
 38 RenderLayoutState::RenderLayoutState(RenderElement&amp; renderer, IsPaginated isPaginated)
 39     : m_clipped(false)
 40     , m_isPaginated(isPaginated == IsPaginated::Yes)
 41     , m_pageLogicalHeightChanged(false)
 42 #if ASSERT_ENABLED
 43     , m_layoutDeltaXSaturated(false)
 44     , m_layoutDeltaYSaturated(false)
 45     , m_renderer(&amp;renderer)
 46 #endif
 47 {
 48     if (RenderElement* container = renderer.container()) {
 49         FloatPoint absContentPoint = container-&gt;localToAbsolute(FloatPoint(), UseTransforms);
 50         m_paintOffset = LayoutSize(absContentPoint.x(), absContentPoint.y());
 51 
 52         if (container-&gt;hasOverflowClip()) {
 53             m_clipped = true;
 54             auto&amp; containerBox = downcast&lt;RenderBox&gt;(*container);
 55             m_clipRect = LayoutRect(toLayoutPoint(m_paintOffset), containerBox.cachedSizeForOverflowClip());
 56             m_paintOffset -= toLayoutSize(containerBox.scrollPosition());
 57         }
 58     }
 59     if (m_isPaginated) {
 60         // This is just a flag for known page height (see RenderBlockFlow::checkForPaginationLogicalHeightChange).
 61         m_pageLogicalHeight = 1;
 62     }
 63 }
 64 
 65 RenderLayoutState::RenderLayoutState(const FrameViewLayoutContext::LayoutStateStack&amp; layoutStateStack, RenderBox&amp; renderer, const LayoutSize&amp; offset, LayoutUnit pageLogicalHeight, bool pageLogicalHeightChanged)
 66     : m_clipped(false)
 67     , m_isPaginated(false)
 68     , m_pageLogicalHeightChanged(false)
 69 #if ASSERT_ENABLED
 70     , m_layoutDeltaXSaturated(false)
 71     , m_layoutDeltaYSaturated(false)
 72     , m_renderer(&amp;renderer)
 73 #endif
 74 {
 75     if (!layoutStateStack.isEmpty()) {
 76         auto&amp; ancestor = *layoutStateStack.last().get();
 77         computeOffsets(ancestor, renderer, offset);
 78         computeClipRect(ancestor, renderer);
 79     }
 80     computePaginationInformation(layoutStateStack, renderer, pageLogicalHeight, pageLogicalHeightChanged);
 81 }
 82 
 83 void RenderLayoutState::computeOffsets(const RenderLayoutState&amp; ancestor, RenderBox&amp; renderer, LayoutSize offset)
 84 {
 85     bool fixed = renderer.isFixedPositioned();
 86     if (fixed) {
 87         FloatPoint fixedOffset = renderer.view().localToAbsolute(FloatPoint(), IsFixed);
 88         m_paintOffset = LayoutSize(fixedOffset.x(), fixedOffset.y()) + offset;
 89     } else
 90         m_paintOffset = ancestor.paintOffset() + offset;
 91 
 92     if (renderer.isOutOfFlowPositioned() &amp;&amp; !fixed) {
 93         if (auto* container = renderer.container()) {
 94             if (container-&gt;isInFlowPositioned() &amp;&amp; is&lt;RenderInline&gt;(*container))
 95                 m_paintOffset += downcast&lt;RenderInline&gt;(*container).offsetForInFlowPositionedInline(&amp;renderer);
 96         }
 97     }
 98 
 99     m_layoutOffset = m_paintOffset;
100 
101     if (renderer.isInFlowPositioned() &amp;&amp; renderer.hasLayer())
102         m_paintOffset += renderer.layer()-&gt;offsetForInFlowPosition();
103 
104     if (renderer.hasOverflowClip())
105         m_paintOffset -= toLayoutSize(renderer.scrollPosition());
106 
107     m_layoutDelta = ancestor.layoutDelta();
108 #if ASSERT_ENABLED
109     m_layoutDeltaXSaturated = ancestor.m_layoutDeltaXSaturated;
110     m_layoutDeltaYSaturated = ancestor.m_layoutDeltaYSaturated;
111 #endif
112 }
113 
114 void RenderLayoutState::computeClipRect(const RenderLayoutState&amp; ancestor, RenderBox&amp; renderer)
115 {
116     m_clipped = !renderer.isFixedPositioned() &amp;&amp; ancestor.isClipped();
117     if (m_clipped)
118         m_clipRect = ancestor.clipRect();
119     if (!renderer.hasOverflowClip())
120         return;
121 
122     auto paintOffsetForClipRect = toLayoutPoint(m_paintOffset + toLayoutSize(renderer.scrollPosition()));
123     LayoutRect clipRect(paintOffsetForClipRect + renderer.view().frameView().layoutContext().layoutDelta(), renderer.cachedSizeForOverflowClip());
124     if (m_clipped)
125         m_clipRect.intersect(clipRect);
126     else
127         m_clipRect = clipRect;
128     m_clipped = true;
129     // FIXME: &lt;http://bugs.webkit.org/show_bug.cgi?id=13443&gt; Apply control clip if present.
130 }
131 
132 void RenderLayoutState::computePaginationInformation(const FrameViewLayoutContext::LayoutStateStack&amp; layoutStateStack, RenderBox&amp; renderer, LayoutUnit pageLogicalHeight, bool pageLogicalHeightChanged)
133 {
134     auto* ancestor = layoutStateStack.isEmpty() ? nullptr : layoutStateStack.last().get();
135     // If we establish a new page height, then cache the offset to the top of the first page.
136     // We can compare this later on to figure out what part of the page we&#39;re actually on.
137     if (pageLogicalHeight || renderer.isRenderFragmentedFlow()) {
138         m_pageLogicalHeight = pageLogicalHeight;
139         bool isFlipped = renderer.style().isFlippedBlocksWritingMode();
140         m_pageOffset = LayoutSize(m_layoutOffset.width() + (!isFlipped ? renderer.borderLeft() + renderer.paddingLeft() : renderer.borderRight() + renderer.paddingRight()), m_layoutOffset.height() + (!isFlipped ? renderer.borderTop() + renderer.paddingTop() : renderer.borderBottom() + renderer.paddingBottom()));
141         m_pageLogicalHeightChanged = pageLogicalHeightChanged;
142         m_isPaginated = true;
143     } else if (ancestor) {
144         // If we don&#39;t establish a new page height, then propagate the old page height and offset down.
145         m_pageLogicalHeight = ancestor-&gt;pageLogicalHeight();
146         m_pageLogicalHeightChanged = ancestor-&gt;pageLogicalHeightChanged();
147         m_pageOffset = ancestor-&gt;pageOffset();
148 
149         // Disable pagination for objects we don&#39;t support. For now this includes overflow:scroll/auto, inline blocks and writing mode roots.
150         if (renderer.isUnsplittableForPagination()) {
151             m_pageLogicalHeight = 0;
152             m_isPaginated = false;
153         } else
154             m_isPaginated = m_pageLogicalHeight || renderer.enclosingFragmentedFlow();
155     }
156 
157     // Propagate line grid information.
158     if (ancestor)
159         propagateLineGridInfo(*ancestor, renderer);
160 
161     if (lineGrid() &amp;&amp; (lineGrid()-&gt;style().writingMode() == renderer.style().writingMode()) &amp;&amp; is&lt;RenderMultiColumnFlow&gt;(renderer))
162         computeLineGridPaginationOrigin(downcast&lt;RenderMultiColumnFlow&gt;(renderer));
163 
164     // If we have a new grid to track, then add it to our set.
165     if (renderer.style().lineGrid() != RenderStyle::initialLineGrid() &amp;&amp; is&lt;RenderBlockFlow&gt;(renderer))
166         establishLineGrid(layoutStateStack, downcast&lt;RenderBlockFlow&gt;(renderer));
167 }
168 
169 LayoutUnit RenderLayoutState::pageLogicalOffset(RenderBox* child, LayoutUnit childLogicalOffset) const
170 {
171     if (child-&gt;isHorizontalWritingMode())
172         return m_layoutOffset.height() + childLogicalOffset - m_pageOffset.height();
173     return m_layoutOffset.width() + childLogicalOffset - m_pageOffset.width();
174 }
175 
176 void RenderLayoutState::computeLineGridPaginationOrigin(const RenderMultiColumnFlow&amp; multicol)
177 {
178     if (!isPaginated() || !pageLogicalHeight())
179         return;
180 
181     if (!multicol.progressionIsInline())
182         return;
183     // We need to cache a line grid pagination origin so that we understand how to reset the line grid
184     // at the top of each column.
185     // Get the current line grid and offset.
186     ASSERT(m_lineGrid);
187     // Get the hypothetical line box used to establish the grid.
188     auto* lineGridBox = m_lineGrid-&gt;lineGridBox();
189     if (!lineGridBox)
190         return;
191 
192     // Now determine our position on the grid. Our baseline needs to be adjusted to the nearest baseline multiple
193     // as established by the line box.
194     // FIXME: Need to handle crazy line-box-contain values that cause the root line box to not be considered. I assume
195     // the grid should honor line-box-contain.
196     LayoutUnit gridLineHeight = lineGridBox-&gt;lineBottomWithLeading() - lineGridBox-&gt;lineTopWithLeading();
197     if (!gridLineHeight)
198         return;
199 
200     bool isHorizontalWritingMode = m_lineGrid-&gt;isHorizontalWritingMode();
201     LayoutUnit lineGridBlockOffset = isHorizontalWritingMode ? m_lineGridOffset.height() : m_lineGridOffset.width();
202     LayoutUnit firstLineTopWithLeading = lineGridBlockOffset + lineGridBox-&gt;lineTopWithLeading();
203     LayoutUnit pageLogicalTop = isHorizontalWritingMode ? m_pageOffset.height() : m_pageOffset.width();
204     if (pageLogicalTop &lt;= firstLineTopWithLeading)
205         return;
206 
207     // Shift to the next highest line grid multiple past the page logical top. Cache the delta
208     // between this new value and the page logical top as the pagination origin.
209     LayoutUnit remainder = roundToInt(pageLogicalTop - firstLineTopWithLeading) % roundToInt(gridLineHeight);
210     LayoutUnit paginationDelta = gridLineHeight - remainder;
211     if (isHorizontalWritingMode)
212         m_lineGridPaginationOrigin.setHeight(paginationDelta);
213     else
214         m_lineGridPaginationOrigin.setWidth(paginationDelta);
215 }
216 
217 void RenderLayoutState::propagateLineGridInfo(const RenderLayoutState&amp; ancestor, RenderBox&amp; renderer)
218 {
219     // Disable line grids for objects we don&#39;t support. For now this includes overflow:scroll/auto, inline blocks and
220     // writing mode roots.
221     if (renderer.isUnsplittableForPagination())
222         return;
223 
224     m_lineGrid = makeWeakPtr(ancestor.lineGrid());
225     m_lineGridOffset = ancestor.lineGridOffset();
226     m_lineGridPaginationOrigin = ancestor.lineGridPaginationOrigin();
227 }
228 
229 void RenderLayoutState::establishLineGrid(const FrameViewLayoutContext::LayoutStateStack&amp; layoutStateStack, RenderBlockFlow&amp; renderer)
230 {
231     // First check to see if this grid has been established already.
232     if (m_lineGrid) {
233         if (m_lineGrid-&gt;style().lineGrid() == renderer.style().lineGrid())
234             return;
235         auto* currentGrid = m_lineGrid.get();
236         for (int i = layoutStateStack.size() - 1; i &lt;= 0; --i) {
237             auto&amp; currentState = *layoutStateStack[i].get();
238             if (currentState.m_lineGrid == currentGrid)
239                 continue;
240             currentGrid = currentState.lineGrid();
241             if (!currentGrid)
242                 break;
243             if (currentGrid-&gt;style().lineGrid() == renderer.style().lineGrid()) {
244                 m_lineGrid = makeWeakPtr(currentGrid);
245                 m_lineGridOffset = currentState.m_lineGridOffset;
246                 return;
247             }
248         }
249     }
250 
251     // We didn&#39;t find an already-established grid with this identifier. Our render object establishes the grid.
252     m_lineGrid = makeWeakPtr(renderer);
253     m_lineGridOffset = m_layoutOffset;
254 }
255 
256 void RenderLayoutState::addLayoutDelta(LayoutSize delta)
257 {
258     m_layoutDelta += delta;
259 #if ASSERT_ENABLED
260     m_layoutDeltaXSaturated |= m_layoutDelta.width() == LayoutUnit::max() || m_layoutDelta.width() == LayoutUnit::min();
261     m_layoutDeltaYSaturated |= m_layoutDelta.height() == LayoutUnit::max() || m_layoutDelta.height() == LayoutUnit::min();
262 #endif
263 }
264 
265 #if ASSERT_ENABLED
266 bool RenderLayoutState::layoutDeltaMatches(LayoutSize delta) const
267 {
268     return (delta.width() == m_layoutDelta.width() || m_layoutDeltaXSaturated) &amp;&amp; (delta.height() == m_layoutDelta.height() || m_layoutDeltaYSaturated);
269 }
270 #endif
271 
272 LayoutStateMaintainer::LayoutStateMaintainer(RenderBox&amp; root, LayoutSize offset, bool disablePaintOffsetCache, LayoutUnit pageHeight, bool pageHeightChanged)
273     : m_context(root.view().frameView().layoutContext())
274     , m_paintOffsetCacheIsDisabled(disablePaintOffsetCache)
275 {
276     m_didPushLayoutState = m_context.pushLayoutState(root, offset, pageHeight, pageHeightChanged);
277     if (m_didPushLayoutState &amp;&amp; m_paintOffsetCacheIsDisabled)
278         m_context.disablePaintOffsetCache();
279 }
280 
281 LayoutStateMaintainer::~LayoutStateMaintainer()
282 {
283     if (!m_didPushLayoutState)
284         return;
285     m_context.popLayoutState();
286     if (m_paintOffsetCacheIsDisabled)
287         m_context.enablePaintOffsetCache();
288 }
289 
290 LayoutStateDisabler::LayoutStateDisabler(FrameViewLayoutContext&amp; context)
291     : m_context(context)
292 {
293     m_context.disablePaintOffsetCache();
294 }
295 
296 LayoutStateDisabler::~LayoutStateDisabler()
297 {
298     m_context.enablePaintOffsetCache();
299 }
300 
301 static bool shouldDisablePaintOffsetCacheForSubtree(RenderElement&amp; subtreeLayoutRoot)
302 {
303     for (auto* renderer = &amp;subtreeLayoutRoot; renderer; renderer = renderer-&gt;container()) {
304         if (renderer-&gt;hasTransform() || renderer-&gt;hasReflection())
305             return true;
306     }
307     return false;
308 }
309 
310 SubtreeLayoutStateMaintainer::SubtreeLayoutStateMaintainer(RenderElement* subtreeLayoutRoot)
311 {
312     if (subtreeLayoutRoot) {
313         m_context = &amp;subtreeLayoutRoot-&gt;view().frameView().layoutContext();
314         m_context-&gt;pushLayoutState(*subtreeLayoutRoot);
315         if (shouldDisablePaintOffsetCacheForSubtree(*subtreeLayoutRoot)) {
316             m_context-&gt;disablePaintOffsetCache();
317             m_didDisablePaintOffsetCache = true;
318         }
319     }
320 }
321 
322 SubtreeLayoutStateMaintainer::~SubtreeLayoutStateMaintainer()
323 {
324     if (m_context) {
325         m_context-&gt;popLayoutState();
326         if (m_didDisablePaintOffsetCache)
327             m_context-&gt;enablePaintOffsetCache();
328     }
329 }
330 
331 PaginatedLayoutStateMaintainer::PaginatedLayoutStateMaintainer(RenderBlockFlow&amp; flow)
332     : m_context(flow.view().frameView().layoutContext())
333     , m_pushed(m_context.pushLayoutStateForPaginationIfNeeded(flow))
334 {
335 }
336 
337 PaginatedLayoutStateMaintainer::~PaginatedLayoutStateMaintainer()
338 {
339     if (m_pushed)
340         m_context.popLayoutState();
341 }
342 
343 } // namespace WebCore
344 
    </pre>
  </body>
</html>
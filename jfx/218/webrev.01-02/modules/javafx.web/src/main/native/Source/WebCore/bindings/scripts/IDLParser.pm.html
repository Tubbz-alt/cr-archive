<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/scripts/IDLParser.pm</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 # 
   2 # KDOM IDL parser
   3 #
   4 # Copyright (C) 2005 Nikolas Zimmermann &lt;wildfox@kde.org&gt;
   5 # 
   6 # This library is free software; you can redistribute it and/or
   7 # modify it under the terms of the GNU Library General Public
   8 # License as published by the Free Software Foundation; either
   9 # version 2 of the License, or (at your option) any later version.
  10 # 
  11 # This library is distributed in the hope that it will be useful,
  12 # but WITHOUT ANY WARRANTY; without even the implied warranty of
  13 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  14 # Library General Public License for more details.
  15 # 
  16 # You should have received a copy of the GNU Library General Public License
  17 # along with this library; see the file COPYING.LIB.  If not, write to
  18 # the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
  19 # Boston, MA 02110-1301, USA.
  20 # 
  21 
  22 package IDLParser;
  23 
  24 use strict;
  25 
  26 use Carp qw&lt;longmess&gt;;
  27 use Data::Dumper;
  28 
  29 use preprocessor;
  30 use Class::Struct;
  31 
  32 use constant StringToken =&gt; 0;
  33 use constant IntegerToken =&gt; 1;
  34 use constant FloatToken =&gt; 2;
  35 use constant IdentifierToken =&gt; 3;
  36 use constant OtherToken =&gt; 4;
  37 use constant EmptyToken =&gt; 5;
  38 
  39 # Used to represent a parsed IDL document
  40 struct( IDLDocument =&gt; {
  41     interfaces =&gt; &#39;@&#39;, # List of &#39;IDLInterface&#39;
  42     enumerations =&gt; &#39;@&#39;, # List of &#39;IDLEnum&#39;
  43     dictionaries =&gt; &#39;@&#39;, # List of &#39;IDLDictionary&#39;
  44     callbackFunctions =&gt; &#39;@&#39;, # List of &#39;IDLCallbackFunction&#39;
  45     fileName =&gt; &#39;$&#39;,
  46 });
  47 
  48 # https://heycam.github.io/webidl/#idl-types
  49 struct( IDLType =&gt; {
  50     name =&gt;         &#39;$&#39;, # Type identifier
  51     isNullable =&gt;   &#39;$&#39;, # Is the type Nullable (T?)
  52     isUnion =&gt;      &#39;$&#39;, # Is the type a union (T or U)
  53     subtypes =&gt;     &#39;@&#39;, # Array of subtypes, only valid if isUnion or sequence
  54     extendedAttributes =&gt; &#39;%&#39;,
  55 });
  56 
  57 # Used to represent &#39;interface&#39; blocks
  58 struct( IDLInterface =&gt; {
  59     type =&gt; &#39;IDLType&#39;,
  60     parentType =&gt; &#39;IDLType&#39;,
  61     constants =&gt; &#39;@&#39;,    # List of &#39;IDLConstant&#39;
  62     operations =&gt; &#39;@&#39;,    # List of &#39;IDLOperation&#39;
  63     anonymousOperations =&gt; &#39;@&#39;, # List of &#39;IDLOperation&#39;
  64     attributes =&gt; &#39;@&#39;,    # List of &#39;IDLAttribute&#39;
  65     constructors =&gt; &#39;@&#39;, # Constructors, list of &#39;IDLOperation&#39;
  66     customConstructors =&gt; &#39;@&#39;, # Custom constructors, list of &#39;IDLOperation&#39;
  67     isException =&gt; &#39;$&#39;, # Used for exception interfaces
  68     isCallback =&gt; &#39;$&#39;, # Used for callback interfaces
  69     isPartial =&gt; &#39;$&#39;, # Used for partial interfaces
  70     iterable =&gt; &#39;$&#39;, # Used for iterable interfaces
  71     mapLike =&gt; &#39;$&#39;, # Used for mapLike interfaces
  72     setLike =&gt; &#39;$&#39;, # Used for setLike interfaces
  73     serializable =&gt; &#39;$&#39;, # Used for serializable interfaces
  74     extendedAttributes =&gt; &#39;$&#39;,
  75 });
  76 
  77 # Used to represent an argument to a IDLOperation.
  78 struct( IDLArgument =&gt; {
  79     name =&gt; &#39;$&#39;,
  80     type =&gt; &#39;IDLType&#39;,
  81     isVariadic =&gt; &#39;$&#39;,
  82     isOptional =&gt; &#39;$&#39;,
  83     default =&gt; &#39;$&#39;,
  84     extendedAttributes =&gt; &#39;%&#39;,
  85 });
  86 
  87 # https://heycam.github.io/webidl/#idl-operations
  88 struct( IDLOperation =&gt; {
  89     name =&gt; &#39;$&#39;,
  90     type =&gt; &#39;IDLType&#39;, # Return type
  91     arguments =&gt; &#39;@&#39;, # List of &#39;IDLArgument&#39;
  92     isStatic =&gt; &#39;$&#39;,
  93     isIterable =&gt; &#39;$&#39;,
  94     isSerializer =&gt; &#39;$&#39;,
  95     isStringifier =&gt; &#39;$&#39;,
  96     isMapLike =&gt; &#39;$&#39;,
  97     isSetLike =&gt; &#39;$&#39;,
  98     specials =&gt; &#39;@&#39;,
  99     extendedAttributes =&gt; &#39;%&#39;,
 100 });
 101 
 102 
 103 # https://heycam.github.io/webidl/#idl-attributes
 104 struct( IDLAttribute =&gt; {
 105     name =&gt; &#39;$&#39;,
 106     type =&gt; &#39;IDLType&#39;,
 107     isStatic =&gt; &#39;$&#39;,
 108     isMapLike =&gt; &#39;$&#39;,
 109     isSetLike =&gt; &#39;$&#39;,
 110     isStringifier =&gt; &#39;$&#39;,
 111     isReadOnly =&gt; &#39;$&#39;,
 112     isInherit =&gt; &#39;$&#39;,
 113     extendedAttributes =&gt; &#39;$&#39;,
 114 });
 115 
 116 # https://heycam.github.io/webidl/#idl-iterable
 117 struct( IDLIterable =&gt; {
 118     isKeyValue =&gt; &#39;$&#39;,
 119     keyType =&gt; &#39;IDLType&#39;,
 120     valueType =&gt; &#39;IDLType&#39;,
 121     operations =&gt; &#39;@&#39;, # Iterable operations (entries, keys, values, [Symbol.Iterator], forEach)
 122     extendedAttributes =&gt; &#39;$&#39;,
 123 });
 124 
 125 # https://heycam.github.io/webidl/#es-maplike
 126 struct( IDLMapLike =&gt; {
 127     isReadOnly =&gt; &#39;$&#39;,
 128     keyType =&gt; &#39;IDLType&#39;,
 129     valueType =&gt; &#39;IDLType&#39;,
 130     attributes =&gt; &#39;@&#39;, # MapLike attributes (size)
 131     operations =&gt; &#39;@&#39;, # MapLike operations (entries, keys, values, forEach, get, has and if not readonly, delete, set and clear)
 132     extendedAttributes =&gt; &#39;$&#39;,
 133 });
 134 
 135 # https://heycam.github.io/webidl/#es-setlike
 136 struct( IDLSetLike =&gt; {
 137     isReadOnly =&gt; &#39;$&#39;,
 138     itemType =&gt; &#39;IDLType&#39;,
 139     attributes =&gt; &#39;@&#39;, # SetLike attributes (size)
 140     operations =&gt; &#39;@&#39;, # SetLike operations (entries, keys, values, forEach, has and if not readonly, delete, set and clear)
 141     extendedAttributes =&gt; &#39;$&#39;,
 142 });
 143 
 144 # https://heycam.github.io/webidl/#idl-serializers
 145 struct( IDLSerializable =&gt; {
 146     attributes =&gt; &#39;@&#39;, # List of attributes to serialize
 147     hasAttribute =&gt; &#39;$&#39;, # serializer = { attribute }
 148     hasInherit =&gt; &#39;$&#39;, # serializer = { inherit }
 149     hasGetter =&gt; &#39;$&#39;, # serializer = { getter }
 150     operations =&gt; &#39;@&#39;, # toJSON operation
 151 });
 152 
 153 # https://heycam.github.io/webidl/#idl-constants
 154 struct( IDLConstant =&gt; {
 155     name =&gt; &#39;$&#39;,
 156     type =&gt; &#39;IDLType&#39;,
 157     value =&gt; &#39;$&#39;,
 158     extendedAttributes =&gt; &#39;$&#39;,
 159 });
 160 
 161 # https://heycam.github.io/webidl/#idl-enums
 162 struct( IDLEnum =&gt; {
 163     name =&gt; &#39;$&#39;,
 164     type =&gt; &#39;IDLType&#39;,
 165     values =&gt; &#39;@&#39;,
 166     extendedAttributes =&gt; &#39;$&#39;,
 167 });
 168 
 169 # https://heycam.github.io/webidl/#dfn-dictionary-member
 170 struct( IDLDictionaryMember =&gt; {
 171     name =&gt; &#39;$&#39;,
 172     type =&gt; &#39;IDLType&#39;,
 173     isRequired =&gt; &#39;$&#39;,
 174     default =&gt; &#39;$&#39;,
 175     extendedAttributes =&gt; &#39;$&#39;,
 176 });
 177 
 178 # https://heycam.github.io/webidl/#idl-dictionaries
 179 struct( IDLDictionary =&gt; {
 180     type =&gt; &#39;IDLType&#39;,
 181     parentType =&gt; &#39;IDLType&#39;,
 182     members =&gt; &#39;@&#39;, # List of &#39;IDLDictionaryMember&#39;
 183     extendedAttributes =&gt; &#39;$&#39;,
 184     isPartial =&gt; &#39;$&#39;, # Used for partial interfaces
 185 });
 186 
 187 # https://heycam.github.io/webidl/#idl-callback-functions
 188 struct( IDLCallbackFunction =&gt; {
 189     type =&gt; &#39;$&#39;,
 190     operation =&gt; &#39;IDLOperation&#39;,
 191     extendedAttributes =&gt; &#39;$&#39;,
 192 });
 193 
 194 # https://heycam.github.io/webidl/#idl-typedefs
 195 struct( IDLTypedef =&gt; {
 196     type =&gt; &#39;IDLType&#39;,
 197 });
 198 
 199 struct( Token =&gt; {
 200     type =&gt; &#39;$&#39;, # type of token
 201     value =&gt; &#39;$&#39; # value of token
 202 });
 203 
 204 # Maps &#39;typedef name&#39; -&gt; Typedef
 205 my %typedefs = ();
 206 
 207 sub new {
 208     my $class = shift;
 209 
 210     my $emptyToken = Token-&gt;new();
 211     $emptyToken-&gt;type(EmptyToken);
 212     $emptyToken-&gt;value(&quot;empty&quot;);
 213 
 214     my $self = {
 215         DocumentContent =&gt; &quot;&quot;,
 216         EmptyToken =&gt; $emptyToken,
 217         NextToken =&gt; $emptyToken,
 218         Token =&gt; $emptyToken,
 219         Line =&gt; &quot;&quot;,
 220         LineNumber =&gt; 1,
 221         ExtendedAttributeMap =&gt; &quot;&quot;
 222     };
 223     return bless $self, $class;
 224 }
 225 
 226 sub assert
 227 {
 228     my $message = shift;
 229 
 230     my $mess = longmess();
 231     print Dumper($mess);
 232 
 233     die $message;
 234 }
 235 
 236 sub assertTokenValue
 237 {
 238     my $self = shift;
 239     my $token = shift;
 240     my $value = shift;
 241     my $line = shift;
 242     my $msg = &quot;Next token should be &quot; . $value . &quot;, but &quot; . $token-&gt;value() . &quot; on line &quot; . $self-&gt;{Line};
 243     if (defined ($line)) {
 244         $msg .= &quot; IDLParser.pm:&quot; . $line;
 245     }
 246 
 247     assert $msg unless $token-&gt;value() eq $value;
 248 }
 249 
 250 sub assertTokenType
 251 {
 252     my $self = shift;
 253     my $token = shift;
 254     my $type = shift;
 255     
 256     assert &quot;Next token&#39;s type should be &quot; . $type . &quot;, but &quot; . $token-&gt;type() . &quot; on line &quot; . $self-&gt;{Line} unless $token-&gt;type() eq $type;
 257 }
 258 
 259 sub assertUnexpectedToken
 260 {
 261     my $self = shift;
 262     my $token = shift;
 263     my $line = shift;
 264     my $msg = &quot;Unexpected token &quot; . $token . &quot; on line &quot; . $self-&gt;{Line};
 265     if (defined ($line)) {
 266         $msg .= &quot; IDLParser.pm:&quot; . $line;
 267     }
 268 
 269     assert $msg;
 270 }
 271 
 272 sub assertExtendedAttributesValidForContext
 273 {
 274     my $self = shift;
 275     my $extendedAttributeList = shift;
 276     my @contexts = @_;
 277 
 278     for my $extendedAttribute (keys %{$extendedAttributeList}) {
 279         # FIXME: Should this be done here, or when parsing the exteded attribute itself?
 280         # Either way, we should add validation of the values, if any, at the same place.
 281 
 282         # Extended attribute parsing collapses multiple &#39;Constructor&#39; or &#39;CustomConstructor&#39;
 283         # attributes into a single plural version. Eventually, it would be nice if that conversion
 284         # hapened later, and the parser kept things relatively simply, but for now, we just undo
 285         # this transformation for the type check.
 286         if ($extendedAttribute eq &quot;Constructors&quot;) {
 287             $extendedAttribute = &quot;Constructor&quot;;
 288         } elsif ($extendedAttribute eq &quot;CustomConstructors&quot;) {
 289             $extendedAttribute = &quot;CustomConstructor&quot;;
 290         }
 291 
 292         if (!exists $self-&gt;{ExtendedAttributeMap}-&gt;{$extendedAttribute}) {
 293             assert &quot;Unknown extended attribute: &#39;${extendedAttribute}&#39;&quot;;
 294         }
 295 
 296         my $foundAllowedContext = 0;
 297         for my $contextAllowed (@{$self-&gt;{ExtendedAttributeMap}-&gt;{$extendedAttribute}-&gt;{&quot;contextsAllowed&quot;}}) {
 298             for my $context (@contexts) {
 299                 if ($contextAllowed eq $context) {
 300                     $foundAllowedContext = 1;
 301                     last;
 302                 }
 303             }
 304         }
 305 
 306         if (!$foundAllowedContext) {
 307             if (scalar(@contexts) == 1) {
 308                 assert &quot;Extended attribute &#39;${extendedAttribute}&#39; used in invalid context &#39;&quot; . $contexts[0] . &quot;&#39;&quot;;
 309             } else {
 310                 # FIXME: Improved this error message a bit.
 311                 assert &quot;Extended attribute &#39;${extendedAttribute}&#39; used in invalid context&quot;;
 312             }
 313         }
 314     }
 315 }
 316 
 317 sub Parse
 318 {
 319     my $self = shift;
 320     my $fileName = shift;
 321     my $defines = shift;
 322     my $preprocessor = shift;
 323     my $idlAttributes = shift;
 324 
 325     my @definitions = ();
 326 
 327     my @lines = applyPreprocessor($fileName, $defines, $preprocessor);
 328     $self-&gt;{Line} = $lines[0];
 329     $self-&gt;{DocumentContent} = join(&#39; &#39;, @lines);
 330     $self-&gt;{ExtendedAttributeMap} = $idlAttributes;
 331 
 332     addBuiltinTypedefs();
 333 
 334     $self-&gt;getToken();
 335     eval {
 336         my $result = $self-&gt;parseDefinitions();
 337         push(@definitions, @{$result});
 338 
 339         my $next = $self-&gt;nextToken();
 340         $self-&gt;assertTokenType($next, EmptyToken);
 341     };
 342     assert $@ . &quot; in $fileName&quot; if $@;
 343 
 344     my $document = IDLDocument-&gt;new();
 345     $document-&gt;fileName($fileName);
 346     foreach my $definition (@definitions) {
 347         if (ref($definition) eq &quot;IDLInterface&quot;) {
 348             push(@{$document-&gt;interfaces}, $definition);
 349         } elsif (ref($definition) eq &quot;IDLEnum&quot;) {
 350             push(@{$document-&gt;enumerations}, $definition);
 351         } elsif (ref($definition) eq &quot;IDLDictionary&quot;) {
 352             push(@{$document-&gt;dictionaries}, $definition);
 353         } elsif (ref($definition) eq &quot;IDLCallbackFunction&quot;) {
 354             push(@{$document-&gt;callbackFunctions}, $definition);
 355         } else {
 356             die &quot;Unrecognized IDL definition kind: \&quot;&quot; . ref($definition) . &quot;\&quot;&quot;;
 357         }
 358     }
 359     return $document;
 360 }
 361 
 362 sub ParseType
 363 {
 364     my ($self, $type, $idlAttributes) = @_;
 365 
 366     $self-&gt;{Line} = $type;
 367     $self-&gt;{DocumentContent} = $type;
 368     $self-&gt;{ExtendedAttributeMap} = $idlAttributes;
 369 
 370     addBuiltinTypedefs();
 371 
 372     my $result;
 373 
 374     $self-&gt;getToken();
 375     eval {
 376         $result = $self-&gt;parseType();
 377 
 378         my $next = $self-&gt;nextToken();
 379         $self-&gt;assertTokenType($next, EmptyToken);
 380     };
 381     assert $@ . &quot; parsing type ${type}&quot; if $@;
 382 
 383     return $result;
 384 }
 385 
 386 sub nextToken
 387 {
 388     my $self = shift;
 389     return $self-&gt;{NextToken};
 390 }
 391 
 392 sub getToken
 393 {
 394     my $self = shift;
 395     $self-&gt;{Token} = $self-&gt;{NextToken};
 396     $self-&gt;{NextToken} = $self-&gt;getTokenInternal();
 397     return $self-&gt;{Token};
 398 }
 399 
 400 my $whitespaceTokenPattern = &#39;^[\t\n\r ]*[\n\r]&#39;;
 401 my $floatTokenPattern = &#39;^(-?(([0-9]+\.[0-9]*|[0-9]*\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+))&#39;;
 402 my $integerTokenPattern = &#39;^(-?[1-9][0-9]*|-?0[Xx][0-9A-Fa-f]+|-?0[0-7]*)&#39;;
 403 my $stringTokenPattern = &#39;^(\&quot;[^\&quot;]*\&quot;)&#39;;
 404 my $identifierTokenPattern = &#39;^([A-Z_a-z][0-9A-Z_a-z]*)&#39;;
 405 my $otherTokenPattern = &#39;^(\.\.\.|[^\t\n\r 0-9A-Z_a-z])&#39;;
 406 
 407 sub getTokenInternal
 408 {
 409     my $self = shift;
 410 
 411     if ($self-&gt;{DocumentContent} =~ /$whitespaceTokenPattern/) {
 412         $self-&gt;{DocumentContent} =~ s/($whitespaceTokenPattern)//;
 413         my $skipped = $1;
 414         $self-&gt;{LineNumber}++ while ($skipped =~ /\n/g);
 415         if ($self-&gt;{DocumentContent} =~ /^([^\n\r]+)/) {
 416             $self-&gt;{Line} = $self-&gt;{LineNumber} . &quot;:&quot; . $1;
 417         } else {
 418             $self-&gt;{Line} = &quot;Unknown&quot;;
 419         }
 420     }
 421     $self-&gt;{DocumentContent} =~ s/^([\t\n\r ]+)//;
 422     if ($self-&gt;{DocumentContent} eq &quot;&quot;) {
 423         return $self-&gt;{EmptyToken};
 424     }
 425 
 426     my $token = Token-&gt;new();
 427     if ($self-&gt;{DocumentContent} =~ /$floatTokenPattern/) {
 428         $token-&gt;type(FloatToken);
 429         $token-&gt;value($1);
 430         $self-&gt;{DocumentContent} =~ s/$floatTokenPattern//;
 431         return $token;
 432     }
 433     if ($self-&gt;{DocumentContent} =~ /$integerTokenPattern/) {
 434         $token-&gt;type(IntegerToken);
 435         $token-&gt;value($1);
 436         $self-&gt;{DocumentContent} =~ s/$integerTokenPattern//;
 437         return $token;
 438     }
 439     if ($self-&gt;{DocumentContent} =~ /$stringTokenPattern/) {
 440         $token-&gt;type(StringToken);
 441         $token-&gt;value($1);
 442         $self-&gt;{DocumentContent} =~ s/$stringTokenPattern//;
 443         return $token;
 444     }
 445     if ($self-&gt;{DocumentContent} =~ /$identifierTokenPattern/) {
 446         $token-&gt;type(IdentifierToken);
 447         $token-&gt;value($1);
 448         $self-&gt;{DocumentContent} =~ s/$identifierTokenPattern//;
 449         return $token;
 450     }
 451     if ($self-&gt;{DocumentContent} =~ /$otherTokenPattern/) {
 452         $token-&gt;type(OtherToken);
 453         $token-&gt;value($1);
 454         $self-&gt;{DocumentContent} =~ s/$otherTokenPattern//;
 455         return $token;
 456     }
 457     die &quot;Failed in tokenizing at &quot; . $self-&gt;{Line};
 458 }
 459 
 460 sub unquoteString
 461 {
 462     my $self = shift;
 463     my $quotedString = shift;
 464     if ($quotedString =~ /^&quot;([^&quot;]*)&quot;$/) {
 465         return $1;
 466     }
 467     die &quot;Failed to parse string (&quot; . $quotedString . &quot;) at &quot; . $self-&gt;{Line};
 468 }
 469 
 470 sub identifierRemoveNullablePrefix
 471 {
 472     my $type = shift;
 473     $type =~ s/^_//;
 474     return $type;
 475 }
 476 
 477 sub copyExtendedAttributes
 478 {
 479     my $extendedAttributeList = shift;
 480     my $attr = shift;
 481 
 482     for my $key (keys %{$attr}) {
 483         if ($key eq &quot;Constructor&quot;) {
 484             push(@{$extendedAttributeList-&gt;{&quot;Constructors&quot;}}, $attr-&gt;{$key});
 485         } elsif ($key eq &quot;Constructors&quot;) {
 486             my @constructors = @{$attr-&gt;{$key}};
 487             foreach my $constructor (@constructors) {
 488                 push(@{$extendedAttributeList-&gt;{&quot;Constructors&quot;}}, $constructor);
 489             }
 490         } elsif ($key eq &quot;CustomConstructor&quot;) {
 491             push(@{$extendedAttributeList-&gt;{&quot;CustomConstructors&quot;}}, $attr-&gt;{$key});
 492         } elsif ($key eq &quot;CustomConstructors&quot;) {
 493            my @customConstructors = @{$attr-&gt;{$key}};
 494             foreach my $customConstructor (@customConstructors) {
 495                 push(@{$extendedAttributeList-&gt;{&quot;CustomConstructors&quot;}}, $customConstructor);
 496             }
 497         } else {
 498             $extendedAttributeList-&gt;{$key} = $attr-&gt;{$key};
 499         }
 500     }
 501 }
 502 
 503 sub isExtendedAttributeApplicableToTypes
 504 {
 505     my $self = shift;
 506     my $extendedAttribute = shift;
 507 
 508     if (!exists $self-&gt;{ExtendedAttributeMap}-&gt;{$extendedAttribute}) {
 509         assert &quot;Unknown extended attribute: &#39;${extendedAttribute}&#39;&quot;;
 510     }
 511 
 512     for my $contextAllowed (@{$self-&gt;{ExtendedAttributeMap}-&gt;{$extendedAttribute}-&gt;{&quot;contextsAllowed&quot;}}) {
 513         if ($contextAllowed eq &quot;type&quot;) {
 514             return 1;
 515         }
 516     }
 517 
 518     return 0;
 519 }
 520 
 521 sub moveExtendedAttributesApplicableToTypes
 522 {
 523     my $self = shift;
 524     my $type = shift;
 525     my $extendedAttributeList = shift;
 526 
 527     for my $key (keys %{$extendedAttributeList}) {
 528         if ($self-&gt;isExtendedAttributeApplicableToTypes($key)) {
 529             if (!defined $type-&gt;extendedAttributes-&gt;{$key}) {
 530                 $type-&gt;extendedAttributes-&gt;{$key} = $extendedAttributeList-&gt;{$key};
 531             }
 532             delete $extendedAttributeList-&gt;{$key};
 533         }
 534     }
 535 }
 536 
 537 sub typeDescription
 538 {
 539     my $type = shift;
 540 
 541     if (scalar @{$type-&gt;subtypes}) {
 542         return $type-&gt;name . &#39;&lt;&#39; . join(&#39;, &#39;, map { typeDescription($_) } @{$type-&gt;subtypes}) . &#39;&gt;&#39; . ($type-&gt;isNullable ? &quot;?&quot; : &quot;&quot;);
 543     }
 544 
 545     return $type-&gt;name . ($type-&gt;isNullable ? &quot;?&quot; : &quot;&quot;);
 546 }
 547 
 548 sub cloneType
 549 {
 550     my $type = shift;
 551 
 552     my $clonedType = IDLType-&gt;new();
 553     $clonedType-&gt;name($type-&gt;name);
 554     $clonedType-&gt;isNullable($type-&gt;isNullable);
 555     $clonedType-&gt;isUnion($type-&gt;isUnion);
 556 
 557     copyExtendedAttributes($clonedType-&gt;extendedAttributes, $type-&gt;extendedAttributes);
 558 
 559     foreach my $subtype (@{$type-&gt;subtypes}) {
 560         push(@{$clonedType-&gt;subtypes}, cloneType($subtype));
 561     }
 562 
 563     return $clonedType;
 564 }
 565 
 566 sub cloneArgument
 567 {
 568     my $argument = shift;
 569 
 570     my $clonedArgument = IDLArgument-&gt;new();
 571     $clonedArgument-&gt;name($argument-&gt;name);
 572     $clonedArgument-&gt;type(cloneType($argument-&gt;type));
 573     $clonedArgument-&gt;isVariadic($argument-&gt;isVariadic);
 574     $clonedArgument-&gt;isOptional($argument-&gt;isOptional);
 575     $clonedArgument-&gt;default($argument-&gt;default);
 576     copyExtendedAttributes($clonedArgument-&gt;extendedAttributes, $argument-&gt;extendedAttributes);
 577 
 578     return $clonedArgument;
 579 }
 580 
 581 sub cloneOperation
 582 {
 583     my $operation = shift;
 584 
 585     my $clonedOperation = IDLOperation-&gt;new();
 586     $clonedOperation-&gt;name($operation-&gt;name);
 587     $clonedOperation-&gt;type(cloneType($operation-&gt;type));
 588     
 589     foreach my $argument (@{$operation-&gt;arguments}) {
 590         push(@{$clonedOperation-&gt;arguments}, cloneArgument($argument));
 591     }
 592 
 593     $clonedOperation-&gt;isStatic($operation-&gt;isStatic);
 594     $clonedOperation-&gt;isIterable($operation-&gt;isIterable);
 595     $clonedOperation-&gt;isSerializer($operation-&gt;isSerializer);
 596     $clonedOperation-&gt;isStringifier($operation-&gt;isStringifier);
 597     $clonedOperation-&gt;isMapLike($operation-&gt;isMapLike);
 598     $clonedOperation-&gt;isSetLike($operation-&gt;isSetLike);
 599     $clonedOperation-&gt;specials($operation-&gt;specials);
 600 
 601     copyExtendedAttributes($clonedOperation-&gt;extendedAttributes, $operation-&gt;extendedAttributes);
 602 
 603     return $clonedOperation;
 604 }
 605 
 606 sub makeSimpleType
 607 {
 608     my $typeName = shift;
 609 
 610     return IDLType-&gt;new(name =&gt; $typeName);
 611 }
 612 
 613 sub addBuiltinTypedefs()
 614 {
 615     # NOTE: This leaves out the ArrayBufferView definition as it is
 616     # treated as its own type, and not a union, to allow us to utilize
 617     # the shared base class all the members of the union have.
 618 
 619     # typedef (ArrayBufferView or ArrayBuffer) BufferSource;
 620 
 621     my $bufferSourceType = IDLType-&gt;new(name =&gt; &quot;UNION&quot;, isUnion =&gt; 1);
 622     push(@{$bufferSourceType-&gt;subtypes}, makeSimpleType(&quot;ArrayBufferView&quot;));
 623     push(@{$bufferSourceType-&gt;subtypes}, makeSimpleType(&quot;ArrayBuffer&quot;));
 624     $typedefs{&quot;BufferSource&quot;} = IDLTypedef-&gt;new(type =&gt; $bufferSourceType);
 625 
 626     # typedef unsigned long long DOMTimeStamp;
 627 
 628     my $DOMTimeStampType = IDLType-&gt;new(name =&gt; &quot;unsigned long long&quot;);
 629     $typedefs{&quot;DOMTimeStamp&quot;} = IDLTypedef-&gt;new(type =&gt; $DOMTimeStampType);
 630 }
 631 
 632 my $nextAttribute_1 = &#39;^(attribute|inherit)$&#39;;
 633 my $nextAttribute_2 = &#39;^(readonly|attribute)$&#39;;
 634 my $nextPrimitiveType_1 = &#39;^(int|long|short|unsigned)$&#39;;
 635 my $nextPrimitiveType_2 = &#39;^(double|float|unrestricted)$&#39;;
 636 my $nextArgumentList_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|\[|any|boolean|byte|double|float|in|long|object|octet|optional|sequence|short|unrestricted|unsigned)$&#39;;
 637 my $nextNonAnyType_1 = &#39;^(boolean|byte|double|float|long|octet|short|unrestricted|unsigned)$&#39;;
 638 my $nextStringType_1 = &#39;^(ByteString|DOMString|USVString)$&#39;;
 639 my $nextInterfaceMember_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|any|attribute|boolean|byte|deleter|double|float|getter|inherit|legacycaller|long|object|octet|readonly|sequence|setter|short|unrestricted|unsigned|void)$&#39;;
 640 my $nextOperation_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|any|boolean|byte|deleter|double|float|getter|legacycaller|long|object|octet|sequence|setter|short|unrestricted|unsigned|void)$&#39;;
 641 my $nextUnrestrictedFloatType_1 = &#39;^(double|float)$&#39;;
 642 my $nextExtendedAttributeRest3_1 = &#39;^(\,|\])$&#39;;
 643 my $nextExceptionField_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|any|boolean|byte|double|float|long|object|octet|sequence|short|unrestricted|unsigned)$&#39;;
 644 my $nextType_1 = &#39;^(ByteString|DOMString|USVString|Date|any|boolean|byte|double|float|long|object|octet|sequence|short|unrestricted|unsigned)$&#39;;
 645 my $nextSpecials_1 = &#39;^(deleter|getter|legacycaller|setter)$&#39;;
 646 my $nextDefinitions_1 = &#39;^(callback|dictionary|enum|exception|interface|partial|typedef)$&#39;;
 647 my $nextExceptionMembers_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|\[|any|boolean|byte|const|double|float|long|object|octet|optional|sequence|short|unrestricted|unsigned)$&#39;;
 648 my $nextInterfaceMembers_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|any|attribute|boolean|byte|const|deleter|double|float|getter|inherit|legacycaller|long|object|octet|readonly|sequence|serializer|setter|short|static|stringifier|unrestricted|unsigned|void)$&#39;;
 649 my $nextSingleType_1 = &#39;^(ByteString|DOMString|USVString|Date|boolean|byte|double|float|long|object|octet|sequence|short|unrestricted|unsigned)$&#39;;
 650 my $nextArgumentName_1 = &#39;^(attribute|callback|const|deleter|dictionary|enum|exception|getter|implements|inherit|interface|legacycaller|partial|serializer|setter|static|stringifier|typedef|unrestricted)$&#39;;
 651 my $nextConstValue_1 = &#39;^(false|true)$&#39;;
 652 my $nextConstValue_2 = &#39;^(-|Infinity|NaN)$&#39;;
 653 my $nextDefinition_1 = &#39;^(callback|interface)$&#39;;
 654 my $nextOperationRest_1 = &#39;^(\(|ByteString|DOMString|USVString|Date|any|boolean|byte|double|float|long|object|octet|sequence|short|unrestricted|unsigned|void)$&#39;;
 655 my $nextUnsignedIntegerType_1 = &#39;^(long|short)$&#39;;
 656 my $nextDefaultValue_1 = &#39;^(-|Infinity|NaN|false|null|true)$&#39;;
 657 
 658 
 659 sub parseDefinitions
 660 {
 661     my $self = shift;
 662     my @definitions = ();
 663 
 664     while (1) {
 665         my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
 666         my $next = $self-&gt;nextToken();
 667         my $definition;
 668         if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextDefinitions_1/) {
 669             $definition = $self-&gt;parseDefinition($extendedAttributeList);
 670         } else {
 671             last;
 672         }
 673         if (defined ($definition)) {
 674             push(@definitions, $definition);
 675         }
 676     }
 677     $self-&gt;applyTypedefs(\@definitions);
 678     return \@definitions;
 679 }
 680 
 681 sub applyTypedefs
 682 {
 683     my $self = shift;
 684     my $definitions = shift;
 685    
 686     if (!%typedefs) {
 687         return;
 688     }
 689     
 690     foreach my $definition (@$definitions) {
 691         if (ref($definition) eq &quot;IDLInterface&quot;) {
 692             foreach my $constant (@{$definition-&gt;constants}) {
 693                 $constant-&gt;type($self-&gt;typeByApplyingTypedefs($constant-&gt;type));
 694             }
 695             foreach my $attribute (@{$definition-&gt;attributes}) {
 696                 $attribute-&gt;type($self-&gt;typeByApplyingTypedefs($attribute-&gt;type));
 697             }
 698             foreach my $operation (@{$definition-&gt;operations}, @{$definition-&gt;anonymousOperations}, @{$definition-&gt;constructors}, @{$definition-&gt;customConstructors}) {
 699                 $self-&gt;applyTypedefsToOperation($operation);
 700             }
 701             if ($definition-&gt;iterable) {
 702                 if ($definition-&gt;iterable-&gt;keyType) {
 703                     $definition-&gt;iterable-&gt;keyType($self-&gt;typeByApplyingTypedefs($definition-&gt;iterable-&gt;keyType));
 704                 }
 705                 if ($definition-&gt;iterable-&gt;valueType) {
 706                     $definition-&gt;iterable-&gt;valueType($self-&gt;typeByApplyingTypedefs($definition-&gt;iterable-&gt;valueType));
 707                 }
 708                 foreach my $operation (@{$definition-&gt;iterable-&gt;operations}) {
 709                     $self-&gt;applyTypedefsToOperation($operation);
 710                 }
 711             }
 712             if ($definition-&gt;mapLike) {
 713                 if ($definition-&gt;mapLike-&gt;keyType) {
 714                     $definition-&gt;mapLike-&gt;keyType($self-&gt;typeByApplyingTypedefs($definition-&gt;mapLike-&gt;keyType));
 715                 }
 716                 if ($definition-&gt;mapLike-&gt;valueType) {
 717                     $definition-&gt;mapLike-&gt;valueType($self-&gt;typeByApplyingTypedefs($definition-&gt;mapLike-&gt;valueType));
 718                 }
 719                 foreach my $attribute (@{$definition-&gt;mapLike-&gt;attributes}) {
 720                     $attribute-&gt;type($self-&gt;typeByApplyingTypedefs($attribute-&gt;type));
 721                 }
 722                 foreach my $operation (@{$definition-&gt;mapLike-&gt;operations}) {
 723                     $self-&gt;applyTypedefsToOperation($operation);
 724                 }
 725             }
 726             if ($definition-&gt;setLike) {
 727                 if ($definition-&gt;setLike-&gt;itemType) {
 728                     $definition-&gt;setLike-&gt;itemType($self-&gt;typeByApplyingTypedefs($definition-&gt;setLike-&gt;itemType));
 729                 }
 730                 foreach my $attribute (@{$definition-&gt;setLike-&gt;attributes}) {
 731                     $attribute-&gt;type($self-&gt;typeByApplyingTypedefs($attribute-&gt;type));
 732                 }
 733                 foreach my $operation (@{$definition-&gt;setLike-&gt;operations}) {
 734                     $self-&gt;applyTypedefsToOperation($operation);
 735                 }
 736             }
 737         } elsif (ref($definition) eq &quot;IDLDictionary&quot;) {
 738             foreach my $member (@{$definition-&gt;members}) {
 739                 $member-&gt;type($self-&gt;typeByApplyingTypedefs($member-&gt;type));
 740             }
 741         } elsif (ref($definition) eq &quot;IDLCallbackFunction&quot;) {
 742             $self-&gt;applyTypedefsToOperation($definition-&gt;operation);
 743         }
 744     }
 745 }
 746 
 747 sub applyTypedefsToOperation
 748 {
 749     my $self = shift;
 750     my $operation = shift;
 751 
 752     if ($operation-&gt;type) {
 753         $operation-&gt;type($self-&gt;typeByApplyingTypedefs($operation-&gt;type));
 754     }
 755 
 756     foreach my $argument (@{$operation-&gt;arguments}) {
 757         $argument-&gt;type($self-&gt;typeByApplyingTypedefs($argument-&gt;type));
 758     }
 759 }
 760 
 761 sub typeByApplyingTypedefs
 762 {
 763     my $self = shift;
 764     my $type = shift;
 765 
 766     assert(&quot;Missing type&quot;) if !$type;
 767 
 768     my $numberOfSubtypes = scalar @{$type-&gt;subtypes};
 769     if ($numberOfSubtypes) {
 770         for my $i (0..$numberOfSubtypes - 1) {
 771             my $subtype = @{$type-&gt;subtypes}[$i];
 772             my $replacementSubtype = $self-&gt;typeByApplyingTypedefs($subtype);
 773             @{$type-&gt;subtypes}[$i] = $replacementSubtype
 774         }
 775 
 776         return $type;
 777     }
 778 
 779     if (exists $typedefs{$type-&gt;name}) {
 780         my $typedef = $typedefs{$type-&gt;name};
 781 
 782         my $clonedType = cloneType($typedef-&gt;type);
 783         $clonedType-&gt;isNullable($clonedType-&gt;isNullable || $type-&gt;isNullable);
 784         $self-&gt;moveExtendedAttributesApplicableToTypes($clonedType, $type-&gt;extendedAttributes);
 785 
 786         return $self-&gt;typeByApplyingTypedefs($clonedType);
 787     }
 788     
 789     return $type;
 790 }
 791 
 792 sub parseDefinition
 793 {
 794     my $self = shift;
 795     my $extendedAttributeList = shift;
 796 
 797     my $next = $self-&gt;nextToken();
 798     if ($next-&gt;value() =~ /$nextDefinition_1/) {
 799         return $self-&gt;parseCallbackOrInterface($extendedAttributeList);
 800     }
 801     if ($next-&gt;value() eq &quot;partial&quot;) {
 802         return $self-&gt;parsePartial($extendedAttributeList);
 803     }
 804     if ($next-&gt;value() eq &quot;dictionary&quot;) {
 805         return $self-&gt;parseDictionary($extendedAttributeList);
 806     }
 807     if ($next-&gt;value() eq &quot;exception&quot;) {
 808         return $self-&gt;parseException($extendedAttributeList);
 809     }
 810     if ($next-&gt;value() eq &quot;enum&quot;) {
 811         return $self-&gt;parseEnum($extendedAttributeList);
 812     }
 813     if ($next-&gt;value() eq &quot;typedef&quot;) {
 814         return $self-&gt;parseTypedef($extendedAttributeList);
 815     }
 816     if ($next-&gt;type() == IdentifierToken) {
 817         return $self-&gt;parseImplementsStatement($extendedAttributeList);
 818     }
 819     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 820 }
 821 
 822 sub parseCallbackOrInterface
 823 {
 824     my $self = shift;
 825     my $extendedAttributeList = shift;
 826 
 827     my $next = $self-&gt;nextToken();
 828     if ($next-&gt;value() eq &quot;callback&quot;) {
 829         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;callback&quot;, __LINE__);
 830         return $self-&gt;parseCallbackRestOrInterface($extendedAttributeList);
 831     }
 832     if ($next-&gt;value() eq &quot;interface&quot;) {
 833         return $self-&gt;parseInterface($extendedAttributeList);
 834     }
 835     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 836 }
 837 
 838 sub parseCallbackRestOrInterface
 839 {
 840     my $self = shift;
 841     my $extendedAttributeList = shift;
 842 
 843     my $next = $self-&gt;nextToken();
 844     if ($next-&gt;value() eq &quot;interface&quot;) {
 845         my $interface = $self-&gt;parseInterface($extendedAttributeList);
 846         $interface-&gt;isCallback(1);
 847         return $interface;
 848     }
 849     if ($next-&gt;type() == IdentifierToken) {
 850         return $self-&gt;parseCallbackRest($extendedAttributeList);
 851     }
 852     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 853 }
 854 
 855 sub parseInterface
 856 {
 857     my $self = shift;
 858     my $extendedAttributeList = shift;
 859 
 860     my $next = $self-&gt;nextToken();
 861     if ($next-&gt;value() eq &quot;interface&quot;) {
 862         my $interface = IDLInterface-&gt;new();
 863         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;interface&quot;, __LINE__);
 864         my $interfaceNameToken = $self-&gt;getToken();
 865         $self-&gt;assertTokenType($interfaceNameToken, IdentifierToken);
 866         
 867         my $name = identifierRemoveNullablePrefix($interfaceNameToken-&gt;value());
 868         $interface-&gt;type(makeSimpleType($name));
 869 
 870         $next = $self-&gt;nextToken();
 871         if ($next-&gt;value() eq &quot;:&quot;) {
 872             my $parent = $self-&gt;parseInheritance();
 873             $interface-&gt;parentType(makeSimpleType($parent));
 874         }
 875 
 876         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);
 877         my $interfaceMembers = $self-&gt;parseInterfaceMembers();
 878         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);
 879         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
 880         applyMemberList($interface, $interfaceMembers);
 881 
 882         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;interface&quot;);
 883         applyExtendedAttributeList($interface, $extendedAttributeList);
 884 
 885         return $interface;
 886     }
 887     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 888 }
 889 
 890 sub parsePartial
 891 {
 892     my $self = shift;
 893     my $extendedAttributeList = shift;
 894 
 895     my $next = $self-&gt;nextToken();
 896     if ($next-&gt;value() eq &quot;partial&quot;) {
 897         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;partial&quot;, __LINE__);
 898         return $self-&gt;parsePartialDefinition($extendedAttributeList);
 899     }
 900     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 901 }
 902 
 903 sub parsePartialDefinition
 904 {
 905     my $self = shift;
 906     my $extendedAttributeList = shift;
 907 
 908     my $next = $self-&gt;nextToken();
 909     if ($next-&gt;value() eq &quot;interface&quot;) {
 910         my $interface = $self-&gt;parseInterface($extendedAttributeList);
 911         $interface-&gt;isPartial(1);
 912         return $interface;
 913     }
 914     if ($next-&gt;value() eq &quot;dictionary&quot;) {
 915         my $dictionary = $self-&gt;parseDictionary($extendedAttributeList);
 916         $dictionary-&gt;isPartial(1);
 917         return $dictionary;
 918     }
 919     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 920 }
 921 
 922 sub parseInterfaceMembers
 923 {
 924     my $self = shift;
 925     my @interfaceMembers = ();
 926 
 927     while (1) {
 928         my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
 929         my $next = $self-&gt;nextToken();
 930         my $interfaceMember;
 931 
 932         if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextInterfaceMembers_1/) {
 933             $interfaceMember = $self-&gt;parseInterfaceMember($extendedAttributeList);
 934         } else {
 935             last;
 936         }
 937         if (defined $interfaceMember) {
 938             push(@interfaceMembers, $interfaceMember);
 939         }
 940     }
 941     return \@interfaceMembers;
 942 }
 943 
 944 sub parseInterfaceMember
 945 {
 946     my $self = shift;
 947     my $extendedAttributeList = shift;
 948 
 949     my $next = $self-&gt;nextToken();
 950     if ($next-&gt;value() eq &quot;const&quot;) {
 951         return $self-&gt;parseConst($extendedAttributeList);
 952     }
 953 
 954     if ($next-&gt;value() eq &quot;serializer&quot;) {
 955         return $self-&gt;parseSerializer($extendedAttributeList);
 956     }
 957 
 958     if ($next-&gt;value() eq &quot;stringifier&quot;) {
 959         return $self-&gt;parseStringifier($extendedAttributeList);
 960     }
 961 
 962     if ($next-&gt;value() eq &quot;static&quot;) {
 963         return $self-&gt;parseStaticMember($extendedAttributeList);
 964     }
 965 
 966     if ($next-&gt;value() eq &quot;iterable&quot;) {
 967         return $self-&gt;parseIterableRest($extendedAttributeList);
 968     }
 969 
 970     if ($next-&gt;value() eq &quot;readonly&quot;) {
 971         return $self-&gt;parseReadOnlyMember($extendedAttributeList);
 972     }
 973 
 974     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextInterfaceMember_1/) {
 975         return $self-&gt;parseOperationOrReadWriteAttributeOrMaplike($extendedAttributeList);
 976     }
 977 
 978     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
 979 }
 980 
 981 sub parseDictionary
 982 {
 983     my $self = shift;
 984     my $extendedAttributeList = shift;
 985 
 986     my $next = $self-&gt;nextToken();
 987     if ($next-&gt;value() eq &quot;dictionary&quot;) {
 988         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;dictionary&quot;, __LINE__);
 989 
 990         my $dictionary = IDLDictionary-&gt;new();
 991 
 992         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;dictionary&quot;);
 993         $dictionary-&gt;extendedAttributes($extendedAttributeList);
 994 
 995         my $nameToken = $self-&gt;getToken();
 996         $self-&gt;assertTokenType($nameToken, IdentifierToken);
 997 
 998         my $name = $nameToken-&gt;value();
 999         $dictionary-&gt;type(makeSimpleType($name));
1000 
1001         $next = $self-&gt;nextToken();
1002         if ($next-&gt;value() eq &quot;:&quot;) {
1003             my $parent = $self-&gt;parseInheritance();
1004             $dictionary-&gt;parentType(makeSimpleType($parent));
1005         }
1006         
1007         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);
1008         $dictionary-&gt;members($self-&gt;parseDictionaryMembers());
1009         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);
1010         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1011         return $dictionary;
1012     }
1013     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1014 }
1015 
1016 sub parseDictionaryMembers
1017 {
1018     my $self = shift;
1019 
1020     my @members = ();
1021 
1022     while (1) {
1023         my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
1024         my $next = $self-&gt;nextToken();
1025         if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
1026             push(@members, $self-&gt;parseDictionaryMember($extendedAttributeList));
1027         } else {
1028             last;
1029         }
1030     }
1031 
1032     return \@members;
1033 }
1034 
1035 sub parseDictionaryMember
1036 {
1037     my $self = shift;
1038     my $extendedAttributeList = shift;
1039 
1040     my $next = $self-&gt;nextToken();
1041     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
1042         my $member = IDLDictionaryMember-&gt;new();
1043 
1044         if ($next-&gt;value eq &quot;required&quot;) {
1045             $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;required&quot;, __LINE__);
1046             $member-&gt;isRequired(1);
1047 
1048             my $type = $self-&gt;parseTypeWithExtendedAttributes();
1049             $member-&gt;type($type);
1050         } else {
1051             $member-&gt;isRequired(0);
1052 
1053             my $type = $self-&gt;parseType();
1054             $self-&gt;moveExtendedAttributesApplicableToTypes($type, $extendedAttributeList);
1055             
1056             $member-&gt;type($type);
1057         }
1058 
1059         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;dictionary-member&quot;);
1060         $member-&gt;extendedAttributes($extendedAttributeList);
1061 
1062         my $nameToken = $self-&gt;getToken();
1063         $self-&gt;assertTokenType($nameToken, IdentifierToken);
1064         $member-&gt;name($nameToken-&gt;value);
1065         $member-&gt;default($self-&gt;parseDefault());
1066         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1067         return $member;
1068     }
1069     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1070 }
1071 
1072 sub parseDefault
1073 {
1074     my $self = shift;
1075     my $next = $self-&gt;nextToken();
1076     if ($next-&gt;value() eq &quot;=&quot;) {
1077         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;=&quot;, __LINE__);
1078         return $self-&gt;parseDefaultValue();
1079     }
1080     return undef;
1081 }
1082 
1083 sub parseDefaultValue
1084 {
1085     my $self = shift;
1086     my $next = $self-&gt;nextToken();
1087     if ($next-&gt;type() == FloatToken || $next-&gt;type() == IntegerToken || $next-&gt;value() =~ /$nextDefaultValue_1/) {
1088         return $self-&gt;parseConstValue();
1089     }
1090     if ($next-&gt;type() == StringToken) {
1091         return $self-&gt;getToken()-&gt;value();
1092     }
1093     if ($next-&gt;value() eq &quot;[&quot;) {
1094         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;[&quot;, __LINE__);
1095         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;]&quot;, __LINE__);
1096         return &quot;[]&quot;;
1097     }
1098     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1099 }
1100 
1101 sub parseException
1102 {
1103     my $self = shift;
1104     my $extendedAttributeList = shift;
1105 
1106     my $next = $self-&gt;nextToken();
1107     if ($next-&gt;value() eq &quot;exception&quot;) {
1108         my $interface = IDLInterface-&gt;new();
1109         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;exception&quot;, __LINE__);
1110         my $exceptionNameToken = $self-&gt;getToken();
1111         $self-&gt;assertTokenType($exceptionNameToken, IdentifierToken);
1112 
1113         my $name = identifierRemoveNullablePrefix($exceptionNameToken-&gt;value());
1114         $interface-&gt;type(makeSimpleType($name));
1115         $interface-&gt;isException(1);
1116 
1117         $next = $self-&gt;nextToken();
1118         if ($next-&gt;value() eq &quot;:&quot;) {
1119             my $parent = $self-&gt;parseInheritance();
1120             $interface-&gt;parentType(makeSimpleType($parent));
1121         }
1122         
1123         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);
1124         my $exceptionMembers = $self-&gt;parseExceptionMembers();
1125         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);
1126         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1127         applyMemberList($interface, $exceptionMembers);
1128         
1129         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;interface&quot;);
1130         applyExtendedAttributeList($interface, $extendedAttributeList);
1131 
1132         return $interface;
1133     }
1134     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1135 }
1136 
1137 sub parseExceptionMembers
1138 {
1139     my $self = shift;
1140     my @members = ();
1141 
1142     while (1) {
1143         my $next = $self-&gt;nextToken();
1144         if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionMembers_1/) {
1145             my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
1146             #my $member = $self-&gt;parseExceptionMember($extendedAttributeList);
1147             my $member = $self-&gt;parseInterfaceMember($extendedAttributeList);
1148             if (defined ($member)) {
1149                 push(@members, $member);
1150             }
1151         } else {
1152             last;
1153         }
1154     }
1155     return \@members;
1156 }
1157 
1158 sub parseInheritance
1159 {
1160     my $self = shift;
1161 
1162     my $next = $self-&gt;nextToken();
1163     if ($next-&gt;value() eq &quot;:&quot;) {
1164         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;:&quot;, __LINE__);
1165         return $self-&gt;parseName();
1166     }
1167     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1168 }
1169 
1170 sub parseEnum
1171 {
1172     my $self = shift;
1173     my $extendedAttributeList = shift;
1174 
1175     my $next = $self-&gt;nextToken();
1176     if ($next-&gt;value() eq &quot;enum&quot;) {
1177         my $enum = IDLEnum-&gt;new();
1178         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;enum&quot;, __LINE__);
1179         my $enumNameToken = $self-&gt;getToken();
1180         $self-&gt;assertTokenType($enumNameToken, IdentifierToken);
1181         my $name = identifierRemoveNullablePrefix($enumNameToken-&gt;value());
1182         $enum-&gt;name($name);
1183         $enum-&gt;type(makeSimpleType($name));
1184         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);
1185         push(@{$enum-&gt;values}, @{$self-&gt;parseEnumValueList()});
1186         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);
1187         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1188         
1189         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;enum&quot;);
1190         $enum-&gt;extendedAttributes($extendedAttributeList);
1191         return $enum;
1192     }
1193     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1194 }
1195 
1196 sub parseEnumValueList
1197 {
1198     my $self = shift;
1199     my @values = ();
1200     my $next = $self-&gt;nextToken();
1201     if ($next-&gt;type() == StringToken) {
1202         my $enumValueToken = $self-&gt;getToken();
1203         $self-&gt;assertTokenType($enumValueToken, StringToken);
1204         my $enumValue = $self-&gt;unquoteString($enumValueToken-&gt;value());
1205         push(@values, $enumValue);
1206         push(@values, @{$self-&gt;parseEnumValues()});
1207         return \@values;
1208     }
1209     # value list must be non-empty
1210     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1211 }
1212 
1213 sub parseEnumValues
1214 {
1215     my $self = shift;
1216     my @values = ();
1217     my $next = $self-&gt;nextToken();
1218     if ($next-&gt;value() eq &quot;,&quot;) {
1219         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
1220         my $enumValueToken = $self-&gt;getToken();
1221         $self-&gt;assertTokenType($enumValueToken, StringToken);
1222         my $enumValue = $self-&gt;unquoteString($enumValueToken-&gt;value());
1223         push(@values, $enumValue);
1224         push(@values, @{$self-&gt;parseEnumValues()});
1225         return \@values;
1226     }
1227     return \@values; # empty list (end of enumeration-values)
1228 }
1229 
1230 sub parseCallbackRest
1231 {
1232     my $self = shift;
1233     my $extendedAttributeList = shift;
1234 
1235     my $next = $self-&gt;nextToken();
1236     if ($next-&gt;type() == IdentifierToken) {
1237         my $callback = IDLCallbackFunction-&gt;new();
1238 
1239         my $nameToken = $self-&gt;getToken();
1240         $self-&gt;assertTokenType($nameToken, IdentifierToken);
1241 
1242         $callback-&gt;type(makeSimpleType($nameToken-&gt;value()));
1243 
1244         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;=&quot;, __LINE__);
1245 
1246         my $operation = IDLOperation-&gt;new();
1247         $operation-&gt;type($self-&gt;parseReturnType());
1248         
1249         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;callback-function&quot;, &quot;operation&quot;);
1250         $operation-&gt;extendedAttributes($extendedAttributeList);
1251 
1252         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, __LINE__);
1253 
1254         push(@{$operation-&gt;arguments}, @{$self-&gt;parseArgumentList()});
1255 
1256         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
1257         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1258 
1259         $callback-&gt;operation($operation);
1260         $callback-&gt;extendedAttributes($extendedAttributeList);
1261 
1262         return $callback;
1263     }
1264     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1265 }
1266 
1267 sub parseTypedef
1268 {
1269     my $self = shift;
1270     my $extendedAttributeList = shift;
1271     die &quot;Extended attributes are not applicable to typedefs themselves: &quot; . $self-&gt;{Line} if %{$extendedAttributeList};
1272 
1273     my $next = $self-&gt;nextToken();
1274     if ($next-&gt;value() eq &quot;typedef&quot;) {
1275         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;typedef&quot;, __LINE__);
1276         my $typedef = IDLTypedef-&gt;new();
1277 
1278         my $type = $self-&gt;parseTypeWithExtendedAttributes();
1279         $typedef-&gt;type($type);
1280 
1281         my $nameToken = $self-&gt;getToken();
1282         $self-&gt;assertTokenType($nameToken, IdentifierToken);
1283         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1284         my $name = $nameToken-&gt;value();
1285         die &quot;typedef redefinition for &quot; . $name . &quot; at &quot; . $self-&gt;{Line} if (exists $typedefs{$name} &amp;&amp; $typedef-&gt;type-&gt;name ne $typedefs{$name}-&gt;type-&gt;name);
1286         $typedefs{$name} = $typedef;
1287         return;
1288     }
1289     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1290 }
1291 
1292 sub parseImplementsStatement
1293 {
1294     my $self = shift;
1295     my $extendedAttributeList = shift;
1296 
1297     my $next = $self-&gt;nextToken();
1298     if ($next-&gt;type() == IdentifierToken) {
1299         $self-&gt;parseName();
1300         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;implements&quot;, __LINE__);
1301         $self-&gt;parseName();
1302         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1303         return;
1304     }
1305     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1306 }
1307 
1308 sub parseConst
1309 {
1310     my $self = shift;
1311     my $extendedAttributeList = shift;
1312 
1313     my $next = $self-&gt;nextToken();
1314     if ($next-&gt;value() eq &quot;const&quot;) {
1315         my $newDataNode = IDLConstant-&gt;new();
1316         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;const&quot;, __LINE__);
1317         my $type = $self-&gt;parseConstType();
1318         $newDataNode-&gt;type($type);
1319         my $constNameToken = $self-&gt;getToken();
1320         $self-&gt;assertTokenType($constNameToken, IdentifierToken);
1321         $newDataNode-&gt;name(identifierRemoveNullablePrefix($constNameToken-&gt;value()));
1322         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;=&quot;, __LINE__);
1323         $newDataNode-&gt;value($self-&gt;parseConstValue());
1324         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1325 
1326         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;constant&quot;);
1327         $newDataNode-&gt;extendedAttributes($extendedAttributeList);
1328 
1329         return $newDataNode;
1330     }
1331     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1332 }
1333 
1334 sub parseConstValue
1335 {
1336     my $self = shift;
1337     my $next = $self-&gt;nextToken();
1338     if ($next-&gt;value() =~ /$nextConstValue_1/) {
1339         return $self-&gt;parseBooleanLiteral();
1340     }
1341     if ($next-&gt;value() eq &quot;null&quot;) {
1342         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;null&quot;, __LINE__);
1343         return &quot;null&quot;;
1344     }
1345     if ($next-&gt;type() == FloatToken || $next-&gt;value() =~ /$nextConstValue_2/) {
1346         return $self-&gt;parseFloatLiteral();
1347     }
1348     if ($next-&gt;type() == IntegerToken) {
1349         return $self-&gt;getToken()-&gt;value();
1350     }
1351     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1352 }
1353 
1354 sub parseBooleanLiteral
1355 {
1356     my $self = shift;
1357     my $next = $self-&gt;nextToken();
1358     if ($next-&gt;value() eq &quot;true&quot;) {
1359         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;true&quot;, __LINE__);
1360         return &quot;true&quot;;
1361     }
1362     if ($next-&gt;value() eq &quot;false&quot;) {
1363         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;false&quot;, __LINE__);
1364         return &quot;false&quot;;
1365     }
1366     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1367 }
1368 
1369 sub parseFloatLiteral
1370 {
1371     my $self = shift;
1372     my $next = $self-&gt;nextToken();
1373     if ($next-&gt;value() eq &quot;-&quot;) {
1374         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;-&quot;, __LINE__);
1375         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;Infinity&quot;, __LINE__);
1376         return &quot;-Infinity&quot;;
1377     }
1378     if ($next-&gt;value() eq &quot;Infinity&quot;) {
1379         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;Infinity&quot;, __LINE__);
1380         return &quot;Infinity&quot;;
1381     }
1382     if ($next-&gt;value() eq &quot;NaN&quot;) {
1383         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;NaN&quot;, __LINE__);
1384         return &quot;NaN&quot;;
1385     }
1386     if ($next-&gt;type() == FloatToken) {
1387         return $self-&gt;getToken()-&gt;value();
1388     }
1389     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1390 }
1391 
1392 sub parseOperationOrReadWriteAttributeOrMaplike
1393 {
1394     my $self = shift;
1395     my $extendedAttributeList = shift;
1396 
1397     my $next = $self-&gt;nextToken();
1398     if ($next-&gt;value() =~ /$nextAttribute_1/) {
1399         return $self-&gt;parseReadWriteAttribute($extendedAttributeList);
1400     }
1401     if ($next-&gt;value() eq &quot;maplike&quot;) {
1402         return $self-&gt;parseMapLikeRest($extendedAttributeList, 0);
1403     }
1404     if ($next-&gt;value() eq &quot;setlike&quot;) {
1405         return $self-&gt;parseSetLikeRest($extendedAttributeList, 0);
1406     }
1407     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextOperation_1/) {
1408         return $self-&gt;parseOperation($extendedAttributeList);
1409     }
1410     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1411 }
1412 
1413 sub parseReadOnlyMember
1414 {
1415     my $self = shift;
1416     my $extendedAttributeList = shift;
1417 
1418     my $next = $self-&gt;nextToken();
1419     if ($next-&gt;value() eq &quot;readonly&quot;) {
1420         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;readonly&quot;, __LINE__);
1421 
1422         my $next = $self-&gt;nextToken();
1423         if ($next-&gt;value() eq &quot;attribute&quot;) {
1424             my $attribute = $self-&gt;parseAttributeRest($extendedAttributeList);
1425             $attribute-&gt;isReadOnly(1);
1426             return $attribute;
1427         }
1428         if ($next-&gt;value() eq &quot;maplike&quot;) {
1429             return $self-&gt;parseMapLikeRest($extendedAttributeList, 1);
1430         }
1431         if ($next-&gt;value() eq &quot;setlike&quot;) {
1432             return $self-&gt;parseSetLikeRest($extendedAttributeList, 1);
1433         }
1434     }
1435     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1436 }
1437 
1438 sub parseSerializer
1439 {
1440     my $self = shift;
1441     my $extendedAttributeList = shift;
1442 
1443     my $next = $self-&gt;nextToken();
1444     if ($next-&gt;value() eq &quot;serializer&quot;) {
1445         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;serializer&quot;, __LINE__);
1446         my $next = $self-&gt;nextToken();
1447         my $newDataNode;
1448         if ($next-&gt;value() ne &quot;;&quot;) {
1449             $newDataNode = $self-&gt;parseSerializerRest($extendedAttributeList);
1450             my $next = $self-&gt;nextToken();
1451         } else {
1452             $newDataNode = IDLSerializable-&gt;new();
1453         }
1454 
1455         my $toJSONOperation = IDLOperation-&gt;new();
1456         $toJSONOperation-&gt;name(&quot;toJSON&quot;);
1457 
1458         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;operation&quot;);
1459         $toJSONOperation-&gt;extendedAttributes($extendedAttributeList);
1460         $toJSONOperation-&gt;isSerializer(1);
1461         push(@{$newDataNode-&gt;operations}, $toJSONOperation);
1462 
1463         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1464         return $newDataNode;
1465     }
1466     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1467 }
1468 
1469 sub parseSerializerRest
1470 {
1471     my $self = shift;
1472     my $extendedAttributeList = shift;
1473 
1474     my $next = $self-&gt;nextToken();
1475     if ($next-&gt;value() eq &quot;=&quot;) {
1476         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;=&quot;, __LINE__);
1477 
1478         return $self-&gt;parseSerializationPattern();
1479 
1480     }
1481     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() eq &quot;(&quot;) {
1482         return $self-&gt;parseOperationRest($extendedAttributeList);
1483     }
1484 }
1485 
1486 sub parseSerializationPattern
1487 {
1488     my $self = shift;
1489 
1490     my $next = $self-&gt;nextToken();
1491     if ($next-&gt;value() eq &quot;{&quot;) {
1492         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;{&quot;, __LINE__);
1493         my $newDataNode = IDLSerializable-&gt;new();
1494         $self-&gt;parseSerializationAttributes($newDataNode);
1495         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;}&quot;, __LINE__);
1496         return $newDataNode;
1497     }
1498     if ($next-&gt;value() eq &quot;[&quot;) {
1499         die &quot;Serialization of lists pattern is not currently supported.&quot;;
1500     }
1501     if ($next-&gt;type() == IdentifierToken) {
1502         my @attributes = ();
1503         my $token = $self-&gt;getToken();
1504         $self-&gt;assertTokenType($token, IdentifierToken);
1505         push(@attributes, $token-&gt;value());
1506 
1507         my $newDataNode = IDLSerializable-&gt;new();
1508         $newDataNode-&gt;attributes(\@attributes);
1509 
1510         return $newDataNode;
1511     }
1512     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1513 }
1514 
1515 sub parseSerializationAttributes
1516 {
1517     my $self = shift;
1518     my $serializable = shift;
1519 
1520     my @attributes = ();
1521     my @identifiers = $self-&gt;parseIdentifierList();
1522 
1523     for my $identifier (@identifiers) {
1524         if ($identifier eq &quot;getter&quot;) {
1525             $serializable-&gt;hasGetter(1);
1526             die &quot;Serializer getter keyword is not currently supported.&quot;;
1527         }
1528 
1529         if ($identifier eq &quot;inherit&quot;) {
1530             $serializable-&gt;hasInherit(1);
1531             next;
1532         }
1533 
1534         if ($identifier eq &quot;attribute&quot;) {
1535             $serializable-&gt;hasAttribute(1);
1536             # Attributes will be filled in via applyMemberList()
1537             next;
1538         }
1539 
1540         push(@attributes, $identifier);
1541     }
1542 
1543     $serializable-&gt;attributes(\@attributes);
1544 }
1545 
1546 sub parseIdentifierList
1547 {
1548     my $self = shift;
1549     my $next = $self-&gt;nextToken();
1550 
1551     my @identifiers = ();
1552     if ($next-&gt;type == IdentifierToken) {
1553         push(@identifiers, $self-&gt;getToken()-&gt;value());
1554         push(@identifiers, @{$self-&gt;parseIdentifiers()});
1555     }
1556     return @identifiers;
1557 }
1558 
1559 sub parseIdentifiers
1560 {
1561     my $self = shift;
1562     my @idents = ();
1563 
1564     while (1) {
1565         my $next = $self-&gt;nextToken();
1566         if ($next-&gt;value() eq &quot;,&quot;) {
1567             $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
1568             my $token = $self-&gt;getToken();
1569             $self-&gt;assertTokenType($token, IdentifierToken);
1570             push(@idents, $token-&gt;value());
1571         } else {
1572             last;
1573         }
1574     }
1575     return \@idents;
1576 }
1577 
1578 sub parseStringifier
1579 {
1580     my $self = shift;
1581     my $extendedAttributeList = shift;
1582 
1583     my $next = $self-&gt;nextToken();
1584     if ($next-&gt;value() eq &quot;stringifier&quot;) {
1585         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;stringifier&quot;, __LINE__);
1586 
1587         $next = $self-&gt;nextToken();
1588         if ($next-&gt;value() eq &quot;;&quot;) {
1589             $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1590 
1591             my $operation = IDLOperation-&gt;new();
1592             $operation-&gt;isStringifier(1);
1593             $operation-&gt;name(&quot;&quot;);
1594             $operation-&gt;type(makeSimpleType(&quot;DOMString&quot;));
1595             $operation-&gt;extendedAttributes($extendedAttributeList);
1596 
1597             return $operation;
1598         } else {
1599             my $attributeOrOperation = $self-&gt;parseAttributeOrOperationForStringifierOrStatic($extendedAttributeList);
1600             $attributeOrOperation-&gt;isStringifier(1);
1601 
1602             return $attributeOrOperation;
1603         }
1604     }
1605     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1606 }
1607 
1608 sub parseStaticMember
1609 {
1610     my $self = shift;
1611     my $extendedAttributeList = shift;
1612 
1613     my $next = $self-&gt;nextToken();
1614     if ($next-&gt;value() eq &quot;static&quot;) {
1615         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;static&quot;, __LINE__);
1616 
1617         my $attributeOrOperation = $self-&gt;parseAttributeOrOperationForStringifierOrStatic($extendedAttributeList);
1618         $attributeOrOperation-&gt;isStatic(1);
1619 
1620         return $attributeOrOperation;
1621     }
1622     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1623 }
1624 
1625 sub parseAttributeOrOperationForStringifierOrStatic
1626 {
1627     my $self = shift;
1628     my $extendedAttributeList = shift;
1629 
1630     my $next = $self-&gt;nextToken();
1631     if ($next-&gt;value() =~ /$nextAttribute_2/) {
1632         my $isReadOnly = $self-&gt;parseReadOnly();
1633 
1634         my $attribute = $self-&gt;parseAttributeRest($extendedAttributeList);
1635         $attribute-&gt;isReadOnly($isReadOnly);
1636 
1637         return $attribute;
1638     }
1639 
1640     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextOperationRest_1/) {
1641         my $returnType = $self-&gt;parseReturnType();
1642 
1643         # NOTE: This is a non-standard addition. In WebIDL, there is no way to associate
1644         # extended attributes with a return type.
1645         $self-&gt;moveExtendedAttributesApplicableToTypes($returnType, $extendedAttributeList);
1646 
1647         my $operation = $self-&gt;parseOperationRest($extendedAttributeList);
1648         $operation-&gt;type($returnType);
1649 
1650         return $operation;
1651     }
1652     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1653 }
1654 
1655 sub parseReadWriteAttribute
1656 {
1657     my $self = shift;
1658     my $extendedAttributeList = shift;
1659 
1660     my $next = $self-&gt;nextToken();
1661     if ($next-&gt;value() eq &quot;inherit&quot;) {
1662         my $isInherit = $self-&gt;parseInherit();
1663         my $isReadOnly = $self-&gt;parseReadOnly();
1664 
1665         my $attribute = $self-&gt;parseAttributeRest($extendedAttributeList);
1666 
1667         $attribute-&gt;isInherit($isInherit);
1668         $attribute-&gt;isReadOnly($isReadOnly);
1669 
1670         return $attribute;
1671     } else {
1672         return $self-&gt;parseAttributeRest($extendedAttributeList);
1673     }
1674     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1675 }
1676 
1677 sub parseAttributeRest
1678 {
1679     my $self = shift;
1680     my $extendedAttributeList = shift;
1681 
1682     my $next = $self-&gt;nextToken();
1683     if ($next-&gt;value() eq &quot;attribute&quot;) {
1684         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;attribute&quot;, __LINE__);
1685 
1686         my $attribute = IDLAttribute-&gt;new();
1687         
1688         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;attribute&quot;);
1689         $attribute-&gt;extendedAttributes($extendedAttributeList);
1690 
1691         my $type = $self-&gt;parseTypeWithExtendedAttributes();
1692         $attribute-&gt;type($type);
1693 
1694         my $token = $self-&gt;getToken();
1695         $self-&gt;assertTokenType($token, IdentifierToken);
1696         $attribute-&gt;name(identifierRemoveNullablePrefix($token-&gt;value()));
1697         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1698 
1699         return $attribute;
1700     }
1701     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1702 }
1703 
1704 sub parseInherit
1705 {
1706     my $self = shift;
1707     my $next = $self-&gt;nextToken();
1708     if ($next-&gt;value() eq &quot;inherit&quot;) {
1709         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;inherit&quot;, __LINE__);
1710         return 1;
1711     }
1712     return 0;
1713 }
1714 
1715 sub parseReadOnly
1716 {
1717     my $self = shift;
1718     my $next = $self-&gt;nextToken();
1719     if ($next-&gt;value() eq &quot;readonly&quot;) {
1720         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;readonly&quot;, __LINE__);
1721         return 1;
1722     }
1723     return 0;
1724 }
1725 
1726 sub parseOperation
1727 {
1728     my $self = shift;
1729     my $extendedAttributeList = shift;
1730     my $isReadOnly = shift;
1731 
1732     my $next = $self-&gt;nextToken();
1733     if ($next-&gt;value() =~ /$nextSpecials_1/) {
1734         return $self-&gt;parseSpecialOperation($extendedAttributeList);
1735     }
1736     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextOperationRest_1/) {
1737         my $returnType = $self-&gt;parseReturnType();
1738 
1739         # NOTE: This is a non-standard addition. In WebIDL, there is no way to associate
1740         # extended attributes with a return type.
1741         $self-&gt;moveExtendedAttributesApplicableToTypes($returnType, $extendedAttributeList);
1742 
1743         my $operation = $self-&gt;parseOperationRest($extendedAttributeList);
1744         $operation-&gt;type($returnType);
1745 
1746         return $operation;
1747     }
1748     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1749 }
1750 
1751 sub parseSpecialOperation
1752 {
1753     my $self = shift;
1754     my $extendedAttributeList = shift;
1755 
1756     my $next = $self-&gt;nextToken();
1757     if ($next-&gt;value() =~ /$nextSpecials_1/) {
1758         my @specials = ();
1759         push(@specials, @{$self-&gt;parseSpecials()});
1760         my $returnType = $self-&gt;parseReturnType();
1761 
1762         # NOTE: This is a non-standard addition. In WebIDL, there is no way to associate
1763         # extended attributes with a return type.
1764         $self-&gt;moveExtendedAttributesApplicableToTypes($returnType, $extendedAttributeList);
1765 
1766         my $operation = $self-&gt;parseOperationRest($extendedAttributeList);
1767         $operation-&gt;type($returnType);
1768         $operation-&gt;specials(\@specials);
1769 
1770         return $operation;
1771     }
1772     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1773 }
1774 
1775 sub parseSpecials
1776 {
1777     my $self = shift;
1778     my @specials = ();
1779 
1780     while (1) {
1781         my $next = $self-&gt;nextToken();
1782         if ($next-&gt;value() =~ /$nextSpecials_1/) {
1783             push(@specials, $self-&gt;parseSpecial());
1784         } else {
1785             last;
1786         }
1787     }
1788     return \@specials;
1789 }
1790 
1791 sub parseSpecial
1792 {
1793     my $self = shift;
1794     my $next = $self-&gt;nextToken();
1795     if ($next-&gt;value() eq &quot;getter&quot;) {
1796         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;getter&quot;, __LINE__);
1797         return &quot;getter&quot;;
1798     }
1799     if ($next-&gt;value() eq &quot;setter&quot;) {
1800         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;setter&quot;, __LINE__);
1801         return &quot;setter&quot;;
1802     }
1803     if ($next-&gt;value() eq &quot;deleter&quot;) {
1804         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;deleter&quot;, __LINE__);
1805         return &quot;deleter&quot;;
1806     }
1807     if ($next-&gt;value() eq &quot;legacycaller&quot;) {
1808         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;legacycaller&quot;, __LINE__);
1809         return &quot;legacycaller&quot;;
1810     }
1811     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1812 }
1813 
1814 sub parseIterableRest
1815 {
1816     my $self = shift;
1817     my $extendedAttributeList = shift;
1818 
1819     my $next = $self-&gt;nextToken();
1820     if ($next-&gt;value() eq &quot;iterable&quot;) {
1821         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;iterable&quot;, __LINE__);
1822         my $iterableNode = $self-&gt;parseOptionalIterableInterface($extendedAttributeList);
1823         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1824         return $iterableNode;
1825     }
1826     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1827 }
1828 
1829 sub parseOptionalIterableInterface
1830 {
1831     my $self = shift;
1832     my $extendedAttributeList = shift;
1833 
1834     my $newDataNode = IDLIterable-&gt;new();
1835 
1836     $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;iterable&quot;);
1837     $newDataNode-&gt;extendedAttributes($extendedAttributeList);
1838 
1839     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
1840     my $type1 = $self-&gt;parseTypeWithExtendedAttributes();
1841 
1842     if ($self-&gt;nextToken()-&gt;value() eq &quot;,&quot;) {
1843         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
1844 
1845         my $type2 = $self-&gt;parseTypeWithExtendedAttributes();
1846         $newDataNode-&gt;isKeyValue(1);
1847         $newDataNode-&gt;keyType($type1);
1848         $newDataNode-&gt;valueType($type2);
1849     } else {
1850         $newDataNode-&gt;isKeyValue(0);
1851         $newDataNode-&gt;valueType($type1);
1852     }
1853     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
1854 
1855     my $symbolIteratorOperation = IDLOperation-&gt;new();
1856     $symbolIteratorOperation-&gt;name(&quot;[Symbol.Iterator]&quot;);
1857     $symbolIteratorOperation-&gt;extendedAttributes($extendedAttributeList);
1858     $symbolIteratorOperation-&gt;isIterable(1);
1859 
1860     my $entriesOperation = IDLOperation-&gt;new();
1861     $entriesOperation-&gt;name(&quot;entries&quot;);
1862     $entriesOperation-&gt;extendedAttributes($extendedAttributeList);
1863     $entriesOperation-&gt;isIterable(1);
1864 
1865     my $keysOperation = IDLOperation-&gt;new();
1866     $keysOperation-&gt;name(&quot;keys&quot;);
1867     $keysOperation-&gt;extendedAttributes($extendedAttributeList);
1868     $keysOperation-&gt;isIterable(1);
1869 
1870     my $valuesOperation = IDLOperation-&gt;new();
1871     $valuesOperation-&gt;name(&quot;values&quot;);
1872     $valuesOperation-&gt;extendedAttributes($extendedAttributeList);
1873     $valuesOperation-&gt;isIterable(1);
1874 
1875     my $forEachOperation = IDLOperation-&gt;new();
1876     $forEachOperation-&gt;name(&quot;forEach&quot;);
1877     $forEachOperation-&gt;extendedAttributes($extendedAttributeList);
1878     $forEachOperation-&gt;isIterable(1);
1879     my $forEachArgument = IDLArgument-&gt;new();
1880     $forEachArgument-&gt;name(&quot;callback&quot;);
1881     $forEachArgument-&gt;type(makeSimpleType(&quot;any&quot;));
1882     push(@{$forEachOperation-&gt;arguments}, ($forEachArgument));
1883 
1884     push(@{$newDataNode-&gt;operations}, $symbolIteratorOperation);
1885     push(@{$newDataNode-&gt;operations}, $entriesOperation);
1886     push(@{$newDataNode-&gt;operations}, $keysOperation);
1887     push(@{$newDataNode-&gt;operations}, $valuesOperation);
1888     push(@{$newDataNode-&gt;operations}, $forEachOperation);
1889 
1890     return $newDataNode;
1891 }
1892 
1893 sub parseMapLikeRest
1894 {
1895     my $self = shift;
1896     my $extendedAttributeList = shift;
1897     my $isReadOnly = shift;
1898 
1899     my $next = $self-&gt;nextToken();
1900     if ($next-&gt;value() eq &quot;maplike&quot;) {
1901         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;maplike&quot;, __LINE__);
1902         my $mapLikeNode = $self-&gt;parseMapLikeProperties($extendedAttributeList, $isReadOnly);
1903         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
1904         return $mapLikeNode;
1905     }
1906     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
1907 }
1908 
1909 sub parseMapLikeProperties
1910 {
1911     my $self = shift;
1912     my $extendedAttributeList = shift;
1913     my $isReadOnly = shift;
1914 
1915     my $maplike = IDLMapLike-&gt;new();
1916     $maplike-&gt;extendedAttributes($extendedAttributeList);
1917     $maplike-&gt;isReadOnly($isReadOnly);
1918 
1919     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
1920     $maplike-&gt;keyType($self-&gt;parseTypeWithExtendedAttributes());
1921     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
1922     $maplike-&gt;valueType($self-&gt;parseTypeWithExtendedAttributes());
1923     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
1924 
1925     # FIXME: Synthetic operations should not be added during parsing. Instead, the CodeGenerator
1926     # should be responsible for them.
1927 
1928     my $notEnumerableExtendedAttributeList = $extendedAttributeList;
1929     $notEnumerableExtendedAttributeList-&gt;{NotEnumerable} = 1;
1930 
1931     my $sizeAttribute = IDLAttribute-&gt;new();
1932     $sizeAttribute-&gt;name(&quot;size&quot;);
1933     $sizeAttribute-&gt;isMapLike(1);
1934     $sizeAttribute-&gt;extendedAttributes($extendedAttributeList);
1935     $sizeAttribute-&gt;isReadOnly(1);
1936     $sizeAttribute-&gt;type(makeSimpleType(&quot;any&quot;));
1937     push(@{$maplike-&gt;attributes}, $sizeAttribute);
1938 
1939     my $getOperation = IDLOperation-&gt;new();
1940     $getOperation-&gt;name(&quot;get&quot;);
1941     $getOperation-&gt;isMapLike(1);
1942     my $getArgument = IDLArgument-&gt;new();
1943     $getArgument-&gt;name(&quot;key&quot;);
1944     $getArgument-&gt;type($maplike-&gt;keyType);
1945     $getArgument-&gt;extendedAttributes($extendedAttributeList);
1946     push(@{$getOperation-&gt;arguments}, ($getArgument));
1947     $getOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1948     $getOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1949 
1950     my $hasOperation = IDLOperation-&gt;new();
1951     $hasOperation-&gt;name(&quot;has&quot;);
1952     $hasOperation-&gt;isMapLike(1);
1953     my $hasArgument = IDLArgument-&gt;new();
1954     $hasArgument-&gt;name(&quot;key&quot;);
1955     $hasArgument-&gt;type($maplike-&gt;keyType);
1956     $hasArgument-&gt;extendedAttributes($extendedAttributeList);
1957     push(@{$hasOperation-&gt;arguments}, ($hasArgument));
1958     $hasOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1959     $hasOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1960 
1961     my $entriesOperation = IDLOperation-&gt;new();
1962     $entriesOperation-&gt;name(&quot;entries&quot;);
1963     $entriesOperation-&gt;isMapLike(1);
1964     $entriesOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1965     $entriesOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1966 
1967     my $keysOperation = IDLOperation-&gt;new();
1968     $keysOperation-&gt;name(&quot;keys&quot;);
1969     $keysOperation-&gt;isMapLike(1);
1970     $keysOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
1971     $keysOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1972 
1973     my $valuesOperation = IDLOperation-&gt;new();
1974     $valuesOperation-&gt;name(&quot;values&quot;);
1975     $valuesOperation-&gt;isMapLike(1);
1976     $valuesOperation-&gt;extendedAttributes($extendedAttributeList);
1977     $valuesOperation-&gt;extendedAttributes-&gt;{NotEnumerable} = 1;
1978     $valuesOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1979 
1980     my $forEachOperation = IDLOperation-&gt;new();
1981     $forEachOperation-&gt;name(&quot;forEach&quot;);
1982     $forEachOperation-&gt;isMapLike(1);
1983     $forEachOperation-&gt;extendedAttributes({});
1984     $forEachOperation-&gt;type(makeSimpleType(&quot;any&quot;));
1985     my $forEachArgument = IDLArgument-&gt;new();
1986     $forEachArgument-&gt;name(&quot;callback&quot;);
1987     $forEachArgument-&gt;type(makeSimpleType(&quot;any&quot;));
1988     $forEachArgument-&gt;extendedAttributes($extendedAttributeList);
1989     push(@{$forEachOperation-&gt;arguments}, ($forEachArgument));
1990 
1991     push(@{$maplike-&gt;operations}, $getOperation);
1992     push(@{$maplike-&gt;operations}, $hasOperation);
1993     push(@{$maplike-&gt;operations}, $entriesOperation);
1994     push(@{$maplike-&gt;operations}, $keysOperation);
1995     push(@{$maplike-&gt;operations}, $valuesOperation);
1996     push(@{$maplike-&gt;operations}, $forEachOperation);
1997 
1998     return $maplike if $isReadOnly;
1999 
2000     my $setOperation = IDLOperation-&gt;new();
2001     $setOperation-&gt;name(&quot;set&quot;);
2002     $setOperation-&gt;isMapLike(1);
2003     my $setKeyArgument = IDLArgument-&gt;new();
2004     $setKeyArgument-&gt;name(&quot;key&quot;);
2005     $setKeyArgument-&gt;type($maplike-&gt;keyType);
2006     $setKeyArgument-&gt;extendedAttributes($extendedAttributeList);
2007     my $setValueArgument = IDLArgument-&gt;new();
2008     $setValueArgument-&gt;name(&quot;value&quot;);
2009     $setValueArgument-&gt;type($maplike-&gt;valueType);
2010     $setValueArgument-&gt;extendedAttributes($extendedAttributeList);
2011     push(@{$setOperation-&gt;arguments}, ($setKeyArgument));
2012     push(@{$setOperation-&gt;arguments}, ($setValueArgument));
2013     $setOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
2014     $setOperation-&gt;type(makeSimpleType(&quot;any&quot;));
2015 
2016     my $clearOperation = IDLOperation-&gt;new();
2017     $clearOperation-&gt;name(&quot;clear&quot;);
2018     $clearOperation-&gt;isMapLike(1);
2019     $clearOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
2020     $clearOperation-&gt;type(makeSimpleType(&quot;void&quot;));
2021 
2022     my $deleteOperation = IDLOperation-&gt;new();
2023     $deleteOperation-&gt;name(&quot;delete&quot;);
2024     $deleteOperation-&gt;isMapLike(1);
2025     my $deleteArgument = IDLArgument-&gt;new();
2026     $deleteArgument-&gt;name(&quot;key&quot;);
2027     $deleteArgument-&gt;type($maplike-&gt;keyType);
2028     $deleteArgument-&gt;extendedAttributes($extendedAttributeList);
2029     push(@{$deleteOperation-&gt;arguments}, ($deleteArgument));
2030     $deleteOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
2031     $deleteOperation-&gt;type(makeSimpleType(&quot;any&quot;));
2032 
2033     push(@{$maplike-&gt;operations}, $setOperation);
2034     push(@{$maplike-&gt;operations}, $clearOperation);
2035     push(@{$maplike-&gt;operations}, $deleteOperation);
2036 
2037     return $maplike;
2038 }
2039 
2040 sub parseSetLikeRest
2041 {
2042     my $self = shift;
2043     my $extendedAttributeList = shift;
2044     my $isReadOnly = shift;
2045 
2046     my $next = $self-&gt;nextToken();
2047     if ($next-&gt;value() eq &quot;setlike&quot;) {
2048         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;setlike&quot;, __LINE__);
2049         my $setLikeNode = $self-&gt;parseSetLikeProperties($extendedAttributeList, $isReadOnly);
2050         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
2051         return $setLikeNode;
2052     }
2053     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2054 }
2055 
2056 sub parseSetLikeProperties
2057 {
2058     my $self = shift;
2059     my $extendedAttributeList = shift;
2060     my $isReadOnly = shift;
2061 
2062     my $setlike = IDLSetLike-&gt;new();
2063     $setlike-&gt;extendedAttributes($extendedAttributeList);
2064 
2065     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
2066     $setlike-&gt;itemType($self-&gt;parseTypeWithExtendedAttributes());
2067     $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
2068 
2069     # FIXME: Synthetic operations should not be added during parsing. Instead, the CodeGenerator
2070     # should be responsible for them.
2071 
2072     my $notEnumerableExtendedAttributeList = $extendedAttributeList;
2073     $notEnumerableExtendedAttributeList-&gt;{NotEnumerable} = 1;
2074 
2075     my $sizeAttribute = IDLAttribute-&gt;new();
2076     $sizeAttribute-&gt;name(&quot;size&quot;);
2077     $sizeAttribute-&gt;isSetLike(1);
2078     $sizeAttribute-&gt;extendedAttributes($extendedAttributeList);
2079     $sizeAttribute-&gt;isReadOnly(1);
2080     $sizeAttribute-&gt;type(makeSimpleType(&quot;any&quot;));
2081     push(@{$setlike-&gt;attributes}, $sizeAttribute);
2082 
2083     my $hasOperation = IDLOperation-&gt;new();
2084     $hasOperation-&gt;name(&quot;has&quot;);
2085     $hasOperation-&gt;isSetLike(1);
2086     my $hasArgument = IDLArgument-&gt;new();
2087     $hasArgument-&gt;name(&quot;key&quot;);
2088     $hasArgument-&gt;type($setlike-&gt;itemType);
2089     $hasArgument-&gt;extendedAttributes($extendedAttributeList);
2090     push(@{$hasOperation-&gt;arguments}, ($hasArgument));
2091     $hasOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
2092     $hasOperation-&gt;type(makeSimpleType(&quot;any&quot;));
2093 
2094     my $entriesOperation = IDLOperation-&gt;new();
2095     $entriesOperation-&gt;name(&quot;entries&quot;);
2096     $entriesOperation-&gt;isSetLike(1);
2097     $entriesOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
2098     $entriesOperation-&gt;type(makeSimpleType(&quot;any&quot;));
2099 
2100     my $keysOperation = IDLOperation-&gt;new();
2101     $keysOperation-&gt;name(&quot;keys&quot;);
2102     $keysOperation-&gt;isSetLike(1);
2103     $keysOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
2104     $keysOperation-&gt;type(makeSimpleType(&quot;any&quot;));
2105 
2106     my $valuesOperation = IDLOperation-&gt;new();
2107     $valuesOperation-&gt;name(&quot;values&quot;);
2108     $valuesOperation-&gt;isSetLike(1);
2109     $valuesOperation-&gt;extendedAttributes($extendedAttributeList);
2110     $valuesOperation-&gt;extendedAttributes-&gt;{NotEnumerable} = 1;
2111     $valuesOperation-&gt;type(makeSimpleType(&quot;any&quot;));
2112 
2113     my $forEachOperation = IDLOperation-&gt;new();
2114     $forEachOperation-&gt;name(&quot;forEach&quot;);
2115     $forEachOperation-&gt;isSetLike(1);
2116     my $forEachArgument = IDLArgument-&gt;new();
2117     $forEachArgument-&gt;name(&quot;callback&quot;);
2118     $forEachArgument-&gt;type(makeSimpleType(&quot;any&quot;));
2119     $forEachArgument-&gt;extendedAttributes($extendedAttributeList);
2120     push(@{$forEachOperation-&gt;arguments}, ($forEachArgument));
2121     $forEachOperation-&gt;extendedAttributes($extendedAttributeList);
2122     $forEachOperation-&gt;extendedAttributes-&gt;{Enumerable} = 1;
2123     $forEachOperation-&gt;type(makeSimpleType(&quot;any&quot;));
2124 
2125     push(@{$setlike-&gt;operations}, $hasOperation);
2126     push(@{$setlike-&gt;operations}, $entriesOperation);
2127     push(@{$setlike-&gt;operations}, $keysOperation);
2128     push(@{$setlike-&gt;operations}, $valuesOperation);
2129     push(@{$setlike-&gt;operations}, $forEachOperation);
2130 
2131     return $setlike if $isReadOnly;
2132 
2133     my $addOperation = IDLOperation-&gt;new();
2134     $addOperation-&gt;name(&quot;add&quot;);
2135     $addOperation-&gt;isSetLike(1);
2136     my $addArgument = IDLArgument-&gt;new();
2137     $addArgument-&gt;name(&quot;key&quot;);
2138     $addArgument-&gt;type($setlike-&gt;itemType);
2139     $addArgument-&gt;extendedAttributes($extendedAttributeList);
2140     push(@{$addOperation-&gt;arguments}, ($addArgument));
2141     $addOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
2142     $addOperation-&gt;type(makeSimpleType(&quot;any&quot;));
2143 
2144     my $clearOperation = IDLOperation-&gt;new();
2145     $clearOperation-&gt;name(&quot;clear&quot;);
2146     $clearOperation-&gt;isSetLike(1);
2147     $clearOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
2148     $clearOperation-&gt;type(makeSimpleType(&quot;void&quot;));
2149 
2150     my $deleteOperation = IDLOperation-&gt;new();
2151     $deleteOperation-&gt;name(&quot;delete&quot;);
2152     $deleteOperation-&gt;isSetLike(1);
2153     my $deleteArgument = IDLArgument-&gt;new();
2154     $deleteArgument-&gt;name(&quot;key&quot;);
2155     $deleteArgument-&gt;type($setlike-&gt;itemType);
2156     $deleteArgument-&gt;extendedAttributes($extendedAttributeList);
2157     push(@{$deleteOperation-&gt;arguments}, ($deleteArgument));
2158     $deleteOperation-&gt;extendedAttributes($notEnumerableExtendedAttributeList);
2159     $deleteOperation-&gt;type(makeSimpleType(&quot;any&quot;));
2160 
2161     push(@{$setlike-&gt;operations}, $addOperation);
2162     push(@{$setlike-&gt;operations}, $clearOperation);
2163     push(@{$setlike-&gt;operations}, $deleteOperation);
2164 
2165     return $setlike;
2166 }
2167 
2168 sub parseOperationRest
2169 {
2170     my $self = shift;
2171     my $extendedAttributeList = shift;
2172 
2173     my $next = $self-&gt;nextToken();
2174     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() eq &quot;(&quot;) {
2175         my $operation = IDLOperation-&gt;new();
2176 
2177         my $name = $self-&gt;parseOptionalIdentifier();
2178         $operation-&gt;name(identifierRemoveNullablePrefix($name));
2179 
2180         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, $name, __LINE__);
2181 
2182         push(@{$operation-&gt;arguments}, @{$self-&gt;parseArgumentList()});
2183 
2184         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2185         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
2186 
2187         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;operation&quot;);
2188         $operation-&gt;extendedAttributes($extendedAttributeList);
2189 
2190         return $operation;
2191     }
2192     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2193 }
2194 
2195 sub parseOptionalIdentifier
2196 {
2197     my $self = shift;
2198     my $next = $self-&gt;nextToken();
2199     if ($next-&gt;type() == IdentifierToken) {
2200         my $token = $self-&gt;getToken();
2201         return $token-&gt;value();
2202     }
2203     return &quot;&quot;;
2204 }
2205 
2206 sub parseArgumentList
2207 {
2208     my $self = shift;
2209     my @arguments = ();
2210 
2211     my $next = $self-&gt;nextToken();
2212     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextArgumentList_1/) {
2213         push(@arguments, $self-&gt;parseArgument());
2214         push(@arguments, @{$self-&gt;parseArguments()});
2215     }
2216     return \@arguments;
2217 }
2218 
2219 sub parseArguments
2220 {
2221     my $self = shift;
2222     my @arguments = ();
2223 
2224     while (1) {
2225         my $next = $self-&gt;nextToken();
2226         if ($next-&gt;value() eq &quot;,&quot;) {
2227             $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
2228             push(@arguments, $self-&gt;parseArgument());
2229         } else {
2230             last;
2231         }
2232     }
2233     return \@arguments;
2234 }
2235 
2236 sub parseArgument
2237 {
2238     my $self = shift;
2239     my $next = $self-&gt;nextToken();
2240     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextArgumentList_1/) {
2241         my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
2242         my $argument = $self-&gt;parseOptionalOrRequiredArgument($extendedAttributeList);
2243         return $argument;
2244     }
2245     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2246 }
2247 
2248 sub parseOptionalOrRequiredArgument
2249 {
2250     my $self = shift;
2251     my $extendedAttributeList = shift;
2252 
2253     my $argument = IDLArgument-&gt;new();
2254 
2255     my $next = $self-&gt;nextToken();
2256     if ($next-&gt;value() eq &quot;optional&quot;) {
2257         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;optional&quot;, __LINE__);
2258 
2259         my $type = $self-&gt;parseTypeWithExtendedAttributes();
2260         $argument-&gt;type($type);
2261         $argument-&gt;isOptional(1);
2262         $argument-&gt;name($self-&gt;parseArgumentName());
2263         $argument-&gt;default($self-&gt;parseDefault());
2264 
2265         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;argument&quot;);
2266         $argument-&gt;extendedAttributes($extendedAttributeList);
2267 
2268         return $argument;
2269     }
2270     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
2271         my $type = $self-&gt;parseType();
2272         $self-&gt;moveExtendedAttributesApplicableToTypes($type, $extendedAttributeList);
2273 
2274         $argument-&gt;type($type);
2275         $argument-&gt;isOptional(0);
2276         $argument-&gt;isVariadic($self-&gt;parseEllipsis());
2277         $argument-&gt;name($self-&gt;parseArgumentName());
2278 
2279         $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;argument&quot;);
2280         $argument-&gt;extendedAttributes($extendedAttributeList);
2281 
2282         return $argument;
2283     }
2284     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2285 }
2286 
2287 sub parseArgumentName
2288 {
2289     my $self = shift;
2290     my $next = $self-&gt;nextToken();
2291     if ($next-&gt;value() =~ /$nextArgumentName_1/) {
2292         return $self-&gt;parseArgumentNameKeyword();
2293     }
2294     if ($next-&gt;type() == IdentifierToken) {
2295         return $self-&gt;getToken()-&gt;value();
2296     }
2297     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2298 }
2299 
2300 sub parseEllipsis
2301 {
2302     my $self = shift;
2303     my $next = $self-&gt;nextToken();
2304     if ($next-&gt;value() eq &quot;...&quot;) {
2305         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;...&quot;, __LINE__);
2306         return 1;
2307     }
2308     return 0;
2309 }
2310 
2311 sub parseExceptionMember
2312 {
2313     my $self = shift;
2314     my $extendedAttributeList = shift;
2315 
2316     my $next = $self-&gt;nextToken();
2317     if ($next-&gt;value() eq &quot;const&quot;) {
2318         return $self-&gt;parseConst($extendedAttributeList);
2319     }
2320     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
2321         return $self-&gt;parseExceptionField($extendedAttributeList);
2322     }
2323     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2324 }
2325 
2326 sub parseExceptionField
2327 {
2328     my $self = shift;
2329     my $extendedAttributeList = shift;
2330 
2331     my $next = $self-&gt;nextToken();
2332     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
2333         my $newDataNode = IDLAttribute-&gt;new();
2334         $newDataNode-&gt;isReadOnly(1);
2335 
2336         my $type = $self-&gt;parseType();
2337         $newDataNode-&gt;type($type);
2338         
2339         my $token = $self-&gt;getToken();
2340         $self-&gt;assertTokenType($token, IdentifierToken);
2341         $newDataNode-&gt;name(identifierRemoveNullablePrefix($token-&gt;value()));
2342         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
2343         $newDataNode-&gt;extendedAttributes($extendedAttributeList);
2344         return $newDataNode;
2345     }
2346     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2347 }
2348 
2349 sub parseExtendedAttributeListAllowEmpty
2350 {
2351     my $self = shift;
2352     my $next = $self-&gt;nextToken();
2353     if ($next-&gt;value() eq &quot;[&quot;) {
2354         return $self-&gt;parseExtendedAttributeList();
2355     }
2356     return {};
2357 }
2358 
2359 sub parseExtendedAttributeList
2360 {
2361     my $self = shift;
2362     my $next = $self-&gt;nextToken();
2363     if ($next-&gt;value() eq &quot;[&quot;) {
2364         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;[&quot;, __LINE__);
2365         my $extendedAttributeList = {};
2366         my $attr = $self-&gt;parseExtendedAttribute();
2367         copyExtendedAttributes($extendedAttributeList, $attr);
2368         $attr = $self-&gt;parseExtendedAttributes();
2369         copyExtendedAttributes($extendedAttributeList, $attr);
2370         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;]&quot;, __LINE__);
2371         return $extendedAttributeList;
2372     }
2373     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2374 }
2375 
2376 sub parseExtendedAttributes
2377 {
2378     my $self = shift;
2379     my $extendedAttributeList = {};
2380 
2381     while (1) {
2382         my $next = $self-&gt;nextToken();
2383         if ($next-&gt;value() eq &quot;,&quot;) {
2384             $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
2385             my $attr = $self-&gt;parseExtendedAttribute2();
2386             copyExtendedAttributes($extendedAttributeList, $attr);
2387         } else {
2388             last;
2389         }
2390     }
2391     return $extendedAttributeList;
2392 }
2393 
2394 sub parseExtendedAttribute
2395 {
2396     my $self = shift;
2397     my $next = $self-&gt;nextToken();
2398     if ($next-&gt;type() == IdentifierToken) {
2399         my $name = $self-&gt;parseName();
2400         return $self-&gt;parseExtendedAttributeRest($name);
2401     }
2402     # backward compatibility. Spec doesn&#39; allow &quot;[]&quot;. But WebKit requires.
2403     if ($next-&gt;value() eq &#39;]&#39;) {
2404         return {};
2405     }
2406     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2407 }
2408 
2409 sub parseExtendedAttribute2
2410 {
2411     my $self = shift;
2412     my $next = $self-&gt;nextToken();
2413     if ($next-&gt;type() == IdentifierToken) {
2414         my $name = $self-&gt;parseName();
2415         return $self-&gt;parseExtendedAttributeRest($name);
2416     }
2417     return {};
2418 }
2419 
2420 sub parseExtendedAttributeRest
2421 {
2422     my $self = shift;
2423     my $name = shift;
2424     my $attrs = {};
2425 
2426     my $next = $self-&gt;nextToken();
2427     if ($next-&gt;value() eq &quot;(&quot;) {
2428         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, __LINE__);
2429         $attrs-&gt;{$name} = $self-&gt;parseArgumentList();
2430         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2431         return $attrs;
2432     }
2433     if ($next-&gt;value() eq &quot;=&quot;) {
2434         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;=&quot;, __LINE__);
2435         $attrs-&gt;{$name} = $self-&gt;parseExtendedAttributeRest2();
2436         return $attrs;
2437     }
2438 
2439     if ($name eq &quot;Constructor&quot; || $name eq &quot;CustomConstructor&quot;) {
2440         $attrs-&gt;{$name} = [];
2441     } else {
2442         $attrs-&gt;{$name} = &quot;VALUE_IS_MISSING&quot;;
2443     }
2444     return $attrs;
2445 }
2446 
2447 sub parseExtendedAttributeRest2
2448 {
2449     my $self = shift;
2450     my $next = $self-&gt;nextToken();
2451     if ($next-&gt;value() eq &quot;(&quot;) {
2452         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, __LINE__);
2453         my @arguments = $self-&gt;parseIdentifierList();
2454         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2455         return \@arguments;
2456     }
2457     if ($next-&gt;type() == IdentifierToken) {
2458         my $name = $self-&gt;parseName();
2459         return $self-&gt;parseExtendedAttributeRest3($name);
2460     }
2461     if ($next-&gt;type() == IntegerToken) {
2462         my $token = $self-&gt;getToken();
2463         return $token-&gt;value();
2464     }
2465     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2466 }
2467 
2468 sub parseExtendedAttributeRest3
2469 {
2470     my $self = shift;
2471     my $name = shift;
2472 
2473     my $next = $self-&gt;nextToken();
2474     if ($next-&gt;value() eq &quot;&amp;&quot;) {
2475         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&amp;&quot;, __LINE__);
2476         my $rightValue = $self-&gt;parseName();
2477         return $name . &quot;&amp;&quot; . $rightValue;
2478     }
2479     if ($next-&gt;value() eq &quot;|&quot;) {
2480         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;|&quot;, __LINE__);
2481         my $rightValue = $self-&gt;parseName();
2482         return $name . &quot;|&quot; . $rightValue;
2483     }
2484     if ($next-&gt;value() eq &quot;(&quot;) {
2485         my $attr = {};
2486         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, __LINE__);
2487         $attr-&gt;{$name} = $self-&gt;parseArgumentList();
2488         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2489         return $attr;
2490     }
2491     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExtendedAttributeRest3_1/) {
2492         $self-&gt;parseNameNoComma();
2493         return $name;
2494     }
2495     $self-&gt;assertUnexpectedToken($next-&gt;value());
2496 }
2497 
2498 sub parseArgumentNameKeyword
2499 {
2500     my $self = shift;
2501     my $next = $self-&gt;nextToken();
2502     if ($next-&gt;value() eq &quot;attribute&quot;) {
2503         return $self-&gt;getToken()-&gt;value();
2504     }
2505     if ($next-&gt;value() eq &quot;callback&quot;) {
2506         return $self-&gt;getToken()-&gt;value();
2507     }
2508     if ($next-&gt;value() eq &quot;const&quot;) {
2509         return $self-&gt;getToken()-&gt;value();
2510     }
2511     if ($next-&gt;value() eq &quot;deleter&quot;) {
2512         return $self-&gt;getToken()-&gt;value();
2513     }
2514     if ($next-&gt;value() eq &quot;dictionary&quot;) {
2515         return $self-&gt;getToken()-&gt;value();
2516     }
2517     if ($next-&gt;value() eq &quot;enum&quot;) {
2518         return $self-&gt;getToken()-&gt;value();
2519     }
2520     if ($next-&gt;value() eq &quot;exception&quot;) {
2521         return $self-&gt;getToken()-&gt;value();
2522     }
2523     if ($next-&gt;value() eq &quot;getter&quot;) {
2524         return $self-&gt;getToken()-&gt;value();
2525     }
2526     if ($next-&gt;value() eq &quot;implements&quot;) {
2527         return $self-&gt;getToken()-&gt;value();
2528     }
2529     if ($next-&gt;value() eq &quot;inherit&quot;) {
2530         return $self-&gt;getToken()-&gt;value();
2531     }
2532     if ($next-&gt;value() eq &quot;interface&quot;) {
2533         return $self-&gt;getToken()-&gt;value();
2534     }
2535     if ($next-&gt;value() eq &quot;legacycaller&quot;) {
2536         return $self-&gt;getToken()-&gt;value();
2537     }
2538     if ($next-&gt;value() eq &quot;partial&quot;) {
2539         return $self-&gt;getToken()-&gt;value();
2540     }
2541     if ($next-&gt;value() eq &quot;serializer&quot;) {
2542         return $self-&gt;getToken()-&gt;value();
2543     }
2544     if ($next-&gt;value() eq &quot;setter&quot;) {
2545         return $self-&gt;getToken()-&gt;value();
2546     }
2547     if ($next-&gt;value() eq &quot;static&quot;) {
2548         return $self-&gt;getToken()-&gt;value();
2549     }
2550     if ($next-&gt;value() eq &quot;stringifier&quot;) {
2551         return $self-&gt;getToken()-&gt;value();
2552     }
2553     if ($next-&gt;value() eq &quot;typedef&quot;) {
2554         return $self-&gt;getToken()-&gt;value();
2555     }
2556     if ($next-&gt;value() eq &quot;unrestricted&quot;) {
2557         return $self-&gt;getToken()-&gt;value();
2558     }
2559     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2560 }
2561 
2562 sub parseType
2563 {
2564     my $self = shift;
2565     my $next = $self-&gt;nextToken();
2566 
2567     my $extendedAttributeList = {};
2568 
2569     if ($next-&gt;value() eq &quot;(&quot;) {
2570         my $unionType = $self-&gt;parseUnionType();
2571         $unionType-&gt;isNullable($self-&gt;parseNull());
2572         $unionType-&gt;extendedAttributes($extendedAttributeList);
2573         return $unionType;
2574     }
2575     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextType_1/) {
2576         my $singleType = $self-&gt;parseSingleType();
2577         $singleType-&gt;extendedAttributes($extendedAttributeList);
2578         return $singleType;
2579     }
2580     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2581 }
2582 
2583 sub parseTypeWithExtendedAttributes
2584 {
2585     my $self = shift;
2586     
2587     my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
2588     $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;type&quot;);
2589 
2590     my $next = $self-&gt;nextToken();
2591     if ($next-&gt;value() eq &quot;(&quot;) {
2592         my $unionType = $self-&gt;parseUnionType();
2593         $unionType-&gt;isNullable($self-&gt;parseNull());
2594         $unionType-&gt;extendedAttributes($extendedAttributeList);
2595         return $unionType;
2596     }
2597     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextType_1/) {
2598         my $singleType = $self-&gt;parseSingleType();
2599         $singleType-&gt;extendedAttributes($extendedAttributeList);
2600         return $singleType;
2601     }
2602     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2603 }
2604 
2605 sub parseSingleType
2606 {
2607     my $self = shift;
2608     my $next = $self-&gt;nextToken();
2609     if ($next-&gt;value() eq &quot;any&quot;) {
2610         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;any&quot;, __LINE__);
2611         
2612         my $anyType = IDLType-&gt;new();
2613         $anyType-&gt;name(&quot;any&quot;);
2614         return $anyType;
2615     }
2616     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextSingleType_1/) {
2617         my $nonAnyType = $self-&gt;parseNonAnyType();
2618         $nonAnyType-&gt;isNullable($self-&gt;parseNull());
2619         return $nonAnyType;
2620     }
2621     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2622 }
2623 
2624 sub parseUnionType
2625 {
2626     my $self = shift;
2627     my $next = $self-&gt;nextToken();
2628 
2629     my $unionType = IDLType-&gt;new();
2630     $unionType-&gt;name(&quot;UNION&quot;);
2631     $unionType-&gt;isUnion(1);
2632 
2633     if ($next-&gt;value() eq &quot;(&quot;) {
2634         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;(&quot;, __LINE__);
2635         
2636         push(@{$unionType-&gt;subtypes}, $self-&gt;parseUnionMemberType());
2637         push(@{$unionType-&gt;subtypes}, $self-&gt;parseUnionMemberTypes());
2638         
2639         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;)&quot;, __LINE__);
2640 
2641         return $unionType;
2642     }
2643     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2644 }
2645 
2646 sub parseUnionMemberType
2647 {
2648     my $self = shift;
2649 
2650     my $extendedAttributeList = $self-&gt;parseExtendedAttributeListAllowEmpty();
2651     $self-&gt;assertExtendedAttributesValidForContext($extendedAttributeList, &quot;type&quot;);
2652 
2653     my $next = $self-&gt;nextToken();
2654 
2655     if ($next-&gt;value() eq &quot;(&quot;) {
2656         my $unionType = $self-&gt;parseUnionType();
2657         $unionType-&gt;isNullable($self-&gt;parseNull());
2658         $unionType-&gt;extendedAttributes($extendedAttributeList);
2659         return $unionType;
2660     }
2661 
2662     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextSingleType_1/) {
2663         my $nonAnyType = $self-&gt;parseNonAnyType();
2664         $nonAnyType-&gt;isNullable($self-&gt;parseNull());
2665         $nonAnyType-&gt;extendedAttributes($extendedAttributeList);
2666         return $nonAnyType;
2667     }
2668     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2669 }
2670 
2671 sub parseUnionMemberTypes
2672 {
2673     my $self = shift;
2674     my $next = $self-&gt;nextToken();
2675 
2676     my @subtypes = ();
2677 
2678     if ($next-&gt;value() eq &quot;or&quot;) {
2679         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;or&quot;, __LINE__);
2680         push(@subtypes, $self-&gt;parseUnionMemberType());
2681         push(@subtypes, $self-&gt;parseUnionMemberTypes());
2682     }
2683 
2684     return @subtypes;
2685 }
2686 
2687 sub parseNonAnyType
2688 {
2689     my $self = shift;
2690     my $next = $self-&gt;nextToken();
2691 
2692     my $type = IDLType-&gt;new();
2693 
2694     if ($next-&gt;value() =~ /$nextNonAnyType_1/) {
2695         $type-&gt;name($self-&gt;parsePrimitiveType());
2696         return $type;
2697     }
2698     if ($next-&gt;value() =~ /$nextStringType_1/) {
2699         $type-&gt;name($self-&gt;parseStringType());
2700         return $type;
2701     }
2702     if ($next-&gt;value() eq &quot;object&quot;) {
2703         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;object&quot;, __LINE__);
2704 
2705         $type-&gt;name(&quot;object&quot;);
2706         return $type;
2707     }
2708     if ($next-&gt;value() eq &quot;Error&quot;) {
2709         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;Error&quot;, __LINE__);
2710 
2711         $type-&gt;name(&quot;Error&quot;);
2712         return $type;
2713     }
2714     if ($next-&gt;value() eq &quot;DOMException&quot;) {
2715         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;DOMException&quot;, __LINE__);
2716 
2717         $type-&gt;name(&quot;DOMException&quot;);
2718         return $type;
2719     }
2720     if ($next-&gt;value() eq &quot;Date&quot;) {
2721         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;Date&quot;, __LINE__);
2722 
2723         $type-&gt;name(&quot;Date&quot;);
2724         return $type;
2725     }
2726     if ($next-&gt;value() eq &quot;sequence&quot;) {
2727         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;sequence&quot;, __LINE__);
2728         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
2729 
2730         my $subtype = $self-&gt;parseTypeWithExtendedAttributes();
2731 
2732         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
2733 
2734         $type-&gt;name(&quot;sequence&quot;);
2735         push(@{$type-&gt;subtypes}, $subtype);
2736 
2737         return $type;
2738     }
2739     if ($next-&gt;value() eq &quot;FrozenArray&quot;) {
2740         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;FrozenArray&quot;, __LINE__);
2741         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
2742 
2743         my $subtype = $self-&gt;parseTypeWithExtendedAttributes();
2744 
2745         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
2746 
2747         $type-&gt;name(&quot;FrozenArray&quot;);
2748         push(@{$type-&gt;subtypes}, $subtype);
2749 
2750         return $type;
2751     }
2752     if ($next-&gt;value() eq &quot;Promise&quot;) {
2753         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;Promise&quot;, __LINE__);
2754         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
2755 
2756         my $subtype = $self-&gt;parseReturnType();
2757 
2758         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
2759 
2760         $type-&gt;name(&quot;Promise&quot;);
2761         push(@{$type-&gt;subtypes}, $subtype);
2762 
2763         return $type;
2764     }
2765     if ($next-&gt;value() eq &quot;record&quot;) {
2766         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;record&quot;, __LINE__);
2767         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&lt;&quot;, __LINE__);
2768 
2769         my $keyType = IDLType-&gt;new();
2770         $keyType-&gt;name($self-&gt;parseStringType());
2771 
2772         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;,&quot;, __LINE__);
2773 
2774         my $valueType = $self-&gt;parseTypeWithExtendedAttributes();
2775 
2776         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;&gt;&quot;, __LINE__);
2777 
2778         $type-&gt;name(&quot;record&quot;);
2779         push(@{$type-&gt;subtypes}, $keyType);
2780         push(@{$type-&gt;subtypes}, $valueType);
2781 
2782         return $type;
2783     }
2784     if ($next-&gt;type() == IdentifierToken) {
2785         my $identifier = $self-&gt;getToken();
2786 
2787         $type-&gt;name(identifierRemoveNullablePrefix($identifier-&gt;value()));
2788         return $type;
2789     }
2790     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2791 }
2792 
2793 sub parseConstType
2794 {
2795     my $self = shift;
2796     my $next = $self-&gt;nextToken();
2797 
2798     my $type = IDLType-&gt;new();
2799 
2800     if ($next-&gt;value() =~ /$nextNonAnyType_1/) {
2801         $type-&gt;name($self-&gt;parsePrimitiveType());
2802         $type-&gt;isNullable($self-&gt;parseNull());
2803         return $type;
2804     }
2805     if ($next-&gt;type() == IdentifierToken) {
2806         my $identifier = $self-&gt;getToken();
2807         
2808         $type-&gt;name($identifier-&gt;value());
2809         $type-&gt;isNullable($self-&gt;parseNull());
2810 
2811         return $type;
2812     }
2813     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2814 }
2815 
2816 sub parseStringType
2817 {
2818     my $self = shift;
2819     my $next = $self-&gt;nextToken();
2820     if ($next-&gt;value() eq &quot;ByteString&quot;) {
2821         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;ByteString&quot;, __LINE__);
2822         return &quot;ByteString&quot;;
2823     }
2824     if ($next-&gt;value() eq &quot;DOMString&quot;) {
2825         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;DOMString&quot;, __LINE__);
2826         return &quot;DOMString&quot;;
2827     }
2828     if ($next-&gt;value() eq &quot;USVString&quot;) {
2829         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;USVString&quot;, __LINE__);
2830         return &quot;USVString&quot;;
2831     }
2832     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2833 }
2834 
2835 sub parsePrimitiveType
2836 {
2837     my $self = shift;
2838     my $next = $self-&gt;nextToken();
2839     if ($next-&gt;value() =~ /$nextPrimitiveType_1/) {
2840         return $self-&gt;parseUnsignedIntegerType();
2841     }
2842     if ($next-&gt;value() =~ /$nextPrimitiveType_2/) {
2843         return $self-&gt;parseUnrestrictedFloatType();
2844     }
2845     if ($next-&gt;value() eq &quot;boolean&quot;) {
2846         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;boolean&quot;, __LINE__);
2847         return &quot;boolean&quot;;
2848     }
2849     if ($next-&gt;value() eq &quot;byte&quot;) {
2850         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;byte&quot;, __LINE__);
2851         return &quot;byte&quot;;
2852     }
2853     if ($next-&gt;value() eq &quot;octet&quot;) {
2854         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;octet&quot;, __LINE__);
2855         return &quot;octet&quot;;
2856     }
2857     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2858 }
2859 
2860 sub parseUnrestrictedFloatType
2861 {
2862     my $self = shift;
2863     my $next = $self-&gt;nextToken();
2864     if ($next-&gt;value() eq &quot;unrestricted&quot;) {
2865         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;unrestricted&quot;, __LINE__);
2866         return &quot;unrestricted &quot; . $self-&gt;parseFloatType();
2867     }
2868     if ($next-&gt;value() =~ /$nextUnrestrictedFloatType_1/) {
2869         return $self-&gt;parseFloatType();
2870     }
2871     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2872 }
2873 
2874 sub parseFloatType
2875 {
2876     my $self = shift;
2877     my $next = $self-&gt;nextToken();
2878     if ($next-&gt;value() eq &quot;float&quot;) {
2879         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;float&quot;, __LINE__);
2880         return &quot;float&quot;;
2881     }
2882     if ($next-&gt;value() eq &quot;double&quot;) {
2883         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;double&quot;, __LINE__);
2884         return &quot;double&quot;;
2885     }
2886     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2887 }
2888 
2889 sub parseUnsignedIntegerType
2890 {
2891     my $self = shift;
2892     my $next = $self-&gt;nextToken();
2893     if ($next-&gt;value() eq &quot;unsigned&quot;) {
2894         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;unsigned&quot;, __LINE__);
2895         return &quot;unsigned &quot; . $self-&gt;parseIntegerType();
2896     }
2897     if ($next-&gt;value() =~ /$nextUnsignedIntegerType_1/) {
2898         return $self-&gt;parseIntegerType();
2899     }
2900     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2901 }
2902 
2903 sub parseIntegerType
2904 {
2905     my $self = shift;
2906     my $next = $self-&gt;nextToken();
2907     if ($next-&gt;value() eq &quot;short&quot;) {
2908         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;short&quot;, __LINE__);
2909         return &quot;short&quot;;
2910     }
2911     if ($next-&gt;value() eq &quot;int&quot;) {
2912         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;int&quot;, __LINE__);
2913         return &quot;int&quot;;
2914     }
2915     if ($next-&gt;value() eq &quot;long&quot;) {
2916         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;long&quot;, __LINE__);
2917         if ($self-&gt;parseOptionalLong()) {
2918             return &quot;long long&quot;;
2919         }
2920         return &quot;long&quot;;
2921     }
2922     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2923 }
2924 
2925 sub parseOptionalLong
2926 {
2927     my $self = shift;
2928     my $next = $self-&gt;nextToken();
2929     if ($next-&gt;value() eq &quot;long&quot;) {
2930         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;long&quot;, __LINE__);
2931         return 1;
2932     }
2933     return 0;
2934 }
2935 
2936 sub parseNull
2937 {
2938     my $self = shift;
2939     my $next = $self-&gt;nextToken();
2940     if ($next-&gt;value() eq &quot;?&quot;) {
2941         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;?&quot;, __LINE__);
2942         return 1;
2943     }
2944     return 0;
2945 }
2946 
2947 sub parseReturnType
2948 {
2949     my $self = shift;
2950     my $next = $self-&gt;nextToken();
2951     if ($next-&gt;value() eq &quot;void&quot;) {
2952         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;void&quot;, __LINE__);
2953         
2954         my $voidType = IDLType-&gt;new();
2955         $voidType-&gt;name(&quot;void&quot;);
2956         return $voidType;
2957     }
2958     if ($next-&gt;type() == IdentifierToken || $next-&gt;value() =~ /$nextExceptionField_1/) {
2959         return $self-&gt;parseType();
2960     }
2961     $self-&gt;assertUnexpectedToken($next-&gt;value(), __LINE__);
2962 }
2963 
2964 sub parseOptionalSemicolon
2965 {
2966     my $self = shift;
2967     my $next = $self-&gt;nextToken();
2968     if ($next-&gt;value() eq &quot;;&quot;) {
2969         $self-&gt;assertTokenValue($self-&gt;getToken(), &quot;;&quot;, __LINE__);
2970     }
2971 }
2972 
2973 sub parseNameNoComma
2974 {
2975     my $self = shift;
2976     my $next = $self-&gt;nextToken();
2977     if ($next-&gt;type() == IdentifierToken) {
2978         my $identifier = $self-&gt;getToken();
2979         return ($identifier-&gt;value());
2980     }
2981 
2982     return ();
2983 }
2984 
2985 sub parseName
2986 {
2987     my $self = shift;
2988     my $next = $self-&gt;nextToken();
2989     if ($next-&gt;type() == IdentifierToken) {
2990         my $identifier = $self-&gt;getToken();
2991         return $identifier-&gt;value();
2992     }
2993     $self-&gt;assertUnexpectedToken($next-&gt;value());
2994 }
2995 
2996 sub applyMemberList
2997 {
2998     my $interface = shift;
2999     my $members = shift;
3000 
3001     for my $item (@{$members}) {
3002         if (ref($item) eq &quot;IDLAttribute&quot;) {
3003             push(@{$interface-&gt;attributes}, $item);
3004             next;
3005         }
3006         if (ref($item) eq &quot;IDLConstant&quot;) {
3007             push(@{$interface-&gt;constants}, $item);
3008             next;
3009         }
3010         if (ref($item) eq &quot;IDLIterable&quot;) {
3011             $interface-&gt;iterable($item);
3012             next;
3013         }
3014         if (ref($item) eq &quot;IDLMapLike&quot;) {
3015             $interface-&gt;mapLike($item);
3016             next;
3017         }
3018         if (ref($item) eq &quot;IDLSetLike&quot;) {
3019             $interface-&gt;setLike($item);
3020             next;
3021         }
3022         if (ref($item) eq &quot;IDLOperation&quot;) {
3023             if ($item-&gt;name eq &quot;&quot;) {
3024                 push(@{$interface-&gt;anonymousOperations}, $item);
3025             } else {
3026                 push(@{$interface-&gt;operations}, $item);
3027             }
3028             next;
3029         }
3030         if (ref($item) eq &quot;IDLSerializable&quot;) {
3031             $interface-&gt;serializable($item);
3032             next;
3033         }
3034     }
3035 
3036     if ($interface-&gt;serializable) {
3037         my $numSerializerAttributes = @{$interface-&gt;serializable-&gt;attributes};
3038         if ($interface-&gt;serializable-&gt;hasAttribute) {
3039             foreach my $attribute (@{$interface-&gt;attributes}) {
3040                 push(@{$interface-&gt;serializable-&gt;attributes}, $attribute-&gt;name);
3041             }
3042         } elsif ($numSerializerAttributes == 0) {
3043             foreach my $attribute (@{$interface-&gt;attributes}) {
3044                 push(@{$interface-&gt;serializable-&gt;attributes}, $attribute-&gt;name);
3045             }
3046         }
3047     }
3048 }
3049 
3050 sub applyExtendedAttributeList
3051 {
3052     my $interface = shift;
3053     my $extendedAttributeList = shift;
3054 
3055     if (defined $extendedAttributeList-&gt;{&quot;Constructors&quot;}) {
3056         my @constructorParams = @{$extendedAttributeList-&gt;{&quot;Constructors&quot;}};
3057         my $index = (@constructorParams == 1) ? 0 : 1;
3058         foreach my $param (@constructorParams) {
3059             my $constructor = IDLOperation-&gt;new();
3060             $constructor-&gt;name(&quot;Constructor&quot;);
3061             $constructor-&gt;extendedAttributes($extendedAttributeList);
3062             $constructor-&gt;arguments($param);
3063             push(@{$interface-&gt;constructors}, $constructor);
3064         }
3065         delete $extendedAttributeList-&gt;{&quot;Constructors&quot;};
3066         $extendedAttributeList-&gt;{&quot;Constructor&quot;} = &quot;VALUE_IS_MISSING&quot;;
3067     } elsif (defined $extendedAttributeList-&gt;{&quot;NamedConstructor&quot;}) {
3068         my $newDataNode = IDLOperation-&gt;new();
3069         $newDataNode-&gt;name(&quot;NamedConstructor&quot;);
3070         $newDataNode-&gt;extendedAttributes($extendedAttributeList);
3071         my %attributes = %{$extendedAttributeList-&gt;{&quot;NamedConstructor&quot;}};
3072         my @attributeKeys = keys (%attributes);
3073         my $constructorName = $attributeKeys[0];
3074         push(@{$newDataNode-&gt;arguments}, @{$attributes{$constructorName}});
3075         $extendedAttributeList-&gt;{&quot;NamedConstructor&quot;} = $constructorName;
3076         push(@{$interface-&gt;constructors}, $newDataNode);
3077     }
3078     if (defined $extendedAttributeList-&gt;{&quot;CustomConstructors&quot;}) {
3079         my @customConstructorParams = @{$extendedAttributeList-&gt;{&quot;CustomConstructors&quot;}};
3080         my $index = (@customConstructorParams == 1) ? 0 : 1;
3081         foreach my $param (@customConstructorParams) {
3082             my $customConstructor = IDLOperation-&gt;new();
3083             $customConstructor-&gt;name(&quot;CustomConstructor&quot;);
3084             $customConstructor-&gt;extendedAttributes($extendedAttributeList);
3085             $customConstructor-&gt;arguments($param);
3086             push(@{$interface-&gt;customConstructors}, $customConstructor);
3087         }
3088         delete $extendedAttributeList-&gt;{&quot;CustomConstructors&quot;};
3089         $extendedAttributeList-&gt;{&quot;CustomConstructor&quot;} = &quot;VALUE_IS_MISSING&quot;;
3090     }
3091     
3092     $interface-&gt;extendedAttributes($extendedAttributeList);
3093 }
3094 
3095 1;
3096 
    </pre>
  </body>
</html>
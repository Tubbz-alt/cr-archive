diff a/modules/javafx.web/src/main/native/Source/WebCore/dom/DocumentMarkerController.cpp b/modules/javafx.web/src/main/native/Source/WebCore/dom/DocumentMarkerController.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/dom/DocumentMarkerController.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/dom/DocumentMarkerController.cpp
@@ -58,25 +58,28 @@
 {
     m_markers.clear();
     m_possiblyExistingMarkerTypes = { };
 }
 
+Vector<RefPtr<Range>> DocumentMarkerController::collectTextRanges(const Range& range)
+{
+    Vector<RefPtr<Range>> textRange;
+    for (TextIterator textIterator(&range); !textIterator.atEnd(); textIterator.advance())
+        textRange.append(textIterator.range());
+    return textRange;
+}
+
 void DocumentMarkerController::addMarker(Range& range, DocumentMarker::MarkerType type, const String& description)
 {
-    for (TextIterator markedText(&range); !markedText.atEnd(); markedText.advance()) {
-        RefPtr<Range> textPiece = markedText.range();
+    for (auto textPiece : collectTextRanges(range))
         addMarker(textPiece->startContainer(), DocumentMarker(type, textPiece->startOffset(), textPiece->endOffset(), description));
-    }
 }
 
 void DocumentMarkerController::addMarker(Range& range, DocumentMarker::MarkerType type)
 {
-    for (TextIterator markedText(&range); !markedText.atEnd(); markedText.advance()) {
-        RefPtr<Range> textPiece = markedText.range();
+    for (auto textPiece : collectTextRanges(range))
         addMarker(textPiece->startContainer(), DocumentMarker(type, textPiece->startOffset(), textPiece->endOffset()));
-    }
-
 }
 
 void DocumentMarkerController::addMarkerToNode(Node& node, unsigned startOffset, unsigned length, DocumentMarker::MarkerType type)
 {
     addMarker(node, DocumentMarker(type, startOffset, startOffset + length));
@@ -87,96 +90,85 @@
     addMarker(node, DocumentMarker(type, startOffset, startOffset + length, WTFMove(data)));
 }
 
 void DocumentMarkerController::addTextMatchMarker(const Range& range, bool activeMatch)
 {
-    for (TextIterator markedText(&range); !markedText.atEnd(); markedText.advance()) {
-        RefPtr<Range> textPiece = markedText.range();
+    for (auto textPiece : collectTextRanges(range)) {
         unsigned startOffset = textPiece->startOffset();
         unsigned endOffset = textPiece->endOffset();
         addMarker(textPiece->startContainer(), DocumentMarker(startOffset, endOffset, activeMatch));
     }
 }
 
 #if PLATFORM(IOS_FAMILY)
 
 void DocumentMarkerController::addMarker(Range& range, DocumentMarker::MarkerType type, const String& description, const Vector<String>& interpretations, const RetainPtr<id>& metadata)
 {
-    for (TextIterator markedText(&range); !markedText.atEnd(); markedText.advance()) {
-        RefPtr<Range> textPiece = markedText.range();
+    for (auto textPiece : collectTextRanges(range))
         addMarker(textPiece->startContainer(), DocumentMarker(type, textPiece->startOffset(), textPiece->endOffset(), description, interpretations, metadata));
-    }
 }
 
 void DocumentMarkerController::addDictationPhraseWithAlternativesMarker(Range& range, const Vector<String>& interpretations)
 {
     ASSERT(interpretations.size() > 1);
     if (interpretations.size() <= 1)
         return;
 
     size_t numberOfAlternatives = interpretations.size() - 1;
-    for (TextIterator markedText(&range); !markedText.atEnd(); markedText.advance()) {
-        RefPtr<Range> textPiece = markedText.range();
+    for (auto textPiece : collectTextRanges(range)) {
         DocumentMarker marker(DocumentMarker::DictationPhraseWithAlternatives, textPiece->startOffset(), textPiece->endOffset(), emptyString(), Vector<String>(numberOfAlternatives), RetainPtr<id>());
         for (size_t i = 0; i < numberOfAlternatives; ++i)
             marker.setAlternative(interpretations[i + 1], i);
         addMarker(textPiece->startContainer(), marker);
     }
 }
 
 void DocumentMarkerController::addDictationResultMarker(Range& range, const RetainPtr<id>& metadata)
 {
-    for (TextIterator markedText(&range); !markedText.atEnd(); markedText.advance()) {
-        RefPtr<Range> textPiece = markedText.range();
+    for (auto textPiece : collectTextRanges(range))
         addMarker(textPiece->startContainer(), DocumentMarker(DocumentMarker::DictationResult, textPiece->startOffset(), textPiece->endOffset(), String(), Vector<String>(), metadata));
-    }
 }
 
 #endif
 
 void DocumentMarkerController::addDraggedContentMarker(Range& range)
 {
-    for (TextIterator markedText(&range); !markedText.atEnd(); markedText.advance()) {
-        auto textPiece = markedText.range();
-        DocumentMarker::DraggedContentData draggedContentData { markedText.node() };
+    for (auto textPiece : collectTextRanges(range)) {
+        DocumentMarker::DraggedContentData draggedContentData { textPiece->firstNode() };
         addMarker(textPiece->startContainer(), { DocumentMarker::DraggedContent, textPiece->startOffset(), textPiece->endOffset(), WTFMove(draggedContentData) });
     }
 }
 
 #if ENABLE(PLATFORM_DRIVEN_TEXT_CHECKING)
 void DocumentMarkerController::addPlatformTextCheckingMarker(Range& range, const String& key, const String& value)
 {
-    for (TextIterator markedText(&range); !markedText.atEnd(); markedText.advance()) {
-        auto textPiece = markedText.range();
+    for (auto textPiece : collectTextRanges(range)) {
         DocumentMarker::PlatformTextCheckingData textCheckingData { key, value };
         addMarker(textPiece->startContainer(), { DocumentMarker::PlatformTextChecking, textPiece->startOffset(), textPiece->endOffset(), WTFMove(textCheckingData) });
     }
 }
 #endif
 
 void DocumentMarkerController::removeMarkers(Range& range, OptionSet<DocumentMarker::MarkerType> markerTypes, RemovePartiallyOverlappingMarkerOrNot shouldRemovePartiallyOverlappingMarker)
 {
-    for (TextIterator markedText(&range); !markedText.atEnd(); markedText.advance()) {
+    for (auto textPiece : collectTextRanges(range)) {
         if (!possiblyHasMarkers(markerTypes))
             return;
         ASSERT(!m_markers.isEmpty());
-
-        auto textPiece = markedText.range();
         unsigned startOffset = textPiece->startOffset();
         unsigned endOffset = textPiece->endOffset();
         removeMarkers(textPiece->startContainer(), startOffset, endOffset - startOffset, markerTypes, nullptr, shouldRemovePartiallyOverlappingMarker);
     }
 }
 
 void DocumentMarkerController::filterMarkers(Range& range, std::function<bool(DocumentMarker*)> filterFunction, OptionSet<DocumentMarker::MarkerType> markerTypes, RemovePartiallyOverlappingMarkerOrNot shouldRemovePartiallyOverlappingMarker)
 {
-    for (TextIterator markedText(&range); !markedText.atEnd(); markedText.advance()) {
+    for (auto textPiece : collectTextRanges(range)) {
         if (!possiblyHasMarkers(markerTypes))
             return;
         ASSERT(!m_markers.isEmpty());
 
-        auto textPiece = markedText.range();
         unsigned startOffset = textPiece->startOffset();
         unsigned endOffset = textPiece->endOffset();
         removeMarkers(textPiece->startContainer(), startOffset, endOffset - startOffset, markerTypes, filterFunction, shouldRemovePartiallyOverlappingMarker);
     }
 }

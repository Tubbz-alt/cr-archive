<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlNumberFormat.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IntlDateTimeFormatPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IntlNumberFormat.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/IntlNumberFormat.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
  3  * Copyright (C) 2016 Sukolsak Sakshuwong (sukolsak@gmail.com)
<span class="line-modified">  4  * Copyright (C) 2016-2019 Apple Inc. All rights reserved.</span>
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 16  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 17  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 19  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 20  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 21  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 22  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 23  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 24  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
 50 
 51 void IntlNumberFormat::UNumberFormatDeleter::operator()(UNumberFormat* numberFormat) const
 52 {
 53     if (numberFormat)
 54         unum_close(numberFormat);
 55 }
 56 
 57 IntlNumberFormat* IntlNumberFormat::create(VM&amp; vm, Structure* structure)
 58 {
 59     IntlNumberFormat* format = new (NotNull, allocateCell&lt;IntlNumberFormat&gt;(vm.heap)) IntlNumberFormat(vm, structure);
 60     format-&gt;finishCreation(vm);
 61     return format;
 62 }
 63 
 64 Structure* IntlNumberFormat::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 65 {
 66     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 67 }
 68 
 69 IntlNumberFormat::IntlNumberFormat(VM&amp; vm, Structure* structure)
<span class="line-modified"> 70     : JSDestructibleObject(vm, structure)</span>
 71 {
 72 }
 73 
 74 void IntlNumberFormat::finishCreation(VM&amp; vm)
 75 {
 76     Base::finishCreation(vm);
 77     ASSERT(inherits(vm, info()));
 78 }
 79 
<span class="line-removed"> 80 void IntlNumberFormat::destroy(JSCell* cell)</span>
<span class="line-removed"> 81 {</span>
<span class="line-removed"> 82     static_cast&lt;IntlNumberFormat*&gt;(cell)-&gt;IntlNumberFormat::~IntlNumberFormat();</span>
<span class="line-removed"> 83 }</span>
<span class="line-removed"> 84 </span>
 85 void IntlNumberFormat::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 86 {
 87     IntlNumberFormat* thisObject = jsCast&lt;IntlNumberFormat*&gt;(cell);
 88     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 89 
 90     Base::visitChildren(thisObject, visitor);
 91 
 92     visitor.append(thisObject-&gt;m_boundFormat);
 93 }
 94 
 95 namespace IntlNFInternal {
 96 static Vector&lt;String&gt; localeData(const String&amp; locale, size_t keyIndex)
 97 {
 98     // 9.1 Internal slots of Service Constructors &amp; 11.2.3 Internal slots (ECMA-402 2.0)
 99     ASSERT_UNUSED(keyIndex, !keyIndex); // The index of the extension key &quot;nu&quot; in relevantExtensionKeys is 0.
100     return numberingSystemsForLocale(locale);
101 }
102 }
103 
104 static inline unsigned computeCurrencySortKey(const String&amp; currency)
</pre>
<hr />
<pre>
142         { &quot;KWD&quot;, 3 },
143         { &quot;LYD&quot;, 3 },
144         { &quot;OMR&quot;, 3 },
145         { &quot;PYG&quot;, 0 },
146         { &quot;RWF&quot;, 0 },
147         { &quot;TND&quot;, 3 },
148         { &quot;UGX&quot;, 0 },
149         { &quot;UYI&quot;, 0 },
150         { &quot;VND&quot;, 0 },
151         { &quot;VUV&quot;, 0 },
152         { &quot;XAF&quot;, 0 },
153         { &quot;XOF&quot;, 0 },
154         { &quot;XPF&quot;, 0 }
155     };
156     auto* currencyMinorUnit = tryBinarySearch&lt;std::pair&lt;const char*, unsigned&gt;&gt;(currencyMinorUnits, WTF_ARRAY_LENGTH(currencyMinorUnits), computeCurrencySortKey(currency), extractCurrencySortKey);
157     if (currencyMinorUnit)
158         return currencyMinorUnit-&gt;second;
159     return 2;
160 }
161 
<span class="line-modified">162 void IntlNumberFormat::initializeNumberFormat(ExecState&amp; state, JSValue locales, JSValue optionsValue)</span>
163 {
<span class="line-modified">164     VM&amp; vm = state.vm();</span>
165     auto scope = DECLARE_THROW_SCOPE(vm);
166 
167     // 11.1.2 InitializeNumberFormat (numberFormat, locales, options) (ECMA-402)
168     // https://tc39.github.io/ecma402/#sec-initializenumberformat
169 
<span class="line-modified">170     auto requestedLocales = canonicalizeLocaleList(state, locales);</span>
171     RETURN_IF_EXCEPTION(scope, void());
172 
173     JSObject* options;
174     if (optionsValue.isUndefined())
<span class="line-modified">175         options = constructEmptyObject(&amp;state, state.lexicalGlobalObject()-&gt;nullPrototypeObjectStructure());</span>
176     else {
<span class="line-modified">177         options = optionsValue.toObject(&amp;state);</span>
178         RETURN_IF_EXCEPTION(scope, void());
179     }
180 
181     HashMap&lt;String, String&gt; opt;
182 
<span class="line-modified">183     String matcher = intlStringOption(state, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);</span>
184     RETURN_IF_EXCEPTION(scope, void());
185     opt.add(&quot;localeMatcher&quot;_s, matcher);
186 
<span class="line-modified">187     auto&amp; availableLocales = state.jsCallee()-&gt;globalObject(vm)-&gt;intlNumberFormatAvailableLocales();</span>
<span class="line-modified">188     auto result = resolveLocale(state, availableLocales, requestedLocales, opt, relevantNumberExtensionKeys, WTF_ARRAY_LENGTH(relevantNumberExtensionKeys), IntlNFInternal::localeData);</span>
189 
190     m_locale = result.get(&quot;locale&quot;_s);
191     if (m_locale.isEmpty()) {
<span class="line-modified">192         throwTypeError(&amp;state, scope, &quot;failed to initialize NumberFormat due to invalid locale&quot;_s);</span>
193         return;
194     }
195 
196     m_numberingSystem = result.get(&quot;nu&quot;_s);
197 
<span class="line-modified">198     String styleString = intlStringOption(state, options, Identifier::fromString(vm, &quot;style&quot;), { &quot;decimal&quot;, &quot;percent&quot;, &quot;currency&quot; }, &quot;style must be either \&quot;decimal\&quot;, \&quot;percent\&quot;, or \&quot;currency\&quot;&quot;, &quot;decimal&quot;);</span>
199     RETURN_IF_EXCEPTION(scope, void());
200     if (styleString == &quot;decimal&quot;)
201         m_style = Style::Decimal;
202     else if (styleString == &quot;percent&quot;)
203         m_style = Style::Percent;
204     else if (styleString == &quot;currency&quot;)
205         m_style = Style::Currency;
206     else
207         ASSERT_NOT_REACHED();
208 
<span class="line-modified">209     String currency = intlStringOption(state, options, Identifier::fromString(vm, &quot;currency&quot;), { }, nullptr, nullptr);</span>
210     RETURN_IF_EXCEPTION(scope, void());
211     if (!currency.isNull()) {
212         if (currency.length() != 3 || !currency.isAllSpecialCharacters&lt;isASCIIAlpha&gt;()) {
<span class="line-modified">213             throwException(&amp;state, scope, createRangeError(&amp;state, &quot;currency is not a well-formed currency code&quot;_s));</span>
214             return;
215         }
216     }
217 
218     unsigned currencyDigits = 0;
219     if (m_style == Style::Currency) {
220         if (currency.isNull()) {
<span class="line-modified">221             throwTypeError(&amp;state, scope, &quot;currency must be a string&quot;_s);</span>
222             return;
223         }
224 
225         currency = currency.convertToASCIIUppercase();
226         m_currency = currency;
227         currencyDigits = computeCurrencyDigits(currency);
228     }
229 
<span class="line-modified">230     String currencyDisplayString = intlStringOption(state, options, Identifier::fromString(vm, &quot;currencyDisplay&quot;), { &quot;code&quot;, &quot;symbol&quot;, &quot;name&quot; }, &quot;currencyDisplay must be either \&quot;code\&quot;, \&quot;symbol\&quot;, or \&quot;name\&quot;&quot;, &quot;symbol&quot;);</span>
231     RETURN_IF_EXCEPTION(scope, void());
232     if (m_style == Style::Currency) {
233         if (currencyDisplayString == &quot;code&quot;)
234             m_currencyDisplay = CurrencyDisplay::Code;
235         else if (currencyDisplayString == &quot;symbol&quot;)
236             m_currencyDisplay = CurrencyDisplay::Symbol;
237         else if (currencyDisplayString == &quot;name&quot;)
238             m_currencyDisplay = CurrencyDisplay::Name;
239         else
240             ASSERT_NOT_REACHED();
241     }
242 
<span class="line-modified">243     unsigned minimumIntegerDigits = intlNumberOption(state, options, Identifier::fromString(vm, &quot;minimumIntegerDigits&quot;), 1, 21, 1);</span>
244     RETURN_IF_EXCEPTION(scope, void());
245     m_minimumIntegerDigits = minimumIntegerDigits;
246 
247     unsigned minimumFractionDigitsDefault = (m_style == Style::Currency) ? currencyDigits : 0;
248 
<span class="line-modified">249     unsigned minimumFractionDigits = intlNumberOption(state, options, Identifier::fromString(vm, &quot;minimumFractionDigits&quot;), 0, 20, minimumFractionDigitsDefault);</span>
250     RETURN_IF_EXCEPTION(scope, void());
251     m_minimumFractionDigits = minimumFractionDigits;
252 
253     unsigned maximumFractionDigitsDefault;
254     if (m_style == Style::Currency)
255         maximumFractionDigitsDefault = std::max(minimumFractionDigits, currencyDigits);
256     else if (m_style == Style::Percent)
257         maximumFractionDigitsDefault = minimumFractionDigits;
258     else
259         maximumFractionDigitsDefault = std::max(minimumFractionDigits, 3u);
260 
<span class="line-modified">261     unsigned maximumFractionDigits = intlNumberOption(state, options, Identifier::fromString(vm, &quot;maximumFractionDigits&quot;), minimumFractionDigits, 20, maximumFractionDigitsDefault);</span>
262     RETURN_IF_EXCEPTION(scope, void());
263     m_maximumFractionDigits = maximumFractionDigits;
264 
<span class="line-modified">265     JSValue minimumSignificantDigitsValue = options-&gt;get(&amp;state, Identifier::fromString(vm, &quot;minimumSignificantDigits&quot;));</span>
266     RETURN_IF_EXCEPTION(scope, void());
267 
<span class="line-modified">268     JSValue maximumSignificantDigitsValue = options-&gt;get(&amp;state, Identifier::fromString(vm, &quot;maximumSignificantDigits&quot;));</span>
269     RETURN_IF_EXCEPTION(scope, void());
270 
271     if (!minimumSignificantDigitsValue.isUndefined() || !maximumSignificantDigitsValue.isUndefined()) {
<span class="line-modified">272         unsigned minimumSignificantDigits = intlDefaultNumberOption(state, minimumSignificantDigitsValue, Identifier::fromString(vm, &quot;minimumSignificantDigits&quot;), 1, 21, 1);</span>
273         RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">274         unsigned maximumSignificantDigits = intlDefaultNumberOption(state, maximumSignificantDigitsValue, Identifier::fromString(vm, &quot;maximumSignificantDigits&quot;), minimumSignificantDigits, 21, 21);</span>
275         RETURN_IF_EXCEPTION(scope, void());
276         m_minimumSignificantDigits = minimumSignificantDigits;
277         m_maximumSignificantDigits = maximumSignificantDigits;
278     }
279 
280     bool usesFallback;
<span class="line-modified">281     bool useGrouping = intlBooleanOption(state, options, Identifier::fromString(vm, &quot;useGrouping&quot;), usesFallback);</span>
282     if (usesFallback)
283         useGrouping = true;
284     RETURN_IF_EXCEPTION(scope, void());
285     m_useGrouping = useGrouping;
286 
287     UNumberFormatStyle style = UNUM_DEFAULT;
288     switch (m_style) {
289     case Style::Decimal:
290         style = UNUM_DECIMAL;
291         break;
292     case Style::Percent:
293         style = UNUM_PERCENT;
294         break;
295     case Style::Currency:
296         switch (m_currencyDisplay) {
297         case CurrencyDisplay::Code:
298             style = UNUM_CURRENCY_ISO;
299             break;
300         case CurrencyDisplay::Symbol:
301             style = UNUM_CURRENCY;
302             break;
303         case CurrencyDisplay::Name:
304             style = UNUM_CURRENCY_PLURAL;
305             break;
306         default:
307             ASSERT_NOT_REACHED();
308         }
309         break;
310     default:
311         ASSERT_NOT_REACHED();
312     }
313 
314     UErrorCode status = U_ZERO_ERROR;
315     m_numberFormat = std::unique_ptr&lt;UNumberFormat, UNumberFormatDeleter&gt;(unum_open(style, nullptr, 0, m_locale.utf8().data(), nullptr, &amp;status));
316     if (U_FAILURE(status)) {
<span class="line-modified">317         throwTypeError(&amp;state, scope, &quot;failed to initialize NumberFormat&quot;_s);</span>
318         return;
319     }
320 
321     if (m_style == Style::Currency) {
322         unum_setTextAttribute(m_numberFormat.get(), UNUM_CURRENCY_CODE, StringView(m_currency).upconvertedCharacters(), m_currency.length(), &amp;status);
323         if (U_FAILURE(status)) {
<span class="line-modified">324             throwTypeError(&amp;state, scope, &quot;failed to initialize NumberFormat&quot;_s);</span>
325             return;
326         }
327     }
328     if (!m_minimumSignificantDigits) {
329         unum_setAttribute(m_numberFormat.get(), UNUM_MIN_INTEGER_DIGITS, m_minimumIntegerDigits);
330         unum_setAttribute(m_numberFormat.get(), UNUM_MIN_FRACTION_DIGITS, m_minimumFractionDigits);
331         unum_setAttribute(m_numberFormat.get(), UNUM_MAX_FRACTION_DIGITS, m_maximumFractionDigits);
332     } else {
333         unum_setAttribute(m_numberFormat.get(), UNUM_SIGNIFICANT_DIGITS_USED, true);
334         unum_setAttribute(m_numberFormat.get(), UNUM_MIN_SIGNIFICANT_DIGITS, m_minimumSignificantDigits);
335         unum_setAttribute(m_numberFormat.get(), UNUM_MAX_SIGNIFICANT_DIGITS, m_maximumSignificantDigits);
336     }
337     unum_setAttribute(m_numberFormat.get(), UNUM_GROUPING_USED, m_useGrouping);
338     unum_setAttribute(m_numberFormat.get(), UNUM_ROUNDING_MODE, UNUM_ROUND_HALFUP);
339 
340     m_initializedNumberFormat = true;
341 }
342 
<span class="line-modified">343 JSValue IntlNumberFormat::formatNumber(ExecState&amp; state, double number)</span>
344 {
<span class="line-modified">345     VM&amp; vm = state.vm();</span>
346     auto scope = DECLARE_THROW_SCOPE(vm);
347 
348     // 11.3.4 FormatNumber abstract operation (ECMA-402 2.0)
349     if (!m_initializedNumberFormat)
<span class="line-modified">350         return throwTypeError(&amp;state, scope, &quot;Intl.NumberFormat.prototype.format called on value that&#39;s not an object initialized as a NumberFormat&quot;_s);</span>
351 
352     // Map negative zero to positive zero.
353     if (!number)
354         number = 0.0;
355 
356     UErrorCode status = U_ZERO_ERROR;
357     Vector&lt;UChar, 32&gt; buffer(32);
358     auto length = unum_formatDouble(m_numberFormat.get(), number, buffer.data(), buffer.size(), nullptr, &amp;status);
359     if (status == U_BUFFER_OVERFLOW_ERROR) {
360         buffer.grow(length);
361         status = U_ZERO_ERROR;
362         unum_formatDouble(m_numberFormat.get(), number, buffer.data(), length, nullptr, &amp;status);
363     }
364     if (U_FAILURE(status))
<span class="line-modified">365         return throwException(&amp;state, scope, createError(&amp;state, &quot;Failed to format a number.&quot;_s));</span>
366 
367     return jsString(vm, String(buffer.data(), length));
368 }
369 
370 ASCIILiteral IntlNumberFormat::styleString(Style style)
371 {
372     switch (style) {
373     case Style::Decimal:
374         return &quot;decimal&quot;_s;
375     case Style::Percent:
376         return &quot;percent&quot;_s;
377     case Style::Currency:
378         return &quot;currency&quot;_s;
379     }
380     ASSERT_NOT_REACHED();
381     return ASCIILiteral::null();
382 }
383 
384 ASCIILiteral IntlNumberFormat::currencyDisplayString(CurrencyDisplay currencyDisplay)
385 {
386     switch (currencyDisplay) {
387     case CurrencyDisplay::Code:
388         return &quot;code&quot;_s;
389     case CurrencyDisplay::Symbol:
390         return &quot;symbol&quot;_s;
391     case CurrencyDisplay::Name:
392         return &quot;name&quot;_s;
393     }
394     ASSERT_NOT_REACHED();
395     return ASCIILiteral::null();
396 }
397 
<span class="line-modified">398 JSObject* IntlNumberFormat::resolvedOptions(ExecState&amp; state)</span>
399 {
<span class="line-modified">400     VM&amp; vm = state.vm();</span>
401     auto scope = DECLARE_THROW_SCOPE(vm);
402 
403     // 11.3.5 Intl.NumberFormat.prototype.resolvedOptions() (ECMA-402 2.0)
404     // The function returns a new object whose properties and attributes are set as if
405     // constructed by an object literal assigning to each of the following properties the
406     // value of the corresponding internal slot of this NumberFormat object (see 11.4):
407     // locale, numberingSystem, style, currency, currencyDisplay, minimumIntegerDigits,
408     // minimumFractionDigits, maximumFractionDigits, minimumSignificantDigits,
409     // maximumSignificantDigits, and useGrouping. Properties whose corresponding internal
410     // slots are not present are not assigned.
411 
412     if (!m_initializedNumberFormat) {
<span class="line-modified">413         initializeNumberFormat(state, jsUndefined(), jsUndefined());</span>
414         scope.assertNoException();
415     }
416 
<span class="line-modified">417     JSObject* options = constructEmptyObject(&amp;state);</span>
418     options-&gt;putDirect(vm, vm.propertyNames-&gt;locale, jsString(vm, m_locale));
419     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;numberingSystem&quot;), jsString(vm, m_numberingSystem));
420     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;style&quot;), jsNontrivialString(vm, styleString(m_style)));
421     if (m_style == Style::Currency) {
422         options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;currency&quot;), jsNontrivialString(vm, m_currency));
423         options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;currencyDisplay&quot;), jsNontrivialString(vm, currencyDisplayString(m_currencyDisplay)));
424     }
425     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;minimumIntegerDigits&quot;), jsNumber(m_minimumIntegerDigits));
426     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;minimumFractionDigits&quot;), jsNumber(m_minimumFractionDigits));
427     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;maximumFractionDigits&quot;), jsNumber(m_maximumFractionDigits));
428     if (m_minimumSignificantDigits) {
429         ASSERT(m_maximumSignificantDigits);
430         options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;minimumSignificantDigits&quot;), jsNumber(m_minimumSignificantDigits));
431         options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;maximumSignificantDigits&quot;), jsNumber(m_maximumSignificantDigits));
432     }
433     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;useGrouping&quot;), jsBoolean(m_useGrouping));
434     return options;
435 }
436 
437 void IntlNumberFormat::setBoundFormat(VM&amp; vm, JSBoundFunction* format)
</pre>
<hr />
<pre>
466     case UNUM_PERCENT_FIELD:
467         return &quot;percentSign&quot;_s;
468     case UNUM_SIGN_FIELD:
469         return value &lt; 0 ? &quot;minusSign&quot;_s : &quot;plusSign&quot;_s;
470     // These should not show up because there is no way to specify them in NumberFormat options.
471     // If they do, they don&#39;t fit well into any of known part types, so consider it an &quot;unknown&quot;.
472     case UNUM_PERMILL_FIELD:
473     case UNUM_EXPONENT_SYMBOL_FIELD:
474     case UNUM_EXPONENT_SIGN_FIELD:
475     case UNUM_EXPONENT_FIELD:
476 #if !defined(U_HIDE_DEPRECATED_API)
477     case UNUM_FIELD_COUNT:
478 #endif
479     // Any newer additions to the UNumberFormatFields enum should just be considered an &quot;unknown&quot; part.
480     default:
481         return &quot;unknown&quot;_s;
482     }
483     return &quot;unknown&quot;_s;
484 }
485 
<span class="line-modified">486 JSValue IntlNumberFormat::formatToParts(ExecState&amp; exec, double value)</span>
487 {
<span class="line-modified">488     VM&amp; vm = exec.vm();</span>
489     auto scope = DECLARE_THROW_SCOPE(vm);
490 
491     // FormatNumberToParts (ECMA-402)
492     // https://tc39.github.io/ecma402/#sec-formatnumbertoparts
493     // https://tc39.github.io/ecma402/#sec-partitionnumberpattern
494 
495     if (!m_initializedNumberFormat)
<span class="line-modified">496         return throwTypeError(&amp;exec, scope, &quot;Intl.NumberFormat.prototype.formatToParts called on value that&#39;s not an object initialized as a NumberFormat&quot;_s);</span>
497 
498     UErrorCode status = U_ZERO_ERROR;
499     auto fieldItr = std::unique_ptr&lt;UFieldPositionIterator, UFieldPositionIteratorDeleter&gt;(ufieldpositer_open(&amp;status));
500     if (U_FAILURE(status))
<span class="line-modified">501         return throwTypeError(&amp;exec, scope, &quot;failed to open field position iterator&quot;_s);</span>
502 
503     status = U_ZERO_ERROR;
504     Vector&lt;UChar, 32&gt; result(32);
505     auto resultLength = unum_formatDoubleForFields(m_numberFormat.get(), value, result.data(), result.size(), fieldItr.get(), &amp;status);
506     if (status == U_BUFFER_OVERFLOW_ERROR) {
507         status = U_ZERO_ERROR;
508         result.grow(resultLength);
509         unum_formatDoubleForFields(m_numberFormat.get(), value, result.data(), resultLength, fieldItr.get(), &amp;status);
510     }
511     if (U_FAILURE(status))
<span class="line-modified">512         return throwTypeError(&amp;exec, scope, &quot;failed to format a number.&quot;_s);</span>
513 
514     int32_t literalFieldType = -1;
515     auto literalField = IntlNumberFormatField(literalFieldType, resultLength);
516     Vector&lt;IntlNumberFormatField&gt; fields(resultLength, literalField);
517     int32_t beginIndex = 0;
518     int32_t endIndex = 0;
519     auto fieldType = ufieldpositer_next(fieldItr.get(), &amp;beginIndex, &amp;endIndex);
520     while (fieldType &gt;= 0) {
521         auto size = endIndex - beginIndex;
522         for (auto i = beginIndex; i &lt; endIndex; ++i) {
523             // Only override previous value if new value is more specific.
524             if (fields[i].size &gt;= size)
525                 fields[i] = IntlNumberFormatField(fieldType, size);
526         }
527         fieldType = ufieldpositer_next(fieldItr.get(), &amp;beginIndex, &amp;endIndex);
528     }
529 
<span class="line-removed">530     JSGlobalObject* globalObject = exec.jsCallee()-&gt;globalObject(vm);</span>
531     JSArray* parts = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), 0);
532     if (!parts)
<span class="line-modified">533         return throwOutOfMemoryError(&amp;exec, scope);</span>
534     unsigned index = 0;
535 
536     auto resultString = String(result.data(), resultLength);
537     auto typePropertyName = Identifier::fromString(vm, &quot;type&quot;);
<span class="line-modified">538     auto literalString = jsString(vm, &quot;literal&quot;_s);</span>
539 
540     int32_t currentIndex = 0;
541     while (currentIndex &lt; resultLength) {
542         auto startIndex = currentIndex;
543         auto fieldType = fields[currentIndex].type;
544         while (currentIndex &lt; resultLength &amp;&amp; fields[currentIndex].type == fieldType)
545             ++currentIndex;
546         auto partType = fieldType == literalFieldType ? literalString : jsString(vm, partTypeString(UNumberFormatFields(fieldType), value));
547         auto partValue = jsSubstring(vm, resultString, startIndex, currentIndex - startIndex);
<span class="line-modified">548         JSObject* part = constructEmptyObject(&amp;exec);</span>
549         part-&gt;putDirect(vm, typePropertyName, partType);
550         part-&gt;putDirect(vm, vm.propertyNames-&gt;value, partValue);
<span class="line-modified">551         parts-&gt;putDirectIndex(&amp;exec, index++, part);</span>
552         RETURN_IF_EXCEPTION(scope, { });
553     }
554 
555     return parts;
556 }
557 #endif
558 
559 } // namespace JSC
560 
561 #endif // ENABLE(INTL)
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
  2  * Copyright (C) 2015 Andy VanWagoner (andy@vanwagoner.family)
  3  * Copyright (C) 2016 Sukolsak Sakshuwong (sukolsak@gmail.com)
<span class="line-modified">  4  * Copyright (C) 2016-2020 Apple Inc. All rights reserved.</span>
  5  *
  6  * Redistribution and use in source and binary forms, with or without
  7  * modification, are permitted provided that the following conditions
  8  * are met:
  9  * 1. Redistributions of source code must retain the above copyright
 10  *    notice, this list of conditions and the following disclaimer.
 11  * 2. Redistributions in binary form must reproduce the above copyright
 12  *    notice, this list of conditions and the following disclaimer in the
 13  *    documentation and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 16  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 17  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 18  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 19  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 20  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 21  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 22  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 23  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 24  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
</pre>
<hr />
<pre>
 50 
 51 void IntlNumberFormat::UNumberFormatDeleter::operator()(UNumberFormat* numberFormat) const
 52 {
 53     if (numberFormat)
 54         unum_close(numberFormat);
 55 }
 56 
 57 IntlNumberFormat* IntlNumberFormat::create(VM&amp; vm, Structure* structure)
 58 {
 59     IntlNumberFormat* format = new (NotNull, allocateCell&lt;IntlNumberFormat&gt;(vm.heap)) IntlNumberFormat(vm, structure);
 60     format-&gt;finishCreation(vm);
 61     return format;
 62 }
 63 
 64 Structure* IntlNumberFormat::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
 65 {
 66     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());
 67 }
 68 
 69 IntlNumberFormat::IntlNumberFormat(VM&amp; vm, Structure* structure)
<span class="line-modified"> 70     : Base(vm, structure)</span>
 71 {
 72 }
 73 
 74 void IntlNumberFormat::finishCreation(VM&amp; vm)
 75 {
 76     Base::finishCreation(vm);
 77     ASSERT(inherits(vm, info()));
 78 }
 79 





 80 void IntlNumberFormat::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
 81 {
 82     IntlNumberFormat* thisObject = jsCast&lt;IntlNumberFormat*&gt;(cell);
 83     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
 84 
 85     Base::visitChildren(thisObject, visitor);
 86 
 87     visitor.append(thisObject-&gt;m_boundFormat);
 88 }
 89 
 90 namespace IntlNFInternal {
 91 static Vector&lt;String&gt; localeData(const String&amp; locale, size_t keyIndex)
 92 {
 93     // 9.1 Internal slots of Service Constructors &amp; 11.2.3 Internal slots (ECMA-402 2.0)
 94     ASSERT_UNUSED(keyIndex, !keyIndex); // The index of the extension key &quot;nu&quot; in relevantExtensionKeys is 0.
 95     return numberingSystemsForLocale(locale);
 96 }
 97 }
 98 
 99 static inline unsigned computeCurrencySortKey(const String&amp; currency)
</pre>
<hr />
<pre>
137         { &quot;KWD&quot;, 3 },
138         { &quot;LYD&quot;, 3 },
139         { &quot;OMR&quot;, 3 },
140         { &quot;PYG&quot;, 0 },
141         { &quot;RWF&quot;, 0 },
142         { &quot;TND&quot;, 3 },
143         { &quot;UGX&quot;, 0 },
144         { &quot;UYI&quot;, 0 },
145         { &quot;VND&quot;, 0 },
146         { &quot;VUV&quot;, 0 },
147         { &quot;XAF&quot;, 0 },
148         { &quot;XOF&quot;, 0 },
149         { &quot;XPF&quot;, 0 }
150     };
151     auto* currencyMinorUnit = tryBinarySearch&lt;std::pair&lt;const char*, unsigned&gt;&gt;(currencyMinorUnits, WTF_ARRAY_LENGTH(currencyMinorUnits), computeCurrencySortKey(currency), extractCurrencySortKey);
152     if (currencyMinorUnit)
153         return currencyMinorUnit-&gt;second;
154     return 2;
155 }
156 
<span class="line-modified">157 void IntlNumberFormat::initializeNumberFormat(JSGlobalObject* globalObject, JSValue locales, JSValue optionsValue)</span>
158 {
<span class="line-modified">159     VM&amp; vm = globalObject-&gt;vm();</span>
160     auto scope = DECLARE_THROW_SCOPE(vm);
161 
162     // 11.1.2 InitializeNumberFormat (numberFormat, locales, options) (ECMA-402)
163     // https://tc39.github.io/ecma402/#sec-initializenumberformat
164 
<span class="line-modified">165     auto requestedLocales = canonicalizeLocaleList(globalObject, locales);</span>
166     RETURN_IF_EXCEPTION(scope, void());
167 
168     JSObject* options;
169     if (optionsValue.isUndefined())
<span class="line-modified">170         options = constructEmptyObject(vm, globalObject-&gt;nullPrototypeObjectStructure());</span>
171     else {
<span class="line-modified">172         options = optionsValue.toObject(globalObject);</span>
173         RETURN_IF_EXCEPTION(scope, void());
174     }
175 
176     HashMap&lt;String, String&gt; opt;
177 
<span class="line-modified">178     String matcher = intlStringOption(globalObject, options, vm.propertyNames-&gt;localeMatcher, { &quot;lookup&quot;, &quot;best fit&quot; }, &quot;localeMatcher must be either \&quot;lookup\&quot; or \&quot;best fit\&quot;&quot;, &quot;best fit&quot;);</span>
179     RETURN_IF_EXCEPTION(scope, void());
180     opt.add(&quot;localeMatcher&quot;_s, matcher);
181 
<span class="line-modified">182     auto&amp; availableLocales = intlNumberFormatAvailableLocales();</span>
<span class="line-modified">183     auto result = resolveLocale(globalObject, availableLocales, requestedLocales, opt, relevantNumberExtensionKeys, WTF_ARRAY_LENGTH(relevantNumberExtensionKeys), IntlNFInternal::localeData);</span>
184 
185     m_locale = result.get(&quot;locale&quot;_s);
186     if (m_locale.isEmpty()) {
<span class="line-modified">187         throwTypeError(globalObject, scope, &quot;failed to initialize NumberFormat due to invalid locale&quot;_s);</span>
188         return;
189     }
190 
191     m_numberingSystem = result.get(&quot;nu&quot;_s);
192 
<span class="line-modified">193     String styleString = intlStringOption(globalObject, options, Identifier::fromString(vm, &quot;style&quot;), { &quot;decimal&quot;, &quot;percent&quot;, &quot;currency&quot; }, &quot;style must be either \&quot;decimal\&quot;, \&quot;percent\&quot;, or \&quot;currency\&quot;&quot;, &quot;decimal&quot;);</span>
194     RETURN_IF_EXCEPTION(scope, void());
195     if (styleString == &quot;decimal&quot;)
196         m_style = Style::Decimal;
197     else if (styleString == &quot;percent&quot;)
198         m_style = Style::Percent;
199     else if (styleString == &quot;currency&quot;)
200         m_style = Style::Currency;
201     else
202         ASSERT_NOT_REACHED();
203 
<span class="line-modified">204     String currency = intlStringOption(globalObject, options, Identifier::fromString(vm, &quot;currency&quot;), { }, nullptr, nullptr);</span>
205     RETURN_IF_EXCEPTION(scope, void());
206     if (!currency.isNull()) {
207         if (currency.length() != 3 || !currency.isAllSpecialCharacters&lt;isASCIIAlpha&gt;()) {
<span class="line-modified">208             throwException(globalObject, scope, createRangeError(globalObject, &quot;currency is not a well-formed currency code&quot;_s));</span>
209             return;
210         }
211     }
212 
213     unsigned currencyDigits = 0;
214     if (m_style == Style::Currency) {
215         if (currency.isNull()) {
<span class="line-modified">216             throwTypeError(globalObject, scope, &quot;currency must be a string&quot;_s);</span>
217             return;
218         }
219 
220         currency = currency.convertToASCIIUppercase();
221         m_currency = currency;
222         currencyDigits = computeCurrencyDigits(currency);
223     }
224 
<span class="line-modified">225     String currencyDisplayString = intlStringOption(globalObject, options, Identifier::fromString(vm, &quot;currencyDisplay&quot;), { &quot;code&quot;, &quot;symbol&quot;, &quot;name&quot; }, &quot;currencyDisplay must be either \&quot;code\&quot;, \&quot;symbol\&quot;, or \&quot;name\&quot;&quot;, &quot;symbol&quot;);</span>
226     RETURN_IF_EXCEPTION(scope, void());
227     if (m_style == Style::Currency) {
228         if (currencyDisplayString == &quot;code&quot;)
229             m_currencyDisplay = CurrencyDisplay::Code;
230         else if (currencyDisplayString == &quot;symbol&quot;)
231             m_currencyDisplay = CurrencyDisplay::Symbol;
232         else if (currencyDisplayString == &quot;name&quot;)
233             m_currencyDisplay = CurrencyDisplay::Name;
234         else
235             ASSERT_NOT_REACHED();
236     }
237 
<span class="line-modified">238     unsigned minimumIntegerDigits = intlNumberOption(globalObject, options, Identifier::fromString(vm, &quot;minimumIntegerDigits&quot;), 1, 21, 1);</span>
239     RETURN_IF_EXCEPTION(scope, void());
240     m_minimumIntegerDigits = minimumIntegerDigits;
241 
242     unsigned minimumFractionDigitsDefault = (m_style == Style::Currency) ? currencyDigits : 0;
243 
<span class="line-modified">244     unsigned minimumFractionDigits = intlNumberOption(globalObject, options, Identifier::fromString(vm, &quot;minimumFractionDigits&quot;), 0, 20, minimumFractionDigitsDefault);</span>
245     RETURN_IF_EXCEPTION(scope, void());
246     m_minimumFractionDigits = minimumFractionDigits;
247 
248     unsigned maximumFractionDigitsDefault;
249     if (m_style == Style::Currency)
250         maximumFractionDigitsDefault = std::max(minimumFractionDigits, currencyDigits);
251     else if (m_style == Style::Percent)
252         maximumFractionDigitsDefault = minimumFractionDigits;
253     else
254         maximumFractionDigitsDefault = std::max(minimumFractionDigits, 3u);
255 
<span class="line-modified">256     unsigned maximumFractionDigits = intlNumberOption(globalObject, options, Identifier::fromString(vm, &quot;maximumFractionDigits&quot;), minimumFractionDigits, 20, maximumFractionDigitsDefault);</span>
257     RETURN_IF_EXCEPTION(scope, void());
258     m_maximumFractionDigits = maximumFractionDigits;
259 
<span class="line-modified">260     JSValue minimumSignificantDigitsValue = options-&gt;get(globalObject, Identifier::fromString(vm, &quot;minimumSignificantDigits&quot;));</span>
261     RETURN_IF_EXCEPTION(scope, void());
262 
<span class="line-modified">263     JSValue maximumSignificantDigitsValue = options-&gt;get(globalObject, Identifier::fromString(vm, &quot;maximumSignificantDigits&quot;));</span>
264     RETURN_IF_EXCEPTION(scope, void());
265 
266     if (!minimumSignificantDigitsValue.isUndefined() || !maximumSignificantDigitsValue.isUndefined()) {
<span class="line-modified">267         unsigned minimumSignificantDigits = intlDefaultNumberOption(globalObject, minimumSignificantDigitsValue, Identifier::fromString(vm, &quot;minimumSignificantDigits&quot;), 1, 21, 1);</span>
268         RETURN_IF_EXCEPTION(scope, void());
<span class="line-modified">269         unsigned maximumSignificantDigits = intlDefaultNumberOption(globalObject, maximumSignificantDigitsValue, Identifier::fromString(vm, &quot;maximumSignificantDigits&quot;), minimumSignificantDigits, 21, 21);</span>
270         RETURN_IF_EXCEPTION(scope, void());
271         m_minimumSignificantDigits = minimumSignificantDigits;
272         m_maximumSignificantDigits = maximumSignificantDigits;
273     }
274 
275     bool usesFallback;
<span class="line-modified">276     bool useGrouping = intlBooleanOption(globalObject, options, Identifier::fromString(vm, &quot;useGrouping&quot;), usesFallback);</span>
277     if (usesFallback)
278         useGrouping = true;
279     RETURN_IF_EXCEPTION(scope, void());
280     m_useGrouping = useGrouping;
281 
282     UNumberFormatStyle style = UNUM_DEFAULT;
283     switch (m_style) {
284     case Style::Decimal:
285         style = UNUM_DECIMAL;
286         break;
287     case Style::Percent:
288         style = UNUM_PERCENT;
289         break;
290     case Style::Currency:
291         switch (m_currencyDisplay) {
292         case CurrencyDisplay::Code:
293             style = UNUM_CURRENCY_ISO;
294             break;
295         case CurrencyDisplay::Symbol:
296             style = UNUM_CURRENCY;
297             break;
298         case CurrencyDisplay::Name:
299             style = UNUM_CURRENCY_PLURAL;
300             break;
301         default:
302             ASSERT_NOT_REACHED();
303         }
304         break;
305     default:
306         ASSERT_NOT_REACHED();
307     }
308 
309     UErrorCode status = U_ZERO_ERROR;
310     m_numberFormat = std::unique_ptr&lt;UNumberFormat, UNumberFormatDeleter&gt;(unum_open(style, nullptr, 0, m_locale.utf8().data(), nullptr, &amp;status));
311     if (U_FAILURE(status)) {
<span class="line-modified">312         throwTypeError(globalObject, scope, &quot;failed to initialize NumberFormat&quot;_s);</span>
313         return;
314     }
315 
316     if (m_style == Style::Currency) {
317         unum_setTextAttribute(m_numberFormat.get(), UNUM_CURRENCY_CODE, StringView(m_currency).upconvertedCharacters(), m_currency.length(), &amp;status);
318         if (U_FAILURE(status)) {
<span class="line-modified">319             throwTypeError(globalObject, scope, &quot;failed to initialize NumberFormat&quot;_s);</span>
320             return;
321         }
322     }
323     if (!m_minimumSignificantDigits) {
324         unum_setAttribute(m_numberFormat.get(), UNUM_MIN_INTEGER_DIGITS, m_minimumIntegerDigits);
325         unum_setAttribute(m_numberFormat.get(), UNUM_MIN_FRACTION_DIGITS, m_minimumFractionDigits);
326         unum_setAttribute(m_numberFormat.get(), UNUM_MAX_FRACTION_DIGITS, m_maximumFractionDigits);
327     } else {
328         unum_setAttribute(m_numberFormat.get(), UNUM_SIGNIFICANT_DIGITS_USED, true);
329         unum_setAttribute(m_numberFormat.get(), UNUM_MIN_SIGNIFICANT_DIGITS, m_minimumSignificantDigits);
330         unum_setAttribute(m_numberFormat.get(), UNUM_MAX_SIGNIFICANT_DIGITS, m_maximumSignificantDigits);
331     }
332     unum_setAttribute(m_numberFormat.get(), UNUM_GROUPING_USED, m_useGrouping);
333     unum_setAttribute(m_numberFormat.get(), UNUM_ROUNDING_MODE, UNUM_ROUND_HALFUP);
334 
335     m_initializedNumberFormat = true;
336 }
337 
<span class="line-modified">338 JSValue IntlNumberFormat::formatNumber(JSGlobalObject* globalObject, double number)</span>
339 {
<span class="line-modified">340     VM&amp; vm = globalObject-&gt;vm();</span>
341     auto scope = DECLARE_THROW_SCOPE(vm);
342 
343     // 11.3.4 FormatNumber abstract operation (ECMA-402 2.0)
344     if (!m_initializedNumberFormat)
<span class="line-modified">345         return throwTypeError(globalObject, scope, &quot;Intl.NumberFormat.prototype.format called on value that&#39;s not an object initialized as a NumberFormat&quot;_s);</span>
346 
347     // Map negative zero to positive zero.
348     if (!number)
349         number = 0.0;
350 
351     UErrorCode status = U_ZERO_ERROR;
352     Vector&lt;UChar, 32&gt; buffer(32);
353     auto length = unum_formatDouble(m_numberFormat.get(), number, buffer.data(), buffer.size(), nullptr, &amp;status);
354     if (status == U_BUFFER_OVERFLOW_ERROR) {
355         buffer.grow(length);
356         status = U_ZERO_ERROR;
357         unum_formatDouble(m_numberFormat.get(), number, buffer.data(), length, nullptr, &amp;status);
358     }
359     if (U_FAILURE(status))
<span class="line-modified">360         return throwException(globalObject, scope, createError(globalObject, &quot;Failed to format a number.&quot;_s));</span>
361 
362     return jsString(vm, String(buffer.data(), length));
363 }
364 
365 ASCIILiteral IntlNumberFormat::styleString(Style style)
366 {
367     switch (style) {
368     case Style::Decimal:
369         return &quot;decimal&quot;_s;
370     case Style::Percent:
371         return &quot;percent&quot;_s;
372     case Style::Currency:
373         return &quot;currency&quot;_s;
374     }
375     ASSERT_NOT_REACHED();
376     return ASCIILiteral::null();
377 }
378 
379 ASCIILiteral IntlNumberFormat::currencyDisplayString(CurrencyDisplay currencyDisplay)
380 {
381     switch (currencyDisplay) {
382     case CurrencyDisplay::Code:
383         return &quot;code&quot;_s;
384     case CurrencyDisplay::Symbol:
385         return &quot;symbol&quot;_s;
386     case CurrencyDisplay::Name:
387         return &quot;name&quot;_s;
388     }
389     ASSERT_NOT_REACHED();
390     return ASCIILiteral::null();
391 }
392 
<span class="line-modified">393 JSObject* IntlNumberFormat::resolvedOptions(JSGlobalObject* globalObject)</span>
394 {
<span class="line-modified">395     VM&amp; vm = globalObject-&gt;vm();</span>
396     auto scope = DECLARE_THROW_SCOPE(vm);
397 
398     // 11.3.5 Intl.NumberFormat.prototype.resolvedOptions() (ECMA-402 2.0)
399     // The function returns a new object whose properties and attributes are set as if
400     // constructed by an object literal assigning to each of the following properties the
401     // value of the corresponding internal slot of this NumberFormat object (see 11.4):
402     // locale, numberingSystem, style, currency, currencyDisplay, minimumIntegerDigits,
403     // minimumFractionDigits, maximumFractionDigits, minimumSignificantDigits,
404     // maximumSignificantDigits, and useGrouping. Properties whose corresponding internal
405     // slots are not present are not assigned.
406 
407     if (!m_initializedNumberFormat) {
<span class="line-modified">408         initializeNumberFormat(globalObject, jsUndefined(), jsUndefined());</span>
409         scope.assertNoException();
410     }
411 
<span class="line-modified">412     JSObject* options = constructEmptyObject(globalObject);</span>
413     options-&gt;putDirect(vm, vm.propertyNames-&gt;locale, jsString(vm, m_locale));
414     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;numberingSystem&quot;), jsString(vm, m_numberingSystem));
415     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;style&quot;), jsNontrivialString(vm, styleString(m_style)));
416     if (m_style == Style::Currency) {
417         options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;currency&quot;), jsNontrivialString(vm, m_currency));
418         options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;currencyDisplay&quot;), jsNontrivialString(vm, currencyDisplayString(m_currencyDisplay)));
419     }
420     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;minimumIntegerDigits&quot;), jsNumber(m_minimumIntegerDigits));
421     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;minimumFractionDigits&quot;), jsNumber(m_minimumFractionDigits));
422     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;maximumFractionDigits&quot;), jsNumber(m_maximumFractionDigits));
423     if (m_minimumSignificantDigits) {
424         ASSERT(m_maximumSignificantDigits);
425         options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;minimumSignificantDigits&quot;), jsNumber(m_minimumSignificantDigits));
426         options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;maximumSignificantDigits&quot;), jsNumber(m_maximumSignificantDigits));
427     }
428     options-&gt;putDirect(vm, Identifier::fromString(vm, &quot;useGrouping&quot;), jsBoolean(m_useGrouping));
429     return options;
430 }
431 
432 void IntlNumberFormat::setBoundFormat(VM&amp; vm, JSBoundFunction* format)
</pre>
<hr />
<pre>
461     case UNUM_PERCENT_FIELD:
462         return &quot;percentSign&quot;_s;
463     case UNUM_SIGN_FIELD:
464         return value &lt; 0 ? &quot;minusSign&quot;_s : &quot;plusSign&quot;_s;
465     // These should not show up because there is no way to specify them in NumberFormat options.
466     // If they do, they don&#39;t fit well into any of known part types, so consider it an &quot;unknown&quot;.
467     case UNUM_PERMILL_FIELD:
468     case UNUM_EXPONENT_SYMBOL_FIELD:
469     case UNUM_EXPONENT_SIGN_FIELD:
470     case UNUM_EXPONENT_FIELD:
471 #if !defined(U_HIDE_DEPRECATED_API)
472     case UNUM_FIELD_COUNT:
473 #endif
474     // Any newer additions to the UNumberFormatFields enum should just be considered an &quot;unknown&quot; part.
475     default:
476         return &quot;unknown&quot;_s;
477     }
478     return &quot;unknown&quot;_s;
479 }
480 
<span class="line-modified">481 JSValue IntlNumberFormat::formatToParts(JSGlobalObject* globalObject, double value)</span>
482 {
<span class="line-modified">483     VM&amp; vm = globalObject-&gt;vm();</span>
484     auto scope = DECLARE_THROW_SCOPE(vm);
485 
486     // FormatNumberToParts (ECMA-402)
487     // https://tc39.github.io/ecma402/#sec-formatnumbertoparts
488     // https://tc39.github.io/ecma402/#sec-partitionnumberpattern
489 
490     if (!m_initializedNumberFormat)
<span class="line-modified">491         return throwTypeError(globalObject, scope, &quot;Intl.NumberFormat.prototype.formatToParts called on value that&#39;s not an object initialized as a NumberFormat&quot;_s);</span>
492 
493     UErrorCode status = U_ZERO_ERROR;
494     auto fieldItr = std::unique_ptr&lt;UFieldPositionIterator, UFieldPositionIteratorDeleter&gt;(ufieldpositer_open(&amp;status));
495     if (U_FAILURE(status))
<span class="line-modified">496         return throwTypeError(globalObject, scope, &quot;failed to open field position iterator&quot;_s);</span>
497 
498     status = U_ZERO_ERROR;
499     Vector&lt;UChar, 32&gt; result(32);
500     auto resultLength = unum_formatDoubleForFields(m_numberFormat.get(), value, result.data(), result.size(), fieldItr.get(), &amp;status);
501     if (status == U_BUFFER_OVERFLOW_ERROR) {
502         status = U_ZERO_ERROR;
503         result.grow(resultLength);
504         unum_formatDoubleForFields(m_numberFormat.get(), value, result.data(), resultLength, fieldItr.get(), &amp;status);
505     }
506     if (U_FAILURE(status))
<span class="line-modified">507         return throwTypeError(globalObject, scope, &quot;failed to format a number.&quot;_s);</span>
508 
509     int32_t literalFieldType = -1;
510     auto literalField = IntlNumberFormatField(literalFieldType, resultLength);
511     Vector&lt;IntlNumberFormatField&gt; fields(resultLength, literalField);
512     int32_t beginIndex = 0;
513     int32_t endIndex = 0;
514     auto fieldType = ufieldpositer_next(fieldItr.get(), &amp;beginIndex, &amp;endIndex);
515     while (fieldType &gt;= 0) {
516         auto size = endIndex - beginIndex;
517         for (auto i = beginIndex; i &lt; endIndex; ++i) {
518             // Only override previous value if new value is more specific.
519             if (fields[i].size &gt;= size)
520                 fields[i] = IntlNumberFormatField(fieldType, size);
521         }
522         fieldType = ufieldpositer_next(fieldItr.get(), &amp;beginIndex, &amp;endIndex);
523     }
524 

525     JSArray* parts = JSArray::tryCreate(vm, globalObject-&gt;arrayStructureForIndexingTypeDuringAllocation(ArrayWithContiguous), 0);
526     if (!parts)
<span class="line-modified">527         return throwOutOfMemoryError(globalObject, scope);</span>
528     unsigned index = 0;
529 
530     auto resultString = String(result.data(), resultLength);
531     auto typePropertyName = Identifier::fromString(vm, &quot;type&quot;);
<span class="line-modified">532     auto literalString = jsNontrivialString(vm, &quot;literal&quot;_s);</span>
533 
534     int32_t currentIndex = 0;
535     while (currentIndex &lt; resultLength) {
536         auto startIndex = currentIndex;
537         auto fieldType = fields[currentIndex].type;
538         while (currentIndex &lt; resultLength &amp;&amp; fields[currentIndex].type == fieldType)
539             ++currentIndex;
540         auto partType = fieldType == literalFieldType ? literalString : jsString(vm, partTypeString(UNumberFormatFields(fieldType), value));
541         auto partValue = jsSubstring(vm, resultString, startIndex, currentIndex - startIndex);
<span class="line-modified">542         JSObject* part = constructEmptyObject(globalObject);</span>
543         part-&gt;putDirect(vm, typePropertyName, partType);
544         part-&gt;putDirect(vm, vm.propertyNames-&gt;value, partValue);
<span class="line-modified">545         parts-&gt;putDirectIndex(globalObject, index++, part);</span>
546         RETURN_IF_EXCEPTION(scope, { });
547     }
548 
549     return parts;
550 }
551 #endif
552 
553 } // namespace JSC
554 
555 #endif // ENABLE(INTL)
</pre>
</td>
</tr>
</table>
<center><a href="IntlDateTimeFormatPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IntlNumberFormat.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
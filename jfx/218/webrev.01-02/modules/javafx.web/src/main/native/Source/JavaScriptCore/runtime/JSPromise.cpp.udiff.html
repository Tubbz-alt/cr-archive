<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSPromise.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JSObjectInlines.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSPromise.h.udiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/JSPromise.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -27,12 +27,14 @@</span>
  #include &quot;JSPromise.h&quot;
  
  #include &quot;BuiltinNames.h&quot;
  #include &quot;Error.h&quot;
  #include &quot;JSCInlines.h&quot;
<span class="udiff-line-added">+ #include &quot;JSInternalFieldObjectImplInlines.h&quot;</span>
  #include &quot;JSPromiseConstructor.h&quot;
  #include &quot;Microtask.h&quot;
<span class="udiff-line-added">+ #include &quot;PromiseTimer.h&quot;</span>
  
  namespace JSC {
  
  const ClassInfo JSPromise::s_info = { &quot;Promise&quot;, &amp;Base::s_info, nullptr, nullptr, CREATE_METHOD_TABLE(JSPromise) };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -43,74 +45,146 @@</span>
      return promise;
  }
  
  Structure* JSPromise::createStructure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype)
  {
<span class="udiff-line-modified-removed">-     return Structure::create(vm, globalObject, prototype, TypeInfo(ObjectType, StructureFlags), info());</span>
<span class="udiff-line-modified-added">+     return Structure::create(vm, globalObject, prototype, TypeInfo(JSPromiseType, StructureFlags), info());</span>
  }
  
  JSPromise::JSPromise(VM&amp; vm, Structure* structure)
      : Base(vm, structure)
  {
  }
  
  void JSPromise::finishCreation(VM&amp; vm)
  {
      Base::finishCreation(vm);
<span class="udiff-line-modified-removed">-     putDirect(vm, vm.propertyNames-&gt;builtinNames().promiseStatePrivateName(), jsNumber(static_cast&lt;unsigned&gt;(Status::Pending)));</span>
<span class="udiff-line-modified-removed">-     putDirect(vm, vm.propertyNames-&gt;builtinNames().promiseReactionsPrivateName(), jsUndefined());</span>
<span class="udiff-line-removed">-     putDirect(vm, vm.propertyNames-&gt;builtinNames().promiseResultPrivateName(), jsUndefined());</span>
<span class="udiff-line-modified-added">+     internalField(static_cast&lt;unsigned&gt;(Field::Flags)).set(vm, this, jsNumber(static_cast&lt;unsigned&gt;(Status::Pending)));</span>
<span class="udiff-line-modified-added">+     internalField(static_cast&lt;unsigned&gt;(Field::ReactionsOrResult)).set(vm, this, jsUndefined());</span>
  }
  
<span class="udiff-line-modified-removed">- void JSPromise::initialize(ExecState* exec, JSGlobalObject* globalObject, JSValue executor)</span>
<span class="udiff-line-modified-added">+ void JSPromise::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)</span>
  {
<span class="udiff-line-modified-removed">-     JSFunction* initializePromise = globalObject-&gt;initializePromiseFunction();</span>
<span class="udiff-line-modified-removed">-     CallData callData;</span>
<span class="udiff-line-modified-removed">-     CallType callType = JSC::getCallData(exec-&gt;vm(), initializePromise, callData);</span>
<span class="udiff-line-removed">-     ASSERT(callType != CallType::None);</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     MarkedArgumentBuffer arguments;</span>
<span class="udiff-line-removed">-     arguments.append(executor);</span>
<span class="udiff-line-removed">-     ASSERT(!arguments.hasOverflowed());</span>
<span class="udiff-line-removed">-     call(exec, initializePromise, callType, callData, this, arguments);</span>
<span class="udiff-line-modified-added">+     auto* thisObject = jsCast&lt;JSPromise*&gt;(cell);</span>
<span class="udiff-line-modified-added">+     ASSERT_GC_OBJECT_INHERITS(thisObject, info());</span>
<span class="udiff-line-modified-added">+     Base::visitChildren(thisObject, visitor);</span>
  }
  
<span class="udiff-line-modified-removed">- auto JSPromise::status(VM&amp; vm) const -&gt; Status</span>
<span class="udiff-line-modified-added">+ auto JSPromise::status(VM&amp;) const -&gt; Status</span>
  {
<span class="udiff-line-modified-removed">-     JSValue value = getDirect(vm, vm.propertyNames-&gt;builtinNames().promiseStatePrivateName());</span>
<span class="udiff-line-modified-removed">-     ASSERT(value.isUInt32());</span>
<span class="udiff-line-modified-removed">-     return static_cast&lt;Status&gt;(value.asUInt32());</span>
<span class="udiff-line-modified-added">+     JSValue value = internalField(static_cast&lt;unsigned&gt;(Field::Flags)).get();</span>
<span class="udiff-line-modified-added">+     uint32_t flags = value.asUInt32AsAnyInt();</span>
<span class="udiff-line-modified-added">+     return static_cast&lt;Status&gt;(flags &amp; stateMask);</span>
  }
  
  JSValue JSPromise::result(VM&amp; vm) const
  {
<span class="udiff-line-modified-removed">-     return getDirect(vm, vm.propertyNames-&gt;builtinNames().promiseResultPrivateName());</span>
<span class="udiff-line-modified-added">+     Status status = this-&gt;status(vm);</span>
<span class="udiff-line-added">+     if (status == Status::Pending)</span>
<span class="udiff-line-added">+         return jsUndefined();</span>
<span class="udiff-line-added">+     return internalField(static_cast&lt;unsigned&gt;(Field::ReactionsOrResult)).get();</span>
  }
  
<span class="udiff-line-modified-removed">- bool JSPromise::isHandled(VM&amp; vm) const</span>
<span class="udiff-line-modified-added">+ uint32_t JSPromise::flags() const</span>
  {
<span class="udiff-line-modified-removed">-     JSValue value = getDirect(vm, vm.propertyNames-&gt;builtinNames().promiseIsHandledPrivateName());</span>
<span class="udiff-line-modified-removed">-     ASSERT(value.isBoolean());</span>
<span class="udiff-line-removed">-     return value.asBoolean();</span>
<span class="udiff-line-modified-added">+     JSValue value = internalField(static_cast&lt;unsigned&gt;(Field::Flags)).get();</span>
<span class="udiff-line-modified-added">+     return value.asUInt32AsAnyInt();</span>
  }
  
<span class="udiff-line-modified-removed">- JSPromise* JSPromise::resolve(JSGlobalObject&amp; globalObject, JSValue value)</span>
<span class="udiff-line-modified-added">+ bool JSPromise::isHandled(VM&amp;) const</span>
  {
<span class="udiff-line-modified-removed">-     auto* exec = globalObject.globalExec();</span>
<span class="udiff-line-modified-removed">-     auto&amp; vm = exec-&gt;vm();</span>
<span class="udiff-line-modified-added">+     return flags() &amp; isHandledFlag;</span>
<span class="udiff-line-modified-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ JSPromise::DeferredData JSPromise::createDeferredData(JSGlobalObject* globalObject, JSPromiseConstructor* promiseConstructor)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
      auto scope = DECLARE_THROW_SCOPE(vm);
  
<span class="udiff-line-modified-removed">-     auto* promiseResolveFunction = globalObject.promiseResolveFunction();</span>
<span class="udiff-line-modified-added">+     JSFunction* newPromiseCapabilityFunction = globalObject-&gt;newPromiseCapabilityFunction();</span>
      CallData callData;
<span class="udiff-line-modified-removed">-     auto callType = JSC::getCallData(vm, promiseResolveFunction, callData);</span>
<span class="udiff-line-modified-added">+     CallType callType = JSC::getCallData(globalObject-&gt;vm(), newPromiseCapabilityFunction, callData);</span>
      ASSERT(callType != CallType::None);
  
      MarkedArgumentBuffer arguments;
<span class="udiff-line-modified-removed">-     arguments.append(value);</span>
<span class="udiff-line-modified-added">+     arguments.append(promiseConstructor);</span>
      ASSERT(!arguments.hasOverflowed());
<span class="udiff-line-modified-removed">-     auto result = call(exec, promiseResolveFunction, callType, callData, globalObject.promiseConstructor(), arguments);</span>
<span class="udiff-line-modified-added">+     JSValue deferred = call(globalObject, newPromiseCapabilityFunction, callType, callData, jsUndefined(), arguments);</span>
<span class="udiff-line-added">+     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     DeferredData result;</span>
<span class="udiff-line-added">+     result.promise = jsCast&lt;JSPromise*&gt;(deferred.get(globalObject, vm.propertyNames-&gt;builtinNames().promisePrivateName()));</span>
<span class="udiff-line-added">+     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="udiff-line-added">+     result.resolve = jsCast&lt;JSFunction*&gt;(deferred.get(globalObject, vm.propertyNames-&gt;builtinNames().resolvePrivateName()));</span>
<span class="udiff-line-added">+     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="udiff-line-added">+     result.reject = jsCast&lt;JSFunction*&gt;(deferred.get(globalObject, vm.propertyNames-&gt;builtinNames().rejectPrivateName()));</span>
<span class="udiff-line-added">+     RETURN_IF_EXCEPTION(scope, { });</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     return result;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ JSPromise* JSPromise::resolvedPromise(JSGlobalObject* globalObject, JSValue value)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     VM&amp; vm = globalObject-&gt;vm();</span>
<span class="udiff-line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     JSFunction* function = globalObject-&gt;promiseResolveFunction();</span>
<span class="udiff-line-added">+     CallData callData;</span>
<span class="udiff-line-added">+     CallType callType = JSC::getCallData(vm, function, callData);</span>
<span class="udiff-line-added">+     ASSERT(callType != CallType::None);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     MarkedArgumentBuffer arguments;</span>
<span class="udiff-line-added">+     arguments.append(value);</span>
<span class="udiff-line-added">+     auto result = call(globalObject, function, callType, callData, globalObject-&gt;promiseConstructor(), arguments);</span>
      RETURN_IF_EXCEPTION(scope, nullptr);
      ASSERT(result.inherits&lt;JSPromise&gt;(vm));
      return jsCast&lt;JSPromise*&gt;(result);
  }
  
<span class="udiff-line-added">+ static inline void callFunction(JSGlobalObject* globalObject, JSValue function, JSPromise* promise, JSValue value)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     CallData callData;</span>
<span class="udiff-line-added">+     CallType callType = getCallData(globalObject-&gt;vm(), function, callData);</span>
<span class="udiff-line-added">+     ASSERT(callType != CallType::None);</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     MarkedArgumentBuffer arguments;</span>
<span class="udiff-line-added">+     arguments.append(promise);</span>
<span class="udiff-line-added">+     arguments.append(value);</span>
<span class="udiff-line-added">+     ASSERT(!arguments.hasOverflowed());</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     call(globalObject, function, callType, callData, jsUndefined(), arguments);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void JSPromise::resolve(JSGlobalObject* lexicalGlobalObject, JSValue value)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
<span class="udiff-line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="udiff-line-added">+     uint32_t flags = this-&gt;flags();</span>
<span class="udiff-line-added">+     if (!(flags &amp; isFirstResolvingFunctionCalledFlag)) {</span>
<span class="udiff-line-added">+         internalField(static_cast&lt;unsigned&gt;(Field::Flags)).set(vm, this, jsNumber(flags | isFirstResolvingFunctionCalledFlag));</span>
<span class="udiff-line-added">+         JSGlobalObject* globalObject = this-&gt;globalObject(vm);</span>
<span class="udiff-line-added">+         callFunction(lexicalGlobalObject, globalObject-&gt;resolvePromiseFunction(), this, value);</span>
<span class="udiff-line-added">+         RETURN_IF_EXCEPTION(scope, void());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     vm.promiseTimer-&gt;cancelPendingPromise(this);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void JSPromise::reject(JSGlobalObject* lexicalGlobalObject, JSValue value)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     VM&amp; vm = lexicalGlobalObject-&gt;vm();</span>
<span class="udiff-line-added">+     auto scope = DECLARE_THROW_SCOPE(vm);</span>
<span class="udiff-line-added">+     uint32_t flags = this-&gt;flags();</span>
<span class="udiff-line-added">+     if (!(flags &amp; isFirstResolvingFunctionCalledFlag)) {</span>
<span class="udiff-line-added">+         internalField(static_cast&lt;unsigned&gt;(Field::Flags)).set(vm, this, jsNumber(flags | isFirstResolvingFunctionCalledFlag));</span>
<span class="udiff-line-added">+         JSGlobalObject* globalObject = this-&gt;globalObject(vm);</span>
<span class="udiff-line-added">+         callFunction(lexicalGlobalObject, globalObject-&gt;rejectPromiseFunction(), this, value);</span>
<span class="udiff-line-added">+         RETURN_IF_EXCEPTION(scope, void());</span>
<span class="udiff-line-added">+     }</span>
<span class="udiff-line-added">+     vm.promiseTimer-&gt;cancelPendingPromise(this);</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ void JSPromise::reject(JSGlobalObject* lexicalGlobalObject, Exception* reason)</span>
<span class="udiff-line-added">+ {</span>
<span class="udiff-line-added">+     reject(lexicalGlobalObject, reason-&gt;value());</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  } // namespace JSC
</pre>
<center><a href="JSObjectInlines.h.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="JSPromise.h.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
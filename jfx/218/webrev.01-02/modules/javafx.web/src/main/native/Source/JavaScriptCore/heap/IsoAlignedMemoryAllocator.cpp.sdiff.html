<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoAlignedMemoryAllocator.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="IncrementalSweeper.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IsoAlignedMemoryAllocator.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/heap/IsoAlignedMemoryAllocator.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;IsoAlignedMemoryAllocator.h&quot;
 28 #include &quot;MarkedBlock.h&quot;
 29 
 30 namespace JSC {
 31 
<span class="line-modified"> 32 IsoAlignedMemoryAllocator::IsoAlignedMemoryAllocator()</span>



 33 {

 34 }
 35 
 36 IsoAlignedMemoryAllocator::~IsoAlignedMemoryAllocator()
 37 {

 38     for (unsigned i = 0; i &lt; m_blocks.size(); ++i) {
 39         void* block = m_blocks[i];
 40         if (!m_committed[i])
 41             WTF::fastCommitAlignedMemory(block, MarkedBlock::blockSize);
 42         fastAlignedFree(block);
 43     }

 44 }
 45 
 46 void* IsoAlignedMemoryAllocator::tryAllocateAlignedMemory(size_t alignment, size_t size)
 47 {
 48     // Since this is designed specially for IsoSubspace, we know that we will only be asked to
 49     // allocate MarkedBlocks.
 50     RELEASE_ASSERT(alignment == MarkedBlock::blockSize);
 51     RELEASE_ASSERT(size == MarkedBlock::blockSize);
 52 



 53     auto locker = holdLock(m_lock);
 54 
 55     m_firstUncommitted = m_committed.findBit(m_firstUncommitted, false);
 56     if (m_firstUncommitted &lt; m_blocks.size()) {
 57         m_committed[m_firstUncommitted] = true;
 58         void* result = m_blocks[m_firstUncommitted];
 59         WTF::fastCommitAlignedMemory(result, MarkedBlock::blockSize);
 60         return result;
 61     }
 62 
 63     void* result = tryFastAlignedMalloc(MarkedBlock::blockSize, MarkedBlock::blockSize);
 64     if (!result)
 65         return nullptr;
 66     unsigned index = m_blocks.size();
 67     m_blocks.append(result);
 68     m_blockIndices.add(result, index);
 69     if (m_blocks.capacity() != m_committed.size())
 70         m_committed.resize(m_blocks.capacity());
 71     m_committed[index] = true;
 72     return result;

 73 }
 74 
 75 void IsoAlignedMemoryAllocator::freeAlignedMemory(void* basePtr)
 76 {



 77     auto locker = holdLock(m_lock);
 78 
 79     auto iter = m_blockIndices.find(basePtr);
 80     RELEASE_ASSERT(iter != m_blockIndices.end());
 81     unsigned index = iter-&gt;value;
 82     m_committed[index] = false;
 83     m_firstUncommitted = std::min(index, m_firstUncommitted);
 84     WTF::fastDecommitAlignedMemory(basePtr, MarkedBlock::blockSize);

 85 }
 86 
 87 void IsoAlignedMemoryAllocator::dump(PrintStream&amp; out) const
 88 {
 89     out.print(&quot;Iso(&quot;, RawPointer(this), &quot;)&quot;);
 90 }
 91 
<span class="line-modified"> 92 void* IsoAlignedMemoryAllocator::tryAllocateMemory(size_t)</span>
 93 {
<span class="line-modified"> 94     RELEASE_ASSERT_NOT_REACHED();</span>




 95 }
 96 
<span class="line-modified"> 97 void IsoAlignedMemoryAllocator::freeMemory(void*)</span>
 98 {
<span class="line-modified"> 99     RELEASE_ASSERT_NOT_REACHED();</span>




100 }
101 
102 void* IsoAlignedMemoryAllocator::tryReallocateMemory(void*, size_t)
103 {

104     RELEASE_ASSERT_NOT_REACHED();
105 }
106 
107 } // namespace JSC
108 
</pre>
</td>
<td>
<hr />
<pre>
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;IsoAlignedMemoryAllocator.h&quot;
 28 #include &quot;MarkedBlock.h&quot;
 29 
 30 namespace JSC {
 31 
<span class="line-modified"> 32 IsoAlignedMemoryAllocator::IsoAlignedMemoryAllocator(CString name)</span>
<span class="line-added"> 33 #if ENABLE(MALLOC_HEAP_BREAKDOWN)</span>
<span class="line-added"> 34     : m_debugHeap(name.data())</span>
<span class="line-added"> 35 #endif</span>
 36 {
<span class="line-added"> 37     UNUSED_PARAM(name);</span>
 38 }
 39 
 40 IsoAlignedMemoryAllocator::~IsoAlignedMemoryAllocator()
 41 {
<span class="line-added"> 42 #if !ENABLE(MALLOC_HEAP_BREAKDOWN)</span>
 43     for (unsigned i = 0; i &lt; m_blocks.size(); ++i) {
 44         void* block = m_blocks[i];
 45         if (!m_committed[i])
 46             WTF::fastCommitAlignedMemory(block, MarkedBlock::blockSize);
 47         fastAlignedFree(block);
 48     }
<span class="line-added"> 49 #endif</span>
 50 }
 51 
 52 void* IsoAlignedMemoryAllocator::tryAllocateAlignedMemory(size_t alignment, size_t size)
 53 {
 54     // Since this is designed specially for IsoSubspace, we know that we will only be asked to
 55     // allocate MarkedBlocks.
 56     RELEASE_ASSERT(alignment == MarkedBlock::blockSize);
 57     RELEASE_ASSERT(size == MarkedBlock::blockSize);
 58 
<span class="line-added"> 59 #if ENABLE(MALLOC_HEAP_BREAKDOWN)</span>
<span class="line-added"> 60     return m_debugHeap.memalign(MarkedBlock::blockSize, MarkedBlock::blockSize, true);</span>
<span class="line-added"> 61 #else</span>
 62     auto locker = holdLock(m_lock);
 63 
 64     m_firstUncommitted = m_committed.findBit(m_firstUncommitted, false);
 65     if (m_firstUncommitted &lt; m_blocks.size()) {
 66         m_committed[m_firstUncommitted] = true;
 67         void* result = m_blocks[m_firstUncommitted];
 68         WTF::fastCommitAlignedMemory(result, MarkedBlock::blockSize);
 69         return result;
 70     }
 71 
 72     void* result = tryFastAlignedMalloc(MarkedBlock::blockSize, MarkedBlock::blockSize);
 73     if (!result)
 74         return nullptr;
 75     unsigned index = m_blocks.size();
 76     m_blocks.append(result);
 77     m_blockIndices.add(result, index);
 78     if (m_blocks.capacity() != m_committed.size())
 79         m_committed.resize(m_blocks.capacity());
 80     m_committed[index] = true;
 81     return result;
<span class="line-added"> 82 #endif</span>
 83 }
 84 
 85 void IsoAlignedMemoryAllocator::freeAlignedMemory(void* basePtr)
 86 {
<span class="line-added"> 87 #if ENABLE(MALLOC_HEAP_BREAKDOWN)</span>
<span class="line-added"> 88     m_debugHeap.free(basePtr);</span>
<span class="line-added"> 89 #else</span>
 90     auto locker = holdLock(m_lock);
 91 
 92     auto iter = m_blockIndices.find(basePtr);
 93     RELEASE_ASSERT(iter != m_blockIndices.end());
 94     unsigned index = iter-&gt;value;
 95     m_committed[index] = false;
 96     m_firstUncommitted = std::min(index, m_firstUncommitted);
 97     WTF::fastDecommitAlignedMemory(basePtr, MarkedBlock::blockSize);
<span class="line-added"> 98 #endif</span>
 99 }
100 
101 void IsoAlignedMemoryAllocator::dump(PrintStream&amp; out) const
102 {
103     out.print(&quot;Iso(&quot;, RawPointer(this), &quot;)&quot;);
104 }
105 
<span class="line-modified">106 void* IsoAlignedMemoryAllocator::tryAllocateMemory(size_t size)</span>
107 {
<span class="line-modified">108 #if ENABLE(MALLOC_HEAP_BREAKDOWN)</span>
<span class="line-added">109     return m_debugHeap.malloc(size);</span>
<span class="line-added">110 #else</span>
<span class="line-added">111     return FastMalloc::tryMalloc(size);</span>
<span class="line-added">112 #endif</span>
113 }
114 
<span class="line-modified">115 void IsoAlignedMemoryAllocator::freeMemory(void* pointer)</span>
116 {
<span class="line-modified">117 #if ENABLE(MALLOC_HEAP_BREAKDOWN)</span>
<span class="line-added">118     m_debugHeap.free(pointer);</span>
<span class="line-added">119 #else</span>
<span class="line-added">120     FastMalloc::free(pointer);</span>
<span class="line-added">121 #endif</span>
122 }
123 
124 void* IsoAlignedMemoryAllocator::tryReallocateMemory(void*, size_t)
125 {
<span class="line-added">126     // In IsoSubspace-managed PreciseAllocation, we must not perform realloc.</span>
127     RELEASE_ASSERT_NOT_REACHED();
128 }
129 
130 } // namespace JSC
131 
</pre>
</td>
</tr>
</table>
<center><a href="IncrementalSweeper.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="IsoAlignedMemoryAllocator.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
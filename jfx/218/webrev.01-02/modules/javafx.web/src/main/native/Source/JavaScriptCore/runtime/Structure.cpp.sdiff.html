<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Structure.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="StringRecursionChecker.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Structure.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/Structure.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  70 
  71 inline Structure* StructureTransitionTable::singleTransition() const
  72 {
  73     ASSERT(isUsingSingleSlot());
  74     if (WeakImpl* impl = this-&gt;weakImpl()) {
  75         if (impl-&gt;state() == WeakImpl::Live)
  76             return jsCast&lt;Structure*&gt;(impl-&gt;jsValue().asCell());
  77     }
  78     return nullptr;
  79 }
  80 
  81 inline void StructureTransitionTable::setSingleTransition(Structure* structure)
  82 {
  83     ASSERT(isUsingSingleSlot());
  84     if (WeakImpl* impl = this-&gt;weakImpl())
  85         WeakSet::deallocate(impl);
  86     WeakImpl* impl = WeakSet::allocate(structure, &amp;singleSlotTransitionWeakOwner(), this);
  87     m_data = bitwise_cast&lt;intptr_t&gt;(impl) | UsingSingleSlotFlag;
  88 }
  89 
<span class="line-modified">  90 bool StructureTransitionTable::contains(UniquedStringImpl* rep, unsigned attributes) const</span>
  91 {
  92     if (isUsingSingleSlot()) {
  93         Structure* transition = singleTransition();
<span class="line-modified">  94         return transition &amp;&amp; transition-&gt;m_nameInPrevious == rep &amp;&amp; transition-&gt;attributesInPrevious() == attributes;</span>
  95     }
<span class="line-modified">  96     return map()-&gt;get(std::make_pair(rep, attributes));</span>
  97 }
  98 
<span class="line-modified">  99 inline Structure* StructureTransitionTable::get(UniquedStringImpl* rep, unsigned attributes) const</span>
 100 {
 101     if (isUsingSingleSlot()) {
 102         Structure* transition = singleTransition();
<span class="line-modified"> 103         return (transition &amp;&amp; transition-&gt;m_nameInPrevious == rep &amp;&amp; transition-&gt;attributesInPrevious() == attributes) ? transition : 0;</span>
 104     }
<span class="line-modified"> 105     return map()-&gt;get(std::make_pair(rep, attributes));</span>
 106 }
 107 
 108 void StructureTransitionTable::add(VM&amp; vm, Structure* structure)
 109 {
 110     if (isUsingSingleSlot()) {
 111         Structure* existingTransition = singleTransition();
 112 
 113         // This handles the first transition being added.
 114         if (!existingTransition) {
 115             setSingleTransition(structure);
 116             return;
 117         }
 118 
 119         // This handles the second transition being added
 120         // (or the first transition being despecified!)
 121         setMap(new TransitionMap(vm));
 122         add(vm, existingTransition);
 123     }
 124 
 125     // Add the structure to the map.
<span class="line-modified"> 126 </span>
<span class="line-removed"> 127     // Newer versions of the STL have an std::make_pair function that takes rvalue references.</span>
<span class="line-removed"> 128     // When either of the parameters are bitfields, the C++ compiler will try to bind them as lvalues, which is invalid. To work around this, use unary &quot;+&quot; to make the parameter an rvalue.</span>
<span class="line-removed"> 129     // See https://bugs.webkit.org/show_bug.cgi?id=59261 for more details</span>
<span class="line-removed"> 130     map()-&gt;set(std::make_pair(structure-&gt;m_nameInPrevious.get(), +structure-&gt;attributesInPrevious()), structure);</span>
 131 }
 132 
 133 void Structure::dumpStatistics()
 134 {
 135 #if DUMP_STRUCTURE_ID_STATISTICS
 136     unsigned numberLeaf = 0;
 137     unsigned numberUsingSingleSlot = 0;
 138     unsigned numberSingletons = 0;
 139     unsigned numberWithPropertyMaps = 0;
 140     unsigned totalPropertyMapsSize = 0;
 141 
 142     HashSet&lt;Structure*&gt;::const_iterator end = liveStructureSet.end();
 143     for (HashSet&lt;Structure*&gt;::const_iterator it = liveStructureSet.begin(); it != end; ++it) {
 144         Structure* structure = *it;
 145 
 146         switch (structure-&gt;m_transitionTable.size()) {
 147             case 0:
 148                 ++numberLeaf;
 149                 if (!structure-&gt;previousID())
 150                     ++numberSingletons;
</pre>
<hr />
<pre>
 168     dataLogF(&quot;Number of Structures with PropertyMaps: %d\n&quot;, numberWithPropertyMaps);
 169 
 170     dataLogF(&quot;Size of a single Structures: %d\n&quot;, static_cast&lt;unsigned&gt;(sizeof(Structure)));
 171     dataLogF(&quot;Size of sum of all property maps: %d\n&quot;, totalPropertyMapsSize);
 172     dataLogF(&quot;Size of average of all property maps: %f\n&quot;, static_cast&lt;double&gt;(totalPropertyMapsSize) / static_cast&lt;double&gt;(liveStructureSet.size()));
 173 #else
 174     dataLogF(&quot;Dumping Structure statistics is not enabled.\n&quot;);
 175 #endif
 176 }
 177 
 178 Structure::Structure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, const TypeInfo&amp; typeInfo, const ClassInfo* classInfo, IndexingType indexingType, unsigned inlineCapacity)
 179     : JSCell(vm, vm.structureStructure.get())
 180     , m_blob(vm.heap.structureIDTable().allocateID(this), indexingType, typeInfo)
 181     , m_outOfLineTypeFlags(typeInfo.outOfLineTypeFlags())
 182     , m_inlineCapacity(inlineCapacity)
 183     , m_bitField(0)
 184     , m_globalObject(vm, this, globalObject, WriteBarrier&lt;JSGlobalObject&gt;::MayBeNull)
 185     , m_prototype(vm, this, prototype)
 186     , m_classInfo(classInfo)
 187     , m_transitionWatchpointSet(IsWatched)
<span class="line-removed"> 188     , m_offset(invalidOffset)</span>
 189     , m_propertyHash(0)
 190 {
 191     setDictionaryKind(NoneDictionaryKind);
 192     setIsPinnedPropertyTable(false);
 193     setHasGetterSetterProperties(classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 194     setHasCustomGetterSetterProperties(false);
 195     setHasReadOnlyOrGetterSetterPropertiesExcludingProto(classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 196     setHasUnderscoreProtoPropertyExcludingOriginalProto(false);
 197     setIsQuickPropertyAccessAllowedForEnumeration(true);
<span class="line-modified"> 198     setAttributesInPrevious(0);</span>
 199     setDidPreventExtensions(false);
 200     setDidTransition(false);
 201     setStaticPropertiesReified(false);
 202     setTransitionWatchpointIsLikelyToBeFired(false);
 203     setHasBeenDictionary(false);
<span class="line-modified"> 204     setIsAddingPropertyForTransition(false);</span>



 205 
 206     ASSERT(inlineCapacity &lt;= JSFinalObject::maxInlineCapacity());
 207     ASSERT(static_cast&lt;PropertyOffset&gt;(inlineCapacity) &lt; firstOutOfLineOffset);
 208     ASSERT(!hasRareData());
 209     ASSERT(hasReadOnlyOrGetterSetterPropertiesExcludingProto() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 210     ASSERT(hasGetterSetterProperties() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 211     ASSERT(!this-&gt;typeInfo().overridesGetCallData() || m_classInfo-&gt;methodTable.getCallData != &amp;JSCell::getCallData);
 212 }
 213 
 214 const ClassInfo Structure::s_info = { &quot;Structure&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(Structure) };
 215 
 216 Structure::Structure(VM&amp; vm)
 217     : JSCell(CreatingEarlyCell)
 218     , m_inlineCapacity(0)
 219     , m_bitField(0)
 220     , m_prototype(vm, this, jsNull())
 221     , m_classInfo(info())
 222     , m_transitionWatchpointSet(IsWatched)
<span class="line-removed"> 223     , m_offset(invalidOffset)</span>
 224     , m_propertyHash(0)
 225 {
 226     setDictionaryKind(NoneDictionaryKind);
 227     setIsPinnedPropertyTable(false);
 228     setHasGetterSetterProperties(m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 229     setHasCustomGetterSetterProperties(false);
 230     setHasReadOnlyOrGetterSetterPropertiesExcludingProto(m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 231     setHasUnderscoreProtoPropertyExcludingOriginalProto(false);
 232     setIsQuickPropertyAccessAllowedForEnumeration(true);
<span class="line-modified"> 233     setAttributesInPrevious(0);</span>
 234     setDidPreventExtensions(false);
 235     setDidTransition(false);
 236     setStaticPropertiesReified(false);
 237     setTransitionWatchpointIsLikelyToBeFired(false);
 238     setHasBeenDictionary(false);
<span class="line-modified"> 239     setIsAddingPropertyForTransition(false);</span>



 240 
 241     TypeInfo typeInfo = TypeInfo(CellType, StructureFlags);
 242     m_blob = StructureIDBlob(vm.heap.structureIDTable().allocateID(this), 0, typeInfo);
 243     m_outOfLineTypeFlags = typeInfo.outOfLineTypeFlags();
 244 
 245     ASSERT(hasReadOnlyOrGetterSetterPropertiesExcludingProto() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 246     ASSERT(hasGetterSetterProperties() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 247     ASSERT(!this-&gt;typeInfo().overridesGetCallData() || m_classInfo-&gt;methodTable.getCallData != &amp;JSCell::getCallData);
 248 }
 249 
 250 Structure::Structure(VM&amp; vm, Structure* previous, DeferredStructureTransitionWatchpointFire* deferred)
 251     : JSCell(vm, vm.structureStructure.get())
 252     , m_inlineCapacity(previous-&gt;m_inlineCapacity)
 253     , m_bitField(0)
 254     , m_prototype(vm, this, previous-&gt;m_prototype.get())
 255     , m_classInfo(previous-&gt;m_classInfo)
 256     , m_transitionWatchpointSet(IsWatched)
<span class="line-removed"> 257     , m_offset(invalidOffset)</span>
 258     , m_propertyHash(previous-&gt;m_propertyHash)

 259 {
 260     setDictionaryKind(previous-&gt;dictionaryKind());
 261     setIsPinnedPropertyTable(false);
 262     setHasBeenFlattenedBefore(previous-&gt;hasBeenFlattenedBefore());
 263     setHasGetterSetterProperties(previous-&gt;hasGetterSetterProperties());
 264     setHasCustomGetterSetterProperties(previous-&gt;hasCustomGetterSetterProperties());
 265     setHasReadOnlyOrGetterSetterPropertiesExcludingProto(previous-&gt;hasReadOnlyOrGetterSetterPropertiesExcludingProto());
 266     setHasUnderscoreProtoPropertyExcludingOriginalProto(previous-&gt;hasUnderscoreProtoPropertyExcludingOriginalProto());
 267     setIsQuickPropertyAccessAllowedForEnumeration(previous-&gt;isQuickPropertyAccessAllowedForEnumeration());
<span class="line-modified"> 268     setAttributesInPrevious(0);</span>
 269     setDidPreventExtensions(previous-&gt;didPreventExtensions());
 270     setDidTransition(true);
 271     setStaticPropertiesReified(previous-&gt;staticPropertiesReified());
 272     setHasBeenDictionary(previous-&gt;hasBeenDictionary());
<span class="line-modified"> 273     setIsAddingPropertyForTransition(false);</span>



 274 
 275     TypeInfo typeInfo = previous-&gt;typeInfo();
 276     m_blob = StructureIDBlob(vm.heap.structureIDTable().allocateID(this), previous-&gt;indexingModeIncludingHistory(), typeInfo);
 277     m_outOfLineTypeFlags = typeInfo.outOfLineTypeFlags();
 278 
 279     ASSERT(!previous-&gt;typeInfo().structureIsImmortal());
 280     setPreviousID(vm, previous);
 281 
 282     previous-&gt;didTransitionFromThisStructure(deferred);
 283 
 284     // Copy this bit now, in case previous was being watched.
 285     setTransitionWatchpointIsLikelyToBeFired(previous-&gt;transitionWatchpointIsLikelyToBeFired());
 286 
 287     if (previous-&gt;m_globalObject)
 288         m_globalObject.set(vm, this, previous-&gt;m_globalObject.get());
 289     ASSERT(hasReadOnlyOrGetterSetterPropertiesExcludingProto() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 290     ASSERT(hasGetterSetterProperties() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 291     ASSERT(!this-&gt;typeInfo().overridesGetCallData() || m_classInfo-&gt;methodTable.getCallData != &amp;JSCell::getCallData);
 292 }
 293 
 294 Structure::~Structure()
 295 {
 296     if (typeInfo().structureIsImmortal())
 297         return;
 298     Heap::heap(this)-&gt;structureIDTable().deallocateID(this, m_blob.structureID());
 299 }
 300 
 301 void Structure::destroy(JSCell* cell)
 302 {
 303     static_cast&lt;Structure*&gt;(cell)-&gt;Structure::~Structure();
 304 }
 305 
 306 Structure* Structure::create(PolyProtoTag, VM&amp; vm, JSGlobalObject* globalObject, JSObject* prototype, const TypeInfo&amp; typeInfo, const ClassInfo* classInfo, IndexingType indexingType, unsigned inlineCapacity)
 307 {
 308     Structure* result = create(vm, globalObject, prototype, typeInfo, classInfo, indexingType, inlineCapacity);
 309 
 310     unsigned oldOutOfLineCapacity = result-&gt;outOfLineCapacity();
 311     result-&gt;addPropertyWithoutTransition(
 312         vm, vm.propertyNames-&gt;builtinNames().polyProtoName(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum),
<span class="line-modified"> 313         [&amp;] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset offset, PropertyOffset newLastOffset) {</span>
<span class="line-modified"> 314             RELEASE_ASSERT(Structure::outOfLineCapacity(newLastOffset) == oldOutOfLineCapacity);</span>
 315             RELEASE_ASSERT(offset == knownPolyProtoOffset);
 316             RELEASE_ASSERT(isInlineOffset(knownPolyProtoOffset));
 317             result-&gt;m_prototype.setWithoutWriteBarrier(JSValue());
<span class="line-modified"> 318             result-&gt;setLastOffset(newLastOffset);</span>
 319         });
 320 
 321     return result;
 322 }
 323 
 324 bool Structure::isValidPrototype(JSValue prototype)
 325 {
 326     return prototype.isNull() || (prototype.isObject() &amp;&amp; prototype.getObject()-&gt;mayBePrototype());
 327 }
 328 
 329 void Structure::findStructuresAndMapForMaterialization(Vector&lt;Structure*, 8&gt;&amp; structures, Structure*&amp; structure, PropertyTable*&amp; table)
 330 {
 331     ASSERT(structures.isEmpty());
 332     table = 0;
 333 
 334     for (structure = this; structure; structure = structure-&gt;previousID()) {
 335         structure-&gt;m_lock.lock();
 336 
 337         table = structure-&gt;propertyTableOrNull();
 338         if (table) {
 339             // Leave the structure locked, so that the caller can do things to it atomically
 340             // before it loses its property table.
 341             return;
 342         }
 343 
 344         structures.append(structure);
 345         structure-&gt;m_lock.unlock();
 346     }
 347 
 348     ASSERT(!structure);
 349     ASSERT(!table);
 350 }
 351 
 352 PropertyTable* Structure::materializePropertyTable(VM&amp; vm, bool setPropertyTable)
 353 {
 354     ASSERT(structure(vm)-&gt;classInfo() == info());
<span class="line-modified"> 355     ASSERT(!isAddingPropertyForTransition());</span>
 356 
 357     DeferGC deferGC(vm.heap);
 358 
 359     Vector&lt;Structure*, 8&gt; structures;
 360     Structure* structure;
 361     PropertyTable* table;
 362 
 363     findStructuresAndMapForMaterialization(structures, structure, table);
 364 
<span class="line-modified"> 365     unsigned capacity = numberOfSlotsForLastOffset(m_offset, m_inlineCapacity);</span>
 366     if (table) {
 367         table = table-&gt;copy(vm, capacity);
 368         structure-&gt;m_lock.unlock();
 369     } else
 370         table = PropertyTable::create(vm, capacity);
 371 
 372     // Must hold the lock on this structure, since we will be modifying this structure&#39;s
 373     // property map. We don&#39;t want getConcurrently() to see the property map in a half-baked
 374     // state.
 375     GCSafeConcurrentJSLocker locker(m_lock, vm.heap);
 376     if (setPropertyTable)
 377         this-&gt;setPropertyTable(vm, table);
 378 
 379     for (size_t i = structures.size(); i--;) {
 380         structure = structures[i];
<span class="line-modified"> 381         if (!structure-&gt;m_nameInPrevious)</span>






 382             continue;
<span class="line-modified"> 383         PropertyMapEntry entry(structure-&gt;m_nameInPrevious.get(), structure-&gt;m_offset, structure-&gt;attributesInPrevious());</span>
<span class="line-modified"> 384         table-&gt;add(entry, m_offset, PropertyTable::PropertyOffsetMustNotChange);</span>





 385     }
 386 
 387     checkOffsetConsistency(
 388         table,
 389         [&amp;] () {
 390             dataLog(&quot;Detected in materializePropertyTable.\n&quot;);
 391             dataLog(&quot;Found structure = &quot;, RawPointer(structure), &quot;\n&quot;);
 392             dataLog(&quot;structures = &quot;);
 393             CommaPrinter comma;
 394             for (Structure* structure : structures)
 395                 dataLog(comma, RawPointer(structure));
 396             dataLog(&quot;\n&quot;);
 397         });
 398 
 399     return table;
 400 }
 401 
 402 Structure* Structure::addPropertyTransitionToExistingStructureImpl(Structure* structure, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp; offset)
 403 {
 404     ASSERT(!structure-&gt;isDictionary());
 405     ASSERT(structure-&gt;isObject());
 406 
<span class="line-modified"> 407     if (Structure* existingTransition = structure-&gt;m_transitionTable.get(uid, attributes)) {</span>
<span class="line-modified"> 408         validateOffset(existingTransition-&gt;m_offset, existingTransition-&gt;inlineCapacity());</span>
<span class="line-modified"> 409         offset = existingTransition-&gt;m_offset;</span>

 410         return existingTransition;
 411     }
 412 
 413     return 0;
 414 }
 415 
 416 Structure* Structure::addPropertyTransitionToExistingStructure(Structure* structure, PropertyName propertyName, unsigned attributes, PropertyOffset&amp; offset)
 417 {
 418     ASSERT(!isCompilationThread());
 419     return addPropertyTransitionToExistingStructureImpl(structure, propertyName.uid(), attributes, offset);
 420 }
 421 
 422 Structure* Structure::addPropertyTransitionToExistingStructureConcurrently(Structure* structure, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp; offset)
 423 {
 424     ConcurrentJSLocker locker(structure-&gt;m_lock);
 425     return addPropertyTransitionToExistingStructureImpl(structure, uid, attributes, offset);
 426 }
 427 
 428 bool Structure::holesMustForwardToPrototype(VM&amp; vm, JSObject* base) const
 429 {
</pre>
<hr />
<pre>
 456     Structure* newStructure = addPropertyTransitionToExistingStructure(
 457         structure, propertyName, attributes, offset);
 458     if (newStructure)
 459         return newStructure;
 460 
 461     return addNewPropertyTransition(
 462         vm, structure, propertyName, attributes, offset, PutPropertySlot::UnknownContext);
 463 }
 464 
 465 Structure* Structure::addNewPropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, unsigned attributes, PropertyOffset&amp; offset, PutPropertySlot::Context context, DeferredStructureTransitionWatchpointFire* deferred)
 466 {
 467     ASSERT(!structure-&gt;isDictionary());
 468     ASSERT(structure-&gt;isObject());
 469     ASSERT(!Structure::addPropertyTransitionToExistingStructure(structure, propertyName, attributes, offset));
 470 
 471     int maxTransitionLength;
 472     if (context == PutPropertySlot::PutById)
 473         maxTransitionLength = s_maxTransitionLengthForNonEvalPutById;
 474     else
 475         maxTransitionLength = s_maxTransitionLength;
<span class="line-modified"> 476     if (structure-&gt;transitionCount() &gt; maxTransitionLength) {</span>
 477         ASSERT(!isCopyOnWrite(structure-&gt;indexingMode()));
 478         Structure* transition = toCacheableDictionaryTransition(vm, structure, deferred);
 479         ASSERT(structure != transition);
 480         offset = transition-&gt;add(vm, propertyName, attributes);
 481         return transition;
 482     }
 483 
 484     Structure* transition = create(vm, structure, deferred);
 485 
 486     transition-&gt;m_cachedPrototypeChain.setMayBeNull(vm, transition, structure-&gt;m_cachedPrototypeChain.get());
 487 
 488     // While we are adding the property, rematerializing the property table is super weird: we already
<span class="line-modified"> 489     // have a m_nameInPrevious and attributesInPrevious but the m_offset is still wrong. If the</span>
 490     // materialization algorithm runs, it&#39;ll build a property table that already has the property but
 491     // at a bogus offset. Rather than try to teach the materialization code how to create a table under
 492     // those conditions, we just tell the GC not to blow the table away during this period of time.
 493     // Holding the lock ensures that we either do this before the GC starts scanning the structure, in
 494     // which case the GC will not blow the table away, or we do it after the GC already ran in which
 495     // case all is well.  If it wasn&#39;t for the lock, the GC would have TOCTOU: if could read
<span class="line-modified"> 496     // isAddingPropertyForTransition before we set it to true, and then blow the table away after.</span>
 497     {
 498         ConcurrentJSLocker locker(transition-&gt;m_lock);
<span class="line-modified"> 499         transition-&gt;setIsAddingPropertyForTransition(true);</span>
 500     }
 501 
 502     transition-&gt;m_blob.setIndexingModeIncludingHistory(structure-&gt;indexingModeIncludingHistory() &amp; ~CopyOnWrite);
<span class="line-modified"> 503     transition-&gt;m_nameInPrevious = propertyName.uid();</span>
<span class="line-modified"> 504     transition-&gt;setAttributesInPrevious(attributes);</span>
 505     transition-&gt;setPropertyTable(vm, structure-&gt;takePropertyTableOrCloneIfPinned(vm));
<span class="line-modified"> 506     transition-&gt;m_offset = structure-&gt;m_offset;</span>
 507 
 508     offset = transition-&gt;add(vm, propertyName, attributes);

 509 
 510     // Now that everything is fine with the new structure&#39;s bookkeeping, the GC is free to blow the
 511     // table away if it wants. We can now rebuild it fine.
 512     WTF::storeStoreFence();
<span class="line-modified"> 513     transition-&gt;setIsAddingPropertyForTransition(false);</span>
 514 
<span class="line-modified"> 515     checkOffset(transition-&gt;m_offset, transition-&gt;inlineCapacity());</span>
 516     {
<span class="line-modified"> 517         ConcurrentJSLocker locker(structure-&gt;m_lock);</span>
<span class="line-removed"> 518         DeferGC deferGC(vm.heap);</span>
 519         structure-&gt;m_transitionTable.add(vm, transition);
 520     }
 521     transition-&gt;checkOffsetConsistency();
 522     structure-&gt;checkOffsetConsistency();
 523     return transition;
 524 }
 525 
<span class="line-modified"> 526 Structure* Structure::removePropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertyOffset&amp; offset)</span>
<span class="line-modified"> 527 {</span>
<span class="line-modified"> 528     // NOTE: There are some good reasons why this goes directly to uncacheable dictionary rather than</span>
<span class="line-modified"> 529     // caching the removal. We can fix all of these things, but we must remember to do so, if we ever try</span>
<span class="line-modified"> 530     // to optimize this case.</span>
<span class="line-modified"> 531     //</span>
<span class="line-modified"> 532     // - Cached transitions usually steal the property table, and assume that this is possible because they</span>
<span class="line-modified"> 533     //   can just rebuild the table by looking at past transitions. That code assumes that the table only</span>
<span class="line-modified"> 534     //   grew and never shrank. To support removals, we&#39;d have to change the property table materialization</span>
<span class="line-modified"> 535     //   code to handle deletions. Also, we have logic to get the list of properties on a structure that</span>
<span class="line-modified"> 536     //   lacks a property table by just looking back through the set of transitions since the last</span>
<span class="line-modified"> 537     //   structure that had a pinned table. That logic would also have to be changed to handle cached</span>
<span class="line-modified"> 538     //   removals.</span>
<span class="line-modified"> 539     //</span>
 540     ASSERT(!structure-&gt;isUncacheableDictionary());




 541 
<span class="line-modified"> 542     Structure* transition = toUncacheableDictionaryTransition(vm, structure);</span>





 543 
<span class="line-modified"> 544     offset = transition-&gt;remove(propertyName);</span>

 545 















































 546     transition-&gt;checkOffsetConsistency();

 547     return transition;
 548 }
 549 
 550 Structure* Structure::changePrototypeTransition(VM&amp; vm, Structure* structure, JSValue prototype, DeferredStructureTransitionWatchpointFire&amp; deferred)
 551 {
 552     ASSERT(isValidPrototype(prototype));
 553 
 554     DeferGC deferGC(vm.heap);
 555     Structure* transition = create(vm, structure, &amp;deferred);
 556 
 557     transition-&gt;m_prototype.set(vm, transition, prototype);
 558 
 559     PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 560     transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
<span class="line-modified"> 561     transition-&gt;m_offset = structure-&gt;m_offset;</span>
 562 
 563     transition-&gt;checkOffsetConsistency();
 564     return transition;
 565 }
 566 
 567 Structure* Structure::attributeChangeTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, unsigned attributes)
 568 {
 569     if (!structure-&gt;isUncacheableDictionary()) {
 570         Structure* transition = create(vm, structure);
 571 
 572         PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 573         transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
<span class="line-modified"> 574         transition-&gt;m_offset = structure-&gt;m_offset;</span>
 575 
 576         structure = transition;
 577     }
 578 
 579     PropertyMapEntry* entry = structure-&gt;ensurePropertyTable(vm)-&gt;get(propertyName.uid());
 580     ASSERT(entry);
 581     entry-&gt;attributes = attributes;
 582 
 583     structure-&gt;checkOffsetConsistency();
 584     return structure;
 585 }
 586 
 587 Structure* Structure::toDictionaryTransition(VM&amp; vm, Structure* structure, DictionaryKind kind, DeferredStructureTransitionWatchpointFire* deferred)
 588 {
 589     ASSERT(!structure-&gt;isUncacheableDictionary());
 590     DeferGC deferGC(vm.heap);
 591 
 592     Structure* transition = create(vm, structure, deferred);
 593 
 594     PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 595     transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
<span class="line-modified"> 596     transition-&gt;m_offset = structure-&gt;m_offset;</span>
 597     transition-&gt;setDictionaryKind(kind);
 598     transition-&gt;setHasBeenDictionary(true);
 599 
 600     transition-&gt;checkOffsetConsistency();
 601     return transition;
 602 }
 603 
 604 Structure* Structure::toCacheableDictionaryTransition(VM&amp; vm, Structure* structure, DeferredStructureTransitionWatchpointFire* deferred)
 605 {
 606     return toDictionaryTransition(vm, structure, CachedDictionaryKind, deferred);
 607 }
 608 
<span class="line-modified"> 609 Structure* Structure::toUncacheableDictionaryTransition(VM&amp; vm, Structure* structure)</span>
 610 {
<span class="line-modified"> 611     return toDictionaryTransition(vm, structure, UncachedDictionaryKind);</span>
 612 }
 613 
 614 Structure* Structure::sealTransition(VM&amp; vm, Structure* structure)
 615 {
 616     return nonPropertyTransition(vm, structure, NonPropertyTransition::Seal);
 617 }
 618 
 619 Structure* Structure::freezeTransition(VM&amp; vm, Structure* structure)
 620 {
 621     return nonPropertyTransition(vm, structure, NonPropertyTransition::Freeze);
 622 }
 623 
 624 Structure* Structure::preventExtensionsTransition(VM&amp; vm, Structure* structure)
 625 {
 626     return nonPropertyTransition(vm, structure, NonPropertyTransition::PreventExtensions);
 627 }
 628 
 629 PropertyTable* Structure::takePropertyTableOrCloneIfPinned(VM&amp; vm)
 630 {
 631     // This must always return a property table. It can&#39;t return null.
 632     PropertyTable* result = propertyTableOrNull();
 633     if (result) {
 634         if (isPinnedPropertyTable())
 635             return result-&gt;copy(vm, result-&gt;size() + 1);
 636         ConcurrentJSLocker locker(m_lock);
 637         setPropertyTable(vm, nullptr);
 638         return result;
 639     }
 640     bool setPropertyTable = false;
 641     return materializePropertyTable(vm, setPropertyTable);
 642 }
 643 
 644 Structure* Structure::nonPropertyTransitionSlow(VM&amp; vm, Structure* structure, NonPropertyTransition transitionKind)
 645 {
 646     unsigned attributes = toAttributes(transitionKind);
 647     IndexingType indexingModeIncludingHistory = newIndexingType(structure-&gt;indexingModeIncludingHistory(), transitionKind);
 648 
 649     Structure* existingTransition;
<span class="line-modified"> 650     if (!structure-&gt;isDictionary() &amp;&amp; (existingTransition = structure-&gt;m_transitionTable.get(0, attributes))) {</span>
<span class="line-modified"> 651         ASSERT(existingTransition-&gt;attributesInPrevious() == attributes);</span>

 652         ASSERT(existingTransition-&gt;indexingModeIncludingHistory() == indexingModeIncludingHistory);
 653         return existingTransition;
 654     }
 655 
 656     DeferGC deferGC(vm.heap);
 657 
 658     Structure* transition = create(vm, structure);
<span class="line-modified"> 659     transition-&gt;setAttributesInPrevious(attributes);</span>
 660     transition-&gt;m_blob.setIndexingModeIncludingHistory(indexingModeIncludingHistory);
 661 
 662     if (preventsExtensions(transitionKind))
 663         transition-&gt;setDidPreventExtensions(true);
 664 
 665     if (setsDontDeleteOnAllProperties(transitionKind)
 666         || setsReadOnlyOnNonAccessorProperties(transitionKind)) {
 667         // We pin the property table on transitions that do wholesale editing of the property
 668         // table, since our logic for walking the property transition chain to rematerialize the
 669         // table doesn&#39;t know how to take into account such wholesale edits.
 670 
 671         PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 672         transition-&gt;pinForCaching(holdLock(transition-&gt;m_lock), vm, table);
<span class="line-modified"> 673         transition-&gt;m_offset = structure-&gt;m_offset;</span>
 674 
 675         table = transition-&gt;propertyTableOrNull();
 676         RELEASE_ASSERT(table);
 677         for (auto&amp; entry : *table) {
 678             if (setsDontDeleteOnAllProperties(transitionKind))
 679                 entry.attributes |= static_cast&lt;unsigned&gt;(PropertyAttribute::DontDelete);
 680             if (setsReadOnlyOnNonAccessorProperties(transitionKind) &amp;&amp; !(entry.attributes &amp; PropertyAttribute::Accessor))
 681                 entry.attributes |= static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly);
 682         }
 683     } else {
 684         transition-&gt;setPropertyTable(vm, structure-&gt;takePropertyTableOrCloneIfPinned(vm));
<span class="line-modified"> 685         transition-&gt;m_offset = structure-&gt;m_offset;</span>
<span class="line-modified"> 686         checkOffset(transition-&gt;m_offset, transition-&gt;inlineCapacity());</span>
 687     }
 688 
 689     if (setsReadOnlyOnNonAccessorProperties(transitionKind)
 690         &amp;&amp; !transition-&gt;propertyTableOrNull()-&gt;isEmpty())
 691         transition-&gt;setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true);
 692 
 693     if (structure-&gt;isDictionary()) {
 694         PropertyTable* table = transition-&gt;ensurePropertyTable(vm);
 695         transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
 696     } else {
 697         auto locker = holdLock(structure-&gt;m_lock);
 698         structure-&gt;m_transitionTable.add(vm, transition);
 699     }
 700 
 701     transition-&gt;checkOffsetConsistency();
 702     return transition;
 703 }
 704 
 705 // In future we may want to cache this property.
 706 bool Structure::isSealed(VM&amp; vm)
</pre>
<hr />
<pre>
 727         return false;
 728 
 729     PropertyTable* table = ensurePropertyTableIfNotEmpty(vm);
 730     if (!table)
 731         return true;
 732 
 733     PropertyTable::iterator end = table-&gt;end();
 734     for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter) {
 735         if (!(iter-&gt;attributes &amp; PropertyAttribute::DontDelete))
 736             return false;
 737         if (!(iter-&gt;attributes &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor)))
 738             return false;
 739     }
 740     return true;
 741 }
 742 
 743 Structure* Structure::flattenDictionaryStructure(VM&amp; vm, JSObject* object)
 744 {
 745     checkOffsetConsistency();
 746     ASSERT(isDictionary());

 747 
 748     GCSafeConcurrentJSLocker locker(m_lock, vm.heap);
 749 
 750     object-&gt;setStructureIDDirectly(nuke(id()));
 751     WTF::storeStoreFence();
 752 
 753     size_t beforeOutOfLineCapacity = this-&gt;outOfLineCapacity();
 754     if (isUncacheableDictionary()) {
 755         PropertyTable* table = propertyTableOrNull();
 756         ASSERT(table);
 757 
 758         size_t propertyCount = table-&gt;size();
 759 
 760         // Holds our values compacted by insertion order.
 761         Vector&lt;JSValue&gt; values(propertyCount);
 762 
 763         // Copies out our values from their hashed locations, compacting property table offsets as we go.
 764         unsigned i = 0;
 765         PropertyTable::iterator end = table-&gt;end();
<span class="line-modified"> 766         m_offset = invalidOffset;</span>
 767         for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter, ++i) {
 768             values[i] = object-&gt;getDirect(iter-&gt;offset);
<span class="line-modified"> 769             m_offset = iter-&gt;offset = offsetForPropertyNumber(i, m_inlineCapacity);</span>
 770         }


 771 
 772         // Copies in our values to their compacted locations.
 773         for (unsigned i = 0; i &lt; propertyCount; i++)
 774             object-&gt;putDirect(vm, offsetForPropertyNumber(i, m_inlineCapacity), values[i]);
 775 
 776         table-&gt;clearDeletedOffsets();
 777 
 778         // We need to zero our unused property space; otherwise the GC might see a
 779         // stale pointer when we add properties in the future.
<span class="line-modified"> 780         memset(</span>
 781             object-&gt;inlineStorageUnsafe() + inlineSize(),
<span class="line-removed"> 782             0,</span>
 783             (inlineCapacity() - inlineSize()) * sizeof(EncodedJSValue));
 784 
 785         Butterfly* butterfly = object-&gt;butterfly();
 786         size_t preCapacity = butterfly-&gt;indexingHeader()-&gt;preCapacity(this);
 787         void* base = butterfly-&gt;base(preCapacity, beforeOutOfLineCapacity);
 788         void* startOfPropertyStorageSlots = reinterpret_cast&lt;EncodedJSValue*&gt;(base) + preCapacity;
<span class="line-modified"> 789         memset(startOfPropertyStorageSlots, 0, (beforeOutOfLineCapacity - outOfLineSize()) * sizeof(EncodedJSValue));</span>
 790         checkOffsetConsistency();
 791     }
 792 
 793     setDictionaryKind(NoneDictionaryKind);
 794     setHasBeenFlattenedBefore(true);
 795 
 796     size_t afterOutOfLineCapacity = this-&gt;outOfLineCapacity();
 797 
 798     if (object-&gt;butterfly() &amp;&amp; beforeOutOfLineCapacity != afterOutOfLineCapacity) {
 799         ASSERT(beforeOutOfLineCapacity &gt; afterOutOfLineCapacity);
 800         // If the object had a Butterfly but after flattening/compacting we no longer have need of it,
 801         // we need to zero it out because the collector depends on the Structure to know the size for copying.
 802         if (!afterOutOfLineCapacity &amp;&amp; !this-&gt;hasIndexingHeader(object))
 803             object-&gt;setButterfly(vm, nullptr);
 804         // If the object was down-sized to the point where the base of the Butterfly is no longer within the
 805         // first CopiedBlock::blockSize bytes, we&#39;ll get the wrong answer if we try to mask the base back to
 806         // the CopiedBlock header. To prevent this case we need to memmove the Butterfly down.
 807         else
 808             object-&gt;shiftButterflyAfterFlattening(locker, vm, this, afterOutOfLineCapacity);
 809     }
 810 
 811     WTF::storeStoreFence();
 812     object-&gt;setStructureIDDirectly(id());
 813 
 814     // We need to do a writebarrier here because the GC thread might be scanning the butterfly while
 815     // we are shuffling properties around. See: https://bugs.webkit.org/show_bug.cgi?id=166989
 816     vm.heap.writeBarrier(object);
 817 
 818     return this;
 819 }
 820 
 821 void Structure::pin(const AbstractLocker&amp;, VM&amp; vm, PropertyTable* table)
 822 {
 823     setIsPinnedPropertyTable(true);
 824     setPropertyTable(vm, table);
 825     clearPreviousID();
<span class="line-modified"> 826     m_nameInPrevious = nullptr;</span>
 827 }
 828 
 829 void Structure::pinForCaching(const AbstractLocker&amp;, VM&amp; vm, PropertyTable* table)
 830 {
 831     setIsPinnedPropertyTable(true);
 832     setPropertyTable(vm, table);
<span class="line-modified"> 833     m_nameInPrevious = nullptr;</span>
 834 }
 835 
 836 void Structure::allocateRareData(VM&amp; vm)
 837 {
 838     ASSERT(!hasRareData());
 839     StructureRareData* rareData = StructureRareData::create(vm, previousID());
 840     WTF::storeStoreFence();
 841     m_previousOrRareData.set(vm, this, rareData);
 842     ASSERT(hasRareData());
 843 }
 844 
 845 WatchpointSet* Structure::ensurePropertyReplacementWatchpointSet(VM&amp; vm, PropertyOffset offset)
 846 {
 847     ASSERT(!isUncacheableDictionary());
 848 
 849     // In some places it&#39;s convenient to call this with an invalid offset. So, we do the check here.
 850     if (!isValidOffset(offset))
 851         return nullptr;
 852 
 853     if (!hasRareData())
</pre>
<hr />
<pre>
 945     return result;
 946 }
 947 
 948 Vector&lt;PropertyMapEntry&gt; Structure::getPropertiesConcurrently()
 949 {
 950     Vector&lt;PropertyMapEntry&gt; result;
 951 
 952     forEachPropertyConcurrently(
 953         [&amp;] (const PropertyMapEntry&amp; entry) -&gt; bool {
 954             result.append(entry);
 955             return true;
 956         });
 957 
 958     return result;
 959 }
 960 
 961 PropertyOffset Structure::add(VM&amp; vm, PropertyName propertyName, unsigned attributes)
 962 {
 963     return add&lt;ShouldPin::No&gt;(
 964         vm, propertyName, attributes,
<span class="line-modified"> 965         [this] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset, PropertyOffset newLastOffset) {</span>
<span class="line-modified"> 966             setLastOffset(newLastOffset);</span>
 967         });
 968 }
 969 
<span class="line-modified"> 970 PropertyOffset Structure::remove(PropertyName propertyName)</span>
 971 {
<span class="line-modified"> 972     return remove(propertyName, [] (const ConcurrentJSLocker&amp;, PropertyOffset) { });</span>


 973 }
 974 
 975 void Structure::getPropertyNamesFromStructure(VM&amp; vm, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
 976 {
 977     PropertyTable* table = ensurePropertyTableIfNotEmpty(vm);
 978     if (!table)
 979         return;
 980 
 981     bool knownUnique = propertyNames.canAddKnownUniqueForStructure();
 982 
 983     PropertyTable::iterator end = table-&gt;end();
 984     for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter) {
 985         ASSERT(!isQuickPropertyAccessAllowedForEnumeration() || !(iter-&gt;attributes &amp; PropertyAttribute::DontEnum));
 986         ASSERT(!isQuickPropertyAccessAllowedForEnumeration() || !iter-&gt;key-&gt;isSymbol());
 987         if (!(iter-&gt;attributes &amp; PropertyAttribute::DontEnum) || mode.includeDontEnumProperties()) {
 988             if (iter-&gt;key-&gt;isSymbol() &amp;&amp; !propertyNames.includeSymbolProperties())
 989                 continue;
 990             if (knownUnique)
 991                 propertyNames.addUnchecked(iter-&gt;key);
 992             else
</pre>
<hr />
<pre>
1032 }
1033 
1034 void Structure::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
1035 {
1036     Structure* thisObject = jsCast&lt;Structure*&gt;(cell);
1037     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
1038 
1039     Base::visitChildren(thisObject, visitor);
1040 
1041     ConcurrentJSLocker locker(thisObject-&gt;m_lock);
1042 
1043     visitor.append(thisObject-&gt;m_globalObject);
1044     if (!thisObject-&gt;isObject())
1045         thisObject-&gt;m_cachedPrototypeChain.clear();
1046     else {
1047         visitor.append(thisObject-&gt;m_prototype);
1048         visitor.append(thisObject-&gt;m_cachedPrototypeChain);
1049     }
1050     visitor.append(thisObject-&gt;m_previousOrRareData);
1051 
<span class="line-modified">1052     if (thisObject-&gt;isPinnedPropertyTable() || thisObject-&gt;isAddingPropertyForTransition()) {</span>
1053         // NOTE: This can interleave in pin(), in which case it may see a null property table.
1054         // That&#39;s fine, because then the barrier will fire and we will scan this again.
1055         visitor.append(thisObject-&gt;m_propertyTableUnsafe);
1056     } else if (visitor.isAnalyzingHeap())
1057         visitor.append(thisObject-&gt;m_propertyTableUnsafe);
1058     else if (thisObject-&gt;m_propertyTableUnsafe)
1059         thisObject-&gt;m_propertyTableUnsafe.clear();
1060 }
1061 
1062 bool Structure::isCheapDuringGC(VM&amp; vm)
1063 {
1064     // FIXME: We could make this even safer by returning false if this structure&#39;s property table
1065     // has any large property names.
1066     // https://bugs.webkit.org/show_bug.cgi?id=157334
1067 
1068     return (!m_globalObject || vm.heap.isMarked(m_globalObject.get()))
1069         &amp;&amp; (hasPolyProto() || !storedPrototypeObject() || vm.heap.isMarked(storedPrototypeObject()));
1070 }
1071 
1072 bool Structure::markIfCheap(SlotVisitor&amp; visitor)
</pre>
<hr />
<pre>
1190         }
1191     }
1192     return false;
1193 }
1194 
1195 void Structure::setCachedPropertyNameEnumerator(VM&amp; vm, JSPropertyNameEnumerator* enumerator)
1196 {
1197     ASSERT(!isDictionary());
1198     if (!hasRareData())
1199         allocateRareData(vm);
1200     rareData()-&gt;setCachedPropertyNameEnumerator(vm, enumerator);
1201 }
1202 
1203 JSPropertyNameEnumerator* Structure::cachedPropertyNameEnumerator() const
1204 {
1205     if (!hasRareData())
1206         return nullptr;
1207     return rareData()-&gt;cachedPropertyNameEnumerator();
1208 }
1209 
<span class="line-modified">1210 bool Structure::canCachePropertyNameEnumerator() const</span>
1211 {
1212     if (!this-&gt;canCacheOwnKeys())
1213         return false;
1214 
1215     StructureChain* structureChain = m_cachedPrototypeChain.get();
1216     ASSERT(structureChain);
<span class="line-modified">1217     WriteBarrier&lt;Structure&gt;* structure = structureChain-&gt;head();</span>
1218     while (true) {
<span class="line-modified">1219         if (!structure-&gt;get())</span>

1220             return true;
<span class="line-modified">1221         if (!structure-&gt;get()-&gt;canCacheOwnKeys())</span>

1222             return false;
<span class="line-modified">1223         structure++;</span>
1224     }
1225 
1226     ASSERT_NOT_REACHED();
1227     return true;
1228 }
1229 
1230 bool Structure::canAccessPropertiesQuicklyForEnumeration() const
1231 {
1232     if (!isQuickPropertyAccessAllowedForEnumeration())
1233         return false;
1234     if (hasGetterSetterProperties())
1235         return false;
1236     if (isUncacheableDictionary())
1237         return false;
1238     return true;
1239 }
1240 











1241 } // namespace JSC
</pre>
</td>
<td>
<hr />
<pre>
  70 
  71 inline Structure* StructureTransitionTable::singleTransition() const
  72 {
  73     ASSERT(isUsingSingleSlot());
  74     if (WeakImpl* impl = this-&gt;weakImpl()) {
  75         if (impl-&gt;state() == WeakImpl::Live)
  76             return jsCast&lt;Structure*&gt;(impl-&gt;jsValue().asCell());
  77     }
  78     return nullptr;
  79 }
  80 
  81 inline void StructureTransitionTable::setSingleTransition(Structure* structure)
  82 {
  83     ASSERT(isUsingSingleSlot());
  84     if (WeakImpl* impl = this-&gt;weakImpl())
  85         WeakSet::deallocate(impl);
  86     WeakImpl* impl = WeakSet::allocate(structure, &amp;singleSlotTransitionWeakOwner(), this);
  87     m_data = bitwise_cast&lt;intptr_t&gt;(impl) | UsingSingleSlotFlag;
  88 }
  89 
<span class="line-modified">  90 bool StructureTransitionTable::contains(UniquedStringImpl* rep, unsigned attributes, bool isAddition) const</span>
  91 {
  92     if (isUsingSingleSlot()) {
  93         Structure* transition = singleTransition();
<span class="line-modified">  94         return transition &amp;&amp; transition-&gt;m_transitionPropertyName == rep &amp;&amp; transition-&gt;transitionPropertyAttributes() == attributes &amp;&amp; transition-&gt;isPropertyDeletionTransition() == !isAddition;</span>
  95     }
<span class="line-modified">  96     return map()-&gt;get(StructureTransitionTable::Hash::Key(rep, attributes, isAddition));</span>
  97 }
  98 
<span class="line-modified">  99 inline Structure* StructureTransitionTable::get(UniquedStringImpl* rep, unsigned attributes, bool isAddition) const</span>
 100 {
 101     if (isUsingSingleSlot()) {
 102         Structure* transition = singleTransition();
<span class="line-modified"> 103         return (transition &amp;&amp; transition-&gt;m_transitionPropertyName == rep &amp;&amp; transition-&gt;transitionPropertyAttributes() == attributes &amp;&amp; transition-&gt;isPropertyDeletionTransition() == !isAddition) ? transition : 0;</span>
 104     }
<span class="line-modified"> 105     return map()-&gt;get(StructureTransitionTable::Hash::Key(rep, attributes, isAddition));</span>
 106 }
 107 
 108 void StructureTransitionTable::add(VM&amp; vm, Structure* structure)
 109 {
 110     if (isUsingSingleSlot()) {
 111         Structure* existingTransition = singleTransition();
 112 
 113         // This handles the first transition being added.
 114         if (!existingTransition) {
 115             setSingleTransition(structure);
 116             return;
 117         }
 118 
 119         // This handles the second transition being added
 120         // (or the first transition being despecified!)
 121         setMap(new TransitionMap(vm));
 122         add(vm, existingTransition);
 123     }
 124 
 125     // Add the structure to the map.
<span class="line-modified"> 126     map()-&gt;set(StructureTransitionTable::Hash::Key(structure-&gt;m_transitionPropertyName.get(), structure-&gt;transitionPropertyAttributes(), !structure-&gt;isPropertyDeletionTransition()), structure);</span>




 127 }
 128 
 129 void Structure::dumpStatistics()
 130 {
 131 #if DUMP_STRUCTURE_ID_STATISTICS
 132     unsigned numberLeaf = 0;
 133     unsigned numberUsingSingleSlot = 0;
 134     unsigned numberSingletons = 0;
 135     unsigned numberWithPropertyMaps = 0;
 136     unsigned totalPropertyMapsSize = 0;
 137 
 138     HashSet&lt;Structure*&gt;::const_iterator end = liveStructureSet.end();
 139     for (HashSet&lt;Structure*&gt;::const_iterator it = liveStructureSet.begin(); it != end; ++it) {
 140         Structure* structure = *it;
 141 
 142         switch (structure-&gt;m_transitionTable.size()) {
 143             case 0:
 144                 ++numberLeaf;
 145                 if (!structure-&gt;previousID())
 146                     ++numberSingletons;
</pre>
<hr />
<pre>
 164     dataLogF(&quot;Number of Structures with PropertyMaps: %d\n&quot;, numberWithPropertyMaps);
 165 
 166     dataLogF(&quot;Size of a single Structures: %d\n&quot;, static_cast&lt;unsigned&gt;(sizeof(Structure)));
 167     dataLogF(&quot;Size of sum of all property maps: %d\n&quot;, totalPropertyMapsSize);
 168     dataLogF(&quot;Size of average of all property maps: %f\n&quot;, static_cast&lt;double&gt;(totalPropertyMapsSize) / static_cast&lt;double&gt;(liveStructureSet.size()));
 169 #else
 170     dataLogF(&quot;Dumping Structure statistics is not enabled.\n&quot;);
 171 #endif
 172 }
 173 
 174 Structure::Structure(VM&amp; vm, JSGlobalObject* globalObject, JSValue prototype, const TypeInfo&amp; typeInfo, const ClassInfo* classInfo, IndexingType indexingType, unsigned inlineCapacity)
 175     : JSCell(vm, vm.structureStructure.get())
 176     , m_blob(vm.heap.structureIDTable().allocateID(this), indexingType, typeInfo)
 177     , m_outOfLineTypeFlags(typeInfo.outOfLineTypeFlags())
 178     , m_inlineCapacity(inlineCapacity)
 179     , m_bitField(0)
 180     , m_globalObject(vm, this, globalObject, WriteBarrier&lt;JSGlobalObject&gt;::MayBeNull)
 181     , m_prototype(vm, this, prototype)
 182     , m_classInfo(classInfo)
 183     , m_transitionWatchpointSet(IsWatched)

 184     , m_propertyHash(0)
 185 {
 186     setDictionaryKind(NoneDictionaryKind);
 187     setIsPinnedPropertyTable(false);
 188     setHasGetterSetterProperties(classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 189     setHasCustomGetterSetterProperties(false);
 190     setHasReadOnlyOrGetterSetterPropertiesExcludingProto(classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 191     setHasUnderscoreProtoPropertyExcludingOriginalProto(false);
 192     setIsQuickPropertyAccessAllowedForEnumeration(true);
<span class="line-modified"> 193     setTransitionPropertyAttributes(0);</span>
 194     setDidPreventExtensions(false);
 195     setDidTransition(false);
 196     setStaticPropertiesReified(false);
 197     setTransitionWatchpointIsLikelyToBeFired(false);
 198     setHasBeenDictionary(false);
<span class="line-modified"> 199     setProtectPropertyTableWhileTransitioning(false);</span>
<span class="line-added"> 200     setIsPropertyDeletionTransition(false);</span>
<span class="line-added"> 201     setTransitionOffset(vm, invalidOffset);</span>
<span class="line-added"> 202     setMaxOffset(vm, invalidOffset);</span>
 203 
 204     ASSERT(inlineCapacity &lt;= JSFinalObject::maxInlineCapacity());
 205     ASSERT(static_cast&lt;PropertyOffset&gt;(inlineCapacity) &lt; firstOutOfLineOffset);
 206     ASSERT(!hasRareData());
 207     ASSERT(hasReadOnlyOrGetterSetterPropertiesExcludingProto() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 208     ASSERT(hasGetterSetterProperties() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 209     ASSERT(!this-&gt;typeInfo().overridesGetCallData() || m_classInfo-&gt;methodTable.getCallData != &amp;JSCell::getCallData);
 210 }
 211 
 212 const ClassInfo Structure::s_info = { &quot;Structure&quot;, nullptr, nullptr, nullptr, CREATE_METHOD_TABLE(Structure) };
 213 
 214 Structure::Structure(VM&amp; vm)
 215     : JSCell(CreatingEarlyCell)
 216     , m_inlineCapacity(0)
 217     , m_bitField(0)
 218     , m_prototype(vm, this, jsNull())
 219     , m_classInfo(info())
 220     , m_transitionWatchpointSet(IsWatched)

 221     , m_propertyHash(0)
 222 {
 223     setDictionaryKind(NoneDictionaryKind);
 224     setIsPinnedPropertyTable(false);
 225     setHasGetterSetterProperties(m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 226     setHasCustomGetterSetterProperties(false);
 227     setHasReadOnlyOrGetterSetterPropertiesExcludingProto(m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 228     setHasUnderscoreProtoPropertyExcludingOriginalProto(false);
 229     setIsQuickPropertyAccessAllowedForEnumeration(true);
<span class="line-modified"> 230     setTransitionPropertyAttributes(0);</span>
 231     setDidPreventExtensions(false);
 232     setDidTransition(false);
 233     setStaticPropertiesReified(false);
 234     setTransitionWatchpointIsLikelyToBeFired(false);
 235     setHasBeenDictionary(false);
<span class="line-modified"> 236     setProtectPropertyTableWhileTransitioning(false);</span>
<span class="line-added"> 237     setIsPropertyDeletionTransition(false);</span>
<span class="line-added"> 238     setTransitionOffset(vm, invalidOffset);</span>
<span class="line-added"> 239     setMaxOffset(vm, invalidOffset);</span>
 240 
 241     TypeInfo typeInfo = TypeInfo(CellType, StructureFlags);
 242     m_blob = StructureIDBlob(vm.heap.structureIDTable().allocateID(this), 0, typeInfo);
 243     m_outOfLineTypeFlags = typeInfo.outOfLineTypeFlags();
 244 
 245     ASSERT(hasReadOnlyOrGetterSetterPropertiesExcludingProto() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 246     ASSERT(hasGetterSetterProperties() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 247     ASSERT(!this-&gt;typeInfo().overridesGetCallData() || m_classInfo-&gt;methodTable.getCallData != &amp;JSCell::getCallData);
 248 }
 249 
 250 Structure::Structure(VM&amp; vm, Structure* previous, DeferredStructureTransitionWatchpointFire* deferred)
 251     : JSCell(vm, vm.structureStructure.get())
 252     , m_inlineCapacity(previous-&gt;m_inlineCapacity)
 253     , m_bitField(0)
 254     , m_prototype(vm, this, previous-&gt;m_prototype.get())
 255     , m_classInfo(previous-&gt;m_classInfo)
 256     , m_transitionWatchpointSet(IsWatched)

 257     , m_propertyHash(previous-&gt;m_propertyHash)
<span class="line-added"> 258     , m_seenProperties(previous-&gt;m_seenProperties)</span>
 259 {
 260     setDictionaryKind(previous-&gt;dictionaryKind());
 261     setIsPinnedPropertyTable(false);
 262     setHasBeenFlattenedBefore(previous-&gt;hasBeenFlattenedBefore());
 263     setHasGetterSetterProperties(previous-&gt;hasGetterSetterProperties());
 264     setHasCustomGetterSetterProperties(previous-&gt;hasCustomGetterSetterProperties());
 265     setHasReadOnlyOrGetterSetterPropertiesExcludingProto(previous-&gt;hasReadOnlyOrGetterSetterPropertiesExcludingProto());
 266     setHasUnderscoreProtoPropertyExcludingOriginalProto(previous-&gt;hasUnderscoreProtoPropertyExcludingOriginalProto());
 267     setIsQuickPropertyAccessAllowedForEnumeration(previous-&gt;isQuickPropertyAccessAllowedForEnumeration());
<span class="line-modified"> 268     setTransitionPropertyAttributes(0);</span>
 269     setDidPreventExtensions(previous-&gt;didPreventExtensions());
 270     setDidTransition(true);
 271     setStaticPropertiesReified(previous-&gt;staticPropertiesReified());
 272     setHasBeenDictionary(previous-&gt;hasBeenDictionary());
<span class="line-modified"> 273     setProtectPropertyTableWhileTransitioning(false);</span>
<span class="line-added"> 274     setIsPropertyDeletionTransition(false);</span>
<span class="line-added"> 275     setTransitionOffset(vm, invalidOffset);</span>
<span class="line-added"> 276     setMaxOffset(vm, invalidOffset);</span>
 277 
 278     TypeInfo typeInfo = previous-&gt;typeInfo();
 279     m_blob = StructureIDBlob(vm.heap.structureIDTable().allocateID(this), previous-&gt;indexingModeIncludingHistory(), typeInfo);
 280     m_outOfLineTypeFlags = typeInfo.outOfLineTypeFlags();
 281 
 282     ASSERT(!previous-&gt;typeInfo().structureIsImmortal());
 283     setPreviousID(vm, previous);
 284 
 285     previous-&gt;didTransitionFromThisStructure(deferred);
 286 
 287     // Copy this bit now, in case previous was being watched.
 288     setTransitionWatchpointIsLikelyToBeFired(previous-&gt;transitionWatchpointIsLikelyToBeFired());
 289 
 290     if (previous-&gt;m_globalObject)
 291         m_globalObject.set(vm, this, previous-&gt;m_globalObject.get());
 292     ASSERT(hasReadOnlyOrGetterSetterPropertiesExcludingProto() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 293     ASSERT(hasGetterSetterProperties() || !m_classInfo-&gt;hasStaticSetterOrReadonlyProperties());
 294     ASSERT(!this-&gt;typeInfo().overridesGetCallData() || m_classInfo-&gt;methodTable.getCallData != &amp;JSCell::getCallData);
 295 }
 296 
 297 Structure::~Structure()
 298 {
 299     if (typeInfo().structureIsImmortal())
 300         return;
 301     Heap::heap(this)-&gt;structureIDTable().deallocateID(this, m_blob.structureID());
 302 }
 303 
 304 void Structure::destroy(JSCell* cell)
 305 {
 306     static_cast&lt;Structure*&gt;(cell)-&gt;Structure::~Structure();
 307 }
 308 
 309 Structure* Structure::create(PolyProtoTag, VM&amp; vm, JSGlobalObject* globalObject, JSObject* prototype, const TypeInfo&amp; typeInfo, const ClassInfo* classInfo, IndexingType indexingType, unsigned inlineCapacity)
 310 {
 311     Structure* result = create(vm, globalObject, prototype, typeInfo, classInfo, indexingType, inlineCapacity);
 312 
 313     unsigned oldOutOfLineCapacity = result-&gt;outOfLineCapacity();
 314     result-&gt;addPropertyWithoutTransition(
 315         vm, vm.propertyNames-&gt;builtinNames().polyProtoName(), static_cast&lt;unsigned&gt;(PropertyAttribute::DontEnum),
<span class="line-modified"> 316         [&amp;] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset offset, PropertyOffset newMaxOffset) {</span>
<span class="line-modified"> 317             RELEASE_ASSERT(Structure::outOfLineCapacity(newMaxOffset) == oldOutOfLineCapacity);</span>
 318             RELEASE_ASSERT(offset == knownPolyProtoOffset);
 319             RELEASE_ASSERT(isInlineOffset(knownPolyProtoOffset));
 320             result-&gt;m_prototype.setWithoutWriteBarrier(JSValue());
<span class="line-modified"> 321             result-&gt;setMaxOffset(vm, newMaxOffset);</span>
 322         });
 323 
 324     return result;
 325 }
 326 
 327 bool Structure::isValidPrototype(JSValue prototype)
 328 {
 329     return prototype.isNull() || (prototype.isObject() &amp;&amp; prototype.getObject()-&gt;mayBePrototype());
 330 }
 331 
 332 void Structure::findStructuresAndMapForMaterialization(Vector&lt;Structure*, 8&gt;&amp; structures, Structure*&amp; structure, PropertyTable*&amp; table)
 333 {
 334     ASSERT(structures.isEmpty());
 335     table = 0;
 336 
 337     for (structure = this; structure; structure = structure-&gt;previousID()) {
 338         structure-&gt;m_lock.lock();
 339 
 340         table = structure-&gt;propertyTableOrNull();
 341         if (table) {
 342             // Leave the structure locked, so that the caller can do things to it atomically
 343             // before it loses its property table.
 344             return;
 345         }
 346 
 347         structures.append(structure);
 348         structure-&gt;m_lock.unlock();
 349     }
 350 
 351     ASSERT(!structure);
 352     ASSERT(!table);
 353 }
 354 
 355 PropertyTable* Structure::materializePropertyTable(VM&amp; vm, bool setPropertyTable)
 356 {
 357     ASSERT(structure(vm)-&gt;classInfo() == info());
<span class="line-modified"> 358     ASSERT(!protectPropertyTableWhileTransitioning());</span>
 359 
 360     DeferGC deferGC(vm.heap);
 361 
 362     Vector&lt;Structure*, 8&gt; structures;
 363     Structure* structure;
 364     PropertyTable* table;
 365 
 366     findStructuresAndMapForMaterialization(structures, structure, table);
 367 
<span class="line-modified"> 368     unsigned capacity = numberOfSlotsForMaxOffset(maxOffset(), m_inlineCapacity);</span>
 369     if (table) {
 370         table = table-&gt;copy(vm, capacity);
 371         structure-&gt;m_lock.unlock();
 372     } else
 373         table = PropertyTable::create(vm, capacity);
 374 
 375     // Must hold the lock on this structure, since we will be modifying this structure&#39;s
 376     // property map. We don&#39;t want getConcurrently() to see the property map in a half-baked
 377     // state.
 378     GCSafeConcurrentJSLocker locker(m_lock, vm.heap);
 379     if (setPropertyTable)
 380         this-&gt;setPropertyTable(vm, table);
 381 
 382     for (size_t i = structures.size(); i--;) {
 383         structure = structures[i];
<span class="line-modified"> 384         if (!structure-&gt;m_transitionPropertyName)</span>
<span class="line-added"> 385             continue;</span>
<span class="line-added"> 386         if (structure-&gt;isPropertyDeletionTransition()) {</span>
<span class="line-added"> 387             auto item = table-&gt;find(structure-&gt;m_transitionPropertyName.get());</span>
<span class="line-added"> 388             ASSERT(item.first);</span>
<span class="line-added"> 389             table-&gt;remove(item);</span>
<span class="line-added"> 390             table-&gt;addDeletedOffset(structure-&gt;transitionOffset());</span>
 391             continue;
<span class="line-modified"> 392         }</span>
<span class="line-modified"> 393         PropertyMapEntry entry(structure-&gt;m_transitionPropertyName.get(), structure-&gt;transitionOffset(), structure-&gt;transitionPropertyAttributes());</span>
<span class="line-added"> 394         auto nextOffset = table-&gt;nextOffset(structure-&gt;inlineCapacity());</span>
<span class="line-added"> 395         ASSERT_UNUSED(nextOffset, nextOffset == structure-&gt;transitionOffset());</span>
<span class="line-added"> 396         auto result = table-&gt;add(entry);</span>
<span class="line-added"> 397         ASSERT_UNUSED(result, result.second);</span>
<span class="line-added"> 398         ASSERT_UNUSED(result, result.first.first-&gt;offset == nextOffset);</span>
 399     }
 400 
 401     checkOffsetConsistency(
 402         table,
 403         [&amp;] () {
 404             dataLog(&quot;Detected in materializePropertyTable.\n&quot;);
 405             dataLog(&quot;Found structure = &quot;, RawPointer(structure), &quot;\n&quot;);
 406             dataLog(&quot;structures = &quot;);
 407             CommaPrinter comma;
 408             for (Structure* structure : structures)
 409                 dataLog(comma, RawPointer(structure));
 410             dataLog(&quot;\n&quot;);
 411         });
 412 
 413     return table;
 414 }
 415 
 416 Structure* Structure::addPropertyTransitionToExistingStructureImpl(Structure* structure, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp; offset)
 417 {
 418     ASSERT(!structure-&gt;isDictionary());
 419     ASSERT(structure-&gt;isObject());
 420 
<span class="line-modified"> 421     constexpr bool isAddition = true;</span>
<span class="line-modified"> 422     if (Structure* existingTransition = structure-&gt;m_transitionTable.get(uid, attributes, isAddition)) {</span>
<span class="line-modified"> 423         validateOffset(existingTransition-&gt;transitionOffset(), existingTransition-&gt;inlineCapacity());</span>
<span class="line-added"> 424         offset = existingTransition-&gt;transitionOffset();</span>
 425         return existingTransition;
 426     }
 427 
 428     return 0;
 429 }
 430 
 431 Structure* Structure::addPropertyTransitionToExistingStructure(Structure* structure, PropertyName propertyName, unsigned attributes, PropertyOffset&amp; offset)
 432 {
 433     ASSERT(!isCompilationThread());
 434     return addPropertyTransitionToExistingStructureImpl(structure, propertyName.uid(), attributes, offset);
 435 }
 436 
 437 Structure* Structure::addPropertyTransitionToExistingStructureConcurrently(Structure* structure, UniquedStringImpl* uid, unsigned attributes, PropertyOffset&amp; offset)
 438 {
 439     ConcurrentJSLocker locker(structure-&gt;m_lock);
 440     return addPropertyTransitionToExistingStructureImpl(structure, uid, attributes, offset);
 441 }
 442 
 443 bool Structure::holesMustForwardToPrototype(VM&amp; vm, JSObject* base) const
 444 {
</pre>
<hr />
<pre>
 471     Structure* newStructure = addPropertyTransitionToExistingStructure(
 472         structure, propertyName, attributes, offset);
 473     if (newStructure)
 474         return newStructure;
 475 
 476     return addNewPropertyTransition(
 477         vm, structure, propertyName, attributes, offset, PutPropertySlot::UnknownContext);
 478 }
 479 
 480 Structure* Structure::addNewPropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, unsigned attributes, PropertyOffset&amp; offset, PutPropertySlot::Context context, DeferredStructureTransitionWatchpointFire* deferred)
 481 {
 482     ASSERT(!structure-&gt;isDictionary());
 483     ASSERT(structure-&gt;isObject());
 484     ASSERT(!Structure::addPropertyTransitionToExistingStructure(structure, propertyName, attributes, offset));
 485 
 486     int maxTransitionLength;
 487     if (context == PutPropertySlot::PutById)
 488         maxTransitionLength = s_maxTransitionLengthForNonEvalPutById;
 489     else
 490         maxTransitionLength = s_maxTransitionLength;
<span class="line-modified"> 491     if (structure-&gt;transitionCountEstimate() &gt; maxTransitionLength) {</span>
 492         ASSERT(!isCopyOnWrite(structure-&gt;indexingMode()));
 493         Structure* transition = toCacheableDictionaryTransition(vm, structure, deferred);
 494         ASSERT(structure != transition);
 495         offset = transition-&gt;add(vm, propertyName, attributes);
 496         return transition;
 497     }
 498 
 499     Structure* transition = create(vm, structure, deferred);
 500 
 501     transition-&gt;m_cachedPrototypeChain.setMayBeNull(vm, transition, structure-&gt;m_cachedPrototypeChain.get());
 502 
 503     // While we are adding the property, rematerializing the property table is super weird: we already
<span class="line-modified"> 504     // have a m_transitionPropertyName and transitionPropertyAttributes but the m_transitionOffset is still wrong. If the</span>
 505     // materialization algorithm runs, it&#39;ll build a property table that already has the property but
 506     // at a bogus offset. Rather than try to teach the materialization code how to create a table under
 507     // those conditions, we just tell the GC not to blow the table away during this period of time.
 508     // Holding the lock ensures that we either do this before the GC starts scanning the structure, in
 509     // which case the GC will not blow the table away, or we do it after the GC already ran in which
 510     // case all is well.  If it wasn&#39;t for the lock, the GC would have TOCTOU: if could read
<span class="line-modified"> 511     // protectPropertyTableWhileTransitioning before we set it to true, and then blow the table away after.</span>
 512     {
 513         ConcurrentJSLocker locker(transition-&gt;m_lock);
<span class="line-modified"> 514         transition-&gt;setProtectPropertyTableWhileTransitioning(true);</span>
 515     }
 516 
 517     transition-&gt;m_blob.setIndexingModeIncludingHistory(structure-&gt;indexingModeIncludingHistory() &amp; ~CopyOnWrite);
<span class="line-modified"> 518     transition-&gt;m_transitionPropertyName = propertyName.uid();</span>
<span class="line-modified"> 519     transition-&gt;setTransitionPropertyAttributes(attributes);</span>
 520     transition-&gt;setPropertyTable(vm, structure-&gt;takePropertyTableOrCloneIfPinned(vm));
<span class="line-modified"> 521     transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
 522 
 523     offset = transition-&gt;add(vm, propertyName, attributes);
<span class="line-added"> 524     transition-&gt;setTransitionOffset(vm, offset);</span>
 525 
 526     // Now that everything is fine with the new structure&#39;s bookkeeping, the GC is free to blow the
 527     // table away if it wants. We can now rebuild it fine.
 528     WTF::storeStoreFence();
<span class="line-modified"> 529     transition-&gt;setProtectPropertyTableWhileTransitioning(false);</span>
 530 
<span class="line-modified"> 531     checkOffset(transition-&gt;transitionOffset(), transition-&gt;inlineCapacity());</span>
 532     {
<span class="line-modified"> 533         GCSafeConcurrentJSLocker locker(structure-&gt;m_lock, vm.heap);</span>

 534         structure-&gt;m_transitionTable.add(vm, transition);
 535     }
 536     transition-&gt;checkOffsetConsistency();
 537     structure-&gt;checkOffsetConsistency();
 538     return transition;
 539 }
 540 
<span class="line-modified"> 541 Structure* Structure::removePropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertyOffset&amp; offset, DeferredStructureTransitionWatchpointFire* deferred)</span>
<span class="line-modified"> 542 {</span>
<span class="line-modified"> 543     Structure* newStructure = removePropertyTransitionFromExistingStructure(</span>
<span class="line-modified"> 544         vm, structure, propertyName, offset, deferred);</span>
<span class="line-modified"> 545     if (newStructure)</span>
<span class="line-modified"> 546         return newStructure;</span>
<span class="line-modified"> 547 </span>
<span class="line-modified"> 548     return removeNewPropertyTransition(</span>
<span class="line-modified"> 549         vm, structure, propertyName, offset, deferred);</span>
<span class="line-modified"> 550 }</span>
<span class="line-modified"> 551 </span>
<span class="line-modified"> 552 Structure* Structure::removePropertyTransitionFromExistingStructure(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertyOffset&amp; offset, DeferredStructureTransitionWatchpointFire*)</span>
<span class="line-modified"> 553 {</span>
<span class="line-modified"> 554     ASSERT(!isCompilationThread());</span>
 555     ASSERT(!structure-&gt;isUncacheableDictionary());
<span class="line-added"> 556     ASSERT(structure-&gt;isObject());</span>
<span class="line-added"> 557 </span>
<span class="line-added"> 558     unsigned attributes;</span>
<span class="line-added"> 559     structure-&gt;get(vm, propertyName, attributes);</span>
 560 
<span class="line-modified"> 561     constexpr bool isAddition = false;</span>
<span class="line-added"> 562     if (Structure* existingTransition = structure-&gt;m_transitionTable.get(propertyName.uid(), attributes, isAddition)) {</span>
<span class="line-added"> 563         validateOffset(existingTransition-&gt;transitionOffset(), existingTransition-&gt;inlineCapacity());</span>
<span class="line-added"> 564         offset = existingTransition-&gt;transitionOffset();</span>
<span class="line-added"> 565         return existingTransition;</span>
<span class="line-added"> 566     }</span>
 567 
<span class="line-modified"> 568     return nullptr;</span>
<span class="line-added"> 569 }</span>
 570 
<span class="line-added"> 571 Structure* Structure::removeNewPropertyTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, PropertyOffset&amp; offset, DeferredStructureTransitionWatchpointFire* deferred)</span>
<span class="line-added"> 572 {</span>
<span class="line-added"> 573     ASSERT(!structure-&gt;isUncacheableDictionary());</span>
<span class="line-added"> 574     ASSERT(structure-&gt;isObject());</span>
<span class="line-added"> 575     ASSERT(!Structure::removePropertyTransitionFromExistingStructure(vm, structure, propertyName, offset, deferred));</span>
<span class="line-added"> 576 </span>
<span class="line-added"> 577     int transitionCount = 0;</span>
<span class="line-added"> 578     for (auto* s = structure; s &amp;&amp; transitionCount &lt;= s_maxTransitionLength; s = s-&gt;previousID())</span>
<span class="line-added"> 579         ++transitionCount;</span>
<span class="line-added"> 580 </span>
<span class="line-added"> 581     if (transitionCount &gt; s_maxTransitionLength) {</span>
<span class="line-added"> 582         ASSERT(!isCopyOnWrite(structure-&gt;indexingMode()));</span>
<span class="line-added"> 583         Structure* transition = toUncacheableDictionaryTransition(vm, structure, deferred);</span>
<span class="line-added"> 584         ASSERT(structure != transition);</span>
<span class="line-added"> 585         offset = transition-&gt;remove(vm, propertyName);</span>
<span class="line-added"> 586         return transition;</span>
<span class="line-added"> 587     }</span>
<span class="line-added"> 588 </span>
<span class="line-added"> 589     Structure* transition = create(vm, structure, deferred);</span>
<span class="line-added"> 590     transition-&gt;m_cachedPrototypeChain.setMayBeNull(vm, transition, structure-&gt;m_cachedPrototypeChain.get());</span>
<span class="line-added"> 591 </span>
<span class="line-added"> 592     // While we are deleting the property, we need to make sure the table is not cleared.</span>
<span class="line-added"> 593     {</span>
<span class="line-added"> 594         ConcurrentJSLocker locker(transition-&gt;m_lock);</span>
<span class="line-added"> 595         transition-&gt;setProtectPropertyTableWhileTransitioning(true);</span>
<span class="line-added"> 596     }</span>
<span class="line-added"> 597 </span>
<span class="line-added"> 598     transition-&gt;m_blob.setIndexingModeIncludingHistory(structure-&gt;indexingModeIncludingHistory() &amp; ~CopyOnWrite);</span>
<span class="line-added"> 599     transition-&gt;m_transitionPropertyName = propertyName.uid();</span>
<span class="line-added"> 600     transition-&gt;setPropertyTable(vm, structure-&gt;takePropertyTableOrCloneIfPinned(vm));</span>
<span class="line-added"> 601     transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
<span class="line-added"> 602     transition-&gt;setIsPropertyDeletionTransition(true);</span>
<span class="line-added"> 603 </span>
<span class="line-added"> 604     offset = transition-&gt;remove(vm, propertyName);</span>
<span class="line-added"> 605     ASSERT(offset != invalidOffset);</span>
<span class="line-added"> 606     transition-&gt;setTransitionOffset(vm, offset);</span>
<span class="line-added"> 607 </span>
<span class="line-added"> 608     // Now that everything is fine with the new structure&#39;s bookkeeping, the GC is free to blow the</span>
<span class="line-added"> 609     // table away if it wants. We can now rebuild it fine.</span>
<span class="line-added"> 610     WTF::storeStoreFence();</span>
<span class="line-added"> 611     transition-&gt;setProtectPropertyTableWhileTransitioning(false);</span>
<span class="line-added"> 612 </span>
<span class="line-added"> 613     checkOffset(transition-&gt;transitionOffset(), transition-&gt;inlineCapacity());</span>
<span class="line-added"> 614     {</span>
<span class="line-added"> 615         GCSafeConcurrentJSLocker locker(structure-&gt;m_lock, vm.heap);</span>
<span class="line-added"> 616         structure-&gt;m_transitionTable.add(vm, transition);</span>
<span class="line-added"> 617     }</span>
 618     transition-&gt;checkOffsetConsistency();
<span class="line-added"> 619     structure-&gt;checkOffsetConsistency();</span>
 620     return transition;
 621 }
 622 
 623 Structure* Structure::changePrototypeTransition(VM&amp; vm, Structure* structure, JSValue prototype, DeferredStructureTransitionWatchpointFire&amp; deferred)
 624 {
 625     ASSERT(isValidPrototype(prototype));
 626 
 627     DeferGC deferGC(vm.heap);
 628     Structure* transition = create(vm, structure, &amp;deferred);
 629 
 630     transition-&gt;m_prototype.set(vm, transition, prototype);
 631 
 632     PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 633     transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
<span class="line-modified"> 634     transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
 635 
 636     transition-&gt;checkOffsetConsistency();
 637     return transition;
 638 }
 639 
 640 Structure* Structure::attributeChangeTransition(VM&amp; vm, Structure* structure, PropertyName propertyName, unsigned attributes)
 641 {
 642     if (!structure-&gt;isUncacheableDictionary()) {
 643         Structure* transition = create(vm, structure);
 644 
 645         PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 646         transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
<span class="line-modified"> 647         transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
 648 
 649         structure = transition;
 650     }
 651 
 652     PropertyMapEntry* entry = structure-&gt;ensurePropertyTable(vm)-&gt;get(propertyName.uid());
 653     ASSERT(entry);
 654     entry-&gt;attributes = attributes;
 655 
 656     structure-&gt;checkOffsetConsistency();
 657     return structure;
 658 }
 659 
 660 Structure* Structure::toDictionaryTransition(VM&amp; vm, Structure* structure, DictionaryKind kind, DeferredStructureTransitionWatchpointFire* deferred)
 661 {
 662     ASSERT(!structure-&gt;isUncacheableDictionary());
 663     DeferGC deferGC(vm.heap);
 664 
 665     Structure* transition = create(vm, structure, deferred);
 666 
 667     PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 668     transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
<span class="line-modified"> 669     transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
 670     transition-&gt;setDictionaryKind(kind);
 671     transition-&gt;setHasBeenDictionary(true);
 672 
 673     transition-&gt;checkOffsetConsistency();
 674     return transition;
 675 }
 676 
 677 Structure* Structure::toCacheableDictionaryTransition(VM&amp; vm, Structure* structure, DeferredStructureTransitionWatchpointFire* deferred)
 678 {
 679     return toDictionaryTransition(vm, structure, CachedDictionaryKind, deferred);
 680 }
 681 
<span class="line-modified"> 682 Structure* Structure::toUncacheableDictionaryTransition(VM&amp; vm, Structure* structure, DeferredStructureTransitionWatchpointFire* deferred)</span>
 683 {
<span class="line-modified"> 684     return toDictionaryTransition(vm, structure, UncachedDictionaryKind, deferred);</span>
 685 }
 686 
 687 Structure* Structure::sealTransition(VM&amp; vm, Structure* structure)
 688 {
 689     return nonPropertyTransition(vm, structure, NonPropertyTransition::Seal);
 690 }
 691 
 692 Structure* Structure::freezeTransition(VM&amp; vm, Structure* structure)
 693 {
 694     return nonPropertyTransition(vm, structure, NonPropertyTransition::Freeze);
 695 }
 696 
 697 Structure* Structure::preventExtensionsTransition(VM&amp; vm, Structure* structure)
 698 {
 699     return nonPropertyTransition(vm, structure, NonPropertyTransition::PreventExtensions);
 700 }
 701 
 702 PropertyTable* Structure::takePropertyTableOrCloneIfPinned(VM&amp; vm)
 703 {
 704     // This must always return a property table. It can&#39;t return null.
 705     PropertyTable* result = propertyTableOrNull();
 706     if (result) {
 707         if (isPinnedPropertyTable())
 708             return result-&gt;copy(vm, result-&gt;size() + 1);
 709         ConcurrentJSLocker locker(m_lock);
 710         setPropertyTable(vm, nullptr);
 711         return result;
 712     }
 713     bool setPropertyTable = false;
 714     return materializePropertyTable(vm, setPropertyTable);
 715 }
 716 
 717 Structure* Structure::nonPropertyTransitionSlow(VM&amp; vm, Structure* structure, NonPropertyTransition transitionKind)
 718 {
 719     unsigned attributes = toAttributes(transitionKind);
 720     IndexingType indexingModeIncludingHistory = newIndexingType(structure-&gt;indexingModeIncludingHistory(), transitionKind);
 721 
 722     Structure* existingTransition;
<span class="line-modified"> 723     constexpr bool isAddition = true;</span>
<span class="line-modified"> 724     if (!structure-&gt;isDictionary() &amp;&amp; (existingTransition = structure-&gt;m_transitionTable.get(0, attributes, isAddition))) {</span>
<span class="line-added"> 725         ASSERT(existingTransition-&gt;transitionPropertyAttributes() == attributes);</span>
 726         ASSERT(existingTransition-&gt;indexingModeIncludingHistory() == indexingModeIncludingHistory);
 727         return existingTransition;
 728     }
 729 
 730     DeferGC deferGC(vm.heap);
 731 
 732     Structure* transition = create(vm, structure);
<span class="line-modified"> 733     transition-&gt;setTransitionPropertyAttributes(attributes);</span>
 734     transition-&gt;m_blob.setIndexingModeIncludingHistory(indexingModeIncludingHistory);
 735 
 736     if (preventsExtensions(transitionKind))
 737         transition-&gt;setDidPreventExtensions(true);
 738 
 739     if (setsDontDeleteOnAllProperties(transitionKind)
 740         || setsReadOnlyOnNonAccessorProperties(transitionKind)) {
 741         // We pin the property table on transitions that do wholesale editing of the property
 742         // table, since our logic for walking the property transition chain to rematerialize the
 743         // table doesn&#39;t know how to take into account such wholesale edits.
 744 
 745         PropertyTable* table = structure-&gt;copyPropertyTableForPinning(vm);
 746         transition-&gt;pinForCaching(holdLock(transition-&gt;m_lock), vm, table);
<span class="line-modified"> 747         transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
 748 
 749         table = transition-&gt;propertyTableOrNull();
 750         RELEASE_ASSERT(table);
 751         for (auto&amp; entry : *table) {
 752             if (setsDontDeleteOnAllProperties(transitionKind))
 753                 entry.attributes |= static_cast&lt;unsigned&gt;(PropertyAttribute::DontDelete);
 754             if (setsReadOnlyOnNonAccessorProperties(transitionKind) &amp;&amp; !(entry.attributes &amp; PropertyAttribute::Accessor))
 755                 entry.attributes |= static_cast&lt;unsigned&gt;(PropertyAttribute::ReadOnly);
 756         }
 757     } else {
 758         transition-&gt;setPropertyTable(vm, structure-&gt;takePropertyTableOrCloneIfPinned(vm));
<span class="line-modified"> 759         transition-&gt;setMaxOffset(vm, structure-&gt;maxOffset());</span>
<span class="line-modified"> 760         checkOffset(transition-&gt;maxOffset(), transition-&gt;inlineCapacity());</span>
 761     }
 762 
 763     if (setsReadOnlyOnNonAccessorProperties(transitionKind)
 764         &amp;&amp; !transition-&gt;propertyTableOrNull()-&gt;isEmpty())
 765         transition-&gt;setHasReadOnlyOrGetterSetterPropertiesExcludingProto(true);
 766 
 767     if (structure-&gt;isDictionary()) {
 768         PropertyTable* table = transition-&gt;ensurePropertyTable(vm);
 769         transition-&gt;pin(holdLock(transition-&gt;m_lock), vm, table);
 770     } else {
 771         auto locker = holdLock(structure-&gt;m_lock);
 772         structure-&gt;m_transitionTable.add(vm, transition);
 773     }
 774 
 775     transition-&gt;checkOffsetConsistency();
 776     return transition;
 777 }
 778 
 779 // In future we may want to cache this property.
 780 bool Structure::isSealed(VM&amp; vm)
</pre>
<hr />
<pre>
 801         return false;
 802 
 803     PropertyTable* table = ensurePropertyTableIfNotEmpty(vm);
 804     if (!table)
 805         return true;
 806 
 807     PropertyTable::iterator end = table-&gt;end();
 808     for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter) {
 809         if (!(iter-&gt;attributes &amp; PropertyAttribute::DontDelete))
 810             return false;
 811         if (!(iter-&gt;attributes &amp; (PropertyAttribute::ReadOnly | PropertyAttribute::Accessor)))
 812             return false;
 813     }
 814     return true;
 815 }
 816 
 817 Structure* Structure::flattenDictionaryStructure(VM&amp; vm, JSObject* object)
 818 {
 819     checkOffsetConsistency();
 820     ASSERT(isDictionary());
<span class="line-added"> 821     ASSERT(object-&gt;structure(vm) == this);</span>
 822 
 823     GCSafeConcurrentJSLocker locker(m_lock, vm.heap);
 824 
 825     object-&gt;setStructureIDDirectly(nuke(id()));
 826     WTF::storeStoreFence();
 827 
 828     size_t beforeOutOfLineCapacity = this-&gt;outOfLineCapacity();
 829     if (isUncacheableDictionary()) {
 830         PropertyTable* table = propertyTableOrNull();
 831         ASSERT(table);
 832 
 833         size_t propertyCount = table-&gt;size();
 834 
 835         // Holds our values compacted by insertion order.
 836         Vector&lt;JSValue&gt; values(propertyCount);
 837 
 838         // Copies out our values from their hashed locations, compacting property table offsets as we go.
 839         unsigned i = 0;
 840         PropertyTable::iterator end = table-&gt;end();
<span class="line-modified"> 841         auto offset = invalidOffset;</span>
 842         for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter, ++i) {
 843             values[i] = object-&gt;getDirect(iter-&gt;offset);
<span class="line-modified"> 844             offset = iter-&gt;offset = offsetForPropertyNumber(i, m_inlineCapacity);</span>
 845         }
<span class="line-added"> 846         setMaxOffset(vm, offset);</span>
<span class="line-added"> 847         ASSERT(transitionOffset() == invalidOffset);</span>
 848 
 849         // Copies in our values to their compacted locations.
 850         for (unsigned i = 0; i &lt; propertyCount; i++)
 851             object-&gt;putDirect(vm, offsetForPropertyNumber(i, m_inlineCapacity), values[i]);
 852 
 853         table-&gt;clearDeletedOffsets();
 854 
 855         // We need to zero our unused property space; otherwise the GC might see a
 856         // stale pointer when we add properties in the future.
<span class="line-modified"> 857         gcSafeZeroMemory(</span>
 858             object-&gt;inlineStorageUnsafe() + inlineSize(),

 859             (inlineCapacity() - inlineSize()) * sizeof(EncodedJSValue));
 860 
 861         Butterfly* butterfly = object-&gt;butterfly();
 862         size_t preCapacity = butterfly-&gt;indexingHeader()-&gt;preCapacity(this);
 863         void* base = butterfly-&gt;base(preCapacity, beforeOutOfLineCapacity);
 864         void* startOfPropertyStorageSlots = reinterpret_cast&lt;EncodedJSValue*&gt;(base) + preCapacity;
<span class="line-modified"> 865         gcSafeZeroMemory(static_cast&lt;JSValue*&gt;(startOfPropertyStorageSlots), (beforeOutOfLineCapacity - outOfLineSize()) * sizeof(EncodedJSValue));</span>
 866         checkOffsetConsistency();
 867     }
 868 
 869     setDictionaryKind(NoneDictionaryKind);
 870     setHasBeenFlattenedBefore(true);
 871 
 872     size_t afterOutOfLineCapacity = this-&gt;outOfLineCapacity();
 873 
 874     if (object-&gt;butterfly() &amp;&amp; beforeOutOfLineCapacity != afterOutOfLineCapacity) {
 875         ASSERT(beforeOutOfLineCapacity &gt; afterOutOfLineCapacity);
 876         // If the object had a Butterfly but after flattening/compacting we no longer have need of it,
 877         // we need to zero it out because the collector depends on the Structure to know the size for copying.
 878         if (!afterOutOfLineCapacity &amp;&amp; !this-&gt;hasIndexingHeader(object))
 879             object-&gt;setButterfly(vm, nullptr);
 880         // If the object was down-sized to the point where the base of the Butterfly is no longer within the
 881         // first CopiedBlock::blockSize bytes, we&#39;ll get the wrong answer if we try to mask the base back to
 882         // the CopiedBlock header. To prevent this case we need to memmove the Butterfly down.
 883         else
 884             object-&gt;shiftButterflyAfterFlattening(locker, vm, this, afterOutOfLineCapacity);
 885     }
 886 
 887     WTF::storeStoreFence();
 888     object-&gt;setStructureIDDirectly(id());
 889 
 890     // We need to do a writebarrier here because the GC thread might be scanning the butterfly while
 891     // we are shuffling properties around. See: https://bugs.webkit.org/show_bug.cgi?id=166989
 892     vm.heap.writeBarrier(object);
 893 
 894     return this;
 895 }
 896 
 897 void Structure::pin(const AbstractLocker&amp;, VM&amp; vm, PropertyTable* table)
 898 {
 899     setIsPinnedPropertyTable(true);
 900     setPropertyTable(vm, table);
 901     clearPreviousID();
<span class="line-modified"> 902     m_transitionPropertyName = nullptr;</span>
 903 }
 904 
 905 void Structure::pinForCaching(const AbstractLocker&amp;, VM&amp; vm, PropertyTable* table)
 906 {
 907     setIsPinnedPropertyTable(true);
 908     setPropertyTable(vm, table);
<span class="line-modified"> 909     m_transitionPropertyName = nullptr;</span>
 910 }
 911 
 912 void Structure::allocateRareData(VM&amp; vm)
 913 {
 914     ASSERT(!hasRareData());
 915     StructureRareData* rareData = StructureRareData::create(vm, previousID());
 916     WTF::storeStoreFence();
 917     m_previousOrRareData.set(vm, this, rareData);
 918     ASSERT(hasRareData());
 919 }
 920 
 921 WatchpointSet* Structure::ensurePropertyReplacementWatchpointSet(VM&amp; vm, PropertyOffset offset)
 922 {
 923     ASSERT(!isUncacheableDictionary());
 924 
 925     // In some places it&#39;s convenient to call this with an invalid offset. So, we do the check here.
 926     if (!isValidOffset(offset))
 927         return nullptr;
 928 
 929     if (!hasRareData())
</pre>
<hr />
<pre>
1021     return result;
1022 }
1023 
1024 Vector&lt;PropertyMapEntry&gt; Structure::getPropertiesConcurrently()
1025 {
1026     Vector&lt;PropertyMapEntry&gt; result;
1027 
1028     forEachPropertyConcurrently(
1029         [&amp;] (const PropertyMapEntry&amp; entry) -&gt; bool {
1030             result.append(entry);
1031             return true;
1032         });
1033 
1034     return result;
1035 }
1036 
1037 PropertyOffset Structure::add(VM&amp; vm, PropertyName propertyName, unsigned attributes)
1038 {
1039     return add&lt;ShouldPin::No&gt;(
1040         vm, propertyName, attributes,
<span class="line-modified">1041         [this, &amp;vm] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset, PropertyOffset newMaxOffset) {</span>
<span class="line-modified">1042             setMaxOffset(vm, newMaxOffset);</span>
1043         });
1044 }
1045 
<span class="line-modified">1046 PropertyOffset Structure::remove(VM&amp; vm, PropertyName propertyName)</span>
1047 {
<span class="line-modified">1048     return remove&lt;ShouldPin::No&gt;(vm, propertyName, [this, &amp;vm] (const GCSafeConcurrentJSLocker&amp;, PropertyOffset, PropertyOffset newMaxOffset) {</span>
<span class="line-added">1049         setMaxOffset(vm, newMaxOffset);</span>
<span class="line-added">1050     });</span>
1051 }
1052 
1053 void Structure::getPropertyNamesFromStructure(VM&amp; vm, PropertyNameArray&amp; propertyNames, EnumerationMode mode)
1054 {
1055     PropertyTable* table = ensurePropertyTableIfNotEmpty(vm);
1056     if (!table)
1057         return;
1058 
1059     bool knownUnique = propertyNames.canAddKnownUniqueForStructure();
1060 
1061     PropertyTable::iterator end = table-&gt;end();
1062     for (PropertyTable::iterator iter = table-&gt;begin(); iter != end; ++iter) {
1063         ASSERT(!isQuickPropertyAccessAllowedForEnumeration() || !(iter-&gt;attributes &amp; PropertyAttribute::DontEnum));
1064         ASSERT(!isQuickPropertyAccessAllowedForEnumeration() || !iter-&gt;key-&gt;isSymbol());
1065         if (!(iter-&gt;attributes &amp; PropertyAttribute::DontEnum) || mode.includeDontEnumProperties()) {
1066             if (iter-&gt;key-&gt;isSymbol() &amp;&amp; !propertyNames.includeSymbolProperties())
1067                 continue;
1068             if (knownUnique)
1069                 propertyNames.addUnchecked(iter-&gt;key);
1070             else
</pre>
<hr />
<pre>
1110 }
1111 
1112 void Structure::visitChildren(JSCell* cell, SlotVisitor&amp; visitor)
1113 {
1114     Structure* thisObject = jsCast&lt;Structure*&gt;(cell);
1115     ASSERT_GC_OBJECT_INHERITS(thisObject, info());
1116 
1117     Base::visitChildren(thisObject, visitor);
1118 
1119     ConcurrentJSLocker locker(thisObject-&gt;m_lock);
1120 
1121     visitor.append(thisObject-&gt;m_globalObject);
1122     if (!thisObject-&gt;isObject())
1123         thisObject-&gt;m_cachedPrototypeChain.clear();
1124     else {
1125         visitor.append(thisObject-&gt;m_prototype);
1126         visitor.append(thisObject-&gt;m_cachedPrototypeChain);
1127     }
1128     visitor.append(thisObject-&gt;m_previousOrRareData);
1129 
<span class="line-modified">1130     if (thisObject-&gt;isPinnedPropertyTable() || thisObject-&gt;protectPropertyTableWhileTransitioning()) {</span>
1131         // NOTE: This can interleave in pin(), in which case it may see a null property table.
1132         // That&#39;s fine, because then the barrier will fire and we will scan this again.
1133         visitor.append(thisObject-&gt;m_propertyTableUnsafe);
1134     } else if (visitor.isAnalyzingHeap())
1135         visitor.append(thisObject-&gt;m_propertyTableUnsafe);
1136     else if (thisObject-&gt;m_propertyTableUnsafe)
1137         thisObject-&gt;m_propertyTableUnsafe.clear();
1138 }
1139 
1140 bool Structure::isCheapDuringGC(VM&amp; vm)
1141 {
1142     // FIXME: We could make this even safer by returning false if this structure&#39;s property table
1143     // has any large property names.
1144     // https://bugs.webkit.org/show_bug.cgi?id=157334
1145 
1146     return (!m_globalObject || vm.heap.isMarked(m_globalObject.get()))
1147         &amp;&amp; (hasPolyProto() || !storedPrototypeObject() || vm.heap.isMarked(storedPrototypeObject()));
1148 }
1149 
1150 bool Structure::markIfCheap(SlotVisitor&amp; visitor)
</pre>
<hr />
<pre>
1268         }
1269     }
1270     return false;
1271 }
1272 
1273 void Structure::setCachedPropertyNameEnumerator(VM&amp; vm, JSPropertyNameEnumerator* enumerator)
1274 {
1275     ASSERT(!isDictionary());
1276     if (!hasRareData())
1277         allocateRareData(vm);
1278     rareData()-&gt;setCachedPropertyNameEnumerator(vm, enumerator);
1279 }
1280 
1281 JSPropertyNameEnumerator* Structure::cachedPropertyNameEnumerator() const
1282 {
1283     if (!hasRareData())
1284         return nullptr;
1285     return rareData()-&gt;cachedPropertyNameEnumerator();
1286 }
1287 
<span class="line-modified">1288 bool Structure::canCachePropertyNameEnumerator(VM&amp; vm) const</span>
1289 {
1290     if (!this-&gt;canCacheOwnKeys())
1291         return false;
1292 
1293     StructureChain* structureChain = m_cachedPrototypeChain.get();
1294     ASSERT(structureChain);
<span class="line-modified">1295     StructureID* currentStructureID = structureChain-&gt;head();</span>
1296     while (true) {
<span class="line-modified">1297         StructureID structureID = *currentStructureID;</span>
<span class="line-added">1298         if (!structureID)</span>
1299             return true;
<span class="line-modified">1300         Structure* structure = vm.getStructure(structureID);</span>
<span class="line-added">1301         if (!structure-&gt;canCacheOwnKeys())</span>
1302             return false;
<span class="line-modified">1303         currentStructureID++;</span>
1304     }
1305 
1306     ASSERT_NOT_REACHED();
1307     return true;
1308 }
1309 
1310 bool Structure::canAccessPropertiesQuicklyForEnumeration() const
1311 {
1312     if (!isQuickPropertyAccessAllowedForEnumeration())
1313         return false;
1314     if (hasGetterSetterProperties())
1315         return false;
1316     if (isUncacheableDictionary())
1317         return false;
1318     return true;
1319 }
1320 
<span class="line-added">1321 auto Structure::findPropertyHashEntry(PropertyName propertyName) const -&gt; Optional&lt;PropertyHashEntry&gt;</span>
<span class="line-added">1322 {</span>
<span class="line-added">1323     for (const ClassInfo* info = classInfo(); info; info = info-&gt;parentClass) {</span>
<span class="line-added">1324         if (const HashTable* propHashTable = info-&gt;staticPropHashTable) {</span>
<span class="line-added">1325             if (const HashTableValue* entry = propHashTable-&gt;entry(propertyName))</span>
<span class="line-added">1326                 return PropertyHashEntry { propHashTable, entry };</span>
<span class="line-added">1327         }</span>
<span class="line-added">1328     }</span>
<span class="line-added">1329     return WTF::nullopt;</span>
<span class="line-added">1330 }</span>
<span class="line-added">1331 </span>
1332 } // namespace JSC
</pre>
</td>
</tr>
</table>
<center><a href="StringRecursionChecker.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Structure.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
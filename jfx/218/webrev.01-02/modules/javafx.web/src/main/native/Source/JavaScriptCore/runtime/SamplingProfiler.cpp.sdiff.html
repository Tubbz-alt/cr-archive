<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SamplingProfiler.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RegExpStringIteratorPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SamplingProfiler.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/runtime/SamplingProfiler.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  48 #include &quot;SlotVisitor.h&quot;
  49 #include &quot;StrongInlines.h&quot;
  50 #include &quot;VM.h&quot;
  51 #include &quot;WasmCallee.h&quot;
  52 #include &quot;WasmCalleeRegistry.h&quot;
  53 #include &lt;thread&gt;
  54 #include &lt;wtf/FilePrintStream.h&gt;
  55 #include &lt;wtf/HashSet.h&gt;
  56 #include &lt;wtf/RefPtr.h&gt;
  57 #include &lt;wtf/StackTrace.h&gt;
  58 #include &lt;wtf/text/StringBuilder.h&gt;
  59 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  60 
  61 namespace JSC {
  62 
  63 static double sNumTotalStackTraces = 0;
  64 static double sNumTotalWalks = 0;
  65 static double sNumFailedWalks = 0;
  66 static const uint32_t sNumWalkReportingFrequency = 50;
  67 static const double sWalkErrorPercentage = .05;
<span class="line-modified">  68 static const bool sReportStatsOnlyWhenTheyreAboveThreshold = false;</span>
<span class="line-modified">  69 static const bool sReportStats = false;</span>
  70 
  71 using FrameType = SamplingProfiler::FrameType;
  72 using UnprocessedStackFrame = SamplingProfiler::UnprocessedStackFrame;
  73 
  74 ALWAYS_INLINE static void reportStats()
  75 {
  76     if (sReportStats &amp;&amp; sNumTotalWalks &amp;&amp; static_cast&lt;uint64_t&gt;(sNumTotalWalks) % sNumWalkReportingFrequency == 0) {
  77         if (!sReportStatsOnlyWhenTheyreAboveThreshold || (sNumFailedWalks / sNumTotalWalks &gt; sWalkErrorPercentage)) {
  78             dataLogF(&quot;Num total walks: %llu. Failed walks percent: %lf\n&quot;,
  79                 static_cast&lt;unsigned long long&gt;(sNumTotalWalks), sNumFailedWalks / sNumTotalWalks);
  80         }
  81     }
  82 }
  83 
  84 class FrameWalker {
  85 public:
<span class="line-modified">  86     FrameWalker(VM&amp; vm, ExecState* callFrame, const AbstractLocker&amp; codeBlockSetLocker, const AbstractLocker&amp; machineThreadsLocker, const AbstractLocker&amp; wasmCalleeLocker)</span>
  87         : m_vm(vm)
  88         , m_callFrame(callFrame)
  89         , m_entryFrame(vm.topEntryFrame)
  90         , m_codeBlockSetLocker(codeBlockSetLocker)
  91         , m_machineThreadsLocker(machineThreadsLocker)
  92         , m_wasmCalleeLocker(wasmCalleeLocker)
  93     {
  94     }
  95 
  96     SUPPRESS_ASAN
  97     size_t walk(Vector&lt;UnprocessedStackFrame&gt;&amp; stackTrace, bool&amp; didRunOutOfSpace)
  98     {
  99         if (sReportStats)
 100             sNumTotalWalks++;
 101         resetAtMachineFrame();
 102         size_t maxStackTraceSize = stackTrace.size();
 103         while (!isAtTop() &amp;&amp; !m_bailingOut &amp;&amp; m_depth &lt; maxStackTraceSize) {
 104             recordJITFrame(stackTrace);
 105             advanceToParentFrame();
 106             resetAtMachineFrame();
 107         }
 108         didRunOutOfSpace = m_depth &gt;= maxStackTraceSize &amp;&amp; !isAtTop();
 109         reportStats();
 110         return m_depth;
 111     }
 112 
 113     bool wasValidWalk() const
 114     {
 115         return !m_bailingOut;
 116     }
 117 
 118 protected:
 119 
 120     SUPPRESS_ASAN
 121     void recordJITFrame(Vector&lt;UnprocessedStackFrame&gt;&amp; stackTrace)
 122     {
 123         CallSiteIndex callSiteIndex;
 124         CalleeBits unsafeCallee = m_callFrame-&gt;unsafeCallee();
 125         CodeBlock* codeBlock = m_callFrame-&gt;unsafeCodeBlock();


 126         if (codeBlock) {
 127             ASSERT(isValidCodeBlock(codeBlock));
 128             callSiteIndex = m_callFrame-&gt;unsafeCallSiteIndex();
 129         }
 130         stackTrace[m_depth] = UnprocessedStackFrame(codeBlock, unsafeCallee, callSiteIndex);
 131 #if ENABLE(WEBASSEMBLY)
 132         if (unsafeCallee.isWasm()) {
 133             auto* wasmCallee = unsafeCallee.asWasmCallee();
 134             if (Wasm::CalleeRegistry::singleton().isValidCallee(m_wasmCalleeLocker, wasmCallee)) {
 135                 // At this point, Wasm::Callee would be dying (ref count is 0), but its fields are still live.
 136                 // And we can safely copy Wasm::IndexOrName even when any lock is held by suspended threads.
 137                 stackTrace[m_depth].wasmIndexOrName = wasmCallee-&gt;indexOrName();
 138                 stackTrace[m_depth].wasmCompilationMode = wasmCallee-&gt;compilationMode();
 139             }
 140         }
 141 #endif
 142         m_depth++;
 143     }
 144 
 145     SUPPRESS_ASAN
</pre>
<hr />
<pre>
 151     bool isAtTop() const
 152     {
 153         return !m_callFrame;
 154     }
 155 
 156     SUPPRESS_ASAN
 157     void resetAtMachineFrame()
 158     {
 159         if (isAtTop())
 160             return;
 161 
 162         if (!isValidFramePointer(m_callFrame)) {
 163             // Guard against pausing the process at weird program points.
 164             m_bailingOut = true;
 165             if (sReportStats)
 166                 sNumFailedWalks++;
 167             return;
 168         }
 169 
 170         CodeBlock* codeBlock = m_callFrame-&gt;unsafeCodeBlock();
<span class="line-modified"> 171         if (!codeBlock)</span>
 172             return;
 173 
 174         if (!isValidCodeBlock(codeBlock)) {
 175             m_bailingOut = true;
 176             if (sReportStats)
 177                 sNumFailedWalks++;
 178             return;
 179         }
 180     }
 181 
<span class="line-modified"> 182     bool isValidFramePointer(void* exec)</span>
 183     {
<span class="line-modified"> 184         uint8_t* fpCast = bitwise_cast&lt;uint8_t*&gt;(exec);</span>
 185         for (auto&amp; thread : m_vm.heap.machineThreads().threads(m_machineThreadsLocker)) {
 186             uint8_t* stackBase = static_cast&lt;uint8_t*&gt;(thread-&gt;stack().origin());
 187             uint8_t* stackLimit = static_cast&lt;uint8_t*&gt;(thread-&gt;stack().end());
 188             RELEASE_ASSERT(stackBase);
 189             RELEASE_ASSERT(stackLimit);
 190             RELEASE_ASSERT(stackLimit &lt;= stackBase);
 191             if (fpCast &lt; stackBase &amp;&amp; fpCast &gt;= stackLimit)
 192                 return true;
 193         }
 194         return false;
 195     }
 196 
 197     bool isValidCodeBlock(CodeBlock* codeBlock)
 198     {
 199         if (!codeBlock)
 200             return false;
 201         bool result = m_vm.heap.codeBlockSet().contains(m_codeBlockSetLocker, codeBlock);
 202         return result;
 203     }
 204 
 205     VM&amp; m_vm;
<span class="line-modified"> 206     ExecState* m_callFrame;</span>
 207     EntryFrame* m_entryFrame;
 208     const AbstractLocker&amp; m_codeBlockSetLocker;
 209     const AbstractLocker&amp; m_machineThreadsLocker;
 210     const AbstractLocker&amp; m_wasmCalleeLocker;
 211     bool m_bailingOut { false };
 212     size_t m_depth { 0 };
 213 };
 214 
 215 class CFrameWalker : public FrameWalker {
 216 public:
 217     typedef FrameWalker Base;
 218 
<span class="line-modified"> 219     CFrameWalker(VM&amp; vm, void* machineFrame, ExecState* callFrame, const AbstractLocker&amp; codeBlockSetLocker, const AbstractLocker&amp; machineThreadsLocker, const AbstractLocker&amp; wasmCalleeLocker)</span>
 220         : Base(vm, callFrame, codeBlockSetLocker, machineThreadsLocker, wasmCalleeLocker)
 221         , m_machineFrame(machineFrame)
 222     {
 223     }
 224 
 225     size_t walk(Vector&lt;UnprocessedStackFrame&gt;&amp; stackTrace, bool&amp; didRunOutOfSpace)
 226     {
 227         if (sReportStats)
 228             sNumTotalWalks++;
 229         resetAtMachineFrame();
 230         size_t maxStackTraceSize = stackTrace.size();
 231         // The way the C walker decides if a frame it is about to trace is C or JS is by
 232         // ensuring m_callFrame points to some frame above the machineFrame.
 233         if (!isAtTop() &amp;&amp; !m_bailingOut &amp;&amp; m_machineFrame == m_callFrame) {
 234             recordJITFrame(stackTrace);
 235             Base::advanceToParentFrame();
 236             resetAtMachineFrame();
 237         }
 238 
 239         while (!isAtTop() &amp;&amp; !m_bailingOut &amp;&amp; m_depth &lt; maxStackTraceSize) {
</pre>
<hr />
<pre>
 288         return reinterpret_cast&lt;CallerFrameAndPC*&gt;(m_machineFrame);
 289     }
 290 
 291     void* m_machineFrame;
 292 };
 293 
 294 SamplingProfiler::SamplingProfiler(VM&amp; vm, RefPtr&lt;Stopwatch&gt;&amp;&amp; stopwatch)
 295     : m_isPaused(false)
 296     , m_isShutDown(false)
 297     , m_vm(vm)
 298     , m_weakRandom()
 299     , m_stopwatch(WTFMove(stopwatch))
 300     , m_timingInterval(Seconds::fromMicroseconds(Options::sampleInterval()))
 301 {
 302     if (sReportStats) {
 303         sNumTotalWalks = 0;
 304         sNumFailedWalks = 0;
 305     }
 306 
 307     m_currentFrames.grow(256);

 308 }
 309 
 310 SamplingProfiler::~SamplingProfiler()
 311 {
 312 }
 313 
 314 void SamplingProfiler::createThreadIfNecessary(const AbstractLocker&amp;)
 315 {
 316     ASSERT(m_lock.isLocked());
 317 
 318     if (m_thread)
 319         return;
 320 
 321     RefPtr&lt;SamplingProfiler&gt; profiler = this;
 322     m_thread = Thread::create(&quot;jsc.sampling-profiler.thread&quot;, [profiler] {
 323         profiler-&gt;timerLoop();
 324     });
 325 }
 326 
 327 void SamplingProfiler::timerLoop()
</pre>
<hr />
<pre>
 352 void SamplingProfiler::takeSample(const AbstractLocker&amp;, Seconds&amp; stackTraceProcessingTime)
 353 {
 354     ASSERT(m_lock.isLocked());
 355     if (m_vm.entryScope) {
 356         Seconds nowTime = m_stopwatch-&gt;elapsedTime();
 357 
 358         auto machineThreadsLocker = holdLock(m_vm.heap.machineThreads().getLock());
 359         auto codeBlockSetLocker = holdLock(m_vm.heap.codeBlockSet().getLock());
 360         auto executableAllocatorLocker = holdLock(ExecutableAllocator::singleton().getLock());
 361 #if ENABLE(WEBASSEMBLY)
 362         auto wasmCalleesLocker = holdLock(Wasm::CalleeRegistry::singleton().getLock());
 363 #else
 364         LockHolder wasmCalleesLocker(NoLockingNecessary);
 365 #endif
 366 
 367         auto didSuspend = m_jscExecutionThread-&gt;suspend();
 368         if (didSuspend) {
 369             // While the JSC thread is suspended, we can&#39;t do things like malloc because the JSC thread
 370             // may be holding the malloc lock.
 371             void* machineFrame;
<span class="line-modified"> 372             ExecState* callFrame;</span>
 373             void* machinePC;
 374             bool topFrameIsLLInt = false;
 375             void* llintPC;
 376             {
 377                 PlatformRegisters registers;
 378                 m_jscExecutionThread-&gt;getRegisters(registers);
 379                 machineFrame = MachineContext::framePointer(registers);
<span class="line-modified"> 380                 callFrame = static_cast&lt;ExecState*&gt;(machineFrame);</span>
 381                 auto instructionPointer = MachineContext::instructionPointer(registers);
 382                 if (instructionPointer)
 383                     machinePC = instructionPointer-&gt;untaggedExecutableAddress();
 384                 else
 385                     machinePC = nullptr;
 386                 llintPC = removeCodePtrTag(MachineContext::llintInstructionPointer(registers));
 387                 assertIsNotTagged(machinePC);
 388             }
 389             // FIXME: Lets have a way of detecting when we&#39;re parsing code.
 390             // https://bugs.webkit.org/show_bug.cgi?id=152761
 391             if (ExecutableAllocator::singleton().isValidExecutableMemory(executableAllocatorLocker, machinePC)) {
 392                 if (m_vm.isExecutingInRegExpJIT) {
 393                     // FIXME: We&#39;re executing a regexp. Lets gather more intersting data.
 394                     // https://bugs.webkit.org/show_bug.cgi?id=152729
 395                     callFrame = m_vm.topCallFrame; // We need to do this or else we&#39;d fail our backtrace validation b/c this isn&#39;t a JS frame.
 396                 }
 397             } else if (LLInt::isLLIntPC(machinePC)) {
 398                 topFrameIsLLInt = true;
 399                 // We&#39;re okay to take a normal stack trace when the PC
 400                 // is in LLInt code.
</pre>
<hr />
<pre>
 429                     sNumTotalStackTraces++;
 430                 Vector&lt;UnprocessedStackFrame&gt; stackTrace;
 431                 stackTrace.reserveInitialCapacity(walkSize);
 432                 for (size_t i = 0; i &lt; walkSize; i++) {
 433                     UnprocessedStackFrame frame = m_currentFrames[i];
 434                     stackTrace.uncheckedAppend(frame);
 435                 }
 436 
 437                 m_unprocessedStackTraces.append(UnprocessedStackTrace { nowTime, machinePC, topFrameIsLLInt, llintPC, WTFMove(stackTrace) });
 438 
 439                 if (didRunOutOfVectorSpace)
 440                     m_currentFrames.grow(m_currentFrames.size() * 1.25);
 441             }
 442 
 443             auto endTime = MonotonicTime::now();
 444             stackTraceProcessingTime = endTime - startTime;
 445         }
 446     }
 447 }
 448 
<span class="line-modified"> 449 static ALWAYS_INLINE unsigned tryGetBytecodeIndex(unsigned llintPC, CodeBlock* codeBlock, bool&amp; isValid)</span>
 450 {
 451 #if ENABLE(DFG_JIT)
 452     RELEASE_ASSERT(!codeBlock-&gt;hasCodeOrigins());
 453 #endif
 454 
<span class="line-modified"> 455 #if USE(JSVALUE64)</span>
<span class="line-modified"> 456     unsigned bytecodeIndex = llintPC;</span>
<span class="line-modified"> 457     if (bytecodeIndex &lt; codeBlock-&gt;instructionsSize()) {</span>
<span class="line-modified"> 458         isValid = true;</span>
<span class="line-removed"> 459         return bytecodeIndex;</span>
<span class="line-removed"> 460     }</span>
<span class="line-removed"> 461     isValid = false;</span>
<span class="line-removed"> 462     return 0;</span>
<span class="line-removed"> 463 #else</span>
<span class="line-removed"> 464     Instruction* instruction = bitwise_cast&lt;Instruction*&gt;(llintPC);</span>
<span class="line-removed"> 465 </span>
<span class="line-removed"> 466     if (codeBlock-&gt;instructions().contains(instruction)) {</span>
<span class="line-removed"> 467         isValid = true;</span>
<span class="line-removed"> 468         return codeBlock-&gt;bytecodeOffset(instruction);</span>
<span class="line-removed"> 469     }</span>
<span class="line-removed"> 470     isValid = false;</span>
<span class="line-removed"> 471     return 0;</span>
<span class="line-removed"> 472 #endif</span>
 473 }
 474 
<span class="line-modified"> 475 void SamplingProfiler::processUnverifiedStackTraces()</span>
 476 {
 477     // This function needs to be called from the JSC execution thread.
 478     RELEASE_ASSERT(m_lock.isLocked());
 479 
 480     TinyBloomFilter filter = m_vm.heap.objectSpace().blocks().filter();
 481 
 482     for (UnprocessedStackTrace&amp; unprocessedStackTrace : m_unprocessedStackTraces) {
 483         m_stackTraces.append(StackTrace());
 484         StackTrace&amp; stackTrace = m_stackTraces.last();
 485         stackTrace.timestamp = unprocessedStackTrace.timestamp;
 486 
<span class="line-modified"> 487         auto populateCodeLocation = [] (CodeBlock* codeBlock, unsigned bytecodeIndex, StackFrame::CodeLocation&amp; location) {</span>
<span class="line-modified"> 488             if (bytecodeIndex &lt; codeBlock-&gt;instructionsSize()) {</span>
 489                 int divot;
 490                 int startOffset;
 491                 int endOffset;
<span class="line-modified"> 492                 codeBlock-&gt;expressionRangeForBytecodeOffset(bytecodeIndex, divot, startOffset, endOffset,</span>
 493                     location.lineNumber, location.columnNumber);
 494                 location.bytecodeIndex = bytecodeIndex;
 495             }
 496             if (Options::collectSamplingProfilerDataForJSCShell()) {
 497                 location.codeBlockHash = codeBlock-&gt;hash();
 498                 location.jitType = codeBlock-&gt;jitType();
 499             }
 500         };
 501 
<span class="line-modified"> 502         auto appendCodeBlock = [&amp;] (CodeBlock* codeBlock, unsigned bytecodeIndex) {</span>
 503             stackTrace.frames.append(StackFrame(codeBlock-&gt;ownerExecutable()));
 504             m_liveCellPointers.add(codeBlock-&gt;ownerExecutable());
 505             populateCodeLocation(codeBlock, bytecodeIndex, stackTrace.frames.last().semanticLocation);
 506         };
 507 
 508         auto appendEmptyFrame = [&amp;] {
 509             stackTrace.frames.append(StackFrame());
 510         };
 511 
 512         auto storeCalleeIntoLastFrame = [&amp;] (UnprocessedStackFrame&amp; unprocessedStackFrame) {
 513             // Set the callee if it&#39;s a valid GC object.
 514             CalleeBits calleeBits = unprocessedStackFrame.unverifiedCallee;
 515             StackFrame&amp; stackFrame = stackTrace.frames.last();
 516             bool alreadyHasExecutable = !!stackFrame.executable;
 517 #if ENABLE(WEBASSEMBLY)
 518             if (calleeBits.isWasm()) {
 519                 stackFrame.frameType = FrameType::Wasm;
 520                 stackFrame.wasmIndexOrName = unprocessedStackFrame.wasmIndexOrName;
 521                 stackFrame.wasmCompilationMode = unprocessedStackFrame.wasmCompilationMode;
 522                 return;
</pre>
<hr />
<pre>
 597                 // inspector in the future if we find a need for it there.
 598                 RELEASE_ASSERT(stackTrace.frames.size());
 599                 m_liveCellPointers.add(machineCodeBlock);
 600                 for (size_t i = startIndex; i &lt; stackTrace.frames.size() - 1; i++)
 601                     stackTrace.frames[i].machineLocation = std::make_pair(machineLocation, machineCodeBlock);
 602             }
 603         };
 604 
 605         // Prepend the top-most inlined frame if needed and gather
 606         // location information about where the top frame is executing.
 607         size_t startIndex = 0;
 608         if (unprocessedStackTrace.frames.size() &amp;&amp; !!unprocessedStackTrace.frames[0].verifiedCodeBlock) {
 609             CodeBlock* topCodeBlock = unprocessedStackTrace.frames[0].verifiedCodeBlock;
 610             if (unprocessedStackTrace.topFrameIsLLInt) {
 611                 // We reuse LLInt CodeBlocks for the baseline JIT, so we need to check for both jit types.
 612                 // This might also be false for various reasons (known and unknown), even though
 613                 // it&#39;s super unlikely. One reason that this can be false is when we throw from a DFG frame,
 614                 // and we end up having to unwind past an EntryFrame, we will end up executing
 615                 // inside the LLInt&#39;s handleUncaughtException. So we just protect against this
 616                 // by ignoring it.
<span class="line-modified"> 617                 unsigned bytecodeIndex = 0;</span>
 618                 if (topCodeBlock-&gt;jitType() == JITType::InterpreterThunk || topCodeBlock-&gt;jitType() == JITType::BaselineJIT) {
<span class="line-modified"> 619                     bool isValidPC;</span>
<span class="line-modified"> 620                     unsigned bits;</span>
<span class="line-removed"> 621 #if USE(JSVALUE64)</span>
<span class="line-removed"> 622                     bits = static_cast&lt;unsigned&gt;(bitwise_cast&lt;uintptr_t&gt;(unprocessedStackTrace.llintPC));</span>
<span class="line-removed"> 623 #else</span>
<span class="line-removed"> 624                     bits = bitwise_cast&lt;unsigned&gt;(unprocessedStackTrace.llintPC);</span>
<span class="line-removed"> 625 #endif</span>
<span class="line-removed"> 626                     bytecodeIndex = tryGetBytecodeIndex(bits, topCodeBlock, isValidPC);</span>
 627 
<span class="line-modified"> 628                     UNUSED_PARAM(isValidPC); // FIXME: do something with this info for the web inspector: https://bugs.webkit.org/show_bug.cgi?id=153455</span>
 629 
 630                     appendCodeBlock(topCodeBlock, bytecodeIndex);
 631                     storeCalleeIntoLastFrame(unprocessedStackTrace.frames[0]);
 632                     startIndex = 1;
 633                 }
 634             } else {
 635 #if ENABLE(JIT)
 636                 if (Optional&lt;CodeOrigin&gt; codeOrigin = topCodeBlock-&gt;findPC(unprocessedStackTrace.topPC)) {
 637                     appendCodeOrigin(topCodeBlock, *codeOrigin);
 638                     storeCalleeIntoLastFrame(unprocessedStackTrace.frames[0]);
 639                     startIndex = 1;
 640                 }
 641 #endif
 642                 UNUSED_PARAM(appendCodeOrigin);
 643             }
 644         }
 645 
 646         for (size_t i = startIndex; i &lt; unprocessedStackTrace.frames.size(); i++) {
 647             UnprocessedStackFrame&amp; unprocessedStackFrame = unprocessedStackTrace.frames[i];
 648             if (CodeBlock* codeBlock = unprocessedStackFrame.verifiedCodeBlock) {
 649                 CallSiteIndex callSiteIndex = unprocessedStackFrame.callSiteIndex;
 650 
 651                 auto appendCodeBlockNoInlining = [&amp;] {
<span class="line-modified"> 652                     bool isValidPC;</span>
<span class="line-removed"> 653                     appendCodeBlock(codeBlock, tryGetBytecodeIndex(callSiteIndex.bits(), codeBlock, isValidPC));</span>
 654                 };
 655 
 656 #if ENABLE(DFG_JIT)
 657                 if (codeBlock-&gt;hasCodeOrigins()) {
 658                     if (codeBlock-&gt;canGetCodeOrigin(callSiteIndex))
 659                         appendCodeOrigin(codeBlock, codeBlock-&gt;codeOrigin(callSiteIndex));
 660                     else
<span class="line-modified"> 661                         appendCodeBlock(codeBlock, std::numeric_limits&lt;unsigned&gt;::max());</span>
 662                 } else
 663                     appendCodeBlockNoInlining();
 664 #else
 665                 appendCodeBlockNoInlining();
 666 #endif
 667             } else if (unprocessedStackFrame.cCodePC) {
 668                 appendEmptyFrame();
 669                 stackTrace.frames.last().cCodePC = unprocessedStackFrame.cCodePC;
 670                 stackTrace.frames.last().frameType = FrameType::C;
 671             } else
 672                 appendEmptyFrame();
 673 
 674             // Note that this is okay to do if we walked the inline stack because
 675             // the machine frame will be at the top of the processed stack trace.
 676             if (!unprocessedStackFrame.cCodePC)
 677                 storeCalleeIntoLastFrame(unprocessedStackFrame);
 678         }
 679     }
 680 
 681     m_unprocessedStackTraces.clear();
</pre>
<hr />
<pre>
 738     ASSERT(m_vm.entryScope);
 739     noticeCurrentThreadAsJSCExecutionThread(locker);
 740     m_lastTime = m_stopwatch-&gt;elapsedTime();
 741     createThreadIfNecessary(locker);
 742 }
 743 
 744 void SamplingProfiler::clearData(const AbstractLocker&amp;)
 745 {
 746     ASSERT(m_lock.isLocked());
 747     m_stackTraces.clear();
 748     m_liveCellPointers.clear();
 749     m_unprocessedStackTraces.clear();
 750 }
 751 
 752 String SamplingProfiler::StackFrame::nameFromCallee(VM&amp; vm)
 753 {
 754     if (!callee)
 755         return String();
 756 
 757     auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified"> 758     ExecState* exec = callee-&gt;globalObject(vm)-&gt;globalExec();</span>
 759     auto getPropertyIfPureOperation = [&amp;] (const Identifier&amp; ident) -&gt; String {
 760         PropertySlot slot(callee, PropertySlot::InternalMethodType::VMInquiry);
 761         PropertyName propertyName(ident);
<span class="line-modified"> 762         bool hasProperty = callee-&gt;getPropertySlot(exec, propertyName, slot);</span>
 763         scope.assertNoException();
 764         if (hasProperty) {
 765             if (slot.isValue()) {
<span class="line-modified"> 766                 JSValue nameValue = slot.getValue(exec, propertyName);</span>
 767                 if (isJSString(nameValue))
 768                     return asString(nameValue)-&gt;tryGetValue();
 769             }
 770         }
 771         return String();
 772     };
 773 
 774     String name = getPropertyIfPureOperation(vm.propertyNames-&gt;displayName);
 775     if (!name.isEmpty())
 776         return name;
 777 
 778     return getPropertyIfPureOperation(vm.propertyNames-&gt;name);
 779 }
 780 
 781 String SamplingProfiler::StackFrame::displayName(VM&amp; vm)
 782 {
 783     {
 784         String name = nameFromCallee(vm);
 785         if (!name.isEmpty())
 786             return name;
</pre>
<hr />
<pre>
 940     case FrameType::Wasm:
 941         return emptyString();
 942     case FrameType::Executable:
 943         if (executable-&gt;isHostFunction())
 944             return emptyString();
 945 
 946         String url = static_cast&lt;ScriptExecutable*&gt;(executable)-&gt;sourceURL();
 947         if (url.isEmpty())
 948             return static_cast&lt;ScriptExecutable*&gt;(executable)-&gt;source().provider()-&gt;sourceURLDirective(); // Fall back to sourceURL directive.
 949         return url;
 950     }
 951     RELEASE_ASSERT_NOT_REACHED();
 952     return String();
 953 }
 954 
 955 Vector&lt;SamplingProfiler::StackTrace&gt; SamplingProfiler::releaseStackTraces(const AbstractLocker&amp; locker)
 956 {
 957     ASSERT(m_lock.isLocked());
 958     {
 959         HeapIterationScope heapIterationScope(m_vm.heap);
<span class="line-modified"> 960         processUnverifiedStackTraces();</span>
 961     }
 962 
 963     Vector&lt;StackTrace&gt; result(WTFMove(m_stackTraces));
 964     clearData(locker);
 965     return result;
 966 }
 967 
 968 String SamplingProfiler::stackTracesAsJSON()
 969 {
 970     DeferGC deferGC(m_vm.heap);
<span class="line-modified"> 971     LockHolder locker(m_lock);</span>
 972 
 973     {
 974         HeapIterationScope heapIterationScope(m_vm.heap);
<span class="line-modified"> 975         processUnverifiedStackTraces();</span>
 976     }
 977 
 978     StringBuilder json;
 979     json.append(&#39;[&#39;);
 980 
 981     bool loopedOnce = false;
 982     auto comma = [&amp;] {
 983         if (loopedOnce)
 984             json.append(&#39;,&#39;);
 985     };
 986     for (StackTrace&amp; stackTrace : m_stackTraces) {
 987         comma();
 988         json.append(&#39;[&#39;);
 989         loopedOnce = false;
 990         for (StackFrame&amp; stackFrame : stackTrace.frames) {
 991             comma();
 992             json.appendQuotedJSONString(stackFrame.displayNameForJSONTests(m_vm));
 993             loopedOnce = true;
 994         }
 995         json.append(&#39;]&#39;);
 996         loopedOnce = true;
 997     }
 998 
 999     json.append(&#39;]&#39;);
1000 
1001     clearData(locker);
1002 
1003     return json.toString();
1004 }
1005 
1006 void SamplingProfiler::registerForReportAtExit()
1007 {
1008     static Lock registrationLock;
1009     static HashSet&lt;RefPtr&lt;SamplingProfiler&gt;&gt;* profilesToReport;
1010 
1011     LockHolder holder(registrationLock);
1012 
1013     if (!profilesToReport) {
1014         profilesToReport = new HashSet&lt;RefPtr&lt;SamplingProfiler&gt;&gt;();
1015         atexit([]() {
<span class="line-modified">1016             for (auto profile : *profilesToReport)</span>
1017                 profile-&gt;reportDataToOptionFile();
1018         });
1019     }
1020 
1021     profilesToReport-&gt;add(adoptRef(this));
1022     m_needsReportAtExit = true;
1023 }
1024 
1025 void SamplingProfiler::reportDataToOptionFile()
1026 {
1027     if (m_needsReportAtExit) {
1028         m_needsReportAtExit = false;

1029         const char* path = Options::samplingProfilerPath();
1030         StringPrintStream pathOut;
1031         pathOut.print(path, &quot;/&quot;);
1032         pathOut.print(&quot;JSCSampilingProfile-&quot;, reinterpret_cast&lt;uintptr_t&gt;(this), &quot;.txt&quot;);
1033         auto out = FilePrintStream::open(pathOut.toCString().data(), &quot;w&quot;);
1034         reportTopFunctions(*out);
1035         reportTopBytecodes(*out);
1036     }
1037 }
1038 
1039 void SamplingProfiler::reportTopFunctions()
1040 {
1041     reportTopFunctions(WTF::dataFile());
1042 }
1043 
1044 void SamplingProfiler::reportTopFunctions(PrintStream&amp; out)
1045 {
<span class="line-modified">1046     LockHolder locker(m_lock);</span>
1047     DeferGCForAWhile deferGC(m_vm.heap);
1048 
1049     {
1050         HeapIterationScope heapIterationScope(m_vm.heap);
<span class="line-modified">1051         processUnverifiedStackTraces();</span>
1052     }
1053 
1054 
1055     HashMap&lt;String, size_t&gt; functionCounts;
1056     for (StackTrace&amp; stackTrace : m_stackTraces) {
1057         if (!stackTrace.frames.size())
1058             continue;
1059 
1060         StackFrame&amp; frame = stackTrace.frames.first();
1061         String frameDescription = makeString(frame.displayName(m_vm), &#39;:&#39;, frame.sourceID());
1062         functionCounts.add(frameDescription, 0).iterator-&gt;value++;
1063     }
1064 
1065     auto takeMax = [&amp;] () -&gt; std::pair&lt;String, size_t&gt; {
1066         String maxFrameDescription;
1067         size_t maxFrameCount = 0;
<span class="line-modified">1068         for (auto entry : functionCounts) {</span>
1069             if (entry.value &gt; maxFrameCount) {
1070                 maxFrameCount = entry.value;
1071                 maxFrameDescription = entry.key;
1072             }
1073         }
1074         if (!maxFrameDescription.isEmpty())
1075             functionCounts.remove(maxFrameDescription);
1076         return std::make_pair(maxFrameDescription, maxFrameCount);
1077     };
1078 
1079     if (Options::samplingProfilerTopFunctionsCount()) {
1080         out.print(&quot;\n\nSampling rate: &quot;, m_timingInterval.microseconds(), &quot; microseconds\n&quot;);
1081         out.print(&quot;Top functions as &lt;numSamples  &#39;functionName:sourceID&#39;&gt;\n&quot;);
1082         for (size_t i = 0; i &lt; Options::samplingProfilerTopFunctionsCount(); i++) {
1083             auto pair = takeMax();
1084             if (pair.first.isEmpty())
1085                 break;
1086             out.printf(&quot;%6zu &quot;, pair.second);
1087             out.print(&quot;   &#39;&quot;, pair.first, &quot;&#39;\n&quot;);
1088         }
1089     }
1090 }
1091 
1092 void SamplingProfiler::reportTopBytecodes()
1093 {
1094     reportTopBytecodes(WTF::dataFile());
1095 }
1096 
1097 void SamplingProfiler::reportTopBytecodes(PrintStream&amp; out)
1098 {
<span class="line-modified">1099     LockHolder locker(m_lock);</span>
1100     DeferGCForAWhile deferGC(m_vm.heap);
1101 
1102     {
1103         HeapIterationScope heapIterationScope(m_vm.heap);
<span class="line-modified">1104         processUnverifiedStackTraces();</span>
1105     }
1106 
1107     HashMap&lt;String, size_t&gt; bytecodeCounts;
1108     for (StackTrace&amp; stackTrace : m_stackTraces) {
1109         if (!stackTrace.frames.size())
1110             continue;
1111 
1112         auto descriptionForLocation = [&amp;] (StackFrame::CodeLocation location, Optional&lt;Wasm::CompilationMode&gt; wasmCompilationMode) -&gt; String {
1113             String bytecodeIndex;
1114             String codeBlockHash;
1115             String jitType;
1116             if (location.hasBytecodeIndex())
<span class="line-modified">1117                 bytecodeIndex = String::number(location.bytecodeIndex);</span>
1118             else
1119                 bytecodeIndex = &quot;&lt;nil&gt;&quot;;
1120 
1121             if (location.hasCodeBlockHash()) {
1122                 StringPrintStream stream;
1123                 location.codeBlockHash.dump(stream);
1124                 codeBlockHash = stream.toString();
1125             } else
1126                 codeBlockHash = &quot;&lt;nil&gt;&quot;;
1127 
1128             if (wasmCompilationMode)
1129                 jitType = Wasm::makeString(wasmCompilationMode.value());
1130             else
1131                 jitType = JITCode::typeName(location.jitType);
1132 
1133             return makeString(&quot;#&quot;, codeBlockHash, &quot;:&quot;, jitType, &quot;:&quot;, bytecodeIndex);
1134         };
1135 
1136         StackFrame&amp; frame = stackTrace.frames.first();
1137         String frameDescription = makeString(frame.displayName(m_vm), descriptionForLocation(frame.semanticLocation, frame.wasmCompilationMode));
1138         if (Optional&lt;std::pair&lt;StackFrame::CodeLocation, CodeBlock*&gt;&gt; machineLocation = frame.machineLocation) {
1139             frameDescription = makeString(frameDescription, &quot; &lt;-- &quot;,
1140                 machineLocation-&gt;second-&gt;inferredName().data(), descriptionForLocation(machineLocation-&gt;first, WTF::nullopt));
1141         }
1142         bytecodeCounts.add(frameDescription, 0).iterator-&gt;value++;
1143     }
1144 
1145     auto takeMax = [&amp;] () -&gt; std::pair&lt;String, size_t&gt; {
1146         String maxFrameDescription;
1147         size_t maxFrameCount = 0;
<span class="line-modified">1148         for (auto entry : bytecodeCounts) {</span>
1149             if (entry.value &gt; maxFrameCount) {
1150                 maxFrameCount = entry.value;
1151                 maxFrameDescription = entry.key;
1152             }
1153         }
1154         if (!maxFrameDescription.isEmpty())
1155             bytecodeCounts.remove(maxFrameDescription);
1156         return std::make_pair(maxFrameDescription, maxFrameCount);
1157     };
1158 
1159     if (Options::samplingProfilerTopBytecodesCount()) {
1160         out.print(&quot;\n\nSampling rate: &quot;, m_timingInterval.microseconds(), &quot; microseconds\n&quot;);
1161         out.print(&quot;Hottest bytecodes as &lt;numSamples   &#39;functionName#hash:JITType:bytecodeIndex&#39;&gt;\n&quot;);
1162         for (size_t i = 0; i &lt; Options::samplingProfilerTopBytecodesCount(); i++) {
1163             auto pair = takeMax();
1164             if (pair.first.isEmpty())
1165                 break;
1166             out.printf(&quot;%6zu &quot;, pair.second);
1167             out.print(&quot;   &#39;&quot;, pair.first, &quot;&#39;\n&quot;);
1168         }
</pre>
</td>
<td>
<hr />
<pre>
  48 #include &quot;SlotVisitor.h&quot;
  49 #include &quot;StrongInlines.h&quot;
  50 #include &quot;VM.h&quot;
  51 #include &quot;WasmCallee.h&quot;
  52 #include &quot;WasmCalleeRegistry.h&quot;
  53 #include &lt;thread&gt;
  54 #include &lt;wtf/FilePrintStream.h&gt;
  55 #include &lt;wtf/HashSet.h&gt;
  56 #include &lt;wtf/RefPtr.h&gt;
  57 #include &lt;wtf/StackTrace.h&gt;
  58 #include &lt;wtf/text/StringBuilder.h&gt;
  59 #include &lt;wtf/text/StringConcatenateNumbers.h&gt;
  60 
  61 namespace JSC {
  62 
  63 static double sNumTotalStackTraces = 0;
  64 static double sNumTotalWalks = 0;
  65 static double sNumFailedWalks = 0;
  66 static const uint32_t sNumWalkReportingFrequency = 50;
  67 static const double sWalkErrorPercentage = .05;
<span class="line-modified">  68 static constexpr bool sReportStatsOnlyWhenTheyreAboveThreshold = false;</span>
<span class="line-modified">  69 static constexpr bool sReportStats = false;</span>
  70 
  71 using FrameType = SamplingProfiler::FrameType;
  72 using UnprocessedStackFrame = SamplingProfiler::UnprocessedStackFrame;
  73 
  74 ALWAYS_INLINE static void reportStats()
  75 {
  76     if (sReportStats &amp;&amp; sNumTotalWalks &amp;&amp; static_cast&lt;uint64_t&gt;(sNumTotalWalks) % sNumWalkReportingFrequency == 0) {
  77         if (!sReportStatsOnlyWhenTheyreAboveThreshold || (sNumFailedWalks / sNumTotalWalks &gt; sWalkErrorPercentage)) {
  78             dataLogF(&quot;Num total walks: %llu. Failed walks percent: %lf\n&quot;,
  79                 static_cast&lt;unsigned long long&gt;(sNumTotalWalks), sNumFailedWalks / sNumTotalWalks);
  80         }
  81     }
  82 }
  83 
  84 class FrameWalker {
  85 public:
<span class="line-modified">  86     FrameWalker(VM&amp; vm, CallFrame* callFrame, const AbstractLocker&amp; codeBlockSetLocker, const AbstractLocker&amp; machineThreadsLocker, const AbstractLocker&amp; wasmCalleeLocker)</span>
  87         : m_vm(vm)
  88         , m_callFrame(callFrame)
  89         , m_entryFrame(vm.topEntryFrame)
  90         , m_codeBlockSetLocker(codeBlockSetLocker)
  91         , m_machineThreadsLocker(machineThreadsLocker)
  92         , m_wasmCalleeLocker(wasmCalleeLocker)
  93     {
  94     }
  95 
  96     SUPPRESS_ASAN
  97     size_t walk(Vector&lt;UnprocessedStackFrame&gt;&amp; stackTrace, bool&amp; didRunOutOfSpace)
  98     {
  99         if (sReportStats)
 100             sNumTotalWalks++;
 101         resetAtMachineFrame();
 102         size_t maxStackTraceSize = stackTrace.size();
 103         while (!isAtTop() &amp;&amp; !m_bailingOut &amp;&amp; m_depth &lt; maxStackTraceSize) {
 104             recordJITFrame(stackTrace);
 105             advanceToParentFrame();
 106             resetAtMachineFrame();
 107         }
 108         didRunOutOfSpace = m_depth &gt;= maxStackTraceSize &amp;&amp; !isAtTop();
 109         reportStats();
 110         return m_depth;
 111     }
 112 
 113     bool wasValidWalk() const
 114     {
 115         return !m_bailingOut;
 116     }
 117 
 118 protected:
 119 
 120     SUPPRESS_ASAN
 121     void recordJITFrame(Vector&lt;UnprocessedStackFrame&gt;&amp; stackTrace)
 122     {
 123         CallSiteIndex callSiteIndex;
 124         CalleeBits unsafeCallee = m_callFrame-&gt;unsafeCallee();
 125         CodeBlock* codeBlock = m_callFrame-&gt;unsafeCodeBlock();
<span class="line-added"> 126         if (unsafeCallee.isWasm())</span>
<span class="line-added"> 127             codeBlock = nullptr;</span>
 128         if (codeBlock) {
 129             ASSERT(isValidCodeBlock(codeBlock));
 130             callSiteIndex = m_callFrame-&gt;unsafeCallSiteIndex();
 131         }
 132         stackTrace[m_depth] = UnprocessedStackFrame(codeBlock, unsafeCallee, callSiteIndex);
 133 #if ENABLE(WEBASSEMBLY)
 134         if (unsafeCallee.isWasm()) {
 135             auto* wasmCallee = unsafeCallee.asWasmCallee();
 136             if (Wasm::CalleeRegistry::singleton().isValidCallee(m_wasmCalleeLocker, wasmCallee)) {
 137                 // At this point, Wasm::Callee would be dying (ref count is 0), but its fields are still live.
 138                 // And we can safely copy Wasm::IndexOrName even when any lock is held by suspended threads.
 139                 stackTrace[m_depth].wasmIndexOrName = wasmCallee-&gt;indexOrName();
 140                 stackTrace[m_depth].wasmCompilationMode = wasmCallee-&gt;compilationMode();
 141             }
 142         }
 143 #endif
 144         m_depth++;
 145     }
 146 
 147     SUPPRESS_ASAN
</pre>
<hr />
<pre>
 153     bool isAtTop() const
 154     {
 155         return !m_callFrame;
 156     }
 157 
 158     SUPPRESS_ASAN
 159     void resetAtMachineFrame()
 160     {
 161         if (isAtTop())
 162             return;
 163 
 164         if (!isValidFramePointer(m_callFrame)) {
 165             // Guard against pausing the process at weird program points.
 166             m_bailingOut = true;
 167             if (sReportStats)
 168                 sNumFailedWalks++;
 169             return;
 170         }
 171 
 172         CodeBlock* codeBlock = m_callFrame-&gt;unsafeCodeBlock();
<span class="line-modified"> 173         if (!codeBlock || m_callFrame-&gt;unsafeCallee().isWasm())</span>
 174             return;
 175 
 176         if (!isValidCodeBlock(codeBlock)) {
 177             m_bailingOut = true;
 178             if (sReportStats)
 179                 sNumFailedWalks++;
 180             return;
 181         }
 182     }
 183 
<span class="line-modified"> 184     bool isValidFramePointer(void* callFrame)</span>
 185     {
<span class="line-modified"> 186         uint8_t* fpCast = bitwise_cast&lt;uint8_t*&gt;(callFrame);</span>
 187         for (auto&amp; thread : m_vm.heap.machineThreads().threads(m_machineThreadsLocker)) {
 188             uint8_t* stackBase = static_cast&lt;uint8_t*&gt;(thread-&gt;stack().origin());
 189             uint8_t* stackLimit = static_cast&lt;uint8_t*&gt;(thread-&gt;stack().end());
 190             RELEASE_ASSERT(stackBase);
 191             RELEASE_ASSERT(stackLimit);
 192             RELEASE_ASSERT(stackLimit &lt;= stackBase);
 193             if (fpCast &lt; stackBase &amp;&amp; fpCast &gt;= stackLimit)
 194                 return true;
 195         }
 196         return false;
 197     }
 198 
 199     bool isValidCodeBlock(CodeBlock* codeBlock)
 200     {
 201         if (!codeBlock)
 202             return false;
 203         bool result = m_vm.heap.codeBlockSet().contains(m_codeBlockSetLocker, codeBlock);
 204         return result;
 205     }
 206 
 207     VM&amp; m_vm;
<span class="line-modified"> 208     CallFrame* m_callFrame;</span>
 209     EntryFrame* m_entryFrame;
 210     const AbstractLocker&amp; m_codeBlockSetLocker;
 211     const AbstractLocker&amp; m_machineThreadsLocker;
 212     const AbstractLocker&amp; m_wasmCalleeLocker;
 213     bool m_bailingOut { false };
 214     size_t m_depth { 0 };
 215 };
 216 
 217 class CFrameWalker : public FrameWalker {
 218 public:
 219     typedef FrameWalker Base;
 220 
<span class="line-modified"> 221     CFrameWalker(VM&amp; vm, void* machineFrame, CallFrame* callFrame, const AbstractLocker&amp; codeBlockSetLocker, const AbstractLocker&amp; machineThreadsLocker, const AbstractLocker&amp; wasmCalleeLocker)</span>
 222         : Base(vm, callFrame, codeBlockSetLocker, machineThreadsLocker, wasmCalleeLocker)
 223         , m_machineFrame(machineFrame)
 224     {
 225     }
 226 
 227     size_t walk(Vector&lt;UnprocessedStackFrame&gt;&amp; stackTrace, bool&amp; didRunOutOfSpace)
 228     {
 229         if (sReportStats)
 230             sNumTotalWalks++;
 231         resetAtMachineFrame();
 232         size_t maxStackTraceSize = stackTrace.size();
 233         // The way the C walker decides if a frame it is about to trace is C or JS is by
 234         // ensuring m_callFrame points to some frame above the machineFrame.
 235         if (!isAtTop() &amp;&amp; !m_bailingOut &amp;&amp; m_machineFrame == m_callFrame) {
 236             recordJITFrame(stackTrace);
 237             Base::advanceToParentFrame();
 238             resetAtMachineFrame();
 239         }
 240 
 241         while (!isAtTop() &amp;&amp; !m_bailingOut &amp;&amp; m_depth &lt; maxStackTraceSize) {
</pre>
<hr />
<pre>
 290         return reinterpret_cast&lt;CallerFrameAndPC*&gt;(m_machineFrame);
 291     }
 292 
 293     void* m_machineFrame;
 294 };
 295 
 296 SamplingProfiler::SamplingProfiler(VM&amp; vm, RefPtr&lt;Stopwatch&gt;&amp;&amp; stopwatch)
 297     : m_isPaused(false)
 298     , m_isShutDown(false)
 299     , m_vm(vm)
 300     , m_weakRandom()
 301     , m_stopwatch(WTFMove(stopwatch))
 302     , m_timingInterval(Seconds::fromMicroseconds(Options::sampleInterval()))
 303 {
 304     if (sReportStats) {
 305         sNumTotalWalks = 0;
 306         sNumFailedWalks = 0;
 307     }
 308 
 309     m_currentFrames.grow(256);
<span class="line-added"> 310     vm.heap.objectSpace().enablePreciseAllocationTracking();</span>
 311 }
 312 
 313 SamplingProfiler::~SamplingProfiler()
 314 {
 315 }
 316 
 317 void SamplingProfiler::createThreadIfNecessary(const AbstractLocker&amp;)
 318 {
 319     ASSERT(m_lock.isLocked());
 320 
 321     if (m_thread)
 322         return;
 323 
 324     RefPtr&lt;SamplingProfiler&gt; profiler = this;
 325     m_thread = Thread::create(&quot;jsc.sampling-profiler.thread&quot;, [profiler] {
 326         profiler-&gt;timerLoop();
 327     });
 328 }
 329 
 330 void SamplingProfiler::timerLoop()
</pre>
<hr />
<pre>
 355 void SamplingProfiler::takeSample(const AbstractLocker&amp;, Seconds&amp; stackTraceProcessingTime)
 356 {
 357     ASSERT(m_lock.isLocked());
 358     if (m_vm.entryScope) {
 359         Seconds nowTime = m_stopwatch-&gt;elapsedTime();
 360 
 361         auto machineThreadsLocker = holdLock(m_vm.heap.machineThreads().getLock());
 362         auto codeBlockSetLocker = holdLock(m_vm.heap.codeBlockSet().getLock());
 363         auto executableAllocatorLocker = holdLock(ExecutableAllocator::singleton().getLock());
 364 #if ENABLE(WEBASSEMBLY)
 365         auto wasmCalleesLocker = holdLock(Wasm::CalleeRegistry::singleton().getLock());
 366 #else
 367         LockHolder wasmCalleesLocker(NoLockingNecessary);
 368 #endif
 369 
 370         auto didSuspend = m_jscExecutionThread-&gt;suspend();
 371         if (didSuspend) {
 372             // While the JSC thread is suspended, we can&#39;t do things like malloc because the JSC thread
 373             // may be holding the malloc lock.
 374             void* machineFrame;
<span class="line-modified"> 375             CallFrame* callFrame;</span>
 376             void* machinePC;
 377             bool topFrameIsLLInt = false;
 378             void* llintPC;
 379             {
 380                 PlatformRegisters registers;
 381                 m_jscExecutionThread-&gt;getRegisters(registers);
 382                 machineFrame = MachineContext::framePointer(registers);
<span class="line-modified"> 383                 callFrame = static_cast&lt;CallFrame*&gt;(machineFrame);</span>
 384                 auto instructionPointer = MachineContext::instructionPointer(registers);
 385                 if (instructionPointer)
 386                     machinePC = instructionPointer-&gt;untaggedExecutableAddress();
 387                 else
 388                     machinePC = nullptr;
 389                 llintPC = removeCodePtrTag(MachineContext::llintInstructionPointer(registers));
 390                 assertIsNotTagged(machinePC);
 391             }
 392             // FIXME: Lets have a way of detecting when we&#39;re parsing code.
 393             // https://bugs.webkit.org/show_bug.cgi?id=152761
 394             if (ExecutableAllocator::singleton().isValidExecutableMemory(executableAllocatorLocker, machinePC)) {
 395                 if (m_vm.isExecutingInRegExpJIT) {
 396                     // FIXME: We&#39;re executing a regexp. Lets gather more intersting data.
 397                     // https://bugs.webkit.org/show_bug.cgi?id=152729
 398                     callFrame = m_vm.topCallFrame; // We need to do this or else we&#39;d fail our backtrace validation b/c this isn&#39;t a JS frame.
 399                 }
 400             } else if (LLInt::isLLIntPC(machinePC)) {
 401                 topFrameIsLLInt = true;
 402                 // We&#39;re okay to take a normal stack trace when the PC
 403                 // is in LLInt code.
</pre>
<hr />
<pre>
 432                     sNumTotalStackTraces++;
 433                 Vector&lt;UnprocessedStackFrame&gt; stackTrace;
 434                 stackTrace.reserveInitialCapacity(walkSize);
 435                 for (size_t i = 0; i &lt; walkSize; i++) {
 436                     UnprocessedStackFrame frame = m_currentFrames[i];
 437                     stackTrace.uncheckedAppend(frame);
 438                 }
 439 
 440                 m_unprocessedStackTraces.append(UnprocessedStackTrace { nowTime, machinePC, topFrameIsLLInt, llintPC, WTFMove(stackTrace) });
 441 
 442                 if (didRunOutOfVectorSpace)
 443                     m_currentFrames.grow(m_currentFrames.size() * 1.25);
 444             }
 445 
 446             auto endTime = MonotonicTime::now();
 447             stackTraceProcessingTime = endTime - startTime;
 448         }
 449     }
 450 }
 451 
<span class="line-modified"> 452 static ALWAYS_INLINE BytecodeIndex tryGetBytecodeIndex(unsigned llintPC, CodeBlock* codeBlock)</span>
 453 {
 454 #if ENABLE(DFG_JIT)
 455     RELEASE_ASSERT(!codeBlock-&gt;hasCodeOrigins());
 456 #endif
 457 
<span class="line-modified"> 458     unsigned bytecodeOffset = llintPC;</span>
<span class="line-modified"> 459     if (bytecodeOffset &lt; codeBlock-&gt;instructionsSize())</span>
<span class="line-modified"> 460         return BytecodeIndex(bytecodeOffset);</span>
<span class="line-modified"> 461     return BytecodeIndex();</span>














 462 }
 463 
<span class="line-modified"> 464 void SamplingProfiler::processUnverifiedStackTraces(const AbstractLocker&amp;)</span>
 465 {
 466     // This function needs to be called from the JSC execution thread.
 467     RELEASE_ASSERT(m_lock.isLocked());
 468 
 469     TinyBloomFilter filter = m_vm.heap.objectSpace().blocks().filter();
 470 
 471     for (UnprocessedStackTrace&amp; unprocessedStackTrace : m_unprocessedStackTraces) {
 472         m_stackTraces.append(StackTrace());
 473         StackTrace&amp; stackTrace = m_stackTraces.last();
 474         stackTrace.timestamp = unprocessedStackTrace.timestamp;
 475 
<span class="line-modified"> 476         auto populateCodeLocation = [] (CodeBlock* codeBlock, BytecodeIndex bytecodeIndex, StackFrame::CodeLocation&amp; location) {</span>
<span class="line-modified"> 477             if (bytecodeIndex.offset() &lt; codeBlock-&gt;instructionsSize()) {</span>
 478                 int divot;
 479                 int startOffset;
 480                 int endOffset;
<span class="line-modified"> 481                 codeBlock-&gt;expressionRangeForBytecodeIndex(bytecodeIndex, divot, startOffset, endOffset,</span>
 482                     location.lineNumber, location.columnNumber);
 483                 location.bytecodeIndex = bytecodeIndex;
 484             }
 485             if (Options::collectSamplingProfilerDataForJSCShell()) {
 486                 location.codeBlockHash = codeBlock-&gt;hash();
 487                 location.jitType = codeBlock-&gt;jitType();
 488             }
 489         };
 490 
<span class="line-modified"> 491         auto appendCodeBlock = [&amp;] (CodeBlock* codeBlock, BytecodeIndex bytecodeIndex) {</span>
 492             stackTrace.frames.append(StackFrame(codeBlock-&gt;ownerExecutable()));
 493             m_liveCellPointers.add(codeBlock-&gt;ownerExecutable());
 494             populateCodeLocation(codeBlock, bytecodeIndex, stackTrace.frames.last().semanticLocation);
 495         };
 496 
 497         auto appendEmptyFrame = [&amp;] {
 498             stackTrace.frames.append(StackFrame());
 499         };
 500 
 501         auto storeCalleeIntoLastFrame = [&amp;] (UnprocessedStackFrame&amp; unprocessedStackFrame) {
 502             // Set the callee if it&#39;s a valid GC object.
 503             CalleeBits calleeBits = unprocessedStackFrame.unverifiedCallee;
 504             StackFrame&amp; stackFrame = stackTrace.frames.last();
 505             bool alreadyHasExecutable = !!stackFrame.executable;
 506 #if ENABLE(WEBASSEMBLY)
 507             if (calleeBits.isWasm()) {
 508                 stackFrame.frameType = FrameType::Wasm;
 509                 stackFrame.wasmIndexOrName = unprocessedStackFrame.wasmIndexOrName;
 510                 stackFrame.wasmCompilationMode = unprocessedStackFrame.wasmCompilationMode;
 511                 return;
</pre>
<hr />
<pre>
 586                 // inspector in the future if we find a need for it there.
 587                 RELEASE_ASSERT(stackTrace.frames.size());
 588                 m_liveCellPointers.add(machineCodeBlock);
 589                 for (size_t i = startIndex; i &lt; stackTrace.frames.size() - 1; i++)
 590                     stackTrace.frames[i].machineLocation = std::make_pair(machineLocation, machineCodeBlock);
 591             }
 592         };
 593 
 594         // Prepend the top-most inlined frame if needed and gather
 595         // location information about where the top frame is executing.
 596         size_t startIndex = 0;
 597         if (unprocessedStackTrace.frames.size() &amp;&amp; !!unprocessedStackTrace.frames[0].verifiedCodeBlock) {
 598             CodeBlock* topCodeBlock = unprocessedStackTrace.frames[0].verifiedCodeBlock;
 599             if (unprocessedStackTrace.topFrameIsLLInt) {
 600                 // We reuse LLInt CodeBlocks for the baseline JIT, so we need to check for both jit types.
 601                 // This might also be false for various reasons (known and unknown), even though
 602                 // it&#39;s super unlikely. One reason that this can be false is when we throw from a DFG frame,
 603                 // and we end up having to unwind past an EntryFrame, we will end up executing
 604                 // inside the LLInt&#39;s handleUncaughtException. So we just protect against this
 605                 // by ignoring it.
<span class="line-modified"> 606                 BytecodeIndex bytecodeIndex = BytecodeIndex(0);</span>
 607                 if (topCodeBlock-&gt;jitType() == JITType::InterpreterThunk || topCodeBlock-&gt;jitType() == JITType::BaselineJIT) {
<span class="line-modified"> 608                     unsigned bits = static_cast&lt;unsigned&gt;(bitwise_cast&lt;uintptr_t&gt;(unprocessedStackTrace.llintPC));</span>
<span class="line-modified"> 609                     bytecodeIndex = tryGetBytecodeIndex(bits, topCodeBlock);</span>






 610 
<span class="line-modified"> 611                     UNUSED_PARAM(bytecodeIndex); // FIXME: do something with this info for the web inspector: https://bugs.webkit.org/show_bug.cgi?id=153455</span>
 612 
 613                     appendCodeBlock(topCodeBlock, bytecodeIndex);
 614                     storeCalleeIntoLastFrame(unprocessedStackTrace.frames[0]);
 615                     startIndex = 1;
 616                 }
 617             } else {
 618 #if ENABLE(JIT)
 619                 if (Optional&lt;CodeOrigin&gt; codeOrigin = topCodeBlock-&gt;findPC(unprocessedStackTrace.topPC)) {
 620                     appendCodeOrigin(topCodeBlock, *codeOrigin);
 621                     storeCalleeIntoLastFrame(unprocessedStackTrace.frames[0]);
 622                     startIndex = 1;
 623                 }
 624 #endif
 625                 UNUSED_PARAM(appendCodeOrigin);
 626             }
 627         }
 628 
 629         for (size_t i = startIndex; i &lt; unprocessedStackTrace.frames.size(); i++) {
 630             UnprocessedStackFrame&amp; unprocessedStackFrame = unprocessedStackTrace.frames[i];
 631             if (CodeBlock* codeBlock = unprocessedStackFrame.verifiedCodeBlock) {
 632                 CallSiteIndex callSiteIndex = unprocessedStackFrame.callSiteIndex;
 633 
 634                 auto appendCodeBlockNoInlining = [&amp;] {
<span class="line-modified"> 635                     appendCodeBlock(codeBlock, tryGetBytecodeIndex(callSiteIndex.bits(), codeBlock));</span>

 636                 };
 637 
 638 #if ENABLE(DFG_JIT)
 639                 if (codeBlock-&gt;hasCodeOrigins()) {
 640                     if (codeBlock-&gt;canGetCodeOrigin(callSiteIndex))
 641                         appendCodeOrigin(codeBlock, codeBlock-&gt;codeOrigin(callSiteIndex));
 642                     else
<span class="line-modified"> 643                         appendCodeBlock(codeBlock, BytecodeIndex());</span>
 644                 } else
 645                     appendCodeBlockNoInlining();
 646 #else
 647                 appendCodeBlockNoInlining();
 648 #endif
 649             } else if (unprocessedStackFrame.cCodePC) {
 650                 appendEmptyFrame();
 651                 stackTrace.frames.last().cCodePC = unprocessedStackFrame.cCodePC;
 652                 stackTrace.frames.last().frameType = FrameType::C;
 653             } else
 654                 appendEmptyFrame();
 655 
 656             // Note that this is okay to do if we walked the inline stack because
 657             // the machine frame will be at the top of the processed stack trace.
 658             if (!unprocessedStackFrame.cCodePC)
 659                 storeCalleeIntoLastFrame(unprocessedStackFrame);
 660         }
 661     }
 662 
 663     m_unprocessedStackTraces.clear();
</pre>
<hr />
<pre>
 720     ASSERT(m_vm.entryScope);
 721     noticeCurrentThreadAsJSCExecutionThread(locker);
 722     m_lastTime = m_stopwatch-&gt;elapsedTime();
 723     createThreadIfNecessary(locker);
 724 }
 725 
 726 void SamplingProfiler::clearData(const AbstractLocker&amp;)
 727 {
 728     ASSERT(m_lock.isLocked());
 729     m_stackTraces.clear();
 730     m_liveCellPointers.clear();
 731     m_unprocessedStackTraces.clear();
 732 }
 733 
 734 String SamplingProfiler::StackFrame::nameFromCallee(VM&amp; vm)
 735 {
 736     if (!callee)
 737         return String();
 738 
 739     auto scope = DECLARE_CATCH_SCOPE(vm);
<span class="line-modified"> 740     JSGlobalObject* globalObject = callee-&gt;globalObject(vm);</span>
 741     auto getPropertyIfPureOperation = [&amp;] (const Identifier&amp; ident) -&gt; String {
 742         PropertySlot slot(callee, PropertySlot::InternalMethodType::VMInquiry);
 743         PropertyName propertyName(ident);
<span class="line-modified"> 744         bool hasProperty = callee-&gt;getPropertySlot(globalObject, propertyName, slot);</span>
 745         scope.assertNoException();
 746         if (hasProperty) {
 747             if (slot.isValue()) {
<span class="line-modified"> 748                 JSValue nameValue = slot.getValue(globalObject, propertyName);</span>
 749                 if (isJSString(nameValue))
 750                     return asString(nameValue)-&gt;tryGetValue();
 751             }
 752         }
 753         return String();
 754     };
 755 
 756     String name = getPropertyIfPureOperation(vm.propertyNames-&gt;displayName);
 757     if (!name.isEmpty())
 758         return name;
 759 
 760     return getPropertyIfPureOperation(vm.propertyNames-&gt;name);
 761 }
 762 
 763 String SamplingProfiler::StackFrame::displayName(VM&amp; vm)
 764 {
 765     {
 766         String name = nameFromCallee(vm);
 767         if (!name.isEmpty())
 768             return name;
</pre>
<hr />
<pre>
 922     case FrameType::Wasm:
 923         return emptyString();
 924     case FrameType::Executable:
 925         if (executable-&gt;isHostFunction())
 926             return emptyString();
 927 
 928         String url = static_cast&lt;ScriptExecutable*&gt;(executable)-&gt;sourceURL();
 929         if (url.isEmpty())
 930             return static_cast&lt;ScriptExecutable*&gt;(executable)-&gt;source().provider()-&gt;sourceURLDirective(); // Fall back to sourceURL directive.
 931         return url;
 932     }
 933     RELEASE_ASSERT_NOT_REACHED();
 934     return String();
 935 }
 936 
 937 Vector&lt;SamplingProfiler::StackTrace&gt; SamplingProfiler::releaseStackTraces(const AbstractLocker&amp; locker)
 938 {
 939     ASSERT(m_lock.isLocked());
 940     {
 941         HeapIterationScope heapIterationScope(m_vm.heap);
<span class="line-modified"> 942         processUnverifiedStackTraces(locker);</span>
 943     }
 944 
 945     Vector&lt;StackTrace&gt; result(WTFMove(m_stackTraces));
 946     clearData(locker);
 947     return result;
 948 }
 949 
 950 String SamplingProfiler::stackTracesAsJSON()
 951 {
 952     DeferGC deferGC(m_vm.heap);
<span class="line-modified"> 953     auto locker = holdLock(m_lock);</span>
 954 
 955     {
 956         HeapIterationScope heapIterationScope(m_vm.heap);
<span class="line-modified"> 957         processUnverifiedStackTraces(locker);</span>
 958     }
 959 
 960     StringBuilder json;
 961     json.append(&#39;[&#39;);
 962 
 963     bool loopedOnce = false;
 964     auto comma = [&amp;] {
 965         if (loopedOnce)
 966             json.append(&#39;,&#39;);
 967     };
 968     for (StackTrace&amp; stackTrace : m_stackTraces) {
 969         comma();
 970         json.append(&#39;[&#39;);
 971         loopedOnce = false;
 972         for (StackFrame&amp; stackFrame : stackTrace.frames) {
 973             comma();
 974             json.appendQuotedJSONString(stackFrame.displayNameForJSONTests(m_vm));
 975             loopedOnce = true;
 976         }
 977         json.append(&#39;]&#39;);
 978         loopedOnce = true;
 979     }
 980 
 981     json.append(&#39;]&#39;);
 982 
 983     clearData(locker);
 984 
 985     return json.toString();
 986 }
 987 
 988 void SamplingProfiler::registerForReportAtExit()
 989 {
 990     static Lock registrationLock;
 991     static HashSet&lt;RefPtr&lt;SamplingProfiler&gt;&gt;* profilesToReport;
 992 
 993     LockHolder holder(registrationLock);
 994 
 995     if (!profilesToReport) {
 996         profilesToReport = new HashSet&lt;RefPtr&lt;SamplingProfiler&gt;&gt;();
 997         atexit([]() {
<span class="line-modified"> 998             for (const auto&amp; profile : *profilesToReport)</span>
 999                 profile-&gt;reportDataToOptionFile();
1000         });
1001     }
1002 
1003     profilesToReport-&gt;add(adoptRef(this));
1004     m_needsReportAtExit = true;
1005 }
1006 
1007 void SamplingProfiler::reportDataToOptionFile()
1008 {
1009     if (m_needsReportAtExit) {
1010         m_needsReportAtExit = false;
<span class="line-added">1011         JSLockHolder holder(m_vm);</span>
1012         const char* path = Options::samplingProfilerPath();
1013         StringPrintStream pathOut;
1014         pathOut.print(path, &quot;/&quot;);
1015         pathOut.print(&quot;JSCSampilingProfile-&quot;, reinterpret_cast&lt;uintptr_t&gt;(this), &quot;.txt&quot;);
1016         auto out = FilePrintStream::open(pathOut.toCString().data(), &quot;w&quot;);
1017         reportTopFunctions(*out);
1018         reportTopBytecodes(*out);
1019     }
1020 }
1021 
1022 void SamplingProfiler::reportTopFunctions()
1023 {
1024     reportTopFunctions(WTF::dataFile());
1025 }
1026 
1027 void SamplingProfiler::reportTopFunctions(PrintStream&amp; out)
1028 {
<span class="line-modified">1029     auto locker = holdLock(m_lock);</span>
1030     DeferGCForAWhile deferGC(m_vm.heap);
1031 
1032     {
1033         HeapIterationScope heapIterationScope(m_vm.heap);
<span class="line-modified">1034         processUnverifiedStackTraces(locker);</span>
1035     }
1036 
1037 
1038     HashMap&lt;String, size_t&gt; functionCounts;
1039     for (StackTrace&amp; stackTrace : m_stackTraces) {
1040         if (!stackTrace.frames.size())
1041             continue;
1042 
1043         StackFrame&amp; frame = stackTrace.frames.first();
1044         String frameDescription = makeString(frame.displayName(m_vm), &#39;:&#39;, frame.sourceID());
1045         functionCounts.add(frameDescription, 0).iterator-&gt;value++;
1046     }
1047 
1048     auto takeMax = [&amp;] () -&gt; std::pair&lt;String, size_t&gt; {
1049         String maxFrameDescription;
1050         size_t maxFrameCount = 0;
<span class="line-modified">1051         for (const auto&amp; entry : functionCounts) {</span>
1052             if (entry.value &gt; maxFrameCount) {
1053                 maxFrameCount = entry.value;
1054                 maxFrameDescription = entry.key;
1055             }
1056         }
1057         if (!maxFrameDescription.isEmpty())
1058             functionCounts.remove(maxFrameDescription);
1059         return std::make_pair(maxFrameDescription, maxFrameCount);
1060     };
1061 
1062     if (Options::samplingProfilerTopFunctionsCount()) {
1063         out.print(&quot;\n\nSampling rate: &quot;, m_timingInterval.microseconds(), &quot; microseconds\n&quot;);
1064         out.print(&quot;Top functions as &lt;numSamples  &#39;functionName:sourceID&#39;&gt;\n&quot;);
1065         for (size_t i = 0; i &lt; Options::samplingProfilerTopFunctionsCount(); i++) {
1066             auto pair = takeMax();
1067             if (pair.first.isEmpty())
1068                 break;
1069             out.printf(&quot;%6zu &quot;, pair.second);
1070             out.print(&quot;   &#39;&quot;, pair.first, &quot;&#39;\n&quot;);
1071         }
1072     }
1073 }
1074 
1075 void SamplingProfiler::reportTopBytecodes()
1076 {
1077     reportTopBytecodes(WTF::dataFile());
1078 }
1079 
1080 void SamplingProfiler::reportTopBytecodes(PrintStream&amp; out)
1081 {
<span class="line-modified">1082     auto locker = holdLock(m_lock);</span>
1083     DeferGCForAWhile deferGC(m_vm.heap);
1084 
1085     {
1086         HeapIterationScope heapIterationScope(m_vm.heap);
<span class="line-modified">1087         processUnverifiedStackTraces(locker);</span>
1088     }
1089 
1090     HashMap&lt;String, size_t&gt; bytecodeCounts;
1091     for (StackTrace&amp; stackTrace : m_stackTraces) {
1092         if (!stackTrace.frames.size())
1093             continue;
1094 
1095         auto descriptionForLocation = [&amp;] (StackFrame::CodeLocation location, Optional&lt;Wasm::CompilationMode&gt; wasmCompilationMode) -&gt; String {
1096             String bytecodeIndex;
1097             String codeBlockHash;
1098             String jitType;
1099             if (location.hasBytecodeIndex())
<span class="line-modified">1100                 bytecodeIndex = toString(location.bytecodeIndex);</span>
1101             else
1102                 bytecodeIndex = &quot;&lt;nil&gt;&quot;;
1103 
1104             if (location.hasCodeBlockHash()) {
1105                 StringPrintStream stream;
1106                 location.codeBlockHash.dump(stream);
1107                 codeBlockHash = stream.toString();
1108             } else
1109                 codeBlockHash = &quot;&lt;nil&gt;&quot;;
1110 
1111             if (wasmCompilationMode)
1112                 jitType = Wasm::makeString(wasmCompilationMode.value());
1113             else
1114                 jitType = JITCode::typeName(location.jitType);
1115 
1116             return makeString(&quot;#&quot;, codeBlockHash, &quot;:&quot;, jitType, &quot;:&quot;, bytecodeIndex);
1117         };
1118 
1119         StackFrame&amp; frame = stackTrace.frames.first();
1120         String frameDescription = makeString(frame.displayName(m_vm), descriptionForLocation(frame.semanticLocation, frame.wasmCompilationMode));
1121         if (Optional&lt;std::pair&lt;StackFrame::CodeLocation, CodeBlock*&gt;&gt; machineLocation = frame.machineLocation) {
1122             frameDescription = makeString(frameDescription, &quot; &lt;-- &quot;,
1123                 machineLocation-&gt;second-&gt;inferredName().data(), descriptionForLocation(machineLocation-&gt;first, WTF::nullopt));
1124         }
1125         bytecodeCounts.add(frameDescription, 0).iterator-&gt;value++;
1126     }
1127 
1128     auto takeMax = [&amp;] () -&gt; std::pair&lt;String, size_t&gt; {
1129         String maxFrameDescription;
1130         size_t maxFrameCount = 0;
<span class="line-modified">1131         for (const auto&amp; entry : bytecodeCounts) {</span>
1132             if (entry.value &gt; maxFrameCount) {
1133                 maxFrameCount = entry.value;
1134                 maxFrameDescription = entry.key;
1135             }
1136         }
1137         if (!maxFrameDescription.isEmpty())
1138             bytecodeCounts.remove(maxFrameDescription);
1139         return std::make_pair(maxFrameDescription, maxFrameCount);
1140     };
1141 
1142     if (Options::samplingProfilerTopBytecodesCount()) {
1143         out.print(&quot;\n\nSampling rate: &quot;, m_timingInterval.microseconds(), &quot; microseconds\n&quot;);
1144         out.print(&quot;Hottest bytecodes as &lt;numSamples   &#39;functionName#hash:JITType:bytecodeIndex&#39;&gt;\n&quot;);
1145         for (size_t i = 0; i &lt; Options::samplingProfilerTopBytecodesCount(); i++) {
1146             auto pair = takeMax();
1147             if (pair.first.isEmpty())
1148                 break;
1149             out.printf(&quot;%6zu &quot;, pair.second);
1150             out.print(&quot;   &#39;&quot;, pair.first, &quot;&#39;\n&quot;);
1151         }
</pre>
</td>
</tr>
</table>
<center><a href="RegExpStringIteratorPrototype.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="SamplingProfiler.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
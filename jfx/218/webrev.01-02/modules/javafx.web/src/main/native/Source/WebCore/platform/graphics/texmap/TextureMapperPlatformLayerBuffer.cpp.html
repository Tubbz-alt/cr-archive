<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/graphics/texmap/TextureMapperPlatformLayerBuffer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2015 Igalia S.L.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;TextureMapperPlatformLayerBuffer.h&quot;
 28 
 29 #if USE(COORDINATED_GRAPHICS)
 30 
 31 #include &quot;FloatRect.h&quot;
 32 #include &quot;NotImplemented.h&quot;
 33 
 34 namespace WebCore {
 35 
 36 TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(RefPtr&lt;BitmapTexture&gt;&amp;&amp; texture, TextureMapperGL::Flags flags)
 37     : m_texture(WTFMove(texture))
 38     , m_variant(RGBTexture { 0 })
 39     , m_extraFlags(flags)
 40     , m_hasManagedTexture(true)
 41 {
 42 }
 43 
 44 TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(GLuint textureID, const IntSize&amp; size, TextureMapperGL::Flags flags, GLint internalFormat)
 45     : TextureMapperPlatformLayerBuffer({ RGBTexture { textureID } }, size, flags, internalFormat)
 46 {
 47 }
 48 
 49 TextureMapperPlatformLayerBuffer::TextureMapperPlatformLayerBuffer(TextureVariant&amp;&amp; variant, const IntSize&amp; size, TextureMapperGL::Flags flags, GLint internalFormat)
 50     : m_variant(WTFMove(variant))
 51     , m_size(size)
 52     , m_internalFormat(internalFormat)
 53     , m_extraFlags(flags)
 54     , m_hasManagedTexture(false)
 55 {
 56 }
 57 
 58 TextureMapperPlatformLayerBuffer::~TextureMapperPlatformLayerBuffer()
 59 {
 60 }
 61 
 62 bool TextureMapperPlatformLayerBuffer::canReuseWithoutReset(const IntSize&amp; size, GLint internalFormat)
 63 {
 64     return m_texture &amp;&amp; (m_texture-&gt;size() == size) &amp;&amp; (static_cast&lt;BitmapTextureGL*&gt;(m_texture.get())-&gt;internalFormat() == internalFormat || internalFormat == GL_DONT_CARE);
 65 }
 66 
 67 std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; TextureMapperPlatformLayerBuffer::clone()
 68 {
 69     if (m_hasManagedTexture) {
 70         notImplemented();
 71         return nullptr;
 72     }
 73 
 74     return WTF::switchOn(m_variant,
 75         [&amp;](const RGBTexture&amp; texture) mutable -&gt; std::unique_ptr&lt;TextureMapperPlatformLayerBuffer&gt; {
 76             if (!texture.id) {
 77                 notImplemented();
 78                 return nullptr;
 79             }
 80 
 81             auto clonedTexture = BitmapTextureGL::create(TextureMapperContextAttributes::get(), m_internalFormat);
 82             clonedTexture-&gt;reset(m_size);
 83             static_cast&lt;BitmapTextureGL&amp;&gt;(clonedTexture.get()).copyFromExternalTexture(texture.id);
 84             return makeUnique&lt;TextureMapperPlatformLayerBuffer&gt;(WTFMove(clonedTexture), m_extraFlags);
 85         },
 86         [](const YUVTexture&amp;)
 87         {
 88             notImplemented();
 89             return nullptr;
 90         },
 91         [](const ExternalOESTexture&amp;)
 92         {
 93             notImplemented();
 94             return nullptr;
 95         });
 96 }
 97 
 98 void TextureMapperPlatformLayerBuffer::paintToTextureMapper(TextureMapper&amp; textureMapper, const FloatRect&amp; targetRect, const TransformationMatrix&amp; modelViewMatrix, float opacity)
 99 {
100     TextureMapperGL&amp; texmapGL = static_cast&lt;TextureMapperGL&amp;&gt;(textureMapper);
101 
102     if (m_hasManagedTexture) {
103         ASSERT(m_texture);
104         BitmapTextureGL* textureGL = static_cast&lt;BitmapTextureGL*&gt;(m_texture.get());
105 #if USE(ANGLE)
106         textureGL-&gt;updatePendingContents(IntRect(IntPoint(), textureGL-&gt;contentSize()), IntPoint());
107 #endif
108         texmapGL.drawTexture(textureGL-&gt;id(), m_extraFlags | textureGL-&gt;colorConvertFlags(), textureGL-&gt;size(), targetRect, modelViewMatrix, opacity);
109         return;
110     }
111 
112     if (m_extraFlags &amp; TextureMapperGL::ShouldNotBlend) {
113         ASSERT(!m_texture);
114         if (m_holePunchClient)
115             m_holePunchClient-&gt;setVideoRectangle(enclosingIntRect(modelViewMatrix.mapRect(targetRect)));
116         texmapGL.drawSolidColor(targetRect, modelViewMatrix, Color(0, 0, 0, 0), false);
117         return;
118     }
119 
120 #if USE(GSTREAMER_GL)
121     if (m_unmanagedBufferDataHolder)
122         m_unmanagedBufferDataHolder-&gt;waitForCPUSync();
123 #endif // USE(GSTREAMER_GL)
124 
125     WTF::switchOn(m_variant,
126         [&amp;](const RGBTexture&amp; texture) {
127             ASSERT(texture.id);
128             texmapGL.drawTexture(texture.id, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);
129         },
130         [&amp;](const YUVTexture&amp; texture) {
131             switch (texture.numberOfPlanes) {
132             case 1:
133                 ASSERT(texture.yuvPlane[0] == texture.yuvPlane[1] &amp;&amp; texture.yuvPlane[1] == texture.yuvPlane[2]);
134                 ASSERT(texture.yuvPlaneOffset[0] == 2 &amp;&amp; texture.yuvPlaneOffset[1] == 1 &amp;&amp; !texture.yuvPlaneOffset[2]);
135                 texmapGL.drawTexturePackedYUV(texture.planes[texture.yuvPlane[0]],
136                     texture.yuvToRgbMatrix, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);
137                 break;
138             case 2:
139                 ASSERT(!texture.yuvPlaneOffset[0]);
140                 texmapGL.drawTextureSemiPlanarYUV(std::array&lt;GLuint, 2&gt; { texture.planes[texture.yuvPlane[0]], texture.planes[texture.yuvPlane[1]] }, !!texture.yuvPlaneOffset[1],
141                     texture.yuvToRgbMatrix, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);
142                 break;
143             case 3:
144                 ASSERT(!texture.yuvPlaneOffset[0] &amp;&amp; !texture.yuvPlaneOffset[1] &amp;&amp; !texture.yuvPlaneOffset[2]);
145                 texmapGL.drawTexturePlanarYUV(std::array&lt;GLuint, 3&gt; { texture.planes[texture.yuvPlane[0]], texture.planes[texture.yuvPlane[1]], texture.planes[texture.yuvPlane[2]] },
146                     texture.yuvToRgbMatrix, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);
147                 break;
148             }
149         },
150         [&amp;](const ExternalOESTexture&amp; texture) {
151             ASSERT(texture.id);
152             texmapGL.drawTextureExternalOES(texture.id, m_extraFlags, m_size, targetRect, modelViewMatrix, opacity);
153         });
154 }
155 
156 } // namespace WebCore
157 
158 #endif // USE(COORDINATED_GRAPHICS)
    </pre>
  </body>
</html>
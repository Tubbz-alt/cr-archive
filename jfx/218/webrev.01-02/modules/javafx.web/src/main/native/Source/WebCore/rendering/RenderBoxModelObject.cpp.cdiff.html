<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBoxModelObject.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderBox.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBoxModelObject.h.cdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBoxModelObject.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 60,11 ***</span>
  #include &quot;ScrollingConstraints.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;TransformState.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
<span class="line-modified">! #if !ASSERT_DISABLED</span>
  #include &lt;wtf/SetForScope.h&gt;
  #endif
  
  #if PLATFORM(IOS_FAMILY)
  #include &quot;RuntimeApplicationChecks.h&quot;
<span class="line-new-header">--- 60,11 ---</span>
  #include &quot;ScrollingConstraints.h&quot;
  #include &quot;Settings.h&quot;
  #include &quot;TransformState.h&quot;
  #include &lt;wtf/IsoMallocInlines.h&gt;
  #include &lt;wtf/NeverDestroyed.h&gt;
<span class="line-modified">! #if ASSERT_ENABLED</span>
  #include &lt;wtf/SetForScope.h&gt;
  #endif
  
  #if PLATFORM(IOS_FAMILY)
  #include &quot;RuntimeApplicationChecks.h&quot;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 443,11 ***</span>
  
  const RenderBox&amp; RenderBoxModelObject::enclosingClippingBoxForStickyPosition(const RenderLayer** enclosingClippingLayer) const
  {
      ASSERT(isStickilyPositioned());
  
<span class="line-modified">!     auto* clipLayer = layer()-&gt;enclosingOverflowClipLayer(ExcludeSelf);</span>
      if (enclosingClippingLayer)
          *enclosingClippingLayer = clipLayer;
  
      return clipLayer ? downcast&lt;RenderBox&gt;(clipLayer-&gt;renderer()) : view();
  }
<span class="line-new-header">--- 443,12 ---</span>
  
  const RenderBox&amp; RenderBoxModelObject::enclosingClippingBoxForStickyPosition(const RenderLayer** enclosingClippingLayer) const
  {
      ASSERT(isStickilyPositioned());
  
<span class="line-modified">!     RenderLayer* clipLayer = hasLayer() ? layer()-&gt;enclosingOverflowClipLayer(ExcludeSelf) : nullptr;</span>
<span class="line-added">+ </span>
      if (enclosingClippingLayer)
          *enclosingClippingLayer = clipLayer;
  
      return clipLayer ? downcast&lt;RenderBox&gt;(clipLayer-&gt;renderer()) : view();
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 534,11 ***</span>
      }
  }
  
  FloatRect RenderBoxModelObject::constrainingRectForStickyPosition() const
  {
<span class="line-modified">!     RenderLayer* enclosingClippingLayer = layer()-&gt;enclosingOverflowClipLayer(ExcludeSelf);</span>
      if (enclosingClippingLayer) {
          RenderBox&amp; enclosingClippingBox = downcast&lt;RenderBox&gt;(enclosingClippingLayer-&gt;renderer());
          LayoutRect clipRect = enclosingClippingBox.overflowClipRect(LayoutPoint(), nullptr); // FIXME: make this work in regions.
          clipRect.contract(LayoutSize(enclosingClippingBox.paddingLeft() + enclosingClippingBox.paddingRight(),
              enclosingClippingBox.paddingTop() + enclosingClippingBox.paddingBottom()));
<span class="line-new-header">--- 535,12 ---</span>
      }
  }
  
  FloatRect RenderBoxModelObject::constrainingRectForStickyPosition() const
  {
<span class="line-modified">!     RenderLayer* enclosingClippingLayer = hasLayer() ? layer()-&gt;enclosingOverflowClipLayer(ExcludeSelf) : nullptr;</span>
<span class="line-added">+ </span>
      if (enclosingClippingLayer) {
          RenderBox&amp; enclosingClippingBox = downcast&lt;RenderBox&gt;(enclosingClippingLayer-&gt;renderer());
          LayoutRect clipRect = enclosingClippingBox.overflowClipRect(LayoutPoint(), nullptr); // FIXME: make this work in regions.
          clipRect.contract(LayoutSize(enclosingClippingBox.paddingLeft() + enclosingClippingBox.paddingRight(),
              enclosingClippingBox.paddingTop() + enclosingClippingBox.paddingBottom()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 558,12 ***</span>
      return view().frameView().rectForFixedPositionLayout();
  }
  
  LayoutSize RenderBoxModelObject::stickyPositionOffset() const
  {
<span class="line-removed">-     ASSERT(hasLayer());</span>
<span class="line-removed">- </span>
      FloatRect constrainingRect = constrainingRectForStickyPosition();
      StickyPositionViewportConstraints constraints;
      computeStickyPositionConstraints(constraints, constrainingRect);
  
      // The sticky offset is physical, so we can just return the delta computed in absolute coords (though it may be wrong with transforms).
<span class="line-new-header">--- 560,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 678,11 ***</span>
  }
  
  static void applyBoxShadowForBackground(GraphicsContext&amp; context, const RenderStyle&amp; style)
  {
      const ShadowData* boxShadow = style.boxShadow();
<span class="line-modified">!     while (boxShadow-&gt;style() != Normal)</span>
          boxShadow = boxShadow-&gt;next();
  
      FloatSize shadowOffset(boxShadow-&gt;x(), boxShadow-&gt;y());
      if (!boxShadow-&gt;isWebkitBoxShadow())
          context.setShadow(shadowOffset, boxShadow-&gt;radius(), style.colorByApplyingColorFilter(boxShadow-&gt;color()));
<span class="line-new-header">--- 678,11 ---</span>
  }
  
  static void applyBoxShadowForBackground(GraphicsContext&amp; context, const RenderStyle&amp; style)
  {
      const ShadowData* boxShadow = style.boxShadow();
<span class="line-modified">!     while (boxShadow-&gt;style() != ShadowStyle::Normal)</span>
          boxShadow = boxShadow-&gt;next();
  
      FloatSize shadowOffset(boxShadow-&gt;x(), boxShadow-&gt;y());
      if (!boxShadow-&gt;isWebkitBoxShadow())
          context.setShadow(shadowOffset, boxShadow-&gt;radius(), style.colorByApplyingColorFilter(boxShadow-&gt;color()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 859,11 ***</span>
          // to actually render, so we should intersect the dirty rect with the border box of the background.
          maskRect = snappedIntRect(rect);
          maskRect.intersect(snappedIntRect(paintInfo.rect));
  
          // Now create the mask.
<span class="line-modified">!         maskImage = ImageBuffer::createCompatibleBuffer(maskRect.size(), ColorSpaceSRGB, context);</span>
          if (!maskImage)
              return;
          paintMaskForTextFillBox(maskImage.get(), maskRect, box, scrolledPaintRect);
  
          // The mask has been created.  Now we just need to clip to it.
<span class="line-new-header">--- 859,11 ---</span>
          // to actually render, so we should intersect the dirty rect with the border box of the background.
          maskRect = snappedIntRect(rect);
          maskRect.intersect(snappedIntRect(paintInfo.rect));
  
          // Now create the mask.
<span class="line-modified">!         maskImage = ImageBuffer::createCompatibleBuffer(maskRect.size(), ColorSpace::SRGB, context);</span>
          if (!maskImage)
              return;
          paintMaskForTextFillBox(maskImage.get(), maskRect, box, scrolledPaintRect);
  
          // The mask has been created.  Now we just need to clip to it.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 924,18 ***</span>
  
              FloatRect backgroundRectForPainting = snapRectToDevicePixels(backgroundRect, deviceScaleFactor);
              if (baseColor.isVisible()) {
                  if (!baseBgColorOnly &amp;&amp; bgColor.isVisible())
                      baseColor = baseColor.blend(bgColor);
<span class="line-modified">!                 context.fillRect(backgroundRectForPainting, baseColor, CompositeCopy);</span>
              } else if (!baseBgColorOnly &amp;&amp; bgColor.isVisible()) {
                  auto operation = context.compositeOperation();
                  if (shouldClearBackground) {
<span class="line-modified">!                     if (op == CompositeDestinationOut) // We&#39;re punching out the background.</span>
                          operation = op;
                      else
<span class="line-modified">!                         operation = CompositeCopy;</span>
                  }
                  context.fillRect(backgroundRectForPainting, bgColor, operation);
              } else if (shouldClearBackground)
                  context.clearRect(backgroundRectForPainting);
          }
<span class="line-new-header">--- 924,18 ---</span>
  
              FloatRect backgroundRectForPainting = snapRectToDevicePixels(backgroundRect, deviceScaleFactor);
              if (baseColor.isVisible()) {
                  if (!baseBgColorOnly &amp;&amp; bgColor.isVisible())
                      baseColor = baseColor.blend(bgColor);
<span class="line-modified">!                 context.fillRect(backgroundRectForPainting, baseColor, CompositeOperator::Copy);</span>
              } else if (!baseBgColorOnly &amp;&amp; bgColor.isVisible()) {
                  auto operation = context.compositeOperation();
                  if (shouldClearBackground) {
<span class="line-modified">!                     if (op == CompositeOperator::DestinationOut) // We&#39;re punching out the background.</span>
                          operation = op;
                      else
<span class="line-modified">!                         operation = CompositeOperator::Copy;</span>
                  }
                  context.fillRect(backgroundRectForPainting, bgColor, operation);
              } else if (shouldClearBackground)
                  context.clearRect(backgroundRectForPainting);
          }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 945,28 ***</span>
      if (!baseBgColorOnly &amp;&amp; shouldPaintBackgroundImage) {
          auto geometry = calculateBackgroundImageGeometry(paintInfo.paintContainer, bgLayer, rect.location(), scrolledPaintRect, backgroundObject);
          geometry.clip(LayoutRect(pixelSnappedRect));
          RefPtr&lt;Image&gt; image;
          if (!geometry.destRect().isEmpty() &amp;&amp; (image = bgImage-&gt;image(backgroundObject ? backgroundObject : this, geometry.tileSize()))) {
<span class="line-removed">-             auto compositeOp = op == CompositeSourceOver ? bgLayer.composite() : op;</span>
              context.setDrawLuminanceMask(bgLayer.maskSourceType() == MaskSourceType::Luminance);
  
              if (is&lt;BitmapImage&gt;(image))
                  downcast&lt;BitmapImage&gt;(*image).updateFromSettings(settings());
  
<span class="line-modified">!             auto interpolation = chooseInterpolationQuality(context, *image, &amp;bgLayer, geometry.tileSize());</span>
<span class="line-modified">!             auto decodingMode = decodingModeForImageDraw(*image, paintInfo);</span>
<span class="line-modified">!             auto drawResult = context.drawTiledImage(*image, geometry.destRect(), toLayoutPoint(geometry.relativePhase()), geometry.tileSize(), geometry.spaceSize(), { compositeOp, bgLayer.blendMode(), decodingMode, interpolation });</span>
              if (drawResult == ImageDrawResult::DidRequestDecoding) {
<span class="line-modified">!                 ASSERT(bgImage-&gt;isCachedImage());</span>
                  bgImage-&gt;cachedImage()-&gt;addClientWaitingForAsyncDecoding(*this);
              }
          }
      }
  
      if (maskImage &amp;&amp; bgLayer.clip() == FillBox::Text) {
<span class="line-modified">!         context.drawConsumingImageBuffer(WTFMove(maskImage), maskRect, CompositeDestinationIn);</span>
          context.endTransparencyLayer();
      }
  }
  
  static inline LayoutUnit resolveWidthForRatio(LayoutUnit height, const LayoutSize&amp; intrinsicRatio)
<span class="line-new-header">--- 945,33 ---</span>
      if (!baseBgColorOnly &amp;&amp; shouldPaintBackgroundImage) {
          auto geometry = calculateBackgroundImageGeometry(paintInfo.paintContainer, bgLayer, rect.location(), scrolledPaintRect, backgroundObject);
          geometry.clip(LayoutRect(pixelSnappedRect));
          RefPtr&lt;Image&gt; image;
          if (!geometry.destRect().isEmpty() &amp;&amp; (image = bgImage-&gt;image(backgroundObject ? backgroundObject : this, geometry.tileSize()))) {
              context.setDrawLuminanceMask(bgLayer.maskSourceType() == MaskSourceType::Luminance);
  
              if (is&lt;BitmapImage&gt;(image))
                  downcast&lt;BitmapImage&gt;(*image).updateFromSettings(settings());
  
<span class="line-modified">!             ImagePaintingOptions options = {</span>
<span class="line-modified">!                 op == CompositeOperator::SourceOver ? bgLayer.composite() : op,</span>
<span class="line-modified">!                 bgLayer.blendMode(),</span>
<span class="line-added">+                 decodingModeForImageDraw(*image, paintInfo),</span>
<span class="line-added">+                 ImageOrientation::FromImage,</span>
<span class="line-added">+                 chooseInterpolationQuality(context, *image, &amp;bgLayer, geometry.tileSize())</span>
<span class="line-added">+             };</span>
<span class="line-added">+ </span>
<span class="line-added">+             auto drawResult = context.drawTiledImage(*image, geometry.destRect(), toLayoutPoint(geometry.relativePhase()), geometry.tileSize(), geometry.spaceSize(), options);</span>
              if (drawResult == ImageDrawResult::DidRequestDecoding) {
<span class="line-modified">!                 ASSERT(bgImage-&gt;hasCachedImage());</span>
                  bgImage-&gt;cachedImage()-&gt;addClientWaitingForAsyncDecoding(*this);
              }
          }
      }
  
      if (maskImage &amp;&amp; bgLayer.clip() == FillBox::Text) {
<span class="line-modified">!         context.drawConsumingImageBuffer(WTFMove(maskImage), maskRect, CompositeOperator::DestinationIn);</span>
          context.endTransparencyLayer();
      }
  }
  
  static inline LayoutUnit resolveWidthForRatio(LayoutUnit height, const LayoutSize&amp; intrinsicRatio)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2278,11 ***</span>
      if (style().hasAppearance())
          return false;
  
      bool hasOneNormalBoxShadow = false;
      for (const ShadowData* currentShadow = style().boxShadow(); currentShadow; currentShadow = currentShadow-&gt;next()) {
<span class="line-modified">!         if (currentShadow-&gt;style() != Normal)</span>
              continue;
  
          if (hasOneNormalBoxShadow)
              return false;
          hasOneNormalBoxShadow = true;
<span class="line-new-header">--- 2283,11 ---</span>
      if (style().hasAppearance())
          return false;
  
      bool hasOneNormalBoxShadow = false;
      for (const ShadowData* currentShadow = style().boxShadow(); currentShadow; currentShadow = currentShadow-&gt;next()) {
<span class="line-modified">!         if (currentShadow-&gt;style() != ShadowStyle::Normal)</span>
              continue;
  
          if (hasOneNormalBoxShadow)
              return false;
          hasOneNormalBoxShadow = true;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2315,11 ***</span>
          return false;
  
      return true;
  }
  
<span class="line-modified">! static inline LayoutRect areaCastingShadowInHole(const LayoutRect&amp; holeRect, int shadowExtent, int shadowSpread, const IntSize&amp; shadowOffset)</span>
  {
      LayoutRect bounds(holeRect);
  
      bounds.inflate(shadowExtent);
  
<span class="line-new-header">--- 2320,11 ---</span>
          return false;
  
      return true;
  }
  
<span class="line-modified">! static inline LayoutRect areaCastingShadowInHole(const LayoutRect&amp; holeRect, LayoutUnit shadowExtent, LayoutUnit shadowSpread, const LayoutSize&amp; shadowOffset)</span>
  {
      LayoutRect bounds(holeRect);
  
      bounds.inflate(shadowExtent);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2336,11 ***</span>
      // FIXME: Deal with border-image.  Would be great to use border-image as a mask.
      GraphicsContext&amp; context = info.context();
      if (context.paintingDisabled() || !style.boxShadow())
          return;
  
<span class="line-modified">!     RoundedRect border = (shadowStyle == Inset) ? style.getRoundedInnerBorderFor(paintRect, includeLogicalLeftEdge, includeLogicalRightEdge)</span>
          : style.getRoundedBorderFor(paintRect, includeLogicalLeftEdge, includeLogicalRightEdge);
  
      bool hasBorderRadius = style.hasBorderRadius();
      bool isHorizontal = style.isHorizontalWritingMode();
      float deviceScaleFactor = document().deviceScaleFactor();
<span class="line-new-header">--- 2341,11 ---</span>
      // FIXME: Deal with border-image.  Would be great to use border-image as a mask.
      GraphicsContext&amp; context = info.context();
      if (context.paintingDisabled() || !style.boxShadow())
          return;
  
<span class="line-modified">!     RoundedRect border = (shadowStyle == ShadowStyle::Inset) ? style.getRoundedInnerBorderFor(paintRect, includeLogicalLeftEdge, includeLogicalRightEdge)</span>
          : style.getRoundedBorderFor(paintRect, includeLogicalLeftEdge, includeLogicalRightEdge);
  
      bool hasBorderRadius = style.hasBorderRadius();
      bool isHorizontal = style.isHorizontalWritingMode();
      float deviceScaleFactor = document().deviceScaleFactor();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2348,57 ***</span>
      bool hasOpaqueBackground = style.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor).isOpaque();
      for (const ShadowData* shadow = style.boxShadow(); shadow; shadow = shadow-&gt;next()) {
          if (shadow-&gt;style() != shadowStyle)
              continue;
  
<span class="line-modified">!         // FIXME: Add subpixel support for the shadow values. Soon after the shadow offset becomes fractional,</span>
<span class="line-modified">!         // all the early snappings here need to be pushed to the actual painting operations.</span>
<span class="line-modified">!         IntSize shadowOffset(shadow-&gt;x(), shadow-&gt;y());</span>
          int shadowRadius = shadow-&gt;radius();
<span class="line-removed">-         int shadowPaintingExtent = shadow-&gt;paintingExtent();</span>
<span class="line-removed">-         int shadowSpread = shadow-&gt;spread();</span>
  
          if (shadowOffset.isZero() &amp;&amp; !shadowRadius &amp;&amp; !shadowSpread)
              continue;
  
          Color shadowColor = style.colorByApplyingColorFilter(shadow-&gt;color());
  
<span class="line-modified">!         if (shadow-&gt;style() == Normal) {</span>
              RoundedRect fillRect = border;
              fillRect.inflate(shadowSpread);
              if (fillRect.isEmpty())
                  continue;
  
<span class="line-modified">!             FloatRect pixelSnappedShadowRect = snapRectToDevicePixels(border.rect(), deviceScaleFactor);</span>
<span class="line-modified">!             pixelSnappedShadowRect.inflate(shadowPaintingExtent + shadowSpread);</span>
<span class="line-modified">!             pixelSnappedShadowRect.move(shadowOffset);</span>
  
              GraphicsContextStateSaver stateSaver(context);
              context.clip(pixelSnappedShadowRect);
  
<span class="line-modified">!             // Move the fill just outside the clip, adding 1 pixel separation so that the fill does not</span>
              // bleed in (due to antialiasing) if the context is transformed.
<span class="line-modified">!             IntSize extraOffset(roundToInt(paintRect.width()) + std::max(0, shadowOffset.width()) + shadowPaintingExtent + 2 * shadowSpread + 1, 0);</span>
              shadowOffset -= extraOffset;
              fillRect.move(extraOffset);
  
              if (shadow-&gt;isWebkitBoxShadow())
<span class="line-modified">!                 context.setLegacyShadow(shadowOffset, shadowRadius, shadowColor);</span>
              else
<span class="line-modified">!                 context.setShadow(shadowOffset, shadowRadius, shadowColor);</span>
  
<span class="line-removed">-             FloatRoundedRect rectToClipOut = border.pixelSnappedRoundedRectForPainting(deviceScaleFactor);</span>
<span class="line-removed">-             FloatRoundedRect pixelSnappedFillRect = fillRect.pixelSnappedRoundedRectForPainting(deviceScaleFactor);</span>
              if (hasBorderRadius) {
                  // If the box is opaque, it is unnecessary to clip it out. However, doing so saves time
                  // when painting the shadow. On the other hand, it introduces subpixel gaps along the
                  // corners. Those are avoided by insetting the clipping path by one pixel.
                  if (hasOpaqueBackground)
<span class="line-modified">!                     rectToClipOut.inflateWithRadii(-1.0f);</span>
  
<span class="line-modified">!                 if (!rectToClipOut.isEmpty())</span>
<span class="line-modified">!                     context.clipOutRoundedRect(rectToClipOut);</span>
  
                  RoundedRect influenceRect(LayoutRect(pixelSnappedShadowRect), border.radii());
                  influenceRect.expandRadii(2 * shadowPaintingExtent + shadowSpread);
  
                  if (allCornersClippedOut(influenceRect, info.rect))
<span class="line-new-header">--- 2353,62 ---</span>
      bool hasOpaqueBackground = style.visitedDependentColorWithColorFilter(CSSPropertyBackgroundColor).isOpaque();
      for (const ShadowData* shadow = style.boxShadow(); shadow; shadow = shadow-&gt;next()) {
          if (shadow-&gt;style() != shadowStyle)
              continue;
  
<span class="line-modified">!         LayoutSize shadowOffset(shadow-&gt;x(), shadow-&gt;y());</span>
<span class="line-modified">!         LayoutUnit shadowPaintingExtent = shadow-&gt;paintingExtent();</span>
<span class="line-modified">!         LayoutUnit shadowSpread = shadow-&gt;spread();</span>
          int shadowRadius = shadow-&gt;radius();
  
          if (shadowOffset.isZero() &amp;&amp; !shadowRadius &amp;&amp; !shadowSpread)
              continue;
  
          Color shadowColor = style.colorByApplyingColorFilter(shadow-&gt;color());
  
<span class="line-modified">!         if (shadow-&gt;style() == ShadowStyle::Normal) {</span>
              RoundedRect fillRect = border;
              fillRect.inflate(shadowSpread);
              if (fillRect.isEmpty())
                  continue;
  
<span class="line-modified">!             LayoutRect shadowRect = border.rect();</span>
<span class="line-modified">!             shadowRect.inflate(shadowPaintingExtent + shadowSpread);</span>
<span class="line-modified">!             shadowRect.move(shadowOffset);</span>
<span class="line-added">+             FloatRect pixelSnappedShadowRect = snapRectToDevicePixels(shadowRect, deviceScaleFactor);</span>
  
              GraphicsContextStateSaver stateSaver(context);
              context.clip(pixelSnappedShadowRect);
  
<span class="line-modified">!             // Move the fill just outside the clip, adding at least 1 pixel of separation so that the fill does not</span>
              // bleed in (due to antialiasing) if the context is transformed.
<span class="line-modified">!             LayoutUnit xOffset = paintRect.width() + std::max&lt;LayoutUnit&gt;(0, shadowOffset.width()) + shadowPaintingExtent + 2 * shadowSpread + LayoutUnit(1);</span>
<span class="line-added">+             LayoutSize extraOffset(xOffset.ceil(), 0);</span>
              shadowOffset -= extraOffset;
              fillRect.move(extraOffset);
  
<span class="line-added">+             FloatRoundedRect pixelSnappedRectToClipOut = border.pixelSnappedRoundedRectForPainting(deviceScaleFactor);</span>
<span class="line-added">+             FloatRoundedRect pixelSnappedFillRect = fillRect.pixelSnappedRoundedRectForPainting(deviceScaleFactor);</span>
<span class="line-added">+ </span>
<span class="line-added">+             LayoutPoint shadowRectOrigin = fillRect.rect().location() + shadowOffset;</span>
<span class="line-added">+             FloatPoint snappedShadowOrigin = FloatPoint(roundToDevicePixel(shadowRectOrigin.x(), deviceScaleFactor), roundToDevicePixel(shadowRectOrigin.y(), deviceScaleFactor));</span>
<span class="line-added">+             FloatSize snappedShadowOffset = snappedShadowOrigin - pixelSnappedFillRect.rect().location();</span>
<span class="line-added">+ </span>
              if (shadow-&gt;isWebkitBoxShadow())
<span class="line-modified">!                 context.setLegacyShadow(snappedShadowOffset, shadowRadius, shadowColor);</span>
              else
<span class="line-modified">!                 context.setShadow(snappedShadowOffset, shadowRadius, shadowColor);</span>
  
              if (hasBorderRadius) {
                  // If the box is opaque, it is unnecessary to clip it out. However, doing so saves time
                  // when painting the shadow. On the other hand, it introduces subpixel gaps along the
                  // corners. Those are avoided by insetting the clipping path by one pixel.
                  if (hasOpaqueBackground)
<span class="line-modified">!                     pixelSnappedRectToClipOut.inflateWithRadii(-1.0f);</span>
  
<span class="line-modified">!                 if (!pixelSnappedRectToClipOut.isEmpty())</span>
<span class="line-modified">!                     context.clipOutRoundedRect(pixelSnappedRectToClipOut);</span>
  
                  RoundedRect influenceRect(LayoutRect(pixelSnappedShadowRect), border.radii());
                  influenceRect.expandRadii(2 * shadowPaintingExtent + shadowSpread);
  
                  if (allCornersClippedOut(influenceRect, info.rect))
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2417,22 ***</span>
                  if (hasOpaqueBackground) {
                      // FIXME: The function to decide on the policy based on the transform should be a named function.
                      // FIXME: It&#39;s not clear if this check is right. What about integral scale factors?
                      AffineTransform transform = context.getCTM();
                      if (transform.a() != 1 || (transform.d() != 1 &amp;&amp; transform.d() != -1) || transform.b() || transform.c())
<span class="line-modified">!                         rectToClipOut.inflate(-1.0f);</span>
                  }
  
<span class="line-modified">!                 if (!rectToClipOut.isEmpty())</span>
<span class="line-modified">!                     context.clipOut(rectToClipOut.rect());</span>
                  context.fillRect(pixelSnappedFillRect.rect(), Color::black);
              }
          } else {
              // Inset shadow.
              FloatRoundedRect pixelSnappedBorderRect = border.pixelSnappedRoundedRectForPainting(deviceScaleFactor);
<span class="line-removed">-             FloatRect pixelSnappedHoleRect = pixelSnappedBorderRect.rect();</span>
<span class="line-removed">-             pixelSnappedHoleRect.inflate(-shadowSpread);</span>
  
              if (pixelSnappedHoleRect.isEmpty()) {
                  if (hasBorderRadius)
                      context.fillRoundedRect(pixelSnappedBorderRect, shadowColor);
                  else
<span class="line-new-header">--- 2427,24 ---</span>
                  if (hasOpaqueBackground) {
                      // FIXME: The function to decide on the policy based on the transform should be a named function.
                      // FIXME: It&#39;s not clear if this check is right. What about integral scale factors?
                      AffineTransform transform = context.getCTM();
                      if (transform.a() != 1 || (transform.d() != 1 &amp;&amp; transform.d() != -1) || transform.b() || transform.c())
<span class="line-modified">!                         pixelSnappedRectToClipOut.inflate(-1.0f);</span>
                  }
  
<span class="line-modified">!                 if (!pixelSnappedRectToClipOut.isEmpty())</span>
<span class="line-modified">!                     context.clipOut(pixelSnappedRectToClipOut.rect());</span>
<span class="line-added">+ </span>
                  context.fillRect(pixelSnappedFillRect.rect(), Color::black);
              }
          } else {
              // Inset shadow.
<span class="line-added">+             LayoutRect holeRect = border.rect();</span>
<span class="line-added">+             holeRect.inflate(-shadowSpread);</span>
<span class="line-added">+             FloatRect pixelSnappedHoleRect = snapRectToDevicePixels(holeRect, deviceScaleFactor);</span>
              FloatRoundedRect pixelSnappedBorderRect = border.pixelSnappedRoundedRectForPainting(deviceScaleFactor);
  
              if (pixelSnappedHoleRect.isEmpty()) {
                  if (hasBorderRadius)
                      context.fillRoundedRect(pixelSnappedBorderRect, shadowColor);
                  else
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2440,46 ***</span>
                  continue;
              }
  
              if (!includeLogicalLeftEdge) {
                  if (isHorizontal) {
<span class="line-modified">!                     pixelSnappedHoleRect.move(-std::max(shadowOffset.width(), 0) - shadowPaintingExtent, 0);</span>
<span class="line-modified">!                     pixelSnappedHoleRect.setWidth(pixelSnappedHoleRect.width() + std::max(shadowOffset.width(), 0) + shadowPaintingExtent);</span>
                  } else {
<span class="line-modified">!                     pixelSnappedHoleRect.move(0, -std::max(shadowOffset.height(), 0) - shadowPaintingExtent);</span>
<span class="line-modified">!                     pixelSnappedHoleRect.setHeight(pixelSnappedHoleRect.height() + std::max(shadowOffset.height(), 0) + shadowPaintingExtent);</span>
                  }
              }
              if (!includeLogicalRightEdge) {
                  if (isHorizontal)
<span class="line-modified">!                     pixelSnappedHoleRect.setWidth(pixelSnappedHoleRect.width() - std::min(shadowOffset.width(), 0) + shadowPaintingExtent);</span>
                  else
<span class="line-modified">!                     pixelSnappedHoleRect.setHeight(pixelSnappedHoleRect.height() - std::min(shadowOffset.height(), 0) + shadowPaintingExtent);</span>
              }
  
              Color fillColor(shadowColor.red(), shadowColor.green(), shadowColor.blue(), 255);
  
<span class="line-modified">!             FloatRect pixelSnappedOuterRect = snapRectToDevicePixels(areaCastingShadowInHole(LayoutRect(pixelSnappedBorderRect.rect()), shadowPaintingExtent, shadowSpread, shadowOffset), deviceScaleFactor);</span>
<span class="line-modified">!             FloatRoundedRect pixelSnappedRoundedHole = FloatRoundedRect(pixelSnappedHoleRect, pixelSnappedBorderRect.radii());</span>
  
              GraphicsContextStateSaver stateSaver(context);
              if (hasBorderRadius) {
                  context.clipRoundedRect(pixelSnappedBorderRect);
                  pixelSnappedRoundedHole.shrinkRadii(shadowSpread);
              } else
                  context.clip(pixelSnappedBorderRect.rect());
  
<span class="line-modified">!             IntSize extraOffset(2 * roundToInt(paintRect.width()) + std::max(0, shadowOffset.width()) + shadowPaintingExtent - 2 * shadowSpread + 1, 0);</span>
              context.translate(extraOffset);
              shadowOffset -= extraOffset;
  
              if (shadow-&gt;isWebkitBoxShadow())
                  context.setLegacyShadow(shadowOffset, shadowRadius, shadowColor);
              else
                  context.setShadow(shadowOffset, shadowRadius, shadowColor);
  
<span class="line-modified">!             context.fillRectWithRoundedHole(pixelSnappedOuterRect, pixelSnappedRoundedHole, fillColor);</span>
          }
      }
  }
  
  LayoutUnit RenderBoxModelObject::containingBlockLogicalWidthForContent() const
<span class="line-new-header">--- 2452,55 ---</span>
                  continue;
              }
  
              if (!includeLogicalLeftEdge) {
                  if (isHorizontal) {
<span class="line-modified">!                     holeRect.move(-std::max&lt;LayoutUnit&gt;(shadowOffset.width(), 0) - shadowPaintingExtent, 0);</span>
<span class="line-modified">!                     holeRect.setWidth(holeRect.width() + std::max&lt;LayoutUnit&gt;(shadowOffset.width(), 0) + shadowPaintingExtent);</span>
                  } else {
<span class="line-modified">!                     holeRect.move(0, -std::max&lt;LayoutUnit&gt;(shadowOffset.height(), 0) - shadowPaintingExtent);</span>
<span class="line-modified">!                     holeRect.setHeight(holeRect.height() + std::max&lt;LayoutUnit&gt;(shadowOffset.height(), 0) + shadowPaintingExtent);</span>
                  }
              }
<span class="line-added">+ </span>
              if (!includeLogicalRightEdge) {
                  if (isHorizontal)
<span class="line-modified">!                     holeRect.setWidth(holeRect.width() - std::min&lt;LayoutUnit&gt;(shadowOffset.width(), 0) + shadowPaintingExtent);</span>
                  else
<span class="line-modified">!                     holeRect.setHeight(holeRect.height() - std::min&lt;LayoutUnit&gt;(shadowOffset.height(), 0) + shadowPaintingExtent);</span>
              }
  
<span class="line-added">+             if (!includeLogicalLeftEdge || !includeLogicalRightEdge)</span>
<span class="line-added">+                 pixelSnappedHoleRect = snapRectToDevicePixels(holeRect, deviceScaleFactor);</span>
<span class="line-added">+ </span>
              Color fillColor(shadowColor.red(), shadowColor.green(), shadowColor.blue(), 255);
  
<span class="line-modified">!             LayoutRect shadowCastingRect = areaCastingShadowInHole(border.rect(), shadowPaintingExtent, shadowSpread, shadowOffset);</span>
<span class="line-modified">!             RoundedRect roundedHoleRect(holeRect, border.radii());</span>
<span class="line-added">+ </span>
<span class="line-added">+             FloatRect pixelSnappedOuterRect = snapRectToDevicePixels(shadowCastingRect, deviceScaleFactor);</span>
<span class="line-added">+             FloatRoundedRect pixelSnappedRoundedHole = roundedHoleRect.pixelSnappedRoundedRectForPainting(deviceScaleFactor);</span>
  
              GraphicsContextStateSaver stateSaver(context);
              if (hasBorderRadius) {
                  context.clipRoundedRect(pixelSnappedBorderRect);
                  pixelSnappedRoundedHole.shrinkRadii(shadowSpread);
              } else
                  context.clip(pixelSnappedBorderRect.rect());
  
<span class="line-modified">!             LayoutUnit xOffset = 2 * paintRect.width() + std::max&lt;LayoutUnit&gt;(0, shadowOffset.width()) + shadowPaintingExtent + 2 * shadowSpread + LayoutUnit(1);</span>
<span class="line-added">+             LayoutSize extraOffset(xOffset.ceil(), 0);</span>
<span class="line-added">+ </span>
              context.translate(extraOffset);
              shadowOffset -= extraOffset;
  
              if (shadow-&gt;isWebkitBoxShadow())
                  context.setLegacyShadow(shadowOffset, shadowRadius, shadowColor);
              else
                  context.setShadow(shadowOffset, shadowRadius, shadowColor);
  
<span class="line-modified">!             context.fillRectWithRoundedHole(enclosingIntRect(pixelSnappedOuterRect), pixelSnappedRoundedHole, fillColor); // todo tav IntRect is required as first param</span>
          }
      }
  }
  
  LayoutUnit RenderBoxModelObject::containingBlockLogicalWidthForContent() const
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2672,6 ***</span>
<span class="line-new-header">--- 2693,23 ---</span>
              return timeline-&gt;runningAnimationsForElementAreAllAccelerated(*node);
      }
      return false;
  }
  
<span class="line-added">+ void RenderBoxModelObject::collectAbsoluteQuadsForContinuation(Vector&lt;FloatQuad&gt;&amp; quads, bool* wasFixed) const</span>
<span class="line-added">+ {</span>
<span class="line-added">+     ASSERT(continuation());</span>
<span class="line-added">+     for (auto* nextInContinuation = this-&gt;continuation(); nextInContinuation; nextInContinuation = nextInContinuation-&gt;continuation()) {</span>
<span class="line-added">+         if (is&lt;RenderBlock&gt;(*nextInContinuation)) {</span>
<span class="line-added">+             auto&amp; blockBox = downcast&lt;RenderBlock&gt;(*nextInContinuation);</span>
<span class="line-added">+             // For blocks inside inlines, we include margins so that we run right up to the inline boxes</span>
<span class="line-added">+             // above and below us (thus getting merged with them to form a single irregular shape).</span>
<span class="line-added">+             auto logicalRect = FloatRect { 0, -blockBox.collapsedMarginBefore(), blockBox.width(),</span>
<span class="line-added">+                 blockBox.height() + blockBox.collapsedMarginBefore() + blockBox.collapsedMarginAfter() };</span>
<span class="line-added">+             nextInContinuation-&gt;absoluteQuadsIgnoringContinuation(logicalRect, quads, wasFixed);</span>
<span class="line-added">+             continue;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         nextInContinuation-&gt;absoluteQuadsIgnoringContinuation({ }, quads, wasFixed);</span>
<span class="line-added">+     }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  } // namespace WebCore
</pre>
<center><a href="RenderBox.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderBoxModelObject.h.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
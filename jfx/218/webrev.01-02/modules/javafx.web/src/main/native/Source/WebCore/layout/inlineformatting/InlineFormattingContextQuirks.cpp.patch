diff a/modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContextQuirks.cpp b/modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContextQuirks.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContextQuirks.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/layout/inlineformatting/InlineFormattingContextQuirks.cpp
@@ -26,81 +26,71 @@
 #include "config.h"
 #include "InlineFormattingContext.h"
 
 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 
-#include "InlineItem.h"
-#include "InlineLine.h"
-#include "InlineTextItem.h"
+#include "InlineLineBuilder.h"
 #include "LayoutState.h"
 
 namespace WebCore {
 namespace Layout {
 
-bool InlineFormattingContext::Quirks::lineDescentNeedsCollapsing(const LayoutState& layoutState, const Line::Content& lineContent)
+bool InlineFormattingContext::Quirks::lineDescentNeedsCollapsing(const LineBuilder::RunList& runList) const
 {
     // Collapse line descent in limited and full quirk mode when there's no baseline aligned content or
     // the baseline aligned content has no descent.
+    auto& layoutState = this->layoutState();
     if (!layoutState.inQuirksMode() && !layoutState.inLimitedQuirksMode())
         return false;
 
-    for (auto& run : lineContent.runs()) {
-        auto& layoutBox = run->layoutBox();
-        if (layoutBox.style().verticalAlign() != VerticalAlign::Baseline)
+    for (auto& run : runList) {
+        auto& layoutBox = run.layoutBox();
+        if (run.isContainerEnd() || layoutBox.style().verticalAlign() != VerticalAlign::Baseline)
             continue;
 
-        switch (run->type()) {
-        case InlineItem::Type::Text:
-            if (!run->textContext() || !run->textContext()->isCollapsed)
-                return false;
-            break;
-        case InlineItem::Type::HardLineBreak:
+        if (run.isLineBreak())
+            return false;
+        if (run.isText())
             return false;
-        case InlineItem::Type::ContainerStart: {
-            auto& displayBox = layoutState.displayBoxForLayoutBox(layoutBox);
-            if (displayBox.horizontalBorder() || (displayBox.horizontalPadding() && displayBox.horizontalPadding().value()))
+        if (run.isContainerStart()) {
+            auto& boxGeometry = formattingContext().geometryForBox(layoutBox);
+            if (boxGeometry.horizontalBorder() || (boxGeometry.horizontalPadding() && boxGeometry.horizontalPadding().value()))
                 return false;
-            break;
+            continue;
         }
-        case InlineItem::Type::ContainerEnd:
-            break;
-        case InlineItem::Type::Box: {
+        if (run.isBox()) {
             if (layoutBox.isInlineBlockBox() && layoutBox.establishesInlineFormattingContext()) {
-                auto& formattingState = downcast<InlineFormattingState>(layoutState.establishedFormattingState(layoutBox));
-                ASSERT(!formattingState.lineBoxes().isEmpty());
-                auto inlineBlockBaseline = formattingState.lineBoxes().last().baseline();
-                if (inlineBlockBaseline.descent)
+                auto& formattingState = layoutState.establishedInlineFormattingState(downcast<Container>(layoutBox));
+                auto inlineBlockBaseline = formattingState.displayInlineContent()->lineBoxes.last().baseline();
+                if (inlineBlockBaseline.descent())
                     return false;
             }
-            break;
-        }
-        default:
-            ASSERT_NOT_REACHED();
-            break;
+            continue;
         }
+        ASSERT_NOT_REACHED();
     }
     return true;
 }
 
-Line::InitialConstraints::HeightAndBaseline InlineFormattingContext::Quirks::lineHeightConstraints(const LayoutState& layoutState, const Box& formattingRoot)
+LineBuilder::Constraints::HeightAndBaseline InlineFormattingContext::Quirks::lineHeightConstraints(const Container& formattingRoot) const
 {
     // computedLineHeight takes font-size into account when line-height is not set.
     // Strut is the imaginary box that we put on every line. It sets the initial vertical constraints for each new line.
-    auto strutHeight = formattingRoot.style().computedLineHeight();
-    auto strutBaselineOffset = Line::halfLeadingMetrics(formattingRoot.style().fontMetrics(), strutHeight).ascent;
-    if (layoutState.inNoQuirksMode())
+    InlineLayoutUnit strutHeight = formattingRoot.style().computedLineHeight();
+    auto strutBaselineOffset = LineBuilder::halfLeadingMetrics(formattingRoot.style().fontMetrics(), strutHeight).ascent();
+    if (layoutState().inNoQuirksMode())
         return { strutHeight, strutBaselineOffset, { } };
 
     auto lineHeight = formattingRoot.style().lineHeight();
     if (lineHeight.isPercentOrCalculated()) {
-        auto initialBaselineOffset = Line::halfLeadingMetrics(formattingRoot.style().fontMetrics(), { }).ascent;
-        return { initialBaselineOffset, initialBaselineOffset, LineBox::Baseline { strutBaselineOffset, strutHeight - strutBaselineOffset } };
+        auto initialBaselineOffset = LineBuilder::halfLeadingMetrics(formattingRoot.style().fontMetrics(), 0_lu).ascent();
+        return { initialBaselineOffset, initialBaselineOffset, LineBoxBuilder::Baseline { strutBaselineOffset, strutHeight - strutBaselineOffset } };
     }
     // FIXME: The only reason why we use intValue() here is to match current inline tree (integral)behavior.
-    auto initialLineHeight = LayoutUnit { lineHeight.intValue() };
-    auto initialBaselineOffset = Line::halfLeadingMetrics(formattingRoot.style().fontMetrics(), initialLineHeight).ascent;
-    return { initialLineHeight, initialBaselineOffset, LineBox::Baseline { strutBaselineOffset, strutHeight - strutBaselineOffset } };
+    InlineLayoutUnit initialLineHeight = lineHeight.intValue();
+    auto initialBaselineOffset = LineBuilder::halfLeadingMetrics(formattingRoot.style().fontMetrics(), initialLineHeight).ascent();
+    return { initialLineHeight, initialBaselineOffset, LineBoxBuilder::Baseline { strutBaselineOffset, strutHeight - strutBaselineOffset } };
 }
 
 }
 }
 

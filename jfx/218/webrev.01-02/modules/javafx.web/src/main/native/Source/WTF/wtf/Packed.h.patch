diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/Packed.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/Packed.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/Packed.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/Packed.h
@@ -24,10 +24,13 @@
  */
 
 #pragma once
 
 #include <array>
+#include <wtf/Forward.h>
+#include <wtf/GetPtr.h>
+#include <wtf/HashFunctions.h>
 #include <wtf/MathExtras.h>
 #include <wtf/StdLibExtras.h>
 #include <wtf/UnalignedAccess.h>
 
 namespace WTF {
@@ -98,19 +101,20 @@
 };
 
 // PackedAlignedPtr can take alignment parameter too. PackedAlignedPtr only uses this alignment information if it is profitable: we use
 // alignment information only when we can reduce the size of the storage. Since the pointer width is 36 bits and JSCells are aligned to 16 bytes,
 // we can use 4 bits in Darwin ARM64, we can compact cell pointer into 4 bytes (32 bits).
-template<typename T, size_t alignment = alignof(T)>
+template<typename T, size_t passedAlignment>
 class PackedAlignedPtr {
     WTF_MAKE_FAST_ALLOCATED;
 public:
-    static_assert(hasOneBitSet(alignment), "Alignment needs to be power-of-two");
+    static_assert(hasOneBitSet(passedAlignment), "Alignment needs to be power-of-two");
+    static constexpr size_t alignment = passedAlignment;
     static constexpr bool isPackedType = true;
     static constexpr unsigned alignmentShiftSizeIfProfitable = getLSBSetConstexpr(alignment);
-    static constexpr unsigned storageSizeWithoutAlignmentShift = roundUpToMultipleOf<8>(WTF_CPU_EFFECTIVE_ADDRESS_WIDTH) / 8;
-    static constexpr unsigned storageSizeWithAlignmentShift = roundUpToMultipleOf<8>(WTF_CPU_EFFECTIVE_ADDRESS_WIDTH - alignmentShiftSizeIfProfitable) / 8;
+    static constexpr unsigned storageSizeWithoutAlignmentShift = roundUpToMultipleOf<8>(OS_CONSTANT(EFFECTIVE_ADDRESS_WIDTH)) / 8;
+    static constexpr unsigned storageSizeWithAlignmentShift = roundUpToMultipleOf<8>(OS_CONSTANT(EFFECTIVE_ADDRESS_WIDTH) - alignmentShiftSizeIfProfitable) / 8;
     static constexpr bool isAlignmentShiftProfitable = storageSizeWithoutAlignmentShift > storageSizeWithAlignmentShift;
     static constexpr unsigned alignmentShiftSize = isAlignmentShiftProfitable ? alignmentShiftSizeIfProfitable : 0;
     static constexpr unsigned storageSize = storageSizeWithAlignmentShift;
 
     constexpr PackedAlignedPtr()
@@ -161,22 +165,26 @@
     }
 
     T* operator->() const { return get(); }
     T& operator*() const { return *get(); }
     bool operator!() const { return !get(); }
+
+    // This conversion operator allows implicit conversion to bool but not to other integer types.
+    typedef T* (PackedAlignedPtr::*UnspecifiedBoolType);
+    operator UnspecifiedBoolType() const { return get() ? &PackedAlignedPtr::m_storage : nullptr; }
     explicit operator bool() const { return get(); }
 
     PackedAlignedPtr& operator=(T* value)
     {
         set(value);
         return *this;
     }
 
     template<class U>
-    T exchange(U&& newValue)
+    T* exchange(U&& newValue)
     {
-        T oldValue = get();
+        T* oldValue = get();
         set(std::forward<U>(newValue));
         return oldValue;
     }
 
     void swap(std::nullptr_t) { clear(); }
@@ -187,19 +195,19 @@
     }
 
     template<typename Other, typename = std::enable_if_t<Other::isPackedType>>
     void swap(Other& other)
     {
-        T t1 = get();
-        T t2 = other.get();
+        T* t1 = get();
+        T* t2 = other.get();
         set(t2);
         other.set(t1);
     }
 
-    void swap(T& t2)
+    void swap(T* t2)
     {
-        T t1 = get();
+        T* t1 = get();
         std::swap(t1, t2);
         set(t1);
     }
 
 private:
@@ -209,15 +217,30 @@
 template<typename T>
 class Packed<T*> : public PackedAlignedPtr<T, 1> {
 public:
     using Base = PackedAlignedPtr<T, 1>;
     using Base::Base;
+
+    // Hash table deleted values, which are only constructed and never copied or destroyed.
+    Packed(HashTableDeletedValueType) : Base(bitwise_cast<T*>(static_cast<uintptr_t>(Base::alignment))) { }
+    bool isHashTableDeletedValue() const { return Base::get() == bitwise_cast<T*>(static_cast<uintptr_t>(Base::alignment)); }
 };
 
 template<typename T>
 using PackedPtr = Packed<T*>;
 
+template <typename T>
+struct GetPtrHelper<PackedPtr<T>> {
+    using PtrType = T*;
+    static T* getPtr(const PackedPtr<T>& p) { return const_cast<T*>(p.get()); }
+};
+
+template <typename T>
+struct IsSmartPtr<PackedPtr<T>> {
+    static constexpr bool value = true;
+};
+
 template<typename T>
 struct PackedPtrTraits {
     template<typename U> using RebindTraits = PackedPtrTraits<U>;
 
     using StorageType = PackedPtr<T>;
@@ -225,12 +248,20 @@
     template<class U> static ALWAYS_INLINE T* exchange(StorageType& ptr, U&& newValue) { return ptr.exchange(newValue); }
 
     template<typename Other> static ALWAYS_INLINE void swap(PackedPtr<T>& a, Other& b) { a.swap(b); }
 
     static ALWAYS_INLINE T* unwrap(const StorageType& ptr) { return ptr.get(); }
+
+    // We assume that,
+    // 1. The alignment is < 4KB. (It is tested by HashTraits).
+    // 2. The first page (including nullptr) is never mapped.
+    static StorageType hashTableDeletedValue() { return StorageType { bitwise_cast<T*>(static_cast<uintptr_t>(StorageType::alignment)) }; }
+    static ALWAYS_INLINE bool isHashTableDeletedValue(const StorageType& ptr) { return ptr.get() == bitwise_cast<T*>(static_cast<uintptr_t>(StorageType::alignment)); }
 };
 
+template<typename P> struct DefaultHash<PackedPtr<P>> { using Hash = PtrHash<PackedPtr<P>>; };
+
 } // namespace WTF
 
 using WTF::Packed;
 using WTF::PackedAlignedPtr;
 using WTF::PackedPtr;

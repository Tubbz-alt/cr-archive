<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/workers/service/context/SWContextManager.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2017 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;SWContextManager.h&quot;
 28 
 29 #if ENABLE(SERVICE_WORKER)
 30 #include &quot;Logging.h&quot;
 31 #include &quot;MessageWithMessagePorts.h&quot;
 32 #include &quot;ServiceWorkerClientIdentifier.h&quot;
 33 #include &quot;ServiceWorkerGlobalScope.h&quot;
 34 
 35 namespace WebCore {
 36 
 37 SWContextManager&amp; SWContextManager::singleton()
 38 {
 39     static SWContextManager* sharedManager = new SWContextManager;
 40     return *sharedManager;
 41 }
 42 
 43 void SWContextManager::setConnection(std::unique_ptr&lt;Connection&gt;&amp;&amp; connection)
 44 {
 45     ASSERT(!m_connection || m_connection-&gt;isClosed());
 46     m_connection = WTFMove(connection);
 47 }
 48 
 49 auto SWContextManager::connection() const -&gt; Connection*
 50 {
 51     return m_connection.get();
 52 }
 53 
 54 void SWContextManager::registerServiceWorkerThreadForInstall(Ref&lt;ServiceWorkerThreadProxy&gt;&amp;&amp; serviceWorkerThreadProxy)
 55 {
 56     auto serviceWorkerIdentifier = serviceWorkerThreadProxy-&gt;identifier();
 57     auto jobDataIdentifier = serviceWorkerThreadProxy-&gt;thread().contextData().jobDataIdentifier;
 58     auto* threadProxy = serviceWorkerThreadProxy.ptr();
 59     auto result = m_workerMap.add(serviceWorkerIdentifier, WTFMove(serviceWorkerThreadProxy));
 60     ASSERT_UNUSED(result, result.isNewEntry);
 61 
 62     threadProxy-&gt;thread().start([jobDataIdentifier, serviceWorkerIdentifier](const String&amp; exceptionMessage, bool doesHandleFetch) {
 63         SWContextManager::singleton().startedServiceWorker(jobDataIdentifier, serviceWorkerIdentifier, exceptionMessage, doesHandleFetch);
 64     });
 65 }
 66 
 67 void SWContextManager::startedServiceWorker(Optional&lt;ServiceWorkerJobDataIdentifier&gt; jobDataIdentifier, ServiceWorkerIdentifier serviceWorkerIdentifier, const String&amp; exceptionMessage, bool doesHandleFetch)
 68 {
 69     if (m_serviceWorkerCreationCallback)
 70         m_serviceWorkerCreationCallback(serviceWorkerIdentifier.toUInt64());
 71     if (!exceptionMessage.isEmpty()) {
 72         connection()-&gt;serviceWorkerFailedToStart(jobDataIdentifier, serviceWorkerIdentifier, exceptionMessage);
 73         return;
 74     }
 75     connection()-&gt;serviceWorkerStarted(jobDataIdentifier, serviceWorkerIdentifier, doesHandleFetch);
 76 }
 77 
 78 ServiceWorkerThreadProxy* SWContextManager::serviceWorkerThreadProxy(ServiceWorkerIdentifier identifier) const
 79 {
 80     return m_workerMap.get(identifier);
 81 }
 82 
 83 void SWContextManager::postMessageToServiceWorker(ServiceWorkerIdentifier destination, MessageWithMessagePorts&amp;&amp; message, ServiceWorkerOrClientData&amp;&amp; sourceData)
 84 {
 85     auto* serviceWorker = m_workerMap.get(destination);
 86     ASSERT(serviceWorker);
 87     ASSERT(!serviceWorker-&gt;isTerminatingOrTerminated());
 88 
 89     // FIXME: We should pass valid MessagePortChannels.
 90     serviceWorker-&gt;postMessageToServiceWorker(WTFMove(message), WTFMove(sourceData));
 91 }
 92 
 93 void SWContextManager::fireInstallEvent(ServiceWorkerIdentifier identifier)
 94 {
 95     auto* serviceWorker = m_workerMap.get(identifier);
 96     if (!serviceWorker)
 97         return;
 98 
 99     serviceWorker-&gt;fireInstallEvent();
100 }
101 
102 void SWContextManager::fireActivateEvent(ServiceWorkerIdentifier identifier)
103 {
104     auto* serviceWorker = m_workerMap.get(identifier);
105     if (!serviceWorker)
106         return;
107 
108     serviceWorker-&gt;fireActivateEvent();
109 }
110 
111 void SWContextManager::terminateWorker(ServiceWorkerIdentifier identifier, Seconds timeout, Function&lt;void()&gt;&amp;&amp; completionHandler)
112 {
113     auto serviceWorker = m_workerMap.take(identifier);
114     if (!serviceWorker) {
115         if (completionHandler)
116             completionHandler();
117         return;
118     }
119     stopWorker(*serviceWorker, timeout, WTFMove(completionHandler));
120 }
121 
122 void SWContextManager::stopWorker(ServiceWorkerThreadProxy&amp; serviceWorker, Seconds timeout, Function&lt;void()&gt;&amp;&amp; completionHandler)
123 {
124     auto identifier = serviceWorker.identifier();
125     serviceWorker.setAsTerminatingOrTerminated();
126 
127     m_pendingServiceWorkerTerminationRequests.add(identifier, makeUnique&lt;ServiceWorkerTerminationRequest&gt;(*this, identifier, timeout));
128 
129     auto&amp; thread = serviceWorker.thread();
130     thread.stop([this, identifier, serviceWorker = makeRef(serviceWorker), completionHandler = WTFMove(completionHandler)]() mutable {
131         m_pendingServiceWorkerTerminationRequests.remove(identifier);
132 
133         if (auto* connection = SWContextManager::singleton().connection())
134             connection-&gt;workerTerminated(identifier);
135 
136         if (completionHandler)
137             completionHandler();
138 
139         // Spin the runloop before releasing the worker thread proxy, as there would otherwise be
140         // a race towards its destruction.
141         callOnMainThread([serviceWorker = WTFMove(serviceWorker)] { });
142     });
143 }
144 
145 void SWContextManager::forEachServiceWorkerThread(const WTF::Function&lt;void(ServiceWorkerThreadProxy&amp;)&gt;&amp; apply)
146 {
147     for (auto&amp; workerThread : m_workerMap.values())
148         apply(workerThread);
149 }
150 
151 bool SWContextManager::postTaskToServiceWorker(ServiceWorkerIdentifier identifier, WTF::Function&lt;void(ServiceWorkerGlobalScope&amp;)&gt;&amp;&amp; task)
152 {
153     auto* serviceWorker = m_workerMap.get(identifier);
154     if (!serviceWorker)
155         return false;
156 
157     serviceWorker-&gt;thread().runLoop().postTask([task = WTFMove(task)] (auto&amp; context) {
158         task(downcast&lt;ServiceWorkerGlobalScope&gt;(context));
159     });
160     return true;
161 }
162 
163 void SWContextManager::serviceWorkerFailedToTerminate(ServiceWorkerIdentifier serviceWorkerIdentifier)
164 {
165     UNUSED_PARAM(serviceWorkerIdentifier);
166     RELEASE_LOG_ERROR(ServiceWorker, &quot;Failed to terminate service worker with identifier %s, killing the service worker process&quot;, serviceWorkerIdentifier.loggingString().utf8().data());
167     ASSERT_NOT_REACHED();
168     _exit(EXIT_FAILURE);
169 }
170 
171 SWContextManager::ServiceWorkerTerminationRequest::ServiceWorkerTerminationRequest(SWContextManager&amp; manager, ServiceWorkerIdentifier serviceWorkerIdentifier, Seconds timeout)
172     : m_timeoutTimer([&amp;manager, serviceWorkerIdentifier] { manager.serviceWorkerFailedToTerminate(serviceWorkerIdentifier); })
173 {
174     m_timeoutTimer.startOneShot(timeout);
175 }
176 
177 void SWContextManager::stopAllServiceWorkers()
178 {
179     auto serviceWorkers = WTFMove(m_workerMap);
180     for (auto&amp; serviceWorker : serviceWorkers.values())
181         stopWorker(serviceWorker, workerTerminationTimeout, [] { });
182 }
183 
184 } // namespace WebCore
185 
186 #endif
    </pre>
  </body>
</html>
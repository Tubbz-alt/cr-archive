<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/JavaScriptCore/generator/Opcode.rb</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Metadata.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Options.rb.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/JavaScriptCore/generator/Opcode.rb</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 22 # THE POSSIBILITY OF SUCH DAMAGE.
 23 
 24 require_relative &#39;Argument&#39;
 25 require_relative &#39;Fits&#39;
 26 require_relative &#39;Metadata&#39;
 27 
 28 class Opcode
 29     attr_reader :id
 30     attr_reader :args
 31     attr_reader :metadata


 32 
 33     module Size
 34         Narrow = &quot;OpcodeSize::Narrow&quot;
 35         Wide16 = &quot;OpcodeSize::Wide16&quot;
 36         Wide32 = &quot;OpcodeSize::Wide32&quot;
 37     end
 38 
 39     @@id = 0
 40 
 41     def self.id
 42         tid = @@id
 43         @@id = @@id + 1
 44         tid
 45     end
 46 
<span class="line-modified"> 47     def initialize(section, name, args, metadata, metadata_initializers)</span>
 48         @section = section
 49         @name = name

 50         @metadata = Metadata.new metadata, metadata_initializers
<span class="line-modified"> 51         @args = args.map.with_index { |(arg_name, type), index| Argument.new arg_name, type, index + 1 } unless args.nil?</span>


 52     end
 53 
 54     def create_id!
 55         @id = self.class.id
 56     end
 57 
 58     def print_args(&amp;block)
 59         return if @args.nil?
 60         @args.map(&amp;block).join &quot;\n&quot;
 61     end
 62 
 63     def print_members(prefix, &amp;block)
 64         return if @args.nil?
 65         @args.map(&amp;block).map { |arg| &quot;#{prefix}#{arg}&quot; }.join &quot;\n&quot;
 66     end
 67 
 68     def capitalized_name
 69         name.split(&#39;_&#39;).map(&amp;:capitalize).join
 70     end
 71 
 72     def typed_args
 73         return if @args.nil?
 74 
 75         @args.map(&amp;:create_param).unshift(&quot;&quot;).join(&quot;, &quot;)
 76     end
 77 
 78     def typed_reference_args
 79         return if @args.nil?
 80 
 81         @args.map(&amp;:create_reference_param).unshift(&quot;&quot;).join(&quot;, &quot;)
 82     end
 83 
 84     def untyped_args
 85         return if @args.nil?
 86 
 87         @args.map(&amp;:name).unshift(&quot;&quot;).join(&quot;, &quot;)
 88     end
 89 
















 90     def map_fields_with_size(prefix, size, &amp;block)
<span class="line-modified"> 91         args = [Argument.new(&quot;opcodeID&quot;, :OpcodeID, 0)]</span>









 92         args += @args.dup if @args
 93         unless @metadata.empty?
 94             args &lt;&lt; @metadata.emitter_local
 95         end
 96         args.map { |arg| &quot;#{prefix}#{block.call(arg, size)}&quot; }
 97     end
 98 
 99     def struct
100         &lt;&lt;-EOF
101 struct #{capitalized_name} : public Instruction {
102     #{opcodeID}


103 
104 #{emitter}
105 #{dumper}
106 #{constructors}
107 #{setters}#{metadata_struct_and_accessor}
108 #{members}
109 };
110 EOF
111     end
112 
113     def opcodeID
<span class="line-modified">114         &quot;static constexpr OpcodeID opcodeID = #{name};&quot;</span>












115     end
116 
117     def emitter
<span class="line-modified">118         op_wide16 = Argument.new(&quot;op_wide16&quot;, :OpcodeID, 0)</span>
<span class="line-modified">119         op_wide32 = Argument.new(&quot;op_wide32&quot;, :OpcodeID, 0)</span>
120         metadata_param = @metadata.empty? ? &quot;&quot; : &quot;, #{@metadata.emitter_local.create_param}&quot;
121         metadata_arg = @metadata.empty? ? &quot;&quot; : &quot;, #{@metadata.emitter_local.name}&quot;
122         &lt;&lt;-EOF.chomp

123     static void emit(BytecodeGenerator* gen#{typed_args})
124     {
<span class="line-modified">125         emitWithSmallestSizeRequirement&lt;OpcodeSize::Narrow&gt;(gen#{untyped_args});</span>
126     }
127 #{%{
<span class="line-modified">128     template&lt;OpcodeSize size, FitsAssertion shouldAssert = Assert&gt;</span>
129     static bool emit(BytecodeGenerator* gen#{typed_args})
130     {#{@metadata.create_emitter_local}
<span class="line-modified">131         return emit&lt;size, shouldAssert&gt;(gen#{untyped_args}#{metadata_arg});</span>
132     }
133 
<span class="line-modified">134     template&lt;OpcodeSize size&gt;</span>
135     static bool checkWithoutMetadataID(BytecodeGenerator* gen#{typed_args})
136     {
137         decltype(gen-&gt;addMetadataFor(opcodeID)) __metadataID { };
<span class="line-modified">138         return checkImpl&lt;size&gt;(gen#{untyped_args}#{metadata_arg});</span>
139     }
140 } unless @metadata.empty?}
<span class="line-modified">141     template&lt;OpcodeSize size, FitsAssertion shouldAssert = Assert, bool recordOpcode = true&gt;</span>
142     static bool emit(BytecodeGenerator* gen#{typed_args}#{metadata_param})
143     {
<span class="line-modified">144         bool didEmit = emitImpl&lt;size, recordOpcode&gt;(gen#{untyped_args}#{metadata_arg});</span>
145         if (shouldAssert == Assert)
146             ASSERT(didEmit);
147         return didEmit;
148     }
149 
<span class="line-modified">150     template&lt;OpcodeSize size&gt;</span>
151     static void emitWithSmallestSizeRequirement(BytecodeGenerator* gen#{typed_args})
152     {
153         #{@metadata.create_emitter_local}
<span class="line-modified">154         if (static_cast&lt;unsigned&gt;(size) &lt;= static_cast&lt;unsigned&gt;(OpcodeSize::Narrow)) {</span>
<span class="line-modified">155             if (emit&lt;OpcodeSize::Narrow, NoAssert, true&gt;(gen#{untyped_args}#{metadata_arg}))</span>
156                 return;
157         }
<span class="line-modified">158         if (static_cast&lt;unsigned&gt;(size) &lt;= static_cast&lt;unsigned&gt;(OpcodeSize::Wide16)) {</span>
<span class="line-modified">159             if (emit&lt;OpcodeSize::Wide16, NoAssert, true&gt;(gen#{untyped_args}#{metadata_arg}))</span>
160                 return;
161         }
<span class="line-modified">162         emit&lt;OpcodeSize::Wide32, Assert, true&gt;(gen#{untyped_args}#{metadata_arg});</span>
163     }
164 
165 private:
<span class="line-modified">166     template&lt;OpcodeSize size&gt;</span>
167     static bool checkImpl(BytecodeGenerator* gen#{typed_reference_args}#{metadata_param})
168     {
169         UNUSED_PARAM(gen);
170 #if OS(WINDOWS) &amp;&amp; ENABLE(C_LOOP)
171         // FIXME: Disable wide16 optimization for Windows CLoop
172         // https://bugs.webkit.org/show_bug.cgi?id=198283
<span class="line-modified">173         if (size == OpcodeSize::Wide16)</span>
174             return false;
175 #endif
<span class="line-modified">176         return #{map_fields_with_size(&quot;&quot;, &quot;size&quot;, &amp;:fits_check).join &quot;\n            &amp;&amp; &quot;}</span>
<span class="line-modified">177             &amp;&amp; (size == OpcodeSize::Wide16 ? #{op_wide16.fits_check(Size::Narrow)} : true)</span>
<span class="line-modified">178             &amp;&amp; (size == OpcodeSize::Wide32 ? #{op_wide32.fits_check(Size::Narrow)} : true);</span>
179     }
180 
<span class="line-modified">181     template&lt;OpcodeSize size, bool recordOpcode&gt;</span>
182     static bool emitImpl(BytecodeGenerator* gen#{typed_args}#{metadata_param})
183     {
<span class="line-modified">184         if (size == OpcodeSize::Wide16)</span>

185             gen-&gt;alignWideOpcode16();
<span class="line-modified">186         else if (size == OpcodeSize::Wide32)</span>
187             gen-&gt;alignWideOpcode32();
<span class="line-modified">188         if (checkImpl&lt;size&gt;(gen#{untyped_args}#{metadata_arg})) {</span>
189             if (recordOpcode)
190                 gen-&gt;recordOpcode(opcodeID);
<span class="line-modified">191             if (size == OpcodeSize::Wide16)</span>
192                 #{op_wide16.fits_write Size::Narrow}
<span class="line-modified">193             else if (size == OpcodeSize::Wide32)</span>
194                 #{op_wide32.fits_write Size::Narrow}
<span class="line-modified">195 #{map_fields_with_size(&quot;            &quot;, &quot;size&quot;, &amp;:fits_write).join &quot;\n&quot;}</span>

196             return true;
197         }
198         return false;
199     }
200 
201 public:
202 EOF
203     end
204 
205     def dumper
206         &lt;&lt;-EOF
<span class="line-modified">207     template&lt;typename Block&gt;</span>
<span class="line-removed">208     void dump(BytecodeDumper&lt;Block&gt;* dumper, InstructionStream::Offset __location, int __sizeShiftAmount)</span>
209     {
210         dumper-&gt;printLocationAndOp(__location, &amp;&quot;**#{@name}&quot;[2 - __sizeShiftAmount]);
211 #{print_args { |arg|
212 &lt;&lt;-EOF.chomp
<span class="line-modified">213         dumper-&gt;dumpOperand(#{arg.field_name}, #{arg.index == 1});</span>
214 EOF
215     }}
216     }
217 EOF
218     end
219 
220     def constructors
221         fields = (@args || []) + (@metadata.empty? ? [] : [@metadata])
<span class="line-modified">222         init = -&gt;(size) { fields.empty?  ? &quot;&quot; : &quot;: #{fields.map.with_index { |arg, i| arg.load_from_stream(i + 1, size) }.join &quot;\n        , &quot; }&quot; }</span>
223 
224         &lt;&lt;-EOF
225     #{capitalized_name}(const uint8_t* stream)
226         #{init.call(&quot;OpcodeSize::Narrow&quot;)}
227     {
<span class="line-modified">228         ASSERT_UNUSED(stream, stream[0] == opcodeID);</span>
229     }
230 
231     #{capitalized_name}(const uint16_t* stream)
232         #{init.call(&quot;OpcodeSize::Wide16&quot;)}
233     {
<span class="line-modified">234         ASSERT_UNUSED(stream, stream[0] == opcodeID);</span>
235     }
236 
237 
238     #{capitalized_name}(const uint32_t* stream)
239         #{init.call(&quot;OpcodeSize::Wide32&quot;)}
240     {
<span class="line-modified">241         ASSERT_UNUSED(stream, stream[0] == opcodeID);</span>
242     }
243 
244     static #{capitalized_name} decode(const uint8_t* stream)
245     {
<span class="line-modified">246         if (*stream == op_wide32) </span>
<span class="line-modified">247             return { bitwise_cast&lt;const uint32_t*&gt;(stream + 1) };</span>
<span class="line-modified">248         if (*stream == op_wide16) </span>
<span class="line-modified">249             return { bitwise_cast&lt;const uint16_t*&gt;(stream + 1) };</span>
<span class="line-modified">250         return { stream };</span>

251     }
252 EOF
253     end
254 
255     def setters
<span class="line-modified">256         print_args(&amp;:setter)</span>
257     end
258 
259     def metadata_struct_and_accessor
260         &lt;&lt;-EOF.chomp
261 #{@metadata.struct(self)}#{@metadata.accessor}
262 EOF
263     end
264 
265     def members
266         &lt;&lt;-EOF.chomp
267 #{print_members(&quot;    &quot;, &amp;:field)}#{@metadata.field(&quot;    &quot;)}
268 EOF
269     end
270 
271     def set_entry_address(id)
272         &quot;setEntryAddress(#{id}, _#{full_name})&quot;
273     end
274 
275     def set_entry_address_wide16(id)
276         &quot;setEntryAddressWide16(#{id}, _#{full_name}_wide16)&quot;
277     end
278 
279     def set_entry_address_wide32(id)
280         &quot;setEntryAddressWide32(#{id}, _#{full_name}_wide32)&quot;
281     end
282 
283     def struct_indices
284         out = []
285         out += @args.map(&amp;:field_name) unless @args.nil?
286         out &lt;&lt; Metadata.field_name unless @metadata.empty?
287         out.map.with_index do |name, index|
<span class="line-modified">288             &quot;const unsigned #{capitalized_name}_#{name}_index = #{index + 1};&quot;</span>
289         end
290     end
291 
292     def full_name
293         &quot;#{@section.config[:asm_prefix]}#{@section.config[:op_prefix]}#{@name}&quot;
294     end
295 
296     def name
297         &quot;#{@section.config[:op_prefix]}#{@name}&quot;
298     end
299 




300     def length
301         1 + (@args.nil? ? 0 : @args.length) + (@metadata.empty? ? 0 : 1)
302     end
303 
<span class="line-modified">304     def self.dump_bytecode(opcodes)</span>
305         &lt;&lt;-EOF.chomp
<span class="line-modified">306 template&lt;typename Block&gt;</span>
<span class="line-removed">307 static void dumpBytecode(BytecodeDumper&lt;Block&gt;* dumper, InstructionStream::Offset __location, const Instruction* __instruction)</span>
308 {
<span class="line-modified">309     switch (__instruction-&gt;opcodeID()) {</span>
310 #{opcodes.map { |op|
311         &lt;&lt;-EOF.chomp
312     case #{op.name}:
<span class="line-modified">313         __instruction-&gt;as&lt;#{op.capitalized_name}&gt;().dump(dumper, __location, __instruction-&gt;sizeShiftAmount());</span>
314         break;
315 EOF
316     }.join &quot;\n&quot;}
317     default:
318         ASSERT_NOT_REACHED();
319     }
320 }
321 EOF
322     end
323 end
</pre>
</td>
<td>
<hr />
<pre>
 12 # THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 13 # AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 14 # THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 15 # PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 16 # BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 17 # CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 18 # SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 19 # INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 20 # CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 21 # ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 22 # THE POSSIBILITY OF SUCH DAMAGE.
 23 
 24 require_relative &#39;Argument&#39;
 25 require_relative &#39;Fits&#39;
 26 require_relative &#39;Metadata&#39;
 27 
 28 class Opcode
 29     attr_reader :id
 30     attr_reader :args
 31     attr_reader :metadata
<span class="line-added"> 32     attr_reader :extras</span>
<span class="line-added"> 33     attr_reader :checkpoints</span>
 34 
 35     module Size
 36         Narrow = &quot;OpcodeSize::Narrow&quot;
 37         Wide16 = &quot;OpcodeSize::Wide16&quot;
 38         Wide32 = &quot;OpcodeSize::Wide32&quot;
 39     end
 40 
 41     @@id = 0
 42 
 43     def self.id
 44         tid = @@id
 45         @@id = @@id + 1
 46         tid
 47     end
 48 
<span class="line-modified"> 49     def initialize(section, name, extras, args, metadata, metadata_initializers, tmps, checkpoints)</span>
 50         @section = section
 51         @name = name
<span class="line-added"> 52         @extras = extras || {}</span>
 53         @metadata = Metadata.new metadata, metadata_initializers
<span class="line-modified"> 54         @args = args.map.with_index { |(arg_name, type), index| Argument.new arg_name, type, index } unless args.nil?</span>
<span class="line-added"> 55         @tmps = tmps</span>
<span class="line-added"> 56         @checkpoints = checkpoints.map { |(checkpoint, _)| checkpoint } unless checkpoints.nil?</span>
 57     end
 58 
 59     def create_id!
 60         @id = self.class.id
 61     end
 62 
 63     def print_args(&amp;block)
 64         return if @args.nil?
 65         @args.map(&amp;block).join &quot;\n&quot;
 66     end
 67 
 68     def print_members(prefix, &amp;block)
 69         return if @args.nil?
 70         @args.map(&amp;block).map { |arg| &quot;#{prefix}#{arg}&quot; }.join &quot;\n&quot;
 71     end
 72 
 73     def capitalized_name
 74         name.split(&#39;_&#39;).map(&amp;:capitalize).join
 75     end
 76 
 77     def typed_args
 78         return if @args.nil?
 79 
 80         @args.map(&amp;:create_param).unshift(&quot;&quot;).join(&quot;, &quot;)
 81     end
 82 
 83     def typed_reference_args
 84         return if @args.nil?
 85 
 86         @args.map(&amp;:create_reference_param).unshift(&quot;&quot;).join(&quot;, &quot;)
 87     end
 88 
 89     def untyped_args
 90         return if @args.nil?
 91 
 92         @args.map(&amp;:name).unshift(&quot;&quot;).join(&quot;, &quot;)
 93     end
 94 
<span class="line-added"> 95     def opcodeIDType</span>
<span class="line-added"> 96       @section.is_wasm? ? :WasmOpcodeID : :OpcodeID</span>
<span class="line-added"> 97     end</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99     def wide16</span>
<span class="line-added">100       @section.is_wasm? ? :wasm_wide16 : :op_wide16</span>
<span class="line-added">101     end</span>
<span class="line-added">102 </span>
<span class="line-added">103     def wide32</span>
<span class="line-added">104       @section.is_wasm? ? :wasm_wide32 : :op_wide32</span>
<span class="line-added">105     end</span>
<span class="line-added">106 </span>
<span class="line-added">107     def traits</span>
<span class="line-added">108       @section.is_wasm? ? &quot;WasmOpcodeTraits&quot; : &quot;JSOpcodeTraits&quot;</span>
<span class="line-added">109     end</span>
<span class="line-added">110 </span>
111     def map_fields_with_size(prefix, size, &amp;block)
<span class="line-modified">112         args = [Argument.new(&quot;opcodeID&quot;, opcodeIDType, 0)]</span>
<span class="line-added">113         args += @args.dup if @args</span>
<span class="line-added">114         unless @metadata.empty?</span>
<span class="line-added">115             args &lt;&lt; @metadata.emitter_local</span>
<span class="line-added">116         end</span>
<span class="line-added">117         args.map { |arg| &quot;#{prefix}#{block.call(arg, size)}&quot; }</span>
<span class="line-added">118     end</span>
<span class="line-added">119 </span>
<span class="line-added">120     def map_operands_with_size(prefix, size, &amp;block)</span>
<span class="line-added">121         args = []</span>
122         args += @args.dup if @args
123         unless @metadata.empty?
124             args &lt;&lt; @metadata.emitter_local
125         end
126         args.map { |arg| &quot;#{prefix}#{block.call(arg, size)}&quot; }
127     end
128 
129     def struct
130         &lt;&lt;-EOF
131 struct #{capitalized_name} : public Instruction {
132     #{opcodeID}
<span class="line-added">133     #{temps}</span>
<span class="line-added">134     #{checkpointValues}</span>
135 
136 #{emitter}
137 #{dumper}
138 #{constructors}
139 #{setters}#{metadata_struct_and_accessor}
140 #{members}
141 };
142 EOF
143     end
144 
145     def opcodeID
<span class="line-modified">146         &quot;static constexpr #{opcodeIDType} opcodeID = #{name};&quot;</span>
<span class="line-added">147     end</span>
<span class="line-added">148 </span>
<span class="line-added">149     def checkpointValues</span>
<span class="line-added">150         return if @checkpoints.nil?</span>
<span class="line-added">151 </span>
<span class="line-added">152         [&quot;enum Checkpoints : uint8_t {&quot;].concat(checkpoints.map{ |checkpoint| &quot;        #{checkpoint},&quot; }).concat([&quot;        numberOfCheckpoints,&quot;, &quot;    };&quot;]).join(&quot;\n&quot;)</span>
<span class="line-added">153     end</span>
<span class="line-added">154 </span>
<span class="line-added">155     def temps</span>
<span class="line-added">156         return if @tmps.nil?</span>
<span class="line-added">157 </span>
<span class="line-added">158         [&quot;enum Tmps : uint8_t {&quot;].concat(@tmps.map {|(tmp, type)| &quot;        #{tmp},&quot;}).push(&quot;    };&quot;).join(&quot;\n&quot;)</span>
159     end
160 
161     def emitter
<span class="line-modified">162         op_wide16 = Argument.new(wide16, opcodeIDType, 0)</span>
<span class="line-modified">163         op_wide32 = Argument.new(wide32, opcodeIDType, 0)</span>
164         metadata_param = @metadata.empty? ? &quot;&quot; : &quot;, #{@metadata.emitter_local.create_param}&quot;
165         metadata_arg = @metadata.empty? ? &quot;&quot; : &quot;, #{@metadata.emitter_local.name}&quot;
166         &lt;&lt;-EOF.chomp
<span class="line-added">167     template&lt;typename BytecodeGenerator&gt;</span>
168     static void emit(BytecodeGenerator* gen#{typed_args})
169     {
<span class="line-modified">170         emitWithSmallestSizeRequirement&lt;OpcodeSize::Narrow, BytecodeGenerator&gt;(gen#{untyped_args});</span>
171     }
172 #{%{
<span class="line-modified">173     template&lt;OpcodeSize __size, typename BytecodeGenerator, FitsAssertion shouldAssert = Assert&gt;</span>
174     static bool emit(BytecodeGenerator* gen#{typed_args})
175     {#{@metadata.create_emitter_local}
<span class="line-modified">176         return emit&lt;__size, BytecodeGenerator, shouldAssert&gt;(gen#{untyped_args}#{metadata_arg});</span>
177     }
178 
<span class="line-modified">179     template&lt;OpcodeSize __size, typename BytecodeGenerator&gt;</span>
180     static bool checkWithoutMetadataID(BytecodeGenerator* gen#{typed_args})
181     {
182         decltype(gen-&gt;addMetadataFor(opcodeID)) __metadataID { };
<span class="line-modified">183         return checkImpl&lt;__size, BytecodeGenerator&gt;(gen#{untyped_args}#{metadata_arg});</span>
184     }
185 } unless @metadata.empty?}
<span class="line-modified">186     template&lt;OpcodeSize __size, typename BytecodeGenerator, FitsAssertion shouldAssert = Assert, bool recordOpcode = true&gt;</span>
187     static bool emit(BytecodeGenerator* gen#{typed_args}#{metadata_param})
188     {
<span class="line-modified">189         bool didEmit = emitImpl&lt;__size, recordOpcode, BytecodeGenerator&gt;(gen#{untyped_args}#{metadata_arg});</span>
190         if (shouldAssert == Assert)
191             ASSERT(didEmit);
192         return didEmit;
193     }
194 
<span class="line-modified">195     template&lt;OpcodeSize __size, typename BytecodeGenerator&gt;</span>
196     static void emitWithSmallestSizeRequirement(BytecodeGenerator* gen#{typed_args})
197     {
198         #{@metadata.create_emitter_local}
<span class="line-modified">199         if (static_cast&lt;unsigned&gt;(__size) &lt;= static_cast&lt;unsigned&gt;(OpcodeSize::Narrow)) {</span>
<span class="line-modified">200             if (emit&lt;OpcodeSize::Narrow, BytecodeGenerator, NoAssert, true&gt;(gen#{untyped_args}#{metadata_arg}))</span>
201                 return;
202         }
<span class="line-modified">203         if (static_cast&lt;unsigned&gt;(__size) &lt;= static_cast&lt;unsigned&gt;(OpcodeSize::Wide16)) {</span>
<span class="line-modified">204             if (emit&lt;OpcodeSize::Wide16, BytecodeGenerator, NoAssert, true&gt;(gen#{untyped_args}#{metadata_arg}))</span>
205                 return;
206         }
<span class="line-modified">207         emit&lt;OpcodeSize::Wide32, BytecodeGenerator, Assert, true&gt;(gen#{untyped_args}#{metadata_arg});</span>
208     }
209 
210 private:
<span class="line-modified">211     template&lt;OpcodeSize __size, typename BytecodeGenerator&gt;</span>
212     static bool checkImpl(BytecodeGenerator* gen#{typed_reference_args}#{metadata_param})
213     {
214         UNUSED_PARAM(gen);
215 #if OS(WINDOWS) &amp;&amp; ENABLE(C_LOOP)
216         // FIXME: Disable wide16 optimization for Windows CLoop
217         // https://bugs.webkit.org/show_bug.cgi?id=198283
<span class="line-modified">218         if (__size == OpcodeSize::Wide16)</span>
219             return false;
220 #endif
<span class="line-modified">221         return #{map_fields_with_size(&quot;&quot;, &quot;__size&quot;, &amp;:fits_check).join &quot;\n            &amp;&amp; &quot;}</span>
<span class="line-modified">222             &amp;&amp; (__size == OpcodeSize::Wide16 ? #{op_wide16.fits_check(Size::Narrow)} : true)</span>
<span class="line-modified">223             &amp;&amp; (__size == OpcodeSize::Wide32 ? #{op_wide32.fits_check(Size::Narrow)} : true);</span>
224     }
225 
<span class="line-modified">226     template&lt;OpcodeSize __size, bool recordOpcode, typename BytecodeGenerator&gt;</span>
227     static bool emitImpl(BytecodeGenerator* gen#{typed_args}#{metadata_param})
228     {
<span class="line-modified">229         #{!@checkpoints.nil? ? &quot;gen-&gt;setUsesCheckpoints();&quot; : &quot;&quot;}</span>
<span class="line-added">230         if (__size == OpcodeSize::Wide16)</span>
231             gen-&gt;alignWideOpcode16();
<span class="line-modified">232         else if (__size == OpcodeSize::Wide32)</span>
233             gen-&gt;alignWideOpcode32();
<span class="line-modified">234         if (checkImpl&lt;__size&gt;(gen#{untyped_args}#{metadata_arg})) {</span>
235             if (recordOpcode)
236                 gen-&gt;recordOpcode(opcodeID);
<span class="line-modified">237             if (__size == OpcodeSize::Wide16)</span>
238                 #{op_wide16.fits_write Size::Narrow}
<span class="line-modified">239             else if (__size == OpcodeSize::Wide32)</span>
240                 #{op_wide32.fits_write Size::Narrow}
<span class="line-modified">241             #{Argument.new(&quot;opcodeID&quot;, opcodeIDType, 0).fits_write Size::Narrow}</span>
<span class="line-added">242 #{map_operands_with_size(&quot;            &quot;, &quot;__size&quot;, &amp;:fits_write).join &quot;\n&quot;}</span>
243             return true;
244         }
245         return false;
246     }
247 
248 public:
249 EOF
250     end
251 
252     def dumper
253         &lt;&lt;-EOF
<span class="line-modified">254     void dump(BytecodeDumperBase* dumper, InstructionStream::Offset __location, int __sizeShiftAmount)</span>

255     {
256         dumper-&gt;printLocationAndOp(__location, &amp;&quot;**#{@name}&quot;[2 - __sizeShiftAmount]);
257 #{print_args { |arg|
258 &lt;&lt;-EOF.chomp
<span class="line-modified">259         dumper-&gt;dumpOperand(#{arg.field_name}, #{arg.index == 0});</span>
260 EOF
261     }}
262     }
263 EOF
264     end
265 
266     def constructors
267         fields = (@args || []) + (@metadata.empty? ? [] : [@metadata])
<span class="line-modified">268         init = -&gt;(size) { fields.empty?  ? &quot;&quot; : &quot;: #{fields.map.with_index { |arg, i| arg.load_from_stream(i, size) }.join &quot;\n        , &quot; }&quot; }</span>
269 
270         &lt;&lt;-EOF
271     #{capitalized_name}(const uint8_t* stream)
272         #{init.call(&quot;OpcodeSize::Narrow&quot;)}
273     {
<span class="line-modified">274         ASSERT_UNUSED(stream, bitwise_cast&lt;const uint8_t*&gt;(stream)[-1] == opcodeID);</span>
275     }
276 
277     #{capitalized_name}(const uint16_t* stream)
278         #{init.call(&quot;OpcodeSize::Wide16&quot;)}
279     {
<span class="line-modified">280         ASSERT_UNUSED(stream, bitwise_cast&lt;const uint8_t*&gt;(stream)[-1] == opcodeID);</span>
281     }
282 
283 
284     #{capitalized_name}(const uint32_t* stream)
285         #{init.call(&quot;OpcodeSize::Wide32&quot;)}
286     {
<span class="line-modified">287         ASSERT_UNUSED(stream, bitwise_cast&lt;const uint8_t*&gt;(stream)[-1] == opcodeID);</span>
288     }
289 
290     static #{capitalized_name} decode(const uint8_t* stream)
291     {
<span class="line-modified">292         // A pointer is pointing to the first operand (opcode and prefix are not included).</span>
<span class="line-modified">293         if (*stream == #{wide32})</span>
<span class="line-modified">294             return { bitwise_cast&lt;const uint32_t*&gt;(stream + 2) };</span>
<span class="line-modified">295         if (*stream == #{wide16})</span>
<span class="line-modified">296             return { bitwise_cast&lt;const uint16_t*&gt;(stream + 2) };</span>
<span class="line-added">297         return { stream + 1 };</span>
298     }
299 EOF
300     end
301 
302     def setters
<span class="line-modified">303         print_args { |a| a.setter(traits) }</span>
304     end
305 
306     def metadata_struct_and_accessor
307         &lt;&lt;-EOF.chomp
308 #{@metadata.struct(self)}#{@metadata.accessor}
309 EOF
310     end
311 
312     def members
313         &lt;&lt;-EOF.chomp
314 #{print_members(&quot;    &quot;, &amp;:field)}#{@metadata.field(&quot;    &quot;)}
315 EOF
316     end
317 
318     def set_entry_address(id)
319         &quot;setEntryAddress(#{id}, _#{full_name})&quot;
320     end
321 
322     def set_entry_address_wide16(id)
323         &quot;setEntryAddressWide16(#{id}, _#{full_name}_wide16)&quot;
324     end
325 
326     def set_entry_address_wide32(id)
327         &quot;setEntryAddressWide32(#{id}, _#{full_name}_wide32)&quot;
328     end
329 
330     def struct_indices
331         out = []
332         out += @args.map(&amp;:field_name) unless @args.nil?
333         out &lt;&lt; Metadata.field_name unless @metadata.empty?
334         out.map.with_index do |name, index|
<span class="line-modified">335             &quot;const unsigned #{capitalized_name}_#{name}_index = #{index};&quot;</span>
336         end
337     end
338 
339     def full_name
340         &quot;#{@section.config[:asm_prefix]}#{@section.config[:op_prefix]}#{@name}&quot;
341     end
342 
343     def name
344         &quot;#{@section.config[:op_prefix]}#{@name}&quot;
345     end
346 
<span class="line-added">347     def unprefixed_name</span>
<span class="line-added">348       @name</span>
<span class="line-added">349     end</span>
<span class="line-added">350 </span>
351     def length
352         1 + (@args.nil? ? 0 : @args.length) + (@metadata.empty? ? 0 : 1)
353     end
354 
<span class="line-modified">355     def self.dump_bytecode(name, opcode_traits, opcodes)</span>
356         &lt;&lt;-EOF.chomp
<span class="line-modified">357 void dump#{name}(BytecodeDumperBase* dumper, InstructionStream::Offset __location, const Instruction* __instruction)</span>

358 {
<span class="line-modified">359     switch (__instruction-&gt;opcodeID&lt;#{opcode_traits}&gt;()) {</span>
360 #{opcodes.map { |op|
361         &lt;&lt;-EOF.chomp
362     case #{op.name}:
<span class="line-modified">363         __instruction-&gt;as&lt;#{op.capitalized_name}, #{opcode_traits}&gt;().dump(dumper, __location, __instruction-&gt;sizeShiftAmount&lt;#{opcode_traits}&gt;());</span>
364         break;
365 EOF
366     }.join &quot;\n&quot;}
367     default:
368         ASSERT_NOT_REACHED();
369     }
370 }
371 EOF
372     end
373 end
</pre>
</td>
</tr>
</table>
<center><a href="Metadata.rb.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="Options.rb.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
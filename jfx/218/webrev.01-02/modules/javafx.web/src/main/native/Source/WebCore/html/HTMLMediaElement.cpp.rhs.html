<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/html/HTMLMediaElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (C) 2007-2019 Apple Inc. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  * 1. Redistributions of source code must retain the above copyright
   8  *    notice, this list of conditions and the following disclaimer.
   9  * 2. Redistributions in binary form must reproduce the above copyright
  10  *    notice, this list of conditions and the following disclaimer in the
  11  *    documentation and/or other materials provided with the distribution.
  12  *
  13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
  14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
  17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
  21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  24  */
  25 
  26 #include &quot;config.h&quot;
  27 #include &quot;HTMLMediaElement.h&quot;
  28 
  29 #if ENABLE(VIDEO)
  30 
  31 #include &quot;ApplicationCacheHost.h&quot;
  32 #include &quot;ApplicationCacheResource.h&quot;
  33 #include &quot;Attribute.h&quot;
  34 #include &quot;Blob.h&quot;
  35 #include &quot;CSSPropertyNames.h&quot;
  36 #include &quot;CSSValueKeywords.h&quot;
  37 #include &quot;ChromeClient.h&quot;
  38 #include &quot;CommonVM.h&quot;
  39 #include &quot;ContentRuleListResults.h&quot;
  40 #include &quot;ContentSecurityPolicy.h&quot;
  41 #include &quot;ContentType.h&quot;
  42 #include &quot;CookieJar.h&quot;
  43 #include &quot;CustomHeaderFields.h&quot;
  44 #include &quot;DeprecatedGlobalSettings.h&quot;
  45 #include &quot;DiagnosticLoggingClient.h&quot;
  46 #include &quot;DiagnosticLoggingKeys.h&quot;
  47 #include &quot;Document.h&quot;
  48 #include &quot;DocumentLoader.h&quot;
  49 #include &quot;ElementChildIterator.h&quot;
  50 #include &quot;EventNames.h&quot;
  51 #include &quot;Frame.h&quot;
  52 #include &quot;FrameLoader.h&quot;
  53 #include &quot;FrameLoaderClient.h&quot;
  54 #include &quot;FrameView.h&quot;
  55 #include &quot;FullscreenManager.h&quot;
  56 #include &quot;HTMLParserIdioms.h&quot;
  57 #include &quot;HTMLSourceElement.h&quot;
  58 #include &quot;HTMLVideoElement.h&quot;
  59 #include &quot;InspectorInstrumentation.h&quot;
  60 #include &quot;JSDOMException.h&quot;
  61 #include &quot;JSDOMPromiseDeferred.h&quot;
  62 #include &quot;JSHTMLMediaElement.h&quot;
  63 #include &quot;Logging.h&quot;
  64 #include &quot;MIMETypeRegistry.h&quot;
  65 #include &quot;MediaController.h&quot;
  66 #include &quot;MediaControls.h&quot;
  67 #include &quot;MediaDocument.h&quot;
  68 #include &quot;MediaError.h&quot;
  69 #include &quot;MediaFragmentURIParser.h&quot;
  70 #include &quot;MediaList.h&quot;
  71 #include &quot;MediaPlayer.h&quot;
  72 #include &quot;MediaQueryEvaluator.h&quot;
  73 #include &quot;MediaResourceLoader.h&quot;
  74 #include &quot;NetworkingContext.h&quot;
<a name="1" id="anc1"></a><span class="line-added">  75 #include &quot;PODIntervalTree.h&quot;</span>
  76 #include &quot;Page.h&quot;
  77 #include &quot;PageGroup.h&quot;
<a name="2" id="anc2"></a><span class="line-added">  78 #include &quot;PictureInPictureSupport.h&quot;</span>
  79 #include &quot;PlatformMediaSessionManager.h&quot;
  80 #include &quot;ProgressTracker.h&quot;
  81 #include &quot;Quirks.h&quot;
  82 #include &quot;RegistrableDomain.h&quot;
  83 #include &quot;RenderLayerCompositor.h&quot;
  84 #include &quot;RenderTheme.h&quot;
  85 #include &quot;RenderVideo.h&quot;
  86 #include &quot;RenderView.h&quot;
  87 #include &quot;ResourceLoadInfo.h&quot;
  88 #include &quot;ScriptController.h&quot;
  89 #include &quot;ScriptDisallowedScope.h&quot;
  90 #include &quot;ScriptSourceCode.h&quot;
  91 #include &quot;SecurityOriginData.h&quot;
  92 #include &quot;SecurityPolicy.h&quot;
  93 #include &quot;Settings.h&quot;
  94 #include &quot;ShadowRoot.h&quot;
  95 #include &quot;TimeRanges.h&quot;
  96 #include &quot;UserContentController.h&quot;
  97 #include &quot;UserGestureIndicator.h&quot;
  98 #include &quot;VideoPlaybackQuality.h&quot;
  99 #include &lt;JavaScriptCore/Uint8Array.h&gt;
 100 #include &lt;limits&gt;
 101 #include &lt;pal/SessionID.h&gt;
 102 #include &lt;pal/system/SleepDisabler.h&gt;
 103 #include &lt;wtf/Algorithms.h&gt;
 104 #include &lt;wtf/IsoMallocInlines.h&gt;
 105 #include &lt;wtf/Language.h&gt;
 106 #include &lt;wtf/MathExtras.h&gt;
 107 #include &lt;wtf/MemoryPressureHandler.h&gt;
 108 #include &lt;wtf/Ref.h&gt;
 109 #include &lt;wtf/text/CString.h&gt;
 110 
 111 #if ENABLE(VIDEO_TRACK)
 112 #include &quot;AudioTrackList.h&quot;
 113 #include &quot;HTMLTrackElement.h&quot;
 114 #include &quot;InbandGenericTextTrack.h&quot;
 115 #include &quot;InbandTextTrackPrivate.h&quot;
 116 #include &quot;InbandWebVTTTextTrack.h&quot;
 117 #include &quot;RuntimeEnabledFeatures.h&quot;
 118 #include &quot;TextTrackCueList.h&quot;
 119 #include &quot;TextTrackList.h&quot;
 120 #include &quot;VideoTrackList.h&quot;
 121 #endif
 122 
 123 #if ENABLE(WEB_AUDIO)
 124 #include &quot;AudioSourceProvider.h&quot;
 125 #include &quot;MediaElementAudioSourceNode.h&quot;
 126 #endif
 127 
 128 #if PLATFORM(IOS_FAMILY)
 129 #include &quot;RuntimeApplicationChecks.h&quot;
 130 #include &quot;VideoFullscreenInterfaceAVKit.h&quot;
 131 #endif
 132 
 133 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<a name="3" id="anc3"></a><span class="line-added"> 134 #include &quot;RemotePlayback.h&quot;</span>
 135 #include &quot;WebKitPlaybackTargetAvailabilityEvent.h&quot;
 136 #endif
 137 
 138 #if ENABLE(MEDIA_SESSION)
 139 #include &quot;MediaSession.h&quot;
 140 #endif
 141 
 142 #if ENABLE(MEDIA_SOURCE)
 143 #include &quot;DOMWindow.h&quot;
 144 #include &quot;MediaSource.h&quot;
 145 #endif
 146 
 147 #if ENABLE(MEDIA_STREAM)
 148 #include &quot;DOMURL.h&quot;
 149 #include &quot;MediaStream.h&quot;
 150 #endif
 151 
 152 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 153 #include &quot;WebKitMediaKeyNeededEvent.h&quot;
 154 #include &quot;WebKitMediaKeys.h&quot;
 155 #endif
 156 
 157 #if ENABLE(ENCRYPTED_MEDIA)
 158 #include &quot;MediaEncryptedEvent.h&quot;
 159 #include &quot;MediaKeys.h&quot;
 160 #endif
 161 
 162 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 163 #include &quot;JSMediaControlsHost.h&quot;
 164 #include &quot;MediaControlsHost.h&quot;
 165 #include &lt;JavaScriptCore/ScriptObject.h&gt;
 166 #endif
 167 
 168 #if ENABLE(ENCRYPTED_MEDIA)
 169 #include &quot;NotImplemented.h&quot;
 170 #endif
 171 
 172 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
 173 #include &quot;VideoFullscreenModel.h&quot;
 174 #endif
 175 
 176 namespace WTF {
 177 template &lt;&gt;
 178 struct LogArgument&lt;URL&gt; {
 179     static String toString(const URL&amp; url)
 180     {
 181 #if !LOG_DISABLED
 182         static const unsigned maximumURLLengthForLogging = 512;
 183 
 184         if (url.string().length() &lt; maximumURLLengthForLogging)
 185             return url.string();
 186         return url.string().substring(0, maximumURLLengthForLogging) + &quot;...&quot;;
 187 #else
 188         UNUSED_PARAM(url);
 189         return &quot;[url]&quot;;
 190 #endif
 191     }
 192 };
 193 }
 194 
 195 
 196 namespace WebCore {
 197 
 198 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLMediaElement);
 199 
 200 using namespace PAL;
 201 
 202 static const Seconds SeekRepeatDelay { 100_ms };
 203 static const double SeekTime = 0.2;
 204 static const Seconds ScanRepeatDelay { 1.5_s };
 205 static const double ScanMaximumRate = 8;
 206 static const double AutoplayInterferenceTimeThreshold = 10;
 207 static const Seconds hideMediaControlsAfterEndedDelay { 6_s };
 208 
 209 #ifndef LOG_CACHED_TIME_WARNINGS
 210 // Default to not logging warnings about excessive drift in the cached media time because it adds a
 211 // fair amount of overhead and logging.
 212 #define LOG_CACHED_TIME_WARNINGS 0
 213 #endif
 214 
 215 #if ENABLE(MEDIA_SOURCE)
 216 // URL protocol used to signal that the media source API is being used.
 217 static const char* mediaSourceBlobProtocol = &quot;blob&quot;;
 218 #endif
 219 
 220 #if ENABLE(MEDIA_STREAM)
 221 // URL protocol used to signal that the media stream API is being used.
 222 static const char* mediaStreamBlobProtocol = &quot;blob&quot;;
 223 #endif
 224 
 225 using namespace HTMLNames;
 226 
 227 String convertEnumerationToString(HTMLMediaElement::ReadyState enumerationValue)
 228 {
 229     static const NeverDestroyed&lt;String&gt; values[] = {
 230         MAKE_STATIC_STRING_IMPL(&quot;HAVE_NOTHING&quot;),
 231         MAKE_STATIC_STRING_IMPL(&quot;HAVE_METADATA&quot;),
 232         MAKE_STATIC_STRING_IMPL(&quot;HAVE_CURRENT_DATA&quot;),
 233         MAKE_STATIC_STRING_IMPL(&quot;HAVE_FUTURE_DATA&quot;),
 234         MAKE_STATIC_STRING_IMPL(&quot;HAVE_ENOUGH_DATA&quot;),
 235     };
 236     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::HAVE_NOTHING) == 0, &quot;HTMLMediaElementEnums::HAVE_NOTHING is not 0 as expected&quot;);
 237     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::HAVE_METADATA) == 1, &quot;HTMLMediaElementEnums::HAVE_METADATA is not 1 as expected&quot;);
 238     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::HAVE_CURRENT_DATA) == 2, &quot;HTMLMediaElementEnums::HAVE_CURRENT_DATA is not 2 as expected&quot;);
 239     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::HAVE_FUTURE_DATA) == 3, &quot;HTMLMediaElementEnums::HAVE_FUTURE_DATA is not 3 as expected&quot;);
 240     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::HAVE_ENOUGH_DATA) == 4, &quot;HTMLMediaElementEnums::HAVE_ENOUGH_DATA is not 4 as expected&quot;);
 241     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
 242     return values[static_cast&lt;size_t&gt;(enumerationValue)];
 243 }
 244 
 245 String convertEnumerationToString(HTMLMediaElement::NetworkState enumerationValue)
 246 {
 247     static const NeverDestroyed&lt;String&gt; values[] = {
 248         MAKE_STATIC_STRING_IMPL(&quot;NETWORK_EMPTY&quot;),
 249         MAKE_STATIC_STRING_IMPL(&quot;NETWORK_IDLE&quot;),
 250         MAKE_STATIC_STRING_IMPL(&quot;NETWORK_LOADING&quot;),
 251         MAKE_STATIC_STRING_IMPL(&quot;NETWORK_NO_SOURCE&quot;),
 252     };
 253     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::NETWORK_EMPTY) == 0, &quot;HTMLMediaElementEnums::NETWORK_EMPTY is not 0 as expected&quot;);
 254     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::NETWORK_IDLE) == 1, &quot;HTMLMediaElementEnums::NETWORK_IDLE is not 1 as expected&quot;);
 255     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::NETWORK_LOADING) == 2, &quot;HTMLMediaElementEnums::NETWORK_LOADING is not 2 as expected&quot;);
 256     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElementEnums::NETWORK_NO_SOURCE) == 3, &quot;HTMLMediaElementEnums::NETWORK_NO_SOURCE is not 3 as expected&quot;);
 257     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
 258     return values[static_cast&lt;size_t&gt;(enumerationValue)];
 259 }
 260 
 261 String convertEnumerationToString(HTMLMediaElement::AutoplayEventPlaybackState enumerationValue)
 262 {
 263     static const NeverDestroyed&lt;String&gt; values[] = {
 264         MAKE_STATIC_STRING_IMPL(&quot;None&quot;),
 265         MAKE_STATIC_STRING_IMPL(&quot;PreventedAutoplay&quot;),
 266         MAKE_STATIC_STRING_IMPL(&quot;StartedWithUserGesture&quot;),
 267         MAKE_STATIC_STRING_IMPL(&quot;StartedWithoutUserGesture&quot;),
 268     };
 269     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::None) == 0, &quot;AutoplayEventPlaybackState::None is not 0 as expected&quot;);
 270     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::PreventedAutoplay) == 1, &quot;AutoplayEventPlaybackState::PreventedAutoplay is not 1 as expected&quot;);
 271     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::StartedWithUserGesture) == 2, &quot;AutoplayEventPlaybackState::StartedWithUserGesture is not 2 as expected&quot;);
 272     static_assert(static_cast&lt;size_t&gt;(HTMLMediaElement::AutoplayEventPlaybackState::StartedWithoutUserGesture) == 3, &quot;AutoplayEventPlaybackState::StartedWithoutUserGesture is not 3 as expected&quot;);
 273     ASSERT(static_cast&lt;size_t&gt;(enumerationValue) &lt; WTF_ARRAY_LENGTH(values));
 274     return values[static_cast&lt;size_t&gt;(enumerationValue)];
 275 }
 276 
<a name="4" id="anc4"></a>























 277 #if ENABLE(VIDEO_TRACK)
 278 
 279 class TrackDisplayUpdateScope {
 280 public:
 281     TrackDisplayUpdateScope(HTMLMediaElement&amp; element)
 282         : m_element(element)
 283     {
 284         m_element.beginIgnoringTrackDisplayUpdateRequests();
 285     }
 286     ~TrackDisplayUpdateScope()
 287     {
 288         m_element.endIgnoringTrackDisplayUpdateRequests();
 289     }
 290 
 291 private:
 292     HTMLMediaElement&amp; m_element;
 293 };
 294 
<a name="5" id="anc5"></a>
 295 
 296 struct HTMLMediaElement::TrackGroup {
 297     enum GroupKind { CaptionsAndSubtitles, Description, Chapter, Metadata, Other };
 298 
 299     TrackGroup(GroupKind kind)
 300         : kind(kind)
 301     {
 302     }
 303 
 304     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; tracks;
 305     RefPtr&lt;TextTrack&gt; visibleTrack;
 306     RefPtr&lt;TextTrack&gt; defaultTrack;
 307     GroupKind kind;
 308     bool hasSrcLang { false };
 309 };
<a name="6" id="anc6"></a><span class="line-added"> 310 #endif</span>
 311 
 312 HashSet&lt;HTMLMediaElement*&gt;&amp; HTMLMediaElement::allMediaElements()
 313 {
 314     static NeverDestroyed&lt;HashSet&lt;HTMLMediaElement*&gt;&gt; elements;
 315     return elements;
 316 }
 317 
 318 #if ENABLE(MEDIA_SESSION)
 319 typedef HashMap&lt;uint64_t, HTMLMediaElement*&gt; IDToElementMap;
 320 
 321 static IDToElementMap&amp; elementIDsToElements()
 322 {
 323     static NeverDestroyed&lt;IDToElementMap&gt; map;
 324     return map;
 325 }
 326 
 327 HTMLMediaElement* HTMLMediaElement::elementWithID(uint64_t id)
 328 {
 329     if (id == HTMLMediaElementInvalidID)
 330         return nullptr;
 331 
 332     return elementIDsToElements().get(id);
 333 }
 334 
 335 static uint64_t nextElementID()
 336 {
 337     static uint64_t elementID = 0;
 338     return ++elementID;
 339 }
 340 #endif
 341 
 342 struct MediaElementSessionInfo {
 343     const MediaElementSession* session;
 344     MediaElementSession::PlaybackControlsPurpose purpose;
 345 
 346     MonotonicTime timeOfLastUserInteraction;
 347     bool canShowControlsManager : 1;
 348     bool isVisibleInViewportOrFullscreen : 1;
 349     bool isLargeEnoughForMainContent : 1;
 350     bool isPlayingAudio : 1;
 351 };
 352 
 353 static MediaElementSessionInfo mediaElementSessionInfoForSession(const MediaElementSession&amp; session, MediaElementSession::PlaybackControlsPurpose purpose)
 354 {
 355     const HTMLMediaElement&amp; element = session.element();
 356     return {
 357         &amp;session,
 358         purpose,
 359         session.mostRecentUserInteractionTime(),
 360         session.canShowControlsManager(purpose),
 361         element.isFullscreen() || element.isVisibleInViewport(),
 362         session.isLargeEnoughForMainContent(MediaSessionMainContentPurpose::MediaControls),
 363         element.isPlaying() &amp;&amp; element.hasAudio() &amp;&amp; !element.muted()
 364     };
 365 }
 366 
 367 static bool preferMediaControlsForCandidateSessionOverOtherCandidateSession(const MediaElementSessionInfo&amp; session, const MediaElementSessionInfo&amp; otherSession)
 368 {
 369     MediaElementSession::PlaybackControlsPurpose purpose = session.purpose;
 370     ASSERT(purpose == otherSession.purpose);
 371 
 372     // For the controls manager, prioritize visible media over offscreen media.
 373     if (purpose == MediaElementSession::PlaybackControlsPurpose::ControlsManager &amp;&amp; session.isVisibleInViewportOrFullscreen != otherSession.isVisibleInViewportOrFullscreen)
 374         return session.isVisibleInViewportOrFullscreen;
 375 
 376     // For Now Playing, prioritize elements that would normally satisfy main content.
 377     if (purpose == MediaElementSession::PlaybackControlsPurpose::NowPlaying &amp;&amp; session.isLargeEnoughForMainContent != otherSession.isLargeEnoughForMainContent)
 378         return session.isLargeEnoughForMainContent;
 379 
 380     // As a tiebreaker, prioritize elements that the user recently interacted with.
 381     return session.timeOfLastUserInteraction &gt; otherSession.timeOfLastUserInteraction;
 382 }
 383 
 384 static bool mediaSessionMayBeConfusedWithMainContent(const MediaElementSessionInfo&amp; session, MediaElementSession::PlaybackControlsPurpose purpose)
 385 {
 386     if (purpose == MediaElementSession::PlaybackControlsPurpose::NowPlaying)
 387         return session.isPlayingAudio;
 388 
 389     if (!session.isVisibleInViewportOrFullscreen)
 390         return false;
 391 
 392     if (!session.isLargeEnoughForMainContent)
 393         return false;
 394 
 395     // Even if this video is not a candidate, if it is visible to the user and large enough
 396     // to be main content, it poses a risk for being confused with main content.
 397     return true;
 398 }
 399 
 400 HTMLMediaElement::HTMLMediaElement(const QualifiedName&amp; tagName, Document&amp; document, bool createdByParser)
 401     : HTMLElement(tagName, document)
 402     , ActiveDOMObject(document)
 403     , m_progressEventTimer(*this, &amp;HTMLMediaElement::progressEventTimerFired)
 404     , m_playbackProgressTimer(*this, &amp;HTMLMediaElement::playbackProgressTimerFired)
 405     , m_scanTimer(*this, &amp;HTMLMediaElement::scanTimerFired)
 406     , m_playbackControlsManagerBehaviorRestrictionsTimer(*this, &amp;HTMLMediaElement::playbackControlsManagerBehaviorRestrictionsTimerFired)
 407     , m_seekToPlaybackPositionEndedTimer(*this, &amp;HTMLMediaElement::seekToPlaybackPositionEndedTimerFired)
<a name="7" id="anc7"></a><span class="line-modified"> 408     , m_updatePlayStateTask(*this)</span>
<span class="line-added"> 409     , m_asyncEventQueue(MainThreadGenericEventQueue::create(*this))</span>
 410     , m_lastTimeUpdateEventMovieTime(MediaTime::positiveInfiniteTime())
 411     , m_firstTimePlaying(true)
 412     , m_playing(false)
 413     , m_isWaitingUntilMediaCanStart(false)
 414     , m_shouldDelayLoadEvent(false)
 415     , m_haveFiredLoadedData(false)
 416     , m_inActiveDocument(true)
 417     , m_autoplaying(true)
 418     , m_muted(false)
 419     , m_explicitlyMuted(false)
 420     , m_initiallyMuted(false)
 421     , m_paused(true)
 422     , m_seeking(false)
 423     , m_seekRequested(false)
 424     , m_sentStalledEvent(false)
 425     , m_sentEndEvent(false)
 426     , m_pausedInternal(false)
 427     , m_closedCaptionsVisible(false)
 428     , m_webkitLegacyClosedCaptionOverride(false)
 429     , m_completelyLoaded(false)
 430     , m_havePreparedToPlay(false)
 431     , m_parsingInProgress(createdByParser)
 432     , m_elementIsHidden(document.hidden())
 433     , m_creatingControls(false)
 434     , m_receivedLayoutSizeChanged(false)
 435     , m_hasEverNotifiedAboutPlaying(false)
 436     , m_hasEverHadAudio(false)
 437     , m_hasEverHadVideo(false)
 438 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 439     , m_mediaControlsDependOnPageScaleFactor(false)
 440     , m_haveSetUpCaptionContainer(false)
 441 #endif
 442     , m_isScrubbingRemotely(false)
 443 #if ENABLE(VIDEO_TRACK)
 444     , m_tracksAreReady(true)
 445     , m_haveVisibleTextTrack(false)
 446     , m_processingPreferenceChange(false)
 447 #endif
<a name="8" id="anc8"></a><span class="line-added"> 448 #if ENABLE(WIRELESS_PLAYBACK_TARGET)</span>
<span class="line-added"> 449     , m_remote(RemotePlayback::create(*this))</span>
<span class="line-added"> 450 #endif</span>
 451 #if !RELEASE_LOG_DISABLED
 452     , m_logger(&amp;document.logger())
 453     , m_logIdentifier(uniqueLogIdentifier())
 454 #endif
 455 {
 456     allMediaElements().add(this);
 457 
 458     ALWAYS_LOG(LOGIDENTIFIER);
 459 
 460     setHasCustomStyleResolveCallbacks();
 461 
 462     InspectorInstrumentation::addEventListenersToNode(*this);
 463 }
 464 
 465 void HTMLMediaElement::finishInitialization()
 466 {
 467     m_mediaSession = makeUnique&lt;MediaElementSession&gt;(*this);
 468 
 469     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForFullscreen);
 470     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToLoadMedia);
 471 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 472     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToAutoplayToExternalDevice);
 473 #endif
 474     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager);
 475     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePlaybackToControlControlsManager);
 476 
 477     auto&amp; document = this-&gt;document();
 478     auto* page = document.page();
 479 
 480     if (document.settings().invisibleAutoplayNotPermitted())
 481         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::InvisibleAutoplayNotPermitted);
 482 
 483     if (document.ownerElement() || !document.isMediaDocument()) {
 484         const auto&amp; topDocument = document.topDocument();
 485         const bool isProcessingUserGesture = processingUserGestureForMedia();
 486         const bool shouldAudioPlaybackRequireUserGesture = topDocument.audioPlaybackRequiresUserGesture() &amp;&amp; !isProcessingUserGesture;
 487         const bool shouldVideoPlaybackRequireUserGesture = topDocument.videoPlaybackRequiresUserGesture() &amp;&amp; !isProcessingUserGesture;
 488 
 489         if (shouldVideoPlaybackRequireUserGesture) {
 490             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoRateChange);
 491             if (document.settings().requiresUserGestureToLoadVideo())
 492                 m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForLoad);
 493         }
 494 
 495         if (page &amp;&amp; page-&gt;isLowPowerModeEnabled())
 496             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoDueToLowPowerMode);
 497 
 498         if (shouldAudioPlaybackRequireUserGesture)
 499             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForAudioRateChange);
 500 
 501 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 502         if (shouldVideoPlaybackRequireUserGesture || shouldAudioPlaybackRequireUserGesture)
 503             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker);
 504 #endif
 505 
<a name="9" id="anc9"></a><span class="line-modified"> 506         if (!document.mediaDataLoadsAutomatically() &amp;&amp; !document.quirks().needsPreloadAutoQuirk())</span>
 507             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::AutoPreloadingNotPermitted);
 508 
 509         if (document.settings().mainContentUserGestureOverrideEnabled())
 510             m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::OverrideUserGestureRequirementForMainContent);
 511     }
 512 
 513 #if PLATFORM(IOS_FAMILY)
 514     if (!document.settings().videoPlaybackRequiresUserGesture() &amp;&amp; !document.settings().audioPlaybackRequiresUserGesture()) {
 515         // Relax RequireUserGestureForFullscreen when videoPlaybackRequiresUserGesture and audioPlaybackRequiresUserGesture is not set:
 516         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureForFullscreen);
 517     }
 518 #endif
 519 
 520 #if ENABLE(MEDIA_SESSION)
 521     m_elementID = nextElementID();
 522     elementIDsToElements().add(m_elementID, this);
 523 
 524     setSessionInternal(document.defaultMediaSession());
 525 #endif
 526 
 527     registerWithDocument(document);
 528 
 529 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 530     AudioSession::sharedSession().addMutedStateObserver(this);
 531 #endif
 532 
 533     mediaSession().clientWillBeginAutoplaying();
 534 }
 535 
<a name="10" id="anc10"></a>













 536 HTMLMediaElement::~HTMLMediaElement()
 537 {
<a name="11" id="anc11"></a>
 538     ALWAYS_LOG(LOGIDENTIFIER);
 539 
 540     beginIgnoringTrackDisplayUpdateRequests();
 541     allMediaElements().remove(this);
 542 
<a name="12" id="anc12"></a><span class="line-modified"> 543     m_asyncEventQueue-&gt;close();</span>
 544 
 545     setShouldDelayLoadEvent(false);
 546     unregisterWithDocument(document());
 547 
 548 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
 549     AudioSession::sharedSession().removeMutedStateObserver(this);
 550 #endif
 551 
 552 #if ENABLE(VIDEO_TRACK)
 553     if (m_audioTracks)
 554         m_audioTracks-&gt;clearElement();
 555     if (m_textTracks)
 556         m_textTracks-&gt;clearElement();
 557     if (m_videoTracks)
 558         m_videoTracks-&gt;clearElement();
 559 #endif
 560 
 561 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<a name="13" id="anc13"></a><span class="line-modified"> 562     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) || m_remote-&gt;hasAvailabilityCallbacks()) {</span>
 563         m_hasPlaybackTargetAvailabilityListeners = false;
 564         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
 565         updateMediaState();
 566     }
 567 #endif
 568 
 569     if (m_mediaController) {
 570         m_mediaController-&gt;removeMediaElement(*this);
 571         m_mediaController = nullptr;
 572     }
 573 
 574 #if ENABLE(MEDIA_SOURCE)
 575     detachMediaSource();
 576 #endif
 577 
 578 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
 579     webkitSetMediaKeys(nullptr);
 580 #endif
 581 
 582 #if ENABLE(ENCRYPTED_MEDIA)
 583     if (m_mediaKeys) {
 584         m_mediaKeys-&gt;detachCDMClient(*this);
 585         if (m_player)
 586             m_player-&gt;cdmInstanceDetached(m_mediaKeys-&gt;cdmInstance());
 587     }
 588 #endif
 589 
 590 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 591     if (m_isolatedWorld)
 592         m_isolatedWorld-&gt;clearWrappers();
 593 #endif
 594 
 595 #if ENABLE(MEDIA_SESSION)
 596     if (m_session) {
 597         m_session-&gt;removeMediaElement(*this);
 598         m_session = nullptr;
 599     }
 600 
 601     elementIDsToElements().remove(m_elementID);
 602 #endif
 603 
 604     m_seekTaskQueue.close();
 605     m_resumeTaskQueue.close();
 606     m_promiseTaskQueue.close();
 607     m_pauseAfterDetachedTaskQueue.close();
 608     m_playbackControlsManagerBehaviorRestrictionsQueue.close();
 609     m_resourceSelectionTaskQueue.close();
 610     m_visibilityChangeTaskQueue.close();
 611 #if ENABLE(ENCRYPTED_MEDIA)
 612     m_encryptedMediaQueue.close();
 613 #endif
 614 
 615     m_completelyLoaded = true;
 616 
 617     if (m_player) {
 618         m_player-&gt;invalidate();
 619         m_player = nullptr;
 620     }
 621 
 622     m_mediaSession = nullptr;
 623     schedulePlaybackControlsManagerUpdate();
 624 }
 625 RefPtr&lt;HTMLMediaElement&gt; HTMLMediaElement::bestMediaElementForShowingPlaybackControlsManager(MediaElementSession::PlaybackControlsPurpose purpose)
 626 {
 627     Vector&lt;MediaElementSessionInfo&gt; candidateSessions;
 628     bool atLeastOneNonCandidateMayBeConfusedForMainContent = false;
 629     PlatformMediaSessionManager::sharedManager().forEachMatchingSession([](auto&amp; session) {
 630         return is&lt;MediaElementSession&gt;(session);
 631     }, [&amp;](auto&amp; session) {
 632         auto mediaElementSessionInfo = mediaElementSessionInfoForSession(downcast&lt;MediaElementSession&gt;(session), purpose);
 633         if (mediaElementSessionInfo.canShowControlsManager)
 634             candidateSessions.append(mediaElementSessionInfo);
 635         else if (mediaSessionMayBeConfusedWithMainContent(mediaElementSessionInfo, purpose))
 636             atLeastOneNonCandidateMayBeConfusedForMainContent = true;
 637     });
 638 
 639     if (!candidateSessions.size())
 640         return nullptr;
 641 
 642     std::sort(candidateSessions.begin(), candidateSessions.end(), preferMediaControlsForCandidateSessionOverOtherCandidateSession);
 643     auto strongestSessionCandidate = candidateSessions.first();
 644     if (!strongestSessionCandidate.isVisibleInViewportOrFullscreen &amp;&amp; !strongestSessionCandidate.isPlayingAudio &amp;&amp; atLeastOneNonCandidateMayBeConfusedForMainContent)
 645         return nullptr;
 646 
 647     return &amp;strongestSessionCandidate.session-&gt;element();
 648 }
 649 
 650 void HTMLMediaElement::registerWithDocument(Document&amp; document)
 651 {
<a name="14" id="anc14"></a><span class="line-added"> 652     document.registerMediaElement(*this);</span>
<span class="line-added"> 653 </span>
 654     m_mediaSession-&gt;registerWithDocument(document);
 655 
 656     if (m_isWaitingUntilMediaCanStart)
 657         document.addMediaCanStartListener(*this);
 658 
<a name="15" id="anc15"></a>




 659     document.registerForVisibilityStateChangedCallbacks(*this);
 660 
 661 #if ENABLE(VIDEO_TRACK)
 662     if (m_requireCaptionPreferencesChangedCallbacks)
 663         document.registerForCaptionPreferencesChangedCallbacks(*this);
 664 #endif
 665 
<a name="16" id="anc16"></a>





 666 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 667     document.registerForDocumentSuspensionCallbacks(*this);
 668 #endif
 669 
<a name="17" id="anc17"></a>

 670     document.addAudioProducer(*this);
<a name="18" id="anc18"></a>






 671 }
 672 
 673 void HTMLMediaElement::unregisterWithDocument(Document&amp; document)
 674 {
<a name="19" id="anc19"></a><span class="line-added"> 675     document.unregisterMediaElement(*this);</span>
<span class="line-added"> 676 </span>
 677     m_mediaSession-&gt;unregisterWithDocument(document);
 678 
 679     if (m_isWaitingUntilMediaCanStart)
 680         document.removeMediaCanStartListener(*this);
 681 
<a name="20" id="anc20"></a>




 682     document.unregisterForVisibilityStateChangedCallbacks(*this);
 683 
 684 #if ENABLE(VIDEO_TRACK)
 685     if (m_requireCaptionPreferencesChangedCallbacks)
 686         document.unregisterForCaptionPreferencesChangedCallbacks(*this);
 687 #endif
 688 
<a name="21" id="anc21"></a>





 689 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
 690     document.unregisterForDocumentSuspensionCallbacks(*this);
 691 #endif
 692 
<a name="22" id="anc22"></a>

 693     document.removeAudioProducer(*this);
<a name="23" id="anc23"></a>






 694 }
 695 
 696 void HTMLMediaElement::didMoveToNewDocument(Document&amp; oldDocument, Document&amp; newDocument)
 697 {
 698     ASSERT_WITH_SECURITY_IMPLICATION(&amp;document() == &amp;newDocument);
 699     if (m_shouldDelayLoadEvent) {
 700         oldDocument.decrementLoadEventDelayCount();
 701         newDocument.incrementLoadEventDelayCount();
 702     }
 703 
 704     unregisterWithDocument(oldDocument);
 705     registerWithDocument(newDocument);
 706 
 707     HTMLElement::didMoveToNewDocument(oldDocument, newDocument);
 708     updateShouldAutoplay();
 709 }
 710 
 711 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<a name="24" id="anc24"></a><span class="line-added"> 712 </span>
 713 void HTMLMediaElement::prepareForDocumentSuspension()
 714 {
 715     m_mediaSession-&gt;unregisterWithDocument(document());
 716 }
 717 
 718 void HTMLMediaElement::resumeFromDocumentSuspension()
 719 {
 720     m_mediaSession-&gt;registerWithDocument(document());
 721     updateShouldAutoplay();
 722 }
<a name="25" id="anc25"></a><span class="line-added"> 723 </span>
 724 #endif
 725 
 726 bool HTMLMediaElement::supportsFocus() const
 727 {
 728     if (document().isMediaDocument())
 729         return false;
 730 
 731     // If no controls specified, we should still be able to focus the element if it has tabIndex.
 732     return controls() ||  HTMLElement::supportsFocus();
 733 }
 734 
 735 bool HTMLMediaElement::isMouseFocusable() const
 736 {
 737     return false;
 738 }
 739 
 740 bool HTMLMediaElement::isInteractiveContent() const
 741 {
 742     return controls();
 743 }
 744 
 745 void HTMLMediaElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 746 {
 747     if (name == srcAttr) {
 748         // https://html.spec.whatwg.org/multipage/embedded-content.html#location-of-the-media-resource
 749         // Location of the Media Resource
 750         // 12 February 2017
 751 
 752         // If a src attribute of a media element is set or changed, the user
 753         // agent must invoke the media element&#39;s media element load algorithm.
 754         if (!value.isNull())
 755             prepareForLoad();
 756     } else if (name == controlsAttr)
 757         configureMediaControls();
 758     else if (name == loopAttr)
 759         updateSleepDisabling();
 760     else if (name == preloadAttr) {
 761         if (equalLettersIgnoringASCIICase(value, &quot;none&quot;))
<a name="26" id="anc26"></a><span class="line-modified"> 762             m_preload = MediaPlayer::Preload::None;</span>
 763         else if (equalLettersIgnoringASCIICase(value, &quot;metadata&quot;))
<a name="27" id="anc27"></a><span class="line-modified"> 764             m_preload = MediaPlayer::Preload::MetaData;</span>
 765         else {
 766             // The spec does not define an &quot;invalid value default&quot; but &quot;auto&quot; is suggested as the
 767             // &quot;missing value default&quot;, so use it for everything except &quot;none&quot; and &quot;metadata&quot;
<a name="28" id="anc28"></a><span class="line-modified"> 768             m_preload = MediaPlayer::Preload::Auto;</span>
 769         }
 770 
 771         // The attribute must be ignored if the autoplay attribute is present
 772         if (!autoplay() &amp;&amp; !m_havePreparedToPlay &amp;&amp; m_player)
 773             m_player-&gt;setPreload(m_mediaSession-&gt;effectivePreloadForElement());
 774 
 775     } else if (name == mediagroupAttr)
 776         setMediaGroup(value);
 777     else if (name == autoplayAttr) {
 778         if (processingUserGestureForMedia())
 779             removeBehaviorRestrictionsAfterFirstUserGesture();
 780     } else if (name == titleAttr) {
 781         if (m_mediaSession)
 782             m_mediaSession-&gt;clientCharacteristicsChanged();
 783     }
 784     else
 785         HTMLElement::parseAttribute(name, value);
 786 }
 787 
 788 void HTMLMediaElement::finishParsingChildren()
 789 {
 790     HTMLElement::finishParsingChildren();
 791     m_parsingInProgress = false;
 792 
 793 #if ENABLE(VIDEO_TRACK)
 794     if (childrenOfType&lt;HTMLTrackElement&gt;(*this).first())
 795         scheduleConfigureTextTracks();
 796 #endif
 797 }
 798 
 799 bool HTMLMediaElement::rendererIsNeeded(const RenderStyle&amp; style)
 800 {
 801     return controls() &amp;&amp; HTMLElement::rendererIsNeeded(style);
 802 }
 803 
 804 RenderPtr&lt;RenderElement&gt; HTMLMediaElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp;)
 805 {
 806     return createRenderer&lt;RenderMedia&gt;(*this, WTFMove(style));
 807 }
 808 
 809 bool HTMLMediaElement::childShouldCreateRenderer(const Node&amp; child) const
 810 {
 811 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
 812     return hasShadowRootParent(child) &amp;&amp; HTMLElement::childShouldCreateRenderer(child);
 813 #else
 814     if (!hasMediaControls())
 815         return false;
 816     // &lt;media&gt; doesn&#39;t allow its content, including shadow subtree, to
 817     // be rendered. So this should return false for most of the children.
 818     // One exception is a shadow tree built for rendering controls which should be visible.
 819     // So we let them go here by comparing its subtree root with one of the controls.
 820     return &amp;mediaControls()-&gt;treeScope() == &amp;child.treeScope()
 821         &amp;&amp; hasShadowRootParent(child)
 822         &amp;&amp; HTMLElement::childShouldCreateRenderer(child);
 823 #endif
 824 }
 825 
 826 Node::InsertedIntoAncestorResult HTMLMediaElement::insertedIntoAncestor(InsertionType insertionType, ContainerNode&amp; parentOfInsertedTree)
 827 {
 828     INFO_LOG(LOGIDENTIFIER);
 829 
 830     HTMLElement::insertedIntoAncestor(insertionType, parentOfInsertedTree);
 831     if (insertionType.connectedToDocument)
 832         setInActiveDocument(true);
 833 
 834     return InsertedIntoAncestorResult::NeedsPostInsertionCallback;
 835 }
 836 
 837 void HTMLMediaElement::didFinishInsertingNode()
 838 {
 839     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // prepareForLoad may result in a &#39;beforeload&#39; event, which can make arbitrary DOM mutations.
 840 
 841     INFO_LOG(LOGIDENTIFIER);
 842 
 843     if (m_inActiveDocument &amp;&amp; m_networkState == NETWORK_EMPTY &amp;&amp; !attributeWithoutSynchronization(srcAttr).isEmpty())
 844         prepareForLoad();
 845 
 846     if (!m_explicitlyMuted) {
 847         m_explicitlyMuted = true;
 848         m_muted = hasAttributeWithoutSynchronization(mutedAttr);
 849         m_mediaSession-&gt;canProduceAudioChanged();
 850     }
 851 
 852     configureMediaControls();
 853 }
 854 
 855 void HTMLMediaElement::pauseAfterDetachedTask()
 856 {
 857     // If we were re-inserted into an active document, no need to pause.
 858     if (m_inActiveDocument)
 859         return;
 860 
 861     if (hasMediaControls())
 862         mediaControls()-&gt;hide();
 863     if (m_networkState &gt; NETWORK_EMPTY)
 864         pause();
 865     if (m_videoFullscreenMode != VideoFullscreenModeNone)
 866         exitFullscreen();
 867 
 868     if (!m_player)
 869         return;
 870 
 871     size_t extraMemoryCost = m_player-&gt;extraMemoryCost();
 872     if (extraMemoryCost &gt; m_reportedExtraMemoryCost) {
 873         JSC::VM&amp; vm = commonVM();
 874         JSC::JSLockHolder lock(vm);
 875 
 876         size_t extraMemoryCostDelta = extraMemoryCost - m_reportedExtraMemoryCost;
 877         m_reportedExtraMemoryCost = extraMemoryCost;
 878         // FIXME: Adopt reportExtraMemoryVisited, and switch to reportExtraMemoryAllocated.
 879         // https://bugs.webkit.org/show_bug.cgi?id=142595
 880         vm.heap.deprecatedReportExtraMemory(extraMemoryCostDelta);
 881     }
 882 }
 883 
 884 void HTMLMediaElement::removedFromAncestor(RemovalType removalType, ContainerNode&amp; oldParentOfRemovedTree)
 885 {
 886     INFO_LOG(LOGIDENTIFIER);
 887 
 888     setInActiveDocument(false);
 889     if (removalType.disconnectedFromDocument) {
 890         // Pause asynchronously to let the operation that removed us finish, in case we get inserted back into a document.
 891         m_pauseAfterDetachedTaskQueue.enqueueTask(std::bind(&amp;HTMLMediaElement::pauseAfterDetachedTask, this));
 892     }
 893 
 894     if (m_mediaSession)
 895         m_mediaSession-&gt;clientCharacteristicsChanged();
 896 
 897     HTMLElement::removedFromAncestor(removalType, oldParentOfRemovedTree);
 898 }
 899 
 900 void HTMLMediaElement::willAttachRenderers()
 901 {
 902     ASSERT(!renderer());
 903 }
 904 
 905 inline void HTMLMediaElement::updateRenderer()
 906 {
 907     if (auto* renderer = this-&gt;renderer())
 908         renderer-&gt;updateFromElement();
<a name="29" id="anc29"></a><span class="line-added"> 909 </span>
<span class="line-added"> 910 #if ENABLE(MEDIA_CONTROLS_SCRIPT)</span>
<span class="line-added"> 911     if (m_mediaControlsHost)</span>
<span class="line-added"> 912         m_mediaControlsHost-&gt;updateCaptionDisplaySizes();</span>
<span class="line-added"> 913 #endif</span>
 914 }
 915 
 916 void HTMLMediaElement::didAttachRenderers()
 917 {
 918     if (auto* renderer = this-&gt;renderer()) {
 919         renderer-&gt;updateFromElement();
 920         if (m_mediaSession &amp;&amp; m_mediaSession-&gt;wantsToObserveViewportVisibilityForAutoplay())
 921             renderer-&gt;registerForVisibleInViewportCallback();
 922     }
 923     updateShouldAutoplay();
 924 }
 925 
 926 void HTMLMediaElement::willDetachRenderers()
 927 {
 928     if (auto* renderer = this-&gt;renderer())
 929         renderer-&gt;unregisterForVisibleInViewportCallback();
 930 }
 931 
 932 void HTMLMediaElement::didDetachRenderers()
 933 {
 934     updateShouldAutoplay();
 935 }
 936 
 937 void HTMLMediaElement::didRecalcStyle(Style::Change)
 938 {
 939     updateRenderer();
 940 }
 941 
 942 void HTMLMediaElement::scheduleNextSourceChild()
 943 {
 944     // Schedule the timer to try the next &lt;source&gt; element WITHOUT resetting state ala prepareForLoad.
 945     m_resourceSelectionTaskQueue.enqueueTask([this] {
 946         loadNextSourceChild();
 947     });
 948 }
 949 
<a name="30" id="anc30"></a><span class="line-modified"> 950 void HTMLMediaElement::mediaPlayerActiveSourceBuffersChanged()</span>
 951 {
 952     m_hasEverHadAudio |= hasAudio();
 953     m_hasEverHadVideo |= hasVideo();
 954 }
 955 
 956 void HTMLMediaElement::scheduleEvent(const AtomString&amp; eventName)
 957 {
 958     auto event = Event::create(eventName, Event::CanBubble::No, Event::IsCancelable::Yes);
 959 
 960     // Don&#39;t set the event target, the event queue will set it in GenericEventQueue::timerFired and setting it here
 961     // will trigger an ASSERT if this element has been marked for deletion.
 962 
<a name="31" id="anc31"></a><span class="line-modified"> 963     m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
<span class="line-added"> 964 }</span>
<span class="line-added"> 965 </span>
<span class="line-added"> 966 #if ENABLE(PICTURE_IN_PICTURE_API)</span>
<span class="line-added"> 967 void HTMLMediaElement::scheduleEvent(Ref&lt;Event&gt;&amp;&amp; event)</span>
<span class="line-added"> 968 {</span>
<span class="line-added"> 969     m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
 970 }
<a name="32" id="anc32"></a><span class="line-added"> 971 #endif</span>
 972 
 973 void HTMLMediaElement::scheduleResolvePendingPlayPromises()
 974 {
 975     m_promiseTaskQueue.enqueueTask([this, pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
 976         resolvePendingPlayPromises(WTFMove(pendingPlayPromises));
 977     });
 978 }
 979 
 980 void HTMLMediaElement::scheduleRejectPendingPlayPromises(Ref&lt;DOMException&gt;&amp;&amp; error)
 981 {
 982     m_promiseTaskQueue.enqueueTask([this, error = WTFMove(error), pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
 983         rejectPendingPlayPromises(WTFMove(pendingPlayPromises), WTFMove(error));
 984     });
 985 }
 986 
 987 void HTMLMediaElement::rejectPendingPlayPromises(PlayPromiseVector&amp;&amp; pendingPlayPromises, Ref&lt;DOMException&gt;&amp;&amp; error)
 988 {
 989     for (auto&amp; promise : pendingPlayPromises)
 990         promise.rejectType&lt;IDLInterface&lt;DOMException&gt;&gt;(error);
 991 }
 992 
 993 void HTMLMediaElement::resolvePendingPlayPromises(PlayPromiseVector&amp;&amp; pendingPlayPromises)
 994 {
 995     for (auto&amp; promise : pendingPlayPromises)
 996         promise.resolve();
 997 }
 998 
 999 void HTMLMediaElement::scheduleNotifyAboutPlaying()
1000 {
1001     m_promiseTaskQueue.enqueueTask([this, pendingPlayPromises = WTFMove(m_pendingPlayPromises)] () mutable {
1002         notifyAboutPlaying(WTFMove(pendingPlayPromises));
1003     });
1004 }
1005 
1006 void HTMLMediaElement::notifyAboutPlaying(PlayPromiseVector&amp;&amp; pendingPlayPromises)
1007 {
1008     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // The &#39;playing&#39; event can make arbitrary DOM mutations.
1009     m_playbackStartedTime = currentMediaTime().toDouble();
1010     m_hasEverNotifiedAboutPlaying = true;
1011     dispatchEvent(Event::create(eventNames().playingEvent, Event::CanBubble::No, Event::IsCancelable::Yes));
1012     resolvePendingPlayPromises(WTFMove(pendingPlayPromises));
1013 
1014     schedulePlaybackControlsManagerUpdate();
1015 }
1016 
1017 bool HTMLMediaElement::hasEverNotifiedAboutPlaying() const
1018 {
1019     return m_hasEverNotifiedAboutPlaying;
1020 }
1021 
1022 void HTMLMediaElement::scheduleCheckPlaybackTargetCompatability()
1023 {
1024     if (m_checkPlaybackTargetCompatablityTask.hasPendingTask())
1025         return;
1026 
1027     auto logSiteIdentifier = LOGIDENTIFIER;
1028     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
1029     m_checkPlaybackTargetCompatablityTask.scheduleTask([this, logSiteIdentifier] {
1030         UNUSED_PARAM(logSiteIdentifier);
1031         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
1032         checkPlaybackTargetCompatablity();
1033     });
1034 }
1035 
1036 void HTMLMediaElement::checkPlaybackTargetCompatablity()
1037 {
1038 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1039     auto logSiteIdentifier = LOGIDENTIFIER;
1040     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
1041     if (m_isPlayingToWirelessTarget &amp;&amp; !m_player-&gt;canPlayToWirelessPlaybackTarget()) {
1042         UNUSED_PARAM(logSiteIdentifier);
1043         INFO_LOG(logSiteIdentifier, &quot;calling setShouldPlayToPlaybackTarget(false)&quot;);
1044         m_failedToPlayToWirelessTarget = true;
1045         m_player-&gt;setShouldPlayToPlaybackTarget(false);
1046     }
1047 #endif
1048 }
1049 
1050 MediaError* HTMLMediaElement::error() const
1051 {
1052     return m_error.get();
1053 }
1054 
1055 void HTMLMediaElement::setSrcObject(MediaProvider&amp;&amp; mediaProvider)
1056 {
1057     // FIXME: Setting the srcObject attribute may cause other changes to the media element&#39;s internal state:
1058     // Specifically, if srcObject is specified, the UA must use it as the source of media, even if the src
1059     // attribute is also set or children are present. If the value of srcObject is replaced or set to null
1060     // the UA must re-run the media element load algorithm.
1061     //
1062     // https://bugs.webkit.org/show_bug.cgi?id=124896
1063 
1064 
1065     // https://www.w3.org/TR/html51/semantics-embedded-content.html#dom-htmlmediaelement-srcobject
1066     // 4.7.14.2. Location of the media resource
1067     // srcObject: On setting, it must set the element’s assigned media provider object to the new
1068     // value, and then invoke the element’s media element load algorithm.
1069     INFO_LOG(LOGIDENTIFIER);
1070     m_mediaProvider = WTFMove(mediaProvider);
1071     prepareForLoad();
1072 }
1073 
1074 void HTMLMediaElement::setCrossOrigin(const AtomString&amp; value)
1075 {
1076     setAttributeWithoutSynchronization(crossoriginAttr, value);
1077 }
1078 
1079 String HTMLMediaElement::crossOrigin() const
1080 {
1081     return parseCORSSettingsAttribute(attributeWithoutSynchronization(crossoriginAttr));
1082 }
1083 
1084 HTMLMediaElement::NetworkState HTMLMediaElement::networkState() const
1085 {
1086     return m_networkState;
1087 }
1088 
1089 String HTMLMediaElement::canPlayType(const String&amp; mimeType) const
1090 {
1091     MediaEngineSupportParameters parameters;
1092     ContentType contentType(mimeType);
1093     parameters.type = contentType;
1094     parameters.contentTypesRequiringHardwareSupport = mediaContentTypesRequiringHardwareSupport();
1095     MediaPlayer::SupportsType support = MediaPlayer::supportsType(parameters);
1096     String canPlay;
1097 
1098     // 4.8.10.3
1099     switch (support)
1100     {
<a name="33" id="anc33"></a><span class="line-modified">1101         case MediaPlayer::SupportsType::IsNotSupported:</span>
1102             canPlay = emptyString();
1103             break;
<a name="34" id="anc34"></a><span class="line-modified">1104         case MediaPlayer::SupportsType::MayBeSupported:</span>
1105             canPlay = &quot;maybe&quot;_s;
1106             break;
<a name="35" id="anc35"></a><span class="line-modified">1107         case MediaPlayer::SupportsType::IsSupported:</span>
1108             canPlay = &quot;probably&quot;_s;
1109             break;
1110     }
1111 
1112     INFO_LOG(LOGIDENTIFIER, mimeType, &quot;: &quot;, canPlay);
1113 
1114     return canPlay;
1115 }
1116 
1117 double HTMLMediaElement::getStartDate() const
1118 {
1119     if (!m_player)
1120         return std::numeric_limits&lt;double&gt;::quiet_NaN();
1121     return m_player-&gt;getStartDate().toDouble();
1122 }
1123 
1124 void HTMLMediaElement::load()
1125 {
1126     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // prepareForLoad may result in a &#39;beforeload&#39; event, which can make arbitrary DOM mutations.
1127 
1128     INFO_LOG(LOGIDENTIFIER);
1129 
1130     prepareForLoad();
1131     m_resourceSelectionTaskQueue.enqueueTask([this] {
1132         prepareToPlay();
1133     });
1134 }
1135 
1136 void HTMLMediaElement::prepareForLoad()
1137 {
1138     // https://html.spec.whatwg.org/multipage/embedded-content.html#media-element-load-algorithm
1139     // The Media Element Load Algorithm
1140     // 12 February 2017
1141 
1142     ALWAYS_LOG(LOGIDENTIFIER, &quot;gesture = &quot;, processingUserGestureForMedia());
1143 
1144     if (processingUserGestureForMedia())
1145         removeBehaviorRestrictionsAfterFirstUserGesture();
1146 
1147     // 1 - Abort any already-running instance of the resource selection algorithm for this element.
1148     // Perform the cleanup required for the resource load algorithm to run.
1149     stopPeriodicTimers();
1150     m_resourceSelectionTaskQueue.cancelAllTasks();
1151     // FIXME: Figure out appropriate place to reset LoadTextTrackResource if necessary and set m_pendingActionFlags to 0 here.
1152     m_sentEndEvent = false;
1153     m_sentStalledEvent = false;
1154     m_haveFiredLoadedData = false;
1155     m_completelyLoaded = false;
1156     m_havePreparedToPlay = false;
1157     m_displayMode = Unknown;
1158     m_currentSrc = URL();
1159 
1160 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
1161     m_failedToPlayToWirelessTarget = false;
1162 #endif
1163 
1164     m_loadState = WaitingForSource;
1165     m_currentSourceNode = nullptr;
1166 
1167     if (!document().hasBrowsingContext())
1168         return;
1169 
1170     createMediaPlayer();
1171 
1172     // 2 - Let pending tasks be a list of all tasks from the media element&#39;s media element event task source in one of the task queues.
1173     // 3 - For each task in pending tasks that would resolve pending play promises or reject pending play promises, immediately resolve or reject those promises in the order the corresponding tasks were queued.
1174     // 4 - Remove each task in pending tasks from its task queue
1175     cancelPendingEventsAndCallbacks();
1176 
1177     // 5 - If the media element&#39;s networkState is set to NETWORK_LOADING or NETWORK_IDLE, queue
1178     // a task to fire a simple event named abort at the media element.
1179     if (m_networkState == NETWORK_LOADING || m_networkState == NETWORK_IDLE)
1180         scheduleEvent(eventNames().abortEvent);
1181 
1182     // 6 - If the media element&#39;s networkState is not set to NETWORK_EMPTY, then run these substeps
1183     if (m_networkState != NETWORK_EMPTY) {
1184         // 6.1 - Queue a task to fire a simple event named emptied at the media element.
1185         scheduleEvent(eventNames().emptiedEvent);
1186 
1187         // 6.2 - If a fetching process is in progress for the media element, the user agent should stop it.
1188         m_networkState = NETWORK_EMPTY;
1189 
1190         // 6.3 - If the media element’s assigned media provider object is a MediaSource object, then detach it.
1191 #if ENABLE(MEDIA_SOURCE)
1192         detachMediaSource();
1193 #endif
1194 
<a name="36" id="anc36"></a><span class="line-added">1195 #if ENABLE(VIDEO_TRACK)</span>
1196         // 6.4 - Forget the media element&#39;s media-resource-specific tracks.
1197         forgetResourceSpecificTracks();
<a name="37" id="anc37"></a><span class="line-added">1198 #endif</span>
1199 
1200         // 6.5 - If readyState is not set to HAVE_NOTHING, then set it to that state.
1201         m_readyState = HAVE_NOTHING;
1202         m_readyStateMaximum = HAVE_NOTHING;
1203 
1204         // 6.6 - If the paused attribute is false, then set it to true.
1205         m_paused = true;
1206 
1207         // 6.7 - If seeking is true, set it to false.
1208         clearSeeking();
1209 
1210         // 6.8 - Set the current playback position to 0.
1211         //       Set the official playback position to 0.
1212         //       If this changed the official playback position, then queue a task to fire a simple event named timeupdate at the media element.
1213         m_lastSeekTime = MediaTime::zeroTime();
1214         m_playedTimeRanges = TimeRanges::create();
1215         // FIXME: Add support for firing this event. e.g., scheduleEvent(eventNames().timeUpdateEvent);
1216 
1217         // 4.9 - Set the initial playback position to 0.
1218         // FIXME: Make this less subtle. The position only becomes 0 because of the createMediaPlayer() call
1219         // above.
1220         refreshCachedTime();
1221 
1222         invalidateCachedTime();
1223 
1224         // 4.10 - Set the timeline offset to Not-a-Number (NaN).
1225         // 4.11 - Update the duration attribute to Not-a-Number (NaN).
1226 
1227         updateMediaController();
1228 #if ENABLE(VIDEO_TRACK)
1229         updateActiveTextTrackCues(MediaTime::zeroTime());
1230 #endif
1231     }
1232 
1233     // 7 - Set the playbackRate attribute to the value of the defaultPlaybackRate attribute.
1234     setPlaybackRate(defaultPlaybackRate());
1235 
1236     // 8 - Set the error attribute to null and the autoplaying flag to true.
1237     m_error = nullptr;
1238     m_autoplaying = true;
1239     mediaSession().clientWillBeginAutoplaying();
1240 
1241     if (!MediaPlayer::isAvailable())
1242         noneSupported();
1243     else {
1244         // 9 - Invoke the media element&#39;s resource selection algorithm.
1245         // Note, unless the restriction on requiring user action has been removed,
1246         // do not begin downloading data.
1247         if (m_mediaSession-&gt;dataLoadingPermitted())
1248             selectMediaResource();
1249     }
1250 
1251     // 10 - Note: Playback of any previously playing media resource for this element stops.
1252 
1253     configureMediaControls();
1254 }
1255 
1256 void HTMLMediaElement::selectMediaResource()
1257 {
1258     // https://www.w3.org/TR/2016/REC-html51-20161101/semantics-embedded-content.html#resource-selection-algorithm
1259     // The Resource Selection Algorithm
1260 
1261     // 1. Set the element’s networkState attribute to the NETWORK_NO_SOURCE value.
1262     m_networkState = NETWORK_NO_SOURCE;
1263 
1264     // 2. Set the element’s show poster flag to true.
1265     setDisplayMode(Poster);
1266 
1267     // 3. Set the media element’s delaying-the-load-event flag to true (this delays the load event).
1268     setShouldDelayLoadEvent(true);
1269 
1270     // 4. in parallel await a stable state, allowing the task that invoked this algorithm to continue.
1271     if (m_resourceSelectionTaskQueue.hasPendingTasks())
1272         return;
1273 
1274     if (!m_mediaSession-&gt;pageAllowsDataLoading()) {
1275         ALWAYS_LOG(LOGIDENTIFIER, &quot;not allowed to load in background, waiting&quot;);
1276         setShouldDelayLoadEvent(false);
1277         if (m_isWaitingUntilMediaCanStart)
1278             return;
1279         m_isWaitingUntilMediaCanStart = true;
1280         document().addMediaCanStartListener(*this);
1281         return;
1282     }
1283 
1284     // Once the page has allowed an element to load media, it is free to load at will. This allows a
1285     // playlist that starts in a foreground tab to continue automatically if the tab is subsequently
1286     // put into the background.
1287     m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePageConsentToLoadMedia);
1288 
1289     auto logSiteIdentifier = LOGIDENTIFIER;
1290     UNUSED_PARAM(logSiteIdentifier);
1291 
1292     m_resourceSelectionTaskQueue.enqueueTask([this, logSiteIdentifier]  {
1293 
1294         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
1295 
1296         // 5. If the media element’s blocked-on-parser flag is false, then populate the list of pending text tracks.
1297 #if ENABLE(VIDEO_TRACK)
1298         if (hasMediaControls())
1299             mediaControls()-&gt;changedClosedCaptionsVisibility();
1300 
1301         // HTMLMediaElement::textTracksAreReady will need &quot;... the text tracks whose mode was not in the
1302         // disabled state when the element&#39;s resource selection algorithm last started&quot;.
1303         // FIXME: Update this to match &quot;populate the list of pending text tracks&quot; step.
1304         m_textTracksWhenResourceSelectionBegan.clear();
1305         if (m_textTracks) {
1306             for (unsigned i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
1307                 RefPtr&lt;TextTrack&gt; track = m_textTracks-&gt;item(i);
1308                 if (track-&gt;mode() != TextTrack::Mode::Disabled)
1309                     m_textTracksWhenResourceSelectionBegan.append(track);
1310             }
1311         }
1312 #endif
1313 
1314         enum Mode { None, Object, Attribute, Children };
1315         Mode mode = None;
1316 
1317         if (m_mediaProvider) {
1318             // 6. If the media element has an assigned media provider object, then let mode be object.
1319             mode = Object;
1320         } else if (hasAttributeWithoutSynchronization(srcAttr)) {
1321             //    Otherwise, if the media element has no assigned media provider object but has a src attribute, then let mode be attribute.
1322             mode = Attribute;
1323             ASSERT(m_player);
1324             if (!m_player) {
1325                 ERROR_LOG(logSiteIdentifier, &quot; has srcAttr but m_player is not created&quot;);
1326                 return;
1327             }
1328         } else if (auto firstSource = childrenOfType&lt;HTMLSourceElement&gt;(*this).first()) {
1329             //    Otherwise, if the media element does not have an assigned media provider object and does not have a src attribute,
1330             //    but does have a source element child, then let mode be children and let candidate be the first such source element
1331             //    child in tree order.
1332             mode = Children;
1333             m_nextChildNodeToConsider = firstSource;
1334             m_currentSourceNode = nullptr;
1335         } else {
1336             //  Otherwise the media element has no assigned media provider object and has neither a src attribute nor a source
1337             //  element child: set the networkState to NETWORK_EMPTY, and abort these steps; the synchronous section ends.
1338             m_loadState = WaitingForSource;
1339             setShouldDelayLoadEvent(false);
1340             m_networkState = NETWORK_EMPTY;
1341 
1342             ALWAYS_LOG(logSiteIdentifier, &quot;nothing to load&quot;);
1343             return;
1344         }
1345 
1346         // 7. Set the media element’s networkState to NETWORK_LOADING.
1347         m_networkState = NETWORK_LOADING;
1348 
1349         // 8. Queue a task to fire a simple event named loadstart at the media element.
1350         scheduleEvent(eventNames().loadstartEvent);
1351 
1352         // 9. Run the appropriate steps from the following list:
1353         // ↳ If mode is object
1354         if (mode == Object) {
1355             // 1. Set the currentSrc attribute to the empty string.
1356             m_currentSrc = URL();
1357 
1358             // 2. End the synchronous section, continuing the remaining steps in parallel.
1359             // 3. Run the resource fetch algorithm with the assigned media provider object.
1360             switchOn(m_mediaProvider.value(),
1361 #if ENABLE(MEDIA_STREAM)
1362                 [this](RefPtr&lt;MediaStream&gt; stream) { m_mediaStreamSrcObject = stream; },
1363 #endif
1364 #if ENABLE(MEDIA_SOURCE)
1365                 [this](RefPtr&lt;MediaSource&gt; source) { m_mediaSource = source; },
1366 #endif
1367                 [this](RefPtr&lt;Blob&gt; blob) { m_blob = blob; }
1368             );
1369 
1370             ContentType contentType;
1371             loadResource(URL(), contentType, String());
1372             ALWAYS_LOG(logSiteIdentifier, &quot;using &#39;srcObject&#39; property&quot;);
1373 
1374             //    If that algorithm returns without aborting this one, then the load failed.
1375             // 4. Failed with media provider: Reaching this step indicates that the media resource
1376             //    failed to load. Queue a task to run the dedicated media source failure steps.
1377             // 5. Wait for the task queued by the previous step to have executed.
1378             // 6. Abort these steps. The element won’t attempt to load another resource until this
1379             //    algorithm is triggered again.
1380             return;
1381         }
1382 
1383         // ↳ If mode is attribute
1384         if (mode == Attribute) {
1385             m_loadState = LoadingFromSrcAttr;
1386 
1387             // 1. If the src attribute’s value is the empty string, then end the synchronous section,
1388             //    and jump down to the failed with attribute step below.
1389             // 2. Let absolute URL be the absolute URL that would have resulted from parsing the URL
1390             //    specified by the src attribute’s value relative to the media element when the src
1391             //    attribute was last changed.
1392             URL absoluteURL = getNonEmptyURLAttribute(srcAttr);
1393             if (absoluteURL.isEmpty()) {
<a name="38" id="anc38"></a><span class="line-modified">1394                 mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1395                 ALWAYS_LOG(logSiteIdentifier, &quot;empty &#39;src&#39;&quot;);
1396                 return;
1397             }
1398 
1399             if (!isSafeToLoadURL(absoluteURL, Complain) || !dispatchBeforeLoadEvent(absoluteURL.string())) {
<a name="39" id="anc39"></a><span class="line-modified">1400                 mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1401                 return;
1402             }
1403 
1404             // 3. If absolute URL was obtained successfully, set the currentSrc attribute to absolute URL.
1405             m_currentSrc = absoluteURL;
1406 
1407             // 4. End the synchronous section, continuing the remaining steps in parallel.
1408             // 5. If absolute URL was obtained successfully, run the resource fetch algorithm with absolute
1409             //    URL. If that algorithm returns without aborting this one, then the load failed.
1410 
1411             // No type or key system information is available when the url comes
1412             // from the &#39;src&#39; attribute so MediaPlayer
1413             // will have to pick a media engine based on the file extension.
1414             ContentType contentType;
1415             loadResource(absoluteURL, contentType, String());
1416             ALWAYS_LOG(logSiteIdentifier, &quot;using &#39;src&#39; attribute url&quot;);
1417 
1418             // 6. Failed with attribute: Reaching this step indicates that the media resource failed to load
1419             //    or that the given URL could not be resolved. Queue a task to run the dedicated media source failure steps.
1420             // 7. Wait for the task queued by the previous step to have executed.
1421             // 8. Abort these steps. The element won’t attempt to load another resource until this algorithm is triggered again.
1422             return;
1423         }
1424 
1425         // ↳ Otherwise (mode is children)
1426         // (Ctd. in loadNextSourceChild())
1427         loadNextSourceChild();
1428     });
1429 }
1430 
1431 void HTMLMediaElement::loadNextSourceChild()
1432 {
1433     ContentType contentType;
1434     String keySystem;
1435     URL mediaURL = selectNextSourceChild(&amp;contentType, &amp;keySystem, Complain);
1436     if (!mediaURL.isValid()) {
1437         waitForSourceChange();
1438         return;
1439     }
1440 
1441     // Recreate the media player for the new url
1442     createMediaPlayer();
1443 
1444     m_loadState = LoadingFromSourceElement;
1445     loadResource(mediaURL, contentType, keySystem);
1446 }
1447 
1448 void HTMLMediaElement::loadResource(const URL&amp; initialURL, ContentType&amp; contentType, const String&amp; keySystem)
1449 {
1450     ASSERT(initialURL.isEmpty() || isSafeToLoadURL(initialURL, Complain));
1451 
1452     INFO_LOG(LOGIDENTIFIER, initialURL, contentType, keySystem);
1453 
1454     RefPtr&lt;Frame&gt; frame = document().frame();
1455     if (!frame) {
<a name="40" id="anc40"></a><span class="line-modified">1456         mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1457         return;
1458     }
1459 
1460     Page* page = frame-&gt;page();
1461     if (!page) {
<a name="41" id="anc41"></a><span class="line-modified">1462         mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1463         return;
1464     }
1465 
1466     URL url = initialURL;
1467     if (!url.isEmpty() &amp;&amp; !frame-&gt;loader().willLoadMediaElementURL(url, *this)) {
<a name="42" id="anc42"></a><span class="line-modified">1468         mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1469         return;
1470     }
1471 
1472 #if ENABLE(CONTENT_EXTENSIONS)
1473     if (auto documentLoader = makeRefPtr(frame-&gt;loader().documentLoader())) {
1474         if (page-&gt;userContentProvider().processContentRuleListsForLoad(url, ContentExtensions::ResourceType::Media, *documentLoader).summary.blockedLoad) {
<a name="43" id="anc43"></a><span class="line-modified">1475             mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1476             return;
1477         }
1478     }
1479 #endif
1480 
1481     // The resource fetch algorithm
1482     m_networkState = NETWORK_LOADING;
1483 
1484     // If the URL should be loaded from the application cache, pass the URL of the cached file to the media engine.
1485     ApplicationCacheResource* resource = nullptr;
1486     if (!url.isEmpty() &amp;&amp; frame-&gt;loader().documentLoader()-&gt;applicationCacheHost().shouldLoadResourceFromApplicationCache(ResourceRequest(url), resource)) {
1487         // Resources that are not present in the manifest will always fail to load (at least, after the
1488         // cache has been primed the first time), making the testing of offline applications simpler.
1489         if (!resource || resource-&gt;path().isEmpty()) {
<a name="44" id="anc44"></a><span class="line-modified">1490             mediaLoadingFailed(MediaPlayer::NetworkState::NetworkError);</span>
1491             return;
1492         }
1493     }
1494 
1495     // Log that we started loading a media element.
1496     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(isVideo() ? DiagnosticLoggingKeys::videoKey() : DiagnosticLoggingKeys::audioKey(), DiagnosticLoggingKeys::loadingKey(), ShouldSample::No);
1497 
1498     m_firstTimePlaying = true;
1499 
1500     // Set m_currentSrc *before* changing to the cache URL, the fact that we are loading from the app
1501     // cache is an internal detail not exposed through the media element API.
1502     m_currentSrc = url;
1503 
1504     if (resource) {
1505         url = ApplicationCacheHost::createFileURL(resource-&gt;path());
1506         INFO_LOG(LOGIDENTIFIER, &quot;will load from app cache &quot;, url);
1507     }
1508 
1509     INFO_LOG(LOGIDENTIFIER, &quot;m_currentSrc is &quot;, m_currentSrc);
1510 
1511     startProgressEventTimer();
1512 
1513     bool privateMode = document().page() &amp;&amp; document().page()-&gt;usesEphemeralSession();
1514     m_player-&gt;setPrivateBrowsingMode(privateMode);
1515 
1516     // Reset display mode to force a recalculation of what to show because we are resetting the player.
1517     setDisplayMode(Unknown);
1518 
1519     if (!autoplay() &amp;&amp; !m_havePreparedToPlay)
1520         m_player-&gt;setPreload(m_mediaSession-&gt;effectivePreloadForElement());
1521     m_player-&gt;setPreservesPitch(m_webkitPreservesPitch);
1522 
1523     if (!m_explicitlyMuted) {
1524         m_explicitlyMuted = true;
1525         m_muted = hasAttributeWithoutSynchronization(mutedAttr);
1526         m_mediaSession-&gt;canProduceAudioChanged();
1527     }
1528 
1529     updateVolume();
1530 
1531     bool loadAttempted = false;
1532 #if ENABLE(MEDIA_SOURCE)
1533     if (!m_mediaSource &amp;&amp; url.protocolIs(mediaSourceBlobProtocol))
1534         m_mediaSource = MediaSource::lookup(url.string());
1535 
1536     if (m_mediaSource) {
1537         loadAttempted = true;
1538 
1539         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading MSE blob&quot;);
<a name="45" id="anc45"></a><span class="line-modified">1540         if (!m_mediaSource-&gt;attachToElement(*this)) {</span>
1541             // Forget our reference to the MediaSource, so we leave it alone
1542             // while processing remainder of load failure.
1543             m_mediaSource = nullptr;
<a name="46" id="anc46"></a><span class="line-modified">1544             mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
<span class="line-added">1545         } else if (!m_player-&gt;load(url, contentType, m_mediaSource.get())) {</span>
<span class="line-added">1546             // We have to detach the MediaSource before we forget the reference to it.</span>
<span class="line-added">1547             m_mediaSource-&gt;detachFromElement(*this);</span>
<span class="line-added">1548             m_mediaSource = nullptr;</span>
<span class="line-added">1549             mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1550         }
1551     }
1552 #endif
1553 #if ENABLE(MEDIA_STREAM)
1554     if (!loadAttempted &amp;&amp; m_mediaStreamSrcObject) {
1555         loadAttempted = true;
1556         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading media stream blob&quot;);
1557         if (!m_player-&gt;load(m_mediaStreamSrcObject-&gt;privateStream()))
<a name="47" id="anc47"></a><span class="line-modified">1558             mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1559     }
1560 #endif
1561 
1562     if (!loadAttempted &amp;&amp; m_blob) {
1563         loadAttempted = true;
1564         ALWAYS_LOG(LOGIDENTIFIER, &quot;loading generic blob&quot;);
1565         if (!m_player-&gt;load(m_blob-&gt;url(), contentType, keySystem))
<a name="48" id="anc48"></a><span class="line-modified">1566             mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1567     }
1568 
1569     if (!loadAttempted &amp;&amp; !m_player-&gt;load(url, contentType, keySystem))
<a name="49" id="anc49"></a><span class="line-modified">1570         mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
1571 
1572     // If there is no poster to display, allow the media engine to render video frames as soon as
1573     // they are available.
1574     updateDisplayState();
1575 
1576     updateRenderer();
1577 }
1578 
1579 #if ENABLE(VIDEO_TRACK)
1580 
<a name="50" id="anc50"></a><span class="line-added">1581 struct HTMLMediaElement::CueData {</span>
<span class="line-added">1582     WTF_MAKE_STRUCT_FAST_ALLOCATED;</span>
<span class="line-added">1583     PODIntervalTree&lt;MediaTime, TextTrackCue*&gt; cueTree;</span>
<span class="line-added">1584     CueList currentlyActiveCues;</span>
<span class="line-added">1585 };</span>
<span class="line-added">1586 </span>
1587 static bool trackIndexCompare(TextTrack* a, TextTrack* b)
1588 {
1589     return a-&gt;trackIndex() - b-&gt;trackIndex() &lt; 0;
1590 }
1591 
1592 static bool eventTimeCueCompare(const std::pair&lt;MediaTime, TextTrackCue*&gt;&amp; a, const std::pair&lt;MediaTime, TextTrackCue*&gt;&amp; b)
1593 {
1594     // 12 - Sort the tasks in events in ascending time order (tasks with earlier
1595     // times first).
1596     if (a.first != b.first)
1597         return a.first - b.first &lt; MediaTime::zeroTime();
1598 
1599     // If the cues belong to different text tracks, it doesn&#39;t make sense to
1600     // compare the two tracks by the relative cue order, so return the relative
1601     // track order.
1602     if (a.second-&gt;track() != b.second-&gt;track())
1603         return trackIndexCompare(a.second-&gt;track(), b.second-&gt;track());
1604 
1605     // 12 - Further sort tasks in events that have the same time by the
1606     // relative text track cue order of the text track cues associated
1607     // with these tasks.
1608     return a.second-&gt;isOrderedBefore(b.second);
1609 }
1610 
1611 static bool compareCueInterval(const CueInterval&amp; one, const CueInterval&amp; two)
1612 {
1613     return one.data()-&gt;isOrderedBefore(two.data());
1614 }
1615 
1616 static bool compareCueIntervalEndTime(const CueInterval&amp; one, const CueInterval&amp; two)
1617 {
1618     return one.data()-&gt;endMediaTime() &gt; two.data()-&gt;endMediaTime();
1619 }
1620 
<a name="51" id="anc51"></a><span class="line-added">1621 bool HTMLMediaElement::ignoreTrackDisplayUpdateRequests() const</span>
<span class="line-added">1622 {</span>
<span class="line-added">1623     return m_ignoreTrackDisplayUpdate &gt; 0 || !m_textTracks || !m_cueData || m_cueData-&gt;cueTree.isEmpty();</span>
<span class="line-added">1624 }</span>
<span class="line-added">1625 </span>
1626 void HTMLMediaElement::updateActiveTextTrackCues(const MediaTime&amp; movieTime)
1627 {
1628     // 4.8.10.8 Playing the media resource
1629 
1630     //  If the current playback position changes while the steps are running,
1631     //  then the user agent must wait for the steps to complete, and then must
1632     //  immediately rerun the steps.
1633     if (ignoreTrackDisplayUpdateRequests())
1634         return;
1635 
1636     // 1 - Let current cues be a list of cues, initialized to contain all the
1637     // cues of all the hidden, showing, or showing by default text tracks of the
1638     // media element (not the disabled ones) whose start times are less than or
1639     // equal to the current playback position and whose end times are greater
1640     // than the current playback position.
1641     CueList currentCues;
1642 
1643     // The user agent must synchronously unset [the text track cue active] flag
1644     // whenever ... the media element&#39;s readyState is changed back to HAVE_NOTHING.
<a name="52" id="anc52"></a>
1645     if (m_readyState != HAVE_NOTHING &amp;&amp; m_player) {
<a name="53" id="anc53"></a><span class="line-modified">1646         currentCues = m_cueData-&gt;cueTree.allOverlaps({ movieTime, movieTime });</span>
1647         if (currentCues.size() &gt; 1)
1648             std::sort(currentCues.begin(), currentCues.end(), &amp;compareCueInterval);
1649     }
1650 
1651     CueList previousCues;
1652     CueList missedCues;
1653 
1654     // 2 - Let other cues be a list of cues, initialized to contain all the cues
1655     // of hidden, showing, and showing by default text tracks of the media
1656     // element that are not present in current cues.
<a name="54" id="anc54"></a><span class="line-modified">1657     previousCues = m_cueData-&gt;currentlyActiveCues;</span>
1658 
1659     // 3 - Let last time be the current playback position at the time this
1660     // algorithm was last run for this media element, if this is not the first
1661     // time it has run.
1662     MediaTime lastTime = m_lastTextTrackUpdateTime;
1663 
1664     // 4 - If the current playback position has, since the last time this
1665     // algorithm was run, only changed through its usual monotonic increase
1666     // during normal playback, then let missed cues be the list of cues in other
1667     // cues whose start times are greater than or equal to last time and whose
1668     // end times are less than or equal to the current playback position.
1669     // Otherwise, let missed cues be an empty list.
1670     if (lastTime &gt;= MediaTime::zeroTime() &amp;&amp; m_lastSeekTime &lt; movieTime) {
<a name="55" id="anc55"></a><span class="line-modified">1671         for (auto&amp; cue : m_cueData-&gt;cueTree.allOverlaps({ lastTime, movieTime })) {</span>
1672             // Consider cues that may have been missed since the last seek time.
1673             if (cue.low() &gt; std::max(m_lastSeekTime, lastTime) &amp;&amp; cue.high() &lt; movieTime)
1674                 missedCues.append(cue);
1675         }
1676     }
1677 
1678     m_lastTextTrackUpdateTime = movieTime;
1679 
1680     // 5 - If the time was reached through the usual monotonic increase of the
1681     // current playback position during normal playback, and if the user agent
1682     // has not fired a timeupdate event at the element in the past 15 to 250ms
1683     // and is not still running event handlers for such an event, then the user
1684     // agent must queue a task to fire a simple event named timeupdate at the
1685     // element. (In the other cases, such as explicit seeks, relevant events get
1686     // fired as part of the overall process of changing the current playback
1687     // position.)
1688     if (!m_paused &amp;&amp; m_lastSeekTime &lt;= lastTime)
1689         scheduleTimeupdateEvent(false);
1690 
1691     // Explicitly cache vector sizes, as their content is constant from here.
1692     size_t currentCuesSize = currentCues.size();
1693     size_t missedCuesSize = missedCues.size();
1694     size_t previousCuesSize = previousCues.size();
1695 
1696     // 6 - If all of the cues in current cues have their text track cue active
1697     // flag set, none of the cues in other cues have their text track cue active
1698     // flag set, and missed cues is empty, then abort these steps.
1699     bool activeSetChanged = missedCuesSize;
1700 
1701     for (size_t i = 0; !activeSetChanged &amp;&amp; i &lt; previousCuesSize; ++i)
1702         if (!currentCues.contains(previousCues[i]) &amp;&amp; previousCues[i].data()-&gt;isActive())
1703             activeSetChanged = true;
1704 
1705     for (size_t i = 0; i &lt; currentCuesSize; ++i) {
1706         RefPtr&lt;TextTrackCue&gt; cue = currentCues[i].data();
<a name="56" id="anc56"></a><span class="line-modified">1707         cue-&gt;updateDisplayTree(movieTime);</span>



1708         if (!cue-&gt;isActive())
1709             activeSetChanged = true;
1710     }
1711 
1712     MediaTime nextInterestingTime = MediaTime::invalidTime();
1713     if (auto nearestEndingCue = std::min_element(currentCues.begin(), currentCues.end(), compareCueIntervalEndTime))
1714         nextInterestingTime = nearestEndingCue-&gt;data()-&gt;endMediaTime();
1715 
<a name="57" id="anc57"></a><span class="line-modified">1716     Optional&lt;CueInterval&gt; nextCue = m_cueData-&gt;cueTree.nextIntervalAfter(movieTime);</span>
1717     if (nextCue)
1718         nextInterestingTime = std::min(nextInterestingTime, nextCue-&gt;low());
1719 
1720     INFO_LOG(LOGIDENTIFIER, &quot;nextInterestingTime:&quot;, nextInterestingTime);
1721 
1722     if (nextInterestingTime.isValid() &amp;&amp; m_player) {
1723         m_player-&gt;performTaskAtMediaTime([this, weakThis = makeWeakPtr(this), nextInterestingTime] {
1724             if (!weakThis)
1725                 return;
1726 
1727             auto currentMediaTime = this-&gt;currentMediaTime();
1728             INFO_LOG(LOGIDENTIFIER, &quot; lambda, currentMediaTime: &quot;, currentMediaTime);
1729             this-&gt;updateActiveTextTrackCues(currentMediaTime);
1730         }, nextInterestingTime);
1731     }
1732 
1733     if (!activeSetChanged)
1734         return;
1735 
1736     // 7 - If the time was reached through the usual monotonic increase of the
1737     // current playback position during normal playback, and there are cues in
1738     // other cues that have their text track cue pause-on-exi flag set and that
1739     // either have their text track cue active flag set or are also in missed
1740     // cues, then immediately pause the media element.
1741     for (size_t i = 0; !m_paused &amp;&amp; i &lt; previousCuesSize; ++i) {
1742         if (previousCues[i].data()-&gt;pauseOnExit()
1743             &amp;&amp; previousCues[i].data()-&gt;isActive()
1744             &amp;&amp; !currentCues.contains(previousCues[i]))
1745             pause();
1746     }
1747 
1748     for (size_t i = 0; !m_paused &amp;&amp; i &lt; missedCuesSize; ++i) {
1749         if (missedCues[i].data()-&gt;pauseOnExit())
1750             pause();
1751     }
1752 
1753     // 8 - Let events be a list of tasks, initially empty. Each task in this
1754     // list will be associated with a text track, a text track cue, and a time,
1755     // which are used to sort the list before the tasks are queued.
1756     Vector&lt;std::pair&lt;MediaTime, TextTrackCue*&gt;&gt; eventTasks;
1757 
1758     // 8 - Let affected tracks be a list of text tracks, initially empty.
1759     Vector&lt;TextTrack*&gt; affectedTracks;
1760 
1761     for (size_t i = 0; i &lt; missedCuesSize; ++i) {
1762         // 9 - For each text track cue in missed cues, prepare an event named enter
1763         // for the TextTrackCue object with the text track cue start time.
1764         eventTasks.append({ missedCues[i].data()-&gt;startMediaTime(), missedCues[i].data() });
1765 
1766         // 10 - For each text track [...] in missed cues, prepare an event
1767         // named exit for the TextTrackCue object with the  with the later of
1768         // the text track cue end time and the text track cue start time.
1769 
1770         // Note: An explicit task is added only if the cue is NOT a zero or
1771         // negative length cue. Otherwise, the need for an exit event is
1772         // checked when these tasks are actually queued below. This doesn&#39;t
1773         // affect sorting events before dispatch either, because the exit
1774         // event has the same time as the enter event.
1775         if (missedCues[i].data()-&gt;startMediaTime() &lt; missedCues[i].data()-&gt;endMediaTime())
1776             eventTasks.append({ missedCues[i].data()-&gt;endMediaTime(), missedCues[i].data() });
1777     }
1778 
1779     for (size_t i = 0; i &lt; previousCuesSize; ++i) {
1780         // 10 - For each text track cue in other cues that has its text
1781         // track cue active flag set prepare an event named exit for the
1782         // TextTrackCue object with the text track cue end time.
1783         if (!currentCues.contains(previousCues[i]))
1784             eventTasks.append({ previousCues[i].data()-&gt;endMediaTime(), previousCues[i].data() });
1785     }
1786 
1787     for (size_t i = 0; i &lt; currentCuesSize; ++i) {
1788         // 11 - For each text track cue in current cues that does not have its
1789         // text track cue active flag set, prepare an event named enter for the
1790         // TextTrackCue object with the text track cue start time.
1791         if (!previousCues.contains(currentCues[i]))
1792             eventTasks.append({ currentCues[i].data()-&gt;startMediaTime(), currentCues[i].data() });
1793     }
1794 
1795     // 12 - Sort the tasks in events in ascending time order (tasks with earlier
1796     // times first).
1797     std::sort(eventTasks.begin(), eventTasks.end(), eventTimeCueCompare);
1798 
1799     for (auto&amp; eventTask : eventTasks) {
1800         if (!affectedTracks.contains(eventTask.second-&gt;track()))
1801             affectedTracks.append(eventTask.second-&gt;track());
1802 
1803         // 13 - Queue each task in events, in list order.
1804 
1805         // Each event in eventTasks may be either an enterEvent or an exitEvent,
1806         // depending on the time that is associated with the event. This
1807         // correctly identifies the type of the event, if the startTime is
1808         // less than the endTime in the cue.
1809         if (eventTask.second-&gt;startTime() &gt;= eventTask.second-&gt;endTime()) {
1810             auto enterEvent = Event::create(eventNames().enterEvent, Event::CanBubble::No, Event::IsCancelable::No);
1811             enterEvent-&gt;setTarget(eventTask.second);
<a name="58" id="anc58"></a><span class="line-modified">1812             m_asyncEventQueue-&gt;enqueueEvent(WTFMove(enterEvent));</span>
1813 
1814             auto exitEvent = Event::create(eventNames().exitEvent, Event::CanBubble::No, Event::IsCancelable::No);
1815             exitEvent-&gt;setTarget(eventTask.second);
<a name="59" id="anc59"></a><span class="line-modified">1816             m_asyncEventQueue-&gt;enqueueEvent(WTFMove(exitEvent));</span>
1817         } else {
1818             RefPtr&lt;Event&gt; event;
1819             if (eventTask.first == eventTask.second-&gt;startMediaTime())
1820                 event = Event::create(eventNames().enterEvent, Event::CanBubble::No, Event::IsCancelable::No);
1821             else
1822                 event = Event::create(eventNames().exitEvent, Event::CanBubble::No, Event::IsCancelable::No);
1823             event-&gt;setTarget(eventTask.second);
<a name="60" id="anc60"></a><span class="line-modified">1824             m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
1825         }
1826     }
1827 
1828     // 14 - Sort affected tracks in the same order as the text tracks appear in
1829     // the media element&#39;s list of text tracks, and remove duplicates.
1830     std::sort(affectedTracks.begin(), affectedTracks.end(), trackIndexCompare);
1831 
1832     // 15 - For each text track in affected tracks, in the list order, queue a
1833     // task to fire a simple event named cuechange at the TextTrack object, and, ...
1834     for (auto&amp; affectedTrack : affectedTracks) {
1835         auto event = Event::create(eventNames().cuechangeEvent, Event::CanBubble::No, Event::IsCancelable::No);
1836         event-&gt;setTarget(affectedTrack);
<a name="61" id="anc61"></a><span class="line-modified">1837         m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
1838 
1839         // ... if the text track has a corresponding track element, to then fire a
1840         // simple event named cuechange at the track element as well.
1841         if (is&lt;LoadableTextTrack&gt;(*affectedTrack)) {
1842             auto event = Event::create(eventNames().cuechangeEvent, Event::CanBubble::No, Event::IsCancelable::No);
1843             auto trackElement = makeRefPtr(downcast&lt;LoadableTextTrack&gt;(*affectedTrack).trackElement());
1844             ASSERT(trackElement);
1845             event-&gt;setTarget(trackElement);
<a name="62" id="anc62"></a><span class="line-modified">1846             m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
1847         }
1848     }
1849 
1850     // 16 - Set the text track cue active flag of all the cues in the current
1851     // cues, and unset the text track cue active flag of all the cues in the
1852     // other cues.
1853     for (size_t i = 0; i &lt; currentCuesSize; ++i)
1854         currentCues[i].data()-&gt;setIsActive(true);
1855 
1856     for (size_t i = 0; i &lt; previousCuesSize; ++i)
1857         if (!currentCues.contains(previousCues[i]))
1858             previousCues[i].data()-&gt;setIsActive(false);
1859 
1860     // Update the current active cues.
<a name="63" id="anc63"></a><span class="line-modified">1861     m_cueData-&gt;currentlyActiveCues = currentCues;</span>
1862 
1863     if (activeSetChanged)
1864         updateTextTrackDisplay();
1865 }
1866 
1867 bool HTMLMediaElement::textTracksAreReady() const
1868 {
1869     // 4.8.10.12.1 Text track model
1870     // ...
1871     // The text tracks of a media element are ready if all the text tracks whose mode was not
1872     // in the disabled state when the element&#39;s resource selection algorithm last started now
1873     // have a text track readiness state of loaded or failed to load.
1874     for (unsigned i = 0; i &lt; m_textTracksWhenResourceSelectionBegan.size(); ++i) {
1875         if (m_textTracksWhenResourceSelectionBegan[i]-&gt;readinessState() == TextTrack::Loading
1876             || m_textTracksWhenResourceSelectionBegan[i]-&gt;readinessState() == TextTrack::NotLoaded)
1877             return false;
1878     }
1879 
1880     return true;
1881 }
1882 
1883 void HTMLMediaElement::textTrackReadyStateChanged(TextTrack* track)
1884 {
1885     if (track-&gt;readinessState() != TextTrack::Loading
1886         &amp;&amp; track-&gt;mode() != TextTrack::Mode::Disabled) {
1887         // The display trees exist as long as the track is active, in this case,
1888         // and if the same track is loaded again (for example if the src attribute was changed),
1889         // cues can be accumulated with the old ones, that&#39;s why they needs to be flushed
1890         if (hasMediaControls())
1891             mediaControls()-&gt;clearTextDisplayContainer();
1892         updateTextTrackDisplay();
1893     }
1894     if (m_player &amp;&amp; m_textTracksWhenResourceSelectionBegan.contains(track)) {
1895         if (track-&gt;readinessState() != TextTrack::Loading)
1896             setReadyState(m_player-&gt;readyState());
1897     } else {
1898         // The track readiness state might have changed as a result of the user
1899         // clicking the captions button. In this case, a check whether all the
1900         // resources have failed loading should be done in order to hide the CC button.
1901         if (hasMediaControls() &amp;&amp; track-&gt;readinessState() == TextTrack::FailedToLoad)
1902             mediaControls()-&gt;refreshClosedCaptionsButtonVisibility();
1903     }
1904 }
1905 
1906 void HTMLMediaElement::audioTrackEnabledChanged(AudioTrack&amp; track)
1907 {
1908     if (m_audioTracks &amp;&amp; m_audioTracks-&gt;contains(track))
1909         m_audioTracks-&gt;scheduleChangeEvent();
1910     if (processingUserGestureForMedia())
1911         removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);
1912 }
1913 
1914 void HTMLMediaElement::textTrackModeChanged(TextTrack&amp; track)
1915 {
1916     bool trackIsLoaded = true;
1917     if (track.trackType() == TextTrack::TrackElement) {
1918         trackIsLoaded = false;
1919         for (auto&amp; trackElement : childrenOfType&lt;HTMLTrackElement&gt;(*this)) {
1920             if (&amp;trackElement.track() == &amp;track) {
1921                 if (trackElement.readyState() == HTMLTrackElement::LOADING || trackElement.readyState() == HTMLTrackElement::LOADED)
1922                     trackIsLoaded = true;
1923                 break;
1924             }
1925         }
1926     }
1927 
1928     // If this is the first added track, create the list of text tracks.
1929     if (!m_textTracks)
<a name="64" id="anc64"></a><span class="line-modified">1930         m_textTracks = TextTrackList::create(makeWeakPtr(this), ActiveDOMObject::scriptExecutionContext());</span>
1931 
1932     // Mark this track as &quot;configured&quot; so configureTextTracks won&#39;t change the mode again.
1933     track.setHasBeenConfigured(true);
1934 
1935     if (track.mode() != TextTrack::Mode::Disabled &amp;&amp; trackIsLoaded)
1936         textTrackAddCues(track, *track.cues());
1937 
1938     configureTextTrackDisplay(AssumeTextTrackVisibilityChanged);
1939 
1940     if (m_textTracks &amp;&amp; m_textTracks-&gt;contains(track))
1941         m_textTracks-&gt;scheduleChangeEvent();
1942 
1943 #if ENABLE(AVF_CAPTIONS)
1944     if (track.trackType() == TextTrack::TrackElement &amp;&amp; m_player)
1945         m_player-&gt;notifyTrackModeChanged();
1946 #endif
1947 }
1948 
1949 void HTMLMediaElement::videoTrackSelectedChanged(VideoTrack&amp; track)
1950 {
1951     if (m_videoTracks &amp;&amp; m_videoTracks-&gt;contains(track))
1952         m_videoTracks-&gt;scheduleChangeEvent();
1953 }
1954 
1955 void HTMLMediaElement::textTrackKindChanged(TextTrack&amp; track)
1956 {
1957     if (track.kind() != TextTrack::Kind::Captions &amp;&amp; track.kind() != TextTrack::Kind::Subtitles &amp;&amp; track.mode() == TextTrack::Mode::Showing)
1958         track.setMode(TextTrack::Mode::Hidden);
1959 }
1960 
1961 void HTMLMediaElement::beginIgnoringTrackDisplayUpdateRequests()
1962 {
1963     ++m_ignoreTrackDisplayUpdate;
1964 }
1965 
1966 void HTMLMediaElement::endIgnoringTrackDisplayUpdateRequests()
1967 {
1968     ASSERT(m_ignoreTrackDisplayUpdate);
1969     --m_ignoreTrackDisplayUpdate;
1970     if (!m_ignoreTrackDisplayUpdate &amp;&amp; m_inActiveDocument)
1971         updateActiveTextTrackCues(currentMediaTime());
1972 }
1973 
1974 void HTMLMediaElement::textTrackAddCues(TextTrack&amp; track, const TextTrackCueList&amp; cues)
1975 {
1976     if (track.mode() == TextTrack::Mode::Disabled)
1977         return;
1978 
1979     TrackDisplayUpdateScope scope { *this };
1980     for (unsigned i = 0; i &lt; cues.length(); ++i)
1981         textTrackAddCue(track, *cues.item(i));
1982 }
1983 
1984 void HTMLMediaElement::textTrackRemoveCues(TextTrack&amp;, const TextTrackCueList&amp; cues)
1985 {
1986     TrackDisplayUpdateScope scope { *this };
1987     for (unsigned i = 0; i &lt; cues.length(); ++i) {
1988         auto&amp; cue = *cues.item(i);
1989         textTrackRemoveCue(*cue.track(), cue);
1990     }
1991 }
1992 
1993 void HTMLMediaElement::textTrackAddCue(TextTrack&amp; track, TextTrackCue&amp; cue)
1994 {
1995     if (track.mode() == TextTrack::Mode::Disabled)
1996         return;
1997 
<a name="65" id="anc65"></a><span class="line-added">1998     if (!m_cueData)</span>
<span class="line-added">1999         m_cueData = makeUnique&lt;CueData&gt;();</span>
<span class="line-added">2000 </span>
2001     // Negative duration cues need be treated in the interval tree as
2002     // zero-length cues.
2003     MediaTime endTime = std::max(cue.startMediaTime(), cue.endMediaTime());
2004 
<a name="66" id="anc66"></a><span class="line-modified">2005     CueInterval interval(cue.startMediaTime(), endTime, &amp;cue);</span>
<span class="line-modified">2006     if (!m_cueData-&gt;cueTree.contains(interval))</span>
<span class="line-modified">2007         m_cueData-&gt;cueTree.add(interval);</span>
2008     updateActiveTextTrackCues(currentMediaTime());
2009 }
2010 
2011 void HTMLMediaElement::textTrackRemoveCue(TextTrack&amp;, TextTrackCue&amp; cue)
2012 {
<a name="67" id="anc67"></a><span class="line-added">2013     if (!m_cueData)</span>
<span class="line-added">2014         m_cueData = makeUnique&lt;CueData&gt;();</span>
<span class="line-added">2015 </span>
2016     // Negative duration cues need to be treated in the interval tree as
2017     // zero-length cues.
2018     MediaTime endTime = std::max(cue.startMediaTime(), cue.endMediaTime());
2019 
<a name="68" id="anc68"></a><span class="line-modified">2020     CueInterval interval(cue.startMediaTime(), endTime, &amp;cue);</span>
<span class="line-modified">2021     m_cueData-&gt;cueTree.remove(interval);</span>
2022 
2023     // Since the cue will be removed from the media element and likely the
2024     // TextTrack might also be destructed, notifying the region of the cue
2025     // removal shouldn&#39;t be done.
<a name="69" id="anc69"></a><span class="line-modified">2026     auto isVTT = is&lt;VTTCue&gt;(cue);</span>
<span class="line-added">2027     if (isVTT)</span>
2028         toVTTCue(&amp;cue)-&gt;notifyRegionWhenRemovingDisplayTree(false);
2029 
<a name="70" id="anc70"></a><span class="line-modified">2030     size_t index = m_cueData-&gt;currentlyActiveCues.find(interval);</span>
2031     if (index != notFound) {
2032         cue.setIsActive(false);
<a name="71" id="anc71"></a><span class="line-modified">2033         m_cueData-&gt;currentlyActiveCues.remove(index);</span>
2034     }
2035 
<a name="72" id="anc72"></a><span class="line-modified">2036     cue.removeDisplayTree();</span>

2037     updateActiveTextTrackCues(currentMediaTime());
2038 
<a name="73" id="anc73"></a><span class="line-modified">2039     if (isVTT)</span>
2040         toVTTCue(&amp;cue)-&gt;notifyRegionWhenRemovingDisplayTree(true);
2041 }
2042 
<a name="74" id="anc74"></a><span class="line-added">2043 CueList HTMLMediaElement::currentlyActiveCues() const</span>
<span class="line-added">2044 {</span>
<span class="line-added">2045     if (!m_cueData)</span>
<span class="line-added">2046         return { };</span>
<span class="line-added">2047     return m_cueData-&gt;currentlyActiveCues;</span>
<span class="line-added">2048 }</span>
<span class="line-added">2049 </span>
2050 #endif
2051 
2052 static inline bool isAllowedToLoadMediaURL(HTMLMediaElement&amp; element, const URL&amp; url, bool isInUserAgentShadowTree)
2053 {
2054     // Elements in user agent show tree should load whatever the embedding document policy is.
2055     if (isInUserAgentShadowTree)
2056         return true;
2057 
2058     ASSERT(element.document().contentSecurityPolicy());
2059     return element.document().contentSecurityPolicy()-&gt;allowMediaFromSource(url);
2060 }
2061 
2062 bool HTMLMediaElement::isSafeToLoadURL(const URL&amp; url, InvalidURLAction actionIfInvalid)
2063 {
2064     if (!url.isValid()) {
2065         ERROR_LOG(LOGIDENTIFIER, url, &quot; is invalid&quot;);
2066         return false;
2067     }
2068 
2069     RefPtr&lt;Frame&gt; frame = document().frame();
2070     if (!frame || !document().securityOrigin().canDisplay(url)) {
2071         if (actionIfInvalid == Complain) {
2072             FrameLoader::reportLocalLoadFailed(frame.get(), url.stringCenterEllipsizedToLength());
2073             ERROR_LOG(LOGIDENTIFIER, url , &quot; was rejected by SecurityOrigin&quot;);
2074         }
2075         return false;
2076     }
2077 
2078     if (!isAllowedToLoadMediaURL(*this, url, isInUserAgentShadowTree())) {
2079         ERROR_LOG(LOGIDENTIFIER, url, &quot; was rejected by Content Security Policy&quot;);
2080         return false;
2081     }
2082 
2083     return true;
2084 }
2085 
2086 void HTMLMediaElement::startProgressEventTimer()
2087 {
2088     if (m_progressEventTimer.isActive())
2089         return;
2090 
2091     m_previousProgressTime = MonotonicTime::now();
2092     // 350ms is not magic, it is in the spec!
2093     m_progressEventTimer.startRepeating(350_ms);
2094 }
2095 
2096 void HTMLMediaElement::waitForSourceChange()
2097 {
2098     INFO_LOG(LOGIDENTIFIER);
2099 
2100     stopPeriodicTimers();
2101     m_loadState = WaitingForSource;
2102 
2103     // 6.17 - Waiting: Set the element&#39;s networkState attribute to the NETWORK_NO_SOURCE value
2104     m_networkState = NETWORK_NO_SOURCE;
2105 
2106     // 6.18 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
2107     setShouldDelayLoadEvent(false);
2108 
2109     updateDisplayState();
2110     updateRenderer();
2111 }
2112 
2113 void HTMLMediaElement::noneSupported()
2114 {
2115     if (m_error)
2116         return;
2117 
2118     INFO_LOG(LOGIDENTIFIER);
2119 
2120     stopPeriodicTimers();
2121     m_loadState = WaitingForSource;
2122     m_currentSourceNode = nullptr;
2123 
2124     // 4.8.10.5
2125     // 6 - Reaching this step indicates that the media resource failed to load or that the given
2126     // URL could not be resolved. In one atomic operation, run the following steps:
2127 
2128     // 6.1 - Set the error attribute to a new MediaError object whose code attribute is set to
2129     // MEDIA_ERR_SRC_NOT_SUPPORTED.
2130     m_error = MediaError::create(MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED);
2131 
<a name="75" id="anc75"></a><span class="line-added">2132 #if ENABLE(VIDEO_TRACK)</span>
2133     // 6.2 - Forget the media element&#39;s media-resource-specific text tracks.
2134     forgetResourceSpecificTracks();
<a name="76" id="anc76"></a><span class="line-added">2135 #endif</span>
2136 
2137     // 6.3 - Set the element&#39;s networkState attribute to the NETWORK_NO_SOURCE value.
2138     m_networkState = NETWORK_NO_SOURCE;
2139 
2140     // 7 - Queue a task to fire a simple event named error at the media element.
2141     scheduleEvent(eventNames().errorEvent);
2142 
2143     rejectPendingPlayPromises(WTFMove(m_pendingPlayPromises), DOMException::create(NotSupportedError));
2144 
2145 #if ENABLE(MEDIA_SOURCE)
2146     detachMediaSource();
2147 #endif
2148 
2149     // 8 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
2150     setShouldDelayLoadEvent(false);
2151 
2152     // 9 - Abort these steps. Until the load() method is invoked or the src attribute is changed,
2153     // the element won&#39;t attempt to load another resource.
2154 
2155     updateDisplayState();
2156     updateRenderer();
2157 }
2158 
2159 void HTMLMediaElement::mediaLoadingFailedFatally(MediaPlayer::NetworkState error)
2160 {
2161     // 1 - The user agent should cancel the fetching process.
2162     stopPeriodicTimers();
2163     m_loadState = WaitingForSource;
2164 
2165     // 2 - Set the error attribute to a new MediaError object whose code attribute is
2166     // set to MEDIA_ERR_NETWORK/MEDIA_ERR_DECODE.
<a name="77" id="anc77"></a><span class="line-modified">2167     if (error == MediaPlayer::NetworkState::NetworkError)</span>
2168         m_error = MediaError::create(MediaError::MEDIA_ERR_NETWORK);
<a name="78" id="anc78"></a><span class="line-modified">2169     else if (error == MediaPlayer::NetworkState::DecodeError)</span>
2170         m_error = MediaError::create(MediaError::MEDIA_ERR_DECODE);
2171     else
2172         ASSERT_NOT_REACHED();
2173 
2174     // 3 - Queue a task to fire a simple event named error at the media element.
2175     scheduleEvent(eventNames().errorEvent);
2176 
2177 #if ENABLE(MEDIA_SOURCE)
2178     detachMediaSource();
2179 #endif
2180 
2181     // 4 - Set the element&#39;s networkState attribute to the NETWORK_EMPTY value and queue a
2182     // task to fire a simple event called emptied at the element.
2183     m_networkState = NETWORK_EMPTY;
2184     scheduleEvent(eventNames().emptiedEvent);
2185 
2186     // 5 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
2187     setShouldDelayLoadEvent(false);
2188 
2189     // 6 - Abort the overall resource selection algorithm.
2190     m_currentSourceNode = nullptr;
<a name="79" id="anc79"></a>




2191 }
2192 
2193 void HTMLMediaElement::cancelPendingEventsAndCallbacks()
2194 {
2195     INFO_LOG(LOGIDENTIFIER);
<a name="80" id="anc80"></a><span class="line-modified">2196     m_asyncEventQueue-&gt;cancelAllEvents();</span>
2197 
2198     for (auto&amp; source : childrenOfType&lt;HTMLSourceElement&gt;(*this))
2199         source.cancelPendingErrorEvent();
2200 
2201     rejectPendingPlayPromises(WTFMove(m_pendingPlayPromises), DOMException::create(AbortError));
2202 }
2203 
<a name="81" id="anc81"></a><span class="line-modified">2204 void HTMLMediaElement::mediaPlayerNetworkStateChanged()</span>
2205 {
2206     beginProcessingMediaPlayerCallback();
2207     setNetworkState(m_player-&gt;networkState());
2208     endProcessingMediaPlayerCallback();
2209 }
2210 
2211 static void logMediaLoadRequest(Page* page, const String&amp; mediaEngine, const String&amp; errorMessage, bool succeeded)
2212 {
2213     if (!page)
2214         return;
2215 
2216     DiagnosticLoggingClient&amp; diagnosticLoggingClient = page-&gt;diagnosticLoggingClient();
2217     if (!succeeded) {
2218         diagnosticLoggingClient.logDiagnosticMessageWithResult(DiagnosticLoggingKeys::mediaLoadingFailedKey(), errorMessage, DiagnosticLoggingResultFail, ShouldSample::No);
2219         return;
2220     }
2221 
2222     diagnosticLoggingClient.logDiagnosticMessage(DiagnosticLoggingKeys::mediaLoadedKey(), mediaEngine, ShouldSample::No);
2223 
2224     if (!page-&gt;hasSeenAnyMediaEngine())
2225         diagnosticLoggingClient.logDiagnosticMessage(DiagnosticLoggingKeys::pageContainsAtLeastOneMediaEngineKey(), emptyString(), ShouldSample::No);
2226 
2227     if (!page-&gt;hasSeenMediaEngine(mediaEngine))
2228         diagnosticLoggingClient.logDiagnosticMessage(DiagnosticLoggingKeys::pageContainsMediaEngineKey(), mediaEngine, ShouldSample::No);
2229 
2230     page-&gt;sawMediaEngine(mediaEngine);
2231 }
2232 
<a name="82" id="anc82"></a>













2233 void HTMLMediaElement::mediaLoadingFailed(MediaPlayer::NetworkState error)
2234 {
2235     stopPeriodicTimers();
2236 
2237     // If we failed while trying to load a &lt;source&gt; element, the movie was never parsed, and there are more
2238     // &lt;source&gt; children, schedule the next one
2239     if (m_readyState &lt; HAVE_METADATA &amp;&amp; m_loadState == LoadingFromSourceElement) {
2240 
2241         // resource selection algorithm
2242         // Step 9.Otherwise.9 - Failed with elements: Queue a task, using the DOM manipulation task source, to fire a simple event named error at the candidate element.
2243         if (m_currentSourceNode)
2244             m_currentSourceNode-&gt;scheduleErrorEvent();
2245         else
2246             INFO_LOG(LOGIDENTIFIER, &quot;error event not sent, &lt;source&gt; was removed&quot;);
2247 
2248         // 9.Otherwise.10 - Asynchronously await a stable state. The synchronous section consists of all the remaining steps of this algorithm until the algorithm says the synchronous section has ended.
2249 
<a name="83" id="anc83"></a><span class="line-added">2250 #if ENABLE(VIDEO_TRACK)</span>
2251         // 9.Otherwise.11 - Forget the media element&#39;s media-resource-specific tracks.
2252         forgetResourceSpecificTracks();
<a name="84" id="anc84"></a><span class="line-added">2253 #endif</span>
2254 
2255         if (havePotentialSourceChild()) {
2256             INFO_LOG(LOGIDENTIFIER, &quot;scheduling next &lt;source&gt;&quot;);
2257             scheduleNextSourceChild();
2258         } else {
2259             INFO_LOG(LOGIDENTIFIER, &quot;no more &lt;source&gt; elements, waiting&quot;);
2260             waitForSourceChange();
2261         }
2262 
2263         return;
2264     }
2265 
<a name="85" id="anc85"></a><span class="line-modified">2266     if ((error == MediaPlayer::NetworkState::NetworkError &amp;&amp; m_readyState &gt;= HAVE_METADATA) || error == MediaPlayer::NetworkState::DecodeError)</span>
2267         mediaLoadingFailedFatally(error);
<a name="86" id="anc86"></a><span class="line-modified">2268     else if ((error == MediaPlayer::NetworkState::FormatError || error == MediaPlayer::NetworkState::NetworkError) &amp;&amp; m_loadState == LoadingFromSrcAttr)</span>
2269         noneSupported();
2270 
2271     updateDisplayState();
2272     if (hasMediaControls()) {
2273         mediaControls()-&gt;reset();
2274         mediaControls()-&gt;reportedError();
2275     }
2276 
2277     ERROR_LOG(LOGIDENTIFIER, &quot;error = &quot;, static_cast&lt;int&gt;(error));
2278 
<a name="87" id="anc87"></a><span class="line-modified">2279     logMediaLoadRequest(document().page(), String(), convertEnumerationToString(error), false);</span>
2280 
2281     m_mediaSession-&gt;clientCharacteristicsChanged();
2282 }
2283 
2284 void HTMLMediaElement::setNetworkState(MediaPlayer::NetworkState state)
2285 {
2286     if (static_cast&lt;int&gt;(state) != static_cast&lt;int&gt;(m_networkState))
2287         ALWAYS_LOG(LOGIDENTIFIER, &quot;new state = &quot;, state, &quot;, current state = &quot;, m_networkState);
2288 
<a name="88" id="anc88"></a><span class="line-modified">2289     if (state == MediaPlayer::NetworkState::Empty) {</span>
2290         // Just update the cached state and leave, we can&#39;t do anything.
2291         m_networkState = NETWORK_EMPTY;
2292         return;
2293     }
2294 
<a name="89" id="anc89"></a><span class="line-modified">2295     if (state == MediaPlayer::NetworkState::FormatError || state == MediaPlayer::NetworkState::NetworkError || state == MediaPlayer::NetworkState::DecodeError) {</span>
2296         mediaLoadingFailed(state);
2297         return;
2298     }
2299 
<a name="90" id="anc90"></a><span class="line-modified">2300     if (state == MediaPlayer::NetworkState::Idle) {</span>
2301         if (m_networkState &gt; NETWORK_IDLE) {
2302             changeNetworkStateFromLoadingToIdle();
2303             setShouldDelayLoadEvent(false);
2304         } else {
2305             m_networkState = NETWORK_IDLE;
2306         }
2307     }
2308 
<a name="91" id="anc91"></a><span class="line-modified">2309     if (state == MediaPlayer::NetworkState::Loading) {</span>
2310         if (m_networkState &lt; NETWORK_LOADING || m_networkState == NETWORK_NO_SOURCE)
2311             startProgressEventTimer();
2312         m_networkState = NETWORK_LOADING;
2313     }
2314 
<a name="92" id="anc92"></a><span class="line-modified">2315     if (state == MediaPlayer::NetworkState::Loaded) {</span>
2316         if (m_networkState != NETWORK_IDLE)
2317             changeNetworkStateFromLoadingToIdle();
2318         m_completelyLoaded = true;
2319     }
2320 
2321     if (hasMediaControls())
2322         mediaControls()-&gt;updateStatusDisplay();
2323 }
2324 
2325 void HTMLMediaElement::changeNetworkStateFromLoadingToIdle()
2326 {
2327     m_progressEventTimer.stop();
2328     if (hasMediaControls() &amp;&amp; m_player-&gt;didLoadingProgress())
2329         mediaControls()-&gt;bufferingProgressed();
2330 
2331     // Schedule one last progress event so we guarantee that at least one is fired
2332     // for files that load very quickly.
2333     scheduleEvent(eventNames().progressEvent);
2334     scheduleEvent(eventNames().suspendEvent);
2335     m_networkState = NETWORK_IDLE;
2336 }
2337 
<a name="93" id="anc93"></a><span class="line-modified">2338 void HTMLMediaElement::mediaPlayerReadyStateChanged()</span>
2339 {
<a name="94" id="anc94"></a><span class="line-added">2340     if (isSuspended()) {</span>
<span class="line-added">2341         queueTaskKeepingObjectAlive(*this, TaskSource::MediaElement, [this] {</span>
<span class="line-added">2342             mediaPlayerReadyStateChanged();</span>
<span class="line-added">2343         });</span>
<span class="line-added">2344         return;</span>
<span class="line-added">2345     }</span>
<span class="line-added">2346 </span>
2347     beginProcessingMediaPlayerCallback();
2348 
2349     setReadyState(m_player-&gt;readyState());
2350 
2351     endProcessingMediaPlayerCallback();
2352 }
2353 
2354 SuccessOr&lt;MediaPlaybackDenialReason&gt; HTMLMediaElement::canTransitionFromAutoplayToPlay() const
2355 {
2356     if (m_readyState != HAVE_ENOUGH_DATA) {
2357         ALWAYS_LOG(LOGIDENTIFIER, &quot;m_readyState != HAVE_ENOUGH_DATA&quot;);
2358         return MediaPlaybackDenialReason::PageConsentRequired;
2359     }
2360     if (!isAutoplaying()) {
2361         ALWAYS_LOG(LOGIDENTIFIER, &quot;!isAutoplaying&quot;);
2362         return MediaPlaybackDenialReason::PageConsentRequired;
2363     }
2364     if (!mediaSession().autoplayPermitted()) {
2365         ALWAYS_LOG(LOGIDENTIFIER, &quot;!mediaSession().autoplayPermitted&quot;);
2366         return MediaPlaybackDenialReason::PageConsentRequired;
2367     }
2368     if (!paused()) {
2369         ALWAYS_LOG(LOGIDENTIFIER, &quot;!paused&quot;);
2370         return MediaPlaybackDenialReason::PageConsentRequired;
2371     }
2372     if (!autoplay()) {
2373         ALWAYS_LOG(LOGIDENTIFIER, &quot;!autoplay&quot;);
2374         return MediaPlaybackDenialReason::PageConsentRequired;
2375     }
2376     if (pausedForUserInteraction()) {
2377         ALWAYS_LOG(LOGIDENTIFIER, &quot;pausedForUserInteraction&quot;);
2378         return MediaPlaybackDenialReason::PageConsentRequired;
2379     }
2380     if (document().isSandboxed(SandboxAutomaticFeatures)) {
2381         ALWAYS_LOG(LOGIDENTIFIER, &quot;isSandboxed&quot;);
2382         return MediaPlaybackDenialReason::PageConsentRequired;
2383     }
2384 
2385     auto permitted = mediaSession().playbackPermitted();
2386 #if !RELEASE_LOG_DISABLED
2387     if (!permitted)
2388         ALWAYS_LOG(LOGIDENTIFIER, permitted.value());
2389     else
2390         ALWAYS_LOG(LOGIDENTIFIER, &quot;can transition!&quot;);
2391 #endif
2392 
2393     return permitted;
2394 }
2395 
2396 void HTMLMediaElement::dispatchPlayPauseEventsIfNeedsQuirks()
2397 {
2398     if (!document().quirks().needsAutoplayPlayPauseEvents())
2399         return;
2400 
2401     ALWAYS_LOG(LOGIDENTIFIER);
2402     scheduleEvent(eventNames().playingEvent);
2403     scheduleEvent(eventNames().pauseEvent);
2404 }
2405 
2406 void HTMLMediaElement::setReadyState(MediaPlayer::ReadyState state)
2407 {
2408     // Set &quot;wasPotentiallyPlaying&quot; BEFORE updating m_readyState, potentiallyPlaying() uses it
2409     bool wasPotentiallyPlaying = potentiallyPlaying();
2410 
2411     ReadyState oldState = m_readyState;
2412     ReadyState newState = static_cast&lt;ReadyState&gt;(state);
2413 
2414 #if ENABLE(VIDEO_TRACK)
2415     bool tracksAreReady = textTracksAreReady();
2416 
2417     if (newState == oldState &amp;&amp; m_tracksAreReady == tracksAreReady)
2418         return;
2419 
2420     m_tracksAreReady = tracksAreReady;
2421 #else
2422     if (newState == oldState)
2423         return;
2424     bool tracksAreReady = true;
2425 #endif
2426 
2427     ALWAYS_LOG(LOGIDENTIFIER, &quot;new state = &quot;, state, &quot;, current state = &quot;, m_readyState);
2428 
2429     if (tracksAreReady)
2430         m_readyState = newState;
2431     else {
2432         // If a media file has text tracks the readyState may not progress beyond HAVE_FUTURE_DATA until
2433         // the text tracks are ready, regardless of the state of the media file.
2434         if (newState &lt;= HAVE_METADATA)
2435             m_readyState = newState;
2436         else
2437             m_readyState = HAVE_CURRENT_DATA;
2438     }
2439 
2440     if (oldState &gt; m_readyStateMaximum)
2441         m_readyStateMaximum = oldState;
2442 
2443     if (m_networkState == NETWORK_EMPTY)
2444         return;
2445 
2446     if (m_seeking) {
2447         // 4.8.10.9, step 11
2448         if (wasPotentiallyPlaying &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA)
2449             scheduleEvent(eventNames().waitingEvent);
2450 
2451         // 4.8.10.10 step 14 &amp; 15.
2452         if (m_seekRequested &amp;&amp; !m_player-&gt;seeking() &amp;&amp; m_readyState &gt;= HAVE_CURRENT_DATA)
2453             finishSeek();
2454     } else {
2455         if (wasPotentiallyPlaying &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA) {
2456             // 4.8.10.8
2457             invalidateCachedTime();
2458             scheduleTimeupdateEvent(false);
2459             scheduleEvent(eventNames().waitingEvent);
2460         }
2461     }
2462 
2463     if (m_readyState &gt;= HAVE_METADATA &amp;&amp; oldState &lt; HAVE_METADATA) {
2464         prepareMediaFragmentURI();
2465         scheduleEvent(eventNames().durationchangeEvent);
2466         scheduleResizeEvent();
2467         scheduleEvent(eventNames().loadedmetadataEvent);
2468 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2469         if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent))
2470             enqueuePlaybackTargetAvailabilityChangedEvent();
2471 #endif
2472         m_initiallyMuted = m_volume &lt; 0.05 || muted();
2473 
2474         if (hasMediaControls())
2475             mediaControls()-&gt;loadedMetadata();
2476         updateRenderer();
2477 
2478         if (is&lt;MediaDocument&gt;(document()))
2479             downcast&lt;MediaDocument&gt;(document()).mediaElementNaturalSizeChanged(expandedIntSize(m_player-&gt;naturalSize()));
2480 
2481         logMediaLoadRequest(document().page(), m_player-&gt;engineDescription(), String(), true);
2482 
2483 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
2484         scheduleUpdateMediaState();
2485 #endif
2486 
2487         m_mediaSession-&gt;clientCharacteristicsChanged();
2488     }
2489 
2490     bool shouldUpdateDisplayState = false;
2491 
2492     if (m_readyState &gt;= HAVE_CURRENT_DATA &amp;&amp; oldState &lt; HAVE_CURRENT_DATA) {
2493         if (!m_haveFiredLoadedData) {
2494             m_haveFiredLoadedData = true;
2495             scheduleEvent(eventNames().loadeddataEvent);
2496             // FIXME: It&#39;s not clear that it&#39;s correct to skip these two operations just
2497             // because m_haveFiredLoadedData is already true. At one time we were skipping
2498             // the call to setShouldDelayLoadEvent, which was definitely incorrect.
2499             shouldUpdateDisplayState = true;
2500             applyMediaFragmentURI();
2501         }
2502         setShouldDelayLoadEvent(false);
2503     }
2504 
2505     if (m_readyState == HAVE_FUTURE_DATA &amp;&amp; oldState &lt;= HAVE_CURRENT_DATA &amp;&amp; tracksAreReady) {
2506         scheduleEvent(eventNames().canplayEvent);
2507         shouldUpdateDisplayState = true;
2508     }
2509 
2510     if (m_readyState == HAVE_ENOUGH_DATA &amp;&amp; oldState &lt; HAVE_ENOUGH_DATA &amp;&amp; tracksAreReady) {
2511         if (oldState &lt;= HAVE_CURRENT_DATA)
2512             scheduleEvent(eventNames().canplayEvent);
2513 
2514         scheduleEvent(eventNames().canplaythroughEvent);
2515 
2516         auto success = canTransitionFromAutoplayToPlay();
2517         if (success) {
2518             m_paused = false;
2519             invalidateCachedTime();
2520             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::StartedWithoutUserGesture);
2521             m_playbackStartedTime = currentMediaTime().toDouble();
2522             scheduleEvent(eventNames().playEvent);
2523         } else if (success.value() == MediaPlaybackDenialReason::UserGestureRequired) {
2524             ALWAYS_LOG(LOGIDENTIFIER, &quot;Autoplay blocked, user gesture required&quot;);
2525             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
2526         }
2527 
2528         shouldUpdateDisplayState = true;
2529     }
2530 
2531     // If we transition to the Future Data state and we&#39;re about to begin playing, ensure playback is actually permitted first,
2532     // honoring any playback denial reasons such as the requirement of a user gesture.
2533     if (m_readyState == HAVE_FUTURE_DATA &amp;&amp; oldState &lt; HAVE_FUTURE_DATA &amp;&amp; potentiallyPlaying() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
2534         auto canTransition = canTransitionFromAutoplayToPlay();
2535         if (canTransition &amp;&amp; canTransition.value() == MediaPlaybackDenialReason::UserGestureRequired)
2536             ALWAYS_LOG(LOGIDENTIFIER, &quot;Autoplay blocked, user gesture required&quot;);
2537 
2538         pauseInternal();
2539         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
2540     }
2541 
2542     if (shouldUpdateDisplayState) {
2543         updateDisplayState();
2544         if (hasMediaControls()) {
2545             mediaControls()-&gt;refreshClosedCaptionsButtonVisibility();
2546             mediaControls()-&gt;updateStatusDisplay();
2547         }
2548     }
2549 
2550     updatePlayState();
2551     updateMediaController();
2552 #if ENABLE(VIDEO_TRACK)
2553     updateActiveTextTrackCues(currentMediaTime());
2554 #endif
2555 }
2556 
2557 #if ENABLE(LEGACY_ENCRYPTED_MEDIA)
2558 RefPtr&lt;ArrayBuffer&gt; HTMLMediaElement::mediaPlayerCachedKeyForKeyId(const String&amp; keyId) const
2559 {
2560     return m_webKitMediaKeys ? m_webKitMediaKeys-&gt;cachedKeyForKeyId(keyId) : nullptr;
2561 }
2562 
<a name="95" id="anc95"></a><span class="line-modified">2563 bool HTMLMediaElement::mediaPlayerKeyNeeded(Uint8Array* initData)</span>
2564 {
2565     if (!RuntimeEnabledFeatures::sharedFeatures().legacyEncryptedMediaAPIEnabled())
2566         return false;
2567 
2568     if (!hasEventListeners(&quot;webkitneedkey&quot;)
2569 #if ENABLE(ENCRYPTED_MEDIA)
2570         // Only fire an error if ENCRYPTED_MEDIA is not enabled, to give clients of the
2571         // &quot;encrypted&quot; event a chance to handle it without resulting in a synthetic error.
2572         &amp;&amp; (!RuntimeEnabledFeatures::sharedFeatures().encryptedMediaAPIEnabled() || document().quirks().hasBrokenEncryptedMediaAPISupportQuirk())
2573 #endif
2574         ) {
2575         m_error = MediaError::create(MediaError::MEDIA_ERR_ENCRYPTED);
2576         scheduleEvent(eventNames().errorEvent);
2577         return false;
2578     }
2579 
2580     auto event = WebKitMediaKeyNeededEvent::create(eventNames().webkitneedkeyEvent, initData);
2581     event-&gt;setTarget(this);
<a name="96" id="anc96"></a><span class="line-modified">2582     m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
2583 
2584     return true;
2585 }
2586 
2587 String HTMLMediaElement::mediaPlayerMediaKeysStorageDirectory() const
2588 {
2589     auto* page = document().page();
2590     if (!page || page-&gt;usesEphemeralSession())
2591         return emptyString();
2592 
2593     String storageDirectory = document().settings().mediaKeysStorageDirectory();
2594     if (storageDirectory.isEmpty())
2595         return emptyString();
2596 
2597     return FileSystem::pathByAppendingComponent(storageDirectory, document().securityOrigin().data().databaseIdentifier());
2598 }
2599 
2600 void HTMLMediaElement::webkitSetMediaKeys(WebKitMediaKeys* mediaKeys)
2601 {
2602     if (!RuntimeEnabledFeatures::sharedFeatures().legacyEncryptedMediaAPIEnabled())
2603         return;
2604 
2605     if (m_webKitMediaKeys == mediaKeys)
2606         return;
2607 
2608     if (m_webKitMediaKeys)
2609         m_webKitMediaKeys-&gt;setMediaElement(nullptr);
2610     m_webKitMediaKeys = mediaKeys;
2611     if (m_webKitMediaKeys)
2612         m_webKitMediaKeys-&gt;setMediaElement(this);
2613 }
2614 
2615 void HTMLMediaElement::keyAdded()
2616 {
2617     if (!RuntimeEnabledFeatures::sharedFeatures().legacyEncryptedMediaAPIEnabled())
2618         return;
2619 
2620     if (m_player)
2621         m_player-&gt;keyAdded();
2622 }
2623 
2624 #endif
2625 
2626 #if ENABLE(ENCRYPTED_MEDIA)
2627 
2628 MediaKeys* HTMLMediaElement::mediaKeys() const
2629 {
2630     return m_mediaKeys.get();
2631 }
2632 
2633 void HTMLMediaElement::setMediaKeys(MediaKeys* mediaKeys, Ref&lt;DeferredPromise&gt;&amp;&amp; promise)
2634 {
2635     // https://w3c.github.io/encrypted-media/#dom-htmlmediaelement-setmediakeys
2636     // W3C Editor&#39;s Draft 23 June 2017
2637 
2638     // 1. If this object&#39;s attaching media keys value is true, return a promise rejected with an InvalidStateError.
2639     if (m_attachingMediaKeys) {
2640         promise-&gt;reject(InvalidStateError);
2641         return;
2642     }
2643 
2644     // 2. If mediaKeys and the mediaKeys attribute are the same object, return a resolved promise.
2645     if (mediaKeys == m_mediaKeys) {
2646         promise-&gt;resolve();
2647         return;
2648     }
2649 
2650     // 3. Let this object&#39;s attaching media keys value be true.
2651     m_attachingMediaKeys = true;
2652 
2653     // 4. Let promise be a new promise.
2654     // 5. Run the following steps in parallel:
2655     m_encryptedMediaQueue.enqueueTask([this, mediaKeys = RefPtr&lt;MediaKeys&gt;(mediaKeys), promise = WTFMove(promise)]() mutable {
2656         // 5.1. If all the following conditions hold:
2657         //      - mediaKeys is not null,
2658         //      - the CDM instance represented by mediaKeys is already in use by another media element
2659         //      - the user agent is unable to use it with this element
2660         //      then let this object&#39;s attaching media keys value be false and reject promise with a QuotaExceededError.
2661         // FIXME: ^
2662 
2663         // 5.2. If the mediaKeys attribute is not null, run the following steps:
2664         if (m_mediaKeys) {
2665             // 5.2.1. If the user agent or CDM do not support removing the association, let this object&#39;s attaching media keys value be false and reject promise with a NotSupportedError.
2666             // 5.2.2. If the association cannot currently be removed, let this object&#39;s attaching media keys value be false and reject promise with an InvalidStateError.
2667             // 5.2.3. Stop using the CDM instance represented by the mediaKeys attribute to decrypt media data and remove the association with the media element.
2668             // 5.2.4. If the preceding step failed, let this object&#39;s attaching media keys value be false and reject promise with the appropriate error name.
2669             // FIXME: ^
2670 
2671             m_mediaKeys-&gt;detachCDMClient(*this);
2672             if (m_player)
2673                 m_player-&gt;cdmInstanceDetached(m_mediaKeys-&gt;cdmInstance());
2674         }
2675 
2676         // 5.3. If mediaKeys is not null, run the following steps:
2677         if (mediaKeys) {
2678             // 5.3.1. Associate the CDM instance represented by mediaKeys with the media element for decrypting media data.
2679             mediaKeys-&gt;attachCDMClient(*this);
2680             if (m_player)
2681                 m_player-&gt;cdmInstanceAttached(mediaKeys-&gt;cdmInstance());
2682 
2683             // 5.3.2. If the preceding step failed, run the following steps:
2684             //   5.3.2.1. Set the mediaKeys attribute to null.
2685             //   5.3.2.2. Let this object&#39;s attaching media keys value be false.
2686             //   5.3.2.3. Reject promise with a new DOMException whose name is the appropriate error name.
2687             // FIXME: ^
2688 
2689             // 5.3.3. Queue a task to run the Attempt to Resume Playback If Necessary algorithm on the media element.
2690             m_encryptedMediaQueue.enqueueTask([this] {
2691                 attemptToResumePlaybackIfNecessary();
2692             });
2693         }
2694 
2695         // 5.4. Set the mediaKeys attribute to mediaKeys.
2696         // 5.5. Let this object&#39;s attaching media keys value be false.
2697         // 5.6. Resolve promise.
2698         m_mediaKeys = WTFMove(mediaKeys);
2699         m_attachingMediaKeys = false;
2700         promise-&gt;resolve();
2701     });
2702 
2703     // 6. Return promise.
2704 }
2705 
2706 void HTMLMediaElement::mediaPlayerInitializationDataEncountered(const String&amp; initDataType, RefPtr&lt;ArrayBuffer&gt;&amp;&amp; initData)
2707 {
2708     if (!RuntimeEnabledFeatures::sharedFeatures().encryptedMediaAPIEnabled() || document().quirks().hasBrokenEncryptedMediaAPISupportQuirk())
2709         return;
2710 
2711     // https://w3c.github.io/encrypted-media/#initdata-encountered
2712     // W3C Editor&#39;s Draft 23 June 2017
2713 
2714     // 1. Let the media element be the specified HTMLMediaElement object.
2715     // 2. Let initDataType be the empty string.
2716     // 3. Let initData be null.
2717     // 4. If the media data is CORS-same-origin and not mixed content, run the following steps:
2718     //   4.1. Let initDataType be the string representing the Initialization Data Type of the Initialization Data.
2719     //   4.2. Let initData be the Initialization Data.
2720     // FIXME: ^
2721 
2722     // 5. Queue a task to create an event named encrypted that does not bubble and is not cancellable using the
2723     //    MediaEncryptedEvent interface with its type attribute set to encrypted and its isTrusted attribute
2724     //    initialized to true, and dispatch it at the media element.
2725     //    The event interface MediaEncryptedEvent has:
2726     //      initDataType = initDataType
2727     //      initData = initData
2728     MediaEncryptedEventInit initializer { initDataType, WTFMove(initData) };
<a name="97" id="anc97"></a><span class="line-modified">2729     m_asyncEventQueue-&gt;enqueueEvent(MediaEncryptedEvent::create(eventNames().encryptedEvent, initializer, Event::IsTrusted::Yes));</span>
2730 }
2731 
2732 void HTMLMediaElement::mediaPlayerWaitingForKeyChanged()
2733 {
2734     if (!m_player)
2735         return;
2736 
2737     if (!m_player-&gt;waitingForKey() &amp;&amp; m_playbackBlockedWaitingForKey) {
2738         // https://w3c.github.io/encrypted-media/#resume-playback
2739         // W3C Editor&#39;s Draft 23 June 2017
2740 
2741         // NOTE: continued from HTMLMediaElement::attemptToDecrypt().
2742         // 4. If the user agent can advance the current playback position in the direction of playback:
2743         //   4.1. Set the media element&#39;s decryption blocked waiting for key value to false.
2744         // FIXME: ^
2745         //   4.2. Set the media element&#39;s playback blocked waiting for key value to false.
2746         m_playbackBlockedWaitingForKey = false;
2747 
2748         //   4.3. Set the media element&#39;s readyState value to HAVE_CURRENT_DATA, HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA as appropriate.
2749         setReadyState(m_player-&gt;readyState());
2750 
2751         return;
2752     }
2753 
2754     // https://www.w3.org/TR/encrypted-media/#wait-for-key
2755     // W3C Recommendation 18 September 2017
2756 
2757     // The Wait for Key algorithm queues a waitingforkey event and
2758     // updates readyState. It should only be called when the
2759     // HTMLMediaElement object is potentially playing and its
2760     // readyState is equal to HAVE_FUTURE_DATA or greater. Requests to
2761     // run this algorithm include a target HTMLMediaElement object.
2762 
2763     // The following steps are run:
2764 
2765     // 1. Let the media element be the specified HTMLMediaElement
2766     // object.
2767     // 2. If the media element&#39;s playback blocked waiting for key
2768     // value is true, abort these steps.
2769     if (m_playbackBlockedWaitingForKey)
2770         return;
2771 
2772     // 3. Set the media element&#39;s playback blocked waiting for key
2773     // value to true.
2774     m_playbackBlockedWaitingForKey = true;
2775 
2776     // NOTE
2777     // As a result of the above step, the media element will become a
2778     // blocked media element if it wasn&#39;t already. In that case, the
2779     // media element will stop playback.
2780 
2781     // 4. Follow the steps for the first matching condition from the
2782     // following list:
2783 
2784     // If data for the immediate current playback position is
2785     // available
2786     // Set the readyState of media element to HAVE_CURRENT_DATA.
2787     // Otherwise
2788     // Set the readyState of media element to HAVE_METADATA.
2789     ReadyState nextReadyState = buffered()-&gt;contain(currentTime()) ? HAVE_CURRENT_DATA : HAVE_METADATA;
2790     if (nextReadyState &lt; m_readyState)
2791         setReadyState(static_cast&lt;MediaPlayer::ReadyState&gt;(nextReadyState));
2792 
2793     // NOTE
2794     // In other words, if the video frame and audio data for the
2795     // current playback position have been decoded because they were
2796     // unencrypted and/or successfully decrypted, set readyState to
2797     // HAVE_CURRENT_DATA. Otherwise, including if this was previously
2798     // the case but the data is no longer available, set readyState to
2799     // HAVE_METADATA.
2800 
2801     // 5. Queue a task to fire a simple event named waitingforkey at the
2802     // media element.
2803     scheduleEvent(eventNames().waitingforkeyEvent);
2804 
2805     // 6. Suspend playback.
2806     // GStreamer handles this without suspending explicitly.
2807 }
2808 
2809 void HTMLMediaElement::attemptToDecrypt()
2810 {
2811     // https://w3c.github.io/encrypted-media/#attempt-to-decrypt
2812     // W3C Editor&#39;s Draft 23 June 2017
2813 
2814     // 1. Let the media element be the specified HTMLMediaElement object.
2815     // 2. If the media element&#39;s encrypted block queue is empty, abort these steps.
2816     // FIXME: ^
2817 
2818     // 3. If the media element&#39;s mediaKeys attribute is not null, run the following steps:
2819     if (m_mediaKeys) {
2820         // 3.1. Let media keys be the MediaKeys object referenced by that attribute.
2821         // 3.2. Let cdm be the CDM instance represented by media keys&#39;s cdm instance value.
2822         auto&amp; cdmInstance = m_mediaKeys-&gt;cdmInstance();
2823 
2824         // 3.3. If cdm is no longer usable for any reason, run the following steps:
2825         //   3.3.1. Run the media data is corrupted steps of the resource fetch algorithm.
2826         //   3.3.2. Run the CDM Unavailable algorithm on media keys.
2827         //   3.3.3. Abort these steps.
2828         // FIXME: ^
2829 
2830         // 3.4. If there is at least one MediaKeySession created by the media keys that is not closed, run the following steps:
2831         if (m_mediaKeys-&gt;hasOpenSessions()) {
2832             // Continued in MediaPlayer::attemptToDecryptWithInstance().
2833             if (m_player)
2834                 m_player-&gt;attemptToDecryptWithInstance(cdmInstance);
2835         }
2836     }
2837 
2838     // 4. Set the media element&#39;s decryption blocked waiting for key value to true.
2839     // FIXME: ^
2840 }
2841 
2842 void HTMLMediaElement::attemptToResumePlaybackIfNecessary()
2843 {
2844     // https://w3c.github.io/encrypted-media/#resume-playback
2845     // W3C Editor&#39;s Draft 23 June 2017
2846 
2847     // 1. Let the media element be the specified HTMLMediaElement object.
2848     // 2. If the media element&#39;s playback blocked waiting for key is false, abort these steps.
2849     if (!m_playbackBlockedWaitingForKey)
2850         return;
2851 
2852     // 3. Run the Attempt to Decrypt algorithm on the media element.
2853     attemptToDecrypt();
2854 
2855     // NOTE: continued in HTMLMediaElement::waitingForKeyChanged()
2856 }
2857 
2858 void HTMLMediaElement::cdmClientAttemptToResumePlaybackIfNecessary()
2859 {
2860     attemptToResumePlaybackIfNecessary();
2861 }
2862 
2863 #endif // ENABLE(ENCRYPTED_MEDIA)
2864 
2865 void HTMLMediaElement::progressEventTimerFired()
2866 {
2867     ASSERT(m_player);
2868     if (m_networkState != NETWORK_LOADING)
2869         return;
2870 
2871     MonotonicTime time = MonotonicTime::now();
2872     Seconds timedelta = time - m_previousProgressTime;
2873 
2874     if (m_player-&gt;didLoadingProgress()) {
2875         scheduleEvent(eventNames().progressEvent);
2876         m_previousProgressTime = time;
2877         m_sentStalledEvent = false;
2878         updateRenderer();
2879         if (hasMediaControls())
2880             mediaControls()-&gt;bufferingProgressed();
2881     } else if (timedelta &gt; 3_s &amp;&amp; !m_sentStalledEvent) {
2882         scheduleEvent(eventNames().stalledEvent);
2883         m_sentStalledEvent = true;
2884         setShouldDelayLoadEvent(false);
2885     }
2886 }
2887 
2888 void HTMLMediaElement::rewind(double timeDelta)
2889 {
2890     setCurrentTime(std::max(currentMediaTime() - MediaTime::createWithDouble(timeDelta), minTimeSeekable()));
2891 }
2892 
2893 void HTMLMediaElement::returnToRealtime()
2894 {
2895     setCurrentTime(maxTimeSeekable());
2896 }
2897 
2898 void HTMLMediaElement::addPlayedRange(const MediaTime&amp; start, const MediaTime&amp; end)
2899 {
2900     DEBUG_LOG(LOGIDENTIFIER, MediaTimeRange { start, end });
2901     if (!m_playedTimeRanges)
2902         m_playedTimeRanges = TimeRanges::create();
2903     m_playedTimeRanges-&gt;ranges().add(start, end);
2904 }
2905 
2906 bool HTMLMediaElement::supportsScanning() const
2907 {
2908     return m_player ? m_player-&gt;supportsScanning() : false;
2909 }
2910 
2911 void HTMLMediaElement::prepareToPlay()
2912 {
2913     ScriptDisallowedScope::InMainThread scriptDisallowedScope;
2914 
2915     INFO_LOG(LOGIDENTIFIER);
2916     if (m_havePreparedToPlay || !document().hasBrowsingContext())
2917         return;
2918     m_havePreparedToPlay = true;
2919     if (m_player)
2920         m_player-&gt;prepareToPlay();
2921 }
2922 
2923 void HTMLMediaElement::fastSeek(double time)
2924 {
2925     fastSeek(MediaTime::createWithDouble(time));
2926 }
2927 
2928 void HTMLMediaElement::fastSeek(const MediaTime&amp; time)
2929 {
2930     INFO_LOG(LOGIDENTIFIER, time);
2931     // 4.7.10.9 Seeking
2932     // 9. If the approximate-for-speed flag is set, adjust the new playback position to a value that will
2933     // allow for playback to resume promptly. If new playback position before this step is before current
2934     // playback position, then the adjusted new playback position must also be before the current playback
2935     // position. Similarly, if the new playback position before this step is after current playback position,
2936     // then the adjusted new playback position must also be after the current playback position.
2937     refreshCachedTime();
2938 
2939     MediaTime delta = time - currentMediaTime();
2940     MediaTime negativeTolerance = delta &lt; MediaTime::zeroTime() ? MediaTime::positiveInfiniteTime() : delta;
2941     seekWithTolerance(time, negativeTolerance, MediaTime::zeroTime(), true);
2942 }
2943 
2944 void HTMLMediaElement::seek(const MediaTime&amp; time)
2945 {
2946     INFO_LOG(LOGIDENTIFIER, time);
2947     seekWithTolerance(time, MediaTime::zeroTime(), MediaTime::zeroTime(), true);
2948 }
2949 
2950 void HTMLMediaElement::seekInternal(const MediaTime&amp; time)
2951 {
2952     INFO_LOG(LOGIDENTIFIER, time);
2953     seekWithTolerance(time, MediaTime::zeroTime(), MediaTime::zeroTime(), false);
2954 }
2955 
2956 void HTMLMediaElement::seekWithTolerance(const MediaTime&amp; inTime, const MediaTime&amp; negativeTolerance, const MediaTime&amp; positiveTolerance, bool fromDOM)
2957 {
2958     // 4.8.10.9 Seeking
2959     MediaTime time = inTime;
2960 
2961     // 1 - Set the media element&#39;s show poster flag to false.
2962     setDisplayMode(Video);
2963 
2964     // 2 - If the media element&#39;s readyState is HAVE_NOTHING, abort these steps.
2965     if (m_readyState == HAVE_NOTHING || !m_player)
2966         return;
2967 
2968     // If the media engine has been told to postpone loading data, let it go ahead now.
<a name="98" id="anc98"></a><span class="line-modified">2969     if (m_preload &lt; MediaPlayer::Preload::Auto &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA)</span>
2970         prepareToPlay();
2971 
2972     // Get the current time before setting m_seeking, m_lastSeekTime is returned once it is set.
2973     refreshCachedTime();
2974     MediaTime now = currentMediaTime();
2975 
2976     // 3 - If the element&#39;s seeking IDL attribute is true, then another instance of this algorithm is
2977     // already running. Abort that other instance of the algorithm without waiting for the step that
2978     // it is running to complete.
2979     if (m_seekTaskQueue.hasPendingTask()) {
2980         INFO_LOG(LOGIDENTIFIER, &quot;cancelling pending seeks&quot;);
2981         m_seekTaskQueue.cancelTask();
2982         if (m_pendingSeek) {
2983             now = m_pendingSeek-&gt;now;
2984             m_pendingSeek = nullptr;
2985         }
2986         m_pendingSeekType = NoSeek;
2987     }
2988 
2989     // 4 - Set the seeking IDL attribute to true.
2990     // The flag will be cleared when the engine tells us the time has actually changed.
2991     m_seeking = true;
2992     if (m_playing) {
2993         if (m_lastSeekTime &lt; now)
2994             addPlayedRange(m_lastSeekTime, now);
2995     }
2996     m_lastSeekTime = time;
2997 
2998     // 5 - If the seek was in response to a DOM method call or setting of an IDL attribute, then continue
2999     // the script. The remainder of these steps must be run asynchronously.
3000     m_pendingSeek = makeUnique&lt;PendingSeek&gt;(now, time, negativeTolerance, positiveTolerance);
3001     if (fromDOM) {
3002         INFO_LOG(LOGIDENTIFIER, &quot;enqueuing seek from &quot;, now, &quot; to &quot;, time);
3003         m_seekTaskQueue.scheduleTask(std::bind(&amp;HTMLMediaElement::seekTask, this));
3004     } else
3005         seekTask();
3006 
3007     if (processingUserGestureForMedia())
3008         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager);
3009 }
3010 
3011 void HTMLMediaElement::seekTask()
3012 {
3013     INFO_LOG(LOGIDENTIFIER);
3014 
3015     if (!m_player) {
3016         clearSeeking();
3017         return;
3018     }
3019 
3020     ASSERT(m_pendingSeek);
3021     MediaTime now = m_pendingSeek-&gt;now;
3022     MediaTime time = m_pendingSeek-&gt;targetTime;
3023     MediaTime negativeTolerance = m_pendingSeek-&gt;negativeTolerance;
3024     MediaTime positiveTolerance = m_pendingSeek-&gt;positiveTolerance;
3025     m_pendingSeek = nullptr;
3026 
3027     ASSERT(negativeTolerance &gt;= MediaTime::zeroTime());
3028 
3029     // 6 - If the new playback position is later than the end of the media resource, then let it be the end
3030     // of the media resource instead.
3031     time = std::min(time, durationMediaTime());
3032 
3033     // 7 - If the new playback position is less than the earliest possible position, let it be that position instead.
3034     MediaTime earliestTime = m_player-&gt;startTime();
3035     time = std::max(time, earliestTime);
3036 
3037     // Ask the media engine for the time value in the movie&#39;s time scale before comparing with current time. This
3038     // is necessary because if the seek time is not equal to currentTime but the delta is less than the movie&#39;s
3039     // time scale, we will ask the media engine to &quot;seek&quot; to the current movie time, which may be a noop and
3040     // not generate a timechanged callback. This means m_seeking will never be cleared and we will never
3041     // fire a &#39;seeked&#39; event.
3042     if (willLog(WTFLogLevel::Debug)) {
3043         MediaTime mediaTime = m_player-&gt;mediaTimeForTimeValue(time);
3044         if (time != mediaTime)
3045             INFO_LOG(LOGIDENTIFIER, time, &quot; media timeline equivalent is &quot;, mediaTime);
3046     }
3047 
3048     time = m_player-&gt;mediaTimeForTimeValue(time);
3049 
3050     // 8 - If the (possibly now changed) new playback position is not in one of the ranges given in the
3051     // seekable attribute, then let it be the position in one of the ranges given in the seekable attribute
3052     // that is the nearest to the new playback position. ... If there are no ranges given in the seekable
3053     // attribute then set the seeking IDL attribute to false and abort these steps.
3054     RefPtr&lt;TimeRanges&gt; seekableRanges = seekable();
3055     bool noSeekRequired = !seekableRanges-&gt;length();
3056 
3057     // Short circuit seeking to the current time by just firing the events if no seek is required.
3058     // Don&#39;t skip calling the media engine if 1) we are in poster mode (because a seek should always cancel
3059     // poster display), or 2) if there is a pending fast seek, or 3) if this seek is not an exact seek
3060     SeekType thisSeekType = (negativeTolerance == MediaTime::zeroTime() &amp;&amp; positiveTolerance == MediaTime::zeroTime()) ? Precise : Fast;
3061     if (!noSeekRequired &amp;&amp; time == now &amp;&amp; thisSeekType == Precise &amp;&amp; m_pendingSeekType != Fast &amp;&amp; displayMode() != Poster)
3062         noSeekRequired = true;
3063 
3064 #if ENABLE(MEDIA_SOURCE)
3065     // Always notify the media engine of a seek if the source is not closed. This ensures that the source is
3066     // always in a flushed state when the &#39;seeking&#39; event fires.
3067     if (m_mediaSource &amp;&amp; !m_mediaSource-&gt;isClosed())
3068         noSeekRequired = false;
3069 #endif
3070 
3071     if (noSeekRequired) {
3072         INFO_LOG(LOGIDENTIFIER, &quot;ignored seek to &quot;, time);
3073         if (time == now) {
3074             scheduleEvent(eventNames().seekingEvent);
3075             scheduleTimeupdateEvent(false);
3076             scheduleEvent(eventNames().seekedEvent);
3077         }
3078         clearSeeking();
3079         return;
3080     }
3081     time = seekableRanges-&gt;ranges().nearest(time);
3082 
3083     m_sentEndEvent = false;
3084     m_lastSeekTime = time;
3085     m_pendingSeekType = thisSeekType;
3086     m_seeking = true;
3087 
3088     // 10 - Queue a task to fire a simple event named seeking at the element.
3089     scheduleEvent(eventNames().seekingEvent);
3090 
3091     // 11 - Set the current playback position to the given new playback position
3092     m_seekRequested = true;
3093     m_player-&gt;seekWithTolerance(time, negativeTolerance, positiveTolerance);
3094 
3095     // 12 - Wait until the user agent has established whether or not the media data for the new playback
3096     // position is available, and, if it is, until it has decoded enough data to play back that position.
3097     // 13 - Await a stable state. The synchronous section consists of all the remaining steps of this algorithm.
3098 }
3099 
3100 void HTMLMediaElement::clearSeeking()
3101 {
3102     m_seeking = false;
3103     m_seekRequested = false;
3104     m_pendingSeekType = NoSeek;
3105     invalidateCachedTime();
3106 }
3107 
3108 void HTMLMediaElement::finishSeek()
3109 {
3110     // 4.8.10.9 Seeking
3111     // 14 - Set the seeking IDL attribute to false.
3112     clearSeeking();
3113 
3114     INFO_LOG(LOGIDENTIFIER, &quot;current time = &quot;, currentMediaTime());
3115 
3116     // 15 - Run the time maches on steps.
3117     // Handled by mediaPlayerTimeChanged().
3118 
3119     // 16 - Queue a task to fire a simple event named timeupdate at the element.
3120     scheduleEvent(eventNames().timeupdateEvent);
3121 
3122     // 17 - Queue a task to fire a simple event named seeked at the element.
3123     scheduleEvent(eventNames().seekedEvent);
3124 
3125     if (m_mediaSession)
3126         m_mediaSession-&gt;clientCharacteristicsChanged();
3127 
3128 #if ENABLE(MEDIA_SOURCE)
3129     if (m_mediaSource)
3130         m_mediaSource-&gt;monitorSourceBuffers();
3131 #endif
3132 }
3133 
3134 HTMLMediaElement::ReadyState HTMLMediaElement::readyState() const
3135 {
3136     return m_readyState;
3137 }
3138 
3139 MediaPlayer::MovieLoadType HTMLMediaElement::movieLoadType() const
3140 {
<a name="99" id="anc99"></a><span class="line-modified">3141     return m_player ? m_player-&gt;movieLoadType() : MediaPlayer::MovieLoadType::Unknown;</span>
3142 }
3143 
3144 bool HTMLMediaElement::hasAudio() const
3145 {
3146     return m_player ? m_player-&gt;hasAudio() : false;
3147 }
3148 
3149 bool HTMLMediaElement::seeking() const
3150 {
3151     return m_seeking;
3152 }
3153 
3154 void HTMLMediaElement::refreshCachedTime() const
3155 {
3156     if (!m_player)
3157         return;
3158 
3159     m_cachedTime = m_player-&gt;currentTime();
3160     if (!m_cachedTime) {
3161         // Do not use m_cachedTime until the media engine returns a non-zero value because we can&#39;t
3162         // estimate current time until playback actually begins.
3163         invalidateCachedTime();
3164         return;
3165     }
3166 
3167     m_clockTimeAtLastCachedTimeUpdate = MonotonicTime::now();
3168 }
3169 
3170 void HTMLMediaElement::invalidateCachedTime() const
3171 {
3172     m_cachedTime = MediaTime::invalidTime();
3173     if (!m_player || !m_player-&gt;maximumDurationToCacheMediaTime())
3174         return;
3175 
3176     // Don&#39;t try to cache movie time when playback first starts as the time reported by the engine
3177     // sometimes fluctuates for a short amount of time, so the cached time will be off if we take it
3178     // too early.
3179     static const Seconds minimumTimePlayingBeforeCacheSnapshot = 500_ms;
3180 
3181     m_minimumClockTimeToUpdateCachedTime = MonotonicTime::now() + minimumTimePlayingBeforeCacheSnapshot;
3182 }
3183 
3184 // playback state
3185 double HTMLMediaElement::currentTime() const
3186 {
3187     return currentMediaTime().toDouble();
3188 }
3189 
3190 MediaTime HTMLMediaElement::currentMediaTime() const
3191 {
3192 #if LOG_CACHED_TIME_WARNINGS
3193     static const MediaTime minCachedDeltaForWarning = MediaTime::create(1, 100);
3194 #endif
3195 
3196     if (!m_player)
3197         return MediaTime::zeroTime();
3198 
3199     if (m_seeking) {
3200         INFO_LOG(LOGIDENTIFIER, &quot;seeking, returning&quot;, m_lastSeekTime);
3201         return m_lastSeekTime;
3202     }
3203 
3204     if (m_cachedTime.isValid() &amp;&amp; m_paused) {
3205 #if LOG_CACHED_TIME_WARNINGS
3206         MediaTime delta = m_cachedTime - m_player-&gt;currentTime();
3207         if (delta &gt; minCachedDeltaForWarning)
3208             WARNING_LOG(LOGIDENTIFIER, &quot;cached time is &quot;, delta, &quot; seconds off of media time when paused&quot;);
3209 #endif
3210         return m_cachedTime;
3211     }
3212 
3213     // Is it too soon use a cached time?
3214     MonotonicTime now = MonotonicTime::now();
3215     double maximumDurationToCacheMediaTime = m_player-&gt;maximumDurationToCacheMediaTime();
3216 
3217     if (maximumDurationToCacheMediaTime &amp;&amp; m_cachedTime.isValid() &amp;&amp; !m_paused &amp;&amp; now &gt; m_minimumClockTimeToUpdateCachedTime) {
3218         Seconds clockDelta = now - m_clockTimeAtLastCachedTimeUpdate;
3219 
3220         // Not too soon, use the cached time only if it hasn&#39;t expired.
3221         if (clockDelta.seconds() &lt; maximumDurationToCacheMediaTime) {
3222             MediaTime adjustedCacheTime = m_cachedTime + MediaTime::createWithDouble(effectivePlaybackRate() * clockDelta.seconds());
3223 
3224 #if LOG_CACHED_TIME_WARNINGS
3225             MediaTime delta = adjustedCacheTime - m_player-&gt;currentTime();
3226             if (delta &gt; minCachedDeltaForWarning)
3227                 WARNING_LOG(LOGIDENTIFIER, &quot;cached time is &quot;, delta, &quot; seconds off of media time when playing&quot;);
3228 #endif
3229             return adjustedCacheTime;
3230         }
3231     }
3232 
3233 #if LOG_CACHED_TIME_WARNINGS
3234     if (maximumDurationToCacheMediaTime &amp;&amp; now &gt; m_minimumClockTimeToUpdateCachedTime &amp;&amp; m_cachedTime != MediaPlayer::invalidTime()) {
3235         Seconds clockDelta = now - m_clockTimeAtLastCachedTimeUpdate;
3236         MediaTime delta = m_cachedTime + MediaTime::createWithDouble(effectivePlaybackRate() * clockDelta.seconds()) - m_player-&gt;currentTime();
3237         WARNING_LOG(LOGIDENTIFIER, &quot;cached time was &quot;, delta, &quot; seconds off of media time when it expired&quot;);
3238     }
3239 #endif
3240 
3241     refreshCachedTime();
3242 
3243     if (m_cachedTime.isInvalid())
3244         return MediaTime::zeroTime();
3245 
3246     return m_cachedTime;
3247 }
3248 
3249 void HTMLMediaElement::setCurrentTime(double time)
3250 {
3251     setCurrentTime(MediaTime::createWithDouble(time));
3252 }
3253 
3254 void HTMLMediaElement::setCurrentTimeWithTolerance(double time, double toleranceBefore, double toleranceAfter)
3255 {
3256     seekWithTolerance(MediaTime::createWithDouble(time), MediaTime::createWithDouble(toleranceBefore), MediaTime::createWithDouble(toleranceAfter), true);
3257 }
3258 
3259 void HTMLMediaElement::setCurrentTime(const MediaTime&amp; time)
3260 {
3261     if (m_mediaController)
3262         return;
3263 
3264     seekInternal(time);
3265 }
3266 
3267 ExceptionOr&lt;void&gt; HTMLMediaElement::setCurrentTimeForBindings(double time)
3268 {
3269     if (m_mediaController)
3270         return Exception { InvalidStateError };
3271     seek(MediaTime::createWithDouble(time));
3272     return { };
3273 }
3274 
3275 double HTMLMediaElement::duration() const
3276 {
3277     return durationMediaTime().toDouble();
3278 }
3279 
3280 MediaTime HTMLMediaElement::durationMediaTime() const
3281 {
3282     if (m_player &amp;&amp; m_readyState &gt;= HAVE_METADATA)
3283         return m_player-&gt;duration();
3284 
3285     return MediaTime::invalidTime();
3286 }
3287 
3288 bool HTMLMediaElement::paused() const
3289 {
3290     // As of this writing, JavaScript garbage collection calls this function directly. In the past
3291     // we had problems where this was called on an object after a bad cast. The assertion below
3292     // made our regression test detect the problem, so we should keep it because of that. But note
3293     // that the value of the assertion relies on the compiler not being smart enough to know that
3294     // isHTMLUnknownElement is guaranteed to return false for an HTMLMediaElement.
3295     ASSERT(!isHTMLUnknownElement());
3296 
3297     return m_paused;
3298 }
3299 
3300 double HTMLMediaElement::defaultPlaybackRate() const
3301 {
3302 #if ENABLE(MEDIA_STREAM)
3303     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3304     // &quot;defaultPlaybackRate&quot; - On setting: ignored. On getting: return 1.0
3305     // A MediaStream is not seekable. Therefore, this attribute must always have the
3306     // value 1.0 and any attempt to alter it must be ignored. Note that this also means
3307     // that the ratechange event will not fire.
3308     if (m_mediaStreamSrcObject)
3309         return 1;
3310 #endif
3311 
3312     return m_defaultPlaybackRate;
3313 }
3314 
3315 void HTMLMediaElement::setDefaultPlaybackRate(double rate)
3316 {
3317 #if ENABLE(MEDIA_STREAM)
3318     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3319     // &quot;defaultPlaybackRate&quot; - On setting: ignored. On getting: return 1.0
3320     // A MediaStream is not seekable. Therefore, this attribute must always have the
3321     // value 1.0 and any attempt to alter it must be ignored. Note that this also means
3322     // that the ratechange event will not fire.
3323     if (m_mediaStreamSrcObject)
3324         return;
3325 #endif
3326 
3327     if (m_defaultPlaybackRate == rate)
3328         return;
3329 
3330     ALWAYS_LOG(LOGIDENTIFIER, rate);
3331     m_defaultPlaybackRate = rate;
3332     scheduleEvent(eventNames().ratechangeEvent);
3333 }
3334 
3335 double HTMLMediaElement::effectivePlaybackRate() const
3336 {
3337     return m_mediaController ? m_mediaController-&gt;playbackRate() : m_reportedPlaybackRate;
3338 }
3339 
3340 double HTMLMediaElement::requestedPlaybackRate() const
3341 {
3342     return m_mediaController ? m_mediaController-&gt;playbackRate() : m_requestedPlaybackRate;
3343 }
3344 
3345 double HTMLMediaElement::playbackRate() const
3346 {
3347 #if ENABLE(MEDIA_STREAM)
3348     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3349     // &quot;playbackRate&quot; - A MediaStream is not seekable. Therefore, this attribute must always
3350     // have the value 1.0 and any attempt to alter it must be ignored. Note that this also
3351     // means that the ratechange event will not fire.
3352     if (m_mediaStreamSrcObject)
3353         return 1;
3354 #endif
3355 
3356     return m_requestedPlaybackRate;
3357 }
3358 
3359 void HTMLMediaElement::setPlaybackRate(double rate)
3360 {
3361     ALWAYS_LOG(LOGIDENTIFIER, rate);
3362 
3363 #if ENABLE(MEDIA_STREAM)
3364     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3365     // &quot;playbackRate&quot; - A MediaStream is not seekable. Therefore, this attribute must always
3366     // have the value 1.0 and any attempt to alter it must be ignored. Note that this also
3367     // means that the ratechange event will not fire.
3368     if (m_mediaStreamSrcObject)
3369         return;
3370 #endif
3371 
3372     if (m_player &amp;&amp; potentiallyPlaying() &amp;&amp; m_player-&gt;rate() != rate &amp;&amp; !m_mediaController)
3373         m_player-&gt;setRate(rate);
3374 
3375     if (m_requestedPlaybackRate != rate) {
3376         m_reportedPlaybackRate = m_requestedPlaybackRate = rate;
3377         invalidateCachedTime();
3378         scheduleEvent(eventNames().ratechangeEvent);
3379     }
3380 }
3381 
3382 void HTMLMediaElement::updatePlaybackRate()
3383 {
3384     double requestedRate = requestedPlaybackRate();
3385     if (m_player &amp;&amp; potentiallyPlaying() &amp;&amp; m_player-&gt;rate() != requestedRate)
3386         m_player-&gt;setRate(requestedRate);
3387 }
3388 
3389 bool HTMLMediaElement::webkitPreservesPitch() const
3390 {
3391     return m_webkitPreservesPitch;
3392 }
3393 
3394 void HTMLMediaElement::setWebkitPreservesPitch(bool preservesPitch)
3395 {
3396     INFO_LOG(LOGIDENTIFIER, preservesPitch);
3397 
3398     m_webkitPreservesPitch = preservesPitch;
3399 
3400     if (!m_player)
3401         return;
3402 
3403     m_player-&gt;setPreservesPitch(preservesPitch);
3404 }
3405 
3406 bool HTMLMediaElement::ended() const
3407 {
3408 #if ENABLE(MEDIA_STREAM)
3409     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3410     // When the MediaStream state moves from the active to the inactive state, the User Agent
3411     // must raise an ended event on the HTMLMediaElement and set its ended attribute to true.
3412     if (m_mediaStreamSrcObject &amp;&amp; m_player &amp;&amp; m_player-&gt;ended())
3413         return true;
3414 #endif
3415 
3416     // 4.8.10.8 Playing the media resource
3417     // The ended attribute must return true if the media element has ended
3418     // playback and the direction of playback is forwards, and false otherwise.
3419     return endedPlayback() &amp;&amp; requestedPlaybackRate() &gt; 0;
3420 }
3421 
3422 bool HTMLMediaElement::autoplay() const
3423 {
3424     return hasAttributeWithoutSynchronization(autoplayAttr);
3425 }
3426 
3427 String HTMLMediaElement::preload() const
3428 {
3429 #if ENABLE(MEDIA_STREAM)
3430     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3431     // &quot;preload&quot; - On getting: none. On setting: ignored.
3432     if (m_mediaStreamSrcObject)
3433         return &quot;none&quot;_s;
3434 #endif
3435 
3436     switch (m_preload) {
<a name="100" id="anc100"></a><span class="line-modified">3437     case MediaPlayer::Preload::None:</span>
3438         return &quot;none&quot;_s;
<a name="101" id="anc101"></a><span class="line-modified">3439     case MediaPlayer::Preload::MetaData:</span>
3440         return &quot;metadata&quot;_s;
<a name="102" id="anc102"></a><span class="line-modified">3441     case MediaPlayer::Preload::Auto:</span>
3442         return &quot;auto&quot;_s;
3443     }
3444 
3445     ASSERT_NOT_REACHED();
3446     return String();
3447 }
3448 
3449 void HTMLMediaElement::setPreload(const String&amp; preload)
3450 {
3451     INFO_LOG(LOGIDENTIFIER, preload);
3452 #if ENABLE(MEDIA_STREAM)
3453     // http://w3c.github.io/mediacapture-main/#mediastreams-in-media-elements
3454     // &quot;preload&quot; - On getting: none. On setting: ignored.
3455     if (m_mediaStreamSrcObject)
3456         return;
3457 #endif
3458 
3459     setAttributeWithoutSynchronization(preloadAttr, preload);
3460 }
3461 
3462 void HTMLMediaElement::play(DOMPromiseDeferred&lt;void&gt;&amp;&amp; promise)
3463 {
3464     ALWAYS_LOG(LOGIDENTIFIER);
3465 
3466     auto success = m_mediaSession-&gt;playbackPermitted();
3467     if (!success) {
3468         if (success.value() == MediaPlaybackDenialReason::UserGestureRequired)
3469             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3470         promise.reject(NotAllowedError);
3471         return;
3472     }
3473 
3474     if (m_error &amp;&amp; m_error-&gt;code() == MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED) {
3475         promise.reject(NotSupportedError, &quot;The operation is not supported.&quot;);
3476         return;
3477     }
3478 
3479     if (processingUserGestureForMedia())
3480         removeBehaviorRestrictionsAfterFirstUserGesture();
3481 
3482     m_pendingPlayPromises.append(WTFMove(promise));
3483     playInternal();
3484 }
3485 
3486 void HTMLMediaElement::play()
3487 {
3488     ALWAYS_LOG(LOGIDENTIFIER);
3489 
3490     auto success = m_mediaSession-&gt;playbackPermitted();
3491     if (!success) {
3492         if (success.value() == MediaPlaybackDenialReason::UserGestureRequired)
3493             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3494         return;
3495     }
3496     if (processingUserGestureForMedia())
3497         removeBehaviorRestrictionsAfterFirstUserGesture();
3498 
3499     playInternal();
3500 }
3501 
3502 void HTMLMediaElement::playInternal()
3503 {
3504     ALWAYS_LOG(LOGIDENTIFIER);
3505 
3506     if (isSuspended()) {
3507         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning because context is suspended&quot;);
3508         return;
3509     }
3510 
3511     if (!document().hasBrowsingContext()) {
3512         INFO_LOG(LOGIDENTIFIER, &quot;returning because there is no browsing context&quot;);
3513         return;
3514     }
3515 
3516     if (!m_mediaSession-&gt;clientWillBeginPlayback()) {
3517         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning because of interruption&quot;);
3518         return;
3519     }
3520 
3521     // 4.8.10.9. Playing the media resource
3522     if (!m_player || m_networkState == NETWORK_EMPTY)
3523         selectMediaResource();
3524 
3525     if (endedPlayback())
3526         seekInternal(MediaTime::zeroTime());
3527 
3528     if (m_mediaController)
3529         m_mediaController-&gt;bringElementUpToSpeed(*this);
3530 
3531     if (m_paused) {
3532         m_paused = false;
3533         invalidateCachedTime();
3534 
3535         // This avoids the first timeUpdated event after playback starts, when currentTime is still
3536         // the same as it was when the video was paused (and the time hasn&#39;t changed yet).
3537         m_lastTimeUpdateEventMovieTime = currentMediaTime();
3538         m_playbackStartedTime = m_lastTimeUpdateEventMovieTime.toDouble();
3539 
3540         scheduleEvent(eventNames().playEvent);
3541 
3542 #if ENABLE(MEDIA_SESSION)
3543         // 6.3 Activating a media session from a media element
3544         // When the play() method is invoked, the paused attribute is true, and the readyState attribute has the value
3545         // HAVE_FUTURE_DATA or HAVE_ENOUGH_DATA, then
3546         // 1. Let media session be the value of the current media session.
3547         // 2. If we are not currently in media session&#39;s list of active participating media elements then append
3548         //    ourselves to this list.
3549         // 3. Let activated be the result of running the media session invocation algorithm for media session.
3550         // 4. If activated is failure, pause ourselves.
3551         if (m_readyState == HAVE_ENOUGH_DATA || m_readyState == HAVE_FUTURE_DATA) {
3552             if (m_session) {
3553                 m_session-&gt;addActiveMediaElement(*this);
3554 
3555                 if (m_session-&gt;kind() == MediaSessionKind::Content) {
3556                     if (Page* page = document().page())
3557                         page-&gt;chrome().client().focusedContentMediaElementDidChange(m_elementID);
3558                 }
3559 
3560                 if (!m_session-&gt;invoke()) {
3561                     pause();
3562                     return;
3563                 }
3564             }
3565         }
3566 #endif
3567         if (m_readyState &lt;= HAVE_CURRENT_DATA)
3568             scheduleEvent(eventNames().waitingEvent);
3569     } else if (m_readyState &gt;= HAVE_FUTURE_DATA)
3570         scheduleResolvePendingPlayPromises();
3571 
3572     if (processingUserGestureForMedia()) {
3573         if (m_autoplayEventPlaybackState == AutoplayEventPlaybackState::PreventedAutoplay) {
3574             handleAutoplayEvent(AutoplayEvent::DidPlayMediaWithUserGesture);
3575             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
3576         } else
3577             setAutoplayEventPlaybackState(AutoplayEventPlaybackState::StartedWithUserGesture);
3578     } else
3579         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::StartedWithoutUserGesture);
3580 
3581     m_autoplaying = false;
3582     updatePlayState();
3583 }
3584 
3585 void HTMLMediaElement::pause()
3586 {
3587     ALWAYS_LOG(LOGIDENTIFIER);
3588 
3589     m_temporarilyAllowingInlinePlaybackAfterFullscreen = false;
3590 
3591     if (m_waitingToEnterFullscreen)
3592         m_waitingToEnterFullscreen = false;
3593 
3594     if (!m_mediaSession-&gt;playbackPermitted())
3595         return;
3596 
3597     if (processingUserGestureForMedia())
3598         removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::RequireUserGestureToControlControlsManager);
3599 
3600     pauseInternal();
3601 }
3602 
3603 
3604 void HTMLMediaElement::pauseInternal()
3605 {
3606     ALWAYS_LOG(LOGIDENTIFIER);
3607 
3608     if (isSuspended()) {
3609         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning because context is suspended&quot;);
3610         return;
3611     }
3612 
3613     if (!document().hasBrowsingContext()) {
3614         INFO_LOG(LOGIDENTIFIER, &quot;returning because there is no browsing context&quot;);
3615         return;
3616     }
3617 
3618     if (!m_mediaSession-&gt;clientWillPausePlayback()) {
3619         ALWAYS_LOG(LOGIDENTIFIER, &quot;returning because of interruption&quot;);
3620         return;
3621     }
3622 
3623     // 4.8.10.9. Playing the media resource
3624     if (!m_player || m_networkState == NETWORK_EMPTY) {
3625         // Unless the restriction on media requiring user action has been lifted
3626         // don&#39;t trigger loading if a script calls pause().
3627         if (!m_mediaSession-&gt;playbackPermitted())
3628             return;
3629         selectMediaResource();
3630     }
3631 
3632     m_autoplaying = false;
3633 
3634     if (processingUserGestureForMedia())
3635         userDidInterfereWithAutoplay();
3636 
3637     setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
3638 
3639     if (!m_paused) {
3640         m_paused = true;
3641         scheduleTimeupdateEvent(false);
3642         scheduleEvent(eventNames().pauseEvent);
3643         scheduleRejectPendingPlayPromises(DOMException::create(AbortError));
3644         if (MemoryPressureHandler::singleton().isUnderMemoryPressure())
3645             purgeBufferedDataIfPossible();
3646     }
3647 
3648     updatePlayState();
3649 }
3650 
3651 #if ENABLE(MEDIA_SOURCE)
3652 
3653 void HTMLMediaElement::detachMediaSource()
3654 {
3655     if (!m_mediaSource)
3656         return;
3657 
3658     m_mediaSource-&gt;detachFromElement(*this);
3659     m_mediaSource = nullptr;
3660 }
3661 
3662 #endif
3663 
3664 bool HTMLMediaElement::loop() const
3665 {
3666     return hasAttributeWithoutSynchronization(loopAttr);
3667 }
3668 
3669 void HTMLMediaElement::setLoop(bool loop)
3670 {
3671     INFO_LOG(LOGIDENTIFIER, loop);
3672     setBooleanAttribute(loopAttr, loop);
3673 }
3674 
3675 bool HTMLMediaElement::controls() const
3676 {
3677     RefPtr&lt;Frame&gt; frame = document().frame();
3678 
3679     // always show controls when scripting is disabled
3680     if (frame &amp;&amp; !frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
3681         return true;
3682 
3683     return hasAttributeWithoutSynchronization(controlsAttr);
3684 }
3685 
3686 void HTMLMediaElement::setControls(bool controls)
3687 {
3688     INFO_LOG(LOGIDENTIFIER, controls);
3689     setBooleanAttribute(controlsAttr, controls);
3690 }
3691 
3692 double HTMLMediaElement::volume() const
3693 {
3694     return m_volume;
3695 }
3696 
3697 ExceptionOr&lt;void&gt; HTMLMediaElement::setVolume(double volume)
3698 {
3699     INFO_LOG(LOGIDENTIFIER, volume);
3700 
3701     if (!(volume &gt;= 0 &amp;&amp; volume &lt;= 1))
3702         return Exception { IndexSizeError };
3703 
3704     if (m_volume == volume)
3705         return { };
3706 
3707 #if !PLATFORM(IOS_FAMILY)
3708     if (volume &amp;&amp; processingUserGestureForMedia())
3709         removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);
3710 
3711     m_volume = volume;
3712     m_volumeInitialized = true;
3713     updateVolume();
3714     scheduleEvent(eventNames().volumechangeEvent);
3715 
3716     if (isPlaying() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
3717         pauseInternal();
3718         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3719     }
3720 #else
3721     auto oldVolume = m_volume;
3722     m_volume = volume;
3723 
3724     if (m_volumeRevertTaskQueue.hasPendingTask())
3725         return { };
3726 
3727     m_volumeRevertTaskQueue.scheduleTask([this, oldVolume] {
3728         m_volume = oldVolume;
3729     });
3730 
3731 #endif
3732 
3733     return { };
3734 }
3735 
3736 bool HTMLMediaElement::muted() const
3737 {
3738     return m_explicitlyMuted ? m_muted : hasAttributeWithoutSynchronization(mutedAttr);
3739 }
3740 
3741 void HTMLMediaElement::setMuted(bool muted)
3742 {
3743     INFO_LOG(LOGIDENTIFIER, muted);
3744 
3745     bool mutedStateChanged = m_muted != muted;
3746     if (mutedStateChanged || !m_explicitlyMuted) {
3747         if (processingUserGestureForMedia()) {
3748             removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::AllRestrictions &amp; ~MediaElementSession::RequireUserGestureToControlControlsManager);
3749 
3750             if (hasAudio() &amp;&amp; muted)
3751                 userDidInterfereWithAutoplay();
3752         }
3753 
3754         m_muted = muted;
3755         m_explicitlyMuted = true;
3756 
3757         // Avoid recursion when the player reports volume changes.
3758         if (!processingMediaPlayerCallback()) {
3759             if (m_player) {
3760                 m_player-&gt;setMuted(effectiveMuted());
3761                 if (hasMediaControls())
3762                     mediaControls()-&gt;changedMute();
3763             }
3764         }
3765 
3766         if (mutedStateChanged)
3767             scheduleEvent(eventNames().volumechangeEvent);
3768 
3769         updateShouldPlay();
3770 
3771 #if ENABLE(MEDIA_SESSION)
3772         document().updateIsPlayingMedia(m_elementID);
3773 #else
3774         document().updateIsPlayingMedia();
3775 #endif
3776 
3777 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
3778         scheduleUpdateMediaState();
3779 #endif
3780         m_mediaSession-&gt;canProduceAudioChanged();
<a name="103" id="anc103"></a><span class="line-added">3781         updateSleepDisabling();</span>
3782     }
3783 
3784     schedulePlaybackControlsManagerUpdate();
3785 }
3786 
3787 #if USE(AUDIO_SESSION) &amp;&amp; PLATFORM(MAC)
3788 void HTMLMediaElement::hardwareMutedStateDidChange(AudioSession* session)
3789 {
3790     if (!session-&gt;isMuted())
3791         return;
3792 
3793     if (!hasAudio())
3794         return;
3795 
3796     if (effectiveMuted() || !volume())
3797         return;
3798 
3799     INFO_LOG(LOGIDENTIFIER);
3800     userDidInterfereWithAutoplay();
3801 }
3802 #endif
3803 
3804 void HTMLMediaElement::togglePlayState()
3805 {
3806     INFO_LOG(LOGIDENTIFIER, &quot;canPlay() is &quot;, canPlay());
3807 
3808     // We can safely call the internal play/pause methods, which don&#39;t check restrictions, because
3809     // this method is only called from the built-in media controller
3810     if (canPlay()) {
3811         updatePlaybackRate();
3812         playInternal();
3813     } else
3814         pauseInternal();
3815 }
3816 
3817 void HTMLMediaElement::beginScrubbing()
3818 {
3819     INFO_LOG(LOGIDENTIFIER, &quot;paused() is &quot;, paused());
3820 
3821     if (!paused()) {
3822         if (ended()) {
3823             // Because a media element stays in non-paused state when it reaches end, playback resumes
3824             // when the slider is dragged from the end to another position unless we pause first. Do
3825             // a &quot;hard pause&quot; so an event is generated, since we want to stay paused after scrubbing finishes.
3826             pause();
3827         } else {
3828             // Not at the end but we still want to pause playback so the media engine doesn&#39;t try to
3829             // continue playing during scrubbing. Pause without generating an event as we will
3830             // unpause after scrubbing finishes.
3831             setPausedInternal(true);
3832         }
3833     }
3834 
3835     m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager);
3836 }
3837 
3838 void HTMLMediaElement::endScrubbing()
3839 {
3840     INFO_LOG(LOGIDENTIFIER, &quot;m_pausedInternal is&quot;, m_pausedInternal);
3841 
3842     if (m_pausedInternal)
3843         setPausedInternal(false);
3844 }
3845 
3846 void HTMLMediaElement::beginScanning(ScanDirection direction)
3847 {
3848     m_scanType = supportsScanning() ? Scan : Seek;
3849     m_scanDirection = direction;
3850 
3851     if (m_scanType == Seek) {
3852         // Scanning by seeking requires the video to be paused during scanning.
3853         m_actionAfterScan = paused() ? Nothing : Play;
3854         pause();
3855     } else {
3856         // Scanning by scanning requires the video to be playing during scanninging.
3857         m_actionAfterScan = paused() ? Pause : Nothing;
3858         play();
3859         setPlaybackRate(nextScanRate());
3860     }
3861 
3862     m_scanTimer.start(0_s, m_scanType == Seek ? SeekRepeatDelay : ScanRepeatDelay);
3863 }
3864 
3865 void HTMLMediaElement::endScanning()
3866 {
3867     if (m_scanType == Scan)
3868         setPlaybackRate(defaultPlaybackRate());
3869 
3870     if (m_actionAfterScan == Play)
3871         play();
3872     else if (m_actionAfterScan == Pause)
3873         pause();
3874 
3875     if (m_scanTimer.isActive())
3876         m_scanTimer.stop();
3877 }
3878 
3879 double HTMLMediaElement::nextScanRate()
3880 {
3881     double rate = std::min(ScanMaximumRate, fabs(playbackRate() * 2));
3882     if (m_scanDirection == Backward)
3883         rate *= -1;
3884 #if PLATFORM(IOS_FAMILY)
3885     rate = std::min(std::max(rate, minFastReverseRate()), maxFastForwardRate());
3886 #endif
3887     return rate;
3888 }
3889 
3890 void HTMLMediaElement::scanTimerFired()
3891 {
3892     if (m_scanType == Seek) {
3893         double seekTime = m_scanDirection == Forward ? SeekTime : -SeekTime;
3894         setCurrentTime(currentTime() + seekTime);
3895     } else
3896         setPlaybackRate(nextScanRate());
3897 }
3898 
3899 // The spec says to fire periodic timeupdate events (those sent while playing) every
3900 // &quot;15 to 250ms&quot;, we choose the slowest frequency
3901 static const Seconds maxTimeupdateEventFrequency { 250_ms };
3902 
3903 void HTMLMediaElement::startPlaybackProgressTimer()
3904 {
3905     if (m_playbackProgressTimer.isActive())
3906         return;
3907 
3908     m_previousProgressTime = MonotonicTime::now();
3909     m_playbackProgressTimer.startRepeating(maxTimeupdateEventFrequency);
3910 }
3911 
3912 void HTMLMediaElement::playbackProgressTimerFired()
3913 {
3914     ASSERT(m_player);
3915 
3916     if (m_fragmentEndTime.isValid() &amp;&amp; currentMediaTime() &gt;= m_fragmentEndTime &amp;&amp; requestedPlaybackRate() &gt; 0) {
3917         m_fragmentEndTime = MediaTime::invalidTime();
3918         if (!m_mediaController &amp;&amp; !m_paused) {
3919             // changes paused to true and fires a simple event named pause at the media element.
3920             pauseInternal();
3921         }
3922     }
3923 
3924     scheduleTimeupdateEvent(true);
3925 
3926     if (!requestedPlaybackRate())
3927         return;
3928 
3929     if (!m_paused &amp;&amp; hasMediaControls())
3930         mediaControls()-&gt;playbackProgressed();
3931 
3932 #if ENABLE(VIDEO_TRACK)
3933     updateActiveTextTrackCues(currentMediaTime());
3934 #endif
3935 
3936 #if ENABLE(MEDIA_SOURCE)
3937     if (m_mediaSource)
3938         m_mediaSource-&gt;monitorSourceBuffers();
3939 #endif
3940 
3941     bool playbackStarted = m_autoplayEventPlaybackState == AutoplayEventPlaybackState::StartedWithUserGesture || m_autoplayEventPlaybackState == AutoplayEventPlaybackState::StartedWithoutUserGesture;
3942     if (!seeking() &amp;&amp; playbackStarted &amp;&amp; currentTime() - playbackStartedTime() &gt; AutoplayInterferenceTimeThreshold) {
3943         handleAutoplayEvent(m_autoplayEventPlaybackState == AutoplayEventPlaybackState::StartedWithoutUserGesture ? AutoplayEvent::DidAutoplayMediaPastThresholdWithoutUserInterference : AutoplayEvent::DidPlayMediaWithUserGesture);
3944         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
3945     }
3946 }
3947 
3948 void HTMLMediaElement::scheduleTimeupdateEvent(bool periodicEvent)
3949 {
3950     MonotonicTime now = MonotonicTime::now();
3951     Seconds timedelta = now - m_clockTimeAtLastUpdateEvent;
3952 
3953     // throttle the periodic events
3954     if (periodicEvent &amp;&amp; timedelta &lt; maxTimeupdateEventFrequency)
3955         return;
3956 
3957     // Some media engines make multiple &quot;time changed&quot; callbacks at the same time, but we only want one
3958     // event at a given time so filter here
3959     MediaTime movieTime = currentMediaTime();
3960     if (movieTime != m_lastTimeUpdateEventMovieTime) {
3961         scheduleEvent(eventNames().timeupdateEvent);
3962         m_clockTimeAtLastUpdateEvent = now;
3963         m_lastTimeUpdateEventMovieTime = movieTime;
3964     }
3965 }
3966 
3967 bool HTMLMediaElement::canPlay() const
3968 {
3969     return paused() || ended() || m_readyState &lt; HAVE_METADATA;
3970 }
3971 
3972 double HTMLMediaElement::percentLoaded() const
3973 {
3974     if (!m_player)
3975         return 0;
3976     MediaTime duration = m_player-&gt;duration();
3977 
3978     if (!duration || duration.isPositiveInfinite() || duration.isNegativeInfinite())
3979         return 0;
3980 
3981     MediaTime buffered = MediaTime::zeroTime();
3982     bool ignored;
3983     std::unique_ptr&lt;PlatformTimeRanges&gt; timeRanges = m_player-&gt;buffered();
3984     for (unsigned i = 0; i &lt; timeRanges-&gt;length(); ++i) {
3985         MediaTime start = timeRanges-&gt;start(i, ignored);
3986         MediaTime end = timeRanges-&gt;end(i, ignored);
3987         buffered += end - start;
3988     }
3989     return buffered.toDouble() / duration.toDouble();
3990 }
3991 
3992 #if ENABLE(VIDEO_TRACK)
3993 
3994 void HTMLMediaElement::mediaPlayerDidAddAudioTrack(AudioTrackPrivate&amp; track)
3995 {
3996     if (isPlaying() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
3997         pauseInternal();
3998         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
3999     }
4000 
4001     addAudioTrack(AudioTrack::create(*this, track));
4002 }
4003 
4004 void HTMLMediaElement::mediaPlayerDidAddTextTrack(InbandTextTrackPrivate&amp; track)
4005 {
4006     // 4.8.10.12.2 Sourcing in-band text tracks
4007     // 1. Associate the relevant data with a new text track and its corresponding new TextTrack object.
4008     auto textTrack = InbandTextTrack::create(*ActiveDOMObject::scriptExecutionContext(), *this, track);
<a name="104" id="anc104"></a><span class="line-modified">4009     textTrack-&gt;setMediaElement(makeWeakPtr(this));</span>
4010 
4011     // 2. Set the new text track&#39;s kind, label, and language based on the semantics of the relevant data,
4012     // as defined by the relevant specification. If there is no label in that data, then the label must
4013     // be set to the empty string.
4014     // 3. Associate the text track list of cues with the rules for updating the text track rendering appropriate
4015     // for the format in question.
4016     // 4. If the new text track&#39;s kind is metadata, then set the text track in-band metadata track dispatch type
4017     // as follows, based on the type of the media resource:
4018     // 5. Populate the new text track&#39;s list of cues with the cues parsed so far, folllowing the guidelines for exposing
4019     // cues, and begin updating it dynamically as necessary.
4020     //   - Thess are all done by the media engine.
4021 
4022     // 6. Set the new text track&#39;s readiness state to loaded.
4023     textTrack-&gt;setReadinessState(TextTrack::Loaded);
4024 
4025     // 7. Set the new text track&#39;s mode to the mode consistent with the user&#39;s preferences and the requirements of
4026     // the relevant specification for the data.
4027     //  - This will happen in configureTextTracks()
4028     scheduleConfigureTextTracks();
4029 
4030     // 8. Add the new text track to the media element&#39;s list of text tracks.
4031     // 9. Fire an event with the name addtrack, that does not bubble and is not cancelable, and that uses the TrackEvent
4032     // interface, with the track attribute initialized to the text track&#39;s TextTrack object, at the media element&#39;s
4033     // textTracks attribute&#39;s TextTrackList object.
4034     addTextTrack(WTFMove(textTrack));
4035 }
4036 
4037 void HTMLMediaElement::mediaPlayerDidAddVideoTrack(VideoTrackPrivate&amp; track)
4038 {
4039     addVideoTrack(VideoTrack::create(*this, track));
4040 }
4041 
4042 void HTMLMediaElement::mediaPlayerDidRemoveAudioTrack(AudioTrackPrivate&amp; track)
4043 {
4044     track.willBeRemoved();
4045 }
4046 
4047 void HTMLMediaElement::mediaPlayerDidRemoveTextTrack(InbandTextTrackPrivate&amp; track)
4048 {
4049     track.willBeRemoved();
4050 }
4051 
4052 void HTMLMediaElement::mediaPlayerDidRemoveVideoTrack(VideoTrackPrivate&amp; track)
4053 {
4054     track.willBeRemoved();
4055 }
4056 
4057 void HTMLMediaElement::closeCaptionTracksChanged()
4058 {
4059     if (hasMediaControls())
4060         mediaControls()-&gt;closedCaptionTracksChanged();
4061 }
4062 
4063 void HTMLMediaElement::addAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp; track)
4064 {
4065     ensureAudioTracks().append(WTFMove(track));
4066 }
4067 
4068 void HTMLMediaElement::addTextTrack(Ref&lt;TextTrack&gt;&amp;&amp; track)
4069 {
4070     if (!m_requireCaptionPreferencesChangedCallbacks) {
4071         m_requireCaptionPreferencesChangedCallbacks = true;
4072         Document&amp; document = this-&gt;document();
4073         document.registerForCaptionPreferencesChangedCallbacks(*this);
4074         if (Page* page = document.page())
4075             m_captionDisplayMode = page-&gt;group().captionPreferences().captionDisplayMode();
4076     }
4077 
4078     ensureTextTracks().append(WTFMove(track));
4079 
4080     closeCaptionTracksChanged();
4081 }
4082 
4083 void HTMLMediaElement::addVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp; track)
4084 {
4085     ensureVideoTracks().append(WTFMove(track));
4086 }
4087 
4088 void HTMLMediaElement::removeAudioTrack(Ref&lt;AudioTrack&gt;&amp;&amp; track)
4089 {
4090     track-&gt;clearClient();
4091     m_audioTracks-&gt;remove(track.get());
4092 }
4093 
4094 void HTMLMediaElement::removeTextTrack(Ref&lt;TextTrack&gt;&amp;&amp; track, bool scheduleEvent)
4095 {
4096     TrackDisplayUpdateScope scope { *this };
4097     if (auto cues = makeRefPtr(track-&gt;cues()))
4098         textTrackRemoveCues(track, *cues);
4099     track-&gt;clearClient();
4100     if (m_textTracks)
4101         m_textTracks-&gt;remove(track, scheduleEvent);
4102 
4103     closeCaptionTracksChanged();
4104 }
4105 
4106 void HTMLMediaElement::removeVideoTrack(Ref&lt;VideoTrack&gt;&amp;&amp; track)
4107 {
4108     track-&gt;clearClient();
4109     m_videoTracks-&gt;remove(track);
4110 }
4111 
4112 void HTMLMediaElement::forgetResourceSpecificTracks()
4113 {
4114     while (m_audioTracks &amp;&amp;  m_audioTracks-&gt;length())
4115         removeAudioTrack(*m_audioTracks-&gt;lastItem());
4116 
4117     if (m_textTracks) {
4118         TrackDisplayUpdateScope scope { *this };
4119         for (int i = m_textTracks-&gt;length() - 1; i &gt;= 0; --i) {
4120             auto track = makeRef(*m_textTracks-&gt;item(i));
4121             if (track-&gt;trackType() == TextTrack::InBand)
4122                 removeTextTrack(WTFMove(track), false);
4123         }
4124     }
4125 
4126     while (m_videoTracks &amp;&amp;  m_videoTracks-&gt;length())
4127         removeVideoTrack(*m_videoTracks-&gt;lastItem());
4128 }
4129 
4130 ExceptionOr&lt;TextTrack&amp;&gt; HTMLMediaElement::addTextTrack(const String&amp; kind, const String&amp; label, const String&amp; language)
4131 {
4132     // 4.8.10.12.4 Text track API
4133     // The addTextTrack(kind, label, language) method of media elements, when invoked, must run the following steps:
4134 
4135     // 1. If kind is not one of the following strings, then throw a SyntaxError exception and abort these steps
4136     if (!TextTrack::isValidKindKeyword(kind))
4137         return Exception { TypeError };
4138 
4139     // 2. If the label argument was omitted, let label be the empty string.
4140     // 3. If the language argument was omitted, let language be the empty string.
4141     // 4. Create a new TextTrack object.
4142 
4143     // 5. Create a new text track corresponding to the new object, and set its text track kind to kind, its text
4144     // track label to label, its text track language to language...
4145     auto track = TextTrack::create(ActiveDOMObject::scriptExecutionContext(), this, kind, emptyString(), label, language);
4146     auto&amp; trackReference = track.get();
4147 
4148     // Note, due to side effects when changing track parameters, we have to
4149     // first append the track to the text track list.
4150 
4151     // 6. Add the new text track to the media element&#39;s list of text tracks.
4152     addTextTrack(WTFMove(track));
4153 
4154     // ... its text track readiness state to the text track loaded state ...
4155     trackReference.setReadinessState(TextTrack::Loaded);
4156 
4157     // ... its text track mode to the text track hidden mode, and its text track list of cues to an empty list ...
4158     trackReference.setMode(TextTrack::Mode::Hidden);
4159 
4160     return trackReference;
4161 }
4162 
4163 AudioTrackList&amp; HTMLMediaElement::ensureAudioTracks()
4164 {
4165     if (!m_audioTracks)
<a name="105" id="anc105"></a><span class="line-modified">4166         m_audioTracks = AudioTrackList::create(makeWeakPtr(this), ActiveDOMObject::scriptExecutionContext());</span>
4167 
4168     return *m_audioTracks;
4169 }
4170 
4171 TextTrackList&amp; HTMLMediaElement::ensureTextTracks()
4172 {
4173     if (!m_textTracks)
<a name="106" id="anc106"></a><span class="line-modified">4174         m_textTracks = TextTrackList::create(makeWeakPtr(this), ActiveDOMObject::scriptExecutionContext());</span>
4175 
4176     return *m_textTracks;
4177 }
4178 
4179 VideoTrackList&amp; HTMLMediaElement::ensureVideoTracks()
4180 {
4181     if (!m_videoTracks)
<a name="107" id="anc107"></a><span class="line-modified">4182         m_videoTracks = VideoTrackList::create(makeWeakPtr(this), ActiveDOMObject::scriptExecutionContext());</span>
4183 
4184     return *m_videoTracks;
4185 }
4186 
4187 void HTMLMediaElement::didAddTextTrack(HTMLTrackElement&amp; trackElement)
4188 {
4189     ASSERT(trackElement.hasTagName(trackTag));
4190 
4191     // 4.8.10.12.3 Sourcing out-of-band text tracks
4192     // When a track element&#39;s parent element changes and the new parent is a media element,
4193     // then the user agent must add the track element&#39;s corresponding text track to the
4194     // media element&#39;s list of text tracks ... [continues in TextTrackList::append]
4195     addTextTrack(trackElement.track());
4196 
4197     // Do not schedule the track loading until parsing finishes so we don&#39;t start before all tracks
4198     // in the markup have been added.
4199     if (!m_parsingInProgress)
4200         scheduleConfigureTextTracks();
4201 
4202     if (hasMediaControls())
4203         mediaControls()-&gt;closedCaptionTracksChanged();
4204 }
4205 
4206 void HTMLMediaElement::didRemoveTextTrack(HTMLTrackElement&amp; trackElement)
4207 {
4208     ASSERT(trackElement.hasTagName(trackTag));
4209 
4210     auto&amp; textTrack = trackElement.track();
4211 
4212     textTrack.setHasBeenConfigured(false);
4213 
4214     if (!m_textTracks)
4215         return;
4216 
4217     // 4.8.10.12.3 Sourcing out-of-band text tracks
4218     // When a track element&#39;s parent element changes and the old parent was a media element,
4219     // then the user agent must remove the track element&#39;s corresponding text track from the
4220     // media element&#39;s list of text tracks.
4221     removeTextTrack(textTrack);
4222 
4223     m_textTracksWhenResourceSelectionBegan.removeFirst(&amp;textTrack);
4224 }
4225 
4226 void HTMLMediaElement::configureTextTrackGroup(const TrackGroup&amp; group)
4227 {
4228     ASSERT(group.tracks.size());
4229 
4230     Page* page = document().page();
4231     CaptionUserPreferences* captionPreferences = page ? &amp;page-&gt;group().captionPreferences() : 0;
4232     CaptionUserPreferences::CaptionDisplayMode displayMode = captionPreferences ? captionPreferences-&gt;captionDisplayMode() : CaptionUserPreferences::Automatic;
4233 
4234     // First, find the track in the group that should be enabled (if any).
4235     Vector&lt;RefPtr&lt;TextTrack&gt;&gt; currentlyEnabledTracks;
4236     RefPtr&lt;TextTrack&gt; trackToEnable;
4237     RefPtr&lt;TextTrack&gt; defaultTrack;
4238     RefPtr&lt;TextTrack&gt; fallbackTrack;
4239     RefPtr&lt;TextTrack&gt; forcedSubitleTrack;
4240     int highestTrackScore = 0;
4241     int highestForcedScore = 0;
4242 
4243     // If there is a visible track, it has already been configured so it won&#39;t be considered in the loop below. We don&#39;t want to choose another
4244     // track if it is less suitable, and we do want to disable it if another track is more suitable.
4245     int alreadyVisibleTrackScore = 0;
4246     if (group.visibleTrack &amp;&amp; captionPreferences) {
4247         alreadyVisibleTrackScore = captionPreferences-&gt;textTrackSelectionScore(group.visibleTrack.get(), this);
4248         currentlyEnabledTracks.append(group.visibleTrack);
4249     }
4250 
4251     for (size_t i = 0; i &lt; group.tracks.size(); ++i) {
4252         RefPtr&lt;TextTrack&gt; textTrack = group.tracks[i];
4253 
4254         if (m_processingPreferenceChange &amp;&amp; textTrack-&gt;mode() == TextTrack::Mode::Showing)
4255             currentlyEnabledTracks.append(textTrack);
4256 
4257         int trackScore = captionPreferences ? captionPreferences-&gt;textTrackSelectionScore(textTrack.get(), this) : 0;
4258         INFO_LOG(LOGIDENTIFIER, &quot;&#39;&quot;, textTrack-&gt;kindKeyword(), &quot;&#39; track with language &#39;&quot;, textTrack-&gt;language(), &quot;&#39; and BCP 47 language &#39;&quot;, textTrack-&gt;validBCP47Language(), &quot;&#39; has score &quot;, trackScore);
4259 
4260         if (trackScore) {
4261 
4262             // * If the text track kind is { [subtitles or captions] [descriptions] } and the user has indicated an interest in having a
4263             // track with this text track kind, text track language, and text track label enabled, and there is no
4264             // other text track in the media element&#39;s list of text tracks with a text track kind of either subtitles
4265             // or captions whose text track mode is showing
4266             // ...
4267             // * If the text track kind is chapters and the text track language is one that the user agent has reason
4268             // to believe is appropriate for the user, and there is no other text track in the media element&#39;s list of
4269             // text tracks with a text track kind of chapters whose text track mode is showing
4270             //    Let the text track mode be showing.
4271             if (trackScore &gt; highestTrackScore &amp;&amp; trackScore &gt; alreadyVisibleTrackScore) {
4272                 highestTrackScore = trackScore;
4273                 trackToEnable = textTrack;
4274             }
4275 
4276             if (!defaultTrack &amp;&amp; textTrack-&gt;isDefault())
4277                 defaultTrack = textTrack;
4278             if (!defaultTrack &amp;&amp; !fallbackTrack)
4279                 fallbackTrack = textTrack;
4280             if (textTrack-&gt;containsOnlyForcedSubtitles() &amp;&amp; trackScore &gt; highestForcedScore) {
4281                 forcedSubitleTrack = textTrack;
4282                 highestForcedScore = trackScore;
4283             }
4284         } else if (!group.visibleTrack &amp;&amp; !defaultTrack &amp;&amp; textTrack-&gt;isDefault()) {
4285             // * If the track element has a default attribute specified, and there is no other text track in the media
4286             // element&#39;s list of text tracks whose text track mode is showing or showing by default
4287             //    Let the text track mode be showing by default.
4288             if (group.kind != TrackGroup::CaptionsAndSubtitles || displayMode != CaptionUserPreferences::ForcedOnly)
4289                 defaultTrack = textTrack;
4290         }
4291     }
4292 
4293     if (displayMode != CaptionUserPreferences::Manual) {
4294         if (!trackToEnable &amp;&amp; defaultTrack)
4295             trackToEnable = defaultTrack;
4296 
4297         // If no track matches the user&#39;s preferred language, none was marked as &#39;default&#39;, and there is a forced subtitle track
4298         // in the same language as the language of the primary audio track, enable it.
4299         if (!trackToEnable &amp;&amp; forcedSubitleTrack)
4300             trackToEnable = forcedSubitleTrack;
4301 
4302         // If no track matches, don&#39;t disable an already visible track unless preferences say they all should be off.
4303         if (group.kind != TrackGroup::CaptionsAndSubtitles || displayMode != CaptionUserPreferences::ForcedOnly) {
4304             if (!trackToEnable &amp;&amp; !defaultTrack &amp;&amp; group.visibleTrack)
4305                 trackToEnable = group.visibleTrack;
4306         }
4307 
4308         // If no track matches the user&#39;s preferred language and non was marked &#39;default&#39;, enable the first track
4309         // because the user has explicitly stated a preference for this kind of track.
4310         if (!trackToEnable &amp;&amp; fallbackTrack)
4311             trackToEnable = fallbackTrack;
4312 
4313         if (trackToEnable)
4314             m_subtitleTrackLanguage = trackToEnable-&gt;language();
4315         else
4316             m_subtitleTrackLanguage = emptyString();
4317     }
4318 
4319     if (currentlyEnabledTracks.size()) {
4320         for (size_t i = 0; i &lt; currentlyEnabledTracks.size(); ++i) {
4321             RefPtr&lt;TextTrack&gt; textTrack = currentlyEnabledTracks[i];
4322             if (textTrack != trackToEnable)
4323                 textTrack-&gt;setMode(TextTrack::Mode::Disabled);
4324         }
4325     }
4326 
4327     if (trackToEnable) {
4328         trackToEnable-&gt;setMode(TextTrack::Mode::Showing);
4329 
4330         // If user preferences indicate we should always display captions, make sure we reflect the
4331         // proper status via the webkitClosedCaptionsVisible API call:
4332         if (!webkitClosedCaptionsVisible() &amp;&amp; closedCaptionsVisible() &amp;&amp; displayMode == CaptionUserPreferences::AlwaysOn)
4333             m_webkitLegacyClosedCaptionOverride = true;
4334     }
4335 
4336     m_processingPreferenceChange = false;
4337 }
4338 
<a name="108" id="anc108"></a><span class="line-modified">4339 static JSC::JSValue controllerJSValue(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, HTMLMediaElement&amp; media)</span>
4340 {
4341     JSC::VM&amp; vm = globalObject.vm();
4342     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="109" id="anc109"></a><span class="line-modified">4343     auto mediaJSWrapper = toJS(&amp;lexicalGlobalObject, &amp;globalObject, media);</span>
4344 
4345     // Retrieve the controller through the JS object graph
4346     JSC::JSObject* mediaJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaJSWrapper);
4347     if (!mediaJSWrapperObject)
4348         return JSC::jsNull();
4349 
4350     JSC::Identifier controlsHost = JSC::Identifier::fromString(vm, &quot;controlsHost&quot;);
<a name="110" id="anc110"></a><span class="line-modified">4351     JSC::JSValue controlsHostJSWrapper = mediaJSWrapperObject-&gt;get(&amp;lexicalGlobalObject, controlsHost);</span>
4352     RETURN_IF_EXCEPTION(scope, JSC::jsNull());
4353 
4354     JSC::JSObject* controlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controlsHostJSWrapper);
4355     if (!controlsHostJSWrapperObject)
4356         return JSC::jsNull();
4357 
4358     JSC::Identifier controllerID = JSC::Identifier::fromString(vm, &quot;controller&quot;);
<a name="111" id="anc111"></a><span class="line-modified">4359     JSC::JSValue controllerJSWrapper = controlsHostJSWrapperObject-&gt;get(&amp;lexicalGlobalObject, controllerID);</span>
4360     RETURN_IF_EXCEPTION(scope, JSC::jsNull());
4361 
4362     return controllerJSWrapper;
4363 }
4364 
4365 void HTMLMediaElement::ensureMediaControlsShadowRoot()
4366 {
4367     ASSERT(!m_creatingControls);
4368     m_creatingControls = true;
4369     ensureUserAgentShadowRoot();
4370     m_creatingControls = false;
4371 }
4372 
4373 bool HTMLMediaElement::setupAndCallJS(const JSSetupFunction&amp; task)
4374 {
4375     Page* page = document().page();
4376     if (!page)
4377         return false;
4378 
4379     auto pendingActivity = makePendingActivity(*this);
4380     auto&amp; world = ensureIsolatedWorld();
4381     auto&amp; scriptController = document().frame()-&gt;script();
4382     auto* globalObject = JSC::jsCast&lt;JSDOMGlobalObject*&gt;(scriptController.globalObject(world));
4383     auto&amp; vm = globalObject-&gt;vm();
4384     JSC::JSLockHolder lock(vm);
4385     auto scope = DECLARE_THROW_SCOPE(vm);
<a name="112" id="anc112"></a><span class="line-modified">4386     auto* lexicalGlobalObject = globalObject;</span>
4387 
4388     RETURN_IF_EXCEPTION(scope, false);
4389 
<a name="113" id="anc113"></a><span class="line-modified">4390     return task(*globalObject, *lexicalGlobalObject, scriptController, world);</span>
4391 }
4392 
4393 void HTMLMediaElement::updateCaptionContainer()
4394 {
4395 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
4396     if (m_haveSetUpCaptionContainer)
4397         return;
4398 
4399     if (!ensureMediaControlsInjectedScript())
4400         return;
4401 
4402     ensureMediaControlsShadowRoot();
4403 
4404     if (!m_mediaControlsHost)
4405         m_mediaControlsHost = MediaControlsHost::create(this);
4406 
<a name="114" id="anc114"></a><span class="line-modified">4407     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
4408         auto&amp; vm = globalObject.vm();
4409         auto scope = DECLARE_CATCH_SCOPE(vm);
<a name="115" id="anc115"></a><span class="line-modified">4410         auto controllerValue = controllerJSValue(lexicalGlobalObject, globalObject, *this);</span>
4411         auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
4412         if (!controllerObject)
4413             return false;
4414 
4415         // The media controls script must provide a method on the Controller object with the following details.
4416         // Name: updateCaptionContainer
4417         // Parameters:
4418         //     None
4419         // Return value:
4420         //     None
<a name="116" id="anc116"></a><span class="line-modified">4421         auto methodValue = controllerObject-&gt;get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;updateCaptionContainer&quot;));</span>
4422         auto* methodObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, methodValue);
4423         if (!methodObject)
4424             return false;
4425 
4426         JSC::CallData callData;
4427         auto callType = methodObject-&gt;methodTable(vm)-&gt;getCallData(methodObject, callData);
4428         if (callType == JSC::CallType::None)
4429             return false;
4430 
4431         JSC::MarkedArgumentBuffer noArguments;
4432         ASSERT(!noArguments.hasOverflowed());
<a name="117" id="anc117"></a><span class="line-modified">4433         JSC::call(&amp;lexicalGlobalObject, methodObject, callType, callData, controllerObject, noArguments);</span>
4434         scope.clearException();
4435 
4436         m_haveSetUpCaptionContainer = true;
4437 
4438         return true;
4439     });
4440 
4441 #endif
4442 }
4443 
4444 void HTMLMediaElement::layoutSizeChanged()
4445 {
4446 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
4447     if (auto frameView = makeRefPtr(document().view())) {
4448         auto task = [this, protectedThis = makeRef(*this)] {
4449             if (auto root = userAgentShadowRoot())
4450                 root-&gt;dispatchEvent(Event::create(&quot;resize&quot;, Event::CanBubble::No, Event::IsCancelable::No));
4451         };
4452         frameView-&gt;queuePostLayoutCallback(WTFMove(task));
4453     }
4454 #endif
4455 
4456     if (!m_receivedLayoutSizeChanged) {
4457         m_receivedLayoutSizeChanged = true;
4458         schedulePlaybackControlsManagerUpdate();
4459     }
4460 
4461     // If the video is a candidate for main content, we should register it for viewport visibility callbacks
4462     // if it hasn&#39;t already been registered.
4463     if (renderer() &amp;&amp; m_mediaSession &amp;&amp; !m_mediaSession-&gt;wantsToObserveViewportVisibilityForAutoplay() &amp;&amp; m_mediaSession-&gt;wantsToObserveViewportVisibilityForMediaControls())
4464         renderer()-&gt;registerForVisibleInViewportCallback();
4465 }
4466 
4467 void HTMLMediaElement::visibilityDidChange()
4468 {
4469     updateShouldAutoplay();
4470 }
4471 
4472 void HTMLMediaElement::setSelectedTextTrack(TextTrack* trackToSelect)
4473 {
4474     auto* trackList = textTracks();
4475     if (!trackList || !trackList-&gt;length())
4476         return;
4477 
4478     if (trackToSelect == TextTrack::captionMenuAutomaticItem()) {
4479         if (captionDisplayMode() != CaptionUserPreferences::Automatic)
4480             m_textTracks-&gt;scheduleChangeEvent();
4481     } else if (trackToSelect == TextTrack::captionMenuOffItem()) {
4482         for (int i = 0, length = trackList-&gt;length(); i &lt; length; ++i)
4483             trackList-&gt;item(i)-&gt;setMode(TextTrack::Mode::Disabled);
4484 
4485         if (captionDisplayMode() != CaptionUserPreferences::ForcedOnly &amp;&amp; !trackList-&gt;isChangeEventScheduled())
4486             m_textTracks-&gt;scheduleChangeEvent();
4487     } else {
4488         if (!trackToSelect || !trackList-&gt;contains(*trackToSelect))
4489             return;
4490 
4491         for (int i = 0, length = trackList-&gt;length(); i &lt; length; ++i) {
4492             auto&amp; track = *trackList-&gt;item(i);
4493             if (&amp;track != trackToSelect)
4494                 track.setMode(TextTrack::Mode::Disabled);
4495             else
4496                 track.setMode(TextTrack::Mode::Showing);
4497         }
4498     }
4499 
4500     if (!document().page())
4501         return;
4502 
4503     auto&amp; captionPreferences = document().page()-&gt;group().captionPreferences();
4504     CaptionUserPreferences::CaptionDisplayMode displayMode;
4505     if (trackToSelect == TextTrack::captionMenuOffItem())
4506         displayMode = CaptionUserPreferences::ForcedOnly;
4507     else if (trackToSelect == TextTrack::captionMenuAutomaticItem())
4508         displayMode = CaptionUserPreferences::Automatic;
4509     else {
4510         displayMode = CaptionUserPreferences::AlwaysOn;
4511         if (trackToSelect-&gt;validBCP47Language().length())
4512             captionPreferences.setPreferredLanguage(trackToSelect-&gt;validBCP47Language());
4513     }
4514 
4515     captionPreferences.setCaptionDisplayMode(displayMode);
4516 }
4517 
4518 void HTMLMediaElement::scheduleConfigureTextTracks()
4519 {
4520     if (m_configureTextTracksTask.hasPendingTask())
4521         return;
4522 
4523     auto logSiteIdentifier = LOGIDENTIFIER;
4524     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
4525     m_configureTextTracksTask.scheduleTask([this, logSiteIdentifier] {
4526         UNUSED_PARAM(logSiteIdentifier);
4527         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
4528         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // configureTextTracks calls methods that can trigger arbitrary DOM mutations.
4529         configureTextTracks();
4530     });
4531 }
4532 
4533 void HTMLMediaElement::configureTextTracks()
4534 {
4535     TrackGroup captionAndSubtitleTracks(TrackGroup::CaptionsAndSubtitles);
4536     TrackGroup descriptionTracks(TrackGroup::Description);
4537     TrackGroup chapterTracks(TrackGroup::Chapter);
4538     TrackGroup metadataTracks(TrackGroup::Metadata);
4539     TrackGroup otherTracks(TrackGroup::Other);
4540 
4541     if (!m_textTracks)
4542         return;
4543 
4544     for (size_t i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
4545         RefPtr&lt;TextTrack&gt; textTrack = m_textTracks-&gt;item(i);
4546         if (!textTrack)
4547             continue;
4548 
4549         auto kind = textTrack-&gt;kind();
4550         TrackGroup* currentGroup;
4551         if (kind == TextTrack::Kind::Subtitles || kind == TextTrack::Kind::Captions || kind == TextTrack::Kind::Forced)
4552             currentGroup = &amp;captionAndSubtitleTracks;
4553         else if (kind == TextTrack::Kind::Descriptions)
4554             currentGroup = &amp;descriptionTracks;
4555         else if (kind == TextTrack::Kind::Chapters)
4556             currentGroup = &amp;chapterTracks;
4557         else if (kind == TextTrack::Kind::Metadata)
4558             currentGroup = &amp;metadataTracks;
4559         else
4560             currentGroup = &amp;otherTracks;
4561 
4562         if (!currentGroup-&gt;visibleTrack &amp;&amp; textTrack-&gt;mode() == TextTrack::Mode::Showing)
4563             currentGroup-&gt;visibleTrack = textTrack;
4564         if (!currentGroup-&gt;defaultTrack &amp;&amp; textTrack-&gt;isDefault())
4565             currentGroup-&gt;defaultTrack = textTrack;
4566 
4567         // Do not add this track to the group if it has already been automatically configured
4568         // as we only want to call configureTextTrack once per track so that adding another
4569         // track after the initial configuration doesn&#39;t reconfigure every track - only those
4570         // that should be changed by the new addition. For example all metadata tracks are
4571         // disabled by default, and we don&#39;t want a track that has been enabled by script
4572         // to be disabled automatically when a new metadata track is added later.
4573         if (textTrack-&gt;hasBeenConfigured())
4574             continue;
4575 
4576         if (textTrack-&gt;language().length())
4577             currentGroup-&gt;hasSrcLang = true;
4578         currentGroup-&gt;tracks.append(textTrack);
4579     }
4580 
4581     if (captionAndSubtitleTracks.tracks.size())
4582         configureTextTrackGroup(captionAndSubtitleTracks);
4583     if (descriptionTracks.tracks.size())
4584         configureTextTrackGroup(descriptionTracks);
4585     if (chapterTracks.tracks.size())
4586         configureTextTrackGroup(chapterTracks);
4587     if (metadataTracks.tracks.size())
4588         configureTextTrackGroup(metadataTracks);
4589     if (otherTracks.tracks.size())
4590         configureTextTrackGroup(otherTracks);
4591 
4592     updateCaptionContainer();
4593     configureTextTrackDisplay();
4594     if (hasMediaControls())
4595         mediaControls()-&gt;closedCaptionTracksChanged();
4596 }
4597 #endif
4598 
4599 bool HTMLMediaElement::havePotentialSourceChild()
4600 {
4601     // Stash the current &lt;source&gt; node and next nodes so we can restore them after checking
4602     // to see there is another potential.
4603     RefPtr&lt;HTMLSourceElement&gt; currentSourceNode = m_currentSourceNode;
4604     RefPtr&lt;HTMLSourceElement&gt; nextNode = m_nextChildNodeToConsider;
4605 
4606     URL nextURL = selectNextSourceChild(0, 0, DoNothing);
4607 
4608     m_currentSourceNode = currentSourceNode;
4609     m_nextChildNodeToConsider = nextNode;
4610 
4611     return nextURL.isValid();
4612 }
4613 
4614 URL HTMLMediaElement::selectNextSourceChild(ContentType* contentType, String* keySystem, InvalidURLAction actionIfInvalid)
4615 {
4616     UNUSED_PARAM(keySystem);
4617 
4618     // Don&#39;t log if this was just called to find out if there are any valid &lt;source&gt; elements.
4619     bool shouldLog = willLog(WTFLogLevel::Debug) &amp;&amp; actionIfInvalid != DoNothing;
4620     if (shouldLog)
4621         INFO_LOG(LOGIDENTIFIER);
4622 
4623     if (!m_nextChildNodeToConsider) {
4624         if (shouldLog)
4625             INFO_LOG(LOGIDENTIFIER, &quot;end of list, stopping&quot;);
4626         return URL();
4627     }
4628 
4629     // Because the DOM may be mutated in the course of the following algorithm,
4630     // keep strong references to each of the child source nodes, and verify that
4631     // each still is a child of this media element before using.
4632     Vector&lt;Ref&lt;HTMLSourceElement&gt;&gt; potentialSourceNodes;
4633     auto sources = childrenOfType&lt;HTMLSourceElement&gt;(*this);
4634     for (auto next = m_nextChildNodeToConsider ? sources.beginAt(*m_nextChildNodeToConsider) : sources.begin(), end = sources.end(); next != end; ++next)
4635         potentialSourceNodes.append(*next);
4636 
4637     for (auto&amp; source : potentialSourceNodes) {
4638         if (source-&gt;parentNode() != this)
4639             continue;
4640 
4641         // If candidate does not have a src attribute, or if its src attribute&#39;s value is the empty string ... jump down to the failed step below
4642         auto mediaURL = source-&gt;getNonEmptyURLAttribute(srcAttr);
4643         String type;
4644         if (shouldLog)
4645             INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, mediaURL);
4646         if (mediaURL.isEmpty())
4647             goto CheckAgain;
4648 
4649         if (auto* media = source-&gt;parsedMediaAttribute(document())) {
4650             if (shouldLog)
4651                 INFO_LOG(LOGIDENTIFIER, &quot;&#39;media&#39; is &quot;, source-&gt;attributeWithoutSynchronization(mediaAttr));
4652             auto* renderer = this-&gt;renderer();
4653             LOG(MediaQueries, &quot;HTMLMediaElement %p selectNextSourceChild evaluating media queries&quot;, this);
4654             if (!MediaQueryEvaluator { &quot;screen&quot;, document(), renderer ? &amp;renderer-&gt;style() : nullptr }.evaluate(*media))
4655                 goto CheckAgain;
4656         }
4657 
4658         type = source-&gt;attributeWithoutSynchronization(typeAttr);
4659         if (type.isEmpty() &amp;&amp; mediaURL.protocolIsData())
4660             type = mimeTypeFromDataURL(mediaURL);
4661         if (!type.isEmpty()) {
4662             if (shouldLog)
4663                 INFO_LOG(LOGIDENTIFIER, &quot;&#39;type&#39; is &quot;, type);
4664             MediaEngineSupportParameters parameters;
4665             parameters.type = ContentType(type);
4666             parameters.url = mediaURL;
4667 #if ENABLE(MEDIA_SOURCE)
4668             parameters.isMediaSource = mediaURL.protocolIs(mediaSourceBlobProtocol);
4669 #endif
4670 #if ENABLE(MEDIA_STREAM)
4671             parameters.isMediaStream = mediaURL.protocolIs(mediaStreamBlobProtocol);
4672 #endif
4673             if (!document().settings().allowMediaContentTypesRequiringHardwareSupportAsFallback() || Traversal&lt;HTMLSourceElement&gt;::nextSkippingChildren(source))
4674                 parameters.contentTypesRequiringHardwareSupport = mediaContentTypesRequiringHardwareSupport();
4675 
<a name="118" id="anc118"></a><span class="line-modified">4676             if (MediaPlayer::supportsType(parameters) == MediaPlayer::SupportsType::IsNotSupported)</span>
4677                 goto CheckAgain;
4678         }
4679 
4680         // Is it safe to load this url?
4681         if (!isSafeToLoadURL(mediaURL, actionIfInvalid) || !dispatchBeforeLoadEvent(mediaURL.string()))
4682             goto CheckAgain;
4683 
4684         // A &#39;beforeload&#39; event handler can mutate the DOM, so check to see if the source element is still a child node.
4685         if (source-&gt;parentNode() != this) {
4686             INFO_LOG(LOGIDENTIFIER, &quot;&#39;beforeload&#39; removed current element&quot;);
4687             continue;
4688         }
4689 
4690         // Making it this far means the &lt;source&gt; looks reasonable.
4691         if (contentType)
4692             *contentType = ContentType(type);
4693         m_nextChildNodeToConsider = Traversal&lt;HTMLSourceElement&gt;::nextSkippingChildren(source);
4694         m_currentSourceNode = WTFMove(source);
4695 
4696         if (shouldLog)
4697             INFO_LOG(LOGIDENTIFIER, &quot; = &quot;, mediaURL);
4698 
4699         return mediaURL;
4700 
4701 CheckAgain:
4702         if (actionIfInvalid == Complain)
4703             source-&gt;scheduleErrorEvent();
4704     }
4705 
4706     m_currentSourceNode = nullptr;
4707     m_nextChildNodeToConsider = nullptr;
4708 
4709 #if !LOG_DISABLED
4710     if (shouldLog)
4711         INFO_LOG(LOGIDENTIFIER, &quot;failed&quot;);
4712 #endif
4713     return URL();
4714 }
4715 
4716 void HTMLMediaElement::sourceWasAdded(HTMLSourceElement&amp; source)
4717 {
4718     if (willLog(WTFLogLevel::Info) &amp;&amp; source.hasTagName(sourceTag)) {
4719         URL url = source.getNonEmptyURLAttribute(srcAttr);
4720         INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, url);
4721     }
4722 
4723     if (!document().hasBrowsingContext()) {
4724         INFO_LOG(LOGIDENTIFIER, &quot;&lt;source&gt; inserted inside a document without a browsing context is not loaded&quot;);
4725         return;
4726     }
4727 
4728     // We should only consider a &lt;source&gt; element when there is not src attribute at all.
4729     if (hasAttributeWithoutSynchronization(srcAttr))
4730         return;
4731 
4732     // 4.8.8 - If a source element is inserted as a child of a media element that has no src
4733     // attribute and whose networkState has the value NETWORK_EMPTY, the user agent must invoke
4734     // the media element&#39;s resource selection algorithm.
4735     if (m_networkState == NETWORK_EMPTY) {
4736         m_nextChildNodeToConsider = &amp;source;
4737 #if PLATFORM(IOS_FAMILY)
4738         if (m_mediaSession-&gt;dataLoadingPermitted())
4739 #endif
4740             selectMediaResource();
4741         return;
4742     }
4743 
4744     if (m_currentSourceNode &amp;&amp; &amp;source == Traversal&lt;HTMLSourceElement&gt;::nextSibling(*m_currentSourceNode)) {
4745         INFO_LOG(LOGIDENTIFIER, &quot;&lt;source&gt; inserted immediately after current source&quot;);
4746         m_nextChildNodeToConsider = &amp;source;
4747         return;
4748     }
4749 
4750     if (m_nextChildNodeToConsider)
4751         return;
4752 
4753     // 4.8.9.5, resource selection algorithm, source elements section:
4754     // 21. Wait until the node after pointer is a node other than the end of the list. (This step might wait forever.)
4755     // 22. Asynchronously await a stable state...
4756     // 23. Set the element&#39;s delaying-the-load-event flag back to true (this delays the load event again, in case
4757     // it hasn&#39;t been fired yet).
4758     setShouldDelayLoadEvent(true);
4759 
4760     // 24. Set the networkState back to NETWORK_LOADING.
4761     m_networkState = NETWORK_LOADING;
4762 
4763     // 25. Jump back to the find next candidate step above.
4764     m_nextChildNodeToConsider = &amp;source;
4765     scheduleNextSourceChild();
4766 }
4767 
4768 void HTMLMediaElement::sourceWasRemoved(HTMLSourceElement&amp; source)
4769 {
4770     if (willLog(WTFLogLevel::Info) &amp;&amp; source.hasTagName(sourceTag)) {
4771         URL url = source.getNonEmptyURLAttribute(srcAttr);
4772         INFO_LOG(LOGIDENTIFIER, &quot;&#39;src&#39; is &quot;, url);
4773     }
4774 
4775     if (&amp;source != m_currentSourceNode &amp;&amp; &amp;source != m_nextChildNodeToConsider)
4776         return;
4777 
4778     if (&amp;source == m_nextChildNodeToConsider) {
4779         m_nextChildNodeToConsider = m_currentSourceNode ? Traversal&lt;HTMLSourceElement&gt;::nextSibling(*m_currentSourceNode) : nullptr;
4780         INFO_LOG(LOGIDENTIFIER);
4781     } else if (&amp;source == m_currentSourceNode) {
4782         // Clear the current source node pointer, but don&#39;t change the movie as the spec says:
4783         // 4.8.8 - Dynamically modifying a source element and its attribute when the element is already
4784         // inserted in a video or audio element will have no effect.
4785         m_currentSourceNode = nullptr;
4786         INFO_LOG(LOGIDENTIFIER, &quot;m_currentSourceNode cleared&quot;);
4787     }
4788 }
4789 
<a name="119" id="anc119"></a><span class="line-modified">4790 void HTMLMediaElement::mediaPlayerTimeChanged()</span>
4791 {
4792     INFO_LOG(LOGIDENTIFIER);
4793 
4794 #if ENABLE(VIDEO_TRACK)
4795     updateActiveTextTrackCues(currentMediaTime());
4796 #endif
4797 
4798     beginProcessingMediaPlayerCallback();
4799 
4800     invalidateCachedTime();
4801     bool wasSeeking = seeking();
4802 
4803     // 4.8.10.9 step 14 &amp; 15.  Needed if no ReadyState change is associated with the seek.
4804     if (m_seekRequested &amp;&amp; m_readyState &gt;= HAVE_CURRENT_DATA &amp;&amp; !m_player-&gt;seeking())
4805         finishSeek();
4806 
4807     // Always call scheduleTimeupdateEvent when the media engine reports a time discontinuity,
4808     // it will only queue a &#39;timeupdate&#39; event if we haven&#39;t already posted one at the current
4809     // movie time.
4810     else
4811         scheduleTimeupdateEvent(false);
4812 
4813     MediaTime now = currentMediaTime();
4814     MediaTime dur = durationMediaTime();
4815     double playbackRate = requestedPlaybackRate();
4816 
4817     // When the current playback position reaches the end of the media resource then the user agent must follow these steps:
4818     if (dur &amp;&amp; dur.isValid() &amp;&amp; !dur.isPositiveInfinite() &amp;&amp; !dur.isNegativeInfinite()) {
4819         // If the media element has a loop attribute specified and does not have a current media controller,
4820         if (loop() &amp;&amp; !m_mediaController &amp;&amp; playbackRate &gt; 0) {
4821             m_sentEndEvent = false;
4822             // then seek to the earliest possible position of the media resource and abort these steps when the direction of
4823             // playback is forwards,
4824             if (now &gt;= dur)
4825                 seekInternal(MediaTime::zeroTime());
4826         } else if ((now &lt;= MediaTime::zeroTime() &amp;&amp; playbackRate &lt; 0) || (now &gt;= dur &amp;&amp; playbackRate &gt; 0)) {
4827             // If the media element does not have a current media controller, and the media element
4828             // has still ended playback and paused is false,
4829             if (!m_mediaController &amp;&amp; !m_paused) {
4830                 // changes paused to true and fires a simple event named pause at the media element.
4831                 m_paused = true;
4832                 scheduleEvent(eventNames().pauseEvent);
4833                 m_mediaSession-&gt;clientWillPausePlayback();
4834             }
4835             // Queue a task to fire a simple event named ended at the media element.
4836             if (!m_sentEndEvent) {
4837                 m_sentEndEvent = true;
4838                 scheduleEvent(eventNames().endedEvent);
4839                 if (!wasSeeking)
4840                     addBehaviorRestrictionsOnEndIfNecessary();
4841                 setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
4842             }
4843             setPlaying(false);
4844             // If the media element has a current media controller, then report the controller state
4845             // for the media element&#39;s current media controller.
4846             updateMediaController();
4847         } else
4848             m_sentEndEvent = false;
4849     } else {
4850 #if ENABLE(MEDIA_STREAM)
4851         if (m_mediaStreamSrcObject) {
4852             // http://w3c.github.io/mediacapture-main/#event-mediastream-inactive
4853             // 6. MediaStreams in Media Elements
4854             // When the MediaStream state moves from the active to the inactive state, the User Agent
4855             // must raise an ended event on the HTMLMediaElement and set its ended attribute to true.
4856             // Note that once ended equals true the HTMLMediaElement will not play media even if new
4857             // MediaStreamTrack&#39;s are added to the MediaStream (causing it to return to the active
4858             // state) unless autoplay is true or the web application restarts the element, e.g.,
4859             // by calling play()
4860             if (!m_sentEndEvent &amp;&amp; m_player &amp;&amp; m_player-&gt;ended()) {
4861                 m_sentEndEvent = true;
4862                 scheduleEvent(eventNames().endedEvent);
4863                 if (!wasSeeking)
4864                     addBehaviorRestrictionsOnEndIfNecessary();
4865                 m_paused = true;
4866                 setPlaying(false);
4867             }
4868         } else
4869 #endif
4870         m_sentEndEvent = false;
4871     }
4872 
4873     scheduleUpdatePlayState();
4874     endProcessingMediaPlayerCallback();
4875 }
4876 
4877 void HTMLMediaElement::addBehaviorRestrictionsOnEndIfNecessary()
4878 {
4879     if (isFullscreen())
4880         return;
4881 
4882     m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager);
4883     m_playbackControlsManagerBehaviorRestrictionsTimer.stop();
4884     m_playbackControlsManagerBehaviorRestrictionsTimer.startOneShot(hideMediaControlsAfterEndedDelay);
4885 }
4886 
4887 void HTMLMediaElement::handleSeekToPlaybackPosition(double position)
4888 {
4889 #if PLATFORM(MAC)
4890     // FIXME: This should ideally use faskSeek, but this causes MediaRemote&#39;s playhead to flicker upon release.
4891     // Please see &lt;rdar://problem/28457219&gt; for more details.
4892     seek(MediaTime::createWithDouble(position));
4893     m_seekToPlaybackPositionEndedTimer.stop();
4894     m_seekToPlaybackPositionEndedTimer.startOneShot(500_ms);
4895 
4896     if (!m_isScrubbingRemotely) {
4897         m_isScrubbingRemotely = true;
4898         if (!paused())
4899             pauseInternal();
4900     }
4901 #else
4902     fastSeek(position);
4903 #endif
4904 }
4905 
4906 void HTMLMediaElement::seekToPlaybackPositionEndedTimerFired()
4907 {
4908 #if PLATFORM(MAC)
4909     if (!m_isScrubbingRemotely)
4910         return;
4911 
4912     PlatformMediaSessionManager::sharedManager().sessionDidEndRemoteScrubbing(*m_mediaSession);
4913     m_isScrubbingRemotely = false;
4914     m_seekToPlaybackPositionEndedTimer.stop();
4915 #endif
4916 }
4917 
<a name="120" id="anc120"></a><span class="line-modified">4918 void HTMLMediaElement::mediaPlayerVolumeChanged()</span>
4919 {
4920     INFO_LOG(LOGIDENTIFIER);
4921 
4922     beginProcessingMediaPlayerCallback();
4923     if (m_player) {
4924         double vol = m_player-&gt;volume();
4925         if (vol != m_volume) {
4926             m_volume = vol;
4927             updateVolume();
4928             scheduleEvent(eventNames().volumechangeEvent);
4929         }
4930     }
4931     endProcessingMediaPlayerCallback();
4932 }
4933 
<a name="121" id="anc121"></a><span class="line-modified">4934 void HTMLMediaElement::mediaPlayerMuteChanged()</span>
4935 {
4936     INFO_LOG(LOGIDENTIFIER);
4937 
4938     beginProcessingMediaPlayerCallback();
4939     if (m_player)
4940         setMuted(m_player-&gt;muted());
4941     endProcessingMediaPlayerCallback();
4942 }
4943 
<a name="122" id="anc122"></a><span class="line-modified">4944 void HTMLMediaElement::mediaPlayerDurationChanged()</span>
4945 {
4946     INFO_LOG(LOGIDENTIFIER);
4947 
4948     beginProcessingMediaPlayerCallback();
4949 
4950     scheduleEvent(eventNames().durationchangeEvent);
<a name="123" id="anc123"></a><span class="line-modified">4951     mediaPlayerCharacteristicChanged();</span>
4952 
4953     MediaTime now = currentMediaTime();
4954     MediaTime dur = durationMediaTime();
4955     if (now &gt; dur)
4956         seekInternal(dur);
4957 
4958     endProcessingMediaPlayerCallback();
4959 }
4960 
<a name="124" id="anc124"></a><span class="line-modified">4961 void HTMLMediaElement::mediaPlayerRateChanged()</span>
4962 {
4963     beginProcessingMediaPlayerCallback();
4964 
4965     // Stash the rate in case the one we tried to set isn&#39;t what the engine is
4966     // using (eg. it can&#39;t handle the rate we set)
4967     m_reportedPlaybackRate = m_player-&gt;rate();
4968 
4969     INFO_LOG(LOGIDENTIFIER, &quot;rate: &quot;, m_reportedPlaybackRate);
4970 
4971     if (m_playing)
4972         invalidateCachedTime();
4973 
4974     updateSleepDisabling();
4975 
4976     endProcessingMediaPlayerCallback();
4977 }
4978 
<a name="125" id="anc125"></a><span class="line-modified">4979 void HTMLMediaElement::mediaPlayerPlaybackStateChanged()</span>
4980 {
4981     INFO_LOG(LOGIDENTIFIER);
4982 
4983     if (!m_player || m_pausedInternal)
4984         return;
4985 
4986     beginProcessingMediaPlayerCallback();
4987     if (m_player-&gt;paused())
4988         pauseInternal();
4989     else
4990         playInternal();
4991 
4992     updateSleepDisabling();
4993 
4994     endProcessingMediaPlayerCallback();
4995 }
4996 
<a name="126" id="anc126"></a><span class="line-modified">4997 void HTMLMediaElement::mediaPlayerResourceNotSupported()</span>











4998 {
4999     INFO_LOG(LOGIDENTIFIER);
5000 
5001     // The MediaPlayer came across content which no installed engine supports.
<a name="127" id="anc127"></a><span class="line-modified">5002     mediaLoadingFailed(MediaPlayer::NetworkState::FormatError);</span>
5003 }
5004 
5005 // MediaPlayerPresentation methods
<a name="128" id="anc128"></a><span class="line-modified">5006 void HTMLMediaElement::mediaPlayerRepaint()</span>
5007 {
5008     beginProcessingMediaPlayerCallback();
5009     updateDisplayState();
5010     if (auto* renderer = this-&gt;renderer())
5011         renderer-&gt;repaint();
5012     endProcessingMediaPlayerCallback();
5013 }
5014 
<a name="129" id="anc129"></a><span class="line-modified">5015 void HTMLMediaElement::mediaPlayerSizeChanged()</span>
5016 {
5017     INFO_LOG(LOGIDENTIFIER);
5018 
5019     if (is&lt;MediaDocument&gt;(document()) &amp;&amp; m_player)
5020         downcast&lt;MediaDocument&gt;(document()).mediaElementNaturalSizeChanged(expandedIntSize(m_player-&gt;naturalSize()));
5021 
5022     beginProcessingMediaPlayerCallback();
5023     if (m_readyState &gt; HAVE_NOTHING)
5024         scheduleResizeEventIfSizeChanged();
5025     updateRenderer();
5026     endProcessingMediaPlayerCallback();
5027 }
5028 
<a name="130" id="anc130"></a><span class="line-modified">5029 bool HTMLMediaElement::mediaPlayerRenderingCanBeAccelerated()</span>
5030 {
5031     auto* renderer = this-&gt;renderer();
5032     return is&lt;RenderVideo&gt;(renderer)
5033         &amp;&amp; downcast&lt;RenderVideo&gt;(*renderer).view().compositor().canAccelerateVideoRendering(downcast&lt;RenderVideo&gt;(*renderer));
5034 }
5035 
<a name="131" id="anc131"></a><span class="line-modified">5036 void HTMLMediaElement::mediaPlayerRenderingModeChanged()</span>
5037 {
5038     INFO_LOG(LOGIDENTIFIER);
5039 
5040     // Kick off a fake recalcStyle that will update the compositing tree.
5041     invalidateStyleAndLayerComposition();
5042 }
5043 
5044 bool HTMLMediaElement::mediaPlayerAcceleratedCompositingEnabled()
5045 {
5046     return document().settings().acceleratedCompositingEnabled();
5047 }
5048 
5049 #if PLATFORM(WIN) &amp;&amp; USE(AVFOUNDATION)
5050 
<a name="132" id="anc132"></a><span class="line-modified">5051 GraphicsDeviceAdapter* HTMLMediaElement::mediaPlayerGraphicsDeviceAdapter() const</span>
5052 {
5053     auto* page = document().page();
5054     if (!page)
5055         return nullptr;
5056     return page-&gt;chrome().client().graphicsDeviceAdapter();
5057 }
5058 
5059 #endif
5060 
5061 void HTMLMediaElement::scheduleMediaEngineWasUpdated()
5062 {
5063     if (m_mediaEngineUpdatedTask.hasPendingTask())
5064         return;
5065 
5066     auto logSiteIdentifier = LOGIDENTIFIER;
5067     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
5068     m_mediaEngineUpdatedTask.scheduleTask([this, logSiteIdentifier] {
5069         UNUSED_PARAM(logSiteIdentifier);
5070         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
5071         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // mediaEngineWasUpdated calls methods that can trigger arbitrary DOM mutations.
5072         mediaEngineWasUpdated();
5073     });
5074 }
5075 
5076 void HTMLMediaElement::mediaEngineWasUpdated()
5077 {
5078     INFO_LOG(LOGIDENTIFIER);
5079     beginProcessingMediaPlayerCallback();
5080     updateRenderer();
5081     endProcessingMediaPlayerCallback();
5082 
5083     m_mediaSession-&gt;mediaEngineUpdated();
5084 
5085 #if ENABLE(WEB_AUDIO)
5086     if (m_audioSourceNode &amp;&amp; audioSourceProvider()) {
5087         m_audioSourceNode-&gt;lock();
5088         audioSourceProvider()-&gt;setClient(m_audioSourceNode);
5089         m_audioSourceNode-&gt;unlock();
5090     }
5091 #endif
5092 
5093 #if ENABLE(ENCRYPTED_MEDIA)
5094     if (m_player &amp;&amp; m_mediaKeys)
5095         m_player-&gt;cdmInstanceAttached(m_mediaKeys-&gt;cdmInstance());
5096 #endif
5097 
5098 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
5099     if (!m_player)
5100         return;
5101     m_player-&gt;setVideoFullscreenFrame(m_videoFullscreenFrame);
5102     m_player-&gt;setVideoFullscreenGravity(m_videoFullscreenGravity);
5103     m_player-&gt;setVideoFullscreenLayer(m_videoFullscreenLayer.get());
5104 #endif
5105 
5106 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5107     scheduleUpdateMediaState();
5108 #endif
5109 }
5110 
<a name="133" id="anc133"></a><span class="line-modified">5111 void HTMLMediaElement::mediaPlayerEngineUpdated()</span>
5112 {
5113     INFO_LOG(LOGIDENTIFIER);
5114 
5115 #if ENABLE(MEDIA_SOURCE)
5116     m_droppedVideoFrames = 0;
5117 #endif
5118 
5119     m_havePreparedToPlay = false;
5120 
5121     scheduleMediaEngineWasUpdated();
5122 }
5123 
<a name="134" id="anc134"></a><span class="line-modified">5124 void HTMLMediaElement::mediaPlayerFirstVideoFrameAvailable()</span>
5125 {
5126     INFO_LOG(LOGIDENTIFIER, &quot;current display mode = &quot;, (int)displayMode());
5127 
5128     beginProcessingMediaPlayerCallback();
5129     if (displayMode() == PosterWaitingForVideo) {
5130         setDisplayMode(Video);
<a name="135" id="anc135"></a><span class="line-modified">5131         mediaPlayerRenderingModeChanged();</span>
5132     }
5133     endProcessingMediaPlayerCallback();
5134 }
5135 
<a name="136" id="anc136"></a><span class="line-modified">5136 void HTMLMediaElement::mediaPlayerCharacteristicChanged()</span>
5137 {
5138     INFO_LOG(LOGIDENTIFIER);
5139 
5140     beginProcessingMediaPlayerCallback();
5141 
5142 #if ENABLE(VIDEO_TRACK)
5143     if (captionDisplayMode() == CaptionUserPreferences::Automatic &amp;&amp; m_subtitleTrackLanguage != m_player-&gt;languageOfPrimaryAudioTrack())
5144         markCaptionAndSubtitleTracksAsUnconfigured(AfterDelay);
5145 #endif
5146 
5147     if (potentiallyPlaying() &amp;&amp; displayMode() == PosterWaitingForVideo) {
5148         setDisplayMode(Video);
<a name="137" id="anc137"></a><span class="line-modified">5149         mediaPlayerRenderingModeChanged();</span>
5150     }
5151 
5152     if (hasMediaControls())
5153         mediaControls()-&gt;reset();
5154     updateRenderer();
5155 
5156     if (!paused() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
5157         pauseInternal();
5158         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
5159     }
5160 
5161 #if ENABLE(MEDIA_SESSION)
5162     document().updateIsPlayingMedia(m_elementID);
5163 #else
5164     document().updateIsPlayingMedia();
5165 #endif
5166 
5167     m_hasEverHadAudio |= hasAudio();
5168     m_hasEverHadVideo |= hasVideo();
5169 
5170     m_mediaSession-&gt;canProduceAudioChanged();
5171 
5172     updateSleepDisabling();
5173 
5174     endProcessingMediaPlayerCallback();
5175 }
5176 
5177 Ref&lt;TimeRanges&gt; HTMLMediaElement::buffered() const
5178 {
5179     if (!m_player)
5180         return TimeRanges::create();
5181 
5182 #if ENABLE(MEDIA_SOURCE)
5183     if (m_mediaSource)
5184         return TimeRanges::create(*m_mediaSource-&gt;buffered());
5185 #endif
5186 
5187     return TimeRanges::create(*m_player-&gt;buffered());
5188 }
5189 
5190 double HTMLMediaElement::maxBufferedTime() const
5191 {
5192     auto bufferedRanges = buffered();
5193     unsigned numRanges = bufferedRanges-&gt;length();
5194     if (!numRanges)
5195         return 0;
5196     return bufferedRanges.get().ranges().end(numRanges - 1).toDouble();
5197 }
5198 
5199 Ref&lt;TimeRanges&gt; HTMLMediaElement::played()
5200 {
5201     if (m_playing) {
5202         MediaTime time = currentMediaTime();
5203         if (time &gt; m_lastSeekTime)
5204             addPlayedRange(m_lastSeekTime, time);
5205     }
5206 
5207     if (!m_playedTimeRanges)
5208         m_playedTimeRanges = TimeRanges::create();
5209 
5210     return m_playedTimeRanges-&gt;copy();
5211 }
5212 
5213 Ref&lt;TimeRanges&gt; HTMLMediaElement::seekable() const
5214 {
5215 #if ENABLE(MEDIA_SOURCE)
5216     if (m_mediaSource)
5217         return m_mediaSource-&gt;seekable();
5218 #endif
5219 
5220     if (m_player)
5221         return TimeRanges::create(*m_player-&gt;seekable());
5222 
5223     return TimeRanges::create();
5224 }
5225 
5226 double HTMLMediaElement::seekableTimeRangesLastModifiedTime() const
5227 {
5228     return m_player ? m_player-&gt;seekableTimeRangesLastModifiedTime() : 0;
5229 }
5230 
5231 double HTMLMediaElement::liveUpdateInterval() const
5232 {
5233     return m_player ? m_player-&gt;liveUpdateInterval() : 0;
5234 }
5235 
5236 bool HTMLMediaElement::potentiallyPlaying() const
5237 {
5238     if (isBlockedOnMediaController())
5239         return false;
5240 
5241     if (!couldPlayIfEnoughData())
5242         return false;
5243 
5244     if (m_readyState &gt;= HAVE_FUTURE_DATA)
5245         return true;
5246 
5247     return m_readyStateMaximum &gt;= HAVE_FUTURE_DATA &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA;
5248 }
5249 
5250 bool HTMLMediaElement::couldPlayIfEnoughData() const
5251 {
5252     if (paused())
5253         return false;
5254 
5255     if (endedPlayback())
5256         return false;
5257 
5258     if (stoppedDueToErrors())
5259         return false;
5260 
5261     if (pausedForUserInteraction())
5262         return false;
5263 
5264     return true;
5265 }
5266 
5267 bool HTMLMediaElement::endedPlayback() const
5268 {
5269     MediaTime dur = durationMediaTime();
5270     if (!m_player || !dur.isValid())
5271         return false;
5272 
5273     // 4.8.10.8 Playing the media resource
5274 
5275     // A media element is said to have ended playback when the element&#39;s
5276     // readyState attribute is HAVE_METADATA or greater,
5277     if (m_readyState &lt; HAVE_METADATA)
5278         return false;
5279 
5280     // and the current playback position is the end of the media resource and the direction
5281     // of playback is forwards, Either the media element does not have a loop attribute specified,
5282     // or the media element has a current media controller.
5283     MediaTime now = currentMediaTime();
5284     if (requestedPlaybackRate() &gt; 0)
5285         return dur &gt; MediaTime::zeroTime() &amp;&amp; now &gt;= dur &amp;&amp; (!loop() || m_mediaController);
5286 
5287     // or the current playback position is the earliest possible position and the direction
5288     // of playback is backwards
5289     if (requestedPlaybackRate() &lt; 0)
5290         return now &lt;= MediaTime::zeroTime();
5291 
5292     return false;
5293 }
5294 
5295 bool HTMLMediaElement::stoppedDueToErrors() const
5296 {
5297     if (m_readyState &gt;= HAVE_METADATA &amp;&amp; m_error) {
5298         RefPtr&lt;TimeRanges&gt; seekableRanges = seekable();
5299         if (!seekableRanges-&gt;contain(currentTime()))
5300             return true;
5301     }
5302 
5303     return false;
5304 }
5305 
5306 bool HTMLMediaElement::pausedForUserInteraction() const
5307 {
5308     if (m_mediaSession-&gt;state() == PlatformMediaSession::Interrupted)
5309         return true;
5310 
5311     return false;
5312 }
5313 
5314 MediaTime HTMLMediaElement::minTimeSeekable() const
5315 {
5316     return m_player ? m_player-&gt;minTimeSeekable() : MediaTime::zeroTime();
5317 }
5318 
5319 MediaTime HTMLMediaElement::maxTimeSeekable() const
5320 {
5321     return m_player ? m_player-&gt;maxTimeSeekable() : MediaTime::zeroTime();
5322 }
5323 
5324 void HTMLMediaElement::updateVolume()
5325 {
5326     if (!m_player)
5327         return;
5328 #if PLATFORM(IOS_FAMILY)
5329     // Only the user can change audio volume so update the cached volume and post the changed event.
5330     float volume = m_player-&gt;volume();
5331     if (m_volume != volume) {
5332         m_volume = volume;
5333         scheduleEvent(eventNames().volumechangeEvent);
5334     }
5335 #else
5336     // Avoid recursion when the player reports volume changes.
5337     if (!processingMediaPlayerCallback()) {
5338         m_player-&gt;setMuted(effectiveMuted());
5339         m_player-&gt;setVolume(effectiveVolume());
5340     }
5341 
5342 #if ENABLE(MEDIA_SESSION)
5343     document().updateIsPlayingMedia(m_elementID);
5344 #else
5345     document().updateIsPlayingMedia();
5346 #endif
5347 
5348     if (hasMediaControls())
5349         mediaControls()-&gt;changedVolume();
5350 #endif
5351 }
5352 
5353 void HTMLMediaElement::scheduleUpdatePlayState()
5354 {
5355     if (m_updatePlayStateTask.hasPendingTask())
5356         return;
5357 
5358     auto logSiteIdentifier = LOGIDENTIFIER;
5359     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
5360     m_updatePlayStateTask.scheduleTask([this, logSiteIdentifier] {
5361         UNUSED_PARAM(logSiteIdentifier);
5362         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
5363         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // updatePlayState calls methods that can trigger arbitrary DOM mutations.
5364         updatePlayState();
5365     });
5366 }
5367 
5368 void HTMLMediaElement::updatePlayState()
5369 {
5370     if (!m_player)
5371         return;
5372 
5373     if (m_pausedInternal) {
5374         if (!m_player-&gt;paused())
5375             m_player-&gt;pause();
5376         refreshCachedTime();
5377         m_playbackProgressTimer.stop();
5378         if (hasMediaControls())
5379             mediaControls()-&gt;playbackStopped();
5380         return;
5381     }
5382 
5383     bool shouldBePlaying = potentiallyPlaying();
5384     bool playerPaused = m_player-&gt;paused();
5385 
5386     INFO_LOG(LOGIDENTIFIER, &quot;shouldBePlaying = &quot;, shouldBePlaying, &quot;, playerPaused = &quot;, playerPaused);
5387 
5388     if (shouldBePlaying &amp;&amp; playerPaused &amp;&amp; m_mediaSession-&gt;requiresFullscreenForVideoPlayback() &amp;&amp; (m_waitingToEnterFullscreen || !isFullscreen())) {
5389         if (!m_waitingToEnterFullscreen)
5390             enterFullscreen();
5391 
5392 #if PLATFORM(WATCHOS)
5393         // FIXME: Investigate doing this for all builds.
5394         return;
5395 #endif
5396     }
5397 
5398     if (shouldBePlaying) {
5399         schedulePlaybackControlsManagerUpdate();
5400 
5401         setDisplayMode(Video);
5402         invalidateCachedTime();
5403 
5404         if (playerPaused) {
5405             m_mediaSession-&gt;clientWillBeginPlayback();
5406 
5407             // Set rate, muted and volume before calling play in case they were set before the media engine was set up.
5408             // The media engine should just stash the rate, muted and volume values since it isn&#39;t already playing.
5409             m_player-&gt;setRate(requestedPlaybackRate());
5410             m_player-&gt;setMuted(effectiveMuted());
5411             m_player-&gt;setVolume(effectiveVolume());
5412 
5413             if (m_firstTimePlaying) {
5414                 // Log that a media element was played.
5415                 if (auto* page = document().page())
5416                     page-&gt;diagnosticLoggingClient().logDiagnosticMessage(isVideo() ? DiagnosticLoggingKeys::videoKey() : DiagnosticLoggingKeys::audioKey(), DiagnosticLoggingKeys::playedKey(), ShouldSample::No);
5417                 m_firstTimePlaying = false;
5418             }
5419 
5420             m_player-&gt;play();
5421         }
5422 
5423         if (hasMediaControls())
5424             mediaControls()-&gt;playbackStarted();
5425 
5426         startPlaybackProgressTimer();
5427         setPlaying(true);
5428     } else {
5429         schedulePlaybackControlsManagerUpdate();
5430 
5431         if (!playerPaused)
5432             m_player-&gt;pause();
5433         refreshCachedTime();
5434 
5435         m_playbackProgressTimer.stop();
5436         setPlaying(false);
5437         MediaTime time = currentMediaTime();
5438         if (time &gt; m_lastSeekTime)
5439             addPlayedRange(m_lastSeekTime, time);
5440 
5441         if (couldPlayIfEnoughData())
5442             prepareToPlay();
5443 
5444         if (hasMediaControls())
5445             mediaControls()-&gt;playbackStopped();
5446     }
5447 
5448     updateMediaController();
5449     updateRenderer();
5450 
5451     m_hasEverHadAudio |= hasAudio();
5452     m_hasEverHadVideo |= hasVideo();
5453 }
5454 
5455 void HTMLMediaElement::setPlaying(bool playing)
5456 {
5457     if (playing &amp;&amp; m_mediaSession)
5458         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePlaybackToControlControlsManager);
5459 
5460     if (m_playing == playing)
5461         return;
5462 
5463     m_playing = playing;
5464 
5465     if (m_playing)
5466         scheduleNotifyAboutPlaying();
5467 
5468 #if ENABLE(MEDIA_SESSION)
5469     document().updateIsPlayingMedia(m_elementID);
5470 #else
5471     document().updateIsPlayingMedia();
5472 #endif
5473 
5474 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5475     scheduleUpdateMediaState();
5476 #endif
5477 }
5478 
5479 void HTMLMediaElement::setPausedInternal(bool b)
5480 {
5481     m_pausedInternal = b;
5482     scheduleUpdatePlayState();
5483 }
5484 
<a name="138" id="anc138"></a><span class="line-added">5485 void HTMLMediaElement::pauseAndUpdatePlayStateImmediately()</span>
<span class="line-added">5486 {</span>
<span class="line-added">5487     m_pausedInternal = true;</span>
<span class="line-added">5488     updatePlayState();</span>
<span class="line-added">5489 }</span>
<span class="line-added">5490 </span>
5491 void HTMLMediaElement::stopPeriodicTimers()
5492 {
5493     m_progressEventTimer.stop();
5494     m_playbackProgressTimer.stop();
5495 }
5496 
5497 void HTMLMediaElement::cancelPendingTasks()
5498 {
5499     m_configureTextTracksTask.cancelTask();
5500     m_checkPlaybackTargetCompatablityTask.cancelTask();
5501     m_updateMediaStateTask.cancelTask();
5502     m_mediaEngineUpdatedTask.cancelTask();
5503     m_updatePlayStateTask.cancelTask();
5504 #if PLATFORM(IOS_FAMILY)
5505     m_volumeRevertTaskQueue.cancelTask();
5506 #endif
5507 }
5508 
5509 void HTMLMediaElement::userCancelledLoad()
5510 {
5511     INFO_LOG(LOGIDENTIFIER);
5512 
5513     // FIXME: We should look to reconcile the iOS and non-iOS code (below).
5514 #if PLATFORM(IOS_FAMILY)
5515     if (m_networkState == NETWORK_EMPTY || m_readyState &gt;= HAVE_METADATA)
5516         return;
5517 #else
5518     if (m_networkState == NETWORK_EMPTY || m_completelyLoaded)
5519         return;
5520 #endif
5521 
5522     // If the media data fetching process is aborted by the user:
5523 
5524     // 1 - The user agent should cancel the fetching process.
5525     clearMediaPlayer();
5526 
5527     // 2 - Set the error attribute to a new MediaError object whose code attribute is set to MEDIA_ERR_ABORTED.
5528     m_error = MediaError::create(MediaError::MEDIA_ERR_ABORTED);
5529 
5530     // 3 - Queue a task to fire a simple event named error at the media element.
5531     scheduleEvent(eventNames().abortEvent);
5532 
5533 #if ENABLE(MEDIA_SOURCE)
5534     detachMediaSource();
5535 #endif
5536 
5537     // 4 - If the media element&#39;s readyState attribute has a value equal to HAVE_NOTHING, set the
5538     // element&#39;s networkState attribute to the NETWORK_EMPTY value and queue a task to fire a
5539     // simple event named emptied at the element. Otherwise, set the element&#39;s networkState
5540     // attribute to the NETWORK_IDLE value.
5541     if (m_readyState == HAVE_NOTHING) {
5542         m_networkState = NETWORK_EMPTY;
5543         scheduleEvent(eventNames().emptiedEvent);
5544     }
5545     else
5546         m_networkState = NETWORK_IDLE;
5547 
5548     // 5 - Set the element&#39;s delaying-the-load-event flag to false. This stops delaying the load event.
5549     setShouldDelayLoadEvent(false);
5550 
5551     // 6 - Abort the overall resource selection algorithm.
5552     m_currentSourceNode = nullptr;
5553 
5554     // Reset m_readyState since m_player is gone.
5555     m_readyState = HAVE_NOTHING;
5556     updateMediaController();
5557 
5558 #if ENABLE(VIDEO_TRACK)
5559     auto* context = scriptExecutionContext();
5560     if (!context || context-&gt;activeDOMObjectsAreStopped())
5561         return; // Document is about to be destructed. Avoid updating layout in updateActiveTextTrackCues.
5562 
5563     updateActiveTextTrackCues(MediaTime::zeroTime());
5564 #endif
5565 }
5566 
5567 void HTMLMediaElement::clearMediaPlayer()
5568 {
5569 #if ENABLE(MEDIA_STREAM)
5570     if (!m_settingMediaStreamSrcObject)
5571         m_mediaStreamSrcObject = nullptr;
5572 #endif
5573 
5574 #if ENABLE(MEDIA_SOURCE)
5575     detachMediaSource();
5576 #endif
5577 
5578     m_blob = nullptr;
5579 
5580 #if ENABLE(VIDEO_TRACK)
5581     forgetResourceSpecificTracks();
5582 #endif
5583 
5584 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<a name="139" id="anc139"></a><span class="line-modified">5585     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) || m_remote-&gt;hasAvailabilityCallbacks()) {</span>
5586         m_hasPlaybackTargetAvailabilityListeners = false;
5587         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
5588 
5589         // Send an availability event in case scripts want to hide the picker when the element
5590         // doesn&#39;t support playback to a target.
5591         enqueuePlaybackTargetAvailabilityChangedEvent();
5592     }
5593 
5594     if (m_isPlayingToWirelessTarget)
5595         setIsPlayingToWirelessTarget(false);
5596 #endif
5597 
5598     if (m_isWaitingUntilMediaCanStart) {
5599         m_isWaitingUntilMediaCanStart = false;
5600         document().removeMediaCanStartListener(*this);
5601     }
5602 
5603     if (m_player) {
5604         m_player-&gt;invalidate();
5605         m_player = nullptr;
5606     }
5607     schedulePlaybackControlsManagerUpdate();
5608 
5609     stopPeriodicTimers();
5610     cancelPendingTasks();
5611 
5612     m_loadState = WaitingForSource;
5613 
5614 #if ENABLE(VIDEO_TRACK)
5615     if (m_textTracks)
5616         configureTextTrackDisplay();
5617 #endif
5618 
5619     m_mediaSession-&gt;clientCharacteristicsChanged();
5620     m_mediaSession-&gt;canProduceAudioChanged();
5621 
5622     m_resourceSelectionTaskQueue.cancelAllTasks();
5623 
5624     updateSleepDisabling();
5625 }
5626 
<a name="140" id="anc140"></a>




5627 const char* HTMLMediaElement::activeDOMObjectName() const
5628 {
5629     return &quot;HTMLMediaElement&quot;;
5630 }
5631 
5632 void HTMLMediaElement::stopWithoutDestroyingMediaPlayer()
5633 {
5634     INFO_LOG(LOGIDENTIFIER);
5635 
5636     if (m_videoFullscreenMode != VideoFullscreenModeNone)
5637         exitFullscreen();
5638 
5639     setPreparedToReturnVideoLayerToInline(true);
5640 
5641     schedulePlaybackControlsManagerUpdate();
5642     setInActiveDocument(false);
5643 
5644     // Stop the playback without generating events
5645     setPlaying(false);
<a name="141" id="anc141"></a><span class="line-modified">5646     pauseAndUpdatePlayStateImmediately();</span>
<span class="line-modified">5647     m_mediaSession-&gt;clientWillBeDOMSuspended();</span>
5648 
5649     setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
5650 
5651     userCancelledLoad();
5652 
5653     updateRenderer();
5654 
5655     stopPeriodicTimers();
5656 
5657     updateSleepDisabling();
5658 }
5659 
5660 void HTMLMediaElement::closeTaskQueues()
5661 {
5662     m_configureTextTracksTask.close();
5663     m_checkPlaybackTargetCompatablityTask.close();
5664     m_updateMediaStateTask.close();
5665     m_mediaEngineUpdatedTask.close();
5666     m_updatePlayStateTask.close();
5667     m_resumeTaskQueue.close();
5668     m_seekTaskQueue.close();
5669     m_playbackControlsManagerBehaviorRestrictionsQueue.close();
5670     m_seekTaskQueue.close();
5671     m_resumeTaskQueue.close();
5672     m_promiseTaskQueue.close();
5673     m_pauseAfterDetachedTaskQueue.close();
5674     m_resourceSelectionTaskQueue.close();
5675     m_visibilityChangeTaskQueue.close();
5676 #if ENABLE(ENCRYPTED_MEDIA)
5677     m_encryptedMediaQueue.close();
5678 #endif
<a name="142" id="anc142"></a><span class="line-modified">5679     m_asyncEventQueue-&gt;close();</span>
5680 #if PLATFORM(IOS_FAMILY)
5681     m_volumeRevertTaskQueue.close();
5682 #endif
5683 }
5684 
5685 void HTMLMediaElement::contextDestroyed()
5686 {
5687     closeTaskQueues();
5688     m_pendingPlayPromises.clear();
5689 
5690     ActiveDOMObject::contextDestroyed();
5691 }
5692 
5693 void HTMLMediaElement::stop()
5694 {
5695     INFO_LOG(LOGIDENTIFIER);
5696 
5697     Ref&lt;HTMLMediaElement&gt; protectedThis(*this);
5698     stopWithoutDestroyingMediaPlayer();
5699     closeTaskQueues();
5700 
5701     // Once an active DOM object has been stopped it can not be restarted, so we can deallocate
5702     // the media player now. Note that userCancelledLoad will already called clearMediaPlayer
5703     // if the media was not fully loaded, but we need the same cleanup if the file was completely
5704     // loaded and calling it again won&#39;t cause any problems.
5705     clearMediaPlayer();
5706 
5707     m_mediaSession-&gt;stopSession();
5708 }
5709 
5710 void HTMLMediaElement::suspend(ReasonForSuspension reason)
5711 {
5712     INFO_LOG(LOGIDENTIFIER);
5713     Ref&lt;HTMLMediaElement&gt; protectedThis(*this);
5714 
5715     m_resumeTaskQueue.cancelTask();
5716 
5717     switch (reason) {
<a name="143" id="anc143"></a><span class="line-modified">5718     case ReasonForSuspension::BackForwardCache:</span>
5719         stopWithoutDestroyingMediaPlayer();
<a name="144" id="anc144"></a>
5720         setBufferingPolicy(BufferingPolicy::MakeResourcesPurgeable);
5721         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
5722         break;
5723     case ReasonForSuspension::PageWillBeSuspended:
5724     case ReasonForSuspension::JavaScriptDebuggerPaused:
5725     case ReasonForSuspension::WillDeferLoading:
5726         // Do nothing, we don&#39;t pause media playback in these cases.
5727         break;
5728     }
5729 }
5730 
5731 void HTMLMediaElement::resume()
5732 {
5733     INFO_LOG(LOGIDENTIFIER);
5734 
5735     setInActiveDocument(true);
5736 
<a name="145" id="anc145"></a>

5737     if (!m_mediaSession-&gt;pageAllowsPlaybackAfterResuming())
5738         document().addMediaCanStartListener(*this);
5739     else
5740         setPausedInternal(false);
5741 
5742     m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequirePageConsentToResumeMedia);
5743     m_mediaSession-&gt;updateBufferingPolicy();
5744 
5745     if (m_error &amp;&amp; m_error-&gt;code() == MediaError::MEDIA_ERR_ABORTED &amp;&amp; !m_resumeTaskQueue.hasPendingTask()) {
<a name="146" id="anc146"></a><span class="line-modified">5746         // Restart the load if it was aborted in the middle by moving the document to the back/forward cache.</span>
5747         // m_error is only left at MEDIA_ERR_ABORTED when the document becomes inactive (it is set to
5748         //  MEDIA_ERR_ABORTED while the abortEvent is being sent, but cleared immediately afterwards).
5749         // This behavior is not specified but it seems like a sensible thing to do.
5750         // As it is not safe to immedately start loading now, let&#39;s schedule a load.
5751         m_resumeTaskQueue.scheduleTask(std::bind(&amp;HTMLMediaElement::prepareForLoad, this));
5752     }
5753 
5754     updateRenderer();
5755 }
5756 
5757 bool HTMLMediaElement::hasPendingActivity() const
5758 {
<a name="147" id="anc147"></a><span class="line-modified">5759     return (hasAudio() &amp;&amp; isPlaying()) || m_asyncEventQueue-&gt;hasPendingEvents() || m_creatingControls;</span>
5760 }
5761 
5762 void HTMLMediaElement::mediaVolumeDidChange()
5763 {
<a name="148" id="anc148"></a><span class="line-added">5764     // FIXME: We should try to reconcile this so there&#39;s no difference for PLATFORM(IOS_FAMILY).</span>
<span class="line-added">5765 #if !PLATFORM(IOS_FAMILY)</span>
5766     INFO_LOG(LOGIDENTIFIER);
5767     updateVolume();
<a name="149" id="anc149"></a><span class="line-added">5768 #endif</span>
5769 }
5770 
5771 void HTMLMediaElement::visibilityStateChanged()
5772 {
5773     bool elementIsHidden = document().hidden() &amp;&amp; m_videoFullscreenMode != VideoFullscreenModePictureInPicture;
5774     if (elementIsHidden == m_elementIsHidden)
5775         return;
5776 
5777     m_elementIsHidden = elementIsHidden;
5778     INFO_LOG(LOGIDENTIFIER, &quot;visible = &quot;, !m_elementIsHidden);
5779 
5780     updateSleepDisabling();
5781     m_mediaSession-&gt;visibilityChanged();
5782     if (m_player)
5783         m_player-&gt;setVisible(!m_elementIsHidden);
5784 
5785     bool isPlayingAudio = isPlaying() &amp;&amp; hasAudio() &amp;&amp; !muted() &amp;&amp; volume();
5786     if (!isPlayingAudio) {
5787         if (m_elementIsHidden) {
5788             ALWAYS_LOG(LOGIDENTIFIER, &quot;Suspending playback after going to the background&quot;);
5789             m_mediaSession-&gt;beginInterruption(PlatformMediaSession::EnteringBackground);
5790         } else {
5791             ALWAYS_LOG(LOGIDENTIFIER, &quot;Resuming playback after entering foreground&quot;);
5792             m_mediaSession-&gt;endInterruption(PlatformMediaSession::MayResumePlaying);
5793         }
5794     }
5795 }
5796 
5797 #if ENABLE(VIDEO_TRACK)
5798 bool HTMLMediaElement::requiresTextTrackRepresentation() const
5799 {
5800     return (m_videoFullscreenMode != VideoFullscreenModeNone) &amp;&amp; m_player ? m_player-&gt;requiresTextTrackRepresentation() : false;
5801 }
5802 
5803 void HTMLMediaElement::setTextTrackRepresentation(TextTrackRepresentation* representation)
5804 {
5805     if (m_player)
5806         m_player-&gt;setTextTrackRepresentation(representation);
5807 }
5808 
5809 void HTMLMediaElement::syncTextTrackBounds()
5810 {
5811     if (m_player)
5812         m_player-&gt;syncTextTrackBounds();
5813 }
5814 #endif // ENABLE(VIDEO_TRACK)
5815 
5816 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5817 void HTMLMediaElement::webkitShowPlaybackTargetPicker()
5818 {
5819     ALWAYS_LOG(LOGIDENTIFIER);
5820     if (processingUserGestureForMedia())
5821         removeBehaviorRestrictionsAfterFirstUserGesture();
5822     m_mediaSession-&gt;showPlaybackTargetPicker();
5823 }
5824 
5825 void HTMLMediaElement::wirelessRoutesAvailableDidChange()
5826 {
<a name="150" id="anc150"></a><span class="line-added">5827     bool hasTargets = m_mediaSession-&gt;hasWirelessPlaybackTargets();</span>
<span class="line-added">5828     m_remote-&gt;availabilityChanged(hasTargets);</span>
<span class="line-added">5829 </span>
5830     enqueuePlaybackTargetAvailabilityChangedEvent();
5831 }
5832 
<a name="151" id="anc151"></a><span class="line-modified">5833 void HTMLMediaElement::mediaPlayerCurrentPlaybackTargetIsWirelessChanged(bool isCurrentPlayBackTargetWireless)</span>
5834 {
<a name="152" id="anc152"></a><span class="line-modified">5835     setIsPlayingToWirelessTarget(m_player &amp;&amp; isCurrentPlayBackTargetWireless);</span>
5836 }
5837 
5838 void HTMLMediaElement::setIsPlayingToWirelessTarget(bool isPlayingToWirelessTarget)
5839 {
5840     m_playbackTargetIsWirelessQueue.enqueueTask([this, isPlayingToWirelessTarget] {
5841         if (isPlayingToWirelessTarget == m_isPlayingToWirelessTarget)
5842             return;
5843         m_isPlayingToWirelessTarget = m_player &amp;&amp; m_player-&gt;isCurrentPlaybackTargetWireless();
<a name="153" id="anc153"></a><span class="line-modified">5844         m_remote-&gt;isPlayingToRemoteTargetChanged(m_isPlayingToWirelessTarget);</span>
5845         ALWAYS_LOG(LOGIDENTIFIER, m_isPlayingToWirelessTarget);
5846         configureMediaControls();
5847         m_mediaSession-&gt;isPlayingToWirelessPlaybackTargetChanged(m_isPlayingToWirelessTarget);
5848         m_mediaSession-&gt;canProduceAudioChanged();
5849         scheduleUpdateMediaState();
5850         updateSleepDisabling();
5851 
5852         m_failedToPlayToWirelessTarget = false;
5853         scheduleCheckPlaybackTargetCompatability();
5854 
5855         dispatchEvent(Event::create(eventNames().webkitcurrentplaybacktargetiswirelesschangedEvent, Event::CanBubble::No, Event::IsCancelable::Yes));
5856     });
5857 }
5858 
5859 void HTMLMediaElement::dispatchEvent(Event&amp; event)
5860 {
5861     DEBUG_LOG(LOGIDENTIFIER, event.type());
5862 
5863     if (m_removedBehaviorRestrictionsAfterFirstUserGesture &amp;&amp; event.type() == eventNames().endedEvent)
5864         document().userActivatedMediaFinishedPlaying();
5865 
5866     HTMLElement::dispatchEvent(event);
5867 }
5868 
5869 bool HTMLMediaElement::addEventListener(const AtomString&amp; eventType, Ref&lt;EventListener&gt;&amp;&amp; listener, const AddEventListenerOptions&amp; options)
5870 {
5871     if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
5872         return Node::addEventListener(eventType, WTFMove(listener), options);
5873 
<a name="154" id="anc154"></a><span class="line-modified">5874     bool isFirstAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) &amp;&amp; !m_remote-&gt;hasAvailabilityCallbacks();</span>
<span class="line-added">5875 </span>
5876     if (!Node::addEventListener(eventType, WTFMove(listener), options))
5877         return false;
5878 
5879     if (isFirstAvailabilityChangedListener) {
5880         m_hasPlaybackTargetAvailabilityListeners = true;
5881         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(true);
5882     }
5883 
5884     INFO_LOG(LOGIDENTIFIER, &quot;&#39;webkitplaybacktargetavailabilitychanged&#39;&quot;);
5885 
5886     enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
5887     return true;
5888 }
5889 
5890 bool HTMLMediaElement::removeEventListener(const AtomString&amp; eventType, EventListener&amp; listener, const ListenerOptions&amp; options)
5891 {
5892     if (eventType != eventNames().webkitplaybacktargetavailabilitychangedEvent)
5893         return Node::removeEventListener(eventType, listener, options);
5894 
5895     if (!Node::removeEventListener(eventType, listener, options))
5896         return false;
5897 
<a name="155" id="anc155"></a><span class="line-modified">5898     bool didRemoveLastAvailabilityChangedListener = !hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) &amp;&amp; !m_remote-&gt;hasAvailabilityCallbacks();</span>
5899     INFO_LOG(LOGIDENTIFIER, &quot;removed last listener = &quot;, didRemoveLastAvailabilityChangedListener);
5900     if (didRemoveLastAvailabilityChangedListener) {
5901         m_hasPlaybackTargetAvailabilityListeners = false;
5902         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(false);
5903         scheduleUpdateMediaState();
5904     }
5905 
5906     return true;
5907 }
5908 
5909 void HTMLMediaElement::enqueuePlaybackTargetAvailabilityChangedEvent()
5910 {
5911     bool hasTargets = m_mediaSession-&gt;hasWirelessPlaybackTargets();
5912     INFO_LOG(LOGIDENTIFIER, &quot;hasTargets = &quot;, hasTargets);
5913     auto event = WebKitPlaybackTargetAvailabilityEvent::create(eventNames().webkitplaybacktargetavailabilitychangedEvent, hasTargets);
5914     event-&gt;setTarget(this);
<a name="156" id="anc156"></a><span class="line-modified">5915     m_asyncEventQueue-&gt;enqueueEvent(WTFMove(event));</span>
5916     scheduleUpdateMediaState();
5917 }
5918 
5919 void HTMLMediaElement::setWirelessPlaybackTarget(Ref&lt;MediaPlaybackTarget&gt;&amp;&amp; device)
5920 {
5921     ALWAYS_LOG(LOGIDENTIFIER);
<a name="157" id="anc157"></a><span class="line-added">5922     bool hasActiveRoute = device-&gt;hasActiveRoute();</span>
5923     if (m_player)
5924         m_player-&gt;setWirelessPlaybackTarget(WTFMove(device));
<a name="158" id="anc158"></a><span class="line-added">5925 </span>
<span class="line-added">5926     m_remote-&gt;shouldPlayToRemoteTargetChanged(hasActiveRoute);</span>
5927 }
5928 
5929 void HTMLMediaElement::setShouldPlayToPlaybackTarget(bool shouldPlay)
5930 {
5931     ALWAYS_LOG(LOGIDENTIFIER, shouldPlay);
5932 
5933     if (m_player)
5934         m_player-&gt;setShouldPlayToPlaybackTarget(shouldPlay);
5935 }
5936 
<a name="159" id="anc159"></a><span class="line-added">5937 void HTMLMediaElement::playbackTargetPickerWasDismissed()</span>
<span class="line-added">5938 {</span>
<span class="line-added">5939     m_remote-&gt;playbackTargetPickerWasDismissed();</span>
<span class="line-added">5940 }</span>
<span class="line-added">5941 </span>
<span class="line-added">5942 void HTMLMediaElement::remoteHasAvailabilityCallbacksChanged()</span>
<span class="line-added">5943 {</span>
<span class="line-added">5944     bool hasListeners = hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) || m_remote-&gt;hasAvailabilityCallbacks();</span>
<span class="line-added">5945     if (m_hasPlaybackTargetAvailabilityListeners == hasListeners)</span>
<span class="line-added">5946         return;</span>
<span class="line-added">5947 </span>
<span class="line-added">5948     INFO_LOG(LOGIDENTIFIER, &quot;hasListeners: &quot;, hasListeners);</span>
<span class="line-added">5949     m_hasPlaybackTargetAvailabilityListeners = hasListeners;</span>
<span class="line-added">5950     m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(hasListeners);</span>
<span class="line-added">5951     scheduleUpdateMediaState();</span>
<span class="line-added">5952 }</span>
5953 #endif // ENABLE(WIRELESS_PLAYBACK_TARGET)
5954 
5955 bool HTMLMediaElement::webkitCurrentPlaybackTargetIsWireless() const
5956 {
5957     INFO_LOG(LOGIDENTIFIER, m_isPlayingToWirelessTarget);
5958     return m_isPlayingToWirelessTarget;
5959 }
5960 
5961 void HTMLMediaElement::setPlayingOnSecondScreen(bool value)
5962 {
5963     if (value == m_playingOnSecondScreen)
5964         return;
5965 
5966     m_playingOnSecondScreen = value;
5967 
5968 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
5969     scheduleUpdateMediaState();
5970 #endif
5971 }
5972 
5973 double HTMLMediaElement::minFastReverseRate() const
5974 {
5975     return m_player ? m_player-&gt;minFastReverseRate() : 0;
5976 }
5977 
5978 double HTMLMediaElement::maxFastForwardRate() const
5979 {
5980     return m_player ? m_player-&gt;maxFastForwardRate() : 0;
5981 }
5982 
5983 bool HTMLMediaElement::isFullscreen() const
5984 {
5985     if (m_videoFullscreenMode != VideoFullscreenModeNone)
5986         return true;
5987 
5988 #if ENABLE(FULLSCREEN_API)
5989     if (document().fullscreenManager().isFullscreen() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == this)
5990         return true;
5991 #endif
5992 
5993     return false;
5994 }
5995 
5996 bool HTMLMediaElement::isStandardFullscreen() const
5997 {
5998 #if ENABLE(FULLSCREEN_API)
5999     if (document().fullscreenManager().isFullscreen() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == this)
6000         return true;
6001 #endif
6002 
6003     return m_videoFullscreenMode == VideoFullscreenModeStandard;
6004 }
6005 
6006 void HTMLMediaElement::toggleStandardFullscreenState()
6007 {
6008     if (isStandardFullscreen())
6009         exitFullscreen();
6010     else
6011         enterFullscreen();
6012 }
6013 
6014 void HTMLMediaElement::enterFullscreen(VideoFullscreenMode mode)
6015 {
<a name="160" id="anc160"></a><span class="line-modified">6016     INFO_LOG(LOGIDENTIFIER, &quot;, m_videoFullscreenMode = &quot;, m_videoFullscreenMode, &quot;, mode = &quot;, mode);</span>
6017     ASSERT(mode != VideoFullscreenModeNone);
6018 
6019     if (m_videoFullscreenMode == mode)
6020         return;
6021 
6022     m_temporarilyAllowingInlinePlaybackAfterFullscreen = false;
6023     m_waitingToEnterFullscreen = true;
6024 
6025 #if ENABLE(FULLSCREEN_API) &amp;&amp; ENABLE(VIDEO_USES_ELEMENT_FULLSCREEN)
6026     if (document().settings().fullScreenEnabled() &amp;&amp; mode == VideoFullscreenModeStandard) {
6027         document().fullscreenManager().requestFullscreenForElement(this, FullscreenManager::ExemptIFrameAllowFullscreenRequirement);
6028         return;
6029     }
6030 #endif
6031 
6032     m_fullscreenTaskQueue.enqueueTask([this, mode] {
6033         if (document().hidden()) {
6034             ALWAYS_LOG(LOGIDENTIFIER, &quot;  returning because document is hidden&quot;);
6035             return;
6036         }
6037 
6038         fullscreenModeChanged(mode);
6039         configureMediaControls();
6040         if (hasMediaControls())
6041             mediaControls()-&gt;enteredFullscreen();
6042         if (is&lt;HTMLVideoElement&gt;(*this)) {
6043             HTMLVideoElement&amp; asVideo = downcast&lt;HTMLVideoElement&gt;(*this);
6044             if (document().page()-&gt;chrome().client().supportsVideoFullscreen(m_videoFullscreenMode)) {
<a name="161" id="anc161"></a><span class="line-added">6045                 INFO_LOG(LOGIDENTIFIER, &quot;Entering fullscreen mode &quot;, m_videoFullscreenMode, &quot;, m_videoFullscreenStandby = &quot;, m_videoFullscreenStandby);</span>
6046                 document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(asVideo, m_videoFullscreenMode, m_videoFullscreenStandby);
6047                 scheduleEvent(eventNames().webkitbeginfullscreenEvent);
6048             }
6049         }
6050     });
6051 }
6052 
6053 void HTMLMediaElement::enterFullscreen()
6054 {
6055     enterFullscreen(VideoFullscreenModeStandard);
6056 }
6057 
6058 void HTMLMediaElement::exitFullscreen()
6059 {
6060     INFO_LOG(LOGIDENTIFIER);
6061 
6062     m_waitingToEnterFullscreen = false;
6063 
6064 #if ENABLE(FULLSCREEN_API)
6065     if (document().settings().fullScreenEnabled() &amp;&amp; document().fullscreenManager().currentFullscreenElement() == this) {
6066         if (document().fullscreenManager().isFullscreen())
6067             document().fullscreenManager().cancelFullscreen();
6068 
6069         if (m_videoFullscreenMode == VideoFullscreenModeStandard)
6070             return;
6071     }
6072 #endif
6073 
6074     ASSERT(m_videoFullscreenMode != VideoFullscreenModeNone);
6075     VideoFullscreenMode oldVideoFullscreenMode = m_videoFullscreenMode;
6076     fullscreenModeChanged(VideoFullscreenModeNone);
6077 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6078     Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // updateMediaControlsAfterPresentationModeChange calls methods that can trigger arbitrary DOM mutations.
6079     updateMediaControlsAfterPresentationModeChange();
6080 #endif
6081     if (hasMediaControls())
6082         mediaControls()-&gt;exitedFullscreen();
6083 
6084     if (!document().page() || !is&lt;HTMLVideoElement&gt;(*this))
6085         return;
6086 
6087     if (!paused() &amp;&amp; m_mediaSession-&gt;requiresFullscreenForVideoPlayback()) {
6088         if (!document().settings().allowsInlineMediaPlaybackAfterFullscreen() || isVideoTooSmallForInlinePlayback())
6089             pauseInternal();
6090         else {
6091             // Allow inline playback, but set a flag so pausing and starting again (e.g. when scrubbing or looping) won&#39;t go back to fullscreen.
6092             // Also set the controls attribute so the user will be able to control playback.
6093             m_temporarilyAllowingInlinePlaybackAfterFullscreen = true;
6094             setControls(true);
6095         }
6096     }
6097 
6098 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
6099     if (document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped())
6100         document().page()-&gt;chrome().client().exitVideoFullscreenToModeWithoutAnimation(downcast&lt;HTMLVideoElement&gt;(*this), VideoFullscreenModeNone);
6101     else
6102 #endif
6103     if (document().page()-&gt;chrome().client().supportsVideoFullscreen(oldVideoFullscreenMode)) {
6104         if (m_videoFullscreenStandby)
6105             document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this), m_videoFullscreenMode, m_videoFullscreenStandby);
6106         else
6107             document().page()-&gt;chrome().client().exitVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this));
6108         scheduleEvent(eventNames().webkitendfullscreenEvent);
6109     }
6110 }
6111 
6112 WEBCORE_EXPORT void HTMLMediaElement::setVideoFullscreenStandby(bool value)
6113 {
6114     ASSERT(is&lt;HTMLVideoElement&gt;(*this));
6115     if (m_videoFullscreenStandby == value)
6116         return;
6117 
6118     if (!document().page())
6119         return;
6120 
6121     if (!document().page()-&gt;chrome().client().supportsVideoFullscreenStandby())
6122         return;
6123 
6124     m_videoFullscreenStandby = value;
6125 
6126 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
6127     if (m_player)
6128         m_player-&gt;videoFullscreenStandbyChanged();
6129 #endif
6130 
6131     if (m_videoFullscreenStandby || m_videoFullscreenMode != VideoFullscreenModeNone)
6132         document().page()-&gt;chrome().client().enterVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this), m_videoFullscreenMode, m_videoFullscreenStandby);
6133     else
6134         document().page()-&gt;chrome().client().exitVideoFullscreenForVideoElement(downcast&lt;HTMLVideoElement&gt;(*this));
6135 }
6136 
6137 void HTMLMediaElement::willBecomeFullscreenElement()
6138 {
6139 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
6140     HTMLMediaElementEnums::VideoFullscreenMode oldVideoFullscreenMode = m_videoFullscreenMode;
6141 #endif
6142 
6143     fullscreenModeChanged(VideoFullscreenModeStandard);
6144 
6145 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
6146     switch (oldVideoFullscreenMode) {
6147     case VideoFullscreenModeNone:
6148     case VideoFullscreenModeStandard:
6149         // Don&#39;t need to do anything if we are not in any special fullscreen mode or it&#39;s already
6150         // in standard fullscreen mode.
6151         break;
6152     case VideoFullscreenModePictureInPicture:
6153         if (is&lt;HTMLVideoElement&gt;(*this))
6154             downcast&lt;HTMLVideoElement&gt;(this)-&gt;exitToFullscreenModeWithoutAnimationIfPossible(oldVideoFullscreenMode, VideoFullscreenModeStandard);
6155         break;
6156     }
6157 #endif
6158 
6159     Element::willBecomeFullscreenElement();
6160 }
6161 
6162 void HTMLMediaElement::didBecomeFullscreenElement()
6163 {
<a name="162" id="anc162"></a><span class="line-added">6164     INFO_LOG(LOGIDENTIFIER, &quot;, fullscreen mode = &quot;, fullscreenMode());</span>
6165     m_waitingToEnterFullscreen = false;
6166     if (hasMediaControls())
6167         mediaControls()-&gt;enteredFullscreen();
6168     scheduleUpdatePlayState();
6169 }
6170 
6171 void HTMLMediaElement::willStopBeingFullscreenElement()
6172 {
6173     if (hasMediaControls())
6174         mediaControls()-&gt;exitedFullscreen();
6175 
6176     if (fullscreenMode() == VideoFullscreenModeStandard)
6177         fullscreenModeChanged(VideoFullscreenModeNone);
6178 }
6179 
6180 PlatformLayer* HTMLMediaElement::platformLayer() const
6181 {
6182     return m_player ? m_player-&gt;platformLayer() : nullptr;
6183 }
6184 
6185 void HTMLMediaElement::setPreparedToReturnVideoLayerToInline(bool value)
6186 {
6187     m_preparedForInline = value;
6188     if (m_preparedForInline &amp;&amp; m_preparedForInlineCompletionHandler) {
6189         m_preparedForInlineCompletionHandler();
6190         m_preparedForInlineCompletionHandler = nullptr;
6191     }
6192 }
6193 
6194 void HTMLMediaElement::waitForPreparedForInlineThen(WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
6195 {
<a name="163" id="anc163"></a><span class="line-added">6196     INFO_LOG(LOGIDENTIFIER);</span>
6197     ASSERT(!m_preparedForInlineCompletionHandler);
6198     if (m_preparedForInline)  {
6199         completionHandler();
6200         return;
6201     }
6202 
6203     m_preparedForInlineCompletionHandler = WTFMove(completionHandler);
6204 }
6205 
6206 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE))
6207 
6208 void HTMLMediaElement::willExitFullscreen()
6209 {
6210     if (m_player)
6211         m_player-&gt;updateVideoFullscreenInlineImage();
6212 }
6213 
6214 bool HTMLMediaElement::isVideoLayerInline()
6215 {
6216     return !m_videoFullscreenLayer;
6217 };
6218 
6219 void HTMLMediaElement::setVideoFullscreenLayer(PlatformLayer* platformLayer, WTF::Function&lt;void()&gt;&amp;&amp; completionHandler)
6220 {
<a name="164" id="anc164"></a><span class="line-added">6221     INFO_LOG(LOGIDENTIFIER);</span>
6222     m_videoFullscreenLayer = platformLayer;
6223     if (!m_player) {
6224         completionHandler();
6225         return;
6226     }
6227 
6228     m_player-&gt;setVideoFullscreenLayer(platformLayer, WTFMove(completionHandler));
6229     invalidateStyleAndLayerComposition();
6230 #if ENABLE(VIDEO_TRACK)
6231     updateTextTrackDisplay();
6232 #endif
6233 }
6234 
6235 void HTMLMediaElement::setVideoFullscreenFrame(FloatRect frame)
6236 {
6237     m_videoFullscreenFrame = frame;
6238     if (m_player)
6239         m_player-&gt;setVideoFullscreenFrame(frame);
6240 }
6241 
6242 void HTMLMediaElement::setVideoFullscreenGravity(MediaPlayer::VideoGravity gravity)
6243 {
6244     m_videoFullscreenGravity = gravity;
6245     if (m_player)
6246         m_player-&gt;setVideoFullscreenGravity(gravity);
6247 }
6248 
6249 #else
6250 
6251 bool HTMLMediaElement::isVideoLayerInline()
6252 {
6253     return true;
6254 };
6255 
6256 #endif
6257 
6258 bool HTMLMediaElement::hasClosedCaptions() const
6259 {
6260     if (m_player &amp;&amp; m_player-&gt;hasClosedCaptions())
6261         return true;
6262 
6263 #if ENABLE(VIDEO_TRACK)
6264     if (!m_textTracks)
6265         return false;
6266 
6267     for (unsigned i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
6268         auto&amp; track = *m_textTracks-&gt;item(i);
6269         if (track.readinessState() == TextTrack::FailedToLoad)
6270             continue;
6271         if (track.kind() == TextTrack::Kind::Captions || track.kind() == TextTrack::Kind::Subtitles)
6272             return true;
6273     }
6274 #endif
6275 
6276     return false;
6277 }
6278 
6279 bool HTMLMediaElement::closedCaptionsVisible() const
6280 {
6281     return m_closedCaptionsVisible;
6282 }
6283 
6284 #if ENABLE(VIDEO_TRACK)
6285 
6286 void HTMLMediaElement::updateTextTrackDisplay()
6287 {
6288 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6289     ensureMediaControlsShadowRoot();
6290     if (!m_mediaControlsHost)
6291         m_mediaControlsHost = MediaControlsHost::create(this);
6292     m_mediaControlsHost-&gt;updateTextTrackContainer();
6293 #else
6294     if (!hasMediaControls() &amp;&amp; !createMediaControls())
6295         return;
6296 
6297     mediaControls()-&gt;updateTextTrackDisplay();
6298 #endif
6299 }
6300 
6301 #endif
6302 
6303 void HTMLMediaElement::setClosedCaptionsVisible(bool closedCaptionVisible)
6304 {
6305     INFO_LOG(LOGIDENTIFIER, closedCaptionVisible);
6306 
6307     m_closedCaptionsVisible = false;
6308 
6309     if (!m_player || !hasClosedCaptions())
6310         return;
6311 
6312     m_closedCaptionsVisible = closedCaptionVisible;
6313     m_player-&gt;setClosedCaptionsVisible(closedCaptionVisible);
6314 
6315 #if ENABLE(VIDEO_TRACK)
6316     markCaptionAndSubtitleTracksAsUnconfigured(Immediately);
6317     updateTextTrackDisplay();
6318 #else
6319     if (hasMediaControls())
6320         mediaControls()-&gt;changedClosedCaptionsVisibility();
6321 #endif
6322 }
6323 
6324 void HTMLMediaElement::setWebkitClosedCaptionsVisible(bool visible)
6325 {
6326     m_webkitLegacyClosedCaptionOverride = visible;
6327     setClosedCaptionsVisible(visible);
6328 }
6329 
6330 bool HTMLMediaElement::webkitClosedCaptionsVisible() const
6331 {
6332     return m_webkitLegacyClosedCaptionOverride &amp;&amp; m_closedCaptionsVisible;
6333 }
6334 
6335 
6336 bool HTMLMediaElement::webkitHasClosedCaptions() const
6337 {
6338     return hasClosedCaptions();
6339 }
6340 
6341 #if ENABLE(MEDIA_STATISTICS)
6342 unsigned HTMLMediaElement::webkitAudioDecodedByteCount() const
6343 {
6344     if (!m_player)
6345         return 0;
6346     return m_player-&gt;audioDecodedByteCount();
6347 }
6348 
6349 unsigned HTMLMediaElement::webkitVideoDecodedByteCount() const
6350 {
6351     if (!m_player)
6352         return 0;
6353     return m_player-&gt;videoDecodedByteCount();
6354 }
6355 #endif
6356 
6357 void HTMLMediaElement::mediaCanStart(Document&amp; document)
6358 {
6359     ASSERT_UNUSED(document, &amp;document == &amp;this-&gt;document());
6360     INFO_LOG(LOGIDENTIFIER, &quot;m_isWaitingUntilMediaCanStart = &quot;, m_isWaitingUntilMediaCanStart, &quot;, m_pausedInternal = &quot;, m_pausedInternal);
6361 
6362     ASSERT(m_isWaitingUntilMediaCanStart || m_pausedInternal);
6363     if (m_isWaitingUntilMediaCanStart) {
6364         m_isWaitingUntilMediaCanStart = false;
6365         selectMediaResource();
6366     }
6367     if (m_pausedInternal)
6368         setPausedInternal(false);
6369 }
6370 
6371 bool HTMLMediaElement::isURLAttribute(const Attribute&amp; attribute) const
6372 {
6373     return attribute.name() == srcAttr || HTMLElement::isURLAttribute(attribute);
6374 }
6375 
6376 void HTMLMediaElement::setShouldDelayLoadEvent(bool shouldDelay)
6377 {
6378     if (m_shouldDelayLoadEvent == shouldDelay)
6379         return;
6380 
6381     INFO_LOG(LOGIDENTIFIER, shouldDelay);
6382 
6383     m_shouldDelayLoadEvent = shouldDelay;
6384     if (shouldDelay)
6385         document().incrementLoadEventDelayCount();
6386     else
6387         document().decrementLoadEventDelayCount();
6388 }
6389 
6390 static String&amp; sharedMediaCacheDirectory()
6391 {
6392     static NeverDestroyed&lt;String&gt; sharedMediaCacheDirectory;
6393     return sharedMediaCacheDirectory;
6394 }
6395 
6396 void HTMLMediaElement::setMediaCacheDirectory(const String&amp; path)
6397 {
6398     sharedMediaCacheDirectory() = path;
6399 }
6400 
6401 const String&amp; HTMLMediaElement::mediaCacheDirectory()
6402 {
6403     return sharedMediaCacheDirectory();
6404 }
6405 
6406 HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt; HTMLMediaElement::originsInMediaCache(const String&amp; path)
6407 {
6408     return MediaPlayer::originsInMediaCache(path);
6409 }
6410 
6411 void HTMLMediaElement::clearMediaCache(const String&amp; path, WallTime modifiedSince)
6412 {
6413     MediaPlayer::clearMediaCache(path, modifiedSince);
6414 }
6415 
6416 void HTMLMediaElement::clearMediaCacheForOrigins(const String&amp; path, const HashSet&lt;RefPtr&lt;SecurityOrigin&gt;&gt;&amp; origins)
6417 {
6418     MediaPlayer::clearMediaCacheForOrigins(path, origins);
6419 }
6420 
6421 void HTMLMediaElement::resetMediaEngines()
6422 {
6423     MediaPlayer::resetMediaEngines();
6424 }
6425 
6426 void HTMLMediaElement::privateBrowsingStateDidChange(PAL::SessionID sessionID)
6427 {
<a name="165" id="anc165"></a><span class="line-added">6428     // FIXME: We should try to reconcile this so there&#39;s no difference for PLATFORM(IOS_FAMILY).</span>
<span class="line-added">6429 #if PLATFORM(IOS_FAMILY)</span>
<span class="line-added">6430     UNUSED_PARAM(sessionID);</span>
<span class="line-added">6431 #else</span>
6432     if (!m_player)
6433         return;
6434 
6435     m_player-&gt;setPrivateBrowsingMode(sessionID.isEphemeral());
<a name="166" id="anc166"></a><span class="line-added">6436 #endif</span>
6437 }
6438 
6439 MediaControls* HTMLMediaElement::mediaControls() const
6440 {
6441 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6442     return nullptr;
6443 #else
6444     auto root = userAgentShadowRoot();
6445     if (!root)
6446         return nullptr;
6447 
6448     return childrenOfType&lt;MediaControls&gt;(*root).first();
6449 #endif
6450 }
6451 
6452 bool HTMLMediaElement::hasMediaControls() const
6453 {
6454 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6455     return false;
6456 #else
6457 
6458     if (auto userAgent = userAgentShadowRoot()) {
6459         RefPtr&lt;Node&gt; node = childrenOfType&lt;MediaControls&gt;(*root).first();
6460         ASSERT_WITH_SECURITY_IMPLICATION(!node || node-&gt;isMediaControls());
6461         return node;
6462     }
6463 
6464     return false;
6465 #endif
6466 }
6467 
6468 bool HTMLMediaElement::createMediaControls()
6469 {
6470 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6471     ensureMediaControlsShadowRoot();
6472     return false;
6473 #else
6474     if (hasMediaControls())
6475         return true;
6476 
6477     auto mediaControls = MediaControls::create(document());
6478     if (!mediaControls)
6479         return false;
6480 
6481     mediaControls-&gt;setMediaController(m_mediaController ? m_mediaController.get() : static_cast&lt;MediaControllerInterface*&gt;(this));
6482     mediaControls-&gt;reset();
6483     if (isFullscreen())
6484         mediaControls-&gt;enteredFullscreen();
6485 
6486     ensureUserAgentShadowRoot().appendChild(mediaControls);
6487 
6488     if (!controls() || !isConnected())
6489         mediaControls-&gt;hide();
6490 
6491     return true;
6492 #endif
6493 }
6494 
6495 bool HTMLMediaElement::shouldForceControlsDisplay() const
6496 {
6497     // Always create controls for autoplay video that requires user gesture due to being in low power mode.
6498     return isVideo() &amp;&amp; autoplay() &amp;&amp; m_mediaSession-&gt;hasBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoDueToLowPowerMode);
6499 }
6500 
6501 void HTMLMediaElement::configureMediaControls()
6502 {
6503     bool requireControls = controls();
6504 
6505     // Always create controls for video when fullscreen playback is required.
6506     if (isVideo() &amp;&amp; m_mediaSession-&gt;requiresFullscreenForVideoPlayback())
6507         requireControls = true;
6508 
6509     if (shouldForceControlsDisplay())
6510         requireControls = true;
6511 
6512     // Always create controls when in full screen mode.
6513     if (isFullscreen())
6514         requireControls = true;
6515 
6516 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6517     if (m_isPlayingToWirelessTarget)
6518         requireControls = true;
6519 #endif
6520 
6521 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6522     if (!requireControls || !isConnected() || !inActiveDocument())
6523         return;
6524 
6525     ensureMediaControlsShadowRoot();
6526 #else
6527     if (!requireControls || !isConnected() || !inActiveDocument()) {
6528         if (hasMediaControls())
6529             mediaControls()-&gt;hide();
6530         return;
6531     }
6532 
6533     if (!hasMediaControls() &amp;&amp; !createMediaControls())
6534         return;
6535 
6536     mediaControls()-&gt;show();
6537 #endif
6538 }
6539 
6540 #if ENABLE(VIDEO_TRACK)
6541 void HTMLMediaElement::configureTextTrackDisplay(TextTrackVisibilityCheckType checkType)
6542 {
6543     ALWAYS_LOG(LOGIDENTIFIER);
6544     ASSERT(m_textTracks);
6545 
6546     if (m_processingPreferenceChange)
6547         return;
6548 
6549     if (document().activeDOMObjectsAreStopped())
6550         return;
6551 
6552     bool haveVisibleTextTrack = false;
6553     for (unsigned i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
6554         if (m_textTracks-&gt;item(i)-&gt;mode() == TextTrack::Mode::Showing) {
6555             haveVisibleTextTrack = true;
6556             break;
6557         }
6558     }
6559 
6560     if (checkType == CheckTextTrackVisibility &amp;&amp; m_haveVisibleTextTrack == haveVisibleTextTrack) {
6561         updateActiveTextTrackCues(currentMediaTime());
6562         return;
6563     }
6564 
6565     m_haveVisibleTextTrack = haveVisibleTextTrack;
6566     m_closedCaptionsVisible = m_haveVisibleTextTrack;
6567 
6568 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6569     if (!m_haveVisibleTextTrack)
6570         return;
6571 
6572     ensureMediaControlsShadowRoot();
<a name="167" id="anc167"></a><span class="line-added">6573     updateTextTrackDisplay();</span>
6574 #else
6575     if (!m_haveVisibleTextTrack &amp;&amp; !hasMediaControls())
6576         return;
6577     if (!hasMediaControls() &amp;&amp; !createMediaControls())
6578         return;
6579 
6580     mediaControls()-&gt;changedClosedCaptionsVisibility();
6581 
6582     updateTextTrackDisplay();
6583     updateActiveTextTrackCues(currentMediaTime());
6584 #endif
6585 }
6586 
6587 void HTMLMediaElement::captionPreferencesChanged()
6588 {
6589     if (!isVideo())
6590         return;
6591 
6592     if (hasMediaControls())
6593         mediaControls()-&gt;textTrackPreferencesChanged();
6594 
6595 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
6596     if (m_mediaControlsHost)
<a name="168" id="anc168"></a><span class="line-modified">6597         m_mediaControlsHost-&gt;updateCaptionDisplaySizes(MediaControlsHost::ForceUpdate::Yes);</span>
6598 #endif
6599 
6600     if (m_player)
6601         m_player-&gt;tracksChanged();
6602 
6603     if (!document().page())
6604         return;
6605 
6606     CaptionUserPreferences::CaptionDisplayMode displayMode = document().page()-&gt;group().captionPreferences().captionDisplayMode();
6607     if (captionDisplayMode() == displayMode)
6608         return;
6609 
6610     m_captionDisplayMode = displayMode;
6611     setWebkitClosedCaptionsVisible(captionDisplayMode() == CaptionUserPreferences::AlwaysOn);
6612 }
6613 
6614 CaptionUserPreferences::CaptionDisplayMode HTMLMediaElement::captionDisplayMode()
6615 {
6616     if (!m_captionDisplayMode.hasValue()) {
6617         if (document().page())
6618             m_captionDisplayMode = document().page()-&gt;group().captionPreferences().captionDisplayMode();
6619         else
6620             m_captionDisplayMode = CaptionUserPreferences::Automatic;
6621     }
6622 
6623     return m_captionDisplayMode.value();
6624 }
6625 
6626 void HTMLMediaElement::markCaptionAndSubtitleTracksAsUnconfigured(ReconfigureMode mode)
6627 {
6628     if (!m_textTracks)
6629         return;
6630 
6631     INFO_LOG(LOGIDENTIFIER);
6632 
6633     // Mark all tracks as not &quot;configured&quot; so that configureTextTracks()
6634     // will reconsider which tracks to display in light of new user preferences
6635     // (e.g. default tracks should not be displayed if the user has turned off
6636     // captions and non-default tracks should be displayed based on language
6637     // preferences if the user has turned captions on).
6638     for (unsigned i = 0; i &lt; m_textTracks-&gt;length(); ++i) {
6639         auto&amp; track = *m_textTracks-&gt;item(i);
6640         auto kind = track.kind();
6641         if (kind == TextTrack::Kind::Subtitles || kind == TextTrack::Kind::Captions)
6642             track.setHasBeenConfigured(false);
6643     }
6644 
6645     m_processingPreferenceChange = true;
6646     m_configureTextTracksTask.cancelTask();
6647     if (mode == Immediately) {
6648         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // configureTextTracks calls methods that can trigger arbitrary DOM mutations.
6649         configureTextTracks();
6650     }
6651     else
6652         scheduleConfigureTextTracks();
6653 }
6654 
6655 #endif
6656 
6657 void HTMLMediaElement::createMediaPlayer()
6658 {
6659     INFO_LOG(LOGIDENTIFIER);
6660 
6661 #if ENABLE(WEB_AUDIO)
6662     if (m_audioSourceNode)
6663         m_audioSourceNode-&gt;lock();
6664 #endif
6665 
6666 #if ENABLE(MEDIA_SOURCE)
6667     detachMediaSource();
6668 #endif
6669 
6670 #if ENABLE(VIDEO_TRACK)
6671     forgetResourceSpecificTracks();
6672 #endif
6673 
6674 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6675     if (m_isPlayingToWirelessTarget)
6676         setIsPlayingToWirelessTarget(false);
6677 #endif
6678 
6679     m_player = MediaPlayer::create(*this);
6680     m_player-&gt;setBufferingPolicy(m_bufferingPolicy);
6681     schedulePlaybackControlsManagerUpdate();
6682 
6683 #if ENABLE(WEB_AUDIO)
6684     if (m_audioSourceNode) {
6685         // When creating the player, make sure its AudioSourceProvider knows about the MediaElementAudioSourceNode.
6686         if (audioSourceProvider())
6687             audioSourceProvider()-&gt;setClient(m_audioSourceNode);
6688 
6689         m_audioSourceNode-&gt;unlock();
6690     }
6691 #endif
6692 
6693 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
<a name="169" id="anc169"></a><span class="line-modified">6694     if (hasEventListeners(eventNames().webkitplaybacktargetavailabilitychangedEvent) || m_remote-&gt;hasAvailabilityCallbacks()) {</span>
6695         m_hasPlaybackTargetAvailabilityListeners = true;
6696         m_mediaSession-&gt;setHasPlaybackTargetAvailabilityListeners(true);
6697         enqueuePlaybackTargetAvailabilityChangedEvent(); // Ensure the event listener gets at least one event.
6698     }
6699 #endif
6700 
6701     updateSleepDisabling();
6702 }
6703 
6704 #if ENABLE(WEB_AUDIO)
<a name="170" id="anc170"></a><span class="line-added">6705 </span>
6706 void HTMLMediaElement::setAudioSourceNode(MediaElementAudioSourceNode* sourceNode)
6707 {
6708     m_audioSourceNode = sourceNode;
6709 
6710     if (audioSourceProvider())
6711         audioSourceProvider()-&gt;setClient(m_audioSourceNode);
6712 }
6713 
6714 AudioSourceProvider* HTMLMediaElement::audioSourceProvider()
6715 {
6716     if (m_player)
6717         return m_player-&gt;audioSourceProvider();
6718 
<a name="171" id="anc171"></a><span class="line-modified">6719     return nullptr;</span>
6720 }
<a name="172" id="anc172"></a><span class="line-added">6721 </span>
6722 #endif
6723 
6724 const String&amp; HTMLMediaElement::mediaGroup() const
6725 {
6726     return m_mediaGroup;
6727 }
6728 
6729 void HTMLMediaElement::setMediaGroup(const String&amp; group)
6730 {
6731     if (m_mediaGroup == group)
6732         return;
6733     m_mediaGroup = group;
6734 
6735     // When a media element is created with a mediagroup attribute, and when a media element&#39;s mediagroup
6736     // attribute is set, changed, or removed, the user agent must run the following steps:
6737     // 1. Let m [this] be the media element in question.
6738     // 2. Let m have no current media controller, if it currently has one.
6739     setController(nullptr);
6740 
6741     // 3. If m&#39;s mediagroup attribute is being removed, then abort these steps.
6742     if (group.isEmpty())
6743         return;
6744 
6745     // 4. If there is another media element whose Document is the same as m&#39;s Document (even if one or both
6746     // of these elements are not actually in the Document),
<a name="173" id="anc173"></a><span class="line-modified">6747     // FIXME: It does not seem OK that this algorithm iterates the media elements in a random order.</span>
<span class="line-modified">6748     document().forEachMediaElement([&amp;] (HTMLMediaElement&amp; element) {</span>



6749         // and which also has a mediagroup attribute, and whose mediagroup attribute has the same value as
6750         // the new value of m&#39;s mediagroup attribute,
<a name="174" id="anc174"></a><span class="line-modified">6751         if (&amp;element != this &amp;&amp; !controller() &amp;&amp; element.mediaGroup() == group) {</span>
6752             //  then let controller be that media element&#39;s current media controller.
<a name="175" id="anc175"></a><span class="line-modified">6753             setController(element.controller());</span>

6754         }
<a name="176" id="anc176"></a><span class="line-modified">6755     });</span>
6756 
6757     // Otherwise, let controller be a newly created MediaController.
<a name="177" id="anc177"></a><span class="line-modified">6758     if (!controller())</span>
<span class="line-added">6759         setController(MediaController::create(document()));</span>
6760 }
6761 
6762 MediaController* HTMLMediaElement::controller() const
6763 {
6764     return m_mediaController.get();
6765 }
6766 
6767 void HTMLMediaElement::setController(RefPtr&lt;MediaController&gt;&amp;&amp; controller)
6768 {
6769     if (m_mediaController)
6770         m_mediaController-&gt;removeMediaElement(*this);
6771 
6772     m_mediaController = WTFMove(controller);
6773 
6774     if (m_mediaController)
6775         m_mediaController-&gt;addMediaElement(*this);
6776 
6777     if (hasMediaControls())
6778         mediaControls()-&gt;setMediaController(m_mediaController ? m_mediaController.get() : static_cast&lt;MediaControllerInterface*&gt;(this));
6779 }
6780 
6781 void HTMLMediaElement::setControllerForBindings(MediaController* controller)
6782 {
6783     // 4.8.10.11.2 Media controllers: controller attribute.
6784     // On setting, it must first remove the element&#39;s mediagroup attribute, if any,
6785     setMediaGroup({ });
6786     // and then set the current media controller to the given value.
6787     setController(controller);
6788 }
6789 
6790 void HTMLMediaElement::updateMediaController()
6791 {
6792     if (m_mediaController)
6793         m_mediaController-&gt;reportControllerState();
6794 }
6795 
6796 bool HTMLMediaElement::isBlocked() const
6797 {
6798     // A media element is a blocked media element if its readyState attribute is in the
6799     // HAVE_NOTHING state, the HAVE_METADATA state, or the HAVE_CURRENT_DATA state,
6800     if (m_readyState &lt;= HAVE_CURRENT_DATA)
6801         return true;
6802 
6803     // or if the element has paused for user interaction.
6804     return pausedForUserInteraction();
6805 }
6806 
6807 bool HTMLMediaElement::isBlockedOnMediaController() const
6808 {
6809     if (!m_mediaController)
6810         return false;
6811 
6812     // A media element is blocked on its media controller if the MediaController is a blocked
6813     // media controller,
6814     if (m_mediaController-&gt;isBlocked())
6815         return true;
6816 
6817     // or if its media controller position is either before the media resource&#39;s earliest possible
6818     // position relative to the MediaController&#39;s timeline or after the end of the media resource
6819     // relative to the MediaController&#39;s timeline.
6820     double mediaControllerPosition = m_mediaController-&gt;currentTime();
6821     if (mediaControllerPosition &lt; 0 || mediaControllerPosition &gt; duration())
6822         return true;
6823 
6824     return false;
6825 }
6826 
6827 void HTMLMediaElement::prepareMediaFragmentURI()
6828 {
6829     MediaFragmentURIParser fragmentParser(m_currentSrc);
6830     MediaTime dur = durationMediaTime();
6831 
6832     MediaTime start = fragmentParser.startTime();
6833     if (start.isValid() &amp;&amp; start &gt; MediaTime::zeroTime()) {
6834         m_fragmentStartTime = start;
6835         if (m_fragmentStartTime &gt; dur)
6836             m_fragmentStartTime = dur;
6837     } else
6838         m_fragmentStartTime = MediaTime::invalidTime();
6839 
6840     MediaTime end = fragmentParser.endTime();
6841     if (end.isValid() &amp;&amp; end &gt; MediaTime::zeroTime() &amp;&amp; (!m_fragmentStartTime.isValid() || end &gt; m_fragmentStartTime)) {
6842         m_fragmentEndTime = end;
6843         if (m_fragmentEndTime &gt; dur)
6844             m_fragmentEndTime = dur;
6845     } else
6846         m_fragmentEndTime = MediaTime::invalidTime();
6847 
6848     if (m_fragmentStartTime.isValid() &amp;&amp; m_readyState &lt; HAVE_FUTURE_DATA)
6849         prepareToPlay();
6850 }
6851 
6852 void HTMLMediaElement::applyMediaFragmentURI()
6853 {
6854     if (m_fragmentStartTime.isValid()) {
6855         m_sentEndEvent = false;
6856         seek(m_fragmentStartTime);
6857     }
6858 }
6859 
6860 void HTMLMediaElement::updateSleepDisabling()
6861 {
6862     SleepType shouldDisableSleep = this-&gt;shouldDisableSleep();
6863     if (shouldDisableSleep == SleepType::None &amp;&amp; m_sleepDisabler)
6864         m_sleepDisabler = nullptr;
6865     else if (shouldDisableSleep != SleepType::None) {
6866         auto type = shouldDisableSleep == SleepType::Display ? PAL::SleepDisabler::Type::Display : PAL::SleepDisabler::Type::System;
6867         if (!m_sleepDisabler || m_sleepDisabler-&gt;type() != type)
6868             m_sleepDisabler = PAL::SleepDisabler::create(&quot;com.apple.WebCore: HTMLMediaElement playback&quot;, type);
6869     }
6870 
6871     if (m_player)
6872         m_player-&gt;setShouldDisableSleep(shouldDisableSleep == SleepType::Display);
6873 }
6874 
6875 #if ENABLE(MEDIA_STREAM)
6876 static inline bool isRemoteMediaStreamVideoTrack(RefPtr&lt;MediaStreamTrack&gt;&amp; item)
6877 {
6878     auto* track = item.get();
6879     return track-&gt;privateTrack().type() == RealtimeMediaSource::Type::Video &amp;&amp; !track-&gt;isCaptureTrack() &amp;&amp; !track-&gt;isCanvas();
6880 }
6881 #endif
6882 
6883 HTMLMediaElement::SleepType HTMLMediaElement::shouldDisableSleep() const
6884 {
6885 #if !PLATFORM(COCOA) &amp;&amp; !PLATFORM(GTK) &amp;&amp; !PLATFORM(WPE)
6886     return SleepType::None;
6887 #endif
6888     if (!m_player || m_player-&gt;paused() || loop())
6889         return SleepType::None;
6890 
6891 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
6892     // If the media is playing remotely, we can&#39;t know definitively whether it has audio or video tracks.
6893     if (m_isPlayingToWirelessTarget)
6894         return SleepType::System;
6895 #endif
6896 
6897     if (PlatformMediaSessionManager::sharedManager().processIsSuspended())
6898         return SleepType::None;
6899 
6900     bool shouldBeAbleToSleep = mediaType() != PlatformMediaSession::VideoAudio;
6901 #if ENABLE(MEDIA_STREAM)
6902     // Remote media stream video tracks may have their corresponding audio tracks being played outside of the media element. Let&#39;s ensure to not IDLE the screen in that case.
6903     // FIXME: We should check that audio is being/to be played. Ideally, we would come up with a media stream agnostic heuristisc.
6904     shouldBeAbleToSleep = shouldBeAbleToSleep &amp;&amp; !(m_mediaStreamSrcObject &amp;&amp; WTF::anyOf(m_mediaStreamSrcObject-&gt;getTracks(), isRemoteMediaStreamVideoTrack));
6905 #endif
6906 
6907     if (shouldBeAbleToSleep)
6908         return SleepType::None;
6909 
6910     if (m_elementIsHidden)
6911         return SleepType::System;
6912 
6913     return SleepType::Display;
6914 }
6915 
6916 String HTMLMediaElement::mediaPlayerReferrer() const
6917 {
6918     RefPtr&lt;Frame&gt; frame = document().frame();
6919     if (!frame)
6920         return String();
6921 
6922     return SecurityPolicy::generateReferrerHeader(document().referrerPolicy(), m_currentSrc, frame-&gt;loader().outgoingReferrer());
6923 }
6924 
6925 String HTMLMediaElement::mediaPlayerUserAgent() const
6926 {
6927     RefPtr&lt;Frame&gt; frame = document().frame();
6928     if (!frame)
6929         return String();
6930 
6931     return frame-&gt;loader().userAgent(m_currentSrc);
6932 }
6933 
6934 #if ENABLE(AVF_CAPTIONS)
6935 
6936 static inline PlatformTextTrack::TrackKind toPlatform(TextTrack::Kind kind)
6937 {
6938     switch (kind) {
6939     case TextTrack::Kind::Captions:
6940         return PlatformTextTrack::Caption;
6941     case TextTrack::Kind::Chapters:
6942         return PlatformTextTrack::Chapter;
6943     case TextTrack::Kind::Descriptions:
6944         return PlatformTextTrack::Description;
6945     case TextTrack::Kind::Forced:
6946         return PlatformTextTrack::Forced;
6947     case TextTrack::Kind::Metadata:
6948         return PlatformTextTrack::MetaData;
6949     case TextTrack::Kind::Subtitles:
6950         return PlatformTextTrack::Subtitle;
6951     }
6952     ASSERT_NOT_REACHED();
6953     return PlatformTextTrack::Caption;
6954 }
6955 
6956 static inline PlatformTextTrack::TrackMode toPlatform(TextTrack::Mode mode)
6957 {
6958     switch (mode) {
6959     case TextTrack::Mode::Disabled:
6960         return PlatformTextTrack::Disabled;
6961     case TextTrack::Mode::Hidden:
6962         return PlatformTextTrack::Hidden;
6963     case TextTrack::Mode::Showing:
6964         return PlatformTextTrack::Showing;
6965     }
6966     ASSERT_NOT_REACHED();
6967     return PlatformTextTrack::Disabled;
6968 }
6969 
6970 Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; HTMLMediaElement::outOfBandTrackSources()
6971 {
6972     Vector&lt;RefPtr&lt;PlatformTextTrack&gt;&gt; outOfBandTrackSources;
6973     for (auto&amp; trackElement : childrenOfType&lt;HTMLTrackElement&gt;(*this)) {
6974         URL url = trackElement.getNonEmptyURLAttribute(srcAttr);
6975         if (url.isEmpty())
6976             continue;
6977 
6978         if (!isAllowedToLoadMediaURL(*this, url, trackElement.isInUserAgentShadowTree()))
6979             continue;
6980 
6981         auto&amp; track = trackElement.track();
6982         auto kind = track.kind();
6983 
6984         // FIXME: The switch statement below preserves existing behavior where we ignore chapters and metadata tracks.
6985         // If we confirm this behavior is valuable, we should remove this comment. Otherwise, remove both comment and switch.
6986         switch (kind) {
6987         case TextTrack::Kind::Captions:
6988         case TextTrack::Kind::Descriptions:
6989         case TextTrack::Kind::Forced:
6990         case TextTrack::Kind::Subtitles:
6991             break;
6992         case TextTrack::Kind::Chapters:
6993         case TextTrack::Kind::Metadata:
6994             continue;
6995         }
6996 
6997         outOfBandTrackSources.append(PlatformTextTrack::createOutOfBand(trackElement.label(), trackElement.srclang(), url.string(), toPlatform(track.mode()), toPlatform(kind), track.uniqueId(), trackElement.isDefault()));
6998     }
6999 
7000     return outOfBandTrackSources;
7001 }
7002 
7003 #endif
7004 
7005 void HTMLMediaElement::mediaPlayerEnterFullscreen()
7006 {
7007     enterFullscreen();
7008 }
7009 
7010 void HTMLMediaElement::mediaPlayerExitFullscreen()
7011 {
7012     exitFullscreen();
7013 }
7014 
7015 bool HTMLMediaElement::mediaPlayerIsFullscreen() const
7016 {
7017     return isFullscreen();
7018 }
7019 
7020 bool HTMLMediaElement::mediaPlayerIsFullscreenPermitted() const
7021 {
7022     return m_mediaSession-&gt;fullscreenPermitted();
7023 }
7024 
7025 bool HTMLMediaElement::mediaPlayerIsVideo() const
7026 {
7027     return isVideo();
7028 }
7029 
7030 LayoutRect HTMLMediaElement::mediaPlayerContentBoxRect() const
7031 {
7032     auto* renderer = this-&gt;renderer();
7033     if (!renderer)
7034         return { };
7035     return renderer-&gt;enclosingBox().contentBoxRect();
7036 }
7037 
7038 float HTMLMediaElement::mediaPlayerContentsScale() const
7039 {
7040     if (auto page = document().page())
7041         return page-&gt;pageScaleFactor() * page-&gt;deviceScaleFactor();
7042     return 1;
7043 }
7044 
<a name="178" id="anc178"></a>





7045 void HTMLMediaElement::mediaPlayerPause()
7046 {
7047     pause();
7048 }
7049 
7050 void HTMLMediaElement::mediaPlayerPlay()
7051 {
7052     play();
7053 }
7054 
7055 bool HTMLMediaElement::mediaPlayerPlatformVolumeConfigurationRequired() const
7056 {
7057     return !m_volumeInitialized;
7058 }
7059 
<a name="179" id="anc179"></a>




7060 bool HTMLMediaElement::mediaPlayerIsLooping() const
7061 {
7062     return loop();
7063 }
7064 
7065 CachedResourceLoader* HTMLMediaElement::mediaPlayerCachedResourceLoader()
7066 {
7067     return &amp;document().cachedResourceLoader();
7068 }
7069 
7070 RefPtr&lt;PlatformMediaResourceLoader&gt; HTMLMediaElement::mediaPlayerCreateResourceLoader()
7071 {
7072     auto mediaResourceLoader = adoptRef(*new MediaResourceLoader(document(), *this, crossOrigin()));
7073 
7074     m_lastMediaResourceLoaderForTesting = makeWeakPtr(mediaResourceLoader.get());
7075 
7076     return mediaResourceLoader;
7077 }
7078 
7079 const MediaResourceLoader* HTMLMediaElement::lastMediaResourceLoaderForTesting() const
7080 {
7081     return m_lastMediaResourceLoaderForTesting.get();
7082 }
7083 
7084 bool HTMLMediaElement::mediaPlayerShouldUsePersistentCache() const
7085 {
7086     if (Page* page = document().page())
<a name="180" id="anc180"></a><span class="line-modified">7087         return !page-&gt;usesEphemeralSession() &amp;&amp; !page-&gt;isResourceCachingDisabledByWebInspector();</span>
7088 
7089     return false;
7090 }
7091 
7092 const String&amp; HTMLMediaElement::mediaPlayerMediaCacheDirectory() const
7093 {
7094     return mediaCacheDirectory();
7095 }
7096 
7097 String HTMLMediaElement::sourceApplicationIdentifier() const
7098 {
7099     if (RefPtr&lt;Frame&gt; frame = document().frame()) {
7100         if (NetworkingContext* networkingContext = frame-&gt;loader().networkingContext())
7101             return networkingContext-&gt;sourceApplicationIdentifier();
7102     }
7103     return emptyString();
7104 }
7105 
7106 Vector&lt;String&gt; HTMLMediaElement::mediaPlayerPreferredAudioCharacteristics() const
7107 {
<a name="181" id="anc181"></a><span class="line-added">7108 #if ENABLE(VIDEO_TRACK)</span>
7109     if (Page* page = document().page())
7110         return page-&gt;group().captionPreferences().preferredAudioCharacteristics();
<a name="182" id="anc182"></a><span class="line-added">7111 #endif</span>
7112     return Vector&lt;String&gt;();
7113 }
7114 
7115 #if PLATFORM(IOS_FAMILY)
<a name="183" id="anc183"></a><span class="line-added">7116 </span>
7117 String HTMLMediaElement::mediaPlayerNetworkInterfaceName() const
7118 {
7119     return DeprecatedGlobalSettings::networkInterfaceName();
7120 }
7121 
7122 bool HTMLMediaElement::mediaPlayerGetRawCookies(const URL&amp; url, Vector&lt;Cookie&gt;&amp; cookies) const
7123 {
7124     if (auto* page = document().page())
7125         return page-&gt;cookieJar().getRawCookies(document(), url, cookies);
7126     return false;
7127 }
<a name="184" id="anc184"></a>
7128 
<a name="185" id="anc185"></a><span class="line-modified">7129 #endif</span>



7130 
7131 void HTMLMediaElement::mediaPlayerEngineFailedToLoad() const
7132 {
7133     if (!m_player)
7134         return;
7135 
7136     if (auto* page = document().page())
7137         page-&gt;diagnosticLoggingClient().logDiagnosticMessageWithValue(DiagnosticLoggingKeys::engineFailedToLoadKey(), m_player-&gt;engineDescription(), m_player-&gt;platformErrorCode(), 4, ShouldSample::No);
7138 }
7139 
7140 double HTMLMediaElement::mediaPlayerRequestedPlaybackRate() const
7141 {
7142     return potentiallyPlaying() ? requestedPlaybackRate() : 0;
7143 }
7144 
7145 const Vector&lt;ContentType&gt;&amp; HTMLMediaElement::mediaContentTypesRequiringHardwareSupport() const
7146 {
7147     return document().settings().mediaContentTypesRequiringHardwareSupport();
7148 }
7149 
7150 bool HTMLMediaElement::mediaPlayerShouldCheckHardwareSupport() const
7151 {
7152     if (!document().settings().allowMediaContentTypesRequiringHardwareSupportAsFallback())
7153         return true;
7154 
7155     if (m_loadState == LoadingFromSourceElement &amp;&amp; m_currentSourceNode &amp;&amp; !m_nextChildNodeToConsider)
7156         return false;
7157 
7158     if (m_loadState == LoadingFromSrcAttr)
7159         return false;
7160 
7161     return true;
7162 }
7163 
7164 #if USE(GSTREAMER)
7165 void HTMLMediaElement::requestInstallMissingPlugins(const String&amp; details, const String&amp; description, MediaPlayerRequestInstallMissingPluginsCallback&amp; callback)
7166 {
7167     if (!document().page())
7168         return;
7169 
7170     document().page()-&gt;chrome().client().requestInstallMissingMediaPlugins(details, description, callback);
7171 }
7172 #endif
7173 
7174 void HTMLMediaElement::removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::BehaviorRestrictions mask)
7175 {
7176     MediaElementSession::BehaviorRestrictions restrictionsToRemove = mask &amp;
7177         (MediaElementSession::RequireUserGestureForLoad
7178 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7179         | MediaElementSession::RequireUserGestureToShowPlaybackTargetPicker
7180         | MediaElementSession::RequireUserGestureToAutoplayToExternalDevice
7181 #endif
7182         | MediaElementSession::RequireUserGestureForVideoRateChange
7183         | MediaElementSession::RequireUserGestureForAudioRateChange
7184         | MediaElementSession::RequireUserGestureForFullscreen
7185         | MediaElementSession::RequireUserGestureForVideoDueToLowPowerMode
7186         | MediaElementSession::InvisibleAutoplayNotPermitted
7187         | MediaElementSession::RequireUserGestureToControlControlsManager);
7188 
7189     m_removedBehaviorRestrictionsAfterFirstUserGesture = true;
7190 
7191     m_mediaSession-&gt;removeBehaviorRestriction(restrictionsToRemove);
7192     document().topDocument().noteUserInteractionWithMediaElement();
7193 }
7194 
7195 void HTMLMediaElement::updateRateChangeRestrictions()
7196 {
7197     const auto&amp; document = this-&gt;document();
7198     if (!document.ownerElement() &amp;&amp; document.isMediaDocument())
7199         return;
7200 
7201     const auto&amp; topDocument = document.topDocument();
7202     if (topDocument.videoPlaybackRequiresUserGesture())
7203         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoRateChange);
7204     else
7205         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureForVideoRateChange);
7206 
7207     if (topDocument.audioPlaybackRequiresUserGesture())
7208         m_mediaSession-&gt;addBehaviorRestriction(MediaElementSession::RequireUserGestureForAudioRateChange);
7209     else
7210         m_mediaSession-&gt;removeBehaviorRestriction(MediaElementSession::RequireUserGestureForAudioRateChange);
7211 }
7212 
7213 RefPtr&lt;VideoPlaybackQuality&gt; HTMLMediaElement::getVideoPlaybackQuality()
7214 {
7215     RefPtr&lt;DOMWindow&gt; domWindow = document().domWindow();
7216     double timestamp = domWindow ? 1000 * domWindow-&gt;nowTimestamp() : 0;
7217 
7218     auto metrics = m_player ? m_player-&gt;videoPlaybackQualityMetrics() : WTF::nullopt;
7219     if (!metrics)
7220         return VideoPlaybackQuality::create(timestamp, { });
7221 
7222 #if ENABLE(MEDIA_SOURCE)
7223     metrics.value().totalVideoFrames += m_droppedVideoFrames;
7224     metrics.value().droppedVideoFrames += m_droppedVideoFrames;
7225 #endif
7226 
7227     return VideoPlaybackQuality::create(timestamp, metrics.value());
7228 }
7229 
7230 #if ENABLE(MEDIA_CONTROLS_SCRIPT)
7231 DOMWrapperWorld&amp; HTMLMediaElement::ensureIsolatedWorld()
7232 {
7233     if (!m_isolatedWorld)
<a name="186" id="anc186"></a><span class="line-modified">7234         m_isolatedWorld = DOMWrapperWorld::create(commonVM(), DOMWrapperWorld::Type::Internal, makeString(&quot;Media Controls (&quot;, localName(), &#39;)&#39;));</span>
7235     return *m_isolatedWorld;
7236 }
7237 
7238 bool HTMLMediaElement::ensureMediaControlsInjectedScript()
7239 {
7240     INFO_LOG(LOGIDENTIFIER);
7241 
7242     Page* page = document().page();
7243     if (!page)
7244         return false;
7245 
7246     String mediaControlsScript = RenderTheme::singleton().mediaControlsScript();
7247     if (!mediaControlsScript.length())
7248         return false;
7249 
<a name="187" id="anc187"></a><span class="line-modified">7250     return setupAndCallJS([mediaControlsScript](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp; scriptController, DOMWrapperWorld&amp; world) {</span>
7251         auto&amp; vm = globalObject.vm();
7252         auto scope = DECLARE_CATCH_SCOPE(vm);
7253 
<a name="188" id="anc188"></a><span class="line-modified">7254         auto functionValue = globalObject.get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;createControls&quot;));</span>
7255         if (functionValue.isFunction(vm))
7256             return true;
7257 
7258 #ifndef NDEBUG
7259         // Setting a scriptURL allows the source to be debuggable in the inspector.
7260         URL scriptURL = URL({ }, &quot;mediaControlsScript&quot;_s);
7261 #else
7262         URL scriptURL;
7263 #endif
<a name="189" id="anc189"></a><span class="line-modified">7264         scriptController.evaluateInWorldIgnoringException(ScriptSourceCode(mediaControlsScript, WTFMove(scriptURL)), world);</span>
7265         if (UNLIKELY(scope.exception())) {
7266             scope.clearException();
7267             return false;
7268         }
7269 
7270         return true;
7271     });
7272 }
7273 
7274 void HTMLMediaElement::updatePageScaleFactorJSProperty()
7275 {
7276     Page* page = document().page();
7277     if (!page)
7278         return;
7279 
7280     setControllerJSProperty(&quot;pageScaleFactor&quot;, JSC::jsNumber(page-&gt;pageScaleFactor()));
7281 }
7282 
7283 void HTMLMediaElement::updateUsesLTRUserInterfaceLayoutDirectionJSProperty()
7284 {
7285     Page* page = document().page();
7286     if (!page)
7287         return;
7288 
7289     bool usesLTRUserInterfaceLayoutDirectionProperty = page-&gt;userInterfaceLayoutDirection() == UserInterfaceLayoutDirection::LTR;
7290     setControllerJSProperty(&quot;usesLTRUserInterfaceLayoutDirection&quot;, JSC::jsBoolean(usesLTRUserInterfaceLayoutDirectionProperty));
7291 }
7292 
7293 void HTMLMediaElement::setControllerJSProperty(const char* propertyName, JSC::JSValue propertyValue)
7294 {
<a name="190" id="anc190"></a><span class="line-modified">7295     setupAndCallJS([this, propertyName, propertyValue](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
7296         auto&amp; vm = globalObject.vm();
<a name="191" id="anc191"></a><span class="line-modified">7297         auto controllerValue = controllerJSValue(lexicalGlobalObject, globalObject, *this);</span>
7298         if (controllerValue.isNull())
7299             return false;
7300 
7301         JSC::PutPropertySlot propertySlot(controllerValue);
<a name="192" id="anc192"></a><span class="line-modified">7302         auto* controllerObject = controllerValue.toObject(&amp;lexicalGlobalObject);</span>
7303         if (!controllerObject)
7304             return false;
7305 
<a name="193" id="anc193"></a><span class="line-modified">7306         controllerObject-&gt;methodTable(vm)-&gt;put(controllerObject, &amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, propertyName), propertyValue, propertySlot);</span>
7307 
7308         return true;
7309     });
7310 }
7311 
7312 void HTMLMediaElement::didAddUserAgentShadowRoot(ShadowRoot&amp; root)
7313 {
7314     INFO_LOG(LOGIDENTIFIER);
7315 
7316     if (!ensureMediaControlsInjectedScript())
7317         return;
7318 
<a name="194" id="anc194"></a><span class="line-modified">7319     setupAndCallJS([this, &amp;root](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
7320         auto&amp; vm = globalObject.vm();
7321         auto scope = DECLARE_CATCH_SCOPE(vm);
7322 
7323         // The media controls script must provide a method with the following details.
7324         // Name: createControls
7325         // Parameters:
7326         //     1. The ShadowRoot element that will hold the controls.
7327         //     2. This object (and HTMLMediaElement).
7328         //     3. The MediaControlsHost object.
7329         // Return value:
7330         //     A reference to the created media controller instance.
7331 
<a name="195" id="anc195"></a><span class="line-modified">7332         auto functionValue = globalObject.get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;createControls&quot;));</span>
7333         if (functionValue.isUndefinedOrNull())
7334             return false;
7335 
7336         if (!m_mediaControlsHost)
7337             m_mediaControlsHost = MediaControlsHost::create(this);
7338 
<a name="196" id="anc196"></a><span class="line-modified">7339         auto mediaJSWrapper = toJS(&amp;lexicalGlobalObject, &amp;globalObject, *this);</span>
<span class="line-modified">7340         auto mediaControlsHostJSWrapper = toJS(&amp;lexicalGlobalObject, &amp;globalObject, *m_mediaControlsHost);</span>
7341 
7342         JSC::MarkedArgumentBuffer argList;
<a name="197" id="anc197"></a><span class="line-modified">7343         argList.append(toJS(&amp;lexicalGlobalObject, &amp;globalObject, root));</span>
7344         argList.append(mediaJSWrapper);
7345         argList.append(mediaControlsHostJSWrapper);
7346         ASSERT(!argList.hasOverflowed());
7347 
<a name="198" id="anc198"></a><span class="line-modified">7348         auto* function = functionValue.toObject(&amp;lexicalGlobalObject);</span>
7349         scope.assertNoException();
7350         JSC::CallData callData;
7351         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7352         if (callType == JSC::CallType::None)
7353             return false;
7354 
<a name="199" id="anc199"></a><span class="line-modified">7355         auto controllerValue = JSC::call(&amp;lexicalGlobalObject, function, callType, callData, &amp;globalObject, argList);</span>
7356         scope.clearException();
7357         auto* controllerObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, controllerValue);
7358         if (!controllerObject)
7359             return false;
7360 
7361         // Connect the Media, MediaControllerHost, and Controller so the GC knows about their relationship
<a name="200" id="anc200"></a><span class="line-modified">7362         auto* mediaJSWrapperObject = mediaJSWrapper.toObject(&amp;lexicalGlobalObject);</span>
7363         scope.assertNoException();
7364         auto controlsHost = JSC::Identifier::fromString(vm, &quot;controlsHost&quot;);
7365 
<a name="201" id="anc201"></a><span class="line-modified">7366         ASSERT(!mediaJSWrapperObject-&gt;hasProperty(&amp;lexicalGlobalObject, controlsHost));</span>
7367 
7368         mediaJSWrapperObject-&gt;putDirect(vm, controlsHost, mediaControlsHostJSWrapper, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);
7369 
7370         auto* mediaControlsHostJSWrapperObject = JSC::jsDynamicCast&lt;JSC::JSObject*&gt;(vm, mediaControlsHostJSWrapper);
7371         if (!mediaControlsHostJSWrapperObject)
7372             return false;
7373 
7374         auto controller = JSC::Identifier::fromString(vm, &quot;controller&quot;);
7375 
<a name="202" id="anc202"></a><span class="line-modified">7376         ASSERT(!controllerObject-&gt;hasProperty(&amp;lexicalGlobalObject, controller));</span>
7377 
7378         mediaControlsHostJSWrapperObject-&gt;putDirect(vm, controller, controllerValue, JSC::PropertyAttribute::DontDelete | JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);
7379 
7380         updatePageScaleFactorJSProperty();
7381         updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
7382 
7383         if (UNLIKELY(scope.exception()))
7384             scope.clearException();
7385 
7386         return true;
7387     });
7388 }
7389 
7390 void HTMLMediaElement::setMediaControlsDependOnPageScaleFactor(bool dependsOnPageScale)
7391 {
7392     INFO_LOG(LOGIDENTIFIER, dependsOnPageScale);
7393 
7394     if (document().settings().mediaControlsScaleWithPageZoom()) {
7395         INFO_LOG(LOGIDENTIFIER, &quot;forced to false by Settings value&quot;);
7396         m_mediaControlsDependOnPageScaleFactor = false;
7397         return;
7398     }
7399 
<a name="203" id="anc203"></a>


7400     m_mediaControlsDependOnPageScaleFactor = dependsOnPageScale;
<a name="204" id="anc204"></a>




7401 }
7402 
7403 void HTMLMediaElement::updateMediaControlsAfterPresentationModeChange()
7404 {
7405     // Don&#39;t execute script if the controls script hasn&#39;t been injected yet, or we have
7406     // stopped/suspended the object.
7407     if (!m_mediaControlsHost || document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped())
7408         return;
7409 
7410     if (RuntimeEnabledFeatures::sharedFeatures().modernMediaControlsEnabled())
7411         return;
7412 
<a name="205" id="anc205"></a><span class="line-modified">7413     setupAndCallJS([this](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
7414         auto&amp; vm = globalObject.vm();
7415         auto scope = DECLARE_THROW_SCOPE(vm);
7416 
<a name="206" id="anc206"></a><span class="line-modified">7417         auto controllerValue = controllerJSValue(lexicalGlobalObject, globalObject, *this);</span>
<span class="line-modified">7418         auto* controllerObject = controllerValue.toObject(&amp;lexicalGlobalObject);</span>
7419 
7420         RETURN_IF_EXCEPTION(scope, false);
7421 
<a name="207" id="anc207"></a><span class="line-modified">7422         auto functionValue = controllerObject-&gt;get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;handlePresentationModeChange&quot;));</span>
7423         if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
7424             return false;
7425 
<a name="208" id="anc208"></a><span class="line-modified">7426         auto* function = functionValue.toObject(&amp;lexicalGlobalObject);</span>
7427         scope.assertNoException();
7428         JSC::CallData callData;
7429         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7430         if (callType == JSC::CallType::None)
7431             return false;
7432 
7433         JSC::MarkedArgumentBuffer argList;
7434         ASSERT(!argList.hasOverflowed());
<a name="209" id="anc209"></a><span class="line-modified">7435         JSC::call(&amp;lexicalGlobalObject, function, callType, callData, controllerObject, argList);</span>
7436 
7437         return true;
7438     });
7439 }
7440 
7441 void HTMLMediaElement::pageScaleFactorChanged()
7442 {
<a name="210" id="anc210"></a><span class="line-modified">7443     if (m_mediaControlsDependOnPageScaleFactor)</span>
<span class="line-added">7444         updatePageScaleFactorJSProperty();</span>
7445 }
7446 
7447 void HTMLMediaElement::userInterfaceLayoutDirectionChanged()
7448 {
7449     updateUsesLTRUserInterfaceLayoutDirectionJSProperty();
7450 }
7451 
7452 String HTMLMediaElement::getCurrentMediaControlsStatus()
7453 {
7454     ensureMediaControlsShadowRoot();
7455 
7456     String status;
<a name="211" id="anc211"></a><span class="line-modified">7457     setupAndCallJS([this, &amp;status](JSDOMGlobalObject&amp; globalObject, JSC::JSGlobalObject&amp; lexicalGlobalObject, ScriptController&amp;, DOMWrapperWorld&amp;) {</span>
7458         auto&amp; vm = globalObject.vm();
7459         auto scope = DECLARE_THROW_SCOPE(vm);
7460 
<a name="212" id="anc212"></a><span class="line-modified">7461         auto controllerValue = controllerJSValue(lexicalGlobalObject, globalObject, *this);</span>
<span class="line-modified">7462         auto* controllerObject = controllerValue.toObject(&amp;lexicalGlobalObject);</span>
7463 
7464         RETURN_IF_EXCEPTION(scope, false);
7465 
<a name="213" id="anc213"></a><span class="line-modified">7466         auto functionValue = controllerObject-&gt;get(&amp;lexicalGlobalObject, JSC::Identifier::fromString(vm, &quot;getCurrentControlsStatus&quot;));</span>
7467         if (UNLIKELY(scope.exception()) || functionValue.isUndefinedOrNull())
7468             return false;
7469 
<a name="214" id="anc214"></a><span class="line-modified">7470         auto* function = functionValue.toObject(&amp;lexicalGlobalObject);</span>
7471         scope.assertNoException();
7472         JSC::CallData callData;
7473         auto callType = function-&gt;methodTable(vm)-&gt;getCallData(function, callData);
7474         JSC::MarkedArgumentBuffer argList;
7475         ASSERT(!argList.hasOverflowed());
7476         if (callType == JSC::CallType::None)
7477             return false;
7478 
<a name="215" id="anc215"></a><span class="line-modified">7479         auto outputValue = JSC::call(&amp;lexicalGlobalObject, function, callType, callData, controllerObject, argList);</span>
7480 
7481         RETURN_IF_EXCEPTION(scope, false);
7482 
<a name="216" id="anc216"></a><span class="line-modified">7483         status = outputValue.getString(&amp;lexicalGlobalObject);</span>
7484         return true;
7485     });
7486 
7487     return status;
7488 }
7489 #endif // ENABLE(MEDIA_CONTROLS_SCRIPT)
7490 
7491 unsigned long long HTMLMediaElement::fileSize() const
7492 {
7493     if (m_player)
7494         return m_player-&gt;fileSize();
7495 
7496     return 0;
7497 }
7498 
7499 PlatformMediaSession::MediaType HTMLMediaElement::mediaType() const
7500 {
7501     if (m_player &amp;&amp; m_readyState &gt;= HAVE_METADATA) {
7502         if (hasVideo() &amp;&amp; hasAudio() &amp;&amp; !muted())
7503             return PlatformMediaSession::VideoAudio;
7504         return hasVideo() ? PlatformMediaSession::Video : PlatformMediaSession::Audio;
7505     }
7506 
7507     return presentationType();
7508 }
7509 
7510 PlatformMediaSession::MediaType HTMLMediaElement::presentationType() const
7511 {
7512     if (hasTagName(HTMLNames::videoTag))
7513         return muted() ? PlatformMediaSession::Video : PlatformMediaSession::VideoAudio;
7514 
7515     return PlatformMediaSession::Audio;
7516 }
7517 
7518 PlatformMediaSession::DisplayType HTMLMediaElement::displayType() const
7519 {
7520     if (m_videoFullscreenMode == VideoFullscreenModeStandard)
7521         return PlatformMediaSession::Fullscreen;
7522     if (m_videoFullscreenMode &amp; VideoFullscreenModePictureInPicture)
7523         return PlatformMediaSession::Optimized;
7524     if (m_videoFullscreenMode == VideoFullscreenModeNone)
7525         return PlatformMediaSession::Normal;
7526 
7527     ASSERT_NOT_REACHED();
7528     return PlatformMediaSession::Normal;
7529 }
7530 
7531 PlatformMediaSession::CharacteristicsFlags HTMLMediaElement::characteristics() const
7532 {
7533     if (m_readyState &lt; HAVE_METADATA)
7534         return PlatformMediaSession::HasNothing;
7535 
7536     PlatformMediaSession::CharacteristicsFlags state = PlatformMediaSession::HasNothing;
7537     if (isVideo() &amp;&amp; hasVideo())
7538         state |= PlatformMediaSession::HasVideo;
7539     if (this-&gt;hasAudio())
7540         state |= PlatformMediaSession::HasAudio;
7541 
7542     return state;
7543 }
7544 
7545 bool HTMLMediaElement::canProduceAudio() const
7546 {
7547 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7548     // Because the remote target could unmute playback without notifying us, we must assume
7549     // that we may be playing audio.
7550     if (m_isPlayingToWirelessTarget)
7551         return true;
7552 #endif
7553 
7554     if (muted())
7555         return false;
7556 
<a name="217" id="anc217"></a><span class="line-modified">7557     if (m_player &amp;&amp; m_readyState &gt;= HAVE_METADATA)</span>
<span class="line-added">7558         return hasAudio();</span>
<span class="line-added">7559 </span>
<span class="line-added">7560     return hasEverHadAudio();</span>
7561 }
7562 
7563 bool HTMLMediaElement::isSuspended() const
7564 {
7565     return document().activeDOMObjectsAreSuspended() || document().activeDOMObjectsAreStopped();
7566 }
7567 
7568 #if ENABLE(MEDIA_SOURCE)
7569 size_t HTMLMediaElement::maximumSourceBufferSize(const SourceBuffer&amp; buffer) const
7570 {
7571     return m_mediaSession-&gt;maximumMediaSourceBufferSize(buffer);
7572 }
7573 #endif
7574 
7575 void HTMLMediaElement::suspendPlayback()
7576 {
7577     INFO_LOG(LOGIDENTIFIER, &quot;paused = &quot;, paused());
7578     if (!paused())
7579         pause();
7580 }
7581 
7582 void HTMLMediaElement::resumeAutoplaying()
7583 {
7584     INFO_LOG(LOGIDENTIFIER, &quot;paused = &quot;, paused());
7585     m_autoplaying = true;
7586 
7587     if (canTransitionFromAutoplayToPlay())
7588         play();
7589 }
7590 
7591 void HTMLMediaElement::mayResumePlayback(bool shouldResume)
7592 {
7593     INFO_LOG(LOGIDENTIFIER, &quot;paused = &quot;, paused());
7594     if (paused() &amp;&amp; shouldResume)
7595         play();
7596 }
7597 
7598 String HTMLMediaElement::mediaSessionTitle() const
7599 {
7600     if (!document().page() || document().page()-&gt;usesEphemeralSession())
7601         return emptyString();
7602 
7603     auto title = String(attributeWithoutSynchronization(titleAttr)).stripWhiteSpace().simplifyWhiteSpace();
7604     if (!title.isEmpty())
7605         return title;
7606 
7607     title = document().title().stripWhiteSpace().simplifyWhiteSpace();
7608     if (!title.isEmpty())
7609         return title;
7610 
7611     title = m_currentSrc.host().toString();
<a name="218" id="anc218"></a><span class="line-modified">7612 #if PLATFORM(COCOA)</span>
7613     if (!title.isEmpty())
7614         title = decodeHostName(title);
7615 #endif
7616     if (!title.isEmpty()) {
7617         auto domain = RegistrableDomain { m_currentSrc };
7618         if (!domain.isEmpty())
7619             title = domain.string();
7620     }
7621 
7622     return title;
7623 }
7624 
7625 uint64_t HTMLMediaElement::mediaSessionUniqueIdentifier() const
7626 {
7627     auto&amp; url = m_currentSrc.string();
7628     return url.impl() ? url.impl()-&gt;hash() : 0;
7629 }
7630 
7631 void HTMLMediaElement::didReceiveRemoteControlCommand(PlatformMediaSession::RemoteControlCommandType command, const PlatformMediaSession::RemoteCommandArgument* argument)
7632 {
7633     INFO_LOG(LOGIDENTIFIER, command);
7634 
7635     UserGestureIndicator remoteControlUserGesture(ProcessingUserGesture, &amp;document());
7636     switch (command) {
7637     case PlatformMediaSession::PlayCommand:
7638         play();
7639         break;
7640     case PlatformMediaSession::StopCommand:
7641     case PlatformMediaSession::PauseCommand:
7642         pause();
7643         break;
7644     case PlatformMediaSession::TogglePlayPauseCommand:
7645         canPlay() ? play() : pause();
7646         break;
7647     case PlatformMediaSession::BeginSeekingBackwardCommand:
7648         beginScanning(Backward);
7649         break;
7650     case PlatformMediaSession::BeginSeekingForwardCommand:
7651         beginScanning(Forward);
7652         break;
7653     case PlatformMediaSession::EndSeekingBackwardCommand:
7654     case PlatformMediaSession::EndSeekingForwardCommand:
7655         endScanning();
7656         break;
7657     case PlatformMediaSession::SeekToPlaybackPositionCommand:
7658         ASSERT(argument);
7659         if (argument)
7660             handleSeekToPlaybackPosition(argument-&gt;asDouble);
7661         break;
7662     default:
7663         { } // Do nothing
7664     }
7665 }
7666 
7667 bool HTMLMediaElement::supportsSeeking() const
7668 {
7669     return !document().quirks().needsSeekingSupportDisabled() &amp;&amp; !isLiveStream();
7670 }
7671 
7672 bool HTMLMediaElement::shouldOverrideBackgroundPlaybackRestriction(PlatformMediaSession::InterruptionType type) const
7673 {
7674     if (type == PlatformMediaSession::EnteringBackground) {
7675         if (isPlayingToExternalTarget()) {
7676             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToExternalTarget() is true&quot;);
7677             return true;
7678         }
7679         if (PlatformMediaSessionManager::sharedManager().isPlayingToAutomotiveHeadUnit()) {
7680             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToAutomotiveHeadUnit() is true&quot;);
7681             return true;
7682         }
7683         if (m_videoFullscreenMode &amp; VideoFullscreenModePictureInPicture)
7684             return true;
7685 #if PLATFORM(MAC) &amp;&amp; ENABLE(VIDEO_PRESENTATION_MODE)
7686         if (((m_videoFullscreenMode == VideoFullscreenModeStandard) || m_videoFullscreenStandby) &amp;&amp; supportsPictureInPicture() &amp;&amp; isPlaying())
7687             return true;
7688 #endif
7689     } else if (type == PlatformMediaSession::SuspendedUnderLock) {
7690         if (isPlayingToExternalTarget()) {
7691             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToExternalTarget() is true&quot;);
7692             return true;
7693         }
7694         if (PlatformMediaSessionManager::sharedManager().isPlayingToAutomotiveHeadUnit()) {
7695             INFO_LOG(LOGIDENTIFIER, &quot;returning true because isPlayingToAutomotiveHeadUnit() is true&quot;);
7696             return true;
7697         }
7698     }
7699     return false;
7700 }
7701 
7702 bool HTMLMediaElement::processingUserGestureForMedia() const
7703 {
7704     return document().processingUserGestureForMedia();
7705 }
7706 
7707 void HTMLMediaElement::processIsSuspendedChanged()
7708 {
7709     updateSleepDisabling();
7710 }
7711 
7712 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7713 
7714 void HTMLMediaElement::scheduleUpdateMediaState()
7715 {
7716     if (m_updateMediaStateTask.hasPendingTask())
7717         return;
7718 
7719     auto logSiteIdentifier = LOGIDENTIFIER;
7720     ALWAYS_LOG(logSiteIdentifier, &quot;task scheduled&quot;);
7721     m_updateMediaStateTask.scheduleTask([this, logSiteIdentifier] {
7722         UNUSED_PARAM(logSiteIdentifier);
7723         ALWAYS_LOG(logSiteIdentifier, &quot;lambda(), task fired&quot;);
7724         Ref&lt;HTMLMediaElement&gt; protectedThis(*this); // updateMediaState calls methods that can trigger arbitrary DOM mutations.
7725         updateMediaState();
7726     });
7727 }
7728 
7729 void HTMLMediaElement::updateMediaState()
7730 {
7731     MediaProducer::MediaStateFlags state = mediaState();
7732     if (m_mediaState == state)
7733         return;
7734 
7735     m_mediaState = state;
7736     m_mediaSession-&gt;mediaStateDidChange(m_mediaState);
7737 #if ENABLE(MEDIA_SESSION)
7738     document().updateIsPlayingMedia(m_elementID);
7739 #else
7740     document().updateIsPlayingMedia();
7741 #endif
7742 }
7743 #endif
7744 
7745 MediaProducer::MediaStateFlags HTMLMediaElement::mediaState() const
7746 {
7747     MediaStateFlags state = IsNotPlaying;
7748 
7749     bool hasActiveVideo = isVideo() &amp;&amp; hasVideo();
7750     bool hasAudio = this-&gt;hasAudio();
7751     if (isPlayingToExternalTarget())
7752         state |= IsPlayingToExternalDevice;
7753 
7754 #if ENABLE(WIRELESS_PLAYBACK_TARGET)
7755     if (m_hasPlaybackTargetAvailabilityListeners) {
7756         state |= HasPlaybackTargetAvailabilityListener;
7757         if (!m_mediaSession-&gt;wirelessVideoPlaybackDisabled())
7758             state |= RequiresPlaybackTargetMonitoring;
7759     }
7760 
7761     bool requireUserGesture = m_mediaSession-&gt;hasBehaviorRestriction(MediaElementSession::RequireUserGestureToAutoplayToExternalDevice);
7762     if (m_readyState &gt;= HAVE_METADATA &amp;&amp; !requireUserGesture &amp;&amp; !m_failedToPlayToWirelessTarget)
7763         state |= ExternalDeviceAutoPlayCandidate;
7764 
7765     if (hasActiveVideo || hasAudio)
7766         state |= HasAudioOrVideo;
7767 
7768     if (hasActiveVideo &amp;&amp; endedPlayback())
7769         state |= DidPlayToEnd;
7770 #endif
7771 
7772     if (!isPlaying())
7773         return state;
7774 
7775     if (hasAudio &amp;&amp; !muted() &amp;&amp; volume())
7776         state |= IsPlayingAudio;
7777 
7778     if (hasActiveVideo)
7779         state |= IsPlayingVideo;
7780 
7781     return state;
7782 }
7783 
7784 void HTMLMediaElement::handleAutoplayEvent(AutoplayEvent event)
7785 {
7786     if (Page* page = document().page()) {
7787         bool hasAudio = this-&gt;hasAudio() &amp;&amp; !muted() &amp;&amp; volume();
7788         bool wasPlaybackPrevented = m_autoplayEventPlaybackState == AutoplayEventPlaybackState::PreventedAutoplay;
7789         bool hasMainContent = m_mediaSession &amp;&amp; m_mediaSession-&gt;isMainContentForPurposesOfAutoplayEvents();
7790         ALWAYS_LOG(LOGIDENTIFIER, &quot;hasAudio = &quot;, hasAudio, &quot; wasPlaybackPrevented = &quot;, wasPlaybackPrevented, &quot; hasMainContent = &quot;, hasMainContent);
7791 
7792         OptionSet&lt;AutoplayEventFlags&gt; flags;
7793         if (hasAudio)
7794             flags.add(AutoplayEventFlags::HasAudio);
7795         if (wasPlaybackPrevented)
7796             flags.add(AutoplayEventFlags::PlaybackWasPrevented);
7797         if (hasMainContent)
7798             flags.add(AutoplayEventFlags::MediaIsMainContent);
7799 
7800         page-&gt;chrome().client().handleAutoplayEvent(event, flags);
7801     }
7802 }
7803 
7804 void HTMLMediaElement::userDidInterfereWithAutoplay()
7805 {
7806     if (m_autoplayEventPlaybackState != AutoplayEventPlaybackState::StartedWithoutUserGesture)
7807         return;
7808 
7809     // Only consider interference in the first 10 seconds of automatic playback.
7810     if (currentTime() - playbackStartedTime() &gt; AutoplayInterferenceTimeThreshold)
7811         return;
7812 
7813     ALWAYS_LOG(LOGIDENTIFIER);
7814     handleAutoplayEvent(AutoplayEvent::UserDidInterfereWithPlayback);
7815     setAutoplayEventPlaybackState(AutoplayEventPlaybackState::None);
7816 }
7817 
7818 void HTMLMediaElement::setAutoplayEventPlaybackState(AutoplayEventPlaybackState reason)
7819 {
7820     ALWAYS_LOG(LOGIDENTIFIER, reason);
7821 
7822     m_autoplayEventPlaybackState = reason;
7823 
7824     if (reason == AutoplayEventPlaybackState::PreventedAutoplay) {
7825         dispatchPlayPauseEventsIfNeedsQuirks();
7826         handleAutoplayEvent(AutoplayEvent::DidPreventMediaFromPlaying);
7827     }
7828 }
7829 
7830 void HTMLMediaElement::pageMutedStateDidChange()
7831 {
7832     updateVolume();
7833 
7834     if (Page* page = document().page()) {
7835         if (hasAudio() &amp;&amp; !muted() &amp;&amp; page-&gt;isAudioMuted())
7836             userDidInterfereWithAutoplay();
7837     }
7838 }
7839 
7840 double HTMLMediaElement::effectiveVolume() const
7841 {
7842     auto* page = document().page();
7843     double volumeMultiplier = page ? page-&gt;mediaVolume() : 1;
7844     if (m_mediaController)
7845         volumeMultiplier *= m_mediaController-&gt;volume();
7846 #if ENABLE(MEDIA_SESSION)
7847     if (m_shouldDuck)
7848         volumeMultiplier *= 0.25;
7849 #endif
7850 
7851     return m_volume * volumeMultiplier;
7852 }
7853 
7854 bool HTMLMediaElement::effectiveMuted() const
7855 {
7856     return muted() || (m_mediaController &amp;&amp; m_mediaController-&gt;muted()) || (document().page() &amp;&amp; document().page()-&gt;isAudioMuted());
7857 }
7858 
7859 bool HTMLMediaElement::doesHaveAttribute(const AtomString&amp; attribute, AtomString* value) const
7860 {
7861     QualifiedName attributeName(nullAtom(), attribute, nullAtom());
7862 
7863     auto&amp; elementValue = attributeWithoutSynchronization(attributeName);
7864     if (elementValue.isNull())
7865         return false;
7866 
7867     if (attributeName == HTMLNames::x_itunes_inherit_uri_query_componentAttr &amp;&amp; !document().settings().enableInheritURIQueryComponent())
7868         return false;
7869 
7870     if (value)
7871         *value = elementValue;
7872 
7873     return true;
7874 }
7875 
7876 void HTMLMediaElement::setBufferingPolicy(BufferingPolicy policy)
7877 {
7878     if (policy == m_bufferingPolicy)
7879         return;
7880 
7881     INFO_LOG(LOGIDENTIFIER, policy);
7882 
7883     m_bufferingPolicy = policy;
7884     if (m_player)
7885         m_player-&gt;setBufferingPolicy(policy);
7886 }
7887 
7888 void HTMLMediaElement::purgeBufferedDataIfPossible()
7889 {
7890     INFO_LOG(LOGIDENTIFIER);
7891 
7892     if (!MemoryPressureHandler::singleton().isUnderMemoryPressure() &amp;&amp; m_mediaSession-&gt;preferredBufferingPolicy() == BufferingPolicy::Default)
7893         return;
7894 
7895     if (isPlayingToExternalTarget()) {
7896         INFO_LOG(LOGIDENTIFIER, &quot;early return because playing to wireless target&quot;);
7897         return;
7898     }
7899 
7900     setBufferingPolicy(BufferingPolicy::PurgeResources);
7901 }
7902 
7903 bool HTMLMediaElement::canSaveMediaData() const
7904 {
7905     if (m_player)
7906         return m_player-&gt;canSaveMediaData();
7907 
7908     return false;
7909 }
7910 
7911 #if ENABLE(MEDIA_SESSION)
<a name="219" id="anc219"></a><span class="line-added">7912 </span>
7913 double HTMLMediaElement::playerVolume() const
7914 {
7915     return m_player ? m_player-&gt;volume() : 0;
7916 }
7917 
7918 MediaSession* HTMLMediaElement::session() const
7919 {
7920     RefPtr&lt;MediaSession&gt; session = m_session.get();
7921     if (session &amp;&amp; session == &amp;document().defaultMediaSession())
7922         return nullptr;
7923 
7924     return session.get();
7925 }
7926 
7927 void HTMLMediaElement::setSession(MediaSession* session)
7928 {
7929     // 6.1. Extensions to the HTMLMediaElement interface
7930     // 1. Let m be the media element in question.
7931     // 2. Let old media session be m’s current media session, if it has one, and null otherwise.
7932     // 3. Let m’s current media session be the new value or the top-level browsing context’s media session if the new value is null.
7933     // 4. Let new media session be m’s current media session.
7934 
7935     // 5. Update media sessions: If old media session and new media session are the same (whether both null or both the same media session), then terminate these steps.
7936     if (m_session.get() == session)
7937         return;
7938 
7939     if (m_session) {
7940         // 6. If m is an audio-producing participant of old media session, then pause m and remove m from old media session’s list of audio-producing participants.
7941         if (m_session-&gt;isMediaElementActive(*this))
7942             pause();
7943 
7944         m_session-&gt;removeMediaElement(*this);
7945 
7946         // 7. If old media session is not null and no longer has one or more audio-producing participants, then run the media session deactivation algorithm for old media session.
7947         if (!m_session-&gt;hasActiveMediaElements())
7948             m_session-&gt;deactivate();
7949     }
7950 
7951     if (session)
7952         setSessionInternal(*session);
7953     else
7954         setSessionInternal(document().defaultMediaSession());
7955 }
7956 
7957 void HTMLMediaElement::setSessionInternal(MediaSession&amp; session)
7958 {
7959     m_session = &amp;session;
7960     session.addMediaElement(*this);
7961     m_kind = session.kind();
7962 }
7963 
7964 void HTMLMediaElement::setShouldDuck(bool duck)
7965 {
7966     if (m_shouldDuck == duck)
7967         return;
7968 
7969     m_shouldDuck = duck;
7970     updateVolume();
7971 }
7972 
7973 #endif
7974 
7975 void HTMLMediaElement::allowsMediaDocumentInlinePlaybackChanged()
7976 {
7977     if (potentiallyPlaying() &amp;&amp; m_mediaSession-&gt;requiresFullscreenForVideoPlayback() &amp;&amp; !isFullscreen())
7978         enterFullscreen();
7979 }
7980 
7981 bool HTMLMediaElement::isVideoTooSmallForInlinePlayback()
7982 {
7983     auto* renderer = this-&gt;renderer();
7984 
7985     if (!renderer || !is&lt;RenderVideo&gt;(*renderer))
7986         return true;
7987 
7988     IntRect videoBox = downcast&lt;RenderVideo&gt;(*renderer).videoBox();
7989     return (videoBox.width() &lt;= 1 || videoBox.height() &lt;= 1);
7990 }
7991 
7992 void HTMLMediaElement::isVisibleInViewportChanged()
7993 {
7994     m_visibilityChangeTaskQueue.enqueueTask([this] {
7995         m_mediaSession-&gt;isVisibleInViewportChanged();
7996         updateShouldAutoplay();
7997         schedulePlaybackControlsManagerUpdate();
7998     });
7999 }
8000 
8001 void HTMLMediaElement::updateShouldAutoplay()
8002 {
8003     if (!autoplay())
8004         return;
8005 
8006     if (!m_mediaSession-&gt;hasBehaviorRestriction(MediaElementSession::InvisibleAutoplayNotPermitted))
8007         return;
8008 
8009     bool canAutoplay = mediaSession().autoplayPermitted();
8010     if (canAutoplay
8011         &amp;&amp; m_mediaSession-&gt;state() == PlatformMediaSession::Interrupted
8012         &amp;&amp; m_mediaSession-&gt;interruptionType() == PlatformMediaSession::InvisibleAutoplay)
8013         m_mediaSession-&gt;endInterruption(PlatformMediaSession::MayResumePlaying);
8014     else if (!canAutoplay
8015         &amp;&amp; m_mediaSession-&gt;state() != PlatformMediaSession::Interrupted)
8016         m_mediaSession-&gt;beginInterruption(PlatformMediaSession::InvisibleAutoplay);
8017 }
8018 
8019 void HTMLMediaElement::updateShouldPlay()
8020 {
8021     if (!paused() &amp;&amp; !m_mediaSession-&gt;playbackPermitted()) {
8022         pauseInternal();
8023         setAutoplayEventPlaybackState(AutoplayEventPlaybackState::PreventedAutoplay);
8024     } else if (canTransitionFromAutoplayToPlay())
8025         play();
8026 }
8027 
8028 void HTMLMediaElement::resetPlaybackSessionState()
8029 {
8030     if (m_mediaSession)
8031         m_mediaSession-&gt;resetPlaybackSessionState();
8032 }
8033 
8034 bool HTMLMediaElement::isVisibleInViewport() const
8035 {
8036     auto renderer = this-&gt;renderer();
8037     return renderer &amp;&amp; renderer-&gt;visibleInViewportState() == VisibleInViewportState::Yes;
8038 }
8039 
8040 void HTMLMediaElement::schedulePlaybackControlsManagerUpdate()
8041 {
8042     Page* page = document().page();
8043     if (!page)
8044         return;
8045     page-&gt;schedulePlaybackControlsManagerUpdate();
8046 }
8047 
8048 void HTMLMediaElement::playbackControlsManagerBehaviorRestrictionsTimerFired()
8049 {
8050     if (m_playbackControlsManagerBehaviorRestrictionsQueue.hasPendingTask())
8051         return;
8052 
8053     if (!m_mediaSession-&gt;hasBehaviorRestriction(MediaElementSession::RequireUserGestureToControlControlsManager))
8054         return;
8055 
8056     RefPtr&lt;HTMLMediaElement&gt; protectedThis(this);
8057     m_playbackControlsManagerBehaviorRestrictionsQueue.scheduleTask([protectedThis] () {
8058         MediaElementSession* mediaElementSession = protectedThis-&gt;m_mediaSession.get();
8059         if (protectedThis-&gt;isPlaying() || mediaElementSession-&gt;state() == PlatformMediaSession::Autoplaying || mediaElementSession-&gt;state() == PlatformMediaSession::Playing)
8060             return;
8061 
8062         mediaElementSession-&gt;addBehaviorRestriction(MediaElementSession::RequirePlaybackToControlControlsManager);
8063         protectedThis-&gt;schedulePlaybackControlsManagerUpdate();
8064     });
8065 }
8066 
8067 bool HTMLMediaElement::shouldOverrideBackgroundLoadingRestriction() const
8068 {
8069     if (isPlayingToExternalTarget())
8070         return true;
8071 
8072     return m_videoFullscreenMode == VideoFullscreenModePictureInPicture;
8073 }
8074 
8075 void HTMLMediaElement::fullscreenModeChanged(VideoFullscreenMode mode)
8076 {
8077     if (m_videoFullscreenMode == mode)
8078         return;
8079 
8080     m_videoFullscreenMode = mode;
8081     visibilityStateChanged();
8082     schedulePlaybackControlsManagerUpdate();
8083 }
8084 
8085 #if !RELEASE_LOG_DISABLED
8086 WTFLogChannel&amp; HTMLMediaElement::logChannel() const
8087 {
8088     return LogMedia;
8089 }
8090 #endif
8091 
8092 bool HTMLMediaElement::willLog(WTFLogLevel level) const
8093 {
8094 #if !RELEASE_LOG_DISABLED
8095     return m_logger-&gt;willLog(logChannel(), level);
8096 #else
8097     UNUSED_PARAM(level);
8098     return false;
8099 #endif
8100 }
8101 
8102 void HTMLMediaElement::applicationWillResignActive()
8103 {
8104     if (m_player)
8105         m_player-&gt;applicationWillResignActive();
8106 }
8107 
8108 void HTMLMediaElement::applicationDidBecomeActive()
8109 {
8110     if (m_player)
8111         m_player-&gt;applicationDidBecomeActive();
8112 }
8113 
8114 void HTMLMediaElement::setInActiveDocument(bool inActiveDocument)
8115 {
8116     if (inActiveDocument == m_inActiveDocument)
8117         return;
8118 
8119     m_inActiveDocument = inActiveDocument;
8120     m_mediaSession-&gt;inActiveDocumentChanged();
8121 }
8122 
8123 HTMLMediaElementEnums::BufferingPolicy HTMLMediaElement::bufferingPolicy() const
8124 {
8125     return m_bufferingPolicy;
8126 }
8127 
8128 bool HTMLMediaElement::hasMediaStreamSource() const
8129 {
8130 #if ENABLE(MEDIA_STREAM)
8131     return hasMediaStreamSrcObject();
8132 #else
8133     return false;
8134 #endif
8135 }
8136 
<a name="220" id="anc220"></a><span class="line-added">8137 #if ENABLE(MEDIA_STREAM)</span>
<span class="line-added">8138 void HTMLMediaElement::mediaStreamCaptureStarted()</span>
<span class="line-added">8139 {</span>
<span class="line-added">8140     if (canTransitionFromAutoplayToPlay())</span>
<span class="line-added">8141         play();</span>
<span class="line-added">8142 }</span>
<span class="line-added">8143 #endif</span>
<span class="line-added">8144 </span>
<span class="line-added">8145 void HTMLMediaElement::enqueueTaskForDispatcher(Function&lt;void()&gt;&amp;&amp; function)</span>
<span class="line-added">8146 {</span>
<span class="line-added">8147     if (!isMainThread()) {</span>
<span class="line-added">8148         callOnMainThread([this, weakThis = makeWeakPtr(*this), function = WTFMove(function)]() mutable {</span>
<span class="line-added">8149             if (!weakThis)</span>
<span class="line-added">8150                 return;</span>
<span class="line-added">8151             enqueueTaskForDispatcher(WTFMove(function));</span>
<span class="line-added">8152         });</span>
<span class="line-added">8153         return;</span>
<span class="line-added">8154     }</span>
<span class="line-added">8155 </span>
<span class="line-added">8156     if (!scriptExecutionContext())</span>
<span class="line-added">8157         return;</span>
<span class="line-added">8158     scriptExecutionContext()-&gt;eventLoop().queueTask(TaskSource::MediaElement, WTFMove(function));</span>
<span class="line-added">8159 }</span>
<span class="line-added">8160 </span>
8161 }
8162 
8163 #endif
<a name="221" id="anc221"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="221" type="hidden" />
</body>
</html>
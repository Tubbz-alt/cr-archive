<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WTF/wtf/SmallPtrSet.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Apple Inc. All Rights Reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 14  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/Assertions.h&gt;
 29 #include &lt;wtf/FastMalloc.h&gt;
 30 #include &lt;wtf/HashFunctions.h&gt;
 31 #include &lt;wtf/Noncopyable.h&gt;
 32 
 33 namespace WTF {
 34 
 35 DECLARE_ALLOCATOR_WITH_HEAP_IDENTIFIER(SmallPtrSet);
 36 
 37 template&lt;typename PtrType, unsigned SmallArraySize = 8&gt;
 38 class SmallPtrSet {
 39     WTF_MAKE_FAST_ALLOCATED;
 40     WTF_MAKE_NONCOPYABLE(SmallPtrSet);
 41     static_assert(std::is_trivially_destructible&lt;PtrType&gt;::value, &quot;We currently don&#39;t support non-trivially destructible pointer types.&quot;);
 42     static_assert(sizeof(PtrType) == sizeof(void*), &quot;Only support pointer sized things.&quot;);
 43     static_assert(!(SmallArraySize &amp; (SmallArraySize - 1)), &quot;Inline size must be a power of two.&quot;);
 44 
 45 public:
 46     SmallPtrSet()
 47     {
 48         initialize();
 49     }
 50 
 51     // We take care to have SmallPtrSet have partial move semantics allowable through
 52     // memcpy. It&#39;s partial move semantics because our destructor should not be called
 53     // on the SmallPtrObject in the old memory we were moved from (otherwise, we might free m_buffer twice)
 54     // unless that old memory is reset to be isSmall(). See move constructor below.
 55     // To maintain these semantics, we determine if we&#39;re small by checking our size
 56     // and not our m_buffer pointer. And when we&#39;re small, we don&#39;t do operations on
 57     // m_buffer, instead, we perform operations on m_smallStorage directly. The reason we want
 58     // these semantics is that it&#39;s beneficial to have a Vector that contains SmallPtrSet
 59     // (or an object with SmallPtrSet as a field) be allowed to use memcpy for its move operation.
 60 
 61     SmallPtrSet(SmallPtrSet&amp;&amp; other)
 62     {
 63         memcpy(this, &amp;other, sizeof(SmallPtrSet));
 64         other.initialize();
 65     }
 66 
 67     SmallPtrSet&amp; operator=(SmallPtrSet&amp;&amp; other)
 68     {
 69         this-&gt;~SmallPtrSet();
 70         new (this) SmallPtrSet(WTFMove(other));
 71         return *this;
 72     }
 73 
 74     ~SmallPtrSet()
 75     {
 76         if (!isSmall())
 77             SmallPtrSetMalloc::free(m_buffer);
 78     }
 79 
 80     inline void add(PtrType ptr)
 81     {
 82         ASSERT(isValidEntry(ptr));
 83 
 84         if (isSmall()) {
 85             for (unsigned i = 0; i &lt; m_size; i++) {
 86                 if (m_smallStorage[i] == ptr)
 87                     return;
 88             }
 89 
 90             if (m_size &lt; SmallArraySize) {
 91                 m_smallStorage[m_size] = ptr;
 92                 ++m_size;
 93                 return;
 94             }
 95 
 96             grow(std::max(64u, SmallArraySize * 2));
 97             // Fall through. We&#39;re no longer small :(
 98         }
 99 
100         // If we&#39;re more than 3/4ths full we grow.
101         if (UNLIKELY(m_size * 4 &gt;= m_capacity * 3)) {
102             grow(m_capacity * 2);
103             ASSERT(!(m_capacity &amp; (m_capacity - 1)));
104         }
105 
106         void** bucket = this-&gt;bucket(ptr);
107         if (*bucket != ptr) {
108             *bucket = ptr;
109             ++m_size;
110         }
111     }
112 
113     inline bool contains(PtrType ptr) const
114     {
115         ASSERT(isValidEntry(ptr));
116         if (isSmall()) {
117             for (unsigned i = 0; i &lt; m_size; i++) { // We only need to search up to m_size because we store things linearly inside m_smallStorage.
118                 if (m_smallStorage[i] == ptr)
119                     return true;
120             }
121             return false;
122         }
123 
124         void** bucket = this-&gt;bucket(ptr);
125         return *bucket == ptr;
126     }
127 
128     class iterator {
129         WTF_MAKE_FAST_ALLOCATED;
130     public:
131         iterator&amp; operator++()
132         {
133             m_index++;
134             ASSERT(m_index &lt;= m_capacity);
135             while (m_index &lt; m_capacity &amp;&amp; m_buffer[m_index] == emptyValue())
136                 m_index++;
137             return *this;
138         }
139 
140         PtrType operator*() const { ASSERT(m_index &lt; m_capacity); return static_cast&lt;PtrType&gt;(m_buffer[m_index]); }
141         bool operator==(const iterator&amp; other) const { ASSERT(m_buffer == other.m_buffer); return m_index == other.m_index; }
142         bool operator!=(const iterator&amp; other) const { ASSERT(m_buffer == other.m_buffer); return !(*this == other); }
143 
144     private:
145         template&lt;typename U, unsigned S&gt; friend class WTF::SmallPtrSet;
146         unsigned m_index;
147         unsigned m_capacity;
148         void** m_buffer;
149     };
150 
151     iterator begin() const
152     {
153         iterator it;
154         it.m_index = std::numeric_limits&lt;unsigned&gt;::max();
155         it.m_capacity = m_capacity;
156         if (isSmall())
157             it.m_buffer = const_cast&lt;void**&gt;(m_smallStorage);
158         else
159             it.m_buffer = m_buffer;
160 
161         ++it;
162 
163         return it;
164     }
165 
166     iterator end() const
167     {
168         iterator it;
169         it.m_index = m_capacity;
170         it.m_capacity = m_capacity;
171         if (isSmall())
172             it.m_buffer = const_cast&lt;void**&gt;(m_smallStorage);
173         else
174             it.m_buffer = m_buffer;
175 
176         return it;
177     }
178 
179     inline unsigned size() const { return m_size; }
180 
181 private:
182     constexpr static void* emptyValue()
183     {
184         return bitwise_cast&lt;void*&gt;(std::numeric_limits&lt;uintptr_t&gt;::max());
185     }
186 
187     bool isValidEntry(const PtrType ptr) const
188     {
189         return ptr != emptyValue();
190     }
191 
192     inline bool isSmall() const
193     {
194         return m_capacity == SmallArraySize;
195     }
196 
197     inline void initialize()
198     {
199         m_size = 0;
200         m_buffer = nullptr;
201         m_capacity = SmallArraySize;
202         memset(m_smallStorage, -1, sizeof(void*) * SmallArraySize);
203         ASSERT(isSmall());
204     }
205 
206     inline void grow(unsigned size)
207     {
208         ASSERT(static_cast&lt;int32_t&gt;(bitwise_cast&lt;intptr_t&gt;(emptyValue())) == -1);
209 
210         size_t allocationSize = sizeof(void*) * size;
211         bool wasSmall = isSmall();
212         void** oldBuffer = wasSmall ? m_smallStorage : m_buffer;
213         unsigned oldCapacity = m_capacity;
214         m_buffer = static_cast&lt;void**&gt;(SmallPtrSetMalloc::malloc(allocationSize));
215         memset(m_buffer, -1, allocationSize);
216         m_capacity = size;
217 
218         for (unsigned i = 0; i &lt; oldCapacity; i++) {
219             if (oldBuffer[i] != emptyValue()) {
220                 void** ptr = this-&gt;bucket(static_cast&lt;PtrType&gt;(oldBuffer[i]));
221                 *ptr = oldBuffer[i];
222             }
223         }
224 
225         if (!wasSmall)
226             SmallPtrSetMalloc::free(oldBuffer);
227     }
228 
229 
230     inline void** bucket(PtrType target) const
231     {
232         ASSERT(!(m_capacity &amp; (m_capacity - 1)));
233         unsigned bucket = PtrHashBase&lt;PtrType, false /* isSmartPtr */&gt;::hash(target) &amp; (m_capacity - 1);
234         unsigned index = 0;
235         while (true) {
236             void** ptr = m_buffer + bucket;
237             if (*ptr == emptyValue())
238                 return ptr;
239             if (*ptr == target)
240                 return ptr;
241             index++;
242             bucket = (bucket + index) &amp; (m_capacity - 1);
243         }
244     }
245 
246     unsigned m_size;
247     unsigned m_capacity;
248     void** m_buffer;
249     void* m_smallStorage[SmallArraySize];
250 };
251 
252 } // namespace WTF
253 
254 using WTF::SmallPtrSet;
    </pre>
  </body>
</html>
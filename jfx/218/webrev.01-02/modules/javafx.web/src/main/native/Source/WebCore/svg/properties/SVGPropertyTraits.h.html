<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/svg/properties/SVGPropertyTraits.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2004, 2005, 2006, 2007, 2008 Nikolas Zimmermann &lt;zimmermann@kde.org&gt;
  3  * Copyright (C) Research In Motion Limited 2010. All rights reserved.
  4  * Copyright (C) 2018 Apple Inc. All rights reserved.
  5  *
  6  * This library is free software; you can redistribute it and/or
  7  * modify it under the terms of the GNU Library General Public
  8  * License as published by the Free Software Foundation; either
  9  * version 2 of the License, or (at your option) any later version.
 10  *
 11  * This library is distributed in the hope that it will be useful,
 12  * but WITHOUT ANY WARRANTY; without even the implied warranty of
 13  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 14  * Library General Public License for more details.
 15  *
 16  * You should have received a copy of the GNU Library General Public License
 17  * along with this library; see the file COPYING.LIB.  If not, write to
 18  * the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
 19  * Boston, MA 02110-1301, USA.
 20  */
 21 
 22 #pragma once
 23 
 24 #include &quot;CSSParser.h&quot;
 25 #include &quot;Color.h&quot;
 26 #include &quot;FloatPoint.h&quot;
 27 #include &quot;FloatRect.h&quot;
 28 #include &quot;QualifiedName.h&quot;
 29 #include &quot;SVGParserUtilities.h&quot;
 30 
 31 namespace WebCore {
 32 
 33 template&lt;typename PropertyType&gt;
 34 struct SVGPropertyTraits { };
 35 
 36 template&lt;&gt;
 37 struct SVGPropertyTraits&lt;bool&gt; {
 38     static bool initialValue() { return false; }
 39     static bool fromString(const String&amp; string) { return string == &quot;true&quot;; }
 40     static Optional&lt;bool&gt; parse(const QualifiedName&amp;, const String&amp;) { ASSERT_NOT_REACHED(); return initialValue(); }
 41     static String toString(bool type) { return type ? &quot;true&quot; : &quot;false&quot;; }
 42 };
 43 
 44 template&lt;&gt;
 45 struct SVGPropertyTraits&lt;Color&gt; {
 46     static Color initialValue() { return Color(); }
 47     static Color fromString(const String&amp; string) { return CSSParser::parseColor(string.stripWhiteSpace()); }
 48     static Optional&lt;Color&gt; parse(const QualifiedName&amp;, const String&amp; string)
 49     {
 50         Color color = CSSParser::parseColor(string.stripWhiteSpace());
 51         if (!color.isValid())
 52             return WTF::nullopt;
 53         return color;
 54     }
 55     static String toString(const Color&amp; type) { return type.serialized(); }
 56 };
 57 
 58 template&lt;&gt;
 59 struct SVGPropertyTraits&lt;unsigned&gt; {
 60     static unsigned initialValue() { return 0; }
 61     static Optional&lt;unsigned&gt; parse(const QualifiedName&amp;, const String&amp;) { ASSERT_NOT_REACHED(); return initialValue(); }
 62     static String toString(unsigned type) { return String::number(type); }
 63 };
 64 
 65 template&lt;&gt;
 66 struct SVGPropertyTraits&lt;int&gt; {
 67     static int initialValue() { return 0; }
 68     static int fromString(const String&amp;string) { return string.toIntStrict(); }
 69     static Optional&lt;int&gt; parse(const QualifiedName&amp;, const String&amp;) { ASSERT_NOT_REACHED(); return initialValue(); }
 70     static String toString(int type) { return String::number(type); }
 71 };
 72 
 73 template&lt;&gt;
 74 struct SVGPropertyTraits&lt;std::pair&lt;int, int&gt;&gt; {
 75     static std::pair&lt;int, int&gt; initialValue() { return { }; }
 76     static std::pair&lt;int, int&gt; fromString(const String&amp; string)
 77     {
 78         float firstNumber = 0, secondNumber = 0;
 79         if (!parseNumberOptionalNumber(string, firstNumber, secondNumber))
 80             return { };
 81         return std::make_pair(static_cast&lt;int&gt;(roundf(firstNumber)), static_cast&lt;int&gt;(roundf(secondNumber)));
 82     }
 83     static Optional&lt;std::pair&lt;int, int&gt;&gt; parse(const QualifiedName&amp;, const String&amp;) { ASSERT_NOT_REACHED(); return initialValue(); }
 84     static String toString(std::pair&lt;int, int&gt;) { ASSERT_NOT_REACHED(); return emptyString(); }
 85 };
 86 
 87 template&lt;&gt;
 88 struct SVGPropertyTraits&lt;float&gt; {
 89     static float initialValue() { return 0; }
 90     static float fromString(const String&amp; string)
 91     {
 92         float number = 0;
 93         if (!parseNumberFromString(string, number))
 94             return 0;
 95         return number;
 96     }
 97     static Optional&lt;float&gt; parse(const QualifiedName&amp;, const String&amp; string)
 98     {
 99         float number;
100         if (!parseNumberFromString(string, number))
101             return WTF::nullopt;
102         return number;
103     }
104     static String toString(float type) { return String::number(type); }
105 };
106 
107 template&lt;&gt;
108 struct SVGPropertyTraits&lt;std::pair&lt;float, float&gt;&gt; {
109     static std::pair&lt;float, float&gt; initialValue() { return { }; }
110     static std::pair&lt;float, float&gt; fromString(const String&amp; string)
111     {
112         float firstNumber = 0, secondNumber = 0;
113         if (!parseNumberOptionalNumber(string, firstNumber, secondNumber))
114             return { };
115         return std::make_pair(firstNumber, secondNumber);
116     }
117     static Optional&lt;std::pair&lt;float, float&gt;&gt; parse(const QualifiedName&amp;, const String&amp;) { ASSERT_NOT_REACHED(); return initialValue(); }
118     static String toString(std::pair&lt;float, float&gt;) { ASSERT_NOT_REACHED(); return emptyString(); }
119 };
120 
121 template&lt;&gt;
122 struct SVGPropertyTraits&lt;FloatPoint&gt; {
123     static FloatPoint initialValue() { return FloatPoint(); }
124     static FloatPoint fromString(const String&amp; string)
125     {
126         FloatPoint point;
127         if (!parsePoint(string, point))
128             return { };
129         return point;
130     }
131     static Optional&lt;FloatPoint&gt; parse(const QualifiedName&amp;, const String&amp; string)
132     {
133         FloatPoint point;
134         if (!parsePoint(string, point))
135             return WTF::nullopt;
136         return point;
137     }
138     static String toString(const FloatPoint&amp; type)
139     {
140         return makeString(type.x(), &#39; &#39;, type.y());
141     }
142 };
143 
144 template&lt;&gt;
145 struct SVGPropertyTraits&lt;FloatRect&gt; {
146     static FloatRect initialValue() { return FloatRect(); }
147     static FloatRect fromString(const String&amp; string)
148     {
149         FloatRect rect;
150         if (!parseRect(string, rect))
151             return { };
152         return rect;
153     }
154     static Optional&lt;FloatRect&gt; parse(const QualifiedName&amp;, const String&amp; string)
155     {
156         FloatRect rect;
157         if (!parseRect(string, rect))
158             return WTF::nullopt;
159         return rect;
160     }
161     static String toString(const FloatRect&amp; type)
162     {
163         return makeString(type.x(), &#39; &#39;, type.y(), &#39; &#39;, type.width(), &#39; &#39;, type.height());
164     }
165 };
166 
167 template&lt;&gt;
168 struct SVGPropertyTraits&lt;String&gt; {
169     static String initialValue() { return String(); }
170     static String fromString(const String&amp; string) { return string; }
171     static Optional&lt;String&gt; parse(const QualifiedName&amp;, const String&amp; string) { return string; }
172     static String toString(const String&amp; string) { return string; }
173 };
174 
175 template&lt;typename EnumType&gt;
176 struct SVGIDLEnumLimits {
177     // Specialize this function for a particular enumeration to limit the values that are exposed through the DOM.
178     static unsigned highestExposedEnumValue() { return SVGPropertyTraits&lt;EnumType&gt;::highestEnumValue(); }
179 };
180 
181 } // namespace WebCore
    </pre>
  </body>
</html>
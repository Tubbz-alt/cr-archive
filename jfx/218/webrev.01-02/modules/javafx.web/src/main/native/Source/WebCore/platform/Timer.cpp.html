<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/platform/Timer.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2006, 2008 Apple Inc. All rights reserved.
  3  * Copyright (C) 2009 Google Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 #include &quot;Timer.h&quot;
 29 
 30 #include &quot;RuntimeApplicationChecks.h&quot;
 31 #include &quot;SharedTimer.h&quot;
 32 #include &quot;ThreadGlobalData.h&quot;
 33 #include &quot;ThreadTimers.h&quot;
 34 #include &lt;limits&gt;
 35 #include &lt;math.h&gt;
 36 #include &lt;wtf/MainThread.h&gt;
 37 #include &lt;wtf/Vector.h&gt;
 38 
 39 #if PLATFORM(COCOA)
 40 #include &lt;wtf/spi/darwin/dyldSPI.h&gt;
 41 #endif
 42 
 43 namespace WebCore {
 44 
 45 class TimerHeapReference;
 46 
 47 // Timers are stored in a heap data structure, used to implement a priority queue.
 48 // This allows us to efficiently determine which timer needs to fire the soonest.
 49 // Then we set a single shared system timer to fire at that time.
 50 //
 51 // When a timer&#39;s &quot;next fire time&quot; changes, we need to move it around in the priority queue.
 52 #if ASSERT_ENABLED
 53 static ThreadTimerHeap&amp; threadGlobalTimerHeap()
 54 {
 55     return threadGlobalData().threadTimers().timerHeap();
 56 }
 57 #endif
 58 
 59 inline ThreadTimerHeapItem::ThreadTimerHeapItem(TimerBase&amp; timer, MonotonicTime time, unsigned insertionOrder)
 60     : time(time)
 61     , insertionOrder(insertionOrder)
 62     , m_threadTimers(threadGlobalData().threadTimers())
 63     , m_timer(&amp;timer)
 64 {
 65     ASSERT(m_timer);
 66 }
 67 
 68 inline RefPtr&lt;ThreadTimerHeapItem&gt; ThreadTimerHeapItem::create(TimerBase&amp; timer, MonotonicTime time, unsigned insertionOrder)
 69 {
 70     return adoptRef(*new ThreadTimerHeapItem { timer, time, insertionOrder });
 71 }
 72 
 73 // ----------------
 74 
 75 class TimerHeapPointer {
 76 public:
 77     TimerHeapPointer(RefPtr&lt;ThreadTimerHeapItem&gt;* pointer)
 78         : m_pointer(pointer)
 79     { }
 80 
 81     TimerHeapReference operator*() const;
 82     RefPtr&lt;ThreadTimerHeapItem&gt;&amp; operator-&gt;() const { return *m_pointer; }
 83 private:
 84     RefPtr&lt;ThreadTimerHeapItem&gt;* m_pointer;
 85 };
 86 
 87 class TimerHeapReference {
 88 public:
 89     TimerHeapReference(RefPtr&lt;ThreadTimerHeapItem&gt;&amp; reference)
 90         : m_reference(reference)
 91     { }
 92 
 93     TimerHeapReference(const TimerHeapReference&amp; other)
 94         : m_reference(other.m_reference)
 95     { }
 96 
 97     operator RefPtr&lt;ThreadTimerHeapItem&gt;&amp;() const { return m_reference; }
 98     TimerHeapPointer operator&amp;() const { return &amp;m_reference; }
 99     TimerHeapReference&amp; operator=(TimerHeapReference&amp;&amp;);
100     TimerHeapReference&amp; operator=(RefPtr&lt;ThreadTimerHeapItem&gt;&amp;&amp;);
101 
102     void swap(TimerHeapReference&amp; other);
103 
104     void updateHeapIndex();
105 
106 private:
107     RefPtr&lt;ThreadTimerHeapItem&gt;&amp; m_reference;
108 
109     friend void swap(TimerHeapReference a, TimerHeapReference b);
110 };
111 
112 inline TimerHeapReference TimerHeapPointer::operator*() const
113 {
114     return TimerHeapReference { *m_pointer };
115 }
116 
117 inline TimerHeapReference&amp; TimerHeapReference::operator=(TimerHeapReference&amp;&amp; other)
118 {
119     m_reference = WTFMove(other.m_reference);
120     updateHeapIndex();
121     return *this;
122 }
123 
124 inline TimerHeapReference&amp; TimerHeapReference::operator=(RefPtr&lt;ThreadTimerHeapItem&gt;&amp;&amp; item)
125 {
126     m_reference = WTFMove(item);
127     updateHeapIndex();
128     return *this;
129 }
130 
131 inline void TimerHeapReference::swap(TimerHeapReference&amp; other)
132 {
133     m_reference.swap(other.m_reference);
134     updateHeapIndex();
135     other.updateHeapIndex();
136 }
137 
138 inline void TimerHeapReference::updateHeapIndex()
139 {
140     auto&amp; heap = m_reference-&gt;timerHeap();
141     if (&amp;m_reference &gt;= heap.data() &amp;&amp; &amp;m_reference &lt; heap.data() + heap.size())
142         m_reference-&gt;setHeapIndex(&amp;m_reference - heap.data());
143 }
144 
145 inline void swap(TimerHeapReference a, TimerHeapReference b)
146 {
147     a.swap(b);
148 }
149 
150 // ----------------
151 
152 // Class to represent iterators in the heap when calling the standard library heap algorithms.
153 // Uses a custom pointer and reference type that update indices for pointers in the heap.
154 class TimerHeapIterator : public std::iterator&lt;std::random_access_iterator_tag, RefPtr&lt;ThreadTimerHeapItem&gt;, ptrdiff_t, TimerHeapPointer, TimerHeapReference&gt; {
155 public:
156     explicit TimerHeapIterator(RefPtr&lt;ThreadTimerHeapItem&gt;* pointer) : m_pointer(pointer) { checkConsistency(); }
157 
158     TimerHeapIterator&amp; operator++() { checkConsistency(); ++m_pointer; checkConsistency(); return *this; }
159     TimerHeapIterator operator++(int) { checkConsistency(1); return TimerHeapIterator(m_pointer++); }
160 
161     TimerHeapIterator&amp; operator--() { checkConsistency(); --m_pointer; checkConsistency(); return *this; }
162     TimerHeapIterator operator--(int) { checkConsistency(-1); return TimerHeapIterator(m_pointer--); }
163 
164     TimerHeapIterator&amp; operator+=(ptrdiff_t i) { checkConsistency(); m_pointer += i; checkConsistency(); return *this; }
165     TimerHeapIterator&amp; operator-=(ptrdiff_t i) { checkConsistency(); m_pointer -= i; checkConsistency(); return *this; }
166 
167     TimerHeapReference operator*() const { return TimerHeapReference(*m_pointer); }
168     TimerHeapReference operator[](ptrdiff_t i) const { return TimerHeapReference(m_pointer[i]); }
169     RefPtr&lt;ThreadTimerHeapItem&gt;&amp; operator-&gt;() const { return *m_pointer; }
170 
171 private:
172     void checkConsistency(ptrdiff_t offset = 0) const
173     {
174         ASSERT(m_pointer &gt;= threadGlobalTimerHeap().data());
175         ASSERT(m_pointer &lt;= threadGlobalTimerHeap().data() + threadGlobalTimerHeap().size());
176         ASSERT_UNUSED(offset, m_pointer + offset &gt;= threadGlobalTimerHeap().data());
177         ASSERT_UNUSED(offset, m_pointer + offset &lt;= threadGlobalTimerHeap().data() + threadGlobalTimerHeap().size());
178     }
179 
180     friend bool operator==(TimerHeapIterator, TimerHeapIterator);
181     friend bool operator!=(TimerHeapIterator, TimerHeapIterator);
182     friend bool operator&lt;(TimerHeapIterator, TimerHeapIterator);
183     friend bool operator&gt;(TimerHeapIterator, TimerHeapIterator);
184     friend bool operator&lt;=(TimerHeapIterator, TimerHeapIterator);
185     friend bool operator&gt;=(TimerHeapIterator, TimerHeapIterator);
186 
187     friend TimerHeapIterator operator+(TimerHeapIterator, size_t);
188     friend TimerHeapIterator operator+(size_t, TimerHeapIterator);
189 
190     friend TimerHeapIterator operator-(TimerHeapIterator, size_t);
191     friend ptrdiff_t operator-(TimerHeapIterator, TimerHeapIterator);
192 
193     RefPtr&lt;ThreadTimerHeapItem&gt;* m_pointer;
194 };
195 
196 inline bool operator==(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer == b.m_pointer; }
197 inline bool operator!=(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer != b.m_pointer; }
198 inline bool operator&lt;(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer &lt; b.m_pointer; }
199 inline bool operator&gt;(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer &gt; b.m_pointer; }
200 inline bool operator&lt;=(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer &lt;= b.m_pointer; }
201 inline bool operator&gt;=(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer &gt;= b.m_pointer; }
202 
203 inline TimerHeapIterator operator+(TimerHeapIterator a, size_t b) { return TimerHeapIterator(a.m_pointer + b); }
204 inline TimerHeapIterator operator+(size_t a, TimerHeapIterator b) { return TimerHeapIterator(a + b.m_pointer); }
205 
206 inline TimerHeapIterator operator-(TimerHeapIterator a, size_t b) { return TimerHeapIterator(a.m_pointer - b); }
207 inline ptrdiff_t operator-(TimerHeapIterator a, TimerHeapIterator b) { return a.m_pointer - b.m_pointer; }
208 
209 // ----------------
210 
211 class TimerHeapLessThanFunction {
212 public:
213     static bool compare(const TimerBase&amp; a, const RefPtr&lt;ThreadTimerHeapItem&gt;&amp; b)
214     {
215         return compare(a.m_heapItem-&gt;time, a.m_heapItem-&gt;insertionOrder, b-&gt;time, b-&gt;insertionOrder);
216     }
217 
218     static bool compare(const RefPtr&lt;ThreadTimerHeapItem&gt;&amp; a, const TimerBase&amp; b)
219     {
220         return compare(a-&gt;time, a-&gt;insertionOrder, b.m_heapItem-&gt;time, b.m_heapItem-&gt;insertionOrder);
221     }
222 
223     bool operator()(const RefPtr&lt;ThreadTimerHeapItem&gt;&amp; a, const RefPtr&lt;ThreadTimerHeapItem&gt;&amp; b) const
224     {
225         return compare(a-&gt;time, a-&gt;insertionOrder, b-&gt;time, b-&gt;insertionOrder);
226     }
227 
228 private:
229     static bool compare(MonotonicTime aTime, unsigned aOrder, MonotonicTime bTime, unsigned bOrder)
230     {
231         // The comparisons below are &quot;backwards&quot; because the heap puts the largest
232         // element first and we want the lowest time to be the first one in the heap.
233         if (bTime != aTime)
234             return bTime &lt; aTime;
235         // We need to look at the difference of the insertion orders instead of comparing the two
236         // outright in case of overflow.
237         unsigned difference = aOrder - bOrder;
238         return difference &lt; std::numeric_limits&lt;unsigned&gt;::max() / 2;
239     }
240 };
241 
242 // ----------------
243 
244 static bool shouldSuppressThreadSafetyCheck()
245 {
246 #if PLATFORM(IOS_FAMILY)
247     return WebThreadIsEnabled() || applicationSDKVersion() &lt; DYLD_IOS_VERSION_12_0;
248 #elif PLATFORM(MAC)
249     return !isInWebProcess() &amp;&amp; applicationSDKVersion() &lt; DYLD_MACOSX_VERSION_10_14;
250 #else
251     return false;
252 #endif
253 }
254 
255 TimerBase::TimerBase()
256 {
257 }
258 
259 TimerBase::~TimerBase()
260 {
261     ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));
262     RELEASE_ASSERT(canCurrentThreadAccessThreadLocalData(m_thread) || shouldSuppressThreadSafetyCheck());
263     stop();
264     ASSERT(!inHeap());
265     if (m_heapItem)
266         m_heapItem-&gt;clearTimer();
267     m_unalignedNextFireTime = MonotonicTime::nan();
268 }
269 
270 void TimerBase::start(Seconds nextFireInterval, Seconds repeatInterval)
271 {
272     ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));
273 
274     m_repeatInterval = repeatInterval;
275     setNextFireTime(MonotonicTime::now() + nextFireInterval);
276 }
277 
278 void TimerBase::stop()
279 {
280     ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));
281 
282     m_repeatInterval = 0_s;
283     setNextFireTime(MonotonicTime { });
284 
285     ASSERT(!static_cast&lt;bool&gt;(nextFireTime()));
286     ASSERT(m_repeatInterval == 0_s);
287     ASSERT(!inHeap());
288 }
289 
290 Seconds TimerBase::nextFireInterval() const
291 {
292     ASSERT(isActive());
293     ASSERT(m_heapItem);
294     MonotonicTime current = MonotonicTime::now();
295     auto fireTime = nextFireTime();
296     if (fireTime &lt; current)
297         return 0_s;
298     return fireTime - current;
299 }
300 
301 inline void TimerBase::checkHeapIndex() const
302 {
303 #if ASSERT_ENABLED
304     ASSERT(m_heapItem);
305     auto&amp; heap = m_heapItem-&gt;timerHeap();
306     ASSERT(&amp;heap == &amp;threadGlobalTimerHeap());
307     ASSERT(!heap.isEmpty());
308     ASSERT(m_heapItem-&gt;isInHeap());
309     ASSERT(m_heapItem-&gt;heapIndex() &lt; m_heapItem-&gt;timerHeap().size());
310     ASSERT(heap[m_heapItem-&gt;heapIndex()] == m_heapItem);
311     for (unsigned i = 0, size = heap.size(); i &lt; size; i++)
312         ASSERT(heap[i]-&gt;heapIndex() == i);
313 #endif
314 }
315 
316 inline void TimerBase::checkConsistency() const
317 {
318     // Timers should be in the heap if and only if they have a non-zero next fire time.
319     ASSERT(inHeap() == static_cast&lt;bool&gt;(nextFireTime()));
320     if (inHeap())
321         checkHeapIndex();
322 }
323 
324 void TimerBase::heapDecreaseKey()
325 {
326     ASSERT(static_cast&lt;bool&gt;(nextFireTime()));
327     ASSERT(m_heapItem);
328     checkHeapIndex();
329     auto* heapData = m_heapItem-&gt;timerHeap().data();
330     push_heap(TimerHeapIterator(heapData), TimerHeapIterator(heapData + m_heapItem-&gt;heapIndex() + 1), TimerHeapLessThanFunction());
331     checkHeapIndex();
332 }
333 
334 inline void TimerBase::heapDelete()
335 {
336     ASSERT(!static_cast&lt;bool&gt;(nextFireTime()));
337     heapPop();
338     m_heapItem-&gt;timerHeap().removeLast();
339     m_heapItem-&gt;setNotInHeap();
340 }
341 
342 void TimerBase::heapDeleteMin()
343 {
344     ASSERT(!static_cast&lt;bool&gt;(nextFireTime()));
345     heapPopMin();
346     m_heapItem-&gt;timerHeap().removeLast();
347     m_heapItem-&gt;setNotInHeap();
348 }
349 
350 inline void TimerBase::heapIncreaseKey()
351 {
352     ASSERT(static_cast&lt;bool&gt;(nextFireTime()));
353     heapPop();
354     heapDecreaseKey();
355 }
356 
357 inline void TimerBase::heapInsert()
358 {
359     ASSERT(!inHeap());
360     ASSERT(m_heapItem);
361     auto&amp; heap = m_heapItem-&gt;timerHeap();
362     heap.append(m_heapItem.copyRef());
363     m_heapItem-&gt;setHeapIndex(heap.size() - 1);
364     heapDecreaseKey();
365 }
366 
367 inline void TimerBase::heapPop()
368 {
369     ASSERT(m_heapItem);
370     // Temporarily force this timer to have the minimum key so we can pop it.
371     MonotonicTime fireTime = m_heapItem-&gt;time;
372     m_heapItem-&gt;time = -MonotonicTime::infinity();
373     heapDecreaseKey();
374     heapPopMin();
375     m_heapItem-&gt;time = fireTime;
376 }
377 
378 void TimerBase::heapPopMin()
379 {
380     ASSERT(m_heapItem == m_heapItem-&gt;timerHeap().first());
381     checkHeapIndex();
382     auto&amp; heap = m_heapItem-&gt;timerHeap();
383     auto* heapData = heap.data();
384     pop_heap(TimerHeapIterator(heapData), TimerHeapIterator(heapData + heap.size()), TimerHeapLessThanFunction());
385     checkHeapIndex();
386     ASSERT(m_heapItem == m_heapItem-&gt;timerHeap().last());
387 }
388 
389 void TimerBase::heapDeleteNullMin(ThreadTimerHeap&amp; heap)
390 {
391     RELEASE_ASSERT(!heap.first()-&gt;hasTimer());
392     heap.first()-&gt;time = -MonotonicTime::infinity();
393     auto* heapData = heap.data();
394     pop_heap(TimerHeapIterator(heapData), TimerHeapIterator(heapData + heap.size()), TimerHeapLessThanFunction());
395     heap.removeLast();
396 }
397 
398 static inline bool parentHeapPropertyHolds(const TimerBase* current, const ThreadTimerHeap&amp; heap, unsigned currentIndex)
399 {
400     if (!currentIndex)
401         return true;
402     unsigned parentIndex = (currentIndex - 1) / 2;
403     return TimerHeapLessThanFunction::compare(*current, heap[parentIndex]);
404 }
405 
406 static inline bool childHeapPropertyHolds(const TimerBase* current, const ThreadTimerHeap&amp; heap, unsigned childIndex)
407 {
408     if (childIndex &gt;= heap.size())
409         return true;
410     return TimerHeapLessThanFunction::compare(heap[childIndex], *current);
411 }
412 
413 bool TimerBase::hasValidHeapPosition() const
414 {
415     ASSERT(nextFireTime());
416     ASSERT(m_heapItem);
417     if (!inHeap())
418         return false;
419     // Check if the heap property still holds with the new fire time. If it does we don&#39;t need to do anything.
420     // This assumes that the STL heap is a standard binary heap. In an unlikely event it is not, the assertions
421     // in updateHeapIfNeeded() will get hit.
422     const auto&amp; heap = m_heapItem-&gt;timerHeap();
423     unsigned heapIndex = m_heapItem-&gt;heapIndex();
424     if (!parentHeapPropertyHolds(this, heap, heapIndex))
425         return false;
426     unsigned childIndex1 = 2 * heapIndex + 1;
427     unsigned childIndex2 = childIndex1 + 1;
428     return childHeapPropertyHolds(this, heap, childIndex1) &amp;&amp; childHeapPropertyHolds(this, heap, childIndex2);
429 }
430 
431 void TimerBase::updateHeapIfNeeded(MonotonicTime oldTime)
432 {
433     auto fireTime = nextFireTime();
434     if (fireTime &amp;&amp; hasValidHeapPosition())
435         return;
436 
437 #if ASSERT_ENABLED
438     Optional&lt;unsigned&gt; oldHeapIndex;
439     if (m_heapItem-&gt;isInHeap())
440         oldHeapIndex = m_heapItem-&gt;heapIndex();
441 #endif
442 
443     if (!oldTime)
444         heapInsert();
445     else if (!fireTime)
446         heapDelete();
447     else if (fireTime &lt; oldTime)
448         heapDecreaseKey();
449     else
450         heapIncreaseKey();
451 
452 #if ASSERT_ENABLED
453     Optional&lt;unsigned&gt; newHeapIndex;
454     if (m_heapItem-&gt;isInHeap())
455         newHeapIndex = m_heapItem-&gt;heapIndex();
456     ASSERT(newHeapIndex != oldHeapIndex);
457 #endif
458 
459     ASSERT(!inHeap() || hasValidHeapPosition());
460 }
461 
462 void TimerBase::setNextFireTime(MonotonicTime newTime)
463 {
464     ASSERT(canCurrentThreadAccessThreadLocalData(m_thread));
465     RELEASE_ASSERT(canCurrentThreadAccessThreadLocalData(m_thread) || shouldSuppressThreadSafetyCheck());
466     bool timerHasBeenDeleted = std::isnan(m_unalignedNextFireTime);
467     RELEASE_ASSERT_WITH_SECURITY_IMPLICATION(!timerHasBeenDeleted);
468 
469     if (m_unalignedNextFireTime != newTime) {
470         RELEASE_ASSERT(!std::isnan(newTime));
471         m_unalignedNextFireTime = newTime;
472     }
473 
474     // Keep heap valid while changing the next-fire time.
475     MonotonicTime oldTime = nextFireTime();
476     // Don&#39;t realign zero-delay timers.
477     if (newTime) {
478         if (auto newAlignedTime = alignedFireTime(newTime))
479             newTime = newAlignedTime.value();
480     }
481 
482     if (oldTime != newTime) {
483         auto newOrder = threadGlobalData().threadTimers().nextHeapInsertionCount();
484 
485         if (!m_heapItem)
486             m_heapItem = ThreadTimerHeapItem::create(*this, newTime, 0);
487         m_heapItem-&gt;time = newTime;
488         m_heapItem-&gt;insertionOrder = newOrder;
489 
490         bool wasFirstTimerInHeap = m_heapItem-&gt;isFirstInHeap();
491 
492         updateHeapIfNeeded(oldTime);
493 
494         bool isFirstTimerInHeap = m_heapItem-&gt;isFirstInHeap();
495 
496         if (wasFirstTimerInHeap || isFirstTimerInHeap)
497             threadGlobalData().threadTimers().updateSharedTimer();
498     }
499 
500     checkConsistency();
501 }
502 
503 void TimerBase::fireTimersInNestedEventLoop()
504 {
505     // Redirect to ThreadTimers.
506     threadGlobalData().threadTimers().fireTimersInNestedEventLoop();
507 }
508 
509 void TimerBase::didChangeAlignmentInterval()
510 {
511     setNextFireTime(m_unalignedNextFireTime);
512 }
513 
514 Seconds TimerBase::nextUnalignedFireInterval() const
515 {
516     ASSERT(isActive());
517     auto result = std::max(m_unalignedNextFireTime - MonotonicTime::now(), 0_s);
518     RELEASE_ASSERT(std::isfinite(result));
519     return result;
520 }
521 
522 } // namespace WebCore
523 
    </pre>
  </body>
</html>
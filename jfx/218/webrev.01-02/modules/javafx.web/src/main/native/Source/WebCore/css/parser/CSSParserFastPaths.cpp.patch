diff a/modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserFastPaths.cpp b/modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserFastPaths.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserFastPaths.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserFastPaths.cpp
@@ -62,10 +62,13 @@
     case CSSPropertyMinBlockSize:
     case CSSPropertyPaddingBlockEnd:
     case CSSPropertyPaddingBlockStart:
     case CSSPropertyPaddingInlineEnd:
     case CSSPropertyPaddingInlineStart:
+    case CSSPropertyR:
+    case CSSPropertyRx:
+    case CSSPropertyRy:
     case CSSPropertyShapeMargin:
         acceptsNegativeNumbers = false;
         return true;
     case CSSPropertyBottom:
     case CSSPropertyCx:
@@ -85,29 +88,26 @@
     case CSSPropertyMarginBlockStart:
     case CSSPropertyMarginInlineEnd:
     case CSSPropertyMarginInlineStart:
     case CSSPropertyX:
     case CSSPropertyY:
-    case CSSPropertyR:
-    case CSSPropertyRx:
-    case CSSPropertyRy:
         acceptsNegativeNumbers = true;
         return true;
     default:
         return false;
     }
 }
 
 template <typename CharacterType>
-static inline bool parseSimpleLength(const CharacterType* characters, unsigned length, CSSPrimitiveValue::UnitType& unit, double& number)
+static inline bool parseSimpleLength(const CharacterType* characters, unsigned length, CSSUnitType& unit, double& number)
 {
     if (length > 2 && (characters[length - 2] | 0x20) == 'p' && (characters[length - 1] | 0x20) == 'x') {
         length -= 2;
-        unit = CSSPrimitiveValue::UnitType::CSS_PX;
+        unit = CSSUnitType::CSS_PX;
     } else if (length > 1 && characters[length - 1] == '%') {
         length -= 1;
-        unit = CSSPrimitiveValue::UnitType::CSS_PERCENTAGE;
+        unit = CSSUnitType::CSS_PERCENTAGE;
     }
 
     // We rely on charactersToDouble for validation as well. The function
     // will set "ok" to "false" if the entire passed-in character range does
     // not represent a double.
@@ -117,22 +117,22 @@
         return false;
     return true;
 }
 
 template <typename CharacterType>
-static inline bool parseSimpleAngle(const CharacterType* characters, unsigned length, CSSPrimitiveValue::UnitType& unit, double& number)
+static inline bool parseSimpleAngle(const CharacterType* characters, unsigned length, CSSUnitType& unit, double& number)
 {
     // Just support deg and rad for now.
     if (length < 4)
         return false;
 
     if ((characters[length - 3] | 0x20) == 'd' && (characters[length - 2] | 0x20) == 'e' && (characters[length - 1] | 0x20) == 'g') {
         length -= 3;
-        unit = CSSPrimitiveValue::UnitType::CSS_DEG;
+        unit = CSSUnitType::CSS_DEG;
     } else if ((characters[length - 3] | 0x20) == 'r' && (characters[length - 2] | 0x20) == 'a' && (characters[length - 1] | 0x20) == 'd') {
         length -= 3;
-        unit = CSSPrimitiveValue::UnitType::CSS_RAD;
+        unit = CSSUnitType::CSS_RAD;
     } else
         return false;
 
     // We rely on charactersToDouble for validation as well. The function
     // will set "ok" to "false" if the entire passed-in character range does
@@ -153,24 +153,24 @@
     if (isCSSViewportParsingEnabledForMode(cssParserMode) || !isSimpleLengthPropertyID(propertyId, acceptsNegativeNumbers))
         return nullptr;
 
     unsigned length = string.length();
     double number;
-    CSSPrimitiveValue::UnitType unit = CSSPrimitiveValue::UnitType::CSS_NUMBER;
+    CSSUnitType unit = CSSUnitType::CSS_NUMBER;
 
     if (string.is8Bit()) {
         if (!parseSimpleLength(string.characters8(), length, unit, number))
             return nullptr;
     } else {
         if (!parseSimpleLength(string.characters16(), length, unit, number))
             return nullptr;
     }
 
-    if (unit == CSSPrimitiveValue::UnitType::CSS_NUMBER) {
+    if (unit == CSSUnitType::CSS_NUMBER) {
         if (number && cssParserMode != SVGAttributeMode)
             return nullptr;
-        unit = CSSPrimitiveValue::UnitType::CSS_PX;
+        unit = CSSUnitType::CSS_PX;
     }
 
     if (number < 0 && !acceptsNegativeNumbers)
         return nullptr;
     if (std::isinf(number))
@@ -278,11 +278,11 @@
     value = localValue + fraction / scale;
     return length;
 }
 
 template <typename CharacterType>
-static bool parseColorIntOrPercentage(const CharacterType*& string, const CharacterType* end, const char terminator, CSSPrimitiveValue::UnitType& expect, int& value)
+static bool parseColorIntOrPercentage(const CharacterType*& string, const CharacterType* end, const char terminator, CSSUnitType& expect, int& value)
 {
     const CharacterType* current = string;
     double localValue = 0;
     bool negative = false;
     while (current != end && isHTMLSpace<CharacterType>(*current))
@@ -306,11 +306,11 @@
     }
 
     if (current == end)
         return false;
 
-    if (expect == CSSPrimitiveValue::UnitType::CSS_NUMBER && (*current == '.' || *current == '%'))
+    if (expect == CSSUnitType::CSS_NUMBER && (*current == '.' || *current == '%'))
         return false;
 
     if (*current == '.') {
         // We already parsed the integral part, try to parse
         // the fraction part of the percentage value.
@@ -322,22 +322,22 @@
         if (*current != '%')
             return false;
         localValue += percentage;
     }
 
-    if (expect == CSSPrimitiveValue::UnitType::CSS_PERCENTAGE && *current != '%')
+    if (expect == CSSUnitType::CSS_PERCENTAGE && *current != '%')
         return false;
 
     if (*current == '%') {
-        expect = CSSPrimitiveValue::UnitType::CSS_PERCENTAGE;
-        localValue = localValue / 100.0 * 256.0;
+        expect = CSSUnitType::CSS_PERCENTAGE;
+        localValue = localValue / 100.0 * 255.0;
         // Clamp values at 255 for percentages over 100%
         if (localValue > 255)
             localValue = 255;
         current++;
     } else {
-        expect = CSSPrimitiveValue::UnitType::CSS_NUMBER;
+        expect = CSSUnitType::CSS_NUMBER;
     }
 
     while (current != end && isHTMLSpace<CharacterType>(*current))
         current++;
     if (current == end || *current++ != terminator)
@@ -398,20 +398,22 @@
         string = end;
         return true;
     }
 
     if (isTenthAlpha(string, length - 1)) {
-        static const int tenthAlphaValues[] = { 0, 25, 51, 76, 102, 127, 153, 179, 204, 230 };
+        static const int tenthAlphaValues[] = { 0, 26, 51, 77, 102, 128, 153, 179, 204, 230 };
         value = negative ? 0 : tenthAlphaValues[string[length - 2] - '0'];
         string = end;
         return true;
     }
 
     double alpha = 0;
     if (!parseDouble(string, end, terminator, alpha))
         return false;
-    value = negative ? 0 : static_cast<int>(alpha * nextafter(256.0, 0.0));
+
+    // W3 standard stipulates a 2.55 alpha value multiplication factor.
+    value = negative ? 0 : static_cast<int>(lroundf(clampTo<double>(alpha, 0.0, 1.0) * 255.0f));
     string = end;
     return true;
 }
 
 template <typename CharacterType>
@@ -438,11 +440,11 @@
 }
 
 template <typename CharacterType>
 static Color fastParseColorInternal(const CharacterType* characters, unsigned length, bool quirksMode)
 {
-    CSSPrimitiveValue::UnitType expect = CSSPrimitiveValue::UnitType::CSS_UNKNOWN;
+    CSSUnitType expect = CSSUnitType::CSS_UNKNOWN;
 
     if (length >= 4 && characters[0] == '#') {
         RGBA32 rgb;
         if (Color::parseHexColor(characters + 1, length - 1, rgb))
             return Color(rgb);
@@ -495,18 +497,18 @@
     }
 
     return Color();
 }
 
-RefPtr<CSSValue> CSSParserFastPaths::parseColor(const String& string, CSSParserMode parserMode)
+RefPtr<CSSValue> CSSParserFastPaths::parseColor(const String& string, CSSParserMode parserMode, CSSValuePool& valuePool)
 {
     ASSERT(!string.isEmpty());
     CSSValueID valueID = cssValueKeywordID(string);
     if (StyleColor::isColorKeyword(valueID)) {
         if (!isValueAllowedInMode(valueID, parserMode))
             return nullptr;
-        return CSSValuePool::singleton().createIdentifierValue(valueID);
+        return valuePool.createIdentifierValue(valueID);
     }
 
     bool quirksMode = isQuirksModeBehavior(parserMode);
 
     // Fast path for hex colors and rgb()/rgba() colors
@@ -515,11 +517,11 @@
         color = fastParseColorInternal(string.characters8(), string.length(), quirksMode);
     else
         color = fastParseColorInternal(string.characters16(), string.length(), quirksMode);
     if (!color.isValid())
         return nullptr;
-    return CSSValuePool::singleton().createColorValue(color);
+    return valuePool.createColorValue(color);
 }
 
 bool CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyID propertyId, CSSValueID valueID, const CSSParserContext& context)
 {
 #if !ENABLE(OVERFLOW_SCROLLING_TOUCH)
@@ -587,10 +589,12 @@
             || (valueID >= CSSValueCentral && valueID <= CSSValueMathematical);
     case CSSPropertyEmptyCells: // show | hide
         return valueID == CSSValueShow || valueID == CSSValueHide;
     case CSSPropertyFloat: // left | right | none
         return valueID == CSSValueLeft || valueID == CSSValueRight || valueID == CSSValueNone;
+    case CSSPropertyImageOrientation: // from-image | none
+        return valueID == CSSValueFromImage || valueID == CSSValueNone;
     case CSSPropertyImageRendering: // auto | optimizeContrast | pixelated | optimizeSpeed | crispEdges | optimizeQuality | webkit-crispEdges
         return valueID == CSSValueAuto || valueID == CSSValueOptimizeSpeed || valueID == CSSValueOptimizeQuality || valueID == CSSValueWebkitCrispEdges || valueID == CSSValueWebkitOptimizeContrast || valueID == CSSValueCrispEdges || valueID == CSSValuePixelated;
 #if ENABLE(CSS_COMPOSITING)
     case CSSPropertyIsolation: // auto | isolate
         return valueID == CSSValueAuto || valueID == CSSValueIsolate;
@@ -623,23 +627,19 @@
     case CSSPropertyBreakInside:
         return valueID == CSSValueAuto || valueID == CSSValueAvoid || valueID == CSSValueAvoidPage || valueID == CSSValueAvoidColumn;
     case CSSPropertyPointerEvents:
         // none | visiblePainted | visibleFill | visibleStroke | visible |
         // painted | fill | stroke | auto | all | bounding-box
-        return valueID == CSSValueVisible || valueID == CSSValueNone || valueID == CSSValueAll || valueID == CSSValueAuto || (valueID >= CSSValueVisiblePainted && valueID <= CSSValueStroke);
+        return valueID == CSSValueVisible || valueID == CSSValueNone || valueID == CSSValueAll || valueID == CSSValueAuto || valueID == CSSValueBoundingBox || (valueID >= CSSValueVisiblePainted && valueID <= CSSValueStroke);
     case CSSPropertyPosition: // static | relative | absolute | fixed | sticky
         return valueID == CSSValueStatic
             || valueID == CSSValueRelative
             || valueID == CSSValueAbsolute
             || valueID == CSSValueFixed
             || valueID == CSSValueSticky || valueID == CSSValueWebkitSticky;
     case CSSPropertyResize: // none | both | horizontal | vertical | auto
         return valueID == CSSValueNone || valueID == CSSValueBoth || valueID == CSSValueHorizontal || valueID == CSSValueVertical || valueID == CSSValueAuto;
-    // FIXME-NEWPARSER: Investigate this property.
-    // case CSSPropertyScrollBehavior: // auto | smooth
-    //     ASSERT(RuntimeEnabledFeatures::cssomSmoothScrollEnabled());
-    //   return valueID == CSSValueAuto || valueID == CSSValueSmooth;
     case CSSPropertyShapeRendering:
         return valueID == CSSValueAuto || valueID == CSSValueOptimizeSpeed || valueID == CSSValueCrispedges || valueID == CSSValueGeometricPrecision;
     case CSSPropertyStrokeLinejoin:
         return valueID == CSSValueMiter || valueID == CSSValueRound || valueID == CSSValueBevel;
     case CSSPropertyStrokeLinecap:
@@ -853,10 +853,11 @@
     case CSSPropertyFlexWrap:
     case CSSPropertyFloat:
     case CSSPropertyFontVariantAlternates:
     case CSSPropertyFontVariantCaps:
     case CSSPropertyFontVariantPosition:
+    case CSSPropertyImageOrientation:
     case CSSPropertyImageRendering:
     case CSSPropertyListStylePosition:
     case CSSPropertyListStyleType:
     case CSSPropertyObjectFit:
     case CSSPropertyOutlineStyle:
@@ -935,11 +936,10 @@
     // FIXME-NEWPARSER: Add the following unprefixed properties:
     // case CSSPropertyBackfaceVisibility:
     // case CSSPropertyFontKerning:
     // case CSSPropertyHyphens:
     // case CSSPropertyOverflowAnchor:
-    // case CSSPropertyScrollBehavior:
     // case CSSPropertyScrollSnapType:
     // case CSSPropertyTextAlignLast:
     // case CSSPropertyTextCombineUpright:
     // case CSSPropertyTextDecorationStyle:
     // case CSSPropertyTextJustify:
@@ -1035,17 +1035,17 @@
     while (expectedCount) {
         size_t delimiter = WTF::find(pos, end - pos, expectedCount == 1 ? ')' : ',');
         if (delimiter == notFound)
             return false;
         unsigned argumentLength = static_cast<unsigned>(delimiter);
-        CSSPrimitiveValue::UnitType unit = CSSPrimitiveValue::UnitType::CSS_NUMBER;
+        CSSUnitType unit = CSSUnitType::CSS_NUMBER;
         double number;
         if (!parseSimpleLength(pos, argumentLength, unit, number))
             return false;
-        if (!number && unit == CSSPrimitiveValue::CSS_NUMBER)
-            unit = CSSPrimitiveValue::UnitType::CSS_PX;
-        if (unit == CSSPrimitiveValue::UnitType::CSS_NUMBER || (unit == CSSPrimitiveValue::UnitType::CSS_PERCENTAGE && (transformValue->name() == CSSValueTranslateZ || (transformValue->name() == CSSValueTranslate3d && expectedCount == 1))))
+        if (!number && unit == CSSUnitType::CSS_NUMBER)
+            unit = CSSUnitType::CSS_PX;
+        if (unit == CSSUnitType::CSS_NUMBER || (unit == CSSUnitType::CSS_PERCENTAGE && (transformValue->name() == CSSValueTranslateZ || (transformValue->name() == CSSValueTranslate3d && expectedCount == 1))))
             return false;
         transformValue->append(CSSPrimitiveValue::create(number, unit));
         pos += argumentLength + 1;
         --expectedCount;
     }
@@ -1058,16 +1058,16 @@
     size_t delimiter = WTF::find(pos, end - pos, ')');
     if (delimiter == notFound)
         return false;
 
     unsigned argumentLength = static_cast<unsigned>(delimiter);
-    CSSPrimitiveValue::UnitType unit = CSSPrimitiveValue::UnitType::CSS_NUMBER;
+    CSSUnitType unit = CSSUnitType::CSS_NUMBER;
     double number;
     if (!parseSimpleAngle(pos, argumentLength, unit, number))
         return false;
-    if (!number && unit == CSSPrimitiveValue::CSS_NUMBER)
-        unit = CSSPrimitiveValue::UnitType::CSS_DEG;
+    if (!number && unit == CSSUnitType::CSS_NUMBER)
+        unit = CSSUnitType::CSS_DEG;
 
     transformValue->append(CSSPrimitiveValue::create(number, unit));
     pos += argumentLength + 1;
 
     return true;
@@ -1083,11 +1083,11 @@
         unsigned argumentLength = static_cast<unsigned>(delimiter);
         bool ok;
         double number = charactersToDouble(pos, argumentLength, &ok);
         if (!ok)
             return false;
-        transformValue->append(CSSPrimitiveValue::create(number, CSSPrimitiveValue::UnitType::CSS_NUMBER));
+        transformValue->append(CSSPrimitiveValue::create(number, CSSUnitType::CSS_NUMBER));
         pos += argumentLength + 1;
         --expectedCount;
     }
     return true;
 }
@@ -1298,21 +1298,21 @@
 {
     ASSERT(!string.isEmpty());
     CSSValueID valueID = cssValueKeywordID(string);
     if (valueID == CSSValueAuto)
         return CSSValuePool::singleton().createIdentifierValue(valueID);
-    return CSSParserFastPaths::parseColor(string, parserMode);
+    return CSSParserFastPaths::parseColor(string, parserMode, CSSValuePool::singleton());
 }
 
 RefPtr<CSSValue> CSSParserFastPaths::maybeParseValue(CSSPropertyID propertyID, const String& string, const CSSParserContext& context)
 {
     if (auto result = parseSimpleLengthValue(propertyID, string, context.mode))
         return result;
     if (propertyID == CSSPropertyCaretColor)
         return parseCaretColor(string, context.mode);
     if (isColorPropertyID(propertyID))
-        return parseColor(string, context.mode);
+        return parseColor(string, context.mode, CSSValuePool::singleton());
     if (auto result = parseKeywordValue(propertyID, string, context))
         return result;
     return parseSimpleTransform(propertyID, string);
 }
 

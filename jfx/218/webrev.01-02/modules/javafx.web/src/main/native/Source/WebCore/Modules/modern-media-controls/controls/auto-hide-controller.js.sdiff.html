<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/modern-media-controls/controls/auto-hide-controller.js</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../mediastream/libwebrtc/LibWebRTCUtils.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="slider.js.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/modern-media-controls/controls/auto-hide-controller.js</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 const AutoHideDelayMS = 4000;
 27 
 28 class AutoHideController
 29 {
 30 
 31     constructor(mediaControls)
 32     {
 33         this._mediaControls = mediaControls;
 34 
<span class="line-modified"> 35         if (GestureRecognizer.SupportsTouches) {</span>
<span class="line-modified"> 36             this._touchIdentifiersPreventingAutoHide = new Set;</span>


 37             this._tapGestureRecognizer = new TapGestureRecognizer(this._mediaControls.element, this);
<span class="line-removed"> 38         }</span>
 39 
 40         this.autoHideDelay = AutoHideDelayMS;
 41     }
 42 
 43     // Public
 44 
 45     get fadesWhileIdle()
 46     {
 47         return this._fadesWhileIdle;
 48     }
 49 
 50     set fadesWhileIdle(flag)
 51     {
 52         if (this._fadesWhileIdle == flag)
 53             return;
 54 
 55         this._fadesWhileIdle = flag;
 56 
<span class="line-modified"> 57         if (GestureRecognizer.SupportsTouches) {</span>
<span class="line-modified"> 58             if (flag) {</span>
<span class="line-modified"> 59                 this._mediaControls.element.addEventListener(&quot;touchstart&quot;, this);</span>
<span class="line-modified"> 60                 this._mediaControls.element.addEventListener(&quot;touchend&quot;, this);</span>
<span class="line-modified"> 61             } else {</span>
<span class="line-modified"> 62                 this._mediaControls.element.removeEventListener(&quot;touchstart&quot;, this);</span>
<span class="line-removed"> 63                 this._mediaControls.element.removeEventListener(&quot;touchend&quot;, this);</span>
<span class="line-removed"> 64             }</span>
<span class="line-removed"> 65             this._tapGestureRecognizer.enabled = flag;</span>
 66         } else {
<span class="line-modified"> 67             if (flag) {</span>
<span class="line-modified"> 68                 this._mediaControls.element.addEventListener(&quot;mousemove&quot;, this);</span>
<span class="line-modified"> 69                 this._mediaControls.element.addEventListener(&quot;mouseleave&quot;, this);</span>
<span class="line-modified"> 70             } else {</span>
<span class="line-modified"> 71                 this._mediaControls.element.removeEventListener(&quot;mousemove&quot;, this);</span>
<span class="line-removed"> 72                 this._mediaControls.element.removeEventListener(&quot;mouseleave&quot;, this);</span>
<span class="line-removed"> 73             }</span>
 74         }
 75 
 76         if (flag &amp;&amp; !this._mediaControls.faded)
 77             this._resetAutoHideTimer(false);
 78         else if (!flag)
 79             this._mediaControls.faded = false;
 80     }
 81 
 82     // Protected
 83 
 84     handleEvent(event)
 85     {
 86         if (event.currentTarget !== this._mediaControls.element)
 87             return;
 88 
<span class="line-modified"> 89         if (event.type === &quot;mousemove&quot;) {</span>
 90             this._mediaControls.faded = false;
 91             this._resetAutoHideTimer(true);
 92             if (this._mediaControls.isPointInControls(new DOMPoint(event.clientX, event.clientY))) {
<span class="line-modified"> 93                 this._disableAutoHiding = true;</span>
 94                 this._cancelNonEnforcedAutoHideTimer();
 95             } else {
<span class="line-modified"> 96                 delete this._disableAutoHiding;</span>
 97                 this._resetAutoHideTimer(true);
 98             }
<span class="line-modified"> 99         } else if (event.type === &quot;mouseleave&quot; &amp;&amp; this._fadesWhileIdle &amp;&amp; !this.hasSecondaryUIAttached &amp;&amp; !this._enforceAutoHideTimer)</span>
<span class="line-modified">100             this._mediaControls.faded = !this._mediaControls.isPointInControls(new DOMPoint(event.clientX, event.clientY));</span>






101 
<span class="line-modified">102         if (event.type === &quot;touchstart&quot;) {</span>



103             // Remember the current faded state so that we can determine,
104             // if we recognize a tap, if it should fade the controls out.
105             this._nextTapCanFadeControls = !this._mediaControls.faded;
<span class="line-modified">106             for (var touch in event.changedTouches)</span>
<span class="line-removed">107                 this._touchIdentifiersPreventingAutoHide.add(touch.identifier);</span>
108             this._mediaControls.faded = false;
<span class="line-removed">109             this._disableAutoHiding = true;</span>
110             this._cancelNonEnforcedAutoHideTimer();
<span class="line-modified">111         } else if (event.type === &quot;touchend&quot;) {</span>
<span class="line-modified">112             for (var touch in event.changedTouches)</span>
<span class="line-modified">113                 this._touchIdentifiersPreventingAutoHide.delete(touch.identifier);</span>
<span class="line-removed">114             if (!this._touchIdentifiersPreventingAutoHide.size) {</span>
<span class="line-removed">115                 delete this._disableAutoHiding;</span>
<span class="line-removed">116                 this._resetAutoHideTimer(true);</span>
<span class="line-removed">117             }</span>
118         }
119     }
120 
121     gestureRecognizerStateDidChange(recognizer)
122     {
123         if (this._tapGestureRecognizer !== recognizer || recognizer.state !== GestureRecognizer.States.Recognized)
124             return;
125 
126         this._mediaControls.faded = this._nextTapCanFadeControls &amp;&amp; !this._mediaControls.isPointInControls(recognizer.locationInClient());
127         delete this._nextTapCanFadeControls;
128     }
129 
130     mediaControlsFadedStateDidChange()
131     {
132         if (this._mediaControls.faded)
133             delete this._enforceAutoHideTimer;
134         else
135             this._resetAutoHideTimer(true);
136     }
137 
</pre>
<hr />
<pre>
154         delete this._autoHideTimer;
155     }
156 
157     _resetAutoHideTimer(cancelable)
158     {
159         if (cancelable &amp;&amp; this._enforceAutoHideTimer)
160             return;
161 
162         this._cancelAutoHideTimer();
163 
164         if (cancelable)
165             delete this._enforceAutoHideTimer;
166         else
167             this._enforceAutoHideTimer = true;
168 
169         this._autoHideTimer = window.setTimeout(this._autoHideTimerFired.bind(this), this.autoHideDelay);
170     }
171 
172     _autoHideTimerFired()
173     {


174         delete this._enforceAutoHideTimer;
<span class="line-modified">175         if (this._disableAutoHiding)</span>
176             return;
177 
178         this._cancelAutoHideTimer();
179         this._mediaControls.faded = this._fadesWhileIdle &amp;&amp; !this.hasSecondaryUIAttached;
180     }
181 
182 }
</pre>
</td>
<td>
<hr />
<pre>
 15  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
 17  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 18  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 19  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 20  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 21  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 22  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 23  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 const AutoHideDelayMS = 4000;
 27 
 28 class AutoHideController
 29 {
 30 
 31     constructor(mediaControls)
 32     {
 33         this._mediaControls = mediaControls;
 34 
<span class="line-modified"> 35         this._pointerIdentifiersPreventingAutoHide = new Set;</span>
<span class="line-modified"> 36         this._pointerIdentifiersPreventingAutoHideForHover = new Set;</span>
<span class="line-added"> 37 </span>
<span class="line-added"> 38         if (GestureRecognizer.SupportsTouches)</span>
 39             this._tapGestureRecognizer = new TapGestureRecognizer(this._mediaControls.element, this);

 40 
 41         this.autoHideDelay = AutoHideDelayMS;
 42     }
 43 
 44     // Public
 45 
 46     get fadesWhileIdle()
 47     {
 48         return this._fadesWhileIdle;
 49     }
 50 
 51     set fadesWhileIdle(flag)
 52     {
 53         if (this._fadesWhileIdle == flag)
 54             return;
 55 
 56         this._fadesWhileIdle = flag;
 57 
<span class="line-modified"> 58         if (flag) {</span>
<span class="line-modified"> 59             this._mediaControls.element.addEventListener(&quot;pointermove&quot;, this);</span>
<span class="line-modified"> 60             this._mediaControls.element.addEventListener(&quot;pointerdown&quot;, this);</span>
<span class="line-modified"> 61             this._mediaControls.element.addEventListener(&quot;pointerup&quot;, this);</span>
<span class="line-modified"> 62             this._mediaControls.element.addEventListener(&quot;pointerleave&quot;, this);</span>
<span class="line-modified"> 63             this._mediaControls.element.addEventListener(&quot;pointerout&quot;, this);</span>



 64         } else {
<span class="line-modified"> 65             this._mediaControls.element.removeEventListener(&quot;pointermove&quot;, this);</span>
<span class="line-modified"> 66             this._mediaControls.element.removeEventListener(&quot;pointerdown&quot;, this);</span>
<span class="line-modified"> 67             this._mediaControls.element.removeEventListener(&quot;pointerup&quot;, this);</span>
<span class="line-modified"> 68             this._mediaControls.element.removeEventListener(&quot;pointerleave&quot;, this);</span>
<span class="line-modified"> 69             this._mediaControls.element.removeEventListener(&quot;pointerout&quot;, this);</span>


 70         }
 71 
 72         if (flag &amp;&amp; !this._mediaControls.faded)
 73             this._resetAutoHideTimer(false);
 74         else if (!flag)
 75             this._mediaControls.faded = false;
 76     }
 77 
 78     // Protected
 79 
 80     handleEvent(event)
 81     {
 82         if (event.currentTarget !== this._mediaControls.element)
 83             return;
 84 
<span class="line-modified"> 85         if (event.type === &quot;pointermove&quot;) {</span>
 86             this._mediaControls.faded = false;
 87             this._resetAutoHideTimer(true);
 88             if (this._mediaControls.isPointInControls(new DOMPoint(event.clientX, event.clientY))) {
<span class="line-modified"> 89                 this._pointerIdentifiersPreventingAutoHideForHover.add(event.pointerId);</span>
 90                 this._cancelNonEnforcedAutoHideTimer();
 91             } else {
<span class="line-modified"> 92                 this._pointerIdentifiersPreventingAutoHideForHover.delete(event.pointerId);</span>
 93                 this._resetAutoHideTimer(true);
 94             }
<span class="line-modified"> 95         } else if (event.type === &quot;pointerleave&quot; &amp;&amp; this._fadesWhileIdle &amp;&amp; !this.hasSecondaryUIAttached &amp;&amp; !this._enforceAutoHideTimer) {</span>
<span class="line-modified"> 96             this._pointerIdentifiersPreventingAutoHide.delete(event.pointerId);</span>
<span class="line-added"> 97             this._pointerIdentifiersPreventingAutoHideForHover.delete(event.pointerId);</span>
<span class="line-added"> 98 </span>
<span class="line-added"> 99             // If the pointer is a mouse (supports hover), see if we can</span>
<span class="line-added">100             // immediately hide without waiting for the auto-hide timer.</span>
<span class="line-added">101             if (event.pointerType == &quot;mouse&quot;)</span>
<span class="line-added">102                 this._autoHideTimerFired();</span>
103 
<span class="line-modified">104             this._resetAutoHideTimer(true);</span>
<span class="line-added">105         }</span>
<span class="line-added">106 </span>
<span class="line-added">107         if (event.type === &quot;pointerdown&quot;) {</span>
108             // Remember the current faded state so that we can determine,
109             // if we recognize a tap, if it should fade the controls out.
110             this._nextTapCanFadeControls = !this._mediaControls.faded;
<span class="line-modified">111             this._pointerIdentifiersPreventingAutoHide.add(event.pointerId);</span>

112             this._mediaControls.faded = false;

113             this._cancelNonEnforcedAutoHideTimer();
<span class="line-modified">114         } else if (event.type === &quot;pointerup&quot;) {</span>
<span class="line-modified">115             this._pointerIdentifiersPreventingAutoHide.delete(event.pointerId);</span>
<span class="line-modified">116             this._resetAutoHideTimer(true);</span>




117         }
118     }
119 
120     gestureRecognizerStateDidChange(recognizer)
121     {
122         if (this._tapGestureRecognizer !== recognizer || recognizer.state !== GestureRecognizer.States.Recognized)
123             return;
124 
125         this._mediaControls.faded = this._nextTapCanFadeControls &amp;&amp; !this._mediaControls.isPointInControls(recognizer.locationInClient());
126         delete this._nextTapCanFadeControls;
127     }
128 
129     mediaControlsFadedStateDidChange()
130     {
131         if (this._mediaControls.faded)
132             delete this._enforceAutoHideTimer;
133         else
134             this._resetAutoHideTimer(true);
135     }
136 
</pre>
<hr />
<pre>
153         delete this._autoHideTimer;
154     }
155 
156     _resetAutoHideTimer(cancelable)
157     {
158         if (cancelable &amp;&amp; this._enforceAutoHideTimer)
159             return;
160 
161         this._cancelAutoHideTimer();
162 
163         if (cancelable)
164             delete this._enforceAutoHideTimer;
165         else
166             this._enforceAutoHideTimer = true;
167 
168         this._autoHideTimer = window.setTimeout(this._autoHideTimerFired.bind(this), this.autoHideDelay);
169     }
170 
171     _autoHideTimerFired()
172     {
<span class="line-added">173         const disableAutoHiding = this._pointerIdentifiersPreventingAutoHide.size || this._pointerIdentifiersPreventingAutoHideForHover.size;</span>
<span class="line-added">174 </span>
175         delete this._enforceAutoHideTimer;
<span class="line-modified">176         if (disableAutoHiding)</span>
177             return;
178 
179         this._cancelAutoHideTimer();
180         this._mediaControls.faded = this._fadesWhileIdle &amp;&amp; !this.hasSecondaryUIAttached;
181     }
182 
183 }
</pre>
</td>
</tr>
</table>
<center><a href="../../mediastream/libwebrtc/LibWebRTCUtils.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="slider.js.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
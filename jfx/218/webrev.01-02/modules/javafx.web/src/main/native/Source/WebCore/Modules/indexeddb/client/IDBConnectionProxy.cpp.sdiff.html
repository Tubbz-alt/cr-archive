<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/client/IDBConnectionProxy.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../IndexedDB.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="IDBConnectionProxy.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/Modules/indexeddb/client/IDBConnectionProxy.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 98 }
 99 
100 void IDBConnectionProxy::didDeleteDatabase(const IDBResultData&amp; resultData)
101 {
102     completeOpenDBRequest(resultData);
103 }
104 
105 void IDBConnectionProxy::completeOpenDBRequest(const IDBResultData&amp; resultData)
106 {
107     ASSERT(isMainThread());
108 
109     RefPtr&lt;IDBOpenDBRequest&gt; request;
110     {
111         Locker&lt;Lock&gt; locker(m_openDBRequestMapLock);
112         request = m_openDBRequestMap.take(resultData.requestIdentifier());
113     }
114 
115     if (!request)
116         return;
117 













118     request-&gt;performCallbackOnOriginThread(*request, &amp;IDBOpenDBRequest::requestCompleted, resultData);
119 }
120 
121 void IDBConnectionProxy::createObjectStore(TransactionOperation&amp; operation, const IDBObjectStoreInfo&amp; info)
122 {
123     const IDBRequestData requestData { operation };
124     saveOperation(operation);
125 
126     callConnectionOnMainThread(&amp;IDBConnectionToServer::createObjectStore, requestData, info);
127 }
128 
129 void IDBConnectionProxy::renameObjectStore(TransactionOperation&amp; operation, uint64_t objectStoreIdentifier, const String&amp; newName)
130 {
131     const IDBRequestData requestData { operation };
132     saveOperation(operation);
133 
134     callConnectionOnMainThread(&amp;IDBConnectionToServer::renameObjectStore, requestData, objectStoreIdentifier, newName);
135 }
136 
137 void IDBConnectionProxy::renameIndex(TransactionOperation&amp; operation, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
</pre>
<hr />
<pre>
208 
209 void IDBConnectionProxy::deleteRecord(TransactionOperation&amp; operation, const IDBKeyRangeData&amp; keyRange)
210 {
211     const IDBRequestData requestData { operation };
212     saveOperation(operation);
213 
214     callConnectionOnMainThread(&amp;IDBConnectionToServer::deleteRecord, requestData, keyRange);
215 }
216 
217 void IDBConnectionProxy::openCursor(TransactionOperation&amp; operation, const IDBCursorInfo&amp; info)
218 {
219     const IDBRequestData requestData { operation };
220     saveOperation(operation);
221 
222     callConnectionOnMainThread(&amp;IDBConnectionToServer::openCursor, requestData, info);
223 }
224 
225 void IDBConnectionProxy::iterateCursor(TransactionOperation&amp; operation, const IDBIterateCursorData&amp; data)
226 {
227     const IDBRequestData requestData { operation };
<span class="line-modified">228     saveOperation(operation);</span>

229 
230     callConnectionOnMainThread(&amp;IDBConnectionToServer::iterateCursor, requestData, data);
231 }
232 
233 void IDBConnectionProxy::saveOperation(TransactionOperation&amp; operation)
234 {
235     Locker&lt;Lock&gt; locker(m_transactionOperationLock);
236 
237     ASSERT(!m_activeOperations.contains(operation.identifier()));
238     m_activeOperations.set(operation.identifier(), &amp;operation);
239 }
240 
241 void IDBConnectionProxy::completeOperation(const IDBResultData&amp; resultData)
242 {
243     RefPtr&lt;TransactionOperation&gt; operation;
244     {
245         Locker&lt;Lock&gt; locker(m_transactionOperationLock);
246         operation = m_activeOperations.take(resultData.requestIdentifier());
247     }
248 
</pre>
<hr />
<pre>
251 
252     operation-&gt;transitionToComplete(resultData, WTFMove(operation));
253 }
254 
255 void IDBConnectionProxy::abortOpenAndUpgradeNeeded(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
256 {
257     callConnectionOnMainThread(&amp;IDBConnectionToServer::abortOpenAndUpgradeNeeded, databaseConnectionIdentifier, transactionIdentifier);
258 }
259 
260 void IDBConnectionProxy::fireVersionChangeEvent(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; requestIdentifier, uint64_t requestedVersion)
261 {
262     RefPtr&lt;IDBDatabase&gt; database;
263     {
264         Locker&lt;Lock&gt; locker(m_databaseConnectionMapLock);
265         database = m_databaseConnectionMap.get(databaseConnectionIdentifier);
266     }
267 
268     if (!database)
269         return;
270 






271     database-&gt;performCallbackOnOriginThread(*database, &amp;IDBDatabase::fireVersionChangeEvent, requestIdentifier, requestedVersion);
272 }
273 
<span class="line-modified">274 void IDBConnectionProxy::didFireVersionChangeEvent(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; requestIdentifier)</span>
275 {
<span class="line-modified">276     callConnectionOnMainThread(&amp;IDBConnectionToServer::didFireVersionChangeEvent, databaseConnectionIdentifier, requestIdentifier);</span>
277 }
278 
279 void IDBConnectionProxy::notifyOpenDBRequestBlocked(const IDBResourceIdentifier&amp; requestIdentifier, uint64_t oldVersion, uint64_t newVersion)
280 {
281     ASSERT(isMainThread());
282 
283     RefPtr&lt;IDBOpenDBRequest&gt; request;
284     {
285         Locker&lt;Lock&gt; locker(m_openDBRequestMapLock);
286         request = m_openDBRequestMap.get(requestIdentifier);
287     }
288 
289     if (!request)
290         return;
291 
292     request-&gt;performCallbackOnOriginThread(*request, &amp;IDBOpenDBRequest::requestBlocked, oldVersion, newVersion);
293 }
294 
295 void IDBConnectionProxy::openDBRequestCancelled(const IDBRequestData&amp; requestData)
296 {
</pre>
<hr />
<pre>
386 }
387 
388 void IDBConnectionProxy::databaseConnectionPendingClose(IDBDatabase&amp; database)
389 {
390     callConnectionOnMainThread(&amp;IDBConnectionToServer::databaseConnectionPendingClose, database.databaseConnectionIdentifier());
391 }
392 
393 void IDBConnectionProxy::databaseConnectionClosed(IDBDatabase&amp; database)
394 {
395     callConnectionOnMainThread(&amp;IDBConnectionToServer::databaseConnectionClosed, database.databaseConnectionIdentifier());
396 }
397 
398 void IDBConnectionProxy::didCloseFromServer(uint64_t databaseConnectionIdentifier, const IDBError&amp; error)
399 {
400     RefPtr&lt;IDBDatabase&gt; database;
401     {
402         Locker&lt;Lock&gt; locker(m_databaseConnectionMapLock);
403         database = m_databaseConnectionMap.get(databaseConnectionIdentifier);
404     }
405 
<span class="line-modified">406     // If the IDBDatabase object is gone, message back to the server so it doesn&#39;t hang</span>
<span class="line-removed">407     // waiting for a reply that will never come.</span>
<span class="line-removed">408     if (!database) {</span>
<span class="line-removed">409         m_connectionToServer.confirmDidCloseFromServer(databaseConnectionIdentifier);</span>
410         return;
<span class="line-removed">411     }</span>
412 
413     database-&gt;performCallbackOnOriginThread(*database, &amp;IDBDatabase::didCloseFromServer, error);
414 }
415 
<span class="line-removed">416 void IDBConnectionProxy::confirmDidCloseFromServer(IDBDatabase&amp; database)</span>
<span class="line-removed">417 {</span>
<span class="line-removed">418     callConnectionOnMainThread(&amp;IDBConnectionToServer::confirmDidCloseFromServer, database.databaseConnectionIdentifier());</span>
<span class="line-removed">419 }</span>
<span class="line-removed">420 </span>
421 void IDBConnectionProxy::connectionToServerLost(const IDBError&amp; error)
422 {
423     Vector&lt;uint64_t&gt; databaseConnectionIdentifiers;
424     {
425         Locker&lt;Lock&gt; locker(m_databaseConnectionMapLock);
426         databaseConnectionIdentifiers = copyToVector(m_databaseConnectionMap.keys());
427     }
428 
429     for (auto connectionIdentifier : databaseConnectionIdentifiers) {
430         RefPtr&lt;IDBDatabase&gt; database;
431         {
432             Locker&lt;Lock&gt; locker(m_databaseConnectionMapLock);
433             database = m_databaseConnectionMap.get(connectionIdentifier);
434         }
435 
436         if (!database)
437             continue;
438 
439         database-&gt;performCallbackOnOriginThread(*database, &amp;IDBDatabase::connectionToServerLost, error);
440     }
</pre>
<hr />
<pre>
512 void IDBConnectionProxy::forgetActiveOperations(const Vector&lt;RefPtr&lt;TransactionOperation&gt;&gt;&amp; operations)
513 {
514     Locker&lt;Lock&gt; locker(m_transactionOperationLock);
515 
516     for (auto&amp; operation : operations)
517         m_activeOperations.remove(operation-&gt;identifier());
518 }
519 
520 void IDBConnectionProxy::forgetTransaction(IDBTransaction&amp; transaction)
521 {
522     Locker&lt;Lock&gt; locker(m_transactionMapLock);
523 
524     m_pendingTransactions.remove(transaction.info().identifier());
525     m_committingTransactions.remove(transaction.info().identifier());
526     m_abortingTransactions.remove(transaction.info().identifier());
527 }
528 
529 template&lt;typename KeyType, typename ValueType&gt;
530 void removeItemsMatchingCurrentThread(HashMap&lt;KeyType, ValueType&gt;&amp; map)
531 {


532     auto&amp; currentThread = Thread::current();
533 
534     Vector&lt;KeyType&gt; keys;
535     keys.reserveInitialCapacity(map.size());
536     for (auto&amp; iterator : map) {
537         if (&amp;iterator.value-&gt;originThread() == &amp;currentThread)
538             keys.uncheckedAppend(iterator.key);
539     }
540 
541     for (auto&amp; key : keys)
542         map.remove(key);
543 }
544 



















545 void IDBConnectionProxy::forgetActivityForCurrentThread()
546 {
547     ASSERT(!isMainThread());
548 
549     {
550         Locker&lt;Lock&gt; lock(m_databaseConnectionMapLock);
551         removeItemsMatchingCurrentThread(m_databaseConnectionMap);
552     }
553     {
554         Locker&lt;Lock&gt; lock(m_openDBRequestMapLock);
555         removeItemsMatchingCurrentThread(m_openDBRequestMap);
556     }
557     {
558         Locker&lt;Lock&gt; lock(m_transactionMapLock);
559         removeItemsMatchingCurrentThread(m_pendingTransactions);
560         removeItemsMatchingCurrentThread(m_committingTransactions);
561         removeItemsMatchingCurrentThread(m_abortingTransactions);
562     }
563     {
564         Locker&lt;Lock&gt; lock(m_transactionOperationLock);
565         removeItemsMatchingCurrentThread(m_activeOperations);
566     }
567 }
568 












569 } // namesapce IDBClient
570 } // namespace WebCore
571 
572 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
<td>
<hr />
<pre>
 98 }
 99 
100 void IDBConnectionProxy::didDeleteDatabase(const IDBResultData&amp; resultData)
101 {
102     completeOpenDBRequest(resultData);
103 }
104 
105 void IDBConnectionProxy::completeOpenDBRequest(const IDBResultData&amp; resultData)
106 {
107     ASSERT(isMainThread());
108 
109     RefPtr&lt;IDBOpenDBRequest&gt; request;
110     {
111         Locker&lt;Lock&gt; locker(m_openDBRequestMapLock);
112         request = m_openDBRequestMap.take(resultData.requestIdentifier());
113     }
114 
115     if (!request)
116         return;
117 
<span class="line-added">118     if (request-&gt;isContextSuspended()) {</span>
<span class="line-added">119         switch (resultData.type()) {</span>
<span class="line-added">120         case IDBResultType::OpenDatabaseUpgradeNeeded: {</span>
<span class="line-added">121             abortOpenAndUpgradeNeeded(resultData.databaseConnectionIdentifier(), resultData.transactionInfo().identifier());</span>
<span class="line-added">122             auto result = IDBResultData::error(resultData.requestIdentifier(), IDBError { UnknownError, &quot;Version change transaction on cached page is aborted to unblock other connections&quot;_s });</span>
<span class="line-added">123             request-&gt;performCallbackOnOriginThread(*request, &amp;IDBOpenDBRequest::requestCompleted, result);</span>
<span class="line-added">124             return;</span>
<span class="line-added">125         }</span>
<span class="line-added">126         default:</span>
<span class="line-added">127             break;</span>
<span class="line-added">128         }</span>
<span class="line-added">129     }</span>
<span class="line-added">130 </span>
131     request-&gt;performCallbackOnOriginThread(*request, &amp;IDBOpenDBRequest::requestCompleted, resultData);
132 }
133 
134 void IDBConnectionProxy::createObjectStore(TransactionOperation&amp; operation, const IDBObjectStoreInfo&amp; info)
135 {
136     const IDBRequestData requestData { operation };
137     saveOperation(operation);
138 
139     callConnectionOnMainThread(&amp;IDBConnectionToServer::createObjectStore, requestData, info);
140 }
141 
142 void IDBConnectionProxy::renameObjectStore(TransactionOperation&amp; operation, uint64_t objectStoreIdentifier, const String&amp; newName)
143 {
144     const IDBRequestData requestData { operation };
145     saveOperation(operation);
146 
147     callConnectionOnMainThread(&amp;IDBConnectionToServer::renameObjectStore, requestData, objectStoreIdentifier, newName);
148 }
149 
150 void IDBConnectionProxy::renameIndex(TransactionOperation&amp; operation, uint64_t objectStoreIdentifier, uint64_t indexIdentifier, const String&amp; newName)
</pre>
<hr />
<pre>
221 
222 void IDBConnectionProxy::deleteRecord(TransactionOperation&amp; operation, const IDBKeyRangeData&amp; keyRange)
223 {
224     const IDBRequestData requestData { operation };
225     saveOperation(operation);
226 
227     callConnectionOnMainThread(&amp;IDBConnectionToServer::deleteRecord, requestData, keyRange);
228 }
229 
230 void IDBConnectionProxy::openCursor(TransactionOperation&amp; operation, const IDBCursorInfo&amp; info)
231 {
232     const IDBRequestData requestData { operation };
233     saveOperation(operation);
234 
235     callConnectionOnMainThread(&amp;IDBConnectionToServer::openCursor, requestData, info);
236 }
237 
238 void IDBConnectionProxy::iterateCursor(TransactionOperation&amp; operation, const IDBIterateCursorData&amp; data)
239 {
240     const IDBRequestData requestData { operation };
<span class="line-modified">241     if (data.option != IndexedDB::CursorIterateOption::DoNotReply)</span>
<span class="line-added">242         saveOperation(operation);</span>
243 
244     callConnectionOnMainThread(&amp;IDBConnectionToServer::iterateCursor, requestData, data);
245 }
246 
247 void IDBConnectionProxy::saveOperation(TransactionOperation&amp; operation)
248 {
249     Locker&lt;Lock&gt; locker(m_transactionOperationLock);
250 
251     ASSERT(!m_activeOperations.contains(operation.identifier()));
252     m_activeOperations.set(operation.identifier(), &amp;operation);
253 }
254 
255 void IDBConnectionProxy::completeOperation(const IDBResultData&amp; resultData)
256 {
257     RefPtr&lt;TransactionOperation&gt; operation;
258     {
259         Locker&lt;Lock&gt; locker(m_transactionOperationLock);
260         operation = m_activeOperations.take(resultData.requestIdentifier());
261     }
262 
</pre>
<hr />
<pre>
265 
266     operation-&gt;transitionToComplete(resultData, WTFMove(operation));
267 }
268 
269 void IDBConnectionProxy::abortOpenAndUpgradeNeeded(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; transactionIdentifier)
270 {
271     callConnectionOnMainThread(&amp;IDBConnectionToServer::abortOpenAndUpgradeNeeded, databaseConnectionIdentifier, transactionIdentifier);
272 }
273 
274 void IDBConnectionProxy::fireVersionChangeEvent(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; requestIdentifier, uint64_t requestedVersion)
275 {
276     RefPtr&lt;IDBDatabase&gt; database;
277     {
278         Locker&lt;Lock&gt; locker(m_databaseConnectionMapLock);
279         database = m_databaseConnectionMap.get(databaseConnectionIdentifier);
280     }
281 
282     if (!database)
283         return;
284 
<span class="line-added">285     if (database-&gt;isContextSuspended()) {</span>
<span class="line-added">286         didFireVersionChangeEvent(databaseConnectionIdentifier, requestIdentifier, IndexedDB::ConnectionClosedOnBehalfOfServer::Yes);</span>
<span class="line-added">287         database-&gt;performCallbackOnOriginThread(*database, &amp;IDBDatabase::connectionToServerLost, IDBError { UnknownError, &quot;Connection on cached page closed to unblock other connections&quot;_s});</span>
<span class="line-added">288         return;</span>
<span class="line-added">289     }</span>
<span class="line-added">290 </span>
291     database-&gt;performCallbackOnOriginThread(*database, &amp;IDBDatabase::fireVersionChangeEvent, requestIdentifier, requestedVersion);
292 }
293 
<span class="line-modified">294 void IDBConnectionProxy::didFireVersionChangeEvent(uint64_t databaseConnectionIdentifier, const IDBResourceIdentifier&amp; requestIdentifier, IndexedDB::ConnectionClosedOnBehalfOfServer connectionClosed)</span>
295 {
<span class="line-modified">296     callConnectionOnMainThread(&amp;IDBConnectionToServer::didFireVersionChangeEvent, databaseConnectionIdentifier, requestIdentifier, connectionClosed);</span>
297 }
298 
299 void IDBConnectionProxy::notifyOpenDBRequestBlocked(const IDBResourceIdentifier&amp; requestIdentifier, uint64_t oldVersion, uint64_t newVersion)
300 {
301     ASSERT(isMainThread());
302 
303     RefPtr&lt;IDBOpenDBRequest&gt; request;
304     {
305         Locker&lt;Lock&gt; locker(m_openDBRequestMapLock);
306         request = m_openDBRequestMap.get(requestIdentifier);
307     }
308 
309     if (!request)
310         return;
311 
312     request-&gt;performCallbackOnOriginThread(*request, &amp;IDBOpenDBRequest::requestBlocked, oldVersion, newVersion);
313 }
314 
315 void IDBConnectionProxy::openDBRequestCancelled(const IDBRequestData&amp; requestData)
316 {
</pre>
<hr />
<pre>
406 }
407 
408 void IDBConnectionProxy::databaseConnectionPendingClose(IDBDatabase&amp; database)
409 {
410     callConnectionOnMainThread(&amp;IDBConnectionToServer::databaseConnectionPendingClose, database.databaseConnectionIdentifier());
411 }
412 
413 void IDBConnectionProxy::databaseConnectionClosed(IDBDatabase&amp; database)
414 {
415     callConnectionOnMainThread(&amp;IDBConnectionToServer::databaseConnectionClosed, database.databaseConnectionIdentifier());
416 }
417 
418 void IDBConnectionProxy::didCloseFromServer(uint64_t databaseConnectionIdentifier, const IDBError&amp; error)
419 {
420     RefPtr&lt;IDBDatabase&gt; database;
421     {
422         Locker&lt;Lock&gt; locker(m_databaseConnectionMapLock);
423         database = m_databaseConnectionMap.get(databaseConnectionIdentifier);
424     }
425 
<span class="line-modified">426     if (!database)</span>



427         return;

428 
429     database-&gt;performCallbackOnOriginThread(*database, &amp;IDBDatabase::didCloseFromServer, error);
430 }
431 





432 void IDBConnectionProxy::connectionToServerLost(const IDBError&amp; error)
433 {
434     Vector&lt;uint64_t&gt; databaseConnectionIdentifiers;
435     {
436         Locker&lt;Lock&gt; locker(m_databaseConnectionMapLock);
437         databaseConnectionIdentifiers = copyToVector(m_databaseConnectionMap.keys());
438     }
439 
440     for (auto connectionIdentifier : databaseConnectionIdentifiers) {
441         RefPtr&lt;IDBDatabase&gt; database;
442         {
443             Locker&lt;Lock&gt; locker(m_databaseConnectionMapLock);
444             database = m_databaseConnectionMap.get(connectionIdentifier);
445         }
446 
447         if (!database)
448             continue;
449 
450         database-&gt;performCallbackOnOriginThread(*database, &amp;IDBDatabase::connectionToServerLost, error);
451     }
</pre>
<hr />
<pre>
523 void IDBConnectionProxy::forgetActiveOperations(const Vector&lt;RefPtr&lt;TransactionOperation&gt;&gt;&amp; operations)
524 {
525     Locker&lt;Lock&gt; locker(m_transactionOperationLock);
526 
527     for (auto&amp; operation : operations)
528         m_activeOperations.remove(operation-&gt;identifier());
529 }
530 
531 void IDBConnectionProxy::forgetTransaction(IDBTransaction&amp; transaction)
532 {
533     Locker&lt;Lock&gt; locker(m_transactionMapLock);
534 
535     m_pendingTransactions.remove(transaction.info().identifier());
536     m_committingTransactions.remove(transaction.info().identifier());
537     m_abortingTransactions.remove(transaction.info().identifier());
538 }
539 
540 template&lt;typename KeyType, typename ValueType&gt;
541 void removeItemsMatchingCurrentThread(HashMap&lt;KeyType, ValueType&gt;&amp; map)
542 {
<span class="line-added">543     // FIXME: Revisit when introducing WebThread aware thread comparison.</span>
<span class="line-added">544     // https://bugs.webkit.org/show_bug.cgi?id=204345</span>
545     auto&amp; currentThread = Thread::current();
546 
547     Vector&lt;KeyType&gt; keys;
548     keys.reserveInitialCapacity(map.size());
549     for (auto&amp; iterator : map) {
550         if (&amp;iterator.value-&gt;originThread() == &amp;currentThread)
551             keys.uncheckedAppend(iterator.key);
552     }
553 
554     for (auto&amp; key : keys)
555         map.remove(key);
556 }
557 
<span class="line-added">558 template&lt;typename KeyType, typename ValueType&gt;</span>
<span class="line-added">559 void setMatchingItemsContextSuspended(ScriptExecutionContext&amp; currentContext, HashMap&lt;KeyType, ValueType&gt;&amp; map, bool isContextSuspended)</span>
<span class="line-added">560 {</span>
<span class="line-added">561     // FIXME: Revisit when introducing WebThread aware thread comparison.</span>
<span class="line-added">562     // https://bugs.webkit.org/show_bug.cgi?id=204345</span>
<span class="line-added">563     auto&amp; currentThread = Thread::current();</span>
<span class="line-added">564     for (auto&amp; iterator : map) {</span>
<span class="line-added">565         if (&amp;iterator.value-&gt;originThread() != &amp;currentThread)</span>
<span class="line-added">566             continue;</span>
<span class="line-added">567 </span>
<span class="line-added">568         auto* context = iterator.value-&gt;scriptExecutionContext();</span>
<span class="line-added">569         if (!context)</span>
<span class="line-added">570             continue;</span>
<span class="line-added">571 </span>
<span class="line-added">572         if (context == &amp;currentContext)</span>
<span class="line-added">573             iterator.value-&gt;setIsContextSuspended(isContextSuspended);</span>
<span class="line-added">574     }</span>
<span class="line-added">575 }</span>
<span class="line-added">576 </span>
577 void IDBConnectionProxy::forgetActivityForCurrentThread()
578 {
579     ASSERT(!isMainThread());
580 
581     {
582         Locker&lt;Lock&gt; lock(m_databaseConnectionMapLock);
583         removeItemsMatchingCurrentThread(m_databaseConnectionMap);
584     }
585     {
586         Locker&lt;Lock&gt; lock(m_openDBRequestMapLock);
587         removeItemsMatchingCurrentThread(m_openDBRequestMap);
588     }
589     {
590         Locker&lt;Lock&gt; lock(m_transactionMapLock);
591         removeItemsMatchingCurrentThread(m_pendingTransactions);
592         removeItemsMatchingCurrentThread(m_committingTransactions);
593         removeItemsMatchingCurrentThread(m_abortingTransactions);
594     }
595     {
596         Locker&lt;Lock&gt; lock(m_transactionOperationLock);
597         removeItemsMatchingCurrentThread(m_activeOperations);
598     }
599 }
600 
<span class="line-added">601 void IDBConnectionProxy::setContextSuspended(ScriptExecutionContext&amp; currentContext, bool isContextSuspended)</span>
<span class="line-added">602 {</span>
<span class="line-added">603     {</span>
<span class="line-added">604         Locker&lt;Lock&gt; lock(m_databaseConnectionMapLock);</span>
<span class="line-added">605         setMatchingItemsContextSuspended(currentContext, m_databaseConnectionMap, isContextSuspended);</span>
<span class="line-added">606     }</span>
<span class="line-added">607     {</span>
<span class="line-added">608         Locker&lt;Lock&gt; lock(m_openDBRequestMapLock);</span>
<span class="line-added">609         setMatchingItemsContextSuspended(currentContext, m_openDBRequestMap, isContextSuspended);</span>
<span class="line-added">610     }</span>
<span class="line-added">611 }</span>
<span class="line-added">612 </span>
613 } // namesapce IDBClient
614 } // namespace WebCore
615 
616 #endif // ENABLE(INDEXED_DATABASE)
</pre>
</td>
</tr>
</table>
<center><a href="../IndexedDB.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="IDBConnectionProxy.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
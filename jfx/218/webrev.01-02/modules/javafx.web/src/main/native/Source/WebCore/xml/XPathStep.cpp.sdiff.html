<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/xml/XPathStep.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="XPathResult.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="XPathUtil.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/xml/XPathStep.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
127     // Check predicates that couldn&#39;t be merged into node test.
128     for (auto&amp; predicate : m_predicates) {
129         NodeSet newNodes;
130         if (!nodes.isSorted())
131             newNodes.markSorted(false);
132 
133         for (unsigned j = 0; j &lt; nodes.size(); j++) {
134             Node* node = nodes[j];
135 
136             evaluationContext.node = node;
137             evaluationContext.size = nodes.size();
138             evaluationContext.position = j + 1;
139             if (evaluatePredicate(*predicate))
140                 newNodes.append(node);
141         }
142 
143         nodes = WTFMove(newNodes);
144     }
145 }
146 
<span class="line-modified">147 #if !ASSERT_DISABLED</span>
148 static inline Node::NodeType primaryNodeType(Step::Axis axis)
149 {
150     switch (axis) {
151         case Step::AttributeAxis:
152             return Node::ATTRIBUTE_NODE;
153         default:
154             return Node::ELEMENT_NODE;
155     }
156 }
<span class="line-modified">157 #endif</span>
158 
159 // Evaluate NodeTest without considering merged predicates.
160 inline bool nodeMatchesBasicTest(Node&amp; node, Step::Axis axis, const Step::NodeTest&amp; nodeTest)
161 {
162     switch (nodeTest.m_kind) {
163         case Step::NodeTest::TextNodeTest:
164             return node.nodeType() == Node::TEXT_NODE || node.nodeType() == Node::CDATA_SECTION_NODE;
165         case Step::NodeTest::CommentNodeTest:
166             return node.nodeType() == Node::COMMENT_NODE;
167         case Step::NodeTest::ProcessingInstructionNodeTest: {
168             const AtomString&amp; name = nodeTest.m_data;
169             return node.nodeType() == Node::PROCESSING_INSTRUCTION_NODE &amp;&amp; (name.isEmpty() || node.nodeName() == name);
170         }
171         case Step::NodeTest::AnyNodeTest:
172             return true;
173         case Step::NodeTest::NameTest: {
174             const AtomString&amp; name = nodeTest.m_data;
175             const AtomString&amp; namespaceURI = nodeTest.m_namespaceURI;
176 
177             if (axis == Step::AttributeAxis) {
</pre>
</td>
<td>
<hr />
<pre>
127     // Check predicates that couldn&#39;t be merged into node test.
128     for (auto&amp; predicate : m_predicates) {
129         NodeSet newNodes;
130         if (!nodes.isSorted())
131             newNodes.markSorted(false);
132 
133         for (unsigned j = 0; j &lt; nodes.size(); j++) {
134             Node* node = nodes[j];
135 
136             evaluationContext.node = node;
137             evaluationContext.size = nodes.size();
138             evaluationContext.position = j + 1;
139             if (evaluatePredicate(*predicate))
140                 newNodes.append(node);
141         }
142 
143         nodes = WTFMove(newNodes);
144     }
145 }
146 
<span class="line-modified">147 #if ASSERT_ENABLED</span>
148 static inline Node::NodeType primaryNodeType(Step::Axis axis)
149 {
150     switch (axis) {
151         case Step::AttributeAxis:
152             return Node::ATTRIBUTE_NODE;
153         default:
154             return Node::ELEMENT_NODE;
155     }
156 }
<span class="line-modified">157 #endif // ASSERT_ENABLED</span>
158 
159 // Evaluate NodeTest without considering merged predicates.
160 inline bool nodeMatchesBasicTest(Node&amp; node, Step::Axis axis, const Step::NodeTest&amp; nodeTest)
161 {
162     switch (nodeTest.m_kind) {
163         case Step::NodeTest::TextNodeTest:
164             return node.nodeType() == Node::TEXT_NODE || node.nodeType() == Node::CDATA_SECTION_NODE;
165         case Step::NodeTest::CommentNodeTest:
166             return node.nodeType() == Node::COMMENT_NODE;
167         case Step::NodeTest::ProcessingInstructionNodeTest: {
168             const AtomString&amp; name = nodeTest.m_data;
169             return node.nodeType() == Node::PROCESSING_INSTRUCTION_NODE &amp;&amp; (name.isEmpty() || node.nodeName() == name);
170         }
171         case Step::NodeTest::AnyNodeTest:
172             return true;
173         case Step::NodeTest::NameTest: {
174             const AtomString&amp; name = nodeTest.m_data;
175             const AtomString&amp; namespaceURI = nodeTest.m_namespaceURI;
176 
177             if (axis == Step::AttributeAxis) {
</pre>
</td>
</tr>
</table>
<center><a href="XPathResult.idl.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="XPathUtil.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
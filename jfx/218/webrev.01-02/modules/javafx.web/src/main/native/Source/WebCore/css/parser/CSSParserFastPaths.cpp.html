<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/css/parser/CSSParserFastPaths.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 // Copyright 2014 The Chromium Authors. All rights reserved.
   2 // Copyright (C) 2016-2018 Apple Inc. All rights reserved.
   3 //
   4 // Redistribution and use in source and binary forms, with or without
   5 // modification, are permitted provided that the following conditions are
   6 // met:
   7 //
   8 //    * Redistributions of source code must retain the above copyright
   9 // notice, this list of conditions and the following disclaimer.
  10 //    * Redistributions in binary form must reproduce the above
  11 // copyright notice, this list of conditions and the following disclaimer
  12 // in the documentation and/or other materials provided with the
  13 // distribution.
  14 //    * Neither the name of Google Inc. nor the names of its
  15 // contributors may be used to endorse or promote products derived from
  16 // this software without specific prior written permission.
  17 //
  18 // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
  19 // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
  20 // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
  21 // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
  22 // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
  23 // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  24 // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  25 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  26 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  27 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  28 // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  29 
  30 #include &quot;config.h&quot;
  31 #include &quot;CSSParserFastPaths.h&quot;
  32 
  33 #include &quot;CSSFunctionValue.h&quot;
  34 #include &quot;CSSParserContext.h&quot;
  35 #include &quot;CSSParserIdioms.h&quot;
  36 #include &quot;CSSPrimitiveValue.h&quot;
  37 #include &quot;CSSPropertyParser.h&quot;
  38 #include &quot;CSSValueList.h&quot;
  39 #include &quot;CSSValuePool.h&quot;
  40 #include &quot;HTMLParserIdioms.h&quot;
  41 #include &quot;RuntimeEnabledFeatures.h&quot;
  42 #include &quot;StyleColor.h&quot;
  43 #include &quot;StylePropertyShorthand.h&quot;
  44 
  45 namespace WebCore {
  46 
  47 static inline bool isSimpleLengthPropertyID(CSSPropertyID propertyId, bool&amp; acceptsNegativeNumbers)
  48 {
  49     switch (propertyId) {
  50     case CSSPropertyFontSize:
  51     case CSSPropertyHeight:
  52     case CSSPropertyWidth:
  53     case CSSPropertyMinHeight:
  54     case CSSPropertyMinWidth:
  55     case CSSPropertyPaddingBottom:
  56     case CSSPropertyPaddingLeft:
  57     case CSSPropertyPaddingRight:
  58     case CSSPropertyPaddingTop:
  59     case CSSPropertyInlineSize:
  60     case CSSPropertyBlockSize:
  61     case CSSPropertyMinInlineSize:
  62     case CSSPropertyMinBlockSize:
  63     case CSSPropertyPaddingBlockEnd:
  64     case CSSPropertyPaddingBlockStart:
  65     case CSSPropertyPaddingInlineEnd:
  66     case CSSPropertyPaddingInlineStart:
  67     case CSSPropertyR:
  68     case CSSPropertyRx:
  69     case CSSPropertyRy:
  70     case CSSPropertyShapeMargin:
  71         acceptsNegativeNumbers = false;
  72         return true;
  73     case CSSPropertyBottom:
  74     case CSSPropertyCx:
  75     case CSSPropertyCy:
  76     case CSSPropertyLeft:
  77     case CSSPropertyInsetBlockEnd:
  78     case CSSPropertyInsetBlockStart:
  79     case CSSPropertyInsetInlineEnd:
  80     case CSSPropertyInsetInlineStart:
  81     case CSSPropertyMarginBottom:
  82     case CSSPropertyMarginLeft:
  83     case CSSPropertyMarginRight:
  84     case CSSPropertyMarginTop:
  85     case CSSPropertyRight:
  86     case CSSPropertyTop:
  87     case CSSPropertyMarginBlockEnd:
  88     case CSSPropertyMarginBlockStart:
  89     case CSSPropertyMarginInlineEnd:
  90     case CSSPropertyMarginInlineStart:
  91     case CSSPropertyX:
  92     case CSSPropertyY:
  93         acceptsNegativeNumbers = true;
  94         return true;
  95     default:
  96         return false;
  97     }
  98 }
  99 
 100 template &lt;typename CharacterType&gt;
 101 static inline bool parseSimpleLength(const CharacterType* characters, unsigned length, CSSUnitType&amp; unit, double&amp; number)
 102 {
 103     if (length &gt; 2 &amp;&amp; (characters[length - 2] | 0x20) == &#39;p&#39; &amp;&amp; (characters[length - 1] | 0x20) == &#39;x&#39;) {
 104         length -= 2;
 105         unit = CSSUnitType::CSS_PX;
 106     } else if (length &gt; 1 &amp;&amp; characters[length - 1] == &#39;%&#39;) {
 107         length -= 1;
 108         unit = CSSUnitType::CSS_PERCENTAGE;
 109     }
 110 
 111     // We rely on charactersToDouble for validation as well. The function
 112     // will set &quot;ok&quot; to &quot;false&quot; if the entire passed-in character range does
 113     // not represent a double.
 114     bool ok;
 115     number = charactersToDouble(characters, length, &amp;ok);
 116     if (!ok)
 117         return false;
 118     return true;
 119 }
 120 
 121 template &lt;typename CharacterType&gt;
 122 static inline bool parseSimpleAngle(const CharacterType* characters, unsigned length, CSSUnitType&amp; unit, double&amp; number)
 123 {
 124     // Just support deg and rad for now.
 125     if (length &lt; 4)
 126         return false;
 127 
 128     if ((characters[length - 3] | 0x20) == &#39;d&#39; &amp;&amp; (characters[length - 2] | 0x20) == &#39;e&#39; &amp;&amp; (characters[length - 1] | 0x20) == &#39;g&#39;) {
 129         length -= 3;
 130         unit = CSSUnitType::CSS_DEG;
 131     } else if ((characters[length - 3] | 0x20) == &#39;r&#39; &amp;&amp; (characters[length - 2] | 0x20) == &#39;a&#39; &amp;&amp; (characters[length - 1] | 0x20) == &#39;d&#39;) {
 132         length -= 3;
 133         unit = CSSUnitType::CSS_RAD;
 134     } else
 135         return false;
 136 
 137     // We rely on charactersToDouble for validation as well. The function
 138     // will set &quot;ok&quot; to &quot;false&quot; if the entire passed-in character range does
 139     // not represent a double.
 140     bool ok;
 141     number = charactersToDouble(characters, length, &amp;ok);
 142     if (!ok)
 143         return false;
 144     return true;
 145 }
 146 
 147 static RefPtr&lt;CSSValue&gt; parseSimpleLengthValue(CSSPropertyID propertyId, const String&amp; string, CSSParserMode cssParserMode)
 148 {
 149     ASSERT(!string.isEmpty());
 150     bool acceptsNegativeNumbers = false;
 151 
 152     // In @viewport, width and height are shorthands, not simple length values.
 153     if (isCSSViewportParsingEnabledForMode(cssParserMode) || !isSimpleLengthPropertyID(propertyId, acceptsNegativeNumbers))
 154         return nullptr;
 155 
 156     unsigned length = string.length();
 157     double number;
 158     CSSUnitType unit = CSSUnitType::CSS_NUMBER;
 159 
 160     if (string.is8Bit()) {
 161         if (!parseSimpleLength(string.characters8(), length, unit, number))
 162             return nullptr;
 163     } else {
 164         if (!parseSimpleLength(string.characters16(), length, unit, number))
 165             return nullptr;
 166     }
 167 
 168     if (unit == CSSUnitType::CSS_NUMBER) {
 169         if (number &amp;&amp; cssParserMode != SVGAttributeMode)
 170             return nullptr;
 171         unit = CSSUnitType::CSS_PX;
 172     }
 173 
 174     if (number &lt; 0 &amp;&amp; !acceptsNegativeNumbers)
 175         return nullptr;
 176     if (std::isinf(number))
 177         return nullptr;
 178 
 179     return CSSPrimitiveValue::create(number, unit);
 180 }
 181 
 182 static inline bool isColorPropertyID(CSSPropertyID propertyId)
 183 {
 184     switch (propertyId) {
 185     case CSSPropertyColor:
 186     case CSSPropertyBackgroundColor:
 187     case CSSPropertyBorderBottomColor:
 188     case CSSPropertyBorderLeftColor:
 189     case CSSPropertyBorderRightColor:
 190     case CSSPropertyBorderTopColor:
 191     case CSSPropertyFill:
 192     case CSSPropertyFloodColor:
 193     case CSSPropertyLightingColor:
 194     case CSSPropertyOutlineColor:
 195     case CSSPropertyStopColor:
 196     case CSSPropertyStroke:
 197     case CSSPropertyStrokeColor:
 198     case CSSPropertyBorderBlockEndColor:
 199     case CSSPropertyBorderBlockStartColor:
 200     case CSSPropertyBorderInlineEndColor:
 201     case CSSPropertyBorderInlineStartColor:
 202     case CSSPropertyColumnRuleColor:
 203     case CSSPropertyWebkitTextEmphasisColor:
 204     case CSSPropertyWebkitTextFillColor:
 205     case CSSPropertyWebkitTextStrokeColor:
 206     case CSSPropertyTextDecorationColor:
 207         return true;
 208     default:
 209         return false;
 210     }
 211 }
 212 
 213 // Returns the number of characters which form a valid double
 214 // and are terminated by the given terminator character
 215 template &lt;typename CharacterType&gt;
 216 static int checkForValidDouble(const CharacterType* string, const CharacterType* end, const char terminator)
 217 {
 218     int length = end - string;
 219     if (length &lt; 1)
 220         return 0;
 221 
 222     bool decimalMarkSeen = false;
 223     int processedLength = 0;
 224 
 225     for (int i = 0; i &lt; length; ++i) {
 226         if (string[i] == terminator) {
 227             processedLength = i;
 228             break;
 229         }
 230         if (!isASCIIDigit(string[i])) {
 231             if (!decimalMarkSeen &amp;&amp; string[i] == &#39;.&#39;)
 232                 decimalMarkSeen = true;
 233             else
 234                 return 0;
 235         }
 236     }
 237 
 238     if (decimalMarkSeen &amp;&amp; processedLength == 1)
 239         return 0;
 240 
 241     return processedLength;
 242 }
 243 
 244 // Returns the number of characters consumed for parsing a valid double
 245 // terminated by the given terminator character
 246 template &lt;typename CharacterType&gt;
 247 static int parseDouble(const CharacterType* string, const CharacterType* end, const char terminator, double&amp; value)
 248 {
 249     int length = checkForValidDouble(string, end, terminator);
 250     if (!length)
 251         return 0;
 252 
 253     int position = 0;
 254     double localValue = 0;
 255 
 256     // The consumed characters here are guaranteed to be
 257     // ASCII digits with or without a decimal mark
 258     for (; position &lt; length; ++position) {
 259         if (string[position] == &#39;.&#39;)
 260             break;
 261         localValue = localValue * 10 + string[position] - &#39;0&#39;;
 262     }
 263 
 264     if (++position == length) {
 265         value = localValue;
 266         return length;
 267     }
 268 
 269     double fraction = 0;
 270     double scale = 1;
 271 
 272     const double maxScale = 1000000;
 273     while (position &lt; length &amp;&amp; scale &lt; maxScale) {
 274         fraction = fraction * 10 + string[position++] - &#39;0&#39;;
 275         scale *= 10;
 276     }
 277 
 278     value = localValue + fraction / scale;
 279     return length;
 280 }
 281 
 282 template &lt;typename CharacterType&gt;
 283 static bool parseColorIntOrPercentage(const CharacterType*&amp; string, const CharacterType* end, const char terminator, CSSUnitType&amp; expect, int&amp; value)
 284 {
 285     const CharacterType* current = string;
 286     double localValue = 0;
 287     bool negative = false;
 288     while (current != end &amp;&amp; isHTMLSpace&lt;CharacterType&gt;(*current))
 289         current++;
 290     if (current != end &amp;&amp; *current == &#39;-&#39;) {
 291         negative = true;
 292         current++;
 293     }
 294     if (current == end || !isASCIIDigit(*current))
 295         return false;
 296     while (current != end &amp;&amp; isASCIIDigit(*current)) {
 297         double newValue = localValue * 10 + *current++ - &#39;0&#39;;
 298         if (newValue &gt;= 255) {
 299             // Clamp values at 255.
 300             localValue = 255;
 301             while (current != end &amp;&amp; isASCIIDigit(*current))
 302                 ++current;
 303             break;
 304         }
 305         localValue = newValue;
 306     }
 307 
 308     if (current == end)
 309         return false;
 310 
 311     if (expect == CSSUnitType::CSS_NUMBER &amp;&amp; (*current == &#39;.&#39; || *current == &#39;%&#39;))
 312         return false;
 313 
 314     if (*current == &#39;.&#39;) {
 315         // We already parsed the integral part, try to parse
 316         // the fraction part of the percentage value.
 317         double percentage = 0;
 318         int numCharactersParsed = parseDouble(current, end, &#39;%&#39;, percentage);
 319         if (!numCharactersParsed)
 320             return false;
 321         current += numCharactersParsed;
 322         if (*current != &#39;%&#39;)
 323             return false;
 324         localValue += percentage;
 325     }
 326 
 327     if (expect == CSSUnitType::CSS_PERCENTAGE &amp;&amp; *current != &#39;%&#39;)
 328         return false;
 329 
 330     if (*current == &#39;%&#39;) {
 331         expect = CSSUnitType::CSS_PERCENTAGE;
 332         localValue = localValue / 100.0 * 255.0;
 333         // Clamp values at 255 for percentages over 100%
 334         if (localValue &gt; 255)
 335             localValue = 255;
 336         current++;
 337     } else {
 338         expect = CSSUnitType::CSS_NUMBER;
 339     }
 340 
 341     while (current != end &amp;&amp; isHTMLSpace&lt;CharacterType&gt;(*current))
 342         current++;
 343     if (current == end || *current++ != terminator)
 344         return false;
 345     // Clamp negative values at zero.
 346     value = negative ? 0 : static_cast&lt;int&gt;(localValue);
 347     string = current;
 348     return true;
 349 }
 350 
 351 template &lt;typename CharacterType&gt;
 352 static inline bool isTenthAlpha(const CharacterType* string, const int length)
 353 {
 354     // &quot;0.X&quot;
 355     if (length == 3 &amp;&amp; string[0] == &#39;0&#39; &amp;&amp; string[1] == &#39;.&#39; &amp;&amp; isASCIIDigit(string[2]))
 356         return true;
 357 
 358     // &quot;.X&quot;
 359     if (length == 2 &amp;&amp; string[0] == &#39;.&#39; &amp;&amp; isASCIIDigit(string[1]))
 360         return true;
 361 
 362     return false;
 363 }
 364 
 365 template &lt;typename CharacterType&gt;
 366 static inline bool parseAlphaValue(const CharacterType*&amp; string, const CharacterType* end, const char terminator, int&amp; value)
 367 {
 368     while (string != end &amp;&amp; isHTMLSpace&lt;CharacterType&gt;(*string))
 369         string++;
 370 
 371     bool negative = false;
 372 
 373     if (string != end &amp;&amp; *string == &#39;-&#39;) {
 374         negative = true;
 375         string++;
 376     }
 377 
 378     value = 0;
 379 
 380     int length = end - string;
 381     if (length &lt; 2)
 382         return false;
 383 
 384     if (string[length - 1] != terminator || !isASCIIDigit(string[length - 2]))
 385         return false;
 386 
 387     if (string[0] != &#39;0&#39; &amp;&amp; string[0] != &#39;1&#39; &amp;&amp; string[0] != &#39;.&#39;) {
 388         if (checkForValidDouble(string, end, terminator)) {
 389             value = negative ? 0 : 255;
 390             string = end;
 391             return true;
 392         }
 393         return false;
 394     }
 395 
 396     if (length == 2 &amp;&amp; string[0] != &#39;.&#39;) {
 397         value = !negative &amp;&amp; string[0] == &#39;1&#39; ? 255 : 0;
 398         string = end;
 399         return true;
 400     }
 401 
 402     if (isTenthAlpha(string, length - 1)) {
 403         static const int tenthAlphaValues[] = { 0, 26, 51, 77, 102, 128, 153, 179, 204, 230 };
 404         value = negative ? 0 : tenthAlphaValues[string[length - 2] - &#39;0&#39;];
 405         string = end;
 406         return true;
 407     }
 408 
 409     double alpha = 0;
 410     if (!parseDouble(string, end, terminator, alpha))
 411         return false;
 412 
 413     // W3 standard stipulates a 2.55 alpha value multiplication factor.
 414     value = negative ? 0 : static_cast&lt;int&gt;(lroundf(clampTo&lt;double&gt;(alpha, 0.0, 1.0) * 255.0f));
 415     string = end;
 416     return true;
 417 }
 418 
 419 template &lt;typename CharacterType&gt;
 420 static inline bool mightBeRGBA(const CharacterType* characters, unsigned length)
 421 {
 422     if (length &lt; 5)
 423         return false;
 424     return characters[4] == &#39;(&#39;
 425         &amp;&amp; isASCIIAlphaCaselessEqual(characters[0], &#39;r&#39;)
 426         &amp;&amp; isASCIIAlphaCaselessEqual(characters[1], &#39;g&#39;)
 427         &amp;&amp; isASCIIAlphaCaselessEqual(characters[2], &#39;b&#39;)
 428         &amp;&amp; isASCIIAlphaCaselessEqual(characters[3], &#39;a&#39;);
 429 }
 430 
 431 template &lt;typename CharacterType&gt;
 432 static inline bool mightBeRGB(const CharacterType* characters, unsigned length)
 433 {
 434     if (length &lt; 4)
 435         return false;
 436     return characters[3] == &#39;(&#39;
 437         &amp;&amp; isASCIIAlphaCaselessEqual(characters[0], &#39;r&#39;)
 438         &amp;&amp; isASCIIAlphaCaselessEqual(characters[1], &#39;g&#39;)
 439         &amp;&amp; isASCIIAlphaCaselessEqual(characters[2], &#39;b&#39;);
 440 }
 441 
 442 template &lt;typename CharacterType&gt;
 443 static Color fastParseColorInternal(const CharacterType* characters, unsigned length, bool quirksMode)
 444 {
 445     CSSUnitType expect = CSSUnitType::CSS_UNKNOWN;
 446 
 447     if (length &gt;= 4 &amp;&amp; characters[0] == &#39;#&#39;) {
 448         RGBA32 rgb;
 449         if (Color::parseHexColor(characters + 1, length - 1, rgb))
 450             return Color(rgb);
 451     }
 452 
 453     if (quirksMode &amp;&amp; (length == 3 || length == 6)) {
 454         RGBA32 rgb;
 455         if (Color::parseHexColor(characters, length, rgb))
 456             return Color(rgb);
 457     }
 458 
 459     // Try rgba() syntax.
 460     if (mightBeRGBA(characters, length)) {
 461         const CharacterType* current = characters + 5;
 462         const CharacterType* end = characters + length;
 463         int red;
 464         int green;
 465         int blue;
 466         int alpha;
 467 
 468         if (!parseColorIntOrPercentage(current, end, &#39;,&#39;, expect, red))
 469             return Color();
 470         if (!parseColorIntOrPercentage(current, end, &#39;,&#39;, expect, green))
 471             return Color();
 472         if (!parseColorIntOrPercentage(current, end, &#39;,&#39;, expect, blue))
 473             return Color();
 474         if (!parseAlphaValue(current, end, &#39;)&#39;, alpha))
 475             return Color();
 476         if (current != end)
 477             return Color();
 478         return Color(makeRGBA(red, green, blue, alpha));
 479     }
 480 
 481     // Try rgb() syntax.
 482     if (mightBeRGB(characters, length)) {
 483         const CharacterType* current = characters + 4;
 484         const CharacterType* end = characters + length;
 485         int red;
 486         int green;
 487         int blue;
 488         if (!parseColorIntOrPercentage(current, end, &#39;,&#39;, expect, red))
 489             return Color();
 490         if (!parseColorIntOrPercentage(current, end, &#39;,&#39;, expect, green))
 491             return Color();
 492         if (!parseColorIntOrPercentage(current, end, &#39;)&#39;, expect, blue))
 493             return Color();
 494         if (current != end)
 495             return Color();
 496         return Color(makeRGB(red, green, blue));
 497     }
 498 
 499     return Color();
 500 }
 501 
 502 RefPtr&lt;CSSValue&gt; CSSParserFastPaths::parseColor(const String&amp; string, CSSParserMode parserMode, CSSValuePool&amp; valuePool)
 503 {
 504     ASSERT(!string.isEmpty());
 505     CSSValueID valueID = cssValueKeywordID(string);
 506     if (StyleColor::isColorKeyword(valueID)) {
 507         if (!isValueAllowedInMode(valueID, parserMode))
 508             return nullptr;
 509         return valuePool.createIdentifierValue(valueID);
 510     }
 511 
 512     bool quirksMode = isQuirksModeBehavior(parserMode);
 513 
 514     // Fast path for hex colors and rgb()/rgba() colors
 515     Color color;
 516     if (string.is8Bit())
 517         color = fastParseColorInternal(string.characters8(), string.length(), quirksMode);
 518     else
 519         color = fastParseColorInternal(string.characters16(), string.length(), quirksMode);
 520     if (!color.isValid())
 521         return nullptr;
 522     return valuePool.createColorValue(color);
 523 }
 524 
 525 bool CSSParserFastPaths::isValidKeywordPropertyAndValue(CSSPropertyID propertyId, CSSValueID valueID, const CSSParserContext&amp; context)
 526 {
 527 #if !ENABLE(OVERFLOW_SCROLLING_TOUCH)
 528     UNUSED_PARAM(context);
 529 #endif
 530 
 531     if (valueID == CSSValueInvalid || !isValueAllowedInMode(valueID, context.mode))
 532         return false;
 533 
 534     switch (propertyId) {
 535     case CSSPropertyAlignmentBaseline:
 536         // auto | baseline | before-edge | text-before-edge | middle |
 537         // central | after-edge | text-after-edge | ideographic | alphabetic |
 538         // hanging | mathematical
 539         return valueID == CSSValueAuto || valueID == CSSValueAlphabetic || valueID == CSSValueBaseline
 540             || valueID == CSSValueMiddle || (valueID &gt;= CSSValueBeforeEdge &amp;&amp; valueID &lt;= CSSValueMathematical);
 541     case CSSPropertyAll:
 542         return false; // Only accepts css-wide keywords
 543     case CSSPropertyBackgroundRepeatX: // repeat | no-repeat
 544     case CSSPropertyBackgroundRepeatY: // repeat | no-repeat
 545         return valueID == CSSValueRepeat || valueID == CSSValueNoRepeat;
 546     case CSSPropertyBorderCollapse: // collapse | separate
 547         return valueID == CSSValueCollapse || valueID == CSSValueSeparate;
 548     case CSSPropertyBorderTopStyle: // &lt;border-style&gt;
 549     case CSSPropertyBorderRightStyle: // Defined as: none | hidden | dotted | dashed |
 550     case CSSPropertyBorderBottomStyle: // solid | double | groove | ridge | inset | outset
 551     case CSSPropertyBorderLeftStyle:
 552     case CSSPropertyBorderBlockEndStyle:
 553     case CSSPropertyBorderBlockStartStyle:
 554     case CSSPropertyBorderInlineEndStyle:
 555     case CSSPropertyBorderInlineStartStyle:
 556     case CSSPropertyColumnRuleStyle:
 557         return valueID &gt;= CSSValueNone &amp;&amp; valueID &lt;= CSSValueDouble;
 558     case CSSPropertyBoxSizing:
 559         return valueID == CSSValueBorderBox || valueID == CSSValueContentBox;
 560     case CSSPropertyBufferedRendering:
 561         return valueID == CSSValueAuto || valueID == CSSValueDynamic || valueID == CSSValueStatic;
 562     case CSSPropertyCaptionSide: // top | bottom | left | right
 563         return valueID == CSSValueLeft || valueID == CSSValueRight || valueID == CSSValueTop || valueID == CSSValueBottom;
 564     case CSSPropertyClear: // none | left | right | both
 565         return valueID == CSSValueNone || valueID == CSSValueLeft || valueID == CSSValueRight || valueID == CSSValueBoth;
 566     case CSSPropertyClipRule:
 567     case CSSPropertyFillRule:
 568         return valueID == CSSValueNonzero || valueID == CSSValueEvenodd;
 569     case CSSPropertyColorInterpolation:
 570     case CSSPropertyColorInterpolationFilters:
 571         return valueID == CSSValueAuto || valueID == CSSValueSRGB || valueID == CSSValueLinearRGB;
 572     case CSSPropertyColorRendering:
 573         return valueID == CSSValueAuto || valueID == CSSValueOptimizeSpeed || valueID == CSSValueOptimizeQuality;
 574     case CSSPropertyDirection: // ltr | rtl
 575         return valueID == CSSValueLtr || valueID == CSSValueRtl;
 576     case CSSPropertyDisplay:
 577         // inline | block | list-item | inline-block | table |
 578         // inline-table | table-row-group | table-header-group | table-footer-group | table-row |
 579         // table-column-group | table-column | table-cell | table-caption | -webkit-box | -webkit-inline-box | none
 580         // flex | inline-flex | -webkit-flex | -webkit-inline-flex | grid | inline-grid
 581         return (valueID &gt;= CSSValueInline &amp;&amp; valueID &lt;= CSSValueContents) || valueID == CSSValueNone
 582             || valueID == CSSValueGrid || valueID == CSSValueInlineGrid || valueID == CSSValueFlowRoot;
 583     case CSSPropertyDominantBaseline:
 584         // auto | use-script | no-change | reset-size | ideographic |
 585         // alphabetic | hanging | mathematical | central | middle |
 586         // text-after-edge | text-before-edge
 587         return valueID == CSSValueAuto || valueID == CSSValueAlphabetic || valueID == CSSValueMiddle
 588             || (valueID &gt;= CSSValueUseScript &amp;&amp; valueID &lt;= CSSValueResetSize)
 589             || (valueID &gt;= CSSValueCentral &amp;&amp; valueID &lt;= CSSValueMathematical);
 590     case CSSPropertyEmptyCells: // show | hide
 591         return valueID == CSSValueShow || valueID == CSSValueHide;
 592     case CSSPropertyFloat: // left | right | none
 593         return valueID == CSSValueLeft || valueID == CSSValueRight || valueID == CSSValueNone;
 594     case CSSPropertyImageOrientation: // from-image | none
 595         return valueID == CSSValueFromImage || valueID == CSSValueNone;
 596     case CSSPropertyImageRendering: // auto | optimizeContrast | pixelated | optimizeSpeed | crispEdges | optimizeQuality | webkit-crispEdges
 597         return valueID == CSSValueAuto || valueID == CSSValueOptimizeSpeed || valueID == CSSValueOptimizeQuality || valueID == CSSValueWebkitCrispEdges || valueID == CSSValueWebkitOptimizeContrast || valueID == CSSValueCrispEdges || valueID == CSSValuePixelated;
 598 #if ENABLE(CSS_COMPOSITING)
 599     case CSSPropertyIsolation: // auto | isolate
 600         return valueID == CSSValueAuto || valueID == CSSValueIsolate;
 601 #endif
 602     case CSSPropertyListStylePosition: // inside | outside
 603         return valueID == CSSValueInside || valueID == CSSValueOutside;
 604     case CSSPropertyListStyleType:
 605         // See section CSS_PROP_LIST_STYLE_TYPE of file CSSValueKeywords.in
 606         // for the list of supported list-style-types.
 607         return (valueID &gt;= CSSValueDisc &amp;&amp; valueID &lt;= CSSValueKatakanaIroha) || valueID == CSSValueNone;
 608     case CSSPropertyMaskType:
 609         return valueID == CSSValueLuminance || valueID == CSSValueAlpha;
 610     case CSSPropertyObjectFit:
 611         return valueID == CSSValueFill || valueID == CSSValueContain || valueID == CSSValueCover || valueID == CSSValueNone || valueID == CSSValueScaleDown;
 612     case CSSPropertyOutlineStyle: // (&lt;border-style&gt; except hidden) | auto
 613         return valueID == CSSValueAuto || valueID == CSSValueNone || (valueID &gt;= CSSValueInset &amp;&amp; valueID &lt;= CSSValueDouble);
 614     // FIXME-NEWPARSER: Support?
 615     // case CSSPropertyOverflowAnchor:
 616     //    return valueID == CSSValueVisible || valueID == CSSValueNone || valueID == CSSValueAuto;
 617     case CSSPropertyOverflowWrap: // normal | break-word
 618     case CSSPropertyWordWrap:
 619         return valueID == CSSValueNormal || valueID == CSSValueBreakWord;
 620     case CSSPropertyOverflowX: // visible | hidden | scroll | auto | overlay (overlay is a synonym for auto)
 621         return valueID == CSSValueVisible || valueID == CSSValueHidden || valueID == CSSValueScroll || valueID == CSSValueAuto || valueID == CSSValueOverlay;
 622     case CSSPropertyOverflowY: // visible | hidden | scroll | auto | overlay | -webkit-paged-x | -webkit-paged-y (overlay is a synonym for auto)
 623         return valueID == CSSValueVisible || valueID == CSSValueHidden || valueID == CSSValueScroll || valueID == CSSValueAuto || valueID == CSSValueOverlay || valueID == CSSValueWebkitPagedX || valueID == CSSValueWebkitPagedY;
 624     case CSSPropertyBreakAfter:
 625     case CSSPropertyBreakBefore:
 626         return valueID == CSSValueAuto || valueID == CSSValueAvoid || valueID == CSSValueAvoidPage || valueID == CSSValuePage || valueID == CSSValueLeft || valueID == CSSValueRight || valueID == CSSValueRecto || valueID == CSSValueVerso || valueID == CSSValueAvoidColumn || valueID == CSSValueColumn;
 627     case CSSPropertyBreakInside:
 628         return valueID == CSSValueAuto || valueID == CSSValueAvoid || valueID == CSSValueAvoidPage || valueID == CSSValueAvoidColumn;
 629     case CSSPropertyPointerEvents:
 630         // none | visiblePainted | visibleFill | visibleStroke | visible |
 631         // painted | fill | stroke | auto | all | bounding-box
 632         return valueID == CSSValueVisible || valueID == CSSValueNone || valueID == CSSValueAll || valueID == CSSValueAuto || valueID == CSSValueBoundingBox || (valueID &gt;= CSSValueVisiblePainted &amp;&amp; valueID &lt;= CSSValueStroke);
 633     case CSSPropertyPosition: // static | relative | absolute | fixed | sticky
 634         return valueID == CSSValueStatic
 635             || valueID == CSSValueRelative
 636             || valueID == CSSValueAbsolute
 637             || valueID == CSSValueFixed
 638             || valueID == CSSValueSticky || valueID == CSSValueWebkitSticky;
 639     case CSSPropertyResize: // none | both | horizontal | vertical | auto
 640         return valueID == CSSValueNone || valueID == CSSValueBoth || valueID == CSSValueHorizontal || valueID == CSSValueVertical || valueID == CSSValueAuto;
 641     case CSSPropertyShapeRendering:
 642         return valueID == CSSValueAuto || valueID == CSSValueOptimizeSpeed || valueID == CSSValueCrispedges || valueID == CSSValueGeometricPrecision;
 643     case CSSPropertyStrokeLinejoin:
 644         return valueID == CSSValueMiter || valueID == CSSValueRound || valueID == CSSValueBevel;
 645     case CSSPropertyStrokeLinecap:
 646         return valueID == CSSValueButt || valueID == CSSValueRound || valueID == CSSValueSquare;
 647     case CSSPropertyTableLayout: // auto | fixed
 648         return valueID == CSSValueAuto || valueID == CSSValueFixed;
 649     case CSSPropertyTextAlign:
 650         return (valueID &gt;= CSSValueWebkitAuto &amp;&amp; valueID &lt;= CSSValueWebkitMatchParent) || valueID == CSSValueStart || valueID == CSSValueEnd;
 651 #if ENABLE(CSS3_TEXT)
 652     case CSSPropertyWebkitTextAlignLast:
 653         // auto | start | end | left | right | center | justify
 654         return (valueID &gt;= CSSValueLeft &amp;&amp; valueID &lt;= CSSValueJustify) || valueID == CSSValueStart || valueID == CSSValueEnd || valueID == CSSValueAuto;
 655 #endif
 656     case CSSPropertyTextAnchor:
 657         return valueID == CSSValueStart || valueID == CSSValueMiddle || valueID == CSSValueEnd;
 658 // FIXME-NEWPARSER: Support
 659 //    case CSSPropertyTextCombineUpright:
 660 //        return valueID == CSSValueNone || valueID == CSSValueAll;
 661     case CSSPropertyTextDecorationStyle:
 662         // solid | double | dotted | dashed | wavy
 663         return valueID == CSSValueSolid || valueID == CSSValueDouble || valueID == CSSValueDotted || valueID == CSSValueDashed || valueID == CSSValueWavy;
 664 #if ENABLE(CSS3_TEXT)
 665     case CSSPropertyWebkitTextJustify:
 666         // auto | none | inter-word | distribute
 667         return valueID == CSSValueInterWord || valueID == CSSValueDistribute || valueID == CSSValueAuto || valueID == CSSValueNone;
 668 #endif
 669     case CSSPropertyWebkitTextOrientation: // mixed | upright | sideways | sideways-right
 670         return valueID == CSSValueMixed || valueID == CSSValueUpright || valueID == CSSValueSideways || valueID == CSSValueSidewaysRight;
 671     case CSSPropertyTextOverflow: // clip | ellipsis
 672         return valueID == CSSValueClip || valueID == CSSValueEllipsis;
 673     case CSSPropertyTextRendering: // auto | optimizeSpeed | optimizeLegibility | geometricPrecision
 674         return valueID == CSSValueAuto || valueID == CSSValueOptimizeSpeed || valueID == CSSValueOptimizeLegibility || valueID == CSSValueGeometricPrecision;
 675     case CSSPropertyTextTransform: // capitalize | uppercase | lowercase | none
 676         return (valueID &gt;= CSSValueCapitalize &amp;&amp; valueID &lt;= CSSValueLowercase) || valueID == CSSValueNone;
 677     case CSSPropertyUnicodeBidi:
 678         return valueID == CSSValueNormal || valueID == CSSValueEmbed
 679             || valueID == CSSValueBidiOverride
 680             || valueID == CSSValueIsolate || valueID == CSSValueWebkitIsolate
 681             || valueID == CSSValueIsolateOverride || valueID == CSSValueWebkitIsolateOverride
 682             || valueID == CSSValuePlaintext || valueID == CSSValueWebkitPlaintext;
 683     case CSSPropertyVectorEffect:
 684         return valueID == CSSValueNone || valueID == CSSValueNonScalingStroke;
 685     case CSSPropertyVisibility: // visible | hidden | collapse
 686         return valueID == CSSValueVisible || valueID == CSSValueHidden || valueID == CSSValueCollapse;
 687     case CSSPropertyWebkitAppearance:
 688         return (valueID &gt;= CSSValueCheckbox &amp;&amp; valueID &lt;= CSSValueCapsLockIndicator) || valueID == CSSValueNone;
 689     case CSSPropertyWebkitBackfaceVisibility:
 690         return valueID == CSSValueVisible || valueID == CSSValueHidden;
 691 #if ENABLE(CSS_COMPOSITING)
 692     case CSSPropertyMixBlendMode:
 693         return valueID == CSSValueNormal || valueID == CSSValueMultiply || valueID == CSSValueScreen || valueID == CSSValueOverlay
 694             || valueID == CSSValueDarken || valueID == CSSValueLighten || valueID == CSSValueColorDodge || valueID == CSSValueColorBurn
 695             || valueID == CSSValueHardLight || valueID == CSSValueSoftLight || valueID == CSSValueDifference || valueID == CSSValueExclusion
 696             || valueID == CSSValueHue || valueID == CSSValueSaturation || valueID == CSSValueColor || valueID == CSSValueLuminosity || valueID == CSSValuePlusDarker || valueID == CSSValuePlusLighter;
 697 #endif
 698     case CSSPropertyWebkitBoxAlign:
 699         return valueID == CSSValueStretch || valueID == CSSValueStart || valueID == CSSValueEnd || valueID == CSSValueCenter || valueID == CSSValueBaseline;
 700 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 701     case CSSPropertyWebkitBoxDecorationBreak:
 702         return valueID == CSSValueClone || valueID == CSSValueSlice;
 703     case CSSPropertyWebkitBoxDirection:
 704         return valueID == CSSValueNormal || valueID == CSSValueReverse;
 705 #endif
 706     case CSSPropertyWebkitBoxLines:
 707         return valueID == CSSValueSingle || valueID == CSSValueMultiple;
 708     case CSSPropertyWebkitBoxOrient:
 709         return valueID == CSSValueHorizontal || valueID == CSSValueVertical || valueID == CSSValueInlineAxis || valueID == CSSValueBlockAxis;
 710     case CSSPropertyWebkitBoxPack:
 711         return valueID == CSSValueStart || valueID == CSSValueEnd || valueID == CSSValueCenter || valueID == CSSValueJustify;
 712 #if ENABLE(CURSOR_VISIBILITY)
 713     case CSSPropertyWebkitCursorVisibility:
 714         return valueID == CSSValueAuto || valueID == CSSValueAutoHide;
 715 #endif
 716     case CSSPropertyColumnFill:
 717         return valueID == CSSValueAuto || valueID == CSSValueBalance;
 718     case CSSPropertyWebkitColumnAxis:
 719         return valueID == CSSValueHorizontal || valueID == CSSValueVertical || valueID == CSSValueAuto;
 720     case CSSPropertyWebkitColumnProgression:
 721         return valueID == CSSValueNormal || valueID == CSSValueReverse;
 722     case CSSPropertyFlexDirection:
 723         return valueID == CSSValueRow || valueID == CSSValueRowReverse || valueID == CSSValueColumn || valueID == CSSValueColumnReverse;
 724     case CSSPropertyFlexWrap:
 725         return valueID == CSSValueNowrap || valueID == CSSValueWrap || valueID == CSSValueWrapReverse;
 726     case CSSPropertyWebkitHyphens:
 727         return valueID == CSSValueAuto || valueID == CSSValueNone || valueID == CSSValueManual;
 728     case CSSPropertyWebkitFontKerning:
 729         return valueID == CSSValueAuto || valueID == CSSValueNormal || valueID == CSSValueNone;
 730     case CSSPropertyWebkitFontSmoothing:
 731         return valueID == CSSValueAuto || valueID == CSSValueNone || valueID == CSSValueAntialiased || valueID == CSSValueSubpixelAntialiased;
 732     case CSSPropertyWebkitLineAlign:
 733         return valueID == CSSValueNone || valueID == CSSValueEdges;
 734     case CSSPropertyLineBreak: // auto | loose | normal | strict | after-white-space | anywhere
 735         return valueID == CSSValueAuto || valueID == CSSValueLoose || valueID == CSSValueNormal || valueID == CSSValueStrict || valueID == CSSValueAfterWhiteSpace || valueID == CSSValueAnywhere;
 736     case CSSPropertyWebkitLineSnap:
 737         return valueID == CSSValueNone || valueID == CSSValueBaseline || valueID == CSSValueContain;
 738     case CSSPropertyWebkitMarginAfterCollapse:
 739     case CSSPropertyWebkitMarginBeforeCollapse:
 740     case CSSPropertyWebkitMarginBottomCollapse:
 741     case CSSPropertyWebkitMarginTopCollapse:
 742         return valueID == CSSValueCollapse || valueID == CSSValueSeparate || valueID == CSSValueDiscard;
 743     case CSSPropertyWebkitPrintColorAdjust:
 744         return valueID == CSSValueExact || valueID == CSSValueEconomy;
 745     case CSSPropertyWebkitRtlOrdering:
 746         return valueID == CSSValueLogical || valueID == CSSValueVisual;
 747     case CSSPropertyWebkitRubyPosition:
 748         return valueID == CSSValueBefore || valueID == CSSValueAfter || valueID == CSSValueInterCharacter;
 749     case CSSPropertyWebkitTextCombine:
 750         return valueID == CSSValueNone || valueID == CSSValueHorizontal;
 751     case CSSPropertyWebkitTextSecurity: // disc | circle | square | none
 752         return valueID == CSSValueDisc || valueID == CSSValueCircle || valueID == CSSValueSquare || valueID == CSSValueNone;
 753     case CSSPropertyTransformStyle:
 754     case CSSPropertyWebkitTransformStyle:
 755         return valueID == CSSValueFlat || valueID == CSSValuePreserve3d;
 756     case CSSPropertyWebkitUserDrag: // auto | none | element
 757         return valueID == CSSValueAuto || valueID == CSSValueNone || valueID == CSSValueElement;
 758     case CSSPropertyWebkitUserModify: // read-only | read-write
 759         return valueID == CSSValueReadOnly || valueID == CSSValueReadWrite || valueID == CSSValueReadWritePlaintextOnly;
 760     case CSSPropertyWebkitUserSelect: // auto | none | text | all
 761         return valueID == CSSValueAuto || valueID == CSSValueNone || valueID == CSSValueText || valueID == CSSValueAll;
 762     case CSSPropertyWritingMode:
 763         // Note that horizontal-bt is not supported by the unprefixed version of
 764         // the property, only by the -webkit- version.
 765         return (valueID &gt;= CSSValueHorizontalTb &amp;&amp; valueID &lt;= CSSValueHorizontalBt)
 766             || valueID == CSSValueLrTb || valueID == CSSValueRlTb || valueID == CSSValueTbRl
 767             || valueID == CSSValueLr || valueID == CSSValueRl || valueID == CSSValueTb;
 768     case CSSPropertyWhiteSpace: // normal | pre | nowrap | pre-line | nowrap | break-spacess
 769         return valueID == CSSValueNormal || valueID == CSSValuePre || valueID == CSSValuePreWrap || valueID == CSSValuePreLine || valueID == CSSValueNowrap || valueID == CSSValueBreakSpaces;
 770     case CSSPropertyWordBreak: // normal | break-all | keep-all | break-word (this is a custom extension)
 771         return valueID == CSSValueNormal || valueID == CSSValueBreakAll || valueID == CSSValueKeepAll || valueID == CSSValueBreakWord;
 772     case CSSPropertyWebkitBorderFit:
 773         return valueID == CSSValueBorder || valueID == CSSValueLines;
 774 #if ENABLE(CSS_TRAILING_WORD)
 775     case CSSPropertyAppleTrailingWord: // auto | -apple-partially-balanced
 776         return valueID == CSSValueAuto || valueID == CSSValueWebkitPartiallyBalanced;
 777 #endif
 778 #if ENABLE(APPLE_PAY)
 779     case CSSPropertyApplePayButtonStyle: // white | white-outline | black
 780         return valueID == CSSValueWhite || valueID == CSSValueWhiteOutline || valueID == CSSValueBlack;
 781     case CSSPropertyApplePayButtonType: // plain | buy | set-up | donate
 782         if (valueID == CSSValuePlain || valueID == CSSValueBuy || valueID == CSSValueSetUp || valueID == CSSValueDonate)
 783             return true;
 784 #if ENABLE(APPLE_PAY_SESSION_V4)
 785         // check-out | book | subscribe
 786         return valueID == CSSValueCheckOut || valueID == CSSValueBook || valueID == CSSValueSubscribe;
 787 #else
 788         return false;
 789 #endif
 790 #endif
 791     case CSSPropertyWebkitNbspMode: // normal | space
 792         return valueID == CSSValueNormal || valueID == CSSValueSpace;
 793     case CSSPropertyWebkitTextZoom:
 794         return valueID == CSSValueNormal || valueID == CSSValueReset;
 795 #if PLATFORM(IOS_FAMILY)
 796     // Apple specific property. These will never be standardized and is purely to
 797     // support custom WebKit-based Apple applications.
 798     case CSSPropertyWebkitTouchCallout:
 799         return valueID == CSSValueDefault || valueID == CSSValueNone;
 800 #endif
 801     case CSSPropertyWebkitMarqueeDirection:
 802         return valueID == CSSValueForwards || valueID == CSSValueBackwards || valueID == CSSValueAhead || valueID == CSSValueReverse || valueID == CSSValueLeft || valueID == CSSValueRight || valueID == CSSValueDown
 803             || valueID == CSSValueUp || valueID == CSSValueAuto;
 804     case CSSPropertyWebkitMarqueeStyle:
 805         return valueID == CSSValueNone || valueID == CSSValueSlide || valueID == CSSValueScroll || valueID == CSSValueAlternate;
 806     case CSSPropertyFontVariantPosition: // normal | sub | super
 807         return valueID == CSSValueNormal || valueID == CSSValueSub || valueID == CSSValueSuper;
 808     case CSSPropertyFontVariantCaps: // normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps
 809         return valueID == CSSValueNormal || valueID == CSSValueSmallCaps || valueID == CSSValueAllSmallCaps || valueID == CSSValuePetiteCaps || valueID == CSSValueAllPetiteCaps || valueID == CSSValueUnicase || valueID == CSSValueTitlingCaps;
 810     case CSSPropertyFontVariantAlternates: // We only support the normal and historical-forms values.
 811         return valueID == CSSValueNormal || valueID == CSSValueHistoricalForms;
 812 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
 813     case CSSPropertyWebkitOverflowScrolling:
 814         if (!context.legacyOverflowScrollingTouchEnabled)
 815             return false;
 816         return valueID == CSSValueAuto || valueID == CSSValueTouch;
 817 #endif
 818 #if ENABLE(VARIATION_FONTS)
 819     case CSSPropertyFontOpticalSizing:
 820         return valueID == CSSValueAuto || valueID == CSSValueNone;
 821 #endif
 822     default:
 823         ASSERT_NOT_REACHED();
 824         return false;
 825     }
 826 }
 827 
 828 bool CSSParserFastPaths::isKeywordPropertyID(CSSPropertyID propertyId)
 829 {
 830     switch (propertyId) {
 831     case CSSPropertyBorderBlockEndStyle:
 832     case CSSPropertyBorderBlockStartStyle:
 833     case CSSPropertyBorderBottomStyle:
 834     case CSSPropertyBorderCollapse:
 835     case CSSPropertyBorderInlineEndStyle:
 836     case CSSPropertyBorderInlineStartStyle:
 837     case CSSPropertyBorderLeftStyle:
 838     case CSSPropertyBorderRightStyle:
 839     case CSSPropertyBorderTopStyle:
 840     case CSSPropertyBoxSizing:
 841     case CSSPropertyBreakAfter:
 842     case CSSPropertyBreakBefore:
 843     case CSSPropertyBreakInside:
 844     case CSSPropertyCaptionSide:
 845     case CSSPropertyClear:
 846     case CSSPropertyColumnFill:
 847     case CSSPropertyWebkitColumnProgression:
 848     case CSSPropertyColumnRuleStyle:
 849     case CSSPropertyDirection:
 850     case CSSPropertyDisplay:
 851     case CSSPropertyEmptyCells:
 852     case CSSPropertyFlexDirection:
 853     case CSSPropertyFlexWrap:
 854     case CSSPropertyFloat:
 855     case CSSPropertyFontVariantAlternates:
 856     case CSSPropertyFontVariantCaps:
 857     case CSSPropertyFontVariantPosition:
 858     case CSSPropertyImageOrientation:
 859     case CSSPropertyImageRendering:
 860     case CSSPropertyListStylePosition:
 861     case CSSPropertyListStyleType:
 862     case CSSPropertyObjectFit:
 863     case CSSPropertyOutlineStyle:
 864     case CSSPropertyOverflowWrap:
 865     case CSSPropertyOverflowX:
 866     case CSSPropertyOverflowY:
 867     case CSSPropertyPointerEvents:
 868     case CSSPropertyPosition:
 869     case CSSPropertyResize:
 870     case CSSPropertyTableLayout:
 871     case CSSPropertyTextAlign:
 872     case CSSPropertyTextOverflow:
 873     case CSSPropertyTextRendering:
 874     case CSSPropertyTextTransform:
 875     case CSSPropertyTransformStyle:
 876     case CSSPropertyUnicodeBidi:
 877     case CSSPropertyVisibility:
 878     case CSSPropertyWebkitAppearance:
 879     case CSSPropertyWebkitBackfaceVisibility:
 880     case CSSPropertyWebkitBorderFit:
 881     case CSSPropertyWebkitBoxAlign:
 882     case CSSPropertyWebkitBoxDirection:
 883     case CSSPropertyWebkitBoxLines:
 884     case CSSPropertyWebkitBoxOrient:
 885     case CSSPropertyWebkitBoxPack:
 886     case CSSPropertyWebkitColumnAxis:
 887     case CSSPropertyWebkitFontKerning:
 888     case CSSPropertyWebkitFontSmoothing:
 889     case CSSPropertyWebkitHyphens:
 890     case CSSPropertyWebkitLineAlign:
 891     case CSSPropertyLineBreak:
 892     case CSSPropertyWebkitLineSnap:
 893     case CSSPropertyWebkitMarginAfterCollapse:
 894     case CSSPropertyWebkitMarginBeforeCollapse:
 895     case CSSPropertyWebkitMarginBottomCollapse:
 896     case CSSPropertyWebkitMarginTopCollapse:
 897     case CSSPropertyWebkitMarqueeDirection:
 898     case CSSPropertyWebkitMarqueeStyle:
 899     case CSSPropertyWebkitNbspMode:
 900     case CSSPropertyWebkitPrintColorAdjust:
 901     case CSSPropertyWebkitRtlOrdering:
 902     case CSSPropertyWebkitRubyPosition:
 903     case CSSPropertyWebkitTextCombine:
 904     case CSSPropertyTextDecorationStyle:
 905     case CSSPropertyWebkitTextOrientation:
 906     case CSSPropertyWebkitTextSecurity:
 907     case CSSPropertyWebkitTextZoom:
 908     case CSSPropertyWebkitTransformStyle:
 909     case CSSPropertyWebkitUserDrag:
 910     case CSSPropertyWebkitUserModify:
 911     case CSSPropertyWebkitUserSelect:
 912     case CSSPropertyWhiteSpace:
 913     case CSSPropertyWordBreak:
 914     case CSSPropertyWordWrap:
 915 
 916     // SVG CSS properties from SVG 1.1, Appendix N: Property Index.
 917     case CSSPropertyAlignmentBaseline:
 918     case CSSPropertyBufferedRendering:
 919     case CSSPropertyClipRule:
 920     case CSSPropertyColorInterpolation:
 921     case CSSPropertyColorInterpolationFilters:
 922     case CSSPropertyColorRendering:
 923     case CSSPropertyDominantBaseline:
 924     case CSSPropertyFillRule:
 925     case CSSPropertyMaskType:
 926     case CSSPropertyShapeRendering:
 927     case CSSPropertyStrokeLinecap:
 928     case CSSPropertyStrokeLinejoin:
 929     case CSSPropertyTextAnchor:
 930     case CSSPropertyVectorEffect:
 931     case CSSPropertyWritingMode:
 932 
 933     // FIXME-NEWPARSER: Treat all as a keyword property.
 934     // case CSSPropertyAll:
 935 
 936     // FIXME-NEWPARSER: Add the following unprefixed properties:
 937     // case CSSPropertyBackfaceVisibility:
 938     // case CSSPropertyFontKerning:
 939     // case CSSPropertyHyphens:
 940     // case CSSPropertyOverflowAnchor:
 941     // case CSSPropertyScrollSnapType:
 942     // case CSSPropertyTextAlignLast:
 943     // case CSSPropertyTextCombineUpright:
 944     // case CSSPropertyTextDecorationStyle:
 945     // case CSSPropertyTextJustify:
 946     // case CSSPropertyTextOrientation:
 947     // case CSSPropertyUserSelect:
 948 #if ENABLE(CSS_TRAILING_WORD)
 949     case CSSPropertyAppleTrailingWord:
 950 #endif
 951 #if ENABLE(CSS_COMPOSITING)
 952     case CSSPropertyIsolation:
 953     case CSSPropertyMixBlendMode:
 954 #endif
 955 #if ENABLE(CSS_BOX_DECORATION_BREAK)
 956     case CSSPropertyWebkitBoxDecorationBreak:
 957 #endif
 958 #if ENABLE(CURSOR_VISIBILITY)
 959     case CSSPropertyWebkitCursorVisibility:
 960 #endif
 961 #if ENABLE(OVERFLOW_SCROLLING_TOUCH)
 962     case CSSPropertyWebkitOverflowScrolling:
 963 #endif
 964 #if ENABLE(CSS3_TEXT)
 965     case CSSPropertyWebkitTextAlignLast:
 966     case CSSPropertyWebkitTextJustify:
 967 #endif
 968 #if PLATFORM(IOS_FAMILY)
 969     // Apple specific property. This will never be standardized and is purely to
 970     // support custom WebKit-based Apple applications.
 971     case CSSPropertyWebkitTouchCallout:
 972 #endif
 973 #if ENABLE(APPLE_PAY)
 974     case CSSPropertyApplePayButtonStyle:
 975     case CSSPropertyApplePayButtonType:
 976 #endif
 977 #if ENABLE(VARIATION_FONTS)
 978     case CSSPropertyFontOpticalSizing:
 979 #endif
 980         return true;
 981     default:
 982         return false;
 983     }
 984 }
 985 
 986 static bool isUniversalKeyword(const String&amp; string)
 987 {
 988     // These keywords can be used for all properties.
 989     return equalLettersIgnoringASCIICase(string, &quot;initial&quot;)
 990     || equalLettersIgnoringASCIICase(string, &quot;inherit&quot;)
 991     || equalLettersIgnoringASCIICase(string, &quot;unset&quot;)
 992     || equalLettersIgnoringASCIICase(string, &quot;revert&quot;);
 993 }
 994 
 995 static RefPtr&lt;CSSValue&gt; parseKeywordValue(CSSPropertyID propertyId, const String&amp; string, const CSSParserContext&amp; context)
 996 {
 997     ASSERT(!string.isEmpty());
 998 
 999     if (!CSSParserFastPaths::isKeywordPropertyID(propertyId)) {
1000         // All properties accept the values of &quot;initial&quot; and &quot;inherit&quot;.
1001         if (!isUniversalKeyword(string))
1002             return nullptr;
1003 
1004         // Parse initial/inherit shorthands using the CSSPropertyParser.
1005         if (shorthandForProperty(propertyId).length())
1006             return nullptr;
1007 
1008         // Descriptors do not support css wide keywords.
1009         if (CSSProperty::isDescriptorOnly(propertyId))
1010             return nullptr;
1011     }
1012 
1013     CSSValueID valueID = cssValueKeywordID(string);
1014 
1015     if (!valueID)
1016         return nullptr;
1017 
1018     if (valueID == CSSValueInherit)
1019         return CSSValuePool::singleton().createInheritedValue();
1020     if (valueID == CSSValueInitial)
1021         return CSSValuePool::singleton().createExplicitInitialValue();
1022     if (valueID == CSSValueUnset)
1023         return CSSValuePool::singleton().createUnsetValue();
1024     if (valueID == CSSValueRevert)
1025         return CSSValuePool::singleton().createRevertValue();
1026 
1027     if (CSSParserFastPaths::isValidKeywordPropertyAndValue(propertyId, valueID, context))
1028         return CSSPrimitiveValue::createIdentifier(valueID);
1029     return nullptr;
1030 }
1031 
1032 template &lt;typename CharType&gt;
1033 static bool parseTransformTranslateArguments(CharType*&amp; pos, CharType* end, unsigned expectedCount, CSSFunctionValue* transformValue)
1034 {
1035     while (expectedCount) {
1036         size_t delimiter = WTF::find(pos, end - pos, expectedCount == 1 ? &#39;)&#39; : &#39;,&#39;);
1037         if (delimiter == notFound)
1038             return false;
1039         unsigned argumentLength = static_cast&lt;unsigned&gt;(delimiter);
1040         CSSUnitType unit = CSSUnitType::CSS_NUMBER;
1041         double number;
1042         if (!parseSimpleLength(pos, argumentLength, unit, number))
1043             return false;
1044         if (!number &amp;&amp; unit == CSSUnitType::CSS_NUMBER)
1045             unit = CSSUnitType::CSS_PX;
1046         if (unit == CSSUnitType::CSS_NUMBER || (unit == CSSUnitType::CSS_PERCENTAGE &amp;&amp; (transformValue-&gt;name() == CSSValueTranslateZ || (transformValue-&gt;name() == CSSValueTranslate3d &amp;&amp; expectedCount == 1))))
1047             return false;
1048         transformValue-&gt;append(CSSPrimitiveValue::create(number, unit));
1049         pos += argumentLength + 1;
1050         --expectedCount;
1051     }
1052     return true;
1053 }
1054 
1055 template &lt;typename CharType&gt;
1056 static bool parseTransformAngleArgument(CharType*&amp; pos, CharType* end, CSSFunctionValue* transformValue)
1057 {
1058     size_t delimiter = WTF::find(pos, end - pos, &#39;)&#39;);
1059     if (delimiter == notFound)
1060         return false;
1061 
1062     unsigned argumentLength = static_cast&lt;unsigned&gt;(delimiter);
1063     CSSUnitType unit = CSSUnitType::CSS_NUMBER;
1064     double number;
1065     if (!parseSimpleAngle(pos, argumentLength, unit, number))
1066         return false;
1067     if (!number &amp;&amp; unit == CSSUnitType::CSS_NUMBER)
1068         unit = CSSUnitType::CSS_DEG;
1069 
1070     transformValue-&gt;append(CSSPrimitiveValue::create(number, unit));
1071     pos += argumentLength + 1;
1072 
1073     return true;
1074 }
1075 
1076 template &lt;typename CharType&gt;
1077 static bool parseTransformNumberArguments(CharType*&amp; pos, CharType* end, unsigned expectedCount, CSSFunctionValue* transformValue)
1078 {
1079     while (expectedCount) {
1080         size_t delimiter = WTF::find(pos, end - pos, expectedCount == 1 ? &#39;)&#39; : &#39;,&#39;);
1081         if (delimiter == notFound)
1082             return false;
1083         unsigned argumentLength = static_cast&lt;unsigned&gt;(delimiter);
1084         bool ok;
1085         double number = charactersToDouble(pos, argumentLength, &amp;ok);
1086         if (!ok)
1087             return false;
1088         transformValue-&gt;append(CSSPrimitiveValue::create(number, CSSUnitType::CSS_NUMBER));
1089         pos += argumentLength + 1;
1090         --expectedCount;
1091     }
1092     return true;
1093 }
1094 
1095 static const int kShortestValidTransformStringLength = 9; // &quot;rotate(0)&quot;
1096 
1097 template &lt;typename CharType&gt;
1098 static RefPtr&lt;CSSFunctionValue&gt; parseSimpleTransformValue(CharType*&amp; pos, CharType* end)
1099 {
1100     if (end - pos &lt; kShortestValidTransformStringLength)
1101         return nullptr;
1102 
1103     const bool isTranslate = toASCIILower(pos[0]) == &#39;t&#39;
1104         &amp;&amp; toASCIILower(pos[1]) == &#39;r&#39;
1105         &amp;&amp; toASCIILower(pos[2]) == &#39;a&#39;
1106         &amp;&amp; toASCIILower(pos[3]) == &#39;n&#39;
1107         &amp;&amp; toASCIILower(pos[4]) == &#39;s&#39;
1108         &amp;&amp; toASCIILower(pos[5]) == &#39;l&#39;
1109         &amp;&amp; toASCIILower(pos[6]) == &#39;a&#39;
1110         &amp;&amp; toASCIILower(pos[7]) == &#39;t&#39;
1111         &amp;&amp; toASCIILower(pos[8]) == &#39;e&#39;;
1112 
1113     if (isTranslate) {
1114         CSSValueID transformType;
1115         unsigned expectedArgumentCount = 1;
1116         unsigned argumentStart = 11;
1117         CharType c9 = toASCIILower(pos[9]);
1118         if (c9 == &#39;x&#39; &amp;&amp; pos[10] == &#39;(&#39;) {
1119             transformType = CSSValueTranslateX;
1120         } else if (c9 == &#39;y&#39; &amp;&amp; pos[10] == &#39;(&#39;) {
1121             transformType = CSSValueTranslateY;
1122         } else if (c9 == &#39;z&#39; &amp;&amp; pos[10] == &#39;(&#39;) {
1123             transformType = CSSValueTranslateZ;
1124         } else if (c9 == &#39;(&#39;) {
1125             transformType = CSSValueTranslate;
1126             expectedArgumentCount = 2;
1127             argumentStart = 10;
1128         } else if (c9 == &#39;3&#39; &amp;&amp; toASCIILower(pos[10]) == &#39;d&#39; &amp;&amp; pos[11] == &#39;(&#39;) {
1129             transformType = CSSValueTranslate3d;
1130             expectedArgumentCount = 3;
1131             argumentStart = 12;
1132         } else
1133             return nullptr;
1134 
1135         pos += argumentStart;
1136         RefPtr&lt;CSSFunctionValue&gt; transformValue = CSSFunctionValue::create(transformType);
1137         if (!parseTransformTranslateArguments(pos, end, expectedArgumentCount, transformValue.get()))
1138             return nullptr;
1139         return transformValue;
1140     }
1141 
1142     const bool isMatrix3d = toASCIILower(pos[0]) == &#39;m&#39;
1143         &amp;&amp; toASCIILower(pos[1]) == &#39;a&#39;
1144         &amp;&amp; toASCIILower(pos[2]) == &#39;t&#39;
1145         &amp;&amp; toASCIILower(pos[3]) == &#39;r&#39;
1146         &amp;&amp; toASCIILower(pos[4]) == &#39;i&#39;
1147         &amp;&amp; toASCIILower(pos[5]) == &#39;x&#39;
1148         &amp;&amp; pos[6] == &#39;3&#39;
1149         &amp;&amp; toASCIILower(pos[7]) == &#39;d&#39;
1150         &amp;&amp; pos[8] == &#39;(&#39;;
1151 
1152     if (isMatrix3d) {
1153         pos += 9;
1154         RefPtr&lt;CSSFunctionValue&gt; transformValue = CSSFunctionValue::create(CSSValueMatrix3d);
1155         if (!parseTransformNumberArguments(pos, end, 16, transformValue.get()))
1156             return nullptr;
1157         return transformValue;
1158     }
1159 
1160     const bool isScale3d = toASCIILower(pos[0]) == &#39;s&#39;
1161         &amp;&amp; toASCIILower(pos[1]) == &#39;c&#39;
1162         &amp;&amp; toASCIILower(pos[2]) == &#39;a&#39;
1163         &amp;&amp; toASCIILower(pos[3]) == &#39;l&#39;
1164         &amp;&amp; toASCIILower(pos[4]) == &#39;e&#39;
1165         &amp;&amp; pos[5] == &#39;3&#39;
1166         &amp;&amp; toASCIILower(pos[6]) == &#39;d&#39;
1167         &amp;&amp; pos[7] == &#39;(&#39;;
1168 
1169     if (isScale3d) {
1170         pos += 8;
1171         RefPtr&lt;CSSFunctionValue&gt; transformValue = CSSFunctionValue::create(CSSValueScale3d);
1172         if (!parseTransformNumberArguments(pos, end, 3, transformValue.get()))
1173             return nullptr;
1174         return transformValue;
1175     }
1176 
1177     const bool isRotate = toASCIILower(pos[0]) == &#39;r&#39;
1178         &amp;&amp; toASCIILower(pos[1]) == &#39;o&#39;
1179         &amp;&amp; toASCIILower(pos[2]) == &#39;t&#39;
1180         &amp;&amp; toASCIILower(pos[3]) == &#39;a&#39;
1181         &amp;&amp; toASCIILower(pos[4]) == &#39;t&#39;
1182         &amp;&amp; toASCIILower(pos[5]) == &#39;e&#39;;
1183 
1184     if (isRotate) {
1185         CSSValueID transformType;
1186         unsigned argumentStart = 7;
1187         CharType c6 = toASCIILower(pos[6]);
1188         if (c6 == &#39;(&#39;) {
1189             transformType = CSSValueRotate;
1190         } else if (c6 == &#39;z&#39; &amp;&amp; pos[7] == &#39;(&#39;) {
1191             transformType = CSSValueRotateZ;
1192             argumentStart = 8;
1193         } else
1194             return nullptr;
1195 
1196         pos += argumentStart;
1197         RefPtr&lt;CSSFunctionValue&gt; transformValue = CSSFunctionValue::create(transformType);
1198         if (!parseTransformAngleArgument(pos, end, transformValue.get()))
1199             return nullptr;
1200         return transformValue;
1201     }
1202 
1203     return nullptr;
1204 }
1205 
1206 template &lt;typename CharType&gt;
1207 static bool transformCanLikelyUseFastPath(const CharType* chars, unsigned length)
1208 {
1209     // Very fast scan that attempts to reject most transforms that couldn&#39;t
1210     // take the fast path. This avoids doing the malloc and string-&gt;double
1211     // conversions in parseSimpleTransformValue only to discard them when we
1212     // run into a transform component we don&#39;t understand.
1213     unsigned i = 0;
1214     while (i &lt; length) {
1215         if (isCSSSpace(chars[i])) {
1216             ++i;
1217             continue;
1218         }
1219 
1220         if (length - i &lt; kShortestValidTransformStringLength)
1221             return false;
1222 
1223         switch (toASCIILower(chars[i])) {
1224         case &#39;t&#39;:
1225             // translate, translateX, translateY, translateZ, translate3d.
1226             if (toASCIILower(chars[i + 8]) != &#39;e&#39;)
1227                 return false;
1228             i += 9;
1229             break;
1230         case &#39;m&#39;:
1231             // matrix3d.
1232             if (toASCIILower(chars[i + 7]) != &#39;d&#39;)
1233                 return false;
1234             i += 8;
1235             break;
1236         case &#39;s&#39;:
1237             // scale3d.
1238             if (toASCIILower(chars[i + 6]) != &#39;d&#39;)
1239                 return false;
1240             i += 7;
1241             break;
1242         case &#39;r&#39;:
1243             // rotate.
1244             if (toASCIILower(chars[i + 5]) != &#39;e&#39;)
1245                 return false;
1246             i += 6;
1247             // rotateZ
1248             if (toASCIILower(chars[i]) == &#39;z&#39;)
1249                 ++i;
1250             break;
1251 
1252         default:
1253             return false;
1254         }
1255         size_t argumentsEnd = WTF::find(chars, length, &#39;)&#39;, i);
1256         if (argumentsEnd == notFound)
1257             return false;
1258         // Advance to the end of the arguments.
1259         i = argumentsEnd + 1;
1260     }
1261     return i == length;
1262 }
1263 
1264 template &lt;typename CharType&gt;
1265 static RefPtr&lt;CSSValueList&gt; parseSimpleTransformList(const CharType* chars, unsigned length)
1266 {
1267     if (!transformCanLikelyUseFastPath(chars, length))
1268         return nullptr;
1269     const CharType*&amp; pos = chars;
1270     const CharType* end = chars + length;
1271     RefPtr&lt;CSSValueList&gt; transformList;
1272     while (pos &lt; end) {
1273         while (pos &lt; end &amp;&amp; isCSSSpace(*pos))
1274             ++pos;
1275         if (pos &gt;= end)
1276             break;
1277         RefPtr&lt;CSSFunctionValue&gt; transformValue = parseSimpleTransformValue(pos, end);
1278         if (!transformValue)
1279             return nullptr;
1280         if (!transformList)
1281             transformList = CSSValueList::createSpaceSeparated();
1282         transformList-&gt;append(*transformValue);
1283     }
1284     return transformList;
1285 }
1286 
1287 static RefPtr&lt;CSSValue&gt; parseSimpleTransform(CSSPropertyID propertyID, const String&amp; string)
1288 {
1289     ASSERT(!string.isEmpty());
1290     if (propertyID != CSSPropertyTransform)
1291         return nullptr;
1292     if (string.is8Bit())
1293         return parseSimpleTransformList(string.characters8(), string.length());
1294     return parseSimpleTransformList(string.characters16(), string.length());
1295 }
1296 
1297 static RefPtr&lt;CSSValue&gt; parseCaretColor(const String&amp; string, CSSParserMode parserMode)
1298 {
1299     ASSERT(!string.isEmpty());
1300     CSSValueID valueID = cssValueKeywordID(string);
1301     if (valueID == CSSValueAuto)
1302         return CSSValuePool::singleton().createIdentifierValue(valueID);
1303     return CSSParserFastPaths::parseColor(string, parserMode, CSSValuePool::singleton());
1304 }
1305 
1306 RefPtr&lt;CSSValue&gt; CSSParserFastPaths::maybeParseValue(CSSPropertyID propertyID, const String&amp; string, const CSSParserContext&amp; context)
1307 {
1308     if (auto result = parseSimpleLengthValue(propertyID, string, context.mode))
1309         return result;
1310     if (propertyID == CSSPropertyCaretColor)
1311         return parseCaretColor(string, context.mode);
1312     if (isColorPropertyID(propertyID))
1313         return parseColor(string, context.mode, CSSValuePool::singleton());
1314     if (auto result = parseKeywordValue(propertyID, string, context))
1315         return result;
1316     return parseSimpleTransform(propertyID, string);
1317 }
1318 
1319 } // namespace WebCore
    </pre>
  </body>
</html>
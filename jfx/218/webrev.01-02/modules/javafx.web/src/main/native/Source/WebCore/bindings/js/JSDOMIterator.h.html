<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New modules/javafx.web/src/main/native/Source/WebCore/bindings/js/JSDOMIterator.h</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (C) 2016 Canon, Inc. All rights reserved.
  3  * Copyright (C) 2016-2017 Apple Inc. All rights reserved.
  4  *
  5  * Redistribution and use in source and binary forms, with or without
  6  * modification, are permitted provided that the following conditions
  7  * are met:
  8  * 1. Redistributions of source code must retain the above copyright
  9  *    notice, this list of conditions and the following disclaimer.
 10  * 2. Redistributions in binary form must reproduce the above copyright
 11  *    notice, this list of conditions and the following disclaimer in the
 12  *    documentation and/or other materials provided with the distribution.
 13  *
 14  * THIS SOFTWARE IS PROVIDED BY CANON INC. ``AS IS&#39;&#39; AND ANY
 15  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 16  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 17  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL CANON INC. OR
 18  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 19  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 20  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 21  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 22  * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 24  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #pragma once
 28 
 29 #include &quot;JSDOMConvert.h&quot;
 30 #include &lt;JavaScriptCore/IteratorPrototype.h&gt;
 31 #include &lt;JavaScriptCore/PropertySlot.h&gt;
 32 #include &lt;type_traits&gt;
 33 
 34 namespace WebCore {
 35 
 36 void addValueIterableMethods(JSC::JSGlobalObject&amp;, JSC::JSObject&amp;);
 37 
 38 enum class JSDOMIteratorType { Set, Map };
 39 
 40 // struct IteratorTraits {
 41 //     static constexpr JSDOMIteratorType type = [Map|Set];
 42 //     using KeyType = [IDLType|void];
 43 //     using ValueType = [IDLType];
 44 // };
 45 
 46 template&lt;typename T, typename U = void&gt; using EnableIfMap = typename std::enable_if&lt;T::type == JSDOMIteratorType::Map, U&gt;::type;
 47 template&lt;typename T, typename U = void&gt; using EnableIfSet = typename std::enable_if&lt;T::type == JSDOMIteratorType::Set, U&gt;::type;
 48 
 49 template&lt;typename JSWrapper, typename IteratorTraits&gt; class JSDOMIteratorPrototype final : public JSC::JSNonFinalObject {
 50 public:
 51     using Base = JSC::JSNonFinalObject;
 52     using DOMWrapped = typename JSWrapper::DOMWrapped;
 53 
 54     static JSDOMIteratorPrototype* create(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::Structure* structure)
 55     {
 56         STATIC_ASSERT_ISO_SUBSPACE_SHARABLE(JSDOMIteratorPrototype, JSDOMIteratorPrototype::Base);
 57         JSDOMIteratorPrototype* prototype = new (NotNull, JSC::allocateCell&lt;JSDOMIteratorPrototype&gt;(vm.heap)) JSDOMIteratorPrototype(vm, structure);
 58         prototype-&gt;finishCreation(vm, globalObject);
 59         return prototype;
 60     }
 61 
 62     DECLARE_INFO;
 63 
 64     static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
 65     {
 66         return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
 67     }
 68 
 69     static JSC::EncodedJSValue JSC_HOST_CALL next(JSC::JSGlobalObject*, JSC::CallFrame*);
 70 
 71 private:
 72     JSDOMIteratorPrototype(JSC::VM&amp; vm, JSC::Structure* structure) : Base(vm, structure) { }
 73 
 74     void finishCreation(JSC::VM&amp;, JSC::JSGlobalObject*);
 75 };
 76 
 77 using IterationKind = JSC::IterationKind;
 78 
 79 template&lt;typename JSWrapper, typename IteratorTraits&gt; class JSDOMIterator : public JSDOMObject {
 80 public:
 81     using Base = JSDOMObject;
 82 
 83     using Wrapper = JSWrapper;
 84     using Traits = IteratorTraits;
 85 
 86     using DOMWrapped = typename Wrapper::DOMWrapped;
 87     using Prototype = JSDOMIteratorPrototype&lt;Wrapper, Traits&gt;;
 88 
 89     DECLARE_INFO;
 90 
 91     static JSC::Structure* createStructure(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject, JSC::JSValue prototype)
 92     {
 93         return JSC::Structure::create(vm, globalObject, prototype, JSC::TypeInfo(JSC::ObjectType, StructureFlags), info());
 94     }
 95 
 96     static JSDOMIterator* create(JSC::VM&amp; vm, JSC::Structure* structure, JSWrapper&amp; iteratedObject, IterationKind kind)
 97     {
 98         JSDOMIterator* instance = new (NotNull, JSC::allocateCell&lt;JSDOMIterator&gt;(vm.heap)) JSDOMIterator(structure, iteratedObject, kind);
 99         instance-&gt;finishCreation(vm);
100         return instance;
101     }
102 
103     static Prototype* createPrototype(JSC::VM&amp; vm, JSC::JSGlobalObject&amp; globalObject)
104     {
105         return Prototype::create(vm, &amp;globalObject, Prototype::createStructure(vm, &amp;globalObject, globalObject.iteratorPrototype()));
106     }
107 
108     JSC::JSValue next(JSC::JSGlobalObject&amp;);
109 
110 private:
111     JSDOMIterator(JSC::Structure* structure, JSWrapper&amp; iteratedObject, IterationKind kind)
112         : Base(structure, *iteratedObject.globalObject())
113         , m_iterator(iteratedObject.wrapped().createIterator())
114         , m_kind(kind)
115     {
116     }
117 
118     template&lt;typename IteratorValue, typename T = Traits&gt; EnableIfMap&lt;T, JSC::JSValue&gt; asJS(JSC::JSGlobalObject&amp;, IteratorValue&amp;);
119     template&lt;typename IteratorValue, typename T = Traits&gt; EnableIfSet&lt;T, JSC::JSValue&gt; asJS(JSC::JSGlobalObject&amp;, IteratorValue&amp;);
120 
121     static void destroy(JSC::JSCell*);
122 
123     Optional&lt;typename DOMWrapped::Iterator&gt; m_iterator;
124     IterationKind m_kind;
125 };
126 
127 inline JSC::JSValue jsPair(JSC::JSGlobalObject&amp;, JSDOMGlobalObject&amp; globalObject, JSC::JSValue value1, JSC::JSValue value2)
128 {
129     JSC::MarkedArgumentBuffer arguments;
130     arguments.append(value1);
131     arguments.append(value2);
132     ASSERT(!arguments.hasOverflowed());
133     return constructArray(&amp;globalObject, static_cast&lt;JSC::ArrayAllocationProfile*&gt;(nullptr), arguments);
134 }
135 
136 template&lt;typename FirstType, typename SecondType, typename T, typename U&gt;
137 inline JSC::JSValue jsPair(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, const T&amp; value1, const U&amp; value2)
138 {
139     return jsPair(lexicalGlobalObject, globalObject, toJS&lt;FirstType&gt;(lexicalGlobalObject, globalObject, value1), toJS&lt;SecondType&gt;(lexicalGlobalObject, globalObject, value2));
140 }
141 
142 template&lt;typename JSIterator&gt; JSC::JSValue iteratorCreate(typename JSIterator::Wrapper&amp;, IterationKind);
143 template&lt;typename JSIterator&gt; JSC::JSValue iteratorForEach(JSC::JSGlobalObject&amp;, JSC::CallFrame&amp;, typename JSIterator::Wrapper&amp;, JSC::ThrowScope&amp;);
144 
145 template&lt;typename JSIterator&gt; JSC::JSValue iteratorCreate(typename JSIterator::Wrapper&amp; thisObject, IterationKind kind)
146 {
147     ASSERT(thisObject.globalObject());
148     JSDOMGlobalObject&amp; globalObject = *thisObject.globalObject();
149     return JSIterator::create(globalObject.vm(), getDOMStructure&lt;JSIterator&gt;(globalObject.vm(), globalObject), thisObject, kind);
150 }
151 
152 template&lt;typename JSWrapper, typename IteratorTraits&gt;
153 template&lt;typename IteratorValue, typename T&gt; inline EnableIfMap&lt;T, JSC::JSValue&gt; JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::asJS(JSC::JSGlobalObject&amp; lexicalGlobalObject, IteratorValue&amp; value)
154 {
155     ASSERT(value);
156 
157     switch (m_kind) {
158     case IterationKind::Keys:
159         return toJS&lt;typename Traits::KeyType&gt;(lexicalGlobalObject, *globalObject(), value-&gt;key);
160     case IterationKind::Values:
161         return toJS&lt;typename Traits::ValueType&gt;(lexicalGlobalObject, *globalObject(), value-&gt;value);
162     case IterationKind::Entries:
163         return jsPair&lt;typename Traits::KeyType, typename Traits::ValueType&gt;(lexicalGlobalObject, *globalObject(), value-&gt;key, value-&gt;value);
164     };
165 
166     ASSERT_NOT_REACHED();
167     return { };
168 }
169 
170 template&lt;typename JSWrapper, typename IteratorTraits&gt;
171 template&lt;typename IteratorValue, typename T&gt; inline EnableIfSet&lt;T, JSC::JSValue&gt; JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::asJS(JSC::JSGlobalObject&amp; lexicalGlobalObject, IteratorValue&amp; value)
172 {
173     ASSERT(value);
174 
175     auto globalObject = this-&gt;globalObject();
176     auto result = toJS&lt;typename Traits::ValueType&gt;(lexicalGlobalObject, *globalObject, value);
177 
178     switch (m_kind) {
179     case IterationKind::Keys:
180     case IterationKind::Values:
181         return result;
182     case IterationKind::Entries:
183         return jsPair(lexicalGlobalObject, *globalObject, result, result);
184     };
185 
186     ASSERT_NOT_REACHED();
187     return { };
188 }
189 
190 template&lt;typename JSIterator, typename IteratorValue&gt; EnableIfMap&lt;typename JSIterator::Traits&gt; appendForEachArguments(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, JSC::MarkedArgumentBuffer&amp; arguments, IteratorValue&amp; value)
191 {
192     ASSERT(value);
193     arguments.append(toJS&lt;typename JSIterator::Traits::ValueType&gt;(lexicalGlobalObject, globalObject, value-&gt;value));
194     arguments.append(toJS&lt;typename JSIterator::Traits::KeyType&gt;(lexicalGlobalObject, globalObject, value-&gt;key));
195 }
196 
197 template&lt;typename JSIterator, typename IteratorValue&gt; EnableIfSet&lt;typename JSIterator::Traits&gt; appendForEachArguments(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSDOMGlobalObject&amp; globalObject, JSC::MarkedArgumentBuffer&amp; arguments, IteratorValue&amp; value)
198 {
199     ASSERT(value);
200     auto argument = toJS&lt;typename JSIterator::Traits::ValueType&gt;(lexicalGlobalObject, globalObject, value);
201     arguments.append(argument);
202     arguments.append(argument);
203 }
204 
205 template&lt;typename JSIterator&gt; JSC::JSValue iteratorForEach(JSC::JSGlobalObject&amp; lexicalGlobalObject, JSC::CallFrame&amp; callFrame, typename JSIterator::Wrapper&amp; thisObject, JSC::ThrowScope&amp; scope)
206 {
207     JSC::JSValue callback = callFrame.argument(0);
208     JSC::JSValue thisValue = callFrame.argument(1);
209 
210     JSC::CallData callData;
211     JSC::CallType callType = JSC::getCallData(JSC::getVM(&amp;lexicalGlobalObject), callback, callData);
212     if (callType == JSC::CallType::None)
213         return throwTypeError(&amp;lexicalGlobalObject, scope, &quot;Cannot call callback&quot;_s);
214 
215     auto iterator = thisObject.wrapped().createIterator();
216     while (auto value = iterator.next()) {
217         JSC::MarkedArgumentBuffer arguments;
218         appendForEachArguments&lt;JSIterator&gt;(lexicalGlobalObject, *thisObject.globalObject(), arguments, value);
219         arguments.append(&amp;thisObject);
220         if (UNLIKELY(arguments.hasOverflowed())) {
221             throwOutOfMemoryError(&amp;lexicalGlobalObject, scope);
222             return { };
223         }
224         JSC::call(&amp;lexicalGlobalObject, callback, callType, callData, thisValue, arguments);
225         if (UNLIKELY(scope.exception()))
226             break;
227     }
228     return JSC::jsUndefined();
229 }
230 
231 template&lt;typename JSWrapper, typename IteratorTraits&gt;
232 void JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::destroy(JSCell* cell)
233 {
234     JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;* thisObject = static_cast&lt;JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;*&gt;(cell);
235     thisObject-&gt;JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::~JSDOMIterator();
236 }
237 
238 template&lt;typename JSWrapper, typename IteratorTraits&gt;
239 JSC::JSValue JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;::next(JSC::JSGlobalObject&amp; lexicalGlobalObject)
240 {
241     if (m_iterator) {
242         auto iteratorValue = m_iterator-&gt;next();
243         if (iteratorValue)
244             return createIteratorResultObject(&amp;lexicalGlobalObject, asJS(lexicalGlobalObject, iteratorValue), false);
245         m_iterator = WTF::nullopt;
246     }
247     return createIteratorResultObject(&amp;lexicalGlobalObject, JSC::jsUndefined(), true);
248 }
249 
250 template&lt;typename JSWrapper, typename IteratorTraits&gt;
251 JSC::EncodedJSValue JSC_HOST_CALL JSDOMIteratorPrototype&lt;JSWrapper, IteratorTraits&gt;::next(JSC::JSGlobalObject* globalObject, JSC::CallFrame* callFrame)
252 {
253     JSC::VM&amp; vm = globalObject-&gt;vm();
254     auto scope = DECLARE_THROW_SCOPE(vm);
255 
256     auto iterator = JSC::jsDynamicCast&lt;JSDOMIterator&lt;JSWrapper, IteratorTraits&gt;*&gt;(vm, callFrame-&gt;thisValue());
257     if (!iterator)
258         return JSC::JSValue::encode(throwTypeError(globalObject, scope, &quot;Cannot call next() on a non-Iterator object&quot;_s));
259 
260     return JSC::JSValue::encode(iterator-&gt;next(*globalObject));
261 }
262 
263 template&lt;typename JSWrapper, typename IteratorTraits&gt;
264 void JSDOMIteratorPrototype&lt;JSWrapper, IteratorTraits&gt;::finishCreation(JSC::VM&amp; vm, JSC::JSGlobalObject* globalObject)
265 {
266     Base::finishCreation(vm);
267     ASSERT(inherits(vm, info()));
268 
269     putDirectWithoutTransition(vm, vm.propertyNames-&gt;toStringTagSymbol, jsString(vm, info()-&gt;className), JSC::PropertyAttribute::DontEnum | JSC::PropertyAttribute::ReadOnly);
270     JSC_NATIVE_INTRINSIC_FUNCTION_WITHOUT_TRANSITION(vm.propertyNames-&gt;next, next, 0, 0, JSC::NoIntrinsic);
271 }
272 
273 }
    </pre>
  </body>
</html>
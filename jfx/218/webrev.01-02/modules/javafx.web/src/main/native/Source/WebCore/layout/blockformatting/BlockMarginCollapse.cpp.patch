diff a/modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockMarginCollapse.cpp b/modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockMarginCollapse.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockMarginCollapse.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/layout/blockformatting/BlockMarginCollapse.cpp
@@ -26,10 +26,12 @@
 #include "config.h"
 #include "BlockFormattingContext.h"
 
 #if ENABLE(LAYOUT_FORMATTING_CONTEXT)
 
+#include "BlockFormattingState.h"
+#include "FloatingState.h"
 #include "InlineFormattingState.h"
 #include "LayoutBox.h"
 #include "LayoutContainer.h"
 #include "LayoutUnit.h"
 #include "RenderStyle.h"
@@ -68,51 +70,52 @@
 static bool hasPaddingAfter(const Box& layoutBox)
 {
     return hasPadding(layoutBox.style().paddingAfter());
 }
 
-static bool hasClearance(const LayoutState& layoutState, const Box& layoutBox)
-{
-    if (!layoutBox.hasFloatClear())
-        return false;
-    return layoutState.displayBoxForLayoutBox(layoutBox).hasClearance();
-}
-
 static bool establishesBlockFormattingContext(const Box& layoutBox)
 {
     // WebKit treats the document element renderer as a block formatting context root. It probably only impacts margin collapsing, so let's not do
     // a layout wide quirk on this for now.
     if (layoutBox.isDocumentBox())
         return true;
     return layoutBox.establishesBlockFormattingContext();
 }
 
-bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithParentMarginAfter(const LayoutState& layoutState, const Box& layoutBox)
+bool BlockFormattingContext::MarginCollapse::hasClearance(const Box& layoutBox) const
+{
+    if (!layoutBox.hasFloatClear())
+        return false;
+    // FIXME: precomputedVerticalPositionForFormattingRoot logic ends up calling into this function when the layoutBox (first inflow child) has
+    // not been laid out.
+    if (!layoutState().hasDisplayBox(layoutBox))
+        return false;
+    return formattingContext().geometryForBox(layoutBox).hasClearance();
+}
+
+bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithParentMarginAfter(const Box& layoutBox) const
 {
     // 1. This is the last in-flow child and its margins collapse through and the margin after collapses with parent's margin after or
     // 2. This box's margin after collapses with the next sibling's margin before and that sibling collapses through and
     // we can get to the last in-flow child like that.
     auto* lastInFlowChild = layoutBox.parent()->lastInFlowChild();
     for (auto* currentBox = &layoutBox; currentBox; currentBox = currentBox->nextInFlowSibling()) {
-        if (!marginsCollapseThrough(layoutState, *currentBox))
+        if (!marginsCollapseThrough(*currentBox))
             return false;
         if (currentBox == lastInFlowChild)
-            return marginAfterCollapsesWithParentMarginAfter(layoutState, *currentBox);
-        if (!marginAfterCollapsesWithNextSiblingMarginBefore(layoutState, *currentBox))
+            return marginAfterCollapsesWithParentMarginAfter(*currentBox);
+        if (!marginAfterCollapsesWithNextSiblingMarginBefore(*currentBox))
             return false;
     }
     ASSERT_NOT_REACHED();
     return false;
 }
 
-bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithParentMarginBefore(const LayoutState& layoutState, const Box& layoutBox)
+bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithParentMarginBefore(const Box& layoutBox) const
 {
     // The first inflow child could propagate its top margin to parent.
     // https://www.w3.org/TR/CSS21/box.html#collapsing-margins
-    if (layoutBox.isAnonymous())
-        return false;
-
     ASSERT(layoutBox.isBlockLevelBox());
 
     // Margins between a floated box and any other box do not collapse.
     if (layoutBox.isFloatingPositioned())
         return false;
@@ -139,30 +142,24 @@
 
     if (hasPaddingBefore(parent))
         return false;
 
     // ...and the child has no clearance.
-    if (hasClearance(layoutState, layoutBox))
+    if (hasClearance(layoutBox))
         return false;
 
     return true;
 }
 
-bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithPreviousSiblingMarginAfter(const LayoutState& layoutState, const Box& layoutBox)
+bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithPreviousSiblingMarginAfter(const Box& layoutBox) const
 {
     ASSERT(layoutBox.isBlockLevelBox());
 
-    if (layoutBox.isAnonymous())
-        return false;
-
     if (!layoutBox.previousInFlowSibling())
         return false;
 
     auto& previousInFlowSibling = *layoutBox.previousInFlowSibling();
-    if (previousInFlowSibling.isAnonymous())
-        return false;
-
     // Margins between a floated box and any other box do not collapse.
     if (layoutBox.isFloatingPositioned() || previousInFlowSibling.isFloatingPositioned())
         return false;
 
     // Margins of absolutely positioned boxes do not collapse.
@@ -174,21 +171,18 @@
     if (layoutBox.isInlineBlockBox() || previousInFlowSibling.isInlineBlockBox())
         return false;
 
     // The bottom margin of an in-flow block-level element always collapses with the top margin of
     // its next in-flow block-level sibling, unless that sibling has clearance.
-    if (hasClearance(layoutState, layoutBox))
+    if (hasClearance(layoutBox))
         return false;
 
     return true;
 }
 
-bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithFirstInFlowChildMarginBefore(const LayoutState& layoutState, const Box& layoutBox)
+bool BlockFormattingContext::MarginCollapse::marginBeforeCollapsesWithFirstInFlowChildMarginBefore(const Box& layoutBox) const
 {
-    if (layoutBox.isAnonymous())
-        return false;
-
     ASSERT(layoutBox.isBlockLevelBox());
     // Margins of elements that establish new block formatting contexts do not collapse with their in-flow children.
     if (establishesBlockFormattingContext(layoutBox))
         return false;
 
@@ -207,59 +201,56 @@
     auto& firstInFlowChild = *downcast<Container>(layoutBox).firstInFlowChild();
     if (!firstInFlowChild.isBlockLevelBox())
         return false;
 
     // ...and the child has no clearance.
-    if (hasClearance(layoutState, firstInFlowChild))
+    if (hasClearance(firstInFlowChild))
         return false;
 
     // Margins of inline-block boxes do not collapse.
     if (firstInFlowChild.isInlineBlockBox())
         return false;
 
     return true;
 }
 
-bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithSiblingMarginBeforeWithClearance(const LayoutState& layoutState, const Box& layoutBox)
+bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithSiblingMarginBeforeWithClearance(const Box& layoutBox) const
 {
     // If the top and bottom margins of an element with clearance are adjoining, its margins collapse with the adjoining margins
     // of following siblings but that resulting margin does not collapse with the bottom margin of the parent block.
-    if (!marginsCollapseThrough(layoutState, layoutBox))
+    if (!marginsCollapseThrough(layoutBox))
         return false;
 
     for (auto* previousSibling = layoutBox.previousInFlowSibling(); previousSibling; previousSibling = previousSibling->previousInFlowSibling()) {
-        if (!marginsCollapseThrough(layoutState, *previousSibling))
+        if (!marginsCollapseThrough(*previousSibling))
             return false;
-        if (hasClearance(layoutState, *previousSibling))
+        if (hasClearance(*previousSibling))
             return true;
     }
     return false;
 }
 
-bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithParentMarginBefore(const LayoutState& layoutState, const Box& layoutBox)
+bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithParentMarginBefore(const Box& layoutBox) const
 {
     // 1. This is the first in-flow child and its margins collapse through and the margin before collapses with parent's margin before or
     // 2. This box's margin before collapses with the previous sibling's margin after and that sibling collapses through and
     // we can get to the first in-flow child like that.
     auto* firstInFlowChild = layoutBox.parent()->firstInFlowChild();
     for (auto* currentBox = &layoutBox; currentBox; currentBox = currentBox->previousInFlowSibling()) {
-        if (!marginsCollapseThrough(layoutState, *currentBox))
+        if (!marginsCollapseThrough(*currentBox))
             return false;
         if (currentBox == firstInFlowChild)
-            return marginBeforeCollapsesWithParentMarginBefore(layoutState, *currentBox);
-        if (!marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutState, *currentBox))
+            return marginBeforeCollapsesWithParentMarginBefore(*currentBox);
+        if (!marginBeforeCollapsesWithPreviousSiblingMarginAfter(*currentBox))
             return false;
     }
     ASSERT_NOT_REACHED();
     return false;
 }
 
-bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithParentMarginAfter(const LayoutState& layoutState, const Box& layoutBox)
+bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithParentMarginAfter(const Box& layoutBox) const
 {
-    if (layoutBox.isAnonymous())
-        return false;
-
     ASSERT(layoutBox.isBlockLevelBox());
 
     // Margins between a floated box and any other box do not collapse.
     if (layoutBox.isFloatingPositioned())
         return false;
@@ -292,22 +283,22 @@
     // the box has no bottom border, and
     if (hasBorderAfter(parent))
         return false;
 
     // the child's bottom margin neither collapses with a top margin that has clearance...
-    if (marginAfterCollapsesWithSiblingMarginBeforeWithClearance(layoutState, layoutBox))
+    if (marginAfterCollapsesWithSiblingMarginBeforeWithClearance(layoutBox))
         return false;
 
     // nor (if the box's min-height is non-zero) with the box's top margin.
     auto computedMinHeight = parent.style().logicalMinHeight();
-    if (!computedMinHeight.isAuto() && computedMinHeight.value() && marginAfterCollapsesWithParentMarginBefore(layoutState, layoutBox))
+    if (!computedMinHeight.isAuto() && computedMinHeight.value() && marginAfterCollapsesWithParentMarginBefore(layoutBox))
         return false;
 
     return true;
 }
 
-bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithLastInFlowChildMarginAfter(const LayoutState& layoutState, const Box& layoutBox)
+bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithLastInFlowChildMarginAfter(const Box& layoutBox) const
 {
     ASSERT(layoutBox.isBlockLevelBox());
 
     // Margins of elements that establish new block formatting contexts do not collapse with their in-flow children.
     if (establishesBlockFormattingContext(layoutBox))
@@ -331,37 +322,42 @@
     // the box has no bottom border, and
     if (hasBorderAfter(layoutBox))
         return false;
 
     // the child's bottom margin neither collapses with a top margin that has clearance...
-    if (marginAfterCollapsesWithSiblingMarginBeforeWithClearance(layoutState, lastInFlowChild))
+    if (marginAfterCollapsesWithSiblingMarginBeforeWithClearance(lastInFlowChild))
         return false;
 
     // nor (if the box's min-height is non-zero) with the box's top margin.
     auto computedMinHeight = layoutBox.style().logicalMinHeight();
     if (!computedMinHeight.isAuto() && computedMinHeight.value()
-        && (marginAfterCollapsesWithParentMarginBefore(layoutState, lastInFlowChild) || hasClearance(layoutState, lastInFlowChild)))
+        && (marginAfterCollapsesWithParentMarginBefore(lastInFlowChild) || hasClearance(lastInFlowChild)))
         return false;
 
     // Margins of inline-block boxes do not collapse.
     if (lastInFlowChild.isInlineBlockBox())
         return false;
 
+    // This is a quirk behavior: When the margin after of the last inflow child (or a previous sibling with collapsed through margins)
+    // collapses with a quirk parent's the margin before, then the same margin after does not collapses with the parent's margin after.
+    if (formattingContext().quirks().shouldIgnoreCollapsedQuirkMargin(layoutBox) && marginAfterCollapsesWithParentMarginBefore(lastInFlowChild))
+        return false;
+
     return true;
 }
 
-bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithNextSiblingMarginBefore(const LayoutState& layoutState, const Box& layoutBox)
+bool BlockFormattingContext::MarginCollapse::marginAfterCollapsesWithNextSiblingMarginBefore(const Box& layoutBox) const
 {
     ASSERT(layoutBox.isBlockLevelBox());
 
     if (!layoutBox.nextInFlowSibling())
         return false;
 
-    return marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutState, *layoutBox.nextInFlowSibling());
+    return marginBeforeCollapsesWithPreviousSiblingMarginAfter(*layoutBox.nextInFlowSibling());
 }
 
-bool BlockFormattingContext::MarginCollapse::marginsCollapseThrough(const LayoutState& layoutState, const Box& layoutBox)
+bool BlockFormattingContext::MarginCollapse::marginsCollapseThrough(const Box& layoutBox) const
 {
     ASSERT(layoutBox.isBlockLevelBox());
 
     // A box's own margins collapse if the 'min-height' property is zero, and it has neither top or bottom borders nor top or bottom padding,
     // and it has a 'height' of either 0 or 'auto', and it does not contain a line box, and all of its in-flow children's margins (if any) collapse.
@@ -390,34 +386,44 @@
     if (!downcast<Container>(layoutBox).hasInFlowChild())
         return !establishesBlockFormattingContext(layoutBox);
 
     if (layoutBox.establishesFormattingContext()) {
         if (layoutBox.establishesInlineFormattingContext()) {
+            auto& layoutState = this->layoutState();
             // If we get here through margin estimation, we don't necessarily have an actual state for this layout box since
             // we haven't started laying it out yet.
-            if (!layoutState.hasFormattingState(layoutBox))
-                return false;
-            auto& formattingState = downcast<InlineFormattingState>(layoutState.establishedFormattingState(layoutBox));
-            if (!formattingState.inlineRuns().isEmpty())
+            auto& layoutContainer = downcast<Container>(layoutBox);
+            if (!layoutState.hasInlineFormattingState(layoutContainer))
                 return false;
-            // Any float box in this formatting context prevents collapsing through.
-            auto& floats = formattingState.floatingState().floats();
-            for (auto& floatItem : floats) {
-                if (floatItem.isDescendantOfFormattingRoot(downcast<Container>(layoutBox)))
-                    return false;
-            }
-            return true;
+
+            auto isConsideredEmpty = [&] {
+                auto& formattingState = layoutState.establishedInlineFormattingState(layoutContainer);
+                if (auto* inlineContent = formattingState.displayInlineContent()) {
+                    for (auto& lineBox : inlineContent->lineBoxes) {
+                        if (!lineBox.isConsideredEmpty())
+                            return false;
+                    }
+                }
+                // Any float box in this formatting context prevents collapsing through.
+                auto& floats = formattingState.floatingState().floats();
+                for (auto& floatItem : floats) {
+                    if (floatItem.isDescendantOfFormattingRoot(layoutContainer))
+                        return false;
+                }
+                return true;
+            };
+            return isConsideredEmpty();
         }
 
         // A root of a non-inline formatting context (table, flex etc) with inflow descendants should not collapse through.
         return false;
     }
 
     for (auto* inflowChild = downcast<Container>(layoutBox).firstInFlowOrFloatingChild(); inflowChild; inflowChild = inflowChild->nextInFlowOrFloatingSibling()) {
         if (establishesBlockFormattingContext(*inflowChild))
             return false;
-        if (!marginsCollapseThrough(layoutState, *inflowChild))
+        if (!marginsCollapseThrough(*inflowChild))
             return false;
     }
     return true;
 }
 
@@ -456,38 +462,34 @@
         return marginValues.negative;
 
     return *marginValues.positive + *marginValues.negative;
 }
 
-void BlockFormattingContext::MarginCollapse::updateMarginAfterForPreviousSibling(const LayoutState& layoutState, const Box& layoutBox)
+void BlockFormattingContext::MarginCollapse::updateMarginAfterForPreviousSibling(BlockFormattingContext& blockFormattingContext, const MarginCollapse& marginCollapse, const Box& layoutBox)
 {
     // 1. Get the margin before value from the next in-flow sibling. This is the same as this box's margin after value now since they are collapsed.
     // 2. Update the collapsed margin after value as well as the positive/negative cache.
     // 3. Check if the box's margins collapse through.
-    // 4. If so, update the collapsed margin before value as well as the positive/negative cache.
+    // 4. If so, update the positive/negative cache.
     // 5. In case of collapsed through margins check if the before margin collapes with the previous inflow sibling's after margin.
     // 6. If so, jump to #2.
-    // 7. No need to propagate to parent because its margin is not computed yet (estimated at most).
+    // 7. No need to propagate to parent because its margin is not computed yet (pre-computed at most).
     auto* currentBox = &layoutBox;
-    while (marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutState, *currentBox)) {
+    auto& blockFormattingState = blockFormattingContext.formattingState();
+    while (marginCollapse.marginBeforeCollapsesWithPreviousSiblingMarginAfter(*currentBox)) {
         auto& previousSibling = *currentBox->previousInFlowSibling();
-        auto& previousSiblingDisplayBox = layoutState.displayBoxForLayoutBox(previousSibling);
+        auto& previousSiblingDisplayBox = blockFormattingState.displayBox(previousSibling);
         auto previousSiblingVerticalMargin = previousSiblingDisplayBox.verticalMargin();
 
         auto collapsedVerticalMarginBefore = previousSiblingVerticalMargin.collapsedValues().before;
-        auto collapsedVerticalMarginAfter = layoutState.displayBoxForLayoutBox(*currentBox).verticalMargin().before();
+        auto collapsedVerticalMarginAfter = blockFormattingContext.geometryForBox(*currentBox).verticalMargin().before();
 
-        auto marginsCollapseThrough = MarginCollapse::marginsCollapseThrough(layoutState, previousSibling);
+        auto marginsCollapseThrough = marginCollapse.marginsCollapseThrough(previousSibling);
         if (marginsCollapseThrough)
             collapsedVerticalMarginBefore = collapsedVerticalMarginAfter;
 
-        // Update collapsed vertical margin values.
-        previousSiblingVerticalMargin.setCollapsedValues({ collapsedVerticalMarginBefore, collapsedVerticalMarginAfter });
-        previousSiblingDisplayBox.setVerticalMargin(previousSiblingVerticalMargin);
-
         // Update positive/negative cache.
-        auto& blockFormattingState = downcast<BlockFormattingState>(layoutState.formattingStateForBox(previousSibling));
         auto previousSiblingPositiveNegativeMargin = blockFormattingState.positiveAndNegativeVerticalMargin(previousSibling);
         auto positiveNegativeMarginBefore = blockFormattingState.positiveAndNegativeVerticalMargin(*currentBox).before;
 
         previousSiblingPositiveNegativeMargin.after = computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, previousSiblingPositiveNegativeMargin.after);
         if (marginsCollapseThrough) {
@@ -501,46 +503,46 @@
 
         currentBox = &previousSibling;
     }
 }
 
-PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeValues(const LayoutState& layoutState, const Box& layoutBox, MarginType marginType)
+PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeValues(const Box& layoutBox, MarginType marginType) const
 {
+    auto& layoutState = this->layoutState();
     auto& blockFormattingState = downcast<BlockFormattingState>(layoutState.formattingStateForBox(layoutBox));
     if (blockFormattingState.hasPositiveAndNegativeVerticalMargin(layoutBox)) {
         auto positiveAndNegativeVerticalMargin = blockFormattingState.positiveAndNegativeVerticalMargin(layoutBox);
         return marginType == MarginType::Before ? positiveAndNegativeVerticalMargin.before : positiveAndNegativeVerticalMargin.after;
     }
-    // This is the estimate path. We don't yet have positive/negative margin computed.
-    auto usedValues = UsedHorizontalValues { layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth() };
-    auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, usedValues);
+    // This is the pre-computed path. We don't yet have positive/negative margin computed.
+    auto computedVerticalMargin = formattingContext().geometry().computedVerticalMargin(layoutBox, Geometry::horizontalConstraintsForInFlow(formattingContext().geometryForBox(*layoutBox.containingBlock())));
     auto nonCollapsedMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
 
     if (marginType == MarginType::Before)
-        return positiveNegativeMarginBefore(layoutState, layoutBox, nonCollapsedMargin);
-    return positiveNegativeMarginAfter(layoutState, layoutBox, nonCollapsedMargin);
+        return positiveNegativeMarginBefore(layoutBox, nonCollapsedMargin);
+    return positiveNegativeMarginAfter(layoutBox, nonCollapsedMargin);
 }
 
-PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeMarginBefore(const LayoutState& layoutState, const Box& layoutBox, const UsedVerticalMargin::NonCollapsedValues& nonCollapsedValues)
+PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeMarginBefore(const Box& layoutBox, UsedVerticalMargin::NonCollapsedValues nonCollapsedValues) const
 {
     auto firstChildCollapsedMarginBefore = [&]() -> PositiveAndNegativeVerticalMargin::Values {
-        if (!marginBeforeCollapsesWithFirstInFlowChildMarginBefore(layoutState, layoutBox))
+        if (!marginBeforeCollapsesWithFirstInFlowChildMarginBefore(layoutBox))
             return { };
-        return positiveNegativeValues(layoutState, *downcast<Container>(layoutBox).firstInFlowChild(), MarginType::Before);
+        return positiveNegativeValues(*downcast<Container>(layoutBox).firstInFlowChild(), MarginType::Before);
     };
 
     auto previouSiblingCollapsedMarginAfter = [&]() -> PositiveAndNegativeVerticalMargin::Values {
-        if (!marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutState, layoutBox))
+        if (!marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutBox))
             return { };
-        return positiveNegativeValues(layoutState, *layoutBox.previousInFlowSibling(), MarginType::After);
+        return positiveNegativeValues(*layoutBox.previousInFlowSibling(), MarginType::After);
     };
 
     // 1. Gather positive and negative margin values from first child if margins are adjoining.
     // 2. Gather positive and negative margin values from previous inflow sibling if margins are adjoining.
     // 3. Compute min/max positive and negative collapsed margin values using non-collpased computed margin before.
     auto collapsedMarginBefore = computedPositiveAndNegativeMargin(firstChildCollapsedMarginBefore(), previouSiblingCollapsedMarginAfter());
-    if (collapsedMarginBefore.isQuirk && Quirks::shouldIgnoreCollapsedQuirkMargin(layoutState, layoutBox))
+    if (collapsedMarginBefore.isQuirk && formattingContext().quirks().shouldIgnoreCollapsedQuirkMargin(layoutBox))
         collapsedMarginBefore = { };
 
     PositiveAndNegativeVerticalMargin::Values nonCollapsedBefore;
     if (nonCollapsedValues.before > 0)
         nonCollapsedBefore = { nonCollapsedValues.before, { }, layoutBox.style().hasMarginBeforeQuirk() };
@@ -548,95 +550,82 @@
         nonCollapsedBefore = { { }, nonCollapsedValues.before, layoutBox.style().hasMarginBeforeQuirk() };
 
     return computedPositiveAndNegativeMargin(collapsedMarginBefore, nonCollapsedBefore);
 }
 
-PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeMarginAfter(const LayoutState& layoutState, const Box& layoutBox, const UsedVerticalMargin::NonCollapsedValues& nonCollapsedValues)
+PositiveAndNegativeVerticalMargin::Values BlockFormattingContext::MarginCollapse::positiveNegativeMarginAfter(const Box& layoutBox, UsedVerticalMargin::NonCollapsedValues nonCollapsedValues) const
 {
     auto lastChildCollapsedMarginAfter = [&]() -> PositiveAndNegativeVerticalMargin::Values {
-        if (!marginAfterCollapsesWithLastInFlowChildMarginAfter(layoutState, layoutBox))
+        if (!marginAfterCollapsesWithLastInFlowChildMarginAfter(layoutBox))
             return { };
-        return positiveNegativeValues(layoutState, *downcast<Container>(layoutBox).lastInFlowChild(), MarginType::After);
+        return positiveNegativeValues(*downcast<Container>(layoutBox).lastInFlowChild(), MarginType::After);
     };
 
     // We don't know yet the margin before value of the next sibling. Let's just pretend it does not have one and
-    // update it later when we compute the next sibling's margin before. See updateCollapsedMarginAfter.
+    // update it later when we compute the next sibling's margin before. See updateMarginAfterForPreviousSibling.
     PositiveAndNegativeVerticalMargin::Values nonCollapsedAfter;
     if (nonCollapsedValues.after > 0)
         nonCollapsedAfter = { nonCollapsedValues.after, { }, layoutBox.style().hasMarginAfterQuirk() };
     else if (nonCollapsedValues.after < 0)
         nonCollapsedAfter = { { }, nonCollapsedValues.after, layoutBox.style().hasMarginAfterQuirk() };
 
     return computedPositiveAndNegativeMargin(lastChildCollapsedMarginAfter(), nonCollapsedAfter);
 }
 
-EstimatedMarginBefore BlockFormattingContext::MarginCollapse::estimatedMarginBefore(const LayoutState& layoutState, const Box& layoutBox)
+PrecomputedMarginBefore BlockFormattingContext::MarginCollapse::precomputedMarginBefore(const Box& layoutBox, UsedVerticalMargin::NonCollapsedValues usedNonCollapsedMargin)
 {
-    if (layoutBox.isAnonymous())
-        return { };
-
     ASSERT(layoutBox.isBlockLevelBox());
-    // Don't estimate vertical margins for out of flow boxes.
+    // Don't pre-compute vertical margins for out of flow boxes.
     ASSERT(layoutBox.isInFlow() || layoutBox.isFloatingPositioned());
     ASSERT(!layoutBox.replaced());
 
-    auto usedValues = UsedHorizontalValues { layoutState.displayBoxForLayoutBox(*layoutBox.containingBlock()).contentBoxWidth() };
-    auto computedVerticalMargin = Geometry::computedVerticalMargin(layoutBox, usedValues);
-    auto nonCollapsedMargin = UsedVerticalMargin::NonCollapsedValues { computedVerticalMargin.before.valueOr(0), computedVerticalMargin.after.valueOr(0) };
-    auto marginsCollapseThrough = MarginCollapse::marginsCollapseThrough(layoutState, layoutBox);
-    auto positiveNegativeMarginBefore = MarginCollapse::positiveNegativeMarginBefore(layoutState, layoutBox, nonCollapsedMargin);
+    auto marginsCollapseThrough = this->marginsCollapseThrough(layoutBox);
+    auto positiveNegativeMarginBefore = this->positiveNegativeMarginBefore(layoutBox, usedNonCollapsedMargin);
 
     auto collapsedMarginBefore = marginValue(!marginsCollapseThrough ? positiveNegativeMarginBefore
-        : computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, positiveNegativeMarginAfter(layoutState, layoutBox, nonCollapsedMargin)));
+        : computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, positiveNegativeMarginAfter(layoutBox, usedNonCollapsedMargin)));
 
-    return { nonCollapsedMargin.before, collapsedMarginBefore, marginsCollapseThrough };
+    return { usedNonCollapsedMargin.before, collapsedMarginBefore, marginsCollapseThrough };
 }
 
-LayoutUnit BlockFormattingContext::MarginCollapse::marginBeforeIgnoringCollapsingThrough(const LayoutState& layoutState, const Box& layoutBox, const UsedVerticalMargin::NonCollapsedValues& nonCollapsedValues)
+LayoutUnit BlockFormattingContext::MarginCollapse::marginBeforeIgnoringCollapsingThrough(const Box& layoutBox, UsedVerticalMargin::NonCollapsedValues nonCollapsedValues)
 {
-    ASSERT(!layoutBox.isAnonymous());
     ASSERT(layoutBox.isBlockLevelBox());
-    return marginValue(positiveNegativeMarginBefore(layoutState, layoutBox, nonCollapsedValues)).valueOr(nonCollapsedValues.before);
+    return marginValue(positiveNegativeMarginBefore(layoutBox, nonCollapsedValues)).valueOr(nonCollapsedValues.before);
 }
 
-void BlockFormattingContext::MarginCollapse::updatePositiveNegativeMarginValues(const LayoutState& layoutState, const Box& layoutBox)
+PositiveAndNegativeVerticalMargin BlockFormattingContext::MarginCollapse::resolvedPositiveNegativeMarginValues(const Box& layoutBox, const UsedVerticalMargin::NonCollapsedValues& nonCollapsedValues)
 {
     ASSERT(layoutBox.isBlockLevelBox());
-    auto nonCollapsedValues = layoutState.displayBoxForLayoutBox(layoutBox).verticalMargin().nonCollapsedValues();
-
-    auto positiveNegativeMarginBefore = MarginCollapse::positiveNegativeMarginBefore(layoutState, layoutBox, nonCollapsedValues);
-    auto positiveNegativeMarginAfter = MarginCollapse::positiveNegativeMarginAfter(layoutState, layoutBox, nonCollapsedValues);
+    auto positiveNegativeMarginBefore = this->positiveNegativeMarginBefore(layoutBox, nonCollapsedValues);
+    auto positiveNegativeMarginAfter = this->positiveNegativeMarginAfter(layoutBox, nonCollapsedValues);
 
-    if (MarginCollapse::marginsCollapseThrough(layoutState, layoutBox)) {
+    if (marginsCollapseThrough(layoutBox)) {
         positiveNegativeMarginBefore = computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, positiveNegativeMarginAfter);
         positiveNegativeMarginAfter = positiveNegativeMarginBefore;
     }
-    auto& blockFormattingState = downcast<BlockFormattingState>(layoutState.formattingStateForBox(layoutBox));
-    blockFormattingState.setPositiveAndNegativeVerticalMargin(layoutBox, { positiveNegativeMarginBefore, positiveNegativeMarginAfter });
+    return { positiveNegativeMarginBefore, positiveNegativeMarginAfter };
 }
 
-UsedVerticalMargin::CollapsedValues BlockFormattingContext::MarginCollapse::collapsedVerticalValues(const LayoutState& layoutState, const Box& layoutBox, const UsedVerticalMargin::NonCollapsedValues& nonCollapsedValues)
+UsedVerticalMargin::CollapsedValues BlockFormattingContext::MarginCollapse::collapsedVerticalValues(const Box& layoutBox, UsedVerticalMargin::NonCollapsedValues nonCollapsedValues)
 {
-    if (layoutBox.isAnonymous())
-        return { };
-
     ASSERT(layoutBox.isBlockLevelBox());
     // 1. Get min/max margin top values from the first in-flow child if we are collapsing margin top with it.
     // 2. Get min/max margin top values from the previous in-flow sibling, if we are collapsing margin top with it.
     // 3. Get this layout box's computed margin top value.
     // 4. Update the min/max value and compute the final margin.
-    auto positiveNegativeMarginBefore = MarginCollapse::positiveNegativeMarginBefore(layoutState, layoutBox, nonCollapsedValues);
-    auto positiveNegativeMarginAfter = MarginCollapse::positiveNegativeMarginAfter(layoutState, layoutBox, nonCollapsedValues);
+    auto positiveNegativeMarginBefore = this->positiveNegativeMarginBefore(layoutBox, nonCollapsedValues);
+    auto positiveNegativeMarginAfter = this->positiveNegativeMarginAfter(layoutBox, nonCollapsedValues);
 
-    auto marginsCollapseThrough = MarginCollapse::marginsCollapseThrough(layoutState, layoutBox);
+    auto marginsCollapseThrough = this->marginsCollapseThrough(layoutBox);
     if (marginsCollapseThrough) {
         positiveNegativeMarginBefore = computedPositiveAndNegativeMargin(positiveNegativeMarginBefore, positiveNegativeMarginAfter);
         positiveNegativeMarginAfter = positiveNegativeMarginBefore;
     }
 
-    auto beforeMarginIsCollapsedValue = marginBeforeCollapsesWithFirstInFlowChildMarginBefore(layoutState, layoutBox) || marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutState, layoutBox);
-    auto afterMarginIsCollapsedValue = marginAfterCollapsesWithLastInFlowChildMarginAfter(layoutState, layoutBox);
+    auto beforeMarginIsCollapsedValue = marginBeforeCollapsesWithFirstInFlowChildMarginBefore(layoutBox) || marginBeforeCollapsesWithPreviousSiblingMarginAfter(layoutBox);
+    auto afterMarginIsCollapsedValue = marginAfterCollapsesWithLastInFlowChildMarginAfter(layoutBox);
 
     if ((beforeMarginIsCollapsedValue && afterMarginIsCollapsedValue) || marginsCollapseThrough)
         return { marginValue(positiveNegativeMarginBefore), marginValue(positiveNegativeMarginAfter), marginsCollapseThrough };
     if (beforeMarginIsCollapsedValue)
         return { marginValue(positiveNegativeMarginBefore), { }, false };

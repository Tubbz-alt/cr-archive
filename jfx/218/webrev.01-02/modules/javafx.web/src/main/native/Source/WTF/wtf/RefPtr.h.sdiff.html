<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WTF/wtf/RefPtr.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RefCountedArray.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RetainPtr.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WTF/wtf/RefPtr.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 27 #include &lt;wtf/FastMalloc.h&gt;
 28 #include &lt;wtf/Ref.h&gt;
 29 
 30 namespace WTF {
 31 
 32 template&lt;typename T, typename PtrTraits&gt; class RefPtr;
 33 template&lt;typename T, typename PtrTraits = DumbPtrTraits&lt;T&gt;&gt; RefPtr&lt;T, PtrTraits&gt; adoptRef(T*);
 34 
 35 template&lt;typename T&gt; ALWAYS_INLINE void refIfNotNull(T* ptr)
 36 {
 37     if (LIKELY(ptr != nullptr))
 38         ptr-&gt;ref();
 39 }
 40 
 41 template&lt;typename T&gt; ALWAYS_INLINE void derefIfNotNull(T* ptr)
 42 {
 43     if (LIKELY(ptr != nullptr))
 44         ptr-&gt;deref();
 45 }
 46 
<span class="line-modified"> 47 template&lt;typename T, typename PtrTraits&gt;</span>
 48 class RefPtr {
 49     WTF_MAKE_FAST_ALLOCATED;
 50 public:

 51     typedef T ValueType;
 52     typedef ValueType* PtrType;
 53 
 54     static constexpr bool isRefPtr = true;
 55 
 56     ALWAYS_INLINE constexpr RefPtr() : m_ptr(nullptr) { }
 57     ALWAYS_INLINE RefPtr(T* ptr) : m_ptr(ptr) { refIfNotNull(ptr); }
 58     ALWAYS_INLINE RefPtr(const RefPtr&amp; o) : m_ptr(o.m_ptr) { refIfNotNull(PtrTraits::unwrap(m_ptr)); }
 59     template&lt;typename X, typename Y&gt; RefPtr(const RefPtr&lt;X, Y&gt;&amp; o) : m_ptr(o.get()) { refIfNotNull(PtrTraits::unwrap(m_ptr)); }
 60 
 61     ALWAYS_INLINE RefPtr(RefPtr&amp;&amp; o) : m_ptr(o.leakRef()) { }
 62     template&lt;typename X, typename Y&gt; RefPtr(RefPtr&lt;X, Y&gt;&amp;&amp; o) : m_ptr(o.leakRef()) { }
 63     template&lt;typename X, typename Y&gt; RefPtr(Ref&lt;X, Y&gt;&amp;&amp;);
 64 
 65     // Hash table deleted values, which are only constructed and never copied or destroyed.
<span class="line-modified"> 66     RefPtr(HashTableDeletedValueType) : m_ptr(hashTableDeletedValue()) { }</span>
<span class="line-modified"> 67     bool isHashTableDeletedValue() const { return m_ptr == hashTableDeletedValue(); }</span>
 68 
 69     ALWAYS_INLINE ~RefPtr() { derefIfNotNull(PtrTraits::exchange(m_ptr, nullptr)); }
 70 
 71     T* get() const { return PtrTraits::unwrap(m_ptr); }
 72 
 73     Ref&lt;T&gt; releaseNonNull() { ASSERT(m_ptr); Ref&lt;T&gt; tmp(adoptRef(*m_ptr)); m_ptr = nullptr; return tmp; }
 74     Ref&lt;const T&gt; releaseConstNonNull() { ASSERT(m_ptr); Ref&lt;const T&gt; tmp(adoptRef(*m_ptr)); m_ptr = nullptr; return tmp; }
 75 
 76     T* leakRef() WARN_UNUSED_RETURN;
 77 
 78     T&amp; operator*() const { ASSERT(m_ptr); return *PtrTraits::unwrap(m_ptr); }
 79     ALWAYS_INLINE T* operator-&gt;() const { return PtrTraits::unwrap(m_ptr); }
 80 
 81     bool operator!() const { return !m_ptr; }
 82 
 83     // This conversion operator allows implicit conversion to bool but not to other integer types.
<span class="line-modified"> 84     typedef T* (RefPtr::*UnspecifiedBoolType);</span>
<span class="line-modified"> 85     operator UnspecifiedBoolType() const { return m_ptr ? &amp;RefPtr::m_ptr : nullptr; }</span>
 86 
 87     explicit operator bool() const { return !!m_ptr; }
 88 
 89     RefPtr&amp; operator=(const RefPtr&amp;);
 90     RefPtr&amp; operator=(T*);
 91     RefPtr&amp; operator=(std::nullptr_t);
 92     template&lt;typename X, typename Y&gt; RefPtr&amp; operator=(const RefPtr&lt;X, Y&gt;&amp;);
 93     RefPtr&amp; operator=(RefPtr&amp;&amp;);
 94     template&lt;typename X, typename Y&gt; RefPtr&amp; operator=(RefPtr&lt;X, Y&gt;&amp;&amp;);
 95     template&lt;typename X&gt; RefPtr&amp; operator=(Ref&lt;X&gt;&amp;&amp;);
 96 
 97     template&lt;typename X, typename Y&gt; void swap(RefPtr&lt;X, Y&gt;&amp;);
 98 
<span class="line-removed"> 99     static T* hashTableDeletedValue() { return reinterpret_cast&lt;T*&gt;(-1); }</span>
<span class="line-removed">100 </span>
101     RefPtr copyRef() &amp;&amp; = delete;
102     RefPtr copyRef() const &amp; WARN_UNUSED_RETURN { return RefPtr(m_ptr); }
103 
104 private:


105     friend RefPtr adoptRef&lt;T, PtrTraits&gt;(T*);
106     template&lt;typename X, typename Y&gt; friend class RefPtr;
107 
108     enum AdoptTag { Adopt };
109     RefPtr(T* ptr, AdoptTag) : m_ptr(ptr) { }
110 
111     typename PtrTraits::StorageType m_ptr;
112 };
113 
114 template&lt;typename T, typename U&gt;
115 template&lt;typename X, typename Y&gt;
116 inline RefPtr&lt;T, U&gt;::RefPtr(Ref&lt;X, Y&gt;&amp;&amp; reference)
117     : m_ptr(&amp;reference.leakRef())
118 {
119 }
120 
121 template&lt;typename T, typename U&gt;
122 inline T* RefPtr&lt;T, U&gt;::leakRef()
123 {
124     return U::exchange(m_ptr, nullptr);
</pre>
<hr />
<pre>
222 template&lt;typename T, typename U, typename X&gt;
223 inline bool operator!=(const RefPtr&lt;T, U&gt;&amp; a, X* b)
224 {
225     return a.get() != b;
226 }
227 
228 template&lt;typename T, typename X, typename Y&gt;
229 inline bool operator!=(T* a, const RefPtr&lt;X, Y&gt;&amp; b)
230 {
231     return a != b.get();
232 }
233 
234 template&lt;typename T, typename U = DumbPtrTraits&lt;T&gt;, typename X, typename Y&gt;
235 inline RefPtr&lt;T, U&gt; static_pointer_cast(const RefPtr&lt;X, Y&gt;&amp; p)
236 {
237     return RefPtr&lt;T, U&gt;(static_cast&lt;T*&gt;(p.get()));
238 }
239 
240 template &lt;typename T, typename U&gt;
241 struct IsSmartPtr&lt;RefPtr&lt;T, U&gt;&gt; {
<span class="line-modified">242     static const bool value = true;</span>
243 };
244 
245 template&lt;typename T, typename U&gt;
246 inline RefPtr&lt;T, U&gt; adoptRef(T* p)
247 {
248     adopted(p);
249     return RefPtr&lt;T, U&gt;(p, RefPtr&lt;T, U&gt;::Adopt);
250 }
251 
252 template&lt;typename T&gt; inline RefPtr&lt;T&gt; makeRefPtr(T* pointer)
253 {
254     return pointer;
255 }
256 
257 template&lt;typename T&gt; inline RefPtr&lt;T&gt; makeRefPtr(T&amp; reference)
258 {
259     return &amp;reference;
260 }
261 
262 template&lt;typename ExpectedType, typename ArgType, typename PtrTraits&gt;
</pre>
</td>
<td>
<hr />
<pre>
 27 #include &lt;wtf/FastMalloc.h&gt;
 28 #include &lt;wtf/Ref.h&gt;
 29 
 30 namespace WTF {
 31 
 32 template&lt;typename T, typename PtrTraits&gt; class RefPtr;
 33 template&lt;typename T, typename PtrTraits = DumbPtrTraits&lt;T&gt;&gt; RefPtr&lt;T, PtrTraits&gt; adoptRef(T*);
 34 
 35 template&lt;typename T&gt; ALWAYS_INLINE void refIfNotNull(T* ptr)
 36 {
 37     if (LIKELY(ptr != nullptr))
 38         ptr-&gt;ref();
 39 }
 40 
 41 template&lt;typename T&gt; ALWAYS_INLINE void derefIfNotNull(T* ptr)
 42 {
 43     if (LIKELY(ptr != nullptr))
 44         ptr-&gt;deref();
 45 }
 46 
<span class="line-modified"> 47 template&lt;typename T, typename Traits&gt;</span>
 48 class RefPtr {
 49     WTF_MAKE_FAST_ALLOCATED;
 50 public:
<span class="line-added"> 51     using PtrTraits = Traits;</span>
 52     typedef T ValueType;
 53     typedef ValueType* PtrType;
 54 
 55     static constexpr bool isRefPtr = true;
 56 
 57     ALWAYS_INLINE constexpr RefPtr() : m_ptr(nullptr) { }
 58     ALWAYS_INLINE RefPtr(T* ptr) : m_ptr(ptr) { refIfNotNull(ptr); }
 59     ALWAYS_INLINE RefPtr(const RefPtr&amp; o) : m_ptr(o.m_ptr) { refIfNotNull(PtrTraits::unwrap(m_ptr)); }
 60     template&lt;typename X, typename Y&gt; RefPtr(const RefPtr&lt;X, Y&gt;&amp; o) : m_ptr(o.get()) { refIfNotNull(PtrTraits::unwrap(m_ptr)); }
 61 
 62     ALWAYS_INLINE RefPtr(RefPtr&amp;&amp; o) : m_ptr(o.leakRef()) { }
 63     template&lt;typename X, typename Y&gt; RefPtr(RefPtr&lt;X, Y&gt;&amp;&amp; o) : m_ptr(o.leakRef()) { }
 64     template&lt;typename X, typename Y&gt; RefPtr(Ref&lt;X, Y&gt;&amp;&amp;);
 65 
 66     // Hash table deleted values, which are only constructed and never copied or destroyed.
<span class="line-modified"> 67     RefPtr(HashTableDeletedValueType) : m_ptr(PtrTraits::hashTableDeletedValue()) { }</span>
<span class="line-modified"> 68     bool isHashTableDeletedValue() const { return PtrTraits::isHashTableDeletedValue(m_ptr); }</span>
 69 
 70     ALWAYS_INLINE ~RefPtr() { derefIfNotNull(PtrTraits::exchange(m_ptr, nullptr)); }
 71 
 72     T* get() const { return PtrTraits::unwrap(m_ptr); }
 73 
 74     Ref&lt;T&gt; releaseNonNull() { ASSERT(m_ptr); Ref&lt;T&gt; tmp(adoptRef(*m_ptr)); m_ptr = nullptr; return tmp; }
 75     Ref&lt;const T&gt; releaseConstNonNull() { ASSERT(m_ptr); Ref&lt;const T&gt; tmp(adoptRef(*m_ptr)); m_ptr = nullptr; return tmp; }
 76 
 77     T* leakRef() WARN_UNUSED_RETURN;
 78 
 79     T&amp; operator*() const { ASSERT(m_ptr); return *PtrTraits::unwrap(m_ptr); }
 80     ALWAYS_INLINE T* operator-&gt;() const { return PtrTraits::unwrap(m_ptr); }
 81 
 82     bool operator!() const { return !m_ptr; }
 83 
 84     // This conversion operator allows implicit conversion to bool but not to other integer types.
<span class="line-modified"> 85     using UnspecifiedBoolType = void (RefPtr::*)() const;</span>
<span class="line-modified"> 86     operator UnspecifiedBoolType() const { return m_ptr ? &amp;RefPtr::unspecifiedBoolTypeInstance : nullptr; }</span>
 87 
 88     explicit operator bool() const { return !!m_ptr; }
 89 
 90     RefPtr&amp; operator=(const RefPtr&amp;);
 91     RefPtr&amp; operator=(T*);
 92     RefPtr&amp; operator=(std::nullptr_t);
 93     template&lt;typename X, typename Y&gt; RefPtr&amp; operator=(const RefPtr&lt;X, Y&gt;&amp;);
 94     RefPtr&amp; operator=(RefPtr&amp;&amp;);
 95     template&lt;typename X, typename Y&gt; RefPtr&amp; operator=(RefPtr&lt;X, Y&gt;&amp;&amp;);
 96     template&lt;typename X&gt; RefPtr&amp; operator=(Ref&lt;X&gt;&amp;&amp;);
 97 
 98     template&lt;typename X, typename Y&gt; void swap(RefPtr&lt;X, Y&gt;&amp;);
 99 


100     RefPtr copyRef() &amp;&amp; = delete;
101     RefPtr copyRef() const &amp; WARN_UNUSED_RETURN { return RefPtr(m_ptr); }
102 
103 private:
<span class="line-added">104     void unspecifiedBoolTypeInstance() const { }</span>
<span class="line-added">105 </span>
106     friend RefPtr adoptRef&lt;T, PtrTraits&gt;(T*);
107     template&lt;typename X, typename Y&gt; friend class RefPtr;
108 
109     enum AdoptTag { Adopt };
110     RefPtr(T* ptr, AdoptTag) : m_ptr(ptr) { }
111 
112     typename PtrTraits::StorageType m_ptr;
113 };
114 
115 template&lt;typename T, typename U&gt;
116 template&lt;typename X, typename Y&gt;
117 inline RefPtr&lt;T, U&gt;::RefPtr(Ref&lt;X, Y&gt;&amp;&amp; reference)
118     : m_ptr(&amp;reference.leakRef())
119 {
120 }
121 
122 template&lt;typename T, typename U&gt;
123 inline T* RefPtr&lt;T, U&gt;::leakRef()
124 {
125     return U::exchange(m_ptr, nullptr);
</pre>
<hr />
<pre>
223 template&lt;typename T, typename U, typename X&gt;
224 inline bool operator!=(const RefPtr&lt;T, U&gt;&amp; a, X* b)
225 {
226     return a.get() != b;
227 }
228 
229 template&lt;typename T, typename X, typename Y&gt;
230 inline bool operator!=(T* a, const RefPtr&lt;X, Y&gt;&amp; b)
231 {
232     return a != b.get();
233 }
234 
235 template&lt;typename T, typename U = DumbPtrTraits&lt;T&gt;, typename X, typename Y&gt;
236 inline RefPtr&lt;T, U&gt; static_pointer_cast(const RefPtr&lt;X, Y&gt;&amp; p)
237 {
238     return RefPtr&lt;T, U&gt;(static_cast&lt;T*&gt;(p.get()));
239 }
240 
241 template &lt;typename T, typename U&gt;
242 struct IsSmartPtr&lt;RefPtr&lt;T, U&gt;&gt; {
<span class="line-modified">243     static constexpr bool value = true;</span>
244 };
245 
246 template&lt;typename T, typename U&gt;
247 inline RefPtr&lt;T, U&gt; adoptRef(T* p)
248 {
249     adopted(p);
250     return RefPtr&lt;T, U&gt;(p, RefPtr&lt;T, U&gt;::Adopt);
251 }
252 
253 template&lt;typename T&gt; inline RefPtr&lt;T&gt; makeRefPtr(T* pointer)
254 {
255     return pointer;
256 }
257 
258 template&lt;typename T&gt; inline RefPtr&lt;T&gt; makeRefPtr(T&amp; reference)
259 {
260     return &amp;reference;
261 }
262 
263 template&lt;typename ExpectedType, typename ArgType, typename PtrTraits&gt;
</pre>
</td>
</tr>
</table>
<center><a href="RefCountedArray.h.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RetainPtr.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
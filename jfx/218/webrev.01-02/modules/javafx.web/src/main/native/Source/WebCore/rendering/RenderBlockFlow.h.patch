diff a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.h b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.h
--- a/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.h
+++ b/modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderBlockFlow.h
@@ -35,10 +35,16 @@
 
 class LineBreaker;
 class RenderMultiColumnFlow;
 class RenderRubyRun;
 
+#if ENABLE(LAYOUT_FORMATTING_CONTEXT)
+namespace LayoutIntegration {
+class LineLayout;
+}
+#endif
+
 #if ENABLE(TEXT_AUTOSIZING)
 enum LineCount {
     NOT_SET = 0, NO_LINE = 1, ONE_LINE = 2, MULTI_LINE = 3
 };
 #endif
@@ -70,12 +76,12 @@
     LayoutUnit collapsedMarginBefore() const final { return maxPositiveMarginBefore() - maxNegativeMarginBefore(); }
     LayoutUnit collapsedMarginAfter() const final { return maxPositiveMarginAfter() - maxNegativeMarginAfter(); }
 
     void dirtyLinesFromChangedChild(RenderObject& child) final
     {
-        if (m_complexLineLayout)
-            m_complexLineLayout->lineBoxes().dirtyLinesFromChangedChild(*this, child);
+        if (complexLineLayout())
+            complexLineLayout()->lineBoxes().dirtyLinesFromChangedChild(*this, child);
     }
 
     void paintColumnRules(PaintInfo&, const LayoutPoint&) override;
 
 public:
@@ -330,33 +336,40 @@
             floatingObject.setMarginOffset(LayoutSize(logicalBeforeMargin, logicalLeftMargin));
     }
 
     LayoutPoint flipFloatForWritingModeForChild(const FloatingObject&, const LayoutPoint&) const;
 
-    RootInlineBox* firstRootBox() const { return m_complexLineLayout ? m_complexLineLayout->firstRootBox() : nullptr; }
-    RootInlineBox* lastRootBox() const { return m_complexLineLayout ? m_complexLineLayout->lastRootBox() : nullptr; }
+    RootInlineBox* firstRootBox() const { return complexLineLayout() ? complexLineLayout()->firstRootBox() : nullptr; }
+    RootInlineBox* lastRootBox() const { return complexLineLayout() ? complexLineLayout()->lastRootBox() : nullptr; }
 
     bool hasLines() const;
     void invalidateLineLayoutPath() final;
 
-    enum LineLayoutPath { UndeterminedPath = 0, SimpleLinesPath, LineBoxesPath, ForceLineBoxesPath };
+    enum LineLayoutPath { UndeterminedPath = 0, SimpleLinesPath, LineBoxesPath, LayoutFormattingContextPath, ForceLineBoxesPath };
     LineLayoutPath lineLayoutPath() const { return static_cast<LineLayoutPath>(renderBlockFlowLineLayoutPath()); }
     void setLineLayoutPath(LineLayoutPath path) { setRenderBlockFlowLineLayoutPath(path); }
 
     // Helper methods for computing line counts and heights for line counts.
     RootInlineBox* lineAtIndex(int) const;
-    int lineCount(const RootInlineBox* = nullptr, bool* = nullptr) const;
+    int lineCount() const;
     int heightForLineCount(int);
     void clearTruncation();
 
     void setHasMarkupTruncation(bool b) { setRenderBlockFlowHasMarkupTruncation(b); }
     bool hasMarkupTruncation() const { return renderBlockFlowHasMarkupTruncation(); }
 
     bool containsNonZeroBidiLevel() const;
 
     const SimpleLineLayout::Layout* simpleLineLayout() const;
-    void deleteLineBoxesBeforeSimpleLineLayout();
+    SimpleLineLayout::Layout* simpleLineLayout();
+    const ComplexLineLayout* complexLineLayout() const;
+    ComplexLineLayout* complexLineLayout();
+#if ENABLE(LAYOUT_FORMATTING_CONTEXT)
+    const LayoutIntegration::LineLayout* layoutFormattingContextLineLayout() const;
+    LayoutIntegration::LineLayout* layoutFormattingContextLineLayout();
+#endif
+
     void ensureLineBoxes();
     void generateLineBoxTree();
 
 #if ENABLE(TREE_DEBUGGING)
     void outputLineTreeAndMark(WTF::TextStream&, const InlineBox* markedBox, int depth) const;
@@ -389,10 +402,12 @@
     void updateMinimumPageHeight(LayoutUnit offset, LayoutUnit minHeight);
 
     void addFloatsToNewParent(RenderBlockFlow& toBlockFlow) const;
 
 protected:
+    bool shouldResetLogicalHeightBeforeLayout() const override { return true; }
+
     void computeIntrinsicLogicalWidths(LayoutUnit& minLogicalWidth, LayoutUnit& maxLogicalWidth) const override;
 
     bool pushToNextPageWithMinimumLogicalHeight(LayoutUnit& adjustment, LayoutUnit logicalOffset, LayoutUnit minimumLogicalHeight) const;
 
     // If the child is unsplittable and can't fit on the current page, return the top of the next page/column.
@@ -519,18 +534,25 @@
     Position positionForBox(InlineBox*, bool start = true) const;
     VisiblePosition positionForPointWithInlineChildren(const LayoutPoint& pointInLogicalContents, const RenderFragmentContainer*) override;
     void addFocusRingRectsForInlineChildren(Vector<LayoutRect>& rects, const LayoutPoint& additionalOffset, const RenderLayerModelObject*) override;
 
 public:
-    ComplexLineLayout* complexLineLayout() { return m_complexLineLayout.get(); }
-
     virtual Optional<TextAlignMode> overrideTextAlignmentForLine(bool /* endsWithSoftBreak */) const { return { }; }
     virtual void adjustInlineDirectionLineBounds(int /* expansionOpportunityCount */, float& /* logicalLeft */, float& /* logicalWidth */) const { }
 
 private:
+    bool hasLineLayout() const;
+    bool hasSimpleLineLayout() const;
+    bool hasComplexLineLayout() const;
+
     void layoutSimpleLines(bool relayoutChildren, LayoutUnit& repaintLogicalTop, LayoutUnit& repaintLogicalBottom);
 
+#if ENABLE(LAYOUT_FORMATTING_CONTEXT)
+    bool hasLayoutFormattingContextLineLayout() const;
+    void layoutLFCLines(bool relayoutChildren, LayoutUnit& repaintLogicalTop, LayoutUnit& repaintLogicalBottom);
+#endif
+
     void adjustIntrinsicLogicalWidthsForColumns(LayoutUnit& minLogicalWidth, LayoutUnit& maxLogicalWidth) const;
     void computeInlinePreferredLogicalWidths(LayoutUnit& minLogicalWidth, LayoutUnit& maxLogicalWidth) const;
     void adjustInitialLetterPosition(RenderBox& childBox, LayoutUnit& logicalTopOffset, LayoutUnit& marginBeforeOffset);
 
 #if ENABLE(TEXT_AUTOSIZING)
@@ -563,23 +585,75 @@
 
 protected:
     std::unique_ptr<FloatingObjects> m_floatingObjects;
     std::unique_ptr<RenderBlockFlowRareData> m_rareBlockFlowData;
 
-    // FIXME: Only one of these should be needed at any given time.
-    std::unique_ptr<ComplexLineLayout> m_complexLineLayout;
-    std::unique_ptr<SimpleLineLayout::Layout> m_simpleLineLayout;
+private:
+    Variant<
+        WTF::Monostate,
+        Ref<SimpleLineLayout::Layout>,
+#if ENABLE(LAYOUT_FORMATTING_CONTEXT)
+        std::unique_ptr<LayoutIntegration::LineLayout>,
+#endif
+        std::unique_ptr<ComplexLineLayout>
+    > m_lineLayout;
 
     friend class LineBreaker;
     friend class LineWidth; // Needs to know FloatingObject
     friend class ComplexLineLayout;
 };
 
+inline bool RenderBlockFlow::hasLineLayout() const
+{
+    return !WTF::holds_alternative<WTF::Monostate>(m_lineLayout);
+}
+
+inline bool RenderBlockFlow::hasComplexLineLayout() const
+{
+    return WTF::holds_alternative<std::unique_ptr<ComplexLineLayout>>(m_lineLayout);
+}
+
+inline const ComplexLineLayout* RenderBlockFlow::complexLineLayout() const
+{
+    return hasComplexLineLayout() ? WTF::get<std::unique_ptr<ComplexLineLayout>>(m_lineLayout).get() : nullptr;
+}
+
+inline ComplexLineLayout* RenderBlockFlow::complexLineLayout()
+{
+    return hasComplexLineLayout() ? WTF::get<std::unique_ptr<ComplexLineLayout>>(m_lineLayout).get() : nullptr;
+}
+
+inline bool RenderBlockFlow::hasSimpleLineLayout() const
+{
+    return WTF::holds_alternative<Ref<SimpleLineLayout::Layout>>(m_lineLayout);
+}
+
 inline const SimpleLineLayout::Layout* RenderBlockFlow::simpleLineLayout() const
 {
-    ASSERT(lineLayoutPath() == SimpleLinesPath || !m_simpleLineLayout);
-    return m_simpleLineLayout.get();
+    return hasSimpleLineLayout() ? WTF::get<Ref<SimpleLineLayout::Layout>>(m_lineLayout).ptr() : nullptr;
+}
+
+inline SimpleLineLayout::Layout* RenderBlockFlow::simpleLineLayout()
+{
+    return hasSimpleLineLayout() ? WTF::get<Ref<SimpleLineLayout::Layout>>(m_lineLayout).ptr() : nullptr;
 }
 
+#if ENABLE(LAYOUT_FORMATTING_CONTEXT)
+inline bool RenderBlockFlow::hasLayoutFormattingContextLineLayout() const
+{
+    return WTF::holds_alternative<std::unique_ptr<LayoutIntegration::LineLayout>>(m_lineLayout);
+}
+
+inline const LayoutIntegration::LineLayout* RenderBlockFlow::layoutFormattingContextLineLayout() const
+{
+    return hasLayoutFormattingContextLineLayout() ? WTF::get<std::unique_ptr<LayoutIntegration::LineLayout>>(m_lineLayout).get() : nullptr;
+}
+
+inline LayoutIntegration::LineLayout* RenderBlockFlow::layoutFormattingContextLineLayout()
+{
+    return hasLayoutFormattingContextLineLayout() ? WTF::get<std::unique_ptr<LayoutIntegration::LineLayout>>(m_lineLayout).get() : nullptr;
+}
+#endif
+
 } // namespace WebCore
 
 SPECIALIZE_TYPE_TRAITS_RENDER_OBJECT(RenderBlockFlow, isRenderBlockFlow())

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WebCore/Modules/webgpu/WebGPUDevice.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2018 Apple Inc. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #include &quot;config.h&quot;
 27 #include &quot;WebGPUDevice.h&quot;
 28 
 29 #if ENABLE(WEBGPU)
 30 
<a name="1" id="anc1"></a><span class="line-added"> 31 #include &quot;DOMWindow.h&quot;</span>
<span class="line-added"> 32 #include &quot;Document.h&quot;</span>
<span class="line-added"> 33 #include &quot;EventNames.h&quot;</span>
 34 #include &quot;Exception.h&quot;
 35 #include &quot;GPUBindGroup.h&quot;
 36 #include &quot;GPUBindGroupBinding.h&quot;
 37 #include &quot;GPUBindGroupDescriptor.h&quot;
 38 #include &quot;GPUBindGroupLayoutDescriptor.h&quot;
 39 #include &quot;GPUBufferBinding.h&quot;
 40 #include &quot;GPUBufferDescriptor.h&quot;
 41 #include &quot;GPUCommandBuffer.h&quot;
<a name="2" id="anc2"></a><span class="line-added"> 42 #include &quot;GPUComputePipeline.h&quot;</span>
 43 #include &quot;GPUComputePipelineDescriptor.h&quot;
<a name="3" id="anc3"></a><span class="line-modified"> 44 #include &quot;GPUProgrammableStageDescriptor.h&quot;</span>
<span class="line-added"> 45 #include &quot;GPURenderPipeline.h&quot;</span>
 46 #include &quot;GPURenderPipelineDescriptor.h&quot;
 47 #include &quot;GPUSampler.h&quot;
 48 #include &quot;GPUSamplerDescriptor.h&quot;
 49 #include &quot;GPUShaderModuleDescriptor.h&quot;
 50 #include &quot;GPUTextureDescriptor.h&quot;
<a name="4" id="anc4"></a><span class="line-added"> 51 #include &quot;GPUUncapturedErrorEvent.h&quot;</span>
<span class="line-added"> 52 #include &quot;InspectorInstrumentation.h&quot;</span>
 53 #include &quot;JSDOMConvertBufferSource.h&quot;
<a name="5" id="anc5"></a><span class="line-added"> 54 #include &quot;JSDOMPromiseDeferred.h&quot;</span>
 55 #include &quot;JSGPUOutOfMemoryError.h&quot;
 56 #include &quot;JSGPUValidationError.h&quot;
 57 #include &quot;JSWebGPUBuffer.h&quot;
 58 #include &quot;Logging.h&quot;
 59 #include &quot;WebGPUBindGroup.h&quot;
 60 #include &quot;WebGPUBindGroupBinding.h&quot;
 61 #include &quot;WebGPUBindGroupDescriptor.h&quot;
 62 #include &quot;WebGPUBindGroupLayout.h&quot;
 63 #include &quot;WebGPUBufferBinding.h&quot;
 64 #include &quot;WebGPUCommandEncoder.h&quot;
 65 #include &quot;WebGPUComputePipeline.h&quot;
 66 #include &quot;WebGPUComputePipelineDescriptor.h&quot;
<a name="6" id="anc6"></a><span class="line-added"> 67 #include &quot;WebGPUPipeline.h&quot;</span>
 68 #include &quot;WebGPUPipelineLayout.h&quot;
 69 #include &quot;WebGPUPipelineLayoutDescriptor.h&quot;
<a name="7" id="anc7"></a><span class="line-modified"> 70 #include &quot;WebGPUProgrammableStageDescriptor.h&quot;</span>
 71 #include &quot;WebGPUQueue.h&quot;
 72 #include &quot;WebGPURenderPipeline.h&quot;
 73 #include &quot;WebGPURenderPipelineDescriptor.h&quot;
 74 #include &quot;WebGPUSampler.h&quot;
 75 #include &quot;WebGPUShaderModule.h&quot;
 76 #include &quot;WebGPUShaderModuleDescriptor.h&quot;
 77 #include &quot;WebGPUSwapChain.h&quot;
 78 #include &quot;WebGPUTexture.h&quot;
<a name="8" id="anc8"></a><span class="line-added"> 79 #include &lt;JavaScriptCore/ConsoleMessage.h&gt;</span>
<span class="line-added"> 80 #include &lt;memory&gt;</span>
<span class="line-added"> 81 #include &lt;wtf/HashSet.h&gt;</span>
<span class="line-added"> 82 #include &lt;wtf/IsoMallocInlines.h&gt;</span>
<span class="line-added"> 83 #include &lt;wtf/Lock.h&gt;</span>
<span class="line-added"> 84 #include &lt;wtf/MainThread.h&gt;</span>
<span class="line-added"> 85 #include &lt;wtf/NeverDestroyed.h&gt;</span>
 86 #include &lt;wtf/Optional.h&gt;
<a name="9" id="anc9"></a><span class="line-added"> 87 #include &lt;wtf/Ref.h&gt;</span>
<span class="line-added"> 88 #include &lt;wtf/RefPtr.h&gt;</span>
<span class="line-added"> 89 #include &lt;wtf/Variant.h&gt;</span>
<span class="line-added"> 90 #include &lt;wtf/Vector.h&gt;</span>
 91 #include &lt;wtf/text/WTFString.h&gt;
 92 
 93 namespace WebCore {
 94 
<a name="10" id="anc10"></a><span class="line-modified"> 95 WTF_MAKE_ISO_ALLOCATED_IMPL(WebGPUDevice);</span>
<span class="line-added"> 96 </span>
<span class="line-added"> 97 RefPtr&lt;WebGPUDevice&gt; WebGPUDevice::tryCreate(ScriptExecutionContext&amp; context, Ref&lt;const WebGPUAdapter&gt;&amp;&amp; adapter)</span>
 98 {
 99     if (auto device = GPUDevice::tryCreate(adapter-&gt;options()))
<a name="11" id="anc11"></a><span class="line-modified">100         return adoptRef(new WebGPUDevice(context, WTFMove(adapter), device.releaseNonNull()));</span>
101     return nullptr;
102 }
103 
<a name="12" id="anc12"></a><span class="line-modified">104 HashSet&lt;WebGPUDevice*&gt;&amp; WebGPUDevice::instances(const LockHolder&amp;)</span>
<span class="line-modified">105 {</span>
<span class="line-added">106     static NeverDestroyed&lt;HashSet&lt;WebGPUDevice*&gt;&gt; instances;</span>
<span class="line-added">107     return instances;</span>
<span class="line-added">108 }</span>
<span class="line-added">109 </span>
<span class="line-added">110 Lock&amp; WebGPUDevice::instancesMutex()</span>
<span class="line-added">111 {</span>
<span class="line-added">112     static LazyNeverDestroyed&lt;Lock&gt; mutex;</span>
<span class="line-added">113     static std::once_flag initializeMutex;</span>
<span class="line-added">114     std::call_once(initializeMutex, [] {</span>
<span class="line-added">115         mutex.construct();</span>
<span class="line-added">116     });</span>
<span class="line-added">117     return mutex.get();</span>
<span class="line-added">118 }</span>
<span class="line-added">119 </span>
<span class="line-added">120 WebGPUDevice::WebGPUDevice(ScriptExecutionContext&amp; context, Ref&lt;const WebGPUAdapter&gt;&amp;&amp; adapter, Ref&lt;GPUDevice&gt;&amp;&amp; device)</span>
<span class="line-added">121     : m_scriptExecutionContext(context)</span>
<span class="line-added">122     , m_adapter(WTFMove(adapter))</span>
123     , m_device(WTFMove(device))
<a name="13" id="anc13"></a><span class="line-modified">124     , m_errorScopes(GPUErrorScopes::create([this, weakThis = makeWeakPtr(this)] (GPUError&amp;&amp; error) {</span>
<span class="line-added">125         if (weakThis)</span>
<span class="line-added">126             dispatchUncapturedError(WTFMove(error));</span>
<span class="line-added">127     }))</span>
128 {
<a name="14" id="anc14"></a><span class="line-added">129     ASSERT(m_scriptExecutionContext.isDocument());</span>
<span class="line-added">130 </span>
<span class="line-added">131     {</span>
<span class="line-added">132         LockHolder lock(instancesMutex());</span>
<span class="line-added">133         instances(lock).add(this);</span>
<span class="line-added">134     }</span>
<span class="line-added">135 }</span>
<span class="line-added">136 </span>
<span class="line-added">137 WebGPUDevice::~WebGPUDevice()</span>
<span class="line-added">138 {</span>
<span class="line-added">139     InspectorInstrumentation::willDestroyWebGPUDevice(*this);</span>
<span class="line-added">140 </span>
<span class="line-added">141     {</span>
<span class="line-added">142         LockHolder lock(WebGPUPipeline::instancesMutex());</span>
<span class="line-added">143         for (auto&amp; entry : WebGPUPipeline::instances(lock)) {</span>
<span class="line-added">144             if (entry.value == this) {</span>
<span class="line-added">145                 // Don&#39;t remove any WebGPUPipeline from the instances list, as they may still exist.</span>
<span class="line-added">146                 // Only remove the association with a WebGPU device.</span>
<span class="line-added">147                 entry.value = nullptr;</span>
<span class="line-added">148             }</span>
<span class="line-added">149         }</span>
<span class="line-added">150     }</span>
<span class="line-added">151 </span>
<span class="line-added">152     {</span>
<span class="line-added">153         LockHolder lock(instancesMutex());</span>
<span class="line-added">154         ASSERT(instances(lock).contains(this));</span>
<span class="line-added">155         instances(lock).remove(this);</span>
<span class="line-added">156     }</span>
157 }
158 
159 Ref&lt;WebGPUBuffer&gt; WebGPUDevice::createBuffer(const GPUBufferDescriptor&amp; descriptor) const
160 {
161     m_errorScopes-&gt;setErrorPrefix(&quot;GPUDevice.createBuffer(): &quot;);
162 
163     auto buffer = m_device-&gt;tryCreateBuffer(descriptor, GPUBufferMappedOption::NotMapped, m_errorScopes);
164     return WebGPUBuffer::create(WTFMove(buffer), m_errorScopes);
165 }
166 
<a name="15" id="anc15"></a><span class="line-modified">167 Vector&lt;JSC::JSValue&gt; WebGPUDevice::createBufferMapped(JSC::JSGlobalObject&amp; lexicalGlobalObject, const GPUBufferDescriptor&amp; descriptor) const</span>
168 {
169     m_errorScopes-&gt;setErrorPrefix(&quot;GPUDevice.createBufferMapped(): &quot;);
170 
171     JSC::JSValue wrappedArrayBuffer = JSC::jsNull();
172 
173     auto buffer = m_device-&gt;tryCreateBuffer(descriptor, GPUBufferMappedOption::IsMapped, m_errorScopes);
174     if (buffer) {
175         auto arrayBuffer = buffer-&gt;mapOnCreation();
<a name="16" id="anc16"></a><span class="line-modified">176         wrappedArrayBuffer = toJS(&amp;lexicalGlobalObject, JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject), arrayBuffer);</span>
177     }
178 
179     auto webBuffer = WebGPUBuffer::create(WTFMove(buffer), m_errorScopes);
<a name="17" id="anc17"></a><span class="line-modified">180     auto wrappedWebBuffer = toJS(&amp;lexicalGlobalObject, JSC::jsCast&lt;JSDOMGlobalObject*&gt;(&amp;lexicalGlobalObject), webBuffer);</span>
181 
182     return { wrappedWebBuffer, wrappedArrayBuffer };
183 }
184 
185 Ref&lt;WebGPUTexture&gt; WebGPUDevice::createTexture(const GPUTextureDescriptor&amp; descriptor) const
186 {
187     auto texture = m_device-&gt;tryCreateTexture(descriptor);
188     return WebGPUTexture::create(WTFMove(texture));
189 }
190 
191 Ref&lt;WebGPUSampler&gt; WebGPUDevice::createSampler(const GPUSamplerDescriptor&amp; descriptor) const
192 {
193     auto sampler = m_device-&gt;tryCreateSampler(descriptor);
194     return WebGPUSampler::create(WTFMove(sampler));
195 }
196 
197 Ref&lt;WebGPUBindGroupLayout&gt; WebGPUDevice::createBindGroupLayout(const GPUBindGroupLayoutDescriptor&amp; descriptor) const
198 {
199     auto layout = m_device-&gt;tryCreateBindGroupLayout(descriptor);
200     return WebGPUBindGroupLayout::create(WTFMove(layout));
201 }
202 
203 Ref&lt;WebGPUPipelineLayout&gt; WebGPUDevice::createPipelineLayout(const WebGPUPipelineLayoutDescriptor&amp; descriptor) const
204 {
205     auto gpuDescriptor = descriptor.tryCreateGPUPipelineLayoutDescriptor();
206     if (!gpuDescriptor)
207         return WebGPUPipelineLayout::create(nullptr);
208 
209     auto layout = m_device-&gt;createPipelineLayout(WTFMove(*gpuDescriptor));
210     return WebGPUPipelineLayout::create(WTFMove(layout));
211 }
212 
213 Ref&lt;WebGPUBindGroup&gt; WebGPUDevice::createBindGroup(const WebGPUBindGroupDescriptor&amp; descriptor) const
214 {
215     auto gpuDescriptor = descriptor.tryCreateGPUBindGroupDescriptor();
216     if (!gpuDescriptor)
217         return WebGPUBindGroup::create(nullptr);
218 
219     auto bindGroup = m_device-&gt;tryCreateBindGroup(*gpuDescriptor, m_errorScopes);
220     return WebGPUBindGroup::create(WTFMove(bindGroup));
221 }
222 
223 Ref&lt;WebGPUShaderModule&gt; WebGPUDevice::createShaderModule(const WebGPUShaderModuleDescriptor&amp; descriptor) const
224 {
225     // FIXME: What can be validated here?
226     auto module = m_device-&gt;tryCreateShaderModule(GPUShaderModuleDescriptor { descriptor.code });
<a name="18" id="anc18"></a><span class="line-modified">227     return WebGPUShaderModule::create(WTFMove(module), descriptor.code);</span>
228 }
229 
<a name="19" id="anc19"></a><span class="line-modified">230 Ref&lt;WebGPURenderPipeline&gt; WebGPUDevice::createRenderPipeline(const WebGPURenderPipelineDescriptor&amp; descriptor)</span>
231 {
232     m_errorScopes-&gt;setErrorPrefix(&quot;GPUDevice.createRenderPipeline(): &quot;);
233 
234     auto gpuDescriptor = descriptor.tryCreateGPURenderPipelineDescriptor(m_errorScopes);
235     if (!gpuDescriptor)
<a name="20" id="anc20"></a><span class="line-modified">236         return WebGPURenderPipeline::create(*this, nullptr, m_errorScopes, { }, { });</span>
237 
<a name="21" id="anc21"></a><span class="line-modified">238     auto gpuPipeline = m_device-&gt;tryCreateRenderPipeline(*gpuDescriptor, m_errorScopes);</span>
<span class="line-modified">239 </span>
<span class="line-added">240     WebGPUPipeline::ShaderData vertexShader = { descriptor.vertexStage.module, descriptor.vertexStage.entryPoint };</span>
<span class="line-added">241 </span>
<span class="line-added">242     WebGPUPipeline::ShaderData fragmentShader;</span>
<span class="line-added">243     if (descriptor.fragmentStage)</span>
<span class="line-added">244         fragmentShader = { descriptor.fragmentStage.value().module, descriptor.fragmentStage.value().entryPoint };</span>
<span class="line-added">245 </span>
<span class="line-added">246     auto webGPUPipeline = WebGPURenderPipeline::create(*this, WTFMove(gpuPipeline), m_errorScopes, WTFMove(vertexShader), WTFMove(fragmentShader));</span>
<span class="line-added">247     if (webGPUPipeline-&gt;isValid())</span>
<span class="line-added">248         InspectorInstrumentation::didCreateWebGPUPipeline(*this, webGPUPipeline.get());</span>
<span class="line-added">249     return webGPUPipeline;</span>
250 }
251 
<a name="22" id="anc22"></a><span class="line-modified">252 Ref&lt;WebGPUComputePipeline&gt; WebGPUDevice::createComputePipeline(const WebGPUComputePipelineDescriptor&amp; descriptor)</span>
253 {
254     m_errorScopes-&gt;setErrorPrefix(&quot;GPUDevice.createComputePipeline(): &quot;);
255 
256     auto gpuDescriptor = descriptor.tryCreateGPUComputePipelineDescriptor(m_errorScopes);
257     if (!gpuDescriptor)
<a name="23" id="anc23"></a><span class="line-modified">258         return WebGPUComputePipeline::create(*this, nullptr, m_errorScopes, { });</span>
<span class="line-added">259 </span>
<span class="line-added">260     auto gpuPipeline = m_device-&gt;tryCreateComputePipeline(*gpuDescriptor, m_errorScopes);</span>
261 
<a name="24" id="anc24"></a><span class="line-modified">262     WebGPUPipeline::ShaderData computeShader = { descriptor.computeStage.module, descriptor.computeStage.entryPoint };</span>
<span class="line-modified">263 </span>
<span class="line-added">264     auto webGPUPipeline = WebGPUComputePipeline::create(*this, WTFMove(gpuPipeline), m_errorScopes, WTFMove(computeShader));</span>
<span class="line-added">265     if (webGPUPipeline-&gt;isValid())</span>
<span class="line-added">266         InspectorInstrumentation::didCreateWebGPUPipeline(*this, webGPUPipeline.get());</span>
<span class="line-added">267     return webGPUPipeline;</span>
268 }
269 
270 Ref&lt;WebGPUCommandEncoder&gt; WebGPUDevice::createCommandEncoder() const
271 {
272     auto commandBuffer = m_device-&gt;tryCreateCommandBuffer();
273     return WebGPUCommandEncoder::create(WTFMove(commandBuffer));
274 }
275 
276 Ref&lt;WebGPUQueue&gt; WebGPUDevice::getQueue() const
277 {
278     if (!m_queue)
279         m_queue = WebGPUQueue::create(m_device-&gt;tryGetQueue());
280 
281     return makeRef(*m_queue.get());
282 }
283 
284 void WebGPUDevice::popErrorScope(ErrorPromise&amp;&amp; promise)
285 {
286     String failMessage;
287     Optional&lt;GPUError&gt; error = m_errorScopes-&gt;popErrorScope(failMessage);
288     if (failMessage.isEmpty())
289         promise.resolve(error);
290     else
291         promise.reject(Exception { OperationError, &quot;GPUDevice::popErrorScope(): &quot; + failMessage });
292 }
293 
<a name="25" id="anc25"></a><span class="line-added">294 // Errors reported via the validation error event should also appear in the console as warnings.</span>
<span class="line-added">295 static void printValidationErrorToConsole(GPUError&amp; error, ScriptExecutionContext&amp; context)</span>
<span class="line-added">296 {</span>
<span class="line-added">297     if (!WTF::holds_alternative&lt;RefPtr&lt;GPUValidationError&gt;&gt;(error))</span>
<span class="line-added">298         return;</span>
<span class="line-added">299 </span>
<span class="line-added">300     auto validationError = WTF::get&lt;RefPtr&lt;GPUValidationError&gt;&gt;(error);</span>
<span class="line-added">301     if (!validationError)</span>
<span class="line-added">302         return;</span>
<span class="line-added">303 </span>
<span class="line-added">304     auto message = validationError-&gt;message();</span>
<span class="line-added">305     auto consoleMessage = makeUnique&lt;Inspector::ConsoleMessage&gt;(MessageSource::Rendering, MessageType::Log, MessageLevel::Warning, message);</span>
<span class="line-added">306 </span>
<span class="line-added">307     downcast&lt;Document&gt;(context).addConsoleMessage(WTFMove(consoleMessage));</span>
<span class="line-added">308 }</span>
<span class="line-added">309 </span>
<span class="line-added">310 void WebGPUDevice::dispatchUncapturedError(GPUError&amp;&amp; error)</span>
<span class="line-added">311 {</span>
<span class="line-added">312     printValidationErrorToConsole(error, m_scriptExecutionContext);</span>
<span class="line-added">313 </span>
<span class="line-added">314     callOnMainThread([error = WTFMove(error), this, protectedThis = makeRef(*this)] () mutable {</span>
<span class="line-added">315         dispatchEvent(GPUUncapturedErrorEvent::create(eventNames().uncapturederrorEvent, WTFMove(error)));</span>
<span class="line-added">316     });</span>
<span class="line-added">317 }</span>
<span class="line-added">318 </span>
319 } // namespace WebCore
320 
321 #endif // ENABLE(WEBGPU)
<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCanvasElement.cpp</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HTMLAttributeNames.in.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLCanvasElement.h.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/html/HTMLCanvasElement.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  38 #include &quot;FrameLoaderClient.h&quot;
  39 #include &quot;GPUBasedCanvasRenderingContext.h&quot;
  40 #include &quot;GeometryUtilities.h&quot;
  41 #include &quot;GraphicsContext.h&quot;
  42 #include &quot;HTMLNames.h&quot;
  43 #include &quot;HTMLParserIdioms.h&quot;
  44 #include &quot;ImageBitmapRenderingContext.h&quot;
  45 #include &quot;ImageBuffer.h&quot;
  46 #include &quot;ImageData.h&quot;
  47 #include &quot;InspectorInstrumentation.h&quot;
  48 #include &quot;JSDOMConvertDictionary.h&quot;
  49 #include &quot;MIMETypeRegistry.h&quot;
  50 #include &quot;RenderElement.h&quot;
  51 #include &quot;RenderHTMLCanvas.h&quot;
  52 #include &quot;ResourceLoadObserver.h&quot;
  53 #include &quot;RuntimeEnabledFeatures.h&quot;
  54 #include &quot;ScriptController.h&quot;
  55 #include &quot;Settings.h&quot;
  56 #include &quot;StringAdaptors.h&quot;
  57 #include &lt;JavaScriptCore/JSCInlines.h&gt;
<span class="line-removed">  58 #include &lt;JavaScriptCore/JSLock.h&gt;</span>
  59 #include &lt;math.h&gt;
  60 #include &lt;wtf/IsoMallocInlines.h&gt;
  61 #include &lt;wtf/RAMSize.h&gt;
  62 #include &lt;wtf/text/StringBuilder.h&gt;
  63 
  64 #if ENABLE(MEDIA_STREAM)
  65 #include &quot;CanvasCaptureMediaStreamTrack.h&quot;
  66 #include &quot;MediaStream.h&quot;
  67 #endif
  68 
  69 #if ENABLE(WEBGL)
  70 #include &quot;WebGLContextAttributes.h&quot;
  71 #include &quot;WebGLRenderingContext.h&quot;
  72 #endif
  73 
  74 #if ENABLE(WEBGL2)
  75 #include &quot;WebGL2RenderingContext.h&quot;
  76 #endif
  77 
  78 #if ENABLE(WEBGPU)
  79 #include &quot;GPUCanvasContext.h&quot;
  80 #endif
  81 
  82 #if PLATFORM(COCOA)
  83 #include &quot;MediaSampleAVFObjC.h&quot;
  84 #include &lt;pal/cf/CoreMediaSoftLink.h&gt;
  85 #endif
  86 




  87 namespace WebCore {
  88 
  89 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLCanvasElement);
  90 
  91 using namespace PAL;
  92 using namespace HTMLNames;
  93 
  94 // These values come from the WhatWG/W3C HTML spec.
  95 const int defaultWidth = 300;
  96 const int defaultHeight = 150;
  97 
  98 // Firefox limits width/height to 32767 pixels, but slows down dramatically before it
  99 // reaches that limit. We limit by area instead, giving us larger maximum dimensions,
 100 // in exchange for a smaller maximum canvas size. The maximum canvas size is in device pixels.
 101 #if PLATFORM(IOS_FAMILY)
 102 const unsigned maxCanvasArea = 4096 * 4096;
 103 #else
 104 const unsigned maxCanvasArea = 16384 * 16384;
 105 #endif
 106 
<span class="line-modified"> 107 #if USE(CG)</span>
<span class="line-removed"> 108 // FIXME: It seems strange that the default quality is not the one that is literally named &quot;default&quot;.</span>
<span class="line-removed"> 109 // Should fix names to make this easier to understand, or write an excellent comment here explaining why not.</span>
<span class="line-removed"> 110 const InterpolationQuality defaultInterpolationQuality = InterpolationLow;</span>
<span class="line-removed"> 111 #else</span>
<span class="line-removed"> 112 const InterpolationQuality defaultInterpolationQuality = InterpolationDefault;</span>
<span class="line-removed"> 113 #endif</span>
<span class="line-removed"> 114 </span>
<span class="line-removed"> 115 static size_t activePixelMemory = 0;</span>
 116 
 117 HTMLCanvasElement::HTMLCanvasElement(const QualifiedName&amp; tagName, Document&amp; document)
 118     : HTMLElement(tagName, document)
<span class="line-modified"> 119     , m_size(defaultWidth, defaultHeight)</span>
 120 {
 121     ASSERT(hasTagName(canvasTag));
 122 }
 123 
 124 Ref&lt;HTMLCanvasElement&gt; HTMLCanvasElement::create(Document&amp; document)
 125 {
 126     return adoptRef(*new HTMLCanvasElement(canvasTag, document));
 127 }
 128 
 129 Ref&lt;HTMLCanvasElement&gt; HTMLCanvasElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 130 {
 131     return adoptRef(*new HTMLCanvasElement(tagName, document));
 132 }
 133 
<span class="line-removed"> 134 static void removeFromActivePixelMemory(size_t pixelsReleased)</span>
<span class="line-removed"> 135 {</span>
<span class="line-removed"> 136     if (!pixelsReleased)</span>
<span class="line-removed"> 137         return;</span>
<span class="line-removed"> 138 </span>
<span class="line-removed"> 139     if (pixelsReleased &lt; activePixelMemory)</span>
<span class="line-removed"> 140         activePixelMemory -= pixelsReleased;</span>
<span class="line-removed"> 141     else</span>
<span class="line-removed"> 142         activePixelMemory = 0;</span>
<span class="line-removed"> 143 }</span>
<span class="line-removed"> 144 </span>
 145 HTMLCanvasElement::~HTMLCanvasElement()
 146 {



 147     notifyObserversCanvasDestroyed();
 148 
 149     m_context = nullptr; // Ensure this goes away before the ImageBuffer.
<span class="line-modified"> 150 </span>
<span class="line-removed"> 151     releaseImageBufferAndContext();</span>
 152 }
 153 
 154 void HTMLCanvasElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 155 {
 156     if (name == widthAttr || name == heightAttr)
 157         reset();
 158     HTMLElement::parseAttribute(name, value);
 159 }
 160 
 161 RenderPtr&lt;RenderElement&gt; HTMLCanvasElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp; insertionPosition)
 162 {
 163     RefPtr&lt;Frame&gt; frame = document().frame();
 164     if (frame &amp;&amp; frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
 165         return createRenderer&lt;RenderHTMLCanvas&gt;(*this, WTFMove(style));
 166     return HTMLElement::createElementRenderer(WTFMove(style), insertionPosition);
 167 }
 168 
 169 bool HTMLCanvasElement::canContainRangeEndPoint() const
 170 {
 171     return false;
</pre>
<hr />
<pre>
 175 {
 176     return false;
 177 }
 178 
 179 ExceptionOr&lt;void&gt; HTMLCanvasElement::setHeight(unsigned value)
 180 {
 181     if (m_context &amp;&amp; m_context-&gt;isPlaceholder())
 182         return Exception { InvalidStateError };
 183     setAttributeWithoutSynchronization(heightAttr, AtomString::number(limitToOnlyHTMLNonNegative(value, defaultHeight)));
 184     return { };
 185 }
 186 
 187 ExceptionOr&lt;void&gt; HTMLCanvasElement::setWidth(unsigned value)
 188 {
 189     if (m_context &amp;&amp; m_context-&gt;isPlaceholder())
 190         return Exception { InvalidStateError };
 191     setAttributeWithoutSynchronization(widthAttr, AtomString::number(limitToOnlyHTMLNonNegative(value, defaultWidth)));
 192     return { };
 193 }
 194 












 195 static inline size_t maxActivePixelMemory()
 196 {



 197     static size_t maxPixelMemory;
 198     static std::once_flag onceFlag;
 199     std::call_once(onceFlag, [] {
 200 #if PLATFORM(IOS_FAMILY)
 201         maxPixelMemory = ramSize() / 4;
 202 #else
 203         maxPixelMemory = std::max(ramSize() / 4, 2151 * MB);
 204 #endif
 205     });

 206     return maxPixelMemory;
 207 }
 208 
<span class="line-modified"> 209 ExceptionOr&lt;Optional&lt;RenderingContext&gt;&gt; HTMLCanvasElement::getContext(JSC::ExecState&amp; state, const String&amp; contextId, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>





 210 {
 211     if (m_context) {
 212         if (m_context-&gt;isPlaceholder())
 213             return Exception { InvalidStateError };
 214 
 215         if (m_context-&gt;is2d()) {
 216             if (!is2dType(contextId))
 217                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 218             return Optional&lt;RenderingContext&gt; { RefPtr&lt;CanvasRenderingContext2D&gt; { &amp;downcast&lt;CanvasRenderingContext2D&gt;(*m_context) } };
 219         }
 220 
 221         if (m_context-&gt;isBitmapRenderer()) {
 222             if (!isBitmapRendererType(contextId))
 223                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 224             return Optional&lt;RenderingContext&gt; { RefPtr&lt;ImageBitmapRenderingContext&gt; { &amp;downcast&lt;ImageBitmapRenderingContext&gt;(*m_context) } };
 225         }
 226 
 227 #if ENABLE(WEBGL)
 228         if (m_context-&gt;isWebGL()) {
 229             if (!isWebGLType(contextId))
</pre>
<hr />
<pre>
 314 #if ENABLE(WEBGPU)
 315     if (HTMLCanvasElement::isWebGPUType(type))
 316         return getContextWebGPU(type);
 317 #endif
 318 
 319     return nullptr;
 320 }
 321 
 322 bool HTMLCanvasElement::is2dType(const String&amp; type)
 323 {
 324     return type == &quot;2d&quot;;
 325 }
 326 
 327 CanvasRenderingContext2D* HTMLCanvasElement::createContext2d(const String&amp; type)
 328 {
 329     ASSERT_UNUSED(HTMLCanvasElement::is2dType(type), type);
 330     ASSERT(!m_context);
 331 
 332     // Make sure we don&#39;t use more pixel memory than the system can support.
 333     size_t requestedPixelMemory = 4 * width() * height();
<span class="line-modified"> 334     if (activePixelMemory + requestedPixelMemory &gt; maxActivePixelMemory()) {</span>
 335         StringBuilder stringBuilder;
 336         stringBuilder.appendLiteral(&quot;Total canvas memory use exceeds the maximum limit (&quot;);
 337         stringBuilder.appendNumber(maxActivePixelMemory() / 1024 / 1024);
 338         stringBuilder.appendLiteral(&quot; MB).&quot;);
 339         document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, stringBuilder.toString());
 340         return nullptr;
 341     }
 342 
 343     m_context = CanvasRenderingContext2D::create(*this, document().inQuirksMode());
 344 
 345     downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setUsesDisplayListDrawing(m_usesDisplayListDrawing);
 346     downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setTracksDisplayListReplay(m_tracksDisplayListReplay);
 347 
 348 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
 349     // Need to make sure a RenderLayer and compositing layer get created for the Canvas.
 350     invalidateStyleAndLayerComposition();
 351 #endif
 352 
 353     return static_cast&lt;CanvasRenderingContext2D*&gt;(m_context.get());
 354 }
</pre>
<hr />
<pre>
 520         r.intersect(destRect);
 521 
 522         if (!r.isEmpty() &amp;&amp; !m_dirtyRect.contains(r)) {
 523             m_dirtyRect.unite(r);
 524             renderer-&gt;repaintRectangle(enclosingIntRect(m_dirtyRect));
 525         }
 526     }
 527     notifyObserversCanvasChanged(dirtyRect);
 528 }
 529 
 530 void HTMLCanvasElement::reset()
 531 {
 532     if (m_ignoreReset)
 533         return;
 534 
 535     bool hadImageBuffer = hasCreatedImageBuffer();
 536 
 537     int w = limitToOnlyHTMLNonNegative(attributeWithoutSynchronization(widthAttr), defaultWidth);
 538     int h = limitToOnlyHTMLNonNegative(attributeWithoutSynchronization(heightAttr), defaultHeight);
 539 
<span class="line-modified"> 540     if (m_contextStateSaver) {</span>
<span class="line-removed"> 541         // Reset to the initial graphics context state.</span>
<span class="line-removed"> 542         m_contextStateSaver-&gt;restore();</span>
<span class="line-removed"> 543         m_contextStateSaver-&gt;save();</span>
<span class="line-removed"> 544     }</span>
<span class="line-removed"> 545 </span>
 546     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
 547         downcast&lt;CanvasRenderingContext2D&gt;(*m_context).reset();
 548 
 549     IntSize oldSize = size();
 550     IntSize newSize(w, h);
 551     // If the size of an existing buffer matches, we can just clear it instead of reallocating.
 552     // This optimization is only done for 2D canvases for now.
 553     if (m_hasCreatedImageBuffer &amp;&amp; oldSize == newSize &amp;&amp; m_context &amp;&amp; m_context-&gt;is2d()) {
 554         if (!m_didClearImageBuffer)
 555             clearImageBuffer();
 556         return;
 557     }
 558 
 559     setSurfaceSize(newSize);
 560 
 561     if (isGPUBased() &amp;&amp; oldSize != size())
 562         downcast&lt;GPUBasedCanvasRenderingContext&gt;(*m_context).reshape(width(), height());
 563 
 564     auto renderer = this-&gt;renderer();
 565     if (is&lt;RenderHTMLCanvas&gt;(renderer)) {
</pre>
<hr />
<pre>
 613                 if (m_presentedImage)
 614                     context.drawImage(*m_presentedImage, snappedIntRect(r), renderer()-&gt;imageOrientation());
 615                 else if (ImageBuffer* imageBuffer = buffer())
 616                     context.drawImageBuffer(*imageBuffer, snappedIntRect(r));
 617             }
 618 
 619             if (isGPUBased())
 620                 downcast&lt;GPUBasedCanvasRenderingContext&gt;(*m_context).markLayerComposited();
 621         }
 622     }
 623 
 624     if (UNLIKELY(m_context &amp;&amp; m_context-&gt;callTracingActive()))
 625         InspectorInstrumentation::didFinishRecordingCanvasFrame(*m_context);
 626 }
 627 
 628 bool HTMLCanvasElement::isGPUBased() const
 629 {
 630     return m_context &amp;&amp; m_context-&gt;isGPUBased();
 631 }
 632 
<span class="line-removed"> 633 void HTMLCanvasElement::makeRenderingResultsAvailable()</span>
<span class="line-removed"> 634 {</span>
<span class="line-removed"> 635     if (m_context)</span>
<span class="line-removed"> 636         m_context-&gt;paintRenderingResultsToCanvas();</span>
<span class="line-removed"> 637 }</span>
<span class="line-removed"> 638 </span>
 639 void HTMLCanvasElement::makePresentationCopy()
 640 {
 641     if (!m_presentedImage) {
 642         // The buffer contains the last presented data, so save a copy of it.
 643         m_presentedImage = buffer()-&gt;copyImage(CopyBackingStore, PreserveResolution::Yes);
 644     }
 645 }
 646 
 647 void HTMLCanvasElement::clearPresentationCopy()
 648 {
 649     m_presentedImage = nullptr;
 650 }
 651 
<span class="line-removed"> 652 void HTMLCanvasElement::releaseImageBufferAndContext()</span>
<span class="line-removed"> 653 {</span>
<span class="line-removed"> 654     m_contextStateSaver = nullptr;</span>
<span class="line-removed"> 655     setImageBuffer(nullptr);</span>
<span class="line-removed"> 656 }</span>
<span class="line-removed"> 657 </span>
 658 void HTMLCanvasElement::setSurfaceSize(const IntSize&amp; size)
 659 {
<span class="line-modified"> 660     m_size = size;</span>
 661     m_hasCreatedImageBuffer = false;
<span class="line-modified"> 662     releaseImageBufferAndContext();</span>
 663     clearCopiedImage();
 664 }
 665 
 666 static String toEncodingMimeType(const String&amp; mimeType)
 667 {
 668     if (!MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(mimeType))
 669         return &quot;image/png&quot;_s;
 670     return mimeType.convertToASCIILowercase();
 671 }
 672 
 673 // https://html.spec.whatwg.org/multipage/canvas.html#a-serialisation-of-the-bitmap-as-a-file
 674 static Optional&lt;double&gt; qualityFromJSValue(JSC::JSValue qualityValue)
 675 {
 676     if (!qualityValue.isNumber())
 677         return WTF::nullopt;
 678 
 679     double qualityNumber = qualityValue.asNumber();
 680     if (qualityNumber &lt; 0 || qualityNumber &gt; 1)
 681         return WTF::nullopt;
 682 
 683     return qualityNumber;
 684 }
 685 
 686 ExceptionOr&lt;UncachedString&gt; HTMLCanvasElement::toDataURL(const String&amp; mimeType, JSC::JSValue qualityValue)
 687 {
 688     if (!originClean())
 689         return Exception { SecurityError };
 690 
<span class="line-modified"> 691     if (m_size.isEmpty() || !buffer())</span>
 692         return UncachedString { &quot;data:,&quot;_s };
 693     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
 694         ResourceLoadObserver::shared().logCanvasRead(document());
 695 
 696     auto encodingMIMEType = toEncodingMimeType(mimeType);
 697     auto quality = qualityFromJSValue(qualityValue);
 698 
 699 #if USE(CG)
 700     // Try to get ImageData first, as that may avoid lossy conversions.
 701     if (auto imageData = getImageData())
 702         return UncachedString { dataURL(*imageData, encodingMIMEType, quality) };
 703 #endif
 704 
 705     makeRenderingResultsAvailable();
 706 
 707     return UncachedString { buffer()-&gt;toDataURL(encodingMIMEType, quality) };
 708 }
 709 
 710 ExceptionOr&lt;UncachedString&gt; HTMLCanvasElement::toDataURL(const String&amp; mimeType)
 711 {
 712     return toDataURL(mimeType, { });
 713 }
 714 
 715 ExceptionOr&lt;void&gt; HTMLCanvasElement::toBlob(ScriptExecutionContext&amp; context, Ref&lt;BlobCallback&gt;&amp;&amp; callback, const String&amp; mimeType, JSC::JSValue qualityValue)
 716 {
 717     if (!originClean())
 718         return Exception { SecurityError };
 719 
<span class="line-modified"> 720     if (m_size.isEmpty() || !buffer()) {</span>
 721         callback-&gt;scheduleCallback(context, nullptr);
 722         return { };
 723     }
 724     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
 725         ResourceLoadObserver::shared().logCanvasRead(document());
 726 
 727     auto encodingMIMEType = toEncodingMimeType(mimeType);
 728     auto quality = qualityFromJSValue(qualityValue);
 729 
 730 #if USE(CG)
 731     if (auto imageData = getImageData()) {
 732         RefPtr&lt;Blob&gt; blob;
 733         Vector&lt;uint8_t&gt; blobData = data(*imageData, encodingMIMEType, quality);
 734         if (!blobData.isEmpty())
<span class="line-modified"> 735             blob = Blob::create(context.sessionID(), WTFMove(blobData), encodingMIMEType);</span>
 736         callback-&gt;scheduleCallback(context, WTFMove(blob));
 737         return { };
 738     }
 739 #endif
 740 
 741     makeRenderingResultsAvailable();
 742 
 743     RefPtr&lt;Blob&gt; blob;
 744     Vector&lt;uint8_t&gt; blobData = buffer()-&gt;toData(encodingMIMEType, quality);
 745     if (!blobData.isEmpty())
<span class="line-modified"> 746         blob = Blob::create(context.sessionID(), WTFMove(blobData), encodingMIMEType);</span>
 747     callback-&gt;scheduleCallback(context, WTFMove(blob));
 748     return { };
 749 }
 750 
 751 RefPtr&lt;ImageData&gt; HTMLCanvasElement::getImageData()
 752 {
 753 #if ENABLE(WEBGL)
 754     if (is&lt;WebGLRenderingContextBase&gt;(m_context.get())) {
 755         if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
 756             ResourceLoadObserver::shared().logCanvasRead(document());
 757         return downcast&lt;WebGLRenderingContextBase&gt;(*m_context).paintRenderingResultsToImageData();
 758     }
 759 #endif
 760     return nullptr;
 761 }
 762 
 763 #if ENABLE(MEDIA_STREAM)
 764 
 765 RefPtr&lt;MediaSample&gt; HTMLCanvasElement::toMediaSample()
 766 {
</pre>
<hr />
<pre>
 813 
 814 #if USE(IOSURFACE_CANVAS_BACKING_STORE)
 815     return settings.canvasUsesAcceleratedDrawing();
 816 #elif ENABLE(ACCELERATED_2D_CANVAS)
 817     if (m_context &amp;&amp; !m_context-&gt;is2d())
 818         return false;
 819 
 820     if (!settings.accelerated2dCanvasEnabled())
 821         return false;
 822 
 823     if (area &lt; settings.minimumAccelerated2dCanvasSize())
 824         return false;
 825 
 826     return true;
 827 #else
 828     UNUSED_PARAM(size);
 829     return false;
 830 #endif
 831 }
 832 
<span class="line-removed"> 833 size_t HTMLCanvasElement::memoryCost() const</span>
<span class="line-removed"> 834 {</span>
<span class="line-removed"> 835     // memoryCost() may be invoked concurrently from a GC thread, and we need to be careful</span>
<span class="line-removed"> 836     // about what data we access here and how. We need to hold a lock to prevent m_imageBuffer</span>
<span class="line-removed"> 837     // from being changed while we access it.</span>
<span class="line-removed"> 838     auto locker = holdLock(m_imageBufferAssignmentLock);</span>
<span class="line-removed"> 839     if (!m_imageBuffer)</span>
<span class="line-removed"> 840         return 0;</span>
<span class="line-removed"> 841     return m_imageBuffer-&gt;memoryCost();</span>
<span class="line-removed"> 842 }</span>
<span class="line-removed"> 843 </span>
<span class="line-removed"> 844 size_t HTMLCanvasElement::externalMemoryCost() const</span>
<span class="line-removed"> 845 {</span>
<span class="line-removed"> 846     // externalMemoryCost() may be invoked concurrently from a GC thread, and we need to be careful</span>
<span class="line-removed"> 847     // about what data we access here and how. We need to hold a lock to prevent m_imageBuffer</span>
<span class="line-removed"> 848     // from being changed while we access it.</span>
<span class="line-removed"> 849     auto locker = holdLock(m_imageBufferAssignmentLock);</span>
<span class="line-removed"> 850     if (!m_imageBuffer)</span>
<span class="line-removed"> 851         return 0;</span>
<span class="line-removed"> 852     return m_imageBuffer-&gt;externalMemoryCost();</span>
<span class="line-removed"> 853 }</span>
<span class="line-removed"> 854 </span>
 855 void HTMLCanvasElement::setUsesDisplayListDrawing(bool usesDisplayListDrawing)
 856 {
 857     if (usesDisplayListDrawing == m_usesDisplayListDrawing)
 858         return;
 859 
 860     m_usesDisplayListDrawing = usesDisplayListDrawing;
 861 
 862     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
 863         downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setUsesDisplayListDrawing(m_usesDisplayListDrawing);
 864 }
 865 
 866 void HTMLCanvasElement::setTracksDisplayListReplay(bool tracksDisplayListReplay)
 867 {
 868     if (tracksDisplayListReplay == m_tracksDisplayListReplay)
 869         return;
 870 
 871     m_tracksDisplayListReplay = tracksDisplayListReplay;
 872 
 873     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
 874         downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setTracksDisplayListReplay(m_tracksDisplayListReplay);
 875 }
 876 
 877 String HTMLCanvasElement::displayListAsText(DisplayList::AsTextFlags flags) const
 878 {
 879     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
 880         return downcast&lt;CanvasRenderingContext2D&gt;(*m_context).displayListAsText(flags);
 881 
 882     return String();
 883 }
 884 
 885 String HTMLCanvasElement::replayDisplayListAsText(DisplayList::AsTextFlags flags) const
 886 {
 887     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
 888         return downcast&lt;CanvasRenderingContext2D&gt;(*m_context).replayDisplayListAsText(flags);
 889 
 890     return String();
 891 }
 892 
 893 void HTMLCanvasElement::createImageBuffer() const
 894 {
<span class="line-modified"> 895     ASSERT(!m_imageBuffer);</span>
 896 
 897     m_hasCreatedImageBuffer = true;
 898     m_didClearImageBuffer = true;
 899 
 900     // Perform multiplication as floating point to avoid overflow
 901     if (float(width()) * height() &gt; maxCanvasArea) {
 902         StringBuilder stringBuilder;
 903         stringBuilder.appendLiteral(&quot;Canvas area exceeds the maximum limit (width * height &gt; &quot;);
 904         stringBuilder.appendNumber(maxCanvasArea);
 905         stringBuilder.appendLiteral(&quot;).&quot;);
 906         document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, stringBuilder.toString());
 907         return;
 908     }
 909 
 910     // Make sure we don&#39;t use more pixel memory than the system can support.
 911     size_t requestedPixelMemory = 4 * width() * height();
<span class="line-modified"> 912     if (activePixelMemory + requestedPixelMemory &gt; maxActivePixelMemory()) {</span>
 913         StringBuilder stringBuilder;
 914         stringBuilder.appendLiteral(&quot;Total canvas memory use exceeds the maximum limit (&quot;);
 915         stringBuilder.appendNumber(maxActivePixelMemory() / 1024 / 1024);
 916         stringBuilder.appendLiteral(&quot; MB).&quot;);
 917         document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, stringBuilder.toString());
 918         return;
 919     }
 920 
 921     if (!width() || !height())
 922         return;
 923 
<span class="line-modified"> 924     RenderingMode renderingMode = shouldAccelerate(size()) ? Accelerated : Unaccelerated;</span>
 925 
 926     auto hostWindow = (document().view() &amp;&amp; document().view()-&gt;root()) ? document().view()-&gt;root()-&gt;hostWindow() : nullptr;
<span class="line-modified"> 927     setImageBuffer(ImageBuffer::create(size(), renderingMode, 1, ColorSpaceSRGB, hostWindow));</span>
<span class="line-removed"> 928 }</span>
<span class="line-removed"> 929 </span>
<span class="line-removed"> 930 void HTMLCanvasElement::setImageBuffer(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer) const</span>
<span class="line-removed"> 931 {</span>
<span class="line-removed"> 932     size_t previousMemoryCost = memoryCost();</span>
<span class="line-removed"> 933     removeFromActivePixelMemory(previousMemoryCost);</span>
<span class="line-removed"> 934 </span>
<span class="line-removed"> 935     {</span>
<span class="line-removed"> 936         auto locker = holdLock(m_imageBufferAssignmentLock);</span>
<span class="line-removed"> 937         m_contextStateSaver = nullptr;</span>
<span class="line-removed"> 938         m_imageBuffer = WTFMove(buffer);</span>
<span class="line-removed"> 939     }</span>
<span class="line-removed"> 940 </span>
<span class="line-removed"> 941     if (m_imageBuffer &amp;&amp; m_size != m_imageBuffer-&gt;internalSize())</span>
<span class="line-removed"> 942         m_size = m_imageBuffer-&gt;internalSize();</span>
<span class="line-removed"> 943 </span>
<span class="line-removed"> 944     size_t currentMemoryCost = memoryCost();</span>
<span class="line-removed"> 945     activePixelMemory += currentMemoryCost;</span>
<span class="line-removed"> 946 </span>
<span class="line-removed"> 947     if (m_context &amp;&amp; m_imageBuffer &amp;&amp; previousMemoryCost != currentMemoryCost)</span>
<span class="line-removed"> 948         InspectorInstrumentation::didChangeCanvasMemory(*m_context);</span>
<span class="line-removed"> 949 </span>
<span class="line-removed"> 950     if (!m_imageBuffer)</span>
<span class="line-removed"> 951         return;</span>
<span class="line-removed"> 952     m_imageBuffer-&gt;context().setShadowsIgnoreTransforms(true);</span>
<span class="line-removed"> 953     m_imageBuffer-&gt;context().setImageInterpolationQuality(defaultInterpolationQuality);</span>
<span class="line-removed"> 954     m_imageBuffer-&gt;context().setStrokeThickness(1);</span>
<span class="line-removed"> 955     m_contextStateSaver = makeUnique&lt;GraphicsContextStateSaver&gt;(m_imageBuffer-&gt;context());</span>
<span class="line-removed"> 956 </span>
<span class="line-removed"> 957     JSC::JSLockHolder lock(HTMLElement::scriptExecutionContext()-&gt;vm());</span>
<span class="line-removed"> 958     HTMLElement::scriptExecutionContext()-&gt;vm().heap.reportExtraMemoryAllocated(memoryCost());</span>
 959 
 960 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
 961     if (m_context &amp;&amp; m_context-&gt;is2d()) {
 962         // Recalculate compositing requirements if acceleration state changed.
 963         const_cast&lt;HTMLCanvasElement*&gt;(this)-&gt;invalidateStyleAndLayerComposition();
 964     }
 965 #endif
 966 }
 967 
 968 void HTMLCanvasElement::setImageBufferAndMarkDirty(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer)
 969 {
 970     m_hasCreatedImageBuffer = true;
 971     setImageBuffer(WTFMove(buffer));
<span class="line-modified"> 972     didDraw(FloatRect(FloatPoint(), m_size));</span>
<span class="line-removed"> 973 }</span>
<span class="line-removed"> 974 </span>
<span class="line-removed"> 975 GraphicsContext* HTMLCanvasElement::drawingContext() const</span>
<span class="line-removed"> 976 {</span>
<span class="line-removed"> 977     if (m_context &amp;&amp; !m_context-&gt;is2d())</span>
<span class="line-removed"> 978         return nullptr;</span>
<span class="line-removed"> 979 </span>
<span class="line-removed"> 980     return buffer() ? &amp;m_imageBuffer-&gt;context() : nullptr;</span>
<span class="line-removed"> 981 }</span>
<span class="line-removed"> 982 </span>
<span class="line-removed"> 983 GraphicsContext* HTMLCanvasElement::existingDrawingContext() const</span>
<span class="line-removed"> 984 {</span>
<span class="line-removed"> 985     if (!m_hasCreatedImageBuffer)</span>
<span class="line-removed"> 986         return nullptr;</span>
<span class="line-removed"> 987 </span>
<span class="line-removed"> 988     return drawingContext();</span>
<span class="line-removed"> 989 }</span>
<span class="line-removed"> 990 </span>
<span class="line-removed"> 991 ImageBuffer* HTMLCanvasElement::buffer() const</span>
<span class="line-removed"> 992 {</span>
<span class="line-removed"> 993     if (!m_hasCreatedImageBuffer)</span>
<span class="line-removed"> 994         createImageBuffer();</span>
<span class="line-removed"> 995     return m_imageBuffer.get();</span>
 996 }
 997 
 998 Image* HTMLCanvasElement::copiedImage() const
 999 {
1000     if (!m_copiedImage &amp;&amp; buffer()) {
1001         if (m_context)
1002             m_context-&gt;paintRenderingResultsToCanvas();
1003         m_copiedImage = buffer()-&gt;copyImage(CopyBackingStore, PreserveResolution::Yes);
1004     }
1005     return m_copiedImage.get();
1006 }
1007 
1008 void HTMLCanvasElement::clearImageBuffer() const
1009 {
1010     ASSERT(m_hasCreatedImageBuffer);
1011     ASSERT(!m_didClearImageBuffer);
1012     ASSERT(m_context);
1013 
1014     m_didClearImageBuffer = true;
1015 
1016     if (is&lt;CanvasRenderingContext2D&gt;(*m_context)) {
1017         // No need to undo transforms/clip/etc. because we are called right after the context is reset.
1018         downcast&lt;CanvasRenderingContext2D&gt;(*m_context).clearRect(0, 0, width(), height());
1019     }
1020 }
1021 
1022 void HTMLCanvasElement::clearCopiedImage()
1023 {
1024     m_copiedImage = nullptr;
1025     m_didClearImageBuffer = false;
1026 }
1027 
<span class="line-removed">1028 AffineTransform HTMLCanvasElement::baseTransform() const</span>
<span class="line-removed">1029 {</span>
<span class="line-removed">1030     ASSERT(m_hasCreatedImageBuffer);</span>
<span class="line-removed">1031     return m_imageBuffer-&gt;baseTransform();</span>
<span class="line-removed">1032 }</span>
<span class="line-removed">1033 </span>
1034 }
</pre>
</td>
<td>
<hr />
<pre>
  38 #include &quot;FrameLoaderClient.h&quot;
  39 #include &quot;GPUBasedCanvasRenderingContext.h&quot;
  40 #include &quot;GeometryUtilities.h&quot;
  41 #include &quot;GraphicsContext.h&quot;
  42 #include &quot;HTMLNames.h&quot;
  43 #include &quot;HTMLParserIdioms.h&quot;
  44 #include &quot;ImageBitmapRenderingContext.h&quot;
  45 #include &quot;ImageBuffer.h&quot;
  46 #include &quot;ImageData.h&quot;
  47 #include &quot;InspectorInstrumentation.h&quot;
  48 #include &quot;JSDOMConvertDictionary.h&quot;
  49 #include &quot;MIMETypeRegistry.h&quot;
  50 #include &quot;RenderElement.h&quot;
  51 #include &quot;RenderHTMLCanvas.h&quot;
  52 #include &quot;ResourceLoadObserver.h&quot;
  53 #include &quot;RuntimeEnabledFeatures.h&quot;
  54 #include &quot;ScriptController.h&quot;
  55 #include &quot;Settings.h&quot;
  56 #include &quot;StringAdaptors.h&quot;
  57 #include &lt;JavaScriptCore/JSCInlines.h&gt;

  58 #include &lt;math.h&gt;
  59 #include &lt;wtf/IsoMallocInlines.h&gt;
  60 #include &lt;wtf/RAMSize.h&gt;
  61 #include &lt;wtf/text/StringBuilder.h&gt;
  62 
  63 #if ENABLE(MEDIA_STREAM)
  64 #include &quot;CanvasCaptureMediaStreamTrack.h&quot;
  65 #include &quot;MediaStream.h&quot;
  66 #endif
  67 
  68 #if ENABLE(WEBGL)
  69 #include &quot;WebGLContextAttributes.h&quot;
  70 #include &quot;WebGLRenderingContext.h&quot;
  71 #endif
  72 
  73 #if ENABLE(WEBGL2)
  74 #include &quot;WebGL2RenderingContext.h&quot;
  75 #endif
  76 
  77 #if ENABLE(WEBGPU)
  78 #include &quot;GPUCanvasContext.h&quot;
  79 #endif
  80 
  81 #if PLATFORM(COCOA)
  82 #include &quot;MediaSampleAVFObjC.h&quot;
  83 #include &lt;pal/cf/CoreMediaSoftLink.h&gt;
  84 #endif
  85 
<span class="line-added">  86 #if USE(CG)</span>
<span class="line-added">  87 #include &quot;ImageBufferUtilitiesCG.h&quot;</span>
<span class="line-added">  88 #endif</span>
<span class="line-added">  89 </span>
  90 namespace WebCore {
  91 
  92 WTF_MAKE_ISO_ALLOCATED_IMPL(HTMLCanvasElement);
  93 
  94 using namespace PAL;
  95 using namespace HTMLNames;
  96 
  97 // These values come from the WhatWG/W3C HTML spec.
  98 const int defaultWidth = 300;
  99 const int defaultHeight = 150;
 100 
 101 // Firefox limits width/height to 32767 pixels, but slows down dramatically before it
 102 // reaches that limit. We limit by area instead, giving us larger maximum dimensions,
 103 // in exchange for a smaller maximum canvas size. The maximum canvas size is in device pixels.
 104 #if PLATFORM(IOS_FAMILY)
 105 const unsigned maxCanvasArea = 4096 * 4096;
 106 #else
 107 const unsigned maxCanvasArea = 16384 * 16384;
 108 #endif
 109 
<span class="line-modified"> 110 static size_t maxActivePixelMemoryForTesting = 0;</span>








 111 
 112 HTMLCanvasElement::HTMLCanvasElement(const QualifiedName&amp; tagName, Document&amp; document)
 113     : HTMLElement(tagName, document)
<span class="line-modified"> 114     , CanvasBase(IntSize(defaultWidth, defaultHeight))</span>
 115 {
 116     ASSERT(hasTagName(canvasTag));
 117 }
 118 
 119 Ref&lt;HTMLCanvasElement&gt; HTMLCanvasElement::create(Document&amp; document)
 120 {
 121     return adoptRef(*new HTMLCanvasElement(canvasTag, document));
 122 }
 123 
 124 Ref&lt;HTMLCanvasElement&gt; HTMLCanvasElement::create(const QualifiedName&amp; tagName, Document&amp; document)
 125 {
 126     return adoptRef(*new HTMLCanvasElement(tagName, document));
 127 }
 128 











 129 HTMLCanvasElement::~HTMLCanvasElement()
 130 {
<span class="line-added"> 131     // FIXME: This has to be called here because CSSCanvasValue::CanvasObserverProxy::canvasDestroyed()</span>
<span class="line-added"> 132     // downcasts the CanvasBase object to HTMLCanvasElement. That invokes virtual methods, which should be</span>
<span class="line-added"> 133     // avoided in destructors, but works as long as it&#39;s done before HTMLCanvasElement destructs completely.</span>
 134     notifyObserversCanvasDestroyed();
 135 
 136     m_context = nullptr; // Ensure this goes away before the ImageBuffer.
<span class="line-modified"> 137     setImageBuffer(nullptr);</span>

 138 }
 139 
 140 void HTMLCanvasElement::parseAttribute(const QualifiedName&amp; name, const AtomString&amp; value)
 141 {
 142     if (name == widthAttr || name == heightAttr)
 143         reset();
 144     HTMLElement::parseAttribute(name, value);
 145 }
 146 
 147 RenderPtr&lt;RenderElement&gt; HTMLCanvasElement::createElementRenderer(RenderStyle&amp;&amp; style, const RenderTreePosition&amp; insertionPosition)
 148 {
 149     RefPtr&lt;Frame&gt; frame = document().frame();
 150     if (frame &amp;&amp; frame-&gt;script().canExecuteScripts(NotAboutToExecuteScript))
 151         return createRenderer&lt;RenderHTMLCanvas&gt;(*this, WTFMove(style));
 152     return HTMLElement::createElementRenderer(WTFMove(style), insertionPosition);
 153 }
 154 
 155 bool HTMLCanvasElement::canContainRangeEndPoint() const
 156 {
 157     return false;
</pre>
<hr />
<pre>
 161 {
 162     return false;
 163 }
 164 
 165 ExceptionOr&lt;void&gt; HTMLCanvasElement::setHeight(unsigned value)
 166 {
 167     if (m_context &amp;&amp; m_context-&gt;isPlaceholder())
 168         return Exception { InvalidStateError };
 169     setAttributeWithoutSynchronization(heightAttr, AtomString::number(limitToOnlyHTMLNonNegative(value, defaultHeight)));
 170     return { };
 171 }
 172 
 173 ExceptionOr&lt;void&gt; HTMLCanvasElement::setWidth(unsigned value)
 174 {
 175     if (m_context &amp;&amp; m_context-&gt;isPlaceholder())
 176         return Exception { InvalidStateError };
 177     setAttributeWithoutSynchronization(widthAttr, AtomString::number(limitToOnlyHTMLNonNegative(value, defaultWidth)));
 178     return { };
 179 }
 180 
<span class="line-added"> 181 void HTMLCanvasElement::setSize(const IntSize&amp; newSize)</span>
<span class="line-added"> 182 {</span>
<span class="line-added"> 183     if (newSize == size())</span>
<span class="line-added"> 184         return;</span>
<span class="line-added"> 185 </span>
<span class="line-added"> 186     m_ignoreReset = true;</span>
<span class="line-added"> 187     setWidth(newSize.width());</span>
<span class="line-added"> 188     setHeight(newSize.height());</span>
<span class="line-added"> 189     m_ignoreReset = false;</span>
<span class="line-added"> 190     reset();</span>
<span class="line-added"> 191 }</span>
<span class="line-added"> 192 </span>
 193 static inline size_t maxActivePixelMemory()
 194 {
<span class="line-added"> 195     if (maxActivePixelMemoryForTesting)</span>
<span class="line-added"> 196         return maxActivePixelMemoryForTesting;</span>
<span class="line-added"> 197 </span>
 198     static size_t maxPixelMemory;
 199     static std::once_flag onceFlag;
 200     std::call_once(onceFlag, [] {
 201 #if PLATFORM(IOS_FAMILY)
 202         maxPixelMemory = ramSize() / 4;
 203 #else
 204         maxPixelMemory = std::max(ramSize() / 4, 2151 * MB);
 205 #endif
 206     });
<span class="line-added"> 207 </span>
 208     return maxPixelMemory;
 209 }
 210 
<span class="line-modified"> 211 void HTMLCanvasElement::setMaxPixelMemoryForTesting(size_t size)</span>
<span class="line-added"> 212 {</span>
<span class="line-added"> 213     maxActivePixelMemoryForTesting = size;</span>
<span class="line-added"> 214 }</span>
<span class="line-added"> 215 </span>
<span class="line-added"> 216 ExceptionOr&lt;Optional&lt;RenderingContext&gt;&gt; HTMLCanvasElement::getContext(JSC::JSGlobalObject&amp; state, const String&amp; contextId, Vector&lt;JSC::Strong&lt;JSC::Unknown&gt;&gt;&amp;&amp; arguments)</span>
 217 {
 218     if (m_context) {
 219         if (m_context-&gt;isPlaceholder())
 220             return Exception { InvalidStateError };
 221 
 222         if (m_context-&gt;is2d()) {
 223             if (!is2dType(contextId))
 224                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 225             return Optional&lt;RenderingContext&gt; { RefPtr&lt;CanvasRenderingContext2D&gt; { &amp;downcast&lt;CanvasRenderingContext2D&gt;(*m_context) } };
 226         }
 227 
 228         if (m_context-&gt;isBitmapRenderer()) {
 229             if (!isBitmapRendererType(contextId))
 230                 return Optional&lt;RenderingContext&gt; { WTF::nullopt };
 231             return Optional&lt;RenderingContext&gt; { RefPtr&lt;ImageBitmapRenderingContext&gt; { &amp;downcast&lt;ImageBitmapRenderingContext&gt;(*m_context) } };
 232         }
 233 
 234 #if ENABLE(WEBGL)
 235         if (m_context-&gt;isWebGL()) {
 236             if (!isWebGLType(contextId))
</pre>
<hr />
<pre>
 321 #if ENABLE(WEBGPU)
 322     if (HTMLCanvasElement::isWebGPUType(type))
 323         return getContextWebGPU(type);
 324 #endif
 325 
 326     return nullptr;
 327 }
 328 
 329 bool HTMLCanvasElement::is2dType(const String&amp; type)
 330 {
 331     return type == &quot;2d&quot;;
 332 }
 333 
 334 CanvasRenderingContext2D* HTMLCanvasElement::createContext2d(const String&amp; type)
 335 {
 336     ASSERT_UNUSED(HTMLCanvasElement::is2dType(type), type);
 337     ASSERT(!m_context);
 338 
 339     // Make sure we don&#39;t use more pixel memory than the system can support.
 340     size_t requestedPixelMemory = 4 * width() * height();
<span class="line-modified"> 341     if (activePixelMemory() + requestedPixelMemory &gt; maxActivePixelMemory()) {</span>
 342         StringBuilder stringBuilder;
 343         stringBuilder.appendLiteral(&quot;Total canvas memory use exceeds the maximum limit (&quot;);
 344         stringBuilder.appendNumber(maxActivePixelMemory() / 1024 / 1024);
 345         stringBuilder.appendLiteral(&quot; MB).&quot;);
 346         document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, stringBuilder.toString());
 347         return nullptr;
 348     }
 349 
 350     m_context = CanvasRenderingContext2D::create(*this, document().inQuirksMode());
 351 
 352     downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setUsesDisplayListDrawing(m_usesDisplayListDrawing);
 353     downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setTracksDisplayListReplay(m_tracksDisplayListReplay);
 354 
 355 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
 356     // Need to make sure a RenderLayer and compositing layer get created for the Canvas.
 357     invalidateStyleAndLayerComposition();
 358 #endif
 359 
 360     return static_cast&lt;CanvasRenderingContext2D*&gt;(m_context.get());
 361 }
</pre>
<hr />
<pre>
 527         r.intersect(destRect);
 528 
 529         if (!r.isEmpty() &amp;&amp; !m_dirtyRect.contains(r)) {
 530             m_dirtyRect.unite(r);
 531             renderer-&gt;repaintRectangle(enclosingIntRect(m_dirtyRect));
 532         }
 533     }
 534     notifyObserversCanvasChanged(dirtyRect);
 535 }
 536 
 537 void HTMLCanvasElement::reset()
 538 {
 539     if (m_ignoreReset)
 540         return;
 541 
 542     bool hadImageBuffer = hasCreatedImageBuffer();
 543 
 544     int w = limitToOnlyHTMLNonNegative(attributeWithoutSynchronization(widthAttr), defaultWidth);
 545     int h = limitToOnlyHTMLNonNegative(attributeWithoutSynchronization(heightAttr), defaultHeight);
 546 
<span class="line-modified"> 547     resetGraphicsContextState();</span>





 548     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
 549         downcast&lt;CanvasRenderingContext2D&gt;(*m_context).reset();
 550 
 551     IntSize oldSize = size();
 552     IntSize newSize(w, h);
 553     // If the size of an existing buffer matches, we can just clear it instead of reallocating.
 554     // This optimization is only done for 2D canvases for now.
 555     if (m_hasCreatedImageBuffer &amp;&amp; oldSize == newSize &amp;&amp; m_context &amp;&amp; m_context-&gt;is2d()) {
 556         if (!m_didClearImageBuffer)
 557             clearImageBuffer();
 558         return;
 559     }
 560 
 561     setSurfaceSize(newSize);
 562 
 563     if (isGPUBased() &amp;&amp; oldSize != size())
 564         downcast&lt;GPUBasedCanvasRenderingContext&gt;(*m_context).reshape(width(), height());
 565 
 566     auto renderer = this-&gt;renderer();
 567     if (is&lt;RenderHTMLCanvas&gt;(renderer)) {
</pre>
<hr />
<pre>
 615                 if (m_presentedImage)
 616                     context.drawImage(*m_presentedImage, snappedIntRect(r), renderer()-&gt;imageOrientation());
 617                 else if (ImageBuffer* imageBuffer = buffer())
 618                     context.drawImageBuffer(*imageBuffer, snappedIntRect(r));
 619             }
 620 
 621             if (isGPUBased())
 622                 downcast&lt;GPUBasedCanvasRenderingContext&gt;(*m_context).markLayerComposited();
 623         }
 624     }
 625 
 626     if (UNLIKELY(m_context &amp;&amp; m_context-&gt;callTracingActive()))
 627         InspectorInstrumentation::didFinishRecordingCanvasFrame(*m_context);
 628 }
 629 
 630 bool HTMLCanvasElement::isGPUBased() const
 631 {
 632     return m_context &amp;&amp; m_context-&gt;isGPUBased();
 633 }
 634 






 635 void HTMLCanvasElement::makePresentationCopy()
 636 {
 637     if (!m_presentedImage) {
 638         // The buffer contains the last presented data, so save a copy of it.
 639         m_presentedImage = buffer()-&gt;copyImage(CopyBackingStore, PreserveResolution::Yes);
 640     }
 641 }
 642 
 643 void HTMLCanvasElement::clearPresentationCopy()
 644 {
 645     m_presentedImage = nullptr;
 646 }
 647 






 648 void HTMLCanvasElement::setSurfaceSize(const IntSize&amp; size)
 649 {
<span class="line-modified"> 650     CanvasBase::setSize(size);</span>
 651     m_hasCreatedImageBuffer = false;
<span class="line-modified"> 652     setImageBuffer(nullptr);</span>
 653     clearCopiedImage();
 654 }
 655 
 656 static String toEncodingMimeType(const String&amp; mimeType)
 657 {
 658     if (!MIMETypeRegistry::isSupportedImageMIMETypeForEncoding(mimeType))
 659         return &quot;image/png&quot;_s;
 660     return mimeType.convertToASCIILowercase();
 661 }
 662 
 663 // https://html.spec.whatwg.org/multipage/canvas.html#a-serialisation-of-the-bitmap-as-a-file
 664 static Optional&lt;double&gt; qualityFromJSValue(JSC::JSValue qualityValue)
 665 {
 666     if (!qualityValue.isNumber())
 667         return WTF::nullopt;
 668 
 669     double qualityNumber = qualityValue.asNumber();
 670     if (qualityNumber &lt; 0 || qualityNumber &gt; 1)
 671         return WTF::nullopt;
 672 
 673     return qualityNumber;
 674 }
 675 
 676 ExceptionOr&lt;UncachedString&gt; HTMLCanvasElement::toDataURL(const String&amp; mimeType, JSC::JSValue qualityValue)
 677 {
 678     if (!originClean())
 679         return Exception { SecurityError };
 680 
<span class="line-modified"> 681     if (size().isEmpty() || !buffer())</span>
 682         return UncachedString { &quot;data:,&quot;_s };
 683     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
 684         ResourceLoadObserver::shared().logCanvasRead(document());
 685 
 686     auto encodingMIMEType = toEncodingMimeType(mimeType);
 687     auto quality = qualityFromJSValue(qualityValue);
 688 
 689 #if USE(CG)
 690     // Try to get ImageData first, as that may avoid lossy conversions.
 691     if (auto imageData = getImageData())
 692         return UncachedString { dataURL(*imageData, encodingMIMEType, quality) };
 693 #endif
 694 
 695     makeRenderingResultsAvailable();
 696 
 697     return UncachedString { buffer()-&gt;toDataURL(encodingMIMEType, quality) };
 698 }
 699 
 700 ExceptionOr&lt;UncachedString&gt; HTMLCanvasElement::toDataURL(const String&amp; mimeType)
 701 {
 702     return toDataURL(mimeType, { });
 703 }
 704 
 705 ExceptionOr&lt;void&gt; HTMLCanvasElement::toBlob(ScriptExecutionContext&amp; context, Ref&lt;BlobCallback&gt;&amp;&amp; callback, const String&amp; mimeType, JSC::JSValue qualityValue)
 706 {
 707     if (!originClean())
 708         return Exception { SecurityError };
 709 
<span class="line-modified"> 710     if (size().isEmpty() || !buffer()) {</span>
 711         callback-&gt;scheduleCallback(context, nullptr);
 712         return { };
 713     }
 714     if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
 715         ResourceLoadObserver::shared().logCanvasRead(document());
 716 
 717     auto encodingMIMEType = toEncodingMimeType(mimeType);
 718     auto quality = qualityFromJSValue(qualityValue);
 719 
 720 #if USE(CG)
 721     if (auto imageData = getImageData()) {
 722         RefPtr&lt;Blob&gt; blob;
 723         Vector&lt;uint8_t&gt; blobData = data(*imageData, encodingMIMEType, quality);
 724         if (!blobData.isEmpty())
<span class="line-modified"> 725             blob = Blob::create(WTFMove(blobData), encodingMIMEType);</span>
 726         callback-&gt;scheduleCallback(context, WTFMove(blob));
 727         return { };
 728     }
 729 #endif
 730 
 731     makeRenderingResultsAvailable();
 732 
 733     RefPtr&lt;Blob&gt; blob;
 734     Vector&lt;uint8_t&gt; blobData = buffer()-&gt;toData(encodingMIMEType, quality);
 735     if (!blobData.isEmpty())
<span class="line-modified"> 736         blob = Blob::create(WTFMove(blobData), encodingMIMEType);</span>
 737     callback-&gt;scheduleCallback(context, WTFMove(blob));
 738     return { };
 739 }
 740 
 741 RefPtr&lt;ImageData&gt; HTMLCanvasElement::getImageData()
 742 {
 743 #if ENABLE(WEBGL)
 744     if (is&lt;WebGLRenderingContextBase&gt;(m_context.get())) {
 745         if (RuntimeEnabledFeatures::sharedFeatures().webAPIStatisticsEnabled())
 746             ResourceLoadObserver::shared().logCanvasRead(document());
 747         return downcast&lt;WebGLRenderingContextBase&gt;(*m_context).paintRenderingResultsToImageData();
 748     }
 749 #endif
 750     return nullptr;
 751 }
 752 
 753 #if ENABLE(MEDIA_STREAM)
 754 
 755 RefPtr&lt;MediaSample&gt; HTMLCanvasElement::toMediaSample()
 756 {
</pre>
<hr />
<pre>
 803 
 804 #if USE(IOSURFACE_CANVAS_BACKING_STORE)
 805     return settings.canvasUsesAcceleratedDrawing();
 806 #elif ENABLE(ACCELERATED_2D_CANVAS)
 807     if (m_context &amp;&amp; !m_context-&gt;is2d())
 808         return false;
 809 
 810     if (!settings.accelerated2dCanvasEnabled())
 811         return false;
 812 
 813     if (area &lt; settings.minimumAccelerated2dCanvasSize())
 814         return false;
 815 
 816     return true;
 817 #else
 818     UNUSED_PARAM(size);
 819     return false;
 820 #endif
 821 }
 822 






















 823 void HTMLCanvasElement::setUsesDisplayListDrawing(bool usesDisplayListDrawing)
 824 {
 825     if (usesDisplayListDrawing == m_usesDisplayListDrawing)
 826         return;
 827 
 828     m_usesDisplayListDrawing = usesDisplayListDrawing;
 829 
 830     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
 831         downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setUsesDisplayListDrawing(m_usesDisplayListDrawing);
 832 }
 833 
 834 void HTMLCanvasElement::setTracksDisplayListReplay(bool tracksDisplayListReplay)
 835 {
 836     if (tracksDisplayListReplay == m_tracksDisplayListReplay)
 837         return;
 838 
 839     m_tracksDisplayListReplay = tracksDisplayListReplay;
 840 
 841     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
 842         downcast&lt;CanvasRenderingContext2D&gt;(*m_context).setTracksDisplayListReplay(m_tracksDisplayListReplay);
 843 }
 844 
 845 String HTMLCanvasElement::displayListAsText(DisplayList::AsTextFlags flags) const
 846 {
 847     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
 848         return downcast&lt;CanvasRenderingContext2D&gt;(*m_context).displayListAsText(flags);
 849 
 850     return String();
 851 }
 852 
 853 String HTMLCanvasElement::replayDisplayListAsText(DisplayList::AsTextFlags flags) const
 854 {
 855     if (is&lt;CanvasRenderingContext2D&gt;(m_context.get()))
 856         return downcast&lt;CanvasRenderingContext2D&gt;(*m_context).replayDisplayListAsText(flags);
 857 
 858     return String();
 859 }
 860 
 861 void HTMLCanvasElement::createImageBuffer() const
 862 {
<span class="line-modified"> 863     ASSERT(!hasCreatedImageBuffer());</span>
 864 
 865     m_hasCreatedImageBuffer = true;
 866     m_didClearImageBuffer = true;
 867 
 868     // Perform multiplication as floating point to avoid overflow
 869     if (float(width()) * height() &gt; maxCanvasArea) {
 870         StringBuilder stringBuilder;
 871         stringBuilder.appendLiteral(&quot;Canvas area exceeds the maximum limit (width * height &gt; &quot;);
 872         stringBuilder.appendNumber(maxCanvasArea);
 873         stringBuilder.appendLiteral(&quot;).&quot;);
 874         document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, stringBuilder.toString());
 875         return;
 876     }
 877 
 878     // Make sure we don&#39;t use more pixel memory than the system can support.
 879     size_t requestedPixelMemory = 4 * width() * height();
<span class="line-modified"> 880     if (activePixelMemory() + requestedPixelMemory &gt; maxActivePixelMemory()) {</span>
 881         StringBuilder stringBuilder;
 882         stringBuilder.appendLiteral(&quot;Total canvas memory use exceeds the maximum limit (&quot;);
 883         stringBuilder.appendNumber(maxActivePixelMemory() / 1024 / 1024);
 884         stringBuilder.appendLiteral(&quot; MB).&quot;);
 885         document().addConsoleMessage(MessageSource::JS, MessageLevel::Warning, stringBuilder.toString());
 886         return;
 887     }
 888 
 889     if (!width() || !height())
 890         return;
 891 
<span class="line-modified"> 892     RenderingMode renderingMode = shouldAccelerate(size()) ? RenderingMode::Accelerated : RenderingMode::Unaccelerated;</span>
 893 
 894     auto hostWindow = (document().view() &amp;&amp; document().view()-&gt;root()) ? document().view()-&gt;root()-&gt;hostWindow() : nullptr;
<span class="line-modified"> 895     setImageBuffer(ImageBuffer::create(size(), renderingMode, 1, ColorSpace::SRGB, hostWindow));</span>































 896 
 897 #if USE(IOSURFACE_CANVAS_BACKING_STORE) || ENABLE(ACCELERATED_2D_CANVAS)
 898     if (m_context &amp;&amp; m_context-&gt;is2d()) {
 899         // Recalculate compositing requirements if acceleration state changed.
 900         const_cast&lt;HTMLCanvasElement*&gt;(this)-&gt;invalidateStyleAndLayerComposition();
 901     }
 902 #endif
 903 }
 904 
 905 void HTMLCanvasElement::setImageBufferAndMarkDirty(std::unique_ptr&lt;ImageBuffer&gt;&amp;&amp; buffer)
 906 {
 907     m_hasCreatedImageBuffer = true;
 908     setImageBuffer(WTFMove(buffer));
<span class="line-modified"> 909     didDraw(FloatRect(FloatPoint(), size()));</span>























 910 }
 911 
 912 Image* HTMLCanvasElement::copiedImage() const
 913 {
 914     if (!m_copiedImage &amp;&amp; buffer()) {
 915         if (m_context)
 916             m_context-&gt;paintRenderingResultsToCanvas();
 917         m_copiedImage = buffer()-&gt;copyImage(CopyBackingStore, PreserveResolution::Yes);
 918     }
 919     return m_copiedImage.get();
 920 }
 921 
 922 void HTMLCanvasElement::clearImageBuffer() const
 923 {
 924     ASSERT(m_hasCreatedImageBuffer);
 925     ASSERT(!m_didClearImageBuffer);
 926     ASSERT(m_context);
 927 
 928     m_didClearImageBuffer = true;
 929 
 930     if (is&lt;CanvasRenderingContext2D&gt;(*m_context)) {
 931         // No need to undo transforms/clip/etc. because we are called right after the context is reset.
 932         downcast&lt;CanvasRenderingContext2D&gt;(*m_context).clearRect(0, 0, width(), height());
 933     }
 934 }
 935 
 936 void HTMLCanvasElement::clearCopiedImage()
 937 {
 938     m_copiedImage = nullptr;
 939     m_didClearImageBuffer = false;
 940 }
 941 






 942 }
</pre>
</td>
</tr>
</table>
<center><a href="HTMLAttributeNames.in.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="HTMLCanvasElement.h.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLProgram.cpp b/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLProgram.cpp
--- a/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLProgram.cpp
+++ b/modules/javafx.web/src/main/native/Source/WebCore/html/canvas/WebGLProgram.cpp
@@ -26,14 +26,15 @@
 #include "config.h"
 #include "WebGLProgram.h"
 
 #if ENABLE(WEBGL)
 
+#include "InspectorInstrumentation.h"
+#include "ScriptExecutionContext.h"
 #include "WebGLContextGroup.h"
 #include "WebGLRenderingContextBase.h"
 #include "WebGLShader.h"
-#include <wtf/HashMap.h>
 #include <wtf/Lock.h>
 #include <wtf/NeverDestroyed.h>
 
 namespace WebCore {
 
@@ -58,31 +59,43 @@
     return adoptRef(*new WebGLProgram(ctx));
 }
 
 WebGLProgram::WebGLProgram(WebGLRenderingContextBase& ctx)
     : WebGLSharedObject(ctx)
+    , ContextDestructionObserver(ctx.scriptExecutionContext())
 {
+    ASSERT(scriptExecutionContext());
+
     {
         LockHolder lock(instancesMutex());
         instances(lock).add(this, &ctx);
     }
 
-    setObject(ctx.graphicsContext3D()->createProgram());
+    setObject(ctx.graphicsContextGL()->createProgram());
 }
 
 WebGLProgram::~WebGLProgram()
 {
+    InspectorInstrumentation::willDestroyWebGLProgram(*this);
+
     deleteObject(0);
 
     {
         LockHolder lock(instancesMutex());
         ASSERT(instances(lock).contains(this));
         instances(lock).remove(this);
     }
 }
 
-void WebGLProgram::deleteObjectImpl(GraphicsContext3D* context3d, Platform3DObject obj)
+void WebGLProgram::contextDestroyed()
+{
+    InspectorInstrumentation::willDestroyWebGLProgram(*this);
+
+    ContextDestructionObserver::contextDestroyed();
+}
+
+void WebGLProgram::deleteObjectImpl(GraphicsContextGLOpenGL* context3d, PlatformGLObject obj)
 {
     context3d->deleteProgram(obj);
     if (m_vertexShader) {
         m_vertexShader->onDetached(context3d);
         m_vertexShader = nullptr;
@@ -97,11 +110,11 @@
 {
     cacheInfoIfNeeded();
     return m_activeAttribLocations.size();
 }
 
-GC3Dint WebGLProgram::getActiveAttribLocation(GC3Duint index)
+GCGLint WebGLProgram::getActiveAttribLocation(GCGLuint index)
 {
     cacheInfoIfNeeded();
     if (index >= numActiveAttribLocations())
         return -1;
     return m_activeAttribLocations[index];
@@ -133,16 +146,16 @@
 {
     ++m_linkCount;
     m_infoValid = false;
 }
 
-WebGLShader* WebGLProgram::getAttachedShader(GC3Denum type)
+WebGLShader* WebGLProgram::getAttachedShader(GCGLenum type)
 {
     switch (type) {
-    case GraphicsContext3D::VERTEX_SHADER:
+    case GraphicsContextGL::VERTEX_SHADER:
         return m_vertexShader.get();
-    case GraphicsContext3D::FRAGMENT_SHADER:
+    case GraphicsContextGL::FRAGMENT_SHADER:
         return m_fragmentShader.get();
     default:
         return 0;
     }
 }
@@ -150,16 +163,16 @@
 bool WebGLProgram::attachShader(WebGLShader* shader)
 {
     if (!shader || !shader->object())
         return false;
     switch (shader->getType()) {
-    case GraphicsContext3D::VERTEX_SHADER:
+    case GraphicsContextGL::VERTEX_SHADER:
         if (m_vertexShader)
             return false;
         m_vertexShader = shader;
         return true;
-    case GraphicsContext3D::FRAGMENT_SHADER:
+    case GraphicsContextGL::FRAGMENT_SHADER:
         if (m_fragmentShader)
             return false;
         m_fragmentShader = shader;
         return true;
     default:
@@ -170,34 +183,34 @@
 bool WebGLProgram::detachShader(WebGLShader* shader)
 {
     if (!shader || !shader->object())
         return false;
     switch (shader->getType()) {
-    case GraphicsContext3D::VERTEX_SHADER:
+    case GraphicsContextGL::VERTEX_SHADER:
         if (m_vertexShader != shader)
             return false;
         m_vertexShader = nullptr;
         return true;
-    case GraphicsContext3D::FRAGMENT_SHADER:
+    case GraphicsContextGL::FRAGMENT_SHADER:
         if (m_fragmentShader != shader)
             return false;
         m_fragmentShader = nullptr;
         return true;
     default:
         return false;
     }
 }
 
-void WebGLProgram::cacheActiveAttribLocations(GraphicsContext3D* context3d)
+void WebGLProgram::cacheActiveAttribLocations(GraphicsContextGLOpenGL* context3d)
 {
     m_activeAttribLocations.clear();
 
-    GC3Dint numAttribs = 0;
-    context3d->getProgramiv(object(), GraphicsContext3D::ACTIVE_ATTRIBUTES, &numAttribs);
+    GCGLint numAttribs = 0;
+    context3d->getProgramiv(object(), GraphicsContextGL::ACTIVE_ATTRIBUTES, &numAttribs);
     m_activeAttribLocations.resize(static_cast<size_t>(numAttribs));
     for (int i = 0; i < numAttribs; ++i) {
-        ActiveInfo info;
+        GraphicsContextGL::ActiveInfo info;
         context3d->getActiveAttribImpl(object(), i, info);
         m_activeAttribLocations[i] = context3d->getAttribLocation(object(), info.name);
     }
 }
 
@@ -207,15 +220,15 @@
         return;
 
     if (!object())
         return;
 
-    GraphicsContext3D* context = getAGraphicsContext3D();
+    GraphicsContextGLOpenGL* context = getAGraphicsContextGL();
     if (!context)
         return;
-    GC3Dint linkStatus = 0;
-    context->getProgramiv(object(), GraphicsContext3D::LINK_STATUS, &linkStatus);
+    GCGLint linkStatus = 0;
+    context->getProgramiv(object(), GraphicsContextGL::LINK_STATUS, &linkStatus);
     m_linkStatus = linkStatus;
     if (m_linkStatus)
         cacheActiveAttribLocations(context);
     m_infoValid = true;
 }

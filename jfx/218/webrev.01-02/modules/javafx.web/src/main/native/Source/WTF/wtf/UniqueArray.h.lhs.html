<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/WTF/wtf/UniqueArray.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (C) 2018 Yusuke Suzuki &lt;utatane.tea@gmail.com&gt;. All rights reserved.
  3  *
  4  * Redistribution and use in source and binary forms, with or without
  5  * modification, are permitted provided that the following conditions
  6  * are met:
  7  * 1. Redistributions of source code must retain the above copyright
  8  *    notice, this list of conditions and the following disclaimer.
  9  * 2. Redistributions in binary form must reproduce the above copyright
 10  *    notice, this list of conditions and the following disclaimer in the
 11  *    documentation and/or other materials provided with the distribution.
 12  *
 13  * THIS SOFTWARE IS PROVIDED BY APPLE INC. AND ITS CONTRIBUTORS ``AS IS&#39;&#39;
 14  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 15  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 16  * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL APPLE INC. OR ITS CONTRIBUTORS
 17  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 18  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 19  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 20  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 21  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 22  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 23  * THE POSSIBILITY OF SUCH DAMAGE.
 24  */
 25 
 26 #pragma once
 27 
 28 #include &lt;wtf/CheckedArithmetic.h&gt;
 29 #include &lt;wtf/FastMalloc.h&gt;
 30 #include &lt;wtf/Vector.h&gt;
 31 
 32 namespace WTF {
 33 
<a name="1" id="anc1"></a>


 34 template&lt;bool isTriviallyDestructible, typename T&gt; struct UniqueArrayMaker;
 35 
<a name="2" id="anc2"></a>




















 36 template&lt;typename T&gt;
 37 struct UniqueArrayMaker&lt;true, T&gt; {
<a name="3" id="anc3"></a><span class="line-modified"> 38     using ResultType = typename std::unique_ptr&lt;T[], FastFree&lt;T[]&gt;&gt;;</span>
 39 
 40     static ResultType make(size_t size)
 41     {
 42         // C++ `new T[N]` stores its `N` to somewhere. Otherwise, `delete []` cannot destroy
 43         // these N elements. But we do not want to increase the size of allocated memory.
 44         // If it is acceptable, we can just use Vector&lt;T&gt; instead. So this UniqueArray&lt;T&gt; only
 45         // accepts the type T which has a trivial destructor. This allows us to skip calling
 46         // destructors for N elements. And this allows UniqueArray&lt;T&gt; not to store its N size.
 47         static_assert(std::is_trivially_destructible&lt;T&gt;::value, &quot;&quot;);
 48 
 49         // Do not use placement new like `new (storage) T[size]()`. `new T[size]()` requires
 50         // larger storage than the `sizeof(T) * size` storage since it want to store `size`
 51         // to somewhere.
<a name="4" id="anc4"></a><span class="line-modified"> 52         T* storage = static_cast&lt;T*&gt;(fastMalloc((Checked&lt;size_t&gt;(sizeof(T)) * size).unsafeGet()));</span>
 53         VectorTypeOperations&lt;T&gt;::initialize(storage, storage + size);
 54         return ResultType(storage);
 55     }
 56 };
 57 
 58 template&lt;typename T&gt;
 59 struct UniqueArrayMaker&lt;false, T&gt; {
 60     // Since we do not know how to store/retrieve N size to/from allocated memory when calling new [] and delete [],
 61     // we use new [] and delete [] operators simply. We create UniqueArrayElement container for the type T.
 62     // UniqueArrayElement has new [] and delete [] operators for FastMalloc. We allocate UniqueArrayElement[] and cast
 63     // it to T[]. When deleting, the custom deleter casts T[] to UniqueArrayElement[] and deletes it.
 64     class UniqueArrayElement {
<a name="5" id="anc5"></a><span class="line-modified"> 65         WTF_MAKE_FAST_ALLOCATED;</span>
 66     public:
 67         struct Deleter {
 68             void operator()(T* pointer)
 69             {
 70                 delete [] bitwise_cast&lt;UniqueArrayElement*&gt;(pointer);
 71             };
 72         };
 73 
 74         UniqueArrayElement() = default;
 75 
 76         T value { };
 77     };
 78     static_assert(sizeof(T) == sizeof(UniqueArrayElement), &quot;&quot;);
 79 
 80     using ResultType = typename std::unique_ptr&lt;T[], typename UniqueArrayElement::Deleter&gt;;
 81 
 82     static ResultType make(size_t size)
 83     {
 84         return ResultType(bitwise_cast&lt;T*&gt;(new UniqueArrayElement[size]()));
 85     }
 86 };
 87 
 88 template&lt;typename T&gt;
 89 using UniqueArray = typename UniqueArrayMaker&lt;std::is_trivially_destructible&lt;T&gt;::value, T&gt;::ResultType;
 90 
 91 template&lt;typename T&gt;
 92 UniqueArray&lt;T&gt; makeUniqueArray(size_t size)
 93 {
 94     static_assert(std::is_same&lt;typename std::remove_extent&lt;T&gt;::type, T&gt;::value, &quot;&quot;);
 95     return UniqueArrayMaker&lt;std::is_trivially_destructible&lt;T&gt;::value, T&gt;::make(size);
 96 }
 97 
 98 } // namespace WTF
 99 
100 using WTF::UniqueArray;
101 using WTF::makeUniqueArray;
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
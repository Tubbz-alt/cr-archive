<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames modules/javafx.web/src/main/native/Source/JavaScriptCore/disassembler/udis86/udis86_syn-intel.c</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /* udis86 - libudis86/syn-intel.c
  2  *
  3  * Copyright (c) 2002-2013 Vivek Thampi
  4  * All rights reserved.
  5  *
  6  * Redistribution and use in source and binary forms, with or without modification,
  7  * are permitted provided that the following conditions are met:
  8  *
  9  *     * Redistributions of source code must retain the above copyright notice,
 10  *       this list of conditions and the following disclaimer.
 11  *     * Redistributions in binary form must reproduce the above copyright notice,
 12  *       this list of conditions and the following disclaimer in the documentation
 13  *       and/or other materials provided with the distribution.
 14  *
 15  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 16  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 17  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 18  * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 19  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 20  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 21  * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 22  * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 23  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 24  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 25  */
 26 
 27 #include &quot;config.h&quot;
 28 
<a name="1" id="anc1"></a><span class="line-modified"> 29 #if ENABLE(UDIS86)</span>
 30 
 31 #include &quot;udis86_types.h&quot;
 32 #include &quot;udis86_extern.h&quot;
 33 #include &quot;udis86_decode.h&quot;
 34 #include &quot;udis86_itab.h&quot;
 35 #include &quot;udis86_syn.h&quot;
 36 #include &quot;udis86_udint.h&quot;
 37 
 38 /* -----------------------------------------------------------------------------
 39  * opr_cast() - Prints an operand cast.
 40  * -----------------------------------------------------------------------------
 41  */
 42 static void
 43 opr_cast(struct ud* u, struct ud_operand* op)
 44 {
 45   if (u-&gt;br_far) {
 46     ud_asmprintf(u, &quot;far &quot;);
 47   }
 48   switch(op-&gt;size) {
 49   case  8:  ud_asmprintf(u, &quot;byte &quot; ); break;
 50   case 16:  ud_asmprintf(u, &quot;word &quot; ); break;
 51   case 32:  ud_asmprintf(u, &quot;dword &quot;); break;
 52   case 64:  ud_asmprintf(u, &quot;qword &quot;); break;
 53   case 80:  ud_asmprintf(u, &quot;tword &quot;); break;
 54   case 128: ud_asmprintf(u, &quot;oword &quot;); break;
 55   case 256: ud_asmprintf(u, &quot;yword &quot;); break;
 56   default: break;
 57   }
 58 }
 59 
 60 /* -----------------------------------------------------------------------------
 61  * gen_operand() - Generates assembly output for each operand.
 62  * -----------------------------------------------------------------------------
 63  */
 64 static void gen_operand(struct ud* u, struct ud_operand* op, int syn_cast)
 65 {
 66   switch(op-&gt;type) {
 67   case UD_OP_REG:
 68     ud_asmprintf(u, &quot;%s&quot;, ud_reg_tab[op-&gt;base - UD_R_AL]);
 69     break;
 70 
 71   case UD_OP_MEM:
 72     if (syn_cast) {
 73       opr_cast(u, op);
 74     }
 75     ud_asmprintf(u, &quot;[&quot;);
 76     if (u-&gt;pfx_seg) {
 77       ud_asmprintf(u, &quot;%s:&quot;, ud_reg_tab[u-&gt;pfx_seg - UD_R_AL]);
 78     }
 79     if (op-&gt;base) {
 80       ud_asmprintf(u, &quot;%s&quot;, ud_reg_tab[op-&gt;base - UD_R_AL]);
 81     }
 82     if (op-&gt;index) {
 83       ud_asmprintf(u, &quot;%s%s&quot;, op-&gt;base != UD_NONE? &quot;+&quot; : &quot;&quot;,
 84                               ud_reg_tab[op-&gt;index - UD_R_AL]);
 85       if (op-&gt;scale) {
 86         ud_asmprintf(u, &quot;*%d&quot;, op-&gt;scale);
 87       }
 88     }
 89     if (op-&gt;offset != 0) {
 90       ud_syn_print_mem_disp(u, op, (op-&gt;base  != UD_NONE ||
 91                                     op-&gt;index != UD_NONE) ? 1 : 0);
 92     }
 93     ud_asmprintf(u, &quot;]&quot;);
 94     break;
 95 
 96   case UD_OP_IMM:
 97     ud_syn_print_imm(u, op);
 98     break;
 99 
100 
101   case UD_OP_JIMM:
102     ud_syn_print_addr(u, ud_syn_rel_target(u, op));
103     break;
104 
105   case UD_OP_PTR:
106     switch (op-&gt;size) {
107       case 32:
108         ud_asmprintf(u, &quot;word 0x%x:0x%x&quot;, op-&gt;lval.ptr.seg,
109           op-&gt;lval.ptr.off &amp; 0xFFFF);
110         break;
111       case 48:
112         ud_asmprintf(u, &quot;dword 0x%x:0x%x&quot;, op-&gt;lval.ptr.seg,
113           op-&gt;lval.ptr.off);
114         break;
115     }
116     break;
117 
118   case UD_OP_CONST:
119     if (syn_cast) opr_cast(u, op);
120     ud_asmprintf(u, &quot;%d&quot;, op-&gt;lval.udword);
121     break;
122 
123   default: return;
124   }
125 }
126 
127 /* =============================================================================
128  * translates to intel syntax
129  * =============================================================================
130  */
131 extern void
132 ud_translate_intel(struct ud* u)
133 {
134   /* check if P_OSO prefix is used */
135   if (!P_OSO(u-&gt;itab_entry-&gt;prefix) &amp;&amp; u-&gt;pfx_opr) {
136     switch (u-&gt;dis_mode) {
137     case 16: ud_asmprintf(u, &quot;o32 &quot;); break;
138     case 32:
139     case 64: ud_asmprintf(u, &quot;o16 &quot;); break;
140     }
141   }
142 
143   /* check if P_ASO prefix was used */
144   if (!P_ASO(u-&gt;itab_entry-&gt;prefix) &amp;&amp; u-&gt;pfx_adr) {
145     switch (u-&gt;dis_mode) {
146     case 16: ud_asmprintf(u, &quot;a32 &quot;); break;
147     case 32: ud_asmprintf(u, &quot;a16 &quot;); break;
148     case 64: ud_asmprintf(u, &quot;a32 &quot;); break;
149     }
150   }
151 
152   if (u-&gt;pfx_seg &amp;&amp;
153       u-&gt;operand[0].type != UD_OP_MEM &amp;&amp;
154       u-&gt;operand[1].type != UD_OP_MEM ) {
155     ud_asmprintf(u, &quot;%s &quot;, ud_reg_tab[u-&gt;pfx_seg - UD_R_AL]);
156   }
157 
158   if (u-&gt;pfx_lock) {
159     ud_asmprintf(u, &quot;lock &quot;);
160   }
161   if (u-&gt;pfx_rep) {
162     ud_asmprintf(u, &quot;rep &quot;);
163   } else if (u-&gt;pfx_repe) {
164     ud_asmprintf(u, &quot;repe &quot;);
165   } else if (u-&gt;pfx_repne) {
166     ud_asmprintf(u, &quot;repne &quot;);
167   }
168 
169   /* print the instruction mnemonic */
170   ud_asmprintf(u, &quot;%s&quot;, ud_lookup_mnemonic(u-&gt;mnemonic));
171 
172   if (u-&gt;operand[0].type != UD_NONE) {
173     int cast = 0;
174     ud_asmprintf(u, &quot; &quot;);
175     if (u-&gt;operand[0].type == UD_OP_MEM) {
176       if (u-&gt;operand[1].type == UD_OP_IMM   ||
177           u-&gt;operand[1].type == UD_OP_CONST ||
178           u-&gt;operand[1].type == UD_NONE     ||
179           (u-&gt;operand[0].size != u-&gt;operand[1].size)) {
180           cast = 1;
181       } else if (u-&gt;operand[1].type == UD_OP_REG &amp;&amp;
182                  u-&gt;operand[1].base == UD_R_CL) {
183           switch (u-&gt;mnemonic) {
184           case UD_Ircl:
185           case UD_Irol:
186           case UD_Iror:
187           case UD_Ircr:
188           case UD_Ishl:
189           case UD_Ishr:
190           case UD_Isar:
191               cast = 1;
192               break;
193           default: break;
194           }
195       }
196     }
197     gen_operand(u, &amp;u-&gt;operand[0], cast);
198   }
199 
200   if (u-&gt;operand[1].type != UD_NONE) {
201     int cast = 0;
202     ud_asmprintf(u, &quot;, &quot;);
203     if (u-&gt;operand[1].type == UD_OP_MEM &amp;&amp;
204         u-&gt;operand[0].size != u-&gt;operand[1].size &amp;&amp;
205         !ud_opr_is_sreg(&amp;u-&gt;operand[0])) {
206       cast = 1;
207     }
208     gen_operand(u, &amp;u-&gt;operand[1], cast);
209   }
210 
211   if (u-&gt;operand[2].type != UD_NONE) {
212     int cast = 0;
213     ud_asmprintf(u, &quot;, &quot;);
214     if (u-&gt;operand[2].type == UD_OP_MEM &amp;&amp;
215         u-&gt;operand[2].size != u-&gt;operand[1].size) {
216       cast = 1;
217     }
218     gen_operand(u, &amp;u-&gt;operand[2], cast);
219   }
220 
221   if (u-&gt;operand[3].type != UD_NONE) {
222     ud_asmprintf(u, &quot;, &quot;);
223     gen_operand(u, &amp;u-&gt;operand[3], 0);
224   }
225 }
226 
<a name="2" id="anc2"></a><span class="line-modified">227 #endif // ENABLE(UDIS86)</span>
228 
229 /*
230 vim: set ts=2 sw=2 expandtab
231 */
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
diff a/modules/javafx.web/src/main/native/Source/WTF/wtf/BloomFilter.h b/modules/javafx.web/src/main/native/Source/WTF/wtf/BloomFilter.h
--- a/modules/javafx.web/src/main/native/Source/WTF/wtf/BloomFilter.h
+++ b/modules/javafx.web/src/main/native/Source/WTF/wtf/BloomFilter.h
@@ -1,7 +1,7 @@
 /*
- * Copyright (C) 2011, 2015 Apple Inc. All rights reserved.
+ * Copyright (C) 2011-2019 Apple Inc. All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
  * are met:
  * 1. Redistributions of source code must retain the above copyright
@@ -36,11 +36,11 @@
 // See http://en.wikipedia.org/wiki/Bloom_filter
 template <unsigned keyBits>
 class BloomFilter {
     WTF_MAKE_FAST_ALLOCATED;
 public:
-    static const size_t tableSize = 1 << keyBits;
+    static constexpr size_t tableSize = 1 << keyBits;
 
     BloomFilter();
 
     void add(unsigned hash);
     // For example SHA1::Digest.
@@ -59,12 +59,12 @@
     void add(const String& string) { add(string.impl()->hash()); }
     bool mayContain(const AtomString& string) const { return mayContain(string.impl()->existingHash()); }
     bool mayContain(const String& string) const { return mayContain(string.impl()->hash()); }
 
 private:
-    static const unsigned bitsPerPosition = 8 * sizeof(unsigned);
-    static const unsigned keyMask = (1 << keyBits) - 1;
+    static constexpr unsigned bitsPerPosition = 8 * sizeof(unsigned);
+    static constexpr unsigned keyMask = (1 << keyBits) - 1;
     static unsigned arrayIndex(unsigned key) { return key / bitsPerPosition; }
     static unsigned bitMask(unsigned key) { return 1 << (key % bitsPerPosition); }
     template <size_t hashSize> static std::pair<unsigned, unsigned> keysFromHash(const std::array<uint8_t, hashSize>&);
 
     bool isBitSet(unsigned key) const;
@@ -156,11 +156,11 @@
 // See http://en.wikipedia.org/wiki/Bloom_filter#Counting_filters
 template <unsigned keyBits>
 class CountingBloomFilter {
     WTF_MAKE_FAST_ALLOCATED;
 public:
-    static const size_t tableSize = 1 << keyBits;
+    static constexpr size_t tableSize = 1 << keyBits;
     static unsigned maximumCount() { return std::numeric_limits<uint8_t>::max(); }
 
     CountingBloomFilter();
 
     void add(unsigned hash);
@@ -180,18 +180,18 @@
     void remove(const String& string) { remove(string.impl()->hash()); }
 
     bool mayContain(const AtomString& string) const { return mayContain(string.impl()->existingHash()); }
     bool mayContain(const String& string) const { return mayContain(string.impl()->hash()); }
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
     // Slow.
     bool likelyEmpty() const;
     bool isClear() const;
 #endif
 
 private:
-    static const unsigned keyMask = (1 << keyBits) - 1;
+    static constexpr unsigned keyMask = (1 << keyBits) - 1;
 
     uint8_t& firstBucket(unsigned hash) { return m_buckets[hash & keyMask]; }
     uint8_t& secondBucket(unsigned hash) { return m_buckets[(hash >> 16) & keyMask]; }
     const uint8_t& firstBucket(unsigned hash) const { return m_buckets[hash & keyMask]; }
     const uint8_t& secondBucket(unsigned hash) const { return m_buckets[(hash >> 16) & keyMask]; }
@@ -234,11 +234,11 @@
 inline void CountingBloomFilter<keyBits>::clear()
 {
     m_buckets.fill(0);
 }
 
-#if !ASSERT_DISABLED
+#if ASSERT_ENABLED
 template <unsigned keyBits>
 bool CountingBloomFilter<keyBits>::likelyEmpty() const
 {
     for (auto& bucket : m_buckets) {
         if (bucket && bucket != maximumCount())
@@ -254,11 +254,11 @@
         if (bucket)
             return false;
     }
     return true;
 }
-#endif
+#endif // ASSERT_ENABLED
 
-}
+} // namespace WTF
 
 using WTF::BloomFilter;
 using WTF::CountingBloomFilter;

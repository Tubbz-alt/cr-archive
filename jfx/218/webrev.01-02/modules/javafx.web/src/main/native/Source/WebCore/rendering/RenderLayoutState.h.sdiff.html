<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayoutState.h</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="RenderLayoutState.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLineBreak.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>modules/javafx.web/src/main/native/Source/WebCore/rendering/RenderLayoutState.h</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 29 #include &quot;LayoutRect.h&quot;
 30 #include &lt;wtf/Noncopyable.h&gt;
 31 
 32 namespace WebCore {
 33 
 34 class RenderBlockFlow;
 35 class RenderBox;
 36 class RenderElement;
 37 class RenderFragmentedFlow;
 38 class RenderMultiColumnFlow;
 39 class RenderObject;
 40 
 41 class RenderLayoutState {
 42     WTF_MAKE_NONCOPYABLE(RenderLayoutState); WTF_MAKE_FAST_ALLOCATED;
 43 
 44 public:
 45     RenderLayoutState()
 46         : m_clipped(false)
 47         , m_isPaginated(false)
 48         , m_pageLogicalHeightChanged(false)
<span class="line-modified"> 49 #if !ASSERT_DISABLED</span>
 50         , m_layoutDeltaXSaturated(false)
 51         , m_layoutDeltaYSaturated(false)
 52 #endif
 53     {
 54     }
 55     RenderLayoutState(const FrameViewLayoutContext::LayoutStateStack&amp;, RenderBox&amp;, const LayoutSize&amp; offset, LayoutUnit pageHeight, bool pageHeightChanged);
 56     enum class IsPaginated { No, Yes };
 57     explicit RenderLayoutState(RenderElement&amp;, IsPaginated = IsPaginated::No);
 58 
 59     bool isPaginated() const { return m_isPaginated; }
 60 
 61     // The page logical offset is the object&#39;s offset from the top of the page in the page progression
 62     // direction (so an x-offset in vertical text and a y-offset for horizontal text).
 63     LayoutUnit pageLogicalOffset(RenderBox*, LayoutUnit childLogicalOffset) const;
 64 
 65     LayoutUnit pageLogicalHeight() const { return m_pageLogicalHeight; }
 66     bool pageLogicalHeightChanged() const { return m_pageLogicalHeightChanged; }
 67 
 68     RenderBlockFlow* lineGrid() const { return m_lineGrid.get(); }
 69     LayoutSize lineGridOffset() const { return m_lineGridOffset; }
 70     LayoutSize lineGridPaginationOrigin() const { return m_lineGridPaginationOrigin; }
 71 
 72     LayoutSize paintOffset() const { return m_paintOffset; }
 73     LayoutSize layoutOffset() const { return m_layoutOffset; }
 74 
 75     LayoutSize pageOffset() const { return m_pageOffset; }
 76 
 77     bool needsBlockDirectionLocationSetBeforeLayout() const { return m_lineGrid || (m_isPaginated &amp;&amp; m_pageLogicalHeight); }
 78 
<span class="line-modified"> 79 #ifndef NDEBUG</span>
 80     RenderElement* renderer() const { return m_renderer; }
 81 #endif
 82     LayoutRect clipRect() const { return m_clipRect; }
 83     bool isClipped() const { return m_clipped; }
 84 
 85     void addLayoutDelta(LayoutSize);
 86     LayoutSize layoutDelta() const { return m_layoutDelta; }
<span class="line-modified"> 87 #if !ASSERT_DISABLED</span>
 88     bool layoutDeltaMatches(LayoutSize) const;
 89 #endif
 90 
 91 private:
 92     void computeOffsets(const RenderLayoutState&amp; ancestor, RenderBox&amp;, LayoutSize offset);
 93     void computeClipRect(const RenderLayoutState&amp; ancestor, RenderBox&amp;);
 94     // FIXME: webkit.org/b/179440 these functions should be part of the pagination code/FrameViewLayoutContext.
 95     void computePaginationInformation(const FrameViewLayoutContext::LayoutStateStack&amp;, RenderBox&amp;, LayoutUnit pageLogicalHeight, bool pageLogicalHeightChanged);
 96     void propagateLineGridInfo(const RenderLayoutState&amp; ancestor, RenderBox&amp;);
 97     void establishLineGrid(const FrameViewLayoutContext::LayoutStateStack&amp;, RenderBlockFlow&amp;);
 98     void computeLineGridPaginationOrigin(const RenderMultiColumnFlow&amp;);
 99 
100     // Do not add anything apart from bitfields. See https://bugs.webkit.org/show_bug.cgi?id=100173
101     bool m_clipped : 1;
102     bool m_isPaginated : 1;
103     // If our page height has changed, this will force all blocks to relayout.
104     bool m_pageLogicalHeightChanged : 1;
<span class="line-modified">105 #if !ASSERT_DISABLED</span>
106     bool m_layoutDeltaXSaturated : 1;
107     bool m_layoutDeltaYSaturated : 1;
108 #endif
109     // The current line grid that we&#39;re snapping to and the offset of the start of the grid.
110     WeakPtr&lt;RenderBlockFlow&gt; m_lineGrid;
111 
112     // FIXME: Distinguish between the layout clip rect and the paint clip rect which may be larger,
113     // e.g., because of composited scrolling.
114     LayoutRect m_clipRect;
115 
116     // x/y offset from layout root. Includes in-flow positioning and scroll offsets.
117     LayoutSize m_paintOffset;
118     // x/y offset from layout root. Does not include in-flow positioning or scroll offsets.
119     LayoutSize m_layoutOffset;
120     // Transient offset from the final position of the object
121     // used to ensure that repaints happen in the correct place.
122     // This is a total delta accumulated from the root.
123     LayoutSize m_layoutDelta;
124 
125     // The current page height for the pagination model that encloses us.
126     LayoutUnit m_pageLogicalHeight;
127     // The offset of the start of the first page in the nearest enclosing pagination model.
128     LayoutSize m_pageOffset;
129     LayoutSize m_lineGridOffset;
130     LayoutSize m_lineGridPaginationOrigin;
<span class="line-modified">131 #ifndef NDEBUG</span>
132     RenderElement* m_renderer { nullptr };
133 #endif
134 };
135 
136 // Stack-based class to assist with LayoutState push/pop
137 class LayoutStateMaintainer {
138     WTF_MAKE_NONCOPYABLE(LayoutStateMaintainer);
139 public:
140     explicit LayoutStateMaintainer(RenderBox&amp;, LayoutSize offset, bool disableState = false, LayoutUnit pageHeight = 0_lu, bool pageHeightChanged = false);
141     ~LayoutStateMaintainer();
142 
143 private:
144     FrameViewLayoutContext&amp; m_context;
145     bool m_paintOffsetCacheIsDisabled { false };
146     bool m_didPushLayoutState { false };
147 };
148 
149 class SubtreeLayoutStateMaintainer {
150 public:
151     SubtreeLayoutStateMaintainer(RenderElement* subtreeLayoutRoot);
</pre>
</td>
<td>
<hr />
<pre>
 29 #include &quot;LayoutRect.h&quot;
 30 #include &lt;wtf/Noncopyable.h&gt;
 31 
 32 namespace WebCore {
 33 
 34 class RenderBlockFlow;
 35 class RenderBox;
 36 class RenderElement;
 37 class RenderFragmentedFlow;
 38 class RenderMultiColumnFlow;
 39 class RenderObject;
 40 
 41 class RenderLayoutState {
 42     WTF_MAKE_NONCOPYABLE(RenderLayoutState); WTF_MAKE_FAST_ALLOCATED;
 43 
 44 public:
 45     RenderLayoutState()
 46         : m_clipped(false)
 47         , m_isPaginated(false)
 48         , m_pageLogicalHeightChanged(false)
<span class="line-modified"> 49 #if ASSERT_ENABLED</span>
 50         , m_layoutDeltaXSaturated(false)
 51         , m_layoutDeltaYSaturated(false)
 52 #endif
 53     {
 54     }
 55     RenderLayoutState(const FrameViewLayoutContext::LayoutStateStack&amp;, RenderBox&amp;, const LayoutSize&amp; offset, LayoutUnit pageHeight, bool pageHeightChanged);
 56     enum class IsPaginated { No, Yes };
 57     explicit RenderLayoutState(RenderElement&amp;, IsPaginated = IsPaginated::No);
 58 
 59     bool isPaginated() const { return m_isPaginated; }
 60 
 61     // The page logical offset is the object&#39;s offset from the top of the page in the page progression
 62     // direction (so an x-offset in vertical text and a y-offset for horizontal text).
 63     LayoutUnit pageLogicalOffset(RenderBox*, LayoutUnit childLogicalOffset) const;
 64 
 65     LayoutUnit pageLogicalHeight() const { return m_pageLogicalHeight; }
 66     bool pageLogicalHeightChanged() const { return m_pageLogicalHeightChanged; }
 67 
 68     RenderBlockFlow* lineGrid() const { return m_lineGrid.get(); }
 69     LayoutSize lineGridOffset() const { return m_lineGridOffset; }
 70     LayoutSize lineGridPaginationOrigin() const { return m_lineGridPaginationOrigin; }
 71 
 72     LayoutSize paintOffset() const { return m_paintOffset; }
 73     LayoutSize layoutOffset() const { return m_layoutOffset; }
 74 
 75     LayoutSize pageOffset() const { return m_pageOffset; }
 76 
 77     bool needsBlockDirectionLocationSetBeforeLayout() const { return m_lineGrid || (m_isPaginated &amp;&amp; m_pageLogicalHeight); }
 78 
<span class="line-modified"> 79 #if ASSERT_ENABLED</span>
 80     RenderElement* renderer() const { return m_renderer; }
 81 #endif
 82     LayoutRect clipRect() const { return m_clipRect; }
 83     bool isClipped() const { return m_clipped; }
 84 
 85     void addLayoutDelta(LayoutSize);
 86     LayoutSize layoutDelta() const { return m_layoutDelta; }
<span class="line-modified"> 87 #if ASSERT_ENABLED</span>
 88     bool layoutDeltaMatches(LayoutSize) const;
 89 #endif
 90 
 91 private:
 92     void computeOffsets(const RenderLayoutState&amp; ancestor, RenderBox&amp;, LayoutSize offset);
 93     void computeClipRect(const RenderLayoutState&amp; ancestor, RenderBox&amp;);
 94     // FIXME: webkit.org/b/179440 these functions should be part of the pagination code/FrameViewLayoutContext.
 95     void computePaginationInformation(const FrameViewLayoutContext::LayoutStateStack&amp;, RenderBox&amp;, LayoutUnit pageLogicalHeight, bool pageLogicalHeightChanged);
 96     void propagateLineGridInfo(const RenderLayoutState&amp; ancestor, RenderBox&amp;);
 97     void establishLineGrid(const FrameViewLayoutContext::LayoutStateStack&amp;, RenderBlockFlow&amp;);
 98     void computeLineGridPaginationOrigin(const RenderMultiColumnFlow&amp;);
 99 
100     // Do not add anything apart from bitfields. See https://bugs.webkit.org/show_bug.cgi?id=100173
101     bool m_clipped : 1;
102     bool m_isPaginated : 1;
103     // If our page height has changed, this will force all blocks to relayout.
104     bool m_pageLogicalHeightChanged : 1;
<span class="line-modified">105 #if ASSERT_ENABLED</span>
106     bool m_layoutDeltaXSaturated : 1;
107     bool m_layoutDeltaYSaturated : 1;
108 #endif
109     // The current line grid that we&#39;re snapping to and the offset of the start of the grid.
110     WeakPtr&lt;RenderBlockFlow&gt; m_lineGrid;
111 
112     // FIXME: Distinguish between the layout clip rect and the paint clip rect which may be larger,
113     // e.g., because of composited scrolling.
114     LayoutRect m_clipRect;
115 
116     // x/y offset from layout root. Includes in-flow positioning and scroll offsets.
117     LayoutSize m_paintOffset;
118     // x/y offset from layout root. Does not include in-flow positioning or scroll offsets.
119     LayoutSize m_layoutOffset;
120     // Transient offset from the final position of the object
121     // used to ensure that repaints happen in the correct place.
122     // This is a total delta accumulated from the root.
123     LayoutSize m_layoutDelta;
124 
125     // The current page height for the pagination model that encloses us.
126     LayoutUnit m_pageLogicalHeight;
127     // The offset of the start of the first page in the nearest enclosing pagination model.
128     LayoutSize m_pageOffset;
129     LayoutSize m_lineGridOffset;
130     LayoutSize m_lineGridPaginationOrigin;
<span class="line-modified">131 #if ASSERT_ENABLED</span>
132     RenderElement* m_renderer { nullptr };
133 #endif
134 };
135 
136 // Stack-based class to assist with LayoutState push/pop
137 class LayoutStateMaintainer {
138     WTF_MAKE_NONCOPYABLE(LayoutStateMaintainer);
139 public:
140     explicit LayoutStateMaintainer(RenderBox&amp;, LayoutSize offset, bool disableState = false, LayoutUnit pageHeight = 0_lu, bool pageHeightChanged = false);
141     ~LayoutStateMaintainer();
142 
143 private:
144     FrameViewLayoutContext&amp; m_context;
145     bool m_paintOffsetCacheIsDisabled { false };
146     bool m_didPushLayoutState { false };
147 };
148 
149 class SubtreeLayoutStateMaintainer {
150 public:
151     SubtreeLayoutStateMaintainer(RenderElement* subtreeLayoutRoot);
</pre>
</td>
</tr>
</table>
<center><a href="RenderLayoutState.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="RenderLineBreak.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>